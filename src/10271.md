# [インデックス 10271] ファイルの概要

## コミット

**著者**: Ron Minnich <rminnich@gmail.com>  
**日付**: 2011年11月7日 11:42:13 -0500  
**コミットメッセージ**: gc: use HEADER_IO macro from gopack  
**コミットハッシュ**: 986ad31b2dad78d2238a426904fcf9fbf120d2c8  

## GitHub上でのコミットページへのリンク

https://github.com/golang/go/commit/986ad31b2dad78d2238a426904fcf9fbf120d2c8

## 元コミット内容

このコミットは、Go言語のgcコンパイラにおけるアーカイブファイルの読み取り処理の移植性を改善するものです。gopackツールで使用されているHEADER_IOマクロを導入することで、Plan 9の6cコンパイラで生成されたアーカイブヘッダーを他のシステムで読み取る際の問題を解決しています。

**変更サマリー**:
- `src/cmd/gc/lex.c`の`arsize`関数を修正
- 非移植的なアーカイブヘッダー読み取りコードを、移植性の高いHEADER_IOマクロを使用した実装に置き換え
- 構造体のポインタアクセスから値アクセスへの変更
- OSXでのビルドテストを含む全テストが通過

## 変更の背景

このコミットは、Go言語のクロスプラットフォーム対応における重要な移植性の問題を解決するために実装されました。具体的には以下の問題が発生していました：

1. **Plan 9との互換性問題**: Plan 9の6cコンパイラで生成されたアーカイブファイルを、他のシステム（LinuxやmacOSなど）で読み取る際に正しく処理されない問題が発生していました。

2. **アーキテクチャ依存の構造体パディング**: UNIXのar形式における`ar_hdr`構造体は、アーキテクチャごとに異なるパディングが適用されるため、構造体全体を一度に読み書きすると移植性の問題が発生していました。

3. **gopackツールとの統合**: gopackツールで既に実装されていた移植可能なアーカイブヘッダー読み取りマクロを、gcコンパイラでも使用する必要がありました。

## 前提知識の解説

### Go言語のgcコンパイラについて
Go言語の初期のコンパイラツールチェーンは、Plan 9のコンパイラツールチェーンを基盤として設計されていました。gcコンパイラは、Go言語のソースコードをオブジェクトファイルにコンパイルし、これらのオブジェクトファイルをアーカイブファイルにまとめる機能を持っています。

### Plan 9とGo言語の関係
Go言語は、Plan 9オペレーティングシステムの開発に携わったRob Pike、Ken Thompson、Robert Griesemerによって設計されました。そのため、Go言語の多くの設計思想とツールチェーンは、Plan 9の影響を強く受けています。

### UNIXアーカイブ形式（ar形式）
UNIXのar形式は、複数のオブジェクトファイルを1つのアーカイブファイルにまとめるために使用される標準的なファイル形式です。各ファイルはヘッダー情報とデータで構成され、ヘッダーには以下の情報が含まれます：

```c
struct ar_hdr {
    char name[16];    // ファイル名
    char date[12];    // 更新日時
    char uid[6];      // ユーザーID
    char gid[6];      // グループID
    char mode[8];     // ファイルモード
    char size[10];    // ファイルサイズ
    char fmag[2];     // マジックナンバー
};
```

### アーキテクチャ依存パディングの問題
異なるアーキテクチャ（32bit/64bit、リトルエンディアン/ビッグエンディアン）では、構造体のメンバー間に挿入されるパディングが異なります。そのため、構造体全体を一度に読み書きすると、アーキテクチャ間での互換性が失われます。

## 技術的詳細

### 修正前のコード
```c
static int
arsize(Biobuf *b, char *name)
{
    struct ar_hdr *a;

    if((a = Brdline(b, '\n')) == nil)
        return -1;
    if(Blinelen(b) != sizeof(struct ar_hdr))
        return -1;
    if(strncmp(a->name, name, strlen(name)) != 0)
        return -1;
    return atoi(a->size);
}
```

修正前のコードは、`Brdline`関数を使用して改行文字まで読み取り、それを`ar_hdr`構造体のポインタとして扱っていました。このアプローチには以下の問題がありました：

1. **構造体サイズの前提**: `Blinelen(b) != sizeof(struct ar_hdr)`の比較は、異なるアーキテクチャでは正しく動作しません。
2. **アライメントの問題**: ポインタキャストによるアクセスは、メモリアライメントの問題を引き起こす可能性があります。
3. **エンディアンネスの問題**: バイナリデータの解釈が、プラットフォーム間で一貫性がありません。

### 修正後のコード
```c
/*
 *	macro to portably read/write archive header.
 *	'cmd' is read/write/Bread/Bwrite, etc.
 */
#define	HEADER_IO(cmd, f, h)	cmd(f, h.name, sizeof(h.name)) != sizeof(h.name)\
			|| cmd(f, h.date, sizeof(h.date)) != sizeof(h.date)\
			|| cmd(f, h.uid, sizeof(h.uid)) != sizeof(h.uid)\
			|| cmd(f, h.gid, sizeof(h.gid)) != sizeof(h.gid)\
			|| cmd(f, h.mode, sizeof(h.mode)) != sizeof(h.mode)\
			|| cmd(f, h.size, sizeof(h.size)) != sizeof(h.size)\
			|| cmd(f, h.fmag, sizeof(h.fmag)) != sizeof(h.fmag)

static int
arsize(Biobuf *b, char *name)
{
    struct ar_hdr a;

    if (HEADER_IO(Bread, b, a))
        return -1;

    if(strncmp(a.name, name, strlen(name)) != 0)
        return -1;

    return atoi(a.size);
}
```

修正後のコードでは、以下の改善が行われています：

1. **フィールド単位でのIO**: HEADER_IOマクロは、構造体の各フィールドを個別に読み取るため、アーキテクチャ依存のパディングの影響を回避できます。
2. **値による構造体アクセス**: ポインタではなく値として構造体を宣言することで、メモリアライメントの問題を回避しています。
3. **エラーハンドリング**: 各フィールドの読み取りで失敗した場合の適切なエラーハンドリングを提供しています。

## コアとなるコードの変更箇所

### 1. HEADER_IOマクロの導入 (src/cmd/gc/lex.c:33-39)

```c
#define	HEADER_IO(cmd, f, h)	cmd(f, h.name, sizeof(h.name)) != sizeof(h.name)\
			|| cmd(f, h.date, sizeof(h.date)) != sizeof(h.date)\
			|| cmd(f, h.uid, sizeof(h.uid)) != sizeof(h.uid)\
			|| cmd(f, h.gid, sizeof(h.gid)) != sizeof(h.gid)\
			|| cmd(f, h.mode, sizeof(h.mode)) != sizeof(h.mode)\
			|| cmd(f, h.size, sizeof(h.size)) != sizeof(h.size)\
			|| cmd(f, h.fmag, sizeof(h.fmag)) != sizeof(h.fmag)
```

### 2. arsize関数の書き換え (src/cmd/gc/lex.c:41-58)

```c
static int
arsize(Biobuf *b, char *name)
{
    struct ar_hdr a;

    if (HEADER_IO(Bread, b, a))
        return -1;

    if(strncmp(a.name, name, strlen(name)) != 0)
        return -1;

    return atoi(a.size);
}
```

## コアとなるコードの解説

### HEADER_IOマクロの設計思想

HEADER_IOマクロは、Go言語のクロスプラットフォーム対応における重要な設計パターンを示しています：

1. **汎用性**: `cmd`パラメータにより、読み取り（Bread）と書き込み（Bwrite）の両方に対応できます。
2. **エラー伝播**: 各フィールドの読み取りで失敗した場合、論理OR演算子（||）により即座にエラーを返します。
3. **型安全性**: `sizeof(h.field)`を使用することで、フィールドサイズを動的に取得し、型の変更に対する保守性を向上させています。

### マクロの動作メカニズム

マクロは以下の手順で動作します：

1. **フィールド順次読み取り**: `ar_hdr`構造体の各フィールドを定義された順序で読み取ります。
2. **サイズ検証**: 読み取ったバイト数が期待されるフィールドサイズと一致するかを検証します。
3. **短絡評価**: 最初のフィールドで失敗した場合、以降のフィールドは評価されません。

### Plan 9の移植性哲学の実装

このコードは、Plan 9の移植性に関する哲学を具現化しています：

1. **#ifdefの回避**: アーキテクチャ固有の条件分岐を避け、統一的なアプローチを採用。
2. **定義済みフォーマット**: バイナリデータを特定のバイトオーダーで読み書きし、プラットフォーム間の一貫性を保証。
3. **フィールド単位アクセス**: 構造体全体ではなく、フィールド単位でのアクセスにより、パディングの問題を回避。

## 関連リンク

- [Go言語のPlan 9サポート](https://go.dev/wiki/Plan9)
- [UNIX ar形式の仕様](https://en.wikipedia.org/wiki/Ar_(Unix))
- [Plan 9のar形式ドキュメント](http://man.cat-v.org/plan_9/6/ar)
- [Go言語のソースコードからのビルド](https://go.dev/doc/install/source)

## 参考にした情報源リンク

- [Go言語のクロスプラットフォーム対応に関する情報](https://go.dev/wiki/Plan9)
- [UNIX ar形式の移植性に関する技術文書](https://stackoverflow.com/questions/66588751/c-check-if-archive-file-is-truncated-with-struct-ar-hdr-ar-h)
- [Plan 9のファイル形式とポータビリティ](https://www.lysator.liu.se/c/plan9c.html)
- [Go言語の初期のコンパイラツールチェーン](https://github.com/golang/go/blob/master/src/cmd/go/internal/work/gc.go)