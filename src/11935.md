# [インデックス 11935] ファイルの概要

## コミット

```
commit aef23cc49e745e619c10bd8e4f9d4555de3a9c5c
Author: Ian Lance Taylor <iant@golang.org>
Date:   Wed Feb 15 07:39:46 2012 -0800

    test: add new test of indirect type references
    
    Similar to bug190, but without recursive reference. Crashed
    gccgo.
    
    R=golang-dev, rsc
    CC=golang-dev
    https://golang.org/cl/5672053
```

## GitHub上でのコミットページへのリンク

[https://github.com/golang/go/commit/aef23cc49e745e619c10bd8e4f9d4555de3a9c5c](https://github.com/golang/go/commit/aef23cc49e745e619c10bd8e4f9d4555de3a9c5c)

## 元コミット内容

このコミットは、`gccgo`コンパイラが特定の「間接的な型参照」を処理する際にクラッシュするバグを再現するための新しいテストケースを追加します。このテストは、以前の`bug190`に関連していますが、再帰的な参照を含まない点が異なります。

## 変更の背景

Go言語のコンパイラである`gccgo`において、型情報の処理に関するバグが存在していました。具体的には、ある型が別の型を間接的に参照している場合（例えば、ポインタ、スライス、マップ、チャネル、インターフェース、関数シグネチャなどを介して）、`gccgo`がその参照先の型のサイズを計算する前に、そのサイズが既知であると誤って仮定してしまう問題がありました。この誤った仮定が原因で、コンパイル時にクラッシュが発生していました。

このコミットで追加されたテストケースは、このような間接的な型参照の様々なパターンを網羅し、`gccgo`が正しく型サイズを計算できることを検証することを目的としています。特に、`bug190`という既存のバグ報告に関連していることが示唆されており、そのバグが再帰的な型参照に焦点を当てていたのに対し、この新しいテストは再帰的ではない間接参照に焦点を当てることで、より広範な問題の特定と修正に貢献しています。

## 前提知識の解説

### Go言語の型システム

Go言語は静的型付け言語であり、変数は使用される前に型が宣言されます。Goの型システムは、構造体（struct）、配列（array）、スライス（slice）、マップ（map）、ポインタ（pointer）、チャネル（channel）、インターフェース（interface）、関数（function）など、多様な複合型をサポートしています。

### 間接的な型参照 (Indirect Type References)

間接的な型参照とは、ある型が直接的に別の型をフィールドとして持つのではなく、ポインタ、スライス、マップ、チャネル、インターフェース、または関数シグネチャなどを介して別の型を参照する状況を指します。

例:
- **ポインタ**: `*T` (Tへのポインタ)
- **スライス**: `[]T` (Tのスライス)
- **マップ**: `map[K]V` (キーK、値Vのマップ)
- **チャネル**: `chan T` (Tを送受信するチャネル)
- **インターフェース**: インターフェースのメソッドが引数や戻り値として特定の型`T`を使用する場合。
- **関数シグネチャ**: 関数の引数や戻り値として特定の型`T`を使用する場合。

これらの場合、`T`のサイズやレイアウトは、それを間接的に参照する型のサイズやレイアウトを決定する上で重要になります。

### 再帰的な型参照 (Recursive Type References)

再帰的な型参照とは、型が自分自身を直接的または間接的に参照する状況を指します。これは、リンクリストやツリー構造のようなデータ構造を定義する際によく見られます。

例:
```go
type Node struct {
    Value int
    Next *Node // 自分自身へのポインタ
}
```

### `gccgo`コンパイラ

`gccgo`は、GCC（GNU Compiler Collection）のフロントエンドとして実装されたGo言語コンパイラです。Go言語のソースコードをGCCの中間表現に変換し、その後GCCのバックエンドがターゲットマシンコードを生成します。`gccgo`は、Go言語の公式コンパイラである`gc`とは異なる実装であり、それぞれ異なる最適化やバグ特性を持つことがあります。

### 型のサイズ計算とコンパイル

コンパイラは、プログラムの実行時にメモリを適切に割り当てるために、各型のメモリ上のサイズを正確に計算する必要があります。複合型の場合、そのサイズは構成要素となる型のサイズに依存します。間接的な型参照や再帰的な型参照が存在する場合、コンパイラは型の依存関係を解決し、循環参照がないか、または正しく処理できるかを判断しながら、型のサイズを決定する必要があります。このプロセスが正しく行われないと、メモリレイアウトの誤りやコンパイラのクラッシュにつながります。

## 技術的詳細

このコミットで追加された`test/fixedbugs/bug417.go`ファイルは、`gccgo`が間接的な型参照を処理する際のバグを浮き彫りにするために設計されています。このテストケースは、`S1`と`S2`という2つの構造体を定義し、それぞれが`S3`という別の構造体を様々な形で間接的に参照しています。

`S3`は非常に単純な構造体で、`int`型のフィールド`I`を1つだけ持ちます。これは、`S3`のサイズが明確であることを保証するためです。

`S1`構造体は、`S3`を以下の形で間接的に参照しています。

- `p *[1]S3`: `S3`の配列へのポインタ。
- `s [][1]S3`: `S3`の配列のスライス。
- `m map[int][1]S3`: `int`をキーとし、`S3`の配列を値とするマップ。
- `c chan [1]S3`: `S3`の配列を送受信するチャネル。
- `i interface { f([1]S3) [1]S3 }`: `S3`の配列を引数にとり、`S3`の配列を返すメソッドを持つインターフェース。
- `f func([1]S3) [1]S3`: `S3`の配列を引数にとり、`S3`の配列を返す関数。

`S2`構造体は、`S3`を匿名構造体（`struct { F S3 }`）の形で間接的に参照しています。これは、`S1`と同様に、ポインタ、スライス、マップ、チャネル、インターフェース、関数シグネチャを介して行われます。

このテストの核心は、`gccgo`がこれらの複雑な間接参照パスを辿って`S3`のサイズを正しく解決できるかどうかを検証することにあります。コミットメッセージにあるように、`gccgo`は「型のサイズが計算される前に既知であると仮定した」ためにクラッシュしていました。これは、コンパイラが型の依存関係グラフを構築し、トポロジカルソートのような方法でサイズを決定する際に、誤った順序で処理を進めてしまったことを示唆しています。

このテストケースは、再帰的な参照（例えば、`type Node struct { Next *Node }`のような）を含んでいない点が重要です。これは、`bug190`が再帰的な参照に焦点を当てていたのに対し、このテストは再帰的ではないが複雑な間接参照のシナリオをカバーすることで、より広範な型解決のバグを特定しようとしていることを意味します。

## コアとなるコードの変更箇所

このコミットでは、`test/fixedbugs/bug417.go`という新しいテストファイルが追加されています。

```diff
diff --git a/test/fixedbugs/bug417.go b/test/fixedbugs/bug417.go
new file mode 100644
index 0000000000..8cd3f5eb92
--- /dev/null
+++ b/test/fixedbugs/bug417.go
@@ -0,0 +1,32 @@
+// $G $D/$F.go || echo BUG: should compile
+//
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+//
+// Some indirect uses of types crashed gccgo, because it assumed that
+// the size of the type was known before it had been computed.
+//
+package p
+
+type S1 struct {
+	p *[1]S3
+	s [][1]S3
+	m map[int][1]S3
+	c chan [1]S3
+	i interface { f([1]S3) [1]S3 }
+	f func([1]S3) [1]S3
+}
+
+type S2 struct {
+	p *struct { F S3 }
+	s []struct { F S3 }
+	m map[int]struct { F S3 }
+	c chan struct { F S3 }
+	i interface { f(struct { F S3 }) struct { F S3 } }
+	f func(struct { F S3 } ) struct { F S3 }
+}
+
+type S3 struct {
+	I int
+}
```

## コアとなるコードの解説

追加された`bug417.go`ファイルは、Go言語のテストフレームワークの一部として、特定のコンパイルエラーを検出するために使用されます。ファイルの先頭にある`// $G $D/$F.go || echo BUG: should compile`という行は、Goコンパイラ（`$G`）でこのファイルをコンパイルし、もしコンパイルが失敗した場合は「BUG: should compile」というメッセージを出力するというテスト指示です。これは、このファイルがエラーなくコンパイルされるべきであることを示しています。

ファイル内で定義されている主要な構造体は以下の通りです。

1.  **`type S3 struct { I int }`**:
    これは最も基本的な構造体で、`int`型のフィールド`I`を1つだけ持ちます。この構造体のサイズは明確であり、他の構造体がこれを間接的に参照する際の基準となります。

2.  **`type S1 struct { ... }`**:
    この構造体は、`S3`を直接ではなく、様々なGoの組み込み型を介して間接的に参照しています。
    -   `p *[1]S3`: `S3`の要素を1つ持つ配列へのポインタ。
    -   `s [][1]S3`: `S3`の要素を1つ持つ配列のスライス。
    -   `m map[int][1]S3`: キーが`int`、値が`S3`の要素を1つ持つ配列であるマップ。
    -   `c chan [1]S3`: `S3`の要素を1つ持つ配列を送受信するチャネル。
    -   `i interface { f([1]S3) [1]S3 }`: `f`というメソッドを持つインターフェース。このメソッドは`S3`の配列を引数にとり、`S3`の配列を返します。
    -   `f func([1]S3) [1]S3`: `S3`の配列を引数にとり、`S3`の配列を返す関数型。

3.  **`type S2 struct { ... }`**:
    この構造体も`S3`を間接的に参照していますが、`S1`とは異なり、匿名構造体`struct { F S3 }`を介して参照しています。これにより、`S3`がさらに一重の抽象化レイヤーを挟んで参照されるシナリオをテストします。
    -   `p *struct { F S3 }`: `S3`をフィールド`F`として持つ匿名構造体へのポインタ。
    -   `s []struct { F S3 }`: `S3`をフィールド`F`として持つ匿名構造体のスライス。
    -   `m map[int]struct { F S3 }`: キーが`int`、値が`S3`をフィールド`F`として持つ匿名構造体であるマップ。
    -   `c chan struct { F S3 }`: `S3`をフィールド`F`として持つ匿名構造体を送受信するチャネル。
    -   `i interface { f(struct { F S3 }) struct { F S3 } }`: `f`というメソッドを持つインターフェース。このメソッドは`S3`をフィールド`F`として持つ匿名構造体を引数にとり、同じ型の匿名構造体を返します。
    -   `f func(struct { F S3 } ) struct { F S3 }`: `S3`をフィールド`F`として持つ匿名構造体を引数にとり、同じ型の匿名構造体を返す関数型。

これらの構造体定義は、`gccgo`が型の依存関係を正しく解決し、メモリレイアウトを計算できることを確認するための包括的なテストケースを提供します。特に、ポインタ、スライス、マップ、チャネル、インターフェース、関数といったGoの多様な型構成要素が、間接的な型参照の解決にどのように影響するかを検証しています。このテストがクラッシュするという事実は、`gccgo`の型システムまたはメモリレイアウト計算ロジックに、これらの複雑な間接参照を扱う上での欠陥があったことを明確に示しています。

## 関連リンク

-   Go言語の公式ドキュメント: [https://golang.org/doc/](https://golang.org/doc/)
-   Go言語の型システムに関するドキュメント: [https://go.dev/ref/spec#Types](https://go.dev/ref/spec#Types)
-   GCCGoプロジェクトページ: [https://gcc.gnu.org/onlinedocs/gccgo/](https://gcc.gnu.org/onlinedocs/gccgo/)
-   Go言語のバグトラッカー (Go Issues): [https://go.dev/issue/](https://go.dev/issue/)

## 参考にした情報源リンク

-   Go言語の型システムに関する一般的な情報源
-   GCCGoコンパイラの動作に関する情報源
-   Go言語のバグ報告やコミット履歴（特に`bug190`に関する情報）
-   Go言語のテストファイルの慣習と構文に関する情報
-   `golang.org/cl/5672053` (Go Code Reviewの変更リスト)
    -   [https://go.dev/cl/5672053](https://go.dev/cl/5672053) (このコミットに対応するGo Code Reviewのページ)
    -   このページには、コミットに関する議論や、関連するバグ報告へのリンクが含まれている可能性があります。
    -   特に、`bug190`に関する詳細情報や、このバグがどのように修正されたかについての議論が参考になります。
    -   [https://go.dev/issue/190](https://go.dev/issue/190) (Go Issue 190: `cmd/gc: crash on recursive type`)
        -   このIssueは、再帰的な型参照が`gc`コンパイラをクラッシュさせる問題について議論しており、今回のコミットが「bug190に似ているが再帰的ではない」と述べている背景を理解するのに役立ちます。
        -   このIssueの解決策や議論は、コンパイラが型サイズを計算する際の課題を理解する上で重要です。
-   Go言語のテストディレクトリの構造と慣習に関する情報。
-   Go言語のコンパイラが型情報をどのように処理するかに関する技術記事やドキュメント。
-   Go言語のポインタ、スライス、マップ、チャネル、インターフェース、関数の各型の詳細な動作に関する情報。```markdown
# [インデックス 11935] ファイルの概要

## コミット

```
commit aef23cc49e745e619c10bd8e4f9d4555de3a9c5c
Author: Ian Lance Taylor <iant@golang.org>
Date:   Wed Feb 15 07:39:46 2012 -0800

    test: add new test of indirect type references
    
    Similar to bug190, but without recursive reference. Crashed
    gccgo.

    R=golang-dev, rsc
    CC=golang-dev
    https://golang.org/cl/5672053
```

## GitHub上でのコミットページへのリンク

[https://github.com/golang/go/commit/aef23cc49e745e619c10bd8e4f9d4555de3a9c5c](https://github.com/golang/go/commit/aef23cc49e745e619c10bd8e4f9d4555de3a9c5c)

## 元コミット内容

このコミットは、`gccgo`コンパイラが特定の「間接的な型参照」を処理する際にクラッシュするバグを再現するための新しいテストケースを追加します。このテストは、以前の`bug190`に関連していますが、再帰的な参照を含まない点が異なります。

## 変更の背景

Go言語のコンパイラである`gccgo`において、型情報の処理に関するバグが存在していました。具体的には、ある型が別の型を間接的に参照している場合（例えば、ポインタ、スライス、マップ、チャネル、インターフェース、関数シグネチャなどを介して）、`gccgo`がその参照先の型のサイズを計算する前に、そのサイズが既知であると誤って仮定してしまう問題がありました。この誤った仮定が原因で、コンパイル時にクラッシュが発生していました。

このコミットで追加されたテストケースは、このような間接的な型参照の様々なパターンを網羅し、`gccgo`が正しく型サイズを計算できることを検証することを目的としています。特に、`bug190`という既存のバグ報告に関連していることが示唆されており、そのバグが再帰的な型参照に焦点を当てていたのに対し、この新しいテストは再帰的ではない間接参照に焦点を当てることで、より広範な問題の特定と修正に貢献しています。

## 前提知識の解説

### Go言語の型システム

Go言語は静的型付け言語であり、変数は使用される前に型が宣言されます。Goの型システムは、構造体（struct）、配列（array）、スライス（slice）、マップ（map）、ポインタ（pointer）、チャネル（channel）、インターフェース（interface）、関数（function）など、多様な複合型をサポートしています。

### 間接的な型参照 (Indirect Type References)

間接的な型参照とは、ある型が直接的に別の型をフィールドとして持つのではなく、ポインタ、スライス、マップ、チャネル、インターフェース、または関数シグネチャなどを介して別の型を参照する状況を指します。

例:
- **ポインタ**: `*T` (Tへのポインタ)
- **スライス**: `[]T` (Tのスライス)
- **マップ**: `map[K]V` (キーK、値Vのマップ)
- **チャネル**: `chan T` (Tを送受信するチャネル)
- **インターフェース**: インターフェースのメソッドが引数や戻り値として特定の型`T`を使用する場合。
- **関数シグネチャ**: 関数の引数や戻り値として特定の型`T`を使用する場合。

これらの場合、`T`のサイズやレイアウトは、それを間接的に参照する型のサイズやレイアウトを決定する上で重要になります。

### 再帰的な型参照 (Recursive Type References)

再帰的な型参照とは、型が自分自身を直接的または間接的に参照する状況を指します。これは、リンクリストやツリー構造のようなデータ構造を定義する際によく見られます。

例:
```go
type Node struct {
    Value int
    Next *Node // 自分自身へのポインタ
}
```

### `gccgo`コンパイラ

`gccgo`は、GCC（GNU Compiler Collection）のフロントエンドとして実装されたGo言語コンパイラです。Go言語のソースコードをGCCの中間表現に変換し、その後GCCのバックエンドがターゲットマシンコードを生成します。`gccgo`は、Go言語の公式コンパイラである`gc`とは異なる実装であり、それぞれ異なる最適化やバグ特性を持つことがあります。

### 型のサイズ計算とコンパイル

コンパイラは、プログラムの実行時にメモリを適切に割り当てるために、各型のメモリ上のサイズを正確に計算する必要があります。複合型の場合、そのサイズは構成要素となる型のサイズに依存します。間接的な型参照や再帰的な型参照が存在する場合、コンパイラは型の依存関係を解決し、循環参照がないか、または正しく処理できるかを判断しながら、型のサイズを決定する必要があります。このプロセスが正しく行われないと、メモリレイアウトの誤りやコンパイラのクラッシュにつながります。

## 技術的詳細

このコミットで追加された`test/fixedbugs/bug417.go`ファイルは、`gccgo`が間接的な型参照を処理する際のバグを浮き彫りにするために設計されています。このテストケースは、`S1`と`S2`という2つの構造体を定義し、それぞれが`S3`という別の構造体を様々な形で間接的に参照しています。

`S3`は非常に単純な構造体で、`int`型のフィールド`I`を1つだけ持ちます。これは、`S3`のサイズが明確であることを保証するためです。

`S1`構造体は、`S3`を以下の形で間接的に参照しています。

- `p *[1]S3`: `S3`の配列へのポインタ。
- `s [][1]S3`: `S3`の配列のスライス。
- `m map[int][1]S3`: `int`をキーとし、`S3`の配列を値とするマップ。
- `c chan [1]S3`: `S3`の配列を送受信するチャネル。
- `i interface { f([1]S3) [1]S3 }`: `S3`の配列を引数にとり、`S3`の配列を返すメソッドを持つインターフェース。
- `f func([1]S3) [1]S3`: `S3`の配列を引数にとり、`S3`の配列を返す関数。

`S2`構造体は、`S3`を匿名構造体（`struct { F S3 }`）の形で間接的に参照しています。これは、`S1`と同様に、ポインタ、スライス、マップ、チャネル、インターフェース、関数シグネチャを介して行われます。

このテストの核心は、`gccgo`がこれらの複雑な間接参照パスを辿って`S3`のサイズを正しく解決できるかどうかを検証することにあります。コミットメッセージにあるように、`gccgo`は「型のサイズが計算される前に既知であると仮定した」ためにクラッシュしていました。これは、コンパイラが型の依存関係グラフを構築し、トポロジカルソートのような方法でサイズを決定する際に、誤った順序で処理を進めてしまったことを示唆しています。

このテストケースは、再帰的な参照（例えば、`type Node struct { Next *Node }`のような）を含んでいない点が重要です。これは、`bug190`が再帰的な参照に焦点を当てていたのに対し、このテストは再帰的ではないが複雑な間接参照のシナリオをカバーすることで、より広範な型解決のバグを特定しようとしていることを意味します。

## コアとなるコードの変更箇所

このコミットでは、`test/fixedbugs/bug417.go`という新しいテストファイルが追加されています。

```diff
diff --git a/test/fixedbugs/bug417.go b/test/fixedbugs/bug417.go
new file mode 100644
index 0000000000..8cd3f5eb92
--- /dev/null
+++ b/test/fixedbugs/bug417.go
@@ -0,0 +1,32 @@
+// $G $D/$F.go || echo BUG: should compile
+//
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+//
+// Some indirect uses of types crashed gccgo, because it assumed that
+// the size of the type was known before it had been computed.
+//
+package p
+
+type S1 struct {
+	p *[1]S3
+	s [][1]S3
+	m map[int][1]S3
+	c chan [1]S3
+	i interface { f([1]S3) [1]S3 }
+	f func([1]S3) [1]S3
+}
+
+type S2 struct {
+	p *struct { F S3 }
+	s []struct { F S3 }
+	m map[int]struct { F S3 }
+	c chan struct { F S3 }
+	i interface { f(struct { F S3 }) struct { F S3 } }
+	f func(struct { F S3 } ) struct { F S3 }
+}
+
+type S3 struct {
+	I int
+}
```

## コアとなるコードの解説

追加された`bug417.go`ファイルは、Go言語のテストフレームワークの一部として、特定のコンパイルエラーを検出するために使用されます。ファイルの先頭にある`// $G $D/$F.go || echo BUG: should compile`という行は、Goコンパイラ（`$G`）でこのファイルをコンパイルし、もしコンパイルが失敗した場合は「BUG: should compile」というメッセージを出力するというテスト指示です。これは、このファイルがエラーなくコンパイルされるべきであることを示しています。

ファイル内で定義されている主要な構造体は以下の通りです。

1.  **`type S3 struct { I int }`**:
    これは最も基本的な構造体で、`int`型のフィールド`I`を1つだけ持ちます。この構造体のサイズは明確であり、他の構造体がこれを間接的に参照する際の基準となります。

2.  **`type S1 struct { ... }`**:
    この構造体は、`S3`を直接ではなく、様々なGoの組み込み型を介して間接的に参照しています。
    -   `p *[1]S3`: `S3`の要素を1つ持つ配列へのポインタ。
    -   `s [][1]S3`: `S3`の要素を1つ持つ配列のスライス。
    -   `m map[int][1]S3`: キーが`int`、値が`S3`の要素を1つ持つ配列であるマップ。
    -   `c chan [1]S3`: `S3`の要素を1つ持つ配列を送受信するチャネル。
    -   `i interface { f([1]S3) [1]S3 }`: `f`というメソッドを持つインターフェース。このメソッドは`S3`の配列を引数にとり、`S3`の配列を返します。
    -   `f func([1]S3) [1]S3`: `S3`の配列を引数にとり、`S3`の配列を返す関数型。

3.  **`type S2 struct { ... }`**:
    この構造体も`S3`を間接的に参照していますが、`S1`とは異なり、匿名構造体`struct { F S3 }`を介して参照しています。これにより、`S3`がさらに一重の抽象化レイヤーを挟んで参照されるシナリオをテストします。
    -   `p *struct { F S3 }`: `S3`をフィールド`F`として持つ匿名構造体へのポインタ。
    -   `s []struct { F S3 }`: `S3`をフィールド`F`として持つ匿名構造体のスライス。
    -   `m map[int]struct { F S3 }`: キーが`int`、値が`S3`をフィールド`F`として持つ匿名構造体であるマップ。
    -   `c chan struct { F S3 }`: `S3`をフィールド`F`として持つ匿名構造体を送受信するチャネル。
    -   `i interface { f(struct { F S3 }) struct { F S3 } }`: `f`というメソッドを持つインターフェース。このメソッドは`S3`をフィールド`F`として持つ匿名構造体を引数にとり、同じ型の匿名構造体を返します。
    -   `f func(struct { F S3 } ) struct { F S3 }`: `S3`をフィールド`F`として持つ匿名構造体を引数にとり、同じ型の匿名構造体を返す関数型。

これらの構造体定義は、`gccgo`が型の依存関係を正しく解決し、メモリレイアウトを計算できることを確認するための包括的なテストケースを提供します。特に、ポインタ、スライス、マップ、チャネル、インターフェース、関数といったGoの多様な型構成要素が、間接的な型参照の解決にどのように影響するかを検証しています。このテストがクラッシュするという事実は、`gccgo`の型システムまたはメモリレイアウト計算ロジックに、これらの複雑な間接参照を扱う上での欠陥があったことを明確に示しています。

## 関連リンク

-   Go言語の公式ドキュメント: [https://golang.org/doc/](https://golang.org/doc/)
-   Go言語の型システムに関するドキュメント: [https://go.dev/ref/spec#Types](https://go.dev/ref/spec#Types)
-   GCCGoプロジェクトページ: [https://gcc.gnu.org/onlinedocs/gccgo/](https://gcc.gnu.org/onlinedocs/gccgo/)
-   Go言語のバグトラッカー (Go Issues): [https://go.dev/issue/](https://go.dev/issue/)

## 参考にした情報源リンク

-   Go言語の型システムに関する一般的な情報源
-   GCCGoコンパイラの動作に関する情報源
-   Go言語のバグ報告やコミット履歴（特に`bug190`に関する情報）
-   Go言語のテストファイルの慣習と構文に関する情報
-   `golang.org/cl/5672053` (Go Code Reviewの変更リスト)
    -   [https://go.dev/cl/5672053](https://go.dev/cl/5672053) (このコミットに対応するGo Code Reviewのページ)
    -   このページには、コミットに関する議論や、関連するバグ報告へのリンクが含まれている可能性があります。
    -   特に、`bug190`に関する詳細情報や、このバグがどのように修正されたかについての議論が参考になります。
    -   [https://go.dev/issue/190](https://go.dev/issue/190) (Go Issue 190: `cmd/gc: crash on recursive type`)
        -   このIssueは、再帰的な型参照が`gc`コンパイラをクラッシュさせる問題について議論しており、今回のコミットが「bug190に似ているが再帰的ではない」と述べている背景を理解するのに役立ちます。
        -   このIssueの解決策や議論は、コンパイラが型サイズを計算する際の課題を理解する上で重要です。
-   Go言語のテストディレクトリの構造と慣習に関する情報。
-   Go言語のコンパイラが型情報をどのように処理するかに関する技術記事やドキュメント。
-   Go言語のポインタ、スライス、マップ、チャネル、インターフェース、関数の各型の詳細な動作に関する情報。
```
