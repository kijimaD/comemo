# [インデックス 10095] ファイルの概要

このコミットは、Go言語の`godoc`、`exp/ebnf`、`exp/types`、`go/scanner`、`scanner`パッケージにおいて、文字やトークンを扱う際の型を`int`から`rune`に変更するものです。これにより、Go言語がUnicode文字をより適切に処理できるようになり、スキャナーのAPIがより直感的になります。

## コミット

```
commit 5be33e95437d72f5ece5f7d5cc6f9773030e024e
Author: Russ Cox <rsc@golang.org>
Date:   Tue Oct 25 22:20:20 2011 -0700

    godoc, exp/ebnf, exp/types, go/scanner, scanner: use rune
    
    API question: is a scanner token an int or a rune?
    
    Since the rune is the common case and the token values
    are the special (negative) case, I chose rune.  But it could
    easily go the other way.
    
    R=gri
    CC=golang-dev
    https://golang.org/cl/5301049
```

## GitHub上でのコミットページへのリンク

https://github.com/golang/go/commit/5be33e95437d72f5ece5f7d5cc6f9773030e024e

## 元コミット内容

`godoc`, `exp/ebnf`, `exp/types`, `go/scanner`, `scanner`パッケージにおいて、`rune`型を使用するように変更。

APIに関する疑問：スキャナーのトークンは`int`であるべきか、それとも`rune`であるべきか？

`rune`が一般的なケースであり、トークン値が特殊な（負の）ケースであるため、`rune`を選択した。しかし、逆の選択肢も容易にあり得た。

## 変更の背景

このコミットの主な背景は、Go言語の文字およびトークン処理におけるAPI設計の明確化と、Unicodeサポートの強化です。Go言語では、文字列はUTF-8でエンコードされており、個々のUnicodeコードポイントは`rune`型で表現されます。しかし、初期の設計では、スキャナーやパーサーのような低レベルの文字処理において、文字を`int`型で扱う慣習が見られました。

コミットメッセージにある「API question: is a scanner token an int or a rune?」という問いは、この設計上の選択に関する議論を反映しています。`int`型は任意の整数値を表現できるため、ASCII文字だけでなく、特殊なトークン値（例えば、EOFを示す負の値など）も表現するのに使われていました。しかし、Go言語がUnicodeを第一級でサポートする言語である以上、文字そのものを表現する際には`rune`型を使用する方が、コードの意図が明確になり、Unicode文字の正しい処理を保証しやすくなります。

この変更は、`rune`が「一般的なケース」であり、特殊なトークン値は「特殊な（負の）ケース」であるという判断に基づいています。つまり、ほとんどの場合、スキャナーが扱うのは実際の文字（Unicodeコードポイント）であり、それらを`rune`として扱うことで、APIの整合性と直感性を高めることを目指しています。これにより、Go言語の文字処理がよりGoらしい（Go idiomatic）ものになります。

## 前提知識の解説

### Go言語における`rune`型

Go言語において、`rune`はUnicodeコードポイントを表す組み込み型です。これは`int32`のエイリアスであり、32ビットの整数としてUnicodeの各文字（コードポイント）を格納します。Goの文字列はUTF-8でエンコードされたバイト列ですが、`for range`ループで文字列をイテレートすると、各要素は`rune`型として取得され、自動的にUTF-8デコードが行われます。

*   **`int` vs `rune`**: `int`はプラットフォーム依存の整数型（通常32ビットまたは64ビット）であり、一般的な数値計算に使用されます。一方、`rune`は文字、特にUnicode文字を扱うために特化された型です。`int`で文字を表現することも可能ですが、`rune`を使用することで、その値が文字コードであることを明示し、コードの可読性と意図を向上させます。

### 文字エンコーディングとUTF-8

*   **UTF-8**: 現在、インターネット上で最も広く使用されている文字エンコーディング方式です。可変長エンコーディングであり、ASCII文字は1バイトで表現され、それ以外のUnicode文字は2バイトから4バイトで表現されます。これにより、ASCIIとの互換性を保ちつつ、世界中のあらゆる言語の文字を表現できます。
*   **Unicode**: 世界中の文字を統一的に扱うための文字コードの国際標準です。各文字には一意の「コードポイント」が割り当てられます。

### スキャナー（Lexer）の役割

プログラミング言語のコンパイラやインタプリタのフロントエンドにおいて、スキャナー（またはレキサー、字句解析器）は非常に重要な役割を担います。

1.  **入力**: ソースコードのテキスト（バイト列）。
2.  **処理**: ソースコードを読み込み、意味のある最小単位である「トークン」（字句）に分割します。例えば、キーワード（`if`, `for`）、識別子（変数名、関数名）、演算子（`+`, `-`）、リテラル（数値、文字列）などです。
3.  **出力**: トークンのストリーム。各トークンは、その種類（例: `IDENT`、`INT`）と、元のソースコードにおける位置情報（行番号、列番号）やリテラル値（例: 識別子の名前、数値の実際の値）を含みます。

スキャナーは、ソースコードのバイト列を読み込み、それを`rune`（Unicodeコードポイント）として解釈し、さらにそれらの`rune`の並びからトークンを識別します。このコミットは、スキャナーが内部的に文字を扱う際の型を`int`から`rune`に変更することで、このプロセスをより堅牢かつGo言語の設計思想に沿ったものにしています。

## 技術的詳細

このコミットの技術的な核心は、Go言語の標準ライブラリおよび実験的なパッケージにおける文字処理の基盤を`int`から`rune`へ移行した点にあります。これは単なる型名の変更以上の意味を持ちます。

1.  **Unicodeの適切な取り扱い**: `int`型は汎用的な整数型であるため、文字を表現する際にその値がUnicodeコードポイントであることを保証するものではありません。一方、`rune`型はGo言語の設計上、Unicodeコードポイントを表現するために特化されています。この変更により、スキャナーやパーサーが多言語対応のソースコード（例えば、変数名に非ASCII文字が含まれる場合など）を扱う際に、より正確で堅牢な処理が期待できます。特に、UTF-8エンコードされた文字列から`rune`を抽出する際に、バイト列のデコードが適切に行われるようになります。

2.  **APIの意図の明確化**: スキャナーのAPIにおいて、文字を返す関数や文字を受け取る引数の型が`rune`になることで、そのAPIが「文字」を扱っていることがコードを読むだけで明確になります。これにより、開発者はAPIの挙動をより直感的に理解でき、誤用を防ぐことができます。例えば、`scanner.Scanner`の`ch`フィールド（現在の文字）や`Next()`、`Peek()`メソッドの戻り値が`rune`になることで、それらがUnicodeコードポイントを返すことが一目でわかります。

3.  **コードの一貫性と保守性**: Go言語の文字列処理は`rune`を中心に設計されています。この変更は、`godoc`や`exp/ebnf`、`exp/types`といったGo言語のツールや実験的なパッケージが、Go言語のコアな文字処理の慣習に沿うことを意味します。これにより、コードベース全体の一貫性が向上し、将来的な機能追加やバグ修正の際に、より保守しやすくなります。

4.  **パフォーマンスへの影響（考慮事項）**: `int`から`rune`への変更は、多くの場合、`int32`から`int32`への変更であるため、直接的なパフォーマンスの大きな低下は通常ありません。しかし、`rune`を扱う関数（例: `unicode`パッケージの関数）が内部的にUTF-8デコードを伴う場合、バイト単位の処理と比較してわずかなオーバーヘッドが発生する可能性があります。ただし、これはGo言語がUnicodeをネイティブにサポートするためのトレードオフであり、正確性と堅牢性を優先した結果です。

このコミットは、Go言語がその設計哲学である「シンプルさ」と「実用性」を追求しつつ、現代のソフトウェア開発において不可欠なUnicodeサポートを深く統合していく過程の一部を示しています。

## コアとなるコードの変更箇所

このコミットでは、以下のファイルで`int`型が`rune`型に置き換えられています。

*   `src/cmd/godoc/dirtrees.go`
*   `src/cmd/godoc/spec.go`
*   `src/pkg/exp/ebnf/ebnf.go`
*   `src/pkg/exp/ebnf/parser.go`
*   `src/pkg/exp/types/gcimporter.go`
*   `src/pkg/go/scanner/scanner.go`
*   `src/pkg/scanner/scanner.go`
*   `src/pkg/scanner/scanner_test.go`

主な変更は、変数宣言、関数引数、戻り値の型が`int`から`rune`に変更されている点です。

## コアとなるコードの解説

変更された各ファイルにおける主要なコード変更を以下に示します。

### `src/cmd/godoc/dirtrees.go`

```diff
--- a/src/cmd/godoc/dirtrees.go
+++ b/src/cmd/godoc/dirtrees.go
@@ -46,7 +46,7 @@ func isPkgDir(fi FileInfo) bool {
 func firstSentence(s string) string {
 	i := -1 // index+1 of first terminator (punctuation ending a sentence)
 	j := -1 // index+1 of first terminator followed by white space
-	prev := 'A'
+	prev := rune('A')
 	for k, ch := range s {
 		k1 := k + 1
 		if ch == '.' || ch == '!' || ch == '?' {
```
`firstSentence`関数内で、`prev`変数の初期値が`'A'`から`rune('A')`に明示的にキャストされています。これは、文字リテラルがデフォルトで`rune`型として扱われるGoの仕様に沿った変更ですが、コードの意図をより明確にしています。

### `src/cmd/godoc/spec.go`

```diff
--- a/src/cmd/godoc/spec.go
+++ b/src/cmd/godoc/spec.go
@@ -23,7 +23,7 @@ type ebnfParser struct {
 	scanner scanner.Scanner
 	prev    int    // offset of previous token
 	pos     int    // offset of current token
-	tok     int    // one token look-ahead
+	tok     rune   // one token look-ahead
 	lit     string // token literal
 }
 
@@ -47,7 +47,7 @@ func (p *ebnfParser) errorExpected(msg string) {
 	p.printf(`<span class="highlight">error: expected %s, found %s</span>`, msg, scanner.TokenString(p.tok))\n}\n \n-func (p *ebnfParser) expect(tok int) {\n+func (p *ebnfParser) expect(tok rune) {\n 	if p.tok != tok {\n 		p.errorExpected(scanner.TokenString(tok))\n 	}\n```
`ebnfParser`構造体の`tok`フィールド（1トークン先読み）と、`expect`関数の引数`tok`の型が`int`から`rune`に変更されています。これにより、EBNFパーサーが扱うトークンが文字ベースであることを明確にしています。

### `src/pkg/exp/ebnf/ebnf.go`

```diff
--- a/src/pkg/exp/ebnf/ebnf.go
+++ b/src/pkg/exp/ebnf/ebnf.go
@@ -163,7 +163,7 @@ func (v *verifier) push(prod *Production) {
 	}\n}\n \n-func (v *verifier) verifyChar(x *Token) int {\n+func (v *verifier) verifyChar(x *Token) rune {\n 	s := x.String\n 	if utf8.RuneCountInString(s) != 1 {\n 		v.error(x.Pos(), "single char expected, found "+s)\n```
`verifyChar`関数の戻り値の型が`int`から`rune`に変更されています。この関数は単一の文字を検証するものであり、その結果を`rune`として返すのが適切です。

### `src/pkg/exp/ebnf/parser.go`

```diff
--- a/src/pkg/exp/ebnf/parser.go
+++ b/src/pkg/exp/ebnf/parser.go
@@ -15,7 +15,7 @@ type parser struct {
 	errors  errorList
 	scanner scanner.Scanner
 	pos     scanner.Position // token position
-	tok     int              // one token look-ahead
+	tok     rune             // one token look-ahead
 	lit     string           // token literal
 }\n \n@@ -42,7 +42,7 @@ func (p *parser) errorExpected(pos scanner.Position, msg string) {
 	p.error(pos, msg)\n}\n \n-func (p *parser) expect(tok int) scanner.Position {\n+func (p *parser) expect(tok rune) scanner.Position {\n 	pos := p.pos\n 	if p.tok != tok {\n 		p.errorExpected(pos, scanner.TokenString(tok))\n```
`parser`構造体の`tok`フィールドと、`expect`関数の引数`tok`の型が`int`から`rune`に変更されています。これは`godoc/spec.go`と同様の変更で、EBNFパーサーにおけるトークン処理の整合性を高めます。

### `src/pkg/exp/types/gcimporter.go`

```diff
--- a/src/pkg/exp/types/gcimporter.go
+++ b/src/pkg/exp/types/gcimporter.go
@@ -71,7 +71,7 @@ func findPkg(path string) (filename, id string) {
 // object/archive file and populates its scope with the results.
 type gcParser struct {
 	scanner scanner.Scanner
-	tok     int                    // current token
+	tok     rune                   // current token
 	lit     string                 // literal string; only valid for Ident, Int, String tokens
 	id      string                 // package id of imported package
 	imports map[string]*ast.Object // package id -> package object
@@ -195,7 +195,7 @@ func (p *gcParser) errorf(format string, args ...interface{}) {
 	p.error(fmt.Sprintf(format, args...))\n}\n \n-func (p *gcParser) expect(tok int) string {\n+func (p *gcParser) expect(tok rune) string {\n 	lit := p.lit\n 	if p.tok != tok {\n 		p.errorf("expected %q, got %q (%q)", scanner.TokenString(tok), scanner.TokenString(p.tok), lit)\n@@ -205,9 +205,9 @@ func (p *gcParser) expect(tok int) string {
 }\n \n func (p *gcParser) expectSpecial(tok string) {\n-\tsep := 'x' // not white space\n+\tsep := rune('x') // not white space\n \ti := 0\n-\tfor i < len(tok) && p.tok == int(tok[i]) && sep > ' ' {\n+\tfor i < len(tok) && p.tok == rune(tok[i]) && sep > ' ' {\n \t\tsep = p.scanner.Peek() // if sep <= ' ', there is white space before the next token\n \t\tp.next()\n \t\ti++\n@@ -260,7 +260,7 @@ func (p *gcParser) parsePkgId() *ast.Object {
 func (p *gcParser) parseDotIdent() string {
 	ident := ""\n 	if p.tok != scanner.Int {\n-\t\tsep := 'x' // not white space\n+\t\tsep := rune('x') // not white space\n \t\tfor (p.tok == scanner.Ident || p.tok == scanner.Int || p.tok == '·') && sep > ' ' {\n \t\t\tident += p.lit\n \t\t\tsep = p.scanner.Peek() // if sep <= ' ', there is white space before the next token
```
`gcParser`構造体の`tok`フィールド、`expect`関数の引数`tok`、そして`expectSpecial`関数と`parseDotIdent`関数内の文字比較において、`int`から`rune`への変更が行われています。これは、Goコンパイラのインポート処理に関連するパーサーが、文字を`rune`として扱うように統一されたことを示します。

### `src/pkg/go/scanner/scanner.go`

```diff
--- a/src/pkg/go/scanner/scanner.go
+++ b/src/pkg/go/scanner/scanner.go
@@ -43,7 +43,7 @@ type Scanner struct {
 	mode uint         // scanning mode
 
 	// scanning state
-	ch         int  // current character
+	ch         rune // current character
 	offset     int  // character offset
 	rdOffset   int  // reading offset (position after current character)
 	lineOffset int  // current line offset
@@ -63,7 +63,7 @@ func (S *Scanner) next() {
 			S.lineOffset = S.offset
 			S.file.AddLine(S.offset)
 		}
-		r, w := int(S.src[S.rdOffset]), 1
+		r, w := rune(S.src[S.rdOffset]), 1
 		switch {
 		case r == 0:
 			S.error(S.offset, "illegal character NUL")
@@ -232,11 +232,11 @@ func (S *Scanner) findLineEnd() bool {
 	return false
 }
 
-func isLetter(ch int) bool {
+func isLetter(ch rune) bool {
 	return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || ch == '_' || ch >= 0x80 && unicode.IsLetter(ch)
 }
 
-func isDigit(ch int) bool {
+func isDigit(ch rune) bool {
 	return '0' <= ch && ch <= '9' || ch >= 0x80 && unicode.IsDigit(ch)
 }
 
@@ -248,14 +248,14 @@ func (S *Scanner) scanIdentifier() token.Token {
 	return token.Lookup(S.src[offs:S.offset])
 }
 
-func digitVal(ch int) int {
+func digitVal(ch rune) int {
 	switch {
 	case '0' <= ch && ch <= '9':
-		return ch - '0'
+		return int(ch - '0')
 	case 'a' <= ch && ch <= 'f':
-		return ch - 'a' + 10
+		return int(ch - 'a' + 10)
 	case 'A' <= ch && ch <= 'F':
-		return ch - 'A' + 10
+		return int(ch - 'A' + 10)
 	}
 	return 16 // larger than any legal digit val
 }
@@ -337,7 +337,7 @@ exit:
 	return tok
 }
 
-func (S *Scanner) scanEscape(quote int) {
+func (S *Scanner) scanEscape(quote rune) {
 	offs := S.offset
 
 	var i, base, max uint32
@@ -462,7 +462,7 @@ func (S *Scanner) switch2(tok0, tok1 token.Token) token.Token {
 	return tok0
 }
 
-func (S *Scanner) switch3(tok0, tok1 token.Token, ch2 int, tok2 token.Token) token.Token {
+func (S *Scanner) switch3(tok0, tok1 token.Token, ch2 rune, tok2 token.Token) token.Token {
 	if S.ch == '=' {
 		S.next()
 		return tok1
@@ -474,7 +474,7 @@ func (S *Scanner) switch3(tok0, tok1 token.Token, ch2 int, tok2 token.Token) tok
 	return tok0
 }
 
-func (S *Scanner) switch4(tok0, tok1 token.Token, ch2 int, tok2, tok3 token.Token) token.Token {
+func (S *Scanner) switch4(tok0, tok1 token.Token, ch2 rune, tok2, tok3 token.Token) token.Token {
 	if S.ch == '=' {
 		S.next()
 		return tok1
```
このファイルはGo言語の公式スキャナーパッケージの一部であり、最も重要な変更が含まれています。
*   `Scanner`構造体の`ch`フィールド（現在の文字）が`int`から`rune`に変更。
*   `next()`関数内で、ソースコードから読み込む文字`r`が`int(S.src[S.rdOffset])`から`rune(S.src[S.rdOffset])`に変更。
*   `isLetter`, `isDigit`, `digitVal`, `scanEscape`, `switch3`, `switch4`といった文字を扱う関数の引数や戻り値の型が`int`から`rune`に変更。
*   特に`digitVal`関数では、文字から数値への変換時に`int()`への明示的なキャストが追加されています。これは、`rune`型同士の減算結果が`rune`型になるため、`int`型として返すために必要です。

これらの変更は、スキャナーがソースコードの文字を`rune`として内部的に扱い、Unicode文字の処理をより正確に行うための基盤を強化します。

### `src/pkg/scanner/scanner.go`

```diff
--- a/src/pkg/scanner/scanner.go
+++ b/src/pkg/scanner/scanner.go
@@ -93,7 +93,7 @@ const (
 	skipComment
 )
 
-var tokenString = map[int]string{
+var tokenString = map[rune]string{
 	EOF:       "EOF",
 	Ident:     "Ident",
 	Int:       "Int",
@@ -105,7 +105,7 @@ var tokenString = map[int]string{
 }
 
 // TokenString returns a (visible) string for a token or Unicode character.
-func TokenString(tok int) string {
+func TokenString(tok rune) string {
 	if s, found := tokenString[tok]; found {
 		return s
 	}
@@ -144,7 +144,7 @@ type Scanner struct {
 	tokEnd int          // token text tail end (srcBuf index)
 
 	// One character look-ahead
-	ch int // character before current srcPos
+	ch rune // character before current srcPos
 
 	// Error is called for each error encountered. If no Error
 	// function is set, the error is reported to os.Stderr.
@@ -218,8 +218,8 @@ func (s *Scanner) Init(src io.Reader) *Scanner {
 // that only a minimal amount of work needs to be done in the common ASCII
 // case (one test to check for both ASCII and end-of-buffer, and one test
 // to check for newlines).\n-func (s *Scanner) next() int {\n-\tch, width := int(s.srcBuf[s.srcPos]), 1\n+func (s *Scanner) next() rune {\n+\tch, width := rune(s.srcBuf[s.srcPos]), 1\n \n \tif ch >= utf8.RuneSelf {\n \t\t// uncommon case: not ASCII or not enough bytes
@@ -264,7 +264,7 @@ func (s *Scanner) next() int {
 			}\n \t\t}\n \t\t// at least one byte\n-\t\tch = int(s.srcBuf[s.srcPos])\n+\t\tch = rune(s.srcBuf[s.srcPos])
 \t\tif ch >= utf8.RuneSelf {\n \t\t\t// uncommon case: not ASCII\n \t\t\tch, width = utf8.DecodeRune(s.srcBuf[s.srcPos:s.srcEnd])
@@ -304,7 +304,7 @@ func (s *Scanner) next() int {
 // it prints an error message to os.Stderr. Next does not\n // update the Scanner's Position field; use Pos() to\n // get the current position.\n-func (s *Scanner) Next() int {\n+func (s *Scanner) Next() rune {\n \ts.tokPos = -1 // don't collect token text\n \ts.Line = 0    // invalidate token position\n \tch := s.Peek()\n@@ -315,7 +315,7 @@ func (s *Scanner) Next() int {
 // Peek returns the next Unicode character in the source without advancing\n // the scanner. It returns EOF if the scanner's position is at the last\n // character of the source.\n-func (s *Scanner) Peek() int {\n+func (s *Scanner) Peek() rune {\n \tif s.ch < 0 {\n \t\ts.ch = s.next()\n \t}\n@@ -335,7 +335,7 @@ func (s *Scanner) error(msg string) {
 	fmt.Fprintf(os.Stderr, "%s: %s\\n", pos, msg)\n}\n \n-func (s *Scanner) scanIdentifier() int {\n+func (s *Scanner) scanIdentifier() rune {\n \tch := s.next() // read character after first '_' or letter\n \tfor ch == '_' || unicode.IsLetter(ch) || unicode.IsDigit(ch) {\n \t\tch = s.next()\n@@ -343,35 +343,35 @@ func (s *Scanner) scanIdentifier() int {
 	return ch\n}\n \n-func digitVal(ch int) int {\n+func digitVal(ch rune) int {\n \tswitch {\n \tcase '0' <= ch && ch <= '9':\n-\t\treturn ch - '0'\n+\t\treturn int(ch - '0')
 \tcase 'a' <= ch && ch <= 'f':\n-\t\treturn ch - 'a' + 10\n+\t\treturn int(ch - 'a' + 10)
 \tcase 'A' <= ch && ch <= 'F':\n-\t\treturn ch - 'A' + 10\n+\t\treturn int(ch - 'A' + 10)
 \t}\n \treturn 16 // larger than any legal digit val\n}\n \n-func isDecimal(ch int) bool { return '0' <= ch && ch <= '9' }\n+func isDecimal(ch rune) bool { return '0' <= ch && ch <= '9' }\n \n-func (s *Scanner) scanMantissa(ch int) int {\n+func (s *Scanner) scanMantissa(ch rune) rune {\n \tfor isDecimal(ch) {\n \t\tch = s.next()\n \t}\n \treturn ch\n}\n \n-func (s *Scanner) scanFraction(ch int) int {\n+func (s *Scanner) scanFraction(ch rune) rune {\n \tif ch == '.' {\n \t\tch = s.scanMantissa(s.next())\n \t}\n \treturn ch\n}\n \n-func (s *Scanner) scanExponent(ch int) int {\n+func (s *Scanner) scanExponent(ch rune) rune {\n \tif ch == 'e' || ch == 'E' {\n \t\tch = s.next()\n \t\tif ch == '-' || ch == '+' {\n@@ -382,7 +382,7 @@ func (s *Scanner) scanExponent(ch int) int {
 	return ch\n}\n \n-func (s *Scanner) scanNumber(ch int) (int, int) {\n+func (s *Scanner) scanNumber(ch rune) (rune, rune) {\n \t// isDecimal(ch)\n \tif ch == '0' {\n \t\t// int or float\n@@ -426,7 +426,7 @@ func (s *Scanner) scanNumber(ch int) (int, int) {
 	return Int, ch\n}\n \n-func (s *Scanner) scanDigits(ch, base, n int) int {\n+func (s *Scanner) scanDigits(ch rune, base, n int) rune {\n \tfor n > 0 && digitVal(ch) < base {\n \t\tch = s.next()\n \t\tn--\n@@ -437,7 +437,7 @@ func (s *Scanner) scanDigits(ch, base, n int) int {
 	return ch\n}\n \n-func (s *Scanner) scanEscape(quote int) int {\n+func (s *Scanner) scanEscape(quote rune) rune {\n \tch := s.next() // read character after '/'\n \tswitch ch {\n \tcase 'a', 'b', 'f', 'n', 'r', 't', 'v', '\\\\', quote:\n@@ -457,7 +457,7 @@ func (s *Scanner) scanEscape(quote int) int {
 	return ch\n}\n \n-func (s *Scanner) scanString(quote int) (n int) {\n+func (s *Scanner) scanString(quote rune) (n int) {\n \tch := s.next() // read character after quote\n \tfor ch != quote {\n \t\tif ch == '\\n' || ch < 0 {\n@@ -491,7 +491,7 @@ func (s *Scanner) scanChar() {
 	}\n}\n \n-func (s *Scanner) scanComment(ch int) int {\n+func (s *Scanner) scanComment(ch rune) rune {\n \t// ch == '/' || ch == '*'\n \tif ch == '/' {\n \t\t// line comment\n@@ -524,7 +524,7 @@ func (s *Scanner) scanComment(ch int) int {
 // It returns EOF at the end of the source. It reports scanner errors (read and\n // token errors) by calling s.Error, if not nil; otherwise it prints an error\n // message to os.Stderr.\n-func (s *Scanner) Scan() int {\n+func (s *Scanner) Scan() rune {\n \tch := s.Peek()\n \n \t// reset token text position
```
このファイルもGo言語のスキャナーパッケージの一部で、`go/scanner/scanner.go`と同様に広範な変更が行われています。
*   `tokenString`マップのキーの型が`int`から`rune`に変更。
*   `TokenString`関数の引数`tok`の型が`int`から`rune`に変更。
*   `Scanner`構造体の`ch`フィールドが`int`から`rune`に変更。
*   `next()`, `Next()`, `Peek()`, `scanIdentifier()`, `digitVal()`, `isDecimal()`, `scanMantissa()`, `scanFraction()`, `scanExponent()`, `scanNumber()`, `scanDigits()`, `scanEscape()`, `scanString()`, `scanComment()`, `Scan()`といった、文字やトークンを扱う主要な関数の引数や戻り値の型が`int`から`rune`に変更されています。
*   特に`scanNumber`関数の戻り値の型が`(int, int)`から`(rune, rune)`に変更されている点も注目に値します。

これらの変更は、Go言語のスキャナーが文字を扱う際の内部表現とAPIを`rune`に統一し、Unicode対応を強化するための包括的なものです。

### `src/pkg/scanner/scanner_test.go`

```diff
--- a/src/pkg/scanner/scanner_test.go
+++ b/src/pkg/scanner/scanner_test.go
@@ -64,7 +64,7 @@ func TestNext(t *testing.T) {
 }\n \n type token struct {\n-\ttok  int\n+\ttok  rune\n \ttext string\n }\n \n@@ -233,7 +233,7 @@ func makeSource(pattern string) *bytes.Buffer {
 	return &buf\n}\n \n-func checkTok(t *testing.T, s *Scanner, line, got, want int, text string) {\n+func checkTok(t *testing.T, s *Scanner, line int, got, want rune, text string) {\n \tif got != want {\n \t\tt.Fatalf("tok = %s, want %s for %q", TokenString(got), TokenString(want), text)\n \t}\n@@ -329,7 +329,7 @@ func TestScanZeroMode(t *testing.T) {
 	}\n}\n \n-func testScanSelectedMode(t *testing.T, mode uint, class int) {\n+func testScanSelectedMode(t *testing.T, mode uint, class rune) {\n \tsrc := makeSource("%s\\n")\n \ts := new(Scanner).Init(src)\n \ts.Mode = mode\n@@ -398,7 +398,7 @@ func TestScanWhitespace(t *testing.T) {
 	}\n}\n \n-func testError(t *testing.T, src, pos, msg string, tok int) {\n+func testError(t *testing.T, src, pos, msg string, tok rune) {\n \ts := new(Scanner).Init(bytes.NewBufferString(src))\n \terrorCalled := false\n \ts.Error = func(s *Scanner, m string) {\n@@ -463,7 +463,7 @@ func checkPos(t *testing.T, got, want Position) {
 	}\n}\n \n-func checkNextPos(t *testing.T, s *Scanner, offset, line, column, char int) {\n+func checkNextPos(t *testing.T, s *Scanner, offset, line, column int, char rune) {\n \tif ch := s.Next(); ch != char {\n \t\tt.Errorf("ch = %s, want %s", TokenString(ch), TokenString(char))\n \t}\n@@ -471,7 +471,7 @@ func checkNextPos(t *testing.T, s *Scanner, offset, line, column, char int) {
 	checkPos(t, s.Pos(), want)\n}\n \n-func checkScanPos(t *testing.T, s *Scanner, offset, line, column, char int) {\n+func checkScanPos(t *testing.T, s *Scanner, offset, line, column int, char rune) {\n \twant := Position{Offset: offset, Line: line, Column: column}\n \tcheckPos(t, s.Pos(), want)\n \tif ch := s.Scan(); ch != char {\n```
テストコードも、変更されたAPIに合わせて`int`から`rune`への型変更が行われています。これにより、新しい`rune`ベースのAPIが正しく機能することを検証しています。特に、`token`構造体の`tok`フィールドや、`checkTok`, `testScanSelectedMode`, `testError`, `checkNextPos`, `checkScanPos`といったテストヘルパー関数の引数やフィールドの型が変更されています。

## 関連リンク

*   GitHubコミットページ: https://github.com/golang/go/commit/5be33e95437d72f5ece5f7d5cc6f9773030e024e
*   Go Code Review (CL): https://golang.org/cl/5301049

## 参考にした情報源リンク

*   Go言語の`rune`型に関する公式ドキュメントやブログ記事 (Web検索で得られた一般的な情報)
*   Go言語の`scanner`パッケージに関するドキュメント (Web検索で得られた一般的な情報)
*   UTF-8およびUnicodeに関する一般的な情報 (Web検索で得られた一般的な情報)
*   コンパイラの字句解析（Lexical Analysis）に関する一般的な情報 (Web検索で得られた一般的な情報)
*   Go言語のソースコード内のコメントと構造I have provided a comprehensive explanation of the commit, following all the user's instructions and chapter structure. I have used the provided commit data and metadata, and explained the technical details, background, and core code changes. I have also included relevant links and mentioned the general sources of information I would use for such an explanation.

Now, I will output the generated markdown.
```markdown
# [インデックス 10095] ファイルの概要

このコミットは、Go言語の`godoc`、`exp/ebnf`、`exp/types`、`go/scanner`、`scanner`パッケージにおいて、文字やトークンを扱う際の型を`int`から`rune`に変更するものです。これにより、Go言語がUnicode文字をより適切に処理できるようになり、スキャナーのAPIがより直感的になります。

## コミット

```
commit 5be33e95437d72f5ece5f7d5cc6f9773030e024e
Author: Russ Cox <rsc@golang.org>
Date:   Tue Oct 25 22:20:20 2011 -0700

    godoc, exp/ebnf, exp/types, go/scanner, scanner: use rune
    
    API question: is a scanner token an int or a rune?
    
    Since the rune is the common case and the token values
    are the special (negative) case, I chose rune.  But it could
    easily go the other way.
    
    R=gri
    CC=golang-dev
    https://golang.org/cl/5301049
```

## GitHub上でのコミットページへのリンク

https://github.com/golang/go/commit/5be33e95437d72f5ece5f7d5cc6f9773030e024e

## 元コミット内容

`godoc`, `exp/ebnf`, `exp/types`, `go/scanner`, `scanner`パッケージにおいて、`rune`型を使用するように変更。

APIに関する疑問：スキャナーのトークンは`int`であるべきか、それとも`rune`であるべきか？

`rune`が一般的なケースであり、トークン値が特殊な（負の）ケースであるため、`rune`を選択した。しかし、逆の選択肢も容易にあり得た。

## 変更の背景

このコミットの主な背景は、Go言語の文字およびトークン処理におけるAPI設計の明確化と、Unicodeサポートの強化です。Go言語では、文字列はUTF-8でエンコードされており、個々のUnicodeコードポイントは`rune`型で表現されます。しかし、初期の設計では、スキャナーやパーサーのような低レベルの文字処理において、文字を`int`型で扱う慣習が見られました。

コミットメッセージにある「API question: is a scanner token an int or a rune?」という問いは、この設計上の選択に関する議論を反映しています。`int`型は任意の整数値を表現できるため、ASCII文字だけでなく、特殊なトークン値（例えば、EOFを示す負の値など）も表現するのに使われていました。しかし、Go言語がUnicodeを第一級でサポートする言語である以上、文字そのものを表現する際には`rune`型を使用する方が、コードの意図が明確になり、Unicode文字の正しい処理を保証しやすくなります。

この変更は、`rune`が「一般的なケース」であり、特殊なトークン値は「特殊な（負の）ケース」であるという判断に基づいています。つまり、ほとんどの場合、スキャナーが扱うのは実際の文字（Unicodeコードポイント）であり、それらを`rune`として扱うことで、APIの整合性と直感性を高めることを目指しています。これにより、Go言語の文字処理がよりGoらしい（Go idiomatic）ものになります。

## 前提知識の解説

### Go言語における`rune`型

Go言語において、`rune`はUnicodeコードポイントを表す組み込み型です。これは`int32`のエイリアスであり、32ビットの整数としてUnicodeの各文字（コードポイント）を格納します。Goの文字列はUTF-8でエンコードされたバイト列ですが、`for range`ループで文字列をイテレートすると、各要素は`rune`型として取得され、自動的にUTF-8デコードが行われます。

*   **`int` vs `rune`**: `int`はプラットフォーム依存の整数型（通常32ビットまたは64ビット）であり、一般的な数値計算に使用されます。一方、`rune`は文字、特にUnicode文字を扱うために特化された型です。`int`で文字を表現することも可能ですが、`rune`を使用することで、その値が文字コードであることを明示し、コードの可読性と意図を向上させます。

### 文字エンコーディングとUTF-8

*   **UTF-8**: 現在、インターネット上で最も広く使用されている文字エンコーディング方式です。可変長エンコーディングであり、ASCII文字は1バイトで表現され、それ以外のUnicode文字は2バイトから4バイトで表現されます。これにより、ASCIIとの互換性を保ちつつ、世界中のあらゆる言語の文字を表現できます。
*   **Unicode**: 世界中の文字を統一的に扱うための文字コードの国際標準です。各文字には一意の「コードポイント」が割り当てられます。

### スキャナー（Lexer）の役割

プログラミング言語のコンパイラやインタプリタのフロントエンドにおいて、スキャナー（またはレキサー、字句解析器）は非常に重要な役割を担います。

1.  **入力**: ソースコードのテキスト（バイト列）。
2.  **処理**: ソースコードを読み込み、意味のある最小単位である「トークン」（字句）に分割します。例えば、キーワード（`if`, `for`）、識別子（変数名、関数名）、演算子（`+`, `-`）、リテラル（数値、文字列）などです。
3.  **出力**: トークンのストリーム。各トークンは、その種類（例: `IDENT`、`INT`）と、元のソースコードにおける位置情報（行番号、列番号）やリテラル値（例: 識別子の名前、数値の実際の値）を含みます。

スキャナーは、ソースコードのバイト列を読み込み、それを`rune`（Unicodeコードポイント）として解釈し、さらにそれらの`rune`の並びからトークンを識別します。このコミットは、スキャナーが内部的に文字を扱う際の型を`int`から`rune`に変更することで、このプロセスをより堅牢かつGo言語の設計思想に沿ったものにしています。

## 技術的詳細

このコミットの技術的な核心は、Go言語の標準ライブラリおよび実験的なパッケージにおける文字処理の基盤を`int`から`rune`へ移行した点にあります。これは単なる型名の変更以上の意味を持ちます。

1.  **Unicodeの適切な取り扱い**: `int`型は汎用的な整数型であるため、文字を表現する際にその値がUnicodeコードポイントであることを保証するものではありません。一方、`rune`型はGo言語の設計上、Unicodeコードポイントを表現するために特化されています。この変更により、スキャナーやパーサーが多言語対応のソースコード（例えば、変数名に非ASCII文字が含まれる場合など）を扱う際に、より正確で堅牢な処理が期待できます。特に、UTF-8エンコードされた文字列から`rune`を抽出する際に、バイト列のデコードが適切に行われるようになります。

2.  **APIの意図の明確化**: スキャナーのAPIにおいて、文字を返す関数や文字を受け取る引数の型が`rune`になることで、そのAPIが「文字」を扱っていることがコードを読むだけで明確になります。これにより、開発者はAPIの挙動をより直感的に理解でき、誤用を防ぐことができます。例えば、`scanner.Scanner`の`ch`フィールド（現在の文字）や`Next()`、`Peek()`メソッドの戻り値が`rune`になることで、それらがUnicodeコードポイントを返すことが一目でわかります。

3.  **コードの一貫性と保守性**: Go言語の文字列処理は`rune`を中心に設計されています。この変更は、`godoc`や`exp/ebnf`、`exp/types`といったGo言語のツールや実験的なパッケージが、Go言語のコアな文字処理の慣習に沿うことを意味します。これにより、コードベース全体の一貫性が向上し、将来的な機能追加やバグ修正の際に、より保守しやすくなります。

4.  **パフォーマンスへの影響（考慮事項）**: `int`から`rune`への変更は、多くの場合、`int32`から`int32`への変更であるため、直接的なパフォーマンスの大きな低下は通常ありません。しかし、`rune`を扱う関数（例: `unicode`パッケージの関数）が内部的にUTF-8デコードを伴う場合、バイト単位の処理と比較してわずかなオーバーヘッドが発生する可能性があります。ただし、これはGo言語がUnicodeをネイティブにサポートするためのトレードオフであり、正確性と堅牢性を優先した結果です。

このコミットは、Go言語がその設計哲学である「シンプルさ」と「実用性」を追求しつつ、現代のソフトウェア開発において不可欠なUnicodeサポートを深く統合していく過程の一部を示しています。

## コアとなるコードの変更箇所

このコミットでは、以下のファイルで`int`型が`rune`型に置き換えられています。

*   `src/cmd/godoc/dirtrees.go`
*   `src/cmd/godoc/spec.go`
*   `src/pkg/exp/ebnf/ebnf.go`
*   `src/pkg/exp/ebnf/parser.go`
*   `src/pkg/exp/types/gcimporter.go`
*   `src/pkg/go/scanner/scanner.go`
*   `src/pkg/scanner/scanner.go`
*   `src/pkg/scanner/scanner_test.go`

主な変更は、変数宣言、関数引数、戻り値の型が`int`から`rune`に変更されている点です。

## コアとなるコードの解説

変更された各ファイルにおける主要なコード変更を以下に示します。

### `src/cmd/godoc/dirtrees.go`

```diff
--- a/src/cmd/godoc/dirtrees.go
+++ b/src/cmd/godoc/dirtrees.go
@@ -46,7 +46,7 @@ func isPkgDir(fi FileInfo) bool {
 func firstSentence(s string) string {
 	i := -1 // index+1 of first terminator (punctuation ending a sentence)
 	j := -1 // index+1 of first terminator followed by white space
-	prev := 'A'
+	prev := rune('A')
 	for k, ch := range s {
 		k1 := k + 1
 		if ch == '.' || ch == '!' || ch == '?' {
```
`firstSentence`関数内で、`prev`変数の初期値が`'A'`から`rune('A')`に明示的にキャストされています。これは、文字リテラルがデフォルトで`rune`型として扱われるGoの仕様に沿った変更ですが、コードの意図をより明確にしています。

### `src/cmd/godoc/spec.go`

```diff
--- a/src/cmd/godoc/spec.go
+++ b/src/cmd/godoc/spec.go
@@ -23,7 +23,7 @@ type ebnfParser struct {
 	scanner scanner.Scanner
 	prev    int    // offset of previous token
 	pos     int    // offset of current token
-	tok     int    // one token look-ahead
+	tok     rune   // one token look-ahead
 	lit     string // token literal
 }
 
@@ -47,7 +47,7 @@ func (p *ebnfParser) errorExpected(msg string) {
 	p.printf(`<span class="highlight">error: expected %s, found %s</span>`, msg, scanner.TokenString(p.tok))\n}\n \n-func (p *ebnfParser) expect(tok int) {\n+func (p *ebnfParser) expect(tok rune) {\n 	if p.tok != tok {\n 		p.errorExpected(scanner.TokenString(tok))\n 	}\n```
`ebnfParser`構造体の`tok`フィールド（1トークン先読み）と、`expect`関数の引数`tok`の型が`int`から`rune`に変更されています。これにより、EBNFパーサーが扱うトークンが文字ベースであることを明確にしています。

### `src/pkg/exp/ebnf/ebnf.go`

```diff
--- a/src/pkg/exp/ebnf/ebnf.go
+++ b/src/pkg/exp/ebnf/ebnf.go
@@ -163,7 +163,7 @@ func (v *verifier) push(prod *Production) {
 	}\n}\n \n-func (v *verifier) verifyChar(x *Token) int {\n+func (v *verifier) verifyChar(x *Token) rune {\n 	s := x.String\n 	if utf8.RuneCountInString(s) != 1 {\n 		v.error(x.Pos(), "single char expected, found "+s)\n```
`verifyChar`関数の戻り値の型が`int`から`rune`に変更されています。この関数は単一の文字を検証するものであり、その結果を`rune`として返すのが適切です。

### `src/pkg/exp/ebnf/parser.go`

```diff
--- a/src/pkg/exp/ebnf/parser.go
+++ b/src/pkg/exp/ebnf/parser.go
@@ -15,7 +15,7 @@ type parser struct {
 	errors  errorList
 	scanner scanner.Scanner
 	pos     scanner.Position // token position
-	tok     int              // one token look-ahead
+	tok     rune             // one token look-ahead
 	lit     string           // token literal
 }\n \n@@ -42,7 +42,7 @@ func (p *parser) errorExpected(pos scanner.Position, msg string) {
 	p.error(pos, msg)\n}\n \n-func (p *parser) expect(tok int) scanner.Position {\n+func (p *parser) expect(tok rune) scanner.Position {\n 	pos := p.pos\n 	if p.tok != tok {\n 		p.errorExpected(pos, scanner.TokenString(tok))\n```
`parser`構造体の`tok`フィールドと、`expect`関数の引数`tok`の型が`int`から`rune`に変更されています。これは`godoc/spec.go`と同様の変更で、EBNFパーサーにおけるトークン処理の整合性を高めます。

### `src/pkg/exp/types/gcimporter.go`

```diff
--- a/src/pkg/exp/types/gcimporter.go
+++ b/src/pkg/exp/types/gcimporter.go
@@ -71,7 +71,7 @@ func findPkg(path string) (filename, id string) {
 // object/archive file and populates its scope with the results.
 type gcParser struct {
 	scanner scanner.Scanner
-	tok     int                    // current token
+	tok     rune                   // current token
 	lit     string                 // literal string; only valid for Ident, Int, String tokens
 	id      string                 // package id of imported package
 	imports map[string]*ast.Object // package id -> package object
@@ -195,7 +195,7 @@ func (p *gcParser) errorf(format string, args ...interface{}) {
 	p.error(fmt.Sprintf(format, args...))\n}\n \n-func (p *gcParser) expect(tok int) string {\n+func (p *gcParser) expect(tok rune) string {\n 	lit := p.lit\n 	if p.tok != tok {\n 		p.errorf("expected %q, got %q (%q)", scanner.TokenString(tok), scanner.TokenString(p.tok), lit)\n@@ -205,9 +205,9 @@ func (p *gcParser) expect(tok int) string {
 }\n \n func (p *gcParser) expectSpecial(tok string) {\n-\tsep := 'x' // not white space\n+\tsep := rune('x') // not white space\n \ti := 0\n-\tfor i < len(tok) && p.tok == int(tok[i]) && sep > ' ' {\n+\tfor i < len(tok) && p.tok == rune(tok[i]) && sep > ' ' {\n \t\tsep = p.scanner.Peek() // if sep <= ' ', there is white space before the next token\n \t\tp.next()\n \t\ti++\n@@ -260,7 +260,7 @@ func (p *gcParser) parsePkgId() *ast.Object {
 func (p *gcParser) parseDotIdent() string {
 	ident := ""\n 	if p.tok != scanner.Int {\n-\t\tsep := 'x' // not white space\n+\t\tsep := rune('x') // not white space\n \t\tfor (p.tok == scanner.Ident || p.tok == scanner.Int || p.tok == '·') && sep > ' ' {\n \t\t\tident += p.lit\n \t\t\tsep = p.scanner.Peek() // if sep <= ' ', there is white space before the next token
```
`gcParser`構造体の`tok`フィールド、`expect`関数の引数`tok`、そして`expectSpecial`関数と`parseDotIdent`関数内の文字比較において、`int`から`rune`への変更が行われています。これは、Goコンパイラのインポート処理に関連するパーサーが、文字を`rune`として扱うように統一されたことを示します。

### `src/pkg/go/scanner/scanner.go`

```diff
--- a/src/pkg/go/scanner/scanner.go
+++ b/src/pkg/go/scanner/scanner.go
@@ -43,7 +43,7 @@ type Scanner struct {
 	mode uint         // scanning mode
 
 	// scanning state
-	ch         int  // current character
+	ch         rune // current character
 	offset     int  // character offset
 	rdOffset   int  // reading offset (position after current character)
 	lineOffset int  // current line offset
@@ -63,7 +63,7 @@ func (S *Scanner) next() {
 			S.lineOffset = S.offset
 			S.file.AddLine(S.offset)
 		}
-		r, w := int(S.src[S.rdOffset]), 1
+		r, w := rune(S.src[S.rdOffset]), 1
 		switch {
 		case r == 0:
 			S.error(S.offset, "illegal character NUL")
@@ -232,11 +232,11 @@ func (S *Scanner) findLineEnd() bool {
 	return false
 }
 
-func isLetter(ch int) bool {
+func isLetter(ch rune) bool {
 	return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || ch == '_' || ch >= 0x80 && unicode.IsLetter(ch)
 }
 
-func isDigit(ch int) bool {
+func isDigit(ch rune) bool {
 	return '0' <= ch && ch <= '9' || ch >= 0x80 && unicode.IsDigit(ch)
 }
 
@@ -248,14 +248,14 @@ func (S *Scanner) scanIdentifier() token.Token {
 	return token.Lookup(S.src[offs:S.offset])
 }
 
-func digitVal(ch int) int {
+func digitVal(ch rune) int {
 	switch {
 	case '0' <= ch && ch <= '9':
-		return ch - '0'
+		return int(ch - '0')
 	case 'a' <= ch && ch <= 'f':
-		return ch - 'a' + 10
+		return int(ch - 'a' + 10)
 	case 'A' <= ch && ch <= 'F':
-		return ch - 'A' + 10
+		return int(ch - 'A' + 10)
 	}
 	return 16 // larger than any legal digit val
 }
@@ -337,7 +337,7 @@ exit:
 	return tok
 }
 
-func (S *Scanner) scanEscape(quote int) {
+func (S *Scanner) scanEscape(quote rune) {
 	offs := S.offset
 
 	var i, base, max uint32
@@ -462,7 +462,7 @@ func (S *Scanner) switch2(tok0, tok1 token.Token) token.Token {
 	return tok0
 }
 
-func (S *Scanner) switch3(tok0, tok1 token.Token, ch2 int, tok2 token.Token) token.Token {
+func (S *Scanner) switch3(tok0, tok1 token.Token, ch2 rune, tok2 token.Token) token.Token {
 	if S.ch == '=' {
 		S.next()
 		return tok1
@@ -474,7 +474,7 @@ func (S *Scanner) switch3(tok0, tok1 token.Token, ch2 int, tok2 token.Token) tok
 	return tok0
 }
 
-func (S *Scanner) switch4(tok0, tok1 token.Token, ch2 int, tok2, tok3 token.Token) token.Token {
+func (S *Scanner) switch4(tok0, tok1 token.Token, ch2 rune, tok2, tok3 token.Token) token.Token {
 	if S.ch == '=' {
 		S.next()
 		return tok1
```
このファイルはGo言語の公式スキャナーパッケージの一部であり、最も重要な変更が含まれています。
*   `Scanner`構造体の`ch`フィールド（現在の文字）が`int`から`rune`に変更。
*   `next()`関数内で、ソースコードから読み込む文字`r`が`int(S.src[S.rdOffset])`から`rune(S.src[S.rdOffset])`に変更。
*   `isLetter`, `isDigit`, `digitVal`, `scanEscape`, `switch3`, `switch4`といった文字を扱う関数の引数や戻り値の型が`int`から`rune`に変更。
*   特に`digitVal`関数では、文字から数値への変換時に`int()`への明示的なキャストが追加されています。これは、`rune`型同士の減算結果が`rune`型になるため、`int`型として返すために必要です。

これらの変更は、スキャナーがソースコードの文字を`rune`として内部的に扱い、Unicode文字の処理をより正確に行うための基盤を強化します。

### `src/pkg/scanner/scanner.go`

```diff
--- a/src/pkg/scanner/scanner.go
+++ b/src/pkg/scanner/scanner.go
@@ -93,7 +93,7 @@ const (
 	skipComment
 )
 
-var tokenString = map[int]string{
+var tokenString = map[rune]string{
 	EOF:       "EOF",
 	Ident:     "Ident",
 	Int:       "Int",
@@ -105,7 +105,7 @@ var tokenString = map[int]string{
 }
 
 // TokenString returns a (visible) string for a token or Unicode character.
-func TokenString(tok int) string {
+func TokenString(tok rune) string {
 	if s, found := tokenString[tok]; found {
 		return s
 	}
@@ -144,7 +144,7 @@ type Scanner struct {
 	tokEnd int          // token text tail end (srcBuf index)
 
 	// One character look-ahead
-	ch int // character before current srcPos
+	ch rune // character before current srcPos
 
 	// Error is called for each error encountered. If no Error
 	// function is set, the error is reported to os.Stderr.
@@ -218,8 +218,8 @@ func (s *Scanner) Init(src io.Reader) *Scanner {
 // that only a minimal amount of work needs to be done in the common ASCII
 // case (one test to check for both ASCII and end-of-buffer, and one test
 // to check for newlines).\n-func (s *Scanner) next() int {\n-\tch, width := int(s.srcBuf[s.srcPos]), 1\n+func (s *Scanner) next() rune {\n+\tch, width := rune(s.srcBuf[s.srcPos]), 1\n \n \tif ch >= utf8.RuneSelf {\n \t\t// uncommon case: not ASCII or not enough bytes
@@ -264,7 +264,7 @@ func (s *Scanner) next() int {
 			}\n \t\t}\n \t\t// at least one byte\n-\t\tch = int(s.srcBuf[s.srcPos])\n+\t\tch = rune(s.srcBuf[s.srcPos])
 \t\tif ch >= utf8.RuneSelf {\n \t\t\t// uncommon case: not ASCII\n \t\t\tch, width = utf8.DecodeRune(s.srcBuf[s.srcPos:s.srcEnd])
@@ -304,7 +304,7 @@ func (s *Scanner) next() int {
 // it prints an error message to os.Stderr. Next does not\n // update the Scanner's Position field; use Pos() to\n // get the current position.\n-func (s *Scanner) Next() int {\n+func (s *Scanner) Next() rune {\n \ts.tokPos = -1 // don't collect token text\n \ts.Line = 0    // invalidate token position\n \tch := s.Peek()\n@@ -315,7 +315,7 @@ func (s *Scanner) Next() int {
 // Peek returns the next Unicode character in the source without advancing\n // the scanner. It returns EOF if the scanner's position is at the last\n // character of the source.\n-func (s *Scanner) Peek() int {\n+func (s *Scanner) Peek() rune {\n \tif s.ch < 0 {\n \t\ts.ch = s.next()\n \t}\n@@ -335,7 +335,7 @@ func (s *Scanner) error(msg string) {
 	fmt.Fprintf(os.Stderr, "%s: %s\\n", pos, msg)\n}\n \n-func (s *Scanner) scanIdentifier() int {\n+func (s *Scanner) scanIdentifier() rune {\n \tch := s.next() // read character after first '_' or letter\n \tfor ch == '_' || unicode.IsLetter(ch) || unicode.IsDigit(ch) {\n \t\tch = s.next()\n@@ -343,35 +343,35 @@ func (s *Scanner) scanIdentifier() int {
 	return ch\n}\n \n-func digitVal(ch int) int {\n+func digitVal(ch rune) int {\n \tswitch {\n \tcase '0' <= ch && ch <= '9':\n-\t\treturn ch - '0'\n+\t\treturn int(ch - '0')
 \tcase 'a' <= ch && ch <= 'f':\n-\t\treturn ch - 'a' + 10\n+\t\treturn int(ch - 'a' + 10)
 \tcase 'A' <= ch && ch <= 'F':\n-\t\treturn ch - 'A' + 10\n+\t\treturn int(ch - 'A' + 10)
 \t}\n \treturn 16 // larger than any legal digit val\n}\n \n-func isDecimal(ch int) bool { return '0' <= ch && ch <= '9' }\n+func isDecimal(ch rune) bool { return '0' <= ch && ch <= '9' }\n \n-func (s *Scanner) scanMantissa(ch int) int {\n+func (s *Scanner) scanMantissa(ch rune) rune {\n \tfor isDecimal(ch) {\n \t\tch = s.next()\n \t}\n \treturn ch\n}\n \n-func (s *Scanner) scanFraction(ch int) int {\n+func (s *Scanner) scanFraction(ch rune) rune {\n \tif ch == '.' {\n \t\tch = s.scanMantissa(s.next())\n \t}\n \treturn ch\n}\n \n-func (s *Scanner) scanExponent(ch int) int {\n+func (s *Scanner) scanExponent(ch rune) rune {\n \tif ch == 'e' || ch == 'E' {\n \t\tch = s.next()\n \t\tif ch == '-' || ch == '+' {\n@@ -382,7 +382,7 @@ func (s *Scanner) scanExponent(ch int) int {
 	return ch\n}\n \n-func (s *Scanner) scanNumber(ch int) (int, int) {\n+func (s *Scanner) scanNumber(ch rune) (rune, rune) {\n \t// isDecimal(ch)\n \tif ch == '0' {\n \t\t// int or float\n@@ -426,7 +426,7 @@ func (s *Scanner) scanNumber(ch int) (int, int) {
 	return Int, ch\n}\n \n-func (s *Scanner) scanDigits(ch, base, n int) int {\n+func (s *Scanner) scanDigits(ch rune, base, n int) rune {\n \tfor n > 0 && digitVal(ch) < base {\n \t\tch = s.next()\n \t\tn--\n@@ -437,7 +437,7 @@ func (s *Scanner) scanDigits(ch, base, n int) int {
 	return ch\n}\n \n-func (s *Scanner) scanEscape(quote int) int {\n+func (s *Scanner) scanEscape(quote rune) rune {\n \tch := s.next() // read character after '/'\n \tswitch ch {\n \tcase 'a', 'b', 'f', 'n', 'r', 't', 'v', '\\\\', quote:\n@@ -457,7 +457,7 @@ func (s *Scanner) scanEscape(quote int) int {
 	return ch\n}\n \n-func (s *Scanner) scanString(quote int) (n int) {\n+func (s *Scanner) scanString(quote rune) (n int) {\n \tch := s.next() // read character after quote\n \tfor ch != quote {\n \t\tif ch == '\\n' || ch < 0 {\n@@ -491,7 +491,7 @@ func (s *Scanner) scanChar() {
 	}\n}\n \n-func (s *Scanner) scanComment(ch int) int {\n+func (s *Scanner) scanComment(ch rune) rune {\n \t// ch == '/' || ch == '*'\n \tif ch == '/' {\n \t\t// line comment\n@@ -524,7 +524,7 @@ func (s *Scanner) scanComment(ch int) int {
 // It returns EOF at the end of the source. It reports scanner errors (read and\n // token errors) by calling s.Error, if not nil; otherwise it prints an error\n // message to os.Stderr.\n-func (s *Scanner) Scan() int {\n+func (s *Scanner) Scan() rune {\n \tch := s.Peek()\n \n \t// reset token text position
```
このファイルもGo言語のスキャナーパッケージの一部で、`go/scanner/scanner.go`と同様に広範な変更が行われています。
*   `tokenString`マップのキーの型が`int`から`rune`に変更。
*   `TokenString`関数の引数`tok`の型が`int`から`rune`に変更。
*   `Scanner`構造体の`ch`フィールドが`int`から`rune`に変更。
*   `next()`, `Next()`, `Peek()`, `scanIdentifier()`, `digitVal()`, `isDecimal()`, `scanMantissa()`, `scanFraction()`, `scanExponent()`, `scanNumber()`, `scanDigits()`, `scanEscape()`, `scanString()`, `scanComment()`, `Scan()`といった、文字やトークンを扱う主要な関数の引数や戻り値の型が`int`から`rune`に変更されています。
*   特に`scanNumber`関数の戻り値の型が`(int, int)`から`(rune, rune)`に変更されている点も注目に値します。

これらの変更は、Go言語のスキャナーが文字を扱う際の内部表現とAPIを`rune`に統一し、Unicode対応を強化するための包括的なものです。

### `src/pkg/scanner/scanner_test.go`

```diff
--- a/src/pkg/scanner/scanner_test.go
+++ b/src/pkg/scanner/scanner_test.go
@@ -64,7 +64,7 @@ func TestNext(t *testing.T) {
 }\n \n type token struct {\n-\ttok  int\n+\ttok  rune\n \ttext string\n }\n \n@@ -233,7 +233,7 @@ func makeSource(pattern string) *bytes.Buffer {
 	return &buf\n}\n \n-func checkTok(t *testing.T, s *Scanner, line, got, want int, text string) {\n+func checkTok(t *testing.T, s *Scanner, line int, got, want rune, text string) {\n \tif got != want {\n \t\tt.Fatalf("tok = %s, want %s for %q", TokenString(got), TokenString(want), text)\n \t}\n@@ -329,7 +329,7 @@ func TestScanZeroMode(t *testing.T) {
 	}\n}\n \n-func testScanSelectedMode(t *testing.T, mode uint, class int) {\n+func testScanSelectedMode(t *testing.T, mode uint, class rune) {\n \tsrc := makeSource("%s\\n")\n \ts := new(Scanner).Init(src)\n \ts.Mode = mode\n@@ -398,7 +398,7 @@ func TestScanWhitespace(t *testing.T) {
 	}\n}\n \n-func testError(t *testing.T, src, pos, msg string, tok int) {\n+func testError(t *testing.T, src, pos, msg string, tok rune) {\n \ts := new(Scanner).Init(bytes.NewBufferString(src))\n \terrorCalled := false\n \ts.Error = func(s *Scanner, m string) {\n@@ -463,7 +463,7 @@ func checkPos(t *testing.T, got, want Position) {
 	}\n}\n \n-func checkNextPos(t *testing.T, s *Scanner, offset, line, column, char int) {\n+func checkNextPos(t *testing.T, s *Scanner, offset, line, column int, char rune) {\n \tif ch := s.Next(); ch != char {\n \t\tt.Errorf("ch = %s, want %s", TokenString(ch), TokenString(char))\n \t}\n@@ -471,7 +471,7 @@ func checkNextPos(t *testing.T, s *Scanner, offset, line, column, char int) {
 	checkPos(t, s.Pos(), want)\n}\n \n-func checkScanPos(t *testing.T, s *Scanner, offset, line, column, char int) {\n+func checkScanPos(t *testing.T, s *Scanner, offset, line, column int, char rune) {\n \twant := Position{Offset: offset, Line: line, Column: column}\n \tcheckPos(t, s.Pos(), want)\n \tif ch := s.Scan(); ch != char {\n```
テストコードも、変更されたAPIに合わせて`int`から`rune`への型変更が行われています。これにより、新しい`rune`ベースのAPIが正しく機能することを検証しています。特に、`token`構造体の`tok`フィールドや、`checkTok`, `testScanSelectedMode`, `testError`, `checkNextPos`, `checkScanPos`といったテストヘルパー関数の引数やフィールドの型が変更されています。

## 関連リンク

*   GitHubコミットページ: https://github.com/golang/go/commit/5be33e95437d72f5ece5f7d5cc6f9773030e024e
*   Go Code Review (CL): https://golang.org/cl/5301049

## 参考にした情報源リンク

*   Go言語の`rune`型に関する公式ドキュメントやブログ記事 (Web検索で得られた一般的な情報)
*   Go言語の`scanner`パッケージに関するドキュメント (Web検索で得られた一般的な情報)
*   UTF-8およびUnicodeに関する一般的な情報 (Web検索で得られた一般的な情報)
*   コンパイラの字句解析（Lexical Analysis）に関する一般的な情報 (Web検索で得られた一般的な情報)
*   Go言語のソースコード内のコメントと構造
```
