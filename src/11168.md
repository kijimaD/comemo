# [インデックス 11168] ファイルの概要

このコミットは、Go言語の実験的な`exp/terminal`パッケージにおける2つの主要な改善を導入しています。一つは、ターミナルプロンプトを設定するための`SetPrompt`関数の追加です。もう一つは、ターミナルへの大量のペースト（貼り付け）操作時の挙動の修正です。以前は、大量のデータが一度にペーストされた際に、ターミナルが正しく入力処理を行えず、誤動作する問題がありました。このコミットは、このバグを修正し、より堅牢な入力処理を実現しています。

## コミット

```
commit a9e1f6d7a67d0cc423765e83193640335e8b8301
Author: Adam Langley <agl@golang.org>
Date:   Sat Jan 14 10:59:11 2012 -0500

    exp/terminal: add SetPrompt and handle large pastes.

    (This was missing in the last change because I uploaded it from the
    wrong machine.)

    Large pastes previously misbehaved because the code tried reading from
    the terminal before checking whether an line was already buffered.
    Large pastes can cause multiples lines to be read at once from the
    terminal.

    R=bradfitz
    CC=golang-dev
    https://golang.org/cl/5542049
```

## GitHub上でのコミットページへのリンク

[https://github.com/golang/go/commit/a9e1f6d7a67d0cc423765e83193640335e8b8301](https://github.com/golang/go/commit/a9e1f6d7a67d0cc423765e83193640335e8b8301)

## 元コミット内容

このコミットは、`exp/terminal`パッケージに`SetPrompt`関数を追加し、ターミナルへの大量ペースト時の挙動を修正するものです。以前の変更で`SetPrompt`が漏れていたことへの補足と、大量ペースト時にターミナルが誤動作するバグの修正が主な内容です。このバグは、コードが既にバッファされている行があるかを確認する前にターミナルから読み取ろうとしたために発生していました。

## 変更の背景

この変更の背景には、Go言語で開発されるCLIツールやインタラクティブなアプリケーションが、より洗練されたユーザーエクスペリエンスを提供するためのニーズがあります。

1.  **`SetPrompt`関数の追加**: インタラクティブなターミナルアプリケーションでは、ユーザーに現在の状態や次の入力を促すためのプロンプト表示が不可欠です。この機能が不足していたため、開発者がより柔軟にプロンプトを制御できるようにするために追加されました。コミットメッセージにある「This was missing in the last change because I uploaded it from the wrong machine.」という記述から、以前の関連する変更で意図せず漏れてしまった機能であることが示唆されます。
2.  **大量ペースト時のバグ修正**: ターミナルアプリケーションにおいて、ユーザーが大量のテキスト（例えば、長いコマンド、コードスニペット、設定ファイルの内容など）を一度にペーストするシナリオは頻繁に発生します。この際、`exp/terminal`パッケージが内部的に入力を処理する方法に問題があり、複数の行が一度に読み込まれた場合に、バッファリングのロジックが正しく機能せず、誤った挙動を引き起こしていました。このバグは、ユーザーエクスペリエンスを著しく損なうため、その修正が急務でした。

これらの変更は、Go言語で構築されるターミナルベースのアプリケーションの堅牢性と使いやすさを向上させることを目的としています。

## 前提知識の解説

このコミットを理解するためには、以下の概念について基本的な知識があると役立ちます。

*   **Go言語の`exp`パッケージ**: Go言語の標準ライブラリには、`exp`（experimental）というプレフィックスを持つパッケージ群が存在します。これらは、将来的に標準ライブラリに取り込まれる可能性のある実験的な機能や、まだ安定版ではない機能を提供します。`exp`パッケージのAPIは、予告なく変更される可能性があり、本番環境での使用には注意が必要です。このコミットで変更されている`exp/terminal`もその一つです。現在では、`golang.org/x/term`パッケージが後継として推奨されています。
*   **ターミナルI/O**: ターミナル（またはコンソール）は、ユーザーがコマンドを入力し、プログラムが出力を表示するためのインターフェースです。ターミナルI/O（Input/Output）は、プログラムがターミナルから入力を読み取り、ターミナルにテキストを出力するプロセスを指します。これには、キーボードからの入力、ペースト操作、画面への文字表示などが含まれます。
*   **バッファリング**: コンピュータシステムにおいて、データが一時的に保存される領域をバッファと呼びます。I/O操作では、効率を高めるためにデータがバッファに一時的に蓄えられ、まとめて処理されることがよくあります。ターミナル入力の場合、ユーザーが入力した文字やペーストされたデータは、すぐにプログラムに渡されるのではなく、内部バッファに蓄積されることがあります。
*   **プロンプト**: コマンドラインインターフェース（CLI）において、ユーザーに次の入力を促すために表示される記号やテキストのことです。例えば、`$`や`>`、あるいは`user@hostname:~$`のような形式で表示されます。インタラクティブなアプリケーションでは、プログラムの状態に応じてプロンプトが変化することがあります。
*   **`io.EOF`**: Go言語の`io`パッケージで定義されているエラー定数で、"end of file"（ファイルの終端）を意味します。入力ストリームの終わりに達したことを示すために使用されます。ターミナル入力の場合、ユーザーがCtrl+D（Unix系システム）などのEOFシグナルを送信した際に発生することがあります。

## 技術的詳細

このコミットの技術的詳細は、主に`exp/terminal`パッケージの`readLine`関数の内部ロジックの変更と、`SetPrompt`関数の追加に集約されます。

### 大量ペースト時の挙動修正

従来の`readLine`関数は、ターミナルからの入力を処理する際に、既に内部バッファにデータが残っているかどうかを確認する前に、新たな入力を読み込もうとする問題がありました。この挙動は、特にユーザーが大量のテキストを一度にペーストした場合に顕在化しました。

1.  **問題点**: 大量のペーストが行われると、ターミナルは一度に複数のキーイベントや行終端文字（改行）を送信することがあります。`readLine`関数が、まだ処理されていないバッファ内のデータがあるにもかかわらず、`t.c.Read(readBuf)`（ターミナルからの読み込み）を試みると、入力ストリームの同期が崩れ、予期せぬ動作やデータの欠落が発生する可能性がありました。コミットメッセージにある「Large pastes previously misbehaved because the code tried reading from the terminal before checking whether an line was already buffered.」という記述がこれを明確に示しています。
2.  **修正内容**: 修正後のコードでは、`readLine`関数のループの冒頭で、まず`t.remainder`（以前の読み込みで残った部分的なキーシーケンスやバッファ）を優先的に処理するロジックが追加されました。
    *   `rest := t.remainder`で残りのデータを取得。
    *   `for !lineOk`ループ内で、`bytesToKey(rest)`を使って残りのデータからキーイベントを抽出し、`t.handleKey(key)`で処理します。
    *   この処理が完了した後、`lineOk`が`true`であれば、行が完全に読み込まれたと判断し、関数を終了します。
    *   もし`lineOk`が`false`で、かつ`len(rest) > 0`（まだ処理すべきデータが残っている）場合は、その残りのデータを`t.remainder`にコピーし、次回のループで優先的に処理されるようにします。
    *   この変更により、ターミナルからの新たな読み込み（`t.c.Read(readBuf)`）は、既存のバッファが適切に処理された後にのみ行われるようになり、大量ペースト時の入力処理の堅牢性が向上しました。

### `SetPrompt`関数の追加

`SetPrompt`関数は、ターミナルオブジェクトのプロンプト文字列を動的に変更するためのシンプルなセッター関数です。

*   **機能**: `func (t *Terminal) SetPrompt(prompt string)`というシグネチャを持ち、引数として新しいプロンプト文字列を受け取ります。
*   **実装**: 内部的には、`t.lock.Lock()`と`t.lock.Unlock()`を使用してミューテックスロックをかけ、`t.prompt`フィールドに新しいプロンプト文字列を安全に設定します。これにより、複数のゴルーチンから同時にプロンプトを変更しようとした場合でも、データ競合を防ぎ、スレッドセーフな操作を保証します。
*   **目的**: この関数が追加されたことで、アプリケーションはユーザーの操作やプログラムの状態に応じて、プロンプトをリアルタイムで更新できるようになり、よりインタラクティブでユーザーフレンドリーなCLIアプリケーションの構築が可能になります。

## コアとなるコードの変更箇所

変更は主に`src/pkg/exp/terminal/terminal.go`ファイルに集中しています。

*   **`readLine`関数**:
    *   既存の入力処理ループの冒頭に、`t.remainder`を優先的に処理する新しいロジックが追加されました。
    *   以前の`if err == nil { ... }`ブロック内のバッファ処理ロジックが削除され、新しいロジックに置き換えられました。
*   **`SetPrompt`関数**:
    *   ファイルの末尾付近に、新しい公開関数`SetPrompt`が追加されました。

具体的な行数としては、`src/pkg/exp/terminal/terminal.go`において、34行が追加され、28行が削除されています。

## コアとなるコードの解説

### `readLine`関数の変更

変更の核心は、`readLine`関数がターミナルからの入力をどのように処理するか、特にバッファリングされたデータと新規入力の優先順位付けにあります。

```go
// 変更前（簡略化）
// for {
//     // ターミナルから読み込み
//     n, err := t.c.Read(readBuf)
//     if err == nil {
//         // 読み込んだデータをバッファに追加
//         t.remainder = t.inBuf[:n+len(t.remainder)]
//         // バッファからキーを処理
//         // ...
//     }
// }

// 変更後（簡略化）
for {
    rest := t.remainder // まず既存のバッファ（remainder）を処理
    lineOk := false
    for !lineOk {
        var key int
        key, rest = bytesToKey(rest) // remainderからキーを抽出
        if key < 0 {
            break // キーが不完全ならループを抜ける
        }
        if key == keyCtrlD {
            return "", io.EOF // Ctrl+DならEOF
        }
        line, lineOk = t.handleKey(key) // キーを処理
    }
    if len(rest) > 0 {
        // 処理しきれなかったremainderがあれば、次回のremainderに設定
        n := copy(t.inBuf[:], rest)
        t.remainder = t.inBuf[:n]
    } else {
        t.remainder = nil // remainderが空ならnilに
    }
    t.c.Write(t.outBuf) // 出力バッファを書き出す
    t.outBuf = t.outBuf[:0] // 出力バッファをクリア
    if lineOk {
        return // 行が完成したら終了
    }

    // 行が完成していない場合のみ、ターミナルから新たな入力を読み込む
    readBuf := t.inBuf[len(t.remainder):]
    n, err := t.c.Read(readBuf)
    // ... エラー処理とremainderの更新
}
```

この変更により、`readLine`はまず`t.remainder`に存在する部分的なキーシーケンスや、以前の読み込みで残ったデータがないかを確認し、それらを優先的に処理します。これにより、大量のペーストによって一度に多くのデータが入力された場合でも、システムが既存のバッファを適切に消化してから新たな入力を受け入れるようになり、入力処理のロバスト性が大幅に向上しました。

### `SetPrompt`関数の追加

```go
// SetPrompt sets the prompt to be used when reading subsequent lines.
func (t *Terminal) SetPrompt(prompt string) {
    t.lock.Lock()   // ロックを取得
    defer t.lock.Unlock() // 関数終了時にロックを解放

    t.prompt = prompt // プロンプト文字列を更新
}
```

この関数は非常にシンプルですが、その存在意義は大きいです。`t.lock`というミューテックスを使用して`t.prompt`フィールドへのアクセスを保護することで、並行処理環境下でのデータ競合を防ぎます。これにより、複数のゴルーチンが同時にプロンプトを変更しようとしても、安全に操作が完了することが保証されます。アプリケーション開発者は、この関数を呼び出すだけで、ユーザーインターフェースの重要な要素であるプロンプトを動的に制御できるようになります。

## 関連リンク

*   Go Change-Id: `5542049` (Goの内部的な変更管理システムにおけるID)
*   Go `x/term`パッケージ: `exp/terminal`の後継となる、現在推奨されているターミナル操作用パッケージ。
    *   [https://pkg.go.dev/golang.org/x/term](https://pkg.go.dev/golang.org/x/term)

## 参考にした情報源リンク

*   Go言語の`exp`パッケージに関する情報（Web検索結果より）
*   Go言語のターミナル操作に関する一般的な情報（Web検索結果より）
*   コミットメッセージの内容

