# [インデックス 10318] ファイルの概要

このコミットは、Go言語の標準ライブラリ `math` パッケージ内の `gamma.go` および `lgamma.go` ファイルに対する変更を含んでいます。具体的には、`Lgamma` 関数の計算速度を向上させるための最適化と、それに伴う変数名の調整が行われています。

## コミット

このコミットは、`math` パッケージにおける `Lgamma` 関数のパフォーマンス改善を目的としています。多項式定数から配列を用いた定数への変換により、`Lgamma` の処理速度が51.3 ns/opから37.7 ns/opへと高速化されました。また、`Gamma` 関数内の変数名が `Lgamma` との重複を避けるために変更されています。

## GitHub上でのコミットページへのリンク

[https://github.com/golang/go/commit/300b443ade1dd71963a014b4401614d988b3428c](https://github.com/golang/go/commit/300b443ade1dd71963a014b4401614d988b3428c)

## 元コミット内容

```
math: faster Lgamma

Converting from polynomial constants to counted array speeds up Lgamma from 51.3 to 37.7 ns/op. Variables renamed in Gamma to avoid overlap in Lgamma.

R=rsc, golang-dev
CC=golang-dev
https://golang.org/cl/5359045
```

## 変更の背景

この変更の主な背景は、`math` パッケージ内の `Lgamma` 関数の計算効率の向上です。`Lgamma` 関数はガンマ関数の自然対数を計算するものであり、統計学、物理学、工学など、様々な科学技術計算で利用されます。このような基本的な数学関数の性能は、それを利用するアプリケーション全体のパフォーマンスに大きな影響を与えます。

元の実装では、`Lgamma` 関数内で使用される多数の定数が個別の変数として定義されていました（例: `A0`, `A1`, `T0`, `T1` など）。これらの定数は、多項式評価において係数として使用されます。しかし、個別の変数としてアクセスするよりも、配列としてまとめて管理し、インデックスでアクセスする方が、コンパイラによる最適化の機会が増え、結果として実行時のパフォーマンスが向上する可能性があります。

このコミットでは、この最適化の可能性を追求し、定数を配列にまとめることで、`Lgamma` 関数の実行時間を約26%（51.3 ns/opから37.7 ns/op）短縮することに成功しました。これは、数値計算ライブラリにおいて非常に重要な改善であり、Go言語の科学技術計算における実用性を高めるものです。

また、`Gamma` 関数と `Lgamma` 関数で一部の変数名が重複していたため、コードの可読性と保守性を向上させる目的で、`Gamma` 関数内の変数名に `_gam` プレフィックスが追加されました。これは直接的なパフォーマンス改善とは関係ありませんが、コードベースの品質を維持するための重要な変更です。

## 前提知識の解説

### ガンマ関数 (Gamma Function, Γ(z))

ガンマ関数は、階乗の概念を複素数に拡張した特殊関数です。正の整数 `n` に対しては `Γ(n) = (n-1)!` と定義されます。一般的には、以下の積分で定義されます。

`Γ(z) = ∫₀^∞ t^(z-1)e^(-t) dt`

ガンマ関数は、確率論、統計学（特にガンマ分布、ベータ分布など）、物理学、工学など、多くの分野で広く利用されています。

### Lgamma 関数 (Log-Gamma Function, ln|Γ(x)|)

`Lgamma` 関数は、ガンマ関数の絶対値の自然対数 `ln|Γ(x)|` を計算する関数です。ガンマ関数は非常に速く成長するため、その値は非常に大きくなったり小さくなったりします。そのため、直接ガンマ関数を計算するとオーバーフローやアンダーフローが発生しやすくなります。対数を取ることで、これらの数値的な問題を回避し、より広い範囲の引数に対して安定した計算が可能になります。

`Lgamma` 関数は、特に確率密度関数の計算や、最尤推定などの統計的推論において頻繁に用いられます。また、`Lgamma` 関数はガンマ関数の符号も返すことが一般的です。

### 多項式評価と定数配列

数値計算では、特定の関数（この場合は `Lgamma`）の値を近似するために、多項式がよく用いられます。多項式は `P(x) = c₀ + c₁x + c₂x² + ... + cₙxⁿ` の形で表され、`cᵢ` は定数（係数）です。

多項式を評価する際、これらの係数をどのように格納し、アクセスするかはパフォーマンスに影響を与えます。

*   **個別の変数としての定数**: `A0`, `A1`, `A2`, ... のように、各係数を個別の名前付き変数として定義する方法です。コードの可読性は高いかもしれませんが、コンパイラがこれらの変数を連続したメモリ領域に配置する保証はなく、アクセスパターンが最適化されにくい場合があります。
*   **配列としての定数**: `_lgamA = [...]float64{A0, A1, A2, ...}` のように、係数を配列として定義する方法です。配列は通常、メモリ上で連続した領域に配置されるため、CPUのキャッシュ効率が向上しやすくなります。また、ループ処理やインデックスアクセスを用いることで、コンパイラがSIMD（Single Instruction, Multiple Data）命令などのベクトル化最適化を適用しやすくなり、複数のデータに対する演算を並行して実行できるようになる可能性があります。

このコミットの変更は、後者の「配列としての定数」を採用することで、CPUのキャッシュヒット率の向上と、より効率的なコード生成（特に多項式評価のループ構造において）を狙ったものです。

## 技術的詳細

このコミットの技術的な核心は、`Lgamma` 関数内で使用される多数の浮動小数点定数を、個別の名前付き変数からGo言語の配列（`[...]float64`）に移行した点にあります。

変更前は、`lgamma.go` 内で以下のように定数が定義されていました。

```go
const (
    A0    = 7.72156649015328655494e-02
    A1    = 3.22467033424113591611e-01
    // ...
    A11   = 4.48640949618915160150e-05
    // ...
    T0    = 4.83836122723810047042e-01
    // ...
    T14   = 3.35529192635519073543e-04
    // ...
)
```

これらの定数は、`Lgamma` 関数の内部で多項式評価のために直接使用されていました。例えば、以下のようなコードです。

```go
p1 := A0 + z*(A2+z*(A4+z*(A6+z*(A8+z*A10))))
p2 := z * (A1 + z*(A3+z*(A5+z*(A7+z*(A9+z*A11)))))
```

変更後、これらの定数は以下のように配列として定義されました。

```go
var _lgamA = [...]float64{
    7.72156649015328655494e-02, // 0x3FB3C467E37DB0C8
    3.22467033424113591611e-01, // 0x3FD4A34CC4A60FAD
    // ...
}
```

そして、多項式評価のコードは配列のインデックスアクセスを使用するように変更されました。

```go
p1 := _lgamA[0] + z*(_lgamA[2]+z*(_lgamA[4]+z*(_lgamA[6]+z*(_lgamA[8]+z*_lgamA[10]))))
p2 := z * (_lgamA[1] + z*(_lgamA[3]+z*(_lgamA[5]+z*(_lgamA[7]+z*(_lgamA[9]+z*_lgamA[11])))))
```

この変更がパフォーマンスに寄与する理由はいくつか考えられます。

1.  **キャッシュ効率の向上**: 配列はメモリ上で連続して配置されるため、CPUが一度に複数の係数をキャッシュに読み込むことができます。これにより、多項式評価中に必要な係数がすでにキャッシュに存在している可能性が高まり、メモリアクセスの遅延が減少します。個別の変数では、コンパイラがそれらをどのように配置するかは保証されず、キャッシュミスが発生しやすくなる可能性があります。
2.  **コンパイラの最適化**: 配列によるアクセスパターンは、コンパイラがより高度な最適化（特にループアンローリングやSIMD命令の利用）を適用しやすくなります。例えば、複数の浮動小数点演算を単一のCPU命令で処理できる場合、計算スループットが大幅に向上します。多項式評価は本質的にループのような構造を持つため、この恩恵を受けやすいです。
3.  **コードサイズの削減（可能性）**: 個別の定数定義が多数ある場合、それぞれの定数にアクセスするための命令が生成されます。配列としてまとめることで、アクセス命令がより汎用的なものになり、全体的なコードサイズがわずかに削減される可能性もあります。

`gamma.go` における変更は、`Gamma` 関数内で使用される定数 `_P`, `_Q`, `_S` の変数名を `_gamP`, `_gamQ`, `_gamS` に変更したものです。これは `Lgamma` 関数内の新しい配列名との衝突を避けるためのもので、機能的な変更やパフォーマンスへの影響はありません。

全体として、このコミットはGo言語の `math` パッケージにおける数値計算の基盤を強化し、より効率的な実行を可能にするための、細かではあるが重要な最適化を示しています。

## コアとなるコードの変更箇所

### `src/pkg/math/gamma.go`

```diff
--- a/src/pkg/math/gamma.go
+++ b/src/pkg/math/gamma.go
@@ -63,19 +63,19 @@ package math
 //   Stephen L. Moshier
 //   moshier@na-net.ornl.gov
 
-var _P = [...]float64{
+var _gamP = [...]float64{
 	1.60119522476751861407e-04,
 	1.19135147006586384913e-03,
 	1.04213797561761569935e-02,
 	4.76367800457137231464e-02,
 	2.07448227648435887146e-01,
 	4.94214826801497100753e-01,
 	9.99999999999999996796e-01,
 }
-var _Q = [...]float64{
+var _gamQ = [...]float64{
 	-2.31581873324120129819e-05,
 	5.39605580493303397842e-04,
 	-4.45641913851797240494e-03,
 	2.26840725005594019252e-02,
 	-5.96738211499965028212e-02,
 	7.14304917030273074085e-02,
 	1.00000000000000000320e+00,
 }
-var _S = [...]float64{
+var _gamS = [...]float64{
 	7.87311395793093628397e-04,
 	-2.29549961613378126380e-04,
 	-2.68132617805781232825e-03,
@@ -98,8 +98,8 @@ func Gamma(x float64) float64 {
 	}\n \n 	x = x - 2
-	p = (((((x*_P[0]+_P[1])*x+_P[2])*x+_P[3])*x+_P[4])*x+_P[5])*x + _P[6]
-	q = ((((((x*_Q[0]+_Q[1])*x+_Q[2])*x+_Q[3])*x+_Q[4])*x+_Q[5])*x+_Q[6])*x + _Q[7]
+	p = (((((x*_gamP[0]+_gamP[1])*x+_gamP[2])*x+_gamP[3])*x+_gamP[4])*x+_gamP[5])*x + _gamP[6]
+	q = ((((((x*_gamQ[0]+_gamQ[1])*x+_gamQ[2])*x+_gamQ[3])*x+_gamQ[4])*x+_gamQ[5])*x+_gamQ[6])*x + _gamQ[7]
 	return z * p / q
 
 small:
```

### `src/pkg/math/lgamma.go`

```diff
--- a/src/pkg/math/lgamma.go
+++ b/src/pkg/math/lgamma.go
@@ -88,68 +88,81 @@ package math
 //
 //
 
+var _lgamA = [...]float64{
+	7.72156649015328655494e-02, // 0x3FB3C467E37DB0C8
+	3.22467033424113591611e-01, // 0x3FD4A34CC4A60FAD
+	6.73523010531292681824e-02, // 0x3FB13E001A5562A7
+	2.05808084325167332806e-02, // 0x3F951322AC92547B
+	7.38555086081402883957e-03, // 0x3F7E404FB68FEFE8
+	2.89051383673415629091e-03, // 0x3F67ADD8CCB7926B
+	1.19270763183362067845e-03, // 0x3F538A94116F3F5D
+	5.10069792153511336608e-04, // 0x3F40B6C689B99C00
+	2.20862790713908385557e-04, // 0x3F2CF2ECED10E54D
+	1.08011567247583939954e-04, // 0x3F1C5088987DFB07
+	2.52144565451257326939e-05, // 0x3EFA7074428CFA52
+	4.48640949618915160150e-05, // 0x3F07858E90A45837
+}
+var _lgamR = [...]float64{
+	1.0, // placeholder
+	1.39200533467621045958e+00, // 0x3FF645A762C4AB74
+	7.21935547567138069525e-01, // 0x3FE71A1893D3DCDC
+	1.71933865632803078993e-01, // 0x3FC601EDCCFBDF27
+	1.86459191715652901344e-02, // 0x3F9317EA742ED475
+	7.77942496381893596434e-04, // 0x3F497DDACA41A95B
+	7.32668430744625636189e-06, // 0x3EDEBAF7A5B38140
+}
+var _lgamS = [...]float64{
+	-7.72156649015328655494e-02, // 0xBFB3C467E37DB0C8
+	2.14982415960608852501e-01,  // 0x3FCB848B36E20878
+	3.25778796408930981787e-01,  // 0x3FD4D98F4F139F59
+	1.46350472652464452805e-01,  // 0x3FC2BB9CBEE5F2F7
+	2.66422703033638609560e-02,  // 0x3F9B481C7E939961
+	1.84028451407337715652e-03,  // 0x3F5E26B67368F239
+	3.19475326584100867617e-05,  // 0x3F00BFECDD17E945
+}
+var _lgamT = [...]float64{
+	4.83836122723810047042e-01,  // 0x3FDEF72BC8EE38A2
+	-1.47587722994593911752e-01, // 0xBFC2E4278DC6C509
+	6.46249402391333854778e-02,  // 0x3FB08B4294D5419B
+	-3.27885410759859649565e-02, // 0xBFA0C9A8DF35B713
+	1.79706750811820387126e-02,  // 0x3F9266E7970AF9EC
+	-1.03142241298341437450e-02, // 0xBF851F9FBA91EC6A
+	6.10053870246291332635e-03,  // 0x3F78FCE0E370E344
+	-3.68452016781138256760e-03, // 0xBF6E2EFFB3E914D7
+	2.25964780900612472250e-03,  // 0x3F6282D32E15C915
+	-1.40346469989232843813e-03, // 0xBF56FE8EBF2D1AF1
+	8.81081882437654011382e-04,  // 0x3F4CDF0CEF61A8E9
+	-5.38595305356740546715e-04, // 0xBF41A6109C73E0EC
+	3.15632070903625950361e-04,  // 0x3F34AF6D6C0EBBF7
+	-3.12754168375120860518e-04, // 0xBF347F24ECC38C38
+	3.35529192635519073543e-04,  // 0x3F35FD3EE8C2D3F4
+}
+var _lgamU = [...]float64{
+	-7.72156649015328655494e-02, // 0xBFB3C467E37DB0C8
+	6.32827064025093366517e-01,  // 0x3FE4401E8B005DFF
+	1.45492250137234768737e+00,  // 0x3FF7475CD119BD6F
+	9.77717527963372745603e-01,  // 0x3FEF497644EA8450
+	2.28963728064692451092e-01,  // 0x3FCD4EAEF6010924
+	1.33810918536787660377e-02,  // 0x3F8B678BBF2BAB09
+}
+var _lgamV = [...]float64{
+	1.0,
+	2.45597793713041134822e+00, // 0x4003A5D7C2BD619C
+	2.12848976379893395361e+00, // 0x40010725A42B18F5
+	7.69285150456672783825e-01, // 0x3FE89DFBE45050AF
+	1.04222645593369134254e-01, // 0x3FBAAE55D6537C88
+	3.21709242282423911810e-03, // 0x3F6A5ABB57D0CF61
+}
+var _lgamW = [...]float64{
+	4.18938533204672725052e-01,  // 0x3FDACFE390C97D69
+	8.33333333333329678849e-02,  // 0x3FB555555555553B
+	-2.77777777728775536470e-03, // 0xBF66C16C16B02E5C
+	7.93650558643019558500e-04,  // 0x3F4A019F98CF38B6
+	-5.95187557450339963135e-04, // 0xBF4380CB8C0FE741
+	8.36339918996282139126e-04,  // 0x3F4B67BA4CDAD5D1
+	-1.63092934096575273989e-03, // 0xBF5AB89D0B9E43E4
+}
+
 // Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).
 //
 // Special cases are:
@@ -103,68 +178,10 @@ func Lgamma(x float64) (lgamma float64, sign int) {
 	\t\tTwo53 = 1 << 53                     // 0x4340000000000000 ~9.0072e+15
 	\t\tTwo58 = 1 << 58                     // 0x4390000000000000 ~2.8823e+17
 	\t\tTiny  = 1.0 / (1 << 70)             // 0x3b90000000000000 ~8.47033e-22
-\t\t\tA0    = 7.72156649015328655494e-02  // 0x3FB3C467E37DB0C8
-\t\t\tA1    = 3.22467033424113591611e-01  // 0x3FD4A34CC4A60FAD
-\t\t\tA2    = 6.73523010531292681824e-02  // 0x3FB13E001A5562A7
-\t\t\tA3    = 2.05808084325167332806e-02  // 0x3F951322AC92547B
-\t\t\tA4    = 7.38555086081402883957e-03  // 0x3F7E404FB68FEFE8
-\t\t\tA5    = 2.89051383673415629091e-03  // 0x3F67ADD8CCB7926B
-\t\t\tA6    = 1.19270763183362067845e-03  // 0x3F538A94116F3F5D
-\t\t\tA7    = 5.10069792153511336608e-04  // 0x3F40B6C689B99C00
-\t\t\tA8    = 2.20862790713908385557e-04  // 0x3F2CF2ECED10E54D
-\t\t\tA9    = 1.08011567247583939954e-04  // 0x3F1C5088987DFB07
-\t\t\tA10   = 2.52144565451257326939e-05  // 0x3EFA7074428CFA52
-\t\t\tA11   = 4.48640949618915160150e-05  // 0x3F07858E90A45837
 \t\tTc    = 1.46163214496836224576e+00  // 0x3FF762D86356BE3F
 \t\tTf    = -1.21486290535849611461e-01 // 0xBFBF19B9BCC38A42
 \t\t// Tt = -(tail of Tf)\n-\t\tTt  = -3.63867699703950536541e-18 // 0xBC50C7CAA48A971F
-\t\tT0  = 4.83836122723810047042e-01  // 0x3FDEF72BC8EE38A2
-\t\tT1  = -1.47587722994593911752e-01 // 0xBFC2E4278DC6C509
-\t\tT2  = 6.46249402391333854778e-02  // 0x3FB08B4294D5419B
-\t\tT3  = -3.27885410759859649565e-02 // 0xBFA0C9A8DF35B713
-\t\tT4  = 1.79706750811820387126e-02  // 0x3F9266E7970AF9EC
-\t\tT5  = -1.03142241298341437450e-02 // 0xBF851F9FBA91EC6A
-\t\tT6  = 6.10053870246291332635e-03  // 0x3F78FCE0E370E344
-\t\tT7  = -3.68452016781138256760e-03 // 0xBF6E2EFFB3E914D7
-\t\tT8  = 2.25964780900612472250e-03  // 0x3F6282D32E15C915
-\t\tT9  = -1.40346469989232843813e-03 // 0xBF56FE8EBF2D1AF1
-\t\tT10 = 8.81081882437654011382e-04  // 0x3F4CDF0CEF61A8E9
-\t\tT11 = -5.38595305356740546715e-04 // 0xBF41A6109C73E0EC
-\t\tT12 = 3.15632070903625950361e-04  // 0x3F34AF6D6C0EBBF7
-\t\tT13 = -3.12754168375120860518e-04 // 0xBF347F24ECC38C38
-\t\tT14 = 3.35529192635519073543e-04  // 0x3F35FD3EE8C2D3F4
-\t\tU0  = -7.72156649015328655494e-02 // 0xBFB3C467E37DB0C8
-\t\tU1  = 6.32827064025093366517e-01  // 0x3FE4401E8B005DFF
-\t\tU2  = 1.45492250137234768737e+00  // 0x3FF7475CD119BD6F
-\t\tU3  = 9.77717527963372745603e-01  // 0x3FEF497644EA8450
-\t\tU4  = 2.28963728064692451092e-01  // 0x3FCD4EAEF6010924
-\t\tU5  = 1.33810918536787660377e-02  // 0x3F8B678BBF2BAB09
-\t\tV1  = 2.45597793713041134822e+00  // 0x4003A5D7C2BD619C
-\t\tV2  = 2.12848976379893395361e+00  // 0x40010725A42B18F5
-\t\tV3  = 7.69285150456672783825e-01  // 0x3FE89DFBE45050AF
-\t\tV4  = 1.04222645593369134254e-01  // 0x3FBAAE55D6537C88
-\t\tV5  = 3.21709242282423911810e-03  // 0x3F6A5ABB57D0CF61
-\t\tS0  = -7.72156649015328655494e-02 // 0xBFB3C467E37DB0C8
-\t\tS1  = 2.14982415960608852501e-01  // 0x3FCB848B36E20878
-\t\tS2  = 3.25778796408930981787e-01  // 0x3FD4D98F4F139F59
-\t\tS3  = 1.46350472652464452805e-01  // 0x3FC2BB9CBEE5F2F7
-\t\tS4  = 2.66422703033638609560e-02  // 0x3F9B481C7E939961
-\t\tS5  = 1.84028451407337715652e-03  // 0x3F5E26B67368F239
-\t\tS6  = 3.19475326584100867617e-05  // 0x3F00BFECDD17E945
-\t\tR1  = 1.39200533467621045958e+00  // 0x3FF645A762C4AB74
-\t\tR2  = 7.21935547567138069525e-01  // 0x3FE71A1893D3DCDC
-\t\tR3  = 1.71933865632803078993e-01  // 0x3FC601EDCCFBDF27
-\t\tR4  = 1.86459191715652901344e-02  // 0x3F9317EA742ED475
-\t\tR5  = 7.77942496381893596434e-04  // 0x3F497DDACA41A95B
-\t\tR6  = 7.32668430744625636189e-06  // 0x3EDEBAF7A5B38140
-\t\tW0  = 4.18938533204672725052e-01  // 0x3FDACFE390C97D69
-\t\tW1  = 8.33333333333329678849e-02  // 0x3FB555555555553B
-\t\tW2  = -2.77777777728775536470e-03 // 0xBF66C16C16B02E5C
-\t\tW3  = 7.93650558643019558500e-04  // 0x3F4A019F9CF38B6
-\t\tW4  = -5.95187557450339963135e-04 // 0xBF4380CB8C0FE741
-\t\tW5  = 8.36339918996282139126e-04  // 0x3F4B67BA4CDAD5D1
-\t\tW6  = -1.63092934096575273989e-03 // 0xBF5AB89D0B9E43E4
+\t\tTt = -3.63867699703950536541e-18 // 0xBC50C7CAA48A971F
 \t)\n \t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n \t// when compiler does it for us\n@@ -249,28 +266,28 @@ func Lgamma(x float64) (lgamma float64, sign int) {\n \t\tswitch i {\n \t\tcase 0:\n \t\t\tz := y * y\n-\t\t\tp1 := A0 + z*(A2+z*(A4+z*(A6+z*(A8+z*A10))))\n-\t\t\tp2 := z * (A1 + z*(A3+z*(A5+z*(A7+z*(A9+z*A11)))))\n+\t\t\tp1 := _lgamA[0] + z*(_lgamA[2]+z*(_lgamA[4]+z*(_lgamA[6]+z*(_lgamA[8]+z*_lgamA[10]))))\n+\t\t\tp2 := z * (_lgamA[1] + z*(+_lgamA[3]+z*(_lgamA[5]+z*(_lgamA[7]+z*(_lgamA[9]+z*_lgamA[11])))))\n \t\t\tp := y*p1 + p2\n \t\t\tlgamma += (p - 0.5*y)\n \t\tcase 1:\n \t\t\tz := y * y\n \t\t\tw := z * y\n-\t\t\tp1 := T0 + w*(T3+w*(T6+w*(T9+w*T12))) // parallel comp\n-\t\t\tp2 := T1 + w*(T4+w*(T7+w*(T10+w*T13)))\n-\t\t\tp3 := T2 + w*(T5+w*(T8+w*(T11+w*T14)))\n+\t\t\tp1 := _lgamT[0] + w*(_lgamT[3]+w*(_lgamT[6]+w*(_lgamT[9]+w*_lgamT[12]))) // parallel comp\n+\t\t\tp2 := _lgamT[1] + w*(_lgamT[4]+w*(_lgamT[7]+w*(_lgamT[10]+w*_lgamT[13])))\n+\t\t\tp3 := _lgamT[2] + w*(_lgamT[5]+w*(_lgamT[8]+w*(_lgamT[11]+w*_lgamT[14])))\n \t\t\tp := z*p1 - (Tt - w*(p2+y*p3))\n \t\t\tlgamma += (Tf + p)\n \t\tcase 2:\n-\t\t\tp1 := y * (U0 + y*(U1+y*(U2+y*(U3+y*(U4+y*U5)))))\n-\t\t\tp2 := 1 + y*(V1+y*(V2+y*(V3+y*(V4+y*V5))))\n+\t\t\tp1 := y * (_lgamU[0] + y*(_lgamU[1]+y*(_lgamU[2]+y*(_lgamU[3]+y*(_lgamU[4]+y*_lgamU[5])))))\n+\t\t\tp2 := 1 + y*(_lgamV[1]+y*(_lgamV[2]+y*(_lgamV[3]+y*(_lgamV[4]+y*_lgamV[5]))))\n \t\t\tlgamma += (-0.5*y + p1/p2)\n \t\t}\n \tcase x < 8: // 2 <= x < 8\n \t\ti := int(x)\n \t\ty := x - float64(i)\n-\t\tp := y * (S0 + y*(S1+y*(S2+y*(S3+y*(S4+y*(S5+y*S6))))))\n-\t\tq := 1 + y*(R1+y*(R2+y*(R3+y*(R4+y*(R5+y*R6)))))\n+\t\tp := y * (_lgamS[0] + y*(_lgamS[1]+y*(_lgamS[2]+y*(_lgamS[3]+y*(_lgamS[4]+y*(_lgamS[5]+y*_lgamS[6]))))))\n+\t\tq := 1 + y*(_lgamR[1]+y*(_lgamR[2]+y*(_lgamR[3]+y*(_lgamR[4]+y*(_lgamR[5]+y*_lgamR[6])))))\n \t\tlgamma = 0.5*y + p/q\n \t\tz := 1.0 // Lgamma(1+s) = Log(s) + Lgamma(s)\n \t\tswitch i {\n@@ -294,7 +311,7 @@ func Lgamma(x float64) (lgamma float64, sign int) {\n \t\tt := Log(x)\n \t\tz := 1 / x\n \t\ty := z * z\n-\t\tw := W0 + z*(W1+y*(W2+y*(W3+y*(W4+y*(W5+y*W6)))))\n+\t\tw := _lgamW[0] + z*(_lgamW[1]+y*(_lgamW[2]+y*(_lgamW[3]+y*(_lgamW[4]+y*(_lgamW[5]+y*_lgamW[6])))))\n \t\tlgamma = (x-0.5)*(t-1) + w\n \tdefault: // 2**58 <= x <= Inf\n \t\tlgamma = x * (Log(x) - 1)\n```

## コアとなるコードの解説

### `src/pkg/math/gamma.go` の変更

このファイルでは、`Gamma` 関数内で使用される多項式係数を格納するグローバル変数 `_P`, `_Q`, `_S` の名前がそれぞれ `_gamP`, `_gamQ`, `_gamS` に変更されました。

*   `var _P = [...]float64{...}` が `var _gamP = [...]float64{...}` に変更。
*   `var _Q = [...]float64{...}` が `var _gamQ = [...]float64{...}` に変更。
*   `var _S = [...]float64{...}` が `var _gamS = [...]float64{...}` に変更。

これに伴い、`stirling` 関数と `Gamma` 関数内でこれらの変数を使用している箇所も、新しい変数名に更新されています。例えば、`Gamma` 関数内の以下の行が変更されました。

```go
// 変更前
p = (((((x*_P[0]+_P[1])*x+_P[2])*x+_P[3])*x+_P[4])*x+_P[5])*x + _P[6]
q = ((((((x*_Q[0]+_Q[1])*x+_Q[2])*x+_Q[3])*x+_Q[4])*x+_Q[5])*x+_Q[6])*x + _Q[7]

// 変更後
p = (((((x*_gamP[0]+_gamP[1])*x+_gamP[2])*x+_gamP[3])*x+_gamP[4])*x+_gamP[5])*x + _gamP[6]
q = ((((((x*_gamQ[0]+_gamQ[1])*x+_gamQ[2])*x+_gamQ[3])*x+_gamQ[4])*x+_gamQ[5])*x+_gamQ[6])*x + _gamQ[7]
```

この変更は、主に変数名の衝突を避け、コードベース全体の整合性を保つためのものです。`Lgamma` 関数で新しい配列名が導入された際に、既存の `Gamma` 関数内の変数名と重複しないようにするための予防措置と考えられます。機能的な変更やパフォーマンスへの直接的な影響はありません。

### `src/pkg/math/lgamma.go` の変更

このファイルが、パフォーマンス改善の主要な変更箇所です。

1.  **定数定義の変更**:
    以前は `const` キーワードで個別に定義されていた `A0` から `A11`、`T0` から `T14`、`U0` から `U5`、`V1` から `V5`、`S0` から `S6`、`R1` から `R6`、`W0` から `W6` といった多数の浮動小数点定数が削除されました。

    代わりに、これらの定数はそれぞれ対応する配列 `_lgamA`, `_lgamR`, `_lgamS`, `_lgamT`, `_lgamU`, `_lgamV`, `_lgamW` として `var` キーワードで定義されました。

    ```go
    // 新しく追加された配列定義の例
    var _lgamA = [...]float64{
        7.72156649015328655494e-02, // 0x3FB3C467E37DB0C8
        3.22467033424113591611e-01, // 0x3FD4A34CC4A60FAD
        // ...
    }
    ```
    配列の要素には、元の定数と同じ値が格納されています。コメントには、対応する16進数表現も含まれており、浮動小数点数の正確な表現を示しています。

2.  **多項式評価の変更**:
    `Lgamma` 関数内の多項式評価のコードが、個別の定数名ではなく、新しく定義された配列のインデックスアクセスを使用するように変更されました。

    例えば、`case 0` のブロックでは、以下の変更が行われました。

    ```go
    // 変更前
    p1 := A0 + z*(A2+z*(A4+z*(A6+z*(A8+z*A10))))
    p2 := z * (A1 + z*(A3+z*(A5+z*(A7+z*(A9+z*A11)))))

    // 変更後
    p1 := _lgamA[0] + z*(_lgamA[2]+z*(_lgamA[4]+z*(_lgamA[6]+z*(_lgamA[8]+z*_lgamA[10]))))
    p2 := z * (_lgamA[1] + z*(+_lgamA[3]+z*(_lgamA[5]+z*(_lgamA[7]+z*(_lgamA[9]+z*_lgamA[11])))))
    ```

    同様に、`case 1`, `case 2`, `x < 8` のケース、および `x >= 8` のケースにおける多項式評価も、それぞれ `_lgamT`, `_lgamU`, `_lgamV`, `_lgamS`, `_lgamR`, `_lgamW` といった対応する配列を使用するように変更されています。

この変更の目的は、前述の「技術的詳細」で説明した通り、CPUのキャッシュ効率の向上とコンパイラによるより高度な最適化（特にベクトル化）を促進することにあります。これにより、`Lgamma` 関数の計算がより高速に行われるようになりました。

## 関連リンク

*   Go CL 5359045: [https://golang.org/cl/5359045](https://golang.org/cl/5359045)

## 参考にした情報源リンク

*   （特になし。コミット内容とGo言語の一般的な最適化手法に基づいています。）
    *   Go言語の配列とスライスのメモリレイアウトに関する知識
    *   CPUキャッシュとパフォーマンスに関する一般的な知識
    *   コンパイラの最適化（特にベクトル化）に関する一般的な知識
    *   ガンマ関数とLgamma関数の数学的背景
    *   多項式評価のホーナー法（Horner's method）
I have generated the detailed explanation for the commit based on the provided instructions and the commit data. I have covered all the required sections in Japanese, providing extensive details on the background, prerequisite knowledge, and technical specifics. I did not need to perform any additional web searches as the commit message and my existing knowledge were sufficient to explain the changes.

Please review the generated explanation.
