# [インデックス 1140] ファイルの概要

このコミットは、Go言語の標準ライブラリにおいて、数値と文字列間の変換処理を大幅に改善し、`strconv`という新しいパッケージを導入するものです。これにより、浮動小数点数の変換における丸め処理の正確性が向上し、整数変換のロジックも一元化されました。

具体的には、以下のファイルが新規作成または変更されています。

**新規作成ファイル:**
- `src/lib/strconv/Makefile`: `strconv`パッケージのビルド設定。
- `src/lib/strconv/atof.go`: 文字列から浮動小数点数への変換（ASCII to Float）。
- `src/lib/strconv/atoi.go`: 文字列から整数への変換（ASCII to Integer）。
- `src/lib/strconv/decimal.go`: 任意精度10進数演算を扱うための内部ヘルパー。浮動小数点数変換の正確な丸めに使用。
- `src/lib/strconv/ftoa.go`: 浮動小数点数から文字列への変換（Float to ASCII）。
- `src/lib/strconv/itoa.go`: 整数から文字列への変換（Integer to ASCII）。
- `src/lib/strconv/test.bash`: `strconv`パッケージのテストスクリプト。
- `src/lib/strconv/testatof.go`: `atof`関数のテスト。
- `src/lib/strconv/testfp.go`: 浮動小数点数変換の包括的なテスト。
- `src/lib/strconv/testfp.txt`: 浮動小数点数テストのデータ。
- `src/lib/strconv/testftoa.go`: `ftoa`関数のテスト。

**変更ファイル:**
- `src/lib/fmt/Makefile`: `fmt`パッケージのビルド設定。
- `src/lib/fmt/format.go`: `fmt`パッケージのフォーマットロジック。浮動小数点数変換を`strconv`に委譲。
- `src/lib/fmt/print.go`: `fmt`パッケージの出力ロジック。浮動小数点数変換を`strconv`に委譲。
- `src/lib/http/server.go`: `strings.atoi`の使用箇所を`strconv.atoi`に更新。
- `src/lib/make.bash`: ビルドディレクトリに`strconv`を追加。
- `src/lib/net/net.go`: `strings.itoa`の使用箇所を`strconv.itoa`に更新。
- `src/lib/reflect/test.go`: `reflect`パッケージのテスト。浮動小数点数のテスト値を更新。
- `src/lib/reflect/tostring.go`: `reflect`パッケージの`ValueToString`関数で`strconv`を使用。
- `src/lib/strings.go`: 浮動小数点数および整数変換関連の関数が削除。
- `src/run.bash`: 変更なし。
- `test/chan/goroutines.go`: 変更なし。
- `test/fmt_test.go`: `fmt`のテスト。
- `test/stringslib.go`: `strings`ライブラリのテスト。

## コミット

```
commit 079c00a475d11f71a69fe848dd67e8fe34ac88a8
Author: Russ Cox <rsc@golang.org>
Date:   Mon Nov 17 12:34:03 2008 -0800

    correctly rounded floating-point conversions
    in new package strconv.
    
    move atoi etc to strconv too.
    
    update fmt, etc to use strconv.
    
    R=r
    DELTA=2232  (1691 added, 424 deleted, 117 changed)
    OCL=19286
    CL=19380
```

## GitHub上でのコミットページへのリンク

[https://github.com/golang/go/commit/079c00a475d11f71a69fe848dd67e8fe34ac88a8](https://github.com/golang/go/commit/079c00a475d11f71a69fe848dd67e8fe34ac88a8)

## 元コミット内容

```
correctly rounded floating-point conversions
in new package strconv.

move atoi etc to strconv too.

update fmt, etc to use strconv.
```

## 変更の背景

このコミットの主な背景には、Go言語の初期開発段階におけるコードベースの整理と、数値変換、特に浮動小数点数変換の正確性向上という二つの重要な目的があります。

1.  **コードのモジュール化と責務の分離:** 以前は、`fmt`パッケージや`strings`パッケージが数値と文字列間の変換ロジックの一部を直接持っていました。これは、各パッケージが自身の主要な責務（フォーマット済みI/Oや文字列操作）に加えて、数値変換という別の責務も担っている状態でした。このような設計は、コードの重複、保守性の低下、そして変換ロジックの一貫性の欠如につながる可能性があります。`strconv`という独立したパッケージを導入することで、数値変換に関するすべてのロジックを一箇所に集約し、各パッケージの責務を明確に分離することができました。これにより、コードの可読性、再利用性、および保守性が向上します。

2.  **浮動小数点数変換の正確性向上:** 浮動小数点数（`float32`, `float64`）と文字列間の変換は、コンピュータサイエンスにおいて非常に複雑で、正確な丸め処理が求められる領域です。特に、IEEE 754標準に準拠した正確な変換は、科学技術計算、金融アプリケーション、データ処理など、多くの分野で不可欠です。従来の変換ロジックでは、特定のケースで丸め誤差が生じたり、最短かつ正確な文字列表現を生成できなかったりする可能性がありました。このコミットは、「correctly rounded floating-point conversions」と明記されており、この問題に対処するために、より堅牢で数学的に正確なアルゴリズムを`strconv`パッケージ内に実装することを目的としています。これにより、Go言語が数値計算において信頼性の高い基盤を提供できるようになります。

これらの変更は、Go言語がより成熟した、堅牢な標準ライブラリを持つための重要な一歩でした。

## 前提知識の解説

このコミットの理解には、以下の技術的な前提知識が役立ちます。

1.  **浮動小数点数 (Floating-Point Numbers) と IEEE 754 標準:**
    *   **定義:** 浮動小数点数は、実数を近似的に表現するためのコンピュータの数値表現形式です。固定小数点数とは異なり、非常に広い範囲の数値を表現できますが、精度には限界があります。
    *   **IEEE 754:** ほとんどの現代のコンピュータシステムで採用されている浮動小数点数の国際標準です。単精度 (32-bit, `float32`) と倍精度 (64-bit, `float64`) が一般的です。
    *   **構造:** 浮動小数点数は通常、以下の3つの部分で構成されます。
        *   **符号部 (Sign Bit):** 数値が正か負かを示します（0: 正, 1: 負）。
        *   **指数部 (Exponent):** 数値の大きさを表します。バイアス形式で表現され、実際の指数を得るにはバイアス値を引く必要があります。
        *   **仮数部 (Mantissa/Significand):** 数値の精度を表す有効数字の部分です。通常、正規化された形式では先頭に暗黙の「1」が仮定されます。
    *   **課題:** 浮動小数点数は2進数で表現されるため、10進数で有限桁の数値（例: 0.1）でも2進数では無限小数になることが多く、正確に表現できない場合があります。このため、変換時に丸め誤差が生じます。

2.  **数値と文字列間の変換:**
    *   **`atof` (ASCII to Float):** 文字列形式の浮動小数点数（例: "3.14"）を、対応する2進浮動小数点数表現に変換するプロセスです。この変換では、入力文字列の10進数値を最も近い2進浮動小数点数に正確に丸めることが重要です。IEEE 754では、「最近接偶数への丸め (round half to even)」などの丸めモードが定義されています。
    *   **`ftoa` (Float to ASCII):** 2進浮動小数点数表現を、人間が読める文字列形式（例: "3.14"）に変換するプロセスです。この変換の主要な課題は、「最短かつ正確な表現 (shortest unique representation)」を見つけることです。例えば、`float64`で表現された0.1は、内部的には0.10000000000000000555...のような値ですが、これを「0.1」と出力するのが理想的です。これは、その2進浮動小数点数を一意に識別できる最短の10進数表現であるためです。この問題は、Dragon4やGrisuなどの複雑なアルゴリズムによって解決されます。
    *   **`atoi` (ASCII to Integer) / `itoa` (Integer to ASCII):** 文字列と整数間の変換です。浮動小数点数変換ほど複雑ではありませんが、オーバーフローのチェックや基数変換（10進数、16進数など）の処理が必要です。

3.  **Go言語のパッケージ構造:**
    *   Go言語の標準ライブラリは、機能ごとにパッケージに分割されています。例えば、`fmt`はフォーマット済みI/O、`strings`は文字列操作を提供します。
    *   このコミット以前は、これらのパッケージが数値変換の一部を担っていましたが、`strconv`パッケージの導入により、数値変換の責務が専門のパッケージに集約されました。

## 技術的詳細

このコミットで導入された`strconv`パッケージは、Go言語における数値と文字列間の変換の基盤を確立しました。特に浮動小数点数変換の正確性を保証するために、高度なアルゴリズムが採用されています。

1.  **`strconv`パッケージの役割:**
    `strconv`は "string conversion" の略であり、Goの組み込み型（ブール値、整数、浮動小数点数）と文字列との間の変換機能を提供します。これにより、数値変換に関するロジックが一元化され、他のパッケージ（`fmt`, `net`, `http`, `reflect`など）は、変換の詳細を気にすることなく、このパッケージの関数を呼び出すだけでよくなりました。

2.  **浮動小数点数変換のアルゴリズム (`atof`, `ftoa`):**
    このコミットの核心は、浮動小数点数変換の正確な丸め処理です。
    *   **任意精度10進数 (`decimal.go`):** `strconv`パッケージは、`Decimal`という内部的な任意精度10進数型を導入しています。これは、浮動小数点数変換の計算中に発生する可能性のある精度損失を避けるために使用されます。`Decimal`型は、10進数の桁をバイト配列として保持し、小数点位置 (`dp`) と桁数 (`nd`) を管理します。
        *   `Shift(k int)`: このメソッドは、10進数を2のべき乗で乗算または除算する（バイナリシフト）操作を正確に実行します。これは、浮動小数点数の指数部を調整する際に必要となります。`LeftShift`と`RightShift`という内部関数が、それぞれ乗算と除算を処理します。特に`LeftShift`では、`leftcheat`というテーブルを使用して、シフトによって導入される新しい桁数を効率的に計算する工夫が見られます。
        *   `RoundedInteger()`: 10進数の整数部分を、適切な丸め（最近接偶数への丸めなど）を適用して抽出します。
    *   **`atof` (文字列から浮動小数点数へ):** `atof.go`では、入力文字列をまず`StringToDecimal`関数で`Decimal`型に変換します。その後、`DecimalToFloatBits`関数が、この任意精度10進数をターゲットの浮動小数点数形式（`float32`または`float64`）のビット表現に変換します。このプロセスでは、`Decimal`型を2のべき乗でシフトして、浮動小数点数の正規化された範囲（[0.5, 1.0) または [1.0, 2.0)）に収まるように調整し、その後、仮数部と指数部を抽出します。
    *   **`ftoa` (浮動小数点数から文字列へ):** `ftoa.go`では、入力された浮動小数点数のビット表現（符号、指数、仮数）を解析します。
        *   まず、仮数部を`NewDecimal`で`Decimal`型に変換し、指数部に基づいて`Shift`操作を行います。これにより、元の浮動小数点数を正確に表す任意精度10進数が得られます。
        *   次に、`RoundShortest`関数が呼び出されます。これは、Goの`ftoa`実装の重要な部分であり、元の浮動小数点数を一意に識別できる最短の10進数表現を生成するために使用されます。この関数は、元の浮動小数点数の「上下の隣接する浮動小数点数」との中間点を計算し、その範囲内で最も短い10進数表現を見つけ出します。これは、Dragon4やGrisuのようなアルゴリズムの原理に基づいています。
        *   最後に、`FmtE`（指数表記）、`FmtF`（固定小数点表記）、`FmtB`（2進数表記）などの関数が、丸められた`Decimal`型を最終的な文字列形式に整形します。

3.  **整数変換 (`atoi`, `itoa`):**
    `atoi.go`と`itoa.go`には、文字列と整数（`int`, `int64`, `uint`, `uint64`）間の基本的な変換ロジックが実装されています。これらは浮動小数点数変換ほど複雑ではありませんが、符号の処理、基数変換、およびオーバーフローの基本的な考慮が含まれています。

4.  **既存パッケージの更新:**
    `fmt`, `http`, `net`, `reflect`などの既存のパッケージは、数値変換が必要な箇所で、直接変換ロジックを持つ代わりに、新しく導入された`strconv`パッケージの関数を呼び出すように変更されました。これにより、コードベース全体で数値変換の一貫性と正確性が保証されます。

## コアとなるコードの変更箇所

このコミットの主要な変更は、`src/lib/strconv`ディレクトリの新規作成と、既存の`src/lib/fmt/format.go`、`src/lib/fmt/print.go`、`src/lib/strings.go`における数値変換ロジックの移管と置き換えです。

### `src/lib/fmt/format.go` の変更

浮動小数点数 (`float64`, `float32`) のフォーマット処理が、`strconv`パッケージの関数に委譲されています。

**変更前:**
```go
// floating-point
func (f *Fmt) e64(a float64) *Fmt {
	// ... 独自の浮動小数点数変換ロジック ...
}

func (f *Fmt) f64(a float64) *Fmt {
	// ... 独自の浮動小数点数変換ロジック ...
}
// ... 他の浮動小数点数変換関数 ...
```

**変更後:**
```go
package fmt

import "strconv" // strconvパッケージをインポート

// ...

func (f *Fmt) e64(a float64) *Fmt {
	return FmtString(f, strconv.ftoa64(a, 'e', Prec(f, 6))); // strconv.ftoa64を呼び出す
}

func (f *Fmt) f64(a float64) *Fmt {
	return FmtString(f, strconv.ftoa64(a, 'f', Prec(f, 6))); // strconv.ftoa64を呼び出す
}

func (f *Fmt) g64(a float64) *Fmt {
	return FmtString(f, strconv.ftoa64(a, 'g', Prec(f, -1))); // strconv.ftoa64を呼び出す
}

func (f *Fmt) fb64(a float64) *Fmt {
	return FmtString(f, strconv.ftoa64(a, 'b', 0)); // strconv.ftoa64を呼び出す
}

// float32についても同様にstrconv.ftoa32を呼び出す
func (f *Fmt) e32(a float32) *Fmt {
	return FmtString(f, strconv.ftoa32(a, 'e', Prec(f, -1)));
}

func (f *Fmt) f32(a float32) *Fmt {
	return FmtString(f, strconv.ftoa32(a, 'f', Prec(f, 6)));
}

func (f *Fmt) g32(a float32) *Fmt {
	return FmtString(f, strconv.ftoa32(a, 'g', Prec(f, -1)));
}

func (f *Fmt) fb32(a float32) *Fmt {
	return FmtString(f, strconv.ftoa32(a, 'b', 0));
}

// float型（float32またはfloat64のエイリアス）の処理もstrconv.floatsizeに基づいて分岐
func (x *Fmt) f(a float) *Fmt {
	if strconv.floatsize == 32 {
		return x.f32(float32(a))
	}
	return x.f64(float64(a))
}
// ... 他のfloat型変換関数も同様 ...
```

### `src/lib/strings.go` の変更

`strings`パッケージから、数値変換に関連する関数（`atoi`, `ltoa`, `f64toa`など）が削除されました。これらの機能は`strconv`パッケージに移管されました。

**変更前:**
```go
// src/lib/strings.go (削除された部分の例)
func atoi(s string) (i int, ok bool) { ... }
func ltoa(i int64) string { ... }
func f64toa(f float64) string { ... }
```

**変更後:**
該当する関数定義がファイルから完全に削除されています。

### `src/lib/strconv/ftoa.go` (新規作成)

浮動小数点数から文字列への変換ロジックがここに実装されています。

```go
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Binary to decimal floating point conversion.
// Algorithm:
//   1) store mantissa in multiprecision decimal
//   2) shift decimal by exponent
//   3) read digits out & format

package strconv

import "strconv" // 自身のパッケージをインポートしているが、これはGoの初期の構文の可能性あり

// FloatInfo struct defines properties of float types (mantissa bits, exponent bits, bias)
package type FloatInfo struct {
	mantbits uint;
	expbits uint;
	bias int;
}
package var float32info = FloatInfo{ 23, 8, -127 }
package var float64info = FloatInfo{ 52, 11, -1023 }

// ftoa32 and ftoa64 are the main entry points for float to string conversion
export func ftoa32(f float32, fmt byte, prec int) string {
	return GenericFtoa(uint64(sys.float32bits(f)), fmt, prec, &float32info);
}

export func ftoa64(f float64, fmt byte, prec int) string {
	return GenericFtoa(sys.float64bits(f), fmt, prec, &float64info);
}

// GenericFtoa handles the core conversion logic
func GenericFtoa(bits uint64, fmt byte, prec int, flt *FloatInfo) string {
	// ... NaN, Inf, denormalized numbersの処理 ...

	// Create exact decimal representation.
	// The shift is exp - flt.mantbits because mant is a 1-bit integer
	// followed by a flt.mantbits fraction, and we are treating it as
	// a 1+flt.mantbits-bit integer.
	d := NewDecimal(mant).Shift(exp - int(flt.mantbits)); // 任意精度Decimalに変換し、指数でシフト

	// Round appropriately.
	// Negative precision means "only as much as needed to be exact."
	if prec < 0 {
		RoundShortest(d, mant, exp, flt); // 最短表現への丸め
		// ... 精度設定 ...
	} else {
		// ... 指定された精度への丸め ...
	}

	switch fmt {
	case 'e':
		return FmtE(neg, d, prec); // 指数表記でフォーマット
	case 'f':
		return FmtF(neg, d, prec); // 固定小数点表記でフォーマット
	case 'g':
		// ... 'g' フォーマットのロジック ...
	}
	// ...
}

// RoundShortest is crucial for generating the shortest unique decimal representation
func RoundShortest(d *Decimal, mant uint64, exp int, flt *FloatInfo) {
	// ... 上限と下限を計算し、その範囲内で最短の10進数表現を見つけるロジック ...
}

// FmtE, FmtF, FmtB handle the final string formatting
func FmtE(neg bool, d *Decimal, prec int) string { ... }
func FmtF(neg bool, d *Decimal, prec int) string { ... }
func FmtB(neg bool, mant uint64, exp int, flt *FloatInfo) string { ... }
```

## コアとなるコードの解説

### `fmt`パッケージの変更点

`fmt`パッケージは、Go言語におけるフォーマット済みI/O（`fmt.Printf`, `fmt.Sprintf`など）を担当します。このコミット以前は、`fmt`パッケージ内に浮動小数点数を文字列に変換する独自のロジックが含まれていました。しかし、このコミットにより、そのロジックは`strconv`パッケージに移管され、`fmt`は`strconv`の関数を呼び出すようになりました。

*   **`import "strconv"`:** `fmt/format.go`の冒頭に`strconv`パッケージのインポートが追加されています。これにより、`fmt`パッケージが`strconv`の機能を利用できるようになります。
*   **`strconv.ftoa64(a, 'e', Prec(f, 6))`:** 以前は`fmt`内部で実装されていた`e64`（指数表記の`float64`フォーマット）のような関数が、`strconv.ftoa64`を呼び出すように変更されています。
    *   `a`: 変換対象の`float64`値。
    *   `'e'`: フォーマットの種類（指数表記）。
    *   `Prec(f, 6)`: 精度（小数点以下の桁数）を指定します。`Prec`関数は、`fmt`のフォーマットフラグで指定された精度を返すか、デフォルト値（`e`と`f`では6、`g`では-1で最短表現）を使用します。
*   **`strconv.floatsize`による分岐:** `float`型（Goの組み込み型で、実装によって`float32`または`float64`のいずれかになる）の変換では、`strconv.floatsize`という変数を使って、実行環境の`float`が32ビットか64ビットかを判定し、適切な`ftoa32`または`ftoa64`を呼び出しています。これは、Goの初期段階で`float`のサイズが固定されていなかったことの名残です。

これらの変更により、`fmt`パッケージは数値のフォーマット表示に特化し、実際の数値変換の複雑なロジックは`strconv`に任せるという、よりクリーンな責務分離が実現されました。

### `strconv/ftoa.go` の主要ロジック

`ftoa.go`は、2進浮動小数点数を正確な10進数文字列に変換する核心的なロジックを含んでいます。

1.  **`GenericFtoa`関数:**
    この関数は、`ftoa32`と`ftoa64`の両方から呼び出される汎用的な変換エントリポイントです。
    *   **ビットの解析:** 入力された浮動小数点数のビット表現（`bits`）から、符号 (`neg`)、指数 (`exp`)、仮数 (`mant`) を抽出します。
    *   **特殊値の処理:** `NaN` (Not a Number) や `Inf` (Infinity) といった特殊な浮動小数点数値を最初に処理し、それぞれ "NaN", "-Inf", "+Inf" といった文字列を返します。
    *   **任意精度10進数への変換:**
        `d := NewDecimal(mant).Shift(exp - int(flt.mantbits));`
        この行が変換の鍵です。
        *   `NewDecimal(mant)`: 浮動小数点数の仮数部を、`Decimal`という任意精度10進数型として初期化します。例えば、`float64`の仮数部が`1.xxxx...`であれば、`Decimal`は`1xxxx...`という10進数を保持します。
        *   `.Shift(exp - int(flt.mantbits))`: この`Shift`メソッドが、`Decimal`型の値を2のべき乗で乗算または除算します。`exp - int(flt.mantbits)`は、仮数部が表す数値の実際のスケール（指数）を調整するためのシフト量です。これにより、元の2進浮動小数点数が表す正確な10進数値が`d`に格納されます。
    *   **丸め処理 (`RoundShortest`):**
        `RoundShortest(d, mant, exp, flt);`
        これが「最短かつ正確な表現」を生成するための最も重要なステップです。
        *   この関数は、現在の`Decimal`値`d`が、元の浮動小数点数を一意に識別できる最短の10進数表現であるかどうかを判断します。
        *   具体的には、元の浮動小数点数の「すぐ上の浮動小数点数」と「すぐ下の浮動小数点数」を計算し、それらの中間点を10進数で表現します。
        *   そして、`d`がその中間点との関係で、どの桁までが元の浮動小数点数を一意に識別するために必要かを判断し、不要な末尾の桁を丸めます。このプロセスは、IEEE 754の丸め規則（特に「最近接偶数への丸め」）を考慮に入れています。
        *   このアルゴリズムは、Dragon4やGrisuといった現代の浮動小数点数変換アルゴリズムの原理に基づいています。

2.  **`strconv/decimal.go` の `Decimal` 型と `Shift` メソッド:**
    `decimal.go`は、`ftoa.go`や`atof.go`で利用される任意精度10進数演算の基盤を提供します。
    *   **`type Decimal struct { d [2000] byte; nd int; dp int; }`:**
        *   `d`: 10進数の各桁をバイトとして格納する配列。`[2000]byte`というサイズは、非常に大きな桁数に対応できることを示唆しています。
        *   `nd`: `d`配列内で実際に使用されている桁数。
        *   `dp`: 小数点の位置。例えば、`d`が`[1, 2, 3]`で`dp`が2なら`12.3`を意味します。
    *   **`func (a *Decimal) Shift(k int) *Decimal`:**
        このメソッドは、`Decimal`型の値を2のべき乗で乗算（`k > 0`）または除算（`k < 0`）します。
        *   内部的には、`LeftShift`（乗算）と`RightShift`（除算）という関数を呼び出します。
        *   これらの関数は、10進数の桁配列を操作して、2進数のシフト操作を正確にシミュレートします。例えば、10進数`1`を2倍すると`2`ですが、10進数`5`を2倍すると`10`となり桁数が増えます。このような桁数の変化を正確に処理するために、`LeftCheat`テーブルのような工夫が用いられています。

これらの変更と新しいパッケージの導入により、Go言語は数値変換において高い正確性と信頼性を実現し、その後のGoの発展における数値計算の基盤を固めました。

## 関連リンク

*   Go言語 `strconv` パッケージのドキュメント: [https://pkg.go.dev/strconv](https://pkg.go.dev/strconv)
*   Go言語 `fmt` パッケージのドキュメント: [https://pkg.go.dev/fmt](https://pkg.go.dev/fmt)
*   IEEE 754 浮動小数点数標準 (Wikipedia): [https://ja.wikipedia.org/wiki/IEEE_754](https://ja.wikipedia.org/wiki/IEEE_754)

## 参考にした情報源リンク

*   "How to Print Floating-Point Numbers Accurately" by David Gay (Dragon4 algorithm): [https://www.cs.berkeley.edu/~wkahan/V7.ps](https://www.cs.berkeley.edu/~wkahan/V7.ps) (直接の参照ではないが、Goの`ftoa`の背景にあるアルゴリズムの基礎)
*   "Printing Floating-Point Numbers Quickly and Accurately with Integers" (Grisu algorithm): [https://www.ryanjuckett.com/programming/printing-floating-point-numbers/](https://www.ryanjuckett.com/programming/printing-floating-point-numbers/) (直接の参照ではないが、Goの`ftoa`の背景にあるアルゴリズムの基礎)
*   Go言語の初期のコミット履歴と設計に関する議論（GoのメーリングリストやIssueトラッカーなど、当時の情報源）
*   Go言語のソースコード（特に`src/strconv`ディレクトリ内のファイル）
# [インデックス 1140] ファイルの概要

このコミットは、Go言語の標準ライブラリにおいて、数値と文字列間の変換処理を大幅に改善し、`strconv`という新しいパッケージを導入するものです。これにより、浮動小数点数の変換における丸め処理の正確性が向上し、整数変換のロジックも一元化されました。

具体的には、以下のファイルが新規作成または変更されています。

**新規作成ファイル:**
- `src/lib/strconv/Makefile`: `strconv`パッケージのビルド設定。
- `src/lib/strconv/atof.go`: 文字列から浮動小数点数への変換（ASCII to Float）。
- `src/lib/strconv/atoi.go`: 文字列から整数への変換（ASCII to Integer）。
- `src/lib/strconv/decimal.go`: 任意精度10進数演算を扱うための内部ヘルパー。浮動小数点数変換の正確な丸めに使用。
- `src/lib/strconv/ftoa.go`: 浮動小数点数から文字列への変換（Float to ASCII）。
- `src/lib/strconv/itoa.go`: 整数から文字列への変換（Integer to ASCII）。
- `src/lib/strconv/test.bash`: `strconv`パッケージのテストスクリプト。
- `src/lib/strconv/testatof.go`: `atof`関数のテスト。
- `src/lib/strconv/testfp.go`: 浮動小数点数変換の包括的なテスト。
- `src/lib/strconv/testfp.txt`: 浮動小数点数テストのデータ。
- `src/lib/strconv/testftoa.go`: `ftoa`関数のテスト。

**変更ファイル:**
- `src/lib/fmt/Makefile`: `fmt`パッケージのビルド設定。
- `src/lib/fmt/format.go`: `fmt`パッケージのフォーマットロジック。浮動小数点数変換を`strconv`に委譲。
- `src/lib/fmt/print.go`: `fmt`パッケージの出力ロジック。浮動小数点数変換を`strconv`に委譲。
- `src/lib/http/server.go`: `strings.atoi`の使用箇所を`strconv.atoi`に更新。
- `src/lib/make.bash`: ビルドディレクトリに`strconv`を追加。
- `src/lib/net/net.go`: `strings.itoa`の使用箇所を`strconv.itoa`に更新。
- `src/lib/reflect/test.go`: `reflect`パッケージのテスト。浮動小数点数のテスト値を更新。
- `src/lib/reflect/tostring.go`: `reflect`パッケージの`ValueToString`関数で`strconv`を使用。
- `src/lib/strings.go`: 浮動小数点数および整数変換関連の関数が削除。
- `src/run.bash`: 変更なし。
- `test/chan/goroutines.go`: 変更なし。
- `test/fmt_test.go`: `fmt`のテスト。
- `test/stringslib.go`: `strings`ライブラリのテスト。

## コミット

```
commit 079c00a475d11f71a69fe848dd67e8fe34ac88a8
Author: Russ Cox <rsc@golang.org>
Date:   Mon Nov 17 12:34:03 2008 -0800

    correctly rounded floating-point conversions
    in new package strconv.
    
    move atoi etc to strconv too.
    
    update fmt, etc to use strconv.
    
    R=r
    DELTA=2232  (1691 added, 424 deleted, 117 changed)
    OCL=19286
    CL=19380
```

## GitHub上でのコミットページへのリンク

[https://github.com/golang/go/commit/079c00a475d11f71a69fe848dd67e8fe34ac88a8](https://github.com/golang/go/commit/079c00a475d11f71a69fe848dd67e8fe34ac88a8)

## 元コミット内容

```
correctly rounded floating-point conversions
in new package strconv.

move atoi etc to strconv too.

update fmt, etc to use strconv.
```

## 変更の背景

このコミットの主な背景には、Go言語の初期開発段階におけるコードベースの整理と、数値変換、特に浮動小数点数変換の正確性向上という二つの重要な目的があります。

1.  **コードのモジュール化と責務の分離:** 以前は、`fmt`パッケージや`strings`パッケージが数値と文字列間の変換ロジックの一部を直接持っていました。これは、各パッケージが自身の主要な責務（フォーマット済みI/Oや文字列操作）に加えて、数値変換という別の責務も担っている状態でした。このような設計は、コードの重複、保守性の低下、そして変換ロジックの一貫性の欠如につながる可能性があります。`strconv`という独立したパッケージを導入することで、数値変換に関するすべてのロジックを一箇所に集約し、各パッケージの責務を明確に分離することができました。これにより、コードの可読性、再利用性、および保守性が向上します。

2.  **浮動小数点数変換の正確性向上:** 浮動小数点数（`float32`, `float64`）と文字列間の変換は、コンピュータサイエンスにおいて非常に複雑で、正確な丸め処理が求められる領域です。特に、IEEE 754標準に準拠した正確な変換は、科学技術計算、金融アプリケーション、データ処理など、多くの分野で不可欠です。従来の変換ロジックでは、特定のケースで丸め誤差が生じたり、最短かつ正確な文字列表現を生成できなかったりする可能性がありました。このコミットは、「correctly rounded floating-point conversions」と明記されており、この問題に対処するために、より堅牢で数学的に正確なアルゴリズムを`strconv`パッケージ内に実装することを目的としています。これにより、Go言語が数値計算において信頼性の高い基盤を提供できるようになります。

これらの変更は、Go言語がより成熟した、堅牢な標準ライブラリを持つための重要な一歩でした。

## 前提知識の解説

このコミットの理解には、以下の技術的な前提知識が役立ちます。

1.  **浮動小数点数 (Floating-Point Numbers) と IEEE 754 標準:**
    *   **定義:** 浮動小数点数は、実数を近似的に表現するためのコンピュータの数値表現形式です。固定小数点数とは異なり、非常に広い範囲の数値を表現できますが、精度には限界があります。
    *   **IEEE 754:** ほとんどの現代のコンピュータシステムで採用されている浮動小数点数の国際標準です。単精度 (32-bit, `float32`) と倍精度 (64-bit, `float64`) が一般的です。
    *   **構造:** 浮動小数点数は通常、以下の3つの部分で構成されます。
        *   **符号部 (Sign Bit):** 数値が正か負かを示します（0: 正, 1: 負）。
        *   **指数部 (Exponent):** 数値の大きさを表します。バイアス形式で表現され、実際の指数を得るにはバイアス値を引く必要があります。
        *   **仮数部 (Mantissa/Significand):** 数値の精度を表す有効数字の部分です。通常、正規化された形式では先頭に暗黙の「1」が仮定されます。
    *   **課題:** 浮動小数点数は2進数で表現されるため、10進数で有限桁の数値（例: 0.1）でも2進数では無限小数になることが多く、正確に表現できない場合があります。このため、変換時に丸め誤差が生じます。

2.  **数値と文字列間の変換:**
    *   **`atof` (ASCII to Float):** 文字列形式の浮動小数点数（例: "3.14"）を、対応する2進浮動小数点数表現に変換するプロセスです。この変換では、入力文字列の10進数値を最も近い2進浮動小数点数に正確に丸めることが重要です。IEEE 754では、「最近接偶数への丸め (round half to even)」などの丸めモードが定義されています。
    *   **`ftoa` (Float to ASCII):** 2進浮動小数点数表現を、人間が読める文字列形式（例: "3.14"）に変換するプロセスです。この変換の主要な課題は、「最短かつ正確な表現 (shortest unique representation)」を見つけることです。例えば、`float64`で表現された0.1は、内部的には0.10000000000000000555...のような値ですが、これを「0.1」と出力するのが理想的です。これは、その2進浮動小数点数を一意に識別できる最短の10進数表現であるためです。この問題は、Dragon4やGrisuなどの複雑なアルゴリズムによって解決されます。
    *   **`atoi` (ASCII to Integer) / `itoa` (Integer to ASCII):** 文字列と整数間の変換です。浮動小数点数変換ほど複雑ではありませんが、オーバーフローのチェックや基数変換（10進数、16進数など）の処理が必要です。

3.  **Go言語のパッケージ構造:**
    *   Go言語の標準ライブラリは、機能ごとにパッケージに分割されています。例えば、`fmt`はフォーマット済みI/O、`strings`は文字列操作を提供します。
    *   このコミット以前は、これらのパッケージが数値変換の一部を担っていましたが、`strconv`パッケージの導入により、数値変換の責務が専門のパッケージに集約されました。

## 技術的詳細

このコミットで導入された`strconv`パッケージは、Go言語における数値と文字列間の変換の基盤を確立しました。特に浮動小数点数変換の正確性を保証するために、高度なアルゴリズムが採用されています。

1.  **`strconv`パッケージの役割:**
    `strconv`は "string conversion" の略であり、Goの組み込み型（ブール値、整数、浮動小数点数）と文字列との間の変換機能を提供します。これにより、数値変換に関するロジックが一元化され、他のパッケージ（`fmt`, `net`, `http`, `reflect`など）は、変換の詳細を気にすることなく、このパッケージの関数を呼び出すだけでよくなりました。

2.  **浮動小数点数変換のアルゴリズム (`atof`, `ftoa`):**
    このコミットの核心は、浮動小数点数変換の正確な丸め処理です。
    *   **任意精度10進数 (`decimal.go`):** `strconv`パッケージは、`Decimal`という内部的な任意精度10進数型を導入しています。これは、浮動小数点数変換の計算中に発生する可能性のある精度損失を避けるために使用されます。`Decimal`型は、10進数の桁をバイト配列として保持し、小数点位置 (`dp`) と桁数 (`nd`) を管理します。
        *   `Shift(k int)`: このメソッドは、10進数を2のべき乗で乗算または除算する（バイナリシフト）操作を正確に実行します。これは、浮動小数点数の指数部を調整する際に必要となります。`LeftShift`と`RightShift`という内部関数が、それぞれ乗算と除算を処理します。特に`LeftShift`では、`leftcheat`というテーブルを使用して、シフトによって導入される新しい桁数を効率的に計算する工夫が見られます。
        *   `RoundedInteger()`: 10進数の整数部分を、適切な丸め（最近接偶数への丸めなど）を適用して抽出します。
    *   **`atof` (文字列から浮動小数点数へ):** `atof.go`では、入力文字列をまず`StringToDecimal`関数で`Decimal`型に変換します。その後、`DecimalToFloatBits`関数が、この任意精度10進数をターゲットの浮動小数点数形式（`float32`または`float64`）のビット表現に変換します。このプロセスでは、`Decimal`型を2のべき乗でシフトして、浮動小数点数の正規化された範囲（[0.5, 1.0) または [1.0, 2.0)）に収まるように調整し、その後、仮数部と指数部を抽出します。
    *   **`ftoa` (浮動小数点数から文字列へ):** `ftoa.go`では、入力された浮動小数点数のビット表現（符号、指数、仮数）を解析します。
        *   まず、仮数部を`NewDecimal`で`Decimal`型に変換し、指数部に基づいて`Shift`操作を行います。これにより、元の浮動小数点数を正確に表す任意精度10進数が得られます。
        *   次に、`RoundShortest`関数が呼び出されます。これは、Goの`ftoa`実装の重要な部分であり、元の浮動小数点数を一意に識別できる最短の10進数表現を生成するために使用されます。この関数は、元の浮動小数点数の「上下の隣接する浮動小数点数」との中間点を計算し、その範囲内で最も短い10進数表現を見つけ出します。これは、Dragon4やGrisuなどの複雑なアルゴリズムの原理に基づいています。
        *   最後に、`FmtE`（指数表記）、`FmtF`（固定小数点表記）、`FmtB`（2進数表記）などの関数が、丸められた`Decimal`型を最終的な文字列形式に整形します。

3.  **整数変換 (`atoi`, `itoa`):**
    `atoi.go`と`itoa.go`には、文字列と整数（`int`, `int64`, `uint`, `uint64`）間の基本的な変換ロジックが実装されています。これらは浮動小数点数変換ほど複雑ではありませんが、符号の処理、基数変換、およびオーバーフローの基本的な考慮が含まれています。

4.  **既存パッケージの更新:**
    `fmt`, `http`, `net`, `reflect`などの既存のパッケージは、数値変換が必要な箇所で、直接変換ロジックを持つ代わりに、新しく導入された`strconv`パッケージの関数を呼び出すように変更されました。これにより、コードベース全体で数値変換の一貫性と正確性が保証されます。

## コアとなるコードの変更箇所

このコミットの主要な変更は、`src/lib/strconv`ディレクトリの新規作成と、既存の`src/lib/fmt/format.go`、`src/lib/fmt/print.go`、`src/lib/strings.go`における数値変換ロジックの移管と置き換えです。

### `src/lib/fmt/format.go` の変更

浮動小数点数 (`float64`, `float32`) のフォーマット処理が、`strconv`パッケージの関数に委譲されています。

**変更前:**
```go
// floating-point
func (f *Fmt) e64(a float64) *Fmt {
	// ... 独自の浮動小数点数変換ロジック ...
}

func (f *Fmt) f64(a float64) *Fmt {
	// ... 独自の浮動小数点数変換ロジック ...
}
// ... 他の浮動小数点数変換関数 ...
```

**変更後:**
```go
package fmt

import "strconv" // strconvパッケージをインポート

// ...

func (f *Fmt) e64(a float64) *Fmt {
	return FmtString(f, strconv.ftoa64(a, 'e', Prec(f, 6))); // strconv.ftoa64を呼び出す
}

func (f *Fmt) f64(a float64) *Fmt {
	return FmtString(f, strconv.ftoa64(a, 'f', Prec(f, 6))); // strconv.ftoa64を呼び出す
}

func (f *Fmt) g64(a float64) *Fmt {
	return FmtString(f, strconv.ftoa64(a, 'g', Prec(f, -1))); // strconv.ftoa64を呼び出す
}

func (f *Fmt) fb64(a float64) *Fmt {
	return FmtString(f, strconv.ftoa64(a, 'b', 0)); // strconv.ftoa64を呼び出す
}

// float32についても同様にstrconv.ftoa32を呼び出す
func (f *Fmt) e32(a float32) *Fmt {
	return FmtString(f, strconv.ftoa32(a, 'e', Prec(f, -1)));
}

func (f *Fmt) f32(a float32) *Fmt {
	return FmtString(f, strconv.ftoa32(a, 'f', Prec(f, 6)));
}

func (f *Fmt) g32(a float32) *Fmt {
	return FmtString(f, strconv.ftoa32(a, 'g', Prec(f, -1)));
}

func (f *Fmt) fb32(a float32) *Fmt {
	return FmtString(f, strconv.ftoa32(a, 'b', 0));
}

// float型（float32またはfloat64のエイリアス）の処理もstrconv.floatsizeに基づいて分岐
func (x *Fmt) f(a float) *Fmt {
	if strconv.floatsize == 32 {
		return x.f32(float32(a))
	}
	return x.f64(float64(a))
}
// ... 他のfloat型変換関数も同様 ...
```

### `src/lib/strings.go` の変更

`strings`パッケージから、数値変換に関連する関数（`atoi`, `ltoa`, `f64toa`など）が削除されました。これらの機能は`strconv`パッケージに移管されました。

**変更前:**
```go
// src/lib/strings.go (削除された部分の例)
func atoi(s string) (i int, ok bool) { ... }
func ltoa(i int64) string { ... }
func f64toa(f float64) string { ... }
```

**変更後:**
該当する関数定義がファイルから完全に削除されています。

### `src/lib/strconv/ftoa.go` (新規作成)

浮動小数点数から文字列への変換ロジックがここに実装されています。

```go
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Binary to decimal floating point conversion.
// Algorithm:
//   1) store mantissa in multiprecision decimal
//   2) shift decimal by exponent
//   3) read digits out & format

package strconv

import "strconv" // 自身のパッケージをインポートしているが、これはGoの初期の構文の可能性あり

// FloatInfo struct defines properties of float types (mantissa bits, exponent bits, bias)
package type FloatInfo struct {
	mantbits uint;
	expbits uint;
	bias int;
}
package var float32info = FloatInfo{ 23, 8, -127 }
package var float64info = FloatInfo{ 52, 11, -1023 }

// ftoa32 and ftoa64 are the main entry points for float to string conversion
export func ftoa32(f float32, fmt byte, prec int) string {
	return GenericFtoa(uint64(sys.float32bits(f)), fmt, prec, &float32info);
}

export func ftoa64(f float64, fmt byte, prec int) string {
	return GenericFtoa(sys.float64bits(f), fmt, prec, &float64info);
}

// GenericFtoa handles the core conversion logic
func GenericFtoa(bits uint64, fmt byte, prec int, flt *FloatInfo) string {
	// ... NaN, Inf, denormalized numbersの処理 ...

	// Create exact decimal representation.
	// The shift is exp - flt.mantbits because mant is a 1-bit integer
	// followed by a flt.mantbits fraction, and we are treating it as
	// a 1+flt.mantbits-bit integer.
	d := NewDecimal(mant).Shift(exp - int(flt.mantbits)); // 任意精度Decimalに変換し、指数でシフト

	// Round appropriately.
	// Negative precision means "only as much as needed to be exact."
	if prec < 0 {
		RoundShortest(d, mant, exp, flt); // 最短表現への丸め
		// ... 精度設定 ...
	} else {
		// ... 指定された精度への丸め ...
	}

	switch fmt {
	case 'e':
		return FmtE(neg, d, prec); // 指数表記でフォーマット
	case 'f':
		return FmtF(neg, d, prec); // 固定小数点表記でフォーマット
	case 'g':
		// ... 'g' フォーマットのロジック ...
	}
	// ...
}

// RoundShortest is crucial for generating the shortest unique decimal representation
func RoundShortest(d *Decimal, mant uint64, exp int, flt *FloatInfo) {
	// ... 上限と下限を計算し、その範囲内で最短の10進数表現を見つけるロジック ...
}

// FmtE, FmtF, FmtB handle the final string formatting
func FmtE(neg bool, d *Decimal, prec int) string { ... }
func FmtF(neg bool, d *Decimal, prec int) string { ... }
func FmtB(neg bool, mant uint64, exp int, flt *FloatInfo) string { ... }
```

## コアとなるコードの解説

### `fmt`パッケージの変更点

`fmt`パッケージは、Go言語におけるフォーマット済みI/O（`fmt.Printf`, `fmt.Sprintf`など）を担当します。このコミット以前は、`fmt`パッケージ内に浮動小数点数を文字列に変換する独自のロジックが含まれていました。しかし、このコミットにより、そのロジックは`strconv`パッケージに移管され、`fmt`は`strconv`の関数を呼び出すようになりました。

*   **`import "strconv"`:** `fmt/format.go`の冒頭に`strconv`パッケージのインポートが追加されています。これにより、`fmt`パッケージが`strconv`の機能を利用できるようになります。
*   **`strconv.ftoa64(a, 'e', Prec(f, 6))`:** 以前は`fmt`内部で実装されていた`e64`（指数表記の`float64`フォーマット）のような関数が、`strconv.ftoa64`を呼び出すように変更されています。
    *   `a`: 変換対象の`float64`値。
    *   `'e'`: フォーマットの種類（指数表記）。
    *   `Prec(f, 6)`: 精度（小数点以下の桁数）を指定します。`Prec`関数は、`fmt`のフォーマットフラグで指定された精度を返すか、デフォルト値（`e`と`f`では6、`g`では-1で最短表現）を使用します。
*   **`strconv.floatsize`による分岐:** `float`型（Goの組み込み型で、実装によって`float32`または`float64`のいずれかになる）の変換では、`strconv.floatsize`という変数を使って、実行環境の`float`が32ビットか64ビットかを判定し、適切な`ftoa32`または`ftoa64`を呼び出しています。これは、Goの初期段階で`float`のサイズが固定されていなかったことの名残です。

これらの変更により、`fmt`パッケージは数値のフォーマット表示に特化し、実際の数値変換の複雑なロジックは`strconv`に任せるという、よりクリーンな責務分離が実現されました。

### `strconv/ftoa.go` の主要ロジック

`ftoa.go`は、2進浮動小数点数を正確な10進数文字列に変換する核心的なロジックを含んでいます。

1.  **`GenericFtoa`関数:**
    この関数は、`ftoa32`と`ftoa64`の両方から呼び出される汎用的な変換エントリポイントです。
    *   **ビットの解析:** 入力された浮動小数点数のビット表現（`bits`）から、符号 (`neg`)、指数 (`exp`)、仮数 (`mant`) を抽出します。
    *   **特殊値の処理:** `NaN` (Not a Number) や `Inf` (Infinity) といった特殊な浮動小数点数値を最初に処理し、それぞれ "NaN", "-Inf", "+Inf" といった文字列を返します。
    *   **任意精度10進数への変換:**
        `d := NewDecimal(mant).Shift(exp - int(flt.mantbits));`
        この行が変換の鍵です。
        *   `NewDecimal(mant)`: 浮動小数点数の仮数部を、`Decimal`という任意精度10進数型として初期化します。例えば、`float64`の仮数部が`1.xxxx...`であれば、`Decimal`は`1xxxx...`という10進数を保持します。
        *   `.Shift(exp - int(flt.mantbits))`: この`Shift`メソッドが、`Decimal`型の値を2のべき乗で乗算または除算します。`exp - int(flt.mantbits)`は、仮数部が表す数値の実際のスケール（指数）を調整するためのシフト量です。これにより、元の2進浮動小数点数が表す正確な10進数値が`d`に格納されます。
    *   **丸め処理 (`RoundShortest`):**
        `RoundShortest(d, mant, exp, flt);`
        これが「最短かつ正確な表現」を生成するための最も重要なステップです。
        *   この関数は、現在の`Decimal`値`d`が、元の浮動小数点数を一意に識別できる最短の10進数表現であるかどうかを判断します。
        *   具体的には、元の浮動小数点数の「すぐ上の浮動小数点数」と「すぐ下の浮動小数点数」を計算し、それらの中間点を10進数で表現します。
        *   そして、`d`がその中間点との関係で、どの桁までが元の浮動小数点数を一意に識別するために必要かを判断し、不要な末尾の桁を丸めます。このプロセスは、IEEE 754の丸め規則（特に「最近接偶数への丸め」）を考慮に入れています。
        *   このアルゴリズムは、Dragon4やGrisuといった現代の浮動小数点数変換アルゴリズムの原理に基づいています。

2.  **`strconv/decimal.go` の `Decimal` 型と `Shift` メソッド:**
    `decimal.go`は、`ftoa.go`や`atof.go`で利用される任意精度10進数演算の基盤を提供します。
    *   **`type Decimal struct { d [2000] byte; nd int; dp int; }`:**
        *   `d`: 10進数の各桁をバイトとして格納する配列。`[2000]byte`というサイズは、非常に大きな桁数に対応できることを示唆しています。
        *   `nd`: `d`配列内で実際に使用されている桁数。
        *   `dp`: 小数点の位置。例えば、`d`が`[1, 2, 3]`で`dp`が2なら`12.3`を意味します。
    *   **`func (a *Decimal) Shift(k int) *Decimal`:**
        このメソッドは、`Decimal`型の値を2のべき乗で乗算（`k > 0`）または除算（`k < 0`）します。
        *   内部的には、`LeftShift`（乗算）と`RightShift`（除算）という関数を呼び出します。
        *   これらの関数は、10進数の桁配列を操作して、2進数のシフト操作を正確にシミュレートします。例えば、10進数`1`を2倍すると`2`ですが、10進数`5`を2倍すると`10`となり桁数が増えます。このような桁数の変化を正確に処理するために、`LeftCheat`テーブルのような工夫が用いられています。

これらの変更と新しいパッケージの導入により、Go言語は数値変換において高い正確性と信頼性を実現し、その後のGoの発展における数値計算の基盤を固めました。

## 関連リンク

*   Go言語 `strconv` パッケージのドキュメント: [https://pkg.go.dev/strconv](https://pkg.go.dev/strconv)
*   Go言語 `fmt` パッケージのドキュメント: [https://pkg.go.dev/fmt](https://pkg.go.dev/fmt)
*   IEEE 754 浮動小数点数標準 (Wikipedia): [https://ja.wikipedia.org/wiki/IEEE_754](https://ja.wikipedia.org/wiki/IEEE_754)

## 参考にした情報源リンク

*   "How to Print Floating-Point Numbers Accurately" by David Gay (Dragon4 algorithm): [https://www.cs.berkeley.edu/~wkahan/V7.ps](https://www.cs.berkeley.edu/~wkahan/V7.ps) (直接の参照ではないが、Goの`ftoa`の背景にあるアルゴリズムの基礎)
*   "Printing Floating-Point Numbers Quickly and Accurately with Integers" (Grisu algorithm): [https://www.ryanjuckett.com/programming/printing-floating-point-numbers/](https://www.ryanjuckett.com/programming/printing-floating-point-numbers/) (直接の参照ではないが、Goの`ftoa`の背景にあるアルゴリズムの基礎)
*   Go言語の初期のコミット履歴と設計に関する議論（GoのメーリングリストやIssueトラッカーなど、当時の情報源）
*   Go言語のソースコード（特に`src/strconv`ディレクトリ内のファイル）
# [インデックス 1140] ファイルの概要

このコミットは、Go言語の標準ライブラリにおいて、数値と文字列間の変換処理を大幅に改善し、`strconv`という新しいパッケージを導入するものです。これにより、浮動小数点数の変換における丸め処理の正確性が向上し、整数変換のロジックも一元化されました。

具体的には、以下のファイルが新規作成または変更されています。

**新規作成ファイル:**
- `src/lib/strconv/Makefile`: `strconv`パッケージのビルド設定。
- `src/lib/strconv/atof.go`: 文字列から浮動小数点数への変換（ASCII to Float）。
- `src/lib/strconv/atoi.go`: 文字列から整数への変換（ASCII to Integer）。
- `src/lib/strconv/decimal.go`: 任意精度10進数演算を扱うための内部ヘルパー。浮動小数点数変換の正確な丸めに使用。
- `src/lib/strconv/ftoa.go`: 浮動小数点数から文字列への変換（Float to ASCII）。
- `src/lib/strconv/itoa.go`: 整数から文字列への変換（Integer to ASCII）。
- `src/lib/strconv/test.bash`: `strconv`パッケージのテストスクリプト。
- `src/lib/strconv/testatof.go`: `atof`関数のテスト。
- `src/lib/strconv/testfp.go`: 浮動小数点数変換の包括的なテスト。
- `src/lib/strconv/testfp.txt`: 浮動小数点数テストのデータ。
- `src/lib/strconv/testftoa.go`: `ftoa`関数のテスト。

**変更ファイル:**
- `src/lib/fmt/Makefile`: `fmt`パッケージのビルド設定。
- `src/lib/fmt/format.go`: `fmt`パッケージのフォーマットロジック。浮動小数点数変換を`strconv`に委譲。
- `src/lib/fmt/print.go`: `fmt`パッケージの出力ロジック。浮動小数点数変換を`strconv`に委譲。
- `src/lib/http/server.go`: `strings.atoi`の使用箇所を`strconv.atoi`に更新。
- `src/lib/make.bash`: ビルドディレクトリに`strconv`を追加。
- `src/lib/net/net.go`: `strings.itoa`の使用箇所を`strconv.itoa`に更新。
- `src/lib/reflect/test.go`: `reflect`パッケージのテスト。浮動小数点数のテスト値を更新。
- `src/lib/reflect/tostring.go`: `reflect`パッケージの`ValueToString`関数で`strconv`を使用。
- `src/lib/strings.go`: 浮動小数点数および整数変換関連の関数が削除。
- `src/run.bash`: 変更なし。
- `test/chan/goroutines.go`: 変更なし。
- `test/fmt_test.go`: `fmt`のテスト。
- `test/stringslib.go`: `strings`ライブラリのテスト。

## コミット

```
commit 079c00a475d11f71a69fe848dd67e8fe34ac88a8
Author: Russ Cox <rsc@golang.org>
Date:   Mon Nov 17 12:34:03 2008 -0800

    correctly rounded floating-point conversions
    in new package strconv.
    
    move atoi etc to strconv too.
    
    update fmt, etc to use strconv.
    
    R=r
    DELTA=2232  (1691 added, 424 deleted, 117 changed)
    OCL=19286
    CL=19380
```

## GitHub上でのコミットページへのリンク

[https://github.com/golang/go/commit/079c00a475d11f71a69fe848dd67e8fe34ac88a8](https://github.com/golang/go/commit/079c00a475d11f71a69fe848dd67e8fe34ac88a8)

## 元コミット内容

```
correctly rounded floating-point conversions
in new package strconv.

move atoi etc to strconv too.

update fmt, etc to use strconv.
```

## 変更の背景

このコミットの主な背景には、Go言語の初期開発段階におけるコードベースの整理と、数値変換、特に浮動小数点数変換の正確性向上という二つの重要な目的があります。

1.  **コードのモジュール化と責務の分離:** 以前は、`fmt`パッケージや`strings`パッケージが数値と文字列間の変換ロジックの一部を直接持っていました。これは、各パッケージが自身の主要な責務（フォーマット済みI/Oや文字列操作）に加えて、数値変換という別の責務も担っている状態でした。このような設計は、コードの重複、保守性の低下、そして変換ロジックの一貫性の欠如につながる可能性があります。`strconv`という独立したパッケージを導入することで、数値変換に関するすべてのロジックを一箇所に集約し、各パッケージの責務を明確に分離することができました。これにより、コードの可読性、再利用性、および保守性が向上します。

2.  **浮動小数点数変換の正確性向上:** 浮動小数点数（`float32`, `float64`）と文字列間の変換は、コンピュータサイエンスにおいて非常に複雑で、正確な丸め処理が求められる領域です。特に、IEEE 754標準に準拠した正確な変換は、科学技術計算、金融アプリケーション、データ処理など、多くの分野で不可欠です。従来の変換ロジックでは、特定のケースで丸め誤差が生じたり、最短かつ正確な文字列表現を生成できなかったりする可能性がありました。このコミットは、「correctly rounded floating-point conversions」と明記されており、この問題に対処するために、より堅牢で数学的に正確なアルゴリズムを`strconv`パッケージ内に実装することを目的としています。これにより、Go言語が数値計算において信頼性の高い基盤を提供できるようになります。

これらの変更は、Go言語がより成熟した、堅牢な標準ライブラリを持つための重要な一歩でした。

## 前提知識の解説

このコミットの理解には、以下の技術的な前提知識が役立ちます。

1.  **浮動小数点数 (Floating-Point Numbers) と IEEE 754 標準:**
    *   **定義:** 浮動小数点数は、実数を近似的に表現するためのコンピュータの数値表現形式です。固定小数点数とは異なり、非常に広い範囲の数値を表現できますが、精度には限界があります。
    *   **IEEE 754:** ほとんどの現代のコンピュータシステムで採用されている浮動小数点数の国際標準です。単精度 (32-bit, `float32`) と倍精度 (64-bit, `float64`) が一般的です。
    *   **構造:** 浮動小数点数は通常、以下の3つの部分で構成されます。
        *   **符号部 (Sign Bit):** 数値が正か負かを示します（0: 正, 1: 負）。
        *   **指数部 (Exponent):** 数値の大きさを表します。バイアス形式で表現され、実際の指数を得るにはバイアス値を引く必要があります。
        *   **仮数部 (Mantissa/Significand):** 数値の精度を表す有効数字の部分です。通常、正規化された形式では先頭に暗黙の「1」が仮定されます。
    *   **課題:** 浮動小数点数は2進数で表現されるため、10進数で有限桁の数値（例: 0.1）でも2進数では無限小数になることが多く、正確に表現できない場合があります。このため、変換時に丸め誤差が生じます。

2.  **数値と文字列間の変換:**
    *   **`atof` (ASCII to Float):** 文字列形式の浮動小数点数（例: "3.14"）を、対応する2進浮動小数点数表現に変換するプロセスです。この変換では、入力文字列の10進数値を最も近い2進浮動小数点数に正確に丸めることが重要です。IEEE 754では、「最近接偶数への丸め (round half to even)」などの丸めモードが定義されています。
    *   **`ftoa` (Float to ASCII):** 2進浮動小数点数表現を、人間が読める文字列形式（例: "3.14"）に変換するプロセスです。この変換の主要な課題は、「最短かつ正確な表現 (shortest unique representation)」を見つけることです。例えば、`float64`で表現された0.1は、内部的には0.10000000000000000555...のような値ですが、これを「0.1」と出力するのが理想的です。これは、その2進浮動小数点数を一意に識別できる最短の10進数表現であるためです。この問題は、Dragon4やGrisuなどの複雑なアルゴリズムによって解決されます。
    *   **`atoi` (ASCII to Integer) / `itoa` (Integer to ASCII):** 文字列と整数間の変換です。浮動小数点数変換ほど複雑ではありませんが、オーバーフローのチェックや基数変換（10進数、16進数など）の処理が必要です。

3.  **Go言語のパッケージ構造:**
    *   Go言語の標準ライブラリは、機能ごとにパッケージに分割されています。例えば、`fmt`はフォーマット済みI/O、`strings`は文字列操作を提供します。
    *   このコミット以前は、これらのパッケージが数値変換の一部を担っていましたが、`strconv`パッケージの導入により、数値変換の責務が専門のパッケージに集約されました。

## 技術的詳細

このコミットで導入された`strconv`パッケージは、Go言語における数値と文字列間の変換の基盤を確立しました。特に浮動小数点数変換の正確性を保証するために、高度なアルゴリズムが採用されています。

1.  **`strconv`パッケージの役割:**
    `strconv`は "string conversion" の略であり、Goの組み込み型（ブール値、整数、浮動小数点数）と文字列との間の変換機能を提供します。これにより、数値変換に関するロジックが一元化され、他のパッケージ（`fmt`, `net`, `http`, `reflect`など）は、変換の詳細を気にすることなく、このパッケージの関数を呼び出すだけでよくなりました。

2.  **浮動小数点数変換のアルゴリズム (`atof`, `ftoa`):**
    このコミットの核心は、浮動小数点数変換の正確な丸め処理です。
    *   **任意精度10進数 (`decimal.go`):** `strconv`パッケージは、`Decimal`という内部的な任意精度10進数型を導入しています。これは、浮動小数点数変換の計算中に発生する可能性のある精度損失を避けるために使用されます。`Decimal`型は、10進数の桁をバイト配列として保持し、小数点位置 (`dp`) と桁数 (`nd`) を管理します。
        *   `Shift(k int)`: このメソッドは、10進数を2のべき乗で乗算または除算する（バイナリシフト）操作を正確に実行します。これは、浮動小数点数の指数部を調整する際に必要となります。`LeftShift`と`RightShift`という内部関数が、それぞれ乗算と除算を処理します。特に`LeftShift`では、`leftcheat`というテーブルを使用して、シフトによって導入される新しい桁数を効率的に計算する工夫が見られます。
        *   `RoundedInteger()`: 10進数の整数部分を、適切な丸め（最近接偶数への丸めなど）を適用して抽出します。
    *   **`atof` (文字列から浮動小数点数へ):** `atof.go`では、入力文字列をまず`StringToDecimal`関数で`Decimal`型に変換します。その後、`DecimalToFloatBits`関数が、この任意精度10進数をターゲットの浮動小数点数形式（`float32`または`float64`）のビット表現に変換します。このプロセスでは、`Decimal`型を2のべき乗でシフトして、浮動小数点数の正規化された範囲（[0.5, 1.0) または [1.0, 2.0)）に収まるように調整し、その後、仮数部と指数部を抽出します。
    *   **`ftoa` (浮動小数点数から文字列へ):** `ftoa.go`では、入力された浮動小数点数のビット表現（符号、指数、仮数）を解析します。
        *   まず、仮数部を`NewDecimal`で`Decimal`型に変換し、指数部に基づいて`Shift`操作を行います。これにより、元の浮動小数点数を正確に表す任意精度10進数が得られます。
        *   次に、`RoundShortest`関数が呼び出されます。これは、Goの`ftoa`実装の重要な部分であり、元の浮動小数点数を一意に識別できる最短の10進数表現を生成するために使用されます。この関数は、元の浮動小数点数の「上下の隣接する浮動小数点数」との中間点を計算し、その範囲内で最も短い10進数表現を見つけ出します。これは、Dragon4やGrisuなどの複雑なアルゴリズムの原理に基づいています。
        *   最後に、`FmtE`（指数表記）、`FmtF`（固定小数点表記）、`FmtB`（2進数表記）などの関数が、丸められた`Decimal`型を最終的な文字列形式に整形します。

3.  **整数変換 (`atoi`, `itoa`):**
    `atoi.go`と`itoa.go`には、文字列と整数（`int`, `int64`, `uint`, `uint64`）間の基本的な変換ロジックが実装されています。これらは浮動小数点数変換ほど複雑ではありませんが、符号の処理、基数変換、およびオーバーフローの基本的な考慮が含まれています。

4.  **既存パッケージの更新:**
    `fmt`, `http`, `net`, `reflect`などの既存のパッケージは、数値変換が必要な箇所で、直接変換ロジックを持つ代わりに、新しく導入された`strconv`パッケージの関数を呼び出すように変更されました。これにより、コードベース全体で数値変換の一貫性と正確性が保証されます。

## コアとなるコードの変更箇所

このコミットの主要な変更は、`src/lib/strconv`ディレクトリの新規作成と、既存の`src/lib/fmt/format.go`、`src/lib/fmt/print.go`、`src/lib/strings.go`における数値変換ロジックの移管と置き換えです。

### `src/lib/fmt/format.go` の変更

浮動小数点数 (`float64`, `float32`) のフォーマット処理が、`strconv`パッケージの関数に委譲されています。

**変更前:**
```go
// floating-point
func (f *Fmt) e64(a float64) *Fmt {
	// ... 独自の浮動小数点数変換ロジック ...
}

func (f *Fmt) f64(a float64) *Fmt {
	// ... 独自の浮動小数点数変換ロジック ...
}
// ... 他の浮動小数点数変換関数 ...
```

**変更後:**
```go
package fmt

import "strconv" // strconvパッケージをインポート

// ...

func (f *Fmt) e64(a float64) *Fmt {
	return FmtString(f, strconv.ftoa64(a, 'e', Prec(f, 6))); // strconv.ftoa64を呼び出す
}

func (f *Fmt) f64(a float64) *Fmt {
	return FmtString(f, strconv.ftoa64(a, 'f', Prec(f, 6))); // strconv.ftoa64を呼び出す
}

func (f *Fmt) g64(a float64) *Fmt {
	return FmtString(f, strconv.ftoa64(a, 'g', Prec(f, -1))); // strconv.ftoa64を呼び出す
}

func (f *Fmt) fb64(a float64) *Fmt {
	return FmtString(f, strconv.ftoa64(a, 'b', 0)); // strconv.ftoa64を呼び出す
}

// float32についても同様にstrconv.ftoa32を呼び出す
func (f *Fmt) e32(a float32) *Fmt {
	return FmtString(f, strconv.ftoa32(a, 'e', Prec(f, -1)));
}

func (f *Fmt) f32(a float32) *Fmt {
	return FmtString(f, strconv.ftoa32(a, 'f', Prec(f, 6)));
}

func (f *Fmt) g32(a float32) *Fmt {
	return FmtString(f, strconv.ftoa32(a, 'g', Prec(f, -1)));
}

func (f *Fmt) fb32(a float32) *Fmt {
	return FmtString(f, strconv.ftoa32(a, 'b', 0));
}

// float型（float32またはfloat64のエイリアス）の処理もstrconv.floatsizeに基づいて分岐
func (x *Fmt) f(a float) *Fmt {
	if strconv.floatsize == 32 {
		return x.f32(float32(a))
	}
	return x.f64(float64(a))
}
// ... 他のfloat型変換関数も同様 ...
```

### `src/lib/strings.go` の変更

`strings`パッケージから、数値変換に関連する関数（`atoi`, `ltoa`, `f64toa`など）が削除されました。これらの機能は`strconv`パッケージに移管されました。

**変更前:**
```go
// src/lib/strings.go (削除された部分の例)
func atoi(s string) (i int, ok bool) { ... }
func ltoa(i int64) string { ... }
func f64toa(f float64) string { ... }
```

**変更後:**
該当する関数定義がファイルから完全に削除されています。

### `src/lib/strconv/ftoa.go` (新規作成)

浮動小数点数から文字列への変換ロジックがここに実装されています。

```go
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Binary to decimal floating point conversion.
// Algorithm:
//   1) store mantissa in multiprecision decimal
//   2) shift decimal by exponent
//   3) read digits out & format

package strconv

import "strconv" // 自身のパッケージをインポートしているが、これはGoの初期の構文の可能性あり

// FloatInfo struct defines properties of float types (mantissa bits, exponent bits, bias)
package type FloatInfo struct {
	mantbits uint;
	expbits uint;
	bias int;
}
package var float32info = FloatInfo{ 23, 8, -127 }
package var float64info = FloatInfo{ 52, 11, -1023 }

// ftoa32 and ftoa64 are the main entry points for float to string conversion
export func ftoa32(f float32, fmt byte, prec int) string {
	return GenericFtoa(uint64(sys.float32bits(f)), fmt, prec, &float32info);
}

export func ftoa64(f float64, fmt byte, prec int) string {
	return GenericFtoa(sys.float64bits(f), fmt, prec, &float64info);
}

// GenericFtoa handles the core conversion logic
func GenericFtoa(bits uint64, fmt byte, prec int, flt *FloatInfo) string {
	// ... NaN, Inf, denormalized numbersの処理 ...

	// Create exact decimal representation.
	// The shift is exp - flt.mantbits because mant is a 1-bit integer
	// followed by a flt.mantbits fraction, and we are treating it as
	// a 1+flt.mantbits-bit integer.
	d := NewDecimal(mant).Shift(exp - int(flt.mantbits)); // 任意精度Decimalに変換し、指数でシフト

	// Round appropriately.
	// Negative precision means "only as much as needed to be exact."
	if prec < 0 {
		RoundShortest(d, mant, exp, flt); // 最短表現への丸め
		// ... 精度設定 ...
	} else {
		// ... 指定された精度への丸め ...
	}

	switch fmt {
	case 'e':
		return FmtE(neg, d, prec); // 指数表記でフォーマット
	case 'f':
		return FmtF(neg, d, prec); // 固定小数点表記でフォーマット
	case 'g':
		// ... 'g' フォーマットのロジック ...
	}
	// ...
}

// RoundShortest is crucial for generating the shortest unique decimal representation
func RoundShortest(d *Decimal, mant uint64, exp int, flt *FloatInfo) {
	// ... 上限と下限を計算し、その範囲内で最短の10進数表現を見つけるロジック ...
}

// FmtE, FmtF, FmtB handle the final string formatting
func FmtE(neg bool, d *Decimal, prec int) string { ... }
func FmtF(neg bool, d *Decimal, prec int) string { ... }
func FmtB(neg bool, mant uint64, exp int, flt *FloatInfo) string { ... }
```

## コアとなるコードの解説

### `fmt`パッケージの変更点

`fmt`パッケージは、Go言語におけるフォーマット済みI/O（`fmt.Printf`, `fmt.Sprintf`など）を担当します。このコミット以前は、`fmt`パッケージ内に浮動小数点数を文字列に変換する独自のロジックが含まれていました。しかし、このコミットにより、そのロジックは`strconv`パッケージに移管され、`fmt`は`strconv`の関数を呼び出すようになりました。

*   **`import "strconv"`:** `fmt/format.go`の冒頭に`strconv`パッケージのインポートが追加されています。これにより、`fmt`パッケージが`strconv`の機能を利用できるようになります。
*   **`strconv.ftoa64(a, 'e', Prec(f, 6))`:** 以前は`fmt`内部で実装されていた`e64`（指数表記の`float64`フォーマット）のような関数が、`strconv.ftoa64`を呼び出すように変更されています。
    *   `a`: 変換対象の`float64`値。
    *   `'e'`: フォーマットの種類（指数表記）。
    *   `Prec(f, 6)`: 精度（小数点以下の桁数）を指定します。`Prec`関数は、`fmt`のフォーマットフラグで指定された精度を返すか、デフォルト値（`e`と`f`では6、`g`では-1で最短表現）を使用します。
*   **`strconv.floatsize`による分岐:** `float`型（Goの組み込み型で、実装によって`float32`または`float64`のいずれかになる）の変換では、`strconv.floatsize`という変数を使って、実行環境の`float`が32ビットか64ビットかを判定し、適切な`ftoa32`または`ftoa64`を呼び出しています。これは、Goの初期段階で`float`のサイズが固定されていなかったことの名残です。

これらの変更により、`fmt`パッケージは数値のフォーマット表示に特化し、実際の数値変換の複雑なロジックは`strconv`に任せるという、よりクリーンな責務分離が実現されました。

### `strconv/ftoa.go` の主要ロジック

`ftoa.go`は、2進浮動小数点数を正確な10進数文字列に変換する核心的なロジックを含んでいます。

1.  **`GenericFtoa`関数:**
    この関数は、`ftoa32`と`ftoa64`の両方から呼び出される汎用的な変換エントリポイントです。
    *   **ビットの解析:** 入力された浮動小数点数のビット表現（`bits`）から、符号 (`neg`)、指数 (`exp`)、仮数 (`mant`) を抽出します。
    *   **特殊値の処理:** `NaN` (Not a Number) や `Inf` (Infinity) といった特殊な浮動小数点数値を最初に処理し、それぞれ "NaN", "-Inf", "+Inf" といった文字列を返します。
    *   **任意精度10進数への変換:**
        `d := NewDecimal(mant).Shift(exp - int(flt.mantbits));`
        この行が変換の鍵です。
        *   `NewDecimal(mant)`: 浮動小数点数の仮数部を、`Decimal`という任意精度10進数型として初期化します。例えば、`float64`の仮数部が`1.xxxx...`であれば、`Decimal`は`1xxxx...`という10進数を保持します。
        *   `.Shift(exp - int(flt.mantbits))`: この`Shift`メソッドが、`Decimal`型の値を2のべき乗で乗算または除算します。`exp - int(flt.mantbits)`は、仮数部が表す数値の実際のスケール（指数）を調整するためのシフト量です。これにより、元の2進浮動小数点数が表す正確な10進数値が`d`に格納されます。
    *   **丸め処理 (`RoundShortest`):**
        `RoundShortest(d, mant, exp, flt);`
        これが「最短かつ正確な表現」を生成するための最も重要なステップです。
        *   この関数は、現在の`Decimal`値`d`が、元の浮動小数点数を一意に識別できる最短の10進数表現であるかどうかを判断します。
        *   具体的には、元の浮動小数点数の「すぐ上の浮動小数点数」と「すぐ下の浮動小数点数」を計算し、それらの中間点を10進数で表現します。
        *   そして、`d`がその中間点との関係で、どの桁までが元の浮動小数点数を一意に識別するために必要かを判断し、不要な末尾の桁を丸めます。このプロセスは、IEEE 754の丸め規則（特に「最近接偶数への丸め」）を考慮に入れています。
        *   このアルゴリズムは、Dragon4やGrisuといった現代の浮動小数点数変換アルゴリズムの原理に基づいています。

2.  **`strconv/decimal.go` の `Decimal` 型と `Shift` メソッド:**
    `decimal.go`は、`ftoa.go`や`atof.go`で利用される任意精度10進数演算の基盤を提供します。
    *   **`type Decimal struct { d [2000] byte; nd int; dp int; }`:**
        *   `d`: 10進数の各桁をバイトとして格納する配列。`[2000]byte`というサイズは、非常に大きな桁数に対応できることを示唆しています。
        *   `nd`: `d`配列内で実際に使用されている桁数。
        *   `dp`: 小数点の位置。例えば、`d`が`[1, 2, 3]`で`dp`が2なら`12.3`を意味します。
    *   **`func (a *Decimal) Shift(k int) *Decimal`:**
        このメソッドは、`Decimal`型の値を2のべき乗で乗算（`k > 0`）または除算（`k < 0`）します。
        *   内部的には、`LeftShift`（乗算）と`RightShift`（除算）という関数を呼び出します。
        *   これらの関数は、10進数の桁配列を操作して、2進数のシフト操作を正確にシミュレートします。例えば、10進数`1`を2倍すると`2`ですが、10進数`5`を2倍すると`10`となり桁数が増えます。このような桁数の変化を正確に処理するために、`LeftCheat`テーブルのような工夫が用いられています。

これらの変更と新しいパッケージの導入により、Go言語は数値変換において高い正確性と信頼性を実現し、その後のGoの発展における数値計算の基盤を固めました。

## 関連リンク

*   Go言語 `strconv` パッケージのドキュメント: [https://pkg.go.dev/strconv](https://pkg.go.dev/strconv)
*   Go言語 `fmt` パッケージのドキュメント: [https://pkg.go.dev/fmt](https://pkg.go.dev/fmt)
*   IEEE 754 浮動小数点数標準 (Wikipedia): [https://ja.wikipedia.org/wiki/IEEE_754](https://ja.wikipedia.org/wiki/IEEE_754)

## 参考にした情報源リンク

*   "How to Print Floating-Point Numbers Accurately" by David Gay (Dragon4 algorithm): [https://www.cs.berkeley.edu/~wkahan/V7.ps](https://www.cs.berkeley.edu/~wkahan/V7.ps) (直接の参照ではないが、Goの`ftoa`の背景にあるアルゴリズムの基礎)
*   "Printing Floating-Point Numbers Quickly and Accurately with Integers" (Grisu algorithm): [https://www.ryanjuckett.com/programming/printing-floating-point-numbers/](https://www.ryanjuckett.com/programming/printing-floating-point-numbers/) (直接の参照ではないが、Goの`ftoa`の背景にあるアルゴリズムの基礎)
*   Go言語の初期のコミット履歴と設計に関する議論（GoのメーリングリストやIssueトラッカーなど、当時の情報源）
*   Go言語のソースコード（特に`src/strconv`ディレクトリ内のファイル）

