commit 40621d5c0d3f9fc222089967ab1aec44e94b5f78
Author: Robert Griesemer <gri@golang.org>
Date:   Mon Nov 9 12:07:39 2009 -0800

    remove semis after statements in one-statement statement lists
    
    R=rsc, r
    http://go/go-review/1025029
---
 misc/cgo/gmp/fib.go                            |   4 +-
 misc/cgo/gmp/gmp.go                            |  24 +-
 misc/cgo/gmp/pi.go                             |   6 +-
 misc/cgo/stdio/fib.go                          |   2 +-
 misc/cgo/stdio/hello.go                        |   2 +-
 src/cmd/cgo/ast.go                             |  72 ++--
 src/cmd/cgo/gcc.go                             | 144 +++----
 src/cmd/cgo/main.go                            |  12 +-
 src/cmd/cgo/out.go                             |  10 +-
 src/cmd/cgo/util.go                            |  16 +-
 src/cmd/ebnflint/ebnflint.go                   |  20 +-
 src/cmd/godoc/godoc.go                         | 128 +++---
 src/cmd/godoc/index.go                         |  70 ++--
 src/cmd/godoc/main.go                          |  26 +-
 src/cmd/godoc/snippet.go                       |  20 +-
 src/cmd/godoc/spec.go                          |  24 +-
 src/cmd/gofmt/gofmt.go                         |  36 +-
 src/cmd/goyacc/goyacc.go                       | 538 ++++++++++++-------------
 src/cmd/hgpatch/main.go                        |  48 +--
 src/pkg/archive/tar/reader.go                  |  38 +-
 src/pkg/archive/tar/reader_test.go             |  18 +-
 src/pkg/archive/tar/writer.go                  |  24 +-
 src/pkg/archive/tar/writer_test.go             |  12 +-
 src/pkg/asn1/asn1.go                           | 140 +++----
 src/pkg/asn1/asn1_test.go                      |  40 +-
 src/pkg/big/arith.go                           |  32 +-
 src/pkg/big/arith_test.go                      |  16 +-
 src/pkg/big/int.go                             |  46 +--
 src/pkg/big/int_test.go                        |  40 +-
 src/pkg/big/nat.go                             |  88 ++--
 src/pkg/big/nat_test.go                        |  14 +-
 src/pkg/bignum/arith.go                        |   2 +-
 src/pkg/bignum/bignum.go                       | 132 +++---
 src/pkg/bignum/bignum_test.go                  |  62 +--
 src/pkg/bignum/integer.go                      |  60 +--
 src/pkg/bignum/nrdiv_test.go                   |  22 +-
 src/pkg/bignum/rational.go                     |  16 +-
 src/pkg/bufio/bufio.go                         |  72 ++--
 src/pkg/bufio/bufio_test.go                    |  68 ++--
 src/pkg/bytes/buffer.go                        |  16 +-
 src/pkg/bytes/buffer_test.go                   |  40 +-
 src/pkg/bytes/bytes.go                         |  64 +--
 src/pkg/bytes/bytes_test.go                    |  36 +-
 src/pkg/compress/flate/deflate.go              |  70 ++--
 src/pkg/compress/flate/deflate_test.go         |  14 +-
 src/pkg/compress/flate/flate_test.go           |   6 +-
 src/pkg/compress/flate/huffman_bit_writer.go   |  50 +--
 src/pkg/compress/flate/huffman_code.go         |  22 +-
 src/pkg/compress/flate/inflate.go              | 104 ++---
 src/pkg/compress/flate/reverse_bits.go         |   4 +-
 src/pkg/compress/flate/token.go                |   8 +-
 src/pkg/compress/flate/util.go                 |  20 +-
 src/pkg/compress/gzip/gunzip.go                |  38 +-
 src/pkg/compress/gzip/gunzip_test.go           |   6 +-
 src/pkg/compress/zlib/reader.go                |  16 +-
 src/pkg/compress/zlib/reader_test.go           |   6 +-
 src/pkg/compress/zlib/writer.go                |  22 +-
 src/pkg/compress/zlib/writer_test.go           |   6 +-
 src/pkg/container/heap/heap.go                 |   8 +-
 src/pkg/container/heap/heap_test.go            |  10 +-
 src/pkg/container/list/list.go                 |  32 +-
 src/pkg/container/list/list_test.go            |  20 +-
 src/pkg/container/ring/ring.go                 |  18 +-
 src/pkg/container/ring/ring_test.go            |  34 +-
 src/pkg/container/vector/intvector.go          |  10 +-
 src/pkg/container/vector/stringvector.go       |  12 +-
 src/pkg/container/vector/vector.go             |  22 +-
 src/pkg/container/vector/vector_test.go        |  72 ++--
 src/pkg/crypto/aes/aes_test.go                 |  20 +-
 src/pkg/crypto/aes/block.go                    |  12 +-
 src/pkg/crypto/aes/cipher.go                   |  10 +-
 src/pkg/crypto/block/cbc.go                    |   8 +-
 src/pkg/crypto/block/cbc_aes_test.go           |  10 +-
 src/pkg/crypto/block/cfb.go                    |  18 +-
 src/pkg/crypto/block/cfb_aes_test.go           |  12 +-
 src/pkg/crypto/block/cipher.go                 |   6 +-
 src/pkg/crypto/block/cmac.go                   |  18 +-
 src/pkg/crypto/block/ctr.go                    |   6 +-
 src/pkg/crypto/block/ctr_aes_test.go           |  10 +-
 src/pkg/crypto/block/eax.go                    |  32 +-
 src/pkg/crypto/block/eax_aes_test.go           |  14 +-
 src/pkg/crypto/block/ecb.go                    |  42 +-
 src/pkg/crypto/block/ecb_aes_test.go           |  10 +-
 src/pkg/crypto/block/ecb_test.go               |  30 +-
 src/pkg/crypto/block/ofb.go                    |   6 +-
 src/pkg/crypto/block/ofb_aes_test.go           |  10 +-
 src/pkg/crypto/block/xor.go                    |  12 +-
 src/pkg/crypto/block/xor_test.go               |  20 +-
 src/pkg/crypto/hmac/hmac.go                    |  10 +-
 src/pkg/crypto/hmac/hmac_test.go               |   2 +-
 src/pkg/crypto/md5/md5.go                      |  14 +-
 src/pkg/crypto/rc4/rc4.go                      |   8 +-
 src/pkg/crypto/rsa/pkcs1v15.go                 |  12 +-
 src/pkg/crypto/rsa/pkcs1v15_test.go            |  22 +-
 src/pkg/crypto/rsa/rsa.go                      |  30 +-
 src/pkg/crypto/rsa/rsa_test.go                 |  14 +-
 src/pkg/crypto/sha1/sha1.go                    |  14 +-
 src/pkg/crypto/subtle/constant_time.go         |   4 +-
 src/pkg/crypto/subtle/constant_time_test.go    |  24 +-
 src/pkg/crypto/tls/common.go                   |   4 +-
 src/pkg/crypto/tls/handshake_messages.go       |  32 +-
 src/pkg/crypto/tls/handshake_messages_test.go  |   4 +-
 src/pkg/crypto/tls/handshake_server_test.go    |  18 +-
 src/pkg/crypto/tls/prf.go                      |   6 +-
 src/pkg/crypto/tls/prf_test.go                 |   4 +-
 src/pkg/crypto/tls/record_process.go           |  34 +-
 src/pkg/crypto/tls/record_process_test.go      |  12 +-
 src/pkg/crypto/tls/record_read.go              |   6 +-
 src/pkg/crypto/tls/record_read_test.go         |   8 +-
 src/pkg/crypto/tls/record_write.go             |  18 +-
 src/pkg/crypto/tls/tls.go                      |  14 +-
 src/pkg/crypto/x509/x509.go                    |   6 +-
 src/pkg/crypto/x509/x509_test.go               |   4 +-
 src/pkg/debug/dwarf/buf.go                     |  20 +-
 src/pkg/debug/dwarf/const.go                   |   8 +-
 src/pkg/debug/dwarf/entry.go                   |  80 ++--
 src/pkg/debug/dwarf/open.go                    |  12 +-
 src/pkg/debug/dwarf/type.go                    |  90 ++---
 src/pkg/debug/dwarf/type_test.go               |  28 +-
 src/pkg/debug/dwarf/unit.go                    |   6 +-
 src/pkg/debug/elf/elf.go                       |  12 +-
 src/pkg/debug/elf/elf_test.go                  |   2 +-
 src/pkg/debug/elf/file.go                      |  72 ++--
 src/pkg/debug/elf/file_test.go                 |   6 +-
 src/pkg/debug/gosym/pclntab.go                 |   8 +-
 src/pkg/debug/gosym/pclntab_test.go            |  46 +--
 src/pkg/debug/gosym/symtab.go                  |  92 ++---
 src/pkg/debug/macho/file.go                    |  36 +-
 src/pkg/debug/macho/file_test.go               |  14 +-
 src/pkg/debug/macho/macho.go                   |  10 +-
 src/pkg/debug/proc/proc.go                     |   8 +-
 src/pkg/debug/proc/proc_darwin.go              |   4 +-
 src/pkg/debug/proc/proc_linux.go               | 200 ++++-----
 src/pkg/debug/proc/proc_nacl.go                |   4 +-
 src/pkg/debug/proc/regs_linux_386.go           |  68 ++--
 src/pkg/debug/proc/regs_linux_amd64.go         | 102 ++---
 src/pkg/debug/proc/regs_linux_arm.go           |   2 +-
 src/pkg/ebnf/ebnf.go                           |  26 +-
 src/pkg/ebnf/ebnf_test.go                      |   8 +-
 src/pkg/ebnf/parser.go                         |  32 +-
 src/pkg/encoding/ascii85/ascii85.go            |  36 +-
 src/pkg/encoding/ascii85/ascii85_test.go       |  20 +-
 src/pkg/encoding/base64/base64.go              |  50 +--
 src/pkg/encoding/base64/base64_test.go         |  22 +-
 src/pkg/encoding/binary/binary.go              |  60 +--
 src/pkg/encoding/binary/binary_test.go         |   6 +-
 src/pkg/encoding/git85/git.go                  |  46 +--
 src/pkg/encoding/git85/git_test.go             |  26 +-
 src/pkg/encoding/hex/hex.go                    |  16 +-
 src/pkg/encoding/hex/hex_test.go               |  16 +-
 src/pkg/encoding/pem/pem.go                    |  22 +-
 src/pkg/encoding/pem/pem_test.go               |   8 +-
 src/pkg/exec/exec.go                           |  60 +--
 src/pkg/exec/exec_test.go                      |  16 +-
 src/pkg/exp/4s/4s.go                           |  12 +-
 src/pkg/exp/4s/xs.go                           |  98 ++---
 src/pkg/exp/datafmt/datafmt.go                 |  72 ++--
 src/pkg/exp/datafmt/datafmt_test.go            |  14 +-
 src/pkg/exp/datafmt/parser.go                  |  62 +--
 src/pkg/exp/draw/arith.go                      |  36 +-
 src/pkg/exp/draw/color.go                      |  16 +-
 src/pkg/exp/draw/draw.go                       |  14 +-
 src/pkg/exp/eval/abort.go                      |  10 +-
 src/pkg/exp/eval/bridge.go                     |  58 +--
 src/pkg/exp/eval/eval_test.go                  |  26 +-
 src/pkg/exp/eval/expr.go                       | 344 ++++++++--------
 src/pkg/exp/eval/expr1.go                      | 528 ++++++++++++------------
 src/pkg/exp/eval/func.go                       |   4 +-
 src/pkg/exp/eval/gen.go                        |   4 +-
 src/pkg/exp/eval/main.go                       |   8 +-
 src/pkg/exp/eval/scope.go                      |  30 +-
 src/pkg/exp/eval/stmt.go                       | 258 ++++++------
 src/pkg/exp/eval/type.go                       | 150 +++----
 src/pkg/exp/eval/typec.go                      |  62 +--
 src/pkg/exp/eval/util.go                       |   6 +-
 src/pkg/exp/eval/value.go                      |  44 +-
 src/pkg/exp/eval/world.go                      |  26 +-
 src/pkg/exp/iterable/iterable.go               |  22 +-
 src/pkg/exp/iterable/iterable_test.go          |  20 +-
 src/pkg/exp/nacl/av/av.go                      |  34 +-
 src/pkg/exp/nacl/av/event.go                   |  12 +-
 src/pkg/exp/nacl/av/image.go                   |  12 +-
 src/pkg/exp/nacl/srpc/client.go                |  24 +-
 src/pkg/exp/nacl/srpc/msg.go                   |  80 ++--
 src/pkg/exp/nacl/srpc/server.go                |  14 +-
 src/pkg/exp/ogle/arch.go                       |   8 +-
 src/pkg/exp/ogle/cmd.go                        |  72 ++--
 src/pkg/exp/ogle/event.go                      |  30 +-
 src/pkg/exp/ogle/frame.go                      |  26 +-
 src/pkg/exp/ogle/goroutine.go                  |  18 +-
 src/pkg/exp/ogle/process.go                    |  94 ++---
 src/pkg/exp/ogle/rruntime.go                   |   4 +-
 src/pkg/exp/ogle/rtype.go                      |  24 +-
 src/pkg/exp/ogle/rvalue.go                     | 110 ++---
 src/pkg/exp/ogle/vars.go                       |  42 +-
 src/pkg/exp/spacewar/pdp1.go                   |  98 ++---
 src/pkg/exp/spacewar/spacewar.go               |  22 +-
 src/pkg/expvar/expvar.go                       |  16 +-
 src/pkg/expvar/expvar_test.go                  |  30 +-
 src/pkg/flag/flag.go                           |  48 +--
 src/pkg/flag/flag_test.go                      |  14 +-
 src/pkg/fmt/fmt_test.go                        |  28 +-
 src/pkg/fmt/format.go                          |  56 +--
 src/pkg/fmt/print.go                           | 220 +++++-----
 src/pkg/go/ast/ast.go                          |   4 +-
 src/pkg/go/ast/filter.go                       |  28 +-
 src/pkg/go/ast/scope.go                        |   4 +-
 src/pkg/go/ast/walk.go                         |  66 +--
 src/pkg/go/doc/comment.go                      |  36 +-
 src/pkg/go/doc/doc.go                          |  60 +--
 src/pkg/go/parser/interface.go                 |  34 +-
 src/pkg/go/parser/parser.go                    | 374 ++++++++---------
 src/pkg/go/parser/parser_test.go               |  14 +-
 src/pkg/go/printer/nodes.go                    | 200 ++++-----
 src/pkg/go/printer/printer.go                  | 140 +++----
 src/pkg/go/printer/printer_test.go             |  10 +-
 src/pkg/go/printer/testdata/comments.golden    |   4 +-
 src/pkg/go/printer/testdata/expressions.golden |   4 +-
 src/pkg/go/printer/testdata/expressions.raw    |   4 +-
 src/pkg/go/printer/testdata/linebreaks.golden  |   4 +-
 src/pkg/go/printer/testdata/statements.golden  |  48 +--
 src/pkg/go/scanner/errors.go                   |  26 +-
 src/pkg/go/scanner/scanner.go                  | 120 +++---
 src/pkg/go/scanner/scanner_test.go             |  50 +--
 src/pkg/go/token/token.go                      |  22 +-
 src/pkg/gob/codec_test.go                      | 138 +++----
 src/pkg/gob/decode.go                          | 190 ++++-----
 src/pkg/gob/decoder.go                         |  10 +-
 src/pkg/gob/encode.go                          |  36 +-
 src/pkg/gob/encoder.go                         |  14 +-
 src/pkg/gob/encoder_test.go                    |  80 ++--
 src/pkg/gob/type.go                            |  78 ++--
 src/pkg/gob/type_test.go                       |  28 +-
 src/pkg/hash/crc32/crc32.go                    |   6 +-
 src/pkg/http/client.go                         |  32 +-
 src/pkg/http/client_test.go                    |   4 +-
 src/pkg/http/fs.go                             |  18 +-
 src/pkg/http/request.go                        | 136 +++----
 src/pkg/http/request_test.go                   |  14 +-
 src/pkg/http/server.go                         |  88 ++--
 src/pkg/http/triv.go                           |  16 +-
 src/pkg/http/url.go                            |  64 +--
 src/pkg/http/url_test.go                       |  14 +-
 src/pkg/image/color.go                         |  18 +-
 src/pkg/image/image.go                         |  28 +-
 src/pkg/image/png/reader.go                    | 110 ++---
 src/pkg/image/png/reader_test.go               |  12 +-
 src/pkg/image/png/writer.go                    |  44 +-
 src/pkg/image/png/writer_test.go               |   4 +-
 src/pkg/io/io.go                               |  40 +-
 src/pkg/io/pipe.go                             |  26 +-
 src/pkg/io/pipe_test.go                        |  66 +--
 src/pkg/io/utils.go                            |  12 +-
 src/pkg/io/utils_test.go                       |  26 +-
 src/pkg/json/generic.go                        |  64 +--
 src/pkg/json/generic_test.go                   |  12 +-
 src/pkg/json/parse.go                          |  48 +--
 src/pkg/json/struct.go                         |  86 ++--
 src/pkg/json/struct_test.go                    |   8 +-
 src/pkg/log/log.go                             |  16 +-
 src/pkg/log/log_test.go                        |  12 +-
 src/pkg/math/all_test.go                       |  30 +-
 src/pkg/math/asin.go                           |  10 +-
 src/pkg/math/atan.go                           |   6 +-
 src/pkg/math/atan2.go                          |   4 +-
 src/pkg/math/bits.go                           |  12 +-
 src/pkg/math/exp.go                            |  14 +-
 src/pkg/math/fabs.go                           |   2 +-
 src/pkg/math/floor.go                          |   2 +-
 src/pkg/math/fmod.go                           |   8 +-
 src/pkg/math/hypot.go                          |  10 +-
 src/pkg/math/log.go                            |   8 +-
 src/pkg/math/pow.go                            |  16 +-
 src/pkg/math/pow10.go                          |   4 +-
 src/pkg/math/sin.go                            |   6 +-
 src/pkg/math/sinh.go                           |  10 +-
 src/pkg/math/sqrt.go                           |   6 +-
 src/pkg/math/tan.go                            |   4 +-
 src/pkg/math/tanh.go                           |   4 +-
 src/pkg/net/dialgoogle_test.go                 |   4 +-
 src/pkg/net/dnsclient.go                       |  48 +--
 src/pkg/net/dnsconfig.go                       |  16 +-
 src/pkg/net/dnsmsg.go                          | 128 +++---
 src/pkg/net/fd.go                              |  68 ++--
 src/pkg/net/fd_darwin.go                       |  28 +-
 src/pkg/net/fd_linux.go                        |  34 +-
 src/pkg/net/fd_nacl.go                         |   2 +-
 src/pkg/net/ip.go                              |  84 ++--
 src/pkg/net/ip_test.go                         |   8 +-
 src/pkg/net/ipsock.go                          |  44 +-
 src/pkg/net/net.go                             |  34 +-
 src/pkg/net/net_test.go                        |   4 +-
 src/pkg/net/parse.go                           |  26 +-
 src/pkg/net/parse_test.go                      |  10 +-
 src/pkg/net/port.go                            |  14 +-
 src/pkg/net/port_test.go                       |   2 +-
 src/pkg/net/server_test.go                     |  34 +-
 src/pkg/net/sock.go                            |  26 +-
 src/pkg/net/tcpsock.go                         |  52 +--
 src/pkg/net/timeout_test.go                    |   8 +-
 src/pkg/net/udpsock.go                         |  66 +--
 src/pkg/net/unixsock.go                        | 100 ++---
 src/pkg/once/once_test.go                      |   6 +-
 src/pkg/os/dir_darwin.go                       |  10 +-
 src/pkg/os/dir_linux.go                        |  14 +-
 src/pkg/os/dir_nacl.go                         |  14 +-
 src/pkg/os/env.go                              |   6 +-
 src/pkg/os/error.go                            |   2 +-
 src/pkg/os/exec.go                             |  26 +-
 src/pkg/os/file.go                             |  90 ++---
 src/pkg/os/getwd.go                            |  16 +-
 src/pkg/os/os_test.go                          | 180 ++++-----
 src/pkg/os/path.go                             |  26 +-
 src/pkg/os/path_test.go                        |  56 +--
 src/pkg/os/stat_darwin.go                      |   4 +-
 src/pkg/os/stat_linux.go                       |   4 +-
 src/pkg/os/stat_nacl.go                        |   4 +-
 src/pkg/os/sys_darwin.go                       |   2 +-
 src/pkg/os/sys_linux.go                        |   6 +-
 src/pkg/os/time.go                             |   2 +-
 src/pkg/patch/apply.go                         |   4 +-
 src/pkg/patch/git.go                           |  26 +-
 src/pkg/patch/patch.go                         |  34 +-
 src/pkg/patch/patch_test.go                    |   2 +-
 src/pkg/patch/textdiff.go                      |  48 +--
 src/pkg/path/path.go                           |  24 +-
 src/pkg/path/path_test.go                      |  32 +-
 src/pkg/rand/exp.go                            |   6 +-
 src/pkg/rand/normal.go                         |  10 +-
 src/pkg/rand/rand.go                           |   6 +-
 src/pkg/rand/rand_test.go                      |  46 +--
 src/pkg/rand/rng.go                            |  10 +-
 src/pkg/reflect/all_test.go                    | 228 +++++------
 src/pkg/reflect/deepequal.go                   |  34 +-
 src/pkg/reflect/tostring_test.go               |  48 +--
 src/pkg/reflect/type.go                        | 110 ++---
 src/pkg/reflect/value.go                       | 174 ++++----
 src/pkg/regexp/all_test.go                     |  58 +--
 src/pkg/regexp/regexp.go                       | 142 +++----
 src/pkg/rpc/client.go                          |  18 +-
 src/pkg/rpc/debug.go                           |   2 +-
 src/pkg/rpc/server.go                          |  12 +-
 src/pkg/rpc/server_test.go                     |  42 +-
 src/pkg/sort/sort.go                           |  16 +-
 src/pkg/sort/sort_test.go                      |  32 +-
 src/pkg/strconv/atof.go                        |  62 +--
 src/pkg/strconv/atof_test.go                   |   8 +-
 src/pkg/strconv/atoi.go                        |  34 +-
 src/pkg/strconv/atoi_test.go                   |  28 +-
 src/pkg/strconv/decimal.go                     |  40 +-
 src/pkg/strconv/decimal_test.go                |  10 +-
 src/pkg/strconv/fp_test.go                     |  22 +-
 src/pkg/strconv/ftoa.go                        |  68 ++--
 src/pkg/strconv/ftoa_test.go                   |   6 +-
 src/pkg/strconv/itoa.go                        |   6 +-
 src/pkg/strconv/itoa_test.go                   |  24 +-
 src/pkg/strconv/quote.go                       |  76 ++--
 src/pkg/strconv/quote_test.go                  |  10 +-
 src/pkg/strings/reader.go                      |   4 +-
 src/pkg/strings/strings.go                     |  42 +-
 src/pkg/strings/strings_test.go                |  36 +-
 src/pkg/sync/mutex.go                          |   6 +-
 src/pkg/sync/mutex_test.go                     |   8 +-
 src/pkg/syscall/errstr.go                      |   4 +-
 src/pkg/syscall/exec.go                        |  50 +--
 src/pkg/syscall/syscall.go                     |   2 +-
 src/pkg/syscall/syscall_darwin.go              |  86 ++--
 src/pkg/syscall/syscall_linux.go               | 110 ++---
 src/pkg/syscall/syscall_linux_386.go           |   4 +-
 src/pkg/syscall/syscall_nacl.go                |  46 +--
 src/pkg/syscall/zsyscall_darwin_386.go         |  20 +-
 src/pkg/syscall/zsyscall_darwin_amd64.go       |  20 +-
 src/pkg/syscall/zsyscall_linux_386.go          |  22 +-
 src/pkg/syscall/zsyscall_linux_amd64.go        |  26 +-
 src/pkg/syscall/zsyscall_linux_arm.go          |  26 +-
 src/pkg/syscall/zsyscall_nacl_386.go           |   6 +-
 src/pkg/tabwriter/tabwriter.go                 |  62 +--
 src/pkg/tabwriter/tabwriter_test.go            |  18 +-
 src/pkg/template/format.go                     |  14 +-
 src/pkg/template/template.go                   | 150 +++----
 src/pkg/template/template_test.go              |  38 +-
 src/pkg/testing/iotest/logger.go               |  12 +-
 src/pkg/testing/iotest/reader.go               |   6 +-
 src/pkg/testing/iotest/writer.go               |   8 +-
 src/pkg/testing/quick/quick.go                 |  74 ++--
 src/pkg/testing/quick/quick_test.go            |  22 +-
 src/pkg/testing/regexp.go                      |  98 ++---
 src/pkg/testing/regexp_test.go                 |  46 +--
 src/pkg/testing/script/script.go               |  32 +-
 src/pkg/testing/script/script_test.go          |  14 +-
 src/pkg/testing/testing.go                     |  10 +-
 src/pkg/time/tick.go                           |  10 +-
 src/pkg/time/tick_test.go                      |   6 +-
 src/pkg/time/time.go                           |  26 +-
 src/pkg/time/time_test.go                      |   8 +-
 src/pkg/time/zoneinfo.go                       |  36 +-
 src/pkg/unicode/digit.go                       |   2 +-
 src/pkg/unicode/digit_test.go                  |   6 +-
 src/pkg/unicode/letter.go                      |  32 +-
 src/pkg/unicode/letter_test.go                 |  52 +--
 src/pkg/unicode/maketables.go                  | 208 +++++-----
 src/pkg/unicode/script_test.go                 |  26 +-
 src/pkg/utf8/utf8.go                           |  62 +--
 src/pkg/utf8/utf8_test.go                      |  36 +-
 src/pkg/xml/read.go                            |  62 +--
 src/pkg/xml/read_test.go                       |   4 +-
 src/pkg/xml/xml.go                             | 116 +++---
 src/pkg/xml/xml_test.go                        |  12 +-
 408 files changed, 7859 insertions(+), 7859 deletions(-)

diff --git a/misc/cgo/gmp/fib.go b/misc/cgo/gmp/fib.go
index 02b98b108c..1ff156ef22 100644
--- a/misc/cgo/gmp/fib.go
+++ b/misc/cgo/gmp/fib.go
@@ -22,7 +22,7 @@ func fibber(c chan *big.Int, out chan string, n int64) {
 
 	i := big.NewInt(n);
 	if n == 0 {
-		c <- i;
+		c <- i
 	}
 	for {
 		j := <-c;
@@ -38,6 +38,6 @@ func main() {
 	go fibber(c, out, 0);
 	go fibber(c, out, 1);
 	for i := 0; i < 200; i++ {
-		println(<-out);
+		println(<-out)
 	}
 }
diff --git a/misc/cgo/gmp/gmp.go b/misc/cgo/gmp/gmp.go
index a876f9cbc8..5a21c53841 100644
--- a/misc/cgo/gmp/gmp.go
+++ b/misc/cgo/gmp/gmp.go
@@ -130,7 +130,7 @@ func NewInt(x int64) *Int	{ return new(Int).SetInt64(x) }
 // making zero values useful and gmp's decision not to.
 func (z *Int) doinit() {
 	if z.init {
-		return;
+		return
 	}
 	z.init = true;
 	C.mpz_init(&z.i[0]);
@@ -162,9 +162,9 @@ func (z *Int) Set(x *Int) *Int {
 func (z *Int) SetBytes(b []byte) *Int {
 	z.doinit();
 	if len(b) == 0 {
-		z.SetInt64(0);
+		z.SetInt64(0)
 	} else {
-		C.mpz_import(&z.i[0], C.size_t(len(b)), 1, 1, 1, 0, unsafe.Pointer(&b[0]));
+		C.mpz_import(&z.i[0], C.size_t(len(b)), 1, 1, 1, 0, unsafe.Pointer(&b[0]))
 	}
 	return z;
 }
@@ -183,12 +183,12 @@ func (z *Int) SetInt64(x int64) *Int {
 func (z *Int) SetString(s string, base int) os.Error {
 	z.doinit();
 	if base < 2 || base > 36 {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	p := C.CString(s);
 	defer C.free(unsafe.Pointer(p));
 	if C.mpz_set_str(&z.i[0], p, C.int(base)) < 0 {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return z;
 }
@@ -196,7 +196,7 @@ func (z *Int) SetString(s string, base int) os.Error {
 // String returns the decimal representation of z.
 func (z *Int) String() string {
 	if z == nil {
-		return "nil";
+		return "nil"
 	}
 	z.doinit();
 	p := C.mpz_get_str(nil, 10, &z.i[0]);
@@ -207,7 +207,7 @@ func (z *Int) String() string {
 
 func (z *Int) destroy() {
 	if z.init {
-		C.mpz_clear(&z.i[0]);
+		C.mpz_clear(&z.i[0])
 	}
 	z.init = false;
 }
@@ -287,16 +287,16 @@ func (z *Int) Exp(x, y, m *Int) *Int {
 	y.doinit();
 	z.doinit();
 	if m == nil {
-		C.mpz_pow_ui(&z.i[0], &x.i[0], C.mpz_get_ui(&y.i[0]));
+		C.mpz_pow_ui(&z.i[0], &x.i[0], C.mpz_get_ui(&y.i[0]))
 	} else {
-		C.mpz_powm(&z.i[0], &x.i[0], &y.i[0], &m.i[0]);
+		C.mpz_powm(&z.i[0], &x.i[0], &y.i[0], &m.i[0])
 	}
 	return z;
 }
 
 func (z *Int) Int64() int64 {
 	if !z.init {
-		return 0;
+		return 0
 	}
 	return int64(C.mpz_get_si(&z.i[0]));
 }
@@ -334,9 +334,9 @@ func CmpInt(x, y *Int) int {
 	y.doinit();
 	switch cmp := C.mpz_cmp(&x.i[0], &y.i[0]); {
 	case cmp < 0:
-		return -1;
+		return -1
 	case cmp == 0:
-		return 0;
+		return 0
 	}
 	return +1;
 }
diff --git a/misc/cgo/gmp/pi.go b/misc/cgo/gmp/pi.go
index b03fa2c112..61b88a417d 100644
--- a/misc/cgo/gmp/pi.go
+++ b/misc/cgo/gmp/pi.go
@@ -54,13 +54,13 @@ var (
 
 func extractDigit() int64 {
 	if big.CmpInt(numer, accum) > 0 {
-		return -1;
+		return -1
 	}
 	tmp1.Lsh(numer, 1).Add(tmp1, numer).Add(tmp1, accum);
 	big.DivModInt(tmp1, tmp2, tmp1, denom);
 	tmp2.Add(tmp2, numer);
 	if big.CmpInt(tmp2, denom) >= 0 {
-		return -1;
+		return -1
 	}
 	return tmp1.Int64();
 }
@@ -95,7 +95,7 @@ func main() {
 		if i++; i%50 == 0 {
 			fmt.Printf("\n");
 			if i >= 1000 {
-				break;
+				break
 			}
 		}
 	}
diff --git a/misc/cgo/stdio/fib.go b/misc/cgo/stdio/fib.go
index 972057e11f..1e2336d5b2 100644
--- a/misc/cgo/stdio/fib.go
+++ b/misc/cgo/stdio/fib.go
@@ -22,7 +22,7 @@ func fibber(c, out chan int64, i int64) {
 	runtime.LockOSThread();
 
 	if i == 0 {
-		c <- i;
+		c <- i
 	}
 	for {
 		j := <-c;
diff --git a/misc/cgo/stdio/hello.go b/misc/cgo/stdio/hello.go
index c2555d0086..47f9de02f1 100644
--- a/misc/cgo/stdio/hello.go
+++ b/misc/cgo/stdio/hello.go
@@ -8,5 +8,5 @@ import "stdio"
 
 func main() {
 	//	stdio.Stdout.WriteString("hello, world\n");
-	stdio.Puts("hello, world");
+	stdio.Puts("hello, world")
 }
diff --git a/src/cmd/cgo/ast.go b/src/cmd/cgo/ast.go
index e5956375ca..f739c355aa 100644
--- a/src/cmd/cgo/ast.go
+++ b/src/cmd/cgo/ast.go
@@ -65,7 +65,7 @@ func openProg(name string) *Prog {
 			// Instead, turn it into a new Error that will return
 			// details for all the errors.
 			for _, e := range list {
-				fmt.Fprintln(os.Stderr, e);
+				fmt.Fprintln(os.Stderr, e)
 			}
 			os.Exit(2);
 		}
@@ -94,16 +94,16 @@ func openProg(name string) *Prog {
 			}
 			sawC = true;
 			if s.Name != nil {
-				error(s.Path[0].Pos(), `cannot rename import "C"`);
+				error(s.Path[0].Pos(), `cannot rename import "C"`)
 			}
 			if s.Doc != nil {
-				p.Preamble += doc.CommentText(s.Doc) + "\n";
+				p.Preamble += doc.CommentText(s.Doc) + "\n"
 			} else if len(d.Specs) == 1 && d.Doc != nil {
-				p.Preamble += doc.CommentText(d.Doc) + "\n";
+				p.Preamble += doc.CommentText(d.Doc) + "\n"
 			}
 		}
 		if ws == 0 {
-			continue;
+			continue
 		}
 		d.Specs = d.Specs[0:ws];
 		p.AST.Decls[w] = d;
@@ -112,7 +112,7 @@ func openProg(name string) *Prog {
 	p.AST.Decls = p.AST.Decls[0:w];
 
 	if !sawC {
-		error(noPos, `cannot find import "C"`);
+		error(noPos, `cannot find import "C"`)
 	}
 
 	// Accumulate pointers to uses of C.x.
@@ -135,7 +135,7 @@ func walk(x interface{}, p *Prog, context string) {
 				if i >= cap(p.Crefs) {
 					new := make([]*Cref, 2*i);
 					for j, v := range p.Crefs {
-						new[j] = v;
+						new[j] = v
 					}
 					p.Crefs = new;
 				}
@@ -159,7 +159,7 @@ func walk(x interface{}, p *Prog, context string) {
 
 	// These are ordered and grouped to match ../../pkg/go/ast/ast.go
 	case *ast.Field:
-		walk(&n.Type, p, "type");
+		walk(&n.Type, p, "type")
 	case *ast.BadExpr:
 	case *ast.Ident:
 	case *ast.Ellipsis:
@@ -172,14 +172,14 @@ func walk(x interface{}, p *Prog, context string) {
 		walk(&n.Type, p, "type");
 		walk(n.Elts, p, "expr");
 	case *ast.ParenExpr:
-		walk(&n.X, p, context);
+		walk(&n.X, p, context)
 	case *ast.SelectorExpr:
-		walk(&n.X, p, "selector");
+		walk(&n.X, p, "selector")
 	case *ast.IndexExpr:
 		walk(&n.X, p, "expr");
 		walk(&n.Index, p, "expr");
 		if n.End != nil {
-			walk(&n.End, p, "expr");
+			walk(&n.End, p, "expr")
 		}
 	case *ast.TypeAssertExpr:
 		walk(&n.X, p, "expr");
@@ -188,9 +188,9 @@ func walk(x interface{}, p *Prog, context string) {
 		walk(&n.Fun, p, "call");
 		walk(n.Args, p, "expr");
 	case *ast.StarExpr:
-		walk(&n.X, p, context);
+		walk(&n.X, p, context)
 	case *ast.UnaryExpr:
-		walk(&n.X, p, "expr");
+		walk(&n.X, p, "expr")
 	case *ast.BinaryExpr:
 		walk(&n.X, p, "expr");
 		walk(&n.Y, p, "expr");
@@ -202,40 +202,40 @@ func walk(x interface{}, p *Prog, context string) {
 		walk(&n.Len, p, "expr");
 		walk(&n.Elt, p, "type");
 	case *ast.StructType:
-		walk(n.Fields, p, "field");
+		walk(n.Fields, p, "field")
 	case *ast.FuncType:
 		walk(n.Params, p, "field");
 		walk(n.Results, p, "field");
 	case *ast.InterfaceType:
-		walk(n.Methods, p, "field");
+		walk(n.Methods, p, "field")
 	case *ast.MapType:
 		walk(&n.Key, p, "type");
 		walk(&n.Value, p, "type");
 	case *ast.ChanType:
-		walk(&n.Value, p, "type");
+		walk(&n.Value, p, "type")
 
 	case *ast.BadStmt:
 	case *ast.DeclStmt:
-		walk(n.Decl, p, "decl");
+		walk(n.Decl, p, "decl")
 	case *ast.EmptyStmt:
 	case *ast.LabeledStmt:
-		walk(n.Stmt, p, "stmt");
+		walk(n.Stmt, p, "stmt")
 	case *ast.ExprStmt:
-		walk(&n.X, p, "expr");
+		walk(&n.X, p, "expr")
 	case *ast.IncDecStmt:
-		walk(&n.X, p, "expr");
+		walk(&n.X, p, "expr")
 	case *ast.AssignStmt:
 		walk(n.Lhs, p, "expr");
 		walk(n.Rhs, p, "expr");
 	case *ast.GoStmt:
-		walk(n.Call, p, "expr");
+		walk(n.Call, p, "expr")
 	case *ast.DeferStmt:
-		walk(n.Call, p, "expr");
+		walk(n.Call, p, "expr")
 	case *ast.ReturnStmt:
-		walk(n.Results, p, "expr");
+		walk(n.Results, p, "expr")
 	case *ast.BranchStmt:
 	case *ast.BlockStmt:
-		walk(n.List, p, "stmt");
+		walk(n.List, p, "stmt")
 	case *ast.IfStmt:
 		walk(n.Init, p, "stmt");
 		walk(&n.Cond, p, "expr");
@@ -260,7 +260,7 @@ func walk(x interface{}, p *Prog, context string) {
 		walk(n.Rhs, p, "expr");
 		walk(n.Body, p, "stmt");
 	case *ast.SelectStmt:
-		walk(n.Body, p, "stmt");
+		walk(n.Body, p, "stmt")
 	case *ast.ForStmt:
 		walk(n.Init, p, "stmt");
 		walk(&n.Cond, p, "expr");
@@ -277,47 +277,47 @@ func walk(x interface{}, p *Prog, context string) {
 		walk(&n.Type, p, "type");
 		walk(n.Values, p, "expr");
 	case *ast.TypeSpec:
-		walk(&n.Type, p, "type");
+		walk(&n.Type, p, "type")
 
 	case *ast.BadDecl:
 	case *ast.GenDecl:
-		walk(n.Specs, p, "spec");
+		walk(n.Specs, p, "spec")
 	case *ast.FuncDecl:
 		if n.Recv != nil {
-			walk(n.Recv, p, "field");
+			walk(n.Recv, p, "field")
 		}
 		walk(n.Type, p, "type");
 		if n.Body != nil {
-			walk(n.Body, p, "stmt");
+			walk(n.Body, p, "stmt")
 		}
 
 	case *ast.File:
-		walk(n.Decls, p, "decl");
+		walk(n.Decls, p, "decl")
 
 	case *ast.Package:
 		for _, f := range n.Files {
-			walk(f, p, "file");
+			walk(f, p, "file")
 		}
 
 	case []ast.Decl:
 		for _, d := range n {
-			walk(d, p, context);
+			walk(d, p, context)
 		}
 	case []ast.Expr:
 		for i := range n {
-			walk(&n[i], p, context);
+			walk(&n[i], p, context)
 		}
 	case []*ast.Field:
 		for _, f := range n {
-			walk(f, p, context);
+			walk(f, p, context)
 		}
 	case []ast.Stmt:
 		for _, s := range n {
-			walk(s, p, context);
+			walk(s, p, context)
 		}
 	case []ast.Spec:
 		for _, s := range n {
-			walk(s, p, context);
+			walk(s, p, context)
 		}
 	}
 }
diff --git a/src/cmd/cgo/gcc.go b/src/cmd/cgo/gcc.go
index 9087c9197c..f5c33e82c5 100644
--- a/src/cmd/cgo/gcc.go
+++ b/src/cmd/cgo/gcc.go
@@ -24,7 +24,7 @@ func (p *Prog) loadDebugInfo() {
 	// Construct a slice of unique names from p.Crefs.
 	m := make(map[string]int);
 	for _, c := range p.Crefs {
-		m[c.Name] = -1;
+		m[c.Name] = -1
 	}
 	names := make([]string, 0, len(m));
 	for name, _ := range m {
@@ -59,40 +59,40 @@ func (p *Prog) loadDebugInfo() {
 	kind := make(map[string]string);
 	_, stderr := p.gccDebug(b.Bytes());
 	if stderr == "" {
-		fatal("gcc produced no output");
+		fatal("gcc produced no output")
 	}
 	for _, line := range strings.Split(stderr, "\n", 0) {
 		if len(line) < 9 || line[0:9] != "cgo-test:" {
-			continue;
+			continue
 		}
 		line = line[9:len(line)];
 		colon := strings.Index(line, ":");
 		if colon < 0 {
-			continue;
+			continue
 		}
 		i, err := strconv.Atoi(line[0:colon]);
 		if err != nil {
-			continue;
+			continue
 		}
 		what := "";
 		switch {
 		default:
-			continue;
+			continue
 		case strings.Index(line, ": useless type name in empty declaration") >= 0:
-			what = "type";
+			what = "type"
 		case strings.Index(line, ": statement with no effect") >= 0:
-			what = "value";
+			what = "value"
 		case strings.Index(line, "undeclared") >= 0:
-			what = "error";
+			what = "error"
 		}
 		if old, ok := kind[names[i]]; ok && old != what {
-			error(noPos, "inconsistent gcc output about C.%s", names[i]);
+			error(noPos, "inconsistent gcc output about C.%s", names[i])
 		}
 		kind[names[i]] = what;
 	}
 	for _, n := range names {
 		if _, ok := kind[n]; !ok {
-			error(noPos, "could not determine kind of name for C.%s", n);
+			error(noPos, "could not determine kind of name for C.%s", n)
 		}
 	}
 
@@ -107,11 +107,11 @@ func (p *Prog) loadDebugInfo() {
 	b.Reset();
 	b.WriteString(p.Preamble);
 	for i, n := range names {
-		fmt.Fprintf(&b, "typeof(%s) *__cgo__%d;\n", n, i);
+		fmt.Fprintf(&b, "typeof(%s) *__cgo__%d;\n", n, i)
 	}
 	d, stderr := p.gccDebug(b.Bytes());
 	if d == nil {
-		fatal("gcc failed:\n%s\non input:\n%s", stderr, b.Bytes());
+		fatal("gcc failed:\n%s\non input:\n%s", stderr, b.Bytes())
 	}
 
 	// Scan DWARF info for top-level TagVariable entries with AttrName __cgo__i.
@@ -120,39 +120,39 @@ func (p *Prog) loadDebugInfo() {
 	for {
 		e, err := r.Next();
 		if err != nil {
-			fatal("reading DWARF entry: %s", err);
+			fatal("reading DWARF entry: %s", err)
 		}
 		if e == nil {
-			break;
+			break
 		}
 		if e.Tag != dwarf.TagVariable {
-			goto Continue;
+			goto Continue
 		}
 		name, _ := e.Val(dwarf.AttrName).(string);
 		typOff, _ := e.Val(dwarf.AttrType).(dwarf.Offset);
 		if name == "" || typOff == 0 {
-			fatal("malformed DWARF TagVariable entry");
+			fatal("malformed DWARF TagVariable entry")
 		}
 		if !strings.HasPrefix(name, "__cgo__") {
-			goto Continue;
+			goto Continue
 		}
 		typ, err := d.Type(typOff);
 		if err != nil {
-			fatal("loading DWARF type: %s", err);
+			fatal("loading DWARF type: %s", err)
 		}
 		t, ok := typ.(*dwarf.PtrType);
 		if !ok || t == nil {
-			fatal("internal error: %s has non-pointer type", name);
+			fatal("internal error: %s has non-pointer type", name)
 		}
 		i, err := strconv.Atoi(name[7:len(name)]);
 		if err != nil {
-			fatal("malformed __cgo__ name: %s", name);
+			fatal("malformed __cgo__ name: %s", name)
 		}
 		types[i] = t.Type;
 
 	Continue:
 		if e.Tag != dwarf.TagCompileUnit {
-			r.SkipChildren();
+			r.SkipChildren()
 		}
 	}
 
@@ -164,9 +164,9 @@ func (p *Prog) loadDebugInfo() {
 		c.TypeName = kind[c.Name] == "type";
 		f, fok := types[i].(*dwarf.FuncType);
 		if c.Context == "call" && !c.TypeName && fok {
-			c.FuncType = conv.FuncType(f);
+			c.FuncType = conv.FuncType(f)
 		} else {
-			c.Type = conv.Type(types[i]);
+			c.Type = conv.Type(types[i])
 		}
 	}
 	p.Typedef = conv.typedef;
@@ -175,10 +175,10 @@ func (p *Prog) loadDebugInfo() {
 func concat(a, b []string) []string {
 	c := make([]string, len(a)+len(b));
 	for i, s := range a {
-		c[i] = s;
+		c[i] = s
 	}
 	for i, s := range b {
-		c[i+len(a)] = s;
+		c[i+len(a)] = s
 	}
 	return c;
 }
@@ -189,7 +189,7 @@ func concat(a, b []string) []string {
 func (p *Prog) gccDebug(stdin []byte) (*dwarf.Data, string) {
 	machine := "-m32";
 	if p.PtrSize == 8 {
-		machine = "-m64";
+		machine = "-m64"
 	}
 
 	tmp := "_cgo_.o";
@@ -206,7 +206,7 @@ func (p *Prog) gccDebug(stdin []byte) (*dwarf.Data, string) {
 	};
 	_, stderr, ok := run(stdin, concat(base, p.GccOptions));
 	if !ok {
-		return nil, string(stderr);
+		return nil, string(stderr)
 	}
 
 	// Try to parse f as ELF and Mach-O and hope one works.
@@ -216,13 +216,13 @@ func (p *Prog) gccDebug(stdin []byte) (*dwarf.Data, string) {
 	var err os.Error;
 	if f, err = elf.Open(tmp); err != nil {
 		if f, err = macho.Open(tmp); err != nil {
-			fatal("cannot parse gcc output %s as ELF or Mach-O object", tmp);
+			fatal("cannot parse gcc output %s as ELF or Mach-O object", tmp)
 		}
 	}
 
 	d, err := f.DWARF();
 	if err != nil {
-		fatal("cannot load DWARF debug information from %s: %s", tmp, err);
+		fatal("cannot load DWARF debug information from %s: %s", tmp, err)
 	}
 	return d, "";
 }
@@ -302,7 +302,7 @@ var cnameMap = map[string]string{
 func (c *typeConv) Type(dtype dwarf.Type) *Type {
 	if t, ok := c.m[dtype]; ok {
 		if t.Go == nil {
-			fatal("type conversion loop at %s", dtype);
+			fatal("type conversion loop at %s", dtype)
 		}
 		return t;
 	}
@@ -312,17 +312,17 @@ func (c *typeConv) Type(dtype dwarf.Type) *Type {
 	t.Align = -1;
 	t.C = dtype.Common().Name;
 	if t.Size < 0 {
-		fatal("dwarf.Type %s reports unknown size", dtype);
+		fatal("dwarf.Type %s reports unknown size", dtype)
 	}
 
 	c.m[dtype] = t;
 	switch dt := dtype.(type) {
 	default:
-		fatal("unexpected type: %s", dtype);
+		fatal("unexpected type: %s", dtype)
 
 	case *dwarf.AddrType:
 		if t.Size != c.ptrSize {
-			fatal("unexpected: %d-byte address type - %s", t.Size, dtype);
+			fatal("unexpected: %d-byte address type - %s", t.Size, dtype)
 		}
 		t.Go = c.uintptr;
 		t.Align = t.Size;
@@ -344,7 +344,7 @@ func (c *typeConv) Type(dtype dwarf.Type) *Type {
 
 	case *dwarf.CharType:
 		if t.Size != 1 {
-			fatal("unexpected: %d-byte char type - %s", t.Size, dtype);
+			fatal("unexpected: %d-byte char type - %s", t.Size, dtype)
 		}
 		t.Go = c.int8;
 		t.Align = 1;
@@ -352,32 +352,32 @@ func (c *typeConv) Type(dtype dwarf.Type) *Type {
 	case *dwarf.EnumType:
 		switch t.Size {
 		default:
-			fatal("unexpected: %d-byte enum type - %s", t.Size, dtype);
+			fatal("unexpected: %d-byte enum type - %s", t.Size, dtype)
 		case 1:
-			t.Go = c.uint8;
+			t.Go = c.uint8
 		case 2:
-			t.Go = c.uint16;
+			t.Go = c.uint16
 		case 4:
-			t.Go = c.uint32;
+			t.Go = c.uint32
 		case 8:
-			t.Go = c.uint64;
+			t.Go = c.uint64
 		}
 		if t.Align = t.Size; t.Align >= c.ptrSize {
-			t.Align = c.ptrSize;
+			t.Align = c.ptrSize
 		}
 		t.C = "enum " + dt.EnumName;
 
 	case *dwarf.FloatType:
 		switch t.Size {
 		default:
-			fatal("unexpected: %d-byte float type - %s", t.Size, dtype);
+			fatal("unexpected: %d-byte float type - %s", t.Size, dtype)
 		case 4:
-			t.Go = c.float32;
+			t.Go = c.float32
 		case 8:
-			t.Go = c.float64;
+			t.Go = c.float64
 		}
 		if t.Align = t.Size; t.Align >= c.ptrSize {
-			t.Align = c.ptrSize;
+			t.Align = c.ptrSize
 		}
 
 	case *dwarf.FuncType:
@@ -388,22 +388,22 @@ func (c *typeConv) Type(dtype dwarf.Type) *Type {
 
 	case *dwarf.IntType:
 		if dt.BitSize > 0 {
-			fatal("unexpected: %d-bit int type - %s", dt.BitSize, dtype);
+			fatal("unexpected: %d-bit int type - %s", dt.BitSize, dtype)
 		}
 		switch t.Size {
 		default:
-			fatal("unexpected: %d-byte int type - %s", t.Size, dtype);
+			fatal("unexpected: %d-byte int type - %s", t.Size, dtype)
 		case 1:
-			t.Go = c.int8;
+			t.Go = c.int8
 		case 2:
-			t.Go = c.int16;
+			t.Go = c.int16
 		case 4:
-			t.Go = c.int32;
+			t.Go = c.int32
 		case 8:
-			t.Go = c.int64;
+			t.Go = c.int64
 		}
 		if t.Align = t.Size; t.Align >= c.ptrSize {
-			t.Align = c.ptrSize;
+			t.Align = c.ptrSize
 		}
 
 	case *dwarf.PtrType:
@@ -436,7 +436,7 @@ func (c *typeConv) Type(dtype dwarf.Type) *Type {
 			tag = "__" + strconv.Itoa(c.tagGen);
 			c.tagGen++;
 		} else if t.C == "" {
-			t.C = dt.Kind + " " + tag;
+			t.C = dt.Kind + " " + tag
 		}
 		name := c.Ident("_C" + dt.Kind + "_" + tag);
 		t.Go = name;	// publish before recursive calls
@@ -444,12 +444,12 @@ func (c *typeConv) Type(dtype dwarf.Type) *Type {
 		case "union", "class":
 			c.typedef[name.Value] = c.Opaque(t.Size);
 			if t.C == "" {
-				t.C = fmt.Sprintf("typeof(unsigned char[%d])", t.Size);
+				t.C = fmt.Sprintf("typeof(unsigned char[%d])", t.Size)
 			}
 		case "struct":
 			g, csyntax, align := c.Struct(dt);
 			if t.C == "" {
-				t.C = csyntax;
+				t.C = csyntax
 			}
 			t.Align = align;
 			c.typedef[name.Value] = g;
@@ -472,34 +472,34 @@ func (c *typeConv) Type(dtype dwarf.Type) *Type {
 		t.Size = sub.Size;
 		t.Align = sub.Align;
 		if _, ok := c.typedef[name.Value]; !ok {
-			c.typedef[name.Value] = sub.Go;
+			c.typedef[name.Value] = sub.Go
 		}
 
 	case *dwarf.UcharType:
 		if t.Size != 1 {
-			fatal("unexpected: %d-byte uchar type - %s", t.Size, dtype);
+			fatal("unexpected: %d-byte uchar type - %s", t.Size, dtype)
 		}
 		t.Go = c.uint8;
 		t.Align = 1;
 
 	case *dwarf.UintType:
 		if dt.BitSize > 0 {
-			fatal("unexpected: %d-bit uint type - %s", dt.BitSize, dtype);
+			fatal("unexpected: %d-bit uint type - %s", dt.BitSize, dtype)
 		}
 		switch t.Size {
 		default:
-			fatal("unexpected: %d-byte uint type - %s", t.Size, dtype);
+			fatal("unexpected: %d-byte uint type - %s", t.Size, dtype)
 		case 1:
-			t.Go = c.uint8;
+			t.Go = c.uint8
 		case 2:
-			t.Go = c.uint16;
+			t.Go = c.uint16
 		case 4:
-			t.Go = c.uint32;
+			t.Go = c.uint32
 		case 8:
-			t.Go = c.uint64;
+			t.Go = c.uint64
 		}
 		if t.Align = t.Size; t.Align >= c.ptrSize {
-			t.Align = c.ptrSize;
+			t.Align = c.ptrSize
 		}
 
 	case *dwarf.VoidType:
@@ -512,7 +512,7 @@ func (c *typeConv) Type(dtype dwarf.Type) *Type {
 		s := dtype.Common().Name;
 		if s != "" {
 			if ss, ok := cnameMap[s]; ok {
-				s = ss;
+				s = ss
 			}
 			s = strings.Join(strings.Split(s, " ", 0), "");	// strip spaces
 			name := c.Ident("_C_"+s);
@@ -522,7 +522,7 @@ func (c *typeConv) Type(dtype dwarf.Type) *Type {
 	}
 
 	if t.C == "" {
-		fatal("internal error: did not create C name for %s", dtype);
+		fatal("internal error: did not create C name for %s", dtype)
 	}
 
 	return t;
@@ -541,14 +541,14 @@ func (c *typeConv) FuncArg(dtype dwarf.Type) *Type {
 			Align: c.ptrSize,
 			Go: &ast.StarExpr{X: t.Go},
 			C: t.C + "*",
-		};
+		}
 	case *dwarf.TypedefType:
 		// C has much more relaxed rules than Go for
 		// implicit type conversions.  When the parameter
 		// is type T defined as *X, simulate a little of the
 		// laxness of C by making the argument *X instead of T.
 		if ptr, ok := base(dt.Type).(*dwarf.PtrType); ok {
-			return c.Type(ptr);
+			return c.Type(ptr)
 		}
 	}
 	return t;
@@ -587,7 +587,7 @@ func (c *typeConv) Opaque(n int64) ast.Expr {
 	return &ast.ArrayType{
 		Len: c.intExpr(n),
 		Elt: c.byte,
-	};
+	}
 }
 
 // Expr for integer n.
@@ -595,7 +595,7 @@ func (c *typeConv) intExpr(n int64) ast.Expr {
 	return &ast.BasicLit{
 		Kind: token.INT,
 		Value: strings.Bytes(strconv.Itoa64(n)),
-	};
+	}
 }
 
 // Add padding of given size to fld.
@@ -623,7 +623,7 @@ func (c *typeConv) Struct(dt *dwarf.StructType) (expr *ast.StructType, csyntax s
 		off += t.Size;
 		csyntax += t.C + " " + f.Name + "; ";
 		if t.Align > align {
-			align = t.Align;
+			align = t.Align
 		}
 	}
 	if off < dt.ByteSize {
@@ -631,7 +631,7 @@ func (c *typeConv) Struct(dt *dwarf.StructType) (expr *ast.StructType, csyntax s
 		off = dt.ByteSize;
 	}
 	if off != dt.ByteSize {
-		fatal("struct size calculation error");
+		fatal("struct size calculation error")
 	}
 	csyntax += "}";
 	expr = &ast.StructType{Fields: fld};
diff --git a/src/cmd/cgo/main.go b/src/cmd/cgo/main.go
index c801704780..1eadfba9b1 100644
--- a/src/cmd/cgo/main.go
+++ b/src/cmd/cgo/main.go
@@ -45,18 +45,18 @@ func main() {
 
 	arch := os.Getenv("GOARCH");
 	if arch == "" {
-		fatal("$GOARCH is not set");
+		fatal("$GOARCH is not set")
 	}
 	ptrSize, ok := ptrSizeMap[arch];
 	if !ok {
-		fatal("unknown architecture %s", arch);
+		fatal("unknown architecture %s", arch)
 	}
 
 	p := openProg(input);
 	for _, cref := range p.Crefs {
 		// Convert C.ulong to C.unsigned long, etc.
 		if expand, ok := expandName[cref.Name]; ok {
-			cref.Name = expand;
+			cref.Name = expand
 		}
 	}
 
@@ -79,7 +79,7 @@ func main() {
 			*cref.Expr = cref.Type.Go;
 		case "expr":
 			if cref.TypeName {
-				error((*cref.Expr).Pos(), "type C.%s used as expression", cref.Name);
+				error((*cref.Expr).Pos(), "type C.%s used as expression", cref.Name)
 			}
 			// Reference to C variable.
 			// We declare a pointer and arrange to have it filled in.
@@ -87,13 +87,13 @@ func main() {
 			p.Vardef[cref.Name] = cref.Type;
 		case "type":
 			if !cref.TypeName {
-				error((*cref.Expr).Pos(), "expression C.%s used as type", cref.Name);
+				error((*cref.Expr).Pos(), "expression C.%s used as type", cref.Name)
 			}
 			*cref.Expr = cref.Type.Go;
 		}
 	}
 	if nerrors > 0 {
-		os.Exit(2);
+		os.Exit(2)
 	}
 
 	p.PackagePath = p.Package;
diff --git a/src/cmd/cgo/out.go b/src/cmd/cgo/out.go
index 2ae56fc289..2a62233b7a 100644
--- a/src/cmd/cgo/out.go
+++ b/src/cmd/cgo/out.go
@@ -15,7 +15,7 @@ import (
 func creat(name string) *os.File {
 	f, err := os.Open(name, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, 0666);
 	if err != nil {
-		fatal("%s", err);
+		fatal("%s", err)
 	}
 	return f;
 }
@@ -27,7 +27,7 @@ func (p *Prog) writeOutput(srcfile string) {
 
 	base := srcfile;
 	if strings.HasSuffix(base, ".go") {
-		base = base[0 : len(base)-3];
+		base = base[0 : len(base)-3]
 	}
 	fgo1 := creat(base + ".cgo1.go");
 	fgo2 := creat(base + ".cgo2.go");
@@ -80,7 +80,7 @@ func (p *Prog) writeOutput(srcfile string) {
 
 		if name == "CString" || name == "GoString" {
 			// The builtins are already defined in the C prolog.
-			continue;
+			continue
 		}
 
 		// Construct a gcc struct matching the 6c argument frame.
@@ -150,12 +150,12 @@ func (p *Prog) writeOutput(srcfile string) {
 		fmt.Fprintf(fgcc, "\t%s *a = v;\n", structType);
 		fmt.Fprintf(fgcc, "\t");
 		if def.Result != nil {
-			fmt.Fprintf(fgcc, "a->r = ");
+			fmt.Fprintf(fgcc, "a->r = ")
 		}
 		fmt.Fprintf(fgcc, "%s(", name);
 		for i := range def.Params {
 			if i > 0 {
-				fmt.Fprintf(fgcc, ", ");
+				fmt.Fprintf(fgcc, ", ")
 			}
 			fmt.Fprintf(fgcc, "a->p%d", i);
 		}
diff --git a/src/cmd/cgo/util.go b/src/cmd/cgo/util.go
index a2a013180b..d91516eb9d 100644
--- a/src/cmd/cgo/util.go
+++ b/src/cmd/cgo/util.go
@@ -18,7 +18,7 @@ type ByteReaderAt []byte
 
 func (r ByteReaderAt) ReadAt(p []byte, off int64) (n int, err os.Error) {
 	if off >= int64(len(r)) || off < 0 {
-		return 0, os.EOF;
+		return 0, os.EOF
 	}
 	return bytes.Copy(p, r[off:len(r)]), nil;
 }
@@ -29,23 +29,23 @@ func (r ByteReaderAt) ReadAt(p []byte, off int64) (n int, err os.Error) {
 func run(stdin []byte, argv []string) (stdout, stderr []byte, ok bool) {
 	cmd, err := exec.LookPath(argv[0]);
 	if err != nil {
-		fatal("exec %s: %s", argv[0], err);
+		fatal("exec %s: %s", argv[0], err)
 	}
 	r0, w0, err := os.Pipe();
 	if err != nil {
-		fatal("%s", err);
+		fatal("%s", err)
 	}
 	r1, w1, err := os.Pipe();
 	if err != nil {
-		fatal("%s", err);
+		fatal("%s", err)
 	}
 	r2, w2, err := os.Pipe();
 	if err != nil {
-		fatal("%s", err);
+		fatal("%s", err)
 	}
 	pid, err := os.ForkExec(cmd, argv, os.Environ(), "", []*os.File{r0, w1, w2});
 	if err != nil {
-		fatal("%s", err);
+		fatal("%s", err)
 	}
 	r0.Close();
 	w1.Close();
@@ -70,7 +70,7 @@ func run(stdin []byte, argv []string) (stdout, stderr []byte, ok bool) {
 
 	w, err := os.Wait(pid, 0);
 	if err != nil {
-		fatal("%s", err);
+		fatal("%s", err)
 	}
 	ok = w.Exited() && w.ExitStatus() == 0;
 	return;
@@ -88,7 +88,7 @@ var noPos token.Position
 func error(pos token.Position, msg string, args ...) {
 	nerrors++;
 	if pos.IsValid() {
-		fmt.Fprintf(os.Stderr, "%s: ", pos);
+		fmt.Fprintf(os.Stderr, "%s: ", pos)
 	}
 	fmt.Fprintf(os.Stderr, msg, args);
 	fmt.Fprintf(os.Stderr, "\n");
diff --git a/src/cmd/ebnflint/ebnflint.go b/src/cmd/ebnflint/ebnflint.go
index 57fb87ea93..e013dd0300 100644
--- a/src/cmd/ebnflint/ebnflint.go
+++ b/src/cmd/ebnflint/ebnflint.go
@@ -41,7 +41,7 @@ func extractEBNF(src []byte) []byte {
 		// i = beginning of EBNF text
 		i := bytes.Index(src, open);
 		if i < 0 {
-			break;	// no EBNF found - we are done
+			break	// no EBNF found - we are done
 		}
 		i += len(open);
 
@@ -49,14 +49,14 @@ func extractEBNF(src []byte) []byte {
 		// to maintain correct line numbers in error messages
 		for _, ch := range src[0:i] {
 			if ch == '\n' {
-				buf.WriteByte('\n');
+				buf.WriteByte('\n')
 			}
 		}
 
 		// j = end of EBNF text (or end of source)
 		j := bytes.Index(src[i:len(src)], close);	// close marker
 		if j < 0 {
-			j = len(src)-i;
+			j = len(src)-i
 		}
 		j += i;
 
@@ -77,28 +77,28 @@ func main() {
 	var filename string;
 	switch flag.NArg() {
 	case 0:
-		filename = "/dev/stdin";
+		filename = "/dev/stdin"
 	case 1:
-		filename = flag.Arg(0);
+		filename = flag.Arg(0)
 	default:
-		usage();
+		usage()
 	}
 
 	src, err := io.ReadFile(filename);
 	if err != nil {
-		scanner.PrintError(os.Stderr, err);
+		scanner.PrintError(os.Stderr, err)
 	}
 
 	if path.Ext(filename) == ".html" {
-		src = extractEBNF(src);
+		src = extractEBNF(src)
 	}
 
 	grammar, err := ebnf.Parse(filename, src);
 	if err != nil {
-		scanner.PrintError(os.Stderr, err);
+		scanner.PrintError(os.Stderr, err)
 	}
 
 	if err = ebnf.Verify(grammar, *start); err != nil {
-		scanner.PrintError(os.Stderr, err);
+		scanner.PrintError(os.Stderr, err)
 	}
 }
diff --git a/src/cmd/godoc/godoc.go b/src/cmd/godoc/godoc.go
index 91e21ea463..10c280e296 100644
--- a/src/cmd/godoc/godoc.go
+++ b/src/cmd/godoc/godoc.go
@@ -67,7 +67,7 @@ func (dt *delayTime) backoff(max int) {
 	dt.mutex.Lock();
 	v := dt.value.(int) * 2;
 	if v > max {
-		v = max;
+		v = max
 	}
 	dt.value = v;
 	dt.mutex.Unlock();
@@ -94,7 +94,7 @@ var fsTree RWValue	// *Directory tree of packages, updated with each sync
 func init() {
 	goroot = os.Getenv("GOROOT");
 	if goroot == "" {
-		goroot = pathutil.Join(os.Getenv("HOME"), "go");
+		goroot = pathutil.Join(os.Getenv("HOME"), "go")
 	}
 	flag.StringVar(&goroot, "goroot", goroot, "Go root directory");
 }
@@ -106,25 +106,25 @@ func init() {
 func isGoFile(dir *os.Dir) bool {
 	return dir.IsRegular() &&
 		!strings.HasPrefix(dir.Name, ".") &&	// ignore .files
-		pathutil.Ext(dir.Name) == ".go";
+		pathutil.Ext(dir.Name) == ".go"
 }
 
 
 func isPkgFile(dir *os.Dir) bool {
 	return isGoFile(dir) &&
-		!strings.HasSuffix(dir.Name, "_test.go");	// ignore test files
+		!strings.HasSuffix(dir.Name, "_test.go")	// ignore test files
 }
 
 
 func isPkgDir(dir *os.Dir) bool {
-	return dir.IsDirectory() && len(dir.Name) > 0 && dir.Name[0] != '_';
+	return dir.IsDirectory() && len(dir.Name) > 0 && dir.Name[0] != '_'
 }
 
 
 func pkgName(filename string) string {
 	file, err := parse(filename, parser.PackageClauseOnly);
 	if err != nil || file == nil {
-		return "";
+		return ""
 	}
 	return file.Name.Value;
 }
@@ -145,11 +145,11 @@ func firstSentence(s string) string {
 		k1 := k+1;
 		if ch == '.' {
 			if i < 0 {
-				i = k1;	// first period
+				i = k1	// first period
 			}
 			if k1 < len(s) && s[k1] <= ' ' {
 				if j < 0 {
-					j = k1;	// first period followed by white space
+					j = k1	// first period followed by white space
 				}
 				if !unicode.IsUpper(prev) {
 					j = k1;
@@ -165,7 +165,7 @@ func firstSentence(s string) string {
 		j = i;
 		if j < 0 {
 			// no period at all, use the entire string
-			j = len(s);
+			j = len(s)
 		}
 	}
 
@@ -190,7 +190,7 @@ func newDirTree(path, name string, depth, maxDepth int) *Directory {
 		// return a dummy directory so that the parent directory
 		// doesn't get discarded just because we reached the max
 		// directory depth
-		return &Directory{depth, path, name, "", nil};
+		return &Directory{depth, path, name, "", nil}
 	}
 
 	list, _ := io.ReadDir(path);	// ignore errors
@@ -202,7 +202,7 @@ func newDirTree(path, name string, depth, maxDepth int) *Directory {
 	for _, d := range list {
 		switch {
 		case isPkgDir(d):
-			ndirs++;
+			ndirs++
 		case isPkgFile(d):
 			nfiles++;
 			if text == "" {
@@ -218,7 +218,7 @@ func newDirTree(path, name string, depth, maxDepth int) *Directory {
 					(file.Name.Value == name || file.Name.Value == fakePkgName) &&
 					file.Doc != nil {
 					// found documentation; extract a synopsys
-					text = firstSentence(doc.CommentText(file.Doc));
+					text = firstSentence(doc.CommentText(file.Doc))
 				}
 			}
 		}
@@ -244,7 +244,7 @@ func newDirTree(path, name string, depth, maxDepth int) *Directory {
 	// if there are no package files and no subdirectories
 	// (with package files), ignore the directory
 	if nfiles == 0 && len(dirs) == 0 {
-		return nil;
+		return nil
 	}
 
 	return &Directory{depth, path, name, text, dirs};
@@ -259,7 +259,7 @@ func newDirTree(path, name string, depth, maxDepth int) *Directory {
 func newDirectory(root string, maxDepth int) *Directory {
 	d, err := os.Lstat(root);
 	if err != nil || !isPkgDir(d) {
-		return nil;
+		return nil
 	}
 	return newDirTree(root, d.Name, 0, maxDepth);
 }
@@ -268,10 +268,10 @@ func newDirectory(root string, maxDepth int) *Directory {
 func (dir *Directory) walk(c chan<- *Directory, skipRoot bool) {
 	if dir != nil {
 		if !skipRoot {
-			c <- dir;
+			c <- dir
 		}
 		for _, d := range dir.Dirs {
-			d.walk(c, false);
+			d.walk(c, false)
 		}
 	}
 }
@@ -292,7 +292,7 @@ func (dir *Directory) lookup(path string) *Directory {
 	path = pathutil.Clean(path);	// no trailing '/'
 
 	if dir == nil || path == "" || path == "." {
-		return dir;
+		return dir
 	}
 
 	dpath, dname := pathutil.Split(path);
@@ -300,7 +300,7 @@ func (dir *Directory) lookup(path string) *Directory {
 		// directory-local name
 		for _, d := range dir.Dirs {
 			if dname == d.Name {
-				return d;
+				return d
 			}
 		}
 		return nil;
@@ -333,7 +333,7 @@ type DirList struct {
 //
 func (root *Directory) listing(skipRoot bool) *DirList {
 	if root == nil {
-		return nil;
+		return nil
 	}
 
 	// determine number of entries n and maximum height
@@ -343,16 +343,16 @@ func (root *Directory) listing(skipRoot bool) *DirList {
 	for d := range root.iter(skipRoot) {
 		n++;
 		if minDepth > d.Depth {
-			minDepth = d.Depth;
+			minDepth = d.Depth
 		}
 		if maxDepth < d.Depth {
-			maxDepth = d.Depth;
+			maxDepth = d.Depth
 		}
 	}
 	maxHeight := maxDepth-minDepth+1;
 
 	if n == 0 {
-		return nil;
+		return nil
 	}
 
 	// create list
@@ -367,11 +367,11 @@ func (root *Directory) listing(skipRoot bool) *DirList {
 		// crashes and check)
 		path := d.Path;
 		if strings.HasPrefix(d.Path, root.Path) {
-			path = d.Path[len(root.Path):len(d.Path)];
+			path = d.Path[len(root.Path):len(d.Path)]
 		}
 		// remove trailing '/' if any - path must be relative
 		if len(path) > 0 && path[0] == '/' {
-			path = path[1:len(path)];
+			path = path[1:len(path)]
 		}
 		p.Path = path;
 		p.Name = d.Name;
@@ -502,7 +502,7 @@ func (s *Styler) BasicLit(x *ast.BasicLit) (text []byte, tag printer.HTMLTag) {
 func (s *Styler) Ident(id *ast.Ident) (text []byte, tag printer.HTMLTag) {
 	text = strings.Bytes(id.Value);
 	if s.highlight == id.Value {
-		tag = printer.HTMLTag{"<span class=highlight>", "</span>"};
+		tag = printer.HTMLTag{"<span class=highlight>", "</span>"}
 	}
 	return;
 }
@@ -521,7 +521,7 @@ func (s *Styler) Token(tok token.Token) (text []byte, tag printer.HTMLTag) {
 func writeNode(w io.Writer, node interface{}, html bool, styler printer.Styler) {
 	mode := printer.UseSpaces;
 	if html {
-		mode |= printer.GenHTML;
+		mode |= printer.GenHTML
 	}
 	(&printer.Config{mode, *tabwidth, styler}).Fprint(w, node);
 }
@@ -541,20 +541,20 @@ func writeText(w io.Writer, text []byte, html bool) {
 func writeAny(w io.Writer, x interface{}, html bool) {
 	switch v := x.(type) {
 	case []byte:
-		writeText(w, v, html);
+		writeText(w, v, html)
 	case string:
-		writeText(w, strings.Bytes(v), html);
+		writeText(w, strings.Bytes(v), html)
 	case ast.Decl:
-		writeNode(w, v, html, &defaultStyler);
+		writeNode(w, v, html, &defaultStyler)
 	case ast.Expr:
-		writeNode(w, v, html, &defaultStyler);
+		writeNode(w, v, html, &defaultStyler)
 	default:
 		if html {
 			var buf bytes.Buffer;
 			fmt.Fprint(&buf, x);
 			writeText(w, buf.Bytes(), true);
 		} else {
-			fmt.Fprint(w, x);
+			fmt.Fprint(w, x)
 		}
 	}
 }
@@ -562,7 +562,7 @@ func writeAny(w io.Writer, x interface{}, html bool) {
 
 // Template formatter for "html" format.
 func htmlFmt(w io.Writer, x interface{}, format string) {
-	writeAny(w, x, true);
+	writeAny(w, x, true)
 }
 
 
@@ -576,13 +576,13 @@ func htmlCommentFmt(w io.Writer, x interface{}, format string) {
 
 // Template formatter for "" (default) format.
 func textFmt(w io.Writer, x interface{}, format string) {
-	writeAny(w, x, false);
+	writeAny(w, x, false)
 }
 
 
 func removePrefix(s, prefix string) string {
 	if strings.HasPrefix(s, prefix) {
-		return s[len(prefix):len(s)];
+		return s[len(prefix):len(s)]
 	}
 	return s;
 }
@@ -593,7 +593,7 @@ func pathFmt(w io.Writer, x interface{}, format string) {
 	// TODO(gri): Need to find a better solution for this.
 	//            This will not work correctly if *cmdroot
 	//            or *pkgroot change.
-	writeAny(w, removePrefix(x.(string), "src"), true);
+	writeAny(w, removePrefix(x.(string), "src"), true)
 }
 
 
@@ -607,7 +607,7 @@ func linkFmt(w io.Writer, x interface{}, format string) {
 		if pos.IsValid() {
 			// line id's in html-printed source are of the
 			// form "L%d" where %d stands for the line number
-			fmt.Fprintf(w, "/%s#L%d", htmlEscape(pos.Filename), pos.Line);
+			fmt.Fprintf(w, "/%s#L%d", htmlEscape(pos.Filename), pos.Line)
 		}
 	}
 }
@@ -628,7 +628,7 @@ var infoKinds = [nKinds]string{
 
 // Template formatter for "infoKind" format.
 func infoKindFmt(w io.Writer, x interface{}, format string) {
-	fmt.Fprintf(w, infoKinds[x.(SpotKind)]);	// infoKind entries are html-escaped
+	fmt.Fprintf(w, infoKinds[x.(SpotKind)])	// infoKind entries are html-escaped
 }
 
 
@@ -661,7 +661,7 @@ func infoSnippetFmt(w io.Writer, x interface{}, format string) {
 // Template formatter for "padding" format.
 func paddingFmt(w io.Writer, x interface{}, format string) {
 	for i := x.(int); i > 0; i-- {
-		fmt.Fprint(w, `<td width="25"></td>`);
+		fmt.Fprint(w, `<td width="25"></td>`)
 	}
 }
 
@@ -669,7 +669,7 @@ func paddingFmt(w io.Writer, x interface{}, format string) {
 // Template formatter for "time" format.
 func timeFmt(w io.Writer, x interface{}, format string) {
 	// note: os.Dir.Mtime_ns is in uint64 in ns!
-	template.HTMLEscape(w, strings.Bytes(time.SecondsToLocalTime(int64(x.(uint64) / 1e9)).String()));
+	template.HTMLEscape(w, strings.Bytes(time.SecondsToLocalTime(int64(x.(uint64) / 1e9)).String()))
 }
 
 
@@ -691,11 +691,11 @@ func readTemplate(name string) *template.Template {
 	path := pathutil.Join(*tmplroot, name);
 	data, err := io.ReadFile(path);
 	if err != nil {
-		log.Exitf("ReadFile %s: %v", path, err);
+		log.Exitf("ReadFile %s: %v", path, err)
 	}
 	t, err := template.Parse(string(data), fmap);
 	if err != nil {
-		log.Exitf("%s: %v", name, err);
+		log.Exitf("%s: %v", name, err)
 	}
 	return t;
 }
@@ -744,7 +744,7 @@ func servePage(c *http.Conn, title, query string, content []byte) {
 	};
 
 	if err := godocHTML.Execute(&d, c); err != nil {
-		log.Stderrf("godocHTML.Execute: %s", err);
+		log.Stderrf("godocHTML.Execute: %s", err)
 	}
 }
 
@@ -768,7 +768,7 @@ func commentText(src []byte) (text string) {
 	i := bytes.Index(src, tagBegin);
 	j := bytes.Index(src, tagEnd);
 	if i >= 0 && j >= i+len(tagBegin) {
-		text = string(bytes.TrimSpace(src[i+len(tagBegin) : j]));
+		text = string(bytes.TrimSpace(src[i+len(tagBegin) : j]))
 	}
 	return;
 }
@@ -799,7 +799,7 @@ func serveParseErrors(c *http.Conn, errors *parseErrors) {
 	// format errors
 	var buf bytes.Buffer;
 	if err := parseerrorHTML.Execute(errors, &buf); err != nil {
-		log.Stderrf("parseerrorHTML.Execute: %s", err);
+		log.Stderrf("parseerrorHTML.Execute: %s", err)
 	}
 	servePage(c, "Parse errors in source file " + errors.filename, "", buf.Bytes());
 }
@@ -842,7 +842,7 @@ var textExt = map[string]bool{
 func isTextFile(path string) bool {
 	// if the extension is known, use it for decision making
 	if isText, found := textExt[pathutil.Ext(path)]; found {
-		return isText;
+		return isText
 	}
 
 	// the extension is not known; read an initial chunk of
@@ -850,24 +850,24 @@ func isTextFile(path string) bool {
 	// does, it's probably a text file
 	f, err := os.Open(path, os.O_RDONLY, 0);
 	if err != nil {
-		return false;
+		return false
 	}
 
 	var buf [1024]byte;
 	n, err := f.Read(&buf);
 	if err != nil {
-		return false;
+		return false
 	}
 
 	s := string(buf[0:n]);
 	n -= utf8.UTFMax;	// make sure there's enough bytes for a complete unicode char
 	for i, c := range s {
 		if i > n {
-			break;
+			break
 		}
 		if c == 0xFFFD || c < ' ' && c != '\n' && c != '\t' {
 			// decoding error or control character - not a text file
-			return false;
+			return false
 		}
 	}
 
@@ -879,7 +879,7 @@ func isTextFile(path string) bool {
 func serveTextFile(c *http.Conn, r *http.Request, path string) {
 	src, err := io.ReadFile(path);
 	if err != nil {
-		log.Stderrf("serveTextFile: %s", err);
+		log.Stderrf("serveTextFile: %s", err)
 	}
 
 	var buf bytes.Buffer;
@@ -893,7 +893,7 @@ func serveTextFile(c *http.Conn, r *http.Request, path string) {
 
 func serveDirectory(c *http.Conn, r *http.Request, path string) {
 	if redirect(c, r) {
-		return;
+		return
 	}
 
 	list, err := io.ReadDir(path);
@@ -904,7 +904,7 @@ func serveDirectory(c *http.Conn, r *http.Request, path string) {
 
 	var buf bytes.Buffer;
 	if err := dirlistHTML.Execute(list, &buf); err != nil {
-		log.Stderrf("dirlistHTML.Execute: %s", err);
+		log.Stderrf("dirlistHTML.Execute: %s", err)
 	}
 
 	servePage(c, "Directory " + path, "", buf.Bytes());
@@ -1009,7 +1009,7 @@ func (h *httpHandler) getPageInfo(path string) PageInfo {
 	pkg, err := parser.ParsePackage(dirname, filter, parser.ParseComments);
 	if err != nil {
 		// TODO: parse errors should be shown instead of an empty directory
-		log.Stderrf("parser.parsePackage: %s", err);
+		log.Stderrf("parser.parsePackage: %s", err)
 	}
 
 	// compute package documentation
@@ -1025,11 +1025,11 @@ func (h *httpHandler) getPageInfo(path string) PageInfo {
 		// directory tree is present; lookup respective directory
 		// (may still fail if the file system was updated and the
 		// new directory tree has not yet beet computed)
-		dir = tree.(*Directory).lookup(dirname);
+		dir = tree.(*Directory).lookup(dirname)
 	} else {
 		// no directory tree present (either early after startup
 		// or command-line mode); compute one level for this page
-		dir = newDirectory(dirname, 1);
+		dir = newDirectory(dirname, 1)
 	}
 
 	return PageInfo{pdoc, dir.listing(true), h.isPkg};
@@ -1038,7 +1038,7 @@ func (h *httpHandler) getPageInfo(path string) PageInfo {
 
 func (h *httpHandler) ServeHTTP(c *http.Conn, r *http.Request) {
 	if redirect(c, r) {
-		return;
+		return
 	}
 
 	path := r.URL.Path;
@@ -1048,30 +1048,30 @@ func (h *httpHandler) ServeHTTP(c *http.Conn, r *http.Request) {
 	var buf bytes.Buffer;
 	if r.FormValue("f") == "text" {
 		if err := packageText.Execute(info, &buf); err != nil {
-			log.Stderrf("packageText.Execute: %s", err);
+			log.Stderrf("packageText.Execute: %s", err)
 		}
 		serveText(c, buf.Bytes());
 		return;
 	}
 
 	if err := packageHTML.Execute(info, &buf); err != nil {
-		log.Stderrf("packageHTML.Execute: %s", err);
+		log.Stderrf("packageHTML.Execute: %s", err)
 	}
 
 	if path == "" {
-		path = ".";	// don't display an empty path
+		path = "."	// don't display an empty path
 	}
 	title := "Directory " + path;
 	if info.PDoc != nil {
 		switch {
 		case h.isPkg:
-			title = "Package " + info.PDoc.PackageName;
+			title = "Package " + info.PDoc.PackageName
 		case info.PDoc.PackageName == fakePkgName:
 			// assume that the directory name is the command name
 			_, pkgname := pathutil.Split(pathutil.Clean(path));
 			title = "Command " + pkgname;
 		default:
-			title = "Command " + info.PDoc.PackageName;
+			title = "Command " + info.PDoc.PackageName
 		}
 	}
 
@@ -1105,14 +1105,14 @@ func search(c *http.Conn, r *http.Request) {
 
 	var buf bytes.Buffer;
 	if err := searchHTML.Execute(result, &buf); err != nil {
-		log.Stderrf("searchHTML.Execute: %s", err);
+		log.Stderrf("searchHTML.Execute: %s", err)
 	}
 
 	var title string;
 	if result.Hit != nil {
-		title = fmt.Sprintf(`Results for query %q`, query);
+		title = fmt.Sprintf(`Results for query %q`, query)
 	} else {
-		title = fmt.Sprintf(`No results found for query %q`, query);
+		title = fmt.Sprintf(`No results found for query %q`, query)
 	}
 
 	servePage(c, title, query, buf.Bytes());
diff --git a/src/cmd/godoc/index.go b/src/cmd/godoc/index.go
index 223019cf87..cd246bd2fc 100644
--- a/src/cmd/godoc/index.go
+++ b/src/cmd/godoc/index.go
@@ -77,7 +77,7 @@ func (h *RunList) reduce(less func(x, y interface{}) bool, newRun func(h *RunLis
 	}
 	// add final run, if any
 	if i < h.Len() {
-		hh.Push(newRun(h, i, h.Len()));
+		hh.Push(newRun(h, i, h.Len()))
 	}
 
 	return &hh;
@@ -119,7 +119,7 @@ func init() {
 	// sanity check: if nKinds is too large, the SpotInfo
 	// accessor functions may need to be updated
 	if nKinds > 8 {
-		panic();
+		panic()
 	}
 }
 
@@ -132,13 +132,13 @@ func makeSpotInfo(kind SpotKind, lori int, isIndex bool) SpotInfo {
 		// lori value doesn't fit - since snippet indices are
 		// most certainly always smaller then 1<<28, this can
 		// only happen for line numbers; give it no line number (= 0)
-		x = 0;
+		x = 0
 	}
 	// encode kind: bits [1..4)
 	x |= SpotInfo(kind)<<1;
 	// encode isIndex: bit 0
 	if isIndex {
-		x |= 1;
+		x |= 1
 	}
 	return x;
 }
@@ -220,7 +220,7 @@ type Pak struct {
 
 // Paks are sorted by name (primary key) and by import path (secondary key).
 func (p *Pak) less(q *Pak) bool {
-	return p.Name < q.Name || p.Name == q.Name && p.Path < q.Path;
+	return p.Name < q.Name || p.Name == q.Name && p.Path < q.Path
 }
 
 
@@ -266,7 +266,7 @@ func newFileRun(h0 *RunList, i, j int) interface{} {
 	// create the FileRun
 	groups := make([]*KindRun, h2.Len());
 	for i := 0; i < h2.Len(); i++ {
-		groups[i] = h2.At(i).(*KindRun);
+		groups[i] = h2.At(i).(*KindRun)
 	}
 	return &FileRun{file, groups};
 }
@@ -289,7 +289,7 @@ func (p *PakRun) Swap(i, j int)		{ p.Files[i], p.Files[j] = p.Files[j], p.Files[
 
 // FileRuns are sorted by package for the reduction into PakRuns.
 func lessFileRun(x, y interface{}) bool {
-	return x.(*FileRun).File.Pak.less(&y.(*FileRun).File.Pak);
+	return x.(*FileRun).File.Pak.less(&y.(*FileRun).File.Pak)
 }
 
 
@@ -329,7 +329,7 @@ func reduce(h0 *RunList) HitList {
 	// create a HitList
 	h := make(HitList, h2.Len());
 	for i := 0; i < h2.Len(); i++ {
-		h[i] = h2.At(i).(*PakRun);
+		h[i] = h2.At(i).(*PakRun)
 	}
 	return h;
 }
@@ -340,7 +340,7 @@ func (h HitList) filter(pakname string) HitList {
 	n := 0;
 	for _, p := range h {
 		if p.Pak.Name == pakname {
-			n++;
+			n++
 		}
 	}
 	// create filtered HitList
@@ -393,7 +393,7 @@ func newAltWords(h *RunList, i, j int) interface{} {
 func (a *AltWords) filter(s string) *AltWords {
 	if len(a.Alts) == 1 && a.Alts[0] == s {
 		// there are no different alternatives
-		return nil;
+		return nil
 	}
 
 	// make a new AltWords with the current spelling removed
@@ -445,7 +445,7 @@ func (x *Indexer) addSnippet(s *Snippet) int {
 
 func (x *Indexer) visitComment(c *ast.CommentGroup) {
 	if c != nil {
-		ast.Walk(x, c);
+		ast.Walk(x, c)
 	}
 }
 
@@ -480,7 +480,7 @@ func (x *Indexer) visitSpec(spec ast.Spec, isVarDecl bool) {
 		x.visitComment(n.Doc);
 		x.visitIdent(ImportDecl, n.Name);
 		for _, s := range n.Path {
-			ast.Walk(x, s);
+			ast.Walk(x, s)
 		}
 		x.visitComment(n.Comment);
 
@@ -488,14 +488,14 @@ func (x *Indexer) visitSpec(spec ast.Spec, isVarDecl bool) {
 		x.visitComment(n.Doc);
 		kind := ConstDecl;
 		if isVarDecl {
-			kind = VarDecl;
+			kind = VarDecl
 		}
 		for _, n := range n.Names {
-			x.visitIdent(kind, n);
+			x.visitIdent(kind, n)
 		}
 		ast.Walk(x, n.Type);
 		for _, v := range n.Values {
-			ast.Walk(x, v);
+			ast.Walk(x, v)
 		}
 		x.visitComment(n.Comment);
 
@@ -512,17 +512,17 @@ func (x *Indexer) Visit(node interface{}) bool {
 	// TODO(gri): methods in interface types are categorized as VarDecl
 	switch n := node.(type) {
 	case *ast.Ident:
-		x.visitIdent(Use, n);
+		x.visitIdent(Use, n)
 
 	case *ast.Field:
 		x.decl = nil;	// no snippets for fields
 		x.visitComment(n.Doc);
 		for _, m := range n.Names {
-			x.visitIdent(VarDecl, m);
+			x.visitIdent(VarDecl, m)
 		}
 		ast.Walk(x, n.Type);
 		for _, s := range n.Tag {
-			ast.Walk(x, s);
+			ast.Walk(x, s)
 		}
 		x.visitComment(n.Comment);
 
@@ -532,18 +532,18 @@ func (x *Indexer) Visit(node interface{}) bool {
 			x.decl = nil;	// no snippets for local declarations
 			x.visitComment(decl.Doc);
 			for _, s := range decl.Specs {
-				x.visitSpec(s, decl.Tok == token.VAR);
+				x.visitSpec(s, decl.Tok == token.VAR)
 			}
 		} else {
 			// handle error case gracefully
-			ast.Walk(x, n.Decl);
+			ast.Walk(x, n.Decl)
 		}
 
 	case *ast.GenDecl:
 		x.decl = n;
 		x.visitComment(n.Doc);
 		for _, s := range n.Specs {
-			x.visitSpec(s, n.Tok == token.VAR);
+			x.visitSpec(s, n.Tok == token.VAR)
 		}
 
 	case *ast.FuncDecl:
@@ -557,7 +557,7 @@ func (x *Indexer) Visit(node interface{}) bool {
 		x.visitIdent(kind, n.Name);
 		ast.Walk(x, n.Type);
 		if n.Body != nil {
-			ast.Walk(x, n.Type);
+			ast.Walk(x, n.Type)
 		}
 
 	case *ast.File:
@@ -565,14 +565,14 @@ func (x *Indexer) Visit(node interface{}) bool {
 		x.decl = nil;
 		x.visitIdent(PackageClause, n.Name);
 		for _, d := range n.Decls {
-			ast.Walk(x, d);
+			ast.Walk(x, d)
 		}
 		// don't visit package level comments for now
 		// to avoid duplicate visiting from individual
 		// nodes
 
 	default:
-		return true;
+		return true
 	}
 
 	return false;
@@ -580,26 +580,26 @@ func (x *Indexer) Visit(node interface{}) bool {
 
 
 func (x *Indexer) VisitDir(path string, d *os.Dir) bool {
-	return true;
+	return true
 }
 
 
 func (x *Indexer) VisitFile(path string, d *os.Dir) {
 	if !isGoFile(d) {
-		return;
+		return
 	}
 
 	if excludeTestFiles && (!isPkgFile(d) || strings.HasPrefix(path, "test/")) {
-		return;
+		return
 	}
 
 	if excludeMainPackages && pkgName(path) == "main" {
-		return;
+		return
 	}
 
 	file, err := parser.ParseFile(path, nil, parser.ParseComments);
 	if err != nil {
-		return;	// ignore files with (parse) errors
+		return	// ignore files with (parse) errors
 	}
 
 	dir, _ := pathutil.Split(path);
@@ -668,7 +668,7 @@ func NewIndex(root string) *Index {
 	// convert snippet vector into a list
 	snippets := make([]*Snippet, x.snippets.Len());
 	for i := 0; i < x.snippets.Len(); i++ {
-		snippets[i] = x.snippets.At(i).(*Snippet);
+		snippets[i] = x.snippets.At(i).(*Snippet)
 	}
 
 	return &Index{words, alts, snippets, x.nspots};
@@ -678,7 +678,7 @@ func NewIndex(root string) *Index {
 // Size returns the number of different words and
 // spots indexed as a measure for the index size.
 func (x *Index) Size() (nwords int, nspots int) {
-	return len(x.words), x.nspots;
+	return len(x.words), x.nspots
 }
 
 
@@ -689,7 +689,7 @@ func (x *Index) LookupWord(w string) (match *LookupResult, alt *AltWords) {
 	// (if there is no match, the alternatives do
 	// not contain the current spelling)
 	if match != nil && alt != nil {
-		alt = alt.filter(w);
+		alt = alt.filter(w)
 	}
 	return;
 }
@@ -722,7 +722,7 @@ func (x *Index) Lookup(query string) (match *LookupResult, alt *AltWords, illega
 
 	switch len(ss) {
 	case 1:
-		match, alt = x.LookupWord(ss[0]);
+		match, alt = x.LookupWord(ss[0])
 
 	case 2:
 		pakname := ss[0];
@@ -735,7 +735,7 @@ func (x *Index) Lookup(query string) (match *LookupResult, alt *AltWords, illega
 		}
 
 	default:
-		illegal = true;
+		illegal = true
 	}
 
 	return;
@@ -745,7 +745,7 @@ func (x *Index) Lookup(query string) (match *LookupResult, alt *AltWords, illega
 func (x *Index) Snippet(i int) *Snippet {
 	// handle illegal snippet indices gracefully
 	if 0 <= i && i < len(x.snippets) {
-		return x.snippets[i];
+		return x.snippets[i]
 	}
 	return nil;
 }
diff --git a/src/cmd/godoc/main.go b/src/cmd/godoc/main.go
index 83a05a12f6..ee4f196507 100644
--- a/src/cmd/godoc/main.go
+++ b/src/cmd/godoc/main.go
@@ -60,7 +60,7 @@ func exec(c *http.Conn, args []string) (status int) {
 	bin := args[0];
 	fds := []*os.File{nil, w, w};
 	if *verbose {
-		log.Stderrf("executing %v", args);
+		log.Stderrf("executing %v", args)
 	}
 	pid, err := os.ForkExec(bin, args, os.Environ(), goroot, fds);
 	defer r.Close();
@@ -86,7 +86,7 @@ func exec(c *http.Conn, args []string) (status int) {
 	}
 
 	if *verbose {
-		os.Stderr.Write(buf.Bytes());
+		os.Stderr.Write(buf.Bytes())
 	}
 	if c != nil {
 		c.SetHeader("content-type", "text/plain; charset=utf-8");
@@ -114,10 +114,10 @@ func dosync(c *http.Conn, r *http.Request) {
 	case 1:
 		// sync failed because no files changed;
 		// don't change the package tree
-		syncDelay.set(*syncMin);	//  revert to regular sync schedule
+		syncDelay.set(*syncMin)	//  revert to regular sync schedule
 	default:
 		// sync failed because of an error - back off exponentially, but try at least once a day
-		syncDelay.backoff(24*60);
+		syncDelay.backoff(24*60)
 	}
 }
 
@@ -135,7 +135,7 @@ func loggingHandler(h http.Handler) http.Handler {
 	return http.HandlerFunc(func(c *http.Conn, req *http.Request) {
 		log.Stderrf("%s\t%s", c.RemoteAddr, req.URL);
 		h.ServeHTTP(c, req);
-	});
+	})
 }
 
 
@@ -145,15 +145,15 @@ func main() {
 
 	// Check usage: either server and no args, or command line and args
 	if (*httpaddr != "") != (flag.NArg() == 0) {
-		usage();
+		usage()
 	}
 
 	if *tabwidth < 0 {
-		log.Exitf("negative tabwidth %d", *tabwidth);
+		log.Exitf("negative tabwidth %d", *tabwidth)
 	}
 
 	if err := os.Chdir(goroot); err != nil {
-		log.Exitf("chdir %s: %v", goroot, err);
+		log.Exitf("chdir %s: %v", goroot, err)
 	}
 
 	readTemplates();
@@ -174,7 +174,7 @@ func main() {
 
 		registerPublicHandlers(http.DefaultServeMux);
 		if *syncCmd != "" {
-			http.Handle("/debug/sync", http.HandlerFunc(dosync));
+			http.Handle("/debug/sync", http.HandlerFunc(dosync))
 		}
 
 		// Initialize directory tree with corresponding timestamp.
@@ -192,7 +192,7 @@ func main() {
 					dosync(nil, nil);
 					delay, _ := syncDelay.get();
 					if *verbose {
-						log.Stderrf("next sync in %dmin", delay.(int));
+						log.Stderrf("next sync in %dmin", delay.(int))
 					}
 					time.Sleep(int64(delay.(int))*60e9);
 				}
@@ -210,7 +210,7 @@ func main() {
 
 		// Start http server.
 		if err := http.ListenAndServe(*httpaddr, handler); err != nil {
-			log.Exitf("ListenAndServe %s: %v", *httpaddr, err);
+			log.Exitf("ListenAndServe %s: %v", *httpaddr, err)
 		}
 		return;
 	}
@@ -225,7 +225,7 @@ func main() {
 
 	if info.PDoc == nil && info.Dirs == nil {
 		// try again, this time assume it's a command
-		info = cmdHandler.getPageInfo(flag.Arg(0));
+		info = cmdHandler.getPageInfo(flag.Arg(0))
 	}
 
 	if info.PDoc != nil && flag.NArg() > 1 {
@@ -234,6 +234,6 @@ func main() {
 	}
 
 	if err := packageText.Execute(info, os.Stdout); err != nil {
-		log.Stderrf("packageText.Execute: %s", err);
+		log.Stderrf("packageText.Execute: %s", err)
 	}
 }
diff --git a/src/cmd/godoc/snippet.go b/src/cmd/godoc/snippet.go
index b6f64462a7..be027ffc81 100755
--- a/src/cmd/godoc/snippet.go
+++ b/src/cmd/godoc/snippet.go
@@ -31,14 +31,14 @@ type snippetStyler struct {
 
 
 func (s *snippetStyler) LineTag(line int) (text []uint8, tag printer.HTMLTag) {
-	return;	// no LineTag for snippets
+	return	// no LineTag for snippets
 }
 
 
 func (s *snippetStyler) Ident(id *ast.Ident) (text []byte, tag printer.HTMLTag) {
 	text = strings.Bytes(id.Value);
 	if s.highlight == id {
-		tag = printer.HTMLTag{"<span class=highlight>", "</span>"};
+		tag = printer.HTMLTag{"<span class=highlight>", "</span>"}
 	}
 	return;
 }
@@ -56,17 +56,17 @@ func findSpec(list []ast.Spec, id *ast.Ident) ast.Spec {
 		switch s := spec.(type) {
 		case *ast.ImportSpec:
 			if s.Name == id {
-				return s;
+				return s
 			}
 		case *ast.ValueSpec:
 			for _, n := range s.Names {
 				if n == id {
-					return s;
+					return s
 				}
 			}
 		case *ast.TypeSpec:
 			if s.Name == id {
-				return s;
+				return s
 			}
 		}
 	}
@@ -77,7 +77,7 @@ func findSpec(list []ast.Spec, id *ast.Ident) ast.Spec {
 func genSnippet(d *ast.GenDecl, id *ast.Ident) *Snippet {
 	s := findSpec(d.Specs, id);
 	if s == nil {
-		return nil;	//  declaration doesn't contain id - exit gracefully
+		return nil	//  declaration doesn't contain id - exit gracefully
 	}
 
 	// only use the spec containing the id for the snippet
@@ -89,7 +89,7 @@ func genSnippet(d *ast.GenDecl, id *ast.Ident) *Snippet {
 
 func funcSnippet(d *ast.FuncDecl, id *ast.Ident) *Snippet {
 	if d.Name != id {
-		return nil;	//  declaration doesn't contain id - exit gracefully
+		return nil	//  declaration doesn't contain id - exit gracefully
 	}
 
 	// only use the function signature for the snippet
@@ -106,9 +106,9 @@ func funcSnippet(d *ast.FuncDecl, id *ast.Ident) *Snippet {
 func NewSnippet(decl ast.Decl, id *ast.Ident) (s *Snippet) {
 	switch d := decl.(type) {
 	case *ast.GenDecl:
-		s = genSnippet(d, id);
+		s = genSnippet(d, id)
 	case *ast.FuncDecl:
-		s = funcSnippet(d, id);
+		s = funcSnippet(d, id)
 	}
 
 	// handle failure gracefully
@@ -116,7 +116,7 @@ func NewSnippet(decl ast.Decl, id *ast.Ident) (s *Snippet) {
 		s = &Snippet{
 			id.Pos().Line,
 			fmt.Sprintf(`could not generate a snippet for <span class="highlight">%s</span>`, id.Value),
-		};
+		}
 	}
 	return;
 }
diff --git a/src/cmd/godoc/spec.go b/src/cmd/godoc/spec.go
index a473fc7b44..a863a16cd3 100644
--- a/src/cmd/godoc/spec.go
+++ b/src/cmd/godoc/spec.go
@@ -43,13 +43,13 @@ func (p *ebnfParser) next() {
 	if p.tok.IsKeyword() {
 		// TODO Should keyword mapping always happen outside scanner?
 		//      Or should there be a flag to scanner to enable keyword mapping?
-		p.tok = token.IDENT;
+		p.tok = token.IDENT
 	}
 }
 
 
 func (p *ebnfParser) Error(pos token.Position, msg string) {
-	fmt.Fprintf(p.out, `<span class="alert">error: %s</span>`, msg);
+	fmt.Fprintf(p.out, `<span class="alert">error: %s</span>`, msg)
 }
 
 
@@ -60,7 +60,7 @@ func (p *ebnfParser) errorExpected(pos token.Position, msg string) {
 		// make the error message more specific
 		msg += ", found '" + p.tok.String() + "'";
 		if p.tok.IsLiteral() {
-			msg += " "+string(p.lit);
+			msg += " "+string(p.lit)
 		}
 	}
 	p.Error(pos, msg);
@@ -70,7 +70,7 @@ func (p *ebnfParser) errorExpected(pos token.Position, msg string) {
 func (p *ebnfParser) expect(tok token.Token) token.Position {
 	pos := p.pos;
 	if p.tok != tok {
-		p.errorExpected(pos, "'" + tok.String() + "'");
+		p.errorExpected(pos, "'" + tok.String() + "'")
 	}
 	p.next();	// make progress in any case
 	return pos;
@@ -81,9 +81,9 @@ func (p *ebnfParser) parseIdentifier(def bool) {
 	name := string(p.lit);
 	p.expect(token.IDENT);
 	if def {
-		fmt.Fprintf(p.out, `<a id="%s">%s</a>`, name, name);
+		fmt.Fprintf(p.out, `<a id="%s">%s</a>`, name, name)
 	} else {
-		fmt.Fprintf(p.out, `<a href="#%s" class="noline">%s</a>`, name, name);
+		fmt.Fprintf(p.out, `<a href="#%s" class="noline">%s</a>`, name, name)
 	}
 	p.prev += len(name);	// skip identifier when calling flush
 }
@@ -92,7 +92,7 @@ func (p *ebnfParser) parseIdentifier(def bool) {
 func (p *ebnfParser) parseTerm() bool {
 	switch p.tok {
 	case token.IDENT:
-		p.parseIdentifier(false);
+		p.parseIdentifier(false)
 
 	case token.STRING:
 		p.next();
@@ -117,7 +117,7 @@ func (p *ebnfParser) parseTerm() bool {
 		p.expect(token.RBRACE);
 
 	default:
-		return false;
+		return false
 	}
 
 	return true;
@@ -134,7 +134,7 @@ func (p *ebnfParser) parseExpression() {
 	for {
 		p.parseSequence();
 		if p.tok != token.OR {
-			break;
+			break
 		}
 		p.next();
 	}
@@ -158,7 +158,7 @@ func (p *ebnfParser) parse(out io.Writer, src []byte) {
 
 	// process source
 	for p.tok != token.EOF {
-		p.parseProduction();
+		p.parseProduction()
 	}
 	p.flush();
 }
@@ -178,14 +178,14 @@ func linkify(out io.Writer, src []byte) {
 		// i: beginning of EBNF text (or end of source)
 		i := bytes.Index(src, openTag);
 		if i < 0 {
-			i = n-len(openTag);
+			i = n-len(openTag)
 		}
 		i += len(openTag);
 
 		// j: end of EBNF text (or end of source)
 		j := bytes.Index(src[i:n], closeTag);	// close marker
 		if j < 0 {
-			j = n-i;
+			j = n-i
 		}
 		j += i;
 
diff --git a/src/cmd/gofmt/gofmt.go b/src/cmd/gofmt/gofmt.go
index b554c4f151..4d2d14f521 100644
--- a/src/cmd/gofmt/gofmt.go
+++ b/src/cmd/gofmt/gofmt.go
@@ -52,10 +52,10 @@ func usage() {
 func parserMode() uint {
 	mode := uint(0);
 	if *comments {
-		mode |= parser.ParseComments;
+		mode |= parser.ParseComments
 	}
 	if *trace {
-		mode |= parser.Trace;
+		mode |= parser.Trace
 	}
 	return mode;
 }
@@ -64,10 +64,10 @@ func parserMode() uint {
 func printerMode() uint {
 	mode := uint(0);
 	if !*align {
-		mode |= printer.RawFormat;
+		mode |= printer.RawFormat
 	}
 	if *usespaces {
-		mode |= printer.UseSpaces;
+		mode |= printer.UseSpaces
 	}
 	return mode;
 }
@@ -75,42 +75,42 @@ func printerMode() uint {
 
 func isGoFile(d *os.Dir) bool {
 	// ignore non-Go files
-	return d.IsRegular() && !strings.HasPrefix(d.Name, ".") && strings.HasSuffix(d.Name, ".go");
+	return d.IsRegular() && !strings.HasPrefix(d.Name, ".") && strings.HasSuffix(d.Name, ".go")
 }
 
 
 func processFile(filename string) os.Error {
 	src, err := io.ReadFile(filename);
 	if err != nil {
-		return err;
+		return err
 	}
 
 	file, err := parser.ParseFile(filename, src, parserMode());
 	if err != nil {
-		return err;
+		return err
 	}
 
 	var res bytes.Buffer;
 	_, err = (&printer.Config{printerMode(), *tabwidth, nil}).Fprint(&res, file);
 	if err != nil {
-		return err;
+		return err
 	}
 
 	if bytes.Compare(src, res.Bytes()) != 0 {
 		// formatting has changed
 		if *list {
-			fmt.Fprintln(os.Stdout, filename);
+			fmt.Fprintln(os.Stdout, filename)
 		}
 		if *write {
 			err = io.WriteFile(filename, res.Bytes(), 0);
 			if err != nil {
-				return err;
+				return err
 			}
 		}
 	}
 
 	if !*list && !*write {
-		_, err = os.Stdout.Write(res.Bytes());
+		_, err = os.Stdout.Write(res.Bytes())
 	}
 
 	return err;
@@ -120,7 +120,7 @@ func processFile(filename string) os.Error {
 type fileVisitor chan os.Error
 
 func (v fileVisitor) VisitDir(path string, d *os.Dir) bool {
-	return true;
+	return true
 }
 
 
@@ -128,7 +128,7 @@ func (v fileVisitor) VisitFile(path string, d *os.Dir) {
 	if isGoFile(d) {
 		v <- nil;	// synchronize error handler
 		if err := processFile(path); err != nil {
-			v <- err;
+			v <- err
 		}
 	}
 }
@@ -140,7 +140,7 @@ func walkDir(path string) {
 	go func() {
 		for err := range v {
 			if err != nil {
-				report(err);
+				report(err)
 			}
 		}
 	}();
@@ -160,7 +160,7 @@ func main() {
 
 	if flag.NArg() == 0 {
 		if err := processFile("/dev/stdin"); err != nil {
-			report(err);
+			report(err)
 		}
 	}
 
@@ -168,13 +168,13 @@ func main() {
 		path := flag.Arg(i);
 		switch dir, err := os.Stat(path); {
 		case err != nil:
-			report(err);
+			report(err)
 		case dir.IsRegular():
 			if err := processFile(path); err != nil {
-				report(err);
+				report(err)
 			}
 		case dir.IsDirectory():
-			walkDir(path);
+			walkDir(path)
 		}
 	}
 
diff --git a/src/cmd/goyacc/goyacc.go b/src/cmd/goyacc/goyacc.go
index ea4c544f8c..983052cf23 100644
--- a/src/cmd/goyacc/goyacc.go
+++ b/src/cmd/goyacc/goyacc.go
@@ -352,7 +352,7 @@ func setup() {
 
 	flag.Parse();
 	if flag.NArg() != 1 {
-		usage();
+		usage()
 	}
 	if stacksize < 1 {
 		// never set so cannot happen
@@ -374,24 +374,24 @@ outer:
 	for {
 		switch t {
 		default:
-			error("syntax error tok=%v", t-PRIVATE);
+			error("syntax error tok=%v", t-PRIVATE)
 
 		case MARK, ENDFILE:
-			break outer;
+			break outer
 
 		case ';':
 
 		case START:
 			t = gettok();
 			if t != IDENTIFIER {
-				error("bad %%start construction");
+				error("bad %%start construction")
 			}
 			start = chfind(1, tokname);
 
 		case TYPEDEF:
 			t = gettok();
 			if t != TYPENAME {
-				error("bad syntax in %%type");
+				error("bad syntax in %%type")
 			}
 			ty = numbval;
 			for {
@@ -403,36 +403,36 @@ outer:
 						j = TYPE(toklev[t]);
 						if j != 0 && j != ty {
 							error("type redeclaration of token ",
-								tokset[t].name);
+								tokset[t].name)
 						} else {
-							toklev[t] = SETTYPE(toklev[t], ty);
+							toklev[t] = SETTYPE(toklev[t], ty)
 						}
 					} else {
 						j = nontrst[t-NTBASE].value;
 						if j != 0 && j != ty {
 							error("type redeclaration of nonterminal %v",
-								nontrst[t-NTBASE].name);
+								nontrst[t-NTBASE].name)
 						} else {
-							nontrst[t-NTBASE].value = ty;
+							nontrst[t-NTBASE].value = ty
 						}
 					}
 					continue;
 
 				case ',':
-					continue;
+					continue
 				}
 				break;
 			}
 			continue;
 
 		case UNION:
-			cpyunion();
+			cpyunion()
 
 		case LEFT, BINARY, RIGHT, TERM:
 			// nonzero means new prec. and assoc.
 			lev := t-TERM;
 			if lev != 0 {
-				i++;
+				i++
 			}
 			ty = 0;
 
@@ -451,23 +451,23 @@ outer:
 					continue;
 
 				case ';':
-					break;
+					break
 
 				case IDENTIFIER:
 					j = chfind(0, tokname);
 					if j >= NTBASE {
-						error("%v defined earlier as nonterminal", tokname);
+						error("%v defined earlier as nonterminal", tokname)
 					}
 					if lev != 0 {
 						if ASSOC(toklev[j]) != 0 {
-							error("redeclaration of precedence of %v", tokname);
+							error("redeclaration of precedence of %v", tokname)
 						}
 						toklev[j] = SETASC(toklev[j], lev);
 						toklev[j] = SETPLEV(toklev[j], i);
 					}
 					if ty != 0 {
 						if TYPE(toklev[j]) != 0 {
-							error("redeclaration of type of %v", tokname);
+							error("redeclaration of type of %v", tokname)
 						}
 						toklev[j] = SETTYPE(toklev[j], ty);
 					}
@@ -484,13 +484,13 @@ outer:
 			continue;
 
 		case LCURLY:
-			cpycode();
+			cpycode()
 		}
 		t = gettok();
 	}
 
 	if t == ENDFILE {
-		error("unexpected EOF before %%");
+		error("unexpected EOF before %%")
 	}
 
 	// put out non-literal terminals
@@ -498,14 +498,14 @@ outer:
 		// non-literals
 		c := tokset[i].name[0];
 		if c != ' ' && c != '$' {
-			fmt.Fprintf(ftable, "const\t%v\t= %v\n", tokset[i].name, tokset[i].value);
+			fmt.Fprintf(ftable, "const\t%v\t= %v\n", tokset[i].name, tokset[i].value)
 		}
 	}
 
 	// put out names of token names
 	fmt.Fprintf(ftable, "var\tToknames\t =[]string {\n");
 	for i := TOKSTART; i <= ntokens; i++ {
-		fmt.Fprintf(ftable, "\t\"%v\",\n", tokset[i].name);
+		fmt.Fprintf(ftable, "\t\"%v\",\n", tokset[i].name)
 	}
 	fmt.Fprintf(ftable, "}\n");
 
@@ -527,11 +527,11 @@ outer:
 	curprod := make([]int, RULEINC);
 	t = gettok();
 	if t != IDENTCOLON {
-		error("bad syntax on first rule");
+		error("bad syntax on first rule")
 	}
 
 	if start == 0 {
-		prdptr[0][1] = chfind(1, tokname);
+		prdptr[0][1] = chfind(1, tokname)
 	}
 
 	// read rules
@@ -551,11 +551,11 @@ outer:
 		} else if t == IDENTCOLON {
 			curprod[mem] = chfind(1, tokname);
 			if curprod[mem] < NTBASE {
-				error("token illegal on LHS of grammar rule");
+				error("token illegal on LHS of grammar rule")
 			}
 			mem++;
 		} else {
-			error("illegal rule: missing semicolon or | ?");
+			error("illegal rule: missing semicolon or | ?")
 		}
 
 		// read rule body
@@ -564,13 +564,13 @@ outer:
 			for t == IDENTIFIER {
 				curprod[mem] = chfind(1, tokname);
 				if curprod[mem] < NTBASE {
-					levprd[nprod] = toklev[curprod[mem]];
+					levprd[nprod] = toklev[curprod[mem]]
 				}
 				mem++;
 				if mem >= len(curprod) {
 					ncurprod := make([]int, mem+RULEINC);
 					for ll := 0; ll < mem; ll++ {
-						ncurprod[ll] = curprod[ll];
+						ncurprod[ll] = curprod[ll]
 					}
 					curprod = ncurprod;
 				}
@@ -578,17 +578,17 @@ outer:
 			}
 			if t == PREC {
 				if gettok() != IDENTIFIER {
-					error("illegal %%prec syntax");
+					error("illegal %%prec syntax")
 				}
 				j = chfind(2, tokname);
 				if j >= NTBASE {
-					error("nonterminal " + nontrst[j-NTBASE].name + " illegal after %%prec");
+					error("nonterminal " + nontrst[j-NTBASE].name + " illegal after %%prec")
 				}
 				levprd[nprod] = toklev[j];
 				t = gettok();
 			}
 			if t != '=' {
-				break;
+				break
 			}
 			levprd[nprod] |= ACTFLAG;
 			fmt.Fprintf(ftable, "\ncase %v:", nprod);
@@ -621,7 +621,7 @@ outer:
 				if mem >= len(curprod) {
 					ncurprod := make([]int, mem+RULEINC);
 					for ll := 0; ll < mem; ll++ {
-						ncurprod[ll] = curprod[ll];
+						ncurprod[ll] = curprod[ll]
 					}
 					curprod = ncurprod;
 				}
@@ -629,7 +629,7 @@ outer:
 		}
 
 		for t == ';' {
-			t = gettok();
+			t = gettok()
 		}
 		curprod[mem] = -nprod;
 		mem++;
@@ -640,15 +640,15 @@ outer:
 			// no explicit action, LHS has value
 			tempty := curprod[1];
 			if tempty < 0 {
-				error("must return a value, since LHS has a type");
+				error("must return a value, since LHS has a type")
 			}
 			if tempty >= NTBASE {
-				tempty = nontrst[tempty-NTBASE].value;
+				tempty = nontrst[tempty-NTBASE].value
 			} else {
-				tempty = TYPE(toklev[tempty]);
+				tempty = TYPE(toklev[tempty])
 			}
 			if tempty != nontrst[curprod[0]-NTBASE].value {
-				error("default action causes potential type clash");
+				error("default action causes potential type clash")
 			}
 			fmt.Fprintf(ftable, "\ncase %v:", nprod);
 			fmt.Fprintf(ftable, "\n\tYYVAL.%v = YYS[yypt-0].%v;",
@@ -657,7 +657,7 @@ outer:
 		moreprod();
 		prdptr[nprod] = make([]int, mem);
 		for ll := 0; ll < mem; ll++ {
-			prdptr[nprod][ll] = curprod[ll];
+			prdptr[nprod][ll] = curprod[ll]
 		}
 		nprod++;
 		moreprod();
@@ -681,12 +681,12 @@ outer:
 	//
 	if t == MARK {
 		if !lflag {
-			fmt.Fprintf(ftable, "\n//line %v:%v\n", infile, lineno);
+			fmt.Fprintf(ftable, "\n//line %v:%v\n", infile, lineno)
 		}
 		for {
 			c := getrune(finput);
 			if c == EOF {
-				break;
+				break
 			}
 			putrune(ftable, c);
 		}
@@ -727,7 +727,7 @@ func defin(nt int, s string) int {
 		if nnonter >= len(nontrst) {
 			anontrst := make([]Symb, nnonter+SYMINC);
 			for ll := 0; ll < len(nontrst); ll++ {
-				anontrst[ll] = nontrst[ll];
+				anontrst[ll] = nontrst[ll]
 			}
 			nontrst = anontrst;
 		}
@@ -756,31 +756,31 @@ func defin(nt int, s string) int {
 	// establish value for token
 	// single character literal
 	if s[0] == ' ' && len(s) == 1+1 {
-		val = int(s[1]);
+		val = int(s[1])
 	} else if s[0] == ' ' && s[1] == '\\' {	// escape sequence
 		if len(s) == 2+1 {
 			// single character escape sequence
 			switch s[2] {
 			case '\'':
-				val = '\'';
+				val = '\''
 			case '"':
-				val = '"';
+				val = '"'
 			case '\\':
-				val = '\\';
+				val = '\\'
 			case 'a':
-				val = '\a';
+				val = '\a'
 			case 'b':
-				val = '\b';
+				val = '\b'
 			case 'n':
-				val = '\n';
+				val = '\n'
 			case 'r':
-				val = '\r';
+				val = '\r'
 			case 't':
-				val = '\t';
+				val = '\t'
 			case 'v':
-				val = '\v';
+				val = '\v'
 			default:
-				error("invalid escape %v", s[1:3]);
+				error("invalid escape %v", s[1:3])
 			}
 		} else if s[2] == 'u' && len(s) == 2+1+4 {	// \unnnn sequence
 			val = 0;
@@ -789,22 +789,22 @@ func defin(nt int, s string) int {
 				c := int(s[0]);
 				switch {
 				case c >= '0' && c <= '9':
-					c -= '0';
+					c -= '0'
 				case c >= 'a' && c <= 'f':
-					c -= 'a'-10;
+					c -= 'a'-10
 				case c >= 'A' && c <= 'F':
-					c -= 'A'-10;
+					c -= 'A'-10
 				default:
-					error("illegal \\unnnn construction");
+					error("illegal \\unnnn construction")
 				}
 				val = val*16 + c;
 				s = s[1:len(s)];
 			}
 			if val == 0 {
-				error("'\\u0000' is illegal");
+				error("'\\u0000' is illegal")
 			}
 		} else {
-			error("unknown escape");
+			error("unknown escape")
 		}
 	} else {
 		val = extval;
@@ -827,14 +827,14 @@ func gettok() int {
 		c = getrune(finput);
 		for c == ' ' || c == '\n' || c == '\t' || c == '\v' || c == '\r' {
 			if c == '\n' {
-				lineno++;
+				lineno++
 			}
 			c = getrune(finput);
 		}
 
 		// skip comment -- fix
 		if c != '/' {
-			break;
+			break
 		}
 		lineno += skipcom();
 	}
@@ -842,14 +842,14 @@ func gettok() int {
 	switch c {
 	case EOF:
 		if tokflag {
-			fmt.Printf(">>> ENDFILE %v\n", lineno);
+			fmt.Printf(">>> ENDFILE %v\n", lineno)
 		}
 		return ENDFILE;
 
 	case '{':
 		ungetrune(finput, c);
 		if tokflag {
-			fmt.Printf(">>> ={ %v\n", lineno);
+			fmt.Printf(">>> ={ %v\n", lineno)
 		}
 		return '=';
 
@@ -862,14 +862,14 @@ func gettok() int {
 		}
 
 		if c != '>' {
-			error("unterminated < ... > clause");
+			error("unterminated < ... > clause")
 		}
 
 		for i = 1; i <= ntypes; i++ {
 			if typeset[i] == tokname {
 				numbval = i;
 				if tokflag {
-					fmt.Printf(">>> TYPENAME old <%v> %v\n", tokname, lineno);
+					fmt.Printf(">>> TYPENAME old <%v> %v\n", tokname, lineno)
 				}
 				return TYPENAME;
 			}
@@ -878,7 +878,7 @@ func gettok() int {
 		numbval = ntypes;
 		typeset[numbval] = tokname;
 		if tokflag {
-			fmt.Printf(">>> TYPENAME new <%v> %v\n", tokname, lineno);
+			fmt.Printf(">>> TYPENAME new <%v> %v\n", tokname, lineno)
 		}
 		return TYPENAME;
 
@@ -888,14 +888,14 @@ func gettok() int {
 		for {
 			c = getrune(finput);
 			if c == '\n' || c == EOF {
-				error("illegal or missing ' or \"");
+				error("illegal or missing ' or \"")
 			}
 			if c == '\\' {
 				tokname += string('\\');
 				c = getrune(finput);
 			} else if c == match {
 				if tokflag {
-					fmt.Printf(">>> IDENTIFIER \"%v\" %v\n", tokname, lineno);
+					fmt.Printf(">>> IDENTIFIER \"%v\" %v\n", tokname, lineno)
 				}
 				return IDENTIFIER;
 			}
@@ -907,17 +907,17 @@ func gettok() int {
 		switch c {
 		case '%':
 			if tokflag {
-				fmt.Printf(">>> MARK %%%% %v\n", lineno);
+				fmt.Printf(">>> MARK %%%% %v\n", lineno)
 			}
 			return MARK;
 		case '=':
 			if tokflag {
-				fmt.Printf(">>> PREC %%= %v\n", lineno);
+				fmt.Printf(">>> PREC %%= %v\n", lineno)
 			}
 			return PREC;
 		case '{':
 			if tokflag {
-				fmt.Printf(">>> LCURLY %%{ %v\n", lineno);
+				fmt.Printf(">>> LCURLY %%{ %v\n", lineno)
 			}
 			return LCURLY;
 		}
@@ -928,7 +928,7 @@ func gettok() int {
 			if tokname == resrv[c].name {
 				if tokflag {
 					fmt.Printf(">>> %%%v %v %v\n", tokname,
-						resrv[c].value - PRIVATE, lineno);
+						resrv[c].value - PRIVATE, lineno)
 				}
 				return resrv[c].value;
 			}
@@ -940,13 +940,13 @@ func gettok() int {
 		for {
 			c = getrune(finput);
 			if !isdigit(c) {
-				break;
+				break
 			}
 			numbval = numbval*10 + c - '0';
 		}
 		ungetrune(finput, c);
 		if tokflag {
-			fmt.Printf(">>> NUMBER %v %v\n", numbval, lineno);
+			fmt.Printf(">>> NUMBER %v %v\n", numbval, lineno)
 		}
 		return NUMBER;
 
@@ -956,7 +956,7 @@ func gettok() int {
 			break;
 		}
 		if tokflag {
-			fmt.Printf(">>> OPERATOR %v %v\n", string(c), lineno);
+			fmt.Printf(">>> OPERATOR %v %v\n", string(c), lineno)
 		}
 		return c;
 	}
@@ -965,24 +965,24 @@ func gettok() int {
 	c = getrune(finput);
 	for c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\r' || c == '/' {
 		if c == '\n' {
-			peekline++;
+			peekline++
 		}
 		// look for comments
 		if c == '/' {
-			peekline += skipcom();
+			peekline += skipcom()
 		}
 		c = getrune(finput);
 	}
 	if c == ':' {
 		if tokflag {
-			fmt.Printf(">>> IDENTCOLON %v: %v\n", tokname, lineno);
+			fmt.Printf(">>> IDENTCOLON %v: %v\n", tokname, lineno)
 		}
 		return IDENTCOLON;
 	}
 
 	ungetrune(finput, c);
 	if tokflag {
-		fmt.Printf(">>> IDENTIFIER %v %v\n", tokname, lineno);
+		fmt.Printf(">>> IDENTIFIER %v %v\n", tokname, lineno)
 	}
 	return IDENTIFIER;
 }
@@ -1011,29 +1011,29 @@ func fdtype(t int) int {
 		s = tokset[t].name;
 	}
 	if v <= 0 {
-		error("must specify type for %v", s);
+		error("must specify type for %v", s)
 	}
 	return v;
 }
 
 func chfind(t int, s string) int {
 	if s[0] == ' ' {
-		t = 0;
+		t = 0
 	}
 	for i := 0; i <= ntokens; i++ {
 		if s == tokset[i].name {
-			return i;
+			return i
 		}
 	}
 	for i := 0; i <= nnonter; i++ {
 		if s == nontrst[i].name {
-			return NTBASE+i;
+			return NTBASE+i
 		}
 	}
 
 	// cannot find name
 	if t > 1 {
-		error("%v should have been defined earlier", s);
+		error("%v should have been defined earlier", s)
 	}
 	return defin(t, s);
 }
@@ -1044,7 +1044,7 @@ func chfind(t int, s string) int {
 func cpyunion() {
 
 	if !lflag {
-		fmt.Fprintf(ftable, "\n//line %v %v\n", lineno, infile);
+		fmt.Fprintf(ftable, "\n//line %v %v\n", lineno, infile)
 	}
 	fmt.Fprintf(ftable, "type\tYYSTYPE\tstruct");
 
@@ -1054,21 +1054,21 @@ out:
 	for {
 		c := getrune(finput);
 		if c == EOF {
-			error("EOF encountered while processing %%union");
+			error("EOF encountered while processing %%union")
 		}
 		putrune(ftable, c);
 		switch c {
 		case '\n':
-			lineno++;
+			lineno++
 		case '{':
 			if level == 0 {
-				fmt.Fprintf(ftable, "\n\tyys\tint;");
+				fmt.Fprintf(ftable, "\n\tyys\tint;")
 			}
 			level++;
 		case '}':
 			level--;
 			if level == 0 {
-				break out;
+				break out
 			}
 		}
 	}
@@ -1090,19 +1090,19 @@ func cpycode() {
 		lineno++;
 	}
 	if !lflag {
-		fmt.Fprintf(ftable, "\n//line %v %v\n", lineno, infile);
+		fmt.Fprintf(ftable, "\n//line %v %v\n", lineno, infile)
 	}
 	for c != EOF {
 		if c == '%' {
 			c = getrune(finput);
 			if c == '}' {
-				return;
+				return
 			}
 			putrune(ftable, '%');
 		}
 		putrune(ftable, c);
 		if c == '\n' {
-			lineno++;
+			lineno++
 		}
 		c = getrune(finput);
 	}
@@ -1189,7 +1189,7 @@ func skipcom() int {
 	if c == '/' {
 		for c != EOF {
 			if c == '\n' {
-				return 1;
+				return 1
 			}
 			c = getrune(finput);
 		}
@@ -1197,7 +1197,7 @@ func skipcom() int {
 		return 0;
 	}
 	if c != '*' {
-		error("illegal comment");
+		error("illegal comment")
 	}
 
 	nl := 0;	// lines skipped
@@ -1208,7 +1208,7 @@ l1:
 	case '*':
 		c = getrune(finput);
 		if c == '/' {
-			break;
+			break
 		}
 		goto l1;
 
@@ -1228,9 +1228,9 @@ func dumpprod(curprod []int, max int) {
 	for i := 0; i < max; i++ {
 		p := curprod[i];
 		if p < 0 {
-			fmt.Printf("[%v] %v\n", i, p);
+			fmt.Printf("[%v] %v\n", i, p)
 		} else {
-			fmt.Printf("[%v] %v\n", i, symnam(p));
+			fmt.Printf("[%v] %v\n", i, symnam(p))
 		}
 	}
 }
@@ -1241,7 +1241,7 @@ func dumpprod(curprod []int, max int) {
 func cpyact(curprod []int, max int) {
 
 	if !lflag {
-		fmt.Fprintf(ftable, "\n//line %v %v\n", lineno, infile);
+		fmt.Fprintf(ftable, "\n//line %v %v\n", lineno, infile)
 	}
 
 	lno := lineno;
@@ -1274,7 +1274,7 @@ loop:
 			if c == '<' {
 				ungetrune(finput, c);
 				if gettok() != TYPENAME {
-					error("bad syntax on $<ident> clause");
+					error("bad syntax on $<ident> clause")
 				}
 				tok = numbval;
 				c = getrune(finput);
@@ -1285,7 +1285,7 @@ loop:
 				// put out the proper tag...
 				if ntypes != 0 {
 					if tok < 0 {
-						tok = fdtype(curprod[0]);
+						tok = fdtype(curprod[0])
 					}
 					fmt.Fprintf(ftable, ".%v", typeset[tok]);
 				}
@@ -1304,39 +1304,39 @@ loop:
 				ungetrune(finput, c);
 				j = j*s;
 				if j >= max {
-					error("Illegal use of $%v", j);
+					error("Illegal use of $%v", j)
 				}
 			} else if isword(c) || c == '_' || c == '.' {
 				// look for $name
 				ungetrune(finput, c);
 				if gettok() != IDENTIFIER {
-					error("$ must be followed by an identifier");
+					error("$ must be followed by an identifier")
 				}
 				tokn := chfind(2, tokname);
 				fnd := -1;
 				c = getrune(finput);
 				if c != '@' {
-					ungetrune(finput, c);
+					ungetrune(finput, c)
 				} else if gettok() != NUMBER {
-					error("@ must be followed by number");
+					error("@ must be followed by number")
 				} else {
-					fnd = numbval;
+					fnd = numbval
 				}
 				for j = 1; j < max; j++ {
 					if tokn == curprod[j] {
 						fnd--;
 						if fnd <= 0 {
-							break;
+							break
 						}
 					}
 				}
 				if j >= max {
-					error("$name or $name@number not found");
+					error("$name or $name@number not found")
 				}
 			} else {
 				putrune(ftable, '$');
 				if s < 0 {
-					putrune(ftable, '-');
+					putrune(ftable, '-')
 				}
 				ungetrune(finput, c);
 				continue loop;
@@ -1346,10 +1346,10 @@ loop:
 			// put out the proper tag
 			if ntypes != 0 {
 				if j <= 0 && tok < 0 {
-					error("must specify type of $%v", j);
+					error("must specify type of $%v", j)
 				}
 				if tok < 0 {
-					tok = fdtype(curprod[j]);
+					tok = fdtype(curprod[j])
 				}
 				fmt.Fprintf(ftable, ".%v", typeset[tok]);
 			}
@@ -1358,7 +1358,7 @@ loop:
 		case '}':
 			brac--;
 			if brac != 0 {
-				break;
+				break
 			}
 			putrune(ftable, c);
 			return;
@@ -1387,13 +1387,13 @@ loop:
 					putrune(ftable, c);
 					c = getrune(finput);
 					if c == '\n' {
-						lineno++;
+						lineno++
 					}
 				} else if c == match {
-					break swt;
+					break swt
 				}
 				if c == '\n' {
-					error("newline in string or char const");
+					error("newline in string or char const")
 				}
 				putrune(ftable, c);
 				c = getrune(finput);
@@ -1405,7 +1405,7 @@ loop:
 			error("action does not terminate");
 
 		case '\n':
-			lineno++;
+			lineno++
 		}
 
 		putrune(ftable, c);
@@ -1416,24 +1416,24 @@ func openup() {
 	infile = flag.Arg(0);
 	finput = open(infile);
 	if finput == nil {
-		error("cannot open %v", infile);
+		error("cannot open %v", infile)
 	}
 
 	foutput = nil;
 	if vflag != "" {
 		foutput = create(vflag, 0666);
 		if foutput == nil {
-			error("can't create file %v", vflag);
+			error("can't create file %v", vflag)
 		}
 	}
 
 	ftable = nil;
 	if oflag == "" {
-		oflag = "y.go";
+		oflag = "y.go"
 	}
 	ftable = create(oflag, 0666);
 	if ftable == nil {
-		error("can't create file %v", oflag);
+		error("can't create file %v", oflag)
 	}
 
 }
@@ -1445,12 +1445,12 @@ func symnam(i int) string {
 	var s string;
 
 	if i >= NTBASE {
-		s = nontrst[i-NTBASE].name;
+		s = nontrst[i-NTBASE].name
 	} else {
-		s = tokset[i].name;
+		s = tokset[i].name
 	}
 	if s[0] == ' ' {
-		s = s[1:len(s)];
+		s = s[1:len(s)]
 	}
 	return s;
 }
@@ -1460,7 +1460,7 @@ func symnam(i int) string {
 //
 func aryfil(v []int, n, c int) {
 	for i := 0; i < n; i++ {
-		v[i] = c;
+		v[i] = c
 	}
 }
 
@@ -1475,10 +1475,10 @@ func cpres() {
 
 	if false {
 		for j := 0; j <= nnonter; j++ {
-			fmt.Printf("nnonter[%v] = %v\n", j, nontrst[j].name);
+			fmt.Printf("nnonter[%v] = %v\n", j, nontrst[j].name)
 		}
 		for j := 0; j < nprod; j++ {
-			fmt.Printf("prdptr[%v][0] = %v+NTBASE\n", j, prdptr[j][0]-NTBASE);
+			fmt.Printf("prdptr[%v][0] = %v+NTBASE\n", j, prdptr[j][0]-NTBASE)
 		}
 	}
 
@@ -1498,7 +1498,7 @@ func cpres() {
 		}
 		pres[i] = make([][]int, n);
 		for ll := 0; ll < n; ll++ {
-			pres[i][ll] = curres[ll];
+			pres[i][ll] = curres[ll]
 		}
 	}
 	fatfl = 1;
@@ -1516,7 +1516,7 @@ func dumppres() {
 			print("\tproduction %d:", j);
 			prd := curres[j];
 			for k := 0; k < len(prd); k++ {
-				print(" %d", prd[k]);
+				print(" %d", prd[k])
 			}
 			print("\n");
 		}
@@ -1543,12 +1543,12 @@ more:
 		for i = 0; i < nprod; i++ {
 			prd = prdptr[i];
 			if pempty[prd[0]-NTBASE] != 0 {
-				continue;
+				continue
 			}
 			np = len(prd)-1;
 			for p = 1; p < np; p++ {
 				if prd[p] >= NTBASE && pempty[prd[p]-NTBASE] == WHOKNOWS {
-					break;
+					break
 				}
 			}
 			// production can be derived
@@ -1564,7 +1564,7 @@ more:
 	for i = 0; i <= nnonter; i++ {
 		// the added production rises or falls as the start symbol ...
 		if i == 0 {
-			continue;
+			continue
 		}
 		if pempty[i] != OK {
 			fatfl = 0;
@@ -1590,12 +1590,12 @@ again:
 			// not known to be empty
 			prd = prdptr[i];
 			if pempty[prd[0]-NTBASE] != WHOKNOWS {
-				continue;
+				continue
 			}
 			np = len(prd)-1;
 			for p = 1; p < np; p++ {
 				if prd[p] < NTBASE || pempty[prd[p]-NTBASE] != EMPTY {
-					continue next;
+					continue next
 				}
 			}
 
@@ -1612,7 +1612,7 @@ again:
 func dumpempty() {
 	for i := 0; i <= nnonter; i++ {
 		if pempty[i] == EMPTY {
-			print("non-term %d %s matches empty\n", i, symnam(i+NTBASE));
+			print("non-term %d %s matches empty\n", i, symnam(i+NTBASE))
 		}
 	}
 }
@@ -1644,7 +1644,7 @@ func cpfir() {
 					break;
 				}
 				if pempty[ch-NTBASE] == 0 {
-					break;
+					break
 				}
 			}
 		}
@@ -1663,11 +1663,11 @@ func cpfir() {
 				for p = 0; p < np; p++ {
 					ch = prd[p]-NTBASE;
 					if ch < 0 {
-						break;
+						break
 					}
 					changes |= setunion(pfirst[i], pfirst[ch]);
 					if pempty[ch] == 0 {
-						break;
+						break
 					}
 				}
 			}
@@ -1675,12 +1675,12 @@ func cpfir() {
 	}
 
 	if indebug == 0 {
-		return;
+		return
 	}
 	if foutput != nil {
 		for i = 0; i <= nnonter; i++ {
 			fmt.Fprintf(foutput, "\n%v: %v %v\n",
-				nontrst[i].name, pfirst[i], pempty[i]);
+				nontrst[i].name, pfirst[i], pempty[i])
 		}
 	}
 }
@@ -1717,7 +1717,7 @@ func stagen() {
 		more = 0;
 		for i := 0; i < nstate; i++ {
 			if tystate[i] != MUSTDO {
-				continue;
+				continue
 			}
 
 			tystate[i] = DONE;
@@ -1730,13 +1730,13 @@ func stagen() {
 			for p := 0; p < cwp; p++ {
 				pi := wsets[p];
 				if pi.flag != 0 {
-					continue;
+					continue
 				}
 				wsets[p].flag = 1;
 				c := pi.pitem.first;
 				if c <= 1 {
 					if pstate[i+1]-pstate[i] <= p {
-						tystate[i] = MUSTLOOKAHEAD;
+						tystate[i] = MUSTLOOKAHEAD
 					}
 					continue;
 				}
@@ -1752,9 +1752,9 @@ func stagen() {
 				}
 
 				if c < NTBASE {
-					state(c);	// register new state
+					state(c)	// register new state
 				} else {
-					temp1[c-NTBASE] = state(c);
+					temp1[c-NTBASE] = state(c)
 				}
 			}
 
@@ -1762,14 +1762,14 @@ func stagen() {
 				fmt.Fprintf(foutput, "%v: ", i);
 				for j := 0; j <= nnonter; j++ {
 					if temp1[j] != 0 {
-						fmt.Fprintf(foutput, "%v %v,", nontrst[j].name, temp1[j]);
+						fmt.Fprintf(foutput, "%v %v,", nontrst[j].name, temp1[j])
 					}
 				}
 				fmt.Fprintf(foutput, "\n");
 			}
 
 			if first != 0 {
-				indgo[i] = apack(temp1[1:len(temp1)], nnonter-1) - 1;
+				indgo[i] = apack(temp1[1:len(temp1)], nnonter-1) - 1
 			}
 
 			more++;
@@ -1790,7 +1790,7 @@ func closure(i int) {
 		wsets[cwp].pitem = statemem[p].pitem;
 		wsets[cwp].flag = 1;	// this item must get closed
 		for ll := 0; ll < len(wsets[cwp].ws); ll++ {
-			wsets[cwp].ws[ll] = statemem[p].look[ll];
+			wsets[cwp].ws[ll] = statemem[p].look[ll]
 		}
 		cwp++;
 	}
@@ -1801,7 +1801,7 @@ func closure(i int) {
 		work = 0;
 		for u := 0; u < cwp; u++ {
 			if wsets[u].flag == 0 {
-				continue;
+				continue
 			}
 
 			// dot is before c
@@ -1818,14 +1818,14 @@ func closure(i int) {
 			// find items involving c
 			for v := u; v < cwp; v++ {
 				if wsets[v].flag != 1 || wsets[v].pitem.first != c {
-					continue;
+					continue
 				}
 				pi := wsets[v].pitem.prod;
 				ipi := wsets[v].pitem.off + 1;
 
 				wsets[v].flag = 0;
 				if nolook != 0 {
-					continue;
+					continue
 				}
 
 				ch := pi[ipi];
@@ -1840,13 +1840,13 @@ func closure(i int) {
 					// nonterminal symbol
 					setunion(clset, pfirst[ch-NTBASE]);
 					if pempty[ch-NTBASE] == 0 {
-						break;
+						break
 					}
 					ch = pi[ipi];
 					ipi++;
 				}
 				if ch <= 0 {
-					setunion(clset, wsets[v].ws);
+					setunion(clset, wsets[v].ws)
 				}
 			}
 
@@ -1882,7 +1882,7 @@ func closure(i int) {
 				if cwp >= len(wsets) {
 					awsets := make([]Wset, cwp+WSETINC);
 					for ll := 0; ll < len(wsets); ll++ {
-						awsets[ll] = wsets[ll];
+						awsets[ll] = wsets[ll]
 					}
 					wsets = awsets;
 				}
@@ -1892,7 +1892,7 @@ func closure(i int) {
 				if nolook == 0 {
 					work = 1;
 					for ll := 0; ll < len(wsets[cwp].ws); ll++ {
-						wsets[cwp].ws[ll] = clset[ll];
+						wsets[cwp].ws[ll] = clset[ll]
 					}
 				}
 				cwp++;
@@ -1905,7 +1905,7 @@ func closure(i int) {
 		fmt.Fprintf(foutput, "\nState %v, nolook = %v\n", i, nolook);
 		for u := 0; u < cwp; u++ {
 			if wsets[u].flag != 0 {
-				fmt.Fprintf(foutput, "flag set\n");
+				fmt.Fprintf(foutput, "flag set\n")
 			}
 			wsets[u].flag = 0;
 			fmt.Fprintf(foutput, "\t%v", writem(wsets[u].pitem));
@@ -1923,7 +1923,7 @@ func state(c int) int {
 	p1 := pstate[nstate];
 	p2 := pstate[nstate+1];
 	if p1 == p2 {
-		return 0;	// null state
+		return 0	// null state
 	}
 
 	// sort the items
@@ -1937,7 +1937,7 @@ func state(c int) int {
 				statemem[l] = statemem[l-1];
 				statemem[l-1] = s;
 			} else {
-				break;
+				break
 			}
 		}
 	}
@@ -1946,9 +1946,9 @@ func state(c int) int {
 
 	var i int;
 	if c >= NTBASE {
-		i = ntstates[c-NTBASE];
+		i = ntstates[c-NTBASE]
 	} else {
-		i = tstates[c];
+		i = tstates[c]
 	}
 
 look:
@@ -1958,13 +1958,13 @@ look:
 		q2 := pstate[i+1];
 		size2 := q2-q1;
 		if size1 != size2 {
-			continue;
+			continue
 		}
 		k = p1;
 		for l = q1; l < q2; l++ {
 			if aryeq(statemem[l].pitem.prod, statemem[k].pitem.prod) == 0 ||
 				statemem[l].pitem.off != statemem[k].pitem.off {
-				continue look;
+				continue look
 			}
 			k++;
 		}
@@ -1974,12 +1974,12 @@ look:
 
 		// fix up lookaheads
 		if nolook != 0 {
-			return i;
+			return i
 		}
 		k = p1;
 		for l = q1; l < q2; l++ {
 			if setunion(statemem[l].look, statemem[k].look) != 0 {
-				tystate[i] = MUSTDO;
+				tystate[i] = MUSTDO
 			}
 			k++;
 		}
@@ -1989,11 +1989,11 @@ look:
 	// state is new
 	zznewstate++;
 	if nolook != 0 {
-		error("yacc state/nolook error");
+		error("yacc state/nolook error")
 	}
 	pstate[nstate+2] = p2;
 	if nstate+1 >= NSTATES {
-		error("too many states");
+		error("too many states")
 	}
 	if c >= NTBASE {
 		mstates[nstate] = ntstates[c-NTBASE];
@@ -2012,13 +2012,13 @@ func putitem(p Pitem, set Lkset) {
 	p.first = p.prod[p.off];
 
 	if pidebug != 0 && foutput != nil {
-		fmt.Fprintf(foutput, "putitem(%v), state %v\n", writem(p), nstate);
+		fmt.Fprintf(foutput, "putitem(%v), state %v\n", writem(p), nstate)
 	}
 	j := pstate[nstate+1];
 	if j >= len(statemem) {
 		asm := make([]Item, j+STATEINC);
 		for ll := 0; ll < len(statemem); ll++ {
-			asm[ll] = statemem[ll];
+			asm[ll] = statemem[ll]
 		}
 		statemem = asm;
 	}
@@ -2026,7 +2026,7 @@ func putitem(p Pitem, set Lkset) {
 	if nolook == 0 {
 		s := mkset();
 		for ll := 0; ll < len(set); ll++ {
-			s[ll] = set[ll];
+			s[ll] = set[ll]
 		}
 		statemem[j].look = s;
 	}
@@ -2049,14 +2049,14 @@ func writem(pp Pitem) string {
 	for {
 		c := ' ';
 		if pi == npi {
-			c = '.';
+			c = '.'
 		}
 		q += string(c);
 
 		i = p[pi];
 		pi++;
 		if i <= 0 {
-			break;
+			break
 		}
 		q += chcopy(symnam(i));
 	}
@@ -2064,7 +2064,7 @@ func writem(pp Pitem) string {
 	// an item calling for a reduction
 	i = p[npi];
 	if i < 0 {
-		q += fmt.Sprintf("    (%v)", -i);
+		q += fmt.Sprintf("    (%v)", -i)
 	}
 
 	return q;
@@ -2082,12 +2082,12 @@ func apack(p []int, n int) int {
 	off := 0;
 	pp := 0;
 	for ; pp <= n && p[pp] == 0; pp++ {
-		off--;
+		off--
 	}
 
 	// no actions
 	if pp > n {
-		return 0;
+		return 0
 	}
 	for ; n > pp && p[n] == 0; n-- {
 	}
@@ -2102,7 +2102,7 @@ nextk:
 		for pp = 0; pp < len(p); pp++ {
 			if p[pp] != 0 {
 				if p[pp] != amem[qq] && amem[qq] != 0 {
-					continue nextk;
+					continue nextk
 				}
 			}
 			qq++;
@@ -2110,13 +2110,13 @@ nextk:
 
 		// we have found an acceptable k
 		if pkdebug != 0 && foutput != nil {
-			fmt.Fprintf(foutput, "off = %v, k = %v\n", off+rr, rr);
+			fmt.Fprintf(foutput, "off = %v, k = %v\n", off+rr, rr)
 		}
 		qq = rr;
 		for pp = 0; pp < len(p); pp++ {
 			if p[pp] != 0 {
 				if qq > memp {
-					memp = qq;
+					memp = qq
 				}
 				amem[qq] = p[pp];
 			}
@@ -2126,7 +2126,7 @@ nextk:
 			for pp = 0; pp <= memp; pp += 10 {
 				fmt.Fprintf(foutput, "\n");
 				for qq = pp; qq <= pp+9; qq++ {
-					fmt.Fprintf(foutput, "%v ", amem[qq]);
+					fmt.Fprintf(foutput, "%v ", amem[qq])
 				}
 				fmt.Fprintf(foutput, "\n");
 			}
@@ -2151,7 +2151,7 @@ func output() {
 	for i := 0; i < nstate; i++ {
 		nolook = 0;
 		if tystate[i] != MUSTLOOKAHEAD {
-			nolook = 1;
+			nolook = 1
 		}
 		closure(i);
 
@@ -2163,19 +2163,19 @@ func output() {
 			if c > 1 && c < NTBASE && temp1[c] == 0 {
 				for v = u; v < cwp; v++ {
 					if c == wsets[v].pitem.first {
-						putitem(wsets[v].pitem, noset);
+						putitem(wsets[v].pitem, noset)
 					}
 				}
 				temp1[c] = state(c);
 			} else if c > NTBASE {
 				c -= NTBASE;
 				if temp1[c+ntokens] == 0 {
-					temp1[c+ntokens] = amem[indgo[i]+c];
+					temp1[c+ntokens] = amem[indgo[i]+c]
 				}
 			}
 		}
 		if i == 1 {
-			temp1[1] = ACCEPTCODE;
+			temp1[1] = ACCEPTCODE
 		}
 
 		// now, we have the shifts; look at the reductions
@@ -2185,30 +2185,30 @@ func output() {
 
 			// reduction
 			if c > 0 {
-				continue;
+				continue
 			}
 			lastred = -c;
 			us := wsets[u].ws;
 			for k := 0; k <= ntokens; k++ {
 				if bitset(us, k) == 0 {
-					continue;
+					continue
 				}
 				if temp1[k] == 0 {
-					temp1[k] = c;
+					temp1[k] = c
 				} else if temp1[k] < 0 {	// reduce/reduce conflict
 					if foutput != nil {
 						fmt.Fprintf(foutput,
 							"\n %v: reduce/reduce conflict  (red'ns "
 								"%v and %v) on %v",
-							i, -temp1[k], lastred, symnam(k));
+							i, -temp1[k], lastred, symnam(k))
 					}
 					if -temp1[k] > lastred {
-						temp1[k] = -lastred;
+						temp1[k] = -lastred
 					}
 					zzrrconf++;
 				} else {
 					// potential shift/reduce conflict
-					precftn(lastred, k, i);
+					precftn(lastred, k, i)
 				}
 			}
 		}
@@ -2238,23 +2238,23 @@ func precftn(r, t, s int) {
 		if foutput != nil {
 			fmt.Fprintf(foutput,
 				"\n%v: shift/reduce conflict (shift %v(%v), red'n %v(%v)) on %v",
-				s, temp1[t], PLEVEL(lt), r, PLEVEL(lp), symnam(t));
+				s, temp1[t], PLEVEL(lt), r, PLEVEL(lp), symnam(t))
 		}
 		zzsrconf++;
 		return;
 	}
 	if PLEVEL(lt) == PLEVEL(lp) {
-		action = ASSOC(lt);
+		action = ASSOC(lt)
 	} else if PLEVEL(lt) > PLEVEL(lp) {
-		action = RASC;	// shift
+		action = RASC	// shift
 	} else {
-		action = LASC;
+		action = LASC
 	}	// reduce
 	switch action {
 	case BASC:	// error action
-		temp1[t] = ERRCODE;
+		temp1[t] = ERRCODE
 	case LASC:	// reduce
-		temp1[t] = -r;
+		temp1[t] = -r
 	}
 }
 
@@ -2270,10 +2270,10 @@ func wract(i int) {
 	ntimes := 0;
 	for j := 0; j <= ntokens; j++ {
 		if temp1[j] >= 0 {
-			continue;
+			continue
 		}
 		if temp1[j]+lastred == 0 {
-			continue;
+			continue
 		}
 		// count the number of appearances of temp1[j]
 		count := 0;
@@ -2281,7 +2281,7 @@ func wract(i int) {
 		levprd[tred] |= REDFLAG;
 		for p = 0; p <= ntokens; p++ {
 			if temp1[p]+tred == 0 {
-				count++;
+				count++
 			}
 		}
 		if count > ntimes {
@@ -2295,7 +2295,7 @@ func wract(i int) {
 	// error recovery token, `error', that the default be the error action
 	//
 	if temp1[2] > 0 {
-		lastred = 0;
+		lastred = 0
 	}
 
 	// clear out entries in temp1 which equal lastred
@@ -2308,7 +2308,7 @@ func wract(i int) {
 			p1 = 0;
 		}
 		if p1 > 0 && p1 != ACCEPTCODE && p1 != ERRCODE {
-			n++;
+			n++
 		}
 	}
 
@@ -2321,11 +2321,11 @@ func wract(i int) {
 		p1 = temp1[p];
 		if p1 != 0 {
 			if p1 < 0 {
-				p1 = -p1;
+				p1 = -p1
 			} else if p1 == ACCEPTCODE {
-				p1 = -1;
+				p1 = -1
 			} else if p1 == ERRCODE {
-				p1 = 0;
+				p1 = 0
 			} else {
 				os[n] = p;
 				n++;
@@ -2335,7 +2335,7 @@ func wract(i int) {
 				continue;
 			}
 			if flag == 0 {
-				fmt.Fprintf(ftable, "-1, %v,\n", i);
+				fmt.Fprintf(ftable, "-1, %v,\n", i)
 			}
 			flag++;
 			fmt.Fprintf(ftable, "\t%v, %v,\n", p, p1);
@@ -2357,18 +2357,18 @@ func wrstate(i int) {
 	var pp, qq int;
 
 	if foutput == nil {
-		return;
+		return
 	}
 	fmt.Fprintf(foutput, "\nstate %v\n", i);
 	qq = pstate[i+1];
 	for pp = pstate[i]; pp < qq; pp++ {
-		fmt.Fprintf(foutput, "\t%v\n", writem(statemem[pp].pitem));
+		fmt.Fprintf(foutput, "\t%v\n", writem(statemem[pp].pitem))
 	}
 	if tystate[i] == MUSTLOOKAHEAD {
 		// print out empty productions in closure
 		for u = pstate[i+1]-pstate[i]; u < cwp; u++ {
 			if wsets[u].pitem.first < 0 {
-				fmt.Fprintf(foutput, "\t%v\n", writem(wsets[u].pitem));
+				fmt.Fprintf(foutput, "\t%v\n", writem(wsets[u].pitem))
 			}
 		}
 	}
@@ -2382,14 +2382,14 @@ func wrstate(i int) {
 			// shift, error, or accept
 			if j1 > 0 {
 				if j1 == ACCEPTCODE {
-					fmt.Fprintf(foutput, "accept");
+					fmt.Fprintf(foutput, "accept")
 				} else if j1 == ERRCODE {
-					fmt.Fprintf(foutput, "error");
+					fmt.Fprintf(foutput, "error")
 				} else {
-					fmt.Fprintf(foutput, "shift %v", j1);
+					fmt.Fprintf(foutput, "shift %v", j1)
 				}
 			} else {
-				fmt.Fprintf(foutput, "reduce %v (src line %v)", -j1, rlines[-j1]);
+				fmt.Fprintf(foutput, "reduce %v (src line %v)", -j1, rlines[-j1])
 			}
 		}
 	}
@@ -2397,9 +2397,9 @@ func wrstate(i int) {
 	// output the final production
 	if lastred != 0 {
 		fmt.Fprintf(foutput, "\n\t.  reduce %v (src line %v)\n\n",
-			lastred, rlines[lastred]);
+			lastred, rlines[lastred])
 	} else {
-		fmt.Fprintf(foutput, "\n\t.  error\n\n");
+		fmt.Fprintf(foutput, "\n\t.  error\n\n")
 	}
 
 	// now, output nonterminal actions
@@ -2407,7 +2407,7 @@ func wrstate(i int) {
 	for j0 = 1; j0 <= nnonter; j0++ {
 		j1++;
 		if temp1[j1] != 0 {
-			fmt.Fprintf(foutput, "\t%v  goto %v\n", symnam(j0+NTBASE), temp1[j1]);
+			fmt.Fprintf(foutput, "\t%v  goto %v\n", symnam(j0+NTBASE), temp1[j1])
 		}
 	}
 }
@@ -2426,10 +2426,10 @@ func go2out() {
 		// is j the most frequent
 		for j := 0; j < nstate; j++ {
 			if tystate[j] == 0 {
-				continue;
+				continue
 			}
 			if tystate[j] == best {
-				continue;
+				continue
 			}
 
 			// is tystate[j] the most frequent
@@ -2437,7 +2437,7 @@ func go2out() {
 			cbest := tystate[j];
 			for k := j; k < nstate; k++ {
 				if tystate[k] == cbest {
-					count++;
+					count++
 				}
 			}
 			if count > times {
@@ -2451,7 +2451,7 @@ func go2out() {
 		n := 0;
 		for j := 0; j < nstate; j++ {
 			if tystate[j] != 0 && tystate[j] != best {
-				n++;
+				n++
 			}
 		}
 		goent := make([]int, 2*n + 1);
@@ -2468,7 +2468,7 @@ func go2out() {
 
 		// now, the default
 		if best == -1 {
-			best = 0;
+			best = 0
 		}
 
 		zzgoent++;
@@ -2508,7 +2508,7 @@ func go2gen(c int) {
 		fmt.Fprintf(foutput, "%v: gotos on ", nontrst[c].name);
 		for i = 0; i <= nnonter; i++ {
 			if temp1[i] != 0 {
-				fmt.Fprintf(foutput, "%v ", nontrst[i].name);
+				fmt.Fprintf(foutput, "%v ", nontrst[i].name)
 			}
 		}
 		fmt.Fprintf(foutput, "\n");
@@ -2544,7 +2544,7 @@ func hideprod() {
 		if (levprd[i]&REDFLAG) == 0 {
 			if foutput != nil {
 				fmt.Fprintf(foutput, "Rule not reduced: %v\n",
-					writem(Pitem{prdptr[i], 0, 0, i}));
+					writem(Pitem{prdptr[i], 0, 0, i}))
 			}
 			fmt.Printf("rule %v never reduced\n", writem(Pitem{prdptr[i], 0, 0, i}));
 			nred++;
@@ -2552,7 +2552,7 @@ func hideprod() {
 		levprd[i] = prdptr[i][0]-NTBASE;
 	}
 	if nred != 0 {
-		fmt.Printf("%v rules never reduced\n", nred);
+		fmt.Printf("%v rules never reduced\n", nred)
 	}
 }
 
@@ -2571,10 +2571,10 @@ func callopt() {
 		q = len(v);
 		for p = 0; p < q; p += 2 {
 			if v[p] > j {
-				j = v[p];
+				j = v[p]
 			}
 			if v[p] < k {
-				k = v[p];
+				k = v[p]
 			}
 		}
 
@@ -2583,12 +2583,12 @@ func callopt() {
 			// j is now the range
 			//			j -= k;			// call scj
 			if k > maxoff {
-				maxoff = k;
+				maxoff = k
 			}
 		}
 		tystate[i] = q + 2*j;
 		if j > maxspr {
-			maxspr = j;
+			maxspr = j
 		}
 	}
 
@@ -2604,23 +2604,23 @@ func callopt() {
 		for p = 0; p < q; p += 2 {
 			ggreed[i] += 2;
 			if v[p] > j {
-				j = v[p];
+				j = v[p]
 			}
 		}
 		ggreed[i] = ggreed[i] + 2*j;
 		if j > maxoff {
-			maxoff = j;
+			maxoff = j
 		}
 	}
 
 	// now, prepare to put the shift actions into the amem array
 	for i = 0; i < ACTSIZE; i++ {
-		amem[i] = 0;
+		amem[i] = 0
 	}
 	maxa = 0;
 	for i = 0; i < nstate; i++ {
 		if tystate[i] == 0 && adb > 1 {
-			fmt.Fprintf(ftable, "State %v: null\n", i);
+			fmt.Fprintf(ftable, "State %v: null\n", i)
 		}
 		indgo[i] = YYFLAG;
 	}
@@ -2628,9 +2628,9 @@ func callopt() {
 	i = nxti();
 	for i != NOMORE {
 		if i >= 0 {
-			stin(i);
+			stin(i)
 		} else {
-			gin(-i);
+			gin(-i)
 		}
 		i = nxti();
 	}
@@ -2640,7 +2640,7 @@ func callopt() {
 		for p = 0; p <= maxa; p += 10 {
 			fmt.Fprintf(ftable, "%v  ", p);
 			for i = 0; i < 10; i++ {
-				fmt.Fprintf(ftable, "%v  ", amem[p+i]);
+				fmt.Fprintf(ftable, "%v  ", amem[p+i])
 			}
 			putrune(ftable, '\n');
 		}
@@ -2669,7 +2669,7 @@ func nxti() int {
 		}
 	}
 	if max == 0 {
-		return NOMORE;
+		return NOMORE
 	}
 	return maxi;
 }
@@ -2687,25 +2687,25 @@ func gin(i int) {
 nextgp:
 	for p := 0; p < ACTSIZE; p++ {
 		if amem[p] != 0 {
-			continue;
+			continue
 		}
 		for r := 0; r < nq; r += 2 {
 			s = p+q[r]+1;
 			if s > maxa {
 				maxa = s;
 				if maxa >= ACTSIZE {
-					error("a array overflow");
+					error("a array overflow")
 				}
 			}
 			if amem[s] != 0 {
-				continue nextgp;
+				continue nextgp
 			}
 		}
 
 		// we have found amem spot
 		amem[p] = q[nq];
 		if p > maxa {
-			maxa = p;
+			maxa = p
 		}
 		for r := 0; r < nq; r += 2 {
 			s = p+q[r]+1;
@@ -2713,7 +2713,7 @@ nextgp:
 		}
 		pgo[i] = p;
 		if adb > 1 {
-			fmt.Fprintf(ftable, "Nonterminal %v, entry at %v\n", i, pgo[i]);
+			fmt.Fprintf(ftable, "Nonterminal %v, entry at %v\n", i, pgo[i])
 		}
 		return;
 	}
@@ -2736,12 +2736,12 @@ nextn:
 		for r := 0; r < nq; r += 2 {
 			s = q[r]+n;
 			if s < 0 || s > ACTSIZE {
-				continue nextn;
+				continue nextn
 			}
 			if amem[s] == 0 {
-				flag++;
+				flag++
 			} else if amem[s] != q[r+1] {
-				continue nextn;
+				continue nextn
 			}
 		}
 
@@ -2751,7 +2751,7 @@ nextn:
 
 				// we have some disagreement
 				if flag != 0 {
-					continue nextn;
+					continue nextn
 				}
 				if nq == len(optst[j]) {
 
@@ -2760,7 +2760,7 @@ nextn:
 					if adb > 1 {
 						fmt.Fprintf(ftable, "State %v: entry at"
 							"%v equals state %v\n",
-							i, n, j);
+							i, n, j)
 					}
 					return;
 				}
@@ -2773,16 +2773,16 @@ nextn:
 		for r := 0; r < nq; r += 2 {
 			s = q[r]+n;
 			if s > maxa {
-				maxa = s;
+				maxa = s
 			}
 			if amem[s] != 0 && amem[s] != q[r+1] {
-				error("clobber of a array, pos'n %v, by %v", s, q[r+1]);
+				error("clobber of a array, pos'n %v, by %v", s, q[r+1])
 			}
 			amem[s] = q[r+1];
 		}
 		indgo[i] = n;
 		if adb > 1 {
-			fmt.Fprintf(ftable, "State %v: entry at %v\n", i, indgo[i]);
+			fmt.Fprintf(ftable, "State %v: entry at %v\n", i, indgo[i])
 		}
 		return;
 	}
@@ -2813,19 +2813,19 @@ func others() {
 	//yyr2 is the number of rules for each production
 	//
 	for i = 1; i < nprod; i++ {
-		temp1[i] = len(prdptr[i])-2;
+		temp1[i] = len(prdptr[i])-2
 	}
 	arout("YYR2", temp1, nprod);
 
 	aryfil(temp1, nstate, -1000);
 	for i = 0; i <= ntokens; i++ {
 		for j := tstates[i]; j != 0; j = mstates[j] {
-			temp1[j] = i;
+			temp1[j] = i
 		}
 	}
 	for i = 0; i <= nnonter; i++ {
 		for j = ntstates[i]; j != 0; j = mstates[j] {
-			temp1[j] = -i;
+			temp1[j] = -i
 		}
 	}
 	arout("YYCHK", temp1, nstate);
@@ -2845,13 +2845,13 @@ func others() {
 			}
 			temp1[j] = i;
 			if j > c {
-				c = j;
+				c = j
 			}
 		}
 	}
 	for i = 0; i <= c; i++ {
 		if temp1[i] == 0 {
-			temp1[i] = YYLEXUNK;
+			temp1[i] = YYLEXUNK
 		}
 	}
 	arout("YYTOK1", temp1, c+1);
@@ -2869,7 +2869,7 @@ func others() {
 			}
 			temp1[j] = i;
 			if j > c {
-				c = j;
+				c = j
 			}
 		}
 	}
@@ -2881,16 +2881,16 @@ func others() {
 	for i = 1; i <= ntokens; i++ {
 		j = tokset[i].value;
 		if j >= 0 && j < 256 {
-			continue;
+			continue
 		}
 		if j >= PRIVATE && j < 256+PRIVATE {
-			continue;
+			continue
 		}
 
 		fmt.Fprintf(ftable, "%4d,%4d,", j, i);
 		c++;
 		if c%5 == 0 {
-			putrune(ftable, '\n');
+			putrune(ftable, '\n')
 		}
 	}
 	fmt.Fprintf(ftable, "%4d\n };\n", 0);
@@ -2910,7 +2910,7 @@ func arout(s string, v []int, n int) {
 	fmt.Fprintf(ftable, "var\t%v\t= []int {\n", s);
 	for i := 0; i < n; i++ {
 		if i%10 == 0 {
-			putrune(ftable, '\n');
+			putrune(ftable, '\n')
 		}
 		fmt.Fprintf(ftable, "%4d", v[i]);
 		putrune(ftable, ',');
@@ -2936,13 +2936,13 @@ func summary() {
 	if zzsrconf != 0 || zzrrconf != 0 {
 		fmt.Printf("\nconflicts: ");
 		if zzsrconf != 0 {
-			fmt.Printf("%v shift/reduce", zzsrconf);
+			fmt.Printf("%v shift/reduce", zzsrconf)
 		}
 		if zzsrconf != 0 && zzrrconf != 0 {
-			fmt.Printf(", ");
+			fmt.Printf(", ")
 		}
 		if zzrrconf != 0 {
-			fmt.Printf("%v reduce/reduce", zzrrconf);
+			fmt.Printf("%v reduce/reduce", zzrrconf)
 		}
 		fmt.Printf("\n");
 	}
@@ -2953,12 +2953,12 @@ func summary() {
 //
 func osummary() {
 	if foutput == nil {
-		return;
+		return
 	}
 	i := 0;
 	for p := maxa; p >= 0; p-- {
 		if amem[p] == 0 {
-			i++;
+			i++
 		}
 	}
 
@@ -3005,7 +3005,7 @@ func setunion(a, b []int) int {
 		y := x|b[i];
 		a[i] = y;
 		if y != x {
-			sub = 1;
+			sub = 1
 		}
 	}
 	return sub;
@@ -3019,7 +3019,7 @@ func prlook(p Lkset) {
 	fmt.Fprintf(foutput, " { ");
 	for j := 0; j <= ntokens; j++ {
 		if bitset(p, j) != 0 {
-			fmt.Fprintf(foutput, "%v ", symnam(j));
+			fmt.Fprintf(foutput, "%v ", symnam(j))
 		}
 	}
 	fmt.Fprintf(foutput, "}");
@@ -3033,7 +3033,7 @@ var peekrune int
 func isdigit(c int) bool	{ return c >= '0' && c <= '9' }
 
 func isword(c int) bool {
-	return c >= 0xa0 || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
+	return c >= 0xa0 || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')
 }
 
 func mktemp(t string) string	{ return t }
@@ -3045,11 +3045,11 @@ func mktemp(t string) string	{ return t }
 func aryeq(a []int, b []int) int {
 	n := len(a);
 	if len(b) != n {
-		return 0;
+		return 0
 	}
 	for ll := 0; ll < n; ll++ {
 		if a[ll] != b[ll] {
-			return 0;
+			return 0
 		}
 	}
 	return 1;
@@ -3058,7 +3058,7 @@ func aryeq(a []int, b []int) int {
 func putrune(f *bufio.Writer, c int) {
 	s := string(c);
 	for i := 0; i < len(s); i++ {
-		f.WriteByte(s[i]);
+		f.WriteByte(s[i])
 	}
 }
 
@@ -3067,7 +3067,7 @@ func getrune(f *bufio.Reader) int {
 
 	if peekrune != 0 {
 		if peekrune == EOF {
-			return EOF;
+			return EOF
 		}
 		r = peekrune;
 		peekrune = 0;
@@ -3076,10 +3076,10 @@ func getrune(f *bufio.Reader) int {
 
 	c, n, err := f.ReadRune();
 	if n == 0 {
-		return EOF;
+		return EOF
 	}
 	if err != nil {
-		error("read error: %v", err);
+		error("read error: %v", err)
 	}
 	//fmt.Printf("rune = %v n=%v\n", string(c), n);
 	return c;
@@ -3087,10 +3087,10 @@ func getrune(f *bufio.Reader) int {
 
 func ungetrune(f *bufio.Reader, c int) {
 	if f != finput {
-		panic("ungetc - not finput");
+		panic("ungetc - not finput")
 	}
 	if peekrune != 0 {
-		panic("ungetc - 2nd unget");
+		panic("ungetc - 2nd unget")
 	}
 	peekrune = c;
 }
@@ -3103,7 +3103,7 @@ func write(f *bufio.Writer, b []byte, n int) int {
 func open(s string) *bufio.Reader {
 	fi, err := os.Open(s, os.O_RDONLY, 0);
 	if err != nil {
-		error("error opening %v: %v", s, err);
+		error("error opening %v: %v", s, err)
 	}
 	//fmt.Printf("open %v\n", s);
 	return bufio.NewReader(fi);
@@ -3112,7 +3112,7 @@ func open(s string) *bufio.Reader {
 func create(s string, m int) *bufio.Writer {
 	fo, err := os.Open(s, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, m);
 	if err != nil {
-		error("error opening %v: %v", s, err);
+		error("error opening %v: %v", s, err)
 	}
 	//fmt.Printf("create %v mode %v\n", s, m);
 	return bufio.NewWriter(fo);
diff --git a/src/cmd/hgpatch/main.go b/src/cmd/hgpatch/main.go
index a46f9ab75f..53dbfa1f5b 100644
--- a/src/cmd/hgpatch/main.go
+++ b/src/cmd/hgpatch/main.go
@@ -35,11 +35,11 @@ func main() {
 	var err os.Error;
 	switch len(args) {
 	case 0:
-		data, err = io.ReadAll(os.Stdin);
+		data, err = io.ReadAll(os.Stdin)
 	case 1:
-		data, err = io.ReadFile(args[0]);
+		data, err = io.ReadFile(args[0])
 	default:
-		usage();
+		usage()
 	}
 	chk(err);
 
@@ -63,25 +63,25 @@ func main() {
 	chk(err);
 	dirty := make(map[string]int);
 	for _, f := range dirtylist {
-		dirty[f] = 1;
+		dirty[f] = 1
 	}
 	conflict := make(map[string]int);
 	for _, f := range pset.File {
 		if f.Verb == patch.Delete || f.Verb == patch.Rename {
 			if _, ok := dirty[f.Src]; ok {
-				conflict[f.Src] = 1;
+				conflict[f.Src] = 1
 			}
 		}
 		if f.Verb != patch.Delete {
 			if _, ok := dirty[f.Dst]; ok {
-				conflict[f.Dst] = 1;
+				conflict[f.Dst] = 1
 			}
 		}
 	}
 	if len(conflict) > 0 {
 		fmt.Fprintf(os.Stderr, "cannot apply patch to locally modified files:\n");
 		for name := range conflict {
-			fmt.Fprintf(os.Stderr, "\t%s\n", name);
+			fmt.Fprintf(os.Stderr, "\t%s\n", name)
 		}
 		os.Exit(2);
 	}
@@ -136,7 +136,7 @@ func main() {
 	for i := range op {
 		o := &op[i];
 		if o.Verb == patch.Delete {
-			continue;
+			continue
 		}
 		if o.Verb == patch.Add {
 			makeParent(o.Dst);
@@ -145,9 +145,9 @@ func main() {
 		if o.Data != nil {
 			chk(io.WriteFile(o.Dst, o.Data, 0644));
 			if o.Verb == patch.Add {
-				undoRm(o.Dst);
+				undoRm(o.Dst)
 			} else {
-				undoRevert(o.Dst);
+				undoRevert(o.Dst)
 			}
 			changed[o.Dst] = 1;
 		}
@@ -178,7 +178,7 @@ func main() {
 	}
 	sort.SortStrings(list);
 	for _, f := range list {
-		fmt.Printf("%s\n", f);
+		fmt.Printf("%s\n", f)
 	}
 }
 
@@ -195,25 +195,25 @@ func mkdirAll(path string, perm int) os.Error {
 	dir, err := os.Lstat(path);
 	if err == nil {
 		if dir.IsDirectory() {
-			return nil;
+			return nil
 		}
 		return &os.PathError{"mkdir", path, os.ENOTDIR};
 	}
 
 	i := len(path);
 	for i > 0 && path[i-1] == '/' {	// Skip trailing slashes.
-		i--;
+		i--
 	}
 
 	j := i;
 	for j > 0 && path[j-1] != '/' {	// Scan backward over element.
-		j--;
+		j--
 	}
 
 	if j > 0 {
 		err = mkdirAll(path[0 : j-1], perm);
 		if err != nil {
-			return err;
+			return err
 		}
 	}
 
@@ -223,7 +223,7 @@ func mkdirAll(path string, perm int) os.Error {
 		// double-checking that directory doesn't exist.
 		dir, err1 := os.Lstat(path);
 		if err1 == nil && dir.IsDirectory() {
-			return nil;
+			return nil
 		}
 		return err;
 	}
@@ -253,7 +253,7 @@ func undoRm(name string)	{ undoLog.Push(undo(func() os.Error { return os.Remove(
 func runUndo() {
 	for i := undoLog.Len() - 1; i >= 0; i-- {
 		if err := undoLog.At(i).(undo)(); err != nil {
-			fmt.Fprintf(os.Stderr, "%s\n", err);
+			fmt.Fprintf(os.Stderr, "%s\n", err)
 		}
 	}
 }
@@ -263,7 +263,7 @@ func runUndo() {
 func hgRoot() (string, os.Error) {
 	out, err := run([]string{"hg", "root"}, nil);
 	if err != nil {
-		return "", err;
+		return "", err
 	}
 	return strings.TrimSpace(out), nil;
 }
@@ -280,7 +280,7 @@ func hgIncoming() bool {
 func hgModified() ([]string, os.Error) {
 	out, err := run([]string{"hg", "status", "-n"}, nil);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	return strings.Split(strings.TrimSpace(out), "\n", 0), nil;
 }
@@ -320,7 +320,7 @@ func hgRename(dst, src string) os.Error {
 func copy(a []string) []string {
 	b := make([]string, len(a));
 	for i, s := range a {
-		b[i] = s;
+		b[i] = s
 	}
 	return b;
 }
@@ -338,7 +338,7 @@ func run(argv []string, input []byte) (out string, err os.Error) {
 	if !ok {
 		prog, err = exec.LookPath(argv[0]);
 		if err != nil {
-			goto Error;
+			goto Error
 		}
 		lookPathCache[argv[0]] = prog;
 	}
@@ -347,12 +347,12 @@ func run(argv []string, input []byte) (out string, err os.Error) {
 	if len(input) == 0 {
 		cmd, err = exec.Run(prog, argv, os.Environ(), exec.DevNull, exec.Pipe, exec.MergeWithStdout);
 		if err != nil {
-			goto Error;
+			goto Error
 		}
 	} else {
 		cmd, err = exec.Run(prog, argv, os.Environ(), exec.Pipe, exec.Pipe, exec.MergeWithStdout);
 		if err != nil {
-			goto Error;
+			goto Error
 		}
 		go func() {
 			cmd.Stdin.Write(input);
@@ -369,7 +369,7 @@ func run(argv []string, input []byte) (out string, err os.Error) {
 	}
 	w, err := cmd.Wait(0);
 	if err != nil {
-		goto Error;
+		goto Error
 	}
 	if !w.Exited() || w.ExitStatus() != 0 {
 		err = w;
diff --git a/src/pkg/archive/tar/reader.go b/src/pkg/archive/tar/reader.go
index 8cb40304d7..a10b913283 100644
--- a/src/pkg/archive/tar/reader.go
+++ b/src/pkg/archive/tar/reader.go
@@ -50,10 +50,10 @@ func NewReader(r io.Reader) *Reader	{ return &Reader{r: r} }
 func (tr *Reader) Next() (*Header, os.Error) {
 	var hdr *Header;
 	if tr.err == nil {
-		tr.skipUnread();
+		tr.skipUnread()
 	}
 	if tr.err == nil {
-		hdr = tr.readHeader();
+		hdr = tr.readHeader()
 	}
 	return hdr, tr.err;
 }
@@ -63,7 +63,7 @@ func (tr *Reader) Next() (*Header, os.Error) {
 func cString(b []byte) string {
 	n := 0;
 	for n < len(b) && b[n] != 0 {
-		n++;
+		n++
 	}
 	return string(b[0:n]);
 }
@@ -71,15 +71,15 @@ func cString(b []byte) string {
 func (tr *Reader) octal(b []byte) int64 {
 	// Removing leading spaces.
 	for len(b) > 0 && b[0] == ' ' {
-		b = b[1:len(b)];
+		b = b[1:len(b)]
 	}
 	// Removing trailing NULs and spaces.
 	for len(b) > 0 && (b[len(b)-1] == ' ' || b[len(b)-1] == '\x00') {
-		b = b[0 : len(b)-1];
+		b = b[0 : len(b)-1]
 	}
 	x, err := strconv.Btoui64(cString(b), 8);
 	if err != nil {
-		tr.err = err;
+		tr.err = err
 	}
 	return int64(x);
 }
@@ -87,7 +87,7 @@ func (tr *Reader) octal(b []byte) int64 {
 type ignoreWriter struct{}
 
 func (ignoreWriter) Write(b []byte) (n int, err os.Error) {
-	return len(b), nil;
+	return len(b), nil
 }
 
 // Skip any unread bytes in the existing file entry, as well as any alignment padding.
@@ -95,16 +95,16 @@ func (tr *Reader) skipUnread() {
 	nr := tr.nb + tr.pad;	// number of bytes to skip
 
 	if sr, ok := tr.r.(io.Seeker); ok {
-		_, tr.err = sr.Seek(nr, 1);
+		_, tr.err = sr.Seek(nr, 1)
 	} else {
-		_, tr.err = io.Copyn(ignoreWriter{}, tr.r, nr);
+		_, tr.err = io.Copyn(ignoreWriter{}, tr.r, nr)
 	}
 	tr.nb, tr.pad = 0, 0;
 }
 
 func (tr *Reader) verifyChecksum(header []byte) bool {
 	if tr.err != nil {
-		return false;
+		return false
 	}
 
 	given := tr.octal(header[148:156]);
@@ -115,16 +115,16 @@ func (tr *Reader) verifyChecksum(header []byte) bool {
 func (tr *Reader) readHeader() *Header {
 	header := make([]byte, blockSize);
 	if _, tr.err = io.ReadFull(tr.r, header); tr.err != nil {
-		return nil;
+		return nil
 	}
 
 	// Two blocks of zero bytes marks the end of the archive.
 	if bytes.Equal(header, zeroBlock[0 : blockSize]) {
 		if _, tr.err = io.ReadFull(tr.r, header); tr.err != nil {
-			return nil;
+			return nil
 		}
 		if !bytes.Equal(header, zeroBlock[0 : blockSize]) {
-			tr.err = HeaderError;
+			tr.err = HeaderError
 		}
 		return nil;
 	}
@@ -156,12 +156,12 @@ func (tr *Reader) readHeader() *Header {
 	switch magic {
 	case "ustar\x0000":	// POSIX tar (1003.1-1988)
 		if string(header[508:512]) == "tar\x00" {
-			format = "star";
+			format = "star"
 		} else {
-			format = "posix";
+			format = "posix"
 		}
 	case "ustar  \x00":	// old GNU tar
-		format = "gnu";
+		format = "gnu"
 	}
 
 	switch format {
@@ -177,14 +177,14 @@ func (tr *Reader) readHeader() *Header {
 		var prefix string;
 		switch format {
 		case "posix", "gnu":
-			prefix = cString(s.next(155));
+			prefix = cString(s.next(155))
 		case "star":
 			prefix = cString(s.next(131));
 			hdr.Atime = tr.octal(s.next(12));
 			hdr.Ctime = tr.octal(s.next(12));
 		}
 		if len(prefix) > 0 {
-			hdr.Name = prefix + "/" + hdr.Name;
+			hdr.Name = prefix + "/" + hdr.Name
 		}
 	}
 
@@ -206,7 +206,7 @@ func (tr *Reader) readHeader() *Header {
 // until Next is called to advance to the next entry.
 func (tr *Reader) Read(b []uint8) (n int, err os.Error) {
 	if int64(len(b)) > tr.nb {
-		b = b[0 : tr.nb];
+		b = b[0 : tr.nb]
 	}
 	n, err = tr.r.Read(b);
 	tr.nb -= int64(n);
diff --git a/src/pkg/archive/tar/reader_test.go b/src/pkg/archive/tar/reader_test.go
index 0cefc08693..0e6f40082b 100644
--- a/src/pkg/archive/tar/reader_test.go
+++ b/src/pkg/archive/tar/reader_test.go
@@ -120,12 +120,12 @@ testLoop:
 			}
 			if !reflect.DeepEqual(hdr, header) {
 				t.Errorf("test %d, entry %d: Incorrect header:\nhave %+v\nwant %+v",
-					i, j, *hdr, *header);
+					i, j, *hdr, *header)
 			}
 		}
 		hdr, err := tr.Next();
 		if hdr != nil || err != nil {
-			t.Errorf("test %d: Unexpected entry or error: hdr=%v err=%v", i, err);
+			t.Errorf("test %d: Unexpected entry or error: hdr=%v err=%v", i, err)
 		}
 		f.Close();
 	}
@@ -134,7 +134,7 @@ testLoop:
 func TestPartialRead(t *testing.T) {
 	f, err := os.Open("testdata/gnu.tar", os.O_RDONLY, 0444);
 	if err != nil {
-		t.Fatalf("Unexpected error: %v", err);
+		t.Fatalf("Unexpected error: %v", err)
 	}
 	defer f.Close();
 
@@ -143,26 +143,26 @@ func TestPartialRead(t *testing.T) {
 	// Read the first four bytes; Next() should skip the last byte.
 	hdr, err := tr.Next();
 	if err != nil || hdr == nil {
-		t.Fatalf("Didn't get first file: %v", err);
+		t.Fatalf("Didn't get first file: %v", err)
 	}
 	buf := make([]byte, 4);
 	if _, err := io.ReadFull(tr, buf); err != nil {
-		t.Fatalf("Unexpected error: %v", err);
+		t.Fatalf("Unexpected error: %v", err)
 	}
 	if expected := strings.Bytes("Kilt"); !bytes.Equal(buf, expected) {
-		t.Errorf("Contents = %v, want %v", buf, expected);
+		t.Errorf("Contents = %v, want %v", buf, expected)
 	}
 
 	// Second file
 	hdr, err = tr.Next();
 	if err != nil || hdr == nil {
-		t.Fatalf("Didn't get second file: %v", err);
+		t.Fatalf("Didn't get second file: %v", err)
 	}
 	buf = make([]byte, 6);
 	if _, err := io.ReadFull(tr, buf); err != nil {
-		t.Fatalf("Unexpected error: %v", err);
+		t.Fatalf("Unexpected error: %v", err)
 	}
 	if expected := strings.Bytes("Google"); !bytes.Equal(buf, expected) {
-		t.Errorf("Contents = %v, want %v", buf, expected);
+		t.Errorf("Contents = %v, want %v", buf, expected)
 	}
 }
diff --git a/src/pkg/archive/tar/writer.go b/src/pkg/archive/tar/writer.go
index a3c03cef14..16443fcc6b 100644
--- a/src/pkg/archive/tar/writer.go
+++ b/src/pkg/archive/tar/writer.go
@@ -53,7 +53,7 @@ func (tw *Writer) Flush() os.Error {
 	for n > 0 && tw.err == nil {
 		nr := n;
 		if nr > blockSize {
-			nr = blockSize;
+			nr = blockSize
 		}
 		var nw int;
 		nw, tw.err = tw.w.Write(zeroBlock[0:nr]);
@@ -68,15 +68,15 @@ func (tw *Writer) Flush() os.Error {
 func (tw *Writer) cString(b []byte, s string) {
 	if len(s) > len(b) {
 		if tw.err == nil {
-			tw.err = ErrFieldTooLong;
+			tw.err = ErrFieldTooLong
 		}
 		return;
 	}
 	for i, ch := range strings.Bytes(s) {
-		b[i] = ch;
+		b[i] = ch
 	}
 	if len(s) < len(b) {
-		b[len(s)] = 0;
+		b[len(s)] = 0
 	}
 }
 
@@ -85,7 +85,7 @@ func (tw *Writer) octal(b []byte, x int64) {
 	s := strconv.Itob64(x, 8);
 	// leading zeros, but leave room for a NUL.
 	for len(s)+1 < len(b) {
-		s = "0"+s;
+		s = "0"+s
 	}
 	tw.cString(b, s);
 }
@@ -111,10 +111,10 @@ func (tw *Writer) numeric(b []byte, x int64) {
 // WriteHeader calls Flush if it is not the first header.
 func (tw *Writer) WriteHeader(hdr *Header) os.Error {
 	if tw.err == nil {
-		tw.Flush();
+		tw.Flush()
 	}
 	if tw.err != nil {
-		return tw.err;
+		return tw.err
 	}
 
 	tw.nb = int64(hdr.Size);
@@ -142,7 +142,7 @@ func (tw *Writer) WriteHeader(hdr *Header) os.Error {
 
 	// Use the GNU magic instead of POSIX magic if we used any GNU extensions.
 	if tw.usedBinary {
-		bytes.Copy(header[257:265], strings.Bytes("ustar  \x00"));
+		bytes.Copy(header[257:265], strings.Bytes("ustar  \x00"))
 	}
 
 	// The chksum field is terminated by a NUL and a space.
@@ -153,7 +153,7 @@ func (tw *Writer) WriteHeader(hdr *Header) os.Error {
 
 	if tw.err != nil {
 		// problem with header; probably integer too big for a field.
-		return tw.err;
+		return tw.err
 	}
 
 	_, tw.err = tw.w.Write(header);
@@ -173,7 +173,7 @@ func (tw *Writer) Write(b []uint8) (n int, err os.Error) {
 	n, err = tw.w.Write(b);
 	tw.nb -= int64(n);
 	if err == nil && overwrite {
-		err = ErrWriteTooLong;
+		err = ErrWriteTooLong
 	}
 	tw.err = err;
 	return;
@@ -181,7 +181,7 @@ func (tw *Writer) Write(b []uint8) (n int, err os.Error) {
 
 func (tw *Writer) Close() os.Error {
 	if tw.err != nil || tw.closed {
-		return tw.err;
+		return tw.err
 	}
 	tw.Flush();
 	tw.closed = true;
@@ -190,7 +190,7 @@ func (tw *Writer) Close() os.Error {
 	for i := 0; i < 2; i++ {
 		_, tw.err = tw.w.Write(zeroBlock);
 		if tw.err != nil {
-			break;
+			break
 		}
 	}
 	return tw.err;
diff --git a/src/pkg/archive/tar/writer_test.go b/src/pkg/archive/tar/writer_test.go
index 94251f9a5e..5edeaba078 100644
--- a/src/pkg/archive/tar/writer_test.go
+++ b/src/pkg/archive/tar/writer_test.go
@@ -87,9 +87,9 @@ func bytestr(offset int, b []byte) string {
 	for _, ch := range b {
 		switch {
 		case '0' <= ch && ch <= '9', 'A' <= ch && ch <= 'Z', 'a' <= ch && ch <= 'z':
-			s += fmt.Sprintf("  %c", ch);
+			s += fmt.Sprintf("  %c", ch)
 		default:
-			s += fmt.Sprintf(" %02x", ch);
+			s += fmt.Sprintf(" %02x", ch)
 		}
 	}
 	return s;
@@ -102,15 +102,15 @@ func bytediff(a []byte, b []byte) string {
 	for offset := 0; len(a)+len(b) > 0; offset += rowLen {
 		na, nb := rowLen, rowLen;
 		if na > len(a) {
-			na = len(a);
+			na = len(a)
 		}
 		if nb > len(b) {
-			nb = len(b);
+			nb = len(b)
 		}
 		sa := bytestr(offset, a[0:na]);
 		sb := bytestr(offset, b[0:nb]);
 		if sa != sb {
-			s += fmt.Sprintf("-%v\n+%v\n", sa, sb);
+			s += fmt.Sprintf("-%v\n+%v\n", sa, sb)
 		}
 		a = a[na:len(a)];
 		b = b[nb:len(b)];
@@ -147,7 +147,7 @@ testLoop:
 		actual := buf.Bytes();
 		if !bytes.Equal(expected, actual) {
 			t.Errorf("test %d: Incorrect result: (-=expected, +=actual)\n%v",
-				i, bytediff(expected, actual));
+				i, bytediff(expected, actual))
 		}
 	}
 }
diff --git a/src/pkg/asn1/asn1.go b/src/pkg/asn1/asn1.go
index fac5bba556..b787bd8249 100644
--- a/src/pkg/asn1/asn1.go
+++ b/src/pkg/asn1/asn1.go
@@ -82,10 +82,10 @@ func parseInt64(bytes []byte) (ret int64, err os.Error) {
 func parseInt(bytes []byte) (int, os.Error) {
 	ret64, err := parseInt64(bytes);
 	if err != nil {
-		return 0, err;
+		return 0, err
 	}
 	if ret64 != int64(int(ret64)) {
-		return 0, StructuralError{"integer too large"};
+		return 0, StructuralError{"integer too large"}
 	}
 	return int(ret64), nil;
 }
@@ -104,7 +104,7 @@ type BitString struct {
 // returns false.
 func (b BitString) At(i int) int {
 	if i < 0 || i >= b.BitLength {
-		return 0;
+		return 0
 	}
 	x := i/8;
 	y := 7-uint(i%8);
@@ -155,7 +155,7 @@ func parseObjectIdentifier(bytes []byte) (s []int, err os.Error) {
 		var v int;
 		v, offset, err = parseBase128Int(bytes, offset);
 		if err != nil {
-			return;
+			return
 		}
 		s[i] = v;
 	}
@@ -177,7 +177,7 @@ func parseBase128Int(bytes []byte, initOffset int) (ret, offset int, err os.Erro
 		ret |= int(b&0x7f);
 		offset++;
 		if b&0x80 == 0 {
-			return;
+			return
 		}
 	}
 	err = SyntaxError{"truncated base 128 integer"};
@@ -192,12 +192,12 @@ func isDigit(b byte) bool	{ return '0' <= b && b <= '9' }
 func twoDigits(bytes []byte, max int) (int, bool) {
 	for i := 0; i < 2; i++ {
 		if !isDigit(bytes[i]) {
-			return 0, false;
+			return 0, false
 		}
 	}
 	value := (int(bytes[0])-'0')*10 + int(bytes[1]-'0');
 	if value > max {
-		return 0, false;
+		return 0, false
 	}
 	return value, true;
 }
@@ -225,54 +225,54 @@ func parseUTCTime(bytes []byte) (ret time.Time, err os.Error) {
 	// RFC 5280, section 5.1.2.4 says that years 2050 or later use another date
 	// scheme.
 	if year > 50 {
-		ret.Year = 1900+int64(year);
+		ret.Year = 1900+int64(year)
 	} else {
-		ret.Year = 2000+int64(year);
+		ret.Year = 2000+int64(year)
 	}
 	ret.Month, ok2 = twoDigits(bytes[2:4], 12);
 	ret.Day, ok3 = twoDigits(bytes[4:6], 31);
 	ret.Hour, ok4 = twoDigits(bytes[6:8], 23);
 	ret.Minute, ok5 = twoDigits(bytes[8:10], 59);
 	if !ok1 || !ok2 || !ok3 || !ok4 || !ok5 {
-		goto Error;
+		goto Error
 	}
 	bytes = bytes[10:len(bytes)];
 	switch bytes[0] {
 	case '0', '1', '2', '3', '4', '5', '6':
 		if len(bytes) < 3 {
-			goto Error;
+			goto Error
 		}
 		ret.Second, ok1 = twoDigits(bytes[0:2], 60);	// 60, not 59, because of leap seconds.
 		if !ok1 {
-			goto Error;
+			goto Error
 		}
 		bytes = bytes[2:len(bytes)];
 	}
 	if len(bytes) == 0 {
-		goto Error;
+		goto Error
 	}
 	switch bytes[0] {
 	case 'Z':
 		if len(bytes) != 1 {
-			goto Error;
+			goto Error
 		}
 		return;
 	case '-', '+':
 		if len(bytes) != 5 {
-			goto Error;
+			goto Error
 		}
 		hours, ok1 := twoDigits(bytes[1:3], 12);
 		minutes, ok2 := twoDigits(bytes[3:5], 59);
 		if !ok1 || !ok2 {
-			goto Error;
+			goto Error
 		}
 		sign := 1;
 		if bytes[0] == '-' {
-			sign = -1;
+			sign = -1
 		}
 		ret.ZoneOffset = sign*(60*(hours*60 + minutes));
 	default:
-		goto Error;
+		goto Error
 	}
 	return;
 
@@ -306,7 +306,7 @@ func isPrintable(b byte) bool {
 		b == ' ' ||
 		b == ':' ||
 		b == '=' ||
-		b == '?';
+		b == '?'
 }
 
 // IA5String
@@ -383,7 +383,7 @@ func parseTagAndLength(bytes []byte, initOffset int) (ret tagAndLength, offset i
 	if ret.tag == 0x1f {
 		ret.tag, offset, err = parseBase128Int(bytes, offset);
 		if err != nil {
-			return;
+			return
 		}
 	}
 	if offset >= len(bytes) {
@@ -394,7 +394,7 @@ func parseTagAndLength(bytes []byte, initOffset int) (ret tagAndLength, offset i
 	offset++;
 	if b&0x80 == 0 {
 		// The length is encoded in the bottom 7 bits.
-		ret.length = int(b&0x7f);
+		ret.length = int(b&0x7f)
 	} else {
 		// Bottom 7 bits give the number of length bytes to follow.
 		numBytes := int(b&0x7f);
@@ -423,7 +423,7 @@ func parseTagAndLength(bytes []byte, initOffset int) (ret tagAndLength, offset i
 	// We magically map SET and SET OF to SEQUENCE and SEQUENCE OF
 	// because we treat everything as ordered.
 	if ret.tag == tagSet {
-		ret.tag = tagSequence;
+		ret.tag = tagSequence
 	}
 	return;
 }
@@ -464,7 +464,7 @@ func parseFieldParameters(str string) (ret fieldParameters) {
 	for _, part := range strings.Split(str, ",", 0) {
 		switch {
 		case part == "optional":
-			ret.optional = true;
+			ret.optional = true
 		case part == "explicit":
 			ret.explicit = true;
 			if ret.tag == nil {
@@ -493,28 +493,28 @@ func parseFieldParameters(str string) (ret fieldParameters) {
 func getUniversalType(t reflect.Type) (tagNumber int, isCompound, ok bool) {
 	switch t {
 	case objectIdentifierType:
-		return tagOID, false, true;
+		return tagOID, false, true
 	case bitStringType:
-		return tagBitString, false, true;
+		return tagBitString, false, true
 	case timeType:
-		return tagUTCTime, false, true;
+		return tagUTCTime, false, true
 	}
 	switch i := t.(type) {
 	case *reflect.BoolType:
-		return tagBoolean, false, true;
+		return tagBoolean, false, true
 	case *reflect.IntType:
-		return tagInteger, false, true;
+		return tagInteger, false, true
 	case *reflect.Int64Type:
-		return tagInteger, false, true;
+		return tagInteger, false, true
 	case *reflect.StructType:
-		return tagSequence, true, true;
+		return tagSequence, true, true
 	case *reflect.SliceType:
 		if _, ok := t.(*reflect.SliceType).Elem().(*reflect.Uint8Type); ok {
-			return tagOctetString, false, true;
+			return tagOctetString, false, true
 		}
 		return tagSequence, true, true;
 	case *reflect.StringType:
-		return tagPrintableString, false, true;
+		return tagPrintableString, false, true
 	}
 	return 0, false, false;
 }
@@ -536,7 +536,7 @@ func parseSequenceOf(bytes []byte, sliceType *reflect.SliceType, elemType reflec
 		var t tagAndLength;
 		t, offset, err = parseTagAndLength(bytes, offset);
 		if err != nil {
-			return;
+			return
 		}
 		if t.class != classUniversal || t.isCompound != compoundType || t.tag != expectedTag {
 			err = StructuralError{"sequence tag mismatch"};
@@ -555,7 +555,7 @@ func parseSequenceOf(bytes []byte, sliceType *reflect.SliceType, elemType reflec
 	for i := 0; i < numElements; i++ {
 		offset, err = parseField(ret.Elem(i), bytes, offset, params);
 		if err != nil {
-			return;
+			return
 		}
 	}
 	return;
@@ -571,7 +571,7 @@ var (
 // invalidLength returns true iff offset + length > sliceLength, or if the
 // addition would overflow.
 func invalidLength(offset, length, sliceLength int) bool {
-	return offset+length < offset || offset+length > sliceLength;
+	return offset+length < offset || offset+length > sliceLength
 }
 
 // parseField is the main parsing function. Given a byte array and an offset
@@ -584,7 +584,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam
 	// If we have run out of data, it may be that there are optional elements at the end.
 	if offset == len(bytes) {
 		if !setDefaultValue(v, params) {
-			err = SyntaxError{"sequence truncated"};
+			err = SyntaxError{"sequence truncated"}
 		}
 		return;
 	}
@@ -594,7 +594,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam
 		var t tagAndLength;
 		t, offset, err = parseTagAndLength(bytes, offset);
 		if err != nil {
-			return;
+			return
 		}
 		if invalidLength(offset, t.length, len(bytes)) {
 			err = SyntaxError{"data truncated"};
@@ -612,7 +612,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam
 		var t tagAndLength;
 		t, offset, err = parseTagAndLength(bytes, offset);
 		if err != nil {
-			return;
+			return
 		}
 		if invalidLength(offset, t.length, len(bytes)) {
 			err = SyntaxError{"data truncated"};
@@ -623,29 +623,29 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam
 			innerBytes := bytes[offset : offset + t.length];
 			switch t.tag {
 			case tagPrintableString:
-				result, err = parsePrintableString(innerBytes);
+				result, err = parsePrintableString(innerBytes)
 			case tagIA5String:
-				result, err = parseIA5String(innerBytes);
+				result, err = parseIA5String(innerBytes)
 			case tagInteger:
-				result, err = parseInt64(innerBytes);
+				result, err = parseInt64(innerBytes)
 			case tagBitString:
-				result, err = parseBitString(innerBytes);
+				result, err = parseBitString(innerBytes)
 			case tagOID:
-				result, err = parseObjectIdentifier(innerBytes);
+				result, err = parseObjectIdentifier(innerBytes)
 			case tagUTCTime:
-				result, err = parseUTCTime(innerBytes);
+				result, err = parseUTCTime(innerBytes)
 			case tagOctetString:
-				result = innerBytes;
+				result = innerBytes
 			default:
 				// If we don't know how to handle the type, we just leave Value as nil.
 			}
 		}
 		offset += t.length;
 		if err != nil {
-			return;
+			return
 		}
 		if result != nil {
-			ifaceValue.Set(reflect.NewValue(result));
+			ifaceValue.Set(reflect.NewValue(result))
 		}
 		return;
 	}
@@ -657,21 +657,21 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam
 
 	t, offset, err := parseTagAndLength(bytes, offset);
 	if err != nil {
-		return;
+		return
 	}
 	if params.explicit {
 		if t.class == classContextSpecific && t.tag == *params.tag && t.isCompound {
 			t, offset, err = parseTagAndLength(bytes, offset);
 			if err != nil {
-				return;
+				return
 			}
 		} else {
 			// The tags didn't match, it might be an optional element.
 			ok := setDefaultValue(v, params);
 			if ok {
-				offset = initOffset;
+				offset = initOffset
 			} else {
-				err = StructuralError{"explicitly tagged member didn't match"};
+				err = StructuralError{"explicitly tagged member didn't match"}
 			}
 			return;
 		}
@@ -682,7 +682,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam
 	// PrintableString when it sees a string so, if we see an IA5String on
 	// the wire, we change the universal type to match.
 	if universalTag == tagPrintableString && t.tag == tagIA5String {
-		universalTag = tagIA5String;
+		universalTag = tagIA5String
 	}
 
 	expectedClass := classUniversal;
@@ -698,9 +698,9 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam
 		// Tags don't match. Again, it could be an optional element.
 		ok := setDefaultValue(v, params);
 		if ok {
-			offset = initOffset;
+			offset = initOffset
 		} else {
-			err = StructuralError{fmt.Sprintf("tags don't match (%d vs %+v) %+v %s %#v", expectedTag, t, params, fieldType.Name(), bytes[offset:len(bytes)])};
+			err = StructuralError{fmt.Sprintf("tags don't match (%d vs %+v) %+v %s %#v", expectedTag, t, params, fieldType.Name(), bytes[offset:len(bytes)])}
 		}
 		return;
 	}
@@ -717,7 +717,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam
 		sliceValue := v.(*reflect.SliceValue);
 		sliceValue.Set(reflect.MakeSlice(sliceValue.Type().(*reflect.SliceType), len(newSlice), len(newSlice)));
 		if err1 == nil {
-			reflect.ArrayCopy(sliceValue, reflect.NewValue(newSlice).(reflect.ArrayOrSliceValue));
+			reflect.ArrayCopy(sliceValue, reflect.NewValue(newSlice).(reflect.ArrayOrSliceValue))
 		}
 		offset += t.length;
 		err = err1;
@@ -727,7 +727,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam
 		bs, err1 := parseBitString(innerBytes);
 		offset += t.length;
 		if err1 == nil {
-			structValue.Set(reflect.NewValue(bs).(*reflect.StructValue));
+			structValue.Set(reflect.NewValue(bs).(*reflect.StructValue))
 		}
 		err = err1;
 		return;
@@ -736,7 +736,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam
 		time, err1 := parseUTCTime(innerBytes);
 		offset += t.length;
 		if err1 == nil {
-			structValue.Set(reflect.NewValue(time).(*reflect.StructValue));
+			structValue.Set(reflect.NewValue(time).(*reflect.StructValue))
 		}
 		err = err1;
 		return;
@@ -746,7 +746,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam
 		parsedBool, err1 := parseBool(innerBytes);
 		offset += t.length;
 		if err1 == nil {
-			val.Set(parsedBool);
+			val.Set(parsedBool)
 		}
 		err = err1;
 		return;
@@ -754,7 +754,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam
 		parsedInt, err1 := parseInt(innerBytes);
 		offset += t.length;
 		if err1 == nil {
-			val.Set(parsedInt);
+			val.Set(parsedInt)
 		}
 		err = err1;
 		return;
@@ -762,7 +762,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam
 		parsedInt, err1 := parseInt64(innerBytes);
 		offset += t.length;
 		if err1 == nil {
-			val.Set(parsedInt);
+			val.Set(parsedInt)
 		}
 		err = err1;
 		return;
@@ -773,7 +773,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam
 			field := structType.Field(i);
 			innerOffset, err = parseField(val.Field(i), innerBytes, innerOffset, parseFieldParameters(field.Tag));
 			if err != nil {
-				return;
+				return
 			}
 		}
 		offset += t.length;
@@ -791,7 +791,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam
 		newSlice, err1 := parseSequenceOf(innerBytes, sliceType, sliceType.Elem());
 		offset += t.length;
 		if err1 == nil {
-			val.Set(newSlice);
+			val.Set(newSlice)
 		}
 		err = err1;
 		return;
@@ -799,14 +799,14 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam
 		var v string;
 		switch universalTag {
 		case tagPrintableString:
-			v, err = parsePrintableString(innerBytes);
+			v, err = parsePrintableString(innerBytes)
 		case tagIA5String:
-			v, err = parseIA5String(innerBytes);
+			v, err = parseIA5String(innerBytes)
 		default:
-			err = SyntaxError{fmt.Sprintf("internal error: unknown string type %d", universalTag)};
+			err = SyntaxError{fmt.Sprintf("internal error: unknown string type %d", universalTag)}
 		}
 		if err == nil {
-			val.Set(v);
+			val.Set(v)
 		}
 		return;
 	}
@@ -819,17 +819,17 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam
 // wasn't provided or it failed to install it into the Value.
 func setDefaultValue(v reflect.Value, params fieldParameters) (ok bool) {
 	if !params.optional {
-		return;
+		return
 	}
 	ok = true;
 	if params.defaultValue == nil {
-		return;
+		return
 	}
 	switch val := v.(type) {
 	case *reflect.IntValue:
-		val.Set(int(*params.defaultValue));
+		val.Set(int(*params.defaultValue))
 	case *reflect.Int64Value:
-		val.Set(int64(*params.defaultValue));
+		val.Set(int64(*params.defaultValue))
 	}
 	return;
 }
diff --git a/src/pkg/asn1/asn1_test.go b/src/pkg/asn1/asn1_test.go
index f9a7106d94..6d537fb5e3 100644
--- a/src/pkg/asn1/asn1_test.go
+++ b/src/pkg/asn1/asn1_test.go
@@ -35,10 +35,10 @@ func TestParseInt64(t *testing.T) {
 	for i, test := range int64TestData {
 		ret, err := parseInt64(test.in);
 		if (err == nil) != test.ok {
-			t.Errorf("#%d: Incorrect error result (did fail? %v, expected: %v)", i, err == nil, test.ok);
+			t.Errorf("#%d: Incorrect error result (did fail? %v, expected: %v)", i, err == nil, test.ok)
 		}
 		if test.ok && ret != test.out {
-			t.Errorf("#%d: Bad result: %v (expected %v)", i, ret, test.out);
+			t.Errorf("#%d: Bad result: %v (expected %v)", i, ret, test.out)
 		}
 	}
 }
@@ -63,11 +63,11 @@ func TestBitString(t *testing.T) {
 	for i, test := range bitStringTestData {
 		ret, err := parseBitString(test.in);
 		if (err == nil) != test.ok {
-			t.Errorf("#%d: Incorrect error result (did fail? %v, expected: %v)", i, err == nil, test.ok);
+			t.Errorf("#%d: Incorrect error result (did fail? %v, expected: %v)", i, err == nil, test.ok)
 		}
 		if err == nil {
 			if test.bitLength != ret.BitLength || bytes.Compare(ret.Bytes, test.out) != 0 {
-				t.Errorf("#%d: Bad result: %v (expected %v %v)", i, ret, test.out, test.bitLength);
+				t.Errorf("#%d: Bad result: %v (expected %v %v)", i, ret, test.out, test.bitLength)
 			}
 		}
 	}
@@ -76,16 +76,16 @@ func TestBitString(t *testing.T) {
 func TestBitStringAt(t *testing.T) {
 	bs := BitString{[]byte{0x82, 0x40}, 16};
 	if bs.At(0) != 1 {
-		t.Error("#1: Failed");
+		t.Error("#1: Failed")
 	}
 	if bs.At(1) != 0 {
-		t.Error("#2: Failed");
+		t.Error("#2: Failed")
 	}
 	if bs.At(6) != 1 {
-		t.Error("#3: Failed");
+		t.Error("#3: Failed")
 	}
 	if bs.At(9) != 1 {
-		t.Error("#4: Failed");
+		t.Error("#4: Failed")
 	}
 }
 
@@ -107,11 +107,11 @@ func TestObjectIdentifier(t *testing.T) {
 	for i, test := range objectIdentifierTestData {
 		ret, err := parseObjectIdentifier(test.in);
 		if (err == nil) != test.ok {
-			t.Errorf("#%d: Incorrect error result (did fail? %v, expected: %v)", i, err == nil, test.ok);
+			t.Errorf("#%d: Incorrect error result (did fail? %v, expected: %v)", i, err == nil, test.ok)
 		}
 		if err == nil {
 			if !reflect.DeepEqual(test.out, ret) {
-				t.Errorf("#%d: Bad result: %v (expected %v)", i, ret, test.out);
+				t.Errorf("#%d: Bad result: %v (expected %v)", i, ret, test.out)
 			}
 		}
 	}
@@ -142,11 +142,11 @@ func TestTime(t *testing.T) {
 	for i, test := range timeTestData {
 		ret, err := parseUTCTime(strings.Bytes(test.in));
 		if (err == nil) != test.ok {
-			t.Errorf("#%d: Incorrect error result (did fail? %v, expected: %v)", i, err == nil, test.ok);
+			t.Errorf("#%d: Incorrect error result (did fail? %v, expected: %v)", i, err == nil, test.ok)
 		}
 		if err == nil {
 			if !reflect.DeepEqual(test.out, ret) {
-				t.Errorf("#%d: Bad result: %v (expected %v)", i, ret, test.out);
+				t.Errorf("#%d: Bad result: %v (expected %v)", i, ret, test.out)
 			}
 		}
 	}
@@ -177,10 +177,10 @@ func TestParseTagAndLength(t *testing.T) {
 	for i, test := range tagAndLengthData {
 		tagAndLength, _, err := parseTagAndLength(test.in, 0);
 		if (err == nil) != test.ok {
-			t.Errorf("#%d: Incorrect error result (did pass? %v, expected: %v)", i, err == nil, test.ok);
+			t.Errorf("#%d: Incorrect error result (did pass? %v, expected: %v)", i, err == nil, test.ok)
 		}
 		if err == nil && !reflect.DeepEqual(test.out, tagAndLength) {
-			t.Errorf("#%d: Bad result: %v (expected %v)", i, tagAndLength, test.out);
+			t.Errorf("#%d: Bad result: %v (expected %v)", i, tagAndLength, test.out)
 		}
 	}
 }
@@ -213,7 +213,7 @@ func TestParseFieldParameters(t *testing.T) {
 	for i, test := range parseFieldParametersTestData {
 		f := parseFieldParameters(test.in);
 		if !reflect.DeepEqual(f, test.out) {
-			t.Errorf("#%d: Bad result: %v (expected %v)", i, f, test.out);
+			t.Errorf("#%d: Bad result: %v (expected %v)", i, f, test.out)
 		}
 	}
 }
@@ -260,10 +260,10 @@ func TestUnmarshal(t *testing.T) {
 		val := pv.Interface();
 		err := Unmarshal(val, test.in);
 		if err != nil {
-			t.Errorf("Unmarshal failed at index %d %v", i, err);
+			t.Errorf("Unmarshal failed at index %d %v", i, err)
 		}
 		if !reflect.DeepEqual(val, test.out) {
-			t.Errorf("#%d:\nhave %#v\nwant %#v", i, val, test.out);
+			t.Errorf("#%d:\nhave %#v\nwant %#v", i, val, test.out)
 		}
 	}
 }
@@ -310,10 +310,10 @@ func TestCertificate(t *testing.T) {
 	// This is a minimal, self-signed certificate that should parse correctly.
 	var cert Certificate;
 	if err := Unmarshal(&cert, derEncodedSelfSignedCertBytes); err != nil {
-		t.Errorf("Unmarshal failed: %v", err);
+		t.Errorf("Unmarshal failed: %v", err)
 	}
 	if !reflect.DeepEqual(cert, derEncodedSelfSignedCert) {
-		t.Errorf("Bad result:\ngot: %+v\nwant: %+v\n", cert, derEncodedSelfSignedCert);
+		t.Errorf("Bad result:\ngot: %+v\nwant: %+v\n", cert, derEncodedSelfSignedCert)
 	}
 }
 
@@ -323,7 +323,7 @@ func TestCertificateWithNUL(t *testing.T) {
 
 	var cert Certificate;
 	if err := Unmarshal(&cert, derEncodedPaypalNULCertBytes); err == nil {
-		t.Error("Unmarshal succeeded, should not have");
+		t.Error("Unmarshal succeeded, should not have")
 	}
 }
 
diff --git a/src/pkg/big/arith.go b/src/pkg/big/arith.go
index d442e1dda3..dfef4f6e37 100644
--- a/src/pkg/big/arith.go
+++ b/src/pkg/big/arith.go
@@ -33,7 +33,7 @@ func addWW_g(x, y, c Word) (z1, z0 Word) {
 	yc := y+c;
 	z0 = x+yc;
 	if z0 < x || yc < y {
-		z1 = 1;
+		z1 = 1
 	}
 	return;
 }
@@ -44,7 +44,7 @@ func subWW_g(x, y, c Word) (z1, z0 Word) {
 	yc := y+c;
 	z0 = x-yc;
 	if z0 > x || yc < y {
-		z1 = 1;
+		z1 = 1
 	}
 	return;
 }
@@ -57,7 +57,7 @@ func mulWW_g(x, y Word) (z1, z0 Word) {
 	// and return the product as 2 Words.
 
 	if x < y {
-		x, y = y, x;
+		x, y = y, x
 	}
 
 	if x < _B2 {
@@ -100,7 +100,7 @@ func mulWW_g(x, y Word) (z1, z0 Word) {
 	t1a := t1;
 	t1 += x0*y1;
 	if t1 < t1a {
-		c++;
+		c++
 	}
 	t2 := x1*y1 + c*_B2;
 
@@ -114,7 +114,7 @@ func mulWW_g(x, y Word) (z1, z0 Word) {
 	var c3 Word;
 	z1 = t1 + t0>>_W2;
 	if z1 < t1 {
-		c3++;
+		c3++
 	}
 	z1 >>= _W2;
 	z1 += c3*_B2;
@@ -149,7 +149,7 @@ func mulAddWWW_g(x, y, c Word) (z1, z0 Word) {
 	t1a := t1;
 	t1 += x0*y1;
 	if t1 < t1a {	// If the number got smaller then we overflowed.
-		c2++;
+		c2++
 	}
 
 	t2 := x1*y1 + c2*_B2;
@@ -164,7 +164,7 @@ func mulAddWWW_g(x, y, c Word) (z1, z0 Word) {
 	var c3 Word;
 	z1 = t1 + t0>>_W2;
 	if z1 < t1 {
-		c3++;
+		c3++
 	}
 	z1 >>= _W2;
 	z1 += t2 + c3*_B2;
@@ -213,7 +213,7 @@ func divStep(x1, x0, y Word) (q, r Word) {
 // Number of leading zeros in x.
 func leadingZeros(x Word) (n uint) {
 	if x == 0 {
-		return uint(_W);
+		return uint(_W)
 	}
 	for x&(1<<(_W-1)) == 0 {
 		n++;
@@ -259,7 +259,7 @@ func divWW_g(x1, x0, y Word) (q, r Word) {
 	r = x0>>z;
 
 	if q1 != 0 {
-		panic("div out of range");
+		panic("div out of range")
 	}
 
 	return q0, r;
@@ -315,14 +315,14 @@ func init() {
 
 
 func (p *Word) at(i int) *Word {
-	return (*Word)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(i)*_S));
+	return (*Word)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(i)*_S))
 }
 
 
 func addVV_s(z, x, y *Word, n int) (c Word)
 func addVV_g(z, x, y *Word, n int) (c Word) {
 	for i := 0; i < n; i++ {
-		c, *z.at(i) = addWW_g(*x.at(i), *y.at(i), c);
+		c, *z.at(i) = addWW_g(*x.at(i), *y.at(i), c)
 	}
 	return;
 }
@@ -331,7 +331,7 @@ func addVV_g(z, x, y *Word, n int) (c Word) {
 func subVV_s(z, x, y *Word, n int) (c Word)
 func subVV_g(z, x, y *Word, n int) (c Word) {
 	for i := 0; i < n; i++ {
-		c, *z.at(i) = subWW_g(*x.at(i), *y.at(i), c);
+		c, *z.at(i) = subWW_g(*x.at(i), *y.at(i), c)
 	}
 	return;
 }
@@ -341,7 +341,7 @@ func addVW_s(z, x *Word, y Word, n int) (c Word)
 func addVW_g(z, x *Word, y Word, n int) (c Word) {
 	c = y;
 	for i := 0; i < n; i++ {
-		c, *z.at(i) = addWW_g(*x.at(i), c, 0);
+		c, *z.at(i) = addWW_g(*x.at(i), c, 0)
 	}
 	return;
 }
@@ -351,7 +351,7 @@ func subVW_s(z, x *Word, y Word, n int) (c Word)
 func subVW_g(z, x *Word, y Word, n int) (c Word) {
 	c = y;
 	for i := 0; i < n; i++ {
-		c, *z.at(i) = subWW_g(*x.at(i), c, 0);
+		c, *z.at(i) = subWW_g(*x.at(i), c, 0)
 	}
 	return;
 }
@@ -361,7 +361,7 @@ func mulAddVWW_s(z, x *Word, y, r Word, n int) (c Word)
 func mulAddVWW_g(z, x *Word, y, r Word, n int) (c Word) {
 	c = r;
 	for i := 0; i < n; i++ {
-		c, *z.at(i) = mulAddWWW_g(*x.at(i), y, c);
+		c, *z.at(i) = mulAddWWW_g(*x.at(i), y, c)
 	}
 	return;
 }
@@ -382,7 +382,7 @@ func divWVW_s(z *Word, xn Word, x *Word, y Word, n int) (r Word)
 func divWVW_g(z *Word, xn Word, x *Word, y Word, n int) (r Word) {
 	r = xn;
 	for i := n-1; i >= 0; i-- {
-		*z.at(i), r = divWW_g(r, *x.at(i), y);
+		*z.at(i), r = divWW_g(r, *x.at(i), y)
 	}
 	return;
 }
diff --git a/src/pkg/big/arith_test.go b/src/pkg/big/arith_test.go
index 030b81f168..205d51c0b1 100644
--- a/src/pkg/big/arith_test.go
+++ b/src/pkg/big/arith_test.go
@@ -30,7 +30,7 @@ var sumWW = []argWW{
 func testFunWW(t *testing.T, msg string, f funWW, a argWW) {
 	z1, z0 := f(a.x, a.y, a.c);
 	if z1 != a.z1 || z0 != a.z0 {
-		t.Errorf("%s%+v\n\tgot z1:z0 = %#x:%#x; want %#x:%#x", msg, a, z1, z0, a.z1, a.z0);
+		t.Errorf("%s%+v\n\tgot z1:z0 = %#x:%#x; want %#x:%#x", msg, a, z1, z0, a.z1, a.z0)
 	}
 }
 
@@ -54,7 +54,7 @@ func TestFunWW(t *testing.T) {
 
 func addr(x []Word) *Word {
 	if len(x) == 0 {
-		return nil;
+		return nil
 	}
 	return &x[0];
 }
@@ -90,7 +90,7 @@ func testFunVV(t *testing.T, msg string, f funVV, a argVV) {
 		}
 	}
 	if c != a.c {
-		t.Errorf("%s%+v\n\tgot c = %#x; want %#x", msg, a, c, a.c);
+		t.Errorf("%s%+v\n\tgot c = %#x; want %#x", msg, a, c, a.c)
 	}
 }
 
@@ -159,7 +159,7 @@ func testFunVW(t *testing.T, msg string, f funVW, a argVW) {
 		}
 	}
 	if c != a.c {
-		t.Errorf("%s%+v\n\tgot c = %#x; want %#x", msg, a, c, a.c);
+		t.Errorf("%s%+v\n\tgot c = %#x; want %#x", msg, a, c, a.c)
 	}
 }
 
@@ -222,7 +222,7 @@ func testFunVWW(t *testing.T, msg string, f funVWW, a argVWW) {
 		}
 	}
 	if c != a.c {
-		t.Errorf("%s%+v\n\tgot c = %#x; want %#x", msg, a, c, a.c);
+		t.Errorf("%s%+v\n\tgot c = %#x; want %#x", msg, a, c, a.c)
 	}
 }
 
@@ -250,7 +250,7 @@ func testFunWVW(t *testing.T, msg string, f funWVW, a argWVW) {
 		}
 	}
 	if r != a.r {
-		t.Errorf("%s%+v\n\tgot r = %#x; want %#x", msg, a, r, a.r);
+		t.Errorf("%s%+v\n\tgot r = %#x; want %#x", msg, a, r, a.r)
 	}
 }
 
@@ -286,7 +286,7 @@ func TestMulWW(t *testing.T) {
 	for i, test := range mulWWTests {
 		q, r := mulWW_g(test.x, test.y);
 		if q != test.q || r != test.r {
-			t.Errorf("#%d got (%x, %x) want (%x, %x)", i, q, r, test.q, test.r);
+			t.Errorf("#%d got (%x, %x) want (%x, %x)", i, q, r, test.q, test.r)
 		}
 	}
 }
@@ -311,7 +311,7 @@ func TestMulAddWWW(t *testing.T) {
 	for i, test := range mulAddWWWTests {
 		q, r := mulAddWWW_g(test.x, test.y, test.c);
 		if q != test.q || r != test.r {
-			t.Errorf("#%d got (%x, %x) want (%x, %x)", i, q, r, test.q, test.r);
+			t.Errorf("#%d got (%x, %x) want (%x, %x)", i, q, r, test.q, test.r)
 		}
 	}
 }
diff --git a/src/pkg/big/int.go b/src/pkg/big/int.go
index 235becfeb3..a92875bbdd 100644
--- a/src/pkg/big/int.go
+++ b/src/pkg/big/int.go
@@ -57,7 +57,7 @@ func (z *Int) Add(x, y *Int) *Int {
 		}
 	}
 	if len(z.abs) == 0 {
-		z.neg = false;	// 0 has no sign
+		z.neg = false	// 0 has no sign
 	}
 	return z;
 }
@@ -82,7 +82,7 @@ func (z *Int) Sub(x, y *Int) *Int {
 		}
 	}
 	if len(z.abs) == 0 {
-		z.neg = false;	// 0 has no sign
+		z.neg = false	// 0 has no sign
 	}
 	return z;
 }
@@ -120,7 +120,7 @@ func (z *Int) Mod(x, y *Int) (r *Int) {
 
 func div(q, r, x, y *Int) {
 	if len(y.abs) == 0 {
-		panic("Divide by zero undefined");
+		panic("Divide by zero undefined")
 	}
 
 	if cmpNN(x.abs, y.abs) < 0 {
@@ -131,12 +131,12 @@ func div(q, r, x, y *Int) {
 		src := x.abs;
 		dst := x.abs;
 		if r == x {
-			dst = nil;
+			dst = nil
 		}
 
 		r.abs = makeN(dst, len(src), false);
 		for i, v := range src {
-			r.abs[i] = v;
+			r.abs[i] = v
 		}
 		return;
 	}
@@ -185,12 +185,12 @@ func CmpInt(x, y *Int) (r int) {
 	case x.neg == y.neg:
 		r = cmpNN(x.abs, y.abs);
 		if x.neg {
-			r = -r;
+			r = -r
 		}
 	case x.neg:
-		r = -1;
+		r = -1
 	default:
-		r = 1;
+		r = 1
 	}
 	return;
 }
@@ -199,7 +199,7 @@ func CmpInt(x, y *Int) (r int) {
 func (z *Int) String() string {
 	s := "";
 	if z.neg {
-		s = "-";
+		s = "-"
 	}
 	return s + stringN(z.abs, 10);
 }
@@ -212,23 +212,23 @@ func (z *Int) SetString(s string, base int) (*Int, bool) {
 	var scanned int;
 
 	if base == 1 || base > 16 {
-		goto Error;
+		goto Error
 	}
 
 	if len(s) == 0 {
-		goto Error;
+		goto Error
 	}
 
 	if s[0] == '-' {
 		z.neg = true;
 		s = s[1:len(s)];
 	} else {
-		z.neg = false;
+		z.neg = false
 	}
 
 	z.abs, _, scanned = scanN(z.abs, s, base);
 	if scanned != len(s) {
-		goto Error;
+		goto Error
 	}
 
 	return z, true;
@@ -293,7 +293,7 @@ func (z *Int) Bytes() []byte {
 
 	i := 0;
 	for i < len(b) && b[i] == 0 {
-		i++;
+		i++
 	}
 
 	return b[i:len(b)];
@@ -304,7 +304,7 @@ func (z *Int) Bytes() []byte {
 // considered to have a length of one.
 func (z *Int) Len() int {
 	if len(z.abs) == 0 {
-		return 0;
+		return 0
 	}
 
 	return len(z.abs)*int(_W) - int(leadingZeros(z.abs[len(z.abs)-1]));
@@ -338,11 +338,11 @@ func (z *Int) Exp(x, y, m *Int) *Int {
 		z.Mul(z, z);
 
 		if v&mask != 0 {
-			z.Mul(z, x);
+			z.Mul(z, x)
 		}
 
 		if m != nil {
-			z.Mod(z, m);
+			z.Mod(z, m)
 		}
 
 		v <<= 1;
@@ -355,11 +355,11 @@ func (z *Int) Exp(x, y, m *Int) *Int {
 			z.Mul(z, z);
 
 			if v&mask != 0 {
-				z.Mul(z, x);
+				z.Mul(z, x)
 			}
 
 			if m != nil {
-				z.Mod(z, m);
+				z.Mod(z, m)
 			}
 
 			v <<= 1;
@@ -379,10 +379,10 @@ func GcdInt(d, x, y, a, b *Int) {
 	if a.neg || b.neg {
 		d.New(0);
 		if x != nil {
-			x.New(0);
+			x.New(0)
 		}
 		if y != nil {
-			y.New(0);
+			y.New(0)
 		}
 		return;
 	}
@@ -418,11 +418,11 @@ func GcdInt(d, x, y, a, b *Int) {
 	}
 
 	if x != nil {
-		*x = *lastX;
+		*x = *lastX
 	}
 
 	if y != nil {
-		*y = *lastY;
+		*y = *lastY
 	}
 
 	*d = *A;
diff --git a/src/pkg/big/int_test.go b/src/pkg/big/int_test.go
index a89b7aa9e0..e5795232a5 100644
--- a/src/pkg/big/int_test.go
+++ b/src/pkg/big/int_test.go
@@ -47,7 +47,7 @@ func TestSetZ(t *testing.T) {
 		var z Int;
 		z.Set(a.z);
 		if CmpInt(&z, a.z) != 0 {
-			t.Errorf("got z = %v; want %v", z, a.z);
+			t.Errorf("got z = %v; want %v", z, a.z)
 		}
 	}
 }
@@ -57,7 +57,7 @@ func testFunZZ(t *testing.T, msg string, f funZZ, a argZZ) {
 	var z Int;
 	f(&z, a.x, a.y);
 	if CmpInt(&z, a.z) != 0 {
-		t.Errorf("%s%+v\n\tgot z = %v; want %v", msg, a, &z, a.z);
+		t.Errorf("%s%+v\n\tgot z = %v; want %v", msg, a, &z, a.z)
 	}
 }
 
@@ -121,7 +121,7 @@ func TestFact(t *testing.T) {
 	for n, s := range facts {
 		f := fact(n).String();
 		if f != s {
-			t.Errorf("%d! = %s; want %s", n, f, s);
+			t.Errorf("%d! = %s; want %s", n, f, s)
 		}
 	}
 }
@@ -162,11 +162,11 @@ func TestSetString(t *testing.T) {
 			continue;
 		}
 		if !ok {
-			continue;
+			continue
 		}
 
 		if CmpInt(n, new(Int).New(test.out)) != 0 {
-			t.Errorf("#%d (input '%s') got: %s want: %d\n", i, test.in, n, test.out);
+			t.Errorf("#%d (input '%s') got: %s want: %d\n", i, test.in, n, test.out)
 		}
 	}
 }
@@ -197,7 +197,7 @@ func TestDivSigns(t *testing.T) {
 		expectedR := new(Int).New(test.r);
 
 		if CmpInt(q, expectedQ) != 0 || CmpInt(r, expectedR) != 0 {
-			t.Errorf("#%d: got (%s, %s) want (%s, %s)", i, q, r, expectedQ, expectedR);
+			t.Errorf("#%d: got (%s, %s) want (%s, %s)", i, q, r, expectedQ, expectedR)
 		}
 	}
 }
@@ -208,11 +208,11 @@ func checkSetBytes(b []byte) bool {
 	hex2 := hex.EncodeToString(b);
 
 	for len(hex1) < len(hex2) {
-		hex1 = "0"+hex1;
+		hex1 = "0"+hex1
 	}
 
 	for len(hex1) > len(hex2) {
-		hex2 = "0"+hex2;
+		hex2 = "0"+hex2
 	}
 
 	return hex1 == hex2;
@@ -222,7 +222,7 @@ func checkSetBytes(b []byte) bool {
 func TestSetBytes(t *testing.T) {
 	err := quick.Check(checkSetBytes, nil);
 	if err != nil {
-		t.Error(err);
+		t.Error(err)
 	}
 }
 
@@ -236,7 +236,7 @@ func checkBytes(b []byte) bool {
 func TestBytes(t *testing.T) {
 	err := quick.Check(checkSetBytes, nil);
 	if err != nil {
-		t.Error(err);
+		t.Error(err)
 	}
 }
 
@@ -246,13 +246,13 @@ func checkDiv(x, y []byte) bool {
 	v := new(Int).SetBytes(y);
 
 	if len(v.abs) == 0 {
-		return true;
+		return true
 	}
 
 	q, r := new(Int).Div(u, v);
 
 	if CmpInt(r, v) >= 0 {
-		return false;
+		return false
 	}
 
 	uprime := new(Int).Set(q);
@@ -282,7 +282,7 @@ var divTests = []divTest{
 func TestDiv(t *testing.T) {
 	err := quick.Check(checkDiv, nil);
 	if err != nil {
-		t.Error(err);
+		t.Error(err)
 	}
 
 	for i, test := range divTests {
@@ -294,7 +294,7 @@ func TestDiv(t *testing.T) {
 		q, r := new(Int).Div(x, y);
 
 		if CmpInt(q, expectedQ) != 0 || CmpInt(r, expectedR) != 0 {
-			t.Errorf("#%d got (%s, %s) want (%s, %s)", i, q, r, expectedQ, expectedR);
+			t.Errorf("#%d got (%s, %s) want (%s, %s)", i, q, r, expectedQ, expectedR)
 		}
 	}
 }
@@ -314,7 +314,7 @@ func TestDivStepD6(t *testing.T) {
 	const expectedR32 = "39614081266355540837921718287";
 	if q.String() != expectedQ64 && q.String() != expectedQ32 ||
 		r.String() != expectedR64 && r.String() != expectedR32 {
-		t.Errorf("got (%s, %s) want (%s, %s) or (%s, %s)", q, r, expectedQ64, expectedR64, expectedQ32, expectedR32);
+		t.Errorf("got (%s, %s) want (%s, %s) or (%s, %s)", q, r, expectedQ64, expectedR64, expectedQ32, expectedR32)
 	}
 }
 
@@ -347,7 +347,7 @@ func TestLen(t *testing.T) {
 		}
 
 		if n.Len() != test.out {
-			t.Errorf("#%d got %d want %d\n", i, n.Len(), test.out);
+			t.Errorf("#%d got %d want %d\n", i, n.Len(), test.out)
 		}
 	}
 }
@@ -390,9 +390,9 @@ func TestExp(t *testing.T) {
 		var m *Int;
 
 		if len(test.m) == 0 {
-			m, ok4 = nil, true;
+			m, ok4 = nil, true
 		} else {
-			m, ok4 = new(Int).SetString(test.m, 0);
+			m, ok4 = new(Int).SetString(test.m, 0)
 		}
 
 		if !ok1 || !ok2 || !ok3 || !ok4 {
@@ -402,7 +402,7 @@ func TestExp(t *testing.T) {
 
 		z := new(Int).Exp(x, y, m);
 		if CmpInt(z, out) != 0 {
-			t.Errorf("#%d got %s want %s", i, z, out);
+			t.Errorf("#%d got %s want %s", i, z, out)
 		}
 	}
 }
@@ -454,7 +454,7 @@ func TestGcd(t *testing.T) {
 		if CmpInt(expectedX, x) != 0 ||
 			CmpInt(expectedY, y) != 0 ||
 			CmpInt(expectedD, d) != 0 {
-			t.Errorf("#%d got (%s %s %s) want (%s %s %s)", i, x, y, d, expectedX, expectedY, expectedD);
+			t.Errorf("#%d got (%s %s %s) want (%s %s %s)", i, x, y, d, expectedX, expectedY, expectedD)
 		}
 	}
 
diff --git a/src/pkg/big/nat.go b/src/pkg/big/nat.go
index 99ddefb627..4816273153 100644
--- a/src/pkg/big/nat.go
+++ b/src/pkg/big/nat.go
@@ -37,7 +37,7 @@ package big
 func normN(z []Word) []Word {
 	i := len(z);
 	for i > 0 && z[i-1] == 0 {
-		i--;
+		i--
 	}
 	z = z[0:i];
 	return z;
@@ -49,7 +49,7 @@ func makeN(z []Word, m int, clear bool) []Word {
 		z = z[0:m];	// reuse z - has at least one extra word for a carry, if any
 		if clear {
 			for i := range z {
-				z[i] = 0;
+				z[i] = 0
 			}
 		}
 		return z;
@@ -57,7 +57,7 @@ func makeN(z []Word, m int, clear bool) []Word {
 
 	c := 4;	// minimum capacity
 	if m > c {
-		c = m;
+		c = m
 	}
 	return make([]Word, m, c+1);	// +1: extra word for a carry, if any
 }
@@ -65,7 +65,7 @@ func makeN(z []Word, m int, clear bool) []Word {
 
 func newN(z []Word, x uint64) []Word {
 	if x == 0 {
-		return makeN(z, 0, false);
+		return makeN(z, 0, false)
 	}
 
 	// single-digit values
@@ -78,7 +78,7 @@ func newN(z []Word, x uint64) []Word {
 	// compute number of words n required to represent x
 	n := 0;
 	for t := x; t > 0; t >>= _W {
-		n++;
+		n++
 	}
 
 	// split x into n words
@@ -95,7 +95,7 @@ func newN(z []Word, x uint64) []Word {
 func setN(z, x []Word) []Word {
 	z = makeN(z, len(x), false);
 	for i, d := range x {
-		z[i] = d;
+		z[i] = d
 	}
 	return z;
 }
@@ -107,20 +107,20 @@ func addNN(z, x, y []Word) []Word {
 
 	switch {
 	case m < n:
-		return addNN(z, y, x);
+		return addNN(z, y, x)
 	case m == 0:
 		// n == 0 because m >= n; result is 0
-		return makeN(z, 0, false);
+		return makeN(z, 0, false)
 	case n == 0:
 		// result is x
-		return setN(z, x);
+		return setN(z, x)
 	}
 	// m > 0
 
 	z = makeN(z, m, false);
 	c := addVV(&z[0], &x[0], &y[0], n);
 	if m > n {
-		c = addVW(&z[n], &x[n], c, m-n);
+		c = addVW(&z[n], &x[n], c, m-n)
 	}
 	if c > 0 {
 		z = z[0 : m+1];
@@ -137,23 +137,23 @@ func subNN(z, x, y []Word) []Word {
 
 	switch {
 	case m < n:
-		panic("underflow");
+		panic("underflow")
 	case m == 0:
 		// n == 0 because m >= n; result is 0
-		return makeN(z, 0, false);
+		return makeN(z, 0, false)
 	case n == 0:
 		// result is x
-		return setN(z, x);
+		return setN(z, x)
 	}
 	// m > 0
 
 	z = makeN(z, m, false);
 	c := subVV(&z[0], &x[0], &y[0], n);
 	if m > n {
-		c = subVW(&z[n], &x[n], c, m-n);
+		c = subVW(&z[n], &x[n], c, m-n)
 	}
 	if c != 0 {
-		panic("underflow");
+		panic("underflow")
 	}
 	z = normN(z);
 
@@ -167,23 +167,23 @@ func cmpNN(x, y []Word) (r int) {
 	if m != n || m == 0 {
 		switch {
 		case m < n:
-			r = -1;
+			r = -1
 		case m > n:
-			r = 1;
+			r = 1
 		}
 		return;
 	}
 
 	i := m-1;
 	for i > 0 && x[i] == y[i] {
-		i--;
+		i--
 	}
 
 	switch {
 	case x[i] < y[i]:
-		r = -1;
+		r = -1
 	case x[i] > y[i]:
-		r = 1;
+		r = 1
 	}
 	return;
 }
@@ -192,7 +192,7 @@ func cmpNN(x, y []Word) (r int) {
 func mulAddNWW(z, x []Word, y, r Word) []Word {
 	m := len(x);
 	if m == 0 || y == 0 {
-		return newN(z, uint64(r));	// result is r
+		return newN(z, uint64(r))	// result is r
 	}
 	// m > 0
 
@@ -213,21 +213,21 @@ func mulNN(z, x, y []Word) []Word {
 
 	switch {
 	case m < n:
-		return mulNN(z, y, x);
+		return mulNN(z, y, x)
 	case m == 0 || n == 0:
-		return makeN(z, 0, false);
+		return makeN(z, 0, false)
 	case n == 1:
-		return mulAddNWW(z, x, y[0], 0);
+		return mulAddNWW(z, x, y[0], 0)
 	}
 	// m >= n && m > 1 && n > 1
 
 	z = makeN(z, m+n, true);
 	if &z[0] == &x[0] || &z[0] == &y[0] {
-		z = makeN(nil, m+n, true);	// z is an alias for x or y - cannot reuse
+		z = makeN(nil, m+n, true)	// z is an alias for x or y - cannot reuse
 	}
 	for i := 0; i < n; i++ {
 		if f := y[i]; f != 0 {
-			z[m+i] = addMulVVW(&z[i], &x[0], f, m);
+			z[m+i] = addMulVVW(&z[i], &x[0], f, m)
 		}
 	}
 	z = normN(z);
@@ -241,7 +241,7 @@ func divNW(z, x []Word, y Word) (q []Word, r Word) {
 	m := len(x);
 	switch {
 	case y == 0:
-		panic("division by zero");
+		panic("division by zero")
 	case y == 1:
 		q = setN(z, x);	// result is x
 		return;
@@ -290,7 +290,7 @@ func divNN(z, z2, uIn, v []Word) (q, r []Word) {
 			rhat += v[n-1];
 			// v[n-1] >= 0, so this tests for overflow.
 			if rhat < prevRhat {
-				break;
+				break
 			}
 			x1, x2 = mulWW_g(qhat, v[n-2]);
 		}
@@ -323,7 +323,7 @@ func divNN(z, z2, uIn, v []Word) (q, r []Word) {
 func log2(x Word) int {
 	n := 0;
 	for ; x > 0; x >>= 1 {
-		n++;
+		n++
 	}
 	return n-1;
 }
@@ -335,7 +335,7 @@ func log2(x Word) int {
 func log2N(x []Word) int {
 	m := len(x);
 	if m > 0 {
-		return (m-1)*int(_W) + log2(x[m-1]);
+		return (m-1)*int(_W) + log2(x[m-1])
 	}
 	return -1;
 }
@@ -345,13 +345,13 @@ func hexValue(ch byte) int {
 	var d byte;
 	switch {
 	case '0' <= ch && ch <= '9':
-		d = ch-'0';
+		d = ch-'0'
 	case 'a' <= ch && ch <= 'f':
-		d = ch-'a'+10;
+		d = ch-'a'+10
 	case 'A' <= ch && ch <= 'F':
-		d = ch-'A'+10;
+		d = ch-'A'+10
 	default:
-		return -1;
+		return -1
 	}
 	return int(d);
 }
@@ -376,16 +376,16 @@ func scanN(z []Word, s string, base int) ([]Word, int, int) {
 			if n > 1 && (s[1] == 'x' || s[1] == 'X') {
 				if n == 2 {
 					// Reject a string which is just '0x' as nonsense.
-					return nil, 0, 0;
+					return nil, 0, 0
 				}
 				base, i = 16, 2;
 			} else {
-				base, i = 8, 1;
+				base, i = 8, 1
 			}
 		}
 	}
 	if base < 2 || 16 < base {
-		panic("illegal base");
+		panic("illegal base")
 	}
 
 	// convert string
@@ -393,9 +393,9 @@ func scanN(z []Word, s string, base int) ([]Word, int, int) {
 	for ; i < n; i++ {
 		d := hexValue(s[i]);
 		if 0 <= d && d < base {
-			z = mulAddNWW(z, z, Word(base), Word(d));
+			z = mulAddNWW(z, z, Word(base), Word(d))
 		} else {
-			break;
+			break
 		}
 	}
 
@@ -408,11 +408,11 @@ func scanN(z []Word, s string, base int) ([]Word, int, int) {
 //           a []byte buffer and return it
 func stringN(x []Word, base int) string {
 	if base < 2 || 16 < base {
-		panic("illegal base");
+		panic("illegal base")
 	}
 
 	if len(x) == 0 {
-		return "0";
+		return "0"
 	}
 
 	// allocate buffer for conversion
@@ -444,7 +444,7 @@ func leadingZeroBits(x Word) int {
 
 	for i := 0; x != 0; i++ {
 		if x&(1<<(_W-1)) != 0 {
-			return i+c;
+			return i+c
 		}
 		x <<= 1;
 	}
@@ -455,7 +455,7 @@ func leadingZeroBits(x Word) int {
 
 func shiftLeft(dst, src []Word, n int) {
 	if len(src) == 0 {
-		return;
+		return
 	}
 
 	ñ := uint(_W)-uint(n);
@@ -469,7 +469,7 @@ func shiftLeft(dst, src []Word, n int) {
 
 func shiftRight(dst, src []Word, n int) {
 	if len(src) == 0 {
-		return;
+		return
 	}
 
 	ñ := uint(_W)-uint(n);
diff --git a/src/pkg/big/nat_test.go b/src/pkg/big/nat_test.go
index 098575a172..1c8c293217 100644
--- a/src/pkg/big/nat_test.go
+++ b/src/pkg/big/nat_test.go
@@ -43,7 +43,7 @@ func TestSetN(t *testing.T) {
 	for _, a := range sumNN {
 		z := setN(nil, a.z);
 		if cmpNN(z, a.z) != 0 {
-			t.Errorf("got z = %v; want %v", z, a.z);
+			t.Errorf("got z = %v; want %v", z, a.z)
 		}
 	}
 }
@@ -52,7 +52,7 @@ func TestSetN(t *testing.T) {
 func testFunNN(t *testing.T, msg string, f funNN, a argNN) {
 	z := f(nil, a.x, a.y);
 	if cmpNN(z, a.z) != 0 {
-		t.Errorf("%s%+v\n\tgot z = %v; want %v", msg, a, z, a.z);
+		t.Errorf("%s%+v\n\tgot z = %v; want %v", msg, a, z, a.z)
 	}
 }
 
@@ -101,18 +101,18 @@ func TestStringN(t *testing.T) {
 	for _, a := range tabN {
 		s := stringN(a.x, a.b);
 		if s != a.s {
-			t.Errorf("stringN%+v\n\tgot s = %s; want %s", a, s, a.s);
+			t.Errorf("stringN%+v\n\tgot s = %s; want %s", a, s, a.s)
 		}
 
 		x, b, n := scanN(nil, a.s, a.b);
 		if cmpNN(x, a.x) != 0 {
-			t.Errorf("scanN%+v\n\tgot z = %v; want %v", a, x, a.x);
+			t.Errorf("scanN%+v\n\tgot z = %v; want %v", a, x, a.x)
 		}
 		if b != a.b {
-			t.Errorf("scanN%+v\n\tgot b = %d; want %d", a, b, a.b);
+			t.Errorf("scanN%+v\n\tgot b = %d; want %d", a, b, a.b)
 		}
 		if n != len(a.s) {
-			t.Errorf("scanN%+v\n\tgot n = %d; want %d", a, n, len(a.s));
+			t.Errorf("scanN%+v\n\tgot n = %d; want %d", a, n, len(a.s))
 		}
 	}
 }
@@ -122,7 +122,7 @@ func TestLeadingZeroBits(t *testing.T) {
 	var x Word = 1<<(_W-1);
 	for i := 0; i <= int(_W); i++ {
 		if leadingZeroBits(x) != i {
-			t.Errorf("failed at %x: got %d want %d", x, leadingZeroBits(x), i);
+			t.Errorf("failed at %x: got %d want %d", x, leadingZeroBits(x), i)
 		}
 		x >>= 1;
 	}
diff --git a/src/pkg/bignum/arith.go b/src/pkg/bignum/arith.go
index a84a1139ee..068416729b 100644
--- a/src/pkg/bignum/arith.go
+++ b/src/pkg/bignum/arith.go
@@ -25,7 +25,7 @@ func Mul128(x, y uint64) (z1, z0 uint64) {
 	)
 
 	if x < y {
-		x, y = y, x;
+		x, y = y, x
 	}
 
 	if x < B2 {
diff --git a/src/pkg/bignum/bignum.go b/src/pkg/bignum/bignum.go
index ed61dad6bd..bb7fb68f05 100755
--- a/src/pkg/bignum/bignum.go
+++ b/src/pkg/bignum/bignum.go
@@ -83,7 +83,7 @@ const (
 
 func assert(p bool) {
 	if !p {
-		panic("assert failed");
+		panic("assert failed")
 	}
 }
 
@@ -115,14 +115,14 @@ type Natural []digit
 //
 func Nat(x uint64) Natural {
 	if x == 0 {
-		return nil;	// len == 0
+		return nil	// len == 0
 	}
 
 	// single-digit values
 	// (note: cannot re-use preallocated values because
 	//        the in-place operations may overwrite them)
 	if x < _B {
-		return Natural{digit(x)};
+		return Natural{digit(x)}
 	}
 
 	// compute number of digits required to represent x
@@ -130,7 +130,7 @@ func Nat(x uint64) Natural {
 	// for any base)
 	n := 0;
 	for t := x; t > 0; t >>= _W {
-		n++;
+		n++
 	}
 
 	// split x into digits
@@ -151,9 +151,9 @@ func (x Natural) Value() uint64 {
 	n := len(x);
 	switch n {
 	case 0:
-		return 0;
+		return 0
 	case 1:
-		return uint64(x[0]);
+		return uint64(x[0])
 	}
 
 	// multi-digit values
@@ -199,7 +199,7 @@ func (x Natural) IsZero() bool	{ return len(x) == 0 }
 func normalize(x Natural) Natural {
 	n := len(x);
 	for n > 0 && x[n-1] == 0 {
-		n--;
+		n--
 	}
 	return x[0:n];
 }
@@ -212,10 +212,10 @@ func normalize(x Natural) Natural {
 func nalloc(z Natural, n int) Natural {
 	size := n;
 	if size <= 0 {
-		size = 4;
+		size = 4
 	}
 	if size <= cap(z) {
-		return z[0:n];
+		return z[0:n]
 	}
 	return make(Natural, n, size);
 }
@@ -270,7 +270,7 @@ func Nsub(zp *Natural, x, y Natural) {
 	n := len(x);
 	m := len(y);
 	if n < m {
-		panic("underflow");
+		panic("underflow")
 	}
 
 	z := nalloc(*zp, n);
@@ -287,7 +287,7 @@ func Nsub(zp *Natural, x, y Natural) {
 		i++;
 	}
 	if int64(c) < 0 {
-		panic("underflow");
+		panic("underflow")
 	}
 	*zp = normalize(z);
 }
@@ -313,7 +313,7 @@ func muladd11(x, y, c digit) (digit, digit) {
 
 func mul1(z, x Natural, y digit) (c digit) {
 	for i := 0; i < len(x); i++ {
-		c, z[i] = muladd11(x[i], y, c);
+		c, z[i] = muladd11(x[i], y, c)
 	}
 	return;
 }
@@ -327,7 +327,7 @@ func Nscale(z *Natural, d uint64) {
 		*z = Nat(0);
 		return;
 	case d == 1:
-		return;
+		return
 	case d >= _B:
 		*z = z.Mul1(d);
 		return;
@@ -340,11 +340,11 @@ func Nscale(z *Natural, d uint64) {
 		if n >= cap(*z) {
 			zz := make(Natural, n+1);
 			for i, d := range *z {
-				zz[i] = d;
+				zz[i] = d
 			}
 			*z = zz;
 		} else {
-			*z = (*z)[0 : n+1];
+			*z = (*z)[0 : n+1]
 		}
 		(*z)[n] = c;
 	}
@@ -373,13 +373,13 @@ func muladd1(x Natural, d, c digit) Natural {
 func (x Natural) Mul1(d uint64) Natural {
 	switch {
 	case d == 0:
-		return Nat(0);
+		return Nat(0)
 	case d == 1:
-		return x;
+		return x
 	case isSmall(digit(d)):
-		muladd1(x, digit(d), 0);
+		muladd1(x, digit(d), 0)
 	case d >= _B:
-		return x.Mul(Nat(d));
+		return x.Mul(Nat(d))
 	}
 
 	z := make(Natural, len(x)+1);
@@ -395,15 +395,15 @@ func (x Natural) Mul(y Natural) Natural {
 	n := len(x);
 	m := len(y);
 	if n < m {
-		return y.Mul(x);
+		return y.Mul(x)
 	}
 
 	if m == 0 {
-		return Nat(0);
+		return Nat(0)
 	}
 
 	if m == 1 && y[0] < _B {
-		return x.Mul1(uint64(y[0]));
+		return x.Mul1(uint64(y[0]))
 	}
 
 	z := make(Natural, n+m);
@@ -412,7 +412,7 @@ func (x Natural) Mul(y Natural) Natural {
 		if d != 0 {
 			c := digit(0);
 			for i := 0; i < n; i++ {
-				c, z[i+j] = muladd11(x[i], d, z[i+j]+c);
+				c, z[i+j] = muladd11(x[i], d, z[i+j]+c)
 			}
 			z[n+j] = c;
 		}
@@ -439,7 +439,7 @@ func unpack(x Natural) []digit2 {
 	// normalize result
 	k := 2*n;
 	for k > 0 && z[k-1] == 0 {
-		k--;
+		k--
 	}
 	return z[0:k];	// trim leading 0's
 }
@@ -454,7 +454,7 @@ func pack(x []digit2) Natural {
 		z[n] = digit(x[n*2]);
 	}
 	for i := 0; i < n; i++ {
-		z[i] = digit(x[i*2 + 1])<<_W2 | digit(x[i*2]);
+		z[i] = digit(x[i*2 + 1])<<_W2 | digit(x[i*2])
 	}
 	return normalize(z);
 }
@@ -506,7 +506,7 @@ func divmod(x, y []digit2) ([]digit2, []digit2) {
 	n := len(x);
 	m := len(y);
 	if m == 0 {
-		panic("division by zero");
+		panic("division by zero")
 	}
 	assert(n+1 <= cap(x));	// space for one extra digit
 	x = x[0 : n+1];
@@ -515,12 +515,12 @@ func divmod(x, y []digit2) ([]digit2, []digit2) {
 	if m == 1 {
 		// division by single digit
 		// result is shifted left by 1 in place!
-		x[0] = div21(x[1 : n+1], x[0:n], y[0]);
+		x[0] = div21(x[1 : n+1], x[0:n], y[0])
 
 	} else if m > n {
 		// y > x => quotient = 0, remainder = x
 		// TODO in this case we shouldn't even unpack x and y
-		m = n;
+		m = n
 
 	} else {
 		// general case
@@ -546,12 +546,12 @@ func divmod(x, y []digit2) ([]digit2, []digit2) {
 			{
 				x0, x1, x2 := digit(x[k]), digit(x[k-1]), digit(x[k-2]);
 				if x0 != y1 {
-					q = (x0<<_W2 + x1)/y1;
+					q = (x0<<_W2 + x1)/y1
 				} else {
-					q = _B2-1;
+					q = _B2-1
 				}
 				for y2*q > (x0<<_W2 + x1 - y1*q)<<_W2 + x2 {
-					q--;
+					q--
 				}
 			}
 
@@ -623,7 +623,7 @@ func shl(z, x Natural, s uint) digit {
 	n := len(x);
 	c := digit(0);
 	for i := 0; i < n; i++ {
-		c, z[i] = x[i]>>(_W-s), x[i]<<s&_M | c;
+		c, z[i] = x[i]>>(_W-s), x[i]<<s&_M | c
 	}
 	return c;
 }
@@ -647,7 +647,7 @@ func shr(z, x Natural, s uint) digit {
 	n := len(x);
 	c := digit(0);
 	for i := n-1; i >= 0; i-- {
-		c, z[i] = x[i]<<(_W-s)&_M, x[i]>>s | c;
+		c, z[i] = x[i]<<(_W-s)&_M, x[i]>>s | c
 	}
 	return c;
 }
@@ -659,7 +659,7 @@ func (x Natural) Shr(s uint) Natural {
 	n := uint(len(x));
 	m := n - s/_W;
 	if m > n {	// check for underflow
-		m = 0;
+		m = 0
 	}
 	z := make(Natural, m);
 
@@ -675,12 +675,12 @@ func (x Natural) And(y Natural) Natural {
 	n := len(x);
 	m := len(y);
 	if n < m {
-		return y.And(x);
+		return y.And(x)
 	}
 
 	z := make(Natural, m);
 	for i := 0; i < m; i++ {
-		z[i] = x[i]&y[i];
+		z[i] = x[i]&y[i]
 	}
 	// upper bits are 0
 
@@ -690,7 +690,7 @@ func (x Natural) And(y Natural) Natural {
 
 func copy(z, x Natural) {
 	for i, e := range x {
-		z[i] = e;
+		z[i] = e
 	}
 }
 
@@ -701,12 +701,12 @@ func (x Natural) AndNot(y Natural) Natural {
 	n := len(x);
 	m := len(y);
 	if n < m {
-		m = n;
+		m = n
 	}
 
 	z := make(Natural, n);
 	for i := 0; i < m; i++ {
-		z[i] = x[i]&^y[i];
+		z[i] = x[i]&^y[i]
 	}
 	copy(z[m:n], x[m:n]);
 
@@ -720,12 +720,12 @@ func (x Natural) Or(y Natural) Natural {
 	n := len(x);
 	m := len(y);
 	if n < m {
-		return y.Or(x);
+		return y.Or(x)
 	}
 
 	z := make(Natural, n);
 	for i := 0; i < m; i++ {
-		z[i] = x[i]|y[i];
+		z[i] = x[i]|y[i]
 	}
 	copy(z[m:n], x[m:n]);
 
@@ -739,12 +739,12 @@ func (x Natural) Xor(y Natural) Natural {
 	n := len(x);
 	m := len(y);
 	if n < m {
-		return y.Xor(x);
+		return y.Xor(x)
 	}
 
 	z := make(Natural, n);
 	for i := 0; i < m; i++ {
-		z[i] = x[i]^y[i];
+		z[i] = x[i]^y[i]
 	}
 	copy(z[m:n], x[m:n]);
 
@@ -763,20 +763,20 @@ func (x Natural) Cmp(y Natural) int {
 	m := len(y);
 
 	if n != m || n == 0 {
-		return n-m;
+		return n-m
 	}
 
 	i := n-1;
 	for i > 0 && x[i] == y[i] {
-		i--;
+		i--
 	}
 
 	d := 0;
 	switch {
 	case x[i] < y[i]:
-		d = -1;
+		d = -1
 	case x[i] > y[i]:
-		d = 1;
+		d = 1
 	}
 
 	return d;
@@ -805,7 +805,7 @@ func log2(x uint64) uint {
 func (x Natural) Log2() uint {
 	n := len(x);
 	if n > 0 {
-		return (uint(n)-1)*_W + log2(uint64(x[n-1]));
+		return (uint(n)-1)*_W + log2(uint64(x[n-1]))
 	}
 	panic("Log2(0)");
 }
@@ -831,7 +831,7 @@ func divmod1(x Natural, d digit) (Natural, digit) {
 //
 func (x Natural) ToString(base uint) string {
 	if len(x) == 0 {
-		return "0";
+		return "0"
 	}
 
 	// allocate buffer for conversion
@@ -865,11 +865,11 @@ func (x Natural) String() string	{ return x.ToString(10) }
 func fmtbase(c int) uint {
 	switch c {
 	case 'b':
-		return 2;
+		return 2
 	case 'o':
-		return 8;
+		return 8
 	case 'x':
-		return 16;
+		return 16
 	}
 	return 10;
 }
@@ -885,11 +885,11 @@ func hexvalue(ch byte) uint {
 	d := uint(1<<logH);
 	switch {
 	case '0' <= ch && ch <= '9':
-		d = uint(ch-'0');
+		d = uint(ch-'0')
 	case 'a' <= ch && ch <= 'f':
-		d = uint(ch-'a')+10;
+		d = uint(ch-'a')+10
 	case 'A' <= ch && ch <= 'F':
-		d = uint(ch-'A')+10;
+		d = uint(ch-'A')+10
 	}
 	return d;
 }
@@ -912,9 +912,9 @@ func NatFromString(s string, base uint) (Natural, uint, int) {
 		base = 10;
 		if n > 0 && s[0] == '0' {
 			if n > 1 && (s[1] == 'x' || s[1] == 'X') {
-				base, i = 16, 2;
+				base, i = 16, 2
 			} else {
-				base, i = 8, 1;
+				base, i = 8, 1
 			}
 		}
 	}
@@ -925,9 +925,9 @@ func NatFromString(s string, base uint) (Natural, uint, int) {
 	for ; i < n; i++ {
 		d := hexvalue(s[i]);
 		if d < base {
-			x = muladd1(x, digit(base), digit(d));
+			x = muladd1(x, digit(base), digit(d))
 		} else {
-			break;
+			break
 		}
 	}
 
@@ -952,7 +952,7 @@ func pop1(x digit) uint {
 func (x Natural) Pop() uint {
 	n := uint(0);
 	for i := len(x)-1; i >= 0; i-- {
-		n += pop1(x[i]);
+		n += pop1(x[i])
 	}
 	return n;
 }
@@ -966,7 +966,7 @@ func (xp Natural) Pow(n uint) Natural {
 	for n > 0 {
 		// z * x^n == x^n0
 		if n&1 == 1 {
-			z = z.Mul(x);
+			z = z.Mul(x)
 		}
 		x, n = x.Mul(x), n/2;
 	}
@@ -980,11 +980,11 @@ func (xp Natural) Pow(n uint) Natural {
 func MulRange(a, b uint) Natural {
 	switch {
 	case a > b:
-		return Nat(1);
+		return Nat(1)
 	case a == b:
-		return Nat(uint64(a));
+		return Nat(uint64(a))
 	case a+1 == b:
-		return Nat(uint64(a)).Mul(Nat(uint64(b)));
+		return Nat(uint64(a)).Mul(Nat(uint64(b)))
 	}
 	m := (a+b)>>1;
 	assert(a <= m && m < b);
@@ -997,7 +997,7 @@ func MulRange(a, b uint) Natural {
 func Fact(n uint) Natural {
 	// Using MulRange() instead of the basic for-loop
 	// lead to faster factorial computation.
-	return MulRange(2, n);
+	return MulRange(2, n)
 }
 
 
@@ -1012,7 +1012,7 @@ func (x Natural) Gcd(y Natural) Natural {
 	// Euclidean algorithm.
 	a, b := x, y;
 	for !b.IsZero() {
-		a, b = b, a.Mod(b);
+		a, b = b, a.Mod(b)
 	}
 	return a;
 }
diff --git a/src/pkg/bignum/bignum_test.go b/src/pkg/bignum/bignum_test.go
index 230e42f13b..b62fbf4859 100644
--- a/src/pkg/bignum/bignum_test.go
+++ b/src/pkg/bignum/bignum_test.go
@@ -21,7 +21,7 @@ const (
 func natFromString(s string, base uint, slen *int) Natural {
 	x, _, len := NatFromString(s, base);
 	if slen != nil {
-		*slen = len;
+		*slen = len
 	}
 	return x;
 }
@@ -30,7 +30,7 @@ func natFromString(s string, base uint, slen *int) Natural {
 func intFromString(s string, base uint, slen *int) *Integer {
 	x, _, len := IntFromString(s, base);
 	if slen != nil {
-		*slen = len;
+		*slen = len
 	}
 	return x;
 }
@@ -39,7 +39,7 @@ func intFromString(s string, base uint, slen *int) *Integer {
 func ratFromString(s string, base uint, slen *int) *Rational {
 	x, _, len := RatFromString(s, base);
 	if slen != nil {
-		*slen = len;
+		*slen = len
 	}
 	return x;
 }
@@ -69,28 +69,28 @@ var tester *testing.T
 
 func test(n uint, b bool) {
 	if !b {
-		tester.Fatalf("TEST failed: %s (%d)", test_msg, n);
+		tester.Fatalf("TEST failed: %s (%d)", test_msg, n)
 	}
 }
 
 
 func nat_eq(n uint, x, y Natural) {
 	if x.Cmp(y) != 0 {
-		tester.Fatalf("TEST failed: %s (%d)\nx = %v\ny = %v", test_msg, n, &x, &y);
+		tester.Fatalf("TEST failed: %s (%d)\nx = %v\ny = %v", test_msg, n, &x, &y)
 	}
 }
 
 
 func int_eq(n uint, x, y *Integer) {
 	if x.Cmp(y) != 0 {
-		tester.Fatalf("TEST failed: %s (%d)\nx = %v\ny = %v", test_msg, n, x, y);
+		tester.Fatalf("TEST failed: %s (%d)\nx = %v\ny = %v", test_msg, n, x, y)
 	}
 }
 
 
 func rat_eq(n uint, x, y *Rational) {
 	if x.Cmp(y) != 0 {
-		tester.Fatalf("TEST failed: %s (%d)\nx = %v\ny = %v", test_msg, n, x, y);
+		tester.Fatalf("TEST failed: %s (%d)\nx = %v\ny = %v", test_msg, n, x, y)
 	}
 }
 
@@ -116,7 +116,7 @@ func TestNatConv(t *testing.T) {
 
 	test_msg = "NatConvB";
 	for i := uint(0); i < 100; i++ {
-		test(i, Nat(uint64(i)).String() == fmt.Sprintf("%d", i));
+		test(i, Nat(uint64(i)).String() == fmt.Sprintf("%d", i))
 	}
 
 	test_msg = "NatConvC";
@@ -146,7 +146,7 @@ func TestNatConv(t *testing.T) {
 	test_msg = "NatConvF";
 	tmp := c.Mul(c);
 	for base := uint(2); base <= 16; base++ {
-		nat_eq(base, natFromString(tmp.ToString(base), base, nil), tmp);
+		nat_eq(base, natFromString(tmp.ToString(base), base, nil), tmp)
 	}
 
 	test_msg = "NatConvG";
@@ -158,7 +158,7 @@ func TestNatConv(t *testing.T) {
 
 func abs(x int64) uint64 {
 	if x < 0 {
-		x = -x;
+		x = -x
 	}
 	return uint64(x);
 }
@@ -235,7 +235,7 @@ func add(x, y Natural) Natural {
 	z1 := x.Add(y);
 	z2 := y.Add(x);
 	if z1.Cmp(z2) != 0 {
-		tester.Fatalf("addition not symmetric:\n\tx = %v\n\ty = %t", x, y);
+		tester.Fatalf("addition not symmetric:\n\tx = %v\n\ty = %t", x, y)
 	}
 	return z1;
 }
@@ -244,7 +244,7 @@ func add(x, y Natural) Natural {
 func sum(n uint64, scale Natural) Natural {
 	s := nat_zero;
 	for ; n > 0; n-- {
-		s = add(s, Nat(n).Mul(scale));
+		s = add(s, Nat(n).Mul(scale))
 	}
 	return s;
 }
@@ -268,13 +268,13 @@ func mul(x, y Natural) Natural {
 	z1 := x.Mul(y);
 	z2 := y.Mul(x);
 	if z1.Cmp(z2) != 0 {
-		tester.Fatalf("multiplication not symmetric:\n\tx = %v\n\ty = %t", x, y);
+		tester.Fatalf("multiplication not symmetric:\n\tx = %v\n\ty = %t", x, y)
 	}
 	if !x.IsZero() && z1.Div(x).Cmp(y) != 0 {
-		tester.Fatalf("multiplication/division not inverse (A):\n\tx = %v\n\ty = %t", x, y);
+		tester.Fatalf("multiplication/division not inverse (A):\n\tx = %v\n\ty = %t", x, y)
 	}
 	if !y.IsZero() && z1.Div(y).Cmp(x) != 0 {
-		tester.Fatalf("multiplication/division not inverse (B):\n\tx = %v\n\ty = %t", x, y);
+		tester.Fatalf("multiplication/division not inverse (B):\n\tx = %v\n\ty = %t", x, y)
 	}
 	return z1;
 }
@@ -290,7 +290,7 @@ func TestNatSub(t *testing.T) {
 	for i := uint64(0); i < 100; i++ {
 		t := sum(i, c);
 		for j := uint64(0); j <= i; j++ {
-			t = t.Sub(mul(Nat(j), c));
+			t = t.Sub(mul(Nat(j), c))
 		}
 		nat_eq(uint(i), t, nat_zero);
 	}
@@ -311,7 +311,7 @@ func TestNatMul(t *testing.T) {
 	const n = 100;
 	p := b.Mul(c).Shl(n);
 	for i := uint(0); i < n; i++ {
-		nat_eq(i, mul(b.Shl(i), c.Shl(n-i)), p);
+		nat_eq(i, mul(b.Shl(i), c.Shl(n-i)), p)
 	}
 }
 
@@ -329,7 +329,7 @@ func TestNatDiv(t *testing.T) {
 	const n = 100;
 	p := Fact(n);
 	for i := uint(0); i < n; i++ {
-		nat_eq(100+i, p.Div(MulRange(1, i)), MulRange(i+1, n));
+		nat_eq(100+i, p.Div(MulRange(1, i)), MulRange(i+1, n))
 	}
 }
 
@@ -398,7 +398,7 @@ func TestNatMod(t *testing.T) {
 	for i := uint(0); ; i++ {
 		d := nat_one.Shl(i);
 		if d.Cmp(c) < 0 {
-			nat_eq(i, c.Add(d).Mod(c), d);
+			nat_eq(i, c.Add(d).Mod(c), d)
 		} else {
 			nat_eq(i, c.Add(d).Div(c), nat_two);
 			nat_eq(i, c.Add(d).Mod(c), d.Sub(c));
@@ -420,7 +420,7 @@ func TestNatShift(t *testing.T) {
 
 	test_msg = "NatShift2";
 	for i := uint(0); i < 100; i++ {
-		test(i, c.Shl(i).Shr(i).Cmp(c) == 0);
+		test(i, c.Shl(i).Shr(i).Cmp(c) == 0)
 	}
 
 	test_msg = "NatShift3L";
@@ -457,7 +457,7 @@ func TestIntShift(t *testing.T) {
 
 	test_msg = "IntShift2";
 	for i := uint(0); i < 100; i++ {
-		test(i, ip.Shl(i).Shr(i).Cmp(ip) == 0);
+		test(i, ip.Shl(i).Shr(i).Cmp(ip) == 0)
 	}
 
 	test_msg = "IntShift3L";
@@ -499,25 +499,25 @@ func TestNatBitOps(t *testing.T) {
 	test_msg = "NatAnd";
 	bz := Nat(x&y);
 	for i := uint(0); i < 100; i++ {
-		nat_eq(i, bx.Shl(i).And(by.Shl(i)), bz.Shl(i));
+		nat_eq(i, bx.Shl(i).And(by.Shl(i)), bz.Shl(i))
 	}
 
 	test_msg = "NatAndNot";
 	bz = Nat(x&^y);
 	for i := uint(0); i < 100; i++ {
-		nat_eq(i, bx.Shl(i).AndNot(by.Shl(i)), bz.Shl(i));
+		nat_eq(i, bx.Shl(i).AndNot(by.Shl(i)), bz.Shl(i))
 	}
 
 	test_msg = "NatOr";
 	bz = Nat(x|y);
 	for i := uint(0); i < 100; i++ {
-		nat_eq(i, bx.Shl(i).Or(by.Shl(i)), bz.Shl(i));
+		nat_eq(i, bx.Shl(i).Or(by.Shl(i)), bz.Shl(i))
 	}
 
 	test_msg = "NatXor";
 	bz = Nat(x^y);
 	for i := uint(0); i < 100; i++ {
-		nat_eq(i, bx.Shl(i).Xor(by.Shl(i)), bz.Shl(i));
+		nat_eq(i, bx.Shl(i).Xor(by.Shl(i)), bz.Shl(i))
 	}
 }
 
@@ -560,7 +560,7 @@ func TestIntBitOps2(t *testing.T) {
 		for y := int64(-5); y < 15; y++ {
 			by := Int(y);
 			for i := uint(50); i < 70; i++ {	// shift across 64bit boundary
-				int_eq(i, bx.Shl(i).And(by.Shl(i)), Int(x&y).Shl(i));
+				int_eq(i, bx.Shl(i).And(by.Shl(i)), Int(x&y).Shl(i))
 			}
 		}
 	}
@@ -583,7 +583,7 @@ func TestIntBitOps2(t *testing.T) {
 		for y := int64(-5); y < 15; y++ {
 			by := Int(y);
 			for i := uint(50); i < 70; i++ {	// shift across 64bit boundary
-				int_eq(i, bx.Shl(i).Or(by.Shl(i)), Int(x|y).Shl(i));
+				int_eq(i, bx.Shl(i).Or(by.Shl(i)), Int(x|y).Shl(i))
 			}
 		}
 	}
@@ -594,7 +594,7 @@ func TestIntBitOps2(t *testing.T) {
 		for y := int64(-5); y < 15; y++ {
 			by := Int(y);
 			for i := uint(50); i < 70; i++ {	// shift across 64bit boundary
-				int_eq(i, bx.Shl(i).Xor(by.Shl(i)), Int(x^y).Shl(i));
+				int_eq(i, bx.Shl(i).Xor(by.Shl(i)), Int(x^y).Shl(i))
 			}
 		}
 	}
@@ -624,7 +624,7 @@ func TestNatLog2(t *testing.T) {
 
 	test_msg = "NatLog2B";
 	for i := uint(0); i < 100; i++ {
-		test(i, nat_one.Shl(i).Log2() == i);
+		test(i, nat_one.Shl(i).Log2() == i)
 	}
 }
 
@@ -644,7 +644,7 @@ func TestNatPow(t *testing.T) {
 
 	test_msg = "NatPowB";
 	for i := uint(0); i < 100; i++ {
-		nat_eq(i, nat_two.Pow(i), nat_one.Shl(i));
+		nat_eq(i, nat_two.Pow(i), nat_one.Shl(i))
 	}
 }
 
@@ -660,6 +660,6 @@ func TestNatPop(t *testing.T) {
 
 	test_msg = "NatPopB";
 	for i := uint(0); i < 100; i++ {
-		test(i, nat_one.Shl(i).Sub(nat_one).Pop() == i);
+		test(i, nat_one.Shl(i).Sub(nat_one).Pop() == i)
 	}
 }
diff --git a/src/pkg/bignum/integer.go b/src/pkg/bignum/integer.go
index d305625b5a..618c6d3d20 100644
--- a/src/pkg/bignum/integer.go
+++ b/src/pkg/bignum/integer.go
@@ -29,7 +29,7 @@ type Integer struct {
 //
 func MakeInt(sign bool, mant Natural) *Integer {
 	if mant.IsZero() {
-		sign = false;	// normalize
+		sign = false	// normalize
 	}
 	return &Integer{sign, mant};
 }
@@ -42,9 +42,9 @@ func Int(x int64) *Integer {
 	if x < 0 {
 		// For the most negative x, -x == x, and
 		// the bit pattern has the correct value.
-		ux = uint64(-x);
+		ux = uint64(-x)
 	} else {
-		ux = uint64(x);
+		ux = uint64(x)
 	}
 	return MakeInt(x < 0, Nat(ux));
 }
@@ -56,7 +56,7 @@ func Int(x int64) *Integer {
 func (x *Integer) Value() int64 {
 	z := int64(x.mant.Value());
 	if x.sign {
-		z = -z;
+		z = -z
 	}
 	return z;
 }
@@ -167,7 +167,7 @@ func (x *Integer) Sub(y *Integer) *Integer {
 func Iscale(z *Integer, d int64) {
 	f := uint64(d);
 	if d < 0 {
-		f = uint64(-d);
+		f = uint64(-d)
 	}
 	z.sign = z.sign != (d < 0);
 	Nscale(&z.mant, f);
@@ -179,7 +179,7 @@ func Iscale(z *Integer, d int64) {
 func (x *Integer) Mul1(d int64) *Integer {
 	f := uint64(d);
 	if d < 0 {
-		f = uint64(-d);
+		f = uint64(-d)
 	}
 	return MakeInt(x.sign != (d < 0), x.mant.Mul1(f));
 }
@@ -192,7 +192,7 @@ func (x *Integer) Mul(y *Integer) *Integer {
 	// x * (-y) == -(x * y)
 	// (-x) * y == -(x * y)
 	// (-x) * (-y) == x * y
-	return MakeInt(x.sign != y.sign, x.mant.Mul(y.mant));
+	return MakeInt(x.sign != y.sign, x.mant.Mul(y.mant))
 }
 
 
@@ -201,7 +201,7 @@ func (x *Integer) Mul(y *Integer) *Integer {
 func (x *Integer) MulNat(y Natural) *Integer {
 	// x * y == x * y
 	// (-x) * y == -(x * y)
-	return MakeInt(x.sign, x.mant.Mul(y));
+	return MakeInt(x.sign, x.mant.Mul(y))
 }
 
 
@@ -220,7 +220,7 @@ func (x *Integer) Quo(y *Integer) *Integer {
 	// x / (-y) == -(x / y)
 	// (-x) / y == -(x / y)
 	// (-x) / (-y) == x / y
-	return MakeInt(x.sign != y.sign, x.mant.Div(y.mant));
+	return MakeInt(x.sign != y.sign, x.mant.Div(y.mant))
 }
 
 
@@ -234,7 +234,7 @@ func (x *Integer) Rem(y *Integer) *Integer {
 	// x % (-y) == x % y
 	// (-x) % y == -(x % y)
 	// (-x) % (-y) == -(x % y)
-	return MakeInt(x.sign, x.mant.Mod(y.mant));
+	return MakeInt(x.sign, x.mant.Mod(y.mant))
 }
 
 
@@ -264,9 +264,9 @@ func (x *Integer) Div(y *Integer) *Integer {
 	q, r := x.QuoRem(y);
 	if r.IsNeg() {
 		if y.IsPos() {
-			q = q.Sub(Int(1));
+			q = q.Sub(Int(1))
 		} else {
-			q = q.Add(Int(1));
+			q = q.Add(Int(1))
 		}
 	}
 	return q;
@@ -281,9 +281,9 @@ func (x *Integer) Mod(y *Integer) *Integer {
 	r := x.Rem(y);
 	if r.IsNeg() {
 		if y.IsPos() {
-			r = r.Add(y);
+			r = r.Add(y)
 		} else {
-			r = r.Sub(y);
+			r = r.Sub(y)
 		}
 	}
 	return r;
@@ -333,7 +333,7 @@ func (x *Integer) Shl(s uint) *Integer	{ return MakeInt(x.sign, x.mant.Shl(s)) }
 func (x *Integer) Shr(s uint) *Integer {
 	if x.sign {
 		// (-x) >> s == ^(x-1) >> s == ^((x-1) >> s) == -(((x-1) >> s) + 1)
-		return MakeInt(true, x.mant.Sub(Nat(1)).Shr(s).Add(Nat(1)));
+		return MakeInt(true, x.mant.Sub(Nat(1)).Shr(s).Add(Nat(1)))
 	}
 
 	return MakeInt(false, x.mant.Shr(s));
@@ -344,7 +344,7 @@ func (x *Integer) Shr(s uint) *Integer {
 func (x *Integer) Not() *Integer {
 	if x.sign {
 		// ^(-x) == ^(^(x-1)) == x-1
-		return MakeInt(false, x.mant.Sub(Nat(1)));
+		return MakeInt(false, x.mant.Sub(Nat(1)))
 	}
 
 	// ^x == -x-1 == -(x+1)
@@ -358,7 +358,7 @@ func (x *Integer) And(y *Integer) *Integer {
 	if x.sign == y.sign {
 		if x.sign {
 			// (-x) & (-y) == ^(x-1) & ^(y-1) == ^((x-1) | (y-1)) == -(((x-1) | (y-1)) + 1)
-			return MakeInt(true, x.mant.Sub(Nat(1)).Or(y.mant.Sub(Nat(1))).Add(Nat(1)));
+			return MakeInt(true, x.mant.Sub(Nat(1)).Or(y.mant.Sub(Nat(1))).Add(Nat(1)))
 		}
 
 		// x & y == x & y
@@ -367,7 +367,7 @@ func (x *Integer) And(y *Integer) *Integer {
 
 	// x.sign != y.sign
 	if x.sign {
-		x, y = y, x;	// & is symmetric
+		x, y = y, x	// & is symmetric
 	}
 
 	// x & (-y) == x & ^(y-1) == x &^ (y-1)
@@ -381,7 +381,7 @@ func (x *Integer) AndNot(y *Integer) *Integer {
 	if x.sign == y.sign {
 		if x.sign {
 			// (-x) &^ (-y) == ^(x-1) &^ ^(y-1) == ^(x-1) & (y-1) == (y-1) &^ (x-1)
-			return MakeInt(false, y.mant.Sub(Nat(1)).AndNot(x.mant.Sub(Nat(1))));
+			return MakeInt(false, y.mant.Sub(Nat(1)).AndNot(x.mant.Sub(Nat(1))))
 		}
 
 		// x &^ y == x &^ y
@@ -390,7 +390,7 @@ func (x *Integer) AndNot(y *Integer) *Integer {
 
 	if x.sign {
 		// (-x) &^ y == ^(x-1) &^ y == ^(x-1) & ^y == ^((x-1) | y) == -(((x-1) | y) + 1)
-		return MakeInt(true, x.mant.Sub(Nat(1)).Or(y.mant).Add(Nat(1)));
+		return MakeInt(true, x.mant.Sub(Nat(1)).Or(y.mant).Add(Nat(1)))
 	}
 
 	// x &^ (-y) == x &^ ^(y-1) == x & (y-1)
@@ -404,7 +404,7 @@ func (x *Integer) Or(y *Integer) *Integer {
 	if x.sign == y.sign {
 		if x.sign {
 			// (-x) | (-y) == ^(x-1) | ^(y-1) == ^((x-1) & (y-1)) == -(((x-1) & (y-1)) + 1)
-			return MakeInt(true, x.mant.Sub(Nat(1)).And(y.mant.Sub(Nat(1))).Add(Nat(1)));
+			return MakeInt(true, x.mant.Sub(Nat(1)).And(y.mant.Sub(Nat(1))).Add(Nat(1)))
 		}
 
 		// x | y == x | y
@@ -413,7 +413,7 @@ func (x *Integer) Or(y *Integer) *Integer {
 
 	// x.sign != y.sign
 	if x.sign {
-		x, y = y, x;	// | or symmetric
+		x, y = y, x	// | or symmetric
 	}
 
 	// x | (-y) == x | ^(y-1) == ^((y-1) &^ x) == -(^((y-1) &^ x) + 1)
@@ -427,7 +427,7 @@ func (x *Integer) Xor(y *Integer) *Integer {
 	if x.sign == y.sign {
 		if x.sign {
 			// (-x) ^ (-y) == ^(x-1) ^ ^(y-1) == (x-1) ^ (y-1)
-			return MakeInt(false, x.mant.Sub(Nat(1)).Xor(y.mant.Sub(Nat(1))));
+			return MakeInt(false, x.mant.Sub(Nat(1)).Xor(y.mant.Sub(Nat(1))))
 		}
 
 		// x ^ y == x ^ y
@@ -436,7 +436,7 @@ func (x *Integer) Xor(y *Integer) *Integer {
 
 	// x.sign != y.sign
 	if x.sign {
-		x, y = y, x;	// ^ is symmetric
+		x, y = y, x	// ^ is symmetric
 	}
 
 	// x ^ (-y) == x ^ ^(y-1) == ^(x ^ (y-1)) == -((x ^ (y-1)) + 1)
@@ -460,12 +460,12 @@ func (x *Integer) Cmp(y *Integer) int {
 	case x.sign == y.sign:
 		r = x.mant.Cmp(y.mant);
 		if x.sign {
-			r = -r;
+			r = -r
 		}
 	case x.sign:
-		r = -1;
+		r = -1
 	case y.sign:
-		r = 1;
+		r = 1
 	}
 	return r;
 }
@@ -475,11 +475,11 @@ func (x *Integer) Cmp(y *Integer) int {
 //
 func (x *Integer) ToString(base uint) string {
 	if x.mant.IsZero() {
-		return "0";
+		return "0"
 	}
 	var s string;
 	if x.sign {
-		s = "-";
+		s = "-"
 	}
 	return s + x.mant.ToString(base);
 }
@@ -511,7 +511,7 @@ func IntFromString(s string, base uint) (*Integer, uint, int) {
 	// skip sign, if any
 	i0 := 0;
 	if len(s) > 0 && (s[0] == '-' || s[0] == '+') {
-		i0 = 1;
+		i0 = 1
 	}
 
 	mant, base, slen := NatFromString(s[i0:len(s)], base);
diff --git a/src/pkg/bignum/nrdiv_test.go b/src/pkg/bignum/nrdiv_test.go
index a695e73c5b..752ab79037 100644
--- a/src/pkg/bignum/nrdiv_test.go
+++ b/src/pkg/bignum/nrdiv_test.go
@@ -30,9 +30,9 @@ type fpNat struct {
 func (x fpNat) sub(y fpNat) fpNat {
 	switch d := x.e - y.e; {
 	case d < 0:
-		return fpNat{x.m.Sub(y.m.Shl(uint(-d))), x.e};
+		return fpNat{x.m.Sub(y.m.Shl(uint(-d))), x.e}
 	case d > 0:
-		return fpNat{x.m.Shl(uint(d)).Sub(y.m), y.e};
+		return fpNat{x.m.Shl(uint(d)).Sub(y.m), y.e}
 	}
 	return fpNat{x.m.Sub(y.m), x.e};
 }
@@ -52,9 +52,9 @@ func (x fpNat) mul(y fpNat) fpNat	{ return fpNat{x.m.Mul(y.m), x.e + y.e} }
 func (x fpNat) mant() Natural {
 	switch {
 	case x.e > 0:
-		return x.m.Shl(uint(x.e));
+		return x.m.Shl(uint(x.e))
 	case x.e < 0:
-		return x.m.Shr(uint(-x.e));
+		return x.m.Shr(uint(-x.e))
 	}
 	return x.m;
 }
@@ -71,15 +71,15 @@ func nrDivEst(x0, y0 Natural) Natural {
 	// y0 > 0
 
 	if y0.Cmp(Nat(1)) == 0 {
-		return x0;
+		return x0
 	}
 	// y0 > 1
 
 	switch d := x0.Cmp(y0); {
 	case d < 0:
-		return Nat(0);
+		return Nat(0)
 	case d == 0:
-		return Nat(1);
+		return Nat(1)
 	}
 	// x0 > y0 > 1
 
@@ -119,7 +119,7 @@ func nrDivEst(x0, y0 Natural) Natural {
 		q.e -= e;
 		res := q.mant();
 		if res.Cmp(p) == 0 {
-			return res;
+			return res
 		}
 		p = res;
 
@@ -131,7 +131,7 @@ func nrDivEst(x0, y0 Natural) Natural {
 		//       computation time massively.
 		d := int(r.m.Log2() + 1)-maxLen;
 		if d > 0 {
-			r = fpNat{r.m.Shr(uint(d)), r.e + d};
+			r = fpNat{r.m.Shr(uint(d)), r.e + d}
 		}
 	}
 
@@ -157,10 +157,10 @@ func div(t *testing.T, x, y Natural) {
 	q, r := nrdiv(x, y);
 	qx, rx := x.DivMod(y);
 	if q.Cmp(qx) != 0 {
-		t.Errorf("x = %s, y = %s, got q = %s, want q = %s", x, y, q, qx);
+		t.Errorf("x = %s, y = %s, got q = %s, want q = %s", x, y, q, qx)
 	}
 	if r.Cmp(rx) != 0 {
-		t.Errorf("x = %s, y = %s, got r = %s, want r = %s", x, y, r, rx);
+		t.Errorf("x = %s, y = %s, got r = %s, want r = %s", x, y, r, rx)
 	}
 }
 
diff --git a/src/pkg/bignum/rational.go b/src/pkg/bignum/rational.go
index 6cdc1f3441..e65efc138a 100644
--- a/src/pkg/bignum/rational.go
+++ b/src/pkg/bignum/rational.go
@@ -34,7 +34,7 @@ func MakeRat(a *Integer, b Natural) *Rational {
 func Rat(a0 int64, b0 int64) *Rational {
 	a, b := Int(a0), Int(b0);
 	if b.sign {
-		a = a.Neg();
+		a = a.Neg()
 	}
 	return MakeRat(a, b.mant);
 }
@@ -43,7 +43,7 @@ func Rat(a0 int64, b0 int64) *Rational {
 // Value returns the numerator and denominator of x.
 //
 func (x *Rational) Value() (numerator *Integer, denominator Natural) {
-	return x.a, x.b;
+	return x.a, x.b
 }
 
 
@@ -80,14 +80,14 @@ func (x *Rational) Neg() *Rational	{ return MakeRat(x.a.Neg(), x.b) }
 // Add returns the sum x + y.
 //
 func (x *Rational) Add(y *Rational) *Rational {
-	return MakeRat((x.a.MulNat(y.b)).Add(y.a.MulNat(x.b)), x.b.Mul(y.b));
+	return MakeRat((x.a.MulNat(y.b)).Add(y.a.MulNat(x.b)), x.b.Mul(y.b))
 }
 
 
 // Sub returns the difference x - y.
 //
 func (x *Rational) Sub(y *Rational) *Rational {
-	return MakeRat((x.a.MulNat(y.b)).Sub(y.a.MulNat(x.b)), x.b.Mul(y.b));
+	return MakeRat((x.a.MulNat(y.b)).Sub(y.a.MulNat(x.b)), x.b.Mul(y.b))
 }
 
 
@@ -103,7 +103,7 @@ func (x *Rational) Quo(y *Rational) *Rational {
 	a := x.a.MulNat(y.b);
 	b := y.a.MulNat(x.b);
 	if b.IsNeg() {
-		a = a.Neg();
+		a = a.Neg()
 	}
 	return MakeRat(a, b.mant);
 }
@@ -125,7 +125,7 @@ func (x *Rational) Cmp(y *Rational) int	{ return (x.a.MulNat(y.b)).Cmp(y.a.MulNa
 func (x *Rational) ToString(base uint) string {
 	s := x.a.ToString(base);
 	if !x.IsInt() {
-		s += "/" + x.b.ToString(base);
+		s += "/" + x.b.ToString(base)
 	}
 	return s;
 }
@@ -194,9 +194,9 @@ func RatFromString(s string, base uint) (*Rational, uint, int) {
 			rlen += elen;
 			m := Nat(10).Pow(uint(e.mant.Value()));
 			if e.sign {
-				b = b.Mul(m);
+				b = b.Mul(m)
 			} else {
-				a = a.MulNat(m);
+				a = a.MulNat(m)
 			}
 		}
 	}
diff --git a/src/pkg/bufio/bufio.go b/src/pkg/bufio/bufio.go
index c529f7d94d..ef36c7aec8 100644
--- a/src/pkg/bufio/bufio.go
+++ b/src/pkg/bufio/bufio.go
@@ -34,12 +34,12 @@ var (
 type BufSizeError int
 
 func (b BufSizeError) String() string {
-	return "bufio: bad buffer size " + strconv.Itoa(int(b));
+	return "bufio: bad buffer size " + strconv.Itoa(int(b))
 }
 
 func copySlice(dst []byte, src []byte) {
 	for i := 0; i < len(dst); i++ {
-		dst[i] = src[i];
+		dst[i] = src[i]
 	}
 }
 
@@ -61,12 +61,12 @@ type Reader struct {
 // It returns the Reader and any error.
 func NewReaderSize(rd io.Reader, size int) (*Reader, os.Error) {
 	if size <= 0 {
-		return nil, BufSizeError(size);
+		return nil, BufSizeError(size)
 	}
 	// Is it already a Reader?
 	b, ok := rd.(*Reader);
 	if ok && len(b.buf) >= size {
-		return b, nil;
+		return b, nil
 	}
 	b = new(Reader);
 	b.buf = make([]byte, size);
@@ -80,7 +80,7 @@ func NewReader(rd io.Reader) *Reader {
 	b, err := NewReaderSize(rd, defaultBufSize);
 	if err != nil {
 		// cannot happen - defaultBufSize is a valid size
-		panic("bufio: NewReader: ", err.String());
+		panic("bufio: NewReader: ", err.String())
 	}
 	return b;
 }
@@ -92,7 +92,7 @@ func (b *Reader) fill() {
 		copySlice(b.buf[0 : b.w - b.r], b.buf[b.r : b.w]);
 		b.w -= b.r;
 	} else {
-		b.w = 0;
+		b.w = 0
 	}
 	b.r = 0;
 
@@ -100,7 +100,7 @@ func (b *Reader) fill() {
 	n, e := b.rd.Read(b.buf[b.w : len(b.buf)]);
 	b.w += n;
 	if e != nil {
-		b.err = e;
+		b.err = e
 	}
 }
 
@@ -115,14 +115,14 @@ func (b *Reader) Read(p []byte) (nn int, err os.Error) {
 		n := len(p);
 		if b.w == b.r {
 			if b.err != nil {
-				return nn, b.err;
+				return nn, b.err
 			}
 			if len(p) >= len(b.buf) {
 				// Large read, empty buffer.
 				// Read directly into p to avoid copy.
 				n, b.err = b.rd.Read(p);
 				if n > 0 {
-					b.lastbyte = int(p[n-1]);
+					b.lastbyte = int(p[n-1])
 				}
 				p = p[n:len(p)];
 				nn += n;
@@ -132,7 +132,7 @@ func (b *Reader) Read(p []byte) (nn int, err os.Error) {
 			continue;
 		}
 		if n > b.w - b.r {
-			n = b.w - b.r;
+			n = b.w - b.r
 		}
 		copySlice(p[0:n], b.buf[b.r : b.r + n]);
 		p = p[n:len(p)];
@@ -148,7 +148,7 @@ func (b *Reader) Read(p []byte) (nn int, err os.Error) {
 func (b *Reader) ReadByte() (c byte, err os.Error) {
 	for b.w == b.r {
 		if b.err != nil {
-			return 0, b.err;
+			return 0, b.err
 		}
 		b.fill();
 	}
@@ -168,7 +168,7 @@ func (b *Reader) UnreadByte() os.Error {
 		return nil;
 	}
 	if b.r <= 0 {
-		return ErrInvalidUnreadByte;
+		return ErrInvalidUnreadByte
 	}
 	b.r--;
 	b.lastbyte = -1;
@@ -179,14 +179,14 @@ func (b *Reader) UnreadByte() os.Error {
 // rune and its size in bytes.
 func (b *Reader) ReadRune() (rune int, size int, err os.Error) {
 	for b.r + utf8.UTFMax > b.w && !utf8.FullRune(b.buf[b.r : b.w]) && b.err == nil {
-		b.fill();
+		b.fill()
 	}
 	if b.r == b.w {
-		return 0, 0, b.err;
+		return 0, 0, b.err
 	}
 	rune, size = int(b.buf[b.r]), 1;
 	if rune >= 0x80 {
-		rune, size = utf8.DecodeRune(b.buf[b.r : b.w]);
+		rune, size = utf8.DecodeRune(b.buf[b.r : b.w])
 	}
 	b.r += size;
 	b.lastbyte = int(b.buf[b.r - 1]);
@@ -198,7 +198,7 @@ func (b *Reader) ReadRune() (rune int, size int, err os.Error) {
 func findByte(p []byte, c byte) int {
 	for i := 0; i < len(p); i++ {
 		if p[i] == c {
-			return i;
+			return i
 		}
 	}
 	return -1;
@@ -245,7 +245,7 @@ func (b *Reader) ReadSlice(delim byte) (line []byte, err os.Error) {
 
 		// Buffer is full?
 		if b.Buffered() >= len(b.buf) {
-			return nil, ErrBufferFull;
+			return nil, ErrBufferFull
 		}
 	}
 	panic("not reached");
@@ -268,7 +268,7 @@ func (b *Reader) ReadBytes(delim byte) (line []byte, err os.Error) {
 		var e os.Error;
 		frag, e = b.ReadSlice(delim);
 		if e == nil {	// got final fragment
-			break;
+			break
 		}
 		if e != ErrBufferFull {	// unexpected error
 			err = e;
@@ -292,11 +292,11 @@ func (b *Reader) ReadBytes(delim byte) (line []byte, err os.Error) {
 
 		// Grow list if needed.
 		if full == nil {
-			full = make([][]byte, 16);
+			full = make([][]byte, 16)
 		} else if nfull >= len(full) {
 			newfull := make([][]byte, len(full)*2);
 			for i := 0; i < len(full); i++ {
-				newfull[i] = full[i];
+				newfull[i] = full[i]
 			}
 			full = newfull;
 		}
@@ -309,7 +309,7 @@ func (b *Reader) ReadBytes(delim byte) (line []byte, err os.Error) {
 	// Allocate new buffer to hold the full pieces and the fragment.
 	n := 0;
 	for i := 0; i < nfull; i++ {
-		n += len(full[i]);
+		n += len(full[i])
 	}
 	n += len(frag);
 
@@ -351,12 +351,12 @@ type Writer struct {
 // It returns the Writer and any error.
 func NewWriterSize(wr io.Writer, size int) (*Writer, os.Error) {
 	if size <= 0 {
-		return nil, BufSizeError(size);
+		return nil, BufSizeError(size)
 	}
 	// Is it already a Writer?
 	b, ok := wr.(*Writer);
 	if ok && len(b.buf) >= size {
-		return b, nil;
+		return b, nil
 	}
 	b = new(Writer);
 	b.buf = make([]byte, size);
@@ -369,7 +369,7 @@ func NewWriter(wr io.Writer) *Writer {
 	b, err := NewWriterSize(wr, defaultBufSize);
 	if err != nil {
 		// cannot happen - defaultBufSize is valid size
-		panic("bufio: NewWriter: ", err.String());
+		panic("bufio: NewWriter: ", err.String())
 	}
 	return b;
 }
@@ -377,15 +377,15 @@ func NewWriter(wr io.Writer) *Writer {
 // Flush writes any buffered data to the underlying io.Writer.
 func (b *Writer) Flush() os.Error {
 	if b.err != nil {
-		return b.err;
+		return b.err
 	}
 	n, e := b.wr.Write(b.buf[0 : b.n]);
 	if n < b.n && e == nil {
-		e = io.ErrShortWrite;
+		e = io.ErrShortWrite
 	}
 	if e != nil {
 		if n > 0 && n < b.n {
-			copySlice(b.buf[0 : b.n - n], b.buf[n : b.n]);
+			copySlice(b.buf[0 : b.n - n], b.buf[n : b.n])
 		}
 		b.n -= n;
 		b.err = e;
@@ -407,14 +407,14 @@ func (b *Writer) Buffered() int	{ return b.n }
 // why the write is short.
 func (b *Writer) Write(p []byte) (nn int, err os.Error) {
 	if b.err != nil {
-		return 0, b.err;
+		return 0, b.err
 	}
 	nn = 0;
 	for len(p) > 0 {
 		n := b.Available();
 		if n <= 0 {
 			if b.Flush(); b.err != nil {
-				break;
+				break
 			}
 			n = b.Available();
 		}
@@ -425,12 +425,12 @@ func (b *Writer) Write(p []byte) (nn int, err os.Error) {
 			nn += n;
 			p = p[n:len(p)];
 			if b.err != nil {
-				break;
+				break
 			}
 			continue;
 		}
 		if n > len(p) {
-			n = len(p);
+			n = len(p)
 		}
 		copySlice(b.buf[b.n : b.n + n], p[0:n]);
 		b.n += n;
@@ -443,10 +443,10 @@ func (b *Writer) Write(p []byte) (nn int, err os.Error) {
 // WriteByte writes a single byte.
 func (b *Writer) WriteByte(c byte) os.Error {
 	if b.err != nil {
-		return b.err;
+		return b.err
 	}
 	if b.Available() <= 0 && b.Flush() != nil {
-		return b.err;
+		return b.err
 	}
 	b.buf[b.n] = c;
 	b.n++;
@@ -456,7 +456,7 @@ func (b *Writer) WriteByte(c byte) os.Error {
 // WriteString writes a string.
 func (b *Writer) WriteString(s string) os.Error {
 	if b.err != nil {
-		return b.err;
+		return b.err
 	}
 	// Common case, worth making fast.
 	if b.Available() >= len(s) || len(b.buf) >= len(s) && b.Flush() == nil {
@@ -467,7 +467,7 @@ func (b *Writer) WriteString(s string) os.Error {
 		return nil;
 	}
 	for i := 0; i < len(s); i++ {	// loop over bytes, not runes.
-		b.WriteByte(s[i]);
+		b.WriteByte(s[i])
 	}
 	return b.err;
 }
@@ -483,5 +483,5 @@ type ReadWriter struct {
 
 // NewReadWriter allocates a new ReadWriter that dispatches to r and w.
 func NewReadWriter(r *Reader, w *Writer) *ReadWriter {
-	return &ReadWriter{r, w};
+	return &ReadWriter{r, w}
 }
diff --git a/src/pkg/bufio/bufio_test.go b/src/pkg/bufio/bufio_test.go
index 545ed7e94d..cc24dbfe0c 100644
--- a/src/pkg/bufio/bufio_test.go
+++ b/src/pkg/bufio/bufio_test.go
@@ -28,14 +28,14 @@ func newRot13Reader(r io.Reader) *rot13Reader {
 func (r13 *rot13Reader) Read(p []byte) (int, os.Error) {
 	n, e := r13.r.Read(p);
 	if e != nil {
-		return n, e;
+		return n, e
 	}
 	for i := 0; i < n; i++ {
 		c := p[i]|0x20;	// lowercase byte
 		if 'a' <= c && c <= 'm' {
-			p[i] += 13;
+			p[i] += 13
 		} else if 'n' <= c && c <= 'z' {
-			p[i] -= 13;
+			p[i] -= 13
 		}
 	}
 	return n, nil;
@@ -48,10 +48,10 @@ func readBytes(buf *Reader) string {
 	for {
 		c, e := buf.ReadByte();
 		if e == os.EOF {
-			break;
+			break
 		}
 		if e != nil {
-			panic("Data: " + e.String());
+			panic("Data: " + e.String())
 		}
 		b[nb] = c;
 		nb++;
@@ -63,12 +63,12 @@ func TestReaderSimple(t *testing.T) {
 	data := "hello world";
 	b := NewReader(bytes.NewBufferString(data));
 	if s := readBytes(b); s != "hello world" {
-		t.Errorf("simple hello world test failed: got %q", s);
+		t.Errorf("simple hello world test failed: got %q", s)
 	}
 
 	b = NewReader(newRot13Reader(bytes.NewBufferString(data)));
 	if s := readBytes(b); s != "uryyb jbeyq" {
-		t.Error("rot13 hello world test failed: got %q", s);
+		t.Error("rot13 hello world test failed: got %q", s)
 	}
 }
 
@@ -92,10 +92,10 @@ func readLines(b *Reader) string {
 	for {
 		s1, e := b.ReadString('\n');
 		if e == os.EOF {
-			break;
+			break
 		}
 		if e != nil {
-			panic("GetLines: " + e.String());
+			panic("GetLines: " + e.String())
 		}
 		s += s1;
 	}
@@ -110,7 +110,7 @@ func reads(buf *Reader, m int) string {
 		n, e := buf.Read(b[nb : nb+m]);
 		nb += n;
 		if e == os.EOF {
-			break;
+			break
 		}
 	}
 	return string(b[0:nb]);
@@ -161,7 +161,7 @@ func TestReader(t *testing.T) {
 					s := bufreader.fn(buf);
 					if s != text {
 						t.Errorf("reader=%s fn=%s bufsize=%d want=%q got=%q",
-							readmaker.name, bufreader.name, bufsize, text, s);
+							readmaker.name, bufreader.name, bufsize, text, s)
 					}
 				}
 			}
@@ -179,12 +179,12 @@ func (r *StringReader) Read(p []byte) (n int, err os.Error) {
 	if r.step < len(r.data) {
 		s := r.data[r.step];
 		for i := 0; i < len(s); i++ {
-			p[i] = s[i];
+			p[i] = s[i]
 		}
 		n = len(s);
 		r.step++;
 	} else {
-		err = os.EOF;
+		err = os.EOF
 	}
 	return;
 }
@@ -197,14 +197,14 @@ func readRuneSegments(t *testing.T, segments []string) {
 		rune, _, err := r.ReadRune();
 		if err != nil {
 			if err != os.EOF {
-				return;
+				return
 			}
 			break;
 		}
 		got += string(rune);
 	}
 	if got != want {
-		t.Errorf("segments=%v got=%s want=%s", segments, got, want);
+		t.Errorf("segments=%v got=%s want=%s", segments, got, want)
 	}
 }
 
@@ -221,7 +221,7 @@ var segmentList = [][]string{
 
 func TestReadRune(t *testing.T) {
 	for _, s := range segmentList {
-		readRuneSegments(t, s);
+		readRuneSegments(t, s)
 	}
 }
 
@@ -229,7 +229,7 @@ func TestWriter(t *testing.T) {
 	var data [8192]byte;
 
 	for i := 0; i < len(data); i++ {
-		data[i] = byte(' ' + i%('~'-' '));
+		data[i] = byte(' ' + i%('~'-' '))
 	}
 	w := new(bytes.Buffer);
 	for i := 0; i < len(bufsizes); i++ {
@@ -254,12 +254,12 @@ func TestWriter(t *testing.T) {
 				continue;
 			}
 			if e = buf.Flush(); e != nil {
-				t.Errorf("%s: buf.Flush = %v", context, e);
+				t.Errorf("%s: buf.Flush = %v", context, e)
 			}
 
 			written := w.Bytes();
 			if len(written) != nwrite {
-				t.Errorf("%s: %d bytes written", context, len(written));
+				t.Errorf("%s: %d bytes written", context, len(written))
 			}
 			for l := 0; l < len(written); l++ {
 				if written[i] != data[i] {
@@ -281,7 +281,7 @@ type errorWriterTest struct {
 }
 
 func (w errorWriterTest) Write(p []byte) (int, os.Error) {
-	return len(p) * w.n / w.m, w.err;
+	return len(p) * w.n / w.m, w.err
 }
 
 var errorWriterTests = []errorWriterTest{
@@ -303,7 +303,7 @@ func TestWriteErrors(t *testing.T) {
 		}
 		e = buf.Flush();
 		if e != w.expect {
-			t.Errorf("Flush %v: got %v, wanted %v", w, e, w.expect);
+			t.Errorf("Flush %v: got %v, wanted %v", w, e, w.expect)
 		}
 	}
 }
@@ -312,23 +312,23 @@ func TestNewReaderSizeIdempotent(t *testing.T) {
 	const BufSize = 1000;
 	b, err := NewReaderSize(bytes.NewBufferString("hello world"), BufSize);
 	if err != nil {
-		t.Error("NewReaderSize create fail", err);
+		t.Error("NewReaderSize create fail", err)
 	}
 	// Does it recognize itself?
 	b1, err2 := NewReaderSize(b, BufSize);
 	if err2 != nil {
-		t.Error("NewReaderSize #2 create fail", err2);
+		t.Error("NewReaderSize #2 create fail", err2)
 	}
 	if b1 != b {
-		t.Error("NewReaderSize did not detect underlying Reader");
+		t.Error("NewReaderSize did not detect underlying Reader")
 	}
 	// Does it wrap if existing buffer is too small?
 	b2, err3 := NewReaderSize(b, 2*BufSize);
 	if err3 != nil {
-		t.Error("NewReaderSize #3 create fail", err3);
+		t.Error("NewReaderSize #3 create fail", err3)
 	}
 	if b2 == b {
-		t.Error("NewReaderSize did not enlarge buffer");
+		t.Error("NewReaderSize did not enlarge buffer")
 	}
 }
 
@@ -336,23 +336,23 @@ func TestNewWriterSizeIdempotent(t *testing.T) {
 	const BufSize = 1000;
 	b, err := NewWriterSize(new(bytes.Buffer), BufSize);
 	if err != nil {
-		t.Error("NewWriterSize create fail", err);
+		t.Error("NewWriterSize create fail", err)
 	}
 	// Does it recognize itself?
 	b1, err2 := NewWriterSize(b, BufSize);
 	if err2 != nil {
-		t.Error("NewWriterSize #2 create fail", err2);
+		t.Error("NewWriterSize #2 create fail", err2)
 	}
 	if b1 != b {
-		t.Error("NewWriterSize did not detect underlying Writer");
+		t.Error("NewWriterSize did not detect underlying Writer")
 	}
 	// Does it wrap if existing buffer is too small?
 	b2, err3 := NewWriterSize(b, 2*BufSize);
 	if err3 != nil {
-		t.Error("NewWriterSize #3 create fail", err3);
+		t.Error("NewWriterSize #3 create fail", err3)
 	}
 	if b2 == b {
-		t.Error("NewWriterSize did not enlarge buffer");
+		t.Error("NewWriterSize did not enlarge buffer")
 	}
 }
 
@@ -361,7 +361,7 @@ func TestWriteString(t *testing.T) {
 	buf := new(bytes.Buffer);
 	b, err := NewWriterSize(buf, BufSize);
 	if err != nil {
-		t.Error("NewWriterSize create fail", err);
+		t.Error("NewWriterSize create fail", err)
 	}
 	b.WriteString("0");				// easy
 	b.WriteString("123456");			// still easy
@@ -370,10 +370,10 @@ func TestWriteString(t *testing.T) {
 	b.WriteString("z");
 	b.Flush();
 	if b.err != nil {
-		t.Error("WriteString", b.err);
+		t.Error("WriteString", b.err)
 	}
 	s := "01234567890abcdefghijklmnopqrstuvwxyz";
 	if string(buf.Bytes()) != s {
-		t.Errorf("WriteString wants %q gets %q", s, string(buf.Bytes()));
+		t.Errorf("WriteString wants %q gets %q", s, string(buf.Bytes()))
 	}
 }
diff --git a/src/pkg/bytes/buffer.go b/src/pkg/bytes/buffer.go
index a448dff845..eed8f6b681 100644
--- a/src/pkg/bytes/buffer.go
+++ b/src/pkg/bytes/buffer.go
@@ -44,7 +44,7 @@ func (b *Buffer) Bytes() []byte	{ return b.buf[b.off : len(b.buf)] }
 func (b *Buffer) String() string {
 	if b == nil {
 		// Special case, useful in debugging.
-		return "<nil>";
+		return "<nil>"
 	}
 	return string(b.buf[b.off : len(b.buf)]);
 }
@@ -58,7 +58,7 @@ func (b *Buffer) Len() int	{ return len(b.buf) - b.off }
 func (b *Buffer) Truncate(n int) {
 	if n == 0 {
 		// Reuse buffer space.
-		b.off = 0;
+		b.off = 0
 	}
 	b.buf = b.buf[0 : b.off + n];
 }
@@ -78,7 +78,7 @@ func (b *Buffer) Write(p []byte) (n int, err os.Error) {
 		buf := b.buf;
 		if m+n > cap(b.buf) {
 			// not enough space anywhere
-			buf = make([]byte, 2*cap(b.buf) + n);
+			buf = make([]byte, 2*cap(b.buf) + n)
 		}
 		copyBytes(buf, 0, b.buf[b.off : b.off + m]);
 		b.buf = buf;
@@ -101,7 +101,7 @@ func (b *Buffer) WriteString(s string) (n int, err os.Error) {
 		buf := b.buf;
 		if m+n > cap(b.buf) {
 			// not enough space anywhere
-			buf = make([]byte, 2*cap(b.buf) + n);
+			buf = make([]byte, 2*cap(b.buf) + n)
 		}
 		copyBytes(buf, 0, b.buf[b.off : b.off + m]);
 		b.buf = buf;
@@ -119,7 +119,7 @@ func (b *Buffer) WriteString(s string) (n int, err os.Error) {
 func (b *Buffer) WriteByte(c byte) os.Error {
 	if b.oneByte == nil {
 		// Only happens once per Buffer, and then we have a slice.
-		b.oneByte = make([]byte, 1);
+		b.oneByte = make([]byte, 1)
 	}
 	b.oneByte[0] = c;
 	b.Write(b.oneByte);
@@ -132,14 +132,14 @@ func (b *Buffer) WriteByte(c byte) os.Error {
 // otherwise it is nil.
 func (b *Buffer) Read(p []byte) (n int, err os.Error) {
 	if b.off >= len(b.buf) {
-		return 0, os.EOF;
+		return 0, os.EOF
 	}
 	m := b.Len();
 	n = len(p);
 
 	if n > m {
 		// more bytes requested than available
-		n = m;
+		n = m
 	}
 
 	copyBytes(p, 0, b.buf[b.off : b.off + n]);
@@ -151,7 +151,7 @@ func (b *Buffer) Read(p []byte) (n int, err os.Error) {
 // If no byte is available, it returns error os.EOF.
 func (b *Buffer) ReadByte() (c byte, err os.Error) {
 	if b.off >= len(b.buf) {
-		return 0, os.EOF;
+		return 0, os.EOF
 	}
 	c = b.buf[b.off];
 	b.off++;
diff --git a/src/pkg/bytes/buffer_test.go b/src/pkg/bytes/buffer_test.go
index c364eece4f..f566183be7 100644
--- a/src/pkg/bytes/buffer_test.go
+++ b/src/pkg/bytes/buffer_test.go
@@ -19,7 +19,7 @@ var bytes []byte	// test data; same as data but as a slice.
 func init() {
 	bytes = make([]byte, N);
 	for i := 0; i < N; i++ {
-		bytes[i] = 'a'+byte(i%26);
+		bytes[i] = 'a'+byte(i%26)
 	}
 	data = string(bytes);
 }
@@ -29,19 +29,19 @@ func check(t *testing.T, testname string, buf *Buffer, s string) {
 	bytes := buf.Bytes();
 	str := buf.String();
 	if buf.Len() != len(bytes) {
-		t.Errorf("%s: buf.Len() == %d, len(buf.Bytes()) == %d\n", testname, buf.Len(), len(bytes));
+		t.Errorf("%s: buf.Len() == %d, len(buf.Bytes()) == %d\n", testname, buf.Len(), len(bytes))
 	}
 
 	if buf.Len() != len(str) {
-		t.Errorf("%s: buf.Len() == %d, len(buf.String()) == %d\n", testname, buf.Len(), len(str));
+		t.Errorf("%s: buf.Len() == %d, len(buf.String()) == %d\n", testname, buf.Len(), len(str))
 	}
 
 	if buf.Len() != len(s) {
-		t.Errorf("%s: buf.Len() == %d, len(s) == %d\n", testname, buf.Len(), len(s));
+		t.Errorf("%s: buf.Len() == %d, len(s) == %d\n", testname, buf.Len(), len(s))
 	}
 
 	if string(bytes) != s {
-		t.Errorf("%s: string(buf.Bytes()) == %q, s == %q\n", testname, string(bytes), s);
+		t.Errorf("%s: string(buf.Bytes()) == %q, s == %q\n", testname, string(bytes), s)
 	}
 }
 
@@ -54,10 +54,10 @@ func fillString(t *testing.T, testname string, buf *Buffer, s string, n int, fus
 	for ; n > 0; n-- {
 		m, err := buf.WriteString(fus);
 		if m != len(fus) {
-			t.Errorf(testname + " (fill 2): m == %d, expected %d\n", m, len(fus));
+			t.Errorf(testname + " (fill 2): m == %d, expected %d\n", m, len(fus))
 		}
 		if err != nil {
-			t.Errorf(testname + " (fill 3): err should always be nil, found err == %s\n", err);
+			t.Errorf(testname + " (fill 3): err should always be nil, found err == %s\n", err)
 		}
 		s += fus;
 		check(t, testname + " (fill 4)", buf, s);
@@ -74,10 +74,10 @@ func fillBytes(t *testing.T, testname string, buf *Buffer, s string, n int, fub
 	for ; n > 0; n-- {
 		m, err := buf.Write(fub);
 		if m != len(fub) {
-			t.Errorf(testname + " (fill 2): m == %d, expected %d\n", m, len(fub));
+			t.Errorf(testname + " (fill 2): m == %d, expected %d\n", m, len(fub))
 		}
 		if err != nil {
-			t.Errorf(testname + " (fill 3): err should always be nil, found err == %s\n", err);
+			t.Errorf(testname + " (fill 3): err should always be nil, found err == %s\n", err)
 		}
 		s += string(fub);
 		check(t, testname + " (fill 4)", buf, s);
@@ -106,10 +106,10 @@ func empty(t *testing.T, testname string, buf *Buffer, s string, fub []byte) {
 	for {
 		n, err := buf.Read(fub);
 		if n == 0 {
-			break;
+			break
 		}
 		if err != nil {
-			t.Errorf(testname + " (empty 2): err should always be nil, found err == %s\n", err);
+			t.Errorf(testname + " (empty 2): err should always be nil, found err == %s\n", err)
 		}
 		s = s[n:len(s)];
 		check(t, testname + " (empty 3)", buf, s);
@@ -133,10 +133,10 @@ func TestBasicOperations(t *testing.T) {
 
 		n, err := buf.Write(Bytes(data[0:1]));
 		if n != 1 {
-			t.Errorf("wrote 1 byte, but n == %d\n", n);
+			t.Errorf("wrote 1 byte, but n == %d\n", n)
 		}
 		if err != nil {
-			t.Errorf("err should always be nil, but err == %s\n", err);
+			t.Errorf("err should always be nil, but err == %s\n", err)
 		}
 		check(t, "TestBasicOperations (4)", &buf, "a");
 
@@ -145,7 +145,7 @@ func TestBasicOperations(t *testing.T) {
 
 		n, err = buf.Write(Bytes(data[2:26]));
 		if n != 24 {
-			t.Errorf("wrote 25 bytes, but n == %d\n", n);
+			t.Errorf("wrote 25 bytes, but n == %d\n", n)
 		}
 		check(t, "TestBasicOperations (6)", &buf, string(data[0:26]));
 
@@ -161,14 +161,14 @@ func TestBasicOperations(t *testing.T) {
 		buf.WriteByte(data[1]);
 		c, err := buf.ReadByte();
 		if err != nil {
-			t.Errorf("ReadByte unexpected eof\n");
+			t.Errorf("ReadByte unexpected eof\n")
 		}
 		if c != data[1] {
-			t.Errorf("ReadByte wrong value c=%v\n", c);
+			t.Errorf("ReadByte wrong value c=%v\n", c)
 		}
 		c, err = buf.ReadByte();
 		if err == nil {
-			t.Errorf("ReadByte unexpected not eof\n");
+			t.Errorf("ReadByte unexpected not eof\n")
 		}
 	}
 }
@@ -220,9 +220,9 @@ func TestMixedReadsAndWrites(t *testing.T) {
 	for i := 0; i < 50; i++ {
 		wlen := rand.Intn(len(data));
 		if i%2 == 0 {
-			s = fillString(t, "TestMixedReadsAndWrites (1)", &buf, s, 1, data[0:wlen]);
+			s = fillString(t, "TestMixedReadsAndWrites (1)", &buf, s, 1, data[0:wlen])
 		} else {
-			s = fillBytes(t, "TestMixedReadsAndWrites (1)", &buf, s, 1, bytes[0:wlen]);
+			s = fillBytes(t, "TestMixedReadsAndWrites (1)", &buf, s, 1, bytes[0:wlen])
 		}
 
 		rlen := rand.Intn(len(data));
@@ -237,6 +237,6 @@ func TestMixedReadsAndWrites(t *testing.T) {
 func TestNil(t *testing.T) {
 	var b *Buffer;
 	if b.String() != "<nil>" {
-		t.Error("expcted <nil>; got %q", b.String());
+		t.Error("expcted <nil>; got %q", b.String())
 	}
 }
diff --git a/src/pkg/bytes/bytes.go b/src/pkg/bytes/bytes.go
index 3ebc8373ab..db964f6dae 100644
--- a/src/pkg/bytes/bytes.go
+++ b/src/pkg/bytes/bytes.go
@@ -17,16 +17,16 @@ func Compare(a, b []byte) int {
 	for i := 0; i < len(a) && i < len(b); i++ {
 		switch {
 		case a[i] > b[i]:
-			return 1;
+			return 1
 		case a[i] < b[i]:
-			return -1;
+			return -1
 		}
 	}
 	switch {
 	case len(a) < len(b):
-		return -1;
+		return -1
 	case len(a) > len(b):
-		return 1;
+		return 1
 	}
 	return 0;
 }
@@ -34,11 +34,11 @@ func Compare(a, b []byte) int {
 // Equal returns a boolean reporting whether a == b.
 func Equal(a, b []byte) bool {
 	if len(a) != len(b) {
-		return false;
+		return false
 	}
 	for i := 0; i < len(a); i++ {
 		if a[i] != b[i] {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -50,10 +50,10 @@ func Equal(a, b []byte) bool {
 // It returns the number of bytes copied.
 func Copy(dst, src []byte) int {
 	if len(src) > len(dst) {
-		src = src[0:len(dst)];
+		src = src[0:len(dst)]
 	}
 	for i, x := range src {
-		dst[i] = x;
+		dst[i] = x
 	}
 	return len(src);
 }
@@ -62,7 +62,7 @@ func Copy(dst, src []byte) int {
 // up to a maximum of n byte arrays. Invalid UTF-8 sequences are chopped into individual bytes.
 func explode(s []byte, n int) [][]byte {
 	if n <= 0 {
-		n = len(s);
+		n = len(s)
 	}
 	a := make([][]byte, n);
 	var size int;
@@ -84,7 +84,7 @@ func explode(s []byte, n int) [][]byte {
 // Count counts the number of non-overlapping instances of sep in s.
 func Count(s, sep []byte) int {
 	if len(sep) == 0 {
-		return utf8.RuneCount(s) + 1;
+		return utf8.RuneCount(s) + 1
 	}
 	c := sep[0];
 	n := 0;
@@ -101,12 +101,12 @@ func Count(s, sep []byte) int {
 func Index(s, sep []byte) int {
 	n := len(sep);
 	if n == 0 {
-		return 0;
+		return 0
 	}
 	c := sep[0];
 	for i := 0; i+n <= len(s); i++ {
 		if s[i] == c && (n == 1 || Equal(s[i : i+n], sep)) {
-			return i;
+			return i
 		}
 	}
 	return -1;
@@ -116,12 +116,12 @@ func Index(s, sep []byte) int {
 func LastIndex(s, sep []byte) int {
 	n := len(sep);
 	if n == 0 {
-		return len(s);
+		return len(s)
 	}
 	c := sep[0];
 	for i := len(s)-n; i >= 0; i-- {
 		if s[i] == c && (n == 1 || Equal(s[i : i+n], sep)) {
-			return i;
+			return i
 		}
 	}
 	return -1;
@@ -131,10 +131,10 @@ func LastIndex(s, sep []byte) int {
 // including sepSave bytes of sep in the subarrays.
 func genSplit(s, sep []byte, sepSave, n int) [][]byte {
 	if len(sep) == 0 {
-		return explode(s, n);
+		return explode(s, n)
 	}
 	if n <= 0 {
-		n = Count(s, sep) + 1;
+		n = Count(s, sep) + 1
 	}
 	c := sep[0];
 	start := 0;
@@ -162,21 +162,21 @@ func Split(s, sep []byte, n int) [][]byte	{ return genSplit(s, sep, 0, n) }
 // If n > 0, SplitAfter splits s into at most n subarrays; the last subarray will contain an
 // unsplit remainder.
 func SplitAfter(s, sep []byte, n int) [][]byte {
-	return genSplit(s, sep, len(sep), n);
+	return genSplit(s, sep, len(sep), n)
 }
 
 // Join concatenates the elements of a to create a single byte array.   The separator
 // sep is placed between elements in the resulting array.
 func Join(a [][]byte, sep []byte) []byte {
 	if len(a) == 0 {
-		return []byte{};
+		return []byte{}
 	}
 	if len(a) == 1 {
-		return a[0];
+		return a[0]
 	}
 	n := len(sep)*(len(a)-1);
 	for i := 0; i < len(a); i++ {
-		n += len(a[i]);
+		n += len(a[i])
 	}
 
 	b := make([]byte, n);
@@ -200,12 +200,12 @@ func Join(a [][]byte, sep []byte) []byte {
 
 // HasPrefix tests whether the byte array s begins with prefix.
 func HasPrefix(s, prefix []byte) bool {
-	return len(s) >= len(prefix) && Equal(s[0:len(prefix)], prefix);
+	return len(s) >= len(prefix) && Equal(s[0:len(prefix)], prefix)
 }
 
 // HasSuffix tests whether the byte array s ends with suffix.
 func HasSuffix(s, suffix []byte) bool {
-	return len(s) >= len(suffix) && Equal(s[len(s)-len(suffix) : len(s)], suffix);
+	return len(s) >= len(suffix) && Equal(s[len(s)-len(suffix) : len(s)], suffix)
 }
 
 // Map returns a copy of the byte array s with all its characters modified
@@ -221,9 +221,9 @@ func Map(mapping func(rune int) int, s []byte) []byte {
 		wid := 1;
 		rune := int(s[i]);
 		if rune < utf8.RuneSelf {
-			rune = mapping(rune);
+			rune = mapping(rune)
 		} else {
-			rune, wid = utf8.DecodeRune(s[i:len(s)]);
+			rune, wid = utf8.DecodeRune(s[i:len(s)])
 		}
 		rune = mapping(rune);
 		if nbytes + utf8.RuneLen(rune) > maxbytes {
@@ -231,7 +231,7 @@ func Map(mapping func(rune int) int, s []byte) []byte {
 			maxbytes = maxbytes*2 + utf8.UTFMax;
 			nb := make([]byte, maxbytes);
 			for i, c := range b[0:nbytes] {
-				nb[i] = c;
+				nb[i] = c
 			}
 			b = nb;
 		}
@@ -258,10 +258,10 @@ func TrimSpace(s []byte) []byte {
 		wid := 1;
 		rune := int(s[start]);
 		if rune >= utf8.RuneSelf {
-			rune, wid = utf8.DecodeRune(s[start:end]);
+			rune, wid = utf8.DecodeRune(s[start:end])
 		}
 		if !unicode.IsSpace(rune) {
-			break;
+			break
 		}
 		start += wid;
 	}
@@ -273,12 +273,12 @@ func TrimSpace(s []byte) []byte {
 			for wid = 2; start <= end-wid && !utf8.RuneStart(s[end-wid]); wid++ {
 			}
 			if start > end-wid {	// invalid UTF-8 sequence; stop processing
-				return s[start:end];
+				return s[start:end]
 			}
 			rune, wid = utf8.DecodeRune(s[end-wid : end]);
 		}
 		if !unicode.IsSpace(rune) {
-			break;
+			break
 		}
 		end -= wid;
 	}
@@ -289,7 +289,7 @@ func TrimSpace(s []byte) []byte {
 // Heuristic: Scale by 50% to give n log n time.
 func resize(n int) int {
 	if n < 16 {
-		n = 16;
+		n = 16
 	}
 	return n + n/2;
 }
@@ -301,7 +301,7 @@ func Add(s, t []byte) []byte {
 	lens := len(s);
 	lent := len(t);
 	if lens+lent <= cap(s) {
-		s = s[0 : lens+lent];
+		s = s[0 : lens+lent]
 	} else {
 		news := make([]byte, lens+lent, resize(lens+lent));
 		Copy(news, s);
@@ -317,7 +317,7 @@ func Add(s, t []byte) []byte {
 func AddByte(s []byte, t byte) []byte {
 	lens := len(s);
 	if lens+1 <= cap(s) {
-		s = s[0 : lens+1];
+		s = s[0 : lens+1]
 	} else {
 		news := make([]byte, lens+1, resize(lens+1));
 		Copy(news, s);
diff --git a/src/pkg/bytes/bytes_test.go b/src/pkg/bytes/bytes_test.go
index b00de1b0cd..47e5964d1a 100644
--- a/src/pkg/bytes/bytes_test.go
+++ b/src/pkg/bytes/bytes_test.go
@@ -13,11 +13,11 @@ import (
 
 func eq(a, b []string) bool {
 	if len(a) != len(b) {
-		return false;
+		return false
 	}
 	for i := 0; i < len(a); i++ {
 		if a[i] != b[i] {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -26,7 +26,7 @@ func eq(a, b []string) bool {
 func arrayOfString(a [][]byte) []string {
 	result := make([]string, len(a));
 	for j := 0; j < len(a); j++ {
-		result[j] = string(a[j]);
+		result[j] = string(a[j])
 	}
 	return result;
 }
@@ -66,10 +66,10 @@ func TestCompare(t *testing.T) {
 		cmp := Compare(a, b);
 		eql := Equal(a, b);
 		if cmp != tt.cmp {
-			t.Errorf(`Compare(%q, %q) = %v`, tt.a, tt.b, cmp);
+			t.Errorf(`Compare(%q, %q) = %v`, tt.a, tt.b, cmp)
 		}
 		if eql != (tt.cmp == 0) {
-			t.Errorf(`Equal(%q, %q) = %v`, tt.a, tt.b, eql);
+			t.Errorf(`Equal(%q, %q) = %v`, tt.a, tt.b, eql)
 		}
 	}
 }
@@ -97,7 +97,7 @@ func TestExplode(t *testing.T) {
 		}
 		s := Join(a, []byte{});
 		if string(s) != tt.s {
-			t.Errorf(`Join(Explode("%s", %d), "") = "%s"`, tt.s, tt.n, s);
+			t.Errorf(`Join(Explode("%s", %d), "") = "%s"`, tt.s, tt.n, s)
 		}
 	}
 }
@@ -136,7 +136,7 @@ func TestSplit(t *testing.T) {
 		}
 		s := Join(a, strings.Bytes(tt.sep));
 		if string(s) != tt.s {
-			t.Errorf(`Join(Split(%q, %q, %d), %q) = %q`, tt.s, tt.sep, tt.n, tt.sep, s);
+			t.Errorf(`Join(Split(%q, %q, %d), %q) = %q`, tt.s, tt.sep, tt.n, tt.sep, s)
 		}
 	}
 }
@@ -167,7 +167,7 @@ func TestSplitAfter(t *testing.T) {
 		}
 		s := Join(a, nil);
 		if string(s) != tt.s {
-			t.Errorf(`Join(Split(%q, %q, %d), %q) = %q`, tt.s, tt.sep, tt.n, tt.sep, s);
+			t.Errorf(`Join(Split(%q, %q, %d), %q) = %q`, tt.s, tt.sep, tt.n, tt.sep, s)
 		}
 	}
 }
@@ -244,7 +244,7 @@ var trimSpaceTests = []StringTest{
 func Bytes(s string) []byte {
 	b := make([]byte, len(s));
 	for i := 0; i < len(s); i++ {
-		b[i] = s[i];
+		b[i] = s[i]
 	}
 	return b;
 }
@@ -255,7 +255,7 @@ func runStringTests(t *testing.T, f func([]byte) []byte, funcName string, testCa
 	for _, tc := range testCases {
 		actual := string(f(Bytes(tc.in)));
 		if actual != tc.out {
-			t.Errorf("%s(%q) = %q; want %q", funcName, tc.in, actual, tc.out);
+			t.Errorf("%s(%q) = %q; want %q", funcName, tc.in, actual, tc.out)
 		}
 	}
 }
@@ -263,7 +263,7 @@ func runStringTests(t *testing.T, f func([]byte) []byte, funcName string, testCa
 func tenRunes(rune int) string {
 	r := make([]int, 10);
 	for i := range r {
-		r[i] = rune;
+		r[i] = rune
 	}
 	return string(r);
 }
@@ -276,14 +276,14 @@ func TestMap(t *testing.T) {
 	m := Map(maxRune, Bytes(a));
 	expect := tenRunes(unicode.MaxRune);
 	if string(m) != expect {
-		t.Errorf("growing: expected %q got %q", expect, m);
+		t.Errorf("growing: expected %q got %q", expect, m)
 	}
 	// 2. Shrink
 	minRune := func(rune int) int { return 'a' };
 	m = Map(minRune, Bytes(tenRunes(unicode.MaxRune)));
 	expect = a;
 	if string(m) != expect {
-		t.Errorf("shrinking: expected %q got %q", expect, m);
+		t.Errorf("shrinking: expected %q got %q", expect, m)
 	}
 }
 
@@ -309,11 +309,11 @@ func TestAdd(t *testing.T) {
 	for _, test := range addtests {
 		b := make([]byte, len(test.s), test.cap);
 		for i := 0; i < len(test.s); i++ {
-			b[i] = test.s[i];
+			b[i] = test.s[i]
 		}
 		b = Add(b, strings.Bytes(test.t));
 		if string(b) != test.s + test.t {
-			t.Errorf("Add(%q,%q) = %q", test.s, test.t, string(b));
+			t.Errorf("Add(%q,%q) = %q", test.s, test.t, string(b))
 		}
 	}
 }
@@ -322,14 +322,14 @@ func TestAddByte(t *testing.T) {
 	const N = 2e5;
 	b := make([]byte, 0);
 	for i := 0; i < N; i++ {
-		b = AddByte(b, byte(i));
+		b = AddByte(b, byte(i))
 	}
 	if len(b) != N {
-		t.Errorf("AddByte: too small; expected %d got %d", N, len(b));
+		t.Errorf("AddByte: too small; expected %d got %d", N, len(b))
 	}
 	for i, c := range b {
 		if c != byte(i) {
-			t.Fatalf("AddByte: b[%d] should be %d is %d", i, c, byte(i));
+			t.Fatalf("AddByte: b[%d] should be %d is %d", i, c, byte(i))
 		}
 	}
 }
diff --git a/src/pkg/compress/flate/deflate.go b/src/pkg/compress/flate/deflate.go
index 79b8ec3ba4..4b6726e304 100644
--- a/src/pkg/compress/flate/deflate.go
+++ b/src/pkg/compress/flate/deflate.go
@@ -132,15 +132,15 @@ func (d *deflater) fillWindow(index int) (int, os.Error) {
 		index -= wSize;
 		d.windowEnd -= wSize;
 		if d.blockStart >= wSize {
-			d.blockStart -= wSize;
+			d.blockStart -= wSize
 		} else {
-			d.blockStart = math.MaxInt32;
+			d.blockStart = math.MaxInt32
 		}
 		for i, h := range d.hashHead {
-			d.hashHead[i] = max(h-wSize, -1);
+			d.hashHead[i] = max(h-wSize, -1)
 		}
 		for i, h := range d.hashPrev {
-			d.hashPrev[i] = max(h-wSize, -1);
+			d.hashPrev[i] = max(h-wSize, -1)
 		}
 	}
 	var count int;
@@ -148,7 +148,7 @@ func (d *deflater) fillWindow(index int) (int, os.Error) {
 	count, err = io.ReadAtLeast(d.r, d.window[d.windowEnd : len(d.window)], 1);
 	d.windowEnd += count;
 	if err == os.EOF {
-		return index, nil;
+		return index, nil
 	}
 	return index, err;
 }
@@ -157,7 +157,7 @@ func (d *deflater) writeBlock(tokens []token, index int, eof bool) os.Error {
 	if index > 0 || eof {
 		var window []byte;
 		if d.blockStart <= index {
-			window = d.window[d.blockStart : index];
+			window = d.window[d.blockStart : index]
 		}
 		d.blockStart = index;
 		d.w.writeBlock(tokens, eof, window);
@@ -178,7 +178,7 @@ func (d *deflater) findMatch(pos int, prevHead int, prevLength int, lookahead in
 	tries := d.maxChainLength;
 	length = prevLength;
 	if length >= d.goodMatch {
-		tries >>= 2;
+		tries >>= 2
 	}
 
 	w0 := win[pos];
@@ -192,7 +192,7 @@ func (d *deflater) findMatch(pos int, prevHead int, prevLength int, lookahead in
 
 			n := 3;
 			for pos+n < len(win) && win[i+n] == win[pos+n] {
-				n++;
+				n++
 			}
 			if n > length && (n > 3 || pos-i <= 4096) {
 				length = n;
@@ -200,17 +200,17 @@ func (d *deflater) findMatch(pos int, prevHead int, prevLength int, lookahead in
 				ok = true;
 				if n >= nice {
 					// The match is good enough that we don't try to find a better one.
-					break;
+					break
 				}
 				wEnd = win[pos+n];
 			}
 		}
 		if i == minIndex {
 			// hashPrev[i & windowMask] has already been overwritten, so stop now.
-			break;
+			break
 		}
 		if i = d.hashPrev[i & d.windowMask]; i < minIndex || i < 0 {
-			break;
+			break
 		}
 	}
 	return;
@@ -218,7 +218,7 @@ func (d *deflater) findMatch(pos int, prevHead int, prevLength int, lookahead in
 
 func (d *deflater) writeStoredBlock(buf []byte) os.Error {
 	if d.w.writeStoredHeader(len(buf), false); d.w.err != nil {
-		return d.w.err;
+		return d.w.err
 	}
 	d.w.writeBytes(buf);
 	return d.w.err;
@@ -230,12 +230,12 @@ func (d *deflater) storedDeflate() os.Error {
 		n, err := d.r.Read(buf);
 		if n > 0 {
 			if err := d.writeStoredBlock(buf[0:n]); err != nil {
-				return err;
+				return err
 			}
 		}
 		if err != nil {
 			if err == os.EOF {
-				break;
+				break
 			}
 			return err;
 		}
@@ -263,7 +263,7 @@ func (d *deflater) doDeflate() (err os.Error) {
 	index := 0;
 	// run
 	if index, err = d.fillWindow(index); err != nil {
-		return;
+		return
 	}
 	maxOffset := d.windowMask + 1;	// (1 << logWindowSize);
 	// only need to change when you refill the window
@@ -273,26 +273,26 @@ func (d *deflater) doDeflate() (err os.Error) {
 
 	hash := int(0);
 	if index < maxInsertIndex {
-		hash = int(d.window[index]) << hashShift + int(d.window[index+1]);
+		hash = int(d.window[index]) << hashShift + int(d.window[index+1])
 	}
 	chainHead := -1;
 	for {
 		if index > windowEnd {
-			panic("index > windowEnd");
+			panic("index > windowEnd")
 		}
 		lookahead := windowEnd - index;
 		if lookahead < minMatchLength + maxMatchLength {
 			if index, err = d.fillWindow(index); err != nil {
-				return;
+				return
 			}
 			windowEnd = d.windowEnd;
 			if index > windowEnd {
-				panic("index > windowEnd");
+				panic("index > windowEnd")
 			}
 			maxInsertIndex = windowEnd - (minMatchLength - 1);
 			lookahead = windowEnd - index;
 			if lookahead == 0 {
-				break;
+				break
 			}
 		}
 		if index < maxInsertIndex {
@@ -321,9 +321,9 @@ func (d *deflater) doDeflate() (err os.Error) {
 			// There was a match at the previous step, and the current match is
 			// not better. Output the previous match.
 			if isFastDeflate {
-				tokens[ti] = matchToken(uint32(length - minMatchLength), uint32(offset - minOffsetSize));
+				tokens[ti] = matchToken(uint32(length - minMatchLength), uint32(offset - minOffsetSize))
 			} else {
-				tokens[ti] = matchToken(uint32(prevLength - minMatchLength), uint32(prevOffset - minOffsetSize));
+				tokens[ti] = matchToken(uint32(prevLength - minMatchLength), uint32(prevOffset - minOffsetSize))
 			}
 			ti++;
 			// Insert in the hash table all strings up to the end of the match.
@@ -333,9 +333,9 @@ func (d *deflater) doDeflate() (err os.Error) {
 			if length <= l.fastSkipHashing {
 				var newIndex int;
 				if isFastDeflate {
-					newIndex = index+length;
+					newIndex = index+length
 				} else {
-					newIndex = prevLength - 1;
+					newIndex = prevLength - 1
 				}
 				for index++; index < newIndex; index++ {
 					if index < maxInsertIndex {
@@ -360,7 +360,7 @@ func (d *deflater) doDeflate() (err os.Error) {
 			if ti == maxFlateBlockTokens {
 				// The block includes the current character
 				if err = d.writeBlock(tokens, index, false); err != nil {
-					return;
+					return
 				}
 				ti = 0;
 			}
@@ -368,20 +368,20 @@ func (d *deflater) doDeflate() (err os.Error) {
 			if isFastDeflate || byteAvailable {
 				i := index-1;
 				if isFastDeflate {
-					i = index;
+					i = index
 				}
 				tokens[ti] = literalToken(uint32(d.window[i])&0xFF);
 				ti++;
 				if ti == maxFlateBlockTokens {
 					if err = d.writeBlock(tokens, i+1, false); err != nil {
-						return;
+						return
 					}
 					ti = 0;
 				}
 			}
 			index++;
 			if !isFastDeflate {
-				byteAvailable = true;
+				byteAvailable = true
 			}
 		}
 
@@ -394,7 +394,7 @@ func (d *deflater) doDeflate() (err os.Error) {
 
 	if ti > 0 {
 		if err = d.writeBlock(tokens[0:ti], index, false); err != nil {
-			return;
+			return
 		}
 	}
 	return;
@@ -408,21 +408,21 @@ func (d *deflater) deflater(r io.Reader, w io.Writer, level int, logWindowSize u
 
 	switch {
 	case level == NoCompression:
-		err = d.storedDeflate();
+		err = d.storedDeflate()
 	case level == DefaultCompression:
 		d.level = 6;
 		fallthrough;
 	case 1 <= level && level <= 9:
-		err = d.doDeflate();
+		err = d.doDeflate()
 	default:
-		return WrongValueError{"level", 0, 9, int32(level)};
+		return WrongValueError{"level", 0, 9, int32(level)}
 	}
 
 	if err != nil {
-		return err;
+		return err
 	}
 	if d.w.writeStoredHeader(0, true); d.w.err != nil {
-		return d.w.err;
+		return d.w.err
 	}
 	return d.flush();
 }
@@ -438,5 +438,5 @@ func newDeflater(w io.Writer, level int, logWindowSize uint) io.WriteCloser {
 }
 
 func NewDeflater(w io.Writer, level int) io.WriteCloser {
-	return newDeflater(w, level, logMaxOffsetSize);
+	return newDeflater(w, level, logMaxOffsetSize)
 }
diff --git a/src/pkg/compress/flate/deflate_test.go b/src/pkg/compress/flate/deflate_test.go
index 3f6c60bf55..85cc12d383 100644
--- a/src/pkg/compress/flate/deflate_test.go
+++ b/src/pkg/compress/flate/deflate_test.go
@@ -72,7 +72,7 @@ var reverseBitsTests = []*reverseBitsTest{
 func getLargeDataChunk() []byte {
 	result := make([]byte, 100000);
 	for i := range result {
-		result[i] = byte(int64(i)*int64(i)&0xFF);
+		result[i] = byte(int64(i)*int64(i)&0xFF)
 	}
 	return result;
 }
@@ -85,7 +85,7 @@ func TestDeflate(t *testing.T) {
 		w.Close();
 		if bytes.Compare(buffer.Bytes(), h.out) != 0 {
 			t.Errorf("buffer is wrong; level = %v, buffer.Bytes() = %v, expected output = %v",
-				h.level, buffer.Bytes(), h.out);
+				h.level, buffer.Bytes(), h.out)
 		}
 	}
 }
@@ -103,20 +103,20 @@ func testToFromWithLevel(t *testing.T, level int, input []byte, name string) os.
 	}
 	inflater.Close();
 	if bytes.Compare(input, decompressed) != 0 {
-		t.Errorf("decompress(compress(data)) != data: level=%d input=%s", level, name);
+		t.Errorf("decompress(compress(data)) != data: level=%d input=%s", level, name)
 	}
 	return nil;
 }
 
 func testToFrom(t *testing.T, input []byte, name string) {
 	for i := 0; i < 10; i++ {
-		testToFromWithLevel(t, i, input, name);
+		testToFromWithLevel(t, i, input, name)
 	}
 }
 
 func TestDeflateInflate(t *testing.T) {
 	for i, h := range deflateInflateTests {
-		testToFrom(t, h.in, fmt.Sprintf("#%d", i));
+		testToFrom(t, h.in, fmt.Sprintf("#%d", i))
 	}
 }
 
@@ -124,7 +124,7 @@ func TestReverseBits(t *testing.T) {
 	for _, h := range reverseBitsTests {
 		if v := reverseBits(h.in, h.bitCount); v != h.out {
 			t.Errorf("reverseBits(%v,%v) = %v, want %v",
-				h.in, h.bitCount, v, h.out);
+				h.in, h.bitCount, v, h.out)
 		}
 	}
 }
@@ -260,5 +260,5 @@ func getEdata() string {
 		"30186739439716388611764209004068663398856841681003872389214483176070116684503887" +
 		"21236436704331409115573328018297798873659091665961240202177855885487617616198937" +
 		"07943800566633648843650891448055710397652146960276625835990519870423001794655367" +
-		"9";
+		"9"
 }
diff --git a/src/pkg/compress/flate/flate_test.go b/src/pkg/compress/flate/flate_test.go
index ab7ce250b7..e2a97b368e 100644
--- a/src/pkg/compress/flate/flate_test.go
+++ b/src/pkg/compress/flate/flate_test.go
@@ -121,7 +121,7 @@ func TestInitDecoder(t *testing.T) {
 			continue;
 		}
 		if !reflect.DeepEqual(&h, &tt.out) {
-			t.Errorf("test %d:\nhave %v\nwant %v", i, h, tt.out);
+			t.Errorf("test %d:\nhave %v\nwant %v", i, h, tt.out)
 		}
 	}
 }
@@ -131,9 +131,9 @@ func TestUncompressedSource(t *testing.T) {
 	output := make([]byte, 1);
 	n, error := decoder.Read(output);
 	if n != 1 || error != nil {
-		t.Fatalf("decoder.Read() = %d, %v, want 1, nil", n, error);
+		t.Fatalf("decoder.Read() = %d, %v, want 1, nil", n, error)
 	}
 	if output[0] != 0x11 {
-		t.Errorf("output[0] = %x, want 0x11", output[0]);
+		t.Errorf("output[0] = %x, want 0x11", output[0])
 	}
 }
diff --git a/src/pkg/compress/flate/huffman_bit_writer.go b/src/pkg/compress/flate/huffman_bit_writer.go
index e81c6e6e05..44cb9811b9 100644
--- a/src/pkg/compress/flate/huffman_bit_writer.go
+++ b/src/pkg/compress/flate/huffman_bit_writer.go
@@ -106,12 +106,12 @@ func newHuffmanBitWriter(w io.Writer) *huffmanBitWriter {
 		literalEncoding: newHuffmanEncoder(maxLit),
 		offsetEncoding: newHuffmanEncoder(extendedOffsetCodeCount),
 		codegenEncoding: newHuffmanEncoder(codegenCodeCount),
-	};
+	}
 }
 
 func (err WrongValueError) String() string {
 	return "huffmanBitWriter: " + err.name + " should belong to [" + strconv.Itoa64(int64(err.from)) + ";" +
-		strconv.Itoa64(int64(err.to)) + "] but actual value is " + strconv.Itoa64(int64(err.value));
+		strconv.Itoa64(int64(err.to)) + "] but actual value is " + strconv.Itoa64(int64(err.value))
 }
 
 func (w *huffmanBitWriter) flushBits() {
@@ -157,13 +157,13 @@ func (w *huffmanBitWriter) flush() {
 func (w *huffmanBitWriter) writeBits(b, nb int32) {
 	w.bits |= uint32(b) << w.nbits;
 	if w.nbits += uint32(nb); w.nbits >= 16 {
-		w.flushBits();
+		w.flushBits()
 	}
 }
 
 func (w *huffmanBitWriter) writeBytes(bytes []byte) {
 	if w.err != nil {
-		return;
+		return
 	}
 	n := w.nbytes;
 	if w.nbits == 8 {
@@ -178,7 +178,7 @@ func (w *huffmanBitWriter) writeBytes(bytes []byte) {
 	if n != 0 {
 		_, w.err = w.w.Write(w.bytes[0:n]);
 		if w.err != nil {
-			return;
+			return
 		}
 	}
 	w.nbytes = 0;
@@ -270,7 +270,7 @@ func (w *huffmanBitWriter) generateCodegen(numLiterals int, numOffsets int) {
 
 func (w *huffmanBitWriter) writeCode(code *huffmanEncoder, literal uint32) {
 	if w.err != nil {
-		return;
+		return
 	}
 	w.writeBits(int32(code.code[literal]), int32(code.codeBits[literal]));
 }
@@ -282,11 +282,11 @@ func (w *huffmanBitWriter) writeCode(code *huffmanEncoder, literal uint32) {
 //  numCodegens  Tne number of codegens used in codegen
 func (w *huffmanBitWriter) writeDynamicHeader(numLiterals int, numOffsets int, numCodegens int, isEof bool) {
 	if w.err != nil {
-		return;
+		return
 	}
 	var firstBits int32 = 4;
 	if isEof {
-		firstBits = 5;
+		firstBits = 5
 	}
 	w.writeBits(firstBits, 3);
 	w.writeBits(int32(numLiterals - 257), 5);
@@ -295,7 +295,7 @@ func (w *huffmanBitWriter) writeDynamicHeader(numLiterals int, numOffsets int, n
 		w.writeBits(int32(offsetCodeCount + ((numOffsets - (1 + offsetCodeCount))>>3)), 5);
 		w.writeBits(int32((numOffsets - (1 + offsetCodeCount))&0x7), 3);
 	} else {
-		w.writeBits(int32(numOffsets - 1), 5);
+		w.writeBits(int32(numOffsets - 1), 5)
 	}
 	w.writeBits(int32(numCodegens - 4), 4);
 
@@ -309,7 +309,7 @@ func (w *huffmanBitWriter) writeDynamicHeader(numLiterals int, numOffsets int, n
 		var codeWord int = int(w.codegen[i]);
 		i++;
 		if codeWord == badCode {
-			break;
+			break
 		}
 		// The low byte contains the actual code to generate.
 		w.writeCode(w.codegenEncoding, uint32(codeWord));
@@ -333,11 +333,11 @@ func (w *huffmanBitWriter) writeDynamicHeader(numLiterals int, numOffsets int, n
 
 func (w *huffmanBitWriter) writeStoredHeader(length int, isEof bool) {
 	if w.err != nil {
-		return;
+		return
 	}
 	var flag int32;
 	if isEof {
-		flag = 1;
+		flag = 1
 	}
 	w.writeBits(flag, 3);
 	w.flush();
@@ -347,19 +347,19 @@ func (w *huffmanBitWriter) writeStoredHeader(length int, isEof bool) {
 
 func (w *huffmanBitWriter) writeFixedHeader(isEof bool) {
 	if w.err != nil {
-		return;
+		return
 	}
 	// Indicate that we are a fixed Huffman block
 	var value int32 = 2;
 	if isEof {
-		value = 3;
+		value = 3
 	}
 	w.writeBits(value, 3);
 }
 
 func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte) {
 	if w.err != nil {
-		return;
+		return
 	}
 	fillInt32s(w.literalFreq, 0);
 	fillInt32s(w.offsetFreq, 0);
@@ -390,16 +390,16 @@ func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte) {
 	// get the number of literals
 	numLiterals := len(w.literalFreq);
 	for w.literalFreq[numLiterals - 1] == 0 {
-		numLiterals--;
+		numLiterals--
 	}
 	// get the number of offsets
 	numOffsets := len(w.offsetFreq);
 	for numOffsets > 1 && w.offsetFreq[numOffsets - 1] == 0 {
-		numOffsets--;
+		numOffsets--
 	}
 	storedBytes := 0;
 	if input != nil {
-		storedBytes = len(input);
+		storedBytes = len(input)
 	}
 	var extraBits int64;
 	var storedSize int64;
@@ -411,14 +411,14 @@ func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte) {
 		// against stored encoding.
 		for lengthCode := lengthCodesStart + 8; lengthCode < numLiterals; lengthCode++ {
 			// First eight length codes have extra size = 0.
-			extraBits += int64(w.literalFreq[lengthCode])*int64(lengthExtraBits[lengthCode - lengthCodesStart]);
+			extraBits += int64(w.literalFreq[lengthCode])*int64(lengthExtraBits[lengthCode - lengthCodesStart])
 		}
 		for offsetCode := 4; offsetCode < numOffsets; offsetCode++ {
 			// First four offset codes have extra size = 0.
-			extraBits += int64(w.offsetFreq[offsetCode])*int64(offsetExtraBits[offsetCode]);
+			extraBits += int64(w.offsetFreq[offsetCode])*int64(offsetExtraBits[offsetCode])
 		}
 	} else {
-		storedSize = math.MaxInt32;
+		storedSize = math.MaxInt32
 	}
 
 	// Figure out which generates smaller code, fixed Huffman, dynamic
@@ -428,7 +428,7 @@ func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte) {
 		fixedSize = int64(3) +
 			fixedLiteralEncoding.bitLength(w.literalFreq) +
 			fixedOffsetEncoding.bitLength(w.offsetFreq) +
-			extraBits;
+			extraBits
 	}
 	// Generate codegen and codegenFrequencies, which indicates how to encode
 	// the literalEncoding and the offsetEncoding.
@@ -436,11 +436,11 @@ func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte) {
 	w.codegenEncoding.generate(w.codegenFreq, 7);
 	numCodegens := len(w.codegenFreq);
 	for numCodegens > 4 && w.codegenFreq[codegenOrder[numCodegens - 1]] == 0 {
-		numCodegens--;
+		numCodegens--
 	}
 	extensionSummand := 0;
 	if numOffsets > offsetCodeCount {
-		extensionSummand = 3;
+		extensionSummand = 3
 	}
 	dynamicHeader := int64(3+5+5+4+(3 * numCodegens)) +
 		// Following line is an extension.
@@ -500,7 +500,7 @@ func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte) {
 			}
 			break;
 		default:
-			panic("unknown token type: " + string(t));
+			panic("unknown token type: " + string(t))
 		}
 	}
 }
diff --git a/src/pkg/compress/flate/huffman_code.go b/src/pkg/compress/flate/huffman_code.go
index eecfceb9c1..c3cd482dc9 100644
--- a/src/pkg/compress/flate/huffman_code.go
+++ b/src/pkg/compress/flate/huffman_code.go
@@ -58,7 +58,7 @@ type levelInfo struct {
 func maxNode() literalNode	{ return literalNode{math.MaxUint16, math.MaxInt32} }
 
 func newHuffmanEncoder(size int) *huffmanEncoder {
-	return &huffmanEncoder{make([]uint8, size), make([]uint16, size)};
+	return &huffmanEncoder{make([]uint8, size), make([]uint16, size)}
 }
 
 // Generates a HuffmanCode corresponding to the fixed literal table
@@ -115,7 +115,7 @@ func (h *huffmanEncoder) bitLength(freq []int32) int64 {
 	var total int64;
 	for i, f := range freq {
 		if f != 0 {
-			total += int64(f)*int64(h.codeBits[i]);
+			total += int64(f)*int64(h.codeBits[i])
 		}
 	}
 	return total;
@@ -163,14 +163,14 @@ func (h *huffmanEncoder) generateChains(top *levelInfo, list []literalNode) {
 			up := l.up;
 			if up == nil {
 				// All done!
-				return;
+				return
 			}
 			up.nextPairFreq = prevFreq + l.lastChain.freq;
 			l = up;
 		} else {
 			// If we stole from below, move down temporarily to replenish it.
 			for l.down.needed > 0 {
-				l = l.down;
+				l = l.down
 			}
 		}
 	}
@@ -215,7 +215,7 @@ func (h *huffmanEncoder) bitCounts(list []literalNode, maxBits int32) []int32 {
 		};
 		top.down.up = top;
 		if level == 1 {
-			top.nextPairFreq = math.MaxInt32;
+			top.nextPairFreq = math.MaxInt32
 		}
 	}
 
@@ -258,14 +258,14 @@ func (h *huffmanEncoder) bitCounts(list []literalNode, maxBits int32) []int32 {
 			up := l.up;
 			if up == nil {
 				// All done!
-				break;
+				break
 			}
 			up.nextPairFreq = prevFreq + l.lastChain.freq;
 			l = up;
 		} else {
 			// If we stole from below, move down temporarily to replenish it.
 			for l.down.needed > 0 {
-				l = l.down;
+				l = l.down
 			}
 		}
 	}
@@ -274,7 +274,7 @@ func (h *huffmanEncoder) bitCounts(list []literalNode, maxBits int32) []int32 {
 	// Somethings is wrong if at the end, the top level is null or hasn't used
 	// all of the leaves.
 	if top.lastChain.leafCount != n {
-		panic("top.lastChain.leafCount != n");
+		panic("top.lastChain.leafCount != n")
 	}
 
 	bitCount := make([]int32, maxBits+1);
@@ -295,7 +295,7 @@ func (h *huffmanEncoder) assignEncodingAndSize(bitCount []int32, list []literalN
 	for n, bits := range bitCount {
 		code <<= 1;
 		if n == 0 || bits == 0 {
-			continue;
+			continue
 		}
 		// The literals list[len(list)-bits] .. list[len(list)-bits]
 		// are encoded using "bits" bits, and get the values
@@ -326,7 +326,7 @@ func (h *huffmanEncoder) generate(freq []int32, maxBits int32) {
 			list[count] = literalNode{uint16(i), f};
 			count++;
 		} else {
-			h.codeBits[i] = 0;
+			h.codeBits[i] = 0
 		}
 	}
 	// If freq[] is shorter than codeBits[], fill rest of codeBits[] with zeros
@@ -358,7 +358,7 @@ type literalNodeSorter struct {
 func (s literalNodeSorter) Len() int	{ return len(s.a) }
 
 func (s literalNodeSorter) Less(i, j int) bool {
-	return s.less(i, j);
+	return s.less(i, j)
 }
 
 func (s literalNodeSorter) Swap(i, j int)	{ s.a[i], s.a[j] = s.a[j], s.a[i] }
diff --git a/src/pkg/compress/flate/inflate.go b/src/pkg/compress/flate/inflate.go
index a39166d961..5bdd5cfae5 100644
--- a/src/pkg/compress/flate/inflate.go
+++ b/src/pkg/compress/flate/inflate.go
@@ -26,7 +26,7 @@ const (
 type CorruptInputError int64
 
 func (e CorruptInputError) String() string {
-	return "flate: corrupt input before offset " + strconv.Itoa64(int64(e));
+	return "flate: corrupt input before offset " + strconv.Itoa64(int64(e))
 }
 
 // An InternalError reports an error in the flate code itself.
@@ -41,7 +41,7 @@ type ReadError struct {
 }
 
 func (e *ReadError) String() string {
-	return "flate: read error at offset " + strconv.Itoa64(e.Offset) + ": " + e.Error.String();
+	return "flate: read error at offset " + strconv.Itoa64(e.Offset) + ": " + e.Error.String()
 }
 
 // A WriteError reports an error encountered while writing output.
@@ -51,7 +51,7 @@ type WriteError struct {
 }
 
 func (e *WriteError) String() string {
-	return "flate: write error at offset " + strconv.Itoa64(e.Offset) + ": " + e.Error.String();
+	return "flate: write error at offset " + strconv.Itoa64(e.Offset) + ": " + e.Error.String()
 }
 
 // Huffman decoder is based on
@@ -85,18 +85,18 @@ func (h *huffmanDecoder) init(bits []int) bool {
 	var min, max int;
 	for _, n := range bits {
 		if n == 0 {
-			continue;
+			continue
 		}
 		if min == 0 || n < min {
-			min = n;
+			min = n
 		}
 		if n > max {
-			max = n;
+			max = n
 		}
 		count[n]++;
 	}
 	if max == 0 {
-		return false;
+		return false
 	}
 
 	h.min = min;
@@ -122,11 +122,11 @@ func (h *huffmanDecoder) init(bits []int) bool {
 
 	// Make array mapping sequence numbers to codes.
 	if len(h.codes) < len(bits) {
-		h.codes = make([]int, len(bits));
+		h.codes = make([]int, len(bits))
 	}
 	for i, n := range bits {
 		if n == 0 {
-			continue;
+			continue
 		}
 		code := nextcode[n];
 		nextcode[n]++;
@@ -229,7 +229,7 @@ func (f *inflater) inflate() (err os.Error) {
 	for err == nil && !final {
 		for f.nb < 1+2 {
 			if err = f.moreBits(); err != nil {
-				return;
+				return
 			}
 		}
 		final = f.b & 1 == 1;
@@ -239,18 +239,18 @@ func (f *inflater) inflate() (err os.Error) {
 		f.nb -= 1+2;
 		switch typ {
 		case 0:
-			err = f.dataBlock();
+			err = f.dataBlock()
 		case 1:
 			// compressed, fixed Huffman tables
-			err = f.decodeBlock(&fixedHuffmanDecoder, nil);
+			err = f.decodeBlock(&fixedHuffmanDecoder, nil)
 		case 2:
 			// compressed, dynamic Huffman tables
 			if err = f.readHuffman(); err == nil {
-				err = f.decodeBlock(&f.h1, &f.h2);
+				err = f.decodeBlock(&f.h1, &f.h2)
 			}
 		default:
 			// 3 is reserved.
-			err = CorruptInputError(f.roffset);
+			err = CorruptInputError(f.roffset)
 		}
 	}
 	return;
@@ -265,7 +265,7 @@ func (f *inflater) readHuffman() os.Error {
 	// HLIT[5], HDIST[5], HCLEN[4].
 	for f.nb < 5+5+4 {
 		if err := f.moreBits(); err != nil {
-			return err;
+			return err
 		}
 	}
 	nlit := int(f.b & 0x1F)+257;
@@ -280,7 +280,7 @@ func (f *inflater) readHuffman() os.Error {
 	for i := 0; i < nclen; i++ {
 		for f.nb < 3 {
 			if err := f.moreBits(); err != nil {
-				return err;
+				return err
 			}
 		}
 		f.codebits[codeOrder[i]] = int(f.b & 0x7);
@@ -288,10 +288,10 @@ func (f *inflater) readHuffman() os.Error {
 		f.nb -= 3;
 	}
 	for i := nclen; i < len(codeOrder); i++ {
-		f.codebits[codeOrder[i]] = 0;
+		f.codebits[codeOrder[i]] = 0
 	}
 	if !f.h1.init(&f.codebits) {
-		return CorruptInputError(f.roffset);
+		return CorruptInputError(f.roffset)
 	}
 
 	// HLIT + 257 code lengths, HDIST + 1 code lengths,
@@ -299,7 +299,7 @@ func (f *inflater) readHuffman() os.Error {
 	for i, n := 0, nlit+ndist; i < n; {
 		x, err := f.huffSym(&f.h1);
 		if err != nil {
-			return err;
+			return err
 		}
 		if x < 16 {
 			// Actual length.
@@ -313,12 +313,12 @@ func (f *inflater) readHuffman() os.Error {
 		var b int;
 		switch x {
 		default:
-			return InternalError("unexpected length code");
+			return InternalError("unexpected length code")
 		case 16:
 			rep = 3;
 			nb = 2;
 			if i == 0 {
-				return CorruptInputError(f.roffset);
+				return CorruptInputError(f.roffset)
 			}
 			b = f.bits[i-1];
 		case 17:
@@ -332,14 +332,14 @@ func (f *inflater) readHuffman() os.Error {
 		}
 		for f.nb < nb {
 			if err := f.moreBits(); err != nil {
-				return err;
+				return err
 			}
 		}
 		rep += int(f.b & uint32(1<<nb - 1));
 		f.b >>= nb;
 		f.nb -= nb;
 		if i+rep > n {
-			return CorruptInputError(f.roffset);
+			return CorruptInputError(f.roffset)
 		}
 		for j := 0; j < rep; j++ {
 			f.bits[i] = b;
@@ -348,7 +348,7 @@ func (f *inflater) readHuffman() os.Error {
 	}
 
 	if !f.h1.init(f.bits[0:nlit]) || !f.h2.init(f.bits[nlit : nlit+ndist]) {
-		return CorruptInputError(f.roffset);
+		return CorruptInputError(f.roffset)
 	}
 
 	return nil;
@@ -362,7 +362,7 @@ func (f *inflater) decodeBlock(hl, hd *huffmanDecoder) os.Error {
 	for {
 		v, err := f.huffSym(hl);
 		if err != nil {
-			return err;
+			return err
 		}
 		var n uint;	// number of bits extra
 		var length int;
@@ -372,12 +372,12 @@ func (f *inflater) decodeBlock(hl, hd *huffmanDecoder) os.Error {
 			f.hp++;
 			if f.hp == len(f.hist) {
 				if err = f.flush(); err != nil {
-					return err;
+					return err
 				}
 			}
 			continue;
 		case v == 256:
-			return nil;
+			return nil
 		// otherwise, reference to older data
 		case v < 265:
 			length = v-(257-3);
@@ -404,7 +404,7 @@ func (f *inflater) decodeBlock(hl, hd *huffmanDecoder) os.Error {
 		if n > 0 {
 			for f.nb < n {
 				if err = f.moreBits(); err != nil {
-					return err;
+					return err
 				}
 			}
 			length += int(f.b & uint32(1<<n - 1));
@@ -416,7 +416,7 @@ func (f *inflater) decodeBlock(hl, hd *huffmanDecoder) os.Error {
 		if hd == nil {
 			for f.nb < 5 {
 				if err = f.moreBits(); err != nil {
-					return err;
+					return err
 				}
 			}
 			dist = int(reverseByte[(f.b & 0x1F)<<3]);
@@ -424,22 +424,22 @@ func (f *inflater) decodeBlock(hl, hd *huffmanDecoder) os.Error {
 			f.nb -= 5;
 		} else {
 			if dist, err = f.huffSym(hd); err != nil {
-				return err;
+				return err
 			}
 		}
 
 		switch {
 		case dist < 4:
-			dist++;
+			dist++
 		case dist >= 30:
-			return CorruptInputError(f.roffset);
+			return CorruptInputError(f.roffset)
 		default:
 			nb := uint(dist-2)>>1;
 			// have 1 bit in bottom of dist, need nb more.
 			extra := (dist&1)<<nb;
 			for f.nb < nb {
 				if err = f.moreBits(); err != nil {
-					return err;
+					return err
 				}
 			}
 			extra |= int(f.b & uint32(1<<nb - 1));
@@ -450,17 +450,17 @@ func (f *inflater) decodeBlock(hl, hd *huffmanDecoder) os.Error {
 
 		// Copy history[-dist:-dist+length] into output.
 		if dist > len(f.hist) {
-			return InternalError("bad history distance");
+			return InternalError("bad history distance")
 		}
 
 		// No check on length; encoding can be prescient.
 		if !f.hfull && dist > f.hp {
-			return CorruptInputError(f.roffset);
+			return CorruptInputError(f.roffset)
 		}
 
 		p := f.hp - dist;
 		if p < 0 {
-			p += len(f.hist);
+			p += len(f.hist)
 		}
 		for i := 0; i < length; i++ {
 			f.hist[f.hp] = f.hist[p];
@@ -468,11 +468,11 @@ func (f *inflater) decodeBlock(hl, hd *huffmanDecoder) os.Error {
 			p++;
 			if f.hp == len(f.hist) {
 				if err = f.flush(); err != nil {
-					return err;
+					return err
 				}
 			}
 			if p == len(f.hist) {
-				p = 0;
+				p = 0
 			}
 		}
 	}
@@ -490,12 +490,12 @@ func (f *inflater) dataBlock() os.Error {
 	nr, err := io.ReadFull(f.r, f.buf[0:4]);
 	f.roffset += int64(nr);
 	if err != nil {
-		return &ReadError{f.roffset, err};
+		return &ReadError{f.roffset, err}
 	}
 	n := int(f.buf[0]) | int(f.buf[1])<<8;
 	nn := int(f.buf[2]) | int(f.buf[3])<<8;
 	if uint16(nn) != uint16(^n) {
-		return CorruptInputError(f.roffset);
+		return CorruptInputError(f.roffset)
 	}
 
 	// Read len bytes into history,
@@ -503,18 +503,18 @@ func (f *inflater) dataBlock() os.Error {
 	for n > 0 {
 		m := len(f.hist) - f.hp;
 		if m > n {
-			m = n;
+			m = n
 		}
 		m, err := io.ReadFull(f.r, f.hist[f.hp : f.hp + m]);
 		f.roffset += int64(m);
 		if err != nil {
-			return &ReadError{f.roffset, err};
+			return &ReadError{f.roffset, err}
 		}
 		n -= m;
 		f.hp += m;
 		if f.hp == len(f.hist) {
 			if err = f.flush(); err != nil {
-				return err;
+				return err
 			}
 		}
 	}
@@ -525,7 +525,7 @@ func (f *inflater) moreBits() os.Error {
 	c, err := f.r.ReadByte();
 	if err != nil {
 		if err == os.EOF {
-			err = io.ErrUnexpectedEOF;
+			err = io.ErrUnexpectedEOF
 		}
 		return err;
 	}
@@ -540,11 +540,11 @@ func (f *inflater) huffSym(h *huffmanDecoder) (int, os.Error) {
 	for n := uint(h.min); n <= uint(h.max); n++ {
 		lim := h.limit[n];
 		if lim == -1 {
-			continue;
+			continue
 		}
 		for f.nb < n {
 			if err := f.moreBits(); err != nil {
-				return 0, err;
+				return 0, err
 			}
 		}
 		v := int(f.b & uint32(1<<n - 1));
@@ -562,14 +562,14 @@ func (f *inflater) huffSym(h *huffmanDecoder) (int, os.Error) {
 // Flush any buffered output to the underlying writer.
 func (f *inflater) flush() os.Error {
 	if f.hp == 0 {
-		return nil;
+		return nil
 	}
 	n, err := f.w.Write(f.hist[0 : f.hp]);
 	if n != f.hp && err == nil {
-		err = io.ErrShortWrite;
+		err = io.ErrShortWrite
 	}
 	if err != nil {
-		return &WriteError{f.woffset, err};
+		return &WriteError{f.woffset, err}
 	}
 	f.woffset += int64(f.hp);
 	f.hp = 0;
@@ -579,7 +579,7 @@ func (f *inflater) flush() os.Error {
 
 func makeReader(r io.Reader) Reader {
 	if rr, ok := r.(Reader); ok {
-		return rr;
+		return rr
 	}
 	return bufio.NewReader(r);
 }
@@ -591,10 +591,10 @@ func (f *inflater) inflater(r io.Reader, w io.Writer) os.Error {
 	f.w = w;
 	f.woffset = 0;
 	if err := f.inflate(); err != nil {
-		return err;
+		return err
 	}
 	if err := f.flush(); err != nil {
-		return err;
+		return err
 	}
 	return nil;
 }
diff --git a/src/pkg/compress/flate/reverse_bits.go b/src/pkg/compress/flate/reverse_bits.go
index 76693d4757..8376da32a6 100644
--- a/src/pkg/compress/flate/reverse_bits.go
+++ b/src/pkg/compress/flate/reverse_bits.go
@@ -40,9 +40,9 @@ var reverseByte = [256]byte{
 }
 
 func reverseUint16(v uint16) uint16 {
-	return uint16(reverseByte[v>>8]) | uint16(reverseByte[v&0xFF])<<8;
+	return uint16(reverseByte[v>>8]) | uint16(reverseByte[v&0xFF])<<8
 }
 
 func reverseBits(number uint16, bitLength byte) uint16 {
-	return reverseUint16(number<<uint8(16 - bitLength));
+	return reverseUint16(number<<uint8(16 - bitLength))
 }
diff --git a/src/pkg/compress/flate/token.go b/src/pkg/compress/flate/token.go
index d37730ca57..5d4bcefaf5 100644
--- a/src/pkg/compress/flate/token.go
+++ b/src/pkg/compress/flate/token.go
@@ -72,7 +72,7 @@ func literalToken(literal uint32) token	{ return token(literalType + literal) }
 
 // Convert a < xlength, xoffset > pair into a match token.
 func matchToken(xlength uint32, xoffset uint32) token {
-	return token(matchType + xlength << lengthShift + xoffset);
+	return token(matchType + xlength << lengthShift + xoffset)
 }
 
 // Returns the type of a token
@@ -93,11 +93,11 @@ func offsetCode(off uint32) uint32 {
 	const n = uint32(len(offsetCodes));
 	switch {
 	case off < n:
-		return offsetCodes[off];
+		return offsetCodes[off]
 	case off>>7 < n:
-		return offsetCodes[off>>7] + 14;
+		return offsetCodes[off>>7] + 14
 	default:
-		return offsetCodes[off>>14] + 28;
+		return offsetCodes[off>>14] + 28
 	}
 	panic("unreachable");
 }
diff --git a/src/pkg/compress/flate/util.go b/src/pkg/compress/flate/util.go
index 177ee21d6f..f4e0b9ba38 100644
--- a/src/pkg/compress/flate/util.go
+++ b/src/pkg/compress/flate/util.go
@@ -6,59 +6,59 @@ package flate
 
 func min(left int, right int) int {
 	if left < right {
-		return left;
+		return left
 	}
 	return right;
 }
 
 func minInt32(left int32, right int32) int32 {
 	if left < right {
-		return left;
+		return left
 	}
 	return right;
 }
 
 func max(left int, right int) int {
 	if left > right {
-		return left;
+		return left
 	}
 	return right;
 }
 
 func fillInts(a []int, value int) {
 	for i := range a {
-		a[i] = value;
+		a[i] = value
 	}
 }
 
 func fillInt32s(a []int32, value int32) {
 	for i := range a {
-		a[i] = value;
+		a[i] = value
 	}
 }
 
 func fillBytes(a []byte, value byte) {
 	for i := range a {
-		a[i] = value;
+		a[i] = value
 	}
 }
 
 func fillInt8s(a []int8, value int8) {
 	for i := range a {
-		a[i] = value;
+		a[i] = value
 	}
 }
 
 func fillUint8s(a []uint8, value uint8) {
 	for i := range a {
-		a[i] = value;
+		a[i] = value
 	}
 }
 
 func copyInt8s(dst []int8, src []int8) int {
 	cnt := min(len(dst), len(src));
 	for i := 0; i < cnt; i++ {
-		dst[i] = src[i];
+		dst[i] = src[i]
 	}
 	return cnt;
 }
@@ -66,7 +66,7 @@ func copyInt8s(dst []int8, src []int8) int {
 func copyUint8s(dst []uint8, src []uint8) int {
 	cnt := min(len(dst), len(src));
 	for i := 0; i < cnt; i++ {
-		dst[i] = src[i];
+		dst[i] = src[i]
 	}
 	return cnt;
 }
diff --git a/src/pkg/compress/gzip/gunzip.go b/src/pkg/compress/gzip/gunzip.go
index 3dbfeca652..8dc64fea36 100644
--- a/src/pkg/compress/gzip/gunzip.go
+++ b/src/pkg/compress/gzip/gunzip.go
@@ -28,7 +28,7 @@ const (
 
 func makeReader(r io.Reader) flate.Reader {
 	if rr, ok := r.(flate.Reader); ok {
-		return rr;
+		return rr
 	}
 	return bufio.NewReader(r);
 }
@@ -85,21 +85,21 @@ func NewInflater(r io.Reader) (*Inflater, os.Error) {
 
 // GZIP (RFC 1952) is little-endian, unlike ZLIB (RFC 1950).
 func get4(p []byte) uint32 {
-	return uint32(p[0]) | uint32(p[1])<<8 | uint32(p[2])<<16 | uint32(p[3])<<24;
+	return uint32(p[0]) | uint32(p[1])<<8 | uint32(p[2])<<16 | uint32(p[3])<<24
 }
 
 func (z *Inflater) readString() (string, os.Error) {
 	var err os.Error;
 	for i := 0; ; i++ {
 		if i >= len(z.buf) {
-			return "", HeaderError;
+			return "", HeaderError
 		}
 		z.buf[i], err = z.r.ReadByte();
 		if err != nil {
-			return "", err;
+			return "", err
 		}
 		if z.buf[i] == 0 {
-			return string(z.buf[0:i]), nil;
+			return string(z.buf[0:i]), nil
 		}
 	}
 	panic("not reached");
@@ -108,7 +108,7 @@ func (z *Inflater) readString() (string, os.Error) {
 func (z *Inflater) read2() (uint32, os.Error) {
 	_, err := z.r.Read(z.buf[0:2]);
 	if err != nil {
-		return 0, err;
+		return 0, err
 	}
 	return uint32(z.buf[0]) | uint32(z.buf[1])<<8, nil;
 }
@@ -116,10 +116,10 @@ func (z *Inflater) read2() (uint32, os.Error) {
 func (z *Inflater) readHeader(save bool) os.Error {
 	_, err := io.ReadFull(z.r, z.buf[0:10]);
 	if err != nil {
-		return err;
+		return err
 	}
 	if z.buf[0] != gzipID1 || z.buf[1] != gzipID2 || z.buf[2] != gzipDeflate {
-		return HeaderError;
+		return HeaderError
 	}
 	z.flg = z.buf[3];
 	if save {
@@ -133,44 +133,44 @@ func (z *Inflater) readHeader(save bool) os.Error {
 	if z.flg & flagExtra != 0 {
 		n, err := z.read2();
 		if err != nil {
-			return err;
+			return err
 		}
 		data := make([]byte, n);
 		if _, err = io.ReadFull(z.r, data); err != nil {
-			return err;
+			return err
 		}
 		if save {
-			z.Extra = data;
+			z.Extra = data
 		}
 	}
 
 	var s string;
 	if z.flg & flagName != 0 {
 		if s, err = z.readString(); err != nil {
-			return err;
+			return err
 		}
 		if save {
-			z.Name = s;
+			z.Name = s
 		}
 	}
 
 	if z.flg & flagComment != 0 {
 		if s, err = z.readString(); err != nil {
-			return err;
+			return err
 		}
 		if save {
-			z.Comment = s;
+			z.Comment = s
 		}
 	}
 
 	if z.flg & flagHdrCrc != 0 {
 		n, err := z.read2();
 		if err != nil {
-			return err;
+			return err
 		}
 		sum := z.digest.Sum32() & 0xFFFF;
 		if n != sum {
-			return HeaderError;
+			return HeaderError
 		}
 	}
 
@@ -181,10 +181,10 @@ func (z *Inflater) readHeader(save bool) os.Error {
 
 func (z *Inflater) Read(p []byte) (n int, err os.Error) {
 	if z.err != nil {
-		return 0, z.err;
+		return 0, z.err
 	}
 	if z.eof || len(p) == 0 {
-		return 0, nil;
+		return 0, nil
 	}
 
 	n, err = z.inflater.Read(p);
diff --git a/src/pkg/compress/gzip/gunzip_test.go b/src/pkg/compress/gzip/gunzip_test.go
index 08e1a59677..84286ee3f6 100644
--- a/src/pkg/compress/gzip/gunzip_test.go
+++ b/src/pkg/compress/gzip/gunzip_test.go
@@ -290,16 +290,16 @@ func TestInflater(t *testing.T) {
 		}
 		defer gzip.Close();
 		if tt.name != gzip.Name {
-			t.Errorf("%s: got name %s", tt.name, gzip.Name);
+			t.Errorf("%s: got name %s", tt.name, gzip.Name)
 		}
 		b.Reset();
 		n, err := io.Copy(b, gzip);
 		if err != tt.err {
-			t.Errorf("%s: io.Copy: %v want %v", tt.name, err, tt.err);
+			t.Errorf("%s: io.Copy: %v want %v", tt.name, err, tt.err)
 		}
 		s := b.String();
 		if s != tt.raw {
-			t.Errorf("%s: got %d-byte %q want %d-byte %q", tt.name, n, s, len(tt.raw), tt.raw);
+			t.Errorf("%s: got %d-byte %q want %d-byte %q", tt.name, n, s, len(tt.raw), tt.raw)
 		}
 	}
 }
diff --git a/src/pkg/compress/zlib/reader.go b/src/pkg/compress/zlib/reader.go
index cf0eb1b29a..c002589958 100644
--- a/src/pkg/compress/zlib/reader.go
+++ b/src/pkg/compress/zlib/reader.go
@@ -35,21 +35,21 @@ type reader struct {
 func NewInflater(r io.Reader) (io.ReadCloser, os.Error) {
 	z := new(reader);
 	if fr, ok := r.(flate.Reader); ok {
-		z.r = fr;
+		z.r = fr
 	} else {
-		z.r = bufio.NewReader(r);
+		z.r = bufio.NewReader(r)
 	}
 	_, err := io.ReadFull(z.r, z.scratch[0:2]);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	h := uint(z.scratch[0])<<8 | uint(z.scratch[1]);
 	if (z.scratch[0] & 0x0f != zlibDeflate) || (h%31 != 0) {
-		return nil, HeaderError;
+		return nil, HeaderError
 	}
 	if z.scratch[1] & 0x20 != 0 {
 		// BUG(nigeltao): The zlib package does not implement the FDICT flag.
-		return nil, UnsupportedError;
+		return nil, UnsupportedError
 	}
 	z.digest = adler32.New();
 	z.inflater = flate.NewInflater(z.r);
@@ -58,10 +58,10 @@ func NewInflater(r io.Reader) (io.ReadCloser, os.Error) {
 
 func (z *reader) Read(p []byte) (n int, err os.Error) {
 	if z.err != nil {
-		return 0, z.err;
+		return 0, z.err
 	}
 	if len(p) == 0 {
-		return 0, nil;
+		return 0, nil
 	}
 
 	n, err = z.inflater.Read(p);
@@ -88,7 +88,7 @@ func (z *reader) Read(p []byte) (n int, err os.Error) {
 // Calling Close does not close the wrapped io.Reader originally passed to NewInflater.
 func (z *reader) Close() os.Error {
 	if z.err != nil {
-		return z.err;
+		return z.err
 	}
 	z.err = z.inflater.Close();
 	return z.err;
diff --git a/src/pkg/compress/zlib/reader_test.go b/src/pkg/compress/zlib/reader_test.go
index 037c9bf6ff..5e057ee21b 100644
--- a/src/pkg/compress/zlib/reader_test.go
+++ b/src/pkg/compress/zlib/reader_test.go
@@ -74,7 +74,7 @@ func TestInflater(t *testing.T) {
 		zlib, err := NewInflater(in);
 		if err != nil {
 			if err != tt.err {
-				t.Errorf("%s: NewInflater: %s", tt.desc, err);
+				t.Errorf("%s: NewInflater: %s", tt.desc, err)
 			}
 			continue;
 		}
@@ -83,13 +83,13 @@ func TestInflater(t *testing.T) {
 		n, err := io.Copy(b, zlib);
 		if err != nil {
 			if err != tt.err {
-				t.Errorf("%s: io.Copy: %v want %v", tt.desc, err, tt.err);
+				t.Errorf("%s: io.Copy: %v want %v", tt.desc, err, tt.err)
 			}
 			continue;
 		}
 		s := b.String();
 		if s != tt.raw {
-			t.Errorf("%s: got %d-byte %q want %d-byte %q", tt.desc, n, s, len(tt.raw), tt.raw);
+			t.Errorf("%s: got %d-byte %q want %d-byte %q", tt.desc, n, s, len(tt.raw), tt.raw)
 		}
 	}
 }
diff --git a/src/pkg/compress/zlib/writer.go b/src/pkg/compress/zlib/writer.go
index 6c0c0bbd42..9b23b22938 100644
--- a/src/pkg/compress/zlib/writer.go
+++ b/src/pkg/compress/zlib/writer.go
@@ -31,7 +31,7 @@ type writer struct {
 
 // NewDeflater calls NewDeflaterLevel with the default compression level.
 func NewDeflater(w io.Writer) (io.WriteCloser, os.Error) {
-	return NewDeflaterLevel(w, DefaultCompression);
+	return NewDeflaterLevel(w, DefaultCompression)
 }
 
 // NewDeflater creates a new io.WriteCloser that satisfies writes by compressing data written to w.
@@ -50,19 +50,19 @@ func NewDeflaterLevel(w io.Writer, level int) (io.WriteCloser, os.Error) {
 	// The final five FCHECK bits form a mod-31 checksum.
 	switch level {
 	case 0, 1:
-		z.scratch[1] = 0x01;
+		z.scratch[1] = 0x01
 	case 2, 3, 4, 5:
-		z.scratch[1] = 0x5e;
+		z.scratch[1] = 0x5e
 	case 6, -1:
-		z.scratch[1] = 0x9c;
+		z.scratch[1] = 0x9c
 	case 7, 8, 9:
-		z.scratch[1] = 0xda;
+		z.scratch[1] = 0xda
 	default:
-		return nil, os.NewError("level out of range");
+		return nil, os.NewError("level out of range")
 	}
 	_, err := w.Write(z.scratch[0:2]);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	z.w = w;
 	z.deflater = flate.NewDeflater(w, level);
@@ -72,10 +72,10 @@ func NewDeflaterLevel(w io.Writer, level int) (io.WriteCloser, os.Error) {
 
 func (z *writer) Write(p []byte) (n int, err os.Error) {
 	if z.err != nil {
-		return 0, z.err;
+		return 0, z.err
 	}
 	if len(p) == 0 {
-		return 0, nil;
+		return 0, nil
 	}
 	n, err = z.deflater.Write(p);
 	if err != nil {
@@ -89,11 +89,11 @@ func (z *writer) Write(p []byte) (n int, err os.Error) {
 // Calling Close does not close the wrapped io.Writer originally passed to NewDeflater.
 func (z *writer) Close() os.Error {
 	if z.err != nil {
-		return z.err;
+		return z.err
 	}
 	z.err = z.deflater.Close();
 	if z.err != nil {
-		return z.err;
+		return z.err
 	}
 	checksum := z.digest.Sum32();
 	// ZLIB (RFC 1950) is big-endian, unlike GZIP (RFC 1952).
diff --git a/src/pkg/compress/zlib/writer_test.go b/src/pkg/compress/zlib/writer_test.go
index 16e88a6a9a..13c20d9d1c 100644
--- a/src/pkg/compress/zlib/writer_test.go
+++ b/src/pkg/compress/zlib/writer_test.go
@@ -53,14 +53,14 @@ func testFileLevel(t *testing.T, fn string, level int) {
 			_, err1 := zlibw.Write(b[0:n]);
 			if err1 == os.EPIPE {
 				// Fail, but do not report the error, as some other (presumably reportable) error broke the pipe.
-				return;
+				return
 			}
 			if err1 != nil {
 				t.Errorf("%s (level=%d): %v", fn, level, err1);
 				return;
 			}
 			if err0 == os.EOF {
-				break;
+				break
 			}
 		}
 	}();
@@ -99,7 +99,7 @@ func TestWriter(t *testing.T) {
 		testFileLevel(t, fn, DefaultCompression);
 		testFileLevel(t, fn, NoCompression);
 		for level := BestSpeed; level <= BestCompression; level++ {
-			testFileLevel(t, fn, level);
+			testFileLevel(t, fn, level)
 		}
 	}
 }
diff --git a/src/pkg/container/heap/heap.go b/src/pkg/container/heap/heap.go
index 100dcad054..b80805972d 100644
--- a/src/pkg/container/heap/heap.go
+++ b/src/pkg/container/heap/heap.go
@@ -68,7 +68,7 @@ func up(h Interface, j int) {
 	for {
 		i := (j-1)/2;
 		if i == j || h.Less(i, j) {
-			break;
+			break
 		}
 		h.Swap(i, j);
 		j = i;
@@ -80,13 +80,13 @@ func down(h Interface, i, n int) {
 	for {
 		j := 2*i + 1;
 		if j >= n {
-			break;
+			break
 		}
 		if j1 := j+1; j1 < n && !h.Less(j, j1) {
-			j = j1;	// = 2*i + 2
+			j = j1	// = 2*i + 2
 		}
 		if h.Less(i, j) {
-			break;
+			break
 		}
 		h.Swap(i, j);
 		i = j;
diff --git a/src/pkg/container/heap/heap_test.go b/src/pkg/container/heap/heap_test.go
index 2375906b96..3259be8126 100644
--- a/src/pkg/container/heap/heap_test.go
+++ b/src/pkg/container/heap/heap_test.go
@@ -52,7 +52,7 @@ func (h *myHeap) Pop() interface{}	{ return h.IntVector.Pop() }
 func TestInit(t *testing.T) {
 	h := newHeap();
 	for i := 20; i > 0; i-- {
-		h.Push(i);
+		h.Push(i)
 	}
 	Init(h);
 	h.verify(t, 0);
@@ -61,7 +61,7 @@ func TestInit(t *testing.T) {
 		x := Pop(h).(int);
 		h.verify(t, 0);
 		if x != i {
-			t.Errorf("%d.th pop got %d; want %d", i, x, i);
+			t.Errorf("%d.th pop got %d; want %d", i, x, i)
 		}
 	}
 }
@@ -72,7 +72,7 @@ func Test(t *testing.T) {
 	h.verify(t, 0);
 
 	for i := 20; i > 10; i-- {
-		h.Push(i);
+		h.Push(i)
 	}
 	Init(h);
 	h.verify(t, 0);
@@ -85,11 +85,11 @@ func Test(t *testing.T) {
 	for i := 1; h.Len() > 0; i++ {
 		x := Pop(h).(int);
 		if i < 20 {
-			Push(h, 20+i);
+			Push(h, 20+i)
 		}
 		h.verify(t, 0);
 		if x != i {
-			t.Errorf("%d.th pop got %d; want %d", i, x, i);
+			t.Errorf("%d.th pop got %d; want %d", i, x, i)
 		}
 	}
 }
diff --git a/src/pkg/container/list/list.go b/src/pkg/container/list/list.go
index b1f12080f0..b7b392ceaa 100755
--- a/src/pkg/container/list/list.go
+++ b/src/pkg/container/list/list.go
@@ -52,17 +52,17 @@ func (l *List) Back() *Element	{ return l.back }
 // Remove removes the element from the list.
 func (l *List) Remove(e *Element) {
 	if e.id != l.id {
-		return;
+		return
 	}
 	if e.prev == nil {
-		l.front = e.next;
+		l.front = e.next
 	} else {
-		e.prev.next = e.next;
+		e.prev.next = e.next
 	}
 	if e.next == nil {
-		l.back = e.prev;
+		l.back = e.prev
 	} else {
-		e.next.prev = e.prev;
+		e.next.prev = e.prev
 	}
 
 	e.prev = nil;
@@ -73,9 +73,9 @@ func (l *List) Remove(e *Element) {
 func (l *List) insertBefore(e *Element, mark *Element) {
 	if mark.prev == nil {
 		// new front of the list
-		l.front = e;
+		l.front = e
 	} else {
-		mark.prev.next = e;
+		mark.prev.next = e
 	}
 	e.prev = mark.prev;
 	mark.prev = e;
@@ -86,9 +86,9 @@ func (l *List) insertBefore(e *Element, mark *Element) {
 func (l *List) insertAfter(e *Element, mark *Element) {
 	if mark.next == nil {
 		// new back of the list
-		l.back = e;
+		l.back = e
 	} else {
-		mark.next.prev = e;
+		mark.next.prev = e
 	}
 	e.next = mark.next;
 	mark.next = e;
@@ -121,7 +121,7 @@ func (l *List) insertBack(e *Element) {
 // PushFront inserts the value at the front of the list and returns a new Element containing the value.
 func (l *List) PushFront(value interface{}) *Element {
 	if l.id == nil {
-		l.Init();
+		l.Init()
 	}
 	e := &Element{nil, nil, l.id, value};
 	l.insertFront(e);
@@ -131,7 +131,7 @@ func (l *List) PushFront(value interface{}) *Element {
 // PushBack inserts the value at the back of the list and returns a new Element containing the value.
 func (l *List) PushBack(value interface{}) *Element {
 	if l.id == nil {
-		l.Init();
+		l.Init()
 	}
 	e := &Element{nil, nil, l.id, value};
 	l.insertBack(e);
@@ -141,7 +141,7 @@ func (l *List) PushBack(value interface{}) *Element {
 // InsertBefore inserts the value immediately before mark and returns a new Element containing the value.
 func (l *List) InsertBefore(value interface{}, mark *Element) *Element {
 	if mark.id != l.id {
-		return nil;
+		return nil
 	}
 	e := &Element{nil, nil, l.id, value};
 	l.insertBefore(e, mark);
@@ -151,7 +151,7 @@ func (l *List) InsertBefore(value interface{}, mark *Element) *Element {
 // InsertAfter inserts the value immediately after mark and returns a new Element containing the value.
 func (l *List) InsertAfter(value interface{}, mark *Element) *Element {
 	if mark.id != l.id {
-		return nil;
+		return nil
 	}
 	e := &Element{nil, nil, l.id, value};
 	l.insertAfter(e, mark);
@@ -161,7 +161,7 @@ func (l *List) InsertAfter(value interface{}, mark *Element) *Element {
 // MoveToFront moves the element to the front of the list.
 func (l *List) MoveToFront(e *Element) {
 	if e.id != l.id || l.front == e {
-		return;
+		return
 	}
 	l.Remove(e);
 	l.insertFront(e);
@@ -170,7 +170,7 @@ func (l *List) MoveToFront(e *Element) {
 // MoveToBack moves the element to the back of the list.
 func (l *List) MoveToBack(e *Element) {
 	if e.id != l.id || l.back == e {
-		return;
+		return
 	}
 	l.Remove(e);
 	l.insertBack(e);
@@ -181,7 +181,7 @@ func (l *List) Len() int	{ return l.len }
 
 func (l *List) iterate(c chan<- interface{}) {
 	for e := l.front; e != nil; e = e.next {
-		c <- e.Value;
+		c <- e.Value
 	}
 	close(c);
 }
diff --git a/src/pkg/container/list/list_test.go b/src/pkg/container/list/list_test.go
index 5fa9e62c6e..52df37f561 100755
--- a/src/pkg/container/list/list_test.go
+++ b/src/pkg/container/list/list_test.go
@@ -11,39 +11,39 @@ import (
 func checkListPointers(t *testing.T, l *List, es []*Element) {
 	if len(es) == 0 {
 		if l.front != nil || l.back != nil {
-			t.Errorf("l.front/l.back = %v/%v should be nil/nil", l.front, l.back);
+			t.Errorf("l.front/l.back = %v/%v should be nil/nil", l.front, l.back)
 		}
 		return;
 	}
 
 	if l.front != es[0] {
-		t.Errorf("l.front = %v, want %v", l.front, es[0]);
+		t.Errorf("l.front = %v, want %v", l.front, es[0])
 	}
 	if last := es[len(es)-1]; l.back != last {
-		t.Errorf("l.back = %v, want %v", l.back, last);
+		t.Errorf("l.back = %v, want %v", l.back, last)
 	}
 
 	for i := 0; i < len(es); i++ {
 		e := es[i];
 		var e_prev, e_next *Element = nil, nil;
 		if i > 0 {
-			e_prev = es[i-1];
+			e_prev = es[i-1]
 		}
 		if i < len(es)-1 {
-			e_next = es[i+1];
+			e_next = es[i+1]
 		}
 		if e.prev != e_prev {
-			t.Errorf("elt #%d (%v) has prev=%v, want %v", i, e, e.prev, e_prev);
+			t.Errorf("elt #%d (%v) has prev=%v, want %v", i, e, e.prev, e_prev)
 		}
 		if e.next != e_next {
-			t.Errorf("elt #%d (%v) has next=%v, want %v", i, e, e.next, e_next);
+			t.Errorf("elt #%d (%v) has next=%v, want %v", i, e, e.next, e_next)
 		}
 	}
 }
 
 func checkListLen(t *testing.T, l *List, n int) {
 	if an := l.Len(); an != n {
-		t.Errorf("l.Len() = %d, want %d", an, n);
+		t.Errorf("l.Len() = %d, want %d", an, n)
 	}
 }
 
@@ -118,11 +118,11 @@ func TestList(t *testing.T) {
 	sum := 0;
 	for e := range l.Iter() {
 		if i, ok := e.(int); ok {
-			sum += i;
+			sum += i
 		}
 	}
 	if sum != 4 {
-		t.Errorf("sum over l.Iter() = %d, want 4", sum);
+		t.Errorf("sum over l.Iter() = %d, want 4", sum)
 	}
 
 	// Clear all elements by iterating
diff --git a/src/pkg/container/ring/ring.go b/src/pkg/container/ring/ring.go
index 14593f2159..a4b631db0b 100644
--- a/src/pkg/container/ring/ring.go
+++ b/src/pkg/container/ring/ring.go
@@ -27,7 +27,7 @@ func (r *Ring) init() *Ring {
 // Next returns the next ring element. r must not be empty.
 func (r *Ring) Next() *Ring {
 	if r.next == nil {
-		return r.init();
+		return r.init()
 	}
 	return r.next;
 }
@@ -36,7 +36,7 @@ func (r *Ring) Next() *Ring {
 // Prev returns the previous ring element. r must not be empty.
 func (r *Ring) Prev() *Ring {
 	if r.next == nil {
-		return r.init();
+		return r.init()
 	}
 	return r.prev;
 }
@@ -47,16 +47,16 @@ func (r *Ring) Prev() *Ring {
 //
 func (r *Ring) Move(n int) *Ring {
 	if r.next == nil {
-		return r.init();
+		return r.init()
 	}
 	switch {
 	case n < 0:
 		for ; n < 0; n++ {
-			r = r.prev;
+			r = r.prev
 		}
 	case n > 0:
 		for ; n > 0; n-- {
-			r = r.next;
+			r = r.next
 		}
 	}
 	return r;
@@ -66,7 +66,7 @@ func (r *Ring) Move(n int) *Ring {
 // New creates a ring of n elements.
 func New(n int) *Ring {
 	if n <= 0 {
-		return nil;
+		return nil
 	}
 	r := new(Ring);
 	p := r;
@@ -117,7 +117,7 @@ func (r *Ring) Link(s *Ring) *Ring {
 //
 func (r *Ring) Unlink(n int) *Ring {
 	if n <= 0 {
-		return nil;
+		return nil
 	}
 	return r.Link(r.Move(n+1));
 }
@@ -131,7 +131,7 @@ func (r *Ring) Len() int {
 	if r != nil {
 		n = 1;
 		for p := r.Next(); p != r; p = p.next {
-			n++;
+			n++
 		}
 	}
 	return n;
@@ -144,7 +144,7 @@ func (r *Ring) Iter() <-chan interface{} {
 		if r != nil {
 			c <- r.Value;
 			for p := r.Next(); p != r; p = p.next {
-				c <- p.Value;
+				c <- p.Value
 			}
 		}
 		close(c);
diff --git a/src/pkg/container/ring/ring_test.go b/src/pkg/container/ring/ring_test.go
index 7032cdfcff..db6fe42c82 100644
--- a/src/pkg/container/ring/ring_test.go
+++ b/src/pkg/container/ring/ring_test.go
@@ -29,7 +29,7 @@ func verify(t *testing.T, r *Ring, N int, sum int) {
 	// Len
 	n := r.Len();
 	if n != N {
-		t.Errorf("r.Len() == %d; expected %d", n, N);
+		t.Errorf("r.Len() == %d; expected %d", n, N)
 	}
 
 	// iteration
@@ -38,18 +38,18 @@ func verify(t *testing.T, r *Ring, N int, sum int) {
 	for p := range r.Iter() {
 		n++;
 		if p != nil {
-			s += p.(int);
+			s += p.(int)
 		}
 	}
 	if n != N {
-		t.Errorf("number of forward iterations == %d; expected %d", n, N);
+		t.Errorf("number of forward iterations == %d; expected %d", n, N)
 	}
 	if sum >= 0 && s != sum {
-		t.Errorf("forward ring sum = %d; expected %d", s, sum);
+		t.Errorf("forward ring sum = %d; expected %d", s, sum)
 	}
 
 	if r == nil {
-		return;
+		return
 	}
 
 	// connections
@@ -57,41 +57,41 @@ func verify(t *testing.T, r *Ring, N int, sum int) {
 		var p *Ring;	// previous element
 		for q := r; p == nil || q != r; q = q.next {
 			if p != nil && p != q.prev {
-				t.Errorf("prev = %p, expected q.prev = %p\n", p, q.prev);
+				t.Errorf("prev = %p, expected q.prev = %p\n", p, q.prev)
 			}
 			p = q;
 		}
 		if p != r.prev {
-			t.Errorf("prev = %p, expected r.prev = %p\n", p, r.prev);
+			t.Errorf("prev = %p, expected r.prev = %p\n", p, r.prev)
 		}
 	}
 
 	// Next, Prev
 	if r.Next() != r.next {
-		t.Errorf("r.Next() != r.next");
+		t.Errorf("r.Next() != r.next")
 	}
 	if r.Prev() != r.prev {
-		t.Errorf("r.Prev() != r.prev");
+		t.Errorf("r.Prev() != r.prev")
 	}
 
 	// Move
 	if r.Move(0) != r {
-		t.Errorf("r.Move(0) != r");
+		t.Errorf("r.Move(0) != r")
 	}
 	if r.Move(N) != r {
-		t.Errorf("r.Move(%d) != r", N);
+		t.Errorf("r.Move(%d) != r", N)
 	}
 	if r.Move(-N) != r {
-		t.Errorf("r.Move(%d) != r", -N);
+		t.Errorf("r.Move(%d) != r", -N)
 	}
 	for i := 0; i < 10; i++ {
 		ni := N+i;
 		mi := ni%N;
 		if r.Move(ni) != r.Move(mi) {
-			t.Errorf("r.Move(%d) != r.Move(%d)", ni, mi);
+			t.Errorf("r.Move(%d) != r.Move(%d)", ni, mi)
 		}
 		if r.Move(-ni) != r.Move(-mi) {
-			t.Errorf("r.Move(%d) != r.Move(%d)", -ni, -mi);
+			t.Errorf("r.Move(%d) != r.Move(%d)", -ni, -mi)
 		}
 	}
 }
@@ -132,7 +132,7 @@ func makeN(n int) *Ring {
 func sum(r *Ring) int {
 	s := 0;
 	for p := range r.Iter() {
-		s += p.(int);
+		s += p.(int)
 	}
 	return s;
 }
@@ -159,13 +159,13 @@ func TestLink1(t *testing.T) {
 	r2a := r1a.Link(&r1b);
 	verify(t, r2a, 2, 1);
 	if r2a != r1a {
-		t.Errorf("a) 2-element link failed");
+		t.Errorf("a) 2-element link failed")
 	}
 
 	r2b := r2a.Link(r2a.Next());
 	verify(t, r2b, 2, 1);
 	if r2b != r2a.Next() {
-		t.Errorf("b) 2-element link failed");
+		t.Errorf("b) 2-element link failed")
 	}
 
 	r1c := r2b.Link(r2b);
diff --git a/src/pkg/container/vector/intvector.go b/src/pkg/container/vector/intvector.go
index e17d619ad6..75f794f79a 100644
--- a/src/pkg/container/vector/intvector.go
+++ b/src/pkg/container/vector/intvector.go
@@ -40,7 +40,7 @@ func (p *IntVector) Last() int	{ return p.Vector.Last().(int) }
 func (p *IntVector) Data() []int {
 	arr := make([]int, p.Len());
 	for i, v := range p.a {
-		arr[i] = v.(int);
+		arr[i] = v.(int)
 	}
 	return arr;
 }
@@ -54,14 +54,14 @@ func (p *IntVector) Insert(i int, x int)	{ p.Vector.Insert(i, x) }
 // InsertVector inserts into the vector the contents of the Vector
 // x such that the 0th element of x appears at index i after insertion.
 func (p *IntVector) InsertVector(i int, x *IntVector) {
-	p.Vector.InsertVector(i, &x.Vector);
+	p.Vector.InsertVector(i, &x.Vector)
 }
 
 
 // Slice returns a new IntVector by slicing the old one to extract slice [i:j].
 // The elements are copied. The original vector is unchanged.
 func (p *IntVector) Slice(i, j int) *IntVector {
-	return &IntVector{*p.Vector.Slice(i, j)};
+	return &IntVector{*p.Vector.Slice(i, j)}
 }
 
 
@@ -75,7 +75,7 @@ func (p *IntVector) Pop() int	{ return p.Vector.Pop().(int) }
 
 // AppendVector appends the entire IntVector x to the end of this vector.
 func (p *IntVector) AppendVector(x *IntVector) {
-	p.Vector.InsertVector(len(p.a), &x.Vector);
+	p.Vector.InsertVector(len(p.a), &x.Vector)
 }
 
 
@@ -87,7 +87,7 @@ func (p *IntVector) Less(i, j int) bool	{ return p.At(i) < p.At(j) }
 // Iterate over all elements; driver for range
 func (p *IntVector) iterate(c chan<- int) {
 	for _, v := range p.a {
-		c <- v.(int);
+		c <- v.(int)
 	}
 	close(c);
 }
diff --git a/src/pkg/container/vector/stringvector.go b/src/pkg/container/vector/stringvector.go
index c3f31f046e..0178f6be2e 100644
--- a/src/pkg/container/vector/stringvector.go
+++ b/src/pkg/container/vector/stringvector.go
@@ -39,7 +39,7 @@ func (p *StringVector) Last() string	{ return p.Vector.Last().(string) }
 func (p *StringVector) Data() []string {
 	arr := make([]string, p.Len());
 	for i, v := range p.a {
-		arr[i] = v.(string);
+		arr[i] = v.(string)
 	}
 	return arr;
 }
@@ -48,21 +48,21 @@ func (p *StringVector) Data() []string {
 // Insert inserts into the vector an element of value x before
 // the current element at index i.
 func (p *StringVector) Insert(i int, x string) {
-	p.Vector.Insert(i, x);
+	p.Vector.Insert(i, x)
 }
 
 
 // InsertVector inserts into the vector the contents of the Vector
 // x such that the 0th element of x appears at index i after insertion.
 func (p *StringVector) InsertVector(i int, x *StringVector) {
-	p.Vector.InsertVector(i, &x.Vector);
+	p.Vector.InsertVector(i, &x.Vector)
 }
 
 
 // Slice returns a new StringVector by slicing the old one to extract slice [i:j].
 // The elements are copied. The original vector is unchanged.
 func (p *StringVector) Slice(i, j int) *StringVector {
-	return &StringVector{*p.Vector.Slice(i, j)};
+	return &StringVector{*p.Vector.Slice(i, j)}
 }
 
 
@@ -76,7 +76,7 @@ func (p *StringVector) Pop() string	{ return p.Vector.Pop().(string) }
 
 // AppendVector appends the entire StringVector x to the end of this vector.
 func (p *StringVector) AppendVector(x *StringVector) {
-	p.Vector.InsertVector(len(p.a), &x.Vector);
+	p.Vector.InsertVector(len(p.a), &x.Vector)
 }
 
 
@@ -88,7 +88,7 @@ func (p *StringVector) Less(i, j int) bool	{ return p.At(i) < p.At(j) }
 // Iterate over all elements; driver for range
 func (p *StringVector) iterate(c chan<- string) {
 	for _, v := range p.a {
-		c <- v.(string);
+		c <- v.(string)
 	}
 	close(c);
 }
diff --git a/src/pkg/container/vector/vector.go b/src/pkg/container/vector/vector.go
index ee19997fb7..97c917a7e7 100644
--- a/src/pkg/container/vector/vector.go
+++ b/src/pkg/container/vector/vector.go
@@ -20,7 +20,7 @@ type Vector struct {
 
 func copy(dst, src []Element) {
 	for i := 0; i < len(src); i++ {
-		dst[i] = src[i];
+		dst[i] = src[i]
 	}
 }
 
@@ -32,13 +32,13 @@ func expand(a []Element, i, n int) []Element {
 	len1 := len0+n;
 	if len1 < cap(a) {
 		// enough space - just expand
-		a = a[0:len1];
+		a = a[0:len1]
 	} else {
 		// not enough space - double capacity
 		capb := cap(a)*2;
 		if capb < len1 {
 			// still not enough - use required length
-			capb = len1;
+			capb = len1
 		}
 		// capb >= len1
 		b := make([]Element, len1, capb);
@@ -48,7 +48,7 @@ func expand(a []Element, i, n int) []Element {
 
 	// make a hole
 	for j := len0-1; j >= i; j-- {
-		a[j+n] = a[j];
+		a[j+n] = a[j]
 	}
 	return a;
 }
@@ -63,13 +63,13 @@ func (p *Vector) Init(initial_len int) *Vector {
 	if cap(a) == 0 || cap(a) < initial_len {
 		n := 8;	// initial capacity
 		if initial_len > n {
-			n = initial_len;
+			n = initial_len
 		}
 		a = make([]Element, n);
 	} else {
 		// nil out entries
 		for j := len(a)-1; j >= 0; j-- {
-			a[j] = nil;
+			a[j] = nil
 		}
 	}
 
@@ -86,7 +86,7 @@ func New(len int) *Vector	{ return new(Vector).Init(len) }
 // Len is 0 if p == nil.
 func (p *Vector) Len() int {
 	if p == nil {
-		return 0;
+		return 0
 	}
 	return len(p.a);
 }
@@ -108,7 +108,7 @@ func (p *Vector) Last() Element	{ return p.a[len(p.a)-1] }
 func (p *Vector) Data() []Element {
 	arr := make([]Element, p.Len());
 	for i, v := range p.a {
-		arr[i] = v;
+		arr[i] = v
 	}
 	return arr;
 }
@@ -150,7 +150,7 @@ func (p *Vector) Cut(i, j int) {
 
 	copy(a[i:m], a[j:n]);
 	for k := m; k < n; k++ {
-		a[k] = nil;	// support GC, nil out entries
+		a[k] = nil	// support GC, nil out entries
 	}
 
 	p.a = a[0:m];
@@ -170,7 +170,7 @@ func (p *Vector) Slice(i, j int) *Vector {
 // The function should not change the indexing of the vector underfoot.
 func (p *Vector) Do(f func(elem Element)) {
 	for i := 0; i < len(p.a); i++ {
-		f(p.a[i]);	// not too safe if f changes the Vector
+		f(p.a[i])	// not too safe if f changes the Vector
 	}
 }
 
@@ -217,7 +217,7 @@ func (p *Vector) Swap(i, j int) {
 // Iterate over all elements; driver for range
 func (p *Vector) iterate(c chan<- Element) {
 	for _, v := range p.a {
-		c <- v;
+		c <- v
 	}
 	close(c);
 }
diff --git a/src/pkg/container/vector/vector_test.go b/src/pkg/container/vector/vector_test.go
index 12a8aa0771..4e242601dd 100644
--- a/src/pkg/container/vector/vector_test.go
+++ b/src/pkg/container/vector/vector_test.go
@@ -12,11 +12,11 @@ import "fmt"
 func TestZeroLen(t *testing.T) {
 	var a *Vector;
 	if a.Len() != 0 {
-		t.Errorf("A) expected 0, got %d", a.Len());
+		t.Errorf("A) expected 0, got %d", a.Len())
 	}
 	a = New(0);
 	if a.Len() != 0 {
-		t.Errorf("B) expected 0, got %d", a.Len());
+		t.Errorf("B) expected 0, got %d", a.Len())
 	}
 }
 
@@ -24,26 +24,26 @@ func TestZeroLen(t *testing.T) {
 func TestInit(t *testing.T) {
 	var a Vector;
 	if a.Init(0).Len() != 0 {
-		t.Error("A");
+		t.Error("A")
 	}
 	if a.Init(1).Len() != 1 {
-		t.Error("B");
+		t.Error("B")
 	}
 	if a.Init(10).Len() != 10 {
-		t.Error("C");
+		t.Error("C")
 	}
 }
 
 
 func TestNew(t *testing.T) {
 	if New(0).Len() != 0 {
-		t.Error("A");
+		t.Error("A")
 	}
 	if New(1).Len() != 1 {
-		t.Error("B");
+		t.Error("B")
 	}
 	if New(10).Len() != 10 {
-		t.Error("C");
+		t.Error("C")
 	}
 }
 
@@ -56,11 +56,11 @@ func TestAccess(t *testing.T) {
 	var a Vector;
 	a.Init(n);
 	for i := 0; i < n; i++ {
-		a.Set(i, val(i));
+		a.Set(i, val(i))
 	}
 	for i := 0; i < n; i++ {
 		if a.At(i).(int) != val(i) {
-			t.Error(i);
+			t.Error(i)
 		}
 	}
 }
@@ -72,41 +72,41 @@ func TestInsertDeleteClear(t *testing.T) {
 
 	for i := 0; i < n; i++ {
 		if a.Len() != i {
-			t.Errorf("A) wrong len %d (expected %d)", a.Len(), i);
+			t.Errorf("A) wrong len %d (expected %d)", a.Len(), i)
 		}
 		a.Insert(0, val(i));
 		if a.Last().(int) != val(0) {
-			t.Error("B");
+			t.Error("B")
 		}
 	}
 	for i := n-1; i >= 0; i-- {
 		if a.Last().(int) != val(0) {
-			t.Error("C");
+			t.Error("C")
 		}
 		if a.At(0).(int) != val(i) {
-			t.Error("D");
+			t.Error("D")
 		}
 		a.Delete(0);
 		if a.Len() != i {
-			t.Errorf("E) wrong len %d (expected %d)", a.Len(), i);
+			t.Errorf("E) wrong len %d (expected %d)", a.Len(), i)
 		}
 	}
 
 	if a.Len() != 0 {
-		t.Errorf("F) wrong len %d (expected 0)", a.Len());
+		t.Errorf("F) wrong len %d (expected 0)", a.Len())
 	}
 	for i := 0; i < n; i++ {
 		a.Push(val(i));
 		if a.Len() != i+1 {
-			t.Errorf("G) wrong len %d (expected %d)", a.Len(), i+1);
+			t.Errorf("G) wrong len %d (expected %d)", a.Len(), i+1)
 		}
 		if a.Last().(int) != val(i) {
-			t.Error("H");
+			t.Error("H")
 		}
 	}
 	a.Init(0);
 	if a.Len() != 0 {
-		t.Errorf("I wrong len %d (expected 0)", a.Len());
+		t.Errorf("I wrong len %d (expected 0)", a.Len())
 	}
 
 	const m = 5;
@@ -116,15 +116,15 @@ func TestInsertDeleteClear(t *testing.T) {
 			x := val(i);
 			a.Push(x);
 			if a.Pop().(int) != x {
-				t.Error("J");
+				t.Error("J")
 			}
 			if a.Len() != j+1 {
-				t.Errorf("K) wrong len %d (expected %d)", a.Len(), j+1);
+				t.Errorf("K) wrong len %d (expected %d)", a.Len(), j+1)
 			}
 		}
 	}
 	if a.Len() != m {
-		t.Errorf("L) wrong len %d (expected %d)", a.Len(), m);
+		t.Errorf("L) wrong len %d (expected %d)", a.Len(), m)
 	}
 }
 
@@ -132,14 +132,14 @@ func TestInsertDeleteClear(t *testing.T) {
 func verify_slice(t *testing.T, x *Vector, elt, i, j int) {
 	for k := i; k < j; k++ {
 		if x.At(k).(int) != elt {
-			t.Errorf("M) wrong [%d] element %d (expected %d)", k, x.At(k).(int), elt);
+			t.Errorf("M) wrong [%d] element %d (expected %d)", k, x.At(k).(int), elt)
 		}
 	}
 
 	s := x.Slice(i, j);
 	for k, n := 0, j-i; k < n; k++ {
 		if s.At(k).(int) != elt {
-			t.Errorf("N) wrong [%d] element %d (expected %d)", k, x.At(k).(int), elt);
+			t.Errorf("N) wrong [%d] element %d (expected %d)", k, x.At(k).(int), elt)
 		}
 	}
 }
@@ -148,7 +148,7 @@ func verify_slice(t *testing.T, x *Vector, elt, i, j int) {
 func verify_pattern(t *testing.T, x *Vector, a, b, c int) {
 	n := a+b+c;
 	if x.Len() != n {
-		t.Errorf("O) wrong len %d (expected %d)", x.Len(), n);
+		t.Errorf("O) wrong len %d (expected %d)", x.Len(), n)
 	}
 	verify_slice(t, x, 0, 0, a);
 	verify_slice(t, x, 1, a, a+b);
@@ -159,7 +159,7 @@ func verify_pattern(t *testing.T, x *Vector, a, b, c int) {
 func make_vector(elt, len int) *Vector {
 	x := New(len);
 	for i := 0; i < len; i++ {
-		x.Set(i, elt);
+		x.Set(i, elt)
 	}
 	return x;
 }
@@ -195,18 +195,18 @@ func TestSorting(t *testing.T) {
 
 	a := NewIntVector(n);
 	for i := n-1; i >= 0; i-- {
-		a.Set(i, n-1-i);
+		a.Set(i, n-1-i)
 	}
 	if sort.IsSorted(a) {
-		t.Error("int vector not sorted");
+		t.Error("int vector not sorted")
 	}
 
 	b := NewStringVector(n);
 	for i := n-1; i >= 0; i-- {
-		b.Set(i, fmt.Sprint(n-1-i));
+		b.Set(i, fmt.Sprint(n-1-i))
 	}
 	if sort.IsSorted(b) {
-		t.Error("string vector not sorted");
+		t.Error("string vector not sorted")
 	}
 }
 
@@ -216,18 +216,18 @@ func TestDo(t *testing.T) {
 	const salt = 17;
 	a := NewIntVector(n);
 	for i := 0; i < n; i++ {
-		a.Set(i, salt*i);
+		a.Set(i, salt*i)
 	}
 	count := 0;
 	a.Do(func(e Element) {
 		i := e.(int);
 		if i != count*salt {
-			t.Error("value at", count, "should be", count*salt, "not", i);
+			t.Error("value at", count, "should be", count*salt, "not", i)
 		}
 		count++;
 	});
 	if count != n {
-		t.Error("should visit", n, "values; did visit", count);
+		t.Error("should visit", n, "values; did visit", count)
 	}
 }
 
@@ -236,16 +236,16 @@ func TestIter(t *testing.T) {
 	const Len = 100;
 	x := New(Len);
 	for i := 0; i < Len; i++ {
-		x.Set(i, i*i);
+		x.Set(i, i*i)
 	}
 	i := 0;
 	for v := range x.Iter() {
 		if v.(int) != i*i {
-			t.Error("Iter expected", i*i, "got", v.(int));
+			t.Error("Iter expected", i*i, "got", v.(int))
 		}
 		i++;
 	}
 	if i != Len {
-		t.Error("Iter stopped at", i, "not", Len);
+		t.Error("Iter stopped at", i, "not", Len)
 	}
 }
diff --git a/src/pkg/crypto/aes/aes_test.go b/src/pkg/crypto/aes/aes_test.go
index 4bdf358f65..d3a6b2b729 100644
--- a/src/pkg/crypto/aes/aes_test.go
+++ b/src/pkg/crypto/aes/aes_test.go
@@ -16,11 +16,11 @@ func TestPowx(t *testing.T) {
 	p := 1;
 	for i := 0; i < len(powx); i++ {
 		if powx[i] != byte(p) {
-			t.Errorf("powx[%d] = %#x, want %#x", i, powx[i], p);
+			t.Errorf("powx[%d] = %#x, want %#x", i, powx[i], p)
 		}
 		p <<= 1;
 		if p&0x100 != 0 {
-			p ^= poly;
+			p ^= poly
 		}
 	}
 }
@@ -42,7 +42,7 @@ func mul(b, c uint32) uint32 {
 		// i *= x in GF(2) modulo the polynomial
 		i <<= 1;
 		if i&0x100 != 0 {
-			i ^= poly;
+			i ^= poly
 		}
 	}
 	return s;
@@ -57,12 +57,12 @@ func TestMul(t *testing.T) {
 			for k := uint(0); k < 8; k++ {
 				for l := uint(0); l < 8; l++ {
 					if i&(1<<k) != 0 && j&(1<<l) != 0 {
-						s ^= powx[k+l];
+						s ^= powx[k+l]
 					}
 				}
 			}
 			if x := mul(i, j); x != uint32(s) {
-				t.Fatalf("mul(%#x, %#x) = %#x, want %#x", i, j, x, s);
+				t.Fatalf("mul(%#x, %#x) = %#x, want %#x", i, j, x, s)
 			}
 		}
 	}
@@ -75,10 +75,10 @@ func TestMul(t *testing.T) {
 func TestSboxes(t *testing.T) {
 	for i := 0; i < 256; i++ {
 		if j := sbox0[sbox1[i]]; j != byte(i) {
-			t.Errorf("sbox0[sbox1[%#x]] = %#x", i, j);
+			t.Errorf("sbox0[sbox1[%#x]] = %#x", i, j)
 		}
 		if j := sbox1[sbox0[i]]; j != byte(i) {
-			t.Errorf("sbox1[sbox0[%#x]] = %#x", i, j);
+			t.Errorf("sbox1[sbox0[%#x]] = %#x", i, j)
 		}
 	}
 }
@@ -93,7 +93,7 @@ func TestTe(t *testing.T) {
 		w := s2<<24 | s<<16 | s<<8 | s3;
 		for j := 0; j < 4; j++ {
 			if x := te[j][i]; x != w {
-				t.Fatalf("te[%d][%d] = %#x, want %#x", j, i, x, w);
+				t.Fatalf("te[%d][%d] = %#x, want %#x", j, i, x, w)
 			}
 			w = w<<24 | w>>8;
 		}
@@ -112,7 +112,7 @@ func TestTd(t *testing.T) {
 		w := se<<24 | s9<<16 | sd<<8 | sb;
 		for j := 0; j < 4; j++ {
 			if x := td[j][i]; x != w {
-				t.Fatalf("td[%d][%d] = %#x, want %#x", j, i, x, w);
+				t.Fatalf("td[%d][%d] = %#x, want %#x", j, i, x, w)
 			}
 			w = w<<24 | w>>8;
 		}
@@ -217,7 +217,7 @@ L:
 		enc := make([]uint32, len(tt.enc));
 		var dec []uint32;
 		if tt.dec != nil {
-			dec = make([]uint32, len(tt.dec));
+			dec = make([]uint32, len(tt.dec))
 		}
 		expandKey(tt.key, enc, dec);
 		for j, v := range enc {
diff --git a/src/pkg/crypto/aes/block.go b/src/pkg/crypto/aes/block.go
index 9699830195..c8870af1a7 100644
--- a/src/pkg/crypto/aes/block.go
+++ b/src/pkg/crypto/aes/block.go
@@ -131,7 +131,7 @@ func subw(w uint32) uint32 {
 	return uint32(sbox0[w>>24])<<24 |
 		uint32(sbox0[w>>16&0xff])<<16 |
 		uint32(sbox0[w>>8&0xff])<<8 |
-		uint32(sbox0[w&0xff]);
+		uint32(sbox0[w&0xff])
 }
 
 // Rotate
@@ -144,14 +144,14 @@ func expandKey(key []byte, enc, dec []uint32) {
 	var i int;
 	nk := len(key)/4;
 	for i = 0; i < nk; i++ {
-		enc[i] = uint32(key[4*i])<<24 | uint32(key[4*i + 1])<<16 | uint32(key[4*i + 2])<<8 | uint32(key[4*i + 3]);
+		enc[i] = uint32(key[4*i])<<24 | uint32(key[4*i + 1])<<16 | uint32(key[4*i + 2])<<8 | uint32(key[4*i + 3])
 	}
 	for ; i < len(enc); i++ {
 		t := enc[i-1];
 		if i%nk == 0 {
-			t = subw(rotw(t))^(uint32(powx[i/nk - 1])<<24);
+			t = subw(rotw(t))^(uint32(powx[i/nk - 1])<<24)
 		} else if nk > 6 && i%nk == 4 {
-			t = subw(t);
+			t = subw(t)
 		}
 		enc[i] = enc[i-nk]^t;
 	}
@@ -160,7 +160,7 @@ func expandKey(key []byte, enc, dec []uint32) {
 	// Reverse the 4-word round key sets from enc to produce dec.
 	// All sets but the first and last get the MixColumn transform applied.
 	if dec == nil {
-		return;
+		return
 	}
 	n := len(enc);
 	for i := 0; i < n; i += 4 {
@@ -168,7 +168,7 @@ func expandKey(key []byte, enc, dec []uint32) {
 		for j := 0; j < 4; j++ {
 			x := enc[ei+j];
 			if i > 0 && i+4 < n {
-				x = td[0][sbox0[x>>24]]^td[1][sbox0[x>>16&0xff]]^td[2][sbox0[x>>8&0xff]]^td[3][sbox0[x&0xff]];
+				x = td[0][sbox0[x>>24]]^td[1][sbox0[x>>16&0xff]]^td[2][sbox0[x>>8&0xff]]^td[3][sbox0[x&0xff]]
 			}
 			dec[i+j] = x;
 		}
diff --git a/src/pkg/crypto/aes/cipher.go b/src/pkg/crypto/aes/cipher.go
index 4112725491..fba5863cf1 100644
--- a/src/pkg/crypto/aes/cipher.go
+++ b/src/pkg/crypto/aes/cipher.go
@@ -21,7 +21,7 @@ type Cipher struct {
 type KeySizeError int
 
 func (k KeySizeError) String() string {
-	return "crypto/aes: invalid key size " + strconv.Itoa(int(k));
+	return "crypto/aes: invalid key size " + strconv.Itoa(int(k))
 }
 
 // NewCipher creates and returns a new Cipher.
@@ -32,9 +32,9 @@ func NewCipher(key []byte) (*Cipher, os.Error) {
 	k := len(key);
 	switch k {
 	default:
-		return nil, KeySizeError(k);
+		return nil, KeySizeError(k)
 	case 16, 24, 32:
-		break;
+		break
 	}
 
 	n := k+28;
@@ -63,9 +63,9 @@ func (c *Cipher) Decrypt(src, dst []byte)	{ decryptBlock(c.dec, src, dst) }
 // appear in the process's memory.
 func (c *Cipher) Reset() {
 	for i := 0; i < len(c.enc); i++ {
-		c.enc[i] = 0;
+		c.enc[i] = 0
 	}
 	for i := 0; i < len(c.dec); i++ {
-		c.dec[i] = 0;
+		c.dec[i] = 0
 	}
 }
diff --git a/src/pkg/crypto/block/cbc.go b/src/pkg/crypto/block/cbc.go
index 47aa8f32d9..ac41ab1fbe 100644
--- a/src/pkg/crypto/block/cbc.go
+++ b/src/pkg/crypto/block/cbc.go
@@ -36,11 +36,11 @@ func (x *cbcCipher) BlockSize() int	{ return x.blockSize }
 
 func (x *cbcCipher) Encrypt(src, dst []byte) {
 	for i := 0; i < x.blockSize; i++ {
-		x.iv[i] ^= src[i];
+		x.iv[i] ^= src[i]
 	}
 	x.c.Encrypt(x.iv, x.iv);
 	for i := 0; i < x.blockSize; i++ {
-		dst[i] = x.iv[i];
+		dst[i] = x.iv[i]
 	}
 }
 
@@ -58,7 +58,7 @@ func (x *cbcCipher) Decrypt(src, dst []byte) {
 // The returned Reader does not buffer or read ahead except
 // as required by the cipher's block size.
 func NewCBCDecrypter(c Cipher, iv []byte, r io.Reader) io.Reader {
-	return NewECBDecrypter(newCBC(c, iv), r);
+	return NewECBDecrypter(newCBC(c, iv), r)
 }
 
 // NewCBCEncrypter returns a writer that encrypts data using c
@@ -67,5 +67,5 @@ func NewCBCDecrypter(c Cipher, iv []byte, r io.Reader) io.Reader {
 // The returned Writer does no buffering except as required
 // by the cipher's block size, so there is no need for a Flush method.
 func NewCBCEncrypter(c Cipher, iv []byte, w io.Writer) io.Writer {
-	return NewECBEncrypter(newCBC(c, iv), w);
+	return NewECBEncrypter(newCBC(c, iv), w)
 }
diff --git a/src/pkg/crypto/block/cbc_aes_test.go b/src/pkg/crypto/block/cbc_aes_test.go
index 5149e058c6..02c58fabdd 100644
--- a/src/pkg/crypto/block/cbc_aes_test.go
+++ b/src/pkg/crypto/block/cbc_aes_test.go
@@ -80,9 +80,9 @@ func TestCBC_AES(t *testing.T) {
 		var r io.Reader = bytes.NewBuffer(tt.in);
 		n, err := io.Copy(w, r);
 		if n != int64(len(tt.in)) || err != nil {
-			t.Errorf("%s: CBCEncrypter io.Copy = %d, %v want %d, nil", test, n, err, len(tt.in));
+			t.Errorf("%s: CBCEncrypter io.Copy = %d, %v want %d, nil", test, n, err, len(tt.in))
 		} else if d := crypt.Bytes(); !same(tt.out, d) {
-			t.Errorf("%s: CBCEncrypter\nhave %x\nwant %x", test, d, tt.out);
+			t.Errorf("%s: CBCEncrypter\nhave %x\nwant %x", test, d, tt.out)
 		}
 
 		var plain bytes.Buffer;
@@ -90,13 +90,13 @@ func TestCBC_AES(t *testing.T) {
 		w = &plain;
 		n, err = io.Copy(w, r);
 		if n != int64(len(tt.out)) || err != nil {
-			t.Errorf("%s: CBCDecrypter io.Copy = %d, %v want %d, nil", test, n, err, len(tt.out));
+			t.Errorf("%s: CBCDecrypter io.Copy = %d, %v want %d, nil", test, n, err, len(tt.out))
 		} else if d := plain.Bytes(); !same(tt.in, d) {
-			t.Errorf("%s: CBCDecrypter\nhave %x\nwant %x", test, d, tt.in);
+			t.Errorf("%s: CBCDecrypter\nhave %x\nwant %x", test, d, tt.in)
 		}
 
 		if t.Failed() {
-			break;
+			break
 		}
 	}
 }
diff --git a/src/pkg/crypto/block/cfb.go b/src/pkg/crypto/block/cfb.go
index f515bdcfd6..b07ea31389 100644
--- a/src/pkg/crypto/block/cfb.go
+++ b/src/pkg/crypto/block/cfb.go
@@ -26,7 +26,7 @@ type cfbCipher struct {
 
 func newCFB(c Cipher, s int, iv []byte) *cfbCipher {
 	if s == 0 || s%8 != 0 {
-		panicln("crypto/block: invalid CFB mode", s);
+		panicln("crypto/block: invalid CFB mode", s)
 	}
 	b := c.BlockSize();
 	x := new(cfbCipher);
@@ -44,16 +44,16 @@ func (x *cfbCipher) Encrypt(src, dst []byte) {
 	// Encrypt old IV and xor prefix with src to make dst.
 	x.c.Encrypt(x.iv, x.tmp);
 	for i := 0; i < x.blockSize; i++ {
-		dst[i] = src[i] ^ x.tmp[i];
+		dst[i] = src[i] ^ x.tmp[i]
 	}
 
 	// Slide unused IV pieces down and insert dst at end.
 	for i := 0; i < x.cipherSize - x.blockSize; i++ {
-		x.iv[i] = x.iv[i + x.blockSize];
+		x.iv[i] = x.iv[i + x.blockSize]
 	}
 	off := x.cipherSize - x.blockSize;
 	for i := off; i < x.cipherSize; i++ {
-		x.iv[i] = dst[i-off];
+		x.iv[i] = dst[i-off]
 	}
 }
 
@@ -61,18 +61,18 @@ func (x *cfbCipher) Decrypt(src, dst []byte) {
 	// Encrypt [sic] old IV and xor prefix with src to make dst.
 	x.c.Encrypt(x.iv, x.tmp);
 	for i := 0; i < x.blockSize; i++ {
-		dst[i] = src[i] ^ x.tmp[i];
+		dst[i] = src[i] ^ x.tmp[i]
 	}
 
 	// Slide unused IV pieces down and insert src at top.
 	for i := 0; i < x.cipherSize - x.blockSize; i++ {
-		x.iv[i] = x.iv[i + x.blockSize];
+		x.iv[i] = x.iv[i + x.blockSize]
 	}
 	off := x.cipherSize - x.blockSize;
 	for i := off; i < x.cipherSize; i++ {
 		// Reconstruct src = dst ^ x.tmp
 		// in case we overwrote src (src == dst).
-		x.iv[i] = dst[i-off] ^ x.tmp[i-off];
+		x.iv[i] = dst[i-off] ^ x.tmp[i-off]
 	}
 }
 
@@ -82,7 +82,7 @@ func (x *cfbCipher) Decrypt(src, dst []byte) {
 // as required by the cipher's block size.
 // Modes for s not a multiple of 8 are unimplemented.
 func NewCFBDecrypter(c Cipher, s int, iv []byte, r io.Reader) io.Reader {
-	return NewECBDecrypter(newCFB(c, s, iv), r);
+	return NewECBDecrypter(newCFB(c, s, iv), r)
 }
 
 // NewCFBEncrypter returns a writer that encrypts data using c
@@ -92,5 +92,5 @@ func NewCFBDecrypter(c Cipher, s int, iv []byte, r io.Reader) io.Reader {
 // by the cipher's block size, so there is no need for a Flush method.
 // Modes for s not a multiple of 8 are unimplemented.
 func NewCFBEncrypter(c Cipher, s int, iv []byte, w io.Writer) io.Writer {
-	return NewECBEncrypter(newCFB(c, s, iv), w);
+	return NewECBEncrypter(newCFB(c, s, iv), w)
 }
diff --git a/src/pkg/crypto/block/cfb_aes_test.go b/src/pkg/crypto/block/cfb_aes_test.go
index 521ebd1d28..f1913691b9 100644
--- a/src/pkg/crypto/block/cfb_aes_test.go
+++ b/src/pkg/crypto/block/cfb_aes_test.go
@@ -275,7 +275,7 @@ func TestCFB_AES(t *testing.T) {
 
 		if tt.s == 1 {
 			// 1-bit CFB not implemented
-			continue;
+			continue
 		}
 
 		c, err := aes.NewCipher(tt.key);
@@ -289,9 +289,9 @@ func TestCFB_AES(t *testing.T) {
 		var r io.Reader = bytes.NewBuffer(tt.in);
 		n, err := io.Copy(w, r);
 		if n != int64(len(tt.in)) || err != nil {
-			t.Errorf("%s: CFBEncrypter io.Copy = %d, %v want %d, nil", test, n, err, len(tt.in));
+			t.Errorf("%s: CFBEncrypter io.Copy = %d, %v want %d, nil", test, n, err, len(tt.in))
 		} else if d := crypt.Bytes(); !same(tt.out, d) {
-			t.Errorf("%s: CFBEncrypter\nhave %x\nwant %x", test, d, tt.out);
+			t.Errorf("%s: CFBEncrypter\nhave %x\nwant %x", test, d, tt.out)
 		}
 
 		var plain bytes.Buffer;
@@ -299,13 +299,13 @@ func TestCFB_AES(t *testing.T) {
 		w = &plain;
 		n, err = io.Copy(w, r);
 		if n != int64(len(tt.out)) || err != nil {
-			t.Errorf("%s: CFBDecrypter io.Copy = %d, %v want %d, nil", test, n, err, len(tt.out));
+			t.Errorf("%s: CFBDecrypter io.Copy = %d, %v want %d, nil", test, n, err, len(tt.out))
 		} else if d := plain.Bytes(); !same(tt.in, d) {
-			t.Errorf("%s: CFBDecrypter\nhave %x\nwant %x", test, d, tt.in);
+			t.Errorf("%s: CFBDecrypter\nhave %x\nwant %x", test, d, tt.in)
 		}
 
 		if t.Failed() {
-			break;
+			break
 		}
 	}
 }
diff --git a/src/pkg/crypto/block/cipher.go b/src/pkg/crypto/block/cipher.go
index 8bff1b8782..37ffebfa07 100644
--- a/src/pkg/crypto/block/cipher.go
+++ b/src/pkg/crypto/block/cipher.go
@@ -39,11 +39,11 @@ func shift1(src, dst []byte) byte {
 
 func same(p, q []byte) bool {
 	if len(p) != len(q) {
-		return false;
+		return false
 	}
 	for i := 0; i < len(p); i++ {
 		if p[i] != q[i] {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -52,7 +52,7 @@ func same(p, q []byte) bool {
 func copy(p []byte) []byte {
 	q := make([]byte, len(p));
 	for i, b := range p {
-		q[i] = b;
+		q[i] = b
 	}
 	return q;
 }
diff --git a/src/pkg/crypto/block/cmac.go b/src/pkg/crypto/block/cmac.go
index f57e641746..9b29316e6a 100644
--- a/src/pkg/crypto/block/cmac.go
+++ b/src/pkg/crypto/block/cmac.go
@@ -33,11 +33,11 @@ func NewCMAC(c Cipher) hash.Hash {
 	n := c.BlockSize();
 	switch n {
 	case 64/8:
-		r = r64;
+		r = r64
 	case 128/8:
-		r = r128;
+		r = r128
 	default:
-		panic("crypto/block: NewCMAC: invalid cipher block size", n);
+		panic("crypto/block: NewCMAC: invalid cipher block size", n)
 	}
 
 	d := new(cmac);
@@ -50,10 +50,10 @@ func NewCMAC(c Cipher) hash.Hash {
 	// Subkey generation, p. 7
 	c.Encrypt(d.k1, d.k1);
 	if shift1(d.k1, d.k1) != 0 {
-		d.k1[n-1] ^= r;
+		d.k1[n-1] ^= r
 	}
 	if shift1(d.k1, d.k2) != 0 {
-		d.k2[n-1] ^= r;
+		d.k2[n-1] ^= r
 	}
 
 	return d;
@@ -62,7 +62,7 @@ func NewCMAC(c Cipher) hash.Hash {
 // Reset clears the digest state, starting a new digest.
 func (d *cmac) Reset() {
 	for i := range d.ci {
-		d.ci[i] = 0;
+		d.ci[i] = 0
 	}
 	d.p = 0;
 }
@@ -90,13 +90,13 @@ func (d *cmac) Sum() []byte {
 	// to keep digesting after call to Sum.
 	k := d.k1;
 	if d.p < len(d.digest) {
-		k = d.k2;
+		k = d.k2
 	}
 	for i := 0; i < len(d.ci); i++ {
-		d.digest[i] = d.ci[i] ^ k[i];
+		d.digest[i] = d.ci[i] ^ k[i]
 	}
 	if d.p < len(d.digest) {
-		d.digest[d.p] ^= 0x80;
+		d.digest[d.p] ^= 0x80
 	}
 	d.c.Encrypt(d.digest, d.digest);
 	return d.digest;
diff --git a/src/pkg/crypto/block/ctr.go b/src/pkg/crypto/block/ctr.go
index 1e238c43c7..1733a8de10 100644
--- a/src/pkg/crypto/block/ctr.go
+++ b/src/pkg/crypto/block/ctr.go
@@ -38,7 +38,7 @@ func (x *ctrStream) Next() []byte {
 	for i := len(x.ctr)-1; i >= 0; i-- {
 		x.ctr[i]++;
 		if x.ctr[i] != 0 {
-			break;
+			break
 		}
 	}
 
@@ -52,7 +52,7 @@ func (x *ctrStream) Next() []byte {
 // a CTR reader applied to an encrypted stream produces a decrypted
 // stream and vice versa.
 func NewCTRReader(c Cipher, iv []byte, r io.Reader) io.Reader {
-	return newXorReader(newCTRStream(c, iv), r);
+	return newXorReader(newCTRStream(c, iv), r)
 }
 
 // NewCTRWriter returns a writer that encrypts (or decrypts) data using c
@@ -63,5 +63,5 @@ func NewCTRReader(c Cipher, iv []byte, r io.Reader) io.Reader {
 // a CTR writer applied to an decrypted stream produces an encrypted
 // stream and vice versa.
 func NewCTRWriter(c Cipher, iv []byte, w io.Writer) io.Writer {
-	return newXorWriter(newCTRStream(c, iv), w);
+	return newXorWriter(newCTRStream(c, iv), w)
 }
diff --git a/src/pkg/crypto/block/ctr_aes_test.go b/src/pkg/crypto/block/ctr_aes_test.go
index 5cef931841..456c07131b 100644
--- a/src/pkg/crypto/block/ctr_aes_test.go
+++ b/src/pkg/crypto/block/ctr_aes_test.go
@@ -84,9 +84,9 @@ func TestCTR_AES(t *testing.T) {
 			var r io.Reader = bytes.NewBuffer(in);
 			n, err := io.Copy(w, r);
 			if n != int64(len(in)) || err != nil {
-				t.Errorf("%s/%d: CTRWriter io.Copy = %d, %v want %d, nil", test, len(in), n, err, len(in));
+				t.Errorf("%s/%d: CTRWriter io.Copy = %d, %v want %d, nil", test, len(in), n, err, len(in))
 			} else if d, out := crypt.Bytes(), tt.out[0:len(in)]; !same(out, d) {
-				t.Errorf("%s/%d: CTRWriter\ninpt %x\nhave %x\nwant %x", test, len(in), in, d, out);
+				t.Errorf("%s/%d: CTRWriter\ninpt %x\nhave %x\nwant %x", test, len(in), in, d, out)
 			}
 		}
 
@@ -97,14 +97,14 @@ func TestCTR_AES(t *testing.T) {
 			w := &plain;
 			n, err := io.Copy(w, r);
 			if n != int64(len(out)) || err != nil {
-				t.Errorf("%s/%d: CTRReader io.Copy = %d, %v want %d, nil", test, len(out), n, err, len(out));
+				t.Errorf("%s/%d: CTRReader io.Copy = %d, %v want %d, nil", test, len(out), n, err, len(out))
 			} else if d, in := plain.Bytes(), tt.in[0:len(out)]; !same(in, d) {
-				t.Errorf("%s/%d: CTRReader\nhave %x\nwant %x", test, len(out), d, in);
+				t.Errorf("%s/%d: CTRReader\nhave %x\nwant %x", test, len(out), d, in)
 			}
 		}
 
 		if t.Failed() {
-			break;
+			break
 		}
 	}
 }
diff --git a/src/pkg/crypto/block/eax.go b/src/pkg/crypto/block/eax.go
index 3992ea8f7a..867c74fc73 100644
--- a/src/pkg/crypto/block/eax.go
+++ b/src/pkg/crypto/block/eax.go
@@ -30,13 +30,13 @@ type EAXTagError struct {
 }
 
 func (e *EAXTagError) String() string {
-	return fmt.Sprintf("crypto/block: EAX tag mismatch: read %x but computed %x", e.Read, e.Computed);
+	return fmt.Sprintf("crypto/block: EAX tag mismatch: read %x but computed %x", e.Read, e.Computed)
 }
 
 func setupEAX(c Cipher, iv, hdr []byte, tagBytes int) (ctrIV, tag []byte, cmac hash.Hash) {
 	n := len(iv);
 	if n != c.BlockSize() {
-		panicln("crypto/block: EAX: iv length", n, "!=", c.BlockSize());
+		panicln("crypto/block: EAX: iv length", n, "!=", c.BlockSize())
 	}
 	buf := make([]byte, n);	// zeroed
 
@@ -54,7 +54,7 @@ func setupEAX(c Cipher, iv, hdr []byte, tagBytes int) (ctrIV, tag []byte, cmac h
 	cmac.Write(hdr);
 	sum = cmac.Sum();
 	for i := 0; i < tagBytes; i++ {
-		tag[i] ^= sum[i];
+		tag[i] ^= sum[i]
 	}
 
 	cmac.Reset();
@@ -68,7 +68,7 @@ func finishEAX(tag []byte, cmac hash.Hash) {
 	// Finish CMAC #2 and xor into tag.
 	sum := cmac.Sum();
 	for i := range tag {
-		tag[i] ^= sum[i];
+		tag[i] ^= sum[i]
 	}
 }
 
@@ -110,7 +110,7 @@ func NewEAXEncrypter(c Cipher, iv []byte, hdr []byte, tagBytes int, w io.Writer)
 }
 
 func (x *eaxEncrypter) Write(p []byte) (n int, err os.Error) {
-	return x.ctr.Write(p);
+	return x.ctr.Write(p)
 }
 
 func (x *eaxEncrypter) Close() os.Error {
@@ -120,7 +120,7 @@ func (x *eaxEncrypter) Close() os.Error {
 	finishEAX(x.tag, x.cw.cmac);
 	n, err := x.cw.w.Write(x.tag);
 	if n != len(x.tag) && err == nil {
-		err = io.ErrShortWrite;
+		err = io.ErrShortWrite
 	}
 
 	return err;
@@ -154,7 +154,7 @@ func (cr *cmacReader) Read(p []byte) (n int, err os.Error) {
 		tag = tag[0 : nt+nn];
 		cr.tag = tag;
 		if err1 != nil {
-			return 0, err1;
+			return 0, err1
 		}
 	}
 
@@ -163,15 +163,15 @@ func (cr *cmacReader) Read(p []byte) (n int, err os.Error) {
 		// If p is big, try to read directly into p to avoid a copy.
 		n, err = cr.r.Read(p[tagBytes:len(p)]);
 		if n == 0 {
-			goto out;
+			goto out
 		}
 		// copy old tag into p
 		for i := 0; i < tagBytes; i++ {
-			p[i] = tag[i];
+			p[i] = tag[i]
 		}
 		// copy new tag out of p
 		for i := 0; i < tagBytes; i++ {
-			tag[i] = p[n+i];
+			tag[i] = p[n+i]
 		}
 		goto out;
 	}
@@ -179,7 +179,7 @@ func (cr *cmacReader) Read(p []byte) (n int, err os.Error) {
 	// Otherwise, read into p and then slide data
 	n, err = cr.r.Read(p);
 	if n == 0 {
-		goto out;
+		goto out
 	}
 
 	// copy tag+p into p+tmp and then swap tmp, tag
@@ -187,14 +187,14 @@ func (cr *cmacReader) Read(p []byte) (n int, err os.Error) {
 	for i := n+tagBytes-1; i >= 0; i-- {
 		var c byte;
 		if i < tagBytes {
-			c = tag[i];
+			c = tag[i]
 		} else {
-			c = p[i-tagBytes];
+			c = p[i-tagBytes]
 		}
 		if i < n {
-			p[i] = c;
+			p[i] = c
 		} else {
-			tmp[i] = c;
+			tmp[i] = c
 		}
 	}
 	cr.tmp, cr.tag = tag, tmp;
@@ -247,7 +247,7 @@ func (x *eaxDecrypter) checkTag() os.Error {
 func (x *eaxDecrypter) Read(p []byte) (n int, err os.Error) {
 	n, err = x.ctr.Read(p);
 	if n == 0 && err == nil {
-		err = x.checkTag();
+		err = x.checkTag()
 	}
 	return n, err;
 }
diff --git a/src/pkg/crypto/block/eax_aes_test.go b/src/pkg/crypto/block/eax_aes_test.go
index 5fbf835d29..43f126d216 100644
--- a/src/pkg/crypto/block/eax_aes_test.go
+++ b/src/pkg/crypto/block/eax_aes_test.go
@@ -101,20 +101,20 @@ func TestEAXEncrypt_AES(t *testing.T) {
 		test := fmt.Sprintf("test %d", i);
 		c, err := aes.NewCipher(tt.key);
 		if err != nil {
-			t.Fatalf("%s: NewCipher(%d bytes) = %s", test, len(tt.key), err);
+			t.Fatalf("%s: NewCipher(%d bytes) = %s", test, len(tt.key), err)
 		}
 		b.Reset();
 		enc := NewEAXEncrypter(c, tt.nonce, tt.header, 16, b);
 		n, err := io.Copy(enc, bytes.NewBuffer(tt.msg));
 		if n != int64(len(tt.msg)) || err != nil {
-			t.Fatalf("%s: io.Copy into encrypter: %d, %s", test, n, err);
+			t.Fatalf("%s: io.Copy into encrypter: %d, %s", test, n, err)
 		}
 		err = enc.Close();
 		if err != nil {
-			t.Fatalf("%s: enc.Close: %s", test, err);
+			t.Fatalf("%s: enc.Close: %s", test, err)
 		}
 		if d := b.Bytes(); !same(d, tt.cipher) {
-			t.Fatalf("%s: got %x want %x", test, d, tt.cipher);
+			t.Fatalf("%s: got %x want %x", test, d, tt.cipher)
 		}
 	}
 }
@@ -125,16 +125,16 @@ func TestEAXDecrypt_AES(t *testing.T) {
 		test := fmt.Sprintf("test %d", i);
 		c, err := aes.NewCipher(tt.key);
 		if err != nil {
-			t.Fatalf("%s: NewCipher(%d bytes) = %s", test, len(tt.key), err);
+			t.Fatalf("%s: NewCipher(%d bytes) = %s", test, len(tt.key), err)
 		}
 		b.Reset();
 		dec := NewEAXDecrypter(c, tt.nonce, tt.header, 16, bytes.NewBuffer(tt.cipher));
 		n, err := io.Copy(b, dec);
 		if n != int64(len(tt.msg)) || err != nil {
-			t.Fatalf("%s: io.Copy into decrypter: %d, %s", test, n, err);
+			t.Fatalf("%s: io.Copy into decrypter: %d, %s", test, n, err)
 		}
 		if d := b.Bytes(); !same(d, tt.msg) {
-			t.Fatalf("%s: got %x want %x", test, d, tt.msg);
+			t.Fatalf("%s: got %x want %x", test, d, tt.msg)
 		}
 	}
 }
diff --git a/src/pkg/crypto/block/ecb.go b/src/pkg/crypto/block/ecb.go
index f2455ff0a5..b6818a72b9 100644
--- a/src/pkg/crypto/block/ecb.go
+++ b/src/pkg/crypto/block/ecb.go
@@ -41,7 +41,7 @@ func (x *ecbDecrypter) fillCrypt() os.Error {
 		m, err = x.r.Read(x.crypt[off : x.blockSize]);
 		x.crypt = x.crypt[0 : off+m];
 		if m == 0 {
-			break;
+			break
 		}
 
 		// If an error happened but we got enough
@@ -50,7 +50,7 @@ func (x *ecbDecrypter) fillCrypt() os.Error {
 		// But if we don't have enough to decrypt,
 		// have to stop now.
 		if err != nil && len(x.crypt) < x.blockSize {
-			break;
+			break
 		}
 	}
 	return err;
@@ -60,15 +60,15 @@ func (x *ecbDecrypter) fillCrypt() os.Error {
 func (x *ecbDecrypter) readPlain(p []byte) int {
 	n := len(x.plain);
 	if n > len(p) {
-		n = len(p);
+		n = len(p)
 	}
 	for i := 0; i < n; i++ {
-		p[i] = x.plain[i];
+		p[i] = x.plain[i]
 	}
 	if n < len(x.plain) {
-		x.plain = x.plain[n:len(x.plain)];
+		x.plain = x.plain[n:len(x.plain)]
 	} else {
-		x.plain = nil;
+		x.plain = nil
 	}
 	return n;
 }
@@ -76,12 +76,12 @@ func (x *ecbDecrypter) readPlain(p []byte) int {
 type ecbFragmentError int
 
 func (n ecbFragmentError) String() string {
-	return "crypto/block: " + strconv.Itoa(int(n)) + "-byte fragment at EOF";
+	return "crypto/block: " + strconv.Itoa(int(n)) + "-byte fragment at EOF"
 }
 
 func (x *ecbDecrypter) Read(p []byte) (n int, err os.Error) {
 	if len(p) == 0 {
-		return;
+		return
 	}
 
 	// If there's no plaintext waiting and p is not big enough
@@ -89,7 +89,7 @@ func (x *ecbDecrypter) Read(p []byte) (n int, err os.Error) {
 	// cipher text buffer.  Set it to non-nil so that the
 	// code below will fill it.
 	if x.plain == nil && len(p) < x.blockSize && x.crypt == nil {
-		x.crypt = x.buf[0:0];
+		x.crypt = x.buf[0:0]
 	}
 
 	// If there is a leftover cipher text buffer,
@@ -97,7 +97,7 @@ func (x *ecbDecrypter) Read(p []byte) (n int, err os.Error) {
 	if x.crypt != nil {
 		err = x.fillCrypt();
 		if err != nil || len(x.crypt) == 0 {
-			return;
+			return
 		}
 		x.c.Decrypt(x.crypt, x.crypt);
 		x.plain = x.crypt;
@@ -128,7 +128,7 @@ func (x *ecbDecrypter) Read(p []byte) (n int, err os.Error) {
 	if i < n {
 		p = p[i:n];
 		for j, v := range p {
-			x.buf[j] = v;
+			x.buf[j] = v
 		}
 		x.crypt = x.buf[0:len(p)];
 		n = i;
@@ -168,17 +168,17 @@ type ecbEncrypter struct {
 // Flush the x.crypt buffer to x.w.
 func (x *ecbEncrypter) flushCrypt() os.Error {
 	if len(x.crypt) == 0 {
-		return nil;
+		return nil
 	}
 	n, err := x.w.Write(x.crypt);
 	if n < len(x.crypt) {
 		x.crypt = x.crypt[n:len(x.crypt)];
 		if err == nil {
-			err = io.ErrShortWrite;
+			err = io.ErrShortWrite
 		}
 	}
 	if err != nil {
-		return err;
+		return err
 	}
 	x.crypt = nil;
 	return nil;
@@ -189,12 +189,12 @@ func (x *ecbEncrypter) flushCrypt() os.Error {
 // so this is cheap enough.
 func (x *ecbEncrypter) slidePlain() {
 	if len(x.plain) == 0 {
-		x.plain = x.buf[0:0];
+		x.plain = x.buf[0:0]
 	} else if cap(x.plain) < cap(x.buf) {
 		// plain and buf share same data,
 		// but buf is before plain, so forward loop is correct
 		for i := 0; i < len(x.plain); i++ {
-			x.buf[i] = x.plain[i];
+			x.buf[i] = x.plain[i]
 		}
 		x.plain = x.buf[0:len(x.plain)];
 	}
@@ -206,11 +206,11 @@ func (x *ecbEncrypter) fillPlain(p []byte) int {
 	off := len(x.plain);
 	n := len(p);
 	if max := cap(x.plain)-off; n > max {
-		n = max;
+		n = max
 	}
 	x.plain = x.plain[0 : off+n];
 	for i := 0; i < n; i++ {
-		x.plain[off+i] = p[i];
+		x.plain[off+i] = p[i]
 	}
 	return n;
 }
@@ -233,7 +233,7 @@ func (x *ecbEncrypter) Write(p []byte) (n int, err os.Error) {
 		// This can happen on the first iteration
 		// if a write failed in an earlier call.
 		if err = x.flushCrypt(); err != nil {
-			return;
+			return
 		}
 
 		// Now that encrypted data is gone (flush ran),
@@ -243,7 +243,7 @@ func (x *ecbEncrypter) Write(p []byte) (n int, err os.Error) {
 		// Fill plaintext buffer from p.
 		m := x.fillPlain(p);
 		if m == 0 {
-			break;
+			break
 		}
 		n += m;
 		p = p[m:len(p)];
@@ -253,7 +253,7 @@ func (x *ecbEncrypter) Write(p []byte) (n int, err os.Error) {
 
 		// Write x.crypt.
 		if err = x.flushCrypt(); err != nil {
-			break;
+			break
 		}
 	}
 	return;
diff --git a/src/pkg/crypto/block/ecb_aes_test.go b/src/pkg/crypto/block/ecb_aes_test.go
index 74dc006829..315ec213de 100644
--- a/src/pkg/crypto/block/ecb_aes_test.go
+++ b/src/pkg/crypto/block/ecb_aes_test.go
@@ -105,9 +105,9 @@ func TestECB_AES(t *testing.T) {
 		var r io.Reader = bytes.NewBuffer(tt.in);
 		n, err := io.Copy(w, r);
 		if n != int64(len(tt.in)) || err != nil {
-			t.Errorf("%s: ECBReader io.Copy = %d, %v want %d, nil", test, n, err, len(tt.in));
+			t.Errorf("%s: ECBReader io.Copy = %d, %v want %d, nil", test, n, err, len(tt.in))
 		} else if d := crypt.Bytes(); !same(tt.out, d) {
-			t.Errorf("%s: ECBReader\nhave %x\nwant %x", test, d, tt.out);
+			t.Errorf("%s: ECBReader\nhave %x\nwant %x", test, d, tt.out)
 		}
 
 		var plain bytes.Buffer;
@@ -115,13 +115,13 @@ func TestECB_AES(t *testing.T) {
 		w = &plain;
 		n, err = io.Copy(w, r);
 		if n != int64(len(tt.out)) || err != nil {
-			t.Errorf("%s: ECBWriter io.Copy = %d, %v want %d, nil", test, n, err, len(tt.out));
+			t.Errorf("%s: ECBWriter io.Copy = %d, %v want %d, nil", test, n, err, len(tt.out))
 		} else if d := plain.Bytes(); !same(tt.in, d) {
-			t.Errorf("%s: ECBWriter\nhave %x\nwant %x", test, d, tt.in);
+			t.Errorf("%s: ECBWriter\nhave %x\nwant %x", test, d, tt.in)
 		}
 
 		if t.Failed() {
-			break;
+			break
 		}
 	}
 }
diff --git a/src/pkg/crypto/block/ecb_test.go b/src/pkg/crypto/block/ecb_test.go
index c6507220bf..57aae7ed2b 100644
--- a/src/pkg/crypto/block/ecb_test.go
+++ b/src/pkg/crypto/block/ecb_test.go
@@ -24,34 +24,34 @@ func (c *IncCipher) BlockSize() int	{ return c.blockSize }
 
 func (c *IncCipher) Encrypt(src, dst []byte) {
 	if !c.encrypting {
-		panicln("encrypt: not encrypting");
+		panicln("encrypt: not encrypting")
 	}
 	if len(src) != c.blockSize || len(dst) != c.blockSize {
-		panicln("encrypt: wrong block size", c.blockSize, len(src), len(dst));
+		panicln("encrypt: wrong block size", c.blockSize, len(src), len(dst))
 	}
 	c.delta++;
 	for i, b := range src {
-		dst[i] = b + c.delta;
+		dst[i] = b + c.delta
 	}
 }
 
 func (c *IncCipher) Decrypt(src, dst []byte) {
 	if c.encrypting {
-		panicln("decrypt: not decrypting");
+		panicln("decrypt: not decrypting")
 	}
 	if len(src) != c.blockSize || len(dst) != c.blockSize {
-		panicln("decrypt: wrong block size", c.blockSize, len(src), len(dst));
+		panicln("decrypt: wrong block size", c.blockSize, len(src), len(dst))
 	}
 	c.delta--;
 	for i, b := range src {
-		dst[i] = b + c.delta;
+		dst[i] = b + c.delta
 	}
 }
 
 func TestECBEncrypter(t *testing.T) {
 	var plain, crypt [256]byte;
 	for i := 0; i < len(plain); i++ {
-		plain[i] = byte(i);
+		plain[i] = byte(i)
 	}
 	b := new(bytes.Buffer);
 	for block := 1; block <= 64; block *= 2 {
@@ -59,7 +59,7 @@ func TestECBEncrypter(t *testing.T) {
 		delta := byte(0);
 		for i := 0; i < len(crypt); i++ {
 			if i%block == 0 {
-				delta++;
+				delta++
 			}
 			crypt[i] = plain[i]+delta;
 		}
@@ -82,7 +82,7 @@ func TestECBEncrypter(t *testing.T) {
 			for n := 1; n <= len(plain)/2; n *= 2 {
 				_, err := io.Copyn(w, r, int64(n));
 				if err != nil {
-					t.Errorf("block=%d frag=%d: Copyn %d: %s", block, frag, n, err);
+					t.Errorf("block=%d frag=%d: Copyn %d: %s", block, frag, n, err)
 				}
 			}
 			if frag != 0 {
@@ -101,7 +101,7 @@ func TestECBEncrypter(t *testing.T) {
 			}
 
 			if string(data) != string(&crypt) {
-				t.Errorf("block=%d frag=%d: want %x got %x", block, frag, data, crypt);
+				t.Errorf("block=%d frag=%d: want %x got %x", block, frag, data, crypt)
 			}
 		}
 	}
@@ -115,7 +115,7 @@ func testECBDecrypter(t *testing.T, maxio int) {
 	};
 	var plain, crypt [256]byte;
 	for i := 0; i < len(plain); i++ {
-		plain[i] = byte(255-i);
+		plain[i] = byte(255-i)
 	}
 	b := new(bytes.Buffer);
 	for block := 1; block <= 64 && block <= maxio; block *= 2 {
@@ -123,7 +123,7 @@ func testECBDecrypter(t *testing.T, maxio int) {
 		delta := byte(0);
 		for i := 0; i < len(crypt); i++ {
 			if i%block == 0 {
-				delta++;
+				delta++
 			}
 			crypt[i] = plain[i]+delta;
 		}
@@ -147,7 +147,7 @@ func testECBDecrypter(t *testing.T, maxio int) {
 				for n := 1; n <= maxio/2; n *= 2 {
 					_, err := io.Copyn(b, r, int64(n));
 					if err != nil {
-						t.Errorf("%s: Copyn %d: %s", test, n, err);
+						t.Errorf("%s: Copyn %d: %s", test, n, err)
 					}
 				}
 				if frag != 0 {
@@ -166,7 +166,7 @@ func testECBDecrypter(t *testing.T, maxio int) {
 				}
 
 				if string(data) != string(plain[0:maxio]) {
-					t.Errorf("%s: input=%x want %x got %x", test, crypt[0:maxio], plain[0:maxio], data);
+					t.Errorf("%s: input=%x want %x got %x", test, crypt[0:maxio], plain[0:maxio], data)
 				}
 			}
 		}
@@ -176,6 +176,6 @@ func testECBDecrypter(t *testing.T, maxio int) {
 func TestECBDecrypter(t *testing.T) {
 	// Do shorter I/O sizes first; they're easier to debug.
 	for n := 1; n <= 256 && !t.Failed(); n *= 2 {
-		testECBDecrypter(t, n);
+		testECBDecrypter(t, n)
 	}
 }
diff --git a/src/pkg/crypto/block/ofb.go b/src/pkg/crypto/block/ofb.go
index 86647abc2f..c297541e33 100644
--- a/src/pkg/crypto/block/ofb.go
+++ b/src/pkg/crypto/block/ofb.go
@@ -26,7 +26,7 @@ func newOFBStream(c Cipher, iv []byte) *ofbStream {
 	x.c = c;
 	n := len(iv);
 	if n != c.BlockSize() {
-		panicln("crypto/block: newOFBStream: invalid iv size", n, "!=", c.BlockSize());
+		panicln("crypto/block: newOFBStream: invalid iv size", n, "!=", c.BlockSize())
 	}
 	x.iv = copy(iv);
 	return x;
@@ -44,7 +44,7 @@ func (x *ofbStream) Next() []byte {
 // an OFB reader applied to an encrypted stream produces a decrypted
 // stream and vice versa.
 func NewOFBReader(c Cipher, iv []byte, r io.Reader) io.Reader {
-	return newXorReader(newOFBStream(c, iv), r);
+	return newXorReader(newOFBStream(c, iv), r)
 }
 
 // NewOFBWriter returns a writer that encrypts (or decrypts) data using c
@@ -55,5 +55,5 @@ func NewOFBReader(c Cipher, iv []byte, r io.Reader) io.Reader {
 // an OFB writer applied to an decrypted stream produces an encrypted
 // stream and vice versa.
 func NewOFBWriter(c Cipher, iv []byte, w io.Writer) io.Writer {
-	return newXorWriter(newOFBStream(c, iv), w);
+	return newXorWriter(newOFBStream(c, iv), w)
 }
diff --git a/src/pkg/crypto/block/ofb_aes_test.go b/src/pkg/crypto/block/ofb_aes_test.go
index 3db92215ab..80af78fe40 100644
--- a/src/pkg/crypto/block/ofb_aes_test.go
+++ b/src/pkg/crypto/block/ofb_aes_test.go
@@ -82,9 +82,9 @@ func TestOFB_AES(t *testing.T) {
 			var r io.Reader = bytes.NewBuffer(in);
 			n, err := io.Copy(w, r);
 			if n != int64(len(in)) || err != nil {
-				t.Errorf("%s/%d: OFBWriter io.Copy = %d, %v want %d, nil", test, len(in), n, err, len(in));
+				t.Errorf("%s/%d: OFBWriter io.Copy = %d, %v want %d, nil", test, len(in), n, err, len(in))
 			} else if d, out := crypt.Bytes(), tt.out[0:len(in)]; !same(out, d) {
-				t.Errorf("%s/%d: OFBWriter\ninpt %x\nhave %x\nwant %x", test, len(in), in, d, out);
+				t.Errorf("%s/%d: OFBWriter\ninpt %x\nhave %x\nwant %x", test, len(in), in, d, out)
 			}
 		}
 
@@ -95,14 +95,14 @@ func TestOFB_AES(t *testing.T) {
 			w := &plain;
 			n, err := io.Copy(w, r);
 			if n != int64(len(out)) || err != nil {
-				t.Errorf("%s/%d: OFBReader io.Copy = %d, %v want %d, nil", test, len(out), n, err, len(out));
+				t.Errorf("%s/%d: OFBReader io.Copy = %d, %v want %d, nil", test, len(out), n, err, len(out))
 			} else if d, in := plain.Bytes(), tt.in[0:len(out)]; !same(in, d) {
-				t.Errorf("%s/%d: OFBReader\nhave %x\nwant %x", test, len(out), d, in);
+				t.Errorf("%s/%d: OFBReader\nhave %x\nwant %x", test, len(out), d, in)
 			}
 		}
 
 		if t.Failed() {
-			break;
+			break
 		}
 	}
 }
diff --git a/src/pkg/crypto/block/xor.go b/src/pkg/crypto/block/xor.go
index c92d2d3ffb..36fc5799bc 100644
--- a/src/pkg/crypto/block/xor.go
+++ b/src/pkg/crypto/block/xor.go
@@ -75,16 +75,16 @@ func (x *xorWriter) Write(p []byte) (n int, err os.Error) {
 		if nn := len(x.extra); nn > 0 {
 			// extra points into work, so edit directly
 			if m > nn {
-				m = nn;
+				m = nn
 			}
 			for i := 0; i < m; i++ {
-				x.extra[i] ^= p[i];
+				x.extra[i] ^= p[i]
 			}
 			chunk = x.extra[0:m];
 		} else {
 			// xor p ^ buf into work, refreshing buf as needed
 			if nn := len(x.work); m > nn {
-				m = nn;
+				m = nn
 			}
 			bp := 0;
 			buf := x.buf;
@@ -104,19 +104,19 @@ func (x *xorWriter) Write(p []byte) (n int, err os.Error) {
 		var nn int;
 		nn, err = x.w.Write(chunk);
 		if nn != len(chunk) && err == nil {
-			err = io.ErrShortWrite;
+			err = io.ErrShortWrite
 		}
 		if nn < len(chunk) {
 			// Reconstruct the random bits from the unwritten
 			// data and save them for next time.
 			for i := nn; i < m; i++ {
-				chunk[i] ^= p[i];
+				chunk[i] ^= p[i]
 			}
 			x.extra = chunk[nn:len(chunk)];
 		}
 		n += nn;
 		if err != nil {
-			return;
+			return
 		}
 		p = p[m:len(p)];
 	}
diff --git a/src/pkg/crypto/block/xor_test.go b/src/pkg/crypto/block/xor_test.go
index 671e319986..7d1decae84 100644
--- a/src/pkg/crypto/block/xor_test.go
+++ b/src/pkg/crypto/block/xor_test.go
@@ -36,7 +36,7 @@ func (x *incStream) Next() []byte {
 func testXorWriter(t *testing.T, maxio int) {
 	var plain, crypt [256]byte;
 	for i := 0; i < len(plain); i++ {
-		plain[i] = byte(i);
+		plain[i] = byte(i)
 	}
 	b := new(bytes.Buffer);
 	for block := 1; block <= 64 && block <= maxio; block *= 2 {
@@ -44,7 +44,7 @@ func testXorWriter(t *testing.T, maxio int) {
 		n := byte(0);
 		for i := 0; i < len(crypt); i++ {
 			if i%block == 0 {
-				n++;
+				n++
 			}
 			crypt[i] = plain[i]^n;
 			n++;
@@ -69,7 +69,7 @@ func testXorWriter(t *testing.T, maxio int) {
 			for n := 1; n <= len(plain)/2; n *= 2 {
 				_, err := io.Copyn(w, r, int64(n));
 				if err != nil {
-					t.Errorf("%s: Copyn %d: %s", test, n, err);
+					t.Errorf("%s: Copyn %d: %s", test, n, err)
 				}
 			}
 
@@ -82,7 +82,7 @@ func testXorWriter(t *testing.T, maxio int) {
 			}
 
 			if string(data) != string(crypt) {
-				t.Errorf("%s: want %x got %x", test, data, crypt);
+				t.Errorf("%s: want %x got %x", test, data, crypt)
 			}
 		}
 	}
@@ -92,7 +92,7 @@ func testXorWriter(t *testing.T, maxio int) {
 func TestXorWriter(t *testing.T) {
 	// Do shorter I/O sizes first; they're easier to debug.
 	for n := 1; n <= 256 && !t.Failed(); n *= 2 {
-		testXorWriter(t, n);
+		testXorWriter(t, n)
 	}
 }
 
@@ -104,7 +104,7 @@ func testXorReader(t *testing.T, maxio int) {
 	};
 	var plain, crypt [256]byte;
 	for i := 0; i < len(plain); i++ {
-		plain[i] = byte(255-i);
+		plain[i] = byte(255-i)
 	}
 	b := new(bytes.Buffer);
 	for block := 1; block <= 64 && block <= maxio; block *= 2 {
@@ -112,7 +112,7 @@ func testXorReader(t *testing.T, maxio int) {
 		n := byte(0);
 		for i := 0; i < len(crypt); i++ {
 			if i%block == 0 {
-				n++;
+				n++
 			}
 			crypt[i] = plain[i]^n;
 			n++;
@@ -137,7 +137,7 @@ func testXorReader(t *testing.T, maxio int) {
 				for n := 1; n <= maxio/2; n *= 2 {
 					_, err := io.Copyn(b, r, int64(n));
 					if err != nil {
-						t.Errorf("%s: Copyn %d: %s", test, n, err);
+						t.Errorf("%s: Copyn %d: %s", test, n, err)
 					}
 				}
 
@@ -151,7 +151,7 @@ func testXorReader(t *testing.T, maxio int) {
 				}
 
 				if string(data) != string(plain) {
-					t.Errorf("%s: input=%x want %x got %x", test, crypt, plain, data);
+					t.Errorf("%s: input=%x want %x got %x", test, crypt, plain, data)
 				}
 			}
 		}
@@ -161,7 +161,7 @@ func testXorReader(t *testing.T, maxio int) {
 func TestXorReader(t *testing.T) {
 	// Do shorter I/O sizes first; they're easier to debug.
 	for n := 1; n <= 256 && !t.Failed(); n *= 2 {
-		testXorReader(t, n);
+		testXorReader(t, n)
 	}
 }
 
diff --git a/src/pkg/crypto/hmac/hmac.go b/src/pkg/crypto/hmac/hmac.go
index f1cc6b32a2..d3be7c4ac7 100644
--- a/src/pkg/crypto/hmac/hmac.go
+++ b/src/pkg/crypto/hmac/hmac.go
@@ -42,10 +42,10 @@ type hmac struct {
 
 func (h *hmac) tmpPad(xor byte) {
 	for i, k := range h.key {
-		h.tmp[i] = xor^k;
+		h.tmp[i] = xor^k
 	}
 	for i := len(h.key); i < padSize; i++ {
-		h.tmp[i] = xor;
+		h.tmp[i] = xor
 	}
 }
 
@@ -53,7 +53,7 @@ func (h *hmac) Sum() []byte {
 	h.tmpPad(0x5c);
 	sum := h.inner.Sum();
 	for i, b := range sum {
-		h.tmp[padSize+i] = b;
+		h.tmp[padSize+i] = b
 	}
 	h.inner.Reset();
 	h.inner.Write(h.tmp);
@@ -61,7 +61,7 @@ func (h *hmac) Sum() []byte {
 }
 
 func (h *hmac) Write(p []byte) (n int, err os.Error) {
-	return h.inner.Write(p);
+	return h.inner.Write(p)
 }
 
 func (h *hmac) Size() int	{ return h.size }
@@ -84,7 +84,7 @@ func New(h hash.Hash, key []byte) hash.Hash {
 	hm.size = h.Size();
 	hm.key = make([]byte, len(key));
 	for i, k := range key {
-		hm.key[i] = k;
+		hm.key[i] = k
 	}
 	hm.tmp = make([]byte, padSize + hm.size);
 	hm.Reset();
diff --git a/src/pkg/crypto/hmac/hmac_test.go b/src/pkg/crypto/hmac/hmac_test.go
index 6df6484134..1c81fd9906 100644
--- a/src/pkg/crypto/hmac/hmac_test.go
+++ b/src/pkg/crypto/hmac/hmac_test.go
@@ -87,7 +87,7 @@ func TestHMAC(t *testing.T) {
 			}
 			sum := fmt.Sprintf("%x", h.Sum());
 			if sum != tt.out {
-				t.Errorf("test %d.%d: have %s want %s\n", i, j, sum, tt.out);
+				t.Errorf("test %d.%d: have %s want %s\n", i, j, sum, tt.out)
 			}
 
 			// Second iteration: make sure reset works.
diff --git a/src/pkg/crypto/md5/md5.go b/src/pkg/crypto/md5/md5.go
index 4236ad3fa0..3834665888 100644
--- a/src/pkg/crypto/md5/md5.go
+++ b/src/pkg/crypto/md5/md5.go
@@ -53,10 +53,10 @@ func (d *digest) Write(p []byte) (nn int, err os.Error) {
 	if d.nx > 0 {
 		n := len(p);
 		if n > _Chunk - d.nx {
-			n = _Chunk - d.nx;
+			n = _Chunk - d.nx
 		}
 		for i := 0; i < n; i++ {
-			d.x[d.nx + i] = p[i];
+			d.x[d.nx + i] = p[i]
 		}
 		d.nx += n;
 		if d.nx == _Chunk {
@@ -69,7 +69,7 @@ func (d *digest) Write(p []byte) (nn int, err os.Error) {
 	p = p[n:len(p)];
 	if len(p) > 0 {
 		for i := 0; i < len(p); i++ {
-			d.x[i] = p[i];
+			d.x[i] = p[i]
 		}
 		d.nx = len(p);
 	}
@@ -82,20 +82,20 @@ func (d *digest) Sum() []byte {
 	var tmp [64]byte;
 	tmp[0] = 0x80;
 	if len%64 < 56 {
-		d.Write(tmp[0 : 56 - len%64]);
+		d.Write(tmp[0 : 56 - len%64])
 	} else {
-		d.Write(tmp[0 : 64 + 56 - len%64]);
+		d.Write(tmp[0 : 64 + 56 - len%64])
 	}
 
 	// Length in bits.
 	len <<= 3;
 	for i := uint(0); i < 8; i++ {
-		tmp[i] = byte(len>>(8*i));
+		tmp[i] = byte(len>>(8*i))
 	}
 	d.Write(tmp[0:8]);
 
 	if d.nx != 0 {
-		panicln("oops");
+		panicln("oops")
 	}
 
 	p := make([]byte, 16);
diff --git a/src/pkg/crypto/rc4/rc4.go b/src/pkg/crypto/rc4/rc4.go
index a93784e622..5f770f29b6 100644
--- a/src/pkg/crypto/rc4/rc4.go
+++ b/src/pkg/crypto/rc4/rc4.go
@@ -23,7 +23,7 @@ type Cipher struct {
 type KeySizeError int
 
 func (k KeySizeError) String() string {
-	return "crypto/rc4: invalid key size " + strconv.Itoa(int(k));
+	return "crypto/rc4: invalid key size " + strconv.Itoa(int(k))
 }
 
 // NewCipher creates and returns a new Cipher.  The key argument should be the
@@ -31,11 +31,11 @@ func (k KeySizeError) String() string {
 func NewCipher(key []byte) (*Cipher, os.Error) {
 	k := len(key);
 	if k < 1 || k > 256 {
-		return nil, KeySizeError(k);
+		return nil, KeySizeError(k)
 	}
 	var c Cipher;
 	for i := 0; i < 256; i++ {
-		c.s[i] = uint8(i);
+		c.s[i] = uint8(i)
 	}
 	var j uint8 = 0;
 	for i := 0; i < 256; i++ {
@@ -60,7 +60,7 @@ func (c *Cipher) XORKeyStream(buf []byte) {
 // process's memory.
 func (c *Cipher) Reset() {
 	for i := range c.s {
-		c.s[i] = 0;
+		c.s[i] = 0
 	}
 	c.i, c.j = 0, 0;
 }
diff --git a/src/pkg/crypto/rsa/pkcs1v15.go b/src/pkg/crypto/rsa/pkcs1v15.go
index 58f860facf..ddfaad5798 100644
--- a/src/pkg/crypto/rsa/pkcs1v15.go
+++ b/src/pkg/crypto/rsa/pkcs1v15.go
@@ -31,7 +31,7 @@ func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, er
 	ps, mm := em[1 : len(em)-len(msg)-1], em[len(em)-len(msg) : len(em)];
 	err = nonZeroRandomBytes(ps, rand);
 	if err != nil {
-		return;
+		return
 	}
 	em[len(em)-len(msg)-1] = 0;
 	bytes.Copy(mm, msg);
@@ -47,7 +47,7 @@ func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, er
 func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (out []byte, err os.Error) {
 	valid, out, err := decryptPKCS1v15(rand, priv, ciphertext);
 	if err == nil && valid == 0 {
-		err = DecryptionError{};
+		err = DecryptionError{}
 	}
 
 	return;
@@ -75,7 +75,7 @@ func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []by
 
 	valid, msg, err := decryptPKCS1v15(rand, priv, ciphertext);
 	if err != nil {
-		return;
+		return
 	}
 
 	valid &= subtle.ConstantTimeEq(int32(len(msg)), int32(len(key)));
@@ -93,7 +93,7 @@ func decryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (valid
 	c := new(big.Int).SetBytes(ciphertext);
 	m, err := decrypt(rand, priv, c);
 	if err != nil {
-		return;
+		return
 	}
 
 	em := leftPad(m.Bytes(), k);
@@ -122,14 +122,14 @@ func decryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (valid
 func nonZeroRandomBytes(s []byte, rand io.Reader) (err os.Error) {
 	_, err = io.ReadFull(rand, s);
 	if err != nil {
-		return;
+		return
 	}
 
 	for i := 0; i < len(s); i++ {
 		for s[i] == 0 {
 			_, err = rand.Read(s[i : i+1]);
 			if err != nil {
-				return;
+				return
 			}
 		}
 	}
diff --git a/src/pkg/crypto/rsa/pkcs1v15_test.go b/src/pkg/crypto/rsa/pkcs1v15_test.go
index 1f5cf463a2..549bca4bf1 100644
--- a/src/pkg/crypto/rsa/pkcs1v15_test.go
+++ b/src/pkg/crypto/rsa/pkcs1v15_test.go
@@ -19,7 +19,7 @@ func decodeBase64(in string) []byte {
 	out := make([]byte, base64.StdEncoding.DecodedLen(len(in)));
 	n, err := base64.StdEncoding.Decode(out, strings.Bytes(in));
 	if err != nil {
-		return nil;
+		return nil
 	}
 	return out[0:n];
 }
@@ -52,11 +52,11 @@ func TestDecryptPKCS1v15(t *testing.T) {
 	for i, test := range decryptPKCS1v15Tests {
 		out, err := DecryptPKCS1v15(nil, rsaPrivateKey, decodeBase64(test.in));
 		if err != nil {
-			t.Errorf("#%d error decrypting", i);
+			t.Errorf("#%d error decrypting", i)
 		}
 		want := strings.Bytes(test.out);
 		if bytes.Compare(out, want) != 0 {
-			t.Errorf("#%d got:%#v want:%#v", i, out, want);
+			t.Errorf("#%d got:%#v want:%#v", i, out, want)
 		}
 	}
 }
@@ -64,13 +64,13 @@ func TestDecryptPKCS1v15(t *testing.T) {
 func TestEncryptPKCS1v15(t *testing.T) {
 	urandom, err := os.Open("/dev/urandom", os.O_RDONLY, 0);
 	if err != nil {
-		t.Errorf("Failed to open /dev/urandom");
+		t.Errorf("Failed to open /dev/urandom")
 	}
 	k := (rsaPrivateKey.N.Len() + 7)/8;
 
 	tryEncryptDecrypt := func(in []byte, blind bool) bool {
 		if len(in) > k-11 {
-			in = in[0 : k-11];
+			in = in[0 : k-11]
 		}
 
 		ciphertext, err := EncryptPKCS1v15(urandom, &rsaPrivateKey.PublicKey, in);
@@ -81,9 +81,9 @@ func TestEncryptPKCS1v15(t *testing.T) {
 
 		var rand io.Reader;
 		if !blind {
-			rand = nil;
+			rand = nil
 		} else {
-			rand = urandom;
+			rand = urandom
 		}
 		plaintext, err := DecryptPKCS1v15(rand, rsaPrivateKey, ciphertext);
 		if err != nil {
@@ -126,11 +126,11 @@ func TestEncryptPKCS1v15SessionKey(t *testing.T) {
 		key := strings.Bytes("FAIL");
 		err := DecryptPKCS1v15SessionKey(nil, rsaPrivateKey, decodeBase64(test.in), key);
 		if err != nil {
-			t.Errorf("#%d error decrypting", i);
+			t.Errorf("#%d error decrypting", i)
 		}
 		want := strings.Bytes(test.out);
 		if bytes.Compare(key, want) != 0 {
-			t.Errorf("#%d got:%#v want:%#v", i, key, want);
+			t.Errorf("#%d got:%#v want:%#v", i, key, want)
 		}
 	}
 }
@@ -138,13 +138,13 @@ func TestEncryptPKCS1v15SessionKey(t *testing.T) {
 func TestNonZeroRandomBytes(t *testing.T) {
 	urandom, err := os.Open("/dev/urandom", os.O_RDONLY, 0);
 	if err != nil {
-		t.Errorf("Failed to open /dev/urandom");
+		t.Errorf("Failed to open /dev/urandom")
 	}
 
 	b := make([]byte, 512);
 	err = nonZeroRandomBytes(b, urandom);
 	if err != nil {
-		t.Errorf("returned error: %s", err);
+		t.Errorf("returned error: %s", err)
 	}
 	for _, b := range b {
 		if b == 0 {
diff --git a/src/pkg/crypto/rsa/rsa.go b/src/pkg/crypto/rsa/rsa.go
index beb4162973..6aeab041b6 100644
--- a/src/pkg/crypto/rsa/rsa.go
+++ b/src/pkg/crypto/rsa/rsa.go
@@ -67,7 +67,7 @@ func randomNumber(rand io.Reader, max *big.Int) (n *big.Int, err os.Error) {
 	// max.
 	r := uint(max.Len() % 8);
 	if r == 0 {
-		r = 8;
+		r = 8
 	}
 
 	bytes := make([]byte, k);
@@ -76,7 +76,7 @@ func randomNumber(rand io.Reader, max *big.Int) (n *big.Int, err os.Error) {
 	for {
 		_, err = io.ReadFull(rand, bytes);
 		if err != nil {
-			return;
+			return
 		}
 
 		// Clear bits in the first byte to increase the probability
@@ -85,7 +85,7 @@ func randomNumber(rand io.Reader, max *big.Int) (n *big.Int, err os.Error) {
 
 		n.SetBytes(bytes);
 		if big.CmpInt(n, max) < 0 {
-			return;
+			return
 		}
 	}
 
@@ -123,7 +123,7 @@ func (priv PrivateKey) Validate() os.Error {
 	// Check that p*q == n.
 	modulus := new(big.Int).Mul(priv.P, priv.Q);
 	if big.CmpInt(modulus, priv.N) != 0 {
-		return os.ErrorString("invalid modulus");
+		return os.ErrorString("invalid modulus")
 	}
 	// Check that e and totient(p, q) are coprime.
 	pminus1 := new(big.Int).Sub(priv.P, bigOne);
@@ -135,13 +135,13 @@ func (priv PrivateKey) Validate() os.Error {
 	y := new(big.Int);
 	big.GcdInt(gcd, x, y, totient, e);
 	if big.CmpInt(gcd, bigOne) != 0 {
-		return os.ErrorString("invalid public exponent E");
+		return os.ErrorString("invalid public exponent E")
 	}
 	// Check that de ≡ 1 (mod totient(p, q))
 	de := new(big.Int).Mul(priv.D, e);
 	de.Mod(de, totient);
 	if big.CmpInt(de, bigOne) != 0 {
-		return os.ErrorString("invalid private exponent D");
+		return os.ErrorString("invalid private exponent D")
 	}
 	return nil;
 }
@@ -209,13 +209,13 @@ func GenerateKey(rand io.Reader, bits int) (priv *PrivateKey, err os.Error) {
 // incCounter increments a four byte, big-endian counter.
 func incCounter(c *[4]byte) {
 	if c[3]++; c[3] != 0 {
-		return;
+		return
 	}
 	if c[2]++; c[2] != 0 {
-		return;
+		return
 	}
 	if c[1]++; c[1] != 0 {
-		return;
+		return
 	}
 	c[0]++;
 }
@@ -245,7 +245,7 @@ func mgf1XOR(out []byte, hash hash.Hash, seed []byte) {
 type MessageTooLongError struct{}
 
 func (MessageTooLongError) String() string {
-	return "message too long for RSA public key size";
+	return "message too long for RSA public key size"
 }
 
 func encrypt(c *big.Int, pub *PublicKey, m *big.Int) *big.Int {
@@ -279,7 +279,7 @@ func EncryptOAEP(hash hash.Hash, rand io.Reader, pub *PublicKey, msg []byte, lab
 
 	_, err = io.ReadFull(rand, seed);
 	if err != nil {
-		return;
+		return
 	}
 
 	mgf1XOR(db, hash, seed);
@@ -308,7 +308,7 @@ func modInverse(a, n *big.Int) (ia *big.Int) {
 	if big.CmpInt(x, bigOne) < 0 {
 		// 0 is not the multiplicative inverse of any element so, if x
 		// < 1, then x is negative.
-		x.Add(x, n);
+		x.Add(x, n)
 	}
 
 	return x;
@@ -336,7 +336,7 @@ func decrypt(rand io.Reader, priv *PrivateKey, c *big.Int) (m *big.Int, err os.E
 			return;
 		}
 		if big.CmpInt(r, bigZero) == 0 {
-			r = bigOne;
+			r = bigOne
 		}
 		ir = modInverse(r, priv.N);
 		bigE := big.NewInt(int64(priv.E));
@@ -370,7 +370,7 @@ func DecryptOAEP(hash hash.Hash, rand io.Reader, priv *PrivateKey, ciphertext []
 
 	m, err := decrypt(rand, priv, c);
 	if err != nil {
-		return;
+		return
 	}
 
 	hash.Write(label);
@@ -431,7 +431,7 @@ func DecryptOAEP(hash hash.Hash, rand io.Reader, priv *PrivateKey, ciphertext []
 func leftPad(input []byte, size int) (out []byte) {
 	n := len(input);
 	if n > size {
-		n = size;
+		n = size
 	}
 	out = make([]byte, size);
 	bytes.Copy(out[len(out)-n : len(out)], input);
diff --git a/src/pkg/crypto/rsa/rsa_test.go b/src/pkg/crypto/rsa/rsa_test.go
index 7070a8ba8e..feeefd476e 100644
--- a/src/pkg/crypto/rsa/rsa_test.go
+++ b/src/pkg/crypto/rsa/rsa_test.go
@@ -72,10 +72,10 @@ func TestEncryptOAEP(t *testing.T) {
 			randomSource := bytes.NewBuffer(message.seed);
 			out, err := EncryptOAEP(sha1, randomSource, &public, message.in, nil);
 			if err != nil {
-				t.Errorf("#%d,%d error: %s", i, j, err);
+				t.Errorf("#%d,%d error: %s", i, j, err)
 			}
 			if bytes.Compare(out, message.out) != 0 {
-				t.Errorf("#%d,%d bad result: %s (want %s)", i, j, out, message.out);
+				t.Errorf("#%d,%d bad result: %s (want %s)", i, j, out, message.out)
 			}
 		}
 	}
@@ -84,7 +84,7 @@ func TestEncryptOAEP(t *testing.T) {
 func TestDecryptOAEP(t *testing.T) {
 	urandom, err := os.Open("/dev/urandom", os.O_RDONLY, 0);
 	if err != nil {
-		t.Errorf("Failed to open /dev/urandom");
+		t.Errorf("Failed to open /dev/urandom")
 	}
 
 	sha1 := sha1.New();
@@ -98,17 +98,17 @@ func TestDecryptOAEP(t *testing.T) {
 		for j, message := range test.msgs {
 			out, err := DecryptOAEP(sha1, nil, &private, message.out, nil);
 			if err != nil {
-				t.Errorf("#%d,%d error: %s", i, j, err);
+				t.Errorf("#%d,%d error: %s", i, j, err)
 			} else if bytes.Compare(out, message.in) != 0 {
-				t.Errorf("#%d,%d bad result: %#v (want %#v)", i, j, out, message.in);
+				t.Errorf("#%d,%d bad result: %#v (want %#v)", i, j, out, message.in)
 			}
 
 			// Decrypt with blinding.
 			out, err = DecryptOAEP(sha1, urandom, &private, message.out, nil);
 			if err != nil {
-				t.Errorf("#%d,%d (blind) error: %s", i, j, err);
+				t.Errorf("#%d,%d (blind) error: %s", i, j, err)
 			} else if bytes.Compare(out, message.in) != 0 {
-				t.Errorf("#%d,%d (blind) bad result: %#v (want %#v)", i, j, out, message.in);
+				t.Errorf("#%d,%d (blind) bad result: %#v (want %#v)", i, j, out, message.in)
 			}
 		}
 	}
diff --git a/src/pkg/crypto/sha1/sha1.go b/src/pkg/crypto/sha1/sha1.go
index 4e75b7336b..b14fdbbf13 100644
--- a/src/pkg/crypto/sha1/sha1.go
+++ b/src/pkg/crypto/sha1/sha1.go
@@ -55,10 +55,10 @@ func (d *digest) Write(p []byte) (nn int, err os.Error) {
 	if d.nx > 0 {
 		n := len(p);
 		if n > _Chunk - d.nx {
-			n = _Chunk - d.nx;
+			n = _Chunk - d.nx
 		}
 		for i := 0; i < n; i++ {
-			d.x[d.nx + i] = p[i];
+			d.x[d.nx + i] = p[i]
 		}
 		d.nx += n;
 		if d.nx == _Chunk {
@@ -71,7 +71,7 @@ func (d *digest) Write(p []byte) (nn int, err os.Error) {
 	p = p[n:len(p)];
 	if len(p) > 0 {
 		for i := 0; i < len(p); i++ {
-			d.x[i] = p[i];
+			d.x[i] = p[i]
 		}
 		d.nx = len(p);
 	}
@@ -84,20 +84,20 @@ func (d *digest) Sum() []byte {
 	var tmp [64]byte;
 	tmp[0] = 0x80;
 	if len%64 < 56 {
-		d.Write(tmp[0 : 56 - len%64]);
+		d.Write(tmp[0 : 56 - len%64])
 	} else {
-		d.Write(tmp[0 : 64 + 56 - len%64]);
+		d.Write(tmp[0 : 64 + 56 - len%64])
 	}
 
 	// Length in bits.
 	len <<= 3;
 	for i := uint(0); i < 8; i++ {
-		tmp[i] = byte(len>>(56 - 8*i));
+		tmp[i] = byte(len>>(56 - 8*i))
 	}
 	d.Write(tmp[0:8]);
 
 	if d.nx != 0 {
-		panicln("oops");
+		panicln("oops")
 	}
 
 	p := make([]byte, 20);
diff --git a/src/pkg/crypto/subtle/constant_time.go b/src/pkg/crypto/subtle/constant_time.go
index 4dd7aa0423..8b5e37ee05 100644
--- a/src/pkg/crypto/subtle/constant_time.go
+++ b/src/pkg/crypto/subtle/constant_time.go
@@ -13,7 +13,7 @@ func ConstantTimeCompare(x, y []byte) int {
 	var v byte;
 
 	for i := 0; i < len(x); i++ {
-		v |= x[i]^y[i];
+		v |= x[i]^y[i]
 	}
 
 	return ConstantTimeByteEq(v, 0);
@@ -51,7 +51,7 @@ func ConstantTimeCopy(v int, x, y []byte) {
 	xmask := byte(v-1);
 	ymask := byte(^(v-1));
 	for i := 0; i < len(x); i++ {
-		x[i] = x[i]&xmask | y[i]&ymask;
+		x[i] = x[i]&xmask | y[i]&ymask
 	}
 	return;
 }
diff --git a/src/pkg/crypto/subtle/constant_time_test.go b/src/pkg/crypto/subtle/constant_time_test.go
index 78aa6771d2..9b25b9b72d 100644
--- a/src/pkg/crypto/subtle/constant_time_test.go
+++ b/src/pkg/crypto/subtle/constant_time_test.go
@@ -24,7 +24,7 @@ var testConstandTimeCompareData = []TestConstantTimeCompareStruct{
 func TestConstantTimeCompare(t *testing.T) {
 	for i, test := range testConstandTimeCompareData {
 		if r := ConstantTimeCompare(test.a, test.b); r != test.out {
-			t.Errorf("#%d bad result (got %x, want %x)", i, r, test.out);
+			t.Errorf("#%d bad result (got %x, want %x)", i, r, test.out)
 		}
 	}
 }
@@ -44,7 +44,7 @@ var testConstandTimeByteEqData = []TestConstantTimeByteEqStruct{
 
 func byteEq(a, b uint8) int {
 	if a == b {
-		return 1;
+		return 1
 	}
 	return 0;
 }
@@ -52,18 +52,18 @@ func byteEq(a, b uint8) int {
 func TestConstantTimeByteEq(t *testing.T) {
 	for i, test := range testConstandTimeByteEqData {
 		if r := ConstantTimeByteEq(test.a, test.b); r != test.out {
-			t.Errorf("#%d bad result (got %x, want %x)", i, r, test.out);
+			t.Errorf("#%d bad result (got %x, want %x)", i, r, test.out)
 		}
 	}
 	err := quick.CheckEqual(ConstantTimeByteEq, byteEq, nil);
 	if err != nil {
-		t.Error(err);
+		t.Error(err)
 	}
 }
 
 func eq(a, b int32) int {
 	if a == b {
-		return 1;
+		return 1
 	}
 	return 0;
 }
@@ -71,27 +71,27 @@ func eq(a, b int32) int {
 func TestConstantTimeEq(t *testing.T) {
 	err := quick.CheckEqual(ConstantTimeEq, eq, nil);
 	if err != nil {
-		t.Error(err);
+		t.Error(err)
 	}
 }
 
 func copy(v int, x, y []byte) []byte {
 	if len(x) > len(y) {
-		x = x[0:len(y)];
+		x = x[0:len(y)]
 	} else {
-		y = y[0:len(x)];
+		y = y[0:len(x)]
 	}
 	if v == 1 {
-		bytes.Copy(x, y);
+		bytes.Copy(x, y)
 	}
 	return x;
 }
 
 func constantTimeCopyWrapper(v int, x, y []byte) []byte {
 	if len(x) > len(y) {
-		x = x[0:len(y)];
+		x = x[0:len(y)]
 	} else {
-		y = y[0:len(x)];
+		y = y[0:len(x)]
 	}
 	v &= 1;
 	ConstantTimeCopy(v, x, y);
@@ -101,6 +101,6 @@ func constantTimeCopyWrapper(v int, x, y []byte) []byte {
 func TestConstantTimeCopy(t *testing.T) {
 	err := quick.CheckEqual(constantTimeCopyWrapper, copy, nil);
 	if err != nil {
-		t.Error(err);
+		t.Error(err)
 	}
 }
diff --git a/src/pkg/crypto/tls/common.go b/src/pkg/crypto/tls/common.go
index 36ad640cd6..d0ea5f6e24 100644
--- a/src/pkg/crypto/tls/common.go
+++ b/src/pkg/crypto/tls/common.go
@@ -92,12 +92,12 @@ type encryptor interface {
 func mutualVersion(theirMajor, theirMinor uint8) (major, minor uint8, ok bool) {
 	// We don't deal with peers < TLS 1.0 (aka version 3.1).
 	if theirMajor < 3 || theirMajor == 3 && theirMinor < 1 {
-		return 0, 0, false;
+		return 0, 0, false
 	}
 	major = 3;
 	minor = 2;
 	if theirMinor < minor {
-		minor = theirMinor;
+		minor = theirMinor
 	}
 	ok = true;
 	return;
diff --git a/src/pkg/crypto/tls/handshake_messages.go b/src/pkg/crypto/tls/handshake_messages.go
index f2d88d8db9..0eb91fe742 100644
--- a/src/pkg/crypto/tls/handshake_messages.go
+++ b/src/pkg/crypto/tls/handshake_messages.go
@@ -19,7 +19,7 @@ type clientHelloMsg struct {
 
 func (m *clientHelloMsg) marshal() []byte {
 	if m.raw != nil {
-		return m.raw;
+		return m.raw
 	}
 
 	length := 2 + 32 + 1 + len(m.sessionId) + 2 + len(m.cipherSuites)*2 + 1 + len(m.compressionMethods);
@@ -50,7 +50,7 @@ func (m *clientHelloMsg) marshal() []byte {
 
 func (m *clientHelloMsg) unmarshal(data []byte) bool {
 	if len(data) < 39 {
-		return false;
+		return false
 	}
 	m.raw = data;
 	m.major = data[4];
@@ -58,31 +58,31 @@ func (m *clientHelloMsg) unmarshal(data []byte) bool {
 	m.random = data[6:38];
 	sessionIdLen := int(data[38]);
 	if sessionIdLen > 32 || len(data) < 39 + sessionIdLen {
-		return false;
+		return false
 	}
 	m.sessionId = data[39 : 39 + sessionIdLen];
 	data = data[39 + sessionIdLen : len(data)];
 	if len(data) < 2 {
-		return false;
+		return false
 	}
 	// cipherSuiteLen is the number of bytes of cipher suite numbers. Since
 	// they are uint16s, the number must be even.
 	cipherSuiteLen := int(data[0])<<8 | int(data[1]);
 	if cipherSuiteLen % 2 == 1 || len(data) < 2 + cipherSuiteLen {
-		return false;
+		return false
 	}
 	numCipherSuites := cipherSuiteLen / 2;
 	m.cipherSuites = make([]uint16, numCipherSuites);
 	for i := 0; i < numCipherSuites; i++ {
-		m.cipherSuites[i] = uint16(data[2 + 2*i])<<8 | uint16(data[3 + 2*i]);
+		m.cipherSuites[i] = uint16(data[2 + 2*i])<<8 | uint16(data[3 + 2*i])
 	}
 	data = data[2 + cipherSuiteLen : len(data)];
 	if len(data) < 2 {
-		return false;
+		return false
 	}
 	compressionMethodsLen := int(data[0]);
 	if len(data) < 1 + compressionMethodsLen {
-		return false;
+		return false
 	}
 	m.compressionMethods = data[1 : 1 + compressionMethodsLen];
 
@@ -101,7 +101,7 @@ type serverHelloMsg struct {
 
 func (m *serverHelloMsg) marshal() []byte {
 	if m.raw != nil {
-		return m.raw;
+		return m.raw
 	}
 
 	length := 38+len(m.sessionId);
@@ -131,12 +131,12 @@ type certificateMsg struct {
 
 func (m *certificateMsg) marshal() (x []byte) {
 	if m.raw != nil {
-		return m.raw;
+		return m.raw
 	}
 
 	var i int;
 	for _, slice := range m.certificates {
-		i += len(slice);
+		i += len(slice)
 	}
 
 	length := 3 + 3*len(m.certificates) + i;
@@ -179,7 +179,7 @@ type clientKeyExchangeMsg struct {
 
 func (m *clientKeyExchangeMsg) marshal() []byte {
 	if m.raw != nil {
-		return m.raw;
+		return m.raw
 	}
 	length := len(m.ciphertext)+2;
 	x := make([]byte, length+4);
@@ -198,11 +198,11 @@ func (m *clientKeyExchangeMsg) marshal() []byte {
 func (m *clientKeyExchangeMsg) unmarshal(data []byte) bool {
 	m.raw = data;
 	if len(data) < 7 {
-		return false;
+		return false
 	}
 	cipherTextLen := int(data[4])<<8 | int(data[5]);
 	if len(data) != 6 + cipherTextLen {
-		return false;
+		return false
 	}
 	m.ciphertext = data[6:len(data)];
 	return true;
@@ -215,7 +215,7 @@ type finishedMsg struct {
 
 func (m *finishedMsg) marshal() (x []byte) {
 	if m.raw != nil {
-		return m.raw;
+		return m.raw
 	}
 
 	x = make([]byte, 16);
@@ -229,7 +229,7 @@ func (m *finishedMsg) marshal() (x []byte) {
 func (m *finishedMsg) unmarshal(data []byte) bool {
 	m.raw = data;
 	if len(data) != 4+12 {
-		return false;
+		return false
 	}
 	m.verifyData = data[4:len(data)];
 	return true;
diff --git a/src/pkg/crypto/tls/handshake_messages_test.go b/src/pkg/crypto/tls/handshake_messages_test.go
index ff4d741b14..0fd3e48596 100644
--- a/src/pkg/crypto/tls/handshake_messages_test.go
+++ b/src/pkg/crypto/tls/handshake_messages_test.go
@@ -62,7 +62,7 @@ func TestMarshalUnmarshal(t *testing.T) {
 func randomBytes(n int, rand *rand.Rand) []byte {
 	r := make([]byte, n);
 	for i := 0; i < n; i++ {
-		r[i] = byte(rand.Int31());
+		r[i] = byte(rand.Int31())
 	}
 	return r;
 }
@@ -75,7 +75,7 @@ func (*clientHelloMsg) Generate(rand *rand.Rand, size int) reflect.Value {
 	m.sessionId = randomBytes(rand.Intn(32), rand);
 	m.cipherSuites = make([]uint16, rand.Intn(63) + 1);
 	for i := 0; i < len(m.cipherSuites); i++ {
-		m.cipherSuites[i] = uint16(rand.Int31());
+		m.cipherSuites[i] = uint16(rand.Int31())
 	}
 	m.compressionMethods = randomBytes(rand.Intn(63) + 1, rand);
 
diff --git a/src/pkg/crypto/tls/handshake_server_test.go b/src/pkg/crypto/tls/handshake_server_test.go
index 4e7507e861..91583d2da5 100644
--- a/src/pkg/crypto/tls/handshake_server_test.go
+++ b/src/pkg/crypto/tls/handshake_server_test.go
@@ -17,7 +17,7 @@ type zeroSource struct{}
 
 func (zeroSource) Read(b []byte) (n int, err os.Error) {
 	for i := range b {
-		b[i] = 0;
+		b[i] = 0
 	}
 
 	return len(b), nil;
@@ -56,12 +56,12 @@ func testClientHelloFailure(t *testing.T, clientHello interface{}, expectedAlert
 
 	err := script.Perform(0, []*script.Event{send, recvAlert, close1, recvState, close2});
 	if err != nil {
-		t.Errorf("Got error: %s", err);
+		t.Errorf("Got error: %s", err)
 	}
 }
 
 func TestSimpleError(t *testing.T) {
-	testClientHelloFailure(t, &serverHelloDoneMsg{}, alertUnexpectedMessage);
+	testClientHelloFailure(t, &serverHelloDoneMsg{}, alertUnexpectedMessage)
 }
 
 var badProtocolVersions = []uint8{0, 0, 0, 5, 1, 0, 1, 5, 2, 0, 2, 5, 3, 0}
@@ -91,7 +91,7 @@ func TestNoCompressionOverlap(t *testing.T) {
 func matchServerHello(v interface{}) bool {
 	serverHello, ok := v.(*serverHelloMsg);
 	if !ok {
-		return false;
+		return false
 	}
 	return serverHello.major == 3 &&
 		serverHello.minor == 2 &&
@@ -111,7 +111,7 @@ func TestAlertForwarding(t *testing.T) {
 
 	err := script.Perform(0, []*script.Event{sendAlert, recvAlert, closeWriter, closeControl});
 	if err != nil {
-		t.Errorf("Got error: %s", err);
+		t.Errorf("Got error: %s", err)
 	}
 }
 
@@ -124,14 +124,14 @@ func TestClose(t *testing.T) {
 
 	err := script.Perform(0, []*script.Event{close, closed1, closed2});
 	if err != nil {
-		t.Errorf("Got error: %s", err);
+		t.Errorf("Got error: %s", err)
 	}
 }
 
 func matchCertificate(v interface{}) bool {
 	cert, ok := v.(*certificateMsg);
 	if !ok {
-		return false;
+		return false
 	}
 	return len(cert.certificates) == 1 &&
 		bytes.Compare(cert.certificates[0], testCertificate) == 0;
@@ -150,7 +150,7 @@ func matchDone(v interface{}) bool {
 func matchFinished(v interface{}) bool {
 	finished, ok := v.(*finishedMsg);
 	if !ok {
-		return false;
+		return false
 	}
 	return bytes.Compare(finished.verifyData, fromHex("29122ae11453e631487b02ed")) == 0;
 }
@@ -187,7 +187,7 @@ func TestFullHandshake(t *testing.T) {
 
 	err := script.Perform(0, []*script.Event{sendHello, setVersion, recvHello, recvCert, recvDone, sendCKX, sendCCS, recvNCS, sendFinished, setCipher, recvConnectionState, recvFinished});
 	if err != nil {
-		t.Errorf("Got error: %s", err);
+		t.Errorf("Got error: %s", err)
 	}
 }
 
diff --git a/src/pkg/crypto/tls/prf.go b/src/pkg/crypto/tls/prf.go
index fb2ae658ed..f8f3aa452a 100644
--- a/src/pkg/crypto/tls/prf.go
+++ b/src/pkg/crypto/tls/prf.go
@@ -35,7 +35,7 @@ func pHash(result, secret, seed []byte, hash hash.Hash) {
 		b := h.Sum();
 		todo := len(b);
 		if j+todo > len(result) {
-			todo = len(result)-j;
+			todo = len(result)-j
 		}
 		bytes.Copy(result[j : j+todo], b);
 		j += todo;
@@ -61,7 +61,7 @@ func pRF11(result, secret, label, seed []byte) {
 	pHash(result2, s2, labelAndSeed, hashSHA1);
 
 	for i, b := range result2 {
-		result[i] ^= b;
+		result[i] ^= b
 	}
 }
 
@@ -109,7 +109,7 @@ type finishedHash struct {
 }
 
 func newFinishedHash() finishedHash {
-	return finishedHash{md5.New(), sha1.New(), md5.New(), sha1.New()};
+	return finishedHash{md5.New(), sha1.New(), md5.New(), sha1.New()}
 }
 
 func (h finishedHash) Write(msg []byte) (n int, err os.Error) {
diff --git a/src/pkg/crypto/tls/prf_test.go b/src/pkg/crypto/tls/prf_test.go
index dc7d3cca71..0d4a4db35e 100644
--- a/src/pkg/crypto/tls/prf_test.go
+++ b/src/pkg/crypto/tls/prf_test.go
@@ -28,7 +28,7 @@ func TestSplitPreMasterSecret(t *testing.T) {
 		s1 := hex.EncodeToString(out1);
 		s2 := hex.EncodeToString(out2);
 		if s1 != test.out1 || s2 != test.out2 {
-			t.Errorf("#%d: got: (%s, %s) want: (%s, %s)", i, s1, s2, test.out1, test.out2);
+			t.Errorf("#%d: got: (%s, %s) want: (%s, %s)", i, s1, s2, test.out1, test.out2)
 		}
 	}
 }
@@ -58,7 +58,7 @@ func TestKeysFromPreMasterSecret(t *testing.T) {
 			serverMACString != test.serverMAC ||
 			clientKeyString != test.clientKey ||
 			serverKeyString != test.serverKey {
-			t.Errorf("#%d: got: (%s, %s, %s, %s, %s) want: (%s, %s, %s, %s %s)", i, masterString, clientMACString, serverMACString, clientKeyString, serverMACString, test.masterSecret, test.clientMAC, test.serverMAC, test.clientKey, test.serverKey);
+			t.Errorf("#%d: got: (%s, %s, %s, %s, %s) want: (%s, %s, %s, %s %s)", i, masterString, clientMACString, serverMACString, clientKeyString, serverMACString, test.masterSecret, test.clientMAC, test.serverMAC, test.clientKey, test.serverKey)
 		}
 	}
 }
diff --git a/src/pkg/crypto/tls/record_process.go b/src/pkg/crypto/tls/record_process.go
index 1cd6879af9..9a20ab68be 100644
--- a/src/pkg/crypto/tls/record_process.go
+++ b/src/pkg/crypto/tls/record_process.go
@@ -73,13 +73,13 @@ type recordProcessor struct {
 func drainRequestChannel(requestChan <-chan interface{}, c ConnectionState) {
 	for v := range requestChan {
 		if closed(requestChan) {
-			return;
+			return
 		}
 		switch r := v.(type) {
 		case getConnectionState:
-			r.reply <- c;
+			r.reply <- c
 		case waitConnectionState:
-			r.reply <- c;
+			r.reply <- c
 		}
 	}
 }
@@ -104,11 +104,11 @@ func (p *recordProcessor) loop(appDataChan chan<- []byte, requestChan <-chan int
 			p.appDataSend = nil;
 			p.recordRead = p.recordChan;
 		case c := <-controlChan:
-			p.processControlMsg(c);
+			p.processControlMsg(c)
 		case r := <-requestChan:
-			p.processRequestMsg(r);
+			p.processRequestMsg(r)
 		case r := <-p.recordRead:
-			p.processRecord(r);
+			p.processRecord(r)
 		}
 	}
 
@@ -121,7 +121,7 @@ func (p *recordProcessor) loop(appDataChan chan<- []byte, requestChan <-chan int
 
 	close(handshakeChan);
 	if len(p.appData) > 0 {
-		appDataChan <- p.appData;
+		appDataChan <- p.appData
 	}
 	close(appDataChan);
 }
@@ -134,10 +134,10 @@ func (p *recordProcessor) processRequestMsg(requestMsg interface{}) {
 
 	switch r := requestMsg.(type) {
 	case getConnectionState:
-		r.reply <- p.connState;
+		r.reply <- p.connState
 	case waitConnectionState:
 		if p.connState.HandshakeComplete {
-			r.reply <- p.connState;
+			r.reply <- p.connState
 		}
 		p.waitQueue.PushBack(r.reply);
 	}
@@ -156,7 +156,7 @@ func (p *recordProcessor) processControlMsg(msg interface{}) {
 
 func (p *recordProcessor) wakeWaiters() {
 	for i := p.waitQueue.Front(); i != nil; i = i.Next() {
-		i.Value.(chan<- ConnectionState) <- p.connState;
+		i.Value.(chan<- ConnectionState) <- p.connState
 	}
 	p.waitQueue.Init();
 }
@@ -188,7 +188,7 @@ func (p *recordProcessor) processRecord(r *record) {
 
 	switch r.contentType {
 	case recordTypeHandshake:
-		p.processHandshakeRecord(r.payload[0 : len(r.payload) - p.mac.Size()]);
+		p.processHandshakeRecord(r.payload[0 : len(r.payload) - p.mac.Size()])
 	case recordTypeChangeCipherSpec:
 		if len(r.payload) != 1 || r.payload[0] != 1 {
 			p.error(alertUnexpectedMessage);
@@ -221,7 +221,7 @@ func (p *recordProcessor) processRecord(r *record) {
 
 func (p *recordProcessor) processHandshakeRecord(data []byte) {
 	if p.handshakeBuf == nil {
-		p.handshakeBuf = data;
+		p.handshakeBuf = data
 	} else {
 		if len(p.handshakeBuf) > maxHandshakeMsg {
 			p.error(alertInternalError);
@@ -238,7 +238,7 @@ func (p *recordProcessor) processHandshakeRecord(data []byte) {
 			int(p.handshakeBuf[2])<<8 |
 			int(p.handshakeBuf[3]);
 		if handshakeLen + 4 > len(p.handshakeBuf) {
-			break;
+			break
 		}
 
 		bytes := p.handshakeBuf[0 : handshakeLen + 4];
@@ -249,7 +249,7 @@ func (p *recordProcessor) processHandshakeRecord(data []byte) {
 			// forwarding application data.
 			m := new(finishedMsg);
 			if !m.unmarshal(bytes) {
-				p.error(alertUnexpectedMessage);
+				p.error(alertUnexpectedMessage)
 			}
 			p.handshakeChan <- m;
 			var ok bool;
@@ -283,11 +283,11 @@ func parseHandshakeMsg(data []byte) (interface{}, bool) {
 
 	switch data[0] {
 	case typeClientHello:
-		m = new(clientHelloMsg);
+		m = new(clientHelloMsg)
 	case typeClientKeyExchange:
-		m = new(clientKeyExchangeMsg);
+		m = new(clientKeyExchangeMsg)
 	default:
-		return nil, false;
+		return nil, false
 	}
 
 	ok := m.unmarshal(data);
diff --git a/src/pkg/crypto/tls/record_process_test.go b/src/pkg/crypto/tls/record_process_test.go
index 30e2126dcf..1d019e30de 100644
--- a/src/pkg/crypto/tls/record_process_test.go
+++ b/src/pkg/crypto/tls/record_process_test.go
@@ -40,7 +40,7 @@ func TestNullConnectionState(t *testing.T) {
 
 	err := script.Perform(0, []*script.Event{sendReq, getReply});
 	if err != nil {
-		t.Errorf("Got error: %s", err);
+		t.Errorf("Got error: %s", err)
 	}
 }
 
@@ -61,7 +61,7 @@ func TestWaitConnectionState(t *testing.T) {
 
 	err := script.Perform(0, []*script.Event{sendReq, sendReq2, getReply2, sendState, getReply});
 	if err != nil {
-		t.Errorf("Got error: %s", err);
+		t.Errorf("Got error: %s", err)
 	}
 }
 
@@ -79,7 +79,7 @@ func TestHandshakeAssembly(t *testing.T) {
 
 	err := script.Perform(0, []*script.Event{send1, send2, send3, recvMsg});
 	if err != nil {
-		t.Errorf("Got error: %s", err);
+		t.Errorf("Got error: %s", err)
 	}
 }
 
@@ -95,7 +95,7 @@ func TestEarlyApplicationData(t *testing.T) {
 
 	err := script.Perform(0, []*script.Event{send, recv});
 	if err != nil {
-		t.Errorf("Got error: %s", err);
+		t.Errorf("Got error: %s", err)
 	}
 }
 
@@ -114,7 +114,7 @@ func TestApplicationData(t *testing.T) {
 
 	err := script.Perform(0, []*script.Event{send1, recv1, send2, send3, recv2});
 	if err != nil {
-		t.Errorf("Got error: %s", err);
+		t.Errorf("Got error: %s", err)
 	}
 }
 
@@ -132,6 +132,6 @@ func TestInvalidChangeCipherSpec(t *testing.T) {
 
 	err := script.Perform(0, []*script.Event{send1, recv1, send2, close, close2});
 	if err != nil {
-		t.Errorf("Got error: %s", err);
+		t.Errorf("Got error: %s", err)
 	}
 }
diff --git a/src/pkg/crypto/tls/record_read.go b/src/pkg/crypto/tls/record_read.go
index 27b0455361..877cfc797d 100644
--- a/src/pkg/crypto/tls/record_read.go
+++ b/src/pkg/crypto/tls/record_read.go
@@ -23,18 +23,18 @@ func recordReader(c chan<- *record, source io.Reader) {
 		var header [5]byte;
 		n, _ := buf.Read(header[0:len(header)]);
 		if n != 5 {
-			return;
+			return
 		}
 
 		recordLength := int(header[3])<<8 | int(header[4]);
 		if recordLength > maxTLSCiphertext {
-			return;
+			return
 		}
 
 		payload := make([]byte, recordLength);
 		n, _ = buf.Read(payload);
 		if n != recordLength {
-			return;
+			return
 		}
 
 		c <- &record{recordType(header[0]), header[1], header[2], payload};
diff --git a/src/pkg/crypto/tls/record_read_test.go b/src/pkg/crypto/tls/record_read_test.go
index 7bd943c723..ce1a8e6b4c 100644
--- a/src/pkg/crypto/tls/record_read_test.go
+++ b/src/pkg/crypto/tls/record_read_test.go
@@ -12,10 +12,10 @@ import (
 
 func matchRecord(r1, r2 *record) bool {
 	if (r1 == nil) != (r2 == nil) {
-		return false;
+		return false
 	}
 	if r1 == nil {
-		return true;
+		return true
 	}
 	return r1.contentType == r2.contentType &&
 		r1.major == r2.major &&
@@ -63,11 +63,11 @@ func matchRecordReaderOutput(t *testing.T, i int, test recordReaderTest, c <-cha
 			break;
 		}
 		if !matchRecord(r1, r2) {
-			t.Errorf("#%d (%d) got:%#v want:%#v", i, j, r2, r1);
+			t.Errorf("#%d (%d) got:%#v want:%#v", i, j, r2, r1)
 		}
 	}
 	<-c;
 	if !closed(c) {
-		t.Errorf("#%d: channel didn't close", i);
+		t.Errorf("#%d: channel didn't close", i)
 	}
 }
diff --git a/src/pkg/crypto/tls/record_write.go b/src/pkg/crypto/tls/record_write.go
index 38135c9799..7fcc603977 100644
--- a/src/pkg/crypto/tls/record_write.go
+++ b/src/pkg/crypto/tls/record_write.go
@@ -53,7 +53,7 @@ func (w *recordWriter) loop(writer io.Writer, appChan <-chan []byte, controlChan
 	for !w.shutdown {
 		msg := <-controlChan;
 		if _, ok := msg.(writerEnableApplicationData); ok {
-			break;
+			break
 		}
 		w.processControlMessage(msg);
 	}
@@ -67,9 +67,9 @@ func (w *recordWriter) loop(writer io.Writer, appChan <-chan []byte, controlChan
 
 		select {
 		case controlMsg := <-controlChan:
-			w.processControlMessage(controlMsg);
+			w.processControlMessage(controlMsg)
 		case appMsg := <-appChan:
-			w.processAppMessage(appMsg);
+			w.processAppMessage(appMsg)
 		}
 	}
 
@@ -77,13 +77,13 @@ func (w *recordWriter) loop(writer io.Writer, appChan <-chan []byte, controlChan
 		go func() {
 			for _ = range appChan {
 			}
-		}();
+		}()
 	}
 	if !closed(controlChan) {
 		go func() {
 			for _ = range controlChan {
 			}
-		}();
+		}()
 	}
 }
 
@@ -142,12 +142,12 @@ func (w *recordWriter) processControlMessage(controlMsg interface{}) {
 		w.major = msg.major;
 		w.minor = msg.minor;
 	case alert:
-		w.writeRecord(&record{recordTypeAlert, w.major, w.minor, []byte{byte(msg.level), byte(msg.error)}});
+		w.writeRecord(&record{recordTypeAlert, w.major, w.minor, []byte{byte(msg.level), byte(msg.error)}})
 	case handshakeMessage:
 		// TODO(agl): marshal may return a slice too large for a single record.
-		w.writeRecord(&record{recordTypeHandshake, w.major, w.minor, msg.marshal()});
+		w.writeRecord(&record{recordTypeHandshake, w.major, w.minor, msg.marshal()})
 	default:
-		fmt.Printf("processControlMessage: unknown %#v\n", msg);
+		fmt.Printf("processControlMessage: unknown %#v\n", msg)
 	}
 }
 
@@ -162,7 +162,7 @@ func (w *recordWriter) processAppMessage(appMsg []byte) {
 	for done < len(appMsg) {
 		todo := len(appMsg);
 		if todo > maxTLSPlaintext {
-			todo = maxTLSPlaintext;
+			todo = maxTLSPlaintext
 		}
 		w.writeRecord(&record{recordTypeApplicationData, w.major, w.minor, appMsg[done : done+todo]});
 		done += todo;
diff --git a/src/pkg/crypto/tls/tls.go b/src/pkg/crypto/tls/tls.go
index c20e24e55c..20b1139e0d 100644
--- a/src/pkg/crypto/tls/tls.go
+++ b/src/pkg/crypto/tls/tls.go
@@ -32,7 +32,7 @@ func timeout(c chan<- bool, nsecs int64) {
 func (tls *Conn) Read(p []byte) (int, os.Error) {
 	if len(tls.readBuf) == 0 {
 		if tls.eof {
-			return 0, os.EOF;
+			return 0, os.EOF
 		}
 
 		var timeoutChan chan bool;
@@ -43,15 +43,15 @@ func (tls *Conn) Read(p []byte) (int, os.Error) {
 
 		select {
 		case b := <-tls.readChan:
-			tls.readBuf = b;
+			tls.readBuf = b
 		case <-timeoutChan:
-			return 0, os.EAGAIN;
+			return 0, os.EAGAIN
 		}
 
 		// TLS distinguishes between orderly closes and truncations. An
 		// orderly close is represented by a zero length slice.
 		if closed(tls.readChan) {
-			return 0, io.ErrUnexpectedEOF;
+			return 0, io.ErrUnexpectedEOF
 		}
 		if len(tls.readBuf) == 0 {
 			tls.eof = true;
@@ -66,7 +66,7 @@ func (tls *Conn) Read(p []byte) (int, os.Error) {
 
 func (tls *Conn) Write(p []byte) (int, os.Error) {
 	if tls.eof || closed(tls.readChan) {
-		return 0, os.EOF;
+		return 0, os.EOF
 	}
 
 	var timeoutChan chan bool;
@@ -78,7 +78,7 @@ func (tls *Conn) Write(p []byte) (int, os.Error) {
 	select {
 	case tls.writeChan <- p:
 	case <-timeoutChan:
-		return 0, os.EAGAIN;
+		return 0, os.EAGAIN
 	}
 
 	return len(p), nil;
@@ -148,7 +148,7 @@ type Listener struct {
 func (l Listener) Accept() (c net.Conn, err os.Error) {
 	c, err = l.listener.Accept();
 	if err != nil {
-		return;
+		return
 	}
 
 	c = Server(c, l.config);
diff --git a/src/pkg/crypto/x509/x509.go b/src/pkg/crypto/x509/x509.go
index 87829ec8e2..572b4e6394 100644
--- a/src/pkg/crypto/x509/x509.go
+++ b/src/pkg/crypto/x509/x509.go
@@ -26,7 +26,7 @@ type pkcs1PrivateKey struct {
 
 // rawValueIsInteger returns true iff the given ASN.1 RawValue is an INTEGER type.
 func rawValueIsInteger(raw *asn1.RawValue) bool {
-	return raw.Class == 0 && raw.Tag == 2 && raw.IsCompound == false;
+	return raw.Class == 0 && raw.Tag == 2 && raw.IsCompound == false
 }
 
 // ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.
@@ -34,7 +34,7 @@ func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err os.Error) {
 	var priv pkcs1PrivateKey;
 	err = asn1.Unmarshal(&priv, der);
 	if err != nil {
-		return;
+		return
 	}
 
 	if !rawValueIsInteger(&priv.N) ||
@@ -57,7 +57,7 @@ func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err os.Error) {
 
 	err = key.Validate();
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	return;
 }
diff --git a/src/pkg/crypto/x509/x509_test.go b/src/pkg/crypto/x509/x509_test.go
index 4b2a5ec8a2..2c94d35ee7 100644
--- a/src/pkg/crypto/x509/x509_test.go
+++ b/src/pkg/crypto/x509/x509_test.go
@@ -17,10 +17,10 @@ func TestParsePKCS1PrivateKey(t *testing.T) {
 	block, _ := pem.Decode(strings.Bytes(pemPrivateKey));
 	priv, err := ParsePKCS1PrivateKey(block.Bytes);
 	if err != nil {
-		t.Errorf("Failed to parse private key: %s", err);
+		t.Errorf("Failed to parse private key: %s", err)
 	}
 	if !reflect.DeepEqual(priv, rsaPrivateKey) {
-		t.Errorf("got:%+v want:%+v", priv, rsaPrivateKey);
+		t.Errorf("got:%+v want:%+v", priv, rsaPrivateKey)
 	}
 }
 
diff --git a/src/pkg/debug/dwarf/buf.go b/src/pkg/debug/dwarf/buf.go
index 87576e65ce..2838c098fd 100644
--- a/src/pkg/debug/dwarf/buf.go
+++ b/src/pkg/debug/dwarf/buf.go
@@ -24,7 +24,7 @@ type buf struct {
 }
 
 func makeBuf(d *Data, name string, off Offset, data []byte, addrsize int) buf {
-	return buf{d, d.order, name, off, data, addrsize, nil};
+	return buf{d, d.order, name, off, data, addrsize, nil}
 }
 
 func (b *buf) uint8() uint8 {
@@ -67,7 +67,7 @@ func (b *buf) string() string {
 func (b *buf) uint16() uint16 {
 	a := b.bytes(2);
 	if a == nil {
-		return 0;
+		return 0
 	}
 	return b.order.Uint16(a);
 }
@@ -75,7 +75,7 @@ func (b *buf) uint16() uint16 {
 func (b *buf) uint32() uint32 {
 	a := b.bytes(4);
 	if a == nil {
-		return 0;
+		return 0
 	}
 	return b.order.Uint32(a);
 }
@@ -83,7 +83,7 @@ func (b *buf) uint32() uint32 {
 func (b *buf) uint64() uint64 {
 	a := b.bytes(8);
 	if a == nil {
-		return 0;
+		return 0
 	}
 	return b.order.Uint64(a);
 }
@@ -115,7 +115,7 @@ func (b *buf) int() int64 {
 	ux, bits := b.varint();
 	x := int64(ux);
 	if x&(1<<(bits-1)) != 0 {
-		x |= -1 << bits;
+		x |= -1 << bits
 	}
 	return x;
 }
@@ -124,13 +124,13 @@ func (b *buf) int() int64 {
 func (b *buf) addr() uint64 {
 	switch b.addrsize {
 	case 1:
-		return uint64(b.uint8());
+		return uint64(b.uint8())
 	case 2:
-		return uint64(b.uint16());
+		return uint64(b.uint16())
 	case 4:
-		return uint64(b.uint32());
+		return uint64(b.uint32())
 	case 8:
-		return uint64(b.uint64());
+		return uint64(b.uint64())
 	}
 	b.error("unknown address size");
 	return 0;
@@ -150,5 +150,5 @@ type DecodeError struct {
 }
 
 func (e DecodeError) String() string {
-	return "decoding dwarf section " + e.Name + " at offset 0x" + strconv.Itob64(int64(e.Offset), 16) + ": " + e.Error;
+	return "decoding dwarf section " + e.Name + " at offset 0x" + strconv.Itob64(int64(e.Offset), 16) + ": " + e.Error
 }
diff --git a/src/pkg/debug/dwarf/const.go b/src/pkg/debug/dwarf/const.go
index 0b626c4b56..808a80c8a4 100644
--- a/src/pkg/debug/dwarf/const.go
+++ b/src/pkg/debug/dwarf/const.go
@@ -165,7 +165,7 @@ func (a Attr) String() string {
 	if int(a) < len(attrNames) {
 		s := attrNames[a];
 		if s != "" {
-			return s;
+			return s
 		}
 	}
 	return strconv.Itoa(int(a));
@@ -175,7 +175,7 @@ func (a Attr) GoString() string {
 	if int(a) < len(attrNames) {
 		s := attrNames[a];
 		if s != "" {
-			return "dwarf.Attr" + s;
+			return "dwarf.Attr" + s
 		}
 	}
 	return "dwarf.Attr(" + strconv.Itoa64(int64(a)) + ")";
@@ -334,7 +334,7 @@ func (t Tag) String() string {
 	if int(t) < len(tagNames) {
 		s := tagNames[t];
 		if s != "" {
-			return s;
+			return s
 		}
 	}
 	return strconv.Itoa(int(t));
@@ -344,7 +344,7 @@ func (t Tag) GoString() string {
 	if int(t) < len(tagNames) {
 		s := tagNames[t];
 		if s != "" {
-			return "dwarf.Tag" + s;
+			return "dwarf.Tag" + s
 		}
 	}
 	return "dwarf.Tag(" + strconv.Itoa64(int64(t)) + ")";
diff --git a/src/pkg/debug/dwarf/entry.go b/src/pkg/debug/dwarf/entry.go
index 97e58af402..9b2727b26d 100644
--- a/src/pkg/debug/dwarf/entry.go
+++ b/src/pkg/debug/dwarf/entry.go
@@ -31,14 +31,14 @@ type abbrevTable map[uint32]abbrev
 // in the .debug_abbrev section.
 func (d *Data) parseAbbrev(off uint32) (abbrevTable, os.Error) {
 	if m, ok := d.abbrevCache[off]; ok {
-		return m, nil;
+		return m, nil
 	}
 
 	data := d.abbrev;
 	if off > uint32(len(data)) {
-		data = nil;
+		data = nil
 	} else {
-		data = data[off:len(data)];
+		data = data[off:len(data)]
 	}
 	b := makeBuf(d, "abbrev", 0, data, 0);
 
@@ -49,7 +49,7 @@ func (d *Data) parseAbbrev(off uint32) (abbrevTable, os.Error) {
 		// Table ends with id == 0.
 		id := uint32(b.uint());
 		if id == 0 {
-			break;
+			break
 		}
 
 		// Walk over attributes, counting.
@@ -61,12 +61,12 @@ func (d *Data) parseAbbrev(off uint32) (abbrevTable, os.Error) {
 			tag := b1.uint();
 			fmt := b1.uint();
 			if tag == 0 && fmt == 0 {
-				break;
+				break
 			}
 			n++;
 		}
 		if b1.err != nil {
-			return nil, b1.err;
+			return nil, b1.err
 		}
 
 		// Walk over attributes again, this time writing them down.
@@ -84,7 +84,7 @@ func (d *Data) parseAbbrev(off uint32) (abbrevTable, os.Error) {
 		m[id] = a;
 	}
 	if b.err != nil {
-		return nil, b.err;
+		return nil, b.err
 	}
 	d.abbrevCache[off] = m;
 	return m, nil;
@@ -114,7 +114,7 @@ type Field struct {
 func (e *Entry) Val(a Attr) interface{} {
 	for _, f := range e.Field {
 		if f.Attr == a {
-			return f.Val;
+			return f.Val
 		}
 	}
 	return nil;
@@ -130,7 +130,7 @@ func (b *buf) entry(atab abbrevTable, ubase Offset) *Entry {
 	off := b.off;
 	id := uint32(b.uint());
 	if id == 0 {
-		return &Entry{};
+		return &Entry{}
 	}
 	a, ok := atab[id];
 	if !ok {
@@ -147,66 +147,66 @@ func (b *buf) entry(atab abbrevTable, ubase Offset) *Entry {
 		e.Field[i].Attr = a.field[i].attr;
 		fmt := a.field[i].fmt;
 		if fmt == formIndirect {
-			fmt = format(b.uint());
+			fmt = format(b.uint())
 		}
 		var val interface{}
 		switch fmt {
 		default:
-			b.error("unknown entry attr format");
+			b.error("unknown entry attr format")
 
 		// address
 		case formAddr:
-			val = b.addr();
+			val = b.addr()
 
 		// block
 		case formDwarfBlock1:
-			val = b.bytes(int(b.uint8()));
+			val = b.bytes(int(b.uint8()))
 		case formDwarfBlock2:
-			val = b.bytes(int(b.uint16()));
+			val = b.bytes(int(b.uint16()))
 		case formDwarfBlock4:
-			val = b.bytes(int(b.uint32()));
+			val = b.bytes(int(b.uint32()))
 		case formDwarfBlock:
-			val = b.bytes(int(b.uint()));
+			val = b.bytes(int(b.uint()))
 
 		// constant
 		case formData1:
-			val = int64(b.uint8());
+			val = int64(b.uint8())
 		case formData2:
-			val = int64(b.uint16());
+			val = int64(b.uint16())
 		case formData4:
-			val = int64(b.uint32());
+			val = int64(b.uint32())
 		case formData8:
-			val = int64(b.uint64());
+			val = int64(b.uint64())
 		case formSdata:
-			val = int64(b.int());
+			val = int64(b.int())
 		case formUdata:
-			val = int64(b.uint());
+			val = int64(b.uint())
 
 		// flag
 		case formFlag:
-			val = b.uint8() == 1;
+			val = b.uint8() == 1
 
 		// reference to other entry
 		case formRefAddr:
-			val = Offset(b.addr());
+			val = Offset(b.addr())
 		case formRef1:
-			val = Offset(b.uint8())+ubase;
+			val = Offset(b.uint8())+ubase
 		case formRef2:
-			val = Offset(b.uint16())+ubase;
+			val = Offset(b.uint16())+ubase
 		case formRef4:
-			val = Offset(b.uint32())+ubase;
+			val = Offset(b.uint32())+ubase
 		case formRef8:
-			val = Offset(b.uint64())+ubase;
+			val = Offset(b.uint64())+ubase
 		case formRefUdata:
-			val = Offset(b.uint())+ubase;
+			val = Offset(b.uint())+ubase
 
 		// string
 		case formString:
-			val = b.string();
+			val = b.string()
 		case formStrp:
 			off := b.uint32();	// offset into .debug_str
 			if b.err != nil {
-				return nil;
+				return nil
 			}
 			b1 := makeBuf(b.dwarf, "str", 0, b.dwarf.str, 0);
 			b1.skip(int(off));
@@ -219,7 +219,7 @@ func (b *buf) entry(atab abbrevTable, ubase Offset) *Entry {
 		e.Field[i].Val = val;
 	}
 	if b.err != nil {
-		return nil;
+		return nil
 	}
 	return e;
 }
@@ -254,7 +254,7 @@ func (r *Reader) Seek(off Offset) {
 	r.lastChildren = false;
 	if off == 0 {
 		if len(d.unit) == 0 {
-			return;
+			return
 		}
 		u := &d.unit[0];
 		r.unit = 0;
@@ -291,11 +291,11 @@ func (r *Reader) maybeNextUnit() {
 // offset cannot be decoded as a valid Entry.
 func (r *Reader) Next() (*Entry, os.Error) {
 	if r.err != nil {
-		return nil, r.err;
+		return nil, r.err
 	}
 	r.maybeNextUnit();
 	if len(r.b.data) == 0 {
-		return nil, nil;
+		return nil, nil
 	}
 	u := &r.d.unit[r.unit];
 	e := r.b.entry(u.atable, u.base);
@@ -306,10 +306,10 @@ func (r *Reader) Next() (*Entry, os.Error) {
 	if e != nil {
 		r.lastChildren = e.Children;
 		if r.lastChildren {
-			r.lastSibling, _ = e.Val(AttrSibling).(Offset);
+			r.lastSibling, _ = e.Val(AttrSibling).(Offset)
 		}
 	} else {
-		r.lastChildren = false;
+		r.lastChildren = false
 	}
 	return e, nil;
 }
@@ -319,7 +319,7 @@ func (r *Reader) Next() (*Entry, os.Error) {
 // children or Next has not been called, SkipChildren is a no-op.
 func (r *Reader) SkipChildren() {
 	if r.err != nil || !r.lastChildren {
-		return;
+		return
 	}
 
 	// If the last entry had a sibling attribute,
@@ -334,10 +334,10 @@ func (r *Reader) SkipChildren() {
 	for {
 		e, err := r.Next();
 		if err != nil || e == nil || e.Tag == 0 {
-			break;
+			break
 		}
 		if e.Children {
-			r.SkipChildren();
+			r.SkipChildren()
 		}
 	}
 }
diff --git a/src/pkg/debug/dwarf/open.go b/src/pkg/debug/dwarf/open.go
index 1b50beaa4d..a5cb1a1034 100644
--- a/src/pkg/debug/dwarf/open.go
+++ b/src/pkg/debug/dwarf/open.go
@@ -57,23 +57,23 @@ func New(abbrev, aranges, frame, info, line, pubnames, ranges, str []byte) (*Dat
 	// Sniff .debug_info to figure out byte order.
 	// bytes 4:6 are the version, a tiny 16-bit number (1, 2, 3).
 	if len(d.info) < 6 {
-		return nil, DecodeError{"info", Offset(len(d.info)), "too short"};
+		return nil, DecodeError{"info", Offset(len(d.info)), "too short"}
 	}
 	x, y := d.info[4], d.info[5];
 	switch {
 	case x == 0 && y == 0:
-		return nil, DecodeError{"info", 4, "unsupported version 0"};
+		return nil, DecodeError{"info", 4, "unsupported version 0"}
 	case x == 0:
-		d.order = binary.BigEndian;
+		d.order = binary.BigEndian
 	case y == 0:
-		d.order = binary.LittleEndian;
+		d.order = binary.LittleEndian
 	default:
-		return nil, DecodeError{"info", 4, "cannot determine byte order"};
+		return nil, DecodeError{"info", 4, "cannot determine byte order"}
 	}
 
 	u, err := d.parseUnits();
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	d.unit = u;
 	return d, nil;
diff --git a/src/pkg/debug/dwarf/type.go b/src/pkg/debug/dwarf/type.go
index 77d24f5d27..2cac2e4fb3 100644
--- a/src/pkg/debug/dwarf/type.go
+++ b/src/pkg/debug/dwarf/type.go
@@ -46,7 +46,7 @@ func (b *BasicType) Basic() *BasicType	{ return b }
 
 func (t *BasicType) String() string {
 	if t.Name != "" {
-		return t.Name;
+		return t.Name
 	}
 	return "?";
 }
@@ -113,7 +113,7 @@ type ArrayType struct {
 }
 
 func (t *ArrayType) String() string {
-	return "[" + strconv.Itoa64(t.Count) + "]" + t.Type.String();
+	return "[" + strconv.Itoa64(t.Count) + "]" + t.Type.String()
 }
 
 func (t *ArrayType) Size() int64	{ return t.Count * t.Type.Size() }
@@ -154,7 +154,7 @@ type StructField struct {
 
 func (t *StructType) String() string {
 	if t.StructName != "" {
-		return t.Kind + " " + t.StructName;
+		return t.Kind + " " + t.StructName
 	}
 	return t.Defn();
 }
@@ -162,7 +162,7 @@ func (t *StructType) String() string {
 func (t *StructType) Defn() string {
 	s := t.Kind;
 	if t.StructName != "" {
-		s += " " + t.StructName;
+		s += " " + t.StructName
 	}
 	if t.Incomplete {
 		s += " /*incomplete*/";
@@ -171,7 +171,7 @@ func (t *StructType) Defn() string {
 	s += " {";
 	for i, f := range t.Field {
 		if i > 0 {
-			s += "; ";
+			s += "; "
 		}
 		s += f.Name + " " + f.Type.String();
 		s += "@" + strconv.Itoa64(f.ByteOffset);
@@ -202,12 +202,12 @@ type EnumValue struct {
 func (t *EnumType) String() string {
 	s := "enum";
 	if t.EnumName != "" {
-		s += " " + t.EnumName;
+		s += " " + t.EnumName
 	}
 	s += " {";
 	for i, v := range t.Val {
 		if i > 0 {
-			s += "; ";
+			s += "; "
 		}
 		s += v.Name + "=" + strconv.Itoa64(v.Val);
 	}
@@ -226,13 +226,13 @@ func (t *FuncType) String() string {
 	s := "func(";
 	for i, t := range t.ParamType {
 		if i > 0 {
-			s += ", ";
+			s += ", "
 		}
 		s += t.String();
 	}
 	s += ")";
 	if t.ReturnType != nil {
-		s += " " + t.ReturnType.String();
+		s += " " + t.ReturnType.String()
 	}
 	return s;
 }
@@ -256,17 +256,17 @@ func (t *TypedefType) Size() int64	{ return t.Type.Size() }
 
 func (d *Data) Type(off Offset) (Type, os.Error) {
 	if t, ok := d.typeCache[off]; ok {
-		return t, nil;
+		return t, nil
 	}
 
 	r := d.Reader();
 	r.Seek(off);
 	e, err := r.Next();
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	if e == nil || e.Offset != off {
-		return nil, DecodeError{"info", off, "no type at offset"};
+		return nil, DecodeError{"info", off, "no type at offset"}
 	}
 
 	// Parse type from Entry.
@@ -277,7 +277,7 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 	// Get next child; set err if error happens.
 	next := func() *Entry {
 		if !e.Children {
-			return nil;
+			return nil
 		}
 		kid, err1 := r.Next();
 		if err1 != nil {
@@ -289,7 +289,7 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 			return nil;
 		}
 		if kid.Tag == 0 {
-			return nil;
+			return nil
 		}
 		return kid;
 	};
@@ -300,11 +300,11 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 		toff, ok := e.Val(AttrType).(Offset);
 		if !ok {
 			// It appears that no Type means "void".
-			return new(VoidType);
+			return new(VoidType)
 		}
 		var t Type;
 		if t, err = d.Type(toff); err != nil {
-			return nil;
+			return nil
 		}
 		return t;
 	};
@@ -323,7 +323,7 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 		typ = t;
 		d.typeCache[off] = t;
 		if t.Type = typeOf(e); err != nil {
-			goto Error;
+			goto Error
 		}
 		t.StrideBitSize, _ = e.Val(AttrStrideSize).(int64);
 
@@ -336,14 +336,14 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 			case TagSubrangeType:
 				max, ok := kid.Val(AttrUpperBound).(int64);
 				if !ok {
-					max = -2;	// Count == -1, as in x[].
+					max = -2	// Count == -1, as in x[].
 				}
 				if ndim == 0 {
-					t.Count = max+1;
+					t.Count = max+1
 				} else {
 					// Multidimensional array.
 					// Create new array type underneath this one.
-					t.Type = &ArrayType{Type: t.Type, Count: max+1};
+					t.Type = &ArrayType{Type: t.Type, Count: max+1}
 				}
 				ndim++;
 			case TagEnumerationType:
@@ -376,21 +376,21 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 			goto Error;
 
 		case encAddress:
-			typ = new(AddrType);
+			typ = new(AddrType)
 		case encBoolean:
-			typ = new(BoolType);
+			typ = new(BoolType)
 		case encComplexFloat:
-			typ = new(ComplexType);
+			typ = new(ComplexType)
 		case encFloat:
-			typ = new(FloatType);
+			typ = new(FloatType)
 		case encSigned:
-			typ = new(IntType);
+			typ = new(IntType)
 		case encUnsigned:
-			typ = new(UintType);
+			typ = new(UintType)
 		case encSignedChar:
-			typ = new(CharType);
+			typ = new(CharType)
 		case encUnsignedChar:
-			typ = new(UcharType);
+			typ = new(UcharType)
 		}
 		d.typeCache[off] = typ;
 		t := typ.(interface {
@@ -420,11 +420,11 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 		d.typeCache[off] = t;
 		switch e.Tag {
 		case TagClassType:
-			t.Kind = "class";
+			t.Kind = "class"
 		case TagStructType:
-			t.Kind = "struct";
+			t.Kind = "struct"
 		case TagUnionType:
-			t.Kind = "union";
+			t.Kind = "union"
 		}
 		t.StructName, _ = e.Val(AttrName).(string);
 		t.Incomplete = e.Val(AttrDeclaration) != nil;
@@ -433,7 +433,7 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 			if kid.Tag == TagMember {
 				f := new(StructField);
 				if f.Type = typeOf(kid); err != nil {
-					goto Error;
+					goto Error
 				}
 				if loc, ok := kid.Val(AttrDataMemberLoc).([]byte); ok {
 					b := makeBuf(d, "location", 0, loc, d.addrsize);
@@ -455,7 +455,7 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 				if n >= cap(t.Field) {
 					fld := make([]*StructField, n, n*2);
 					for i, f := range t.Field {
-						fld[i] = f;
+						fld[i] = f
 					}
 					t.Field = fld;
 				}
@@ -472,15 +472,15 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 		typ = t;
 		d.typeCache[off] = t;
 		if t.Type = typeOf(e); err != nil {
-			goto Error;
+			goto Error
 		}
 		switch e.Tag {
 		case TagConstType:
-			t.Qual = "const";
+			t.Qual = "const"
 		case TagRestrictType:
-			t.Qual = "restrict";
+			t.Qual = "restrict"
 		case TagVolatileType:
-			t.Qual = "volatile";
+			t.Qual = "volatile"
 		}
 
 	case TagEnumerationType:
@@ -506,7 +506,7 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 				if n >= cap(t.Val) {
 					val := make([]*EnumValue, n, n*2);
 					for i, f := range t.Val {
-						val[i] = f;
+						val[i] = f
 					}
 					t.Val = val;
 				}
@@ -543,26 +543,26 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 		typ = t;
 		d.typeCache[off] = t;
 		if t.ReturnType = typeOf(e); err != nil {
-			goto Error;
+			goto Error
 		}
 		t.ParamType = make([]Type, 0, 8);
 		for kid := next(); kid != nil; kid = next() {
 			var tkid Type;
 			switch kid.Tag {
 			default:
-				continue;
+				continue
 			case TagFormalParameter:
 				if tkid = typeOf(kid); err != nil {
-					goto Error;
+					goto Error
 				}
 			case TagUnspecifiedParameters:
-				tkid = &DotDotDotType{};
+				tkid = &DotDotDotType{}
 			}
 			n := len(t.ParamType);
 			if n >= cap(t.ParamType) {
 				param := make([]Type, n, n*2);
 				for i, t := range t.ParamType {
-					param[i] = t;
+					param[i] = t
 				}
 				t.ParamType = param;
 			}
@@ -583,12 +583,12 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 	}
 
 	if err != nil {
-		goto Error;
+		goto Error
 	}
 
 	b, ok := e.Val(AttrByteSize).(int64);
 	if !ok {
-		b = -1;
+		b = -1
 	}
 	typ.Common().ByteSize = b;
 
diff --git a/src/pkg/debug/dwarf/type_test.go b/src/pkg/debug/dwarf/type_test.go
index dcecbe2c3e..629f0fb166 100644
--- a/src/pkg/debug/dwarf/type_test.go
+++ b/src/pkg/debug/dwarf/type_test.go
@@ -32,12 +32,12 @@ var typedefTests = map[string]string{
 func elfData(t *testing.T, name string) *Data {
 	f, err := elf.Open(name);
 	if err != nil {
-		t.Fatal(err);
+		t.Fatal(err)
 	}
 
 	d, err := f.DWARF();
 	if err != nil {
-		t.Fatal(err);
+		t.Fatal(err)
 	}
 	return d;
 }
@@ -45,12 +45,12 @@ func elfData(t *testing.T, name string) *Data {
 func machoData(t *testing.T, name string) *Data {
 	f, err := macho.Open(name);
 	if err != nil {
-		t.Fatal(err);
+		t.Fatal(err)
 	}
 
 	d, err := f.DWARF();
 	if err != nil {
-		t.Fatal(err);
+		t.Fatal(err)
 	}
 	return d;
 }
@@ -59,7 +59,7 @@ func machoData(t *testing.T, name string) *Data {
 func TestTypedefsELF(t *testing.T)	{ testTypedefs(t, elfData(t, "testdata/typedef.elf")) }
 
 func TestTypedefsMachO(t *testing.T) {
-	testTypedefs(t, machoData(t, "testdata/typedef.macho"));
+	testTypedefs(t, machoData(t, "testdata/typedef.macho"))
 }
 
 func testTypedefs(t *testing.T, d *Data) {
@@ -68,42 +68,42 @@ func testTypedefs(t *testing.T, d *Data) {
 	for {
 		e, err := r.Next();
 		if err != nil {
-			t.Fatal("r.Next:", err);
+			t.Fatal("r.Next:", err)
 		}
 		if e == nil {
-			break;
+			break
 		}
 		if e.Tag == TagTypedef {
 			typ, err := d.Type(e.Offset);
 			if err != nil {
-				t.Fatal("d.Type:", err);
+				t.Fatal("d.Type:", err)
 			}
 			t1 := typ.(*TypedefType);
 			var typstr string;
 			if ts, ok := t1.Type.(*StructType); ok {
-				typstr = ts.Defn();
+				typstr = ts.Defn()
 			} else {
-				typstr = t1.Type.String();
+				typstr = t1.Type.String()
 			}
 
 			if want, ok := typedefTests[t1.Name]; ok {
 				if _, ok := seen[t1.Name]; ok {
-					t.Errorf("multiple definitions for %s", t1.Name);
+					t.Errorf("multiple definitions for %s", t1.Name)
 				}
 				seen[t1.Name] = true;
 				if typstr != want {
-					t.Errorf("%s:\n\thave %s\n\twant %s", t1.Name, typstr, want);
+					t.Errorf("%s:\n\thave %s\n\twant %s", t1.Name, typstr, want)
 				}
 			}
 		}
 		if e.Tag != TagCompileUnit {
-			r.SkipChildren();
+			r.SkipChildren()
 		}
 	}
 
 	for k := range typedefTests {
 		if _, ok := seen[k]; !ok {
-			t.Errorf("missing %s", k);
+			t.Errorf("missing %s", k)
 		}
 	}
 }
diff --git a/src/pkg/debug/dwarf/unit.go b/src/pkg/debug/dwarf/unit.go
index d4bcf5889d..582fd0cf27 100644
--- a/src/pkg/debug/dwarf/unit.go
+++ b/src/pkg/debug/dwarf/unit.go
@@ -29,7 +29,7 @@ func (d *Data) parseUnits() ([]unit, os.Error) {
 		nunit++;
 	}
 	if b.err != nil {
-		return nil, b.err;
+		return nil, b.err
 	}
 
 	// Again, this time writing them down.
@@ -46,7 +46,7 @@ func (d *Data) parseUnits() ([]unit, os.Error) {
 		atable, err := d.parseAbbrev(b.uint32());
 		if err != nil {
 			if b.err == nil {
-				b.err = err;
+				b.err = err
 			}
 			break;
 		}
@@ -56,7 +56,7 @@ func (d *Data) parseUnits() ([]unit, os.Error) {
 		u.data = b.bytes(int(n-(2+4+1)));
 	}
 	if b.err != nil {
-		return nil, b.err;
+		return nil, b.err
 	}
 	return units, nil;
 }
diff --git a/src/pkg/debug/elf/elf.go b/src/pkg/debug/elf/elf.go
index 42a240efd7..d0f75355ec 100644
--- a/src/pkg/debug/elf/elf.go
+++ b/src/pkg/debug/elf/elf.go
@@ -1482,7 +1482,7 @@ func stringName(i uint32, names []intName, goSyntax bool) string {
 	for _, n := range names {
 		if n.i == i {
 			if goSyntax {
-				return "elf." + n.s;
+				return "elf." + n.s
 			}
 			return n.s;
 		}
@@ -1495,7 +1495,7 @@ func stringName(i uint32, names []intName, goSyntax bool) string {
 		if n.i < i {
 			s := n.s;
 			if goSyntax {
-				s = "elf."+s;
+				s = "elf."+s
 			}
 			return s + "+" + strconv.Uitoa64(uint64(i - n.i));
 		}
@@ -1509,20 +1509,20 @@ func flagName(i uint32, names []intName, goSyntax bool) string {
 	for _, n := range names {
 		if n.i & i == n.i {
 			if len(s) > 0 {
-				s += "+";
+				s += "+"
 			}
 			if goSyntax {
-				s += "elf.";
+				s += "elf."
 			}
 			s += n.s;
 			i -= n.i;
 		}
 	}
 	if len(s) == 0 {
-		return "0x" + strconv.Uitob64(uint64(i), 16);
+		return "0x" + strconv.Uitob64(uint64(i), 16)
 	}
 	if i != 0 {
-		s += "+0x" + strconv.Uitob64(uint64(i), 16);
+		s += "+0x" + strconv.Uitob64(uint64(i), 16)
 	}
 	return s;
 }
diff --git a/src/pkg/debug/elf/elf_test.go b/src/pkg/debug/elf/elf_test.go
index c48e6d9590..50827d2bc3 100644
--- a/src/pkg/debug/elf/elf_test.go
+++ b/src/pkg/debug/elf/elf_test.go
@@ -43,7 +43,7 @@ func TestNames(t *testing.T) {
 	for i, tt := range nameTests {
 		s := fmt.Sprint(tt.val);
 		if s != tt.str {
-			t.Errorf("#%d: want %q have %q", i, s, tt.str);
+			t.Errorf("#%d: want %q have %q", i, s, tt.str)
 		}
 	}
 }
diff --git a/src/pkg/debug/elf/file.go b/src/pkg/debug/elf/file.go
index c51f9bd16d..3d15f29cec 100644
--- a/src/pkg/debug/elf/file.go
+++ b/src/pkg/debug/elf/file.go
@@ -127,7 +127,7 @@ type FormatError struct {
 func (e *FormatError) String() string {
 	msg := e.msg;
 	if e.val != nil {
-		msg += fmt.Sprintf(" '%v' ", e.val);
+		msg += fmt.Sprintf(" '%v' ", e.val)
 	}
 	msg += fmt.Sprintf("in record at byte %#x", e.off);
 	return msg;
@@ -137,7 +137,7 @@ func (e *FormatError) String() string {
 func Open(name string) (*File, os.Error) {
 	f, err := os.Open(name, os.O_RDONLY, 0);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	ff, err := NewFile(f);
 	if err != nil {
@@ -167,10 +167,10 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 	// Read and decode ELF identifier
 	var ident [16]uint8;
 	if _, err := r.ReadAt(&ident, 0); err != nil {
-		return nil, err;
+		return nil, err
 	}
 	if ident[0] != '\x7f' || ident[1] != 'E' || ident[2] != 'L' || ident[3] != 'F' {
-		return nil, &FormatError{0, "bad magic number", ident[0:4]};
+		return nil, &FormatError{0, "bad magic number", ident[0:4]}
 	}
 
 	f := new(File);
@@ -180,22 +180,22 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 	case ELFCLASS64:
 		// ok
 	default:
-		return nil, &FormatError{0, "unknown ELF class", f.Class};
+		return nil, &FormatError{0, "unknown ELF class", f.Class}
 	}
 
 	f.Data = Data(ident[EI_DATA]);
 	switch f.Data {
 	case ELFDATA2LSB:
-		f.ByteOrder = binary.LittleEndian;
+		f.ByteOrder = binary.LittleEndian
 	case ELFDATA2MSB:
-		f.ByteOrder = binary.BigEndian;
+		f.ByteOrder = binary.BigEndian
 	default:
-		return nil, &FormatError{0, "unknown ELF data encoding", f.Data};
+		return nil, &FormatError{0, "unknown ELF data encoding", f.Data}
 	}
 
 	f.Version = Version(ident[EI_VERSION]);
 	if f.Version != EV_CURRENT {
-		return nil, &FormatError{0, "unknown ELF version", f.Version};
+		return nil, &FormatError{0, "unknown ELF version", f.Version}
 	}
 
 	f.OSABI = OSABI(ident[EI_OSABI]);
@@ -210,12 +210,12 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 		hdr := new(Header32);
 		sr.Seek(0, 0);
 		if err := binary.Read(sr, f.ByteOrder, hdr); err != nil {
-			return nil, err;
+			return nil, err
 		}
 		f.Type = Type(hdr.Type);
 		f.Machine = Machine(hdr.Machine);
 		if v := Version(hdr.Version); v != f.Version {
-			return nil, &FormatError{0, "mismatched ELF version", v};
+			return nil, &FormatError{0, "mismatched ELF version", v}
 		}
 		shoff = int64(hdr.Shoff);
 		shentsize = int(hdr.Shentsize);
@@ -225,12 +225,12 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 		hdr := new(Header64);
 		sr.Seek(0, 0);
 		if err := binary.Read(sr, f.ByteOrder, hdr); err != nil {
-			return nil, err;
+			return nil, err
 		}
 		f.Type = Type(hdr.Type);
 		f.Machine = Machine(hdr.Machine);
 		if v := Version(hdr.Version); v != f.Version {
-			return nil, &FormatError{0, "mismatched ELF version", v};
+			return nil, &FormatError{0, "mismatched ELF version", v}
 		}
 		shoff = int64(hdr.Shoff);
 		shentsize = int(hdr.Shentsize);
@@ -238,7 +238,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 		shstrndx = int(hdr.Shstrndx);
 	}
 	if shstrndx < 0 || shstrndx >= shnum {
-		return nil, &FormatError{0, "invalid ELF shstrndx", shstrndx};
+		return nil, &FormatError{0, "invalid ELF shstrndx", shstrndx}
 	}
 
 	// Read program headers
@@ -255,7 +255,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 		case ELFCLASS32:
 			sh := new(Section32);
 			if err := binary.Read(sr, f.ByteOrder, sh); err != nil {
-				return nil, err;
+				return nil, err
 			}
 			names[i] = sh.Name;
 			s.SectionHeader = SectionHeader{
@@ -272,7 +272,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 		case ELFCLASS64:
 			sh := new(Section64);
 			if err := binary.Read(sr, f.ByteOrder, sh); err != nil {
-				return nil, err;
+				return nil, err
 			}
 			names[i] = sh.Name;
 			s.SectionHeader = SectionHeader{
@@ -296,13 +296,13 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 	s := f.Sections[shstrndx];
 	shstrtab := make([]byte, s.Size);
 	if _, err := r.ReadAt(shstrtab, int64(s.Offset)); err != nil {
-		return nil, err;
+		return nil, err
 	}
 	for i, s := range f.Sections {
 		var ok bool;
 		s.Name, ok = getString(shstrtab, int(names[i]));
 		if !ok {
-			return nil, &FormatError{shoff+int64(i * shentsize), "bad section name index", names[i]};
+			return nil, &FormatError{shoff+int64(i * shentsize), "bad section name index", names[i]}
 		}
 	}
 
@@ -312,7 +312,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 func (f *File) getSymbols() ([]Symbol, os.Error) {
 	switch f.Class {
 	case ELFCLASS64:
-		return f.getSymbols64();
+		return f.getSymbols64()
 	}
 
 	return nil, os.ErrorString("not implemented");
@@ -329,16 +329,16 @@ func (f *File) getSymbols64() ([]Symbol, os.Error) {
 	}
 
 	if symtabSection == nil {
-		return nil, os.ErrorString("no symbol section");
+		return nil, os.ErrorString("no symbol section")
 	}
 
 	data, err := symtabSection.Data();
 	if err != nil {
-		return nil, os.ErrorString("cannot load symbol section");
+		return nil, os.ErrorString("cannot load symbol section")
 	}
 	symtab := bytes.NewBuffer(data);
 	if symtab.Len() % Sym64Size != 0 {
-		return nil, os.ErrorString("length of symbol section is not a multiple of Sym64Size");
+		return nil, os.ErrorString("length of symbol section is not a multiple of Sym64Size")
 	}
 
 	// The first entry is all zeros.
@@ -366,12 +366,12 @@ func (f *File) getSymbols64() ([]Symbol, os.Error) {
 // getString extracts a string from an ELF string table.
 func getString(section []byte, start int) (string, bool) {
 	if start < 0 || start >= len(section) {
-		return "", false;
+		return "", false
 	}
 
 	for end := start; end < len(section); end++ {
 		if section[end] == 0 {
-			return string(section[start:end]), true;
+			return string(section[start:end]), true
 		}
 	}
 	return "", false;
@@ -382,7 +382,7 @@ func getString(section []byte, start int) (string, bool) {
 func (f *File) Section(name string) *Section {
 	for _, s := range f.Sections {
 		if s.Name == name {
-			return s;
+			return s
 		}
 	}
 	return nil;
@@ -392,7 +392,7 @@ func (f *File) Section(name string) *Section {
 // in RELA format.
 func (f *File) applyRelocations(dst []byte, rels []byte) os.Error {
 	if f.Class == ELFCLASS64 && f.Machine == EM_X86_64 {
-		return f.applyRelocationsAMD64(dst, rels);
+		return f.applyRelocationsAMD64(dst, rels)
 	}
 
 	return os.ErrorString("not implemented");
@@ -400,12 +400,12 @@ func (f *File) applyRelocations(dst []byte, rels []byte) os.Error {
 
 func (f *File) applyRelocationsAMD64(dst []byte, rels []byte) os.Error {
 	if len(rels) % Sym64Size != 0 {
-		return os.ErrorString("length of relocation section is not a multiple of Sym64Size");
+		return os.ErrorString("length of relocation section is not a multiple of Sym64Size")
 	}
 
 	symbols, err := f.getSymbols();
 	if err != nil {
-		return err;
+		return err
 	}
 
 	b := bytes.NewBuffer(rels);
@@ -417,23 +417,23 @@ func (f *File) applyRelocationsAMD64(dst []byte, rels []byte) os.Error {
 		t := R_X86_64(rela.Info & 0xffff);
 
 		if symNo >= uint64(len(symbols)) {
-			continue;
+			continue
 		}
 		sym := &symbols[symNo];
 		if SymType(sym.Info & 0xf) != STT_SECTION {
 			// We don't handle non-section relocations for now.
-			continue;
+			continue
 		}
 
 		switch t {
 		case R_X86_64_64:
 			if rela.Off + 8 >= uint64(len(dst)) || rela.Addend < 0 {
-				continue;
+				continue
 			}
 			f.ByteOrder.PutUint64(dst[rela.Off : rela.Off + 8], uint64(rela.Addend));
 		case R_X86_64_32:
 			if rela.Off + 4 >= uint64(len(dst)) || rela.Addend < 0 {
-				continue;
+				continue
 			}
 			f.ByteOrder.PutUint32(dst[rela.Off : rela.Off + 4], uint32(rela.Addend));
 		}
@@ -452,11 +452,11 @@ func (f *File) DWARF() (*dwarf.Data, os.Error) {
 		name = ".debug_" + name;
 		s := f.Section(name);
 		if s == nil {
-			continue;
+			continue
 		}
 		b, err := s.Data();
 		if err != nil && uint64(len(b)) < s.Size {
-			return nil, err;
+			return nil, err
 		}
 		dat[i] = b;
 	}
@@ -467,11 +467,11 @@ func (f *File) DWARF() (*dwarf.Data, os.Error) {
 	if rela != nil && rela.Type == SHT_RELA && f.Machine == EM_X86_64 {
 		data, err := rela.Data();
 		if err != nil {
-			return nil, err;
+			return nil, err
 		}
 		err = f.applyRelocations(dat[1], data);
 		if err != nil {
-			return nil, err;
+			return nil, err
 		}
 	}
 
diff --git a/src/pkg/debug/elf/file_test.go b/src/pkg/debug/elf/file_test.go
index 04c924d124..9cd15fbd3d 100644
--- a/src/pkg/debug/elf/file_test.go
+++ b/src/pkg/debug/elf/file_test.go
@@ -114,17 +114,17 @@ func TestOpen(t *testing.T) {
 		}
 		for i, s := range f.Sections {
 			if i >= len(tt.sections) {
-				break;
+				break
 			}
 			sh := &tt.sections[i];
 			if !reflect.DeepEqual(&s.SectionHeader, sh) {
-				t.Errorf("open %s, section %d:\n\thave %#v\n\twant %#v\n", tt.file, i, &s.SectionHeader, sh);
+				t.Errorf("open %s, section %d:\n\thave %#v\n\twant %#v\n", tt.file, i, &s.SectionHeader, sh)
 			}
 		}
 		tn := len(tt.sections);
 		fn := len(f.Sections);
 		if tn != fn {
-			t.Errorf("open %s: len(Sections) = %d, want %d", tt.file, fn, tn);
+			t.Errorf("open %s: len(Sections) = %d, want %d", tt.file, fn, tn)
 		}
 	}
 }
diff --git a/src/pkg/debug/gosym/pclntab.go b/src/pkg/debug/gosym/pclntab.go
index 8008ada83c..cfda629786 100644
--- a/src/pkg/debug/gosym/pclntab.go
+++ b/src/pkg/debug/gosym/pclntab.go
@@ -42,9 +42,9 @@ func (t *LineTable) parse(targetPC uint64, targetLine int) (b []byte, pc uint64,
 			b = b[4:len(b)];
 			line += int(val);
 		case code <= 64:
-			line += int(code);
+			line += int(code)
 		case code <= 128:
-			line -= int(code-64);
+			line -= int(code-64)
 		default:
 			pc += quantum*uint64(code-128);
 			continue;
@@ -67,7 +67,7 @@ func (t *LineTable) PCToLine(pc uint64) int {
 func (t *LineTable) LineToPC(line int, maxpc uint64) uint64 {
 	_, pc, line1 := t.parse(maxpc, line);
 	if line1 != line {
-		return 0;
+		return 0
 	}
 	// Subtract quantum from PC to account for post-line increment
 	return pc-quantum;
@@ -78,5 +78,5 @@ func (t *LineTable) LineToPC(line int, maxpc uint64) uint64 {
 // Text must be the start address of the
 // corresponding text segment.
 func NewLineTable(data []byte, text uint64) *LineTable {
-	return &LineTable{data, text, 0};
+	return &LineTable{data, text, 0}
 }
diff --git a/src/pkg/debug/gosym/pclntab_test.go b/src/pkg/debug/gosym/pclntab_test.go
index 6b70ba1638..79a87f4a2e 100644
--- a/src/pkg/debug/gosym/pclntab_test.go
+++ b/src/pkg/debug/gosym/pclntab_test.go
@@ -13,7 +13,7 @@ import (
 
 func dotest() bool {
 	// For now, only works on ELF platforms.
-	return syscall.OS == "linux" && os.Getenv("GOARCH") == "amd64";
+	return syscall.OS == "linux" && os.Getenv("GOARCH") == "amd64"
 }
 
 func getTable(t *testing.T) *Table {
@@ -26,7 +26,7 @@ func crack(file string, t *testing.T) (*elf.File, *Table) {
 	// Open self
 	f, err := elf.Open(file);
 	if err != nil {
-		t.Fatal(err);
+		t.Fatal(err)
 	}
 	return parse(file, f, t);
 }
@@ -57,7 +57,7 @@ var goarch = os.Getenv("O")
 
 func TestLineFromAline(t *testing.T) {
 	if !dotest() {
-		return;
+		return
 	}
 
 	tab := getTable(t);
@@ -65,7 +65,7 @@ func TestLineFromAline(t *testing.T) {
 	// Find the sym package
 	pkg := tab.LookupFunc("gosym.TestLineFromAline").Obj;
 	if pkg == nil {
-		t.Fatalf("nil pkg");
+		t.Fatalf("nil pkg")
 	}
 
 	// Walk every absolute line and ensure that we hit every
@@ -77,11 +77,11 @@ func TestLineFromAline(t *testing.T) {
 		// Check for end of object
 		if path == "" {
 			if final == -1 {
-				final = i-1;
+				final = i-1
 			}
 			continue;
 		} else if final != -1 {
-			t.Fatalf("reached end of package at absolute line %d, but absolute line %d mapped to %s:%d", final, i, path, line);
+			t.Fatalf("reached end of package at absolute line %d, but absolute line %d mapped to %s:%d", final, i, path, line)
 		}
 		// It's okay to see files multiple times (e.g., sys.a)
 		if line == 1 {
@@ -91,20 +91,20 @@ func TestLineFromAline(t *testing.T) {
 		// Check that the is the next line in path
 		ll, ok := lastline[path];
 		if !ok {
-			t.Errorf("file %s starts on line %d", path, line);
+			t.Errorf("file %s starts on line %d", path, line)
 		} else if line != ll+1 {
-			t.Errorf("expected next line of file %s to be %d, got %d", path, ll+1, line);
+			t.Errorf("expected next line of file %s to be %d, got %d", path, ll+1, line)
 		}
 		lastline[path] = line;
 	}
 	if final == -1 {
-		t.Errorf("never reached end of object");
+		t.Errorf("never reached end of object")
 	}
 }
 
 func TestLineAline(t *testing.T) {
 	if !dotest() {
-		return;
+		return
 	}
 
 	tab := getTable(t);
@@ -117,27 +117,27 @@ func TestLineAline(t *testing.T) {
 		for i := 0; i < 1000; i++ {
 			path, line := o.lineFromAline(i);
 			if path == "" {
-				break;
+				break
 			}
 
 			// cgo files are full of 'Z' symbols, which we don't handle
 			if len(path) > 4 && path[len(path)-4 : len(path)] == ".cgo" {
-				continue;
+				continue
 			}
 
 			if minline, ok := found[path]; path != "" && ok {
 				if minline >= line {
 					// We've already covered this file
-					continue;
+					continue
 				}
 			}
 			found[path] = line;
 
 			a, err := o.alineFromLine(path, line);
 			if err != nil {
-				t.Errorf("absolute line %d in object %s maps to %s:%d, but mapping that back gives error %s", i, o.Paths[0].Name, path, line, err);
+				t.Errorf("absolute line %d in object %s maps to %s:%d, but mapping that back gives error %s", i, o.Paths[0].Name, path, line, err)
 			} else if a != i {
-				t.Errorf("absolute line %d in object %s maps to %s:%d, which maps back to absolute line %d\n", i, o.Paths[0].Name, path, line, a);
+				t.Errorf("absolute line %d in object %s maps to %s:%d, which maps back to absolute line %d\n", i, o.Paths[0].Name, path, line, a)
 			}
 		}
 	}
@@ -148,14 +148,14 @@ func TestLineAline(t *testing.T) {
 // gotest: fi
 func TestPCLine(t *testing.T) {
 	if !dotest() {
-		return;
+		return
 	}
 
 	f, tab := crack("_test/pclinetest", t);
 	text := f.Section(".text");
 	textdat, err := text.Data();
 	if err != nil {
-		t.Fatalf("reading .text: %v", err);
+		t.Fatalf("reading .text: %v", err)
 	}
 
 	// Test PCToLine
@@ -166,9 +166,9 @@ func TestPCLine(t *testing.T) {
 		off := pc - text.Addr;	// TODO(rsc): should not need off; bug in 8g
 		wantLine += int(textdat[off]);
 		if fn == nil {
-			t.Errorf("failed to get line of PC %#x", pc);
+			t.Errorf("failed to get line of PC %#x", pc)
 		} else if len(file) < 12 || file[len(file)-12 : len(file)] != "pclinetest.s" || line != wantLine || fn != sym {
-			t.Errorf("expected %s:%d (%s) at PC %#x, got %s:%d (%s)", "pclinetest.s", wantLine, sym.Name, pc, file, line, fn.Name);
+			t.Errorf("expected %s:%d (%s) at PC %#x, got %s:%d (%s)", "pclinetest.s", wantLine, sym.Name, pc, file, line, fn.Name)
 		}
 	}
 
@@ -187,19 +187,19 @@ func TestPCLine(t *testing.T) {
 			continue;
 		}
 		if lookupline == -1 {
-			lookupline = line;
+			lookupline = line
 		}
 		for ; lookupline <= line; lookupline++ {
 			pc2, fn2, err := tab.LineToPC(file, lookupline);
 			if lookupline != line {
 				// Should be nothing on this line
 				if err == nil {
-					t.Errorf("expected no PC at line %d, got %#x (%s)", lookupline, pc2, fn2.Name);
+					t.Errorf("expected no PC at line %d, got %#x (%s)", lookupline, pc2, fn2.Name)
 				}
 			} else if err != nil {
-				t.Errorf("failed to get PC of line %d: %s", lookupline, err);
+				t.Errorf("failed to get PC of line %d: %s", lookupline, err)
 			} else if pc != pc2 {
-				t.Errorf("expected PC %#x (%s) at line %d, got PC %#x (%s)", pc, fn.Name, line, pc2, fn2.Name);
+				t.Errorf("expected PC %#x (%s) at line %d, got PC %#x (%s)", pc, fn.Name, line, pc2, fn2.Name)
 			}
 		}
 		off = pc + 1 - text.Addr;
diff --git a/src/pkg/debug/gosym/symtab.go b/src/pkg/debug/gosym/symtab.go
index cb9b1f4eb1..ba20c7f385 100644
--- a/src/pkg/debug/gosym/symtab.go
+++ b/src/pkg/debug/gosym/symtab.go
@@ -41,7 +41,7 @@ func (s *Sym) Static() bool	{ return s.Type >= 'a' }
 // or the empty string if there is none.
 func (s *Sym) PackageName() string {
 	if i := strings.Index(s.Name, "."); i != -1 {
-		return s.Name[0:i];
+		return s.Name[0:i]
 	}
 	return "";
 }
@@ -52,7 +52,7 @@ func (s *Sym) ReceiverName() string {
 	l := strings.Index(s.Name, ".");
 	r := strings.LastIndex(s.Name, ".");
 	if l == -1 || r == -1 || l == r {
-		return "";
+		return ""
 	}
 	return s.Name[l+1 : r];
 }
@@ -60,7 +60,7 @@ func (s *Sym) ReceiverName() string {
 // BaseName returns the symbol name without the package or receiver name.
 func (s *Sym) BaseName() string {
 	if i := strings.LastIndex(s.Name, "."); i != -1 {
-		return s.Name[i+1 : len(s.Name)];
+		return s.Name[i+1 : len(s.Name)]
 	}
 	return s.Name;
 }
@@ -112,7 +112,7 @@ func walksymtab(data []byte, fn func(sym) os.Error) os.Error {
 		s.value = binary.BigEndian.Uint32(p[0:4]);
 		typ := p[4];
 		if typ&0x80 == 0 {
-			return &DecodingError{len(data)-len(p)+4, "bad symbol type", typ};
+			return &DecodingError{len(data)-len(p)+4, "bad symbol type", typ}
 		}
 		typ &^= 0x80;
 		s.typ = typ;
@@ -136,7 +136,7 @@ func walksymtab(data []byte, fn func(sym) os.Error) os.Error {
 			}
 		}
 		if i+nnul+4 > len(p) {
-			return &DecodingError{len(data), "unexpected EOF", nil};
+			return &DecodingError{len(data), "unexpected EOF", nil}
 		}
 		s.name = p[0:i];
 		i += nnul;
@@ -156,7 +156,7 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
 		return nil;
 	});
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	var t Table;
@@ -188,31 +188,31 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
 			ts.Name = string(s.name[0:w]);
 		case 'z', 'Z':
 			if lasttyp != 'z' && lasttyp != 'Z' {
-				nz++;
+				nz++
 			}
 			for i := 0; i < len(s.name); i += 2 {
 				eltIdx := binary.BigEndian.Uint16(s.name[i : i+2]);
 				elt, ok := fname[eltIdx];
 				if !ok {
-					return &DecodingError{-1, "bad filename code", eltIdx};
+					return &DecodingError{-1, "bad filename code", eltIdx}
 				}
 				if n := len(ts.Name); n > 0 && ts.Name[n-1] != '/' {
-					ts.Name += "/";
+					ts.Name += "/"
 				}
 				ts.Name += elt;
 			}
 		}
 		switch s.typ {
 		case 'T', 't', 'L', 'l':
-			nf++;
+			nf++
 		case 'f':
-			fname[uint16(s.value)] = ts.Name;
+			fname[uint16(s.value)] = ts.Name
 		}
 		lasttyp = s.typ;
 		return nil;
 	});
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	t.Funcs = make([]Func, 0, nf);
@@ -229,7 +229,7 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
 		case 'Z', 'z':	// path symbol
 			// Finish the current object
 			if obj != nil {
-				obj.Funcs = t.Funcs[lastf:len(t.Funcs)];
+				obj.Funcs = t.Funcs[lastf:len(t.Funcs)]
 			}
 			lastf = len(t.Funcs);
 
@@ -242,7 +242,7 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
 			var end int;
 			for end = i+1; end < len(t.Syms); end++ {
 				if c := t.Syms[end].Type; c != 'Z' && c != 'z' {
-					break;
+					break
 				}
 			}
 			obj.Paths = t.Syms[i:end];
@@ -253,10 +253,10 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
 			for j := range obj.Paths {
 				s := &obj.Paths[j];
 				if s.Name == "" {
-					depth--;
+					depth--
 				} else {
 					if depth == 0 {
-						t.Files[s.Name] = obj;
+						t.Files[s.Name] = obj
 					}
 					depth++;
 				}
@@ -264,10 +264,10 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
 
 		case 'T', 't', 'L', 'l':	// text symbol
 			if n := len(t.Funcs); n > 0 {
-				t.Funcs[n-1].End = sym.Value;
+				t.Funcs[n-1].End = sym.Value
 			}
 			if sym.Name == "etext" {
-				continue;
+				continue
 			}
 
 			// Count parameter and local (auto) syms
@@ -277,11 +277,11 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
 			for end = i+1; end < len(t.Syms); end++ {
 				switch t.Syms[end].Type {
 				case 'T', 't', 'L', 'l', 'Z', 'z':
-					break countloop;
+					break countloop
 				case 'p':
-					np++;
+					np++
 				case 'a':
-					na++;
+					na++
 				}
 			}
 
@@ -303,7 +303,7 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
 				s := &t.Syms[j];
 				switch s.Type {
 				case 'm':
-					fn.FrameSize = int(s.Value);
+					fn.FrameSize = int(s.Value)
 				case 'p':
 					n := len(fn.Params);
 					fn.Params = fn.Params[0 : n+1];
@@ -318,7 +318,7 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
 		}
 	}
 	if obj != nil {
-		obj.Funcs = t.Funcs[lastf:len(t.Funcs)];
+		obj.Funcs = t.Funcs[lastf:len(t.Funcs)]
 	}
 	return &t, nil;
 }
@@ -332,11 +332,11 @@ func (t *Table) PCToFunc(pc uint64) *Func {
 		fn := &funcs[m];
 		switch {
 		case pc < fn.Entry:
-			funcs = funcs[0:m];
+			funcs = funcs[0:m]
 		case fn.Entry <= pc && pc < fn.End:
-			return fn;
+			return fn
 		default:
-			funcs = funcs[m+1 : len(funcs)];
+			funcs = funcs[m+1 : len(funcs)]
 		}
 	}
 	return nil;
@@ -346,7 +346,7 @@ func (t *Table) PCToFunc(pc uint64) *Func {
 // If there is no information, it returns fn == nil.
 func (t *Table) PCToLine(pc uint64) (file string, line int, fn *Func) {
 	if fn = t.PCToFunc(pc); fn == nil {
-		return;
+		return
 	}
 	file, line = fn.Obj.lineFromAline(fn.LineTable.PCToLine(pc));
 	return;
@@ -358,17 +358,17 @@ func (t *Table) PCToLine(pc uint64) (file string, line int, fn *Func) {
 func (t *Table) LineToPC(file string, line int) (pc uint64, fn *Func, err os.Error) {
 	obj, ok := t.Files[file];
 	if !ok {
-		return 0, nil, UnknownFileError(file);
+		return 0, nil, UnknownFileError(file)
 	}
 	abs, err := obj.alineFromLine(file, line);
 	if err != nil {
-		return;
+		return
 	}
 	for i := range obj.Funcs {
 		f := &obj.Funcs[i];
 		pc := f.LineTable.LineToPC(abs, f.End);
 		if pc != 0 {
-			return pc, f, nil;
+			return pc, f, nil
 		}
 	}
 	return 0, nil, &UnknownLineError{file, line};
@@ -383,7 +383,7 @@ func (t *Table) LookupSym(name string) *Sym {
 		switch s.Type {
 		case 'T', 't', 'L', 'l', 'D', 'd', 'B', 'b':
 			if s.Name == name {
-				return s;
+				return s
 			}
 		}
 	}
@@ -396,7 +396,7 @@ func (t *Table) LookupFunc(name string) *Func {
 	for i := range t.Funcs {
 		f := &t.Funcs[i];
 		if f.Sym.Name == name {
-			return f;
+			return f
 		}
 	}
 	return nil;
@@ -411,7 +411,7 @@ func (t *Table) SymByAddr(addr uint64) *Sym {
 		switch s.Type {
 		case 'T', 't', 'L', 'l', 'D', 'd', 'B', 'b':
 			if s.Value == addr {
-				return s;
+				return s
 			}
 		}
 	}
@@ -440,41 +440,41 @@ pathloop:
 		val := int(s.Value);
 		switch {
 		case val > aline:
-			break pathloop;
+			break pathloop
 
 		case val == 1:
 			// Start a new stack
-			tos = &stackEnt{s.Name, val, 0, noPath};
+			tos = &stackEnt{s.Name, val, 0, noPath}
 
 		case s.Name == "":
 			// Pop
 			if tos == noPath {
-				return "<malformed symbol table>", 0;
+				return "<malformed symbol table>", 0
 			}
 			tos.prev.offset += val - tos.start;
 			tos = tos.prev;
 
 		default:
 			// Push
-			tos = &stackEnt{s.Name, val, 0, tos};
+			tos = &stackEnt{s.Name, val, 0, tos}
 		}
 	}
 
 	if tos == noPath {
-		return "", 0;
+		return "", 0
 	}
 	return tos.path, aline - tos.start - tos.offset + 1;
 }
 
 func (o *Obj) alineFromLine(path string, line int) (int, os.Error) {
 	if line < 1 {
-		return 0, &UnknownLineError{path, line};
+		return 0, &UnknownLineError{path, line}
 	}
 
 	for i, s := range o.Paths {
 		// Find this path
 		if s.Name != path {
-			continue;
+			continue
 		}
 
 		// Find this line at this stack level
@@ -486,19 +486,19 @@ func (o *Obj) alineFromLine(path string, line int) (int, os.Error) {
 			val := int(s.Value);
 			switch {
 			case depth == 1 && val >= line:
-				return line-1, nil;
+				return line-1, nil
 
 			case s.Name == "":
 				depth--;
 				if depth == 0 {
-					break pathloop;
+					break pathloop
 				} else if depth == 1 {
-					line += val-incstart;
+					line += val-incstart
 				}
 
 			default:
 				if depth == 1 {
-					incstart = val;
+					incstart = val
 				}
 				depth++;
 			}
@@ -527,7 +527,7 @@ type UnknownLineError struct {
 }
 
 func (e *UnknownLineError) String() string {
-	return "no code at " + e.File + ":" + strconv.Itoa(e.Line);
+	return "no code at " + e.File + ":" + strconv.Itoa(e.Line)
 }
 
 // DecodingError represents an error during the decoding of
@@ -541,7 +541,7 @@ type DecodingError struct {
 func (e *DecodingError) String() string {
 	msg := e.msg;
 	if e.val != nil {
-		msg += fmt.Sprintf(" '%v'", e.val);
+		msg += fmt.Sprintf(" '%v'", e.val)
 	}
 	msg += fmt.Sprintf(" at byte %#x", e.off);
 	return msg;
diff --git a/src/pkg/debug/macho/file.go b/src/pkg/debug/macho/file.go
index 52ba94fd74..48687849a2 100644
--- a/src/pkg/debug/macho/file.go
+++ b/src/pkg/debug/macho/file.go
@@ -126,7 +126,7 @@ type FormatError struct {
 func (e *FormatError) String() string {
 	msg := e.msg;
 	if e.val != nil {
-		msg += fmt.Sprintf(" '%v' ", e.val);
+		msg += fmt.Sprintf(" '%v' ", e.val)
 	}
 	msg += fmt.Sprintf("in record at byte %#x", e.off);
 	return msg;
@@ -136,7 +136,7 @@ func (e *FormatError) String() string {
 func Open(name string) (*File, os.Error) {
 	f, err := os.Open(name, os.O_RDONLY, 0);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	ff, err := NewFile(f);
 	if err != nil {
@@ -169,7 +169,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 	// Magic32 and Magic64 differ only in the bottom bit.
 	var ident [4]uint8;
 	if _, err := r.ReadAt(&ident, 0); err != nil {
-		return nil, err;
+		return nil, err
 	}
 	be := binary.BigEndian.Uint32(&ident);
 	le := binary.LittleEndian.Uint32(&ident);
@@ -184,28 +184,28 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 
 	// Read entire file header.
 	if err := binary.Read(sr, f.ByteOrder, &f.FileHeader); err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	// Then load commands.
 	offset := int64(fileHeaderSize32);
 	if f.Magic == Magic64 {
-		offset = fileHeaderSize64;
+		offset = fileHeaderSize64
 	}
 	dat := make([]byte, f.Cmdsz);
 	if _, err := r.ReadAt(dat, offset); err != nil {
-		return nil, err;
+		return nil, err
 	}
 	f.Loads = make([]Load, f.Ncmd);
 	bo := f.ByteOrder;
 	for i := range f.Loads {
 		// Each load command begins with uint32 command and length.
 		if len(dat) < 8 {
-			return nil, &FormatError{offset, "command block too small", nil};
+			return nil, &FormatError{offset, "command block too small", nil}
 		}
 		cmd, siz := LoadCmd(bo.Uint32(dat[0:4])), bo.Uint32(dat[4:8]);
 		if siz < 8 || siz > uint32(len(dat)) {
-			return nil, &FormatError{offset, "invalid command block size", nil};
+			return nil, &FormatError{offset, "invalid command block size", nil}
 		}
 		var cmddat []byte;
 		cmddat, dat = dat[0:siz], dat[siz:len(dat)];
@@ -213,13 +213,13 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 		var s *Segment;
 		switch cmd {
 		default:
-			f.Loads[i] = LoadBytes(cmddat);
+			f.Loads[i] = LoadBytes(cmddat)
 
 		case LoadCmdSegment:
 			var seg32 Segment32;
 			b := bytes.NewBuffer(cmddat);
 			if err := binary.Read(b, bo, &seg32); err != nil {
-				return nil, err;
+				return nil, err
 			}
 			s = new(Segment);
 			s.LoadBytes = cmddat;
@@ -238,7 +238,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 			for i := 0; i < int(s.Nsect); i++ {
 				var sh32 Section32;
 				if err := binary.Read(b, bo, &sh32); err != nil {
-					return nil, err;
+					return nil, err
 				}
 				sh := new(Section);
 				sh.Name = cstring(&sh32.Name);
@@ -257,7 +257,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 			var seg64 Segment64;
 			b := bytes.NewBuffer(cmddat);
 			if err := binary.Read(b, bo, &seg64); err != nil {
-				return nil, err;
+				return nil, err
 			}
 			s = new(Segment);
 			s.LoadBytes = cmddat;
@@ -276,7 +276,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 			for i := 0; i < int(s.Nsect); i++ {
 				var sh64 Section64;
 				if err := binary.Read(b, bo, &sh64); err != nil {
-					return nil, err;
+					return nil, err
 				}
 				sh := new(Section);
 				sh.Name = cstring(&sh64.Name);
@@ -305,7 +305,7 @@ func (f *File) pushSection(sh *Section, r io.ReaderAt) {
 		m := (n+1)*2;
 		new := make([]*Section, n, m);
 		for i, sh := range f.Sections {
-			new[i] = sh;
+			new[i] = sh
 		}
 		f.Sections = new;
 	}
@@ -326,7 +326,7 @@ func cstring(b []byte) string {
 func (f *File) Segment(name string) *Segment {
 	for _, l := range f.Loads {
 		if s, ok := l.(*Segment); ok && s.Name == name {
-			return s;
+			return s
 		}
 	}
 	return nil;
@@ -337,7 +337,7 @@ func (f *File) Segment(name string) *Segment {
 func (f *File) Section(name string) *Section {
 	for _, s := range f.Sections {
 		if s.Name == name {
-			return s;
+			return s
 		}
 	}
 	return nil;
@@ -354,11 +354,11 @@ func (f *File) DWARF() (*dwarf.Data, os.Error) {
 		name = "__debug_" + name;
 		s := f.Section(name);
 		if s == nil {
-			return nil, os.NewError("missing Mach-O section " + name);
+			return nil, os.NewError("missing Mach-O section " + name)
 		}
 		b, err := s.Data();
 		if err != nil && uint64(len(b)) < s.Size {
-			return nil, err;
+			return nil, err
 		}
 		dat[i] = b;
 	}
diff --git a/src/pkg/debug/macho/file_test.go b/src/pkg/debug/macho/file_test.go
index fe0b3ff12c..e1d75da15f 100644
--- a/src/pkg/debug/macho/file_test.go
+++ b/src/pkg/debug/macho/file_test.go
@@ -113,13 +113,13 @@ func TestOpen(t *testing.T) {
 		}
 		for i, l := range f.Loads {
 			if i >= len(tt.segments) {
-				break;
+				break
 			}
 			sh := tt.segments[i];
 			s, ok := l.(*Segment);
 			if sh == nil {
 				if ok {
-					t.Errorf("open %s, section %d: skipping %#v\n", tt.file, i, &s.SegmentHeader);
+					t.Errorf("open %s, section %d: skipping %#v\n", tt.file, i, &s.SegmentHeader)
 				}
 				continue;
 			}
@@ -130,29 +130,29 @@ func TestOpen(t *testing.T) {
 			have := &s.SegmentHeader;
 			want := sh;
 			if !reflect.DeepEqual(have, want) {
-				t.Errorf("open %s, segment %d:\n\thave %#v\n\twant %#v\n", tt.file, i, have, want);
+				t.Errorf("open %s, segment %d:\n\thave %#v\n\twant %#v\n", tt.file, i, have, want)
 			}
 		}
 		tn := len(tt.segments);
 		fn := len(f.Loads);
 		if tn != fn {
-			t.Errorf("open %s: len(Loads) = %d, want %d", tt.file, fn, tn);
+			t.Errorf("open %s: len(Loads) = %d, want %d", tt.file, fn, tn)
 		}
 
 		for i, sh := range f.Sections {
 			if i >= len(tt.sections) {
-				break;
+				break
 			}
 			have := &sh.SectionHeader;
 			want := tt.sections[i];
 			if !reflect.DeepEqual(have, want) {
-				t.Errorf("open %s, section %d:\n\thave %#v\n\twant %#v\n", tt.file, i, have, want);
+				t.Errorf("open %s, section %d:\n\thave %#v\n\twant %#v\n", tt.file, i, have, want)
 			}
 		}
 		tn = len(tt.sections);
 		fn = len(f.Sections);
 		if tn != fn {
-			t.Errorf("open %s: len(Sections) = %d, want %d", tt.file, fn, tn);
+			t.Errorf("open %s: len(Sections) = %d, want %d", tt.file, fn, tn)
 		}
 
 	}
diff --git a/src/pkg/debug/macho/macho.go b/src/pkg/debug/macho/macho.go
index d8fbba376b..fc4924b2f4 100644
--- a/src/pkg/debug/macho/macho.go
+++ b/src/pkg/debug/macho/macho.go
@@ -197,7 +197,7 @@ func stringName(i uint32, names []intName, goSyntax bool) string {
 	for _, n := range names {
 		if n.i == i {
 			if goSyntax {
-				return "macho." + n.s;
+				return "macho." + n.s
 			}
 			return n.s;
 		}
@@ -210,20 +210,20 @@ func flagName(i uint32, names []intName, goSyntax bool) string {
 	for _, n := range names {
 		if n.i & i == n.i {
 			if len(s) > 0 {
-				s += "+";
+				s += "+"
 			}
 			if goSyntax {
-				s += "macho.";
+				s += "macho."
 			}
 			s += n.s;
 			i -= n.i;
 		}
 	}
 	if len(s) == 0 {
-		return "0x" + strconv.Uitob64(uint64(i), 16);
+		return "0x" + strconv.Uitob64(uint64(i), 16)
 	}
 	if i != 0 {
-		s += "+0x" + strconv.Uitob64(uint64(i), 16);
+		s += "+0x" + strconv.Uitob64(uint64(i), 16)
 	}
 	return s;
 }
diff --git a/src/pkg/debug/proc/proc.go b/src/pkg/debug/proc/proc.go
index 0719ebef3e..7f8e778c6f 100644
--- a/src/pkg/debug/proc/proc.go
+++ b/src/pkg/debug/proc/proc.go
@@ -161,7 +161,7 @@ type Breakpoint Word
 func (c Breakpoint) PC() Word	{ return Word(c) }
 
 func (c Breakpoint) String() string {
-	return "breakpoint at 0x" + strconv.Uitob64(uint64(c.PC()), 16);
+	return "breakpoint at 0x" + strconv.Uitob64(uint64(c.PC()), 16)
 }
 
 // Signal is a stop cause resulting from a thread receiving a signal.
@@ -212,11 +212,11 @@ func (c *ThreadExit) String() string {
 	res := "thread exited ";
 	switch {
 	case c.Exited():
-		res += "with status " + strconv.Itoa(c.ExitStatus());
+		res += "with status " + strconv.Itoa(c.ExitStatus())
 	case c.Signaled():
-		res += "from signal " + c.StopSignal();
+		res += "from signal " + c.StopSignal()
 	default:
-		res += "from unknown cause";
+		res += "from unknown cause"
 	}
 	return res;
 }
diff --git a/src/pkg/debug/proc/proc_darwin.go b/src/pkg/debug/proc/proc_darwin.go
index 2c7b4231f5..7caf3a21a4 100644
--- a/src/pkg/debug/proc/proc_darwin.go
+++ b/src/pkg/debug/proc/proc_darwin.go
@@ -9,9 +9,9 @@ import "os"
 // Process tracing is not supported on OS X yet.
 
 func Attach(pid int) (Process, os.Error) {
-	return nil, os.NewError("debug/proc not implemented on OS X");
+	return nil, os.NewError("debug/proc not implemented on OS X")
 }
 
 func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []*os.File) (Process, os.Error) {
-	return Attach(0);
+	return Attach(0)
 }
diff --git a/src/pkg/debug/proc/proc_linux.go b/src/pkg/debug/proc/proc_linux.go
index ac469ecad0..be42022d6b 100644
--- a/src/pkg/debug/proc/proc_linux.go
+++ b/src/pkg/debug/proc/proc_linux.go
@@ -77,11 +77,11 @@ const (
 )
 
 func (ts threadState) isRunning() bool {
-	return ts == running || ts == singleStepping || ts == stopping;
+	return ts == running || ts == singleStepping || ts == stopping
 }
 
 func (ts threadState) isStopped() bool {
-	return ts == stopped || ts == stoppedBreakpoint || ts == stoppedSignal || ts == stoppedThreadCreate || ts == stoppedExiting;
+	return ts == stopped || ts == stoppedBreakpoint || ts == stoppedSignal || ts == stoppedThreadCreate || ts == stoppedExiting
 }
 
 func (ts threadState) isZombie() bool	{ return ts == exiting }
@@ -104,7 +104,7 @@ type breakpoint struct {
 
 func (bp *breakpoint) String() string {
 	if bp == nil {
-		return "<nil>";
+		return "<nil>"
 	}
 	return fmt.Sprintf("%#x", bp.pc);
 }
@@ -189,13 +189,13 @@ type badState struct {
 }
 
 func (e *badState) String() string {
-	return fmt.Sprintf("Thread %d %s from state %v", e.thread.tid, e.message, e.state);
+	return fmt.Sprintf("Thread %d %s from state %v", e.thread.tid, e.message, e.state)
 }
 
 type breakpointExistsError Word
 
 func (e breakpointExistsError) String() string {
-	return fmt.Sprintf("breakpoint already exists at PC %#x", e);
+	return fmt.Sprintf("breakpoint already exists at PC %#x", e)
 }
 
 type noBreakpointError Word
@@ -209,7 +209,7 @@ type newThreadError struct {
 }
 
 func (e *newThreadError) String() string {
-	return fmt.Sprintf("newThread wait wanted pid %v and signal %v, got %v and %v", e.Pid, e.StopSignal(), e.wantPid, e.wantSig);
+	return fmt.Sprintf("newThread wait wanted pid %v and signal %v, got %v and %v", e.Pid, e.StopSignal(), e.wantPid, e.wantSig)
 }
 
 type ProcessExited struct{}
@@ -223,7 +223,7 @@ func (p ProcessExited) String() string	{ return "process exited" }
 func (t *thread) ptracePeekText(addr uintptr, out []byte) (int, os.Error) {
 	c, err := syscall.PtracePeekText(t.tid, addr, out);
 	if traceMem {
-		fmt.Printf("peek(%#x) => %v, %v\n", addr, out, err);
+		fmt.Printf("peek(%#x) => %v, %v\n", addr, out, err)
 	}
 	return c, os.NewSyscallError("ptrace(PEEKTEXT)", err);
 }
@@ -231,7 +231,7 @@ func (t *thread) ptracePeekText(addr uintptr, out []byte) (int, os.Error) {
 func (t *thread) ptracePokeText(addr uintptr, out []byte) (int, os.Error) {
 	c, err := syscall.PtracePokeText(t.tid, addr, out);
 	if traceMem {
-		fmt.Printf("poke(%#x, %v) => %v\n", addr, out, err);
+		fmt.Printf("poke(%#x, %v) => %v\n", addr, out, err)
 	}
 	return c, os.NewSyscallError("ptrace(POKETEXT)", err);
 }
@@ -284,7 +284,7 @@ var logLock sync.Mutex
 
 func (t *thread) logTrace(format string, args ...) {
 	if !trace {
-		return;
+		return
 	}
 	logLock.Lock();
 	defer logLock.Unlock();
@@ -293,7 +293,7 @@ func (t *thread) logTrace(format string, args ...) {
 		var regs syscall.PtraceRegs;
 		err := t.ptraceGetRegs(&regs);
 		if err == nil {
-			fmt.Fprintf(os.Stderr, "@%x", regs.PC());
+			fmt.Fprintf(os.Stderr, "@%x", regs.PC())
 		}
 	}
 	fmt.Fprint(os.Stderr, ": ");
@@ -311,7 +311,7 @@ func (t *thread) warn(format string, args ...) {
 
 func (p *process) logTrace(format string, args ...) {
 	if !trace {
-		return;
+		return
 	}
 	logLock.Lock();
 	defer logLock.Unlock();
@@ -331,7 +331,7 @@ func (p *process) logTrace(format string, args ...) {
 func (p *process) someStoppedThread() *thread {
 	for _, t := range p.threads {
 		if t.state.isStopped() {
-			return t;
+			return t
 		}
 	}
 	return nil;
@@ -344,7 +344,7 @@ func (p *process) someStoppedThread() *thread {
 func (p *process) someRunningThread() *thread {
 	for _, t := range p.threads {
 		if t.state.isRunning() {
-			return t;
+			return t
 		}
 	}
 	return nil;
@@ -362,7 +362,7 @@ func (p *process) installBreakpoints() os.Error {
 	main := p.someStoppedThread();
 	for _, b := range p.breakpoints {
 		if b.olddata != nil {
-			continue;
+			continue
 		}
 
 		b.olddata = make([]byte, len(bpinst386));
@@ -380,7 +380,7 @@ func (p *process) installBreakpoints() os.Error {
 		n++;
 	}
 	if n > 0 {
-		p.logTrace("installed %d/%d breakpoints", n, len(p.breakpoints));
+		p.logTrace("installed %d/%d breakpoints", n, len(p.breakpoints))
 	}
 
 	return nil;
@@ -391,24 +391,24 @@ func (p *process) installBreakpoints() os.Error {
 // Must be called from the monitor thread.
 func (p *process) uninstallBreakpoints() os.Error {
 	if len(p.threads) == 0 {
-		return nil;
+		return nil
 	}
 	n := 0;
 	main := p.someStoppedThread();
 	for _, b := range p.breakpoints {
 		if b.olddata == nil {
-			continue;
+			continue
 		}
 
 		_, err := main.ptracePokeText(uintptr(b.pc), b.olddata);
 		if err != nil {
-			return err;
+			return err
 		}
 		b.olddata = nil;
 		n++;
 	}
 	if n > 0 {
-		p.logTrace("uninstalled %d/%d breakpoints", n, len(p.breakpoints));
+		p.logTrace("uninstalled %d/%d breakpoints", n, len(p.breakpoints))
 	}
 
 	return nil;
@@ -430,14 +430,14 @@ func (t *thread) wait() {
 		t.logTrace("beginning wait");
 		ev.Waitmsg, ev.err = os.Wait(t.tid, syscall.WALL);
 		if ev.err == nil && ev.Pid != t.tid {
-			panic("Wait returned pid ", ev.Pid, " wanted ", t.tid);
+			panic("Wait returned pid ", ev.Pid, " wanted ", t.tid)
 		}
 		if ev.StopSignal() == syscall.SIGSTOP && t.ignoreNextSigstop {
 			// Spurious SIGSTOP.  See Thread.Stop().
 			t.ignoreNextSigstop = false;
 			err := t.ptraceCont();
 			if err == nil {
-				continue;
+				continue
 			}
 			// If we failed to continue, just let
 			// the stop go through so we can
@@ -445,7 +445,7 @@ func (t *thread) wait() {
 		}
 		if !<-t.proc.ready {
 			// The monitor exited
-			break;
+			break
 		}
 		t.proc.debugEvents <- &ev;
 		break;
@@ -463,13 +463,13 @@ func (t *thread) setState(new threadState) {
 
 	if !old.isRunning() && (new.isRunning() || new.isZombie()) {
 		// Start waiting on this thread
-		go t.wait();
+		go t.wait()
 	}
 
 	// Invoke state change handlers
 	handlers := t.proc.transitionHandlers;
 	if handlers.Len() == 0 {
-		return;
+		return
 	}
 
 	t.proc.transitionHandlers = vector.New(0);
@@ -494,7 +494,7 @@ func (p *process) stopAsync() os.Error {
 		if t.state == running {
 			err := t.sendSigstop();
 			if err != nil {
-				return err;
+				return err
 			}
 			t.setState(stopping);
 		}
@@ -511,7 +511,7 @@ func (ev *debugEvent) doTrap() (threadState, os.Error) {
 	t := ev.t;
 
 	if t.state == singleStepping {
-		return stopped, nil;
+		return stopped, nil
 	}
 
 	// Hit a breakpoint.  Linux leaves the program counter after
@@ -520,7 +520,7 @@ func (ev *debugEvent) doTrap() (threadState, os.Error) {
 	var regs syscall.PtraceRegs;
 	err := t.ptraceGetRegs(&regs);
 	if err != nil {
-		return stopped, err;
+		return stopped, err
 	}
 
 	b, ok := t.proc.breakpoints[uintptr(regs.PC())-uintptr(len(bpinst386))];
@@ -529,7 +529,7 @@ func (ev *debugEvent) doTrap() (threadState, os.Error) {
 		// the program.  Leave the IP where it is so we don't
 		// re-execute the breakpoint instruction.  Expose the
 		// fact that we stopped with a SIGTRAP.
-		return stoppedSignal, nil;
+		return stoppedSignal, nil
 	}
 
 	t.breakpoint = b;
@@ -538,7 +538,7 @@ func (ev *debugEvent) doTrap() (threadState, os.Error) {
 	regs.SetPC(uint64(b.pc));
 	err = t.ptraceSetRegs(&regs);
 	if err != nil {
-		return stopped, err;
+		return stopped, err
 	}
 	return stoppedBreakpoint, nil;
 }
@@ -552,12 +552,12 @@ func (ev *debugEvent) doPtraceClone() (threadState, os.Error) {
 	// Get the TID of the new thread
 	tid, err := t.ptraceGetEventMsg();
 	if err != nil {
-		return stopped, err;
+		return stopped, err
 	}
 
 	nt, err := t.proc.newThread(int(tid), syscall.SIGSTOP, true);
 	if err != nil {
-		return stopped, err;
+		return stopped, err
 	}
 
 	// Remember the thread
@@ -576,15 +576,15 @@ func (ev *debugEvent) doPtraceExit() (threadState, os.Error) {
 	// Get exit status
 	exitStatus, err := t.ptraceGetEventMsg();
 	if err != nil {
-		return stopped, err;
+		return stopped, err
 	}
 	ws := syscall.WaitStatus(exitStatus);
 	t.logTrace("exited with %v", ws);
 	switch {
 	case ws.Exited():
-		t.exitStatus = ws.ExitStatus();
+		t.exitStatus = ws.ExitStatus()
 	case ws.Signaled():
-		t.signal = ws.Signal();
+		t.signal = ws.Signal()
 	}
 
 	// We still need to continue this thread and wait on this
@@ -597,7 +597,7 @@ func (ev *debugEvent) doPtraceExit() (threadState, os.Error) {
 // any running threads.
 func (ev *debugEvent) process() os.Error {
 	if ev.err != nil {
-		return ev.err;
+		return ev.err
 	}
 
 	t := ev.t;
@@ -617,16 +617,16 @@ func (ev *debugEvent) process() os.Error {
 			switch cause := ev.TrapCause(); cause {
 			case 0:
 				// Breakpoint or single stepping
-				state, err = ev.doTrap();
+				state, err = ev.doTrap()
 
 			case syscall.PTRACE_EVENT_CLONE:
-				state, err = ev.doPtraceClone();
+				state, err = ev.doPtraceClone()
 
 			case syscall.PTRACE_EVENT_EXIT:
-				state, err = ev.doPtraceExit();
+				state, err = ev.doPtraceExit()
 
 			default:
-				t.warn("Unknown trap cause %d", cause);
+				t.warn("Unknown trap cause %d", cause)
 			}
 
 			if err != nil {
@@ -651,7 +651,7 @@ func (ev *debugEvent) process() os.Error {
 		t.signal = ev.Signal();
 
 	default:
-		panic(fmt.Sprintf("Unexpected wait status %v", ev.Waitmsg));
+		panic(fmt.Sprintf("Unexpected wait status %v", ev.Waitmsg))
 	}
 
 	// If we sent a SIGSTOP to the thread (indicated by state
@@ -660,7 +660,7 @@ func (ev *debugEvent) process() os.Error {
 	// SIGSTOP we sent is now queued up, so we should ignore the
 	// next one we get.
 	if t.state == stopping && ev.StopSignal() != syscall.SIGSTOP {
-		t.ignoreNextSigstop = true;
+		t.ignoreNextSigstop = true
 	}
 
 	// TODO(austin) If we're in state stopping and get a SIGSTOP,
@@ -670,7 +670,7 @@ func (ev *debugEvent) process() os.Error {
 
 	if t.proc.someRunningThread() == nil {
 		// Nothing is running, uninstall breakpoints
-		return t.proc.uninstallBreakpoints();
+		return t.proc.uninstallBreakpoints()
 	}
 	// Stop any other running threads
 	return t.proc.stopAsync();
@@ -689,9 +689,9 @@ func (t *thread) onStop(handle func(), onErr func(os.Error)) {
 	h := &transitionHandler{nil, onErr};
 	h.handle = func(st *thread, old, new threadState) {
 		if t == st && old.isRunning() && !new.isRunning() {
-			handle();
+			handle()
 		} else {
-			t.proc.transitionHandlers.Push(h);
+			t.proc.transitionHandlers.Push(h)
 		}
 	};
 	t.proc.transitionHandlers.Push(h);
@@ -717,13 +717,13 @@ func (p *process) monitor() {
 		p.ready <- true;
 		select {
 		case event := <-p.debugEvents:
-			err = event.process();
+			err = event.process()
 
 		case req := <-p.debugReqs:
-			req.res <- req.f();
+			req.res <- req.f()
 
 		case err = <-p.stopReq:
-			break;
+			break
 		}
 
 		if len(p.threads) == 0 {
@@ -732,7 +732,7 @@ func (p *process) monitor() {
 				err = ProcessExited{};
 			}
 		} else {
-			hadThreads = true;
+			hadThreads = true
 		}
 	}
 
@@ -754,7 +754,7 @@ func (p *process) monitor() {
 // Must NOT be called from the monitor thread.
 func (p *process) do(f func() os.Error) os.Error {
 	if !<-p.ready {
-		return p.err;
+		return p.err
 	}
 	req := &debugReq{f, make(chan os.Error)};
 	p.debugReqs <- req;
@@ -765,10 +765,10 @@ func (p *process) do(f func() os.Error) os.Error {
 // is already stopped, does nothing.
 func (p *process) stopMonitor(err os.Error) {
 	if err == nil {
-		panic("cannot stop the monitor with no error");
+		panic("cannot stop the monitor with no error")
 	}
 	if <-p.ready {
-		p.stopReq <- err;
+		p.stopReq <- err
 	}
 }
 
@@ -781,21 +781,21 @@ func (t *thread) Regs() (Regs, os.Error) {
 
 	err := t.proc.do(func() os.Error {
 		if !t.state.isStopped() {
-			return &badState{t, "cannot get registers", t.state};
+			return &badState{t, "cannot get registers", t.state}
 		}
 		return t.ptraceGetRegs(&regs);
 	});
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	setter := func(r *syscall.PtraceRegs) os.Error {
 		return t.proc.do(func() os.Error {
 			if !t.state.isStopped() {
-				return &badState{t, "cannot get registers", t.state};
+				return &badState{t, "cannot get registers", t.state}
 			}
 			return t.ptraceSetRegs(r);
-		});
+		})
 	};
 	return newRegs(&regs, setter), nil;
 }
@@ -805,7 +805,7 @@ func (t *thread) Peek(addr Word, out []byte) (int, os.Error) {
 
 	err := t.proc.do(func() os.Error {
 		if !t.state.isStopped() {
-			return &badState{t, "cannot peek text", t.state};
+			return &badState{t, "cannot peek text", t.state}
 		}
 
 		var err os.Error;
@@ -821,7 +821,7 @@ func (t *thread) Poke(addr Word, out []byte) (int, os.Error) {
 
 	err := t.proc.do(func() os.Error {
 		if !t.state.isStopped() {
-			return &badState{t, "cannot poke text", t.state};
+			return &badState{t, "cannot poke text", t.state}
 		}
 
 		var err os.Error;
@@ -839,7 +839,7 @@ func (t *thread) Poke(addr Word, out []byte) (int, os.Error) {
 // sends that error on the channel.
 func (t *thread) stepAsync(ready chan os.Error) os.Error {
 	if err := t.ptraceStep(); err != nil {
-		return err;
+		return err
 	}
 	t.setState(singleStepping);
 	t.onStop(func() { ready <- nil },
@@ -855,12 +855,12 @@ func (t *thread) Step() os.Error {
 
 	err := t.proc.do(func() os.Error {
 		if !t.state.isStopped() {
-			return &badState{t, "cannot single step", t.state};
+			return &badState{t, "cannot single step", t.state}
 		}
 		return t.stepAsync(ready);
 	});
 	if err != nil {
-		return err;
+		return err
 	}
 
 	err = <-ready;
@@ -882,7 +882,7 @@ var sigNames = [...]string{
 // the signal number is invalid, returns "<invalid>".
 func sigName(signal int) string {
 	if signal < 0 || signal >= len(sigNames) {
-		return "<invalid>";
+		return "<invalid>"
 	}
 	return sigNames[signal];
 }
@@ -892,31 +892,31 @@ func (t *thread) Stopped() (Cause, os.Error) {
 	err := t.proc.do(func() os.Error {
 		switch t.state {
 		case stopped:
-			c = Stopped{};
+			c = Stopped{}
 
 		case stoppedBreakpoint:
-			c = Breakpoint(t.breakpoint.pc);
+			c = Breakpoint(t.breakpoint.pc)
 
 		case stoppedSignal:
-			c = Signal(sigName(t.signal));
+			c = Signal(sigName(t.signal))
 
 		case stoppedThreadCreate:
-			c = &ThreadCreate{t.newThread};
+			c = &ThreadCreate{t.newThread}
 
 		case stoppedExiting, exiting, exited:
 			if t.signal == -1 {
-				c = &ThreadExit{t.exitStatus, ""};
+				c = &ThreadExit{t.exitStatus, ""}
 			} else {
-				c = &ThreadExit{t.exitStatus, sigName(t.signal)};
+				c = &ThreadExit{t.exitStatus, sigName(t.signal)}
 			}
 
 		default:
-			return &badState{t, "cannot get stop cause", t.state};
+			return &badState{t, "cannot get stop cause", t.state}
 		}
 		return nil;
 	});
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	return c, nil;
@@ -932,7 +932,7 @@ func (p *process) Threads() []Thread {
 			// Exclude zombie threads.
 			st := t.state;
 			if st == exiting || st == exited || st == detached {
-				continue;
+				continue
 			}
 
 			res[i] = t;
@@ -947,27 +947,27 @@ func (p *process) Threads() []Thread {
 func (p *process) AddBreakpoint(pc Word) os.Error {
 	return p.do(func() os.Error {
 		if t := p.someRunningThread(); t != nil {
-			return &badState{t, "cannot add breakpoint", t.state};
+			return &badState{t, "cannot add breakpoint", t.state}
 		}
 		if _, ok := p.breakpoints[uintptr(pc)]; ok {
-			return breakpointExistsError(pc);
+			return breakpointExistsError(pc)
 		}
 		p.breakpoints[uintptr(pc)] = &breakpoint{pc: uintptr(pc)};
 		return nil;
-	});
+	})
 }
 
 func (p *process) RemoveBreakpoint(pc Word) os.Error {
 	return p.do(func() os.Error {
 		if t := p.someRunningThread(); t != nil {
-			return &badState{t, "cannot remove breakpoint", t.state};
+			return &badState{t, "cannot remove breakpoint", t.state}
 		}
 		if _, ok := p.breakpoints[uintptr(pc)]; !ok {
-			return noBreakpointError(pc);
+			return noBreakpointError(pc)
 		}
 		p.breakpoints[uintptr(pc)] = nil, false;
 		return nil;
-	});
+	})
 }
 
 func (p *process) Continue() os.Error {
@@ -984,7 +984,7 @@ func (p *process) Continue() os.Error {
 
 		for _, t := range p.threads {
 			if !t.state.isStopped() {
-				continue;
+				continue
 			}
 
 			// We use the breakpoint map directly here
@@ -995,12 +995,12 @@ func (p *process) Continue() os.Error {
 			var regs syscall.PtraceRegs;
 			err := t.ptraceGetRegs(&regs);
 			if err != nil {
-				return err;
+				return err
 			}
 			if b, ok := p.breakpoints[uintptr(regs.PC())]; ok {
 				t.logTrace("stepping over breakpoint %v", b);
 				if err := t.stepAsync(ready); err != nil {
-					return err;
+					return err
 				}
 				count++;
 			}
@@ -1025,14 +1025,14 @@ func (p *process) Continue() os.Error {
 	// Continue all threads
 	err = p.do(func() os.Error {
 		if err := p.installBreakpoints(); err != nil {
-			return err;
+			return err
 		}
 
 		for _, t := range p.threads {
 			var err os.Error;
 			switch {
 			case !t.state.isStopped():
-				continue;
+				continue
 
 			case t.state == stoppedSignal && t.signal != syscall.SIGSTOP && t.signal != syscall.SIGTRAP:
 				t.logTrace("continuing with signal %d", t.signal);
@@ -1043,12 +1043,12 @@ func (p *process) Continue() os.Error {
 				err = t.ptraceCont();
 			}
 			if err != nil {
-				return err;
+				return err
 			}
 			if t.state == stoppedExiting {
-				t.setState(exiting);
+				t.setState(exiting)
 			} else {
-				t.setState(running);
+				t.setState(running)
 			}
 		}
 		return nil;
@@ -1091,7 +1091,7 @@ func (p *process) WaitStop() os.Error {
 		return nil;
 	});
 	if err != nil {
-		return err;
+		return err
 	}
 
 	return <-ready;
@@ -1100,7 +1100,7 @@ func (p *process) WaitStop() os.Error {
 func (p *process) Stop() os.Error {
 	err := p.do(func() os.Error { return p.stopAsync() });
 	if err != nil {
-		return err;
+		return err
 	}
 
 	return p.WaitStop();
@@ -1108,19 +1108,19 @@ func (p *process) Stop() os.Error {
 
 func (p *process) Detach() os.Error {
 	if err := p.Stop(); err != nil {
-		return err;
+		return err
 	}
 
 	err := p.do(func() os.Error {
 		if err := p.uninstallBreakpoints(); err != nil {
-			return err;
+			return err
 		}
 
 		for pid, t := range p.threads {
 			if t.state.isStopped() {
 				// We can't detach from zombies.
 				if err := t.ptraceDetach(); err != nil {
-					return err;
+					return err
 				}
 			}
 			t.setState(detached);
@@ -1144,16 +1144,16 @@ func (p *process) newThread(tid int, signal int, cloned bool) (*thread, os.Error
 	// TODO(austin) Thread might already be stopped if we're attaching.
 	w, err := os.Wait(tid, syscall.WALL);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	if w.Pid != tid || w.StopSignal() != signal {
-		return nil, &newThreadError{w, tid, signal};
+		return nil, &newThreadError{w, tid, signal}
 	}
 
 	if !cloned {
 		err = t.ptraceSetOptions(syscall.PTRACE_O_TRACECLONE | syscall.PTRACE_O_TRACEEXIT);
 		if err != nil {
-			return nil, err;
+			return nil, err
 		}
 	}
 
@@ -1171,7 +1171,7 @@ func (p *process) attachThread(tid int) (*thread, os.Error) {
 	err := p.do(func() os.Error {
 		errno := syscall.PtraceAttach(tid);
 		if errno != 0 {
-			return os.NewSyscallError("ptrace(ATTACH)", errno);
+			return os.NewSyscallError("ptrace(ATTACH)", errno)
 		}
 
 		var err os.Error;
@@ -1186,7 +1186,7 @@ func (p *process) attachAllThreads() os.Error {
 	taskPath := "/proc/" + strconv.Itoa(p.pid) + "/task";
 	taskDir, err := os.Open(taskPath, os.O_RDONLY, 0);
 	if err != nil {
-		return err;
+		return err
 	}
 	defer taskDir.Close();
 
@@ -1199,16 +1199,16 @@ func (p *process) attachAllThreads() os.Error {
 
 		tids, err := taskDir.Readdirnames(-1);
 		if err != nil {
-			return err;
+			return err
 		}
 
 		for _, tidStr := range tids {
 			tid, err := strconv.Atoi(tidStr);
 			if err != nil {
-				return err;
+				return err
 			}
 			if _, ok := p.threads[tid]; ok {
-				continue;
+				continue
 			}
 
 			_, err = p.attachThread(tid);
@@ -1290,9 +1290,9 @@ func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []*os.F
 	intfd := make([]int, len(fd));
 	for i, f := range fd {
 		if f == nil {
-			intfd[i] = -1;
+			intfd[i] = -1
 		} else {
-			intfd[i] = f.Fd();
+			intfd[i] = f.Fd()
 		}
 	}
 
@@ -1300,7 +1300,7 @@ func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []*os.F
 	err := p.do(func() os.Error {
 		pid, errno := syscall.PtraceForkExec(argv0, argv, envv, dir, intfd);
 		if errno != 0 {
-			return &os.PathError{"fork/exec", argv0, os.Errno(errno)};
+			return &os.PathError{"fork/exec", argv0, os.Errno(errno)}
 		}
 		p.pid = pid;
 
diff --git a/src/pkg/debug/proc/proc_nacl.go b/src/pkg/debug/proc/proc_nacl.go
index 6942209a6b..c4f6067393 100644
--- a/src/pkg/debug/proc/proc_nacl.go
+++ b/src/pkg/debug/proc/proc_nacl.go
@@ -12,9 +12,9 @@ import (
 // Process tracing is not supported on Native Client.
 
 func Attach(pid int) (Process, os.Error) {
-	return nil, os.NewSyscallError("ptrace", syscall.ENACL);
+	return nil, os.NewSyscallError("ptrace", syscall.ENACL)
 }
 
 func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []*os.File) (Process, os.Error) {
-	return nil, os.NewSyscallError("fork/exec", syscall.ENACL);
+	return nil, os.NewSyscallError("fork/exec", syscall.ENACL)
 }
diff --git a/src/pkg/debug/proc/regs_linux_386.go b/src/pkg/debug/proc/regs_linux_386.go
index a665cd4d14..abeb45f4b8 100644
--- a/src/pkg/debug/proc/regs_linux_386.go
+++ b/src/pkg/debug/proc/regs_linux_386.go
@@ -43,7 +43,7 @@ func (r *_386Regs) SetPC(val Word) os.Error {
 
 func (r *_386Regs) Link() Word {
 	// TODO(austin)
-	panic("No link register");
+	panic("No link register")
 }
 
 func (r *_386Regs) SetLink(val Word) os.Error	{ panic("No link register") }
@@ -60,37 +60,37 @@ func (r *_386Regs) Names() []string	{ return &names }
 func (r *_386Regs) Get(i int) Word {
 	switch i {
 	case 0:
-		return Word(uint32(r.Eax));
+		return Word(uint32(r.Eax))
 	case 1:
-		return Word(uint32(r.Ebx));
+		return Word(uint32(r.Ebx))
 	case 2:
-		return Word(uint32(r.Ecx));
+		return Word(uint32(r.Ecx))
 	case 3:
-		return Word(uint32(r.Edx));
+		return Word(uint32(r.Edx))
 	case 4:
-		return Word(uint32(r.Esi));
+		return Word(uint32(r.Esi))
 	case 5:
-		return Word(uint32(r.Edi));
+		return Word(uint32(r.Edi))
 	case 6:
-		return Word(uint32(r.Ebp));
+		return Word(uint32(r.Ebp))
 	case 7:
-		return Word(uint32(r.Esp));
+		return Word(uint32(r.Esp))
 	case 8:
-		return Word(uint32(r.Eip));
+		return Word(uint32(r.Eip))
 	case 9:
-		return Word(uint32(r.Eflags));
+		return Word(uint32(r.Eflags))
 	case 10:
-		return Word(r.Cs);
+		return Word(r.Cs)
 	case 11:
-		return Word(r.Ss);
+		return Word(r.Ss)
 	case 12:
-		return Word(r.Ds);
+		return Word(r.Ds)
 	case 13:
-		return Word(r.Es);
+		return Word(r.Es)
 	case 14:
-		return Word(r.Fs);
+		return Word(r.Fs)
 	case 15:
-		return Word(r.Gs);
+		return Word(r.Gs)
 	}
 	panic("invalid register index ", strconv.Itoa(i));
 }
@@ -98,39 +98,39 @@ func (r *_386Regs) Get(i int) Word {
 func (r *_386Regs) Set(i int, val Word) os.Error {
 	switch i {
 	case 0:
-		r.Eax = int32(val);
+		r.Eax = int32(val)
 	case 1:
-		r.Ebx = int32(val);
+		r.Ebx = int32(val)
 	case 2:
-		r.Ecx = int32(val);
+		r.Ecx = int32(val)
 	case 3:
-		r.Edx = int32(val);
+		r.Edx = int32(val)
 	case 4:
-		r.Esi = int32(val);
+		r.Esi = int32(val)
 	case 5:
-		r.Edi = int32(val);
+		r.Edi = int32(val)
 	case 6:
-		r.Ebp = int32(val);
+		r.Ebp = int32(val)
 	case 7:
-		r.Esp = int32(val);
+		r.Esp = int32(val)
 	case 8:
-		r.Eip = int32(val);
+		r.Eip = int32(val)
 	case 9:
-		r.Eflags = int32(val);
+		r.Eflags = int32(val)
 	case 10:
-		r.Cs = uint16(val);
+		r.Cs = uint16(val)
 	case 11:
-		r.Ss = uint16(val);
+		r.Ss = uint16(val)
 	case 12:
-		r.Ds = uint16(val);
+		r.Ds = uint16(val)
 	case 13:
-		r.Es = uint16(val);
+		r.Es = uint16(val)
 	case 14:
-		r.Fs = uint16(val);
+		r.Fs = uint16(val)
 	case 15:
-		r.Gs = uint16(val);
+		r.Gs = uint16(val)
 	default:
-		panic("invalid register index ", strconv.Itoa(i));
+		panic("invalid register index ", strconv.Itoa(i))
 	}
 	return r.setter(&r.PtraceRegs);
 }
diff --git a/src/pkg/debug/proc/regs_linux_amd64.go b/src/pkg/debug/proc/regs_linux_amd64.go
index 64559dc9e1..63083a948f 100644
--- a/src/pkg/debug/proc/regs_linux_amd64.go
+++ b/src/pkg/debug/proc/regs_linux_amd64.go
@@ -57,11 +57,11 @@ func (r *amd64Regs) SetPC(val Word) os.Error {
 
 func (r *amd64Regs) Link() Word {
 	// TODO(austin)
-	panic("No link register");
+	panic("No link register")
 }
 
 func (r *amd64Regs) SetLink(val Word) os.Error {
-	panic("No link register");
+	panic("No link register")
 }
 
 func (r *amd64Regs) SP() Word	{ return Word(r.Rsp) }
@@ -76,53 +76,53 @@ func (r *amd64Regs) Names() []string	{ return &names }
 func (r *amd64Regs) Get(i int) Word {
 	switch i {
 	case 0:
-		return Word(r.Rax);
+		return Word(r.Rax)
 	case 1:
-		return Word(r.Rbx);
+		return Word(r.Rbx)
 	case 2:
-		return Word(r.Rcx);
+		return Word(r.Rcx)
 	case 3:
-		return Word(r.Rdx);
+		return Word(r.Rdx)
 	case 4:
-		return Word(r.Rsi);
+		return Word(r.Rsi)
 	case 5:
-		return Word(r.Rdi);
+		return Word(r.Rdi)
 	case 6:
-		return Word(r.Rbp);
+		return Word(r.Rbp)
 	case 7:
-		return Word(r.Rsp);
+		return Word(r.Rsp)
 	case 8:
-		return Word(r.R8);
+		return Word(r.R8)
 	case 9:
-		return Word(r.R9);
+		return Word(r.R9)
 	case 10:
-		return Word(r.R10);
+		return Word(r.R10)
 	case 11:
-		return Word(r.R11);
+		return Word(r.R11)
 	case 12:
-		return Word(r.R12);
+		return Word(r.R12)
 	case 13:
-		return Word(r.R13);
+		return Word(r.R13)
 	case 14:
-		return Word(r.R14);
+		return Word(r.R14)
 	case 15:
-		return Word(r.R15);
+		return Word(r.R15)
 	case 16:
-		return Word(r.Rip);
+		return Word(r.Rip)
 	case 17:
-		return Word(r.Eflags);
+		return Word(r.Eflags)
 	case 18:
-		return Word(r.Cs);
+		return Word(r.Cs)
 	case 19:
-		return Word(r.Ss);
+		return Word(r.Ss)
 	case 20:
-		return Word(r.Ds);
+		return Word(r.Ds)
 	case 21:
-		return Word(r.Es);
+		return Word(r.Es)
 	case 22:
-		return Word(r.Fs);
+		return Word(r.Fs)
 	case 23:
-		return Word(r.Gs);
+		return Word(r.Gs)
 	}
 	panic("invalid register index ", strconv.Itoa(i));
 }
@@ -130,55 +130,55 @@ func (r *amd64Regs) Get(i int) Word {
 func (r *amd64Regs) Set(i int, val Word) os.Error {
 	switch i {
 	case 0:
-		r.Rax = uint64(val);
+		r.Rax = uint64(val)
 	case 1:
-		r.Rbx = uint64(val);
+		r.Rbx = uint64(val)
 	case 2:
-		r.Rcx = uint64(val);
+		r.Rcx = uint64(val)
 	case 3:
-		r.Rdx = uint64(val);
+		r.Rdx = uint64(val)
 	case 4:
-		r.Rsi = uint64(val);
+		r.Rsi = uint64(val)
 	case 5:
-		r.Rdi = uint64(val);
+		r.Rdi = uint64(val)
 	case 6:
-		r.Rbp = uint64(val);
+		r.Rbp = uint64(val)
 	case 7:
-		r.Rsp = uint64(val);
+		r.Rsp = uint64(val)
 	case 8:
-		r.R8 = uint64(val);
+		r.R8 = uint64(val)
 	case 9:
-		r.R9 = uint64(val);
+		r.R9 = uint64(val)
 	case 10:
-		r.R10 = uint64(val);
+		r.R10 = uint64(val)
 	case 11:
-		r.R11 = uint64(val);
+		r.R11 = uint64(val)
 	case 12:
-		r.R12 = uint64(val);
+		r.R12 = uint64(val)
 	case 13:
-		r.R13 = uint64(val);
+		r.R13 = uint64(val)
 	case 14:
-		r.R14 = uint64(val);
+		r.R14 = uint64(val)
 	case 15:
-		r.R15 = uint64(val);
+		r.R15 = uint64(val)
 	case 16:
-		r.Rip = uint64(val);
+		r.Rip = uint64(val)
 	case 17:
-		r.Eflags = uint64(val);
+		r.Eflags = uint64(val)
 	case 18:
-		r.Cs = uint64(val);
+		r.Cs = uint64(val)
 	case 19:
-		r.Ss = uint64(val);
+		r.Ss = uint64(val)
 	case 20:
-		r.Ds = uint64(val);
+		r.Ds = uint64(val)
 	case 21:
-		r.Es = uint64(val);
+		r.Es = uint64(val)
 	case 22:
-		r.Fs = uint64(val);
+		r.Fs = uint64(val)
 	case 23:
-		r.Gs = uint64(val);
+		r.Gs = uint64(val)
 	default:
-		panic("invalid register index ", strconv.Itoa(i));
+		panic("invalid register index ", strconv.Itoa(i))
 	}
 	return r.setter(&r.PtraceRegs);
 }
diff --git a/src/pkg/debug/proc/regs_linux_arm.go b/src/pkg/debug/proc/regs_linux_arm.go
index ed2834f697..e58ab388bd 100644
--- a/src/pkg/debug/proc/regs_linux_arm.go
+++ b/src/pkg/debug/proc/regs_linux_arm.go
@@ -30,7 +30,7 @@ func (r *armRegs) Names() []string	{ return nil }
 func (r *armRegs) Get(i int) Word	{ return Word(0) }
 
 func (r *armRegs) Set(i int, val Word) os.Error {
-	return nil;
+	return nil
 }
 
 func newRegs(regs *syscall.PtraceRegs, setter func(*syscall.PtraceRegs) os.Error) Regs {
diff --git a/src/pkg/ebnf/ebnf.go b/src/pkg/ebnf/ebnf.go
index fdbb4b1ea9..0df330181d 100644
--- a/src/pkg/ebnf/ebnf.go
+++ b/src/pkg/ebnf/ebnf.go
@@ -97,12 +97,12 @@ type (
 
 
 func (x Alternative) Pos() token.Position {
-	return x[0].Pos();	// the parser always generates non-empty Alternative
+	return x[0].Pos()	// the parser always generates non-empty Alternative
 }
 
 
 func (x Sequence) Pos() token.Position {
-	return x[0].Pos();	// the parser always generates non-empty Sequences
+	return x[0].Pos()	// the parser always generates non-empty Sequences
 }
 
 
@@ -155,24 +155,24 @@ func (v *verifier) verifyExpr(expr Expression, lexical bool) {
 		// empty expression
 	case Alternative:
 		for _, e := range x {
-			v.verifyExpr(e, lexical);
+			v.verifyExpr(e, lexical)
 		}
 	case Sequence:
 		for _, e := range x {
-			v.verifyExpr(e, lexical);
+			v.verifyExpr(e, lexical)
 		}
 	case *Name:
 		// a production with this name must exist;
 		// add it to the worklist if not yet processed
 		if prod, found := v.grammar[x.String]; found {
-			v.push(prod);
+			v.push(prod)
 		} else {
-			v.Error(x.Pos(), "missing production " + x.String);
+			v.Error(x.Pos(), "missing production " + x.String)
 		}
 		// within a lexical production references
 		// to non-lexical productions are invalid
 		if lexical && !isLexical(x.String) {
-			v.Error(x.Pos(), "reference to non-lexical production " + x.String);
+			v.Error(x.Pos(), "reference to non-lexical production " + x.String)
 		}
 	case *Token:
 		// nothing to do for now
@@ -180,16 +180,16 @@ func (v *verifier) verifyExpr(expr Expression, lexical bool) {
 		i := v.verifyChar(x.Begin);
 		j := v.verifyChar(x.End);
 		if i >= j {
-			v.Error(x.Pos(), "decreasing character range");
+			v.Error(x.Pos(), "decreasing character range")
 		}
 	case *Group:
-		v.verifyExpr(x.Body, lexical);
+		v.verifyExpr(x.Body, lexical)
 	case *Option:
-		v.verifyExpr(x.Body, lexical);
+		v.verifyExpr(x.Body, lexical)
 	case *Repetition:
-		v.verifyExpr(x.Body, lexical);
+		v.verifyExpr(x.Body, lexical)
 	default:
-		panic("unreachable");
+		panic("unreachable")
 	}
 }
 
@@ -220,7 +220,7 @@ func (v *verifier) verify(grammar Grammar, start string) {
 	if len(v.reached) < len(v.grammar) {
 		for name, prod := range v.grammar {
 			if _, found := v.reached[name]; !found {
-				v.Error(prod.Pos(), name + " is unreachable");
+				v.Error(prod.Pos(), name + " is unreachable")
 			}
 		}
 	}
diff --git a/src/pkg/ebnf/ebnf_test.go b/src/pkg/ebnf/ebnf_test.go
index 498be622c0..3eda8d9a3c 100644
--- a/src/pkg/ebnf/ebnf_test.go
+++ b/src/pkg/ebnf/ebnf_test.go
@@ -43,17 +43,17 @@ var grammars = []string{
 func check(t *testing.T, filename string, src []byte) {
 	grammar, err := Parse(filename, src);
 	if err != nil {
-		t.Errorf("Parse(%s) failed: %v", src, err);
+		t.Errorf("Parse(%s) failed: %v", src, err)
 	}
 	if err = Verify(grammar, "Program"); err != nil {
-		t.Errorf("Verify(%s) failed: %v", src, err);
+		t.Errorf("Verify(%s) failed: %v", src, err)
 	}
 }
 
 
 func TestGrammars(t *testing.T) {
 	for _, src := range grammars {
-		check(t, "", strings.Bytes(src));
+		check(t, "", strings.Bytes(src))
 	}
 }
 
@@ -67,7 +67,7 @@ func TestFiles(t *testing.T) {
 	for _, filename := range files {
 		src, err := io.ReadFile(filename);
 		if err != nil {
-			t.Fatal(err);
+			t.Fatal(err)
 		}
 		check(t, filename, src);
 	}
diff --git a/src/pkg/ebnf/parser.go b/src/pkg/ebnf/parser.go
index 325673caf7..8c7b0b1410 100644
--- a/src/pkg/ebnf/parser.go
+++ b/src/pkg/ebnf/parser.go
@@ -27,7 +27,7 @@ func (p *parser) next() {
 	if p.tok.IsKeyword() {
 		// TODO Should keyword mapping always happen outside scanner?
 		//      Or should there be a flag to scanner to enable keyword mapping?
-		p.tok = token.IDENT;
+		p.tok = token.IDENT
 	}
 }
 
@@ -39,7 +39,7 @@ func (p *parser) errorExpected(pos token.Position, msg string) {
 		// make the error message more specific
 		msg += ", found '" + p.tok.String() + "'";
 		if p.tok.IsLiteral() {
-			msg += " "+string(p.lit);
+			msg += " "+string(p.lit)
 		}
 	}
 	p.Error(pos, msg);
@@ -49,7 +49,7 @@ func (p *parser) errorExpected(pos token.Position, msg string) {
 func (p *parser) expect(tok token.Token) token.Position {
 	pos := p.pos;
 	if p.tok != tok {
-		p.errorExpected(pos, "'" + tok.String() + "'");
+		p.errorExpected(pos, "'" + tok.String() + "'")
 	}
 	p.next();	// make progress in any case
 	return pos;
@@ -74,7 +74,7 @@ func (p *parser) parseToken() *Token {
 		// has already been reported.
 		p.next();
 	} else {
-		p.expect(token.STRING);
+		p.expect(token.STRING)
 	}
 	return &Token{pos, value};
 }
@@ -85,7 +85,7 @@ func (p *parser) parseTerm() (x Expression) {
 
 	switch p.tok {
 	case token.IDENT:
-		x = p.parseIdentifier();
+		x = p.parseIdentifier()
 
 	case token.STRING:
 		tok := p.parseToken();
@@ -120,21 +120,21 @@ func (p *parser) parseSequence() Expression {
 	list.Init(0);
 
 	for x := p.parseTerm(); x != nil; x = p.parseTerm() {
-		list.Push(x);
+		list.Push(x)
 	}
 
 	// no need for a sequence if list.Len() < 2
 	switch list.Len() {
 	case 0:
-		return nil;
+		return nil
 	case 1:
-		return list.At(0).(Expression);
+		return list.At(0).(Expression)
 	}
 
 	// convert list into a sequence
 	seq := make(Sequence, list.Len());
 	for i := 0; i < list.Len(); i++ {
-		seq[i] = list.At(i).(Expression);
+		seq[i] = list.At(i).(Expression)
 	}
 	return seq;
 }
@@ -147,10 +147,10 @@ func (p *parser) parseExpression() Expression {
 	for {
 		x := p.parseSequence();
 		if x != nil {
-			list.Push(x);
+			list.Push(x)
 		}
 		if p.tok != token.OR {
-			break;
+			break
 		}
 		p.next();
 	}
@@ -158,15 +158,15 @@ func (p *parser) parseExpression() Expression {
 	// no need for an Alternative node if list.Len() < 2
 	switch list.Len() {
 	case 0:
-		return nil;
+		return nil
 	case 1:
-		return list.At(0).(Expression);
+		return list.At(0).(Expression)
 	}
 
 	// convert list into an Alternative node
 	alt := make(Alternative, list.Len());
 	for i := 0; i < list.Len(); i++ {
-		alt[i] = list.At(i).(Expression);
+		alt[i] = list.At(i).(Expression)
 	}
 	return alt;
 }
@@ -192,9 +192,9 @@ func (p *parser) parse(filename string, src []byte) Grammar {
 		prod := p.parseProduction();
 		name := prod.Name.String;
 		if _, found := grammar[name]; !found {
-			grammar[name] = prod;
+			grammar[name] = prod
 		} else {
-			p.Error(prod.Pos(), name + " declared already");
+			p.Error(prod.Pos(), name + " declared already")
 		}
 	}
 
diff --git a/src/pkg/encoding/ascii85/ascii85.go b/src/pkg/encoding/ascii85/ascii85.go
index a1d9f7a7ae..819b263d07 100644
--- a/src/pkg/encoding/ascii85/ascii85.go
+++ b/src/pkg/encoding/ascii85/ascii85.go
@@ -28,7 +28,7 @@ import (
 // Encode does not add these.
 func Encode(dst, src []byte) int {
 	if len(src) == 0 {
-		return 0;
+		return 0
 	}
 
 	n := 0;
@@ -52,7 +52,7 @@ func Encode(dst, src []byte) int {
 			v |= uint32(src[1])<<16;
 			fallthrough;
 		case 1:
-			v |= uint32(src[0])<<24;
+			v |= uint32(src[0])<<24
 		}
 
 		// Special case: zero (!!!!!) shortens to z.
@@ -75,7 +75,7 @@ func Encode(dst, src []byte) int {
 			m -= 4-len(src);
 			src = nil;
 		} else {
-			src = src[4:len(src)];
+			src = src[4:len(src)]
 		}
 		dst = dst[m:len(dst)];
 		n += m;
@@ -103,7 +103,7 @@ type encoder struct {
 
 func (e *encoder) Write(p []byte) (n int, err os.Error) {
 	if e.err != nil {
-		return 0, e.err;
+		return 0, e.err
 	}
 
 	// Leading fringe.
@@ -116,11 +116,11 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 		n += i;
 		p = p[i:len(p)];
 		if e.nbuf < 4 {
-			return;
+			return
 		}
 		nout := Encode(&e.out, &e.buf);
 		if _, e.err = e.w.Write(e.out[0:nout]); e.err != nil {
-			return n, e.err;
+			return n, e.err
 		}
 		e.nbuf = 0;
 	}
@@ -129,13 +129,13 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 	for len(p) >= 4 {
 		nn := len(e.out)/5*4;
 		if nn > len(p) {
-			nn = len(p);
+			nn = len(p)
 		}
 		nn -= nn%4;
 		if nn > 0 {
 			nout := Encode(&e.out, p[0:nn]);
 			if _, e.err = e.w.Write(e.out[0:nout]); e.err != nil {
-				return n, e.err;
+				return n, e.err
 			}
 		}
 		n += nn;
@@ -144,7 +144,7 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 
 	// Trailing fringe.
 	for i := 0; i < len(p); i++ {
-		e.buf[i] = p[i];
+		e.buf[i] = p[i]
 	}
 	e.nbuf = len(p);
 	n += len(p);
@@ -170,7 +170,7 @@ func (e *encoder) Close() os.Error {
 type CorruptInputError int64
 
 func (e CorruptInputError) String() string {
-	return "illegal ascii85 data at input byte" + strconv.Itoa64(int64(e));
+	return "illegal ascii85 data at input byte" + strconv.Itoa64(int64(e))
 }
 
 // Decode decodes src into dst, returning both the number
@@ -192,11 +192,11 @@ func Decode(dst, src []byte, flush bool) (ndst, nsrc int, err os.Error) {
 	var nb int;
 	for i, b := range src {
 		if len(dst)-ndst < 4 {
-			return;
+			return
 		}
 		switch {
 		case b <= ' ':
-			continue;
+			continue
 		case b == 'z' && nb == 0:
 			nb = 5;
 			v = 0;
@@ -204,7 +204,7 @@ func Decode(dst, src []byte, flush bool) (ndst, nsrc int, err os.Error) {
 			v = v*85 + uint32(b-'!');
 			nb++;
 		default:
-			return 0, 0, CorruptInputError(i);
+			return 0, 0, CorruptInputError(i)
 		}
 		if nb == 5 {
 			nsrc = i+1;
@@ -225,13 +225,13 @@ func Decode(dst, src []byte, flush bool) (ndst, nsrc int, err os.Error) {
 			// the extra byte provides enough bits to cover
 			// the inefficiency of the encoding for the block.
 			if nb == 1 {
-				return 0, 0, CorruptInputError(len(src));
+				return 0, 0, CorruptInputError(len(src))
 			}
 			for i := nb; i < 5; i++ {
 				// The short encoding truncated the output value.
 				// We have to assume the worst case values (digit 84)
 				// in order to ensure that the top bits are correct.
-				v = v*85 + 84;
+				v = v*85 + 84
 			}
 			for i := 0; i < nb-1; i++ {
 				dst[ndst] = byte(v>>24);
@@ -259,10 +259,10 @@ type decoder struct {
 
 func (d *decoder) Read(p []byte) (n int, err os.Error) {
 	if len(p) == 0 {
-		return 0, nil;
+		return 0, nil
 	}
 	if d.err != nil {
-		return 0, d.err;
+		return 0, d.err
 	}
 
 	for {
@@ -286,7 +286,7 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 
 		// Out of input, out of decoded output.  Check errors.
 		if d.err != nil {
-			return 0, d.err;
+			return 0, d.err
 		}
 		if d.readErr != nil {
 			d.err = d.readErr;
diff --git a/src/pkg/encoding/ascii85/ascii85_test.go b/src/pkg/encoding/ascii85/ascii85_test.go
index fa31a89519..36cc019d0d 100644
--- a/src/pkg/encoding/ascii85/ascii85_test.go
+++ b/src/pkg/encoding/ascii85/ascii85_test.go
@@ -85,7 +85,7 @@ func TestEncoderBuffering(t *testing.T) {
 		for pos := 0; pos < len(input); pos += bs {
 			end := pos+bs;
 			if end > len(input) {
-				end = len(input);
+				end = len(input)
 			}
 			n, err := encoder.Write(input[pos:end]);
 			testEqual(t, "Write(%q) gave error %v, want %v", input[pos:end], err, os.Error(nil));
@@ -113,12 +113,12 @@ func TestDecoder(t *testing.T) {
 		decoder := NewDecoder(bytes.NewBufferString(p.encoded));
 		dbuf, err := io.ReadAll(decoder);
 		if err != nil {
-			t.Fatal("Read failed", err);
+			t.Fatal("Read failed", err)
 		}
 		testEqual(t, "Read from %q = length %v, want %v", p.encoded, len(dbuf), len(p.decoded));
 		testEqual(t, "Decoding of %q = %q, want %q", p.encoded, string(dbuf), p.decoded);
 		if err != nil {
-			testEqual(t, "Read from %q = %v, want %v", p.encoded, err, os.EOF);
+			testEqual(t, "Read from %q = %v, want %v", p.encoded, err, os.EOF)
 		}
 	}
 }
@@ -152,9 +152,9 @@ func TestDecodeCorrupt(t *testing.T) {
 		_, _, err := Decode(dbuf, strings.Bytes(e.e), true);
 		switch err := err.(type) {
 		case CorruptInputError:
-			testEqual(t, "Corruption in %q at offset %v, want %v", e.e, int(err), e.p);
+			testEqual(t, "Corruption in %q at offset %v, want %v", e.e, int(err), e.p)
 		default:
-			t.Error("Decoder failed to detect corruption in", e);
+			t.Error("Decoder failed to detect corruption in", e)
 		}
 	}
 }
@@ -164,28 +164,28 @@ func TestBig(t *testing.T) {
 	raw := make([]byte, n);
 	const alpha = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
 	for i := 0; i < n; i++ {
-		raw[i] = alpha[i%len(alpha)];
+		raw[i] = alpha[i%len(alpha)]
 	}
 	encoded := new(bytes.Buffer);
 	w := NewEncoder(encoded);
 	nn, err := w.Write(raw);
 	if nn != n || err != nil {
-		t.Fatalf("Encoder.Write(raw) = %d, %v want %d, nil", nn, err, n);
+		t.Fatalf("Encoder.Write(raw) = %d, %v want %d, nil", nn, err, n)
 	}
 	err = w.Close();
 	if err != nil {
-		t.Fatalf("Encoder.Close() = %v want nil", err);
+		t.Fatalf("Encoder.Close() = %v want nil", err)
 	}
 	decoded, err := io.ReadAll(NewDecoder(encoded));
 	if err != nil {
-		t.Fatalf("io.ReadAll(NewDecoder(...)): %v", err);
+		t.Fatalf("io.ReadAll(NewDecoder(...)): %v", err)
 	}
 
 	if !bytes.Equal(raw, decoded) {
 		var i int;
 		for i = 0; i < len(decoded) && i < len(raw); i++ {
 			if decoded[i] != raw[i] {
-				break;
+				break
 			}
 		}
 		t.Errorf("Decode(Encode(%d-byte string)) failed at offset %d", n, i);
diff --git a/src/pkg/encoding/base64/base64.go b/src/pkg/encoding/base64/base64.go
index 33010aa1b1..83521ad45c 100644
--- a/src/pkg/encoding/base64/base64.go
+++ b/src/pkg/encoding/base64/base64.go
@@ -35,10 +35,10 @@ func NewEncoding(encoder string) *Encoding {
 	e := new(Encoding);
 	e.encode = encoder;
 	for i := 0; i < len(e.decodeMap); i++ {
-		e.decodeMap[i] = 0xFF;
+		e.decodeMap[i] = 0xFF
 	}
 	for i := 0; i < len(encoder); i++ {
-		e.decodeMap[encoder[i]] = byte(i);
+		e.decodeMap[encoder[i]] = byte(i)
 	}
 	return e;
 }
@@ -63,7 +63,7 @@ var URLEncoding = NewEncoding(encodeURL)
 // of a large data stream.  Use NewEncoder() instead.
 func (enc *Encoding) Encode(dst, src []byte) {
 	if len(src) == 0 {
-		return;
+		return
 	}
 
 	for len(src) > 0 {
@@ -90,14 +90,14 @@ func (enc *Encoding) Encode(dst, src []byte) {
 
 		// Encode 6-bit blocks using the base64 alphabet
 		for j := 0; j < 4; j++ {
-			dst[j] = enc.encode[dst[j]];
+			dst[j] = enc.encode[dst[j]]
 		}
 
 		// Pad the final quantum
 		if len(src) < 3 {
 			dst[3] = '=';
 			if len(src) < 2 {
-				dst[2] = '=';
+				dst[2] = '='
 			}
 			break;
 		}
@@ -118,7 +118,7 @@ type encoder struct {
 
 func (e *encoder) Write(p []byte) (n int, err os.Error) {
 	if e.err != nil {
-		return 0, e.err;
+		return 0, e.err
 	}
 
 	// Leading fringe.
@@ -131,11 +131,11 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 		n += i;
 		p = p[i:len(p)];
 		if e.nbuf < 3 {
-			return;
+			return
 		}
 		e.enc.Encode(&e.out, &e.buf);
 		if _, e.err = e.w.Write(e.out[0:4]); e.err != nil {
-			return n, e.err;
+			return n, e.err
 		}
 		e.nbuf = 0;
 	}
@@ -144,13 +144,13 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 	for len(p) >= 3 {
 		nn := len(e.out)/4*3;
 		if nn > len(p) {
-			nn = len(p);
+			nn = len(p)
 		}
 		nn -= nn%3;
 		if nn > 0 {
 			e.enc.Encode(&e.out, p[0:nn]);
 			if _, e.err = e.w.Write(e.out[0 : nn/3*4]); e.err != nil {
-				return n, e.err;
+				return n, e.err
 			}
 		}
 		n += nn;
@@ -159,7 +159,7 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 
 	// Trailing fringe.
 	for i := 0; i < len(p); i++ {
-		e.buf[i] = p[i];
+		e.buf[i] = p[i]
 	}
 	e.nbuf = len(p);
 	n += len(p);
@@ -184,7 +184,7 @@ func (e *encoder) Close() os.Error {
 // writing, the caller must Close the returned encoder to flush any
 // partially written blocks.
 func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser {
-	return &encoder{enc: enc, w: w};
+	return &encoder{enc: enc, w: w}
 }
 
 // EncodedLen returns the length in bytes of the base64 encoding
@@ -198,7 +198,7 @@ func (enc *Encoding) EncodedLen(n int) int	{ return (n+2)/3*4 }
 type CorruptInputError int64
 
 func (e CorruptInputError) String() string {
-	return "illegal base64 data at input byte" + strconv.Itoa64(int64(e));
+	return "illegal base64 data at input byte" + strconv.Itoa64(int64(e))
 }
 
 // decode is like Decode but returns an additional 'end' value, which
@@ -218,7 +218,7 @@ func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err os.Error) {
 				// We've reached the end and there's
 				// padding
 				if src[i*4 + 3] != '=' {
-					return n, false, CorruptInputError(i*4 + 2);
+					return n, false, CorruptInputError(i*4 + 2)
 				}
 				dlen = j;
 				end = true;
@@ -226,7 +226,7 @@ func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err os.Error) {
 			}
 			dbuf[j] = enc.decodeMap[in];
 			if dbuf[j] == 0xFF {
-				return n, false, CorruptInputError(i*4 + j);
+				return n, false, CorruptInputError(i*4 + j)
 			}
 		}
 
@@ -240,7 +240,7 @@ func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err os.Error) {
 			dst[i*3 + 1] = dbuf[1]<<4 | dbuf[2]>>2;
 			fallthrough;
 		case 2:
-			dst[i*3 + 0] = dbuf[0]<<2 | dbuf[1]>>4;
+			dst[i*3 + 0] = dbuf[0]<<2 | dbuf[1]>>4
 		}
 		n += dlen-1;
 	}
@@ -254,7 +254,7 @@ func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err os.Error) {
 // number of bytes successfully written and CorruptInputError.
 func (enc *Encoding) Decode(dst, src []byte) (n int, err os.Error) {
 	if len(src)%4 != 0 {
-		return 0, CorruptInputError(len(src)/4*4);
+		return 0, CorruptInputError(len(src)/4*4)
 	}
 
 	n, _, err = enc.decode(dst, src);
@@ -274,7 +274,7 @@ type decoder struct {
 
 func (d *decoder) Read(p []byte) (n int, err os.Error) {
 	if d.err != nil {
-		return 0, d.err;
+		return 0, d.err
 	}
 
 	// Use leftover decoded output from last read.
@@ -287,15 +287,15 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 	// Read a chunk.
 	nn := len(p)/3*4;
 	if nn < 4 {
-		nn = 4;
+		nn = 4
 	}
 	if nn > len(d.buf) {
-		nn = len(d.buf);
+		nn = len(d.buf)
 	}
 	nn, d.err = io.ReadAtLeast(d.r, d.buf[d.nbuf : nn], 4 - d.nbuf);
 	d.nbuf += nn;
 	if d.nbuf < 4 {
-		return 0, d.err;
+		return 0, d.err
 	}
 
 	// Decode chunk into p, or d.out and then p if p is too small.
@@ -307,22 +307,22 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 		n = bytes.Copy(p, d.out);
 		d.out = d.out[n:len(d.out)];
 	} else {
-		n, d.end, d.err = d.enc.decode(p, d.buf[0:nr]);
+		n, d.end, d.err = d.enc.decode(p, d.buf[0:nr])
 	}
 	d.nbuf -= nr;
 	for i := 0; i < d.nbuf; i++ {
-		d.buf[i] = d.buf[i+nr];
+		d.buf[i] = d.buf[i+nr]
 	}
 
 	if d.err == nil {
-		d.err = err;
+		d.err = err
 	}
 	return n, d.err;
 }
 
 // NewDecoder constructs a new base64 stream decoder.
 func NewDecoder(enc *Encoding, r io.Reader) io.Reader {
-	return &decoder{enc: enc, r: r};
+	return &decoder{enc: enc, r: r}
 }
 
 // DecodeLen returns the maximum length in bytes of the decoded data
diff --git a/src/pkg/encoding/base64/base64_test.go b/src/pkg/encoding/base64/base64_test.go
index 8cd7e875fe..2eb658bacb 100644
--- a/src/pkg/encoding/base64/base64_test.go
+++ b/src/pkg/encoding/base64/base64_test.go
@@ -85,7 +85,7 @@ func TestEncoderBuffering(t *testing.T) {
 		for pos := 0; pos < len(input); pos += bs {
 			end := pos+bs;
 			if end > len(input) {
-				end = len(input);
+				end = len(input)
 			}
 			n, err := encoder.Write(input[pos:end]);
 			testEqual(t, "Write(%q) gave error %v, want %v", input[pos:end], err, os.Error(nil));
@@ -104,7 +104,7 @@ func TestDecode(t *testing.T) {
 		testEqual(t, "Decode(%q) = error %v, want %v", p.encoded, err, os.Error(nil));
 		testEqual(t, "Decode(%q) = length %v, want %v", p.encoded, count, len(p.decoded));
 		if len(p.encoded) > 0 {
-			testEqual(t, "Decode(%q) = end %v, want %v", p.encoded, end, (p.encoded[len(p.encoded)-1] == '='));
+			testEqual(t, "Decode(%q) = end %v, want %v", p.encoded, end, (p.encoded[len(p.encoded)-1] == '='))
 		}
 		testEqual(t, "Decode(%q) = %q, want %q", p.encoded, string(dbuf[0:count]), p.decoded);
 	}
@@ -116,12 +116,12 @@ func TestDecoder(t *testing.T) {
 		dbuf := make([]byte, StdEncoding.DecodedLen(len(p.encoded)));
 		count, err := decoder.Read(dbuf);
 		if err != nil && err != os.EOF {
-			t.Fatal("Read failed", err);
+			t.Fatal("Read failed", err)
 		}
 		testEqual(t, "Read from %q = length %v, want %v", p.encoded, count, len(p.decoded));
 		testEqual(t, "Decoding of %q = %q, want %q", p.encoded, string(dbuf[0:count]), p.decoded);
 		if err != os.EOF {
-			count, err = decoder.Read(dbuf);
+			count, err = decoder.Read(dbuf)
 		}
 		testEqual(t, "Read from %q = %v, want %v", p.encoded, err, os.EOF);
 	}
@@ -160,9 +160,9 @@ func TestDecodeCorrupt(t *testing.T) {
 		_, err := StdEncoding.Decode(dbuf, strings.Bytes(e.e));
 		switch err := err.(type) {
 		case CorruptInputError:
-			testEqual(t, "Corruption in %q at offset %v, want %v", e.e, int(err), e.p);
+			testEqual(t, "Corruption in %q at offset %v, want %v", e.e, int(err), e.p)
 		default:
-			t.Error("Decoder failed to detect corruption in", e);
+			t.Error("Decoder failed to detect corruption in", e)
 		}
 	}
 }
@@ -172,28 +172,28 @@ func TestBig(t *testing.T) {
 	raw := make([]byte, n);
 	const alpha = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
 	for i := 0; i < n; i++ {
-		raw[i] = alpha[i%len(alpha)];
+		raw[i] = alpha[i%len(alpha)]
 	}
 	encoded := new(bytes.Buffer);
 	w := NewEncoder(StdEncoding, encoded);
 	nn, err := w.Write(raw);
 	if nn != n || err != nil {
-		t.Fatalf("Encoder.Write(raw) = %d, %v want %d, nil", nn, err, n);
+		t.Fatalf("Encoder.Write(raw) = %d, %v want %d, nil", nn, err, n)
 	}
 	err = w.Close();
 	if err != nil {
-		t.Fatalf("Encoder.Close() = %v want nil", err);
+		t.Fatalf("Encoder.Close() = %v want nil", err)
 	}
 	decoded, err := io.ReadAll(NewDecoder(StdEncoding, encoded));
 	if err != nil {
-		t.Fatalf("io.ReadAll(NewDecoder(...)): %v", err);
+		t.Fatalf("io.ReadAll(NewDecoder(...)): %v", err)
 	}
 
 	if !bytes.Equal(raw, decoded) {
 		var i int;
 		for i = 0; i < len(decoded) && i < len(raw); i++ {
 			if decoded[i] != raw[i] {
-				break;
+				break
 			}
 		}
 		t.Errorf("Decode(Encode(%d-byte string)) failed at offset %d", n, i);
diff --git a/src/pkg/encoding/binary/binary.go b/src/pkg/encoding/binary/binary.go
index 6907fa02cd..62d42a6b8c 100644
--- a/src/pkg/encoding/binary/binary.go
+++ b/src/pkg/encoding/binary/binary.go
@@ -42,7 +42,7 @@ func (littleEndian) PutUint16(b []byte, v uint16) {
 }
 
 func (littleEndian) Uint32(b []byte) uint32 {
-	return uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24;
+	return uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24
 }
 
 func (littleEndian) PutUint32(b []byte, v uint32) {
@@ -54,7 +54,7 @@ func (littleEndian) PutUint32(b []byte, v uint32) {
 
 func (littleEndian) Uint64(b []byte) uint64 {
 	return uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 |
-		uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56;
+		uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56
 }
 
 func (littleEndian) PutUint64(b []byte, v uint64) {
@@ -82,7 +82,7 @@ func (bigEndian) PutUint16(b []byte, v uint16) {
 }
 
 func (bigEndian) Uint32(b []byte) uint32 {
-	return uint32(b[3]) | uint32(b[2])<<8 | uint32(b[1])<<16 | uint32(b[0])<<24;
+	return uint32(b[3]) | uint32(b[2])<<8 | uint32(b[1])<<16 | uint32(b[0])<<24
 }
 
 func (bigEndian) PutUint32(b []byte, v uint32) {
@@ -94,7 +94,7 @@ func (bigEndian) PutUint32(b []byte, v uint32) {
 
 func (bigEndian) Uint64(b []byte) uint64 {
 	return uint64(b[7]) | uint64(b[6])<<8 | uint64(b[5])<<16 | uint64(b[4])<<24 |
-		uint64(b[3])<<32 | uint64(b[2])<<40 | uint64(b[1])<<48 | uint64(b[0])<<56;
+		uint64(b[3])<<32 | uint64(b[2])<<40 | uint64(b[1])<<48 | uint64(b[0])<<56
 }
 
 func (bigEndian) PutUint64(b []byte, v uint64) {
@@ -123,11 +123,11 @@ func Read(r io.Reader, order ByteOrder, data interface{}) os.Error {
 	v := reflect.NewValue(data).(*reflect.PtrValue).Elem();
 	size := sizeof(v.Type());
 	if size < 0 {
-		return os.NewError("binary.Read: invalid type " + v.Type().String());
+		return os.NewError("binary.Read: invalid type " + v.Type().String())
 	}
 	d := &decoder{order: order, buf: make([]byte, size)};
 	if _, err := io.ReadFull(r, d.buf); err != nil {
-		return err;
+		return err
 	}
 	d.value(v);
 	return nil;
@@ -138,7 +138,7 @@ func sizeof(t reflect.Type) int {
 	case *reflect.ArrayType:
 		n := sizeof(t.Elem());
 		if n < 0 {
-			return -1;
+			return -1
 		}
 		return t.Len() * n;
 
@@ -147,32 +147,32 @@ func sizeof(t reflect.Type) int {
 		for i, n := 0, t.NumField(); i < n; i++ {
 			s := sizeof(t.Field(i).Type);
 			if s < 0 {
-				return -1;
+				return -1
 			}
 			sum += s;
 		}
 		return sum;
 
 	case *reflect.Uint8Type:
-		return 1;
+		return 1
 	case *reflect.Uint16Type:
-		return 2;
+		return 2
 	case *reflect.Uint32Type:
-		return 4;
+		return 4
 	case *reflect.Uint64Type:
-		return 8;
+		return 8
 	case *reflect.Int8Type:
-		return 1;
+		return 1
 	case *reflect.Int16Type:
-		return 2;
+		return 2
 	case *reflect.Int32Type:
-		return 4;
+		return 4
 	case *reflect.Int64Type:
-		return 8;
+		return 8
 	case *reflect.Float32Type:
-		return 4;
+		return 4
 	case *reflect.Float64Type:
-		return 8;
+		return 8
 	}
 	return -1;
 }
@@ -219,33 +219,33 @@ func (d *decoder) value(v reflect.Value) {
 	case *reflect.ArrayValue:
 		l := v.Len();
 		for i := 0; i < l; i++ {
-			d.value(v.Elem(i));
+			d.value(v.Elem(i))
 		}
 	case *reflect.StructValue:
 		l := v.NumField();
 		for i := 0; i < l; i++ {
-			d.value(v.Field(i));
+			d.value(v.Field(i))
 		}
 
 	case *reflect.Uint8Value:
-		v.Set(d.uint8());
+		v.Set(d.uint8())
 	case *reflect.Uint16Value:
-		v.Set(d.uint16());
+		v.Set(d.uint16())
 	case *reflect.Uint32Value:
-		v.Set(d.uint32());
+		v.Set(d.uint32())
 	case *reflect.Uint64Value:
-		v.Set(d.uint64());
+		v.Set(d.uint64())
 	case *reflect.Int8Value:
-		v.Set(d.int8());
+		v.Set(d.int8())
 	case *reflect.Int16Value:
-		v.Set(d.int16());
+		v.Set(d.int16())
 	case *reflect.Int32Value:
-		v.Set(d.int32());
+		v.Set(d.int32())
 	case *reflect.Int64Value:
-		v.Set(d.int64());
+		v.Set(d.int64())
 	case *reflect.Float32Value:
-		v.Set(math.Float32frombits(d.uint32()));
+		v.Set(math.Float32frombits(d.uint32()))
 	case *reflect.Float64Value:
-		v.Set(math.Float64frombits(d.uint64()));
+		v.Set(math.Float64frombits(d.uint64()))
 	}
 }
diff --git a/src/pkg/encoding/binary/binary_test.go b/src/pkg/encoding/binary/binary_test.go
index a04684b72b..078a13a530 100644
--- a/src/pkg/encoding/binary/binary_test.go
+++ b/src/pkg/encoding/binary/binary_test.go
@@ -72,15 +72,15 @@ func TestRead(t *testing.T) {
 		goto little;
 	}
 	if !reflect.DeepEqual(sb, s) {
-		t.Errorf("Read big-endian:\n\thave %+v\n\twant %+v", sb, s);
+		t.Errorf("Read big-endian:\n\thave %+v\n\twant %+v", sb, s)
 	}
 
 little:
 	err = Read(bytes.NewBuffer(little), LittleEndian, &sl);
 	if err != nil {
-		t.Errorf("Read little-endian: %v", err);
+		t.Errorf("Read little-endian: %v", err)
 	}
 	if !reflect.DeepEqual(sl, s) {
-		t.Errorf("Read big-endian:\n\thave %+v\n\twant %+v", sl, s);
+		t.Errorf("Read big-endian:\n\thave %+v\n\twant %+v", sl, s)
 	}
 }
diff --git a/src/pkg/encoding/git85/git.go b/src/pkg/encoding/git85/git.go
index e49251fb3a..d9c72e83c1 100644
--- a/src/pkg/encoding/git85/git.go
+++ b/src/pkg/encoding/git85/git.go
@@ -16,7 +16,7 @@ import (
 type CorruptInputError int64
 
 func (e CorruptInputError) String() string {
-	return "illegal git85 data at input byte" + strconv.Itoa64(int64(e));
+	return "illegal git85 data at input byte" + strconv.Itoa64(int64(e))
 }
 
 const encode = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~"
@@ -53,18 +53,18 @@ func Encode(dst, src []byte) int {
 	for len(src) > 0 {
 		n := len(src);
 		if n > 52 {
-			n = 52;
+			n = 52
 		}
 		if n <= 27 {
-			dst[ndst] = byte('A'+n-1);
+			dst[ndst] = byte('A'+n-1)
 		} else {
-			dst[ndst] = byte('a'+n-26-1);
+			dst[ndst] = byte('a'+n-26-1)
 		}
 		ndst++;
 		for i := 0; i < n; i += 4 {
 			var v uint32;
 			for j := 0; j < 4 && i+j < n; j++ {
-				v |= uint32(src[i+j])<<uint(24 - j*8);
+				v |= uint32(src[i+j])<<uint(24 - j*8)
 			}
 			for j := 4; j >= 0; j-- {
 				dst[ndst+j] = encode[v%85];
@@ -82,7 +82,7 @@ func Encode(dst, src []byte) int {
 // EncodedLen returns the length of an encoding of n source bytes.
 func EncodedLen(n int) int {
 	if n == 0 {
-		return 0;
+		return 0
 	}
 	// 5 bytes per 4 bytes of input, rounded up.
 	// 2 extra bytes for each line of 52 src bytes, rounded up.
@@ -103,18 +103,18 @@ func Decode(dst, src []byte) (n int, err os.Error) {
 		var l int;
 		switch ch := int(src[nsrc]); {
 		case 'A' <= ch && ch <= 'Z':
-			l = ch-'A'+1;
+			l = ch-'A'+1
 		case 'a' <= ch && ch <= 'z':
-			l = ch-'a'+26+1;
+			l = ch-'a'+26+1
 		default:
-			return ndst, CorruptInputError(nsrc);
+			return ndst, CorruptInputError(nsrc)
 		}
 		if nsrc+1+l > len(src) {
-			return ndst, CorruptInputError(nsrc);
+			return ndst, CorruptInputError(nsrc)
 		}
 		el := (l+3)/4*5;	// encoded len
 		if nsrc+1+el+1 > len(src) || src[nsrc+1+el] != '\n' {
-			return ndst, CorruptInputError(nsrc);
+			return ndst, CorruptInputError(nsrc)
 		}
 		line := src[nsrc+1 : nsrc+1+el];
 		for i := 0; i < el; i += 5 {
@@ -122,7 +122,7 @@ func Decode(dst, src []byte) (n int, err os.Error) {
 			for j := 0; j < 5; j++ {
 				ch := decode[line[i+j]];
 				if ch == 0 {
-					return ndst, CorruptInputError(nsrc+1+i+j);
+					return ndst, CorruptInputError(nsrc+1+i+j)
 				}
 				v = v*85 + uint32(ch-1);
 			}
@@ -135,7 +135,7 @@ func Decode(dst, src []byte) (n int, err os.Error) {
 		// Last fragment may have run too far (but there was room in dst).
 		// Back up.
 		if l%4 != 0 {
-			ndst -= 4 - l%4;
+			ndst -= 4 - l%4
 		}
 		nsrc += 1+el+1;
 	}
@@ -162,7 +162,7 @@ type encoder struct {
 
 func (e *encoder) Write(p []byte) (n int, err os.Error) {
 	if e.err != nil {
-		return 0, e.err;
+		return 0, e.err
 	}
 
 	// Leading fringe.
@@ -175,11 +175,11 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 		n += i;
 		p = p[i:len(p)];
 		if e.nbuf < 52 {
-			return;
+			return
 		}
 		nout := Encode(&e.out, &e.buf);
 		if _, e.err = e.w.Write(e.out[0:nout]); e.err != nil {
-			return n, e.err;
+			return n, e.err
 		}
 		e.nbuf = 0;
 	}
@@ -188,12 +188,12 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 	for len(p) >= 52 {
 		nn := len(e.out)/(1 + 52/4*5 + 1)*52;
 		if nn > len(p) {
-			nn = len(p)/52*52;
+			nn = len(p)/52*52
 		}
 		if nn > 0 {
 			nout := Encode(&e.out, p[0:nn]);
 			if _, e.err = e.w.Write(e.out[0:nout]); e.err != nil {
-				return n, e.err;
+				return n, e.err
 			}
 		}
 		n += nn;
@@ -202,7 +202,7 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 
 	// Trailing fringe.
 	for i := 0; i < len(p); i++ {
-		e.buf[i] = p[i];
+		e.buf[i] = p[i]
 	}
 	e.nbuf = len(p);
 	n += len(p);
@@ -235,7 +235,7 @@ type decoder struct {
 
 func (d *decoder) Read(p []byte) (n int, err os.Error) {
 	if len(p) == 0 {
-		return 0, nil;
+		return 0, nil
 	}
 
 	for {
@@ -248,7 +248,7 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 
 		// Out of decoded output.  Check errors.
 		if d.err != nil {
-			return 0, d.err;
+			return 0, d.err
 		}
 		if d.readErr != nil {
 			d.err = d.readErr;
@@ -263,11 +263,11 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 		// Send complete lines to Decode.
 		nl := bytes.LastIndex(d.buf[0 : d.nbuf], newline);
 		if nl < 0 {
-			continue;
+			continue
 		}
 		nn, d.err = Decode(&d.outbuf, d.buf[0 : nl+1]);
 		if e, ok := d.err.(CorruptInputError); ok {
-			d.err = CorruptInputError(int64(e) + d.off);
+			d.err = CorruptInputError(int64(e) + d.off)
 		}
 		d.out = d.outbuf[0:nn];
 		d.nbuf = bytes.Copy(&d.buf, d.buf[nl+1 : d.nbuf]);
diff --git a/src/pkg/encoding/git85/git_test.go b/src/pkg/encoding/git85/git_test.go
index fbe675e811..d956ed4ae9 100644
--- a/src/pkg/encoding/git85/git_test.go
+++ b/src/pkg/encoding/git85/git_test.go
@@ -32,13 +32,13 @@ func TestGitTable(t *testing.T) {
 	var saw [256]bool;
 	for i, c := range encode {
 		if decode[c] != uint8(i+1) {
-			t.Errorf("decode['%c'] = %d, want %d", c, decode[c], i+1);
+			t.Errorf("decode['%c'] = %d, want %d", c, decode[c], i+1)
 		}
 		saw[c] = true;
 	}
 	for i, b := range saw {
 		if !b && decode[i] != 0 {
-			t.Errorf("decode[%d] = %d, want 0", i, decode[i]);
+			t.Errorf("decode[%d] = %d, want 0", i, decode[i])
 		}
 	}
 }
@@ -67,7 +67,7 @@ func TestEncode(t *testing.T) {
 		buf := make([]byte, EncodedLen(len(p.decoded)));
 		n := Encode(buf, strings.Bytes(p.decoded));
 		if n != len(buf) {
-			t.Errorf("EncodedLen does not agree with Encode");
+			t.Errorf("EncodedLen does not agree with Encode")
 		}
 		buf = buf[0:n];
 		testEqual(t, "Encode(%q) = %q, want %q", p.decoded, string(buf), p.encoded);
@@ -92,7 +92,7 @@ func TestEncoderBuffering(t *testing.T) {
 		for pos := 0; pos < len(input); pos += bs {
 			end := pos+bs;
 			if end > len(input) {
-				end = len(input);
+				end = len(input)
 			}
 			n, err := encoder.Write(input[pos:end]);
 			testEqual(t, "Write(%q) gave error %v, want %v", input[pos:end], err, os.Error(nil));
@@ -119,12 +119,12 @@ func TestDecoder(t *testing.T) {
 		decoder := NewDecoder(bytes.NewBufferString(p.encoded));
 		dbuf, err := io.ReadAll(decoder);
 		if err != nil {
-			t.Fatal("Read failed", err);
+			t.Fatal("Read failed", err)
 		}
 		testEqual(t, "Read from %q = length %v, want %v", p.encoded, len(dbuf), len(p.decoded));
 		testEqual(t, "Decoding of %q = %q, want %q", p.encoded, string(dbuf), p.decoded);
 		if err != nil {
-			testEqual(t, "Read from %q = %v, want %v", p.encoded, err, os.EOF);
+			testEqual(t, "Read from %q = %v, want %v", p.encoded, err, os.EOF)
 		}
 	}
 }
@@ -158,9 +158,9 @@ func TestDecodeCorrupt(t *testing.T) {
 		_, err := Decode(dbuf, strings.Bytes(e.e));
 		switch err := err.(type) {
 		case CorruptInputError:
-			testEqual(t, "Corruption in %q at offset %v, want %v", e.e, int(err), e.p);
+			testEqual(t, "Corruption in %q at offset %v, want %v", e.e, int(err), e.p)
 		default:
-			t.Error("Decoder failed to detect corruption in", e);
+			t.Error("Decoder failed to detect corruption in", e)
 		}
 	}
 }
@@ -170,28 +170,28 @@ func TestGitBig(t *testing.T) {
 	raw := make([]byte, n);
 	const alpha = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
 	for i := 0; i < n; i++ {
-		raw[i] = alpha[i%len(alpha)];
+		raw[i] = alpha[i%len(alpha)]
 	}
 	encoded := new(bytes.Buffer);
 	w := NewEncoder(encoded);
 	nn, err := w.Write(raw);
 	if nn != n || err != nil {
-		t.Fatalf("Encoder.Write(raw) = %d, %v want %d, nil", nn, err, n);
+		t.Fatalf("Encoder.Write(raw) = %d, %v want %d, nil", nn, err, n)
 	}
 	err = w.Close();
 	if err != nil {
-		t.Fatalf("Encoder.Close() = %v want nil", err);
+		t.Fatalf("Encoder.Close() = %v want nil", err)
 	}
 	decoded, err := io.ReadAll(NewDecoder(encoded));
 	if err != nil {
-		t.Fatalf("io.ReadAll(NewDecoder(...)): %v", err);
+		t.Fatalf("io.ReadAll(NewDecoder(...)): %v", err)
 	}
 
 	if !bytes.Equal(raw, decoded) {
 		var i int;
 		for i = 0; i < len(decoded) && i < len(raw); i++ {
 			if decoded[i] != raw[i] {
-				break;
+				break
 			}
 		}
 		t.Errorf("Decode(Encode(%d-byte string)) failed at offset %d", n, i);
diff --git a/src/pkg/encoding/hex/hex.go b/src/pkg/encoding/hex/hex.go
index ff55dd489a..d97723db1f 100644
--- a/src/pkg/encoding/hex/hex.go
+++ b/src/pkg/encoding/hex/hex.go
@@ -38,7 +38,7 @@ func (OddLengthInputError) String() string	{ return "odd length hex string" }
 type InvalidHexCharError byte
 
 func (e InvalidHexCharError) String() string {
-	return "invalid hex char: " + strconv.Itoa(int(e));
+	return "invalid hex char: " + strconv.Itoa(int(e))
 }
 
 
@@ -51,17 +51,17 @@ func DecodedLen(x int) int	{ return x/2 }
 // InvalidHexCharError.
 func Decode(dst, src []byte) (int, os.Error) {
 	if len(src)%2 == 1 {
-		return 0, OddLengthInputError{};
+		return 0, OddLengthInputError{}
 	}
 
 	for i := 0; i < len(src)/2; i++ {
 		a, ok := fromHexChar(src[i*2]);
 		if !ok {
-			return 0, InvalidHexCharError(src[i*2]);
+			return 0, InvalidHexCharError(src[i*2])
 		}
 		b, ok := fromHexChar(src[i*2 + 1]);
 		if !ok {
-			return 0, InvalidHexCharError(src[i*2 + 1]);
+			return 0, InvalidHexCharError(src[i*2 + 1])
 		}
 		dst[i] = (a<<4)|b;
 	}
@@ -73,11 +73,11 @@ func Decode(dst, src []byte) (int, os.Error) {
 func fromHexChar(c byte) (byte, bool) {
 	switch {
 	case 0 <= c && c <= '9':
-		return c-'0', true;
+		return c-'0', true
 	case 'a' <= c && c <= 'f':
-		return c-'a'+10, true;
+		return c-'a'+10, true
 	case 'A' <= c && c <= 'F':
-		return c-'A'+10, true;
+		return c-'A'+10, true
 	}
 
 	return 0, false;
@@ -96,7 +96,7 @@ func DecodeString(s string) ([]byte, os.Error) {
 	dst := make([]byte, DecodedLen(len(src)));
 	_, err := Decode(dst, src);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	return dst, nil;
 }
diff --git a/src/pkg/encoding/hex/hex_test.go b/src/pkg/encoding/hex/hex_test.go
index e1dd4c57c2..e409dbd1e5 100644
--- a/src/pkg/encoding/hex/hex_test.go
+++ b/src/pkg/encoding/hex/hex_test.go
@@ -41,10 +41,10 @@ func TestEncode(t *testing.T) {
 		dst := make([]byte, EncodedLen(len(test.in)));
 		n := Encode(dst, test.in);
 		if n != len(dst) {
-			t.Errorf("#%d: bad return value: got: %d want: %d", i, n, len(dst));
+			t.Errorf("#%d: bad return value: got: %d want: %d", i, n, len(dst))
 		}
 		if bytes.Compare(dst, test.out) != 0 {
-			t.Errorf("#%d: got: %#v want: %#v", i, dst, test.out);
+			t.Errorf("#%d: got: %#v want: %#v", i, dst, test.out)
 		}
 	}
 }
@@ -87,13 +87,13 @@ func TestDecode(t *testing.T) {
 		dst := make([]byte, DecodedLen(len(test.in)));
 		n, err := Decode(dst, test.in);
 		if err == nil && n != len(dst) {
-			t.Errorf("#%d: bad return value: got:%d want:%d", i, n, len(dst));
+			t.Errorf("#%d: bad return value: got:%d want:%d", i, n, len(dst))
 		}
 		if test.ok != (err == nil) {
-			t.Errorf("#%d: unexpected err value: %s", i, err);
+			t.Errorf("#%d: unexpected err value: %s", i, err)
 		}
 		if err == nil && bytes.Compare(dst, test.out) != 0 {
-			t.Errorf("#%d: got: %#v want: %#v", i, dst, test.out);
+			t.Errorf("#%d: got: %#v want: %#v", i, dst, test.out)
 		}
 	}
 }
@@ -114,7 +114,7 @@ func TestEncodeToString(t *testing.T) {
 	for i, test := range encodeStringTests {
 		s := EncodeToString(test.in);
 		if s != test.out {
-			t.Errorf("#%d got:%s want:%s", i, s, test.out);
+			t.Errorf("#%d got:%s want:%s", i, s, test.out)
 		}
 	}
 }
@@ -138,10 +138,10 @@ func TestDecodeString(t *testing.T) {
 	for i, test := range decodeStringTests {
 		dst, err := DecodeString(test.in);
 		if test.ok != (err == nil) {
-			t.Errorf("#%d: unexpected err value: %s", i, err);
+			t.Errorf("#%d: unexpected err value: %s", i, err)
 		}
 		if err == nil && bytes.Compare(dst, test.out) != 0 {
-			t.Errorf("#%d: got: %#v want: #%v", i, dst, test.out);
+			t.Errorf("#%d: got: %#v want: #%v", i, dst, test.out)
 		}
 	}
 }
diff --git a/src/pkg/encoding/pem/pem.go b/src/pkg/encoding/pem/pem.go
index c33c39b759..640673b3e8 100644
--- a/src/pkg/encoding/pem/pem.go
+++ b/src/pkg/encoding/pem/pem.go
@@ -40,7 +40,7 @@ func getLine(data []byte) (line, rest []byte) {
 	} else {
 		j = i+1;
 		if i > 0 && data[i-1] == '\r' {
-			i--;
+			i--
 		}
 	}
 	return data[0:i], data[j:len(data)];
@@ -54,7 +54,7 @@ func removeWhitespace(data []byte) []byte {
 
 	for _, b := range data {
 		if b == ' ' || b == '\t' || b == '\r' || b == '\n' {
-			continue;
+			continue
 		}
 		result[n] = b;
 		n++;
@@ -76,16 +76,16 @@ func Decode(data []byte) (p *Block, rest []byte) {
 	// the byte array, we'll accept the start string without it.
 	rest = data;
 	if bytes.HasPrefix(data, pemStart[1:len(pemStart)]) {
-		rest = rest[len(pemStart)-1 : len(data)];
+		rest = rest[len(pemStart)-1 : len(data)]
 	} else if i := bytes.Index(data, pemStart); i >= 0 {
-		rest = rest[i+len(pemStart) : len(data)];
+		rest = rest[i+len(pemStart) : len(data)]
 	} else {
-		return nil, data;
+		return nil, data
 	}
 
 	typeLine, rest := getLine(rest);
 	if !bytes.HasSuffix(typeLine, pemEndOfLine) {
-		goto Error;
+		goto Error
 	}
 	typeLine = typeLine[0 : len(typeLine)-len(pemEndOfLine)];
 
@@ -98,13 +98,13 @@ func Decode(data []byte) (p *Block, rest []byte) {
 		// This loop terminates because getLine's second result is
 		// always smaller than it's argument.
 		if len(rest) == 0 {
-			return nil, data;
+			return nil, data
 		}
 		line, next := getLine(rest);
 
 		i := bytes.Index(line, []byte{':'});
 		if i == -1 {
-			break;
+			break
 		}
 
 		// TODO(agl): need to cope with values that spread across lines.
@@ -117,14 +117,14 @@ func Decode(data []byte) (p *Block, rest []byte) {
 
 	i := bytes.Index(rest, pemEnd);
 	if i < 0 {
-		goto Error;
+		goto Error
 	}
 	base64Data := removeWhitespace(rest[0:i]);
 
 	p.Bytes = make([]byte, base64.StdEncoding.DecodedLen(len(base64Data)));
 	n, err := base64.StdEncoding.Decode(p.Bytes, base64Data);
 	if err != nil {
-		goto Error;
+		goto Error
 	}
 	p.Bytes = p.Bytes[0:n];
 
@@ -155,7 +155,7 @@ Error:
 	// and now will try again, using the second BEGIN line.
 	p, rest = Decode(rest);
 	if p == nil {
-		rest = data;
+		rest = data
 	}
 	return;
 }
diff --git a/src/pkg/encoding/pem/pem_test.go b/src/pkg/encoding/pem/pem_test.go
index dad29ac4c4..262dadd373 100644
--- a/src/pkg/encoding/pem/pem_test.go
+++ b/src/pkg/encoding/pem/pem_test.go
@@ -29,7 +29,7 @@ func TestGetLine(t *testing.T) {
 	for i, test := range getLineTests {
 		x, y := getLine(strings.Bytes(test.in));
 		if string(x) != test.out1 || string(y) != test.out2 {
-			t.Errorf("#%d got:%+v,%+v want:%s,%s", i, x, y, test.out1, test.out2);
+			t.Errorf("#%d got:%+v,%+v want:%s,%s", i, x, y, test.out1, test.out2)
 		}
 	}
 }
@@ -37,15 +37,15 @@ func TestGetLine(t *testing.T) {
 func TestDecode(t *testing.T) {
 	result, remainder := Decode(strings.Bytes(pemData));
 	if !reflect.DeepEqual(result, certificate) {
-		t.Errorf("#0 got:%#v want:%#v", result, certificate);
+		t.Errorf("#0 got:%#v want:%#v", result, certificate)
 	}
 	result, remainder = Decode(remainder);
 	if !reflect.DeepEqual(result, privateKey) {
-		t.Errorf("#1 got:%#v want:%#v", result, privateKey);
+		t.Errorf("#1 got:%#v want:%#v", result, privateKey)
 	}
 	result, _ = Decode(strings.Bytes(pemPrivateKey));
 	if !reflect.DeepEqual(result, privateKey2) {
-		t.Errorf("#2 got:%#v want:%#v", result, privateKey2);
+		t.Errorf("#2 got:%#v want:%#v", result, privateKey2)
 	}
 }
 
diff --git a/src/pkg/exec/exec.go b/src/pkg/exec/exec.go
index fc68561223..5f5c33c573 100644
--- a/src/pkg/exec/exec.go
+++ b/src/pkg/exec/exec.go
@@ -37,26 +37,26 @@ func modeToFiles(mode, fd int) (*os.File, *os.File, os.Error) {
 	case DevNull:
 		rw := os.O_WRONLY;
 		if fd == 0 {
-			rw = os.O_RDONLY;
+			rw = os.O_RDONLY
 		}
 		f, err := os.Open("/dev/null", rw, 0);
 		return f, nil, err;
 	case PassThrough:
 		switch fd {
 		case 0:
-			return os.Stdin, nil, nil;
+			return os.Stdin, nil, nil
 		case 1:
-			return os.Stdout, nil, nil;
+			return os.Stdout, nil, nil
 		case 2:
-			return os.Stderr, nil, nil;
+			return os.Stderr, nil, nil
 		}
 	case Pipe:
 		r, w, err := os.Pipe();
 		if err != nil {
-			return nil, nil, err;
+			return nil, nil, err
 		}
 		if fd == 0 {
-			return r, w, nil;
+			return r, w, nil
 		}
 		return w, r, nil;
 	}
@@ -83,51 +83,51 @@ func Run(argv0 string, argv, envv []string, stdin, stdout, stderr int) (p *Cmd,
 	var fd [3]*os.File;
 
 	if fd[0], p.Stdin, err = modeToFiles(stdin, 0); err != nil {
-		goto Error;
+		goto Error
 	}
 	if fd[1], p.Stdout, err = modeToFiles(stdout, 1); err != nil {
-		goto Error;
+		goto Error
 	}
 	if stderr == MergeWithStdout {
-		p.Stderr = p.Stdout;
+		p.Stderr = p.Stdout
 	} else if fd[2], p.Stderr, err = modeToFiles(stderr, 2); err != nil {
-		goto Error;
+		goto Error
 	}
 
 	// Run command.
 	p.Pid, err = os.ForkExec(argv0, argv, envv, "", &fd);
 	if err != nil {
-		goto Error;
+		goto Error
 	}
 	if fd[0] != os.Stdin {
-		fd[0].Close();
+		fd[0].Close()
 	}
 	if fd[1] != os.Stdout {
-		fd[1].Close();
+		fd[1].Close()
 	}
 	if fd[2] != os.Stderr && fd[2] != fd[1] {
-		fd[2].Close();
+		fd[2].Close()
 	}
 	return p, nil;
 
 Error:
 	if fd[0] != os.Stdin && fd[0] != nil {
-		fd[0].Close();
+		fd[0].Close()
 	}
 	if fd[1] != os.Stdout && fd[1] != nil {
-		fd[1].Close();
+		fd[1].Close()
 	}
 	if fd[2] != os.Stderr && fd[2] != nil && fd[2] != fd[1] {
-		fd[2].Close();
+		fd[2].Close()
 	}
 	if p.Stdin != nil {
-		p.Stdin.Close();
+		p.Stdin.Close()
 	}
 	if p.Stdout != nil {
-		p.Stdout.Close();
+		p.Stdout.Close()
 	}
 	if p.Stderr != nil {
-		p.Stderr.Close();
+		p.Stderr.Close()
 	}
 	return nil, err;
 }
@@ -140,11 +140,11 @@ Error:
 // process events; see package os for details.
 func (p *Cmd) Wait(options int) (*os.Waitmsg, os.Error) {
 	if p.Pid <= 0 {
-		return nil, os.ErrorString("exec: invalid use of Cmd.Wait");
+		return nil, os.ErrorString("exec: invalid use of Cmd.Wait")
 	}
 	w, err := os.Wait(p.Pid, options);
 	if w != nil && (w.Exited() || w.Signaled()) {
-		p.Pid = -1;
+		p.Pid = -1
 	}
 	return w, err;
 }
@@ -159,7 +159,7 @@ func (p *Cmd) Close() os.Error {
 		// caller has already waited for pid.
 		_, err := p.Wait(0);
 		for err == os.EINTR {
-			_, err = p.Wait(0);
+			_, err = p.Wait(0)
 		}
 	}
 
@@ -167,17 +167,17 @@ func (p *Cmd) Close() os.Error {
 	var err os.Error;
 	if p.Stdin != nil && p.Stdin.Fd() >= 0 {
 		if err1 := p.Stdin.Close(); err1 != nil {
-			err = err1;
+			err = err1
 		}
 	}
 	if p.Stdout != nil && p.Stdout.Fd() >= 0 {
 		if err1 := p.Stdout.Close(); err1 != nil && err != nil {
-			err = err1;
+			err = err1
 		}
 	}
 	if p.Stderr != nil && p.Stderr != p.Stdout && p.Stderr.Fd() >= 0 {
 		if err1 := p.Stderr.Close(); err1 != nil && err != nil {
-			err = err1;
+			err = err1
 		}
 	}
 	return err;
@@ -186,7 +186,7 @@ func (p *Cmd) Close() os.Error {
 func canExec(file string) bool {
 	d, err := os.Stat(file);
 	if err != nil {
-		return false;
+		return false
 	}
 	return d.IsRegular() && d.Permission() & 0111 != 0;
 }
@@ -203,7 +203,7 @@ func LookPath(file string) (string, os.Error) {
 
 	if strings.Index(file, "/") >= 0 {
 		if canExec(file) {
-			return file, nil;
+			return file, nil
 		}
 		return "", os.ENOENT;
 	}
@@ -211,10 +211,10 @@ func LookPath(file string) (string, os.Error) {
 	for _, dir := range strings.Split(pathenv, ":", 0) {
 		if dir == "" {
 			// Unix shell semantics: path element "" means "."
-			dir = ".";
+			dir = "."
 		}
 		if canExec(dir+"/"+file) {
-			return dir+"/"+file, nil;
+			return dir+"/"+file, nil
 		}
 	}
 	return "", os.ENOENT;
diff --git a/src/pkg/exec/exec_test.go b/src/pkg/exec/exec_test.go
index d5585029eb..af86b55a02 100644
--- a/src/pkg/exec/exec_test.go
+++ b/src/pkg/exec/exec_test.go
@@ -13,19 +13,19 @@ func TestRunCat(t *testing.T) {
 	cmd, err := Run("/bin/cat", []string{"cat"}, nil,
 		Pipe, Pipe, DevNull);
 	if err != nil {
-		t.Fatalf("opencmd /bin/cat: %v", err);
+		t.Fatalf("opencmd /bin/cat: %v", err)
 	}
 	io.WriteString(cmd.Stdin, "hello, world\n");
 	cmd.Stdin.Close();
 	buf, err := io.ReadAll(cmd.Stdout);
 	if err != nil {
-		t.Fatalf("reading from /bin/cat: %v", err);
+		t.Fatalf("reading from /bin/cat: %v", err)
 	}
 	if string(buf) != "hello, world\n" {
-		t.Fatalf("reading from /bin/cat: got %q", buf);
+		t.Fatalf("reading from /bin/cat: got %q", buf)
 	}
 	if err = cmd.Close(); err != nil {
-		t.Fatalf("closing /bin/cat: %v", err);
+		t.Fatalf("closing /bin/cat: %v", err)
 	}
 }
 
@@ -33,16 +33,16 @@ func TestRunEcho(t *testing.T) {
 	cmd, err := Run("/bin/echo", []string{"echo", "hello", "world"}, nil,
 		DevNull, Pipe, DevNull);
 	if err != nil {
-		t.Fatalf("opencmd /bin/echo: %v", err);
+		t.Fatalf("opencmd /bin/echo: %v", err)
 	}
 	buf, err := io.ReadAll(cmd.Stdout);
 	if err != nil {
-		t.Fatalf("reading from /bin/echo: %v", err);
+		t.Fatalf("reading from /bin/echo: %v", err)
 	}
 	if string(buf) != "hello world\n" {
-		t.Fatalf("reading from /bin/echo: got %q", buf);
+		t.Fatalf("reading from /bin/echo: got %q", buf)
 	}
 	if err = cmd.Close(); err != nil {
-		t.Fatalf("closing /bin/echo: %v", err);
+		t.Fatalf("closing /bin/echo: %v", err)
 	}
 }
diff --git a/src/pkg/exp/4s/4s.go b/src/pkg/exp/4s/4s.go
index fbe8c5f0a4..9064ac7678 100644
--- a/src/pkg/exp/4s/4s.go
+++ b/src/pkg/exp/4s/4s.go
@@ -23,18 +23,18 @@ func main() {
 	runtime.LockOSThread();
 
 	if srpc.Enabled() {
-		go srpc.ServeRuntime();
+		go srpc.ServeRuntime()
 	}
 
 	args := os.Args;
 	p := pieces4;
 	if len(args) > 1 && args[1] == "-5" {
-		p = pieces5;
+		p = pieces5
 	}
 	dx, dy := 500, 500;
 	w, err := av.Init(av.SubsystemVideo | av.SubsystemAudio, dx, dy);
 	if err != nil {
-		log.Exit(err);
+		log.Exit(err)
 	}
 
 	sndc = make(chan []uint16, 10);
@@ -49,7 +49,7 @@ func audioServer() {
 
 	n, err := av.AudioStream(nil);
 	if err != nil {
-		log.Exit(err);
+		log.Exit(err)
 	}
 	for {
 		b := <-sndc;
@@ -58,13 +58,13 @@ func audioServer() {
 			a, b = b[0 : n/2], b[n/2 : len(b)];
 			n, err = av.AudioStream(a);
 			if err != nil {
-				log.Exit(err);
+				log.Exit(err)
 			}
 			println(n, len(b)*2);
 		}
 		a := make([]uint16, n/2);
 		for i := range b {
-			a[i] = b[i];
+			a[i] = b[i]
 		}
 		n, err = av.AudioStream(a);
 	}
diff --git a/src/pkg/exp/4s/xs.go b/src/pkg/exp/4s/xs.go
index 3b7c1a4b39..e8cf48d783 100644
--- a/src/pkg/exp/4s/xs.go
+++ b/src/pkg/exp/4s/xs.go
@@ -160,17 +160,17 @@ var txpix = [NCOL]draw.Color{
 func movemouse() int {
 	//mouse.draw.Point = draw.Pt(rboard.Min.X + rboard.Dx()/2, rboard.Min.Y + rboard.Dy()/2);
 	//moveto(mousectl, mouse.Xy);
-	return mouse.X;
+	return mouse.X
 }
 
 func warp(p draw.Point, x int) int {
 	if !suspended && piece != nil {
 		x = pos.X + piece.sz.X * pcsz / 2;
 		if p.Y < rboard.Min.Y {
-			p.Y = rboard.Min.Y;
+			p.Y = rboard.Min.Y
 		}
 		if p.Y >= rboard.Max.Y {
-			p.Y = rboard.Max.Y - 1;
+			p.Y = rboard.Max.Y - 1
 		}
 		//moveto(mousectl, draw.Pt(x, p.Y));
 	}
@@ -181,14 +181,14 @@ func initPieces() {
 	for i := range pieces {
 		p := &pieces[i];
 		if p.rot == 3 {
-			p.right = &pieces[i-3];
+			p.right = &pieces[i-3]
 		} else {
-			p.right = &pieces[i+1];
+			p.right = &pieces[i+1]
 		}
 		if p.rot == 0 {
-			p.left = &pieces[i+3];
+			p.left = &pieces[i+3]
 		} else {
-			p.left = &pieces[i-1];
+			p.left = &pieces[i-1]
 		}
 	}
 }
@@ -204,7 +204,7 @@ func collide(pt draw.Point, p *Piece) bool {
 			continue;
 		}
 		if board[pt.Y][pt.X] != 0 {
-			return true;
+			return true
 		}
 	}
 	return false;
@@ -218,7 +218,7 @@ func collider(pt, pmax draw.Point) bool {
 	for i := pi; i < pi+n && i < NX; i++ {
 		for j := pj; j < pj+m && j < NY; j++ {
 			if board[j][i] != 0 {
-				return true;
+				return true
 			}
 		}
 	}
@@ -232,7 +232,7 @@ func setpiece(p *Piece) {
 	br2 = br;
 	piece = p;
 	if p == nil {
-		return;
+		return
 	}
 	var op draw.Point;
 	var r draw.Rectangle;
@@ -252,10 +252,10 @@ func setpiece(p *Piece) {
 			draw.Draw(bbmask, r, bbmask, nil, op);
 		}
 		if br.Max.X < r.Max.X {
-			br.Max.X = r.Max.X;
+			br.Max.X = r.Max.X
 		}
 		if br.Max.Y < r.Max.Y {
-			br.Max.Y = r.Max.Y;
+			br.Max.Y = r.Max.Y
 		}
 	}
 	br.Max = br.Max.Sub(bbr.Min);
@@ -273,14 +273,14 @@ func setpiece(p *Piece) {
 func drawpiece() {
 	draw.Draw(screen, br.Add(pos), bb, bbmask, bbr.Min);
 	if suspended {
-		draw.Draw(screen, br.Add(pos), draw.White, whitemask, draw.ZP);
+		draw.Draw(screen, br.Add(pos), draw.White, whitemask, draw.ZP)
 	}
 }
 
 func undrawpiece() {
 	var mask image.Image;
 	if collider(pos, br.Max) {
-		mask = bbmask;
+		mask = bbmask
 	}
 	draw.Draw(screen, br.Add(pos), draw.White, mask, bbr.Min);
 }
@@ -300,7 +300,7 @@ func canfit(p *Piece) bool {
 	if j >= 4 {
 		j = p.sz.X;
 		if j < p.sz.Y {
-			j = p.sz.Y;
+			j = p.sz.Y
 		}
 		j = 2*j - 1;
 	}
@@ -321,7 +321,7 @@ func canfit(p *Piece) bool {
 }
 
 func score(p int) {
-	points += p;
+	points += p
 	//	snprint(buf, sizeof(buf), "%.6ld", points);
 	//	draw.Draw(screen, draw.Rpt(pscore, pscore.Add(scoresz)), draw.White, nil, draw.ZP);
 	//	string(screen, pscore, draw.Black, draw.ZP, font, buf);
@@ -343,13 +343,13 @@ func drawboard() {
 	for i := 0; i < NY; i++ {
 		for j := 0; j < NX; j++ {
 			if board[i][j] != 0 {
-				drawsq(screen, draw.Pt(rboard.Min.X + j*pcsz, rboard.Min.Y + i*pcsz), int(board[i][j]-16));
+				drawsq(screen, draw.Pt(rboard.Min.X + j*pcsz, rboard.Min.Y + i*pcsz), int(board[i][j]-16))
 			}
 		}
 	}
 	score(0);
 	if suspended {
-		draw.Draw(screen, screenr, draw.White, whitemask, draw.ZP);
+		draw.Draw(screen, screenr, draw.White, whitemask, draw.ZP)
 	}
 }
 
@@ -360,7 +360,7 @@ func choosepiece() {
 		pos = rboard.Min;
 		pos.X += rand.Intn(NX) * pcsz;
 		if !collide(draw.Pt(pos.X, pos.Y + pcsz - DY), piece) {
-			break;
+			break
 		}
 	}
 	drawpiece();
@@ -370,10 +370,10 @@ func choosepiece() {
 func movepiece() bool {
 	var mask image.Image;
 	if collide(draw.Pt(pos.X, pos.Y + pcsz), piece) {
-		return false;
+		return false
 	}
 	if collider(pos, br2.Max) {
-		mask = bb2mask;
+		mask = bb2mask
 	}
 	draw.Draw(screen, br2.Add(pos), bb2, mask, bb2r.Min);
 	pos.Y += DY;
@@ -391,7 +391,7 @@ func suspend(s bool) {
 		}
 	*/
 	if !suspended {
-		drawpiece();
+		drawpiece()
 	}
 	drawboard();
 	display.FlushImage();
@@ -403,18 +403,18 @@ func pause(t int) {
 		select {
 		case s := <-suspc:
 			if !suspended && s {
-				suspend(true);
+				suspend(true)
 			} else if suspended && !s {
 				suspend(false);
 				lastmx = warp(mouse.Point, lastmx);
 			}
 		case <-timerc:
 			if suspended {
-				break;
+				break
 			}
 			t -= tsleep;
 			if t < 0 {
-				return;
+				return
 			}
 		case <-resizec:
 			//redraw(true);
@@ -437,7 +437,7 @@ func horiz() bool {
 		}
 	}
 	if h == 0 {
-		return false;
+		return false
 	}
 	r := rboard;
 	newscreen = false;
@@ -471,7 +471,7 @@ func horiz() bool {
 		r.Max.Y = rboard.Min.Y + pcsz;
 		draw.Draw(screen, r, draw.White, nil, draw.ZP);
 		for k := lev[j]-1; k >= 0; k-- {
-			board[k+1] = board[k];
+			board[k+1] = board[k]
 		}
 		board[0] = [NX]byte{};
 	}
@@ -526,7 +526,7 @@ func drop(f bool) bool {
 	fusst = 0;
 	rest();
 	if pos.Y == rboard.Min.Y && !horiz() {
-		return true;
+		return true
 	}
 	horiz();
 	setpiece(nil);
@@ -551,7 +551,7 @@ func play() {
 				break;
 			}
 			if lastmx < 0 {
-				lastmx = mouse.X;
+				lastmx = mouse.X
 			}
 			if mouse.X > lastmx+DMOUSE {
 				mright();
@@ -562,21 +562,21 @@ func play() {
 				lastmx = mouse.X;
 			}
 			if mouse.Buttons &^ om.Buttons & 1 == 1 {
-				rleft();
+				rleft()
 			}
 			if mouse.Buttons &^ om.Buttons & 2 == 2 {
 				if drop(true) {
-					return;
+					return
 				}
 			}
 			if mouse.Buttons &^ om.Buttons & 4 == 4 {
-				rright();
+				rright()
 			}
 			om = mouse;
 
 		case s := <-suspc:
 			if !suspended && s {
-				suspend(true);
+				suspend(true)
 			} else if suspended && !s {
 				suspend(false);
 				lastmx = warp(mouse.Point, lastmx);
@@ -587,26 +587,26 @@ func play() {
 
 		case r := <-kbdc:
 			if suspended {
-				break;
+				break
 			}
 			switch r {
 			case 'f', ';':
-				mright();
+				mright()
 			case 'a', 'j':
-				mleft();
+				mleft()
 			case 'd', 'l':
-				rright();
+				rright()
 			case 's', 'k':
-				rleft();
+				rleft()
 			case ' ':
 				if drop(true) {
-					return;
+					return
 				}
 			}
 
 		case <-timerc:
 			if suspended {
-				break;
+				break
 			}
 			dt -= tsleep;
 			if dt < 0 {
@@ -619,12 +619,12 @@ func play() {
 				dt = 52-dt;
 				for ; i > 0; i-- {
 					if movepiece() {
-						continue;
+						continue
 					}
 					fusst++;
 					if fusst == 40 {
 						if drop(false) {
-							return;
+							return
 						}
 						break;
 					}
@@ -642,11 +642,11 @@ func suspproc() {
 	for {
 		select {
 		case mouse = <-mc:
-			mousec <- mouse;
+			mousec <- mouse
 		case r := <-kc:
 			switch r {
 			case 'q', 'Q', 0x04, 0x7F:
-				os.Exit(0);
+				os.Exit(0)
 			default:
 				if s {
 					s = false;
@@ -658,7 +658,7 @@ func suspproc() {
 					s = true;
 					suspc <- s;
 				default:
-					kbdc <- r;
+					kbdc <- r
 				}
 			}
 		}
@@ -676,16 +676,16 @@ func redraw(new bool) {
 	dy := r.Max.Y - r.Min.Y - 2*32;
 	DY = dx/NX;
 	if DY > dy/NY {
-		DY = dy/NY;
+		DY = dy/NY
 	}
 	DY /= 8;
 	if DY > 4 {
-		DY = 4;
+		DY = 4
 	}
 	pcsz = DY*8;
 	DMOUSE = pcsz/3;
 	if pcsz < 8 {
-		log.Exitf("screen too small: %d", pcsz);
+		log.Exitf("screen too small: %d", pcsz)
 	}
 	rboard = screenr;
 	rboard.Min.X += (dx - pcsz*NX)/2;
@@ -707,7 +707,7 @@ func redraw(new bool) {
 	drawboard();
 	setpiece(piece);
 	if piece != nil {
-		drawpiece();
+		drawpiece()
 	}
 	lastmx = movemouse();
 	newscreen = true;
diff --git a/src/pkg/exp/datafmt/datafmt.go b/src/pkg/exp/datafmt/datafmt.go
index 28c9e74496..b6f596429d 100644
--- a/src/pkg/exp/datafmt/datafmt.go
+++ b/src/pkg/exp/datafmt/datafmt.go
@@ -319,12 +319,12 @@ func newState(fmt Format, env Environment, errors chan os.Error) *State {
 
 	// if we have a default rule, cache it's expression for fast access
 	if x, found := fmt["default"]; found {
-		s.default_ = x;
+		s.default_ = x
 	}
 
 	// if we have a global separator rule, cache it's expression for fast access
 	if x, found := fmt["/"]; found {
-		s.separator = x;
+		s.separator = x
 	}
 
 	return s;
@@ -383,7 +383,7 @@ type checkpoint struct {
 func (s *State) save() checkpoint {
 	saved := checkpoint{nil, s.hasOutput, s.output.Len(), s.linePos};
 	if s.env != nil {
-		saved.env = s.env.Copy();
+		saved.env = s.env.Copy()
 	}
 	return saved;
 }
@@ -410,32 +410,32 @@ func (s *State) error(msg string) {
 func typename(typ reflect.Type) string {
 	switch typ.(type) {
 	case *reflect.ArrayType:
-		return "array";
+		return "array"
 	case *reflect.SliceType:
-		return "array";
+		return "array"
 	case *reflect.ChanType:
-		return "chan";
+		return "chan"
 	case *reflect.DotDotDotType:
-		return "ellipsis";
+		return "ellipsis"
 	case *reflect.FuncType:
-		return "func";
+		return "func"
 	case *reflect.InterfaceType:
-		return "interface";
+		return "interface"
 	case *reflect.MapType:
-		return "map";
+		return "map"
 	case *reflect.PtrType:
-		return "ptr";
+		return "ptr"
 	}
 	return typ.String();
 }
 
 func (s *State) getFormat(name string) expr {
 	if fexpr, found := s.fmt[name]; found {
-		return fexpr;
+		return fexpr
 	}
 
 	if s.default_ != nil {
-		return s.default_;
+		return s.default_
 	}
 
 	s.error(fmt.Sprintf("no format rule for type: '%s'", name));
@@ -452,7 +452,7 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {
 	// an empty format expression always evaluates
 	// to a non-nil (but empty) []byte
 	if fexpr == nil {
-		return true;
+		return true
 	}
 
 	switch t := fexpr.(type) {
@@ -462,7 +462,7 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {
 		mark := s.save();
 		for _, x := range t {
 			if s.eval(x, value, index) {
-				return true;
+				return true
 			}
 			s.restore(mark);
 		}
@@ -489,7 +489,7 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {
 				s.separator = nil;	// and disable it (avoid recursion)
 				mark := s.save();
 				if !s.eval(sep, value, index) {
-					s.restore(mark);
+					s.restore(mark)
 				}
 				s.separator = sep;	// enable it again
 			}
@@ -501,14 +501,14 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {
 				// segment contains a %-format at the beginning
 				if lit[1] == '%' {
 					// "%%" is printed as a single "%"
-					s.Write(lit[1:len(lit)]);
+					s.Write(lit[1:len(lit)])
 				} else {
 					// use s instead of s.output to get indentation right
-					fmt.Fprintf(s, string(lit), value.Interface());
+					fmt.Fprintf(s, string(lit), value.Interface())
 				}
 			} else {
 				// segment contains no %-formats
-				s.Write(lit);
+				s.Write(lit)
 			}
 		}
 		return true;	// a literal never evaluates to nil
@@ -524,39 +524,39 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {
 			switch v := value.(type) {
 			case *reflect.ArrayValue:
 				if v.Len() <= index {
-					return false;
+					return false
 				}
 				value = v.Elem(index);
 
 			case *reflect.SliceValue:
 				if v.IsNil() || v.Len() <= index {
-					return false;
+					return false
 				}
 				value = v.Elem(index);
 
 			case *reflect.MapValue:
-				s.error("reflection support for maps incomplete");
+				s.error("reflection support for maps incomplete")
 
 			case *reflect.PtrValue:
 				if v.IsNil() {
-					return false;
+					return false
 				}
 				value = v.Elem();
 
 			case *reflect.InterfaceValue:
 				if v.IsNil() {
-					return false;
+					return false
 				}
 				value = v.Elem();
 
 			case *reflect.ChanValue:
-				s.error("reflection support for chans incomplete");
+				s.error("reflection support for chans incomplete")
 
 			case *reflect.FuncValue:
-				s.error("reflection support for funcs incomplete");
+				s.error("reflection support for funcs incomplete")
 
 			default:
-				s.error(fmt.Sprintf("error: * does not apply to `%s`", value.Type()));
+				s.error(fmt.Sprintf("error: * does not apply to `%s`", value.Type()))
 			}
 
 		default:
@@ -566,7 +566,7 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {
 				field = sval.FieldByName(t.fieldName);
 				if field == nil {
 					// TODO consider just returning false in this case
-					s.error(fmt.Sprintf("error: no field `%s` in `%s`", t.fieldName, value.Type()));
+					s.error(fmt.Sprintf("error: no field `%s` in `%s`", t.fieldName, value.Type()))
 				}
 			}
 			value = field;
@@ -576,7 +576,7 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {
 		ruleName := t.ruleName;
 		if ruleName == "" {
 			// no alternate rule name, value type determines rule
-			ruleName = typename(value.Type());
+			ruleName = typename(value.Type())
 		}
 		fexpr = s.getFormat(ruleName);
 
@@ -617,7 +617,7 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {
 		// buffer unless the result is nil
 		mark := s.save();
 		if !s.eval(t.body, value, 0) {	// TODO is 0 index correct?
-			s.restore(mark);
+			s.restore(mark)
 		}
 		return true;	// an option never evaluates to nil
 
@@ -631,7 +631,7 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {
 				// nil result from separator is ignored
 				mark := s.save();
 				if !s.eval(t.separator, value, i) {
-					s.restore(mark);
+					s.restore(mark)
 				}
 			}
 			if !s.eval(t.body, value, i) {
@@ -665,7 +665,7 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {
 //
 func (f Format) Eval(env Environment, args ...) ([]byte, os.Error) {
 	if f == nil {
-		return nil, os.NewError("format is nil");
+		return nil, os.NewError("format is nil")
 	}
 
 	errors := make(chan os.Error);
@@ -677,7 +677,7 @@ func (f Format) Eval(env Environment, args ...) ([]byte, os.Error) {
 			fld := value.Field(i);
 			mark := s.save();
 			if !s.eval(s.getFormat(typename(fld.Type())), fld, 0) {	// TODO is 0 index correct?
-				s.restore(mark);
+				s.restore(mark)
 			}
 		}
 		errors <- nil;	// no errors
@@ -699,7 +699,7 @@ func (f Format) Fprint(w io.Writer, env Environment, args ...) (int, os.Error) {
 	data, err := f.Eval(env, args);
 	if err != nil {
 		// TODO should we print partial result in case of error?
-		return 0, err;
+		return 0, err
 	}
 	return w.Write(data);
 }
@@ -710,7 +710,7 @@ func (f Format) Fprint(w io.Writer, env Environment, args ...) (int, os.Error) {
 // number of bytes written and an os.Error, if any.
 //
 func (f Format) Print(args ...) (int, os.Error) {
-	return f.Fprint(os.Stdout, nil, args);
+	return f.Fprint(os.Stdout, nil, args)
 }
 
 
@@ -723,7 +723,7 @@ func (f Format) Sprint(args ...) string {
 	var buf bytes.Buffer;
 	_, err := f.Fprint(&buf, nil, args);
 	if err != nil {
-		fmt.Fprintf(&buf, "--- Sprint(%s) failed: %v", fmt.Sprint(args), err);
+		fmt.Fprintf(&buf, "--- Sprint(%s) failed: %v", fmt.Sprint(args), err)
 	}
 	return buf.String();
 }
diff --git a/src/pkg/exp/datafmt/datafmt_test.go b/src/pkg/exp/datafmt/datafmt_test.go
index c43cca2b7f..b4e5ed8d28 100644
--- a/src/pkg/exp/datafmt/datafmt_test.go
+++ b/src/pkg/exp/datafmt/datafmt_test.go
@@ -23,13 +23,13 @@ func parse(t *testing.T, form string, fmap FormatterMap) Format {
 
 func verify(t *testing.T, f Format, expected string, args ...) {
 	if f == nil {
-		return;	// allow other tests to run
+		return	// allow other tests to run
 	}
 	result := f.Sprint(args);
 	if result != expected {
 		t.Errorf(
 			"result  : `%s`\nexpected: `%s`\n\n",
-			result, expected);
+			result, expected)
 	}
 }
 
@@ -44,13 +44,13 @@ func formatter(s *State, value interface{}, rule_name string) bool {
 		return true;
 	case "int":
 		if value.(int) & 1 == 0 {
-			fmt.Fprint(s, "even ");
+			fmt.Fprint(s, "even ")
 		} else {
-			fmt.Fprint(s, "odd ");
+			fmt.Fprint(s, "odd ")
 		}
 		return true;
 	case "nil":
-		return false;
+		return false
 	case "testing.T":
 		s.Write(strings.Bytes("testing.T"));
 		return true;
@@ -96,13 +96,13 @@ func TestCustomFormatters(t *testing.T) {
 func check(t *testing.T, form, expected string, args ...) {
 	f := parse(t, form, nil);
 	if f == nil {
-		return;	// allow other tests to run
+		return	// allow other tests to run
 	}
 	result := f.Sprint(args);
 	if result != expected {
 		t.Errorf(
 			"format  : %s\nresult  : `%s`\nexpected: `%s`\n\n",
-			form, result, expected);
+			form, result, expected)
 	}
 }
 
diff --git a/src/pkg/exp/datafmt/parser.go b/src/pkg/exp/datafmt/parser.go
index c7d754fe7d..e3d5b61346 100644
--- a/src/pkg/exp/datafmt/parser.go
+++ b/src/pkg/exp/datafmt/parser.go
@@ -34,7 +34,7 @@ func (p *parser) next() {
 	case token.CHAN, token.FUNC, token.INTERFACE, token.MAP, token.STRUCT:
 		// Go keywords for composite types are type names
 		// returned by reflect. Accept them as identifiers.
-		p.tok = token.IDENT;	// p.lit is already set correctly
+		p.tok = token.IDENT	// p.lit is already set correctly
 	}
 }
 
@@ -55,7 +55,7 @@ func (p *parser) errorExpected(pos token.Position, msg string) {
 		// make the error message more specific
 		msg += ", found '" + p.tok.String() + "'";
 		if p.tok.IsLiteral() {
-			msg += " "+string(p.lit);
+			msg += " "+string(p.lit)
 		}
 	}
 	p.Error(pos, msg);
@@ -65,7 +65,7 @@ func (p *parser) errorExpected(pos token.Position, msg string) {
 func (p *parser) expect(tok token.Token) token.Position {
 	pos := p.pos;
 	if p.tok != tok {
-		p.errorExpected(pos, "'" + tok.String() + "'");
+		p.errorExpected(pos, "'" + tok.String() + "'")
 	}
 	p.next();	// make progress in any case
 	return pos;
@@ -85,9 +85,9 @@ func (p *parser) parseTypeName() (string, bool) {
 	if p.tok == token.PERIOD {
 		// got a package name, lookup package
 		if importPath, found := p.packs[name]; found {
-			name = importPath;
+			name = importPath
 		} else {
-			p.Error(pos, "package not declared: " + name);
+			p.Error(pos, "package not declared: " + name)
 		}
 		p.next();
 		name, isIdent = name + "." + p.parseIdentifier(), false;
@@ -105,7 +105,7 @@ func (p *parser) parseRuleName() (string, bool) {
 	name, isIdent := "", false;
 	switch p.tok {
 	case token.IDENT:
-		name, isIdent = p.parseTypeName();
+		name, isIdent = p.parseTypeName()
 	case token.DEFAULT:
 		name = "default";
 		p.next();
@@ -130,7 +130,7 @@ func (p *parser) parseString() string {
 		p.next();
 		return s;
 	} else {
-		p.expect(token.STRING);
+		p.expect(token.STRING)
 	}
 	return s;
 }
@@ -164,7 +164,7 @@ func (p *parser) parseLiteral() literal {
 	// convert list into a literal
 	lit := make(literal, list.Len());
 	for i := 0; i < list.Len(); i++ {
-		lit[i] = list.At(i).([]byte);
+		lit[i] = list.At(i).([]byte)
 	}
 
 	return lit;
@@ -176,7 +176,7 @@ func (p *parser) parseField() expr {
 	switch p.tok {
 	case token.ILLEGAL:
 		if string(p.lit) != "@" {
-			return nil;
+			return nil
 		}
 		fname = "@";
 		p.next();
@@ -184,9 +184,9 @@ func (p *parser) parseField() expr {
 		fname = "*";
 		p.next();
 	case token.IDENT:
-		fname = p.parseIdentifier();
+		fname = p.parseIdentifier()
 	default:
-		return nil;
+		return nil
 	}
 
 	var ruleName string;
@@ -202,7 +202,7 @@ func (p *parser) parseField() expr {
 func (p *parser) parseOperand() (x expr) {
 	switch p.tok {
 	case token.STRING:
-		x = p.parseLiteral();
+		x = p.parseLiteral()
 
 	case token.LPAREN:
 		p.next();
@@ -230,7 +230,7 @@ func (p *parser) parseOperand() (x expr) {
 		p.expect(token.RBRACE);
 
 	default:
-		x = p.parseField();	// may be nil
+		x = p.parseField()	// may be nil
 	}
 
 	return x;
@@ -242,21 +242,21 @@ func (p *parser) parseSequence() expr {
 	list.Init(0);
 
 	for x := p.parseOperand(); x != nil; x = p.parseOperand() {
-		list.Push(x);
+		list.Push(x)
 	}
 
 	// no need for a sequence if list.Len() < 2
 	switch list.Len() {
 	case 0:
-		return nil;
+		return nil
 	case 1:
-		return list.At(0).(expr);
+		return list.At(0).(expr)
 	}
 
 	// convert list into a sequence
 	seq := make(sequence, list.Len());
 	for i := 0; i < list.Len(); i++ {
-		seq[i] = list.At(i).(expr);
+		seq[i] = list.At(i).(expr)
 	}
 	return seq;
 }
@@ -269,10 +269,10 @@ func (p *parser) parseExpression() expr {
 	for {
 		x := p.parseSequence();
 		if x != nil {
-			list.Push(x);
+			list.Push(x)
 		}
 		if p.tok != token.OR {
-			break;
+			break
 		}
 		p.next();
 	}
@@ -280,15 +280,15 @@ func (p *parser) parseExpression() expr {
 	// no need for an alternatives if list.Len() < 2
 	switch list.Len() {
 	case 0:
-		return nil;
+		return nil
 	case 1:
-		return list.At(0).(expr);
+		return list.At(0).(expr)
 	}
 
 	// convert list into a alternatives
 	alt := make(alternatives, list.Len());
 	for i := 0; i < list.Len(); i++ {
-		alt[i] = list.At(i).(expr);
+		alt[i] = list.At(i).(expr)
 	}
 	return alt;
 }
@@ -306,11 +306,11 @@ func (p *parser) parseFormat() {
 
 			// add package declaration
 			if !isIdent {
-				p.Error(pos, "illegal package name: " + name);
+				p.Error(pos, "illegal package name: " + name)
 			} else if _, found := p.packs[name]; !found {
-				p.packs[name] = importPath;
+				p.packs[name] = importPath
 			} else {
-				p.Error(pos, "package already declared: " + name);
+				p.Error(pos, "package already declared: " + name)
 			}
 
 		case token.ASSIGN:
@@ -320,9 +320,9 @@ func (p *parser) parseFormat() {
 
 			// add rule
 			if _, found := p.rules[name]; !found {
-				p.rules[name] = x;
+				p.rules[name] = x
 			} else {
-				p.Error(pos, "format rule already declared: " + name);
+				p.Error(pos, "format rule already declared: " + name)
 			}
 
 		default:
@@ -331,9 +331,9 @@ func (p *parser) parseFormat() {
 		}
 
 		if p.tok == token.SEMICOLON {
-			p.next();
+			p.next()
 		} else {
-			break;
+			break
 		}
 	}
 	p.expect(token.EOF);
@@ -346,7 +346,7 @@ func remap(p *parser, name string) string {
 		packageName, suffix := name[0:i], name[i:len(name)];
 		// lookup package
 		if importPath, found := p.packs[packageName]; found {
-			name = importPath + suffix;
+			name = importPath + suffix
 		} else {
 			var invalidPos token.Position;
 			p.Error(invalidPos, "package not declared: " + packageName);
@@ -371,7 +371,7 @@ func Parse(filename string, src []byte, fmap FormatterMap) (Format, os.Error) {
 	for name, form := range fmap {
 		name = remap(&p, name);
 		if _, found := p.rules[name]; !found {
-			p.rules[name] = &custom{name, form};
+			p.rules[name] = &custom{name, form}
 		} else {
 			var invalidPos token.Position;
 			p.Error(invalidPos, "formatter already declared: " + name);
diff --git a/src/pkg/exp/draw/arith.go b/src/pkg/exp/draw/arith.go
index 314754ea90..59830bba5a 100644
--- a/src/pkg/exp/draw/arith.go
+++ b/src/pkg/exp/draw/arith.go
@@ -46,7 +46,7 @@ func (p Point) Eq(q Point) bool	{ return p.X == q.X && p.Y == q.Y }
 
 // Inset returns the rectangle r inset by n: Rect(r.Min.X+n, r.Min.Y+n, r.Max.X-n, r.Max.Y-n).
 func (r Rectangle) Inset(n int) Rectangle {
-	return Rectangle{Point{r.Min.X + n, r.Min.Y + n}, Point{r.Max.X - n, r.Max.Y - n}};
+	return Rectangle{Point{r.Min.X + n, r.Min.Y + n}, Point{r.Max.X - n, r.Max.Y - n}}
 }
 
 // Add returns the rectangle r translated by p: Rpt(r.Min.Add(p), r.Max.Add(p)).
@@ -59,10 +59,10 @@ func (r Rectangle) Sub(p Point) Rectangle	{ return Rectangle{r.Min.Sub(p), r.Max
 // has Min.X <= Max.X and Min.Y <= Max.Y.
 func (r Rectangle) Canon() Rectangle {
 	if r.Max.X < r.Min.X {
-		r.Max.X = r.Min.X;
+		r.Max.X = r.Min.X
 	}
 	if r.Max.Y < r.Min.Y {
-		r.Max.Y = r.Min.Y;
+		r.Max.Y = r.Min.Y
 	}
 	return r;
 }
@@ -70,7 +70,7 @@ func (r Rectangle) Canon() Rectangle {
 // Overlaps returns true if r and r1 cross; that is, it returns true if they share any point.
 func (r Rectangle) Overlaps(r1 Rectangle) bool {
 	return r.Min.X < r1.Max.X && r1.Min.X < r.Max.X &&
-		r.Min.Y < r1.Max.Y && r1.Min.Y < r.Max.Y;
+		r.Min.Y < r1.Max.Y && r1.Min.Y < r.Max.Y
 }
 
 // Empty retruns true if r contains no points.
@@ -79,10 +79,10 @@ func (r Rectangle) Empty() bool	{ return r.Max.X <= r.Min.X || r.Max.Y <= r.Min.
 // InRect returns true if all the points in r are also in r1.
 func (r Rectangle) In(r1 Rectangle) bool {
 	if r.Empty() {
-		return true;
+		return true
 	}
 	if r1.Empty() {
-		return false;
+		return false
 	}
 	return r1.Min.X <= r.Min.X && r.Max.X <= r1.Max.X &&
 		r1.Min.Y <= r.Min.Y && r.Max.Y <= r1.Max.Y;
@@ -91,22 +91,22 @@ func (r Rectangle) In(r1 Rectangle) bool {
 // Combine returns the smallest rectangle containing all points from r and from r1.
 func (r Rectangle) Combine(r1 Rectangle) Rectangle {
 	if r.Empty() {
-		return r1;
+		return r1
 	}
 	if r1.Empty() {
-		return r;
+		return r
 	}
 	if r.Min.X > r1.Min.X {
-		r.Min.X = r1.Min.X;
+		r.Min.X = r1.Min.X
 	}
 	if r.Min.Y > r1.Min.Y {
-		r.Min.Y = r1.Min.Y;
+		r.Min.Y = r1.Min.Y
 	}
 	if r.Max.X < r1.Max.X {
-		r.Max.X = r1.Max.X;
+		r.Max.X = r1.Max.X
 	}
 	if r.Max.Y < r1.Max.Y {
-		r.Max.Y = r1.Max.Y;
+		r.Max.Y = r1.Max.Y
 	}
 	return r;
 }
@@ -114,22 +114,22 @@ func (r Rectangle) Combine(r1 Rectangle) Rectangle {
 // Clip returns the largest rectangle containing only points shared by r and r1.
 func (r Rectangle) Clip(r1 Rectangle) Rectangle {
 	if r.Empty() {
-		return r;
+		return r
 	}
 	if r1.Empty() {
-		return r1;
+		return r1
 	}
 	if r.Min.X < r1.Min.X {
-		r.Min.X = r1.Min.X;
+		r.Min.X = r1.Min.X
 	}
 	if r.Min.Y < r1.Min.Y {
-		r.Min.Y = r1.Min.Y;
+		r.Min.Y = r1.Min.Y
 	}
 	if r.Max.X > r1.Max.X {
-		r.Max.X = r1.Max.X;
+		r.Max.X = r1.Max.X
 	}
 	if r.Max.Y > r1.Max.Y {
-		r.Max.Y = r1.Max.Y;
+		r.Max.Y = r1.Max.Y
 	}
 	return r;
 }
diff --git a/src/pkg/exp/draw/color.go b/src/pkg/exp/draw/color.go
index 310f70e30d..0d94800de1 100644
--- a/src/pkg/exp/draw/color.go
+++ b/src/pkg/exp/draw/color.go
@@ -66,28 +66,28 @@ func (c Color) RGBA() (r, g, b, a uint32) {
 func (c Color) SetAlpha(a uint8) Color {
 	r, g, b, oa := c>>24, (c>>16)&0xFF, (c>>8)&0xFF, c&0xFF;
 	if oa == 0 {
-		return 0;
+		return 0
 	}
 	r = r*Color(a)/oa;
 	if r < 0 {
-		r = 0;
+		r = 0
 	}
 	if r > 0xFF {
-		r = 0xFF;
+		r = 0xFF
 	}
 	g = g*Color(a)/oa;
 	if g < 0 {
-		g = 0;
+		g = 0
 	}
 	if g > 0xFF {
-		g = 0xFF;
+		g = 0xFF
 	}
 	b = b*Color(a)/oa;
 	if b < 0 {
-		b = 0;
+		b = 0
 	}
 	if b > 0xFF {
-		b = 0xFF;
+		b = 0xFF
 	}
 	return r<<24 | g<<16 | b<<8 | Color(a);
 }
@@ -100,7 +100,7 @@ func (c Color) At(x, y int) image.Color	{ return c }
 
 func toColor(color image.Color) image.Color {
 	if c, ok := color.(Color); ok {
-		return c;
+		return c
 	}
 	r, g, b, a := color.RGBA();
 	return Color(r>>24<<24 | g>>24<<16 | b>>24<<8 | a>>24);
diff --git a/src/pkg/exp/draw/draw.go b/src/pkg/exp/draw/draw.go
index 0f5f9bb468..284211aa2a 100644
--- a/src/pkg/exp/draw/draw.go
+++ b/src/pkg/exp/draw/draw.go
@@ -30,19 +30,19 @@ func Draw(dst Image, r Rectangle, src, mask image.Image, pt Point) {
 	dx, dy := src.Width(), src.Height();
 	if mask != nil {
 		if dx > mask.Width() {
-			dx = mask.Width();
+			dx = mask.Width()
 		}
 		if dy > mask.Width() {
-			dy = mask.Width();
+			dy = mask.Width()
 		}
 	}
 	dx -= pt.X;
 	dy -= pt.Y;
 	if r.Dx() > dx {
-		r.Max.X = r.Min.X + dx;
+		r.Max.X = r.Min.X + dx
 	}
 	if r.Dy() > dy {
-		r.Max.Y = r.Min.Y + dy;
+		r.Max.Y = r.Min.Y + dy
 	}
 
 	x0, x1, dx := r.Min.X, r.Max.X, 1;
@@ -67,9 +67,9 @@ func Draw(dst Image, r Rectangle, src, mask image.Image, pt Point) {
 			_, _, _, ma := mask.At(sx, sy).RGBA();
 			switch ma {
 			case 0:
-				continue;
+				continue
 			case 0xFFFFFFFF:
-				dst.Set(x, y, src.At(sx, sy));
+				dst.Set(x, y, src.At(sx, sy))
 			default:
 				dr, dg, db, da := dst.At(x, y).RGBA();
 				dr >>= 16;
@@ -89,7 +89,7 @@ func Draw(dst Image, r Rectangle, src, mask image.Image, pt Point) {
 				db = (db*(M-a) + sb*ma)/M;
 				da = (da*(M-a) + sa*ma)/M;
 				if out == nil {
-					out = new(image.RGBA64Color);
+					out = new(image.RGBA64Color)
 				}
 				out.R = uint16(dr);
 				out.G = uint16(dg);
diff --git a/src/pkg/exp/eval/abort.go b/src/pkg/exp/eval/abort.go
index 6cac2175ac..fd16d7eaab 100644
--- a/src/pkg/exp/eval/abort.go
+++ b/src/pkg/exp/eval/abort.go
@@ -14,7 +14,7 @@ import (
 // causing the innermost Try to return err.
 func (t *Thread) Abort(err os.Error) {
 	if t.abort == nil {
-		panicln("abort:", err.String());
+		panicln("abort:", err.String())
 	}
 	t.abort <- err;
 	runtime.Goexit();
@@ -49,7 +49,7 @@ type IndexError struct {
 
 func (e IndexError) String() string {
 	if e.Idx < 0 {
-		return fmt.Sprintf("negative index: %d", e.Idx);
+		return fmt.Sprintf("negative index: %d", e.Idx)
 	}
 	return fmt.Sprintf("index %d exceeds length %d", e.Idx, e.Len);
 }
@@ -59,7 +59,7 @@ type SliceError struct {
 }
 
 func (e SliceError) String() string {
-	return fmt.Sprintf("slice [%d:%d]; cap %d", e.Lo, e.Hi, e.Cap);
+	return fmt.Sprintf("slice [%d:%d]; cap %d", e.Lo, e.Hi, e.Cap)
 }
 
 type KeyError struct {
@@ -73,7 +73,7 @@ type NegativeLengthError struct {
 }
 
 func (e NegativeLengthError) String() string {
-	return fmt.Sprintf("negative length: %d", e.Len);
+	return fmt.Sprintf("negative length: %d", e.Len)
 }
 
 type NegativeCapacityError struct {
@@ -81,5 +81,5 @@ type NegativeCapacityError struct {
 }
 
 func (e NegativeCapacityError) String() string {
-	return fmt.Sprintf("negative capacity: %d", e.Len);
+	return fmt.Sprintf("negative capacity: %d", e.Len)
 }
diff --git a/src/pkg/exp/eval/bridge.go b/src/pkg/exp/eval/bridge.go
index d10aade9ed..1118ddd089 100644
--- a/src/pkg/exp/eval/bridge.go
+++ b/src/pkg/exp/eval/bridge.go
@@ -23,7 +23,7 @@ var (
 // interpreter Type.
 func TypeFromNative(t reflect.Type) Type {
 	if et, ok := evalTypes[t]; ok {
-		return et;
+		return et
 	}
 
 	var nt *NamedType;
@@ -36,42 +36,42 @@ func TypeFromNative(t reflect.Type) Type {
 	var et Type;
 	switch t := t.(type) {
 	case *reflect.BoolType:
-		et = BoolType;
+		et = BoolType
 	case *reflect.Float32Type:
-		et = Float32Type;
+		et = Float32Type
 	case *reflect.Float64Type:
-		et = Float64Type;
+		et = Float64Type
 	case *reflect.FloatType:
-		et = FloatType;
+		et = FloatType
 	case *reflect.Int16Type:
-		et = Int16Type;
+		et = Int16Type
 	case *reflect.Int32Type:
-		et = Int32Type;
+		et = Int32Type
 	case *reflect.Int64Type:
-		et = Int64Type;
+		et = Int64Type
 	case *reflect.Int8Type:
-		et = Int8Type;
+		et = Int8Type
 	case *reflect.IntType:
-		et = IntType;
+		et = IntType
 	case *reflect.StringType:
-		et = StringType;
+		et = StringType
 	case *reflect.Uint16Type:
-		et = Uint16Type;
+		et = Uint16Type
 	case *reflect.Uint32Type:
-		et = Uint32Type;
+		et = Uint32Type
 	case *reflect.Uint64Type:
-		et = Uint64Type;
+		et = Uint64Type
 	case *reflect.Uint8Type:
-		et = Uint8Type;
+		et = Uint8Type
 	case *reflect.UintType:
-		et = UintType;
+		et = UintType
 	case *reflect.UintptrType:
-		et = UintptrType;
+		et = UintptrType
 
 	case *reflect.ArrayType:
-		et = NewArrayType(int64(t.Len()), TypeFromNative(t.Elem()));
+		et = NewArrayType(int64(t.Len()), TypeFromNative(t.Elem()))
 	case *reflect.ChanType:
-		log.Crashf("%T not implemented", t);
+		log.Crashf("%T not implemented", t)
 	case *reflect.FuncType:
 		nin := t.NumIn();
 		// Variadic functions have DotDotDotType at the end
@@ -84,21 +84,21 @@ func TypeFromNative(t reflect.Type) Type {
 		}
 		in := make([]Type, nin);
 		for i := range in {
-			in[i] = TypeFromNative(t.In(i));
+			in[i] = TypeFromNative(t.In(i))
 		}
 		out := make([]Type, t.NumOut());
 		for i := range out {
-			out[i] = TypeFromNative(t.Out(i));
+			out[i] = TypeFromNative(t.Out(i))
 		}
 		et = NewFuncType(in, varidic, out);
 	case *reflect.InterfaceType:
-		log.Crashf("%T not implemented", t);
+		log.Crashf("%T not implemented", t)
 	case *reflect.MapType:
-		log.Crashf("%T not implemented", t);
+		log.Crashf("%T not implemented", t)
 	case *reflect.PtrType:
-		et = NewPtrType(TypeFromNative(t.Elem()));
+		et = NewPtrType(TypeFromNative(t.Elem()))
 	case *reflect.SliceType:
-		et = NewSliceType(TypeFromNative(t.Elem()));
+		et = NewSliceType(TypeFromNative(t.Elem()))
 	case *reflect.StructType:
 		n := t.NumField();
 		fields := make([]StructField, n);
@@ -111,9 +111,9 @@ func TypeFromNative(t reflect.Type) Type {
 		}
 		et = NewStructType(fields);
 	case *reflect.UnsafePointerType:
-		log.Crashf("%T not implemented", t);
+		log.Crashf("%T not implemented", t)
 	default:
-		log.Crashf("unexpected reflect.Type: %T", t);
+		log.Crashf("unexpected reflect.Type: %T", t)
 	}
 
 	if nt != nil {
@@ -147,7 +147,7 @@ func (f *nativeFunc) NewFrame() *Frame {
 }
 
 func (f *nativeFunc) Call(t *Thread) {
-	f.fn(t, t.f.Vars[0 : f.in], t.f.Vars[f.in : f.in + f.out]);
+	f.fn(t, t.f.Vars[0 : f.in], t.f.Vars[f.in : f.in + f.out])
 }
 
 // FuncFromNative creates an interpreter function from a native
@@ -155,7 +155,7 @@ func (f *nativeFunc) Call(t *Thread) {
 // interpreter Value's.  While somewhat inconvenient, this avoids
 // value marshalling.
 func FuncFromNative(fn func(*Thread, []Value, []Value), t *FuncType) FuncValue {
-	return &funcV{&nativeFunc{fn, len(t.In), len(t.Out)}};
+	return &funcV{&nativeFunc{fn, len(t.In), len(t.Out)}}
 }
 
 // FuncFromNativeTyped is like FuncFromNative, but constructs the
diff --git a/src/pkg/exp/eval/eval_test.go b/src/pkg/exp/eval/eval_test.go
index 307c504868..354ac01984 100644
--- a/src/pkg/exp/eval/eval_test.go
+++ b/src/pkg/exp/eval/eval_test.go
@@ -45,7 +45,7 @@ func (a test) run(t *testing.T, name string) {
 	for _, j := range a {
 		src := j.code;
 		if noisy {
-			println("code:", src);
+			println("code:", src)
 		}
 
 		code, err := w.Compile(src);
@@ -83,7 +83,7 @@ func (a test) run(t *testing.T, name string) {
 		}
 
 		if !j.noval && !reflect.DeepEqual(val, j.val) {
-			t.Errorf("%s: Run %s = %T(%v) want %T(%v)", name, src, val, val, j.val, j.val);
+			t.Errorf("%s: Run %s = %T(%v) want %T(%v)", name, src, val, val, j.val, j.val)
 		}
 	}
 }
@@ -91,7 +91,7 @@ func (a test) run(t *testing.T, name string) {
 func match(t *testing.T, err os.Error, pat string) bool {
 	ok, errstr := testing.MatchString(pat, err.String());
 	if errstr != "" {
-		t.Fatalf("compile regexp %s: %v", pat, errstr);
+		t.Fatalf("compile regexp %s: %v", pat, errstr)
 	}
 	return ok;
 }
@@ -109,7 +109,7 @@ func RErr(expr string, rterr string) test	{ return test([]job{job{code: expr, rt
 
 // Expression value
 func Val(expr string, val interface{}) test {
-	return test([]job{job{code: expr, val: toValue(val)}});
+	return test([]job{job{code: expr, val: toValue(val)}})
 }
 
 // Statement runs without error
@@ -119,7 +119,7 @@ func Run(stmts string) test	{ return test([]job{job{code: stmts, noval: true}})
 // TODO(rsc): Should be possible with Run but the parser
 // won't let us do both top-level and non-top-level statements.
 func Run2(stmt1, stmt2 string) test {
-	return test([]job{job{code: stmt1, noval: true}, job{code: stmt2, noval: true}});
+	return test([]job{job{code: stmt1, noval: true}, job{code: stmt2, noval: true}})
 }
 
 // Statement runs and test one expression's value
@@ -127,7 +127,7 @@ func Val1(stmts string, expr1 string, val1 interface{}) test {
 	return test([]job{
 		job{code: stmts, noval: true},
 		job{code: expr1, val: toValue(val1)},
-	});
+	})
 }
 
 // Statement runs and test two expressions' values
@@ -136,7 +136,7 @@ func Val2(stmts string, expr1 string, val1 interface{}, expr2 string, val2 inter
 		job{code: stmts, noval: true},
 		job{code: expr1, val: toValue(val1)},
 		job{code: expr2, val: toValue(val2)},
-	});
+	})
 }
 
 /*
@@ -167,33 +167,33 @@ func toValue(val interface{}) Value {
 		r := intV(val);
 		return &r;
 	case *bignum.Integer:
-		return &idealIntV{val};
+		return &idealIntV{val}
 	case float:
 		r := floatV(val);
 		return &r;
 	case *bignum.Rational:
-		return &idealFloatV{val};
+		return &idealFloatV{val}
 	case string:
 		r := stringV(val);
 		return &r;
 	case vstruct:
 		elems := make([]Value, len(val));
 		for i, e := range val {
-			elems[i] = toValue(e);
+			elems[i] = toValue(e)
 		}
 		r := structV(elems);
 		return &r;
 	case varray:
 		elems := make([]Value, len(val));
 		for i, e := range val {
-			elems[i] = toValue(e);
+			elems[i] = toValue(e)
 		}
 		r := arrayV(elems);
 		return &r;
 	case vslice:
-		return &sliceV{Slice{toValue(val.arr).(ArrayValue), int64(val.len), int64(val.cap)}};
+		return &sliceV{Slice{toValue(val.arr).(ArrayValue), int64(val.len), int64(val.cap)}}
 	case Func:
-		return &funcV{val};
+		return &funcV{val}
 	}
 	log.Crashf("toValue(%T) not implemented", val);
 	panic();
diff --git a/src/pkg/exp/eval/expr.go b/src/pkg/exp/eval/expr.go
index af6259a78d..d149c284a6 100644
--- a/src/pkg/exp/eval/expr.go
+++ b/src/pkg/exp/eval/expr.go
@@ -55,19 +55,19 @@ type exprInfo struct {
 }
 
 func (a *exprInfo) newExpr(t Type, desc string) *expr {
-	return &expr{exprInfo: a, t: t, desc: desc};
+	return &expr{exprInfo: a, t: t, desc: desc}
 }
 
 func (a *exprInfo) diag(format string, args ...) {
-	a.diagAt(&a.pos, format, args);
+	a.diagAt(&a.pos, format, args)
 }
 
 func (a *exprInfo) diagOpType(op token.Token, vt Type) {
-	a.diag("illegal operand type for '%v' operator\n\t%v", op, vt);
+	a.diag("illegal operand type for '%v' operator\n\t%v", op, vt)
 }
 
 func (a *exprInfo) diagOpTypes(op token.Token, lt Type, rt Type) {
-	a.diag("illegal operand types for '%v' operator\n\t%v\n\t%v", op, lt, rt);
+	a.diag("illegal operand types for '%v' operator\n\t%v\n\t%v", op, lt, rt)
 }
 
 /*
@@ -81,7 +81,7 @@ func (a *exprInfo) diagOpTypes(op token.Token, lt Type, rt Type) {
 // TODO(austin) Rename to resolveIdeal or something?
 func (a *expr) convertTo(t Type) *expr {
 	if !a.t.isIdeal() {
-		log.Crashf("attempted to convert from %v, expected ideal", a.t);
+		log.Crashf("attempted to convert from %v, expected ideal", a.t)
 	}
 
 	var rat *bignum.Rational;
@@ -103,7 +103,7 @@ func (a *expr) convertTo(t Type) *expr {
 		i := a.asIdealInt()();
 		rat = bignum.MakeRat(i, bignum.Nat(1));
 	default:
-		log.Crashf("unexpected ideal type %v", a.t);
+		log.Crashf("unexpected ideal type %v", a.t)
 	}
 
 	// Check bounds
@@ -140,9 +140,9 @@ func (a *expr) convertTo(t Type) *expr {
 		v := float64(n.Value())/float64(d.Value());
 		res.eval = func(*Thread) float64 { return v };
 	case *idealFloatType:
-		res.eval = func() *bignum.Rational { return rat };
+		res.eval = func() *bignum.Rational { return rat }
 	default:
-		log.Crashf("cannot convert to type %T", t);
+		log.Crashf("cannot convert to type %T", t)
 	}
 
 	return res;
@@ -163,7 +163,7 @@ func (a *expr) convertToInt(max int64, negErr string, errOp string) *expr {
 		}
 		bound := max;
 		if negErr == "slice" {
-			bound++;
+			bound++
 		}
 		if max != -1 && val.Cmp(bignum.Int(bound)) >= 0 {
 			a.diag("index %s exceeds length %d", val, max);
@@ -180,7 +180,7 @@ func (a *expr) convertToInt(max int64, negErr string, errOp string) *expr {
 
 	case *intType:
 		// Good as is
-		return a;
+		return a
 	}
 
 	a.diag("illegal operand type for %s\n\t%v", errOp, a.t);
@@ -195,7 +195,7 @@ func (a *expr) derefArray() *expr {
 		if _, ok := pt.Elem.lit().(*ArrayType); ok {
 			deref := a.compileStarExpr(a);
 			if deref == nil {
-				log.Crashf("failed to dereference *array");
+				log.Crashf("failed to dereference *array")
 			}
 			return deref;
 		}
@@ -309,7 +309,7 @@ func (a *assignCompiler) compile(b *block, lt Type) (func(Value, *Thread)) {
 
 	// Create unary MultiType for single LHS
 	if !isMT {
-		lmt = NewMultiType([]Type{lt});
+		lmt = NewMultiType([]Type{lt})
 	}
 
 	// Check that the assignment count matches
@@ -321,7 +321,7 @@ func (a *assignCompiler) compile(b *block, lt Type) (func(Value, *Thread)) {
 		if rcount > lcount {
 			msg = "too many";
 			if lcount > 0 {
-				pos = a.rs[lcount-1].pos;
+				pos = a.rs[lcount-1].pos
 			}
 		}
 		a.diagAt(&pos, "%s %ss for %s\n\t%s\n\t%s", msg, a.errPosName, a.errOp, lt, rmt);
@@ -340,7 +340,7 @@ func (a *assignCompiler) compile(b *block, lt Type) (func(Value, *Thread)) {
 		temp := b.DefineTemp(a.rmt);
 		tempIdx := temp.Index;
 		if tempIdx < 0 {
-			panicln("tempidx", tempIdx);
+			panicln("tempidx", tempIdx)
 		}
 		if a.isMapUnpack {
 			rf := a.rs[0].evalMapValue;
@@ -363,7 +363,7 @@ func (a *assignCompiler) compile(b *block, lt Type) (func(Value, *Thread)) {
 		a.rs = make([]*expr, len(a.rmt.Elems));
 		for i, t := range a.rmt.Elems {
 			if t.isIdeal() {
-				log.Crashf("Right side of unpack contains ideal: %s", rmt);
+				log.Crashf("Right side of unpack contains ideal: %s", rmt)
 			}
 			a.rs[i] = orig.newExpr(t, orig.desc);
 			index := i;
@@ -411,34 +411,34 @@ func (a *assignCompiler) compile(b *block, lt Type) (func(Value, *Thread)) {
 
 		if !lt.compat(rt, false) {
 			if len(a.rs) == 1 {
-				a.rs[0].diag("illegal operand types for %s\n\t%v\n\t%v", a.errOp, lt, rt);
+				a.rs[0].diag("illegal operand types for %s\n\t%v\n\t%v", a.errOp, lt, rt)
 			} else {
-				a.rs[i].diag("illegal operand types in %s %d of %s\n\t%v\n\t%v", a.errPosName, i+1, a.errOp, lt, rt);
+				a.rs[i].diag("illegal operand types in %s %d of %s\n\t%v\n\t%v", a.errPosName, i+1, a.errOp, lt, rt)
 			}
 			bad = true;
 		}
 	}
 	if bad {
-		return nil;
+		return nil
 	}
 
 	// Compile
 	if !isMT {
 		// Case 1
-		return genAssign(lt, a.rs[0]);
+		return genAssign(lt, a.rs[0])
 	}
 	// Case 2 or 3
 	as := make([]func(lv Value, t *Thread), len(a.rs));
 	for i, r := range a.rs {
-		as[i] = genAssign(lmt.Elems[i], r);
+		as[i] = genAssign(lmt.Elems[i], r)
 	}
 	return func(lv Value, t *Thread) {
 		if effect != nil {
-			effect(t);
+			effect(t)
 		}
 		lmv := lv.(multiV);
 		for i, a := range as {
-			a(lmv[i], t);
+			a(lmv[i], t)
 		}
 	};
 }
@@ -449,7 +449,7 @@ func (a *assignCompiler) compile(b *block, lt Type) (func(Value, *Thread)) {
 func (a *compiler) compileAssign(pos token.Position, b *block, lt Type, rs []*expr, errOp, errPosName string) (func(Value, *Thread)) {
 	ac, ok := a.checkAssign(pos, rs, errOp, errPosName);
 	if !ok {
-		return nil;
+		return nil
 	}
 	return ac.compile(b, lt);
 }
@@ -481,30 +481,30 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {
 	case *ast.BasicLit:
 		switch x.Kind {
 		case token.INT:
-			return ei.compileIntLit(string(x.Value));
+			return ei.compileIntLit(string(x.Value))
 		case token.FLOAT:
-			return ei.compileFloatLit(string(x.Value));
+			return ei.compileFloatLit(string(x.Value))
 		case token.CHAR:
-			return ei.compileCharLit(string(x.Value));
+			return ei.compileCharLit(string(x.Value))
 		case token.STRING:
-			return ei.compileStringLit(string(x.Value));
+			return ei.compileStringLit(string(x.Value))
 		default:
-			log.Crashf("unexpected basic literal type %v", x.Kind);
+			log.Crashf("unexpected basic literal type %v", x.Kind)
 		}
 
 	case *ast.CompositeLit:
-		goto notimpl;
+		goto notimpl
 
 	case *ast.FuncLit:
 		decl := ei.compileFuncType(a.block, x.Type);
 		if decl == nil {
 			// TODO(austin) Try compiling the body,
 			// perhaps with dummy argument definitions
-			return nil;
+			return nil
 		}
 		fn := ei.compileFunc(a.block, decl, x.Body);
 		if fn == nil {
-			return nil;
+			return nil
 		}
 		if a.constant {
 			a.diagAt(x, "function literal used in constant expression");
@@ -515,22 +515,22 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {
 	// Types
 	case *ast.ArrayType:
 		// TODO(austin) Use a multi-type case
-		goto typeexpr;
+		goto typeexpr
 
 	case *ast.ChanType:
-		goto typeexpr;
+		goto typeexpr
 
 	case *ast.Ellipsis:
-		goto typeexpr;
+		goto typeexpr
 
 	case *ast.FuncType:
-		goto typeexpr;
+		goto typeexpr
 
 	case *ast.InterfaceType:
-		goto typeexpr;
+		goto typeexpr
 
 	case *ast.MapType:
-		goto typeexpr;
+		goto typeexpr
 
 	// Remaining expressions
 	case *ast.BadExpr:
@@ -541,7 +541,7 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {
 	case *ast.BinaryExpr:
 		l, r := a.compile(x.X, false), a.compile(x.Y, false);
 		if l == nil || r == nil {
-			return nil;
+			return nil
 		}
 		return ei.compileBinaryExpr(x.Op, l, r);
 
@@ -554,14 +554,14 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {
 				argei := &exprInfo{a.compiler, arg.Pos()};
 				args[i] = argei.exprFromType(a.compileType(a.block, arg));
 			} else {
-				args[i] = a.compile(arg, false);
+				args[i] = a.compile(arg, false)
 			}
 			if args[i] == nil {
-				bad = true;
+				bad = true
 			}
 		}
 		if bad || l == nil {
-			return nil;
+			return nil
 		}
 		if a.constant {
 			a.diagAt(x, "function call in constant context");
@@ -572,13 +572,13 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {
 			a.diagAt(x, "type conversions not implemented");
 			return nil;
 		} else if ft, ok := l.t.(*FuncType); ok && ft.builtin != "" {
-			return ei.compileBuiltinCallExpr(a.block, ft, args);
+			return ei.compileBuiltinCallExpr(a.block, ft, args)
 		} else {
-			return ei.compileCallExpr(a.block, l, args);
+			return ei.compileCallExpr(a.block, l, args)
 		}
 
 	case *ast.Ident:
-		return ei.compileIdent(a.block, a.constant, callCtx, x.Value);
+		return ei.compileIdent(a.block, a.constant, callCtx, x.Value)
 
 	case *ast.IndexExpr:
 		if x.End != nil {
@@ -586,26 +586,26 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {
 			lo := a.compile(x.Index, false);
 			hi := a.compile(x.End, false);
 			if arr == nil || lo == nil || hi == nil {
-				return nil;
+				return nil
 			}
 			return ei.compileSliceExpr(arr, lo, hi);
 		}
 		l, r := a.compile(x.X, false), a.compile(x.Index, false);
 		if l == nil || r == nil {
-			return nil;
+			return nil
 		}
 		return ei.compileIndexExpr(l, r);
 
 	case *ast.KeyValueExpr:
-		goto notimpl;
+		goto notimpl
 
 	case *ast.ParenExpr:
-		return a.compile(x.X, callCtx);
+		return a.compile(x.X, callCtx)
 
 	case *ast.SelectorExpr:
 		v := a.compile(x.X, false);
 		if v == nil {
-			return nil;
+			return nil
 		}
 		return ei.compileSelectorExpr(v, x.Sel.Value);
 
@@ -614,11 +614,11 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {
 		// a pointer type (and thus a type conversion)
 		v := a.compile(x.X, callCtx);
 		if v == nil {
-			return nil;
+			return nil
 		}
 		if v.valType != nil {
 			// Turns out this was a pointer type, not a dereference
-			return ei.exprFromType(NewPtrType(v.valType));
+			return ei.exprFromType(NewPtrType(v.valType))
 		}
 		return ei.compileStarExpr(v);
 
@@ -628,24 +628,24 @@ func (a *exprCompiler) compile(x ast.Expr, callCtx bool) *expr {
 		for i, s := range x.Strings {
 			strings[i] = a.compile(s, false);
 			if strings[i] == nil {
-				bad = true;
+				bad = true
 			}
 		}
 		if bad {
-			return nil;
+			return nil
 		}
 		return ei.compileStringList(strings);
 
 	case *ast.StructType:
-		goto notimpl;
+		goto notimpl
 
 	case *ast.TypeAssertExpr:
-		goto notimpl;
+		goto notimpl
 
 	case *ast.UnaryExpr:
 		v := a.compile(x.X, false);
 		if v == nil {
-			return nil;
+			return nil
 		}
 		return ei.compileUnaryExpr(x.Op, v);
 	}
@@ -666,7 +666,7 @@ notimpl:
 
 func (a *exprInfo) exprFromType(t Type) *expr {
 	if t == nil {
-		return nil;
+		return nil
 	}
 	expr := a.newExpr(nil, "type");
 	expr.valType = t;
@@ -692,7 +692,7 @@ func (a *exprInfo) compileIdent(b *block, constant bool, callCtx bool, name stri
 			// Otherwise, we leave the evaluators empty
 			// because this is handled specially
 		} else {
-			expr.genConstant(def.Value);
+			expr.genConstant(def.Value)
 		}
 		return expr;
 	case *Variable:
@@ -701,12 +701,12 @@ func (a *exprInfo) compileIdent(b *block, constant bool, callCtx bool, name stri
 			return nil;
 		}
 		if bl.global {
-			return a.compileGlobalVariable(def);
+			return a.compileGlobalVariable(def)
 		}
 		return a.compileVariable(level, def);
 	case Type:
 		if callCtx {
-			return a.exprFromType(def);
+			return a.exprFromType(def)
 		}
 		a.diag("type %v used as expression", name);
 		return nil;
@@ -733,7 +733,7 @@ func (a *exprInfo) compileGlobalVariable(v *Variable) *expr {
 		return nil;
 	}
 	if v.Init == nil {
-		v.Init = v.Type.Zero();
+		v.Init = v.Type.Zero()
 	}
 	expr := a.newExpr(v.Type, "variable");
 	val := v.Init;
@@ -770,7 +770,7 @@ func (a *exprInfo) compileCharLit(lit string) *expr {
 func (a *exprInfo) compileFloatLit(lit string) *expr {
 	f, _, n := bignum.RatFromString(lit, 0);
 	if n != len(lit) {
-		log.Crashf("malformed float literal %s at %v passed parser", lit, a.pos);
+		log.Crashf("malformed float literal %s at %v passed parser", lit, a.pos)
 	}
 	expr := a.newExpr(IdealFloatType, "float literal");
 	expr.eval = func() *bignum.Rational { return f };
@@ -799,7 +799,7 @@ func (a *exprInfo) compileStringLit(lit string) *expr {
 func (a *exprInfo) compileStringList(list []*expr) *expr {
 	ss := make([]string, len(list));
 	for i, s := range list {
-		ss[i] = s.asString()(nil);
+		ss[i] = s.asString()(nil)
 	}
 	return a.compileString(strings.Join(ss, ""));
 }
@@ -825,10 +825,10 @@ func (a *exprInfo) compileSelectorExpr(v *expr, name string) *expr {
 			amberr = "";
 
 		case depth == bestDepth:
-			ambig = true;
+			ambig = true
 
 		default:
-			log.Crashf("Marked field at depth %d, but already found one at depth %d", depth, bestDepth);
+			log.Crashf("Marked field at depth %d, but already found one at depth %d", depth, bestDepth)
 		}
 		amberr += "\n\t"+pathName[1:len(pathName)];
 	};
@@ -849,12 +849,12 @@ func (a *exprInfo) compileSelectorExpr(v *expr, name string) *expr {
 	find = func(t Type, depth int, pathName string) (func(*expr) *expr) {
 		// Don't bother looking if we've found something shallower
 		if bestDepth != -1 && bestDepth < depth {
-			return nil;
+			return nil
 		}
 
 		// Don't check the same type twice and avoid loops
 		if _, ok := visited[t]; ok {
-			return nil;
+			return nil
 		}
 		visited[t] = true;
 
@@ -888,11 +888,11 @@ func (a *exprInfo) compileSelectorExpr(v *expr, name string) *expr {
 				case f.Anonymous:
 					sub = find(f.Type, depth+1, pathName + "." + f.Name);
 					if sub == nil {
-						continue;
+						continue
 					}
 
 				default:
-					continue;
+					continue
 				}
 
 				// We found something.  Create a
@@ -901,7 +901,7 @@ func (a *exprInfo) compileSelectorExpr(v *expr, name string) *expr {
 				index := i;
 				builder = func(parent *expr) *expr {
 					if deref {
-						parent = a.compileStarExpr(parent);
+						parent = a.compileStarExpr(parent)
 					}
 					expr := a.newExpr(ft, "selector expression");
 					pf := parent.asStruct();
@@ -941,10 +941,10 @@ func (a *exprInfo) compileSliceExpr(arr, lo, hi *expr) *expr {
 		maxIndex = lt.Len;
 
 	case *SliceType:
-		at = lt;
+		at = lt
 
 	case *stringType:
-		at = lt;
+		at = lt
 
 	default:
 		a.diag("cannot slice %v", arr.t);
@@ -958,7 +958,7 @@ func (a *exprInfo) compileSliceExpr(arr, lo, hi *expr) *expr {
 	lo = lo.convertToInt(maxIndex, "slice", "slice");
 	hi = hi.convertToInt(maxIndex, "slice", "slice");
 	if lo == nil || hi == nil {
-		return nil;
+		return nil
 	}
 
 	expr := a.newExpr(at, "slice expression");
@@ -973,7 +973,7 @@ func (a *exprInfo) compileSliceExpr(arr, lo, hi *expr) *expr {
 		expr.eval = func(t *Thread) Slice {
 			arr, lo, hi := arrf(t), lof(t), hif(t);
 			if lo > hi || hi > bound || lo < 0 {
-				t.Abort(SliceError{lo, hi, bound});
+				t.Abort(SliceError{lo, hi, bound})
 			}
 			return Slice{arr.Sub(lo, bound-lo), hi-lo, bound-lo};
 		};
@@ -983,7 +983,7 @@ func (a *exprInfo) compileSliceExpr(arr, lo, hi *expr) *expr {
 		expr.eval = func(t *Thread) Slice {
 			arr, lo, hi := arrf(t), lof(t), hif(t);
 			if lo > hi || hi > arr.Cap || lo < 0 {
-				t.Abort(SliceError{lo, hi, arr.Cap});
+				t.Abort(SliceError{lo, hi, arr.Cap})
 			}
 			return Slice{arr.Base.Sub(lo, arr.Cap - lo), hi-lo, arr.Cap - lo};
 		};
@@ -996,13 +996,13 @@ func (a *exprInfo) compileSliceExpr(arr, lo, hi *expr) *expr {
 		expr.eval = func(t *Thread) string {
 			arr, lo, hi := arrf(t), lof(t), hif(t);
 			if lo > hi || hi > int64(len(arr)) || lo < 0 {
-				t.Abort(SliceError{lo, hi, int64(len(arr))});
+				t.Abort(SliceError{lo, hi, int64(len(arr))})
 			}
 			return arr[lo:hi];
 		};
 
 	default:
-		log.Crashf("unexpected left operand type %T", arr.t.lit());
+		log.Crashf("unexpected left operand type %T", arr.t.lit())
 	}
 
 	return expr;
@@ -1035,7 +1035,7 @@ func (a *exprInfo) compileIndexExpr(l, r *expr) *expr {
 		if r.t.isIdeal() {
 			r = r.convertTo(lt.Key);
 			if r == nil {
-				return nil;
+				return nil
 			}
 		}
 		if !lt.Key.compat(r.t, false) {
@@ -1055,7 +1055,7 @@ func (a *exprInfo) compileIndexExpr(l, r *expr) *expr {
 		// believe that's wrong.
 		r = r.convertToInt(maxIndex, "index", "index");
 		if r == nil {
-			return nil;
+			return nil
 		}
 	}
 
@@ -1070,7 +1070,7 @@ func (a *exprInfo) compileIndexExpr(l, r *expr) *expr {
 		expr.genValue(func(t *Thread) Value {
 			l, r := lf(t), rf(t);
 			if r < 0 || r >= bound {
-				t.Abort(IndexError{r, bound});
+				t.Abort(IndexError{r, bound})
 			}
 			return l.Elem(t, r);
 		});
@@ -1081,10 +1081,10 @@ func (a *exprInfo) compileIndexExpr(l, r *expr) *expr {
 		expr.genValue(func(t *Thread) Value {
 			l, r := lf(t), rf(t);
 			if l.Base == nil {
-				t.Abort(NilPointerError{});
+				t.Abort(NilPointerError{})
 			}
 			if r < 0 || r >= l.Len {
-				t.Abort(IndexError{r, l.Len});
+				t.Abort(IndexError{r, l.Len})
 			}
 			return l.Base.Elem(t, r);
 		});
@@ -1097,7 +1097,7 @@ func (a *exprInfo) compileIndexExpr(l, r *expr) *expr {
 		expr.eval = func(t *Thread) uint64 {
 			l, r := lf(t), rf(t);
 			if r < 0 || r >= int64(len(l)) {
-				t.Abort(IndexError{r, int64(len(l))});
+				t.Abort(IndexError{r, int64(len(l))})
 			}
 			return uint64(l[r]);
 		};
@@ -1109,11 +1109,11 @@ func (a *exprInfo) compileIndexExpr(l, r *expr) *expr {
 			m := lf(t);
 			k := rf(t);
 			if m == nil {
-				t.Abort(NilPointerError{});
+				t.Abort(NilPointerError{})
 			}
 			e := m.Elem(t, k);
 			if e == nil {
-				t.Abort(KeyError{k});
+				t.Abort(KeyError{k})
 			}
 			return e;
 		});
@@ -1122,11 +1122,11 @@ func (a *exprInfo) compileIndexExpr(l, r *expr) *expr {
 		expr.evalAddr = nil;
 		expr.evalMapValue = func(t *Thread) (Map, interface{}) {
 			// TODO(austin) Key check?  nil check?
-			return lf(t), rf(t);
+			return lf(t), rf(t)
 		};
 
 	default:
-		log.Crashf("unexpected left operand type %T", l.t.lit());
+		log.Crashf("unexpected left operand type %T", l.t.lit())
 	}
 
 	return expr;
@@ -1157,28 +1157,28 @@ func (a *exprInfo) compileCallExpr(b *block, l *expr, as []*expr) *expr {
 	nin := len(lt.In);
 	assign := a.compileAssign(a.pos, b, NewMultiType(lt.In), as, "function call", "argument");
 	if assign == nil {
-		return nil;
+		return nil
 	}
 
 	var t Type;
 	nout := len(lt.Out);
 	switch nout {
 	case 0:
-		t = EmptyType;
+		t = EmptyType
 	case 1:
-		t = lt.Out[0];
+		t = lt.Out[0]
 	default:
-		t = NewMultiType(lt.Out);
+		t = NewMultiType(lt.Out)
 	}
 	expr := a.newExpr(t, "function call");
 
 	// Gather argument and out types to initialize frame variables
 	vts := make([]Type, nin+nout);
 	for i, t := range lt.In {
-		vts[i] = t;
+		vts[i] = t
 	}
 	for i, t := range lt.Out {
-		vts[i+nin] = t;
+		vts[i+nin] = t
 	}
 
 	// Compile
@@ -1187,7 +1187,7 @@ func (a *exprInfo) compileCallExpr(b *block, l *expr, as []*expr) *expr {
 		fun := lf(t);
 		fr := fun.NewFrame();
 		for i, t := range vts {
-			fr.Vars[i] = t.Zero();
+			fr.Vars[i] = t.Zero()
 		}
 		assign(multiV(fr.Vars[0:nin]), t);
 		oldf := t.f;
@@ -1216,7 +1216,7 @@ func (a *exprInfo) compileBuiltinCallExpr(b *block, ft *FuncType, as []*expr) *e
 	switch ft {
 	case capType:
 		if !checkCount(1, 1) {
-			return nil;
+			return nil
 		}
 		arg := as[0].derefArray();
 		expr := a.newExpr(IntType, "function call");
@@ -1241,7 +1241,7 @@ func (a *exprInfo) compileBuiltinCallExpr(b *block, ft *FuncType, as []*expr) *e
 
 	case lenType:
 		if !checkCount(1, 1) {
-			return nil;
+			return nil
 		}
 		arg := as[0].derefArray();
 		expr := a.newExpr(IntType, "function call");
@@ -1267,7 +1267,7 @@ func (a *exprInfo) compileBuiltinCallExpr(b *block, ft *FuncType, as []*expr) *e
 				// uninitialized map?
 				m := vf(t);
 				if m == nil {
-					return 0;
+					return 0
 				}
 				return m.Len(t);
 			};
@@ -1282,7 +1282,7 @@ func (a *exprInfo) compileBuiltinCallExpr(b *block, ft *FuncType, as []*expr) *e
 
 	case makeType:
 		if !checkCount(1, 3) {
-			return nil;
+			return nil
 		}
 		// XXX(Spec) What are the types of the
 		// arguments?  Do they have to be ints?  6g
@@ -1292,14 +1292,14 @@ func (a *exprInfo) compileBuiltinCallExpr(b *block, ft *FuncType, as []*expr) *e
 		if len(as) > 1 {
 			lenexpr = as[1].convertToInt(-1, "length", "make function");
 			if lenexpr == nil {
-				return nil;
+				return nil
 			}
 			lenf = lenexpr.asInt();
 		}
 		if len(as) > 2 {
 			capexpr = as[2].convertToInt(-1, "capacity", "make function");
 			if capexpr == nil {
-				return nil;
+				return nil
 			}
 			capf = capexpr.asInt();
 		}
@@ -1312,7 +1312,7 @@ func (a *exprInfo) compileBuiltinCallExpr(b *block, ft *FuncType, as []*expr) *e
 			// parameters specifying the length and
 			// optionally the capacity.
 			if !checkCount(2, 3) {
-				return nil;
+				return nil
 			}
 			et := t.Elem;
 			expr := a.newExpr(t, "function call");
@@ -1321,24 +1321,24 @@ func (a *exprInfo) compileBuiltinCallExpr(b *block, ft *FuncType, as []*expr) *e
 				// XXX(Spec) What if len or cap is
 				// negative?  The runtime panics.
 				if l < 0 {
-					t.Abort(NegativeLengthError{l});
+					t.Abort(NegativeLengthError{l})
 				}
 				c := l;
 				if capf != nil {
 					c = capf(t);
 					if c < 0 {
-						t.Abort(NegativeCapacityError{c});
+						t.Abort(NegativeCapacityError{c})
 					}
 					// XXX(Spec) What happens if
 					// len > cap?  The runtime
 					// sets cap to len.
 					if l > c {
-						c = l;
+						c = l
 					}
 				}
 				base := arrayV(make([]Value, c));
 				for i := int64(0); i < c; i++ {
-					base[i] = et.Zero();
+					base[i] = et.Zero()
 				}
 				return Slice{&base, l, c};
 			};
@@ -1350,12 +1350,12 @@ func (a *exprInfo) compileBuiltinCallExpr(b *block, ft *FuncType, as []*expr) *e
 			// type and an optional capacity hint as
 			// arguments.
 			if !checkCount(1, 2) {
-				return nil;
+				return nil
 			}
 			expr := a.newExpr(t, "function call");
 			expr.eval = func(t *Thread) Map {
 				if lenf == nil {
-					return make(evalMap);
+					return make(evalMap)
 				}
 				l := lenf(t);
 				return make(evalMap, l);
@@ -1375,7 +1375,7 @@ func (a *exprInfo) compileBuiltinCallExpr(b *block, ft *FuncType, as []*expr) *e
 
 	case newType:
 		if !checkCount(1, 1) {
-			return nil;
+			return nil
 		}
 
 		t := as[0].valType;
@@ -1386,14 +1386,14 @@ func (a *exprInfo) compileBuiltinCallExpr(b *block, ft *FuncType, as []*expr) *e
 	case panicType, paniclnType, printType, printlnType:
 		evals := make([]func(*Thread) interface{}, len(as));
 		for i, x := range as {
-			evals[i] = x.asInterface();
+			evals[i] = x.asInterface()
 		}
 		spaces := ft == paniclnType || ft == printlnType;
 		newline := ft != printType;
 		printer := func(t *Thread) {
 			for i, eval := range evals {
 				if i > 0 && spaces {
-					print(" ");
+					print(" ")
 				}
 				v := eval(t);
 				type stringer interface {
@@ -1401,23 +1401,23 @@ func (a *exprInfo) compileBuiltinCallExpr(b *block, ft *FuncType, as []*expr) *e
 				}
 				switch v1 := v.(type) {
 				case bool:
-					print(v1);
+					print(v1)
 				case uint64:
-					print(v1);
+					print(v1)
 				case int64:
-					print(v1);
+					print(v1)
 				case float64:
-					print(v1);
+					print(v1)
 				case string:
-					print(v1);
+					print(v1)
 				case stringer:
-					print(v1.String());
+					print(v1.String())
 				default:
-					print("???");
+					print("???")
 				}
 			}
 			if newline {
-				print("\n");
+				print("\n")
 			}
 		};
 		expr := a.newExpr(EmptyType, "print");
@@ -1426,7 +1426,7 @@ func (a *exprInfo) compileBuiltinCallExpr(b *block, ft *FuncType, as []*expr) *e
 			expr.exec = func(t *Thread) {
 				printer(t);
 				t.Abort(os.NewError("panic"));
-			};
+			}
 		}
 		return expr;
 	}
@@ -1443,7 +1443,7 @@ func (a *exprInfo) compileStarExpr(v *expr) *expr {
 		expr.genValue(func(t *Thread) Value {
 			v := vf(t);
 			if v == nil {
-				t.Abort(NilPointerError{});
+				t.Abort(NilPointerError{})
 			}
 			return v;
 		});
@@ -1498,10 +1498,10 @@ func (a *exprInfo) compileUnaryExpr(op token.Token, v *expr) *expr {
 		t = NewPtrType(v.t);
 
 	case token.ARROW:
-		log.Crashf("Unary op %v not implemented", op);
+		log.Crashf("Unary op %v not implemented", op)
 
 	default:
-		log.Crashf("unknown unary operator %v", op);
+		log.Crashf("unknown unary operator %v", op)
 	}
 
 	desc, ok := unaryOpDescs[op];
@@ -1519,20 +1519,20 @@ func (a *exprInfo) compileUnaryExpr(op token.Token, v *expr) *expr {
 		expr.desc = desc;
 
 	case token.SUB:
-		expr.genUnaryOpNeg(v);
+		expr.genUnaryOpNeg(v)
 
 	case token.NOT:
-		expr.genUnaryOpNot(v);
+		expr.genUnaryOpNot(v)
 
 	case token.XOR:
-		expr.genUnaryOpXor(v);
+		expr.genUnaryOpXor(v)
 
 	case token.AND:
 		vf := v.evalAddr;
 		expr.eval = func(t *Thread) Value { return vf(t) };
 
 	default:
-		log.Crashf("Compilation of unary op %v not implemented", op);
+		log.Crashf("Compilation of unary op %v not implemented", op)
 	}
 
 	return expr;
@@ -1564,12 +1564,12 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 		// number, the ideal number is converted to match the
 		// type of the other operand.
 		if (l.t.isInteger() || l.t.isFloat()) && !l.t.isIdeal() && r.t.isIdeal() {
-			r = r.convertTo(l.t);
+			r = r.convertTo(l.t)
 		} else if (r.t.isInteger() || r.t.isFloat()) && !r.t.isIdeal() && l.t.isIdeal() {
-			l = l.convertTo(r.t);
+			l = l.convertTo(r.t)
 		}
 		if l == nil || r == nil {
-			return nil;
+			return nil
 		}
 
 		// Except in shift expressions, if both operands are
@@ -1577,12 +1577,12 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 		// is converted to ideal float.
 		if l.t.isIdeal() && r.t.isIdeal() {
 			if l.t.isInteger() && r.t.isFloat() {
-				l = l.convertTo(r.t);
+				l = l.convertTo(r.t)
 			} else if l.t.isFloat() && r.t.isInteger() {
-				r = r.convertTo(l.t);
+				r = r.convertTo(l.t)
 			}
 			if l == nil || r == nil {
-				return nil;
+				return nil
 			}
 		}
 	}
@@ -1594,7 +1594,7 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 	floats := func() bool { return l.t.isFloat() && r.t.isFloat() };
 	strings := func() bool {
 		// TODO(austin) Deal with named types
-		return l.t == StringType && r.t == StringType;
+		return l.t == StringType && r.t == StringType
 	};
 	booleans := func() bool { return l.t.isBoolean() && r.t.isBoolean() };
 
@@ -1642,13 +1642,13 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 		if r.t.isIdeal() {
 			r2 := r.convertTo(UintType);
 			if r2 == nil {
-				return nil;
+				return nil
 			}
 
 			// If the left operand is not ideal, convert
 			// the right to not ideal.
 			if !l.t.isIdeal() {
-				r = r2;
+				r = r2
 			}
 
 			// If both are ideal, but the right side isn't
@@ -1656,7 +1656,7 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 			if l.t.isIdeal() && !r.t.isInteger() {
 				r = r.convertTo(IdealIntType);
 				if r == nil {
-					log.Crashf("conversion to uintType succeeded, but conversion to idealIntType failed");
+					log.Crashf("conversion to uintType succeeded, but conversion to idealIntType failed")
 				}
 			}
 		} else if _, ok := r.t.lit().(*uintType); !ok {
@@ -1672,7 +1672,7 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 
 			l = l.convertTo(IntType);
 			if l == nil {
-				return nil;
+				return nil
 			}
 		}
 
@@ -1685,7 +1685,7 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 
 	case token.LOR, token.LAND:
 		if !booleans() {
-			return nil;
+			return nil
 		}
 		// XXX(Spec) There's no mention of *which* boolean
 		// type the logical operators return.  From poking at
@@ -1767,7 +1767,7 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 		t = BoolType;
 
 	default:
-		log.Crashf("unknown binary operator %v", op);
+		log.Crashf("unknown binary operator %v", op)
 	}
 
 	desc, ok := binOpDescs[op];
@@ -1792,31 +1792,31 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 	expr := a.newExpr(t, desc);
 	switch op {
 	case token.ADD:
-		expr.genBinOpAdd(l, r);
+		expr.genBinOpAdd(l, r)
 
 	case token.SUB:
-		expr.genBinOpSub(l, r);
+		expr.genBinOpSub(l, r)
 
 	case token.MUL:
-		expr.genBinOpMul(l, r);
+		expr.genBinOpMul(l, r)
 
 	case token.QUO:
-		expr.genBinOpQuo(l, r);
+		expr.genBinOpQuo(l, r)
 
 	case token.REM:
-		expr.genBinOpRem(l, r);
+		expr.genBinOpRem(l, r)
 
 	case token.AND:
-		expr.genBinOpAnd(l, r);
+		expr.genBinOpAnd(l, r)
 
 	case token.OR:
-		expr.genBinOpOr(l, r);
+		expr.genBinOpOr(l, r)
 
 	case token.XOR:
-		expr.genBinOpXor(l, r);
+		expr.genBinOpXor(l, r)
 
 	case token.AND_NOT:
-		expr.genBinOpAndNot(l, r);
+		expr.genBinOpAndNot(l, r)
 
 	case token.SHL:
 		if l.t.isIdeal() {
@@ -1831,7 +1831,7 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 			val := lv.Shl(uint(rv.Value()));
 			expr.eval = func() *bignum.Integer { return val };
 		} else {
-			expr.genBinOpShl(l, r);
+			expr.genBinOpShl(l, r)
 		}
 
 	case token.SHR:
@@ -1841,35 +1841,35 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 			val := lv.Shr(uint(rv.Value()));
 			expr.eval = func() *bignum.Integer { return val };
 		} else {
-			expr.genBinOpShr(l, r);
+			expr.genBinOpShr(l, r)
 		}
 
 	case token.LSS:
-		expr.genBinOpLss(l, r);
+		expr.genBinOpLss(l, r)
 
 	case token.GTR:
-		expr.genBinOpGtr(l, r);
+		expr.genBinOpGtr(l, r)
 
 	case token.LEQ:
-		expr.genBinOpLeq(l, r);
+		expr.genBinOpLeq(l, r)
 
 	case token.GEQ:
-		expr.genBinOpGeq(l, r);
+		expr.genBinOpGeq(l, r)
 
 	case token.EQL:
-		expr.genBinOpEql(l, r);
+		expr.genBinOpEql(l, r)
 
 	case token.NEQ:
-		expr.genBinOpNeq(l, r);
+		expr.genBinOpNeq(l, r)
 
 	case token.LAND:
-		expr.genBinOpLogAnd(l, r);
+		expr.genBinOpLogAnd(l, r)
 
 	case token.LOR:
-		expr.genBinOpLogOr(l, r);
+		expr.genBinOpLogOr(l, r)
 
 	default:
-		log.Crashf("Compilation of binary op %v not implemented", op);
+		log.Crashf("Compilation of binary op %v not implemented", op)
 	}
 
 	return expr;
@@ -1880,14 +1880,14 @@ func (a *exprInfo) compileBinaryExpr(op token.Token, l, r *expr) *expr {
 func (a *compiler) compileArrayLen(b *block, expr ast.Expr) (int64, bool) {
 	lenExpr := a.compileExpr(b, true, expr);
 	if lenExpr == nil {
-		return 0, false;
+		return 0, false
 	}
 
 	// XXX(Spec) Are ideal floats with no fractional part okay?
 	if lenExpr.t.isIdeal() {
 		lenExpr = lenExpr.convertTo(IntType);
 		if lenExpr == nil {
-			return 0, false;
+			return 0, false
 		}
 	}
 
@@ -1898,9 +1898,9 @@ func (a *compiler) compileArrayLen(b *block, expr ast.Expr) (int64, bool) {
 
 	switch lenExpr.t.lit().(type) {
 	case *intType:
-		return lenExpr.asInt()(nil), true;
+		return lenExpr.asInt()(nil), true
 	case *uintType:
-		return int64(lenExpr.asUint()(nil)), true;
+		return int64(lenExpr.asUint()(nil)), true
 	}
 	log.Crashf("unexpected integer type %T", lenExpr.t);
 	return 0, false;
@@ -1911,7 +1911,7 @@ func (a *compiler) compileExpr(b *block, constant bool, expr ast.Expr) *expr {
 	nerr := a.numError();
 	e := ec.compile(expr, false);
 	if e == nil && nerr == a.numError() {
-		log.Crashf("expression compilation failed without reporting errors");
+		log.Crashf("expression compilation failed without reporting errors")
 	}
 	return e;
 }
@@ -1928,13 +1928,13 @@ func (a *expr) extractEffect(b *block, errOp string) (func(*Thread), *expr) {
 	// Create "&a" if a is addressable
 	rhs := a;
 	if a.evalAddr != nil {
-		rhs = a.compileUnaryExpr(token.AND, rhs);
+		rhs = a.compileUnaryExpr(token.AND, rhs)
 	}
 
 	// Create temp
 	ac, ok := a.checkAssign(a.pos, []*expr{rhs}, errOp, "");
 	if !ok {
-		return nil, nil;
+		return nil, nil
 	}
 	if len(ac.rmt.Elems) != 1 {
 		a.diag("multi-valued expression not allowed in %s", errOp);
@@ -1945,11 +1945,11 @@ func (a *expr) extractEffect(b *block, errOp string) (func(*Thread), *expr) {
 		// It's too bad we have to duplicate this rule.
 		switch {
 		case tempType.isInteger():
-			tempType = IntType;
+			tempType = IntType
 		case tempType.isFloat():
-			tempType = FloatType;
+			tempType = FloatType
 		default:
-			log.Crashf("unexpected ideal type %v", tempType);
+			log.Crashf("unexpected ideal type %v", tempType)
 		}
 	}
 	temp := b.DefineTemp(tempType);
@@ -1958,7 +1958,7 @@ func (a *expr) extractEffect(b *block, errOp string) (func(*Thread), *expr) {
 	// Create "temp := rhs"
 	assign := ac.compile(b, tempType);
 	if assign == nil {
-		log.Crashf("compileAssign type check failed");
+		log.Crashf("compileAssign type check failed")
 	}
 
 	effect := func(t *Thread) {
@@ -1970,12 +1970,12 @@ func (a *expr) extractEffect(b *block, errOp string) (func(*Thread), *expr) {
 	// Generate "temp" or "*temp"
 	getTemp := a.compileVariable(0, temp);
 	if a.evalAddr == nil {
-		return effect, getTemp;
+		return effect, getTemp
 	}
 
 	deref := a.compileStarExpr(getTemp);
 	if deref == nil {
-		return nil, nil;
+		return nil, nil
 	}
 	return effect, deref;
 }
diff --git a/src/pkg/exp/eval/expr1.go b/src/pkg/exp/eval/expr1.go
index c77c99934f..c4960abbcb 100644
--- a/src/pkg/exp/eval/expr1.go
+++ b/src/pkg/exp/eval/expr1.go
@@ -14,67 +14,67 @@ import (
  */
 func (a *expr) asBool() (func(*Thread) bool)	{ return a.eval.(func(*Thread) bool) }
 func (a *expr) asUint() (func(*Thread) uint64) {
-	return a.eval.(func(*Thread) uint64);
+	return a.eval.(func(*Thread) uint64)
 }
 func (a *expr) asInt() (func(*Thread) int64)	{ return a.eval.(func(*Thread) int64) }
 func (a *expr) asIdealInt() (func() *bignum.Integer) {
-	return a.eval.(func() *bignum.Integer);
+	return a.eval.(func() *bignum.Integer)
 }
 func (a *expr) asFloat() (func(*Thread) float64) {
-	return a.eval.(func(*Thread) float64);
+	return a.eval.(func(*Thread) float64)
 }
 func (a *expr) asIdealFloat() (func() *bignum.Rational) {
-	return a.eval.(func() *bignum.Rational);
+	return a.eval.(func() *bignum.Rational)
 }
 func (a *expr) asString() (func(*Thread) string) {
-	return a.eval.(func(*Thread) string);
+	return a.eval.(func(*Thread) string)
 }
 func (a *expr) asArray() (func(*Thread) ArrayValue) {
-	return a.eval.(func(*Thread) ArrayValue);
+	return a.eval.(func(*Thread) ArrayValue)
 }
 func (a *expr) asStruct() (func(*Thread) StructValue) {
-	return a.eval.(func(*Thread) StructValue);
+	return a.eval.(func(*Thread) StructValue)
 }
 func (a *expr) asPtr() (func(*Thread) Value)	{ return a.eval.(func(*Thread) Value) }
 func (a *expr) asFunc() (func(*Thread) Func)	{ return a.eval.(func(*Thread) Func) }
 func (a *expr) asSlice() (func(*Thread) Slice) {
-	return a.eval.(func(*Thread) Slice);
+	return a.eval.(func(*Thread) Slice)
 }
 func (a *expr) asMap() (func(*Thread) Map)	{ return a.eval.(func(*Thread) Map) }
 func (a *expr) asMulti() (func(*Thread) []Value) {
-	return a.eval.(func(*Thread) []Value);
+	return a.eval.(func(*Thread) []Value)
 }
 
 func (a *expr) asInterface() (func(*Thread) interface{}) {
 	switch sf := a.eval.(type) {
 	case func(t *Thread) bool:
-		return func(t *Thread) interface{} { return sf(t) };
+		return func(t *Thread) interface{} { return sf(t) }
 	case func(t *Thread) uint64:
-		return func(t *Thread) interface{} { return sf(t) };
+		return func(t *Thread) interface{} { return sf(t) }
 	case func(t *Thread) int64:
-		return func(t *Thread) interface{} { return sf(t) };
+		return func(t *Thread) interface{} { return sf(t) }
 	case func() *bignum.Integer:
-		return func(*Thread) interface{} { return sf() };
+		return func(*Thread) interface{} { return sf() }
 	case func(t *Thread) float64:
-		return func(t *Thread) interface{} { return sf(t) };
+		return func(t *Thread) interface{} { return sf(t) }
 	case func() *bignum.Rational:
-		return func(*Thread) interface{} { return sf() };
+		return func(*Thread) interface{} { return sf() }
 	case func(t *Thread) string:
-		return func(t *Thread) interface{} { return sf(t) };
+		return func(t *Thread) interface{} { return sf(t) }
 	case func(t *Thread) ArrayValue:
-		return func(t *Thread) interface{} { return sf(t) };
+		return func(t *Thread) interface{} { return sf(t) }
 	case func(t *Thread) StructValue:
-		return func(t *Thread) interface{} { return sf(t) };
+		return func(t *Thread) interface{} { return sf(t) }
 	case func(t *Thread) Value:
-		return func(t *Thread) interface{} { return sf(t) };
+		return func(t *Thread) interface{} { return sf(t) }
 	case func(t *Thread) Func:
-		return func(t *Thread) interface{} { return sf(t) };
+		return func(t *Thread) interface{} { return sf(t) }
 	case func(t *Thread) Slice:
-		return func(t *Thread) interface{} { return sf(t) };
+		return func(t *Thread) interface{} { return sf(t) }
 	case func(t *Thread) Map:
-		return func(t *Thread) interface{} { return sf(t) };
+		return func(t *Thread) interface{} { return sf(t) }
 	default:
-		log.Crashf("unexpected expression node type %T at %v", a.eval, a.pos);
+		log.Crashf("unexpected expression node type %T at %v", a.eval, a.pos)
 	}
 	panic();
 }
@@ -86,35 +86,35 @@ func (a *expr) asInterface() (func(*Thread) interface{}) {
 func (a *expr) genConstant(v Value) {
 	switch a.t.lit().(type) {
 	case *boolType:
-		a.eval = func(t *Thread) bool { return v.(BoolValue).Get(t) };
+		a.eval = func(t *Thread) bool { return v.(BoolValue).Get(t) }
 	case *uintType:
-		a.eval = func(t *Thread) uint64 { return v.(UintValue).Get(t) };
+		a.eval = func(t *Thread) uint64 { return v.(UintValue).Get(t) }
 	case *intType:
-		a.eval = func(t *Thread) int64 { return v.(IntValue).Get(t) };
+		a.eval = func(t *Thread) int64 { return v.(IntValue).Get(t) }
 	case *idealIntType:
 		val := v.(IdealIntValue).Get();
 		a.eval = func() *bignum.Integer { return val };
 	case *floatType:
-		a.eval = func(t *Thread) float64 { return v.(FloatValue).Get(t) };
+		a.eval = func(t *Thread) float64 { return v.(FloatValue).Get(t) }
 	case *idealFloatType:
 		val := v.(IdealFloatValue).Get();
 		a.eval = func() *bignum.Rational { return val };
 	case *stringType:
-		a.eval = func(t *Thread) string { return v.(StringValue).Get(t) };
+		a.eval = func(t *Thread) string { return v.(StringValue).Get(t) }
 	case *ArrayType:
-		a.eval = func(t *Thread) ArrayValue { return v.(ArrayValue).Get(t) };
+		a.eval = func(t *Thread) ArrayValue { return v.(ArrayValue).Get(t) }
 	case *StructType:
-		a.eval = func(t *Thread) StructValue { return v.(StructValue).Get(t) };
+		a.eval = func(t *Thread) StructValue { return v.(StructValue).Get(t) }
 	case *PtrType:
-		a.eval = func(t *Thread) Value { return v.(PtrValue).Get(t) };
+		a.eval = func(t *Thread) Value { return v.(PtrValue).Get(t) }
 	case *FuncType:
-		a.eval = func(t *Thread) Func { return v.(FuncValue).Get(t) };
+		a.eval = func(t *Thread) Func { return v.(FuncValue).Get(t) }
 	case *SliceType:
-		a.eval = func(t *Thread) Slice { return v.(SliceValue).Get(t) };
+		a.eval = func(t *Thread) Slice { return v.(SliceValue).Get(t) }
 	case *MapType:
-		a.eval = func(t *Thread) Map { return v.(MapValue).Get(t) };
+		a.eval = func(t *Thread) Map { return v.(MapValue).Get(t) }
 	default:
-		log.Crashf("unexpected constant type %v at %v", a.t, a.pos);
+		log.Crashf("unexpected constant type %v at %v", a.t, a.pos)
 	}
 }
 
@@ -122,29 +122,29 @@ func (a *expr) genIdentOp(level, index int) {
 	a.evalAddr = func(t *Thread) Value { return t.f.Get(level, index) };
 	switch a.t.lit().(type) {
 	case *boolType:
-		a.eval = func(t *Thread) bool { return t.f.Get(level, index).(BoolValue).Get(t) };
+		a.eval = func(t *Thread) bool { return t.f.Get(level, index).(BoolValue).Get(t) }
 	case *uintType:
-		a.eval = func(t *Thread) uint64 { return t.f.Get(level, index).(UintValue).Get(t) };
+		a.eval = func(t *Thread) uint64 { return t.f.Get(level, index).(UintValue).Get(t) }
 	case *intType:
-		a.eval = func(t *Thread) int64 { return t.f.Get(level, index).(IntValue).Get(t) };
+		a.eval = func(t *Thread) int64 { return t.f.Get(level, index).(IntValue).Get(t) }
 	case *floatType:
-		a.eval = func(t *Thread) float64 { return t.f.Get(level, index).(FloatValue).Get(t) };
+		a.eval = func(t *Thread) float64 { return t.f.Get(level, index).(FloatValue).Get(t) }
 	case *stringType:
-		a.eval = func(t *Thread) string { return t.f.Get(level, index).(StringValue).Get(t) };
+		a.eval = func(t *Thread) string { return t.f.Get(level, index).(StringValue).Get(t) }
 	case *ArrayType:
-		a.eval = func(t *Thread) ArrayValue { return t.f.Get(level, index).(ArrayValue).Get(t) };
+		a.eval = func(t *Thread) ArrayValue { return t.f.Get(level, index).(ArrayValue).Get(t) }
 	case *StructType:
-		a.eval = func(t *Thread) StructValue { return t.f.Get(level, index).(StructValue).Get(t) };
+		a.eval = func(t *Thread) StructValue { return t.f.Get(level, index).(StructValue).Get(t) }
 	case *PtrType:
-		a.eval = func(t *Thread) Value { return t.f.Get(level, index).(PtrValue).Get(t) };
+		a.eval = func(t *Thread) Value { return t.f.Get(level, index).(PtrValue).Get(t) }
 	case *FuncType:
-		a.eval = func(t *Thread) Func { return t.f.Get(level, index).(FuncValue).Get(t) };
+		a.eval = func(t *Thread) Func { return t.f.Get(level, index).(FuncValue).Get(t) }
 	case *SliceType:
-		a.eval = func(t *Thread) Slice { return t.f.Get(level, index).(SliceValue).Get(t) };
+		a.eval = func(t *Thread) Slice { return t.f.Get(level, index).(SliceValue).Get(t) }
 	case *MapType:
-		a.eval = func(t *Thread) Map { return t.f.Get(level, index).(MapValue).Get(t) };
+		a.eval = func(t *Thread) Map { return t.f.Get(level, index).(MapValue).Get(t) }
 	default:
-		log.Crashf("unexpected identifier type %v at %v", a.t, a.pos);
+		log.Crashf("unexpected identifier type %v at %v", a.t, a.pos)
 	}
 }
 
@@ -152,31 +152,31 @@ func (a *expr) genFuncCall(call func(t *Thread) []Value) {
 	a.exec = func(t *Thread) { call(t) };
 	switch a.t.lit().(type) {
 	case *boolType:
-		a.eval = func(t *Thread) bool { return call(t)[0].(BoolValue).Get(t) };
+		a.eval = func(t *Thread) bool { return call(t)[0].(BoolValue).Get(t) }
 	case *uintType:
-		a.eval = func(t *Thread) uint64 { return call(t)[0].(UintValue).Get(t) };
+		a.eval = func(t *Thread) uint64 { return call(t)[0].(UintValue).Get(t) }
 	case *intType:
-		a.eval = func(t *Thread) int64 { return call(t)[0].(IntValue).Get(t) };
+		a.eval = func(t *Thread) int64 { return call(t)[0].(IntValue).Get(t) }
 	case *floatType:
-		a.eval = func(t *Thread) float64 { return call(t)[0].(FloatValue).Get(t) };
+		a.eval = func(t *Thread) float64 { return call(t)[0].(FloatValue).Get(t) }
 	case *stringType:
-		a.eval = func(t *Thread) string { return call(t)[0].(StringValue).Get(t) };
+		a.eval = func(t *Thread) string { return call(t)[0].(StringValue).Get(t) }
 	case *ArrayType:
-		a.eval = func(t *Thread) ArrayValue { return call(t)[0].(ArrayValue).Get(t) };
+		a.eval = func(t *Thread) ArrayValue { return call(t)[0].(ArrayValue).Get(t) }
 	case *StructType:
-		a.eval = func(t *Thread) StructValue { return call(t)[0].(StructValue).Get(t) };
+		a.eval = func(t *Thread) StructValue { return call(t)[0].(StructValue).Get(t) }
 	case *PtrType:
-		a.eval = func(t *Thread) Value { return call(t)[0].(PtrValue).Get(t) };
+		a.eval = func(t *Thread) Value { return call(t)[0].(PtrValue).Get(t) }
 	case *FuncType:
-		a.eval = func(t *Thread) Func { return call(t)[0].(FuncValue).Get(t) };
+		a.eval = func(t *Thread) Func { return call(t)[0].(FuncValue).Get(t) }
 	case *SliceType:
-		a.eval = func(t *Thread) Slice { return call(t)[0].(SliceValue).Get(t) };
+		a.eval = func(t *Thread) Slice { return call(t)[0].(SliceValue).Get(t) }
 	case *MapType:
-		a.eval = func(t *Thread) Map { return call(t)[0].(MapValue).Get(t) };
+		a.eval = func(t *Thread) Map { return call(t)[0].(MapValue).Get(t) }
 	case *MultiType:
-		a.eval = func(t *Thread) []Value { return call(t) };
+		a.eval = func(t *Thread) []Value { return call(t) }
 	default:
-		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
+		log.Crashf("unexpected result type %v at %v", a.t, a.pos)
 	}
 }
 
@@ -184,29 +184,29 @@ func (a *expr) genValue(vf func(*Thread) Value) {
 	a.evalAddr = vf;
 	switch a.t.lit().(type) {
 	case *boolType:
-		a.eval = func(t *Thread) bool { return vf(t).(BoolValue).Get(t) };
+		a.eval = func(t *Thread) bool { return vf(t).(BoolValue).Get(t) }
 	case *uintType:
-		a.eval = func(t *Thread) uint64 { return vf(t).(UintValue).Get(t) };
+		a.eval = func(t *Thread) uint64 { return vf(t).(UintValue).Get(t) }
 	case *intType:
-		a.eval = func(t *Thread) int64 { return vf(t).(IntValue).Get(t) };
+		a.eval = func(t *Thread) int64 { return vf(t).(IntValue).Get(t) }
 	case *floatType:
-		a.eval = func(t *Thread) float64 { return vf(t).(FloatValue).Get(t) };
+		a.eval = func(t *Thread) float64 { return vf(t).(FloatValue).Get(t) }
 	case *stringType:
-		a.eval = func(t *Thread) string { return vf(t).(StringValue).Get(t) };
+		a.eval = func(t *Thread) string { return vf(t).(StringValue).Get(t) }
 	case *ArrayType:
-		a.eval = func(t *Thread) ArrayValue { return vf(t).(ArrayValue).Get(t) };
+		a.eval = func(t *Thread) ArrayValue { return vf(t).(ArrayValue).Get(t) }
 	case *StructType:
-		a.eval = func(t *Thread) StructValue { return vf(t).(StructValue).Get(t) };
+		a.eval = func(t *Thread) StructValue { return vf(t).(StructValue).Get(t) }
 	case *PtrType:
-		a.eval = func(t *Thread) Value { return vf(t).(PtrValue).Get(t) };
+		a.eval = func(t *Thread) Value { return vf(t).(PtrValue).Get(t) }
 	case *FuncType:
-		a.eval = func(t *Thread) Func { return vf(t).(FuncValue).Get(t) };
+		a.eval = func(t *Thread) Func { return vf(t).(FuncValue).Get(t) }
 	case *SliceType:
-		a.eval = func(t *Thread) Slice { return vf(t).(SliceValue).Get(t) };
+		a.eval = func(t *Thread) Slice { return vf(t).(SliceValue).Get(t) }
 	case *MapType:
-		a.eval = func(t *Thread) Map { return vf(t).(MapValue).Get(t) };
+		a.eval = func(t *Thread) Map { return vf(t).(MapValue).Get(t) }
 	default:
-		log.Crashf("unexpected result type %v at %v", a.t, a.pos);
+		log.Crashf("unexpected result type %v at %v", a.t, a.pos)
 	}
 }
 
@@ -239,7 +239,7 @@ func (a *expr) genUnaryOpNeg(v *expr) {
 		val := v.Neg();
 		a.eval = func() *bignum.Rational { return val };
 	default:
-		log.Crashf("unexpected type %v at %v", a.t, a.pos);
+		log.Crashf("unexpected type %v at %v", a.t, a.pos)
 	}
 }
 
@@ -252,7 +252,7 @@ func (a *expr) genUnaryOpNot(v *expr) {
 			return !v;
 		};
 	default:
-		log.Crashf("unexpected type %v at %v", a.t, a.pos);
+		log.Crashf("unexpected type %v at %v", a.t, a.pos)
 	}
 }
 
@@ -275,7 +275,7 @@ func (a *expr) genUnaryOpXor(v *expr) {
 		val := v.Neg().Sub(bignum.Int(1));
 		a.eval = func() *bignum.Integer { return val };
 	default:
-		log.Crashf("unexpected type %v at %v", a.t, a.pos);
+		log.Crashf("unexpected type %v at %v", a.t, a.pos)
 	}
 }
 
@@ -303,37 +303,37 @@ func (a *expr) genBinOpAdd(l, r *expr) {
 				var ret uint64;
 				ret = l+r;
 				return uint64(uint8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l+r;
 				return uint64(uint16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l+r;
 				return uint64(uint32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l+r;
 				return uint64(uint64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l+r;
 				return uint64(uint(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
 		lf := l.asInt();
@@ -345,37 +345,37 @@ func (a *expr) genBinOpAdd(l, r *expr) {
 				var ret int64;
 				ret = l+r;
 				return int64(int8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l+r;
 				return int64(int16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l+r;
 				return int64(int32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l+r;
 				return int64(int64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l+r;
 				return int64(int(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealIntType:
 		l := l.asIdealInt()();
@@ -392,23 +392,23 @@ func (a *expr) genBinOpAdd(l, r *expr) {
 				var ret float64;
 				ret = l+r;
 				return float64(float32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) float64 {
 				l, r := lf(t), rf(t);
 				var ret float64;
 				ret = l+r;
 				return float64(float64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) float64 {
 				l, r := lf(t), rf(t);
 				var ret float64;
 				ret = l+r;
 				return float64(float(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealFloatType:
 		l := l.asIdealFloat()();
@@ -423,7 +423,7 @@ func (a *expr) genBinOpAdd(l, r *expr) {
 			return l+r;
 		};
 	default:
-		log.Crashf("unexpected type %v at %v", l.t, a.pos);
+		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
 }
 
@@ -439,37 +439,37 @@ func (a *expr) genBinOpSub(l, r *expr) {
 				var ret uint64;
 				ret = l-r;
 				return uint64(uint8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l-r;
 				return uint64(uint16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l-r;
 				return uint64(uint32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l-r;
 				return uint64(uint64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l-r;
 				return uint64(uint(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
 		lf := l.asInt();
@@ -481,37 +481,37 @@ func (a *expr) genBinOpSub(l, r *expr) {
 				var ret int64;
 				ret = l-r;
 				return int64(int8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l-r;
 				return int64(int16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l-r;
 				return int64(int32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l-r;
 				return int64(int64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l-r;
 				return int64(int(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealIntType:
 		l := l.asIdealInt()();
@@ -528,23 +528,23 @@ func (a *expr) genBinOpSub(l, r *expr) {
 				var ret float64;
 				ret = l-r;
 				return float64(float32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) float64 {
 				l, r := lf(t), rf(t);
 				var ret float64;
 				ret = l-r;
 				return float64(float64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) float64 {
 				l, r := lf(t), rf(t);
 				var ret float64;
 				ret = l-r;
 				return float64(float(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealFloatType:
 		l := l.asIdealFloat()();
@@ -552,7 +552,7 @@ func (a *expr) genBinOpSub(l, r *expr) {
 		val := l.Sub(r);
 		a.eval = func() *bignum.Rational { return val };
 	default:
-		log.Crashf("unexpected type %v at %v", l.t, a.pos);
+		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
 }
 
@@ -568,37 +568,37 @@ func (a *expr) genBinOpMul(l, r *expr) {
 				var ret uint64;
 				ret = l*r;
 				return uint64(uint8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l*r;
 				return uint64(uint16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l*r;
 				return uint64(uint32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l*r;
 				return uint64(uint64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l*r;
 				return uint64(uint(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
 		lf := l.asInt();
@@ -610,37 +610,37 @@ func (a *expr) genBinOpMul(l, r *expr) {
 				var ret int64;
 				ret = l*r;
 				return int64(int8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l*r;
 				return int64(int16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l*r;
 				return int64(int32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l*r;
 				return int64(int64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l*r;
 				return int64(int(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealIntType:
 		l := l.asIdealInt()();
@@ -657,23 +657,23 @@ func (a *expr) genBinOpMul(l, r *expr) {
 				var ret float64;
 				ret = l*r;
 				return float64(float32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) float64 {
 				l, r := lf(t), rf(t);
 				var ret float64;
 				ret = l*r;
 				return float64(float64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) float64 {
 				l, r := lf(t), rf(t);
 				var ret float64;
 				ret = l*r;
 				return float64(float(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealFloatType:
 		l := l.asIdealFloat()();
@@ -681,7 +681,7 @@ func (a *expr) genBinOpMul(l, r *expr) {
 		val := l.Mul(r);
 		a.eval = func() *bignum.Rational { return val };
 	default:
-		log.Crashf("unexpected type %v at %v", l.t, a.pos);
+		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
 }
 
@@ -696,53 +696,53 @@ func (a *expr) genBinOpQuo(l, r *expr) {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l/r;
 				return uint64(uint8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l/r;
 				return uint64(uint16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l/r;
 				return uint64(uint32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l/r;
 				return uint64(uint64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l/r;
 				return uint64(uint(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
 		lf := l.asInt();
@@ -753,53 +753,53 @@ func (a *expr) genBinOpQuo(l, r *expr) {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l/r;
 				return int64(int8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l/r;
 				return int64(int16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l/r;
 				return int64(int32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l/r;
 				return int64(int64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l/r;
 				return int64(int(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealIntType:
 		l := l.asIdealInt()();
@@ -815,33 +815,33 @@ func (a *expr) genBinOpQuo(l, r *expr) {
 				l, r := lf(t), rf(t);
 				var ret float64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l/r;
 				return float64(float32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) float64 {
 				l, r := lf(t), rf(t);
 				var ret float64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l/r;
 				return float64(float64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) float64 {
 				l, r := lf(t), rf(t);
 				var ret float64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l/r;
 				return float64(float(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealFloatType:
 		l := l.asIdealFloat()();
@@ -849,7 +849,7 @@ func (a *expr) genBinOpQuo(l, r *expr) {
 		val := l.Quo(r);
 		a.eval = func() *bignum.Rational { return val };
 	default:
-		log.Crashf("unexpected type %v at %v", l.t, a.pos);
+		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
 }
 
@@ -864,53 +864,53 @@ func (a *expr) genBinOpRem(l, r *expr) {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l%r;
 				return uint64(uint8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l%r;
 				return uint64(uint16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l%r;
 				return uint64(uint32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l%r;
 				return uint64(uint64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l%r;
 				return uint64(uint(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
 		lf := l.asInt();
@@ -921,53 +921,53 @@ func (a *expr) genBinOpRem(l, r *expr) {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l%r;
 				return int64(int8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l%r;
 				return int64(int16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l%r;
 				return int64(int32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l%r;
 				return int64(int64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				if r == 0 {
-					t.Abort(DivByZeroError{});
+					t.Abort(DivByZeroError{})
 				}
 				ret = l%r;
 				return int64(int(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealIntType:
 		l := l.asIdealInt()();
@@ -975,7 +975,7 @@ func (a *expr) genBinOpRem(l, r *expr) {
 		val := l.Rem(r);
 		a.eval = func() *bignum.Integer { return val };
 	default:
-		log.Crashf("unexpected type %v at %v", l.t, a.pos);
+		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
 }
 
@@ -991,37 +991,37 @@ func (a *expr) genBinOpAnd(l, r *expr) {
 				var ret uint64;
 				ret = l&r;
 				return uint64(uint8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l&r;
 				return uint64(uint16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l&r;
 				return uint64(uint32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l&r;
 				return uint64(uint64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l&r;
 				return uint64(uint(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
 		lf := l.asInt();
@@ -1033,37 +1033,37 @@ func (a *expr) genBinOpAnd(l, r *expr) {
 				var ret int64;
 				ret = l&r;
 				return int64(int8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l&r;
 				return int64(int16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l&r;
 				return int64(int32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l&r;
 				return int64(int64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l&r;
 				return int64(int(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealIntType:
 		l := l.asIdealInt()();
@@ -1071,7 +1071,7 @@ func (a *expr) genBinOpAnd(l, r *expr) {
 		val := l.And(r);
 		a.eval = func() *bignum.Integer { return val };
 	default:
-		log.Crashf("unexpected type %v at %v", l.t, a.pos);
+		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
 }
 
@@ -1087,37 +1087,37 @@ func (a *expr) genBinOpOr(l, r *expr) {
 				var ret uint64;
 				ret = l|r;
 				return uint64(uint8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l|r;
 				return uint64(uint16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l|r;
 				return uint64(uint32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l|r;
 				return uint64(uint64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l|r;
 				return uint64(uint(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
 		lf := l.asInt();
@@ -1129,37 +1129,37 @@ func (a *expr) genBinOpOr(l, r *expr) {
 				var ret int64;
 				ret = l|r;
 				return int64(int8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l|r;
 				return int64(int16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l|r;
 				return int64(int32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l|r;
 				return int64(int64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l|r;
 				return int64(int(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealIntType:
 		l := l.asIdealInt()();
@@ -1167,7 +1167,7 @@ func (a *expr) genBinOpOr(l, r *expr) {
 		val := l.Or(r);
 		a.eval = func() *bignum.Integer { return val };
 	default:
-		log.Crashf("unexpected type %v at %v", l.t, a.pos);
+		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
 }
 
@@ -1183,37 +1183,37 @@ func (a *expr) genBinOpXor(l, r *expr) {
 				var ret uint64;
 				ret = l^r;
 				return uint64(uint8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l^r;
 				return uint64(uint16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l^r;
 				return uint64(uint32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l^r;
 				return uint64(uint64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l^r;
 				return uint64(uint(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
 		lf := l.asInt();
@@ -1225,37 +1225,37 @@ func (a *expr) genBinOpXor(l, r *expr) {
 				var ret int64;
 				ret = l^r;
 				return int64(int8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l^r;
 				return int64(int16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l^r;
 				return int64(int32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l^r;
 				return int64(int64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l^r;
 				return int64(int(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealIntType:
 		l := l.asIdealInt()();
@@ -1263,7 +1263,7 @@ func (a *expr) genBinOpXor(l, r *expr) {
 		val := l.Xor(r);
 		a.eval = func() *bignum.Integer { return val };
 	default:
-		log.Crashf("unexpected type %v at %v", l.t, a.pos);
+		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
 }
 
@@ -1279,37 +1279,37 @@ func (a *expr) genBinOpAndNot(l, r *expr) {
 				var ret uint64;
 				ret = l&^r;
 				return uint64(uint8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l&^r;
 				return uint64(uint16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l&^r;
 				return uint64(uint32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l&^r;
 				return uint64(uint64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l&^r;
 				return uint64(uint(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
 		lf := l.asInt();
@@ -1321,37 +1321,37 @@ func (a *expr) genBinOpAndNot(l, r *expr) {
 				var ret int64;
 				ret = l&^r;
 				return int64(int8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l&^r;
 				return int64(int16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l&^r;
 				return int64(int32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l&^r;
 				return int64(int64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l&^r;
 				return int64(int(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *idealIntType:
 		l := l.asIdealInt()();
@@ -1359,7 +1359,7 @@ func (a *expr) genBinOpAndNot(l, r *expr) {
 		val := l.AndNot(r);
 		a.eval = func() *bignum.Integer { return val };
 	default:
-		log.Crashf("unexpected type %v at %v", l.t, a.pos);
+		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
 }
 
@@ -1375,37 +1375,37 @@ func (a *expr) genBinOpShl(l, r *expr) {
 				var ret uint64;
 				ret = l<<r;
 				return uint64(uint8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l<<r;
 				return uint64(uint16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l<<r;
 				return uint64(uint32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l<<r;
 				return uint64(uint64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l<<r;
 				return uint64(uint(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
 		lf := l.asInt();
@@ -1417,40 +1417,40 @@ func (a *expr) genBinOpShl(l, r *expr) {
 				var ret int64;
 				ret = l<<r;
 				return int64(int8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l<<r;
 				return int64(int16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l<<r;
 				return int64(int32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l<<r;
 				return int64(int64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l<<r;
 				return int64(int(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	default:
-		log.Crashf("unexpected type %v at %v", l.t, a.pos);
+		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
 }
 
@@ -1466,37 +1466,37 @@ func (a *expr) genBinOpShr(l, r *expr) {
 				var ret uint64;
 				ret = l>>r;
 				return uint64(uint8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l>>r;
 				return uint64(uint16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l>>r;
 				return uint64(uint32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l>>r;
 				return uint64(uint64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
 				ret = l>>r;
 				return uint64(uint(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	case *intType:
 		lf := l.asInt();
@@ -1508,40 +1508,40 @@ func (a *expr) genBinOpShr(l, r *expr) {
 				var ret int64;
 				ret = l>>r;
 				return int64(int8(ret));
-			};
+			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l>>r;
 				return int64(int16(ret));
-			};
+			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l>>r;
 				return int64(int32(ret));
-			};
+			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l>>r;
 				return int64(int64(ret));
-			};
+			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
 				ret = l>>r;
 				return int64(int(ret));
-			};
+			}
 		default:
-			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos);
+			log.Crashf("unexpected size %d in type %v at %v", t.Bits, t, a.pos)
 		}
 	default:
-		log.Crashf("unexpected type %v at %v", l.t, a.pos);
+		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
 }
 
@@ -1586,7 +1586,7 @@ func (a *expr) genBinOpLss(l, r *expr) {
 			return l < r;
 		};
 	default:
-		log.Crashf("unexpected type %v at %v", l.t, a.pos);
+		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
 }
 
@@ -1631,7 +1631,7 @@ func (a *expr) genBinOpGtr(l, r *expr) {
 			return l > r;
 		};
 	default:
-		log.Crashf("unexpected type %v at %v", l.t, a.pos);
+		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
 }
 
@@ -1676,7 +1676,7 @@ func (a *expr) genBinOpLeq(l, r *expr) {
 			return l <= r;
 		};
 	default:
-		log.Crashf("unexpected type %v at %v", l.t, a.pos);
+		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
 }
 
@@ -1721,7 +1721,7 @@ func (a *expr) genBinOpGeq(l, r *expr) {
 			return l >= r;
 		};
 	default:
-		log.Crashf("unexpected type %v at %v", l.t, a.pos);
+		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
 }
 
@@ -1794,7 +1794,7 @@ func (a *expr) genBinOpEql(l, r *expr) {
 			return l == r;
 		};
 	default:
-		log.Crashf("unexpected type %v at %v", l.t, a.pos);
+		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
 }
 
@@ -1867,7 +1867,7 @@ func (a *expr) genBinOpNeq(l, r *expr) {
 			return l != r;
 		};
 	default:
-		log.Crashf("unexpected type %v at %v", l.t, a.pos);
+		log.Crashf("unexpected type %v at %v", l.t, a.pos)
 	}
 }
 
@@ -1907,7 +1907,7 @@ func genAssign(lt Type, r *expr) (func(lv Value, t *Thread)) {
 		rf := r.asMap();
 		return func(lv Value, t *Thread) { lv.(MapValue).Set(t, rf(t)) };
 	default:
-		log.Crashf("unexpected left operand type %v at %v", lt, r.pos);
+		log.Crashf("unexpected left operand type %v at %v", lt, r.pos)
 	}
 	panic();
 }
diff --git a/src/pkg/exp/eval/func.go b/src/pkg/exp/eval/func.go
index 103d2766d7..9927066413 100644
--- a/src/pkg/exp/eval/func.go
+++ b/src/pkg/exp/eval/func.go
@@ -47,7 +47,7 @@ func (b *codeBuf) push(instr func(*Thread)) {
 	if n >= cap(b.instrs) {
 		a := make(code, n, n*2);
 		for i := range b.instrs {
-			a[i] = b.instrs[i];
+			a[i] = b.instrs[i]
 		}
 		b.instrs = a;
 	}
@@ -61,7 +61,7 @@ func (b *codeBuf) get() code {
 	// Freeze this buffer into an array of exactly the right size
 	a := make(code, len(b.instrs));
 	for i := range b.instrs {
-		a[i] = b.instrs[i];
+		a[i] = b.instrs[i]
 	}
 	return code(a);
 }
diff --git a/src/pkg/exp/eval/gen.go b/src/pkg/exp/eval/gen.go
index 798f3f43cc..df49b21d36 100644
--- a/src/pkg/exp/eval/gen.go
+++ b/src/pkg/exp/eval/gen.go
@@ -366,10 +366,10 @@ func main() {
 	t.SetDelims("«", "»");
 	err := t.Parse(templateStr);
 	if err != nil {
-		log.Exit(err);
+		log.Exit(err)
 	}
 	err = t.Execute(data, os.Stdout);
 	if err != nil {
-		log.Exit(err);
+		log.Exit(err)
 	}
 }
diff --git a/src/pkg/exp/eval/main.go b/src/pkg/exp/eval/main.go
index a757b6694b..769fc07763 100644
--- a/src/pkg/exp/eval/main.go
+++ b/src/pkg/exp/eval/main.go
@@ -34,10 +34,10 @@ func main() {
 		if err != nil {
 			if list, ok := err.(scanner.ErrorList); ok {
 				for _, e := range list {
-					println(e.String());
+					println(e.String())
 				}
 			} else {
-				println(err.String());
+				println(err.String())
 			}
 			os.Exit(1);
 		}
@@ -72,7 +72,7 @@ func main() {
 		print("; ");
 		line, err := r.ReadString('\n');
 		if err != nil {
-			break;
+			break
 		}
 		code, err := w.Compile(line);
 		if err != nil {
@@ -85,7 +85,7 @@ func main() {
 			continue;
 		}
 		if v != nil {
-			println(v.String());
+			println(v.String())
 		}
 	}
 }
diff --git a/src/pkg/exp/eval/scope.go b/src/pkg/exp/eval/scope.go
index 43df7cf631..e67135c0c0 100644
--- a/src/pkg/exp/eval/scope.go
+++ b/src/pkg/exp/eval/scope.go
@@ -74,7 +74,7 @@ type Scope struct {
 
 func (b *block) enterChild() *block {
 	if b.inner != nil && b.inner.scope == b.scope {
-		log.Crash("Failed to exit child block before entering another child");
+		log.Crash("Failed to exit child block before entering another child")
 	}
 	sub := &block{
 		outer: b,
@@ -88,14 +88,14 @@ func (b *block) enterChild() *block {
 
 func (b *block) exit() {
 	if b.outer == nil {
-		log.Crash("Cannot exit top-level block");
+		log.Crash("Cannot exit top-level block")
 	}
 	if b.outer.scope == b.scope {
 		if b.outer.inner != b {
-			log.Crash("Already exited block");
+			log.Crash("Already exited block")
 		}
 		if b.inner != nil && b.inner.scope == b.scope {
-			log.Crash("Exit of parent block without exit of child block");
+			log.Crash("Exit of parent block without exit of child block")
 		}
 	}
 	b.outer.inner = nil;
@@ -103,7 +103,7 @@ func (b *block) exit() {
 
 func (b *block) ChildScope() *Scope {
 	if b.inner != nil && b.inner.scope == b.scope {
-		log.Crash("Failed to exit child block before entering a child scope");
+		log.Crash("Failed to exit child block before entering a child scope")
 	}
 	sub := b.enterChild();
 	sub.offset = 0;
@@ -113,7 +113,7 @@ func (b *block) ChildScope() *Scope {
 
 func (b *block) DefineVar(name string, pos token.Position, t Type) (*Variable, Def) {
 	if prev, ok := b.defs[name]; ok {
-		return nil, prev;
+		return nil, prev
 	}
 	v := b.defineSlot(t, false);
 	v.Position = pos;
@@ -125,14 +125,14 @@ func (b *block) DefineTemp(t Type) *Variable	{ return b.defineSlot(t, true) }
 
 func (b *block) defineSlot(t Type, temp bool) *Variable {
 	if b.inner != nil && b.inner.scope == b.scope {
-		log.Crash("Failed to exit child block before defining variable");
+		log.Crash("Failed to exit child block before defining variable")
 	}
 	index := -1;
 	if !b.global || temp {
 		index = b.offset + b.numVars;
 		b.numVars++;
 		if index >= b.scope.maxVars {
-			b.scope.maxVars = index+1;
+			b.scope.maxVars = index+1
 		}
 	}
 	v := &Variable{token.Position{}, index, t, nil};
@@ -141,7 +141,7 @@ func (b *block) defineSlot(t Type, temp bool) *Variable {
 
 func (b *block) DefineConst(name string, pos token.Position, t Type, v Value) (*Constant, Def) {
 	if prev, ok := b.defs[name]; ok {
-		return nil, prev;
+		return nil, prev
 	}
 	c := &Constant{pos, t, v};
 	b.defs[name] = c;
@@ -150,11 +150,11 @@ func (b *block) DefineConst(name string, pos token.Position, t Type, v Value) (*
 
 func (b *block) DefineType(name string, pos token.Position, t Type) Type {
 	if _, ok := b.defs[name]; ok {
-		return nil;
+		return nil
 	}
 	nt := &NamedType{pos, name, nil, true, make(map[string]Method)};
 	if t != nil {
-		nt.Complete(t);
+		nt.Complete(t)
 	}
 	b.defs[name] = nt;
 	return nt;
@@ -163,10 +163,10 @@ func (b *block) DefineType(name string, pos token.Position, t Type) Type {
 func (b *block) Lookup(name string) (bl *block, level int, def Def) {
 	for b != nil {
 		if d, ok := b.defs[name]; ok {
-			return b, level, d;
+			return b, level, d
 		}
 		if b.outer != nil && b.scope != b.outer.scope {
-			level++;
+			level++
 		}
 		b = b.outer;
 	}
@@ -186,7 +186,7 @@ type Frame struct {
 
 func (f *Frame) Get(level int, index int) Value {
 	for ; level > 0; level-- {
-		f = f.Outer;
+		f = f.Outer
 	}
 	return f.Vars[index];
 }
@@ -195,5 +195,5 @@ func (f *Frame) child(numVars int) *Frame {
 	// TODO(austin) This is probably rather expensive.  All values
 	// require heap allocation and zeroing them when we execute a
 	// definition typically requires some computation.
-	return &Frame{f, make([]Value, numVars)};
+	return &Frame{f, make([]Value, numVars)}
 }
diff --git a/src/pkg/exp/eval/stmt.go b/src/pkg/exp/eval/stmt.go
index b9dcfe5508..8820826eb0 100644
--- a/src/pkg/exp/eval/stmt.go
+++ b/src/pkg/exp/eval/stmt.go
@@ -28,7 +28,7 @@ type stmtCompiler struct {
 }
 
 func (a *stmtCompiler) diag(format string, args ...) {
-	a.diagAt(&a.pos, format, args);
+	a.diagAt(&a.pos, format, args)
 }
 
 /*
@@ -74,7 +74,7 @@ type flowBuf struct {
 }
 
 func newFlowBuf(cb *codeBuf) *flowBuf {
-	return &flowBuf{cb, make(map[uint]*flowEnt), make(map[*token.Position]*flowBlock), make(map[string]*flowBlock)};
+	return &flowBuf{cb, make(map[uint]*flowEnt), make(map[*token.Position]*flowBlock), make(map[string]*flowBlock)}
 }
 
 // put creates a flow control point for the next PC in the code buffer.
@@ -82,7 +82,7 @@ func newFlowBuf(cb *codeBuf) *flowBuf {
 func (f *flowBuf) put(cond bool, term bool, jumps []*uint) {
 	pc := f.cb.nextPC();
 	if ent, ok := f.ents[pc]; ok {
-		log.Crashf("Flow entry already exists at PC %d: %+v", pc, ent);
+		log.Crashf("Flow entry already exists at PC %d: %+v", pc, ent)
 	}
 	f.ents[pc] = &flowEnt{cond, term, jumps, false};
 }
@@ -95,19 +95,19 @@ func (f *flowBuf) putTerm()	{ f.put(false, true, nil) }
 // PC and, if cond is true, can also continue to the PC following the
 // next PC.
 func (f *flowBuf) put1(cond bool, jumpPC *uint) {
-	f.put(cond, false, []*uint{jumpPC});
+	f.put(cond, false, []*uint{jumpPC})
 }
 
 func newFlowBlock(target string, b *block) *flowBlock {
 	// Find the inner-most block containing definitions
 	for b.numVars == 0 && b.outer != nil && b.outer.scope == b.scope {
-		b = b.outer;
+		b = b.outer
 	}
 
 	// Count parents leading to the root of the scope
 	n := 0;
 	for bp := b; bp.scope == b.scope; bp = bp.outer {
-		n++;
+		n++
 	}
 
 	// Capture numVars from each block to the root of the scope
@@ -124,12 +124,12 @@ func newFlowBlock(target string, b *block) *flowBlock {
 // putGoto captures the block at a goto statement.  This should be
 // called in addition to putting a flow control point.
 func (f *flowBuf) putGoto(pos token.Position, target string, b *block) {
-	f.gotos[&pos] = newFlowBlock(target, b);
+	f.gotos[&pos] = newFlowBlock(target, b)
 }
 
 // putLabel captures the block at a label.
 func (f *flowBuf) putLabel(name string, b *block) {
-	f.labels[name] = newFlowBlock("", b);
+	f.labels[name] = newFlowBlock("", b)
 }
 
 // reachesEnd returns true if the end of f's code buffer can be
@@ -138,35 +138,35 @@ func (f *flowBuf) putLabel(name string, b *block) {
 func (f *flowBuf) reachesEnd(pc uint) bool {
 	endPC := f.cb.nextPC();
 	if pc > endPC {
-		log.Crashf("Reached bad PC %d past end PC %d", pc, endPC);
+		log.Crashf("Reached bad PC %d past end PC %d", pc, endPC)
 	}
 
 	for ; pc < endPC; pc++ {
 		ent, ok := f.ents[pc];
 		if !ok {
-			continue;
+			continue
 		}
 
 		if ent.visited {
-			return false;
+			return false
 		}
 		ent.visited = true;
 
 		if ent.term {
-			return false;
+			return false
 		}
 
 		// If anything can reach the end, we can reach the end
 		// from pc.
 		for _, j := range ent.jumps {
 			if f.reachesEnd(*j) {
-				return true;
+				return true
 			}
 		}
 		// If the jump was conditional, we can reach the next
 		// PC, so try reaching the end from it.
 		if ent.cond {
-			continue;
+			continue
 		}
 		return false;
 	}
@@ -216,9 +216,9 @@ func (a *stmtCompiler) defineVar(ident *ast.Ident, t Type) *Variable {
 		// Pos() in a variable.
 		pos := prev.Pos();
 		if pos.IsValid() {
-			a.diagAt(ident, "variable %s redeclared in this block\n\tprevious declaration at %s", ident.Value, &pos);
+			a.diagAt(ident, "variable %s redeclared in this block\n\tprevious declaration at %s", ident.Value, &pos)
 		} else {
-			a.diagAt(ident, "variable %s redeclared in this block", ident.Value);
+			a.diagAt(ident, "variable %s redeclared in this block", ident.Value)
 		}
 		return nil;
 	}
@@ -226,7 +226,7 @@ func (a *stmtCompiler) defineVar(ident *ast.Ident, t Type) *Variable {
 	// Initialize the variable
 	index := v.Index;
 	if v.Index >= 0 {
-		a.push(func(v *Thread) { v.f.Vars[index] = t.Zero() });
+		a.push(func(v *Thread) { v.f.Vars[index] = t.Zero() })
 	}
 	return v;
 }
@@ -239,85 +239,85 @@ func (a *stmtCompiler) defineVar(ident *ast.Ident, t Type) *Variable {
 
 func (a *stmtCompiler) compile(s ast.Stmt) {
 	if a.block.inner != nil {
-		log.Crash("Child scope still entered");
+		log.Crash("Child scope still entered")
 	}
 
 	notimpl := false;
 	switch s := s.(type) {
 	case *ast.BadStmt:
 		// Error already reported by parser.
-		a.silentErrors++;
+		a.silentErrors++
 
 	case *ast.DeclStmt:
-		a.compileDeclStmt(s);
+		a.compileDeclStmt(s)
 
 	case *ast.EmptyStmt:
 		// Do nothing.
 
 	case *ast.LabeledStmt:
-		a.compileLabeledStmt(s);
+		a.compileLabeledStmt(s)
 
 	case *ast.ExprStmt:
-		a.compileExprStmt(s);
+		a.compileExprStmt(s)
 
 	case *ast.IncDecStmt:
-		a.compileIncDecStmt(s);
+		a.compileIncDecStmt(s)
 
 	case *ast.AssignStmt:
-		a.compileAssignStmt(s);
+		a.compileAssignStmt(s)
 
 	case *ast.GoStmt:
-		notimpl = true;
+		notimpl = true
 
 	case *ast.DeferStmt:
-		notimpl = true;
+		notimpl = true
 
 	case *ast.ReturnStmt:
-		a.compileReturnStmt(s);
+		a.compileReturnStmt(s)
 
 	case *ast.BranchStmt:
-		a.compileBranchStmt(s);
+		a.compileBranchStmt(s)
 
 	case *ast.BlockStmt:
-		a.compileBlockStmt(s);
+		a.compileBlockStmt(s)
 
 	case *ast.IfStmt:
-		a.compileIfStmt(s);
+		a.compileIfStmt(s)
 
 	case *ast.CaseClause:
-		a.diag("case clause outside switch");
+		a.diag("case clause outside switch")
 
 	case *ast.SwitchStmt:
-		a.compileSwitchStmt(s);
+		a.compileSwitchStmt(s)
 
 	case *ast.TypeCaseClause:
-		notimpl = true;
+		notimpl = true
 
 	case *ast.TypeSwitchStmt:
-		notimpl = true;
+		notimpl = true
 
 	case *ast.CommClause:
-		notimpl = true;
+		notimpl = true
 
 	case *ast.SelectStmt:
-		notimpl = true;
+		notimpl = true
 
 	case *ast.ForStmt:
-		a.compileForStmt(s);
+		a.compileForStmt(s)
 
 	case *ast.RangeStmt:
-		notimpl = true;
+		notimpl = true
 
 	default:
-		log.Crashf("unexpected ast node type %T", s);
+		log.Crashf("unexpected ast node type %T", s)
 	}
 
 	if notimpl {
-		a.diag("%T statment node not implemented", s);
+		a.diag("%T statment node not implemented", s)
 	}
 
 	if a.block.inner != nil {
-		log.Crash("Forgot to exit child scope");
+		log.Crash("Forgot to exit child scope")
 	}
 }
 
@@ -325,20 +325,20 @@ func (a *stmtCompiler) compileDeclStmt(s *ast.DeclStmt) {
 	switch decl := s.Decl.(type) {
 	case *ast.BadDecl:
 		// Do nothing.  Already reported by parser.
-		a.silentErrors++;
+		a.silentErrors++
 
 	case *ast.FuncDecl:
 		if !a.block.global {
-			log.Crash("FuncDecl at statement level");
+			log.Crash("FuncDecl at statement level")
 		}
 
 	case *ast.GenDecl:
 		if decl.Tok == token.IMPORT && !a.block.global {
-			log.Crash("import at statement level");
+			log.Crash("import at statement level")
 		}
 
 	default:
-		log.Crashf("Unexpected Decl type %T", s.Decl);
+		log.Crashf("Unexpected Decl type %T", s.Decl)
 	}
 	a.compileDecl(s.Decl);
 }
@@ -350,18 +350,18 @@ func (a *stmtCompiler) compileVarDecl(decl *ast.GenDecl) {
 			// Declaration without assignment
 			if spec.Type == nil {
 				// Parser should have caught
-				log.Crash("Type and Values nil");
+				log.Crash("Type and Values nil")
 			}
 			t := a.compileType(a.block, spec.Type);
 			// Define placeholders even if type compile failed
 			for _, n := range spec.Names {
-				a.defineVar(n, t);
+				a.defineVar(n, t)
 			}
 		} else {
 			// Declaration with assignment
 			lhs := make([]ast.Expr, len(spec.Names));
 			for i, n := range spec.Names {
-				lhs[i] = n;
+				lhs[i] = n
 			}
 			a.doAssign(lhs, spec.Values, decl.Tok, spec.Type);
 		}
@@ -372,12 +372,12 @@ func (a *stmtCompiler) compileDecl(decl ast.Decl) {
 	switch d := decl.(type) {
 	case *ast.BadDecl:
 		// Do nothing.  Already reported by parser.
-		a.silentErrors++;
+		a.silentErrors++
 
 	case *ast.FuncDecl:
 		decl := a.compileFuncType(a.block, d.Type);
 		if decl == nil {
-			return;
+			return
 		}
 		// Declare and initialize v before compiling func
 		// so that body can refer to itself.
@@ -385,14 +385,14 @@ func (a *stmtCompiler) compileDecl(decl ast.Decl) {
 		if prev != nil {
 			pos := prev.Pos();
 			if pos.IsValid() {
-				a.diagAt(d.Name, "identifier %s redeclared in this block\n\tprevious declaration at %s", d.Name.Value, &pos);
+				a.diagAt(d.Name, "identifier %s redeclared in this block\n\tprevious declaration at %s", d.Name.Value, &pos)
 			} else {
-				a.diagAt(d.Name, "identifier %s redeclared in this block", d.Name.Value);
+				a.diagAt(d.Name, "identifier %s redeclared in this block", d.Name.Value)
 			}
 		}
 		fn := a.compileFunc(a.block, decl, d.Body);
 		if c == nil || fn == nil {
-			return;
+			return
 		}
 		var zeroThread Thread;
 		c.Value.(FuncValue).Set(nil, fn(&zeroThread));
@@ -400,17 +400,17 @@ func (a *stmtCompiler) compileDecl(decl ast.Decl) {
 	case *ast.GenDecl:
 		switch d.Tok {
 		case token.IMPORT:
-			log.Crashf("%v not implemented", d.Tok);
+			log.Crashf("%v not implemented", d.Tok)
 		case token.CONST:
-			log.Crashf("%v not implemented", d.Tok);
+			log.Crashf("%v not implemented", d.Tok)
 		case token.TYPE:
-			a.compileTypeDecl(a.block, d);
+			a.compileTypeDecl(a.block, d)
 		case token.VAR:
-			a.compileVarDecl(d);
+			a.compileVarDecl(d)
 		}
 
 	default:
-		log.Crashf("Unexpected Decl type %T", decl);
+		log.Crashf("Unexpected Decl type %T", decl)
 	}
 }
 
@@ -419,7 +419,7 @@ func (a *stmtCompiler) compileLabeledStmt(s *ast.LabeledStmt) {
 	l, ok := a.labels[s.Label.Value];
 	if ok {
 		if l.resolved.IsValid() {
-			a.diag("label %s redeclared in this block\n\tprevious declaration at %s", s.Label.Value, &l.resolved);
+			a.diag("label %s redeclared in this block\n\tprevious declaration at %s", s.Label.Value, &l.resolved)
 		}
 	} else {
 		pc := badPC;
@@ -446,7 +446,7 @@ func (a *stmtCompiler) compileExprStmt(s *ast.ExprStmt) {
 
 	e := a.compileExpr(bc.block, false, s.X);
 	if e == nil {
-		return;
+		return
 	}
 
 	if e.exec == nil {
@@ -464,7 +464,7 @@ func (a *stmtCompiler) compileIncDecStmt(s *ast.IncDecStmt) {
 
 	l := a.compileExpr(bc.block, false, s.X);
 	if l == nil {
-		return;
+		return
 	}
 
 	if l.evalAddr == nil {
@@ -486,7 +486,7 @@ func (a *stmtCompiler) compileIncDecStmt(s *ast.IncDecStmt) {
 		op = token.SUB;
 		desc = "decrement statement";
 	default:
-		log.Crashf("Unexpected IncDec token %v", s.Tok);
+		log.Crashf("Unexpected IncDec token %v", s.Tok)
 	}
 
 	effect, l := l.extractEffect(bc.block, desc);
@@ -497,12 +497,12 @@ func (a *stmtCompiler) compileIncDecStmt(s *ast.IncDecStmt) {
 
 	binop := l.compileBinaryExpr(op, l, one);
 	if binop == nil {
-		return;
+		return
 	}
 
 	assign := a.compileAssign(s.Pos(), bc.block, l.t, []*expr{binop}, "", "");
 	if assign == nil {
-		log.Crashf("compileAssign type check failed");
+		log.Crashf("compileAssign type check failed")
 	}
 
 	lf := l.evalAddr;
@@ -520,12 +520,12 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,
 	// made on the left side.
 	rs := make([]*expr, len(rhs));
 	for i, re := range rhs {
-		rs[i] = a.compileExpr(a.block, false, re);
+		rs[i] = a.compileExpr(a.block, false, re)
 	}
 
 	errOp := "assignment";
 	if tok == token.DEFINE || tok == token.VAR {
-		errOp = "declaration";
+		errOp = "declaration"
 	}
 	ac, ok := a.checkAssign(a.pos, rs, errOp, "value");
 	ac.allowMapForms(len(lhs));
@@ -534,13 +534,13 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,
 	// able to produce the usual error message because we can't
 	// begin to infer the types of the LHS.
 	if (tok == token.DEFINE || tok == token.VAR) && len(lhs) > len(ac.rmt.Elems) {
-		a.diag("not enough values for definition");
+		a.diag("not enough values for definition")
 	}
 
 	// Compile left type if there is one
 	var declType Type;
 	if declTypeExpr != nil {
-		declType = a.compileType(a.block, declTypeExpr);
+		declType = a.compileType(a.block, declTypeExpr)
 	}
 
 	// Compile left side
@@ -569,7 +569,7 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,
 			nDefs++;
 
 		case token.VAR:
-			ident = le.(*ast.Ident);
+			ident = le.(*ast.Ident)
 		}
 
 		// If it's a definition, get or infer its type.
@@ -582,17 +582,17 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,
 				// We have a declaration type, use it.
 				// If declType is nil, we gave an
 				// error when we compiled it.
-				lt = declType;
+				lt = declType
 
 			case i >= len(ac.rmt.Elems):
 				// Define a placeholder.  We already
 				// gave the "not enough" error above.
-				lt = nil;
+				lt = nil
 
 			case ac.rmt.Elems[i] == nil:
 				// We gave the error when we compiled
 				// the RHS.
-				lt = nil;
+				lt = nil
 
 			case ac.rmt.Elems[i].isIdeal():
 				// If the type is absent and the
@@ -603,29 +603,29 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,
 				// int or float respectively.
 				switch {
 				case ac.rmt.Elems[i].isInteger():
-					lt = IntType;
+					lt = IntType
 				case ac.rmt.Elems[i].isFloat():
-					lt = FloatType;
+					lt = FloatType
 				default:
-					log.Crashf("unexpected ideal type %v", rs[i].t);
+					log.Crashf("unexpected ideal type %v", rs[i].t)
 				}
 
 			default:
-				lt = ac.rmt.Elems[i];
+				lt = ac.rmt.Elems[i]
 			}
 		}
 
 		// If it's a definition, define the identifier
 		if ident != nil {
 			if a.defineVar(ident, lt) == nil {
-				continue;
+				continue
 			}
 		}
 
 		// Compile LHS
 		ls[i] = a.compileExpr(a.block, false, le);
 		if ls[i] == nil {
-			continue;
+			continue
 		}
 
 		if ls[i].evalMapValue != nil {
@@ -667,7 +667,7 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,
 	// If there have been errors, our arrays are full of nil's so
 	// get out of here now.
 	if nerr != a.numError() {
-		return;
+		return
 	}
 
 	// Check for 'a[x] = r, ok'
@@ -680,12 +680,12 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,
 	var lt Type;
 	n := len(lhs);
 	if n == 1 {
-		lt = ls[0].t;
+		lt = ls[0].t
 	} else {
 		lts := make([]Type, len(ls));
 		for i, l := range ls {
 			if l != nil {
-				lts[i] = l.t;
+				lts[i] = l.t
 			}
 		}
 		lt = NewMultiType(lts);
@@ -694,7 +694,7 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,
 	defer bc.exit();
 	assign := ac.compile(bc.block, lt);
 	if assign == nil {
-		return;
+		return
 	}
 
 	// Compile
@@ -706,12 +706,12 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,
 		// Don't need temporaries
 		lfs := make([]func(*Thread) Value, n);
 		for i, l := range ls {
-			lfs[i] = l.evalAddr;
+			lfs[i] = l.evalAddr
 		}
 		a.push(func(t *Thread) {
 			dest := make([]Value, n);
 			for i, lf := range lfs {
-				dest[i] = lf(t);
+				dest[i] = lf(t)
 			}
 			assign(multiV(dest), t);
 		});
@@ -720,7 +720,7 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,
 		lmt := lt.(*MultiType);
 		lfs := make([]func(*Thread) Value, n);
 		for i, l := range ls {
-			lfs[i] = l.evalAddr;
+			lfs[i] = l.evalAddr
 		}
 		a.push(func(t *Thread) {
 			temp := lmt.Zero().(multiV);
@@ -729,7 +729,7 @@ func (a *stmtCompiler) doAssign(lhs []ast.Expr, rhs []ast.Expr, tok token.Token,
 			for i := 0; i < n; i++ {
 				// TODO(austin) Need to evaluate LHS
 				// before RHS
-				lfs[i](t).Assign(t, temp[i]);
+				lfs[i](t).Assign(t, temp[i])
 			}
 		});
 	}
@@ -763,7 +763,7 @@ func (a *stmtCompiler) doAssignOp(s *ast.AssignStmt) {
 	l := a.compileExpr(bc.block, false, s.Lhs[0]);
 	r := a.compileExpr(bc.block, false, s.Rhs[0]);
 	if l == nil || r == nil {
-		return;
+		return
 	}
 
 	if l.evalAddr == nil {
@@ -775,12 +775,12 @@ func (a *stmtCompiler) doAssignOp(s *ast.AssignStmt) {
 
 	binop := r.compileBinaryExpr(assignOpToOp[s.Tok], l, r);
 	if binop == nil {
-		return;
+		return
 	}
 
 	assign := a.compileAssign(s.Pos(), bc.block, l.t, []*expr{binop}, "assignment", "value");
 	if assign == nil {
-		log.Crashf("compileAssign type check failed");
+		log.Crashf("compileAssign type check failed")
 	}
 
 	lf := l.evalAddr;
@@ -793,10 +793,10 @@ func (a *stmtCompiler) doAssignOp(s *ast.AssignStmt) {
 func (a *stmtCompiler) compileAssignStmt(s *ast.AssignStmt) {
 	switch s.Tok {
 	case token.ASSIGN, token.DEFINE:
-		a.doAssign(s.Lhs, s.Rhs, s.Tok, nil);
+		a.doAssign(s.Lhs, s.Rhs, s.Tok, nil)
 
 	default:
-		a.doAssignOp(s);
+		a.doAssignOp(s)
 	}
 }
 
@@ -822,11 +822,11 @@ func (a *stmtCompiler) compileReturnStmt(s *ast.ReturnStmt) {
 	for i, re := range s.Results {
 		rs[i] = a.compileExpr(bc.block, false, re);
 		if rs[i] == nil {
-			bad = true;
+			bad = true
 		}
 	}
 	if bad {
-		return;
+		return
 	}
 
 	// Create assigner
@@ -855,11 +855,11 @@ func (a *stmtCompiler) findLexicalLabel(name *ast.Ident, pred func(*label) bool,
 	bc := a.blockCompiler;
 	for ; bc != nil; bc = bc.parent {
 		if bc.label == nil {
-			continue;
+			continue
 		}
 		l := bc.label;
 		if name == nil && pred(l) {
-			return l;
+			return l
 		}
 		if name != nil && l.name == name.Value {
 			if !pred(l) {
@@ -870,9 +870,9 @@ func (a *stmtCompiler) findLexicalLabel(name *ast.Ident, pred func(*label) bool,
 		}
 	}
 	if name == nil {
-		a.diag("%s outside %s", errOp, errCtx);
+		a.diag("%s outside %s", errOp, errCtx)
 	} else {
-		a.diag("%s label %s not defined", errOp, name.Value);
+		a.diag("%s label %s not defined", errOp, name.Value)
 	}
 	return nil;
 }
@@ -884,14 +884,14 @@ func (a *stmtCompiler) compileBranchStmt(s *ast.BranchStmt) {
 	case token.BREAK:
 		l := a.findLexicalLabel(s.Label, func(l *label) bool { return l.breakPC != nil }, "break", "for loop, switch, or select");
 		if l == nil {
-			return;
+			return
 		}
 		pc = l.breakPC;
 
 	case token.CONTINUE:
 		l := a.findLexicalLabel(s.Label, func(l *label) bool { return l.continuePC != nil }, "continue", "for loop");
 		if l == nil {
-			return;
+			return
 		}
 		pc = l.continuePC;
 
@@ -911,7 +911,7 @@ func (a *stmtCompiler) compileBranchStmt(s *ast.BranchStmt) {
 		return;
 
 	default:
-		log.Crash("Unexpected branch token %v", s.Tok);
+		log.Crash("Unexpected branch token %v", s.Tok)
 	}
 
 	a.flow.put1(false, pc);
@@ -940,7 +940,7 @@ func (a *stmtCompiler) compileIfStmt(s *ast.IfStmt) {
 
 	// Compile init statement, if any
 	if s.Init != nil {
-		bc.compileStmt(s.Init);
+		bc.compileStmt(s.Init)
 	}
 
 	elsePC := badPC;
@@ -954,13 +954,13 @@ func (a *stmtCompiler) compileIfStmt(s *ast.IfStmt) {
 		case e == nil:
 			// Error reported by compileExpr
 		case !e.t.isBoolean():
-			e.diag("'if' condition must be boolean\n\t%v", e.t);
+			e.diag("'if' condition must be boolean\n\t%v", e.t)
 		default:
 			eval := e.asBool();
 			a.flow.put1(true, &elsePC);
 			a.push(func(t *Thread) {
 				if !eval(t) {
-					t.pc = elsePC;
+					t.pc = elsePC
 				}
 			});
 		}
@@ -979,7 +979,7 @@ func (a *stmtCompiler) compileIfStmt(s *ast.IfStmt) {
 		elsePC = a.nextPC();
 		bc.compileStmt(s.Else);
 	} else {
-		elsePC = a.nextPC();
+		elsePC = a.nextPC()
 	}
 	endPC = a.nextPC();
 }
@@ -991,7 +991,7 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {
 
 	// Compile init statement, if any
 	if s.Init != nil {
-		bc.compileStmt(s.Init);
+		bc.compileStmt(s.Init)
 	}
 
 	// Compile condition, if any, and extract its effects
@@ -1017,11 +1017,11 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {
 		}
 		if clause.Values == nil {
 			if hasDefault {
-				a.diagAt(clause, "switch statement contains more than one default case");
+				a.diagAt(clause, "switch statement contains more than one default case")
 			}
 			hasDefault = true;
 		} else {
-			ncases += len(clause.Values);
+			ncases += len(clause.Values)
 		}
 	}
 
@@ -1031,7 +1031,7 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {
 	for _, c := range s.Body.List {
 		clause, ok := c.(*ast.CaseClause);
 		if !ok {
-			continue;
+			continue
 		}
 		for _, v := range clause.Values {
 			e := condbc.compileExpr(condbc.block, false, v);
@@ -1039,15 +1039,15 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {
 			case e == nil:
 				// Error reported by compileExpr
 			case cond == nil && !e.t.isBoolean():
-				a.diagAt(v, "'case' condition must be boolean");
+				a.diagAt(v, "'case' condition must be boolean")
 			case cond == nil:
-				cases[i] = e.asBool();
+				cases[i] = e.asBool()
 			case cond != nil:
 				// Create comparison
 				// TOOD(austin) This produces bad error messages
 				compare := e.compileBinaryExpr(token.EQL, cond, e);
 				if compare != nil {
-					cases[i] = compare.asBool();
+					cases[i] = compare.asBool()
 				}
 			}
 			i++;
@@ -1075,7 +1075,7 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {
 	for _, c := range s.Body.List {
 		clause, ok := c.(*ast.CaseClause);
 		if !ok {
-			continue;
+			continue
 		}
 
 		// Save jump PC's
@@ -1087,7 +1087,7 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {
 			}
 		} else {
 			// Default clause
-			casePCs[ncases] = &pc;
+			casePCs[ncases] = &pc
 		}
 
 		// Compile body
@@ -1110,7 +1110,7 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {
 				}
 				fall = true;
 			} else {
-				bc.compileStmt(s);
+				bc.compileStmt(s)
 			}
 		}
 		// Jump out of switch, unless there was a fallthrough
@@ -1123,7 +1123,7 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {
 	// Get end PC
 	endPC = a.nextPC();
 	if !hasDefault {
-		casePCs[ncases] = &endPC;
+		casePCs[ncases] = &endPC
 	}
 }
 
@@ -1134,7 +1134,7 @@ func (a *stmtCompiler) compileForStmt(s *ast.ForStmt) {
 
 	// Compile init statement, if any
 	if s.Init != nil {
-		bc.compileStmt(s.Init);
+		bc.compileStmt(s.Init)
 	}
 
 	bodyPC := badPC;
@@ -1151,9 +1151,9 @@ func (a *stmtCompiler) compileForStmt(s *ast.ForStmt) {
 	bodyPC = a.nextPC();
 	body := bc.enterChild();
 	if a.stmtLabel != nil {
-		body.label = a.stmtLabel;
+		body.label = a.stmtLabel
 	} else {
-		body.label = &label{resolved: s.Pos()};
+		body.label = &label{resolved: s.Pos()}
 	}
 	body.label.desc = "for loop";
 	body.label.breakPC = &endPC;
@@ -1166,7 +1166,7 @@ func (a *stmtCompiler) compileForStmt(s *ast.ForStmt) {
 	if s.Post != nil {
 		// TODO(austin) Does the parser disallow short
 		// declarations in s.Post?
-		bc.compileStmt(s.Post);
+		bc.compileStmt(s.Post)
 	}
 
 	// Compile condition check, if any
@@ -1181,13 +1181,13 @@ func (a *stmtCompiler) compileForStmt(s *ast.ForStmt) {
 		case e == nil:
 			// Error reported by compileExpr
 		case !e.t.isBoolean():
-			a.diag("'for' condition must be boolean\n\t%v", e.t);
+			a.diag("'for' condition must be boolean\n\t%v", e.t)
 		default:
 			eval := e.asBool();
 			a.flow.put1(true, &bodyPC);
 			a.push(func(t *Thread) {
 				if eval(t) {
-					t.pc = bodyPC;
+					t.pc = bodyPC
 				}
 			});
 		}
@@ -1207,7 +1207,7 @@ func (a *blockCompiler) compileStmt(s ast.Stmt) {
 
 func (a *blockCompiler) compileStmts(block *ast.BlockStmt) {
 	for _, sub := range block.List {
-		a.compileStmt(sub);
+		a.compileStmt(sub)
 	}
 }
 
@@ -1235,16 +1235,16 @@ func (a *compiler) compileFunc(b *block, decl *FuncDecl, body *ast.BlockStmt) (f
 	defer bodyScope.exit();
 	for i, t := range decl.Type.In {
 		if decl.InNames[i] != nil {
-			bodyScope.DefineVar(decl.InNames[i].Value, decl.InNames[i].Pos(), t);
+			bodyScope.DefineVar(decl.InNames[i].Value, decl.InNames[i].Pos(), t)
 		} else {
-			bodyScope.DefineTemp(t);
+			bodyScope.DefineTemp(t)
 		}
 	}
 	for i, t := range decl.Type.Out {
 		if decl.OutNames[i] != nil {
-			bodyScope.DefineVar(decl.OutNames[i].Value, decl.OutNames[i].Pos(), t);
+			bodyScope.DefineVar(decl.OutNames[i].Value, decl.OutNames[i].Pos(), t)
 		} else {
-			bodyScope.DefineTemp(t);
+			bodyScope.DefineTemp(t)
 		}
 	}
 
@@ -1268,7 +1268,7 @@ func (a *compiler) compileFunc(b *block, decl *FuncDecl, body *ast.BlockStmt) (f
 	bc.compileStmts(body);
 	fc.checkLabels();
 	if nerr != a.numError() {
-		return nil;
+		return nil
 	}
 
 	// Check that the body returned if necessary.  We only check
@@ -1290,12 +1290,12 @@ func (a *funcCompiler) checkLabels() {
 	nerr := a.numError();
 	for _, l := range a.labels {
 		if !l.resolved.IsValid() {
-			a.diagAt(&l.used, "label %s not defined", l.name);
+			a.diagAt(&l.used, "label %s not defined", l.name)
 		}
 	}
 	if nerr != a.numError() {
 		// Don't check scopes if we have unresolved labels
-		return;
+		return
 	}
 
 	// Executing the "goto" statement must not cause any variables
diff --git a/src/pkg/exp/eval/type.go b/src/pkg/exp/eval/type.go
index 85f96fb19d..f63220a6b8 100644
--- a/src/pkg/exp/eval/type.go
+++ b/src/pkg/exp/eval/type.go
@@ -84,7 +84,7 @@ func hashTypeArray(key []Type) uintptr {
 	for _, t := range key {
 		hash = hash*33;
 		if t == nil {
-			continue;
+			continue
 		}
 		addr := reflect.NewValue(t).(*reflect.PtrValue).Get();
 		hash ^= addr;
@@ -97,17 +97,17 @@ func newTypeArrayMap() typeArrayMap	{ return make(map[uintptr]*typeArrayMapEntry
 func (m typeArrayMap) Get(key []Type) interface{} {
 	ent, ok := m[hashTypeArray(key)];
 	if !ok {
-		return nil;
+		return nil
 	}
 
 nextEnt:
 	for ; ent != nil; ent = ent.next {
 		if len(key) != len(ent.key) {
-			continue;
+			continue
 		}
 		for i := 0; i < len(key); i++ {
 			if key[i] != ent.key[i] {
-				continue nextEnt;
+				continue nextEnt
 			}
 		}
 		// Found it
@@ -165,7 +165,7 @@ func (boolType) String() string {
 	// Use angle brackets as a convention for printing the
 	// underlying, unnamed type.  This should only show up in
 	// debug output.
-	return "<bool>";
+	return "<bool>"
 }
 
 func (t *boolType) Zero() Value {
@@ -241,9 +241,9 @@ func (t *uintType) maxVal() *bignum.Rational {
 	bits := t.Bits;
 	if bits == 0 {
 		if t.Ptr {
-			bits = uint(8 * unsafe.Sizeof(uintptr(0)));
+			bits = uint(8 * unsafe.Sizeof(uintptr(0)))
 		} else {
-			bits = uint(8 * unsafe.Sizeof(uint(0)));
+			bits = uint(8 * unsafe.Sizeof(uint(0)))
 		}
 	}
 	return bignum.MakeRat(bignum.Int(1).Shl(bits).Add(bignum.Int(-1)), bignum.Nat(1));
@@ -311,7 +311,7 @@ func (t *intType) Zero() Value {
 func (t *intType) minVal() *bignum.Rational {
 	bits := t.Bits;
 	if bits == 0 {
-		bits = uint(8 * unsafe.Sizeof(int(0)));
+		bits = uint(8 * unsafe.Sizeof(int(0)))
 	}
 	return bignum.MakeRat(bignum.Int(-1).Shl(bits-1), bignum.Nat(1));
 }
@@ -319,7 +319,7 @@ func (t *intType) minVal() *bignum.Rational {
 func (t *intType) maxVal() *bignum.Rational {
 	bits := t.Bits;
 	if bits == 0 {
-		bits = uint(8 * unsafe.Sizeof(int(0)));
+		bits = uint(8 * unsafe.Sizeof(int(0)))
 	}
 	return bignum.MakeRat(bignum.Int(1).Shl(bits-1).Add(bignum.Int(-1)), bignum.Nat(1));
 }
@@ -402,13 +402,13 @@ var minFloat64Val = maxFloat64Val.Neg()
 func (t *floatType) minVal() *bignum.Rational {
 	bits := t.Bits;
 	if bits == 0 {
-		bits = uint(8 * unsafe.Sizeof(float(0)));
+		bits = uint(8 * unsafe.Sizeof(float(0)))
 	}
 	switch bits {
 	case 32:
-		return minFloat32Val;
+		return minFloat32Val
 	case 64:
-		return minFloat64Val;
+		return minFloat64Val
 	}
 	log.Crashf("unexpected floating point bit count: %d", bits);
 	panic();
@@ -417,13 +417,13 @@ func (t *floatType) minVal() *bignum.Rational {
 func (t *floatType) maxVal() *bignum.Rational {
 	bits := t.Bits;
 	if bits == 0 {
-		bits = uint(8 * unsafe.Sizeof(float(0)));
+		bits = uint(8 * unsafe.Sizeof(float(0)))
 	}
 	switch bits {
 	case 32:
-		return maxFloat32Val;
+		return maxFloat32Val
 	case 64:
-		return maxFloat64Val;
+		return maxFloat64Val
 	}
 	log.Crashf("unexpected floating point bit count: %d", bits);
 	panic();
@@ -510,7 +510,7 @@ func NewArrayType(len int64, elem Type) *ArrayType {
 func (t *ArrayType) compat(o Type, conv bool) bool {
 	t2, ok := o.lit().(*ArrayType);
 	if !ok {
-		return false;
+		return false
 	}
 	return t.Len == t2.Len && t.Elem.compat(t2.Elem, conv);
 }
@@ -527,7 +527,7 @@ func (t *ArrayType) Zero() Value {
 	// arrays.  Or we could do something unsafe.  We'll have this
 	// same problem with structs.
 	for i := int64(0); i < t.Len; i++ {
-		res[i] = t.Elem.Zero();
+		res[i] = t.Elem.Zero()
 	}
 	return &res;
 }
@@ -558,11 +558,11 @@ func NewStructType(fields []StructField) *StructType {
 	// Start by looking up just the types
 	fts := make([]Type, len(fields));
 	for i, f := range fields {
-		fts[i] = f.Type;
+		fts[i] = f.Type
 	}
 	tMapI := structTypes.Get(fts);
 	if tMapI == nil {
-		tMapI = structTypes.Put(fts, make(map[string]*StructType));
+		tMapI = structTypes.Put(fts, make(map[string]*StructType))
 	}
 	tMap := tMapI.(map[string]*StructType);
 
@@ -578,7 +578,7 @@ func NewStructType(fields []StructField) *StructType {
 		// else.  We decided that they should be neither
 		// identical or compatible.
 		if f.Anonymous {
-			key += "!";
+			key += "!"
 		}
 		key += f.Name + " ";
 	}
@@ -600,10 +600,10 @@ func NewStructType(fields []StructField) *StructType {
 func (t *StructType) compat(o Type, conv bool) bool {
 	t2, ok := o.lit().(*StructType);
 	if !ok {
-		return false;
+		return false
 	}
 	if len(t.Elems) != len(t2.Elems) {
-		return false;
+		return false
 	}
 	for i, e := range t.Elems {
 		e2 := t2.Elems[i];
@@ -612,7 +612,7 @@ func (t *StructType) compat(o Type, conv bool) bool {
 		if e.Anonymous != e2.Anonymous ||
 			(!e.Anonymous && e.Name != e2.Name) ||
 			!e.Type.compat(e2.Type, conv) {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -624,10 +624,10 @@ func (t *StructType) String() string {
 	s := "struct {";
 	for i, f := range t.Elems {
 		if i > 0 {
-			s += "; ";
+			s += "; "
 		}
 		if !f.Anonymous {
-			s += f.Name + " ";
+			s += f.Name + " "
 		}
 		s += f.Type.String();
 	}
@@ -637,7 +637,7 @@ func (t *StructType) String() string {
 func (t *StructType) Zero() Value {
 	res := structV(make([]Value, len(t.Elems)));
 	for i, f := range t.Elems {
-		res[i] = f.Type.Zero();
+		res[i] = f.Type.Zero()
 	}
 	return &res;
 }
@@ -667,7 +667,7 @@ func NewPtrType(elem Type) *PtrType {
 func (t *PtrType) compat(o Type, conv bool) bool {
 	t2, ok := o.lit().(*PtrType);
 	if !ok {
-		return false;
+		return false
 	}
 	return t.Elem.compat(t2.Elem, conv);
 }
@@ -716,18 +716,18 @@ var (
 func NewFuncType(in []Type, variadic bool, out []Type) *FuncType {
 	inMap := funcTypes;
 	if variadic {
-		inMap = variadicFuncTypes;
+		inMap = variadicFuncTypes
 	}
 
 	outMapI := inMap.Get(in);
 	if outMapI == nil {
-		outMapI = inMap.Put(in, newTypeArrayMap());
+		outMapI = inMap.Put(in, newTypeArrayMap())
 	}
 	outMap := outMapI.(typeArrayMap);
 
 	tI := outMap.Get(out);
 	if tI != nil {
-		return tI.(*FuncType);
+		return tI.(*FuncType)
 	}
 
 	t := &FuncType{commonType{}, in, variadic, out, ""};
@@ -738,19 +738,19 @@ func NewFuncType(in []Type, variadic bool, out []Type) *FuncType {
 func (t *FuncType) compat(o Type, conv bool) bool {
 	t2, ok := o.lit().(*FuncType);
 	if !ok {
-		return false;
+		return false
 	}
 	if len(t.In) != len(t2.In) || t.Variadic != t2.Variadic || len(t.Out) != len(t2.Out) {
-		return false;
+		return false
 	}
 	for i := range t.In {
 		if !t.In[i].compat(t2.In[i], conv) {
-			return false;
+			return false
 		}
 	}
 	for i := range t.Out {
 		if !t.Out[i].compat(t2.Out[i], conv) {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -762,16 +762,16 @@ func typeListString(ts []Type, ns []*ast.Ident) string {
 	s := "";
 	for i, t := range ts {
 		if i > 0 {
-			s += ", ";
+			s += ", "
 		}
 		if ns != nil && ns[i] != nil {
-			s += ns[i].Value + " ";
+			s += ns[i].Value + " "
 		}
 		if t == nil {
 			// Some places use nil types to represent errors
-			s += "<none>";
+			s += "<none>"
 		} else {
-			s += t.String();
+			s += t.String()
 		}
 	}
 	return s;
@@ -779,18 +779,18 @@ func typeListString(ts []Type, ns []*ast.Ident) string {
 
 func (t *FuncType) String() string {
 	if t.builtin != "" {
-		return "built-in function " + t.builtin;
+		return "built-in function " + t.builtin
 	}
 	args := typeListString(t.In, nil);
 	if t.Variadic {
 		if len(args) > 0 {
-			args += ", ";
+			args += ", "
 		}
 		args += "...";
 	}
 	s := "func("+args+")";
 	if len(t.Out) > 0 {
-		s += " (" + typeListString(t.Out, nil) + ")";
+		s += " (" + typeListString(t.Out, nil) + ")"
 	}
 	return s;
 }
@@ -809,7 +809,7 @@ type FuncDecl struct {
 func (t *FuncDecl) String() string {
 	s := "func";
 	if t.Name != nil {
-		s += " " + t.Name.Value;
+		s += " " + t.Name.Value
 	}
 	s += funcTypeString(t.Type, t.InNames, t.OutNames);
 	return s;
@@ -820,13 +820,13 @@ func funcTypeString(ft *FuncType, ins []*ast.Ident, outs []*ast.Ident) string {
 	s += typeListString(ft.In, ins);
 	if ft.Variadic {
 		if len(ft.In) > 0 {
-			s += ", ";
+			s += ", "
 		}
 		s += "...";
 	}
 	s += ")";
 	if len(ft.Out) > 0 {
-		s += " (" + typeListString(ft.Out, outs) + ")";
+		s += " (" + typeListString(ft.Out, outs) + ")"
 	}
 	return s;
 }
@@ -858,13 +858,13 @@ func NewInterfaceType(methods []IMethod, embeds []*InterfaceType) *InterfaceType
 	// Count methods of embedded interfaces
 	nMethods := len(methods);
 	for _, e := range embeds {
-		nMethods += len(e.methods);
+		nMethods += len(e.methods)
 	}
 
 	// Combine methods
 	allMethods := make([]IMethod, nMethods);
 	for i, m := range methods {
-		allMethods[i] = m;
+		allMethods[i] = m
 	}
 	n := len(methods);
 	for _, e := range embeds {
@@ -879,17 +879,17 @@ func NewInterfaceType(methods []IMethod, embeds []*InterfaceType) *InterfaceType
 
 	mts := make([]Type, len(allMethods));
 	for i, m := range methods {
-		mts[i] = m.Type;
+		mts[i] = m.Type
 	}
 	tMapI := interfaceTypes.Get(mts);
 	if tMapI == nil {
-		tMapI = interfaceTypes.Put(mts, make(map[string]*InterfaceType));
+		tMapI = interfaceTypes.Put(mts, make(map[string]*InterfaceType))
 	}
 	tMap := tMapI.(map[string]*InterfaceType);
 
 	key := "";
 	for _, m := range allMethods {
-		key += m.Name + " ";
+		key += m.Name + " "
 	}
 
 	t, ok := tMap[key];
@@ -911,15 +911,15 @@ func (s iMethodSorter) Len() int	{ return len(s) }
 func (t *InterfaceType) compat(o Type, conv bool) bool {
 	t2, ok := o.lit().(*InterfaceType);
 	if !ok {
-		return false;
+		return false
 	}
 	if len(t.methods) != len(t2.methods) {
-		return false;
+		return false
 	}
 	for i, e := range t.methods {
 		e2 := t2.methods[i];
 		if e.Name != e2.Name || !e.Type.compat(e2.Type, conv) {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -933,7 +933,7 @@ func (t *InterfaceType) String() string {
 	s := "interface {";
 	for i, m := range t.methods {
 		if i > 0 {
-			s += "; ";
+			s += "; "
 		}
 		s += m.Name + funcTypeString(m.Type, nil, nil);
 	}
@@ -944,13 +944,13 @@ func (t *InterfaceType) String() string {
 // Otherwise, it returns a method of t that o is missing and false.
 func (t *InterfaceType) implementedBy(o Type) (*IMethod, bool) {
 	if len(t.methods) == 0 {
-		return nil, true;
+		return nil, true
 	}
 
 	// The methods of a named interface types are those of the
 	// underlying type.
 	if it, ok := o.lit().(*InterfaceType); ok {
-		o = it;
+		o = it
 	}
 
 	// XXX(Spec) Interface types: "A type implements any interface
@@ -963,7 +963,7 @@ func (t *InterfaceType) implementedBy(o Type) (*IMethod, bool) {
 		for _, tm := range t.methods {
 			sm, ok := o.methods[tm.Name];
 			if !ok || sm.decl.Type != tm.Type {
-				return &tm, false;
+				return &tm, false
 			}
 		}
 		return nil, true;
@@ -975,18 +975,18 @@ func (t *InterfaceType) implementedBy(o Type) (*IMethod, bool) {
 			switch {
 			case tm.Name == om.Name:
 				if tm.Type != om.Type {
-					return tm, false;
+					return tm, false
 				}
 				ti++;
 				oi++;
 			case tm.Name > om.Name:
-				oi++;
+				oi++
 			default:
-				return tm, false;
+				return tm, false
 			}
 		}
 		if ti < len(t.methods) {
-			return &t.methods[ti], false;
+			return &t.methods[ti], false
 		}
 		return nil, true;
 	}
@@ -1021,7 +1021,7 @@ func NewSliceType(elem Type) *SliceType {
 func (t *SliceType) compat(o Type, conv bool) bool {
 	t2, ok := o.lit().(*SliceType);
 	if !ok {
-		return false;
+		return false
 	}
 	return t.Elem.compat(t2.Elem, conv);
 }
@@ -1033,7 +1033,7 @@ func (t *SliceType) String() string	{ return "[]" + t.Elem.String() }
 func (t *SliceType) Zero() Value {
 	// The value of an uninitialized slice is nil. The length and
 	// capacity of a nil slice are 0.
-	return &sliceV{Slice{nil, 0, 0}};
+	return &sliceV{Slice{nil, 0, 0}}
 }
 
 /*
@@ -1065,7 +1065,7 @@ func NewMapType(key Type, elem Type) *MapType {
 func (t *MapType) compat(o Type, conv bool) bool {
 	t2, ok := o.lit().(*MapType);
 	if !ok {
-		return false;
+		return false
 	}
 	return t.Elem.compat(t2.Elem, conv) && t.Key.compat(t2.Key, conv);
 }
@@ -1076,7 +1076,7 @@ func (t *MapType) String() string	{ return "map[" + t.Key.String() + "] " + t.El
 
 func (t *MapType) Zero() Value {
 	// The value of an uninitialized map is nil.
-	return &mapV{nil};
+	return &mapV{nil}
 }
 
 /*
@@ -1109,17 +1109,17 @@ type NamedType struct {
 // TODO(austin) This is temporarily needed by the debugger's remote
 // type parser.  This should only be possible with block.DefineType.
 func NewNamedType(name string) *NamedType {
-	return &NamedType{token.Position{}, name, nil, true, make(map[string]Method)};
+	return &NamedType{token.Position{}, name, nil, true, make(map[string]Method)}
 }
 
 func (t *NamedType) Complete(def Type) {
 	if !t.incomplete {
-		log.Crashf("cannot complete already completed NamedType %+v", *t);
+		log.Crashf("cannot complete already completed NamedType %+v", *t)
 	}
 	// We strip the name from def because multiple levels of
 	// naming are useless.
 	if ndef, ok := def.(*NamedType); ok {
-		def = ndef.Def;
+		def = ndef.Def
 	}
 	t.Def = def;
 	t.incomplete = false;
@@ -1132,12 +1132,12 @@ func (t *NamedType) compat(o Type, conv bool) bool {
 			// Two named types are conversion compatible
 			// if their literals are conversion
 			// compatible.
-			return t.Def.compat(t2.Def, conv);
+			return t.Def.compat(t2.Def, conv)
 		} else {
 			// Two named types are compatible if their
 			// type names originate in the same type
 			// declaration.
-			return t == t2;
+			return t == t2
 		}
 	}
 	// A named and an unnamed type are compatible if the
@@ -1175,7 +1175,7 @@ var multiTypes = newTypeArrayMap()
 
 func NewMultiType(elems []Type) *MultiType {
 	if t := multiTypes.Get(elems); t != nil {
-		return t.(*MultiType);
+		return t.(*MultiType)
 	}
 
 	t := &MultiType{commonType{}, elems};
@@ -1186,14 +1186,14 @@ func NewMultiType(elems []Type) *MultiType {
 func (t *MultiType) compat(o Type, conv bool) bool {
 	t2, ok := o.lit().(*MultiType);
 	if !ok {
-		return false;
+		return false
 	}
 	if len(t.Elems) != len(t2.Elems) {
-		return false;
+		return false
 	}
 	for i := range t.Elems {
 		if !t.Elems[i].compat(t2.Elems[i], conv) {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -1205,7 +1205,7 @@ func (t *MultiType) lit() Type	{ return t }
 
 func (t *MultiType) String() string {
 	if len(t.Elems) == 0 {
-		return "<none>";
+		return "<none>"
 	}
 	return typeListString(t.Elems, nil);
 }
@@ -1213,7 +1213,7 @@ func (t *MultiType) String() string {
 func (t *MultiType) Zero() Value {
 	res := make([]Value, len(t.Elems));
 	for i, t := range t.Elems {
-		res[i] = t.Zero();
+		res[i] = t.Zero()
 	}
 	return multiV(res);
 }
diff --git a/src/pkg/exp/eval/typec.go b/src/pkg/exp/eval/typec.go
index d771adadaa..a2823b40d2 100644
--- a/src/pkg/exp/eval/typec.go
+++ b/src/pkg/exp/eval/typec.go
@@ -45,11 +45,11 @@ func (a *typeCompiler) compileIdent(x *ast.Ident, allowRec bool) Type {
 		}
 		if !def.incomplete && def.Def == nil {
 			// Placeholder type from an earlier error
-			return nil;
+			return nil
 		}
 		return def;
 	case Type:
-		return def;
+		return def
 	}
 	log.Crashf("name %s has unknown type %T", x.Value, def);
 	return nil;
@@ -62,7 +62,7 @@ func (a *typeCompiler) compileArrayType(x *ast.ArrayType, allowRec bool) Type {
 	// Compile length expression
 	if x.Len == nil {
 		if elem == nil {
-			return nil;
+			return nil
 		}
 		return NewSliceType(elem);
 	}
@@ -73,14 +73,14 @@ func (a *typeCompiler) compileArrayType(x *ast.ArrayType, allowRec bool) Type {
 	}
 	l, ok := a.compileArrayLen(a.block, x.Len);
 	if !ok {
-		return nil;
+		return nil
 	}
 	if l < 0 {
 		a.diagAt(x.Len, "array length must be non-negative");
 		return nil;
 	}
 	if elem == nil {
-		return nil;
+		return nil
 	}
 
 	return NewArrayType(l, elem);
@@ -90,9 +90,9 @@ func countFields(fs []*ast.Field) int {
 	n := 0;
 	for _, f := range fs {
 		if f.Names == nil {
-			n++;
+			n++
 		} else {
-			n += len(f.Names);
+			n += len(f.Names)
 		}
 	}
 	return n;
@@ -109,7 +109,7 @@ func (a *typeCompiler) compileFields(fs []*ast.Field, allowRec bool) ([]Type, []
 	for _, f := range fs {
 		t := a.compileType(f.Type, allowRec);
 		if t == nil {
-			bad = true;
+			bad = true
 		}
 		if f.Names == nil {
 			ns[i] = nil;
@@ -147,10 +147,10 @@ func (a *typeCompiler) compileStructType(x *ast.StructType, allowRec bool) Type
 		// Compute field name and check anonymous fields
 		var name string;
 		if names[i] != nil {
-			name = names[i].Value;
+			name = names[i].Value
 		} else {
 			if ts[i] == nil {
-				continue;
+				continue
 			}
 
 			var nt *NamedType;
@@ -204,7 +204,7 @@ func (a *typeCompiler) compileStructType(x *ast.StructType, allowRec bool) Type
 	}
 
 	if bad {
-		return nil;
+		return nil
 	}
 
 	return NewStructType(fields);
@@ -213,7 +213,7 @@ func (a *typeCompiler) compileStructType(x *ast.StructType, allowRec bool) Type
 func (a *typeCompiler) compilePtrType(x *ast.StarExpr) Type {
 	elem := a.compileType(x.X, true);
 	if elem == nil {
-		return nil;
+		return nil
 	}
 	return NewPtrType(elem);
 }
@@ -228,7 +228,7 @@ func (a *typeCompiler) compileFuncType(x *ast.FuncType, allowRec bool) *FuncDecl
 	out, outNames, _, outBad := a.compileFields(x.Results, allowRec);
 
 	if inBad || outBad {
-		return nil;
+		return nil
 	}
 	return &FuncDecl{NewFuncType(in, false, out), nil, inNames, outNames};
 }
@@ -243,7 +243,7 @@ func (a *typeCompiler) compileInterfaceType(x *ast.InterfaceType, allowRec bool)
 	var nm, ne int;
 	for i := range ts {
 		if ts[i] == nil {
-			continue;
+			continue
 		}
 
 		if names[i] != nil {
@@ -279,7 +279,7 @@ func (a *typeCompiler) compileInterfaceType(x *ast.InterfaceType, allowRec bool)
 	}
 
 	if bad {
-		return nil;
+		return nil
 	}
 
 	methods = methods[0:nm];
@@ -292,7 +292,7 @@ func (a *typeCompiler) compileMapType(x *ast.MapType) Type {
 	key := a.compileType(x.Key, true);
 	val := a.compileType(x.Value, true);
 	if key == nil || val == nil {
-		return nil;
+		return nil
 	}
 	// XXX(Spec) The Map types section explicitly lists all types
 	// that can be map keys except for function types.
@@ -318,35 +318,35 @@ func (a *typeCompiler) compileType(x ast.Expr, allowRec bool) Type {
 		return nil;
 
 	case *ast.Ident:
-		return a.compileIdent(x, allowRec);
+		return a.compileIdent(x, allowRec)
 
 	case *ast.ArrayType:
-		return a.compileArrayType(x, allowRec);
+		return a.compileArrayType(x, allowRec)
 
 	case *ast.StructType:
-		return a.compileStructType(x, allowRec);
+		return a.compileStructType(x, allowRec)
 
 	case *ast.StarExpr:
-		return a.compilePtrType(x);
+		return a.compilePtrType(x)
 
 	case *ast.FuncType:
 		fd := a.compileFuncType(x, allowRec);
 		if fd == nil {
-			return nil;
+			return nil
 		}
 		return fd.Type;
 
 	case *ast.InterfaceType:
-		return a.compileInterfaceType(x, allowRec);
+		return a.compileInterfaceType(x, allowRec)
 
 	case *ast.MapType:
-		return a.compileMapType(x);
+		return a.compileMapType(x)
 
 	case *ast.ChanType:
-		goto notimpl;
+		goto notimpl
 
 	case *ast.ParenExpr:
-		return a.compileType(x.X, allowRec);
+		return a.compileType(x.X, allowRec)
 
 	case *ast.Ellipsis:
 		a.diagAt(x, "illegal use of ellipsis");
@@ -370,7 +370,7 @@ func (a *compiler) compileType(b *block, typ ast.Expr) Type {
 	tc := &typeCompiler{a, b, noLateCheck};
 	t := tc.compileType(typ, false);
 	if !tc.lateCheck() {
-		t = nil;
+		t = nil
 	}
 	return t;
 }
@@ -382,25 +382,25 @@ func (a *compiler) compileTypeDecl(b *block, decl *ast.GenDecl) bool {
 		// Create incomplete type for this type
 		nt := b.DefineType(spec.Name.Value, spec.Name.Pos(), nil);
 		if nt != nil {
-			nt.(*NamedType).incomplete = true;
+			nt.(*NamedType).incomplete = true
 		}
 		// Compile type
 		tc := &typeCompiler{a, b, noLateCheck};
 		t := tc.compileType(spec.Type, false);
 		if t == nil {
 			// Create a placeholder type
-			ok = false;
+			ok = false
 		}
 		// Fill incomplete type
 		if nt != nil {
-			nt.(*NamedType).Complete(t);
+			nt.(*NamedType).Complete(t)
 		}
 		// Perform late type checking with complete type
 		if !tc.lateCheck() {
 			ok = false;
 			if nt != nil {
 				// Make the type a placeholder
-				nt.(*NamedType).Def = nil;
+				nt.(*NamedType).Def = nil
 			}
 		}
 	}
@@ -412,7 +412,7 @@ func (a *compiler) compileFuncType(b *block, typ *ast.FuncType) *FuncDecl {
 	res := tc.compileFuncType(typ, false);
 	if res != nil {
 		if !tc.lateCheck() {
-			res = nil;
+			res = nil
 		}
 	}
 	return res;
diff --git a/src/pkg/exp/eval/util.go b/src/pkg/exp/eval/util.go
index 9cdf237221..bee767d882 100644
--- a/src/pkg/exp/eval/util.go
+++ b/src/pkg/exp/eval/util.go
@@ -15,7 +15,7 @@ func ratToString(rat *bignum.Rational) string {
 	w, frac := n.QuoRem(d);
 	out := w.String();
 	if frac.IsZero() {
-		return out;
+		return out
 	}
 
 	r := frac.Abs();
@@ -23,14 +23,14 @@ func ratToString(rat *bignum.Rational) string {
 	dec, tail := r.DivMod(dnat);
 	// Round last digit
 	if tail.Cmp(dnat.Div(bignum.Nat(2))) >= 0 {
-		dec = dec.Add(bignum.Nat(1));
+		dec = dec.Add(bignum.Nat(1))
 	}
 	// Strip zeros
 	ten := bignum.Nat(10);
 	for !dec.IsZero() {
 		dec2, r2 := dec.DivMod(ten);
 		if !r2.IsZero() {
-			break;
+			break
 		}
 		dec = dec2;
 	}
diff --git a/src/pkg/exp/eval/value.go b/src/pkg/exp/eval/value.go
index d57920538d..4956cf33a6 100644
--- a/src/pkg/exp/eval/value.go
+++ b/src/pkg/exp/eval/value.go
@@ -278,7 +278,7 @@ type idealIntV struct {
 func (v *idealIntV) String() string	{ return v.V.String() }
 
 func (v *idealIntV) Assign(t *Thread, o Value) {
-	v.V = o.(IdealIntValue).Get();
+	v.V = o.(IdealIntValue).Get()
 }
 
 func (v *idealIntV) Get() *bignum.Integer	{ return v.V }
@@ -328,7 +328,7 @@ type idealFloatV struct {
 func (v *idealFloatV) String() string	{ return ratToString(v.V) }
 
 func (v *idealFloatV) Assign(t *Thread, o Value) {
-	v.V = o.(IdealFloatValue).Get();
+	v.V = o.(IdealFloatValue).Get()
 }
 
 func (v *idealFloatV) Get() *bignum.Rational	{ return v.V }
@@ -357,7 +357,7 @@ func (v *arrayV) String() string {
 	res := "{";
 	for i, e := range *v {
 		if i > 0 {
-			res += ", ";
+			res += ", "
 		}
 		res += e.String();
 	}
@@ -368,14 +368,14 @@ func (v *arrayV) Assign(t *Thread, o Value) {
 	oa := o.(ArrayValue);
 	l := int64(len(*v));
 	for i := int64(0); i < l; i++ {
-		(*v)[i].Assign(t, oa.Elem(t, i));
+		(*v)[i].Assign(t, oa.Elem(t, i))
 	}
 }
 
 func (v *arrayV) Get(*Thread) ArrayValue	{ return v }
 
 func (v *arrayV) Elem(t *Thread, i int64) Value {
-	return (*v)[i];
+	return (*v)[i]
 }
 
 func (v *arrayV) Sub(i int64, len int64) ArrayValue {
@@ -395,7 +395,7 @@ func (v *structV) String() string {
 	res := "{";
 	for i, v := range *v {
 		if i > 0 {
-			res += ", ";
+			res += ", "
 		}
 		res += v.String();
 	}
@@ -406,14 +406,14 @@ func (v *structV) Assign(t *Thread, o Value) {
 	oa := o.(StructValue);
 	l := len(*v);
 	for i := 0; i < l; i++ {
-		(*v)[i].Assign(t, oa.Field(t, i));
+		(*v)[i].Assign(t, oa.Field(t, i))
 	}
 }
 
 func (v *structV) Get(*Thread) StructValue	{ return v }
 
 func (v *structV) Field(t *Thread, i int) Value {
-	return (*v)[i];
+	return (*v)[i]
 }
 
 /*
@@ -427,7 +427,7 @@ type ptrV struct {
 
 func (v *ptrV) String() string {
 	if v.target == nil {
-		return "<nil>";
+		return "<nil>"
 	}
 	return "&" + v.target.String();
 }
@@ -448,7 +448,7 @@ type funcV struct {
 
 func (v *funcV) String() string {
 	// TODO(austin) Rob wants to see the definition
-	return "func {...}";
+	return "func {...}"
 }
 
 func (v *funcV) Assign(t *Thread, o Value)	{ v.target = o.(FuncValue).Get(t) }
@@ -467,19 +467,19 @@ type interfaceV struct {
 
 func (v *interfaceV) String() string {
 	if v.Type == nil || v.Value == nil {
-		return "<nil>";
+		return "<nil>"
 	}
 	return v.Value.String();
 }
 
 func (v *interfaceV) Assign(t *Thread, o Value) {
-	v.Interface = o.(InterfaceValue).Get(t);
+	v.Interface = o.(InterfaceValue).Get(t)
 }
 
 func (v *interfaceV) Get(*Thread) Interface	{ return v.Interface }
 
 func (v *interfaceV) Set(t *Thread, x Interface) {
-	v.Interface = x;
+	v.Interface = x
 }
 
 /*
@@ -492,7 +492,7 @@ type sliceV struct {
 
 func (v *sliceV) String() string {
 	if v.Base == nil {
-		return "<nil>";
+		return "<nil>"
 	}
 	return v.Base.Sub(0, v.Len).String();
 }
@@ -513,13 +513,13 @@ type mapV struct {
 
 func (v *mapV) String() string {
 	if v.target == nil {
-		return "<nil>";
+		return "<nil>"
 	}
 	res := "map[";
 	i := 0;
 	v.target.Iter(func(key interface{}, val Value) bool {
 		if i > 0 {
-			res += ", ";
+			res += ", "
 		}
 		i++;
 		res += fmt.Sprint(key) + ":" + val.String();
@@ -540,23 +540,23 @@ func (m evalMap) Len(t *Thread) int64	{ return int64(len(m)) }
 
 func (m evalMap) Elem(t *Thread, key interface{}) Value {
 	if v, ok := m[key]; ok {
-		return v;
+		return v
 	}
 	return nil;
 }
 
 func (m evalMap) SetElem(t *Thread, key interface{}, val Value) {
 	if val == nil {
-		m[key] = nil, false;
+		m[key] = nil, false
 	} else {
-		m[key] = val;
+		m[key] = val
 	}
 }
 
 func (m evalMap) Iter(cb func(key interface{}, val Value) bool) {
 	for k, v := range m {
 		if !cb(k, v) {
-			break;
+			break
 		}
 	}
 }
@@ -571,7 +571,7 @@ func (v multiV) String() string {
 	res := "(";
 	for i, v := range v {
 		if i > 0 {
-			res += ", ";
+			res += ", "
 		}
 		res += v.String();
 	}
@@ -581,7 +581,7 @@ func (v multiV) String() string {
 func (v multiV) Assign(t *Thread, o Value) {
 	omv := o.(multiV);
 	for i := range v {
-		v[i].Assign(t, omv[i]);
+		v[i].Assign(t, omv[i])
 	}
 }
 
diff --git a/src/pkg/exp/eval/world.go b/src/pkg/exp/eval/world.go
index 8218c24f5b..e6e6eed419 100644
--- a/src/pkg/exp/eval/world.go
+++ b/src/pkg/exp/eval/world.go
@@ -44,7 +44,7 @@ type stmtCode struct {
 func (w *World) CompileStmtList(stmts []ast.Stmt) (Code, os.Error) {
 	if len(stmts) == 1 {
 		if s, ok := stmts[0].(*ast.ExprStmt); ok {
-			return w.CompileExpr(s.X);
+			return w.CompileExpr(s.X)
 		}
 	}
 	errors := scanner.NewErrorVector();
@@ -64,11 +64,11 @@ func (w *World) CompileStmtList(stmts []ast.Stmt) (Code, os.Error) {
 	};
 	nerr := cc.numError();
 	for _, stmt := range stmts {
-		bc.compileStmt(stmt);
+		bc.compileStmt(stmt)
 	}
 	fc.checkLabels();
 	if nerr != cc.numError() {
-		return nil, errors.GetError(scanner.Sorted);
+		return nil, errors.GetError(scanner.Sorted)
 	}
 	return &stmtCode{w, fc.get()}, nil;
 }
@@ -76,7 +76,7 @@ func (w *World) CompileStmtList(stmts []ast.Stmt) (Code, os.Error) {
 func (w *World) CompileDeclList(decls []ast.Decl) (Code, os.Error) {
 	stmts := make([]ast.Stmt, len(decls));
 	for i, d := range decls {
-		stmts[i] = &ast.DeclStmt{d};
+		stmts[i] = &ast.DeclStmt{d}
 	}
 	return w.CompileStmtList(stmts);
 }
@@ -101,7 +101,7 @@ func (w *World) CompileExpr(e ast.Expr) (Code, os.Error) {
 
 	ec := cc.compileExpr(w.scope.block, false, e);
 	if ec == nil {
-		return nil, errors.GetError(scanner.Sorted);
+		return nil, errors.GetError(scanner.Sorted)
 	}
 	var eval func(Value, *Thread);
 	switch t := ec.t.(type) {
@@ -111,7 +111,7 @@ func (w *World) CompileExpr(e ast.Expr) (Code, os.Error) {
 		// nothing
 	default:
 		if tm, ok := t.(*MultiType); ok && len(tm.Elems) == 0 {
-			return &stmtCode{w, code{ec.exec}}, nil;
+			return &stmtCode{w, code{ec.exec}}, nil
 		}
 		eval = genAssign(ec.t, ec);
 	}
@@ -125,9 +125,9 @@ func (e *exprCode) Run() (Value, os.Error) {
 	t.f = e.w.scope.NewFrame(nil);
 	switch e.e.t.(type) {
 	case *idealIntType:
-		return &idealIntV{e.e.asIdealInt()()}, nil;
+		return &idealIntV{e.e.asIdealInt()()}, nil
 	case *idealFloatType:
-		return &idealFloatV{e.e.asIdealFloat()()}, nil;
+		return &idealFloatV{e.e.asIdealFloat()()}, nil
 	}
 	v := e.e.t.Zero();
 	eval := e.eval;
@@ -138,13 +138,13 @@ func (e *exprCode) Run() (Value, os.Error) {
 func (w *World) Compile(text string) (Code, os.Error) {
 	stmts, err := parser.ParseStmtList("input", text);
 	if err == nil {
-		return w.CompileStmtList(stmts);
+		return w.CompileStmtList(stmts)
 	}
 
 	// Otherwise try as DeclList.
 	decls, err1 := parser.ParseDeclList("input", text);
 	if err1 == nil {
-		return w.CompileDeclList(decls);
+		return w.CompileDeclList(decls)
 	}
 
 	// Have to pick an error.
@@ -162,7 +162,7 @@ func (e *RedefinitionError) String() string {
 	res := "identifier " + e.Name + " redeclared";
 	pos := e.Prev.Pos();
 	if pos.IsValid() {
-		res += "; previous declaration at " + pos.String();
+		res += "; previous declaration at " + pos.String()
 	}
 	return res;
 }
@@ -170,7 +170,7 @@ func (e *RedefinitionError) String() string {
 func (w *World) DefineConst(name string, t Type, val Value) os.Error {
 	_, prev := w.scope.DefineConst(name, token.Position{}, t, val);
 	if prev != nil {
-		return &RedefinitionError{name, prev};
+		return &RedefinitionError{name, prev}
 	}
 	return nil;
 }
@@ -178,7 +178,7 @@ func (w *World) DefineConst(name string, t Type, val Value) os.Error {
 func (w *World) DefineVar(name string, t Type, val Value) os.Error {
 	v, prev := w.scope.DefineVar(name, token.Position{}, t);
 	if prev != nil {
-		return &RedefinitionError{name, prev};
+		return &RedefinitionError{name, prev}
 	}
 	v.Init = val;
 	return nil;
diff --git a/src/pkg/exp/iterable/iterable.go b/src/pkg/exp/iterable/iterable.go
index 8ea0becb89..d9836d52ba 100644
--- a/src/pkg/exp/iterable/iterable.go
+++ b/src/pkg/exp/iterable/iterable.go
@@ -16,14 +16,14 @@ type Iterable interface {
 }
 
 func not(f func(interface{}) bool) (func(interface{}) bool) {
-	return func(e interface{}) bool { return !f(e) };
+	return func(e interface{}) bool { return !f(e) }
 }
 
 // All tests whether f is true for every element of iter.
 func All(iter Iterable, f func(interface{}) bool) bool {
 	for e := range iter.Iter() {
 		if !f(e) {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -31,14 +31,14 @@ func All(iter Iterable, f func(interface{}) bool) bool {
 
 // Any tests whether f is true for at least one element of iter.
 func Any(iter Iterable, f func(interface{}) bool) bool {
-	return !All(iter, not(f));
+	return !All(iter, not(f))
 }
 
 // Data returns a slice containing the elements of iter.
 func Data(iter Iterable) []interface{} {
 	vec := vector.New(0);
 	for e := range iter.Iter() {
-		vec.Push(e);
+		vec.Push(e)
 	}
 	return vec.Data();
 }
@@ -53,7 +53,7 @@ type filteredIterable struct {
 func (f *filteredIterable) iterate(out chan<- interface{}) {
 	for e := range f.it.Iter() {
 		if f.f(e) {
-			out <- e;
+			out <- e
 		}
 	}
 	close(out);
@@ -67,14 +67,14 @@ func (f *filteredIterable) Iter() <-chan interface{} {
 
 // Filter returns an Iterable that returns the elements of iter that satisfy f.
 func Filter(iter Iterable, f func(interface{}) bool) Iterable {
-	return &filteredIterable{iter, f};
+	return &filteredIterable{iter, f}
 }
 
 // Find returns the first element of iter that satisfies f.
 // Returns nil if no such element is found.
 func Find(iter Iterable, f func(interface{}) bool) interface{} {
 	for e := range Filter(iter, f).Iter() {
-		return e;
+		return e
 	}
 	return nil;
 }
@@ -95,7 +95,7 @@ type Injector func(interface{}, interface{}) interface{}
 func Inject(iter Iterable, initial interface{}, f Injector) interface{} {
 	acc := initial;
 	for e := range iter.Iter() {
-		acc = f(acc, e);
+		acc = f(acc, e)
 	}
 	return acc;
 }
@@ -108,7 +108,7 @@ type mappedIterable struct {
 
 func (m *mappedIterable) iterate(out chan<- interface{}) {
 	for e := range m.it.Iter() {
-		out <- m.f(e);
+		out <- m.f(e)
 	}
 	close(out);
 }
@@ -122,12 +122,12 @@ func (m *mappedIterable) Iter() <-chan interface{} {
 // Map returns an Iterable that returns the result of applying f to each
 // element of iter.
 func Map(iter Iterable, f func(interface{}) interface{}) Iterable {
-	return &mappedIterable{iter, f};
+	return &mappedIterable{iter, f}
 }
 
 // Partition(iter, f) returns Filter(iter, f) and Filter(iter, !f).
 func Partition(iter Iterable, f func(interface{}) bool) (Iterable, Iterable) {
-	return Filter(iter, f), Filter(iter, not(f));
+	return Filter(iter, f), Filter(iter, not(f))
 }
 
 // TODO:
diff --git a/src/pkg/exp/iterable/iterable_test.go b/src/pkg/exp/iterable/iterable_test.go
index fbb24f7b6e..bb22334f9e 100644
--- a/src/pkg/exp/iterable/iterable_test.go
+++ b/src/pkg/exp/iterable/iterable_test.go
@@ -14,7 +14,7 @@ func (arr IntArray) Iter() <-chan interface{} {
 	ch := make(chan interface{});
 	go func() {
 		for _, x := range arr {
-			ch <- x;
+			ch <- x
 		}
 		close(ch);
 	}();
@@ -30,7 +30,7 @@ func isEven(n interface{}) bool		{ return n.(int) % 2 == 0 }
 func doubler(n interface{}) interface{}	{ return n.(int) * 2 }
 func addOne(n interface{}) interface{}	{ return n.(int) + 1 }
 func adder(acc interface{}, n interface{}) interface{} {
-	return acc.(int) + n.(int);
+	return acc.(int) + n.(int)
 }
 
 // A stream of the natural numbers: 0, 1, 2, 3, ...
@@ -40,7 +40,7 @@ func (i integerStream) Iter() <-chan interface{} {
 	ch := make(chan interface{});
 	go func() {
 		for i := 0; ; i++ {
-			ch <- i;
+			ch <- i
 		}
 	}();
 	return ch;
@@ -48,19 +48,19 @@ func (i integerStream) Iter() <-chan interface{} {
 
 func TestAll(t *testing.T) {
 	if !All(oneToFive, isPositive) {
-		t.Error("All(oneToFive, isPositive) == false");
+		t.Error("All(oneToFive, isPositive) == false")
 	}
 	if All(oneToFive, isAbove3) {
-		t.Error("All(oneToFive, isAbove3) == true");
+		t.Error("All(oneToFive, isAbove3) == true")
 	}
 }
 
 func TestAny(t *testing.T) {
 	if Any(oneToFive, isNegative) {
-		t.Error("Any(oneToFive, isNegative) == true");
+		t.Error("Any(oneToFive, isNegative) == true")
 	}
 	if !Any(oneToFive, isEven) {
-		t.Error("Any(oneToFive, isEven) == false");
+		t.Error("Any(oneToFive, isEven) == false")
 	}
 }
 
@@ -85,7 +85,7 @@ func TestFilter(t *testing.T) {
 	moreInts := Filter(ints, isAbove3).Iter();
 	res := make([]interface{}, 3);
 	for i := 0; i < 3; i++ {
-		res[i] = <-moreInts;
+		res[i] = <-moreInts
 	}
 	assertArraysAreEqual(t, res, []int{4, 5, 6});
 }
@@ -94,14 +94,14 @@ func TestFind(t *testing.T) {
 	ints := integerStream{};
 	first := Find(ints, isAbove3);
 	if first.(int) != 4 {
-		t.Errorf("Find(ints, isAbove3) = %v, want 4", first);
+		t.Errorf("Find(ints, isAbove3) = %v, want 4", first)
 	}
 }
 
 func TestInject(t *testing.T) {
 	res := Inject(oneToFive, 0, adder);
 	if res.(int) != 15 {
-		t.Errorf("Inject(oneToFive, 0, adder) = %v, want 15", res);
+		t.Errorf("Inject(oneToFive, 0, adder) = %v, want 15", res)
 	}
 }
 
diff --git a/src/pkg/exp/nacl/av/av.go b/src/pkg/exp/nacl/av/av.go
index 12801c631e..26844c84f5 100644
--- a/src/pkg/exp/nacl/av/av.go
+++ b/src/pkg/exp/nacl/av/av.go
@@ -57,7 +57,7 @@ var _ draw.Context = (*Window)(nil)
 func (w *Window) KeyboardChan() <-chan int	{ return w.kbdc }
 
 func (w *Window) MouseChan() <-chan draw.Mouse {
-	return w.mousec;
+	return w.mousec
 }
 
 func (w *Window) QuitChan() <-chan bool	{ return w.quitc }
@@ -85,18 +85,18 @@ func Init(subsys int, dx, dy int) (*Window, os.Error) {
 	}
 
 	if xsubsys & SubsystemEmbed != 0 {
-		return nil, os.NewError("not embedded");
+		return nil, os.NewError("not embedded")
 	}
 
 	w := new(Window);
 	err := multimediaInit(xsubsys);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	if subsys & SubsystemVideo != 0 {
 		if dx, dy, err = videoInit(dx, dy); err != nil {
-			return nil, err;
+			return nil, err
 		}
 		w.Image = newImage(dx, dy, bridge.pixel);
 		w.resizec = make(chan bool, 64);
@@ -108,13 +108,13 @@ func Init(subsys int, dx, dy int) (*Window, os.Error) {
 	if subsys & SubsystemAudio != 0 {
 		var n int;
 		if n, err = audioInit(AudioFormatStereo44K, 2048); err != nil {
-			return nil, err;
+			return nil, err
 		}
 		println("audio", n);
 	}
 
 	if subsys & SubsystemVideo != 0 {
-		go w.readEvents();
+		go w.readEvents()
 	}
 
 	return w, nil;
@@ -122,13 +122,13 @@ func Init(subsys int, dx, dy int) (*Window, os.Error) {
 
 func (w *Window) FlushImage() {
 	if w.Image == nil {
-		return;
+		return
 	}
 	videoUpdate(w.Image.Linear);
 }
 
 func multimediaInit(subsys int) (err os.Error) {
-	return os.NewSyscallError("multimedia_init", syscall.MultimediaInit(subsys));
+	return os.NewSyscallError("multimedia_init", syscall.MultimediaInit(subsys))
 }
 
 func videoInit(dx, dy int) (ndx, ndy int, err os.Error) {
@@ -137,7 +137,7 @@ func videoInit(dx, dy int) (ndx, ndy int, err os.Error) {
 		return int(bridge.share.width), int(bridge.share.height), nil;
 	}
 	if e := syscall.VideoInit(dx, dy); e != 0 {
-		return 0, 0, os.NewSyscallError("video_init", int(e));
+		return 0, 0, os.NewSyscallError("video_init", int(e))
 	}
 	return dx, dy, nil;
 }
@@ -156,7 +156,7 @@ func videoPollEvent(ev []byte) (err os.Error) {
 	if srpcEnabled {
 		r := bridge.share.eq.ri;
 		if r == bridge.share.eq.wi {
-			return noEvents;
+			return noEvents
 		}
 		bytes.Copy(ev, &bridge.share.eq.event[r]);
 		bridge.share.eq.ri = (r+1)%eqsize;
@@ -169,7 +169,7 @@ func audioInit(fmt int, want int) (got int, err os.Error) {
 	var x int;
 	e := syscall.AudioInit(fmt, want, &x);
 	if e == 0 {
-		return x, nil;
+		return x, nil
 	}
 	return 0, os.NewSyscallError("audio_init", e);
 }
@@ -190,10 +190,10 @@ func AudioStream(data []uint16) (nextSize int, err os.Error) {
 		return int(audioSize), e;
 	}
 	if data == nil {
-		return int(audioSize), nil;
+		return int(audioSize), nil
 	}
 	if uintptr(len(data))*2 != audioSize {
-		log.Stdoutf("invalid audio size want %d got %d", audioSize, len(data));
+		log.Stdoutf("invalid audio size want %d got %d", audioSize, len(data))
 	}
 	e := os.NewSyscallError("audio_stream", syscall.AudioStream(&data[0], &audioSize));
 	return int(audioSize), e;
@@ -255,7 +255,7 @@ func (multimediaBridge) Run(arg, ret []interface{}, size []int) srpc.Errno {
 
 	var st syscall.Stat_t;
 	if errno := syscall.Fstat(bridge.displayFd, &st); errno != 0 {
-		log.Exitf("mmbridge stat display: %s", os.Errno(errno));
+		log.Exitf("mmbridge stat display: %s", os.Errno(errno))
 	}
 
 	addr, _, errno := syscall.Syscall6(syscall.SYS_MMAP,
@@ -266,7 +266,7 @@ func (multimediaBridge) Run(arg, ret []interface{}, size []int) srpc.Errno {
 		uintptr(bridge.displayFd),
 		0);
 	if errno != 0 {
-		log.Exitf("mmap display: %s", os.Errno(errno));
+		log.Exitf("mmap display: %s", os.Errno(errno))
 	}
 
 	bridge.share = (*videoShare)(unsafe.Pointer(addr));
@@ -281,7 +281,7 @@ func (multimediaBridge) Run(arg, ret []interface{}, size []int) srpc.Errno {
 	var err os.Error;
 	bridge.client, err = srpc.NewClient(bridge.rpcFd);
 	if err != nil {
-		log.Exitf("NewClient: %s", err);
+		log.Exitf("NewClient: %s", err)
 	}
 	bridge.flushRPC = bridge.client.NewRPC(nil);
 
@@ -295,6 +295,6 @@ func (multimediaBridge) Run(arg, ret []interface{}, size []int) srpc.Errno {
 func init() {
 	bridge.c = make(chan bool, 1);
 	if srpcEnabled {
-		srpc.Add("nacl_multimedia_bridge", "hh:", multimediaBridge{});
+		srpc.Add("nacl_multimedia_bridge", "hh:", multimediaBridge{})
 	}
 }
diff --git a/src/pkg/exp/nacl/av/event.go b/src/pkg/exp/nacl/av/event.go
index 0b70b7e9c2..1412153cf0 100644
--- a/src/pkg/exp/nacl/av/event.go
+++ b/src/pkg/exp/nacl/av/event.go
@@ -381,7 +381,7 @@ type reader []byte
 func (r *reader) Read(p []byte) (n int, err os.Error) {
 	b := *r;
 	if len(b) == 0 && len(p) > 0 {
-		return 0, os.EOF;
+		return 0, os.EOF
 	}
 	n = bytes.Copy(p, b);
 	*r = b[n:len(b)];
@@ -403,7 +403,7 @@ func (w *Window) readEvents() {
 	for {
 		if err := videoPollEvent(buf); err != nil {
 			if !clean {
-				clean = w.resizec <- false;
+				clean = w.resizec <- false
 			}
 			time.Sleep(10e6);	// 10ms
 			continue;
@@ -441,11 +441,11 @@ func (w *Window) readEvents() {
 		// log.Stdoutf("%#v\n", e);
 		switch buf[0] {
 		case eventExpose:
-			w.resizec <- true;
+			w.resizec <- true
 		case eventKeyDown:
-			w.kbdc <- int(ke.Key);
+			w.kbdc <- int(ke.Key)
 		case eventKeyUp:
-			w.kbdc <- -int(ke.Key);
+			w.kbdc <- -int(ke.Key)
 		case eventMouseMotion:
 			m.X = int(mme.X);
 			m.Y = int(mme.Y);
@@ -467,7 +467,7 @@ func (w *Window) readEvents() {
 			m.Nsec = time.Nanoseconds();
 			_ = w.mousec <- m;
 		case eventQuit:
-			w.quitc <- true;
+			w.quitc <- true
 		}
 	}
 }
diff --git a/src/pkg/exp/nacl/av/image.go b/src/pkg/exp/nacl/av/image.go
index e92ca8aeb2..0c6099ee3d 100644
--- a/src/pkg/exp/nacl/av/image.go
+++ b/src/pkg/exp/nacl/av/image.go
@@ -26,7 +26,7 @@ func (m *Image) ColorModel() image.ColorModel	{ return ColorModel }
 
 func (m *Image) Width() int {
 	if len(m.Pixel) == 0 {
-		return 0;
+		return 0
 	}
 	return len(m.Pixel[0]);
 }
@@ -37,18 +37,18 @@ func (m *Image) At(x, y int) image.Color	{ return m.Pixel[y][x] }
 
 func (m *Image) Set(x, y int, color image.Color) {
 	if c, ok := color.(Color); ok {
-		m.Pixel[y][x] = c;
+		m.Pixel[y][x] = c
 	}
 	m.Pixel[y][x] = makeColor(color.RGBA());
 }
 
 func newImage(dx, dy int, linear []Color) *Image {
 	if linear == nil {
-		linear = make([]Color, dx*dy);
+		linear = make([]Color, dx*dy)
 	}
 	pix := make([][]Color, dy);
 	for i := range pix {
-		pix[i] = linear[dx*i : dx*(i+1)];
+		pix[i] = linear[dx*i : dx*(i+1)]
 	}
 	return &Image{linear, pix};
 }
@@ -75,12 +75,12 @@ func (p Color) RGBA() (r, g, b, a uint32) {
 }
 
 func makeColor(r, g, b, a uint32) Color {
-	return Color(a>>24<<24 | r>>24<<16 | g>>24<<8 | b>>24);
+	return Color(a>>24<<24 | r>>24<<16 | g>>24<<8 | b>>24)
 }
 
 func toColor(color image.Color) image.Color {
 	if c, ok := color.(Color); ok {
-		return c;
+		return c
 	}
 	return makeColor(color.RGBA());
 }
diff --git a/src/pkg/exp/nacl/srpc/client.go b/src/pkg/exp/nacl/srpc/client.go
index 1a2d5fdc9c..251f501615 100644
--- a/src/pkg/exp/nacl/srpc/client.go
+++ b/src/pkg/exp/nacl/srpc/client.go
@@ -60,7 +60,7 @@ func NewClient(fd int) (c *Client, err os.Error) {
 	c.s.send(m);
 	m, err = c.r.recv();
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	m.unpackResponse();
 	if m.status != OK {
@@ -70,7 +70,7 @@ func NewClient(fd int) (c *Client, err os.Error) {
 	for n, line := range bytes.Split(m.Ret[0].([]byte), []byte{'\n'}, 0) {
 		i := bytes.Index(line, []byte{':'});
 		if i < 0 {
-			continue;
+			continue
 		}
 		c.service[string(line[0:i])] = srv{uint32(n), string(line[i+1 : len(line)])};
 	}
@@ -85,7 +85,7 @@ func (c *Client) input() {
 	for {
 		m, err := c.r.recv();
 		if err != nil {
-			log.Exitf("client recv: %s", err);
+			log.Exitf("client recv: %s", err)
 		}
 		if m.unpackResponse(); m.status != OK {
 			log.Stderrf("invalid message: %s", m.status);
@@ -94,7 +94,7 @@ func (c *Client) input() {
 		c.mu.Lock();
 		rpc, ok := c.pending[m.requestId];
 		if ok {
-			c.pending[m.requestId] = nil, false;
+			c.pending[m.requestId] = nil, false
 		}
 		c.mu.Unlock();
 		if !ok {
@@ -108,14 +108,14 @@ func (c *Client) input() {
 
 func (c *Client) output() {
 	for m := range c.out {
-		c.s.send(m);
+		c.s.send(m)
 	}
 }
 
 // NewRPC creates a new RPC on the client connection.
 func (c *Client) NewRPC(done chan *RPC) *RPC {
 	if done == nil {
-		done = make(chan *RPC);
+		done = make(chan *RPC)
 	}
 	c.mu.Lock();
 	id := c.idGen;
@@ -157,7 +157,7 @@ func (r *RPC) Start(name string, arg []interface{}) {
 	// will do that anyway.
 	i := 0;
 	for srv.fmt[i] != ':' {
-		i++;
+		i++
 	}
 	fmt := srv.fmt[i+1 : len(srv.fmt)];
 
@@ -167,21 +167,21 @@ func (r *RPC) Start(name string, arg []interface{}) {
 	for i := 0; i < len(fmt); i++ {
 		switch fmt[i] {
 		default:
-			log.Exitf("unexpected service type %c", fmt[i]);
+			log.Exitf("unexpected service type %c", fmt[i])
 		case 'b':
-			m.Ret[i] = false;
+			m.Ret[i] = false
 		case 'C':
 			m.Ret[i] = []byte(nil);
 			m.Size[i] = 1<<30;
 		case 'd':
-			m.Ret[i] = float64(0);
+			m.Ret[i] = float64(0)
 		case 'D':
 			m.Ret[i] = []float64(nil);
 			m.Size[i] = 1<<30;
 		case 'h':
-			m.Ret[i] = int(-1);
+			m.Ret[i] = int(-1)
 		case 'i':
-			m.Ret[i] = int32(0);
+			m.Ret[i] = int32(0)
 		case 'I':
 			m.Ret[i] = []int32(nil);
 			m.Size[i] = 1<<30;
diff --git a/src/pkg/exp/nacl/srpc/msg.go b/src/pkg/exp/nacl/srpc/msg.go
index e6ab4aa8fc..f158b13856 100644
--- a/src/pkg/exp/nacl/srpc/msg.go
+++ b/src/pkg/exp/nacl/srpc/msg.go
@@ -52,7 +52,7 @@ var errstr = [...]string{
 
 func (e Errno) String() string {
 	if e < OK || int(e-OK) >= len(errstr) {
-		return "Errno(" + strconv.Itoa64(int64(e)) + ")";
+		return "Errno(" + strconv.Itoa64(int64(e)) + ")"
 	}
 	return errstr[e-OK];
 }
@@ -113,7 +113,7 @@ func (r *msgReceiver) recv() (*msg, os.Error) {
 	r.hdr.ndesc = int32(len(r.desc));
 	n, _, e := syscall.Syscall(syscall.SYS_IMC_RECVMSG, uintptr(r.fd), uintptr(unsafe.Pointer(&r.hdr)), 0);
 	if e != 0 {
-		return nil, os.NewSyscallError("imc_recvmsg", int(e));
+		return nil, os.NewSyscallError("imc_recvmsg", int(e))
 	}
 
 	// Make a copy of the data so that the next recvmsg doesn't
@@ -128,7 +128,7 @@ func (r *msgReceiver) recv() (*msg, os.Error) {
 	if r.hdr.ndesc > 0 {
 		m.rdesc = make([]int32, r.hdr.ndesc);
 		for i := range m.rdesc {
-			m.rdesc[i] = r.desc[i];
+			m.rdesc[i] = r.desc[i]
 		}
 	}
 
@@ -144,7 +144,7 @@ type msgSender struct {
 
 func (s *msgSender) send(m *msg) os.Error {
 	if len(m.wdata) > 0 {
-		s.iov.base = &m.wdata[0];
+		s.iov.base = &m.wdata[0]
 	}
 	s.iov.len = int32(len(m.wdata));
 	s.hdr.iov = &s.iov;
@@ -153,7 +153,7 @@ func (s *msgSender) send(m *msg) os.Error {
 	s.hdr.ndesc = 0;
 	_, _, e := syscall.Syscall(syscall.SYS_IMC_SENDMSG, uintptr(s.fd), uintptr(unsafe.Pointer(&s.hdr)), 0);
 	if e != 0 {
-		return os.NewSyscallError("imc_sendmsg", int(e));
+		return os.NewSyscallError("imc_sendmsg", int(e))
 	}
 	return nil;
 }
@@ -161,7 +161,7 @@ func (s *msgSender) send(m *msg) os.Error {
 // Reading from msg.rdata.
 func (m *msg) uint8() uint8 {
 	if m.status != OK {
-		return 0;
+		return 0
 	}
 	if len(m.rdata) < 1 {
 		m.status = ErrMessageTruncated;
@@ -174,7 +174,7 @@ func (m *msg) uint8() uint8 {
 
 func (m *msg) uint32() uint32 {
 	if m.status != OK {
-		return 0;
+		return 0
 	}
 	if len(m.rdata) < 4 {
 		m.status = ErrMessageTruncated;
@@ -188,7 +188,7 @@ func (m *msg) uint32() uint32 {
 
 func (m *msg) uint64() uint64 {
 	if m.status != OK {
-		return 0;
+		return 0
 	}
 	if len(m.rdata) < 8 {
 		m.status = ErrMessageTruncated;
@@ -203,7 +203,7 @@ func (m *msg) uint64() uint64 {
 
 func (m *msg) bytes(n int) []byte {
 	if m.status != OK {
-		return nil;
+		return nil
 	}
 	if len(m.rdata) < n {
 		m.status = ErrMessageTruncated;
@@ -255,7 +255,7 @@ func (m *msg) wbytes(p []byte)	{ bytes.Copy(m.grow(len(p)), p) }
 func (m *msg) wstring(s string) {
 	b := m.grow(len(s));
 	for i := range b {
-		b[i] = s[i];
+		b[i] = s[i]
 	}
 }
 
@@ -308,7 +308,7 @@ func (m *msg) unpackHeader() {
 		status := Errno(m.uint32());
 		m.gotHeader = m.status == OK;	// still ok?
 		if m.gotHeader {
-			m.status = status;
+			m.status = status
 		}
 	}
 }
@@ -317,13 +317,13 @@ func (m *msg) packHeader() {
 	m.wuint32(m.protocol);
 	m.wuint64(m.requestId);
 	if m.isReq {
-		m.wuint8(1);
+		m.wuint8(1)
 	} else {
-		m.wuint8(0);
+		m.wuint8(0)
 	}
 	m.wuint32(m.rpcNumber);
 	if !m.isReq {
-		m.wuint32(uint32(m.status));
+		m.wuint32(uint32(m.status))
 	}
 }
 
@@ -334,40 +334,40 @@ func (m *msg) unpackValues(v []interface{}) {
 		switch t {
 		default:
 			if m.status == OK {
-				m.status = ErrBadArgType;
+				m.status = ErrBadArgType
 			}
 			return;
 		case 'b':	// bool[1]
-			v[i] = m.uint8() > 0;
+			v[i] = m.uint8() > 0
 		case 'C':	// char array
-			v[i] = m.bytes(int(m.uint32()));
+			v[i] = m.bytes(int(m.uint32()))
 		case 'd':	// double
-			v[i] = math.Float64frombits(m.uint64());
+			v[i] = math.Float64frombits(m.uint64())
 		case 'D':	// double array
 			a := make([]float64, int(m.uint32()));
 			for j := range a {
-				a[j] = math.Float64frombits(m.uint64());
+				a[j] = math.Float64frombits(m.uint64())
 			}
 			v[i] = a;
 		case 'h':	// file descriptor (handle)
 			if len(m.rdesc) == 0 {
 				if m.status == OK {
-					m.status = ErrBadArgType;
+					m.status = ErrBadArgType
 				}
 				return;
 			}
 			v[i] = int(m.rdesc[0]);
 			m.rdesc = m.rdesc[1:len(m.rdesc)];
 		case 'i':	// int
-			v[i] = int32(m.uint32());
+			v[i] = int32(m.uint32())
 		case 'I':	// int array
 			a := make([]int32, int(m.uint32()));
 			for j := range a {
-				a[j] = int32(m.uint32());
+				a[j] = int32(m.uint32())
 			}
 			v[i] = a;
 		case 's':	// string
-			v[i] = string(m.bytes(int(m.uint32())));
+			v[i] = string(m.bytes(int(m.uint32())))
 		}
 	}
 }
@@ -377,15 +377,15 @@ func (m *msg) packValues(v []interface{}) {
 		switch x := v[i].(type) {
 		default:
 			if m.status == OK {
-				m.status = ErrInternalError;
+				m.status = ErrInternalError
 			}
 			return;
 		case bool:
 			m.wuint8('b');
 			if x {
-				m.wuint8(1);
+				m.wuint8(1)
 			} else {
-				m.wuint8(0);
+				m.wuint8(0)
 			}
 		case []byte:
 			m.wuint8('C');
@@ -398,7 +398,7 @@ func (m *msg) packValues(v []interface{}) {
 			m.wuint8('D');
 			m.wuint32(uint32(len(x)));
 			for _, f := range x {
-				m.wuint64(math.Float64bits(f));
+				m.wuint64(math.Float64bits(f))
 			}
 		case int32:
 			m.wuint8('i');
@@ -407,7 +407,7 @@ func (m *msg) packValues(v []interface{}) {
 			m.wuint8('I');
 			m.wuint32(uint32(len(x)));
 			for _, i := range x {
-				m.wuint32(uint32(i));
+				m.wuint32(uint32(i))
 			}
 		case string:
 			m.wuint8('s');
@@ -420,7 +420,7 @@ func (m *msg) packValues(v []interface{}) {
 func (m *msg) unpackRequest() {
 	m.status = OK;
 	if m.unpackHeader(); m.status != OK {
-		return;
+		return
 	}
 	if m.protocol != protocol || !m.isReq {
 		m.status = ErrProtocolMismatch;
@@ -431,7 +431,7 @@ func (m *msg) unpackRequest() {
 	m.Arg = make([]interface{}, m.uint32());
 	m.unpackValues(m.Arg);
 	if m.status != OK {
-		return;
+		return
 	}
 
 	// type-tagged expected return sizes.
@@ -446,23 +446,23 @@ func (m *msg) unpackRequest() {
 		switch t {
 		default:
 			if m.status == OK {
-				m.status = ErrBadArgType;
+				m.status = ErrBadArgType
 			}
 			return;
 		case 'b':	// bool[1]
-			m.Ret[i] = false;
+			m.Ret[i] = false
 		case 'C':	// char array
 			m.Size[i] = int(m.uint32());
 			m.Ret[i] = []byte(nil);
 		case 'd':	// double
-			m.Ret[i] = float64(0);
+			m.Ret[i] = float64(0)
 		case 'D':	// double array
 			m.Size[i] = int(m.uint32());
 			m.Ret[i] = []float64(nil);
 		case 'h':	// file descriptor (handle)
-			m.Ret[i] = int(-1);
+			m.Ret[i] = int(-1)
 		case 'i':	// int
-			m.Ret[i] = int32(0);
+			m.Ret[i] = int32(0)
 		case 'I':	// int array
 			m.Size[i] = int(m.uint32());
 			m.Ret[i] = []int32(nil);
@@ -481,19 +481,19 @@ func (m *msg) packRequest() {
 	for i, v := range m.Ret {
 		switch x := v.(type) {
 		case bool:
-			m.wuint8('b');
+			m.wuint8('b')
 		case []byte:
 			m.wuint8('C');
 			m.wuint32(uint32(m.Size[i]));
 		case float64:
-			m.wuint8('d');
+			m.wuint8('d')
 		case []float64:
 			m.wuint8('D');
 			m.wuint32(uint32(m.Size[i]));
 		case int:
-			m.wuint8('h');
+			m.wuint8('h')
 		case int32:
-			m.wuint8('i');
+			m.wuint8('i')
 		case []int32:
 			m.wuint8('I');
 			m.wuint32(uint32(m.Size[i]));
@@ -507,7 +507,7 @@ func (m *msg) packRequest() {
 func (m *msg) unpackResponse() {
 	m.status = OK;
 	if m.unpackHeader(); m.status != OK {
-		return;
+		return
 	}
 	if m.protocol != protocol || m.isReq {
 		m.status = ErrProtocolMismatch;
diff --git a/src/pkg/exp/nacl/srpc/server.go b/src/pkg/exp/nacl/srpc/server.go
index 87b51a6f49..56edfccd02 100644
--- a/src/pkg/exp/nacl/srpc/server.go
+++ b/src/pkg/exp/nacl/srpc/server.go
@@ -57,7 +57,7 @@ func Add(name, fmt string, handler Handler) {
 	if n >= cap(rpcMethod) {
 		a := make([]method, n, (n+4)*2);
 		for i := range a {
-			a[i] = rpcMethod[i];
+			a[i] = rpcMethod[i]
 		}
 		rpcMethod = a;
 	}
@@ -74,7 +74,7 @@ func Serve(fd int) os.Error {
 	for {
 		cfd, _, e := syscall.Syscall(syscall.SYS_IMC_ACCEPT, uintptr(fd), 0, 0);
 		if e != 0 {
-			return os.NewSyscallError("imc_accept", int(e));
+			return os.NewSyscallError("imc_accept", int(e))
 		}
 		go serveLoop(int(cfd));
 	}
@@ -90,7 +90,7 @@ func serveLoop(fd int) {
 	for {
 		m, err := r.recv();
 		if err != nil {
-			break;
+			break
 		}
 		m.unpackRequest();
 		if !m.gotHeader {
@@ -130,9 +130,9 @@ func serveMsg(m *msg, c chan<- *msg) {
 	if meth.fmt != m.fmt {
 		switch {
 		case len(m.fmt) < len(meth.fmt):
-			m.status = ErrTooFewArgs;
+			m.status = ErrTooFewArgs
 		case len(m.fmt) > len(meth.fmt):
-			m.status = ErrTooManyArgs;
+			m.status = ErrTooManyArgs
 		default:
 			// There's a type mismatch.
 			// It's an in-arg mismatch if the mismatch happens
@@ -158,7 +158,7 @@ func serveMsg(m *msg, c chan<- *msg) {
 func ServeRuntime() os.Error {
 	// Call getFd to check that we are running embedded.
 	if _, err := getFd(); err != nil {
-		return err;
+		return err
 	}
 
 	// We are running embedded.
@@ -192,7 +192,7 @@ func (serviceDiscovery) Run(arg, ret []interface{}, size []int) Errno {
 		b.WriteByte('\n');
 	}
 	if b.Len() > size[0] {
-		return ErrNoMemory;
+		return ErrNoMemory
 	}
 	ret[0] = b.Bytes();
 	return OK;
diff --git a/src/pkg/exp/ogle/arch.go b/src/pkg/exp/ogle/arch.go
index 20ce9f6660..5208a2a01c 100644
--- a/src/pkg/exp/ogle/arch.go
+++ b/src/pkg/exp/ogle/arch.go
@@ -56,7 +56,7 @@ type ArchLSB struct{}
 func (ArchLSB) ToWord(data []byte) proc.Word {
 	var v proc.Word;
 	for i, b := range data {
-		v |= proc.Word(b) << (uint(i)*8);
+		v |= proc.Word(b) << (uint(i)*8)
 	}
 	return v;
 }
@@ -71,7 +71,7 @@ func (ArchLSB) FromWord(v proc.Word, out []byte) {
 func (ArchLSB) ToFloat32(bits uint32) float32 {
 	// TODO(austin) Do these definitions depend on my current
 	// architecture?
-	return math.Float32frombits(bits);
+	return math.Float32frombits(bits)
 }
 
 func (ArchLSB) FromFloat32(f float32) uint32	{ return math.Float32bits(f) }
@@ -83,7 +83,7 @@ func (ArchLSB) FromFloat64(f float64) uint64	{ return math.Float64bits(f) }
 type ArchAlignedMultiple struct{}
 
 func (ArchAlignedMultiple) Align(offset, width int) int {
-	return ((offset-1)|(width-1))+1;
+	return ((offset-1)|(width-1))+1
 }
 
 type amd64 struct {
@@ -117,7 +117,7 @@ func (a *amd64) ClosureSize() int	{ return 8 }
 
 func (a *amd64) ParseClosure(data []byte) (int, bool) {
 	if data[0] == 0x48 && data[1] == 0x81 && data[2] == 0xc4 && data[7] == 0xc3 {
-		return int(a.ToWord(data[3:7]) + 8), true;
+		return int(a.ToWord(data[3:7]) + 8), true
 	}
 	return 0, false;
 }
diff --git a/src/pkg/exp/ogle/cmd.go b/src/pkg/exp/ogle/cmd.go
index 4df546a27a..fb01c92cc6 100644
--- a/src/pkg/exp/ogle/cmd.go
+++ b/src/pkg/exp/ogle/cmd.go
@@ -29,7 +29,7 @@ func Main() {
 		print("; ");
 		line, err := r.ReadSlice('\n');
 		if err != nil {
-			break;
+			break
 		}
 
 		// Try line as a command
@@ -37,7 +37,7 @@ func Main() {
 		if cmd != nil {
 			err := cmd.handler(rest);
 			if err != nil {
-				scanner.PrintError(os.Stderr, err);
+				scanner.PrintError(os.Stderr, err)
 			}
 			continue;
 		}
@@ -54,7 +54,7 @@ func Main() {
 			continue;
 		}
 		if v != nil {
-			println(v.String());
+			println(v.String())
 		}
 	}
 }
@@ -96,13 +96,13 @@ func getCmd(line []byte) (*cmd, []byte) {
 	sc, _ := newScanner(line);
 	pos, tok, lit := sc.Scan();
 	if sc.ErrorCount != 0 || tok != token.IDENT {
-		return nil, nil;
+		return nil, nil
 	}
 
 	slit := string(lit);
 	for i := range cmds {
 		if cmds[i].cmd == slit {
-			return &cmds[i], line[pos.Offset + len(lit) : len(line)];
+			return &cmds[i], line[pos.Offset + len(lit) : len(line)]
 		}
 	}
 	return nil, nil;
@@ -127,13 +127,13 @@ func getCmd(line []byte) (*cmd, []byte) {
 func cmdLoad(args []byte) os.Error {
 	ident, path, err := parseLoad(args);
 	if err != nil {
-		return err;
+		return err
 	}
 	if curProc != nil {
-		return UsageError("multiple processes not implemented");
+		return UsageError("multiple processes not implemented")
 	}
 	if ident != "." {
-		return UsageError("process identifiers not implemented");
+		return UsageError("process identifiers not implemented")
 	}
 
 	// Parse argument and start or attach to process
@@ -142,27 +142,27 @@ func cmdLoad(args []byte) os.Error {
 	if len(path) >= 4 && path[0:4] == "pid:" {
 		pid, err := strconv.Atoi(path[4:len(path)]);
 		if err != nil {
-			return err;
+			return err
 		}
 		fname, err = os.Readlink(fmt.Sprintf("/proc/%d/exe", pid));
 		if err != nil {
-			return err;
+			return err
 		}
 		tproc, err = proc.Attach(pid);
 		if err != nil {
-			return err;
+			return err
 		}
 		println("Attached to", pid);
 	} else {
 		parts := strings.Split(path, " ", 0);
 		if len(parts) == 0 {
-			fname = "";
+			fname = ""
 		} else {
-			fname = parts[0];
+			fname = parts[0]
 		}
 		tproc, err = proc.ForkExec(fname, parts, os.Environ(), "", []*os.File{os.Stdin, os.Stdout, os.Stderr});
 		if err != nil {
-			return err;
+			return err
 		}
 		println("Started", path);
 		// TODO(austin) If we fail after this point, kill tproc
@@ -207,7 +207,7 @@ func parseLoad(args []byte) (ident string, path string, err os.Error) {
 	var toks [4]token.Token;
 	var lits [4][]byte;
 	for i := range toks {
-		_, toks[i], lits[i] = sc.Scan();
+		_, toks[i], lits[i] = sc.Scan()
 	}
 	if sc.ErrorCount != 0 {
 		err = ev.GetError(scanner.NoMultiples);
@@ -222,7 +222,7 @@ func parseLoad(args []byte) (ident string, path string, err os.Error) {
 	}
 
 	if toks[i] != token.STRING {
-		return;
+		return
 	}
 	path, uerr := strconv.Unquote(string(lits[i]));
 	if uerr != nil {
@@ -232,10 +232,10 @@ func parseLoad(args []byte) (ident string, path string, err os.Error) {
 	i++;
 
 	if toks[i] == token.SEMICOLON {
-		i++;
+		i++
 	}
 	if toks[i] != token.EOF {
-		return;
+		return
 	}
 
 	return ident, path, nil;
@@ -246,11 +246,11 @@ func parseLoad(args []byte) (ident string, path string, err os.Error) {
 func cmdBt(args []byte) os.Error {
 	err := parseNoArgs(args, "Usage: bt");
 	if err != nil {
-		return err;
+		return err
 	}
 
 	if curProc == nil || curProc.curGoroutine == nil {
-		return NoCurrentGoroutine{};
+		return NoCurrentGoroutine{}
 	}
 
 	f := curProc.curGoroutine.frame;
@@ -260,22 +260,22 @@ func cmdBt(args []byte) os.Error {
 	}
 
 	for f.Inner() != nil {
-		f = f.Inner();
+		f = f.Inner()
 	}
 
 	for i := 0; i < 100; i++ {
 		if f == curProc.curGoroutine.frame {
-			fmt.Printf("=> ");
+			fmt.Printf("=> ")
 		} else {
-			fmt.Printf("   ");
+			fmt.Printf("   ")
 		}
 		fmt.Printf("%8x %v\n", f.pc, f);
 		f, err = f.Outer();
 		if err != nil {
-			return err;
+			return err
 		}
 		if f == nil {
-			return nil;
+			return nil
 		}
 	}
 
@@ -287,10 +287,10 @@ func parseNoArgs(args []byte, usage string) os.Error {
 	sc, ev := newScanner(args);
 	_, tok, _ := sc.Scan();
 	if sc.ErrorCount != 0 {
-		return ev.GetError(scanner.NoMultiples);
+		return ev.GetError(scanner.NoMultiples)
 	}
 	if tok != token.EOF {
-		return UsageError(usage);
+		return UsageError(usage)
 	}
 	return nil;
 }
@@ -313,11 +313,11 @@ func defineFuncs() {
 // a backtrace.
 func printCurFrame() {
 	if curProc == nil || curProc.curGoroutine == nil {
-		return;
+		return
 	}
 	f := curProc.curGoroutine.frame;
 	if f == nil {
-		return;
+		return
 	}
 	fmt.Printf("=> %8x %v\n", f.pc, f);
 }
@@ -326,11 +326,11 @@ func printCurFrame() {
 func fnOutSig()	{}
 func fnOut(t *eval.Thread, args []eval.Value, res []eval.Value) {
 	if curProc == nil {
-		t.Abort(NoCurrentGoroutine{});
+		t.Abort(NoCurrentGoroutine{})
 	}
 	err := curProc.Out();
 	if err != nil {
-		t.Abort(err);
+		t.Abort(err)
 	}
 	// TODO(austin) Only in the command form
 	printCurFrame();
@@ -340,16 +340,16 @@ func fnOut(t *eval.Thread, args []eval.Value, res []eval.Value) {
 func fnContWaitSig()	{}
 func fnContWait(t *eval.Thread, args []eval.Value, res []eval.Value) {
 	if curProc == nil {
-		t.Abort(NoCurrentGoroutine{});
+		t.Abort(NoCurrentGoroutine{})
 	}
 	err := curProc.ContWait();
 	if err != nil {
-		t.Abort(err);
+		t.Abort(err)
 	}
 	// TODO(austin) Only in the command form
 	ev := curProc.Event();
 	if ev != nil {
-		fmt.Printf("%v\n", ev);
+		fmt.Printf("%v\n", ev)
 	}
 	printCurFrame();
 }
@@ -362,12 +362,12 @@ func fnBpSet(t *eval.Thread, args []eval.Value, res []eval.Value) {
 	// Functions and instructions can implement that interface and
 	// we can have something to translate file:line pairs.
 	if curProc == nil {
-		t.Abort(NoCurrentGoroutine{});
+		t.Abort(NoCurrentGoroutine{})
 	}
 	name := args[0].(eval.StringValue).Get(t);
 	fn := curProc.syms.LookupFunc(name);
 	if fn == nil {
-		t.Abort(UsageError("no such function " + name));
+		t.Abort(UsageError("no such function " + name))
 	}
 	curProc.OnBreakpoint(proc.Word(fn.Entry)).AddHandler(EventStop);
 }
diff --git a/src/pkg/exp/ogle/event.go b/src/pkg/exp/ogle/event.go
index 898ab2762a..dc7ae918b3 100644
--- a/src/pkg/exp/ogle/event.go
+++ b/src/pkg/exp/ogle/event.go
@@ -76,7 +76,7 @@ type handler struct {
 }
 
 func (h *commonHook) AddHandler(eh EventHandler) {
-	h.addHandler(eh, false);
+	h.addHandler(eh, false)
 }
 
 func (h *commonHook) addHandler(eh EventHandler, internal bool) {
@@ -84,7 +84,7 @@ func (h *commonHook) addHandler(eh EventHandler, internal bool) {
 	h.RemoveHandler(eh);
 
 	if !internal {
-		h.len++;
+		h.len++
 	}
 	// Add internal handlers to the beginning
 	if internal || h.head == nil {
@@ -95,7 +95,7 @@ func (h *commonHook) addHandler(eh EventHandler, internal bool) {
 	// TODO(austin) This should probably go on the end instead
 	prev := h.head;
 	for prev.next != nil && prev.internal {
-		prev = prev.next;
+		prev = prev.next
 	}
 	prev.next = &handler{eh, internal, false, prev.next};
 }
@@ -105,7 +105,7 @@ func (h *commonHook) RemoveHandler(eh EventHandler) {
 	for l := *plink; l != nil; plink, l = &l.next, l.next {
 		if l.eh == eh {
 			if !l.internal {
-				h.len--;
+				h.len--
 			}
 			l.removed = true;
 			*plink = l.next;
@@ -121,22 +121,22 @@ func (h *commonHook) handle(e Event) (EventAction, os.Error) {
 	plink := &h.head;
 	for l := *plink; l != nil; plink, l = &l.next, l.next {
 		if l.removed {
-			continue;
+			continue
 		}
 		a, err := l.eh(e);
 		if a & EARemoveSelf == EARemoveSelf {
 			if !l.internal {
-				h.len--;
+				h.len--
 			}
 			l.removed = true;
 			*plink = l.next;
 			a &^= EARemoveSelf;
 		}
 		if err != nil {
-			return EAStop, err;
+			return EAStop, err
 		}
 		if a > action {
-			action = a;
+			action = a
 		}
 	}
 	return action, nil;
@@ -167,7 +167,7 @@ func EventPrint(ev Event) (EventAction, os.Error) {
 
 // EventStop is a standard event handler that causes the process to stop.
 func EventStop(ev Event) (EventAction, os.Error) {
-	return EAStop, nil;
+	return EAStop, nil
 }
 
 /*
@@ -190,7 +190,7 @@ type Breakpoint struct {
 }
 
 func (h *breakpointHook) AddHandler(eh EventHandler) {
-	h.addHandler(eh, false);
+	h.addHandler(eh, false)
 }
 
 func (h *breakpointHook) addHandler(eh EventHandler, internal bool) {
@@ -198,7 +198,7 @@ func (h *breakpointHook) addHandler(eh EventHandler, internal bool) {
 	// references to breakpoints without handlers.  Be sure to use
 	// the "canonical" breakpoint if there is one.
 	if cur, ok := h.p.breakpointHooks[h.pc]; ok {
-		h = cur;
+		h = cur
 	}
 	oldhead := h.head;
 	h.commonHook.addHandler(eh, internal);
@@ -220,7 +220,7 @@ func (h *breakpointHook) RemoveHandler(eh EventHandler) {
 func (h *breakpointHook) String() string {
 	// TODO(austin) Include process name?
 	// TODO(austin) Use line:pc or at least sym+%#x
-	return fmt.Sprintf("breakpoint at %#x", h.pc);
+	return fmt.Sprintf("breakpoint at %#x", h.pc)
 }
 
 func (b *Breakpoint) PC() proc.Word	{ return b.pc }
@@ -228,7 +228,7 @@ func (b *Breakpoint) PC() proc.Word	{ return b.pc }
 func (b *Breakpoint) String() string {
 	// TODO(austin) Include process name and goroutine
 	// TODO(austin) Use line:pc or at least sym+%#x
-	return fmt.Sprintf("breakpoint at %#x", b.pc);
+	return fmt.Sprintf("breakpoint at %#x", b.pc)
 }
 
 /*
@@ -256,7 +256,7 @@ func (e *GoroutineCreate) Parent() *Goroutine	{ return e.parent }
 func (e *GoroutineCreate) String() string {
 	// TODO(austin) Include process name
 	if e.parent == nil {
-		return fmt.Sprintf("%v created", e.t);
+		return fmt.Sprintf("%v created", e.t)
 	}
 	return fmt.Sprintf("%v created by %v", e.t, e.parent);
 }
@@ -276,5 +276,5 @@ func (e *GoroutineExit) String() string {
 	// TODO(austin) Include process name
 	//return fmt.Sprintf("%v exited", e.t);
 	// For debugging purposes
-	return fmt.Sprintf("goroutine %#x exited", e.t.g.addr().base);
+	return fmt.Sprintf("goroutine %#x exited", e.t.g.addr().base)
 }
diff --git a/src/pkg/exp/ogle/frame.go b/src/pkg/exp/ogle/frame.go
index a0ba71e74b..22fe0552e9 100644
--- a/src/pkg/exp/ogle/frame.go
+++ b/src/pkg/exp/ogle/frame.go
@@ -44,7 +44,7 @@ func aNewFrame(a aborter, g remoteStruct) *Frame {
 	// Is this G alive?
 	switch g.field(p.f.G.Status).(remoteInt).aGet(a) {
 	case p.runtime.Gidle, p.runtime.Gmoribund, p.runtime.Gdead:
-		return nil;
+		return nil
 	}
 
 	// Find the OS thread for this G
@@ -57,7 +57,7 @@ func aNewFrame(a aborter, g remoteStruct) *Frame {
 		regs, err := t.Regs();
 		if err != nil {
 			// TODO(austin) What to do?
-			continue;
+			continue
 		}
 		thisg := p.G(regs);
 		if thisg == g.addr().base {
@@ -117,19 +117,19 @@ func prepareFrame(a aborter, pc, sp proc.Word, stk remoteStruct, inner *Frame) *
 		// Get the PC of the call instruction
 		callpc := pc;
 		if !top && (p.sys.goexit == nil || pc != proc.Word(p.sys.goexit.Value)) {
-			callpc--;
+			callpc--
 		}
 
 		// Look up function
 		path, line, fn = p.syms.PCToLine(uint64(callpc));
 		if fn != nil {
-			break;
+			break
 		}
 
 		// Closure?
 		var buf = make([]byte, p.ClosureSize());
 		if _, err := p.Peek(pc, buf); err != nil {
-			break;
+			break
 		}
 		spdelta, ok := p.ParseClosure(buf);
 		if ok {
@@ -138,15 +138,15 @@ func prepareFrame(a aborter, pc, sp proc.Word, stk remoteStruct, inner *Frame) *
 		}
 	}
 	if fn == nil {
-		return nil;
+		return nil
 	}
 
 	// Compute frame pointer
 	var fp proc.Word;
 	if fn.FrameSize < p.PtrSize() {
-		fp = sp + proc.Word(p.PtrSize());
+		fp = sp + proc.Word(p.PtrSize())
 	} else {
-		fp = sp + proc.Word(fn.FrameSize);
+		fp = sp + proc.Word(fn.FrameSize)
 	}
 	// TODO(austin) To really figure out if we're in the prologue,
 	// we need to disassemble the function and look for the call
@@ -157,7 +157,7 @@ func prepareFrame(a aborter, pc, sp proc.Word, stk remoteStruct, inner *Frame) *
 	if top && pc == proc.Word(fn.Entry) {
 		// We're in the function prologue, before SP
 		// has been adjusted for the frame.
-		fp -= proc.Word(fn.FrameSize - p.PtrSize());
+		fp -= proc.Word(fn.FrameSize - p.PtrSize())
 	}
 
 	return &Frame{pc, sp, fp, stk, fn, path, line, inner, nil};
@@ -174,7 +174,7 @@ func (f *Frame) Outer() (*Frame, os.Error) {
 func (f *Frame) aOuter(a aborter) *Frame {
 	// Is there a cached outer frame
 	if f.outer != nil {
-		return f.outer;
+		return f.outer
 	}
 
 	p := f.stk.r.p;
@@ -185,12 +185,12 @@ func (f *Frame) aOuter(a aborter) *Frame {
 		// around calls to go and defer.  Russ says this
 		// should get fixed in the compiler, but we account
 		// for it for now.
-		sp += proc.Word(2 * p.PtrSize());
+		sp += proc.Word(2 * p.PtrSize())
 	}
 
 	pc := p.peekUintptr(a, f.fp - proc.Word(p.PtrSize()));
 	if pc < 0x1000 {
-		return nil;
+		return nil
 	}
 
 	// TODO(austin) Register this frame for shoot-down.
@@ -206,7 +206,7 @@ func (f *Frame) Inner() *Frame	{ return f.inner }
 func (f *Frame) String() string {
 	res := f.fn.Name;
 	if f.pc > proc.Word(f.fn.Value) {
-		res += fmt.Sprintf("+%#x", f.pc - proc.Word(f.fn.Entry));
+		res += fmt.Sprintf("+%#x", f.pc - proc.Word(f.fn.Entry))
 	}
 	return res + fmt.Sprintf(" %s:%d", f.path, f.line);
 }
diff --git a/src/pkg/exp/ogle/goroutine.go b/src/pkg/exp/ogle/goroutine.go
index 683b70d195..0c0075249a 100644
--- a/src/pkg/exp/ogle/goroutine.go
+++ b/src/pkg/exp/ogle/goroutine.go
@@ -20,7 +20,7 @@ type Goroutine struct {
 
 func (t *Goroutine) String() string {
 	if t.dead {
-		return "<dead thread>";
+		return "<dead thread>"
 	}
 	// TODO(austin) Give threads friendly ID's, possibly including
 	// the name of the entry function.
@@ -41,7 +41,7 @@ func (t *Goroutine) resetFrame() (err os.Error) {
 func (t *Goroutine) Out() os.Error {
 	f, err := t.frame.Outer();
 	if f != nil {
-		t.frame = f;
+		t.frame = f
 	}
 	return err;
 }
@@ -50,7 +50,7 @@ func (t *Goroutine) Out() os.Error {
 func (t *Goroutine) In() os.Error {
 	f := t.frame.Inner();
 	if f != nil {
-		t.frame = f;
+		t.frame = f
 	}
 	return nil;
 }
@@ -63,7 +63,7 @@ func readylockedBP(ev Event) (EventAction, os.Error) {
 	// stack will have the return address, then the G*.
 	regs, err := b.osThread.Regs();
 	if err != nil {
-		return EAStop, err;
+		return EAStop, err
 	}
 	sp := regs.SP();
 	addr := sp + proc.Word(p.PtrSize());
@@ -71,10 +71,10 @@ func readylockedBP(ev Event) (EventAction, os.Error) {
 	var gp eval.Value;
 	err = try(func(a aborter) { gp = arg.aGet(a) });
 	if err != nil {
-		return EAStop, err;
+		return EAStop, err
 	}
 	if gp == nil {
-		return EAStop, UnknownGoroutine{b.osThread, 0};
+		return EAStop, UnknownGoroutine{b.osThread, 0}
 	}
 	gs := gp.(remoteStruct);
 	g := &Goroutine{gs, nil, false};
@@ -83,13 +83,13 @@ func readylockedBP(ev Event) (EventAction, os.Error) {
 	// Enqueue goroutine creation event
 	parent := b.Goroutine();
 	if parent.isG0() {
-		parent = nil;
+		parent = nil
 	}
 	p.postEvent(&GoroutineCreate{commonEvent{p, g}, parent});
 
 	// If we don't have any thread selected, select this one
 	if p.curGoroutine == nil {
-		p.curGoroutine = g;
+		p.curGoroutine = g
 	}
 
 	return EADefault, nil;
@@ -110,7 +110,7 @@ func goexitBP(ev Event) (EventAction, os.Error) {
 
 	// If we just exited our selected goroutine, selected another
 	if p.curGoroutine == g {
-		p.selectSomeGoroutine();
+		p.selectSomeGoroutine()
 	}
 
 	return EADefault, nil;
diff --git a/src/pkg/exp/ogle/process.go b/src/pkg/exp/ogle/process.go
index 0b45477eaa..3a2954f618 100644
--- a/src/pkg/exp/ogle/process.go
+++ b/src/pkg/exp/ogle/process.go
@@ -27,7 +27,7 @@ func (e FormatError) String() string	{ return string(e) }
 type UnknownArchitecture elf.Machine
 
 func (e UnknownArchitecture) String() string {
-	return "unknown architecture: " + elf.Machine(e).String();
+	return "unknown architecture: " + elf.Machine(e).String()
 }
 
 // A ProcessNotStopped error occurs when attempting to read or write
@@ -44,7 +44,7 @@ type UnknownGoroutine struct {
 }
 
 func (e UnknownGoroutine) String() string {
-	return fmt.Sprintf("internal error: unknown goroutine (G %#x)", e.Goroutine);
+	return fmt.Sprintf("internal error: unknown goroutine (G %#x)", e.Goroutine)
 }
 
 // A NoCurrentGoroutine error occurs when no goroutine is currently
@@ -121,13 +121,13 @@ func NewProcess(tproc proc.Process, arch Arch, syms *gosym.Table) (*Process, os.
 
 	switch {
 	case p.sys.allg.addr().base == 0:
-		return nil, FormatError("failed to find runtime symbol 'allg'");
+		return nil, FormatError("failed to find runtime symbol 'allg'")
 	case p.sys.g0.addr().base == 0:
-		return nil, FormatError("failed to find runtime symbol 'g0'");
+		return nil, FormatError("failed to find runtime symbol 'g0'")
 	case p.sys.newprocreadylocked == nil:
-		return nil, FormatError("failed to find runtime symbol 'newprocreadylocked'");
+		return nil, FormatError("failed to find runtime symbol 'newprocreadylocked'")
 	case p.sys.goexit == nil:
-		return nil, FormatError("failed to find runtime symbol 'sys.goexit'");
+		return nil, FormatError("failed to find runtime symbol 'sys.goexit'")
 	}
 
 	// Get current goroutines
@@ -142,7 +142,7 @@ func NewProcess(tproc proc.Process, arch Arch, syms *gosym.Table) (*Process, os.
 		}
 	});
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	// Create internal breakpoints to catch new and exited goroutines
@@ -151,7 +151,7 @@ func NewProcess(tproc proc.Process, arch Arch, syms *gosym.Table) (*Process, os.
 
 	// Select current frames
 	for _, g := range p.goroutines {
-		g.resetFrame();
+		g.resetFrame()
 	}
 
 	p.selectSomeGoroutine();
@@ -164,22 +164,22 @@ func elfGoSyms(f *elf.File) (*gosym.Table, os.Error) {
 	symtab := f.Section(".gosymtab");
 	pclntab := f.Section(".gopclntab");
 	if text == nil || symtab == nil || pclntab == nil {
-		return nil, nil;
+		return nil, nil
 	}
 
 	symdat, err := symtab.Data();
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	pclndat, err := pclntab.Data();
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	pcln := gosym.NewLineTable(pclndat, text.Addr);
 	tab, err := gosym.NewTable(symdat, pcln);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	return tab, nil;
@@ -190,17 +190,17 @@ func elfGoSyms(f *elf.File) (*gosym.Table, os.Error) {
 func NewProcessElf(tproc proc.Process, f *elf.File) (*Process, os.Error) {
 	syms, err := elfGoSyms(f);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	if syms == nil {
-		return nil, FormatError("Failed to find symbol table");
+		return nil, FormatError("Failed to find symbol table")
 	}
 	var arch Arch;
 	switch f.Machine {
 	case elf.EM_X86_64:
-		arch = Amd64;
+		arch = Amd64
 	default:
-		return nil, UnknownArchitecture(f.Machine);
+		return nil, UnknownArchitecture(f.Machine)
 	}
 	return NewProcess(tproc, arch, syms);
 }
@@ -231,11 +231,11 @@ func (p *Process) bootstrap() {
 	for i := 0; i < rtv.NumField(); i++ {
 		n := rtvt.Field(i).Name;
 		if n[0] != 'P' || n[1] < 'A' || n[1] > 'Z' {
-			continue;
+			continue
 		}
 		sym := p.syms.LookupSym("type.*runtime." + n[1:len(n)]);
 		if sym == nil {
-			continue;
+			continue
 		}
 		rtv.Field(i).(*reflect.Uint64Value).Set(sym.Value);
 	}
@@ -253,10 +253,10 @@ func (p *Process) bootstrap() {
 	p.sys.deferproc = p.syms.LookupFunc("sys.deferproc");
 	p.sys.newprocreadylocked = p.syms.LookupFunc("newprocreadylocked");
 	if allg := p.syms.LookupSym("allg"); allg != nil {
-		p.sys.allg = remotePtr{remote{proc.Word(allg.Value), p}, p.runtime.G};
+		p.sys.allg = remotePtr{remote{proc.Word(allg.Value), p}, p.runtime.G}
 	}
 	if g0 := p.syms.LookupSym("g0"); g0 != nil {
-		p.sys.g0 = p.runtime.G.mk(remote{proc.Word(g0.Value), p}).(remoteStruct);
+		p.sys.g0 = p.runtime.G.mk(remote{proc.Word(g0.Value), p}).(remoteStruct)
 	}
 }
 
@@ -279,7 +279,7 @@ func (p *Process) selectSomeGoroutine() {
 func (p *Process) someStoppedOSThread() proc.Thread {
 	if p.threadCache != nil {
 		if _, err := p.threadCache.Stopped(); err == nil {
-			return p.threadCache;
+			return p.threadCache
 		}
 	}
 
@@ -295,7 +295,7 @@ func (p *Process) someStoppedOSThread() proc.Thread {
 func (p *Process) Peek(addr proc.Word, out []byte) (int, os.Error) {
 	thr := p.someStoppedOSThread();
 	if thr == nil {
-		return 0, ProcessNotStopped{};
+		return 0, ProcessNotStopped{}
 	}
 	return thr.Peek(addr, out);
 }
@@ -303,13 +303,13 @@ func (p *Process) Peek(addr proc.Word, out []byte) (int, os.Error) {
 func (p *Process) Poke(addr proc.Word, b []byte) (int, os.Error) {
 	thr := p.someStoppedOSThread();
 	if thr == nil {
-		return 0, ProcessNotStopped{};
+		return 0, ProcessNotStopped{}
 	}
 	return thr.Poke(addr, b);
 }
 
 func (p *Process) peekUintptr(a aborter, addr proc.Word) proc.Word {
-	return proc.Word(mkUintptr(remote{addr, p}).(remoteUint).aGet(a));
+	return proc.Word(mkUintptr(remote{addr, p}).(remoteUint).aGet(a))
 }
 
 /*
@@ -320,7 +320,7 @@ func (p *Process) peekUintptr(a aborter, addr proc.Word) proc.Word {
 // the given program counter.
 func (p *Process) OnBreakpoint(pc proc.Word) EventHook {
 	if bp, ok := p.breakpointHooks[pc]; ok {
-		return bp;
+		return bp
 	}
 	// The breakpoint will register itself when a handler is added
 	return &breakpointHook{commonHook{nil, 0}, p, pc};
@@ -328,7 +328,7 @@ func (p *Process) OnBreakpoint(pc proc.Word) EventHook {
 
 // OnGoroutineCreate returns the hook that is run when a goroutine is created.
 func (p *Process) OnGoroutineCreate() EventHook {
-	return p.goroutineCreateHook;
+	return p.goroutineCreateHook
 }
 
 // OnGoroutineExit returns the hook that is run when a goroutine exits.
@@ -338,12 +338,12 @@ func (p *Process) OnGoroutineExit() EventHook	{ return p.goroutineExitHook }
 func (p *Process) osThreadToGoroutine(t proc.Thread) (*Goroutine, os.Error) {
 	regs, err := t.Regs();
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	g := p.G(regs);
 	gt, ok := p.goroutines[g];
 	if !ok {
-		return nil, UnknownGoroutine{t, g};
+		return nil, UnknownGoroutine{t, g}
 	}
 	return gt, nil;
 }
@@ -357,7 +357,7 @@ func (p *Process) causesToEvents() ([]Event, os.Error) {
 		if c, err := t.Stopped(); err == nil {
 			switch c := c.(type) {
 			case proc.Breakpoint:
-				nev++;
+				nev++
 			case proc.Signal:
 				// TODO(austin)
 				//nev++;
@@ -374,7 +374,7 @@ func (p *Process) causesToEvents() ([]Event, os.Error) {
 			case proc.Breakpoint:
 				gt, err := p.osThreadToGoroutine(t);
 				if err != nil {
-					return nil, err;
+					return nil, err
 				}
 				events[i] = &Breakpoint{commonEvent{p, gt}, t, proc.Word(c)};
 				i++;
@@ -393,11 +393,11 @@ func (p *Process) postEvent(ev Event) {
 	n := len(p.posted);
 	m := n*2;
 	if m == 0 {
-		m = 4;
+		m = 4
 	}
 	posted := make([]Event, n+1, m);
 	for i, p := range p.posted {
-		posted[i] = p;
+		posted[i] = p
 	}
 	posted[n] = ev;
 	p.posted = posted;
@@ -412,7 +412,7 @@ func (p *Process) processEvents() (EventAction, os.Error) {
 		ev, p.posted = p.posted[0], p.posted[1:len(p.posted)];
 		action, err := p.processEvent(ev);
 		if action == EAStop {
-			return action, err;
+			return action, err
 		}
 	}
 
@@ -420,7 +420,7 @@ func (p *Process) processEvents() (EventAction, os.Error) {
 		ev, p.pending = p.pending[0], p.pending[1:len(p.pending)];
 		action, err := p.processEvent(ev);
 		if action == EAStop {
-			return action, err;
+			return action, err
 		}
 	}
 
@@ -439,7 +439,7 @@ func (p *Process) processEvent(ev Event) (EventAction, os.Error) {
 	case *Breakpoint:
 		hook, ok := p.breakpointHooks[ev.pc];
 		if !ok {
-			break;
+			break
 		}
 		p.curGoroutine = ev.Goroutine();
 		action, err = hook.handle(ev);
@@ -449,16 +449,16 @@ func (p *Process) processEvent(ev Event) (EventAction, os.Error) {
 		action, err = p.goroutineCreateHook.handle(ev);
 
 	case *GoroutineExit:
-		action, err = p.goroutineExitHook.handle(ev);
+		action, err = p.goroutineExitHook.handle(ev)
 
 	default:
-		log.Crashf("Unknown event type %T in queue", p.event);
+		log.Crashf("Unknown event type %T in queue", p.event)
 	}
 
 	if err != nil {
-		return EAStop, err;
+		return EAStop, err
 	} else if action == EAStop {
-		return EAStop, nil;
+		return EAStop, nil
 	}
 	return EAContinue, nil;
 }
@@ -491,24 +491,24 @@ func (p *Process) ContWait() os.Error {
 	for {
 		a, err := p.processEvents();
 		if err != nil {
-			return err;
+			return err
 		} else if a == EAStop {
-			break;
+			break
 		}
 		err = p.proc.Continue();
 		if err != nil {
-			return err;
+			return err
 		}
 		err = p.proc.WaitStop();
 		if err != nil {
-			return err;
+			return err
 		}
 		for _, g := range p.goroutines {
-			g.resetFrame();
+			g.resetFrame()
 		}
 		p.pending, err = p.causesToEvents();
 		if err != nil {
-			return err;
+			return err
 		}
 	}
 	return nil;
@@ -517,7 +517,7 @@ func (p *Process) ContWait() os.Error {
 // Out selects the caller frame of the current frame.
 func (p *Process) Out() os.Error {
 	if p.curGoroutine == nil {
-		return NoCurrentGoroutine{};
+		return NoCurrentGoroutine{}
 	}
 	return p.curGoroutine.Out();
 }
@@ -525,7 +525,7 @@ func (p *Process) Out() os.Error {
 // In selects the frame called by the current frame.
 func (p *Process) In() os.Error {
 	if p.curGoroutine == nil {
-		return NoCurrentGoroutine{};
+		return NoCurrentGoroutine{}
 	}
 	return p.curGoroutine.In();
 }
diff --git a/src/pkg/exp/ogle/rruntime.go b/src/pkg/exp/ogle/rruntime.go
index 7ce258a79c..c9e695b247 100644
--- a/src/pkg/exp/ogle/rruntime.go
+++ b/src/pkg/exp/ogle/rruntime.go
@@ -250,11 +250,11 @@ func fillRuntimeIndexes(runtime *runtimeValues, out *runtimeIndexes) {
 		indexes := make(map[string]int, len(et.Elems));
 		for j, f := range et.Elems {
 			if f.Anonymous {
-				continue;
+				continue
 			}
 			name := f.Name;
 			if name[0] >= 'a' && name[0] <= 'z' {
-				name = string(name[0]+'A'-'a')+name[1:len(name)];
+				name = string(name[0]+'A'-'a')+name[1:len(name)]
 			}
 			indexes[name] = j;
 		}
diff --git a/src/pkg/exp/ogle/rtype.go b/src/pkg/exp/ogle/rtype.go
index 0b05b1120e..74eb9ab15e 100644
--- a/src/pkg/exp/ogle/rtype.go
+++ b/src/pkg/exp/ogle/rtype.go
@@ -34,7 +34,7 @@ var manualTypes = make(map[Arch]map[eval.Type]*remoteType)
 // so we need to layout the structures that describe those types ourselves.
 func newManualType(t eval.Type, arch Arch) *remoteType {
 	if nt, ok := t.(*eval.NamedType); ok {
-		t = nt.Def;
+		t = nt.Def
 	}
 
 	// Get the type map for this architecture
@@ -47,7 +47,7 @@ func newManualType(t eval.Type, arch Arch) *remoteType {
 		basicType := func(t eval.Type, mk maker, size int, fieldAlign int) {
 			t = t.(*eval.NamedType).Def;
 			if fieldAlign == 0 {
-				fieldAlign = size;
+				fieldAlign = size
 			}
 			typeMap[t] = &remoteType{t, size, fieldAlign, mk};
 		};
@@ -61,7 +61,7 @@ func newManualType(t eval.Type, arch Arch) *remoteType {
 	}
 
 	if rt, ok := typeMap[t]; ok {
-		return rt;
+		return rt
 	}
 
 	var rt *remoteType;
@@ -92,7 +92,7 @@ func newManualType(t eval.Type, arch Arch) *remoteType {
 		for i, f := range t.Elems {
 			elem := newManualType(f.Type, arch);
 			if fieldAlign == 0 {
-				fieldAlign = elem.fieldAlign;
+				fieldAlign = elem.fieldAlign
 			}
 			offset = arch.Align(offset, elem.fieldAlign);
 			layout[i].offset = offset;
@@ -103,7 +103,7 @@ func newManualType(t eval.Type, arch Arch) *remoteType {
 		rt = &remoteType{t, offset, fieldAlign, mk};
 
 	default:
-		log.Crashf("cannot manually construct type %T", t);
+		log.Crashf("cannot manually construct type %T", t)
 	}
 
 	typeMap[t] = rt;
@@ -130,7 +130,7 @@ func parseRemoteType(a aborter, rs remoteStruct) *remoteType {
 
 	rt, ok := p.types[addr];
 	if ok && rt.Type != nil {
-		return rt;
+		return rt
 	} else if !ok {
 		rt = &remoteType{};
 		p.types[addr] = rt;
@@ -140,7 +140,7 @@ func parseRemoteType(a aborter, rs remoteStruct) *remoteType {
 		sym := p.syms.SymByAddr(uint64(addr));
 		name := "<unknown>";
 		if sym != nil {
-			name = sym.Name;
+			name = sym.Name
 		}
 		log.Stderrf("%sParsing type at %#x (%s)", prtIndent, addr, name);
 		prtIndent += " ";
@@ -238,9 +238,9 @@ func parseRemoteType(a aborter, rs remoteStruct) *remoteType {
 			fields[i].Type = elem.Type;
 			name := f.field(p.f.StructField.Name).(remotePtr).aGet(a);
 			if name == nil {
-				fields[i].Anonymous = true;
+				fields[i].Anonymous = true
 			} else {
-				fields[i].Name = name.(remoteString).aGet(a);
+				fields[i].Name = name.(remoteString).aGet(a)
 			}
 			layout[i].offset = int(f.field(p.f.StructField.Offset).(remoteUint).aGet(a));
 			layout[i].fieldType = elem;
@@ -272,7 +272,7 @@ func parseRemoteType(a aborter, rs remoteStruct) *remoteType {
 		sym := p.syms.SymByAddr(uint64(itype));
 		name := "<unknown symbol>";
 		if sym != nil {
-			name = sym.Name;
+			name = sym.Name
 		}
 		err := fmt.Sprintf("runtime type at %#x has unexpected type %#x (%s)", addr, itype, name);
 		a.Abort(FormatError(err));
@@ -280,9 +280,9 @@ func parseRemoteType(a aborter, rs remoteStruct) *remoteType {
 
 	// Fill in the remote type
 	if nt != nil {
-		nt.Complete(t);
+		nt.Complete(t)
 	} else {
-		rt.Type = t;
+		rt.Type = t
 	}
 	rt.size = int(typ.field(p.f.CommonType.Size).(remoteUint).aGet(a));
 	rt.mk = mk;
diff --git a/src/pkg/exp/ogle/rvalue.go b/src/pkg/exp/ogle/rvalue.go
index a01512ace6..ebd6a6f22f 100644
--- a/src/pkg/exp/ogle/rvalue.go
+++ b/src/pkg/exp/ogle/rvalue.go
@@ -59,7 +59,7 @@ func (v remote) Get(a aborter, size int) uint64 {
 	buf := arr[0:size];
 	_, err := v.p.Peek(v.base, buf);
 	if err != nil {
-		a.Abort(err);
+		a.Abort(err)
 	}
 	return uint64(v.p.ToWord(buf));
 }
@@ -70,7 +70,7 @@ func (v remote) Set(a aborter, size int, x uint64) {
 	v.p.FromWord(proc.Word(x), buf);
 	_, err := v.p.Poke(v.base, buf);
 	if err != nil {
-		a.Abort(err);
+		a.Abort(err)
 	}
 }
 
@@ -80,7 +80,7 @@ func tryRVString(f func(a aborter) string) string {
 	var s string;
 	err := try(func(a aborter) { s = f(a) });
 	if err != nil {
-		return fmt.Sprintf("<error: %v>", err);
+		return fmt.Sprintf("<error: %v>", err)
 	}
 	return s;
 }
@@ -94,11 +94,11 @@ type remoteBool struct {
 }
 
 func (v remoteBool) String() string {
-	return tryRVString(func(a aborter) string { return fmt.Sprintf("%v", v.aGet(a)) });
+	return tryRVString(func(a aborter) string { return fmt.Sprintf("%v", v.aGet(a)) })
 }
 
 func (v remoteBool) Assign(t *eval.Thread, o eval.Value) {
-	v.Set(t, o.(eval.BoolValue).Get(t));
+	v.Set(t, o.(eval.BoolValue).Get(t))
 }
 
 func (v remoteBool) Get(t *eval.Thread) bool	{ return v.aGet(t) }
@@ -106,14 +106,14 @@ func (v remoteBool) Get(t *eval.Thread) bool	{ return v.aGet(t) }
 func (v remoteBool) aGet(a aborter) bool	{ return v.r.Get(a, 1) != 0 }
 
 func (v remoteBool) Set(t *eval.Thread, x bool) {
-	v.aSet(t, x);
+	v.aSet(t, x)
 }
 
 func (v remoteBool) aSet(a aborter, x bool) {
 	if x {
-		v.r.Set(a, 1, 1);
+		v.r.Set(a, 1, 1)
 	} else {
-		v.r.Set(a, 1, 0);
+		v.r.Set(a, 1, 0)
 	}
 }
 
@@ -131,21 +131,21 @@ type remoteUint struct {
 }
 
 func (v remoteUint) String() string {
-	return tryRVString(func(a aborter) string { return fmt.Sprintf("%v", v.aGet(a)) });
+	return tryRVString(func(a aborter) string { return fmt.Sprintf("%v", v.aGet(a)) })
 }
 
 func (v remoteUint) Assign(t *eval.Thread, o eval.Value) {
-	v.Set(t, o.(eval.UintValue).Get(t));
+	v.Set(t, o.(eval.UintValue).Get(t))
 }
 
 func (v remoteUint) Get(t *eval.Thread) uint64 {
-	return v.aGet(t);
+	return v.aGet(t)
 }
 
 func (v remoteUint) aGet(a aborter) uint64	{ return v.r.Get(a, v.size) }
 
 func (v remoteUint) Set(t *eval.Thread, x uint64) {
-	v.aSet(t, x);
+	v.aSet(t, x)
 }
 
 func (v remoteUint) aSet(a aborter, x uint64)	{ v.r.Set(a, v.size, x) }
@@ -174,11 +174,11 @@ type remoteInt struct {
 }
 
 func (v remoteInt) String() string {
-	return tryRVString(func(a aborter) string { return fmt.Sprintf("%v", v.aGet(a)) });
+	return tryRVString(func(a aborter) string { return fmt.Sprintf("%v", v.aGet(a)) })
 }
 
 func (v remoteInt) Assign(t *eval.Thread, o eval.Value) {
-	v.Set(t, o.(eval.IntValue).Get(t));
+	v.Set(t, o.(eval.IntValue).Get(t))
 }
 
 func (v remoteInt) Get(t *eval.Thread) int64	{ return v.aGet(t) }
@@ -186,7 +186,7 @@ func (v remoteInt) Get(t *eval.Thread) int64	{ return v.aGet(t) }
 func (v remoteInt) aGet(a aborter) int64	{ return int64(v.r.Get(a, v.size)) }
 
 func (v remoteInt) Set(t *eval.Thread, x int64) {
-	v.aSet(t, x);
+	v.aSet(t, x)
 }
 
 func (v remoteInt) aSet(a aborter, x int64)	{ v.r.Set(a, v.size, uint64(x)) }
@@ -213,41 +213,41 @@ type remoteFloat struct {
 }
 
 func (v remoteFloat) String() string {
-	return tryRVString(func(a aborter) string { return fmt.Sprintf("%v", v.aGet(a)) });
+	return tryRVString(func(a aborter) string { return fmt.Sprintf("%v", v.aGet(a)) })
 }
 
 func (v remoteFloat) Assign(t *eval.Thread, o eval.Value) {
-	v.Set(t, o.(eval.FloatValue).Get(t));
+	v.Set(t, o.(eval.FloatValue).Get(t))
 }
 
 func (v remoteFloat) Get(t *eval.Thread) float64 {
-	return v.aGet(t);
+	return v.aGet(t)
 }
 
 func (v remoteFloat) aGet(a aborter) float64 {
 	bits := v.r.Get(a, v.size);
 	switch v.size {
 	case 4:
-		return float64(v.r.p.ToFloat32(uint32(bits)));
+		return float64(v.r.p.ToFloat32(uint32(bits)))
 	case 8:
-		return v.r.p.ToFloat64(bits);
+		return v.r.p.ToFloat64(bits)
 	}
 	panic("Unexpected float size ", v.size);
 }
 
 func (v remoteFloat) Set(t *eval.Thread, x float64) {
-	v.aSet(t, x);
+	v.aSet(t, x)
 }
 
 func (v remoteFloat) aSet(a aborter, x float64) {
 	var bits uint64;
 	switch v.size {
 	case 4:
-		bits = uint64(v.r.p.FromFloat32(float32(x)));
+		bits = uint64(v.r.p.FromFloat32(float32(x)))
 	case 8:
-		bits = v.r.p.FromFloat64(x);
+		bits = v.r.p.FromFloat64(x)
 	default:
-		panic("Unexpected float size ", v.size);
+		panic("Unexpected float size ", v.size)
 	}
 	v.r.Set(a, v.size, bits);
 }
@@ -269,15 +269,15 @@ type remoteString struct {
 }
 
 func (v remoteString) String() string {
-	return tryRVString(func(a aborter) string { return v.aGet(a) });
+	return tryRVString(func(a aborter) string { return v.aGet(a) })
 }
 
 func (v remoteString) Assign(t *eval.Thread, o eval.Value) {
-	v.Set(t, o.(eval.StringValue).Get(t));
+	v.Set(t, o.(eval.StringValue).Get(t))
 }
 
 func (v remoteString) Get(t *eval.Thread) string {
-	return v.aGet(t);
+	return v.aGet(t)
 }
 
 func (v remoteString) aGet(a aborter) string {
@@ -288,19 +288,19 @@ func (v remoteString) aGet(a aborter) string {
 	bytes := make([]uint8, len);
 	_, err := v.r.p.Peek(str, bytes);
 	if err != nil {
-		a.Abort(err);
+		a.Abort(err)
 	}
 	return string(bytes);
 }
 
 func (v remoteString) Set(t *eval.Thread, x string) {
-	v.aSet(t, x);
+	v.aSet(t, x)
 }
 
 func (v remoteString) aSet(a aborter, x string) {
 	// TODO(austin) This isn't generally possible without the
 	// ability to allocate remote memory.
-	a.Abort(ReadOnlyError("remote strings cannot be assigned to"));
+	a.Abort(ReadOnlyError("remote strings cannot be assigned to"))
 }
 
 func mkString(r remote) eval.Value	{ return remoteString{r} }
@@ -319,7 +319,7 @@ func (v remoteArray) String() string {
 	res := "{";
 	for i := int64(0); i < v.len; i++ {
 		if i > 0 {
-			res += ", ";
+			res += ", "
 		}
 		res += v.elem(i).String();
 	}
@@ -331,24 +331,24 @@ func (v remoteArray) Assign(t *eval.Thread, o eval.Value) {
 	// remoteArray in the same Process.
 	oa := o.(eval.ArrayValue);
 	for i := int64(0); i < v.len; i++ {
-		v.Elem(t, i).Assign(t, oa.Elem(t, i));
+		v.Elem(t, i).Assign(t, oa.Elem(t, i))
 	}
 }
 
 func (v remoteArray) Get(t *eval.Thread) eval.ArrayValue {
-	return v;
+	return v
 }
 
 func (v remoteArray) Elem(t *eval.Thread, i int64) eval.Value {
-	return v.elem(i);
+	return v.elem(i)
 }
 
 func (v remoteArray) elem(i int64) eval.Value {
-	return v.elemType.mk(v.r.plus(proc.Word(int64(v.elemType.size)*i)));
+	return v.elemType.mk(v.r.plus(proc.Word(int64(v.elemType.size)*i)))
 }
 
 func (v remoteArray) Sub(i int64, len int64) eval.ArrayValue {
-	return remoteArray{v.r.plus(proc.Word(int64(v.elemType.size)*i)), len, v.elemType};
+	return remoteArray{v.r.plus(proc.Word(int64(v.elemType.size)*i)), len, v.elemType}
 }
 
 /*
@@ -369,7 +369,7 @@ func (v remoteStruct) String() string {
 	res := "{";
 	for i := range v.layout {
 		if i > 0 {
-			res += ", ";
+			res += ", "
 		}
 		res += v.field(i).String();
 	}
@@ -381,16 +381,16 @@ func (v remoteStruct) Assign(t *eval.Thread, o eval.Value) {
 	oa := o.(eval.StructValue);
 	l := len(v.layout);
 	for i := 0; i < l; i++ {
-		v.Field(t, i).Assign(t, oa.Field(t, i));
+		v.Field(t, i).Assign(t, oa.Field(t, i))
 	}
 }
 
 func (v remoteStruct) Get(t *eval.Thread) eval.StructValue {
-	return v;
+	return v
 }
 
 func (v remoteStruct) Field(t *eval.Thread, i int) eval.Value {
-	return v.field(i);
+	return v.field(i)
 }
 
 func (v remoteStruct) field(i int) eval.Value {
@@ -417,30 +417,30 @@ func (v remotePtr) String() string {
 	return tryRVString(func(a aborter) string {
 		e := v.aGet(a);
 		if e == nil {
-			return "<nil>";
+			return "<nil>"
 		}
 		return "&" + e.String();
-	});
+	})
 }
 
 func (v remotePtr) Assign(t *eval.Thread, o eval.Value) {
-	v.Set(t, o.(eval.PtrValue).Get(t));
+	v.Set(t, o.(eval.PtrValue).Get(t))
 }
 
 func (v remotePtr) Get(t *eval.Thread) eval.Value {
-	return v.aGet(t);
+	return v.aGet(t)
 }
 
 func (v remotePtr) aGet(a aborter) eval.Value {
 	addr := proc.Word(v.r.Get(a, v.r.p.PtrSize()));
 	if addr == 0 {
-		return nil;
+		return nil
 	}
 	return v.elemType.mk(remote{addr, v.r.p});
 }
 
 func (v remotePtr) Set(t *eval.Thread, x eval.Value) {
-	v.aSet(t, x);
+	v.aSet(t, x)
 }
 
 func (v remotePtr) aSet(a aborter, x eval.Value) {
@@ -450,7 +450,7 @@ func (v remotePtr) aSet(a aborter, x eval.Value) {
 	}
 	xr, ok := x.(remoteValue);
 	if !ok || v.r.p != xr.addr().p {
-		a.Abort(RemoteMismatchError("remote pointer must point within the same process"));
+		a.Abort(RemoteMismatchError("remote pointer must point within the same process"))
 	}
 	v.r.Set(a, v.r.p.PtrSize(), uint64(xr.addr().base));
 }
@@ -470,18 +470,18 @@ func (v remoteSlice) String() string {
 	return tryRVString(func(a aborter) string {
 		b := v.aGet(a).Base;
 		if b == nil {
-			return "<nil>";
+			return "<nil>"
 		}
 		return b.String();
-	});
+	})
 }
 
 func (v remoteSlice) Assign(t *eval.Thread, o eval.Value) {
-	v.Set(t, o.(eval.SliceValue).Get(t));
+	v.Set(t, o.(eval.SliceValue).Get(t))
 }
 
 func (v remoteSlice) Get(t *eval.Thread) eval.Slice {
-	return v.aGet(t);
+	return v.aGet(t)
 }
 
 func (v remoteSlice) aGet(a aborter) eval.Slice {
@@ -490,23 +490,23 @@ func (v remoteSlice) aGet(a aborter) eval.Slice {
 	nel := rs.field(v.r.p.f.Slice.Len).(remoteInt).aGet(a);
 	cap := rs.field(v.r.p.f.Slice.Cap).(remoteInt).aGet(a);
 	if base == 0 {
-		return eval.Slice{nil, nel, cap};
+		return eval.Slice{nil, nel, cap}
 	}
 	return eval.Slice{remoteArray{remote{base, v.r.p}, nel, v.elemType}, nel, cap};
 }
 
 func (v remoteSlice) Set(t *eval.Thread, x eval.Slice) {
-	v.aSet(t, x);
+	v.aSet(t, x)
 }
 
 func (v remoteSlice) aSet(a aborter, x eval.Slice) {
 	rs := v.r.p.runtime.Slice.mk(v.r).(remoteStruct);
 	if x.Base == nil {
-		rs.field(v.r.p.f.Slice.Array).(remoteUint).aSet(a, 0);
+		rs.field(v.r.p.f.Slice.Array).(remoteUint).aSet(a, 0)
 	} else {
 		ar, ok := x.Base.(remoteArray);
 		if !ok || v.r.p != ar.r.p {
-			a.Abort(RemoteMismatchError("remote slice must point within the same process"));
+			a.Abort(RemoteMismatchError("remote slice must point within the same process"))
 		}
 		rs.field(v.r.p.f.Slice.Array).(remoteUint).aSet(a, uint64(ar.r.base));
 	}
diff --git a/src/pkg/exp/ogle/vars.go b/src/pkg/exp/ogle/vars.go
index 74d540ce90..b881c0ade4 100644
--- a/src/pkg/exp/ogle/vars.go
+++ b/src/pkg/exp/ogle/vars.go
@@ -24,7 +24,7 @@ type NotOnStack struct {
 }
 
 func (e NotOnStack) String() string {
-	return "function " + e.Fn.Name + " not on " + e.Goroutine.String() + "'s stack";
+	return "function " + e.Fn.Name + " not on " + e.Goroutine.String() + "'s stack"
 }
 
 // A remoteFramePtr is an implementation of eval.PtrValue that
@@ -40,22 +40,22 @@ type remoteFramePtr struct {
 
 func (v remoteFramePtr) String() string {
 	// TODO(austin): This could be a really awesome string method
-	return "<remote frame>";
+	return "<remote frame>"
 }
 
 func (v remoteFramePtr) Assign(t *eval.Thread, o eval.Value) {
-	v.Set(t, o.(eval.PtrValue).Get(t));
+	v.Set(t, o.(eval.PtrValue).Get(t))
 }
 
 func (v remoteFramePtr) Get(t *eval.Thread) eval.Value {
 	g := v.p.curGoroutine;
 	if g == nil || g.frame == nil {
-		t.Abort(NoCurrentGoroutine{});
+		t.Abort(NoCurrentGoroutine{})
 	}
 
 	for f := g.frame; f != nil; f = f.aOuter(t) {
 		if f.fn != v.fn {
-			continue;
+			continue
 		}
 
 		// TODO(austin): Register for shootdown with f
@@ -70,7 +70,7 @@ func (v remoteFramePtr) Set(t *eval.Thread, x eval.Value) {
 	// Theoretically this could be a static error.  If remote
 	// packages were packages, remote frames could just be defined
 	// as constants.
-	t.Abort(ReadOnlyError("remote frames cannot be assigned to"));
+	t.Abort(ReadOnlyError("remote frames cannot be assigned to"))
 }
 
 /*
@@ -93,15 +93,15 @@ type remotePackage struct {
 func (v remotePackage) String() string	{ return "<remote package>" }
 
 func (v remotePackage) Assign(t *eval.Thread, o eval.Value) {
-	t.Abort(ReadOnlyError("remote packages cannot be assigned to"));
+	t.Abort(ReadOnlyError("remote packages cannot be assigned to"))
 }
 
 func (v remotePackage) Get(t *eval.Thread) eval.StructValue {
-	return v;
+	return v
 }
 
 func (v remotePackage) Field(t *eval.Thread, i int) eval.Value {
-	return v.defs[i];
+	return v.defs[i]
 }
 
 /*
@@ -121,7 +121,7 @@ func (p *Process) populateWorld(w *eval.World) os.Error {
 	for _, s := range p.syms.Syms {
 		if s.ReceiverName() != "" {
 			// TODO(austin)
-			continue;
+			continue
 		}
 
 		// Package
@@ -129,7 +129,7 @@ func (p *Process) populateWorld(w *eval.World) os.Error {
 		switch pkgName {
 		case "", "type", "extratype", "string", "go":
 			// "go" is really "go.string"
-			continue;
+			continue
 		}
 		pkg, ok := packages[pkgName];
 		if !ok {
@@ -147,7 +147,7 @@ func (p *Process) populateWorld(w *eval.World) os.Error {
 		// Symbol type
 		rt, err := p.typeOfSym(&s);
 		if err != nil {
-			return err;
+			return err
 		}
 
 		// Definition
@@ -155,7 +155,7 @@ func (p *Process) populateWorld(w *eval.World) os.Error {
 		case 'D', 'd', 'B', 'b':
 			// Global variable
 			if rt == nil {
-				continue;
+				continue
 			}
 			pkg[name] = def{rt.Type, rt.mk(remote{proc.Word(s.Value), p})};
 
@@ -167,7 +167,7 @@ func (p *Process) populateWorld(w *eval.World) os.Error {
 			// conversion syntax?
 			rt, err := p.makeFrameType(s);
 			if err != nil {
-				return err;
+				return err
 			}
 			pkg[name] = def{eval.NewPtrType(rt.Type), remoteFramePtr{p, s, rt}};
 		}
@@ -191,7 +191,7 @@ func (p *Process) populateWorld(w *eval.World) os.Error {
 
 		err := w.DefineConst(pkgName, pkgType, pkgVal);
 		if err != nil {
-			log.Stderrf("while defining package %s: %v", pkgName, err);
+			log.Stderrf("while defining package %s: %v", pkgName, err)
 		}
 	}
 
@@ -202,13 +202,13 @@ func (p *Process) populateWorld(w *eval.World) os.Error {
 // has no type, returns nil.
 func (p *Process) typeOfSym(s *gosym.Sym) (*remoteType, os.Error) {
 	if s.GoType == 0 {
-		return nil, nil;
+		return nil, nil
 	}
 	addr := proc.Word(s.GoType);
 	var rt *remoteType;
 	err := try(func(a aborter) { rt = parseRemoteType(a, p.runtime.Type.mk(remote{addr, p}).(remoteStruct)) });
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	return rt, nil;
 }
@@ -232,11 +232,11 @@ func (p *Process) makeFrameType(s *gosym.Func) (*remoteType, os.Error) {
 	for _, param := range s.Params {
 		rt, err := p.typeOfSym(param);
 		if err != nil {
-			return nil, err;
+			return nil, err
 		}
 		if rt == nil {
 			//fmt.Printf(" (no type)\n");
-			continue;
+			continue
 		}
 		// TODO(austin): Why do local variables carry their
 		// package name?
@@ -251,10 +251,10 @@ func (p *Process) makeFrameType(s *gosym.Func) (*remoteType, os.Error) {
 	for _, local := range s.Locals {
 		rt, err := p.typeOfSym(local);
 		if err != nil {
-			return nil, err;
+			return nil, err
 		}
 		if rt == nil {
-			continue;
+			continue
 		}
 		fields[i].Name = local.BaseName();
 		fields[i].Type = rt.Type;
diff --git a/src/pkg/exp/spacewar/pdp1.go b/src/pkg/exp/spacewar/pdp1.go
index 02c3717e9c..3d9dfeb125 100644
--- a/src/pkg/exp/spacewar/pdp1.go
+++ b/src/pkg/exp/spacewar/pdp1.go
@@ -136,7 +136,7 @@ func norm(i Word) Word {
 	i += i>>18;
 	i &= mask;
 	if i == mask {
-		i = 0;
+		i = 0
 	}
 	return i;
 }
@@ -147,13 +147,13 @@ type UnknownInstrError struct {
 }
 
 func (e UnknownInstrError) String() string {
-	return fmt.Sprintf("unknown instruction %06o at %06o", e.Inst, e.PC);
+	return fmt.Sprintf("unknown instruction %06o at %06o", e.Inst, e.PC)
 }
 
 type HaltError Word
 
 func (e HaltError) String() string {
-	return fmt.Sprintf("executed HLT instruction at %06o", e);
+	return fmt.Sprintf("executed HLT instruction at %06o", e)
 }
 
 type LoopError Word
@@ -166,7 +166,7 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 	if op < opSKP && op != opCALJDA {
 		for n := 0; ib != 0; n++ {
 			if n > 07777 {
-				return LoopError(m.PC - 1);
+				return LoopError(m.PC - 1)
 			}
 			ib = (m.Mem[y] >> 12)&1;
 			y = m.Mem[y] & 07777;
@@ -175,33 +175,33 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 
 	switch op {
 	case opAND:
-		m.AC &= m.Mem[y];
+		m.AC &= m.Mem[y]
 	case opIOR:
-		m.AC |= m.Mem[y];
+		m.AC |= m.Mem[y]
 	case opXOR:
-		m.AC ^= m.Mem[y];
+		m.AC ^= m.Mem[y]
 	case opXCT:
-		m.run(m.Mem[y], t);
+		m.run(m.Mem[y], t)
 	case opCALJDA:
 		a := y;
 		if ib == 0 {
-			a = 64;
+			a = 64
 		}
 		m.Mem[a] = m.AC;
 		m.AC = (m.OV << 17) + m.PC;
 		m.PC = a+1;
 	case opLAC:
-		m.AC = m.Mem[y];
+		m.AC = m.Mem[y]
 	case opLIO:
-		m.IO = m.Mem[y];
+		m.IO = m.Mem[y]
 	case opDAC:
-		m.Mem[y] = m.AC;
+		m.Mem[y] = m.AC
 	case opDAP:
-		m.Mem[y] = m.Mem[y] & 0770000 | m.AC & 07777;
+		m.Mem[y] = m.Mem[y] & 0770000 | m.AC & 07777
 	case opDIO:
-		m.Mem[y] = m.IO;
+		m.Mem[y] = m.IO
 	case opDZM:
-		m.Mem[y] = 0;
+		m.Mem[y] = 0
 	case opADD:
 		m.AC += m.Mem[y];
 		m.OV = m.AC >> 18;
@@ -211,7 +211,7 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 		m.AC += m.Mem[y] ^ mask;
 		m.AC = norm(m.AC);
 		if diffSigns && m.Mem[y] >> 17 == m.AC >> 17 {
-			m.OV = 1;
+			m.OV = 1
 		}
 	case opIDX:
 		m.AC = norm(m.Mem[y] + 1);
@@ -220,15 +220,15 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 		m.AC = norm(m.Mem[y] + 1);
 		m.Mem[y] = m.AC;
 		if m.AC & sign == 0 {
-			m.PC++;
+			m.PC++
 		}
 	case opSAD:
 		if m.AC != m.Mem[y] {
-			m.PC++;
+			m.PC++
 		}
 	case opSAS:
 		if m.AC == m.Mem[y] {
-			m.PC++;
+			m.PC++
 		}
 	case opMUS:
 		if m.IO & 1 == 1 {
@@ -241,13 +241,13 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 		m.AC, m.IO = (m.AC << 1 | m.IO >> 17)&mask,
 			((m.IO << 1 | m.AC >> 17)&mask)^1;
 		if m.IO & 1 == 1 {
-			m.AC = m.AC + (m.Mem[y] ^ mask);
+			m.AC = m.AC + (m.Mem[y] ^ mask)
 		} else {
-			m.AC = m.AC + 1 + m.Mem[y];
+			m.AC = m.AC + 1 + m.Mem[y]
 		}
 		m.AC = norm(m.AC);
 	case opJMP:
-		m.PC = y;
+		m.PC = y
 	case opJSP:
 		m.AC = (m.OV << 17) + m.PC;
 		m.PC = y;
@@ -261,74 +261,74 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 			y&070 != 0 && !m.Sense[(y&070)>>3] ||
 			y&070 == 010;
 		if (ib == 0) == cond {
-			m.PC++;
+			m.PC++
 		}
 		if y&01000 == 01000 {
-			m.OV = 0;
+			m.OV = 0
 		}
 	case opSFT:
 		for count := inst&0777; count != 0; count >>= 1 {
 			if count&1 == 0 {
-				continue;
+				continue
 			}
 			switch (inst>>9)&017 {
 			case 001:	// rotate AC left
-				m.AC = (m.AC << 1 | m.AC >> 17)&mask;
+				m.AC = (m.AC << 1 | m.AC >> 17)&mask
 			case 002:	// rotate IO left
-				m.IO = (m.IO << 1 | m.IO >> 17)&mask;
+				m.IO = (m.IO << 1 | m.IO >> 17)&mask
 			case 003:	// rotate AC and IO left.
 				w := uint64(m.AC)<<18 | uint64(m.IO);
 				w = w<<1 | w>>35;
 				m.AC = Word(w>>18)&mask;
 				m.IO = Word(w)&mask;
 			case 005:	// shift AC left (excluding sign bit)
-				m.AC = (m.AC << 1 | m.AC >> 17)&mask&^sign | m.AC & sign;
+				m.AC = (m.AC << 1 | m.AC >> 17)&mask&^sign | m.AC & sign
 			case 006:	// shift IO left (excluding sign bit)
-				m.IO = (m.IO << 1 | m.IO >> 17)&mask&^sign | m.IO & sign;
+				m.IO = (m.IO << 1 | m.IO >> 17)&mask&^sign | m.IO & sign
 			case 007:	// shift AC and IO left (excluding AC's sign bit)
 				w := uint64(m.AC)<<18 | uint64(m.IO);
 				w = w<<1 | w>>35;
 				m.AC = Word(w>>18)&mask&^sign | m.AC & sign;
 				m.IO = Word(w)&mask&^sign | m.AC & sign;
 			case 011:	// rotate AC right
-				m.AC = (m.AC >> 1 | m.AC << 17)&mask;
+				m.AC = (m.AC >> 1 | m.AC << 17)&mask
 			case 012:	// rotate IO right
-				m.IO = (m.IO >> 1 | m.IO << 17)&mask;
+				m.IO = (m.IO >> 1 | m.IO << 17)&mask
 			case 013:	// rotate AC and IO right
 				w := uint64(m.AC)<<18 | uint64(m.IO);
 				w = w>>1 | w<<35;
 				m.AC = Word(w>>18)&mask;
 				m.IO = Word(w)&mask;
 			case 015:	// shift AC right (excluding sign bit)
-				m.AC = m.AC >> 1 | m.AC & sign;
+				m.AC = m.AC >> 1 | m.AC & sign
 			case 016:	// shift IO right (excluding sign bit)
-				m.IO = m.IO >> 1 | m.IO & sign;
+				m.IO = m.IO >> 1 | m.IO & sign
 			case 017:	// shift AC and IO right (excluding AC's sign bit)
 				w := uint64(m.AC)<<18 | uint64(m.IO);
 				w = w>>1;
 				m.AC = Word(w>>18) | m.AC & sign;
 				m.IO = Word(w)&mask;
 			default:
-				goto Unknown;
+				goto Unknown
 			}
 		}
 	case opLAW:
 		if ib == 0 {
-			m.AC = y;
+			m.AC = y
 		} else {
-			m.AC = y^mask;
+			m.AC = y^mask
 		}
 	case opIOT:
-		t.Trap(y);
+		t.Trap(y)
 	case opOPR:
 		if y&0200 == 0200 {
-			m.AC = 0;
+			m.AC = 0
 		}
 		if y&04000 == 04000 {
-			m.IO = 0;
+			m.IO = 0
 		}
 		if y&01000 == 01000 {
-			m.AC ^= mask;
+			m.AC ^= mask
 		}
 		if y&0400 == 0400 {
 			m.PC--;
@@ -337,14 +337,14 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 		switch i, f := y&7, y&010 == 010; {
 		case i == 7:
 			for i := 2; i < 7; i++ {
-				m.Flag[i] = f;
+				m.Flag[i] = f
 			}
 		case i >= 2:
-			m.Flag[i] = f;
+			m.Flag[i] = f
 		}
 	default:
 	Unknown:
-		return UnknownInstrError{inst, m.PC - 1};
+		return UnknownInstrError{inst, m.PC - 1}
 	}
 	return nil;
 }
@@ -358,29 +358,29 @@ func (m *M) Load(r io.Reader) os.Error {
 		line, err := b.ReadString('\n');
 		if err != nil {
 			if err != os.EOF {
-				return err;
+				return err
 			}
 			break;
 		}
 		// look for ^[ +]([0-9]+)\t([0-9]+)
 		if line[0] != ' ' && line[0] != '+' {
-			continue;
+			continue
 		}
 		i := 1;
 		a := Word(0);
 		for ; i < len(line) && '0' <= line[i] && line[i] <= '7'; i++ {
-			a = a*8 + Word(line[i]-'0');
+			a = a*8 + Word(line[i]-'0')
 		}
 		if i >= len(line) || line[i] != '\t' || i == 1 {
-			continue;
+			continue
 		}
 		v := Word(0);
 		j := i;
 		for i++; i < len(line) && '0' <= line[i] && line[i] <= '7'; i++ {
-			v = v*8 + Word(line[i]-'0');
+			v = v*8 + Word(line[i]-'0')
 		}
 		if i == j {
-			continue;
+			continue
 		}
 		m.Mem[a] = v;
 	}
diff --git a/src/pkg/exp/spacewar/spacewar.go b/src/pkg/exp/spacewar/spacewar.go
index 3927a986c9..a09cd8c726 100644
--- a/src/pkg/exp/spacewar/spacewar.go
+++ b/src/pkg/exp/spacewar/spacewar.go
@@ -38,12 +38,12 @@ import (
 func main() {
 	runtime.LockOSThread();
 	if srpc.Enabled() {
-		go srpc.ServeRuntime();
+		go srpc.ServeRuntime()
 	}
 
 	w, err := av.Init(av.SubsystemVideo, 512, 512);
 	if err != nil {
-		log.Exitf("av.Init: %s", err);
+		log.Exitf("av.Init: %s", err)
 	}
 
 	go quitter(w.QuitChan());
@@ -53,13 +53,13 @@ func main() {
 	m.PC = 4;
 	f := bytes.NewBuffer(strings.Bytes(spacewarCode));
 	if err = m.Load(f); err != nil {
-		log.Exitf("loading %s: %s", "spacewar.lst", err);
+		log.Exitf("loading %s: %s", "spacewar.lst", err)
 	}
 	for err == nil {
 		//fmt.Printf("step PC=%06o ", m.PC);
 		//fmt.Printf("inst=%06o AC=%06o IO=%06o OV=%o\n",
 		//	m.Mem[m.PC], m.AC, m.IO, m.OV);
-		err = m.Step();
+		err = m.Step()
 	}
 	log.Exitf("step: %s", err);
 }
@@ -89,7 +89,7 @@ type SpacewarPDP1 struct {
 
 func min(a, b int) int {
 	if a < b {
-		return a;
+		return a
 	}
 	return b;
 }
@@ -103,7 +103,7 @@ func (m *SpacewarPDP1) Init(ctxt draw.Context) {
 	m.colorModel = m.screen.ColorModel();
 	m.pix = make([][]uint8, m.dy);
 	for i := range m.pix {
-		m.pix[i] = make([]uint8, m.dx);
+		m.pix[i] = make([]uint8, m.dx)
 	}
 	m.cmap = make([]image.Color, 256);
 	for i := range m.cmap {
@@ -138,7 +138,7 @@ func (m *SpacewarPDP1) Step() os.Error {
 			m.flush();
 			t := time.Nanoseconds();
 			if t >= m.frameTime + 3 * frameDelay {
-				m.frameTime = t;
+				m.frameTime = t
 			} else {
 				m.frameTime += frameDelay;
 				for t < m.frameTime {
@@ -163,7 +163,7 @@ func (m *SpacewarPDP1) Trap(y pdp1.Word) {
 			m.pix[y][x] = n;
 		}
 	case 011:
-		m.IO = m.ctl;
+		m.IO = m.ctl
 	}
 }
 
@@ -183,13 +183,13 @@ func (m *SpacewarPDP1) pollInput() {
 		select {
 		case ch := <-m.kc:
 			if 0 <= ch && ch < len(ctlBits) {
-				m.ctl |= ctlBits[ch];
+				m.ctl |= ctlBits[ch]
 			}
 			if 0 <= -ch && -ch < len(ctlBits) {
-				m.ctl &^= ctlBits[-ch];
+				m.ctl &^= ctlBits[-ch]
 			}
 		default:
-			return;
+			return
 		}
 	}
 }
diff --git a/src/pkg/expvar/expvar.go b/src/pkg/expvar/expvar.go
index 0c85df8443..3a2e74b267 100644
--- a/src/pkg/expvar/expvar.go
+++ b/src/pkg/expvar/expvar.go
@@ -55,7 +55,7 @@ func (v *Map) String() string {
 	first := true;
 	for key, val := range v.m {
 		if !first {
-			fmt.Fprintf(b, ", ");
+			fmt.Fprintf(b, ", ")
 		}
 		fmt.Fprintf(b, "\"%s\": %v", key, val.String());
 		first = false;
@@ -73,7 +73,7 @@ func (v *Map) Get(key string) Var {
 	v.mu.Lock();
 	defer v.mu.Unlock();
 	if av, ok := v.m[key]; ok {
-		return av;
+		return av
 	}
 	return nil;
 }
@@ -95,14 +95,14 @@ func (v *Map) Add(key string, delta int64) {
 
 	// Add to Int; ignore otherwise.
 	if iv, ok := av.(*Int); ok {
-		iv.Add(delta);
+		iv.Add(delta)
 	}
 }
 
 // TODO(rsc): Make sure map access in separate thread is safe.
 func (v *Map) iterate(c chan<- KeyValue) {
 	for k, v := range v.m {
-		c <- KeyValue{k, v};
+		c <- KeyValue{k, v}
 	}
 	close(c);
 }
@@ -140,7 +140,7 @@ func Publish(name string, v Var) {
 	mutex.Lock();
 	defer mutex.Unlock();
 	if _, existing := vars[name]; existing {
-		log.Crash("Reuse of exported var name:", name);
+		log.Crash("Reuse of exported var name:", name)
 	}
 	vars[name] = v;
 }
@@ -148,7 +148,7 @@ func Publish(name string, v Var) {
 // Get retrieves a named exported variable.
 func Get(name string) Var {
 	if v, ok := vars[name]; ok {
-		return v;
+		return v
 	}
 	return nil;
 }
@@ -184,7 +184,7 @@ func NewString(name string) *String {
 // TODO(rsc): Make sure map access in separate thread is safe.
 func iterate(c chan<- KeyValue) {
 	for k, v := range vars {
-		c <- KeyValue{k, v};
+		c <- KeyValue{k, v}
 	}
 	close(c);
 }
@@ -201,7 +201,7 @@ func expvarHandler(c *http.Conn, req *http.Request) {
 	first := true;
 	for name, value := range vars {
 		if !first {
-			fmt.Fprintf(c, ",\n");
+			fmt.Fprintf(c, ",\n")
 		}
 		first = false;
 		fmt.Fprintf(c, "  %q: %s", name, value);
diff --git a/src/pkg/expvar/expvar_test.go b/src/pkg/expvar/expvar_test.go
index 51c78d5a07..cbbb2cbefe 100644
--- a/src/pkg/expvar/expvar_test.go
+++ b/src/pkg/expvar/expvar_test.go
@@ -12,36 +12,36 @@ import (
 func TestInt(t *testing.T) {
 	reqs := NewInt("requests");
 	if reqs.i != 0 {
-		t.Errorf("reqs.i = %v, want 4", reqs.i);
+		t.Errorf("reqs.i = %v, want 4", reqs.i)
 	}
 	if reqs != Get("requests").(*Int) {
-		t.Errorf("Get() failed.");
+		t.Errorf("Get() failed.")
 	}
 
 	reqs.Add(1);
 	reqs.Add(3);
 	if reqs.i != 4 {
-		t.Errorf("reqs.i = %v, want 4", reqs.i);
+		t.Errorf("reqs.i = %v, want 4", reqs.i)
 	}
 
 	if s := reqs.String(); s != "4" {
-		t.Errorf("reqs.String() = %q, want \"4\"", s);
+		t.Errorf("reqs.String() = %q, want \"4\"", s)
 	}
 }
 
 func TestString(t *testing.T) {
 	name := NewString("my-name");
 	if name.s != "" {
-		t.Errorf("name.s = %q, want \"\"", name.s);
+		t.Errorf("name.s = %q, want \"\"", name.s)
 	}
 
 	name.Set("Mike");
 	if name.s != "Mike" {
-		t.Errorf("name.s = %q, want \"Mike\"", name.s);
+		t.Errorf("name.s = %q, want \"Mike\"", name.s)
 	}
 
 	if s := name.String(); s != "\"Mike\"" {
-		t.Errorf("reqs.String() = %q, want \"\"Mike\"\"", s);
+		t.Errorf("reqs.String() = %q, want \"\"Mike\"\"", s)
 	}
 }
 
@@ -52,10 +52,10 @@ func TestMapCounter(t *testing.T) {
 	colours.Add("red", 2);
 	colours.Add("blue", 4);
 	if x := colours.m["red"].(*Int).i; x != 3 {
-		t.Errorf("colours.m[\"red\"] = %v, want 3", x);
+		t.Errorf("colours.m[\"red\"] = %v, want 3", x)
 	}
 	if x := colours.m["blue"].(*Int).i; x != 4 {
-		t.Errorf("colours.m[\"blue\"] = %v, want 4", x);
+		t.Errorf("colours.m[\"blue\"] = %v, want 4", x)
 	}
 
 	// colours.String() should be '{"red":3, "blue":4}',
@@ -63,17 +63,17 @@ func TestMapCounter(t *testing.T) {
 	s := colours.String();
 	j, ok, errtok := json.StringToJson(s);
 	if !ok {
-		t.Errorf("colours.String() isn't valid JSON: %v", errtok);
+		t.Errorf("colours.String() isn't valid JSON: %v", errtok)
 	}
 	if j.Kind() != json.MapKind {
-		t.Error("colours.String() didn't produce a map.");
+		t.Error("colours.String() didn't produce a map.")
 	}
 	red := j.Get("red");
 	if red.Kind() != json.NumberKind {
-		t.Error("red.Kind() is not a NumberKind.");
+		t.Error("red.Kind() is not a NumberKind.")
 	}
 	if x := red.Number(); x != 3 {
-		t.Error("red = %v, want 3", x);
+		t.Error("red = %v, want 3", x)
 	}
 }
 
@@ -81,11 +81,11 @@ func TestIntFunc(t *testing.T) {
 	x := int(4);
 	ix := IntFunc(func() int64 { return int64(x) });
 	if s := ix.String(); s != "4" {
-		t.Errorf("ix.String() = %v, want 4", s);
+		t.Errorf("ix.String() = %v, want 4", s)
 	}
 
 	x++;
 	if s := ix.String(); s != "5" {
-		t.Errorf("ix.String() = %v, want 5", s);
+		t.Errorf("ix.String() = %v, want 5", s)
 	}
 }
diff --git a/src/pkg/flag/flag.go b/src/pkg/flag/flag.go
index 011b48b692..a88b2d1785 100644
--- a/src/pkg/flag/flag.go
+++ b/src/pkg/flag/flag.go
@@ -52,9 +52,9 @@ import (
 func atob(str string) (value bool, ok bool) {
 	switch str {
 	case "1", "t", "T", "true", "TRUE", "True":
-		return true, true;
+		return true, true
 	case "0", "f", "F", "false", "FALSE", "False":
-		return false, true;
+		return false, true
 	}
 	return false, false;
 }
@@ -228,14 +228,14 @@ var flags *allFlags = &allFlags{make(map[string]*Flag), make(map[string]*Flag),
 // VisitAll visits the flags, calling fn for each. It visits all flags, even those not set.
 func VisitAll(fn func(*Flag)) {
 	for _, f := range flags.formal {
-		fn(f);
+		fn(f)
 	}
 }
 
 // Visit visits the flags, calling fn for each. It visits only those flags that have been set.
 func Visit(fn func(*Flag)) {
 	for _, f := range flags.actual {
-		fn(f);
+		fn(f)
 	}
 }
 
@@ -243,7 +243,7 @@ func Visit(fn func(*Flag)) {
 func Lookup(name string) *Flag {
 	f, ok := flags.formal[name];
 	if !ok {
-		return nil;
+		return nil
 	}
 	return f;
 }
@@ -253,11 +253,11 @@ func Lookup(name string) *Flag {
 func Set(name, value string) bool {
 	f, ok := flags.formal[name];
 	if !ok {
-		return false;
+		return false
 	}
 	ok = f.Value.set(value);
 	if !ok {
-		return false;
+		return false
 	}
 	flags.actual[name] = f;
 	return true;
@@ -269,10 +269,10 @@ func PrintDefaults() {
 		format := "  -%s=%s: %s\n";
 		if _, ok := f.Value.(*stringValue); ok {
 			// put quotes on the value
-			format = "  -%s=%q: %s\n";
+			format = "  -%s=%q: %s\n"
 		}
 		fmt.Fprintf(os.Stderr, format, f.Name, f.DefValue, f.Usage);
-	});
+	})
 }
 
 // Usage prints to standard error a default usage message documenting all defined flags.
@@ -289,7 +289,7 @@ func NFlag() int	{ return len(flags.actual) }
 func Arg(i int) string {
 	i += flags.first_arg;
 	if i < 0 || i >= len(os.Args) {
-		return "";
+		return ""
 	}
 	return os.Args[i];
 }
@@ -314,7 +314,7 @@ func add(name string, value FlagValue, usage string) {
 // BoolVar defines a bool flag with specified name, default value, and usage string.
 // The argument p points to a bool variable in which to store the value of the flag.
 func BoolVar(p *bool, name string, value bool, usage string) {
-	add(name, newBoolValue(value, p), usage);
+	add(name, newBoolValue(value, p), usage)
 }
 
 // Bool defines a bool flag with specified name, default value, and usage string.
@@ -328,7 +328,7 @@ func Bool(name string, value bool, usage string) *bool {
 // IntVar defines an int flag with specified name, default value, and usage string.
 // The argument p points to an int variable in which to store the value of the flag.
 func IntVar(p *int, name string, value int, usage string) {
-	add(name, newIntValue(value, p), usage);
+	add(name, newIntValue(value, p), usage)
 }
 
 // Int defines an int flag with specified name, default value, and usage string.
@@ -342,7 +342,7 @@ func Int(name string, value int, usage string) *int {
 // Int64Var defines an int64 flag with specified name, default value, and usage string.
 // The argument p points to an int64 variable in which to store the value of the flag.
 func Int64Var(p *int64, name string, value int64, usage string) {
-	add(name, newInt64Value(value, p), usage);
+	add(name, newInt64Value(value, p), usage)
 }
 
 // Int64 defines an int64 flag with specified name, default value, and usage string.
@@ -356,7 +356,7 @@ func Int64(name string, value int64, usage string) *int64 {
 // UintVar defines a uint flag with specified name, default value, and usage string.
 // The argument p points to a uint variable in which to store the value of the flag.
 func UintVar(p *uint, name string, value uint, usage string) {
-	add(name, newUintValue(value, p), usage);
+	add(name, newUintValue(value, p), usage)
 }
 
 // Uint defines a uint flag with specified name, default value, and usage string.
@@ -370,7 +370,7 @@ func Uint(name string, value uint, usage string) *uint {
 // Uint64Var defines a uint64 flag with specified name, default value, and usage string.
 // The argument p points to a uint64 variable in which to store the value of the flag.
 func Uint64Var(p *uint64, name string, value uint64, usage string) {
-	add(name, newUint64Value(value, p), usage);
+	add(name, newUint64Value(value, p), usage)
 }
 
 // Uint64 defines a uint64 flag with specified name, default value, and usage string.
@@ -384,7 +384,7 @@ func Uint64(name string, value uint64, usage string) *uint64 {
 // StringVar defines a string flag with specified name, default value, and usage string.
 // The argument p points to a string variable in which to store the value of the flag.
 func StringVar(p *string, name, value string, usage string) {
-	add(name, newStringValue(value, p), usage);
+	add(name, newStringValue(value, p), usage)
 }
 
 // String defines a string flag with specified name, default value, and usage string.
@@ -398,7 +398,7 @@ func String(name, value string, usage string) *string {
 // FloatVar defines a float flag with specified name, default value, and usage string.
 // The argument p points to a float variable in which to store the value of the flag.
 func FloatVar(p *float, name string, value float, usage string) {
-	add(name, newFloatValue(value, p), usage);
+	add(name, newFloatValue(value, p), usage)
 }
 
 // Float defines a float flag with specified name, default value, and usage string.
@@ -412,7 +412,7 @@ func Float(name string, value float, usage string) *float {
 // Float64Var defines a float64 flag with specified name, default value, and usage string.
 // The argument p points to a float64 variable in which to store the value of the flag.
 func Float64Var(p *float64, name string, value float64, usage string) {
-	add(name, newFloat64Value(value, p), usage);
+	add(name, newFloat64Value(value, p), usage)
 }
 
 // Float64 defines a float64 flag with specified name, default value, and usage string.
@@ -428,19 +428,19 @@ func (f *allFlags) parseOne(index int) (ok bool, next int) {
 	s := os.Args[index];
 	f.first_arg = index;	// until proven otherwise
 	if len(s) == 0 {
-		return false, -1;
+		return false, -1
 	}
 	if s[0] != '-' {
-		return false, -1;
+		return false, -1
 	}
 	num_minuses := 1;
 	if len(s) == 1 {
-		return false, index;
+		return false, index
 	}
 	if s[1] == '-' {
 		num_minuses++;
 		if len(s) == 2 {	// "--" terminates the flags
-			return false, index+1;
+			return false, index+1
 		}
 	}
 	name := s[num_minuses : len(s)];
@@ -482,7 +482,7 @@ func (f *allFlags) parseOne(index int) (ok bool, next int) {
 				os.Exit(2);
 			}
 		} else {
-			f.set("true");
+			f.set("true")
 		}
 	} else {
 		// It must have a value, which might be the next argument.
@@ -518,7 +518,7 @@ func Parse() {
 			i = next;
 		}
 		if !ok {
-			break;
+			break
 		}
 	}
 }
diff --git a/src/pkg/flag/flag_test.go b/src/pkg/flag/flag_test.go
index 9a8b087b59..0acfc2f96f 100644
--- a/src/pkg/flag/flag_test.go
+++ b/src/pkg/flag/flag_test.go
@@ -22,7 +22,7 @@ var (
 
 func boolString(s string) string {
 	if s == "0" {
-		return "false";
+		return "false"
 	}
 	return "true";
 }
@@ -36,12 +36,12 @@ func TestEverything(t *testing.T) {
 			ok := false;
 			switch {
 			case f.Value.String() == desired:
-				ok = true;
+				ok = true
 			case f.Name == "test_bool" && f.Value.String() == boolString(desired):
-				ok = true;
+				ok = true
 			}
 			if !ok {
-				t.Error("Visit: bad value", f.Value.String(), "for", f.Name);
+				t.Error("Visit: bad value", f.Value.String(), "for", f.Name)
 			}
 		}
 	};
@@ -49,7 +49,7 @@ func TestEverything(t *testing.T) {
 	if len(m) != 8 {
 		t.Error("VisitAll misses some flags");
 		for k, v := range m {
-			t.Log(k, *v);
+			t.Log(k, *v)
 		}
 	}
 	m = make(map[string]*Flag);
@@ -57,7 +57,7 @@ func TestEverything(t *testing.T) {
 	if len(m) != 0 {
 		t.Errorf("Visit sees unset flags");
 		for k, v := range m {
-			t.Log(k, *v);
+			t.Log(k, *v)
 		}
 	}
 	// Now set all flags
@@ -74,7 +74,7 @@ func TestEverything(t *testing.T) {
 	if len(m) != 8 {
 		t.Error("Visit fails after set");
 		for k, v := range m {
-			t.Log(k, *v);
+			t.Log(k, *v)
 		}
 	}
 }
diff --git a/src/pkg/fmt/fmt_test.go b/src/pkg/fmt/fmt_test.go
index 07b1b221a9..8febdac745 100644
--- a/src/pkg/fmt/fmt_test.go
+++ b/src/pkg/fmt/fmt_test.go
@@ -17,7 +17,7 @@ func TestFmtInterface(t *testing.T) {
 	i1 = "abc";
 	s := Sprintf("%s", i1);
 	if s != "abc" {
-		t.Errorf(`Sprintf("%%s", empty("abc")) = %q want %q`, s, "abc");
+		t.Errorf(`Sprintf("%%s", empty("abc")) = %q want %q`, s, "abc")
 	}
 }
 
@@ -201,7 +201,7 @@ func TestSprintf(t *testing.T) {
 			for ; j < len(s); j++ {
 				c := s[j];
 				if (c < '0' || c > '9') && (c < 'a' || c > 'f') {
-					break;
+					break
 				}
 			}
 			s = s[0:i]+"PTR"+s[j:len(s)];
@@ -210,9 +210,9 @@ func TestSprintf(t *testing.T) {
 			if _, ok := tt.val.(string); ok {
 				// Don't requote the already-quoted strings.
 				// It's too confusing to read the errors.
-				t.Errorf("Sprintf(%q, %q) = %s want %s", tt.fmt, tt.val, s, tt.out);
+				t.Errorf("Sprintf(%q, %q) = %s want %s", tt.fmt, tt.val, s, tt.out)
 			} else {
-				t.Errorf("Sprintf(%q, %v) = %q want %q", tt.fmt, tt.val, s, tt.out);
+				t.Errorf("Sprintf(%q, %v) = %q want %q", tt.fmt, tt.val, s, tt.out)
 			}
 		}
 	}
@@ -224,14 +224,14 @@ func (*flagPrinter) Format(f State, c int) {
 	s := "%";
 	for i := 0; i < 128; i++ {
 		if f.Flag(i) {
-			s += string(i);
+			s += string(i)
 		}
 	}
 	if w, ok := f.Width(); ok {
-		s += Sprintf("%d", w);
+		s += Sprintf("%d", w)
 	}
 	if p, ok := f.Precision(); ok {
-		s += Sprintf(".%d", p);
+		s += Sprintf(".%d", p)
 	}
 	s += string(c);
 	io.WriteString(f, "["+s+"]");
@@ -262,7 +262,7 @@ func TestFlagParser(t *testing.T) {
 	for _, tt := range flagtests {
 		s := Sprintf(tt.in, &flagprinter);
 		if s != tt.out {
-			t.Errorf("Sprintf(%q, &flagprinter) => %q, want %q", tt.in, s, tt.out);
+			t.Errorf("Sprintf(%q, &flagprinter) => %q, want %q", tt.in, s, tt.out)
 		}
 	}
 }
@@ -287,7 +287,7 @@ func TestStructPrinter(t *testing.T) {
 	for _, tt := range tests {
 		out := Sprintf(tt.fmt, s);
 		if out != tt.out {
-			t.Errorf("Sprintf(%q, &s) = %q, want %q", tt.fmt, out, tt.out);
+			t.Errorf("Sprintf(%q, &s) = %q, want %q", tt.fmt, out, tt.out)
 		}
 	}
 }
@@ -297,12 +297,12 @@ func presentInMap(s string, a []string, t *testing.T) {
 	for i := 0; i < len(a); i++ {
 		loc := strings.Index(s, a[i]);
 		if loc < 0 {
-			t.Errorf("map print: expected to find %q in %q", a[i], s);
+			t.Errorf("map print: expected to find %q in %q", a[i], s)
 		}
 		// make sure the match ends here
 		loc += len(a[i]);
 		if loc >= len(s) || (s[loc] != ' ' && s[loc] != ']') {
-			t.Errorf("map print: %q not properly terminated in %q", a[i], s);
+			t.Errorf("map print: %q not properly terminated in %q", a[i], s)
 		}
 	}
 }
@@ -311,7 +311,7 @@ func TestMapPrinter(t *testing.T) {
 	m0 := make(map[int]string);
 	s := Sprint(m0);
 	if s != "map[]" {
-		t.Errorf("empty map printed as %q not %q", s, "map[]");
+		t.Errorf("empty map printed as %q not %q", s, "map[]")
 	}
 	m1 := map[int]string{1: "one", 2: "two", 3: "three"};
 	a := []string{"1:one", "2:two", "3:three"};
@@ -324,11 +324,11 @@ func TestEmptyMap(t *testing.T) {
 	var m map[string]int;
 	s := Sprint(m);
 	if s != emptyMapStr {
-		t.Errorf("nil map printed as %q not %q", s, emptyMapStr);
+		t.Errorf("nil map printed as %q not %q", s, emptyMapStr)
 	}
 	m = make(map[string]int);
 	s = Sprint(m);
 	if s != emptyMapStr {
-		t.Errorf("empty map printed as %q not %q", s, emptyMapStr);
+		t.Errorf("empty map printed as %q not %q", s, emptyMapStr)
 	}
 }
diff --git a/src/pkg/fmt/format.go b/src/pkg/fmt/format.go
index bd09017719..79817bfd46 100644
--- a/src/pkg/fmt/format.go
+++ b/src/pkg/fmt/format.go
@@ -127,20 +127,20 @@ func (f *Fmt) pad(s string) {
 		w -= len(s);
 		padchar := byte(' ');
 		if left && f.zero {
-			padchar = '0';
+			padchar = '0'
 		}
 		if w > 0 {
 			if w > nByte {
-				w = nByte;
+				w = nByte
 			}
 			buf := make([]byte, w);
 			for i := 0; i < w; i++ {
-				buf[i] = padchar;
+				buf[i] = padchar
 			}
 			if left {
-				s = string(buf)+s;
+				s = string(buf)+s
 			} else {
-				s = s+string(buf);
+				s = s+string(buf)
 			}
 		}
 	}
@@ -166,9 +166,9 @@ func putint(buf []byte, base, val uint64, digits string) int {
 // Fmt_boolean formats a boolean.
 func (f *Fmt) Fmt_boolean(v bool) *Fmt {
 	if v {
-		f.pad("true");
+		f.pad("true")
 	} else {
-		f.pad("false");
+		f.pad("false")
 	}
 	f.clearflags();
 	return f;
@@ -179,7 +179,7 @@ func (f *Fmt) integer(a int64, base uint, is_signed bool, digits string) string
 	var buf [nByte]byte;
 	negative := is_signed && a < 0;
 	if negative {
-		a = -a;
+		a = -a
 	}
 
 	// two ways to ask for extra leading zero digits: %.3d or %03d.
@@ -191,7 +191,7 @@ func (f *Fmt) integer(a int64, base uint, is_signed bool, digits string) string
 	} else if f.zero && f.wid_present && !f.minus && f.wid > 0 {
 		prec = f.wid;
 		if negative || f.plus || f.space {
-			prec--;	// leave room for sign
+			prec--	// leave room for sign
 		}
 	}
 
@@ -357,7 +357,7 @@ func (f *Fmt) Fmt_c(v int) *Fmt {
 func (f *Fmt) Fmt_s(s string) *Fmt {
 	if f.prec_present {
 		if f.prec < len(s) {
-			s = s[0 : f.prec];
+			s = s[0 : f.prec]
 		}
 	}
 	f.pad(s);
@@ -370,7 +370,7 @@ func (f *Fmt) Fmt_sx(s string) *Fmt {
 	t := "";
 	for i := 0; i < len(s); i++ {
 		if i > 0 && f.space {
-			t += " ";
+			t += " "
 		}
 		v := s[i];
 		t += string(ldigits[v>>4]);
@@ -398,9 +398,9 @@ func (f *Fmt) Fmt_sX(s string) *Fmt {
 func (f *Fmt) Fmt_q(s string) *Fmt {
 	var quoted string;
 	if f.sharp && strconv.CanBackquote(s) {
-		quoted = "`"+s+"`";
+		quoted = "`"+s+"`"
 	} else {
-		quoted = strconv.Quote(s);
+		quoted = strconv.Quote(s)
 	}
 	f.pad(quoted);
 	f.clearflags();
@@ -411,7 +411,7 @@ func (f *Fmt) Fmt_q(s string) *Fmt {
 
 func doPrec(f *Fmt, def int) int {
 	if f.prec_present {
-		return f.prec;
+		return f.prec
 	}
 	return def;
 }
@@ -424,27 +424,27 @@ func fmtString(f *Fmt, s string) *Fmt {
 
 // Fmt_e64 formats a float64 in the form -1.23e+12.
 func (f *Fmt) Fmt_e64(v float64) *Fmt {
-	return fmtString(f, strconv.Ftoa64(v, 'e', doPrec(f, 6)));
+	return fmtString(f, strconv.Ftoa64(v, 'e', doPrec(f, 6)))
 }
 
 // Fmt_E64 formats a float64 in the form -1.23E+12.
 func (f *Fmt) Fmt_E64(v float64) *Fmt {
-	return fmtString(f, strconv.Ftoa64(v, 'E', doPrec(f, 6)));
+	return fmtString(f, strconv.Ftoa64(v, 'E', doPrec(f, 6)))
 }
 
 // Fmt_f64 formats a float64 in the form -1.23.
 func (f *Fmt) Fmt_f64(v float64) *Fmt {
-	return fmtString(f, strconv.Ftoa64(v, 'f', doPrec(f, 6)));
+	return fmtString(f, strconv.Ftoa64(v, 'f', doPrec(f, 6)))
 }
 
 // Fmt_g64 formats a float64 in the 'f' or 'e' form according to size.
 func (f *Fmt) Fmt_g64(v float64) *Fmt {
-	return fmtString(f, strconv.Ftoa64(v, 'g', doPrec(f, -1)));
+	return fmtString(f, strconv.Ftoa64(v, 'g', doPrec(f, -1)))
 }
 
 // Fmt_g64 formats a float64 in the 'f' or 'E' form according to size.
 func (f *Fmt) Fmt_G64(v float64) *Fmt {
-	return fmtString(f, strconv.Ftoa64(v, 'G', doPrec(f, -1)));
+	return fmtString(f, strconv.Ftoa64(v, 'G', doPrec(f, -1)))
 }
 
 // Fmt_fb64 formats a float64 in the form -123p3 (exponent is power of 2).
@@ -456,27 +456,27 @@ func (f *Fmt) Fmt_fb64(v float64) *Fmt	{ return fmtString(f, strconv.Ftoa64(v, '
 
 // Fmt_e32 formats a float32 in the form -1.23e+12.
 func (f *Fmt) Fmt_e32(v float32) *Fmt {
-	return fmtString(f, strconv.Ftoa32(v, 'e', doPrec(f, 6)));
+	return fmtString(f, strconv.Ftoa32(v, 'e', doPrec(f, 6)))
 }
 
 // Fmt_E32 formats a float32 in the form -1.23E+12.
 func (f *Fmt) Fmt_E32(v float32) *Fmt {
-	return fmtString(f, strconv.Ftoa32(v, 'e', doPrec(f, 6)));
+	return fmtString(f, strconv.Ftoa32(v, 'e', doPrec(f, 6)))
 }
 
 // Fmt_f32 formats a float32 in the form -1.23.
 func (f *Fmt) Fmt_f32(v float32) *Fmt {
-	return fmtString(f, strconv.Ftoa32(v, 'f', doPrec(f, 6)));
+	return fmtString(f, strconv.Ftoa32(v, 'f', doPrec(f, 6)))
 }
 
 // Fmt_g32 formats a float32 in the 'f' or 'e' form according to size.
 func (f *Fmt) Fmt_g32(v float32) *Fmt {
-	return fmtString(f, strconv.Ftoa32(v, 'g', doPrec(f, -1)));
+	return fmtString(f, strconv.Ftoa32(v, 'g', doPrec(f, -1)))
 }
 
 // Fmt_G32 formats a float32 in the 'f' or 'E' form according to size.
 func (f *Fmt) Fmt_G32(v float32) *Fmt {
-	return fmtString(f, strconv.Ftoa32(v, 'G', doPrec(f, -1)));
+	return fmtString(f, strconv.Ftoa32(v, 'G', doPrec(f, -1)))
 }
 
 // Fmt_fb32 formats a float32 in the form -123p3 (exponent is power of 2).
@@ -485,28 +485,28 @@ func (f *Fmt) Fmt_fb32(v float32) *Fmt	{ return fmtString(f, strconv.Ftoa32(v, '
 // float
 func (x *Fmt) f(a float) *Fmt {
 	if strconv.FloatSize == 32 {
-		return x.Fmt_f32(float32(a));
+		return x.Fmt_f32(float32(a))
 	}
 	return x.Fmt_f64(float64(a));
 }
 
 func (x *Fmt) e(a float) *Fmt {
 	if strconv.FloatSize == 32 {
-		return x.Fmt_e32(float32(a));
+		return x.Fmt_e32(float32(a))
 	}
 	return x.Fmt_e64(float64(a));
 }
 
 func (x *Fmt) g(a float) *Fmt {
 	if strconv.FloatSize == 32 {
-		return x.Fmt_g32(float32(a));
+		return x.Fmt_g32(float32(a))
 	}
 	return x.Fmt_g64(float64(a));
 }
 
 func (x *Fmt) fb(a float) *Fmt {
 	if strconv.FloatSize == 32 {
-		return x.Fmt_fb32(float32(a));
+		return x.Fmt_fb32(float32(a))
 	}
 	return x.Fmt_fb64(float64(a));
 }
diff --git a/src/pkg/fmt/print.go b/src/pkg/fmt/print.go
index a27c65cf79..4d7dd4c7f9 100644
--- a/src/pkg/fmt/print.go
+++ b/src/pkg/fmt/print.go
@@ -143,15 +143,15 @@ func (p *pp) Precision() (prec int, ok bool)	{ return p.fmt.prec, p.fmt.prec_pre
 func (p *pp) Flag(b int) bool {
 	switch b {
 	case '-':
-		return p.fmt.minus;
+		return p.fmt.minus
 	case '+':
-		return p.fmt.plus;
+		return p.fmt.plus
 	case '#':
-		return p.fmt.sharp;
+		return p.fmt.sharp
 	case ' ':
-		return p.fmt.space;
+		return p.fmt.space
 	case '0':
-		return p.fmt.zero;
+		return p.fmt.zero
 	}
 	return false;
 }
@@ -160,11 +160,11 @@ func (p *pp) ensure(n int) {
 	if len(p.buf) < n {
 		newn := allocSize + len(p.buf);
 		if newn < n {
-			newn = n + allocSize;
+			newn = n + allocSize
 		}
 		b := make([]byte, newn);
 		for i := 0; i < p.n; i++ {
-			b[i] = p.buf[i];
+			b[i] = p.buf[i]
 		}
 		p.buf = b;
 	}
@@ -193,7 +193,7 @@ func (p *pp) add(c int) {
 		p.buf[p.n] = byte(c);
 		p.n++;
 	} else {
-		p.addstr(string(c));
+		p.addstr(string(c))
 	}
 }
 
@@ -298,7 +298,7 @@ func getField(v *reflect.StructValue, i int) reflect.Value {
 	val := v.Field(i);
 	if i, ok := val.(*reflect.InterfaceValue); ok {
 		if inter := i.Interface(); inter != nil {
-			return reflect.NewValue(inter);
+			return reflect.NewValue(inter)
 		}
 	}
 	return val;
@@ -308,7 +308,7 @@ func getField(v *reflect.StructValue, i int) reflect.Value {
 
 func getBool(v reflect.Value) (val bool, ok bool) {
 	if b, ok := v.(*reflect.BoolValue); ok {
-		return b.Get(), true;
+		return b.Get(), true
 	}
 	return;
 }
@@ -316,37 +316,37 @@ func getBool(v reflect.Value) (val bool, ok bool) {
 func getInt(v reflect.Value) (val int64, signed, ok bool) {
 	switch v := v.(type) {
 	case *reflect.IntValue:
-		return int64(v.Get()), true, true;
+		return int64(v.Get()), true, true
 	case *reflect.Int8Value:
-		return int64(v.Get()), true, true;
+		return int64(v.Get()), true, true
 	case *reflect.Int16Value:
-		return int64(v.Get()), true, true;
+		return int64(v.Get()), true, true
 	case *reflect.Int32Value:
-		return int64(v.Get()), true, true;
+		return int64(v.Get()), true, true
 	case *reflect.Int64Value:
-		return int64(v.Get()), true, true;
+		return int64(v.Get()), true, true
 	case *reflect.UintValue:
-		return int64(v.Get()), false, true;
+		return int64(v.Get()), false, true
 	case *reflect.Uint8Value:
-		return int64(v.Get()), false, true;
+		return int64(v.Get()), false, true
 	case *reflect.Uint16Value:
-		return int64(v.Get()), false, true;
+		return int64(v.Get()), false, true
 	case *reflect.Uint32Value:
-		return int64(v.Get()), false, true;
+		return int64(v.Get()), false, true
 	case *reflect.Uint64Value:
-		return int64(v.Get()), false, true;
+		return int64(v.Get()), false, true
 	case *reflect.UintptrValue:
-		return int64(v.Get()), false, true;
+		return int64(v.Get()), false, true
 	}
 	return;
 }
 
 func getString(v reflect.Value) (val string, ok bool) {
 	if v, ok := v.(*reflect.StringValue); ok {
-		return v.Get(), true;
+		return v.Get(), true
 	}
 	if bytes, ok := v.Interface().([]byte); ok {
-		return string(bytes), true;
+		return string(bytes), true
 	}
 	return;
 }
@@ -354,10 +354,10 @@ func getString(v reflect.Value) (val string, ok bool) {
 func getFloat32(v reflect.Value) (val float32, ok bool) {
 	switch v := v.(type) {
 	case *reflect.Float32Value:
-		return float32(v.Get()), true;
+		return float32(v.Get()), true
 	case *reflect.FloatValue:
 		if v.Type().Size() * 8 == 32 {
-			return float32(v.Get()), true;
+			return float32(v.Get()), true
 		}
 	}
 	return;
@@ -367,10 +367,10 @@ func getFloat64(v reflect.Value) (val float64, ok bool) {
 	switch v := v.(type) {
 	case *reflect.FloatValue:
 		if v.Type().Size() * 8 == 64 {
-			return float64(v.Get()), true;
+			return float64(v.Get()), true
 		}
 	case *reflect.Float64Value:
-		return float64(v.Get()), true;
+		return float64(v.Get()), true
 	}
 	return;
 }
@@ -378,7 +378,7 @@ func getFloat64(v reflect.Value) (val float64, ok bool) {
 func getPtr(v reflect.Value) (val uintptr, ok bool) {
 	switch v := v.(type) {
 	case *reflect.PtrValue:
-		return uintptr(v.Get()), true;
+		return uintptr(v.Get()), true
 	}
 	return;
 }
@@ -387,7 +387,7 @@ func getPtr(v reflect.Value) (val uintptr, ok bool) {
 
 func parsenum(s string, start, end int) (n int, got bool, newi int) {
 	if start >= end {
-		return 0, false, end;
+		return 0, false, end
 	}
 	isnum := false;
 	num := 0;
@@ -423,20 +423,20 @@ func (p *pp) printField(field reflect.Value, plus, sharp bool, depth int) (was_s
 BigSwitch:
 	switch f := field.(type) {
 	case *reflect.BoolValue:
-		s = p.fmt.Fmt_boolean(f.Get()).Str();
+		s = p.fmt.Fmt_boolean(f.Get()).Str()
 	case *reflect.Float32Value:
-		s = p.fmt.Fmt_g32(f.Get()).Str();
+		s = p.fmt.Fmt_g32(f.Get()).Str()
 	case *reflect.Float64Value:
-		s = p.fmt.Fmt_g64(f.Get()).Str();
+		s = p.fmt.Fmt_g64(f.Get()).Str()
 	case *reflect.FloatValue:
 		if field.Type().Size() * 8 == 32 {
-			s = p.fmt.Fmt_g32(float32(f.Get())).Str();
+			s = p.fmt.Fmt_g32(float32(f.Get())).Str()
 		} else {
-			s = p.fmt.Fmt_g64(float64(f.Get())).Str();
+			s = p.fmt.Fmt_g64(float64(f.Get())).Str()
 		}
 	case *reflect.StringValue:
 		if sharp {
-			s = p.fmt.Fmt_q(f.Get()).Str();
+			s = p.fmt.Fmt_q(f.Get()).Str()
 		} else {
 			s = p.fmt.Fmt_s(f.Get()).Str();
 			was_string = true;
@@ -446,15 +446,15 @@ BigSwitch:
 			p.addstr(field.Type().String());
 			p.addstr("{");
 		} else {
-			p.addstr("map[");
+			p.addstr("map[")
 		}
 		keys := f.Keys();
 		for i, key := range keys {
 			if i > 0 {
 				if sharp {
-					p.addstr(", ");
+					p.addstr(", ")
 				} else {
-					p.addstr(" ");
+					p.addstr(" ")
 				}
 			}
 			p.printField(key, plus, sharp, depth+1);
@@ -462,13 +462,13 @@ BigSwitch:
 			p.printField(f.Elem(key), plus, sharp, depth+1);
 		}
 		if sharp {
-			p.addstr("}");
+			p.addstr("}")
 		} else {
-			p.addstr("]");
+			p.addstr("]")
 		}
 	case *reflect.StructValue:
 		if sharp {
-			p.addstr(field.Type().String());
+			p.addstr(field.Type().String())
 		}
 		p.add('{');
 		v := f;
@@ -477,9 +477,9 @@ BigSwitch:
 		for i := 0; i < v.NumField(); i++ {
 			if i > 0 {
 				if sharp {
-					p.addstr(", ");
+					p.addstr(", ")
 				} else {
-					p.addstr(" ");
+					p.addstr(" ")
 				}
 			}
 			if plus || sharp {
@@ -498,32 +498,32 @@ BigSwitch:
 				p.addstr(field.Type().String());
 				p.addstr("(nil)");
 			} else {
-				s = "<nil>";
+				s = "<nil>"
 			}
 		} else {
-			return p.printField(value, plus, sharp, depth+1);
+			return p.printField(value, plus, sharp, depth+1)
 		}
 	case reflect.ArrayOrSliceValue:
 		if sharp {
 			p.addstr(field.Type().String());
 			p.addstr("{");
 		} else {
-			p.addstr("[");
+			p.addstr("[")
 		}
 		for i := 0; i < f.Len(); i++ {
 			if i > 0 {
 				if sharp {
-					p.addstr(", ");
+					p.addstr(", ")
 				} else {
-					p.addstr(" ");
+					p.addstr(" ")
 				}
 			}
 			p.printField(f.Elem(i), plus, sharp, depth+1);
 		}
 		if sharp {
-			p.addstr("}");
+			p.addstr("}")
 		} else {
-			p.addstr("]");
+			p.addstr("]")
 		}
 	case *reflect.PtrValue:
 		v := f.Get();
@@ -546,7 +546,7 @@ BigSwitch:
 			p.addstr(field.Type().String());
 			p.addstr(")(");
 			if v == 0 {
-				p.addstr("nil");
+				p.addstr("nil")
 			} else {
 				p.fmt.sharp = true;
 				p.addstr(p.fmt.Fmt_ux64(uint64(v)).Str());
@@ -567,7 +567,7 @@ BigSwitch:
 			p.addstr(field.Type().String());
 			p.addstr(")(");
 			if v == 0 {
-				p.addstr("nil");
+				p.addstr("nil")
 			} else {
 				p.fmt.sharp = true;
 				p.addstr(p.fmt.Fmt_ux64(uint64(v)).Str());
@@ -581,13 +581,13 @@ BigSwitch:
 		v, signed, ok := getInt(field);
 		if ok {
 			if signed {
-				s = p.fmt.Fmt_d64(v).Str();
+				s = p.fmt.Fmt_d64(v).Str()
 			} else {
 				if sharp {
 					p.fmt.sharp = true;	// turn on 0x
 					s = p.fmt.Fmt_ux64(uint64(v)).Str();
 				} else {
-					s = p.fmt.Fmt_ud64(uint64(v)).Str();
+					s = p.fmt.Fmt_ud64(uint64(v)).Str()
 				}
 			}
 			break;
@@ -615,24 +615,24 @@ func (p *pp) doprintf(format string, v *reflect.StructValue) {
 	F:	for ; i < end; i++ {
 			switch format[i] {
 			case '#':
-				p.fmt.sharp = true;
+				p.fmt.sharp = true
 			case '0':
-				p.fmt.zero = true;
+				p.fmt.zero = true
 			case '+':
-				p.fmt.plus = true;
+				p.fmt.plus = true
 			case '-':
-				p.fmt.minus = true;
+				p.fmt.minus = true
 			case ' ':
-				p.fmt.space = true;
+				p.fmt.space = true
 			default:
-				break F;
+				break F
 			}
 		}
 		// do we have 20 (width)?
 		p.fmt.wid, p.fmt.wid_present, i = parsenum(format, i, end);
 		// do we have .20 (precision)?
 		if i < end && format[i] == '.' {
-			p.fmt.prec, p.fmt.prec_present, i = parsenum(format, i+1, end);
+			p.fmt.prec, p.fmt.prec_present, i = parsenum(format, i+1, end)
 		}
 		c, w = utf8.DecodeRuneInString(format[i:len(format)]);
 		i += w;
@@ -666,116 +666,116 @@ func (p *pp) doprintf(format string, v *reflect.StructValue) {
 		case 't':
 			if v, ok := getBool(field); ok {
 				if v {
-					s = "true";
+					s = "true"
 				} else {
-					s = "false";
+					s = "false"
 				}
 			} else {
-				goto badtype;
+				goto badtype
 			}
 
 		// int
 		case 'b':
 			if v, _, ok := getInt(field); ok {
-				s = p.fmt.Fmt_b64(uint64(v)).Str();	// always unsigned
+				s = p.fmt.Fmt_b64(uint64(v)).Str()	// always unsigned
 			} else if v, ok := getFloat32(field); ok {
-				s = p.fmt.Fmt_fb32(v).Str();
+				s = p.fmt.Fmt_fb32(v).Str()
 			} else if v, ok := getFloat64(field); ok {
-				s = p.fmt.Fmt_fb64(v).Str();
+				s = p.fmt.Fmt_fb64(v).Str()
 			} else {
-				goto badtype;
+				goto badtype
 			}
 		case 'c':
 			if v, _, ok := getInt(field); ok {
-				s = p.fmt.Fmt_c(int(v)).Str();
+				s = p.fmt.Fmt_c(int(v)).Str()
 			} else {
-				goto badtype;
+				goto badtype
 			}
 		case 'd':
 			if v, signed, ok := getInt(field); ok {
 				if signed {
-					s = p.fmt.Fmt_d64(v).Str();
+					s = p.fmt.Fmt_d64(v).Str()
 				} else {
-					s = p.fmt.Fmt_ud64(uint64(v)).Str();
+					s = p.fmt.Fmt_ud64(uint64(v)).Str()
 				}
 			} else {
-				goto badtype;
+				goto badtype
 			}
 		case 'o':
 			if v, signed, ok := getInt(field); ok {
 				if signed {
-					s = p.fmt.Fmt_o64(v).Str();
+					s = p.fmt.Fmt_o64(v).Str()
 				} else {
-					s = p.fmt.Fmt_uo64(uint64(v)).Str();
+					s = p.fmt.Fmt_uo64(uint64(v)).Str()
 				}
 			} else {
-				goto badtype;
+				goto badtype
 			}
 		case 'x':
 			if v, signed, ok := getInt(field); ok {
 				if signed {
-					s = p.fmt.Fmt_x64(v).Str();
+					s = p.fmt.Fmt_x64(v).Str()
 				} else {
-					s = p.fmt.Fmt_ux64(uint64(v)).Str();
+					s = p.fmt.Fmt_ux64(uint64(v)).Str()
 				}
 			} else if v, ok := getString(field); ok {
-				s = p.fmt.Fmt_sx(v).Str();
+				s = p.fmt.Fmt_sx(v).Str()
 			} else {
-				goto badtype;
+				goto badtype
 			}
 		case 'X':
 			if v, signed, ok := getInt(field); ok {
 				if signed {
-					s = p.fmt.Fmt_X64(v).Str();
+					s = p.fmt.Fmt_X64(v).Str()
 				} else {
-					s = p.fmt.Fmt_uX64(uint64(v)).Str();
+					s = p.fmt.Fmt_uX64(uint64(v)).Str()
 				}
 			} else if v, ok := getString(field); ok {
-				s = p.fmt.Fmt_sX(v).Str();
+				s = p.fmt.Fmt_sX(v).Str()
 			} else {
-				goto badtype;
+				goto badtype
 			}
 
 		// float
 		case 'e':
 			if v, ok := getFloat32(field); ok {
-				s = p.fmt.Fmt_e32(v).Str();
+				s = p.fmt.Fmt_e32(v).Str()
 			} else if v, ok := getFloat64(field); ok {
-				s = p.fmt.Fmt_e64(v).Str();
+				s = p.fmt.Fmt_e64(v).Str()
 			} else {
-				goto badtype;
+				goto badtype
 			}
 		case 'E':
 			if v, ok := getFloat32(field); ok {
-				s = p.fmt.Fmt_E32(v).Str();
+				s = p.fmt.Fmt_E32(v).Str()
 			} else if v, ok := getFloat64(field); ok {
-				s = p.fmt.Fmt_E64(v).Str();
+				s = p.fmt.Fmt_E64(v).Str()
 			} else {
-				goto badtype;
+				goto badtype
 			}
 		case 'f':
 			if v, ok := getFloat32(field); ok {
-				s = p.fmt.Fmt_f32(v).Str();
+				s = p.fmt.Fmt_f32(v).Str()
 			} else if v, ok := getFloat64(field); ok {
-				s = p.fmt.Fmt_f64(v).Str();
+				s = p.fmt.Fmt_f64(v).Str()
 			} else {
-				goto badtype;
+				goto badtype
 			}
 		case 'g':
 			if v, ok := getFloat32(field); ok {
-				s = p.fmt.Fmt_g32(v).Str();
+				s = p.fmt.Fmt_g32(v).Str()
 			} else if v, ok := getFloat64(field); ok {
-				s = p.fmt.Fmt_g64(v).Str();
+				s = p.fmt.Fmt_g64(v).Str()
 			} else {
-				goto badtype;
+				goto badtype
 			}
 		case 'G':
 			if v, ok := getFloat32(field); ok {
-				s = p.fmt.Fmt_G32(v).Str();
+				s = p.fmt.Fmt_G32(v).Str()
 			} else if v, ok := getFloat64(field); ok {
-				s = p.fmt.Fmt_G64(v).Str();
+				s = p.fmt.Fmt_G64(v).Str()
 			} else {
-				goto badtype;
+				goto badtype
 			}
 
 		// string
@@ -788,27 +788,27 @@ func (p *pp) doprintf(format string, v *reflect.StructValue) {
 				}
 			}
 			if v, ok := getString(field); ok {
-				s = p.fmt.Fmt_s(v).Str();
+				s = p.fmt.Fmt_s(v).Str()
 			} else {
-				goto badtype;
+				goto badtype
 			}
 		case 'q':
 			if v, ok := getString(field); ok {
-				s = p.fmt.Fmt_q(v).Str();
+				s = p.fmt.Fmt_q(v).Str()
 			} else {
-				goto badtype;
+				goto badtype
 			}
 
 		// pointer
 		case 'p':
 			if v, ok := getPtr(field); ok {
 				if v == 0 {
-					s = "<nil>";
+					s = "<nil>"
 				} else {
-					s = "0x" + p.fmt.Fmt_uX64(uint64(v)).Str();
+					s = "0x" + p.fmt.Fmt_uX64(uint64(v)).Str()
 				}
 			} else {
-				goto badtype;
+				goto badtype
 			}
 
 		// arbitrary value; do your best
@@ -820,7 +820,7 @@ func (p *pp) doprintf(format string, v *reflect.StructValue) {
 
 		// the value's type
 		case 'T':
-			s = field.Type().String();
+			s = field.Type().String()
 
 		default:
 		badtype:
@@ -839,7 +839,7 @@ func (p *pp) doprintf(format string, v *reflect.StructValue) {
 			p.addstr("=");
 			p.printField(field, false, false, 0);
 			if fieldnum+1 < v.NumField() {
-				p.addstr(", ");
+				p.addstr(", ")
 			}
 		}
 		p.addstr(")");
@@ -854,12 +854,12 @@ func (p *pp) doprint(v *reflect.StructValue, addspace, addnewline bool) {
 		if fieldnum > 0 {
 			_, is_string := field.(*reflect.StringValue);
 			if addspace || !is_string && !prev_string {
-				p.add(' ');
+				p.add(' ')
 			}
 		}
 		prev_string = p.printField(field, false, false, 0);
 	}
 	if addnewline {
-		p.add('\n');
+		p.add('\n')
 	}
 }
diff --git a/src/pkg/go/ast/ast.go b/src/pkg/go/ast/ast.go
index ec299c5f75..b501247cb6 100644
--- a/src/pkg/go/ast/ast.go
+++ b/src/pkg/go/ast/ast.go
@@ -97,7 +97,7 @@ type Field struct {
 
 func (f *Field) Pos() token.Position {
 	if len(f.Names) > 0 {
-		return f.Names[0].Pos();
+		return f.Names[0].Pos()
 	}
 	return f.Type.Pos();
 }
@@ -600,7 +600,7 @@ type (
 //
 func (s *ImportSpec) Pos() token.Position {
 	if s.Name != nil {
-		return s.Name.Pos();
+		return s.Name.Pos()
 	}
 	return s.Path[0].Pos();
 }
diff --git a/src/pkg/go/ast/filter.go b/src/pkg/go/ast/filter.go
index ee6747f65b..2e86435bf6 100644
--- a/src/pkg/go/ast/filter.go
+++ b/src/pkg/go/ast/filter.go
@@ -23,14 +23,14 @@ func filterIdentList(list []*Ident) []*Ident {
 func isExportedType(typ Expr) bool {
 	switch t := typ.(type) {
 	case *Ident:
-		return t.IsExported();
+		return t.IsExported()
 	case *ParenExpr:
-		return isExportedType(t.X);
+		return isExportedType(t.X)
 	case *SelectorExpr:
 		// assume t.X is a typename
-		return t.Sel.IsExported();
+		return t.Sel.IsExported()
 	case *StarExpr:
-		return isExportedType(t.X);
+		return isExportedType(t.X)
 	}
 	return false;
 }
@@ -47,12 +47,12 @@ func filterFieldList(list []*Field, incomplete *bool) []*Field {
 			// fields, so this is not absolutely correct.
 			// However, this cannot be done w/o complete
 			// type information.)
-			exported = isExportedType(f.Type);
+			exported = isExportedType(f.Type)
 		} else {
 			n := len(f.Names);
 			f.Names = filterIdentList(f.Names);
 			if len(f.Names) < n {
-				*incomplete = true;
+				*incomplete = true
 			}
 			exported = len(f.Names) > 0;
 		}
@@ -63,7 +63,7 @@ func filterFieldList(list []*Field, incomplete *bool) []*Field {
 		}
 	}
 	if j < len(list) {
-		*incomplete = true;
+		*incomplete = true
 	}
 	return list[0:j];
 }
@@ -71,7 +71,7 @@ func filterFieldList(list []*Field, incomplete *bool) []*Field {
 
 func filterParamList(list []*Field) {
 	for _, f := range list {
-		filterType(f.Type);
+		filterType(f.Type)
 	}
 }
 
@@ -81,19 +81,19 @@ var noPos token.Position
 func filterType(typ Expr) {
 	switch t := typ.(type) {
 	case *ArrayType:
-		filterType(t.Elt);
+		filterType(t.Elt)
 	case *StructType:
-		t.Fields = filterFieldList(t.Fields, &t.Incomplete);
+		t.Fields = filterFieldList(t.Fields, &t.Incomplete)
 	case *FuncType:
 		filterParamList(t.Params);
 		filterParamList(t.Results);
 	case *InterfaceType:
-		t.Methods = filterFieldList(t.Methods, &t.Incomplete);
+		t.Methods = filterFieldList(t.Methods, &t.Incomplete)
 	case *MapType:
 		filterType(t.Key);
 		filterType(t.Value);
 	case *ChanType:
-		filterType(t.Value);
+		filterType(t.Value)
 	}
 }
 
@@ -180,7 +180,7 @@ func PackageExports(pkg *Package) bool {
 	hasExports := false;
 	for _, f := range pkg.Files {
 		if FileExports(f) {
-			hasExports = true;
+			hasExports = true
 		}
 	}
 	return hasExports;
@@ -203,7 +203,7 @@ func MergePackageFiles(pkg *Package) *File {
 	ndecls := 0;
 	for _, f := range pkg.Files {
 		if f.Doc != nil {
-			ncomments += len(f.Doc.List)+1;	// +1 for separator
+			ncomments += len(f.Doc.List)+1	// +1 for separator
 		}
 		ndecls += len(f.Decls);
 	}
diff --git a/src/pkg/go/ast/scope.go b/src/pkg/go/ast/scope.go
index 301630de64..2409536738 100644
--- a/src/pkg/go/ast/scope.go
+++ b/src/pkg/go/ast/scope.go
@@ -26,7 +26,7 @@ func NewScope(outer *Scope) *Scope	{ return &Scope{outer, make(map[string]*Ident
 //
 func (s *Scope) Declare(ident *Ident) bool {
 	if _, found := s.Names[ident.Value]; found {
-		return false;
+		return false
 	}
 	s.Names[ident.Value] = ident;
 	return true;
@@ -40,7 +40,7 @@ func (s *Scope) Declare(ident *Ident) bool {
 func (s *Scope) Lookup(name string) *Ident {
 	for ; s != nil; s = s.Outer {
 		if ident, found := s.Names[name]; found {
-			return ident;
+			return ident
 		}
 	}
 	return nil;
diff --git a/src/pkg/go/ast/walk.go b/src/pkg/go/ast/walk.go
index 379cc90124..c1ed366215 100644
--- a/src/pkg/go/ast/walk.go
+++ b/src/pkg/go/ast/walk.go
@@ -17,49 +17,49 @@ type Visitor interface {
 
 func walkIdent(v Visitor, x *Ident) {
 	if x != nil {
-		Walk(v, x);
+		Walk(v, x)
 	}
 }
 
 
 func walkCommentGroup(v Visitor, g *CommentGroup) {
 	if g != nil {
-		Walk(v, g);
+		Walk(v, g)
 	}
 }
 
 
 func walkFieldList(v Visitor, list []*Field) {
 	for _, x := range list {
-		Walk(v, x);
+		Walk(v, x)
 	}
 }
 
 
 func walkIdentList(v Visitor, list []*Ident) {
 	for _, x := range list {
-		Walk(v, x);
+		Walk(v, x)
 	}
 }
 
 
 func walkExprList(v Visitor, list []Expr) {
 	for _, x := range list {
-		Walk(v, x);
+		Walk(v, x)
 	}
 }
 
 
 func walkStmtList(v Visitor, list []Stmt) {
 	for _, s := range list {
-		Walk(v, s);
+		Walk(v, s)
 	}
 }
 
 
 func walkBlockStmt(v Visitor, b *BlockStmt) {
 	if b != nil {
-		Walk(v, b);
+		Walk(v, b)
 	}
 }
 
@@ -70,7 +70,7 @@ func walkBlockStmt(v Visitor, b *BlockStmt) {
 //
 func Walk(v Visitor, node interface{}) {
 	if node == nil || !v.Visit(node) {
-		return;
+		return
 	}
 
 	// walk children
@@ -83,7 +83,7 @@ func Walk(v Visitor, node interface{}) {
 
 	case *CommentGroup:
 		for _, c := range n.List {
-			Walk(v, c);
+			Walk(v, c)
 		}
 		// TODO(gri): Keep comments in a list/vector instead
 		// of linking them via Next. Following next will lead
@@ -96,7 +96,7 @@ func Walk(v Visitor, node interface{}) {
 		walkIdentList(v, n.Names);
 		Walk(v, n.Type);
 		for _, x := range n.Tag {
-			Walk(v, x);
+			Walk(v, x)
 		}
 		walkCommentGroup(v, n.Comment);
 
@@ -106,12 +106,12 @@ func Walk(v Visitor, node interface{}) {
 
 	case *StringList:
 		for _, x := range n.Strings {
-			Walk(v, x);
+			Walk(v, x)
 		}
 
 	case *FuncLit:
 		if n != nil {
-			Walk(v, n.Type);
+			Walk(v, n.Type)
 		}
 		walkBlockStmt(v, n.Body);
 
@@ -120,7 +120,7 @@ func Walk(v Visitor, node interface{}) {
 		walkExprList(v, n.Elts);
 
 	case *ParenExpr:
-		Walk(v, n.X);
+		Walk(v, n.X)
 
 	case *SelectorExpr:
 		Walk(v, n.X);
@@ -140,10 +140,10 @@ func Walk(v Visitor, node interface{}) {
 		walkExprList(v, n.Args);
 
 	case *StarExpr:
-		Walk(v, n.X);
+		Walk(v, n.X)
 
 	case *UnaryExpr:
-		Walk(v, n.X);
+		Walk(v, n.X)
 
 	case *BinaryExpr:
 		Walk(v, n.X);
@@ -159,28 +159,28 @@ func Walk(v Visitor, node interface{}) {
 		Walk(v, n.Elt);
 
 	case *StructType:
-		walkFieldList(v, n.Fields);
+		walkFieldList(v, n.Fields)
 
 	case *FuncType:
 		walkFieldList(v, n.Params);
 		walkFieldList(v, n.Results);
 
 	case *InterfaceType:
-		walkFieldList(v, n.Methods);
+		walkFieldList(v, n.Methods)
 
 	case *MapType:
 		Walk(v, n.Key);
 		Walk(v, n.Value);
 
 	case *ChanType:
-		Walk(v, n.Value);
+		Walk(v, n.Value)
 
 	// Statements
 	case *BadStmt:
 		// nothing to do
 
 	case *DeclStmt:
-		Walk(v, n.Decl);
+		Walk(v, n.Decl)
 
 	case *EmptyStmt:
 		// nothing to do
@@ -190,10 +190,10 @@ func Walk(v Visitor, node interface{}) {
 		Walk(v, n.Stmt);
 
 	case *ExprStmt:
-		Walk(v, n.X);
+		Walk(v, n.X)
 
 	case *IncDecStmt:
-		Walk(v, n.X);
+		Walk(v, n.X)
 
 	case *AssignStmt:
 		walkExprList(v, n.Lhs);
@@ -201,22 +201,22 @@ func Walk(v Visitor, node interface{}) {
 
 	case *GoStmt:
 		if n.Call != nil {
-			Walk(v, n.Call);
+			Walk(v, n.Call)
 		}
 
 	case *DeferStmt:
 		if n.Call != nil {
-			Walk(v, n.Call);
+			Walk(v, n.Call)
 		}
 
 	case *ReturnStmt:
-		walkExprList(v, n.Results);
+		walkExprList(v, n.Results)
 
 	case *BranchStmt:
-		walkIdent(v, n.Label);
+		walkIdent(v, n.Label)
 
 	case *BlockStmt:
-		walkStmtList(v, n.List);
+		walkStmtList(v, n.List)
 
 	case *IfStmt:
 		Walk(v, n.Init);
@@ -248,7 +248,7 @@ func Walk(v Visitor, node interface{}) {
 		walkStmtList(v, n.Body);
 
 	case *SelectStmt:
-		walkBlockStmt(v, n.Body);
+		walkBlockStmt(v, n.Body)
 
 	case *ForStmt:
 		Walk(v, n.Init);
@@ -267,7 +267,7 @@ func Walk(v Visitor, node interface{}) {
 		walkCommentGroup(v, n.Doc);
 		walkIdent(v, n.Name);
 		for _, x := range n.Path {
-			Walk(v, x);
+			Walk(v, x)
 		}
 		walkCommentGroup(v, n.Comment);
 
@@ -290,17 +290,17 @@ func Walk(v Visitor, node interface{}) {
 	case *GenDecl:
 		walkCommentGroup(v, n.Doc);
 		for _, s := range n.Specs {
-			Walk(v, s);
+			Walk(v, s)
 		}
 
 	case *FuncDecl:
 		walkCommentGroup(v, n.Doc);
 		if n.Recv != nil {
-			Walk(v, n.Recv);
+			Walk(v, n.Recv)
 		}
 		walkIdent(v, n.Name);
 		if n.Type != nil {
-			Walk(v, n.Type);
+			Walk(v, n.Type)
 		}
 		walkBlockStmt(v, n.Body);
 
@@ -309,13 +309,13 @@ func Walk(v Visitor, node interface{}) {
 		walkCommentGroup(v, n.Doc);
 		walkIdent(v, n.Name);
 		for _, d := range n.Decls {
-			Walk(v, d);
+			Walk(v, d)
 		}
 		walkCommentGroup(v, n.Comments);
 
 	case *Package:
 		for _, f := range n.Files {
-			Walk(v, f);
+			Walk(v, f)
 		}
 
 	default:
diff --git a/src/pkg/go/doc/comment.go b/src/pkg/go/doc/comment.go
index 3d04c349c4..ba9371439b 100644
--- a/src/pkg/go/doc/comment.go
+++ b/src/pkg/go/doc/comment.go
@@ -19,11 +19,11 @@ import (
 // with the comment markers - //, /*, and */ - removed.
 func CommentText(comment *ast.CommentGroup) string {
 	if comment == nil {
-		return "";
+		return ""
 	}
 	comments := make([]string, len(comment.List));
 	for i, c := range comment.List {
-		comments[i] = string(c.Text);
+		comments[i] = string(c.Text)
 	}
 
 	lines := make([]string, 0, 20);
@@ -32,12 +32,12 @@ func CommentText(comment *ast.CommentGroup) string {
 		// The parser has given us exactly the comment text.
 		switch n := len(c); {
 		case n >= 4 && c[0:2] == "/*" && c[n-2 : n] == "*/":
-			c = c[2 : n-2];
+			c = c[2 : n-2]
 		case n >= 2 && c[0:2] == "//":
 			c = c[2:n];
 			// Remove leading space after //, if there is one.
 			if len(c) > 0 && c[0] == ' ' {
-				c = c[1:len(c)];
+				c = c[1:len(c)]
 			}
 		}
 
@@ -49,7 +49,7 @@ func CommentText(comment *ast.CommentGroup) string {
 			// Strip trailing white space
 			m := len(l);
 			for m > 0 && (l[m-1] == ' ' || l[m-1] == '\n' || l[m-1] == '\t' || l[m-1] == '\r') {
-				m--;
+				m--
 			}
 			l = l[0:m];
 
@@ -58,7 +58,7 @@ func CommentText(comment *ast.CommentGroup) string {
 			if n+1 >= cap(lines) {
 				newlines := make([]string, n, 2*cap(lines));
 				for k := range newlines {
-					newlines[k] = lines[k];
+					newlines[k] = lines[k]
 				}
 				lines = newlines;
 			}
@@ -100,7 +100,7 @@ func split(text []byte) [][]byte {
 		}
 	}
 	if last < len(text) {
-		n++;
+		n++
 	}
 
 	// split
@@ -115,7 +115,7 @@ func split(text []byte) [][]byte {
 		}
 	}
 	if last < len(text) {
-		out[n] = text[last:len(text)];
+		out[n] = text[last:len(text)]
 	}
 
 	return out;
@@ -137,9 +137,9 @@ func commentEscape(w io.Writer, s []byte) {
 			last = i+2;
 			switch s[i] {
 			case '`':
-				w.Write(ldquo);
+				w.Write(ldquo)
 			case '\'':
-				w.Write(rdquo);
+				w.Write(rdquo)
 			}
 			i++;	// loop will add one more
 		}
@@ -159,7 +159,7 @@ var (
 func indentLen(s []byte) int {
 	i := 0;
 	for i < len(s) && (s[i] == ' ' || s[i] == '\t') {
-		i++;
+		i++
 	}
 	return i;
 }
@@ -171,7 +171,7 @@ func isBlank(s []byte) bool	{ return len(s) == 0 || (len(s) == 1 && s[0] == '\n'
 func commonPrefix(a, b []byte) []byte {
 	i := 0;
 	for i < len(a) && i < len(b) && a[i] == b[i] {
-		i++;
+		i++
 	}
 	return a[0:i];
 }
@@ -179,14 +179,14 @@ func commonPrefix(a, b []byte) []byte {
 
 func unindent(block [][]byte) {
 	if len(block) == 0 {
-		return;
+		return
 	}
 
 	// compute maximum common white prefix
 	prefix := block[0][0 : indentLen(block[0])];
 	for _, line := range block {
 		if !isBlank(line) {
-			prefix = commonPrefix(prefix, line[0 : indentLen(line)]);
+			prefix = commonPrefix(prefix, line[0 : indentLen(line)])
 		}
 	}
 	n := len(prefix);
@@ -194,7 +194,7 @@ func unindent(block [][]byte) {
 	// remove
 	for i, line := range block {
 		if !isBlank(line) {
-			block[i] = line[n:len(line)];
+			block[i] = line[n:len(line)]
 		}
 	}
 }
@@ -244,11 +244,11 @@ func ToHTML(w io.Writer, s []byte) {
 			// count indented or blank lines
 			j := i+1;
 			for j < len(lines) && (isBlank(lines[j]) || indentLen(lines[j]) > 0) {
-				j++;
+				j++
 			}
 			// but not trailing blank lines
 			for j > i && isBlank(lines[j-1]) {
-				j--;
+				j--
 			}
 			block := lines[i:j];
 			i = j;
@@ -260,7 +260,7 @@ func ToHTML(w io.Writer, s []byte) {
 			// just html escaping
 			w.Write(html_pre);
 			for _, line := range block {
-				template.HTMLEscape(w, line);
+				template.HTMLEscape(w, line)
 			}
 			w.Write(html_endpre);
 			continue;
diff --git a/src/pkg/go/doc/doc.go b/src/pkg/go/doc/doc.go
index 865f52ec46..9c85c20beb 100644
--- a/src/pkg/go/doc/doc.go
+++ b/src/pkg/go/doc/doc.go
@@ -61,17 +61,17 @@ func (doc *docReader) addType(decl *ast.GenDecl) {
 	if typ != nil {
 		// a type should be added at most once, so typ.decl
 		// should be nil - if it isn't, simply overwrite it
-		typ.decl = decl;
+		typ.decl = decl
 	}
 }
 
 
 func (doc *docReader) lookupTypeDoc(name string) *typeDoc {
 	if name == "" {
-		return nil;	// no type docs for anonymous types
+		return nil	// no type docs for anonymous types
 	}
 	if tdoc, found := doc.types[name]; found {
-		return tdoc;
+		return tdoc
 	}
 	// type wasn't found - add one without declaration
 	tdoc := &typeDoc{nil, vector.New(0), make(map[string]*ast.FuncDecl), make(map[string]*ast.FuncDecl)};
@@ -86,10 +86,10 @@ func baseTypeName(typ ast.Expr) string {
 		// if the type is not exported, the effect to
 		// a client is as if there were no type name
 		if t.IsExported() {
-			return string(t.Value);
+			return string(t.Value)
 		}
 	case *ast.StarExpr:
-		return baseTypeName(t.X);
+		return baseTypeName(t.X)
 	}
 	return "";
 }
@@ -109,13 +109,13 @@ func (doc *docReader) addValue(decl *ast.GenDecl) {
 			switch {
 			case v.Type != nil:
 				// a type is present; determine it's name
-				name = baseTypeName(v.Type);
+				name = baseTypeName(v.Type)
 			case decl.Tok == token.CONST:
 				// no type is present but we have a constant declaration;
 				// use the previous type name (w/o more type information
 				// we cannot handle the case of unnamed variables with
 				// initializer expressions except for some trivial cases)
-				name = prev;
+				name = prev
 			}
 			if name != "" {
 				// entry has a named type
@@ -139,7 +139,7 @@ func (doc *docReader) addValue(decl *ast.GenDecl) {
 		// typed entries are sufficiently frequent
 		typ := doc.lookupTypeDoc(domName);
 		if typ != nil {
-			values = typ.values;	// associate with that type
+			values = typ.values	// associate with that type
 		}
 	}
 
@@ -156,7 +156,7 @@ func (doc *docReader) addFunc(fun *ast.FuncDecl) {
 		typ := doc.lookupTypeDoc(baseTypeName(fun.Recv.Type));
 		if typ != nil {
 			// exported receiver type
-			typ.methods[name] = fun;
+			typ.methods[name] = fun
 		}
 		// otherwise don't show the method
 		// TODO(gri): There may be exported methods of non-exported types
@@ -209,7 +209,7 @@ func (doc *docReader) addDecl(decl ast.Decl) {
 			switch d.Tok {
 			case token.CONST, token.VAR:
 				// constants and variables are always handled as a group
-				doc.addValue(d);
+				doc.addValue(d)
 			case token.TYPE:
 				// types are handled individually
 				var noPos token.Position;
@@ -225,13 +225,13 @@ func (doc *docReader) addDecl(decl ast.Decl) {
 					// makeTypeDocs below). Simpler data structures, but
 					// would lose GenDecl documentation if the TypeSpec
 					// has documentation as well.
-					doc.addType(&ast.GenDecl{d.Doc, d.Pos(), token.TYPE, noPos, []ast.Spec{spec}, noPos});
+					doc.addType(&ast.GenDecl{d.Doc, d.Pos(), token.TYPE, noPos, []ast.Spec{spec}, noPos})
 					// A new GenDecl node is created, no need to nil out d.Doc.
 				}
 			}
 		}
 	case *ast.FuncDecl:
-		doc.addFunc(d);
+		doc.addFunc(d)
 	}
 }
 
@@ -239,7 +239,7 @@ func (doc *docReader) addDecl(decl ast.Decl) {
 func copyCommentList(list []*ast.Comment) []*ast.Comment {
 	copy := make([]*ast.Comment, len(list));
 	for i, c := range list {
-		copy[i] = c;
+		copy[i] = c
 	}
 	return copy;
 }
@@ -268,7 +268,7 @@ func (doc *docReader) addFile(src *ast.File) {
 
 	// add all declarations
 	for _, decl := range src.Decls {
-		doc.addDecl(decl);
+		doc.addDecl(decl)
 	}
 
 	// collect BUG(...) comments
@@ -331,14 +331,14 @@ func (p sortValueDoc) Swap(i, j int)	{ p[i], p[j] = p[j], p[i] }
 
 func declName(d *ast.GenDecl) string {
 	if len(d.Specs) != 1 {
-		return "";
+		return ""
 	}
 
 	switch v := d.Specs[0].(type) {
 	case *ast.ValueSpec:
-		return v.Names[0].Value;
+		return v.Names[0].Value
 	case *ast.TypeSpec:
-		return v.Name.Value;
+		return v.Name.Value
 	}
 
 	return "";
@@ -350,7 +350,7 @@ func (p sortValueDoc) Less(i, j int) bool {
 	// pull blocks (name = "") up to top
 	// in original order
 	if ni, nj := declName(p[i].Decl), declName(p[j].Decl); ni != nj {
-		return ni < nj;
+		return ni < nj
 	}
 	return p[i].order < p[j].order;
 }
@@ -398,7 +398,7 @@ func makeFuncDocs(m map[string]*ast.FuncDecl) []*FuncDoc {
 		doc.Doc = CommentText(f.Doc);
 		f.Doc = nil;	// doc consumed - remove from ast.FuncDecl node
 		if f.Recv != nil {
-			doc.Recv = f.Recv.Type;
+			doc.Recv = f.Recv.Type
 		}
 		doc.Name = f.Name.Value;
 		doc.Decl = f;
@@ -434,7 +434,7 @@ func (p sortTypeDoc) Less(i, j int) bool {
 	// pull blocks (name = "") up to top
 	// in original order
 	if ni, nj := p[i].Type.Name.Value, p[j].Type.Name.Value; ni != nj {
-		return ni < nj;
+		return ni < nj
 	}
 	return p[i].order < p[j].order;
 }
@@ -457,7 +457,7 @@ func (doc *docReader) makeTypeDocs(m map[string]*typeDoc) []*TypeDoc {
 			typespec.Doc = nil;	// doc consumed - remove from ast.TypeSpec node
 			if doc == nil {
 				// no doc associated with the spec, use the declaration doc, if any
-				doc = decl.Doc;
+				doc = decl.Doc
 			}
 			decl.Doc = nil;	// doc consumed - remove from ast.Decl node
 			t.Doc = CommentText(doc);
@@ -480,13 +480,13 @@ func (doc *docReader) makeTypeDocs(m map[string]*typeDoc) []*TypeDoc {
 			doc.values.AppendVector(old.values);
 			// 2) move factory functions
 			for name, f := range old.factories {
-				doc.funcs[name] = f;
+				doc.funcs[name] = f
 			}
 			// 3) move methods
 			for name, f := range old.methods {
 				// don't overwrite functions with the same name
 				if _, found := doc.funcs[name]; !found {
-					doc.funcs[name] = f;
+					doc.funcs[name] = f
 				}
 			}
 		}
@@ -500,7 +500,7 @@ func (doc *docReader) makeTypeDocs(m map[string]*typeDoc) []*TypeDoc {
 func makeBugDocs(v *vector.Vector) []string {
 	d := make([]string, v.Len());
 	for i := 0; i < v.Len(); i++ {
-		d[i] = CommentText(v.At(i).(*ast.CommentGroup));
+		d[i] = CommentText(v.At(i).(*ast.CommentGroup))
 	}
 	return d;
 }
@@ -553,7 +553,7 @@ func isRegexp(s string) bool {
 	for _, c := range s {
 		for _, m := range metachars {
 			if c == m {
-				return true;
+				return true
 			}
 		}
 	}
@@ -565,11 +565,11 @@ func match(s string, a []string) bool {
 	for _, t := range a {
 		if isRegexp(t) {
 			if matched, _ := regexp.MatchString(t, s); matched {
-				return true;
+				return true
 			}
 		}
 		if s == t {
-			return true;
+			return true
 		}
 	}
 	return false;
@@ -582,12 +582,12 @@ func matchDecl(d *ast.GenDecl, names []string) bool {
 		case *ast.ValueSpec:
 			for _, name := range v.Names {
 				if match(name.Value, names) {
-					return true;
+					return true
 				}
 			}
 		case *ast.TypeSpec:
 			if match(v.Name.Value, names) {
-				return true;
+				return true
 			}
 		}
 	}
@@ -624,7 +624,7 @@ func filterTypeDocs(a []*TypeDoc, names []string) []*TypeDoc {
 	for _, td := range a {
 		match := false;
 		if matchDecl(td.Decl, names) {
-			match = true;
+			match = true
 		} else {
 			// type name doesn't match, but we may have matching factories or methods
 			td.Factories = filterFuncDocs(td.Factories, names);
diff --git a/src/pkg/go/parser/interface.go b/src/pkg/go/parser/interface.go
index 3c9be7532c..50d7dff656 100644
--- a/src/pkg/go/parser/interface.go
+++ b/src/pkg/go/parser/interface.go
@@ -26,23 +26,23 @@ func readSource(filename string, src interface{}) ([]byte, os.Error) {
 	if src != nil {
 		switch s := src.(type) {
 		case string:
-			return strings.Bytes(s), nil;
+			return strings.Bytes(s), nil
 		case []byte:
-			return s, nil;
+			return s, nil
 		case *bytes.Buffer:
 			// is io.Reader, but src is already available in []byte form
 			if s != nil {
-				return s.Bytes(), nil;
+				return s.Bytes(), nil
 			}
 		case io.Reader:
 			var buf bytes.Buffer;
 			_, err := io.Copy(&buf, s);
 			if err != nil {
-				return nil, err;
+				return nil, err
 			}
 			return buf.Bytes(), nil;
 		default:
-			return nil, os.ErrorString("invalid source");
+			return nil, os.ErrorString("invalid source")
 		}
 	}
 
@@ -58,7 +58,7 @@ func readSource(filename string, src interface{}) ([]byte, os.Error) {
 func ParseExpr(filename string, src interface{}) (ast.Expr, os.Error) {
 	data, err := readSource(filename, src);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	var p parser;
@@ -75,7 +75,7 @@ func ParseExpr(filename string, src interface{}) (ast.Expr, os.Error) {
 func ParseStmtList(filename string, src interface{}) ([]ast.Stmt, os.Error) {
 	data, err := readSource(filename, src);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	var p parser;
@@ -92,7 +92,7 @@ func ParseStmtList(filename string, src interface{}) ([]ast.Stmt, os.Error) {
 func ParseDeclList(filename string, src interface{}) ([]ast.Decl, os.Error) {
 	data, err := readSource(filename, src);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	var p parser;
@@ -122,7 +122,7 @@ func ParseDeclList(filename string, src interface{}) ([]ast.Decl, os.Error) {
 func ParseFile(filename string, src interface{}, mode uint) (*ast.File, os.Error) {
 	data, err := readSource(filename, src);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	var p parser;
@@ -140,16 +140,16 @@ func ParseFile(filename string, src interface{}, mode uint) (*ast.File, os.Error
 func ParsePkgFile(pkgname, filename string, mode uint) (*ast.File, os.Error) {
 	src, err := io.ReadFile(filename);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	if pkgname != "" {
 		prog, err := ParseFile(filename, src, PackageClauseOnly);
 		if err != nil {
-			return nil, err;
+			return nil, err
 		}
 		if prog.Name.Value != pkgname {
-			return nil, os.NewError(fmt.Sprintf("multiple packages found: %s, %s", prog.Name.Value, pkgname));
+			return nil, os.NewError(fmt.Sprintf("multiple packages found: %s, %s", prog.Name.Value, pkgname))
 		}
 	}
 
@@ -168,13 +168,13 @@ func ParsePkgFile(pkgname, filename string, mode uint) (*ast.File, os.Error) {
 func ParsePackage(path string, filter func(*os.Dir) bool, mode uint) (*ast.Package, os.Error) {
 	fd, err := os.Open(path, os.O_RDONLY, 0);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	defer fd.Close();
 
 	list, err := fd.Readdir(-1);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	name := "";
@@ -184,17 +184,17 @@ func ParsePackage(path string, filter func(*os.Dir) bool, mode uint) (*ast.Packa
 		if filter == nil || filter(entry) {
 			src, err := ParsePkgFile(name, pathutil.Join(path, entry.Name), mode);
 			if err != nil {
-				return nil, err;
+				return nil, err
 			}
 			files[entry.Name] = src;
 			if name == "" {
-				name = src.Name.Value;
+				name = src.Name.Value
 			}
 		}
 	}
 
 	if len(files) == 0 {
-		return nil, os.NewError(path + ": no package found");
+		return nil, os.NewError(path + ": no package found")
 	}
 
 	return &ast.Package{name, path, files}, nil;
diff --git a/src/pkg/go/parser/parser.go b/src/pkg/go/parser/parser.go
index 53fff192dc..5e0c7307b5 100644
--- a/src/pkg/go/parser/parser.go
+++ b/src/pkg/go/parser/parser.go
@@ -69,7 +69,7 @@ type parser struct {
 // scannerMode returns the scanner mode bits given the parser's mode bits.
 func scannerMode(mode uint) uint {
 	if mode & ParseComments != 0 {
-		return scanner.ScanComments;
+		return scanner.ScanComments
 	}
 	return 0;
 }
@@ -94,7 +94,7 @@ func (p *parser) printTrace(a ...) {
 	fmt.Printf("%5d:%3d: ", p.pos.Line, p.pos.Column);
 	i := 2 * p.indent;
 	for ; i > n; i -= n {
-		fmt.Print(dots);
+		fmt.Print(dots)
 	}
 	fmt.Print(dots[0:i]);
 	fmt.Println(a);
@@ -125,11 +125,11 @@ func (p *parser) next0() {
 		s := p.tok.String();
 		switch {
 		case p.tok.IsLiteral():
-			p.printTrace(s, string(p.lit));
+			p.printTrace(s, string(p.lit))
 		case p.tok.IsOperator(), p.tok.IsKeyword():
-			p.printTrace("\""+s+"\"");
+			p.printTrace("\""+s+"\"")
 		default:
-			p.printTrace(s);
+			p.printTrace(s)
 		}
 	}
 
@@ -146,7 +146,7 @@ func (p *parser) consumeComment() (comment *ast.Comment, endline int) {
 	if p.lit[1] == '*' {
 		for _, b := range p.lit {
 			if b == '\n' {
-				endline++;
+				endline++
 			}
 		}
 	}
@@ -175,15 +175,15 @@ func (p *parser) consumeCommentGroup() int {
 	// convert list
 	group := make([]*ast.Comment, list.Len());
 	for i := 0; i < list.Len(); i++ {
-		group[i] = list.At(i).(*ast.Comment);
+		group[i] = list.At(i).(*ast.Comment)
 	}
 
 	// add comment group to the comments list
 	g := &ast.CommentGroup{group, nil};
 	if p.lastComment != nil {
-		p.lastComment.Next = g;
+		p.lastComment.Next = g
 	} else {
-		p.comments = g;
+		p.comments = g
 	}
 	p.lastComment = g;
 
@@ -220,20 +220,20 @@ func (p *parser) next() {
 			if p.pos.Line != endline {
 				// The next token is on a different line, thus
 				// the last comment group is a line comment.
-				p.lineComment = p.lastComment;
+				p.lineComment = p.lastComment
 			}
 		}
 
 		// consume successor comments, if any
 		endline := -1;
 		for p.tok == token.COMMENT {
-			endline = p.consumeCommentGroup();
+			endline = p.consumeCommentGroup()
 		}
 
 		if endline >= 0 && endline+1 == p.pos.Line {
 			// The next token is following on the line immediately after the
 			// comment group, thus the last comment group is a lead comment.
-			p.leadComment = p.lastComment;
+			p.leadComment = p.lastComment
 		}
 	}
 }
@@ -246,7 +246,7 @@ func (p *parser) errorExpected(pos token.Position, msg string) {
 		// make the error message more specific
 		msg += ", found '" + p.tok.String() + "'";
 		if p.tok.IsLiteral() {
-			msg += " "+string(p.lit);
+			msg += " "+string(p.lit)
 		}
 	}
 	p.Error(pos, msg);
@@ -256,7 +256,7 @@ func (p *parser) errorExpected(pos token.Position, msg string) {
 func (p *parser) expect(tok token.Token) token.Position {
 	pos := p.pos;
 	if p.tok != tok {
-		p.errorExpected(pos, "'" + tok.String() + "'");
+		p.errorExpected(pos, "'" + tok.String() + "'")
 	}
 	p.next();	// make progress in any case
 	return pos;
@@ -278,14 +278,14 @@ func close(p *parser)	{ p.topScope = p.topScope.Outer }
 
 func (p *parser) declare(ident *ast.Ident) {
 	if !p.topScope.Declare(ident) {
-		p.Error(p.pos, "'" + ident.Value + "' declared already");
+		p.Error(p.pos, "'" + ident.Value + "' declared already")
 	}
 }
 
 
 func (p *parser) declareList(idents []*ast.Ident) {
 	for _, ident := range idents {
-		p.declare(ident);
+		p.declare(ident)
 	}
 }
 
@@ -306,7 +306,7 @@ func (p *parser) parseIdent() *ast.Ident {
 
 func (p *parser) parseIdentList() []*ast.Ident {
 	if p.trace {
-		defer un(trace(p, "IdentList"));
+		defer un(trace(p, "IdentList"))
 	}
 
 	list := vector.New(0);
@@ -319,7 +319,7 @@ func (p *parser) parseIdentList() []*ast.Ident {
 	// convert vector
 	idents := make([]*ast.Ident, list.Len());
 	for i := 0; i < list.Len(); i++ {
-		idents[i] = list.At(i).(*ast.Ident);
+		idents[i] = list.At(i).(*ast.Ident)
 	}
 
 	return idents;
@@ -328,7 +328,7 @@ func (p *parser) parseIdentList() []*ast.Ident {
 
 func (p *parser) parseExprList() []ast.Expr {
 	if p.trace {
-		defer un(trace(p, "ExpressionList"));
+		defer un(trace(p, "ExpressionList"))
 	}
 
 	list := vector.New(0);
@@ -341,7 +341,7 @@ func (p *parser) parseExprList() []ast.Expr {
 	// convert list
 	exprs := make([]ast.Expr, list.Len());
 	for i := 0; i < list.Len(); i++ {
-		exprs[i] = list.At(i).(ast.Expr);
+		exprs[i] = list.At(i).(ast.Expr)
 	}
 
 	return exprs;
@@ -353,7 +353,7 @@ func (p *parser) parseExprList() []ast.Expr {
 
 func (p *parser) parseType() ast.Expr {
 	if p.trace {
-		defer un(trace(p, "Type"));
+		defer un(trace(p, "Type"))
 	}
 
 	typ := p.tryType();
@@ -370,7 +370,7 @@ func (p *parser) parseType() ast.Expr {
 
 func (p *parser) parseQualifiedIdent() ast.Expr {
 	if p.trace {
-		defer un(trace(p, "QualifiedIdent"));
+		defer un(trace(p, "QualifiedIdent"))
 	}
 
 	var x ast.Expr = p.parseIdent();
@@ -386,7 +386,7 @@ func (p *parser) parseQualifiedIdent() ast.Expr {
 
 func (p *parser) parseTypeName() ast.Expr {
 	if p.trace {
-		defer un(trace(p, "TypeName"));
+		defer un(trace(p, "TypeName"))
 	}
 
 	return p.parseQualifiedIdent();
@@ -395,7 +395,7 @@ func (p *parser) parseTypeName() ast.Expr {
 
 func (p *parser) parseArrayType(ellipsisOk bool) ast.Expr {
 	if p.trace {
-		defer un(trace(p, "ArrayType"));
+		defer un(trace(p, "ArrayType"))
 	}
 
 	lbrack := p.expect(token.LBRACK);
@@ -404,7 +404,7 @@ func (p *parser) parseArrayType(ellipsisOk bool) ast.Expr {
 		len = &ast.Ellipsis{p.pos};
 		p.next();
 	} else if p.tok != token.RBRACK {
-		len = p.parseExpr();
+		len = p.parseExpr()
 	}
 	p.expect(token.RBRACK);
 	elt := p.parseType();
@@ -430,7 +430,7 @@ func (p *parser) makeIdentList(list *vector.Vector) []*ast.Ident {
 
 func (p *parser) parseFieldDecl() *ast.Field {
 	if p.trace {
-		defer un(trace(p, "FieldDecl"));
+		defer un(trace(p, "FieldDecl"))
 	}
 
 	doc := p.leadComment;
@@ -441,9 +441,9 @@ func (p *parser) parseFieldDecl() *ast.Field {
 		// TODO(gri): do not allow ()'s here
 		list.Push(p.parseType());
 		if p.tok == token.COMMA {
-			p.next();
+			p.next()
 		} else {
-			break;
+			break
 		}
 	}
 
@@ -453,19 +453,19 @@ func (p *parser) parseFieldDecl() *ast.Field {
 	// optional tag
 	var tag []*ast.BasicLit;
 	if p.tok == token.STRING {
-		tag = p.parseStringList(nil);
+		tag = p.parseStringList(nil)
 	}
 
 	// analyze case
 	var idents []*ast.Ident;
 	if typ != nil {
 		// IdentifierList Type
-		idents = p.makeIdentList(list);
+		idents = p.makeIdentList(list)
 	} else {
 		// Type (anonymous field)
 		if list.Len() == 1 {
 			// TODO(gri): check that this looks like a type
-			typ = list.At(0).(ast.Expr);
+			typ = list.At(0).(ast.Expr)
 		} else {
 			p.errorExpected(p.pos, "anonymous field");
 			typ = &ast.BadExpr{p.pos};
@@ -478,7 +478,7 @@ func (p *parser) parseFieldDecl() *ast.Field {
 
 func (p *parser) parseStructType() *ast.StructType {
 	if p.trace {
-		defer un(trace(p, "StructType"));
+		defer un(trace(p, "StructType"))
 	}
 
 	pos := p.expect(token.STRUCT);
@@ -487,7 +487,7 @@ func (p *parser) parseStructType() *ast.StructType {
 	for p.tok == token.IDENT || p.tok == token.MUL {
 		f := p.parseFieldDecl();
 		if p.tok != token.RBRACE {
-			p.expect(token.SEMICOLON);
+			p.expect(token.SEMICOLON)
 		}
 		f.Comment = p.lineComment;
 		list.Push(f);
@@ -498,7 +498,7 @@ func (p *parser) parseStructType() *ast.StructType {
 	// convert vector
 	fields := make([]*ast.Field, list.Len());
 	for i := list.Len() - 1; i >= 0; i-- {
-		fields[i] = list.At(i).(*ast.Field);
+		fields[i] = list.At(i).(*ast.Field)
 	}
 
 	return &ast.StructType{pos, lbrace, fields, rbrace, false};
@@ -507,7 +507,7 @@ func (p *parser) parseStructType() *ast.StructType {
 
 func (p *parser) parsePointerType() *ast.StarExpr {
 	if p.trace {
-		defer un(trace(p, "PointerType"));
+		defer un(trace(p, "PointerType"))
 	}
 
 	star := p.expect(token.MUL);
@@ -523,7 +523,7 @@ func (p *parser) tryParameterType(ellipsisOk bool) ast.Expr {
 		p.next();
 		if p.tok != token.RPAREN {
 			// "..." always must be at the very end of a parameter list
-			p.Error(pos, "expected type, found '...'");
+			p.Error(pos, "expected type, found '...'")
 		}
 		return &ast.Ellipsis{pos};
 	}
@@ -544,7 +544,7 @@ func (p *parser) parseParameterType(ellipsisOk bool) ast.Expr {
 
 func (p *parser) parseParameterDecl(ellipsisOk bool) (*vector.Vector, ast.Expr) {
 	if p.trace {
-		defer un(trace(p, "ParameterDecl"));
+		defer un(trace(p, "ParameterDecl"))
 	}
 
 	// a list of identifiers looks like a list of type names
@@ -553,9 +553,9 @@ func (p *parser) parseParameterDecl(ellipsisOk bool) (*vector.Vector, ast.Expr)
 		// TODO(gri): do not allow ()'s here
 		list.Push(p.parseParameterType(ellipsisOk));
 		if p.tok == token.COMMA {
-			p.next();
+			p.next()
 		} else {
-			break;
+			break
 		}
 	}
 
@@ -568,7 +568,7 @@ func (p *parser) parseParameterDecl(ellipsisOk bool) (*vector.Vector, ast.Expr)
 
 func (p *parser) parseParameterList(ellipsisOk bool) []*ast.Field {
 	if p.trace {
-		defer un(trace(p, "ParameterList"));
+		defer un(trace(p, "ParameterList"))
 	}
 
 	list, typ := p.parseParameterDecl(ellipsisOk);
@@ -589,14 +589,14 @@ func (p *parser) parseParameterList(ellipsisOk bool) []*ast.Field {
 		// Type { "," Type } (anonymous parameters)
 		// convert list of types into list of *Param
 		for i := 0; i < list.Len(); i++ {
-			list.Set(i, &ast.Field{Type: list.At(i).(ast.Expr)});
+			list.Set(i, &ast.Field{Type: list.At(i).(ast.Expr)})
 		}
 	}
 
 	// convert list
 	params := make([]*ast.Field, list.Len());
 	for i := 0; i < list.Len(); i++ {
-		params[i] = list.At(i).(*ast.Field);
+		params[i] = list.At(i).(*ast.Field)
 	}
 
 	return params;
@@ -605,13 +605,13 @@ func (p *parser) parseParameterList(ellipsisOk bool) []*ast.Field {
 
 func (p *parser) parseParameters(ellipsisOk bool) []*ast.Field {
 	if p.trace {
-		defer un(trace(p, "Parameters"));
+		defer un(trace(p, "Parameters"))
 	}
 
 	var params []*ast.Field;
 	p.expect(token.LPAREN);
 	if p.tok != token.RPAREN {
-		params = p.parseParameterList(ellipsisOk);
+		params = p.parseParameterList(ellipsisOk)
 	}
 	p.expect(token.RPAREN);
 
@@ -621,12 +621,12 @@ func (p *parser) parseParameters(ellipsisOk bool) []*ast.Field {
 
 func (p *parser) parseResult() []*ast.Field {
 	if p.trace {
-		defer un(trace(p, "Result"));
+		defer un(trace(p, "Result"))
 	}
 
 	var results []*ast.Field;
 	if p.tok == token.LPAREN {
-		results = p.parseParameters(false);
+		results = p.parseParameters(false)
 	} else if p.tok != token.FUNC {
 		typ := p.tryType();
 		if typ != nil {
@@ -641,7 +641,7 @@ func (p *parser) parseResult() []*ast.Field {
 
 func (p *parser) parseSignature() (params []*ast.Field, results []*ast.Field) {
 	if p.trace {
-		defer un(trace(p, "Signature"));
+		defer un(trace(p, "Signature"))
 	}
 
 	params = p.parseParameters(true);
@@ -653,7 +653,7 @@ func (p *parser) parseSignature() (params []*ast.Field, results []*ast.Field) {
 
 func (p *parser) parseFuncType() *ast.FuncType {
 	if p.trace {
-		defer un(trace(p, "FuncType"));
+		defer un(trace(p, "FuncType"))
 	}
 
 	pos := p.expect(token.FUNC);
@@ -665,7 +665,7 @@ func (p *parser) parseFuncType() *ast.FuncType {
 
 func (p *parser) parseMethodSpec() *ast.Field {
 	if p.trace {
-		defer un(trace(p, "MethodSpec"));
+		defer un(trace(p, "MethodSpec"))
 	}
 
 	doc := p.leadComment;
@@ -679,7 +679,7 @@ func (p *parser) parseMethodSpec() *ast.Field {
 		typ = &ast.FuncType{noPos, params, results};
 	} else {
 		// embedded interface
-		typ = x;
+		typ = x
 	}
 
 	return &ast.Field{doc, idents, typ, nil, nil};
@@ -688,7 +688,7 @@ func (p *parser) parseMethodSpec() *ast.Field {
 
 func (p *parser) parseInterfaceType() *ast.InterfaceType {
 	if p.trace {
-		defer un(trace(p, "InterfaceType"));
+		defer un(trace(p, "InterfaceType"))
 	}
 
 	pos := p.expect(token.INTERFACE);
@@ -697,7 +697,7 @@ func (p *parser) parseInterfaceType() *ast.InterfaceType {
 	for p.tok == token.IDENT {
 		m := p.parseMethodSpec();
 		if p.tok != token.RBRACE {
-			p.expect(token.SEMICOLON);
+			p.expect(token.SEMICOLON)
 		}
 		m.Comment = p.lineComment;
 		list.Push(m);
@@ -708,7 +708,7 @@ func (p *parser) parseInterfaceType() *ast.InterfaceType {
 	// convert vector
 	methods := make([]*ast.Field, list.Len());
 	for i := list.Len() - 1; i >= 0; i-- {
-		methods[i] = list.At(i).(*ast.Field);
+		methods[i] = list.At(i).(*ast.Field)
 	}
 
 	return &ast.InterfaceType{pos, lbrace, methods, rbrace, false};
@@ -717,7 +717,7 @@ func (p *parser) parseInterfaceType() *ast.InterfaceType {
 
 func (p *parser) parseMapType() *ast.MapType {
 	if p.trace {
-		defer un(trace(p, "MapType"));
+		defer un(trace(p, "MapType"))
 	}
 
 	pos := p.expect(token.MAP);
@@ -732,7 +732,7 @@ func (p *parser) parseMapType() *ast.MapType {
 
 func (p *parser) parseChanType() *ast.ChanType {
 	if p.trace {
-		defer un(trace(p, "ChanType"));
+		defer un(trace(p, "ChanType"))
 	}
 
 	pos := p.pos;
@@ -757,21 +757,21 @@ func (p *parser) parseChanType() *ast.ChanType {
 func (p *parser) tryRawType(ellipsisOk bool) ast.Expr {
 	switch p.tok {
 	case token.IDENT:
-		return p.parseTypeName();
+		return p.parseTypeName()
 	case token.LBRACK:
-		return p.parseArrayType(ellipsisOk);
+		return p.parseArrayType(ellipsisOk)
 	case token.STRUCT:
-		return p.parseStructType();
+		return p.parseStructType()
 	case token.MUL:
-		return p.parsePointerType();
+		return p.parsePointerType()
 	case token.FUNC:
-		return p.parseFuncType();
+		return p.parseFuncType()
 	case token.INTERFACE:
-		return p.parseInterfaceType();
+		return p.parseInterfaceType()
 	case token.MAP:
-		return p.parseMapType();
+		return p.parseMapType()
 	case token.CHAN, token.ARROW:
-		return p.parseChanType();
+		return p.parseChanType()
 	case token.LPAREN:
 		lparen := p.pos;
 		p.next();
@@ -794,7 +794,7 @@ func (p *parser) tryType() ast.Expr	{ return p.tryRawType(false) }
 func makeStmtList(list *vector.Vector) []ast.Stmt {
 	stats := make([]ast.Stmt, list.Len());
 	for i := 0; i < list.Len(); i++ {
-		stats[i] = list.At(i).(ast.Stmt);
+		stats[i] = list.At(i).(ast.Stmt)
 	}
 	return stats;
 }
@@ -802,7 +802,7 @@ func makeStmtList(list *vector.Vector) []ast.Stmt {
 
 func (p *parser) parseStmtList() []ast.Stmt {
 	if p.trace {
-		defer un(trace(p, "StatementList"));
+		defer un(trace(p, "StatementList"))
 	}
 
 	list := vector.New(0);
@@ -814,11 +814,11 @@ func (p *parser) parseStmtList() []ast.Stmt {
 		}
 		list.Push(p.parseStmt());
 		if p.tok == token.SEMICOLON {
-			p.next();
+			p.next()
 		} else if p.optSemi {
-			p.optSemi = false;	// "consume" optional semicolon
+			p.optSemi = false	// "consume" optional semicolon
 		} else {
-			expectSemi = true;
+			expectSemi = true
 		}
 	}
 
@@ -828,7 +828,7 @@ func (p *parser) parseStmtList() []ast.Stmt {
 
 func (p *parser) parseBlockStmt(idents []*ast.Ident) *ast.BlockStmt {
 	if p.trace {
-		defer un(trace(p, "BlockStmt"));
+		defer un(trace(p, "BlockStmt"))
 	}
 
 	defer close(openScope(p));
@@ -847,12 +847,12 @@ func (p *parser) parseBlockStmt(idents []*ast.Ident) *ast.BlockStmt {
 
 func (p *parser) parseStringList(x *ast.BasicLit) []*ast.BasicLit {
 	if p.trace {
-		defer un(trace(p, "StringList"));
+		defer un(trace(p, "StringList"))
 	}
 
 	list := vector.New(0);
 	if x != nil {
-		list.Push(x);
+		list.Push(x)
 	}
 
 	for p.tok == token.STRING {
@@ -863,7 +863,7 @@ func (p *parser) parseStringList(x *ast.BasicLit) []*ast.BasicLit {
 	// convert list
 	strings := make([]*ast.BasicLit, list.Len());
 	for i := 0; i < list.Len(); i++ {
-		strings[i] = list.At(i).(*ast.BasicLit);
+		strings[i] = list.At(i).(*ast.BasicLit)
 	}
 
 	return strings;
@@ -872,13 +872,13 @@ func (p *parser) parseStringList(x *ast.BasicLit) []*ast.BasicLit {
 
 func (p *parser) parseFuncTypeOrLit() ast.Expr {
 	if p.trace {
-		defer un(trace(p, "FuncTypeOrLit"));
+		defer un(trace(p, "FuncTypeOrLit"))
 	}
 
 	typ := p.parseFuncType();
 	if p.tok != token.LBRACE {
 		// function type only
-		return typ;
+		return typ
 	}
 
 	p.exprLev++;
@@ -895,18 +895,18 @@ func (p *parser) parseFuncTypeOrLit() ast.Expr {
 //
 func (p *parser) parseOperand() ast.Expr {
 	if p.trace {
-		defer un(trace(p, "Operand"));
+		defer un(trace(p, "Operand"))
 	}
 
 	switch p.tok {
 	case token.IDENT:
-		return p.parseIdent();
+		return p.parseIdent()
 
 	case token.INT, token.FLOAT, token.CHAR, token.STRING:
 		x := &ast.BasicLit{p.pos, p.tok, p.lit};
 		p.next();
 		if p.tok == token.STRING && p.tok == token.STRING {
-			return &ast.StringList{p.parseStringList(x)};
+			return &ast.StringList{p.parseStringList(x)}
 		}
 		return x;
 
@@ -920,12 +920,12 @@ func (p *parser) parseOperand() ast.Expr {
 		return &ast.ParenExpr{lparen, x, rparen};
 
 	case token.FUNC:
-		return p.parseFuncTypeOrLit();
+		return p.parseFuncTypeOrLit()
 
 	default:
 		t := p.tryRawType(true);	// could be type for composite literal or conversion
 		if t != nil {
-			return t;
+			return t
 		}
 	}
 
@@ -937,7 +937,7 @@ func (p *parser) parseOperand() ast.Expr {
 
 func (p *parser) parseSelectorOrTypeAssertion(x ast.Expr) ast.Expr {
 	if p.trace {
-		defer un(trace(p, "SelectorOrTypeAssertion"));
+		defer un(trace(p, "SelectorOrTypeAssertion"))
 	}
 
 	p.expect(token.PERIOD);
@@ -952,9 +952,9 @@ func (p *parser) parseSelectorOrTypeAssertion(x ast.Expr) ast.Expr {
 	var typ ast.Expr;
 	if p.tok == token.TYPE {
 		// type switch: typ == nil
-		p.next();
+		p.next()
 	} else {
-		typ = p.parseType();
+		typ = p.parseType()
 	}
 	p.expect(token.RPAREN);
 
@@ -964,7 +964,7 @@ func (p *parser) parseSelectorOrTypeAssertion(x ast.Expr) ast.Expr {
 
 func (p *parser) parseIndex(x ast.Expr) ast.Expr {
 	if p.trace {
-		defer un(trace(p, "Index"));
+		defer un(trace(p, "Index"))
 	}
 
 	p.expect(token.LBRACK);
@@ -984,13 +984,13 @@ func (p *parser) parseIndex(x ast.Expr) ast.Expr {
 
 func (p *parser) parseCallOrConversion(fun ast.Expr) *ast.CallExpr {
 	if p.trace {
-		defer un(trace(p, "CallOrConversion"));
+		defer un(trace(p, "CallOrConversion"))
 	}
 
 	lparen := p.expect(token.LPAREN);
 	var args []ast.Expr;
 	if p.tok != token.RPAREN {
-		args = p.parseExprList();
+		args = p.parseExprList()
 	}
 	rparen := p.expect(token.RPAREN);
 
@@ -1000,7 +1000,7 @@ func (p *parser) parseCallOrConversion(fun ast.Expr) *ast.CallExpr {
 
 func (p *parser) parseElement() ast.Expr {
 	if p.trace {
-		defer un(trace(p, "Element"));
+		defer un(trace(p, "Element"))
 	}
 
 	x := p.parseExpr();
@@ -1016,23 +1016,23 @@ func (p *parser) parseElement() ast.Expr {
 
 func (p *parser) parseElementList() []ast.Expr {
 	if p.trace {
-		defer un(trace(p, "ElementList"));
+		defer un(trace(p, "ElementList"))
 	}
 
 	list := vector.New(0);
 	for p.tok != token.RBRACE && p.tok != token.EOF {
 		list.Push(p.parseElement());
 		if p.tok == token.COMMA {
-			p.next();
+			p.next()
 		} else {
-			break;
+			break
 		}
 	}
 
 	// convert list
 	elts := make([]ast.Expr, list.Len());
 	for i := 0; i < list.Len(); i++ {
-		elts[i] = list.At(i).(ast.Expr);
+		elts[i] = list.At(i).(ast.Expr)
 	}
 
 	return elts;
@@ -1041,13 +1041,13 @@ func (p *parser) parseElementList() []ast.Expr {
 
 func (p *parser) parseCompositeLit(typ ast.Expr) ast.Expr {
 	if p.trace {
-		defer un(trace(p, "CompositeLit"));
+		defer un(trace(p, "CompositeLit"))
 	}
 
 	lbrace := p.expect(token.LBRACE);
 	var elts []ast.Expr;
 	if p.tok != token.RBRACE {
-		elts = p.parseElementList();
+		elts = p.parseElementList()
 	}
 	rbrace := p.expect(token.RBRACE);
 	return &ast.CompositeLit{typ, lbrace, elts, rbrace};
@@ -1103,11 +1103,11 @@ func isTypeName(x ast.Expr) bool {
 	case *ast.BadExpr:
 	case *ast.Ident:
 	case *ast.ParenExpr:
-		return isTypeName(t.X);	// TODO(gri): should (TypeName) be illegal?
+		return isTypeName(t.X)	// TODO(gri): should (TypeName) be illegal?
 	case *ast.SelectorExpr:
-		return isTypeName(t.X);
+		return isTypeName(t.X)
 	default:
-		return false;	// all other nodes are not type names
+		return false	// all other nodes are not type names
 	}
 	return true;
 }
@@ -1120,14 +1120,14 @@ func isCompositeLitType(x ast.Expr) bool {
 	case *ast.BadExpr:
 	case *ast.Ident:
 	case *ast.ParenExpr:
-		return isCompositeLitType(t.X);
+		return isCompositeLitType(t.X)
 	case *ast.SelectorExpr:
-		return isTypeName(t.X);
+		return isTypeName(t.X)
 	case *ast.ArrayType:
 	case *ast.StructType:
 	case *ast.MapType:
 	default:
-		return false;	// all other nodes are not legal composite literal types
+		return false	// all other nodes are not legal composite literal types
 	}
 	return true;
 }
@@ -1159,26 +1159,26 @@ func (p *parser) checkExprOrType(x ast.Expr) ast.Expr {
 
 func (p *parser) parsePrimaryExpr() ast.Expr {
 	if p.trace {
-		defer un(trace(p, "PrimaryExpr"));
+		defer un(trace(p, "PrimaryExpr"))
 	}
 
 	x := p.parseOperand();
 L:	for {
 		switch p.tok {
 		case token.PERIOD:
-			x = p.parseSelectorOrTypeAssertion(p.checkExpr(x));
+			x = p.parseSelectorOrTypeAssertion(p.checkExpr(x))
 		case token.LBRACK:
-			x = p.parseIndex(p.checkExpr(x));
+			x = p.parseIndex(p.checkExpr(x))
 		case token.LPAREN:
-			x = p.parseCallOrConversion(p.checkExprOrType(x));
+			x = p.parseCallOrConversion(p.checkExprOrType(x))
 		case token.LBRACE:
 			if isCompositeLitType(x) && (p.exprLev >= 0 || !isTypeName(x)) {
-				x = p.parseCompositeLit(x);
+				x = p.parseCompositeLit(x)
 			} else {
-				break L;
+				break L
 			}
 		default:
-			break L;
+			break L
 		}
 	}
 
@@ -1188,7 +1188,7 @@ L:	for {
 
 func (p *parser) parseUnaryExpr() ast.Expr {
 	if p.trace {
-		defer un(trace(p, "UnaryExpr"));
+		defer un(trace(p, "UnaryExpr"))
 	}
 
 	switch p.tok {
@@ -1212,7 +1212,7 @@ func (p *parser) parseUnaryExpr() ast.Expr {
 
 func (p *parser) parseBinaryExpr(prec1 int) ast.Expr {
 	if p.trace {
-		defer un(trace(p, "BinaryExpr"));
+		defer un(trace(p, "BinaryExpr"))
 	}
 
 	x := p.parseUnaryExpr();
@@ -1233,7 +1233,7 @@ func (p *parser) parseBinaryExpr(prec1 int) ast.Expr {
 //            should reject when a type/raw type is obviously not allowed
 func (p *parser) parseExpr() ast.Expr {
 	if p.trace {
-		defer un(trace(p, "Expression"));
+		defer un(trace(p, "Expression"))
 	}
 
 	return p.parseBinaryExpr(token.LowestPrec + 1);
@@ -1246,7 +1246,7 @@ func (p *parser) parseExpr() ast.Expr {
 
 func (p *parser) parseSimpleStmt(labelOk bool) ast.Stmt {
 	if p.trace {
-		defer un(trace(p, "SimpleStmt"));
+		defer un(trace(p, "SimpleStmt"))
 	}
 
 	x := p.parseExprList();
@@ -1257,7 +1257,7 @@ func (p *parser) parseSimpleStmt(labelOk bool) ast.Stmt {
 		p.next();
 		if labelOk && len(x) == 1 {
 			if label, isIdent := x[0].(*ast.Ident); isIdent {
-				return &ast.LabeledStmt{label, p.parseStmt()};
+				return &ast.LabeledStmt{label, p.parseStmt()}
 			}
 		}
 		p.Error(x[0].Pos(), "illegal label declaration");
@@ -1273,13 +1273,13 @@ func (p *parser) parseSimpleStmt(labelOk bool) ast.Stmt {
 		p.next();
 		y := p.parseExprList();
 		if len(x) > 1 && len(y) > 1 && len(x) != len(y) {
-			p.Error(x[0].Pos(), "arity of lhs doesn't match rhs");
+			p.Error(x[0].Pos(), "arity of lhs doesn't match rhs")
 		}
 		return &ast.AssignStmt{x, pos, tok, y};
 	}
 
 	if len(x) > 1 {
-		p.Error(x[0].Pos(), "only one expression allowed");
+		p.Error(x[0].Pos(), "only one expression allowed")
 		// continue with first expression
 	}
 
@@ -1298,7 +1298,7 @@ func (p *parser) parseSimpleStmt(labelOk bool) ast.Stmt {
 func (p *parser) parseCallExpr() *ast.CallExpr {
 	x := p.parseExpr();
 	if call, isCall := x.(*ast.CallExpr); isCall {
-		return call;
+		return call
 	}
 	p.errorExpected(x.Pos(), "function/method call");
 	return nil;
@@ -1307,13 +1307,13 @@ func (p *parser) parseCallExpr() *ast.CallExpr {
 
 func (p *parser) parseGoStmt() ast.Stmt {
 	if p.trace {
-		defer un(trace(p, "GoStmt"));
+		defer un(trace(p, "GoStmt"))
 	}
 
 	pos := p.expect(token.GO);
 	call := p.parseCallExpr();
 	if call != nil {
-		return &ast.GoStmt{pos, call};
+		return &ast.GoStmt{pos, call}
 	}
 	return &ast.BadStmt{pos};
 }
@@ -1321,13 +1321,13 @@ func (p *parser) parseGoStmt() ast.Stmt {
 
 func (p *parser) parseDeferStmt() ast.Stmt {
 	if p.trace {
-		defer un(trace(p, "DeferStmt"));
+		defer un(trace(p, "DeferStmt"))
 	}
 
 	pos := p.expect(token.DEFER);
 	call := p.parseCallExpr();
 	if call != nil {
-		return &ast.DeferStmt{pos, call};
+		return &ast.DeferStmt{pos, call}
 	}
 	return &ast.BadStmt{pos};
 }
@@ -1335,14 +1335,14 @@ func (p *parser) parseDeferStmt() ast.Stmt {
 
 func (p *parser) parseReturnStmt() *ast.ReturnStmt {
 	if p.trace {
-		defer un(trace(p, "ReturnStmt"));
+		defer un(trace(p, "ReturnStmt"))
 	}
 
 	pos := p.pos;
 	p.expect(token.RETURN);
 	var x []ast.Expr;
 	if p.tok != token.SEMICOLON && p.tok != token.CASE && p.tok != token.DEFAULT && p.tok != token.RBRACE {
-		x = p.parseExprList();
+		x = p.parseExprList()
 	}
 
 	return &ast.ReturnStmt{pos, x};
@@ -1351,13 +1351,13 @@ func (p *parser) parseReturnStmt() *ast.ReturnStmt {
 
 func (p *parser) parseBranchStmt(tok token.Token) *ast.BranchStmt {
 	if p.trace {
-		defer un(trace(p, "BranchStmt"));
+		defer un(trace(p, "BranchStmt"))
 	}
 
 	s := &ast.BranchStmt{p.pos, tok, nil};
 	p.expect(tok);
 	if tok != token.FALLTHROUGH && p.tok == token.IDENT {
-		s.Label = p.parseIdent();
+		s.Label = p.parseIdent()
 	}
 
 	return s;
@@ -1366,10 +1366,10 @@ func (p *parser) parseBranchStmt(tok token.Token) *ast.BranchStmt {
 
 func (p *parser) makeExpr(s ast.Stmt) ast.Expr {
 	if s == nil {
-		return nil;
+		return nil
 	}
 	if es, isExpr := s.(*ast.ExprStmt); isExpr {
-		return p.checkExpr(es.X);
+		return p.checkExpr(es.X)
 	}
 	p.Error(s.Pos(), "expected condition, found simple statement");
 	return &ast.BadExpr{s.Pos()};
@@ -1382,22 +1382,22 @@ func (p *parser) parseControlClause(isForStmt bool) (s1, s2, s3 ast.Stmt) {
 		p.exprLev = -1;
 
 		if p.tok != token.SEMICOLON {
-			s1 = p.parseSimpleStmt(false);
+			s1 = p.parseSimpleStmt(false)
 		}
 		if p.tok == token.SEMICOLON {
 			p.next();
 			if p.tok != token.LBRACE && p.tok != token.SEMICOLON {
-				s2 = p.parseSimpleStmt(false);
+				s2 = p.parseSimpleStmt(false)
 			}
 			if isForStmt {
 				// for statements have a 3rd section
 				p.expect(token.SEMICOLON);
 				if p.tok != token.LBRACE {
-					s3 = p.parseSimpleStmt(false);
+					s3 = p.parseSimpleStmt(false)
 				}
 			}
 		} else {
-			s1, s2 = nil, s1;
+			s1, s2 = nil, s1
 		}
 
 		p.exprLev = prevLev;
@@ -1409,7 +1409,7 @@ func (p *parser) parseControlClause(isForStmt bool) (s1, s2, s3 ast.Stmt) {
 
 func (p *parser) parseIfStmt() *ast.IfStmt {
 	if p.trace {
-		defer un(trace(p, "IfStmt"));
+		defer un(trace(p, "IfStmt"))
 	}
 
 	// IfStmt block
@@ -1430,7 +1430,7 @@ func (p *parser) parseIfStmt() *ast.IfStmt {
 
 func (p *parser) parseCaseClause() *ast.CaseClause {
 	if p.trace {
-		defer un(trace(p, "CaseClause"));
+		defer un(trace(p, "CaseClause"))
 	}
 
 	// CaseClause block
@@ -1443,7 +1443,7 @@ func (p *parser) parseCaseClause() *ast.CaseClause {
 		p.next();
 		x = p.parseExprList();
 	} else {
-		p.expect(token.DEFAULT);
+		p.expect(token.DEFAULT)
 	}
 
 	colon := p.expect(token.COLON);
@@ -1455,7 +1455,7 @@ func (p *parser) parseCaseClause() *ast.CaseClause {
 
 func (p *parser) parseTypeList() []ast.Expr {
 	if p.trace {
-		defer un(trace(p, "TypeList"));
+		defer un(trace(p, "TypeList"))
 	}
 
 	list := vector.New(0);
@@ -1468,7 +1468,7 @@ func (p *parser) parseTypeList() []ast.Expr {
 	// convert list
 	exprs := make([]ast.Expr, list.Len());
 	for i := 0; i < list.Len(); i++ {
-		exprs[i] = list.At(i).(ast.Expr);
+		exprs[i] = list.At(i).(ast.Expr)
 	}
 
 	return exprs;
@@ -1477,7 +1477,7 @@ func (p *parser) parseTypeList() []ast.Expr {
 
 func (p *parser) parseTypeCaseClause() *ast.TypeCaseClause {
 	if p.trace {
-		defer un(trace(p, "TypeCaseClause"));
+		defer un(trace(p, "TypeCaseClause"))
 	}
 
 	// TypeCaseClause block
@@ -1490,7 +1490,7 @@ func (p *parser) parseTypeCaseClause() *ast.TypeCaseClause {
 		p.next();
 		types = p.parseTypeList();
 	} else {
-		p.expect(token.DEFAULT);
+		p.expect(token.DEFAULT)
 	}
 
 	colon := p.expect(token.COLON);
@@ -1502,11 +1502,11 @@ func (p *parser) parseTypeCaseClause() *ast.TypeCaseClause {
 
 func isExprSwitch(s ast.Stmt) bool {
 	if s == nil {
-		return true;
+		return true
 	}
 	if e, ok := s.(*ast.ExprStmt); ok {
 		if a, ok := e.X.(*ast.TypeAssertExpr); ok {
-			return a.Type != nil;	// regular type assertion
+			return a.Type != nil	// regular type assertion
 		}
 		return true;
 	}
@@ -1516,7 +1516,7 @@ func isExprSwitch(s ast.Stmt) bool {
 
 func (p *parser) parseSwitchStmt() ast.Stmt {
 	if p.trace {
-		defer un(trace(p, "SwitchStmt"));
+		defer un(trace(p, "SwitchStmt"))
 	}
 
 	// SwitchStmt block
@@ -1529,7 +1529,7 @@ func (p *parser) parseSwitchStmt() ast.Stmt {
 		lbrace := p.expect(token.LBRACE);
 		cases := vector.New(0);
 		for p.tok == token.CASE || p.tok == token.DEFAULT {
-			cases.Push(p.parseCaseClause());
+			cases.Push(p.parseCaseClause())
 		}
 		rbrace := p.expect(token.RBRACE);
 		p.optSemi = true;
@@ -1542,7 +1542,7 @@ func (p *parser) parseSwitchStmt() ast.Stmt {
 	lbrace := p.expect(token.LBRACE);
 	cases := vector.New(0);
 	for p.tok == token.CASE || p.tok == token.DEFAULT {
-		cases.Push(p.parseTypeCaseClause());
+		cases.Push(p.parseTypeCaseClause())
 	}
 	rbrace := p.expect(token.RBRACE);
 	p.optSemi = true;
@@ -1553,7 +1553,7 @@ func (p *parser) parseSwitchStmt() ast.Stmt {
 
 func (p *parser) parseCommClause() *ast.CommClause {
 	if p.trace {
-		defer un(trace(p, "CommClause"));
+		defer un(trace(p, "CommClause"))
 	}
 
 	// CommClause block
@@ -1567,7 +1567,7 @@ func (p *parser) parseCommClause() *ast.CommClause {
 		p.next();
 		if p.tok == token.ARROW {
 			// RecvExpr without assignment
-			rhs = p.parseExpr();
+			rhs = p.parseExpr()
 		} else {
 			// SendExpr or RecvExpr
 			rhs = p.parseExpr();
@@ -1577,15 +1577,15 @@ func (p *parser) parseCommClause() *ast.CommClause {
 				p.next();
 				lhs = rhs;
 				if p.tok == token.ARROW {
-					rhs = p.parseExpr();
+					rhs = p.parseExpr()
 				} else {
-					p.expect(token.ARROW);	// use expect() error handling
+					p.expect(token.ARROW)	// use expect() error handling
 				}
 			}
 			// else SendExpr
 		}
 	} else {
-		p.expect(token.DEFAULT);
+		p.expect(token.DEFAULT)
 	}
 
 	colon := p.expect(token.COLON);
@@ -1597,14 +1597,14 @@ func (p *parser) parseCommClause() *ast.CommClause {
 
 func (p *parser) parseSelectStmt() *ast.SelectStmt {
 	if p.trace {
-		defer un(trace(p, "SelectStmt"));
+		defer un(trace(p, "SelectStmt"))
 	}
 
 	pos := p.expect(token.SELECT);
 	lbrace := p.expect(token.LBRACE);
 	cases := vector.New(0);
 	for p.tok == token.CASE || p.tok == token.DEFAULT {
-		cases.Push(p.parseCommClause());
+		cases.Push(p.parseCommClause())
 	}
 	rbrace := p.expect(token.RBRACE);
 	p.optSemi = true;
@@ -1616,7 +1616,7 @@ func (p *parser) parseSelectStmt() *ast.SelectStmt {
 
 func (p *parser) parseForStmt() ast.Stmt {
 	if p.trace {
-		defer un(trace(p, "ForStmt"));
+		defer un(trace(p, "ForStmt"))
 	}
 
 	// ForStmt block
@@ -1639,7 +1639,7 @@ func (p *parser) parseForStmt() ast.Stmt {
 			value = as.Lhs[1];
 			fallthrough;
 		case 1:
-			key = as.Lhs[0];
+			key = as.Lhs[0]
 		default:
 			p.errorExpected(as.Lhs[0].Pos(), "1 or 2 expressions");
 			return &ast.BadStmt{pos};
@@ -1651,14 +1651,14 @@ func (p *parser) parseForStmt() ast.Stmt {
 		}
 		if rhs, isUnary := as.Rhs[0].(*ast.UnaryExpr); isUnary && rhs.Op == token.RANGE {
 			// rhs is range expression; check lhs
-			return &ast.RangeStmt{pos, key, value, as.TokPos, as.Tok, rhs.X, body};
+			return &ast.RangeStmt{pos, key, value, as.TokPos, as.Tok, rhs.X, body}
 		} else {
 			p.errorExpected(s2.Pos(), "range clause");
 			return &ast.BadStmt{pos};
 		}
 	} else {
 		// regular for statement
-		return &ast.ForStmt{pos, s1, p.makeExpr(s2), s3, body};
+		return &ast.ForStmt{pos, s1, p.makeExpr(s2), s3, body}
 	}
 
 	panic();	// unreachable
@@ -1668,7 +1668,7 @@ func (p *parser) parseForStmt() ast.Stmt {
 
 func (p *parser) parseStmt() ast.Stmt {
 	if p.trace {
-		defer un(trace(p, "Statement"));
+		defer un(trace(p, "Statement"))
 	}
 
 	switch p.tok {
@@ -1680,28 +1680,28 @@ func (p *parser) parseStmt() ast.Stmt {
 		token.IDENT, token.INT, token.FLOAT, token.CHAR, token.STRING, token.FUNC, token.LPAREN,	// operand
 		token.LBRACK, token.STRUCT,	// composite type
 		token.MUL, token.AND, token.ARROW, token.ADD, token.SUB, token.XOR:	// unary operators
-		return p.parseSimpleStmt(true);
+		return p.parseSimpleStmt(true)
 	case token.GO:
-		return p.parseGoStmt();
+		return p.parseGoStmt()
 	case token.DEFER:
-		return p.parseDeferStmt();
+		return p.parseDeferStmt()
 	case token.RETURN:
-		return p.parseReturnStmt();
+		return p.parseReturnStmt()
 	case token.BREAK, token.CONTINUE, token.GOTO, token.FALLTHROUGH:
-		return p.parseBranchStmt(p.tok);
+		return p.parseBranchStmt(p.tok)
 	case token.LBRACE:
-		return p.parseBlockStmt(nil);
+		return p.parseBlockStmt(nil)
 	case token.IF:
-		return p.parseIfStmt();
+		return p.parseIfStmt()
 	case token.SWITCH:
-		return p.parseSwitchStmt();
+		return p.parseSwitchStmt()
 	case token.SELECT:
-		return p.parseSelectStmt();
+		return p.parseSelectStmt()
 	case token.FOR:
-		return p.parseForStmt();
+		return p.parseForStmt()
 	case token.SEMICOLON, token.RBRACE:
 		// don't consume the ";", it is the separator following the empty statement
-		return &ast.EmptyStmt{p.pos};
+		return &ast.EmptyStmt{p.pos}
 	}
 
 	// no statement found
@@ -1731,7 +1731,7 @@ func (p *parser) parseComment(getSemi bool) (comment *ast.CommentGroup, gotSemi
 
 func parseImportSpec(p *parser, doc *ast.CommentGroup, getSemi bool) (spec ast.Spec, gotSemi bool) {
 	if p.trace {
-		defer un(trace(p, "ImportSpec"));
+		defer un(trace(p, "ImportSpec"))
 	}
 
 	var ident *ast.Ident;
@@ -1739,14 +1739,14 @@ func parseImportSpec(p *parser, doc *ast.CommentGroup, getSemi bool) (spec ast.S
 		ident = &ast.Ident{p.pos, "."};
 		p.next();
 	} else if p.tok == token.IDENT {
-		ident = p.parseIdent();
+		ident = p.parseIdent()
 	}
 
 	var path []*ast.BasicLit;
 	if p.tok == token.STRING {
-		path = p.parseStringList(nil);
+		path = p.parseStringList(nil)
 	} else {
-		p.expect(token.STRING);	// use expect() error handling
+		p.expect(token.STRING)	// use expect() error handling
 	}
 
 	comment, gotSemi := p.parseComment(getSemi);
@@ -1757,7 +1757,7 @@ func parseImportSpec(p *parser, doc *ast.CommentGroup, getSemi bool) (spec ast.S
 
 func parseConstSpec(p *parser, doc *ast.CommentGroup, getSemi bool) (spec ast.Spec, gotSemi bool) {
 	if p.trace {
-		defer un(trace(p, "ConstSpec"));
+		defer un(trace(p, "ConstSpec"))
 	}
 
 	idents := p.parseIdentList();
@@ -1775,7 +1775,7 @@ func parseConstSpec(p *parser, doc *ast.CommentGroup, getSemi bool) (spec ast.Sp
 
 func parseTypeSpec(p *parser, doc *ast.CommentGroup, getSemi bool) (spec ast.Spec, gotSemi bool) {
 	if p.trace {
-		defer un(trace(p, "TypeSpec"));
+		defer un(trace(p, "TypeSpec"))
 	}
 
 	ident := p.parseIdent();
@@ -1788,7 +1788,7 @@ func parseTypeSpec(p *parser, doc *ast.CommentGroup, getSemi bool) (spec ast.Spe
 
 func parseVarSpec(p *parser, doc *ast.CommentGroup, getSemi bool) (spec ast.Spec, gotSemi bool) {
 	if p.trace {
-		defer un(trace(p, "VarSpec"));
+		defer un(trace(p, "VarSpec"))
 	}
 
 	idents := p.parseIdentList();
@@ -1806,7 +1806,7 @@ func parseVarSpec(p *parser, doc *ast.CommentGroup, getSemi bool) (spec ast.Spec
 
 func (p *parser) parseGenDecl(keyword token.Token, f parseSpecFunction, getSemi bool) (decl *ast.GenDecl, gotSemi bool) {
 	if p.trace {
-		defer un(trace(p, keyword.String() + "Decl"));
+		defer un(trace(p, keyword.String() + "Decl"))
 	}
 
 	doc := p.leadComment;
@@ -1821,7 +1821,7 @@ func (p *parser) parseGenDecl(keyword token.Token, f parseSpecFunction, getSemi
 			spec, semi := f(p, doc, true);	// consume semicolon if any
 			list.Push(spec);
 			if !semi {
-				break;
+				break
 			}
 		}
 		rparen = p.expect(token.RPAREN);
@@ -1830,7 +1830,7 @@ func (p *parser) parseGenDecl(keyword token.Token, f parseSpecFunction, getSemi
 			p.next();
 			gotSemi = true;
 		} else {
-			p.optSemi = true;
+			p.optSemi = true
 		}
 	} else {
 		spec, semi := f(p, nil, getSemi);
@@ -1841,7 +1841,7 @@ func (p *parser) parseGenDecl(keyword token.Token, f parseSpecFunction, getSemi
 	// convert vector
 	specs := make([]ast.Spec, list.Len());
 	for i := 0; i < list.Len(); i++ {
-		specs[i] = list.At(i).(ast.Spec);
+		specs[i] = list.At(i).(ast.Spec)
 	}
 
 	return &ast.GenDecl{doc, pos, keyword, lparen, specs, rparen}, gotSemi;
@@ -1850,7 +1850,7 @@ func (p *parser) parseGenDecl(keyword token.Token, f parseSpecFunction, getSemi
 
 func (p *parser) parseReceiver() *ast.Field {
 	if p.trace {
-		defer un(trace(p, "Receiver"));
+		defer un(trace(p, "Receiver"))
 	}
 
 	pos := p.pos;
@@ -1867,10 +1867,10 @@ func (p *parser) parseReceiver() *ast.Field {
 	// recv type must be TypeName or *TypeName
 	base := recv.Type;
 	if ptr, isPtr := base.(*ast.StarExpr); isPtr {
-		base = ptr.X;
+		base = ptr.X
 	}
 	if !isTypeName(base) {
-		p.errorExpected(base.Pos(), "type name");
+		p.errorExpected(base.Pos(), "type name")
 	}
 
 	return recv;
@@ -1879,7 +1879,7 @@ func (p *parser) parseReceiver() *ast.Field {
 
 func (p *parser) parseFunctionDecl() *ast.FuncDecl {
 	if p.trace {
-		defer un(trace(p, "FunctionDecl"));
+		defer un(trace(p, "FunctionDecl"))
 	}
 
 	doc := p.leadComment;
@@ -1887,7 +1887,7 @@ func (p *parser) parseFunctionDecl() *ast.FuncDecl {
 
 	var recv *ast.Field;
 	if p.tok == token.LPAREN {
-		recv = p.parseReceiver();
+		recv = p.parseReceiver()
 	}
 
 	ident := p.parseIdent();
@@ -1895,7 +1895,7 @@ func (p *parser) parseFunctionDecl() *ast.FuncDecl {
 
 	var body *ast.BlockStmt;
 	if p.tok == token.LBRACE {
-		body = p.parseBlockStmt(nil);
+		body = p.parseBlockStmt(nil)
 	}
 
 	return &ast.FuncDecl{doc, recv, ident, &ast.FuncType{pos, params, results}, body};
@@ -1904,19 +1904,19 @@ func (p *parser) parseFunctionDecl() *ast.FuncDecl {
 
 func (p *parser) parseDecl(getSemi bool) (decl ast.Decl, gotSemi bool) {
 	if p.trace {
-		defer un(trace(p, "Declaration"));
+		defer un(trace(p, "Declaration"))
 	}
 
 	var f parseSpecFunction;
 	switch p.tok {
 	case token.CONST:
-		f = parseConstSpec;
+		f = parseConstSpec
 
 	case token.TYPE:
-		f = parseTypeSpec;
+		f = parseTypeSpec
 
 	case token.VAR:
-		f = parseVarSpec;
+		f = parseVarSpec
 
 	case token.FUNC:
 		decl = p.parseFunctionDecl();
@@ -1938,7 +1938,7 @@ func (p *parser) parseDecl(getSemi bool) (decl ast.Decl, gotSemi bool) {
 
 func (p *parser) parseDeclList() []ast.Decl {
 	if p.trace {
-		defer un(trace(p, "DeclList"));
+		defer un(trace(p, "DeclList"))
 	}
 
 	list := vector.New(0);
@@ -1950,7 +1950,7 @@ func (p *parser) parseDeclList() []ast.Decl {
 	// convert vector
 	decls := make([]ast.Decl, list.Len());
 	for i := 0; i < list.Len(); i++ {
-		decls[i] = list.At(i).(ast.Decl);
+		decls[i] = list.At(i).(ast.Decl)
 	}
 
 	return decls;
@@ -1962,7 +1962,7 @@ func (p *parser) parseDeclList() []ast.Decl {
 
 func (p *parser) parseFile() *ast.File {
 	if p.trace {
-		defer un(trace(p, "File"));
+		defer un(trace(p, "File"))
 	}
 
 	// file block
@@ -1996,7 +1996,7 @@ func (p *parser) parseFile() *ast.File {
 		// convert declaration list
 		decls = make([]ast.Decl, list.Len());
 		for i := 0; i < list.Len(); i++ {
-			decls[i] = list.At(i).(ast.Decl);
+			decls[i] = list.At(i).(ast.Decl)
 		}
 	}
 
diff --git a/src/pkg/go/parser/parser_test.go b/src/pkg/go/parser/parser_test.go
index 257ef9a7fe..10a750c59e 100644
--- a/src/pkg/go/parser/parser_test.go
+++ b/src/pkg/go/parser/parser_test.go
@@ -22,7 +22,7 @@ func TestParseIllegalInputs(t *testing.T) {
 	for _, src := range illegalInputs {
 		_, err := ParseFile("", src, 0);
 		if err == nil {
-			t.Errorf("ParseFile(%v) should have failed", src);
+			t.Errorf("ParseFile(%v) should have failed", src)
 		}
 	}
 }
@@ -38,7 +38,7 @@ func TestParseValidPrograms(t *testing.T) {
 	for _, src := range validPrograms {
 		_, err := ParseFile("", src, 0);
 		if err != nil {
-			t.Errorf("ParseFile(%q): %v", src, err);
+			t.Errorf("ParseFile(%q): %v", src, err)
 		}
 	}
 }
@@ -54,7 +54,7 @@ func TestParse3(t *testing.T) {
 	for _, filename := range validFiles {
 		_, err := ParseFile(filename, nil, 0);
 		if err != nil {
-			t.Errorf("ParseFile(%s): %v", filename, err);
+			t.Errorf("ParseFile(%s): %v", filename, err)
 		}
 	}
 }
@@ -66,7 +66,7 @@ func nameFilter(filename string) bool {
 	case "interface.go":
 	case "parser_test.go":
 	default:
-		return false;
+		return false
 	}
 	return true;
 }
@@ -79,14 +79,14 @@ func TestParse4(t *testing.T) {
 	path := ".";
 	pkg, err := ParsePackage(path, dirFilter, 0);
 	if err != nil {
-		t.Fatalf("ParsePackage(%s): %v", path, err);
+		t.Fatalf("ParsePackage(%s): %v", path, err)
 	}
 	if pkg.Name != "parser" {
-		t.Errorf("incorrect package name: %s", pkg.Name);
+		t.Errorf("incorrect package name: %s", pkg.Name)
 	}
 	for filename, _ := range pkg.Files {
 		if !nameFilter(filename) {
-			t.Errorf("unexpected package file: %s", filename);
+			t.Errorf("unexpected package file: %s", filename)
 		}
 	}
 }
diff --git a/src/pkg/go/printer/nodes.go b/src/pkg/go/printer/nodes.go
index b89bb2b0c3..6397796903 100644
--- a/src/pkg/go/printer/nodes.go
+++ b/src/pkg/go/printer/nodes.go
@@ -19,7 +19,7 @@ import (
 // Disabled formatting - enable eventually and remove the flag.
 const (
 	compositeLitBlank	= false;
-	fewerSemis		= false;
+	fewerSemis		= true;
 	stringListMode		= exprListMode(0);	// previously: noIndent
 )
 
@@ -49,9 +49,9 @@ func (p *printer) linebreak(line, min, max int, ws whiteSpace, newSection bool)
 	n := line - p.pos.Line;
 	switch {
 	case n < min:
-		n = min;
+		n = min
 	case n > max:
-		n = max;
+		n = max
 	}
 	if n > 0 {
 		p.print(ws);
@@ -81,7 +81,7 @@ func (p *printer) commentList(list []*ast.Comment) {
 		p.print(c.Pos(), t);
 		if t[1] == '/' && i+1 < len(list) {
 			//-style comment which is not at the end; print a newline
-			p.print(newline);
+			p.print(newline)
 		}
 	}
 }
@@ -114,7 +114,7 @@ func (p *printer) identList(list []*ast.Ident, multiLine *bool) {
 	// convert into an expression list
 	xlist := make([]ast.Expr, len(list));
 	for i, x := range list {
-		xlist[i] = x;
+		xlist[i] = x
 	}
 	p.exprList(noPos, xlist, commaSep, multiLine);
 }
@@ -125,7 +125,7 @@ func (p *printer) stringList(list []*ast.BasicLit, multiLine *bool) {
 	// convert into an expression list
 	xlist := make([]ast.Expr, len(list));
 	for i, x := range list {
-		xlist[i] = x;
+		xlist[i] = x
 	}
 	p.exprList(noPos, xlist, stringListMode, multiLine);
 }
@@ -148,11 +148,11 @@ const (
 // lines.
 func (p *printer) exprList(prev token.Position, list []ast.Expr, mode exprListMode, multiLine *bool) {
 	if len(list) == 0 {
-		return;
+		return
 	}
 
 	if mode & blankStart != 0 {
-		p.print(blank);
+		p.print(blank)
 	}
 
 	// TODO(gri): endLine may be incorrect as it is really the beginning
@@ -166,14 +166,14 @@ func (p *printer) exprList(prev token.Position, list []ast.Expr, mode exprListMo
 		for i, x := range list {
 			if i > 0 {
 				if mode&commaSep != 0 {
-					p.print(token.COMMA);
+					p.print(token.COMMA)
 				}
 				p.print(blank);
 			}
 			p.expr(x, multiLine);
 		}
 		if mode&blankEnd != 0 {
-			p.print(blank);
+			p.print(blank)
 		}
 		return;
 	}
@@ -185,7 +185,7 @@ func (p *printer) exprList(prev token.Position, list []ast.Expr, mode exprListMo
 	// i.e., pretend that the first line is already indented
 	ws := ignore;
 	if mode&noIndent == 0 {
-		ws = indent;
+		ws = indent
 	}
 
 	if prev.IsValid() && prev.Line < line && p.linebreak(line, 1, 2, ws, true) {
@@ -198,7 +198,7 @@ func (p *printer) exprList(prev token.Position, list []ast.Expr, mode exprListMo
 		line = x.Pos().Line;
 		if i > 0 {
 			if mode&commaSep != 0 {
-				p.print(token.COMMA);
+				p.print(token.COMMA)
 			}
 			if prev < line {
 				if p.linebreak(line, 1, 2, ws, true) {
@@ -206,7 +206,7 @@ func (p *printer) exprList(prev token.Position, list []ast.Expr, mode exprListMo
 					*multiLine = true;
 				}
 			} else {
-				p.print(blank);
+				p.print(blank)
 			}
 		}
 		p.expr(x, multiLine);
@@ -216,19 +216,19 @@ func (p *printer) exprList(prev token.Position, list []ast.Expr, mode exprListMo
 		p.print(token.COMMA);
 		if ws == ignore && mode&noIndent == 0 {
 			// unindent if we indented
-			p.print(unindent);
+			p.print(unindent)
 		}
 		p.print(formfeed);	// terminating comma needs a line break to look good
 		return;
 	}
 
 	if mode&blankEnd != 0 {
-		p.print(blank);
+		p.print(blank)
 	}
 
 	if ws == ignore && mode&noIndent == 0 {
 		// unindent if we indented
-		p.print(unindent);
+		p.print(unindent)
 	}
 }
 
@@ -239,7 +239,7 @@ func (p *printer) parameters(list []*ast.Field, multiLine *bool) {
 	if len(list) > 0 {
 		for i, par := range list {
 			if i > 0 {
-				p.print(token.COMMA, blank);
+				p.print(token.COMMA, blank)
 			}
 			if len(par.Names) > 0 {
 				p.identList(par.Names, multiLine);
@@ -277,13 +277,13 @@ func (p *printer) signature(params, result []*ast.Field, multiLine *bool) (optSe
 func identListSize(list []*ast.Ident, maxSize int) (size int) {
 	for i, x := range list {
 		if i > 0 {
-			size += 2 // ", "
-			;
+			size += 2	// ", "
+
 
 		}
 		size += len(x.Value);
 		if size >= maxSize {
-			break;
+			break
 		}
 	}
 	return;
@@ -292,18 +292,18 @@ func identListSize(list []*ast.Ident, maxSize int) (size int) {
 
 func (p *printer) isOneLineFieldList(list []*ast.Field) bool {
 	if len(list) != 1 {
-		return false;	// allow only one field
+		return false	// allow only one field
 	}
 	f := list[0];
 	if f.Tag != nil || f.Comment != nil {
-		return false;	// don't allow tags or comments
+		return false	// don't allow tags or comments
 	}
 	// only name(s) and type
 	const maxSize = 30;	// adjust as appropriate, this is an approximate value
 	namesSize := identListSize(f.Names, maxSize);
 	if namesSize > 0 {
-		namesSize = 1 // blank between names and types
-		;
+		namesSize = 1	// blank between names and types
+
 
 	}
 	typeSize := p.nodeSize(f.Type, maxSize);
@@ -326,12 +326,12 @@ func (p *printer) fieldList(lbrace token.Position, list []*ast.Field, rbrace tok
 			f := list[0];
 			for i, x := range f.Names {
 				if i > 0 {
-					p.print(token.COMMA, blank);
+					p.print(token.COMMA, blank)
 				}
 				p.expr(x, ignoreMultiLine);
 			}
 			if len(f.Names) > 0 {
-				p.print(blank);
+				p.print(blank)
 			}
 			p.expr(f.Type, ignoreMultiLine);
 			p.print(blank, rbrace, token.RBRACE);
@@ -345,12 +345,12 @@ func (p *printer) fieldList(lbrace token.Position, list []*ast.Field, rbrace tok
 
 		sep := vtab;
 		if len(list) == 1 {
-			sep = blank;
+			sep = blank
 		}
 		var ml bool;
 		for i, f := range list {
 			if i > 0 {
-				p.linebreak(f.Pos().Line, 1, 2, ignore, ml);
+				p.linebreak(f.Pos().Line, 1, 2, ignore, ml)
 			}
 			ml = false;
 			extraTabs := 0;
@@ -368,7 +368,7 @@ func (p *printer) fieldList(lbrace token.Position, list []*ast.Field, rbrace tok
 			}
 			if f.Tag != nil {
 				if len(f.Names) > 0 && sep == vtab {
-					p.print(sep);
+					p.print(sep)
 				}
 				p.print(sep);
 				p.expr(&ast.StringList{f.Tag}, &ml);
@@ -377,14 +377,14 @@ func (p *printer) fieldList(lbrace token.Position, list []*ast.Field, rbrace tok
 			p.print(token.SEMICOLON);
 			if f.Comment != nil {
 				for ; extraTabs > 0; extraTabs-- {
-					p.print(vtab);
+					p.print(vtab)
 				}
 				p.lineComment(f.Comment);
 			}
 		}
 		if isIncomplete {
 			if len(list) > 0 {
-				p.print(formfeed);
+				p.print(formfeed)
 			}
 			// TODO(gri): this needs to be styled like normal comments
 			p.print("// contains unexported fields");
@@ -395,7 +395,7 @@ func (p *printer) fieldList(lbrace token.Position, list []*ast.Field, rbrace tok
 		var ml bool;
 		for i, f := range list {
 			if i > 0 {
-				p.linebreak(f.Pos().Line, 1, 2, ignore, ml);
+				p.linebreak(f.Pos().Line, 1, 2, ignore, ml)
 			}
 			ml = false;
 			p.leadComment(f.Doc);
@@ -405,14 +405,14 @@ func (p *printer) fieldList(lbrace token.Position, list []*ast.Field, rbrace tok
 				p.signature(ftyp.Params, ftyp.Results, &ml);
 			} else {
 				// embedded interface
-				p.expr(f.Type, &ml);
+				p.expr(f.Type, &ml)
 			}
 			p.print(token.SEMICOLON);
 			p.lineComment(f.Comment);
 		}
 		if isIncomplete {
 			if len(list) > 0 {
-				p.print(formfeed);
+				p.print(formfeed)
 			}
 			// TODO(gri): this needs to be styled like normal comments
 			p.print("// contains unexported methods");
@@ -439,20 +439,20 @@ func needsBlanks(expr ast.Expr) bool {
 	switch x := expr.(type) {
 	case *ast.Ident:
 		// "long" identifiers look better with blanks around them
-		return len(x.Value) > 8;
+		return len(x.Value) > 8
 	case *ast.BasicLit:
 		// "long" literals look better with blanks around them
-		return len(x.Value) > 8;
+		return len(x.Value) > 8
 	case *ast.ParenExpr:
 		// parenthesized expressions don't need blanks around them
-		return false;
+		return false
 	case *ast.IndexExpr:
 		// index expressions don't need blanks if the indexed expressions are simple
-		return needsBlanks(x.X);
+		return needsBlanks(x.X)
 	case *ast.CallExpr:
 		// call expressions need blanks if they have more than one
 		// argument or if the function expression needs blanks
-		return len(x.Args) > 1 || needsBlanks(x.Fun);
+		return len(x.Args) > 1 || needsBlanks(x.Fun)
 	}
 	return true;
 }
@@ -487,16 +487,16 @@ func (p *printer) binaryExpr(x *ast.BinaryExpr, prec1 int, multiLine *bool) {
 			prev := line;
 			line = x.Y.Pos().Line;
 			if needsBlanks(x.Y) || prev != line {
-				printBlanks = true;
+				printBlanks = true
 			}
 		} else {
-			break;
+			break
 		}
 	}
 	prev := line;
 	line = x.X.Pos().Line;
 	if needsBlanks(x.X) || prev != line {
-		printBlanks = true;
+		printBlanks = true
 	}
 
 	// Print collected operations left-to-right, with blanks if necessary.
@@ -516,18 +516,18 @@ func (p *printer) binaryExpr(x *ast.BinaryExpr, prec1 int, multiLine *bool) {
 					*multiLine = true;
 				}
 			} else {
-				p.print(blank, x.OpPos, x.Op, blank);
+				p.print(blank, x.OpPos, x.Op, blank)
 			}
 		} else {
 			if prev != line {
-				panic("internal error");
+				panic("internal error")
 			}
 			p.print(x.OpPos, x.Op);
 		}
 		p.expr1(x.Y, prec, 0, multiLine);
 	}
 	if ws == ignore {
-		p.print(unindent);
+		p.print(unindent)
 	}
 }
 
@@ -539,13 +539,13 @@ func (p *printer) expr1(expr ast.Expr, prec1 int, ctxt exprContext, multiLine *b
 
 	switch x := expr.(type) {
 	case *ast.BadExpr:
-		p.print("BadExpr");
+		p.print("BadExpr")
 
 	case *ast.Ident:
-		p.print(x);
+		p.print(x)
 
 	case *ast.BinaryExpr:
-		p.binaryExpr(x, prec1, multiLine);
+		p.binaryExpr(x, prec1, multiLine)
 
 	case *ast.KeyValueExpr:
 		p.expr(x.Key, multiLine);
@@ -567,16 +567,16 @@ func (p *printer) expr1(expr ast.Expr, prec1 int, ctxt exprContext, multiLine *b
 			// no parenthesis needed
 			p.print(x.Op);
 			if x.Op == token.RANGE {
-				p.print(blank);
+				p.print(blank)
 			}
 			p.expr1(x.X, prec, 0, multiLine);
 		}
 
 	case *ast.BasicLit:
-		p.print(x);
+		p.print(x)
 
 	case *ast.StringList:
-		p.stringList(x.Strings, multiLine);
+		p.stringList(x.Strings, multiLine)
 
 	case *ast.FuncLit:
 		p.expr(x.Type, multiLine);
@@ -596,9 +596,9 @@ func (p *printer) expr1(expr ast.Expr, prec1 int, ctxt exprContext, multiLine *b
 		p.expr1(x.X, token.HighestPrec, 0, multiLine);
 		p.print(token.PERIOD, token.LPAREN);
 		if x.Type != nil {
-			p.expr(x.Type, multiLine);
+			p.expr(x.Type, multiLine)
 		} else {
-			p.print(token.TYPE);
+			p.print(token.TYPE)
 		}
 		p.print(token.RPAREN);
 
@@ -609,10 +609,10 @@ func (p *printer) expr1(expr ast.Expr, prec1 int, ctxt exprContext, multiLine *b
 		if x.End != nil {
 			if needsBlanks(x.Index) || needsBlanks(x.End) {
 				// blanks around ":"
-				p.print(blank, token.COLON, blank);
+				p.print(blank, token.COLON, blank)
 			} else {
 				// no blanks around ":"
-				p.print(token.COLON);
+				p.print(token.COLON)
 			}
 			p.expr(x.End, multiLine);
 		}
@@ -636,7 +636,7 @@ func (p *printer) expr1(expr ast.Expr, prec1 int, ctxt exprContext, multiLine *b
 				// TODO(gri): for now this decision is made by looking at the
 				//            source code - it may not be correct if the source
 				//            code was badly misformatted in the first place
-				p.print(blank);
+				p.print(blank)
 			}
 		}
 		p.print(x.Lbrace, token.LBRACE);
@@ -644,12 +644,12 @@ func (p *printer) expr1(expr ast.Expr, prec1 int, ctxt exprContext, multiLine *b
 		p.print(x.Rbrace, token.RBRACE);
 
 	case *ast.Ellipsis:
-		p.print(token.ELLIPSIS);
+		p.print(token.ELLIPSIS)
 
 	case *ast.ArrayType:
 		p.print(token.LBRACK);
 		if x.Len != nil {
-			p.expr(x.Len, multiLine);
+			p.expr(x.Len, multiLine)
 		}
 		p.print(token.RBRACK);
 		optSemi = p.expr(x.Elt, multiLine);
@@ -677,17 +677,17 @@ func (p *printer) expr1(expr ast.Expr, prec1 int, ctxt exprContext, multiLine *b
 	case *ast.ChanType:
 		switch x.Dir {
 		case ast.SEND | ast.RECV:
-			p.print(token.CHAN);
+			p.print(token.CHAN)
 		case ast.RECV:
-			p.print(token.ARROW, token.CHAN);
+			p.print(token.ARROW, token.CHAN)
 		case ast.SEND:
-			p.print(token.CHAN, token.ARROW);
+			p.print(token.CHAN, token.ARROW)
 		}
 		p.print(blank);
 		optSemi = p.expr(x.Value, multiLine);
 
 	default:
-		panic("unreachable");
+		panic("unreachable")
 	}
 
 	return;
@@ -697,7 +697,7 @@ func (p *printer) expr1(expr ast.Expr, prec1 int, ctxt exprContext, multiLine *b
 // Returns true if a separating semicolon is optional.
 // Sets multiLine to true if the expression spans multiple lines.
 func (p *printer) expr(x ast.Expr, multiLine *bool) (optSemi bool) {
-	return p.expr1(x, token.LowestPrec, 0, multiLine);
+	return p.expr1(x, token.LowestPrec, 0, multiLine)
 }
 
 
@@ -712,7 +712,7 @@ const maxStmtNewlines = 2	// maximum number of newlines between statements
 func (p *printer) stmtList(list []ast.Stmt, _indent int) {
 	// TODO(gri): fix _indent code
 	if _indent > 0 {
-		p.print(indent);
+		p.print(indent)
 	}
 	var multiLine bool;
 	for i, s := range list {
@@ -721,11 +721,11 @@ func (p *printer) stmtList(list []ast.Stmt, _indent int) {
 		p.linebreak(s.Pos().Line, 1, maxStmtNewlines, ignore, i == 0 || _indent == 0 || multiLine);
 		multiLine = false;
 		if !p.stmt(s, &multiLine) && (!fewerSemis || len(list) > 1) {
-			p.print(token.SEMICOLON);
+			p.print(token.SEMICOLON)
 		}
 	}
 	if _indent > 0 {
-		p.print(unindent);
+		p.print(unindent)
 	}
 }
 
@@ -744,7 +744,7 @@ func (p *printer) block(s *ast.BlockStmt, indent int) {
 //            need to be careful to keep them around type expressions.
 func stripParens(x ast.Expr) ast.Expr {
 	if px, hasParens := x.(*ast.ParenExpr); hasParens {
-		return stripParens(px.X);
+		return stripParens(px.X)
 	}
 	return x;
 }
@@ -763,7 +763,7 @@ func (p *printer) controlClause(isForStmt bool, init ast.Stmt, expr ast.Expr, po
 		// all semicolons required
 		// (they are not separators, print them explicitly)
 		if init != nil {
-			p.stmt(init, ignoreMultiLine);
+			p.stmt(init, ignoreMultiLine)
 		}
 		p.print(token.SEMICOLON, blank);
 		if expr != nil {
@@ -780,7 +780,7 @@ func (p *printer) controlClause(isForStmt bool, init ast.Stmt, expr ast.Expr, po
 		}
 	}
 	if needsBlank {
-		p.print(blank);
+		p.print(blank)
 	}
 }
 
@@ -792,7 +792,7 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 
 	switch s := stmt.(type) {
 	case *ast.BadStmt:
-		p.print("BadStmt");
+		p.print("BadStmt")
 
 	case *ast.DeclStmt:
 		p.decl(s.Decl, inStmtList, multiLine);
@@ -812,7 +812,7 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 		optSemi = p.stmt(s.Stmt, multiLine);
 
 	case *ast.ExprStmt:
-		p.expr(s.X, multiLine);
+		p.expr(s.X, multiLine)
 
 	case *ast.IncDecStmt:
 		p.expr(s.X, multiLine);
@@ -834,7 +834,7 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 	case *ast.ReturnStmt:
 		p.print(token.RETURN);
 		if s.Results != nil {
-			p.exprList(s.Pos(), s.Results, blankStart | commaSep, multiLine);
+			p.exprList(s.Pos(), s.Results, blankStart | commaSep, multiLine)
 		}
 
 	case *ast.BranchStmt:
@@ -859,7 +859,7 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 			p.print(blank, token.ELSE, blank);
 			switch s.Else.(type) {
 			case *ast.BlockStmt, *ast.IfStmt:
-				optSemi = p.stmt(s.Else, ignoreMultiLine);
+				optSemi = p.stmt(s.Else, ignoreMultiLine)
 			default:
 				p.print(token.LBRACE, indent, formfeed);
 				p.stmt(s.Else, ignoreMultiLine);
@@ -872,7 +872,7 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 			p.print(token.CASE);
 			p.exprList(s.Pos(), s.Values, blankStart | commaSep, multiLine);
 		} else {
-			p.print(token.DEFAULT);
+			p.print(token.DEFAULT)
 		}
 		p.print(s.Colon, token.COLON);
 		p.stmtList(s.Body, 1);
@@ -890,7 +890,7 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 			p.print(token.CASE);
 			p.exprList(s.Pos(), s.Types, blankStart | commaSep, multiLine);
 		} else {
-			p.print(token.DEFAULT);
+			p.print(token.DEFAULT)
 		}
 		p.print(s.Colon, token.COLON);
 		p.stmtList(s.Body, 1);
@@ -919,7 +919,7 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 			}
 			p.expr(s.Rhs, multiLine);
 		} else {
-			p.print(token.DEFAULT);
+			p.print(token.DEFAULT)
 		}
 		p.print(s.Colon, token.COLON);
 		p.stmtList(s.Body, 1);
@@ -953,7 +953,7 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 		optSemi = true;
 
 	default:
-		panic("unreachable");
+		panic("unreachable")
 	}
 
 	return;
@@ -1009,7 +1009,7 @@ func (p *printer) spec(spec ast.Spec, n int, context declContext, multiLine *boo
 		} else {
 			extraTabs = 2;
 			if s.Type != nil || s.Values != nil {
-				p.print(vtab);
+				p.print(vtab)
 			}
 			if s.Type != nil {
 				optSemi = p.expr(s.Type, multiLine);
@@ -1029,24 +1029,24 @@ func (p *printer) spec(spec ast.Spec, n int, context declContext, multiLine *boo
 		p.leadComment(s.Doc);
 		p.expr(s.Name, multiLine);
 		if n == 1 {
-			p.print(blank);
+			p.print(blank)
 		} else {
-			p.print(vtab);
+			p.print(vtab)
 		}
 		optSemi = p.expr(s.Type, multiLine);
 		comment = s.Comment;
 
 	default:
-		panic("unreachable");
+		panic("unreachable")
 	}
 
 	if context == inGroup || context == inStmtList && !optSemi {
-		p.print(token.SEMICOLON);
+		p.print(token.SEMICOLON)
 	}
 
 	if comment != nil {
 		for ; extraTabs > 0; extraTabs-- {
-			p.print(vtab);
+			p.print(vtab)
 		}
 		p.lineComment(comment);
 	}
@@ -1066,7 +1066,7 @@ func (p *printer) genDecl(d *ast.GenDecl, context declContext, multiLine *bool)
 			var ml bool;
 			for i, s := range d.Specs {
 				if i > 0 {
-					p.linebreak(s.Pos().Line, 1, 2, ignore, ml);
+					p.linebreak(s.Pos().Line, 1, 2, ignore, ml)
 				}
 				ml = false;
 				p.spec(s, len(d.Specs), inGroup, &ml);
@@ -1078,7 +1078,7 @@ func (p *printer) genDecl(d *ast.GenDecl, context declContext, multiLine *bool)
 
 	} else {
 		// single declaration
-		p.spec(d.Specs[0], 1, context, multiLine);
+		p.spec(d.Specs[0], 1, context, multiLine)
 	}
 }
 
@@ -1096,12 +1096,12 @@ func (p *printer) nodeSize(n ast.Node, maxSize int) (size int) {
 	cfg := Config{Mode: RawFormat};
 	var buf bytes.Buffer;
 	if _, err := cfg.Fprint(&buf, n); err != nil {
-		return;
+		return
 	}
 	if buf.Len() <= maxSize {
 		for _, ch := range buf.Bytes() {
 			if ch < ' ' {
-				return;
+				return
 			}
 		}
 		size = buf.Len();	// n fits
@@ -1115,9 +1115,9 @@ func (p *printer) isOneLineFunc(b *ast.BlockStmt, headerSize int) bool {
 	bodySize := 0;
 	switch {
 	case len(b.List) > 1 || p.commentBefore(b.Rbrace):
-		return false;	// too many statements or there is a comment - all bets are off
+		return false	// too many statements or there is a comment - all bets are off
 	case len(b.List) == 1:
-		bodySize = p.nodeSize(b.List[0], maxSize);
+		bodySize = p.nodeSize(b.List[0], maxSize)
 	}
 	// require both headers and overall size to be not "too large"
 	return headerSize <= maxSize/2 && headerSize + bodySize <= maxSize;
@@ -1127,20 +1127,20 @@ func (p *printer) isOneLineFunc(b *ast.BlockStmt, headerSize int) bool {
 // Sets multiLine to true if the function body spans multiple lines.
 func (p *printer) funcBody(b *ast.BlockStmt, headerSize int, isLit bool, multiLine *bool) {
 	if b == nil {
-		return;
+		return
 	}
 
 	if p.isOneLineFunc(b, headerSize) {
 		sep := vtab;
 		if isLit {
-			sep = blank;
+			sep = blank
 		}
 		if len(b.List) > 0 {
 			p.print(sep, b.Pos(), token.LBRACE, blank);
 			p.stmt(b.List[0], ignoreMultiLine);
 			p.print(blank, b.Rbrace, token.RBRACE);
 		} else {
-			p.print(sep, b.Pos(), token.LBRACE, b.Rbrace, token.RBRACE);
+			p.print(sep, b.Pos(), token.LBRACE, b.Rbrace, token.RBRACE)
 		}
 		return;
 	}
@@ -1156,7 +1156,7 @@ func (p *printer) funcBody(b *ast.BlockStmt, headerSize int, isLit bool, multiLi
 // the result is infinity (1<<30).
 func distance(from, to token.Position) int {
 	if from.IsValid() && to.IsValid() && from.Line == to.Line {
-		return to.Column - from.Column;
+		return to.Column - from.Column
 	}
 	return 1<<30;
 }
@@ -1186,13 +1186,13 @@ func (p *printer) funcDecl(d *ast.FuncDecl, multiLine *bool) {
 func (p *printer) decl(decl ast.Decl, context declContext, multiLine *bool) {
 	switch d := decl.(type) {
 	case *ast.BadDecl:
-		p.print(d.Pos(), "BadDecl");
+		p.print(d.Pos(), "BadDecl")
 	case *ast.GenDecl:
-		p.genDecl(d, context, multiLine);
+		p.genDecl(d, context, multiLine)
 	case *ast.FuncDecl:
-		p.funcDecl(d, multiLine);
+		p.funcDecl(d, multiLine)
 	default:
-		panic("unreachable");
+		panic("unreachable")
 	}
 }
 
@@ -1206,9 +1206,9 @@ func declToken(decl ast.Decl) (tok token.Token) {
 	tok = token.ILLEGAL;
 	switch d := decl.(type) {
 	case *ast.GenDecl:
-		tok = d.Tok;
+		tok = d.Tok
 	case *ast.FuncDecl:
-		tok = token.FUNC;
+		tok = token.FUNC
 	}
 	return;
 }
@@ -1228,7 +1228,7 @@ func (p *printer) file(src *ast.File) {
 			// print an empty line between top-level declarations
 			min := 1;
 			if prev != tok {
-				min = 2;
+				min = 2
 			}
 			p.linebreak(d.Pos().Line, min, maxDeclNewlines, ignore, false);
 			p.decl(d, atTop, ignoreMultiLine);
diff --git a/src/pkg/go/printer/printer.go b/src/pkg/go/printer/printer.go
index 9c68da227e..4c3511c615 100644
--- a/src/pkg/go/printer/printer.go
+++ b/src/pkg/go/printer/printer.go
@@ -137,7 +137,7 @@ func (p *printer) write(data []byte) {
 				// must not be discarded by the tabwriter
 				j := p.indent;
 				for ; j > len(htabs); j -= len(htabs) {
-					p.write0(&htabs);
+					p.write0(&htabs)
 				}
 				p.write0(htabs[0:j]);
 
@@ -158,15 +158,15 @@ func (p *printer) write(data []byte) {
 				var esc []byte;
 				switch b {
 				case '"':
-					esc = esc_quot;
+					esc = esc_quot
 				case '\'':
-					esc = esc_apos;
+					esc = esc_apos
 				case '&':
-					esc = esc_amp;
+					esc = esc_amp
 				case '<':
-					esc = esc_lt;
+					esc = esc_lt
 				case '>':
-					esc = esc_gt;
+					esc = esc_gt
 				}
 				p.write0(esc);
 
@@ -180,7 +180,7 @@ func (p *printer) write(data []byte) {
 			}
 
 		case tabwriter.Escape:
-			p.escape = !p.escape;
+			p.escape = !p.escape
 		}
 	}
 
@@ -197,7 +197,7 @@ func (p *printer) write(data []byte) {
 func (p *printer) writeNewlines(n int) {
 	if n > 0 {
 		if n > maxNewlines {
-			n = maxNewlines;
+			n = maxNewlines
 		}
 		p.write(newlines[0:n]);
 	}
@@ -207,7 +207,7 @@ func (p *printer) writeNewlines(n int) {
 func (p *printer) writeFormfeeds(n int) {
 	if n > 0 {
 		if n > maxNewlines {
-			n = maxNewlines;
+			n = maxNewlines
 		}
 		p.write(formfeeds[0:n]);
 	}
@@ -218,12 +218,12 @@ func (p *printer) writeTaggedItem(data []byte, tag HTMLTag) {
 	// write start tag, if any
 	// (no html-escaping and no p.pos update for tags - use write0)
 	if tag.Start != "" {
-		p.write0(strings.Bytes(tag.Start));
+		p.write0(strings.Bytes(tag.Start))
 	}
 	p.write(data);
 	// write end tag, if any
 	if tag.End != "" {
-		p.write0(strings.Bytes(tag.End));
+		p.write0(strings.Bytes(tag.End))
 	}
 }
 
@@ -239,7 +239,7 @@ func (p *printer) writeItem(pos token.Position, data []byte, tag HTMLTag) {
 	p.pos = pos;
 	if debug {
 		// do not update p.pos - use write0
-		p.write0(strings.Bytes(fmt.Sprintf("[%d:%d]", pos.Line, pos.Column)));
+		p.write0(strings.Bytes(fmt.Sprintf("[%d:%d]", pos.Line, pos.Column)))
 	}
 	if p.Mode & GenHTML != 0 {
 		// write line tag if on a new line
@@ -251,7 +251,7 @@ func (p *printer) writeItem(pos token.Position, data []byte, tag HTMLTag) {
 		}
 		p.writeTaggedItem(data, tag);
 	} else {
-		p.write(data);
+		p.write(data)
 	}
 	p.last = p.pos;
 }
@@ -269,7 +269,7 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, isFirst, isKeywor
 	if !p.last.IsValid() {
 		// there was no preceeding item and the comment is the
 		// first item to be printed - don't write any whitespace
-		return;
+		return
 	}
 
 	if pos.Line == p.last.Line {
@@ -291,7 +291,7 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, isFirst, isKeywor
 					continue;
 				case indent:
 					// apply pending indentation
-					continue;
+					continue
 				}
 				j = i;
 				break;
@@ -304,9 +304,9 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, isFirst, isKeywor
 				// next item is on the same line as the comment
 				// (which must be a /*-style comment): separate
 				// with a blank instead of a tab
-				p.write([]byte{' '});
+				p.write([]byte{' '})
 			} else {
-				p.write(htab);
+				p.write(htab)
 			}
 		}
 
@@ -323,7 +323,7 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, isFirst, isKeywor
 					continue;
 				case indent:
 					// apply pending indentation
-					continue;
+					continue
 				case unindent:
 					// if the next token is a keyword, apply the outdent
 					// if it appears that the comment is aligned with the
@@ -332,11 +332,11 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, isFirst, isKeywor
 					// comments before a case label where the comments
 					// apply to the next case instead of the current one)
 					if isKeyword && pos.Column == next.Column {
-						continue;
+						continue
 					}
 				case newline, formfeed:
 					// TODO(gri): may want to keep formfeed info in some cases
-					p.buffer[i] = ignore;
+					p.buffer[i] = ignore
 				}
 				j = i;
 				break;
@@ -359,7 +359,7 @@ func (p *printer) writeCommentLine(comment *ast.Comment, pos token.Position, lin
 	// apply styler, if any
 	var tag HTMLTag;
 	if p.Styler != nil {
-		line, tag = p.Styler.Comment(comment, line);
+		line, tag = p.Styler.Comment(comment, line)
 	}
 
 	p.writeItem(pos, line, tag);
@@ -376,7 +376,7 @@ func split(text []byte) [][]byte {
 	n := 1;
 	for _, c := range text {
 		if c == '\n' {
-			n++;
+			n++
 		}
 	}
 
@@ -400,7 +400,7 @@ func split(text []byte) [][]byte {
 func isBlank(s []byte) bool {
 	for _, b := range s {
 		if b > ' ' {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -410,7 +410,7 @@ func isBlank(s []byte) bool {
 func commonPrefix(a, b []byte) []byte {
 	i := 0;
 	for i < len(a) && i < len(b) && a[i] == b[i] && (a[i] <= ' ' || a[i] == '*') {
-		i++;
+		i++
 	}
 	return a[0:i];
 }
@@ -418,7 +418,7 @@ func commonPrefix(a, b []byte) []byte {
 
 func stripCommonPrefix(lines [][]byte) {
 	if len(lines) < 2 {
-		return;	// at most one line - nothing to do
+		return	// at most one line - nothing to do
 	}
 
 	// The heuristic in this function tries to handle a few
@@ -438,11 +438,11 @@ func stripCommonPrefix(lines [][]byte) {
 		case i == 0 || i == len(lines)-1:
 			// ignore
 		case isBlank(line):
-			lines[i] = nil;
+			lines[i] = nil
 		case prefix == nil:
-			prefix = commonPrefix(line, line);
+			prefix = commonPrefix(line, line)
 		default:
-			prefix = commonPrefix(prefix, line);
+			prefix = commonPrefix(prefix, line)
 		}
 	}
 
@@ -453,7 +453,7 @@ func stripCommonPrefix(lines [][]byte) {
 	if i := bytes.Index(prefix, []byte{'*'}); i >= 0 {
 		// Line of stars present.
 		if i > 0 && prefix[i-1] == ' ' {
-			i--;	// remove trailing blank from prefix so stars remain aligned
+			i--	// remove trailing blank from prefix so stars remain aligned
 		}
 		prefix = prefix[0:i];
 		lineOfStars = true;
@@ -474,10 +474,10 @@ func stripCommonPrefix(lines [][]byte) {
 			// in the first place
 			i := len(prefix);
 			for n := 0; n < 3 && i > 0 && prefix[i-1] == ' '; n++ {
-				i--;
+				i--
 			}
 			if i == len(prefix) && i > 0 && prefix[i-1] == '\t' {
-				i--;
+				i--
 			}
 			prefix = prefix[0:i];
 		} else {
@@ -490,7 +490,7 @@ func stripCommonPrefix(lines [][]byte) {
 			}
 			if n > 2 && suffix[2] == '\t' {
 				// assume the '\t' compensates for the /*
-				suffix = suffix[2:n];
+				suffix = suffix[2:n]
 			} else {
 				// otherwise assume two blanks
 				suffix[0], suffix[1] = ' ', ' ';
@@ -499,7 +499,7 @@ func stripCommonPrefix(lines [][]byte) {
 			// Shorten the computed common prefix by the length of
 			// suffix, if it is found as suffix of the prefix.
 			if bytes.HasSuffix(prefix, suffix) {
-				prefix = prefix[0 : len(prefix)-len(suffix)];
+				prefix = prefix[0 : len(prefix)-len(suffix)]
 			}
 		}
 	}
@@ -515,19 +515,19 @@ func stripCommonPrefix(lines [][]byte) {
 		var sep []byte;
 		if lineOfStars {
 			// insert an aligning blank
-			sep = []byte{' '};
+			sep = []byte{' '}
 		}
 		lines[len(lines)-1] = bytes.Join([][]byte{prefix, closing}, sep);
 	} else {
 		// last line contains more comment text - assume
 		// it is aligned like the other lines
-		prefix = commonPrefix(prefix, last);
+		prefix = commonPrefix(prefix, last)
 	}
 
 	// Remove the common prefix from all but the first and empty lines.
 	for i, line := range lines {
 		if i > 0 && len(line) != 0 {
-			lines[i] = line[len(prefix):len(line)];
+			lines[i] = line[len(prefix):len(line)]
 		}
 	}
 }
@@ -557,7 +557,7 @@ func (p *printer) writeComment(comment *ast.Comment) {
 			pos = p.pos;
 		}
 		if len(line) > 0 {
-			p.writeCommentLine(comment, pos, line);
+			p.writeCommentLine(comment, pos, line)
 		}
 	}
 }
@@ -573,15 +573,15 @@ func (p *printer) writeCommentSuffix(needsLinebreak bool) {
 		switch ch {
 		case blank, vtab:
 			// ignore trailing whitespace
-			p.buffer[i] = ignore;
+			p.buffer[i] = ignore
 		case indent, unindent:
 			// don't loose indentation information
 		case newline, formfeed:
 			// if we need a line break, keep exactly one
 			if needsLinebreak {
-				needsLinebreak = false;
+				needsLinebreak = false
 			} else {
-				p.buffer[i] = ignore;
+				p.buffer[i] = ignore
 			}
 		}
 	}
@@ -589,7 +589,7 @@ func (p *printer) writeCommentSuffix(needsLinebreak bool) {
 
 	// make sure we have a line break
 	if needsLinebreak {
-		p.write([]byte{'\n'});
+		p.write([]byte{'\n'})
 	}
 }
 
@@ -616,7 +616,7 @@ func (p *printer) intersperseComments(next token.Position, isKeyword bool) {
 	if last != nil && !needsLinebreak && last.Pos().Line == next.Line {
 		// the last comment is a /*-style comment and the next item
 		// follows on the same line: separate with an extra blank
-		p.write([]byte{' '});
+		p.write([]byte{' '})
 	}
 	p.writeCommentSuffix(needsLinebreak);
 }
@@ -631,13 +631,13 @@ func (p *printer) writeWhitespace(n int) {
 		case ignore:
 			// ignore!
 		case indent:
-			p.indent++;
+			p.indent++
 		case unindent:
 			p.indent--;
 			if p.indent < 0 {
 				// handle gracefully unless in debug mode
 				if debug {
-					panicln("negative indentation:", p.indent);
+					panicln("negative indentation:", p.indent)
 				}
 				p.indent = 0;
 			}
@@ -704,7 +704,7 @@ func (p *printer) print(args ...) {
 				// don't add ignore's to the buffer; they
 				// may screw up "correcting" unindents (see
 				// LabeledStmt)
-				break;
+				break
 			}
 			i := len(p.buffer);
 			if i == cap(p.buffer) {
@@ -719,22 +719,22 @@ func (p *printer) print(args ...) {
 		case []byte:
 			// TODO(gri): remove this case once commentList
 			//            handles comments correctly
-			data = x;
+			data = x
 		case string:
 			// TODO(gri): remove this case once fieldList
 			//            handles comments correctly
-			data = strings.Bytes(x);
+			data = strings.Bytes(x)
 		case *ast.Ident:
 			if p.Styler != nil {
-				data, tag = p.Styler.Ident(x);
+				data, tag = p.Styler.Ident(x)
 			} else {
-				data = strings.Bytes(x.Value);
+				data = strings.Bytes(x.Value)
 			}
 		case *ast.BasicLit:
 			if p.Styler != nil {
-				data, tag = p.Styler.BasicLit(x);
+				data, tag = p.Styler.BasicLit(x)
 			} else {
-				data = x.Value;
+				data = x.Value
 			}
 			// escape all literals so they pass through unchanged
 			// (note that valid Go programs cannot contain esc ('\xff')
@@ -743,17 +743,17 @@ func (p *printer) print(args ...) {
 			data = strings.Bytes("\xff"+string(data)+"\xff");
 		case token.Token:
 			if p.Styler != nil {
-				data, tag = p.Styler.Token(x);
+				data, tag = p.Styler.Token(x)
 			} else {
-				data = strings.Bytes(x.String());
+				data = strings.Bytes(x.String())
 			}
 			isKeyword = x.IsKeyword();
 		case token.Position:
 			if x.IsValid() {
-				next = x;	// accurate position of next item
+				next = x	// accurate position of next item
 			}
 		default:
-			panicln("print: unsupported argument type", f.Type().String());
+			panicln("print: unsupported argument type", f.Type().String())
 		}
 		p.pos = next;
 
@@ -775,7 +775,7 @@ func (p *printer) print(args ...) {
 // before the next position in the source code.
 //
 func (p *printer) commentBefore(next token.Position) bool {
-	return p.comment != nil && p.comment.List[0].Pos().Offset < next.Offset;
+	return p.comment != nil && p.comment.List[0].Pos().Offset < next.Offset
 }
 
 
@@ -785,7 +785,7 @@ func (p *printer) commentBefore(next token.Position) bool {
 func (p *printer) flush(next token.Position, isKeyword bool) {
 	// if there are comments before the next item, intersperse them
 	if p.commentBefore(next) {
-		p.intersperseComments(next, isKeyword);
+		p.intersperseComments(next, isKeyword)
 	}
 	// write any leftover whitespace
 	p.writeWhitespace(len(p.buffer));
@@ -817,7 +817,7 @@ func (p *trimmer) Write(data []byte) (n int, err os.Error) {
 	// m >= 0: data[m:n] unwritten and no whitespace
 	m := 0;
 	if p.buf.Len() > 0 {
-		m = -1;
+		m = -1
 	}
 
 	var b byte;
@@ -827,7 +827,7 @@ func (p *trimmer) Write(data []byte) (n int, err os.Error) {
 			// write any pending whitespace
 			if m < 0 {
 				if _, err = p.output.Write(p.buf.Bytes()); err != nil {
-					return;
+					return
 				}
 				p.buf.Reset();
 				m = n;
@@ -841,13 +841,13 @@ func (p *trimmer) Write(data []byte) (n int, err os.Error) {
 			// write any pending (non-whitespace) data
 			if m >= 0 {
 				if _, err = p.output.Write(data[m:n]); err != nil {
-					return;
+					return
 				}
 				m = -1;
 			}
 			// collect whitespace but discard tabrwiter.Escapes.
 			if b != tabwriter.Escape {
-				p.buf.WriteByte(b);	// WriteByte returns no errors
+				p.buf.WriteByte(b)	// WriteByte returns no errors
 			}
 
 		case '\f', '\n':
@@ -856,13 +856,13 @@ func (p *trimmer) Write(data []byte) (n int, err os.Error) {
 			// write any pending (non-whitespace) data
 			if m >= 0 {
 				if _, err = p.output.Write(data[m:n]); err != nil {
-					return;
+					return
 				}
 				m = -1;
 			}
 			// convert formfeed into newline
 			if _, err = p.output.Write(newlines[0:1]); err != nil {
-				return;
+				return
 			}
 		}
 	}
@@ -871,7 +871,7 @@ func (p *trimmer) Write(data []byte) (n int, err os.Error) {
 	// write any pending non-whitespace
 	if m >= 0 {
 		if _, err = p.output.Write(data[m:n]); err != nil {
-			return;
+			return
 		}
 	}
 
@@ -933,11 +933,11 @@ func (cfg *Config) Fprint(output io.Writer, node interface{}) (int, os.Error) {
 	if cfg.Mode & RawFormat == 0 {
 		padchar := byte('\t');
 		if cfg.Mode & UseSpaces != 0 {
-			padchar = ' ';
+			padchar = ' '
 		}
 		twmode := tabwriter.DiscardEmptyColumns;
 		if cfg.Mode & GenHTML != 0 {
-			twmode |= tabwriter.FilterHTML;
+			twmode |= tabwriter.FilterHTML
 		}
 		tw = tabwriter.NewWriter(output, cfg.Tabwidth, 1, padchar, twmode);
 		output = tw;
@@ -949,11 +949,11 @@ func (cfg *Config) Fprint(output io.Writer, node interface{}) (int, os.Error) {
 	go func() {
 		switch n := node.(type) {
 		case ast.Expr:
-			p.expr(n, ignoreMultiLine);
+			p.expr(n, ignoreMultiLine)
 		case ast.Stmt:
-			p.stmt(n, ignoreMultiLine);
+			p.stmt(n, ignoreMultiLine)
 		case ast.Decl:
-			p.decl(n, atTop, ignoreMultiLine);
+			p.decl(n, atTop, ignoreMultiLine)
 		case *ast.File:
 			p.comment = n.Comments;
 			p.file(n);
@@ -968,7 +968,7 @@ func (cfg *Config) Fprint(output io.Writer, node interface{}) (int, os.Error) {
 
 	// flush tabwriter, if any
 	if tw != nil {
-		tw.Flush();	// ignore errors
+		tw.Flush()	// ignore errors
 	}
 
 	return p.written, err;
diff --git a/src/pkg/go/printer/printer_test.go b/src/pkg/go/printer/printer_test.go
index ebb1705501..6cafc58209 100644
--- a/src/pkg/go/printer/printer_test.go
+++ b/src/pkg/go/printer/printer_test.go
@@ -27,7 +27,7 @@ var update = flag.Bool("update", false, "update golden files")
 func lineString(text []byte, i int) string {
 	i0 := i;
 	for i < len(text) && text[i] != '\n' {
-		i++;
+		i++
 	}
 	return string(text[i0:i]);
 }
@@ -58,20 +58,20 @@ func check(t *testing.T, source, golden string, mode checkMode) {
 	// determine printer configuration
 	cfg := Config{Tabwidth: tabwidth};
 	if mode & rawFormat != 0 {
-		cfg.Mode |= RawFormat;
+		cfg.Mode |= RawFormat
 	}
 
 	// format source
 	var buf bytes.Buffer;
 	if _, err := cfg.Fprint(&buf, prog); err != nil {
-		t.Error(err);
+		t.Error(err)
 	}
 	res := buf.Bytes();
 
 	// update golden files if necessary
 	if *update {
 		if err := io.WriteFile(golden, res, 0644); err != nil {
-			t.Error(err);
+			t.Error(err)
 		}
 		return;
 	}
@@ -85,7 +85,7 @@ func check(t *testing.T, source, golden string, mode checkMode) {
 
 	// compare lengths
 	if len(res) != len(gld) {
-		t.Errorf("len = %d, expected %d (= len(%s))", len(res), len(gld), golden);
+		t.Errorf("len = %d, expected %d (= len(%s))", len(res), len(gld), golden)
 	}
 
 	// compare contents
diff --git a/src/pkg/go/printer/testdata/comments.golden b/src/pkg/go/printer/testdata/comments.golden
index cb28274765..04f87a6c46 100644
--- a/src/pkg/go/printer/testdata/comments.golden
+++ b/src/pkg/go/printer/testdata/comments.golden
@@ -98,7 +98,7 @@ func _() {
 
 func abs(x int) int {
 	if x < 0 {	// the tab printed before this comment's // must not affect the remaining lines
-		return -x;	// this statement should be properly indented
+		return -x	// this statement should be properly indented
 	}
 	return x;
 }
@@ -120,7 +120,7 @@ func typeswitch(x interface{}) {
 	switch v0, ok := x.(int); x.(type) {
 	case byte:	// this comment should be on the same line as the keyword
 		// this comment should be normally indented
-		_ = 0;
+		_ = 0
 	case bool, int, float:
 		// this comment should be indented
 	case string:
diff --git a/src/pkg/go/printer/testdata/expressions.golden b/src/pkg/go/printer/testdata/expressions.golden
index 4d105f7d30..efca110ca5 100644
--- a/src/pkg/go/printer/testdata/expressions.golden
+++ b/src/pkg/go/printer/testdata/expressions.golden
@@ -230,7 +230,7 @@ func same(t, u *Time) bool {
 		t.Second == u.Second &&
 		t.Weekday == u.Weekday &&
 		t.ZoneOffset == u.ZoneOffset &&
-		t.Zone == u.Zone;
+		t.Zone == u.Zone
 }
 
 
@@ -249,7 +249,7 @@ func addState(s []state, inst instr, match []int) {
 	for i := 0; i < l; i++ {
 		if s[i].inst.index() == index &&	// same instruction
 			s[i].match[0] < pos {	// earlier match already going; leftmost wins
-			return s;
+			return s
 		}
 	}
 }
diff --git a/src/pkg/go/printer/testdata/expressions.raw b/src/pkg/go/printer/testdata/expressions.raw
index ae11b7b16e..29109ba61c 100644
--- a/src/pkg/go/printer/testdata/expressions.raw
+++ b/src/pkg/go/printer/testdata/expressions.raw
@@ -230,7 +230,7 @@ func same(t, u *Time) bool {
 		t.Second == u.Second &&
 		t.Weekday == u.Weekday &&
 		t.ZoneOffset == u.ZoneOffset &&
-		t.Zone == u.Zone;
+		t.Zone == u.Zone
 }
 
 
@@ -249,7 +249,7 @@ func addState(s []state, inst instr, match []int) {
 	for i := 0; i < l; i++ {
 		if s[i].inst.index() == index &&	// same instruction
 			s[i].match[0] < pos {	// earlier match already going; leftmost wins
-			return s;
+			return s
 		}
 	}
 }
diff --git a/src/pkg/go/printer/testdata/linebreaks.golden b/src/pkg/go/printer/testdata/linebreaks.golden
index 9f92a998cc..afc5e7b4f1 100644
--- a/src/pkg/go/printer/testdata/linebreaks.golden
+++ b/src/pkg/go/printer/testdata/linebreaks.golden
@@ -209,12 +209,12 @@ testLoop:
 			}
 			if !reflect.DeepEqual(hdr, header) {
 				t.Errorf("test %d, entry %d: Incorrect header:\nhave %+v\nwant %+v",
-					i, j, *hdr, *header);
+					i, j, *hdr, *header)
 			}
 		}
 		hdr, err := tr.Next();
 		if hdr != nil || err != nil {
-			t.Errorf("test %d: Unexpected entry or error: hdr=%v err=%v", i, err);
+			t.Errorf("test %d: Unexpected entry or error: hdr=%v err=%v", i, err)
 		}
 		f.Close();
 	}
diff --git a/src/pkg/go/printer/testdata/statements.golden b/src/pkg/go/printer/testdata/statements.golden
index 875bac40b3..b09352c4c1 100644
--- a/src/pkg/go/printer/testdata/statements.golden
+++ b/src/pkg/go/printer/testdata/statements.golden
@@ -23,10 +23,10 @@ func _() {
 	if expr {
 	}	// no semicolon and parens printed
 	if x := expr; {
-		use(x);
+		use(x)
 	}
 	if x := expr; expr {
-		use(x);
+		use(x)
 	}
 }
 
@@ -48,11 +48,11 @@ func _() {
 	switch x := expr; {
 	default:
 		use(
-			x);
+			x)
 	}
 	switch x := expr; expr {
 	default:
-		use(x);
+		use(x)
 	}
 }
 
@@ -69,7 +69,7 @@ func _() {
 
 	case 2:	// followed by an empty line
 
-		use(x);	// followed by an empty line
+		use(x)	// followed by an empty line
 
 	case 3:	// no empty lines
 		use(x);
@@ -78,20 +78,20 @@ func _() {
 
 	switch x {
 	case 0:
-		use(x);
+		use(x)
 	case 1:	// this comment should have no effect on the previous or next line
-		use(x);
+		use(x)
 	}
 
 	switch x := 0; x {
 	case 1:
-		x = 0;
+		x = 0
 		// this comment should be indented
 	case 2:
-		x = 0;
+		x = 0
 	// this comment should not be indented, it is aligned with the next case
 	case 3:
-		x = 0;
+		x = 0
 		/* indented comment
 		   aligned
 		   aligned
@@ -99,7 +99,7 @@ func _() {
 		// bla
 		/* and more */
 	case 4:
-		x = 0;
+		x = 0
 	/* not indented comment
 	   aligned
 	   aligned
@@ -122,7 +122,7 @@ func _() {
 	for {
 	}	// no semicolons printed
 	for x := expr; ; {
-		use(x);
+		use(x)
 	}
 	for expr {
 	}	// no semicolons printed
@@ -131,18 +131,18 @@ func _() {
 	for ; ; expr = false {
 	}
 	for x := expr; expr; {
-		use(x);
+		use(x)
 	}
 	for x := expr; ; expr = false {
-		use(x);
+		use(x)
 	}
 	for ; expr; expr = false {
 	}
 	for x := expr; expr; expr = false {
-		use(x);
+		use(x)
 	}
 	for x := range []int{} {
-		use(x);
+		use(x)
 	}
 }
 
@@ -169,11 +169,11 @@ func _() {
 
 	if x < x {
 
-		use(x);
+		use(x)
 
 	} else {
 
-		use(x);
+		use(x)
 
 	}
 }
@@ -182,25 +182,25 @@ func _() {
 // Formatting around labels.
 func _() {
 L:
-	;
+
 }
 
 
 func _() {
 	// this comment should be indented
 L:
-	;
+
 }
 
 
 func _() {
-L:	_ = 0;
+L:	_ = 0
 }
 
 
 func _() {
 	// this comment should be indented
-L:	_ = 0;
+L:	_ = 0
 }
 
 
@@ -225,14 +225,14 @@ func _() {
 
 func _() {
 	if {
-		_ = 0;
+		_ = 0
 	}
 	_ = 0;	// the indentation here should not be affected by the long label name
 AnOverlongLabel:
 	_ = 0;
 
 	if {
-		_ = 0;
+		_ = 0
 	}
 	_ = 0;
 
diff --git a/src/pkg/go/scanner/errors.go b/src/pkg/go/scanner/errors.go
index a8219b1903..16ad53260e 100644
--- a/src/pkg/go/scanner/errors.go
+++ b/src/pkg/go/scanner/errors.go
@@ -68,7 +68,7 @@ func (e *Error) String() string {
 	if e.Pos.Filename != "" || e.Pos.IsValid() {
 		// don't print "<unknown position>"
 		// TODO(gri) reconsider the semantics of Position.IsValid
-		return e.Pos.String() + ": " + e.Msg;
+		return e.Pos.String() + ": " + e.Msg
 	}
 	return e.Msg;
 }
@@ -90,14 +90,14 @@ func (p ErrorList) Less(i, j int) bool {
 	// the offsets do not reflect modified line information (through //line
 	// comments).
 	if e.Filename < f.Filename {
-		return true;
+		return true
 	}
 	if e.Filename == f.Filename {
 		if e.Line < f.Line {
-			return true;
+			return true
 		}
 		if e.Line == f.Line {
-			return e.Column < f.Column;
+			return e.Column < f.Column
 		}
 	}
 	return false;
@@ -107,9 +107,9 @@ func (p ErrorList) Less(i, j int) bool {
 func (p ErrorList) String() string {
 	switch len(p) {
 	case 0:
-		return "unspecified error";
+		return "unspecified error"
 	case 1:
-		return p[0].String();
+		return p[0].String()
 	}
 	return fmt.Sprintf("%s (and %d more errors)", p[0].String(), len(p)-1);
 }
@@ -131,16 +131,16 @@ const (
 //
 func (h *ErrorVector) GetErrorList(mode int) ErrorList {
 	if h.errors.Len() == 0 {
-		return nil;
+		return nil
 	}
 
 	list := make(ErrorList, h.errors.Len());
 	for i := 0; i < h.errors.Len(); i++ {
-		list[i] = h.errors.At(i).(*Error);
+		list[i] = h.errors.At(i).(*Error)
 	}
 
 	if mode >= Sorted {
-		sort.Sort(list);
+		sort.Sort(list)
 	}
 
 	if mode >= NoMultiples {
@@ -166,7 +166,7 @@ func (h *ErrorVector) GetErrorList(mode int) ErrorList {
 //
 func (h *ErrorVector) GetError(mode int) os.Error {
 	if h.errors.Len() == 0 {
-		return nil;
+		return nil
 	}
 
 	return h.GetErrorList(mode);
@@ -175,7 +175,7 @@ func (h *ErrorVector) GetError(mode int) os.Error {
 
 // ErrorVector implements the ErrorHandler interface.
 func (h *ErrorVector) Error(pos token.Position, msg string) {
-	h.errors.Push(&Error{pos, msg});
+	h.errors.Push(&Error{pos, msg})
 }
 
 
@@ -186,9 +186,9 @@ func (h *ErrorVector) Error(pos token.Position, msg string) {
 func PrintError(w io.Writer, err os.Error) {
 	if list, ok := err.(ErrorList); ok {
 		for _, e := range list {
-			fmt.Fprintf(w, "%s\n", e);
+			fmt.Fprintf(w, "%s\n", e)
 		}
 	} else {
-		fmt.Fprintf(w, "%s\n", err);
+		fmt.Fprintf(w, "%s\n", err)
 	}
 }
diff --git a/src/pkg/go/scanner/scanner.go b/src/pkg/go/scanner/scanner.go
index 7f707296e7..cc4ff9cc47 100644
--- a/src/pkg/go/scanner/scanner.go
+++ b/src/pkg/go/scanner/scanner.go
@@ -52,7 +52,7 @@ func (S *Scanner) next() {
 			S.pos.Column = 0;
 		case r >= 0x80:
 			// not ASCII
-			r, w = utf8.DecodeRune(S.src[S.offset : len(S.src)]);
+			r, w = utf8.DecodeRune(S.src[S.offset : len(S.src)])
 		}
 		S.offset += w;
 		S.ch = r;
@@ -96,27 +96,27 @@ func charString(ch int) string {
 	var s string;
 	switch ch {
 	case -1:
-		return `EOF`;
+		return `EOF`
 	case '\a':
-		s = `\a`;
+		s = `\a`
 	case '\b':
-		s = `\b`;
+		s = `\b`
 	case '\f':
-		s = `\f`;
+		s = `\f`
 	case '\n':
-		s = `\n`;
+		s = `\n`
 	case '\r':
-		s = `\r`;
+		s = `\r`
 	case '\t':
-		s = `\t`;
+		s = `\t`
 	case '\v':
-		s = `\v`;
+		s = `\v`
 	case '\\':
-		s = `\\`;
+		s = `\\`
 	case '\'':
-		s = `\'`;
+		s = `\'`
 	default:
-		s = string(ch);
+		s = string(ch)
 	}
 	return "'" + s + "' (U+" + strconv.Itob(ch, 16) + ")";
 }
@@ -124,7 +124,7 @@ func charString(ch int) string {
 
 func (S *Scanner) error(pos token.Position, msg string) {
 	if S.err != nil {
-		S.err.Error(pos, msg);
+		S.err.Error(pos, msg)
 	}
 	S.ErrorCount++;
 }
@@ -132,7 +132,7 @@ func (S *Scanner) error(pos token.Position, msg string) {
 
 func (S *Scanner) expect(ch int) {
 	if S.ch != ch {
-		S.error(S.pos, "expected " + charString(ch) + ", found " + charString(S.ch));
+		S.error(S.pos, "expected " + charString(ch) + ", found " + charString(S.ch))
 	}
 	S.next();	// always make progress
 }
@@ -188,19 +188,19 @@ func (S *Scanner) scanComment(pos token.Position) {
 
 
 func isLetter(ch int) bool {
-	return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || ch == '_' || ch >= 0x80 && unicode.IsLetter(ch);
+	return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || ch == '_' || ch >= 0x80 && unicode.IsLetter(ch)
 }
 
 
 func isDigit(ch int) bool {
-	return '0' <= ch && ch <= '9' || ch >= 0x80 && unicode.IsDigit(ch);
+	return '0' <= ch && ch <= '9' || ch >= 0x80 && unicode.IsDigit(ch)
 }
 
 
 func (S *Scanner) scanIdentifier() token.Token {
 	pos := S.pos.Offset;
 	for isLetter(S.ch) || isDigit(S.ch) {
-		S.next();
+		S.next()
 	}
 	return token.Lookup(S.src[pos : S.pos.Offset]);
 }
@@ -209,11 +209,11 @@ func (S *Scanner) scanIdentifier() token.Token {
 func digitVal(ch int) int {
 	switch {
 	case '0' <= ch && ch <= '9':
-		return ch-'0';
+		return ch-'0'
 	case 'a' <= ch && ch <= 'f':
-		return ch-'a'+10;
+		return ch-'a'+10
 	case 'A' <= ch && ch <= 'F':
-		return ch-'A'+10;
+		return ch-'A'+10
 	}
 	return 16;	// larger than any legal digit val
 }
@@ -221,7 +221,7 @@ func digitVal(ch int) int {
 
 func (S *Scanner) scanMantissa(base int) {
 	for digitVal(S.ch) < base {
-		S.next();
+		S.next()
 	}
 }
 
@@ -272,7 +272,7 @@ exponent:
 		tok = token.FLOAT;
 		S.next();
 		if S.ch == '-' || S.ch == '+' {
-			S.next();
+			S.next()
 		}
 		S.scanMantissa(10);
 	}
@@ -288,7 +288,7 @@ func (S *Scanner) scanDigits(base, length int) {
 		length--;
 	}
 	if length > 0 {
-		S.error(S.pos, "illegal char escape");
+		S.error(S.pos, "illegal char escape")
 	}
 }
 
@@ -301,15 +301,15 @@ func (S *Scanner) scanEscape(quote int) {
 	case 'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', quote:
 	// nothing to do
 	case '0', '1', '2', '3', '4', '5', '6', '7':
-		S.scanDigits(8, 3-1);	// 1 char read already
+		S.scanDigits(8, 3-1)	// 1 char read already
 	case 'x':
-		S.scanDigits(16, 2);
+		S.scanDigits(16, 2)
 	case 'u':
-		S.scanDigits(16, 4);
+		S.scanDigits(16, 4)
 	case 'U':
-		S.scanDigits(16, 8);
+		S.scanDigits(16, 8)
 	default:
-		S.error(pos, "illegal char escape");
+		S.error(pos, "illegal char escape")
 	}
 }
 
@@ -328,14 +328,14 @@ func (S *Scanner) scanChar(pos token.Position) {
 			break;
 		}
 		if ch == '\\' {
-			S.scanEscape('\'');
+			S.scanEscape('\'')
 		}
 	}
 
 	S.next();
 
 	if n != 1 {
-		S.error(pos, "illegal character literal");
+		S.error(pos, "illegal character literal")
 	}
 }
 
@@ -351,7 +351,7 @@ func (S *Scanner) scanString(pos token.Position) {
 			break;
 		}
 		if ch == '\\' {
-			S.scanEscape('"');
+			S.scanEscape('"')
 		}
 	}
 
@@ -435,7 +435,7 @@ func (S *Scanner) Scan() (pos token.Position, tok token.Token, lit []byte) {
 scan_again:
 	// skip white space
 	for S.ch == ' ' || S.ch == '\t' || S.ch == '\n' || S.ch == '\r' {
-		S.next();
+		S.next()
 	}
 
 	// current token start
@@ -444,14 +444,14 @@ scan_again:
 	// determine token value
 	switch ch := S.ch; {
 	case isLetter(ch):
-		tok = S.scanIdentifier();
+		tok = S.scanIdentifier()
 	case digitVal(ch) < 10:
-		tok = S.scanNumber(false);
+		tok = S.scanNumber(false)
 	default:
 		S.next();	// always make progress
 		switch ch {
 		case -1:
-			tok = token.EOF;
+			tok = token.EOF
 		case '"':
 			tok = token.STRING;
 			S.scanString(pos);
@@ -462,10 +462,10 @@ scan_again:
 			tok = token.STRING;
 			S.scanRawString(pos);
 		case ':':
-			tok = S.switch2(token.COLON, token.DEFINE);
+			tok = S.switch2(token.COLON, token.DEFINE)
 		case '.':
 			if digitVal(S.ch) < 10 {
-				tok = S.scanNumber(true);
+				tok = S.scanNumber(true)
 			} else if S.ch == '.' {
 				S.next();
 				if S.ch == '.' {
@@ -473,69 +473,69 @@ scan_again:
 					tok = token.ELLIPSIS;
 				}
 			} else {
-				tok = token.PERIOD;
+				tok = token.PERIOD
 			}
 		case ',':
-			tok = token.COMMA;
+			tok = token.COMMA
 		case ';':
-			tok = token.SEMICOLON;
+			tok = token.SEMICOLON
 		case '(':
-			tok = token.LPAREN;
+			tok = token.LPAREN
 		case ')':
-			tok = token.RPAREN;
+			tok = token.RPAREN
 		case '[':
-			tok = token.LBRACK;
+			tok = token.LBRACK
 		case ']':
-			tok = token.RBRACK;
+			tok = token.RBRACK
 		case '{':
-			tok = token.LBRACE;
+			tok = token.LBRACE
 		case '}':
-			tok = token.RBRACE;
+			tok = token.RBRACE
 		case '+':
-			tok = S.switch3(token.ADD, token.ADD_ASSIGN, '+', token.INC);
+			tok = S.switch3(token.ADD, token.ADD_ASSIGN, '+', token.INC)
 		case '-':
-			tok = S.switch3(token.SUB, token.SUB_ASSIGN, '-', token.DEC);
+			tok = S.switch3(token.SUB, token.SUB_ASSIGN, '-', token.DEC)
 		case '*':
-			tok = S.switch2(token.MUL, token.MUL_ASSIGN);
+			tok = S.switch2(token.MUL, token.MUL_ASSIGN)
 		case '/':
 			if S.ch == '/' || S.ch == '*' {
 				S.scanComment(pos);
 				tok = token.COMMENT;
 				if S.mode & ScanComments == 0 {
-					goto scan_again;
+					goto scan_again
 				}
 			} else {
-				tok = S.switch2(token.QUO, token.QUO_ASSIGN);
+				tok = S.switch2(token.QUO, token.QUO_ASSIGN)
 			}
 		case '%':
-			tok = S.switch2(token.REM, token.REM_ASSIGN);
+			tok = S.switch2(token.REM, token.REM_ASSIGN)
 		case '^':
-			tok = S.switch2(token.XOR, token.XOR_ASSIGN);
+			tok = S.switch2(token.XOR, token.XOR_ASSIGN)
 		case '<':
 			if S.ch == '-' {
 				S.next();
 				tok = token.ARROW;
 			} else {
-				tok = S.switch4(token.LSS, token.LEQ, '<', token.SHL, token.SHL_ASSIGN);
+				tok = S.switch4(token.LSS, token.LEQ, '<', token.SHL, token.SHL_ASSIGN)
 			}
 		case '>':
-			tok = S.switch4(token.GTR, token.GEQ, '>', token.SHR, token.SHR_ASSIGN);
+			tok = S.switch4(token.GTR, token.GEQ, '>', token.SHR, token.SHR_ASSIGN)
 		case '=':
-			tok = S.switch2(token.ASSIGN, token.EQL);
+			tok = S.switch2(token.ASSIGN, token.EQL)
 		case '!':
-			tok = S.switch2(token.NOT, token.NEQ);
+			tok = S.switch2(token.NOT, token.NEQ)
 		case '&':
 			if S.ch == '^' {
 				S.next();
 				tok = S.switch2(token.AND_NOT, token.AND_NOT_ASSIGN);
 			} else {
-				tok = S.switch3(token.AND, token.AND_ASSIGN, '&', token.LAND);
+				tok = S.switch3(token.AND, token.AND_ASSIGN, '&', token.LAND)
 			}
 		case '|':
-			tok = S.switch3(token.OR, token.OR_ASSIGN, '|', token.LOR);
+			tok = S.switch3(token.OR, token.OR_ASSIGN, '|', token.LOR)
 		default:
 			if S.mode & AllowIllegalChars == 0 {
-				S.error(pos, "illegal character " + charString(ch));
+				S.error(pos, "illegal character " + charString(ch))
 			}
 		}
 	}
diff --git a/src/pkg/go/scanner/scanner_test.go b/src/pkg/go/scanner/scanner_test.go
index 0b036e8b46..3bdd71e64c 100644
--- a/src/pkg/go/scanner/scanner_test.go
+++ b/src/pkg/go/scanner/scanner_test.go
@@ -23,11 +23,11 @@ const /* class */ (
 func tokenclass(tok token.Token) int {
 	switch {
 	case tok.IsLiteral():
-		return literal;
+		return literal
 	case tok.IsOperator():
-		return operator;
+		return operator
 	case tok.IsKeyword():
-		return keyword;
+		return keyword
 	}
 	return special;
 }
@@ -169,7 +169,7 @@ type TestErrorHandler struct {
 }
 
 func (h *TestErrorHandler) Error(pos token.Position, msg string) {
-	h.t.Errorf("Error() called (msg = %s)", msg);
+	h.t.Errorf("Error() called (msg = %s)", msg)
 }
 
 
@@ -177,7 +177,7 @@ func NewlineCount(s string) int {
 	n := 0;
 	for i := 0; i < len(s); i++ {
 		if s[i] == '\n' {
-			n++;
+			n++
 		}
 	}
 	return n;
@@ -186,16 +186,16 @@ func NewlineCount(s string) int {
 
 func checkPos(t *testing.T, lit string, pos, expected token.Position) {
 	if pos.Filename != expected.Filename {
-		t.Errorf("bad filename for %s: got %s, expected %s", lit, pos.Filename, expected.Filename);
+		t.Errorf("bad filename for %s: got %s, expected %s", lit, pos.Filename, expected.Filename)
 	}
 	if pos.Offset != expected.Offset {
-		t.Errorf("bad position for %s: got %d, expected %d", lit, pos.Offset, expected.Offset);
+		t.Errorf("bad position for %s: got %d, expected %d", lit, pos.Offset, expected.Offset)
 	}
 	if pos.Line != expected.Line {
-		t.Errorf("bad line for %s: got %d, expected %d", lit, pos.Line, expected.Line);
+		t.Errorf("bad line for %s: got %d, expected %d", lit, pos.Line, expected.Line)
 	}
 	if pos.Column != expected.Column {
-		t.Errorf("bad column for %s: got %d, expected %d", lit, pos.Column, expected.Column);
+		t.Errorf("bad column for %s: got %d, expected %d", lit, pos.Column, expected.Column)
 	}
 }
 
@@ -205,7 +205,7 @@ func TestScan(t *testing.T) {
 	// make source
 	var src string;
 	for _, e := range tokens {
-		src += e.lit + whitespace;
+		src += e.lit + whitespace
 	}
 	whitespace_linecount := NewlineCount(whitespace);
 
@@ -216,7 +216,7 @@ func TestScan(t *testing.T) {
 		func(pos token.Position, tok token.Token, litb []byte) bool {
 			e := elt{token.EOF, "", special};
 			if index < len(tokens) {
-				e = tokens[index];
+				e = tokens[index]
 			}
 			lit := string(litb);
 			if tok == token.EOF {
@@ -225,13 +225,13 @@ func TestScan(t *testing.T) {
 			}
 			checkPos(t, lit, pos, epos);
 			if tok != e.tok {
-				t.Errorf("bad token for %s: got %s, expected %s", lit, tok.String(), e.tok.String());
+				t.Errorf("bad token for %s: got %s, expected %s", lit, tok.String(), e.tok.String())
 			}
 			if e.tok.IsLiteral() && lit != e.lit {
-				t.Errorf("bad literal for %s: got %s, expected %s", lit, lit, e.lit);
+				t.Errorf("bad literal for %s: got %s, expected %s", lit, lit, e.lit)
 			}
 			if tokenclass(tok) != e.class {
-				t.Errorf("bad class for %s: got %d, expected %d", lit, tokenclass(tok), e.class);
+				t.Errorf("bad class for %s: got %d, expected %d", lit, tokenclass(tok), e.class)
 			}
 			epos.Offset += len(lit)+len(whitespace);
 			epos.Line += NewlineCount(lit) + whitespace_linecount;
@@ -244,7 +244,7 @@ func TestScan(t *testing.T) {
 			return tok != token.EOF;
 		});
 	if nerrors != 0 {
-		t.Errorf("found %d errors", nerrors);
+		t.Errorf("found %d errors", nerrors)
 	}
 }
 
@@ -280,7 +280,7 @@ func TestLineComments(t *testing.T) {
 	// make source
 	var src string;
 	for _, e := range segments {
-		src += e.srcline;
+		src += e.srcline
 	}
 
 	// verify scan
@@ -292,7 +292,7 @@ func TestLineComments(t *testing.T) {
 	}
 
 	if S.ErrorCount != 0 {
-		t.Errorf("found %d errors", S.ErrorCount);
+		t.Errorf("found %d errors", S.ErrorCount)
 	}
 }
 
@@ -307,18 +307,18 @@ func TestInit(t *testing.T) {
 	s.Scan();		// true
 	_, tok, _ := s.Scan();	// {
 	if tok != token.LBRACE {
-		t.Errorf("bad token: got %s, expected %s", tok.String(), token.LBRACE);
+		t.Errorf("bad token: got %s, expected %s", tok.String(), token.LBRACE)
 	}
 
 	// 2nd init
 	s.Init("", strings.Bytes("go true { ]"), nil, 0);
 	_, tok, _ = s.Scan();	// go
 	if tok != token.GO {
-		t.Errorf("bad token: got %s, expected %s", tok.String(), token.GO);
+		t.Errorf("bad token: got %s, expected %s", tok.String(), token.GO)
 	}
 
 	if s.ErrorCount != 0 {
-		t.Errorf("found %d errors", s.ErrorCount);
+		t.Errorf("found %d errors", s.ErrorCount)
 	}
 }
 
@@ -331,15 +331,15 @@ func TestIllegalChars(t *testing.T) {
 	for offs, ch := range src {
 		pos, tok, lit := s.Scan();
 		if pos.Offset != offs {
-			t.Errorf("bad position for %s: got %d, expected %d", string(lit), pos.Offset, offs);
+			t.Errorf("bad position for %s: got %d, expected %d", string(lit), pos.Offset, offs)
 		}
 		if tok == token.ILLEGAL && string(lit) != string(ch) {
-			t.Errorf("bad token: got %s, expected %s", string(lit), string(ch));
+			t.Errorf("bad token: got %s, expected %s", string(lit), string(ch))
 		}
 	}
 
 	if s.ErrorCount != 0 {
-		t.Errorf("found %d errors", s.ErrorCount);
+		t.Errorf("found %d errors", s.ErrorCount)
 	}
 }
 
@@ -358,7 +358,7 @@ func TestStdErrorHander(t *testing.T) {
 	v := NewErrorVector();
 	nerrors := Tokenize("File1", strings.Bytes(src), v, 0,
 		func(pos token.Position, tok token.Token, litb []byte) bool {
-			return tok != token.EOF;
+			return tok != token.EOF
 		});
 
 	list := v.GetErrorList(Raw);
@@ -380,6 +380,6 @@ func TestStdErrorHander(t *testing.T) {
 	}
 
 	if v.ErrorCount() != nerrors {
-		t.Errorf("found %d errors, expected %d", v.ErrorCount(), nerrors);
+		t.Errorf("found %d errors, expected %d", v.ErrorCount(), nerrors)
 	}
 }
diff --git a/src/pkg/go/token/token.go b/src/pkg/go/token/token.go
index 28c3354618..10097efbd8 100644
--- a/src/pkg/go/token/token.go
+++ b/src/pkg/go/token/token.go
@@ -239,7 +239,7 @@ var tokens = map[Token]string{
 //
 func (tok Token) String() string {
 	if str, exists := tokens[tok]; exists {
-		return str;
+		return str
 	}
 	return "token(" + strconv.Itoa(int(tok)) + ")";
 }
@@ -265,17 +265,17 @@ const (
 func (op Token) Precedence() int {
 	switch op {
 	case LOR:
-		return 1;
+		return 1
 	case LAND:
-		return 2;
+		return 2
 	case ARROW:
-		return 3;
+		return 3
 	case EQL, NEQ, LSS, LEQ, GTR, GEQ:
-		return 4;
+		return 4
 	case ADD, SUB, OR, XOR:
-		return 5;
+		return 5
 	case MUL, QUO, REM, SHL, SHR, AND, AND_NOT:
-		return 6;
+		return 6
 	}
 	return LowestPrec;
 }
@@ -286,7 +286,7 @@ var keywords map[string]Token
 func init() {
 	keywords = make(map[string]Token);
 	for i := keyword_beg + 1; i < keyword_end; i++ {
-		keywords[tokens[i]] = i;
+		keywords[tokens[i]] = i
 	}
 }
 
@@ -297,7 +297,7 @@ func Lookup(ident []byte) Token {
 	// TODO Maps with []byte key are illegal because []byte does not
 	//      support == . Should find a more efficient solution eventually.
 	if tok, is_keyword := keywords[string(ident)]; is_keyword {
-		return tok;
+		return tok
 	}
 	return IDENT;
 }
@@ -346,12 +346,12 @@ func (pos Position) String() string {
 	s := pos.Filename;
 	if pos.IsValid() {
 		if s != "" {
-			s += ":";
+			s += ":"
 		}
 		s += fmt.Sprintf("%d:%d", pos.Line, pos.Column);
 	}
 	if s == "" {
-		s = "???";
+		s = "???"
 	}
 	return s;
 }
diff --git a/src/pkg/gob/codec_test.go b/src/pkg/gob/codec_test.go
index aa3ae1cd62..4808c1146c 100644
--- a/src/pkg/gob/codec_test.go
+++ b/src/pkg/gob/codec_test.go
@@ -47,10 +47,10 @@ func TestUintCodec(t *testing.T) {
 		b.Reset();
 		encodeUint(encState, tt.x);
 		if encState.err != nil {
-			t.Error("encodeUint:", tt.x, encState.err);
+			t.Error("encodeUint:", tt.x, encState.err)
 		}
 		if !bytes.Equal(tt.b, b.Bytes()) {
-			t.Errorf("encodeUint: %#x encode: expected % x got % x", tt.x, tt.b, b.Bytes());
+			t.Errorf("encodeUint: %#x encode: expected % x got % x", tt.x, tt.b, b.Bytes())
 		}
 	}
 	decState := newDecodeState(b);
@@ -58,17 +58,17 @@ func TestUintCodec(t *testing.T) {
 		b.Reset();
 		encodeUint(encState, u);
 		if encState.err != nil {
-			t.Error("encodeUint:", u, encState.err);
+			t.Error("encodeUint:", u, encState.err)
 		}
 		v := decodeUint(decState);
 		if decState.err != nil {
-			t.Error("DecodeUint:", u, decState.err);
+			t.Error("DecodeUint:", u, decState.err)
 		}
 		if u != v {
-			t.Errorf("Encode/Decode: sent %#x received %#x\n", u, v);
+			t.Errorf("Encode/Decode: sent %#x received %#x\n", u, v)
 		}
 		if u&(1<<63) != 0 {
-			break;
+			break
 		}
 	}
 }
@@ -79,16 +79,16 @@ func verifyInt(i int64, t *testing.T) {
 	encState.b = b;
 	encodeInt(encState, i);
 	if encState.err != nil {
-		t.Error("encodeInt:", i, encState.err);
+		t.Error("encodeInt:", i, encState.err)
 	}
 	decState := newDecodeState(b);
 	decState.buf = make([]byte, 8);
 	j := decodeInt(decState);
 	if decState.err != nil {
-		t.Error("DecodeInt:", i, decState.err);
+		t.Error("DecodeInt:", i, decState.err)
 	}
 	if i != j {
-		t.Errorf("Encode/Decode: sent %#x received %#x\n", uint64(i), uint64(j));
+		t.Errorf("Encode/Decode: sent %#x received %#x\n", uint64(i), uint64(j))
 	}
 }
 
@@ -101,7 +101,7 @@ func TestIntCodec(t *testing.T) {
 		verifyInt(-i, t);
 		verifyInt(^i, t);
 		if u&(1<<63) != 0 {
-			break;
+			break
 		}
 	}
 	verifyInt(-1 << 63, t);	// a tricky case
@@ -136,7 +136,7 @@ func TestScalarEncInstructions(t *testing.T) {
 		state := newencoderState(b);
 		instr.op(instr, state, unsafe.Pointer(&data));
 		if !bytes.Equal(boolResult, b.Bytes()) {
-			t.Errorf("bool enc instructions: expected % x got % x", boolResult, b.Bytes());
+			t.Errorf("bool enc instructions: expected % x got % x", boolResult, b.Bytes())
 		}
 	}
 
@@ -148,7 +148,7 @@ func TestScalarEncInstructions(t *testing.T) {
 		state := newencoderState(b);
 		instr.op(instr, state, unsafe.Pointer(&data));
 		if !bytes.Equal(signedResult, b.Bytes()) {
-			t.Errorf("int enc instructions: expected % x got % x", signedResult, b.Bytes());
+			t.Errorf("int enc instructions: expected % x got % x", signedResult, b.Bytes())
 		}
 	}
 
@@ -160,7 +160,7 @@ func TestScalarEncInstructions(t *testing.T) {
 		state := newencoderState(b);
 		instr.op(instr, state, unsafe.Pointer(&data));
 		if !bytes.Equal(unsignedResult, b.Bytes()) {
-			t.Errorf("uint enc instructions: expected % x got % x", unsignedResult, b.Bytes());
+			t.Errorf("uint enc instructions: expected % x got % x", unsignedResult, b.Bytes())
 		}
 	}
 
@@ -172,7 +172,7 @@ func TestScalarEncInstructions(t *testing.T) {
 		state := newencoderState(b);
 		instr.op(instr, state, unsafe.Pointer(&data));
 		if !bytes.Equal(signedResult, b.Bytes()) {
-			t.Errorf("int8 enc instructions: expected % x got % x", signedResult, b.Bytes());
+			t.Errorf("int8 enc instructions: expected % x got % x", signedResult, b.Bytes())
 		}
 	}
 
@@ -184,7 +184,7 @@ func TestScalarEncInstructions(t *testing.T) {
 		state := newencoderState(b);
 		instr.op(instr, state, unsafe.Pointer(&data));
 		if !bytes.Equal(unsignedResult, b.Bytes()) {
-			t.Errorf("uint8 enc instructions: expected % x got % x", unsignedResult, b.Bytes());
+			t.Errorf("uint8 enc instructions: expected % x got % x", unsignedResult, b.Bytes())
 		}
 	}
 
@@ -196,7 +196,7 @@ func TestScalarEncInstructions(t *testing.T) {
 		state := newencoderState(b);
 		instr.op(instr, state, unsafe.Pointer(&data));
 		if !bytes.Equal(signedResult, b.Bytes()) {
-			t.Errorf("int16 enc instructions: expected % x got % x", signedResult, b.Bytes());
+			t.Errorf("int16 enc instructions: expected % x got % x", signedResult, b.Bytes())
 		}
 	}
 
@@ -208,7 +208,7 @@ func TestScalarEncInstructions(t *testing.T) {
 		state := newencoderState(b);
 		instr.op(instr, state, unsafe.Pointer(&data));
 		if !bytes.Equal(unsignedResult, b.Bytes()) {
-			t.Errorf("uint16 enc instructions: expected % x got % x", unsignedResult, b.Bytes());
+			t.Errorf("uint16 enc instructions: expected % x got % x", unsignedResult, b.Bytes())
 		}
 	}
 
@@ -220,7 +220,7 @@ func TestScalarEncInstructions(t *testing.T) {
 		state := newencoderState(b);
 		instr.op(instr, state, unsafe.Pointer(&data));
 		if !bytes.Equal(signedResult, b.Bytes()) {
-			t.Errorf("int32 enc instructions: expected % x got % x", signedResult, b.Bytes());
+			t.Errorf("int32 enc instructions: expected % x got % x", signedResult, b.Bytes())
 		}
 	}
 
@@ -232,7 +232,7 @@ func TestScalarEncInstructions(t *testing.T) {
 		state := newencoderState(b);
 		instr.op(instr, state, unsafe.Pointer(&data));
 		if !bytes.Equal(unsignedResult, b.Bytes()) {
-			t.Errorf("uint32 enc instructions: expected % x got % x", unsignedResult, b.Bytes());
+			t.Errorf("uint32 enc instructions: expected % x got % x", unsignedResult, b.Bytes())
 		}
 	}
 
@@ -244,7 +244,7 @@ func TestScalarEncInstructions(t *testing.T) {
 		state := newencoderState(b);
 		instr.op(instr, state, unsafe.Pointer(&data));
 		if !bytes.Equal(signedResult, b.Bytes()) {
-			t.Errorf("int64 enc instructions: expected % x got % x", signedResult, b.Bytes());
+			t.Errorf("int64 enc instructions: expected % x got % x", signedResult, b.Bytes())
 		}
 	}
 
@@ -256,7 +256,7 @@ func TestScalarEncInstructions(t *testing.T) {
 		state := newencoderState(b);
 		instr.op(instr, state, unsafe.Pointer(&data));
 		if !bytes.Equal(unsignedResult, b.Bytes()) {
-			t.Errorf("uint64 enc instructions: expected % x got % x", unsignedResult, b.Bytes());
+			t.Errorf("uint64 enc instructions: expected % x got % x", unsignedResult, b.Bytes())
 		}
 	}
 
@@ -268,7 +268,7 @@ func TestScalarEncInstructions(t *testing.T) {
 		state := newencoderState(b);
 		instr.op(instr, state, unsafe.Pointer(&data));
 		if !bytes.Equal(floatResult, b.Bytes()) {
-			t.Errorf("float enc instructions: expected % x got % x", floatResult, b.Bytes());
+			t.Errorf("float enc instructions: expected % x got % x", floatResult, b.Bytes())
 		}
 	}
 
@@ -280,7 +280,7 @@ func TestScalarEncInstructions(t *testing.T) {
 		state := newencoderState(b);
 		instr.op(instr, state, unsafe.Pointer(&data));
 		if !bytes.Equal(floatResult, b.Bytes()) {
-			t.Errorf("float32 enc instructions: expected % x got % x", floatResult, b.Bytes());
+			t.Errorf("float32 enc instructions: expected % x got % x", floatResult, b.Bytes())
 		}
 	}
 
@@ -292,7 +292,7 @@ func TestScalarEncInstructions(t *testing.T) {
 		state := newencoderState(b);
 		instr.op(instr, state, unsafe.Pointer(&data));
 		if !bytes.Equal(floatResult, b.Bytes()) {
-			t.Errorf("float64 enc instructions: expected % x got % x", floatResult, b.Bytes());
+			t.Errorf("float64 enc instructions: expected % x got % x", floatResult, b.Bytes())
 		}
 	}
 
@@ -304,7 +304,7 @@ func TestScalarEncInstructions(t *testing.T) {
 		state := newencoderState(b);
 		instr.op(instr, state, unsafe.Pointer(&data));
 		if !bytes.Equal(bytesResult, b.Bytes()) {
-			t.Errorf("bytes enc instructions: expected % x got % x", bytesResult, b.Bytes());
+			t.Errorf("bytes enc instructions: expected % x got % x", bytesResult, b.Bytes())
 		}
 	}
 
@@ -316,7 +316,7 @@ func TestScalarEncInstructions(t *testing.T) {
 		state := newencoderState(b);
 		instr.op(instr, state, unsafe.Pointer(&data));
 		if !bytes.Equal(bytesResult, b.Bytes()) {
-			t.Errorf("string enc instructions: expected % x got % x", bytesResult, b.Bytes());
+			t.Errorf("string enc instructions: expected % x got % x", bytesResult, b.Bytes())
 		}
 	}
 }
@@ -324,10 +324,10 @@ func TestScalarEncInstructions(t *testing.T) {
 func execDec(typ string, instr *decInstr, state *decodeState, t *testing.T, p unsafe.Pointer) {
 	v := int(decodeUint(state));
 	if state.err != nil {
-		t.Fatalf("decoding %s field: %v", typ, state.err);
+		t.Fatalf("decoding %s field: %v", typ, state.err)
 	}
 	if v + state.fieldnum != 6 {
-		t.Fatalf("decoding field number %d, got %d", 6, v + state.fieldnum);
+		t.Fatalf("decoding field number %d, got %d", 6, v + state.fieldnum)
 	}
 	instr.op(instr, state, decIndirect(p, instr.indir));
 	state.fieldnum = 6;
@@ -353,7 +353,7 @@ func TestScalarDecInstructions(t *testing.T) {
 		state := newDecodeStateFromData(boolResult);
 		execDec("bool", instr, state, t, unsafe.Pointer(&data));
 		if data.a != true {
-			t.Errorf("bool a = %v not true", data.a);
+			t.Errorf("bool a = %v not true", data.a)
 		}
 	}
 	// int
@@ -365,7 +365,7 @@ func TestScalarDecInstructions(t *testing.T) {
 		state := newDecodeStateFromData(signedResult);
 		execDec("int", instr, state, t, unsafe.Pointer(&data));
 		if data.a != 17 {
-			t.Errorf("int a = %v not 17", data.a);
+			t.Errorf("int a = %v not 17", data.a)
 		}
 	}
 
@@ -378,7 +378,7 @@ func TestScalarDecInstructions(t *testing.T) {
 		state := newDecodeStateFromData(unsignedResult);
 		execDec("uint", instr, state, t, unsafe.Pointer(&data));
 		if data.a != 17 {
-			t.Errorf("uint a = %v not 17", data.a);
+			t.Errorf("uint a = %v not 17", data.a)
 		}
 	}
 
@@ -391,7 +391,7 @@ func TestScalarDecInstructions(t *testing.T) {
 		state := newDecodeStateFromData(signedResult);
 		execDec("int8", instr, state, t, unsafe.Pointer(&data));
 		if data.a != 17 {
-			t.Errorf("int8 a = %v not 17", data.a);
+			t.Errorf("int8 a = %v not 17", data.a)
 		}
 	}
 
@@ -404,7 +404,7 @@ func TestScalarDecInstructions(t *testing.T) {
 		state := newDecodeStateFromData(unsignedResult);
 		execDec("uint8", instr, state, t, unsafe.Pointer(&data));
 		if data.a != 17 {
-			t.Errorf("uint8 a = %v not 17", data.a);
+			t.Errorf("uint8 a = %v not 17", data.a)
 		}
 	}
 
@@ -417,7 +417,7 @@ func TestScalarDecInstructions(t *testing.T) {
 		state := newDecodeStateFromData(signedResult);
 		execDec("int16", instr, state, t, unsafe.Pointer(&data));
 		if data.a != 17 {
-			t.Errorf("int16 a = %v not 17", data.a);
+			t.Errorf("int16 a = %v not 17", data.a)
 		}
 	}
 
@@ -430,7 +430,7 @@ func TestScalarDecInstructions(t *testing.T) {
 		state := newDecodeStateFromData(unsignedResult);
 		execDec("uint16", instr, state, t, unsafe.Pointer(&data));
 		if data.a != 17 {
-			t.Errorf("uint16 a = %v not 17", data.a);
+			t.Errorf("uint16 a = %v not 17", data.a)
 		}
 	}
 
@@ -443,7 +443,7 @@ func TestScalarDecInstructions(t *testing.T) {
 		state := newDecodeStateFromData(signedResult);
 		execDec("int32", instr, state, t, unsafe.Pointer(&data));
 		if data.a != 17 {
-			t.Errorf("int32 a = %v not 17", data.a);
+			t.Errorf("int32 a = %v not 17", data.a)
 		}
 	}
 
@@ -456,7 +456,7 @@ func TestScalarDecInstructions(t *testing.T) {
 		state := newDecodeStateFromData(unsignedResult);
 		execDec("uint32", instr, state, t, unsafe.Pointer(&data));
 		if data.a != 17 {
-			t.Errorf("uint32 a = %v not 17", data.a);
+			t.Errorf("uint32 a = %v not 17", data.a)
 		}
 	}
 
@@ -469,7 +469,7 @@ func TestScalarDecInstructions(t *testing.T) {
 		state := newDecodeStateFromData(unsignedResult);
 		execDec("uintptr", instr, state, t, unsafe.Pointer(&data));
 		if data.a != 17 {
-			t.Errorf("uintptr a = %v not 17", data.a);
+			t.Errorf("uintptr a = %v not 17", data.a)
 		}
 	}
 
@@ -482,7 +482,7 @@ func TestScalarDecInstructions(t *testing.T) {
 		state := newDecodeStateFromData(signedResult);
 		execDec("int64", instr, state, t, unsafe.Pointer(&data));
 		if data.a != 17 {
-			t.Errorf("int64 a = %v not 17", data.a);
+			t.Errorf("int64 a = %v not 17", data.a)
 		}
 	}
 
@@ -495,7 +495,7 @@ func TestScalarDecInstructions(t *testing.T) {
 		state := newDecodeStateFromData(unsignedResult);
 		execDec("uint64", instr, state, t, unsafe.Pointer(&data));
 		if data.a != 17 {
-			t.Errorf("uint64 a = %v not 17", data.a);
+			t.Errorf("uint64 a = %v not 17", data.a)
 		}
 	}
 
@@ -508,7 +508,7 @@ func TestScalarDecInstructions(t *testing.T) {
 		state := newDecodeStateFromData(floatResult);
 		execDec("float", instr, state, t, unsafe.Pointer(&data));
 		if data.a != 17 {
-			t.Errorf("float a = %v not 17", data.a);
+			t.Errorf("float a = %v not 17", data.a)
 		}
 	}
 
@@ -521,7 +521,7 @@ func TestScalarDecInstructions(t *testing.T) {
 		state := newDecodeStateFromData(floatResult);
 		execDec("float32", instr, state, t, unsafe.Pointer(&data));
 		if data.a != 17 {
-			t.Errorf("float32 a = %v not 17", data.a);
+			t.Errorf("float32 a = %v not 17", data.a)
 		}
 	}
 
@@ -534,7 +534,7 @@ func TestScalarDecInstructions(t *testing.T) {
 		state := newDecodeStateFromData(floatResult);
 		execDec("float64", instr, state, t, unsafe.Pointer(&data));
 		if data.a != 17 {
-			t.Errorf("float64 a = %v not 17", data.a);
+			t.Errorf("float64 a = %v not 17", data.a)
 		}
 	}
 
@@ -547,7 +547,7 @@ func TestScalarDecInstructions(t *testing.T) {
 		state := newDecodeStateFromData(bytesResult);
 		execDec("bytes", instr, state, t, unsafe.Pointer(&data));
 		if string(data.a) != "hello" {
-			t.Errorf(`bytes a = %q not "hello"`, string(data.a));
+			t.Errorf(`bytes a = %q not "hello"`, string(data.a))
 		}
 	}
 
@@ -560,7 +560,7 @@ func TestScalarDecInstructions(t *testing.T) {
 		state := newDecodeStateFromData(bytesResult);
 		execDec("bytes", instr, state, t, unsafe.Pointer(&data));
 		if data.a != "hello" {
-			t.Errorf(`bytes a = %q not "hello"`, data.a);
+			t.Errorf(`bytes a = %q not "hello"`, data.a)
 		}
 	}
 }
@@ -596,7 +596,7 @@ func TestEndToEnd(t *testing.T) {
 	var _t1 T1;
 	decode(b, getTypeInfoNoError(reflect.Typeof(_t1)).id, &_t1);
 	if !reflect.DeepEqual(t1, &_t1) {
-		t.Errorf("encode expected %v got %v", *t1, _t1);
+		t.Errorf("encode expected %v got %v", *t1, _t1)
 	}
 }
 
@@ -626,7 +626,7 @@ func TestOverflow(t *testing.T) {
 	encode(b, it);
 	err = decode(b, id, &o1);
 	if err == nil || err.String() != `value for "maxi" out of range` {
-		t.Error("wrong overflow error for int8:", err);
+		t.Error("wrong overflow error for int8:", err)
 	}
 	it = inputT{
 		mini: math.MinInt8 - 1,
@@ -635,7 +635,7 @@ func TestOverflow(t *testing.T) {
 	encode(b, it);
 	err = decode(b, id, &o1);
 	if err == nil || err.String() != `value for "mini" out of range` {
-		t.Error("wrong underflow error for int8:", err);
+		t.Error("wrong underflow error for int8:", err)
 	}
 
 	// int16
@@ -651,7 +651,7 @@ func TestOverflow(t *testing.T) {
 	encode(b, it);
 	err = decode(b, id, &o2);
 	if err == nil || err.String() != `value for "maxi" out of range` {
-		t.Error("wrong overflow error for int16:", err);
+		t.Error("wrong overflow error for int16:", err)
 	}
 	it = inputT{
 		mini: math.MinInt16 - 1,
@@ -660,7 +660,7 @@ func TestOverflow(t *testing.T) {
 	encode(b, it);
 	err = decode(b, id, &o2);
 	if err == nil || err.String() != `value for "mini" out of range` {
-		t.Error("wrong underflow error for int16:", err);
+		t.Error("wrong underflow error for int16:", err)
 	}
 
 	// int32
@@ -676,7 +676,7 @@ func TestOverflow(t *testing.T) {
 	encode(b, it);
 	err = decode(b, id, &o3);
 	if err == nil || err.String() != `value for "maxi" out of range` {
-		t.Error("wrong overflow error for int32:", err);
+		t.Error("wrong overflow error for int32:", err)
 	}
 	it = inputT{
 		mini: math.MinInt32 - 1,
@@ -685,7 +685,7 @@ func TestOverflow(t *testing.T) {
 	encode(b, it);
 	err = decode(b, id, &o3);
 	if err == nil || err.String() != `value for "mini" out of range` {
-		t.Error("wrong underflow error for int32:", err);
+		t.Error("wrong underflow error for int32:", err)
 	}
 
 	// uint8
@@ -700,7 +700,7 @@ func TestOverflow(t *testing.T) {
 	encode(b, it);
 	err = decode(b, id, &o4);
 	if err == nil || err.String() != `value for "maxu" out of range` {
-		t.Error("wrong overflow error for uint8:", err);
+		t.Error("wrong overflow error for uint8:", err)
 	}
 
 	// uint16
@@ -715,7 +715,7 @@ func TestOverflow(t *testing.T) {
 	encode(b, it);
 	err = decode(b, id, &o5);
 	if err == nil || err.String() != `value for "maxu" out of range` {
-		t.Error("wrong overflow error for uint16:", err);
+		t.Error("wrong overflow error for uint16:", err)
 	}
 
 	// uint32
@@ -730,7 +730,7 @@ func TestOverflow(t *testing.T) {
 	encode(b, it);
 	err = decode(b, id, &o6);
 	if err == nil || err.String() != `value for "maxu" out of range` {
-		t.Error("wrong overflow error for uint32:", err);
+		t.Error("wrong overflow error for uint32:", err)
 	}
 
 	// float32
@@ -746,7 +746,7 @@ func TestOverflow(t *testing.T) {
 	encode(b, it);
 	err = decode(b, id, &o7);
 	if err == nil || err.String() != `value for "maxf" out of range` {
-		t.Error("wrong overflow error for float32:", err);
+		t.Error("wrong overflow error for float32:", err)
 	}
 }
 
@@ -765,13 +765,13 @@ func TestNesting(t *testing.T) {
 	var drt RT;
 	decode(b, getTypeInfoNoError(reflect.Typeof(drt)).id, &drt);
 	if drt.a != rt.a {
-		t.Errorf("nesting: encode expected %v got %v", *rt, drt);
+		t.Errorf("nesting: encode expected %v got %v", *rt, drt)
 	}
 	if drt.next == nil {
-		t.Errorf("nesting: recursion failed");
+		t.Errorf("nesting: recursion failed")
 	}
 	if drt.next.a != rt.next.a {
-		t.Errorf("nesting: encode expected %v got %v", *rt.next, *drt.next);
+		t.Errorf("nesting: encode expected %v got %v", *rt.next, *drt.next)
 	}
 }
 
@@ -814,7 +814,7 @@ func TestAutoIndirection(t *testing.T) {
 	t0Id := getTypeInfoNoError(reflect.Typeof(t0)).id;
 	decode(b, t0Id, &t0);
 	if t0.a != 17 || t0.b != 177 || t0.c != 1777 || t0.d != 17777 {
-		t.Errorf("t1->t0: expected {17 177 1777 17777}; got %v", t0);
+		t.Errorf("t1->t0: expected {17 177 1777 17777}; got %v", t0)
 	}
 
 	// Now transfer t2 into t0
@@ -834,7 +834,7 @@ func TestAutoIndirection(t *testing.T) {
 	t0 = T0{};
 	decode(b, t0Id, &t0);
 	if t0.a != 17 || t0.b != 177 || t0.c != 1777 || t0.d != 17777 {
-		t.Errorf("t2->t0 expected {17 177 1777 17777}; got %v", t0);
+		t.Errorf("t2->t0 expected {17 177 1777 17777}; got %v", t0)
 	}
 
 	// Now transfer t0 into t1
@@ -845,7 +845,7 @@ func TestAutoIndirection(t *testing.T) {
 	t1Id := getTypeInfoNoError(reflect.Typeof(t1)).id;
 	decode(b, t1Id, &t1);
 	if t1.a != 17 || *t1.b != 177 || **t1.c != 1777 || ***t1.d != 17777 {
-		t.Errorf("t0->t1 expected {17 177 1777 17777}; got {%d %d %d %d}", t1.a, *t1.b, **t1.c, ***t1.d);
+		t.Errorf("t0->t1 expected {17 177 1777 17777}; got {%d %d %d %d}", t1.a, *t1.b, **t1.c, ***t1.d)
 	}
 
 	// Now transfer t0 into t2
@@ -855,7 +855,7 @@ func TestAutoIndirection(t *testing.T) {
 	t2Id := getTypeInfoNoError(reflect.Typeof(t2)).id;
 	decode(b, t2Id, &t2);
 	if ***t2.a != 17 || **t2.b != 177 || *t2.c != 1777 || t2.d != 17777 {
-		t.Errorf("t0->t2 expected {17 177 1777 17777}; got {%d %d %d %d}", ***t2.a, **t2.b, *t2.c, t2.d);
+		t.Errorf("t0->t2 expected {17 177 1777 17777}; got {%d %d %d %d}", ***t2.a, **t2.b, *t2.c, t2.d)
 	}
 
 	// Now do t2 again but without pre-allocated pointers.
@@ -867,7 +867,7 @@ func TestAutoIndirection(t *testing.T) {
 	t2.d = 0;
 	decode(b, t2Id, &t2);
 	if ***t2.a != 17 || **t2.b != 177 || *t2.c != 1777 || t2.d != 17777 {
-		t.Errorf("t0->t2 expected {17 177 1777 17777}; got {%d %d %d %d}", ***t2.a, **t2.b, *t2.c, t2.d);
+		t.Errorf("t0->t2 expected {17 177 1777 17777}; got {%d %d %d %d}", ***t2.a, **t2.b, *t2.c, t2.d)
 	}
 }
 
@@ -895,7 +895,7 @@ func TestReorderedFields(t *testing.T) {
 	// Wire type is RT0, local type is RT1.
 	decode(b, rt0Id, &rt1);
 	if rt0.a != rt1.a || rt0.b != rt1.b || rt0.c != rt1.c {
-		t.Errorf("rt1->rt0: expected %v; got %v", rt0, rt1);
+		t.Errorf("rt1->rt0: expected %v; got %v", rt0, rt1)
 	}
 }
 
@@ -933,10 +933,10 @@ func TestIgnoredFields(t *testing.T) {
 	// Wire type is IT0, local type is RT1.
 	err := decode(b, rt0Id, &rt1);
 	if err != nil {
-		t.Error("error: ", err);
+		t.Error("error: ", err)
 	}
 	if int(it0.a) != rt1.a || it0.b != rt1.b || it0.c != rt1.c {
-		t.Errorf("rt1->rt0: expected %v; got %v", it0, rt1);
+		t.Errorf("rt1->rt0: expected %v; got %v", it0, rt1)
 	}
 }
 
@@ -951,8 +951,8 @@ func TestInvalidField(t *testing.T) {
 	b := new(bytes.Buffer);
 	err := encode(b, &bad0);
 	if err == nil {
-		t.Error("expected error; got none");
+		t.Error("expected error; got none")
 	} else if strings.Index(err.String(), "interface") < 0 {
-		t.Error("expected type error; got", err);
+		t.Error("expected type error; got", err)
 	}
 }
diff --git a/src/pkg/gob/decode.go b/src/pkg/gob/decode.go
index e9e093eef5..2d13318857 100644
--- a/src/pkg/gob/decode.go
+++ b/src/pkg/gob/decode.go
@@ -39,7 +39,7 @@ func newDecodeState(b *bytes.Buffer) *decodeState {
 }
 
 func overflow(name string) os.ErrorString {
-	return os.ErrorString(`value for "` + name + `" out of range`);
+	return os.ErrorString(`value for "` + name + `" out of range`)
 }
 
 // decodeUintReader reads an encoded unsigned integer from an io.Reader.
@@ -47,11 +47,11 @@ func overflow(name string) os.ErrorString {
 func decodeUintReader(r io.Reader, buf []byte) (x uint64, err os.Error) {
 	_, err = r.Read(buf[0:1]);
 	if err != nil {
-		return;
+		return
 	}
 	b := buf[0];
 	if b <= 0x7f {
-		return uint64(b), nil;
+		return uint64(b), nil
 	}
 	nb := -int(int8(b));
 	if nb > uint64Size {
@@ -62,7 +62,7 @@ func decodeUintReader(r io.Reader, buf []byte) (x uint64, err os.Error) {
 	n, err = io.ReadFull(r, buf[0:nb]);
 	if err != nil {
 		if err == os.EOF {
-			err = io.ErrUnexpectedEOF;
+			err = io.ErrUnexpectedEOF
 		}
 		return;
 	}
@@ -79,12 +79,12 @@ func decodeUintReader(r io.Reader, buf []byte) (x uint64, err os.Error) {
 // Does not check for overflow.
 func decodeUint(state *decodeState) (x uint64) {
 	if state.err != nil {
-		return;
+		return
 	}
 	var b uint8;
 	b, state.err = state.b.ReadByte();
 	if b <= 0x7f {	// includes state.err != nil
-		return uint64(b);
+		return uint64(b)
 	}
 	nb := -int(int8(b));
 	if nb > uint64Size {
@@ -108,10 +108,10 @@ func decodeUint(state *decodeState) (x uint64) {
 func decodeInt(state *decodeState) int64 {
 	x := decodeUint(state);
 	if state.err != nil {
-		return 0;
+		return 0
 	}
 	if x&1 != 0 {
-		return ^int64(x>>1);
+		return ^int64(x>>1)
 	}
 	return int64(x>>1);
 }
@@ -139,7 +139,7 @@ func decIndirect(p unsafe.Pointer, indir int) unsafe.Pointer {
 	for ; indir > 1; indir-- {
 		if *(*unsafe.Pointer)(p) == nil {
 			// Allocation required
-			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(unsafe.Pointer));
+			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(unsafe.Pointer))
 		}
 		p = *(*unsafe.Pointer)(p);
 	}
@@ -147,13 +147,13 @@ func decIndirect(p unsafe.Pointer, indir int) unsafe.Pointer {
 }
 
 func ignoreUint(i *decInstr, state *decodeState, p unsafe.Pointer) {
-	decodeUint(state);
+	decodeUint(state)
 }
 
 func decBool(i *decInstr, state *decodeState, p unsafe.Pointer) {
 	if i.indir > 0 {
 		if *(*unsafe.Pointer)(p) == nil {
-			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(bool));
+			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(bool))
 		}
 		p = *(*unsafe.Pointer)(p);
 	}
@@ -163,97 +163,97 @@ func decBool(i *decInstr, state *decodeState, p unsafe.Pointer) {
 func decInt8(i *decInstr, state *decodeState, p unsafe.Pointer) {
 	if i.indir > 0 {
 		if *(*unsafe.Pointer)(p) == nil {
-			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(int8));
+			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(int8))
 		}
 		p = *(*unsafe.Pointer)(p);
 	}
 	v := decodeInt(state);
 	if v < math.MinInt8 || math.MaxInt8 < v {
-		state.err = i.ovfl;
+		state.err = i.ovfl
 	} else {
-		*(*int8)(p) = int8(v);
+		*(*int8)(p) = int8(v)
 	}
 }
 
 func decUint8(i *decInstr, state *decodeState, p unsafe.Pointer) {
 	if i.indir > 0 {
 		if *(*unsafe.Pointer)(p) == nil {
-			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(uint8));
+			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(uint8))
 		}
 		p = *(*unsafe.Pointer)(p);
 	}
 	v := decodeUint(state);
 	if math.MaxUint8 < v {
-		state.err = i.ovfl;
+		state.err = i.ovfl
 	} else {
-		*(*uint8)(p) = uint8(v);
+		*(*uint8)(p) = uint8(v)
 	}
 }
 
 func decInt16(i *decInstr, state *decodeState, p unsafe.Pointer) {
 	if i.indir > 0 {
 		if *(*unsafe.Pointer)(p) == nil {
-			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(int16));
+			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(int16))
 		}
 		p = *(*unsafe.Pointer)(p);
 	}
 	v := decodeInt(state);
 	if v < math.MinInt16 || math.MaxInt16 < v {
-		state.err = i.ovfl;
+		state.err = i.ovfl
 	} else {
-		*(*int16)(p) = int16(v);
+		*(*int16)(p) = int16(v)
 	}
 }
 
 func decUint16(i *decInstr, state *decodeState, p unsafe.Pointer) {
 	if i.indir > 0 {
 		if *(*unsafe.Pointer)(p) == nil {
-			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(uint16));
+			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(uint16))
 		}
 		p = *(*unsafe.Pointer)(p);
 	}
 	v := decodeUint(state);
 	if math.MaxUint16 < v {
-		state.err = i.ovfl;
+		state.err = i.ovfl
 	} else {
-		*(*uint16)(p) = uint16(v);
+		*(*uint16)(p) = uint16(v)
 	}
 }
 
 func decInt32(i *decInstr, state *decodeState, p unsafe.Pointer) {
 	if i.indir > 0 {
 		if *(*unsafe.Pointer)(p) == nil {
-			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(int32));
+			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(int32))
 		}
 		p = *(*unsafe.Pointer)(p);
 	}
 	v := decodeInt(state);
 	if v < math.MinInt32 || math.MaxInt32 < v {
-		state.err = i.ovfl;
+		state.err = i.ovfl
 	} else {
-		*(*int32)(p) = int32(v);
+		*(*int32)(p) = int32(v)
 	}
 }
 
 func decUint32(i *decInstr, state *decodeState, p unsafe.Pointer) {
 	if i.indir > 0 {
 		if *(*unsafe.Pointer)(p) == nil {
-			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(uint32));
+			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(uint32))
 		}
 		p = *(*unsafe.Pointer)(p);
 	}
 	v := decodeUint(state);
 	if math.MaxUint32 < v {
-		state.err = i.ovfl;
+		state.err = i.ovfl
 	} else {
-		*(*uint32)(p) = uint32(v);
+		*(*uint32)(p) = uint32(v)
 	}
 }
 
 func decInt64(i *decInstr, state *decodeState, p unsafe.Pointer) {
 	if i.indir > 0 {
 		if *(*unsafe.Pointer)(p) == nil {
-			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(int64));
+			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(int64))
 		}
 		p = *(*unsafe.Pointer)(p);
 	}
@@ -263,7 +263,7 @@ func decInt64(i *decInstr, state *decodeState, p unsafe.Pointer) {
 func decUint64(i *decInstr, state *decodeState, p unsafe.Pointer) {
 	if i.indir > 0 {
 		if *(*unsafe.Pointer)(p) == nil {
-			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(uint64));
+			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(uint64))
 		}
 		p = *(*unsafe.Pointer)(p);
 	}
@@ -288,26 +288,26 @@ func floatFromBits(u uint64) float64 {
 func decFloat32(i *decInstr, state *decodeState, p unsafe.Pointer) {
 	if i.indir > 0 {
 		if *(*unsafe.Pointer)(p) == nil {
-			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(float32));
+			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(float32))
 		}
 		p = *(*unsafe.Pointer)(p);
 	}
 	v := floatFromBits(decodeUint(state));
 	av := v;
 	if av < 0 {
-		av = -av;
+		av = -av
 	}
 	if math.MaxFloat32 < av {	// underflow is OK
-		state.err = i.ovfl;
+		state.err = i.ovfl
 	} else {
-		*(*float32)(p) = float32(v);
+		*(*float32)(p) = float32(v)
 	}
 }
 
 func decFloat64(i *decInstr, state *decodeState, p unsafe.Pointer) {
 	if i.indir > 0 {
 		if *(*unsafe.Pointer)(p) == nil {
-			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(float64));
+			*(*unsafe.Pointer)(p) = unsafe.Pointer(new(float64))
 		}
 		p = *(*unsafe.Pointer)(p);
 	}
@@ -318,7 +318,7 @@ func decFloat64(i *decInstr, state *decodeState, p unsafe.Pointer) {
 func decUint8Array(i *decInstr, state *decodeState, p unsafe.Pointer) {
 	if i.indir > 0 {
 		if *(*unsafe.Pointer)(p) == nil {
-			*(*unsafe.Pointer)(p) = unsafe.Pointer(new([]uint8));
+			*(*unsafe.Pointer)(p) = unsafe.Pointer(new([]uint8))
 		}
 		p = *(*unsafe.Pointer)(p);
 	}
@@ -331,7 +331,7 @@ func decUint8Array(i *decInstr, state *decodeState, p unsafe.Pointer) {
 func decString(i *decInstr, state *decodeState, p unsafe.Pointer) {
 	if i.indir > 0 {
 		if *(*unsafe.Pointer)(p) == nil {
-			*(*unsafe.Pointer)(p) = unsafe.Pointer(new([]byte));
+			*(*unsafe.Pointer)(p) = unsafe.Pointer(new([]byte))
 		}
 		p = *(*unsafe.Pointer)(p);
 	}
@@ -358,7 +358,7 @@ func decodeStruct(engine *decEngine, rtyp *reflect.StructType, b *bytes.Buffer,
 	if indir > 0 {
 		up := unsafe.Pointer(p);
 		if indir > 1 {
-			up = decIndirect(up, indir);
+			up = decIndirect(up, indir)
 		}
 		if *(*unsafe.Pointer)(up) == nil {
 			// Allocate object by making a slice of bytes and recording the
@@ -378,7 +378,7 @@ func decodeStruct(engine *decEngine, rtyp *reflect.StructType, b *bytes.Buffer,
 			break;
 		}
 		if state.err != nil || delta == 0 {	// struct terminator is zero delta fieldnum
-			break;
+			break
 		}
 		fieldnum := state.fieldnum + delta;
 		if fieldnum >= len(engine.instr) {
@@ -388,7 +388,7 @@ func decodeStruct(engine *decEngine, rtyp *reflect.StructType, b *bytes.Buffer,
 		instr := &engine.instr[fieldnum];
 		p := unsafe.Pointer(basep + instr.offset);
 		if instr.indir > 1 {
-			p = decIndirect(p, instr.indir);
+			p = decIndirect(p, instr.indir)
 		}
 		instr.op(instr, state, p);
 		state.fieldnum = fieldnum;
@@ -406,7 +406,7 @@ func ignoreStruct(engine *decEngine, b *bytes.Buffer) os.Error {
 			break;
 		}
 		if state.err != nil || delta == 0 {	// struct terminator is zero delta fieldnum
-			break;
+			break
 		}
 		fieldnum := state.fieldnum + delta;
 		if fieldnum >= len(engine.instr) {
@@ -425,7 +425,7 @@ func decodeArrayHelper(state *decodeState, p uintptr, elemOp decOp, elemWid uint
 	for i := 0; i < length && state.err == nil; i++ {
 		up := unsafe.Pointer(p);
 		if elemIndir > 1 {
-			up = decIndirect(up, elemIndir);
+			up = decIndirect(up, elemIndir)
 		}
 		elemOp(instr, state, up);
 		p += uintptr(elemWid);
@@ -445,7 +445,7 @@ func decodeArray(atyp *reflect.ArrayType, state *decodeState, p uintptr, elemOp
 		p = *(*uintptr)(up);
 	}
 	if n := decodeUint(state); n != uint64(length) {
-		return os.ErrorString("gob: length mismatch in decodeArray");
+		return os.ErrorString("gob: length mismatch in decodeArray")
 	}
 	return decodeArrayHelper(state, p, elemOp, elemWid, length, elemIndir, ovfl);
 }
@@ -453,14 +453,14 @@ func decodeArray(atyp *reflect.ArrayType, state *decodeState, p uintptr, elemOp
 func ignoreArrayHelper(state *decodeState, elemOp decOp, length int) os.Error {
 	instr := &decInstr{elemOp, 0, 0, 0, os.ErrorString("no error")};
 	for i := 0; i < length && state.err == nil; i++ {
-		elemOp(instr, state, nil);
+		elemOp(instr, state, nil)
 	}
 	return state.err;
 }
 
 func ignoreArray(state *decodeState, elemOp decOp, length int) os.Error {
 	if n := decodeUint(state); n != uint64(length) {
-		return os.ErrorString("gob: length mismatch in ignoreArray");
+		return os.ErrorString("gob: length mismatch in ignoreArray")
 	}
 	return ignoreArrayHelper(state, elemOp, length);
 }
@@ -471,7 +471,7 @@ func decodeSlice(atyp *reflect.SliceType, state *decodeState, p uintptr, elemOp
 		up := unsafe.Pointer(p);
 		if *(*unsafe.Pointer)(up) == nil {
 			// Allocate the slice header.
-			*(*unsafe.Pointer)(up) = unsafe.Pointer(new(reflect.SliceHeader));
+			*(*unsafe.Pointer)(up) = unsafe.Pointer(new(reflect.SliceHeader))
 		}
 		p = *(*uintptr)(up);
 	}
@@ -486,7 +486,7 @@ func decodeSlice(atyp *reflect.SliceType, state *decodeState, p uintptr, elemOp
 }
 
 func ignoreSlice(state *decodeState, elemOp decOp) os.Error {
-	return ignoreArrayHelper(state, elemOp, int(decodeUint(state)));
+	return ignoreArrayHelper(state, elemOp, int(decodeUint(state)))
 }
 
 var decOpMap = map[reflect.Type]decOp{
@@ -530,11 +530,11 @@ func decOpFor(wireId typeId, rt reflect.Type, name string) (decOp, int, os.Error
 			elemId := wireId.gobType().(*sliceType).Elem;
 			elemOp, elemIndir, err := decOpFor(elemId, t.Elem(), name);
 			if err != nil {
-				return nil, 0, err;
+				return nil, 0, err
 			}
 			ovfl := overflow(name);
 			op = func(i *decInstr, state *decodeState, p unsafe.Pointer) {
-				state.err = decodeSlice(t, state, uintptr(p), elemOp, t.Elem().Size(), i.indir, elemIndir, ovfl);
+				state.err = decodeSlice(t, state, uintptr(p), elemOp, t.Elem().Size(), i.indir, elemIndir, ovfl)
 			};
 
 		case *reflect.ArrayType:
@@ -542,27 +542,27 @@ func decOpFor(wireId typeId, rt reflect.Type, name string) (decOp, int, os.Error
 			elemId := wireId.gobType().(*arrayType).Elem;
 			elemOp, elemIndir, err := decOpFor(elemId, t.Elem(), name);
 			if err != nil {
-				return nil, 0, err;
+				return nil, 0, err
 			}
 			ovfl := overflow(name);
 			op = func(i *decInstr, state *decodeState, p unsafe.Pointer) {
-				state.err = decodeArray(t, state, uintptr(p), elemOp, t.Elem().Size(), t.Len(), i.indir, elemIndir, ovfl);
+				state.err = decodeArray(t, state, uintptr(p), elemOp, t.Elem().Size(), t.Len(), i.indir, elemIndir, ovfl)
 			};
 
 		case *reflect.StructType:
 			// Generate a closure that calls out to the engine for the nested type.
 			enginePtr, err := getDecEnginePtr(wireId, typ);
 			if err != nil {
-				return nil, 0, err;
+				return nil, 0, err
 			}
 			op = func(i *decInstr, state *decodeState, p unsafe.Pointer) {
 				// indirect through enginePtr to delay evaluation for recursive structs
-				state.err = decodeStruct(*enginePtr, t, state.b, uintptr(p), i.indir);
+				state.err = decodeStruct(*enginePtr, t, state.b, uintptr(p), i.indir)
 			};
 		}
 	}
 	if op == nil {
-		return nil, 0, os.ErrorString("gob: decode can't handle type " + rt.String());
+		return nil, 0, os.ErrorString("gob: decode can't handle type " + rt.String())
 	}
 	return op, indir, nil;
 }
@@ -577,36 +577,36 @@ func decIgnoreOpFor(wireId typeId) (decOp, os.Error) {
 			elemId := wireId.gobType().(*sliceType).Elem;
 			elemOp, err := decIgnoreOpFor(elemId);
 			if err != nil {
-				return nil, err;
+				return nil, err
 			}
 			op = func(i *decInstr, state *decodeState, p unsafe.Pointer) {
-				state.err = ignoreSlice(state, elemOp);
+				state.err = ignoreSlice(state, elemOp)
 			};
 
 		case *arrayType:
 			elemId := wireId.gobType().(*arrayType).Elem;
 			elemOp, err := decIgnoreOpFor(elemId);
 			if err != nil {
-				return nil, err;
+				return nil, err
 			}
 			op = func(i *decInstr, state *decodeState, p unsafe.Pointer) {
-				state.err = ignoreArray(state, elemOp, t.Len);
+				state.err = ignoreArray(state, elemOp, t.Len)
 			};
 
 		case *structType:
 			// Generate a closure that calls out to the engine for the nested type.
 			enginePtr, err := getIgnoreEnginePtr(wireId);
 			if err != nil {
-				return nil, err;
+				return nil, err
 			}
 			op = func(i *decInstr, state *decodeState, p unsafe.Pointer) {
 				// indirect through enginePtr to delay evaluation for recursive structs
-				state.err = ignoreStruct(*enginePtr, state.b);
+				state.err = ignoreStruct(*enginePtr, state.b)
 			};
 		}
 	}
 	if op == nil {
-		return nil, os.ErrorString("ignore can't handle type " + wireId.String());
+		return nil, os.ErrorString("ignore can't handle type " + wireId.String())
 	}
 	return op, nil;
 }
@@ -625,39 +625,39 @@ func compatibleType(fr reflect.Type, fw typeId) bool {
 	switch t := fr.(type) {
 	default:
 		// interface, map, chan, etc: cannot handle.
-		return false;
+		return false
 	case *reflect.BoolType:
-		return fw == tBool;
+		return fw == tBool
 	case *reflect.IntType:
-		return fw == tInt;
+		return fw == tInt
 	case *reflect.Int8Type:
-		return fw == tInt;
+		return fw == tInt
 	case *reflect.Int16Type:
-		return fw == tInt;
+		return fw == tInt
 	case *reflect.Int32Type:
-		return fw == tInt;
+		return fw == tInt
 	case *reflect.Int64Type:
-		return fw == tInt;
+		return fw == tInt
 	case *reflect.UintType:
-		return fw == tUint;
+		return fw == tUint
 	case *reflect.Uint8Type:
-		return fw == tUint;
+		return fw == tUint
 	case *reflect.Uint16Type:
-		return fw == tUint;
+		return fw == tUint
 	case *reflect.Uint32Type:
-		return fw == tUint;
+		return fw == tUint
 	case *reflect.Uint64Type:
-		return fw == tUint;
+		return fw == tUint
 	case *reflect.UintptrType:
-		return fw == tUint;
+		return fw == tUint
 	case *reflect.FloatType:
-		return fw == tFloat;
+		return fw == tFloat
 	case *reflect.Float32Type:
-		return fw == tFloat;
+		return fw == tFloat
 	case *reflect.Float64Type:
-		return fw == tFloat;
+		return fw == tFloat
 	case *reflect.StringType:
-		return fw == tString;
+		return fw == tString
 	case *reflect.ArrayType:
 		aw, ok := fw.gobType().(*arrayType);
 		return ok && t.Len() == aw.Len && compatibleType(t.Elem(), aw.Elem);
@@ -665,13 +665,13 @@ func compatibleType(fr reflect.Type, fw typeId) bool {
 		// Is it an array of bytes?
 		et := t.Elem();
 		if _, ok := et.(*reflect.Uint8Type); ok {
-			return fw == tBytes;
+			return fw == tBytes
 		}
 		sw, ok := fw.gobType().(*sliceType);
 		elem, _ := indirect(t.Elem());
 		return ok && compatibleType(elem, sw.Elem);
 	case *reflect.StructType:
-		return true;
+		return true
 	}
 	return true;
 }
@@ -680,7 +680,7 @@ func compileDec(wireId typeId, rt reflect.Type) (engine *decEngine, err os.Error
 	srt, ok1 := rt.(*reflect.StructType);
 	wireStruct, ok2 := wireId.gobType().(*structType);
 	if !ok1 || !ok2 {
-		return nil, errNotStruct;
+		return nil, errNotStruct
 	}
 	engine = new(decEngine);
 	engine.instr = make([]decInstr, len(wireStruct.field));
@@ -694,7 +694,7 @@ func compileDec(wireId typeId, rt reflect.Type) (engine *decEngine, err os.Error
 		if !present {
 			op, err := decIgnoreOpFor(wireField.id);
 			if err != nil {
-				return nil, err;
+				return nil, err
 			}
 			engine.instr[fieldnum] = decInstr{op, fieldnum, 0, 0, ovfl};
 			continue;
@@ -705,7 +705,7 @@ func compileDec(wireId typeId, rt reflect.Type) (engine *decEngine, err os.Error
 		}
 		op, indir, err := decOpFor(wireField.id, localField.Type, localField.Name);
 		if err != nil {
-			return nil, err;
+			return nil, err
 		}
 		engine.instr[fieldnum] = decInstr{op, fieldnum, indir, uintptr(localField.Offset), ovfl};
 		engine.numInstr++;
@@ -729,7 +729,7 @@ func getDecEnginePtr(wireId typeId, rt reflect.Type) (enginePtr **decEngine, err
 		decoderMap[wireId] = enginePtr;
 		*enginePtr, err = compileDec(wireId, rt);
 		if err != nil {
-			decoderMap[wireId] = nil, false;
+			decoderMap[wireId] = nil, false
 		}
 	}
 	return;
@@ -749,7 +749,7 @@ func getIgnoreEnginePtr(wireId typeId) (enginePtr **decEngine, err os.Error) {
 		ignorerCache[wireId] = enginePtr;
 		*enginePtr, err = compileDec(wireId, emptyStructType);
 		if err != nil {
-			ignorerCache[wireId] = nil, false;
+			ignorerCache[wireId] = nil, false
 		}
 	}
 	return;
@@ -760,7 +760,7 @@ func decode(b *bytes.Buffer, wireId typeId, e interface{}) os.Error {
 	rt, indir := indirect(reflect.Typeof(e));
 	st, ok := rt.(*reflect.StructType);
 	if !ok {
-		return os.ErrorString("gob: decode can't handle " + rt.String());
+		return os.ErrorString("gob: decode can't handle " + rt.String())
 	}
 	typeLock.Lock();
 	if _, ok := idToType[wireId]; !ok {
@@ -770,7 +770,7 @@ func decode(b *bytes.Buffer, wireId typeId, e interface{}) os.Error {
 	enginePtr, err := getDecEnginePtr(wireId, rt);
 	typeLock.Unlock();
 	if err != nil {
-		return err;
+		return err
 	}
 	engine := *enginePtr;
 	if engine.numInstr == 0 && st.NumField() > 0 && len(wireId.gobType().(*structType).field) > 0 {
@@ -786,11 +786,11 @@ func init() {
 	var op decOp;
 	switch unsafe.Sizeof(float(0)) {
 	case unsafe.Sizeof(float32(0)):
-		op = decFloat32;
+		op = decFloat32
 	case unsafe.Sizeof(float64(0)):
-		op = decFloat64;
+		op = decFloat64
 	default:
-		panic("gob: unknown size of float", unsafe.Sizeof(float(0)));
+		panic("gob: unknown size of float", unsafe.Sizeof(float(0)))
 	}
 	decOpMap[valueKind(float(0))] = op;
 
@@ -804,7 +804,7 @@ func init() {
 		op = decInt64;
 		uop = decUint64;
 	default:
-		panic("gob: unknown size of int/uint", unsafe.Sizeof(int(0)));
+		panic("gob: unknown size of int/uint", unsafe.Sizeof(int(0)))
 	}
 	decOpMap[valueKind(int(0))] = op;
 	decOpMap[valueKind(uint(0))] = uop;
@@ -812,11 +812,11 @@ func init() {
 	// Finally uintptr
 	switch unsafe.Sizeof(uintptr(0)) {
 	case unsafe.Sizeof(uint32(0)):
-		uop = decUint32;
+		uop = decUint32
 	case unsafe.Sizeof(uint64(0)):
-		uop = decUint64;
+		uop = decUint64
 	default:
-		panic("gob: unknown size of uintptr", unsafe.Sizeof(uintptr(0)));
+		panic("gob: unknown size of uintptr", unsafe.Sizeof(uintptr(0)))
 	}
 	decOpMap[valueKind(uintptr(0))] = uop;
 }
diff --git a/src/pkg/gob/decoder.go b/src/pkg/gob/decoder.go
index d00c3a7621..dde5d823f9 100644
--- a/src/pkg/gob/decoder.go
+++ b/src/pkg/gob/decoder.go
@@ -63,11 +63,11 @@ func (dec *Decoder) Decode(e interface{}) os.Error {
 		var nbytes uint64;
 		nbytes, dec.state.err = decodeUintReader(dec.r, dec.oneByte);
 		if dec.state.err != nil {
-			break;
+			break
 		}
 		// Allocate the buffer.
 		if nbytes > uint64(len(dec.buf)) {
-			dec.buf = make([]byte, nbytes+1000);
+			dec.buf = make([]byte, nbytes+1000)
 		}
 		dec.state.b = bytes.NewBuffer(dec.buf[0:nbytes]);
 
@@ -75,7 +75,7 @@ func (dec *Decoder) Decode(e interface{}) os.Error {
 		_, dec.state.err = io.ReadFull(dec.r, dec.buf[0:nbytes]);
 		if dec.state.err != nil {
 			if dec.state.err == os.EOF {
-				dec.state.err = io.ErrUnexpectedEOF;
+				dec.state.err = io.ErrUnexpectedEOF
 			}
 			break;
 		}
@@ -83,7 +83,7 @@ func (dec *Decoder) Decode(e interface{}) os.Error {
 		// Receive a type id.
 		id := typeId(decodeInt(dec.state));
 		if dec.state.err != nil {
-			break;
+			break
 		}
 
 		// Is it a new type?
@@ -91,7 +91,7 @@ func (dec *Decoder) Decode(e interface{}) os.Error {
 			// If the id is negative, we have a type.
 			dec.recvType(-id);
 			if dec.state.err != nil {
-				break;
+				break
 			}
 			continue;
 		}
diff --git a/src/pkg/gob/encode.go b/src/pkg/gob/encode.go
index 1f9d32310d..4f0e60c86a 100644
--- a/src/pkg/gob/encode.go
+++ b/src/pkg/gob/encode.go
@@ -35,7 +35,7 @@ type encoderState struct {
 // If state.err is already non-nil, it does nothing.
 func encodeUint(state *encoderState, x uint64) {
 	if state.err != nil {
-		return;
+		return
 	}
 	if x <= 0x7F {
 		state.err = state.b.WriteByte(uint8(x));
@@ -58,9 +58,9 @@ func encodeUint(state *encoderState, x uint64) {
 func encodeInt(state *encoderState, i int64) {
 	var x uint64;
 	if i < 0 {
-		x = uint64(^i << 1)|1;
+		x = uint64(^i << 1)|1
 	} else {
-		x = uint64(i<<1);
+		x = uint64(i<<1)
 	}
 	encodeUint(state, uint64(x));
 }
@@ -94,7 +94,7 @@ func encIndirect(p unsafe.Pointer, indir int) unsafe.Pointer {
 	for ; indir > 0; indir-- {
 		p = *(*unsafe.Pointer)(p);
 		if p == nil {
-			return unsafe.Pointer(nil);
+			return unsafe.Pointer(nil)
 		}
 	}
 	return p;
@@ -261,7 +261,7 @@ func encString(i *encInstr, state *encoderState, p unsafe.Pointer) {
 
 // The end of a struct is marked by a delta field number of 0.
 func encStructTerminator(i *encInstr, state *encoderState, p unsafe.Pointer) {
-	encodeUint(state, 0);
+	encodeUint(state, 0)
 }
 
 // Execution engine
@@ -281,12 +281,12 @@ func encodeStruct(engine *encEngine, b *bytes.Buffer, basep uintptr) os.Error {
 		p := unsafe.Pointer(basep + instr.offset);
 		if instr.indir > 0 {
 			if p = encIndirect(p, instr.indir); p == nil {
-				continue;
+				continue
 			}
 		}
 		instr.op(instr, state, p);
 		if state.err != nil {
-			break;
+			break
 		}
 	}
 	return state.err;
@@ -349,12 +349,12 @@ func encOpFor(rt reflect.Type) (encOp, int, os.Error) {
 			// Slices have a header; we decode it to find the underlying array.
 			elemOp, indir, err := encOpFor(t.Elem());
 			if err != nil {
-				return nil, 0, err;
+				return nil, 0, err
 			}
 			op = func(i *encInstr, state *encoderState, p unsafe.Pointer) {
 				slice := (*reflect.SliceHeader)(p);
 				if slice.Len == 0 {
-					return;
+					return
 				}
 				state.update(i);
 				state.err = encodeArray(state.b, slice.Data, elemOp, t.Elem().Size(), int(slice.Len), indir);
@@ -363,7 +363,7 @@ func encOpFor(rt reflect.Type) (encOp, int, os.Error) {
 			// True arrays have size in the type.
 			elemOp, indir, err := encOpFor(t.Elem());
 			if err != nil {
-				return nil, 0, err;
+				return nil, 0, err
 			}
 			op = func(i *encInstr, state *encoderState, p unsafe.Pointer) {
 				state.update(i);
@@ -373,7 +373,7 @@ func encOpFor(rt reflect.Type) (encOp, int, os.Error) {
 			// Generate a closure that calls out to the engine for the nested type.
 			_, err := getEncEngine(typ);
 			if err != nil {
-				return nil, 0, err;
+				return nil, 0, err
 			}
 			info := getTypeInfoNoError(typ);
 			op = func(i *encInstr, state *encoderState, p unsafe.Pointer) {
@@ -384,7 +384,7 @@ func encOpFor(rt reflect.Type) (encOp, int, os.Error) {
 		}
 	}
 	if op == nil {
-		return op, indir, os.ErrorString("gob enc: can't happen: encode type" + rt.String());
+		return op, indir, os.ErrorString("gob enc: can't happen: encode type" + rt.String())
 	}
 	return op, indir, nil;
 }
@@ -393,7 +393,7 @@ func encOpFor(rt reflect.Type) (encOp, int, os.Error) {
 func compileEnc(rt reflect.Type) (*encEngine, os.Error) {
 	srt, ok := rt.(*reflect.StructType);
 	if !ok {
-		panicln("can't happen: non-struct");
+		panicln("can't happen: non-struct")
 	}
 	engine := new(encEngine);
 	engine.instr = make([]encInstr, srt.NumField() + 1);	// +1 for terminator
@@ -401,7 +401,7 @@ func compileEnc(rt reflect.Type) (*encEngine, os.Error) {
 		f := srt.Field(fieldnum);
 		op, indir, err := encOpFor(f.Type);
 		if err != nil {
-			return nil, err;
+			return nil, err
 		}
 		engine.instr[fieldnum] = encInstr{op, fieldnum, indir, uintptr(f.Offset)};
 	}
@@ -414,7 +414,7 @@ func compileEnc(rt reflect.Type) (*encEngine, os.Error) {
 func getEncEngine(rt reflect.Type) (*encEngine, os.Error) {
 	info, err := getTypeInfo(rt);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	if info.encoder == nil {
 		// mark this engine as underway before compiling to handle recursive types.
@@ -429,16 +429,16 @@ func encode(b *bytes.Buffer, e interface{}) os.Error {
 	rt, indir := indirect(reflect.Typeof(e));
 	v := reflect.NewValue(e);
 	for i := 0; i < indir; i++ {
-		v = reflect.Indirect(v);
+		v = reflect.Indirect(v)
 	}
 	if _, ok := v.(*reflect.StructValue); !ok {
-		return os.ErrorString("gob: encode can't handle " + v.Type().String());
+		return os.ErrorString("gob: encode can't handle " + v.Type().String())
 	}
 	typeLock.Lock();
 	engine, err := getEncEngine(rt);
 	typeLock.Unlock();
 	if err != nil {
-		return err;
+		return err
 	}
 	return encodeStruct(engine, b, v.Addr());
 }
diff --git a/src/pkg/gob/encoder.go b/src/pkg/gob/encoder.go
index c567b507e4..a59309e335 100644
--- a/src/pkg/gob/encoder.go
+++ b/src/pkg/gob/encoder.go
@@ -213,7 +213,7 @@ func NewEncoder(w io.Writer) *Encoder {
 }
 
 func (enc *Encoder) badType(rt reflect.Type) {
-	enc.state.err = os.ErrorString("gob: can't encode type " + rt.String());
+	enc.state.err = os.ErrorString("gob: can't encode type " + rt.String())
 }
 
 // Send the data item preceded by a unsigned count of its length.
@@ -224,7 +224,7 @@ func (enc *Encoder) send() {
 	countLen := enc.countState.b.Len();
 	total := countLen + enc.state.b.Len();
 	if total > len(enc.buf) {
-		enc.buf = make([]byte, total+1000);	// extra for growth
+		enc.buf = make([]byte, total+1000)	// extra for growth
 	}
 	// Place the length before the data.
 	// TODO(r): avoid the extra copy here.
@@ -245,12 +245,12 @@ func (enc *Encoder) sendType(origt reflect.Type, topLevel bool) {
 		// Basic types do not need to be described, but if this is a top-level
 		// type, it's a user error, at least for now.
 		if topLevel {
-			enc.badType(rt);
+			enc.badType(rt)
 		}
 		return;
 	case *reflect.StructType:
 		// Structs do need to be described.
-		break;
+		break
 	case *reflect.ChanType, *reflect.FuncType, *reflect.MapType, *reflect.InterfaceType:
 		// Probably a bad field in a struct.
 		enc.badType(rt);
@@ -264,7 +264,7 @@ func (enc *Encoder) sendType(origt reflect.Type, topLevel bool) {
 
 	// Have we already sent this type?  This time we ask about the base type.
 	if _, alreadySent := enc.sent[rt]; alreadySent {
-		return;
+		return
 	}
 
 	// Need to send it.
@@ -289,7 +289,7 @@ func (enc *Encoder) sendType(origt reflect.Type, topLevel bool) {
 	// Now send the inner types
 	st := rt.(*reflect.StructType);
 	for i := 0; i < st.NumField(); i++ {
-		enc.sendType(st.Field(i).Type, false);
+		enc.sendType(st.Field(i).Type, false)
 	}
 	return;
 }
@@ -298,7 +298,7 @@ func (enc *Encoder) sendType(origt reflect.Type, topLevel bool) {
 // guaranteeing that all necessary type information has been transmitted first.
 func (enc *Encoder) Encode(e interface{}) os.Error {
 	if enc.state.b.Len() > 0 || enc.countState.b.Len() > 0 {
-		panicln("Encoder: buffer not empty");
+		panicln("Encoder: buffer not empty")
 	}
 	rt, _ := indirect(reflect.Typeof(e));
 
diff --git a/src/pkg/gob/encoder_test.go b/src/pkg/gob/encoder_test.go
index 5f12b172f6..e850bceae5 100644
--- a/src/pkg/gob/encoder_test.go
+++ b/src/pkg/gob/encoder_test.go
@@ -44,7 +44,7 @@ func TestBasicEncoder(t *testing.T) {
 	et1.et2 = new(ET2);
 	enc.Encode(et1);
 	if enc.state.err != nil {
-		t.Error("encoder fail:", enc.state.err);
+		t.Error("encoder fail:", enc.state.err)
 	}
 
 	// Decode the result by hand to verify;
@@ -53,98 +53,98 @@ func TestBasicEncoder(t *testing.T) {
 	// 0) The length, 38.
 	length := decodeUint(state);
 	if length != 38 {
-		t.Fatal("0. expected length 38; got", length);
+		t.Fatal("0. expected length 38; got", length)
 	}
 	// 1) -7: the type id of ET1
 	id1 := decodeInt(state);
 	if id1 >= 0 {
-		t.Fatal("expected ET1 negative id; got", id1);
+		t.Fatal("expected ET1 negative id; got", id1)
 	}
 	// 2) The wireType for ET1
 	wire1 := new(wireType);
 	err := decode(b, tWireType, wire1);
 	if err != nil {
-		t.Fatal("error decoding ET1 type:", err);
+		t.Fatal("error decoding ET1 type:", err)
 	}
 	info := getTypeInfoNoError(reflect.Typeof(ET1{}));
 	trueWire1 := &wireType{s: info.id.gobType().(*structType)};
 	if !reflect.DeepEqual(wire1, trueWire1) {
-		t.Fatalf("invalid wireType for ET1: expected %+v; got %+v\n", *trueWire1, *wire1);
+		t.Fatalf("invalid wireType for ET1: expected %+v; got %+v\n", *trueWire1, *wire1)
 	}
 	// 3) The length, 21.
 	length = decodeUint(state);
 	if length != 21 {
-		t.Fatal("3. expected length 21; got", length);
+		t.Fatal("3. expected length 21; got", length)
 	}
 	// 4) -8: the type id of ET2
 	id2 := decodeInt(state);
 	if id2 >= 0 {
-		t.Fatal("expected ET2 negative id; got", id2);
+		t.Fatal("expected ET2 negative id; got", id2)
 	}
 	// 5) The wireType for ET2
 	wire2 := new(wireType);
 	err = decode(b, tWireType, wire2);
 	if err != nil {
-		t.Fatal("error decoding ET2 type:", err);
+		t.Fatal("error decoding ET2 type:", err)
 	}
 	info = getTypeInfoNoError(reflect.Typeof(ET2{}));
 	trueWire2 := &wireType{s: info.id.gobType().(*structType)};
 	if !reflect.DeepEqual(wire2, trueWire2) {
-		t.Fatalf("invalid wireType for ET2: expected %+v; got %+v\n", *trueWire2, *wire2);
+		t.Fatalf("invalid wireType for ET2: expected %+v; got %+v\n", *trueWire2, *wire2)
 	}
 	// 6) The length, 6.
 	length = decodeUint(state);
 	if length != 6 {
-		t.Fatal("6. expected length 6; got", length);
+		t.Fatal("6. expected length 6; got", length)
 	}
 	// 7) The type id for the et1 value
 	newId1 := decodeInt(state);
 	if newId1 != -id1 {
-		t.Fatal("expected Et1 id", -id1, "got", newId1);
+		t.Fatal("expected Et1 id", -id1, "got", newId1)
 	}
 	// 8) The value of et1
 	newEt1 := new(ET1);
 	et1Id := getTypeInfoNoError(reflect.Typeof(*newEt1)).id;
 	err = decode(b, et1Id, newEt1);
 	if err != nil {
-		t.Fatal("error decoding ET1 value:", err);
+		t.Fatal("error decoding ET1 value:", err)
 	}
 	if !reflect.DeepEqual(et1, newEt1) {
-		t.Fatalf("invalid data for et1: expected %+v; got %+v\n", *et1, *newEt1);
+		t.Fatalf("invalid data for et1: expected %+v; got %+v\n", *et1, *newEt1)
 	}
 	// 9) EOF
 	if b.Len() != 0 {
-		t.Error("not at eof;", b.Len(), "bytes left");
+		t.Error("not at eof;", b.Len(), "bytes left")
 	}
 
 	// Now do it again. This time we should see only the type id and value.
 	b.Reset();
 	enc.Encode(et1);
 	if enc.state.err != nil {
-		t.Error("2nd round: encoder fail:", enc.state.err);
+		t.Error("2nd round: encoder fail:", enc.state.err)
 	}
 	// The length.
 	length = decodeUint(state);
 	if length != 6 {
-		t.Fatal("6. expected length 6; got", length);
+		t.Fatal("6. expected length 6; got", length)
 	}
 	// 5a) The type id for the et1 value
 	newId1 = decodeInt(state);
 	if newId1 != -id1 {
-		t.Fatal("2nd round: expected Et1 id", -id1, "got", newId1);
+		t.Fatal("2nd round: expected Et1 id", -id1, "got", newId1)
 	}
 	// 6a) The value of et1
 	newEt1 = new(ET1);
 	err = decode(b, et1Id, newEt1);
 	if err != nil {
-		t.Fatal("2nd round: error decoding ET1 value:", err);
+		t.Fatal("2nd round: error decoding ET1 value:", err)
 	}
 	if !reflect.DeepEqual(et1, newEt1) {
-		t.Fatalf("2nd round: invalid data for et1: expected %+v; got %+v\n", *et1, *newEt1);
+		t.Fatalf("2nd round: invalid data for et1: expected %+v; got %+v\n", *et1, *newEt1)
 	}
 	// 7a) EOF
 	if b.Len() != 0 {
-		t.Error("2nd round: not at eof;", b.Len(), "bytes left");
+		t.Error("2nd round: not at eof;", b.Len(), "bytes left")
 	}
 }
 
@@ -156,44 +156,44 @@ func TestEncoderDecoder(t *testing.T) {
 	et1.et2 = new(ET2);
 	enc.Encode(et1);
 	if enc.state.err != nil {
-		t.Error("encoder fail:", enc.state.err);
+		t.Error("encoder fail:", enc.state.err)
 	}
 	dec := NewDecoder(b);
 	newEt1 := new(ET1);
 	dec.Decode(newEt1);
 	if dec.state.err != nil {
-		t.Fatal("error decoding ET1:", dec.state.err);
+		t.Fatal("error decoding ET1:", dec.state.err)
 	}
 
 	if !reflect.DeepEqual(et1, newEt1) {
-		t.Fatalf("invalid data for et1: expected %+v; got %+v\n", *et1, *newEt1);
+		t.Fatalf("invalid data for et1: expected %+v; got %+v\n", *et1, *newEt1)
 	}
 	if b.Len() != 0 {
-		t.Error("not at eof;", b.Len(), "bytes left");
+		t.Error("not at eof;", b.Len(), "bytes left")
 	}
 
 	enc.Encode(et1);
 	newEt1 = new(ET1);
 	dec.Decode(newEt1);
 	if dec.state.err != nil {
-		t.Fatal("round 2: error decoding ET1:", dec.state.err);
+		t.Fatal("round 2: error decoding ET1:", dec.state.err)
 	}
 	if !reflect.DeepEqual(et1, newEt1) {
-		t.Fatalf("round 2: invalid data for et1: expected %+v; got %+v\n", *et1, *newEt1);
+		t.Fatalf("round 2: invalid data for et1: expected %+v; got %+v\n", *et1, *newEt1)
 	}
 	if b.Len() != 0 {
-		t.Error("round 2: not at eof;", b.Len(), "bytes left");
+		t.Error("round 2: not at eof;", b.Len(), "bytes left")
 	}
 
 	// Now test with a running encoder/decoder pair that we recognize a type mismatch.
 	enc.Encode(et1);
 	if enc.state.err != nil {
-		t.Error("round 3: encoder fail:", enc.state.err);
+		t.Error("round 3: encoder fail:", enc.state.err)
 	}
 	newEt2 := new(ET2);
 	dec.Decode(newEt2);
 	if dec.state.err == nil {
-		t.Fatal("round 3: expected `bad type' error decoding ET2");
+		t.Fatal("round 3: expected `bad type' error decoding ET2")
 	}
 }
 
@@ -207,15 +207,15 @@ func badTypeCheck(e interface{}, shouldFail bool, msg string, t *testing.T) {
 	et1.et2 = new(ET2);
 	enc.Encode(et1);
 	if enc.state.err != nil {
-		t.Error("encoder fail:", enc.state.err);
+		t.Error("encoder fail:", enc.state.err)
 	}
 	dec := NewDecoder(b);
 	dec.Decode(e);
 	if shouldFail && (dec.state.err == nil) {
-		t.Error("expected error for", msg);
+		t.Error("expected error for", msg)
 	}
 	if !shouldFail && (dec.state.err != nil) {
-		t.Error("unexpected error for", msg);
+		t.Error("unexpected error for", msg)
 	}
 }
 
@@ -231,7 +231,7 @@ func corruptDataCheck(s string, err os.Error, t *testing.T) {
 	dec := NewDecoder(b);
 	dec.Decode(new(ET2));
 	if dec.state.err != err {
-		t.Error("expected error", err, "got", dec.state.err);
+		t.Error("expected error", err, "got", dec.state.err)
 	}
 }
 
@@ -262,7 +262,7 @@ func TestUnsupported(t *testing.T) {
 	for _, v := range unsupportedValues {
 		err := enc.Encode(v);
 		if err == nil {
-			t.Errorf("expected error for %T; got none", v);
+			t.Errorf("expected error for %T; got none", v)
 		}
 	}
 }
@@ -272,12 +272,12 @@ func encAndDec(in, out interface{}) os.Error {
 	enc := NewEncoder(b);
 	enc.Encode(in);
 	if enc.state.err != nil {
-		return enc.state.err;
+		return enc.state.err
 	}
 	dec := NewDecoder(b);
 	dec.Decode(out);
 	if dec.state.err != nil {
-		return dec.state.err;
+		return dec.state.err
 	}
 	return nil;
 }
@@ -290,7 +290,7 @@ func TestTypeToPtrType(t *testing.T) {
 	t0 := Type0{7};
 	t0p := (*Type0)(nil);
 	if err := encAndDec(t0, t0p); err != nil {
-		t.Error(err);
+		t.Error(err)
 	}
 }
 
@@ -302,7 +302,7 @@ func TestPtrTypeToType(t *testing.T) {
 	t1p := &Type1{17};
 	var t1 Type1;
 	if err := encAndDec(t1, t1p); err != nil {
-		t.Error(err);
+		t.Error(err)
 	}
 }
 
@@ -319,9 +319,9 @@ func TestTypeToPtrPtrPtrPtrType(t *testing.T) {
 	****t2.a = 27.4;
 	t2pppp := new(***Type2);
 	if err := encAndDec(t2, t2pppp); err != nil {
-		t.Error(err);
+		t.Error(err)
 	}
 	if ****(****t2pppp).a != ****t2.a {
-		t.Errorf("wrong value after decode: %g not %g", ****(****t2pppp).a, ****t2.a);
+		t.Errorf("wrong value after decode: %g not %g", ****(****t2pppp).a, ****t2.a)
 	}
 }
diff --git a/src/pkg/gob/type.go b/src/pkg/gob/type.go
index ec8a347e4b..92db7cef38 100644
--- a/src/pkg/gob/type.go
+++ b/src/pkg/gob/type.go
@@ -57,7 +57,7 @@ func setTypeId(typ gobType) {
 
 func (t typeId) gobType() gobType {
 	if t == 0 {
-		return nil;
+		return nil
 	}
 	return idToType[t];
 }
@@ -81,7 +81,7 @@ func (t *commonType) setId(id typeId)	{ t._id = id }
 func (t *commonType) String() string	{ return t.name }
 
 func (t *commonType) safeString(seen map[typeId]bool) string {
-	return t.name;
+	return t.name
 }
 
 func (t *commonType) Name() string	{ return t.name }
@@ -121,7 +121,7 @@ func newArrayType(name string, elem gobType, length int) *arrayType {
 
 func (a *arrayType) safeString(seen map[typeId]bool) string {
 	if _, ok := seen[a._id]; ok {
-		return a.name;
+		return a.name
 	}
 	seen[a._id] = true;
 	return fmt.Sprintf("[%d]%s", a.Len, a.Elem.gobType().safeString(seen));
@@ -143,7 +143,7 @@ func newSliceType(name string, elem gobType) *sliceType {
 
 func (s *sliceType) safeString(seen map[typeId]bool) string {
 	if _, ok := seen[s._id]; ok {
-		return s.name;
+		return s.name
 	}
 	seen[s._id] = true;
 	return fmt.Sprintf("[]%s", s.Elem.gobType().safeString(seen));
@@ -164,15 +164,15 @@ type structType struct {
 
 func (s *structType) safeString(seen map[typeId]bool) string {
 	if s == nil {
-		return "<nil>";
+		return "<nil>"
 	}
 	if _, ok := seen[s._id]; ok {
-		return s.name;
+		return s.name
 	}
 	seen[s._id] = true;
 	str := s.name + " = struct { ";
 	for _, f := range s.field {
-		str += fmt.Sprintf("%s %s; ", f.name, f.id.gobType().safeString(seen));
+		str += fmt.Sprintf("%s %s; ", f.name, f.id.gobType().safeString(seen))
 	}
 	str += "}";
 	return str;
@@ -193,7 +193,7 @@ func indirect(t reflect.Type) (rt reflect.Type, count int) {
 	for {
 		pt, ok := rt.(*reflect.PtrType);
 		if !ok {
-			break;
+			break
 		}
 		rt = pt.Elem();
 		count++;
@@ -205,57 +205,57 @@ func newTypeObject(name string, rt reflect.Type) (gobType, os.Error) {
 	switch t := rt.(type) {
 	// All basic types are easy: they are predefined.
 	case *reflect.BoolType:
-		return tBool.gobType(), nil;
+		return tBool.gobType(), nil
 
 	case *reflect.IntType:
-		return tInt.gobType(), nil;
+		return tInt.gobType(), nil
 	case *reflect.Int8Type:
-		return tInt.gobType(), nil;
+		return tInt.gobType(), nil
 	case *reflect.Int16Type:
-		return tInt.gobType(), nil;
+		return tInt.gobType(), nil
 	case *reflect.Int32Type:
-		return tInt.gobType(), nil;
+		return tInt.gobType(), nil
 	case *reflect.Int64Type:
-		return tInt.gobType(), nil;
+		return tInt.gobType(), nil
 
 	case *reflect.UintType:
-		return tUint.gobType(), nil;
+		return tUint.gobType(), nil
 	case *reflect.Uint8Type:
-		return tUint.gobType(), nil;
+		return tUint.gobType(), nil
 	case *reflect.Uint16Type:
-		return tUint.gobType(), nil;
+		return tUint.gobType(), nil
 	case *reflect.Uint32Type:
-		return tUint.gobType(), nil;
+		return tUint.gobType(), nil
 	case *reflect.Uint64Type:
-		return tUint.gobType(), nil;
+		return tUint.gobType(), nil
 	case *reflect.UintptrType:
-		return tUint.gobType(), nil;
+		return tUint.gobType(), nil
 
 	case *reflect.FloatType:
-		return tFloat.gobType(), nil;
+		return tFloat.gobType(), nil
 	case *reflect.Float32Type:
-		return tFloat.gobType(), nil;
+		return tFloat.gobType(), nil
 	case *reflect.Float64Type:
-		return tFloat.gobType(), nil;
+		return tFloat.gobType(), nil
 
 	case *reflect.StringType:
-		return tString.gobType(), nil;
+		return tString.gobType(), nil
 
 	case *reflect.ArrayType:
 		gt, err := getType("", t.Elem());
 		if err != nil {
-			return nil, err;
+			return nil, err
 		}
 		return newArrayType(name, gt, t.Len()), nil;
 
 	case *reflect.SliceType:
 		// []byte == []uint8 is a special case
 		if _, ok := t.Elem().(*reflect.Uint8Type); ok {
-			return tBytes.gobType(), nil;
+			return tBytes.gobType(), nil
 		}
 		gt, err := getType(t.Elem().Name(), t.Elem());
 		if err != nil {
-			return nil, err;
+			return nil, err
 		}
 		return newSliceType(name, gt), nil;
 
@@ -271,11 +271,11 @@ func newTypeObject(name string, rt reflect.Type) (gobType, os.Error) {
 			typ, _ := indirect(f.Type);
 			tname := typ.Name();
 			if tname == "" {
-				tname = f.Type.String();
+				tname = f.Type.String()
 			}
 			gt, err := getType(tname, f.Type);
 			if err != nil {
-				return nil, err;
+				return nil, err
 			}
 			field[i] = &fieldType{f.Name, gt.id()};
 		}
@@ -283,7 +283,7 @@ func newTypeObject(name string, rt reflect.Type) (gobType, os.Error) {
 		return strType, nil;
 
 	default:
-		return nil, os.ErrorString("gob NewTypeObject can't handle type: " + rt.String());
+		return nil, os.ErrorString("gob NewTypeObject can't handle type: " + rt.String())
 	}
 	return nil, nil;
 }
@@ -295,24 +295,24 @@ func getType(name string, rt reflect.Type) (gobType, os.Error) {
 	for {
 		pt, ok := rt.(*reflect.PtrType);
 		if !ok {
-			break;
+			break
 		}
 		rt = pt.Elem();
 	}
 	typ, present := types[rt];
 	if present {
-		return typ, nil;
+		return typ, nil
 	}
 	typ, err := newTypeObject(name, rt);
 	if err == nil {
-		types[rt] = typ;
+		types[rt] = typ
 	}
 	return typ, err;
 }
 
 func checkId(want, got typeId) {
 	if want != got {
-		panicln("bootstrap type wrong id:", got.Name(), got, "not", want);
+		panicln("bootstrap type wrong id:", got.Name(), got, "not", want)
 	}
 }
 
@@ -321,7 +321,7 @@ func bootstrapType(name string, e interface{}, expect typeId) typeId {
 	rt := reflect.Typeof(e);
 	_, present := types[rt];
 	if present {
-		panicln("bootstrap type already present:", name);
+		panicln("bootstrap type already present:", name)
 	}
 	typ := &commonType{name: name};
 	types[rt] = typ;
@@ -346,7 +346,7 @@ type wireType struct {
 
 func (w *wireType) name() string {
 	// generalize once we can have non-struct types on the wire.
-	return w.s.name;
+	return w.s.name
 }
 
 type typeInfo struct {
@@ -361,7 +361,7 @@ var typeInfoMap = make(map[reflect.Type]*typeInfo)	// protected by typeLock
 // typeLock must be held.
 func getTypeInfo(rt reflect.Type) (*typeInfo, os.Error) {
 	if _, ok := rt.(*reflect.PtrType); ok {
-		panicln("pointer type in getTypeInfo:", rt.String());
+		panicln("pointer type in getTypeInfo:", rt.String())
 	}
 	info, ok := typeInfoMap[rt];
 	if !ok {
@@ -369,7 +369,7 @@ func getTypeInfo(rt reflect.Type) (*typeInfo, os.Error) {
 		name := rt.Name();
 		gt, err := getType(name, rt);
 		if err != nil {
-			return nil, err;
+			return nil, err
 		}
 		info.id = gt.id();
 		// assume it's a struct type
@@ -383,7 +383,7 @@ func getTypeInfo(rt reflect.Type) (*typeInfo, os.Error) {
 func getTypeInfoNoError(rt reflect.Type) *typeInfo {
 	t, err := getTypeInfo(rt);
 	if err != nil {
-		panicln("getTypeInfo:", err.String());
+		panicln("getTypeInfo:", err.String())
 	}
 	return t;
 }
diff --git a/src/pkg/gob/type_test.go b/src/pkg/gob/type_test.go
index 5a137e772b..6983d66129 100644
--- a/src/pkg/gob/type_test.go
+++ b/src/pkg/gob/type_test.go
@@ -28,7 +28,7 @@ func getTypeUnlocked(name string, rt reflect.Type) gobType {
 	defer typeLock.Unlock();
 	t, err := getType(name, rt);
 	if err != nil {
-		panicln("getTypeUnlocked:", err.String());
+		panicln("getTypeUnlocked:", err.String())
 	}
 	return t;
 }
@@ -37,10 +37,10 @@ func getTypeUnlocked(name string, rt reflect.Type) gobType {
 func TestBasic(t *testing.T) {
 	for _, tt := range basicTypes {
 		if tt.id.String() != tt.str {
-			t.Errorf("checkType: expected %q got %s", tt.str, tt.id.String());
+			t.Errorf("checkType: expected %q got %s", tt.str, tt.id.String())
 		}
 		if tt.id == 0 {
-			t.Errorf("id for %q is zero", tt.str);
+			t.Errorf("id for %q is zero", tt.str)
 		}
 	}
 }
@@ -49,15 +49,15 @@ func TestBasic(t *testing.T) {
 func TestReregistration(t *testing.T) {
 	newtyp := getTypeUnlocked("int", reflect.Typeof(int(0)));
 	if newtyp != tInt.gobType() {
-		t.Errorf("reregistration of %s got new type", newtyp.String());
+		t.Errorf("reregistration of %s got new type", newtyp.String())
 	}
 	newtyp = getTypeUnlocked("uint", reflect.Typeof(uint(0)));
 	if newtyp != tUint.gobType() {
-		t.Errorf("reregistration of %s got new type", newtyp.String());
+		t.Errorf("reregistration of %s got new type", newtyp.String())
 	}
 	newtyp = getTypeUnlocked("string", reflect.Typeof("hello"));
 	if newtyp != tString.gobType() {
-		t.Errorf("reregistration of %s got new type", newtyp.String());
+		t.Errorf("reregistration of %s got new type", newtyp.String())
 	}
 }
 
@@ -66,22 +66,22 @@ func TestArrayType(t *testing.T) {
 	a3int := getTypeUnlocked("foo", reflect.Typeof(a3));
 	newa3int := getTypeUnlocked("bar", reflect.Typeof(a3));
 	if a3int != newa3int {
-		t.Errorf("second registration of [3]int creates new type");
+		t.Errorf("second registration of [3]int creates new type")
 	}
 	var a4 [4]int;
 	a4int := getTypeUnlocked("goo", reflect.Typeof(a4));
 	if a3int == a4int {
-		t.Errorf("registration of [3]int creates same type as [4]int");
+		t.Errorf("registration of [3]int creates same type as [4]int")
 	}
 	var b3 [3]bool;
 	a3bool := getTypeUnlocked("", reflect.Typeof(b3));
 	if a3int == a3bool {
-		t.Errorf("registration of [3]bool creates same type as [3]int");
+		t.Errorf("registration of [3]bool creates same type as [3]int")
 	}
 	str := a3bool.String();
 	expected := "[3]bool";
 	if str != expected {
-		t.Errorf("array printed as %q; expected %q", str, expected);
+		t.Errorf("array printed as %q; expected %q", str, expected)
 	}
 }
 
@@ -91,17 +91,17 @@ func TestSliceType(t *testing.T) {
 	var news []int;
 	newsint := getTypeUnlocked("slice1", reflect.Typeof(news));
 	if sint != newsint {
-		t.Errorf("second registration of []int creates new type");
+		t.Errorf("second registration of []int creates new type")
 	}
 	var b []bool;
 	sbool := getTypeUnlocked("", reflect.Typeof(b));
 	if sbool == sint {
-		t.Errorf("registration of []bool creates same type as []int");
+		t.Errorf("registration of []bool creates same type as []int")
 	}
 	str := sbool.String();
 	expected := "[]bool";
 	if str != expected {
-		t.Errorf("slice printed as %q; expected %q", str, expected);
+		t.Errorf("slice printed as %q; expected %q", str, expected)
 	}
 }
 
@@ -128,6 +128,6 @@ func TestStructType(t *testing.T) {
 	// If we can print it correctly, we built it correctly.
 	expected := "Foo = struct { a int; b int; c string; d bytes; e float; f float; g Bar = struct { x string; }; h Bar; i Foo; }";
 	if str != expected {
-		t.Errorf("struct printed as %q; expected %q", str, expected);
+		t.Errorf("struct printed as %q; expected %q", str, expected)
 	}
 }
diff --git a/src/pkg/hash/crc32/crc32.go b/src/pkg/hash/crc32/crc32.go
index e450f5fb74..4e54b09e64 100644
--- a/src/pkg/hash/crc32/crc32.go
+++ b/src/pkg/hash/crc32/crc32.go
@@ -41,9 +41,9 @@ func MakeTable(poly uint32) *Table {
 		crc := uint32(i);
 		for j := 0; j < 8; j++ {
 			if crc&1 == 1 {
-				crc = (crc>>1)^poly;
+				crc = (crc>>1)^poly
 			} else {
-				crc >>= 1;
+				crc >>= 1
 			}
 		}
 		t[i] = crc;
@@ -75,7 +75,7 @@ func (d *digest) Reset()	{ d.crc = 0 }
 func update(crc uint32, tab *Table, p []byte) uint32 {
 	crc = ^crc;
 	for i := 0; i < len(p); i++ {
-		crc = tab[byte(crc)^p[i]]^(crc>>8);
+		crc = tab[byte(crc)^p[i]]^(crc>>8)
 	}
 	return ^crc;
 }
diff --git a/src/pkg/http/client.go b/src/pkg/http/client.go
index bd6949b2d9..1c7f23744b 100644
--- a/src/pkg/http/client.go
+++ b/src/pkg/http/client.go
@@ -49,9 +49,9 @@ func (r *Response) AddHeader(key, value string) {
 
 	oldValues, oldValuesPresent := r.Header[key];
 	if oldValuesPresent {
-		r.Header[key] = oldValues + "," + value;
+		r.Header[key] = oldValues + "," + value
 	} else {
-		r.Header[key] = value;
+		r.Header[key] = value
 	}
 }
 
@@ -76,26 +76,26 @@ func ReadResponse(r *bufio.Reader) (*Response, os.Error) {
 
 	line, err := readLine(r);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	f := strings.Split(line, " ", 3);
 	if len(f) < 3 {
-		return nil, &badStringError{"malformed HTTP response", line};
+		return nil, &badStringError{"malformed HTTP response", line}
 	}
 	resp.Status = f[1]+" "+f[2];
 	resp.StatusCode, err = strconv.Atoi(f[1]);
 	if err != nil {
-		return nil, &badStringError{"malformed HTTP status code", f[1]};
+		return nil, &badStringError{"malformed HTTP status code", f[1]}
 	}
 
 	// Parse the response headers.
 	for {
 		key, value, err := readKeyValue(r);
 		if err != nil {
-			return nil, err;
+			return nil, err
 		}
 		if key == "" {
-			break;	// end of response header
+			break	// end of response header
 		}
 		resp.AddHeader(key, value);
 	}
@@ -111,16 +111,16 @@ func ReadResponse(r *bufio.Reader) (*Response, os.Error) {
 // connections, it may no longer make sense to have a method with this signature.
 func send(req *Request) (resp *Response, err os.Error) {
 	if req.URL.Scheme != "http" {
-		return nil, &badStringError{"unsupported protocol scheme", req.URL.Scheme};
+		return nil, &badStringError{"unsupported protocol scheme", req.URL.Scheme}
 	}
 
 	addr := req.URL.Host;
 	if !hasPort(addr) {
-		addr += ":http";
+		addr += ":http"
 	}
 	conn, err := net.Dial("tcp", "", addr);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	err = req.Write(conn);
@@ -138,11 +138,11 @@ func send(req *Request) (resp *Response, err os.Error) {
 
 	r := io.Reader(reader);
 	if v := resp.GetHeader("Transfer-Encoding"); v == "chunked" {
-		r = newChunkedReader(reader);
+		r = newChunkedReader(reader)
 	} else if v := resp.GetHeader("Content-Length"); v != "" {
 		n, err := strconv.Atoi64(v);
 		if err != nil {
-			return nil, &badStringError{"invalid Content-Length", v};
+			return nil, &badStringError{"invalid Content-Length", v}
 		}
 		r = io.LimitReader(r, n);
 	}
@@ -156,7 +156,7 @@ func send(req *Request) (resp *Response, err os.Error) {
 func shouldRedirect(statusCode int) bool {
 	switch statusCode {
 	case StatusMovedPermanently, StatusFound, StatusSeeOther, StatusTemporaryRedirect:
-		return true;
+		return true
 	}
 	return false;
 }
@@ -185,10 +185,10 @@ func Get(url string) (r *Response, finalURL string, err os.Error) {
 
 		var req Request;
 		if req.URL, err = ParseURL(url); err != nil {
-			break;
+			break
 		}
 		if r, err = send(&req); err != nil {
-			break;
+			break
 		}
 		if shouldRedirect(r.StatusCode) {
 			r.Body.Close();
@@ -221,7 +221,7 @@ func Post(url string, bodyType string, body io.Reader) (r *Response, err os.Erro
 
 	req.URL, err = ParseURL(url);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	return send(&req);
diff --git a/src/pkg/http/client_test.go b/src/pkg/http/client_test.go
index 9e353dc26a..8f52130677 100644
--- a/src/pkg/http/client_test.go
+++ b/src/pkg/http/client_test.go
@@ -23,8 +23,8 @@ func TestClient(t *testing.T) {
 		r.Body.Close();
 	}
 	if err != nil {
-		t.Error(err);
+		t.Error(err)
 	} else if s := string(b); !strings.HasPrefix(s, "User-agent:") {
-		t.Errorf("Incorrect page body (did not begin with User-agent): %q", s);
+		t.Errorf("Incorrect page body (did not begin with User-agent): %q", s)
 	}
 }
diff --git a/src/pkg/http/fs.go b/src/pkg/http/fs.go
index bc42f7b6a4..8ee4ba18c8 100644
--- a/src/pkg/http/fs.go
+++ b/src/pkg/http/fs.go
@@ -33,10 +33,10 @@ func isText(b []byte) bool {
 		rune, size := utf8.DecodeRune(b);
 		if size == 1 && rune == utf8.RuneError {
 			// decoding error
-			return false;
+			return false
 		}
 		if 0x80 <= rune && rune <= 0x9F {
-			return false;
+			return false
 		}
 		if rune < ' ' {
 			switch rune {
@@ -44,7 +44,7 @@ func isText(b []byte) bool {
 				// okay
 			default:
 				// binary garbage
-				return false;
+				return false
 			}
 		}
 		b = b[size:len(b)];
@@ -57,12 +57,12 @@ func dirList(c *Conn, f *os.File) {
 	for {
 		dirs, err := f.Readdir(100);
 		if err != nil || len(dirs) == 0 {
-			break;
+			break
 		}
 		for _, d := range dirs {
 			name := d.Name;
 			if d.IsDirectory() {
-				name += "/";
+				name += "/"
 			}
 			// TODO htmlescape
 			fmt.Fprintf(c, "<a href=\"%s\">%s</a>\n", name, name);
@@ -138,16 +138,16 @@ func serveFileInternal(c *Conn, r *Request, name string, redirect bool) {
 	// use extension to find content type.
 	ext := path.Ext(name);
 	if ctype, ok := contentByExt[ext]; ok {
-		c.SetHeader("Content-Type", ctype);
+		c.SetHeader("Content-Type", ctype)
 	} else {
 		// read first chunk to decide between utf-8 text and binary
 		var buf [1024]byte;
 		n, _ := io.ReadFull(f, &buf);
 		b := buf[0:n];
 		if isText(b) {
-			c.SetHeader("Content-Type", "text-plain; charset=utf-8");
+			c.SetHeader("Content-Type", "text-plain; charset=utf-8")
 		} else {
-			c.SetHeader("Content-Type", "application/octet-stream");	// generic binary
+			c.SetHeader("Content-Type", "application/octet-stream")	// generic binary
 		}
 		c.Write(b);
 	}
@@ -156,7 +156,7 @@ func serveFileInternal(c *Conn, r *Request, name string, redirect bool) {
 
 // ServeFile replies to the request with the contents of the named file or directory.
 func ServeFile(c *Conn, r *Request, name string) {
-	serveFileInternal(c, r, name, false);
+	serveFileInternal(c, r, name, false)
 }
 
 type fileHandler struct {
diff --git a/src/pkg/http/request.go b/src/pkg/http/request.go
index f430005d4e..008f965708 100644
--- a/src/pkg/http/request.go
+++ b/src/pkg/http/request.go
@@ -109,13 +109,13 @@ type Request struct {
 // in the request is at least major.minor.
 func (r *Request) ProtoAtLeast(major, minor int) bool {
 	return r.ProtoMajor > major ||
-		r.ProtoMajor == major && r.ProtoMinor >= minor;
+		r.ProtoMajor == major && r.ProtoMinor >= minor
 }
 
 // Return value if nonempty, def otherwise.
 func valueOrDefault(value, def string) string {
 	if value != "" {
-		return value;
+		return value
 	}
 	return def;
 }
@@ -136,7 +136,7 @@ const defaultUserAgent = "http.Client"
 func (req *Request) Write(w io.Writer) os.Error {
 	uri := URLEscape(req.URL.Path);
 	if req.URL.RawQuery != "" {
-		uri += "?" + req.URL.RawQuery;
+		uri += "?" + req.URL.RawQuery
 	}
 
 	fmt.Fprintf(w, "%s %s HTTP/1.1\r\n", valueOrDefault(req.Method, "GET"), uri);
@@ -144,12 +144,12 @@ func (req *Request) Write(w io.Writer) os.Error {
 	fmt.Fprintf(w, "User-Agent: %s\r\n", valueOrDefault(req.UserAgent, defaultUserAgent));
 
 	if req.Referer != "" {
-		fmt.Fprintf(w, "Referer: %s\r\n", req.Referer);
+		fmt.Fprintf(w, "Referer: %s\r\n", req.Referer)
 	}
 
 	if req.Body != nil {
 		// Force chunked encoding
-		req.Header["Transfer-Encoding"] = "chunked";
+		req.Header["Transfer-Encoding"] = "chunked"
 	}
 
 	// TODO: split long values?  (If so, should share code with Conn.Write)
@@ -160,7 +160,7 @@ func (req *Request) Write(w io.Writer) os.Error {
 	// Response.{GetHeader,AddHeader} and string constants for "Host",
 	// "User-Agent" and "Referer".
 	for k, v := range req.Header {
-		io.WriteString(w, k+": "+v+"\r\n");
+		io.WriteString(w, k+": "+v+"\r\n")
 	}
 
 	io.WriteString(w, "\r\n");
@@ -181,13 +181,13 @@ func (req *Request) Write(w io.Writer) os.Error {
 			switch {
 			case er != nil:
 				if er == os.EOF {
-					break Loop;
+					break Loop
 				}
 				return er;
 			case ew != nil:
-				return ew;
+				return ew
 			case nw < nr:
-				return io.ErrShortWrite;
+				return io.ErrShortWrite
 			}
 		}
 		// last-chunk CRLF
@@ -206,19 +206,19 @@ func readLineBytes(b *bufio.Reader) (p []byte, err os.Error) {
 		// We always know when EOF is coming.
 		// If the caller asked for a line, there should be a line.
 		if err == os.EOF {
-			err = io.ErrUnexpectedEOF;
+			err = io.ErrUnexpectedEOF
 		}
 		return nil, err;
 	}
 	if len(p) >= maxLineLength {
-		return nil, ErrLineTooLong;
+		return nil, ErrLineTooLong
 	}
 
 	// Chop off trailing white space.
 	var i int;
 	for i = len(p); i > 0; i-- {
 		if c := p[i-1]; c != ' ' && c != '\r' && c != '\t' && c != '\n' {
-			break;
+			break
 		}
 	}
 	return p[0:i], nil;
@@ -228,7 +228,7 @@ func readLineBytes(b *bufio.Reader) (p []byte, err os.Error) {
 func readLine(b *bufio.Reader) (s string, err os.Error) {
 	p, e := readLineBytes(b);
 	if e != nil {
-		return "", e;
+		return "", e
 	}
 	return string(p), nil;
 }
@@ -242,28 +242,28 @@ var colon = []byte{':'}
 func readKeyValue(b *bufio.Reader) (key, value string, err os.Error) {
 	line, e := readLineBytes(b);
 	if e != nil {
-		return "", "", e;
+		return "", "", e
 	}
 	if len(line) == 0 {
-		return "", "", nil;
+		return "", "", nil
 	}
 
 	// Scan first line for colon.
 	i := bytes.Index(line, colon);
 	if i < 0 {
-		goto Malformed;
+		goto Malformed
 	}
 
 	key = string(line[0:i]);
 	if strings.Index(key, " ") >= 0 {
 		// Key field has space - no good.
-		goto Malformed;
+		goto Malformed
 	}
 
 	// Skip initial space before value.
 	for i++; i < len(line); i++ {
 		if line[i] != ' ' {
-			break;
+			break
 		}
 	}
 	value = string(line[i:len(line)]);
@@ -273,7 +273,7 @@ func readKeyValue(b *bufio.Reader) (key, value string, err os.Error) {
 		c, e := b.ReadByte();
 		if c != ' ' {
 			if e != os.EOF {
-				b.UnreadByte();
+				b.UnreadByte()
 			}
 			break;
 		}
@@ -282,7 +282,7 @@ func readKeyValue(b *bufio.Reader) (key, value string, err os.Error) {
 		for c == ' ' {
 			if c, e = b.ReadByte(); e != nil {
 				if e == os.EOF {
-					e = io.ErrUnexpectedEOF;
+					e = io.ErrUnexpectedEOF
 				}
 				return "", "", e;
 			}
@@ -291,12 +291,12 @@ func readKeyValue(b *bufio.Reader) (key, value string, err os.Error) {
 
 		// Read the rest of the line and add to value.
 		if line, e = readLineBytes(b); e != nil {
-			return "", "", e;
+			return "", "", e
 		}
 		value += " "+string(line);
 
 		if len(value) >= maxValueLength {
-			return "", "", &badStringError{"value too long for key", key};
+			return "", "", &badStringError{"value too long for key", key}
 		}
 	}
 	return key, value, nil;
@@ -311,13 +311,13 @@ Malformed:
 func atoi(s string, i int) (n, i1 int, ok bool) {
 	const Big = 1000000;
 	if i >= len(s) || s[i] < '0' || s[i] > '9' {
-		return 0, 0, false;
+		return 0, 0, false
 	}
 	n = 0;
 	for ; i < len(s) && '0' <= s[i] && s[i] <= '9'; i++ {
 		n = n*10 + int(s[i]-'0');
 		if n > Big {
-			return 0, 0, false;
+			return 0, 0, false
 		}
 	}
 	return n, i, true;
@@ -326,16 +326,16 @@ func atoi(s string, i int) (n, i1 int, ok bool) {
 // Parse HTTP version: "HTTP/1.2" -> (1, 2, true).
 func parseHTTPVersion(vers string) (int, int, bool) {
 	if vers[0:5] != "HTTP/" {
-		return 0, 0, false;
+		return 0, 0, false
 	}
 	major, i, ok := atoi(vers, 5);
 	if !ok || i >= len(vers) || vers[i] != '.' {
-		return 0, 0, false;
+		return 0, 0, false
 	}
 	var minor int;
 	minor, i, ok = atoi(vers, i+1);
 	if !ok || i != len(vers) {
-		return 0, 0, false;
+		return 0, 0, false
 	}
 	return major, minor, true;
 }
@@ -349,7 +349,7 @@ var cmap = make(map[string]string)
 // canonical key for "accept-encoding" is "Accept-Encoding".
 func CanonicalHeaderKey(s string) string {
 	if t, ok := cmap[s]; ok {
-		return t;
+		return t
 	}
 
 	// canonicalize: first letter upper case
@@ -360,14 +360,14 @@ func CanonicalHeaderKey(s string) string {
 	upper := true;
 	for i, v := range a {
 		if upper && 'a' <= v && v <= 'z' {
-			a[i] = v+'A'-'a';
+			a[i] = v+'A'-'a'
 		}
 		if !upper && 'A' <= v && v <= 'Z' {
-			a[i] = v+'a'-'A';
+			a[i] = v+'a'-'A'
 		}
 		upper = false;
 		if v == '-' {
-			upper = true;
+			upper = true
 		}
 	}
 	t := string(a);
@@ -382,7 +382,7 @@ type chunkedReader struct {
 }
 
 func newChunkedReader(r *bufio.Reader) *chunkedReader {
-	return &chunkedReader{r: r};
+	return &chunkedReader{r: r}
 }
 
 func (cr *chunkedReader) beginChunk() {
@@ -390,21 +390,21 @@ func (cr *chunkedReader) beginChunk() {
 	var line string;
 	line, cr.err = readLine(cr.r);
 	if cr.err != nil {
-		return;
+		return
 	}
 	cr.n, cr.err = strconv.Btoui64(line, 16);
 	if cr.err != nil {
-		return;
+		return
 	}
 	if cr.n == 0 {
 		// trailer CRLF
 		for {
 			line, cr.err = readLine(cr.r);
 			if cr.err != nil {
-				return;
+				return
 			}
 			if line == "" {
-				break;
+				break
 			}
 		}
 		cr.err = os.EOF;
@@ -413,16 +413,16 @@ func (cr *chunkedReader) beginChunk() {
 
 func (cr *chunkedReader) Read(b []uint8) (n int, err os.Error) {
 	if cr.err != nil {
-		return 0, cr.err;
+		return 0, cr.err
 	}
 	if cr.n == 0 {
 		cr.beginChunk();
 		if cr.err != nil {
-			return 0, cr.err;
+			return 0, cr.err
 		}
 	}
 	if uint64(len(b)) > cr.n {
-		b = b[0 : cr.n];
+		b = b[0 : cr.n]
 	}
 	n, cr.err = cr.r.Read(b);
 	cr.n -= uint64(n);
@@ -431,7 +431,7 @@ func (cr *chunkedReader) Read(b []uint8) (n int, err os.Error) {
 		b := make([]byte, 2);
 		if _, cr.err = io.ReadFull(cr.r, b); cr.err == nil {
 			if b[0] != '\r' || b[1] != '\n' {
-				cr.err = os.NewError("malformed chunked encoding");
+				cr.err = os.NewError("malformed chunked encoding")
 			}
 		}
 	}
@@ -445,21 +445,21 @@ func ReadRequest(b *bufio.Reader) (req *Request, err os.Error) {
 	// First line: GET /index.html HTTP/1.0
 	var s string;
 	if s, err = readLine(b); err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	var f []string;
 	if f = strings.Split(s, " ", 3); len(f) < 3 {
-		return nil, &badStringError{"malformed HTTP request", s};
+		return nil, &badStringError{"malformed HTTP request", s}
 	}
 	req.Method, req.RawURL, req.Proto = f[0], f[1], f[2];
 	var ok bool;
 	if req.ProtoMajor, req.ProtoMinor, ok = parseHTTPVersion(req.Proto); !ok {
-		return nil, &badStringError{"malformed HTTP version", req.Proto};
+		return nil, &badStringError{"malformed HTTP version", req.Proto}
 	}
 
 	if req.URL, err = ParseURL(req.RawURL); err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	// Subsequent lines: Key: value.
@@ -468,13 +468,13 @@ func ReadRequest(b *bufio.Reader) (req *Request, err os.Error) {
 	for {
 		var key, value string;
 		if key, value, err = readKeyValue(b); err != nil {
-			return nil, err;
+			return nil, err
 		}
 		if key == "" {
-			break;
+			break
 		}
 		if nheader++; nheader >= maxHeaderLines {
-			return nil, ErrHeaderTooLong;
+			return nil, ErrHeaderTooLong
 		}
 
 		key = CanonicalHeaderKey(key);
@@ -484,9 +484,9 @@ func ReadRequest(b *bufio.Reader) (req *Request, err os.Error) {
 		// to concatenating the values separated by commas.
 		oldvalue, present := req.Header[key];
 		if present {
-			req.Header[key] = oldvalue+","+value;
+			req.Header[key] = oldvalue+","+value
 		} else {
-			req.Header[key] = value;
+			req.Header[key] = value
 		}
 	}
 
@@ -498,7 +498,7 @@ func ReadRequest(b *bufio.Reader) (req *Request, err os.Error) {
 	//	Host: doesntmatter
 	// the same.  In the second case, any Host line is ignored.
 	if v, present := req.Header["Host"]; present && req.URL.Host == "" {
-		req.Host = v;
+		req.Host = v
 	}
 
 	// RFC2616: Should treat
@@ -507,27 +507,27 @@ func ReadRequest(b *bufio.Reader) (req *Request, err os.Error) {
 	//	Cache-Control: no-cache
 	if v, present := req.Header["Pragma"]; present && v == "no-cache" {
 		if _, presentcc := req.Header["Cache-Control"]; !presentcc {
-			req.Header["Cache-Control"] = "no-cache";
+			req.Header["Cache-Control"] = "no-cache"
 		}
 	}
 
 	// Determine whether to hang up after sending the reply.
 	if req.ProtoMajor < 1 || (req.ProtoMajor == 1 && req.ProtoMinor < 1) {
-		req.Close = true;
+		req.Close = true
 	} else if v, present := req.Header["Connection"]; present {
 		// TODO: Should split on commas, toss surrounding white space,
 		// and check each field.
 		if v == "close" {
-			req.Close = true;
+			req.Close = true
 		}
 	}
 
 	// Pull out useful fields as a convenience to clients.
 	if v, present := req.Header["Referer"]; present {
-		req.Referer = v;
+		req.Referer = v
 	}
 	if v, present := req.Header["User-Agent"]; present {
-		req.UserAgent = v;
+		req.UserAgent = v
 	}
 
 	// TODO: Parse specific header values:
@@ -559,17 +559,17 @@ func ReadRequest(b *bufio.Reader) (req *Request, err os.Error) {
 	// A message body exists when either Content-Length or Transfer-Encoding
 	// headers are present. Transfer-Encoding trumps Content-Length.
 	if v, present := req.Header["Transfer-Encoding"]; present && v == "chunked" {
-		req.Body = newChunkedReader(b);
+		req.Body = newChunkedReader(b)
 	} else if v, present := req.Header["Content-Length"]; present {
 		length, err := strconv.Btoui64(v, 10);
 		if err != nil {
-			return nil, &badStringError{"invalid Content-Length", v};
+			return nil, &badStringError{"invalid Content-Length", v}
 		}
 		// TODO: limit the Content-Length. This is an easy DoS vector.
 		raw := make([]byte, length);
 		n, err := b.Read(raw);
 		if err != nil || uint64(n) < length {
-			return nil, ErrShortBody;
+			return nil, ErrShortBody
 		}
 		req.Body = bytes.NewBuffer(raw);
 	}
@@ -586,10 +586,10 @@ func parseForm(query string) (m map[string][]string, err os.Error) {
 		var e os.Error;
 		key, e = URLUnescape(kvPair[0]);
 		if e == nil && len(kvPair) > 1 {
-			value, e = URLUnescape(kvPair[1]);
+			value, e = URLUnescape(kvPair[1])
 		}
 		if e != nil {
-			err = e;
+			err = e
 		}
 
 		vec, ok := data[key];
@@ -602,7 +602,7 @@ func parseForm(query string) (m map[string][]string, err os.Error) {
 
 	m = make(map[string][]string);
 	for k, vec := range data {
-		m[k] = vec.Data();
+		m[k] = vec.Data()
 	}
 
 	return;
@@ -612,29 +612,29 @@ func parseForm(query string) (m map[string][]string, err os.Error) {
 // It is idempotent.
 func (r *Request) ParseForm() (err os.Error) {
 	if r.Form != nil {
-		return;
+		return
 	}
 
 	var query string;
 
 	switch r.Method {
 	case "GET":
-		query = r.URL.RawQuery;
+		query = r.URL.RawQuery
 	case "POST":
 		if r.Body == nil {
-			return os.ErrorString("missing form body");
+			return os.ErrorString("missing form body")
 		}
 		ct, _ := r.Header["Content-Type"];
 		switch strings.Split(ct, ";", 2)[0] {
 		case "text/plain", "application/x-www-form-urlencoded", "":
 			var b []byte;
 			if b, err = io.ReadAll(r.Body); err != nil {
-				return;
+				return
 			}
 			query = string(b);
 		// TODO(dsymonds): Handle multipart/form-data
 		default:
-			return &badStringError{"unknown Content-Type", ct};
+			return &badStringError{"unknown Content-Type", ct}
 		}
 	}
 	r.Form, err = parseForm(query);
@@ -645,10 +645,10 @@ func (r *Request) ParseForm() (err os.Error) {
 // FormValue calls ParseForm if necessary.
 func (r *Request) FormValue(key string) string {
 	if r.Form == nil {
-		r.ParseForm();
+		r.ParseForm()
 	}
 	if vs, ok := r.Form[key]; ok && len(vs) > 0 {
-		return vs[0];
+		return vs[0]
 	}
 	return "";
 }
diff --git a/src/pkg/http/request_test.go b/src/pkg/http/request_test.go
index 391b6cb009..200aa14e9f 100644
--- a/src/pkg/http/request_test.go
+++ b/src/pkg/http/request_test.go
@@ -39,7 +39,7 @@ func TestParseForm(t *testing.T) {
 			continue;
 		}
 		if len(form) != len(test.out) {
-			t.Errorf("test %d: len(form) = %d, want %d", i, len(form), len(test.out));
+			t.Errorf("test %d: len(form) = %d, want %d", i, len(form), len(test.out))
 		}
 		for k, evs := range test.out {
 			vs, ok := form[k];
@@ -53,7 +53,7 @@ func TestParseForm(t *testing.T) {
 			}
 			for j, ev := range evs {
 				if v := vs[j]; v != ev {
-					t.Errorf("test %d: form[%q][%d] = %q, want %q", i, k, j, v, ev);
+					t.Errorf("test %d: form[%q][%d] = %q, want %q", i, k, j, v, ev)
 				}
 			}
 		}
@@ -64,7 +64,7 @@ func TestQuery(t *testing.T) {
 	req := &Request{Method: "GET"};
 	req.URL, _ = ParseURL("http://www.google.com/search?q=foo&q=bar");
 	if q := req.FormValue("q"); q != "foo" {
-		t.Errorf(`req.FormValue("q") = %q, want "foo"`, q);
+		t.Errorf(`req.FormValue("q") = %q, want "foo"`, q)
 	}
 }
 
@@ -93,10 +93,10 @@ func TestPostContentTypeParsing(t *testing.T) {
 		};
 		err := req.ParseForm();
 		if !test.error && err != nil {
-			t.Errorf("test %d: Unexpected error: %v", i, err);
+			t.Errorf("test %d: Unexpected error: %v", i, err)
 		}
 		if test.error && err == nil {
-			t.Errorf("test %d should have returned error", i);
+			t.Errorf("test %d should have returned error", i)
 		}
 	}
 }
@@ -108,10 +108,10 @@ func TestRedirect(t *testing.T) {
 	)
 	r, url, err := Get(start);
 	if err != nil {
-		t.Fatal(err);
+		t.Fatal(err)
 	}
 	r.Body.Close();
 	if r.StatusCode != 200 || url != end {
-		t.Fatalf("Get(%s) got status %d at %s, want 200 at %s", start, r.StatusCode, url, end);
+		t.Fatalf("Get(%s) got status %d at %s, want 200 at %s", start, r.StatusCode, url, end)
 	}
 }
diff --git a/src/pkg/http/server.go b/src/pkg/http/server.go
index c155b77252..9651cee338 100644
--- a/src/pkg/http/server.go
+++ b/src/pkg/http/server.go
@@ -59,7 +59,7 @@ type Conn struct {
 func newConn(rwc net.Conn, handler Handler) (c *Conn, err os.Error) {
 	c = new(Conn);
 	if a := rwc.RemoteAddr(); a != nil {
-		c.RemoteAddr = a.String();
+		c.RemoteAddr = a.String()
 	}
 	c.handler = handler;
 	c.rwc = rwc;
@@ -72,10 +72,10 @@ func newConn(rwc net.Conn, handler Handler) (c *Conn, err os.Error) {
 // Read next request from connection.
 func (c *Conn) readRequest() (req *Request, err os.Error) {
 	if c.hijacked {
-		return nil, ErrHijacked;
+		return nil, ErrHijacked
 	}
 	if req, err = ReadRequest(c.buf.Reader); err != nil {
-		return nil, err;
+		return nil, err
 	}
 
 	// Reset per-request connection state.
@@ -135,20 +135,20 @@ func (c *Conn) WriteHeader(code int) {
 	c.status = code;
 	c.written = 0;
 	if !c.Req.ProtoAtLeast(1, 0) {
-		return;
+		return
 	}
 	proto := "HTTP/1.0";
 	if c.Req.ProtoAtLeast(1, 1) {
-		proto = "HTTP/1.1";
+		proto = "HTTP/1.1"
 	}
 	codestring := strconv.Itoa(code);
 	text, ok := statusText[code];
 	if !ok {
-		text = "status code " + codestring;
+		text = "status code " + codestring
 	}
 	io.WriteString(c.buf, proto + " " + codestring + " " + text + "\r\n");
 	for k, v := range c.header {
-		io.WriteString(c.buf, k+": "+v+"\r\n");
+		io.WriteString(c.buf, k+": "+v+"\r\n")
 	}
 	io.WriteString(c.buf, "\r\n");
 }
@@ -162,10 +162,10 @@ func (c *Conn) Write(data []byte) (n int, err os.Error) {
 		return 0, ErrHijacked;
 	}
 	if !c.wroteHeader {
-		c.WriteHeader(StatusOK);
+		c.WriteHeader(StatusOK)
 	}
 	if len(data) == 0 {
-		return 0, nil;
+		return 0, nil
 	}
 
 	c.written += int64(len(data));	// ignoring errors, for errorKludge
@@ -174,15 +174,15 @@ func (c *Conn) Write(data []byte) (n int, err os.Error) {
 	// then there would be fewer chunk headers.
 	// On the other hand, it would make hijacking more difficult.
 	if c.chunking {
-		fmt.Fprintf(c.buf, "%x\r\n", len(data));	// TODO(rsc): use strconv not fmt
+		fmt.Fprintf(c.buf, "%x\r\n", len(data))	// TODO(rsc): use strconv not fmt
 	}
 	n, err = c.buf.Write(data);
 	if err == nil && c.chunking {
 		if n != len(data) {
-			err = io.ErrShortWrite;
+			err = io.ErrShortWrite
 		}
 		if err == nil {
-			io.WriteString(c.buf, "\r\n");
+			io.WriteString(c.buf, "\r\n")
 		}
 	}
 
@@ -201,23 +201,23 @@ func errorKludge(c *Conn, req *Request) {
 
 	// Is this an error?
 	if kind := c.status / 100; kind != 4 && kind != 5 {
-		return;
+		return
 	}
 
 	// Did the handler supply any info?  Enough?
 	if c.written == 0 || c.written >= min {
-		return;
+		return
 	}
 
 	// Is it a broken browser?
 	var msg string;
 	switch agent := req.UserAgent; {
 	case strings.Index(agent, "MSIE") >= 0:
-		msg = "Internet Explorer";
+		msg = "Internet Explorer"
 	case strings.Index(agent, "Chrome/") >= 0:
-		msg = "Chrome";
+		msg = "Chrome"
 	default:
-		return;
+		return
 	}
 	msg += " would ignore this error page if this text weren't here.\n";
 
@@ -227,20 +227,20 @@ func errorKludge(c *Conn, req *Request) {
 	case "text/html":
 		io.WriteString(c, "<!-- ");
 		for c.written < min {
-			io.WriteString(c, msg);
+			io.WriteString(c, msg)
 		}
 		io.WriteString(c, " -->");
 	case "text/plain":
 		io.WriteString(c, "\n");
 		for c.written < min {
-			io.WriteString(c, msg);
+			io.WriteString(c, msg)
 		}
 	}
 }
 
 func (c *Conn) flush() {
 	if !c.wroteHeader {
-		c.WriteHeader(StatusOK);
+		c.WriteHeader(StatusOK)
 	}
 	errorKludge(c, c.Req);
 	if c.chunking {
@@ -268,18 +268,18 @@ func (c *Conn) serve() {
 	for {
 		req, err := c.readRequest();
 		if err != nil {
-			break;
+			break
 		}
 		// HTTP cannot have multiple simultaneous active requests.
 		// Until the server replies to this request, it can't read another,
 		// so we might as well run the handler in this goroutine.
 		c.handler.ServeHTTP(c, req);
 		if c.hijacked {
-			return;
+			return
 		}
 		c.flush();
 		if c.closeAfterReply {
-			break;
+			break
 		}
 	}
 	c.close();
@@ -292,7 +292,7 @@ func (c *Conn) serve() {
 // and close the connection.
 func (c *Conn) Hijack() (rwc io.ReadWriteCloser, buf *bufio.ReadWriter, err os.Error) {
 	if c.hijacked {
-		return nil, nil, ErrHijacked;
+		return nil, nil, ErrHijacked
 	}
 	c.hijacked = true;
 	rwc = c.rwc;
@@ -310,7 +310,7 @@ type HandlerFunc func(*Conn, *Request)
 
 // ServeHTTP calls f(c, req).
 func (f HandlerFunc) ServeHTTP(c *Conn, req *Request) {
-	f(c, req);
+	f(c, req)
 }
 
 // Helper handlers
@@ -333,12 +333,12 @@ func Redirect(c *Conn, url string, code int) {
 	// response because older user agents may not understand 301/307.
 	note := "<a href=\"%v\">" + statusText[code] + "</a>.\n";
 	if c.Req.Method == "POST" {
-		note = "";
+		note = ""
 	}
 
 	u, err := ParseURL(url);
 	if err != nil {
-		goto finish;
+		goto finish
 	}
 
 	// If url was relative, make absolute by
@@ -359,7 +359,7 @@ func Redirect(c *Conn, url string, code int) {
 	// So do we.
 	oldpath := c.Req.URL.Path;
 	if oldpath == "" {	// should not happen, but avoid a crash if it does
-		oldpath = "/";
+		oldpath = "/"
 	}
 	if u.Scheme == "" {
 		// no leading http://server
@@ -373,7 +373,7 @@ func Redirect(c *Conn, url string, code int) {
 		trailing := url[len(url)-1] == '/';
 		url = path.Clean(url);
 		if trailing && url[len(url)-1] != '/' {
-			url += "/";
+			url += "/"
 		}
 	}
 
@@ -390,14 +390,14 @@ type redirectHandler struct {
 }
 
 func (rh *redirectHandler) ServeHTTP(c *Conn, req *Request) {
-	Redirect(c, rh.url, rh.code);
+	Redirect(c, rh.url, rh.code)
 }
 
 // RedirectHandler returns a request handler that redirects
 // each request it receives to the given url using the given
 // status code.
 func RedirectHandler(url string, code int) Handler {
-	return &redirectHandler{url, code};
+	return &redirectHandler{url, code}
 }
 
 // ServeMux is an HTTP request multiplexer.
@@ -438,11 +438,11 @@ var DefaultServeMux = NewServeMux()
 func pathMatch(pattern, path string) bool {
 	if len(pattern) == 0 {
 		// should not happen
-		return false;
+		return false
 	}
 	n := len(pattern);
 	if pattern[n-1] != '/' {
-		return pattern == path;
+		return pattern == path
 	}
 	return len(path) >= n && path[0:n] == pattern;
 }
@@ -450,16 +450,16 @@ func pathMatch(pattern, path string) bool {
 // Return the canonical path for p, eliminating . and .. elements.
 func cleanPath(p string) string {
 	if p == "" {
-		return "/";
+		return "/"
 	}
 	if p[0] != '/' {
-		p = "/"+p;
+		p = "/"+p
 	}
 	np := path.Clean(p);
 	// path.Clean removes trailing slash except for root;
 	// put the trailing slash back if necessary.
 	if p[len(p)-1] == '/' && np != "/" {
-		np += "/";
+		np += "/"
 	}
 	return np;
 }
@@ -479,7 +479,7 @@ func (mux *ServeMux) ServeHTTP(c *Conn, req *Request) {
 	var n = 0;
 	for k, v := range mux.m {
 		if !pathMatch(k, req.URL.Path) {
-			continue;
+			continue
 		}
 		if h == nil || len(k) > n {
 			n = len(k);
@@ -487,7 +487,7 @@ func (mux *ServeMux) ServeHTTP(c *Conn, req *Request) {
 		}
 	}
 	if h == nil {
-		h = NotFoundHandler();
+		h = NotFoundHandler()
 	}
 	h.ServeHTTP(c, req);
 }
@@ -495,7 +495,7 @@ func (mux *ServeMux) ServeHTTP(c *Conn, req *Request) {
 // Handle registers the handler for the given pattern.
 func (mux *ServeMux) Handle(pattern string, handler Handler) {
 	if pattern == "" || pattern[0] != '/' {
-		panicln("http: invalid pattern", pattern);
+		panicln("http: invalid pattern", pattern)
 	}
 
 	mux.m[pattern] = handler;
@@ -504,7 +504,7 @@ func (mux *ServeMux) Handle(pattern string, handler Handler) {
 	// If pattern is /tree/, insert permanent redirect for /tree.
 	n := len(pattern);
 	if n > 0 && pattern[n-1] == '/' {
-		mux.m[pattern[0 : n-1]] = RedirectHandler(pattern, StatusMovedPermanently);
+		mux.m[pattern[0 : n-1]] = RedirectHandler(pattern, StatusMovedPermanently)
 	}
 }
 
@@ -518,16 +518,16 @@ func Handle(pattern string, handler Handler)	{ DefaultServeMux.Handle(pattern, h
 // Handler is typically nil, in which case the DefaultServeMux is used.
 func Serve(l net.Listener, handler Handler) os.Error {
 	if handler == nil {
-		handler = DefaultServeMux;
+		handler = DefaultServeMux
 	}
 	for {
 		rw, e := l.Accept();
 		if e != nil {
-			return e;
+			return e
 		}
 		c, err := newConn(rw, handler);
 		if err != nil {
-			continue;
+			continue
 		}
 		go c.serve();
 	}
@@ -563,7 +563,7 @@ func Serve(l net.Listener, handler Handler) os.Error {
 func ListenAndServe(addr string, handler Handler) os.Error {
 	l, e := net.Listen("tcp", addr);
 	if e != nil {
-		return e;
+		return e
 	}
 	e = Serve(l, handler);
 	l.Close();
diff --git a/src/pkg/http/triv.go b/src/pkg/http/triv.go
index cd983fe6fe..529a6ebffb 100644
--- a/src/pkg/http/triv.go
+++ b/src/pkg/http/triv.go
@@ -38,13 +38,13 @@ func (ctr *Counter) String() string	{ return fmt.Sprintf("%d", ctr.n) }
 func (ctr *Counter) ServeHTTP(c *http.Conn, req *http.Request) {
 	switch req.Method {
 	case "GET":
-		ctr.n++;
+		ctr.n++
 	case "POST":
 		buf := new(bytes.Buffer);
 		io.Copy(buf, req.Body);
 		body := buf.String();
 		if n, err := strconv.Atoi(body); err != nil {
-			fmt.Fprintf(c, "bad POST: %v\nbody: [%v]\n", err, body);
+			fmt.Fprintf(c, "bad POST: %v\nbody: [%v]\n", err, body)
 		} else {
 			ctr.n = n;
 			fmt.Fprint(c, "counter reset\n");
@@ -80,9 +80,9 @@ func FlagServer(c *http.Conn, req *http.Request) {
 	fmt.Fprint(c, "Flags:\n");
 	flag.VisitAll(func(f *flag.Flag) {
 		if f.Value.String() != f.DefValue {
-			fmt.Fprintf(c, "%s = %s [default = %s]\n", f.Name, f.Value.String(), f.DefValue);
+			fmt.Fprintf(c, "%s = %s [default = %s]\n", f.Name, f.Value.String(), f.DefValue)
 		} else {
-			fmt.Fprintf(c, "%s = %s\n", f.Name, f.Value.String());
+			fmt.Fprintf(c, "%s = %s\n", f.Name, f.Value.String())
 		}
 	});
 }
@@ -90,7 +90,7 @@ func FlagServer(c *http.Conn, req *http.Request) {
 // simple argument server
 func ArgServer(c *http.Conn, req *http.Request) {
 	for i, s := range os.Args {
-		fmt.Fprint(c, s, " ");
+		fmt.Fprint(c, s, " ")
 	}
 }
 
@@ -101,14 +101,14 @@ func ChanCreate() Chan {
 	c := make(Chan);
 	go func(c Chan) {
 		for x := 0; ; x++ {
-			c <- x;
+			c <- x
 		}
 	}(c);
 	return c;
 }
 
 func (ch Chan) ServeHTTP(c *http.Conn, req *http.Request) {
-	io.WriteString(c, fmt.Sprintf("channel send #%d\n", <-ch));
+	io.WriteString(c, fmt.Sprintf("channel send #%d\n", <-ch))
 }
 
 // exec a program, redirecting output
@@ -154,6 +154,6 @@ func main() {
 	http.Handle("/date", http.HandlerFunc(DateServer));
 	err := http.ListenAndServe(":12345", nil);
 	if err != nil {
-		log.Crash("ListenAndServe: ", err);
+		log.Crash("ListenAndServe: ", err)
 	}
 }
diff --git a/src/pkg/http/url.go b/src/pkg/http/url.go
index 526c96aa23..a19e8a5189 100644
--- a/src/pkg/http/url.go
+++ b/src/pkg/http/url.go
@@ -25,11 +25,11 @@ func (e *URLError) String() string	{ return e.Op + " " + e.URL + ": " + e.Error.
 func ishex(c byte) bool {
 	switch {
 	case '0' <= c && c <= '9':
-		return true;
+		return true
 	case 'a' <= c && c <= 'f':
-		return true;
+		return true
 	case 'A' <= c && c <= 'F':
-		return true;
+		return true
 	}
 	return false;
 }
@@ -37,11 +37,11 @@ func ishex(c byte) bool {
 func unhex(c byte) byte {
 	switch {
 	case '0' <= c && c <= '9':
-		return c-'0';
+		return c-'0'
 	case 'a' <= c && c <= 'f':
-		return c-'a'+10;
+		return c-'a'+10
 	case 'A' <= c && c <= 'F':
-		return c-'A'+10;
+		return c-'A'+10
 	}
 	return 0;
 }
@@ -49,7 +49,7 @@ func unhex(c byte) byte {
 type URLEscapeError string
 
 func (e URLEscapeError) String() string {
-	return "invalid URL escape " + strconv.Quote(string(e));
+	return "invalid URL escape " + strconv.Quote(string(e))
 }
 
 // Return true if the specified character should be escaped when appearing in a
@@ -60,7 +60,7 @@ func (e URLEscapeError) String() string {
 func shouldEscape(c byte) bool {
 	switch c {
 	case ' ', '?', '&', '=', '#', '+', '%':
-		return true;
+		return true
 	}
 	return false;
 }
@@ -80,7 +80,7 @@ func URLUnescape(s string) (string, os.Error) {
 			if i+2 >= len(s) || !ishex(s[i+1]) || !ishex(s[i+2]) {
 				s = s[i:len(s)];
 				if len(s) > 3 {
-					s = s[0:3];
+					s = s[0:3]
 				}
 				return "", URLEscapeError(s);
 			}
@@ -89,12 +89,12 @@ func URLUnescape(s string) (string, os.Error) {
 			hasPlus = true;
 			i++;
 		default:
-			i++;
+			i++
 		}
 	}
 
 	if n == 0 && !hasPlus {
-		return s, nil;
+		return s, nil
 	}
 
 	t := make([]byte, len(s) - 2*n);
@@ -125,15 +125,15 @@ func URLEscape(s string) string {
 		c := s[i];
 		if shouldEscape(c) {
 			if c == ' ' {
-				spaceCount++;
+				spaceCount++
 			} else {
-				hexCount++;
+				hexCount++
 			}
 		}
 	}
 
 	if spaceCount == 0 && hexCount == 0 {
-		return s;
+		return s
 	}
 
 	t := make([]byte, len(s) + 2*hexCount);
@@ -188,17 +188,17 @@ func getscheme(rawurl string) (scheme, path string, err os.Error) {
 		// do nothing
 		case '0' <= c && c <= '9' || c == '+' || c == '-' || c == '.':
 			if i == 0 {
-				return "", rawurl, nil;
+				return "", rawurl, nil
 			}
 		case c == ':':
 			if i == 0 {
-				return "", "", os.ErrorString("missing protocol scheme");
+				return "", "", os.ErrorString("missing protocol scheme")
 			}
 			return rawurl[0:i], rawurl[i+1 : len(rawurl)], nil;
 		default:
 			// we have encountered an invalid character,
 			// so there is no valid scheme
-			return "", rawurl, nil;
+			return "", rawurl, nil
 		}
 	}
 	return "", rawurl, nil;
@@ -211,7 +211,7 @@ func split(s string, c byte, cutc bool) (string, string) {
 	for i := 0; i < len(s); i++ {
 		if s[i] == c {
 			if cutc {
-				return s[0:i], s[i+1 : len(s)];
+				return s[0:i], s[i+1 : len(s)]
 			}
 			return s[0:i], s[i:len(s)];
 		}
@@ -240,41 +240,41 @@ func ParseURL(rawurl string) (url *URL, err os.Error) {
 	// split off possible leading "http:", "mailto:", etc.
 	var path string;
 	if url.Scheme, path, err = getscheme(rawurl); err != nil {
-		goto Error;
+		goto Error
 	}
 	url.RawPath = path;
 
 	// RFC 2396: a relative URI (no scheme) has a ?query,
 	// but absolute URIs only have query if path begins with /
 	if url.Scheme == "" || len(path) > 0 && path[0] == '/' {
-		path, url.RawQuery = split(path, '?', true);
+		path, url.RawQuery = split(path, '?', true)
 	}
 
 	// Maybe path is //authority/path
 	if len(path) > 2 && path[0:2] == "//" {
-		url.Authority, path = split(path[2:len(path)], '/', false);
+		url.Authority, path = split(path[2:len(path)], '/', false)
 	}
 
 	// If there's no @, split's default is wrong.  Check explicitly.
 	if strings.Index(url.Authority, "@") < 0 {
-		url.Host = url.Authority;
+		url.Host = url.Authority
 	} else {
-		url.Userinfo, url.Host = split(url.Authority, '@', true);
+		url.Userinfo, url.Host = split(url.Authority, '@', true)
 	}
 
 	// What's left is the path.
 	// TODO: Canonicalize (remove . and ..)?
 	if url.Path, err = URLUnescape(path); err != nil {
-		goto Error;
+		goto Error
 	}
 
 	// Remove escapes from the Authority and Userinfo fields, and verify
 	// that Scheme and Host contain no escapes (that would be illegal).
 	if url.Authority, err = URLUnescape(url.Authority); err != nil {
-		goto Error;
+		goto Error
 	}
 	if url.Userinfo, err = URLUnescape(url.Userinfo); err != nil {
-		goto Error;
+		goto Error
 	}
 	if strings.Index(url.Scheme, "%") >= 0 {
 		err = os.ErrorString("hexadecimal escape in scheme");
@@ -297,10 +297,10 @@ func ParseURLReference(rawurlref string) (url *URL, err os.Error) {
 	// Cut off #frag.
 	rawurl, frag := split(rawurlref, '#', true);
 	if url, err = ParseURL(rawurl); err != nil {
-		return nil, err;
+		return nil, err
 	}
 	if url.Fragment, err = URLUnescape(frag); err != nil {
-		return nil, &URLError{"parse", rawurl, err};
+		return nil, &URLError{"parse", rawurl, err}
 	}
 	return url, nil;
 }
@@ -313,21 +313,21 @@ func ParseURLReference(rawurlref string) (url *URL, err os.Error) {
 func (url *URL) String() string {
 	result := "";
 	if url.Scheme != "" {
-		result += url.Scheme + ":";
+		result += url.Scheme + ":"
 	}
 	if url.Host != "" || url.Userinfo != "" {
 		result += "//";
 		if url.Userinfo != "" {
-			result += URLEscape(url.Userinfo) + "@";
+			result += URLEscape(url.Userinfo) + "@"
 		}
 		result += url.Host;
 	}
 	result += URLEscape(url.Path);
 	if url.RawQuery != "" {
-		result += "?" + url.RawQuery;
+		result += "?" + url.RawQuery
 	}
 	if url.Fragment != "" {
-		result += "#" + URLEscape(url.Fragment);
+		result += "#" + URLEscape(url.Fragment)
 	}
 	return result;
 }
diff --git a/src/pkg/http/url_test.go b/src/pkg/http/url_test.go
index 90d5bdd00b..b8df71971b 100644
--- a/src/pkg/http/url_test.go
+++ b/src/pkg/http/url_test.go
@@ -186,7 +186,7 @@ var urlfragtests = []URLTest{
 func ufmt(u *URL) string {
 	return fmt.Sprintf("%q, %q, %q, %q, %q, %q, %q, %q, %q",
 		u.Raw, u.Scheme, u.RawPath, u.Authority, u.Userinfo,
-		u.Host, u.Path, u.RawQuery, u.Fragment);
+		u.Host, u.Path, u.RawQuery, u.Fragment)
 }
 
 func DoTest(t *testing.T, parse func(string) (*URL, os.Error), name string, tests []URLTest) {
@@ -198,7 +198,7 @@ func DoTest(t *testing.T, parse func(string) (*URL, os.Error), name string, test
 		}
 		if !reflect.DeepEqual(u, tt.out) {
 			t.Errorf("%s(%q):\n\thave %v\n\twant %v\n",
-				name, tt.in, ufmt(u), ufmt(tt.out));
+				name, tt.in, ufmt(u), ufmt(tt.out))
 		}
 	}
 }
@@ -223,10 +223,10 @@ func DoTestString(t *testing.T, parse func(string) (*URL, os.Error), name string
 		s := u.String();
 		expected := tt.in;
 		if len(tt.roundtrip) > 0 {
-			expected = tt.roundtrip;
+			expected = tt.roundtrip
 		}
 		if s != expected {
-			t.Errorf("%s(%q).String() == %q (expected %q)", name, tt.in, s, expected);
+			t.Errorf("%s(%q).String() == %q (expected %q)", name, tt.in, s, expected)
 		}
 	}
 }
@@ -308,7 +308,7 @@ func TestURLUnescape(t *testing.T) {
 	for _, tt := range unescapeTests {
 		actual, err := URLUnescape(tt.in);
 		if actual != tt.out || (err != nil) != (tt.err != nil) {
-			t.Errorf("URLUnescape(%q) = %q, %s; want %q, %s", tt.in, actual, err, tt.out, tt.err);
+			t.Errorf("URLUnescape(%q) = %q, %s; want %q, %s", tt.in, actual, err, tt.out, tt.err)
 		}
 	}
 }
@@ -345,13 +345,13 @@ func TestURLEscape(t *testing.T) {
 	for _, tt := range escapeTests {
 		actual := URLEscape(tt.in);
 		if tt.out != actual {
-			t.Errorf("URLEscape(%q) = %q, want %q", tt.in, actual, tt.out);
+			t.Errorf("URLEscape(%q) = %q, want %q", tt.in, actual, tt.out)
 		}
 
 		// for bonus points, verify that escape:unescape is an identity.
 		roundtrip, err := URLUnescape(actual);
 		if roundtrip != tt.in || err != nil {
-			t.Errorf("URLUnescape(%q) = %q, %s; want %q, %s", actual, roundtrip, err, tt.in, "[no error]");
+			t.Errorf("URLUnescape(%q) = %q, %s; want %q, %s", actual, roundtrip, err, tt.in, "[no error]")
 		}
 	}
 }
diff --git a/src/pkg/image/color.go b/src/pkg/image/color.go
index 757be84ce0..c3c5e50246 100644
--- a/src/pkg/image/color.go
+++ b/src/pkg/image/color.go
@@ -113,12 +113,12 @@ type ColorModel interface {
 type ColorModelFunc func(Color) Color
 
 func (f ColorModelFunc) Convert(c Color) Color {
-	return f(c);
+	return f(c)
 }
 
 func toRGBAColor(c Color) Color {
 	if _, ok := c.(RGBAColor); ok {	// no-op conversion
-		return c;
+		return c
 	}
 	r, g, b, a := c.RGBA();
 	return RGBAColor{uint8(r>>24), uint8(g>>24), uint8(b>>24), uint8(a>>24)};
@@ -126,7 +126,7 @@ func toRGBAColor(c Color) Color {
 
 func toRGBA64Color(c Color) Color {
 	if _, ok := c.(RGBA64Color); ok {	// no-op conversion
-		return c;
+		return c
 	}
 	r, g, b, a := c.RGBA();
 	return RGBA64Color{uint16(r>>16), uint16(g>>16), uint16(b>>16), uint16(a>>16)};
@@ -134,15 +134,15 @@ func toRGBA64Color(c Color) Color {
 
 func toNRGBAColor(c Color) Color {
 	if _, ok := c.(NRGBAColor); ok {	// no-op conversion
-		return c;
+		return c
 	}
 	r, g, b, a := c.RGBA();
 	a >>= 16;
 	if a == 0xffff {
-		return NRGBAColor{uint8(r>>24), uint8(g>>24), uint8(b>>24), 0xff};
+		return NRGBAColor{uint8(r>>24), uint8(g>>24), uint8(b>>24), 0xff}
 	}
 	if a == 0 {
-		return NRGBAColor{0, 0, 0, 0};
+		return NRGBAColor{0, 0, 0, 0}
 	}
 	r >>= 16;
 	g >>= 16;
@@ -156,7 +156,7 @@ func toNRGBAColor(c Color) Color {
 
 func toNRGBA64Color(c Color) Color {
 	if _, ok := c.(NRGBA64Color); ok {	// no-op conversion
-		return c;
+		return c
 	}
 	r, g, b, a := c.RGBA();
 	a >>= 16;
@@ -164,10 +164,10 @@ func toNRGBA64Color(c Color) Color {
 	g >>= 16;
 	b >>= 16;
 	if a == 0xffff {
-		return NRGBA64Color{uint16(r), uint16(g), uint16(b), 0xffff};
+		return NRGBA64Color{uint16(r), uint16(g), uint16(b), 0xffff}
 	}
 	if a == 0 {
-		return NRGBA64Color{0, 0, 0, 0};
+		return NRGBA64Color{0, 0, 0, 0}
 	}
 	// Since Color.RGBA returns a alpha-premultiplied color, we should have r <= a && g <= a && b <= a.
 	r = (r*0xffff)/a;
diff --git a/src/pkg/image/image.go b/src/pkg/image/image.go
index 80dbb86367..49d7f5a4d9 100644
--- a/src/pkg/image/image.go
+++ b/src/pkg/image/image.go
@@ -25,7 +25,7 @@ func (p *RGBA) ColorModel() ColorModel	{ return RGBAColorModel }
 
 func (p *RGBA) Width() int {
 	if len(p.Pixel) == 0 {
-		return 0;
+		return 0
 	}
 	return len(p.Pixel[0]);
 }
@@ -40,7 +40,7 @@ func (p *RGBA) Set(x, y int, c Color)	{ p.Pixel[y][x] = toRGBAColor(c).(RGBAColo
 func NewRGBA(w, h int) *RGBA {
 	pixel := make([][]RGBAColor, h);
 	for y := 0; y < int(h); y++ {
-		pixel[y] = make([]RGBAColor, w);
+		pixel[y] = make([]RGBAColor, w)
 	}
 	return &RGBA{pixel};
 }
@@ -55,7 +55,7 @@ func (p *RGBA64) ColorModel() ColorModel	{ return RGBA64ColorModel }
 
 func (p *RGBA64) Width() int {
 	if len(p.Pixel) == 0 {
-		return 0;
+		return 0
 	}
 	return len(p.Pixel[0]);
 }
@@ -70,7 +70,7 @@ func (p *RGBA64) Set(x, y int, c Color)	{ p.Pixel[y][x] = toRGBA64Color(c).(RGBA
 func NewRGBA64(w, h int) *RGBA64 {
 	pixel := make([][]RGBA64Color, h);
 	for y := 0; y < int(h); y++ {
-		pixel[y] = make([]RGBA64Color, w);
+		pixel[y] = make([]RGBA64Color, w)
 	}
 	return &RGBA64{pixel};
 }
@@ -85,7 +85,7 @@ func (p *NRGBA) ColorModel() ColorModel	{ return NRGBAColorModel }
 
 func (p *NRGBA) Width() int {
 	if len(p.Pixel) == 0 {
-		return 0;
+		return 0
 	}
 	return len(p.Pixel[0]);
 }
@@ -100,7 +100,7 @@ func (p *NRGBA) Set(x, y int, c Color)	{ p.Pixel[y][x] = toNRGBAColor(c).(NRGBAC
 func NewNRGBA(w, h int) *NRGBA {
 	pixel := make([][]NRGBAColor, h);
 	for y := 0; y < int(h); y++ {
-		pixel[y] = make([]NRGBAColor, w);
+		pixel[y] = make([]NRGBAColor, w)
 	}
 	return &NRGBA{pixel};
 }
@@ -115,7 +115,7 @@ func (p *NRGBA64) ColorModel() ColorModel	{ return NRGBA64ColorModel }
 
 func (p *NRGBA64) Width() int {
 	if len(p.Pixel) == 0 {
-		return 0;
+		return 0
 	}
 	return len(p.Pixel[0]);
 }
@@ -130,7 +130,7 @@ func (p *NRGBA64) Set(x, y int, c Color)	{ p.Pixel[y][x] = toNRGBA64Color(c).(NR
 func NewNRGBA64(w, h int) *NRGBA64 {
 	pixel := make([][]NRGBA64Color, h);
 	for y := 0; y < int(h); y++ {
-		pixel[y] = make([]NRGBA64Color, w);
+		pixel[y] = make([]NRGBA64Color, w)
 	}
 	return &NRGBA64{pixel};
 }
@@ -140,7 +140,7 @@ type PalettedColorModel []Color
 
 func diff(a, b uint32) uint32 {
 	if a > b {
-		return a-b;
+		return a-b
 	}
 	return b-a;
 }
@@ -148,7 +148,7 @@ func diff(a, b uint32) uint32 {
 // Convert returns the palette color closest to c in Euclidean R,G,B space.
 func (p PalettedColorModel) Convert(c Color) Color {
 	if len(p) == 0 {
-		return nil;
+		return nil
 	}
 	// TODO(nigeltao): Revisit the "pick the palette color which minimizes sum-squared-difference"
 	// algorithm when the premultiplied vs unpremultiplied issue is resolved.
@@ -186,7 +186,7 @@ func (p *Paletted) ColorModel() ColorModel	{ return p.Palette }
 
 func (p *Paletted) Width() int {
 	if len(p.Pixel) == 0 {
-		return 0;
+		return 0
 	}
 	return len(p.Pixel[0]);
 }
@@ -196,18 +196,18 @@ func (p *Paletted) Height() int	{ return len(p.Pixel) }
 func (p *Paletted) At(x, y int) Color	{ return p.Palette[p.Pixel[y][x]] }
 
 func (p *Paletted) ColorIndexAt(x, y int) uint8 {
-	return p.Pixel[y][x];
+	return p.Pixel[y][x]
 }
 
 func (p *Paletted) SetColorIndex(x, y int, index uint8) {
-	p.Pixel[y][x] = index;
+	p.Pixel[y][x] = index
 }
 
 // NewPaletted returns a new Paletted with the given width, height and palette.
 func NewPaletted(w, h int, m PalettedColorModel) *Paletted {
 	pixel := make([][]uint8, h);
 	for y := 0; y < int(h); y++ {
-		pixel[y] = make([]uint8, w);
+		pixel[y] = make([]uint8, w)
 	}
 	return &Paletted{pixel, m};
 }
diff --git a/src/pkg/image/png/reader.go b/src/pkg/image/png/reader.go
index 9ea338d07d..e8eba566a9 100644
--- a/src/pkg/image/png/reader.go
+++ b/src/pkg/image/png/reader.go
@@ -81,57 +81,57 @@ func (e UnsupportedError) String() string	{ return "unsupported PNG feature: " +
 
 // Big-endian.
 func parseUint32(b []uint8) uint32 {
-	return uint32(b[0])<<24 | uint32(b[1])<<16 | uint32(b[2])<<8 | uint32(b[3]);
+	return uint32(b[0])<<24 | uint32(b[1])<<16 | uint32(b[2])<<8 | uint32(b[3])
 }
 
 func abs(x int) int {
 	if x < 0 {
-		return -x;
+		return -x
 	}
 	return x;
 }
 
 func min(a, b int) int {
 	if a < b {
-		return a;
+		return a
 	}
 	return b;
 }
 
 func (d *decoder) parseIHDR(r io.Reader, crc hash.Hash32, length uint32) os.Error {
 	if length != 13 {
-		return FormatError("bad IHDR length");
+		return FormatError("bad IHDR length")
 	}
 	_, err := io.ReadFull(r, d.tmp[0:13]);
 	if err != nil {
-		return err;
+		return err
 	}
 	crc.Write(d.tmp[0:13]);
 	if d.tmp[8] != 8 {
-		return UnsupportedError("bit depth");
+		return UnsupportedError("bit depth")
 	}
 	if d.tmp[10] != 0 || d.tmp[11] != 0 || d.tmp[12] != 0 {
-		return UnsupportedError("compression, filter or interlace method");
+		return UnsupportedError("compression, filter or interlace method")
 	}
 	w := int32(parseUint32(d.tmp[0:4]));
 	h := int32(parseUint32(d.tmp[4:8]));
 	if w < 0 || h < 0 {
-		return FormatError("negative dimension");
+		return FormatError("negative dimension")
 	}
 	nPixels := int64(w)*int64(h);
 	if nPixels != int64(int(nPixels)) {
-		return UnsupportedError("dimension overflow");
+		return UnsupportedError("dimension overflow")
 	}
 	d.colorType = d.tmp[9];
 	switch d.colorType {
 	case ctTrueColor:
-		d.image = image.NewRGBA(int(w), int(h));
+		d.image = image.NewRGBA(int(w), int(h))
 	case ctPaletted:
-		d.image = image.NewPaletted(int(w), int(h), nil);
+		d.image = image.NewPaletted(int(w), int(h), nil)
 	case ctTrueColorAlpha:
-		d.image = image.NewNRGBA(int(w), int(h));
+		d.image = image.NewNRGBA(int(w), int(h))
 	default:
-		return UnsupportedError("color type");
+		return UnsupportedError("color type")
 	}
 	d.width, d.height = int(w), int(h);
 	return nil;
@@ -140,26 +140,26 @@ func (d *decoder) parseIHDR(r io.Reader, crc hash.Hash32, length uint32) os.Erro
 func (d *decoder) parsePLTE(r io.Reader, crc hash.Hash32, length uint32) os.Error {
 	np := int(length/3);	// The number of palette entries.
 	if length%3 != 0 || np <= 0 || np > 256 {
-		return FormatError("bad PLTE length");
+		return FormatError("bad PLTE length")
 	}
 	n, err := io.ReadFull(r, d.tmp[0 : 3*np]);
 	if err != nil {
-		return err;
+		return err
 	}
 	crc.Write(d.tmp[0:n]);
 	switch d.colorType {
 	case ctPaletted:
 		palette := make([]image.Color, np);
 		for i := 0; i < np; i++ {
-			palette[i] = image.RGBAColor{d.tmp[3*i + 0], d.tmp[3*i + 1], d.tmp[3*i + 2], 0xff};
+			palette[i] = image.RGBAColor{d.tmp[3*i + 0], d.tmp[3*i + 1], d.tmp[3*i + 2], 0xff}
 		}
 		d.image.(*image.Paletted).Palette = image.PalettedColorModel(palette);
 	case ctTrueColor, ctTrueColorAlpha:
 		// As per the PNG spec, a PLTE chunk is optional (and for practical purposes,
 		// ignorable) for the ctTrueColor and ctTrueColorAlpha color types (section 4.1.2).
-		return nil;
+		return nil
 	default:
-		return FormatError("PLTE, color type mismatch");
+		return FormatError("PLTE, color type mismatch")
 	}
 	return nil;
 }
@@ -171,9 +171,9 @@ func paeth(a, b, c uint8) uint8 {
 	pb := abs(p-int(b));
 	pc := abs(p-int(c));
 	if pa <= pb && pa <= pc {
-		return a;
+		return a
 	} else if pb <= pc {
-		return b;
+		return b
 	}
 	return c;
 }
@@ -181,7 +181,7 @@ func paeth(a, b, c uint8) uint8 {
 func (d *decoder) idatReader(idat io.Reader) os.Error {
 	r, err := zlib.NewInflater(idat);
 	if err != nil {
-		return err;
+		return err
 	}
 	defer r.Close();
 	bpp := 0;	// Bytes per pixel.
@@ -212,7 +212,7 @@ func (d *decoder) idatReader(idat io.Reader) os.Error {
 		// Read the decompressed bytes.
 		_, err := io.ReadFull(r, cr);
 		if err != nil {
-			return err;
+			return err
 		}
 
 		// Apply the filter.
@@ -223,46 +223,46 @@ func (d *decoder) idatReader(idat io.Reader) os.Error {
 			// No-op.
 		case ftSub:
 			for i := bpp; i < len(cdat); i++ {
-				cdat[i] += cdat[i-bpp];
+				cdat[i] += cdat[i-bpp]
 			}
 		case ftUp:
 			for i := 0; i < len(cdat); i++ {
-				cdat[i] += pdat[i];
+				cdat[i] += pdat[i]
 			}
 		case ftAverage:
 			for i := 0; i < bpp; i++ {
-				cdat[i] += pdat[i]/2;
+				cdat[i] += pdat[i]/2
 			}
 			for i := bpp; i < len(cdat); i++ {
-				cdat[i] += uint8((int(cdat[i-bpp])+int(pdat[i]))/2);
+				cdat[i] += uint8((int(cdat[i-bpp])+int(pdat[i]))/2)
 			}
 		case ftPaeth:
 			for i := 0; i < bpp; i++ {
-				cdat[i] += paeth(0, pdat[i], 0);
+				cdat[i] += paeth(0, pdat[i], 0)
 			}
 			for i := bpp; i < len(cdat); i++ {
-				cdat[i] += paeth(cdat[i-bpp], pdat[i], pdat[i-bpp]);
+				cdat[i] += paeth(cdat[i-bpp], pdat[i], pdat[i-bpp])
 			}
 		default:
-			return FormatError("bad filter type");
+			return FormatError("bad filter type")
 		}
 
 		// Convert from bytes to colors.
 		switch d.colorType {
 		case ctTrueColor:
 			for x := 0; x < d.width; x++ {
-				rgba.Set(x, y, image.RGBAColor{cdat[3*x + 0], cdat[3*x + 1], cdat[3*x + 2], 0xff});
+				rgba.Set(x, y, image.RGBAColor{cdat[3*x + 0], cdat[3*x + 1], cdat[3*x + 2], 0xff})
 			}
 		case ctPaletted:
 			for x := 0; x < d.width; x++ {
 				if cdat[x] > maxPalette {
-					return FormatError("palette index out of range");
+					return FormatError("palette index out of range")
 				}
 				paletted.SetColorIndex(x, y, cdat[x]);
 			}
 		case ctTrueColorAlpha:
 			for x := 0; x < d.width; x++ {
-				nrgba.Set(x, y, image.NRGBAColor{cdat[4*x + 0], cdat[4*x + 1], cdat[4*x + 2], cdat[4*x + 3]});
+				nrgba.Set(x, y, image.NRGBAColor{cdat[4*x + 0], cdat[4*x + 1], cdat[4*x + 2], cdat[4*x + 3]})
 			}
 		}
 
@@ -285,7 +285,7 @@ func (d *decoder) parseIDAT(r io.Reader, crc hash.Hash32, length uint32) os.Erro
 		go func() {
 			err := d.idatReader(pr);
 			if err == os.EOF {
-				err = FormatError("too little IDAT");
+				err = FormatError("too little IDAT")
 			}
 			pr.CloseWithError(FormatError("too much IDAT"));
 			d.idatDone <- err;
@@ -299,10 +299,10 @@ func (d *decoder) parseIDAT(r io.Reader, crc hash.Hash32, length uint32) os.Erro
 		// want to report that error, and not the one that made the Read stop.
 		n, err2 := d.idatWriter.Write(buf[0:n]);
 		if err2 != nil {
-			return err2;
+			return err2
 		}
 		if err1 != nil {
-			return err1;
+			return err1
 		}
 		crc.Write(buf[0:n]);
 		length -= uint32(n);
@@ -312,7 +312,7 @@ func (d *decoder) parseIDAT(r io.Reader, crc hash.Hash32, length uint32) os.Erro
 
 func (d *decoder) parseIEND(r io.Reader, crc hash.Hash32, length uint32) os.Error {
 	if length != 0 {
-		return FormatError("bad IEND length");
+		return FormatError("bad IEND length")
 	}
 	return nil;
 }
@@ -321,20 +321,20 @@ func (d *decoder) parseChunk(r io.Reader) os.Error {
 	// Read the length.
 	n, err := io.ReadFull(r, d.tmp[0:4]);
 	if err == os.EOF {
-		return io.ErrUnexpectedEOF;
+		return io.ErrUnexpectedEOF
 	}
 	if err != nil {
-		return err;
+		return err
 	}
 	length := parseUint32(d.tmp[0:4]);
 
 	// Read the chunk type.
 	n, err = io.ReadFull(r, d.tmp[0:4]);
 	if err == os.EOF {
-		return io.ErrUnexpectedEOF;
+		return io.ErrUnexpectedEOF
 	}
 	if err != nil {
-		return err;
+		return err
 	}
 	crc := crc32.NewIEEE();
 	crc.Write(d.tmp[0:4]);
@@ -343,25 +343,25 @@ func (d *decoder) parseChunk(r io.Reader) os.Error {
 	switch string(d.tmp[0:4]) {
 	case "IHDR":
 		if d.stage != dsStart {
-			return chunkOrderError;
+			return chunkOrderError
 		}
 		d.stage = dsSeenIHDR;
 		err = d.parseIHDR(r, crc, length);
 	case "PLTE":
 		if d.stage != dsSeenIHDR {
-			return chunkOrderError;
+			return chunkOrderError
 		}
 		d.stage = dsSeenPLTE;
 		err = d.parsePLTE(r, crc, length);
 	case "IDAT":
 		if d.stage < dsSeenIHDR || d.stage > dsSeenIDAT || (d.colorType == ctPaletted && d.stage == dsSeenIHDR) {
-			return chunkOrderError;
+			return chunkOrderError
 		}
 		d.stage = dsSeenIDAT;
 		err = d.parseIDAT(r, crc, length);
 	case "IEND":
 		if d.stage != dsSeenIDAT {
-			return chunkOrderError;
+			return chunkOrderError
 		}
 		d.stage = dsSeenIEND;
 		err = d.parseIEND(r, crc, length);
@@ -371,26 +371,26 @@ func (d *decoder) parseChunk(r io.Reader) os.Error {
 		for length > 0 {
 			n, err = io.ReadFull(r, ignored[0 : min(len(ignored), int(length))]);
 			if err != nil {
-				return err;
+				return err
 			}
 			crc.Write(ignored[0:n]);
 			length -= uint32(n);
 		}
 	}
 	if err != nil {
-		return err;
+		return err
 	}
 
 	// Read the checksum.
 	n, err = io.ReadFull(r, d.tmp[0:4]);
 	if err == os.EOF {
-		return io.ErrUnexpectedEOF;
+		return io.ErrUnexpectedEOF
 	}
 	if err != nil {
-		return err;
+		return err
 	}
 	if parseUint32(d.tmp[0:4]) != crc.Sum32() {
-		return FormatError("invalid checksum");
+		return FormatError("invalid checksum")
 	}
 	return nil;
 }
@@ -398,10 +398,10 @@ func (d *decoder) parseChunk(r io.Reader) os.Error {
 func (d *decoder) checkHeader(r io.Reader) os.Error {
 	_, err := io.ReadFull(r, d.tmp[0:8]);
 	if err != nil {
-		return err;
+		return err
 	}
 	if string(d.tmp[0:8]) != pngHeader {
-		return FormatError("not a PNG file");
+		return FormatError("not a PNG file")
 	}
 	return nil;
 }
@@ -412,23 +412,23 @@ func Decode(r io.Reader) (image.Image, os.Error) {
 	var d decoder;
 	err := d.checkHeader(r);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	for d.stage = dsStart; d.stage != dsSeenIEND; {
 		err = d.parseChunk(r);
 		if err != nil {
-			break;
+			break
 		}
 	}
 	if d.idatWriter != nil {
 		d.idatWriter.Close();
 		err1 := <-d.idatDone;
 		if err == nil {
-			err = err1;
+			err = err1
 		}
 	}
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	return d.image, nil;
 }
diff --git a/src/pkg/image/png/reader_test.go b/src/pkg/image/png/reader_test.go
index 97383fdbd2..97b4e8ec6e 100644
--- a/src/pkg/image/png/reader_test.go
+++ b/src/pkg/image/png/reader_test.go
@@ -36,7 +36,7 @@ var filenames = []string{
 func readPng(filename string) (image.Image, os.Error) {
 	f, err := os.Open(filename, os.O_RDONLY, 0444);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	defer f.Close();
 	return Decode(f);
@@ -56,14 +56,14 @@ func sng(w io.WriteCloser, filename string, png image.Image) {
 	cpm, _ := cm.(image.PalettedColorModel);
 	switch {
 	case cm == image.RGBAColorModel:
-		io.WriteString(w, "    using color;\n");
+		io.WriteString(w, "    using color;\n")
 	case cm == image.NRGBAColorModel:
-		io.WriteString(w, "    using color alpha;\n");
+		io.WriteString(w, "    using color alpha;\n")
 	case cpm != nil:
 		io.WriteString(w, "    using color palette;\n");
 		paletted = png.(*image.Paletted);
 	default:
-		io.WriteString(w, "unknown PNG decoder color model\n");
+		io.WriteString(w, "unknown PNG decoder color model\n")
 	}
 	io.WriteString(w, "}\n");
 
@@ -100,7 +100,7 @@ func sng(w io.WriteCloser, filename string, png image.Image) {
 			}
 		case cpm != nil:
 			for x := 0; x < png.Width(); x++ {
-				fmt.Fprintf(w, "%02x", paletted.ColorIndexAt(x, y));
+				fmt.Fprintf(w, "%02x", paletted.ColorIndexAt(x, y))
 			}
 		}
 		io.WriteString(w, "\n");
@@ -139,7 +139,7 @@ func TestReader(t *testing.T) {
 			ps, perr := pb.ReadString('\n');
 			ss, serr := sb.ReadString('\n');
 			if perr == os.EOF && serr == os.EOF {
-				break;
+				break
 			}
 			if perr != nil {
 				t.Error(fn, perr);
diff --git a/src/pkg/image/png/writer.go b/src/pkg/image/png/writer.go
index ceb72598e3..8c8a415371 100644
--- a/src/pkg/image/png/writer.go
+++ b/src/pkg/image/png/writer.go
@@ -38,7 +38,7 @@ func opaque(m image.Image) bool {
 		for x := 0; x < m.Width(); x++ {
 			_, _, _, a := m.At(x, y).RGBA();
 			if a != 0xffffffff {
-				return false;
+				return false
 			}
 		}
 	}
@@ -48,14 +48,14 @@ func opaque(m image.Image) bool {
 // The absolute value of a byte interpreted as a signed int8.
 func abs8(d uint8) int {
 	if d < 128 {
-		return int(d);
+		return int(d)
 	}
 	return 256-int(d);
 }
 
 func (e *encoder) writeChunk(b []byte, name string) {
 	if e.err != nil {
-		return;
+		return
 	}
 	n := uint32(len(b));
 	if int(n) != len(b) {
@@ -74,11 +74,11 @@ func (e *encoder) writeChunk(b []byte, name string) {
 
 	_, e.err = e.w.Write(e.header[0:8]);
 	if e.err != nil {
-		return;
+		return
 	}
 	_, e.err = e.w.Write(b);
 	if e.err != nil {
-		return;
+		return
 	}
 	_, e.err = e.w.Write(e.footer[0:4]);
 }
@@ -125,7 +125,7 @@ func (e *encoder) writePLTE(p image.PalettedColorModel) {
 func (e *encoder) Write(b []byte) (int, os.Error) {
 	e.writeChunk(b, "IDAT");
 	if e.err != nil {
-		return 0, e.err;
+		return 0, e.err
 	}
 	return len(b), nil;
 }
@@ -164,7 +164,7 @@ func filter(cr [][]byte, pr []byte, bpp int) int {
 		cdat4[i] = cdat0[i] - paeth(cdat0[i-bpp], pdat[i], pdat[i-bpp]);
 		sum += abs8(cdat4[i]);
 		if sum >= best {
-			break;
+			break
 		}
 	}
 	if sum < best {
@@ -177,7 +177,7 @@ func filter(cr [][]byte, pr []byte, bpp int) int {
 	for i := 0; i < n; i++ {
 		sum += abs8(cdat0[i]);
 		if sum >= best {
-			break;
+			break
 		}
 	}
 	if sum < best {
@@ -195,7 +195,7 @@ func filter(cr [][]byte, pr []byte, bpp int) int {
 		cdat1[i] = cdat0[i]-cdat0[i-bpp];
 		sum += abs8(cdat1[i]);
 		if sum >= best {
-			break;
+			break
 		}
 	}
 	if sum < best {
@@ -213,7 +213,7 @@ func filter(cr [][]byte, pr []byte, bpp int) int {
 		cdat3[i] = cdat0[i]-uint8((int(cdat0[i-bpp])+int(pdat[i]))/2);
 		sum += abs8(cdat3[i]);
 		if sum >= best {
-			break;
+			break
 		}
 	}
 	if sum < best {
@@ -227,7 +227,7 @@ func filter(cr [][]byte, pr []byte, bpp int) int {
 func writeImage(w io.Writer, m image.Image, ct uint8) os.Error {
 	zw, err := zlib.NewDeflater(w);
 	if err != nil {
-		return err;
+		return err
 	}
 	defer zw.Close();
 
@@ -235,12 +235,12 @@ func writeImage(w io.Writer, m image.Image, ct uint8) os.Error {
 	var paletted *image.Paletted;
 	switch ct {
 	case ctTrueColor:
-		bpp = 3;
+		bpp = 3
 	case ctPaletted:
 		bpp = 1;
 		paletted = m.(*image.Paletted);
 	case ctTrueColorAlpha:
-		bpp = 4;
+		bpp = 4
 	}
 	// cr[*] and pr are the bytes for the current and previous row.
 	// cr[0] is unfiltered (or equivalently, filtered with the ftNone filter).
@@ -267,7 +267,7 @@ func writeImage(w io.Writer, m image.Image, ct uint8) os.Error {
 			}
 		case ctPaletted:
 			for x := 0; x < m.Width(); x++ {
-				cr[0][x+1] = paletted.ColorIndexAt(x, y);
+				cr[0][x+1] = paletted.ColorIndexAt(x, y)
 			}
 		case ctTrueColorAlpha:
 			// Convert from image.Image (which is alpha-premultiplied) to PNG's non-alpha-premultiplied.
@@ -286,7 +286,7 @@ func writeImage(w io.Writer, m image.Image, ct uint8) os.Error {
 		// Write the compressed bytes.
 		_, err = zw.Write(cr[f]);
 		if err != nil {
-			return err;
+			return err
 		}
 
 		// The current row for y is the previous row for y+1.
@@ -298,16 +298,16 @@ func writeImage(w io.Writer, m image.Image, ct uint8) os.Error {
 // Write the actual image data to one or more IDAT chunks.
 func (e *encoder) writeIDATs() {
 	if e.err != nil {
-		return;
+		return
 	}
 	var bw *bufio.Writer;
 	bw, e.err = bufio.NewWriterSize(e, 1<<15);
 	if e.err != nil {
-		return;
+		return
 	}
 	e.err = writeImage(bw, e.m, e.colorType);
 	if e.err != nil {
-		return;
+		return
 	}
 	e.err = bw.Flush();
 }
@@ -322,7 +322,7 @@ func Encode(w io.Writer, m image.Image) os.Error {
 	// also rejected.
 	mw, mh := int64(m.Width()), int64(m.Height());
 	if mw <= 0 || mh <= 0 || mw >= 1<<32 || mh >= 1<<32 {
-		return FormatError("invalid image size: " + strconv.Itoa64(mw) + "x" + strconv.Itoa64(mw));
+		return FormatError("invalid image size: " + strconv.Itoa64(mw) + "x" + strconv.Itoa64(mw))
 	}
 
 	var e encoder;
@@ -331,15 +331,15 @@ func Encode(w io.Writer, m image.Image) os.Error {
 	e.colorType = uint8(ctTrueColorAlpha);
 	pal, _ := m.(*image.Paletted);
 	if pal != nil {
-		e.colorType = ctPaletted;
+		e.colorType = ctPaletted
 	} else if opaque(m) {
-		e.colorType = ctTrueColor;
+		e.colorType = ctTrueColor
 	}
 
 	_, e.err = io.WriteString(w, pngHeader);
 	e.writeIHDR();
 	if pal != nil {
-		e.writePLTE(pal.Palette);
+		e.writePLTE(pal.Palette)
 	}
 	e.writeIDATs();
 	e.writeIEND();
diff --git a/src/pkg/image/png/writer_test.go b/src/pkg/image/png/writer_test.go
index b832f1c267..db50a98721 100644
--- a/src/pkg/image/png/writer_test.go
+++ b/src/pkg/image/png/writer_test.go
@@ -14,14 +14,14 @@ import (
 
 func diff(m0, m1 image.Image) os.Error {
 	if m0.Width() != m1.Width() || m0.Height() != m1.Height() {
-		return os.NewError(fmt.Sprintf("dimensions differ: %dx%d vs %dx%d", m0.Width(), m0.Height(), m1.Width(), m1.Height()));
+		return os.NewError(fmt.Sprintf("dimensions differ: %dx%d vs %dx%d", m0.Width(), m0.Height(), m1.Width(), m1.Height()))
 	}
 	for y := 0; y < m0.Height(); y++ {
 		for x := 0; x < m0.Width(); x++ {
 			r0, g0, b0, a0 := m0.At(x, y).RGBA();
 			r1, g1, b1, a1 := m1.At(x, y).RGBA();
 			if r0 != r1 || g0 != g1 || b0 != b1 || a0 != a1 {
-				return os.NewError(fmt.Sprintf("colors differ at (%d, %d): %v vs %v", x, y, m0.At(x, y), m1.At(x, y)));
+				return os.NewError(fmt.Sprintf("colors differ at (%d, %d): %v vs %v", x, y, m0.At(x, y), m1.At(x, y)))
 			}
 		}
 	}
diff --git a/src/pkg/io/io.go b/src/pkg/io/io.go
index 01157c157e..7b71472add 100644
--- a/src/pkg/io/io.go
+++ b/src/pkg/io/io.go
@@ -143,7 +143,7 @@ type WriterAt interface {
 
 // WriteString writes the contents of the string s to w, which accepts an array of bytes.
 func WriteString(w Writer, s string) (n int, err os.Error) {
-	return w.Write(strings.Bytes(s));
+	return w.Write(strings.Bytes(s))
 }
 
 // ReadAtLeast reads from r into buf until it has read at least min bytes.
@@ -156,11 +156,11 @@ func ReadAtLeast(r Reader, buf []byte, min int) (n int, err os.Error) {
 	for n < min {
 		nn, e := r.Read(buf[n:len(buf)]);
 		if nn > 0 {
-			n += nn;
+			n += nn
 		}
 		if e != nil {
 			if e == os.EOF && n > 0 {
-				e = ErrUnexpectedEOF;
+				e = ErrUnexpectedEOF
 			}
 			return n, e;
 		}
@@ -174,7 +174,7 @@ func ReadAtLeast(r Reader, buf []byte, min int) (n int, err os.Error) {
 // If an EOF happens after reading some but not all the bytes,
 // ReadFull returns ErrUnexpectedEOF.
 func ReadFull(r Reader, buf []byte) (n int, err os.Error) {
-	return ReadAtLeast(r, buf, len(buf));
+	return ReadAtLeast(r, buf, len(buf))
 }
 
 // Copyn copies n bytes (or until an error) from src to dst.
@@ -184,13 +184,13 @@ func Copyn(dst Writer, src Reader, n int64) (written int64, err os.Error) {
 	for written < n {
 		l := len(buf);
 		if d := n-written; d < int64(l) {
-			l = int(d);
+			l = int(d)
 		}
 		nr, er := src.Read(buf[0:l]);
 		if nr > 0 {
 			nw, ew := dst.Write(buf[0:nr]);
 			if nw > 0 {
-				written += int64(nw);
+				written += int64(nw)
 			}
 			if ew != nil {
 				err = ew;
@@ -219,7 +219,7 @@ func Copy(dst Writer, src Reader) (written int64, err os.Error) {
 		if nr > 0 {
 			nw, ew := dst.Write(buf[0:nr]);
 			if nw > 0 {
-				written += int64(nw);
+				written += int64(nw)
 			}
 			if ew != nil {
 				err = ew;
@@ -231,7 +231,7 @@ func Copy(dst Writer, src Reader) (written int64, err os.Error) {
 			}
 		}
 		if er == os.EOF {
-			break;
+			break
 		}
 		if er != nil {
 			err = er;
@@ -252,10 +252,10 @@ type limitedReader struct {
 
 func (l *limitedReader) Read(p []byte) (n int, err os.Error) {
 	if l.n <= 0 {
-		return 0, os.EOF;
+		return 0, os.EOF
 	}
 	if int64(len(p)) > l.n {
-		p = p[0 : l.n];
+		p = p[0 : l.n]
 	}
 	n, err = l.r.Read(p);
 	l.n -= int64(n);
@@ -265,7 +265,7 @@ func (l *limitedReader) Read(p []byte) (n int, err os.Error) {
 // NewSectionReader returns a SectionReader that reads from r
 // starting at offset off and stops with os.EOF after n bytes.
 func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader {
-	return &SectionReader{r, off, off, off+n};
+	return &SectionReader{r, off, off, off+n}
 }
 
 // SectionReader implements Read, Seek, and ReadAt on a section
@@ -279,10 +279,10 @@ type SectionReader struct {
 
 func (s *SectionReader) Read(p []byte) (n int, err os.Error) {
 	if s.off >= s.limit {
-		return 0, os.EOF;
+		return 0, os.EOF
 	}
 	if max := s.limit - s.off; int64(len(p)) > max {
-		p = p[0:max];
+		p = p[0:max]
 	}
 	n, err = s.r.ReadAt(p, s.off);
 	s.off += int64(n);
@@ -292,16 +292,16 @@ func (s *SectionReader) Read(p []byte) (n int, err os.Error) {
 func (s *SectionReader) Seek(offset int64, whence int) (ret int64, err os.Error) {
 	switch whence {
 	default:
-		return 0, os.EINVAL;
+		return 0, os.EINVAL
 	case 0:
-		offset += s.base;
+		offset += s.base
 	case 1:
-		offset += s.off;
+		offset += s.off
 	case 2:
-		offset += s.limit;
+		offset += s.limit
 	}
 	if offset < s.off || offset > s.limit {
-		return 0, os.EINVAL;
+		return 0, os.EINVAL
 	}
 	s.off = offset;
 	return offset - s.base, nil;
@@ -309,11 +309,11 @@ func (s *SectionReader) Seek(offset int64, whence int) (ret int64, err os.Error)
 
 func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err os.Error) {
 	if off < 0 || off >= s.limit - s.base {
-		return 0, os.EOF;
+		return 0, os.EOF
 	}
 	off += s.base;
 	if max := s.limit - off; int64(len(p)) > max {
-		p = p[0:max];
+		p = p[0:max]
 	}
 	return s.r.ReadAt(p, off);
 }
diff --git a/src/pkg/io/pipe.go b/src/pkg/io/pipe.go
index 743e4c468f..2caf21854f 100644
--- a/src/pkg/io/pipe.go
+++ b/src/pkg/io/pipe.go
@@ -31,16 +31,16 @@ type pipe struct {
 
 func (p *pipe) Read(data []byte) (n int, err os.Error) {
 	if p == nil || p.rclosed {
-		return 0, os.EINVAL;
+		return 0, os.EINVAL
 	}
 
 	// Wait for next write block if necessary.
 	if p.wpend == nil {
 		if !p.wclosed {
-			p.wpend = <-p.cr;
+			p.wpend = <-p.cr
 		}
 		if p.wpend == nil {
-			return 0, p.werr;
+			return 0, p.werr
 		}
 		p.wtot = 0;
 	}
@@ -48,10 +48,10 @@ func (p *pipe) Read(data []byte) (n int, err os.Error) {
 	// Read from current write block.
 	n = len(data);
 	if n > len(p.wpend) {
-		n = len(p.wpend);
+		n = len(p.wpend)
 	}
 	for i := 0; i < n; i++ {
-		data[i] = p.wpend[i];
+		data[i] = p.wpend[i]
 	}
 	p.wtot += n;
 	p.wpend = p.wpend[n:len(p.wpend)];
@@ -68,10 +68,10 @@ func (p *pipe) Read(data []byte) (n int, err os.Error) {
 
 func (p *pipe) Write(data []byte) (n int, err os.Error) {
 	if p == nil || p.wclosed {
-		return 0, os.EINVAL;
+		return 0, os.EINVAL
 	}
 	if p.rclosed {
-		return 0, p.rerr;
+		return 0, p.rerr
 	}
 
 	// Send data to reader.
@@ -84,19 +84,19 @@ func (p *pipe) Write(data []byte) (n int, err os.Error) {
 
 func (p *pipe) CloseReader(rerr os.Error) os.Error {
 	if p == nil || p.rclosed {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 
 	// Stop any future writes.
 	p.rclosed = true;
 	if rerr == nil {
-		rerr = os.EPIPE;
+		rerr = os.EPIPE
 	}
 	p.rerr = rerr;
 
 	// Stop the current write.
 	if !p.wclosed {
-		p.cw <- pipeReturn{p.wtot, rerr};
+		p.cw <- pipeReturn{p.wtot, rerr}
 	}
 
 	return nil;
@@ -104,10 +104,10 @@ func (p *pipe) CloseReader(rerr os.Error) os.Error {
 
 func (p *pipe) CloseWriter(werr os.Error) os.Error {
 	if werr == nil {
-		werr = os.EOF;
+		werr = os.EOF
 	}
 	if p == nil || p.wclosed {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 
 	// Stop any future reads.
@@ -116,7 +116,7 @@ func (p *pipe) CloseWriter(werr os.Error) os.Error {
 
 	// Stop the current read.
 	if !p.rclosed {
-		p.cr <- nil;
+		p.cr <- nil
 	}
 
 	return nil;
diff --git a/src/pkg/io/pipe_test.go b/src/pkg/io/pipe_test.go
index a7975714c5..16c49977bc 100644
--- a/src/pkg/io/pipe_test.go
+++ b/src/pkg/io/pipe_test.go
@@ -16,10 +16,10 @@ import (
 func checkWrite(t *testing.T, w Writer, data []byte, c chan int) {
 	n, err := w.Write(data);
 	if err != nil {
-		t.Errorf("write: %v", err);
+		t.Errorf("write: %v", err)
 	}
 	if n != len(data) {
-		t.Errorf("short write: %d != %d", n, len(data));
+		t.Errorf("short write: %d != %d", n, len(data))
 	}
 	c <- 0;
 }
@@ -32,9 +32,9 @@ func TestPipe1(t *testing.T) {
 	go checkWrite(t, w, strings.Bytes("hello, world"), c);
 	n, err := r.Read(buf);
 	if err != nil {
-		t.Errorf("read: %v", err);
+		t.Errorf("read: %v", err)
 	} else if n != 12 || string(buf[0:12]) != "hello, world" {
-		t.Errorf("bad read: got %q", buf[0:n]);
+		t.Errorf("bad read: got %q", buf[0:n])
 	}
 	<-c;
 	r.Close();
@@ -50,7 +50,7 @@ func reader(t *testing.T, r Reader, c chan int) {
 			break;
 		}
 		if err != nil {
-			t.Errorf("read: %v", err);
+			t.Errorf("read: %v", err)
 		}
 		c <- n;
 	}
@@ -66,20 +66,20 @@ func TestPipe2(t *testing.T) {
 		p := buf[0 : 5 + i*10];
 		n, err := w.Write(p);
 		if n != len(p) {
-			t.Errorf("wrote %d, got %d", len(p), n);
+			t.Errorf("wrote %d, got %d", len(p), n)
 		}
 		if err != nil {
-			t.Errorf("write: %v", err);
+			t.Errorf("write: %v", err)
 		}
 		nn := <-c;
 		if nn != n {
-			t.Errorf("wrote %d, read got %d", n, nn);
+			t.Errorf("wrote %d, read got %d", n, nn)
 		}
 	}
 	w.Close();
 	nn := <-c;
 	if nn != 0 {
-		t.Errorf("final read got %d", nn);
+		t.Errorf("final read got %d", nn)
 	}
 }
 
@@ -100,7 +100,7 @@ func TestPipe3(t *testing.T) {
 	r, w := Pipe();
 	var wdat = make([]byte, 128);
 	for i := 0; i < len(wdat); i++ {
-		wdat[i] = byte(i);
+		wdat[i] = byte(i)
 	}
 	go writer(w, wdat, c);
 	var rdat = make([]byte, 1024);
@@ -108,34 +108,34 @@ func TestPipe3(t *testing.T) {
 	for n := 1; n <= 256; n *= 2 {
 		nn, err := r.Read(rdat[tot : tot+n]);
 		if err != nil && err != os.EOF {
-			t.Fatalf("read: %v", err);
+			t.Fatalf("read: %v", err)
 		}
 
 		// only final two reads should be short - 1 byte, then 0
 		expect := n;
 		if n == 128 {
-			expect = 1;
+			expect = 1
 		} else if n == 256 {
 			expect = 0;
 			if err != os.EOF {
-				t.Fatalf("read at end: %v", err);
+				t.Fatalf("read at end: %v", err)
 			}
 		}
 		if nn != expect {
-			t.Fatalf("read %d, expected %d, got %d", n, expect, nn);
+			t.Fatalf("read %d, expected %d, got %d", n, expect, nn)
 		}
 		tot += nn;
 	}
 	pr := <-c;
 	if pr.n != 128 || pr.err != nil {
-		t.Fatalf("write 128: %d, %v", pr.n, pr.err);
+		t.Fatalf("write 128: %d, %v", pr.n, pr.err)
 	}
 	if tot != 128 {
-		t.Fatalf("total read %d != 128", tot);
+		t.Fatalf("total read %d != 128", tot)
 	}
 	for i := 0; i < 128; i++ {
 		if rdat[i] != byte(i) {
-			t.Fatalf("rdat[%d] = %d", i, rdat[i]);
+			t.Fatalf("rdat[%d] = %d", i, rdat[i])
 		}
 	}
 }
@@ -154,7 +154,7 @@ type pipeTest struct {
 }
 
 func (p pipeTest) String() string {
-	return fmt.Sprintf("async=%v err=%v closeWithError=%v", p.async, p.err, p.closeWithError);
+	return fmt.Sprintf("async=%v err=%v closeWithError=%v", p.async, p.err, p.closeWithError)
 }
 
 var pipeTests = []pipeTest{
@@ -170,12 +170,12 @@ func delayClose(t *testing.T, cl closer, ch chan int, tt pipeTest) {
 	time.Sleep(1e6);	// 1 ms
 	var err os.Error;
 	if tt.closeWithError {
-		err = cl.CloseWithError(tt.err);
+		err = cl.CloseWithError(tt.err)
 	} else {
-		err = cl.Close();
+		err = cl.Close()
 	}
 	if err != nil {
-		t.Errorf("delayClose: %v", err);
+		t.Errorf("delayClose: %v", err)
 	}
 	ch <- 0;
 }
@@ -185,25 +185,25 @@ func TestPipeReadClose(t *testing.T) {
 		c := make(chan int, 1);
 		r, w := Pipe();
 		if tt.async {
-			go delayClose(t, w, c, tt);
+			go delayClose(t, w, c, tt)
 		} else {
-			delayClose(t, w, c, tt);
+			delayClose(t, w, c, tt)
 		}
 		var buf = make([]byte, 64);
 		n, err := r.Read(buf);
 		<-c;
 		want := tt.err;
 		if want == nil {
-			want = os.EOF;
+			want = os.EOF
 		}
 		if err != want {
-			t.Errorf("read from closed pipe: %v want %v", err, want);
+			t.Errorf("read from closed pipe: %v want %v", err, want)
 		}
 		if n != 0 {
-			t.Errorf("read on closed pipe returned %d", n);
+			t.Errorf("read on closed pipe returned %d", n)
 		}
 		if err = r.Close(); err != nil {
-			t.Errorf("r.Close: %v", err);
+			t.Errorf("r.Close: %v", err)
 		}
 	}
 }
@@ -215,24 +215,24 @@ func TestPipeWriteClose(t *testing.T) {
 		c := make(chan int, 1);
 		r, w := Pipe();
 		if tt.async {
-			go delayClose(t, r, c, tt);
+			go delayClose(t, r, c, tt)
 		} else {
-			delayClose(t, r, c, tt);
+			delayClose(t, r, c, tt)
 		}
 		n, err := WriteString(w, "hello, world");
 		<-c;
 		expect := tt.err;
 		if expect == nil {
-			expect = os.EPIPE;
+			expect = os.EPIPE
 		}
 		if err != expect {
-			t.Errorf("write on closed pipe: %v want %v", err, expect);
+			t.Errorf("write on closed pipe: %v want %v", err, expect)
 		}
 		if n != 0 {
-			t.Errorf("write on closed pipe returned %d", n);
+			t.Errorf("write on closed pipe returned %d", n)
 		}
 		if err = w.Close(); err != nil {
-			t.Errorf("w.Close: %v", err);
+			t.Errorf("w.Close: %v", err)
 		}
 	}
 }
diff --git a/src/pkg/io/utils.go b/src/pkg/io/utils.go
index 8c5c710b71..c98521d802 100644
--- a/src/pkg/io/utils.go
+++ b/src/pkg/io/utils.go
@@ -23,7 +23,7 @@ func ReadAll(r Reader) ([]byte, os.Error) {
 func ReadFile(filename string) ([]byte, os.Error) {
 	f, err := os.Open(filename, os.O_RDONLY, 0);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	defer f.Close();
 	return ReadAll(f);
@@ -35,12 +35,12 @@ func ReadFile(filename string) ([]byte, os.Error) {
 func WriteFile(filename string, data []byte, perm int) os.Error {
 	f, err := os.Open(filename, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, perm);
 	if err != nil {
-		return err;
+		return err
 	}
 	n, err := f.Write(data);
 	f.Close();
 	if err == nil && n < len(data) {
-		err = ErrShortWrite;
+		err = ErrShortWrite
 	}
 	return err;
 }
@@ -57,16 +57,16 @@ func (d dirList) Swap(i, j int)		{ d[i], d[j] = d[j], d[i] }
 func ReadDir(dirname string) ([]*os.Dir, os.Error) {
 	f, err := os.Open(dirname, os.O_RDONLY, 0);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	list, err := f.Readdir(-1);
 	f.Close();
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	dirs := make(dirList, len(list));
 	for i := range list {
-		dirs[i] = &list[i];
+		dirs[i] = &list[i]
 	}
 	sort.Sort(dirs);
 	return dirs, nil;
diff --git a/src/pkg/io/utils_test.go b/src/pkg/io/utils_test.go
index 9be9eeef80..b7f6e80f41 100644
--- a/src/pkg/io/utils_test.go
+++ b/src/pkg/io/utils_test.go
@@ -14,10 +14,10 @@ import (
 func checkSize(t *testing.T, path string, size uint64) {
 	dir, err := os.Stat(path);
 	if err != nil {
-		t.Fatalf("Stat %q (looking for size %d): %s", path, size, err);
+		t.Fatalf("Stat %q (looking for size %d): %s", path, size, err)
 	}
 	if dir.Size != size {
-		t.Errorf("Stat %q: size %d want %d", path, dir.Size, size);
+		t.Errorf("Stat %q: size %d want %d", path, dir.Size, size)
 	}
 }
 
@@ -25,13 +25,13 @@ func TestReadFile(t *testing.T) {
 	filename := "rumpelstilzchen";
 	contents, err := ReadFile(filename);
 	if err == nil {
-		t.Fatalf("ReadFile %s: error expected, none found", filename);
+		t.Fatalf("ReadFile %s: error expected, none found", filename)
 	}
 
 	filename = "utils_test.go";
 	contents, err = ReadFile(filename);
 	if err != nil {
-		t.Fatalf("ReadFile %s: %v", filename, err);
+		t.Fatalf("ReadFile %s: %v", filename, err)
 	}
 
 	checkSize(t, filename, uint64(len(contents)));
@@ -44,16 +44,16 @@ func TestWriteFile(t *testing.T) {
 		"to produce bigger and better idiots. So far, the Universe is winning.";
 
 	if err := WriteFile(filename, strings.Bytes(data), 0644); err != nil {
-		t.Fatalf("WriteFile %s: %v", filename, err);
+		t.Fatalf("WriteFile %s: %v", filename, err)
 	}
 
 	contents, err := ReadFile(filename);
 	if err != nil {
-		t.Fatalf("ReadFile %s: %v", filename, err);
+		t.Fatalf("ReadFile %s: %v", filename, err)
 	}
 
 	if string(contents) != data {
-		t.Fatalf("contents = %q\nexpected = %q", string(contents), data);
+		t.Fatalf("contents = %q\nexpected = %q", string(contents), data)
 	}
 
 	// cleanup
@@ -65,13 +65,13 @@ func TestReadDir(t *testing.T) {
 	dirname := "rumpelstilzchen";
 	_, err := ReadDir(dirname);
 	if err == nil {
-		t.Fatalf("ReadDir %s: error expected, none found", dirname);
+		t.Fatalf("ReadDir %s: error expected, none found", dirname)
 	}
 
 	dirname = ".";
 	list, err := ReadDir(dirname);
 	if err != nil {
-		t.Fatalf("ReadDir %s: %v", dirname, err);
+		t.Fatalf("ReadDir %s: %v", dirname, err)
 	}
 
 	foundTest := false;
@@ -79,15 +79,15 @@ func TestReadDir(t *testing.T) {
 	for _, dir := range list {
 		switch {
 		case dir.IsRegular() && dir.Name == "utils_test.go":
-			foundTest = true;
+			foundTest = true
 		case dir.IsDirectory() && dir.Name == "_obj":
-			foundObj = true;
+			foundObj = true
 		}
 	}
 	if !foundTest {
-		t.Fatalf("ReadDir %s: test file not found", dirname);
+		t.Fatalf("ReadDir %s: test file not found", dirname)
 	}
 	if !foundObj {
-		t.Fatalf("ReadDir %s: _obj directory not found", dirname);
+		t.Fatalf("ReadDir %s: _obj directory not found", dirname)
 	}
 }
diff --git a/src/pkg/json/generic.go b/src/pkg/json/generic.go
index a8ee836641..fb97edc19f 100644
--- a/src/pkg/json/generic.go
+++ b/src/pkg/json/generic.go
@@ -43,10 +43,10 @@ type Json interface {
 // j.String() == `abc`, but JsonToString(j) == `"abc"`.
 func JsonToString(j Json) string {
 	if j == nil {
-		return "null";
+		return "null"
 	}
 	if j.Kind() == StringKind {
-		return Quote(j.String());
+		return Quote(j.String())
 	}
 	return j.String();
 }
@@ -81,7 +81,7 @@ func (j *_Number) Kind() int		{ return NumberKind }
 func (j *_Number) Number() float64	{ return j.f }
 func (j *_Number) String() string {
 	if math.Floor(j.f) == j.f {
-		return fmt.Sprintf("%.0f", j.f);
+		return fmt.Sprintf("%.0f", j.f)
 	}
 	return fmt.Sprintf("%g", j.f);
 }
@@ -95,7 +95,7 @@ func (j *_Array) Kind() int	{ return ArrayKind }
 func (j *_Array) Len() int	{ return j.a.Len() }
 func (j *_Array) Elem(i int) Json {
 	if i < 0 || i >= j.a.Len() {
-		return Null;
+		return Null
 	}
 	return j.a.At(i).(Json);
 }
@@ -103,7 +103,7 @@ func (j *_Array) String() string {
 	s := "[";
 	for i := 0; i < j.a.Len(); i++ {
 		if i > 0 {
-			s += ",";
+			s += ","
 		}
 		s += JsonToString(j.a.At(i).(Json));
 	}
@@ -120,7 +120,7 @@ func (j *_Bool) Kind() int	{ return BoolKind }
 func (j *_Bool) Bool() bool	{ return j.b }
 func (j *_Bool) String() string {
 	if j.b {
-		return "true";
+		return "true"
 	}
 	return "false";
 }
@@ -134,11 +134,11 @@ func (j *_Map) Kind() int	{ return MapKind }
 func (j *_Map) Len() int	{ return len(j.m) }
 func (j *_Map) Get(s string) Json {
 	if j.m == nil {
-		return Null;
+		return Null
 	}
 	v, ok := j.m[s];
 	if !ok {
-		return Null;
+		return Null
 	}
 	return v;
 }
@@ -147,9 +147,9 @@ func (j *_Map) String() string {
 	first := true;
 	for k, v := range j.m {
 		if first {
-			first = false;
+			first = false
 		} else {
-			s += ",";
+			s += ","
 		}
 		s += Quote(k);
 		s += ":";
@@ -181,13 +181,13 @@ func Walk(j Json, path string) Json {
 		case ArrayKind:
 			indx, err := strconv.Atoi(elem);
 			if err != nil {
-				return Null;
+				return Null
 			}
 			j = j.Elem(indx);
 		case MapKind:
-			j = j.Get(elem);
+			j = j.Get(elem)
 		default:
-			return Null;
+			return Null
 		}
 	}
 	return j;
@@ -197,40 +197,40 @@ func Walk(j Json, path string) Json {
 func Equal(a, b Json) bool {
 	switch {
 	case a == nil && b == nil:
-		return true;
+		return true
 	case a == nil || b == nil:
-		return false;
+		return false
 	case a.Kind() != b.Kind():
-		return false;
+		return false
 	}
 
 	switch a.Kind() {
 	case NullKind:
-		return true;
+		return true
 	case StringKind:
-		return a.String() == b.String();
+		return a.String() == b.String()
 	case NumberKind:
-		return a.Number() == b.Number();
+		return a.Number() == b.Number()
 	case BoolKind:
-		return a.Bool() == b.Bool();
+		return a.Bool() == b.Bool()
 	case ArrayKind:
 		if a.Len() != b.Len() {
-			return false;
+			return false
 		}
 		for i := 0; i < a.Len(); i++ {
 			if !Equal(a.Elem(i), b.Elem(i)) {
-				return false;
+				return false
 			}
 		}
 		return true;
 	case MapKind:
 		m := a.(*_Map).m;
 		if len(m) != len(b.(*_Map).m) {
-			return false;
+			return false
 		}
 		for k, v := range m {
 			if !Equal(v, b.Get(k)) {
-				return false;
+				return false
 			}
 		}
 		return true;
@@ -259,22 +259,22 @@ type _JsonBuilder struct {
 func (b *_JsonBuilder) Put(j Json) {
 	switch {
 	case b.ptr != nil:
-		*b.ptr = j;
+		*b.ptr = j
 	case b.a != nil:
-		b.a.Set(b.i, j);
+		b.a.Set(b.i, j)
 	case b.m != nil:
-		b.m[b.k] = j;
+		b.m[b.k] = j
 	}
 }
 
 func (b *_JsonBuilder) Get() Json {
 	switch {
 	case b.ptr != nil:
-		return *b.ptr;
+		return *b.ptr
 	case b.a != nil:
-		return b.a.At(b.i).(Json);
+		return b.a.At(b.i).(Json)
 	case b.m != nil:
-		return b.m[b.k];
+		return b.m[b.k]
 	}
 	return nil;
 }
@@ -301,7 +301,7 @@ func (b *_JsonBuilder) Elem(i int) Builder {
 	bb.a = b.Get().(*_Array).a;
 	bb.i = i;
 	for i >= bb.a.Len() {
-		bb.a.Push(Null);
+		bb.a.Push(Null)
 	}
 	return bb;
 }
@@ -327,7 +327,7 @@ func StringToJson(s string) (json Json, ok bool, errtok string) {
 	b.ptr = &j;
 	ok, _, errtok = Parse(s, b);
 	if !ok {
-		return nil, false, errtok;
+		return nil, false, errtok
 	}
 	return j, true, "";
 }
diff --git a/src/pkg/json/generic_test.go b/src/pkg/json/generic_test.go
index 522d82dcd2..ce78a39ee4 100644
--- a/src/pkg/json/generic_test.go
+++ b/src/pkg/json/generic_test.go
@@ -44,10 +44,10 @@ func TestJsonMap(t *testing.T) {
 	for i := 0; i < len(jsontests); i++ {
 		val, ok, errtok := StringToJson(jsontests[i]);
 		if !ok {
-			t.Errorf("StringToJson(%#q) => error near %v", jsontests[i], errtok);
+			t.Errorf("StringToJson(%#q) => error near %v", jsontests[i], errtok)
 		}
 		if i > 0 {
-			mapstr += ",";
+			mapstr += ","
 		}
 		values[jsontests[i]] = val;
 		mapstr += Quote(jsontests[i]);
@@ -58,18 +58,18 @@ func TestJsonMap(t *testing.T) {
 
 	mapv, ok, errtok := StringToJson(mapstr);
 	if !ok {
-		t.Fatalf("StringToJson(%#q) => error near %v", mapstr, errtok);
+		t.Fatalf("StringToJson(%#q) => error near %v", mapstr, errtok)
 	}
 	if mapv == nil {
-		t.Fatalf("StringToJson(%#q) => nil, %v, %v", mapstr, ok, errtok);
+		t.Fatalf("StringToJson(%#q) => nil, %v, %v", mapstr, ok, errtok)
 	}
 	if cnt := mapv.Len(); cnt != len(jsontests) {
 		t.Errorf("StringToJson(%#q).Len() => %v, want %v", mapstr, cnt,
-			len(jsontests));
+			len(jsontests))
 	}
 	for k, v := range values {
 		if v1 := mapv.Get(k); !Equal(v1, v) {
-			t.Errorf("MapTest: Walk(%#q) => %v, want %v", k, v1, v);
+			t.Errorf("MapTest: Walk(%#q) => %v, want %v", k, v1, v)
 		}
 	}
 }
diff --git a/src/pkg/json/parse.go b/src/pkg/json/parse.go
index 26c01fe850..74208824b4 100644
--- a/src/pkg/json/parse.go
+++ b/src/pkg/json/parse.go
@@ -26,18 +26,18 @@ func _UnHex(p string, r, l int) (v int, ok bool) {
 	v = 0;
 	for i := r; i < l; i++ {
 		if i >= len(p) {
-			return 0, false;
+			return 0, false
 		}
 		v *= 16;
 		switch {
 		case '0' <= p[i] && p[i] <= '9':
-			v += int(p[i]-'0');
+			v += int(p[i]-'0')
 		case 'a' <= p[i] && p[i] <= 'f':
-			v += int(p[i]-'a'+10);
+			v += int(p[i]-'a'+10)
 		case 'A' <= p[i] && p[i] <= 'F':
-			v += int(p[i]-'A'+10);
+			v += int(p[i]-'A'+10)
 		default:
-			return 0, false;
+			return 0, false
 		}
 	}
 	return v, true;
@@ -48,7 +48,7 @@ func _UnHex(p string, r, l int) (v int, ok bool) {
 // JSON-quoted string, Unquote returns with ok set to false.
 func Unquote(s string) (t string, ok bool) {
 	if len(s) < 2 || s[0] != '"' || s[len(s)-1] != '"' {
-		return;
+		return
 	}
 	b := make([]byte, len(s));
 	w := 0;
@@ -57,11 +57,11 @@ func Unquote(s string) (t string, ok bool) {
 		case s[r] == '\\':
 			r++;
 			if r >= len(s)-1 {
-				return;
+				return
 			}
 			switch s[r] {
 			default:
-				return;
+				return
 			case '"', '\\', '/', '\'':
 				b[w] = s[r];
 				r++;
@@ -90,7 +90,7 @@ func Unquote(s string) (t string, ok bool) {
 				r++;
 				rune, ok := _UnHex(s, r, 4);
 				if !ok {
-					return;
+					return
 				}
 				r += 4;
 				w += utf8.EncodeRune(rune, b[w:len(b)]);
@@ -180,21 +180,21 @@ type _Lexer struct {
 }
 
 func punct(c byte) bool {
-	return c == '"' || c == '[' || c == ']' || c == ':' || c == '{' || c == '}' || c == ',';
+	return c == '"' || c == '[' || c == ']' || c == ':' || c == '{' || c == '}' || c == ','
 }
 
 func white(c byte) bool	{ return c == ' ' || c == '\t' || c == '\n' || c == '\v' }
 
 func skipwhite(p string, i int) int {
 	for i < len(p) && white(p[i]) {
-		i++;
+		i++
 	}
 	return i;
 }
 
 func skiptoken(p string, i int) int {
 	for i < len(p) && !punct(p[i]) && !white(p[i]) {
-		i++;
+		i++
 	}
 	return i;
 }
@@ -202,11 +202,11 @@ func skiptoken(p string, i int) int {
 func skipstring(p string, i int) int {
 	for i++; i < len(p) && p[i] != '"'; i++ {
 		if p[i] == '\\' {
-			i++;
+			i++
 		}
 	}
 	if i >= len(p) {
-		return i;
+		return i
 	}
 	return i+1;
 }
@@ -304,7 +304,7 @@ func parse(lex *_Lexer, build Builder) bool {
 Switch:
 	switch lex.kind {
 	case 0:
-		break;
+		break
 	case '1':
 		// If the number is exactly an integer, use that.
 		if i, err := strconv.Atoi64(lex.token); err == nil {
@@ -347,12 +347,12 @@ Switch:
 		for lex.kind != ']' {
 			if n > 0 {
 				if lex.kind != ',' {
-					break Switch;
+					break Switch
 				}
 				lex.Next();
 			}
 			if !parse(lex, build.Elem(n)) {
-				break Switch;
+				break Switch
 			}
 			n++;
 		}
@@ -366,24 +366,24 @@ Switch:
 		for lex.kind != '}' {
 			if n > 0 {
 				if lex.kind != ',' {
-					break Switch;
+					break Switch
 				}
 				lex.Next();
 			}
 			if lex.kind != '"' {
-				break Switch;
+				break Switch
 			}
 			key, ok := Unquote(lex.token);
 			if !ok {
-				break Switch;
+				break Switch
 			}
 			lex.Next();
 			if lex.kind != ':' {
-				break Switch;
+				break Switch
 			}
 			lex.Next();
 			if !parse(lex, build.Key(key)) {
-				break Switch;
+				break Switch
 			}
 			n++;
 		}
@@ -391,7 +391,7 @@ Switch:
 	}
 
 	if ok {
-		lex.Next();
+		lex.Next()
 	}
 	build.Flush();
 	return ok;
@@ -409,7 +409,7 @@ func Parse(s string, builder Builder) (ok bool, errindx int, errtok string) {
 	lex.Next();
 	if parse(lex, builder) {
 		if lex.kind == 0 {	// EOF
-			return true, 0, "";
+			return true, 0, ""
 		}
 	}
 	return false, lex.i, lex.token;
diff --git a/src/pkg/json/struct.go b/src/pkg/json/struct.go
index 37728d38bb..11aaccee9d 100644
--- a/src/pkg/json/struct.go
+++ b/src/pkg/json/struct.go
@@ -25,7 +25,7 @@ var nobuilder *structBuilder
 func isfloat(v reflect.Value) bool {
 	switch v.(type) {
 	case *reflect.FloatValue, *reflect.Float32Value, *reflect.Float64Value:
-		return true;
+		return true
 	}
 	return false;
 }
@@ -33,36 +33,36 @@ func isfloat(v reflect.Value) bool {
 func setfloat(v reflect.Value, f float64) {
 	switch v := v.(type) {
 	case *reflect.FloatValue:
-		v.Set(float(f));
+		v.Set(float(f))
 	case *reflect.Float32Value:
-		v.Set(float32(f));
+		v.Set(float32(f))
 	case *reflect.Float64Value:
-		v.Set(float64(f));
+		v.Set(float64(f))
 	}
 }
 
 func setint(v reflect.Value, i int64) {
 	switch v := v.(type) {
 	case *reflect.IntValue:
-		v.Set(int(i));
+		v.Set(int(i))
 	case *reflect.Int8Value:
-		v.Set(int8(i));
+		v.Set(int8(i))
 	case *reflect.Int16Value:
-		v.Set(int16(i));
+		v.Set(int16(i))
 	case *reflect.Int32Value:
-		v.Set(int32(i));
+		v.Set(int32(i))
 	case *reflect.Int64Value:
-		v.Set(int64(i));
+		v.Set(int64(i))
 	case *reflect.UintValue:
-		v.Set(uint(i));
+		v.Set(uint(i))
 	case *reflect.Uint8Value:
-		v.Set(uint8(i));
+		v.Set(uint8(i))
 	case *reflect.Uint16Value:
-		v.Set(uint16(i));
+		v.Set(uint16(i))
 	case *reflect.Uint32Value:
-		v.Set(uint32(i));
+		v.Set(uint32(i))
 	case *reflect.Uint64Value:
-		v.Set(uint64(i));
+		v.Set(uint64(i))
 	}
 }
 
@@ -70,46 +70,46 @@ func setint(v reflect.Value, i int64) {
 // copy a changed b.val out to the original.
 func (b *structBuilder) Flush() {
 	if b == nil {
-		return;
+		return
 	}
 	if b.map_ != nil {
-		b.map_.SetElem(b.key, b.val);
+		b.map_.SetElem(b.key, b.val)
 	}
 }
 
 func (b *structBuilder) Int64(i int64) {
 	if b == nil {
-		return;
+		return
 	}
 	v := b.val;
 	if isfloat(v) {
-		setfloat(v, float64(i));
+		setfloat(v, float64(i))
 	} else {
-		setint(v, i);
+		setint(v, i)
 	}
 }
 
 func (b *structBuilder) Uint64(i uint64) {
 	if b == nil {
-		return;
+		return
 	}
 	v := b.val;
 	if isfloat(v) {
-		setfloat(v, float64(i));
+		setfloat(v, float64(i))
 	} else {
-		setint(v, int64(i));
+		setint(v, int64(i))
 	}
 }
 
 func (b *structBuilder) Float64(f float64) {
 	if b == nil {
-		return;
+		return
 	}
 	v := b.val;
 	if isfloat(v) {
-		setfloat(v, f);
+		setfloat(v, f)
 	} else {
-		setint(v, int64(f));
+		setint(v, int64(f))
 	}
 }
 
@@ -117,60 +117,60 @@ func (b *structBuilder) Null()	{}
 
 func (b *structBuilder) String(s string) {
 	if b == nil {
-		return;
+		return
 	}
 	if v, ok := b.val.(*reflect.StringValue); ok {
-		v.Set(s);
+		v.Set(s)
 	}
 }
 
 func (b *structBuilder) Bool(tf bool) {
 	if b == nil {
-		return;
+		return
 	}
 	if v, ok := b.val.(*reflect.BoolValue); ok {
-		v.Set(tf);
+		v.Set(tf)
 	}
 }
 
 func (b *structBuilder) Array() {
 	if b == nil {
-		return;
+		return
 	}
 	if v, ok := b.val.(*reflect.SliceValue); ok {
 		if v.IsNil() {
-			v.Set(reflect.MakeSlice(v.Type().(*reflect.SliceType), 0, 8));
+			v.Set(reflect.MakeSlice(v.Type().(*reflect.SliceType), 0, 8))
 		}
 	}
 }
 
 func (b *structBuilder) Elem(i int) Builder {
 	if b == nil || i < 0 {
-		return nobuilder;
+		return nobuilder
 	}
 	switch v := b.val.(type) {
 	case *reflect.ArrayValue:
 		if i < v.Len() {
-			return &structBuilder{val: v.Elem(i)};
+			return &structBuilder{val: v.Elem(i)}
 		}
 	case *reflect.SliceValue:
 		if i > v.Cap() {
 			n := v.Cap();
 			if n < 8 {
-				n = 8;
+				n = 8
 			}
 			for n <= i {
-				n *= 2;
+				n *= 2
 			}
 			nv := reflect.MakeSlice(v.Type().(*reflect.SliceType), v.Len(), n);
 			reflect.ArrayCopy(nv, v);
 			v.Set(nv);
 		}
 		if v.Len() <= i && i < v.Cap() {
-			v.SetLen(i+1);
+			v.SetLen(i+1)
 		}
 		if i < v.Len() {
-			return &structBuilder{val: v.Elem(i)};
+			return &structBuilder{val: v.Elem(i)}
 		}
 	}
 	return nobuilder;
@@ -178,7 +178,7 @@ func (b *structBuilder) Elem(i int) Builder {
 
 func (b *structBuilder) Map() {
 	if b == nil {
-		return;
+		return
 	}
 	if v, ok := b.val.(*reflect.PtrValue); ok && v.IsNil() {
 		if v.IsNil() {
@@ -189,13 +189,13 @@ func (b *structBuilder) Map() {
 		b.val = v.Elem();
 	}
 	if v, ok := b.val.(*reflect.MapValue); ok && v.IsNil() {
-		v.Set(reflect.MakeMap(v.Type().(*reflect.MapType)));
+		v.Set(reflect.MakeMap(v.Type().(*reflect.MapType)))
 	}
 }
 
 func (b *structBuilder) Key(k string) Builder {
 	if b == nil {
-		return nobuilder;
+		return nobuilder
 	}
 	switch v := reflect.Indirect(b.val).(type) {
 	case *reflect.StructValue:
@@ -204,13 +204,13 @@ func (b *structBuilder) Key(k string) Builder {
 		k = strings.ToLower(k);
 		for i := 0; i < t.NumField(); i++ {
 			if strings.ToLower(t.Field(i).Name) == k {
-				return &structBuilder{val: v.Field(i)};
+				return &structBuilder{val: v.Field(i)}
 			}
 		}
 	case *reflect.MapValue:
 		t := v.Type().(*reflect.MapType);
 		if t.Key() != reflect.Typeof(k) {
-			break;
+			break
 		}
 		key := reflect.NewValue(k);
 		elem := v.Elem(key);
@@ -286,7 +286,7 @@ func Unmarshal(s string, val interface{}) (ok bool, errtok string) {
 	b := &structBuilder{val: reflect.NewValue(val)};
 	ok, _, errtok = Parse(s, b);
 	if !ok {
-		return false, errtok;
+		return false, errtok
 	}
 	return true, "";
 }
diff --git a/src/pkg/json/struct_test.go b/src/pkg/json/struct_test.go
index ad86d493f9..95a3eb2a4e 100644
--- a/src/pkg/json/struct_test.go
+++ b/src/pkg/json/struct_test.go
@@ -58,9 +58,9 @@ var decodedMapPtrStruct = map[string]*myStruct{
 
 func check(t *testing.T, ok bool, name string, v interface{}) {
 	if !ok {
-		t.Errorf("%s = %v (BAD)", name, v);
+		t.Errorf("%s = %v (BAD)", name, v)
 	} else {
-		t.Logf("%s = %v (good)", name, v);
+		t.Logf("%s = %v (good)", name, v)
 	}
 }
 
@@ -69,7 +69,7 @@ func TestUnmarshal(t *testing.T) {
 	m.F = true;
 	ok, errtok := Unmarshal(encoded, &m);
 	if !ok {
-		t.Fatalf("Unmarshal failed near %s", errtok);
+		t.Fatalf("Unmarshal failed near %s", errtok)
 	}
 	check(t, m.T == true, "t", m.T);
 	check(t, m.F == false, "f", m.F);
@@ -95,7 +95,7 @@ func TestUnmarshal(t *testing.T) {
 	}
 	check(t, m.My != nil, "my", m.My);
 	if m.My != nil {
-		check(t, m.My.S == "subguy", "my.s", m.My.S);
+		check(t, m.My.S == "subguy", "my.s", m.My.S)
 	}
 	check(t, reflect.DeepEqual(m.Map, decodedMap), "map", m.Map);
 	check(t, reflect.DeepEqual(m.MapStruct, decodedMapStruct), "mapstruct", m.MapStruct);
diff --git a/src/pkg/log/log.go b/src/pkg/log/log.go
index 04b1e4fa9e..0ace84c0a0 100644
--- a/src/pkg/log/log.go
+++ b/src/pkg/log/log.go
@@ -50,7 +50,7 @@ type Logger struct {
 // The prefix appears at the beginning of each generated log line.
 // The flag argument defines the logging properties.
 func New(out0, out1 io.Writer, prefix string, flag int) *Logger {
-	return &Logger{out0, out1, prefix, flag};
+	return &Logger{out0, out1, prefix, flag}
 }
 
 var (
@@ -66,7 +66,7 @@ var shortnames = make(map[string]string)	// cache of short names to avoid alloca
 func itoa(i int, wid int) string {
 	var u uint = uint(i);
 	if u == 0 && wid <= 1 {
-		return "0";
+		return "0"
 	}
 
 	// Assemble decimal in reverse order.
@@ -86,12 +86,12 @@ func (l *Logger) formatHeader(ns int64, calldepth int) string {
 	if l.flag & (Ldate | Ltime | Lmicroseconds) != 0 {
 		t := time.SecondsToLocalTime(ns/1e9);
 		if l.flag & (Ldate) != 0 {
-			h += itoa(int(t.Year), 4) + "/" + itoa(t.Month, 2) + "/" + itoa(t.Day, 2) + " ";
+			h += itoa(int(t.Year), 4) + "/" + itoa(t.Month, 2) + "/" + itoa(t.Day, 2) + " "
 		}
 		if l.flag & (Ltime | Lmicroseconds) != 0 {
 			h += itoa(t.Hour, 2) + ":" + itoa(t.Minute, 2) + ":" + itoa(t.Second, 2);
 			if l.flag & Lmicroseconds != 0 {
-				h += "." + itoa(int(ns%1e9)/1e3, 6);
+				h += "." + itoa(int(ns%1e9)/1e3, 6)
 			}
 			h += " ";
 		}
@@ -129,18 +129,18 @@ func (l *Logger) Output(calldepth int, s string) {
 	now := time.Nanoseconds();	// get this early.
 	newline := "\n";
 	if len(s) > 0 && s[len(s)-1] == '\n' {
-		newline = "";
+		newline = ""
 	}
 	s = l.formatHeader(now, calldepth + 1) + s + newline;
 	io.WriteString(l.out0, s);
 	if l.out1 != nil {
-		io.WriteString(l.out1, s);
+		io.WriteString(l.out1, s)
 	}
 	switch l.flag & ^lAllBits {
 	case Lcrash:
-		panic("log: fatal error");
+		panic("log: fatal error")
 	case Lexit:
-		os.Exit(1);
+		os.Exit(1)
 	}
 }
 
diff --git a/src/pkg/log/log_test.go b/src/pkg/log/log_test.go
index f26ce4087e..66260935db 100644
--- a/src/pkg/log/log_test.go
+++ b/src/pkg/log/log_test.go
@@ -48,29 +48,29 @@ var tests = []tester{
 func testLog(t *testing.T, flag int, prefix string, pattern string, useLogf bool) {
 	r, w, err1 := os.Pipe();
 	if err1 != nil {
-		t.Fatal("pipe", err1);
+		t.Fatal("pipe", err1)
 	}
 	defer r.Close();
 	defer w.Close();
 	buf := bufio.NewReader(r);
 	l := New(w, nil, prefix, flag);
 	if useLogf {
-		l.Logf("hello %d world", 23);
+		l.Logf("hello %d world", 23)
 	} else {
-		l.Log("hello", 23, "world");
+		l.Log("hello", 23, "world")
 	}
 	line, err3 := buf.ReadString('\n');
 	if err3 != nil {
-		t.Fatal("log error", err3);
+		t.Fatal("log error", err3)
 	}
 	line = line[0 : len(line)-1];
 	pattern = "^" + pattern + "hello 23 world$";
 	matched, err4 := regexp.MatchString(pattern, line);
 	if err4 != nil {
-		t.Fatal("pattern did not compile:", err4);
+		t.Fatal("pattern did not compile:", err4)
 	}
 	if !matched {
-		t.Errorf("log output should match %q is %q", pattern, line);
+		t.Errorf("log output should match %q is %q", pattern, line)
 	}
 }
 
diff --git a/src/pkg/math/all_test.go b/src/pkg/math/all_test.go
index 06c5be2007..7e53044eac 100644
--- a/src/pkg/math/all_test.go
+++ b/src/pkg/math/all_test.go
@@ -157,13 +157,13 @@ var tanh = []float64{
 func tolerance(a, b, e float64) bool {
 	d := a-b;
 	if d < 0 {
-		d = -d;
+		d = -d
 	}
 
 	if a != 0 {
 		e = e*a;
 		if e < 0 {
-			e = -e;
+			e = -e
 		}
 	}
 	return d < e;
@@ -174,7 +174,7 @@ func veryclose(a, b float64) bool	{ return tolerance(a, b, 4e-16) }
 func TestAsin(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		if f := Asin(vf[i]/10); !veryclose(asin[i], f) {
-			t.Errorf("Asin(%g) = %g, want %g\n", vf[i]/10, f, asin[i]);
+			t.Errorf("Asin(%g) = %g, want %g\n", vf[i]/10, f, asin[i])
 		}
 	}
 }
@@ -182,7 +182,7 @@ func TestAsin(t *testing.T) {
 func TestAtan(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		if f := Atan(vf[i]); !veryclose(atan[i], f) {
-			t.Errorf("Atan(%g) = %g, want %g\n", vf[i], f, atan[i]);
+			t.Errorf("Atan(%g) = %g, want %g\n", vf[i], f, atan[i])
 		}
 	}
 }
@@ -190,7 +190,7 @@ func TestAtan(t *testing.T) {
 func TestExp(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		if f := Exp(vf[i]); !veryclose(exp[i], f) {
-			t.Errorf("Exp(%g) = %g, want %g\n", vf[i], f, exp[i]);
+			t.Errorf("Exp(%g) = %g, want %g\n", vf[i], f, exp[i])
 		}
 	}
 }
@@ -198,7 +198,7 @@ func TestExp(t *testing.T) {
 func TestFloor(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		if f := Floor(vf[i]); floor[i] != f {
-			t.Errorf("Floor(%g) = %g, want %g\n", vf[i], f, floor[i]);
+			t.Errorf("Floor(%g) = %g, want %g\n", vf[i], f, floor[i])
 		}
 	}
 }
@@ -207,18 +207,18 @@ func TestLog(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		a := Fabs(vf[i]);
 		if f := Log(a); log[i] != f {
-			t.Errorf("Log(%g) = %g, want %g\n", a, f, log[i]);
+			t.Errorf("Log(%g) = %g, want %g\n", a, f, log[i])
 		}
 	}
 	if f := Log(10); f != Ln10 {
-		t.Errorf("Log(%g) = %g, want %g\n", 10, f, Ln10);
+		t.Errorf("Log(%g) = %g, want %g\n", 10, f, Ln10)
 	}
 }
 
 func TestPow(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		if f := Pow(10, vf[i]); !close(pow[i], f) {
-			t.Errorf("Pow(10, %.17g) = %.17g, want %.17g\n", vf[i], f, pow[i]);
+			t.Errorf("Pow(10, %.17g) = %.17g, want %.17g\n", vf[i], f, pow[i])
 		}
 	}
 }
@@ -226,7 +226,7 @@ func TestPow(t *testing.T) {
 func TestSin(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		if f := Sin(vf[i]); !close(sin[i], f) {
-			t.Errorf("Sin(%g) = %g, want %g\n", vf[i], f, sin[i]);
+			t.Errorf("Sin(%g) = %g, want %g\n", vf[i], f, sin[i])
 		}
 	}
 }
@@ -234,7 +234,7 @@ func TestSin(t *testing.T) {
 func TestSinh(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		if f := Sinh(vf[i]); !veryclose(sinh[i], f) {
-			t.Errorf("Sinh(%g) = %g, want %g\n", vf[i], f, sinh[i]);
+			t.Errorf("Sinh(%g) = %g, want %g\n", vf[i], f, sinh[i])
 		}
 	}
 }
@@ -243,7 +243,7 @@ func TestSqrt(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		a := Fabs(vf[i]);
 		if f := Sqrt(a); !veryclose(sqrt[i], f) {
-			t.Errorf("Sqrt(%g) = %g, want %g\n", a, f, floor[i]);
+			t.Errorf("Sqrt(%g) = %g, want %g\n", a, f, floor[i])
 		}
 	}
 }
@@ -251,7 +251,7 @@ func TestSqrt(t *testing.T) {
 func TestTan(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		if f := Tan(vf[i]); !close(tan[i], f) {
-			t.Errorf("Tan(%g) = %g, want %g\n", vf[i], f, tan[i]);
+			t.Errorf("Tan(%g) = %g, want %g\n", vf[i], f, tan[i])
 		}
 	}
 }
@@ -259,7 +259,7 @@ func TestTan(t *testing.T) {
 func TestTanh(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		if f := Tanh(vf[i]); !veryclose(tanh[i], f) {
-			t.Errorf("Tanh(%g) = %g, want %g\n", vf[i], f, tanh[i]);
+			t.Errorf("Tanh(%g) = %g, want %g\n", vf[i], f, tanh[i])
 		}
 	}
 }
@@ -268,7 +268,7 @@ func TestHypot(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		a := Fabs(tanh[i]*Sqrt(2));
 		if f := Hypot(tanh[i], tanh[i]); !veryclose(a, f) {
-			t.Errorf("Hypot(%g, %g) = %g, want %g\n", tanh[i], tanh[i], f, a);
+			t.Errorf("Hypot(%g, %g) = %g, want %g\n", tanh[i], tanh[i], f, a)
 		}
 	}
 }
diff --git a/src/pkg/math/asin.go b/src/pkg/math/asin.go
index 38fc365b35..c4696e8e3a 100644
--- a/src/pkg/math/asin.go
+++ b/src/pkg/math/asin.go
@@ -20,18 +20,18 @@ func Asin(x float64) float64 {
 		sign = true;
 	}
 	if x > 1 {
-		return NaN();
+		return NaN()
 	}
 
 	temp := Sqrt(1 - x*x);
 	if x > 0.7 {
-		temp = Pi/2 - Atan(temp/x);
+		temp = Pi/2 - Atan(temp/x)
 	} else {
-		temp = Atan(x/temp);
+		temp = Atan(x/temp)
 	}
 
 	if sign {
-		temp = -temp;
+		temp = -temp
 	}
 	return temp;
 }
@@ -39,7 +39,7 @@ func Asin(x float64) float64 {
 // Acos returns the arc cosine of x.
 func Acos(x float64) float64 {
 	if x > 1 || x < -1 {
-		return NaN();
+		return NaN()
 	}
 	return Pi/2 - Asin(x);
 }
diff --git a/src/pkg/math/atan.go b/src/pkg/math/atan.go
index 37b49c7842..641f905518 100644
--- a/src/pkg/math/atan.go
+++ b/src/pkg/math/atan.go
@@ -43,10 +43,10 @@ func xatan(arg float64) float64 {
  */
 func satan(arg float64) float64 {
 	if arg < Sqrt2-1 {
-		return xatan(arg);
+		return xatan(arg)
 	}
 	if arg > Sqrt2+1 {
-		return Pi/2 - xatan(1/arg);
+		return Pi/2 - xatan(1/arg)
 	}
 	return Pi/4 + xatan((arg-1)/(arg+1));
 }
@@ -59,7 +59,7 @@ func satan(arg float64) float64 {
 // Atan returns the arc tangent of x.
 func Atan(x float64) float64 {
 	if x > 0 {
-		return satan(x);
+		return satan(x)
 	}
 	return -satan(-x);
 }
diff --git a/src/pkg/math/atan2.go b/src/pkg/math/atan2.go
index 5ded1a412f..95226b9d8d 100644
--- a/src/pkg/math/atan2.go
+++ b/src/pkg/math/atan2.go
@@ -12,14 +12,14 @@ func Atan2(x, y float64) float64 {
 	// Determine the quadrant and call atan.
 	if x+y == x {
 		if x >= 0 {
-			return Pi/2;
+			return Pi/2
 		}
 		return -Pi / 2;
 	}
 	q := Atan(x/y);
 	if y < 0 {
 		if q <= 0 {
-			return q+Pi;
+			return q+Pi
 		}
 		return q-Pi;
 	}
diff --git a/src/pkg/math/bits.go b/src/pkg/math/bits.go
index 3084ed508f..b1bf2da46e 100644
--- a/src/pkg/math/bits.go
+++ b/src/pkg/math/bits.go
@@ -17,9 +17,9 @@ const (
 func Inf(sign int) float64 {
 	var v uint64;
 	if sign >= 0 {
-		v = uvinf;
+		v = uvinf
 	} else {
-		v = uvneginf;
+		v = uvneginf
 	}
 	return Float64frombits(v);
 }
@@ -48,7 +48,7 @@ func IsInf(f float64, sign int) bool {
 // with the absolute value of frac in the interval [½, 1).
 func Frexp(f float64) (frac float64, exp int) {
 	if f == 0 {
-		return;
+		return
 	}
 	x := Float64bits(f);
 	exp = int((x>>shift)&mask)-bias;
@@ -64,11 +64,11 @@ func Ldexp(frac float64, exp int) float64 {
 	x := Float64bits(frac);
 	exp += int(x>>shift)&mask;
 	if exp <= 0 {
-		return 0;	// underflow
+		return 0	// underflow
 	}
 	if exp >= mask {	// overflow
 		if frac < 0 {
-			return Inf(-1);
+			return Inf(-1)
 		}
 		return Inf(1);
 	}
@@ -94,7 +94,7 @@ func Modf(f float64) (int float64, frac float64) {
 
 	// Keep the top 11+e bits, the integer part; clear the rest.
 	if e < 64-11 {
-		x &^= 1<<(64-11-e) - 1;
+		x &^= 1<<(64-11-e) - 1
 	}
 	int = Float64frombits(x);
 	frac = f-int;
diff --git a/src/pkg/math/exp.go b/src/pkg/math/exp.go
index 2bf80bcdd6..a5f562031a 100644
--- a/src/pkg/math/exp.go
+++ b/src/pkg/math/exp.go
@@ -107,24 +107,24 @@ func Exp(x float64) float64 {
 	// special cases
 	switch {
 	case IsNaN(x) || IsInf(x, 1):
-		return x;
+		return x
 	case IsInf(x, -1):
-		return 0;
+		return 0
 	case x > Overflow:
-		return Inf(1);
+		return Inf(1)
 	case x < Underflow:
-		return 0;
+		return 0
 	case -NearZero < x && x < NearZero:
-		return 1;
+		return 1
 	}
 
 	// reduce; computed as r = hi - lo for extra precision.
 	var k int;
 	switch {
 	case x < 0:
-		k = int(Log2e*x - 0.5);
+		k = int(Log2e*x - 0.5)
 	case x > 0:
-		k = int(Log2e*x + 0.5);
+		k = int(Log2e*x + 0.5)
 	}
 	hi := x - float64(k)*Ln2Hi;
 	lo := float64(k)*Ln2Lo;
diff --git a/src/pkg/math/fabs.go b/src/pkg/math/fabs.go
index 254756cc4e..752133e0cb 100644
--- a/src/pkg/math/fabs.go
+++ b/src/pkg/math/fabs.go
@@ -7,7 +7,7 @@ package math
 // Fabs returns the absolute value of x.
 func Fabs(x float64) float64 {
 	if x < 0 {
-		return -x;
+		return -x
 	}
 	return x;
 }
diff --git a/src/pkg/math/floor.go b/src/pkg/math/floor.go
index cb3110fb2e..7a999852d7 100644
--- a/src/pkg/math/floor.go
+++ b/src/pkg/math/floor.go
@@ -10,7 +10,7 @@ func Floor(x float64) float64 {
 	if x < 0 {
 		d, fract := Modf(-x);
 		if fract != 0.0 {
-			d = d+1;
+			d = d+1
 		}
 		return -d;
 	}
diff --git a/src/pkg/math/fmod.go b/src/pkg/math/fmod.go
index a01c257d9b..34fbfbdb76 100644
--- a/src/pkg/math/fmod.go
+++ b/src/pkg/math/fmod.go
@@ -12,10 +12,10 @@ package math
 // Fmod returns the floating-point remainder of x/y.
 func Fmod(x, y float64) float64 {
 	if y == 0 {
-		return x;
+		return x
 	}
 	if y < 0 {
-		y = -y;
+		y = -y
 	}
 
 	yfr, yexp := Frexp(y);
@@ -29,12 +29,12 @@ func Fmod(x, y float64) float64 {
 	for r >= y {
 		rfr, rexp := Frexp(r);
 		if rfr < yfr {
-			rexp = rexp-1;
+			rexp = rexp-1
 		}
 		r = r - Ldexp(y, rexp-yexp);
 	}
 	if sign {
-		r = -r;
+		r = -r
 	}
 	return r;
 }
diff --git a/src/pkg/math/hypot.go b/src/pkg/math/hypot.go
index 6ba8fb7946..7ff8f4badb 100644
--- a/src/pkg/math/hypot.go
+++ b/src/pkg/math/hypot.go
@@ -16,18 +16,18 @@ package math
 // unnecessary overflow and underflow.
 func Hypot(p, q float64) float64 {
 	if p < 0 {
-		p = -p;
+		p = -p
 	}
 	if q < 0 {
-		q = -q;
+		q = -q
 	}
 
 	if p < q {
-		p, q = q, p;
+		p, q = q, p
 	}
 
 	if p == 0 {
-		return 0;
+		return 0
 	}
 
 	pfac := p;
@@ -38,7 +38,7 @@ func Hypot(p, q float64) float64 {
 		r = r*r;
 		s := r+4;
 		if s == 4 {
-			return p*pfac;
+			return p*pfac
 		}
 		r = r/s;
 		p = p + 2*r*p;
diff --git a/src/pkg/math/log.go b/src/pkg/math/log.go
index 22df7ac1b0..bf8b49a7af 100644
--- a/src/pkg/math/log.go
+++ b/src/pkg/math/log.go
@@ -90,11 +90,11 @@ func Log(x float64) float64 {
 	// special cases
 	switch {
 	case IsNaN(x) || IsInf(x, 1):
-		return x;
+		return x
 	case x < 0:
-		return NaN();
+		return NaN()
 	case x == 0:
-		return Inf(-1);
+		return Inf(-1)
 	}
 
 	// reduce
@@ -121,7 +121,7 @@ func Log(x float64) float64 {
 // The special cases are the same as for Log.
 func Log10(x float64) float64 {
 	if x <= 0 {
-		return NaN();
+		return NaN()
 	}
 	return Log(x)*(1/Ln10);
 }
diff --git a/src/pkg/math/pow.go b/src/pkg/math/pow.go
index b5364fe7f7..9754809364 100644
--- a/src/pkg/math/pow.go
+++ b/src/pkg/math/pow.go
@@ -10,17 +10,17 @@ func Pow(x, y float64) float64 {
 	// TODO: x or y NaN, ±Inf, maybe ±0.
 	switch {
 	case y == 0:
-		return 1;
+		return 1
 	case y == 1:
-		return x;
+		return x
 	case x == 0 && y > 0:
-		return 0;
+		return 0
 	case x == 0 && y < 0:
-		return Inf(1);
+		return Inf(1)
 	case y == 0.5:
-		return Sqrt(x);
+		return Sqrt(x)
 	case y == -0.5:
-		return 1/Sqrt(x);
+		return 1/Sqrt(x)
 	}
 
 	absy := y;
@@ -31,10 +31,10 @@ func Pow(x, y float64) float64 {
 	}
 	yi, yf := Modf(absy);
 	if yf != 0 && x < 0 {
-		return NaN();
+		return NaN()
 	}
 	if yi >= 1<<63 {
-		return Exp(y*Log(x));
+		return Exp(y*Log(x))
 	}
 
 	// ans = a1 * 2^ae (= 1 for now).
diff --git a/src/pkg/math/pow10.go b/src/pkg/math/pow10.go
index b9b074bb4d..1ae6dcd738 100644
--- a/src/pkg/math/pow10.go
+++ b/src/pkg/math/pow10.go
@@ -18,10 +18,10 @@ var pow10tab [70]float64
 // Pow10 returns 10**x, the base-10 exponential of x.
 func Pow10(e int) float64 {
 	if e < 0 {
-		return 1/Pow10(-e);
+		return 1/Pow10(-e)
 	}
 	if e < len(pow10tab) {
-		return pow10tab[e];
+		return pow10tab[e]
 	}
 	m := e/2;
 	return Pow10(m)*Pow10(e-m);
diff --git a/src/pkg/math/sin.go b/src/pkg/math/sin.go
index 740d6778bd..2c6f0079e5 100644
--- a/src/pkg/math/sin.go
+++ b/src/pkg/math/sin.go
@@ -37,10 +37,10 @@ func sinus(x float64, quad int) float64 {
 	}
 
 	if quad&1 != 0 {
-		y = 1-y;
+		y = 1-y
 	}
 	if quad > 1 {
-		y = -y;
+		y = -y
 	}
 
 	yy := y*y;
@@ -52,7 +52,7 @@ func sinus(x float64, quad int) float64 {
 // Cos returns the cosine of x.
 func Cos(x float64) float64 {
 	if x < 0 {
-		x = -x;
+		x = -x
 	}
 	return sinus(x, 1);
 }
diff --git a/src/pkg/math/sinh.go b/src/pkg/math/sinh.go
index 6974b59865..72775da8fc 100644
--- a/src/pkg/math/sinh.go
+++ b/src/pkg/math/sinh.go
@@ -39,10 +39,10 @@ func Sinh(x float64) float64 {
 	var temp float64;
 	switch true {
 	case x > 21:
-		temp = Exp(x)/2;
+		temp = Exp(x)/2
 
 	case x > 0.5:
-		temp = (Exp(x)-Exp(-x))/2;
+		temp = (Exp(x)-Exp(-x))/2
 
 	default:
 		sq := x*x;
@@ -51,7 +51,7 @@ func Sinh(x float64) float64 {
 	}
 
 	if sign {
-		temp = -temp;
+		temp = -temp
 	}
 	return temp;
 }
@@ -59,10 +59,10 @@ func Sinh(x float64) float64 {
 // Cosh returns the hyperbolic cosine of x.
 func Cosh(x float64) float64 {
 	if x < 0 {
-		x = -x;
+		x = -x
 	}
 	if x > 21 {
-		return Exp(x)/2;
+		return Exp(x)/2
 	}
 	return (Exp(x)+Exp(-x))/2;
 }
diff --git a/src/pkg/math/sqrt.go b/src/pkg/math/sqrt.go
index b7fd4ee604..7a5b69a423 100644
--- a/src/pkg/math/sqrt.go
+++ b/src/pkg/math/sqrt.go
@@ -20,12 +20,12 @@ package math
 //	Sqrt(x < 0) = NaN
 func Sqrt(x float64) float64 {
 	if IsInf(x, 1) {
-		return x;
+		return x
 	}
 
 	if x <= 0 {
 		if x < 0 {
-			return NaN();
+			return NaN()
 		}
 		return 0;
 	}
@@ -59,7 +59,7 @@ func Sqrt(x float64) float64 {
 	}
 
 	for i := 0; i <= 4; i++ {
-		temp = 0.5*(temp + x/temp);
+		temp = 0.5*(temp + x/temp)
 	}
 	return temp;
 }
diff --git a/src/pkg/math/tan.go b/src/pkg/math/tan.go
index 7287d80efe..cc57155d1b 100644
--- a/src/pkg/math/tan.go
+++ b/src/pkg/math/tan.go
@@ -54,12 +54,12 @@ func Tan(x float64) float64 {
 
 	if flag {
 		if temp == 0 {
-			panic(NaN());
+			panic(NaN())
 		}
 		temp = 1/temp;
 	}
 	if sign {
-		temp = -temp;
+		temp = -temp
 	}
 	return temp;
 }
diff --git a/src/pkg/math/tanh.go b/src/pkg/math/tanh.go
index dd403a4e05..e6d4da87ba 100644
--- a/src/pkg/math/tanh.go
+++ b/src/pkg/math/tanh.go
@@ -18,12 +18,12 @@ func Tanh(x float64) float64 {
 	if x < 0 {
 		x = -x;
 		if x > 21 {
-			return -1;
+			return -1
 		}
 		return -Sinh(x) / Cosh(x);
 	}
 	if x > 21 {
-		return 1;
+		return 1
 	}
 	return Sinh(x)/Cosh(x);
 }
diff --git a/src/pkg/net/dialgoogle_test.go b/src/pkg/net/dialgoogle_test.go
index 037684c796..8d8848b04f 100644
--- a/src/pkg/net/dialgoogle_test.go
+++ b/src/pkg/net/dialgoogle_test.go
@@ -58,13 +58,13 @@ var googleaddrs = []string{
 func TestDialGoogle(t *testing.T) {
 	// If no ipv6 tunnel, don't try the last address.
 	if !*ipv6 {
-		googleaddrs[len(googleaddrs)-1] = "";
+		googleaddrs[len(googleaddrs)-1] = ""
 	}
 
 	for i := 0; i < len(googleaddrs); i++ {
 		addr := googleaddrs[i];
 		if addr == "" {
-			continue;
+			continue
 		}
 		t.Logf("-- %s --", addr);
 		doDial(t, "tcp", addr);
diff --git a/src/pkg/net/dnsclient.go b/src/pkg/net/dnsclient.go
index 4a3b7dcc11..bea31c3ceb 100644
--- a/src/pkg/net/dnsclient.go
+++ b/src/pkg/net/dnsclient.go
@@ -29,7 +29,7 @@ type DNSError struct {
 func (e *DNSError) String() string {
 	s := "lookup " + e.Name;
 	if e.Server != "" {
-		s += " on " + e.Server;
+		s += " on " + e.Server
 	}
 	s += ": " + e.Error;
 	return s;
@@ -41,7 +41,7 @@ const noSuchHost = "no such host"
 // Up to cfg.attempts attempts.
 func _Exchange(cfg *_DNS_Config, c Conn, name string) (m *_DNS_Msg, err os.Error) {
 	if len(name) >= 256 {
-		return nil, &DNSError{"name too long", name, ""};
+		return nil, &DNSError{"name too long", name, ""}
 	}
 	out := new(_DNS_Msg);
 	out.id = 0x1234;
@@ -51,13 +51,13 @@ func _Exchange(cfg *_DNS_Config, c Conn, name string) (m *_DNS_Msg, err os.Error
 	out.recursion_desired = true;
 	msg, ok := out.Pack();
 	if !ok {
-		return nil, &DNSError{"internal error - cannot pack message", name, ""};
+		return nil, &DNSError{"internal error - cannot pack message", name, ""}
 	}
 
 	for attempt := 0; attempt < cfg.attempts; attempt++ {
 		n, err := c.Write(msg);
 		if err != nil {
-			return nil, err;
+			return nil, err
 		}
 
 		c.SetReadTimeout(1e9);	// nanoseconds
@@ -69,18 +69,18 @@ func _Exchange(cfg *_DNS_Config, c Conn, name string) (m *_DNS_Msg, err os.Error
 			continue;
 		}
 		if err != nil {
-			return nil, err;
+			return nil, err
 		}
 		buf = buf[0:n];
 		in := new(_DNS_Msg);
 		if !in.Unpack(buf) || in.id != out.id {
-			continue;
+			continue
 		}
 		return in, nil;
 	}
 	var server string;
 	if a := c.RemoteAddr(); a != nil {
-		server = a.String();
+		server = a.String()
 	}
 	return nil, &DNSError{"no answer from server", name, server};
 }
@@ -92,14 +92,14 @@ func answer(name, server string, dns *_DNS_Msg) (addrs []string, err *DNSError)
 	addrs = make([]string, 0, len(dns.answer));
 
 	if dns.rcode == _DNS_RcodeNameError && dns.recursion_available {
-		return nil, &DNSError{noSuchHost, name, ""};
+		return nil, &DNSError{noSuchHost, name, ""}
 	}
 	if dns.rcode != _DNS_RcodeSuccess {
 		// None of the error codes make sense
 		// for the query we sent.  If we didn't get
 		// a name error and we didn't get success,
 		// the server is behaving incorrectly.
-		return nil, &DNSError{"server misbehaving", name, server};
+		return nil, &DNSError{"server misbehaving", name, server}
 	}
 
 	// Look for the name.
@@ -128,7 +128,7 @@ Cname:
 			}
 		}
 		if len(addrs) == 0 {
-			return nil, &DNSError{noSuchHost, name, server};
+			return nil, &DNSError{noSuchHost, name, server}
 		}
 		return addrs, nil;
 	}
@@ -140,7 +140,7 @@ Cname:
 // (otherwise answer will not find the answers).
 func tryOneName(cfg *_DNS_Config, name string) (addrs []string, err os.Error) {
 	if len(cfg.servers) == 0 {
-		return nil, &DNSError{"no DNS servers", name, ""};
+		return nil, &DNSError{"no DNS servers", name, ""}
 	}
 	for i := 0; i < len(cfg.servers); i++ {
 		// Calling Dial here is scary -- we have to be sure
@@ -164,12 +164,12 @@ func tryOneName(cfg *_DNS_Config, name string) (addrs []string, err os.Error) {
 		var dnserr *DNSError;
 		addrs, dnserr = answer(name, server, msg);
 		if dnserr != nil {
-			err = dnserr;
+			err = dnserr
 		} else {
-			err = nil;	// nil os.Error, not nil *DNSError
+			err = nil	// nil os.Error, not nil *DNSError
 		}
 		if dnserr == nil || dnserr.Error == noSuchHost {
-			break;
+			break
 		}
 	}
 	return;
@@ -190,10 +190,10 @@ func isDomainName(s string) bool {
 	//	  but RFC 3696 says this has been relaxed to allow digits too.
 	//	  still, there must be a letter somewhere in the entire name.
 	if len(s) == 0 {
-		return false;
+		return false
 	}
 	if s[len(s)-1] != '.' {	// simplify checking loop: make name end in dot
-		s += ".";
+		s += "."
 	}
 
 	last := byte('.');
@@ -202,20 +202,20 @@ func isDomainName(s string) bool {
 		c := s[i];
 		switch {
 		default:
-			return false;
+			return false
 		case 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z':
-			ok = true;
+			ok = true
 		case '0' <= c && c <= '9':
 			// fine
 		case c == '-':
 			// byte before dash cannot be dot
 			if last == '.' {
-				return false;
+				return false
 			}
 		case c == '.':
 			// byte before dot cannot be dot, dash
 			if last == '.' || last == '-' {
-				return false;
+				return false
 			}
 		}
 		last = c;
@@ -229,7 +229,7 @@ func isDomainName(s string) bool {
 // host's addresses.
 func LookupHost(name string) (cname string, addrs []string, err os.Error) {
 	if !isDomainName(name) {
-		return name, nil, &DNSError{"invalid domain name", name, ""};
+		return name, nil, &DNSError{"invalid domain name", name, ""}
 	}
 	once.Do(loadConfig);
 	if dnserr != nil || cfg == nil {
@@ -243,7 +243,7 @@ func LookupHost(name string) (cname string, addrs []string, err os.Error) {
 	if rooted || count(name, '.') >= cfg.ndots {
 		rname := name;
 		if !rooted {
-			rname += ".";
+			rname += "."
 		}
 		// Can try as ordinary name.
 		addrs, err = tryOneName(cfg, rname);
@@ -253,14 +253,14 @@ func LookupHost(name string) (cname string, addrs []string, err os.Error) {
 		}
 	}
 	if rooted {
-		return;
+		return
 	}
 
 	// Otherwise, try suffixes.
 	for i := 0; i < len(cfg.search); i++ {
 		rname := name + "." + cfg.search[i];
 		if rname[len(rname)-1] != '.' {
-			rname += ".";
+			rname += "."
 		}
 		addrs, err = tryOneName(cfg, rname);
 		if err == nil {
diff --git a/src/pkg/net/dnsconfig.go b/src/pkg/net/dnsconfig.go
index b13b1b90a6..243a4b431a 100644
--- a/src/pkg/net/dnsconfig.go
+++ b/src/pkg/net/dnsconfig.go
@@ -26,7 +26,7 @@ var _DNS_configError os.Error
 func _DNS_ReadConfig() (*_DNS_Config, os.Error) {
 	file, err := open("/etc/resolv.conf");
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	conf := new(_DNS_Config);
 	conf.servers = make([]string, 3)[0:0];	// small, but the standard limit
@@ -38,7 +38,7 @@ func _DNS_ReadConfig() (*_DNS_Config, os.Error) {
 	for line, ok := file.readLine(); ok; line, ok = file.readLine() {
 		f := getFields(line);
 		if len(f) < 1 {
-			continue;
+			continue
 		}
 		switch f[0] {
 		case "nameserver":	// add one name server
@@ -61,13 +61,13 @@ func _DNS_ReadConfig() (*_DNS_Config, os.Error) {
 				conf.search = make([]string, 1);
 				conf.search[0] = f[1];
 			} else {
-				conf.search = make([]string, 0);
+				conf.search = make([]string, 0)
 			}
 
 		case "search":	// set search path to given servers
 			conf.search = make([]string, len(f)-1);
 			for i := 0; i < len(conf.search); i++ {
-				conf.search[i] = f[i+1];
+				conf.search[i] = f[i+1]
 			}
 
 		case "options":	// magic options
@@ -77,23 +77,23 @@ func _DNS_ReadConfig() (*_DNS_Config, os.Error) {
 				case len(s) >= 6 && s[0:6] == "ndots:":
 					n, _, _ := dtoi(s, 6);
 					if n < 1 {
-						n = 1;
+						n = 1
 					}
 					conf.ndots = n;
 				case len(s) >= 8 && s[0:8] == "timeout:":
 					n, _, _ := dtoi(s, 8);
 					if n < 1 {
-						n = 1;
+						n = 1
 					}
 					conf.timeout = n;
 				case len(s) >= 8 && s[0:9] == "attempts:":
 					n, _, _ := dtoi(s, 9);
 					if n < 1 {
-						n = 1;
+						n = 1
 					}
 					conf.attempts = n;
 				case s == "rotate":
-					conf.rotate = true;
+					conf.rotate = true
 				}
 			}
 		}
diff --git a/src/pkg/net/dnsmsg.go b/src/pkg/net/dnsmsg.go
index c7c27e3441..179c0f3542 100644
--- a/src/pkg/net/dnsmsg.go
+++ b/src/pkg/net/dnsmsg.go
@@ -108,7 +108,7 @@ type _DNS_RR_Header struct {
 }
 
 func (h *_DNS_RR_Header) Header() *_DNS_RR_Header {
-	return h;
+	return h
 }
 
 type _DNS_RR interface {
@@ -124,7 +124,7 @@ type _DNS_RR_CNAME struct {
 }
 
 func (rr *_DNS_RR_CNAME) Header() *_DNS_RR_Header {
-	return &rr.Hdr;
+	return &rr.Hdr
 }
 
 type _DNS_RR_HINFO struct {
@@ -134,7 +134,7 @@ type _DNS_RR_HINFO struct {
 }
 
 func (rr *_DNS_RR_HINFO) Header() *_DNS_RR_Header {
-	return &rr.Hdr;
+	return &rr.Hdr
 }
 
 type _DNS_RR_MB struct {
@@ -143,7 +143,7 @@ type _DNS_RR_MB struct {
 }
 
 func (rr *_DNS_RR_MB) Header() *_DNS_RR_Header {
-	return &rr.Hdr;
+	return &rr.Hdr
 }
 
 type _DNS_RR_MG struct {
@@ -152,7 +152,7 @@ type _DNS_RR_MG struct {
 }
 
 func (rr *_DNS_RR_MG) Header() *_DNS_RR_Header {
-	return &rr.Hdr;
+	return &rr.Hdr
 }
 
 type _DNS_RR_MINFO struct {
@@ -162,7 +162,7 @@ type _DNS_RR_MINFO struct {
 }
 
 func (rr *_DNS_RR_MINFO) Header() *_DNS_RR_Header {
-	return &rr.Hdr;
+	return &rr.Hdr
 }
 
 type _DNS_RR_MR struct {
@@ -171,7 +171,7 @@ type _DNS_RR_MR struct {
 }
 
 func (rr *_DNS_RR_MR) Header() *_DNS_RR_Header {
-	return &rr.Hdr;
+	return &rr.Hdr
 }
 
 type _DNS_RR_MX struct {
@@ -181,7 +181,7 @@ type _DNS_RR_MX struct {
 }
 
 func (rr *_DNS_RR_MX) Header() *_DNS_RR_Header {
-	return &rr.Hdr;
+	return &rr.Hdr
 }
 
 type _DNS_RR_NS struct {
@@ -190,7 +190,7 @@ type _DNS_RR_NS struct {
 }
 
 func (rr *_DNS_RR_NS) Header() *_DNS_RR_Header {
-	return &rr.Hdr;
+	return &rr.Hdr
 }
 
 type _DNS_RR_PTR struct {
@@ -199,7 +199,7 @@ type _DNS_RR_PTR struct {
 }
 
 func (rr *_DNS_RR_PTR) Header() *_DNS_RR_Header {
-	return &rr.Hdr;
+	return &rr.Hdr
 }
 
 type _DNS_RR_SOA struct {
@@ -214,7 +214,7 @@ type _DNS_RR_SOA struct {
 }
 
 func (rr *_DNS_RR_SOA) Header() *_DNS_RR_Header {
-	return &rr.Hdr;
+	return &rr.Hdr
 }
 
 type _DNS_RR_TXT struct {
@@ -223,7 +223,7 @@ type _DNS_RR_TXT struct {
 }
 
 func (rr *_DNS_RR_TXT) Header() *_DNS_RR_Header {
-	return &rr.Hdr;
+	return &rr.Hdr
 }
 
 type _DNS_RR_A struct {
@@ -264,7 +264,7 @@ var rr_mk = map[int]func() _DNS_RR{
 func packDomainName(s string, msg []byte, off int) (off1 int, ok bool) {
 	// Add trailing dot to canonicalize name.
 	if n := len(s); n == 0 || s[n-1] != '.' {
-		s += ".";
+		s += "."
 	}
 
 	// Each dot ends a segment of the name.
@@ -273,7 +273,7 @@ func packDomainName(s string, msg []byte, off int) (off1 int, ok bool) {
 	// Check that we have all the space we need.
 	tot := len(s)+1;
 	if off+tot > len(msg) {
-		return len(msg), false;
+		return len(msg), false
 	}
 
 	// Emit sequence of counted strings, chopping at dots.
@@ -281,7 +281,7 @@ func packDomainName(s string, msg []byte, off int) (off1 int, ok bool) {
 	for i := 0; i < len(s); i++ {
 		if s[i] == '.' {
 			if i-begin >= 1<<6 {	// top two bits of length must be clear
-				return len(msg), false;
+				return len(msg), false
 			}
 			msg[off] = byte(i-begin);
 			off++;
@@ -316,7 +316,7 @@ func unpackDomainName(msg []byte, off int) (s string, off1 int, ok bool) {
 Loop:
 	for {
 		if off >= len(msg) {
-			return "", len(msg), false;
+			return "", len(msg), false
 		}
 		c := int(msg[off]);
 		off++;
@@ -324,11 +324,11 @@ Loop:
 		case 0x00:
 			if c == 0x00 {
 				// end of name
-				break Loop;
+				break Loop
 			}
 			// literal string
 			if off+c > len(msg) {
-				return "", len(msg), false;
+				return "", len(msg), false
 			}
 			s += string(msg[off : off+c])+".";
 			off += c;
@@ -339,24 +339,24 @@ Loop:
 			// also, don't follow too many pointers --
 			// maybe there's a loop.
 			if off >= len(msg) {
-				return "", len(msg), false;
+				return "", len(msg), false
 			}
 			c1 := msg[off];
 			off++;
 			if ptr == 0 {
-				off1 = off;
+				off1 = off
 			}
 			if ptr++; ptr > 10 {
-				return "", len(msg), false;
+				return "", len(msg), false
 			}
 			off = (c^0xC0)<<8 | int(c1);
 		default:
 			// 0x80 and 0x40 are reserved
-			return "", len(msg), false;
+			return "", len(msg), false
 		}
 	}
 	if ptr == 0 {
-		off1 = off;
+		off1 = off
 	}
 	return s, off1, true;
 }
@@ -372,11 +372,11 @@ func packStructValue(val *reflect.StructValue, msg []byte, off int) (off1 int, o
 			fmt.Fprintf(os.Stderr, "net: dns: unknown packing type %v", f.Type);
 			return len(msg), false;
 		case *reflect.StructValue:
-			off, ok = packStructValue(fv, msg, off);
+			off, ok = packStructValue(fv, msg, off)
 		case *reflect.Uint16Value:
 			i := fv.Get();
 			if off+2 > len(msg) {
-				return len(msg), false;
+				return len(msg), false
 			}
 			msg[off] = byte(i>>8);
 			msg[off+1] = byte(i);
@@ -384,7 +384,7 @@ func packStructValue(val *reflect.StructValue, msg []byte, off int) (off1 int, o
 		case *reflect.Uint32Value:
 			i := fv.Get();
 			if off+4 > len(msg) {
-				return len(msg), false;
+				return len(msg), false
 			}
 			msg[off] = byte(i>>24);
 			msg[off+1] = byte(i>>16);
@@ -402,17 +402,17 @@ func packStructValue(val *reflect.StructValue, msg []byte, off int) (off1 int, o
 			case "domain-name":
 				off, ok = packDomainName(s, msg, off);
 				if !ok {
-					return len(msg), false;
+					return len(msg), false
 				}
 			case "":
 				// Counted string: 1 byte length.
 				if len(s) > 255 || off+1+len(s) > len(msg) {
-					return len(msg), false;
+					return len(msg), false
 				}
 				msg[off] = byte(len(s));
 				off++;
 				for i := 0; i < len(s); i++ {
-					msg[off+i] = s[i];
+					msg[off+i] = s[i]
 				}
 				off += len(s);
 			}
@@ -422,7 +422,7 @@ func packStructValue(val *reflect.StructValue, msg []byte, off int) (off1 int, o
 }
 
 func structValue(any interface{}) *reflect.StructValue {
-	return reflect.NewValue(any).(*reflect.PtrValue).Elem().(*reflect.StructValue);
+	return reflect.NewValue(any).(*reflect.PtrValue).Elem().(*reflect.StructValue)
 }
 
 func packStruct(any interface{}, msg []byte, off int) (off1 int, ok bool) {
@@ -441,17 +441,17 @@ func unpackStructValue(val *reflect.StructValue, msg []byte, off int) (off1 int,
 			fmt.Fprintf(os.Stderr, "net: dns: unknown packing type %v", f.Type);
 			return len(msg), false;
 		case *reflect.StructValue:
-			off, ok = unpackStructValue(fv, msg, off);
+			off, ok = unpackStructValue(fv, msg, off)
 		case *reflect.Uint16Value:
 			if off+2 > len(msg) {
-				return len(msg), false;
+				return len(msg), false
 			}
 			i := uint16(msg[off])<<8 | uint16(msg[off+1]);
 			fv.Set(i);
 			off += 2;
 		case *reflect.Uint32Value:
 			if off+4 > len(msg) {
-				return len(msg), false;
+				return len(msg), false
 			}
 			i := uint32(msg[off])<<24 | uint32(msg[off+1])<<16 | uint32(msg[off+2])<<8 | uint32(msg[off+3]);
 			fv.Set(i);
@@ -465,17 +465,17 @@ func unpackStructValue(val *reflect.StructValue, msg []byte, off int) (off1 int,
 			case "domain-name":
 				s, off, ok = unpackDomainName(msg, off);
 				if !ok {
-					return len(msg), false;
+					return len(msg), false
 				}
 			case "":
 				if off >= len(msg) || off+1+int(msg[off]) > len(msg) {
-					return len(msg), false;
+					return len(msg), false
 				}
 				n := int(msg[off]);
 				off++;
 				b := make([]byte, n);
 				for i := 0; i < n; i++ {
-					b[i] = msg[off+i];
+					b[i] = msg[off+i]
 				}
 				off += n;
 				s = string(b);
@@ -499,20 +499,20 @@ func printStructValue(val *reflect.StructValue) string {
 	s := "{";
 	for i := 0; i < val.NumField(); i++ {
 		if i > 0 {
-			s += ", ";
+			s += ", "
 		}
 		f := val.Type().(*reflect.StructType).Field(i);
 		if !f.Anonymous {
-			s += f.Name + "=";
+			s += f.Name + "="
 		}
 		fval := val.Field(i);
 		if fv, ok := fval.(*reflect.StructValue); ok {
-			s += printStructValue(fv);
+			s += printStructValue(fv)
 		} else if fv, ok := fval.(*reflect.Uint32Value); ok && f.Tag == "ipv4" {
 			i := fv.Get();
 			s += IPv4(byte(i>>24), byte(i>>16), byte(i>>8), byte(i)).String();
 		} else {
-			s += fmt.Sprint(fval.Interface());
+			s += fmt.Sprint(fval.Interface())
 		}
 	}
 	s += "}";
@@ -532,7 +532,7 @@ func packRR(rr _DNS_RR, msg []byte, off int) (off2 int, ok bool) {
 	off1, ok = packStruct(rr.Header(), msg, off);
 	off2, ok = packStruct(rr, msg, off);
 	if !ok {
-		return len(msg), false;
+		return len(msg), false
 	}
 	// pack a third time; redo header with correct data length
 	rr.Header().Rdlength = uint16(off2-off1);
@@ -546,7 +546,7 @@ func unpackRR(msg []byte, off int) (rr _DNS_RR, off1 int, ok bool) {
 	var h _DNS_RR_Header;
 	off0 := off;
 	if off, ok = unpackStruct(&h, msg, off); !ok {
-		return nil, len(msg), false;
+		return nil, len(msg), false
 	}
 	end := off+int(h.Rdlength);
 
@@ -554,12 +554,12 @@ func unpackRR(msg []byte, off int) (rr _DNS_RR, off1 int, ok bool) {
 	// again inefficient but doesn't need to be fast.
 	mk, known := rr_mk[int(h.Rrtype)];
 	if !known {
-		return &h, end, true;
+		return &h, end, true
 	}
 	rr = mk();
 	off, ok = unpackStruct(rr, msg, off0);
 	if off != end {
-		return &h, end, true;
+		return &h, end, true
 	}
 	return rr, off, ok;
 }
@@ -595,19 +595,19 @@ func (dns *_DNS_Msg) Pack() (msg []byte, ok bool) {
 	dh.Id = dns.id;
 	dh.Bits = uint16(dns.opcode)<<11 | uint16(dns.rcode);
 	if dns.recursion_available {
-		dh.Bits |= _RA;
+		dh.Bits |= _RA
 	}
 	if dns.recursion_desired {
-		dh.Bits |= _RD;
+		dh.Bits |= _RD
 	}
 	if dns.truncated {
-		dh.Bits |= _TC;
+		dh.Bits |= _TC
 	}
 	if dns.authoritative {
-		dh.Bits |= _AA;
+		dh.Bits |= _AA
 	}
 	if dns.response {
-		dh.Bits |= _QR;
+		dh.Bits |= _QR
 	}
 
 	// Prepare variable sized arrays.
@@ -630,19 +630,19 @@ func (dns *_DNS_Msg) Pack() (msg []byte, ok bool) {
 	off := 0;
 	off, ok = packStruct(&dh, msg, off);
 	for i := 0; i < len(question); i++ {
-		off, ok = packStruct(&question[i], msg, off);
+		off, ok = packStruct(&question[i], msg, off)
 	}
 	for i := 0; i < len(answer); i++ {
-		off, ok = packStruct(answer[i], msg, off);
+		off, ok = packStruct(answer[i], msg, off)
 	}
 	for i := 0; i < len(ns); i++ {
-		off, ok = packStruct(ns[i], msg, off);
+		off, ok = packStruct(ns[i], msg, off)
 	}
 	for i := 0; i < len(extra); i++ {
-		off, ok = packStruct(extra[i], msg, off);
+		off, ok = packStruct(extra[i], msg, off)
 	}
 	if !ok {
-		return nil, false;
+		return nil, false
 	}
 	return msg[0:off], true;
 }
@@ -653,7 +653,7 @@ func (dns *_DNS_Msg) Unpack(msg []byte) bool {
 	off := 0;
 	var ok bool;
 	if off, ok = unpackStruct(&dh, msg, off); !ok {
-		return false;
+		return false
 	}
 	dns.id = dh.Id;
 	dns.response = (dh.Bits & _QR) != 0;
@@ -671,19 +671,19 @@ func (dns *_DNS_Msg) Unpack(msg []byte) bool {
 	dns.extra = make([]_DNS_RR, dh.Arcount);
 
 	for i := 0; i < len(dns.question); i++ {
-		off, ok = unpackStruct(&dns.question[i], msg, off);
+		off, ok = unpackStruct(&dns.question[i], msg, off)
 	}
 	for i := 0; i < len(dns.answer); i++ {
-		dns.answer[i], off, ok = unpackRR(msg, off);
+		dns.answer[i], off, ok = unpackRR(msg, off)
 	}
 	for i := 0; i < len(dns.ns); i++ {
-		dns.ns[i], off, ok = unpackRR(msg, off);
+		dns.ns[i], off, ok = unpackRR(msg, off)
 	}
 	for i := 0; i < len(dns.extra); i++ {
-		dns.extra[i], off, ok = unpackRR(msg, off);
+		dns.extra[i], off, ok = unpackRR(msg, off)
 	}
 	if !ok {
-		return false;
+		return false
 	}
 	//	if off != len(msg) {
 	//		println("extra bytes in dns packet", off, "<", len(msg));
@@ -696,25 +696,25 @@ func (dns *_DNS_Msg) String() string {
 	if len(dns.question) > 0 {
 		s += "-- Questions\n";
 		for i := 0; i < len(dns.question); i++ {
-			s += printStruct(&dns.question[i]) + "\n";
+			s += printStruct(&dns.question[i]) + "\n"
 		}
 	}
 	if len(dns.answer) > 0 {
 		s += "-- Answers\n";
 		for i := 0; i < len(dns.answer); i++ {
-			s += printStruct(dns.answer[i]) + "\n";
+			s += printStruct(dns.answer[i]) + "\n"
 		}
 	}
 	if len(dns.ns) > 0 {
 		s += "-- Name servers\n";
 		for i := 0; i < len(dns.ns); i++ {
-			s += printStruct(dns.ns[i]) + "\n";
+			s += printStruct(dns.ns[i]) + "\n"
 		}
 	}
 	if len(dns.extra) > 0 {
 		s += "-- Extra\n";
 		for i := 0; i < len(dns.extra); i++ {
-			s += printStruct(dns.extra[i]) + "\n";
+			s += printStruct(dns.extra[i]) + "\n"
 		}
 	}
 	return s;
diff --git a/src/pkg/net/fd.go b/src/pkg/net/fd.go
index bcb7372125..0f4c30a4b4 100644
--- a/src/pkg/net/fd.go
+++ b/src/pkg/net/fd.go
@@ -80,7 +80,7 @@ func newPollServer() (s *pollServer, err os.Error) {
 	s.cr = make(chan *netFD, 1);
 	s.cw = make(chan *netFD, 1);
 	if s.pr, s.pw, err = os.Pipe(); err != nil {
-		return nil, err;
+		return nil, err
 	}
 	var e int;
 	if e = syscall.SetNonblock(s.pr.Fd(), true); e != 0 {
@@ -92,10 +92,10 @@ func newPollServer() (s *pollServer, err os.Error) {
 		return nil, err;
 	}
 	if e = syscall.SetNonblock(s.pw.Fd(), true); e != 0 {
-		goto Errno;
+		goto Errno
 	}
 	if s.poll, err = newpollster(); err != nil {
-		goto Error;
+		goto Error
 	}
 	if err = s.poll.AddFD(s.pr.Fd(), 'r', true); err != nil {
 		s.poll.Close();
@@ -122,9 +122,9 @@ func (s *pollServer) AddFD(fd *netFD, mode int) {
 	if intfd < 0 {
 		// fd closed underfoot
 		if mode == 'r' {
-			fd.cr <- fd;
+			fd.cr <- fd
 		} else {
-			fd.cw <- fd;
+			fd.cw <- fd
 		}
 		return;
 	}
@@ -145,18 +145,18 @@ func (s *pollServer) AddFD(fd *netFD, mode int) {
 	}
 	s.pending[key] = fd;
 	if t > 0 && (s.deadline == 0 || t < s.deadline) {
-		s.deadline = t;
+		s.deadline = t
 	}
 }
 
 func (s *pollServer) LookupFD(fd int, mode int) *netFD {
 	key := fd<<1;
 	if mode == 'w' {
-		key++;
+		key++
 	}
 	netfd, ok := s.pending[key];
 	if !ok {
-		return nil;
+		return nil
 	}
 	s.pending[key] = nil, false;
 	return netfd;
@@ -179,7 +179,7 @@ func (s *pollServer) WakeFD(fd *netFD, mode int) {
 func (s *pollServer) Now() int64 {
 	sec, nsec, err := os.Time();
 	if err != nil {
-		panic("net: os.Time: ", err.String());
+		panic("net: os.Time: ", err.String())
 	}
 	nsec += sec*1e9;
 	return nsec;
@@ -195,14 +195,14 @@ func (s *pollServer) CheckDeadlines() {
 		var t int64;
 		var mode int;
 		if key&1 == 0 {
-			mode = 'r';
+			mode = 'r'
 		} else {
-			mode = 'w';
+			mode = 'w'
 		}
 		if mode == 'r' {
-			t = fd.rdeadline;
+			t = fd.rdeadline
 		} else {
-			t = fd.wdeadline;
+			t = fd.wdeadline
 		}
 		if t > 0 {
 			if t <= now {
@@ -216,7 +216,7 @@ func (s *pollServer) CheckDeadlines() {
 				}
 				s.WakeFD(fd, mode);
 			} else if next_deadline == 0 || t < next_deadline {
-				next_deadline = t;
+				next_deadline = t
 			}
 		}
 	}
@@ -247,15 +247,15 @@ func (s *pollServer) Run() {
 		if fd == s.pr.Fd() {
 			// Drain our wakeup pipe.
 			for nn, _ := s.pr.Read(&scratch); nn > 0; {
-				nn, _ = s.pr.Read(&scratch);
+				nn, _ = s.pr.Read(&scratch)
 			}
 
 			// Read from channels
 			for fd, ok := <-s.cr; ok; fd, ok = <-s.cr {
-				s.AddFD(fd, 'r');
+				s.AddFD(fd, 'r')
 			}
 			for fd, ok := <-s.cw; ok; fd, ok = <-s.cw {
-				s.AddFD(fd, 'w');
+				s.AddFD(fd, 'w')
 			}
 		} else {
 			netfd := s.LookupFD(fd, mode);
@@ -293,7 +293,7 @@ var pollserver *pollServer
 func startServer() {
 	p, err := newPollServer();
 	if err != nil {
-		print("Start pollServer: ", err.String(), "\n");
+		print("Start pollServer: ", err.String(), "\n")
 	}
 	pollserver = p;
 }
@@ -301,7 +301,7 @@ func startServer() {
 func newFD(fd, family, proto int, net string, laddr, raddr Addr) (f *netFD, err os.Error) {
 	once.Do(startServer);
 	if e := syscall.SetNonblock(fd, true); e != 0 {
-		return nil, &OpError{"setnonblock", net, laddr, os.Errno(e)};
+		return nil, &OpError{"setnonblock", net, laddr, os.Errno(e)}
 	}
 	f = &netFD{
 		fd: fd,
@@ -313,10 +313,10 @@ func newFD(fd, family, proto int, net string, laddr, raddr Addr) (f *netFD, err
 	};
 	var ls, rs string;
 	if laddr != nil {
-		ls = laddr.String();
+		ls = laddr.String()
 	}
 	if raddr != nil {
-		rs = raddr.String();
+		rs = raddr.String()
 	}
 	f.file = os.NewFile(fd, net+":"+ls+"->"+rs);
 	f.cr = make(chan *netFD, 1);
@@ -326,14 +326,14 @@ func newFD(fd, family, proto int, net string, laddr, raddr Addr) (f *netFD, err
 
 func isEAGAIN(e os.Error) bool {
 	if e1, ok := e.(*os.PathError); ok {
-		return e1.Error == os.EAGAIN;
+		return e1.Error == os.EAGAIN
 	}
 	return e == os.EAGAIN;
 }
 
 func (fd *netFD) Close() os.Error {
 	if fd == nil || fd.file == nil {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 
 	// In case the user has set linger,
@@ -352,14 +352,14 @@ func (fd *netFD) Close() os.Error {
 
 func (fd *netFD) Read(p []byte) (n int, err os.Error) {
 	if fd == nil || fd.file == nil {
-		return 0, os.EINVAL;
+		return 0, os.EINVAL
 	}
 	fd.rio.Lock();
 	defer fd.rio.Unlock();
 	if fd.rdeadline_delta > 0 {
-		fd.rdeadline = pollserver.Now() + fd.rdeadline_delta;
+		fd.rdeadline = pollserver.Now() + fd.rdeadline_delta
 	} else {
-		fd.rdeadline = 0;
+		fd.rdeadline = 0
 	}
 	for {
 		n, err = fd.file.Read(p);
@@ -374,31 +374,31 @@ func (fd *netFD) Read(p []byte) (n int, err os.Error) {
 
 func (fd *netFD) Write(p []byte) (n int, err os.Error) {
 	if fd == nil || fd.file == nil {
-		return 0, os.EINVAL;
+		return 0, os.EINVAL
 	}
 	fd.wio.Lock();
 	defer fd.wio.Unlock();
 	if fd.wdeadline_delta > 0 {
-		fd.wdeadline = pollserver.Now() + fd.wdeadline_delta;
+		fd.wdeadline = pollserver.Now() + fd.wdeadline_delta
 	} else {
-		fd.wdeadline = 0;
+		fd.wdeadline = 0
 	}
 	err = nil;
 	nn := 0;
 	for nn < len(p) {
 		n, err = fd.file.Write(p[nn:len(p)]);
 		if n > 0 {
-			nn += n;
+			nn += n
 		}
 		if nn == len(p) {
-			break;
+			break
 		}
 		if isEAGAIN(err) && fd.wdeadline >= 0 {
 			pollserver.WaitWrite(fd);
 			continue;
 		}
 		if n == 0 || err != nil {
-			break;
+			break
 		}
 	}
 	return nn, err;
@@ -406,7 +406,7 @@ func (fd *netFD) Write(p []byte) (n int, err os.Error) {
 
 func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (nfd *netFD, err os.Error) {
 	if fd == nil || fd.file == nil {
-		return nil, os.EINVAL;
+		return nil, os.EINVAL
 	}
 
 	// See ../syscall/exec.go for description of ForkLock.
@@ -418,7 +418,7 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (nfd *netFD, err os.
 	for {
 		s, sa, e = syscall.Accept(fd.fd);
 		if e != syscall.EAGAIN {
-			break;
+			break
 		}
 		syscall.ForkLock.RUnlock();
 		pollserver.WaitRead(fd);
diff --git a/src/pkg/net/fd_darwin.go b/src/pkg/net/fd_darwin.go
index 45acad6995..36cb513a9a 100644
--- a/src/pkg/net/fd_darwin.go
+++ b/src/pkg/net/fd_darwin.go
@@ -21,7 +21,7 @@ func newpollster() (p *pollster, err os.Error) {
 	p = new(pollster);
 	var e int;
 	if p.kq, e = syscall.Kqueue(); e != 0 {
-		return nil, os.NewSyscallError("kqueue", e);
+		return nil, os.NewSyscallError("kqueue", e)
 	}
 	p.events = p.eventbuf[0:0];
 	return p, nil;
@@ -30,9 +30,9 @@ func newpollster() (p *pollster, err os.Error) {
 func (p *pollster) AddFD(fd int, mode int, repeat bool) os.Error {
 	var kmode int;
 	if mode == 'r' {
-		kmode = syscall.EVFILT_READ;
+		kmode = syscall.EVFILT_READ
 	} else {
-		kmode = syscall.EVFILT_WRITE;
+		kmode = syscall.EVFILT_WRITE
 	}
 	var events [1]syscall.Kevent_t;
 	ev := &events[0];
@@ -42,19 +42,19 @@ func (p *pollster) AddFD(fd int, mode int, repeat bool) os.Error {
 	// EV_ONESHOT - delete the event the first time it triggers
 	flags := syscall.EV_ADD | syscall.EV_RECEIPT;
 	if !repeat {
-		flags |= syscall.EV_ONESHOT;
+		flags |= syscall.EV_ONESHOT
 	}
 	syscall.SetKevent(ev, fd, kmode, flags);
 
 	n, e := syscall.Kevent(p.kq, &events, &events, nil);
 	if e != 0 {
-		return os.NewSyscallError("kevent", e);
+		return os.NewSyscallError("kevent", e)
 	}
 	if n != 1 || (ev.Flags & syscall.EV_ERROR) == 0 || int(ev.Ident) != fd || int(ev.Filter) != kmode {
-		return os.ErrorString("kqueue phase error");
+		return os.ErrorString("kqueue phase error")
 	}
 	if ev.Data != 0 {
-		return os.Errno(int(ev.Data));
+		return os.Errno(int(ev.Data))
 	}
 	return nil;
 }
@@ -62,9 +62,9 @@ func (p *pollster) AddFD(fd int, mode int, repeat bool) os.Error {
 func (p *pollster) DelFD(fd int, mode int) {
 	var kmode int;
 	if mode == 'r' {
-		kmode = syscall.EVFILT_READ;
+		kmode = syscall.EVFILT_READ
 	} else {
-		kmode = syscall.EVFILT_WRITE;
+		kmode = syscall.EVFILT_WRITE
 	}
 	var events [1]syscall.Kevent_t;
 	ev := &events[0];
@@ -80,19 +80,19 @@ func (p *pollster) WaitFD(nsec int64) (fd int, mode int, err os.Error) {
 	for len(p.events) == 0 {
 		if nsec > 0 {
 			if t == nil {
-				t = new(syscall.Timespec);
+				t = new(syscall.Timespec)
 			}
 			*t = syscall.NsecToTimespec(nsec);
 		}
 		nn, e := syscall.Kevent(p.kq, nil, &p.eventbuf, t);
 		if e != 0 {
 			if e == syscall.EINTR {
-				continue;
+				continue
 			}
 			return -1, 0, os.NewSyscallError("kevent", e);
 		}
 		if nn == 0 {
-			return -1, 0, nil;
+			return -1, 0, nil
 		}
 		p.events = p.eventbuf[0:nn];
 	}
@@ -100,9 +100,9 @@ func (p *pollster) WaitFD(nsec int64) (fd int, mode int, err os.Error) {
 	p.events = p.events[1:len(p.events)];
 	fd = int(ev.Ident);
 	if ev.Filter == syscall.EVFILT_READ {
-		mode = 'r';
+		mode = 'r'
 	} else {
-		mode = 'w';
+		mode = 'w'
 	}
 	return fd, mode, nil;
 }
diff --git a/src/pkg/net/fd_linux.go b/src/pkg/net/fd_linux.go
index 47ae4f1c38..ddde33ee41 100644
--- a/src/pkg/net/fd_linux.go
+++ b/src/pkg/net/fd_linux.go
@@ -31,7 +31,7 @@ func newpollster() (p *pollster, err os.Error) {
 	// about the number of FDs we will care about.
 	// We don't know.
 	if p.epfd, e = syscall.EpollCreate(16); e != 0 {
-		return nil, os.NewSyscallError("epoll_create", e);
+		return nil, os.NewSyscallError("epoll_create", e)
 	}
 	p.events = make(map[int]uint32);
 	return p, nil;
@@ -43,22 +43,22 @@ func (p *pollster) AddFD(fd int, mode int, repeat bool) os.Error {
 	ev.Fd = int32(fd);
 	ev.Events, already = p.events[fd];
 	if !repeat {
-		ev.Events |= syscall.EPOLLONESHOT;
+		ev.Events |= syscall.EPOLLONESHOT
 	}
 	if mode == 'r' {
-		ev.Events |= readFlags;
+		ev.Events |= readFlags
 	} else {
-		ev.Events |= writeFlags;
+		ev.Events |= writeFlags
 	}
 
 	var op int;
 	if already {
-		op = syscall.EPOLL_CTL_MOD;
+		op = syscall.EPOLL_CTL_MOD
 	} else {
-		op = syscall.EPOLL_CTL_ADD;
+		op = syscall.EPOLL_CTL_ADD
 	}
 	if e := syscall.EpollCtl(p.epfd, op, fd, &ev); e != 0 {
-		return os.NewSyscallError("epoll_ctl", e);
+		return os.NewSyscallError("epoll_ctl", e)
 	}
 	p.events[fd] = ev.Events;
 	return nil;
@@ -74,7 +74,7 @@ func (p *pollster) StopWaiting(fd int, bits uint) {
 	// If syscall.EPOLLONESHOT is not set, the wait
 	// is a repeating wait, so don't change it.
 	if events & syscall.EPOLLONESHOT == 0 {
-		return;
+		return
 	}
 
 	// Disable the given bits.
@@ -86,12 +86,12 @@ func (p *pollster) StopWaiting(fd int, bits uint) {
 		ev.Fd = int32(fd);
 		ev.Events = events;
 		if e := syscall.EpollCtl(p.epfd, syscall.EPOLL_CTL_MOD, fd, &ev); e != 0 {
-			print("Epoll modify fd=", fd, ": ", os.Errno(e).String(), "\n");
+			print("Epoll modify fd=", fd, ": ", os.Errno(e).String(), "\n")
 		}
 		p.events[fd] = events;
 	} else {
 		if e := syscall.EpollCtl(p.epfd, syscall.EPOLL_CTL_DEL, fd, nil); e != 0 {
-			print("Epoll delete fd=", fd, ": ", os.Errno(e).String(), "\n");
+			print("Epoll delete fd=", fd, ": ", os.Errno(e).String(), "\n")
 		}
 		p.events[fd] = 0, false;
 	}
@@ -99,9 +99,9 @@ func (p *pollster) StopWaiting(fd int, bits uint) {
 
 func (p *pollster) DelFD(fd int, mode int) {
 	if mode == 'r' {
-		p.StopWaiting(fd, readFlags);
+		p.StopWaiting(fd, readFlags)
 	} else {
-		p.StopWaiting(fd, writeFlags);
+		p.StopWaiting(fd, writeFlags)
 	}
 }
 
@@ -111,17 +111,17 @@ func (p *pollster) WaitFD(nsec int64) (fd int, mode int, err os.Error) {
 	ev := &evarray[0];
 	var msec int = -1;
 	if nsec > 0 {
-		msec = int((nsec+1e6-1)/1e6);
+		msec = int((nsec+1e6-1)/1e6)
 	}
 	n, e := syscall.EpollWait(p.epfd, &evarray, msec);
 	for e == syscall.EAGAIN || e == syscall.EINTR {
-		n, e = syscall.EpollWait(p.epfd, &evarray, msec);
+		n, e = syscall.EpollWait(p.epfd, &evarray, msec)
 	}
 	if e != 0 {
-		return -1, 0, os.NewSyscallError("epoll_wait", e);
+		return -1, 0, os.NewSyscallError("epoll_wait", e)
 	}
 	if n == 0 {
-		return -1, 0, nil;
+		return -1, 0, nil
 	}
 	fd = int(ev.Fd);
 
@@ -145,5 +145,5 @@ func (p *pollster) WaitFD(nsec int64) (fd int, mode int, err os.Error) {
 }
 
 func (p *pollster) Close() os.Error {
-	return os.NewSyscallError("close", syscall.Close(p.epfd));
+	return os.NewSyscallError("close", syscall.Close(p.epfd))
 }
diff --git a/src/pkg/net/fd_nacl.go b/src/pkg/net/fd_nacl.go
index 3167964867..22700fbedb 100644
--- a/src/pkg/net/fd_nacl.go
+++ b/src/pkg/net/fd_nacl.go
@@ -12,7 +12,7 @@ import (
 type pollster struct{}
 
 func newpollster() (p *pollster, err os.Error) {
-	return nil, os.NewSyscallError("networking", syscall.ENACL);
+	return nil, os.NewSyscallError("networking", syscall.ENACL)
 }
 
 func (p *pollster) AddFD(fd int, mode int, repeat bool) os.Error {
diff --git a/src/pkg/net/ip.go b/src/pkg/net/ip.go
index 3178db0215..5d2a1fc859 100644
--- a/src/pkg/net/ip.go
+++ b/src/pkg/net/ip.go
@@ -40,7 +40,7 @@ type IPMask []byte
 func IPv4(a, b, c, d byte) IP {
 	p := make(IP, IPv6len);
 	for i := 0; i < 10; i++ {
-		p[i] = 0;
+		p[i] = 0
 	}
 	p[10] = 0xff;
 	p[11] = 0xff;
@@ -68,7 +68,7 @@ var (
 func isZeros(p IP) bool {
 	for i := 0; i < len(p); i++ {
 		if p[i] != 0 {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -78,13 +78,13 @@ func isZeros(p IP) bool {
 // If ip is not an IPv4 address, To4 returns nil.
 func (ip IP) To4() IP {
 	if len(ip) == IPv4len {
-		return ip;
+		return ip
 	}
 	if len(ip) == IPv6len &&
 		isZeros(ip[0:10]) &&
 		ip[10] == 0xff &&
 		ip[11] == 0xff {
-		return ip[12:16];
+		return ip[12:16]
 	}
 	return nil;
 }
@@ -93,10 +93,10 @@ func (ip IP) To4() IP {
 // If ip is not an IP address (it is the wrong length), To16 returns nil.
 func (ip IP) To16() IP {
 	if len(ip) == IPv4len {
-		return IPv4(ip[0], ip[1], ip[2], ip[3]);
+		return IPv4(ip[0], ip[1], ip[2], ip[3])
 	}
 	if len(ip) == IPv6len {
-		return ip;
+		return ip
 	}
 	return nil;
 }
@@ -113,15 +113,15 @@ var (
 // nil if ip is not a valid IPv4 address.
 func (ip IP) DefaultMask() IPMask {
 	if ip = ip.To4(); ip == nil {
-		return nil;
+		return nil
 	}
 	switch true {
 	case ip[0] < 0x80:
-		return classAMask;
+		return classAMask
 	case ip[0] < 0xC0:
-		return classBMask;
+		return classBMask
 	default:
-		return classCMask;
+		return classCMask
 	}
 	return nil;	// not reached
 }
@@ -130,11 +130,11 @@ func (ip IP) DefaultMask() IPMask {
 func (ip IP) Mask(mask IPMask) IP {
 	n := len(ip);
 	if n != len(mask) {
-		return nil;
+		return nil
 	}
 	out := make(IP, n);
 	for i := 0; i < n; i++ {
-		out[i] = ip[i]&mask[i];
+		out[i] = ip[i]&mask[i]
 	}
 	return out;
 }
@@ -142,7 +142,7 @@ func (ip IP) Mask(mask IPMask) IP {
 // Convert i to decimal string.
 func itod(i uint) string {
 	if i == 0 {
-		return "0";
+		return "0"
 	}
 
 	// Assemble decimal in reverse order.
@@ -159,7 +159,7 @@ func itod(i uint) string {
 // Convert i to hexadecimal string.
 func itox(i uint) string {
 	if i == 0 {
-		return "0";
+		return "0"
 	}
 
 	// Assemble hexadecimal in reverse order.
@@ -181,7 +181,7 @@ func (ip IP) String() string {
 	p := ip;
 
 	if len(ip) == 0 {
-		return "";
+		return ""
 	}
 
 	// If IPv4, use dotted notation.
@@ -189,10 +189,10 @@ func (ip IP) String() string {
 		return itod(uint(p4[0])) + "." +
 			itod(uint(p4[1])) + "." +
 			itod(uint(p4[2])) + "." +
-			itod(uint(p4[3]));
+			itod(uint(p4[3]))
 	}
 	if len(p) != IPv6len {
-		return "?";
+		return "?"
 	}
 
 	// Find longest run of zeros.
@@ -201,7 +201,7 @@ func (ip IP) String() string {
 	for i := 0; i < 16; i += 2 {
 		j := i;
 		for j < 16 && p[j] == 0 && p[j+1] == 0 {
-			j += 2;
+			j += 2
 		}
 		if j > i && j-i > e1-e0 {
 			e0 = i;
@@ -216,10 +216,10 @@ func (ip IP) String() string {
 			s += "::";
 			i = e1;
 			if i >= 16 {
-				break;
+				break
 			}
 		} else if i > 0 {
-			s += ":";
+			s += ":"
 		}
 		s += itox((uint(p[i])<<8)|uint(p[i+1]));
 	}
@@ -232,7 +232,7 @@ func simpleMaskLength(mask IPMask) int {
 	var i int;
 	for i = 0; i < len(mask); i++ {
 		if mask[i] != 0xFF {
-			break;
+			break
 		}
 	}
 	n := 8*i;
@@ -242,11 +242,11 @@ func simpleMaskLength(mask IPMask) int {
 		v <<= 1;
 	}
 	if v != 0 {
-		return -1;
+		return -1
 	}
 	for i++; i < len(mask); i++ {
 		if mask[i] != 0 {
-			return -1;
+			return -1
 		}
 	}
 	return n;
@@ -262,12 +262,12 @@ func (mask IPMask) String() string {
 	case 4:
 		n := simpleMaskLength(mask);
 		if n >= 0 {
-			return itod(uint(n + (IPv6len-IPv4len)*8));
+			return itod(uint(n + (IPv6len-IPv4len)*8))
 		}
 	case 16:
 		n := simpleMaskLength(mask);
 		if n >= 0 {
-			return itod(uint(n));
+			return itod(uint(n))
 		}
 	}
 	return IP(mask).String();
@@ -280,7 +280,7 @@ func parseIPv4(s string) IP {
 	for j := 0; j < IPv4len; j++ {
 		if j > 0 {
 			if s[i] != '.' {
-				return nil;
+				return nil
 			}
 			i++;
 		}
@@ -290,12 +290,12 @@ func parseIPv4(s string) IP {
 		)
 		n, i, ok = dtoi(s, i);
 		if !ok || n > 0xFF {
-			return nil;
+			return nil
 		}
 		p[j] = byte(n);
 	}
 	if i != len(s) {
-		return nil;
+		return nil
 	}
 	return IPv4(p[0], p[1], p[2], p[3]);
 }
@@ -319,7 +319,7 @@ func parseIPv6(s string) IP {
 		i = 2;
 		// Might be only ellipsis
 		if i == len(s) {
-			return p;
+			return p
 		}
 	}
 
@@ -329,22 +329,22 @@ L:	for j < IPv6len {
 		// Hex number.
 		n, i1, ok := xtoi(s, i);
 		if !ok || n > 0xFFFF {
-			return nil;
+			return nil
 		}
 
 		// If followed by dot, might be in trailing IPv4.
 		if i1 < len(s) && s[i1] == '.' {
 			if ellipsis < 0 && j != IPv6len-IPv4len {
 				// Not the right place.
-				return nil;
+				return nil
 			}
 			if j+IPv4len > IPv6len {
 				// Not enough room.
-				return nil;
+				return nil
 			}
 			p4 := parseIPv4(s[i:len(s)]);
 			if p4 == nil {
-				return nil;
+				return nil
 			}
 			p[j] = p4[12];
 			p[j+1] = p4[13];
@@ -363,43 +363,43 @@ L:	for j < IPv6len {
 		// Stop at end of string.
 		i = i1;
 		if i == len(s) {
-			break;
+			break
 		}
 
 		// Otherwise must be followed by colon and more.
 		if s[i] != ':' && i+1 == len(s) {
-			return nil;
+			return nil
 		}
 		i++;
 
 		// Look for ellipsis.
 		if s[i] == ':' {
 			if ellipsis >= 0 {	// already have one
-				return nil;
+				return nil
 			}
 			ellipsis = j;
 			if i++; i == len(s) {	// can be at end
-				break;
+				break
 			}
 		}
 	}
 
 	// Must have used entire string.
 	if i != len(s) {
-		return nil;
+		return nil
 	}
 
 	// If didn't parse enough, expand ellipsis.
 	if j < IPv6len {
 		if ellipsis < 0 {
-			return nil;
+			return nil
 		}
 		n := IPv6len-j;
 		for k := j-1; k >= ellipsis; k-- {
-			p[k+n] = p[k];
+			p[k+n] = p[k]
 		}
 		for k := ellipsis+n-1; k >= ellipsis; k-- {
-			p[k] = 0;
+			p[k] = 0
 		}
 	}
 	return p;
@@ -413,7 +413,7 @@ L:	for j < IPv6len {
 func ParseIP(s string) IP {
 	p := parseIPv4(s);
 	if p != nil {
-		return p;
+		return p
 	}
 	return parseIPv6(s);
 }
diff --git a/src/pkg/net/ip_test.go b/src/pkg/net/ip_test.go
index d23eaff3ac..7cca831b59 100644
--- a/src/pkg/net/ip_test.go
+++ b/src/pkg/net/ip_test.go
@@ -10,14 +10,14 @@ import (
 
 func isEqual(a, b IP) bool {
 	if a == nil && b == nil {
-		return true;
+		return true
 	}
 	if a == nil || b == nil || len(a) != len(b) {
-		return false;
+		return false
 	}
 	for i := 0; i < len(a); i++ {
 		if a[i] != b[i] {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -46,7 +46,7 @@ func TestParseIP(t *testing.T) {
 	for i := 0; i < len(parseiptests); i++ {
 		tt := parseiptests[i];
 		if out := ParseIP(tt.in); !isEqual(out, tt.out) {
-			t.Errorf("ParseIP(%#q) = %v, want %v", tt.in, out, tt.out);
+			t.Errorf("ParseIP(%#q) = %v, want %v", tt.in, out, tt.out)
 		}
 	}
 }
diff --git a/src/pkg/net/ipsock.go b/src/pkg/net/ipsock.go
index fd37155a2c..fc0db9b4ad 100644
--- a/src/pkg/net/ipsock.go
+++ b/src/pkg/net/ipsock.go
@@ -20,7 +20,7 @@ import (
 func kernelSupportsIPv6() bool {
 	fd, e := syscall.Socket(syscall.AF_INET6, syscall.SOCK_STREAM, syscall.IPPROTO_TCP);
 	if fd >= 0 {
-		syscall.Close(fd);
+		syscall.Close(fd)
 	}
 	return e == 0;
 }
@@ -48,7 +48,7 @@ func internetSocket(net string, laddr, raddr sockaddr, proto int, mode string, t
 	family := syscall.AF_INET6;
 	switch net[len(net)-1] {
 	case '4':
-		family = syscall.AF_INET;
+		family = syscall.AF_INET
 	case '6':
 		// nothing to do
 	default:
@@ -57,31 +57,31 @@ func internetSocket(net string, laddr, raddr sockaddr, proto int, mode string, t
 		if preferIPv4 &&
 			(laddr == nil || laddr.family() == syscall.AF_INET) &&
 			(raddr == nil || raddr.family() == syscall.AF_INET) {
-			family = syscall.AF_INET;
+			family = syscall.AF_INET
 		}
 	}
 
 	var la, ra syscall.Sockaddr;
 	if laddr != nil {
 		if la, err = laddr.sockaddr(family); err != nil {
-			goto Error;
+			goto Error
 		}
 	}
 	if raddr != nil {
 		if ra, err = raddr.sockaddr(family); err != nil {
-			goto Error;
+			goto Error
 		}
 	}
 	fd, err = socket(net, family, proto, 0, la, ra, toAddr);
 	if err != nil {
-		goto Error;
+		goto Error
 	}
 	return fd, nil;
 
 Error:
 	addr := raddr;
 	if mode == "listen" {
-		addr = laddr;
+		addr = laddr
 	}
 	return nil, &OpError{mode, net, addr, err};
 }
@@ -92,15 +92,15 @@ func getip(fd int, remote bool) (ip []byte, port int, ok bool) {
 	// caller won't report them anyway.
 	var sa syscall.Sockaddr;
 	if remote {
-		sa, _ = syscall.Getpeername(fd);
+		sa, _ = syscall.Getpeername(fd)
 	} else {
-		sa, _ = syscall.Getsockname(fd);
+		sa, _ = syscall.Getsockname(fd)
 	}
 	switch sa := sa.(type) {
 	case *syscall.SockaddrInet4:
-		return &sa.Addr, sa.Port, true;
+		return &sa.Addr, sa.Port, true
 	case *syscall.SockaddrInet6:
-		return &sa.Addr, sa.Port, true;
+		return &sa.Addr, sa.Port, true
 	}
 	return;
 }
@@ -109,33 +109,33 @@ func ipToSockaddr(family int, ip IP, port int) (syscall.Sockaddr, os.Error) {
 	switch family {
 	case syscall.AF_INET:
 		if len(ip) == 0 {
-			ip = IPv4zero;
+			ip = IPv4zero
 		}
 		if ip = ip.To4(); ip == nil {
-			return nil, os.EINVAL;
+			return nil, os.EINVAL
 		}
 		s := new(syscall.SockaddrInet4);
 		for i := 0; i < IPv4len; i++ {
-			s.Addr[i] = ip[i];
+			s.Addr[i] = ip[i]
 		}
 		s.Port = port;
 		return s, nil;
 	case syscall.AF_INET6:
 		if len(ip) == 0 {
-			ip = IPzero;
+			ip = IPzero
 		}
 		// IPv4 callers use 0.0.0.0 to mean "announce on any available address".
 		// In IPv6 mode, Linux treats that as meaning "announce on 0.0.0.0",
 		// which it refuses to do.  Rewrite to the IPv6 all zeros.
 		if p4 := ip.To4(); p4 != nil && p4[0] == 0 && p4[1] == 0 && p4[2] == 0 && p4[3] == 0 {
-			ip = IPzero;
+			ip = IPzero
 		}
 		if ip = ip.To16(); ip == nil {
-			return nil, os.EINVAL;
+			return nil, os.EINVAL
 		}
 		s := new(syscall.SockaddrInet6);
 		for i := 0; i < IPv6len; i++ {
-			s.Addr[i] = ip[i];
+			s.Addr[i] = ip[i]
 		}
 		s.Port = port;
 		return s, nil;
@@ -157,7 +157,7 @@ func splitHostPort(hostport string) (host, port string, err os.Error) {
 
 	// Can put brackets around host ...
 	if len(host) > 0 && host[0] == '[' && host[len(host)-1] == ']' {
-		host = host[1 : len(host)-1];
+		host = host[1 : len(host)-1]
 	} else {
 		// ... but if there are no brackets, no colons.
 		if byteIndex(host, ':') >= 0 {
@@ -173,7 +173,7 @@ func splitHostPort(hostport string) (host, port string, err os.Error) {
 func joinHostPort(host, port string) string {
 	// If host has colons, have to bracket it.
 	if byteIndex(host, ':') >= 0 {
-		return "["+host+"]:"+port;
+		return "["+host+"]:"+port
 	}
 	return host+":"+port;
 }
@@ -182,7 +182,7 @@ func joinHostPort(host, port string) string {
 func hostPortToIP(net, hostport string) (ip IP, iport int, err os.Error) {
 	host, port, err := splitHostPort(hostport);
 	if err != nil {
-		goto Error;
+		goto Error
 	}
 
 	var addr IP;
@@ -209,7 +209,7 @@ func hostPortToIP(net, hostport string) (ip IP, iport int, err os.Error) {
 	if !ok || i != len(port) {
 		p, err = LookupPort(net, port);
 		if err != nil {
-			goto Error;
+			goto Error
 		}
 	}
 	if p < 0 || p > 0xFFFF {
diff --git a/src/pkg/net/net.go b/src/pkg/net/net.go
index cc5e27ea04..6f75261d3d 100644
--- a/src/pkg/net/net.go
+++ b/src/pkg/net/net.go
@@ -126,12 +126,12 @@ func Dial(net, laddr, raddr string) (c Conn, err os.Error) {
 		var la, ra *TCPAddr;
 		if laddr != "" {
 			if la, err = ResolveTCPAddr(laddr); err != nil {
-				goto Error;
+				goto Error
 			}
 		}
 		if raddr != "" {
 			if ra, err = ResolveTCPAddr(raddr); err != nil {
-				goto Error;
+				goto Error
 			}
 		}
 		return DialTCP(net, la, ra);
@@ -139,12 +139,12 @@ func Dial(net, laddr, raddr string) (c Conn, err os.Error) {
 		var la, ra *UDPAddr;
 		if laddr != "" {
 			if la, err = ResolveUDPAddr(laddr); err != nil {
-				goto Error;
+				goto Error
 			}
 		}
 		if raddr != "" {
 			if ra, err = ResolveUDPAddr(raddr); err != nil {
-				goto Error;
+				goto Error
 			}
 		}
 		return DialUDP(net, la, ra);
@@ -152,12 +152,12 @@ func Dial(net, laddr, raddr string) (c Conn, err os.Error) {
 		var la, ra *UnixAddr;
 		if raddr != "" {
 			if ra, err = ResolveUnixAddr(net, raddr); err != nil {
-				goto Error;
+				goto Error
 			}
 		}
 		if laddr != "" {
 			if la, err = ResolveUnixAddr(net, laddr); err != nil {
-				goto Error;
+				goto Error
 			}
 		}
 		return DialUnix(net, la, ra);
@@ -176,24 +176,24 @@ func Listen(net, laddr string) (l Listener, err os.Error) {
 		var la *TCPAddr;
 		if laddr != "" {
 			if la, err = ResolveTCPAddr(laddr); err != nil {
-				return nil, err;
+				return nil, err
 			}
 		}
 		l, err := ListenTCP(net, la);
 		if err != nil {
-			return nil, err;
+			return nil, err
 		}
 		return l, nil;
 	case "unix":
 		var la *UnixAddr;
 		if laddr != "" {
 			if la, err = ResolveUnixAddr(net, laddr); err != nil {
-				return nil, err;
+				return nil, err
 			}
 		}
 		l, err := ListenUnix(net, la);
 		if err != nil {
-			return nil, err;
+			return nil, err
 		}
 		return l, nil;
 	}
@@ -209,24 +209,24 @@ func ListenPacket(net, laddr string) (c PacketConn, err os.Error) {
 		var la *UDPAddr;
 		if laddr != "" {
 			if la, err = ResolveUDPAddr(laddr); err != nil {
-				return nil, err;
+				return nil, err
 			}
 		}
 		c, err := ListenUDP(net, la);
 		if err != nil {
-			return nil, err;
+			return nil, err
 		}
 		return c, nil;
 	case "unixgram":
 		var la *UnixAddr;
 		if laddr != "" {
 			if la, err = ResolveUnixAddr(net, laddr); err != nil {
-				return nil, err;
+				return nil, err
 			}
 		}
 		c, err := DialUnix(net, la, nil);
 		if err != nil {
-			return nil, err;
+			return nil, err
 		}
 		return c, nil;
 	}
@@ -245,10 +245,10 @@ type OpError struct {
 func (e *OpError) String() string {
 	s := e.Op;
 	if e.Net != "" {
-		s += " " + e.Net;
+		s += " " + e.Net
 	}
 	if e.Addr != nil {
-		s += " " + e.Addr.String();
+		s += " " + e.Addr.String()
 	}
 	s += ": " + e.Error.String();
 	return s;
@@ -262,7 +262,7 @@ type AddrError struct {
 func (e *AddrError) String() string {
 	s := e.Error;
 	if e.Addr != "" {
-		s += " " + e.Addr;
+		s += " " + e.Addr
 	}
 	return s;
 }
diff --git a/src/pkg/net/net_test.go b/src/pkg/net/net_test.go
index 70577ecbc7..532a62b985 100644
--- a/src/pkg/net/net_test.go
+++ b/src/pkg/net/net_test.go
@@ -55,7 +55,7 @@ func TestDialError(t *testing.T) {
 	for i, tt := range dialErrorTests {
 		c, e := Dial(tt.Net, tt.Laddr, tt.Raddr);
 		if c != nil {
-			c.Close();
+			c.Close()
 		}
 		if e == nil {
 			t.Errorf("#%d: nil error, want match for %#q", i, tt.Pattern);
@@ -64,7 +64,7 @@ func TestDialError(t *testing.T) {
 		s := e.String();
 		match, _ := regexp.MatchString(tt.Pattern, s);
 		if !match {
-			t.Errorf("#%d: %q, want match for %#q", i, s, tt.Pattern);
+			t.Errorf("#%d: %q, want match for %#q", i, s, tt.Pattern)
 		}
 	}
 }
diff --git a/src/pkg/net/parse.go b/src/pkg/net/parse.go
index 9ed3f2dbda..aa5bbf39d6 100644
--- a/src/pkg/net/parse.go
+++ b/src/pkg/net/parse.go
@@ -29,7 +29,7 @@ func (f *file) getLineFromData() (s string, ok bool) {
 			i++;
 			n := len(data)-i;
 			for j := 0; j < n; j++ {
-				data[j] = data[i+j];
+				data[j] = data[i+j]
 			}
 			f.data = data[0:n];
 			return;
@@ -40,13 +40,13 @@ func (f *file) getLineFromData() (s string, ok bool) {
 
 func (f *file) readLine() (s string, ok bool) {
 	if s, ok = f.getLineFromData(); ok {
-		return;
+		return
 	}
 	if len(f.data) < cap(f.data) {
 		ln := len(f.data);
 		n, _ := io.ReadFull(f.file, f.data[ln:cap(f.data)]);
 		if n >= 0 {
-			f.data = f.data[0 : ln+n];
+			f.data = f.data[0 : ln+n]
 		}
 	}
 	s, ok = f.getLineFromData();
@@ -56,7 +56,7 @@ func (f *file) readLine() (s string, ok bool) {
 func open(name string) (*file, os.Error) {
 	fd, err := os.Open(name, os.O_RDONLY, 0);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	return &file{fd, make([]byte, 1024)[0:0]}, nil;
 }
@@ -64,7 +64,7 @@ func open(name string) (*file, os.Error) {
 func byteIndex(s string, c byte) int {
 	for i := 0; i < len(s); i++ {
 		if s[i] == c {
-			return i;
+			return i
 		}
 	}
 	return -1;
@@ -75,7 +75,7 @@ func countAnyByte(s string, t string) int {
 	n := 0;
 	for i := 0; i < len(s); i++ {
 		if byteIndex(t, s[i]) >= 0 {
-			n++;
+			n++
 		}
 	}
 	return n;
@@ -114,11 +114,11 @@ func dtoi(s string, i0 int) (n int, i int, ok bool) {
 	for i = i0; i < len(s) && '0' <= s[i] && s[i] <= '9'; i++ {
 		n = n*10 + int(s[i]-'0');
 		if n >= big {
-			return 0, i, false;
+			return 0, i, false
 		}
 	}
 	if i == i0 {
-		return 0, i, false;
+		return 0, i, false
 	}
 	return n, i, true;
 }
@@ -138,14 +138,14 @@ func xtoi(s string, i0 int) (n int, i int, ok bool) {
 			n *= 16;
 			n += int(s[i]-'A')+10;
 		} else {
-			break;
+			break
 		}
 		if n >= big {
-			return 0, i, false;
+			return 0, i, false
 		}
 	}
 	if i == i0 {
-		return 0, i, false;
+		return 0, i, false
 	}
 	return n, i, true;
 }
@@ -177,7 +177,7 @@ func count(s string, b byte) int {
 	n := 0;
 	for i := 0; i < len(s); i++ {
 		if s[i] == b {
-			n++;
+			n++
 		}
 	}
 	return n;
@@ -188,7 +188,7 @@ func last(s string, b byte) int {
 	i := len(s);
 	for i--; i >= 0; i-- {
 		if s[i] == b {
-			break;
+			break
 		}
 	}
 	return i;
diff --git a/src/pkg/net/parse_test.go b/src/pkg/net/parse_test.go
index e187ee76c5..ae94a88c48 100644
--- a/src/pkg/net/parse_test.go
+++ b/src/pkg/net/parse_test.go
@@ -15,14 +15,14 @@ func TestReadLine(t *testing.T) {
 
 	fd, err := os.Open(filename, os.O_RDONLY, 0);
 	if err != nil {
-		t.Fatalf("open %s: %v", filename, err);
+		t.Fatalf("open %s: %v", filename, err)
 	}
 	br := bufio.NewReader(fd);
 
 	var file *file;
 	file, err = open(filename);
 	if file == nil {
-		t.Fatalf("net.open(%s) = nil", filename);
+		t.Fatalf("net.open(%s) = nil", filename)
 	}
 
 	lineno := 1;
@@ -30,15 +30,15 @@ func TestReadLine(t *testing.T) {
 	for {
 		bline, berr := br.ReadString('\n');
 		if n := len(bline); n > 0 {
-			bline = bline[0 : n-1];
+			bline = bline[0 : n-1]
 		}
 		line, ok := file.readLine();
 		if (berr != nil) != !ok || bline != line {
 			t.Fatalf("%s:%d (#%d)\nbufio => %q, %v\nnet => %q, %v",
-				filename, lineno, byteno, bline, berr, line, ok);
+				filename, lineno, byteno, bline, berr, line, ok)
 		}
 		if !ok {
-			break;
+			break
 		}
 		lineno++;
 		byteno += len(line)+1;
diff --git a/src/pkg/net/port.go b/src/pkg/net/port.go
index 32879d90f9..d43a7347d6 100644
--- a/src/pkg/net/port.go
+++ b/src/pkg/net/port.go
@@ -21,16 +21,16 @@ func readServices() {
 	for line, ok := file.readLine(); ok; line, ok = file.readLine() {
 		// "http 80/tcp www www-http # World Wide Web HTTP"
 		if i := byteIndex(line, '#'); i >= 0 {
-			line = line[0:i];
+			line = line[0:i]
 		}
 		f := getFields(line);
 		if len(f) < 2 {
-			continue;
+			continue
 		}
 		portnet := f[1];	// "tcp/80"
 		port, j, ok := dtoi(portnet, 0);
 		if !ok || port <= 0 || j >= len(portnet) || portnet[j] != '/' {
-			continue;
+			continue
 		}
 		netw := portnet[j+1 : len(portnet)];	// "tcp"
 		m, ok1 := services[netw];
@@ -40,7 +40,7 @@ func readServices() {
 		}
 		for i := 0; i < len(f); i++ {
 			if i != 1 {	// f[1] was port/net
-				m[f[i]] = port;
+				m[f[i]] = port
 			}
 		}
 	}
@@ -53,14 +53,14 @@ func LookupPort(network, service string) (port int, err os.Error) {
 
 	switch network {
 	case "tcp4", "tcp6":
-		network = "tcp";
+		network = "tcp"
 	case "udp4", "udp6":
-		network = "udp";
+		network = "udp"
 	}
 
 	if m, ok := services[network]; ok {
 		if port, ok = m[service]; ok {
-			return;
+			return
 		}
 	}
 	return 0, &AddrError{"unknown port", network+"/"+service};
diff --git a/src/pkg/net/port_test.go b/src/pkg/net/port_test.go
index 0d0f4fe48e..9a58d3731e 100644
--- a/src/pkg/net/port_test.go
+++ b/src/pkg/net/port_test.go
@@ -52,7 +52,7 @@ func TestLookupPort(t *testing.T) {
 		tt := porttests[i];
 		if port, err := LookupPort(tt.netw, tt.name); port != tt.port || (err == nil) != tt.ok {
 			t.Errorf("LookupPort(%q, %q) = %v, %s; want %v",
-				tt.netw, tt.name, port, err, tt.port);
+				tt.netw, tt.name, port, err, tt.port)
 		}
 	}
 }
diff --git a/src/pkg/net/server_test.go b/src/pkg/net/server_test.go
index 6a7c479f35..21ee92891d 100644
--- a/src/pkg/net/server_test.go
+++ b/src/pkg/net/server_test.go
@@ -18,7 +18,7 @@ func runEcho(fd io.ReadWriter, done chan<- int) {
 	for {
 		n, err := fd.Read(&buf);
 		if err != nil || n == 0 {
-			break;
+			break
 		}
 		fd.Write(buf[0:n]);
 	}
@@ -28,14 +28,14 @@ func runEcho(fd io.ReadWriter, done chan<- int) {
 func runServe(t *testing.T, network, addr string, listening chan<- string, done chan<- int) {
 	l, err := Listen(network, addr);
 	if err != nil {
-		t.Fatalf("net.Listen(%q, %q) = _, %v", network, addr, err);
+		t.Fatalf("net.Listen(%q, %q) = _, %v", network, addr, err)
 	}
 	listening <- l.Addr().String();
 
 	for {
 		fd, err := l.Accept();
 		if err != nil {
-			break;
+			break
 		}
 		echodone := make(chan int);
 		go runEcho(fd, echodone);
@@ -48,11 +48,11 @@ func runServe(t *testing.T, network, addr string, listening chan<- string, done
 func connect(t *testing.T, network, addr string) {
 	var laddr string;
 	if network == "unixgram" {
-		laddr = addr+".local";
+		laddr = addr+".local"
 	}
 	fd, err := Dial(network, laddr, addr);
 	if err != nil {
-		t.Fatalf("net.Dial(%q, %q, %q) = _, %v", network, laddr, addr, err);
+		t.Fatalf("net.Dial(%q, %q, %q) = _, %v", network, laddr, addr, err)
 	}
 
 	b := strings.Bytes("hello, world\n");
@@ -60,12 +60,12 @@ func connect(t *testing.T, network, addr string) {
 
 	n, errno := fd.Write(b);
 	if n != len(b) {
-		t.Fatalf("fd.Write(%q) = %d, %v", b, n, errno);
+		t.Fatalf("fd.Write(%q) = %d, %v", b, n, errno)
 	}
 
 	n, errno = fd.Read(&b1);
 	if n != len(b) {
-		t.Fatalf("fd.Read() = %d, %v", n, errno);
+		t.Fatalf("fd.Read() = %d, %v", n, errno)
 	}
 	fd.Close();
 }
@@ -75,12 +75,12 @@ func doTest(t *testing.T, network, listenaddr, dialaddr string) {
 	listening := make(chan string);
 	done := make(chan int);
 	if network == "tcp" {
-		listenaddr += ":0";	// any available port
+		listenaddr += ":0"	// any available port
 	}
 	go runServe(t, network, listenaddr, listening, done);
 	addr := <-listening;	// wait for server to start
 	if network == "tcp" {
-		dialaddr += addr[strings.LastIndex(addr, ":") : len(addr)];
+		dialaddr += addr[strings.LastIndex(addr, ":") : len(addr)]
 	}
 	connect(t, network, dialaddr);
 	<-done;	// make sure server stopped
@@ -100,14 +100,14 @@ func TestUnixServer(t *testing.T) {
 	os.Remove("/tmp/gotest.net");
 	if syscall.OS == "linux" {
 		// Test abstract unix domain socket, a Linux-ism
-		doTest(t, "unix", "@gotest/net", "@gotest/net");
+		doTest(t, "unix", "@gotest/net", "@gotest/net")
 	}
 }
 
 func runPacket(t *testing.T, network, addr string, listening chan<- string, done chan<- int) {
 	c, err := ListenPacket(network, addr);
 	if err != nil {
-		t.Fatalf("net.ListenPacket(%q, %q) = _, %v", network, addr, err);
+		t.Fatalf("net.ListenPacket(%q, %q) = _, %v", network, addr, err)
 	}
 	listening <- c.LocalAddr().String();
 	c.SetReadTimeout(10e6);	// 10ms
@@ -116,15 +116,15 @@ func runPacket(t *testing.T, network, addr string, listening chan<- string, done
 		n, addr, err := c.ReadFrom(&buf);
 		if err == os.EAGAIN {
 			if done <- 1 {
-				break;
+				break
 			}
 			continue;
 		}
 		if err != nil {
-			break;
+			break
 		}
 		if _, err = c.WriteTo(buf[0:n], addr); err != nil {
-			t.Fatalf("WriteTo %v: %v", addr, err);
+			t.Fatalf("WriteTo %v: %v", addr, err)
 		}
 	}
 	c.Close();
@@ -136,12 +136,12 @@ func doTestPacket(t *testing.T, network, listenaddr, dialaddr string) {
 	listening := make(chan string);
 	done := make(chan int);
 	if network == "udp" {
-		listenaddr += ":0";	// any available port
+		listenaddr += ":0"	// any available port
 	}
 	go runPacket(t, network, listenaddr, listening, done);
 	addr := <-listening;	// wait for server to start
 	if network == "udp" {
-		dialaddr += addr[strings.LastIndex(addr, ":") : len(addr)];
+		dialaddr += addr[strings.LastIndex(addr, ":") : len(addr)]
 	}
 	connect(t, network, dialaddr);
 	<-done;	// tell server to stop
@@ -164,6 +164,6 @@ func TestUnixDatagramServer(t *testing.T) {
 	os.Remove("/tmp/gotest1.net.local");
 	if syscall.OS == "linux" {
 		// Test abstract unix domain socket, a Linux-ism
-		doTestPacket(t, "unixgram", "@gotest1/net", "@gotest1/net");
+		doTestPacket(t, "unixgram", "@gotest1/net", "@gotest1/net")
 	}
 }
diff --git a/src/pkg/net/sock.go b/src/pkg/net/sock.go
index a078f4c44f..c670aa21e7 100644
--- a/src/pkg/net/sock.go
+++ b/src/pkg/net/sock.go
@@ -15,7 +15,7 @@ import (
 // Boolean to int.
 func boolint(b bool) int {
 	if b {
-		return 1;
+		return 1
 	}
 	return 0;
 }
@@ -66,7 +66,7 @@ func socket(net string, f, p, t int, la, ra syscall.Sockaddr, toAddr func(syscal
 }
 
 func setsockoptInt(fd, level, opt int, value int) os.Error {
-	return os.NewSyscallError("setsockopt", syscall.SetsockoptInt(fd, level, opt, value));
+	return os.NewSyscallError("setsockopt", syscall.SetsockoptInt(fd, level, opt, value))
 }
 
 func setsockoptNsec(fd, level, opt int, nsec int64) os.Error {
@@ -75,11 +75,11 @@ func setsockoptNsec(fd, level, opt int, nsec int64) os.Error {
 }
 
 func setReadBuffer(fd *netFD, bytes int) os.Error {
-	return setsockoptInt(fd.fd, syscall.SOL_SOCKET, syscall.SO_RCVBUF, bytes);
+	return setsockoptInt(fd.fd, syscall.SOL_SOCKET, syscall.SO_RCVBUF, bytes)
 }
 
 func setWriteBuffer(fd *netFD, bytes int) os.Error {
-	return setsockoptInt(fd.fd, syscall.SOL_SOCKET, syscall.SO_SNDBUF, bytes);
+	return setsockoptInt(fd.fd, syscall.SOL_SOCKET, syscall.SO_SNDBUF, bytes)
 }
 
 func setReadTimeout(fd *netFD, nsec int64) os.Error {
@@ -94,26 +94,26 @@ func setWriteTimeout(fd *netFD, nsec int64) os.Error {
 
 func setTimeout(fd *netFD, nsec int64) os.Error {
 	if e := setReadTimeout(fd, nsec); e != nil {
-		return e;
+		return e
 	}
 	return setWriteTimeout(fd, nsec);
 }
 
 func setReuseAddr(fd *netFD, reuse bool) os.Error {
-	return setsockoptInt(fd.fd, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, boolint(reuse));
+	return setsockoptInt(fd.fd, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, boolint(reuse))
 }
 
 func bindToDevice(fd *netFD, dev string) os.Error {
 	// TODO(rsc): call setsockopt with null-terminated string pointer
-	return os.EINVAL;
+	return os.EINVAL
 }
 
 func setDontRoute(fd *netFD, dontroute bool) os.Error {
-	return setsockoptInt(fd.fd, syscall.SOL_SOCKET, syscall.SO_DONTROUTE, boolint(dontroute));
+	return setsockoptInt(fd.fd, syscall.SOL_SOCKET, syscall.SO_DONTROUTE, boolint(dontroute))
 }
 
 func setKeepAlive(fd *netFD, keepalive bool) os.Error {
-	return setsockoptInt(fd.fd, syscall.SOL_SOCKET, syscall.SO_KEEPALIVE, boolint(keepalive));
+	return setsockoptInt(fd.fd, syscall.SOL_SOCKET, syscall.SO_KEEPALIVE, boolint(keepalive))
 }
 
 func setLinger(fd *netFD, sec int) os.Error {
@@ -134,17 +134,17 @@ type UnknownSocketError struct {
 }
 
 func (e *UnknownSocketError) String() string {
-	return "unknown socket address type " + reflect.Typeof(e.sa).String();
+	return "unknown socket address type " + reflect.Typeof(e.sa).String()
 }
 
 func sockaddrToString(sa syscall.Sockaddr) (name string, err os.Error) {
 	switch a := sa.(type) {
 	case *syscall.SockaddrInet4:
-		return joinHostPort(IP(&a.Addr).String(), itoa(a.Port)), nil;
+		return joinHostPort(IP(&a.Addr).String(), itoa(a.Port)), nil
 	case *syscall.SockaddrInet6:
-		return joinHostPort(IP(&a.Addr).String(), itoa(a.Port)), nil;
+		return joinHostPort(IP(&a.Addr).String(), itoa(a.Port)), nil
 	case *syscall.SockaddrUnix:
-		return a.Name, nil;
+		return a.Name, nil
 	}
 
 	return "", &UnknownSocketError{sa};
diff --git a/src/pkg/net/tcpsock.go b/src/pkg/net/tcpsock.go
index a49a73d1b0..2633196266 100644
--- a/src/pkg/net/tcpsock.go
+++ b/src/pkg/net/tcpsock.go
@@ -14,9 +14,9 @@ import (
 func sockaddrToTCP(sa syscall.Sockaddr) Addr {
 	switch sa := sa.(type) {
 	case *syscall.SockaddrInet4:
-		return &TCPAddr{&sa.Addr, sa.Port};
+		return &TCPAddr{&sa.Addr, sa.Port}
 	case *syscall.SockaddrInet6:
-		return &TCPAddr{&sa.Addr, sa.Port};
+		return &TCPAddr{&sa.Addr, sa.Port}
 	}
 	return nil;
 }
@@ -34,21 +34,21 @@ func (a *TCPAddr) String() string	{ return joinHostPort(a.IP.String(), itoa(a.Po
 
 func (a *TCPAddr) family() int {
 	if a == nil || len(a.IP) <= 4 {
-		return syscall.AF_INET;
+		return syscall.AF_INET
 	}
 	if ip := a.IP.To4(); ip != nil {
-		return syscall.AF_INET;
+		return syscall.AF_INET
 	}
 	return syscall.AF_INET6;
 }
 
 func (a *TCPAddr) sockaddr(family int) (syscall.Sockaddr, os.Error) {
-	return ipToSockaddr(family, a.IP, a.Port);
+	return ipToSockaddr(family, a.IP, a.Port)
 }
 
 func (a *TCPAddr) toAddr() sockaddr {
 	if a == nil {	// nil *TCPAddr
-		return nil;	// nil interface
+		return nil	// nil interface
 	}
 	return a;
 }
@@ -60,7 +60,7 @@ func (a *TCPAddr) toAddr() sockaddr {
 func ResolveTCPAddr(addr string) (*TCPAddr, os.Error) {
 	ip, port, err := hostPortToIP("tcp", addr);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	return &TCPAddr{ip, port}, nil;
 }
@@ -87,7 +87,7 @@ func (c *TCPConn) ok() bool	{ return c != nil && c.fd != nil }
 // after a fixed time limit; see SetTimeout and SetReadTimeout.
 func (c *TCPConn) Read(b []byte) (n int, err os.Error) {
 	if !c.ok() {
-		return 0, os.EINVAL;
+		return 0, os.EINVAL
 	}
 	return c.fd.Read(b);
 }
@@ -98,7 +98,7 @@ func (c *TCPConn) Read(b []byte) (n int, err os.Error) {
 // after a fixed time limit; see SetTimeout and SetReadTimeout.
 func (c *TCPConn) Write(b []byte) (n int, err os.Error) {
 	if !c.ok() {
-		return 0, os.EINVAL;
+		return 0, os.EINVAL
 	}
 	return c.fd.Write(b);
 }
@@ -106,7 +106,7 @@ func (c *TCPConn) Write(b []byte) (n int, err os.Error) {
 // Close closes the TCP connection.
 func (c *TCPConn) Close() os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	err := c.fd.Close();
 	c.fd = nil;
@@ -116,7 +116,7 @@ func (c *TCPConn) Close() os.Error {
 // LocalAddr returns the local network address, a *TCPAddr.
 func (c *TCPConn) LocalAddr() Addr {
 	if !c.ok() {
-		return nil;
+		return nil
 	}
 	return c.fd.laddr;
 }
@@ -124,7 +124,7 @@ func (c *TCPConn) LocalAddr() Addr {
 // RemoteAddr returns the remote network address, a *TCPAddr.
 func (c *TCPConn) RemoteAddr() Addr {
 	if !c.ok() {
-		return nil;
+		return nil
 	}
 	return c.fd.raddr;
 }
@@ -133,7 +133,7 @@ func (c *TCPConn) RemoteAddr() Addr {
 // with the connection.
 func (c *TCPConn) SetTimeout(nsec int64) os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return setTimeout(c.fd, nsec);
 }
@@ -143,7 +143,7 @@ func (c *TCPConn) SetTimeout(nsec int64) os.Error {
 // Setting nsec == 0 (the default) disables the deadline.
 func (c *TCPConn) SetReadTimeout(nsec int64) os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return setReadTimeout(c.fd, nsec);
 }
@@ -155,7 +155,7 @@ func (c *TCPConn) SetReadTimeout(nsec int64) os.Error {
 // some of the data was successfully written.
 func (c *TCPConn) SetWriteTimeout(nsec int64) os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return setWriteTimeout(c.fd, nsec);
 }
@@ -164,7 +164,7 @@ func (c *TCPConn) SetWriteTimeout(nsec int64) os.Error {
 // receive buffer associated with the connection.
 func (c *TCPConn) SetReadBuffer(bytes int) os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return setReadBuffer(c.fd, bytes);
 }
@@ -173,7 +173,7 @@ func (c *TCPConn) SetReadBuffer(bytes int) os.Error {
 // transmit buffer associated with the connection.
 func (c *TCPConn) SetWriteBuffer(bytes int) os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return setWriteBuffer(c.fd, bytes);
 }
@@ -191,7 +191,7 @@ func (c *TCPConn) SetWriteBuffer(bytes int) os.Error {
 // data to be sent and acknowledged.
 func (c *TCPConn) SetLinger(sec int) os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return setLinger(c.fd, sec);
 }
@@ -200,7 +200,7 @@ func (c *TCPConn) SetLinger(sec int) os.Error {
 // keepalive messages on the connection.
 func (c *TCPConn) SetKeepAlive(keepalive bool) os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return setKeepAlive(c.fd, keepalive);
 }
@@ -209,11 +209,11 @@ func (c *TCPConn) SetKeepAlive(keepalive bool) os.Error {
 // and returns a TCPConn structure.
 func DialTCP(net string, laddr, raddr *TCPAddr) (c *TCPConn, err os.Error) {
 	if raddr == nil {
-		return nil, &OpError{"dial", "tcp", nil, errMissingAddress};
+		return nil, &OpError{"dial", "tcp", nil, errMissingAddress}
 	}
 	fd, e := internetSocket(net, laddr.toAddr(), raddr.toAddr(), syscall.SOCK_STREAM, "dial", sockaddrToTCP);
 	if e != nil {
-		return nil, e;
+		return nil, e
 	}
 	return newTCPConn(fd), nil;
 }
@@ -232,7 +232,7 @@ type TCPListener struct {
 func ListenTCP(net string, laddr *TCPAddr) (l *TCPListener, err os.Error) {
 	fd, err := internetSocket(net, laddr.toAddr(), nil, syscall.SOCK_STREAM, "listen", sockaddrToTCP);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	errno := syscall.Listen(fd.fd, listenBacklog());
 	if errno != 0 {
@@ -248,11 +248,11 @@ func ListenTCP(net string, laddr *TCPAddr) (l *TCPListener, err os.Error) {
 // and the remote address.
 func (l *TCPListener) AcceptTCP() (c *TCPConn, err os.Error) {
 	if l == nil || l.fd == nil || l.fd.fd < 0 {
-		return nil, os.EINVAL;
+		return nil, os.EINVAL
 	}
 	fd, err := l.fd.accept(sockaddrToTCP);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	return newTCPConn(fd), nil;
 }
@@ -262,7 +262,7 @@ func (l *TCPListener) AcceptTCP() (c *TCPConn, err os.Error) {
 func (l *TCPListener) Accept() (c Conn, err os.Error) {
 	c1, err := l.AcceptTCP();
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	return c1, nil;
 }
@@ -271,7 +271,7 @@ func (l *TCPListener) Accept() (c Conn, err os.Error) {
 // Already Accepted connections are not closed.
 func (l *TCPListener) Close() os.Error {
 	if l == nil || l.fd == nil {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return l.fd.Close();
 }
diff --git a/src/pkg/net/timeout_test.go b/src/pkg/net/timeout_test.go
index acac3c75db..57bfa090c0 100644
--- a/src/pkg/net/timeout_test.go
+++ b/src/pkg/net/timeout_test.go
@@ -13,7 +13,7 @@ func testTimeout(t *testing.T, network, addr string) {
 	fd, err := Dial(network, "", addr);
 	defer fd.Close();
 	if err != nil {
-		t.Errorf("dial %s %s failed: %v", network, addr, err);
+		t.Errorf("dial %s %s failed: %v", network, addr, err)
 	}
 	t0 := time.Nanoseconds();
 	fd.SetReadTimeout(1e8);	// 100ms
@@ -21,10 +21,10 @@ func testTimeout(t *testing.T, network, addr string) {
 	n, err1 := fd.Read(&b);
 	t1 := time.Nanoseconds();
 	if n != 0 || !isEAGAIN(err1) {
-		t.Errorf("fd.Read on %s %s did not return 0, EAGAIN: %v, %v", network, addr, n, err1);
+		t.Errorf("fd.Read on %s %s did not return 0, EAGAIN: %v, %v", network, addr, n, err1)
 	}
 	if t1-t0 < 0.5e8 || t1-t0 > 1.5e8 {
-		t.Errorf("fd.Read on %s %s took %f seconds, expected 0.1", network, addr, float64(t1-t0)/1e9);
+		t.Errorf("fd.Read on %s %s took %f seconds, expected 0.1", network, addr, float64(t1-t0)/1e9)
 	}
 }
 
@@ -34,5 +34,5 @@ func TestTimeoutTCP(t *testing.T) {
 	// 74.125.19.99 is www.google.com.
 	// could use dns, but dns depends on
 	// timeouts and this is the timeout test.
-	testTimeout(t, "tcp", "74.125.19.99:80");
+	testTimeout(t, "tcp", "74.125.19.99:80")
 }
diff --git a/src/pkg/net/udpsock.go b/src/pkg/net/udpsock.go
index 4449e83793..32c7c734cf 100644
--- a/src/pkg/net/udpsock.go
+++ b/src/pkg/net/udpsock.go
@@ -14,9 +14,9 @@ import (
 func sockaddrToUDP(sa syscall.Sockaddr) Addr {
 	switch sa := sa.(type) {
 	case *syscall.SockaddrInet4:
-		return &UDPAddr{&sa.Addr, sa.Port};
+		return &UDPAddr{&sa.Addr, sa.Port}
 	case *syscall.SockaddrInet6:
-		return &UDPAddr{&sa.Addr, sa.Port};
+		return &UDPAddr{&sa.Addr, sa.Port}
 	}
 	return nil;
 }
@@ -34,21 +34,21 @@ func (a *UDPAddr) String() string	{ return joinHostPort(a.IP.String(), itoa(a.Po
 
 func (a *UDPAddr) family() int {
 	if a == nil || len(a.IP) <= 4 {
-		return syscall.AF_INET;
+		return syscall.AF_INET
 	}
 	if ip := a.IP.To4(); ip != nil {
-		return syscall.AF_INET;
+		return syscall.AF_INET
 	}
 	return syscall.AF_INET6;
 }
 
 func (a *UDPAddr) sockaddr(family int) (syscall.Sockaddr, os.Error) {
-	return ipToSockaddr(family, a.IP, a.Port);
+	return ipToSockaddr(family, a.IP, a.Port)
 }
 
 func (a *UDPAddr) toAddr() sockaddr {
 	if a == nil {	// nil *UDPAddr
-		return nil;	// nil interface
+		return nil	// nil interface
 	}
 	return a;
 }
@@ -60,7 +60,7 @@ func (a *UDPAddr) toAddr() sockaddr {
 func ResolveUDPAddr(addr string) (*UDPAddr, os.Error) {
 	ip, port, err := hostPortToIP("udp", addr);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	return &UDPAddr{ip, port}, nil;
 }
@@ -85,7 +85,7 @@ func (c *UDPConn) ok() bool	{ return c != nil && c.fd != nil }
 // after a fixed time limit; see SetTimeout and SetReadTimeout.
 func (c *UDPConn) Read(b []byte) (n int, err os.Error) {
 	if !c.ok() {
-		return 0, os.EINVAL;
+		return 0, os.EINVAL
 	}
 	return c.fd.Read(b);
 }
@@ -96,7 +96,7 @@ func (c *UDPConn) Read(b []byte) (n int, err os.Error) {
 // after a fixed time limit; see SetTimeout and SetReadTimeout.
 func (c *UDPConn) Write(b []byte) (n int, err os.Error) {
 	if !c.ok() {
-		return 0, os.EINVAL;
+		return 0, os.EINVAL
 	}
 	return c.fd.Write(b);
 }
@@ -104,7 +104,7 @@ func (c *UDPConn) Write(b []byte) (n int, err os.Error) {
 // Close closes the UDP connection.
 func (c *UDPConn) Close() os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	err := c.fd.Close();
 	c.fd = nil;
@@ -114,7 +114,7 @@ func (c *UDPConn) Close() os.Error {
 // LocalAddr returns the local network address.
 func (c *UDPConn) LocalAddr() Addr {
 	if !c.ok() {
-		return nil;
+		return nil
 	}
 	return c.fd.laddr;
 }
@@ -122,7 +122,7 @@ func (c *UDPConn) LocalAddr() Addr {
 // RemoteAddr returns the remote network address, a *UDPAddr.
 func (c *UDPConn) RemoteAddr() Addr {
 	if !c.ok() {
-		return nil;
+		return nil
 	}
 	return c.fd.raddr;
 }
@@ -131,7 +131,7 @@ func (c *UDPConn) RemoteAddr() Addr {
 // with the connection.
 func (c *UDPConn) SetTimeout(nsec int64) os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return setTimeout(c.fd, nsec);
 }
@@ -141,7 +141,7 @@ func (c *UDPConn) SetTimeout(nsec int64) os.Error {
 // Setting nsec == 0 (the default) disables the deadline.
 func (c *UDPConn) SetReadTimeout(nsec int64) os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return setReadTimeout(c.fd, nsec);
 }
@@ -153,7 +153,7 @@ func (c *UDPConn) SetReadTimeout(nsec int64) os.Error {
 // some of the data was successfully written.
 func (c *UDPConn) SetWriteTimeout(nsec int64) os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return setWriteTimeout(c.fd, nsec);
 }
@@ -162,7 +162,7 @@ func (c *UDPConn) SetWriteTimeout(nsec int64) os.Error {
 // receive buffer associated with the connection.
 func (c *UDPConn) SetReadBuffer(bytes int) os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return setReadBuffer(c.fd, bytes);
 }
@@ -171,7 +171,7 @@ func (c *UDPConn) SetReadBuffer(bytes int) os.Error {
 // transmit buffer associated with the connection.
 func (c *UDPConn) SetWriteBuffer(bytes int) os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return setWriteBuffer(c.fd, bytes);
 }
@@ -186,17 +186,17 @@ func (c *UDPConn) SetWriteBuffer(bytes int) os.Error {
 // after a fixed time limit; see SetTimeout and SetReadTimeout.
 func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err os.Error) {
 	if !c.ok() {
-		return 0, nil, os.EINVAL;
+		return 0, nil, os.EINVAL
 	}
 	n, sa, errno := syscall.Recvfrom(c.fd.fd, b, 0);
 	if errno != 0 {
-		err = os.Errno(errno);
+		err = os.Errno(errno)
 	}
 	switch sa := sa.(type) {
 	case *syscall.SockaddrInet4:
-		addr = &UDPAddr{&sa.Addr, sa.Port};
+		addr = &UDPAddr{&sa.Addr, sa.Port}
 	case *syscall.SockaddrInet6:
-		addr = &UDPAddr{&sa.Addr, sa.Port};
+		addr = &UDPAddr{&sa.Addr, sa.Port}
 	}
 	return;
 }
@@ -209,7 +209,7 @@ func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err os.Error) {
 // after a fixed time limit; see SetTimeout and SetReadTimeout.
 func (c *UDPConn) ReadFrom(b []byte) (n int, addr Addr, err os.Error) {
 	if !c.ok() {
-		return 0, nil, os.EINVAL;
+		return 0, nil, os.EINVAL
 	}
 	n, uaddr, err := c.ReadFromUDP(b);
 	return n, uaddr.toAddr(), err;
@@ -222,14 +222,14 @@ func (c *UDPConn) ReadFrom(b []byte) (n int, addr Addr, err os.Error) {
 // On packet-oriented connections such as UDP, write timeouts are rare.
 func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (n int, err os.Error) {
 	if !c.ok() {
-		return 0, os.EINVAL;
+		return 0, os.EINVAL
 	}
 	sa, err := addr.sockaddr(c.fd.family);
 	if err != nil {
-		return 0, err;
+		return 0, err
 	}
 	if errno := syscall.Sendto(c.fd.fd, b, 0, sa); errno != 0 {
-		return 0, os.Errno(errno);
+		return 0, os.Errno(errno)
 	}
 	return len(b), nil;
 }
@@ -241,11 +241,11 @@ func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (n int, err os.Error) {
 // On packet-oriented connections such as UDP, write timeouts are rare.
 func (c *UDPConn) WriteTo(b []byte, addr Addr) (n int, err os.Error) {
 	if !c.ok() {
-		return 0, os.EINVAL;
+		return 0, os.EINVAL
 	}
 	a, ok := addr.(*UDPAddr);
 	if !ok {
-		return 0, &OpError{"writeto", "udp", addr, os.EINVAL};
+		return 0, &OpError{"writeto", "udp", addr, os.EINVAL}
 	}
 	return c.WriteToUDP(b, a);
 }
@@ -257,14 +257,14 @@ func DialUDP(net string, laddr, raddr *UDPAddr) (c *UDPConn, err os.Error) {
 	switch net {
 	case "udp", "udp4", "udp6":
 	default:
-		return nil, UnknownNetworkError(net);
+		return nil, UnknownNetworkError(net)
 	}
 	if raddr == nil {
-		return nil, &OpError{"dial", "udp", nil, errMissingAddress};
+		return nil, &OpError{"dial", "udp", nil, errMissingAddress}
 	}
 	fd, e := internetSocket(net, laddr.toAddr(), raddr.toAddr(), syscall.SOCK_DGRAM, "dial", sockaddrToUDP);
 	if e != nil {
-		return nil, e;
+		return nil, e
 	}
 	return newUDPConn(fd), nil;
 }
@@ -277,14 +277,14 @@ func ListenUDP(net string, laddr *UDPAddr) (c *UDPConn, err os.Error) {
 	switch net {
 	case "udp", "udp4", "udp6":
 	default:
-		return nil, UnknownNetworkError(net);
+		return nil, UnknownNetworkError(net)
 	}
 	if laddr == nil {
-		return nil, &OpError{"listen", "udp", nil, errMissingAddress};
+		return nil, &OpError{"listen", "udp", nil, errMissingAddress}
 	}
 	fd, e := internetSocket(net, laddr.toAddr(), nil, syscall.SOCK_DGRAM, "dial", sockaddrToUDP);
 	if e != nil {
-		return nil, e;
+		return nil, e
 	}
 	return newUDPConn(fd), nil;
 }
diff --git a/src/pkg/net/unixsock.go b/src/pkg/net/unixsock.go
index 033f650c3b..f5631d8005 100644
--- a/src/pkg/net/unixsock.go
+++ b/src/pkg/net/unixsock.go
@@ -15,52 +15,52 @@ func unixSocket(net string, laddr, raddr *UnixAddr, mode string) (fd *netFD, err
 	var proto int;
 	switch net {
 	default:
-		return nil, UnknownNetworkError(net);
+		return nil, UnknownNetworkError(net)
 	case "unix":
-		proto = syscall.SOCK_STREAM;
+		proto = syscall.SOCK_STREAM
 	case "unixgram":
-		proto = syscall.SOCK_DGRAM;
+		proto = syscall.SOCK_DGRAM
 	}
 
 	var la, ra syscall.Sockaddr;
 	switch mode {
 	default:
-		panic("unixSocket", mode);
+		panic("unixSocket", mode)
 
 	case "dial":
 		if laddr != nil {
-			la = &syscall.SockaddrUnix{Name: laddr.Name};
+			la = &syscall.SockaddrUnix{Name: laddr.Name}
 		}
 		if raddr != nil {
-			ra = &syscall.SockaddrUnix{Name: raddr.Name};
+			ra = &syscall.SockaddrUnix{Name: raddr.Name}
 		} else if proto != syscall.SOCK_DGRAM || laddr == nil {
-			return nil, &OpError{mode, net, nil, errMissingAddress};
+			return nil, &OpError{mode, net, nil, errMissingAddress}
 		}
 
 	case "listen":
 		if laddr == nil {
-			return nil, &OpError{mode, net, nil, errMissingAddress};
+			return nil, &OpError{mode, net, nil, errMissingAddress}
 		}
 		la = &syscall.SockaddrUnix{Name: laddr.Name};
 		if raddr != nil {
-			return nil, &OpError{mode, net, raddr, &AddrError{"unexpected remote address", raddr.String()}};
+			return nil, &OpError{mode, net, raddr, &AddrError{"unexpected remote address", raddr.String()}}
 		}
 	}
 
 	f := sockaddrToUnix;
 	if proto != syscall.SOCK_STREAM {
-		f = sockaddrToUnixgram;
+		f = sockaddrToUnixgram
 	}
 	fd, err = socket(net, syscall.AF_UNIX, proto, 0, la, ra, f);
 	if err != nil {
-		goto Error;
+		goto Error
 	}
 	return fd, nil;
 
 Error:
 	addr := raddr;
 	if mode == "listen" {
-		addr = laddr;
+		addr = laddr
 	}
 	return nil, &OpError{mode, net, addr, err};
 }
@@ -73,14 +73,14 @@ type UnixAddr struct {
 
 func sockaddrToUnix(sa syscall.Sockaddr) Addr {
 	if s, ok := sa.(*syscall.SockaddrUnix); ok {
-		return &UnixAddr{s.Name, false};
+		return &UnixAddr{s.Name, false}
 	}
 	return nil;
 }
 
 func sockaddrToUnixgram(sa syscall.Sockaddr) Addr {
 	if s, ok := sa.(*syscall.SockaddrUnix); ok {
-		return &UnixAddr{s.Name, true};
+		return &UnixAddr{s.Name, true}
 	}
 	return nil;
 }
@@ -88,21 +88,21 @@ func sockaddrToUnixgram(sa syscall.Sockaddr) Addr {
 // Network returns the address's network name, "unix" or "unixgram".
 func (a *UnixAddr) Network() string {
 	if a == nil || !a.Datagram {
-		return "unix";
+		return "unix"
 	}
 	return "unixgram";
 }
 
 func (a *UnixAddr) String() string {
 	if a == nil {
-		return "<nil>";
+		return "<nil>"
 	}
 	return a.Name;
 }
 
 func (a *UnixAddr) toAddr() Addr {
 	if a == nil {	// nil *UnixAddr
-		return nil;	// nil interface
+		return nil	// nil interface
 	}
 	return a;
 }
@@ -114,9 +114,9 @@ func ResolveUnixAddr(net, addr string) (*UnixAddr, os.Error) {
 	switch net {
 	case "unix":
 	case "unixgram":
-		datagram = true;
+		datagram = true
 	default:
-		return nil, UnknownNetworkError(net);
+		return nil, UnknownNetworkError(net)
 	}
 	return &UnixAddr{addr, datagram}, nil;
 }
@@ -139,7 +139,7 @@ func (c *UnixConn) ok() bool	{ return c != nil && c.fd != nil }
 // after a fixed time limit; see SetTimeout and SetReadTimeout.
 func (c *UnixConn) Read(b []byte) (n int, err os.Error) {
 	if !c.ok() {
-		return 0, os.EINVAL;
+		return 0, os.EINVAL
 	}
 	return c.fd.Read(b);
 }
@@ -150,7 +150,7 @@ func (c *UnixConn) Read(b []byte) (n int, err os.Error) {
 // after a fixed time limit; see SetTimeout and SetReadTimeout.
 func (c *UnixConn) Write(b []byte) (n int, err os.Error) {
 	if !c.ok() {
-		return 0, os.EINVAL;
+		return 0, os.EINVAL
 	}
 	return c.fd.Write(b);
 }
@@ -158,7 +158,7 @@ func (c *UnixConn) Write(b []byte) (n int, err os.Error) {
 // Close closes the Unix domain connection.
 func (c *UnixConn) Close() os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	err := c.fd.Close();
 	c.fd = nil;
@@ -169,7 +169,7 @@ func (c *UnixConn) Close() os.Error {
 // Unlike in other protocols, LocalAddr is usually nil for dialed connections.
 func (c *UnixConn) LocalAddr() Addr {
 	if !c.ok() {
-		return nil;
+		return nil
 	}
 	return c.fd.laddr;
 }
@@ -179,7 +179,7 @@ func (c *UnixConn) LocalAddr() Addr {
 // accepted by a listener.
 func (c *UnixConn) RemoteAddr() Addr {
 	if !c.ok() {
-		return nil;
+		return nil
 	}
 	return c.fd.raddr;
 }
@@ -188,7 +188,7 @@ func (c *UnixConn) RemoteAddr() Addr {
 // with the connection.
 func (c *UnixConn) SetTimeout(nsec int64) os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return setTimeout(c.fd, nsec);
 }
@@ -198,7 +198,7 @@ func (c *UnixConn) SetTimeout(nsec int64) os.Error {
 // Setting nsec == 0 (the default) disables the deadline.
 func (c *UnixConn) SetReadTimeout(nsec int64) os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return setReadTimeout(c.fd, nsec);
 }
@@ -210,7 +210,7 @@ func (c *UnixConn) SetReadTimeout(nsec int64) os.Error {
 // some of the data was successfully written.
 func (c *UnixConn) SetWriteTimeout(nsec int64) os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return setWriteTimeout(c.fd, nsec);
 }
@@ -219,7 +219,7 @@ func (c *UnixConn) SetWriteTimeout(nsec int64) os.Error {
 // receive buffer associated with the connection.
 func (c *UnixConn) SetReadBuffer(bytes int) os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return setReadBuffer(c.fd, bytes);
 }
@@ -228,7 +228,7 @@ func (c *UnixConn) SetReadBuffer(bytes int) os.Error {
 // transmit buffer associated with the connection.
 func (c *UnixConn) SetWriteBuffer(bytes int) os.Error {
 	if !c.ok() {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 	return setWriteBuffer(c.fd, bytes);
 }
@@ -241,15 +241,15 @@ func (c *UnixConn) SetWriteBuffer(bytes int) os.Error {
 // after a fixed time limit; see SetTimeout and SetReadTimeout.
 func (c *UnixConn) ReadFromUnix(b []byte) (n int, addr *UnixAddr, err os.Error) {
 	if !c.ok() {
-		return 0, nil, os.EINVAL;
+		return 0, nil, os.EINVAL
 	}
 	n, sa, errno := syscall.Recvfrom(c.fd.fd, b, 0);
 	if errno != 0 {
-		err = os.Errno(errno);
+		err = os.Errno(errno)
 	}
 	switch sa := sa.(type) {
 	case *syscall.SockaddrUnix:
-		addr = &UnixAddr{sa.Name, c.fd.proto == syscall.SOCK_DGRAM};
+		addr = &UnixAddr{sa.Name, c.fd.proto == syscall.SOCK_DGRAM}
 	}
 	return;
 }
@@ -262,7 +262,7 @@ func (c *UnixConn) ReadFromUnix(b []byte) (n int, addr *UnixAddr, err os.Error)
 // after a fixed time limit; see SetTimeout and SetReadTimeout.
 func (c *UnixConn) ReadFrom(b []byte) (n int, addr Addr, err os.Error) {
 	if !c.ok() {
-		return 0, nil, os.EINVAL;
+		return 0, nil, os.EINVAL
 	}
 	n, uaddr, err := c.ReadFromUnix(b);
 	return n, uaddr.toAddr(), err;
@@ -275,14 +275,14 @@ func (c *UnixConn) ReadFrom(b []byte) (n int, addr Addr, err os.Error) {
 // On packet-oriented connections such as UDP, write timeouts are rare.
 func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (n int, err os.Error) {
 	if !c.ok() {
-		return 0, os.EINVAL;
+		return 0, os.EINVAL
 	}
 	if addr.Datagram != (c.fd.proto == syscall.SOCK_DGRAM) {
-		return 0, os.EAFNOSUPPORT;
+		return 0, os.EAFNOSUPPORT
 	}
 	sa := &syscall.SockaddrUnix{Name: addr.Name};
 	if errno := syscall.Sendto(c.fd.fd, b, 0, sa); errno != 0 {
-		return 0, os.Errno(errno);
+		return 0, os.Errno(errno)
 	}
 	return len(b), nil;
 }
@@ -294,11 +294,11 @@ func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (n int, err os.Error) {
 // On packet-oriented connections such as UDP, write timeouts are rare.
 func (c *UnixConn) WriteTo(b []byte, addr Addr) (n int, err os.Error) {
 	if !c.ok() {
-		return 0, os.EINVAL;
+		return 0, os.EINVAL
 	}
 	a, ok := addr.(*UnixAddr);
 	if !ok {
-		return 0, &OpError{"writeto", "unix", addr, os.EINVAL};
+		return 0, &OpError{"writeto", "unix", addr, os.EINVAL}
 	}
 	return c.WriteToUnix(b, a);
 }
@@ -309,7 +309,7 @@ func (c *UnixConn) WriteTo(b []byte, addr Addr) (n int, err os.Error) {
 func DialUnix(net string, laddr, raddr *UnixAddr) (c *UnixConn, err os.Error) {
 	fd, e := unixSocket(net, laddr, raddr, "dial");
 	if e != nil {
-		return nil, e;
+		return nil, e
 	}
 	return newUnixConn(fd), nil;
 }
@@ -326,15 +326,15 @@ type UnixListener struct {
 // Net must be "unix" (stream sockets).
 func ListenUnix(net string, laddr *UnixAddr) (l *UnixListener, err os.Error) {
 	if net != "unix" && net != "unixgram" {
-		return nil, UnknownNetworkError(net);
+		return nil, UnknownNetworkError(net)
 	}
 	if laddr != nil {
-		laddr = &UnixAddr{laddr.Name, net == "unixgram"};	// make our own copy
+		laddr = &UnixAddr{laddr.Name, net == "unixgram"}	// make our own copy
 	}
 	fd, e := unixSocket(net, laddr, nil, "listen");
 	if e != nil {
 		if pe, ok := e.(*os.PathError); ok {
-			e = pe.Error;
+			e = pe.Error
 		}
 		return nil, e;
 	}
@@ -350,11 +350,11 @@ func ListenUnix(net string, laddr *UnixAddr) (l *UnixListener, err os.Error) {
 // and the remote address.
 func (l *UnixListener) AcceptUnix() (c *UnixConn, err os.Error) {
 	if l == nil || l.fd == nil || l.fd.fd < 0 {
-		return nil, os.EINVAL;
+		return nil, os.EINVAL
 	}
 	fd, e := l.fd.accept(sockaddrToUnix);
 	if e != nil {
-		return nil, e;
+		return nil, e
 	}
 	c = newUnixConn(fd);
 	return c, nil;
@@ -365,7 +365,7 @@ func (l *UnixListener) AcceptUnix() (c *UnixConn, err os.Error) {
 func (l *UnixListener) Accept() (c Conn, err os.Error) {
 	c1, err := l.AcceptUnix();
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	return c1, nil;
 }
@@ -374,7 +374,7 @@ func (l *UnixListener) Accept() (c Conn, err os.Error) {
 // Already accepted connections are not closed.
 func (l *UnixListener) Close() os.Error {
 	if l == nil || l.fd == nil {
-		return os.EINVAL;
+		return os.EINVAL
 	}
 
 	// The operating system doesn't clean up
@@ -388,7 +388,7 @@ func (l *UnixListener) Close() os.Error {
 	// sequence in ListenUnix.  It's only non-Go
 	// programs that can mess us up.
 	if l.path[0] != '@' {
-		syscall.Unlink(l.path);
+		syscall.Unlink(l.path)
 	}
 	err := l.fd.Close();
 	l.fd = nil;
@@ -406,14 +406,14 @@ func ListenUnixgram(net string, laddr *UnixAddr) (c *UDPConn, err os.Error) {
 	switch net {
 	case "unixgram":
 	default:
-		return nil, UnknownNetworkError(net);
+		return nil, UnknownNetworkError(net)
 	}
 	if laddr == nil {
-		return nil, &OpError{"listen", "unixgram", nil, errMissingAddress};
+		return nil, &OpError{"listen", "unixgram", nil, errMissingAddress}
 	}
 	fd, e := unixSocket(net, laddr, nil, "listen");
 	if e != nil {
-		return nil, e;
+		return nil, e
 	}
 	return newUDPConn(fd), nil;
 }
diff --git a/src/pkg/once/once_test.go b/src/pkg/once/once_test.go
index e89e05e81d..e31bcc278f 100644
--- a/src/pkg/once/once_test.go
+++ b/src/pkg/once/once_test.go
@@ -17,14 +17,14 @@ func TestDo(t *testing.T) {
 	ncall = 0;
 	once.Do(call);
 	if ncall != 1 {
-		t.Fatalf("once.Do(call) didn't call(): ncall=%d", ncall);
+		t.Fatalf("once.Do(call) didn't call(): ncall=%d", ncall)
 	}
 	once.Do(call);
 	if ncall != 1 {
-		t.Fatalf("second once.Do(call) did call(): ncall=%d", ncall);
+		t.Fatalf("second once.Do(call) did call(): ncall=%d", ncall)
 	}
 	once.Do(call);
 	if ncall != 1 {
-		t.Fatalf("third once.Do(call) did call(): ncall=%d", ncall);
+		t.Fatalf("third once.Do(call) did call(): ncall=%d", ncall)
 	}
 }
diff --git a/src/pkg/os/dir_darwin.go b/src/pkg/os/dir_darwin.go
index c207a19fd4..74781ae5b4 100644
--- a/src/pkg/os/dir_darwin.go
+++ b/src/pkg/os/dir_darwin.go
@@ -29,7 +29,7 @@ func (file *File) Readdirnames(count int) (names []string, err Error) {
 	d := file.dirinfo;
 	size := count;
 	if size < 0 {
-		size = 100;
+		size = 100
 	}
 	names = make([]string, 0, size);	// Empty with room to grow.
 	for count != 0 {
@@ -44,7 +44,7 @@ func (file *File) Readdirnames(count int) (names []string, err Error) {
 				return names, NewSyscallError("getdirentries", errno);
 			}
 			if d.nbuf <= 0 {
-				break;	// EOF
+				break	// EOF
 			}
 		}
 		// Drain the buffer
@@ -56,18 +56,18 @@ func (file *File) Readdirnames(count int) (names []string, err Error) {
 			}
 			d.bufp += int(dirent.Reclen);
 			if dirent.Ino == 0 {	// File absent in directory.
-				continue;
+				continue
 			}
 			bytes := (*[len(dirent.Name)]byte)(unsafe.Pointer(&dirent.Name[0]));
 			var name = string(bytes[0 : dirent.Namlen]);
 			if name == "." || name == ".." {	// Useless names
-				continue;
+				continue
 			}
 			count--;
 			if len(names) == cap(names) {
 				nnames := make([]string, len(names), 2*len(names));
 				for i := 0; i < len(names); i++ {
-					nnames[i] = names[i];
+					nnames[i] = names[i]
 				}
 				names = nnames;
 			}
diff --git a/src/pkg/os/dir_linux.go b/src/pkg/os/dir_linux.go
index d6e77016cc..0e73fefd65 100644
--- a/src/pkg/os/dir_linux.go
+++ b/src/pkg/os/dir_linux.go
@@ -16,7 +16,7 @@ const (
 func clen(n []byte) int {
 	for i := 0; i < len(n); i++ {
 		if n[i] == 0 {
-			return i;
+			return i
 		}
 	}
 	return len(n);
@@ -33,7 +33,7 @@ func (file *File) Readdirnames(count int) (names []string, err Error) {
 	d := file.dirinfo;
 	size := count;
 	if size < 0 {
-		size = 100;
+		size = 100
 	}
 	names = make([]string, 0, size);	// Empty with room to grow.
 	for count != 0 {
@@ -42,10 +42,10 @@ func (file *File) Readdirnames(count int) (names []string, err Error) {
 			var errno int;
 			d.nbuf, errno = syscall.Getdents(file.fd, d.buf);
 			if errno != 0 {
-				return names, NewSyscallError("getdents", errno);
+				return names, NewSyscallError("getdents", errno)
 			}
 			if d.nbuf <= 0 {
-				break;	// EOF
+				break	// EOF
 			}
 			d.bufp = 0;
 		}
@@ -54,18 +54,18 @@ func (file *File) Readdirnames(count int) (names []string, err Error) {
 			dirent := (*syscall.Dirent)(unsafe.Pointer(&d.buf[d.bufp]));
 			d.bufp += int(dirent.Reclen);
 			if dirent.Ino == 0 {	// File absent in directory.
-				continue;
+				continue
 			}
 			bytes := (*[len(dirent.Name)]byte)(unsafe.Pointer(&dirent.Name[0]));
 			var name = string(bytes[0:clen(bytes)]);
 			if name == "." || name == ".." {	// Useless names
-				continue;
+				continue
 			}
 			count--;
 			if len(names) == cap(names) {
 				nnames := make([]string, len(names), 2*len(names));
 				for i := 0; i < len(names); i++ {
-					nnames[i] = names[i];
+					nnames[i] = names[i]
 				}
 				names = nnames;
 			}
diff --git a/src/pkg/os/dir_nacl.go b/src/pkg/os/dir_nacl.go
index d6e77016cc..0e73fefd65 100644
--- a/src/pkg/os/dir_nacl.go
+++ b/src/pkg/os/dir_nacl.go
@@ -16,7 +16,7 @@ const (
 func clen(n []byte) int {
 	for i := 0; i < len(n); i++ {
 		if n[i] == 0 {
-			return i;
+			return i
 		}
 	}
 	return len(n);
@@ -33,7 +33,7 @@ func (file *File) Readdirnames(count int) (names []string, err Error) {
 	d := file.dirinfo;
 	size := count;
 	if size < 0 {
-		size = 100;
+		size = 100
 	}
 	names = make([]string, 0, size);	// Empty with room to grow.
 	for count != 0 {
@@ -42,10 +42,10 @@ func (file *File) Readdirnames(count int) (names []string, err Error) {
 			var errno int;
 			d.nbuf, errno = syscall.Getdents(file.fd, d.buf);
 			if errno != 0 {
-				return names, NewSyscallError("getdents", errno);
+				return names, NewSyscallError("getdents", errno)
 			}
 			if d.nbuf <= 0 {
-				break;	// EOF
+				break	// EOF
 			}
 			d.bufp = 0;
 		}
@@ -54,18 +54,18 @@ func (file *File) Readdirnames(count int) (names []string, err Error) {
 			dirent := (*syscall.Dirent)(unsafe.Pointer(&d.buf[d.bufp]));
 			d.bufp += int(dirent.Reclen);
 			if dirent.Ino == 0 {	// File absent in directory.
-				continue;
+				continue
 			}
 			bytes := (*[len(dirent.Name)]byte)(unsafe.Pointer(&dirent.Name[0]));
 			var name = string(bytes[0:clen(bytes)]);
 			if name == "." || name == ".." {	// Useless names
-				continue;
+				continue
 			}
 			count--;
 			if len(names) == cap(names) {
 				nnames := make([]string, len(names), 2*len(names));
 				for i := 0; i < len(names); i++ {
-					nnames[i] = names[i];
+					nnames[i] = names[i]
 				}
 				names = nnames;
 			}
diff --git a/src/pkg/os/env.go b/src/pkg/os/env.go
index 3523f57e41..e858649928 100644
--- a/src/pkg/os/env.go
+++ b/src/pkg/os/env.go
@@ -34,11 +34,11 @@ func Getenverror(key string) (value string, err Error) {
 	once.Do(copyenv);
 
 	if len(key) == 0 {
-		return "", EINVAL;
+		return "", EINVAL
 	}
 	v, ok := env[key];
 	if !ok {
-		return "", ENOENV;
+		return "", ENOENV
 	}
 	return v, nil;
 }
@@ -56,7 +56,7 @@ func Setenv(key, value string) Error {
 	once.Do(copyenv);
 
 	if len(key) == 0 {
-		return EINVAL;
+		return EINVAL
 	}
 	env[key] = value;
 	return nil;
diff --git a/src/pkg/os/error.go b/src/pkg/os/error.go
index 6bbf5371ed..34f88de8d1 100644
--- a/src/pkg/os/error.go
+++ b/src/pkg/os/error.go
@@ -97,7 +97,7 @@ func (e *SyscallError) String() string	{ return e.Syscall + ": " + e.Errno.Strin
 // As a convenience, if errno is 0, NewSyscallError returns nil.
 func NewSyscallError(syscall string, errno int) Error {
 	if errno == 0 {
-		return nil;
+		return nil
 	}
 	return &SyscallError{syscall, Errno(errno)};
 }
diff --git a/src/pkg/os/exec.go b/src/pkg/os/exec.go
index a279bf428e..80c2913f07 100644
--- a/src/pkg/os/exec.go
+++ b/src/pkg/os/exec.go
@@ -20,15 +20,15 @@ func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []*File
 	intfd := make([]int, len(fd));
 	for i, f := range fd {
 		if f == nil {
-			intfd[i] = -1;
+			intfd[i] = -1
 		} else {
-			intfd[i] = f.Fd();
+			intfd[i] = f.Fd()
 		}
 	}
 
 	p, e := syscall.ForkExec(argv0, argv, envv, dir, intfd);
 	if e != 0 {
-		return 0, &PathError{"fork/exec", argv0, Errno(e)};
+		return 0, &PathError{"fork/exec", argv0, Errno(e)}
 	}
 	return p, nil;
 }
@@ -39,11 +39,11 @@ func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []*File
 // ForkExec is almost always a better way to execute a program.
 func Exec(argv0 string, argv []string, envv []string) Error {
 	if envv == nil {
-		envv = Environ();
+		envv = Environ()
 	}
 	e := syscall.Exec(argv0, argv, envv);
 	if e != 0 {
-		return &PathError{"exec", argv0, Errno(e)};
+		return &PathError{"exec", argv0, Errno(e)}
 	}
 	return nil;
 }
@@ -86,7 +86,7 @@ func Wait(pid int, options int) (w *Waitmsg, err Error) {
 	}
 	pid1, e := syscall.Wait4(pid, &status, options, rusage);
 	if e != 0 {
-		return nil, NewSyscallError("wait", e);
+		return nil, NewSyscallError("wait", e)
 	}
 	w = new(Waitmsg);
 	w.Pid = pid1;
@@ -98,12 +98,12 @@ func Wait(pid int, options int) (w *Waitmsg, err Error) {
 // Convert i to decimal string.
 func itod(i int) string {
 	if i == 0 {
-		return "0";
+		return "0"
 	}
 
 	u := uint64(i);
 	if i < 0 {
-		u = -u;
+		u = -u
 	}
 
 	// Assemble decimal in reverse order.
@@ -127,19 +127,19 @@ func (w Waitmsg) String() string {
 	res := "";
 	switch {
 	case w.Exited():
-		res = "exit status " + itod(w.ExitStatus());
+		res = "exit status " + itod(w.ExitStatus())
 	case w.Signaled():
-		res = "signal " + itod(w.Signal());
+		res = "signal " + itod(w.Signal())
 	case w.Stopped():
 		res = "stop signal " + itod(w.StopSignal());
 		if w.StopSignal() == syscall.SIGTRAP && w.TrapCause() != 0 {
-			res += " (trap " + itod(w.TrapCause()) + ")";
+			res += " (trap " + itod(w.TrapCause()) + ")"
 		}
 	case w.Continued():
-		res = "continued";
+		res = "continued"
 	}
 	if w.CoreDump() {
-		res += " (core dumped)";
+		res += " (core dumped)"
 	}
 	return res;
 }
diff --git a/src/pkg/os/file.go b/src/pkg/os/file.go
index 0afdca39cc..d378b70254 100644
--- a/src/pkg/os/file.go
+++ b/src/pkg/os/file.go
@@ -34,7 +34,7 @@ func (file *File) Name() string	{ return file.name }
 // NewFile returns a new File with the given file descriptor and name.
 func NewFile(fd int, name string) *File {
 	if fd < 0 {
-		return nil;
+		return nil
 	}
 	return &File{fd, name, nil, 0};
 }
@@ -70,13 +70,13 @@ const (
 func Open(name string, flag int, perm int) (file *File, err Error) {
 	r, e := syscall.Open(name, flag | syscall.O_CLOEXEC, perm);
 	if e != 0 {
-		return nil, &PathError{"open", name, Errno(e)};
+		return nil, &PathError{"open", name, Errno(e)}
 	}
 
 	// There's a race here with fork/exec, which we are
 	// content to live with.  See ../syscall/exec.go
 	if syscall.O_CLOEXEC == 0 {	// O_CLOEXEC not supported
-		syscall.CloseOnExec(r);
+		syscall.CloseOnExec(r)
 	}
 
 	return NewFile(r, name), nil;
@@ -86,11 +86,11 @@ func Open(name string, flag int, perm int) (file *File, err Error) {
 // It returns an Error, if any.
 func (file *File) Close() Error {
 	if file == nil {
-		return EINVAL;
+		return EINVAL
 	}
 	var err Error;
 	if e := syscall.Close(file.fd); e != 0 {
-		err = &PathError{"close", file.name, Errno(e)};
+		err = &PathError{"close", file.name, Errno(e)}
 	}
 	file.fd = -1;	// so it can't be closed again
 	return err;
@@ -112,17 +112,17 @@ var EOF Error = eofError(0)
 // EOF is signaled by a zero count with err set to EOF.
 func (file *File) Read(b []byte) (n int, err Error) {
 	if file == nil {
-		return 0, EINVAL;
+		return 0, EINVAL
 	}
 	n, e := syscall.Read(file.fd, b);
 	if n < 0 {
-		n = 0;
+		n = 0
 	}
 	if n == 0 && e == 0 {
-		return 0, EOF;
+		return 0, EOF
 	}
 	if e != 0 {
-		err = &PathError{"read", file.name, Errno(e)};
+		err = &PathError{"read", file.name, Errno(e)}
 	}
 	return n, err;
 }
@@ -133,7 +133,7 @@ func (file *File) Read(b []byte) (n int, err Error) {
 // ReadAt always returns a non-nil Error when n != len(b).
 func (file *File) ReadAt(b []byte, off int64) (n int, err Error) {
 	if file == nil {
-		return 0, EINVAL;
+		return 0, EINVAL
 	}
 	for len(b) > 0 {
 		m, e := syscall.Pread(file.fd, b, off);
@@ -153,22 +153,22 @@ func (file *File) ReadAt(b []byte, off int64) (n int, err Error) {
 // Write returns a non-nil Error when n != len(b).
 func (file *File) Write(b []byte) (n int, err Error) {
 	if file == nil {
-		return 0, EINVAL;
+		return 0, EINVAL
 	}
 	n, e := syscall.Write(file.fd, b);
 	if n < 0 {
-		n = 0;
+		n = 0
 	}
 	if e == syscall.EPIPE {
 		file.nepipe++;
 		if file.nepipe >= 10 {
-			Exit(syscall.EPIPE);
+			Exit(syscall.EPIPE)
 		}
 	} else {
-		file.nepipe = 0;
+		file.nepipe = 0
 	}
 	if e != 0 {
-		err = &PathError{"write", file.name, Errno(e)};
+		err = &PathError{"write", file.name, Errno(e)}
 	}
 	return n, err;
 }
@@ -178,7 +178,7 @@ func (file *File) Write(b []byte) (n int, err Error) {
 // WriteAt returns a non-nil Error when n != len(b).
 func (file *File) WriteAt(b []byte, off int64) (n int, err Error) {
 	if file == nil {
-		return 0, EINVAL;
+		return 0, EINVAL
 	}
 	for len(b) > 0 {
 		m, e := syscall.Pwrite(file.fd, b, off);
@@ -200,10 +200,10 @@ func (file *File) WriteAt(b []byte, off int64) (n int, err Error) {
 func (file *File) Seek(offset int64, whence int) (ret int64, err Error) {
 	r, e := syscall.Seek(file.fd, offset, whence);
 	if e == 0 && file.dirinfo != nil && r != 0 {
-		e = syscall.EISDIR;
+		e = syscall.EISDIR
 	}
 	if e != 0 {
-		return 0, &PathError{"seek", file.name, Errno(e)};
+		return 0, &PathError{"seek", file.name, Errno(e)}
 	}
 	return r, nil;
 }
@@ -212,7 +212,7 @@ func (file *File) Seek(offset int64, whence int) (ret int64, err Error) {
 // an array of bytes.
 func (file *File) WriteString(s string) (ret int, err Error) {
 	if file == nil {
-		return 0, EINVAL;
+		return 0, EINVAL
 	}
 	b := syscall.StringByteSlice(s);
 	b = b[0 : len(b)-1];
@@ -243,7 +243,7 @@ func Pipe() (r *File, w *File, err Error) {
 func Mkdir(name string, perm int) Error {
 	e := syscall.Mkdir(name, perm);
 	if e != 0 {
-		return &PathError{"mkdir", name, Errno(e)};
+		return &PathError{"mkdir", name, Errno(e)}
 	}
 	return nil;
 }
@@ -257,13 +257,13 @@ func Stat(name string) (dir *Dir, err Error) {
 	var lstat, stat syscall.Stat_t;
 	e := syscall.Lstat(name, &lstat);
 	if e != 0 {
-		return nil, &PathError{"stat", name, Errno(e)};
+		return nil, &PathError{"stat", name, Errno(e)}
 	}
 	statp := &lstat;
 	if lstat.Mode & syscall.S_IFMT == syscall.S_IFLNK {
 		e := syscall.Stat(name, &stat);
 		if e == 0 {
-			statp = &stat;
+			statp = &stat
 		}
 	}
 	return dirFromStat(name, new(Dir), &lstat, statp), nil;
@@ -275,7 +275,7 @@ func (file *File) Stat() (dir *Dir, err Error) {
 	var stat syscall.Stat_t;
 	e := syscall.Fstat(file.fd, &stat);
 	if e != 0 {
-		return nil, &PathError{"stat", file.name, Errno(e)};
+		return nil, &PathError{"stat", file.name, Errno(e)}
 	}
 	return dirFromStat(file.name, new(Dir), &stat, &stat), nil;
 }
@@ -287,7 +287,7 @@ func Lstat(name string) (dir *Dir, err Error) {
 	var stat syscall.Stat_t;
 	e := syscall.Lstat(name, &stat);
 	if e != 0 {
-		return nil, &PathError{"lstat", name, Errno(e)};
+		return nil, &PathError{"lstat", name, Errno(e)}
 	}
 	return dirFromStat(name, new(Dir), &stat, &stat), nil;
 }
@@ -300,20 +300,20 @@ func Lstat(name string) (dir *Dir, err Error) {
 func (file *File) Readdir(count int) (dirs []Dir, err Error) {
 	dirname := file.name;
 	if dirname == "" {
-		dirname = ".";
+		dirname = "."
 	}
 	dirname += "/";
 	names, err1 := file.Readdirnames(count);
 	if err1 != nil {
-		return nil, err1;
+		return nil, err1
 	}
 	dirs = make([]Dir, len(names));
 	for i, filename := range names {
 		dirp, err := Lstat(dirname+filename);
 		if dirp == nil || err != nil {
-			dirs[i].Name = filename;	// rest is already zeroed out
+			dirs[i].Name = filename	// rest is already zeroed out
 		} else {
-			dirs[i] = *dirp;
+			dirs[i] = *dirp
 		}
 	}
 	return;
@@ -322,7 +322,7 @@ func (file *File) Readdir(count int) (dirs []Dir, err Error) {
 // Chdir changes the current working directory to the named directory.
 func Chdir(dir string) Error {
 	if e := syscall.Chdir(dir); e != 0 {
-		return &PathError{"chdir", dir, Errno(e)};
+		return &PathError{"chdir", dir, Errno(e)}
 	}
 	return nil;
 }
@@ -331,7 +331,7 @@ func Chdir(dir string) Error {
 // which must be a directory.
 func (f *File) Chdir() Error {
 	if e := syscall.Fchdir(f.fd); e != 0 {
-		return &PathError{"chdir", f.name, Errno(e)};
+		return &PathError{"chdir", f.name, Errno(e)}
 	}
 	return nil;
 }
@@ -344,11 +344,11 @@ func Remove(name string) Error {
 	// doing a Stat plus the right one.
 	e := syscall.Unlink(name);
 	if e == 0 {
-		return nil;
+		return nil
 	}
 	e1 := syscall.Rmdir(name);
 	if e1 == 0 {
-		return nil;
+		return nil
 	}
 
 	// Both failed: figure out which error to return.
@@ -361,7 +361,7 @@ func Remove(name string) Error {
 	// both errors will be ENOTDIR, so it's okay to
 	// use the error from unlink.
 	if e1 != syscall.ENOTDIR {
-		e = e1;
+		e = e1
 	}
 	return &PathError{"remove", name, Errno(e)};
 }
@@ -376,14 +376,14 @@ type LinkError struct {
 }
 
 func (e *LinkError) String() string {
-	return e.Op + " " + e.Old + " " + e.New + ": " + e.Error.String();
+	return e.Op + " " + e.Old + " " + e.New + ": " + e.Error.String()
 }
 
 // Link creates a hard link.
 func Link(oldname, newname string) Error {
 	e := syscall.Link(oldname, newname);
 	if e != 0 {
-		return &LinkError{"link", oldname, newname, Errno(e)};
+		return &LinkError{"link", oldname, newname, Errno(e)}
 	}
 	return nil;
 }
@@ -392,7 +392,7 @@ func Link(oldname, newname string) Error {
 func Symlink(oldname, newname string) Error {
 	e := syscall.Symlink(oldname, newname);
 	if e != 0 {
-		return &LinkError{"symlink", oldname, newname, Errno(e)};
+		return &LinkError{"symlink", oldname, newname, Errno(e)}
 	}
 	return nil;
 }
@@ -404,10 +404,10 @@ func Readlink(name string) (string, Error) {
 		b := make([]byte, len);
 		n, e := syscall.Readlink(name, b);
 		if e != 0 {
-			return "", &PathError{"readlink", name, Errno(e)};
+			return "", &PathError{"readlink", name, Errno(e)}
 		}
 		if n < len {
-			return string(b[0:n]), nil;
+			return string(b[0:n]), nil
 		}
 	}
 	// Silence 6g.
@@ -418,7 +418,7 @@ func Readlink(name string) (string, Error) {
 // If the file is a symbolic link, it changes the uid and gid of the link's target.
 func Chmod(name string, mode int) Error {
 	if e := syscall.Chmod(name, mode); e != 0 {
-		return &PathError{"chmod", name, Errno(e)};
+		return &PathError{"chmod", name, Errno(e)}
 	}
 	return nil;
 }
@@ -426,7 +426,7 @@ func Chmod(name string, mode int) Error {
 // Chmod changes the mode of the file to mode.
 func (f *File) Chmod(mode int) Error {
 	if e := syscall.Fchmod(f.fd, mode); e != 0 {
-		return &PathError{"chmod", f.name, Errno(e)};
+		return &PathError{"chmod", f.name, Errno(e)}
 	}
 	return nil;
 }
@@ -435,7 +435,7 @@ func (f *File) Chmod(mode int) Error {
 // If the file is a symbolic link, it changes the uid and gid of the link's target.
 func Chown(name string, uid, gid int) Error {
 	if e := syscall.Chown(name, uid, gid); e != 0 {
-		return &PathError{"chown", name, Errno(e)};
+		return &PathError{"chown", name, Errno(e)}
 	}
 	return nil;
 }
@@ -444,7 +444,7 @@ func Chown(name string, uid, gid int) Error {
 // If the file is a symbolic link, it changes the uid and gid of the link itself.
 func Lchown(name string, uid, gid int) Error {
 	if e := syscall.Lchown(name, uid, gid); e != 0 {
-		return &PathError{"lchown", name, Errno(e)};
+		return &PathError{"lchown", name, Errno(e)}
 	}
 	return nil;
 }
@@ -452,7 +452,7 @@ func Lchown(name string, uid, gid int) Error {
 // Chown changes the numeric uid and gid of the named file.
 func (f *File) Chown(uid, gid int) Error {
 	if e := syscall.Fchown(f.fd, uid, gid); e != 0 {
-		return &PathError{"chown", f.name, Errno(e)};
+		return &PathError{"chown", f.name, Errno(e)}
 	}
 	return nil;
 }
@@ -461,7 +461,7 @@ func (f *File) Chown(uid, gid int) Error {
 // If the file is a symbolic link, it changes the size of the link's target.
 func Truncate(name string, size int64) Error {
 	if e := syscall.Truncate(name, size); e != 0 {
-		return &PathError{"truncate", name, Errno(e)};
+		return &PathError{"truncate", name, Errno(e)}
 	}
 	return nil;
 }
@@ -470,7 +470,7 @@ func Truncate(name string, size int64) Error {
 // It does not change the I/O offset.
 func (f *File) Truncate(size int64) Error {
 	if e := syscall.Ftruncate(f.fd, size); e != 0 {
-		return &PathError{"truncate", f.name, Errno(e)};
+		return &PathError{"truncate", f.name, Errno(e)}
 	}
 	return nil;
 }
diff --git a/src/pkg/os/getwd.go b/src/pkg/os/getwd.go
index bb8637b2be..1f7580d227 100644
--- a/src/pkg/os/getwd.go
+++ b/src/pkg/os/getwd.go
@@ -22,7 +22,7 @@ func Getwd() (string, Error) {
 	// Otherwise, we're trying to find our way back to ".".
 	dot, err := Stat(".");
 	if err != nil {
-		return "", err;
+		return "", err
 	}
 
 	// Clumsy but widespread kludge:
@@ -31,7 +31,7 @@ func Getwd() (string, Error) {
 	if len(pwd) > 0 && pwd[0] == '/' {
 		d, err := Stat(pwd);
 		if err == nil && d.Dev == dot.Dev && d.Ino == dot.Ino {
-			return pwd, nil;
+			return pwd, nil
 		}
 	}
 
@@ -40,10 +40,10 @@ func Getwd() (string, Error) {
 	root, err := Stat("/");
 	if err != nil {
 		// Can't stat root - no hope.
-		return "", err;
+		return "", err
 	}
 	if root.Dev == dot.Dev && root.Ino == dot.Ino {
-		return "/", nil;
+		return "/", nil
 	}
 
 	// General algorithm: find name in parent
@@ -52,11 +52,11 @@ func Getwd() (string, Error) {
 	pwd = "";
 	for parent := ".."; ; parent = "../"+parent {
 		if len(parent) >= 1024 {	// Sanity check
-			return "", ENAMETOOLONG;
+			return "", ENAMETOOLONG
 		}
 		fd, err := Open(parent, O_RDONLY, 0);
 		if err != nil {
-			return "", err;
+			return "", err
 		}
 
 		for {
@@ -79,11 +79,11 @@ func Getwd() (string, Error) {
 	Found:
 		pd, err := fd.Stat();
 		if err != nil {
-			return "", err;
+			return "", err
 		}
 		fd.Close();
 		if pd.Dev == root.Dev && pd.Ino == root.Ino {
-			break;
+			break
 		}
 		// Set up for next round.
 		dot = pd;
diff --git a/src/pkg/os/os_test.go b/src/pkg/os/os_test.go
index 832ce60833..9eb032768c 100644
--- a/src/pkg/os/os_test.go
+++ b/src/pkg/os/os_test.go
@@ -36,7 +36,7 @@ func size(name string, t *testing.T) uint64 {
 	file, err := Open(name, O_RDONLY, 0);
 	defer file.Close();
 	if err != nil {
-		t.Fatal("open failed:", err);
+		t.Fatal("open failed:", err)
 	}
 	var buf [100]byte;
 	len := 0;
@@ -44,10 +44,10 @@ func size(name string, t *testing.T) uint64 {
 		n, e := file.Read(&buf);
 		len += n;
 		if e == EOF {
-			break;
+			break
 		}
 		if e != nil {
-			t.Fatal("read failed:", err);
+			t.Fatal("read failed:", err)
 		}
 	}
 	return uint64(len);
@@ -56,14 +56,14 @@ func size(name string, t *testing.T) uint64 {
 func TestStat(t *testing.T) {
 	dir, err := Stat("/etc/passwd");
 	if err != nil {
-		t.Fatal("stat failed:", err);
+		t.Fatal("stat failed:", err)
 	}
 	if dir.Name != "passwd" {
-		t.Error("name should be passwd; is", dir.Name);
+		t.Error("name should be passwd; is", dir.Name)
 	}
 	filesize := size("/etc/passwd", t);
 	if dir.Size != filesize {
-		t.Error("size should be", filesize, "; is", dir.Size);
+		t.Error("size should be", filesize, "; is", dir.Size)
 	}
 }
 
@@ -71,32 +71,32 @@ func TestFstat(t *testing.T) {
 	file, err1 := Open("/etc/passwd", O_RDONLY, 0);
 	defer file.Close();
 	if err1 != nil {
-		t.Fatal("open failed:", err1);
+		t.Fatal("open failed:", err1)
 	}
 	dir, err2 := file.Stat();
 	if err2 != nil {
-		t.Fatal("fstat failed:", err2);
+		t.Fatal("fstat failed:", err2)
 	}
 	if dir.Name != "passwd" {
-		t.Error("name should be passwd; is", dir.Name);
+		t.Error("name should be passwd; is", dir.Name)
 	}
 	filesize := size("/etc/passwd", t);
 	if dir.Size != filesize {
-		t.Error("size should be", filesize, "; is", dir.Size);
+		t.Error("size should be", filesize, "; is", dir.Size)
 	}
 }
 
 func TestLstat(t *testing.T) {
 	dir, err := Lstat("/etc/passwd");
 	if err != nil {
-		t.Fatal("lstat failed:", err);
+		t.Fatal("lstat failed:", err)
 	}
 	if dir.Name != "passwd" {
-		t.Error("name should be passwd; is", dir.Name);
+		t.Error("name should be passwd; is", dir.Name)
 	}
 	filesize := size("/etc/passwd", t);
 	if dir.Size != filesize {
-		t.Error("size should be", filesize, "; is", dir.Size);
+		t.Error("size should be", filesize, "; is", dir.Size)
 	}
 }
 
@@ -104,27 +104,27 @@ func testReaddirnames(dir string, contents []string, t *testing.T) {
 	file, err := Open(dir, O_RDONLY, 0);
 	defer file.Close();
 	if err != nil {
-		t.Fatalf("open %q failed: %v", dir, err);
+		t.Fatalf("open %q failed: %v", dir, err)
 	}
 	s, err2 := file.Readdirnames(-1);
 	if err2 != nil {
-		t.Fatalf("readdirnames %q failed: %v", err2);
+		t.Fatalf("readdirnames %q failed: %v", err2)
 	}
 	for _, m := range contents {
 		found := false;
 		for _, n := range s {
 			if n == "." || n == ".." {
-				t.Errorf("got %s in directory", n);
+				t.Errorf("got %s in directory", n)
 			}
 			if m == n {
 				if found {
-					t.Error("present twice:", m);
+					t.Error("present twice:", m)
 				}
 				found = true;
 			}
 		}
 		if !found {
-			t.Error("could not find", m);
+			t.Error("could not find", m)
 		}
 	}
 }
@@ -133,24 +133,24 @@ func testReaddir(dir string, contents []string, t *testing.T) {
 	file, err := Open(dir, O_RDONLY, 0);
 	defer file.Close();
 	if err != nil {
-		t.Fatalf("open %q failed: %v", dir, err);
+		t.Fatalf("open %q failed: %v", dir, err)
 	}
 	s, err2 := file.Readdir(-1);
 	if err2 != nil {
-		t.Fatalf("readdir %q failed: %v", dir, err2);
+		t.Fatalf("readdir %q failed: %v", dir, err2)
 	}
 	for _, m := range contents {
 		found := false;
 		for _, n := range s {
 			if m == n.Name {
 				if found {
-					t.Error("present twice:", m);
+					t.Error("present twice:", m)
 				}
 				found = true;
 			}
 		}
 		if !found {
-			t.Error("could not find", m);
+			t.Error("could not find", m)
 		}
 	}
 }
@@ -172,10 +172,10 @@ func smallReaddirnames(file *File, length int, t *testing.T) []string {
 	for {
 		d, err := file.Readdirnames(1);
 		if err != nil {
-			t.Fatalf("readdir %q failed: %v", file.Name(), err);
+			t.Fatalf("readdir %q failed: %v", file.Name(), err)
 		}
 		if len(d) == 0 {
-			break;
+			break
 		}
 		names[count] = d[0];
 		count++;
@@ -190,20 +190,20 @@ func TestReaddirnamesOneAtATime(t *testing.T) {
 	file, err := Open(dir, O_RDONLY, 0);
 	defer file.Close();
 	if err != nil {
-		t.Fatalf("open %q failed: %v", dir, err);
+		t.Fatalf("open %q failed: %v", dir, err)
 	}
 	all, err1 := file.Readdirnames(-1);
 	if err1 != nil {
-		t.Fatalf("readdirnames %q failed: %v", dir, err1);
+		t.Fatalf("readdirnames %q failed: %v", dir, err1)
 	}
 	file1, err2 := Open(dir, O_RDONLY, 0);
 	if err2 != nil {
-		t.Fatalf("open %q failed: %v", dir, err2);
+		t.Fatalf("open %q failed: %v", dir, err2)
 	}
 	small := smallReaddirnames(file1, len(all)+100, t);	// +100 in case we screw up
 	for i, n := range all {
 		if small[i] != n {
-			t.Errorf("small read %q %q mismatch: %v", small[i], n);
+			t.Errorf("small read %q %q mismatch: %v", small[i], n)
 		}
 	}
 }
@@ -213,27 +213,27 @@ func TestHardLink(t *testing.T) {
 	Remove(from);	// Just in case.
 	file, err := Open(to, O_CREAT|O_WRONLY, 0666);
 	if err != nil {
-		t.Fatalf("open %q failed: %v", to, err);
+		t.Fatalf("open %q failed: %v", to, err)
 	}
 	defer Remove(to);
 	if err = file.Close(); err != nil {
-		t.Errorf("close %q failed: %v", to, err);
+		t.Errorf("close %q failed: %v", to, err)
 	}
 	err = Link(to, from);
 	if err != nil {
-		t.Fatalf("link %q, %q failed: %v", to, from, err);
+		t.Fatalf("link %q, %q failed: %v", to, from, err)
 	}
 	defer Remove(from);
 	tostat, err := Stat(to);
 	if err != nil {
-		t.Fatalf("stat %q failed: %v", to, err);
+		t.Fatalf("stat %q failed: %v", to, err)
 	}
 	fromstat, err := Stat(from);
 	if err != nil {
-		t.Fatalf("stat %q failed: %v", from, err);
+		t.Fatalf("stat %q failed: %v", from, err)
 	}
 	if tostat.Dev != fromstat.Dev || tostat.Ino != fromstat.Ino {
-		t.Errorf("link %q, %q did not create hard link", to, from);
+		t.Errorf("link %q, %q did not create hard link", to, from)
 	}
 }
 
@@ -242,55 +242,55 @@ func TestSymLink(t *testing.T) {
 	Remove(from);	// Just in case.
 	file, err := Open(to, O_CREAT|O_WRONLY, 0666);
 	if err != nil {
-		t.Fatalf("open %q failed: %v", to, err);
+		t.Fatalf("open %q failed: %v", to, err)
 	}
 	defer Remove(to);
 	if err = file.Close(); err != nil {
-		t.Errorf("close %q failed: %v", to, err);
+		t.Errorf("close %q failed: %v", to, err)
 	}
 	err = Symlink(to, from);
 	if err != nil {
-		t.Fatalf("symlink %q, %q failed: %v", to, from, err);
+		t.Fatalf("symlink %q, %q failed: %v", to, from, err)
 	}
 	defer Remove(from);
 	tostat, err := Stat(to);
 	if err != nil {
-		t.Fatalf("stat %q failed: %v", to, err);
+		t.Fatalf("stat %q failed: %v", to, err)
 	}
 	if tostat.FollowedSymlink {
-		t.Fatalf("stat %q claims to have followed a symlink", to);
+		t.Fatalf("stat %q claims to have followed a symlink", to)
 	}
 	fromstat, err := Stat(from);
 	if err != nil {
-		t.Fatalf("stat %q failed: %v", from, err);
+		t.Fatalf("stat %q failed: %v", from, err)
 	}
 	if tostat.Dev != fromstat.Dev || tostat.Ino != fromstat.Ino {
-		t.Errorf("symlink %q, %q did not create symlink", to, from);
+		t.Errorf("symlink %q, %q did not create symlink", to, from)
 	}
 	fromstat, err = Lstat(from);
 	if err != nil {
-		t.Fatalf("lstat %q failed: %v", from, err);
+		t.Fatalf("lstat %q failed: %v", from, err)
 	}
 	if !fromstat.IsSymlink() {
-		t.Fatalf("symlink %q, %q did not create symlink", to, from);
+		t.Fatalf("symlink %q, %q did not create symlink", to, from)
 	}
 	fromstat, err = Stat(from);
 	if err != nil {
-		t.Fatalf("stat %q failed: %v", from, err);
+		t.Fatalf("stat %q failed: %v", from, err)
 	}
 	if !fromstat.FollowedSymlink {
-		t.Fatalf("stat %q did not follow symlink");
+		t.Fatalf("stat %q did not follow symlink")
 	}
 	s, err := Readlink(from);
 	if err != nil {
-		t.Fatalf("readlink %q failed: %v", from, err);
+		t.Fatalf("readlink %q failed: %v", from, err)
 	}
 	if s != to {
-		t.Fatalf("after symlink %q != %q", s, to);
+		t.Fatalf("after symlink %q != %q", s, to)
 	}
 	file, err = Open(from, O_RDONLY, 0);
 	if err != nil {
-		t.Fatalf("open %q failed: %v", from, err);
+		t.Fatalf("open %q failed: %v", from, err)
 	}
 	file.Close();
 }
@@ -301,26 +301,26 @@ func TestLongSymlink(t *testing.T) {
 	from := "longsymlinktestfrom";
 	err := Symlink(s, from);
 	if err != nil {
-		t.Fatalf("symlink %q, %q failed: %v", s, from, err);
+		t.Fatalf("symlink %q, %q failed: %v", s, from, err)
 	}
 	defer Remove(from);
 	r, err := Readlink(from);
 	if err != nil {
-		t.Fatalf("readlink %q failed: %v", from, err);
+		t.Fatalf("readlink %q failed: %v", from, err)
 	}
 	if r != s {
-		t.Fatalf("after symlink %q != %q", r, s);
+		t.Fatalf("after symlink %q != %q", r, s)
 	}
 }
 
 func TestForkExec(t *testing.T) {
 	r, w, err := Pipe();
 	if err != nil {
-		t.Fatalf("Pipe: %v", err);
+		t.Fatalf("Pipe: %v", err)
 	}
 	pid, err := ForkExec("/bin/pwd", []string{"pwd"}, nil, "/", []*File{nil, w, Stderr});
 	if err != nil {
-		t.Fatalf("ForkExec: %v", err);
+		t.Fatalf("ForkExec: %v", err)
 	}
 	w.Close();
 
@@ -329,7 +329,7 @@ func TestForkExec(t *testing.T) {
 	output := b.String();
 	expect := "/\n";
 	if output != expect {
-		t.Errorf("exec /bin/pwd returned %q wanted %q", output, expect);
+		t.Errorf("exec /bin/pwd returned %q wanted %q", output, expect)
 	}
 	Wait(pid, 0);
 }
@@ -337,10 +337,10 @@ func TestForkExec(t *testing.T) {
 func checkMode(t *testing.T, path string, mode uint32) {
 	dir, err := Stat(path);
 	if err != nil {
-		t.Fatalf("Stat %q (looking for mode %#o): %s", path, mode, err);
+		t.Fatalf("Stat %q (looking for mode %#o): %s", path, mode, err)
 	}
 	if dir.Mode & 0777 != mode {
-		t.Errorf("Stat %q: mode %#o want %#o", path, dir.Mode, 0777);
+		t.Errorf("Stat %q: mode %#o want %#o", path, dir.Mode, 0777)
 	}
 }
 
@@ -349,16 +349,16 @@ func TestChmod(t *testing.T) {
 	const Path = "_obj/_TestChmod_";
 	fd, err := Open(Path, O_WRONLY|O_CREAT, 0666);
 	if err != nil {
-		t.Fatalf("create %s: %s", Path, err);
+		t.Fatalf("create %s: %s", Path, err)
 	}
 
 	if err = Chmod(Path, 0456); err != nil {
-		t.Fatalf("chmod %s 0456: %s", Path, err);
+		t.Fatalf("chmod %s 0456: %s", Path, err)
 	}
 	checkMode(t, Path, 0456);
 
 	if err = fd.Chmod(0123); err != nil {
-		t.Fatalf("fchmod %s 0123: %s", Path, err);
+		t.Fatalf("fchmod %s 0123: %s", Path, err)
 	}
 	checkMode(t, Path, 0123);
 
@@ -369,13 +369,13 @@ func TestChmod(t *testing.T) {
 func checkUidGid(t *testing.T, path string, uid, gid int) {
 	dir, err := Stat(path);
 	if err != nil {
-		t.Fatalf("Stat %q (looking for uid/gid %d/%d): %s", path, uid, gid, err);
+		t.Fatalf("Stat %q (looking for uid/gid %d/%d): %s", path, uid, gid, err)
 	}
 	if dir.Uid != uint32(uid) {
-		t.Errorf("Stat %q: uid %d want %d", path, dir.Uid, uid);
+		t.Errorf("Stat %q: uid %d want %d", path, dir.Uid, uid)
 	}
 	if dir.Gid != uint32(gid) {
-		t.Errorf("Stat %q: gid %d want %d", path, dir.Gid, gid);
+		t.Errorf("Stat %q: gid %d want %d", path, dir.Gid, gid)
 	}
 }
 
@@ -388,11 +388,11 @@ func TestChown(t *testing.T) {
 	const Path = "/tmp/_TestChown_";
 	fd, err := Open(Path, O_WRONLY|O_CREAT, 0666);
 	if err != nil {
-		t.Fatalf("create %s: %s", Path, err);
+		t.Fatalf("create %s: %s", Path, err)
 	}
 	dir, err := fd.Stat();
 	if err != nil {
-		t.Fatalf("fstat %s: %s", Path, err);
+		t.Fatalf("fstat %s: %s", Path, err)
 	}
 	defer fd.Close();
 	defer Remove(Path);
@@ -402,25 +402,25 @@ func TestChown(t *testing.T) {
 	gid := Getgid();
 	t.Log("gid:", gid);
 	if err = Chown(Path, -1, gid); err != nil {
-		t.Fatalf("chown %s -1 %d: %s", Path, gid, err);
+		t.Fatalf("chown %s -1 %d: %s", Path, gid, err)
 	}
 	checkUidGid(t, Path, int(dir.Uid), gid);
 
 	// Then try all the auxiliary groups.
 	groups, err := Getgroups();
 	if err != nil {
-		t.Fatalf("getgroups: %s", err);
+		t.Fatalf("getgroups: %s", err)
 	}
 	t.Log("groups: ", groups);
 	for _, g := range groups {
 		if err = Chown(Path, -1, g); err != nil {
-			t.Fatalf("chown %s -1 %d: %s", Path, g, err);
+			t.Fatalf("chown %s -1 %d: %s", Path, g, err)
 		}
 		checkUidGid(t, Path, int(dir.Uid), g);
 
 		// change back to gid to test fd.Chown
 		if err = fd.Chown(-1, gid); err != nil {
-			t.Fatalf("fchown %s -1 %d: %s", Path, gid, err);
+			t.Fatalf("fchown %s -1 %d: %s", Path, gid, err)
 		}
 		checkUidGid(t, Path, int(dir.Uid), gid);
 	}
@@ -429,10 +429,10 @@ func TestChown(t *testing.T) {
 func checkSize(t *testing.T, path string, size uint64) {
 	dir, err := Stat(path);
 	if err != nil {
-		t.Fatalf("Stat %q (looking for size %d): %s", path, size, err);
+		t.Fatalf("Stat %q (looking for size %d): %s", path, size, err)
 	}
 	if dir.Size != size {
-		t.Errorf("Stat %q: size %d want %d", path, dir.Size, size);
+		t.Errorf("Stat %q: size %d want %d", path, dir.Size, size)
 	}
 }
 
@@ -441,7 +441,7 @@ func TestTruncate(t *testing.T) {
 	const Path = "_obj/_TestTruncate_";
 	fd, err := Open(Path, O_WRONLY|O_CREAT, 0666);
 	if err != nil {
-		t.Fatalf("create %s: %s", Path, err);
+		t.Fatalf("create %s: %s", Path, err)
 	}
 
 	checkSize(t, Path, 0);
@@ -462,7 +462,7 @@ func TestTruncate(t *testing.T) {
 func TestChdirAndGetwd(t *testing.T) {
 	fd, err := Open(".", O_RDONLY, 0);
 	if err != nil {
-		t.Fatalf("Open .: %s", err);
+		t.Fatalf("Open .: %s", err)
 	}
 	// These are chosen carefully not to be symlinks on a Mac
 	// (unlike, say, /var, /etc, and /tmp).
@@ -470,7 +470,7 @@ func TestChdirAndGetwd(t *testing.T) {
 	for mode := 0; mode < 2; mode++ {
 		for _, d := range dirs {
 			if mode == 0 {
-				err = Chdir(d);
+				err = Chdir(d)
 			} else {
 				fd1, err := Open(d, O_RDONLY, 0);
 				if err != nil {
@@ -515,14 +515,14 @@ func TestTime(t *testing.T) {
 	// 365.24*86400 is an integer.
 	sec, nsec, err := Time();
 	if sec < (2009-1970)*36524*864 {
-		t.Errorf("Time() = %d, %d, %s; not plausible", sec, nsec, err);
+		t.Errorf("Time() = %d, %d, %s; not plausible", sec, nsec, err)
 	}
 }
 
 func TestSeek(t *testing.T) {
 	f, err := Open("_obj/seektest", O_CREAT|O_RDWR|O_TRUNC, 0666);
 	if err != nil {
-		t.Fatalf("open _obj/seektest: %s", err);
+		t.Fatalf("open _obj/seektest: %s", err)
 	}
 
 	const data = "hello, world\n";
@@ -546,7 +546,7 @@ func TestSeek(t *testing.T) {
 	for i, tt := range tests {
 		off, err := f.Seek(tt.in, tt.whence);
 		if off != tt.out || err != nil {
-			t.Errorf("#%d: Seek(%v, %v) = %v, %v want %v, nil", i, tt.in, tt.whence, off, err, tt.out);
+			t.Errorf("#%d: Seek(%v, %v) = %v, %v want %v, nil", i, tt.in, tt.whence, off, err, tt.out)
 		}
 	}
 	f.Close();
@@ -585,7 +585,7 @@ func TestOpenError(t *testing.T) {
 			continue;
 		}
 		if s := err.String(); s != tt.error {
-			t.Errorf("Open(%q, %d) = _, %q; want %q", tt.path, tt.mode, s, tt.error);
+			t.Errorf("Open(%q, %d) = _, %q; want %q", tt.path, tt.mode, s, tt.error)
 		}
 	}
 }
@@ -594,11 +594,11 @@ func run(t *testing.T, cmd []string) string {
 	// Run /bin/hostname and collect output.
 	r, w, err := Pipe();
 	if err != nil {
-		t.Fatal(err);
+		t.Fatal(err)
 	}
 	pid, err := ForkExec("/bin/hostname", []string{"hostname"}, nil, "/", []*File{nil, w, Stderr});
 	if err != nil {
-		t.Fatal(err);
+		t.Fatal(err)
 	}
 	w.Close();
 
@@ -607,10 +607,10 @@ func run(t *testing.T, cmd []string) string {
 	Wait(pid, 0);
 	output := b.String();
 	if n := len(output); n > 0 && output[n-1] == '\n' {
-		output = output[0 : n-1];
+		output = output[0 : n-1]
 	}
 	if output == "" {
-		t.Fatalf("%v produced no output", cmd);
+		t.Fatalf("%v produced no output", cmd)
 	}
 
 	return output;
@@ -621,18 +621,18 @@ func TestHostname(t *testing.T) {
 	// Check internal Hostname() against the output of /bin/hostname.
 	hostname, err := Hostname();
 	if err != nil {
-		t.Fatalf("%v", err);
+		t.Fatalf("%v", err)
 	}
 	want := run(t, []string{"/bin/hostname"});
 	if hostname != want {
-		t.Errorf("Hostname() = %q, want %q", hostname, want);
+		t.Errorf("Hostname() = %q, want %q", hostname, want)
 	}
 }
 
 func TestReadAt(t *testing.T) {
 	f, err := Open("_obj/readtest", O_CREAT|O_RDWR|O_TRUNC, 0666);
 	if err != nil {
-		t.Fatalf("open _obj/readtest: %s", err);
+		t.Fatalf("open _obj/readtest: %s", err)
 	}
 	const data = "hello, world\n";
 	io.WriteString(f, data);
@@ -640,31 +640,31 @@ func TestReadAt(t *testing.T) {
 	b := make([]byte, 5);
 	n, err := f.ReadAt(b, 7);
 	if err != nil || n != len(b) {
-		t.Fatalf("ReadAt 7: %d, %r", n, err);
+		t.Fatalf("ReadAt 7: %d, %r", n, err)
 	}
 	if string(b) != "world" {
-		t.Fatalf("ReadAt 7: have %q want %q", string(b), "world");
+		t.Fatalf("ReadAt 7: have %q want %q", string(b), "world")
 	}
 }
 
 func TestWriteAt(t *testing.T) {
 	f, err := Open("_obj/writetest", O_CREAT|O_RDWR|O_TRUNC, 0666);
 	if err != nil {
-		t.Fatalf("open _obj/writetest: %s", err);
+		t.Fatalf("open _obj/writetest: %s", err)
 	}
 	const data = "hello, world\n";
 	io.WriteString(f, data);
 
 	n, err := f.WriteAt(strings.Bytes("WORLD"), 7);
 	if err != nil || n != 5 {
-		t.Fatalf("WriteAt 7: %d, %v", n, err);
+		t.Fatalf("WriteAt 7: %d, %v", n, err)
 	}
 
 	b, err := io.ReadFile("_obj/writetest");
 	if err != nil {
-		t.Fatalf("ReadFile _obj/writetest: %v", err);
+		t.Fatalf("ReadFile _obj/writetest: %v", err)
 	}
 	if string(b) != "hello, WORLD\n" {
-		t.Fatalf("after write: have %q want %q", string(b), "hello, WORLD\n");
+		t.Fatalf("after write: have %q want %q", string(b), "hello, WORLD\n")
 	}
 }
diff --git a/src/pkg/os/path.go b/src/pkg/os/path.go
index de4b020d40..057b20b055 100644
--- a/src/pkg/os/path.go
+++ b/src/pkg/os/path.go
@@ -17,7 +17,7 @@ func MkdirAll(path string, perm int) Error {
 	dir, err := Lstat(path);
 	if err == nil {
 		if dir.IsDirectory() {
-			return nil;
+			return nil
 		}
 		return &PathError{"mkdir", path, ENOTDIR};
 	}
@@ -25,19 +25,19 @@ func MkdirAll(path string, perm int) Error {
 	// Doesn't already exist; make sure parent does.
 	i := len(path);
 	for i > 0 && path[i-1] == '/' {	// Skip trailing slashes.
-		i--;
+		i--
 	}
 
 	j := i;
 	for j > 0 && path[j-1] != '/' {	// Scan backward over element.
-		j--;
+		j--
 	}
 
 	if j > 0 {
 		// Create parent
 		err = MkdirAll(path[0 : j-1], perm);
 		if err != nil {
-			return err;
+			return err
 		}
 	}
 
@@ -48,7 +48,7 @@ func MkdirAll(path string, perm int) Error {
 		// double-checking that directory doesn't exist.
 		dir, err1 := Lstat(path);
 		if err1 == nil && dir.IsDirectory() {
-			return nil;
+			return nil
 		}
 		return err;
 	}
@@ -63,26 +63,26 @@ func RemoveAll(path string) Error {
 	// Simple case: if Remove works, we're done.
 	err := Remove(path);
 	if err == nil {
-		return nil;
+		return nil
 	}
 
 	// Otherwise, is this a directory we need to recurse into?
 	dir, serr := Lstat(path);
 	if serr != nil {
 		if serr, ok := serr.(*PathError); ok && serr.Error == ENOENT {
-			return nil;
+			return nil
 		}
 		return serr;
 	}
 	if !dir.IsDirectory() {
 		// Not a directory; return the error from Remove.
-		return err;
+		return err
 	}
 
 	// Directory.
 	fd, err := Open(path, O_RDONLY, 0);
 	if err != nil {
-		return err;
+		return err
 	}
 	defer fd.Close();
 
@@ -93,22 +93,22 @@ func RemoveAll(path string) Error {
 		for _, name := range names {
 			err1 := RemoveAll(path+"/"+name);
 			if err == nil {
-				err = err1;
+				err = err1
 			}
 		}
 		// If Readdirnames returned an error, use it.
 		if err == nil {
-			err = err1;
+			err = err1
 		}
 		if len(names) == 0 {
-			break;
+			break
 		}
 	}
 
 	// Remove directory.
 	err1 := Remove(path);
 	if err == nil {
-		err = err1;
+		err = err1
 	}
 	return err;
 }
diff --git a/src/pkg/os/path_test.go b/src/pkg/os/path_test.go
index 61cba30ee8..2dce2c5973 100644
--- a/src/pkg/os/path_test.go
+++ b/src/pkg/os/path_test.go
@@ -15,47 +15,47 @@ func TestMkdirAll(t *testing.T) {
 	path := "_obj/_TestMkdirAll_/dir/./dir2";
 	err := MkdirAll(path, 0777);
 	if err != nil {
-		t.Fatalf("MkdirAll %q: %s", path, err);
+		t.Fatalf("MkdirAll %q: %s", path, err)
 	}
 
 	// Already exists, should succeed.
 	err = MkdirAll(path, 0777);
 	if err != nil {
-		t.Fatalf("MkdirAll %q (second time): %s", path, err);
+		t.Fatalf("MkdirAll %q (second time): %s", path, err)
 	}
 
 	// Make file.
 	fpath := path+"/file";
 	_, err = Open(fpath, O_WRONLY|O_CREAT, 0666);
 	if err != nil {
-		t.Fatalf("create %q: %s", fpath, err);
+		t.Fatalf("create %q: %s", fpath, err)
 	}
 
 	// Can't make directory named after file.
 	err = MkdirAll(fpath, 0777);
 	if err == nil {
-		t.Fatalf("MkdirAll %q: no error");
+		t.Fatalf("MkdirAll %q: no error")
 	}
 	perr, ok := err.(*PathError);
 	if !ok {
-		t.Fatalf("MkdirAll %q returned %T, not *PathError", fpath, err);
+		t.Fatalf("MkdirAll %q returned %T, not *PathError", fpath, err)
 	}
 	if perr.Path != fpath {
-		t.Fatalf("MkdirAll %q returned wrong error path: %q not %q", fpath, perr.Path, fpath);
+		t.Fatalf("MkdirAll %q returned wrong error path: %q not %q", fpath, perr.Path, fpath)
 	}
 
 	// Can't make subdirectory of file.
 	ffpath := fpath + "/subdir";
 	err = MkdirAll(ffpath, 0777);
 	if err == nil {
-		t.Fatalf("MkdirAll %q: no error");
+		t.Fatalf("MkdirAll %q: no error")
 	}
 	perr, ok = err.(*PathError);
 	if !ok {
-		t.Fatalf("MkdirAll %q returned %T, not *PathError", ffpath, err);
+		t.Fatalf("MkdirAll %q returned %T, not *PathError", ffpath, err)
 	}
 	if perr.Path != fpath {
-		t.Fatalf("MkdirAll %q returned wrong error path: %q not %q", ffpath, perr.Path, fpath);
+		t.Fatalf("MkdirAll %q returned wrong error path: %q not %q", ffpath, perr.Path, fpath)
 	}
 
 	RemoveAll("_obj/_TestMkdirAll_");
@@ -69,82 +69,82 @@ func TestRemoveAll(t *testing.T) {
 
 	// Make directory with 1 file and remove.
 	if err := MkdirAll(path, 0777); err != nil {
-		t.Fatalf("MkdirAll %q: %s", path, err);
+		t.Fatalf("MkdirAll %q: %s", path, err)
 	}
 	fd, err := Open(fpath, O_WRONLY|O_CREAT, 0666);
 	if err != nil {
-		t.Fatalf("create %q: %s", fpath, err);
+		t.Fatalf("create %q: %s", fpath, err)
 	}
 	fd.Close();
 	if err = RemoveAll(path); err != nil {
-		t.Fatalf("RemoveAll %q (first): %s", path, err);
+		t.Fatalf("RemoveAll %q (first): %s", path, err)
 	}
 	if _, err := Lstat(path); err == nil {
-		t.Fatalf("Lstat %q succeeded after RemoveAll (first)", path);
+		t.Fatalf("Lstat %q succeeded after RemoveAll (first)", path)
 	}
 
 	// Make directory with file and subdirectory and remove.
 	if err = MkdirAll(dpath, 0777); err != nil {
-		t.Fatalf("MkdirAll %q: %s", dpath, err);
+		t.Fatalf("MkdirAll %q: %s", dpath, err)
 	}
 	fd, err = Open(fpath, O_WRONLY|O_CREAT, 0666);
 	if err != nil {
-		t.Fatalf("create %q: %s", fpath, err);
+		t.Fatalf("create %q: %s", fpath, err)
 	}
 	fd.Close();
 	fd, err = Open(dpath+"/file", O_WRONLY|O_CREAT, 0666);
 	if err != nil {
-		t.Fatalf("create %q: %s", fpath, err);
+		t.Fatalf("create %q: %s", fpath, err)
 	}
 	fd.Close();
 	if err = RemoveAll(path); err != nil {
-		t.Fatalf("RemoveAll %q (second): %s", path, err);
+		t.Fatalf("RemoveAll %q (second): %s", path, err)
 	}
 	if _, err := Lstat(path); err == nil {
-		t.Fatalf("Lstat %q succeeded after RemoveAll (second)", path);
+		t.Fatalf("Lstat %q succeeded after RemoveAll (second)", path)
 	}
 
 	// Make directory with file and subdirectory and trigger error.
 	if err = MkdirAll(dpath, 0777); err != nil {
-		t.Fatalf("MkdirAll %q: %s", dpath, err);
+		t.Fatalf("MkdirAll %q: %s", dpath, err)
 	}
 
 	for _, s := range []string{fpath, dpath+"/file1", path+"/zzz"} {
 		fd, err = Open(s, O_WRONLY|O_CREAT, 0666);
 		if err != nil {
-			t.Fatalf("create %q: %s", s, err);
+			t.Fatalf("create %q: %s", s, err)
 		}
 		fd.Close();
 	}
 	if err = Chmod(dpath, 0); err != nil {
-		t.Fatalf("Chmod %q 0: %s", dpath, err);
+		t.Fatalf("Chmod %q 0: %s", dpath, err)
 	}
 	if err = RemoveAll(path); err == nil {
 		_, err := Lstat(path);
 		if err == nil {
-			t.Errorf("Can lstat %q after supposed RemoveAll", path);
+			t.Errorf("Can lstat %q after supposed RemoveAll", path)
 		}
 		t.Fatalf("RemoveAll %q succeeded with chmod 0 subdirectory", path, err);
 	}
 	perr, ok := err.(*PathError);
 	if !ok {
-		t.Fatalf("RemoveAll %q returned %T not *PathError", path, err);
+		t.Fatalf("RemoveAll %q returned %T not *PathError", path, err)
 	}
 	if perr.Path != dpath {
-		t.Fatalf("RemoveAll %q failed at %q not %q", path, perr.Path, dpath);
+		t.Fatalf("RemoveAll %q failed at %q not %q", path, perr.Path, dpath)
 	}
 	if err = Chmod(dpath, 0777); err != nil {
-		t.Fatalf("Chmod %q 0777: %s", dpath, err);
+		t.Fatalf("Chmod %q 0777: %s", dpath, err)
 	}
 	for _, s := range []string{fpath, path+"/zzz"} {
 		if _, err := Lstat(s); err == nil {
-			t.Fatalf("Lstat %q succeeded after partial RemoveAll", s);
+			t.Fatalf("Lstat %q succeeded after partial RemoveAll", s)
 		}
 	}
 	if err = RemoveAll(path); err != nil {
-		t.Fatalf("RemoveAll %q after partial RemoveAll: %s", path, err);
+		t.Fatalf("RemoveAll %q after partial RemoveAll: %s", path, err)
 	}
 	if _, err := Lstat(path); err == nil {
-		t.Fatalf("Lstat %q succeeded after RemoveAll (final)", path);
+		t.Fatalf("Lstat %q succeeded after RemoveAll (final)", path)
 	}
 }
diff --git a/src/pkg/os/stat_darwin.go b/src/pkg/os/stat_darwin.go
index 6ba402fa6c..d712ee8e2a 100644
--- a/src/pkg/os/stat_darwin.go
+++ b/src/pkg/os/stat_darwin.go
@@ -7,7 +7,7 @@ package os
 import "syscall"
 
 func isSymlink(stat *syscall.Stat_t) bool {
-	return stat.Mode & syscall.S_IFMT == syscall.S_IFLNK;
+	return stat.Mode & syscall.S_IFMT == syscall.S_IFLNK
 }
 
 func dirFromStat(name string, dir *Dir, lstat, stat *syscall.Stat_t) *Dir {
@@ -32,7 +32,7 @@ func dirFromStat(name string, dir *Dir, lstat, stat *syscall.Stat_t) *Dir {
 	}
 	dir.Name = name;
 	if isSymlink(lstat) && !isSymlink(stat) {
-		dir.FollowedSymlink = true;
+		dir.FollowedSymlink = true
 	}
 	return dir;
 }
diff --git a/src/pkg/os/stat_linux.go b/src/pkg/os/stat_linux.go
index fe4193a5b8..c63697df72 100644
--- a/src/pkg/os/stat_linux.go
+++ b/src/pkg/os/stat_linux.go
@@ -7,7 +7,7 @@ package os
 import "syscall"
 
 func isSymlink(stat *syscall.Stat_t) bool {
-	return stat.Mode & syscall.S_IFMT == syscall.S_IFLNK;
+	return stat.Mode & syscall.S_IFMT == syscall.S_IFLNK
 }
 
 func dirFromStat(name string, dir *Dir, lstat, stat *syscall.Stat_t) *Dir {
@@ -32,7 +32,7 @@ func dirFromStat(name string, dir *Dir, lstat, stat *syscall.Stat_t) *Dir {
 	}
 	dir.Name = name;
 	if isSymlink(lstat) && !isSymlink(stat) {
-		dir.FollowedSymlink = true;
+		dir.FollowedSymlink = true
 	}
 	return dir;
 }
diff --git a/src/pkg/os/stat_nacl.go b/src/pkg/os/stat_nacl.go
index 5295106df7..a5007d08cd 100644
--- a/src/pkg/os/stat_nacl.go
+++ b/src/pkg/os/stat_nacl.go
@@ -7,7 +7,7 @@ package os
 import "syscall"
 
 func isSymlink(stat *syscall.Stat_t) bool {
-	return stat.Mode & syscall.S_IFMT == syscall.S_IFLNK;
+	return stat.Mode & syscall.S_IFMT == syscall.S_IFLNK
 }
 
 func dirFromStat(name string, dir *Dir, lstat, stat *syscall.Stat_t) *Dir {
@@ -32,7 +32,7 @@ func dirFromStat(name string, dir *Dir, lstat, stat *syscall.Stat_t) *Dir {
 	}
 	dir.Name = name;
 	if isSymlink(lstat) && !isSymlink(stat) {
-		dir.FollowedSymlink = true;
+		dir.FollowedSymlink = true
 	}
 	return dir;
 }
diff --git a/src/pkg/os/sys_darwin.go b/src/pkg/os/sys_darwin.go
index fb57f1733b..c92845578b 100644
--- a/src/pkg/os/sys_darwin.go
+++ b/src/pkg/os/sys_darwin.go
@@ -12,7 +12,7 @@ func Hostname() (name string, err Error) {
 	var errno int;
 	name, errno = syscall.Sysctl("kern.hostname");
 	if errno != 0 {
-		return "", NewSyscallError("sysctl kern.hostname", errno);
+		return "", NewSyscallError("sysctl kern.hostname", errno)
 	}
 	return name, nil;
 }
diff --git a/src/pkg/os/sys_linux.go b/src/pkg/os/sys_linux.go
index 12a99dff32..896be164de 100644
--- a/src/pkg/os/sys_linux.go
+++ b/src/pkg/os/sys_linux.go
@@ -11,18 +11,18 @@ package os
 func Hostname() (name string, err Error) {
 	f, err := Open("/proc/sys/kernel/hostname", O_RDONLY, 0);
 	if err != nil {
-		return "", err;
+		return "", err
 	}
 	defer f.Close();
 
 	var buf [512]byte;	// Enough for a DNS name.
 	n, err := f.Read(&buf);
 	if err != nil {
-		return "", err;
+		return "", err
 	}
 
 	if n > 0 && buf[n-1] == '\n' {
-		n--;
+		n--
 	}
 	return string(buf[0:n]), nil;
 }
diff --git a/src/pkg/os/time.go b/src/pkg/os/time.go
index 21d4df7333..a82a39382e 100644
--- a/src/pkg/os/time.go
+++ b/src/pkg/os/time.go
@@ -14,7 +14,7 @@ import "syscall"
 func Time() (sec int64, nsec int64, err Error) {
 	var tv syscall.Timeval;
 	if errno := syscall.Gettimeofday(&tv); errno != 0 {
-		return 0, 0, NewSyscallError("gettimeofday", errno);
+		return 0, 0, NewSyscallError("gettimeofday", errno)
 	}
 	return int64(tv.Sec), int64(tv.Usec)*1000, err;
 }
diff --git a/src/pkg/patch/apply.go b/src/pkg/patch/apply.go
index 1541330286..fc82f93cc8 100644
--- a/src/pkg/patch/apply.go
+++ b/src/pkg/patch/apply.go
@@ -40,12 +40,12 @@ func (set *Set) Apply(readFile func(string) ([]byte, os.Error)) ([]Op, os.Error)
 			if f.Src != "" {
 				old, err = readFile(f.Src);
 				if err != nil {
-					return nil, &os.PathError{string(f.Verb), f.Src, err};
+					return nil, &os.PathError{string(f.Verb), f.Src, err}
 				}
 			}
 			o.Data, err = f.Diff.Apply(old);
 			if err != nil {
-				return nil, &os.PathError{string(f.Verb), f.Src, err};
+				return nil, &os.PathError{string(f.Verb), f.Src, err}
 			}
 		}
 	}
diff --git a/src/pkg/patch/git.go b/src/pkg/patch/git.go
index fd03f4a92b..f9335cc45b 100644
--- a/src/pkg/patch/git.go
+++ b/src/pkg/patch/git.go
@@ -17,7 +17,7 @@ import (
 func gitSHA1(data []byte) []byte {
 	if len(data) == 0 {
 		// special case: 0 length is all zeros sum
-		return make([]byte, 20);
+		return make([]byte, 20)
 	}
 	h := sha1.New();
 	fmt.Fprintf(h, "blob %d\x00", len(data));
@@ -36,7 +36,7 @@ type GITBinaryLiteral struct {
 // Apply implements the Diff interface's Apply method.
 func (d *GITBinaryLiteral) Apply(old []byte) ([]byte, os.Error) {
 	if sum := gitSHA1(old); !bytes.HasPrefix(sum, d.OldSHA1) {
-		return nil, ErrPatchFailure;
+		return nil, ErrPatchFailure
 	}
 	return d.New, nil;
 }
@@ -44,11 +44,11 @@ func (d *GITBinaryLiteral) Apply(old []byte) ([]byte, os.Error) {
 func unhex(c byte) uint8 {
 	switch {
 	case '0' <= c && c <= '9':
-		return c-'0';
+		return c-'0'
 	case 'a' <= c && c <= 'f':
-		return c-'a'+10;
+		return c-'a'+10
 	case 'A' <= c && c <= 'F':
-		return c-'A'+10;
+		return c-'A'+10
 	}
 	return 255;
 }
@@ -56,12 +56,12 @@ func unhex(c byte) uint8 {
 func getHex(s []byte) (data []byte, rest []byte) {
 	n := 0;
 	for n < len(s) && unhex(s[n]) != 255 {
-		n++;
+		n++
 	}
 	n &^= 1;	// Only take an even number of hex digits.
 	data = make([]byte, n/2);
 	for i := range data {
-		data[i] = unhex(s[2*i])<<4 | unhex(s[2*i + 1]);
+		data[i] = unhex(s[2*i])<<4 | unhex(s[2*i + 1])
 	}
 	rest = s[n:len(s)];
 	return;
@@ -79,7 +79,7 @@ func ParseGITBinary(raw []byte) (Diff, os.Error) {
 		if s, ok := skip(first, "index "); ok {
 			oldSHA1, s = getHex(s);
 			if s, ok = skip(s, ".."); !ok {
-				continue;
+				continue
 			}
 			newSHA1, s = getHex(s);
 			continue;
@@ -93,28 +93,28 @@ func ParseGITBinary(raw []byte) (Diff, os.Error) {
 			d := git85.NewDecoder(bytes.NewBuffer(raw));
 			z, err := zlib.NewInflater(d);
 			if err != nil {
-				return nil, err;
+				return nil, err
 			}
 			defer z.Close();
 			if _, err = io.ReadFull(z, data); err != nil {
 				if err == os.EOF {
-					err = io.ErrUnexpectedEOF;
+					err = io.ErrUnexpectedEOF
 				}
 				return nil, err;
 			}
 			var buf [1]byte;
 			m, err := z.Read(&buf);
 			if m != 0 || err != os.EOF {
-				return nil, os.NewError("GIT binary literal longer than expected");
+				return nil, os.NewError("GIT binary literal longer than expected")
 			}
 
 			if sum := gitSHA1(data); !bytes.HasPrefix(sum, newSHA1) {
-				return nil, os.NewError("GIT binary literal SHA1 mismatch");
+				return nil, os.NewError("GIT binary literal SHA1 mismatch")
 			}
 			return &GITBinaryLiteral{oldSHA1, data}, nil;
 		}
 		if !sawBinary {
-			return nil, os.NewError("unexpected GIT patch header: " + string(first));
+			return nil, os.NewError("unexpected GIT patch header: " + string(first))
 		}
 	}
 	panic("unreachable");
diff --git a/src/pkg/patch/patch.go b/src/pkg/patch/patch.go
index e8ed627f7e..25f03fe610 100644
--- a/src/pkg/patch/patch.go
+++ b/src/pkg/patch/patch.go
@@ -57,7 +57,7 @@ var NoDiff Diff = noDiffType(0)
 type noDiffType int
 
 func (noDiffType) Apply(old []byte) ([]byte, os.Error) {
-	return old, nil;
+	return old, nil
 }
 
 // A SyntaxError represents a syntax error encountered while parsing a patch.
@@ -84,7 +84,7 @@ func Parse(text []byte) (*Set, os.Error) {
 	// First look for Index: lines.  If none, fall back on diff lines.
 	text, files := sections(text, "Index: ");
 	if len(files) == 0 {
-		text, files = sections(text, "diff ");
+		text, files = sections(text, "diff ")
 	}
 
 	set := &Set{string(text), make([]*File, len(files))};
@@ -114,7 +114,7 @@ func Parse(text []byte) (*Set, os.Error) {
 	HaveName:
 		p.Dst = path.Clean(p.Dst);
 		if strings.HasPrefix(p.Dst, "../") || strings.HasPrefix(p.Dst, "/") {
-			return nil, SyntaxError("invalid path: " + p.Dst);
+			return nil, SyntaxError("invalid path: " + p.Dst)
 		}
 
 		// Parse header lines giving file information:
@@ -180,29 +180,29 @@ func Parse(text []byte) (*Set, os.Error) {
 				// Hg prints
 				//	Binary file foo has changed
 				// when deleting a binary file.
-				continue;
+				continue
 			}
 			if s, ok := skip(l, "RCS file: "); ok && len(s) > 0 {
 				// CVS prints
 				//	RCS file: /cvs/plan9/bin/yesterday,v
 				//	retrieving revision 1.1
 				// for each file.
-				continue;
+				continue
 			}
 			if s, ok := skip(l, "retrieving revision "); ok && len(s) > 0 {
 				// CVS prints
 				//	RCS file: /cvs/plan9/bin/yesterday,v
 				//	retrieving revision 1.1
 				// for each file.
-				continue;
+				continue
 			}
 			if hasPrefix(l, "===") || hasPrefix(l, "---") || hasPrefix(l, "+++") || hasPrefix(l, "diff ") {
-				continue;
+				continue
 			}
 			if hasPrefix(l, "@@ -") {
 				diff, err := ParseTextDiff(oldraw);
 				if err != nil {
-					return nil, err;
+					return nil, err
 				}
 				p.Diff = diff;
 				break;
@@ -210,7 +210,7 @@ func Parse(text []byte) (*Set, os.Error) {
 			if hasPrefix(l, "index ") || hasPrefix(l, "GIT binary patch") {
 				diff, err := ParseGITBinary(oldraw);
 				if err != nil {
-					return nil, err;
+					return nil, err
 				}
 				p.Diff = diff;
 				break;
@@ -218,10 +218,10 @@ func Parse(text []byte) (*Set, os.Error) {
 			return nil, SyntaxError("unexpected patch header line: " + string(l));
 		}
 		if p.Diff == nil {
-			p.Diff = NoDiff;
+			p.Diff = NoDiff
 		}
 		if p.Verb == Edit {
-			p.Src = p.Dst;
+			p.Src = p.Dst
 		}
 	}
 
@@ -254,11 +254,11 @@ func sections(text []byte, prefix string) ([]byte, [][]byte) {
 	n := 0;
 	for b := text; ; {
 		if hasPrefix(b, prefix) {
-			n++;
+			n++
 		}
 		nl := bytes.Index(b, newline);
 		if nl < 0 {
-			break;
+			break
 		}
 		b = b[nl+1 : len(b)];
 	}
@@ -285,7 +285,7 @@ func sections(text []byte, prefix string) ([]byte, [][]byte) {
 // s with that prefix removed and ok == true.
 func skip(s []byte, t string) (ss []byte, ok bool) {
 	if len(s) < len(t) || string(s[0:len(t)]) != t {
-		return nil, false;
+		return nil, false
 	}
 	return s[len(t):len(s)], true;
 }
@@ -296,14 +296,14 @@ func skip(s []byte, t string) (ss []byte, ok bool) {
 // prefix and the digits removed.
 func atoi(s []byte, t string, base int) (n int, ss []byte, ok bool) {
 	if s, ok = skip(s, t); !ok {
-		return;
+		return
 	}
 	var i int;
 	for i = 0; i < len(s) && '0' <= s[i] && s[i] <= byte('0'+base-1); i++ {
-		n = n*base + int(s[i]-'0');
+		n = n*base + int(s[i]-'0')
 	}
 	if i == 0 {
-		return;
+		return
 	}
 	return n, s[i:len(s)], true;
 }
diff --git a/src/pkg/patch/patch_test.go b/src/pkg/patch/patch_test.go
index b4c64b31b7..dd610eed67 100644
--- a/src/pkg/patch/patch_test.go
+++ b/src/pkg/patch/patch_test.go
@@ -34,7 +34,7 @@ func TestFileApply(t *testing.T) {
 			continue;
 		}
 		if s := string(new); s != test.out {
-			t.Errorf("#%d:\n--- have\n%s--- want\n%s", i, s, test.out);
+			t.Errorf("#%d:\n--- have\n%s--- want\n%s", i, s, test.out)
 		}
 	}
 }
diff --git a/src/pkg/patch/textdiff.go b/src/pkg/patch/textdiff.go
index db85276824..ddf3b26066 100644
--- a/src/pkg/patch/textdiff.go
+++ b/src/pkg/patch/textdiff.go
@@ -32,32 +32,32 @@ func ParseTextDiff(raw []byte) (TextDiff, os.Error) {
 		s := chunkHeader;
 		if oldLine, s, ok = atoi(s, "@@ -", 10); !ok {
 		ErrChunkHdr:
-			return nil, SyntaxError("unexpected chunk header line: " + string(chunkHeader));
+			return nil, SyntaxError("unexpected chunk header line: " + string(chunkHeader))
 		}
 		if len(s) == 0 || s[0] != ',' {
-			oldCount = 1;
+			oldCount = 1
 		} else if oldCount, s, ok = atoi(s, ",", 10); !ok {
-			goto ErrChunkHdr;
+			goto ErrChunkHdr
 		}
 		if newLine, s, ok = atoi(s, " +", 10); !ok {
-			goto ErrChunkHdr;
+			goto ErrChunkHdr
 		}
 		if len(s) == 0 || s[0] != ',' {
-			newCount = 1;
+			newCount = 1
 		} else if newCount, s, ok = atoi(s, ",", 10); !ok {
-			goto ErrChunkHdr;
+			goto ErrChunkHdr
 		}
 		if !hasPrefix(s, " @@") {
-			goto ErrChunkHdr;
+			goto ErrChunkHdr
 		}
 
 		// Special case: for created or deleted files, the empty half
 		// is given as starting at line 0.  Translate to line 1.
 		if oldCount == 0 && oldLine == 0 {
-			oldLine = 1;
+			oldLine = 1
 		}
 		if newCount == 0 && newLine == 0 {
-			newLine = 1;
+			newLine = 1
 		}
 
 		// Count lines in text
@@ -68,18 +68,18 @@ func ParseTextDiff(raw []byte) (TextDiff, os.Error) {
 		for _, l := range chunk {
 			if nold == oldCount && nnew == newCount && (len(l) == 0 || l[0] != '\\') {
 				if len(bytes.TrimSpace(l)) != 0 {
-					return nil, SyntaxError("too many chunk lines");
+					return nil, SyntaxError("too many chunk lines")
 				}
 				continue;
 			}
 			if len(l) == 0 {
-				return nil, SyntaxError("empty chunk line");
+				return nil, SyntaxError("empty chunk line")
 			}
 			switch l[0] {
 			case '+':
-				nnew++;
+				nnew++
 			case '-':
-				nold++;
+				nold++
 			case ' ':
 				nnew++;
 				nold++;
@@ -87,30 +87,30 @@ func ParseTextDiff(raw []byte) (TextDiff, os.Error) {
 				if _, ok := skip(l, "\\ No newline at end of file"); ok {
 					switch lastch {
 					case '-':
-						dropOldNL = true;
+						dropOldNL = true
 					case '+':
-						dropNewNL = true;
+						dropNewNL = true
 					case ' ':
 						dropOldNL = true;
 						dropNewNL = true;
 					default:
-						return nil, SyntaxError("message `\\ No newline at end of file' out of context");
+						return nil, SyntaxError("message `\\ No newline at end of file' out of context")
 					}
 					break;
 				}
 				fallthrough;
 			default:
-				return nil, SyntaxError("unexpected chunk line: " + string(l));
+				return nil, SyntaxError("unexpected chunk line: " + string(l))
 			}
 			lastch = l[0];
 		}
 
 		// Does it match the header?
 		if nold != oldCount || nnew != newCount {
-			return nil, SyntaxError("chunk header does not match line count: " + string(chunkHeader));
+			return nil, SyntaxError("chunk header does not match line count: " + string(chunkHeader))
 		}
 		if oldLine+delta != newLine {
-			return nil, SyntaxError("chunk delta is out of sync with previous chunks");
+			return nil, SyntaxError("chunk delta is out of sync with previous chunks")
 		}
 		delta += nnew-nold;
 		c.Line = oldLine;
@@ -120,11 +120,11 @@ func ParseTextDiff(raw []byte) (TextDiff, os.Error) {
 		nnew = 0;
 		for _, l := range chunk {
 			if nold == oldCount && nnew == newCount {
-				break;
+				break
 			}
 			ch, l := l[0], l[1:len(l)];
 			if ch == '\\' {
-				continue;
+				continue
 			}
 			if ch != '+' {
 				old.Write(l);
@@ -138,10 +138,10 @@ func ParseTextDiff(raw []byte) (TextDiff, os.Error) {
 		c.Old = old.Bytes();
 		c.New = new.Bytes();
 		if dropOldNL {
-			c.Old = c.Old[0 : len(c.Old)-1];
+			c.Old = c.Old[0 : len(c.Old)-1]
 		}
 		if dropNewNL {
-			c.New = c.New[0 : len(c.New)-1];
+			c.New = c.New[0 : len(c.New)-1]
 		}
 	}
 	return diff, nil;
@@ -159,7 +159,7 @@ func (d TextDiff) Apply(data []byte) ([]byte, os.Error) {
 		var prefix []byte;
 		prefix, data, ok = getLine(data, c.Line - line);
 		if !ok || !bytes.HasPrefix(data, c.Old) {
-			return nil, ErrPatchFailure;
+			return nil, ErrPatchFailure
 		}
 		buf.Write(prefix);
 		data = data[len(c.Old):len(data)];
diff --git a/src/pkg/path/path.go b/src/pkg/path/path.go
index 3f4bf0fd56..b719057129 100644
--- a/src/pkg/path/path.go
+++ b/src/pkg/path/path.go
@@ -31,7 +31,7 @@ import (
 // http://plan9.bell-labs.com/sys/doc/lexnames.html
 func Clean(path string) string {
 	if path == "" {
-		return ".";
+		return "."
 	}
 
 	rooted := path[0] == '/';
@@ -45,17 +45,17 @@ func Clean(path string) string {
 	buf := strings.Bytes(path);
 	r, w, dotdot := 0, 0, 0;
 	if rooted {
-		r, w, dotdot = 1, 1, 1;
+		r, w, dotdot = 1, 1, 1
 	}
 
 	for r < n {
 		switch {
 		case path[r] == '/':
 			// empty path element
-			r++;
+			r++
 		case path[r] == '.' && (r+1 == n || path[r+1] == '/'):
 			// . element
-			r++;
+			r++
 		case path[r] == '.' && path[r+1] == '.' && (r+2 == n || path[r+2] == '/'):
 			// .. element: remove to last /
 			r += 2;
@@ -64,7 +64,7 @@ func Clean(path string) string {
 				// can backtrack
 				w--;
 				for w > dotdot && buf[w] != '/' {
-					w--;
+					w--
 				}
 			case !rooted:
 				// cannot backtrack, but not rooted, so append .. element.
@@ -109,7 +109,7 @@ func Clean(path string) string {
 func Split(path string) (dir, file string) {
 	for i := len(path)-1; i >= 0; i-- {
 		if path[i] == '/' {
-			return path[0 : i+1], path[i+1 : len(path)];
+			return path[0 : i+1], path[i+1 : len(path)]
 		}
 	}
 	return "", path;
@@ -119,7 +119,7 @@ func Split(path string) (dir, file string) {
 // slash if necessary.  If dir is empty, it returns file.
 func Join(dir, file string) string {
 	if dir == "" {
-		return file;
+		return file
 	}
 	return Clean(dir+"/"+file);
 }
@@ -131,7 +131,7 @@ func Join(dir, file string) string {
 func Ext(path string) string {
 	for i := len(path)-1; i >= 0 && path[i] != '/'; i-- {
 		if path[i] == '.' {
-			return path[i:len(path)];
+			return path[i:len(path)]
 		}
 	}
 	return "";
@@ -152,18 +152,18 @@ func walk(path string, d *os.Dir, v Visitor, errors chan<- os.Error) {
 	}
 
 	if !v.VisitDir(path, d) {
-		return;	// skip directory entries
+		return	// skip directory entries
 	}
 
 	list, err := io.ReadDir(path);
 	if err != nil {
 		if errors != nil {
-			errors <- err;
+			errors <- err
 		}
 	}
 
 	for _, e := range list {
-		walk(Join(path, e.Name), e, v, errors);
+		walk(Join(path, e.Name), e, v, errors)
 	}
 }
 
@@ -178,7 +178,7 @@ func Walk(root string, v Visitor, errors chan<- os.Error) {
 	d, err := os.Lstat(root);
 	if err != nil {
 		if errors != nil {
-			errors <- err;
+			errors <- err
 		}
 		return;	// can't progress
 	}
diff --git a/src/pkg/path/path_test.go b/src/pkg/path/path_test.go
index 396d6db7de..b5cc33f182 100644
--- a/src/pkg/path/path_test.go
+++ b/src/pkg/path/path_test.go
@@ -66,7 +66,7 @@ var cleantests = []CleanTest{
 func TestClean(t *testing.T) {
 	for _, test := range cleantests {
 		if s := Clean(test.path); s != test.clean {
-			t.Errorf("Clean(%q) = %q, want %q", test.path, s, test.clean);
+			t.Errorf("Clean(%q) = %q, want %q", test.path, s, test.clean)
 		}
 	}
 }
@@ -86,7 +86,7 @@ var splittests = []SplitTest{
 func TestSplit(t *testing.T) {
 	for _, test := range splittests {
 		if d, f := Split(test.path); d != test.dir || f != test.file {
-			t.Errorf("Split(%q) = %q, %q, want %q, %q", test.path, d, f, test.dir, test.file);
+			t.Errorf("Split(%q) = %q, %q, want %q, %q", test.path, d, f, test.dir, test.file)
 		}
 	}
 }
@@ -108,7 +108,7 @@ var jointests = []JoinTest{
 func TestJoin(t *testing.T) {
 	for _, test := range jointests {
 		if p := Join(test.dir, test.file); p != test.path {
-			t.Errorf("Join(%q, %q) = %q, want %q", test.dir, test.file, p, test.path);
+			t.Errorf("Join(%q, %q) = %q, want %q", test.dir, test.file, p, test.path)
 		}
 	}
 }
@@ -128,7 +128,7 @@ var exttests = []ExtTest{
 func TestExt(t *testing.T) {
 	for _, test := range exttests {
 		if x := Ext(test.path); x != test.ext {
-			t.Errorf("Ext(%q) = %q, want %q", test.path, x, test.ext);
+			t.Errorf("Ext(%q) = %q, want %q", test.path, x, test.ext)
 		}
 	}
 }
@@ -168,7 +168,7 @@ var tree = &Node{
 func walkTree(n *Node, path string, f func(path string, n *Node)) {
 	f(path, n);
 	for _, e := range n.entries {
-		walkTree(e, Join(path, e.name), f);
+		walkTree(e, Join(path, e.name), f)
 	}
 }
 
@@ -177,13 +177,13 @@ func makeTree(t *testing.T) {
 		if n.entries == nil {
 			fd, err := os.Open(path, os.O_CREAT, 0660);
 			if err != nil {
-				t.Errorf("makeTree: %v", err);
+				t.Errorf("makeTree: %v", err)
 			}
 			fd.Close();
 		} else {
-			os.Mkdir(path, 0770);
+			os.Mkdir(path, 0770)
 		}
-	});
+	})
 }
 
 func markTree(n *Node)	{ walkTree(n, "", func(path string, n *Node) { n.mark++ }) }
@@ -191,19 +191,19 @@ func markTree(n *Node)	{ walkTree(n, "", func(path string, n *Node) { n.mark++ }
 func checkMarks(t *testing.T) {
 	walkTree(tree, tree.name, func(path string, n *Node) {
 		if n.mark != 1 {
-			t.Errorf("node %s mark = %d; expected 1", path, n.mark);
+			t.Errorf("node %s mark = %d; expected 1", path, n.mark)
 		}
 		n.mark = 0;
-	});
+	})
 }
 
 // Assumes that each node name is unique. Good enough for a test.
 func mark(name string) {
 	walkTree(tree, tree.name, func(path string, n *Node) {
 		if n.name == name {
-			n.mark++;
+			n.mark++
 		}
-	});
+	})
 }
 
 type TestVisitor struct{}
@@ -214,7 +214,7 @@ func (v *TestVisitor) VisitDir(path string, d *os.Dir) bool {
 }
 
 func (v *TestVisitor) VisitFile(path string, d *os.Dir) {
-	mark(d.Name);
+	mark(d.Name)
 }
 
 func TestWalk(t *testing.T) {
@@ -229,7 +229,7 @@ func TestWalk(t *testing.T) {
 	errors := make(chan os.Error, 64);
 	Walk(tree.name, v, errors);
 	if err, ok := <-errors; ok {
-		t.Errorf("no error expected, found: s", err);
+		t.Errorf("no error expected, found: s", err)
 	}
 	checkMarks(t);
 
@@ -254,7 +254,7 @@ func TestWalk(t *testing.T) {
 		}
 	}
 	if err, ok := <-errors; ok {
-		t.Errorf("only two errors expected, found 3rd: %v", err);
+		t.Errorf("only two errors expected, found 3rd: %v", err)
 	}
 	// the inaccessible subtrees were marked manually
 	checkMarks(t);
@@ -263,6 +263,6 @@ func TestWalk(t *testing.T) {
 	os.Chmod(Join(tree.name, tree.entries[1].name), 0770);
 	os.Chmod(Join(tree.name, tree.entries[3].name), 0770);
 	if err := os.RemoveAll(tree.name); err != nil {
-		t.Errorf("removeTree: %v", err);
+		t.Errorf("removeTree: %v", err)
 	}
 }
diff --git a/src/pkg/rand/exp.go b/src/pkg/rand/exp.go
index a55f361741..b4b1f01bec 100644
--- a/src/pkg/rand/exp.go
+++ b/src/pkg/rand/exp.go
@@ -34,13 +34,13 @@ func (r *Rand) ExpFloat64() float64 {
 		i := j&0xFF;
 		x := float64(j)*float64(we[i]);
 		if j < ke[i] {
-			return x;
+			return x
 		}
 		if i == 0 {
-			return re - math.Log(r.Float64());
+			return re - math.Log(r.Float64())
 		}
 		if fe[i] + float32(r.Float64())*(fe[i-1]-fe[i]) < float32(math.Exp(-x)) {
-			return x;
+			return x
 		}
 	}
 	panic("unreachable");
diff --git a/src/pkg/rand/normal.go b/src/pkg/rand/normal.go
index a2504007e8..f4444dc68a 100644
--- a/src/pkg/rand/normal.go
+++ b/src/pkg/rand/normal.go
@@ -22,7 +22,7 @@ const (
 
 func absInt32(i int32) uint32 {
 	if i < 0 {
-		return uint32(-i);
+		return uint32(-i)
 	}
 	return uint32(i);
 }
@@ -42,7 +42,7 @@ func (r *Rand) NormFloat64() float64 {
 		x := float64(j)*float64(wn[i]);
 		if absInt32(j) < kn[i] {
 			// This case should be hit better than 99% of the time.
-			return x;
+			return x
 		}
 
 		if i == 0 {
@@ -51,16 +51,16 @@ func (r *Rand) NormFloat64() float64 {
 				x = -math.Log(r.Float64()) * (1.0/rn);
 				y := -math.Log(r.Float64());
 				if y+y >= x*x {
-					break;
+					break
 				}
 			}
 			if j > 0 {
-				return rn+x;
+				return rn+x
 			}
 			return -rn - x;
 		}
 		if fn[i] + float32(r.Float64())*(fn[i-1]-fn[i]) < float32(math.Exp(-.5 * x * x)) {
-			return x;
+			return x
 		}
 	}
 	panic("unreachable");
diff --git a/src/pkg/rand/rand.go b/src/pkg/rand/rand.go
index 65b14cd181..0d69490f36 100644
--- a/src/pkg/rand/rand.go
+++ b/src/pkg/rand/rand.go
@@ -49,12 +49,12 @@ func (r *Rand) Int() int {
 // Int63n returns, as an int64, a non-negative pseudo-random number in [0,n).
 func (r *Rand) Int63n(n int64) int64 {
 	if n <= 0 {
-		return 0;
+		return 0
 	}
 	max := int64((1<<63) - 1 - (1<<63)%uint64(n));
 	v := r.Int63();
 	for v > max {
-		v = r.Int63();
+		v = r.Int63()
 	}
 	return v%n;
 }
@@ -78,7 +78,7 @@ func (r *Rand) Float() float	{ return float(r.Float64()) }
 func (r *Rand) Perm(n int) []int {
 	m := make([]int, n);
 	for i := 0; i < n; i++ {
-		m[i] = i;
+		m[i] = i
 	}
 	for i := 0; i < n; i++ {
 		j := r.Intn(i+1);
diff --git a/src/pkg/rand/rand_test.go b/src/pkg/rand/rand_test.go
index 7a9980ecaf..3aea72acd0 100644
--- a/src/pkg/rand/rand_test.go
+++ b/src/pkg/rand/rand_test.go
@@ -24,7 +24,7 @@ type statsResults struct {
 
 func max(a, b float64) float64 {
 	if a > b {
-		return a;
+		return a
 	}
 	return b;
 }
@@ -32,7 +32,7 @@ func max(a, b float64) float64 {
 func nearEqual(a, b, closeEnough, maxError float64) bool {
 	absDiff := math.Fabs(a-b);
 	if absDiff < closeEnough {	// Necessary when one value is zero and one value is close to zero.
-		return true;
+		return true
 	}
 	return absDiff / max(math.Fabs(a), math.Fabs(b)) < maxError;
 }
@@ -59,12 +59,12 @@ func getStatsResults(samples []float64) *statsResults {
 	res := new(statsResults);
 	var sum float64;
 	for i := range samples {
-		sum += samples[i];
+		sum += samples[i]
 	}
 	res.mean = sum/float64(len(samples));
 	var devsum float64;
 	for i := range samples {
-		devsum += math.Pow(samples[i] - res.mean, 2);
+		devsum += math.Pow(samples[i] - res.mean, 2)
 	}
 	res.stddev = math.Sqrt(devsum/float64(len(samples)));
 	return res;
@@ -74,7 +74,7 @@ func checkSampleDistribution(t *testing.T, samples []float64, expected *statsRes
 	actual := getStatsResults(samples);
 	err := actual.checkSimilarDistribution(expected);
 	if err != nil {
-		t.Errorf(err.String());
+		t.Errorf(err.String())
 	}
 }
 
@@ -84,9 +84,9 @@ func checkSampleSliceDistributions(t *testing.T, samples []float64, nslices int,
 		low := i*chunk;
 		var high int;
 		if i == nslices-1 {
-			high = len(samples)-1;
+			high = len(samples)-1
 		} else {
-			high = (i+1)*chunk;
+			high = (i+1)*chunk
 		}
 		checkSampleDistribution(t, samples[low:high], expected);
 	}
@@ -100,7 +100,7 @@ func generateNormalSamples(nsamples int, mean, stddev float64, seed int64) []flo
 	r := New(NewSource(seed));
 	samples := make([]float64, nsamples);
 	for i := range samples {
-		samples[i] = r.NormFloat64() * stddev + mean;
+		samples[i] = r.NormFloat64() * stddev + mean
 	}
 	return samples;
 }
@@ -126,7 +126,7 @@ func testNormalDistribution(t *testing.T, nsamples int, mean, stddev float64, se
 
 func TestStandardNormalValues(t *testing.T) {
 	for _, seed := range testSeeds {
-		testNormalDistribution(t, numTestSamples, 0, 1, seed);
+		testNormalDistribution(t, numTestSamples, 0, 1, seed)
 	}
 }
 
@@ -134,7 +134,7 @@ func TestNonStandardNormalValues(t *testing.T) {
 	for sd := float64(0.5); sd < 1000; sd *= 2 {
 		for m := float64(0.5); m < 1000; m *= 2 {
 			for _, seed := range testSeeds {
-				testNormalDistribution(t, numTestSamples, m, sd, seed);
+				testNormalDistribution(t, numTestSamples, m, sd, seed)
 			}
 		}
 	}
@@ -148,7 +148,7 @@ func generateExponentialSamples(nsamples int, rate float64, seed int64) []float6
 	r := New(NewSource(seed));
 	samples := make([]float64, nsamples);
 	for i := range samples {
-		samples[i] = r.ExpFloat64() / rate;
+		samples[i] = r.ExpFloat64() / rate
 	}
 	return samples;
 }
@@ -177,14 +177,14 @@ func testExponentialDistribution(t *testing.T, nsamples int, rate float64, seed
 
 func TestStandardExponentialValues(t *testing.T) {
 	for _, seed := range testSeeds {
-		testExponentialDistribution(t, numTestSamples, 1, seed);
+		testExponentialDistribution(t, numTestSamples, 1, seed)
 	}
 }
 
 func TestNonStandardExponentialValues(t *testing.T) {
 	for rate := float64(0.05); rate < 10; rate *= 2 {
 		for _, seed := range testSeeds {
-			testExponentialDistribution(t, numTestSamples, rate, seed);
+			testExponentialDistribution(t, numTestSamples, rate, seed)
 		}
 	}
 }
@@ -257,13 +257,13 @@ func initExp() (testKe []uint32, testWe, testFe []float32) {
 func compareUint32Slices(s1, s2 []uint32) int {
 	if len(s1) != len(s2) {
 		if len(s1) > len(s2) {
-			return len(s2)+1;
+			return len(s2)+1
 		}
 		return len(s1)+1;
 	}
 	for i := range s1 {
 		if s1[i] != s2[i] {
-			return i;
+			return i
 		}
 	}
 	return -1;
@@ -275,13 +275,13 @@ func compareUint32Slices(s1, s2 []uint32) int {
 func compareFloat32Slices(s1, s2 []float32) int {
 	if len(s1) != len(s2) {
 		if len(s1) > len(s2) {
-			return len(s2)+1;
+			return len(s2)+1
 		}
 		return len(s1)+1;
 	}
 	for i := range s1 {
 		if !nearEqual(float64(s1[i]), float64(s2[i]), 0, 1e-7) {
-			return i;
+			return i
 		}
 	}
 	return -1;
@@ -290,25 +290,25 @@ func compareFloat32Slices(s1, s2 []float32) int {
 func TestNormTables(t *testing.T) {
 	testKn, testWn, testFn := initNorm();
 	if i := compareUint32Slices(kn[0:len(kn)], testKn); i >= 0 {
-		t.Errorf("kn disagrees at index %v; %v != %v\n", i, kn[i], testKn[i]);
+		t.Errorf("kn disagrees at index %v; %v != %v\n", i, kn[i], testKn[i])
 	}
 	if i := compareFloat32Slices(wn[0:len(wn)], testWn); i >= 0 {
-		t.Errorf("wn disagrees at index %v; %v != %v\n", i, wn[i], testWn[i]);
+		t.Errorf("wn disagrees at index %v; %v != %v\n", i, wn[i], testWn[i])
 	}
 	if i := compareFloat32Slices(fn[0:len(fn)], testFn); i >= 0 {
-		t.Errorf("fn disagrees at index %v; %v != %v\n", i, fn[i], testFn[i]);
+		t.Errorf("fn disagrees at index %v; %v != %v\n", i, fn[i], testFn[i])
 	}
 }
 
 func TestExpTables(t *testing.T) {
 	testKe, testWe, testFe := initExp();
 	if i := compareUint32Slices(ke[0:len(ke)], testKe); i >= 0 {
-		t.Errorf("ke disagrees at index %v; %v != %v\n", i, ke[i], testKe[i]);
+		t.Errorf("ke disagrees at index %v; %v != %v\n", i, ke[i], testKe[i])
 	}
 	if i := compareFloat32Slices(we[0:len(we)], testWe); i >= 0 {
-		t.Errorf("we disagrees at index %v; %v != %v\n", i, we[i], testWe[i]);
+		t.Errorf("we disagrees at index %v; %v != %v\n", i, we[i], testWe[i])
 	}
 	if i := compareFloat32Slices(fe[0:len(fe)], testFe); i >= 0 {
-		t.Errorf("fe disagrees at index %v; %v != %v\n", i, fe[i], testFe[i]);
+		t.Errorf("fe disagrees at index %v; %v != %v\n", i, fe[i], testFe[i])
 	}
 }
diff --git a/src/pkg/rand/rng.go b/src/pkg/rand/rng.go
index 10b4ac78fc..808e9238c7 100644
--- a/src/pkg/rand/rng.go
+++ b/src/pkg/rand/rng.go
@@ -194,7 +194,7 @@ func seedrand(x int32) int32 {
 	lo := x%_Q;
 	x = _A*lo - _R*hi;
 	if x < 0 {
-		x += _M;
+		x += _M
 	}
 	return x;
 }
@@ -206,10 +206,10 @@ func (rng *rngSource) Seed(seed int64) {
 
 	seed = seed%_M;
 	if seed < 0 {
-		seed += _M;
+		seed += _M
 	}
 	if seed == 0 {
-		seed = 89482311;
+		seed = 89482311
 	}
 
 	x := int32(seed);
@@ -232,12 +232,12 @@ func (rng *rngSource) Seed(seed int64) {
 func (rng *rngSource) Int63() int64 {
 	rng.tap--;
 	if rng.tap < 0 {
-		rng.tap += _LEN;
+		rng.tap += _LEN
 	}
 
 	rng.feed--;
 	if rng.feed < 0 {
-		rng.feed += _LEN;
+		rng.feed += _LEN
 	}
 
 	x := (rng.vec[rng.feed] + rng.vec[rng.tap])&_MASK;
diff --git a/src/pkg/reflect/all_test.go b/src/pkg/reflect/all_test.go
index f2e2f92bce..b0ed9e4118 100644
--- a/src/pkg/reflect/all_test.go
+++ b/src/pkg/reflect/all_test.go
@@ -29,7 +29,7 @@ func isDigit(c uint8) bool	{ return '0' <= c && c <= '9' }
 
 func assert(t *testing.T, s, want string) {
 	if s != want {
-		t.Errorf("have %#q want %#q", s, want);
+		t.Errorf("have %#q want %#q", s, want)
 	}
 }
 
@@ -202,13 +202,13 @@ var valueTests = []pair{
 func testType(t *testing.T, i int, typ Type, want string) {
 	s := typ.String();
 	if s != want {
-		t.Errorf("#%d: have %#q, want %#q", i, s, want);
+		t.Errorf("#%d: have %#q, want %#q", i, s, want)
 	}
 }
 
 func TestTypes(t *testing.T) {
 	for i, tt := range typeTests {
-		testType(t, i, NewValue(tt.i).(*StructValue).Field(0).Type(), tt.s);
+		testType(t, i, NewValue(tt.i).(*StructValue).Field(0).Type(), tt.s)
 	}
 }
 
@@ -217,39 +217,39 @@ func TestSet(t *testing.T) {
 		v := NewValue(tt.i);
 		switch v := v.(type) {
 		case *IntValue:
-			v.Set(132);
+			v.Set(132)
 		case *Int8Value:
-			v.Set(8);
+			v.Set(8)
 		case *Int16Value:
-			v.Set(16);
+			v.Set(16)
 		case *Int32Value:
-			v.Set(32);
+			v.Set(32)
 		case *Int64Value:
-			v.Set(64);
+			v.Set(64)
 		case *UintValue:
-			v.Set(132);
+			v.Set(132)
 		case *Uint8Value:
-			v.Set(8);
+			v.Set(8)
 		case *Uint16Value:
-			v.Set(16);
+			v.Set(16)
 		case *Uint32Value:
-			v.Set(32);
+			v.Set(32)
 		case *Uint64Value:
-			v.Set(64);
+			v.Set(64)
 		case *FloatValue:
-			v.Set(3200.0);
+			v.Set(3200.0)
 		case *Float32Value:
-			v.Set(32.1);
+			v.Set(32.1)
 		case *Float64Value:
-			v.Set(64.2);
+			v.Set(64.2)
 		case *StringValue:
-			v.Set("stringy cheese");
+			v.Set("stringy cheese")
 		case *BoolValue:
-			v.Set(true);
+			v.Set(true)
 		}
 		s := valueToString(v);
 		if s != tt.s {
-			t.Errorf("#%d: have %#q, want %#q", i, s, tt.s);
+			t.Errorf("#%d: have %#q, want %#q", i, s, tt.s)
 		}
 	}
 }
@@ -259,39 +259,39 @@ func TestSetValue(t *testing.T) {
 		v := NewValue(tt.i);
 		switch v := v.(type) {
 		case *IntValue:
-			v.SetValue(NewValue(int(132)));
+			v.SetValue(NewValue(int(132)))
 		case *Int8Value:
-			v.SetValue(NewValue(int8(8)));
+			v.SetValue(NewValue(int8(8)))
 		case *Int16Value:
-			v.SetValue(NewValue(int16(16)));
+			v.SetValue(NewValue(int16(16)))
 		case *Int32Value:
-			v.SetValue(NewValue(int32(32)));
+			v.SetValue(NewValue(int32(32)))
 		case *Int64Value:
-			v.SetValue(NewValue(int64(64)));
+			v.SetValue(NewValue(int64(64)))
 		case *UintValue:
-			v.SetValue(NewValue(uint(132)));
+			v.SetValue(NewValue(uint(132)))
 		case *Uint8Value:
-			v.SetValue(NewValue(uint8(8)));
+			v.SetValue(NewValue(uint8(8)))
 		case *Uint16Value:
-			v.SetValue(NewValue(uint16(16)));
+			v.SetValue(NewValue(uint16(16)))
 		case *Uint32Value:
-			v.SetValue(NewValue(uint32(32)));
+			v.SetValue(NewValue(uint32(32)))
 		case *Uint64Value:
-			v.SetValue(NewValue(uint64(64)));
+			v.SetValue(NewValue(uint64(64)))
 		case *FloatValue:
-			v.SetValue(NewValue(float(3200.0)));
+			v.SetValue(NewValue(float(3200.0)))
 		case *Float32Value:
-			v.SetValue(NewValue(float32(32.1)));
+			v.SetValue(NewValue(float32(32.1)))
 		case *Float64Value:
-			v.SetValue(NewValue(float64(64.2)));
+			v.SetValue(NewValue(float64(64.2)))
 		case *StringValue:
-			v.SetValue(NewValue("stringy cheese"));
+			v.SetValue(NewValue("stringy cheese"))
 		case *BoolValue:
-			v.SetValue(NewValue(true));
+			v.SetValue(NewValue(true))
 		}
 		s := valueToString(v);
 		if s != tt.s {
-			t.Errorf("#%d: have %#q, want %#q", i, s, tt.s);
+			t.Errorf("#%d: have %#q, want %#q", i, s, tt.s)
 		}
 	}
 }
@@ -315,7 +315,7 @@ func TestValueToString(t *testing.T) {
 	for i, test := range valueToStringTests {
 		s := valueToString(NewValue(test.i));
 		if s != test.s {
-			t.Errorf("#%d: have %#q, want %#q", i, s, test.s);
+			t.Errorf("#%d: have %#q, want %#q", i, s, test.s)
 		}
 	}
 }
@@ -326,7 +326,7 @@ func TestArrayElemSet(t *testing.T) {
 	s := valueToString(v);
 	const want = "[10]int{1, 2, 3, 4, 123, 6, 7, 8, 9, 10}";
 	if s != want {
-		t.Errorf("[10]int: have %#q want %#q", s, want);
+		t.Errorf("[10]int: have %#q want %#q", s, want)
 	}
 
 	v = NewValue([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10});
@@ -334,7 +334,7 @@ func TestArrayElemSet(t *testing.T) {
 	s = valueToString(v);
 	const want1 = "[]int{1, 2, 3, 4, 123, 6, 7, 8, 9, 10}";
 	if s != want1 {
-		t.Errorf("[]int: have %#q want %#q", s, want1);
+		t.Errorf("[]int: have %#q want %#q", s, want1)
 	}
 }
 
@@ -345,7 +345,7 @@ func TestPtrPointTo(t *testing.T) {
 	vi := NewValue(i);
 	vip.(*PtrValue).Elem().(*PtrValue).PointTo(vi);
 	if *ip != 1234 {
-		t.Errorf("got %d, want 1234", *ip);
+		t.Errorf("got %d, want 1234", *ip)
 	}
 }
 
@@ -366,13 +366,13 @@ func TestAll(t *testing.T) {
 
 	f, present := styp.FieldByName("d");
 	if !present {
-		t.Errorf("FieldByName says present field is absent");
+		t.Errorf("FieldByName says present field is absent")
 	}
 	testType(t, 6, f.Type, "float32");
 
 	f, present = styp.FieldByName("absent");
 	if present {
-		t.Errorf("FieldByName says absent field is present");
+		t.Errorf("FieldByName says absent field is present")
 	}
 
 	typ = Typeof([32]int32{});
@@ -422,14 +422,14 @@ func TestInterfaceValue(t *testing.T) {
 
 	i3 := v2.Interface();
 	if _, ok := i3.(float); !ok {
-		t.Error("v2.Interface() did not return float, got ", Typeof(i3));
+		t.Error("v2.Interface() did not return float, got ", Typeof(i3))
 	}
 }
 
 func TestFunctionValue(t *testing.T) {
 	v := NewValue(func() {});
 	if v.Interface() != v.Interface() {
-		t.Fatalf("TestFunction != itself");
+		t.Fatalf("TestFunction != itself")
 	}
 	assert(t, v.Type().String(), "func()");
 }
@@ -442,7 +442,7 @@ func TestCopyArray(t *testing.T) {
 	vb := NewValue(&b);
 	for i := 0; i < len(b); i++ {
 		if b[i] != c[i] {
-			t.Fatalf("b != c before test");
+			t.Fatalf("b != c before test")
 		}
 	}
 	aa := va.(*PtrValue).Elem().(*SliceValue);
@@ -454,20 +454,20 @@ func TestCopyArray(t *testing.T) {
 		for i := 0; i < tocopy; i++ {
 			if a[i] != b[i] {
 				t.Errorf("(i) tocopy=%d a[%d]=%d, b[%d]=%d",
-					tocopy, i, a[i], i, b[i]);
+					tocopy, i, a[i], i, b[i])
 			}
 		}
 		for i := tocopy; i < len(b); i++ {
 			if b[i] != c[i] {
 				if i < len(a) {
 					t.Errorf("(ii) tocopy=%d a[%d]=%d, b[%d]=%d, c[%d]=%d",
-						tocopy, i, a[i], i, b[i], i, c[i]);
+						tocopy, i, a[i], i, b[i], i, c[i])
 				} else {
 					t.Errorf("(iii) tocopy=%d b[%d]=%d, c[%d]=%d",
-						tocopy, i, b[i], i, c[i]);
+						tocopy, i, b[i], i, c[i])
 				}
 			} else {
-				t.Logf("tocopy=%d elem %d is okay\n", tocopy, i);
+				t.Logf("tocopy=%d elem %d is okay\n", tocopy, i)
 			}
 		}
 	}
@@ -480,7 +480,7 @@ func TestBigUnnamedStruct(t *testing.T) {
 		a, b, c, d int64;
 	});
 	if b1.a != b.a || b1.b != b.b || b1.c != b.c || b1.d != b.d {
-		t.Errorf("NewValue(%v).Interface().(*Big) = %v", b, b1);
+		t.Errorf("NewValue(%v).Interface().(*Big) = %v", b, b1)
 	}
 }
 
@@ -493,7 +493,7 @@ func TestBigStruct(t *testing.T) {
 	v := NewValue(b);
 	b1 := v.Interface().(big);
 	if b1.a != b.a || b1.b != b.b || b1.c != b.c || b1.d != b.d || b1.e != b.e {
-		t.Errorf("NewValue(%v).Interface().(big) = %v", b, b1);
+		t.Errorf("NewValue(%v).Interface().(big) = %v", b, b1)
 	}
 }
 
@@ -552,7 +552,7 @@ var deepEqualTests = []DeepEqualTest{
 func TestDeepEqual(t *testing.T) {
 	for _, test := range deepEqualTests {
 		if r := DeepEqual(test.a, test.b); r != test.eq {
-			t.Errorf("DeepEqual(%v, %v) = %v, want %v", test.a, test.b, r, test.eq);
+			t.Errorf("DeepEqual(%v, %v) = %v, want %v", test.a, test.b, r, test.eq)
 		}
 	}
 }
@@ -561,11 +561,11 @@ func TestTypeof(t *testing.T) {
 	for _, test := range deepEqualTests {
 		v := NewValue(test.a);
 		if v == nil {
-			continue;
+			continue
 		}
 		typ := Typeof(test.a);
 		if typ != v.Type() {
-			t.Errorf("Typeof(%v) = %v, but NewValue(%v).Type() = %v", test.a, typ, test.a, v.Type());
+			t.Errorf("Typeof(%v) = %v, but NewValue(%v).Type() = %v", test.a, typ, test.a, v.Type())
 		}
 	}
 }
@@ -580,7 +580,7 @@ func TestDeepEqualRecursiveStruct(t *testing.T) {
 	*a = Recursive{12, a};
 	*b = Recursive{12, b};
 	if !DeepEqual(a, b) {
-		t.Error("DeepEqual(recursive same) = false, want true");
+		t.Error("DeepEqual(recursive same) = false, want true")
 	}
 }
 
@@ -598,7 +598,7 @@ func TestDeepEqualComplexStruct(t *testing.T) {
 	*a = Complex{5, [3]*Complex{a, b, a}, &stra, m};
 	*b = Complex{5, [3]*Complex{b, a, a}, &strb, m};
 	if !DeepEqual(a, b) {
-		t.Error("DeepEqual(complex same) = false, want true");
+		t.Error("DeepEqual(complex same) = false, want true")
 	}
 }
 
@@ -609,7 +609,7 @@ func TestDeepEqualComplexStructInequality(t *testing.T) {
 	*a = Complex{5, [3]*Complex{a, b, a}, &stra, m};
 	*b = Complex{5, [3]*Complex{b, a, a}, &strb, m};
 	if DeepEqual(a, b) {
-		t.Error("DeepEqual(complex different) = true, want false");
+		t.Error("DeepEqual(complex different) = true, want false")
 	}
 }
 
@@ -618,7 +618,7 @@ func check2ndField(x interface{}, offs uintptr, t *testing.T) {
 	s := NewValue(x).(*StructValue);
 	f := s.Type().(*StructType).Field(1);
 	if f.Offset != offs {
-		t.Error("mismatched offsets in structure alignment:", f.Offset, offs);
+		t.Error("mismatched offsets in structure alignment:", f.Offset, offs)
 	}
 }
 
@@ -654,14 +654,14 @@ type IsNiller interface {
 func Nil(a interface{}, t *testing.T) {
 	n := NewValue(a).(*StructValue).Field(0).(IsNiller);
 	if !n.IsNil() {
-		t.Errorf("%v should be nil", a);
+		t.Errorf("%v should be nil", a)
 	}
 }
 
 func NotNil(a interface{}, t *testing.T) {
 	n := NewValue(a).(*StructValue).Field(0).(IsNiller);
 	if n.IsNil() {
-		t.Errorf("value of type %v should not be nil", NewValue(a).Type().String());
+		t.Errorf("value of type %v should not be nil", NewValue(a).Type().String())
 	}
 }
 
@@ -672,7 +672,7 @@ func TestIsNil(t *testing.T) {
 		ty := Typeof(ts);
 		v := MakeZero(ty);
 		if _, ok := v.(IsNiller); ok {
-			t.Errorf("%s is nilable; should not be", ts);
+			t.Errorf("%s is nilable; should not be", ts)
 		}
 	}
 
@@ -690,7 +690,7 @@ func TestIsNil(t *testing.T) {
 		ty := Typeof(ts).(*StructType).Field(0).Type;
 		v := MakeZero(ty);
 		if _, ok := v.(IsNiller); !ok {
-			t.Errorf("%s %T is not nilable; should be", ts, v);
+			t.Errorf("%s %T is not nilable; should be", ts, v)
 		}
 	}
 
@@ -746,7 +746,7 @@ func TestInterfaceExtraction(t *testing.T) {
 	s.w = os.Stdout;
 	v := Indirect(NewValue(&s)).(*StructValue).Field(0).Interface();
 	if v != s.w.(interface{}) {
-		t.Error("Interface() on interface: ", v, s.w);
+		t.Error("Interface() on interface: ", v, s.w)
 	}
 }
 
@@ -766,7 +766,7 @@ func TestInterfaceEditing(t *testing.T) {
 	// not change the value stored in i.
 	v.(*StringValue).Set("bye");
 	if i.(string) != "hello" {
-		t.Errorf(`Set("bye") changed i to %s`, i.(string));
+		t.Errorf(`Set("bye") changed i to %s`, i.(string))
 	}
 
 	// the same should be true of smaller items.
@@ -774,14 +774,14 @@ func TestInterfaceEditing(t *testing.T) {
 	v = NewValue(i);
 	v.(*IntValue).Set(234);
 	if i.(int) != 123 {
-		t.Errorf("Set(234) changed i to %d", i.(int));
+		t.Errorf("Set(234) changed i to %d", i.(int))
 	}
 }
 
 func TestNilPtrValueSub(t *testing.T) {
 	var pi *int;
 	if pv := NewValue(pi).(*PtrValue); pv.Elem() != nil {
-		t.Error("NewValue((*int)(nil)).(*PtrValue).Elem() != nil");
+		t.Error("NewValue((*int)(nil)).(*PtrValue).Elem() != nil")
 	}
 }
 
@@ -789,7 +789,7 @@ func TestMap(t *testing.T) {
 	m := map[string]int{"a": 1, "b": 2};
 	mv := NewValue(m).(*MapValue);
 	if n := mv.Len(); n != len(m) {
-		t.Errorf("Len = %d, want %d", n, len(m));
+		t.Errorf("Len = %d, want %d", n, len(m))
 	}
 	keys := mv.Keys();
 	i := 0;
@@ -800,16 +800,16 @@ func TestMap(t *testing.T) {
 		// but they are in this implementation, which makes
 		// the test easier.
 		if i >= len(keys) {
-			t.Errorf("Missing key #%d %q", i, k);
+			t.Errorf("Missing key #%d %q", i, k)
 		} else if kv := keys[i].(*StringValue); kv.Get() != k {
-			t.Errorf("Keys[%d] = %q, want %q", i, kv.Get(), k);
+			t.Errorf("Keys[%d] = %q, want %q", i, kv.Get(), k)
 		}
 		i++;
 
 		// Check that value lookup is correct.
 		vv := mv.Elem(NewValue(k));
 		if vi := vv.(*IntValue).Get(); vi != v {
-			t.Errorf("Key %q: have value %d, want %d", vi, v);
+			t.Errorf("Key %q: have value %d, want %d", vi, v)
 		}
 
 		// Copy into new map.
@@ -817,25 +817,25 @@ func TestMap(t *testing.T) {
 	}
 	vv := mv.Elem(NewValue("not-present"));
 	if vv != nil {
-		t.Errorf("Invalid key: got non-nil value %s", valueToString(vv));
+		t.Errorf("Invalid key: got non-nil value %s", valueToString(vv))
 	}
 
 	newm := newmap.Interface().(map[string]int);
 	if len(newm) != len(m) {
-		t.Errorf("length after copy: newm=%d, m=%d", newm, m);
+		t.Errorf("length after copy: newm=%d, m=%d", newm, m)
 	}
 
 	for k, v := range newm {
 		mv, ok := m[k];
 		if mv != v {
-			t.Errorf("newm[%q] = %d, but m[%q] = %d, %v", k, v, k, mv, ok);
+			t.Errorf("newm[%q] = %d, but m[%q] = %d, %v", k, v, k, mv, ok)
 		}
 	}
 
 	newmap.SetElem(NewValue("a"), nil);
 	v, ok := newm["a"];
 	if ok {
-		t.Errorf("newm[\"a\"] = %d after delete", v);
+		t.Errorf("newm[\"a\"] = %d after delete", v)
 	}
 }
 
@@ -857,28 +857,28 @@ func TestChan(t *testing.T) {
 		// Send
 		cv.Send(NewValue(2));
 		if i := <-c; i != 2 {
-			t.Errorf("reflect Send 2, native recv %d", i);
+			t.Errorf("reflect Send 2, native recv %d", i)
 		}
 
 		// Recv
 		c <- 3;
 		if i := cv.Recv().(*IntValue).Get(); i != 3 {
-			t.Errorf("native send 3, reflect Recv %d", i);
+			t.Errorf("native send 3, reflect Recv %d", i)
 		}
 
 		// TryRecv fail
 		val := cv.TryRecv();
 		if val != nil {
-			t.Errorf("TryRecv on empty chan: %s", valueToString(val));
+			t.Errorf("TryRecv on empty chan: %s", valueToString(val))
 		}
 
 		// TryRecv success
 		c <- 4;
 		val = cv.TryRecv();
 		if val == nil {
-			t.Errorf("TryRecv on ready chan got nil");
+			t.Errorf("TryRecv on ready chan got nil")
 		} else if i := val.(*IntValue).Get(); i != 4 {
-			t.Errorf("native send 4, TryRecv %d", i);
+			t.Errorf("native send 4, TryRecv %d", i)
 		}
 
 		// TrySend fail
@@ -886,16 +886,16 @@ func TestChan(t *testing.T) {
 		ok := cv.TrySend(NewValue(5));
 		i := <-c;
 		if ok {
-			t.Errorf("TrySend on full chan succeeded: value %d", i);
+			t.Errorf("TrySend on full chan succeeded: value %d", i)
 		}
 
 		// TrySend success
 		ok = cv.TrySend(NewValue(6));
 		if !ok {
-			t.Errorf("TrySend on empty chan failed");
+			t.Errorf("TrySend on empty chan failed")
 		} else {
 			if i = <-c; i != 6 {
-				t.Errorf("TrySend 6, recv %d", i);
+				t.Errorf("TrySend 6, recv %d", i)
 			}
 		}
 
@@ -903,19 +903,19 @@ func TestChan(t *testing.T) {
 		c <- 123;
 		cv.Close();
 		if cv.Closed() {
-			t.Errorf("closed too soon - 1");
+			t.Errorf("closed too soon - 1")
 		}
 		if i := cv.Recv().(*IntValue).Get(); i != 123 {
-			t.Errorf("send 123 then close; Recv %d", i);
+			t.Errorf("send 123 then close; Recv %d", i)
 		}
 		if cv.Closed() {
-			t.Errorf("closed too soon - 2");
+			t.Errorf("closed too soon - 2")
 		}
 		if i := cv.Recv().(*IntValue).Get(); i != 0 {
-			t.Errorf("after close Recv %d", i);
+			t.Errorf("after close Recv %d", i)
 		}
 		if !cv.Closed() {
-			t.Errorf("not closed");
+			t.Errorf("not closed")
 		}
 	}
 
@@ -924,20 +924,20 @@ func TestChan(t *testing.T) {
 	cv := MakeChan(Typeof(c).(*ChanType), 0);
 	c = cv.Interface().(chan int);
 	if cv.TrySend(NewValue(7)) {
-		t.Errorf("TrySend on sync chan succeeded");
+		t.Errorf("TrySend on sync chan succeeded")
 	}
 	if cv.TryRecv() != nil {
-		t.Errorf("TryRecv on sync chan succeeded");
+		t.Errorf("TryRecv on sync chan succeeded")
 	}
 
 	// len/cap
 	cv = MakeChan(Typeof(c).(*ChanType), 10);
 	c = cv.Interface().(chan int);
 	for i := 0; i < 3; i++ {
-		c <- i;
+		c <- i
 	}
 	if l, m := cv.Len(), cv.Cap(); l != len(c) || m != cap(c) {
-		t.Errorf("Len/Cap = %d/%d want %d/%d", l, m, len(c), cap(c));
+		t.Errorf("Len/Cap = %d/%d want %d/%d", l, m, len(c), cap(c))
 	}
 
 }
@@ -945,20 +945,20 @@ func TestChan(t *testing.T) {
 // Difficult test for function call because of
 // implicit padding between arguments.
 func dummy(b byte, c int, d byte) (i byte, j int, k byte) {
-	return b, c, d;
+	return b, c, d
 }
 
 func TestFunc(t *testing.T) {
 	ret := NewValue(dummy).(*FuncValue).Call([]Value{NewValue(byte(10)), NewValue(20), NewValue(byte(30))});
 	if len(ret) != 3 {
-		t.Fatalf("Call returned %d values, want 3", len(ret));
+		t.Fatalf("Call returned %d values, want 3", len(ret))
 	}
 
 	i := ret[0].(*Uint8Value).Get();
 	j := ret[1].(*IntValue).Get();
 	k := ret[2].(*Uint8Value).Get();
 	if i != 10 || j != 20 || k != 30 {
-		t.Errorf("Call returned %d, %d, %d; want 10, 20, 30", i, j, k);
+		t.Errorf("Call returned %d, %d, %d; want 10, 20, 30", i, j, k)
 	}
 }
 
@@ -973,13 +973,13 @@ func TestMethod(t *testing.T) {
 	p := Point{3, 4};
 	i := Typeof(p).Method(0).Func.Call([]Value{NewValue(p), NewValue(10)})[0].(*IntValue).Get();
 	if i != 250 {
-		t.Errorf("Type Method returned %d; want 250", i);
+		t.Errorf("Type Method returned %d; want 250", i)
 	}
 
 	// Curried method of value.
 	i = NewValue(p).Method(0).Call([]Value{NewValue(10)})[0].(*IntValue).Get();
 	if i != 250 {
-		t.Errorf("Value Method returned %d; want 250", i);
+		t.Errorf("Value Method returned %d; want 250", i)
 	}
 
 	// Curried method of interface value.
@@ -994,7 +994,7 @@ func TestMethod(t *testing.T) {
 	pv := NewValue(s).(*StructValue).Field(0);
 	i = pv.Method(0).Call([]Value{NewValue(10)})[0].(*IntValue).Get();
 	if i != 250 {
-		t.Errorf("Interface Method returned %d; want 250", i);
+		t.Errorf("Interface Method returned %d; want 250", i)
 	}
 }
 
@@ -1010,18 +1010,18 @@ func TestInterfaceSet(t *testing.T) {
 	sv := NewValue(&s).(*PtrValue).Elem().(*StructValue);
 	sv.Field(0).(*InterfaceValue).Set(NewValue(p));
 	if q := s.I.(*Point); q != p {
-		t.Errorf("i: have %p want %p", q, p);
+		t.Errorf("i: have %p want %p", q, p)
 	}
 
 	pv := sv.Field(1).(*InterfaceValue);
 	pv.Set(NewValue(p));
 	if q := s.P.(*Point); q != p {
-		t.Errorf("i: have %p want %p", q, p);
+		t.Errorf("i: have %p want %p", q, p)
 	}
 
 	i := pv.Method(0).Call([]Value{NewValue(10)})[0].(*IntValue).Get();
 	if i != 250 {
-		t.Errorf("Interface Method returned %d; want 250", i);
+		t.Errorf("Interface Method returned %d; want 250", i)
 	}
 }
 
@@ -1036,10 +1036,10 @@ func TestAnonymousFields(t *testing.T) {
 	var t1 T1;
 	type1 := Typeof(t1).(*StructType);
 	if field, ok = type1.FieldByName("int"); !ok {
-		t.Error("no field 'int'");
+		t.Error("no field 'int'")
 	}
 	if field.Index[0] != 1 {
-		t.Error("field index should be 1; is", field.Index);
+		t.Error("field index should be 1; is", field.Index)
 	}
 }
 
@@ -1123,13 +1123,13 @@ func TestFieldByIndex(t *testing.T) {
 		if f.Name != "" {
 			if test.index != nil {
 				if f.Name != test.name {
-					t.Errorf("%s.%s found; want %s", s.Name(), f.Name, test.name);
+					t.Errorf("%s.%s found; want %s", s.Name(), f.Name, test.name)
 				}
 			} else {
-				t.Errorf("%s.%s found", s.Name(), f.Name);
+				t.Errorf("%s.%s found", s.Name(), f.Name)
 			}
 		} else if len(test.index) > 0 {
-			t.Errorf("%s.%s not found", s.Name(), test.name);
+			t.Errorf("%s.%s not found", s.Name(), test.name)
 		}
 
 		if test.value != 0 {
@@ -1137,13 +1137,13 @@ func TestFieldByIndex(t *testing.T) {
 			if v != nil {
 				if x, ok := v.Interface().(int); ok {
 					if x != test.value {
-						t.Errorf("%s%v is %d; want %d", s.Name(), test.index, x, test.value);
+						t.Errorf("%s%v is %d; want %d", s.Name(), test.index, x, test.value)
 					}
 				} else {
-					t.Errorf("%s%v value not an int", s.Name(), test.index);
+					t.Errorf("%s%v value not an int", s.Name(), test.index)
 				}
 			} else {
-				t.Errorf("%s%v value not found", s.Name(), test.index);
+				t.Errorf("%s%v value not found", s.Name(), test.index)
 			}
 		}
 	}
@@ -1157,19 +1157,19 @@ func TestFieldByName(t *testing.T) {
 			if test.index != nil {
 				// Verify field depth and index.
 				if len(f.Index) != len(test.index) {
-					t.Errorf("%s.%s depth %d; want %d", s.Name(), test.name, len(f.Index), len(test.index));
+					t.Errorf("%s.%s depth %d; want %d", s.Name(), test.name, len(f.Index), len(test.index))
 				} else {
 					for i, x := range f.Index {
 						if x != test.index[i] {
-							t.Errorf("%s.%s.Index[%d] is %d; want %d", s.Name(), test.name, i, x, test.index[i]);
+							t.Errorf("%s.%s.Index[%d] is %d; want %d", s.Name(), test.name, i, x, test.index[i])
 						}
 					}
 				}
 			} else {
-				t.Errorf("%s.%s found", s.Name(), f.Name);
+				t.Errorf("%s.%s found", s.Name(), f.Name)
 			}
 		} else if len(test.index) > 0 {
-			t.Errorf("%s.%s not found", s.Name(), test.name);
+			t.Errorf("%s.%s not found", s.Name(), test.name)
 		}
 
 		if test.value != 0 {
@@ -1177,13 +1177,13 @@ func TestFieldByName(t *testing.T) {
 			if v != nil {
 				if x, ok := v.Interface().(int); ok {
 					if x != test.value {
-						t.Errorf("%s.%s is %d; want %d", s.Name(), test.name, x, test.value);
+						t.Errorf("%s.%s is %d; want %d", s.Name(), test.name, x, test.value)
 					}
 				} else {
-					t.Errorf("%s.%s value not an int", s.Name(), test.name);
+					t.Errorf("%s.%s value not an int", s.Name(), test.name)
 				}
 			} else {
-				t.Errorf("%s.%s value not found", s.Name(), test.name);
+				t.Errorf("%s.%s value not found", s.Name(), test.name)
 			}
 		}
 	}
diff --git a/src/pkg/reflect/deepequal.go b/src/pkg/reflect/deepequal.go
index 9d1d14c897..f3e13f85c1 100644
--- a/src/pkg/reflect/deepequal.go
+++ b/src/pkg/reflect/deepequal.go
@@ -23,10 +23,10 @@ type visit struct {
 // recursive types.
 func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) bool {
 	if v1 == nil || v2 == nil {
-		return v1 == v2;
+		return v1 == v2
 	}
 	if v1.Type() != v2.Type() {
-		return false;
+		return false
 	}
 
 	// if depth > 10 { panic("deepValueEqual") }	// for debugging
@@ -35,12 +35,12 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) bool {
 	addr2 := v2.Addr();
 	if addr1 > addr2 {
 		// Canonicalize order to reduce number of entries in visited.
-		addr1, addr2 = addr2, addr1;
+		addr1, addr2 = addr2, addr1
 	}
 
 	// Short circuit if references are identical ...
 	if addr1 == addr2 {
-		return true;
+		return true
 	}
 
 	// ... or already seen
@@ -49,7 +49,7 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) bool {
 	typ := v1.Type();
 	for p := seen; p != nil; p = p.next {
 		if p.a1 == addr1 && p.a2 == addr2 && p.typ == typ {
-			return true;
+			return true
 		}
 	}
 
@@ -61,11 +61,11 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) bool {
 		arr1 := v;
 		arr2 := v2.(*ArrayValue);
 		if arr1.Len() != arr2.Len() {
-			return false;
+			return false
 		}
 		for i := 0; i < arr1.Len(); i++ {
 			if !deepValueEqual(arr1.Elem(i), arr2.Elem(i), visited, depth+1) {
-				return false;
+				return false
 			}
 		}
 		return true;
@@ -73,11 +73,11 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) bool {
 		arr1 := v;
 		arr2 := v2.(*SliceValue);
 		if arr1.Len() != arr2.Len() {
-			return false;
+			return false
 		}
 		for i := 0; i < arr1.Len(); i++ {
 			if !deepValueEqual(arr1.Elem(i), arr2.Elem(i), visited, depth+1) {
-				return false;
+				return false
 			}
 		}
 		return true;
@@ -85,17 +85,17 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) bool {
 		i1 := v.Interface();
 		i2 := v2.Interface();
 		if i1 == nil || i2 == nil {
-			return i1 == i2;
+			return i1 == i2
 		}
 		return deepValueEqual(NewValue(i1), NewValue(i2), visited, depth+1);
 	case *PtrValue:
-		return deepValueEqual(v.Elem(), v2.(*PtrValue).Elem(), visited, depth+1);
+		return deepValueEqual(v.Elem(), v2.(*PtrValue).Elem(), visited, depth+1)
 	case *StructValue:
 		struct1 := v;
 		struct2 := v2.(*StructValue);
 		for i, n := 0, v.NumField(); i < n; i++ {
 			if !deepValueEqual(struct1.Field(i), struct2.Field(i), visited, depth+1) {
-				return false;
+				return false
 			}
 		}
 		return true;
@@ -103,17 +103,17 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) bool {
 		map1 := v;
 		map2 := v2.(*MapValue);
 		if map1.Len() != map2.Len() {
-			return false;
+			return false
 		}
 		for _, k := range map1.Keys() {
 			if !deepValueEqual(map1.Elem(k), map2.Elem(k), visited, depth+1) {
-				return false;
+				return false
 			}
 		}
 		return true;
 	default:
 		// Normal equality suffices
-		return v1.Interface() == v2.Interface();
+		return v1.Interface() == v2.Interface()
 	}
 
 	panic("Not reached");
@@ -124,12 +124,12 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) bool {
 // handles recursive types.
 func DeepEqual(a1, a2 interface{}) bool {
 	if a1 == nil || a2 == nil {
-		return a1 == a2;
+		return a1 == a2
 	}
 	v1 := NewValue(a1);
 	v2 := NewValue(a2);
 	if v1.Type() != v2.Type() {
-		return false;
+		return false
 	}
 	return deepValueEqual(v1, v2, make(map[uintptr]*visit), 0);
 }
diff --git a/src/pkg/reflect/tostring_test.go b/src/pkg/reflect/tostring_test.go
index 2ec5aa9ac8..4a9e75793b 100644
--- a/src/pkg/reflect/tostring_test.go
+++ b/src/pkg/reflect/tostring_test.go
@@ -18,55 +18,55 @@ import (
 func valueToString(val Value) string {
 	var str string;
 	if val == nil {
-		return "<nil>";
+		return "<nil>"
 	}
 	typ := val.Type();
 	switch val := val.(type) {
 	case *IntValue:
-		return strconv.Uitoa64(uint64(val.Get()));
+		return strconv.Uitoa64(uint64(val.Get()))
 	case *Int8Value:
-		return strconv.Itoa64(int64(val.Get()));
+		return strconv.Itoa64(int64(val.Get()))
 	case *Int16Value:
-		return strconv.Itoa64(int64(val.Get()));
+		return strconv.Itoa64(int64(val.Get()))
 	case *Int32Value:
-		return strconv.Itoa64(int64(val.Get()));
+		return strconv.Itoa64(int64(val.Get()))
 	case *Int64Value:
-		return strconv.Itoa64(int64(val.Get()));
+		return strconv.Itoa64(int64(val.Get()))
 	case *UintValue:
-		return strconv.Itoa64(int64(val.Get()));
+		return strconv.Itoa64(int64(val.Get()))
 	case *Uint8Value:
-		return strconv.Itoa64(int64(val.Get()));
+		return strconv.Itoa64(int64(val.Get()))
 	case *Uint16Value:
-		return strconv.Itoa64(int64(val.Get()));
+		return strconv.Itoa64(int64(val.Get()))
 	case *Uint32Value:
-		return strconv.Itoa64(int64(val.Get()));
+		return strconv.Itoa64(int64(val.Get()))
 	case *Uint64Value:
-		return strconv.Uitoa64(uint64(val.Get()));
+		return strconv.Uitoa64(uint64(val.Get()))
 	case *FloatValue:
 		if strconv.FloatSize == 32 {
-			return strconv.Ftoa32(float32(val.Get()), 'g', -1);
+			return strconv.Ftoa32(float32(val.Get()), 'g', -1)
 		} else {
-			return strconv.Ftoa64(float64(val.Get()), 'g', -1);
+			return strconv.Ftoa64(float64(val.Get()), 'g', -1)
 		}
 	case *Float32Value:
-		return strconv.Ftoa32(val.Get(), 'g', -1);
+		return strconv.Ftoa32(val.Get(), 'g', -1)
 	case *Float64Value:
-		return strconv.Ftoa64(val.Get(), 'g', -1);
+		return strconv.Ftoa64(val.Get(), 'g', -1)
 	case *StringValue:
-		return val.Get();
+		return val.Get()
 	case *BoolValue:
 		if val.Get() {
-			return "true";
+			return "true"
 		} else {
-			return "false";
+			return "false"
 		}
 	case *PtrValue:
 		v := val;
 		str = typ.String() + "(";
 		if v.IsNil() {
-			str += "0";
+			str += "0"
 		} else {
-			str += "&" + valueToString(v.Elem());
+			str += "&" + valueToString(v.Elem())
 		}
 		str += ")";
 		return str;
@@ -76,7 +76,7 @@ func valueToString(val Value) string {
 		str += "{";
 		for i := 0; i < v.Len(); i++ {
 			if i > 0 {
-				str += ", ";
+				str += ", "
 			}
 			str += valueToString(v.Elem(i));
 		}
@@ -99,19 +99,19 @@ func valueToString(val Value) string {
 		str += "{";
 		for i, n := 0, v.NumField(); i < n; i++ {
 			if i > 0 {
-				str += ", ";
+				str += ", "
 			}
 			str += valueToString(v.Field(i));
 		}
 		str += "}";
 		return str;
 	case *InterfaceValue:
-		return typ.String() + "(" + valueToString(val.Elem()) + ")";
+		return typ.String() + "(" + valueToString(val.Elem()) + ")"
 	case *FuncValue:
 		v := val;
 		return typ.String() + "(" + strconv.Itoa64(int64(v.Get())) + ")";
 	default:
-		panicln("valueToString: can't print type ", typ.String());
+		panicln("valueToString: can't print type ", typ.String())
 	}
 	return "valueToString: can't happen";
 }
diff --git a/src/pkg/reflect/type.go b/src/pkg/reflect/type.go
index 53ce76a2c9..afb146cef1 100644
--- a/src/pkg/reflect/type.go
+++ b/src/pkg/reflect/type.go
@@ -285,19 +285,19 @@ type Type interface {
 }
 
 func (t *uncommonType) uncommon() *uncommonType {
-	return t;
+	return t
 }
 
 func (t *uncommonType) PkgPath() string {
 	if t == nil || t.pkgPath == nil {
-		return "";
+		return ""
 	}
 	return *t.pkgPath;
 }
 
 func (t *uncommonType) Name() string {
 	if t == nil || t.name == nil {
-		return "";
+		return ""
 	}
 	return *t.name;
 }
@@ -312,14 +312,14 @@ func (t *commonType) FieldAlign() int	{ return int(t.fieldAlign) }
 
 func (t *uncommonType) Method(i int) (m Method) {
 	if t == nil || i < 0 || i >= len(t.methods) {
-		return;
+		return
 	}
 	p := &t.methods[i];
 	if p.name != nil {
-		m.Name = *p.name;
+		m.Name = *p.name
 	}
 	if p.pkgPath != nil {
-		m.PkgPath = *p.pkgPath;
+		m.PkgPath = *p.pkgPath
 	}
 	m.Type = toType(*p.typ).(*FuncType);
 	fn := p.tfn;
@@ -329,7 +329,7 @@ func (t *uncommonType) Method(i int) (m Method) {
 
 func (t *uncommonType) NumMethod() int {
 	if t == nil {
-		return 0;
+		return 0
 	}
 	return len(t.methods);
 }
@@ -360,11 +360,11 @@ func (t *ChanType) Elem() Type	{ return toType(*t.elem) }
 func (d ChanDir) String() string {
 	switch d {
 	case SendDir:
-		return "chan<-";
+		return "chan<-"
 	case RecvDir:
-		return "<-chan";
+		return "<-chan"
 	case BothDir:
-		return "chan";
+		return "chan"
 	}
 	return "ChanDir" + strconv.Itoa(int(d));
 }
@@ -372,7 +372,7 @@ func (d ChanDir) String() string {
 // In returns the type of the i'th function input parameter.
 func (t *FuncType) In(i int) Type {
 	if i < 0 || i >= len(t.in) {
-		return nil;
+		return nil
 	}
 	return toType(*t.in[i]);
 }
@@ -383,7 +383,7 @@ func (t *FuncType) NumIn() int	{ return len(t.in) }
 // Out returns the type of the i'th function output parameter.
 func (t *FuncType) Out(i int) Type {
 	if i < 0 || i >= len(t.out) {
-		return nil;
+		return nil
 	}
 	return toType(*t.out[i]);
 }
@@ -394,12 +394,12 @@ func (t *FuncType) NumOut() int	{ return len(t.out) }
 // Method returns the i'th interface method.
 func (t *InterfaceType) Method(i int) (m Method) {
 	if i < 0 || i >= len(t.methods) {
-		return;
+		return
 	}
 	p := &t.methods[i];
 	m.Name = *p.name;
 	if p.pkgPath != nil {
-		m.PkgPath = *p.pkgPath;
+		m.PkgPath = *p.pkgPath
 	}
 	m.Type = toType(*p.typ).(*FuncType);
 	return;
@@ -433,25 +433,25 @@ type StructField struct {
 // Field returns the i'th struct field.
 func (t *StructType) Field(i int) (f StructField) {
 	if i < 0 || i >= len(t.fields) {
-		return;
+		return
 	}
 	p := t.fields[i];
 	f.Type = toType(*p.typ);
 	if p.name != nil {
-		f.Name = *p.name;
+		f.Name = *p.name
 	} else {
 		t := f.Type;
 		if pt, ok := t.(*PtrType); ok {
-			t = pt.Elem();
+			t = pt.Elem()
 		}
 		f.Name = t.Name();
 		f.Anonymous = true;
 	}
 	if p.pkgPath != nil {
-		f.PkgPath = *p.pkgPath;
+		f.PkgPath = *p.pkgPath
 	}
 	if p.tag != nil {
-		f.Tag = *p.tag;
+		f.Tag = *p.tag
 	}
 	f.Offset = p.offset;
 	f.Index = []int{i};
@@ -467,10 +467,10 @@ func (t *StructType) FieldByIndex(index []int) (f StructField) {
 		if i > 0 {
 			ft := f.Type;
 			if pt, ok := ft.(*PtrType); ok {
-				ft = pt.Elem();
+				ft = pt.Elem()
 			}
 			if st, ok := ft.(*StructType); ok {
-				t = st;
+				t = st
 			} else {
 				var f0 StructField;
 				f = f0;
@@ -489,7 +489,7 @@ func (t *StructType) fieldByName(name string, mark map[*StructType]bool, depth i
 
 	if _, marked := mark[t]; marked {
 		// Struct already seen.
-		return;
+		return
 	}
 	mark[t] = true;
 
@@ -501,20 +501,20 @@ L:	for i, _ := range t.fields {
 		switch {
 		case f.Name == name:
 			// Matching top-level field.
-			d = depth;
+			d = depth
 		case f.Anonymous:
 			ft := f.Type;
 			if pt, ok := ft.(*PtrType); ok {
-				ft = pt.Elem();
+				ft = pt.Elem()
 			}
 			switch {
 			case ft.Name() == name:
 				// Matching anonymous top-level field.
-				d = depth;
+				d = depth
 			case fd > depth:
 				// No top-level field yet; look inside nested structs.
 				if st, ok := ft.(*StructType); ok {
-					f, d = st.fieldByName(name, mark, depth+1);
+					f, d = st.fieldByName(name, mark, depth+1)
 				}
 			}
 		}
@@ -530,7 +530,7 @@ L:	for i, _ := range t.fields {
 			n++;
 			if d == depth {
 				// Impossible to find a field at lower depth.
-				break L;
+				break L
 			}
 		}
 	}
@@ -538,12 +538,12 @@ L:	for i, _ := range t.fields {
 	if n == 1 {
 		// Found matching field.
 		if len(ff.Index) <= depth {
-			ff.Index = make([]int, depth+1);
+			ff.Index = make([]int, depth+1)
 		}
 		ff.Index[depth] = fi;
 	} else {
 		// None or more than one matching field found.
-		fd = inf;
+		fd = inf
 	}
 
 	mark[t] = false, false;
@@ -568,57 +568,57 @@ func (t *StructType) NumField() int	{ return len(t.fields) }
 func toType(i interface{}) Type {
 	switch v := i.(type) {
 	case *runtime.BoolType:
-		return (*BoolType)(unsafe.Pointer(v));
+		return (*BoolType)(unsafe.Pointer(v))
 	case *runtime.DotDotDotType:
-		return (*DotDotDotType)(unsafe.Pointer(v));
+		return (*DotDotDotType)(unsafe.Pointer(v))
 	case *runtime.FloatType:
-		return (*FloatType)(unsafe.Pointer(v));
+		return (*FloatType)(unsafe.Pointer(v))
 	case *runtime.Float32Type:
-		return (*Float32Type)(unsafe.Pointer(v));
+		return (*Float32Type)(unsafe.Pointer(v))
 	case *runtime.Float64Type:
-		return (*Float64Type)(unsafe.Pointer(v));
+		return (*Float64Type)(unsafe.Pointer(v))
 	case *runtime.IntType:
-		return (*IntType)(unsafe.Pointer(v));
+		return (*IntType)(unsafe.Pointer(v))
 	case *runtime.Int8Type:
-		return (*Int8Type)(unsafe.Pointer(v));
+		return (*Int8Type)(unsafe.Pointer(v))
 	case *runtime.Int16Type:
-		return (*Int16Type)(unsafe.Pointer(v));
+		return (*Int16Type)(unsafe.Pointer(v))
 	case *runtime.Int32Type:
-		return (*Int32Type)(unsafe.Pointer(v));
+		return (*Int32Type)(unsafe.Pointer(v))
 	case *runtime.Int64Type:
-		return (*Int64Type)(unsafe.Pointer(v));
+		return (*Int64Type)(unsafe.Pointer(v))
 	case *runtime.StringType:
-		return (*StringType)(unsafe.Pointer(v));
+		return (*StringType)(unsafe.Pointer(v))
 	case *runtime.UintType:
-		return (*UintType)(unsafe.Pointer(v));
+		return (*UintType)(unsafe.Pointer(v))
 	case *runtime.Uint8Type:
-		return (*Uint8Type)(unsafe.Pointer(v));
+		return (*Uint8Type)(unsafe.Pointer(v))
 	case *runtime.Uint16Type:
-		return (*Uint16Type)(unsafe.Pointer(v));
+		return (*Uint16Type)(unsafe.Pointer(v))
 	case *runtime.Uint32Type:
-		return (*Uint32Type)(unsafe.Pointer(v));
+		return (*Uint32Type)(unsafe.Pointer(v))
 	case *runtime.Uint64Type:
-		return (*Uint64Type)(unsafe.Pointer(v));
+		return (*Uint64Type)(unsafe.Pointer(v))
 	case *runtime.UintptrType:
-		return (*UintptrType)(unsafe.Pointer(v));
+		return (*UintptrType)(unsafe.Pointer(v))
 	case *runtime.UnsafePointerType:
-		return (*UnsafePointerType)(unsafe.Pointer(v));
+		return (*UnsafePointerType)(unsafe.Pointer(v))
 	case *runtime.ArrayType:
-		return (*ArrayType)(unsafe.Pointer(v));
+		return (*ArrayType)(unsafe.Pointer(v))
 	case *runtime.ChanType:
-		return (*ChanType)(unsafe.Pointer(v));
+		return (*ChanType)(unsafe.Pointer(v))
 	case *runtime.FuncType:
-		return (*FuncType)(unsafe.Pointer(v));
+		return (*FuncType)(unsafe.Pointer(v))
 	case *runtime.InterfaceType:
-		return (*InterfaceType)(unsafe.Pointer(v));
+		return (*InterfaceType)(unsafe.Pointer(v))
 	case *runtime.MapType:
-		return (*MapType)(unsafe.Pointer(v));
+		return (*MapType)(unsafe.Pointer(v))
 	case *runtime.PtrType:
-		return (*PtrType)(unsafe.Pointer(v));
+		return (*PtrType)(unsafe.Pointer(v))
 	case *runtime.SliceType:
-		return (*SliceType)(unsafe.Pointer(v));
+		return (*SliceType)(unsafe.Pointer(v))
 	case *runtime.StructType:
-		return (*StructType)(unsafe.Pointer(v));
+		return (*StructType)(unsafe.Pointer(v))
 	}
 	panicln("toType", i);
 }
diff --git a/src/pkg/reflect/value.go b/src/pkg/reflect/value.go
index 3935e63538..4ebd49fb2b 100644
--- a/src/pkg/reflect/value.go
+++ b/src/pkg/reflect/value.go
@@ -30,12 +30,12 @@ func memmove(adst, asrc addr, n uintptr) {
 	case (n|src|dst)&(ptrSize-1) != 0:
 		// byte copy forward
 		for i := uintptr(0); i < n; i++ {
-			*(*byte)(addr(dst+i)) = *(*byte)(addr(src+i));
+			*(*byte)(addr(dst+i)) = *(*byte)(addr(src+i))
 		}
 	default:
 		// word copy forward
 		for i := uintptr(0); i < n; i += ptrSize {
-			*(*uintptr)(addr(dst+i)) = *(*uintptr)(addr(src+i));
+			*(*uintptr)(addr(dst+i)) = *(*uintptr)(addr(src+i))
 		}
 	}
 }
@@ -94,7 +94,7 @@ func (v *value) Interface() interface{} {
 		// to extract correctly.
 		if typ.NumMethod() == 0 {
 			// Extract as interface value without methods.
-			return *(*interface{})(v.addr);
+			return *(*interface{})(v.addr)
 		}
 		// Extract from v.addr as interface value with methods.
 		return *(*interface {
@@ -121,7 +121,7 @@ func (v *BoolValue) Get() bool	{ return *(*bool)(v.addr) }
 // Set sets v to the value x.
 func (v *BoolValue) Set(x bool) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	*(*bool)(v.addr) = x;
 }
@@ -140,7 +140,7 @@ func (v *FloatValue) Get() float	{ return *(*float)(v.addr) }
 // Set sets v to the value x.
 func (v *FloatValue) Set(x float) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	*(*float)(v.addr) = x;
 }
@@ -159,7 +159,7 @@ func (v *Float32Value) Get() float32	{ return *(*float32)(v.addr) }
 // Set sets v to the value x.
 func (v *Float32Value) Set(x float32) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	*(*float32)(v.addr) = x;
 }
@@ -178,7 +178,7 @@ func (v *Float64Value) Get() float64	{ return *(*float64)(v.addr) }
 // Set sets v to the value x.
 func (v *Float64Value) Set(x float64) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	*(*float64)(v.addr) = x;
 }
@@ -197,7 +197,7 @@ func (v *IntValue) Get() int	{ return *(*int)(v.addr) }
 // Set sets v to the value x.
 func (v *IntValue) Set(x int) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	*(*int)(v.addr) = x;
 }
@@ -216,7 +216,7 @@ func (v *Int8Value) Get() int8	{ return *(*int8)(v.addr) }
 // Set sets v to the value x.
 func (v *Int8Value) Set(x int8) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	*(*int8)(v.addr) = x;
 }
@@ -235,7 +235,7 @@ func (v *Int16Value) Get() int16	{ return *(*int16)(v.addr) }
 // Set sets v to the value x.
 func (v *Int16Value) Set(x int16) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	*(*int16)(v.addr) = x;
 }
@@ -254,7 +254,7 @@ func (v *Int32Value) Get() int32	{ return *(*int32)(v.addr) }
 // Set sets v to the value x.
 func (v *Int32Value) Set(x int32) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	*(*int32)(v.addr) = x;
 }
@@ -273,7 +273,7 @@ func (v *Int64Value) Get() int64	{ return *(*int64)(v.addr) }
 // Set sets v to the value x.
 func (v *Int64Value) Set(x int64) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	*(*int64)(v.addr) = x;
 }
@@ -292,7 +292,7 @@ func (v *StringValue) Get() string	{ return *(*string)(v.addr) }
 // Set sets v to the value x.
 func (v *StringValue) Set(x string) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	*(*string)(v.addr) = x;
 }
@@ -311,7 +311,7 @@ func (v *UintValue) Get() uint	{ return *(*uint)(v.addr) }
 // Set sets v to the value x.
 func (v *UintValue) Set(x uint) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	*(*uint)(v.addr) = x;
 }
@@ -330,7 +330,7 @@ func (v *Uint8Value) Get() uint8	{ return *(*uint8)(v.addr) }
 // Set sets v to the value x.
 func (v *Uint8Value) Set(x uint8) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	*(*uint8)(v.addr) = x;
 }
@@ -349,7 +349,7 @@ func (v *Uint16Value) Get() uint16	{ return *(*uint16)(v.addr) }
 // Set sets v to the value x.
 func (v *Uint16Value) Set(x uint16) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	*(*uint16)(v.addr) = x;
 }
@@ -368,7 +368,7 @@ func (v *Uint32Value) Get() uint32	{ return *(*uint32)(v.addr) }
 // Set sets v to the value x.
 func (v *Uint32Value) Set(x uint32) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	*(*uint32)(v.addr) = x;
 }
@@ -387,7 +387,7 @@ func (v *Uint64Value) Get() uint64	{ return *(*uint64)(v.addr) }
 // Set sets v to the value x.
 func (v *Uint64Value) Set(x uint64) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	*(*uint64)(v.addr) = x;
 }
@@ -406,7 +406,7 @@ func (v *UintptrValue) Get() uintptr	{ return *(*uintptr)(v.addr) }
 // Set sets v to the value x.
 func (v *UintptrValue) Set(x uintptr) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	*(*uintptr)(v.addr) = x;
 }
@@ -428,19 +428,19 @@ func (v *UnsafePointerValue) Get() uintptr	{ return uintptr(*(*unsafe.Pointer)(v
 // Set sets v to the value x.
 func (v *UnsafePointerValue) Set(x unsafe.Pointer) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	*(*unsafe.Pointer)(v.addr) = x;
 }
 
 // Set sets v to the value x.
 func (v *UnsafePointerValue) SetValue(x Value) {
-	v.Set(unsafe.Pointer(x.(*UnsafePointerValue).Get()));
+	v.Set(unsafe.Pointer(x.(*UnsafePointerValue).Get()))
 }
 
 func typesMustMatch(t1, t2 Type) {
 	if t1 != t2 {
-		panicln("type mismatch:", t1.String(), "!=", t2.String());
+		panicln("type mismatch:", t1.String(), "!=", t2.String())
 	}
 }
 
@@ -470,7 +470,7 @@ func ArrayCopy(dst, src ArrayOrSliceValue) int {
 	typesMustMatch(de, se);
 	n := dst.Len();
 	if xn := src.Len(); n > xn {
-		n = xn;
+		n = xn
 	}
 	memmove(dst.addr(), src.addr(), uintptr(n) * de.Size());
 	return n;
@@ -494,7 +494,7 @@ func (v *ArrayValue) addr() addr	{ return v.value.addr }
 // The new value x must have the same type as v.
 func (v *ArrayValue) Set(x *ArrayValue) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	typesMustMatch(v.typ, x.typ);
 	ArrayCopy(v, x);
@@ -508,7 +508,7 @@ func (v *ArrayValue) Elem(i int) Value {
 	typ := v.typ.(*ArrayType).Elem();
 	n := v.Len();
 	if i < 0 || i >= n {
-		panic("index", i, "in array len", n);
+		panic("index", i, "in array len", n)
 	}
 	p := addr(uintptr(v.addr()) + uintptr(i) * typ.Size());
 	return newValue(typ, p, v.canSet);
@@ -549,7 +549,7 @@ func (v *SliceValue) addr() addr	{ return addr(v.slice().Data) }
 func (v *SliceValue) SetLen(n int) {
 	s := v.slice();
 	if n < 0 || n > int(s.Cap) {
-		panicln("SetLen", n, "with capacity", s.Cap);
+		panicln("SetLen", n, "with capacity", s.Cap)
 	}
 	s.Len = n;
 }
@@ -558,7 +558,7 @@ func (v *SliceValue) SetLen(n int) {
 // The new value x must have the same type as v.
 func (v *SliceValue) Set(x *SliceValue) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	typesMustMatch(v.typ, x.typ);
 	*v.slice() = *x.slice();
@@ -571,7 +571,7 @@ func (v *SliceValue) SetValue(x Value)	{ v.Set(x.(*SliceValue)) }
 func (v *SliceValue) Slice(beg, end int) *SliceValue {
 	cap := v.Cap();
 	if beg < 0 || end < beg || end > cap {
-		panic("slice bounds [", beg, ":", end, "] with capacity ", cap);
+		panic("slice bounds [", beg, ":", end, "] with capacity ", cap)
 	}
 	typ := v.typ.(*SliceType);
 	s := new(SliceHeader);
@@ -586,7 +586,7 @@ func (v *SliceValue) Elem(i int) Value {
 	typ := v.typ.(*SliceType).Elem();
 	n := v.Len();
 	if i < 0 || i >= n {
-		panicln("index", i, "in array of length", n);
+		panicln("index", i, "in array of length", n)
 	}
 	p := addr(uintptr(v.addr()) + uintptr(i) * typ.Size());
 	return newValue(typ, p, v.canSet);
@@ -598,7 +598,7 @@ func MakeSlice(typ *SliceType, len, cap int) *SliceValue {
 	s := new(SliceHeader);
 	size := typ.Elem().Size() * uintptr(cap);
 	if size == 0 {
-		size = 1;
+		size = 1
 	}
 	data := make([]uint8, size);
 	s.Data = uintptr(addr(&data[0]));
@@ -623,7 +623,7 @@ func (v *ChanValue) IsNil() bool	{ return *(*uintptr)(v.addr) == 0 }
 // The new value x must have the same type as v.
 func (v *ChanValue) Set(x *ChanValue) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	typesMustMatch(v.typ, x.typ);
 	*(*uintptr)(v.addr) = *(*uintptr)(x.addr);
@@ -671,7 +671,7 @@ func (v *ChanValue) Cap() int {
 func (v *ChanValue) send(x Value, b *bool) {
 	t := v.Type().(*ChanType);
 	if t.Dir() & SendDir == 0 {
-		panic("send on recv-only channel");
+		panic("send on recv-only channel")
 	}
 	typesMustMatch(t.Elem(), x.Type());
 	ch := *(**byte)(v.addr);
@@ -682,7 +682,7 @@ func (v *ChanValue) send(x Value, b *bool) {
 func (v *ChanValue) recv(b *bool) Value {
 	t := v.Type().(*ChanType);
 	if t.Dir() & RecvDir == 0 {
-		panic("recv on send-only channel");
+		panic("recv on send-only channel")
 	}
 	ch := *(**byte)(v.addr);
 	x := MakeZero(t.Elem());
@@ -710,7 +710,7 @@ func (v *ChanValue) TryRecv() Value {
 	var ok bool;
 	x := v.recv(&ok);
 	if !ok {
-		return nil;
+		return nil
 	}
 	return x;
 }
@@ -718,10 +718,10 @@ func (v *ChanValue) TryRecv() Value {
 // MakeChan creates a new channel with the specified type and buffer size.
 func MakeChan(typ *ChanType, buffer int) *ChanValue {
 	if buffer < 0 {
-		panic("MakeChan: negative buffer size");
+		panic("MakeChan: negative buffer size")
 	}
 	if typ.Dir() != BothDir {
-		panic("MakeChan: unidirectional channel type");
+		panic("MakeChan: unidirectional channel type")
 	}
 	v := MakeZero(typ).(*ChanValue);
 	*(**byte)(v.addr) = makechan((*runtime.ChanType)(unsafe.Pointer(typ)), uint32(buffer));
@@ -750,7 +750,7 @@ func (v *FuncValue) Get() uintptr	{ return *(*uintptr)(v.addr) }
 // The new value x must have the same type as v.
 func (v *FuncValue) Set(x *FuncValue) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	typesMustMatch(v.typ, x.typ);
 	*(*uintptr)(v.addr) = *(*uintptr)(x.addr);
@@ -766,7 +766,7 @@ func (v *FuncValue) SetValue(x Value)	{ v.Set(x.(*FuncValue)) }
 func (v *value) Method(i int) *FuncValue {
 	t := v.Type().uncommon();
 	if t == nil || i < 0 || i >= len(t.methods) {
-		return nil;
+		return nil
 	}
 	p := &t.methods[i];
 	fn := p.tfn;
@@ -789,10 +789,10 @@ func (fv *FuncValue) Call(in []Value) []Value {
 	t := fv.Type().(*FuncType);
 	nin := len(in);
 	if fv.first != nil && !fv.isInterface {
-		nin++;
+		nin++
 	}
 	if nin != t.NumIn() {
-		panic("FuncValue: wrong argument count");
+		panic("FuncValue: wrong argument count")
 	}
 	nout := t.NumOut();
 
@@ -803,7 +803,7 @@ func (fv *FuncValue) Call(in []Value) []Value {
 	size := uintptr(0);
 	if fv.isInterface {
 		// extra word for interface value
-		size += ptrSize;
+		size += ptrSize
 	}
 	for i := 0; i < nin; i++ {
 		tv := t.In(i);
@@ -823,7 +823,7 @@ func (fv *FuncValue) Call(in []Value) []Value {
 	// the argument copying is going to round it up to
 	// a multiple of 8 anyway, so make it 8 to begin with.
 	if size < 8 {
-		size = 8;
+		size = 8
 	}
 	args := make([]byte, size);
 	ptr := uintptr(unsafe.Pointer(&args[0]));
@@ -908,7 +908,7 @@ func setiface(typ *InterfaceType, x *interface{}, addr addr)
 func (v *InterfaceValue) Set(x Value) {
 	i := x.Interface();
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	// Two different representations; see comment in Get.
 	// Empty interface is easy.
@@ -932,7 +932,7 @@ func (v *InterfaceValue) SetValue(x Value)	{ v.Set(x) }
 func (v *InterfaceValue) Method(i int) *FuncValue {
 	t := v.Type().(*InterfaceType);
 	if t == nil || i < 0 || i >= len(t.methods) {
-		return nil;
+		return nil
 	}
 	p := &t.methods[i];
 
@@ -962,7 +962,7 @@ func (v *MapValue) IsNil() bool	{ return *(*uintptr)(v.addr) == 0 }
 // The new value x must have the same type as v.
 func (v *MapValue) Set(x *MapValue) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	typesMustMatch(v.typ, x.typ);
 	*(*uintptr)(v.addr) = *(*uintptr)(x.addr);
@@ -987,11 +987,11 @@ func (v *MapValue) Elem(key Value) Value {
 	typesMustMatch(t.Key(), key.Type());
 	m := *(**byte)(v.addr);
 	if m == nil {
-		return nil;
+		return nil
 	}
 	newval := MakeZero(t.Elem());
 	if !mapaccess(m, (*byte)(key.getAddr()), (*byte)(newval.getAddr())) {
-		return nil;
+		return nil
 	}
 	return newval;
 }
@@ -1014,7 +1014,7 @@ func (v *MapValue) SetElem(key, val Value) {
 func (v *MapValue) Len() int {
 	m := *(**byte)(v.addr);
 	if m == nil {
-		return 0;
+		return 0
 	}
 	return int(maplen(m));
 }
@@ -1026,7 +1026,7 @@ func (v *MapValue) Keys() []Value {
 	m := *(**byte)(v.addr);
 	mlen := int32(0);
 	if m != nil {
-		mlen = maplen(m);
+		mlen = maplen(m)
 	}
 	it := mapiterinit(m);
 	a := make([]Value, mlen);
@@ -1034,7 +1034,7 @@ func (v *MapValue) Keys() []Value {
 	for i = 0; i < len(a); i++ {
 		k := MakeZero(tk);
 		if !mapiterkey(it, (*byte)(k.getAddr())) {
-			break;
+			break
 		}
 		a[i] = k;
 		mapiternext(it);
@@ -1069,7 +1069,7 @@ func (v *PtrValue) Get() uintptr	{ return *(*uintptr)(v.addr) }
 // The new value x must have the same type as v.
 func (v *PtrValue) Set(x *PtrValue) {
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	typesMustMatch(v.typ, x.typ);
 	// TODO: This will have to move into the runtime
@@ -1083,7 +1083,7 @@ func (v *PtrValue) SetValue(x Value)	{ v.Set(x.(*PtrValue)) }
 // PointTo changes v to point to x.
 func (v *PtrValue) PointTo(x Value) {
 	if !x.CanSet() {
-		panic("cannot set x; cannot point to x");
+		panic("cannot set x; cannot point to x")
 	}
 	typesMustMatch(v.typ.(*PtrType).Elem(), x.Type());
 	// TODO: This will have to move into the runtime
@@ -1095,7 +1095,7 @@ func (v *PtrValue) PointTo(x Value) {
 // If v is a nil pointer, Elem returns a nil Value.
 func (v *PtrValue) Elem() Value {
 	if v.IsNil() {
-		return nil;
+		return nil
 	}
 	return newValue(v.typ.(*PtrType).Elem(), *(*addr)(v.addr), v.canSet);
 }
@@ -1105,7 +1105,7 @@ func (v *PtrValue) Elem() Value {
 // If v is not a pointer, Indirect returns v.
 func Indirect(v Value) Value {
 	if pv, ok := v.(*PtrValue); ok {
-		return pv.Elem();
+		return pv.Elem()
 	}
 	return v;
 }
@@ -1125,7 +1125,7 @@ func (v *StructValue) Set(x *StructValue) {
 	// TODO: This will have to move into the runtime
 	// once the gc goes in.
 	if !v.canSet {
-		panic(cannotSet);
+		panic(cannotSet)
 	}
 	typesMustMatch(v.typ, x.typ);
 	memmove(v.addr, x.addr, v.typ.Size());
@@ -1138,7 +1138,7 @@ func (v *StructValue) SetValue(x Value)	{ v.Set(x.(*StructValue)) }
 func (v *StructValue) Field(i int) Value {
 	t := v.typ.(*StructType);
 	if i < 0 || i >= t.NumField() {
-		return nil;
+		return nil
 	}
 	f := t.Field(i);
 	return newValue(f.Type, addr(uintptr(v.addr) + f.Offset), v.canSet && f.PkgPath == "");
@@ -1150,10 +1150,10 @@ func (t *StructValue) FieldByIndex(index []int) (v Value) {
 	for i, x := range index {
 		if i > 0 {
 			if p, ok := v.(*PtrValue); ok {
-				v = p.Elem();
+				v = p.Elem()
 			}
 			if s, ok := v.(*StructValue); ok {
-				t = s;
+				t = s
 			} else {
 				v = nil;
 				return;
@@ -1168,7 +1168,7 @@ func (t *StructValue) FieldByIndex(index []int) (v Value) {
 // The result is nil if no field was found.
 func (t *StructValue) FieldByName(name string) Value {
 	if f, ok := t.Type().(*StructType).FieldByName(name); ok {
-		return t.FieldByIndex(f.Index);
+		return t.FieldByIndex(f.Index)
 	}
 	return nil;
 }
@@ -1184,7 +1184,7 @@ func (v *StructValue) NumField() int	{ return v.typ.(*StructType).NumField() }
 // stored in the interface i.  NewValue(nil) returns nil.
 func NewValue(i interface{}) Value {
 	if i == nil {
-		return nil;
+		return nil
 	}
 	t, a := unsafe.Reflect(i);
 	return newValue(toType(t), addr(a), true);
@@ -1192,14 +1192,14 @@ func NewValue(i interface{}) Value {
 
 
 func newFuncValue(typ Type, addr addr, canSet bool) *FuncValue {
-	return &FuncValue{value: value{typ, addr, canSet}};
+	return &FuncValue{value: value{typ, addr, canSet}}
 }
 
 func newValue(typ Type, addr addr, canSet bool) Value {
 	// FuncValue has a different layout;
 	// it needs a extra space for the fixed receivers.
 	if _, ok := typ.(*FuncType); ok {
-		return newFuncValue(typ, addr, canSet);
+		return newFuncValue(typ, addr, canSet)
 	}
 
 	// All values have same memory layout;
@@ -1214,53 +1214,53 @@ func newValue(typ Type, addr addr, canSet bool) Value {
 		// they're our types.
 		// Something about implicit assignment
 		// to struct fields.
-		return (*ArrayValue)(v);
+		return (*ArrayValue)(v)
 	case *BoolType:
-		return (*BoolValue)(v);
+		return (*BoolValue)(v)
 	case *ChanType:
-		return (*ChanValue)(v);
+		return (*ChanValue)(v)
 	case *FloatType:
-		return (*FloatValue)(v);
+		return (*FloatValue)(v)
 	case *Float32Type:
-		return (*Float32Value)(v);
+		return (*Float32Value)(v)
 	case *Float64Type:
-		return (*Float64Value)(v);
+		return (*Float64Value)(v)
 	case *IntType:
-		return (*IntValue)(v);
+		return (*IntValue)(v)
 	case *Int8Type:
-		return (*Int8Value)(v);
+		return (*Int8Value)(v)
 	case *Int16Type:
-		return (*Int16Value)(v);
+		return (*Int16Value)(v)
 	case *Int32Type:
-		return (*Int32Value)(v);
+		return (*Int32Value)(v)
 	case *Int64Type:
-		return (*Int64Value)(v);
+		return (*Int64Value)(v)
 	case *InterfaceType:
-		return (*InterfaceValue)(v);
+		return (*InterfaceValue)(v)
 	case *MapType:
-		return (*MapValue)(v);
+		return (*MapValue)(v)
 	case *PtrType:
-		return (*PtrValue)(v);
+		return (*PtrValue)(v)
 	case *SliceType:
-		return (*SliceValue)(v);
+		return (*SliceValue)(v)
 	case *StringType:
-		return (*StringValue)(v);
+		return (*StringValue)(v)
 	case *StructType:
-		return (*StructValue)(v);
+		return (*StructValue)(v)
 	case *UintType:
-		return (*UintValue)(v);
+		return (*UintValue)(v)
 	case *Uint8Type:
-		return (*Uint8Value)(v);
+		return (*Uint8Value)(v)
 	case *Uint16Type:
-		return (*Uint16Value)(v);
+		return (*Uint16Value)(v)
 	case *Uint32Type:
-		return (*Uint32Value)(v);
+		return (*Uint32Value)(v)
 	case *Uint64Type:
-		return (*Uint64Value)(v);
+		return (*Uint64Value)(v)
 	case *UintptrType:
-		return (*UintptrValue)(v);
+		return (*UintptrValue)(v)
 	case *UnsafePointerType:
-		return (*UnsafePointerValue)(v);
+		return (*UnsafePointerValue)(v)
 	}
 	panicln("newValue", typ.String());
 }
@@ -1272,7 +1272,7 @@ func MakeZero(typ Type) Value {
 	// with the garbage collector.
 	size := typ.Size();
 	if size == 0 {
-		size = 1;
+		size = 1
 	}
 	data := make([]uint8, size);
 	return newValue(typ, addr(&data[0]), true);
diff --git a/src/pkg/regexp/all_test.go b/src/pkg/regexp/all_test.go
index 2cd2fecf7b..08f99dd68d 100644
--- a/src/pkg/regexp/all_test.go
+++ b/src/pkg/regexp/all_test.go
@@ -91,7 +91,7 @@ var matches = []tester{
 func compileTest(t *testing.T, expr string, error os.Error) *Regexp {
 	re, err := Compile(expr);
 	if err != error {
-		t.Error("compiling `", expr, "`; unexpected error: ", err.String());
+		t.Error("compiling `", expr, "`; unexpected error: ", err.String())
 	}
 	return re;
 }
@@ -99,10 +99,10 @@ func compileTest(t *testing.T, expr string, error os.Error) *Regexp {
 func printVec(t *testing.T, m []int) {
 	l := len(m);
 	if l == 0 {
-		t.Log("\t<no match>");
+		t.Log("\t<no match>")
 	} else {
 		for i := 0; i < l; i = i+2 {
-			t.Log("\t", m[i], ",", m[i+1]);
+			t.Log("\t", m[i], ",", m[i+1])
 		}
 	}
 }
@@ -110,10 +110,10 @@ func printVec(t *testing.T, m []int) {
 func printStrings(t *testing.T, m []string) {
 	l := len(m);
 	if l == 0 {
-		t.Log("\t<no match>");
+		t.Log("\t<no match>")
 	} else {
 		for i := 0; i < l; i = i+2 {
-			t.Logf("\t%q", m[i]);
+			t.Logf("\t%q", m[i])
 		}
 	}
 }
@@ -121,10 +121,10 @@ func printStrings(t *testing.T, m []string) {
 func printBytes(t *testing.T, b [][]byte) {
 	l := len(b);
 	if l == 0 {
-		t.Log("\t<no match>");
+		t.Log("\t<no match>")
 	} else {
 		for i := 0; i < l; i = i+2 {
-			t.Logf("\t%q", b[i]);
+			t.Logf("\t%q", b[i])
 		}
 	}
 }
@@ -132,11 +132,11 @@ func printBytes(t *testing.T, b [][]byte) {
 func equal(m1, m2 []int) bool {
 	l := len(m1);
 	if l != len(m2) {
-		return false;
+		return false
 	}
 	for i := 0; i < l; i++ {
 		if m1[i] != m2[i] {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -145,11 +145,11 @@ func equal(m1, m2 []int) bool {
 func equalStrings(m1, m2 []string) bool {
 	l := len(m1);
 	if l != len(m2) {
-		return false;
+		return false
 	}
 	for i := 0; i < l; i++ {
 		if m1[i] != m2[i] {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -158,11 +158,11 @@ func equalStrings(m1, m2 []string) bool {
 func equalBytes(m1 [][]byte, m2 []string) bool {
 	l := len(m1);
 	if l != len(m2) {
-		return false;
+		return false
 	}
 	for i := 0; i < l; i++ {
 		if string(m1[i]) != m2[i] {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -171,7 +171,7 @@ func equalBytes(m1 [][]byte, m2 []string) bool {
 func executeTest(t *testing.T, expr string, str string, match []int) {
 	re := compileTest(t, expr, nil);
 	if re == nil {
-		return;
+		return
 	}
 	m := re.ExecuteString(str);
 	if !equal(m, match) {
@@ -192,13 +192,13 @@ func executeTest(t *testing.T, expr string, str string, match []int) {
 
 func TestGoodCompile(t *testing.T) {
 	for i := 0; i < len(good_re); i++ {
-		compileTest(t, good_re[i], nil);
+		compileTest(t, good_re[i], nil)
 	}
 }
 
 func TestBadCompile(t *testing.T) {
 	for i := 0; i < len(bad_re); i++ {
-		compileTest(t, bad_re[i].re, bad_re[i].err);
+		compileTest(t, bad_re[i].re, bad_re[i].err)
 	}
 }
 
@@ -212,16 +212,16 @@ func TestExecute(t *testing.T) {
 func matchTest(t *testing.T, expr string, str string, match []int) {
 	re := compileTest(t, expr, nil);
 	if re == nil {
-		return;
+		return
 	}
 	m := re.MatchString(str);
 	if m != (len(match) > 0) {
-		t.Error("MatchString failure on `", expr, "` matching `", str, "`:", m, "should be", len(match) > 0);
+		t.Error("MatchString failure on `", expr, "` matching `", str, "`:", m, "should be", len(match) > 0)
 	}
 	// now try bytes
 	m = re.Match(strings.Bytes(str));
 	if m != (len(match) > 0) {
-		t.Error("Match failure on `", expr, "` matching `", str, "`:", m, "should be", len(match) > 0);
+		t.Error("Match failure on `", expr, "` matching `", str, "`:", m, "should be", len(match) > 0)
 	}
 }
 
@@ -235,11 +235,11 @@ func TestMatch(t *testing.T) {
 func matchStringsTest(t *testing.T, expr string, str string, match []int) {
 	re := compileTest(t, expr, nil);
 	if re == nil {
-		return;
+		return
 	}
 	strs := make([]string, len(match)/2);
 	for i := 0; i < len(match); i++ {
-		strs[i/2] = str[match[i]:match[i+1]];
+		strs[i/2] = str[match[i]:match[i+1]]
 	}
 	m := re.MatchStrings(str);
 	if !equalStrings(m, strs) {
@@ -268,10 +268,10 @@ func TestMatchStrings(t *testing.T) {
 func matchFunctionTest(t *testing.T, expr string, str string, match []int) {
 	m, err := MatchString(expr, str);
 	if err == nil {
-		return;
+		return
 	}
 	if m != (len(match) > 0) {
-		t.Error("function Match failure on `", expr, "` matching `", str, "`:", m, "should be", len(match) > 0);
+		t.Error("function Match failure on `", expr, "` matching `", str, "`:", m, "should be", len(match) > 0)
 	}
 }
 
@@ -358,13 +358,13 @@ func TestReplaceAll(t *testing.T) {
 		actual := re.ReplaceAllString(tc.input, tc.replacement);
 		if actual != tc.output {
 			t.Errorf("%q.Replace(%q,%q) = %q; want %q",
-				tc.pattern, tc.input, tc.replacement, actual, tc.output);
+				tc.pattern, tc.input, tc.replacement, actual, tc.output)
 		}
 		// now try bytes
 		actual = string(re.ReplaceAll(strings.Bytes(tc.input), strings.Bytes(tc.replacement)));
 		if actual != tc.output {
 			t.Errorf("%q.Replace(%q,%q) = %q; want %q",
-				tc.pattern, tc.input, tc.replacement, actual, tc.output);
+				tc.pattern, tc.input, tc.replacement, actual, tc.output)
 		}
 	}
 }
@@ -403,7 +403,7 @@ func TestQuoteMeta(t *testing.T) {
 			expected := "abcxyzdef";
 			if replaced != expected {
 				t.Errorf("QuoteMeta(`%s`).Replace(`%s`,`%s`) = `%s`; want `%s`",
-					tc.pattern, src, repl, replaced, expected);
+					tc.pattern, src, repl, replaced, expected)
 			}
 		}
 	}
@@ -439,10 +439,10 @@ var matchCases = []matchCase{
 func printStringSlice(t *testing.T, s []string) {
 	l := len(s);
 	if l == 0 {
-		t.Log("\t<empty>");
+		t.Log("\t<empty>")
 	} else {
 		for i := 0; i < l; i++ {
-			t.Logf("\t%q", s[i]);
+			t.Logf("\t%q", s[i])
 		}
 	}
 }
@@ -496,7 +496,7 @@ func TestAllMatches(t *testing.T) {
 			}
 			result = result[0:i];
 		case "stringmatch":
-			result = re.AllMatchesString(c.input, c.n);
+			result = re.AllMatchesString(c.input, c.n)
 		}
 
 		if !equalStrings(result, c.expected) {
diff --git a/src/pkg/regexp/regexp.go b/src/pkg/regexp/regexp.go
index 24fd597f77..bc56724a08 100644
--- a/src/pkg/regexp/regexp.go
+++ b/src/pkg/regexp/regexp.go
@@ -153,15 +153,15 @@ func (cclass *_CharClass) kind() int	{ return _CHARCLASS }
 func (cclass *_CharClass) print() {
 	print("charclass");
 	if cclass.negate {
-		print(" (negated)");
+		print(" (negated)")
 	}
 	for i := 0; i < cclass.ranges.Len(); i += 2 {
 		l := cclass.ranges.At(i);
 		r := cclass.ranges.At(i+1);
 		if l == r {
-			print(" [", string(l), "]");
+			print(" [", string(l), "]")
 		} else {
-			print(" [", string(l), "-", string(r), "]");
+			print(" [", string(l), "-", string(r), "]")
 		}
 	}
 }
@@ -177,7 +177,7 @@ func (cclass *_CharClass) matches(c int) bool {
 		min := cclass.ranges.At(i);
 		max := cclass.ranges.At(i+1);
 		if min <= c && c <= max {
-			return !cclass.negate;
+			return !cclass.negate
 		}
 	}
 	return cclass.negate;
@@ -260,7 +260,7 @@ func (p *parser) c() int	{ return p.ch }
 
 func (p *parser) nextc() int {
 	if p.pos >= len(p.re.expr) {
-		p.ch = endOfFile;
+		p.ch = endOfFile
 	} else {
 		c, w := utf8.DecodeRuneInString(p.re.expr[p.pos : len(p.re.expr)]);
 		p.ch = c;
@@ -280,7 +280,7 @@ func special(c int) bool {
 	s := `\.+*?()|[]^$`;
 	for i := 0; i < len(s); i++ {
 		if c == int(s[i]) {
-			return true;
+			return true
 		}
 	}
 	return false;
@@ -290,7 +290,7 @@ func specialcclass(c int) bool {
 	s := `\-[]`;
 	for i := 0; i < len(s); i++ {
 		if c == int(s[i]) {
-			return true;
+			return true
 		}
 	}
 	return false;
@@ -329,7 +329,7 @@ func (p *parser) charClass() instr {
 				p.error = ErrExtraneousBackslash;
 				return nil;
 			case c == 'n':
-				c = '\n';
+				c = '\n'
 			case specialcclass(c):
 				// c is as delivered
 			default:
@@ -345,7 +345,7 @@ func (p *parser) charClass() instr {
 					p.nextc();
 					left = c;
 				} else {	// single char
-					cc.addRange(c, c);
+					cc.addRange(c, c)
 				}
 			case left <= c:	// second of pair
 				cc.addRange(left, c);
@@ -365,11 +365,11 @@ func (p *parser) term() (start, end instr) {
 	// The other functions (closure(), concatenation() etc.) assume
 	// it's safe to recur to here.
 	if p.error != nil {
-		return;
+		return
 	}
 	switch c := p.c(); c {
 	case '|', endOfFile:
-		return nil, nil;
+		return nil, nil
 	case '*', '+':
 		p.error = ErrBareClosure;
 		return;
@@ -398,7 +398,7 @@ func (p *parser) term() (start, end instr) {
 		p.nextc();
 		start = p.charClass();
 		if p.error != nil {
-			return;
+			return
 		}
 		if p.c() != ']' {
 			p.error = ErrUnmatchedLbkt;
@@ -431,7 +431,7 @@ func (p *parser) term() (start, end instr) {
 			}
 			start = ebra;
 		} else {
-			end.setNext(ebra);
+			end.setNext(ebra)
 		}
 		bra.setNext(start);
 		return bra, ebra;
@@ -442,7 +442,7 @@ func (p *parser) term() (start, end instr) {
 			p.error = ErrExtraneousBackslash;
 			return;
 		case c == 'n':
-			c = '\n';
+			c = '\n'
 		case special(c):
 			// c is as delivered
 		default:
@@ -462,7 +462,7 @@ func (p *parser) term() (start, end instr) {
 func (p *parser) closure() (start, end instr) {
 	start, end = p.term();
 	if start == nil || p.error != nil {
-		return;
+		return
 	}
 	switch p.c() {
 	case '*':
@@ -492,11 +492,11 @@ func (p *parser) closure() (start, end instr) {
 		start = alt;		// start is now alt
 		end = nop;		// end is nop pointed to by both branches
 	default:
-		return;
+		return
 	}
 	switch p.nextc() {
 	case '*', '+', '?':
-		p.error = ErrBadClosure;
+		p.error = ErrBadClosure
 	}
 	return;
 }
@@ -505,7 +505,7 @@ func (p *parser) concatenation() (start, end instr) {
 	for {
 		nstart, nend := p.closure();
 		if p.error != nil {
-			return;
+			return
 		}
 		switch {
 		case nstart == nil:	// end of this concatenation
@@ -515,7 +515,7 @@ func (p *parser) concatenation() (start, end instr) {
 			}
 			return;
 		case start == nil:	// this is first element of concatenation
-			start, end = nstart, nend;
+			start, end = nstart, nend
 		default:
 			end.setNext(nstart);
 			end = nend;
@@ -527,17 +527,17 @@ func (p *parser) concatenation() (start, end instr) {
 func (p *parser) regexp() (start, end instr) {
 	start, end = p.concatenation();
 	if p.error != nil {
-		return;
+		return
 	}
 	for {
 		switch p.c() {
 		default:
-			return;
+			return
 		case '|':
 			p.nextc();
 			nstart, nend := p.concatenation();
 			if p.error != nil {
-				return;
+				return
 			}
 			alt := new(_Alt);
 			p.re.add(alt);
@@ -555,7 +555,7 @@ func (p *parser) regexp() (start, end instr) {
 
 func unNop(i instr) instr {
 	for i.kind() == _NOP {
-		i = i.next();
+		i = i.next()
 	}
 	return i;
 }
@@ -564,7 +564,7 @@ func (re *Regexp) eliminateNops() {
 	for i := 0; i < re.inst.Len(); i++ {
 		inst := re.inst.At(i).(instr);
 		if inst.kind() == _END {
-			continue;
+			continue
 		}
 		inst.setNext(unNop(inst.next()));
 		if inst.kind() == _ALT {
@@ -580,7 +580,7 @@ func (re *Regexp) dump() {
 		print(inst.index(), ": ");
 		inst.print();
 		if inst.kind() != _END {
-			print(" -> ", inst.next().index());
+			print(" -> ", inst.next().index())
 		}
 		print("\n");
 	}
@@ -592,7 +592,7 @@ func (re *Regexp) doParse() os.Error {
 	re.add(start);
 	s, e := p.regexp();
 	if p.error != nil {
-		return p.error;
+		return p.error
 	}
 	start.setNext(s);
 	re.start = start;
@@ -627,7 +627,7 @@ func Compile(str string) (regexp *Regexp, error os.Error) {
 func MustCompile(str string) *Regexp {
 	regexp, error := Compile(str);
 	if error != nil {
-		panicln(`regexp: compiling "`, str, `": `, error.String());
+		panicln(`regexp: compiling "`, str, `": `, error.String())
 	}
 	return regexp;
 }
@@ -648,13 +648,13 @@ func addState(s []state, inst instr, match []int) []state {
 	for i := 0; i < l; i++ {
 		if s[i].inst.index() == index &&	// same instruction
 			s[i].match[0] < pos {	// earlier match already going; lefmost wins
-			return s;
+			return s
 		}
 	}
 	if l == cap(s) {
 		s1 := make([]state, 2*l)[0:l];
 		for i := 0; i < l; i++ {
-			s1[i] = s[i];
+			s1[i] = s[i]
 		}
 		s = s1;
 	}
@@ -675,14 +675,14 @@ func (re *Regexp) doExecute(str string, bytes []byte, pos int) []int {
 	found := false;
 	end := len(str);
 	if bytes != nil {
-		end = len(bytes);
+		end = len(bytes)
 	}
 	for pos <= end {
 		if !found {
 			// prime the pump if we haven't seen a match yet
 			match := make([]int, 2*(re.nbra + 1));
 			for i := 0; i < len(match); i++ {
-				match[i] = -1;	// no match seen; catches cases like "a(b)?c" on "ac"
+				match[i] = -1	// no match seen; catches cases like "a(b)?c" on "ac"
 			}
 			match[0] = pos;
 			s[out] = addState(s[out], re.start.next(), match);
@@ -691,15 +691,15 @@ func (re *Regexp) doExecute(str string, bytes []byte, pos int) []int {
 		s[out] = s[out][0:0];	// clear out state
 		if len(s[in]) == 0 {
 			// machine has completed
-			break;
+			break
 		}
 		charwidth := 1;
 		c := endOfFile;
 		if pos < end {
 			if bytes == nil {
-				c, charwidth = utf8.DecodeRuneInString(str[pos:end]);
+				c, charwidth = utf8.DecodeRuneInString(str[pos:end])
 			} else {
-				c, charwidth = utf8.DecodeRune(bytes[pos:end]);
+				c, charwidth = utf8.DecodeRune(bytes[pos:end])
 			}
 		}
 		for i := 0; i < len(s[in]); i++ {
@@ -707,27 +707,27 @@ func (re *Regexp) doExecute(str string, bytes []byte, pos int) []int {
 			switch s[in][i].inst.kind() {
 			case _BOT:
 				if pos == 0 {
-					s[in] = addState(s[in], st.inst.next(), st.match);
+					s[in] = addState(s[in], st.inst.next(), st.match)
 				}
 			case _EOT:
 				if pos == end {
-					s[in] = addState(s[in], st.inst.next(), st.match);
+					s[in] = addState(s[in], st.inst.next(), st.match)
 				}
 			case _CHAR:
 				if c == st.inst.(*_Char).char {
-					s[out] = addState(s[out], st.inst.next(), st.match);
+					s[out] = addState(s[out], st.inst.next(), st.match)
 				}
 			case _CHARCLASS:
 				if st.inst.(*_CharClass).matches(c) {
-					s[out] = addState(s[out], st.inst.next(), st.match);
+					s[out] = addState(s[out], st.inst.next(), st.match)
 				}
 			case _ANY:
 				if c != endOfFile {
-					s[out] = addState(s[out], st.inst.next(), st.match);
+					s[out] = addState(s[out], st.inst.next(), st.match)
 				}
 			case _NOTNL:
 				if c != endOfFile && c != '\n' {
-					s[out] = addState(s[out], st.inst.next(), st.match);
+					s[out] = addState(s[out], st.inst.next(), st.match)
 				}
 			case _BRA:
 				n := st.inst.(*_Bra).n;
@@ -742,7 +742,7 @@ func (re *Regexp) doExecute(str string, bytes []byte, pos int) []int {
 				// give other branch a copy of this match vector
 				s1 := make([]int, 2*(re.nbra + 1));
 				for i := 0; i < len(s1); i++ {
-					s1[i] = st.match[i];
+					s1[i] = st.match[i]
 				}
 				s[in] = addState(s[in], st.inst.next(), s1);
 			case _END:
@@ -773,7 +773,7 @@ func (re *Regexp) doExecute(str string, bytes []byte, pos int) []int {
 // A negative value means the subexpression did not match any element of the string.
 // An empty array means "no match".
 func (re *Regexp) ExecuteString(s string) (a []int) {
-	return re.doExecute(s, nil, 0);
+	return re.doExecute(s, nil, 0)
 }
 
 
@@ -805,12 +805,12 @@ func (re *Regexp) Match(b []byte) bool	{ return len(re.doExecute("", b, 0)) > 0
 func (re *Regexp) MatchStrings(s string) (a []string) {
 	r := re.doExecute(s, nil, 0);
 	if r == nil {
-		return nil;
+		return nil
 	}
 	a = make([]string, len(r)/2);
 	for i := 0; i < len(r); i += 2 {
 		if r[i] != -1 {	// -1 means no match for this subexpression
-			a[i/2] = s[r[i]:r[i+1]];
+			a[i/2] = s[r[i]:r[i+1]]
 		}
 	}
 	return;
@@ -824,12 +824,12 @@ func (re *Regexp) MatchStrings(s string) (a []string) {
 func (re *Regexp) MatchSlices(b []byte) (a [][]byte) {
 	r := re.doExecute("", b, 0);
 	if r == nil {
-		return nil;
+		return nil
 	}
 	a = make([][]byte, len(r)/2);
 	for i := 0; i < len(r); i += 2 {
 		if r[i] != -1 {	// -1 means no match for this subexpression
-			a[i/2] = b[r[i]:r[i+1]];
+			a[i/2] = b[r[i]:r[i+1]]
 		}
 	}
 	return;
@@ -841,7 +841,7 @@ func (re *Regexp) MatchSlices(b []byte) (a [][]byte) {
 func MatchString(pattern string, s string) (matched bool, error os.Error) {
 	re, err := Compile(pattern);
 	if err != nil {
-		return false, err;
+		return false, err
 	}
 	return re.MatchString(s), nil;
 }
@@ -852,7 +852,7 @@ func MatchString(pattern string, s string) (matched bool, error os.Error) {
 func Match(pattern string, b []byte) (matched bool, error os.Error) {
 	re, err := Compile(pattern);
 	if err != nil {
-		return false, err;
+		return false, err
 	}
 	return re.Match(b), nil;
 }
@@ -867,7 +867,7 @@ func (re *Regexp) ReplaceAllString(src, repl string) string {
 	for searchPos <= len(src) {
 		a := re.doExecute(src, nil, searchPos);
 		if len(a) == 0 {
-			break;	// no more matches
+			break	// no more matches
 		}
 
 		// Copy the unmatched characters before this match.
@@ -878,20 +878,20 @@ func (re *Regexp) ReplaceAllString(src, repl string) string {
 		// (Otherwise, we get double replacement for patterns that
 		// match both empty and nonempty strings.)
 		if a[1] > lastMatchEnd || a[0] == 0 {
-			io.WriteString(buf, repl);
+			io.WriteString(buf, repl)
 		}
 		lastMatchEnd = a[1];
 
 		// Advance past this match; always advance at least one character.
 		_, width := utf8.DecodeRuneInString(src[searchPos : len(src)]);
 		if searchPos + width > a[1] {
-			searchPos += width;
+			searchPos += width
 		} else if searchPos + 1 > a[1] {
 			// This clause is only needed at the end of the input
 			// string.  In that case, DecodeRuneInString returns width=0.
-			searchPos++;
+			searchPos++
 		} else {
-			searchPos = a[1];
+			searchPos = a[1]
 		}
 	}
 
@@ -911,7 +911,7 @@ func (re *Regexp) ReplaceAll(src, repl []byte) []byte {
 	for searchPos <= len(src) {
 		a := re.doExecute("", src, searchPos);
 		if len(a) == 0 {
-			break;	// no more matches
+			break	// no more matches
 		}
 
 		// Copy the unmatched characters before this match.
@@ -922,20 +922,20 @@ func (re *Regexp) ReplaceAll(src, repl []byte) []byte {
 		// (Otherwise, we get double replacement for patterns that
 		// match both empty and nonempty strings.)
 		if a[1] > lastMatchEnd || a[0] == 0 {
-			buf.Write(repl);
+			buf.Write(repl)
 		}
 		lastMatchEnd = a[1];
 
 		// Advance past this match; always advance at least one character.
 		_, width := utf8.DecodeRune(src[searchPos : len(src)]);
 		if searchPos + width > a[1] {
-			searchPos += width;
+			searchPos += width
 		} else if searchPos + 1 > a[1] {
 			// This clause is only needed at the end of the input
 			// string.  In that case, DecodeRuneInString returns width=0.
-			searchPos++;
+			searchPos++
 		} else {
-			searchPos = a[1];
+			searchPos = a[1]
 		}
 	}
 
@@ -968,15 +968,15 @@ func QuoteMeta(s string) string {
 func (re *Regexp) allMatches(s string, b []byte, n int, deliver func(int, int)) {
 	var end int;
 	if b == nil {
-		end = len(s);
+		end = len(s)
 	} else {
-		end = len(b);
+		end = len(b)
 	}
 
 	for pos, i, prevMatchEnd := 0, 0, -1; i < n && pos <= end; {
 		matches := re.doExecute(s, b, pos);
 		if len(matches) == 0 {
-			break;
+			break
 		}
 
 		accept := true;
@@ -985,21 +985,21 @@ func (re *Regexp) allMatches(s string, b []byte, n int, deliver func(int, int))
 			if matches[0] == prevMatchEnd {
 				// We don't allow an empty match right
 				// after a previous match, so ignore it.
-				accept = false;
+				accept = false
 			}
 			var width int;
 			if b == nil {
-				_, width = utf8.DecodeRuneInString(s[pos:end]);
+				_, width = utf8.DecodeRuneInString(s[pos:end])
 			} else {
-				_, width = utf8.DecodeRune(b[pos:end]);
+				_, width = utf8.DecodeRune(b[pos:end])
 			}
 			if width > 0 {
-				pos += width;
+				pos += width
 			} else {
-				pos = end+1;
+				pos = end+1
 			}
 		} else {
-			pos = matches[1];
+			pos = matches[1]
 		}
 		prevMatchEnd = matches[1];
 
@@ -1017,7 +1017,7 @@ func (re *Regexp) allMatches(s string, b []byte, n int, deliver func(int, int))
 // containing the matching substrings.
 func (re *Regexp) AllMatches(b []byte, n int) [][]byte {
 	if n <= 0 {
-		n = len(b)+1;
+		n = len(b)+1
 	}
 	result := make([][]byte, n);
 	i := 0;
@@ -1035,7 +1035,7 @@ func (re *Regexp) AllMatches(b []byte, n int) [][]byte {
 // containing the matching substrings.
 func (re *Regexp) AllMatchesString(s string, n int) []string {
 	if n <= 0 {
-		n = len(s)+1;
+		n = len(s)+1
 	}
 	result := make([]string, n);
 	i := 0;
@@ -1053,7 +1053,7 @@ func (re *Regexp) AllMatchesString(s string, n int) []string {
 // channel that iterates over the matching substrings.
 func (re *Regexp) AllMatchesIter(b []byte, n int) <-chan []byte {
 	if n <= 0 {
-		n = len(b)+1;
+		n = len(b)+1
 	}
 	c := make(chan []byte, 10);
 	go func() {
@@ -1070,7 +1070,7 @@ func (re *Regexp) AllMatchesIter(b []byte, n int) <-chan []byte {
 // channel that iterates over the matching substrings.
 func (re *Regexp) AllMatchesStringIter(s string, n int) <-chan string {
 	if n <= 0 {
-		n = len(s)+1;
+		n = len(s)+1
 	}
 	c := make(chan string, 10);
 	go func() {
diff --git a/src/pkg/rpc/client.go b/src/pkg/rpc/client.go
index e1b6a14eca..f959f53b90 100644
--- a/src/pkg/rpc/client.go
+++ b/src/pkg/rpc/client.go
@@ -61,7 +61,7 @@ func (client *Client) send(c *Call) {
 	client.enc.Encode(request);
 	err := client.enc.Encode(c.Args);
 	if err != nil {
-		panicln("rpc: client encode error:", err);
+		panicln("rpc: client encode error:", err)
 	}
 	client.sending.Unlock();
 }
@@ -73,7 +73,7 @@ func (client *Client) input() {
 		err = client.dec.Decode(response);
 		if err != nil {
 			if err == os.EOF {
-				err = io.ErrUnexpectedEOF;
+				err = io.ErrUnexpectedEOF
 			}
 			break;
 		}
@@ -115,7 +115,7 @@ func NewClient(conn io.ReadWriteCloser) *Client {
 func DialHTTP(network, address string) (*Client, os.Error) {
 	conn, err := net.Dial(network, "", address);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	io.WriteString(conn, "CONNECT " + rpcPath + " HTTP/1.0\n\n");
 
@@ -123,10 +123,10 @@ func DialHTTP(network, address string) (*Client, os.Error) {
 	// before switching to RPC protocol.
 	resp, err := http.ReadResponse(bufio.NewReader(conn));
 	if err == nil && resp.Status == connected {
-		return NewClient(conn), nil;
+		return NewClient(conn), nil
 	}
 	if err == nil {
-		err = os.ErrorString("unexpected HTTP response: " + resp.Status);
+		err = os.ErrorString("unexpected HTTP response: " + resp.Status)
 	}
 	conn.Close();
 	return nil, &net.OpError{"dial-http", network+" "+address, nil, err};
@@ -136,7 +136,7 @@ func DialHTTP(network, address string) (*Client, os.Error) {
 func Dial(network, address string) (*Client, os.Error) {
 	conn, err := net.Dial(network, "", address);
 	if err != nil {
-		return nil, err;
+		return nil, err
 	}
 	return NewClient(conn), nil;
 }
@@ -151,14 +151,14 @@ func (client *Client) Go(serviceMethod string, args interface{}, reply interface
 	c.Args = args;
 	c.Reply = reply;
 	if done == nil {
-		done = make(chan *Call, 10);	// buffered.
+		done = make(chan *Call, 10)	// buffered.
 	} else {
 		// If caller passes done != nil, it must arrange that
 		// done has enough buffer for the number of simultaneous
 		// RPCs that will be using that channel.  If the channel
 		// is totally unbuffered, it's best not to run at all.
 		if cap(done) == 0 {
-			log.Crash("rpc: done channel is unbuffered");
+			log.Crash("rpc: done channel is unbuffered")
 		}
 	}
 	c.Done = done;
@@ -174,7 +174,7 @@ func (client *Client) Go(serviceMethod string, args interface{}, reply interface
 // Call invokes the named function, waits for it to complete, and returns its error status.
 func (client *Client) Call(serviceMethod string, args interface{}, reply interface{}) os.Error {
 	if client.shutdown != nil {
-		return client.shutdown;
+		return client.shutdown
 	}
 	call := <-client.Go(serviceMethod, args, reply, nil).Done;
 	return call.Error;
diff --git a/src/pkg/rpc/debug.go b/src/pkg/rpc/debug.go
index 425b7e6e43..7ba74a5e0e 100644
--- a/src/pkg/rpc/debug.go
+++ b/src/pkg/rpc/debug.go
@@ -81,6 +81,6 @@ func debugHTTP(c *http.Conn, req *http.Request) {
 	sort.Sort(services);
 	err := debug.Execute(services, c);
 	if err != nil {
-		fmt.Fprintln(c, "rpc: error executing template:", err.String());
+		fmt.Fprintln(c, "rpc: error executing template:", err.String())
 	}
 }
diff --git a/src/pkg/rpc/server.go b/src/pkg/rpc/server.go
index b66d45406a..c4e9df7633 100644
--- a/src/pkg/rpc/server.go
+++ b/src/pkg/rpc/server.go
@@ -178,14 +178,14 @@ func (server *serverType) register(rcvr interface{}) os.Error {
 	server.Lock();
 	defer server.Unlock();
 	if server.serviceMap == nil {
-		server.serviceMap = make(map[string]*service);
+		server.serviceMap = make(map[string]*service)
 	}
 	s := new(service);
 	s.typ = reflect.Typeof(rcvr);
 	s.rcvr = reflect.NewValue(rcvr);
 	sname := reflect.Indirect(s.rcvr).Type().Name();
 	if sname == "" {
-		log.Exit("rpc: no service name for type", s.typ.String());
+		log.Exit("rpc: no service name for type", s.typ.String())
 	}
 	if !isPublic(sname) {
 		s := "rpc Register: type " + sname + " is not public";
@@ -193,7 +193,7 @@ func (server *serverType) register(rcvr interface{}) os.Error {
 		return os.ErrorString(s);
 	}
 	if _, present := server.serviceMap[sname]; present {
-		return os.ErrorString("rpc: service already defined: " + sname);
+		return os.ErrorString("rpc: service already defined: " + sname)
 	}
 	s.name = sname;
 	s.method = make(map[string]*methodType);
@@ -204,7 +204,7 @@ func (server *serverType) register(rcvr interface{}) os.Error {
 		mtype := method.Type;
 		mname := method.Name;
 		if !isPublic(mname) {
-			continue;
+			continue
 		}
 		// Method needs three ins: receiver, *args, *reply.
 		// The args and reply must be structs until gobs are more general.
@@ -296,7 +296,7 @@ func (s *service) call(sending *sync.Mutex, mtype *methodType, req *Request, arg
 	errInter := returnValues[0].Interface();
 	errmsg := "";
 	if errInter != nil {
-		errmsg = errInter.(os.Error).String();
+		errmsg = errInter.(os.Error).String()
 	}
 	sendResponse(sending, req, replyv.Interface(), enc, errmsg);
 }
@@ -357,7 +357,7 @@ func (server *serverType) accept(lis net.Listener) {
 	for {
 		conn, err := lis.Accept();
 		if err != nil {
-			log.Exit("rpc.Serve: accept:", err.String());	// TODO(r): exit?
+			log.Exit("rpc.Serve: accept:", err.String())	// TODO(r): exit?
 		}
 		go server.input(conn);
 	}
diff --git a/src/pkg/rpc/server_test.go b/src/pkg/rpc/server_test.go
index 00b348dbc0..ca943d5184 100644
--- a/src/pkg/rpc/server_test.go
+++ b/src/pkg/rpc/server_test.go
@@ -42,14 +42,14 @@ func (t *Arith) Mul(args *Args, reply *Reply) os.Error {
 
 func (t *Arith) Div(args *Args, reply *Reply) os.Error {
 	if args.B == 0 {
-		return os.ErrorString("divide by zero");
+		return os.ErrorString("divide by zero")
 	}
 	reply.C = args.A / args.B;
 	return nil;
 }
 
 func (t *Arith) Error(args *Args, reply *Reply) os.Error {
-	panicln("ERROR");
+	panicln("ERROR")
 }
 
 func startServer() {
@@ -57,7 +57,7 @@ func startServer() {
 
 	l, e := net.Listen("tcp", ":0");	// any available address
 	if e != nil {
-		log.Exitf("net.Listen tcp :0: %v", e);
+		log.Exitf("net.Listen tcp :0: %v", e)
 	}
 	serverAddr = l.Addr().String();
 	log.Stderr("Test RPC server listening on ", serverAddr);
@@ -79,7 +79,7 @@ func TestRPC(t *testing.T) {
 
 	client, err := Dial("tcp", serverAddr);
 	if err != nil {
-		t.Fatal("dialing", err);
+		t.Fatal("dialing", err)
 	}
 
 	// Synchronous calls
@@ -87,14 +87,14 @@ func TestRPC(t *testing.T) {
 	reply := new(Reply);
 	err = client.Call("Arith.Add", args, reply);
 	if reply.C != args.A + args.B {
-		t.Errorf("Add: expected %d got %d", reply.C, args.A + args.B);
+		t.Errorf("Add: expected %d got %d", reply.C, args.A + args.B)
 	}
 
 	args = &Args{7, 8};
 	reply = new(Reply);
 	err = client.Call("Arith.Mul", args, reply);
 	if reply.C != args.A * args.B {
-		t.Errorf("Mul: expected %d got %d", reply.C, args.A * args.B);
+		t.Errorf("Mul: expected %d got %d", reply.C, args.A * args.B)
 	}
 
 	// Out of order.
@@ -106,12 +106,12 @@ func TestRPC(t *testing.T) {
 
 	<-addCall.Done;
 	if addReply.C != args.A + args.B {
-		t.Errorf("Add: expected %d got %d", addReply.C, args.A + args.B);
+		t.Errorf("Add: expected %d got %d", addReply.C, args.A + args.B)
 	}
 
 	<-mulCall.Done;
 	if mulReply.C != args.A * args.B {
-		t.Errorf("Mul: expected %d got %d", mulReply.C, args.A * args.B);
+		t.Errorf("Mul: expected %d got %d", mulReply.C, args.A * args.B)
 	}
 
 	// Error test
@@ -120,9 +120,9 @@ func TestRPC(t *testing.T) {
 	err = client.Call("Arith.Div", args, reply);
 	// expect an error: zero divide
 	if err == nil {
-		t.Error("Div: expected error");
+		t.Error("Div: expected error")
 	} else if err.String() != "divide by zero" {
-		t.Error("Div: expected divide by zero error; got", err);
+		t.Error("Div: expected divide by zero error; got", err)
 	}
 }
 
@@ -131,7 +131,7 @@ func TestHTTPRPC(t *testing.T) {
 
 	client, err := DialHTTP("tcp", httpServerAddr);
 	if err != nil {
-		t.Fatal("dialing", err);
+		t.Fatal("dialing", err)
 	}
 
 	// Synchronous calls
@@ -139,7 +139,7 @@ func TestHTTPRPC(t *testing.T) {
 	reply := new(Reply);
 	err = client.Call("Arith.Add", args, reply);
 	if reply.C != args.A + args.B {
-		t.Errorf("Add: expected %d got %d", reply.C, args.A + args.B);
+		t.Errorf("Add: expected %d got %d", reply.C, args.A + args.B)
 	}
 }
 
@@ -148,7 +148,7 @@ func TestCheckUnknownService(t *testing.T) {
 
 	conn, err := net.Dial("tcp", "", serverAddr);
 	if err != nil {
-		t.Fatal("dialing:", err);
+		t.Fatal("dialing:", err)
 	}
 
 	client := NewClient(conn);
@@ -157,9 +157,9 @@ func TestCheckUnknownService(t *testing.T) {
 	reply := new(Reply);
 	err = client.Call("Unknown.Add", args, reply);
 	if err == nil {
-		t.Error("expected error calling unknown service");
+		t.Error("expected error calling unknown service")
 	} else if strings.Index(err.String(), "service") < 0 {
-		t.Error("expected error about service; got", err);
+		t.Error("expected error about service; got", err)
 	}
 }
 
@@ -168,7 +168,7 @@ func TestCheckUnknownMethod(t *testing.T) {
 
 	conn, err := net.Dial("tcp", "", serverAddr);
 	if err != nil {
-		t.Fatal("dialing:", err);
+		t.Fatal("dialing:", err)
 	}
 
 	client := NewClient(conn);
@@ -177,9 +177,9 @@ func TestCheckUnknownMethod(t *testing.T) {
 	reply := new(Reply);
 	err = client.Call("Arith.Unknown", args, reply);
 	if err == nil {
-		t.Error("expected error calling unknown service");
+		t.Error("expected error calling unknown service")
 	} else if strings.Index(err.String(), "method") < 0 {
-		t.Error("expected error about method; got", err);
+		t.Error("expected error about method; got", err)
 	}
 }
 
@@ -188,7 +188,7 @@ func TestCheckBadType(t *testing.T) {
 
 	conn, err := net.Dial("tcp", "", serverAddr);
 	if err != nil {
-		t.Fatal("dialing:", err);
+		t.Fatal("dialing:", err)
 	}
 
 	client := NewClient(conn);
@@ -196,8 +196,8 @@ func TestCheckBadType(t *testing.T) {
 	reply := new(Reply);
 	err = client.Call("Arith.Add", reply, reply);	// args, reply would be the correct thing to use
 	if err == nil {
-		t.Error("expected error calling Arith.Add with wrong arg type");
+		t.Error("expected error calling Arith.Add with wrong arg type")
 	} else if strings.Index(err.String(), "type") < 0 {
-		t.Error("expected error about type; got", err);
+		t.Error("expected error about type; got", err)
 	}
 }
diff --git a/src/pkg/sort/sort.go b/src/pkg/sort/sort.go
index 34a2c4346b..961ce4bc4c 100644
--- a/src/pkg/sort/sort.go
+++ b/src/pkg/sort/sort.go
@@ -21,7 +21,7 @@ type Interface interface {
 
 func min(a, b int) int {
 	if a < b {
-		return a;
+		return a
 	}
 	return b;
 }
@@ -30,7 +30,7 @@ func min(a, b int) int {
 func insertionSort(data Interface, a, b int) {
 	for i := a+1; i < b; i++ {
 		for j := i; j > a && data.Less(j, j-1); j-- {
-			data.Swap(j, j-1);
+			data.Swap(j, j-1)
 		}
 	}
 }
@@ -45,20 +45,20 @@ func medianOfThree(data Interface, a, b, c int) {
 	m2 := c;
 	// bubble sort on 3 elements
 	if data.Less(m1, m0) {
-		data.Swap(m1, m0);
+		data.Swap(m1, m0)
 	}
 	if data.Less(m2, m1) {
-		data.Swap(m2, m1);
+		data.Swap(m2, m1)
 	}
 	if data.Less(m1, m0) {
-		data.Swap(m1, m0);
+		data.Swap(m1, m0)
 	}
 	// now data[m0] <= data[m1] <= data[m2]
 }
 
 func swapRange(data Interface, a, b, n int) {
 	for i := 0; i < n; i++ {
-		data.Swap(a+i, b+i);
+		data.Swap(a+i, b+i)
 	}
 }
 
@@ -127,7 +127,7 @@ func quickSort(data Interface, a, b int) {
 		quickSort(data, a, mlo);
 		quickSort(data, mhi, b);
 	} else if b-a > 1 {
-		insertionSort(data, a, b);
+		insertionSort(data, a, b)
 	}
 }
 
@@ -138,7 +138,7 @@ func IsSorted(data Interface) bool {
 	n := data.Len();
 	for i := n-1; i > 0; i-- {
 		if data.Less(i, i-1) {
-			return false;
+			return false
 		}
 	}
 	return true;
diff --git a/src/pkg/sort/sort_test.go b/src/pkg/sort/sort_test.go
index 623100006c..93c520c9d9 100644
--- a/src/pkg/sort/sort_test.go
+++ b/src/pkg/sort/sort_test.go
@@ -75,14 +75,14 @@ func TestSortStrings(t *testing.T) {
 func TestSortLarge_Random(t *testing.T) {
 	data := make([]int, 1000000);
 	for i := 0; i < len(data); i++ {
-		data[i] = rand.Intn(100);
+		data[i] = rand.Intn(100)
 	}
 	if IntsAreSorted(data) {
-		t.Fatalf("terrible rand.rand");
+		t.Fatalf("terrible rand.rand")
 	}
 	SortInts(data);
 	if !IntsAreSorted(data) {
-		t.Errorf("sort didn't sort - 1M ints");
+		t.Errorf("sort didn't sort - 1M ints")
 	}
 }
 
@@ -127,7 +127,7 @@ func (d *testingData) Swap(i, j int) {
 func lg(n int) int {
 	i := 0;
 	for 1<<uint(i) < n {
-		i++;
+		i++
 	}
 	return i;
 }
@@ -147,13 +147,13 @@ func TestBentleyMcIlroy(t *testing.T) {
 				for i := 0; i < n; i++ {
 					switch dist {
 					case _Sawtooth:
-						data[i] = i%m;
+						data[i] = i%m
 					case _Rand:
-						data[i] = rand.Intn(m);
+						data[i] = rand.Intn(m)
 					case _Stagger:
-						data[i] = (i*m + i)%n;
+						data[i] = (i*m + i)%n
 					case _Plateau:
-						data[i] = min(i, m);
+						data[i] = min(i, m)
 					case _Shuffle:
 						if rand.Intn(m) != 0 {
 							j += 2;
@@ -170,36 +170,36 @@ func TestBentleyMcIlroy(t *testing.T) {
 					switch mode {
 					case _Copy:
 						for i := 0; i < n; i++ {
-							mdata[i] = data[i];
+							mdata[i] = data[i]
 						}
 					case _Reverse:
 						for i := 0; i < n; i++ {
-							mdata[i] = data[n-i-1];
+							mdata[i] = data[n-i-1]
 						}
 					case _ReverseFirstHalf:
 						for i := 0; i < n/2; i++ {
-							mdata[i] = data[n/2 - i - 1];
+							mdata[i] = data[n/2 - i - 1]
 						}
 						for i := n/2; i < n; i++ {
-							mdata[i] = data[i];
+							mdata[i] = data[i]
 						}
 					case _ReverseSecondHalf:
 						for i := 0; i < n/2; i++ {
-							mdata[i] = data[i];
+							mdata[i] = data[i]
 						}
 						for i := n/2; i < n; i++ {
-							mdata[i] = data[n-(i - n/2)-1];
+							mdata[i] = data[n-(i - n/2)-1]
 						}
 					case _Sorted:
 						for i := 0; i < n; i++ {
-							mdata[i] = data[i];
+							mdata[i] = data[i]
 						}
 						// SortInts is known to be correct
 						// because mode Sort runs after mode _Copy.
 						SortInts(mdata);
 					case _Dither:
 						for i := 0; i < n; i++ {
-							mdata[i] = data[i] + i%5;
+							mdata[i] = data[i] + i%5
 						}
 					}
 
diff --git a/src/pkg/strconv/atof.go b/src/pkg/strconv/atof.go
index 3202978d8f..4629a7e175 100644
--- a/src/pkg/strconv/atof.go
+++ b/src/pkg/strconv/atof.go
@@ -25,11 +25,11 @@ func stringToDecimal(s string) (neg bool, d *decimal, trunc bool, ok bool) {
 
 	// optional sign
 	if i >= len(s) {
-		return;
+		return
 	}
 	switch {
 	case s[i] == '+':
-		i++;
+		i++
 	case s[i] == '-':
 		neg = true;
 		i++;
@@ -43,7 +43,7 @@ func stringToDecimal(s string) (neg bool, d *decimal, trunc bool, ok bool) {
 		switch {
 		case s[i] == '.':
 			if sawdot {
-				return;
+				return
 			}
 			sawdot = true;
 			b.dp = b.nd;
@@ -62,10 +62,10 @@ func stringToDecimal(s string) (neg bool, d *decimal, trunc bool, ok bool) {
 		break;
 	}
 	if !sawdigits {
-		return;
+		return
 	}
 	if !sawdot {
-		b.dp = b.nd;
+		b.dp = b.nd
 	}
 
 	// optional exponent moves decimal point.
@@ -76,29 +76,29 @@ func stringToDecimal(s string) (neg bool, d *decimal, trunc bool, ok bool) {
 	if i < len(s) && s[i] == 'e' {
 		i++;
 		if i >= len(s) {
-			return;
+			return
 		}
 		esign := 1;
 		if s[i] == '+' {
-			i++;
+			i++
 		} else if s[i] == '-' {
 			i++;
 			esign = -1;
 		}
 		if i >= len(s) || s[i] < '0' || s[i] > '9' {
-			return;
+			return
 		}
 		e := 0;
 		for ; i < len(s) && '0' <= s[i] && s[i] <= '9'; i++ {
 			if e < 10000 {
-				e = e*10 + int(s[i]) - '0';
+				e = e*10 + int(s[i]) - '0'
 			}
 		}
 		b.dp += e*esign;
 	}
 
 	if i != len(s) {
-		return;
+		return
 	}
 
 	d = b;
@@ -124,7 +124,7 @@ func decimalToFloatBits(neg bool, d *decimal, trunc bool, flt *floatInfo) (b uin
 	// These bounds are for 64-bit floats.
 	// Will have to change if we want to support 80-bit floats in the future.
 	if d.dp > 310 {
-		goto overflow;
+		goto overflow
 	}
 	if d.dp < -330 {
 		// zero
@@ -138,9 +138,9 @@ func decimalToFloatBits(neg bool, d *decimal, trunc bool, flt *floatInfo) (b uin
 	for d.dp > 0 {
 		var n int;
 		if d.dp >= len(powtab) {
-			n = 27;
+			n = 27
 		} else {
-			n = powtab[d.dp];
+			n = powtab[d.dp]
 		}
 		d.Shift(-n);
 		exp += n;
@@ -148,9 +148,9 @@ func decimalToFloatBits(neg bool, d *decimal, trunc bool, flt *floatInfo) (b uin
 	for d.dp < 0 || d.dp == 0 && d.d[0] < '5' {
 		var n int;
 		if -d.dp >= len(powtab) {
-			n = 27;
+			n = 27
 		} else {
-			n = powtab[-d.dp];
+			n = powtab[-d.dp]
 		}
 		d.Shift(n);
 		exp -= n;
@@ -169,7 +169,7 @@ func decimalToFloatBits(neg bool, d *decimal, trunc bool, flt *floatInfo) (b uin
 	}
 
 	if exp - flt.bias >= 1 << flt.expbits - 1 {
-		goto overflow;
+		goto overflow
 	}
 
 	// Extract 1+flt.mantbits bits.
@@ -180,13 +180,13 @@ func decimalToFloatBits(neg bool, d *decimal, trunc bool, flt *floatInfo) (b uin
 		mant >>= 1;
 		exp++;
 		if exp - flt.bias >= 1 << flt.expbits - 1 {
-			goto overflow;
+			goto overflow
 		}
 	}
 
 	// Denormalized?
 	if mant&(1 << flt.mantbits) == 0 {
-		exp = flt.bias;
+		exp = flt.bias
 	}
 	goto out;
 
@@ -201,7 +201,7 @@ out:
 	bits := mant&(uint64(1) << flt.mantbits - 1);
 	bits |= uint64((exp - flt.bias)&(1 << flt.expbits - 1)) << flt.mantbits;
 	if neg {
-		bits |= 1 << flt.mantbits << flt.expbits;
+		bits |= 1 << flt.mantbits << flt.expbits
 	}
 	return bits, overflow;
 }
@@ -211,10 +211,10 @@ out:
 func decimalAtof64Int(neg bool, d *decimal) float64 {
 	f := float64(0);
 	for i := 0; i < d.nd; i++ {
-		f = f*10 + float64(d.d[i] - '0');
+		f = f*10 + float64(d.d[i] - '0')
 	}
 	if neg {
-		f *= -1;	// BUG work around 6g f = -f.
+		f *= -1	// BUG work around 6g f = -f.
 	}
 	return f;
 }
@@ -222,10 +222,10 @@ func decimalAtof64Int(neg bool, d *decimal) float64 {
 func decimalAtof32Int(neg bool, d *decimal) float32 {
 	f := float32(0);
 	for i := 0; i < d.nd; i++ {
-		f = f*10 + float32(d.d[i] - '0');
+		f = f*10 + float32(d.d[i] - '0')
 	}
 	if neg {
-		f *= -1;	// BUG work around 6g f = -f.
+		f *= -1	// BUG work around 6g f = -f.
 	}
 	return f;
 }
@@ -249,7 +249,7 @@ func decimalAtof64(neg bool, d *decimal, trunc bool) (f float64, ok bool) {
 	// Exact integers are <= 10^15.
 	// Exact powers of ten are <= 10^22.
 	if d.nd > 15 {
-		return;
+		return
 	}
 	switch {
 	case d.dp == d.nd:	// int
@@ -280,7 +280,7 @@ func decimalAtof32(neg bool, d *decimal, trunc bool) (f float32, ok bool) {
 	// Exact integers are <= 10^7.
 	// Exact powers of ten are <= 10^10.
 	if d.nd > 7 {
-		return;
+		return
 	}
 	switch {
 	case d.dp == d.nd:	// int
@@ -322,17 +322,17 @@ func decimalAtof32(neg bool, d *decimal, trunc bool) (f float32, ok bool) {
 func Atof32(s string) (f float32, err os.Error) {
 	neg, d, trunc, ok := stringToDecimal(s);
 	if !ok {
-		return 0, &NumError{s, os.EINVAL};
+		return 0, &NumError{s, os.EINVAL}
 	}
 	if optimize {
 		if f, ok := decimalAtof32(neg, d, trunc); ok {
-			return f, nil;
+			return f, nil
 		}
 	}
 	b, ovf := decimalToFloatBits(neg, d, trunc, &float32info);
 	f = math.Float32frombits(uint32(b));
 	if ovf {
-		err = &NumError{s, os.ERANGE};
+		err = &NumError{s, os.ERANGE}
 	}
 	return f, err;
 }
@@ -343,17 +343,17 @@ func Atof32(s string) (f float32, err os.Error) {
 func Atof64(s string) (f float64, err os.Error) {
 	neg, d, trunc, ok := stringToDecimal(s);
 	if !ok {
-		return 0, &NumError{s, os.EINVAL};
+		return 0, &NumError{s, os.EINVAL}
 	}
 	if optimize {
 		if f, ok := decimalAtof64(neg, d, trunc); ok {
-			return f, nil;
+			return f, nil
 		}
 	}
 	b, ovf := decimalToFloatBits(neg, d, trunc, &float64info);
 	f = math.Float64frombits(b);
 	if ovf {
-		err = &NumError{s, os.ERANGE};
+		err = &NumError{s, os.ERANGE}
 	}
 	return f, err;
 }
diff --git a/src/pkg/strconv/atof_test.go b/src/pkg/strconv/atof_test.go
index a59fb78b40..c9b374d352 100644
--- a/src/pkg/strconv/atof_test.go
+++ b/src/pkg/strconv/atof_test.go
@@ -98,7 +98,7 @@ func init() {
 	for i := range atoftests {
 		test := &atoftests[i];
 		if test.err != nil {
-			test.err = &NumError{test.in, test.err};
+			test.err = &NumError{test.in, test.err}
 		}
 	}
 }
@@ -111,7 +111,7 @@ func testAtof(t *testing.T, opt bool) {
 		outs := Ftoa64(out, 'g', -1);
 		if outs != test.out || !reflect.DeepEqual(err, test.err) {
 			t.Errorf("Atof64(%v) = %v, %v want %v, %v\n",
-				test.in, out, err, test.out, test.err);
+				test.in, out, err, test.out, test.err)
 		}
 
 		if float64(float32(out)) == out {
@@ -119,7 +119,7 @@ func testAtof(t *testing.T, opt bool) {
 			outs := Ftoa32(out32, 'g', -1);
 			if outs != test.out || !reflect.DeepEqual(err, test.err) {
 				t.Errorf("Atof32(%v) = %v, %v want %v, %v  # %v\n",
-					test.in, out32, err, test.out, test.err, out);
+					test.in, out32, err, test.out, test.err, out)
 			}
 		}
 
@@ -128,7 +128,7 @@ func testAtof(t *testing.T, opt bool) {
 			outs := Ftoa(outf, 'g', -1);
 			if outs != test.out || !reflect.DeepEqual(err, test.err) {
 				t.Errorf("Ftoa(%v) = %v, %v want %v, %v  # %v\n",
-					test.in, outf, err, test.out, test.err, out);
+					test.in, outf, err, test.out, test.err, out)
 			}
 		}
 	}
diff --git a/src/pkg/strconv/atoi.go b/src/pkg/strconv/atoi.go
index eddda20a5f..2194821f3e 100644
--- a/src/pkg/strconv/atoi.go
+++ b/src/pkg/strconv/atoi.go
@@ -17,7 +17,7 @@ func (e *NumError) String() string	{ return "parsing " + e.Num + ": " + e.Error.
 func computeIntsize() uint {
 	siz := uint(8);
 	for 1<<siz != 0 {
-		siz *= 2;
+		siz *= 2
 	}
 	return siz;
 }
@@ -27,7 +27,7 @@ var IntSize = computeIntsize()
 // Return the first number n such that n*base >= 1<<64.
 func cutoff64(base int) uint64 {
 	if base < 2 {
-		return 0;
+		return 0
 	}
 	return (1<<64 - 1)/uint64(base) + 1;
 }
@@ -62,9 +62,9 @@ func Btoui64(s string, b int) (n uint64, err os.Error) {
 				goto Error;
 			}
 		case s[0] == '0':
-			b = 8;
+			b = 8
 		default:
-			b = 10;
+			b = 10
 		}
 
 	default:
@@ -79,11 +79,11 @@ func Btoui64(s string, b int) (n uint64, err os.Error) {
 		var v byte;
 		switch {
 		case '0' <= s[i] && s[i] <= '9':
-			v = s[i]-'0';
+			v = s[i]-'0'
 		case 'a' <= s[i] && s[i] <= 'z':
-			v = s[i]-'a'+10;
+			v = s[i]-'a'+10
 		case 'A' <= s[i] && s[i] <= 'Z':
-			v = s[i]-'A'+10;
+			v = s[i]-'A'+10
 		default:
 			n = 0;
 			err = os.EINVAL;
@@ -125,7 +125,7 @@ Error:
 // Atoui64 returns err == os.EINVAL if s is empty or contains invalid digits.
 // It returns err == os.ERANGE if s cannot be represented by a uint64.
 func Atoui64(s string) (n uint64, err os.Error) {
-	return Btoui64(s, 10);
+	return Btoui64(s, 10)
 }
 
 // Btoi64 is like Btoui64 but allows signed numbers and
@@ -133,14 +133,14 @@ func Atoui64(s string) (n uint64, err os.Error) {
 func Btoi64(s string, base int) (i int64, err os.Error) {
 	// Empty string bad.
 	if len(s) == 0 {
-		return 0, &NumError{s, os.EINVAL};
+		return 0, &NumError{s, os.EINVAL}
 	}
 
 	// Pick off leading sign.
 	s0 := s;
 	neg := false;
 	if s[0] == '+' {
-		s = s[1:len(s)];
+		s = s[1:len(s)]
 	} else if s[0] == '-' {
 		neg = true;
 		s = s[1:len(s)];
@@ -154,14 +154,14 @@ func Btoi64(s string, base int) (i int64, err os.Error) {
 		return 0, err;
 	}
 	if !neg && un >= 1<<63 {
-		return 1<<63 - 1, &NumError{s0, os.ERANGE};
+		return 1<<63 - 1, &NumError{s0, os.ERANGE}
 	}
 	if neg && un > 1<<63 {
-		return -1 << 63, &NumError{s0, os.ERANGE};
+		return -1 << 63, &NumError{s0, os.ERANGE}
 	}
 	n := int64(un);
 	if neg {
-		n = -n;
+		n = -n
 	}
 	return n, nil;
 }
@@ -175,11 +175,11 @@ func Atoi64(s string) (i int64, err os.Error)	{ return Btoi64(s, 10) }
 func Atoui(s string) (i uint, err os.Error) {
 	i1, e1 := Atoui64(s);
 	if e1 != nil && e1.(*NumError).Error != os.ERANGE {
-		return 0, e1;
+		return 0, e1
 	}
 	i = uint(i1);
 	if uint64(i) != i1 {
-		return ^uint(0), &NumError{s, os.ERANGE};
+		return ^uint(0), &NumError{s, os.ERANGE}
 	}
 	return i, nil;
 }
@@ -188,12 +188,12 @@ func Atoui(s string) (i uint, err os.Error) {
 func Atoi(s string) (i int, err os.Error) {
 	i1, e1 := Atoi64(s);
 	if e1 != nil && e1.(*NumError).Error != os.ERANGE {
-		return 0, e1;
+		return 0, e1
 	}
 	i = int(i1);
 	if int64(i) != i1 {
 		if i1 < 0 {
-			return -1 << (IntSize-1), &NumError{s, os.ERANGE};
+			return -1 << (IntSize-1), &NumError{s, os.ERANGE}
 		}
 		return 1<<(IntSize-1) - 1, &NumError{s, os.ERANGE};
 	}
diff --git a/src/pkg/strconv/atoi_test.go b/src/pkg/strconv/atoi_test.go
index a3c61fcb82..da9de577b7 100644
--- a/src/pkg/strconv/atoi_test.go
+++ b/src/pkg/strconv/atoi_test.go
@@ -153,37 +153,37 @@ func init() {
 	for i := range atoui64tests {
 		test := &atoui64tests[i];
 		if test.err != nil {
-			test.err = &NumError{test.in, test.err};
+			test.err = &NumError{test.in, test.err}
 		}
 	}
 	for i := range btoui64tests {
 		test := &btoui64tests[i];
 		if test.err != nil {
-			test.err = &NumError{test.in, test.err};
+			test.err = &NumError{test.in, test.err}
 		}
 	}
 	for i := range atoi64tests {
 		test := &atoi64tests[i];
 		if test.err != nil {
-			test.err = &NumError{test.in, test.err};
+			test.err = &NumError{test.in, test.err}
 		}
 	}
 	for i := range btoi64tests {
 		test := &btoi64tests[i];
 		if test.err != nil {
-			test.err = &NumError{test.in, test.err};
+			test.err = &NumError{test.in, test.err}
 		}
 	}
 	for i := range atoui32tests {
 		test := &atoui32tests[i];
 		if test.err != nil {
-			test.err = &NumError{test.in, test.err};
+			test.err = &NumError{test.in, test.err}
 		}
 	}
 	for i := range atoi32tests {
 		test := &atoi32tests[i];
 		if test.err != nil {
-			test.err = &NumError{test.in, test.err};
+			test.err = &NumError{test.in, test.err}
 		}
 	}
 }
@@ -194,7 +194,7 @@ func TestAtoui64(t *testing.T) {
 		out, err := Atoui64(test.in);
 		if test.out != out || !reflect.DeepEqual(test.err, err) {
 			t.Errorf("Atoui64(%q) = %v, %v want %v, %v\n",
-				test.in, out, err, test.out, test.err);
+				test.in, out, err, test.out, test.err)
 		}
 	}
 }
@@ -205,7 +205,7 @@ func TestBtoui64(t *testing.T) {
 		out, err := Btoui64(test.in, 0);
 		if test.out != out || !reflect.DeepEqual(test.err, err) {
 			t.Errorf("Btoui64(%q) = %v, %v want %v, %v\n",
-				test.in, out, err, test.out, test.err);
+				test.in, out, err, test.out, test.err)
 		}
 	}
 }
@@ -216,7 +216,7 @@ func TestAtoi64(t *testing.T) {
 		out, err := Atoi64(test.in);
 		if test.out != out || !reflect.DeepEqual(test.err, err) {
 			t.Errorf("Atoi64(%q) = %v, %v want %v, %v\n",
-				test.in, out, err, test.out, test.err);
+				test.in, out, err, test.out, test.err)
 		}
 	}
 }
@@ -227,7 +227,7 @@ func TestBtoi64(t *testing.T) {
 		out, err := Btoi64(test.in, 0);
 		if test.out != out || !reflect.DeepEqual(test.err, err) {
 			t.Errorf("Btoi64(%q) = %v, %v want %v, %v\n",
-				test.in, out, err, test.out, test.err);
+				test.in, out, err, test.out, test.err)
 		}
 	}
 }
@@ -240,7 +240,7 @@ func TestAtoui(t *testing.T) {
 			out, err := Atoui(test.in);
 			if test.out != uint32(out) || !reflect.DeepEqual(test.err, err) {
 				t.Errorf("Atoui(%q) = %v, %v want %v, %v\n",
-					test.in, out, err, test.out, test.err);
+					test.in, out, err, test.out, test.err)
 			}
 		}
 	case 64:
@@ -249,7 +249,7 @@ func TestAtoui(t *testing.T) {
 			out, err := Atoui(test.in);
 			if test.out != uint64(out) || !reflect.DeepEqual(test.err, err) {
 				t.Errorf("Atoui(%q) = %v, %v want %v, %v\n",
-					test.in, out, err, test.out, test.err);
+					test.in, out, err, test.out, test.err)
 			}
 		}
 	}
@@ -263,7 +263,7 @@ func TestAtoi(t *testing.T) {
 			out, err := Atoi(test.in);
 			if test.out != int32(out) || !reflect.DeepEqual(test.err, err) {
 				t.Errorf("Atoi(%q) = %v, %v want %v, %v\n",
-					test.in, out, err, test.out, test.err);
+					test.in, out, err, test.out, test.err)
 			}
 		}
 	case 64:
@@ -272,7 +272,7 @@ func TestAtoi(t *testing.T) {
 			out, err := Atoi(test.in);
 			if test.out != int64(out) || !reflect.DeepEqual(test.err, err) {
 				t.Errorf("Atoi(%q) = %v, %v want %v, %v\n",
-					test.in, out, err, test.out, test.err);
+					test.in, out, err, test.out, test.err)
 			}
 		}
 	}
diff --git a/src/pkg/strconv/decimal.go b/src/pkg/strconv/decimal.go
index 1f0205ca37..898a77dc77 100644
--- a/src/pkg/strconv/decimal.go
+++ b/src/pkg/strconv/decimal.go
@@ -24,17 +24,17 @@ type decimal struct {
 func (a *decimal) String() string {
 	n := 10 + a.nd;
 	if a.dp > 0 {
-		n += a.dp;
+		n += a.dp
 	}
 	if a.dp < 0 {
-		n += -a.dp;
+		n += -a.dp
 	}
 
 	buf := make([]byte, n);
 	w := 0;
 	switch {
 	case a.nd == 0:
-		return "0";
+		return "0"
 
 	case a.dp <= 0:
 		// zeros fill space between decimal point and digits
@@ -62,14 +62,14 @@ func (a *decimal) String() string {
 
 func copy(dst []byte, src []byte) int {
 	for i := 0; i < len(dst); i++ {
-		dst[i] = src[i];
+		dst[i] = src[i]
 	}
 	return len(dst);
 }
 
 func digitZero(dst []byte) int {
 	for i := 0; i < len(dst); i++ {
-		dst[i] = '0';
+		dst[i] = '0'
 	}
 	return len(dst);
 }
@@ -79,10 +79,10 @@ func digitZero(dst []byte) int {
 // independent of the number of digits.)
 func trim(a *decimal) {
 	for a.nd > 0 && a.d[a.nd - 1] == '0' {
-		a.nd--;
+		a.nd--
 	}
 	if a.nd == 0 {
-		a.dp = 0;
+		a.dp = 0
 	}
 }
 
@@ -230,10 +230,10 @@ var leftcheats = []leftCheat{
 func prefixIsLessThan(b []byte, s string) bool {
 	for i := 0; i < len(s); i++ {
 		if i >= len(b) {
-			return true;
+			return true
 		}
 		if b[i] != s[i] {
-			return b[i] < s[i];
+			return b[i] < s[i]
 		}
 	}
 	return false;
@@ -243,7 +243,7 @@ func prefixIsLessThan(b []byte, s string) bool {
 func leftShift(a *decimal, k uint) {
 	delta := leftcheats[k].delta;
 	if prefixIsLessThan(a.d[0 : a.nd], leftcheats[k].cutoff) {
-		delta--;
+		delta--
 	}
 
 	r := a.nd;		// read index
@@ -299,10 +299,10 @@ func (a *decimal) Shift(k int) *decimal {
 // If we chop a at nd digits, should we round up?
 func shouldRoundUp(a *decimal, nd int) bool {
 	if nd <= 0 || nd >= a.nd {
-		return false;
+		return false
 	}
 	if a.d[nd] == '5' && nd+1 == a.nd {	// exactly halfway - round to even
-		return (a.d[nd-1] - '0')%2 != 0;
+		return (a.d[nd-1] - '0')%2 != 0
 	}
 	// not halfway - digit tells all
 	return a.d[nd] >= '5';
@@ -312,10 +312,10 @@ func shouldRoundUp(a *decimal, nd int) bool {
 // Returns receiver for convenience.
 func (a *decimal) Round(nd int) *decimal {
 	if nd <= 0 || nd >= a.nd {
-		return a;
+		return a
 	}
 	if shouldRoundUp(a, nd) {
-		return a.RoundUp(nd);
+		return a.RoundUp(nd)
 	}
 	return a.RoundDown(nd);
 }
@@ -324,7 +324,7 @@ func (a *decimal) Round(nd int) *decimal {
 // Returns receiver for convenience.
 func (a *decimal) RoundDown(nd int) *decimal {
 	if nd <= 0 || nd >= a.nd {
-		return a;
+		return a
 	}
 	a.nd = nd;
 	trim(a);
@@ -335,7 +335,7 @@ func (a *decimal) RoundDown(nd int) *decimal {
 // Returns receiver for convenience.
 func (a *decimal) RoundUp(nd int) *decimal {
 	if nd <= 0 || nd >= a.nd {
-		return a;
+		return a
 	}
 
 	// round up
@@ -360,18 +360,18 @@ func (a *decimal) RoundUp(nd int) *decimal {
 // No guarantees about overflow.
 func (a *decimal) RoundedInteger() uint64 {
 	if a.dp > 20 {
-		return 0xFFFFFFFFFFFFFFFF;
+		return 0xFFFFFFFFFFFFFFFF
 	}
 	var i int;
 	n := uint64(0);
 	for i = 0; i < a.dp && i < a.nd; i++ {
-		n = n*10 + uint64(a.d[i] - '0');
+		n = n*10 + uint64(a.d[i] - '0')
 	}
 	for ; i < a.dp; i++ {
-		n *= 10;
+		n *= 10
 	}
 	if shouldRoundUp(a, a.dp) {
-		n++;
+		n++
 	}
 	return n;
 }
diff --git a/src/pkg/strconv/decimal_test.go b/src/pkg/strconv/decimal_test.go
index 1ac4d5e273..b86eec683e 100644
--- a/src/pkg/strconv/decimal_test.go
+++ b/src/pkg/strconv/decimal_test.go
@@ -35,7 +35,7 @@ func TestDecimalShift(t *testing.T) {
 		s := NewDecimal(test.i).Shift(test.shift).String();
 		if s != test.out {
 			t.Errorf("Decimal %v << %v = %v, want %v\n",
-				test.i, test.shift, s, test.out);
+				test.i, test.shift, s, test.out)
 		}
 	}
 }
@@ -71,17 +71,17 @@ func TestDecimalRound(t *testing.T) {
 		s := NewDecimal(test.i).RoundDown(test.nd).String();
 		if s != test.down {
 			t.Errorf("Decimal %v RoundDown %d = %v, want %v\n",
-				test.i, test.nd, s, test.down);
+				test.i, test.nd, s, test.down)
 		}
 		s = NewDecimal(test.i).Round(test.nd).String();
 		if s != test.round {
 			t.Errorf("Decimal %v Round %d = %v, want %v\n",
-				test.i, test.nd, s, test.down);
+				test.i, test.nd, s, test.down)
 		}
 		s = NewDecimal(test.i).RoundUp(test.nd).String();
 		if s != test.up {
 			t.Errorf("Decimal %v RoundUp %d = %v, want %v\n",
-				test.i, test.nd, s, test.up);
+				test.i, test.nd, s, test.up)
 		}
 	}
 }
@@ -111,7 +111,7 @@ func TestDecimalRoundedInteger(t *testing.T) {
 		int := NewDecimal(test.i).Shift(test.shift).RoundedInteger();
 		if int != test.int {
 			t.Errorf("Decimal %v >> %v RoundedInteger = %v, want %v\n",
-				test.i, test.shift, int, test.int);
+				test.i, test.shift, int, test.int)
 		}
 	}
 }
diff --git a/src/pkg/strconv/fp_test.go b/src/pkg/strconv/fp_test.go
index 47bf6231f7..757041d33c 100644
--- a/src/pkg/strconv/fp_test.go
+++ b/src/pkg/strconv/fp_test.go
@@ -16,11 +16,11 @@ import (
 func pow2(i int) float64 {
 	switch {
 	case i < 0:
-		return 1/pow2(-i);
+		return 1/pow2(-i)
 	case i == 0:
-		return 1;
+		return 1
 	case i == 1:
-		return 2;
+		return 2
 	}
 	return pow2(i/2)*pow2(i - i/2);
 }
@@ -32,7 +32,7 @@ func myatof64(s string) (f float64, ok bool) {
 	if len(a) == 2 {
 		n, err := strconv.Atoi64(a[0]);
 		if err != nil {
-			return 0, false;
+			return 0, false
 		}
 		e, err1 := strconv.Atoi(a[1]);
 		if err1 != nil {
@@ -64,7 +64,7 @@ func myatof64(s string) (f float64, ok bool) {
 	}
 	f1, err := strconv.Atof64(s);
 	if err != nil {
-		return 0, false;
+		return 0, false
 	}
 	return f1, true;
 }
@@ -88,7 +88,7 @@ func myatof32(s string) (f float32, ok bool) {
 	}
 	f1, err1 := strconv.Atof32(s);
 	if err1 != nil {
-		return 0, false;
+		return 0, false
 	}
 	return f1, true;
 }
@@ -96,7 +96,7 @@ func myatof32(s string) (f float32, ok bool) {
 func TestFp(t *testing.T) {
 	f, err := os.Open("testfp.txt", os.O_RDONLY, 0);
 	if err != nil {
-		panicln("testfp: open testfp.txt:", err.String());
+		panicln("testfp: open testfp.txt:", err.String())
 	}
 	defer f.Close();
 
@@ -106,15 +106,15 @@ func TestFp(t *testing.T) {
 	for {
 		line, err2 := b.ReadString('\n');
 		if err2 == os.EOF {
-			break;
+			break
 		}
 		if err2 != nil {
-			panicln("testfp: read testfp.txt:", err2.String());
+			panicln("testfp: read testfp.txt:", err2.String())
 		}
 		line = line[0 : len(line)-1];
 		lineno++;
 		if len(line) == 0 || line[0] == '#' {
-			continue;
+			continue
 		}
 		a := strings.Split(line, " ", 0);
 		if len(a) != 4 {
@@ -143,7 +143,7 @@ func TestFp(t *testing.T) {
 		}
 		if s != a[3] {
 			t.Error("testfp.txt:", lineno, ": ", a[0], " ", a[1], " ", a[2], " (", v, ") ",
-				"want ", a[3], " got ", s);
+				"want ", a[3], " got ", s)
 		}
 	}
 }
diff --git a/src/pkg/strconv/ftoa.go b/src/pkg/strconv/ftoa.go
index f10d071632..d31f44142c 100644
--- a/src/pkg/strconv/ftoa.go
+++ b/src/pkg/strconv/ftoa.go
@@ -28,7 +28,7 @@ func floatsize() int {
 	// is too small for a float32.
 	var f float = 1e-35;
 	if f*f == 0 {
-		return 32;
+		return 32
 	}
 	return 64;
 }
@@ -56,18 +56,18 @@ var FloatSize = floatsize()
 // because correct rounding and the number of digits
 // needed to identify f depend on the precision of the representation.
 func Ftoa32(f float32, fmt byte, prec int) string {
-	return genericFtoa(uint64(math.Float32bits(f)), fmt, prec, &float32info);
+	return genericFtoa(uint64(math.Float32bits(f)), fmt, prec, &float32info)
 }
 
 // Ftoa64 is like Ftoa32 but converts a 64-bit floating-point number.
 func Ftoa64(f float64, fmt byte, prec int) string {
-	return genericFtoa(math.Float64bits(f), fmt, prec, &float64info);
+	return genericFtoa(math.Float64bits(f), fmt, prec, &float64info)
 }
 
 // Ftoa behaves as Ftoa32 or Ftoa64, depending on the size of the float type.
 func Ftoa(f float, fmt byte, prec int) string {
 	if FloatSize == 32 {
-		return Ftoa32(float32(f), fmt, prec);
+		return Ftoa32(float32(f), fmt, prec)
 	}
 	return Ftoa64(float64(f), fmt, prec);
 }
@@ -81,26 +81,26 @@ func genericFtoa(bits uint64, fmt byte, prec int, flt *floatInfo) string {
 	case 1 << flt.expbits - 1:
 		// Inf, NaN
 		if mant != 0 {
-			return "NaN";
+			return "NaN"
 		}
 		if neg {
-			return "-Inf";
+			return "-Inf"
 		}
 		return "+Inf";
 
 	case 0:
 		// denormalized
-		exp++;
+		exp++
 
 	default:
 		// add implicit top bit
-		mant |= uint64(1) << flt.mantbits;
+		mant |= uint64(1) << flt.mantbits
 	}
 	exp += flt.bias;
 
 	// Pick off easy binary format.
 	if fmt == 'b' {
-		return fmtB(neg, mant, exp, flt);
+		return fmtB(neg, mant, exp, flt)
 	}
 
 	// Create exact decimal representation.
@@ -117,21 +117,21 @@ func genericFtoa(bits uint64, fmt byte, prec int, flt *floatInfo) string {
 		roundShortest(d, mant, exp, flt);
 		switch fmt {
 		case 'e', 'E':
-			prec = d.nd - 1;
+			prec = d.nd - 1
 		case 'f':
-			prec = max(d.nd - d.dp, 0);
+			prec = max(d.nd - d.dp, 0)
 		case 'g', 'G':
-			prec = d.nd;
+			prec = d.nd
 		}
 	} else {
 		switch fmt {
 		case 'e', 'E':
-			d.Round(prec+1);
+			d.Round(prec+1)
 		case 'f':
-			d.Round(d.dp + prec);
+			d.Round(d.dp + prec)
 		case 'g', 'G':
 			if prec == 0 {
-				prec = 1;
+				prec = 1
 			}
 			d.Round(prec);
 		}
@@ -139,24 +139,24 @@ func genericFtoa(bits uint64, fmt byte, prec int, flt *floatInfo) string {
 
 	switch fmt {
 	case 'e', 'E':
-		return fmtE(neg, d, prec, fmt);
+		return fmtE(neg, d, prec, fmt)
 	case 'f':
-		return fmtF(neg, d, prec);
+		return fmtF(neg, d, prec)
 	case 'g', 'G':
 		// trailing zeros are removed.
 		if prec > d.nd {
-			prec = d.nd;
+			prec = d.nd
 		}
 		// %e is used if the exponent from the conversion
 		// is less than -4 or greater than or equal to the precision.
 		// if precision was the shortest possible, use precision 6 for this decision.
 		eprec := prec;
 		if shortest {
-			eprec = 6;
+			eprec = 6
 		}
 		exp := d.dp - 1;
 		if exp < -4 || exp >= eprec {
-			return fmtE(neg, d, prec-1, fmt+'e'-'g');
+			return fmtE(neg, d, prec-1, fmt+'e'-'g')
 		}
 		return fmtF(neg, d, max(prec - d.dp, 0));
 	}
@@ -216,15 +216,15 @@ func roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo) {
 	for i := 0; i < d.nd; i++ {
 		var l, m, u byte;	// lower, middle, upper digits
 		if i < lower.nd {
-			l = lower.d[i];
+			l = lower.d[i]
 		} else {
-			l = '0';
+			l = '0'
 		}
 		m = d.d[i];
 		if i < upper.nd {
-			u = upper.d[i];
+			u = upper.d[i]
 		} else {
-			u = '0';
+			u = '0'
 		}
 
 		// Okay to round down (truncate) if lower has a different digit
@@ -264,9 +264,9 @@ func fmtE(neg bool, d *decimal, prec int, fmt byte) string {
 
 	// first digit
 	if d.nd == 0 {
-		buf[w] = '0';
+		buf[w] = '0'
 	} else {
-		buf[w] = d.d[0];
+		buf[w] = d.d[0]
 	}
 	w++;
 
@@ -276,9 +276,9 @@ func fmtE(neg bool, d *decimal, prec int, fmt byte) string {
 		w++;
 		for i := 0; i < prec; i++ {
 			if 1+i < d.nd {
-				buf[w] = d.d[1+i];
+				buf[w] = d.d[1+i]
 			} else {
-				buf[w] = '0';
+				buf[w] = '0'
 			}
 			w++;
 		}
@@ -289,13 +289,13 @@ func fmtE(neg bool, d *decimal, prec int, fmt byte) string {
 	w++;
 	exp := d.dp - 1;
 	if d.nd == 0 {	// special case: 0 has exponent 0
-		exp = 0;
+		exp = 0
 	}
 	if exp < 0 {
 		buf[w] = '-';
 		exp = -exp;
 	} else {
-		buf[w] = '+';
+		buf[w] = '+'
 	}
 	w++;
 
@@ -303,7 +303,7 @@ func fmtE(neg bool, d *decimal, prec int, fmt byte) string {
 	// count digits
 	n := 0;
 	for e := exp; e > 0; e /= 10 {
-		n++;
+		n++
 	}
 	// leading zeros
 	for i := n; i < 2; i++ {
@@ -354,9 +354,9 @@ func fmtF(neg bool, d *decimal, prec int) string {
 		w++;
 		for i := 0; i < prec; i++ {
 			if d.dp + i < 0 || d.dp + i >= d.nd {
-				buf[w] = '0';
+				buf[w] = '0'
 			} else {
-				buf[w] = d.d[d.dp + i];
+				buf[w] = d.d[d.dp + i]
 			}
 			w++;
 		}
@@ -402,7 +402,7 @@ func fmtB(neg bool, mant uint64, exp int, flt *floatInfo) string {
 
 func max(a, b int) int {
 	if a > b {
-		return a;
+		return a
 	}
 	return b;
 }
diff --git a/src/pkg/strconv/ftoa_test.go b/src/pkg/strconv/ftoa_test.go
index 7475ac6b3e..20548e384d 100644
--- a/src/pkg/strconv/ftoa_test.go
+++ b/src/pkg/strconv/ftoa_test.go
@@ -101,18 +101,18 @@ var ftoatests = []ftoaTest{
 
 func TestFtoa(t *testing.T) {
 	if FloatSize != 32 {
-		panic("floatsize: ", FloatSize);
+		panic("floatsize: ", FloatSize)
 	}
 	for i := 0; i < len(ftoatests); i++ {
 		test := &ftoatests[i];
 		s := Ftoa64(test.f, test.fmt, test.prec);
 		if s != test.s {
-			t.Error("test", test.f, string(test.fmt), test.prec, "want", test.s, "got", s);
+			t.Error("test", test.f, string(test.fmt), test.prec, "want", test.s, "got", s)
 		}
 		if float64(float32(test.f)) == test.f && test.fmt != 'b' {
 			s := Ftoa32(float32(test.f), test.fmt, test.prec);
 			if s != test.s {
-				t.Error("test32", test.f, string(test.fmt), test.prec, "want", test.s, "got", s);
+				t.Error("test32", test.f, string(test.fmt), test.prec, "want", test.s, "got", s)
 			}
 		}
 	}
diff --git a/src/pkg/strconv/itoa.go b/src/pkg/strconv/itoa.go
index b1025d4a23..65d60d79c6 100644
--- a/src/pkg/strconv/itoa.go
+++ b/src/pkg/strconv/itoa.go
@@ -7,7 +7,7 @@ package strconv
 // Uitob64 returns the string representation of i in the given base.
 func Uitob64(u uint64, base uint) string {
 	if u == 0 {
-		return "0";
+		return "0"
 	}
 
 	// Assemble decimal in reverse order.
@@ -26,11 +26,11 @@ func Uitob64(u uint64, base uint) string {
 // Itob64 returns the string representation of i in the given base.
 func Itob64(i int64, base uint) string {
 	if i == 0 {
-		return "0";
+		return "0"
 	}
 
 	if i < 0 {
-		return "-" + Uitob64(-uint64(i), base);
+		return "-" + Uitob64(-uint64(i), base)
 	}
 	return Uitob64(uint64(i), base);
 }
diff --git a/src/pkg/strconv/itoa_test.go b/src/pkg/strconv/itoa_test.go
index b8e7ee3ab2..f48a5342a6 100644
--- a/src/pkg/strconv/itoa_test.go
+++ b/src/pkg/strconv/itoa_test.go
@@ -62,14 +62,14 @@ func TestItoa(t *testing.T) {
 		s := Itob64(test.in, test.base);
 		if s != test.out {
 			t.Errorf("Itob64(%v, %v) = %v want %v\n",
-				test.in, test.base, s, test.out);
+				test.in, test.base, s, test.out)
 		}
 
 		if test.in >= 0 {
 			s := Uitob64(uint64(test.in), test.base);
 			if s != test.out {
 				t.Errorf("Uitob64(%v, %v) = %v want %v\n",
-					test.in, test.base, s, test.out);
+					test.in, test.base, s, test.out)
 			}
 		}
 
@@ -77,14 +77,14 @@ func TestItoa(t *testing.T) {
 			s := Itob(int(test.in), test.base);
 			if s != test.out {
 				t.Errorf("Itob(%v, %v) = %v want %v\n",
-					test.in, test.base, s, test.out);
+					test.in, test.base, s, test.out)
 			}
 
 			if test.in >= 0 {
 				s := Uitob(uint(test.in), test.base);
 				if s != test.out {
 					t.Errorf("Uitob(%v, %v) = %v want %v\n",
-						test.in, test.base, s, test.out);
+						test.in, test.base, s, test.out)
 				}
 			}
 		}
@@ -93,14 +93,14 @@ func TestItoa(t *testing.T) {
 			s := Itoa64(test.in);
 			if s != test.out {
 				t.Errorf("Itoa64(%v) = %v want %v\n",
-					test.in, s, test.out);
+					test.in, s, test.out)
 			}
 
 			if test.in >= 0 {
 				s := Uitob64(uint64(test.in), test.base);
 				if s != test.out {
 					t.Errorf("Uitob64(%v, %v) = %v want %v\n",
-						test.in, test.base, s, test.out);
+						test.in, test.base, s, test.out)
 				}
 			}
 
@@ -108,14 +108,14 @@ func TestItoa(t *testing.T) {
 				s := Itoa(int(test.in));
 				if s != test.out {
 					t.Errorf("Itoa(%v) = %v want %v\n",
-						test.in, s, test.out);
+						test.in, s, test.out)
 				}
 
 				if test.in >= 0 {
 					s := Uitoa(uint(test.in));
 					if s != test.out {
 						t.Errorf("Uitoa(%v) = %v want %v\n",
-							test.in, s, test.out);
+							test.in, s, test.out)
 					}
 				}
 			}
@@ -142,14 +142,14 @@ func TestUitoa(t *testing.T) {
 		s := Uitob64(test.in, test.base);
 		if s != test.out {
 			t.Errorf("Uitob64(%v, %v) = %v want %v\n",
-				test.in, test.base, s, test.out);
+				test.in, test.base, s, test.out)
 		}
 
 		if uint64(uint(test.in)) == test.in {
 			s := Uitob(uint(test.in), test.base);
 			if s != test.out {
 				t.Errorf("Uitob(%v, %v) = %v want %v\n",
-					test.in, test.base, s, test.out);
+					test.in, test.base, s, test.out)
 			}
 		}
 
@@ -157,14 +157,14 @@ func TestUitoa(t *testing.T) {
 			s := Uitoa64(test.in);
 			if s != test.out {
 				t.Errorf("Uitoa64(%v) = %v want %v\n",
-					test.in, s, test.out);
+					test.in, s, test.out)
 			}
 
 			if uint64(uint(test.in)) == test.in {
 				s := Uitoa(uint(test.in));
 				if s != test.out {
 					t.Errorf("Uitoa(%v) = %v want %v\n",
-						test.in, s, test.out);
+						test.in, s, test.out)
 				}
 			}
 		}
diff --git a/src/pkg/strconv/quote.go b/src/pkg/strconv/quote.go
index 807b25ace3..c655e2f8c4 100644
--- a/src/pkg/strconv/quote.go
+++ b/src/pkg/strconv/quote.go
@@ -24,41 +24,41 @@ func Quote(s string) string {
 	for ; len(s) > 0; s = s[1:len(s)] {
 		switch c := s[0]; {
 		case c == '"':
-			buf.WriteString(`\"`);
+			buf.WriteString(`\"`)
 		case c == '\\':
-			buf.WriteString(`\\`);
+			buf.WriteString(`\\`)
 		case ' ' <= c && c <= '~':
-			buf.WriteString(string(c));
+			buf.WriteString(string(c))
 		case c == '\a':
-			buf.WriteString(`\a`);
+			buf.WriteString(`\a`)
 		case c == '\b':
-			buf.WriteString(`\b`);
+			buf.WriteString(`\b`)
 		case c == '\f':
-			buf.WriteString(`\f`);
+			buf.WriteString(`\f`)
 		case c == '\n':
-			buf.WriteString(`\n`);
+			buf.WriteString(`\n`)
 		case c == '\r':
-			buf.WriteString(`\r`);
+			buf.WriteString(`\r`)
 		case c == '\t':
-			buf.WriteString(`\t`);
+			buf.WriteString(`\t`)
 		case c == '\v':
-			buf.WriteString(`\v`);
+			buf.WriteString(`\v`)
 
 		case c >= utf8.RuneSelf && utf8.FullRuneInString(s):
 			r, size := utf8.DecodeRuneInString(s);
 			if r == utf8.RuneError && size == 1 {
-				goto EscX;
+				goto EscX
 			}
 			s = s[size-1 : len(s)];	// next iteration will slice off 1 more
 			if r < 0x10000 {
 				buf.WriteString(`\u`);
 				for j := uint(0); j < 4; j++ {
-					buf.WriteByte(lowerhex[(r>>(12 - 4*j))&0xF]);
+					buf.WriteByte(lowerhex[(r>>(12 - 4*j))&0xF])
 				}
 			} else {
 				buf.WriteString(`\U`);
 				for j := uint(0); j < 8; j++ {
-					buf.WriteByte(lowerhex[(r>>(28 - 4*j))&0xF]);
+					buf.WriteByte(lowerhex[(r>>(28 - 4*j))&0xF])
 				}
 			}
 
@@ -78,7 +78,7 @@ func Quote(s string) string {
 func CanBackquote(s string) bool {
 	for i := 0; i < len(s); i++ {
 		if (s[i] < ' ' && s[i] != '\t') || s[i] == '`' {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -88,11 +88,11 @@ func unhex(b byte) (v int, ok bool) {
 	c := int(b);
 	switch {
 	case '0' <= c && c <= '9':
-		return c-'0', true;
+		return c-'0', true
 	case 'a' <= c && c <= 'f':
-		return c-'a'+10, true;
+		return c-'a'+10, true
 	case 'A' <= c && c <= 'F':
-		return c-'A'+10, true;
+		return c-'A'+10, true
 	}
 	return;
 }
@@ -120,7 +120,7 @@ func UnquoteChar(s string, quote byte) (value int, multibyte bool, tail string,
 		r, size := utf8.DecodeRuneInString(s);
 		return r, true, s[size:len(s)], nil;
 	case c != '\\':
-		return int(s[0]), false, s[1:len(s)], nil;
+		return int(s[0]), false, s[1:len(s)], nil
 	}
 
 	// hard case: c is backslash
@@ -133,28 +133,28 @@ func UnquoteChar(s string, quote byte) (value int, multibyte bool, tail string,
 
 	switch c {
 	case 'a':
-		value = '\a';
+		value = '\a'
 	case 'b':
-		value = '\b';
+		value = '\b'
 	case 'f':
-		value = '\f';
+		value = '\f'
 	case 'n':
-		value = '\n';
+		value = '\n'
 	case 'r':
-		value = '\r';
+		value = '\r'
 	case 't':
-		value = '\t';
+		value = '\t'
 	case 'v':
-		value = '\v';
+		value = '\v'
 	case 'x', 'u', 'U':
 		n := 0;
 		switch c {
 		case 'x':
-			n = 2;
+			n = 2
 		case 'u':
-			n = 4;
+			n = 4
 		case 'U':
-			n = 8;
+			n = 8
 		}
 		v := 0;
 		if len(s) < n {
@@ -190,7 +190,7 @@ func UnquoteChar(s string, quote byte) (value int, multibyte bool, tail string,
 		for j := 0; j < 2; j++ {	// one digit already; two more
 			x := int(s[j])-'0';
 			if x < 0 || x > 7 {
-				return;
+				return
 			}
 			v = (v<<3)|x;
 		}
@@ -201,7 +201,7 @@ func UnquoteChar(s string, quote byte) (value int, multibyte bool, tail string,
 		}
 		value = v;
 	case '\\':
-		value = '\\';
+		value = '\\'
 	case '\'', '"':
 		if c != quote {
 			err = os.EINVAL;
@@ -224,39 +224,39 @@ func UnquoteChar(s string, quote byte) (value int, multibyte bool, tail string,
 func Unquote(s string) (t string, err os.Error) {
 	n := len(s);
 	if n < 2 {
-		return "", os.EINVAL;
+		return "", os.EINVAL
 	}
 	quote := s[0];
 	if quote != s[n-1] {
-		return "", os.EINVAL;
+		return "", os.EINVAL
 	}
 	s = s[1 : n-1];
 
 	if quote == '`' {
 		if strings.Index(s, "`") >= 0 {
-			return "", os.EINVAL;
+			return "", os.EINVAL
 		}
 		return s, nil;
 	}
 	if quote != '"' && quote != '\'' {
-		return "", err;
+		return "", err
 	}
 
 	var buf bytes.Buffer;
 	for len(s) > 0 {
 		c, multibyte, ss, err := UnquoteChar(s, quote);
 		if err != nil {
-			return "", err;
+			return "", err
 		}
 		s = ss;
 		if c < utf8.RuneSelf || !multibyte {
-			buf.WriteByte(byte(c));
+			buf.WriteByte(byte(c))
 		} else {
-			buf.WriteString(string(c));
+			buf.WriteString(string(c))
 		}
 		if quote == '\'' && len(s) != 0 {
 			// single-quoted must be single character
-			return "", os.EINVAL;
+			return "", os.EINVAL
 		}
 	}
 	return buf.String(), nil;
diff --git a/src/pkg/strconv/quote_test.go b/src/pkg/strconv/quote_test.go
index 7f83914912..3c42d39711 100644
--- a/src/pkg/strconv/quote_test.go
+++ b/src/pkg/strconv/quote_test.go
@@ -28,7 +28,7 @@ func TestQuote(t *testing.T) {
 	for i := 0; i < len(quotetests); i++ {
 		tt := quotetests[i];
 		if out := Quote(tt.in); out != tt.out {
-			t.Errorf("Quote(%s) = %s, want %s", tt.in, out, tt.out);
+			t.Errorf("Quote(%s) = %s, want %s", tt.in, out, tt.out)
 		}
 	}
 }
@@ -83,7 +83,7 @@ func TestCanBackquote(t *testing.T) {
 	for i := 0; i < len(canbackquotetests); i++ {
 		tt := canbackquotetests[i];
 		if out := CanBackquote(tt.in); out != tt.out {
-			t.Errorf("CanBackquote(%q) = %v, want %v", tt.in, out, tt.out);
+			t.Errorf("CanBackquote(%q) = %v, want %v", tt.in, out, tt.out)
 		}
 	}
 }
@@ -149,7 +149,7 @@ func TestUnquote(t *testing.T) {
 	for i := 0; i < len(unquotetests); i++ {
 		tt := unquotetests[i];
 		if out, err := Unquote(tt.in); err != nil && out != tt.out {
-			t.Errorf("Unquote(%#q) = %q, %v want %q, nil", tt.in, out, err, tt.out);
+			t.Errorf("Unquote(%#q) = %q, %v want %q, nil", tt.in, out, err, tt.out)
 		}
 	}
 
@@ -157,14 +157,14 @@ func TestUnquote(t *testing.T) {
 	for i := 0; i < len(quotetests); i++ {
 		tt := quotetests[i];
 		if in, err := Unquote(tt.out); in != tt.in {
-			t.Errorf("Unquote(%#q) = %q, %v, want %q, nil", tt.out, in, err, tt.in);
+			t.Errorf("Unquote(%#q) = %q, %v, want %q, nil", tt.out, in, err, tt.in)
 		}
 	}
 
 	for i := 0; i < len(misquoted); i++ {
 		s := misquoted[i];
 		if out, err := Unquote(s); out != "" || err != os.EINVAL {
-			t.Errorf("Unquote(%#q) = %q, %v want %q, %v", s, out, err, "", os.EINVAL);
+			t.Errorf("Unquote(%#q) = %q, %v want %q, %v", s, out, err, "", os.EINVAL)
 		}
 	}
 }
diff --git a/src/pkg/strings/reader.go b/src/pkg/strings/reader.go
index 55e4d963f7..880bafacdd 100644
--- a/src/pkg/strings/reader.go
+++ b/src/pkg/strings/reader.go
@@ -13,7 +13,7 @@ type Reader string
 func (r *Reader) Read(b []byte) (n int, err os.Error) {
 	s := *r;
 	if len(s) == 0 {
-		return 0, os.EOF;
+		return 0, os.EOF
 	}
 	for n < len(s) && n < len(b) {
 		b[n] = s[n];
@@ -26,7 +26,7 @@ func (r *Reader) Read(b []byte) (n int, err os.Error) {
 func (r *Reader) ReadByte() (b byte, err os.Error) {
 	s := *r;
 	if len(s) == 0 {
-		return 0, os.EOF;
+		return 0, os.EOF
 	}
 	b = s[0];
 	*r = s[1:len(s)];
diff --git a/src/pkg/strings/strings.go b/src/pkg/strings/strings.go
index 4169f62114..5e1b5b35cc 100644
--- a/src/pkg/strings/strings.go
+++ b/src/pkg/strings/strings.go
@@ -14,7 +14,7 @@ import (
 // Invalid UTF-8 sequences become correct encodings of U+FFF8.
 func explode(s string, n int) []string {
 	if n <= 0 {
-		n = len(s);
+		n = len(s)
 	}
 	a := make([]string, n);
 	var size, rune int;
@@ -36,7 +36,7 @@ func explode(s string, n int) []string {
 // Count counts the number of non-overlapping instances of sep in s.
 func Count(s, sep string) int {
 	if sep == "" {
-		return utf8.RuneCountInString(s) + 1;
+		return utf8.RuneCountInString(s) + 1
 	}
 	c := sep[0];
 	n := 0;
@@ -53,12 +53,12 @@ func Count(s, sep string) int {
 func Index(s, sep string) int {
 	n := len(sep);
 	if n == 0 {
-		return 0;
+		return 0
 	}
 	c := sep[0];
 	for i := 0; i+n <= len(s); i++ {
 		if s[i] == c && (n == 1 || s[i : i+n] == sep) {
-			return i;
+			return i
 		}
 	}
 	return -1;
@@ -68,12 +68,12 @@ func Index(s, sep string) int {
 func LastIndex(s, sep string) int {
 	n := len(sep);
 	if n == 0 {
-		return len(s);
+		return len(s)
 	}
 	c := sep[0];
 	for i := len(s)-n; i >= 0; i-- {
 		if s[i] == c && (n == 1 || s[i : i+n] == sep) {
-			return i;
+			return i
 		}
 	}
 	return -1;
@@ -83,10 +83,10 @@ func LastIndex(s, sep string) int {
 // including sepSave bytes of sep in the subarrays.
 func genSplit(s, sep string, sepSave, n int) []string {
 	if sep == "" {
-		return explode(s, n);
+		return explode(s, n)
 	}
 	if n <= 0 {
-		n = Count(s, sep) + 1;
+		n = Count(s, sep) + 1
 	}
 	c := sep[0];
 	start := 0;
@@ -113,21 +113,21 @@ func Split(s, sep string, n int) []string	{ return genSplit(s, sep, 0, n) }
 // If sep is empty, SplitAfter splits s after each UTF-8 sequence.
 // If n > 0, SplitAfter splits s into at most n substrings; the last substring will be the unsplit remainder.
 func SplitAfter(s, sep string, n int) []string {
-	return genSplit(s, sep, len(sep), n);
+	return genSplit(s, sep, len(sep), n)
 }
 
 // Join concatenates the elements of a to create a single string.   The separator string
 // sep is placed between elements in the resulting string.
 func Join(a []string, sep string) string {
 	if len(a) == 0 {
-		return "";
+		return ""
 	}
 	if len(a) == 1 {
-		return a[0];
+		return a[0]
 	}
 	n := len(sep)*(len(a)-1);
 	for i := 0; i < len(a); i++ {
-		n += len(a[i]);
+		n += len(a[i])
 	}
 
 	b := make([]byte, n);
@@ -151,12 +151,12 @@ func Join(a []string, sep string) string {
 
 // HasPrefix tests whether the string s begins with prefix.
 func HasPrefix(s, prefix string) bool {
-	return len(s) >= len(prefix) && s[0:len(prefix)] == prefix;
+	return len(s) >= len(prefix) && s[0:len(prefix)] == prefix
 }
 
 // HasSuffix tests whether the string s ends with suffix.
 func HasSuffix(s, suffix string) bool {
-	return len(s) >= len(suffix) && s[len(s)-len(suffix) : len(s)] == suffix;
+	return len(s) >= len(suffix) && s[len(s)-len(suffix) : len(s)] == suffix
 }
 
 // Map returns a copy of the string s with all its characters modified
@@ -172,14 +172,14 @@ func Map(mapping func(rune int) int, s string) string {
 		rune := mapping(c);
 		wid := 1;
 		if rune >= utf8.RuneSelf {
-			wid = utf8.RuneLen(rune);
+			wid = utf8.RuneLen(rune)
 		}
 		if nbytes+wid > maxbytes {
 			// Grow the buffer.
 			maxbytes = maxbytes*2 + utf8.UTFMax;
 			nb := make([]byte, maxbytes);
 			for i, c := range b[0:nbytes] {
-				nb[i] = c;
+				nb[i] = c
 			}
 			b = nb;
 		}
@@ -205,10 +205,10 @@ func TrimSpace(s string) string {
 		wid := 1;
 		rune := int(s[start]);
 		if rune >= utf8.RuneSelf {
-			rune, wid = utf8.DecodeRuneInString(s[start:end]);
+			rune, wid = utf8.DecodeRuneInString(s[start:end])
 		}
 		if !unicode.IsSpace(rune) {
-			break;
+			break
 		}
 		start += wid;
 	}
@@ -220,12 +220,12 @@ func TrimSpace(s string) string {
 			for wid = 2; start <= end-wid && !utf8.RuneStart(s[end-wid]); wid++ {
 			}
 			if start > end-wid {	// invalid UTF-8 sequence; stop processing
-				return s[start:end];
+				return s[start:end]
 			}
 			rune, wid = utf8.DecodeRuneInString(s[end-wid : end]);
 		}
 		if !unicode.IsSpace(rune) {
-			break;
+			break
 		}
 		end -= wid;
 	}
@@ -236,7 +236,7 @@ func TrimSpace(s string) string {
 func Bytes(s string) []byte {
 	b := make([]byte, len(s));
 	for i := 0; i < len(s); i++ {
-		b[i] = s[i];
+		b[i] = s[i]
 	}
 	return b;
 }
diff --git a/src/pkg/strings/strings_test.go b/src/pkg/strings/strings_test.go
index f7aa4dbaec..1aab16eed8 100644
--- a/src/pkg/strings/strings_test.go
+++ b/src/pkg/strings/strings_test.go
@@ -13,11 +13,11 @@ import (
 
 func eq(a, b []string) bool {
 	if len(a) != len(b) {
-		return false;
+		return false
 	}
 	for i := 0; i < len(a); i++ {
 		if a[i] != b[i] {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -69,7 +69,7 @@ func runIndexTests(t *testing.T, f func(s, sep string) int, funcName string, tes
 	for _, test := range testCases {
 		actual := f(test.s, test.sep);
 		if actual != test.out {
-			t.Errorf("%s(%q,%q) = %v; want %v", funcName, test.s, test.sep, actual, test.out);
+			t.Errorf("%s(%q,%q) = %v; want %v", funcName, test.s, test.sep, actual, test.out)
 		}
 	}
 }
@@ -100,7 +100,7 @@ func TestExplode(t *testing.T) {
 		}
 		s := Join(a, "");
 		if s != tt.s {
-			t.Errorf(`Join(explode(%q, %d), "") = %q`, tt.s, tt.n, s);
+			t.Errorf(`Join(explode(%q, %d), "") = %q`, tt.s, tt.n, s)
 		}
 	}
 }
@@ -136,7 +136,7 @@ func TestSplit(t *testing.T) {
 		}
 		s := Join(a, tt.sep);
 		if s != tt.s {
-			t.Errorf("Join(Split(%q, %q, %d), %q) = %q", tt.s, tt.sep, tt.n, tt.sep, s);
+			t.Errorf("Join(Split(%q, %q, %d), %q) = %q", tt.s, tt.sep, tt.n, tt.sep, s)
 		}
 	}
 }
@@ -166,7 +166,7 @@ func TestSplitAfter(t *testing.T) {
 		}
 		s := Join(a, "");
 		if s != tt.s {
-			t.Errorf(`Join(Split(%q, %q, %d), %q) = %q`, tt.s, tt.sep, tt.n, tt.sep, s);
+			t.Errorf(`Join(Split(%q, %q, %d), %q) = %q`, tt.s, tt.sep, tt.n, tt.sep, s)
 		}
 	}
 }
@@ -182,7 +182,7 @@ func runStringTests(t *testing.T, f func(string) string, funcName string, testCa
 	for _, tc := range testCases {
 		actual := f(tc.in);
 		if actual != tc.out {
-			t.Errorf("%s(%q) = %q; want %q", funcName, tc.in, actual, tc.out);
+			t.Errorf("%s(%q) = %q; want %q", funcName, tc.in, actual, tc.out)
 		}
 	}
 }
@@ -221,7 +221,7 @@ var trimSpaceTests = []StringTest{
 func tenRunes(rune int) string {
 	r := make([]int, 10);
 	for i := range r {
-		r[i] = rune;
+		r[i] = rune
 	}
 	return string(r);
 }
@@ -234,14 +234,14 @@ func TestMap(t *testing.T) {
 	m := Map(maxRune, a);
 	expect := tenRunes(unicode.MaxRune);
 	if m != expect {
-		t.Errorf("growing: expected %q got %q", expect, m);
+		t.Errorf("growing: expected %q got %q", expect, m)
 	}
 	// 2. Shrink
 	minRune := func(rune int) int { return 'a' };
 	m = Map(minRune, tenRunes(unicode.MaxRune));
 	expect = a;
 	if m != expect {
-		t.Errorf("shrinking: expected %q got %q", expect, m);
+		t.Errorf("shrinking: expected %q got %q", expect, m)
 	}
 }
 
@@ -253,18 +253,18 @@ func TestTrimSpace(t *testing.T)	{ runStringTests(t, TrimSpace, "TrimSpace", tri
 
 func equal(m string, s1, s2 string, t *testing.T) bool {
 	if s1 == s2 {
-		return true;
+		return true
 	}
 	e1 := Split(s1, "", 0);
 	e2 := Split(s2, "", 0);
 	for i, c1 := range e1 {
 		if i > len(e2) {
-			break;
+			break
 		}
 		r1, _ := utf8.DecodeRuneInString(c1);
 		r2, _ := utf8.DecodeRuneInString(e2[i]);
 		if r1 != r2 {
-			t.Errorf("%s diff at %d: U+%04X U+%04X", m, i, r1, r2);
+			t.Errorf("%s diff at %d: U+%04X U+%04X", m, i, r1, r2)
 		}
 	}
 	return false;
@@ -274,7 +274,7 @@ func TestCaseConsistency(t *testing.T) {
 	// Make a string of all the runes.
 	a := make([]int, unicode.MaxRune + 1);
 	for i := range a {
-		a[i] = i;
+		a[i] = i
 	}
 	s := string(a);
 	// convert the cases.
@@ -283,16 +283,16 @@ func TestCaseConsistency(t *testing.T) {
 
 	// Consistency checks
 	if n := utf8.RuneCountInString(upper); n != unicode.MaxRune + 1 {
-		t.Error("rune count wrong in upper:", n);
+		t.Error("rune count wrong in upper:", n)
 	}
 	if n := utf8.RuneCountInString(lower); n != unicode.MaxRune + 1 {
-		t.Error("rune count wrong in lower:", n);
+		t.Error("rune count wrong in lower:", n)
 	}
 	if !equal("ToUpper(upper)", ToUpper(upper), upper, t) {
-		t.Error("ToUpper(upper) consistency fail");
+		t.Error("ToUpper(upper) consistency fail")
 	}
 	if !equal("ToLower(lower)", ToLower(lower), lower, t) {
-		t.Error("ToLower(lower) consistency fail");
+		t.Error("ToLower(lower) consistency fail")
 	}
 	/*
 		  These fail because of non-one-to-oneness of the data, such as multiple
diff --git a/src/pkg/sync/mutex.go b/src/pkg/sync/mutex.go
index ac59db12de..c02abc575f 100644
--- a/src/pkg/sync/mutex.go
+++ b/src/pkg/sync/mutex.go
@@ -25,7 +25,7 @@ func xadd(val *uint32, delta int32) (new uint32) {
 		v := *val;
 		nv := v+uint32(delta);
 		if cas(val, v, nv) {
-			return nv;
+			return nv
 		}
 	}
 	panic("unreached");
@@ -37,7 +37,7 @@ func xadd(val *uint32, delta int32) (new uint32) {
 func (m *Mutex) Lock() {
 	if xadd(&m.key, 1) == 1 {
 		// changed from 0 to 1; we hold lock
-		return;
+		return
 	}
 	runtime.Semacquire(&m.sema);
 }
@@ -51,7 +51,7 @@ func (m *Mutex) Lock() {
 func (m *Mutex) Unlock() {
 	if xadd(&m.key, -1) == 0 {
 		// changed from 1 to 0; no contention
-		return;
+		return
 	}
 	runtime.Semrelease(&m.sema);
 }
diff --git a/src/pkg/sync/mutex_test.go b/src/pkg/sync/mutex_test.go
index 03490af122..72c9c4342a 100644
--- a/src/pkg/sync/mutex_test.go
+++ b/src/pkg/sync/mutex_test.go
@@ -25,10 +25,10 @@ func TestSemaphore(t *testing.T) {
 	*s = 1;
 	c := make(chan bool);
 	for i := 0; i < 10; i++ {
-		go HammerSemaphore(s, c);
+		go HammerSemaphore(s, c)
 	}
 	for i := 0; i < 10; i++ {
-		<-c;
+		<-c
 	}
 }
 
@@ -45,9 +45,9 @@ func TestMutex(t *testing.T) {
 	m := new(Mutex);
 	c := make(chan bool);
 	for i := 0; i < 10; i++ {
-		go HammerMutex(m, c);
+		go HammerMutex(m, c)
 	}
 	for i := 0; i < 10; i++ {
-		<-c;
+		<-c
 	}
 }
diff --git a/src/pkg/syscall/errstr.go b/src/pkg/syscall/errstr.go
index f21e1d94eb..c1935d5b28 100644
--- a/src/pkg/syscall/errstr.go
+++ b/src/pkg/syscall/errstr.go
@@ -7,7 +7,7 @@ package syscall
 
 func str(val int) string {	// do it here rather than with fmt to avoid dependency
 	if val < 0 {
-		return "-"+str(-val);
+		return "-"+str(-val)
 	}
 	var buf [32]byte;	// big enough for int64
 	i := len(buf)-1;
@@ -22,7 +22,7 @@ func str(val int) string {	// do it here rather than with fmt to avoid dependenc
 
 func Errstr(errno int) string {
 	if errno < 0 || errno >= int(len(errors)) {
-		return "error "+str(errno);
+		return "error "+str(errno)
 	}
 	return errors[errno];
 }
diff --git a/src/pkg/syscall/exec.go b/src/pkg/syscall/exec.go
index 4310b9e1ac..a3be959bd5 100644
--- a/src/pkg/syscall/exec.go
+++ b/src/pkg/syscall/exec.go
@@ -65,7 +65,7 @@ var ForkLock sync.RWMutex
 func StringArrayPtr(ss []string) []*byte {
 	bb := make([]*byte, len(ss)+1);
 	for i := 0; i < len(ss); i++ {
-		bb[i] = StringBytePtr(ss[i]);
+		bb[i] = StringBytePtr(ss[i])
 	}
 	bb[len(ss)] = nil;
 	return bb;
@@ -76,12 +76,12 @@ func CloseOnExec(fd int)	{ fcntl(fd, F_SETFD, FD_CLOEXEC) }
 func SetNonblock(fd int, nonblocking bool) (errno int) {
 	flag, err := fcntl(fd, F_GETFL, 0);
 	if err != 0 {
-		return err;
+		return err
 	}
 	if nonblocking {
-		flag |= O_NONBLOCK;
+		flag |= O_NONBLOCK
 	} else {
-		flag &= ^O_NONBLOCK;
+		flag &= ^O_NONBLOCK
 	}
 	_, err = fcntl(fd, F_SETFL, flag);
 	return err;
@@ -109,7 +109,7 @@ func forkAndExecInChild(argv0 *byte, argv []*byte, envv []*byte, traceme bool, d
 	// No more allocation or calls of non-assembly functions.
 	r1, r2, err1 = RawSyscall(SYS_FORK, 0, 0, 0);
 	if err1 != 0 {
-		return 0, int(err1);
+		return 0, int(err1)
 	}
 
 	// On Darwin:
@@ -117,12 +117,12 @@ func forkAndExecInChild(argv0 *byte, argv []*byte, envv []*byte, traceme bool, d
 	//	r2 = 0 in parent, 1 in child.
 	// Convert to normal Unix r1 = 0 in child.
 	if darwin && r2 == 1 {
-		r1 = 0;
+		r1 = 0
 	}
 
 	if r1 != 0 {
 		// parent; return PID
-		return int(r1), 0;
+		return int(r1), 0
 	}
 
 	// Fork succeeded, now in child.
@@ -131,7 +131,7 @@ func forkAndExecInChild(argv0 *byte, argv []*byte, envv []*byte, traceme bool, d
 	if traceme {
 		_, _, err1 = RawSyscall(SYS_PTRACE, uintptr(PTRACE_TRACEME), 0, 0);
 		if err1 != 0 {
-			goto childerror;
+			goto childerror
 		}
 	}
 
@@ -139,7 +139,7 @@ func forkAndExecInChild(argv0 *byte, argv []*byte, envv []*byte, traceme bool, d
 	if dir != nil {
 		_, _, err1 = RawSyscall(SYS_CHDIR, uintptr(unsafe.Pointer(dir)), 0, 0);
 		if err1 != 0 {
-			goto childerror;
+			goto childerror
 		}
 	}
 
@@ -149,7 +149,7 @@ func forkAndExecInChild(argv0 *byte, argv []*byte, envv []*byte, traceme bool, d
 	if pipe < nextfd {
 		_, _, err1 = RawSyscall(SYS_DUP2, uintptr(pipe), uintptr(nextfd), 0);
 		if err1 != 0 {
-			goto childerror;
+			goto childerror
 		}
 		RawSyscall(SYS_FCNTL, uintptr(nextfd), F_SETFD, FD_CLOEXEC);
 		pipe = nextfd;
@@ -159,13 +159,13 @@ func forkAndExecInChild(argv0 *byte, argv []*byte, envv []*byte, traceme bool, d
 		if fd[i] >= 0 && fd[i] < int(i) {
 			_, _, err1 = RawSyscall(SYS_DUP2, uintptr(fd[i]), uintptr(nextfd), 0);
 			if err1 != 0 {
-				goto childerror;
+				goto childerror
 			}
 			RawSyscall(SYS_FCNTL, uintptr(nextfd), F_SETFD, FD_CLOEXEC);
 			fd[i] = nextfd;
 			nextfd++;
 			if nextfd == pipe {	// don't stomp on pipe
-				nextfd++;
+				nextfd++
 			}
 		}
 	}
@@ -181,7 +181,7 @@ func forkAndExecInChild(argv0 *byte, argv []*byte, envv []*byte, traceme bool, d
 			// probably not elsewhere either.
 			_, _, err1 = RawSyscall(SYS_FCNTL, uintptr(fd[i]), F_SETFD, 0);
 			if err1 != 0 {
-				goto childerror;
+				goto childerror
 			}
 			continue;
 		}
@@ -189,7 +189,7 @@ func forkAndExecInChild(argv0 *byte, argv []*byte, envv []*byte, traceme bool, d
 		// which is exactly what we want.
 		_, _, err1 = RawSyscall(SYS_DUP2, uintptr(fd[i]), uintptr(i), 0);
 		if err1 != 0 {
-			goto childerror;
+			goto childerror
 		}
 	}
 
@@ -198,7 +198,7 @@ func forkAndExecInChild(argv0 *byte, argv []*byte, envv []*byte, traceme bool, d
 	// Programs that know they inherit fds >= 3 will need
 	// to set them close-on-exec.
 	for i = len(fd); i < 3; i++ {
-		RawSyscall(SYS_CLOSE, uintptr(i), 0, 0);
+		RawSyscall(SYS_CLOSE, uintptr(i), 0, 0)
 	}
 
 	// Time to exec.
@@ -211,7 +211,7 @@ childerror:
 	// send error code on pipe
 	RawSyscall(SYS_WRITE, uintptr(pipe), uintptr(unsafe.Pointer(&err1)), uintptr(unsafe.Sizeof(err1)));
 	for {
-		RawSyscall(SYS_EXIT, 253, 0, 0);
+		RawSyscall(SYS_EXIT, 253, 0, 0)
 	}
 
 	// Calling panic is not actually safe,
@@ -235,7 +235,7 @@ func forkExec(argv0 string, argv []string, envv []string, traceme bool, dir stri
 	envvp := StringArrayPtr(envv);
 	var dirp *byte;
 	if len(dir) > 0 {
-		dirp = StringBytePtr(dir);
+		dirp = StringBytePtr(dir)
 	}
 
 	// Acquire the fork lock so that no other threads
@@ -245,13 +245,13 @@ func forkExec(argv0 string, argv []string, envv []string, traceme bool, dir stri
 
 	// Allocate child status pipe close on exec.
 	if err = Pipe(&p); err != 0 {
-		goto error;
+		goto error
 	}
 	if _, err = fcntl(p[0], F_SETFD, FD_CLOEXEC); err != 0 {
-		goto error;
+		goto error
 	}
 	if _, err = fcntl(p[1], F_SETFD, FD_CLOEXEC); err != 0 {
-		goto error;
+		goto error
 	}
 
 	// Kick off child.
@@ -273,17 +273,17 @@ func forkExec(argv0 string, argv []string, envv []string, traceme bool, dir stri
 	Close(p[0]);
 	if err != 0 || n != 0 {
 		if n == unsafe.Sizeof(err1) {
-			err = int(err1);
+			err = int(err1)
 		}
 		if err == 0 {
-			err = EPIPE;
+			err = EPIPE
 		}
 
 		// Child failed; wait for it to exit, to make sure
 		// the zombies don't accumulate.
 		_, err1 := Wait4(pid, &wstatus, 0, nil);
 		for err1 == EINTR {
-			_, err1 = Wait4(pid, &wstatus, 0, nil);
+			_, err1 = Wait4(pid, &wstatus, 0, nil)
 		}
 		return 0, err;
 	}
@@ -294,12 +294,12 @@ func forkExec(argv0 string, argv []string, envv []string, traceme bool, dir stri
 
 // Combination of fork and exec, careful to be thread safe.
 func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []int) (pid int, err int) {
-	return forkExec(argv0, argv, envv, false, dir, fd);
+	return forkExec(argv0, argv, envv, false, dir, fd)
 }
 
 // PtraceForkExec is like ForkExec, but starts the child in a traced state.
 func PtraceForkExec(argv0 string, argv []string, envv []string, dir string, fd []int) (pid int, err int) {
-	return forkExec(argv0, argv, envv, true, dir, fd);
+	return forkExec(argv0, argv, envv, true, dir, fd)
 }
 
 // Ordinary exec.
diff --git a/src/pkg/syscall/syscall.go b/src/pkg/syscall/syscall.go
index 89252d1f8b..06f3635d68 100644
--- a/src/pkg/syscall/syscall.go
+++ b/src/pkg/syscall/syscall.go
@@ -20,7 +20,7 @@ func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr)
 func StringByteSlice(s string) []byte {
 	a := make([]byte, len(s)+1);
 	for i := 0; i < len(s); i++ {
-		a[i] = s[i];
+		a[i] = s[i]
 	}
 	return a;
 }
diff --git a/src/pkg/syscall/syscall_darwin.go b/src/pkg/syscall/syscall_darwin.go
index 792dc0bbc5..2663c70921 100644
--- a/src/pkg/syscall/syscall_darwin.go
+++ b/src/pkg/syscall/syscall_darwin.go
@@ -36,37 +36,37 @@ func Getwd() (string, int)	{ return "", ENOTSUP }
 func Getgroups() (gids []int, errno int) {
 	n, err := getgroups(0, nil);
 	if err != 0 {
-		return nil, errno;
+		return nil, errno
 	}
 	if n == 0 {
-		return nil, 0;
+		return nil, 0
 	}
 
 	// Sanity check group count.  Max is 16 on BSD.
 	if n < 0 || n > 1000 {
-		return nil, EINVAL;
+		return nil, EINVAL
 	}
 
 	a := make([]_Gid_t, n);
 	n, err = getgroups(n, &a[0]);
 	if err != 0 {
-		return nil, errno;
+		return nil, errno
 	}
 	gids = make([]int, n);
 	for i, v := range a[0:n] {
-		gids[i] = int(v);
+		gids[i] = int(v)
 	}
 	return;
 }
 
 func Setgroups(gids []int) (errno int) {
 	if len(gids) == 0 {
-		return setgroups(0, nil);
+		return setgroups(0, nil)
 	}
 
 	a := make([]_Gid_t, len(gids));
 	for i, v := range gids {
-		a[i] = _Gid_t(v);
+		a[i] = _Gid_t(v)
 	}
 	return setgroups(len(a), &a[0]);
 }
@@ -92,7 +92,7 @@ func (w WaitStatus) Exited() bool	{ return w&mask == exited }
 
 func (w WaitStatus) ExitStatus() int {
 	if w&mask != exited {
-		return -1;
+		return -1
 	}
 	return int(w>>shift);
 }
@@ -102,7 +102,7 @@ func (w WaitStatus) Signaled() bool	{ return w&mask != stopped && w&mask != 0 }
 func (w WaitStatus) Signal() int {
 	sig := int(w&mask);
 	if sig == stopped || sig == 0 {
-		return -1;
+		return -1
 	}
 	return sig;
 }
@@ -115,14 +115,14 @@ func (w WaitStatus) Continued() bool	{ return w&mask == stopped && w>>shift == S
 
 func (w WaitStatus) StopSignal() int {
 	if !w.Stopped() {
-		return -1;
+		return -1
 	}
 	return int(w>>shift)&0xFF;
 }
 
 func (w WaitStatus) TrapCause() int {
 	// Darwin doesn't have trap causes
-	return -1;
+	return -1
 }
 
 //sys	wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, errno int)
@@ -131,7 +131,7 @@ func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int,
 	var status _C_int;
 	wpid, errno = wait4(pid, &status, options, rusage);
 	if wstatus != nil {
-		*wstatus = WaitStatus(status);
+		*wstatus = WaitStatus(status)
 	}
 	return;
 }
@@ -140,7 +140,7 @@ func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int,
 
 func Pipe(p []int) (errno int) {
 	if len(p) != 2 {
-		return EINVAL;
+		return EINVAL
 	}
 	p[0], p[1], errno = pipe();
 	return;
@@ -175,7 +175,7 @@ type SockaddrInet4 struct {
 
 func (sa *SockaddrInet4) sockaddr() (uintptr, _Socklen, int) {
 	if sa.Port < 0 || sa.Port > 0xFFFF {
-		return 0, 0, EINVAL;
+		return 0, 0, EINVAL
 	}
 	sa.raw.Len = SizeofSockaddrInet4;
 	sa.raw.Family = AF_INET;
@@ -183,7 +183,7 @@ func (sa *SockaddrInet4) sockaddr() (uintptr, _Socklen, int) {
 	p[0] = byte(sa.Port >> 8);
 	p[1] = byte(sa.Port);
 	for i := 0; i < len(sa.Addr); i++ {
-		sa.raw.Addr[i] = sa.Addr[i];
+		sa.raw.Addr[i] = sa.Addr[i]
 	}
 	return uintptr(unsafe.Pointer(&sa.raw)), _Socklen(sa.raw.Len), 0;
 }
@@ -196,7 +196,7 @@ type SockaddrInet6 struct {
 
 func (sa *SockaddrInet6) sockaddr() (uintptr, _Socklen, int) {
 	if sa.Port < 0 || sa.Port > 0xFFFF {
-		return 0, 0, EINVAL;
+		return 0, 0, EINVAL
 	}
 	sa.raw.Len = SizeofSockaddrInet6;
 	sa.raw.Family = AF_INET6;
@@ -204,7 +204,7 @@ func (sa *SockaddrInet6) sockaddr() (uintptr, _Socklen, int) {
 	p[0] = byte(sa.Port >> 8);
 	p[1] = byte(sa.Port);
 	for i := 0; i < len(sa.Addr); i++ {
-		sa.raw.Addr[i] = sa.Addr[i];
+		sa.raw.Addr[i] = sa.Addr[i]
 	}
 	return uintptr(unsafe.Pointer(&sa.raw)), _Socklen(sa.raw.Len), 0;
 }
@@ -218,12 +218,12 @@ func (sa *SockaddrUnix) sockaddr() (uintptr, _Socklen, int) {
 	name := sa.Name;
 	n := len(name);
 	if n >= len(sa.raw.Path) || n == 0 {
-		return 0, 0, EINVAL;
+		return 0, 0, EINVAL
 	}
 	sa.raw.Len = byte(3+n);	// 2 for Family, Len; 1 for NUL
 	sa.raw.Family = AF_UNIX;
 	for i := 0; i < n; i++ {
-		sa.raw.Path[i] = int8(name[i]);
+		sa.raw.Path[i] = int8(name[i])
 	}
 	return uintptr(unsafe.Pointer(&sa.raw)), _Socklen(sa.raw.Len), 0;
 }
@@ -233,7 +233,7 @@ func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, int) {
 	case AF_UNIX:
 		pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa));
 		if pp.Len < 3 || pp.Len > SizeofSockaddrUnix {
-			return nil, EINVAL;
+			return nil, EINVAL
 		}
 		sa := new(SockaddrUnix);
 		n := int(pp.Len)-3;	// subtract leading Family, Len, terminating NUL
@@ -254,7 +254,7 @@ func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, int) {
 		p := (*[2]byte)(unsafe.Pointer(&pp.Port));
 		sa.Port = int(p[0])<<8 + int(p[1]);
 		for i := 0; i < len(sa.Addr); i++ {
-			sa.Addr[i] = pp.Addr[i];
+			sa.Addr[i] = pp.Addr[i]
 		}
 		return sa, 0;
 
@@ -264,7 +264,7 @@ func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, int) {
 		p := (*[2]byte)(unsafe.Pointer(&pp.Port));
 		sa.Port = int(p[0])<<8 + int(p[1]);
 		for i := 0; i < len(sa.Addr); i++ {
-			sa.Addr[i] = pp.Addr[i];
+			sa.Addr[i] = pp.Addr[i]
 		}
 		return sa, 0;
 	}
@@ -276,7 +276,7 @@ func Accept(fd int) (nfd int, sa Sockaddr, errno int) {
 	var len _Socklen = SizeofSockaddrAny;
 	nfd, errno = accept(fd, &rsa, &len);
 	if errno != 0 {
-		return;
+		return
 	}
 	sa, errno = anyToSockaddr(&rsa);
 	if errno != 0 {
@@ -290,7 +290,7 @@ func Getsockname(fd int) (sa Sockaddr, errno int) {
 	var rsa RawSockaddrAny;
 	var len _Socklen = SizeofSockaddrAny;
 	if errno = getsockname(fd, &rsa, &len); errno != 0 {
-		return;
+		return
 	}
 	return anyToSockaddr(&rsa);
 }
@@ -299,7 +299,7 @@ func Getpeername(fd int) (sa Sockaddr, errno int) {
 	var rsa RawSockaddrAny;
 	var len _Socklen = SizeofSockaddrAny;
 	if errno = getpeername(fd, &rsa, &len); errno != 0 {
-		return;
+		return
 	}
 	return anyToSockaddr(&rsa);
 }
@@ -307,7 +307,7 @@ func Getpeername(fd int) (sa Sockaddr, errno int) {
 func Bind(fd int, sa Sockaddr) (errno int) {
 	ptr, n, err := sa.sockaddr();
 	if err != 0 {
-		return err;
+		return err
 	}
 	return bind(fd, ptr, n);
 }
@@ -315,14 +315,14 @@ func Bind(fd int, sa Sockaddr) (errno int) {
 func Connect(fd int, sa Sockaddr) (errno int) {
 	ptr, n, err := sa.sockaddr();
 	if err != 0 {
-		return err;
+		return err
 	}
 	return connect(fd, ptr, n);
 }
 
 func Socket(domain, typ, proto int) (fd, errno int) {
 	if domain == AF_INET6 && SocketDisableIPv6 {
-		return -1, EAFNOSUPPORT;
+		return -1, EAFNOSUPPORT
 	}
 	fd, errno = socket(domain, typ, proto);
 	return;
@@ -334,11 +334,11 @@ func SetsockoptInt(fd, level, opt int, value int) (errno int) {
 }
 
 func SetsockoptTimeval(fd, level, opt int, tv *Timeval) (errno int) {
-	return setsockopt(fd, level, opt, uintptr(unsafe.Pointer(tv)), unsafe.Sizeof(*tv));
+	return setsockopt(fd, level, opt, uintptr(unsafe.Pointer(tv)), unsafe.Sizeof(*tv))
 }
 
 func SetsockoptLinger(fd, level, opt int, l *Linger) (errno int) {
-	return setsockopt(fd, level, opt, uintptr(unsafe.Pointer(l)), unsafe.Sizeof(*l));
+	return setsockopt(fd, level, opt, uintptr(unsafe.Pointer(l)), unsafe.Sizeof(*l))
 }
 
 
@@ -348,7 +348,7 @@ func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, errno int) {
 	var rsa RawSockaddrAny;
 	var len _Socklen = SizeofSockaddrAny;
 	if n, errno = recvfrom(fd, p, flags, &rsa, &len); errno != 0 {
-		return;
+		return
 	}
 	from, errno = anyToSockaddr(&rsa);
 	return;
@@ -359,7 +359,7 @@ func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, errno int) {
 func Sendto(fd int, p []byte, flags int, to Sockaddr) (errno int) {
 	ptr, n, err := to.sockaddr();
 	if err != 0 {
-		return err;
+		return err
 	}
 	return sendto(fd, p, flags, ptr, n);
 }
@@ -369,10 +369,10 @@ func Sendto(fd int, p []byte, flags int, to Sockaddr) (errno int) {
 func Kevent(kq int, changes, events []Kevent_t, timeout *Timespec) (n int, errno int) {
 	var change, event uintptr;
 	if len(changes) > 0 {
-		change = uintptr(unsafe.Pointer(&changes[0]));
+		change = uintptr(unsafe.Pointer(&changes[0]))
 	}
 	if len(events) > 0 {
-		event = uintptr(unsafe.Pointer(&events[0]));
+		event = uintptr(unsafe.Pointer(&events[0]))
 	}
 	return kevent(kq, change, len(changes), event, len(events), timeout);
 }
@@ -400,7 +400,7 @@ func nametomib(name string) (mib []_C_int, errno int) {
 	// Magic sysctl: "setting" 0.3 to a string name
 	// lets you read back the array of integers form.
 	if errno = sysctl([]_C_int{0, 3}, p, &n, &bytes[0], uintptr(len(name))); errno != 0 {
-		return nil, errno;
+		return nil, errno
 	}
 	return buf[0 : n/siz], 0;
 }
@@ -409,27 +409,27 @@ func Sysctl(name string) (value string, errno int) {
 	// Translate name to mib number.
 	mib, errno := nametomib(name);
 	if errno != 0 {
-		return "", errno;
+		return "", errno
 	}
 
 	// Find size.
 	n := uintptr(0);
 	if errno = sysctl(mib, nil, &n, nil, 0); errno != 0 {
-		return "", errno;
+		return "", errno
 	}
 	if n == 0 {
-		return "", 0;
+		return "", 0
 	}
 
 	// Read into buffer of that size.
 	buf := make([]byte, n);
 	if errno = sysctl(mib, &buf[0], &n, nil, 0); errno != 0 {
-		return "", errno;
+		return "", errno
 	}
 
 	// Throw away terminating NUL.
 	if n > 0 && buf[n-1] == '\x00' {
-		n--;
+		n--
 	}
 	return string(buf[0:n]), 0;
 }
@@ -438,17 +438,17 @@ func SysctlUint32(name string) (value uint32, errno int) {
 	// Translate name to mib number.
 	mib, errno := nametomib(name);
 	if errno != 0 {
-		return 0, errno;
+		return 0, errno
 	}
 
 	// Read into buffer of that size.
 	n := uintptr(4);
 	buf := make([]byte, 4);
 	if errno = sysctl(mib, &buf[0], &n, nil, 0); errno != 0 {
-		return 0, errno;
+		return 0, errno
 	}
 	if n != 4 {
-		return 0, EIO;
+		return 0, EIO
 	}
 	return *(*uint32)(unsafe.Pointer(&buf[0])), 0;
 }
diff --git a/src/pkg/syscall/syscall_linux.go b/src/pkg/syscall/syscall_linux.go
index e4b82569e1..165d56d35a 100644
--- a/src/pkg/syscall/syscall_linux.go
+++ b/src/pkg/syscall/syscall_linux.go
@@ -22,7 +22,7 @@ const OS = "linux"
 //sys	pipe(p *[2]_C_int) (errno int)
 func Pipe(p []int) (errno int) {
 	if len(p) != 2 {
-		return EINVAL;
+		return EINVAL
 	}
 	var pp [2]_C_int;
 	errno = pipe(&pp);
@@ -34,7 +34,7 @@ func Pipe(p []int) (errno int) {
 //sys	utimes(path string, times *[2]Timeval) (errno int)
 func Utimes(path string, tv []Timeval) (errno int) {
 	if len(tv) != 2 {
-		return EINVAL;
+		return EINVAL
 	}
 	return utimes(path, (*[2]Timeval)(unsafe.Pointer(&tv[0])));
 }
@@ -42,7 +42,7 @@ func Utimes(path string, tv []Timeval) (errno int) {
 //sys	futimesat(dirfd int, path string, times *[2]Timeval) (errno int)
 func Futimesat(dirfd int, path string, tv []Timeval) (errno int) {
 	if len(tv) != 2 {
-		return EINVAL;
+		return EINVAL
 	}
 	return futimesat(dirfd, path, (*[2]Timeval)(unsafe.Pointer(&tv[0])));
 }
@@ -54,11 +54,11 @@ func Getwd() (wd string, errno int) {
 	var buf [PathMax]byte;
 	n, err := Getcwd(&buf);
 	if err != 0 {
-		return "", err;
+		return "", err
 	}
 	// Getcwd returns the number of bytes written to buf, including the NUL.
 	if n < 1 || n > len(buf) || buf[n-1] != 0 {
-		return "", EINVAL;
+		return "", EINVAL
 	}
 	return string(buf[0 : n-1]), 0;
 }
@@ -66,37 +66,37 @@ func Getwd() (wd string, errno int) {
 func Getgroups() (gids []int, errno int) {
 	n, err := getgroups(0, nil);
 	if err != 0 {
-		return nil, errno;
+		return nil, errno
 	}
 	if n == 0 {
-		return nil, 0;
+		return nil, 0
 	}
 
 	// Sanity check group count.  Max is 1<<16 on Linux.
 	if n < 0 || n > 1<<20 {
-		return nil, EINVAL;
+		return nil, EINVAL
 	}
 
 	a := make([]_Gid_t, n);
 	n, err = getgroups(n, &a[0]);
 	if err != 0 {
-		return nil, errno;
+		return nil, errno
 	}
 	gids = make([]int, n);
 	for i, v := range a[0:n] {
-		gids[i] = int(v);
+		gids[i] = int(v)
 	}
 	return;
 }
 
 func Setgroups(gids []int) (errno int) {
 	if len(gids) == 0 {
-		return setgroups(0, nil);
+		return setgroups(0, nil)
 	}
 
 	a := make([]_Gid_t, len(gids));
 	for i, v := range gids {
-		a[i] = _Gid_t(v);
+		a[i] = _Gid_t(v)
 	}
 	return setgroups(len(a), &a[0]);
 }
@@ -132,28 +132,28 @@ func (w WaitStatus) CoreDump() bool	{ return w.Signaled() && w&core != 0 }
 
 func (w WaitStatus) ExitStatus() int {
 	if !w.Exited() {
-		return -1;
+		return -1
 	}
 	return int(w>>shift)&0xFF;
 }
 
 func (w WaitStatus) Signal() int {
 	if !w.Signaled() {
-		return -1;
+		return -1
 	}
 	return int(w&mask);
 }
 
 func (w WaitStatus) StopSignal() int {
 	if !w.Stopped() {
-		return -1;
+		return -1
 	}
 	return int(w>>shift)&0xFF;
 }
 
 func (w WaitStatus) TrapCause() int {
 	if w.StopSignal() != SIGTRAP {
-		return -1;
+		return -1
 	}
 	return int(w>>shift)>>8;
 }
@@ -163,7 +163,7 @@ func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int,
 	var status _C_int;
 	wpid, errno = wait4(pid, &status, options, rusage);
 	if wstatus != nil {
-		*wstatus = WaitStatus(status);
+		*wstatus = WaitStatus(status)
 	}
 	return;
 }
@@ -190,14 +190,14 @@ type SockaddrInet4 struct {
 
 func (sa *SockaddrInet4) sockaddr() (uintptr, _Socklen, int) {
 	if sa.Port < 0 || sa.Port > 0xFFFF {
-		return 0, 0, EINVAL;
+		return 0, 0, EINVAL
 	}
 	sa.raw.Family = AF_INET;
 	p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port));
 	p[0] = byte(sa.Port >> 8);
 	p[1] = byte(sa.Port);
 	for i := 0; i < len(sa.Addr); i++ {
-		sa.raw.Addr[i] = sa.Addr[i];
+		sa.raw.Addr[i] = sa.Addr[i]
 	}
 	return uintptr(unsafe.Pointer(&sa.raw)), SizeofSockaddrInet4, 0;
 }
@@ -210,14 +210,14 @@ type SockaddrInet6 struct {
 
 func (sa *SockaddrInet6) sockaddr() (uintptr, _Socklen, int) {
 	if sa.Port < 0 || sa.Port > 0xFFFF {
-		return 0, 0, EINVAL;
+		return 0, 0, EINVAL
 	}
 	sa.raw.Family = AF_INET6;
 	p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port));
 	p[0] = byte(sa.Port >> 8);
 	p[1] = byte(sa.Port);
 	for i := 0; i < len(sa.Addr); i++ {
-		sa.raw.Addr[i] = sa.Addr[i];
+		sa.raw.Addr[i] = sa.Addr[i]
 	}
 	return uintptr(unsafe.Pointer(&sa.raw)), SizeofSockaddrInet6, 0;
 }
@@ -231,14 +231,14 @@ func (sa *SockaddrUnix) sockaddr() (uintptr, _Socklen, int) {
 	name := sa.Name;
 	n := len(name);
 	if n >= len(sa.raw.Path) || n == 0 {
-		return 0, 0, EINVAL;
+		return 0, 0, EINVAL
 	}
 	sa.raw.Family = AF_UNIX;
 	for i := 0; i < n; i++ {
-		sa.raw.Path[i] = int8(name[i]);
+		sa.raw.Path[i] = int8(name[i])
 	}
 	if sa.raw.Path[0] == '@' {
-		sa.raw.Path[0] = 0;
+		sa.raw.Path[0] = 0
 	}
 
 	// length is family, name, NUL.
@@ -256,7 +256,7 @@ func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, int) {
 			// (This is the standard convention.)
 			// Not friendly to overwrite in place,
 			// but the callers below don't care.
-			pp.Path[0] = '@';
+			pp.Path[0] = '@'
 		}
 
 		// Assume path ends at NUL.
@@ -266,7 +266,7 @@ func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, int) {
 		// everyone uses this convention.
 		n := 0;
 		for n < len(pp.Path) && pp.Path[n] != 0 {
-			n++;
+			n++
 		}
 		bytes := (*[len(pp.Path)]byte)(unsafe.Pointer(&pp.Path[0]));
 		sa.Name = string(bytes[0:n]);
@@ -278,7 +278,7 @@ func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, int) {
 		p := (*[2]byte)(unsafe.Pointer(&pp.Port));
 		sa.Port = int(p[0])<<8 + int(p[1]);
 		for i := 0; i < len(sa.Addr); i++ {
-			sa.Addr[i] = pp.Addr[i];
+			sa.Addr[i] = pp.Addr[i]
 		}
 		return sa, 0;
 
@@ -288,7 +288,7 @@ func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, int) {
 		p := (*[2]byte)(unsafe.Pointer(&pp.Port));
 		sa.Port = int(p[0])<<8 + int(p[1]);
 		for i := 0; i < len(sa.Addr); i++ {
-			sa.Addr[i] = pp.Addr[i];
+			sa.Addr[i] = pp.Addr[i]
 		}
 		return sa, 0;
 	}
@@ -300,7 +300,7 @@ func Accept(fd int) (nfd int, sa Sockaddr, errno int) {
 	var len _Socklen = SizeofSockaddrAny;
 	nfd, errno = accept(fd, &rsa, &len);
 	if errno != 0 {
-		return;
+		return
 	}
 	sa, errno = anyToSockaddr(&rsa);
 	if errno != 0 {
@@ -314,7 +314,7 @@ func Getsockname(fd int) (sa Sockaddr, errno int) {
 	var rsa RawSockaddrAny;
 	var len _Socklen = SizeofSockaddrAny;
 	if errno = getsockname(fd, &rsa, &len); errno != 0 {
-		return;
+		return
 	}
 	return anyToSockaddr(&rsa);
 }
@@ -323,7 +323,7 @@ func Getpeername(fd int) (sa Sockaddr, errno int) {
 	var rsa RawSockaddrAny;
 	var len _Socklen = SizeofSockaddrAny;
 	if errno = getpeername(fd, &rsa, &len); errno != 0 {
-		return;
+		return
 	}
 	return anyToSockaddr(&rsa);
 }
@@ -331,7 +331,7 @@ func Getpeername(fd int) (sa Sockaddr, errno int) {
 func Bind(fd int, sa Sockaddr) (errno int) {
 	ptr, n, err := sa.sockaddr();
 	if err != 0 {
-		return err;
+		return err
 	}
 	return bind(fd, ptr, n);
 }
@@ -339,14 +339,14 @@ func Bind(fd int, sa Sockaddr) (errno int) {
 func Connect(fd int, sa Sockaddr) (errno int) {
 	ptr, n, err := sa.sockaddr();
 	if err != 0 {
-		return err;
+		return err
 	}
 	return connect(fd, ptr, n);
 }
 
 func Socket(domain, typ, proto int) (fd, errno int) {
 	if domain == AF_INET6 && SocketDisableIPv6 {
-		return -1, EAFNOSUPPORT;
+		return -1, EAFNOSUPPORT
 	}
 	fd, errno = socket(domain, typ, proto);
 	return;
@@ -358,18 +358,18 @@ func SetsockoptInt(fd, level, opt int, value int) (errno int) {
 }
 
 func SetsockoptTimeval(fd, level, opt int, tv *Timeval) (errno int) {
-	return setsockopt(fd, level, opt, uintptr(unsafe.Pointer(tv)), unsafe.Sizeof(*tv));
+	return setsockopt(fd, level, opt, uintptr(unsafe.Pointer(tv)), unsafe.Sizeof(*tv))
 }
 
 func SetsockoptLinger(fd, level, opt int, l *Linger) (errno int) {
-	return setsockopt(fd, level, opt, uintptr(unsafe.Pointer(l)), unsafe.Sizeof(*l));
+	return setsockopt(fd, level, opt, uintptr(unsafe.Pointer(l)), unsafe.Sizeof(*l))
 }
 
 func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, errno int) {
 	var rsa RawSockaddrAny;
 	var len _Socklen = SizeofSockaddrAny;
 	if n, errno = recvfrom(fd, p, flags, &rsa, &len); errno != 0 {
-		return;
+		return
 	}
 	from, errno = anyToSockaddr(&rsa);
 	return;
@@ -378,7 +378,7 @@ func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, errno int) {
 func Sendto(fd int, p []byte, flags int, to Sockaddr) (errno int) {
 	ptr, n, err := to.sockaddr();
 	if err != 0 {
-		return err;
+		return err
 	}
 	return sendto(fd, p, flags, ptr, n);
 }
@@ -388,10 +388,10 @@ func Sendto(fd int, p []byte, flags int, to Sockaddr) (errno int) {
 // See bytes.Copy.
 func bytesCopy(dst, src []byte) int {
 	if len(src) > len(dst) {
-		src = src[0:len(dst)];
+		src = src[0:len(dst)]
 	}
 	for i, x := range src {
-		dst[i] = x;
+		dst[i] = x
 	}
 	return len(src);
 }
@@ -414,7 +414,7 @@ func ptracePeek(req int, pid int, addr uintptr, out []byte) (count int, errno in
 	if addr % sizeofPtr != 0 {
 		errno = ptrace(req, pid, addr - addr % sizeofPtr, uintptr(unsafe.Pointer(&buf[0])));
 		if errno != 0 {
-			return 0, errno;
+			return 0, errno
 		}
 		n += bytesCopy(out, buf[addr % sizeofPtr : len(buf)]);
 		out = out[n:len(out)];
@@ -426,7 +426,7 @@ func ptracePeek(req int, pid int, addr uintptr, out []byte) (count int, errno in
 		// It's not documented if this is necessary, but we're paranoid.
 		errno = ptrace(req, pid, addr+uintptr(n), uintptr(unsafe.Pointer(&buf[0])));
 		if errno != 0 {
-			return n, errno;
+			return n, errno
 		}
 		copied := bytesCopy(out, &buf);
 		n += copied;
@@ -437,11 +437,11 @@ func ptracePeek(req int, pid int, addr uintptr, out []byte) (count int, errno in
 }
 
 func PtracePeekText(pid int, addr uintptr, out []byte) (count int, errno int) {
-	return ptracePeek(PTRACE_PEEKTEXT, pid, addr, out);
+	return ptracePeek(PTRACE_PEEKTEXT, pid, addr, out)
 }
 
 func PtracePeekData(pid int, addr uintptr, out []byte) (count int, errno int) {
-	return ptracePeek(PTRACE_PEEKDATA, pid, addr, out);
+	return ptracePeek(PTRACE_PEEKDATA, pid, addr, out)
 }
 
 func ptracePoke(pokeReq int, peekReq int, pid int, addr uintptr, data []byte) (count int, errno int) {
@@ -454,13 +454,13 @@ func ptracePoke(pokeReq int, peekReq int, pid int, addr uintptr, data []byte) (c
 		var buf [sizeofPtr]byte;
 		errno = ptrace(peekReq, pid, addr - addr % sizeofPtr, uintptr(unsafe.Pointer(&buf[0])));
 		if errno != 0 {
-			return 0, errno;
+			return 0, errno
 		}
 		n += bytesCopy(buf[addr % sizeofPtr : len(buf)], data);
 		word := *((*uintptr)(unsafe.Pointer(&buf[0])));
 		errno = ptrace(pokeReq, pid, addr - addr % sizeofPtr, word);
 		if errno != 0 {
-			return 0, errno;
+			return 0, errno
 		}
 		data = data[n:len(data)];
 	}
@@ -470,7 +470,7 @@ func ptracePoke(pokeReq int, peekReq int, pid int, addr uintptr, data []byte) (c
 		word := *((*uintptr)(unsafe.Pointer(&data[0])));
 		errno = ptrace(pokeReq, pid, addr+uintptr(n), word);
 		if errno != 0 {
-			return n, errno;
+			return n, errno
 		}
 		n += sizeofPtr;
 		data = data[sizeofPtr : len(data)];
@@ -481,13 +481,13 @@ func ptracePoke(pokeReq int, peekReq int, pid int, addr uintptr, data []byte) (c
 		var buf [sizeofPtr]byte;
 		errno = ptrace(peekReq, pid, addr+uintptr(n), uintptr(unsafe.Pointer(&buf[0])));
 		if errno != 0 {
-			return n, errno;
+			return n, errno
 		}
 		bytesCopy(&buf, data);
 		word := *((*uintptr)(unsafe.Pointer(&buf[0])));
 		errno = ptrace(pokeReq, pid, addr+uintptr(n), word);
 		if errno != 0 {
-			return n, errno;
+			return n, errno
 		}
 		n += len(data);
 	}
@@ -496,23 +496,23 @@ func ptracePoke(pokeReq int, peekReq int, pid int, addr uintptr, data []byte) (c
 }
 
 func PtracePokeText(pid int, addr uintptr, data []byte) (count int, errno int) {
-	return ptracePoke(PTRACE_POKETEXT, PTRACE_PEEKTEXT, pid, addr, data);
+	return ptracePoke(PTRACE_POKETEXT, PTRACE_PEEKTEXT, pid, addr, data)
 }
 
 func PtracePokeData(pid int, addr uintptr, data []byte) (count int, errno int) {
-	return ptracePoke(PTRACE_POKEDATA, PTRACE_PEEKDATA, pid, addr, data);
+	return ptracePoke(PTRACE_POKEDATA, PTRACE_PEEKDATA, pid, addr, data)
 }
 
 func PtraceGetRegs(pid int, regsout *PtraceRegs) (errno int) {
-	return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)));
+	return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))
 }
 
 func PtraceSetRegs(pid int, regs *PtraceRegs) (errno int) {
-	return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)));
+	return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))
 }
 
 func PtraceSetOptions(pid int, options int) (errno int) {
-	return ptrace(PTRACE_SETOPTIONS, pid, 0, uintptr(options));
+	return ptrace(PTRACE_SETOPTIONS, pid, 0, uintptr(options))
 }
 
 func PtraceGetEventMsg(pid int) (msg uint, errno int) {
@@ -523,7 +523,7 @@ func PtraceGetEventMsg(pid int) (msg uint, errno int) {
 }
 
 func PtraceCont(pid int, signal int) (errno int) {
-	return ptrace(PTRACE_CONT, pid, 0, uintptr(signal));
+	return ptrace(PTRACE_CONT, pid, 0, uintptr(signal))
 }
 
 func PtraceSingleStep(pid int) (errno int)	{ return ptrace(PTRACE_SINGLESTEP, pid, 0, 0) }
diff --git a/src/pkg/syscall/syscall_linux_386.go b/src/pkg/syscall/syscall_linux_386.go
index 9632a889ef..f18309d871 100644
--- a/src/pkg/syscall/syscall_linux_386.go
+++ b/src/pkg/syscall/syscall_linux_386.go
@@ -125,7 +125,7 @@ func setsockopt(s int, level int, name int, val uintptr, vallen int) (errno int)
 func recvfrom(s int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, errno int) {
 	var base uintptr;
 	if len(p) > 0 {
-		base = uintptr(unsafe.Pointer(&p));
+		base = uintptr(unsafe.Pointer(&p))
 	}
 	n, errno = socketcall(_RECVFROM, uintptr(s), base, uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)));
 	return;
@@ -134,7 +134,7 @@ func recvfrom(s int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Sockle
 func sendto(s int, p []byte, flags int, to uintptr, addrlen _Socklen) (errno int) {
 	var base uintptr;
 	if len(p) > 0 {
-		base = uintptr(unsafe.Pointer(&p));
+		base = uintptr(unsafe.Pointer(&p))
 	}
 	_, errno = socketcall(_SENDTO, uintptr(s), base, uintptr(len(p)), uintptr(flags), to, uintptr(addrlen));
 	return;
diff --git a/src/pkg/syscall/syscall_nacl.go b/src/pkg/syscall/syscall_nacl.go
index 9b3266809c..0a73939a2d 100644
--- a/src/pkg/syscall/syscall_nacl.go
+++ b/src/pkg/syscall/syscall_nacl.go
@@ -52,7 +52,7 @@ const OS = "nacl"
 func Seek(fd int, offset int64, whence int) (newoffset int64, errno int) {
 	// Offset passed to system call is 32 bits.  Failure of vision by NaCl.
 	if int64(int32(offset)) != offset {
-		return 0, ERANGE;
+		return 0, ERANGE
 	}
 	o, _, e := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence));
 	return int64(o), int(e);
@@ -71,7 +71,7 @@ func Sleep(ns int64) (errno int) {
 	ts := NsecToTimespec(ns);
 	var tv Timeval;
 	if errno = Gettimeofday(&tv); errno != 0 {
-		return;
+		return
 	}
 	ts.Sec += tv.Sec;
 	ts.Nsec += tv.Usec * 1000;
@@ -84,11 +84,11 @@ func Sleep(ns int64) (errno int) {
 		ts.Sec--;
 	}
 	if errno = MutexLock(tmu); errno != 0 {
-		return;
+		return
 	}
 	errno = CondTimedWaitAbs(tcv, tmu, &ts);
 	if e := MutexUnlock(tmu); e != 0 && errno == 0 {
-		errno = e;
+		errno = e
 	}
 	return;
 }
@@ -117,21 +117,21 @@ const (
 func Pipe(p []int) (errno int)	{ return ENACL }
 
 func fcntl(fd, cmd, arg int) (val int, errno int) {
-	return 0, ENACL;
+	return 0, ENACL
 }
 
 func Pread(fd int, p []byte, offset int64) (n int, errno int) {
-	return 0, ENACL;
+	return 0, ENACL
 }
 
 func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
-	return 0, ENACL;
+	return 0, ENACL
 }
 
 func Mkdir(path string, mode int) (errno int)	{ return ENACL }
 
 func Lstat(path string, stat *Stat_t) (errno int) {
-	return ENACL;
+	return ENACL
 }
 
 func Chdir(path string) (errno int)	{ return ENACL }
@@ -143,35 +143,35 @@ func Unlink(path string) (errno int)	{ return ENACL }
 func Rmdir(path string) (errno int)	{ return ENACL }
 
 func Link(oldpath, newpath string) (errno int) {
-	return ENACL;
+	return ENACL
 }
 
 func Symlink(path, link string) (errno int)	{ return ENACL }
 
 func Readlink(path string, buf []byte) (n int, errno int) {
-	return 0, ENACL;
+	return 0, ENACL
 }
 
 func Fchmod(fd int, mode int) (errno int)	{ return ENACL }
 
 func Chown(path string, uid int, gid int) (errno int) {
-	return ENACL;
+	return ENACL
 }
 
 func Lchown(path string, uid int, gid int) (errno int) {
-	return ENACL;
+	return ENACL
 }
 
 func Fchown(fd int, uid int, gid int) (errno int) {
-	return ENACL;
+	return ENACL
 }
 
 func Truncate(name string, size int64) (errno int) {
-	return ENACL;
+	return ENACL
 }
 
 func Ftruncate(fd int, length int64) (errno int) {
-	return ENACL;
+	return ENACL
 }
 
 // NaCL doesn't actually implement Getwd, but it also
@@ -240,15 +240,15 @@ const (
 )
 
 func Accept(fd int) (nfd int, sa Sockaddr, errno int) {
-	return 0, nil, ENACL;
+	return 0, nil, ENACL
 }
 
 func Getsockname(fd int) (sa Sockaddr, errno int) {
-	return nil, ENACL;
+	return nil, ENACL
 }
 
 func Getpeername(fd int) (sa Sockaddr, errno int) {
-	return nil, ENACL;
+	return nil, ENACL
 }
 
 func Bind(fd int, sa Sockaddr) (errno int)	{ return ENACL }
@@ -256,15 +256,15 @@ func Bind(fd int, sa Sockaddr) (errno int)	{ return ENACL }
 func Connect(fd int, sa Sockaddr) (errno int)	{ return ENACL }
 
 func Socket(domain, typ, proto int) (fd, errno int) {
-	return 0, ENACL;
+	return 0, ENACL
 }
 
 func SetsockoptInt(fd, level, opt int, value int) (errno int) {
-	return ENACL;
+	return ENACL
 }
 
 func SetsockoptTimeval(fd, level, opt int, tv *Timeval) (errno int) {
-	return ENACL;
+	return ENACL
 }
 
 type Linger struct {
@@ -273,7 +273,7 @@ type Linger struct {
 }
 
 func SetsockoptLinger(fd, level, opt int, l *Linger) (errno int) {
-	return ENACL;
+	return ENACL
 }
 
 func Listen(s int, n int) (errno int)	{ return ENACL }
@@ -298,7 +298,7 @@ type Rusage struct {
 }
 
 func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, errno int) {
-	return 0, ENACL;
+	return 0, ENACL
 }
 
 type WaitStatus uint32
diff --git a/src/pkg/syscall/zsyscall_darwin_386.go b/src/pkg/syscall/zsyscall_darwin_386.go
index ea9ce955f5..20a0e43597 100644
--- a/src/pkg/syscall/zsyscall_darwin_386.go
+++ b/src/pkg/syscall/zsyscall_darwin_386.go
@@ -80,7 +80,7 @@ func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
 func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)));
 	n = int(r0);
@@ -91,7 +91,7 @@ func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Sockl
 func sendto(s int, buf []byte, flags int, to uintptr, addrlen _Socklen) (errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen));
 	errno = int(e1);
@@ -108,7 +108,7 @@ func kevent(kq int, change uintptr, nchange int, event uintptr, nevent int, time
 func sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (errno int) {
 	var _p0 *_C_int;
 	if len(mib) > 0 {
-		_p0 = &mib[0];
+		_p0 = &mib[0]
 	}
 	_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(unsafe.Pointer(_p0)), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen));
 	errno = int(e1);
@@ -258,7 +258,7 @@ func Ftruncate(fd int, length int64) (errno int) {
 func Getdirentries(fd int, buf []byte, basep *uintptr) (n int, errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall6(SYS_GETDIRENTRIES64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0);
 	n = int(r0);
@@ -287,7 +287,7 @@ func Geteuid() (uid int) {
 func Getfsstat(buf []Statfs_t, flags int) (n int, errno int) {
 	var _p0 *Statfs_t;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall(SYS_GETFSSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags));
 	n = int(r0);
@@ -436,7 +436,7 @@ func Pathconf(path string, name int) (val int, errno int) {
 func Pread(fd int, p []byte, offset int64) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0);
 	n = int(r0);
@@ -447,7 +447,7 @@ func Pread(fd int, p []byte, offset int64) (n int, errno int) {
 func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0);
 	n = int(r0);
@@ -458,7 +458,7 @@ func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
 func Read(fd int, p []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
 	n = int(r0);
@@ -469,7 +469,7 @@ func Read(fd int, p []byte) (n int, errno int) {
 func Readlink(path string, buf []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
 	n = int(r0);
@@ -643,7 +643,7 @@ func Unmount(path string, flags int) (errno int) {
 func Write(fd int, p []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
 	n = int(r0);
diff --git a/src/pkg/syscall/zsyscall_darwin_amd64.go b/src/pkg/syscall/zsyscall_darwin_amd64.go
index eb637aa21a..f08a4b8272 100644
--- a/src/pkg/syscall/zsyscall_darwin_amd64.go
+++ b/src/pkg/syscall/zsyscall_darwin_amd64.go
@@ -80,7 +80,7 @@ func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
 func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)));
 	n = int(r0);
@@ -91,7 +91,7 @@ func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Sockl
 func sendto(s int, buf []byte, flags int, to uintptr, addrlen _Socklen) (errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen));
 	errno = int(e1);
@@ -108,7 +108,7 @@ func kevent(kq int, change uintptr, nchange int, event uintptr, nevent int, time
 func sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (errno int) {
 	var _p0 *_C_int;
 	if len(mib) > 0 {
-		_p0 = &mib[0];
+		_p0 = &mib[0]
 	}
 	_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(unsafe.Pointer(_p0)), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen));
 	errno = int(e1);
@@ -258,7 +258,7 @@ func Ftruncate(fd int, length int64) (errno int) {
 func Getdirentries(fd int, buf []byte, basep *uintptr) (n int, errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall6(SYS_GETDIRENTRIES64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0);
 	n = int(r0);
@@ -287,7 +287,7 @@ func Geteuid() (uid int) {
 func Getfsstat(buf []Statfs_t, flags int) (n int, errno int) {
 	var _p0 *Statfs_t;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall(SYS_GETFSSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags));
 	n = int(r0);
@@ -436,7 +436,7 @@ func Pathconf(path string, name int) (val int, errno int) {
 func Pread(fd int, p []byte, offset int64) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0);
 	n = int(r0);
@@ -447,7 +447,7 @@ func Pread(fd int, p []byte, offset int64) (n int, errno int) {
 func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0);
 	n = int(r0);
@@ -458,7 +458,7 @@ func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
 func Read(fd int, p []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
 	n = int(r0);
@@ -469,7 +469,7 @@ func Read(fd int, p []byte) (n int, errno int) {
 func Readlink(path string, buf []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
 	n = int(r0);
@@ -644,7 +644,7 @@ func Unmount(path string, flags int) (errno int) {
 func Write(fd int, p []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
 	n = int(r0);
diff --git a/src/pkg/syscall/zsyscall_linux_386.go b/src/pkg/syscall/zsyscall_linux_386.go
index 13ec70e647..fa5f842de8 100644
--- a/src/pkg/syscall/zsyscall_linux_386.go
+++ b/src/pkg/syscall/zsyscall_linux_386.go
@@ -26,7 +26,7 @@ func futimesat(dirfd int, path string, times *[2]Timeval) (errno int) {
 func Getcwd(buf []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall(SYS_GETCWD, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), 0);
 	n = int(r0);
@@ -127,7 +127,7 @@ func EpollCtl(epfd int, op int, fd int, event *EpollEvent) (errno int) {
 func EpollWait(epfd int, events []EpollEvent, msec int) (n int, errno int) {
 	var _p0 *EpollEvent;
 	if len(events) > 0 {
-		_p0 = &events[0];
+		_p0 = &events[0]
 	}
 	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(unsafe.Pointer(_p0)), uintptr(len(events)), uintptr(msec), 0, 0);
 	n = int(r0);
@@ -204,7 +204,7 @@ func Ftruncate(fd int, length int64) (errno int) {
 func Getdents(fd int, buf []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
 	n = int(r0);
@@ -270,7 +270,7 @@ func Kill(pid int, sig int) (errno int) {
 func Klogctl(typ int, buf []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
 	n = int(r0);
@@ -343,7 +343,7 @@ func PivotRoot(newroot string, putold string) (errno int) {
 func Pread(fd int, p []byte, offset int64) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0);
 	n = int(r0);
@@ -354,7 +354,7 @@ func Pread(fd int, p []byte, offset int64) (n int, errno int) {
 func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0);
 	n = int(r0);
@@ -365,7 +365,7 @@ func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
 func Read(fd int, p []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
 	n = int(r0);
@@ -376,7 +376,7 @@ func Read(fd int, p []byte) (n int, errno int) {
 func Readlink(path string, buf []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
 	n = int(r0);
@@ -405,7 +405,7 @@ func Rmdir(path string) (errno int) {
 func Setdomainname(p []byte) (errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0);
 	errno = int(e1);
@@ -415,7 +415,7 @@ func Setdomainname(p []byte) (errno int) {
 func Sethostname(p []byte) (errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0);
 	errno = int(e1);
@@ -552,7 +552,7 @@ func Utime(path string, buf *Utimbuf) (errno int) {
 func Write(fd int, p []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
 	n = int(r0);
diff --git a/src/pkg/syscall/zsyscall_linux_amd64.go b/src/pkg/syscall/zsyscall_linux_amd64.go
index 0c442fa441..15ccf3bbee 100644
--- a/src/pkg/syscall/zsyscall_linux_amd64.go
+++ b/src/pkg/syscall/zsyscall_linux_amd64.go
@@ -26,7 +26,7 @@ func futimesat(dirfd int, path string, times *[2]Timeval) (errno int) {
 func Getcwd(buf []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall(SYS_GETCWD, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), 0);
 	n = int(r0);
@@ -127,7 +127,7 @@ func EpollCtl(epfd int, op int, fd int, event *EpollEvent) (errno int) {
 func EpollWait(epfd int, events []EpollEvent, msec int) (n int, errno int) {
 	var _p0 *EpollEvent;
 	if len(events) > 0 {
-		_p0 = &events[0];
+		_p0 = &events[0]
 	}
 	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(unsafe.Pointer(_p0)), uintptr(len(events)), uintptr(msec), 0, 0);
 	n = int(r0);
@@ -204,7 +204,7 @@ func Ftruncate(fd int, length int64) (errno int) {
 func Getdents(fd int, buf []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
 	n = int(r0);
@@ -270,7 +270,7 @@ func Kill(pid int, sig int) (errno int) {
 func Klogctl(typ int, buf []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
 	n = int(r0);
@@ -343,7 +343,7 @@ func PivotRoot(newroot string, putold string) (errno int) {
 func Pread(fd int, p []byte, offset int64) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0);
 	n = int(r0);
@@ -354,7 +354,7 @@ func Pread(fd int, p []byte, offset int64) (n int, errno int) {
 func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0);
 	n = int(r0);
@@ -365,7 +365,7 @@ func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
 func Read(fd int, p []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
 	n = int(r0);
@@ -376,7 +376,7 @@ func Read(fd int, p []byte) (n int, errno int) {
 func Readlink(path string, buf []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
 	n = int(r0);
@@ -405,7 +405,7 @@ func Rmdir(path string) (errno int) {
 func Setdomainname(p []byte) (errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0);
 	errno = int(e1);
@@ -415,7 +415,7 @@ func Setdomainname(p []byte) (errno int) {
 func Sethostname(p []byte) (errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0);
 	errno = int(e1);
@@ -554,7 +554,7 @@ func Utime(path string, buf *Utimbuf) (errno int) {
 func Write(fd int, p []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
 	n = int(r0);
@@ -800,7 +800,7 @@ func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
 func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)));
 	n = int(r0);
@@ -811,7 +811,7 @@ func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Sockl
 func sendto(s int, buf []byte, flags int, to uintptr, addrlen _Socklen) (errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen));
 	errno = int(e1);
diff --git a/src/pkg/syscall/zsyscall_linux_arm.go b/src/pkg/syscall/zsyscall_linux_arm.go
index a726cf4cce..f8cd8a70a3 100644
--- a/src/pkg/syscall/zsyscall_linux_arm.go
+++ b/src/pkg/syscall/zsyscall_linux_arm.go
@@ -26,7 +26,7 @@ func futimesat(dirfd int, path string, times *[2]Timeval) (errno int) {
 func Getcwd(buf []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall(SYS_GETCWD, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), 0);
 	n = int(r0);
@@ -127,7 +127,7 @@ func EpollCtl(epfd int, op int, fd int, event *EpollEvent) (errno int) {
 func EpollWait(epfd int, events []EpollEvent, msec int) (n int, errno int) {
 	var _p0 *EpollEvent;
 	if len(events) > 0 {
-		_p0 = &events[0];
+		_p0 = &events[0]
 	}
 	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(unsafe.Pointer(_p0)), uintptr(len(events)), uintptr(msec), 0, 0);
 	n = int(r0);
@@ -204,7 +204,7 @@ func Ftruncate(fd int, length int64) (errno int) {
 func Getdents(fd int, buf []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
 	n = int(r0);
@@ -270,7 +270,7 @@ func Kill(pid int, sig int) (errno int) {
 func Klogctl(typ int, buf []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
 	n = int(r0);
@@ -343,7 +343,7 @@ func PivotRoot(newroot string, putold string) (errno int) {
 func Pread(fd int, p []byte, offset int64) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0);
 	n = int(r0);
@@ -354,7 +354,7 @@ func Pread(fd int, p []byte, offset int64) (n int, errno int) {
 func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0);
 	n = int(r0);
@@ -365,7 +365,7 @@ func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
 func Read(fd int, p []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
 	n = int(r0);
@@ -376,7 +376,7 @@ func Read(fd int, p []byte) (n int, errno int) {
 func Readlink(path string, buf []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
 	n = int(r0);
@@ -405,7 +405,7 @@ func Rmdir(path string) (errno int) {
 func Setdomainname(p []byte) (errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0);
 	errno = int(e1);
@@ -415,7 +415,7 @@ func Setdomainname(p []byte) (errno int) {
 func Sethostname(p []byte) (errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0);
 	errno = int(e1);
@@ -552,7 +552,7 @@ func Utime(path string, buf *Utimbuf) (errno int) {
 func Write(fd int, p []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
 	n = int(r0);
@@ -779,7 +779,7 @@ func Statfs(path string, buf *Statfs_t) (errno int) {
 func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)));
 	n = int(r0);
@@ -790,7 +790,7 @@ func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Sockl
 func sendto(s int, buf []byte, flags int, to uintptr, addrlen _Socklen) (errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen));
 	errno = int(e1);
diff --git a/src/pkg/syscall/zsyscall_nacl_386.go b/src/pkg/syscall/zsyscall_nacl_386.go
index 3fad83e477..7cf331dbac 100644
--- a/src/pkg/syscall/zsyscall_nacl_386.go
+++ b/src/pkg/syscall/zsyscall_nacl_386.go
@@ -37,7 +37,7 @@ func Fstat(fd int, stat *Stat_t) (errno int) {
 func Getdents(fd int, buf []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(buf) > 0 {
-		_p0 = &buf[0];
+		_p0 = &buf[0]
 	}
 	r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
 	n = int(r0);
@@ -67,7 +67,7 @@ func Open(path string, mode int, perm int) (fd int, errno int) {
 func Read(fd int, p []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
 	n = int(r0);
@@ -91,7 +91,7 @@ func Stat(path string, stat *Stat_t) (errno int) {
 func Write(fd int, p []byte) (n int, errno int) {
 	var _p0 *byte;
 	if len(p) > 0 {
-		_p0 = &p[0];
+		_p0 = &p[0]
 	}
 	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
 	n = int(r0);
diff --git a/src/pkg/tabwriter/tabwriter.go b/src/pkg/tabwriter/tabwriter.go
index 0946f2edd5..98edc4a220 100644
--- a/src/pkg/tabwriter/tabwriter.go
+++ b/src/pkg/tabwriter/tabwriter.go
@@ -175,20 +175,20 @@ const (
 //
 func (b *Writer) Init(output io.Writer, cellwidth, padding int, padchar byte, flags uint) *Writer {
 	if cellwidth < 0 {
-		panic("negative cellwidth");
+		panic("negative cellwidth")
 	}
 	if padding < 0 {
-		panic("negative padding");
+		panic("negative padding")
 	}
 	b.output = output;
 	b.cellwidth = cellwidth;
 	b.padding = padding;
 	for i := len(b.padbytes)-1; i >= 0; i-- {
-		b.padbytes[i] = padchar;
+		b.padbytes[i] = padchar
 	}
 	if padchar == '\t' {
 		// tab enforces left-alignment
-		flags &^= AlignRight;
+		flags &^= AlignRight
 	}
 	b.flags = flags;
 
@@ -220,7 +220,7 @@ func (b *Writer) dump() {
 func (b *Writer) write0(buf []byte) os.Error {
 	n, err := b.output.Write(buf);
 	if n != len(buf) && err == nil {
-		err = os.EIO;
+		err = os.EIO
 	}
 	return err;
 }
@@ -230,26 +230,26 @@ var newline = []byte{'\n'}
 
 func (b *Writer) writePadding(textw, cellw int) os.Error {
 	if b.cellwidth == 0 {
-		return nil;
+		return nil
 	}
 
 	if b.padbytes[0] == '\t' {
 		// make cell width a multiple of cellwidth
-		cellw = ((cellw + b.cellwidth - 1) / b.cellwidth) * b.cellwidth;
+		cellw = ((cellw + b.cellwidth - 1) / b.cellwidth) * b.cellwidth
 	}
 
 	n := cellw-textw;
 	if n < 0 {
-		panic("internal error");
+		panic("internal error")
 	}
 
 	if b.padbytes[0] == '\t' {
-		n = (n + b.cellwidth - 1) / b.cellwidth;
+		n = (n + b.cellwidth - 1) / b.cellwidth
 	}
 
 	for n > len(b.padbytes) {
 		if err := b.write0(&b.padbytes); err != nil {
-			return err;
+			return err
 		}
 		n -= len(b.padbytes);
 	}
@@ -269,19 +269,19 @@ func (b *Writer) writeLines(pos0 int, line0, line1 int) (pos int, err os.Error)
 
 			if j > 0 && b.flags & Debug != 0 {
 				if err = b.write0(vbar); err != nil {
-					return;
+					return
 				}
 			}
 			switch {
 			default:	// align left
 
 				if err = b.write0(b.buf.Bytes()[pos : pos + c.size]); err != nil {
-					return;
+					return
 				}
 				pos += c.size;
 				if j < b.widths.Len() {
 					if err = b.writePadding(c.width, b.widths.At(j)); err != nil {
-						return;
+						return
 					}
 				}
 
@@ -289,11 +289,11 @@ func (b *Writer) writeLines(pos0 int, line0, line1 int) (pos int, err os.Error)
 
 				if j < b.widths.Len() {
 					if err = b.writePadding(c.width, b.widths.At(j)); err != nil {
-						return;
+						return
 					}
 				}
 				if err = b.write0(b.buf.Bytes()[pos : pos + c.size]); err != nil {
-					return;
+					return
 				}
 				pos += c.size;
 			}
@@ -303,13 +303,13 @@ func (b *Writer) writeLines(pos0 int, line0, line1 int) (pos int, err os.Error)
 			// last buffered line - we don't have a newline, so just write
 			// any outstanding buffered data
 			if err = b.write0(b.buf.Bytes()[pos : pos + b.cell.size]); err != nil {
-				return;
+				return
 			}
 			pos += b.cell.size;
 		} else {
 			// not the last line - write newline
 			if err = b.write0(newline); err != nil {
-				return;
+				return
 			}
 		}
 	}
@@ -338,7 +338,7 @@ func (b *Writer) format(pos0 int, line0, line1 int) (pos int, err os.Error) {
 
 			// print unprinted lines until beginning of block
 			if pos, err = b.writeLines(pos, line0, this); err != nil {
-				return;
+				return
 			}
 			line0 = this;
 
@@ -352,21 +352,21 @@ func (b *Writer) format(pos0 int, line0, line1 int) (pos int, err os.Error) {
 					c := line.At(column).(cell);
 					// update width
 					if w := c.width + b.padding; w > width {
-						width = w;
+						width = w
 					}
 					// update discardable
 					if c.width > 0 || c.htab {
-						discardable = false;
+						discardable = false
 					}
 				} else {
-					break;
+					break
 				}
 			}
 			// column block end
 
 			// discard empty columns if necessary
 			if discardable && b.flags & DiscardEmptyColumns != 0 {
-				width = 0;
+				width = 0
 			}
 
 			// format and print all columns to the right of this column
@@ -411,11 +411,11 @@ const Escape = '\xff'
 func (b *Writer) startEscape(ch byte) {
 	switch ch {
 	case Escape:
-		b.endChar = Escape;
+		b.endChar = Escape
 	case '<':
-		b.endChar = '>';
+		b.endChar = '>'
 	case '&':
-		b.endChar = ';';
+		b.endChar = ';'
 	}
 }
 
@@ -428,10 +428,10 @@ func (b *Writer) startEscape(ch byte) {
 func (b *Writer) endEscape() {
 	switch b.endChar {
 	case Escape:
-		b.updateWidth();
+		b.updateWidth()
 	case '>':	// tag of zero width
 	case ';':
-		b.cell.width++;	// entity, count as one rune
+		b.cell.width++	// entity, count as one rune
 	}
 	b.pos = b.buf.Len();
 	b.endChar = 0;
@@ -460,7 +460,7 @@ func (b *Writer) Flush() os.Error {
 	if b.cell.size > 0 {
 		if b.endChar != 0 {
 			// inside escape - terminate it even if incomplete
-			b.endEscape();
+			b.endEscape()
 		}
 		b.terminateCell(false);
 	}
@@ -502,7 +502,7 @@ func (b *Writer) Write(buf []byte) (n int, err os.Error) {
 						// line is ignored by format()), thus we can flush the
 						// Writer contents.
 						if err = b.Flush(); err != nil {
-							return;
+							return
 						}
 					}
 				}
@@ -531,7 +531,7 @@ func (b *Writer) Write(buf []byte) (n int, err os.Error) {
 				// end of tag/entity
 				j := i+1;
 				if ch == Escape {
-					j = i;	// exclude Escape
+					j = i	// exclude Escape
 				}
 				b.append(buf[n:j]);
 				n = i+1;	// ch consumed
@@ -551,5 +551,5 @@ func (b *Writer) Write(buf []byte) (n int, err os.Error) {
 // The parameters are the same as for the the Init function.
 //
 func NewWriter(output io.Writer, cellwidth, padding int, padchar byte, flags uint) *Writer {
-	return new(Writer).Init(output, cellwidth, padding, padchar, flags);
+	return new(Writer).Init(output, cellwidth, padding, padchar, flags)
 }
diff --git a/src/pkg/tabwriter/tabwriter_test.go b/src/pkg/tabwriter/tabwriter_test.go
index 1f52eef827..f6e56882ae 100644
--- a/src/pkg/tabwriter/tabwriter_test.go
+++ b/src/pkg/tabwriter/tabwriter_test.go
@@ -28,10 +28,10 @@ func (b *buffer) Write(buf []byte) (written int, err os.Error) {
 	if n+m <= cap(b.a) {
 		b.a = b.a[0 : n+m];
 		for i := 0; i < m; i++ {
-			b.a[n+i] = buf[i];
+			b.a[n+i] = buf[i]
 		}
 	} else {
-		panicln("buffer.Write: buffer too small", n, m, cap(b.a));
+		panicln("buffer.Write: buffer too small", n, m, cap(b.a))
 	}
 	return len(buf), nil;
 }
@@ -43,10 +43,10 @@ func (b *buffer) String() string	{ return string(b.a) }
 func write(t *testing.T, testname string, w *Writer, src string) {
 	written, err := io.WriteString(w, src);
 	if err != nil {
-		t.Errorf("--- test: %s\n--- src:\n%s\n--- write error: %v\n", testname, src, err);
+		t.Errorf("--- test: %s\n--- src:\n%s\n--- write error: %v\n", testname, src, err)
 	}
 	if written != len(src) {
-		t.Errorf("--- test: %s\n--- src:\n%s\n--- written = %d, len(src) = %d\n", testname, src, written, len(src));
+		t.Errorf("--- test: %s\n--- src:\n%s\n--- written = %d, len(src) = %d\n", testname, src, written, len(src))
 	}
 }
 
@@ -54,12 +54,12 @@ func write(t *testing.T, testname string, w *Writer, src string) {
 func verify(t *testing.T, testname string, w *Writer, b *buffer, src, expected string) {
 	err := w.Flush();
 	if err != nil {
-		t.Errorf("--- test: %s\n--- src:\n%s\n--- flush error: %v\n", testname, src, err);
+		t.Errorf("--- test: %s\n--- src:\n%s\n--- flush error: %v\n", testname, src, err)
 	}
 
 	res := b.String();
 	if res != expected {
-		t.Errorf("--- test: %s\n--- src:\n%s\n--- found:\n%s\n--- expected:\n%s\n", testname, src, res, expected);
+		t.Errorf("--- test: %s\n--- src:\n%s\n--- found:\n%s\n--- expected:\n%s\n", testname, src, res, expected)
 	}
 }
 
@@ -79,7 +79,7 @@ func check(t *testing.T, testname string, tabwidth, padding int, padchar byte, f
 	// write byte-by-byte
 	b.clear();
 	for i := 0; i < len(src); i++ {
-		write(t, testname, &w, src[i : i+1]);
+		write(t, testname, &w, src[i : i+1])
 	}
 	verify(t, testname, &w, &b, src, expected);
 
@@ -89,7 +89,7 @@ func check(t *testing.T, testname string, tabwidth, padding int, padchar byte, f
 		write(t, testname, &w, src[i : i+d]);
 		i, d = i+d, d+1;
 		if i+d > len(src) {
-			d = len(src)-i;
+			d = len(src)-i
 		}
 	}
 	verify(t, testname, &w, &b, src, expected);
@@ -591,6 +591,6 @@ var tests = []entry{
 
 func Test(t *testing.T) {
 	for _, e := range tests {
-		check(t, e.testname, e.tabwidth, e.padding, e.padchar, e.flags, e.src, e.expected);
+		check(t, e.testname, e.tabwidth, e.padding, e.padchar, e.flags, e.src, e.expected)
 	}
 }
diff --git a/src/pkg/template/format.go b/src/pkg/template/format.go
index a0468e9d46..bb1ff915bf 100644
--- a/src/pkg/template/format.go
+++ b/src/pkg/template/format.go
@@ -18,7 +18,7 @@ import (
 // You can override the default formatter by storing your default
 // under the name "" in your custom formatter map.
 func StringFormatter(w io.Writer, value interface{}, format string) {
-	fmt.Fprint(w, value);
+	fmt.Fprint(w, value)
 }
 
 var (
@@ -37,17 +37,17 @@ func HTMLEscape(w io.Writer, s []byte) {
 	for i, c := range s {
 		switch c {
 		case '"':
-			esc = esc_quot;
+			esc = esc_quot
 		case '\'':
-			esc = esc_apos;
+			esc = esc_apos
 		case '&':
-			esc = esc_amp;
+			esc = esc_amp
 		case '<':
-			esc = esc_lt;
+			esc = esc_lt
 		case '>':
-			esc = esc_gt;
+			esc = esc_gt
 		default:
-			continue;
+			continue
 		}
 		w.Write(s[last:i]);
 		w.Write(esc);
diff --git a/src/pkg/template/template.go b/src/pkg/template/template.go
index 635323a663..548c706197 100644
--- a/src/pkg/template/template.go
+++ b/src/pkg/template/template.go
@@ -165,7 +165,7 @@ type state struct {
 }
 
 func (parent *state) clone(data reflect.Value) *state {
-	return &state{parent, data, parent.wr, parent.errors};
+	return &state{parent, data, parent.wr, parent.errors}
 }
 
 // New creates a new template with the specified formatter map (which
@@ -188,7 +188,7 @@ func (t *Template) execError(st *state, line int, err string, args ...) {
 // Report error, save in Template to terminate parsing.
 // The line number comes from the template state.
 func (t *Template) parseError(err string, args ...) {
-	t.error = &Error{t.linenum, fmt.Sprintf(err, args)};
+	t.error = &Error{t.linenum, fmt.Sprintf(err, args)}
 }
 
 // -- Lexical analysis
@@ -200,11 +200,11 @@ func white(c uint8) bool	{ return c == ' ' || c == '\t' || c == '\r' || c == '\n
 func equal(s []byte, n int, t []byte) bool {
 	b := s[n:len(s)];
 	if len(t) > len(b) {	// not enough space left for a match.
-		return false;
+		return false
 	}
 	for i, c := range t {
 		if c != b[i] {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -236,17 +236,17 @@ Loop:
 		case !sawLeft && equal(t.buf, i, t.ldelim):	// sawLeft checked because delims may be equal
 			// anything interesting already on the line?
 			if !only_white {
-				break Loop;
+				break Loop
 			}
 			// is it a directive or comment?
 			j := i+len(t.ldelim);	// position after delimiter
 			if j+1 < len(t.buf) && (t.buf[j] == '.' || t.buf[j] == '#') {
 				special = true;
 				if trim_white && only_white {
-					start = i;
+					start = i
 				}
 			} else if i > t.p {	// have some text accumulated so stop before delimiter
-				break Loop;
+				break Loop
 			}
 			sawLeft = true;
 			i = j-1;
@@ -259,7 +259,7 @@ Loop:
 			i += len(t.rdelim);
 			break Loop;
 		default:
-			only_white = false;
+			only_white = false
 		}
 	}
 	if sawLeft {
@@ -295,12 +295,12 @@ func words(buf []byte) []string {
 		for ; p < len(buf) && !white(buf[p]); p++ {
 		}
 		if start == p {	// no text left
-			break;
+			break
 		}
 		if i == cap(s) {
 			ns := make([]string, 2*cap(s));
 			for j := range s {
-				ns[j] = s[j];
+				ns[j] = s[j]
 			}
 			s = ns;
 		}
@@ -398,12 +398,12 @@ func (t *Template) newVariable(name_formatter string) (v *variableElement) {
 	// Is it in user-supplied map?
 	if t.fmap != nil {
 		if _, ok := t.fmap[formatter]; ok {
-			return;
+			return
 		}
 	}
 	// Is it in builtin map?
 	if _, ok := builtins[formatter]; ok {
-		return;
+		return
 	}
 	t.parseError("unknown formatter: %s", formatter);
 	return;
@@ -414,25 +414,25 @@ func (t *Template) newVariable(name_formatter string) (v *variableElement) {
 func (t *Template) parseSimple(item []byte) (done bool, tok int, w []string) {
 	tok, w = t.analyze(item);
 	if t.error != nil {
-		return;
+		return
 	}
 	done = true;	// assume for simplicity
 	switch tok {
 	case tokComment:
-		return;
+		return
 	case tokText:
 		t.elems.Push(&textElement{item});
 		return;
 	case tokLiteral:
 		switch w[0] {
 		case ".meta-left":
-			t.elems.Push(&literalElement{t.ldelim});
+			t.elems.Push(&literalElement{t.ldelim})
 		case ".meta-right":
-			t.elems.Push(&literalElement{t.rdelim});
+			t.elems.Push(&literalElement{t.rdelim})
 		case ".space":
-			t.elems.Push(&literalElement{space});
+			t.elems.Push(&literalElement{space})
 		case ".tab":
-			t.elems.Push(&literalElement{tab});
+			t.elems.Push(&literalElement{tab})
 		default:
 			t.parseError("internal error: unknown literal: %s", w[0]);
 			return;
@@ -461,7 +461,7 @@ Loop:
 	for t.error == nil {
 		item := t.nextItem();
 		if t.error != nil {
-			break;
+			break
 		}
 		if len(item) == 0 {
 			t.parseError("missing .end for .repeated section");
@@ -469,14 +469,14 @@ Loop:
 		}
 		done, tok, w := t.parseSimple(item);
 		if t.error != nil {
-			break;
+			break
 		}
 		if done {
-			continue;
+			continue
 		}
 		switch tok {
 		case tokEnd:
-			break Loop;
+			break Loop
 		case tokOr:
 			if r.or >= 0 {
 				t.parseError("extra .or in .repeated section");
@@ -485,9 +485,9 @@ Loop:
 			r.altend = t.elems.Len();
 			r.or = t.elems.Len();
 		case tokSection:
-			t.parseSection(w);
+			t.parseSection(w)
 		case tokRepeated:
-			t.parseRepeated(w);
+			t.parseRepeated(w)
 		case tokAlternates:
 			if r.altstart >= 0 {
 				t.parseError("extra .alternates in .repeated section");
@@ -504,10 +504,10 @@ Loop:
 		}
 	}
 	if t.error != nil {
-		return nil;
+		return nil
 	}
 	if r.altend < 0 {
-		r.altend = t.elems.Len();
+		r.altend = t.elems.Len()
 	}
 	r.end = t.elems.Len();
 	return r;
@@ -525,7 +525,7 @@ Loop:
 	for t.error == nil {
 		item := t.nextItem();
 		if t.error != nil {
-			break;
+			break
 		}
 		if len(item) == 0 {
 			t.parseError("missing .end for .section");
@@ -533,14 +533,14 @@ Loop:
 		}
 		done, tok, w := t.parseSimple(item);
 		if t.error != nil {
-			break;
+			break
 		}
 		if done {
-			continue;
+			continue
 		}
 		switch tok {
 		case tokEnd:
-			break Loop;
+			break Loop
 		case tokOr:
 			if s.or >= 0 {
 				t.parseError("extra .or in .section");
@@ -548,17 +548,17 @@ Loop:
 			}
 			s.or = t.elems.Len();
 		case tokSection:
-			t.parseSection(w);
+			t.parseSection(w)
 		case tokRepeated:
-			t.parseRepeated(w);
+			t.parseRepeated(w)
 		case tokAlternates:
-			t.parseError(".alternates not in .repeated");
+			t.parseError(".alternates not in .repeated")
 		default:
-			t.parseError("internal error: unknown section item: %s", item);
+			t.parseError("internal error: unknown section item: %s", item)
 		}
 	}
 	if t.error != nil {
-		return nil;
+		return nil
 	}
 	s.end = t.elems.Len();
 	return s;
@@ -568,24 +568,24 @@ func (t *Template) parse() {
 	for t.error == nil {
 		item := t.nextItem();
 		if t.error != nil {
-			break;
+			break
 		}
 		if len(item) == 0 {
-			break;
+			break
 		}
 		done, tok, w := t.parseSimple(item);
 		if done {
-			continue;
+			continue
 		}
 		switch tok {
 		case tokOr, tokEnd, tokAlternates:
-			t.parseError("unexpected %s", w[0]);
+			t.parseError("unexpected %s", w[0])
 		case tokSection:
-			t.parseSection(w);
+			t.parseSection(w)
 		case tokRepeated:
-			t.parseRepeated(w);
+			t.parseRepeated(w)
 		default:
-			t.parseError("internal error: bad directive in parse: %s", item);
+			t.parseError("internal error: bad directive in parse: %s", item)
 		}
 	}
 }
@@ -600,7 +600,7 @@ func (t *Template) parse() {
 // it represents the actual named field.
 func (st *state) findVar(s string) reflect.Value {
 	if s == "@" {
-		return st.data;
+		return st.data
 	}
 	data := st.data;
 	elems := strings.Split(s, ".", 0);
@@ -608,15 +608,15 @@ func (st *state) findVar(s string) reflect.Value {
 		// Look up field; data must be a struct.
 		data = reflect.Indirect(data);
 		if data == nil {
-			return nil;
+			return nil
 		}
 		typ, ok := data.Type().(*reflect.StructType);
 		if !ok {
-			return nil;
+			return nil
 		}
 		field, ok := typ.FieldByName(elems[i]);
 		if !ok {
-			return nil;
+			return nil
 		}
 		data = data.(*reflect.StructValue).FieldByIndex(field.Index);
 	}
@@ -627,19 +627,19 @@ func (st *state) findVar(s string) reflect.Value {
 func empty(v reflect.Value) bool {
 	v = reflect.Indirect(v);
 	if v == nil {
-		return true;
+		return true
 	}
 	switch v := v.(type) {
 	case *reflect.BoolValue:
-		return v.Get() == false;
+		return v.Get() == false
 	case *reflect.StringValue:
-		return v.Get() == "";
+		return v.Get() == ""
 	case *reflect.StructValue:
-		return false;
+		return false
 	case *reflect.ArrayValue:
-		return v.Len() == 0;
+		return v.Len() == 0
 	case *reflect.SliceValue:
-		return v.Len() == 0;
+		return v.Len() == 0
 	}
 	return true;
 }
@@ -649,7 +649,7 @@ func (t *Template) varValue(name string, st *state) reflect.Value {
 	field := st.findVar(name);
 	if field == nil {
 		if st.parent == nil {
-			t.execError(st, t.linenum, "name not found: %s", name);
+			t.execError(st, t.linenum, "name not found: %s", name)
 		}
 		return t.varValue(name, st.parent);
 	}
@@ -703,7 +703,7 @@ func (t *Template) executeElement(i int, st *state) int {
 // Execute the template.
 func (t *Template) execute(start, end int, st *state) {
 	for i := start; i < end; {
-		i = t.executeElement(i, st);
+		i = t.executeElement(i, st)
 	}
 }
 
@@ -712,24 +712,24 @@ func (t *Template) executeSection(s *sectionElement, st *state) {
 	// Find driver data for this section.  It must be in the current struct.
 	field := t.varValue(s.field, st);
 	if field == nil {
-		t.execError(st, s.linenum, ".section: cannot find field %s in %s", s.field, reflect.Indirect(st.data).Type());
+		t.execError(st, s.linenum, ".section: cannot find field %s in %s", s.field, reflect.Indirect(st.data).Type())
 	}
 	st = st.clone(field);
 	start, end := s.start, s.or;
 	if !empty(field) {
 		// Execute the normal block.
 		if end < 0 {
-			end = s.end;
+			end = s.end
 		}
 	} else {
 		// Execute the .or block.  If it's missing, do nothing.
 		start, end = s.or, s.end;
 		if start < 0 {
-			return;
+			return
 		}
 	}
 	for i := start; i < end; {
-		i = t.executeElement(i, st);
+		i = t.executeElement(i, st)
 	}
 }
 
@@ -741,11 +741,11 @@ func iter(v reflect.Value) *reflect.ChanValue {
 		ft := fv.Type().(*reflect.FuncType);
 		// TODO(rsc): NumIn() should return 0 here, because ft is from a curried FuncValue.
 		if mth.Name != "Iter" || ft.NumIn() != 1 || ft.NumOut() != 1 {
-			continue;
+			continue
 		}
 		ct, ok := ft.Out(0).(*reflect.ChanType);
 		if !ok || ct.Dir() & reflect.RecvDir == 0 {
-			continue;
+			continue
 		}
 		return fv.Call(nil)[0].(*reflect.ChanValue);
 	}
@@ -757,15 +757,15 @@ func (t *Template) executeRepeated(r *repeatedElement, st *state) {
 	// Find driver data for this section.  It must be in the current struct.
 	field := t.varValue(r.field, st);
 	if field == nil {
-		t.execError(st, r.linenum, ".repeated: cannot find field %s in %s", r.field, reflect.Indirect(st.data).Type());
+		t.execError(st, r.linenum, ".repeated: cannot find field %s in %s", r.field, reflect.Indirect(st.data).Type())
 	}
 
 	start, end := r.start, r.or;
 	if end < 0 {
-		end = r.end;
+		end = r.end
 	}
 	if r.altstart >= 0 {
-		end = r.altstart;
+		end = r.altstart
 	}
 	first := true;
 
@@ -776,38 +776,38 @@ func (t *Template) executeRepeated(r *repeatedElement, st *state) {
 			// .alternates between elements
 			if !first && r.altstart >= 0 {
 				for i := r.altstart; i < r.altend; {
-					i = t.executeElement(i, newst);
+					i = t.executeElement(i, newst)
 				}
 			}
 			first = false;
 
 			for i := start; i < end; {
-				i = t.executeElement(i, newst);
+				i = t.executeElement(i, newst)
 			}
 		}
 	} else if ch := iter(field); ch != nil {
 		for {
 			e := ch.Recv();
 			if ch.Closed() {
-				break;
+				break
 			}
 			newst := st.clone(e);
 
 			// .alternates between elements
 			if !first && r.altstart >= 0 {
 				for i := r.altstart; i < r.altend; {
-					i = t.executeElement(i, newst);
+					i = t.executeElement(i, newst)
 				}
 			}
 			first = false;
 
 			for i := start; i < end; {
-				i = t.executeElement(i, newst);
+				i = t.executeElement(i, newst)
 			}
 		}
 	} else {
 		t.execError(st, r.linenum, ".repeated: cannot repeat %s (type %s)",
-			r.field, field.Type());
+			r.field, field.Type())
 	}
 
 	if first {
@@ -816,7 +816,7 @@ func (t *Template) executeRepeated(r *repeatedElement, st *state) {
 		if start >= 0 {
 			newst := st.clone(field);
 			for i := start; i < end; {
-				i = t.executeElement(i, newst);
+				i = t.executeElement(i, newst)
 			}
 		}
 		return;
@@ -826,11 +826,11 @@ func (t *Template) executeRepeated(r *repeatedElement, st *state) {
 // A valid delimiter must contain no white space and be non-empty.
 func validDelim(d []byte) bool {
 	if len(d) == 0 {
-		return false;
+		return false
 	}
 	for _, c := range d {
 		if white(c) {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -843,7 +843,7 @@ func validDelim(d []byte) bool {
 // the error.
 func (t *Template) Parse(s string) os.Error {
 	if !validDelim(t.ldelim) || !validDelim(t.rdelim) {
-		return &Error{1, fmt.Sprintf("bad delimiter strings %q %q", t.ldelim, t.rdelim)};
+		return &Error{1, fmt.Sprintf("bad delimiter strings %q %q", t.ldelim, t.rdelim)}
 	}
 	t.buf = strings.Bytes(s);
 	t.p = 0;
@@ -885,7 +885,7 @@ func Parse(s string, fmap FormatterMap) (t *Template, err os.Error) {
 	t = New(fmap);
 	err = t.Parse(s);
 	if err != nil {
-		t = nil;
+		t = nil
 	}
 	return;
 }
@@ -894,7 +894,7 @@ func Parse(s string, fmap FormatterMap) (t *Template, err os.Error) {
 func MustParse(s string, fmap FormatterMap) *Template {
 	t, err := Parse(s, fmap);
 	if err != nil {
-		panic("template parse error: ", err.String());
+		panic("template parse error: ", err.String())
 	}
 	return t;
 }
diff --git a/src/pkg/template/template_test.go b/src/pkg/template/template_test.go
index 6fbc147265..a93faced0d 100644
--- a/src/pkg/template/template_test.go
+++ b/src/pkg/template/template_test.go
@@ -46,7 +46,7 @@ func uppercase(v interface{}) string {
 	for i := 0; i < len(s); i++ {
 		c := s[i];
 		if 'a' <= c && c <= 'z' {
-			c = c+'A'-'a';
+			c = c+'A'-'a'
 		}
 		t += string(c);
 	}
@@ -60,8 +60,8 @@ func plus1(v interface{}) string {
 
 func writer(f func(interface{}) string) (func(io.Writer, interface{}, string)) {
 	return func(w io.Writer, v interface{}, format string) {
-		io.WriteString(w, f(v));
-	};
+		io.WriteString(w, f(v))
+	}
 }
 
 
@@ -305,15 +305,15 @@ func TestAll(t *testing.T) {
 		err = tmpl.Execute(s, &buf);
 		if test.err == "" {
 			if err != nil {
-				t.Error("unexpected execute error:", err);
+				t.Error("unexpected execute error:", err)
 			}
 		} else {
 			if err == nil || err.String() != test.err {
-				t.Errorf("expected execute error %q, got %q", test.err, err.String());
+				t.Errorf("expected execute error %q, got %q", test.err, err.String())
 			}
 		}
 		if buf.String() != test.out {
-			t.Errorf("for %q: expected %q got %q", test.in, test.out, buf.String());
+			t.Errorf("for %q: expected %q got %q", test.in, test.out, buf.String())
 		}
 	}
 }
@@ -321,42 +321,42 @@ func TestAll(t *testing.T) {
 func TestStringDriverType(t *testing.T) {
 	tmpl, err := Parse("template: {@}", nil);
 	if err != nil {
-		t.Error("unexpected parse error:", err);
+		t.Error("unexpected parse error:", err)
 	}
 	var b bytes.Buffer;
 	err = tmpl.Execute("hello", &b);
 	if err != nil {
-		t.Error("unexpected execute error:", err);
+		t.Error("unexpected execute error:", err)
 	}
 	s := b.String();
 	if s != "template: hello" {
-		t.Errorf("failed passing string as data: expected %q got %q", "template: hello", s);
+		t.Errorf("failed passing string as data: expected %q got %q", "template: hello", s)
 	}
 }
 
 func TestTwice(t *testing.T) {
 	tmpl, err := Parse("template: {@}", nil);
 	if err != nil {
-		t.Error("unexpected parse error:", err);
+		t.Error("unexpected parse error:", err)
 	}
 	var b bytes.Buffer;
 	err = tmpl.Execute("hello", &b);
 	if err != nil {
-		t.Error("unexpected parse error:", err);
+		t.Error("unexpected parse error:", err)
 	}
 	s := b.String();
 	text := "template: hello";
 	if s != text {
-		t.Errorf("failed passing string as data: expected %q got %q", text, s);
+		t.Errorf("failed passing string as data: expected %q got %q", text, s)
 	}
 	err = tmpl.Execute("hello", &b);
 	if err != nil {
-		t.Error("unexpected parse error:", err);
+		t.Error("unexpected parse error:", err)
 	}
 	s = b.String();
 	text += text;
 	if s != text {
-		t.Errorf("failed passing string as data: expected %q got %q", text, s);
+		t.Errorf("failed passing string as data: expected %q got %q", text, s)
 	}
 }
 
@@ -377,7 +377,7 @@ func TestCustomDelims(t *testing.T) {
 			err := tmpl.Parse(text);
 			if err != nil {
 				if i == 0 || j == 0 {	// expected
-					continue;
+					continue
 				}
 				t.Error("unexpected parse error:", err);
 			} else if i == 0 || j == 0 {
@@ -388,7 +388,7 @@ func TestCustomDelims(t *testing.T) {
 			err = tmpl.Execute("hello", &b);
 			s := b.String();
 			if s != "template: hello" + ldelim + rdelim {
-				t.Errorf("failed delim check(%q %q) %q got %q", ldelim, rdelim, text, s);
+				t.Errorf("failed delim check(%q %q) %q got %q", ldelim, rdelim, text, s)
 			}
 		}
 	}
@@ -404,14 +404,14 @@ func TestVarIndirection(t *testing.T) {
 	input := "{.section @}{innerPointerT}{.end}";
 	tmpl, err := Parse(input, nil);
 	if err != nil {
-		t.Fatal("unexpected parse error:", err);
+		t.Fatal("unexpected parse error:", err)
 	}
 	err = tmpl.Execute(s, &buf);
 	if err != nil {
-		t.Fatal("unexpected execute error:", err);
+		t.Fatal("unexpected execute error:", err)
 	}
 	expect := fmt.Sprintf("%v", &t1);	// output should be hex address of t1
 	if buf.String() != expect {
-		t.Errorf("for %q: expected %q got %q", input, expect, buf.String());
+		t.Errorf("for %q: expected %q got %q", input, expect, buf.String())
 	}
 }
diff --git a/src/pkg/testing/iotest/logger.go b/src/pkg/testing/iotest/logger.go
index 4eee6670b8..0b01fcbbea 100644
--- a/src/pkg/testing/iotest/logger.go
+++ b/src/pkg/testing/iotest/logger.go
@@ -18,9 +18,9 @@ type writeLogger struct {
 func (l *writeLogger) Write(p []byte) (n int, err os.Error) {
 	n, err = l.w.Write(p);
 	if err != nil {
-		log.Stdoutf("%s %x: %v", l.prefix, p[0:n], err);
+		log.Stdoutf("%s %x: %v", l.prefix, p[0:n], err)
 	} else {
-		log.Stdoutf("%s %x", l.prefix, p[0:n]);
+		log.Stdoutf("%s %x", l.prefix, p[0:n])
 	}
 	return;
 }
@@ -29,7 +29,7 @@ func (l *writeLogger) Write(p []byte) (n int, err os.Error) {
 // that it logs (using log.Stdout) each write to standard output,
 // printing the prefix and the hexadecimal data written.
 func NewWriteLogger(prefix string, w io.Writer) io.Writer {
-	return &writeLogger{prefix, w};
+	return &writeLogger{prefix, w}
 }
 
 type readLogger struct {
@@ -40,9 +40,9 @@ type readLogger struct {
 func (l *readLogger) Read(p []byte) (n int, err os.Error) {
 	n, err = l.r.Read(p);
 	if err != nil {
-		log.Stdoutf("%s %x: %v", l.prefix, p[0:n], err);
+		log.Stdoutf("%s %x: %v", l.prefix, p[0:n], err)
 	} else {
-		log.Stdoutf("%s %x", l.prefix, p[0:n]);
+		log.Stdoutf("%s %x", l.prefix, p[0:n])
 	}
 	return;
 }
@@ -51,5 +51,5 @@ func (l *readLogger) Read(p []byte) (n int, err os.Error) {
 // that it logs (using log.Stdout) each write to standard output,
 // printing the prefix and the hexadecimal data written.
 func NewReadLogger(prefix string, r io.Reader) io.Reader {
-	return &readLogger{prefix, r};
+	return &readLogger{prefix, r}
 }
diff --git a/src/pkg/testing/iotest/reader.go b/src/pkg/testing/iotest/reader.go
index ae427e6fab..61da735de6 100644
--- a/src/pkg/testing/iotest/reader.go
+++ b/src/pkg/testing/iotest/reader.go
@@ -22,7 +22,7 @@ type oneByteReader struct {
 
 func (r *oneByteReader) Read(p []byte) (int, os.Error) {
 	if len(p) == 0 {
-		return 0, nil;
+		return 0, nil
 	}
 	return r.r.Read(p[0:1]);
 }
@@ -36,7 +36,7 @@ type halfReader struct {
 }
 
 func (r *halfReader) Read(p []byte) (int, os.Error) {
-	return r.r.Read(p[0 : (len(p)+1)/2]);
+	return r.r.Read(p[0 : (len(p)+1)/2])
 }
 
 
@@ -61,7 +61,7 @@ func (r *dataErrReader) Read(p []byte) (n int, err os.Error) {
 			err = err1;
 		}
 		if n > 0 {
-			break;
+			break
 		}
 		n = bytes.Copy(p, r.unread);
 		r.unread = r.unread[n:len(r.unread)];
diff --git a/src/pkg/testing/iotest/writer.go b/src/pkg/testing/iotest/writer.go
index 8b0e4ca8fe..54468a6fe2 100644
--- a/src/pkg/testing/iotest/writer.go
+++ b/src/pkg/testing/iotest/writer.go
@@ -12,7 +12,7 @@ import (
 // TruncateWriter returns a Writer that writes to w
 // but stops silently after n bytes.
 func TruncateWriter(w io.Writer, n int64) io.Writer {
-	return &truncateWriter{w, n};
+	return &truncateWriter{w, n}
 }
 
 type truncateWriter struct {
@@ -22,17 +22,17 @@ type truncateWriter struct {
 
 func (t *truncateWriter) Write(p []byte) (n int, err os.Error) {
 	if t.n <= 0 {
-		return len(p), nil;
+		return len(p), nil
 	}
 	// real write
 	n = len(p);
 	if int64(n) > t.n {
-		n = int(t.n);
+		n = int(t.n)
 	}
 	n, err = t.w.Write(p[0:n]);
 	t.n -= int64(n);
 	if err == nil {
-		n = len(p);
+		n = len(p)
 	}
 	return;
 }
diff --git a/src/pkg/testing/quick/quick.go b/src/pkg/testing/quick/quick.go
index 3d47240bda..825fc12e2f 100644
--- a/src/pkg/testing/quick/quick.go
+++ b/src/pkg/testing/quick/quick.go
@@ -28,7 +28,7 @@ type Generator interface {
 func randFloat32(rand *rand.Rand) float32 {
 	f := rand.Float64() * math.MaxFloat32;
 	if rand.Int() & 1 == 1 {
-		f = -f;
+		f = -f
 	}
 	return float32(f);
 }
@@ -37,7 +37,7 @@ func randFloat32(rand *rand.Rand) float32 {
 func randFloat64(rand *rand.Rand) float64 {
 	f := rand.Float64();
 	if rand.Int() & 1 == 1 {
-		f = -f;
+		f = -f
 	}
 	return f;
 }
@@ -54,32 +54,32 @@ const complexSize = 50
 // Note: in order to create arbitrary values for structs, all the members must be public.
 func Value(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool) {
 	if m, ok := reflect.MakeZero(t).Interface().(Generator); ok {
-		return m.Generate(rand, complexSize), true;
+		return m.Generate(rand, complexSize), true
 	}
 
 	switch concrete := t.(type) {
 	case *reflect.BoolType:
-		return reflect.NewValue(rand.Int() & 1 == 0), true;
+		return reflect.NewValue(rand.Int() & 1 == 0), true
 	case *reflect.Float32Type:
-		return reflect.NewValue(randFloat32(rand)), true;
+		return reflect.NewValue(randFloat32(rand)), true
 	case *reflect.Float64Type:
-		return reflect.NewValue(randFloat64(rand)), true;
+		return reflect.NewValue(randFloat64(rand)), true
 	case *reflect.FloatType:
 		if t.Size() == 4 {
-			return reflect.NewValue(float(randFloat32(rand))), true;
+			return reflect.NewValue(float(randFloat32(rand))), true
 		} else {
-			return reflect.NewValue(float(randFloat64(rand))), true;
+			return reflect.NewValue(float(randFloat64(rand))), true
 		}
 	case *reflect.Int16Type:
-		return reflect.NewValue(int16(randInt64(rand))), true;
+		return reflect.NewValue(int16(randInt64(rand))), true
 	case *reflect.Int32Type:
-		return reflect.NewValue(int32(randInt64(rand))), true;
+		return reflect.NewValue(int32(randInt64(rand))), true
 	case *reflect.Int64Type:
-		return reflect.NewValue(randInt64(rand)), true;
+		return reflect.NewValue(randInt64(rand)), true
 	case *reflect.Int8Type:
-		return reflect.NewValue(int8(randInt64(rand))), true;
+		return reflect.NewValue(int8(randInt64(rand))), true
 	case *reflect.IntType:
-		return reflect.NewValue(int(randInt64(rand))), true;
+		return reflect.NewValue(int(randInt64(rand))), true
 	case *reflect.MapType:
 		numElems := rand.Intn(complexSize);
 		m := reflect.MakeMap(concrete);
@@ -87,7 +87,7 @@ func Value(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool) {
 			key, ok1 := Value(concrete.Key(), rand);
 			value, ok2 := Value(concrete.Elem(), rand);
 			if !ok1 || !ok2 {
-				return nil, false;
+				return nil, false
 			}
 			m.SetElem(key, value);
 		}
@@ -95,7 +95,7 @@ func Value(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool) {
 	case *reflect.PtrType:
 		v, ok := Value(concrete.Elem(), rand);
 		if !ok {
-			return nil, false;
+			return nil, false
 		}
 		p := reflect.MakeZero(concrete);
 		p.(*reflect.PtrValue).PointTo(v);
@@ -106,7 +106,7 @@ func Value(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool) {
 		for i := 0; i < numElems; i++ {
 			v, ok := Value(concrete.Elem(), rand);
 			if !ok {
-				return nil, false;
+				return nil, false
 			}
 			s.Elem(i).SetValue(v);
 		}
@@ -115,7 +115,7 @@ func Value(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool) {
 		numChars := rand.Intn(complexSize);
 		codePoints := make([]int, numChars);
 		for i := 0; i < numChars; i++ {
-			codePoints[i] = rand.Intn(0x10ffff);
+			codePoints[i] = rand.Intn(0x10ffff)
 		}
 		return reflect.NewValue(string(codePoints)), true;
 	case *reflect.StructType:
@@ -123,25 +123,25 @@ func Value(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool) {
 		for i := 0; i < s.NumField(); i++ {
 			v, ok := Value(concrete.Field(i).Type, rand);
 			if !ok {
-				return nil, false;
+				return nil, false
 			}
 			s.Field(i).SetValue(v);
 		}
 		return s, true;
 	case *reflect.Uint16Type:
-		return reflect.NewValue(uint16(randInt64(rand))), true;
+		return reflect.NewValue(uint16(randInt64(rand))), true
 	case *reflect.Uint32Type:
-		return reflect.NewValue(uint32(randInt64(rand))), true;
+		return reflect.NewValue(uint32(randInt64(rand))), true
 	case *reflect.Uint64Type:
-		return reflect.NewValue(uint64(randInt64(rand))), true;
+		return reflect.NewValue(uint64(randInt64(rand))), true
 	case *reflect.Uint8Type:
-		return reflect.NewValue(uint8(randInt64(rand))), true;
+		return reflect.NewValue(uint8(randInt64(rand))), true
 	case *reflect.UintType:
-		return reflect.NewValue(uint(randInt64(rand))), true;
+		return reflect.NewValue(uint(randInt64(rand))), true
 	case *reflect.UintptrType:
-		return reflect.NewValue(uintptr(randInt64(rand))), true;
+		return reflect.NewValue(uintptr(randInt64(rand))), true
 	default:
-		return nil, false;
+		return nil, false
 	}
 
 	return;
@@ -169,7 +169,7 @@ var defaultConfig Config
 // getRand returns the *rand.Rand to use for a given Config.
 func (c *Config) getRand() *rand.Rand {
 	if c.Rand == nil {
-		return rand.New(rand.NewSource(0));
+		return rand.New(rand.NewSource(0))
 	}
 	return c.Rand;
 }
@@ -180,9 +180,9 @@ func (c *Config) getMaxCount() (maxCount int) {
 	maxCount = c.MaxCount;
 	if maxCount == 0 {
 		if c.MaxCountScale != 0 {
-			maxCount = int(c.MaxCountScale * float(*defaultMaxCount));
+			maxCount = int(c.MaxCountScale * float(*defaultMaxCount))
 		} else {
-			maxCount = *defaultMaxCount;
+			maxCount = *defaultMaxCount
 		}
 	}
 
@@ -202,7 +202,7 @@ type CheckError struct {
 }
 
 func (s *CheckError) String() string {
-	return fmt.Sprintf("#%d: failed on input %s", s.Count, toString(s.In));
+	return fmt.Sprintf("#%d: failed on input %s", s.Count, toString(s.In))
 }
 
 // A CheckEqualError is the result CheckEqual finding an error.
@@ -213,7 +213,7 @@ type CheckEqualError struct {
 }
 
 func (s *CheckEqualError) String() string {
-	return fmt.Sprintf("#%d: failed on input %s. Output 1: %s. Output 2: %s", s.Count, toString(s.In), toString(s.Out1), toString(s.Out2));
+	return fmt.Sprintf("#%d: failed on input %s. Output 1: %s. Output 2: %s", s.Count, toString(s.In), toString(s.Out1), toString(s.Out2))
 }
 
 // Check looks for an input to f, any function that returns bool,
@@ -233,7 +233,7 @@ func (s *CheckEqualError) String() string {
 // 	}
 func Check(function interface{}, config *Config) (err os.Error) {
 	if config == nil {
-		config = &defaultConfig;
+		config = &defaultConfig
 	}
 
 	f, fType, ok := functionAndType(function);
@@ -258,7 +258,7 @@ func Check(function interface{}, config *Config) (err os.Error) {
 	for i := 0; i < maxCount; i++ {
 		err = arbitraryValues(arguments, fType, config, rand);
 		if err != nil {
-			return;
+			return
 		}
 
 		if !f.Call(arguments)[0].(*reflect.BoolValue).Get() {
@@ -276,7 +276,7 @@ func Check(function interface{}, config *Config) (err os.Error) {
 // describing the input and the outputs.
 func CheckEqual(f, g interface{}, config *Config) (err os.Error) {
 	if config == nil {
-		config = &defaultConfig;
+		config = &defaultConfig
 	}
 
 	x, xType, ok := functionAndType(f);
@@ -302,7 +302,7 @@ func CheckEqual(f, g interface{}, config *Config) (err os.Error) {
 	for i := 0; i < maxCount; i++ {
 		err = arbitraryValues(arguments, xType, config, rand);
 		if err != nil {
-			return;
+			return
 		}
 
 		xOut := toInterfaces(x.Call(arguments));
@@ -340,7 +340,7 @@ func arbitraryValues(args []reflect.Value, f *reflect.FuncType, config *Config,
 func functionAndType(f interface{}) (v *reflect.FuncValue, t *reflect.FuncType, ok bool) {
 	v, ok = reflect.NewValue(f).(*reflect.FuncValue);
 	if !ok {
-		return;
+		return
 	}
 	t = v.Type().(*reflect.FuncType);
 	return;
@@ -349,7 +349,7 @@ func functionAndType(f interface{}) (v *reflect.FuncValue, t *reflect.FuncType,
 func toInterfaces(values []reflect.Value) []interface{} {
 	ret := make([]interface{}, len(values));
 	for i, v := range values {
-		ret[i] = v.Interface();
+		ret[i] = v.Interface()
 	}
 	return ret;
 }
@@ -357,7 +357,7 @@ func toInterfaces(values []reflect.Value) []interface{} {
 func toString(interfaces []interface{}) string {
 	s := make([]string, len(interfaces));
 	for i, v := range interfaces {
-		s[i] = fmt.Sprintf("%#v", v);
+		s[i] = fmt.Sprintf("%#v", v)
 	}
 	return strings.Join(s, ", ");
 }
diff --git a/src/pkg/testing/quick/quick_test.go b/src/pkg/testing/quick/quick_test.go
index 951582e35e..b4037ab550 100644
--- a/src/pkg/testing/quick/quick_test.go
+++ b/src/pkg/testing/quick/quick_test.go
@@ -63,7 +63,7 @@ func fIntptr(a *int) *int {
 
 func reportError(property string, err os.Error, t *testing.T) {
 	if err != nil {
-		t.Errorf("%s: %s", property, err);
+		t.Errorf("%s: %s", property, err)
 	}
 }
 
@@ -99,46 +99,46 @@ type myStruct struct {
 }
 
 func (m myStruct) Generate(r *rand.Rand, _ int) reflect.Value {
-	return reflect.NewValue(myStruct{x: 42});
+	return reflect.NewValue(myStruct{x: 42})
 }
 
 func myStructProperty(in myStruct) bool	{ return in.x == 42 }
 
 func TestCheckProperty(t *testing.T) {
-	reportError("myStructProperty", Check(myStructProperty, nil), t);
+	reportError("myStructProperty", Check(myStructProperty, nil), t)
 }
 
 func TestFailure(t *testing.T) {
 	f := func(x int) bool { return false };
 	err := Check(f, nil);
 	if err == nil {
-		t.Errorf("Check didn't return an error");
+		t.Errorf("Check didn't return an error")
 	}
 	if _, ok := err.(*CheckError); !ok {
-		t.Errorf("Error was not a CheckError: %s", err);
+		t.Errorf("Error was not a CheckError: %s", err)
 	}
 
 	err = CheckEqual(fUint, fUint32, nil);
 	if err == nil {
-		t.Errorf("#1 CheckEqual didn't return an error");
+		t.Errorf("#1 CheckEqual didn't return an error")
 	}
 	if _, ok := err.(SetupError); !ok {
-		t.Errorf("#1 Error was not a SetupError: %s", err);
+		t.Errorf("#1 Error was not a SetupError: %s", err)
 	}
 
 	err = CheckEqual(func(x, y int) {}, func(x int) {}, nil);
 	if err == nil {
-		t.Errorf("#2 CheckEqual didn't return an error");
+		t.Errorf("#2 CheckEqual didn't return an error")
 	}
 	if _, ok := err.(SetupError); !ok {
-		t.Errorf("#2 Error was not a SetupError: %s", err);
+		t.Errorf("#2 Error was not a SetupError: %s", err)
 	}
 
 	err = CheckEqual(func(x int) int { return 0 }, func(x int) int32 { return 0 }, nil);
 	if err == nil {
-		t.Errorf("#3 CheckEqual didn't return an error");
+		t.Errorf("#3 CheckEqual didn't return an error")
 	}
 	if _, ok := err.(SetupError); !ok {
-		t.Errorf("#3 Error was not a SetupError: %s", err);
+		t.Errorf("#3 Error was not a SetupError: %s", err)
 	}
 }
diff --git a/src/pkg/testing/regexp.go b/src/pkg/testing/regexp.go
index f4cfe5e6e2..5093d512e3 100644
--- a/src/pkg/testing/regexp.go
+++ b/src/pkg/testing/regexp.go
@@ -152,15 +152,15 @@ func (cclass *_CharClass) kind() int	{ return _CHARCLASS }
 func (cclass *_CharClass) print() {
 	print("charclass");
 	if cclass.negate {
-		print(" (negated)");
+		print(" (negated)")
 	}
 	for i := 0; i < len(cclass.ranges); i += 2 {
 		l := cclass.ranges[i];
 		r := cclass.ranges[i+1];
 		if l == r {
-			print(" [", string(l), "]");
+			print(" [", string(l), "]")
 		} else {
-			print(" [", string(l), "-", string(r), "]");
+			print(" [", string(l), "-", string(r), "]")
 		}
 	}
 }
@@ -171,7 +171,7 @@ func (cclass *_CharClass) addRange(a, b int) {
 	if n >= cap(cclass.ranges) {
 		nr := make([]int, n, 2*n);
 		for i, j := range nr {
-			nr[i] = j;
+			nr[i] = j
 		}
 		cclass.ranges = nr;
 	}
@@ -187,7 +187,7 @@ func (cclass *_CharClass) matches(c int) bool {
 		min := cclass.ranges[i];
 		max := cclass.ranges[i+1];
 		if min <= c && c <= max {
-			return !cclass.negate;
+			return !cclass.negate
 		}
 	}
 	return cclass.negate;
@@ -256,7 +256,7 @@ func (re *Regexp) add(i instr) instr {
 	if n >= cap(re.inst) {
 		ni := make([]instr, n, 2*n);
 		for i, j := range re.inst {
-			ni[i] = j;
+			ni[i] = j
 		}
 		re.inst = ni;
 	}
@@ -279,7 +279,7 @@ func (p *parser) c() int	{ return p.ch }
 
 func (p *parser) nextc() int {
 	if p.pos >= len(p.re.expr) {
-		p.ch = endOfFile;
+		p.ch = endOfFile
 	} else {
 		c, w := utf8.DecodeRuneInString(p.re.expr[p.pos : len(p.re.expr)]);
 		p.ch = c;
@@ -299,7 +299,7 @@ func special(c int) bool {
 	s := `\.+*?()|[]^$`;
 	for i := 0; i < len(s); i++ {
 		if c == int(s[i]) {
-			return true;
+			return true
 		}
 	}
 	return false;
@@ -309,7 +309,7 @@ func specialcclass(c int) bool {
 	s := `\-[]`;
 	for i := 0; i < len(s); i++ {
 		if c == int(s[i]) {
-			return true;
+			return true
 		}
 	}
 	return false;
@@ -348,7 +348,7 @@ func (p *parser) charClass() instr {
 				p.error = ErrExtraneousBackslash;
 				return nil;
 			case c == 'n':
-				c = '\n';
+				c = '\n'
 			case specialcclass(c):
 			// c is as delivered
 			default:
@@ -364,7 +364,7 @@ func (p *parser) charClass() instr {
 					p.nextc();
 					left = c;
 				} else {	// single char
-					cc.addRange(c, c);
+					cc.addRange(c, c)
 				}
 			case left <= c:	// second of pair
 				cc.addRange(left, c);
@@ -384,11 +384,11 @@ func (p *parser) term() (start, end instr) {
 	// The other functions (closure(), concatenation() etc.) assume
 	// it's safe to recur to here.
 	if p.error != "" {
-		return;
+		return
 	}
 	switch c := p.c(); c {
 	case '|', endOfFile:
-		return nil, nil;
+		return nil, nil
 	case '*', '+':
 		p.error = ErrBareClosure;
 		return;
@@ -417,7 +417,7 @@ func (p *parser) term() (start, end instr) {
 		p.nextc();
 		start = p.charClass();
 		if p.error != "" {
-			return;
+			return
 		}
 		if p.c() != ']' {
 			p.error = ErrUnmatchedLbkt;
@@ -450,7 +450,7 @@ func (p *parser) term() (start, end instr) {
 			}
 			start = ebra;
 		} else {
-			end.setNext(ebra);
+			end.setNext(ebra)
 		}
 		bra.setNext(start);
 		return bra, ebra;
@@ -461,7 +461,7 @@ func (p *parser) term() (start, end instr) {
 			p.error = ErrExtraneousBackslash;
 			return;
 		case c == 'n':
-			c = '\n';
+			c = '\n'
 		case special(c):
 		// c is as delivered
 		default:
@@ -481,7 +481,7 @@ func (p *parser) term() (start, end instr) {
 func (p *parser) closure() (start, end instr) {
 	start, end = p.term();
 	if start == nil || p.error != "" {
-		return;
+		return
 	}
 	switch p.c() {
 	case '*':
@@ -511,11 +511,11 @@ func (p *parser) closure() (start, end instr) {
 		start = alt;		// start is now alt
 		end = nop;		// end is nop pointed to by both branches
 	default:
-		return;
+		return
 	}
 	switch p.nextc() {
 	case '*', '+', '?':
-		p.error = ErrBadClosure;
+		p.error = ErrBadClosure
 	}
 	return;
 }
@@ -524,7 +524,7 @@ func (p *parser) concatenation() (start, end instr) {
 	for {
 		nstart, nend := p.closure();
 		if p.error != "" {
-			return;
+			return
 		}
 		switch {
 		case nstart == nil:	// end of this concatenation
@@ -534,7 +534,7 @@ func (p *parser) concatenation() (start, end instr) {
 			}
 			return;
 		case start == nil:	// this is first element of concatenation
-			start, end = nstart, nend;
+			start, end = nstart, nend
 		default:
 			end.setNext(nstart);
 			end = nend;
@@ -546,17 +546,17 @@ func (p *parser) concatenation() (start, end instr) {
 func (p *parser) regexp() (start, end instr) {
 	start, end = p.concatenation();
 	if p.error != "" {
-		return;
+		return
 	}
 	for {
 		switch p.c() {
 		default:
-			return;
+			return
 		case '|':
 			p.nextc();
 			nstart, nend := p.concatenation();
 			if p.error != "" {
-				return;
+				return
 			}
 			alt := new(_Alt);
 			p.re.add(alt);
@@ -574,7 +574,7 @@ func (p *parser) regexp() (start, end instr) {
 
 func unNop(i instr) instr {
 	for i.kind() == _NOP {
-		i = i.next();
+		i = i.next()
 	}
 	return i;
 }
@@ -583,7 +583,7 @@ func (re *Regexp) eliminateNops() {
 	for i := 0; i < len(re.inst); i++ {
 		inst := re.inst[i];
 		if inst.kind() == _END {
-			continue;
+			continue
 		}
 		inst.setNext(unNop(inst.next()));
 		if inst.kind() == _ALT {
@@ -599,7 +599,7 @@ func (re *Regexp) doParse() string {
 	re.add(start);
 	s, e := p.regexp();
 	if p.error != "" {
-		return p.error;
+		return p.error
 	}
 	start.setNext(s);
 	re.start = start;
@@ -624,7 +624,7 @@ func CompileRegexp(str string) (regexp *Regexp, error string) {
 func MustCompile(str string) *Regexp {
 	regexp, error := CompileRegexp(str);
 	if error != "" {
-		panicln(`regexp: compiling "`, str, `": `, error);
+		panicln(`regexp: compiling "`, str, `": `, error)
 	}
 	return regexp;
 }
@@ -645,13 +645,13 @@ func addState(s []state, inst instr, match []int) []state {
 	for i := 0; i < l; i++ {
 		if s[i].inst.index() == index &&	// same instruction
 			s[i].match[0] < pos {	// earlier match already going; lefmost wins
-			return s;
+			return s
 		}
 	}
 	if l == cap(s) {
 		s1 := make([]state, 2*l)[0:l];
 		for i := 0; i < l; i++ {
-			s1[i] = s[i];
+			s1[i] = s[i]
 		}
 		s = s1;
 	}
@@ -672,14 +672,14 @@ func (re *Regexp) doExecute(str string, bytes []byte, pos int) []int {
 	found := false;
 	end := len(str);
 	if bytes != nil {
-		end = len(bytes);
+		end = len(bytes)
 	}
 	for pos <= end {
 		if !found {
 			// prime the pump if we haven't seen a match yet
 			match := make([]int, 2*(re.nbra + 1));
 			for i := 0; i < len(match); i++ {
-				match[i] = -1;	// no match seen; catches cases like "a(b)?c" on "ac"
+				match[i] = -1	// no match seen; catches cases like "a(b)?c" on "ac"
 			}
 			match[0] = pos;
 			s[out] = addState(s[out], re.start.next(), match);
@@ -688,15 +688,15 @@ func (re *Regexp) doExecute(str string, bytes []byte, pos int) []int {
 		s[out] = s[out][0:0];	// clear out state
 		if len(s[in]) == 0 {
 			// machine has completed
-			break;
+			break
 		}
 		charwidth := 1;
 		c := endOfFile;
 		if pos < end {
 			if bytes == nil {
-				c, charwidth = utf8.DecodeRuneInString(str[pos:end]);
+				c, charwidth = utf8.DecodeRuneInString(str[pos:end])
 			} else {
-				c, charwidth = utf8.DecodeRune(bytes[pos:end]);
+				c, charwidth = utf8.DecodeRune(bytes[pos:end])
 			}
 		}
 		for i := 0; i < len(s[in]); i++ {
@@ -704,27 +704,27 @@ func (re *Regexp) doExecute(str string, bytes []byte, pos int) []int {
 			switch s[in][i].inst.kind() {
 			case _BOT:
 				if pos == 0 {
-					s[in] = addState(s[in], st.inst.next(), st.match);
+					s[in] = addState(s[in], st.inst.next(), st.match)
 				}
 			case _EOT:
 				if pos == end {
-					s[in] = addState(s[in], st.inst.next(), st.match);
+					s[in] = addState(s[in], st.inst.next(), st.match)
 				}
 			case _CHAR:
 				if c == st.inst.(*_Char).char {
-					s[out] = addState(s[out], st.inst.next(), st.match);
+					s[out] = addState(s[out], st.inst.next(), st.match)
 				}
 			case _CHARCLASS:
 				if st.inst.(*_CharClass).matches(c) {
-					s[out] = addState(s[out], st.inst.next(), st.match);
+					s[out] = addState(s[out], st.inst.next(), st.match)
 				}
 			case _ANY:
 				if c != endOfFile {
-					s[out] = addState(s[out], st.inst.next(), st.match);
+					s[out] = addState(s[out], st.inst.next(), st.match)
 				}
 			case _NOTNL:
 				if c != endOfFile && c != '\n' {
-					s[out] = addState(s[out], st.inst.next(), st.match);
+					s[out] = addState(s[out], st.inst.next(), st.match)
 				}
 			case _BRA:
 				n := st.inst.(*_Bra).n;
@@ -739,7 +739,7 @@ func (re *Regexp) doExecute(str string, bytes []byte, pos int) []int {
 				// give other branch a copy of this match vector
 				s1 := make([]int, 2*(re.nbra + 1));
 				for i := 0; i < len(s1); i++ {
-					s1[i] = st.match[i];
+					s1[i] = st.match[i]
 				}
 				s[in] = addState(s[in], st.inst.next(), s1);
 			case _END:
@@ -770,7 +770,7 @@ func (re *Regexp) doExecute(str string, bytes []byte, pos int) []int {
 // A negative value means the subexpression did not match any element of the string.
 // An empty array means "no match".
 func (re *Regexp) ExecuteString(s string) (a []int) {
-	return re.doExecute(s, nil, 0);
+	return re.doExecute(s, nil, 0)
 }
 
 
@@ -802,12 +802,12 @@ func (re *Regexp) Match(b []byte) bool	{ return len(re.doExecute("", b, 0)) > 0
 func (re *Regexp) MatchStrings(s string) (a []string) {
 	r := re.doExecute(s, nil, 0);
 	if r == nil {
-		return nil;
+		return nil
 	}
 	a = make([]string, len(r)/2);
 	for i := 0; i < len(r); i += 2 {
 		if r[i] != -1 {	// -1 means no match for this subexpression
-			a[i/2] = s[r[i]:r[i+1]];
+			a[i/2] = s[r[i]:r[i+1]]
 		}
 	}
 	return;
@@ -821,12 +821,12 @@ func (re *Regexp) MatchStrings(s string) (a []string) {
 func (re *Regexp) MatchSlices(b []byte) (a [][]byte) {
 	r := re.doExecute("", b, 0);
 	if r == nil {
-		return nil;
+		return nil
 	}
 	a = make([][]byte, len(r)/2);
 	for i := 0; i < len(r); i += 2 {
 		if r[i] != -1 {	// -1 means no match for this subexpression
-			a[i/2] = b[r[i]:r[i+1]];
+			a[i/2] = b[r[i]:r[i+1]]
 		}
 	}
 	return;
@@ -838,7 +838,7 @@ func (re *Regexp) MatchSlices(b []byte) (a [][]byte) {
 func MatchString(pattern string, s string) (matched bool, error string) {
 	re, err := CompileRegexp(pattern);
 	if err != "" {
-		return false, err;
+		return false, err
 	}
 	return re.MatchString(s), "";
 }
@@ -849,7 +849,7 @@ func MatchString(pattern string, s string) (matched bool, error string) {
 func Match(pattern string, b []byte) (matched bool, error string) {
 	re, err := CompileRegexp(pattern);
 	if err != "" {
-		return false, err;
+		return false, err
 	}
 	return re.Match(b), "";
 }
diff --git a/src/pkg/testing/regexp_test.go b/src/pkg/testing/regexp_test.go
index d24e801b90..89a214fcae 100644
--- a/src/pkg/testing/regexp_test.go
+++ b/src/pkg/testing/regexp_test.go
@@ -89,7 +89,7 @@ var matches = []tester{
 func compileTest(t *T, expr string, error string) *Regexp {
 	re, err := CompileRegexp(expr);
 	if err != error {
-		t.Error("compiling `", expr, "`; unexpected error: ", err);
+		t.Error("compiling `", expr, "`; unexpected error: ", err)
 	}
 	return re;
 }
@@ -97,10 +97,10 @@ func compileTest(t *T, expr string, error string) *Regexp {
 func printVec(t *T, m []int) {
 	l := len(m);
 	if l == 0 {
-		t.Log("\t<no match>");
+		t.Log("\t<no match>")
 	} else {
 		for i := 0; i < l; i = i+2 {
-			t.Log("\t", m[i], ",", m[i+1]);
+			t.Log("\t", m[i], ",", m[i+1])
 		}
 	}
 }
@@ -108,10 +108,10 @@ func printVec(t *T, m []int) {
 func printStrings(t *T, m []string) {
 	l := len(m);
 	if l == 0 {
-		t.Log("\t<no match>");
+		t.Log("\t<no match>")
 	} else {
 		for i := 0; i < l; i = i+2 {
-			t.Logf("\t%q", m[i]);
+			t.Logf("\t%q", m[i])
 		}
 	}
 }
@@ -119,10 +119,10 @@ func printStrings(t *T, m []string) {
 func printBytes(t *T, b [][]byte) {
 	l := len(b);
 	if l == 0 {
-		t.Log("\t<no match>");
+		t.Log("\t<no match>")
 	} else {
 		for i := 0; i < l; i = i+2 {
-			t.Logf("\t%q", b[i]);
+			t.Logf("\t%q", b[i])
 		}
 	}
 }
@@ -130,11 +130,11 @@ func printBytes(t *T, b [][]byte) {
 func equal(m1, m2 []int) bool {
 	l := len(m1);
 	if l != len(m2) {
-		return false;
+		return false
 	}
 	for i := 0; i < l; i++ {
 		if m1[i] != m2[i] {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -143,11 +143,11 @@ func equal(m1, m2 []int) bool {
 func equalStrings(m1, m2 []string) bool {
 	l := len(m1);
 	if l != len(m2) {
-		return false;
+		return false
 	}
 	for i := 0; i < l; i++ {
 		if m1[i] != m2[i] {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -156,11 +156,11 @@ func equalStrings(m1, m2 []string) bool {
 func equalBytes(m1 [][]byte, m2 []string) bool {
 	l := len(m1);
 	if l != len(m2) {
-		return false;
+		return false
 	}
 	for i := 0; i < l; i++ {
 		if string(m1[i]) != m2[i] {
-			return false;
+			return false
 		}
 	}
 	return true;
@@ -169,7 +169,7 @@ func equalBytes(m1 [][]byte, m2 []string) bool {
 func executeTest(t *T, expr string, str string, match []int) {
 	re := compileTest(t, expr, "");
 	if re == nil {
-		return;
+		return
 	}
 	m := re.ExecuteString(str);
 	if !equal(m, match) {
@@ -190,13 +190,13 @@ func executeTest(t *T, expr string, str string, match []int) {
 
 func TestGoodCompile(t *T) {
 	for i := 0; i < len(good_re); i++ {
-		compileTest(t, good_re[i], "");
+		compileTest(t, good_re[i], "")
 	}
 }
 
 func TestBadCompile(t *T) {
 	for i := 0; i < len(bad_re); i++ {
-		compileTest(t, bad_re[i].re, bad_re[i].err);
+		compileTest(t, bad_re[i].re, bad_re[i].err)
 	}
 }
 
@@ -210,16 +210,16 @@ func TestExecute(t *T) {
 func matchTest(t *T, expr string, str string, match []int) {
 	re := compileTest(t, expr, "");
 	if re == nil {
-		return;
+		return
 	}
 	m := re.MatchString(str);
 	if m != (len(match) > 0) {
-		t.Error("MatchString failure on `", expr, "` matching `", str, "`:", m, "should be", len(match) > 0);
+		t.Error("MatchString failure on `", expr, "` matching `", str, "`:", m, "should be", len(match) > 0)
 	}
 	// now try bytes
 	m = re.Match(strings.Bytes(str));
 	if m != (len(match) > 0) {
-		t.Error("Match failure on `", expr, "` matching `", str, "`:", m, "should be", len(match) > 0);
+		t.Error("Match failure on `", expr, "` matching `", str, "`:", m, "should be", len(match) > 0)
 	}
 }
 
@@ -233,11 +233,11 @@ func TestMatch(t *T) {
 func matchStringsTest(t *T, expr string, str string, match []int) {
 	re := compileTest(t, expr, "");
 	if re == nil {
-		return;
+		return
 	}
 	strs := make([]string, len(match)/2);
 	for i := 0; i < len(match); i++ {
-		strs[i/2] = str[match[i]:match[i+1]];
+		strs[i/2] = str[match[i]:match[i+1]]
 	}
 	m := re.MatchStrings(str);
 	if !equalStrings(m, strs) {
@@ -266,10 +266,10 @@ func TestMatchStrings(t *T) {
 func matchFunctionTest(t *T, expr string, str string, match []int) {
 	m, err := MatchString(expr, str);
 	if err == "" {
-		return;
+		return
 	}
 	if m != (len(match) > 0) {
-		t.Error("function Match failure on `", expr, "` matching `", str, "`:", m, "should be", len(match) > 0);
+		t.Error("function Match failure on `", expr, "` matching `", str, "`:", m, "should be", len(match) > 0)
 	}
 }
 
diff --git a/src/pkg/testing/script/script.go b/src/pkg/testing/script/script.go
index 6bf6ca26fb..623685efd5 100644
--- a/src/pkg/testing/script/script.go
+++ b/src/pkg/testing/script/script.go
@@ -43,7 +43,7 @@ type sendAction interface {
 func (e Event) isReady() bool {
 	for _, predecessor := range e.predecessors {
 		if !predecessor.occurred {
-			return false;
+			return false
 		}
 	}
 
@@ -66,7 +66,7 @@ func (r Recv) getChannel() interface{}	{ return r.Channel }
 func (r Recv) recvMatch(chanEvent interface{}) bool {
 	c, ok := chanEvent.(channelRecv);
 	if !ok || c.channel != r.Channel {
-		return false;
+		return false
 	}
 
 	return reflect.DeepEqual(c.value, r.Expected);
@@ -88,7 +88,7 @@ func (r RecvMatch) getChannel() interface{}	{ return r.Channel }
 func (r RecvMatch) recvMatch(chanEvent interface{}) bool {
 	c, ok := chanEvent.(channelRecv);
 	if !ok || c.channel != r.Channel {
-		return false;
+		return false
 	}
 
 	return r.Match(c.value);
@@ -110,7 +110,7 @@ func (r Closed) getChannel() interface{}	{ return r.Channel }
 func (r Closed) recvMatch(chanEvent interface{}) bool {
 	c, ok := chanEvent.(channelClosed);
 	if !ok || c.channel != r.Channel {
-		return false;
+		return false
 	}
 
 	return true;
@@ -130,7 +130,7 @@ func (s Send) getSend() sendAction	{ return s }
 func (s Send) getChannel() interface{}	{ return s.Channel }
 
 func newEmptyInterface(args ...) reflect.Value {
-	return reflect.NewValue(args).(*reflect.StructValue).Field(0);
+	return reflect.NewValue(args).(*reflect.StructValue).Field(0)
 }
 
 func (s Send) send() {
@@ -140,9 +140,9 @@ func (s Send) send() {
 	c := reflect.NewValue(s.Channel).(*reflect.ChanValue);
 	var v reflect.Value;
 	if iface, ok := c.Type().(*reflect.ChanType).Elem().(*reflect.InterfaceType); ok && iface.NumMethod() == 0 {
-		v = newEmptyInterface(s.Value);
+		v = newEmptyInterface(s.Value)
 	} else {
-		v = reflect.NewValue(s.Value);
+		v = reflect.NewValue(s.Value)
 	}
 	c.Send(v);
 }
@@ -170,7 +170,7 @@ type ReceivedUnexpected struct {
 func (r ReceivedUnexpected) String() string {
 	names := make([]string, len(r.ready));
 	for i, v := range r.ready {
-		names[i] = v.name;
+		names[i] = v.name
 	}
 	return fmt.Sprintf("received unexpected value on one of the channels: %#v. Runnable events: %s", r.Value, strings.Join(names, ", "));
 }
@@ -224,23 +224,23 @@ func Perform(seed int64, events []*Event) (err os.Error) {
 
 	channels, err := getChannels(events);
 	if err != nil {
-		return;
+		return
 	}
 	multiplex := make(chan interface{});
 	for _, channel := range channels {
-		go recvValues(multiplex, channel);
+		go recvValues(multiplex, channel)
 	}
 
 Outer:
 	for {
 		ready, err := readyEvents(events);
 		if err != nil {
-			return err;
+			return err
 		}
 
 		if len(ready) == 0 {
 			// All events occurred.
-			break;
+			break
 		}
 
 		event := ready[r.Intn(len(ready))];
@@ -271,11 +271,11 @@ func getChannels(events []*Event) ([]interface{}, os.Error) {
 	j := 0;
 	for _, event := range events {
 		if recv := event.action.getRecv(); recv == nil {
-			continue;
+			continue
 		}
 		c := event.action.getChannel();
 		if _, ok := reflect.NewValue(c).(*reflect.ChanValue); !ok {
-			return nil, SetupError("one of the channel values is not a channel");
+			return nil, SetupError("one of the channel values is not a channel")
 		}
 
 		duplicate := false;
@@ -329,7 +329,7 @@ func readyEvents(events []*Event) ([]*Event, os.Error) {
 	eventsWaiting := false;
 	for _, event := range events {
 		if event.occurred {
-			continue;
+			continue
 		}
 
 		eventsWaiting = true;
@@ -343,7 +343,7 @@ func readyEvents(events []*Event) ([]*Event, os.Error) {
 		names := make([]string, len(events));
 		for _, event := range events {
 			if event.occurred {
-				continue;
+				continue
 			}
 			names[j] = event.name;
 		}
diff --git a/src/pkg/testing/script/script_test.go b/src/pkg/testing/script/script_test.go
index a1c6f28a72..359218c603 100644
--- a/src/pkg/testing/script/script_test.go
+++ b/src/pkg/testing/script/script_test.go
@@ -11,7 +11,7 @@ import (
 func TestNoop(t *testing.T) {
 	err := Perform(0, nil);
 	if err != nil {
-		t.Errorf("Got error: %s", err);
+		t.Errorf("Got error: %s", err)
 	}
 }
 
@@ -24,7 +24,7 @@ func TestSimple(t *testing.T) {
 
 	err := Perform(0, []*Event{a, b});
 	if err != nil {
-		t.Errorf("Got error: %s", err);
+		t.Errorf("Got error: %s", err)
 	}
 }
 
@@ -37,9 +37,9 @@ func TestFail(t *testing.T) {
 
 	err := Perform(0, []*Event{a, b});
 	if err == nil {
-		t.Errorf("Failed to get expected error");
+		t.Errorf("Failed to get expected error")
 	} else if _, ok := err.(ReceivedUnexpected); !ok {
-		t.Errorf("Error returned was of the wrong type: %s", err);
+		t.Errorf("Error returned was of the wrong type: %s", err)
 	}
 }
 
@@ -51,13 +51,13 @@ func TestClose(t *testing.T) {
 
 	err := Perform(0, []*Event{a, b});
 	if err != nil {
-		t.Errorf("Got error: %s", err);
+		t.Errorf("Got error: %s", err)
 	}
 }
 
 func matchOne(v interface{}) bool {
 	if i, ok := v.(int); ok && i == 1 {
-		return true;
+		return true
 	}
 	return false;
 }
@@ -70,6 +70,6 @@ func TestRecvMatch(t *testing.T) {
 
 	err := Perform(0, []*Event{a, b});
 	if err != nil {
-		t.Errorf("Got error: %s", err);
+		t.Errorf("Got error: %s", err)
 	}
 }
diff --git a/src/pkg/testing/testing.go b/src/pkg/testing/testing.go
index b04e8d40cc..62c79e0b32 100644
--- a/src/pkg/testing/testing.go
+++ b/src/pkg/testing/testing.go
@@ -32,7 +32,7 @@ func tabify(s string) string {
 	}
 	for i := 0; i < n-1; i++ {	// -1 to avoid final newline
 		if s[i] == '\n' {
-			return s[0 : i+1]+"\t"+tabify(s[i+1 : n]);
+			return s[0 : i+1]+"\t"+tabify(s[i+1 : n])
 		}
 	}
 	return s;
@@ -67,7 +67,7 @@ func (t *T) Log(args ...)	{ t.errors += "\t"+tabify(fmt.Sprintln(args)) }
 // Log formats its arguments according to the format, analogous to Printf(),
 // and records the text in the error log.
 func (t *T) Logf(format string, args ...) {
-	t.errors += "\t"+tabify(fmt.Sprintf(format, args));
+	t.errors += "\t"+tabify(fmt.Sprintf(format, args))
 }
 
 // Error is equivalent to Log() followed by Fail().
@@ -112,7 +112,7 @@ func Main(tests []Test) {
 	flag.Parse();
 	ok := true;
 	if len(tests) == 0 {
-		println("testing: warning: no tests to run");
+		println("testing: warning: no tests to run")
 	}
 	re, err := CompileRegexp(*match);
 	if err != "" {
@@ -121,10 +121,10 @@ func Main(tests []Test) {
 	}
 	for i := 0; i < len(tests); i++ {
 		if !re.MatchString(tests[i].Name) {
-			continue;
+			continue
 		}
 		if *chatty {
-			println("=== RUN ", tests[i].Name);
+			println("=== RUN ", tests[i].Name)
 		}
 		t := new(T);
 		t.ch = make(chan *T);
diff --git a/src/pkg/time/tick.go b/src/pkg/time/tick.go
index 771fc9f7e5..ec526be2ab 100644
--- a/src/pkg/time/tick.go
+++ b/src/pkg/time/tick.go
@@ -40,17 +40,17 @@ func (t *Ticker) ticker(c chan<- int64) {
 		// if c <- now took too long, skip ahead
 		if when < now {
 			// one big step
-			when += (now-when) / t.ns * t.ns;
+			when += (now-when) / t.ns * t.ns
 		}
 		for when <= now {
 			// little steps until when > now
-			when += t.ns;
+			when += t.ns
 		}
 
 		Sleep(when-now);
 		now = Nanoseconds();
 		if t.shutdown {
-			return;
+			return
 		}
 		c <- now;
 	}
@@ -60,7 +60,7 @@ func (t *Ticker) ticker(c chan<- int64) {
 // channel only.  Useful for clients that have no need to shut down the ticker.
 func Tick(ns int64) <-chan int64 {
 	if ns <= 0 {
-		return nil;
+		return nil
 	}
 	return NewTicker(ns).C;
 }
@@ -70,7 +70,7 @@ func Tick(ns int64) <-chan int64 {
 // intervals to make up for pauses in delivery of the ticks.
 func NewTicker(ns int64) *Ticker {
 	if ns <= 0 {
-		return nil;
+		return nil
 	}
 	c := make(chan int64);
 	t := &Ticker{c, ns, false};
diff --git a/src/pkg/time/tick_test.go b/src/pkg/time/tick_test.go
index 5694a76090..124c13a531 100644
--- a/src/pkg/time/tick_test.go
+++ b/src/pkg/time/tick_test.go
@@ -17,7 +17,7 @@ func TestTicker(t *testing.T) {
 	ticker := NewTicker(Delta);
 	t0 := Nanoseconds();
 	for i := 0; i < Count; i++ {
-		<-ticker.C;
+		<-ticker.C
 	}
 	ticker.Stop();
 	t1 := Nanoseconds();
@@ -25,12 +25,12 @@ func TestTicker(t *testing.T) {
 	target := int64(Delta*Count);
 	slop := target*2/10;
 	if ns < target-slop || ns > target+slop {
-		t.Fatalf("%d ticks of %g ns took %g ns, expected %g", Count, float64(Delta), float64(ns), float64(target));
+		t.Fatalf("%d ticks of %g ns took %g ns, expected %g", Count, float64(Delta), float64(ns), float64(target))
 	}
 	// Now test that the ticker stopped
 	Sleep(2*Delta);
 	_, received := <-ticker.C;
 	if received {
-		t.Fatalf("Ticker did not shut down");
+		t.Fatalf("Ticker did not shut down")
 	}
 }
diff --git a/src/pkg/time/time.go b/src/pkg/time/time.go
index 72cd348221..ea1941c138 100644
--- a/src/pkg/time/time.go
+++ b/src/pkg/time/time.go
@@ -15,7 +15,7 @@ import (
 func Seconds() int64 {
 	sec, _, err := os.Time();
 	if err != nil {
-		panic("time: os.Time: ", err.String());
+		panic("time: os.Time: ", err.String())
 	}
 	return sec;
 }
@@ -25,7 +25,7 @@ func Seconds() int64 {
 func Nanoseconds() int64 {
 	sec, nsec, err := os.Time();
 	if err != nil {
-		panic("time: os.Time: ", err.String());
+		panic("time: os.Time: ", err.String())
 	}
 	return sec*1e9 + nsec;
 }
@@ -56,7 +56,7 @@ var leapyear = []int{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
 
 func months(year int64) []int {
 	if year%4 == 0 && (year%100 != 0 || year%400 == 0) {
-		return leapyear;
+		return leapyear
 	}
 	return nonleapyear;
 }
@@ -90,7 +90,7 @@ func SecondsToUTC(sec int64) *Time {
 	// Day 0 = January 1, 1970 was a Thursday
 	t.Weekday = int((day+Thursday)%7);
 	if t.Weekday < 0 {
-		t.Weekday += 7;
+		t.Weekday += 7
 	}
 
 	// Change day from 0 = 1970 to 0 = 2001,
@@ -135,7 +135,7 @@ func SecondsToUTC(sec int64) *Time {
 	var m int;
 	yday := int(day);
 	for m = 0; m < 12 && yday >= months[m]; m++ {
-		yday -= months[m];
+		yday -= months[m]
 	}
 	t.Month = m+1;
 	t.Day = yday+1;
@@ -199,7 +199,7 @@ func (t *Time) Seconds() int64 {
 	// Add in days this year.
 	months := months(t.Year);
 	for m := 0; m < t.Month - 1; m++ {
-		day += int64(months[m]);
+		day += int64(months[m])
 	}
 	day += int64(t.Day - 1);
 
@@ -257,13 +257,13 @@ var shortMonthNames = []string{
 
 func copy(dst []byte, s string) {
 	for i := 0; i < len(s); i++ {
-		dst[i] = s[i];
+		dst[i] = s[i]
 	}
 }
 
 func decimal(dst []byte, n int) {
 	if n < 0 {
-		n = 0;
+		n = 0
 	}
 	for i := len(dst)-1; i >= 0; i-- {
 		dst[i] = byte(n%10 + '0');
@@ -288,17 +288,17 @@ func format(t *Time, fmt string) string {
 			i++;
 			switch fmt[i] {
 			case 'A':	// %A full weekday name
-				bp = addString(buf, bp, longDayNames[t.Weekday]);
+				bp = addString(buf, bp, longDayNames[t.Weekday])
 			case 'a':	// %a abbreviated weekday name
-				bp = addString(buf, bp, shortDayNames[t.Weekday]);
+				bp = addString(buf, bp, shortDayNames[t.Weekday])
 			case 'b':	// %b abbreviated month name
-				bp = addString(buf, bp, shortMonthNames[t.Month]);
+				bp = addString(buf, bp, shortMonthNames[t.Month])
 			case 'd':	// %d day of month (01-31)
 				decimal(buf[bp : bp+2], t.Day);
 				bp += 2;
 			case 'e':	// %e day of month ( 1-31)
 				if t.Day >= 10 {
-					decimal(buf[bp : bp+2], t.Day);
+					decimal(buf[bp : bp+2], t.Day)
 				} else {
 					buf[bp] = ' ';
 					buf[bp+1] = byte(t.Day + '0');
@@ -320,7 +320,7 @@ func format(t *Time, fmt string) string {
 				decimal(buf[bp : bp+2], int(t.Year % 100));
 				bp += 2;
 			case 'Z':
-				bp = addString(buf, bp, t.Zone);
+				bp = addString(buf, bp, t.Zone)
 			default:
 				buf[bp] = '%';
 				buf[bp+1] = fmt[i];
diff --git a/src/pkg/time/time_test.go b/src/pkg/time/time_test.go
index 5d9d7c27eb..93ddcee348 100644
--- a/src/pkg/time/time_test.go
+++ b/src/pkg/time/time_test.go
@@ -14,7 +14,7 @@ func init() {
 	// Force US Pacific time for daylight-savings
 	// tests below (localtests).  Needs to be set
 	// before the first call into the time library.
-	os.Setenv("TZ", "US/Pacific");
+	os.Setenv("TZ", "US/Pacific")
 }
 
 type TimeTest struct {
@@ -46,7 +46,7 @@ func same(t, u *Time) bool {
 		t.Second == u.Second &&
 		t.Weekday == u.Weekday &&
 		t.ZoneOffset == u.ZoneOffset &&
-		t.Zone == u.Zone;
+		t.Zone == u.Zone
 }
 
 func TestSecondsToUTC(t *testing.T) {
@@ -56,7 +56,7 @@ func TestSecondsToUTC(t *testing.T) {
 		tm := SecondsToUTC(sec);
 		newsec := tm.Seconds();
 		if newsec != sec {
-			t.Errorf("SecondsToUTC(%d).Seconds() = %d", sec, newsec);
+			t.Errorf("SecondsToUTC(%d).Seconds() = %d", sec, newsec)
 		}
 		if !same(tm, golden) {
 			t.Errorf("SecondsToUTC(%d):", sec);
@@ -73,7 +73,7 @@ func TestSecondsToLocalTime(t *testing.T) {
 		tm := SecondsToLocalTime(sec);
 		newsec := tm.Seconds();
 		if newsec != sec {
-			t.Errorf("SecondsToLocalTime(%d).Seconds() = %d", sec, newsec);
+			t.Errorf("SecondsToLocalTime(%d).Seconds() = %d", sec, newsec)
 		}
 		if !same(tm, golden) {
 			t.Errorf("SecondsToLocalTime(%d):", sec);
diff --git a/src/pkg/time/zoneinfo.go b/src/pkg/time/zoneinfo.go
index 86f185dada..8e66e0ca66 100644
--- a/src/pkg/time/zoneinfo.go
+++ b/src/pkg/time/zoneinfo.go
@@ -61,7 +61,7 @@ func (d *data) byte() (n byte, ok bool) {
 func byteString(p []byte) string {
 	for i := 0; i < len(p); i++ {
 		if p[i] == 0 {
-			return string(p[0:i]);
+			return string(p[0:i])
 		}
 	}
 	return string(p);
@@ -85,13 +85,13 @@ func parseinfo(bytes []byte) (zt []zonetime, ok bool) {
 
 	// 4-byte magic "TZif"
 	if magic := d.read(4); string(magic) != "TZif" {
-		return nil, false;
+		return nil, false
 	}
 
 	// 1-byte version, then 15 bytes of padding
 	var p []byte;
 	if p = d.read(16); len(p) != 16 || p[0] != 0 && p[0] != '2' {
-		return nil, false;
+		return nil, false
 	}
 
 	// six big-endian 32-bit integers:
@@ -113,7 +113,7 @@ func parseinfo(bytes []byte) (zt []zonetime, ok bool) {
 	for i := 0; i < 6; i++ {
 		nn, ok := d.big4();
 		if !ok {
-			return nil, false;
+			return nil, false
 		}
 		n[i] = int(nn);
 	}
@@ -142,7 +142,7 @@ func parseinfo(bytes []byte) (zt []zonetime, ok bool) {
 	isutc := d.read(n[NUTCLocal]);
 
 	if d.error {	// ran out of data
-		return nil, false;
+		return nil, false
 	}
 
 	// If version == 2, the entire file repeats, this time using
@@ -157,16 +157,16 @@ func parseinfo(bytes []byte) (zt []zonetime, ok bool) {
 		var ok bool;
 		var n uint32;
 		if n, ok = zonedata.big4(); !ok {
-			return nil, false;
+			return nil, false
 		}
 		z[i].utcoff = int(n);
 		var b byte;
 		if b, ok = zonedata.byte(); !ok {
-			return nil, false;
+			return nil, false
 		}
 		z[i].isdst = b != 0;
 		if b, ok = zonedata.byte(); !ok || int(b) >= len(abbrev) {
-			return nil, false;
+			return nil, false
 		}
 		z[i].name = byteString(abbrev[b:len(abbrev)]);
 	}
@@ -177,18 +177,18 @@ func parseinfo(bytes []byte) (zt []zonetime, ok bool) {
 		var ok bool;
 		var n uint32;
 		if n, ok = txtimes.big4(); !ok {
-			return nil, false;
+			return nil, false
 		}
 		zt[i].time = int32(n);
 		if int(txzones[i]) >= len(z) {
-			return nil, false;
+			return nil, false
 		}
 		zt[i].zone = &z[txzones[i]];
 		if i < len(isstd) {
-			zt[i].isstd = isstd[i] != 0;
+			zt[i].isstd = isstd[i] != 0
 		}
 		if i < len(isutc) {
-			zt[i].isutc = isutc[i] != 0;
+			zt[i].isutc = isutc[i] != 0
 		}
 	}
 	return zt, true;
@@ -197,7 +197,7 @@ func parseinfo(bytes []byte) (zt []zonetime, ok bool) {
 func readinfofile(name string) ([]zonetime, bool) {
 	buf, err := io.ReadFile(name);
 	if err != nil {
-		return nil, false;
+		return nil, false
 	}
 	return parseinfo(buf);
 }
@@ -213,9 +213,9 @@ func setupZone() {
 	tz, err := os.Getenverror("TZ");
 	switch {
 	case err == os.ENOENV:
-		zones, _ = readinfofile("/etc/localtime");
+		zones, _ = readinfofile("/etc/localtime")
 	case len(tz) > 0:
-		zones, _ = readinfofile(zoneDir+tz);
+		zones, _ = readinfofile(zoneDir+tz)
 	case len(tz) == 0:
 		// do nothing: use UTC
 	}
@@ -224,7 +224,7 @@ func setupZone() {
 func lookupTimezone(sec int64) (zone string, offset int) {
 	once.Do(setupZone);
 	if len(zones) == 0 {
-		return "UTC", 0;
+		return "UTC", 0
 	}
 
 	// Binary search for entry with largest time <= sec
@@ -232,9 +232,9 @@ func lookupTimezone(sec int64) (zone string, offset int) {
 	for len(tz) > 1 {
 		m := len(tz)/2;
 		if sec < int64(tz[m].time) {
-			tz = tz[0:m];
+			tz = tz[0:m]
 		} else {
-			tz = tz[m:len(tz)];
+			tz = tz[m:len(tz)]
 		}
 	}
 	z := tz[0].zone;
diff --git a/src/pkg/unicode/digit.go b/src/pkg/unicode/digit.go
index 5518c06df6..b12ada2d63 100644
--- a/src/pkg/unicode/digit.go
+++ b/src/pkg/unicode/digit.go
@@ -7,7 +7,7 @@ package unicode
 // IsDigit reports whether the rune is a decimal digit.
 func IsDigit(rune int) bool {
 	if rune < 0x100 {	// quick ASCII (Latin-1, really) check
-		return '0' <= rune && rune <= '9';
+		return '0' <= rune && rune <= '9'
 	}
 	return Is(Digit, rune);
 }
diff --git a/src/pkg/unicode/digit_test.go b/src/pkg/unicode/digit_test.go
index 3d46af548c..3031eafc87 100644
--- a/src/pkg/unicode/digit_test.go
+++ b/src/pkg/unicode/digit_test.go
@@ -106,12 +106,12 @@ var testLetter = []int{
 func TestDigit(t *testing.T) {
 	for _, r := range testDigit {
 		if !IsDigit(r) {
-			t.Errorf("IsDigit(U+%04X) = false, want true\n", r);
+			t.Errorf("IsDigit(U+%04X) = false, want true\n", r)
 		}
 	}
 	for _, r := range testLetter {
 		if IsDigit(r) {
-			t.Errorf("IsDigit(U+%04X) = true, want false\n", r);
+			t.Errorf("IsDigit(U+%04X) = true, want false\n", r)
 		}
 	}
 }
@@ -120,7 +120,7 @@ func TestDigit(t *testing.T) {
 func TestDigitOptimization(t *testing.T) {
 	for i := 0; i < 0x100; i++ {
 		if Is(Digit, i) != IsDigit(i) {
-			t.Errorf("IsDigit(U+%04X) disagrees with Is(Digit)", i);
+			t.Errorf("IsDigit(U+%04X) disagrees with Is(Digit)", i)
 		}
 	}
 }
diff --git a/src/pkg/unicode/letter.go b/src/pkg/unicode/letter.go
index 571b3b4548..f44ce56398 100644
--- a/src/pkg/unicode/letter.go
+++ b/src/pkg/unicode/letter.go
@@ -57,10 +57,10 @@ func Is(ranges []Range, rune int) bool {
 	if rune < 0x100 {
 		for _, r := range ranges {
 			if rune > r.Hi {
-				continue;
+				continue
 			}
 			if rune < r.Lo {
-				return false;
+				return false
 			}
 			return (rune - r.Lo) % r.Stride == 0;
 		}
@@ -74,12 +74,12 @@ func Is(ranges []Range, rune int) bool {
 		m := lo + (hi-lo)/2;
 		r := ranges[m];
 		if r.Lo <= rune && rune <= r.Hi {
-			return (rune - r.Lo) % r.Stride == 0;
+			return (rune - r.Lo) % r.Stride == 0
 		}
 		if rune < r.Lo {
-			hi = m;
+			hi = m
 		} else {
-			lo = m+1;
+			lo = m+1
 		}
 	}
 	return false;
@@ -88,7 +88,7 @@ func Is(ranges []Range, rune int) bool {
 // IsUpper reports whether the rune is an upper case letter.
 func IsUpper(rune int) bool {
 	if rune < 0x80 {	// quick ASCII check
-		return 'A' <= rune && rune <= 'Z';
+		return 'A' <= rune && rune <= 'Z'
 	}
 	return Is(Upper, rune);
 }
@@ -96,7 +96,7 @@ func IsUpper(rune int) bool {
 // IsLower reports whether the rune is a lower case letter.
 func IsLower(rune int) bool {
 	if rune < 0x80 {	// quick ASCII check
-		return 'a' <= rune && rune <= 'z';
+		return 'a' <= rune && rune <= 'z'
 	}
 	return Is(Lower, rune);
 }
@@ -104,7 +104,7 @@ func IsLower(rune int) bool {
 // IsTitle reports whether the rune is a title case letter.
 func IsTitle(rune int) bool {
 	if rune < 0x80 {	// quick ASCII check
-		return false;
+		return false
 	}
 	return Is(Title, rune);
 }
@@ -123,7 +123,7 @@ func IsSpace(rune int) bool {
 	if rune <= 0xFF {	// quick Latin-1 check
 		switch rune {
 		case '\t', '\n', '\v', '\f', '\r', ' ', 0x85, 0xA0:
-			return true;
+			return true
 		}
 		return false;
 	}
@@ -133,7 +133,7 @@ func IsSpace(rune int) bool {
 // To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase
 func To(_case int, rune int) int {
 	if _case < 0 || MaxCase <= _case {
-		return ReplacementChar;	// as reasonable an error as any
+		return ReplacementChar	// as reasonable an error as any
 	}
 	// binary search over ranges
 	lo := 0;
@@ -154,14 +154,14 @@ func To(_case int, rune int) int {
 				// bit in the sequence offset.
 				// The constants UpperCase and TitleCase are even while LowerCase
 				// is odd so we take the low bit from _case.
-				return r.Lo + ((rune - r.Lo)&^1 | _case&1);
+				return r.Lo + ((rune - r.Lo)&^1 | _case&1)
 			}
 			return rune+delta;
 		}
 		if rune < r.Lo {
-			hi = m;
+			hi = m
 		} else {
-			lo = m+1;
+			lo = m+1
 		}
 	}
 	return rune;
@@ -171,7 +171,7 @@ func To(_case int, rune int) int {
 func ToUpper(rune int) int {
 	if rune < 0x80 {	// quick ASCII check
 		if 'a' <= rune && rune <= 'z' {
-			rune -= 'a'-'A';
+			rune -= 'a'-'A'
 		}
 		return rune;
 	}
@@ -182,7 +182,7 @@ func ToUpper(rune int) int {
 func ToLower(rune int) int {
 	if rune < 0x80 {	// quick ASCII check
 		if 'A' <= rune && rune <= 'Z' {
-			rune += 'a'-'A';
+			rune += 'a'-'A'
 		}
 		return rune;
 	}
@@ -193,7 +193,7 @@ func ToLower(rune int) int {
 func ToTitle(rune int) int {
 	if rune < 0x80 {	// quick ASCII check
 		if 'a' <= rune && rune <= 'z' {	// title case is upper case for ASCII
-			rune -= 'a'-'A';
+			rune -= 'a'-'A'
 		}
 		return rune;
 	}
diff --git a/src/pkg/unicode/letter_test.go b/src/pkg/unicode/letter_test.go
index f513681de7..3b10caedd1 100644
--- a/src/pkg/unicode/letter_test.go
+++ b/src/pkg/unicode/letter_test.go
@@ -216,17 +216,17 @@ var caseTest = []caseT{
 func TestIsLetter(t *testing.T) {
 	for _, r := range upperTest {
 		if !IsLetter(r) {
-			t.Errorf("IsLetter(U+%04X) = false, want true\n", r);
+			t.Errorf("IsLetter(U+%04X) = false, want true\n", r)
 		}
 	}
 	for _, r := range letterTest {
 		if !IsLetter(r) {
-			t.Errorf("IsLetter(U+%04X) = false, want true\n", r);
+			t.Errorf("IsLetter(U+%04X) = false, want true\n", r)
 		}
 	}
 	for _, r := range notletterTest {
 		if IsLetter(r) {
-			t.Errorf("IsLetter(U+%04X) = true, want false\n", r);
+			t.Errorf("IsLetter(U+%04X) = true, want false\n", r)
 		}
 	}
 }
@@ -234,17 +234,17 @@ func TestIsLetter(t *testing.T) {
 func TestIsUpper(t *testing.T) {
 	for _, r := range upperTest {
 		if !IsUpper(r) {
-			t.Errorf("IsUpper(U+%04X) = false, want true\n", r);
+			t.Errorf("IsUpper(U+%04X) = false, want true\n", r)
 		}
 	}
 	for _, r := range notupperTest {
 		if IsUpper(r) {
-			t.Errorf("IsUpper(U+%04X) = true, want false\n", r);
+			t.Errorf("IsUpper(U+%04X) = true, want false\n", r)
 		}
 	}
 	for _, r := range notletterTest {
 		if IsUpper(r) {
-			t.Errorf("IsUpper(U+%04X) = true, want false\n", r);
+			t.Errorf("IsUpper(U+%04X) = true, want false\n", r)
 		}
 	}
 }
@@ -252,11 +252,11 @@ func TestIsUpper(t *testing.T) {
 func caseString(c int) string {
 	switch c {
 	case UpperCase:
-		return "UpperCase";
+		return "UpperCase"
 	case LowerCase:
-		return "LowerCase";
+		return "LowerCase"
 	case TitleCase:
-		return "TitleCase";
+		return "TitleCase"
 	}
 	return "ErrorCase";
 }
@@ -265,7 +265,7 @@ func TestTo(t *testing.T) {
 	for _, c := range caseTest {
 		r := To(c.cas, c.in);
 		if c.out != r {
-			t.Errorf("To(U+%04X, %s) = U+%04X want U+%04X\n", c.in, caseString(c.cas), r, c.out);
+			t.Errorf("To(U+%04X, %s) = U+%04X want U+%04X\n", c.in, caseString(c.cas), r, c.out)
 		}
 	}
 }
@@ -273,11 +273,11 @@ func TestTo(t *testing.T) {
 func TestToUpperCase(t *testing.T) {
 	for _, c := range caseTest {
 		if c.cas != UpperCase {
-			continue;
+			continue
 		}
 		r := ToUpper(c.in);
 		if c.out != r {
-			t.Errorf("ToUpper(U+%04X) = U+%04X want U+%04X\n", c.in, r, c.out);
+			t.Errorf("ToUpper(U+%04X) = U+%04X want U+%04X\n", c.in, r, c.out)
 		}
 	}
 }
@@ -285,11 +285,11 @@ func TestToUpperCase(t *testing.T) {
 func TestToLowerCase(t *testing.T) {
 	for _, c := range caseTest {
 		if c.cas != LowerCase {
-			continue;
+			continue
 		}
 		r := ToLower(c.in);
 		if c.out != r {
-			t.Errorf("ToLower(U+%04X) = U+%04X want U+%04X\n", c.in, r, c.out);
+			t.Errorf("ToLower(U+%04X) = U+%04X want U+%04X\n", c.in, r, c.out)
 		}
 	}
 }
@@ -297,11 +297,11 @@ func TestToLowerCase(t *testing.T) {
 func TestToTitleCase(t *testing.T) {
 	for _, c := range caseTest {
 		if c.cas != TitleCase {
-			continue;
+			continue
 		}
 		r := ToTitle(c.in);
 		if c.out != r {
-			t.Errorf("ToTitle(U+%04X) = U+%04X want U+%04X\n", c.in, r, c.out);
+			t.Errorf("ToTitle(U+%04X) = U+%04X want U+%04X\n", c.in, r, c.out)
 		}
 	}
 }
@@ -309,12 +309,12 @@ func TestToTitleCase(t *testing.T) {
 func TestIsSpace(t *testing.T) {
 	for _, c := range spaceTest {
 		if !IsSpace(c) {
-			t.Errorf("IsSpace(U+%04X) = false; want true", c);
+			t.Errorf("IsSpace(U+%04X) = false; want true", c)
 		}
 	}
 	for _, c := range letterTest {
 		if IsSpace(c) {
-			t.Errorf("IsSpace(U+%04X) = true; want false", c);
+			t.Errorf("IsSpace(U+%04X) = true; want false", c)
 		}
 	}
 }
@@ -324,28 +324,28 @@ func TestIsSpace(t *testing.T) {
 func TestLetterOptimizations(t *testing.T) {
 	for i := 0; i < 0x100; i++ {
 		if Is(Letter, i) != IsLetter(i) {
-			t.Errorf("IsLetter(U+%04X) disagrees with Is(Letter)", i);
+			t.Errorf("IsLetter(U+%04X) disagrees with Is(Letter)", i)
 		}
 		if Is(Upper, i) != IsUpper(i) {
-			t.Errorf("IsUpper(U+%04X) disagrees with Is(Upper)", i);
+			t.Errorf("IsUpper(U+%04X) disagrees with Is(Upper)", i)
 		}
 		if Is(Lower, i) != IsLower(i) {
-			t.Errorf("IsLower(U+%04X) disagrees with Is(Lower)", i);
+			t.Errorf("IsLower(U+%04X) disagrees with Is(Lower)", i)
 		}
 		if Is(Title, i) != IsTitle(i) {
-			t.Errorf("IsTitle(U+%04X) disagrees with Is(Title)", i);
+			t.Errorf("IsTitle(U+%04X) disagrees with Is(Title)", i)
 		}
 		if Is(White_Space, i) != IsSpace(i) {
-			t.Errorf("IsSpace(U+%04X) disagrees with Is(White_Space)", i);
+			t.Errorf("IsSpace(U+%04X) disagrees with Is(White_Space)", i)
 		}
 		if To(UpperCase, i) != ToUpper(i) {
-			t.Errorf("ToUpper(U+%04X) disagrees with To(Upper)", i);
+			t.Errorf("ToUpper(U+%04X) disagrees with To(Upper)", i)
 		}
 		if To(LowerCase, i) != ToLower(i) {
-			t.Errorf("ToLower(U+%04X) disagrees with To(Lower)", i);
+			t.Errorf("ToLower(U+%04X) disagrees with To(Lower)", i)
 		}
 		if To(TitleCase, i) != ToTitle(i) {
-			t.Errorf("ToTitle(U+%04X) disagrees with To(Title)", i);
+			t.Errorf("ToTitle(U+%04X) disagrees with To(Title)", i)
 		}
 	}
 }
diff --git a/src/pkg/unicode/maketables.go b/src/pkg/unicode/maketables.go
index fddbfd7ea8..70010ca960 100644
--- a/src/pkg/unicode/maketables.go
+++ b/src/pkg/unicode/maketables.go
@@ -141,23 +141,23 @@ const (
 func parseCategory(line string) (state State) {
 	field := strings.Split(line, ";", -1);
 	if len(field) != NumField {
-		die.Logf("%5s: %d fields (expected %d)\n", line, len(field), NumField);
+		die.Logf("%5s: %d fields (expected %d)\n", line, len(field), NumField)
 	}
 	point, err := strconv.Btoui64(field[FCodePoint], 16);
 	if err != nil {
-		die.Log("%.5s...:", err);
+		die.Log("%.5s...:", err)
 	}
 	lastChar = uint32(point);
 	if point == 0 {
-		return;	// not interesting and we use 0 as unset
+		return	// not interesting and we use 0 as unset
 	}
 	if point > MaxChar {
-		return;
+		return
 	}
 	char := &chars[point];
 	char.field = field;
 	if char.codePoint != 0 {
-		die.Logf("point U+%04x reused\n");
+		die.Logf("point U+%04x reused\n")
 	}
 	char.codePoint = lastChar;
 	char.category = field[FGeneralCategory];
@@ -167,22 +167,22 @@ func parseCategory(line string) (state State) {
 		// Decimal digit
 		_, err := strconv.Atoi(field[FNumericValue]);
 		if err != nil {
-			die.Log("U+%04x: bad numeric field: %s", point, err);
+			die.Log("U+%04x: bad numeric field: %s", point, err)
 		}
 	case "Lu":
-		char.letter(field[FCodePoint], field[FSimpleLowercaseMapping], field[FSimpleTitlecaseMapping]);
+		char.letter(field[FCodePoint], field[FSimpleLowercaseMapping], field[FSimpleTitlecaseMapping])
 	case "Ll":
-		char.letter(field[FSimpleUppercaseMapping], field[FCodePoint], field[FSimpleTitlecaseMapping]);
+		char.letter(field[FSimpleUppercaseMapping], field[FCodePoint], field[FSimpleTitlecaseMapping])
 	case "Lt":
-		char.letter(field[FSimpleUppercaseMapping], field[FSimpleLowercaseMapping], field[FCodePoint]);
+		char.letter(field[FSimpleUppercaseMapping], field[FSimpleLowercaseMapping], field[FCodePoint])
 	case "Lm", "Lo":
-		char.letter(field[FSimpleUppercaseMapping], field[FSimpleLowercaseMapping], field[FSimpleTitlecaseMapping]);
+		char.letter(field[FSimpleUppercaseMapping], field[FSimpleLowercaseMapping], field[FSimpleTitlecaseMapping])
 	}
 	switch {
 	case strings.Index(field[FName], ", First>") > 0:
-		state = SFirst;
+		state = SFirst
 	case strings.Index(field[FName], ", Last>") > 0:
-		state = SLast;
+		state = SLast
 	}
 	return;
 }
@@ -190,7 +190,7 @@ func parseCategory(line string) (state State) {
 func (char *Char) dump(s string) {
 	fmt.Print(s, " ");
 	for i := 0; i < len(char.field); i++ {
-		fmt.Printf("%s:%q ", fieldName[i], char.field[i]);
+		fmt.Printf("%s:%q ", fieldName[i], char.field[i])
 	}
 	fmt.Print("\n");
 }
@@ -203,7 +203,7 @@ func (char *Char) letter(u, l, t string) {
 
 func (char *Char) letterValue(s string, cas string) int {
 	if s == "" {
-		return 0;
+		return 0
 	}
 	v, err := strconv.Btoui64(s, 16);
 	if err != nil {
@@ -239,7 +239,7 @@ func version() string {
 	fields := strings.Split(*url, "/", 0);
 	for _, f := range fields {
 		if len(f) > 0 && '0' <= f[0] && f[0] <= '9' {
-			return f;
+			return f
 		}
 	}
 	die.Log("unknown version");
@@ -249,21 +249,21 @@ func version() string {
 func letterOp(code int) bool {
 	switch chars[code].category {
 	case "Lu", "Ll", "Lt", "Lm", "Lo":
-		return true;
+		return true
 	}
 	return false;
 }
 
 func loadChars() {
 	if *dataURL == "" {
-		flag.Set("data", *url + "UnicodeData.txt");
+		flag.Set("data", *url + "UnicodeData.txt")
 	}
 	resp, _, err := http.Get(*dataURL);
 	if err != nil {
-		die.Log(err);
+		die.Log(err)
 	}
 	if resp.StatusCode != 200 {
-		die.Log("bad GET status for UnicodeData.txt", resp.Status);
+		die.Log("bad GET status for UnicodeData.txt", resp.Status)
 	}
 	input := bufio.NewReader(resp.Body);
 	var first uint32 = 0;
@@ -271,23 +271,23 @@ func loadChars() {
 		line, err := input.ReadString('\n');
 		if err != nil {
 			if err == os.EOF {
-				break;
+				break
 			}
 			die.Log(err);
 		}
 		switch parseCategory(line[0 : len(line)-1]) {
 		case SNormal:
 			if first != 0 {
-				die.Logf("bad state normal at U+%04X", lastChar);
+				die.Logf("bad state normal at U+%04X", lastChar)
 			}
 		case SFirst:
 			if first != 0 {
-				die.Logf("bad state first at U+%04X", lastChar);
+				die.Logf("bad state first at U+%04X", lastChar)
 			}
 			first = lastChar;
 		case SLast:
 			if first == 0 {
-				die.Logf("bad state last at U+%04X", lastChar);
+				die.Logf("bad state last at U+%04X", lastChar)
 			}
 			for i := first+1; i <= lastChar; i++ {
 				chars[i] = chars[first];
@@ -301,12 +301,12 @@ func loadChars() {
 
 func printCategories() {
 	if *tablelist == "" {
-		return;
+		return
 	}
 	// Find out which categories to dump
 	list := strings.Split(*tablelist, ",", 0);
 	if *tablelist == "all" {
-		list = allCategories();
+		list = allCategories()
 	}
 	if *test {
 		fullCategoryTest(list);
@@ -327,7 +327,7 @@ func printCategories() {
 		fmt.Println("// Categories is the set of Unicode data tables.");
 		fmt.Println("var Categories = map[string] []Range {");
 		for k, _ := range category {
-			fmt.Printf("\t%q: %s,\n", k, k);
+			fmt.Printf("\t%q: %s,\n", k, k)
 		}
 		fmt.Printf("}\n\n");
 	}
@@ -336,7 +336,7 @@ func printCategories() {
 	ndecl := 0;
 	for _, name := range list {
 		if _, ok := category[name]; !ok {
-			die.Log("unknown category", name);
+			die.Log("unknown category", name)
 		}
 		// We generate an UpperCase name to serve as concise documentation and an _UnderScored
 		// name to store the data.  This stops godoc dumping all the tables but keeps them
@@ -345,20 +345,20 @@ func printCategories() {
 		varDecl := "";
 		switch name {
 		case "letter":
-			varDecl = "\tLetter = letter;	// Letter is the set of Unicode letters.\n";
+			varDecl = "\tLetter = letter;	// Letter is the set of Unicode letters.\n"
 		case "Nd":
-			varDecl = "\tDigit = _Nd;	// Digit is the set of Unicode characters with the \"decimal digit\" property.\n";
+			varDecl = "\tDigit = _Nd;	// Digit is the set of Unicode characters with the \"decimal digit\" property.\n"
 		case "Lu":
-			varDecl = "\tUpper = _Lu;	// Upper is the set of Unicode upper case letters.\n";
+			varDecl = "\tUpper = _Lu;	// Upper is the set of Unicode upper case letters.\n"
 		case "Ll":
-			varDecl = "\tLower = _Ll;	// Lower is the set of Unicode lower case letters.\n";
+			varDecl = "\tLower = _Ll;	// Lower is the set of Unicode lower case letters.\n"
 		case "Lt":
-			varDecl = "\tTitle = _Lt;	// Title is the set of Unicode title case letters.\n";
+			varDecl = "\tTitle = _Lt;	// Title is the set of Unicode title case letters.\n"
 		}
 		if name != "letter" {
 			varDecl += fmt.Sprintf(
 				"\t%s = _%s;	// %s is the set of Unicode characters in category %s.\n",
-				name, name, name, name);
+				name, name, name, name)
 		}
 		decl[ndecl] = varDecl;
 		ndecl++;
@@ -375,7 +375,7 @@ func printCategories() {
 	decl.Sort();
 	fmt.Println("var (");
 	for _, d := range decl {
-		fmt.Print(d);
+		fmt.Print(d)
 	}
 	fmt.Println(")\n");
 }
@@ -391,11 +391,11 @@ func dumpRange(header string, inCategory Op) {
 	for {
 		// look for start of range
 		for next < len(chars) && !inCategory(next) {
-			next++;
+			next++
 		}
 		if next >= len(chars) {
 			// no characters remain
-			break;
+			break
 		}
 
 		// start of range
@@ -406,7 +406,7 @@ func dumpRange(header string, inCategory Op) {
 		next++;
 		// look for another character to set the stride
 		for next < len(chars) && !inCategory(next) {
-			next++;
+			next++
 		}
 		if next >= len(chars) {
 			// no more characters
@@ -420,11 +420,11 @@ func dumpRange(header string, inCategory Op) {
 			if inCategory(i) == (((i-lo)%stride) == 0) {
 				// accept
 				if inCategory(i) {
-					hi = i;
+					hi = i
 				}
 			} else {
 				// no more characters in this run
-				break;
+				break
 			}
 		}
 		fmt.Printf(format, lo, hi, stride);
@@ -437,19 +437,19 @@ func dumpRange(header string, inCategory Op) {
 func fullCategoryTest(list []string) {
 	for _, name := range list {
 		if _, ok := category[name]; !ok {
-			die.Log("unknown category", name);
+			die.Log("unknown category", name)
 		}
 		r, ok := unicode.Categories[name];
 		if !ok {
-			die.Log("unknown table", name);
+			die.Log("unknown table", name)
 		}
 		if name == "letter" {
-			verifyRange(name, letterOp, r);
+			verifyRange(name, letterOp, r)
 		} else {
 			verifyRange(
 				name,
 				func(code int) bool { return chars[code].category == name },
-				r);
+				r)
 		}
 	}
 }
@@ -459,7 +459,7 @@ func verifyRange(name string, inCategory Op, table []unicode.Range) {
 		web := inCategory(i);
 		pkg := unicode.Is(table, i);
 		if web != pkg {
-			fmt.Fprintf(os.Stderr, "%s: U+%04X: web=%t pkg=%t\n", name, i, web, pkg);
+			fmt.Fprintf(os.Stderr, "%s: U+%04X: web=%t pkg=%t\n", name, i, web, pkg)
 		}
 	}
 }
@@ -467,29 +467,29 @@ func verifyRange(name string, inCategory Op, table []unicode.Range) {
 func parseScript(line string, scripts map[string][]Script) {
 	comment := strings.Index(line, "#");
 	if comment >= 0 {
-		line = line[0:comment];
+		line = line[0:comment]
 	}
 	line = strings.TrimSpace(line);
 	if len(line) == 0 {
-		return;
+		return
 	}
 	field := strings.Split(line, ";", -1);
 	if len(field) != 2 {
-		die.Logf("%s: %d fields (expected 2)\n", line, len(field));
+		die.Logf("%s: %d fields (expected 2)\n", line, len(field))
 	}
 	matches := scriptRe.MatchStrings(line);
 	if len(matches) != 4 {
-		die.Logf("%s: %d matches (expected 3)\n", line, len(matches));
+		die.Logf("%s: %d matches (expected 3)\n", line, len(matches))
 	}
 	lo, err := strconv.Btoui64(matches[1], 16);
 	if err != nil {
-		die.Log("%.5s...:", err);
+		die.Log("%.5s...:", err)
 	}
 	hi := lo;
 	if len(matches[2]) > 2 {	// ignore leading ..
 		hi, err = strconv.Btoui64(matches[2][2:len(matches[2])], 16);
 		if err != nil {
-			die.Log("%.5s...:", err);
+			die.Log("%.5s...:", err)
 		}
 	}
 	name := matches[3];
@@ -497,7 +497,7 @@ func parseScript(line string, scripts map[string][]Script) {
 	if !ok || len(s) == cap(s) {
 		ns := make([]Script, len(s), len(s)+100);
 		for i, sc := range s {
-			ns[i] = sc;
+			ns[i] = sc
 		}
 		s = ns;
 	}
@@ -512,7 +512,7 @@ func foldAdjacent(r []Script) []unicode.Range {
 	j := 0;
 	for i := 0; i < len(r); i++ {
 		if j > 0 && int(r[i].lo) == s[j-1].Hi + 1 {
-			s[j-1].Hi = int(r[i].hi);
+			s[j-1].Hi = int(r[i].hi)
 		} else {
 			s = s[0 : j+1];
 			s[j] = unicode.Range{int(r[i].lo), int(r[i].hi), 1};
@@ -525,16 +525,16 @@ func foldAdjacent(r []Script) []unicode.Range {
 func fullScriptTest(list []string, installed map[string][]unicode.Range, scripts map[string][]Script) {
 	for _, name := range list {
 		if _, ok := scripts[name]; !ok {
-			die.Log("unknown script", name);
+			die.Log("unknown script", name)
 		}
 		_, ok := installed[name];
 		if !ok {
-			die.Log("unknown table", name);
+			die.Log("unknown table", name)
 		}
 		for _, script := range scripts[name] {
 			for r := script.lo; r <= script.hi; r++ {
 				if !unicode.Is(installed[name], int(r)) {
-					fmt.Fprintf(os.Stderr, "U+%04X: not in script %s\n", r, name);
+					fmt.Fprintf(os.Stderr, "U+%04X: not in script %s\n", r, name)
 				}
 			}
 		}
@@ -556,22 +556,22 @@ func printScriptOrProperty(doProps bool) {
 		installed = unicode.Properties;
 	}
 	if flaglist == "" {
-		return;
+		return
 	}
 	var err os.Error;
 	resp, _, err := http.Get(*url + file);
 	if err != nil {
-		die.Log(err);
+		die.Log(err)
 	}
 	if resp.StatusCode != 200 {
-		die.Log("bad GET status for ", file, ":", resp.Status);
+		die.Log("bad GET status for ", file, ":", resp.Status)
 	}
 	input := bufio.NewReader(resp.Body);
 	for {
 		line, err := input.ReadString('\n');
 		if err != nil {
 			if err == os.EOF {
-				break;
+				break
 			}
 			die.Log(err);
 		}
@@ -582,7 +582,7 @@ func printScriptOrProperty(doProps bool) {
 	// Find out which scripts to dump
 	list := strings.Split(flaglist, ",", 0);
 	if flaglist == "all" {
-		list = all(table);
+		list = all(table)
 	}
 	if *test {
 		fullScriptTest(list, installed, table);
@@ -605,7 +605,7 @@ func printScriptOrProperty(doProps bool) {
 			fmt.Println("var Scripts = map[string] []Range {");
 		}
 		for k, _ := range table {
-			fmt.Printf("\t%q: %s,\n", k, k);
+			fmt.Printf("\t%q: %s,\n", k, k)
 		}
 		fmt.Printf("}\n\n");
 	}
@@ -616,24 +616,24 @@ func printScriptOrProperty(doProps bool) {
 		if doProps {
 			decl[ndecl] = fmt.Sprintf(
 				"\t%s = _%s;\t// %s is the set of Unicode characters with property %s.\n",
-				name, name, name, name);
+				name, name, name, name)
 		} else {
 			decl[ndecl] = fmt.Sprintf(
 				"\t%s = _%s;\t// %s is the set of Unicode characters in script %s.\n",
-				name, name, name, name);
+				name, name, name, name)
 		}
 		ndecl++;
 		fmt.Printf("var _%s = []Range {\n", name);
 		ranges := foldAdjacent(table[name]);
 		for _, s := range ranges {
-			fmt.Printf(format, s.Lo, s.Hi, s.Stride);
+			fmt.Printf(format, s.Lo, s.Hi, s.Stride)
 		}
 		fmt.Printf("}\n\n");
 	}
 	decl.Sort();
 	fmt.Println("var (");
 	for _, d := range decl {
-		fmt.Print(d);
+		fmt.Print(d)
 	}
 	fmt.Println(")\n");
 }
@@ -657,23 +657,23 @@ type caseState struct {
 // Is d a continuation of the state of c?
 func (c *caseState) adjacent(d *caseState) bool {
 	if d.point < c.point {
-		c, d = d, c;
+		c, d = d, c
 	}
 	switch {
 	case d.point != c.point + 1:	// code points not adjacent (shouldn't happen)
-		return false;
+		return false
 	case d._case != c._case:	// different cases
-		return c.upperLowerAdjacent(d);
+		return c.upperLowerAdjacent(d)
 	case c._case == CaseNone:
-		return false;
+		return false
 	case c._case == CaseMissing:
-		return false;
+		return false
 	case d.deltaToUpper != c.deltaToUpper:
-		return false;
+		return false
 	case d.deltaToLower != c.deltaToLower:
-		return false;
+		return false
 	case d.deltaToTitle != c.deltaToTitle:
-		return false;
+		return false
 	}
 	return true;
 }
@@ -684,30 +684,30 @@ func (c *caseState) upperLowerAdjacent(d *caseState) bool {
 	// check they're a matched case pair.  we know they have adjacent values
 	switch {
 	case c._case == CaseUpper && d._case != CaseLower:
-		return false;
+		return false
 	case c._case == CaseLower && d._case != CaseUpper:
-		return false;
+		return false
 	}
 	// matched pair (at least in upper/lower).  make the order Upper Lower
 	if c._case == CaseLower {
-		c, d = d, c;
+		c, d = d, c
 	}
 	// for an Upper Lower sequence the deltas have to be in order
 	//	c: 0 1 0
 	//	d: -1 0 -1
 	switch {
 	case c.deltaToUpper != 0:
-		return false;
+		return false
 	case c.deltaToLower != 1:
-		return false;
+		return false
 	case c.deltaToTitle != 0:
-		return false;
+		return false
 	case d.deltaToUpper != -1:
-		return false;
+		return false
 	case d.deltaToLower != 0:
-		return false;
+		return false
 	case d.deltaToTitle != -1:
-		return false;
+		return false
 	}
 	return true;
 }
@@ -718,11 +718,11 @@ func (c *caseState) isUpperLower() bool {
 	//	c: 0 1 0
 	switch {
 	case c.deltaToUpper != 0:
-		return false;
+		return false
 	case c.deltaToLower != 1:
-		return false;
+		return false
 	case c.deltaToTitle != 0:
-		return false;
+		return false
 	}
 	return true;
 }
@@ -733,11 +733,11 @@ func (c *caseState) isLowerUpper() bool {
 	//	c: -1 0 -1
 	switch {
 	case c.deltaToUpper != -1:
-		return false;
+		return false
 	case c.deltaToLower != 0:
-		return false;
+		return false
 	case c.deltaToTitle != -1:
-		return false;
+		return false
 	}
 	return true;
 }
@@ -750,27 +750,27 @@ func getCaseState(i int) (c *caseState) {
 		c._case = CaseMissing;	// Will get NUL wrong but that doesn't matter
 		return;
 	case ch.upperCase:
-		c._case = CaseUpper;
+		c._case = CaseUpper
 	case ch.lowerCase:
-		c._case = CaseLower;
+		c._case = CaseLower
 	case ch.titleCase:
-		c._case = CaseTitle;
+		c._case = CaseTitle
 	}
 	if ch.upperCase != 0 {
-		c.deltaToUpper = ch.upperCase - i;
+		c.deltaToUpper = ch.upperCase - i
 	}
 	if ch.lowerCase != 0 {
-		c.deltaToLower = ch.lowerCase - i;
+		c.deltaToLower = ch.lowerCase - i
 	}
 	if ch.titleCase != 0 {
-		c.deltaToTitle = ch.titleCase - i;
+		c.deltaToTitle = ch.titleCase - i
 	}
 	return;
 }
 
 func printCases() {
 	if !*cases {
-		return;
+		return
 	}
 	if *test {
 		fullCaseTest();
@@ -798,7 +798,7 @@ func printCases() {
 		printCaseRange(startState, prevState);
 		startState = nil;
 		if state._case != CaseMissing && state._case != CaseNone {
-			startState = state;
+			startState = state
 		}
 		prevState = state;
 	}
@@ -807,16 +807,16 @@ func printCases() {
 
 func printCaseRange(lo, hi *caseState) {
 	if lo == nil {
-		return;
+		return
 	}
 	if lo.deltaToUpper == 0 && lo.deltaToLower == 0 && lo.deltaToTitle == 0 {
 		// character represents itself in all cases - no need to mention it
-		return;
+		return
 	}
 	switch {
 	case hi.point > lo.point && lo.isUpperLower():
 		fmt.Printf("\tCaseRange{0x%04X, 0x%04X, d{UpperLower, UpperLower, UpperLower}},\n",
-			lo.point, hi.point);
+			lo.point, hi.point)
 	case hi.point > lo.point && lo.isLowerUpper():
 		die.Log("LowerUpper sequence: should not happen: U+%04X.  If it's real, need to fix To()", lo.point);
 		fmt.Printf("\tCaseRange{0x%04X, 0x%04X, d{LowerUpper, LowerUpper, LowerUpper}},\n",
@@ -824,14 +824,14 @@ func printCaseRange(lo, hi *caseState) {
 	default:
 		fmt.Printf("\tCaseRange{0x%04X, 0x%04X, d{%d, %d, %d}},\n",
 			lo.point, hi.point,
-			lo.deltaToUpper, lo.deltaToLower, lo.deltaToTitle);
+			lo.deltaToUpper, lo.deltaToLower, lo.deltaToTitle)
 	}
 }
 
 // If the cased value in the Char is 0, it means use the rune itself.
 func caseIt(rune, cased int) int {
 	if cased == 0 {
-		return rune;
+		return rune
 	}
 	return cased;
 }
@@ -841,17 +841,17 @@ func fullCaseTest() {
 		lower := unicode.ToLower(i);
 		want := caseIt(i, c.lowerCase);
 		if lower != want {
-			fmt.Fprintf(os.Stderr, "lower U+%04X should be U+%04X is U+%04X\n", i, want, lower);
+			fmt.Fprintf(os.Stderr, "lower U+%04X should be U+%04X is U+%04X\n", i, want, lower)
 		}
 		upper := unicode.ToUpper(i);
 		want = caseIt(i, c.upperCase);
 		if upper != want {
-			fmt.Fprintf(os.Stderr, "upper U+%04X should be U+%04X is U+%04X\n", i, want, upper);
+			fmt.Fprintf(os.Stderr, "upper U+%04X should be U+%04X is U+%04X\n", i, want, upper)
 		}
 		title := unicode.ToTitle(i);
 		want = caseIt(i, c.titleCase);
 		if title != want {
-			fmt.Fprintf(os.Stderr, "title U+%04X should be U+%04X is U+%04X\n", i, want, title);
+			fmt.Fprintf(os.Stderr, "title U+%04X should be U+%04X is U+%04X\n", i, want, title)
 		}
 	}
 }
diff --git a/src/pkg/unicode/script_test.go b/src/pkg/unicode/script_test.go
index a5d070a498..96896ca0b6 100644
--- a/src/pkg/unicode/script_test.go
+++ b/src/pkg/unicode/script_test.go
@@ -172,61 +172,61 @@ var inPropTest = []T{
 func TestScripts(t *testing.T) {
 	notTested := make(map[string]bool);
 	for k := range Scripts {
-		notTested[k] = true;
+		notTested[k] = true
 	}
 	for _, test := range inTest {
 		if _, ok := Scripts[test.script]; !ok {
-			t.Fatal(test.script, "not a known script");
+			t.Fatal(test.script, "not a known script")
 		}
 		if !Is(Scripts[test.script], test.rune) {
-			t.Errorf("IsScript(%#x, %s) = false, want true\n", test.rune, test.script);
+			t.Errorf("IsScript(%#x, %s) = false, want true\n", test.rune, test.script)
 		}
 		notTested[test.script] = false, false;
 	}
 	for _, test := range outTest {
 		if Is(Scripts[test.script], test.rune) {
-			t.Errorf("IsScript(%#x, %s) = true, want false\n", test.rune, test.script);
+			t.Errorf("IsScript(%#x, %s) = true, want false\n", test.rune, test.script)
 		}
 	}
 	for k := range notTested {
-		t.Error("not tested:", k);
+		t.Error("not tested:", k)
 	}
 }
 
 func TestCategories(t *testing.T) {
 	notTested := make(map[string]bool);
 	for k := range Categories {
-		notTested[k] = true;
+		notTested[k] = true
 	}
 	for _, test := range inCategoryTest {
 		if _, ok := Categories[test.script]; !ok {
-			t.Fatal(test.script, "not a known category");
+			t.Fatal(test.script, "not a known category")
 		}
 		if !Is(Categories[test.script], test.rune) {
-			t.Errorf("IsCategory(%#x, %s) = false, want true\n", test.rune, test.script);
+			t.Errorf("IsCategory(%#x, %s) = false, want true\n", test.rune, test.script)
 		}
 		notTested[test.script] = false, false;
 	}
 	for k := range notTested {
-		t.Error("not tested:", k);
+		t.Error("not tested:", k)
 	}
 }
 
 func TestProperties(t *testing.T) {
 	notTested := make(map[string]bool);
 	for k := range Properties {
-		notTested[k] = true;
+		notTested[k] = true
 	}
 	for _, test := range inPropTest {
 		if _, ok := Properties[test.script]; !ok {
-			t.Fatal(test.script, "not a known prop");
+			t.Fatal(test.script, "not a known prop")
 		}
 		if !Is(Properties[test.script], test.rune) {
-			t.Errorf("IsCategory(%#x, %s) = false, want true\n", test.rune, test.script);
+			t.Errorf("IsCategory(%#x, %s) = false, want true\n", test.rune, test.script)
 		}
 		notTested[test.script] = false, false;
 	}
 	for k := range notTested {
-		t.Error("not tested:", k);
+		t.Error("not tested:", k)
 	}
 }
diff --git a/src/pkg/utf8/utf8.go b/src/pkg/utf8/utf8.go
index 89cdc99567..1784a6db4e 100644
--- a/src/pkg/utf8/utf8.go
+++ b/src/pkg/utf8/utf8.go
@@ -37,70 +37,70 @@ const (
 func decodeRuneInternal(p []byte) (rune, size int, short bool) {
 	n := len(p);
 	if n < 1 {
-		return RuneError, 0, true;
+		return RuneError, 0, true
 	}
 	c0 := p[0];
 
 	// 1-byte, 7-bit sequence?
 	if c0 < _Tx {
-		return int(c0), 1, false;
+		return int(c0), 1, false
 	}
 
 	// unexpected continuation byte?
 	if c0 < _T2 {
-		return RuneError, 1, false;
+		return RuneError, 1, false
 	}
 
 	// need first continuation byte
 	if n < 2 {
-		return RuneError, 1, true;
+		return RuneError, 1, true
 	}
 	c1 := p[1];
 	if c1 < _Tx || _T2 <= c1 {
-		return RuneError, 1, false;
+		return RuneError, 1, false
 	}
 
 	// 2-byte, 11-bit sequence?
 	if c0 < _T3 {
 		rune = int(c0&_Mask2)<<6 | int(c1&_Maskx);
 		if rune <= _Rune1Max {
-			return RuneError, 1, false;
+			return RuneError, 1, false
 		}
 		return rune, 2, false;
 	}
 
 	// need second continuation byte
 	if n < 3 {
-		return RuneError, 1, true;
+		return RuneError, 1, true
 	}
 	c2 := p[2];
 	if c2 < _Tx || _T2 <= c2 {
-		return RuneError, 1, false;
+		return RuneError, 1, false
 	}
 
 	// 3-byte, 16-bit sequence?
 	if c0 < _T4 {
 		rune = int(c0&_Mask3)<<12 | int(c1&_Maskx)<<6 | int(c2&_Maskx);
 		if rune <= _Rune2Max {
-			return RuneError, 1, false;
+			return RuneError, 1, false
 		}
 		return rune, 3, false;
 	}
 
 	// need third continuation byte
 	if n < 4 {
-		return RuneError, 1, true;
+		return RuneError, 1, true
 	}
 	c3 := p[3];
 	if c3 < _Tx || _T2 <= c3 {
-		return RuneError, 1, false;
+		return RuneError, 1, false
 	}
 
 	// 4-byte, 21-bit sequence?
 	if c0 < _T5 {
 		rune = int(c0&_Mask4)<<18 | int(c1&_Maskx)<<12 | int(c2&_Maskx)<<6 | int(c3&_Maskx);
 		if rune <= _Rune3Max {
-			return RuneError, 1, false;
+			return RuneError, 1, false
 		}
 		return rune, 4, false;
 	}
@@ -112,70 +112,70 @@ func decodeRuneInternal(p []byte) (rune, size int, short bool) {
 func decodeRuneInStringInternal(s string) (rune, size int, short bool) {
 	n := len(s);
 	if n < 1 {
-		return RuneError, 0, true;
+		return RuneError, 0, true
 	}
 	c0 := s[0];
 
 	// 1-byte, 7-bit sequence?
 	if c0 < _Tx {
-		return int(c0), 1, false;
+		return int(c0), 1, false
 	}
 
 	// unexpected continuation byte?
 	if c0 < _T2 {
-		return RuneError, 1, false;
+		return RuneError, 1, false
 	}
 
 	// need first continuation byte
 	if n < 2 {
-		return RuneError, 1, true;
+		return RuneError, 1, true
 	}
 	c1 := s[1];
 	if c1 < _Tx || _T2 <= c1 {
-		return RuneError, 1, false;
+		return RuneError, 1, false
 	}
 
 	// 2-byte, 11-bit sequence?
 	if c0 < _T3 {
 		rune = int(c0&_Mask2)<<6 | int(c1&_Maskx);
 		if rune <= _Rune1Max {
-			return RuneError, 1, false;
+			return RuneError, 1, false
 		}
 		return rune, 2, false;
 	}
 
 	// need second continuation byte
 	if n < 3 {
-		return RuneError, 1, true;
+		return RuneError, 1, true
 	}
 	c2 := s[2];
 	if c2 < _Tx || _T2 <= c2 {
-		return RuneError, 1, false;
+		return RuneError, 1, false
 	}
 
 	// 3-byte, 16-bit sequence?
 	if c0 < _T4 {
 		rune = int(c0&_Mask3)<<12 | int(c1&_Maskx)<<6 | int(c2&_Maskx);
 		if rune <= _Rune2Max {
-			return RuneError, 1, false;
+			return RuneError, 1, false
 		}
 		return rune, 3, false;
 	}
 
 	// need third continuation byte
 	if n < 4 {
-		return RuneError, 1, true;
+		return RuneError, 1, true
 	}
 	c3 := s[3];
 	if c3 < _Tx || _T2 <= c3 {
-		return RuneError, 1, false;
+		return RuneError, 1, false
 	}
 
 	// 4-byte, 21-bit sequence?
 	if c0 < _T5 {
 		rune = int(c0&_Mask4)<<18 | int(c1&_Maskx)<<12 | int(c2&_Maskx)<<6 | int(c3&_Maskx);
 		if rune <= _Rune3Max {
-			return RuneError, 1, false;
+			return RuneError, 1, false
 		}
 		return rune, 4, false;
 	}
@@ -213,13 +213,13 @@ func DecodeRuneInString(s string) (rune, size int) {
 func RuneLen(rune int) int {
 	switch {
 	case rune <= _Rune1Max:
-		return 1;
+		return 1
 	case rune <= _Rune2Max:
-		return 2;
+		return 2
 	case rune <= _Rune3Max:
-		return 3;
+		return 3
 	case rune <= _Rune4Max:
-		return 4;
+		return 4
 	}
 	return -1;
 }
@@ -239,7 +239,7 @@ func EncodeRune(rune int, p []byte) int {
 	}
 
 	if rune > unicode.MaxRune {
-		rune = RuneError;
+		rune = RuneError
 	}
 
 	if rune <= _Rune3Max {
@@ -263,7 +263,7 @@ func RuneCount(p []byte) int {
 	var n int;
 	for n = 0; i < len(p); n++ {
 		if p[i] < RuneSelf {
-			i++;
+			i++
 		} else {
 			_, size := DecodeRune(p[i:len(p)]);
 			i += size;
@@ -279,7 +279,7 @@ func RuneCountInString(s string) int {
 	var n int;
 	for n = 0; i < ei; n++ {
 		if s[i] < RuneSelf {
-			i++;
+			i++
 		} else {
 			_, size, _ := decodeRuneInStringInternal(s[i:ei]);
 			i += size;
diff --git a/src/pkg/utf8/utf8_test.go b/src/pkg/utf8/utf8_test.go
index dd9e334122..6684245d8b 100644
--- a/src/pkg/utf8/utf8_test.go
+++ b/src/pkg/utf8/utf8_test.go
@@ -56,19 +56,19 @@ func TestFullRune(t *testing.T) {
 		m := utf8map[i];
 		b := makeBytes(m.str);
 		if !FullRune(b) {
-			t.Errorf("FullRune(%q) (rune %04x) = false, want true", b, m.rune);
+			t.Errorf("FullRune(%q) (rune %04x) = false, want true", b, m.rune)
 		}
 		s := m.str;
 		if !FullRuneInString(s) {
-			t.Errorf("FullRuneInString(%q) (rune %04x) = false, want true", s, m.rune);
+			t.Errorf("FullRuneInString(%q) (rune %04x) = false, want true", s, m.rune)
 		}
 		b1 := b[0 : len(b)-1];
 		if FullRune(b1) {
-			t.Errorf("FullRune(%q) = true, want false", b1);
+			t.Errorf("FullRune(%q) = true, want false", b1)
 		}
 		s1 := string(b1);
 		if FullRuneInString(s1) {
-			t.Errorf("FullRune(%q) = true, want false", s1);
+			t.Errorf("FullRune(%q) = true, want false", s1)
 		}
 	}
 }
@@ -81,7 +81,7 @@ func TestEncodeRune(t *testing.T) {
 		n := EncodeRune(m.rune, &buf);
 		b1 := buf[0:n];
 		if !bytes.Equal(b, b1) {
-			t.Errorf("EncodeRune(0x%04x) = %q want %q", m.rune, b1, b);
+			t.Errorf("EncodeRune(0x%04x) = %q want %q", m.rune, b1, b)
 		}
 	}
 }
@@ -92,54 +92,54 @@ func TestDecodeRune(t *testing.T) {
 		b := makeBytes(m.str);
 		rune, size := DecodeRune(b);
 		if rune != m.rune || size != len(b) {
-			t.Errorf("DecodeRune(%q) = 0x%04x, %d want 0x%04x, %d", b, rune, size, m.rune, len(b));
+			t.Errorf("DecodeRune(%q) = 0x%04x, %d want 0x%04x, %d", b, rune, size, m.rune, len(b))
 		}
 		s := m.str;
 		rune, size = DecodeRuneInString(s);
 		if rune != m.rune || size != len(b) {
-			t.Errorf("DecodeRune(%q) = 0x%04x, %d want 0x%04x, %d", s, rune, size, m.rune, len(b));
+			t.Errorf("DecodeRune(%q) = 0x%04x, %d want 0x%04x, %d", s, rune, size, m.rune, len(b))
 		}
 
 		// there's an extra byte that bytes left behind - make sure trailing byte works
 		rune, size = DecodeRune(b[0:cap(b)]);
 		if rune != m.rune || size != len(b) {
-			t.Errorf("DecodeRune(%q) = 0x%04x, %d want 0x%04x, %d", b, rune, size, m.rune, len(b));
+			t.Errorf("DecodeRune(%q) = 0x%04x, %d want 0x%04x, %d", b, rune, size, m.rune, len(b))
 		}
 		s = m.str + "\x00";
 		rune, size = DecodeRuneInString(s);
 		if rune != m.rune || size != len(b) {
-			t.Errorf("DecodeRuneInString(%q) = 0x%04x, %d want 0x%04x, %d", s, rune, size, m.rune, len(b));
+			t.Errorf("DecodeRuneInString(%q) = 0x%04x, %d want 0x%04x, %d", s, rune, size, m.rune, len(b))
 		}
 
 		// make sure missing bytes fail
 		wantsize := 1;
 		if wantsize >= len(b) {
-			wantsize = 0;
+			wantsize = 0
 		}
 		rune, size = DecodeRune(b[0 : len(b)-1]);
 		if rune != RuneError || size != wantsize {
-			t.Errorf("DecodeRune(%q) = 0x%04x, %d want 0x%04x, %d", b[0 : len(b)-1], rune, size, RuneError, wantsize);
+			t.Errorf("DecodeRune(%q) = 0x%04x, %d want 0x%04x, %d", b[0 : len(b)-1], rune, size, RuneError, wantsize)
 		}
 		s = m.str[0 : len(m.str)-1];
 		rune, size = DecodeRuneInString(s);
 		if rune != RuneError || size != wantsize {
-			t.Errorf("DecodeRuneInString(%q) = 0x%04x, %d want 0x%04x, %d", s, rune, size, RuneError, wantsize);
+			t.Errorf("DecodeRuneInString(%q) = 0x%04x, %d want 0x%04x, %d", s, rune, size, RuneError, wantsize)
 		}
 
 		// make sure bad sequences fail
 		if len(b) == 1 {
-			b[0] = 0x80;
+			b[0] = 0x80
 		} else {
-			b[len(b)-1] = 0x7F;
+			b[len(b)-1] = 0x7F
 		}
 		rune, size = DecodeRune(b);
 		if rune != RuneError || size != 1 {
-			t.Errorf("DecodeRune(%q) = 0x%04x, %d want 0x%04x, %d", b, rune, size, RuneError, 1);
+			t.Errorf("DecodeRune(%q) = 0x%04x, %d want 0x%04x, %d", b, rune, size, RuneError, 1)
 		}
 		s = string(b);
 		rune, size = DecodeRune(b);
 		if rune != RuneError || size != 1 {
-			t.Errorf("DecodeRuneInString(%q) = 0x%04x, %d want 0x%04x, %d", s, rune, size, RuneError, 1);
+			t.Errorf("DecodeRuneInString(%q) = 0x%04x, %d want 0x%04x, %d", s, rune, size, RuneError, 1)
 		}
 	}
 }
@@ -160,10 +160,10 @@ func TestRuneCount(t *testing.T) {
 	for i := 0; i < len(runecounttests); i++ {
 		tt := runecounttests[i];
 		if out := RuneCountInString(tt.in); out != tt.out {
-			t.Errorf("RuneCountInString(%q) = %d, want %d", tt.in, out, tt.out);
+			t.Errorf("RuneCountInString(%q) = %d, want %d", tt.in, out, tt.out)
 		}
 		if out := RuneCount(makeBytes(tt.in)); out != tt.out {
-			t.Errorf("RuneCount(%q) = %d, want %d", tt.in, out, tt.out);
+			t.Errorf("RuneCount(%q) = %d, want %d", tt.in, out, tt.out)
 		}
 	}
 }
diff --git a/src/pkg/xml/read.go b/src/pkg/xml/read.go
index a33188e26b..b51a302b3f 100644
--- a/src/pkg/xml/read.go
+++ b/src/pkg/xml/read.go
@@ -114,13 +114,13 @@ import (
 func Unmarshal(r io.Reader, val interface{}) os.Error {
 	v, ok := reflect.NewValue(val).(*reflect.PtrValue);
 	if !ok {
-		return os.NewError("non-pointer passed to Unmarshal");
+		return os.NewError("non-pointer passed to Unmarshal")
 	}
 	p := NewParser(r);
 	elem := v.Elem();
 	err := p.unmarshal(elem, nil);
 	if err != nil {
-		return err;
+		return err
 	}
 	return nil;
 }
@@ -139,7 +139,7 @@ func (e UnmarshalError) String() string	{ return string(e) }
 func (p *Parser) Unmarshal(val interface{}, start *StartElement) os.Error {
 	v, ok := reflect.NewValue(val).(*reflect.PtrValue);
 	if !ok {
-		return os.NewError("non-pointer passed to Unmarshal");
+		return os.NewError("non-pointer passed to Unmarshal")
 	}
 	return p.unmarshal(v.Elem(), start);
 }
@@ -151,7 +151,7 @@ func (p *Parser) unmarshal(val reflect.Value, start *StartElement) os.Error {
 		for {
 			tok, err := p.Token();
 			if err != nil {
-				return err;
+				return err
 			}
 			if t, ok := tok.(StartElement); ok {
 				start = &t;
@@ -166,7 +166,7 @@ func (p *Parser) unmarshal(val reflect.Value, start *StartElement) os.Error {
 			pv.PointTo(zv);
 			val = zv;
 		} else {
-			val = pv.Elem();
+			val = pv.Elem()
 		}
 	}
 
@@ -180,7 +180,7 @@ func (p *Parser) unmarshal(val reflect.Value, start *StartElement) os.Error {
 	)
 	switch v := val.(type) {
 	case *reflect.BoolValue:
-		v.Set(true);
+		v.Set(true)
 
 	case *reflect.SliceValue:
 		typ := v.Type().(*reflect.SliceType);
@@ -196,7 +196,7 @@ func (p *Parser) unmarshal(val reflect.Value, start *StartElement) os.Error {
 		if n >= v.Cap() {
 			ncap := 2*n;
 			if ncap < 4 {
-				ncap = 4;
+				ncap = 4
 			}
 			new := reflect.MakeSlice(typ, n, ncap);
 			reflect.ArrayCopy(new, v);
@@ -212,7 +212,7 @@ func (p *Parser) unmarshal(val reflect.Value, start *StartElement) os.Error {
 		return nil;
 
 	case *reflect.StringValue:
-		saveData = v;
+		saveData = v
 
 	case *reflect.StructValue:
 		if _, ok := v.Interface().(Name); ok {
@@ -231,17 +231,17 @@ func (p *Parser) unmarshal(val reflect.Value, start *StartElement) os.Error {
 				ns := "";
 				i := strings.LastIndex(tag, " ");
 				if i >= 0 {
-					ns, tag = tag[0:i], tag[i+1 : len(tag)];
+					ns, tag = tag[0:i], tag[i+1 : len(tag)]
 				}
 				if tag != start.Name.Local {
-					return UnmarshalError("expected element type <" + tag + "> but have <" + start.Name.Local + ">");
+					return UnmarshalError("expected element type <" + tag + "> but have <" + start.Name.Local + ">")
 				}
 				if ns != "" && ns != start.Name.Space {
 					e := "expected element <" + tag + "> in name space " + ns + " but have ";
 					if start.Name.Space == "" {
-						e += "no name space";
+						e += "no name space"
 					} else {
-						e += start.Name.Space;
+						e += start.Name.Space
 					}
 					return UnmarshalError(e);
 				}
@@ -250,7 +250,7 @@ func (p *Parser) unmarshal(val reflect.Value, start *StartElement) os.Error {
 			// Save
 			v := sv.FieldByIndex(f.Index);
 			if _, ok := v.Interface().(Name); !ok {
-				return UnmarshalError(sv.Type().String() + " field XMLName does not have type xml.Name");
+				return UnmarshalError(sv.Type().String() + " field XMLName does not have type xml.Name")
 			}
 			v.(*reflect.StructValue).Set(reflect.NewValue(start.Name).(*reflect.StructValue));
 		}
@@ -263,7 +263,7 @@ func (p *Parser) unmarshal(val reflect.Value, start *StartElement) os.Error {
 			case "attr":
 				strv, ok := sv.FieldByIndex(f.Index).(*reflect.StringValue);
 				if !ok {
-					return UnmarshalError(sv.Type().String() + " field " + f.Name + " has attr tag but is not type string");
+					return UnmarshalError(sv.Type().String() + " field " + f.Name + " has attr tag but is not type string")
 				}
 				// Look for attribute.
 				val := "";
@@ -278,12 +278,12 @@ func (p *Parser) unmarshal(val reflect.Value, start *StartElement) os.Error {
 
 			case "comment":
 				if saveComment == nil {
-					saveComment = sv.FieldByIndex(f.Index);
+					saveComment = sv.FieldByIndex(f.Index)
 				}
 
 			case "chardata":
 				if saveData == nil {
-					saveData = sv.FieldByIndex(f.Index);
+					saveData = sv.FieldByIndex(f.Index)
 				}
 			}
 		}
@@ -295,7 +295,7 @@ Loop:
 	for {
 		tok, err := p.Token();
 		if err != nil {
-			return err;
+			return err
 		}
 		switch t := tok.(type) {
 		case StartElement:
@@ -309,37 +309,37 @@ Loop:
 					f := styp.Field(i);
 					if strings.ToLower(f.Name) == k {
 						if err := p.unmarshal(sv.FieldByIndex(f.Index), &t); err != nil {
-							return err;
+							return err
 						}
 						continue Loop;
 					}
 					if any < 0 && f.Name == "Any" {
-						any = i;
+						any = i
 					}
 				}
 				if any >= 0 {
 					if err := p.unmarshal(sv.FieldByIndex(styp.Field(any).Index), &t); err != nil {
-						return err;
+						return err
 					}
 					continue Loop;
 				}
 			}
 			// Not saving sub-element but still have to skip over it.
 			if err := p.Skip(); err != nil {
-				return err;
+				return err
 			}
 
 		case EndElement:
-			break Loop;
+			break Loop
 
 		case CharData:
 			if saveData != nil {
-				data = bytes.Add(data, t);
+				data = bytes.Add(data, t)
 			}
 
 		case Comment:
 			if saveComment != nil {
-				comment = bytes.Add(comment, t);
+				comment = bytes.Add(comment, t)
 			}
 		}
 	}
@@ -347,16 +347,16 @@ Loop:
 	// Save accumulated character data and comments
 	switch t := saveData.(type) {
 	case *reflect.StringValue:
-		t.Set(string(data));
+		t.Set(string(data))
 	case *reflect.SliceValue:
-		t.Set(reflect.NewValue(data).(*reflect.SliceValue));
+		t.Set(reflect.NewValue(data).(*reflect.SliceValue))
 	}
 
 	switch t := saveComment.(type) {
 	case *reflect.StringValue:
-		t.Set(string(comment));
+		t.Set(string(comment))
 	case *reflect.SliceValue:
-		t.Set(reflect.NewValue(comment).(*reflect.SliceValue));
+		t.Set(reflect.NewValue(comment).(*reflect.SliceValue))
 	}
 
 	return nil;
@@ -370,15 +370,15 @@ func (p *Parser) Skip() os.Error {
 	for {
 		tok, err := p.Token();
 		if err != nil {
-			return err;
+			return err
 		}
 		switch t := tok.(type) {
 		case StartElement:
 			if err := p.Skip(); err != nil {
-				return err;
+				return err
 			}
 		case EndElement:
-			return nil;
+			return nil
 		}
 	}
 	panic("unreachable");
diff --git a/src/pkg/xml/read_test.go b/src/pkg/xml/read_test.go
index 81d2325673..14ad11a318 100644
--- a/src/pkg/xml/read_test.go
+++ b/src/pkg/xml/read_test.go
@@ -14,10 +14,10 @@ import (
 func TestUnmarshalFeed(t *testing.T) {
 	var f Feed;
 	if err := Unmarshal(StringReader(rssFeedString), &f); err != nil {
-		t.Fatalf("Unmarshal: %s", err);
+		t.Fatalf("Unmarshal: %s", err)
 	}
 	if !reflect.DeepEqual(f, rssFeed) {
-		t.Fatalf("have %#v\nwant %#v\n\n%#v", f);
+		t.Fatalf("have %#v\nwant %#v\n\n%#v", f)
 	}
 }
 
diff --git a/src/pkg/xml/xml.go b/src/pkg/xml/xml.go
index 52ef78f2f9..09dd8217bb 100644
--- a/src/pkg/xml/xml.go
+++ b/src/pkg/xml/xml.go
@@ -167,9 +167,9 @@ func NewParser(r io.Reader) *Parser {
 	// ReadByte, it's efficient enough.
 	// Otherwise, use bufio.
 	if rb, ok := r.(readByter); ok {
-		p.r = rb;
+		p.r = rb
 	} else {
-		p.r = bufio.NewReader(r);
+		p.r = bufio.NewReader(r)
 	}
 
 	return p;
@@ -203,7 +203,7 @@ func (p *Parser) Token() (t Token, err os.Error) {
 		t = p.nextToken;
 		p.nextToken = nil;
 	} else if t, err = p.RawToken(); err != nil {
-		return;
+		return
 	}
 
 	if !p.Strict {
@@ -234,7 +234,7 @@ func (p *Parser) Token() (t Token, err os.Error) {
 
 		p.translate(&t1.Name, true);
 		for i := range t1.Attr {
-			p.translate(&t1.Attr[i].Name, false);
+			p.translate(&t1.Attr[i].Name, false)
 		}
 		p.pushElement(t1.Name);
 		t = t1;
@@ -242,7 +242,7 @@ func (p *Parser) Token() (t Token, err os.Error) {
 	case EndElement:
 		p.translate(&t1.Name, true);
 		if !p.popElement(&t1) {
-			return nil, p.err;
+			return nil, p.err
 		}
 		t = t1;
 	}
@@ -255,14 +255,14 @@ func (p *Parser) Token() (t Token, err os.Error) {
 func (p *Parser) translate(n *Name, isElementName bool) {
 	switch {
 	case n.Space == "xmlns":
-		return;
+		return
 	case n.Space == "" && !isElementName:
-		return;
+		return
 	case n.Space == "" && n.Local == "xmlns":
-		return;
+		return
 	}
 	if v, ok := p.ns[n.Space]; ok {
-		n.Space = v;
+		n.Space = v
 	}
 }
 
@@ -285,9 +285,9 @@ const (
 func (p *Parser) push(kind int) *stack {
 	s := p.free;
 	if s != nil {
-		p.free = s.next;
+		p.free = s.next
 	} else {
-		s = new(stack);
+		s = new(stack)
 	}
 	s.next = p.stk;
 	s.kind = kind;
@@ -362,7 +362,7 @@ func (p *Parser) popElement(t *EndElement) bool {
 // t is not the end tag, invent the end tag.
 func (p *Parser) autoClose(t Token) (Token, bool) {
 	if p.stk == nil || p.stk.kind != stkStart {
-		return nil, false;
+		return nil, false
 	}
 	name := strings.ToLower(p.stk.name.Local);
 	for _, s := range p.AutoClose {
@@ -370,7 +370,7 @@ func (p *Parser) autoClose(t Token) (Token, bool) {
 			// This one should be auto closed if t doesn't close it.
 			et, ok := t.(EndElement);
 			if !ok || et.Name.Local != name {
-				return EndElement{p.stk.name}, true;
+				return EndElement{p.stk.name}, true
 			}
 			break;
 		}
@@ -384,7 +384,7 @@ func (p *Parser) autoClose(t Token) (Token, bool) {
 // name space prefixes to their corresponding URLs.
 func (p *Parser) RawToken() (Token, os.Error) {
 	if p.err != nil {
-		return nil, p.err;
+		return nil, p.err
 	}
 	if p.needClose {
 		// The last element we read was self-closing and
@@ -396,7 +396,7 @@ func (p *Parser) RawToken() (Token, os.Error) {
 
 	b, ok := p.getc();
 	if !ok {
-		return nil, p.err;
+		return nil, p.err
 	}
 
 	if b != '<' {
@@ -404,13 +404,13 @@ func (p *Parser) RawToken() (Token, os.Error) {
 		p.ungetc(b);
 		data := p.text(-1, false);
 		if data == nil {
-			return nil, p.err;
+			return nil, p.err
 		}
 		return CharData(data), nil;
 	}
 
 	if b, ok = p.getc(); !ok {
-		return nil, p.err;
+		return nil, p.err
 	}
 	switch b {
 	case '/':
@@ -418,13 +418,13 @@ func (p *Parser) RawToken() (Token, os.Error) {
 		var name Name;
 		if name, ok = p.nsname(); !ok {
 			if p.err == nil {
-				p.err = SyntaxError("expected element name after </");
+				p.err = SyntaxError("expected element name after </")
 			}
 			return nil, p.err;
 		}
 		p.space();
 		if b, ok = p.getc(); !ok {
-			return nil, p.err;
+			return nil, p.err
 		}
 		if b != '>' {
 			p.err = SyntaxError("invalid characters between </" + name.Local + " and >");
@@ -438,7 +438,7 @@ func (p *Parser) RawToken() (Token, os.Error) {
 		// the version is 1.0 and the encoding is UTF-8.
 		var target string;
 		if target, ok = p.name(); !ok {
-			return nil, p.err;
+			return nil, p.err
 		}
 		p.space();
 		p.buf.Reset();
@@ -446,13 +446,13 @@ func (p *Parser) RawToken() (Token, os.Error) {
 		for {
 			if b, ok = p.getc(); !ok {
 				if p.err == os.EOF {
-					p.err = SyntaxError("unterminated <? directive");
+					p.err = SyntaxError("unterminated <? directive")
 				}
 				return nil, p.err;
 			}
 			p.buf.WriteByte(b);
 			if b0 == '?' && b == '>' {
-				break;
+				break
 			}
 			b0 = b;
 		}
@@ -463,13 +463,13 @@ func (p *Parser) RawToken() (Token, os.Error) {
 	case '!':
 		// <!: Maybe comment, maybe CDATA.
 		if b, ok = p.getc(); !ok {
-			return nil, p.err;
+			return nil, p.err
 		}
 		switch b {
 		case '-':	// <!-
 			// Probably <!-- for a comment.
 			if b, ok = p.getc(); !ok {
-				return nil, p.err;
+				return nil, p.err
 			}
 			if b != '-' {
 				p.err = SyntaxError("invalid sequence <!- not part of <!--");
@@ -481,13 +481,13 @@ func (p *Parser) RawToken() (Token, os.Error) {
 			for {
 				if b, ok = p.getc(); !ok {
 					if p.err == os.EOF {
-						p.err = SyntaxError("unterminated <!-- comment");
+						p.err = SyntaxError("unterminated <!-- comment")
 					}
 					return nil, p.err;
 				}
 				p.buf.WriteByte(b);
 				if b0 == '-' && b1 == '-' && b == '>' {
-					break;
+					break
 				}
 				b0, b1 = b1, b;
 			}
@@ -499,7 +499,7 @@ func (p *Parser) RawToken() (Token, os.Error) {
 			// Probably <![CDATA[.
 			for i := 0; i < 7; i++ {
 				if b, ok = p.getc(); !ok {
-					return nil, p.err;
+					return nil, p.err
 				}
 				if b != "[CDATA["[i] {
 					p.err = SyntaxError("invalid <![ sequence");
@@ -509,7 +509,7 @@ func (p *Parser) RawToken() (Token, os.Error) {
 			// Have <![CDATA[.  Read text until ]]>.
 			data := p.text(-1, true);
 			if data == nil {
-				return nil, p.err;
+				return nil, p.err
 			}
 			return CharData(data), nil;
 		}
@@ -520,10 +520,10 @@ func (p *Parser) RawToken() (Token, os.Error) {
 		p.buf.WriteByte(b);
 		for {
 			if b, ok = p.getc(); !ok {
-				return nil, p.err;
+				return nil, p.err
 			}
 			if b == '>' {
-				break;
+				break
 			}
 			p.buf.WriteByte(b);
 		}
@@ -540,7 +540,7 @@ func (p *Parser) RawToken() (Token, os.Error) {
 	)
 	if name, ok = p.nsname(); !ok {
 		if p.err == nil {
-			p.err = SyntaxError("expected element name after <");
+			p.err = SyntaxError("expected element name after <")
 		}
 		return nil, p.err;
 	}
@@ -549,12 +549,12 @@ func (p *Parser) RawToken() (Token, os.Error) {
 	for {
 		p.space();
 		if b, ok = p.getc(); !ok {
-			return nil, p.err;
+			return nil, p.err
 		}
 		if b == '/' {
 			empty = true;
 			if b, ok = p.getc(); !ok {
-				return nil, p.err;
+				return nil, p.err
 			}
 			if b != '>' {
 				p.err = SyntaxError("expected /> in element");
@@ -563,7 +563,7 @@ func (p *Parser) RawToken() (Token, os.Error) {
 			break;
 		}
 		if b == '>' {
-			break;
+			break
 		}
 		p.ungetc(b);
 
@@ -571,7 +571,7 @@ func (p *Parser) RawToken() (Token, os.Error) {
 		if n >= cap(attr) {
 			nattr := make([]Attr, n, 2*cap(attr));
 			for i, a := range attr {
-				nattr[i] = a;
+				nattr[i] = a
 			}
 			attr = nattr;
 		}
@@ -579,13 +579,13 @@ func (p *Parser) RawToken() (Token, os.Error) {
 		a := &attr[n];
 		if a.Name, ok = p.nsname(); !ok {
 			if p.err == nil {
-				p.err = SyntaxError("expected attribute name in element");
+				p.err = SyntaxError("expected attribute name in element")
 			}
 			return nil, p.err;
 		}
 		p.space();
 		if b, ok = p.getc(); !ok {
-			return nil, p.err;
+			return nil, p.err
 		}
 		if b != '=' {
 			p.err = SyntaxError("attribute name without = in element");
@@ -593,7 +593,7 @@ func (p *Parser) RawToken() (Token, os.Error) {
 		}
 		p.space();
 		if b, ok = p.getc(); !ok {
-			return nil, p.err;
+			return nil, p.err
 		}
 		if b != '"' && b != '\'' {
 			p.err = SyntaxError("unquoted or missing attribute value in element");
@@ -601,7 +601,7 @@ func (p *Parser) RawToken() (Token, os.Error) {
 		}
 		data := p.text(int(b), false);
 		if data == nil {
-			return nil, p.err;
+			return nil, p.err
 		}
 		a.Value = string(data);
 	}
@@ -618,7 +618,7 @@ func (p *Parser) space() {
 	for {
 		b, ok := p.getc();
 		if !ok {
-			return;
+			return
 		}
 		switch b {
 		case ' ', '\r', '\n', '\t':
@@ -635,7 +635,7 @@ func (p *Parser) space() {
 // Maintain line number.
 func (p *Parser) getc() (b byte, ok bool) {
 	if p.err != nil {
-		return 0, false;
+		return 0, false
 	}
 	if p.nextByte >= 0 {
 		b = byte(p.nextByte);
@@ -643,11 +643,11 @@ func (p *Parser) getc() (b byte, ok bool) {
 	} else {
 		b, p.err = p.r.ReadByte();
 		if p.err != nil {
-			return 0, false;
+			return 0, false
 		}
 	}
 	if b == '\n' {
-		p.line++;
+		p.line++
 	}
 	return b, true;
 }
@@ -655,7 +655,7 @@ func (p *Parser) getc() (b byte, ok bool) {
 // Unread a single byte.
 func (p *Parser) ungetc(b byte) {
 	if b == '\n' {
-		p.line--;
+		p.line--
 	}
 	p.nextByte = int(b);
 }
@@ -680,7 +680,7 @@ Input:
 	for {
 		b, ok := p.getc();
 		if !ok {
-			return nil;
+			return nil
 		}
 
 		// <![CDATA[ section ends with ]]>.
@@ -704,7 +704,7 @@ Input:
 			break Input;
 		}
 		if quote >= 0 && b == byte(quote) {
-			break Input;
+			break Input
 		}
 		if b == '&' {
 			// Read escaped character expression up to semicolon.
@@ -717,17 +717,17 @@ Input:
 			for i = 0; i < len(p.tmp); i++ {
 				p.tmp[i], p.err = p.r.ReadByte();
 				if p.err != nil {
-					return nil;
+					return nil
 				}
 				c := p.tmp[i];
 				if c == ';' {
-					break;
+					break
 				}
 				if 'a' <= c && c <= 'z' ||
 					'A' <= c && c <= 'Z' ||
 					'0' <= c && c <= '9' ||
 					c == '_' || c == '#' {
-					continue;
+					continue
 				}
 				p.ungetc(c);
 				break;
@@ -749,9 +749,9 @@ Input:
 				var n uint64;
 				var err os.Error;
 				if i >= 3 && s[1] == 'x' {
-					n, err = strconv.Btoui64(s[2:len(s)], 16);
+					n, err = strconv.Btoui64(s[2:len(s)], 16)
 				} else {
-					n, err = strconv.Btoui64(s[1:len(s)], 10);
+					n, err = strconv.Btoui64(s[1:len(s)], 10)
 				}
 				if err == nil && n <= unicode.MaxRune {
 					text = string(n);
@@ -762,7 +762,7 @@ Input:
 					text = string(r);
 					haveText = true;
 				} else {
-					text, haveText = p.Entity[s];
+					text, haveText = p.Entity[s]
 				}
 			}
 			if !haveText {
@@ -791,7 +791,7 @@ Input:
 		b := data[r];
 		if b == '\r' {
 			if r+1 < len(data) && data[r+1] == '\n' {
-				continue;
+				continue
 			}
 			b = '\n';
 		}
@@ -806,11 +806,11 @@ Input:
 func (p *Parser) nsname() (name Name, ok bool) {
 	s, ok := p.name();
 	if !ok {
-		return;
+		return
 	}
 	i := strings.Index(s, ":");
 	if i < 0 {
-		name.Local = s;
+		name.Local = s
 	} else {
 		name.Space = s[0:i];
 		name.Local = s[i+1 : len(s)];
@@ -823,7 +823,7 @@ func (p *Parser) nsname() (name Name, ok bool) {
 func (p *Parser) name() (s string, ok bool) {
 	var b byte;
 	if b, ok = p.getc(); !ok {
-		return;
+		return
 	}
 
 	// As a first approximation, we gather the bytes [A-Za-z_:.-\x80-\xFF]*
@@ -835,7 +835,7 @@ func (p *Parser) name() (s string, ok bool) {
 	p.buf.WriteByte(b);
 	for {
 		if b, ok = p.getc(); !ok {
-			return;
+			return
 		}
 		if b < utf8.RuneSelf && !isNameByte(b) {
 			p.ungetc(b);
@@ -859,7 +859,7 @@ func isNameByte(c byte) bool {
 	return 'A' <= c && c <= 'Z' ||
 		'a' <= c && c <= 'z' ||
 		'0' <= c && c <= '9' ||
-		c == '_' || c == ':' || c == '.' || c == '-';
+		c == '_' || c == ':' || c == '.' || c == '-'
 }
 
 // These tables were generated by cut and paste from Appendix B of
diff --git a/src/pkg/xml/xml_test.go b/src/pkg/xml/xml_test.go
index 8b0fda60a5..058c1e7658 100644
--- a/src/pkg/xml/xml_test.go
+++ b/src/pkg/xml/xml_test.go
@@ -97,7 +97,7 @@ type stringReader struct {
 
 func (r *stringReader) Read(b []byte) (n int, err os.Error) {
 	if r.off >= len(r.s) {
-		return 0, os.EOF;
+		return 0, os.EOF
 	}
 	for r.off < len(r.s) && n < len(b) {
 		b[n] = r.s[r.off];
@@ -109,7 +109,7 @@ func (r *stringReader) Read(b []byte) (n int, err os.Error) {
 
 func (r *stringReader) ReadByte() (b byte, err os.Error) {
 	if r.off >= len(r.s) {
-		return 0, os.EOF;
+		return 0, os.EOF
 	}
 	b = r.s[r.off];
 	r.off++;
@@ -124,10 +124,10 @@ func TestRawToken(t *testing.T) {
 	for i, want := range rawTokens {
 		have, err := p.RawToken();
 		if err != nil {
-			t.Fatalf("token %d: unexpected error: %s", i, err);
+			t.Fatalf("token %d: unexpected error: %s", i, err)
 		}
 		if !reflect.DeepEqual(have, want) {
-			t.Errorf("token %d = %#v want %#v", i, have, want);
+			t.Errorf("token %d = %#v want %#v", i, have, want)
 		}
 	}
 }
@@ -138,10 +138,10 @@ func TestToken(t *testing.T) {
 	for i, want := range cookedTokens {
 		have, err := p.Token();
 		if err != nil {
-			t.Fatalf("token %d: unexpected error: %s", i, err);
+			t.Fatalf("token %d: unexpected error: %s", i, err)
 		}
 		if !reflect.DeepEqual(have, want) {
-			t.Errorf("token %d = %#v want %#v", i, have, want);
+			t.Errorf("token %d = %#v want %#v", i, have, want)
 		}
 	}
 }
