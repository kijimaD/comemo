commit eeddc8e73b72aabe3485120ac7b5ab60efc46f5b
Author: Robert Griesemer <gri@golang.org>
Date:   Thu Mar 26 16:10:07 2009 -0700

    - adjustments to match new token/scanner/ast
    
    R=r
    OCL=26794
    CL=26794
---
 usr/gri/pretty/compilation.go |  28 ++--
 usr/gri/pretty/gds.go         |  12 +-
 usr/gri/pretty/parser.go      | 313 +++++++++++++++++++++++-------------------
 usr/gri/pretty/printer.go     | 164 +++++++++++-----------
 usr/gri/pretty/typechecker.go |   4 +-
 5 files changed, 278 insertions(+), 243 deletions(-)

diff --git a/usr/gri/pretty/compilation.go b/usr/gri/pretty/compilation.go
index 8a9065ac97..8d74ea5b72 100644
--- a/usr/gri/pretty/compilation.go
+++ b/usr/gri/pretty/compilation.go
@@ -11,8 +11,9 @@ import (
 	"os";
 	"utils";
 	"platform";
+	"token";
 	"scanner";
-	Parser "parser";
+	"parser";
 	"ast";
 	"typechecker";
 	"sort";
@@ -34,7 +35,7 @@ type Flags struct {
 
 
 type Error struct {
-	Loc scanner.Location;
+	Pos token.Position;
 	Msg string;
 }
 
@@ -42,7 +43,7 @@ type Error struct {
 type ErrorList []Error
 
 func (list ErrorList) Len() int { return len(list); }
-func (list ErrorList) Less(i, j int) bool { return list[i].Loc.Pos < list[j].Loc.Pos; }
+func (list ErrorList) Less(i, j int) bool { return list[i].Pos.Offset < list[j].Pos.Offset; }
 func (list ErrorList) Swap(i, j int) { list[i], list[j] = list[j], list[i]; }
 
 
@@ -63,23 +64,23 @@ func (h *errorHandler) Init(filename string, src []byte, columns bool) {
 }
 
 
-func (h *errorHandler) Error(loc scanner.Location, msg string) {
+func (h *errorHandler) Error(pos token.Position, msg string) {
 	// only report errors that are on a new line 
 	// in the hope to avoid most follow-up errors
-	if loc.Line == h.errline {
+	if pos.Line == h.errline {
 		return;
 	}
 
 	// report error
-	fmt.Printf("%s:%d:", h.filename, loc.Line);
+	fmt.Printf("%s:%d:", h.filename, pos.Line);
 	if h.columns {
-		fmt.Printf("%d:", loc.Col);
+		fmt.Printf("%d:", pos.Column);
 	}
 	fmt.Printf(" %s\n", msg);
 
 	// collect the error
-	h.errors.Push(Error{loc, msg});
-	h.errline = loc.Line;
+	h.errors.Push(Error{pos, msg});
+	h.errline = pos.Line;
 }
 
 
@@ -96,10 +97,11 @@ func Compile(src_file string, flags *Flags) (*ast.Package, ErrorList) {
 	var scanner scanner.Scanner;
 	scanner.Init(src, &err, true);
 
-	var parser Parser.Parser;
-	parser.Init(&scanner, &err, flags.Verbose);
-
-	prog := parser.Parse(Parser.ParseEntirePackage);
+	pflags := uint(0);
+	if flags.Verbose {
+		pflags |= parser.Trace;
+	}
+	prog := parser.Parse(&scanner, &err, parser.ParseEntirePackage, pflags);
 
 	if err.errors.Len() == 0 {
 		TypeChecker.CheckProgram(&err, prog);
diff --git a/usr/gri/pretty/gds.go b/usr/gri/pretty/gds.go
index db4ce81af1..0fd331b3e8 100644
--- a/usr/gri/pretty/gds.go
+++ b/usr/gri/pretty/gds.go
@@ -124,20 +124,20 @@ func printErrors(c *http.Conn, filename string, errors Compilation.ErrorList) {
 				fmt.Fprintf(c, "could not read file %s\n", *root + filename);
 				return;
 			}
-			pos := 0;
+			offs := 0;
 			for i, e := range errors {
-				if 0 <= e.Loc.Pos && e.Loc.Pos <= len(src) {
+				if 0 <= e.Pos.Offset && e.Pos.Offset <= len(src) {
 					// TODO handle Write errors
-					c.Write(src[pos : e.Loc.Pos]);
+					c.Write(src[offs : e.Pos.Offset]);
 					// TODO this should be done using a .css file
 					fmt.Fprintf(c, "<b><font color=red>%s >>></font></b>", e.Msg);
-					pos = e.Loc.Pos;
+					offs = e.Pos.Offset;
 				} else {
-					log.Stdoutf("error position %d out of bounds (len = %d)", e.Loc.Pos, len(src));
+					log.Stdoutf("error position %d out of bounds (len = %d)", e.Pos.Offset, len(src));
 				}
 			}
 			// TODO handle Write errors
-			c.Write(src[pos : len(src)]);
+			c.Write(src[offs : len(src)]);
 		}
 	});
 }
diff --git a/usr/gri/pretty/parser.go b/usr/gri/pretty/parser.go
index d1de483b17..073fd2a014 100644
--- a/usr/gri/pretty/parser.go
+++ b/usr/gri/pretty/parser.go
@@ -6,37 +6,54 @@
 // provided via the Scanner interface. The output is an abstract syntax
 // tree (AST) representing the Go source.
 //
-// A client may parse the entire program (ParseProgram), only the package
-// clause (ParsePackageClause), or the package clause and the import
-// declarations (ParseImportDecls).
-//
-package Parser
+package parser
 
 import (
 	"fmt";
 	"vector";
 	"token";
-	"scanner";
 	"ast";
 )
 
 
-// TODO rename Position to scanner.Position, possibly factor out
-type Position scanner.Location
-
-
 type interval struct {
 	beg, end int;
 }
 
 
-// A Parser holds the parser's internal state while processing
-// a given text. It can be allocated as part of another data
-// structure but must be initialized via Init before use.
+// An implementation of a Scanner must be provided to the Parser.
+// The parser calls Scan() repeatedly until token.EOF is returned.
+// Scan must return the current token position pos, the token value
+// tok, and the corresponding token literal string lit if the token
+// is a literal (i.e., if tok.IsLiteral() is true).
+//
+type Scanner interface {
+	Scan() (pos token.Position, tok token.Token, lit []byte);
+}
+
+
+// An implementation of an ErrorHandler must be provided to the parser.
+// If a syntax error is encountered, Error is called with a position and
+// an error message. The position points to the beginning of the offending
+// token.
 //
-type Parser struct {
-	scanner *scanner.Scanner;
-	err scanner.ErrorHandler;
+type ErrorHandler interface {
+	Error(pos token.Position, msg string);
+}
+
+
+// The following flags control optional parser functionality. A set of
+// flags (or 0) must be provided as a parameter to the Parse function.
+//
+const (
+	Trace = 1 << iota;
+)
+
+
+// The parser structure holds the parser's internal state.
+type parser struct {
+	scanner Scanner;
+	err ErrorHandler;
 
 	// Tracing/debugging
 	trace bool;
@@ -46,9 +63,9 @@ type Parser struct {
 	last_doc interval;  // last comments interval of consecutive comments
 
 	// The next token
-	pos Position;  // token location
+	pos token.Position;  // token location
 	tok token.Token;  // one token look-ahead
-	val []byte;  // token value
+	lit []byte;  // token literal
 
 	// Non-syntactic parser control
 	opt_semi bool;  // true if semicolon separator is optional in statement list
@@ -58,7 +75,7 @@ type Parser struct {
 
 // When we don't have a location use nopos.
 // TODO make sure we always have a location.
-var nopos Position;
+var nopos token.Position;
 
 
 // ----------------------------------------------------------------------------
@@ -72,7 +89,7 @@ func unreachable() {
 // ----------------------------------------------------------------------------
 // Parsing support
 
-func (P *Parser) printIndent() {
+func (P *parser) printIndent() {
 	i := P.indent;
 	// reduce printing time by a factor of 2 or more
 	for ; i > 10; i -= 10 {
@@ -84,7 +101,7 @@ func (P *Parser) printIndent() {
 }
 
 
-func trace(P *Parser, msg string) *Parser {
+func trace(P *parser, msg string) *parser {
 	P.printIndent();
 	fmt.Printf("%s (\n", msg);
 	P.indent++;
@@ -92,30 +109,30 @@ func trace(P *Parser, msg string) *Parser {
 }
 
 
-func un/*trace*/(P *Parser) {
+func un/*trace*/(P *parser) {
 	P.indent--;
 	P.printIndent();
 	fmt.Printf(")\n");
 }
 
 
-func (P *Parser) next0() {
-	P.pos, P.tok, P.val = P.scanner.Scan();
+func (P *parser) next0() {
+	P.pos, P.tok, P.lit = P.scanner.Scan();
 	P.opt_semi = false;
 
 	if P.trace {
 		P.printIndent();
 		switch P.tok {
 		case token.IDENT, token.INT, token.FLOAT, token.CHAR, token.STRING:
-			fmt.Printf("%d:%d: %s = %s\n", P.pos.Line, P.pos.Col, P.tok.String(), P.val);
+			fmt.Printf("%d:%d: %s = %s\n", P.pos.Line, P.pos.Column, P.tok.String(), P.lit);
 		case token.LPAREN:
 			// don't print '(' - screws up selection in terminal window
-			fmt.Printf("%d:%d: LPAREN\n", P.pos.Line, P.pos.Col);
+			fmt.Printf("%d:%d: LPAREN\n", P.pos.Line, P.pos.Column);
 		case token.RPAREN:
 			// don't print ')' - screws up selection in terminal window
-			fmt.Printf("%d:%d: RPAREN\n", P.pos.Line, P.pos.Col);
+			fmt.Printf("%d:%d: RPAREN\n", P.pos.Line, P.pos.Column);
 		default:
-			fmt.Printf("%d:%d: %s\n", P.pos.Line, P.pos.Col, P.tok.String());
+			fmt.Printf("%d:%d: %s\n", P.pos.Line, P.pos.Column, P.tok.String());
 		}
 	}
 }
@@ -123,27 +140,27 @@ func (P *Parser) next0() {
 
 // Collect a comment in the parser's comment list and return the line
 // on which the comment ends.
-func (P *Parser) collectComment() int {
+func (P *parser) collectComment() int {
 	// For /*-style comments, the comment may end on a different line.
 	// Scan the comment for '\n' chars and adjust the end line accordingly.
 	// (Note that the position of the next token may be even further down
 	// as there may be more whitespace lines after the comment.)
 	endline := P.pos.Line;
-	if P.val[1] == '*' {
-		for i, b := range P.val {
+	if P.lit[1] == '*' {
+		for i, b := range P.lit {
 			if b == '\n' {
 				endline++;
 			}
 		}
 	}
-	P.comments.Push(&ast.Comment{P.pos, P.val, endline});
+	P.comments.Push(&ast.Comment{P.pos, P.lit, endline});
 	P.next0();
 	
 	return endline;
 }
 
 
-func (P *Parser) getComments() interval {
+func (P *parser) getComments() interval {
 	// group adjacent comments, an empty line terminates a group
 	beg := P.comments.Len();
 	endline := P.pos.Line;
@@ -155,7 +172,7 @@ func (P *Parser) getComments() interval {
 }
 
 
-func (P *Parser) next() {
+func (P *parser) next() {
 	P.next0();
 	P.last_doc = interval{0, 0};
 	for P.tok == token.COMMENT {
@@ -164,25 +181,16 @@ func (P *Parser) next() {
 }
 
 
-func (P *Parser) Init(scanner *scanner.Scanner, err scanner.ErrorHandler, trace bool) {
-	P.scanner = scanner;
-	P.err = err;
-	P.trace = trace;
-	P.comments.Init(0);
-	P.next();
-}
-
-
-func (P *Parser) error(pos Position, msg string) {
+func (P *parser) error(pos token.Position, msg string) {
 	P.err.Error(pos, msg);
 }
 
 
-func (P *Parser) expect(tok token.Token) Position {
+func (P *parser) expect(tok token.Token) token.Position {
 	if P.tok != tok {
 		msg := "expected '" + tok.String() + "', found '" + P.tok.String() + "'";
 		if P.tok.IsLiteral() {
-			msg += " " + string(P.val);
+			msg += " " + string(P.lit);
 		}
 		P.error(P.pos, msg);
 	}
@@ -192,7 +200,7 @@ func (P *Parser) expect(tok token.Token) Position {
 }
 
 
-func (P *Parser) getDoc() ast.Comments {
+func (P *parser) getDoc() ast.Comments {
 	doc := P.last_doc;
 	n := doc.end - doc.beg;
 	
@@ -217,19 +225,19 @@ func (P *Parser) getDoc() ast.Comments {
 // ----------------------------------------------------------------------------
 // Common productions
 
-func (P *Parser) tryType() ast.Expr;
-func (P *Parser) parseExpression(prec int) ast.Expr;
-func (P *Parser) parseStatement() ast.Stmt;
-func (P *Parser) parseDeclaration() ast.Decl;
+func (P *parser) tryType() ast.Expr;
+func (P *parser) parseExpression(prec int) ast.Expr;
+func (P *parser) parseStatement() ast.Stmt;
+func (P *parser) parseDeclaration() ast.Decl;
 
 
-func (P *Parser) parseIdent() *ast.Ident {
+func (P *parser) parseIdent() *ast.Ident {
 	if P.trace {
 		defer un(trace(P, "Ident"));
 	}
 
 	if P.tok == token.IDENT {
-		x := &ast.Ident{P.pos, P.val};
+		x := &ast.Ident{P.pos, P.lit};
 		P.next();
 		return x;
 	}
@@ -239,7 +247,7 @@ func (P *Parser) parseIdent() *ast.Ident {
 }
 
 
-func (P *Parser) parseIdentList(x ast.Expr) []*ast.Ident {
+func (P *parser) parseIdentList(x ast.Expr) []*ast.Ident {
 	if P.trace {
 		defer un(trace(P, "IdentList"));
 	}
@@ -264,7 +272,7 @@ func (P *Parser) parseIdentList(x ast.Expr) []*ast.Ident {
 }
 
 
-func (P *Parser) parseExpressionList() []ast.Expr {
+func (P *parser) parseExpressionList() []ast.Expr {
 	if P.trace {
 		defer un(trace(P, "ExpressionList"));
 	}
@@ -289,7 +297,7 @@ func (P *Parser) parseExpressionList() []ast.Expr {
 // ----------------------------------------------------------------------------
 // Types
 
-func (P *Parser) parseType() ast.Expr {
+func (P *parser) parseType() ast.Expr {
 	if P.trace {
 		defer un(trace(P, "Type"));
 	}
@@ -304,7 +312,7 @@ func (P *Parser) parseType() ast.Expr {
 }
 
 
-func (P *Parser) parseVarType() ast.Expr {
+func (P *parser) parseVarType() ast.Expr {
 	if P.trace {
 		defer un(trace(P, "VarType"));
 	}
@@ -313,7 +321,7 @@ func (P *Parser) parseVarType() ast.Expr {
 }
 
 
-func (P *Parser) parseQualifiedIdent() ast.Expr {
+func (P *parser) parseQualifiedIdent() ast.Expr {
 	if P.trace {
 		defer un(trace(P, "QualifiedIdent"));
 	}
@@ -328,7 +336,7 @@ func (P *Parser) parseQualifiedIdent() ast.Expr {
 }
 
 
-func (P *Parser) parseTypeName() ast.Expr {
+func (P *parser) parseTypeName() ast.Expr {
 	if P.trace {
 		defer un(trace(P, "TypeName"));
 	}
@@ -337,7 +345,7 @@ func (P *Parser) parseTypeName() ast.Expr {
 }
 
 
-func (P *Parser) parseArrayType() *ast.ArrayType {
+func (P *parser) parseArrayType() *ast.ArrayType {
 	if P.trace {
 		defer un(trace(P, "ArrayType"));
 	}
@@ -357,7 +365,7 @@ func (P *Parser) parseArrayType() *ast.ArrayType {
 }
 
 
-func (P *Parser) parseChannelType() *ast.ChannelType {
+func (P *parser) parseChannelType() *ast.ChannelType {
 	if P.trace {
 		defer un(trace(P, "ChannelType"));
 	}
@@ -381,7 +389,7 @@ func (P *Parser) parseChannelType() *ast.ChannelType {
 }
 
 
-func (P *Parser) tryParameterType() ast.Expr {
+func (P *parser) tryParameterType() ast.Expr {
 	if P.tok == token.ELLIPSIS {
 		loc  := P.pos;
 		P.next();
@@ -391,7 +399,7 @@ func (P *Parser) tryParameterType() ast.Expr {
 }
 
 
-func (P *Parser) parseParameterType() ast.Expr {
+func (P *parser) parseParameterType() ast.Expr {
 	typ := P.tryParameterType();
 	if typ == nil {
 		P.error(P.pos, "type expected");
@@ -402,7 +410,7 @@ func (P *Parser) parseParameterType() ast.Expr {
 }
 
 
-func (P *Parser) parseParameterDecl(ellipsis_ok bool) (*vector.Vector, ast.Expr) {
+func (P *parser) parseParameterDecl(ellipsis_ok bool) (*vector.Vector, ast.Expr) {
 	if P.trace {
 		defer un(trace(P, "ParameterDecl"));
 	}
@@ -426,7 +434,7 @@ func (P *Parser) parseParameterDecl(ellipsis_ok bool) (*vector.Vector, ast.Expr)
 }
 
 
-func (P *Parser) parseParameterList(ellipsis_ok bool) []*ast.Field {
+func (P *parser) parseParameterList(ellipsis_ok bool) []*ast.Field {
 	if P.trace {
 		defer un(trace(P, "ParameterList"));
 	}
@@ -468,7 +476,7 @@ func (P *Parser) parseParameterList(ellipsis_ok bool) []*ast.Field {
 
 
 // TODO make sure Go spec is updated
-func (P *Parser) parseParameters(ellipsis_ok bool) []*ast.Field {
+func (P *parser) parseParameters(ellipsis_ok bool) []*ast.Field {
 	if P.trace {
 		defer un(trace(P, "Parameters"));
 	}
@@ -484,7 +492,7 @@ func (P *Parser) parseParameters(ellipsis_ok bool) []*ast.Field {
 }
 
 
-func (P *Parser) parseResult() []*ast.Field {
+func (P *parser) parseResult() []*ast.Field {
 	if P.trace {
 		defer un(trace(P, "Result"));
 	}
@@ -510,7 +518,7 @@ func (P *Parser) parseResult() []*ast.Field {
 // (params) type
 // (params) (results)
 
-func (P *Parser) parseSignature() (params []*ast.Field, results []*ast.Field) {
+func (P *parser) parseSignature() (params []*ast.Field, results []*ast.Field) {
 	if P.trace {
 		defer un(trace(P, "Signature"));
 	}
@@ -522,7 +530,7 @@ func (P *Parser) parseSignature() (params []*ast.Field, results []*ast.Field) {
 }
 
 
-func (P *Parser) parseFunctionType() *ast.FunctionType {
+func (P *parser) parseFunctionType() *ast.FunctionType {
 	if P.trace {
 		defer un(trace(P, "FunctionType"));
 	}
@@ -534,7 +542,7 @@ func (P *Parser) parseFunctionType() *ast.FunctionType {
 }
 
 
-func (P *Parser) parseMethodSpec() *ast.Field {
+func (P *parser) parseMethodSpec() *ast.Field {
 	if P.trace {
 		defer un(trace(P, "MethodSpec"));
 	}
@@ -557,13 +565,13 @@ func (P *Parser) parseMethodSpec() *ast.Field {
 }
 
 
-func (P *Parser) parseInterfaceType() *ast.InterfaceType {
+func (P *parser) parseInterfaceType() *ast.InterfaceType {
 	if P.trace {
 		defer un(trace(P, "InterfaceType"));
 	}
 
 	pos := P.expect(token.INTERFACE);
-	var lbrace, rbrace Position;
+	var lbrace, rbrace token.Position;
 	var methods []*ast.Field;
 	if P.tok == token.LBRACE {
 		lbrace = P.pos;
@@ -591,7 +599,7 @@ func (P *Parser) parseInterfaceType() *ast.InterfaceType {
 }
 
 
-func (P *Parser) parseMapType() *ast.MapType {
+func (P *parser) parseMapType() *ast.MapType {
 	if P.trace {
 		defer un(trace(P, "MapType"));
 	}
@@ -606,9 +614,9 @@ func (P *Parser) parseMapType() *ast.MapType {
 }
 
 
-func (P *Parser) parseStringList(x *ast.StringLit) []*ast.StringLit
+func (P *parser) parseStringList(x *ast.StringLit) []*ast.StringLit
 
-func (P *Parser) parseFieldDecl() *ast.Field {
+func (P *parser) parseFieldDecl() *ast.Field {
 	if P.trace {
 		defer un(trace(P, "FieldDecl"));
 	}
@@ -662,13 +670,13 @@ func (P *Parser) parseFieldDecl() *ast.Field {
 }
 
 
-func (P *Parser) parseStructType() *ast.StructType {
+func (P *parser) parseStructType() *ast.StructType {
 	if P.trace {
 		defer un(trace(P, "StructType"));
 	}
 
 	pos := P.expect(token.STRUCT);
-	var lbrace, rbrace Position;
+	var lbrace, rbrace token.Position;
 	var fields []*ast.Field;
 	if P.tok == token.LBRACE {
 		lbrace = P.pos;
@@ -701,7 +709,7 @@ func (P *Parser) parseStructType() *ast.StructType {
 }
 
 
-func (P *Parser) parsePointerType() *ast.StarExpr {
+func (P *parser) parsePointerType() *ast.StarExpr {
 	if P.trace {
 		defer un(trace(P, "PointerType"));
 	}
@@ -713,7 +721,7 @@ func (P *Parser) parsePointerType() *ast.StarExpr {
 }
 
 
-func (P *Parser) tryType() ast.Expr {
+func (P *parser) tryType() ast.Expr {
 	if P.trace {
 		defer un(trace(P, "Type (try)"));
 	}
@@ -752,7 +760,7 @@ func asStmtList(list *vector.Vector) []ast.Stmt {
 }
 
 
-func (P *Parser) parseStatementList() []ast.Stmt {
+func (P *parser) parseStatementList() []ast.Stmt {
 	if P.trace {
 		defer un(trace(P, "StatementList"));
 	}
@@ -778,7 +786,7 @@ func (P *Parser) parseStatementList() []ast.Stmt {
 }
 
 
-func (P *Parser) parseBlockStmt() *ast.BlockStmt {
+func (P *parser) parseBlockStmt() *ast.BlockStmt {
 	if P.trace {
 		defer un(trace(P, "compositeStmt"));
 	}
@@ -795,7 +803,7 @@ func (P *Parser) parseBlockStmt() *ast.BlockStmt {
 // ----------------------------------------------------------------------------
 // Expressions
 
-func (P *Parser) parseFunctionLit() ast.Expr {
+func (P *parser) parseFunctionLit() ast.Expr {
 	if P.trace {
 		defer un(trace(P, "FunctionLit"));
 	}
@@ -809,7 +817,7 @@ func (P *Parser) parseFunctionLit() ast.Expr {
 }
 
 
-func (P *Parser) parseStringList(x *ast.StringLit) []*ast.StringLit {
+func (P *parser) parseStringList(x *ast.StringLit) []*ast.StringLit {
 	if P.trace {
 		defer un(trace(P, "StringList"));
 	}
@@ -820,7 +828,7 @@ func (P *Parser) parseStringList(x *ast.StringLit) []*ast.StringLit {
 	}
 	
 	for P.tok == token.STRING {
-		list.Push(&ast.StringLit{P.pos, P.val});
+		list.Push(&ast.StringLit{P.pos, P.lit});
 		P.next();
 	}
 
@@ -834,7 +842,7 @@ func (P *Parser) parseStringList(x *ast.StringLit) []*ast.StringLit {
 }
 
 
-func (P *Parser) parseOperand() ast.Expr {
+func (P *parser) parseOperand() ast.Expr {
 	if P.trace {
 		defer un(trace(P, "Operand"));
 	}
@@ -844,22 +852,22 @@ func (P *Parser) parseOperand() ast.Expr {
 		return P.parseIdent();
 
 	case token.INT:
-		x := &ast.IntLit{P.pos, P.val};
+		x := &ast.IntLit{P.pos, P.lit};
 		P.next();
 		return x;
 
 	case token.FLOAT:
-		x := &ast.FloatLit{P.pos, P.val};
+		x := &ast.FloatLit{P.pos, P.lit};
 		P.next();
 		return x;
 
 	case token.CHAR:
-		x := &ast.CharLit{P.pos, P.val};
+		x := &ast.CharLit{P.pos, P.lit};
 		P.next();
 		return x;
 
 	case token.STRING:
-		x := &ast.StringLit{P.pos, P.val};
+		x := &ast.StringLit{P.pos, P.lit};
 		P.next();
 		if P.tok == token.STRING {
 			return &ast.StringList{P.parseStringList(x)};
@@ -892,7 +900,7 @@ func (P *Parser) parseOperand() ast.Expr {
 }
 
 
-func (P *Parser) parseSelectorOrTypeAssertion(x ast.Expr) ast.Expr {
+func (P *parser) parseSelectorOrTypeAssertion(x ast.Expr) ast.Expr {
 	if P.trace {
 		defer un(trace(P, "SelectorOrTypeAssertion"));
 	}
@@ -909,7 +917,7 @@ func (P *Parser) parseSelectorOrTypeAssertion(x ast.Expr) ast.Expr {
 		var typ ast.Expr;
 		if P.tok == token.TYPE {
 			// special case for type switch syntax
-			typ = &ast.Ident{P.pos, P.val};
+			typ = &ast.Ident{P.pos, P.lit};
 			P.next();
 		} else {
 			typ = P.parseType();
@@ -923,7 +931,7 @@ func (P *Parser) parseSelectorOrTypeAssertion(x ast.Expr) ast.Expr {
 }
 
 
-func (P *Parser) parseIndexOrSlice(x ast.Expr) ast.Expr {
+func (P *parser) parseIndexOrSlice(x ast.Expr) ast.Expr {
 	if P.trace {
 		defer un(trace(P, "IndexOrSlice"));
 	}
@@ -949,7 +957,7 @@ func (P *Parser) parseIndexOrSlice(x ast.Expr) ast.Expr {
 }
 
 
-func (P *Parser) parseCall(fun ast.Expr) *ast.CallExpr {
+func (P *parser) parseCall(fun ast.Expr) *ast.CallExpr {
 	if P.trace {
 		defer un(trace(P, "Call"));
 	}
@@ -964,7 +972,7 @@ func (P *Parser) parseCall(fun ast.Expr) *ast.CallExpr {
 }
 
 
-func (P *Parser) parseElementList() []ast.Expr {
+func (P *parser) parseElementList() []ast.Expr {
 	if P.trace {
 		defer un(trace(P, "ElementList"));
 	}
@@ -975,17 +983,17 @@ func (P *Parser) parseElementList() []ast.Expr {
 		x := P.parseExpression(0);
 		if list.Len() == 0 {
 			// first element determines syntax for remaining elements
-			if t, is_binary := x.(*ast.BinaryExpr); is_binary && t.Tok == token.COLON {
+			if t, is_binary := x.(*ast.BinaryExpr); is_binary && t.Op == token.COLON {
 				singles = false;
 			}
 		} else {
 			// not the first element - check syntax
 			if singles {
-				if t, is_binary := x.(*ast.BinaryExpr); is_binary && t.Tok == token.COLON {
+				if t, is_binary := x.(*ast.BinaryExpr); is_binary && t.Op == token.COLON {
 					P.error(t.X.Pos(), "single value expected; found pair");
 				}
 			} else {
-				if t, is_binary := x.(*ast.BinaryExpr); !is_binary || t.Tok != token.COLON {
+				if t, is_binary := x.(*ast.BinaryExpr); !is_binary || t.Op != token.COLON {
 					P.error(x.Pos(), "key:value pair expected; found single value");
 				}
 			}
@@ -1010,7 +1018,7 @@ func (P *Parser) parseElementList() []ast.Expr {
 }
 
 
-func (P *Parser) parseCompositeLit(typ ast.Expr) ast.Expr {
+func (P *parser) parseCompositeLit(typ ast.Expr) ast.Expr {
 	if P.trace {
 		defer un(trace(P, "CompositeLit"));
 	}
@@ -1025,7 +1033,7 @@ func (P *Parser) parseCompositeLit(typ ast.Expr) ast.Expr {
 }
 
 
-func (P *Parser) parsePrimaryExpr() ast.Expr {
+func (P *parser) parsePrimaryExpr() ast.Expr {
 	if P.trace {
 		defer un(trace(P, "PrimaryExpr"));
 	}
@@ -1052,7 +1060,7 @@ func (P *Parser) parsePrimaryExpr() ast.Expr {
 }
 
 
-func (P *Parser) parseUnaryExpr() ast.Expr {
+func (P *parser) parseUnaryExpr() ast.Expr {
 	if P.trace {
 		defer un(trace(P, "UnaryExpr"));
 	}
@@ -1076,7 +1084,7 @@ func (P *Parser) parseUnaryExpr() ast.Expr {
 }
 
 
-func (P *Parser) parseBinaryExpr(prec1 int) ast.Expr {
+func (P *parser) parseBinaryExpr(prec1 int) ast.Expr {
 	if P.trace {
 		defer un(trace(P, "BinaryExpr"));
 	}
@@ -1095,7 +1103,7 @@ func (P *Parser) parseBinaryExpr(prec1 int) ast.Expr {
 }
 
 
-func (P *Parser) parseExpression(prec int) ast.Expr {
+func (P *parser) parseExpression(prec int) ast.Expr {
 	if P.trace {
 		defer un(trace(P, "Expression"));
 	}
@@ -1112,7 +1120,7 @@ func (P *Parser) parseExpression(prec int) ast.Expr {
 // Statements
 
 
-func (P *Parser) parseSimpleStmt() ast.Stmt {
+func (P *parser) parseSimpleStmt() ast.Stmt {
 	if P.trace {
 		defer un(trace(P, "SimpleStmt"));
 	}
@@ -1163,7 +1171,7 @@ func (P *Parser) parseSimpleStmt() ast.Stmt {
 }
 
 
-func (P *Parser) parseCallExpr() *ast.CallExpr {
+func (P *parser) parseCallExpr() *ast.CallExpr {
 	x := P.parseExpression(1);
 	if call, is_call := x.(*ast.CallExpr); is_call {
 		return call;
@@ -1173,7 +1181,7 @@ func (P *Parser) parseCallExpr() *ast.CallExpr {
 }
 
 
-func (P *Parser) parseGoStmt() ast.Stmt {
+func (P *parser) parseGoStmt() ast.Stmt {
 	if P.trace {
 		defer un(trace(P, "GoStmt"));
 	}
@@ -1187,7 +1195,7 @@ func (P *Parser) parseGoStmt() ast.Stmt {
 }
 
 
-func (P *Parser) parseDeferStmt() ast.Stmt {
+func (P *parser) parseDeferStmt() ast.Stmt {
 	if P.trace {
 		defer un(trace(P, "DeferStmt"));
 	}
@@ -1201,7 +1209,7 @@ func (P *Parser) parseDeferStmt() ast.Stmt {
 }
 
 
-func (P *Parser) parseReturnStmt() *ast.ReturnStmt {
+func (P *parser) parseReturnStmt() *ast.ReturnStmt {
 	if P.trace {
 		defer un(trace(P, "ReturnStmt"));
 	}
@@ -1217,7 +1225,7 @@ func (P *Parser) parseReturnStmt() *ast.ReturnStmt {
 }
 
 
-func (P *Parser) parseBranchStmt(tok token.Token) *ast.BranchStmt {
+func (P *parser) parseBranchStmt(tok token.Token) *ast.BranchStmt {
 	if P.trace {
 		defer un(trace(P, "BranchStmt"));
 	}
@@ -1232,7 +1240,7 @@ func (P *Parser) parseBranchStmt(tok token.Token) *ast.BranchStmt {
 }
 
 
-func (P *Parser) isExpr(s ast.Stmt) bool {
+func (P *parser) isExpr(s ast.Stmt) bool {
 	if s == nil {
 		return true;
 	}
@@ -1241,7 +1249,7 @@ func (P *Parser) isExpr(s ast.Stmt) bool {
 }
 
 
-func (P *Parser) asExpr(s ast.Stmt) ast.Expr {
+func (P *parser) asExpr(s ast.Stmt) ast.Expr {
 	if s == nil {
 		return nil;
 	}
@@ -1253,7 +1261,7 @@ func (P *Parser) asExpr(s ast.Stmt) ast.Expr {
 }
 
 
-func (P *Parser) parseControlClause(isForStmt bool) (s1, s2, s3 ast.Stmt) {
+func (P *parser) parseControlClause(isForStmt bool) (s1, s2, s3 ast.Stmt) {
 	if P.trace {
 		defer un(trace(P, "ControlClause"));
 	}
@@ -1288,7 +1296,7 @@ func (P *Parser) parseControlClause(isForStmt bool) (s1, s2, s3 ast.Stmt) {
 }
 
 
-func (P *Parser) parseIfStmt() *ast.IfStmt {
+func (P *parser) parseIfStmt() *ast.IfStmt {
 	if P.trace {
 		defer un(trace(P, "IfStmt"));
 	}
@@ -1306,7 +1314,7 @@ func (P *Parser) parseIfStmt() *ast.IfStmt {
 }
 
 
-func (P *Parser) parseCaseClause() *ast.CaseClause {
+func (P *parser) parseCaseClause() *ast.CaseClause {
 	if P.trace {
 		defer un(trace(P, "CaseClause"));
 	}
@@ -1328,7 +1336,7 @@ func (P *Parser) parseCaseClause() *ast.CaseClause {
 }
 
 
-func (P *Parser) parseTypeCaseClause() *ast.TypeCaseClause {
+func (P *parser) parseTypeCaseClause() *ast.TypeCaseClause {
 	if P.trace {
 		defer un(trace(P, "CaseClause"));
 	}
@@ -1350,7 +1358,7 @@ func (P *Parser) parseTypeCaseClause() *ast.TypeCaseClause {
 }
 
 
-func (P *Parser) parseSwitchStmt() ast.Stmt {
+func (P *parser) parseSwitchStmt() ast.Stmt {
 	if P.trace {
 		defer un(trace(P, "SwitchStmt"));
 	}
@@ -1389,7 +1397,7 @@ func (P *Parser) parseSwitchStmt() ast.Stmt {
 }
 
 
-func (P *Parser) parseCommClause() *ast.CommClause {
+func (P *parser) parseCommClause() *ast.CommClause {
 	if P.trace {
 		defer un(trace(P, "CommClause"));
 	}
@@ -1430,7 +1438,7 @@ func (P *Parser) parseCommClause() *ast.CommClause {
 }
 
 
-func (P *Parser) parseSelectStmt() *ast.SelectStmt {
+func (P *parser) parseSelectStmt() *ast.SelectStmt {
 	if P.trace {
 		defer un(trace(P, "SelectStmt"));
 	}
@@ -1449,7 +1457,7 @@ func (P *Parser) parseSelectStmt() *ast.SelectStmt {
 }
 
 
-func (P *Parser) parseForStmt() ast.Stmt {
+func (P *parser) parseForStmt() ast.Stmt {
 	if P.trace {
 		defer un(trace(P, "ForStmt"));
 	}
@@ -1461,7 +1469,7 @@ func (P *Parser) parseForStmt() ast.Stmt {
 	if as, is_as := s2.(*ast.AssignStmt); is_as {
 		// possibly a for statement with a range clause; check assignment operator
 		if as.Tok != token.ASSIGN && as.Tok != token.DEFINE {
-			P.error(as.Pos_, "'=' or ':=' expected");
+			P.error(as.TokPos, "'=' or ':=' expected");
 			return &ast.BadStmt{pos};
 		}
 		// check lhs
@@ -1481,9 +1489,9 @@ func (P *Parser) parseForStmt() ast.Stmt {
 			P.error(as.Rhs[0].Pos(), "expected 1 expressions");
 			return &ast.BadStmt{pos};
 		}
-		if rhs, is_unary := as.Rhs[0].(*ast.UnaryExpr); is_unary && rhs.Tok == token.RANGE {
+		if rhs, is_unary := as.Rhs[0].(*ast.UnaryExpr); is_unary && rhs.Op == token.RANGE {
 			// rhs is range expression; check lhs
-			return &ast.RangeStmt{pos, key, value, as.Pos_, as.Tok, rhs.X, body}
+			return &ast.RangeStmt{pos, key, value, as.TokPos, as.Tok, rhs.X, body}
 		} else {
 			P.error(s2.Pos(), "range clause expected");
 			return &ast.BadStmt{pos};
@@ -1498,7 +1506,7 @@ func (P *Parser) parseForStmt() ast.Stmt {
 }
 
 
-func (P *Parser) parseStatement() ast.Stmt {
+func (P *parser) parseStatement() ast.Stmt {
 	if P.trace {
 		defer un(trace(P, "Statement"));
 	}
@@ -1544,7 +1552,7 @@ func (P *Parser) parseStatement() ast.Stmt {
 // ----------------------------------------------------------------------------
 // Declarations
 
-func (P *Parser) parseImportSpec(pos Position, doc ast.Comments) *ast.ImportDecl {
+func (P *parser) parseImportSpec(pos token.Position, doc ast.Comments) *ast.ImportDecl {
 	if P.trace {
 		defer un(trace(P, "ImportSpec"));
 	}
@@ -1568,7 +1576,7 @@ func (P *Parser) parseImportSpec(pos Position, doc ast.Comments) *ast.ImportDecl
 }
 
 
-func (P *Parser) parseConstSpec(pos Position, doc ast.Comments) *ast.ConstDecl {
+func (P *parser) parseConstSpec(pos token.Position, doc ast.Comments) *ast.ConstDecl {
 	if P.trace {
 		defer un(trace(P, "ConstSpec"));
 	}
@@ -1585,7 +1593,7 @@ func (P *Parser) parseConstSpec(pos Position, doc ast.Comments) *ast.ConstDecl {
 }
 
 
-func (P *Parser) parseTypeSpec(pos Position, doc ast.Comments) *ast.TypeDecl {
+func (P *parser) parseTypeSpec(pos token.Position, doc ast.Comments) *ast.TypeDecl {
 	if P.trace {
 		defer un(trace(P, "TypeSpec"));
 	}
@@ -1597,7 +1605,7 @@ func (P *Parser) parseTypeSpec(pos Position, doc ast.Comments) *ast.TypeDecl {
 }
 
 
-func (P *Parser) parseVarSpec(pos Position, doc ast.Comments) *ast.VarDecl {
+func (P *parser) parseVarSpec(pos token.Position, doc ast.Comments) *ast.VarDecl {
 	if P.trace {
 		defer un(trace(P, "VarSpec"));
 	}
@@ -1614,7 +1622,7 @@ func (P *Parser) parseVarSpec(pos Position, doc ast.Comments) *ast.VarDecl {
 }
 
 
-func (P *Parser) parseSpec(pos Position, doc ast.Comments, keyword int) ast.Decl {
+func (P *parser) parseSpec(pos token.Position, doc ast.Comments, keyword int) ast.Decl {
 	switch keyword {
 	case token.IMPORT: return P.parseImportSpec(pos, doc);
 	case token.CONST: return P.parseConstSpec(pos, doc);
@@ -1627,7 +1635,7 @@ func (P *Parser) parseSpec(pos Position, doc ast.Comments, keyword int) ast.Decl
 }
 
 
-func (P *Parser) parseDecl(keyword int) ast.Decl {
+func (P *parser) parseDecl(keyword int) ast.Decl {
 	if P.trace {
 		defer un(trace(P, "Decl"));
 	}
@@ -1671,7 +1679,7 @@ func (P *Parser) parseDecl(keyword int) ast.Decl {
 // func (recv) ident (params) type
 // func (recv) ident (params) (results)
 
-func (P *Parser) parseFunctionDecl() *ast.FuncDecl {
+func (P *parser) parseFunctionDecl() *ast.FuncDecl {
 	if P.trace {
 		defer un(trace(P, "FunctionDecl"));
 	}
@@ -1702,7 +1710,7 @@ func (P *Parser) parseFunctionDecl() *ast.FuncDecl {
 }
 
 
-func (P *Parser) parseDeclaration() ast.Decl {
+func (P *parser) parseDeclaration() ast.Decl {
 	if P.trace {
 		defer un(trace(P, "Declaration"));
 	}
@@ -1722,23 +1730,18 @@ func (P *Parser) parseDeclaration() ast.Decl {
 
 
 // ----------------------------------------------------------------------------
-// Program
+// Packages
 
-// The Parse function is parametrized with one of the following
-// constants. They control how much of the source text is parsed.
-//
+// The Mode constants control how much of the source text is parsed.
+type Mode int;
 const (
-	ParseEntirePackage = iota;
+	ParseEntirePackage Mode = iota;
 	ParseImportDeclsOnly;
 	ParsePackageClauseOnly;
 )
 
 
-// Parse parses the source...
-//      
-// foo bar
-//
-func (P *Parser) Parse(mode int) *ast.Package {
+func (P *parser) parsePackage(mode Mode) *ast.Package {
 	if P.trace {
 		defer un(trace(P, "Program"));
 	}
@@ -1793,3 +1796,33 @@ func (P *Parser) Parse(mode int) *ast.Package {
 
 	return &ast.Package{comment, pos, name, decls, comments};
 }
+
+
+// ----------------------------------------------------------------------------
+// Parsing of entire programs.
+
+// Parse invokes the Go parser. It calls the scanner's Scan method repeatedly
+// to obtain the token sequence corresponding to the source code. The sequence
+// is parsed according to Go syntax and the corresponding abstract syntax tree
+// is constructed. The error handler err will be used to report syntax errors.
+//
+// If no syntax errors were encountered (i.e., if the error handler was never
+// called), the result is a correct AST. If errors were encountered, the AST
+// may only be constructed partially, with ast.BadX nodes representing the
+// fragments of source code that contained syntax errors.
+//
+// The amount of source text parsed can be controlled with the mode parameter.
+// The flags parameter controls optional parser functionality such as tracing.
+//
+func Parse(scanner Scanner, err ErrorHandler, mode Mode, flags uint) *ast.Package {
+	// initialize parser state
+	var p parser;
+	p.scanner = scanner;
+	p.err = err;
+	p.trace = flags & Trace != 0;
+	p.comments.Init(0);
+	p.next();
+
+	// parse program
+	return p.parsePackage(mode);
+}
diff --git a/usr/gri/pretty/printer.go b/usr/gri/pretty/printer.go
index f59fb9d917..024e44d54e 100644
--- a/usr/gri/pretty/printer.go
+++ b/usr/gri/pretty/printer.go
@@ -37,9 +37,9 @@ var (
 )
 
 
-// When we don't have a location use nopos.
-// TODO make sure we always have a location.
-var nopos scanner.Location;
+// When we don't have a position use nopos.
+// TODO make sure we always have a position.
+var nopos token.Position;
 
 
 // ----------------------------------------------------------------------------
@@ -112,10 +112,10 @@ type Printer struct {
 	// comments
 	comments []*ast.Comment;  // the list of unassociated comments 
 	cindex int;  // the current comment group index
-	cloc scanner.Location;  // the position of the next comment group
+	cpos token.Position;  // the position of the next comment group
 
 	// current state
-	lastloc scanner.Location;  // location after last string
+	lastpos token.Position;  // position after last string
 	level int;  // scope level
 	indentation int;  // indentation level (may be different from scope level)
 
@@ -133,17 +133,17 @@ type Printer struct {
 }
 
 
-func (P *Printer) hasComment(loc scanner.Location) bool {
-	return *comments && P.cloc.Pos < loc.Pos;
+func (P *Printer) hasComment(pos token.Position) bool {
+	return *comments && P.cpos.Offset < pos.Offset;
 }
 
 
 func (P *Printer) nextComments() {
 	P.cindex++;
 	if P.comments != nil && P.cindex < len(P.comments) && P.comments[P.cindex] != nil {
-		P.cloc = P.comments[P.cindex].Pos_;
+		P.cpos = P.comments[P.cindex].Pos();
 	} else {
-		P.cloc = scanner.Location{1<<30, 1<<30, 1};  // infinite
+		P.cpos = token.Position{1<<30, 1<<30, 1};  // infinite
 	}
 }
 
@@ -228,11 +228,11 @@ func (P *Printer) newline(n int) {
 }
 
 
-func (P *Printer) TaggedString(loc scanner.Location, tag, s, endtag string) {
+func (P *Printer) TaggedString(pos token.Position, tag, s, endtag string) {
 	// use estimate for pos if we don't have one
-	pos := loc.Pos;
-	if pos == 0 {
-		pos = P.lastloc.Pos;
+	offs := pos.Offset;
+	if offs == 0 {
+		offs = P.lastpos.Offset;
 	}
 
 	// --------------------------------
@@ -271,18 +271,18 @@ func (P *Printer) TaggedString(loc scanner.Location, tag, s, endtag string) {
 	// interleave comments, if any
 	nlcount := 0;
 	if P.full {
-		for ; P.hasComment(loc); P.nextComments() {
+		for ; P.hasComment(pos); P.nextComments() {
 			// we have a comment group that comes before the string
 			comment := P.comments[P.cindex];
 			ctext := string(comment.Text);  // TODO get rid of string conversion here
 
 			// classify comment (len(ctext) >= 2)
 			//-style comment
-			if nlcount > 0 || P.cloc.Pos == 0 {
+			if nlcount > 0 || P.cpos.Offset == 0 {
 				// only white space before comment on this line
 				// or file starts with comment
 				// - indent
-				if !*newlines && P.cloc.Pos != 0 {
+				if !*newlines && P.cpos.Offset != 0 {
 					nlcount = 1;
 				}
 				P.newline(nlcount);
@@ -318,7 +318,7 @@ func (P *Printer) TaggedString(loc scanner.Location, tag, s, endtag string) {
 
 			// print comment
 			if *debug {
-				P.Printf("[%d]", P.cloc.Pos);
+				P.Printf("[%d]", P.cpos.Offset);
 			}
 			// calling untabify increases the change for idempotent output
 			// since tabs in comments are also interpreted by tabwriter
@@ -382,25 +382,25 @@ func (P *Printer) TaggedString(loc scanner.Location, tag, s, endtag string) {
 	// --------------------------------
 	// done
 	P.opt_semi = false;
-	loc.Pos += len(s);  // rough estimate
-	loc.Col += len(s);  // rough estimate
-	P.lastloc = loc;
+	pos.Offset += len(s);  // rough estimate
+	pos.Column += len(s);  // rough estimate
+	P.lastpos = pos;
 }
 
 
-func (P *Printer) String(loc scanner.Location, s string) {
-	P.TaggedString(loc, "", s, "");
+func (P *Printer) String(pos token.Position, s string) {
+	P.TaggedString(pos, "", s, "");
 }
 
 
-func (P *Printer) Token(loc scanner.Location, tok token.Token) {
-	P.String(loc, tok.String());
+func (P *Printer) Token(pos token.Position, tok token.Token) {
+	P.String(pos, tok.String());
 	//P.TaggedString(pos, "<b>", tok.String(), "</b>");
 }
 
 
-func (P *Printer) Error(loc scanner.Location, tok token.Token, msg string) {
-	fmt.Printf("\ninternal printing error: pos = %d, tok = %s, %s\n", loc.Pos, tok.String(), msg);
+func (P *Printer) Error(pos token.Position, tok token.Token, msg string) {
+	fmt.Printf("\ninternal printing error: pos = %d, tok = %s, %s\n", pos.Offset, tok.String(), msg);
 	panic();
 }
 
@@ -409,7 +409,7 @@ func (P *Printer) Error(loc scanner.Location, tok token.Token, msg string) {
 // HTML support
 
 func (P *Printer) HtmlIdentifier(x *ast.Ident) {
-	P.String(x.Pos_, string(x.Lit));
+	P.String(x.Pos(), string(x.Lit));
 	/*
 	obj := x.Obj;
 	if P.html && obj.Kind != symbolTable.NONE {
@@ -430,13 +430,13 @@ func (P *Printer) HtmlIdentifier(x *ast.Ident) {
 }
 
 
-func (P *Printer) HtmlPackageName(loc scanner.Location, name string) {
+func (P *Printer) HtmlPackageName(pos token.Position, name string) {
 	if P.html {
 		sname := name[1 : len(name)-1];  // strip quotes  TODO do this elsewhere eventually
 		// TODO CAPITAL HACK BELOW FIX THIS
-		P.TaggedString(loc, `"<a href="/src/lib/` + sname + `.go">`, sname, `</a>"`);
+		P.TaggedString(pos, `"<a href="/src/lib/` + sname + `.go">`, sname, `</a>"`);
 	} else {
-		P.String(loc, name);
+		P.String(pos, name);
 	}
 }
 
@@ -515,7 +515,7 @@ func (P *Printer) Signature(params, result []*ast.Field) {
 }
 
 
-func (P *Printer) Fields(lbrace scanner.Location, list []*ast.Field, rbrace scanner.Location, is_interface bool) {
+func (P *Printer) Fields(lbrace token.Position, list []*ast.Field, rbrace token.Position, is_interface bool) {
 	P.state = opening_scope;
 	P.separator = blank;
 	P.Token(lbrace, token.LBRACE);
@@ -576,13 +576,13 @@ func (P *Printer) DoIdent(x *ast.Ident) {
 
 
 func (P *Printer) DoBinaryExpr(x *ast.BinaryExpr) {
-	prec := x.Tok.Precedence();
+	prec := x.Op.Precedence();
 	if prec < P.prec {
 		P.Token(nopos, token.LPAREN);
 	}
 	P.Expr1(x.X, prec);
 	P.separator = blank;
-	P.Token(x.Pos_, x.Tok);
+	P.Token(x.OpPos, x.Op);
 	P.separator = blank;
 	P.Expr1(x.Y, prec);
 	if prec < P.prec {
@@ -592,7 +592,7 @@ func (P *Printer) DoBinaryExpr(x *ast.BinaryExpr) {
 
 
 func (P *Printer) DoStarExpr(x *ast.StarExpr) {
-	P.Token(x.Star, token.MUL);
+	P.Token(x.Pos(), token.MUL);
 	P.Expr(x.X);
 }
 
@@ -602,8 +602,8 @@ func (P *Printer) DoUnaryExpr(x *ast.UnaryExpr) {
 	if prec < P.prec {
 		P.Token(nopos, token.LPAREN);
 	}
-	P.Token(x.Pos_, x.Tok);
-	if x.Tok == token.RANGE {
+	P.Token(x.Pos(), x.Op);
+	if x.Op == token.RANGE {
 		P.separator = blank;
 	}
 	P.Expr1(x.X, prec);
@@ -615,25 +615,25 @@ func (P *Printer) DoUnaryExpr(x *ast.UnaryExpr) {
 
 func (P *Printer) DoIntLit(x *ast.IntLit) {
 	// TODO get rid of string conversion here
-	P.String(x.Pos_, string(x.Lit));
+	P.String(x.Pos(), string(x.Lit));
 }
 
 
 func (P *Printer) DoFloatLit(x *ast.FloatLit) {
 	// TODO get rid of string conversion here
-	P.String(x.Pos_, string(x.Lit));
+	P.String(x.Pos(), string(x.Lit));
 }
 
 
 func (P *Printer) DoCharLit(x *ast.CharLit) {
 	// TODO get rid of string conversion here
-	P.String(x.Pos_, string(x.Lit));
+	P.String(x.Pos(), string(x.Lit));
 }
 
 
 func (P *Printer) DoStringLit(x *ast.StringLit) {
 	// TODO get rid of string conversion here
-	P.String(x.Pos_, string(x.Lit));
+	P.String(x.Pos(), string(x.Lit));
 }
 
 
@@ -658,7 +658,7 @@ func (P *Printer) DoFunctionLit(x *ast.FunctionLit) {
 
 
 func (P *Printer) DoParenExpr(x *ast.ParenExpr) {
-	P.Token(x.Lparen, token.LPAREN);
+	P.Token(x.Pos(), token.LPAREN);
 	P.Expr(x.X);
 	P.Token(x.Rparen, token.RPAREN);
 }
@@ -715,12 +715,12 @@ func (P *Printer) DoCompositeLit(x *ast.CompositeLit) {
 
 
 func (P *Printer) DoEllipsis(x *ast.Ellipsis) {
-	P.Token(x.Pos_, token.ELLIPSIS);
+	P.Token(x.Pos(), token.ELLIPSIS);
 }
 
 
 func (P *Printer) DoArrayType(x *ast.ArrayType) {
-	P.Token(x.Lbrack, token.LBRACK);
+	P.Token(x.Pos(), token.LBRACK);
 	if x.Len != nil {
 		P.Expr(x.Len);
 	}
@@ -730,7 +730,7 @@ func (P *Printer) DoArrayType(x *ast.ArrayType) {
 
 
 func (P *Printer) DoStructType(x *ast.StructType) {
-	P.Token(x.Struct, token.STRUCT);
+	P.Token(x.Pos(), token.STRUCT);
 	if x.Fields != nil {
 		P.Fields(x.Lbrace, x.Fields, x.Rbrace, false);
 	}
@@ -738,13 +738,13 @@ func (P *Printer) DoStructType(x *ast.StructType) {
 
 
 func (P *Printer) DoFunctionType(x *ast.FunctionType) {
-	P.Token(x.Func, token.FUNC);
+	P.Token(x.Pos(), token.FUNC);
 	P.Signature(x.Params, x.Results);
 }
 
 
 func (P *Printer) DoInterfaceType(x *ast.InterfaceType) {
-	P.Token(x.Interface, token.INTERFACE);
+	P.Token(x.Pos(), token.INTERFACE);
 	if x.Methods != nil {
 		P.Fields(x.Lbrace, x.Methods, x.Rbrace, true);
 	}
@@ -757,7 +757,7 @@ func (P *Printer) DoSliceType(x *ast.SliceType) {
 
 
 func (P *Printer) DoMapType(x *ast.MapType) {
-	P.Token(x.Map, token.MAP);
+	P.Token(x.Pos(), token.MAP);
 	P.separator = blank;
 	P.Token(nopos, token.LBRACK);
 	P.Expr(x.Key);
@@ -769,12 +769,12 @@ func (P *Printer) DoMapType(x *ast.MapType) {
 func (P *Printer) DoChannelType(x *ast.ChannelType) {
 	switch x.Dir {
 	case ast.SEND | ast.RECV:
-		P.Token(x.Pos_, token.CHAN);
+		P.Token(x.Pos(), token.CHAN);
 	case ast.RECV:
-		P.Token(x.Pos_, token.ARROW);
+		P.Token(x.Pos(), token.ARROW);
 		P.Token(nopos, token.CHAN);
 	case ast.SEND:
-		P.Token(x.Pos_, token.CHAN);
+		P.Token(x.Pos(), token.CHAN);
 		P.separator = blank;
 		P.Token(nopos, token.ARROW);
 	}
@@ -821,7 +821,7 @@ func (P *Printer) DoDeclStmt(s *ast.DeclStmt) {
 
 
 func (P *Printer) DoEmptyStmt(s *ast.EmptyStmt) {
-	P.String(s.Semicolon, "");
+	P.String(s.Pos(), "");
 }
 
 
@@ -850,35 +850,35 @@ func (P *Printer) DoIncDecStmt(s *ast.IncDecStmt) {
 func (P *Printer) DoAssignStmt(s *ast.AssignStmt) {
 	P.Exprs(s.Lhs);
 	P.separator = blank;
-	P.Token(s.Pos_, s.Tok);
+	P.Token(s.TokPos, s.Tok);
 	P.separator = blank;
 	P.Exprs(s.Rhs);
 }
 
 
 func (P *Printer) DoGoStmt(s *ast.GoStmt) {
-	P.Token(s.Go, token.GO);
+	P.Token(s.Pos(), token.GO);
 	P.separator = blank;
 	P.Expr(s.Call);
 }
 
 
 func (P *Printer) DoDeferStmt(s *ast.DeferStmt) {
-	P.Token(s.Defer, token.DEFER);
+	P.Token(s.Pos(), token.DEFER);
 	P.separator = blank;
 	P.Expr(s.Call);
 }
 
 
 func (P *Printer) DoReturnStmt(s *ast.ReturnStmt) {
-	P.Token(s.Return, token.RETURN);
+	P.Token(s.Pos(), token.RETURN);
 	P.separator = blank;
 	P.Exprs(s.Results);
 }
 
 
 func (P *Printer) DoBranchStmt(s *ast.BranchStmt) {
-	P.Token(s.Pos_, s.Tok);
+	P.Token(s.Pos(), s.Tok);
 	if s.Label != nil {
 		P.separator = blank;
 		P.Expr(s.Label);
@@ -932,7 +932,7 @@ func (P *Printer) Block(list []ast.Stmt, indent bool) {
 
 func (P *Printer) DoBlockStmt(s *ast.BlockStmt) {
 	P.state = opening_scope;
-	P.Token(s.Lbrace, token.LBRACE);
+	P.Token(s.Pos(), token.LBRACE);
 	P.StatementList(s.List);
 	if !*optsemicolons {
 		P.separator = none;
@@ -976,7 +976,7 @@ func (P *Printer) ControlClause(isForStmt bool, init ast.Stmt, expr ast.Expr, po
 
 
 func (P *Printer) DoIfStmt(s *ast.IfStmt) {
-	P.Token(s.If, token.IF);
+	P.Token(s.Pos(), token.IF);
 	P.ControlClause(false, s.Init, s.Cond, nil);
 	P.Stmt(s.Body);
 	if s.Else != nil {
@@ -990,11 +990,11 @@ func (P *Printer) DoIfStmt(s *ast.IfStmt) {
 
 func (P *Printer) DoCaseClause(s *ast.CaseClause) {
 	if s.Values != nil {
-		P.Token(s.Case, token.CASE);
+		P.Token(s.Pos(), token.CASE);
 		P.separator = blank;
 		P.Exprs(s.Values);
 	} else {
-		P.Token(s.Case, token.DEFAULT);
+		P.Token(s.Pos(), token.DEFAULT);
 	}
 	P.Token(s.Colon, token.COLON);
 	P.indentation++;
@@ -1005,7 +1005,7 @@ func (P *Printer) DoCaseClause(s *ast.CaseClause) {
 
 
 func (P *Printer) DoSwitchStmt(s *ast.SwitchStmt) {
-	P.Token(s.Switch, token.SWITCH);
+	P.Token(s.Pos(), token.SWITCH);
 	P.ControlClause(false, s.Init, s.Tag, nil);
 	P.Stmt(s.Body);
 }
@@ -1013,11 +1013,11 @@ func (P *Printer) DoSwitchStmt(s *ast.SwitchStmt) {
 
 func (P *Printer) DoTypeCaseClause(s *ast.TypeCaseClause) {
 	if s.Type != nil {
-		P.Token(s.Case, token.CASE);
+		P.Token(s.Pos(), token.CASE);
 		P.separator = blank;
 		P.Expr(s.Type);
 	} else {
-		P.Token(s.Case, token.DEFAULT);
+		P.Token(s.Pos(), token.DEFAULT);
 	}
 	P.Token(s.Colon, token.COLON);
 	P.indentation++;
@@ -1028,7 +1028,7 @@ func (P *Printer) DoTypeCaseClause(s *ast.TypeCaseClause) {
 
 
 func (P *Printer) DoTypeSwitchStmt(s *ast.TypeSwitchStmt) {
-	P.Token(s.Switch, token.SWITCH);
+	P.Token(s.Pos(), token.SWITCH);
 	P.separator = blank;
 	if s.Init != nil {
 		P.Stmt(s.Init);
@@ -1044,7 +1044,7 @@ func (P *Printer) DoTypeSwitchStmt(s *ast.TypeSwitchStmt) {
 
 func (P *Printer) DoCommClause(s *ast.CommClause) {
 	if s.Rhs != nil {
-		P.Token(s.Case, token.CASE);
+		P.Token(s.Pos(), token.CASE);
 		P.separator = blank;
 		if s.Lhs != nil {
 			P.Expr(s.Lhs);
@@ -1054,7 +1054,7 @@ func (P *Printer) DoCommClause(s *ast.CommClause) {
 		}
 		P.Expr(s.Rhs);
 	} else {
-		P.Token(s.Case, token.DEFAULT);
+		P.Token(s.Pos(), token.DEFAULT);
 	}
 	P.Token(s.Colon, token.COLON);
 	P.indentation++;
@@ -1065,21 +1065,21 @@ func (P *Printer) DoCommClause(s *ast.CommClause) {
 
 
 func (P *Printer) DoSelectStmt(s *ast.SelectStmt) {
-	P.Token(s.Select, token.SELECT);
+	P.Token(s.Pos(), token.SELECT);
 	P.separator = blank;
 	P.Stmt(s.Body);
 }
 
 
 func (P *Printer) DoForStmt(s *ast.ForStmt) {
-	P.Token(s.For, token.FOR);
+	P.Token(s.Pos(), token.FOR);
 	P.ControlClause(true, s.Init, s.Cond, s.Post);
 	P.Stmt(s.Body);
 }
 
 
 func (P *Printer) DoRangeStmt(s *ast.RangeStmt) {
-	P.Token(s.For, token.FOR);
+	P.Token(s.Pos(), token.FOR);
 	P.separator = blank;
 	P.Expr(s.Key);
 	if s.Value != nil {
@@ -1089,7 +1089,7 @@ func (P *Printer) DoRangeStmt(s *ast.RangeStmt) {
 		P.Expr(s.Value);
 	}
 	P.separator = blank;
-	P.Token(s.Pos_, s.Tok);
+	P.Token(s.TokPos, s.Tok);
 	P.separator = blank;
 	P.Token(nopos, token.RANGE);
 	P.separator = blank;
@@ -1103,13 +1103,13 @@ func (P *Printer) DoRangeStmt(s *ast.RangeStmt) {
 // Declarations
 
 func (P *Printer) DoBadDecl(d *ast.BadDecl) {
-	P.String(d.Pos_, "<BAD DECL>");
+	P.String(d.Pos(), "<BAD DECL>");
 }
 
 
 func (P *Printer) DoImportDecl(d *ast.ImportDecl) {
-	if d.Import.Pos > 0 {
-		P.Token(d.Import, token.IMPORT);
+	if d.Pos().Offset > 0 {
+		P.Token(d.Pos(), token.IMPORT);
 		P.separator = blank;
 	}
 	if d.Name != nil {
@@ -1128,8 +1128,8 @@ func (P *Printer) DoImportDecl(d *ast.ImportDecl) {
 
 
 func (P *Printer) DoConstDecl(d *ast.ConstDecl) {
-	if d.Const.Pos > 0 {
-		P.Token(d.Const, token.CONST);
+	if d.Pos().Offset > 0 {
+		P.Token(d.Pos(), token.CONST);
 		P.separator = blank;
 	}
 	P.Idents(d.Names, P.full);
@@ -1148,8 +1148,8 @@ func (P *Printer) DoConstDecl(d *ast.ConstDecl) {
 
 
 func (P *Printer) DoTypeDecl(d *ast.TypeDecl) {
-	if d.Pos_.Pos > 0 {
-		P.Token(d.Pos_, token.TYPE);
+	if d.Pos().Offset > 0 {
+		P.Token(d.Pos(), token.TYPE);
 		P.separator = blank;
 	}
 	P.Expr(d.Name);
@@ -1160,8 +1160,8 @@ func (P *Printer) DoTypeDecl(d *ast.TypeDecl) {
 
 
 func (P *Printer) DoVarDecl(d *ast.VarDecl) {
-	if d.Var.Pos > 0 {
-		P.Token(d.Var, token.VAR);
+	if d.Pos().Offset > 0 {
+		P.Token(d.Pos(), token.VAR);
 		P.separator = blank;
 	}
 	P.Idents(d.Names, P.full);
@@ -1181,7 +1181,7 @@ func (P *Printer) DoVarDecl(d *ast.VarDecl) {
 
 
 func (P *Printer) DoFuncDecl(d *ast.FuncDecl) {
-	P.Token(d.Type.Func, token.FUNC);
+	P.Token(d.Pos(), token.FUNC);
 	P.separator = blank;
 	if recv := d.Recv; recv != nil {
 		// method: print receiver
@@ -1205,7 +1205,7 @@ func (P *Printer) DoFuncDecl(d *ast.FuncDecl) {
 
 
 func (P *Printer) DoDeclList(d *ast.DeclList) {
-	P.Token(d.Pos_, d.Tok);
+	P.Token(d.Pos(), d.Tok);
 	P.separator = blank;
 
 	// group of parenthesized declarations
@@ -1351,7 +1351,7 @@ func (P *Printer) Interface(p *ast.Package) {
 
 func (P *Printer) Program(p *ast.Package) {
 	P.full = true;
-	P.Token(p.Package, token.PACKAGE);
+	P.Token(p.Pos(), token.PACKAGE);
 	P.separator = blank;
 	P.Expr(p.Name);
 	P.newlines = 1;
diff --git a/usr/gri/pretty/typechecker.go b/usr/gri/pretty/typechecker.go
index b027379275..2582f61a5b 100644
--- a/usr/gri/pretty/typechecker.go
+++ b/usr/gri/pretty/typechecker.go
@@ -42,8 +42,8 @@ func assert(pred bool) {
 }
 
 
-func (s *state) Error(loc scanner.Location, msg string) {
-	s.err.Error(loc, msg);
+func (s *state) Error(pos token.Position, msg string) {
+	s.err.Error(pos, msg);
 }
 
 
