commit ff81c14fb27beb32201f673640d2ddb5e42355bb
Author: Russ Cox <rsc@golang.org>
Date:   Thu Feb 5 11:55:51 2015 -0500

    cmd/gc: rename arch to thearch
    
    Otherwise the exported variable collides with the type Arch.
    
    While we're here, remove arch.dumpit (now in portable code)
    and add arch.defframe (forgotten originally, somehow).
    
    Change-Id: I1b3a7dd7e96c5f632dba7cd6c1217b42a2004d72
    Reviewed-on: https://go-review.googlesource.com/4644
    Reviewed-by: Austin Clements <austin@google.com>
---
 src/cmd/5g/galign.c  | 80 ++++++++++++++++++++++++-------------------------
 src/cmd/6g/galign.c  | 84 ++++++++++++++++++++++++++--------------------------
 src/cmd/8g/galign.c  | 80 ++++++++++++++++++++++++-------------------------
 src/cmd/8g/peep.c    |  4 +--
 src/cmd/9g/galign.c  | 84 ++++++++++++++++++++++++++--------------------------
 src/cmd/gc/align.c   | 18 +++++------
 src/cmd/gc/closure.c |  2 +-
 src/cmd/gc/cplx.c    | 50 +++++++++++++++----------------
 src/cmd/gc/export.c  |  2 +-
 src/cmd/gc/gen.c     | 52 ++++++++++++++++----------------
 src/cmd/gc/go.h      |  9 +++---
 src/cmd/gc/gsubr.c   | 38 ++++++++++++------------
 src/cmd/gc/lex.c     | 34 ++++++++++-----------
 src/cmd/gc/obj.c     | 20 ++++++-------
 src/cmd/gc/pgen.c    | 40 ++++++++++++-------------
 src/cmd/gc/plive.c   |  4 +--
 src/cmd/gc/popt.c    | 57 +++++++++++++++++------------------
 src/cmd/gc/reg.c     | 36 +++++++++++-----------
 src/cmd/gc/sinit.c   |  2 +-
 src/cmd/gc/subr.c    |  4 +--
 src/cmd/gc/walk.c    |  6 ++--
 21 files changed, 351 insertions(+), 355 deletions(-)

diff --git a/src/cmd/5g/galign.c b/src/cmd/5g/galign.c
index 394b36d84e..c4d74f0a71 100644
--- a/src/cmd/5g/galign.c
+++ b/src/cmd/5g/galign.c
@@ -42,46 +42,46 @@ betypeinit(void)
 void
 main(int argc, char **argv)
 {
-	arch.thechar = thechar;
-	arch.thestring = thestring;
-	arch.thelinkarch = thelinkarch;
-	arch.typedefs = typedefs;
-	arch.REGSP = REGSP;
-	arch.REGCTXT = REGCTXT;
-	arch.MAXWIDTH = MAXWIDTH;
-	arch.anyregalloc = anyregalloc;
-	arch.betypeinit = betypeinit;
-	arch.bgen = bgen;
-	arch.cgen = cgen;
-	arch.cgen_call = cgen_call;
-	arch.cgen_callinter = cgen_callinter;
-	arch.cgen_ret = cgen_ret;
-	arch.clearfat = clearfat;
-	arch.dumpit = dumpit;
-	arch.excise = excise;
-	arch.expandchecks = expandchecks;
-	arch.gclean = gclean;
-	arch.ginit = ginit;
-	arch.gins = gins;
-	arch.ginscall = ginscall;
-	arch.igen = igen;
-	arch.linkarchinit = linkarchinit;
-	arch.peep = peep;
-	arch.proginfo = proginfo;
-	arch.regalloc = regalloc;
-	arch.regfree = regfree;
-	arch.regtyp = regtyp;
-	arch.sameaddr = sameaddr;
-	arch.smallindir = smallindir;
-	arch.stackaddr = stackaddr;
-	arch.excludedregs = excludedregs;
-	arch.RtoB = RtoB;
-	arch.FtoB = RtoB;
-	arch.BtoR = BtoR;
-	arch.BtoF = BtoF;
-	arch.optoas = optoas;
-	arch.doregbits = doregbits;
-	arch.regnames = regnames;
+	thearch.thechar = thechar;
+	thearch.thestring = thestring;
+	thearch.thelinkarch = thelinkarch;
+	thearch.typedefs = typedefs;
+	thearch.REGSP = REGSP;
+	thearch.REGCTXT = REGCTXT;
+	thearch.MAXWIDTH = MAXWIDTH;
+	thearch.anyregalloc = anyregalloc;
+	thearch.betypeinit = betypeinit;
+	thearch.bgen = bgen;
+	thearch.cgen = cgen;
+	thearch.cgen_call = cgen_call;
+	thearch.cgen_callinter = cgen_callinter;
+	thearch.cgen_ret = cgen_ret;
+	thearch.clearfat = clearfat;
+	thearch.defframe = defframe;
+	thearch.excise = excise;
+	thearch.expandchecks = expandchecks;
+	thearch.gclean = gclean;
+	thearch.ginit = ginit;
+	thearch.gins = gins;
+	thearch.ginscall = ginscall;
+	thearch.igen = igen;
+	thearch.linkarchinit = linkarchinit;
+	thearch.peep = peep;
+	thearch.proginfo = proginfo;
+	thearch.regalloc = regalloc;
+	thearch.regfree = regfree;
+	thearch.regtyp = regtyp;
+	thearch.sameaddr = sameaddr;
+	thearch.smallindir = smallindir;
+	thearch.stackaddr = stackaddr;
+	thearch.excludedregs = excludedregs;
+	thearch.RtoB = RtoB;
+	thearch.FtoB = RtoB;
+	thearch.BtoR = BtoR;
+	thearch.BtoF = BtoF;
+	thearch.optoas = optoas;
+	thearch.doregbits = doregbits;
+	thearch.regnames = regnames;
 	
 	gcmain(argc, argv);
 }
diff --git a/src/cmd/6g/galign.c b/src/cmd/6g/galign.c
index ad66366c78..fa9998b0ee 100644
--- a/src/cmd/6g/galign.c
+++ b/src/cmd/6g/galign.c
@@ -15,9 +15,9 @@ linkarchinit(void)
 {
 	if(strcmp(getgoarch(), "amd64p32") == 0) {
 		thelinkarch = &linkamd64p32;
-		arch.thelinkarch = thelinkarch;
+		thearch.thelinkarch = thelinkarch;
 		thestring = "amd64p32";
-		arch.thestring = "amd64p32";
+		thearch.thestring = "amd64p32";
 	}
 }
 
@@ -65,46 +65,46 @@ betypeinit(void)
 void
 main(int argc, char **argv)
 {
-	arch.thechar = thechar;
-	arch.thestring = thestring;
-	arch.thelinkarch = thelinkarch;
-	arch.typedefs = typedefs;
-	arch.REGSP = REGSP;
-	arch.REGCTXT = REGCTXT;
-	arch.MAXWIDTH = MAXWIDTH;
-	arch.anyregalloc = anyregalloc;
-	arch.betypeinit = betypeinit;
-	arch.bgen = bgen;
-	arch.cgen = cgen;
-	arch.cgen_call = cgen_call;
-	arch.cgen_callinter = cgen_callinter;
-	arch.cgen_ret = cgen_ret;
-	arch.clearfat = clearfat;
-	arch.dumpit = dumpit;
-	arch.excise = excise;
-	arch.expandchecks = expandchecks;
-	arch.gclean = gclean;
-	arch.ginit = ginit;
-	arch.gins = gins;
-	arch.ginscall = ginscall;
-	arch.igen = igen;
-	arch.linkarchinit = linkarchinit;
-	arch.peep = peep;
-	arch.proginfo = proginfo;
-	arch.regalloc = regalloc;
-	arch.regfree = regfree;
-	arch.regtyp = regtyp;
-	arch.sameaddr = sameaddr;
-	arch.smallindir = smallindir;
-	arch.stackaddr = stackaddr;
-	arch.excludedregs = excludedregs;
-	arch.RtoB = RtoB;
-	arch.FtoB = FtoB;
-	arch.BtoR = BtoR;
-	arch.BtoF = BtoF;
-	arch.optoas = optoas;
-	arch.doregbits = doregbits;
-	arch.regnames = regnames;
+	thearch.thechar = thechar;
+	thearch.thestring = thestring;
+	thearch.thelinkarch = thelinkarch;
+	thearch.typedefs = typedefs;
+	thearch.REGSP = REGSP;
+	thearch.REGCTXT = REGCTXT;
+	thearch.MAXWIDTH = MAXWIDTH;
+	thearch.anyregalloc = anyregalloc;
+	thearch.betypeinit = betypeinit;
+	thearch.bgen = bgen;
+	thearch.cgen = cgen;
+	thearch.cgen_call = cgen_call;
+	thearch.cgen_callinter = cgen_callinter;
+	thearch.cgen_ret = cgen_ret;
+	thearch.clearfat = clearfat;
+	thearch.defframe = defframe;
+	thearch.excise = excise;
+	thearch.expandchecks = expandchecks;
+	thearch.gclean = gclean;
+	thearch.ginit = ginit;
+	thearch.gins = gins;
+	thearch.ginscall = ginscall;
+	thearch.igen = igen;
+	thearch.linkarchinit = linkarchinit;
+	thearch.peep = peep;
+	thearch.proginfo = proginfo;
+	thearch.regalloc = regalloc;
+	thearch.regfree = regfree;
+	thearch.regtyp = regtyp;
+	thearch.sameaddr = sameaddr;
+	thearch.smallindir = smallindir;
+	thearch.stackaddr = stackaddr;
+	thearch.excludedregs = excludedregs;
+	thearch.RtoB = RtoB;
+	thearch.FtoB = FtoB;
+	thearch.BtoR = BtoR;
+	thearch.BtoF = BtoF;
+	thearch.optoas = optoas;
+	thearch.doregbits = doregbits;
+	thearch.regnames = regnames;
 	
 	gcmain(argc, argv);
 }
diff --git a/src/cmd/8g/galign.c b/src/cmd/8g/galign.c
index 3ee3dc2f3a..33951adfd2 100644
--- a/src/cmd/8g/galign.c
+++ b/src/cmd/8g/galign.c
@@ -42,46 +42,46 @@ betypeinit(void)
 void
 main(int argc, char **argv)
 {
-	arch.thechar = thechar;
-	arch.thestring = thestring;
-	arch.thelinkarch = thelinkarch;
-	arch.typedefs = typedefs;
-	arch.REGSP = REGSP;
-	arch.REGCTXT = REGCTXT;
-	arch.MAXWIDTH = MAXWIDTH;
-	arch.anyregalloc = anyregalloc;
-	arch.betypeinit = betypeinit;
-	arch.bgen = bgen;
-	arch.cgen = cgen;
-	arch.cgen_call = cgen_call;
-	arch.cgen_callinter = cgen_callinter;
-	arch.cgen_ret = cgen_ret;
-	arch.clearfat = clearfat;
-	arch.dumpit = dumpit;
-	arch.excise = excise;
-	arch.expandchecks = expandchecks;
-	arch.gclean = gclean;
-	arch.ginit = ginit;
-	arch.gins = gins;
-	arch.ginscall = ginscall;
-	arch.igen = igen;
-	arch.linkarchinit = linkarchinit;
-	arch.peep = peep;
-	arch.proginfo = proginfo;
-	arch.regalloc = regalloc;
-	arch.regfree = regfree;
-	arch.regtyp = regtyp;
-	arch.sameaddr = sameaddr;
-	arch.smallindir = smallindir;
-	arch.stackaddr = stackaddr;
-	arch.excludedregs = excludedregs;
-	arch.RtoB = RtoB;
-	arch.FtoB = FtoB;
-	arch.BtoR = BtoR;
-	arch.BtoF = BtoF;
-	arch.optoas = optoas;
-	arch.doregbits = doregbits;
-	arch.regnames = regnames;
+	thearch.thechar = thechar;
+	thearch.thestring = thestring;
+	thearch.thelinkarch = thelinkarch;
+	thearch.typedefs = typedefs;
+	thearch.REGSP = REGSP;
+	thearch.REGCTXT = REGCTXT;
+	thearch.MAXWIDTH = MAXWIDTH;
+	thearch.anyregalloc = anyregalloc;
+	thearch.betypeinit = betypeinit;
+	thearch.bgen = bgen;
+	thearch.cgen = cgen;
+	thearch.cgen_call = cgen_call;
+	thearch.cgen_callinter = cgen_callinter;
+	thearch.cgen_ret = cgen_ret;
+	thearch.clearfat = clearfat;
+	thearch.defframe = defframe;
+	thearch.excise = excise;
+	thearch.expandchecks = expandchecks;
+	thearch.gclean = gclean;
+	thearch.ginit = ginit;
+	thearch.gins = gins;
+	thearch.ginscall = ginscall;
+	thearch.igen = igen;
+	thearch.linkarchinit = linkarchinit;
+	thearch.peep = peep;
+	thearch.proginfo = proginfo;
+	thearch.regalloc = regalloc;
+	thearch.regfree = regfree;
+	thearch.regtyp = regtyp;
+	thearch.sameaddr = sameaddr;
+	thearch.smallindir = smallindir;
+	thearch.stackaddr = stackaddr;
+	thearch.excludedregs = excludedregs;
+	thearch.RtoB = RtoB;
+	thearch.FtoB = FtoB;
+	thearch.BtoR = BtoR;
+	thearch.BtoF = BtoF;
+	thearch.optoas = optoas;
+	thearch.doregbits = doregbits;
+	thearch.regnames = regnames;
 	
 	gcmain(argc, argv);
 }
diff --git a/src/cmd/8g/peep.c b/src/cmd/8g/peep.c
index 0652c0af02..712c8fe11b 100644
--- a/src/cmd/8g/peep.c
+++ b/src/cmd/8g/peep.c
@@ -561,7 +561,7 @@ copyu(Prog *p, Adr *v, Adr *s)
 	case ACALL:
 		if(REGEXT && v->type == TYPE_REG && v->reg <= REGEXT && v->reg > exregoffset)
 			return 2;
-		if(REGARG >= 0 && v->type == TYPE_REG && v->reg == (uchar)REGARG)
+		if(REGARG >= 0 && v->type == TYPE_REG && v->reg == REGARG)
 			return 2;
 		if(v->type == p->from.type && v->reg == p->from.reg)
 			return 2;
@@ -576,7 +576,7 @@ copyu(Prog *p, Adr *v, Adr *s)
 		return 3;
 
 	case ATEXT:
-		if(REGARG >= 0 && v->type == TYPE_REG && v->reg == (uchar)REGARG)
+		if(REGARG >= 0 && v->type == TYPE_REG && v->reg == REGARG)
 			return 3;
 		return 0;
 	}
diff --git a/src/cmd/9g/galign.c b/src/cmd/9g/galign.c
index 5ee535de05..74856e2af0 100644
--- a/src/cmd/9g/galign.c
+++ b/src/cmd/9g/galign.c
@@ -14,12 +14,12 @@ void
 linkarchinit(void)
 {
 	thestring = getgoarch();
-	arch.thestring = thestring;
+	thearch.thestring = thestring;
 	if(strcmp(thestring, "ppc64le") == 0)
 		thelinkarch = &linkppc64le;
 	else
 		thelinkarch = &linkppc64;
-	arch.thelinkarch = thelinkarch;
+	thearch.thelinkarch = thelinkarch;
 }
 
 vlong MAXWIDTH = 1LL<<50;
@@ -49,46 +49,46 @@ betypeinit(void)
 void
 main(int argc, char **argv)
 {
-	arch.thechar = thechar;
-	arch.thestring = thestring;
-	arch.thelinkarch = thelinkarch;
-	arch.typedefs = typedefs;
-	arch.REGSP = REGSP;
-	arch.REGCTXT = REGCTXT;
-	arch.MAXWIDTH = MAXWIDTH;
-	arch.anyregalloc = anyregalloc;
-	arch.betypeinit = betypeinit;
-	arch.bgen = bgen;
-	arch.cgen = cgen;
-	arch.cgen_call = cgen_call;
-	arch.cgen_callinter = cgen_callinter;
-	arch.cgen_ret = cgen_ret;
-	arch.clearfat = clearfat;
-	arch.dumpit = dumpit;
-	arch.excise = excise;
-	arch.expandchecks = expandchecks;
-	arch.gclean = gclean;
-	arch.ginit = ginit;
-	arch.gins = gins;
-	arch.ginscall = ginscall;
-	arch.igen = igen;
-	arch.linkarchinit = linkarchinit;
-	arch.peep = peep;
-	arch.proginfo = proginfo;
-	arch.regalloc = regalloc;
-	arch.regfree = regfree;
-	arch.regtyp = regtyp;
-	arch.sameaddr = sameaddr;
-	arch.smallindir = smallindir;
-	arch.stackaddr = stackaddr;
-	arch.excludedregs = excludedregs;
-	arch.RtoB = RtoB;
-	arch.FtoB = RtoB;
-	arch.BtoR = BtoR;
-	arch.BtoF = BtoF;
-	arch.optoas = optoas;
-	arch.doregbits = doregbits;
-	arch.regnames = regnames;
+	thearch.thechar = thechar;
+	thearch.thestring = thestring;
+	thearch.thelinkarch = thelinkarch;
+	thearch.typedefs = typedefs;
+	thearch.REGSP = REGSP;
+	thearch.REGCTXT = REGCTXT;
+	thearch.MAXWIDTH = MAXWIDTH;
+	thearch.anyregalloc = anyregalloc;
+	thearch.betypeinit = betypeinit;
+	thearch.bgen = bgen;
+	thearch.cgen = cgen;
+	thearch.cgen_call = cgen_call;
+	thearch.cgen_callinter = cgen_callinter;
+	thearch.cgen_ret = cgen_ret;
+	thearch.clearfat = clearfat;
+	thearch.defframe = defframe;
+	thearch.excise = excise;
+	thearch.expandchecks = expandchecks;
+	thearch.gclean = gclean;
+	thearch.ginit = ginit;
+	thearch.gins = gins;
+	thearch.ginscall = ginscall;
+	thearch.igen = igen;
+	thearch.linkarchinit = linkarchinit;
+	thearch.peep = peep;
+	thearch.proginfo = proginfo;
+	thearch.regalloc = regalloc;
+	thearch.regfree = regfree;
+	thearch.regtyp = regtyp;
+	thearch.sameaddr = sameaddr;
+	thearch.smallindir = smallindir;
+	thearch.stackaddr = stackaddr;
+	thearch.excludedregs = excludedregs;
+	thearch.RtoB = RtoB;
+	thearch.FtoB = RtoB;
+	thearch.BtoR = BtoR;
+	thearch.BtoF = BtoF;
+	thearch.optoas = optoas;
+	thearch.doregbits = doregbits;
+	thearch.regnames = regnames;
 	
 	gcmain(argc, argv);
 }
diff --git a/src/cmd/gc/align.c b/src/cmd/gc/align.c
index 26d72e87fc..59ff0abf73 100644
--- a/src/cmd/gc/align.c
+++ b/src/cmd/gc/align.c
@@ -35,7 +35,7 @@ offmod(Type *t)
 			fatal("offmod: not TFIELD: %lT", f);
 		f->width = o;
 		o += widthptr;
-		if(o >= arch.MAXWIDTH) {
+		if(o >= thearch.MAXWIDTH) {
 			yyerror("interface too large");
 			o = widthptr;
 		}
@@ -86,7 +86,7 @@ widstruct(Type *errtype, Type *t, vlong o, int flag)
 		if(w == 0)
 			lastzero = o;
 		o += w;
-		if(o >= arch.MAXWIDTH) {
+		if(o >= thearch.MAXWIDTH) {
 			yyerror("type %lT too large", errtype);
 			o = 8;  // small but nonzero
 		}
@@ -260,7 +260,7 @@ dowidth(Type *t)
 
 			dowidth(t->type);
 			if(t->type->width != 0) {
-				cap = (arch.MAXWIDTH-1) / t->type->width;
+				cap = (thearch.MAXWIDTH-1) / t->type->width;
 				if(t->bound > cap)
 					yyerror("type %lT larger than address space", t);
 			}
@@ -613,15 +613,15 @@ typeinit(void)
 	simtype[TFUNC] = tptr;
 	simtype[TUNSAFEPTR] = tptr;
 
-	/* pick up the backend arch.typedefs */
-	for(i=0; arch.typedefs[i].name; i++) {
-		s = lookup(arch.typedefs[i].name);
-		s1 = pkglookup(arch.typedefs[i].name, builtinpkg);
+	/* pick up the backend thearch.typedefs */
+	for(i=0; thearch.typedefs[i].name; i++) {
+		s = lookup(thearch.typedefs[i].name);
+		s1 = pkglookup(thearch.typedefs[i].name, builtinpkg);
 
-		etype = arch.typedefs[i].etype;
+		etype = thearch.typedefs[i].etype;
 		if(etype < 0 || etype >= nelem(types))
 			fatal("typeinit: %s bad etype", s->name);
-		sameas = arch.typedefs[i].sameas;
+		sameas = thearch.typedefs[i].sameas;
 		if(sameas < 0 || sameas >= nelem(types))
 			fatal("typeinit: %s bad sameas", s->name);
 		simtype[etype] = sameas;
diff --git a/src/cmd/gc/closure.c b/src/cmd/gc/closure.c
index b1c4cd327a..eb72ea14ce 100644
--- a/src/cmd/gc/closure.c
+++ b/src/cmd/gc/closure.c
@@ -311,7 +311,7 @@ transformclosure(Node *xfunc)
 			cv->xoffset = offset;
 			offset += cv->type->width;
 
-			if(v->byval && v->type->width <= 2*widthptr && arch.thechar == '6') {
+			if(v->byval && v->type->width <= 2*widthptr && thearch.thechar == '6') {
 				//  If it is a small variable captured by value, downgrade it to PAUTO.
 				// This optimization is currently enabled only for amd64, see:
 				// https://github.com/golang/go/issues/9865
diff --git a/src/cmd/gc/cplx.c b/src/cmd/gc/cplx.c
index d3fb952558..26c21df82a 100644
--- a/src/cmd/gc/cplx.c
+++ b/src/cmd/gc/cplx.c
@@ -78,8 +78,8 @@ complexmove(Node *f, Node *t)
 		subnode(&n1, &n2, f);
 		subnode(&n3, &n4, t);
 
-		arch.cgen(&n1, &n3);
-		arch.cgen(&n2, &n4);
+		thearch.cgen(&n1, &n3);
+		thearch.cgen(&n2, &n4);
 		break;
 	}
 }
@@ -151,9 +151,9 @@ complexgen(Node *n, Node *res)
 		if(res->addable) {
 			subnode(&n1, &n2, res);
 			tempname(&tmp, n1.type);
-			arch.cgen(n->left, &tmp);
-			arch.cgen(n->right, &n2);
-			arch.cgen(&tmp, &n1);
+			thearch.cgen(n->left, &tmp);
+			thearch.cgen(n->right, &n2);
+			thearch.cgen(&tmp, &n1);
 			return;
 		}
 		break;
@@ -168,10 +168,10 @@ complexgen(Node *n, Node *res)
 		}
 		subnode(&n1, &n2, nl);
 		if(n->op == OREAL) {
-			arch.cgen(&n1, res);
+			thearch.cgen(&n1, res);
 			return;
 		}
-		arch.cgen(&n2, res);
+		thearch.cgen(&n2, res);
 		return;
 	}
 
@@ -191,9 +191,9 @@ complexgen(Node *n, Node *res)
 	}
 
 	if(!res->addable) {
-		arch.igen(res, &n1, N);
-		arch.cgen(n, &n1);
-		arch.regfree(&n1);
+		thearch.igen(res, &n1, N);
+		thearch.cgen(n, &n1);
+		thearch.regfree(&n1);
 		return;
 	}
 	if(n->addable) {
@@ -214,9 +214,9 @@ complexgen(Node *n, Node *res)
 	case OCALLFUNC:
 	case OCALLMETH:
 	case OCALLINTER:
-		arch.igen(n, &n1, res);
+		thearch.igen(n, &n1, res);
 		complexmove(&n1, res);
-		arch.regfree(&n1);
+		thearch.regfree(&n1);
 		return;
 
 	case OCONV:
@@ -239,18 +239,18 @@ complexgen(Node *n, Node *res)
 	if(nr != N) {
 		if(nl->ullman > nr->ullman && !nl->addable) {
 			tempname(&tnl, nl->type);
-			arch.cgen(nl, &tnl);
+			thearch.cgen(nl, &tnl);
 			nl = &tnl;
 		}
 		if(!nr->addable) {
 			tempname(&tnr, nr->type);
-			arch.cgen(nr, &tnr);
+			thearch.cgen(nr, &tnr);
 			nr = &tnr;
 		}
 	}
 	if(!nl->addable) {
 		tempname(&tnl, nl->type);
-		arch.cgen(nl, &tnl);
+		thearch.cgen(nl, &tnl);
 		nl = &tnl;
 	}
 
@@ -289,18 +289,18 @@ complexbool(int op, Node *nl, Node *nr, int true, int likely, Prog *to)
 	if(nr != N) {
 		if(nl->ullman > nr->ullman && !nl->addable) {
 			tempname(&tnl, nl->type);
-			arch.cgen(nl, &tnl);
+			thearch.cgen(nl, &tnl);
 			nl = &tnl;
 		}
 		if(!nr->addable) {
 			tempname(&tnr, nr->type);
-			arch.cgen(nr, &tnr);
+			thearch.cgen(nr, &tnr);
 			nr = &tnr;
 		}
 	}
 	if(!nl->addable) {
 		tempname(&tnl, nl->type);
-		arch.cgen(nl, &tnl);
+		thearch.cgen(nl, &tnl);
 		nl = &tnl;
 	}
 
@@ -331,7 +331,7 @@ complexbool(int op, Node *nl, Node *nr, int true, int likely, Prog *to)
 	if(op == ONE)
 		true = !true;
 
-	arch.bgen(&na, true, likely, to);
+	thearch.bgen(&na, true, likely, to);
 }
 
 void
@@ -387,7 +387,7 @@ minus(Node *nl, Node *res)
 	ra.op = OMINUS;
 	ra.left = nl;
 	ra.type = nl->type;
-	arch.cgen(&ra, res);
+	thearch.cgen(&ra, res);
 }
 
 // build and execute tree
@@ -424,14 +424,14 @@ complexadd(int op, Node *nl, Node *nr, Node *res)
 	ra.left = &n1;
 	ra.right = &n3;
 	ra.type = n1.type;
-	arch.cgen(&ra, &n5);
+	thearch.cgen(&ra, &n5);
 
 	memset(&ra, 0, sizeof(ra));
 	ra.op = op;
 	ra.left = &n2;
 	ra.right = &n4;
 	ra.type = n2.type;
-	arch.cgen(&ra, &n6);
+	thearch.cgen(&ra, &n6);
 }
 
 // build and execute tree
@@ -467,7 +467,7 @@ complexmul(Node *nl, Node *nr, Node *res)
 	ra.left = &rm1;
 	ra.right = &rm2;
 	ra.type = rm1.type;
-	arch.cgen(&ra, &tmp);
+	thearch.cgen(&ra, &tmp);
 
 	// imag part
 	memset(&rm1, 0, sizeof(rm1));
@@ -487,8 +487,8 @@ complexmul(Node *nl, Node *nr, Node *res)
 	ra.left = &rm1;
 	ra.right = &rm2;
 	ra.type = rm1.type;
-	arch.cgen(&ra, &n6);
+	thearch.cgen(&ra, &n6);
 
 	// tmp ->real part
-	arch.cgen(&tmp, &n5);
+	thearch.cgen(&tmp, &n5);
 }
diff --git a/src/cmd/gc/export.c b/src/cmd/gc/export.c
index 8685aa0def..91f4957dc2 100644
--- a/src/cmd/gc/export.c
+++ b/src/cmd/gc/export.c
@@ -538,7 +538,7 @@ dumpasmhdr(void)
 	b = Bopen(asmhdr, OWRITE);
 	if(b == nil)
 		fatal("open %s: %r", asmhdr);
-	Bprint(b, "// generated by %cg -asmhdr from package %s\n\n", arch.thechar, localpkg->name);
+	Bprint(b, "// generated by %cg -asmhdr from package %s\n\n", thearch.thechar, localpkg->name);
 	for(l=asmlist; l; l=l->next) {
 		n = l->n;
 		if(isblanksym(n->sym))
diff --git a/src/cmd/gc/gen.c b/src/cmd/gc/gen.c
index e600c1e5ea..72bcc492a5 100644
--- a/src/cmd/gc/gen.c
+++ b/src/cmd/gc/gen.c
@@ -265,7 +265,7 @@ gen(Node *n)
 //dump("gen", n);
 
 	lno = setlineno(n);
-	wasregalloc = arch.anyregalloc();
+	wasregalloc = thearch.anyregalloc();
 
 	if(n == N)
 		goto ret;
@@ -395,7 +395,7 @@ gen(Node *n)
 		}
 		gen(n->nincr);				// contin:	incr
 		patch(p1, pc);				// test:
-		arch.bgen(n->ntest, 0, -1, breakpc);		//		if(!test) goto break
+		thearch.bgen(n->ntest, 0, -1, breakpc);		//		if(!test) goto break
 		genlist(n->nbody);				//		body
 		gjmp(continpc);
 		patch(breakpc, pc);			// done:
@@ -411,7 +411,7 @@ gen(Node *n)
 		p1 = gjmp(P);			//		goto test
 		p2 = gjmp(P);			// p2:		goto else
 		patch(p1, pc);				// test:
-		arch.bgen(n->ntest, 0, -n->likely, p2);		//		if(!test) goto p2
+		thearch.bgen(n->ntest, 0, -n->likely, p2);		//		if(!test) goto p2
 		genlist(n->nbody);				//		then
 		p3 = gjmp(P);			//		goto done
 		patch(p2, pc);				// else:
@@ -468,11 +468,11 @@ gen(Node *n)
 		break;
 
 	case OCALLINTER:
-		arch.cgen_callinter(n, N, 0);
+		thearch.cgen_callinter(n, N, 0);
 		break;
 
 	case OCALLFUNC:
-		arch.cgen_call(n, 0);
+		thearch.cgen_call(n, 0);
 		break;
 
 	case OPROC:
@@ -485,7 +485,7 @@ gen(Node *n)
 
 	case ORETURN:
 	case ORETJMP:
-		arch.cgen_ret(n);
+		thearch.cgen_ret(n);
 		break;
 	
 	case OCHECKNIL:
@@ -498,7 +498,7 @@ gen(Node *n)
 	}
 
 ret:
-	if(arch.anyregalloc() != wasregalloc) {
+	if(thearch.anyregalloc() != wasregalloc) {
 		dump("node", n);
 		fatal("registers left allocated");
 	}
@@ -532,7 +532,7 @@ cgen_callmeth(Node *n, int proc)
 
 	if(n2.left->op == ONAME)
 		n2.left->class = PFUNC;
-	arch.cgen_call(&n2, proc);
+	thearch.cgen_call(&n2, proc);
 }
 
 /*
@@ -550,11 +550,11 @@ cgen_proc(Node *n, int proc)
 		break;
 
 	case OCALLINTER:
-		arch.cgen_callinter(n->left, N, proc);
+		thearch.cgen_callinter(n->left, N, proc);
 		break;
 
 	case OCALLFUNC:
-		arch.cgen_call(n->left, proc);
+		thearch.cgen_call(n->left, proc);
 		break;
 	}
 
@@ -701,7 +701,7 @@ clearslim(Node *n)
 	}
 
 	ullmancalc(&z);
-	arch.cgen(&z, n);
+	thearch.cgen(&z, n);
 }
 
 /*
@@ -738,7 +738,7 @@ cgen_as(Node *nl, Node *nr)
 		if(isfat(tl)) {
 			if(nl->op == ONAME)
 				gvardef(nl);
-			arch.clearfat(nl);
+			thearch.clearfat(nl);
 			return;
 		}
 		clearslim(nl);
@@ -749,7 +749,7 @@ cgen_as(Node *nl, Node *nr)
 	if(tl == T)
 		return;
 
-	arch.cgen(nr, nl);
+	thearch.cgen(nr, nl);
 }
 
 /*
@@ -769,17 +769,17 @@ cgen_eface(Node *n, Node *res)
 	Node *tmp;
 
 	tmp = temp(types[tptr]);
-	arch.cgen(n->right, tmp);
+	thearch.cgen(n->right, tmp);
 
 	gvardef(res);
 
 	dst = *res;
 	dst.type = types[tptr];
 	dst.xoffset += widthptr;
-	arch.cgen(tmp, &dst);
+	thearch.cgen(tmp, &dst);
 
 	dst.xoffset -= widthptr;
-	arch.cgen(n->left, &dst);
+	thearch.cgen(n->left, &dst);
 }
 
 /*
@@ -820,7 +820,7 @@ cgen_slice(Node *n, Node *res)
 
 	if(isnil(n->left)) {
 		tempname(&src, n->left->type);
-		arch.cgen(n->left, &src);
+		thearch.cgen(n->left, &src);
 	} else
 		src = *n->left;
 	if(n->op == OSLICE || n->op == OSLICE3 || n->op == OSLICESTR)
@@ -829,11 +829,11 @@ cgen_slice(Node *n, Node *res)
 	if(n->op == OSLICEARR || n->op == OSLICE3ARR) {
 		if(!isptr[n->left->type->etype])
 			fatal("slicearr is supposed to work on pointer: %+N\n", n);
-		arch.cgen(&src, base);
+		thearch.cgen(&src, base);
 		cgen_checknil(base);
 	} else {
 		src.type = types[tptr];
-		arch.cgen(&src, base);
+		thearch.cgen(&src, base);
 	}
 	
 	// committed to the update
@@ -842,9 +842,9 @@ cgen_slice(Node *n, Node *res)
 	// compute len and cap.
 	// len = n-i, cap = m-i, and offs = i*width.
 	// computing offs last lets the multiply overwrite i.
-	arch.cgen(len, tmplen);
+	thearch.cgen(len, tmplen);
 	if(n->op != OSLICESTR)
-		arch.cgen(cap, tmpcap);
+		thearch.cgen(cap, tmpcap);
 
 	// if new cap != 0 { base += add }
 	// This avoids advancing base past the end of the underlying array/string,
@@ -860,11 +860,11 @@ cgen_slice(Node *n, Node *res)
 		nodconst(&con, tmpcap->type, 0);
 		cmp = nod(OEQ, tmpcap, &con);
 		typecheck(&cmp, Erv);
-		arch.bgen(cmp, 1, -1, p2);
+		thearch.bgen(cmp, 1, -1, p2);
 
 		add = nod(OADD, base, offs);
 		typecheck(&add, Erv);
-		arch.cgen(add, base);
+		thearch.cgen(add, base);
 
 		patch(p2, pc);
 	}
@@ -873,20 +873,20 @@ cgen_slice(Node *n, Node *res)
 	dst = *res;
 	dst.xoffset += Array_array;
 	dst.type = types[tptr];
-	arch.cgen(base, &dst);
+	thearch.cgen(base, &dst);
 
 	// dst.len = hi [ - lo ]
 	dst = *res;
 	dst.xoffset += Array_nel;
 	dst.type = types[simtype[TUINT]];
-	arch.cgen(tmplen, &dst);
+	thearch.cgen(tmplen, &dst);
 
 	if(n->op != OSLICESTR) {
 		// dst.cap = cap [ - lo ]
 		dst = *res;
 		dst.xoffset += Array_cap;
 		dst.type = types[simtype[TUINT]];
-		arch.cgen(tmpcap, &dst);
+		thearch.cgen(tmpcap, &dst);
 	}
 }
 
diff --git a/src/cmd/gc/go.h b/src/cmd/gc/go.h
index 0efd40d2bf..d99a7d431f 100644
--- a/src/cmd/gc/go.h
+++ b/src/cmd/gc/go.h
@@ -599,7 +599,7 @@ enum
 	OCHECKNIL, // emit code to ensure pointer/interface not nil
 	OVARKILL, // variable is dead
 
-	// arch-specific registers
+	// thearch-specific registers
 	OREGISTER,	// a register, such as AX.
 	OINDREG,	// offset plus indirect of a register, such as 8(SP).
 
@@ -1497,7 +1497,7 @@ Node*	outervalue(Node*);
 void	usefield(Node*);
 
 /*
- *	arch-specific ggen.c/gsubr.c/gobj.c/pgen.c/plive.c
+ *	thearch-specific ggen.c/gsubr.c/gobj.c/pgen.c/plive.c
  */
 #define	P	((Prog*)0)
 
@@ -1678,7 +1678,7 @@ struct Arch
 	void (*cgen_callinter)(Node*, Node*, int);
 	void (*cgen_ret)(Node*);
 	void (*clearfat)(Node*);
-	void (*dumpit)(char*, Flow*, int);
+	void (*defframe)(Prog*);
 	void (*excise)(Flow*);
 	void (*expandchecks)(Prog*);
 	void (*gclean)(void);
@@ -1707,7 +1707,6 @@ struct Arch
 
 void afunclit(Addr*, Node*);
 void clearp(Prog*);
-void defframe(Prog*);
 int dgostringptr(Sym*, int, char*);
 int dgostrlitptr(Sym*, int, Strlit*);
 int dsname(Sym*, int, char*, int);
@@ -1736,7 +1735,7 @@ void	regopt(Prog*);
 
 EXTERN int32	pcloc;
 
-EXTERN Arch arch;
+EXTERN Arch thearch;
 
 EXTERN Node *newproc;
 EXTERN Node *deferproc;
diff --git a/src/cmd/gc/gsubr.c b/src/cmd/gc/gsubr.c
index c97240229d..5175ae34f5 100644
--- a/src/cmd/gc/gsubr.c
+++ b/src/cmd/gc/gsubr.c
@@ -39,7 +39,7 @@ ggloblnod(Node *nam)
 {
 	Prog *p;
 
-	p = arch.gins(AGLOBL, nam, N);
+	p = thearch.gins(AGLOBL, nam, N);
 	p->lineno = nam->lineno;
 	p->from.sym->gotype = linksym(ngotype(nam));
 	p->to.sym = nil;
@@ -56,7 +56,7 @@ gtrack(Sym *s)
 {
 	Prog *p;
 	
-	p = arch.gins(AUSEFIELD, N, N);
+	p = thearch.gins(AUSEFIELD, N, N);
 	p->from.type = TYPE_MEM;
 	p->from.name = NAME_EXTERN;
 	p->from.sym = linksym(s);
@@ -67,7 +67,7 @@ ggloblsym(Sym *s, int32 width, int8 flags)
 {
 	Prog *p;
 
-	p = arch.gins(AGLOBL, N, N);
+	p = thearch.gins(AGLOBL, N, N);
 	p->from.type = TYPE_MEM;
 	p->from.name = NAME_EXTERN;
 	p->from.sym = linksym(s);
@@ -155,7 +155,7 @@ gbranch(int as, Type *t, int likely)
 	p = prog(as);
 	p->to.type = TYPE_BRANCH;
 	p->to.u.branch = P;
-	if(as != AJMP && likely != 0 && arch.thechar != '9') {
+	if(as != AJMP && likely != 0 && thearch.thechar != '9') {
 		p->from.type = TYPE_CONST;
 		p->from.offset = likely > 0;
 	}
@@ -207,7 +207,7 @@ newplist(void)
 void
 gused(Node *n)
 {
-	arch.gins(ANOP, n, N);	// used
+	thearch.gins(ANOP, n, N);	// used
 }
 
 Prog*
@@ -293,7 +293,7 @@ ismem(Node *n)
 	case OCLOSUREVAR:
 		return 1;
 	case OADDR:
-		return arch.thechar == '6' || arch.thechar == '9'; // because 6g uses PC-relative addressing; TODO(rsc): not sure why 9g too
+		return thearch.thechar == '6' || thearch.thechar == '9'; // because 6g uses PC-relative addressing; TODO(rsc): not sure why 9g too
 	}
 	return 0;
 }
@@ -411,10 +411,10 @@ fp:
 	switch(fp) {
 	case 0:		// output arg
 		n->op = OINDREG;
-		n->val.u.reg = arch.REGSP;
-		if(arch.thechar == '5')
+		n->val.u.reg = thearch.REGSP;
+		if(thearch.thechar == '5')
 			n->xoffset += 4;
-		if(arch.thechar == '9')
+		if(thearch.thechar == '9')
 			n->xoffset += 8;
 		break;
 
@@ -425,7 +425,7 @@ fp:
 	case 2:		// offset output arg
 fatal("shouldn't be used");
 		n->op = OINDREG;
-		n->val.u.reg = arch.REGSP;
+		n->val.u.reg = thearch.REGSP;
 		n->xoffset += types[tptr]->width;
 		break;
 	}
@@ -466,7 +466,7 @@ naddr(Node *n, Addr *a, int canemitcode)
 		a->type = TYPE_REG;
 		a->reg = n->val.u.reg;
 		a->sym = nil;
-		if(arch.thechar == '8') // TODO(rsc): Never clear a->width.
+		if(thearch.thechar == '8') // TODO(rsc): Never clear a->width.
 			a->width = 0;
 		break;
 
@@ -477,7 +477,7 @@ naddr(Node *n, Addr *a, int canemitcode)
 		a->offset = n->xoffset;
 		if(a->offset != (int32)a->offset)
 			yyerror("offset %lld too large for OINDREG", a->offset);
-		if(arch.thechar == '8') // TODO(rsc): Never clear a->width.
+		if(thearch.thechar == '8') // TODO(rsc): Never clear a->width.
 			a->width = 0;
 		break;
 
@@ -497,7 +497,7 @@ naddr(Node *n, Addr *a, int canemitcode)
 		if(!curfn->needctxt)
 			fatal("closurevar without needctxt");
 		a->type = TYPE_MEM;
-		a->reg = arch.REGCTXT;
+		a->reg = thearch.REGCTXT;
 		a->sym = nil;
 		a->offset = n->xoffset;
 		break;
@@ -550,7 +550,7 @@ naddr(Node *n, Addr *a, int canemitcode)
 		break;
 
 	case OLITERAL:
-		if(arch.thechar == '8')
+		if(thearch.thechar == '8')
 			a->width = 0;
 		switch(n->val.ctype) {
 		default:
@@ -585,7 +585,7 @@ naddr(Node *n, Addr *a, int canemitcode)
 	case OADDR:
 		naddr(n->left, a, canemitcode);
 		a->etype = tptr;
-		if(arch.thechar != '5' && arch.thechar != '9') // TODO(rsc): Do this even for arm, ppc64.
+		if(thearch.thechar != '5' && thearch.thechar != '9') // TODO(rsc): Do this even for arm, ppc64.
 			a->width = widthptr;
 		if(a->type != TYPE_MEM)
 			fatal("naddr: OADDR %D (from %O)", a, n->left->op);
@@ -617,10 +617,10 @@ naddr(Node *n, Addr *a, int canemitcode)
 		if(a->type == TYPE_CONST && a->offset == 0)
 			break;	// len(nil)
 		a->etype = simtype[TUINT];
-		if(arch.thechar == '9')
+		if(thearch.thechar == '9')
 			a->etype = simtype[TINT];
 		a->offset += Array_nel;
-		if(arch.thechar != '5') // TODO(rsc): Do this even on arm.
+		if(thearch.thechar != '5') // TODO(rsc): Do this even on arm.
 			a->width = widthint;
 		break;
 
@@ -630,10 +630,10 @@ naddr(Node *n, Addr *a, int canemitcode)
 		if(a->type == TYPE_CONST && a->offset == 0)
 			break;	// cap(nil)
 		a->etype = simtype[TUINT];
-		if(arch.thechar == '9')
+		if(thearch.thechar == '9')
 			a->etype = simtype[TINT];
 		a->offset += Array_cap;
-		if(arch.thechar != '5') // TODO(rsc): Do this even on arm.
+		if(thearch.thechar != '5') // TODO(rsc): Do this even on arm.
 			a->width = widthint;
 		break;
 
diff --git a/src/cmd/gc/lex.c b/src/cmd/gc/lex.c
index 902afc0f0f..b915e9fed2 100644
--- a/src/cmd/gc/lex.c
+++ b/src/cmd/gc/lex.c
@@ -95,7 +95,7 @@ enum
 void
 usage(void)
 {
-	print("usage: %cg [options] file.go...\n", arch.thechar);
+	print("usage: %cg [options] file.go...\n", thearch.thechar);
 	flagprint(1);
 	exits("usage");
 }
@@ -140,7 +140,7 @@ doversion(void)
 	sep = "";
 	if(*p)
 		sep = " ";
-	print("%cg version %s%s%s\n", arch.thechar, getgoversion(), sep, p);
+	print("%cg version %s%s%s\n", thearch.thechar, getgoversion(), sep, p);
 	exits(0);
 }
 
@@ -161,15 +161,15 @@ gcmain(int argc, char *argv[])
 	// Tell the FPU to handle all exceptions.
 	setfcr(FPPDBL|FPRNR);
 #endif
-	// Allow GOARCH=arch.thestring or GOARCH=arch.thestringsuffix,
+	// Allow GOARCH=thearch.thestring or GOARCH=thearch.thestringsuffix,
 	// but not other values.	
 	p = getgoarch();
-	if(strncmp(p, arch.thestring, strlen(arch.thestring)) != 0)
-		sysfatal("cannot use %cg with GOARCH=%s", arch.thechar, p);
+	if(strncmp(p, thearch.thestring, strlen(thearch.thestring)) != 0)
+		sysfatal("cannot use %cg with GOARCH=%s", thearch.thechar, p);
 	goarch = p;
 
-	arch.linkarchinit();
-	ctxt = linknew(arch.thelinkarch);
+	thearch.linkarchinit();
+	ctxt = linknew(thearch.thelinkarch);
 	ctxt->diag = yyerror;
 	ctxt->bso = &bstdout;
 	Binit(&bstdout, 1, OWRITE);
@@ -268,7 +268,7 @@ gcmain(int argc, char *argv[])
 	flagcount("wb", "enable write barrier", &use_writebarrier);
 	flagcount("x", "debug lexer", &debug['x']);
 	flagcount("y", "debug declarations in canned imports (with -d)", &debug['y']);
-	if(arch.thechar == '6')
+	if(thearch.thechar == '6')
 		flagcount("largemodel", "generate code that assumes a large memory model", &flag_largemodel);
 
 	flagparse(&argc, &argv, usage);
@@ -309,7 +309,7 @@ gcmain(int argc, char *argv[])
 	if(debug['l'] <= 1)
 		debug['l'] = 1 - debug['l'];
 
-	if(arch.thechar == '8') {
+	if(thearch.thechar == '8') {
 		p = getgo386();
 		if(strcmp(p, "387") == 0)
 			use_sse = 0;
@@ -320,7 +320,7 @@ gcmain(int argc, char *argv[])
 	}
 
 	fmtinstallgo();
-	arch.betypeinit();
+	thearch.betypeinit();
 	if(widthptr == 0)
 		fatal("betypeinit failed");
 
@@ -601,7 +601,7 @@ findpkg(Strlit *name)
 		snprint(namebuf, sizeof(namebuf), "%Z.a", name);
 		if(access(namebuf, 0) >= 0)
 			return 1;
-		snprint(namebuf, sizeof(namebuf), "%Z.%c", name, arch.thechar);
+		snprint(namebuf, sizeof(namebuf), "%Z.%c", name, thearch.thechar);
 		if(access(namebuf, 0) >= 0)
 			return 1;
 		return 0;
@@ -623,7 +623,7 @@ findpkg(Strlit *name)
 		snprint(namebuf, sizeof(namebuf), "%s/%Z.a", p->dir, name);
 		if(access(namebuf, 0) >= 0)
 			return 1;
-		snprint(namebuf, sizeof(namebuf), "%s/%Z.%c", p->dir, name, arch.thechar);
+		snprint(namebuf, sizeof(namebuf), "%s/%Z.%c", p->dir, name, thearch.thechar);
 		if(access(namebuf, 0) >= 0)
 			return 1;
 	}
@@ -640,7 +640,7 @@ findpkg(Strlit *name)
 		snprint(namebuf, sizeof(namebuf), "%s/pkg/%s_%s%s%s/%Z.a", goroot, goos, goarch, suffixsep, suffix, name);
 		if(access(namebuf, 0) >= 0)
 			return 1;
-		snprint(namebuf, sizeof(namebuf), "%s/pkg/%s_%s%s%s/%Z.%c", goroot, goos, goarch, suffixsep, suffix, name, arch.thechar);
+		snprint(namebuf, sizeof(namebuf), "%s/pkg/%s_%s%s%s/%Z.%c", goroot, goos, goarch, suffixsep, suffix, name, thearch.thechar);
 		if(access(namebuf, 0) >= 0)
 			return 1;
 	}
@@ -2283,10 +2283,10 @@ lexfini(void)
 	}
 
 	// backend-specific builtin types (e.g. int).
-	for(i=0; arch.typedefs[i].name; i++) {
-		s = lookup(arch.typedefs[i].name);
+	for(i=0; thearch.typedefs[i].name; i++) {
+		s = lookup(thearch.typedefs[i].name);
 		if(s->def == N) {
-			s->def = typenod(types[arch.typedefs[i].etype]);
+			s->def = typenod(types[thearch.typedefs[i].etype]);
 			s->origpkg = builtinpkg;
 		}
 	}
@@ -2584,6 +2584,6 @@ mkpackage(char* pkgname)
 		p = strrchr(namebuf, '.');
 		if(p != nil)
 			*p = 0;
-		outfile = smprint("%s.%c", namebuf, arch.thechar);
+		outfile = smprint("%s.%c", namebuf, thearch.thechar);
 	}
 }
diff --git a/src/cmd/gc/obj.c b/src/cmd/gc/obj.c
index fdabf40069..3983f99d6d 100644
--- a/src/cmd/gc/obj.c
+++ b/src/cmd/gc/obj.c
@@ -106,7 +106,7 @@ dumpobj(void)
 		if(size&1)
 			Bputc(bout, 0);
 		Bseek(bout, startobj - ArhdrSize, 0);
-		snprint(namebuf, sizeof namebuf, "_go_.%c", arch.thechar);
+		snprint(namebuf, sizeof namebuf, "_go_.%c", thearch.thechar);
 		formathdr(arhdr, namebuf, size);
 		Bwrite(bout, arhdr, ArhdrSize);
 	}
@@ -300,7 +300,7 @@ dsname(Sym *s, int off, char *t, int n)
 {
 	Prog *p;
 
-	p = arch.gins(ADATA, N, N);
+	p = thearch.gins(ADATA, N, N);
 	p->from.type = TYPE_MEM;
 	p->from.name = NAME_EXTERN;
 	p->from.offset = off;
@@ -364,7 +364,7 @@ gdata(Node *nam, Node *nr, int wid)
 			return;
 		}
 	}
-	p = arch.gins(ADATA, nam, nr);
+	p = thearch.gins(ADATA, nam, nr);
 	p->from3.type = TYPE_CONST;
 	p->from3.offset = wid;
 }
@@ -378,13 +378,13 @@ gdatacomplex(Node *nam, Mpcplx *cval)
 	w = cplxsubtype(nam->type->etype);
 	w = types[w]->width;
 
-	p = arch.gins(ADATA, nam, N);
+	p = thearch.gins(ADATA, nam, N);
 	p->from3.type = TYPE_CONST;
 	p->from3.offset = w;
 	p->to.type = TYPE_FCONST;
 	p->to.u.dval = mpgetflt(&cval->real);
 
-	p = arch.gins(ADATA, nam, N);
+	p = thearch.gins(ADATA, nam, N);
 	p->from3.type = TYPE_CONST;
 	p->from3.offset = w;
 	p->from.offset += w;
@@ -398,7 +398,7 @@ gdatastring(Node *nam, Strlit *sval)
 	Prog *p;
 	Node nod1;
 
-	p = arch.gins(ADATA, nam, N);
+	p = thearch.gins(ADATA, nam, N);
 	datastring(sval->s, sval->len, &p->to);
 	p->from3.type = TYPE_CONST;
 	p->from3.offset = types[tptr]->width;
@@ -406,7 +406,7 @@ gdatastring(Node *nam, Strlit *sval)
 //print("%P\n", p);
 
 	nodconst(&nod1, types[TINT], sval->len);
-	p = arch.gins(ADATA, nam, &nod1);
+	p = thearch.gins(ADATA, nam, &nod1);
 	p->from3.type = TYPE_CONST;
 	p->from3.offset = widthint;
 	p->from.offset += widthptr;
@@ -418,7 +418,7 @@ dstringptr(Sym *s, int off, char *str)
 	Prog *p;
 
 	off = rnd(off, widthptr);
-	p = arch.gins(ADATA, N, N);
+	p = thearch.gins(ADATA, N, N);
 	p->from.type = TYPE_MEM;
 	p->from.name = NAME_EXTERN;
 	p->from.sym = linksym(s);
@@ -443,7 +443,7 @@ dgostrlitptr(Sym *s, int off, Strlit *lit)
 		return duintptr(s, off, 0);
 
 	off = rnd(off, widthptr);
-	p = arch.gins(ADATA, N, N);
+	p = thearch.gins(ADATA, N, N);
 	p->from.type = TYPE_MEM;
 	p->from.name = NAME_EXTERN;
 	p->from.sym = linksym(s);
@@ -481,7 +481,7 @@ dsymptr(Sym *s, int off, Sym *x, int xoff)
 
 	off = rnd(off, widthptr);
 
-	p = arch.gins(ADATA, N, N);
+	p = thearch.gins(ADATA, N, N);
 	p->from.type = TYPE_MEM;
 	p->from.name = NAME_EXTERN;
 	p->from.sym = linksym(s);
diff --git a/src/cmd/gc/pgen.c b/src/cmd/gc/pgen.c
index 1665094b73..371db2895f 100644
--- a/src/cmd/gc/pgen.c
+++ b/src/cmd/gc/pgen.c
@@ -30,7 +30,7 @@ makefuncdatasym(char *namefmt, int64 funcdatakind)
 	pnod = newname(sym);
 	pnod->class = PEXTERN;
 	nodconst(&nod, types[TINT32], funcdatakind);
-	arch.gins(AFUNCDATA, &nod, pnod);
+	thearch.gins(AFUNCDATA, &nod, pnod);
 	return sym;
 }
 
@@ -103,7 +103,7 @@ gvardefx(Node *n, int as)
 	case PAUTO:
 	case PPARAM:
 	case PPARAMOUT:
-		arch.gins(as, N, n);
+		thearch.gins(as, N, n);
 	}
 }
 
@@ -229,7 +229,7 @@ compile(Node *fn)
 	setlineno(curfn);
 
 	nodconst(&nod1, types[TINT32], 0);
-	ptxt = arch.gins(ATEXT, isblank(curfn->nname) ? N : curfn->nname, &nod1);
+	ptxt = thearch.gins(ATEXT, isblank(curfn->nname) ? N : curfn->nname, &nod1);
 	if(fn->dupok)
 		ptxt->from3.offset |= DUPOK;
 	if(fn->wrapper)
@@ -249,7 +249,7 @@ compile(Node *fn)
 	
 	afunclit(&ptxt->from, curfn->nname);
 
-	arch.ginit();
+	thearch.ginit();
 
 	gcargs = makefuncdatasym("gcargs·%d", FUNCDATA_ArgsPointerMaps);
 	gclocals = makefuncdatasym("gclocals·%d", FUNCDATA_LocalsPointerMaps);
@@ -266,7 +266,7 @@ compile(Node *fn)
 		case PPARAM:
 		case PPARAMOUT:
 			nodconst(&nod1, types[TUINTPTR], l->n->type->width);
-			p = arch.gins(ATYPE, l->n, &nod1);
+			p = thearch.gins(ATYPE, l->n, &nod1);
 			p->from.gotype = linksym(ngotype(l->n));
 			break;
 		}
@@ -274,7 +274,7 @@ compile(Node *fn)
 
 	genlist(curfn->enter);
 	genlist(curfn->nbody);
-	arch.gclean();
+	thearch.gclean();
 	checklabels();
 	if(nerrors != 0)
 		goto ret;
@@ -282,18 +282,18 @@ compile(Node *fn)
 		lineno = curfn->endlineno;
 
 	if(curfn->type->outtuple != 0)
-		arch.ginscall(throwreturn, 0);
+		thearch.ginscall(throwreturn, 0);
 
-	arch.ginit();
+	thearch.ginit();
 	// TODO: Determine when the final cgen_ret can be omitted. Perhaps always?
-	arch.cgen_ret(nil);
+	thearch.cgen_ret(nil);
 	if(hasdefer) {
 		// deferreturn pretends to have one uintptr argument.
 		// Reserve space for it so stack scanner is happy.
 		if(maxarg < widthptr)
 			maxarg = widthptr;
 	}
-	arch.gclean();
+	thearch.gclean();
 	if(nerrors != 0)
 		goto ret;
 
@@ -305,7 +305,7 @@ compile(Node *fn)
 		regopt(ptxt);
 		nilopt(ptxt);
 	}
-	arch.expandchecks(ptxt);
+	thearch.expandchecks(ptxt);
 
 	oldstksize = stksize;
 	allocauto(ptxt);
@@ -325,7 +325,7 @@ compile(Node *fn)
 	gcsymdup(gcargs);
 	gcsymdup(gclocals);
 
-	defframe(ptxt);
+	thearch.defframe(ptxt);
 
 	if(debug['f'])
 		frame(0);
@@ -469,13 +469,13 @@ allocauto(Prog* ptxt)
 
 		dowidth(n->type);
 		w = n->type->width;
-		if(w >= arch.MAXWIDTH || w < 0)
+		if(w >= thearch.MAXWIDTH || w < 0)
 			fatal("bad width");
 		stksize += w;
 		stksize = rnd(stksize, n->type->align);
 		if(haspointers(n->type))
 			stkptrsize = stksize;
-		if(arch.thechar == '5' || arch.thechar == '9')
+		if(thearch.thechar == '5' || thearch.thechar == '9')
 			stksize = rnd(stksize, widthptr);
 		if(stksize >= (1ULL<<31)) {
 			setlineno(curfn);
@@ -532,12 +532,12 @@ cgen_checknil(Node *n)
 		dump("checknil", n);
 		fatal("bad checknil");
 	}
-	if(((arch.thechar == '5' || arch.thechar == '9') && n->op != OREGISTER) || !n->addable || n->op == OLITERAL) {
-		arch.regalloc(&reg, types[tptr], n);
-		arch.cgen(n, &reg);
-		arch.gins(ACHECKNIL, &reg, N);
-		arch.regfree(&reg);
+	if(((thearch.thechar == '5' || thearch.thechar == '9') && n->op != OREGISTER) || !n->addable || n->op == OLITERAL) {
+		thearch.regalloc(&reg, types[tptr], n);
+		thearch.cgen(n, &reg);
+		thearch.gins(ACHECKNIL, &reg, N);
+		thearch.regfree(&reg);
 		return;
 	}
-	arch.gins(ACHECKNIL, n, N);
+	thearch.gins(ACHECKNIL, n, N);
 }
diff --git a/src/cmd/gc/plive.c b/src/cmd/gc/plive.c
index 05722e0f8e..283c5125e3 100644
--- a/src/cmd/gc/plive.c
+++ b/src/cmd/gc/plive.c
@@ -677,7 +677,7 @@ progeffects(Prog *prog, Array *vars, Bvec *uevar, Bvec *varkill, Bvec *avarinit)
 	bvresetall(varkill);
 	bvresetall(avarinit);
 
-	arch.proginfo(&info, prog);
+	thearch.proginfo(&info, prog);
 	if(prog->as == ARET) {
 		// Return instructions implicitly read all the arguments.  For
 		// the sake of correctness, out arguments must be read.  For the
@@ -701,7 +701,7 @@ progeffects(Prog *prog, Array *vars, Bvec *uevar, Bvec *varkill, Bvec *avarinit)
 				// If we added it to uevar too, we'd not see any kill
 				// and decide that the varible was live entry, which it is not.
 				// So only use uevar in the non-addrtaken case.
-				// The p->to.type == arch.D_NONE limits the bvset to
+				// The p->to.type == thearch.D_NONE limits the bvset to
 				// non-tail-call return instructions; see note above
 				// the for loop for details.
 				if(!node->addrtaken && prog->to.type == TYPE_NONE)
diff --git a/src/cmd/gc/popt.c b/src/cmd/gc/popt.c
index 16bbe43823..83f155564a 100644
--- a/src/cmd/gc/popt.c
+++ b/src/cmd/gc/popt.c
@@ -35,6 +35,7 @@
 #include	<u.h>
 #include	<libc.h>
 #include	"go.h"
+#include	"popt.h"
 
 // p is a call instruction. Does the call fail to return?
 int
@@ -233,7 +234,7 @@ flowstart(Prog *firstp, int size)
 	nf = 0;
 	for(p = firstp; p != P; p = p->link) {
 		p->opt = nil; // should be already, but just in case
-		arch.proginfo(&info, p);
+		thearch.proginfo(&info, p);
 		if(info.flags & Skip)
 			continue;
 		p->opt = (void*)1;
@@ -277,7 +278,7 @@ flowstart(Prog *firstp, int size)
 	// Fill in pred/succ information.
 	for(f = start; f != nil; f = f->link) {
 		p = f->prog;
-		arch.proginfo(&info, p);
+		thearch.proginfo(&info, p);
 		if(!(info.flags & Break)) {
 			f1 = f->link;
 			f->s1 = f1;
@@ -391,10 +392,6 @@ loophead(int32 *idom, Flow *r)
 	return 0;
 }
 
-enum {
-	LOOP = 3,
-};
-
 static void
 loopmark(Flow **rpo2r, int32 head, Flow *r)
 {
@@ -596,7 +593,7 @@ mergetemp(Prog *firstp)
 	// single-use (that's why we have so many!).
 	for(f = g->start; f != nil; f = f->link) {
 		p = f->prog;
-		arch.proginfo(&info, p);
+		thearch.proginfo(&info, p);
 
 		if(p->from.node != N && ((Node*)(p->from.node))->opt && p->to.node != N && ((Node*)(p->to.node))->opt)
 			fatal("double node %P", p);
@@ -616,7 +613,7 @@ mergetemp(Prog *firstp)
 	}
 	
 	if(debugmerge > 1 && debug['v'])
-		arch.dumpit("before", g->start, 0);
+		dumpit("before", g->start, 0);
 	
 	nkill = 0;
 
@@ -627,7 +624,7 @@ mergetemp(Prog *firstp)
 		// Used in only one instruction, which had better be a write.
 		if((f = v->use) != nil && (Flow*)f->data == nil) {
 			p = f->prog;
-			arch.proginfo(&info, p);
+			thearch.proginfo(&info, p);
 			if(p->to.node == v->node && (info.flags & RightWrite) && !(info.flags & RightRead)) {
 				p->as = ANOP;
 				p->to = zprog.to;
@@ -644,9 +641,9 @@ mergetemp(Prog *firstp)
 		// no jumps to the next instruction. Happens mainly in 386 compiler.
 		if((f = v->use) != nil && f->link == (Flow*)f->data && (Flow*)((Flow*)f->data)->data == nil && uniqp(f->link) == f) {
 			p = f->prog;
-			arch.proginfo(&info, p);
+			thearch.proginfo(&info, p);
 			p1 = f->link->prog;
-			arch.proginfo(&info1, p1);
+			thearch.proginfo(&info1, p1);
 			enum {
 				SizeAny = SizeB | SizeW | SizeL | SizeQ | SizeF | SizeD,
 			};
@@ -654,7 +651,7 @@ mergetemp(Prog *firstp)
 			   !((info.flags|info1.flags) & (LeftAddr|RightAddr)) &&
 			   (info.flags & SizeAny) == (info1.flags & SizeAny)) {
 				p1->from = p->from;
-				arch.excise(f);
+				thearch.excise(f);
 				v->removed = 1;
 				if(debugmerge > 0 && debug['v'])
 					print("drop immediate-use %S\n", v->node->sym);
@@ -757,7 +754,7 @@ mergetemp(Prog *firstp)
 		}
 	
 		if(debugmerge > 1 && debug['v'])
-			arch.dumpit("after", g->start, 0);
+			dumpit("after", g->start, 0);
 	}
 
 	// Update node references to use merged temporaries.
@@ -871,16 +868,16 @@ nilopt(Prog *firstp)
 		return;
 
 	if(debug_checknil > 1 /* || strcmp(curfn->nname->sym->name, "f1") == 0 */)
-		arch.dumpit("nilopt", g->start, 0);
+		dumpit("nilopt", g->start, 0);
 
 	ncheck = 0;
 	nkill = 0;
 	for(f = g->start; f != nil; f = f->link) {
 		p = f->prog;
-		if(p->as != ACHECKNIL || !arch.regtyp(&p->from))
+		if(p->as != ACHECKNIL || !thearch.regtyp(&p->from))
 			continue;
 		ncheck++;
-		if(arch.stackaddr(&p->from)) {
+		if(thearch.stackaddr(&p->from)) {
 			if(debug_checknil && p->lineno > 1)
 				warnl(p->lineno, "removed nil check of SP address");
 			f->data = &killed;
@@ -903,7 +900,7 @@ nilopt(Prog *firstp)
 	for(f = g->start; f != nil; f = f->link) {
 		if(f->data != nil) {
 			nkill++;
-			arch.excise(f);
+			thearch.excise(f);
 		}
 	}
 
@@ -922,13 +919,13 @@ nilwalkback(Flow *fcheck)
 	
 	for(f = fcheck; f != nil; f = uniqp(f)) {
 		p = f->prog;
-		arch.proginfo(&info, p);
-		if((info.flags & RightWrite) && arch.sameaddr(&p->to, &fcheck->prog->from)) {
+		thearch.proginfo(&info, p);
+		if((info.flags & RightWrite) && thearch.sameaddr(&p->to, &fcheck->prog->from)) {
 			// Found initialization of value we're checking for nil.
 			// without first finding the check, so this one is unchecked.
 			return;
 		}
-		if(f != fcheck && p->as == ACHECKNIL && arch.sameaddr(&p->from, &fcheck->prog->from)) {
+		if(f != fcheck && p->as == ACHECKNIL && thearch.sameaddr(&p->from, &fcheck->prog->from)) {
 			fcheck->data = &killed;
 			return;
 		}
@@ -949,11 +946,11 @@ nilwalkback(Flow *fcheck)
 		
 		// If same check, stop this loop but still check
 		// alternate predecessors up to this point.
-		if(f1 != fcheck && p->as == ACHECKNIL && arch.sameaddr(&p->from, &fcheck->prog->from))
+		if(f1 != fcheck && p->as == ACHECKNIL && thearch.sameaddr(&p->from, &fcheck->prog->from))
 			break;
 
-		arch.proginfo(&info, p);
-		if((info.flags & RightWrite) && arch.sameaddr(&p->to, &fcheck->prog->from)) {
+		thearch.proginfo(&info, p);
+		if((info.flags & RightWrite) && thearch.sameaddr(&p->to, &fcheck->prog->from)) {
 			// Found initialization of value we're checking for nil.
 			// without first finding the check, so this one is unchecked.
 			fcheck->kill = 0;
@@ -963,8 +960,8 @@ nilwalkback(Flow *fcheck)
 		if(f1->p1 == nil && f1->p2 == nil) {
 			print("lost pred for %P\n", fcheck->prog);
 			for(f1=f0; f1!=nil; f1=f1->p1) {
-				arch.proginfo(&info, f1->prog);
-				print("\t%P %d %d %D %D\n", r1->prog, info.flags&RightWrite, arch.sameaddr(&f1->prog->to, &fcheck->prog->from), &f1->prog->to, &fcheck->prog->from);
+				thearch.proginfo(&info, f1->prog);
+				print("\t%P %d %d %D %D\n", r1->prog, info.flags&RightWrite, thearch.sameaddr(&f1->prog->to, &fcheck->prog->from), &f1->prog->to, &fcheck->prog->from);
 			}
 			fatal("lost pred trail");
 		}
@@ -993,13 +990,13 @@ nilwalkfwd(Flow *fcheck)
 	last = nil;
 	for(f = uniqs(fcheck); f != nil; f = uniqs(f)) {
 		p = f->prog;
-		arch.proginfo(&info, p);
+		thearch.proginfo(&info, p);
 		
-		if((info.flags & LeftRead) && arch.smallindir(&p->from, &fcheck->prog->from)) {
+		if((info.flags & LeftRead) && thearch.smallindir(&p->from, &fcheck->prog->from)) {
 			fcheck->data = &killed;
 			return;
 		}
-		if((info.flags & (RightRead|RightWrite)) && arch.smallindir(&p->to, &fcheck->prog->from)) {
+		if((info.flags & (RightRead|RightWrite)) && thearch.smallindir(&p->to, &fcheck->prog->from)) {
 			fcheck->data = &killed;
 			return;
 		}
@@ -1008,10 +1005,10 @@ nilwalkfwd(Flow *fcheck)
 		if(p->as == ACHECKNIL)
 			return;
 		// Stop if value is lost.
-		if((info.flags & RightWrite) && arch.sameaddr(&p->to, &fcheck->prog->from))
+		if((info.flags & RightWrite) && thearch.sameaddr(&p->to, &fcheck->prog->from))
 			return;
 		// Stop if memory write.
-		if((info.flags & RightWrite) && !arch.regtyp(&p->to))
+		if((info.flags & RightWrite) && !thearch.regtyp(&p->to))
 			return;
 		// Stop if we jump backward.
 		if(last != nil && f->id <= last->id)
diff --git a/src/cmd/gc/reg.c b/src/cmd/gc/reg.c
index f4a88505a6..878705bd85 100644
--- a/src/cmd/gc/reg.c
+++ b/src/cmd/gc/reg.c
@@ -116,7 +116,7 @@ regopt(Prog *firstp)
 	 * than in generated c code.  define pseudo-variables for
 	 * registers, so we have complete register usage information.
 	 */
-	regnames = arch.regnames(&nreg);
+	regnames = thearch.regnames(&nreg);
 	nvar = nreg;
 	memset(var, 0, nreg*sizeof var[0]);
 	for(i=0; i<nreg; i++) {
@@ -125,7 +125,7 @@ regopt(Prog *firstp)
 		var[i].node = regnodes[i];
 	}
 
-	regbits = arch.excludedregs();
+	regbits = thearch.excludedregs();
 	externs = zbits;
 	params = zbits;
 	consts = zbits;
@@ -152,7 +152,7 @@ regopt(Prog *firstp)
 		p = f->prog;
 		if(p->as == AVARDEF || p->as == AVARKILL)
 			continue;
-		arch.proginfo(&info, p);
+		thearch.proginfo(&info, p);
 
 		// Avoid making variables for direct-called functions.
 		if(p->as == ACALL && p->to.type == TYPE_MEM && p->to.name == NAME_EXTERN)
@@ -177,7 +177,7 @@ regopt(Prog *firstp)
 
 		// Compute used register for reg
 		if(info.flags & RegRead)
-			r->use1.b[0] |= arch.RtoB(p->reg);
+			r->use1.b[0] |= thearch.RtoB(p->reg);
 
 		// Currently we never generate three register forms.
 		// If we do, this will need to change.
@@ -345,7 +345,7 @@ loop2:
 			if(debug['w'])
 				print("%L: set and not used: %Q\n", f->prog->lineno, bit);
 			f->refset = 1;
-			arch.excise(f);
+			thearch.excise(f);
 		}
 		for(z=0; z<BITS; z++)
 			bit.b[z] = LOAD(r) & ~(r->act.b[z] | addrs.b[z]);
@@ -423,7 +423,7 @@ brk:
 	 * peep-hole on basic block
 	 */
 	if(!debug['R'] || debug['P'])
-		arch.peep(firstp);
+		thearch.peep(firstp);
 
 	/*
 	 * eliminate nops
@@ -525,10 +525,10 @@ addmove(Flow *r, int bn, int rn, int f)
 		a->type = TYPE_CONST;
 	*/
 
-	p1->as = arch.optoas(OAS, types[(uchar)v->etype]);
+	p1->as = thearch.optoas(OAS, types[(uchar)v->etype]);
 	// TODO(rsc): Remove special case here.
-	if((arch.thechar == '9' || arch.thechar == '5') && v->etype == TBOOL)
-		p1->as = arch.optoas(OAS, types[TUINT8]);
+	if((thearch.thechar == '9' || thearch.thechar == '5') && v->etype == TBOOL)
+		p1->as = thearch.optoas(OAS, types[TUINT8]);
 	p1->from.type = TYPE_REG;
 	p1->from.reg = rn;
 	p1->from.name = NAME_NONE;
@@ -577,11 +577,11 @@ mkvar(Flow *f, Adr *a)
 		goto none;
 
 	r = (Reg*)f->data;
-	r->use1.b[0] |= arch.doregbits(a->index); // TODO: Use RtoB
+	r->use1.b[0] |= thearch.doregbits(a->index); // TODO: Use RtoB
 
 	switch(a->type) {
 	default:
-		regu = arch.doregbits(a->reg) | arch.RtoB(a->reg); // TODO: Use RtoB
+		regu = thearch.doregbits(a->reg) | thearch.RtoB(a->reg); // TODO: Use RtoB
 		if(regu == 0)
 			goto none;
 		bit = zbits;
@@ -590,7 +590,7 @@ mkvar(Flow *f, Adr *a)
 
 	case TYPE_ADDR:
 		// TODO(rsc): Remove special case here.
-		if(arch.thechar == '9' || arch.thechar == '5')
+		if(thearch.thechar == '9' || thearch.thechar == '5')
 			goto memcase;
 		a->type = TYPE_MEM;
 		bit = mkvar(f, a);
@@ -602,7 +602,7 @@ mkvar(Flow *f, Adr *a)
 	case TYPE_MEM:
 	memcase:
 		if(r != R) {
-			r->use1.b[0] |= arch.RtoB(a->reg);
+			r->use1.b[0] |= thearch.RtoB(a->reg);
 			/* NOTE: 5g did
 				if(r->f.prog->scond & (C_PBIT|C_WBIT))
 					r->set.b[0] |= RtoB(a->reg);
@@ -642,7 +642,7 @@ mkvar(Flow *f, Adr *a)
 			if(v->etype == et)
 			if(v->width == w) {
 				// TODO(rsc): Remove special case for arm here.
-				if(!flag || arch.thechar != '5')
+				if(!flag || thearch.thechar != '5')
 					return blsh(i);
 			}
 
@@ -920,19 +920,19 @@ allreg(uint64 b, Rgn *r)
 	case TBOOL:
 	case TPTR32:
 	case TPTR64:
-		i = arch.BtoR(~b);
+		i = thearch.BtoR(~b);
 		if(i && r->cost > 0) {
 			r->regno = i;
-			return arch.RtoB(i);
+			return thearch.RtoB(i);
 		}
 		break;
 
 	case TFLOAT32:
 	case TFLOAT64:
-		i = arch.BtoF(~b);
+		i = thearch.BtoF(~b);
 		if(i && r->cost > 0) {
 			r->regno = i;
-			return arch.FtoB(i);
+			return thearch.FtoB(i);
 		}
 		break;
 	}
diff --git a/src/cmd/gc/sinit.c b/src/cmd/gc/sinit.c
index 7dfa1e42fd..1015950e41 100644
--- a/src/cmd/gc/sinit.c
+++ b/src/cmd/gc/sinit.c
@@ -1223,7 +1223,7 @@ stataddr(Node *nam, Node *n)
 		if(l < 0)
 			break;
 		// Check for overflow.
-		if(n->type->width != 0 && arch.MAXWIDTH/n->type->width <= l)
+		if(n->type->width != 0 && thearch.MAXWIDTH/n->type->width <= l)
 			break;
  		nam->xoffset += l*n->type->width;
 		nam->type = n->type;
diff --git a/src/cmd/gc/subr.c b/src/cmd/gc/subr.c
index c91b14d151..f739a72499 100644
--- a/src/cmd/gc/subr.c
+++ b/src/cmd/gc/subr.c
@@ -2129,10 +2129,10 @@ setmaxarg(Type *t, int32 extra)
 
 	dowidth(t);
 	w = t->argwid;
-	if(w >= arch.MAXWIDTH)
+	if(w >= thearch.MAXWIDTH)
 		fatal("bad argwid %T", t);
 	w += extra;
-	if(w >= arch.MAXWIDTH)
+	if(w >= thearch.MAXWIDTH)
 		fatal("bad argwid %d + %T", extra, t);
 	if(w > maxarg)
 		maxarg = w;
diff --git a/src/cmd/gc/walk.c b/src/cmd/gc/walk.c
index 736277da91..0e69f88b66 100644
--- a/src/cmd/gc/walk.c
+++ b/src/cmd/gc/walk.c
@@ -1015,7 +1015,7 @@ walkexpr(Node **np, NodeList **init)
 
 	case OCONV:
 	case OCONVNOP:
-		if(arch.thechar == '5') {
+		if(thearch.thechar == '5') {
 			if(isfloat[n->left->type->etype]) {
 				if(n->type->etype == TINT64) {
 					n = mkcall("float64toint64", n->type, init, conv(n->left, types[TFLOAT64]));
@@ -3547,7 +3547,7 @@ walkrotate(Node **np)
 	Node *l, *r;
 	Node *n;
 
-	if(arch.thechar == '9')
+	if(thearch.thechar == '9')
 		return;
 	
 	n = *np;
@@ -3675,7 +3675,7 @@ walkdiv(Node **np, NodeList **init)
 	Magic m;
 
 	// TODO(minux)
-	if(arch.thechar == '9')
+	if(thearch.thechar == '9')
 		return;
 
 	n = *np;
