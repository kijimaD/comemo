commit 127526649f68b8fc8ea1ab041d6a01c0fd23b7e0
Author: Robert Griesemer <gri@golang.org>
Date:   Fri Feb 13 15:07:56 2009 -0800

    - vector package (identical to array except for names)
    - updated some file (but not all - left array package in place for now)
    
    R=rsc
    DELTA=530  (483 added, 0 deleted, 47 changed)
    OCL=25025
    CL=25025
---
 src/lib/container/Makefile          |  63 +++++++++++++
 src/lib/container/array/array.go    |   4 +
 src/lib/container/array/intarray.go |   4 +
 src/lib/container/intvector.go      |  64 +++++++++++++
 src/lib/container/vector.go         | 182 ++++++++++++++++++++++++++++++++++++
 src/lib/container/vector_test.go    | 172 ++++++++++++++++++++++++++++++++++
 src/lib/tabwriter/tabwriter.go      |  18 ++--
 test/vectors.go                     |   6 +-
 usr/gri/pretty/ast.go               |  18 ++--
 usr/gri/pretty/compilation.go       |   8 +-
 usr/gri/pretty/parser.go            |  26 +++---
 usr/gri/pretty/printer.go           |  12 +--
 usr/gri/pretty/symboltable.go       |   6 +-
 13 files changed, 536 insertions(+), 47 deletions(-)

diff --git a/src/lib/container/Makefile b/src/lib/container/Makefile
new file mode 100644
index 0000000000..246130c09c
--- /dev/null
+++ b/src/lib/container/Makefile
@@ -0,0 +1,63 @@
+# Copyright 2009 The Go Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style
+# license that can be found in the LICENSE file.
+
+# DO NOT EDIT.  Automatically generated by gobuild.
+# gobuild -m >Makefile
+O=6
+GC=$(O)g
+CC=$(O)c -w
+AS=$(O)a
+AR=$(O)ar
+
+default: packages
+
+clean:
+	rm -f *.$O *.a $O.out
+
+test: packages
+	gotest
+
+coverage: packages
+	gotest
+	6cov -g `pwd` | grep -v '_test\.go:'
+
+%.$O: %.go
+	$(GC) $*.go
+
+%.$O: %.c
+	$(CC) $*.c
+
+%.$O: %.s
+	$(AS) $*.s
+
+O1=\
+	vector.$O\
+
+O2=\
+	intvector.$O\
+
+vector.a: a1 a2
+
+a1:	$(O1)
+	$(AR) grc vector.a vector.$O
+	rm -f $(O1)
+
+a2:	$(O2)
+	$(AR) grc vector.a intvector.$O
+	rm -f $(O2)
+
+newpkg: clean
+	$(AR) grc vector.a
+
+$(O1): newpkg
+$(O2): a1
+
+nuke: clean
+	rm -f $(GOROOT)/pkg/vector.a
+
+packages: vector.a
+
+install: packages
+	cp vector.a $(GOROOT)/pkg/vector.a
+
diff --git a/src/lib/container/array/array.go b/src/lib/container/array/array.go
index e29736fb65..4b8f686ccb 100644
--- a/src/lib/container/array/array.go
+++ b/src/lib/container/array/array.go
@@ -2,6 +2,10 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
+//
+// *** DEPRECATED PACKAGE - USE package vector INSTEAD ***
+//
+
 package array
 
 type (
diff --git a/src/lib/container/array/intarray.go b/src/lib/container/array/intarray.go
index 427ed5076c..5f9549cfeb 100644
--- a/src/lib/container/array/intarray.go
+++ b/src/lib/container/array/intarray.go
@@ -2,6 +2,10 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
+//
+// *** DEPRECATED PACKAGE - USE package vector INSTEAD ***
+//
+
 package array
 
 import "array"
diff --git a/src/lib/container/intvector.go b/src/lib/container/intvector.go
new file mode 100644
index 0000000000..9aae50d6eb
--- /dev/null
+++ b/src/lib/container/intvector.go
@@ -0,0 +1,64 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package vector
+
+import "vector"
+
+type IntVector struct {
+	// TODO do not export field
+	vector.Vector;
+}
+
+
+func (p *IntVector) Init(len int) *IntVector {
+	p.Vector.Init(len);
+	return p;
+}
+
+
+func NewIntVector(len int) *IntVector {
+	return new(IntVector).Init(len)
+}
+
+
+func (p *IntVector) At(i int) int {
+	return p.Vector.At(i).(int)
+}
+
+
+func (p *IntVector) Set(i int, x int) {
+	p.Vector.Set(i, x)
+}
+
+
+func (p *IntVector) Last() int {
+	return p.Vector.Last().(int)
+}
+
+
+func (p *IntVector) Insert(i int, x int) {
+	p.Vector.Insert(i, x)
+}
+
+
+func (p *IntVector) Delete(i int) int {
+	return p.Vector.Delete(i).(int)
+}
+
+
+func (p *IntVector) Push(x int) {
+	p.Vector.Push(x)
+}
+
+
+func (p *IntVector) Pop() int {
+	return p.Vector.Pop().(int)
+}
+
+
+// SortInterface support
+func (p *IntVector) Less(i, j int) bool {
+	return p.At(i) < p.At(j)
+}
diff --git a/src/lib/container/vector.go b/src/lib/container/vector.go
new file mode 100644
index 0000000000..805015079c
--- /dev/null
+++ b/src/lib/container/vector.go
@@ -0,0 +1,182 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package vector
+
+type (
+	Element interface {};
+	Vector struct {
+		a []Element
+	}
+)
+
+
+func copy(dst, src []Element) {
+	for i := 0; i < len(src); i++ {
+		dst[i] = src[i]
+	}
+}
+
+
+// Insert n elements at position i.
+func expand(a []Element, i, n int) []Element {
+	// make sure we have enough space
+	len0 := len(a);
+	len1 := len0 + n;
+	if len1 < cap(a) {
+		// enough space - just expand
+		a = a[0 : len1]
+	} else {
+		// not enough space - double capacity
+		capb := cap(a)*2;
+		if capb < len1 {
+			// still not enough - use required length
+			capb = len1
+		}
+		// capb >= len1
+		b := make([]Element, len1, capb);
+		copy(b, a);
+		a = b
+	}
+
+	// make a hole
+	for j := len0-1; j >= i ; j-- {
+		a[j+n] = a[j]
+	}
+	return a
+}
+
+
+func (p *Vector) Init(initial_len int) *Vector {
+	a := p.a;
+
+	if cap(a) == 0 || cap(a) < initial_len {
+		n := 8;  // initial capacity
+		if initial_len > n {
+			n = initial_len
+		}
+		a = make([]Element, n);
+	} else {
+		// nil out entries
+		for j := len(a) - 1; j >= 0; j-- {
+			a[j] = nil
+		}
+	}
+
+	p.a = a[0 : initial_len];
+	return p
+}
+
+
+func New(len int) *Vector {
+	return new(Vector).Init(len)
+}
+
+
+func (p *Vector) Len() int {
+	return len(p.a)
+}
+
+
+func (p *Vector) At(i int) Element {
+	return p.a[i]
+}
+
+
+func (p *Vector) Set(i int, x Element) {
+	p.a[i] = x
+}
+
+
+func (p *Vector) Last() Element {
+	return p.a[len(p.a) - 1]
+}
+
+
+func (p *Vector) Insert(i int, x Element) {
+	p.a = expand(p.a, i, 1);
+	p.a[i] = x;
+}
+
+
+func (p *Vector) Delete(i int) Element {
+	a := p.a;
+	n := len(a);
+
+	x := a[i];
+	copy(a[i : n-1], a[i+1 : n]);
+	a[n-1] = nil;  // support GC, nil out entry
+	p.a = a[0 : n-1];
+
+	return x
+}
+
+
+func (p *Vector) InsertVector(i int, x *Vector) {
+	p.a = expand(p.a, i, len(x.a));
+	copy(p.a[i : i + len(x.a)], x.a);
+}
+
+
+func (p *Vector) Cut(i, j int) {
+	a := p.a;
+	n := len(a);
+	m := n - (j - i);
+
+	copy(a[i : m], a[j : n]);
+	for k := m; k < n; k++ {
+		a[k] = nil  // support GC, nil out entries
+	}
+
+	p.a = a[0 : m];
+}
+
+
+func (p *Vector) Slice(i, j int) *Vector {
+	s := New(j - i);  // will fail in Init() if j < j
+	copy(s.a, p.a[i : j]);
+	return s;
+}
+
+
+func (p *Vector) Do(f func(elem Element)) {
+	for i := 0; i < len(p.a); i++ {
+		f(p.a[i])	// not too safe if f changes the Vector
+	}
+}
+
+
+// Convenience wrappers
+
+func (p *Vector) Push(x Element) {
+	p.Insert(len(p.a), x)
+}
+
+
+func (p *Vector) Pop() Element {
+	return p.Delete(len(p.a) - 1)
+}
+
+
+func (p *Vector) AppendVector(x *Vector) {
+	p.InsertVector(len(p.a), x);
+}
+
+
+// Partial SortInterface support
+
+type LessInterface interface {
+	Less(y Element) bool
+}
+
+
+func (p *Vector) Less(i, j int) bool {
+	return p.a[i].(LessInterface).Less(p.a[j])
+}
+
+
+func (p *Vector) Swap(i, j int) {
+	a := p.a;
+	a[i], a[j] = a[j], a[i]
+}
diff --git a/src/lib/container/vector_test.go b/src/lib/container/vector_test.go
new file mode 100644
index 0000000000..ac16709a0e
--- /dev/null
+++ b/src/lib/container/vector_test.go
@@ -0,0 +1,172 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package vector
+
+import "vector"
+import "testing"
+import "sort"
+
+
+func TestInit(t *testing.T) {
+	var a vector.Vector;
+	if a.Init(0).Len() != 0 { t.Error("A") }
+	if a.Init(1).Len() != 1 { t.Error("B") }
+	if a.Init(10).Len() != 10 { t.Error("C") }
+}
+
+
+func TestNew(t *testing.T) {
+	if vector.New(0).Len() != 0 { t.Error("A") }
+	if vector.New(1).Len() != 1 { t.Error("B") }
+	if vector.New(10).Len() != 10 { t.Error("C") }
+}
+
+
+func val(i int) int {
+	return i*991 - 1234
+}
+
+
+func TestAccess(t *testing.T) {
+	const n = 100;
+	var a vector.Vector;
+	a.Init(n);
+	for i := 0; i < n; i++ {
+		a.Set(i, val(i));
+	}
+	for i := 0; i < n; i++ {
+		if a.At(i).(int) != val(i) { t.Error(i) }
+	}
+}
+
+
+func TestInsertDeleteClear(t *testing.T) {
+	const n = 100;
+	a := vector.New(0);
+
+	for i := 0; i < n; i++ {
+		if a.Len() != i { t.Errorf("A) wrong len %d (expected %d)", a.Len(), i) }
+		a.Insert(0, val(i));
+		if a.Last().(int) != val(0) { t.Error("B") }
+	}
+	for i := n-1; i >= 0; i-- {
+		if a.Last().(int) != val(0) { t.Error("C") }
+		if a.Delete(0).(int) != val(i) { t.Error("D") }
+		if a.Len() != i { t.Errorf("E) wrong len %d (expected %d)", a.Len(), i) }
+	}
+
+	if a.Len() != 0 { t.Errorf("F) wrong len %d (expected 0)", a.Len()) }
+	for i := 0; i < n; i++ {
+		a.Push(val(i));
+		if a.Len() != i+1 { t.Errorf("G) wrong len %d (expected %d)", a.Len(), i+1) }
+		if a.Last().(int) != val(i) { t.Error("H") }
+	}
+	a.Init(0);
+	if a.Len() != 0 { t.Errorf("I wrong len %d (expected 0)", a.Len()) }
+
+	const m = 5;
+	for j := 0; j < m; j++ {
+		a.Push(j);
+		for i := 0; i < n; i++ {
+			x := val(i);
+			a.Push(x);
+			if a.Pop().(int) != x { t.Error("J") }
+			if a.Len() != j+1 { t.Errorf("K) wrong len %d (expected %d)", a.Len(), j+1) }
+		}
+	}
+	if a.Len() != m { t.Errorf("L) wrong len %d (expected %d)", a.Len(), m) }
+}
+
+
+func verify_slice(t *testing.T, x *vector.Vector, elt, i, j int) {
+	for k := i; k < j; k++ {
+		if x.At(k).(int) != elt {
+			t.Errorf("M) wrong [%d] element %d (expected %d)", k, x.At(k).(int), elt)
+		}
+	}
+
+	s := x.Slice(i, j);
+	for k, n := 0, j-i; k < n; k++ {
+		if s.At(k).(int) != elt {
+			t.Errorf("N) wrong [%d] element %d (expected %d)", k, x.At(k).(int), elt)
+		}
+	}
+}
+
+
+func verify_pattern(t *testing.T, x *vector.Vector, a, b, c int) {
+	n := a + b + c;
+	if x.Len() != n {
+		t.Errorf("O) wrong len %d (expected %d)", x.Len(), n)
+	}
+	verify_slice(t, x, 0, 0, a);
+	verify_slice(t, x, 1, a, a + b);
+	verify_slice(t, x, 0, a + b, n);
+}
+
+
+func make_vector(elt, len int) *vector.Vector {
+	x := vector.New(len);
+	for i := 0; i < len; i++ {
+		x.Set(i, elt);
+	}
+	return x;
+}
+
+
+func TestInsertVector(t *testing.T) {
+	// 1
+	a := make_vector(0, 0);
+	b := make_vector(1, 10);
+	a.InsertVector(0, b);
+	verify_pattern(t, a, 0, 10, 0);
+	// 2
+	a = make_vector(0, 10);
+	b = make_vector(1, 0);
+	a.InsertVector(5, b);
+	verify_pattern(t, a, 5, 0, 5);
+	// 3
+	a = make_vector(0, 10);
+	b = make_vector(1, 3);
+	a.InsertVector(3, b);
+	verify_pattern(t, a, 3, 3, 7);
+	// 4
+	a = make_vector(0, 10);
+	b = make_vector(1, 1000);
+	a.InsertVector(8, b);
+	verify_pattern(t, a, 8, 1000, 2);
+}
+
+func TestSorting(t *testing.T) {
+	const n = 100;
+	a := vector.NewIntVector(n);
+	for i := n-1; i >= 0; i-- {
+		a.Set(i, n-1-i);
+	}
+	if sort.IsSorted(a) { t.Error("not sorted") }
+}
+
+
+func TestDo(t *testing.T) {
+	const n = 25;
+	const salt = 17;
+	a := vector.NewIntVector(n);
+	for i := 0; i < n; i++ {
+		a.Set(i, salt * i);
+	}
+	count := 0;
+	a.Do(
+		func(e vector.Element) {
+			i := e.(int);
+			if i != count*salt {
+				t.Error("value at", count, "should be", count*salt, "not", i)
+			}
+			count++;
+		}
+	);
+	if count != n {
+		t.Error("should visit", n, "values; did visit", count)
+	}
+}
diff --git a/src/lib/tabwriter/tabwriter.go b/src/lib/tabwriter/tabwriter.go
index 6fea62ebae..5b02ff2f11 100644
--- a/src/lib/tabwriter/tabwriter.go
+++ b/src/lib/tabwriter/tabwriter.go
@@ -7,7 +7,7 @@ package tabwriter
 import (
 	"os";
 	"io";
-	"array";
+	"vector";
 	"utf8";
 )
 
@@ -108,9 +108,9 @@ type Writer struct {
 	size int;  // size of incomplete cell in bytes
 	width int;  // width of incomplete cell in runes up to buf[pos] w/o ignored sections
 	pos int;  // buffer position up to which width of incomplete cell has been computed
-	lines_size array.Array;  // list of lines; each line is a list of cell sizes in bytes
-	lines_width array.Array;  // list of lines; each line is a list of cell widths in runes
-	widths array.IntArray;  // list of column widths in runes - re-used during formatting
+	lines_size vector.Vector;  // list of lines; each line is a list of cell sizes in bytes
+	lines_width vector.Vector;  // list of lines; each line is a list of cell widths in runes
+	widths vector.IntVector;  // list of column widths in runes - re-used during formatting
 }
 
 // Internal representation (current state):
@@ -138,8 +138,8 @@ type Writer struct {
 
 
 func (b *Writer) addLine() {
-	b.lines_size.Push(array.NewIntArray(0));
-	b.lines_width.Push(array.NewIntArray(0));
+	b.lines_size.Push(vector.NewIntVector(0));
+	b.lines_width.Push(vector.NewIntVector(0));
 }
 
 
@@ -169,10 +169,10 @@ func (b *Writer) Init(writer io.Write, cellwidth, padding int, padchar byte, ali
 }
 
 
-func (b *Writer) line(i int) (*array.IntArray, *array.IntArray) {
+func (b *Writer) line(i int) (*vector.IntVector, *vector.IntVector) {
 	return
-		b.lines_size.At(i).(*array.IntArray),
-		b.lines_width.At(i).(*array.IntArray);
+		b.lines_size.At(i).(*vector.IntVector),
+		b.lines_width.At(i).(*vector.IntVector);
 }
 
 
diff --git a/test/vectors.go b/test/vectors.go
index 3d745dc6ae..10887771f3 100644
--- a/test/vectors.go
+++ b/test/vectors.go
@@ -6,7 +6,7 @@
 
 package main
 
-import "array"
+import "vector"
 
 
 type S struct {
@@ -21,7 +21,7 @@ func (p *S) Init(val int) *S {
 
 
 func test0() {
-	v := array.New(0);
+	v := vector.New(0);
 	if v.Len() != 0 {
 		panic("len = ", v.Len(), "\n");
 	}
@@ -34,7 +34,7 @@ func test1() {
 		a[i] = new(S).Init(i);
 	}
 
-	v := array.New(0);
+	v := vector.New(0);
 	for i := 0; i < len(a); i++ {
 		v.Insert(0, a[i]);
 		if v.Len() != i + 1 {
diff --git a/usr/gri/pretty/ast.go b/usr/gri/pretty/ast.go
index df8bfbf2cd..05bbafdbf5 100644
--- a/usr/gri/pretty/ast.go
+++ b/usr/gri/pretty/ast.go
@@ -5,7 +5,7 @@
 package AST
 
 import (
-	"array";
+	"vector";
 	Scanner "scanner";
 	SymbolTable "symboltable";
 )
@@ -90,11 +90,11 @@ type Type struct {
 
 	// syntactic components
 	Pos int;  // source position (< 0 if unknown position)
-	Expr Expr;  // type name, array length
+	Expr Expr;  // type name, vector length
 	Mode int;  // channel mode
 	Key *Type;  // receiver type or map key
-	Elt *Type;  // type name type, array, map, channel or pointer element type, function result type
-	List *array.Array; End int;  // struct fields, interface methods, function parameters
+	Elt *Type;  // type name type, vector, map, channel or pointer element type, function result type
+	List *vector.Vector; End int;  // struct fields, interface methods, function parameters
 }
 
 
@@ -305,7 +305,7 @@ func (t *Type) Nfields() int {
 
 type Block struct {
 	Node;
-	List *array.Array;
+	List *vector.Vector;
 	End int;  // position of closing "}" if present
 }
 
@@ -313,7 +313,7 @@ type Block struct {
 func NewBlock(pos, tok int) *Block {
 	assert(tok == Scanner.LBRACE || tok == Scanner.COLON);
 	b := new(Block);
-	b.Pos, b.Tok, b.List = pos, tok, array.New(0);
+	b.Pos, b.Tok, b.List = pos, tok, vector.New(0);
 	return b;
 }
 
@@ -437,7 +437,7 @@ type Decl struct {
 	Val Expr;
 	Body *Block;
 	// list of *Decl for ()-style declarations
-	List *array.Array; End int;
+	List *vector.Vector; End int;
 }
 
 
@@ -470,8 +470,8 @@ func NewComment(pos int, text string) *Comment {
 type Program struct {
 	Pos int;  // tok is Scanner.PACKAGE
 	Ident Expr;
-	Decls *array.Array;
-	Comments *array.Array;
+	Decls *vector.Vector;
+	Comments *vector.Vector;
 }
 
 
diff --git a/usr/gri/pretty/compilation.go b/usr/gri/pretty/compilation.go
index 498175cad4..460bedac52 100644
--- a/usr/gri/pretty/compilation.go
+++ b/usr/gri/pretty/compilation.go
@@ -5,7 +5,7 @@
 package Compilation
 
 import (
-	"array";
+	"vector";
 	"utf8";
 	"fmt";
 	"os";
@@ -150,7 +150,7 @@ func fileExists(name string) bool {
 }
 
 
-func printDep(localset map [string] bool, wset *array.Array, decl *AST.Decl) {
+func printDep(localset map [string] bool, wset *vector.Vector, decl *AST.Decl) {
 	src := decl.Val.(*AST.BasicLit).Val;
 	src = src[1 : len(src) - 1];  // strip "'s
 
@@ -173,7 +173,7 @@ func printDep(localset map [string] bool, wset *array.Array, decl *AST.Decl) {
 }
 
 
-func addDeps(globalset map [string] bool, wset *array.Array, src_file string, flags *Flags) {
+func addDeps(globalset map [string] bool, wset *vector.Vector, src_file string, flags *Flags) {
 	dummy, found := globalset[src_file];
 	if !found {
 		globalset[src_file] = true;
@@ -207,7 +207,7 @@ func addDeps(globalset map [string] bool, wset *array.Array, src_file string, fl
 
 func ComputeDeps(src_file string, flags *Flags) {
 	globalset := make(map [string] bool);
-	wset := array.New(0);
+	wset := vector.New(0);
 	wset.Push(Utils.TrimExt(src_file, ".go"));
 	for wset.Len() > 0 {
 		addDeps(globalset, wset, wset.Pop().(string), flags);
diff --git a/usr/gri/pretty/parser.go b/usr/gri/pretty/parser.go
index 7f1f887b80..53e409e279 100644
--- a/usr/gri/pretty/parser.go
+++ b/usr/gri/pretty/parser.go
@@ -7,7 +7,7 @@ package Parser
 import (
 	"flag";
 	"fmt";
-	"array";
+	"vector";
 	Scanner "scanner";
 	AST "ast";
 	SymbolTable "symboltable";
@@ -21,7 +21,7 @@ type Parser struct {
 
 	// Scanner
 	scanner *Scanner.Scanner;
-	comments *array.Array;
+	comments *vector.Vector;
 
 	// Scanner.Token
 	pos int;  // token source position
@@ -126,7 +126,7 @@ func (P *Parser) Open(trace, sixg, deps bool, scanner *Scanner.Scanner) {
 	P.indent = 0;
 
 	P.scanner = scanner;
-	P.comments = array.New(0);
+	P.comments = vector.New(0);
 
 	P.next();
 	P.expr_lev = 0;
@@ -423,7 +423,7 @@ func (P *Parser) parseVar(expect_ident bool) *AST.Type {
 }
 
 
-func (P *Parser) parseVarList(list *array.Array, ellipsis_ok bool) {
+func (P *Parser) parseVarList(list *vector.Vector, ellipsis_ok bool) {
 	if P.trace {
 		defer un(trace(P, "VarList"));
 	}
@@ -482,12 +482,12 @@ func (P *Parser) parseVarList(list *array.Array, ellipsis_ok bool) {
 }
 
 
-func (P *Parser) parseParameterList(ellipsis_ok bool) *array.Array {
+func (P *Parser) parseParameterList(ellipsis_ok bool) *vector.Vector {
 	if P.trace {
 		defer un(trace(P, "ParameterList"));
 	}
 
-	list := array.New(0);
+	list := vector.New(0);
 	P.parseVarList(list, ellipsis_ok);
 	for P.tok == Scanner.COMMA {
 		P.next();
@@ -543,7 +543,7 @@ func (P *Parser) parseResult(ftyp *AST.Type) *AST.Type {
 		typ := P.tryType();
 		if typ != nil {
 			t = AST.NewType(P.pos, AST.STRUCT);
-			t.List = array.New(0);
+			t.List = vector.New(0);
 			t.List.Push(&AST.TypeLit(typ));
 			t.End = P.pos;
 		}
@@ -590,7 +590,7 @@ func (P *Parser) parseFunctionType() *AST.Type {
 }
 
 
-func (P *Parser) parseMethodSpec(list *array.Array) {
+func (P *Parser) parseMethodSpec(list *vector.Vector) {
 	if P.trace {
 		defer un(trace(P, "MethodDecl"));
 	}
@@ -613,7 +613,7 @@ func (P *Parser) parseInterfaceType() *AST.Type {
 		P.openScope();
 		P.scope_lev++;
 
-		t.List = array.New(0);
+		t.List = vector.New(0);
 		for P.tok == Scanner.IDENT {
 			P.parseMethodSpec(t.List);
 			if P.tok != Scanner.RBRACE {
@@ -659,7 +659,7 @@ func (P *Parser) parseStructType() *AST.Type {
 	if P.tok == Scanner.LBRACE {
 		P.next();
 
-		t.List = array.New(0);
+		t.List = vector.New(0);
 		t.Scope = SymbolTable.NewScope(nil);
 		for P.tok != Scanner.RBRACE && P.tok != Scanner.EOF {
 			P.parseVarList(t.List, false);
@@ -728,7 +728,7 @@ func (P *Parser) tryType() *AST.Type {
 // Blocks
 
 
-func (P *Parser) parseStatementList(list *array.Array) {
+func (P *Parser) parseStatementList(list *vector.Vector) {
 	if P.trace {
 		defer un(trace(P, "StatementList"));
 	}
@@ -1560,7 +1560,7 @@ func (P *Parser) parseDecl(keyword int) *AST.Decl {
 	P.expect(keyword);
 	if P.tok == Scanner.LPAREN {
 		P.next();
-		d.List = array.New(0);
+		d.List = vector.New(0);
 		for P.tok != Scanner.RPAREN && P.tok != Scanner.EOF {
 			d1 := AST.NewDecl(P.pos, keyword);
 			P.parseSpec(d1);
@@ -1658,7 +1658,7 @@ func (P *Parser) ParseProgram() *AST.Program {
 
 	// package body
 	{	P.openScope();
-		p.Decls = array.New(0);
+		p.Decls = vector.New(0);
 		for P.tok == Scanner.IMPORT {
 			p.Decls.Push(P.parseDecl(Scanner.IMPORT));
 			P.OptSemicolon();
diff --git a/usr/gri/pretty/printer.go b/usr/gri/pretty/printer.go
index a0de7d06a6..67a9615809 100644
--- a/usr/gri/pretty/printer.go
+++ b/usr/gri/pretty/printer.go
@@ -7,7 +7,7 @@ package Printer
 import (
 	"os";
 	"io";
-	"array";
+	"vector";
 	"tabwriter";
 	"flag";
 	"fmt";
@@ -83,7 +83,7 @@ type Printer struct {
 	html bool;
 
 	// comments
-	comments *array.Array;  // the list of all comments
+	comments *vector.Vector;  // the list of all comments
 	cindex int;  // the current comments index
 	cpos int;  // the position of the next comment
 
@@ -120,7 +120,7 @@ func (P *Printer) NextComment() {
 }
 
 
-func (P *Printer) Init(text io.Write, html bool, comments *array.Array) {
+func (P *Printer) Init(text io.Write, html bool, comments *vector.Vector) {
 	// writers
 	P.text = text;
 	
@@ -452,7 +452,7 @@ func (P *Printer) HtmlPackageName(pos int, name string) {
 func (P *Printer) Type(t *AST.Type) int
 func (P *Printer) Expr(x AST.Expr)
 
-func (P *Printer) Parameters(pos int, list *array.Array) {
+func (P *Printer) Parameters(pos int, list *vector.Vector) {
 	P.String(pos, "(");
 	if list != nil {
 		var prev int;
@@ -500,7 +500,7 @@ func (P *Printer) Signature(t *AST.Type) int {
 }
 
 
-func (P *Printer) Fields(list *array.Array, end int, in_interface bool) {
+func (P *Printer) Fields(list *vector.Vector, end int, in_interface bool) {
 	P.state = opening_scope;
 	P.String(0, "{");
 
@@ -745,7 +745,7 @@ func (P *Printer) Stat(s AST.Stat) {
 }
 
 
-func (P *Printer) StatementList(list *array.Array) {
+func (P *Printer) StatementList(list *vector.Vector) {
 	for i, n := 0, list.Len(); i < n; i++ {
 		P.newlines = 1;  // for first entry
 		list.At(i).(AST.Stat).Visit(P);
diff --git a/usr/gri/pretty/symboltable.go b/usr/gri/pretty/symboltable.go
index 26c81ea42c..c0435ea03e 100644
--- a/usr/gri/pretty/symboltable.go
+++ b/usr/gri/pretty/symboltable.go
@@ -7,7 +7,7 @@ package SymbolTable
 import (
 	"utf8";
 	"unicode";
-	"array";
+	"vector";
 )
 
 
@@ -269,7 +269,7 @@ type Type struct {
 	Mode int;  // channel mode
 	Key *Type;  // receiver type or map key
 	Elt *Type;  // type name type, array, map, channel or pointer element type, function result type
-	List *array.Array; End int;  // struct fields, interface methods, function parameters
+	List *vector.Vector; End int;  // struct fields, interface methods, function parameters
 }
 
 
@@ -304,7 +304,7 @@ func (typ* Type) String() string {
 
 var (
 	Universe *Scope;
-	PredeclaredTypes array.Array;
+	PredeclaredTypes vector.Vector;
 
 	// internal types
 	Void_typ,
