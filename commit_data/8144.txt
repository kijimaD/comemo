commit 40fccbce6b0a93d86db03ba4a3d5de68d45e250b
Author: Russ Cox <rsc@golang.org>
Date:   Mon Apr 18 14:35:33 2011 -0400

    reflect: more efficient; cannot Set result of NewValue anymore
    
     * Reduces malloc counts during gob encoder/decoder test from 6/6 to 3/5.
    
    The current reflect uses Set to mean two subtly different things.
    
    (1) If you have a reflect.Value v, it might just represent
    itself (as in v = reflect.NewValue(42)), in which case calling
    v.Set only changed v, not any other data in the program.
    
    (2) If you have a reflect Value v derived from a pointer
    or a slice (as in x := []int{42}; v = reflect.NewValue(x).Index(0)),
    v represents the value held there.  Changing x[0] affects the
    value returned by v.Int(), and calling v.Set affects x[0].
    
    This was not really by design; it just happened that way.
    
    The motivation for the new reflect implementation was
    to remove mallocs.  The use case (1) has an implicit malloc
    inside it.  If you can do:
    
           v := reflect.NewValue(0)
           v.Set(42)
           i := v.Int()  // i = 42
    
    then that implies that v is referring to some underlying
    chunk of memory in order to remember the 42; that is,
    NewValue must have allocated some memory.
    
    Almost all the time you are using reflect the goal is to
    inspect or to change other data, not to manipulate data
    stored solely inside a reflect.Value.
    
    This CL removes use case (1), so that an assignable
    reflect.Value must always refer to some other piece of data
    in the program.  Put another way, removing this case would
    make
    
           v := reflect.NewValue(0)
           v.Set(42)
    
    as illegal as
    
           0 = 42.
    
    It would also make this illegal:
    
           x := 0
           v := reflect.NewValue(x)
           v.Set(42)
    
    for the same reason.  (Note that right now, v.Set(42) "succeeds"
    but does not change the value of x.)
    
    If you really wanted to make v refer to x, you'd start with &x
    and dereference it:
    
           x := 0
           v := reflect.NewValue(&x).Elem()  // v = *&x
           v.Set(42)
    
    It's pretty rare, except in tests, to want to use NewValue and then
    call Set to change the Value itself instead of some other piece of
    data in the program.  I haven't seen it happen once yet while
    making the tree build with this change.
    
    For the same reasons, reflect.Zero (formerly reflect.MakeZero)
    would also return an unassignable, unaddressable value.
    This invalidates the (awkward) idiom:
    
           pv := ... some Ptr Value we have ...
           v := reflect.Zero(pv.Type().Elem())
           pv.PointTo(v)
    
    which, when the API changed, turned into:
    
           pv := ... some Ptr Value we have ...
           v := reflect.Zero(pv.Type().Elem())
           pv.Set(v.Addr())
    
    In both, it is far from clear what the code is trying to do.  Now that
    it is possible, this CL adds reflect.New(Type) Value that does the
    obvious thing (same as Go's new), so this code would be replaced by:
    
           pv := ... some Ptr Value we have ...
           pv.Set(reflect.New(pv.Type().Elem()))
    
    The changes just described can be confusing to think about,
    but I believe it is because the old API was confusing - it was
    conflating two different kinds of Values - and that the new API
    by itself is pretty simple: you can only Set (or call Addr on)
    a Value if it actually addresses some real piece of data; that is,
    only if it is the result of dereferencing a Ptr or indexing a Slice.
    
    If you really want the old behavior, you'd get it by translating:
    
           v := reflect.NewValue(x)
    
    into
    
           v := reflect.New(reflect.Typeof(x)).Elem()
           v.Set(reflect.NewValue(x))
    
    Gofix will not be able to help with this, because whether
    and how to change the code depends on whether the original
    code meant use (1) or use (2), so the developer has to read
    and think about the code.
    
    You can see the effect on packages in the tree in
    https://golang.org/cl/4423043/.
    
    R=r
    CC=golang-dev
    https://golang.org/cl/4435042
---
 src/pkg/reflect/all_test.go  |  182 +++--
 src/pkg/reflect/deepequal.go |   45 +-
 src/pkg/reflect/type.go      |   51 +-
 src/pkg/reflect/value.go     | 1778 +++++++++++++++++++++---------------------
 src/pkg/runtime/Makefile     |    1 -
 src/pkg/runtime/chan.c       |  103 ++-
 src/pkg/runtime/hashmap.c    |  121 ++-
 src/pkg/runtime/iface.c      |   54 +-
 src/pkg/runtime/reflect.goc  |  114 ---
 src/pkg/runtime/runtime.h    |    2 -
 10 files changed, 1312 insertions(+), 1139 deletions(-)

diff --git a/src/pkg/reflect/all_test.go b/src/pkg/reflect/all_test.go
index bc9157672a..8529c62ae5 100644
--- a/src/pkg/reflect/all_test.go
+++ b/src/pkg/reflect/all_test.go
@@ -10,6 +10,7 @@ import (
 	"io"
 	"os"
 	. "reflect"
+	"runtime"
 	"testing"
 	"unsafe"
 )
@@ -155,45 +156,45 @@ var typeTests = []pair{
 }
 
 var valueTests = []pair{
-	{(int8)(0), "8"},
-	{(int16)(0), "16"},
-	{(int32)(0), "32"},
-	{(int64)(0), "64"},
-	{(uint8)(0), "8"},
-	{(uint16)(0), "16"},
-	{(uint32)(0), "32"},
-	{(uint64)(0), "64"},
-	{(float32)(0), "256.25"},
-	{(float64)(0), "512.125"},
-	{(string)(""), "stringy cheese"},
-	{(bool)(false), "true"},
-	{(*int8)(nil), "*int8(0)"},
-	{(**int8)(nil), "**int8(0)"},
-	{[5]int32{}, "[5]int32{0, 0, 0, 0, 0}"},
-	{(**integer)(nil), "**reflect_test.integer(0)"},
-	{(map[string]int32)(nil), "map[string] int32{<can't iterate on maps>}"},
-	{(chan<- string)(nil), "chan<- string"},
-	{struct {
+	{new(int8), "8"},
+	{new(int16), "16"},
+	{new(int32), "32"},
+	{new(int64), "64"},
+	{new(uint8), "8"},
+	{new(uint16), "16"},
+	{new(uint32), "32"},
+	{new(uint64), "64"},
+	{new(float32), "256.25"},
+	{new(float64), "512.125"},
+	{new(string), "stringy cheese"},
+	{new(bool), "true"},
+	{new(*int8), "*int8(0)"},
+	{new(**int8), "**int8(0)"},
+	{new([5]int32), "[5]int32{0, 0, 0, 0, 0}"},
+	{new(**integer), "**reflect_test.integer(0)"},
+	{new(map[string]int32), "map[string] int32{<can't iterate on maps>}"},
+	{new(chan<- string), "chan<- string"},
+	{new(func(a int8, b int32)), "func(int8, int32)(0)"},
+	{new(struct {
 		c chan *int32
 		d float32
-	}{},
+	}),
 		"struct { c chan *int32; d float32 }{chan *int32, 0}",
 	},
-	{(func(a int8, b int32))(nil), "func(int8, int32)(0)"},
-	{struct{ c func(chan *integer, *int8) }{},
+	{new(struct{ c func(chan *integer, *int8) }),
 		"struct { c func(chan *reflect_test.integer, *int8) }{func(chan *reflect_test.integer, *int8)(0)}",
 	},
-	{struct {
+	{new(struct {
 		a int8
 		b int32
-	}{},
+	}),
 		"struct { a int8; b int32 }{0, 0}",
 	},
-	{struct {
+	{new(struct {
 		a int8
 		b int8
 		c int32
-	}{},
+	}),
 		"struct { a int8; b int8; c int32 }{0, 0, 0}",
 	},
 }
@@ -213,7 +214,7 @@ func TestTypes(t *testing.T) {
 
 func TestSet(t *testing.T) {
 	for i, tt := range valueTests {
-		v := NewValue(tt.i)
+		v := NewValue(tt.i).Elem()
 		switch v.Kind() {
 		case Int:
 			v.SetInt(132)
@@ -257,7 +258,7 @@ func TestSet(t *testing.T) {
 
 func TestSetValue(t *testing.T) {
 	for i, tt := range valueTests {
-		v := NewValue(tt.i)
+		v := NewValue(tt.i).Elem()
 		switch v.Kind() {
 		case Int:
 			v.Set(NewValue(int(132)))
@@ -324,7 +325,7 @@ func TestValueToString(t *testing.T) {
 }
 
 func TestArrayElemSet(t *testing.T) {
-	v := NewValue([10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
+	v := NewValue(&[10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}).Elem()
 	v.Index(4).SetInt(123)
 	s := valueToString(v)
 	const want = "[10]int{1, 2, 3, 4, 123, 6, 7, 8, 9, 10}"
@@ -345,14 +346,14 @@ func TestPtrPointTo(t *testing.T) {
 	var ip *int32
 	var i int32 = 1234
 	vip := NewValue(&ip)
-	vi := NewValue(i)
+	vi := NewValue(&i).Elem()
 	vip.Elem().Set(vi.Addr())
 	if *ip != 1234 {
 		t.Errorf("got %d, want 1234", *ip)
 	}
 
 	ip = nil
-	vp := NewValue(ip)
+	vp := NewValue(&ip).Elem()
 	vp.Set(Zero(vp.Type()))
 	if ip != nil {
 		t.Errorf("got non-nil (%p), want nil", ip)
@@ -428,9 +429,9 @@ func TestAll(t *testing.T) {
 
 func TestInterfaceGet(t *testing.T) {
 	var inter struct {
-		e interface{}
+		E interface{}
 	}
-	inter.e = 123.456
+	inter.E = 123.456
 	v1 := NewValue(&inter)
 	v2 := v1.Elem().Field(0)
 	assert(t, v2.Type().String(), "interface { }")
@@ -441,9 +442,9 @@ func TestInterfaceGet(t *testing.T) {
 
 func TestInterfaceValue(t *testing.T) {
 	var inter struct {
-		e interface{}
+		E interface{}
 	}
-	inter.e = 123.456
+	inter.E = 123.456
 	v1 := NewValue(&inter)
 	v2 := v1.Elem().Field(0)
 	assert(t, v2.Type().String(), "interface { }")
@@ -457,8 +458,9 @@ func TestInterfaceValue(t *testing.T) {
 }
 
 func TestFunctionValue(t *testing.T) {
-	v := NewValue(func() {})
-	if v.Interface() != v.Interface() {
+	var x interface{} = func() {}
+	v := NewValue(x)
+	if v.Interface() != v.Interface() || v.Interface() != x {
 		t.Fatalf("TestFunction != itself")
 	}
 	assert(t, v.Type().String(), "func()")
@@ -471,6 +473,18 @@ var appendTests = []struct {
 	{make([]int, 2, 4), []int{22, 33, 44}},
 }
 
+func sameInts(x, y []int) bool {
+	if len(x) != len(y) {
+		return false
+	}
+	for i, xx := range x {
+		if xx != y[i] {
+			return false
+		}
+	}
+	return true
+}
+
 func TestAppend(t *testing.T) {
 	for i, test := range appendTests {
 		origLen, extraLen := len(test.orig), len(test.extra)
@@ -485,8 +499,8 @@ func TestAppend(t *testing.T) {
 		// Test Append.
 		a0 := NewValue(test.orig)
 		have0 := Append(a0, e0...).Interface().([]int)
-		if !DeepEqual(have0, want) {
-			t.Errorf("Append #%d: have %v, want %v", i, have0, want)
+		if !sameInts(have0, want) {
+			t.Errorf("Append #%d: have %v, want %v (%p %p)", i, have0, want, test.orig, have0)
 		}
 		// Check that the orig and extra slices were not modified.
 		if len(test.orig) != origLen {
@@ -498,7 +512,7 @@ func TestAppend(t *testing.T) {
 		// Test AppendSlice.
 		a1 := NewValue(test.orig)
 		have1 := AppendSlice(a1, e1).Interface().([]int)
-		if !DeepEqual(have1, want) {
+		if !sameInts(have1, want) {
 			t.Errorf("AppendSlice #%d: have %v, want %v", i, have1, want)
 		}
 		// Check that the orig and extra slices were not modified.
@@ -520,8 +534,10 @@ func TestCopy(t *testing.T) {
 			t.Fatalf("b != c before test")
 		}
 	}
-	aa := NewValue(a)
-	ab := NewValue(b)
+	a1 := a
+	b1 := b
+	aa := NewValue(&a1).Elem()
+	ab := NewValue(&b1).Elem()
 	for tocopy := 1; tocopy <= 7; tocopy++ {
 		aa.SetLen(tocopy)
 		Copy(ab, aa)
@@ -809,34 +825,6 @@ func TestInterfaceExtraction(t *testing.T) {
 	}
 }
 
-func TestInterfaceEditing(t *testing.T) {
-	// strings are bigger than one word,
-	// so the interface conversion allocates
-	// memory to hold a string and puts that
-	// pointer in the interface.
-	var i interface{} = "hello"
-
-	// if i pass the interface value by value
-	// to NewValue, i should get a fresh copy
-	// of the value.
-	v := NewValue(i)
-
-	// and setting that copy to "bye" should
-	// not change the value stored in i.
-	v.SetString("bye")
-	if i.(string) != "hello" {
-		t.Errorf(`Set("bye") changed i to %s`, i.(string))
-	}
-
-	// the same should be true of smaller items.
-	i = 123
-	v = NewValue(i)
-	v.SetInt(234)
-	if i.(int) != 123 {
-		t.Errorf("Set(234) changed i to %d", i.(int))
-	}
-}
-
 func TestNilPtrValueSub(t *testing.T) {
 	var pi *int
 	if pv := NewValue(pi); pv.Elem().IsValid() {
@@ -983,7 +971,7 @@ func TestChan(t *testing.T) {
 		t.Errorf("TrySend on sync chan succeeded")
 	}
 	if v, ok := cv.TryRecv(); v.IsValid() || ok {
-		t.Errorf("TryRecv on sync chan succeeded")
+		t.Errorf("TryRecv on sync chan succeeded: isvalid=%v ok=%v", v.IsValid(), ok)
 	}
 
 	// len/cap
@@ -1022,7 +1010,10 @@ type Point struct {
 	x, y int
 }
 
-func (p Point) Dist(scale int) int { return p.x*p.x*scale + p.y*p.y*scale }
+func (p Point) Dist(scale int) int {
+	//	println("Point.Dist", p.x, p.y, scale)
+	return p.x*p.x*scale + p.y*p.y*scale
+}
 
 func TestMethod(t *testing.T) {
 	// Non-curried method of type.
@@ -1049,18 +1040,12 @@ func TestMethod(t *testing.T) {
 		t.Errorf("Value Method returned %d; want 250", i)
 	}
 
-	// Curried method of pointer to value.
-	i = NewValue(p).Addr().Method(0).Call([]Value{NewValue(10)})[0].Int()
-	if i != 250 {
-		t.Errorf("Value Method returned %d; want 250", i)
-	}
-
 	// Curried method of interface value.
 	// Have to wrap interface value in a struct to get at it.
 	// Passing it to NewValue directly would
 	// access the underlying Point, not the interface.
 	var s = struct {
-		x interface {
+		X interface {
 			Dist(int) int
 		}
 	}{p}
@@ -1385,7 +1370,8 @@ func TestAddr(t *testing.T) {
 
 	// Again but take address of the NewValue value.
 	// Exercises generation of PtrTypes not present in the binary.
-	v = NewValue(&p)
+	q := &p
+	v = NewValue(&q).Elem()
 	v = v.Addr()
 	v = v.Elem()
 	v = v.Elem()
@@ -1399,7 +1385,8 @@ func TestAddr(t *testing.T) {
 
 	// Starting without pointer we should get changed value
 	// in interface.
-	v = NewValue(p)
+	qq := p
+	v = NewValue(&qq).Elem()
 	v0 := v
 	v = v.Addr()
 	v = v.Elem()
@@ -1415,3 +1402,36 @@ func TestAddr(t *testing.T) {
 		t.Errorf("Addr.Elem.Set valued to set value in top value")
 	}
 }
+
+func noAlloc(t *testing.T, n int, f func(int)) {
+	// once to prime everything
+	f(-1)
+	runtime.MemStats.Mallocs = 0
+
+	for j := 0; j < n; j++ {
+		f(j)
+	}
+	if runtime.MemStats.Mallocs != 0 {
+		t.Fatalf("%d mallocs after %d iterations", runtime.MemStats.Mallocs, n)
+	}
+}
+
+func TestAllocations(t *testing.T) {
+	noAlloc(t, 100, func(j int) {
+		var i interface{}
+		var v Value
+		i = 42 + j
+		v = NewValue(i)
+		if int(v.Int()) != 42+j {
+			panic("wrong int")
+		}
+	})
+}
+
+func TestSmallNegativeInt(t *testing.T) {
+	i := int16(-1)
+	v := NewValue(i)
+	if v.Int() != -1 {
+		t.Errorf("int16(-1).Int() returned %v", v.Int())
+	}
+}
diff --git a/src/pkg/reflect/deepequal.go b/src/pkg/reflect/deepequal.go
index f5a7814601..18fed3ca1d 100644
--- a/src/pkg/reflect/deepequal.go
+++ b/src/pkg/reflect/deepequal.go
@@ -6,7 +6,6 @@
 
 package reflect
 
-
 // During deepValueEqual, must keep track of checks that are
 // in progress.  The comparison algorithm assumes that all
 // checks in progress are true when it reencounters them.
@@ -21,7 +20,7 @@ type visit struct {
 // Tests for deep equality using reflected types. The map argument tracks
 // comparisons that have already been seen, which allows short circuiting on
 // recursive types.
-func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) bool {
+func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) (b bool) {
 	if !v1.IsValid() || !v2.IsValid() {
 		return v1.IsValid() == v2.IsValid()
 	}
@@ -31,30 +30,32 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) bool {
 
 	// if depth > 10 { panic("deepValueEqual") }	// for debugging
 
-	addr1 := v1.UnsafeAddr()
-	addr2 := v2.UnsafeAddr()
-	if addr1 > addr2 {
-		// Canonicalize order to reduce number of entries in visited.
-		addr1, addr2 = addr2, addr1
-	}
-
-	// Short circuit if references are identical ...
-	if addr1 == addr2 {
-		return true
-	}
+	if v1.CanAddr() && v2.CanAddr() {
+		addr1 := v1.UnsafeAddr()
+		addr2 := v2.UnsafeAddr()
+		if addr1 > addr2 {
+			// Canonicalize order to reduce number of entries in visited.
+			addr1, addr2 = addr2, addr1
+		}
 
-	// ... or already seen
-	h := 17*addr1 + addr2
-	seen := visited[h]
-	typ := v1.Type()
-	for p := seen; p != nil; p = p.next {
-		if p.a1 == addr1 && p.a2 == addr2 && p.typ == typ {
+		// Short circuit if references are identical ...
+		if addr1 == addr2 {
 			return true
 		}
-	}
 
-	// Remember for later.
-	visited[h] = &visit{addr1, addr2, typ, seen}
+		// ... or already seen
+		h := 17*addr1 + addr2
+		seen := visited[h]
+		typ := v1.Type()
+		for p := seen; p != nil; p = p.next {
+			if p.a1 == addr1 && p.a2 == addr2 && p.typ == typ {
+				return true
+			}
+		}
+
+		// Remember for later.
+		visited[h] = &visit{addr1, addr2, typ, seen}
+	}
 
 	switch v1.Kind() {
 	case Array:
diff --git a/src/pkg/reflect/type.go b/src/pkg/reflect/type.go
index 9f3e0bf682..4801731bbe 100644
--- a/src/pkg/reflect/type.go
+++ b/src/pkg/reflect/type.go
@@ -47,7 +47,7 @@ type Type interface {
 	// method signature, without a receiver, and the Func field is nil.
 	Method(int) Method
 
-	// NumMethods returns the number of methods in the type's method set.
+	// NumMethod returns the number of methods in the type's method set.
 	NumMethod() int
 
 	// Name returns the type's name within its package.
@@ -162,6 +162,8 @@ type Type interface {
 	// It panics if i is not in the range [0, NumOut()).
 	Out(i int) Type
 
+	runtimeType() *runtime.Type
+	common() *commonType
 	uncommon() *uncommonType
 }
 
@@ -408,9 +410,12 @@ func (t *commonType) String() string { return *t.string }
 func (t *commonType) Size() uintptr { return t.size }
 
 func (t *commonType) Bits() int {
+	if t == nil {
+		panic("reflect: Bits of nil Type")
+	}
 	k := t.Kind()
 	if k < Int || k > Complex128 {
-		panic("reflect: Bits of non-arithmetic Type")
+		panic("reflect: Bits of non-arithmetic Type " + t.String())
 	}
 	return int(t.size) * 8
 }
@@ -431,12 +436,14 @@ func (t *uncommonType) Method(i int) (m Method) {
 	if p.name != nil {
 		m.Name = *p.name
 	}
+	flag := uint32(0)
 	if p.pkgPath != nil {
 		m.PkgPath = *p.pkgPath
+		flag |= flagRO
 	}
 	m.Type = toType(p.typ)
 	fn := p.tfn
-	m.Func = Value{&funcValue{value: value{m.Type, addr(&fn), canSet}}}
+	m.Func = valueFromIword(flag, m.Type, iword(fn))
 	return
 }
 
@@ -772,24 +779,32 @@ func (t *structType) FieldByNameFunc(match func(string) bool) (f StructField, pr
 }
 
 // Convert runtime type to reflect type.
-func toType(p *runtime.Type) Type {
+func toCommonType(p *runtime.Type) *commonType {
+	if p == nil {
+		return nil
+	}
 	type hdr struct {
 		x interface{}
 		t commonType
 	}
-	t := &(*hdr)(unsafe.Pointer(p)).t
-	return t.toType()
+	x := unsafe.Pointer(p)
+	if uintptr(x)&reflectFlags != 0 {
+		panic("invalid interface value")
+	}
+	return &(*hdr)(x).t
+}
+
+func toType(p *runtime.Type) Type {
+	if p == nil {
+		return nil
+	}
+	return toCommonType(p).toType()
 }
 
 // Typeof returns the reflection Type of the value in the interface{}.
 func Typeof(i interface{}) Type {
-	type hdr struct {
-		typ *byte
-		val *commonType
-	}
-	rt := unsafe.Typeof(i)
-	t := (*(*hdr)(unsafe.Pointer(&rt))).val
-	return t.toType()
+	eface := *(*emptyInterface)(unsafe.Pointer(&i))
+	return toType(eface.typ)
 }
 
 // ptrMap is the cache for PtrTo.
@@ -798,6 +813,16 @@ var ptrMap struct {
 	m map[*commonType]*ptrType
 }
 
+func (t *commonType) runtimeType() *runtime.Type {
+	// The runtime.Type always precedes the commonType in memory.
+	// Adjust pointer to find it.
+	var rt struct {
+		i  runtime.Type
+		ct commonType
+	}
+	return (*runtime.Type)(unsafe.Pointer(uintptr(unsafe.Pointer(t)) - uintptr(unsafe.Offsetof(rt.ct))))
+}
+
 // PtrTo returns the pointer type with element t.
 // For example, if t represents type Foo, PtrTo(t) represents *Foo.
 func PtrTo(t Type) Type {
diff --git a/src/pkg/reflect/value.go b/src/pkg/reflect/value.go
index ddc31100f1..b31aa5a211 100644
--- a/src/pkg/reflect/value.go
+++ b/src/pkg/reflect/value.go
@@ -7,17 +7,16 @@ package reflect
 import (
 	"math"
 	"runtime"
+	"strconv"
 	"unsafe"
 )
 
 const ptrSize = uintptr(unsafe.Sizeof((*byte)(nil)))
 const cannotSet = "cannot set value obtained from unexported struct field"
 
-type addr unsafe.Pointer
-
 // TODO: This will have to go away when
 // the new gc goes in.
-func memmove(adst, asrc addr, n uintptr) {
+func memmove(adst, asrc unsafe.Pointer, n uintptr) {
 	dst := uintptr(adst)
 	src := uintptr(asrc)
 	switch {
@@ -26,17 +25,17 @@ func memmove(adst, asrc addr, n uintptr) {
 		// careful: i is unsigned
 		for i := n; i > 0; {
 			i--
-			*(*byte)(addr(dst + i)) = *(*byte)(addr(src + i))
+			*(*byte)(unsafe.Pointer(dst + i)) = *(*byte)(unsafe.Pointer(src + i))
 		}
 	case (n|src|dst)&(ptrSize-1) != 0:
 		// byte copy forward
 		for i := uintptr(0); i < n; i++ {
-			*(*byte)(addr(dst + i)) = *(*byte)(addr(src + i))
+			*(*byte)(unsafe.Pointer(dst + i)) = *(*byte)(unsafe.Pointer(src + i))
 		}
 	default:
 		// word copy forward
 		for i := uintptr(0); i < n; i += ptrSize {
-			*(*uintptr)(addr(dst + i)) = *(*uintptr)(addr(src + i))
+			*(*uintptr)(unsafe.Pointer(dst + i)) = *(*uintptr)(unsafe.Pointer(src + i))
 		}
 	}
 }
@@ -54,15 +53,16 @@ func memmove(adst, asrc addr, n uintptr) {
 // its String method returns "<invalid Value>", and all other methods panic.
 // Most functions and methods never return an invalid value.
 // If one does, its documentation states the conditions explicitly.
+//
+// The fields of Value are exported so that clients can copy and
+// pass Values around, but they should not be edited or inspected
+// directly.  A future language change may make it possible not to
+// export these fields while still keeping Values usable as values.
 type Value struct {
-	Internal valueInterface
+	Internal       interface{}
+	InternalMethod int
 }
 
-// TODO(rsc): This implementation of Value is a just a façade
-// in front of the old implementation, now called valueInterface.
-// A future CL will change it to a real implementation.
-// Changing the API is already a big enough step for one CL.
-
 // A ValueError occurs when a Value method is invoked on
 // a Value that does not support it.  Such cases are documented
 // in the description of each method.
@@ -89,37 +89,286 @@ func methodName() string {
 	return f.Name()
 }
 
-func (v Value) internal() valueInterface {
-	vi := v.Internal
-	if vi == nil {
-		panic(&ValueError{methodName(), 0})
+// An iword is the word that would be stored in an
+// interface to represent a given value v.  Specifically, if v is
+// bigger than a pointer, its word is a pointer to v's data.
+// Otherwise, its word is a zero uintptr with the data stored
+// in the leading bytes.
+type iword uintptr
+
+func loadIword(p unsafe.Pointer, size uintptr) iword {
+	// Run the copy ourselves instead of calling memmove
+	// to avoid moving v to the heap.
+	w := iword(0)
+	switch size {
+	default:
+		panic("reflect: internal error: loadIword of " + strconv.Itoa(int(size)) + "-byte value")
+	case 0:
+	case 1:
+		*(*uint8)(unsafe.Pointer(&w)) = *(*uint8)(p)
+	case 2:
+		*(*uint16)(unsafe.Pointer(&w)) = *(*uint16)(p)
+	case 3:
+		*(*[3]byte)(unsafe.Pointer(&w)) = *(*[3]byte)(p)
+	case 4:
+		*(*uint32)(unsafe.Pointer(&w)) = *(*uint32)(p)
+	case 5:
+		*(*[5]byte)(unsafe.Pointer(&w)) = *(*[5]byte)(p)
+	case 6:
+		*(*[6]byte)(unsafe.Pointer(&w)) = *(*[6]byte)(p)
+	case 7:
+		*(*[7]byte)(unsafe.Pointer(&w)) = *(*[7]byte)(p)
+	case 8:
+		*(*uint64)(unsafe.Pointer(&w)) = *(*uint64)(p)
+	}
+	return w
+}
+
+func storeIword(p unsafe.Pointer, w iword, size uintptr) {
+	// Run the copy ourselves instead of calling memmove
+	// to avoid moving v to the heap.
+	switch size {
+	default:
+		panic("reflect: internal error: storeIword of " + strconv.Itoa(int(size)) + "-byte value")
+	case 0:
+	case 1:
+		*(*uint8)(p) = *(*uint8)(unsafe.Pointer(&w))
+	case 2:
+		*(*uint16)(p) = *(*uint16)(unsafe.Pointer(&w))
+	case 3:
+		*(*[3]byte)(p) = *(*[3]byte)(unsafe.Pointer(&w))
+	case 4:
+		*(*uint32)(p) = *(*uint32)(unsafe.Pointer(&w))
+	case 5:
+		*(*[5]byte)(p) = *(*[5]byte)(unsafe.Pointer(&w))
+	case 6:
+		*(*[6]byte)(p) = *(*[6]byte)(unsafe.Pointer(&w))
+	case 7:
+		*(*[7]byte)(p) = *(*[7]byte)(unsafe.Pointer(&w))
+	case 8:
+		*(*uint64)(p) = *(*uint64)(unsafe.Pointer(&w))
+	}
+}
+
+// emptyInterface is the header for an interface{} value.
+type emptyInterface struct {
+	typ  *runtime.Type
+	word iword
+}
+
+// nonEmptyInterface is the header for a interface value with methods.
+type nonEmptyInterface struct {
+	// see ../runtime/iface.c:/Itab
+	itab *struct {
+		ityp   *runtime.Type // static interface type
+		typ    *runtime.Type // dynamic concrete type
+		link   unsafe.Pointer
+		bad    int32
+		unused int32
+		fun    [100000]unsafe.Pointer // method table
+	}
+	word iword
+}
+
+// Regarding the implementation of Value:
+//
+// The Internal interface is a true interface value in the Go sense,
+// but it also serves as a (type, address) pair in whcih one cannot
+// be changed separately from the other.  That is, it serves as a way
+// to prevent unsafe mutations of the Internal state even though
+// we cannot (yet?) hide the field while preserving the ability for
+// clients to make copies of Values.
+//
+// The internal method converts a Value into the expanded internalValue struct.
+// If we could avoid exporting fields we'd probably make internalValue the
+// definition of Value.
+//
+// If a Value is addressable (CanAddr returns true), then the Internal
+// interface value holds a pointer to the actual field data, and Set stores
+// through that pointer.  If a Value is not addressable (CanAddr returns false),
+// then the Internal interface value holds the actual value.
+//
+// In addition to whether a value is addressable, we track whether it was
+// obtained by using an unexported struct field.  Such values are allowed
+// to be read, mainly to make fmt.Print more useful, but they are not
+// allowed to be written.  We call such values read-only.
+//
+// A Value can be set (via the Set, SetUint, etc. methods) only if it is both
+// addressable and not read-only.
+//
+// The two permission bits - addressable and read-only - are stored in
+// the bottom two bits of the type pointer in the interface value.
+//
+//	ordinary value: Internal = value
+//	addressable value: Internal = value, Internal.typ |= flagAddr
+//	read-only value: Internal = value, Internal.typ |= flagRO
+//	addressable, read-only value: Internal = value, Internal.typ |= flagAddr | flagRO
+//
+// It is important that the read-only values have the extra bit set
+// (as opposed to using the bit to mean writable), because client code
+// can grab the interface field and try to use it.  Having the extra bit
+// set makes the type pointer compare not equal to any real type,
+// so that a client cannot, say, write through v.Internal.(*int).
+// The runtime routines that access interface types reject types with
+// low bits set.
+//
+// If a Value fv = v.Method(i), then fv = v with the InternalMethod
+// field set to i+1.  Methods are never addressable.
+//
+// All in all, this is a lot of effort just to avoid making this new API
+// depend on a language change we'll probably do anyway, but
+// it's helpful to keep the two separate, and much of the logic is
+// necessary to implement the Interface method anyway.
+
+const (
+	flagAddr uint32 = 1 << iota // holds address of value
+	flagRO                      // read-only
+
+	reflectFlags = 3
+)
+
+// An internalValue is the unpacked form of a Value.
+// The zero Value unpacks to a zero internalValue
+type internalValue struct {
+	typ       *commonType // type of value
+	kind      Kind        // kind of value
+	flag      uint32
+	word      iword
+	addr      unsafe.Pointer
+	rcvr      iword
+	method    bool
+	nilmethod bool
+}
+
+func (v Value) internal() internalValue {
+	var iv internalValue
+	eface := *(*emptyInterface)(unsafe.Pointer(&v.Internal))
+	p := uintptr(unsafe.Pointer(eface.typ))
+	iv.typ = toCommonType((*runtime.Type)(unsafe.Pointer(p &^ reflectFlags)))
+	if iv.typ == nil {
+		return iv
+	}
+	iv.flag = uint32(p & reflectFlags)
+	iv.word = eface.word
+	if iv.flag&flagAddr != 0 {
+		iv.addr = unsafe.Pointer(iv.word)
+		iv.typ = iv.typ.toType().Elem().common()
+		if iv.typ.size <= ptrSize {
+			iv.word = loadIword(iv.addr, iv.typ.size)
+		}
+	} else {
+		if iv.typ.size > ptrSize {
+			iv.addr = unsafe.Pointer(iv.word)
+		}
+	}
+	iv.kind = iv.typ.Kind()
+
+	// Is this a method?  If so, iv describes the receiver.
+	// Rewrite to describe the method function.
+	if v.InternalMethod != 0 {
+		// If this Value is a method value (x.Method(i) for some Value x)
+		// then we will invoke it using the interface form of the method,
+		// which always passes the receiver as a single word.
+		// Record that information.
+		i := v.InternalMethod - 1
+		if iv.kind == Interface {
+			it := (*interfaceType)(unsafe.Pointer(iv.typ))
+			if i < 0 || i >= len(it.methods) {
+				panic("reflect: broken Value")
+			}
+			m := &it.methods[i]
+			if m.pkgPath != nil {
+				iv.flag |= flagRO
+			}
+			iv.typ = toCommonType(m.typ)
+			iface := (*nonEmptyInterface)(iv.addr)
+			if iface.itab == nil {
+				iv.word = 0
+				iv.nilmethod = true
+			} else {
+				iv.word = iword(iface.itab.fun[i])
+			}
+			iv.rcvr = iface.word
+		} else {
+			ut := iv.typ.uncommon()
+			if ut == nil || i < 0 || i >= len(ut.methods) {
+				panic("reflect: broken Value")
+			}
+			m := &ut.methods[i]
+			if m.pkgPath != nil {
+				iv.flag |= flagRO
+			}
+			iv.typ = toCommonType(m.mtyp)
+			iv.rcvr = iv.word
+			iv.word = iword(m.ifn)
+		}
+		iv.kind = Func
+		iv.method = true
+		iv.flag &^= flagAddr
+		iv.addr = nil
+	}
+
+	return iv
+}
+
+// packValue returns a Value with the given flag bits, type, and interface word.
+func packValue(flag uint32, typ *runtime.Type, word iword) Value {
+	if typ == nil {
+		panic("packValue")
 	}
-	return vi
+	t := uintptr(unsafe.Pointer(typ))
+	t |= uintptr(flag)
+	eface := emptyInterface{(*runtime.Type)(unsafe.Pointer(t)), word}
+	return Value{Internal: *(*interface{})(unsafe.Pointer(&eface))}
 }
 
-func (v Value) panicIfNot(want Kind) valueInterface {
-	vi := v.Internal
-	if vi == nil {
-		panic(&ValueError{methodName(), 0})
+// valueFromAddr returns a Value using the given type and address.
+func valueFromAddr(flag uint32, typ Type, addr unsafe.Pointer) Value {
+	if flag&flagAddr != 0 {
+		// Addressable, so the internal value is
+		// an interface containing a pointer to the real value.
+		return packValue(flag, PtrTo(typ).runtimeType(), iword(addr))
 	}
-	if k := vi.Kind(); k != want {
-		panic(&ValueError{methodName(), k})
+
+	var w iword
+	if n := typ.Size(); n <= ptrSize {
+		// In line, so the interface word is the actual value.
+		w = loadIword(addr, n)
+	} else {
+		// Not in line: the interface word is the address.
+		w = iword(addr)
 	}
-	return vi
+	return packValue(flag, typ.runtimeType(), w)
 }
 
-func (v Value) panicIfNots(wants []Kind) valueInterface {
-	vi := v.Internal
-	if vi == nil {
-		panic(&ValueError{methodName(), 0})
+// valueFromIword returns a Value using the given type and interface word.
+func valueFromIword(flag uint32, typ Type, w iword) Value {
+	if flag&flagAddr != 0 {
+		panic("reflect: internal error: valueFromIword addressable")
 	}
-	k := vi.Kind()
-	for _, want := range wants {
-		if k == want {
-			return vi
-		}
+	return packValue(flag, typ.runtimeType(), w)
+}
+
+func (iv internalValue) mustBe(want Kind) {
+	if iv.kind != want {
+		panic(&ValueError{methodName(), iv.kind})
+	}
+}
+
+func (iv internalValue) mustBeExported() {
+	if iv.flag&flagRO != 0 {
+		panic(methodName() + " of value obtained using unexported field")
+	}
+}
+
+func (iv internalValue) mustBeAssignable() {
+	// Assignable if addressable and not read-only.
+	if iv.flag&flagRO != 0 {
+		panic(methodName() + " of value obtained using unexported field")
+	}
+	if iv.flag&flagAddr == 0 {
+		panic(methodName() + " of unaddressable value")
 	}
-	panic(&ValueError{methodName(), k})
 }
 
 // Addr returns a pointer value representing the address of v.
@@ -128,14 +377,19 @@ func (v Value) panicIfNots(wants []Kind) valueInterface {
 // or slice element in order to call a method that requires a
 // pointer receiver.
 func (v Value) Addr() Value {
-	return v.internal().Addr()
+	iv := v.internal()
+	if iv.flag&flagAddr == 0 {
+		panic("reflect.Value.Addr of unaddressable value")
+	}
+	return valueFromIword(iv.flag&flagRO, PtrTo(iv.typ.toType()), iword(iv.addr))
 }
 
 // Bool returns v's underlying value.
 // It panics if v's kind is not Bool.
 func (v Value) Bool() bool {
-	u := v.panicIfNot(Bool).(*boolValue)
-	return *(*bool)(u.addr)
+	iv := v.internal()
+	iv.mustBe(Bool)
+	return *(*bool)(unsafe.Pointer(&iv.word))
 }
 
 // CanAddr returns true if the value's address can be obtained with Addr.
@@ -145,7 +399,8 @@ func (v Value) Bool() bool {
 // or the result of a call to NewValue, MakeChan, MakeMap, or Zero.
 // If CanAddr returns false, calling Addr will panic.
 func (v Value) CanAddr() bool {
-	return v.internal().CanAddr()
+	iv := v.internal()
+	return iv.flag&flagAddr != 0
 }
 
 // CanSet returns true if the value of v can be changed.
@@ -154,30 +409,38 @@ func (v Value) CanAddr() bool {
 // If CanSet returns false, calling Set or any type-specific
 // setter (e.g., SetBool, SetInt64) will panic.
 func (v Value) CanSet() bool {
-	return v.internal().CanSet()
+	iv := v.internal()
+	return iv.flag&(flagAddr|flagRO) == flagAddr
 }
 
 // Call calls the function v with the input parameters in.
 // It panics if v's Kind is not Func.
 // It returns the output parameters as Values.
 func (v Value) Call(in []Value) []Value {
-	fv := v.panicIfNot(Func).(*funcValue)
-	t := fv.Type()
-	nin := len(in)
-	if fv.first != nil && !fv.isInterface {
-		nin++
+	iv := v.internal()
+	iv.mustBe(Func)
+	iv.mustBeExported()
+
+	if iv.word == 0 {
+		if iv.nilmethod {
+			panic("reflect.Value.Call: call of method on nil interface value")
+		}
+		panic("reflect.Value.Call: call of nil function")
 	}
+
+	t := iv.typ.toType()
+	nin := len(in)
 	if nin != t.NumIn() {
-		panic("funcValue: wrong argument count")
+		panic("reflect.Value.Call: wrong argument count")
 	}
 	nout := t.NumOut()
 
 	// Compute arg size & allocate.
-	// This computation is 6g/8g-dependent
+	// This computation is 5g/6g/8g-dependent
 	// and probably wrong for gccgo, but so
 	// is most of this function.
 	size := uintptr(0)
-	if fv.isInterface {
+	if iv.method {
 		// extra word for interface value
 		size += ptrSize
 	}
@@ -215,36 +478,28 @@ func (v Value) Call(in []Value) []Value {
 	args := make([]*int, size/ptrSize)
 	ptr := uintptr(unsafe.Pointer(&args[0]))
 	off := uintptr(0)
-	delta := 0
-	if v := fv.first; v != nil {
+	if iv.method {
 		// Hard-wired first argument.
-		if fv.isInterface {
-			// v is a single uninterpreted word
-			memmove(addr(ptr), v.getAddr(), ptrSize)
-			off = ptrSize
-		} else {
-			// v is a real value
-			tv := v.Type()
-			typesMustMatch(t.In(0), tv)
-			n := tv.Size()
-			memmove(addr(ptr), v.getAddr(), n)
-			off = n
-			delta = 1
-		}
+		*(*iword)(unsafe.Pointer(ptr)) = iv.rcvr
+		off = ptrSize
 	}
 	for i, v := range in {
-		tv := v.Type()
-		typesMustMatch(t.In(i+delta), tv)
-		a := uintptr(tv.Align())
+		iv := v.internal()
+		typesMustMatch("reflect.Value.Call", t.In(i), iv.typ.toType())
+		a := uintptr(iv.typ.align)
 		off = (off + a - 1) &^ (a - 1)
-		n := tv.Size()
-		memmove(addr(ptr+off), v.internal().getAddr(), n)
+		n := iv.typ.size
+		if iv.addr == nil {
+			storeIword(unsafe.Pointer(ptr+off), iv.word, n)
+		} else {
+			memmove(unsafe.Pointer(ptr+off), iv.addr, n)
+		}
 		off += n
 	}
 	off = (off + ptrSize - 1) &^ (ptrSize - 1)
 
-	// Call
-	call(*(**byte)(fv.addr), (*byte)(addr(ptr)), uint32(size))
+	// Call.
+	call(unsafe.Pointer(iv.word), unsafe.Pointer(ptr), uint32(size))
 
 	// Copy return values out of args.
 	//
@@ -254,111 +509,144 @@ func (v Value) Call(in []Value) []Value {
 		tv := t.Out(i)
 		a := uintptr(tv.Align())
 		off = (off + a - 1) &^ (a - 1)
-		v := Zero(tv)
-		n := tv.Size()
-		memmove(v.internal().getAddr(), addr(ptr+off), n)
-		ret[i] = v
-		off += n
+		ret[i] = valueFromAddr(0, tv, unsafe.Pointer(ptr+off))
+		off += tv.Size()
 	}
 
 	return ret
 }
 
-var capKinds = []Kind{Array, Chan, Slice}
-
 // Cap returns v's capacity.
 // It panics if v's Kind is not Array, Chan, or Slice.
 func (v Value) Cap() int {
-	switch vv := v.panicIfNots(capKinds).(type) {
-	case *arrayValue:
-		return vv.typ.Len()
-	case *chanValue:
-		ch := *(**byte)(vv.addr)
-		return int(chancap(ch))
-	case *sliceValue:
-		return int(vv.slice().Cap)
+	iv := v.internal()
+	switch iv.kind {
+	case Array:
+		return iv.typ.toType().Len()
+	case Chan:
+		return int(chancap(iv.word))
+	case Slice:
+		return (*SliceHeader)(iv.addr).Cap
 	}
-	panic("not reached")
+	panic(&ValueError{"reflect.Value.Cap", iv.kind})
 }
 
 // Close closes the channel v.
 // It panics if v's Kind is not Chan.
 func (v Value) Close() {
-	vv := v.panicIfNot(Chan).(*chanValue)
-
-	ch := *(**byte)(vv.addr)
+	iv := v.internal()
+	iv.mustBe(Chan)
+	iv.mustBeExported()
+	ch := iv.word
 	chanclose(ch)
 }
 
-var complexKinds = []Kind{Complex64, Complex128}
-
 // Complex returns v's underlying value, as a complex128.
 // It panics if v's Kind is not Complex64 or Complex128
 func (v Value) Complex() complex128 {
-	vv := v.panicIfNots(complexKinds).(*complexValue)
-
-	switch vv.typ.Kind() {
+	iv := v.internal()
+	switch iv.kind {
 	case Complex64:
-		return complex128(*(*complex64)(vv.addr))
+		if iv.addr == nil {
+			return complex128(*(*complex64)(unsafe.Pointer(&iv.word)))
+		}
+		return complex128(*(*complex64)(iv.addr))
 	case Complex128:
-		return *(*complex128)(vv.addr)
+		return *(*complex128)(iv.addr)
 	}
-	panic("reflect: invalid complex kind")
+	panic(&ValueError{"reflect.Value.Complex", iv.kind})
 }
 
-var interfaceOrPtr = []Kind{Interface, Ptr}
-
 // Elem returns the value that the interface v contains
 // or that the pointer v points to.
 // It panics if v's Kind is not Interface or Ptr.
 // It returns the zero Value if v is nil.
 func (v Value) Elem() Value {
-	switch vv := v.panicIfNots(interfaceOrPtr).(type) {
-	case *interfaceValue:
-		return NewValue(vv.Interface())
-	case *ptrValue:
-		if v.IsNil() {
+	iv := v.internal()
+	switch iv.kind {
+	case Interface:
+		// Empty interface and non-empty interface have different layouts.
+		// Convert to empty interface.
+		var eface emptyInterface
+		if iv.typ.toType().NumMethod() == 0 {
+			eface = *(*emptyInterface)(iv.addr)
+		} else {
+			iface := (*nonEmptyInterface)(iv.addr)
+			if iface.itab != nil {
+				eface.typ = iface.itab.typ
+			}
+			eface.word = iface.word
+		}
+		if eface.typ == nil {
 			return Value{}
 		}
-		flag := canAddr
-		if vv.flag&canStore != 0 {
-			flag |= canSet | canStore
+		return valueFromIword(iv.flag&flagRO, toType(eface.typ), eface.word)
+
+	case Ptr:
+		// The returned value's address is v's value.
+		if iv.word == 0 {
+			return Value{}
 		}
-		return newValue(vv.typ.Elem(), *(*addr)(vv.addr), flag)
+		return valueFromAddr(iv.flag&flagRO|flagAddr, iv.typ.toType().Elem(), unsafe.Pointer(iv.word))
 	}
-	panic("not reached")
+	panic(&ValueError{"reflect.Value.Elem", iv.kind})
 }
 
 // Field returns the i'th field of the struct v.
-// It panics if v's Kind is not Struct.
+// It panics if v's Kind is not Struct or i is out of range.
 func (v Value) Field(i int) Value {
-	vv := v.panicIfNot(Struct).(*structValue)
-
-	t := vv.typ
+	iv := v.internal()
+	iv.mustBe(Struct)
+	t := iv.typ.toType()
 	if i < 0 || i >= t.NumField() {
 		panic("reflect: Field index out of range")
 	}
 	f := t.Field(i)
-	flag := vv.flag
+
+	// Inherit permission bits from v.
+	flag := iv.flag
+	// Using an unexported field forces flagRO.
 	if f.PkgPath != "" {
-		// unexported field
-		flag &^= canSet | canStore
+		flag |= flagRO
 	}
-	return newValue(f.Type, addr(uintptr(vv.addr)+f.Offset), flag)
+	return valueFromValueOffset(flag, f.Type, iv, f.Offset)
+}
+
+// valueFromValueOffset returns a sub-value of outer
+// (outer is an array or a struct) with the given flag and type
+// starting at the given byte offset into outer.
+func valueFromValueOffset(flag uint32, typ Type, outer internalValue, offset uintptr) Value {
+	if outer.addr != nil {
+		return valueFromAddr(flag, typ, unsafe.Pointer(uintptr(outer.addr)+offset))
+	}
+
+	// outer is so tiny it is in line.
+	// We have to use outer.word and derive
+	// the new word (it cannot possibly be bigger).
+	// In line, so not addressable.
+	if flag&flagAddr != 0 {
+		panic("reflect: internal error: misuse of valueFromValueOffset")
+	}
+	b := *(*[ptrSize]byte)(unsafe.Pointer(&outer.word))
+	for i := uintptr(0); i < typ.Size(); i++ {
+		b[i] = b[offset+i]
+	}
+	for i := typ.Size(); i < ptrSize; i++ {
+		b[i] = 0
+	}
+	w := *(*iword)(unsafe.Pointer(&b))
+	return valueFromIword(flag, typ, w)
 }
 
 // FieldByIndex returns the nested field corresponding to index.
 // It panics if v's Kind is not struct.
 func (v Value) FieldByIndex(index []int) Value {
-	v.panicIfNot(Struct)
+	v.internal().mustBe(Struct)
 	for i, x := range index {
 		if i > 0 {
-			if v.Kind() == Ptr {
+			if v.Kind() == Ptr && v.Elem().Kind() == Struct {
 				v = v.Elem()
 			}
-			if v.Kind() != Struct {
-				return Value{}
-			}
 		}
 		v = v.Field(x)
 	}
@@ -369,7 +657,9 @@ func (v Value) FieldByIndex(index []int) Value {
 // It returns the zero Value if no field was found.
 // It panics if v's Kind is not struct.
 func (v Value) FieldByName(name string) Value {
-	if f, ok := v.Type().FieldByName(name); ok {
+	iv := v.internal()
+	iv.mustBe(Struct)
+	if f, ok := iv.typ.toType().FieldByName(name); ok {
 		return v.FieldByIndex(f.Index)
 	}
 	return Value{}
@@ -380,79 +670,100 @@ func (v Value) FieldByName(name string) Value {
 // It panics if v's Kind is not struct.
 // It returns the zero Value if no field was found.
 func (v Value) FieldByNameFunc(match func(string) bool) Value {
+	v.internal().mustBe(Struct)
 	if f, ok := v.Type().FieldByNameFunc(match); ok {
 		return v.FieldByIndex(f.Index)
 	}
 	return Value{}
 }
 
-var floatKinds = []Kind{Float32, Float64}
-
 // Float returns v's underlying value, as an float64.
 // It panics if v's Kind is not Float32 or Float64
 func (v Value) Float() float64 {
-	vv := v.panicIfNots(floatKinds).(*floatValue)
-
-	switch vv.typ.Kind() {
+	iv := v.internal()
+	switch iv.kind {
 	case Float32:
-		return float64(*(*float32)(vv.addr))
+		return float64(*(*float32)(unsafe.Pointer(&iv.word)))
 	case Float64:
-		return *(*float64)(vv.addr)
+		// If the pointer width can fit an entire float64,
+		// the value is in line when stored in an interface.
+		if iv.addr == nil {
+			return *(*float64)(unsafe.Pointer(&iv.word))
+		}
+		// Otherwise we have a pointer.
+		return *(*float64)(iv.addr)
 	}
-	panic("reflect: invalid float kind")
-
+	panic(&ValueError{"reflect.Value.Float", iv.kind})
 }
 
-var arrayOrSlice = []Kind{Array, Slice}
-
 // Index returns v's i'th element.
-// It panics if v's Kind is not Array or Slice.
+// It panics if v's Kind is not Array or Slice or i is out of range.
 func (v Value) Index(i int) Value {
-	switch vv := v.panicIfNots(arrayOrSlice).(type) {
-	case *arrayValue:
-		typ := vv.typ.Elem()
-		n := v.Len()
-		if i < 0 || i >= n {
-			panic("array index out of bounds")
+	iv := v.internal()
+	switch iv.kind {
+	default:
+		panic(&ValueError{"reflect.Value.Index", iv.kind})
+	case Array:
+		flag := iv.flag // element flag same as overall array
+		t := iv.typ.toType()
+		if i < 0 || i > t.Len() {
+			panic("reflect: array index out of range")
 		}
-		p := addr(uintptr(vv.addr()) + uintptr(i)*typ.Size())
-		return newValue(typ, p, vv.flag)
-	case *sliceValue:
-		typ := vv.typ.Elem()
-		n := v.Len()
-		if i < 0 || i >= n {
+		typ := t.Elem()
+		return valueFromValueOffset(flag, typ, iv, uintptr(i)*typ.Size())
+
+	case Slice:
+		// Element flag same as Elem of Ptr.
+		// Addressable, possibly read-only.
+		flag := iv.flag&flagRO | flagAddr
+		s := (*SliceHeader)(iv.addr)
+		if i < 0 || i >= s.Len {
 			panic("reflect: slice index out of range")
 		}
-		p := addr(uintptr(vv.addr()) + uintptr(i)*typ.Size())
-		flag := canAddr
-		if vv.flag&canStore != 0 {
-			flag |= canSet | canStore
-		}
-		return newValue(typ, p, flag)
+		typ := iv.typ.toType().Elem()
+		addr := unsafe.Pointer(s.Data + uintptr(i)*typ.Size())
+		return valueFromAddr(flag, typ, addr)
 	}
+
 	panic("not reached")
 }
 
-var intKinds = []Kind{Int, Int8, Int16, Int32, Int64}
-
 // Int returns v's underlying value, as an int64.
-// It panics if v's Kind is not a sized or unsized Int kind.
+// It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.
 func (v Value) Int() int64 {
-	vv := v.panicIfNots(intKinds).(*intValue)
-
-	switch vv.typ.Kind() {
+	iv := v.internal()
+	switch iv.kind {
 	case Int:
-		return int64(*(*int)(vv.addr))
+		return int64(*(*int)(unsafe.Pointer(&iv.word)))
 	case Int8:
-		return int64(*(*int8)(vv.addr))
+		return int64(*(*int8)(unsafe.Pointer(&iv.word)))
 	case Int16:
-		return int64(*(*int16)(vv.addr))
+		return int64(*(*int16)(unsafe.Pointer(&iv.word)))
 	case Int32:
-		return int64(*(*int32)(vv.addr))
+		return int64(*(*int32)(unsafe.Pointer(&iv.word)))
 	case Int64:
-		return *(*int64)(vv.addr)
+		if iv.addr == nil {
+			return *(*int64)(unsafe.Pointer(&iv.word))
+		}
+		return *(*int64)(iv.addr)
+	}
+	panic(&ValueError{"reflect.Value.Int", iv.kind})
+}
+
+// CanInterface returns true if Interface can be used without panicking.
+func (v Value) CanInterface() bool {
+	iv := v.internal()
+	if iv.kind == Invalid {
+		panic(&ValueError{"reflect.Value.CanInterface", iv.kind})
 	}
-	panic("reflect: invalid int kind")
+	// TODO(rsc): Check flagRO too.  Decide what to do about asking for
+	// interface for a value obtained via an unexported field.
+	// If the field were of a known type, say chan int or *sync.Mutex,
+	// the caller could interfere with the data after getting the
+	// interface.  But fmt.Print depends on being able to look.
+	// Now that reflect is more efficient the special cases in fmt
+	// might be less important.
+	return v.InternalMethod == 0
 }
 
 // Interface returns v's value as an interface{}.
@@ -460,37 +771,59 @@ func (v Value) Int() int64 {
 // (as opposed to Type.Method), Interface cannot return an
 // interface value, so it panics.
 func (v Value) Interface() interface{} {
-	return v.internal().Interface()
+	if v.InternalMethod != 0 {
+		panic("reflect.Value.Interface: cannot create interface value for method with bound receiver")
+	}
+	/*
+		if v.flag()&noExport != 0 {
+			panic("reflect.Value.Interface: cannot return value obtained from unexported struct field")
+		}
+	*/
+
+	iv := v.internal()
+	if iv.kind == Interface {
+		// Special case: return the element inside the interface.
+		// Won't recurse further because an interface cannot contain an interface.
+		if v.IsNil() {
+			return nil
+		}
+		return v.Elem().Interface()
+	}
+
+	// Non-interface value.
+	var eface emptyInterface
+	eface.typ = iv.typ.runtimeType()
+	eface.word = iv.word
+	return *(*interface{})(unsafe.Pointer(&eface))
 }
 
 // InterfaceData returns the interface v's value as a uintptr pair.
 // It panics if v's Kind is not Interface.
 func (v Value) InterfaceData() [2]uintptr {
-	vv := v.panicIfNot(Interface).(*interfaceValue)
-
-	return *(*[2]uintptr)(vv.addr)
+	iv := v.internal()
+	iv.mustBe(Interface)
+	// We treat this as a read operation, so we allow
+	// it even for unexported data, because the caller
+	// has to import "unsafe" to turn it into something
+	// that can be abused.
+	return *(*[2]uintptr)(iv.addr)
 }
 
-var nilKinds = []Kind{Chan, Func, Interface, Map, Ptr, Slice}
-
 // IsNil returns true if v is a nil value.
 // It panics if v's Kind is not Chan, Func, Interface, Map, Ptr, or Slice.
 func (v Value) IsNil() bool {
-	switch vv := v.panicIfNots(nilKinds).(type) {
-	case *chanValue:
-		return *(*uintptr)(vv.addr) == 0
-	case *funcValue:
-		return *(*uintptr)(vv.addr) == 0
-	case *interfaceValue:
-		return vv.Interface() == nil
-	case *mapValue:
-		return *(*uintptr)(vv.addr) == 0
-	case *ptrValue:
-		return *(*uintptr)(vv.addr) == 0
-	case *sliceValue:
-		return vv.slice().Data == 0
+	iv := v.internal()
+	switch iv.kind {
+	case Chan, Func, Map, Ptr:
+		if iv.kind == Func && v.InternalMethod != 0 {
+			panic("reflect: IsNil of method Value")
+		}
+		return iv.word == 0
+	case Interface, Slice:
+		// Both interface and slice are nil if first word is 0.
+		return *(*uintptr)(iv.addr) == 0
 	}
-	panic("not reached")
+	panic(&ValueError{"reflect.Value.IsNil", iv.kind})
 }
 
 // IsValid returns true if v represents a value.
@@ -505,169 +838,177 @@ func (v Value) IsValid() bool {
 // Kind returns v's Kind.
 // If v is the zero Value (IsValid returns false), Kind returns Invalid.
 func (v Value) Kind() Kind {
-	if v.Internal == nil {
-		return Invalid
-	}
-	return v.internal().Kind()
+	return v.internal().kind
 }
 
-var lenKinds = []Kind{Array, Chan, Map, Slice}
-
 // Len returns v's length.
 // It panics if v's Kind is not Array, Chan, Map, or Slice.
 func (v Value) Len() int {
-	switch vv := v.panicIfNots(lenKinds).(type) {
-	case *arrayValue:
-		return vv.typ.Len()
-	case *chanValue:
-		ch := *(**byte)(vv.addr)
-		return int(chanlen(ch))
-	case *mapValue:
-		m := *(**byte)(vv.addr)
-		if m == nil {
-			return 0
-		}
-		return int(maplen(m))
-	case *sliceValue:
-		return int(vv.slice().Len)
+	iv := v.internal()
+	switch iv.kind {
+	case Array:
+		return iv.typ.toType().Len()
+	case Chan:
+		return int(chanlen(iv.word))
+	case Map:
+		return int(maplen(iv.word))
+	case Slice:
+		return (*SliceHeader)(iv.addr).Len
 	}
-	panic("not reached")
+	panic(&ValueError{"reflect.Value.Len", iv.kind})
 }
 
 // MapIndex returns the value associated with key in the map v.
 // It panics if v's Kind is not Map.
-// It returns the zero Value if key is not found in the map.
+// It returns the zero Value if key is not found in the map or if v represents a nil map.
 func (v Value) MapIndex(key Value) Value {
-	vv := v.panicIfNot(Map).(*mapValue)
-	t := vv.Type()
-	typesMustMatch(t.Key(), key.Type())
-	m := *(**byte)(vv.addr)
-	if m == nil {
+	iv := v.internal()
+	iv.mustBe(Map)
+	typ := iv.typ.toType()
+	ikey := key.internal()
+	ikey.mustBeExported()
+	typesMustMatch("reflect.Value.MapIndex", typ.Key(), ikey.typ.toType())
+	if iv.word == 0 {
 		return Value{}
 	}
-	newval := Zero(t.Elem())
-	if !mapaccess(m, (*byte)(key.internal().getAddr()), (*byte)(newval.internal().getAddr())) {
+
+	flag := iv.flag & flagRO
+	elemType := typ.Elem()
+	elemWord, ok := mapaccess(iv.word, ikey.word)
+	if !ok {
 		return Value{}
 	}
-	return newval
+	return valueFromIword(flag, elemType, elemWord)
 }
 
 // MapKeys returns a slice containing all the keys present in the map,
 // in unspecified order.
 // It panics if v's Kind is not Map.
+// It returns an empty slice if v represents a nil map.
 func (v Value) MapKeys() []Value {
-	vv := v.panicIfNot(Map).(*mapValue)
-	tk := vv.Type().Key()
-	m := *(**byte)(vv.addr)
+	iv := v.internal()
+	iv.mustBe(Map)
+	keyType := iv.typ.toType().Key()
+
+	flag := iv.flag & flagRO
+	m := iv.word
 	mlen := int32(0)
-	if m != nil {
+	if m != 0 {
 		mlen = maplen(m)
 	}
 	it := mapiterinit(m)
 	a := make([]Value, mlen)
 	var i int
 	for i = 0; i < len(a); i++ {
-		k := Zero(tk)
-		if !mapiterkey(it, (*byte)(k.internal().getAddr())) {
+		keyWord, ok := mapiterkey(it)
+		if !ok {
 			break
 		}
-		a[i] = k
+		a[i] = valueFromIword(flag, keyType, keyWord)
 		mapiternext(it)
 	}
-	return a[0:i]
+	return a[:i]
 }
 
 // Method returns a function value corresponding to v's i'th method.
 // The arguments to a Call on the returned function should not include
 // a receiver; the returned function will always use v as the receiver.
+// Method panics if i is out of range.
 func (v Value) Method(i int) Value {
-	return v.internal().Method(i)
+	iv := v.internal()
+	if iv.kind == Invalid {
+		panic(&ValueError{"reflect.Value.Method", Invalid})
+	}
+	if i < 0 || i >= iv.typ.toType().NumMethod() {
+		panic("reflect: Method index out of range")
+	}
+	return Value{v.Internal, i + 1}
 }
 
 // NumField returns the number of fields in the struct v.
 // It panics if v's Kind is not Struct.
 func (v Value) NumField() int {
-	return v.panicIfNot(Struct).(*structValue).typ.NumField()
+	iv := v.internal()
+	iv.mustBe(Struct)
+	return iv.typ.toType().NumField()
 }
 
 // OverflowComplex returns true if the complex128 x cannot be represented by v's type.
 // It panics if v's Kind is not Complex64 or Complex128.
 func (v Value) OverflowComplex(x complex128) bool {
-	vv := v.panicIfNots(complexKinds).(*complexValue)
-
-	if vv.typ.Size() == 16 {
+	iv := v.internal()
+	switch iv.kind {
+	case Complex64:
+		return overflowFloat32(real(x)) || overflowFloat32(imag(x))
+	case Complex128:
 		return false
 	}
-	r := real(x)
-	i := imag(x)
-	if r < 0 {
-		r = -r
-	}
-	if i < 0 {
-		i = -i
-	}
-	return math.MaxFloat32 <= r && r <= math.MaxFloat64 ||
-		math.MaxFloat32 <= i && i <= math.MaxFloat64
+	panic(&ValueError{"reflect.Value.OverflowComplex", iv.kind})
 }
 
 // OverflowFloat returns true if the float64 x cannot be represented by v's type.
 // It panics if v's Kind is not Float32 or Float64.
 func (v Value) OverflowFloat(x float64) bool {
-	vv := v.panicIfNots(floatKinds).(*floatValue)
-
-	if vv.typ.Size() == 8 {
+	iv := v.internal()
+	switch iv.kind {
+	case Float32:
+		return overflowFloat32(x)
+	case Float64:
 		return false
 	}
+	panic(&ValueError{"reflect.Value.OverflowFloat", iv.kind})
+}
+
+func overflowFloat32(x float64) bool {
 	if x < 0 {
 		x = -x
 	}
-	return math.MaxFloat32 < x && x <= math.MaxFloat64
+	return math.MaxFloat32 <= x && x <= math.MaxFloat64
 }
 
 // OverflowInt returns true if the int64 x cannot be represented by v's type.
-// It panics if v's Kind is not a sized or unsized Int kind.
+// It panics if v's Kind is not Int, Int8, int16, Int32, or Int64.
 func (v Value) OverflowInt(x int64) bool {
-	vv := v.panicIfNots(intKinds).(*intValue)
-
-	bitSize := uint(vv.typ.Bits())
-	trunc := (x << (64 - bitSize)) >> (64 - bitSize)
-	return x != trunc
+	iv := v.internal()
+	switch iv.kind {
+	case Int, Int8, Int16, Int32, Int64:
+		bitSize := iv.typ.size * 8
+		trunc := (x << (64 - bitSize)) >> (64 - bitSize)
+		return x != trunc
+	}
+	panic(&ValueError{"reflect.Value.OverflowInt", iv.kind})
 }
 
 // OverflowUint returns true if the uint64 x cannot be represented by v's type.
-// It panics if v's Kind is not a sized or unsized Uint kind.
+// It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.
 func (v Value) OverflowUint(x uint64) bool {
-	vv := v.panicIfNots(uintKinds).(*uintValue)
-
-	bitSize := uint(vv.typ.Bits())
-	trunc := (x << (64 - bitSize)) >> (64 - bitSize)
-	return x != trunc
+	iv := v.internal()
+	switch iv.kind {
+	case Uint, Uintptr, Uint8, Uint16, Uint32, Uint64:
+		bitSize := iv.typ.size * 8
+		trunc := (x << (64 - bitSize)) >> (64 - bitSize)
+		return x != trunc
+	}
+	panic(&ValueError{"reflect.Value.OverflowUint", iv.kind})
 }
 
-var pointerKinds = []Kind{Chan, Func, Map, Ptr, Slice, UnsafePointer}
-
 // Pointer returns v's value as a uintptr.
 // It returns uintptr instead of unsafe.Pointer so that
 // code using reflect cannot obtain unsafe.Pointers
 // without importing the unsafe package explicitly.
 // It panics if v's Kind is not Chan, Func, Map, Ptr, Slice, or UnsafePointer.
 func (v Value) Pointer() uintptr {
-	switch vv := v.panicIfNots(pointerKinds).(type) {
-	case *chanValue:
-		return *(*uintptr)(vv.addr)
-	case *funcValue:
-		return *(*uintptr)(vv.addr)
-	case *mapValue:
-		return *(*uintptr)(vv.addr)
-	case *ptrValue:
-		return *(*uintptr)(vv.addr)
-	case *sliceValue:
-		typ := vv.typ
-		return uintptr(vv.addr()) + uintptr(v.Cap())*typ.Elem().Size()
-	case *unsafePointerValue:
-		return uintptr(*(*unsafe.Pointer)(vv.addr))
+	iv := v.internal()
+	switch iv.kind {
+	case Chan, Func, Map, Ptr, UnsafePointer:
+		if iv.kind == Func && v.InternalMethod != 0 {
+			panic("reflect.Value.Pointer of method Value")
+		}
+		return uintptr(iv.word)
+	case Slice:
+		return (*SliceHeader)(iv.addr).Data
 	}
-	panic("not reached")
+	panic(&ValueError{"reflect.Value.Pointer", iv.kind})
 }
 
 // Recv receives and returns a value from the channel v.
@@ -676,301 +1017,231 @@ func (v Value) Pointer() uintptr {
 // The boolean value ok is true if the value x corresponds to a send
 // on the channel, false if it is a zero value received because the channel is closed.
 func (v Value) Recv() (x Value, ok bool) {
-	return v.panicIfNot(Chan).(*chanValue).recv(nil)
+	iv := v.internal()
+	iv.mustBe(Chan)
+	iv.mustBeExported()
+	return iv.recv(false)
 }
 
-// internal recv; non-blocking if selected != nil
-func (v *chanValue) recv(selected *bool) (Value, bool) {
-	t := v.Type()
+// internal recv, possibly non-blocking (nb)
+func (iv internalValue) recv(nb bool) (val Value, ok bool) {
+	t := iv.typ.toType()
 	if t.ChanDir()&RecvDir == 0 {
 		panic("recv on send-only channel")
 	}
-	ch := *(**byte)(v.addr)
-	x := Zero(t.Elem())
-	var ok bool
-	chanrecv(ch, (*byte)(x.internal().getAddr()), selected, &ok)
-	return x, ok
+	ch := iv.word
+	if ch == 0 {
+		panic("recv on nil channel")
+	}
+	valWord, selected, ok := chanrecv(ch, nb)
+	if selected {
+		val = valueFromIword(0, t.Elem(), valWord)
+	}
+	return
 }
 
 // Send sends x on the channel v.
 // It panics if v's kind is not Chan or if x's type is not the same type as v's element type.
 func (v Value) Send(x Value) {
-	v.panicIfNot(Chan).(*chanValue).send(x, nil)
+	iv := v.internal()
+	iv.mustBe(Chan)
+	iv.mustBeExported()
+	iv.send(x, false)
 }
 
-// internal send; non-blocking if selected != nil
-func (v *chanValue) send(x Value, selected *bool) {
-	t := v.Type()
+// internal send, possibly non-blocking
+func (iv internalValue) send(x Value, nb bool) (selected bool) {
+	t := iv.typ.toType()
 	if t.ChanDir()&SendDir == 0 {
 		panic("send on recv-only channel")
 	}
-	typesMustMatch(t.Elem(), x.Type())
-	ch := *(**byte)(v.addr)
-	chansend(ch, (*byte)(x.internal().getAddr()), selected)
+	ix := x.internal()
+	ix.mustBeExported() // do not let unexported x leak
+	typesMustMatch("reflect.Value.Send", t.Elem(), ix.typ.toType())
+	ch := iv.word
+	if ch == 0 {
+		panic("send on nil channel")
+	}
+	return chansend(ch, ix.word, nb)
 }
 
 // Set assigns x to the value v; x must have the same type as v.
 // It panics if CanSet() returns false or if x is the zero Value.
 func (v Value) Set(x Value) {
-	x.internal()
-	switch vv := v.internal().(type) {
-	case *arrayValue:
-		xx := x.panicIfNot(Array).(*arrayValue)
-		if !vv.CanSet() {
-			panic(cannotSet)
-		}
-		typesMustMatch(vv.typ, xx.typ)
-		Copy(v, x)
-
-	case *boolValue:
-		v.SetBool(x.Bool())
-
-	case *chanValue:
-		x := x.panicIfNot(Chan).(*chanValue)
-		if !vv.CanSet() {
-			panic(cannotSet)
-		}
-		typesMustMatch(vv.typ, x.typ)
-		*(*uintptr)(vv.addr) = *(*uintptr)(x.addr)
-
-	case *floatValue:
-		v.SetFloat(x.Float())
-
-	case *funcValue:
-		x := x.panicIfNot(Func).(*funcValue)
-		if !vv.CanSet() {
-			panic(cannotSet)
+	iv := v.internal()
+	ix := x.internal()
+
+	iv.mustBeAssignable()
+	ix.mustBeExported() // do not let unexported x leak
+
+	if iv.kind == Interface {
+		// Special case: since v is an interface, the types don't have to match.
+		// x can be any type that implements the interface.
+
+		// In fact, x might itself be an interface.
+		if ix.kind == Interface {
+			if x.IsNil() {
+				// Go would only allow this in an implicit conversion
+				// from one interface type to another that was a subset.
+				// TODO(rsc): Figure out whether reflect should be more picky.
+				*(*interface{})(iv.addr) = nil
+				return
+			}
 		}
-		typesMustMatch(vv.typ, x.typ)
-		*(*uintptr)(vv.addr) = *(*uintptr)(x.addr)
-
-	case *intValue:
-		v.SetInt(x.Int())
 
-	case *interfaceValue:
-		i := x.Interface()
-		if !vv.CanSet() {
-			panic(cannotSet)
-		}
-		// Two different representations; see comment in Get.
 		// Empty interface is easy.
-		t := (*interfaceType)(unsafe.Pointer(vv.typ.(*commonType)))
-		if t.NumMethod() == 0 {
-			*(*interface{})(vv.addr) = i
-			return
-		}
-
-		// Non-empty interface requires a runtime check.
-		setiface(t, &i, vv.addr)
-
-	case *mapValue:
-		x := x.panicIfNot(Map).(*mapValue)
-		if !vv.CanSet() {
-			panic(cannotSet)
-		}
-		if x == nil {
-			*(**uintptr)(vv.addr) = nil
+		if iv.typ.toType().NumMethod() == 0 {
+			*(*interface{})(iv.addr) = x.Interface()
 			return
 		}
-		typesMustMatch(vv.typ, x.typ)
-		*(*uintptr)(vv.addr) = *(*uintptr)(x.addr)
 
-	case *ptrValue:
-		x := x.panicIfNot(Ptr).(*ptrValue)
-		if x == nil {
-			*(**uintptr)(vv.addr) = nil
-			return
-		}
-		if !vv.CanSet() {
-			panic(cannotSet)
-		}
-		if x.flag&canStore == 0 {
-			panic("cannot copy pointer obtained from unexported struct field")
-		}
-		typesMustMatch(vv.typ, x.typ)
-		// TODO: This will have to move into the runtime
-		// once the new gc goes in
-		*(*uintptr)(vv.addr) = *(*uintptr)(x.addr)
-
-	case *sliceValue:
-		x := x.panicIfNot(Slice).(*sliceValue)
-		if !vv.CanSet() {
-			panic(cannotSet)
-		}
-		typesMustMatch(vv.typ, x.typ)
-		*vv.slice() = *x.slice()
-
-	case *stringValue:
-		// Do the kind check explicitly, because x.String() does not.
-		x.panicIfNot(String)
-		v.SetString(x.String())
-
-	case *structValue:
-		x := x.panicIfNot(Struct).(*structValue)
-		// TODO: This will have to move into the runtime
-		// once the gc goes in.
-		if !vv.CanSet() {
-			panic(cannotSet)
-		}
-		typesMustMatch(vv.typ, x.typ)
-		memmove(vv.addr, x.addr, vv.typ.Size())
-
-	case *uintValue:
-		v.SetUint(x.Uint())
+		// Non-empty interface requires runtime help.
+		ifaceE2I(iv.typ.runtimeType(), x.Interface(), iv.addr)
+		return
+	}
 
-	case *unsafePointerValue:
-		// Do the kind check explicitly, because x.UnsafePointer
-		// applies to more than just the UnsafePointer Kind.
-		x.panicIfNot(UnsafePointer)
-		v.SetPointer(unsafe.Pointer(x.Pointer()))
+	typesMustMatch("reflect.Set", iv.typ.toType(), ix.typ.toType())
+	n := ix.typ.size
+	if n <= ptrSize {
+		storeIword(iv.addr, ix.word, n)
+	} else {
+		memmove(iv.addr, ix.addr, n)
 	}
 }
 
 // SetBool sets v's underlying value.
 // It panics if v's Kind is not Bool or if CanSet() is false.
 func (v Value) SetBool(x bool) {
-	vv := v.panicIfNot(Bool).(*boolValue)
-
-	if !vv.CanSet() {
-		panic(cannotSet)
-	}
-	*(*bool)(vv.addr) = x
+	iv := v.internal()
+	iv.mustBeAssignable()
+	iv.mustBe(Bool)
+	*(*bool)(iv.addr) = x
 }
 
 // SetComplex sets v's underlying value to x.
 // It panics if v's Kind is not Complex64 or Complex128, or if CanSet() is false.
 func (v Value) SetComplex(x complex128) {
-	vv := v.panicIfNots(complexKinds).(*complexValue)
-
-	if !vv.CanSet() {
-		panic(cannotSet)
-	}
-	switch vv.typ.Kind() {
+	iv := v.internal()
+	iv.mustBeAssignable()
+	switch iv.kind {
 	default:
-		panic("reflect: invalid complex kind")
+		panic(&ValueError{"reflect.Value.SetComplex", iv.kind})
 	case Complex64:
-		*(*complex64)(vv.addr) = complex64(x)
+		*(*complex64)(iv.addr) = complex64(x)
 	case Complex128:
-		*(*complex128)(vv.addr) = x
+		*(*complex128)(iv.addr) = x
 	}
 }
 
 // SetFloat sets v's underlying value to x.
 // It panics if v's Kind is not Float32 or Float64, or if CanSet() is false.
 func (v Value) SetFloat(x float64) {
-	vv := v.panicIfNots(floatKinds).(*floatValue)
-
-	if !vv.CanSet() {
-		panic(cannotSet)
-	}
-	switch vv.typ.Kind() {
+	iv := v.internal()
+	iv.mustBeAssignable()
+	switch iv.kind {
 	default:
-		panic("reflect: invalid float kind")
+		panic(&ValueError{"reflect.Value.SetFloat", iv.kind})
 	case Float32:
-		*(*float32)(vv.addr) = float32(x)
+		*(*float32)(iv.addr) = float32(x)
 	case Float64:
-		*(*float64)(vv.addr) = x
+		*(*float64)(iv.addr) = x
 	}
 }
 
 // SetInt sets v's underlying value to x.
-// It panics if v's Kind is not a sized or unsized Int kind, or if CanSet() is false.
+// It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false.
 func (v Value) SetInt(x int64) {
-	vv := v.panicIfNots(intKinds).(*intValue)
-
-	if !vv.CanSet() {
-		panic(cannotSet)
-	}
-	switch vv.typ.Kind() {
+	iv := v.internal()
+	iv.mustBeAssignable()
+	switch iv.kind {
 	default:
-		panic("reflect: invalid int kind")
+		panic(&ValueError{"reflect.Value.SetInt", iv.kind})
 	case Int:
-		*(*int)(vv.addr) = int(x)
+		*(*int)(iv.addr) = int(x)
 	case Int8:
-		*(*int8)(vv.addr) = int8(x)
+		*(*int8)(iv.addr) = int8(x)
 	case Int16:
-		*(*int16)(vv.addr) = int16(x)
+		*(*int16)(iv.addr) = int16(x)
 	case Int32:
-		*(*int32)(vv.addr) = int32(x)
+		*(*int32)(iv.addr) = int32(x)
 	case Int64:
-		*(*int64)(vv.addr) = x
+		*(*int64)(iv.addr) = x
 	}
 }
 
 // SetLen sets v's length to n.
 // It panics if v's Kind is not Slice.
 func (v Value) SetLen(n int) {
-	vv := v.panicIfNot(Slice).(*sliceValue)
-
-	s := vv.slice()
+	iv := v.internal()
+	iv.mustBeAssignable()
+	iv.mustBe(Slice)
+	s := (*SliceHeader)(iv.addr)
 	if n < 0 || n > int(s.Cap) {
 		panic("reflect: slice length out of range in SetLen")
 	}
 	s.Len = n
 }
 
+// BUG(rsc): For a map keyed on an interface type, MapIndex and SetMapIndex
+// require the key to have the same interface type.  They should allow the use of
+// any key that implements the interface.
+
 // SetMapIndex sets the value associated with key in the map v to val.
 // It panics if v's Kind is not Map.
 // If val is the zero Value, SetMapIndex deletes the key from the map.
 func (v Value) SetMapIndex(key, val Value) {
-	vv := v.panicIfNot(Map).(*mapValue)
-	t := vv.Type()
-	typesMustMatch(t.Key(), key.Type())
-	var vaddr *byte
-	if val.IsValid() {
-		typesMustMatch(t.Elem(), val.Type())
-		vaddr = (*byte)(val.internal().getAddr())
-	}
-	m := *(**byte)(vv.addr)
-	mapassign(m, (*byte)(key.internal().getAddr()), vaddr)
+	iv := v.internal()
+	ikey := key.internal()
+	ival := val.internal()
+
+	iv.mustBe(Map)
+	iv.mustBeExported()
+	ikey.mustBeExported()
+	ival.mustBeExported()
+
+	typesMustMatch("reflect.Value.SetMapIndex", iv.typ.toType().Key(), ikey.typ.toType())
+	mapassign(iv.word, ikey.word, ival.word, ival.kind != Invalid)
 }
 
 // SetUint sets v's underlying value to x.
-// It panics if v's Kind is not a sized or unsized Uint kind, or if CanSet() is false.
+// It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false.
 func (v Value) SetUint(x uint64) {
-	vv := v.panicIfNots(uintKinds).(*uintValue)
-
-	if !vv.CanSet() {
-		panic(cannotSet)
-	}
-	switch vv.typ.Kind() {
+	iv := v.internal()
+	iv.mustBeAssignable()
+	switch iv.kind {
 	default:
-		panic("reflect: invalid uint kind")
+		panic(&ValueError{"reflect.Value.SetUint", iv.kind})
 	case Uint:
-		*(*uint)(vv.addr) = uint(x)
+		*(*uint)(iv.addr) = uint(x)
 	case Uint8:
-		*(*uint8)(vv.addr) = uint8(x)
+		*(*uint8)(iv.addr) = uint8(x)
 	case Uint16:
-		*(*uint16)(vv.addr) = uint16(x)
+		*(*uint16)(iv.addr) = uint16(x)
 	case Uint32:
-		*(*uint32)(vv.addr) = uint32(x)
+		*(*uint32)(iv.addr) = uint32(x)
 	case Uint64:
-		*(*uint64)(vv.addr) = x
+		*(*uint64)(iv.addr) = x
 	case Uintptr:
-		*(*uintptr)(vv.addr) = uintptr(x)
+		*(*uintptr)(iv.addr) = uintptr(x)
 	}
 }
 
 // SetPointer sets the unsafe.Pointer value v to x.
 // It panics if v's Kind is not UnsafePointer.
 func (v Value) SetPointer(x unsafe.Pointer) {
-	vv := v.panicIfNot(UnsafePointer).(*unsafePointerValue)
-
-	if !vv.CanSet() {
-		panic(cannotSet)
-	}
-	*(*unsafe.Pointer)(vv.addr) = x
+	iv := v.internal()
+	iv.mustBeAssignable()
+	iv.mustBe(UnsafePointer)
+	*(*unsafe.Pointer)(iv.addr) = x
 }
 
 // SetString sets v's underlying value to x.
 // It panics if v's Kind is not String or if CanSet() is false.
 func (v Value) SetString(x string) {
-	vv := v.panicIfNot(String).(*stringValue)
-
-	if !vv.CanSet() {
-		panic(cannotSet)
-	}
-	*(*string)(vv.addr) = x
+	iv := v.internal()
+	iv.mustBeAssignable()
+	iv.mustBe(String)
+	*(*string)(iv.addr) = x
 }
 
 // BUG(rsc): Value.Slice should allow slicing arrays.
@@ -978,25 +1249,18 @@ func (v Value) SetString(x string) {
 // Slice returns a slice of v.
 // It panics if v's Kind is not Slice.
 func (v Value) Slice(beg, end int) Value {
-	vv := v.panicIfNot(Slice).(*sliceValue)
-
+	iv := v.internal()
+	iv.mustBe(Slice)
 	cap := v.Cap()
 	if beg < 0 || end < beg || end > cap {
-		panic("slice index out of bounds")
+		panic("reflect.Value.Slice: slice index out of bounds")
 	}
-	typ := vv.typ
+	typ := iv.typ.toType()
 	s := new(SliceHeader)
-	s.Data = uintptr(vv.addr()) + uintptr(beg)*typ.Elem().Size()
+	s.Data = uintptr((*SliceHeader)(iv.addr).Data) + uintptr(beg)*typ.Elem().Size()
 	s.Len = end - beg
 	s.Cap = cap - beg
-
-	// Like the result of Addr, we treat Slice as an
-	// unaddressable temporary, so don't set canAddr.
-	flag := canSet
-	if vv.flag&canStore != 0 {
-		flag |= canStore
-	}
-	return newValue(typ, addr(s), flag)
+	return valueFromAddr(iv.flag&flagRO, typ, unsafe.Pointer(s))
 }
 
 // String returns the string v's underlying value, as a string.
@@ -1004,15 +1268,14 @@ func (v Value) Slice(beg, end int) Value {
 // Unlike the other getters, it does not panic if v's Kind is not String.
 // Instead, it returns a string of the form "<T value>" where T is v's type.
 func (v Value) String() string {
-	vi := v.Internal
-	if vi == nil {
+	iv := v.internal()
+	switch iv.kind {
+	case Invalid:
 		return "<invalid Value>"
+	case String:
+		return *(*string)(iv.addr)
 	}
-	if vi.Kind() == String {
-		vv := vi.(*stringValue)
-		return *(*string)(vv.addr)
-	}
-	return "<" + vi.Type().String() + " Value>"
+	return "<" + iv.typ.String() + " Value>"
 }
 
 // TryRecv attempts to receive a value from the channel v but will not block.
@@ -1021,241 +1284,97 @@ func (v Value) String() string {
 // The boolean ok is true if the value x corresponds to a send
 // on the channel, false if it is a zero value received because the channel is closed.
 func (v Value) TryRecv() (x Value, ok bool) {
-	vv := v.panicIfNot(Chan).(*chanValue)
-
-	var selected bool
-	x, ok = vv.recv(&selected)
-	if !selected {
-		return Value{}, false
-	}
-	return x, ok
+	iv := v.internal()
+	iv.mustBe(Chan)
+	iv.mustBeExported()
+	return iv.recv(true)
 }
 
 // TrySend attempts to send x on the channel v but will not block.
 // It panics if v's Kind is not Chan.
 // It returns true if the value was sent, false otherwise.
 func (v Value) TrySend(x Value) bool {
-	vv := v.panicIfNot(Chan).(*chanValue)
-
-	var selected bool
-	vv.send(x, &selected)
-	return selected
+	iv := v.internal()
+	iv.mustBe(Chan)
+	iv.mustBeExported()
+	return iv.send(x, true)
 }
 
 // Type returns v's type.
 func (v Value) Type() Type {
-	return v.internal().Type()
+	t := v.internal().typ
+	if t == nil {
+		panic(&ValueError{"reflect.Value.Type", Invalid})
+	}
+	return t.toType()
 }
 
-var uintKinds = []Kind{Uint, Uint8, Uint16, Uint32, Uint64, Uintptr}
-
 // Uint returns v's underlying value, as a uint64.
-// It panics if v's Kind is not a sized or unsized Uint kind.
+// It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.
 func (v Value) Uint() uint64 {
-	vv := v.panicIfNots(uintKinds).(*uintValue)
-
-	switch vv.typ.Kind() {
+	iv := v.internal()
+	switch iv.kind {
 	case Uint:
-		return uint64(*(*uint)(vv.addr))
+		return uint64(*(*uint)(unsafe.Pointer(&iv.word)))
 	case Uint8:
-		return uint64(*(*uint8)(vv.addr))
+		return uint64(*(*uint8)(unsafe.Pointer(&iv.word)))
 	case Uint16:
-		return uint64(*(*uint16)(vv.addr))
+		return uint64(*(*uint16)(unsafe.Pointer(&iv.word)))
 	case Uint32:
-		return uint64(*(*uint32)(vv.addr))
-	case Uint64:
-		return *(*uint64)(vv.addr)
+		return uint64(*(*uint32)(unsafe.Pointer(&iv.word)))
 	case Uintptr:
-		return uint64(*(*uintptr)(vv.addr))
+		return uint64(*(*uintptr)(unsafe.Pointer(&iv.word)))
+	case Uint64:
+		if iv.addr == nil {
+			return *(*uint64)(unsafe.Pointer(&iv.word))
+		}
+		return *(*uint64)(iv.addr)
 	}
-	panic("reflect: invalid uint kind")
+	panic(&ValueError{"reflect.Value.Uint", iv.kind})
 }
 
 // UnsafeAddr returns a pointer to v's data.
 // It is for advanced clients that also import the "unsafe" package.
+// It panics if v is not addressable.
 func (v Value) UnsafeAddr() uintptr {
-	return v.internal().UnsafeAddr()
-}
-
-// valueInterface is the common interface to reflection values.
-// The implementations of Value (e.g., arrayValue, structValue)
-// have additional type-specific methods.
-type valueInterface interface {
-	// Type returns the value's type.
-	Type() Type
-
-	// Interface returns the value as an interface{}.
-	Interface() interface{}
-
-	// CanSet returns true if the value can be changed.
-	// Values obtained by the use of non-exported struct fields
-	// can be used in Get but not Set.
-	// If CanSet returns false, calling the type-specific Set will panic.
-	CanSet() bool
-
-	// CanAddr returns true if the value's address can be obtained with Addr.
-	// Such values are called addressable.  A value is addressable if it is
-	// an element of a slice, an element of an addressable array,
-	// a field of an addressable struct, the result of dereferencing a pointer,
-	// or the result of a call to NewValue, MakeChan, MakeMap, or Zero.
-	// If CanAddr returns false, calling Addr will panic.
-	CanAddr() bool
-
-	// Addr returns the address of the value.
-	// If the value is not addressable, Addr panics.
-	// Addr is typically used to obtain a pointer to a struct field or slice element
-	// in order to call a method that requires a pointer receiver.
-	Addr() Value
-
-	// UnsafeAddr returns a pointer to the underlying data.
-	// It is for advanced clients that also import the "unsafe" package.
-	UnsafeAddr() uintptr
-
-	// Method returns a funcValue corresponding to the value's i'th method.
-	// The arguments to a Call on the returned funcValue
-	// should not include a receiver; the funcValue will use
-	// the value as the receiver.
-	Method(i int) Value
-
-	Kind() Kind
-
-	getAddr() addr
-}
-
-// flags for value
-const (
-	canSet   uint32 = 1 << iota // can set value (write to *v.addr)
-	canAddr                     // can take address of value
-	canStore                    // can store through value (write to **v.addr)
-)
-
-// value is the common implementation of most values.
-// It is embedded in other, public struct types, but always
-// with a unique tag like "uint" or "float" so that the client cannot
-// convert from, say, *uintValue to *floatValue.
-type value struct {
-	typ  Type
-	addr addr
-	flag uint32
-}
-
-func (v *value) Type() Type { return v.typ }
-
-func (v *value) Kind() Kind { return v.typ.Kind() }
-
-func (v *value) Addr() Value {
-	if !v.CanAddr() {
-		panic("reflect: cannot take address of value")
+	iv := v.internal()
+	if iv.kind == Invalid {
+		panic(&ValueError{"reflect.Value.UnsafeAddr", iv.kind})
 	}
-	a := v.addr
-	flag := canSet
-	if v.CanSet() {
-		flag |= canStore
+	if iv.flag&flagAddr == 0 {
+		panic("reflect.Value.UnsafeAddr of unaddressable value")
 	}
-	// We could safely set canAddr here too -
-	// the caller would get the address of a -
-	// but it doesn't match the Go model.
-	// The language doesn't let you say &&v.
-	return newValue(PtrTo(v.typ), addr(&a), flag)
-}
-
-func (v *value) UnsafeAddr() uintptr { return uintptr(v.addr) }
-
-func (v *value) getAddr() addr { return v.addr }
-
-func (v *value) Interface() interface{} {
-	typ := v.typ
-	if typ.Kind() == Interface {
-		// There are two different representations of interface values,
-		// one if the interface type has methods and one if it doesn't.
-		// These two representations require different expressions
-		// to extract correctly.
-		if typ.NumMethod() == 0 {
-			// Extract as interface value without methods.
-			return *(*interface{})(v.addr)
-		}
-		// Extract from v.addr as interface value with methods.
-		return *(*interface {
-			m()
-		})(v.addr)
-	}
-	return unsafe.Unreflect(v.typ, unsafe.Pointer(v.addr))
-}
-
-func (v *value) CanSet() bool { return v.flag&canSet != 0 }
-
-func (v *value) CanAddr() bool { return v.flag&canAddr != 0 }
-
-
-/*
- * basic types
- */
-
-// boolValue represents a bool value.
-type boolValue struct {
-	value "bool"
-}
-
-// floatValue represents a float value.
-type floatValue struct {
-	value "float"
-}
-
-// complexValue represents a complex value.
-type complexValue struct {
-	value "complex"
-}
-
-// intValue represents an int value.
-type intValue struct {
-	value "int"
+	return uintptr(iv.addr)
 }
 
 // StringHeader is the runtime representation of a string.
+// It cannot be used safely or portably.
 type StringHeader struct {
 	Data uintptr
 	Len  int
 }
 
-// stringValue represents a string value.
-type stringValue struct {
-	value "string"
-}
-
-// uintValue represents a uint value.
-type uintValue struct {
-	value "uint"
-}
-
-// unsafePointerValue represents an unsafe.Pointer value.
-type unsafePointerValue struct {
-	value "unsafe.Pointer"
+// SliceHeader is the runtime representation of a slice.
+// It cannot be used safely or portably.
+type SliceHeader struct {
+	Data uintptr
+	Len  int
+	Cap  int
 }
 
-func typesMustMatch(t1, t2 Type) {
+func typesMustMatch(what string, t1, t2 Type) {
 	if t1 != t2 {
-		panic("type mismatch: " + t1.String() + " != " + t2.String())
+		panic("reflect: " + what + ": " + t1.String() + " != " + t2.String())
 	}
 }
 
-/*
- * array
- */
-
-// ArrayOrSliceValue is the common interface
-// implemented by both arrayValue and sliceValue.
-type arrayOrSliceValue interface {
-	valueInterface
-	addr() addr
-}
-
 // grow grows the slice s so that it can hold extra more values, allocating
 // more capacity if needed. It also returns the old and new slice lengths.
 func grow(s Value, extra int) (Value, int, int) {
 	i0 := s.Len()
 	i1 := i0 + extra
 	if i1 < i0 {
-		panic("append: slice overflow")
+		panic("reflect.Append: slice overflow")
 	}
 	m := s.Cap()
 	if i1 <= m {
@@ -1280,8 +1399,8 @@ func grow(s Value, extra int) (Value, int, int) {
 // Append appends the values x to a slice s and returns the resulting slice.
 // Each x must have the same type as s' element type.
 func Append(s Value, x ...Value) Value {
+	s.internal().mustBe(Slice)
 	s, i0, i1 := grow(s, len(x))
-	s.panicIfNot(Slice)
 	for i, j := i0, 0; i < i1; i, j = i+1, j+1 {
 		s.Index(i).Set(x[j])
 	}
@@ -1291,6 +1410,9 @@ func Append(s Value, x ...Value) Value {
 // AppendSlice appends a slice t to a slice s and returns the resulting slice.
 // The slices s and t must have the same element type.
 func AppendSlice(s, t Value) Value {
+	s.internal().mustBe(Slice)
+	t.internal().mustBe(Slice)
+	typesMustMatch("reflect.AppendSlice", s.Type().Elem(), t.Type().Elem())
 	s, i0, i1 := grow(s, t.Len())
 	Copy(s.Slice(i0, i1), t)
 	return s
@@ -1299,52 +1421,61 @@ func AppendSlice(s, t Value) Value {
 // Copy copies the contents of src into dst until either
 // dst has been filled or src has been exhausted.
 // It returns the number of elements copied.
-// Dst and src each must be a slice or array, and they
-// must have the same element type.
+// Dst and src each must have kind Slice or Array, and
+// dst and src must have the same element type.
 func Copy(dst, src Value) int {
-	// TODO: This will have to move into the runtime
-	// once the real gc goes in.
-	de := dst.Type().Elem()
-	se := src.Type().Elem()
-	typesMustMatch(de, se)
-	n := dst.Len()
-	if xn := src.Len(); n > xn {
-		n = xn
-	}
-	memmove(dst.panicIfNots(arrayOrSlice).(arrayOrSliceValue).addr(),
-		src.panicIfNots(arrayOrSlice).(arrayOrSliceValue).addr(),
-		uintptr(n)*de.Size())
-	return n
-}
+	idst := dst.internal()
+	isrc := src.internal()
 
-// An arrayValue represents an array.
-type arrayValue struct {
-	value "array"
-}
+	if idst.kind != Array && idst.kind != Slice {
+		panic(&ValueError{"reflect.Copy", idst.kind})
+	}
+	if idst.kind == Array {
+		idst.mustBeAssignable()
+	}
+	idst.mustBeExported()
+	if isrc.kind != Array && isrc.kind != Slice {
+		panic(&ValueError{"reflect.Copy", isrc.kind})
+	}
+	isrc.mustBeExported()
 
-// addr returns the base address of the data in the array.
-func (v *arrayValue) addr() addr { return v.value.addr }
+	de := idst.typ.toType().Elem()
+	se := isrc.typ.toType().Elem()
+	typesMustMatch("reflect.Copy", de, se)
 
-/*
- * slice
- */
+	n := dst.Len()
+	if sn := src.Len(); n > sn {
+		n = sn
+	}
 
-// runtime representation of slice
-type SliceHeader struct {
-	Data uintptr
-	Len  int
-	Cap  int
-}
+	// If sk is an in-line array, cannot take its address.
+	// Instead, copy element by element.
+	if isrc.addr == nil {
+		for i := 0; i < n; i++ {
+			dst.Index(i).Set(src.Index(i))
+		}
+		return n
+	}
 
-// A sliceValue represents a slice.
-type sliceValue struct {
-	value "slice"
+	// Copy via memmove.
+	var da, sa unsafe.Pointer
+	if idst.kind == Array {
+		da = isrc.addr
+	} else {
+		da = unsafe.Pointer((*SliceHeader)(idst.addr).Data)
+	}
+	if isrc.kind == Array {
+		sa = isrc.addr
+	} else {
+		sa = unsafe.Pointer((*SliceHeader)(isrc.addr).Data)
+	}
+	memmove(da, sa, uintptr(n)*de.Size())
+	return n
 }
 
-func (v *sliceValue) slice() *SliceHeader { return (*SliceHeader)(v.value.addr) }
-
-// addr returns the base address of the data in the slice.
-func (v *sliceValue) addr() addr { return addr(v.slice().Data) }
+/*
+ * constructors
+ */
 
 // MakeSlice creates a new zero-initialized slice value
 // for the specified slice type, length, and capacity.
@@ -1357,26 +1488,9 @@ func MakeSlice(typ Type, len, cap int) Value {
 		Len:  len,
 		Cap:  cap,
 	}
-	return newValue(typ, addr(s), canAddr|canSet|canStore)
+	return valueFromAddr(0, typ, unsafe.Pointer(s))
 }
 
-/*
- * chan
- */
-
-// A chanValue represents a chan.
-type chanValue struct {
-	value "chan"
-}
-
-// implemented in ../pkg/runtime/reflect.cgo
-func makechan(typ *runtime.ChanType, size uint32) (ch *byte)
-func chansend(ch, val *byte, selected *bool)
-func chanrecv(ch, val *byte, selected *bool, ok *bool)
-func chanclose(ch *byte)
-func chanlen(ch *byte) int32
-func chancap(ch *byte) int32
-
 // MakeChan creates a new channel with the specified type and buffer size.
 func MakeChan(typ Type, buffer int) Value {
 	if typ.Kind() != Chan {
@@ -1388,121 +1502,17 @@ func MakeChan(typ Type, buffer int) Value {
 	if typ.ChanDir() != BothDir {
 		panic("MakeChan: unidirectional channel type")
 	}
-	v := Zero(typ)
-	ch := v.panicIfNot(Chan).(*chanValue)
-	*(**byte)(ch.addr) = makechan((*runtime.ChanType)(unsafe.Pointer(typ.(*commonType))), uint32(buffer))
-	return v
-}
-
-/*
- * func
- */
-
-// A funcValue represents a function value.
-type funcValue struct {
-	value       "func"
-	first       *value
-	isInterface bool
-}
-
-// Method returns a funcValue corresponding to v's i'th method.
-// The arguments to a Call on the returned funcValue
-// should not include a receiver; the funcValue will use v
-// as the receiver.
-func (v *value) Method(i int) Value {
-	t := v.Type().uncommon()
-	if t == nil || i < 0 || i >= len(t.methods) {
-		panic("reflect: Method index out of range")
-	}
-	p := &t.methods[i]
-	fn := p.tfn
-	fv := &funcValue{value: value{toType(p.typ), addr(&fn), 0}, first: v, isInterface: false}
-	return Value{fv}
+	ch := makechan(typ.runtimeType(), uint32(buffer))
+	return valueFromIword(0, typ, ch)
 }
 
-// implemented in ../pkg/runtime/*/asm.s
-func call(fn, arg *byte, n uint32)
-
-// Interface returns the fv as an interface value.
-// If fv is a method obtained by invoking Value.Method
-// (as opposed to Type.Method), Interface cannot return an
-// interface value, so it panics.
-func (fv *funcValue) Interface() interface{} {
-	if fv.first != nil {
-		panic("funcValue: cannot create interface value for method with bound receiver")
-	}
-	return fv.value.Interface()
-}
-
-/*
- * interface
- */
-
-// An interfaceValue represents an interface value.
-type interfaceValue struct {
-	value "interface"
-}
-
-// ../runtime/reflect.cgo
-func setiface(typ *interfaceType, x *interface{}, addr addr)
-
-// Method returns a funcValue corresponding to v's i'th method.
-// The arguments to a Call on the returned funcValue
-// should not include a receiver; the funcValue will use v
-// as the receiver.
-func (v *interfaceValue) Method(i int) Value {
-	t := (*interfaceType)(unsafe.Pointer(v.Type().(*commonType)))
-	if t == nil || i < 0 || i >= len(t.methods) {
-		panic("reflect: Method index out of range")
-	}
-	p := &t.methods[i]
-
-	// Interface is two words: itable, data.
-	tab := *(**runtime.Itable)(v.addr)
-	data := &value{Typeof((*byte)(nil)), addr(uintptr(v.addr) + ptrSize), 0}
-
-	// Function pointer is at p.perm in the table.
-	fn := tab.Fn[i]
-	fv := &funcValue{value: value{toType(p.typ), addr(&fn), 0}, first: data, isInterface: true}
-	return Value{fv}
-}
-
-/*
- * map
- */
-
-// A mapValue represents a map value.
-type mapValue struct {
-	value "map"
-}
-
-// implemented in ../pkg/runtime/reflect.cgo
-func mapaccess(m, key, val *byte) bool
-func mapassign(m, key, val *byte)
-func maplen(m *byte) int32
-func mapiterinit(m *byte) *byte
-func mapiternext(it *byte)
-func mapiterkey(it *byte, key *byte) bool
-func makemap(t *runtime.MapType) *byte
-
 // MakeMap creates a new map of the specified type.
 func MakeMap(typ Type) Value {
 	if typ.Kind() != Map {
 		panic("reflect: MakeMap of non-map type")
 	}
-	v := Zero(typ)
-	m := v.panicIfNot(Map).(*mapValue)
-	*(**byte)(m.addr) = makemap((*runtime.MapType)(unsafe.Pointer(typ.(*commonType))))
-	return v
-}
-
-/*
- * ptr
- */
-
-// A ptrValue represents a pointer.
-type ptrValue struct {
-	value "ptr"
+	m := makemap(typ.runtimeType())
+	return valueFromIword(0, typ, m)
 }
 
 // Indirect returns the value that v points to.
@@ -1515,64 +1525,16 @@ func Indirect(v Value) Value {
 	return v.Elem()
 }
 
-/*
- * struct
- */
-
-// A structValue represents a struct value.
-type structValue struct {
-	value "struct"
-}
-
-/*
- * constructors
- */
-
 // NewValue returns a new Value initialized to the concrete value
 // stored in the interface i.  NewValue(nil) returns the zero Value.
 func NewValue(i interface{}) Value {
 	if i == nil {
 		return Value{}
 	}
-	_, a := unsafe.Reflect(i)
-	return newValue(Typeof(i), addr(a), canSet|canAddr|canStore)
-}
-
-func newValue(typ Type, addr addr, flag uint32) Value {
-	v := value{typ, addr, flag}
-	switch typ.Kind() {
-	case Array:
-		return Value{&arrayValue{v}}
-	case Bool:
-		return Value{&boolValue{v}}
-	case Chan:
-		return Value{&chanValue{v}}
-	case Float32, Float64:
-		return Value{&floatValue{v}}
-	case Func:
-		return Value{&funcValue{value: v}}
-	case Complex64, Complex128:
-		return Value{&complexValue{v}}
-	case Int, Int8, Int16, Int32, Int64:
-		return Value{&intValue{v}}
-	case Interface:
-		return Value{&interfaceValue{v}}
-	case Map:
-		return Value{&mapValue{v}}
-	case Ptr:
-		return Value{&ptrValue{v}}
-	case Slice:
-		return Value{&sliceValue{v}}
-	case String:
-		return Value{&stringValue{v}}
-	case Struct:
-		return Value{&structValue{v}}
-	case Uint, Uint8, Uint16, Uint32, Uint64, Uintptr:
-		return Value{&uintValue{v}}
-	case UnsafePointer:
-		return Value{&unsafePointerValue{v}}
-	}
-	panic("newValue" + typ.String())
+	// For an interface value with the noAddr bit set,
+	// the representation is identical to an empty interface.
+	eface := *(*emptyInterface)(unsafe.Pointer(&i))
+	return packValue(0, eface.typ, eface.word)
 }
 
 // Zero returns a Value representing a zero value for the specified type.
@@ -1583,5 +1545,37 @@ func Zero(typ Type) Value {
 	if typ == nil {
 		panic("reflect: Zero(nil)")
 	}
-	return newValue(typ, addr(unsafe.New(typ)), canSet|canAddr|canStore)
+	if typ.Size() <= ptrSize {
+		return valueFromIword(0, typ, 0)
+	}
+	return valueFromAddr(0, typ, unsafe.New(typ))
 }
+
+// New returns a Value representing a pointer to a new zero value
+// for the specified type.  That is, the returned Value's Type is PtrTo(t).
+func New(typ Type) Value {
+	if typ == nil {
+		panic("reflect: New(nil)")
+	}
+	ptr := unsafe.New(typ)
+	return valueFromIword(0, PtrTo(typ), iword(ptr))
+}
+
+// implemented in ../pkg/runtime
+func chancap(ch iword) int32
+func chanclose(ch iword)
+func chanlen(ch iword) int32
+func chanrecv(ch iword, nb bool) (val iword, selected, received bool)
+func chansend(ch iword, val iword, nb bool) bool
+
+func makechan(typ *runtime.Type, size uint32) (ch iword)
+func makemap(t *runtime.Type) iword
+func mapaccess(m iword, key iword) (val iword, ok bool)
+func mapassign(m iword, key, val iword, ok bool)
+func mapiterinit(m iword) *byte
+func mapiterkey(it *byte) (key iword, ok bool)
+func mapiternext(it *byte)
+func maplen(m iword) int32
+
+func call(fn, arg unsafe.Pointer, n uint32)
+func ifaceE2I(t *runtime.Type, src interface{}, dst unsafe.Pointer)
diff --git a/src/pkg/runtime/Makefile b/src/pkg/runtime/Makefile
index 4da78c5f09..b122e05999 100644
--- a/src/pkg/runtime/Makefile
+++ b/src/pkg/runtime/Makefile
@@ -71,7 +71,6 @@ OFILES=\
 	msize.$O\
 	print.$O\
 	proc.$O\
-	reflect.$O\
 	rune.$O\
 	runtime.$O\
 	runtime1.$O\
diff --git a/src/pkg/runtime/chan.c b/src/pkg/runtime/chan.c
index f2bdad27be..f94c3ef40a 100644
--- a/src/pkg/runtime/chan.c
+++ b/src/pkg/runtime/chan.c
@@ -128,6 +128,15 @@ runtime·makechan_c(Type *elem, int64 hint)
 	return c;
 }
 
+// For reflect
+//	func makechan(typ *ChanType, size uint32) (chan)
+void
+reflect·makechan(ChanType *t, uint32 size, Hchan *c)
+{
+	c = runtime·makechan_c(t->elem, size);
+	FLUSH(&c);
+}
+
 static void
 destroychan(Hchan *c)
 {
@@ -263,6 +272,7 @@ closed:
 	runtime·panicstring("send on closed channel");
 }
 
+
 void
 runtime·chanrecv(Hchan* c, byte *ep, bool *selected, bool *received)
 {
@@ -519,6 +529,71 @@ runtime·selectnbrecv2(byte *v, bool *received, Hchan *c, bool selected)
 	runtime·chanrecv(c, v, &selected, received);
 }	
 
+// For reflect:
+//	func chansend(c chan, val iword, nb bool) (selected bool)
+// where an iword is the same word an interface value would use:
+// the actual data if it fits, or else a pointer to the data.
+//
+// The "uintptr selected" is really "bool selected" but saying
+// uintptr gets us the right alignment for the output parameter block.
+void
+reflect·chansend(Hchan *c, uintptr val, bool nb, uintptr selected)
+{
+	bool *sp;
+	byte *vp;
+	
+	if(c == nil)
+		runtime·panicstring("send to nil channel");
+
+	if(nb) {
+		selected = false;
+		sp = (bool*)&selected;
+	} else {
+		*(bool*)&selected = true;
+		FLUSH(&selected);
+		sp = nil;
+	}
+	if(c->elemsize <= sizeof(val))
+		vp = (byte*)&val;
+	else
+		vp = (byte*)val;
+	runtime·chansend(c, vp, sp);
+}
+
+// For reflect:
+//	func chanrecv(c chan, nb bool) (val iword, selected, received bool)
+// where an iword is the same word an interface value would use:
+// the actual data if it fits, or else a pointer to the data.
+void
+reflect·chanrecv(Hchan *c, bool nb, uintptr val, bool selected, bool received)
+{
+	byte *vp;
+	bool *sp;
+	
+	if(c == nil)
+		runtime·panicstring("receive from nil channel");
+
+	if(nb) {
+		selected = false;
+		sp = &selected;
+	} else {
+		selected = true;
+		FLUSH(&selected);
+		sp = nil;
+	}
+	received = false;
+	FLUSH(&received);
+	if(c->elemsize <= sizeof(val)) {
+		val = 0;
+		vp = (byte*)&val;
+	} else {
+		vp = runtime·mal(c->elemsize);
+		val = (uintptr)vp;
+		FLUSH(&val);
+	}
+	runtime·chanrecv(c, vp, sp, &received);
+}
+
 static void newselect(int32, Select**);
 
 // newselect(size uint32) (sel *byte);
@@ -1036,22 +1111,36 @@ runtime·closechan(Hchan *c)
 	runtime·unlock(c);
 }
 
+// For reflect
+//	func chanclose(c chan)
 void
-runtime·chanclose(Hchan *c)
+reflect·chanclose(Hchan *c)
 {
 	runtime·closechan(c);
 }
 
-int32
-runtime·chanlen(Hchan *c)
+// For reflect
+//	func chanlen(c chan) (len int32)
+void
+reflect·chanlen(Hchan *c, int32 len)
 {
-	return c->qcount;
+	if(c == nil)
+		len = 0;
+	else
+		len = c->qcount;
+	FLUSH(&len);
 }
 
-int32
-runtime·chancap(Hchan *c)
+// For reflect
+//	func chancap(c chan) (cap int32)
+void
+reflect·chancap(Hchan *c, int32 cap)
 {
-	return c->dataqsiz;
+	if(c == nil)
+		cap = 0;
+	else
+		cap = c->dataqsiz;
+	FLUSH(&cap);
 }
 
 static SudoG*
diff --git a/src/pkg/runtime/hashmap.c b/src/pkg/runtime/hashmap.c
index e50cefd9ab..5ba1eb20ab 100644
--- a/src/pkg/runtime/hashmap.c
+++ b/src/pkg/runtime/hashmap.c
@@ -776,6 +776,15 @@ runtime·makemap(Type *key, Type *val, int64 hint, Hmap *ret)
 	FLUSH(&ret);
 }
 
+// For reflect:
+//	func makemap(Type *mapType) (hmap *map)
+void
+reflect·makemap(MapType *t, Hmap *ret)
+{
+	ret = runtime·makemap_c(t->key, t->elem, 0);
+	FLUSH(&ret);
+}
+
 void
 runtime·mapaccess(Hmap *h, byte *ak, byte *av, bool *pres)
 {
@@ -855,6 +864,34 @@ runtime·mapaccess2(Hmap *h, ...)
 	}
 }
 
+// For reflect:
+//	func mapaccess(h map, key iword) (val iword, pres bool)
+// where an iword is the same word an interface value would use:
+// the actual data if it fits, or else a pointer to the data.
+void
+reflect·mapaccess(Hmap *h, uintptr key, uintptr val, bool pres)
+{
+	byte *ak, *av;
+
+	if(h == nil)
+		runtime·panicstring("lookup in nil map");
+	if(h->keysize <= sizeof(key))
+		ak = (byte*)&key;
+	else
+		ak = (byte*)key;
+	val = 0;
+	pres = false;
+	if(h->valsize <= sizeof(val))
+		av = (byte*)&val;
+	else {
+		av = runtime·mal(h->valsize);
+		val = (uintptr)av;
+	}
+	runtime·mapaccess(h, ak, av, &pres);
+	FLUSH(&val);
+	FLUSH(&pres);
+}
+
 void
 runtime·mapassign(Hmap *h, byte *ak, byte *av)
 {
@@ -938,6 +975,30 @@ runtime·mapassign2(Hmap *h, ...)
 	}
 }
 
+// For reflect:
+//	func mapassign(h map, key, val iword, pres bool)
+// where an iword is the same word an interface value would use:
+// the actual data if it fits, or else a pointer to the data.
+void
+reflect·mapassign(Hmap *h, uintptr key, uintptr val, bool pres)
+{
+	byte *ak, *av;
+
+	if(h == nil)
+		runtime·panicstring("lookup in nil map");
+	if(h->keysize <= sizeof(key))
+		ak = (byte*)&key;
+	else
+		ak = (byte*)key;
+	if(h->valsize <= sizeof(val))
+		av = (byte*)&val;
+	else
+		av = (byte*)val;
+	if(!pres)
+		av = nil;
+	runtime·mapassign(h, ak, av);
+}
+
 // mapiterinit(hmap *map[any]any, hiter *any);
 void
 runtime·mapiterinit(Hmap *h, struct hash_iter *it)
@@ -959,14 +1020,14 @@ runtime·mapiterinit(Hmap *h, struct hash_iter *it)
 	}
 }
 
-struct hash_iter*
-runtime·newmapiterinit(Hmap *h)
+// For reflect:
+//	func mapiterinit(h map) (it iter)
+void
+reflect·mapiterinit(Hmap *h, struct hash_iter *it)
 {
-	struct hash_iter *it;
-
 	it = runtime·mal(sizeof *it);
+	FLUSH(&it);
 	runtime·mapiterinit(h, it);
-	return it;
 }
 
 // mapiternext(hiter *any);
@@ -986,6 +1047,14 @@ runtime·mapiternext(struct hash_iter *it)
 	}
 }
 
+// For reflect:
+//	func mapiternext(it iter)
+void
+reflect·mapiternext(struct hash_iter *it)
+{
+	runtime·mapiternext(it);
+}
+
 // mapiter1(hiter *any) (key any);
 #pragma textflag 7
 void
@@ -1026,6 +1095,48 @@ runtime·mapiterkey(struct hash_iter *it, void *ak)
 	return true;
 }
 
+// For reflect:
+//	func mapiterkey(h map) (key iword, ok bool)
+// where an iword is the same word an interface value would use:
+// the actual data if it fits, or else a pointer to the data.
+void
+reflect·mapiterkey(struct hash_iter *it, uintptr key, bool ok)
+{
+	Hmap *h;
+	byte *res;
+
+	key = 0;
+	ok = false;
+	h = it->h;
+	res = it->data;
+	if(res == nil) {
+		key = 0;
+		ok = false;
+	} else {
+		key = 0;
+		if(h->keysize <= sizeof(key))
+			h->keyalg->copy(h->keysize, (byte*)&key, res);
+		else
+			key = (uintptr)res;
+		ok = true;
+	}
+	FLUSH(&key);
+	FLUSH(&ok);
+}
+
+// For reflect:
+//	func maplen(h map) (len int32)
+// Like len(m) in the actual language, we treat the nil map as length 0.
+void
+reflect·maplen(Hmap *h, int32 len)
+{
+	if(h == nil)
+		len = 0;
+	else
+		len = h->count;
+	FLUSH(&len);
+}
+
 // mapiter2(hiter *any) (key any, val any);
 #pragma textflag 7
 void
diff --git a/src/pkg/runtime/iface.c b/src/pkg/runtime/iface.c
index 698aead3df..6c806512f8 100644
--- a/src/pkg/runtime/iface.c
+++ b/src/pkg/runtime/iface.c
@@ -6,6 +6,14 @@
 #include "type.h"
 #include "malloc.h"
 
+enum 
+{
+	// If an empty interface has these bits set in its type
+	// pointer, it was copied from a reflect.Value and is
+	// not a valid empty interface.
+	reflectFlags = 3,
+};
+
 void
 runtime·printiface(Iface i)
 {
@@ -276,6 +284,8 @@ runtime·assertE2T(Type *t, Eface e, ...)
 {
 	byte *ret;
 
+	if(((uintptr)e.type&reflectFlags) != 0)
+		runtime·throw("invalid interface value");
 	ret = (byte*)(&e+1);
 	assertE2Tret(t, e, ret);
 }
@@ -285,6 +295,8 @@ assertE2Tret(Type *t, Eface e, byte *ret)
 {
 	Eface err;
 
+	if(((uintptr)e.type&reflectFlags) != 0)
+		runtime·throw("invalid interface value");
 	if(e.type == nil) {
 		runtime·newTypeAssertionError(nil, nil, t,
 			nil, nil, t->string,
@@ -309,6 +321,8 @@ runtime·assertE2T2(Type *t, Eface e, ...)
 	bool *ok;
 	int32 wid;
 
+	if(((uintptr)e.type&reflectFlags) != 0)
+		runtime·throw("invalid interface value");
 	ret = (byte*)(&e+1);
 	wid = t->size;
 	ok = (bool*)(ret+runtime·rnd(wid, 1));
@@ -444,6 +458,8 @@ runtime·ifaceE2I(InterfaceType *inter, Eface e, Iface *ret)
 	Type *t;
 	Eface err;
 
+	if(((uintptr)e.type&reflectFlags) != 0)
+		runtime·throw("invalid interface value");
 	t = e.type;
 	if(t == nil) {
 		// explicit conversions require non-nil interface value.
@@ -456,6 +472,14 @@ runtime·ifaceE2I(InterfaceType *inter, Eface e, Iface *ret)
 	ret->tab = itab(inter, t, 0);
 }
 
+// For reflect
+//	func ifaceE2I(t *InterfaceType, e interface{}, dst *Iface)
+void
+reflect·ifaceE2I(InterfaceType *inter, Eface e, Iface *dst)
+{
+	runtime·ifaceE2I(inter, e, dst);
+}
+
 // func ifaceE2I(sigi *byte, iface any) (ret any)
 void
 runtime·assertE2I(InterfaceType* inter, Eface e, Iface ret)
@@ -467,6 +491,8 @@ runtime·assertE2I(InterfaceType* inter, Eface e, Iface ret)
 void
 runtime·assertE2I2(InterfaceType *inter, Eface e, Iface ret, bool ok)
 {
+	if(((uintptr)e.type&reflectFlags) != 0)
+		runtime·throw("invalid interface value");
 	if(e.type == nil) {
 		ok = 0;
 		ret.data = nil;
@@ -489,6 +515,8 @@ runtime·assertE2E(InterfaceType* inter, Eface e, Eface ret)
 	Type *t;
 	Eface err;
 
+	if(((uintptr)e.type&reflectFlags) != 0)
+		runtime·throw("invalid interface value");
 	t = e.type;
 	if(t == nil) {
 		// explicit conversions require non-nil interface value.
@@ -505,6 +533,8 @@ runtime·assertE2E(InterfaceType* inter, Eface e, Eface ret)
 void
 runtime·assertE2E2(InterfaceType* inter, Eface e, Eface ret, bool ok)
 {
+	if(((uintptr)e.type&reflectFlags) != 0)
+		runtime·throw("invalid interface value");
 	USED(inter);
 	ret = e;
 	ok = e.type != nil;
@@ -582,6 +612,10 @@ runtime·ifaceeq_c(Iface i1, Iface i2)
 bool
 runtime·efaceeq_c(Eface e1, Eface e2)
 {
+	if(((uintptr)e1.type&reflectFlags) != 0)
+		runtime·throw("invalid interface value");
+	if(((uintptr)e2.type&reflectFlags) != 0)
+		runtime·throw("invalid interface value");
 	if(e1.type != e2.type)
 		return false;
 	if(e1.type == nil)
@@ -624,6 +658,8 @@ runtime·efacethash(Eface e1, uint32 ret)
 {
 	Type *t;
 
+	if(((uintptr)e1.type&reflectFlags) != 0)
+		runtime·throw("invalid interface value");
 	ret = 0;
 	t = e1.type;
 	if(t != nil)
@@ -634,11 +670,14 @@ runtime·efacethash(Eface e1, uint32 ret)
 void
 unsafe·Typeof(Eface e, Eface ret)
 {
+	if(((uintptr)e.type&reflectFlags) != 0)
+		runtime·throw("invalid interface value");
 	if(e.type == nil) {
 		ret.type = nil;
 		ret.data = nil;
-	} else
-		ret = *(Eface*)e.type;
+	} else {
+		ret = *(Eface*)(e.type);
+	}
 	FLUSH(&ret);
 }
 
@@ -648,6 +687,8 @@ unsafe·Reflect(Eface e, Eface rettype, void *retaddr)
 	uintptr *p;
 	uintptr x;
 
+	if(((uintptr)e.type&reflectFlags) != 0)
+		runtime·throw("invalid interface value");
 	if(e.type == nil) {
 		rettype.type = nil;
 		rettype.data = nil;
@@ -678,6 +719,9 @@ unsafe·Reflect(Eface e, Eface rettype, void *retaddr)
 void
 unsafe·Unreflect(Eface typ, void *addr, Eface e)
 {
+	if(((uintptr)typ.type&reflectFlags) != 0)
+		runtime·throw("invalid interface value");
+
 	// Reflect library has reinterpreted typ
 	// as its own kind of type structure.
 	// We know that the pointer to the original
@@ -702,6 +746,9 @@ unsafe·New(Eface typ, void *ret)
 {
 	Type *t;
 
+	if(((uintptr)typ.type&reflectFlags) != 0)
+		runtime·throw("invalid interface value");
+
 	// Reflect library has reinterpreted typ
 	// as its own kind of type structure.
 	// We know that the pointer to the original
@@ -721,6 +768,9 @@ unsafe·NewArray(Eface typ, uint32 n, void *ret)
 	uint64 size;
 	Type *t;
 
+	if(((uintptr)typ.type&reflectFlags) != 0)
+		runtime·throw("invalid interface value");
+
 	// Reflect library has reinterpreted typ
 	// as its own kind of type structure.
 	// We know that the pointer to the original
diff --git a/src/pkg/runtime/reflect.goc b/src/pkg/runtime/reflect.goc
deleted file mode 100644
index 9bdc48afbc..0000000000
--- a/src/pkg/runtime/reflect.goc
+++ /dev/null
@@ -1,114 +0,0 @@
-// Copyright 2009 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package reflect
-#include "runtime.h"
-#include "type.h"
-
-static Type*
-gettype(void *typ)
-{
-	// typ is a *runtime.Type (or *runtime.MapType, etc), but the Type
-	// defined in type.h includes an interface value header
-	// in front of the raw structure.  the -2 below backs up
-	// to the interface value header.
-	return (Type*)((void**)typ - 2);
-}
-
-/*
- * Go wrappers around the C functions near the bottom of hashmap.c
- * There's no recursion here even though it looks like there is:
- * the names after func are in the reflect package name space
- * but the names in the C bodies are in the standard C name space.
- */
-
-func mapaccess(map *byte, key *byte, val *byte) (pres bool) {
-	runtime·mapaccess((Hmap*)map, key, val, &pres);
-}
-
-func mapassign(map *byte, key *byte, val *byte) {
-	runtime·mapassign((Hmap*)map, key, val);
-}
-
-func maplen(map *byte) (len int32) {
-	// length is first word of map
-	len = *(uint32*)map;
-}
-
-func mapiterinit(map *byte) (it *byte) {
-	it = (byte*)runtime·newmapiterinit((Hmap*)map);
-}
-
-func mapiternext(it *byte) {
-	runtime·mapiternext((struct hash_iter*)it);
-}
-
-func mapiterkey(it *byte, key *byte) (ok bool) {
-	ok = runtime·mapiterkey((struct hash_iter*)it, key);
-}
-
-func makemap(typ *byte) (map *byte) {
-	MapType *t;
-
-	t = (MapType*)gettype(typ);
-	map = (byte*)runtime·makemap_c(t->key, t->elem, 0);
-}
-
-/*
- * Go wrappers around the C functions in chan.c
- */
-
-func makechan(typ *byte, size uint32) (ch *byte) {
-	ChanType *t;
-
-	// typ is a *runtime.ChanType, but the ChanType
-	// defined in type.h includes an interface value header
-	// in front of the raw ChanType.  the -2 below backs up
-	// to the interface value header.
-	t = (ChanType*)gettype(typ);
-	ch = (byte*)runtime·makechan_c(t->elem, size);
-}
-
-func chansend(ch *byte, val *byte, selected *bool) {
-	runtime·chansend((Hchan*)ch, val, selected);
-}
-
-func chanrecv(ch *byte, val *byte, selected *bool, received *bool) {
-	runtime·chanrecv((Hchan*)ch, val, selected, received);
-}
-
-func chanclose(ch *byte) {
-	runtime·chanclose((Hchan*)ch);
-}
-
-func chanlen(ch *byte) (r int32) {
-	r = runtime·chanlen((Hchan*)ch);
-}
-
-func chancap(ch *byte) (r int32) {
-	r = runtime·chancap((Hchan*)ch);
-}
-
-
-/*
- * Go wrappers around the functions in iface.c
- */
-
-func setiface(typ *byte, x *byte, ret *byte) {
-	InterfaceType *t;
-
-	t = (InterfaceType*)gettype(typ);
-	if(t->mhdr.len == 0) {
-		// already an empty interface
-		*(Eface*)ret = *(Eface*)x;
-		return;
-	}
-	if(((Eface*)x)->type == nil) {
-		// can assign nil to any interface
-		((Iface*)ret)->tab = nil;
-		((Iface*)ret)->data = nil;
-		return;
-	}
-	runtime·ifaceE2I((InterfaceType*)gettype(typ), *(Eface*)x, (Iface*)ret);
-}
diff --git a/src/pkg/runtime/runtime.h b/src/pkg/runtime/runtime.h
index 6cf2685fde..fd84396131 100644
--- a/src/pkg/runtime/runtime.h
+++ b/src/pkg/runtime/runtime.h
@@ -580,7 +580,6 @@ int32	runtime·gomaxprocsfunc(int32 n);
 
 void	runtime·mapassign(Hmap*, byte*, byte*);
 void	runtime·mapaccess(Hmap*, byte*, byte*, bool*);
-struct hash_iter*	runtime·newmapiterinit(Hmap*);
 void	runtime·mapiternext(struct hash_iter*);
 bool	runtime·mapiterkey(struct hash_iter*, void*);
 void	runtime·mapiterkeyvalue(struct hash_iter*, void*, void*);
@@ -589,7 +588,6 @@ Hmap*	runtime·makemap_c(Type*, Type*, int64);
 Hchan*	runtime·makechan_c(Type*, int64);
 void	runtime·chansend(Hchan*, void*, bool*);
 void	runtime·chanrecv(Hchan*, void*, bool*, bool*);
-void	runtime·chanclose(Hchan*);
 int32	runtime·chanlen(Hchan*);
 int32	runtime·chancap(Hchan*);
 
