commit 0403181a880d25427d35316fcf0ea9a89fc9e40d
Author: Alex Brainman <alex.brainman@gmail.com>
Date:   Wed Jul 23 12:36:34 2014 +1000

    syscall: allow for mksyscall_windows.go to be used outside of syscall
    
    Fixes #8398.
    
    LGTM=chines
    R=golang-codereviews, chines, josharian
    CC=golang-codereviews
    https://golang.org/cl/114140043
---
 src/pkg/syscall/mksyscall_windows.go | 57 ++++++++++++++++++++++++++++--------
 1 file changed, 45 insertions(+), 12 deletions(-)

diff --git a/src/pkg/syscall/mksyscall_windows.go b/src/pkg/syscall/mksyscall_windows.go
index 4225588de7..3b483ec87a 100644
--- a/src/pkg/syscall/mksyscall_windows.go
+++ b/src/pkg/syscall/mksyscall_windows.go
@@ -47,6 +47,8 @@ import (
 	"errors"
 	"flag"
 	"fmt"
+	"go/parser"
+	"go/token"
 	"io"
 	"log"
 	"os"
@@ -61,6 +63,19 @@ func trim(s string) string {
 	return strings.Trim(s, " \t")
 }
 
+var packageName string
+
+func packagename() string {
+	return packageName
+}
+
+func syscalldot() string {
+	if packageName == "syscall" {
+		return ""
+	}
+	return "syscall."
+}
+
 // Param is function parameter
 type Param struct {
 	Name      string
@@ -243,20 +258,20 @@ func (r *Rets) useLongHandleErrorCode(retvar string) string {
 		if e1 != 0 {
 			err = error(e1)
 		} else {
-			err = EINVAL
+			err = %sEINVAL
 		}
 	}`
 	cond := retvar + " == 0"
 	if r.FailCond != "" {
 		cond = strings.Replace(r.FailCond, "failretval", retvar, 1)
 	}
-	return fmt.Sprintf(code, cond)
+	return fmt.Sprintf(code, cond, syscalldot())
 }
 
 // SetErrorCode returns source code that sets return parameters.
 func (r *Rets) SetErrorCode() string {
 	const code = `if r0 != 0 {
-		%s = Errno(r0)
+		%s = %sErrno(r0)
 	}`
 	if r.Name == "" && !r.ReturnsError {
 		return ""
@@ -265,7 +280,7 @@ func (r *Rets) SetErrorCode() string {
 		return r.useLongHandleErrorCode("r1")
 	}
 	if r.Type == "error" {
-		return fmt.Sprintf(code, r.Name)
+		return fmt.Sprintf(code, r.Name, syscalldot())
 	}
 	s := ""
 	if r.Type[0] == '*' {
@@ -475,9 +490,9 @@ func (f *Fn) SyscallParamCount() int {
 func (f *Fn) Syscall() string {
 	c := f.SyscallParamCount()
 	if c == 3 {
-		return "Syscall"
+		return syscalldot() + "Syscall"
 	}
-	return "Syscall" + strconv.Itoa(c)
+	return syscalldot() + "Syscall" + strconv.Itoa(c)
 }
 
 // SyscallParamList returns source code for SyscallX parameters for function f.
@@ -502,9 +517,9 @@ func (f *Fn) IsUTF16() bool {
 // StrconvFunc returns name of Go string to OS string function for f.
 func (f *Fn) StrconvFunc() string {
 	if f.IsUTF16() {
-		return "UTF16PtrFromString"
+		return syscalldot() + "UTF16PtrFromString"
 	}
-	return "BytePtrFromString"
+	return syscalldot() + "BytePtrFromString"
 }
 
 // StrconvType returns Go type name used for OS string for f.
@@ -582,12 +597,29 @@ func (src *Source) ParseFile(path string) error {
 		return err
 	}
 	src.Files = append(src.Files, path)
+
+	// get package name
+	fset := token.NewFileSet()
+	_, err = file.Seek(0, 0)
+	if err != nil {
+		return err
+	}
+	pkg, err := parser.ParseFile(fset, "", file, parser.PackageClauseOnly)
+	if err != nil {
+		return err
+	}
+	packageName = pkg.Name.Name
+
 	return nil
 }
 
 // Generate output source file from a source set src.
 func (src *Source) Generate(w io.Writer) error {
-	t := template.Must(template.New("main").Parse(srcTemplate))
+	funcMap := template.FuncMap{
+		"syscalldot":  syscalldot,
+		"packagename": packagename,
+	}
+	t := template.Must(template.New("main").Funcs(funcMap).Parse(srcTemplate))
 	err := t.Execute(w, src)
 	if err != nil {
 		return errors.New("Failed to execute template: " + err.Error())
@@ -623,9 +655,10 @@ const srcTemplate = `
 {{define "main"}}// go build mksyscall_windows.go && ./mksyscall_windows{{range .Files}} {{.}}{{end}}
 // MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
 
-package syscall
+package {{packagename}}
 
-import "unsafe"
+import "unsafe"{{if syscalldot}}
+import "syscall"{{end}}
 
 var (
 {{template "dlls" .}}
@@ -635,7 +668,7 @@ var (
 
 {{/* help functions */}}
 
-{{define "dlls"}}{{range .DLLs}}	mod{{.}} = NewLazyDLL("{{.}}.dll")
+{{define "dlls"}}{{range .DLLs}}	mod{{.}} = {{syscalldot}}NewLazyDLL("{{.}}.dll")
 {{end}}{{end}}
 
 {{define "funcnames"}}{{range .Funcs}}	proc{{.DLLFuncName}} = mod{{.DLLName}}.NewProc("{{.DLLFuncName}}")
