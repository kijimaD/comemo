commit cf75c86cdf16b3c100068e102235c94316e8b92e
Author: Alex Brainman <alex.brainman@gmail.com>
Date:   Fri Feb 11 10:15:51 2011 +1100

    syscall: change windows apis with bool return value to return errno instead
    
    This change is to make these apis similar to their unix counterparts.
    
    R=rsc
    CC=golang-dev
    https://golang.org/cl/4185042
---
 src/pkg/crypto/rand/rand_windows.go     |   8 +-
 src/pkg/exp/wingui/gui.go               |   5 +-
 src/pkg/exp/wingui/winapi.go            |  10 +-
 src/pkg/exp/wingui/zwinapi.go           |  29 ++---
 src/pkg/net/fd_windows.go               |   4 +-
 src/pkg/os/env_windows.go               |   4 +-
 src/pkg/os/exec_windows.go              |   6 +-
 src/pkg/os/file_windows.go              |   9 +-
 src/pkg/syscall/exec_windows.go         |  13 +-
 src/pkg/syscall/syscall_windows.go      | 128 +++++++++----------
 src/pkg/syscall/zsyscall_windows_386.go | 210 ++++++++++++++------------------
 11 files changed, 192 insertions(+), 234 deletions(-)

diff --git a/src/pkg/crypto/rand/rand_windows.go b/src/pkg/crypto/rand/rand_windows.go
index 4b2b7a26f3..281d6dc6aa 100755
--- a/src/pkg/crypto/rand/rand_windows.go
+++ b/src/pkg/crypto/rand/rand_windows.go
@@ -28,15 +28,15 @@ func (r *rngReader) Read(b []byte) (n int, err os.Error) {
 	if r.prov == 0 {
 		const provType = syscall.PROV_RSA_FULL
 		const flags = syscall.CRYPT_VERIFYCONTEXT | syscall.CRYPT_SILENT
-		ok, errno := syscall.CryptAcquireContext(&r.prov, nil, nil, provType, flags)
-		if !ok {
+		errno := syscall.CryptAcquireContext(&r.prov, nil, nil, provType, flags)
+		if errno != 0 {
 			r.mu.Unlock()
 			return 0, os.NewSyscallError("CryptAcquireContext", errno)
 		}
 	}
 	r.mu.Unlock()
-	ok, errno := syscall.CryptGenRandom(r.prov, uint32(len(b)), &b[0])
-	if !ok {
+	errno := syscall.CryptGenRandom(r.prov, uint32(len(b)), &b[0])
+	if errno != 0 {
 		return 0, os.NewSyscallError("CryptGenRandom", errno)
 	}
 	return len(b), nil
diff --git a/src/pkg/exp/wingui/gui.go b/src/pkg/exp/wingui/gui.go
index 41ee5b7895..cf392934c5 100644
--- a/src/pkg/exp/wingui/gui.go
+++ b/src/pkg/exp/wingui/gui.go
@@ -51,7 +51,8 @@ func WndProc(hwnd, msg uint32, wparam, lparam int32) uintptr {
 	case WM_COMMAND:
 		switch uint32(lparam) {
 		case bh:
-			if ok, e := PostMessage(hwnd, WM_CLOSE, 0, 0); !ok {
+			e := PostMessage(hwnd, WM_CLOSE, 0, 0)
+			if e != 0 {
 				abortErrNo("PostMessage", e)
 			}
 		default:
@@ -125,7 +126,7 @@ func rungui() int {
 	ShowWindow(wh, SW_SHOWDEFAULT)
 
 	// UpdateWindow
-	if _, e := UpdateWindow(wh); e != 0 {
+	if e := UpdateWindow(wh); e != 0 {
 		abortErrNo("UpdateWindow", e)
 	}
 
diff --git a/src/pkg/exp/wingui/winapi.go b/src/pkg/exp/wingui/winapi.go
index 2f480ec9e5..c96f452999 100644
--- a/src/pkg/exp/wingui/winapi.go
+++ b/src/pkg/exp/wingui/winapi.go
@@ -130,18 +130,18 @@ var (
 //sys	RegisterClassEx(wndclass *Wndclassex) (atom uint16, errno int) = user32.RegisterClassExW
 //sys	CreateWindowEx(exstyle uint32, classname *uint16, windowname *uint16, style uint32, x int32, y int32, width int32, height int32, wndparent uint32, menu uint32, instance uint32, param uintptr) (hwnd uint32, errno int) = user32.CreateWindowExW
 //sys	DefWindowProc(hwnd uint32, msg uint32, wparam int32, lparam int32) (lresult int32) = user32.DefWindowProcW
-//sys	DestroyWindow(hwnd uint32) (ok bool, errno int) = user32.DestroyWindow
+//sys	DestroyWindow(hwnd uint32) (errno int) = user32.DestroyWindow
 //sys	PostQuitMessage(exitcode int32) = user32.PostQuitMessage
-//sys	ShowWindow(hwnd uint32, cmdshow int32) (ok bool) = user32.ShowWindow
-//sys	UpdateWindow(hwnd uint32) (ok bool, errno int) = user32.UpdateWindow
+//sys	ShowWindow(hwnd uint32, cmdshow int32) (wasvisible bool) = user32.ShowWindow
+//sys	UpdateWindow(hwnd uint32) (errno int) = user32.UpdateWindow
 //sys	GetMessage(msg *Msg, hwnd uint32, MsgFilterMin uint32, MsgFilterMax uint32) (ret int32, errno int) [failretval==-1] = user32.GetMessageW
-//sys	TranslateMessage(msg *Msg) (ok bool) = user32.TranslateMessage
+//sys	TranslateMessage(msg *Msg) (done bool) = user32.TranslateMessage
 //sys	DispatchMessage(msg *Msg) (ret int32) = user32.DispatchMessageW
 //sys	LoadIcon(instance uint32, iconname *uint16) (icon uint32, errno int) = user32.LoadIconW
 //sys	LoadCursor(instance uint32, cursorname *uint16) (cursor uint32, errno int) = user32.LoadCursorW
 //sys	SetCursor(cursor uint32) (precursor uint32, errno int) = user32.SetCursor
 //sys	SendMessage(hwnd uint32, msg uint32, wparam int32, lparam int32) (lresult int32) = user32.SendMessageW
-//sys	PostMessage(hwnd uint32, msg uint32, wparam int32, lparam int32) (ok bool, errno int) = user32.PostMessageW
+//sys	PostMessage(hwnd uint32, msg uint32, wparam int32, lparam int32) (errno int) = user32.PostMessageW
 
 func MakeIntResource(id uint16) *uint16 {
 	return (*uint16)(unsafe.Pointer(uintptr(id)))
diff --git a/src/pkg/exp/wingui/zwinapi.go b/src/pkg/exp/wingui/zwinapi.go
index 324bf1773e..60aaac6cf1 100644
--- a/src/pkg/exp/wingui/zwinapi.go
+++ b/src/pkg/exp/wingui/zwinapi.go
@@ -79,10 +79,9 @@ func DefWindowProc(hwnd uint32, msg uint32, wparam int32, lparam int32) (lresult
 	return
 }
 
-func DestroyWindow(hwnd uint32) (ok bool, errno int) {
-	r0, _, e1 := syscall.Syscall(procDestroyWindow, 1, uintptr(hwnd), 0, 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func DestroyWindow(hwnd uint32) (errno int) {
+	r1, _, e1 := syscall.Syscall(procDestroyWindow, 1, uintptr(hwnd), 0, 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -99,16 +98,15 @@ func PostQuitMessage(exitcode int32) {
 	return
 }
 
-func ShowWindow(hwnd uint32, cmdshow int32) (ok bool) {
+func ShowWindow(hwnd uint32, cmdshow int32) (wasvisible bool) {
 	r0, _, _ := syscall.Syscall(procShowWindow, 2, uintptr(hwnd), uintptr(cmdshow), 0)
-	ok = bool(r0 != 0)
+	wasvisible = bool(r0 != 0)
 	return
 }
 
-func UpdateWindow(hwnd uint32) (ok bool, errno int) {
-	r0, _, e1 := syscall.Syscall(procUpdateWindow, 1, uintptr(hwnd), 0, 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func UpdateWindow(hwnd uint32) (errno int) {
+	r1, _, e1 := syscall.Syscall(procUpdateWindow, 1, uintptr(hwnd), 0, 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -135,9 +133,9 @@ func GetMessage(msg *Msg, hwnd uint32, MsgFilterMin uint32, MsgFilterMax uint32)
 	return
 }
 
-func TranslateMessage(msg *Msg) (ok bool) {
+func TranslateMessage(msg *Msg) (done bool) {
 	r0, _, _ := syscall.Syscall(procTranslateMessage, 1, uintptr(unsafe.Pointer(msg)), 0, 0)
-	ok = bool(r0 != 0)
+	done = bool(r0 != 0)
 	return
 }
 
@@ -198,10 +196,9 @@ func SendMessage(hwnd uint32, msg uint32, wparam int32, lparam int32) (lresult i
 	return
 }
 
-func PostMessage(hwnd uint32, msg uint32, wparam int32, lparam int32) (ok bool, errno int) {
-	r0, _, e1 := syscall.Syscall6(procPostMessageW, 4, uintptr(hwnd), uintptr(msg), uintptr(wparam), uintptr(lparam), 0, 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func PostMessage(hwnd uint32, msg uint32, wparam int32, lparam int32) (errno int) {
+	r1, _, e1 := syscall.Syscall6(procPostMessageW, 4, uintptr(hwnd), uintptr(msg), uintptr(wparam), uintptr(lparam), 0, 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
diff --git a/src/pkg/net/fd_windows.go b/src/pkg/net/fd_windows.go
index 9b91eb398c..d9c83831d3 100644
--- a/src/pkg/net/fd_windows.go
+++ b/src/pkg/net/fd_windows.go
@@ -85,7 +85,7 @@ type ioPacket struct {
 func (s *pollServer) getCompletedIO() (ov *syscall.Overlapped, result *ioResult, err os.Error) {
 	var r ioResult
 	var o *syscall.Overlapped
-	_, e := syscall.GetQueuedCompletionStatus(s.iocp, &r.qty, &r.key, &o, syscall.INFINITE)
+	e := syscall.GetQueuedCompletionStatus(s.iocp, &r.qty, &r.key, &o, syscall.INFINITE)
 	switch {
 	case e == 0:
 		// Dequeued successfully completed io packet.
@@ -270,7 +270,7 @@ func timeoutIO() {
 		case writeto:
 			e = syscall.WSASendto(uint32(o.fd.sysfd), o.pckt.w, 1, o.done, 0, *o.sa, &o.pckt.o, nil)
 		case cancel:
-			_, e = syscall.CancelIo(uint32(o.fd.sysfd))
+			e = syscall.CancelIo(uint32(o.fd.sysfd))
 		}
 		o.c <- e
 	}
diff --git a/src/pkg/os/env_windows.go b/src/pkg/os/env_windows.go
index d2b159dfba..a45d79be32 100644
--- a/src/pkg/os/env_windows.go
+++ b/src/pkg/os/env_windows.go
@@ -50,8 +50,8 @@ func Setenv(key, value string) Error {
 	if len(value) > 0 {
 		v = syscall.StringToUTF16Ptr(value)
 	}
-	ok, e := syscall.SetEnvironmentVariable(syscall.StringToUTF16Ptr(key), v)
-	if !ok {
+	e := syscall.SetEnvironmentVariable(syscall.StringToUTF16Ptr(key), v)
+	if e != 0 {
 		return NewSyscallError("SetEnvironmentVariable", e)
 	}
 	return nil
diff --git a/src/pkg/os/exec_windows.go b/src/pkg/os/exec_windows.go
index 73c0104caf..ae8ffeab2e 100644
--- a/src/pkg/os/exec_windows.go
+++ b/src/pkg/os/exec_windows.go
@@ -20,7 +20,8 @@ func (p *Process) Wait(options int) (w *Waitmsg, err Error) {
 		return nil, ErrorString("os: unexpected result from WaitForSingleObject")
 	}
 	var ec uint32
-	if ok, e := syscall.GetExitCodeProcess(uint32(p.handle), &ec); !ok {
+	e = syscall.GetExitCodeProcess(uint32(p.handle), &ec)
+	if e != 0 {
 		return nil, NewSyscallError("GetExitCodeProcess", e)
 	}
 	return &Waitmsg{p.Pid, syscall.WaitStatus{s, ec}, new(syscall.Rusage)}, nil
@@ -30,7 +31,8 @@ func (p *Process) Release() Error {
 	if p.handle == -1 {
 		return EINVAL
 	}
-	if ok, e := syscall.CloseHandle(int32(p.handle)); !ok {
+	e := syscall.CloseHandle(int32(p.handle))
+	if e != 0 {
 		return NewSyscallError("CloseHandle", e)
 	}
 	p.handle = -1
diff --git a/src/pkg/os/file_windows.go b/src/pkg/os/file_windows.go
index bf710bb671..d14c38e17f 100644
--- a/src/pkg/os/file_windows.go
+++ b/src/pkg/os/file_windows.go
@@ -83,9 +83,9 @@ func (file *File) Close() Error {
 	}
 	var e int
 	if file.isdir() {
-		_, e = syscall.FindClose(int32(file.fd))
+		e = syscall.FindClose(int32(file.fd))
 	} else {
-		_, e = syscall.CloseHandle(int32(file.fd))
+		e = syscall.CloseHandle(int32(file.fd))
 	}
 	var err Error
 	if e != 0 {
@@ -100,7 +100,8 @@ func (file *File) Close() Error {
 
 func (file *File) statFile(name string) (fi *FileInfo, err Error) {
 	var stat syscall.ByHandleFileInformation
-	if ok, e := syscall.GetFileInformationByHandle(int32(file.fd), &stat); !ok {
+	e := syscall.GetFileInformationByHandle(int32(file.fd), &stat)
+	if e != 0 {
 		return nil, &PathError{"stat", file.name, Errno(e)}
 	}
 	return fileInfoFromByHandleInfo(new(FileInfo), file.name, &stat), nil
@@ -142,7 +143,7 @@ func (file *File) Readdir(count int) (fi []FileInfo, err Error) {
 		if di.usefirststat {
 			di.usefirststat = false
 		} else {
-			_, e := syscall.FindNextFile(int32(file.fd), &di.stat.Windata)
+			e := syscall.FindNextFile(int32(file.fd), &di.stat.Windata)
 			if e != 0 {
 				if e == syscall.ERROR_NO_MORE_FILES {
 					break
diff --git a/src/pkg/syscall/exec_windows.go b/src/pkg/syscall/exec_windows.go
index 1ce2655066..7256c3ae3f 100644
--- a/src/pkg/syscall/exec_windows.go
+++ b/src/pkg/syscall/exec_windows.go
@@ -148,19 +148,22 @@ func StartProcess(argv0 string, argv []string, envv []string, dir string, fd []i
 
 	var currentProc, _ = GetCurrentProcess()
 	if len(fd) > 0 && fd[0] > 0 {
-		if ok, err := DuplicateHandle(currentProc, int32(fd[0]), currentProc, &startupInfo.StdInput, 0, true, DUPLICATE_SAME_ACCESS); !ok {
+		err := DuplicateHandle(currentProc, int32(fd[0]), currentProc, &startupInfo.StdInput, 0, true, DUPLICATE_SAME_ACCESS)
+		if err != 0 {
 			return 0, 0, err
 		}
 		defer CloseHandle(int32(startupInfo.StdInput))
 	}
 	if len(fd) > 1 && fd[1] > 0 {
-		if ok, err := DuplicateHandle(currentProc, int32(fd[1]), currentProc, &startupInfo.StdOutput, 0, true, DUPLICATE_SAME_ACCESS); !ok {
+		err := DuplicateHandle(currentProc, int32(fd[1]), currentProc, &startupInfo.StdOutput, 0, true, DUPLICATE_SAME_ACCESS)
+		if err != 0 {
 			return 0, 0, err
 		}
 		defer CloseHandle(int32(startupInfo.StdOutput))
 	}
 	if len(fd) > 2 && fd[2] > 0 {
-		if ok, err := DuplicateHandle(currentProc, int32(fd[2]), currentProc, &startupInfo.StdErr, 0, true, DUPLICATE_SAME_ACCESS); !ok {
+		err := DuplicateHandle(currentProc, int32(fd[2]), currentProc, &startupInfo.StdErr, 0, true, DUPLICATE_SAME_ACCESS)
+		if err != 0 {
 			return 0, 0, err
 		}
 		defer CloseHandle(int32(startupInfo.StdErr))
@@ -170,7 +173,7 @@ func StartProcess(argv0 string, argv []string, envv []string, dir string, fd []i
 	}
 	// argv0 must not be longer then 256 chars
 	// but the entire cmd line can have up to 32k chars (msdn)
-	ok, err := CreateProcess(
+	err = CreateProcess(
 		nil,
 		StringToUTF16Ptr(escapeAddQuotes(argv0)+" "+stringJoin(argv[1:], " ", escapeAddQuotes)),
 		nil,  //ptr to struct lpProcessAttributes
@@ -182,7 +185,7 @@ func StartProcess(argv0 string, argv []string, envv []string, dir string, fd []i
 		startupInfo,
 		processInfo)
 
-	if ok {
+	if err != 0 {
 		pid = int(processInfo.ProcessId)
 		handle = int(processInfo.Process)
 		CloseHandle(processInfo.Thread)
diff --git a/src/pkg/syscall/syscall_windows.go b/src/pkg/syscall/syscall_windows.go
index 93e1115123..0cd89d426d 100644
--- a/src/pkg/syscall/syscall_windows.go
+++ b/src/pkg/syscall/syscall_windows.go
@@ -106,59 +106,59 @@ func NewCallback(fn interface{}) uintptr
 
 //sys	GetLastError() (lasterrno int)
 //sys	LoadLibrary(libname string) (handle uint32, errno int) = LoadLibraryW
-//sys	FreeLibrary(handle uint32) (ok bool, errno int)
+//sys	FreeLibrary(handle uint32) (errno int)
 //sys	GetProcAddress(module uint32, procname string) (proc uint32, errno int)
 //sys	GetVersion() (ver uint32, errno int)
 //sys	FormatMessage(flags uint32, msgsrc uint32, msgid uint32, langid uint32, buf []uint16, args *byte) (n uint32, errno int) = FormatMessageW
 //sys	ExitProcess(exitcode uint32)
 //sys	CreateFile(name *uint16, access uint32, mode uint32, sa *SecurityAttributes, createmode uint32, attrs uint32, templatefile int32) (handle int32, errno int) [failretval==-1] = CreateFileW
-//sys	ReadFile(handle int32, buf []byte, done *uint32, overlapped *Overlapped) (ok bool, errno int)
-//sys	WriteFile(handle int32, buf []byte, done *uint32, overlapped *Overlapped) (ok bool, errno int)
+//sys	ReadFile(handle int32, buf []byte, done *uint32, overlapped *Overlapped) (errno int)
+//sys	WriteFile(handle int32, buf []byte, done *uint32, overlapped *Overlapped) (errno int)
 //sys	SetFilePointer(handle int32, lowoffset int32, highoffsetptr *int32, whence uint32) (newlowoffset uint32, errno int) [failretval==0xffffffff]
-//sys	CloseHandle(handle int32) (ok bool, errno int)
+//sys	CloseHandle(handle int32) (errno int)
 //sys	GetStdHandle(stdhandle int32) (handle int32, errno int) [failretval==-1]
 //sys	FindFirstFile(name *uint16, data *Win32finddata) (handle int32, errno int) [failretval==-1] = FindFirstFileW
-//sys	FindNextFile(handle int32, data *Win32finddata) (ok bool, errno int) = FindNextFileW
-//sys	FindClose(handle int32) (ok bool, errno int)
-//sys	GetFileInformationByHandle(handle int32, data *ByHandleFileInformation) (ok bool, errno int)
+//sys	FindNextFile(handle int32, data *Win32finddata) (errno int) = FindNextFileW
+//sys	FindClose(handle int32) (errno int)
+//sys	GetFileInformationByHandle(handle int32, data *ByHandleFileInformation) (errno int)
 //sys	GetCurrentDirectory(buflen uint32, buf *uint16) (n uint32, errno int) = GetCurrentDirectoryW
-//sys	SetCurrentDirectory(path *uint16) (ok bool, errno int) = SetCurrentDirectoryW
-//sys	CreateDirectory(path *uint16, sa *SecurityAttributes) (ok bool, errno int) = CreateDirectoryW
-//sys	RemoveDirectory(path *uint16) (ok bool, errno int) = RemoveDirectoryW
-//sys	DeleteFile(path *uint16) (ok bool, errno int) = DeleteFileW
-//sys	MoveFile(from *uint16, to *uint16) (ok bool, errno int) = MoveFileW
-//sys	GetComputerName(buf *uint16, n *uint32) (ok bool, errno int) = GetComputerNameW
-//sys	SetEndOfFile(handle int32) (ok bool, errno int)
+//sys	SetCurrentDirectory(path *uint16) (errno int) = SetCurrentDirectoryW
+//sys	CreateDirectory(path *uint16, sa *SecurityAttributes) (errno int) = CreateDirectoryW
+//sys	RemoveDirectory(path *uint16) (errno int) = RemoveDirectoryW
+//sys	DeleteFile(path *uint16) (errno int) = DeleteFileW
+//sys	MoveFile(from *uint16, to *uint16) (errno int) = MoveFileW
+//sys	GetComputerName(buf *uint16, n *uint32) (errno int) = GetComputerNameW
+//sys	SetEndOfFile(handle int32) (errno int)
 //sys	GetSystemTimeAsFileTime(time *Filetime)
 //sys	sleep(msec uint32) = Sleep
 //sys	GetTimeZoneInformation(tzi *Timezoneinformation) (rc uint32, errno int) [failretval==0xffffffff]
 //sys	CreateIoCompletionPort(filehandle int32, cphandle int32, key uint32, threadcnt uint32) (handle int32, errno int)
-//sys	GetQueuedCompletionStatus(cphandle int32, qty *uint32, key *uint32, overlapped **Overlapped, timeout uint32) (ok bool, errno int)
-//sys	CancelIo(s uint32) (ok bool, errno int)
-//sys	CreateProcess(appName *int16, commandLine *uint16, procSecurity *int16, threadSecurity *int16, inheritHandles bool, creationFlags uint32, env *uint16, currentDir *uint16, startupInfo *StartupInfo, outProcInfo *ProcessInformation)  (ok bool, errno int) = CreateProcessW
+//sys	GetQueuedCompletionStatus(cphandle int32, qty *uint32, key *uint32, overlapped **Overlapped, timeout uint32) (errno int)
+//sys	CancelIo(s uint32) (errno int)
+//sys	CreateProcess(appName *int16, commandLine *uint16, procSecurity *int16, threadSecurity *int16, inheritHandles bool, creationFlags uint32, env *uint16, currentDir *uint16, startupInfo *StartupInfo, outProcInfo *ProcessInformation) (errno int) = CreateProcessW
 //sys	OpenProcess(da uint32, inheritHandle bool, pid uint32) (handle uint32, errno int)
-//sys	GetExitCodeProcess(handle uint32, exitcode *uint32) (ok bool, errno int)
-//sys	GetStartupInfo(startupInfo *StartupInfo)  (ok bool, errno int) = GetStartupInfoW
+//sys	GetExitCodeProcess(handle uint32, exitcode *uint32) (errno int)
+//sys	GetStartupInfo(startupInfo *StartupInfo) (errno int) = GetStartupInfoW
 //sys	GetCurrentProcess() (pseudoHandle int32, errno int)
-//sys	DuplicateHandle(hSourceProcessHandle int32, hSourceHandle int32, hTargetProcessHandle int32, lpTargetHandle *int32, dwDesiredAccess uint32, bInheritHandle bool, dwOptions uint32) (ok bool, errno int)
+//sys	DuplicateHandle(hSourceProcessHandle int32, hSourceHandle int32, hTargetProcessHandle int32, lpTargetHandle *int32, dwDesiredAccess uint32, bInheritHandle bool, dwOptions uint32) (errno int)
 //sys	WaitForSingleObject(handle int32, waitMilliseconds uint32) (event uint32, errno int) [failretval==0xffffffff]
 //sys	GetTempPath(buflen uint32, buf *uint16) (n uint32, errno int) = GetTempPathW
-//sys	CreatePipe(readhandle *uint32, writehandle *uint32, sa *SecurityAttributes, size uint32) (ok bool, errno int)
+//sys	CreatePipe(readhandle *uint32, writehandle *uint32, sa *SecurityAttributes, size uint32) (errno int)
 //sys	GetFileType(filehandle uint32) (n uint32, errno int)
-//sys	CryptAcquireContext(provhandle *uint32, container *uint16, provider *uint16, provtype uint32, flags uint32) (ok bool, errno int) = advapi32.CryptAcquireContextW
-//sys	CryptReleaseContext(provhandle uint32, flags uint32) (ok bool, errno int) = advapi32.CryptReleaseContext
-//sys	CryptGenRandom(provhandle uint32, buflen uint32, buf *byte) (ok bool, errno int) = advapi32.CryptGenRandom
+//sys	CryptAcquireContext(provhandle *uint32, container *uint16, provider *uint16, provtype uint32, flags uint32) (errno int) = advapi32.CryptAcquireContextW
+//sys	CryptReleaseContext(provhandle uint32, flags uint32) (errno int) = advapi32.CryptReleaseContext
+//sys	CryptGenRandom(provhandle uint32, buflen uint32, buf *byte) (errno int) = advapi32.CryptGenRandom
 //sys	GetEnvironmentStrings() (envs *uint16, errno int) [failretval==nil] = kernel32.GetEnvironmentStringsW
-//sys	FreeEnvironmentStrings(envs *uint16) (ok bool, errno int) = kernel32.FreeEnvironmentStringsW
+//sys	FreeEnvironmentStrings(envs *uint16) (errno int) = kernel32.FreeEnvironmentStringsW
 //sys	GetEnvironmentVariable(name *uint16, buffer *uint16, size uint32) (n uint32, errno int) = kernel32.GetEnvironmentVariableW
-//sys	SetEnvironmentVariable(name *uint16, value *uint16) (ok bool, errno int) = kernel32.SetEnvironmentVariableW
-//sys	SetFileTime(handle int32, ctime *Filetime, atime *Filetime, wtime *Filetime) (ok bool, errno int)
+//sys	SetEnvironmentVariable(name *uint16, value *uint16) (errno int) = kernel32.SetEnvironmentVariableW
+//sys	SetFileTime(handle int32, ctime *Filetime, atime *Filetime, wtime *Filetime) (errno int)
 //sys	GetFileAttributes(name *uint16) (attrs uint32, errno int) [failretval==INVALID_FILE_ATTRIBUTES] = kernel32.GetFileAttributesW
 //sys	GetCommandLine() (cmd *uint16) = kernel32.GetCommandLineW
 //sys	CommandLineToArgv(cmd *uint16, argc *int32) (argv *[8192]*[8192]uint16, errno int) [failretval==nil] = shell32.CommandLineToArgvW
 //sys	LocalFree(hmem uint32) (handle uint32, errno int) [failretval!=0]
-//sys	SetHandleInformation(handle int32, mask uint32, flags uint32) (ok bool, errno int)
-//sys	FlushFileBuffers(handle int32) (ok bool, errno int)
+//sys	SetHandleInformation(handle int32, mask uint32, flags uint32) (errno int)
+//sys	FlushFileBuffers(handle int32) (errno int)
 
 // syscall interface implementation for other packages
 
@@ -234,7 +234,8 @@ func Open(path string, mode int, perm uint32) (fd int, errno int) {
 
 func Read(fd int, p []byte) (n int, errno int) {
 	var done uint32
-	if ok, e := ReadFile(int32(fd), p, &done, nil); !ok {
+	e := ReadFile(int32(fd), p, &done, nil)
+	if e != 0 {
 		if e == ERROR_BROKEN_PIPE {
 			// NOTE(brainman): work around ERROR_BROKEN_PIPE is returned on reading EOF from stdin
 			return 0, 0
@@ -258,7 +259,8 @@ func Pread(fd int, p []byte, offset int64) (n int, errno int) {
 	o.OffsetHigh = uint32(offset >> 32)
 	o.Offset = uint32(offset)
 	var done uint32
-	if ok, e := ReadFile(int32(fd), p, &done, &o); !ok {
+	e = ReadFile(int32(fd), p, &done, &o)
+	if e != 0 {
 		return 0, e
 	}
 	return int(done), 0
@@ -266,7 +268,8 @@ func Pread(fd int, p []byte, offset int64) (n int, errno int) {
 
 func Write(fd int, p []byte) (n int, errno int) {
 	var done uint32
-	if ok, e := WriteFile(int32(fd), p, &done, nil); !ok {
+	e := WriteFile(int32(fd), p, &done, nil)
+	if e != 0 {
 		return 0, e
 	}
 	return int(done), 0
@@ -282,7 +285,8 @@ func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
 	o.OffsetHigh = uint32(offset >> 32)
 	o.Offset = uint32(offset)
 	var done uint32
-	if ok, e := WriteFile(int32(fd), p, &done, &o); !ok {
+	e = WriteFile(int32(fd), p, &done, &o)
+	if e != 0 {
 		return 0, e
 	}
 	return int(done), 0
@@ -313,10 +317,7 @@ func Seek(fd int, offset int64, whence int) (newoffset int64, errno int) {
 }
 
 func Close(fd int) (errno int) {
-	if ok, e := CloseHandle(int32(fd)); !ok {
-		return e
-	}
-	return 0
+	return CloseHandle(int32(fd))
 }
 
 var (
@@ -375,46 +376,32 @@ func Getwd() (wd string, errno int) {
 }
 
 func Chdir(path string) (errno int) {
-	if ok, e := SetCurrentDirectory(&StringToUTF16(path)[0]); !ok {
-		return e
-	}
-	return 0
+	return SetCurrentDirectory(&StringToUTF16(path)[0])
 }
 
 func Mkdir(path string, mode uint32) (errno int) {
-	if ok, e := CreateDirectory(&StringToUTF16(path)[0], nil); !ok {
-		return e
-	}
-	return 0
+	return CreateDirectory(&StringToUTF16(path)[0], nil)
 }
 
 func Rmdir(path string) (errno int) {
-	if ok, e := RemoveDirectory(&StringToUTF16(path)[0]); !ok {
-		return e
-	}
-	return 0
+	return RemoveDirectory(&StringToUTF16(path)[0])
 }
 
 func Unlink(path string) (errno int) {
-	if ok, e := DeleteFile(&StringToUTF16(path)[0]); !ok {
-		return e
-	}
-	return 0
+	return DeleteFile(&StringToUTF16(path)[0])
 }
 
 func Rename(oldpath, newpath string) (errno int) {
 	from := &StringToUTF16(oldpath)[0]
 	to := &StringToUTF16(newpath)[0]
-	if ok, e := MoveFile(from, to); !ok {
-		return e
-	}
-	return 0
+	return MoveFile(from, to)
 }
 
 func ComputerName() (name string, errno int) {
 	var n uint32 = MAX_COMPUTERNAME_LENGTH + 1
 	b := make([]uint16, n)
-	if ok, e := GetComputerName(&b[0], &n); !ok {
+	e := GetComputerName(&b[0], &n)
+	if e != 0 {
 		return "", e
 	}
 	return string(utf16.Decode(b[0:n])), 0
@@ -426,10 +413,12 @@ func Ftruncate(fd int, length int64) (errno int) {
 		return e
 	}
 	defer Seek(fd, curoffset, 0)
-	if _, e := Seek(fd, length, 0); e != 0 {
+	_, e = Seek(fd, length, 0)
+	if e != 0 {
 		return e
 	}
-	if _, e := SetEndOfFile(int32(fd)); e != 0 {
+	e = SetEndOfFile(int32(fd))
+	if e != 0 {
 		return e
 	}
 	return 0
@@ -452,8 +441,9 @@ func Pipe(p []int) (errno int) {
 		return EINVAL
 	}
 	var r, w uint32
-	if ok, errno := CreatePipe(&r, &w, makeInheritSa(), 0); !ok {
-		return errno
+	e := CreatePipe(&r, &w, makeInheritSa(), 0)
+	if e != 0 {
+		return e
 	}
 	p[0] = int(r)
 	p[1] = int(w)
@@ -473,17 +463,11 @@ func Utimes(path string, tv []Timeval) (errno int) {
 	defer Close(int(h))
 	a := NsecToFiletime(tv[0].Nanoseconds())
 	w := NsecToFiletime(tv[1].Nanoseconds())
-	if ok, e := SetFileTime(h, nil, &a, &w); !ok {
-		return e
-	}
-	return 0
+	return SetFileTime(h, nil, &a, &w)
 }
 
 func Fsync(fd int) (errno int) {
-	if ok, e := FlushFileBuffers(int32(fd)); !ok {
-		return e
-	}
-	return 0
+	return FlushFileBuffers(int32(fd))
 }
 
 // net api calls
@@ -499,7 +483,7 @@ func Fsync(fd int) (errno int) {
 //sys	listen(s int32, backlog int32) (errno int) [failretval==-1] = wsock32.listen
 //sys	shutdown(s int32, how int32) (errno int) [failretval==-1] = wsock32.shutdown
 //sys	Closesocket(s int32) (errno int) [failretval==-1] = wsock32.closesocket
-//sys	AcceptEx(ls uint32, as uint32, buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, recvd *uint32, overlapped *Overlapped) (ok bool, errno int) = wsock32.AcceptEx
+//sys	AcceptEx(ls uint32, as uint32, buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, recvd *uint32, overlapped *Overlapped) (errno int) = wsock32.AcceptEx
 //sys	GetAcceptExSockaddrs(buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, lrsa **RawSockaddrAny, lrsalen *int32, rrsa **RawSockaddrAny, rrsalen *int32) = wsock32.GetAcceptExSockaddrs
 //sys	WSARecv(s uint32, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, overlapped *Overlapped, croutine *byte) (errno int) [failretval==-1] = ws2_32.WSARecv
 //sys	WSASend(s uint32, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, overlapped *Overlapped, croutine *byte) (errno int) [failretval==-1] = ws2_32.WSASend
@@ -657,7 +641,7 @@ func AcceptIOCP(iocpfd, fd int, o *Overlapped) (attrs *byte, errno int) {
 	attrs = (*byte)(unsafe.Pointer(&rsa[0]))
 	alen := uint32(unsafe.Sizeof(rsa[0]))
 	var done uint32
-	_, errno = AcceptEx(uint32(iocpfd), uint32(fd), attrs, 0, alen, alen, &done, o)
+	errno = AcceptEx(uint32(iocpfd), uint32(fd), attrs, 0, alen, alen, &done, o)
 	return
 }
 
diff --git a/src/pkg/syscall/zsyscall_windows_386.go b/src/pkg/syscall/zsyscall_windows_386.go
index 608a8ba39d..46e16f43c5 100644
--- a/src/pkg/syscall/zsyscall_windows_386.go
+++ b/src/pkg/syscall/zsyscall_windows_386.go
@@ -113,10 +113,9 @@ func LoadLibrary(libname string) (handle uint32, errno int) {
 	return
 }
 
-func FreeLibrary(handle uint32) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procFreeLibrary, 1, uintptr(handle), 0, 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func FreeLibrary(handle uint32) (errno int) {
+	r1, _, e1 := Syscall(procFreeLibrary, 1, uintptr(handle), 0, 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -197,14 +196,13 @@ func CreateFile(name *uint16, access uint32, mode uint32, sa *SecurityAttributes
 	return
 }
 
-func ReadFile(handle int32, buf []byte, done *uint32, overlapped *Overlapped) (ok bool, errno int) {
+func ReadFile(handle int32, buf []byte, done *uint32, overlapped *Overlapped) (errno int) {
 	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall6(procReadFile, 5, uintptr(handle), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(done)), uintptr(unsafe.Pointer(overlapped)), 0)
-	ok = bool(r0 != 0)
-	if !ok {
+	r1, _, e1 := Syscall6(procReadFile, 5, uintptr(handle), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(done)), uintptr(unsafe.Pointer(overlapped)), 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -216,14 +214,13 @@ func ReadFile(handle int32, buf []byte, done *uint32, overlapped *Overlapped) (o
 	return
 }
 
-func WriteFile(handle int32, buf []byte, done *uint32, overlapped *Overlapped) (ok bool, errno int) {
+func WriteFile(handle int32, buf []byte, done *uint32, overlapped *Overlapped) (errno int) {
 	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall6(procWriteFile, 5, uintptr(handle), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(done)), uintptr(unsafe.Pointer(overlapped)), 0)
-	ok = bool(r0 != 0)
-	if !ok {
+	r1, _, e1 := Syscall6(procWriteFile, 5, uintptr(handle), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(done)), uintptr(unsafe.Pointer(overlapped)), 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -250,10 +247,9 @@ func SetFilePointer(handle int32, lowoffset int32, highoffsetptr *int32, whence
 	return
 }
 
-func CloseHandle(handle int32) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procCloseHandle, 1, uintptr(handle), 0, 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func CloseHandle(handle int32) (errno int) {
+	r1, _, e1 := Syscall(procCloseHandle, 1, uintptr(handle), 0, 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -295,10 +291,9 @@ func FindFirstFile(name *uint16, data *Win32finddata) (handle int32, errno int)
 	return
 }
 
-func FindNextFile(handle int32, data *Win32finddata) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procFindNextFileW, 2, uintptr(handle), uintptr(unsafe.Pointer(data)), 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func FindNextFile(handle int32, data *Win32finddata) (errno int) {
+	r1, _, e1 := Syscall(procFindNextFileW, 2, uintptr(handle), uintptr(unsafe.Pointer(data)), 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -310,10 +305,9 @@ func FindNextFile(handle int32, data *Win32finddata) (ok bool, errno int) {
 	return
 }
 
-func FindClose(handle int32) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procFindClose, 1, uintptr(handle), 0, 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func FindClose(handle int32) (errno int) {
+	r1, _, e1 := Syscall(procFindClose, 1, uintptr(handle), 0, 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -325,10 +319,9 @@ func FindClose(handle int32) (ok bool, errno int) {
 	return
 }
 
-func GetFileInformationByHandle(handle int32, data *ByHandleFileInformation) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procGetFileInformationByHandle, 2, uintptr(handle), uintptr(unsafe.Pointer(data)), 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func GetFileInformationByHandle(handle int32, data *ByHandleFileInformation) (errno int) {
+	r1, _, e1 := Syscall(procGetFileInformationByHandle, 2, uintptr(handle), uintptr(unsafe.Pointer(data)), 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -355,10 +348,9 @@ func GetCurrentDirectory(buflen uint32, buf *uint16) (n uint32, errno int) {
 	return
 }
 
-func SetCurrentDirectory(path *uint16) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procSetCurrentDirectoryW, 1, uintptr(unsafe.Pointer(path)), 0, 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func SetCurrentDirectory(path *uint16) (errno int) {
+	r1, _, e1 := Syscall(procSetCurrentDirectoryW, 1, uintptr(unsafe.Pointer(path)), 0, 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -370,10 +362,9 @@ func SetCurrentDirectory(path *uint16) (ok bool, errno int) {
 	return
 }
 
-func CreateDirectory(path *uint16, sa *SecurityAttributes) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procCreateDirectoryW, 2, uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(sa)), 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func CreateDirectory(path *uint16, sa *SecurityAttributes) (errno int) {
+	r1, _, e1 := Syscall(procCreateDirectoryW, 2, uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(sa)), 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -385,10 +376,9 @@ func CreateDirectory(path *uint16, sa *SecurityAttributes) (ok bool, errno int)
 	return
 }
 
-func RemoveDirectory(path *uint16) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procRemoveDirectoryW, 1, uintptr(unsafe.Pointer(path)), 0, 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func RemoveDirectory(path *uint16) (errno int) {
+	r1, _, e1 := Syscall(procRemoveDirectoryW, 1, uintptr(unsafe.Pointer(path)), 0, 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -400,10 +390,9 @@ func RemoveDirectory(path *uint16) (ok bool, errno int) {
 	return
 }
 
-func DeleteFile(path *uint16) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procDeleteFileW, 1, uintptr(unsafe.Pointer(path)), 0, 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func DeleteFile(path *uint16) (errno int) {
+	r1, _, e1 := Syscall(procDeleteFileW, 1, uintptr(unsafe.Pointer(path)), 0, 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -415,10 +404,9 @@ func DeleteFile(path *uint16) (ok bool, errno int) {
 	return
 }
 
-func MoveFile(from *uint16, to *uint16) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procMoveFileW, 2, uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(to)), 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func MoveFile(from *uint16, to *uint16) (errno int) {
+	r1, _, e1 := Syscall(procMoveFileW, 2, uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(to)), 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -430,10 +418,9 @@ func MoveFile(from *uint16, to *uint16) (ok bool, errno int) {
 	return
 }
 
-func GetComputerName(buf *uint16, n *uint32) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procGetComputerNameW, 2, uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(n)), 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func GetComputerName(buf *uint16, n *uint32) (errno int) {
+	r1, _, e1 := Syscall(procGetComputerNameW, 2, uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(n)), 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -445,10 +432,9 @@ func GetComputerName(buf *uint16, n *uint32) (ok bool, errno int) {
 	return
 }
 
-func SetEndOfFile(handle int32) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procSetEndOfFile, 1, uintptr(handle), 0, 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func SetEndOfFile(handle int32) (errno int) {
+	r1, _, e1 := Syscall(procSetEndOfFile, 1, uintptr(handle), 0, 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -500,10 +486,9 @@ func CreateIoCompletionPort(filehandle int32, cphandle int32, key uint32, thread
 	return
 }
 
-func GetQueuedCompletionStatus(cphandle int32, qty *uint32, key *uint32, overlapped **Overlapped, timeout uint32) (ok bool, errno int) {
-	r0, _, e1 := Syscall6(procGetQueuedCompletionStatus, 5, uintptr(cphandle), uintptr(unsafe.Pointer(qty)), uintptr(unsafe.Pointer(key)), uintptr(unsafe.Pointer(overlapped)), uintptr(timeout), 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func GetQueuedCompletionStatus(cphandle int32, qty *uint32, key *uint32, overlapped **Overlapped, timeout uint32) (errno int) {
+	r1, _, e1 := Syscall6(procGetQueuedCompletionStatus, 5, uintptr(cphandle), uintptr(unsafe.Pointer(qty)), uintptr(unsafe.Pointer(key)), uintptr(unsafe.Pointer(overlapped)), uintptr(timeout), 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -515,10 +500,9 @@ func GetQueuedCompletionStatus(cphandle int32, qty *uint32, key *uint32, overlap
 	return
 }
 
-func CancelIo(s uint32) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procCancelIo, 1, uintptr(s), 0, 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func CancelIo(s uint32) (errno int) {
+	r1, _, e1 := Syscall(procCancelIo, 1, uintptr(s), 0, 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -530,16 +514,15 @@ func CancelIo(s uint32) (ok bool, errno int) {
 	return
 }
 
-func CreateProcess(appName *int16, commandLine *uint16, procSecurity *int16, threadSecurity *int16, inheritHandles bool, creationFlags uint32, env *uint16, currentDir *uint16, startupInfo *StartupInfo, outProcInfo *ProcessInformation) (ok bool, errno int) {
+func CreateProcess(appName *int16, commandLine *uint16, procSecurity *int16, threadSecurity *int16, inheritHandles bool, creationFlags uint32, env *uint16, currentDir *uint16, startupInfo *StartupInfo, outProcInfo *ProcessInformation) (errno int) {
 	var _p0 uint32
 	if inheritHandles {
 		_p0 = 1
 	} else {
 		_p0 = 0
 	}
-	r0, _, e1 := Syscall12(procCreateProcessW, 10, uintptr(unsafe.Pointer(appName)), uintptr(unsafe.Pointer(commandLine)), uintptr(unsafe.Pointer(procSecurity)), uintptr(unsafe.Pointer(threadSecurity)), uintptr(_p0), uintptr(creationFlags), uintptr(unsafe.Pointer(env)), uintptr(unsafe.Pointer(currentDir)), uintptr(unsafe.Pointer(startupInfo)), uintptr(unsafe.Pointer(outProcInfo)), 0, 0)
-	ok = bool(r0 != 0)
-	if !ok {
+	r1, _, e1 := Syscall12(procCreateProcessW, 10, uintptr(unsafe.Pointer(appName)), uintptr(unsafe.Pointer(commandLine)), uintptr(unsafe.Pointer(procSecurity)), uintptr(unsafe.Pointer(threadSecurity)), uintptr(_p0), uintptr(creationFlags), uintptr(unsafe.Pointer(env)), uintptr(unsafe.Pointer(currentDir)), uintptr(unsafe.Pointer(startupInfo)), uintptr(unsafe.Pointer(outProcInfo)), 0, 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -572,10 +555,9 @@ func OpenProcess(da uint32, inheritHandle bool, pid uint32) (handle uint32, errn
 	return
 }
 
-func GetExitCodeProcess(handle uint32, exitcode *uint32) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procGetExitCodeProcess, 2, uintptr(handle), uintptr(unsafe.Pointer(exitcode)), 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func GetExitCodeProcess(handle uint32, exitcode *uint32) (errno int) {
+	r1, _, e1 := Syscall(procGetExitCodeProcess, 2, uintptr(handle), uintptr(unsafe.Pointer(exitcode)), 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -587,10 +569,9 @@ func GetExitCodeProcess(handle uint32, exitcode *uint32) (ok bool, errno int) {
 	return
 }
 
-func GetStartupInfo(startupInfo *StartupInfo) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procGetStartupInfoW, 1, uintptr(unsafe.Pointer(startupInfo)), 0, 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func GetStartupInfo(startupInfo *StartupInfo) (errno int) {
+	r1, _, e1 := Syscall(procGetStartupInfoW, 1, uintptr(unsafe.Pointer(startupInfo)), 0, 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -617,16 +598,15 @@ func GetCurrentProcess() (pseudoHandle int32, errno int) {
 	return
 }
 
-func DuplicateHandle(hSourceProcessHandle int32, hSourceHandle int32, hTargetProcessHandle int32, lpTargetHandle *int32, dwDesiredAccess uint32, bInheritHandle bool, dwOptions uint32) (ok bool, errno int) {
+func DuplicateHandle(hSourceProcessHandle int32, hSourceHandle int32, hTargetProcessHandle int32, lpTargetHandle *int32, dwDesiredAccess uint32, bInheritHandle bool, dwOptions uint32) (errno int) {
 	var _p0 uint32
 	if bInheritHandle {
 		_p0 = 1
 	} else {
 		_p0 = 0
 	}
-	r0, _, e1 := Syscall9(procDuplicateHandle, 7, uintptr(hSourceProcessHandle), uintptr(hSourceHandle), uintptr(hTargetProcessHandle), uintptr(unsafe.Pointer(lpTargetHandle)), uintptr(dwDesiredAccess), uintptr(_p0), uintptr(dwOptions), 0, 0)
-	ok = bool(r0 != 0)
-	if !ok {
+	r1, _, e1 := Syscall9(procDuplicateHandle, 7, uintptr(hSourceProcessHandle), uintptr(hSourceHandle), uintptr(hTargetProcessHandle), uintptr(unsafe.Pointer(lpTargetHandle)), uintptr(dwDesiredAccess), uintptr(_p0), uintptr(dwOptions), 0, 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -668,10 +648,9 @@ func GetTempPath(buflen uint32, buf *uint16) (n uint32, errno int) {
 	return
 }
 
-func CreatePipe(readhandle *uint32, writehandle *uint32, sa *SecurityAttributes, size uint32) (ok bool, errno int) {
-	r0, _, e1 := Syscall6(procCreatePipe, 4, uintptr(unsafe.Pointer(readhandle)), uintptr(unsafe.Pointer(writehandle)), uintptr(unsafe.Pointer(sa)), uintptr(size), 0, 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func CreatePipe(readhandle *uint32, writehandle *uint32, sa *SecurityAttributes, size uint32) (errno int) {
+	r1, _, e1 := Syscall6(procCreatePipe, 4, uintptr(unsafe.Pointer(readhandle)), uintptr(unsafe.Pointer(writehandle)), uintptr(unsafe.Pointer(sa)), uintptr(size), 0, 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -698,10 +677,9 @@ func GetFileType(filehandle uint32) (n uint32, errno int) {
 	return
 }
 
-func CryptAcquireContext(provhandle *uint32, container *uint16, provider *uint16, provtype uint32, flags uint32) (ok bool, errno int) {
-	r0, _, e1 := Syscall6(procCryptAcquireContextW, 5, uintptr(unsafe.Pointer(provhandle)), uintptr(unsafe.Pointer(container)), uintptr(unsafe.Pointer(provider)), uintptr(provtype), uintptr(flags), 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func CryptAcquireContext(provhandle *uint32, container *uint16, provider *uint16, provtype uint32, flags uint32) (errno int) {
+	r1, _, e1 := Syscall6(procCryptAcquireContextW, 5, uintptr(unsafe.Pointer(provhandle)), uintptr(unsafe.Pointer(container)), uintptr(unsafe.Pointer(provider)), uintptr(provtype), uintptr(flags), 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -713,10 +691,9 @@ func CryptAcquireContext(provhandle *uint32, container *uint16, provider *uint16
 	return
 }
 
-func CryptReleaseContext(provhandle uint32, flags uint32) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procCryptReleaseContext, 2, uintptr(provhandle), uintptr(flags), 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func CryptReleaseContext(provhandle uint32, flags uint32) (errno int) {
+	r1, _, e1 := Syscall(procCryptReleaseContext, 2, uintptr(provhandle), uintptr(flags), 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -728,10 +705,9 @@ func CryptReleaseContext(provhandle uint32, flags uint32) (ok bool, errno int) {
 	return
 }
 
-func CryptGenRandom(provhandle uint32, buflen uint32, buf *byte) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procCryptGenRandom, 3, uintptr(provhandle), uintptr(buflen), uintptr(unsafe.Pointer(buf)))
-	ok = bool(r0 != 0)
-	if !ok {
+func CryptGenRandom(provhandle uint32, buflen uint32, buf *byte) (errno int) {
+	r1, _, e1 := Syscall(procCryptGenRandom, 3, uintptr(provhandle), uintptr(buflen), uintptr(unsafe.Pointer(buf)))
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -758,10 +734,9 @@ func GetEnvironmentStrings() (envs *uint16, errno int) {
 	return
 }
 
-func FreeEnvironmentStrings(envs *uint16) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procFreeEnvironmentStringsW, 1, uintptr(unsafe.Pointer(envs)), 0, 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func FreeEnvironmentStrings(envs *uint16) (errno int) {
+	r1, _, e1 := Syscall(procFreeEnvironmentStringsW, 1, uintptr(unsafe.Pointer(envs)), 0, 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -788,10 +763,9 @@ func GetEnvironmentVariable(name *uint16, buffer *uint16, size uint32) (n uint32
 	return
 }
 
-func SetEnvironmentVariable(name *uint16, value *uint16) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procSetEnvironmentVariableW, 2, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(value)), 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func SetEnvironmentVariable(name *uint16, value *uint16) (errno int) {
+	r1, _, e1 := Syscall(procSetEnvironmentVariableW, 2, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(value)), 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -803,10 +777,9 @@ func SetEnvironmentVariable(name *uint16, value *uint16) (ok bool, errno int) {
 	return
 }
 
-func SetFileTime(handle int32, ctime *Filetime, atime *Filetime, wtime *Filetime) (ok bool, errno int) {
-	r0, _, e1 := Syscall6(procSetFileTime, 4, uintptr(handle), uintptr(unsafe.Pointer(ctime)), uintptr(unsafe.Pointer(atime)), uintptr(unsafe.Pointer(wtime)), 0, 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func SetFileTime(handle int32, ctime *Filetime, atime *Filetime, wtime *Filetime) (errno int) {
+	r1, _, e1 := Syscall6(procSetFileTime, 4, uintptr(handle), uintptr(unsafe.Pointer(ctime)), uintptr(unsafe.Pointer(atime)), uintptr(unsafe.Pointer(wtime)), 0, 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -869,10 +842,9 @@ func LocalFree(hmem uint32) (handle uint32, errno int) {
 	return
 }
 
-func SetHandleInformation(handle int32, mask uint32, flags uint32) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procSetHandleInformation, 3, uintptr(handle), uintptr(mask), uintptr(flags))
-	ok = bool(r0 != 0)
-	if !ok {
+func SetHandleInformation(handle int32, mask uint32, flags uint32) (errno int) {
+	r1, _, e1 := Syscall(procSetHandleInformation, 3, uintptr(handle), uintptr(mask), uintptr(flags))
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -884,10 +856,9 @@ func SetHandleInformation(handle int32, mask uint32, flags uint32) (ok bool, err
 	return
 }
 
-func FlushFileBuffers(handle int32) (ok bool, errno int) {
-	r0, _, e1 := Syscall(procFlushFileBuffers, 1, uintptr(handle), 0, 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func FlushFileBuffers(handle int32) (errno int) {
+	r1, _, e1 := Syscall(procFlushFileBuffers, 1, uintptr(handle), 0, 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
@@ -1046,10 +1017,9 @@ func Closesocket(s int32) (errno int) {
 	return
 }
 
-func AcceptEx(ls uint32, as uint32, buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, recvd *uint32, overlapped *Overlapped) (ok bool, errno int) {
-	r0, _, e1 := Syscall9(procAcceptEx, 8, uintptr(ls), uintptr(as), uintptr(unsafe.Pointer(buf)), uintptr(rxdatalen), uintptr(laddrlen), uintptr(raddrlen), uintptr(unsafe.Pointer(recvd)), uintptr(unsafe.Pointer(overlapped)), 0)
-	ok = bool(r0 != 0)
-	if !ok {
+func AcceptEx(ls uint32, as uint32, buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, recvd *uint32, overlapped *Overlapped) (errno int) {
+	r1, _, e1 := Syscall9(procAcceptEx, 8, uintptr(ls), uintptr(as), uintptr(unsafe.Pointer(buf)), uintptr(rxdatalen), uintptr(laddrlen), uintptr(raddrlen), uintptr(unsafe.Pointer(recvd)), uintptr(unsafe.Pointer(overlapped)), 0)
+	if int(r1) == 0 {
 		if e1 != 0 {
 			errno = int(e1)
 		} else {
