commit e7cbbbe9bb878b6ca4ce04fde645df1c8f1845bd
Author: Daniel Martí <mvdan@mvdan.cc>
Date:   Mon Feb 12 16:34:48 2018 +0000

    cmd/vendor/github.com/google/pprof: refresh from upstream
    
    Updating to commit 0e0e5b7254e076a62326ab7305ba49e8515f0c91
    from github.com/google/pprof
    
    Recent modifications to the vendored pprof, such as skipping
    TestWebInterface to avoid starting a web browser, have all been fixed
    upstream.
    
    Change-Id: I72e11108c438e1573bf2f9216e76d157378e8d45
    Reviewed-on: https://go-review.googlesource.com/93375
    Run-TryBot: Daniel Martí <mvdan@mvdan.cc>
    TryBot-Result: Gobot Gobot <gobot@golang.org>
    Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org>
---
 src/cmd/vendor/github.com/google/pprof/.gitignore  |    8 -
 .../vendor/github.com/google/pprof/CONTRIBUTING.md |   92 +-
 .../vendor/github.com/google/pprof/CONTRIBUTORS    |    3 +-
 .../google/pprof/internal/binutils/binutils.go     |   27 +-
 .../pprof/internal/binutils/binutils_test.go       |  147 +-
 .../google/pprof/internal/binutils/disasm.go       |   34 +-
 .../binutils/testdata/{hello => exe_linux_64}      |  Bin
 .../google/pprof/internal/driver/commands.go       |    3 +-
 .../google/pprof/internal/driver/driver.go         |    2 +-
 .../google/pprof/internal/driver/driver_test.go    |   10 +-
 .../google/pprof/internal/driver/fetch_test.go     |    9 +-
 .../google/pprof/internal/driver/flamegraph.go     |   99 +
 .../google/pprof/internal/driver/interactive.go    |   23 +
 .../pprof/internal/driver/interactive_test.go      |   58 +-
 .../{third_party/svg => internal/driver}/svg.go    |   19 +-
 .../testdata/pprof.cpu.flat.addresses.weblist      |    4 +-
 .../google/pprof/internal/driver/webhtml.go        | 1214 ++---
 .../google/pprof/internal/driver/webui.go          |   79 +-
 .../google/pprof/internal/driver/webui_test.go     |   77 +-
 .../google/pprof/internal/elfexec/elfexec.go       |   16 +
 .../google/pprof/internal/graph/dotgraph.go        |   21 +-
 .../pprof/internal/measurement/measurement.go      |   18 +
 .../google/pprof/internal/proftest/proftest.go     |   13 +-
 .../google/pprof/internal/report/report.go         |   42 +-
 .../google/pprof/internal/report/report_test.go    |    4 +-
 .../google/pprof/internal/report/source.go         |    7 +-
 .../google/pprof/internal/report/source_test.go    |    4 +-
 .../google/pprof/internal/symbolizer/symbolizer.go |    1 +
 .../google/pprof/internal/symbolz/symbolz.go       |   21 +-
 .../google/pprof/internal/symbolz/symbolz_test.go  |   11 +
 .../github.com/google/pprof/profile/encode.go      |    9 +-
 .../github.com/google/pprof/profile/merge.go       |   23 +-
 .../github.com/google/pprof/profile/profile.go     |   15 +-
 .../google/pprof/profile/profile_test.go           |  147 +-
 .../github.com/google/pprof/profile/proto_test.go  |   24 +-
 .../github.com/google/pprof/proto/profile.proto    |   13 +-
 src/cmd/vendor/github.com/google/pprof/test.sh     |    9 +-
 .../github.com/google/pprof/third_party/d3/LICENSE |   27 +
 .../google/pprof/third_party/d3/README.md          |  119 +
 .../github.com/google/pprof/third_party/d3/d3.go   | 4675 ++++++++++++++++++++
 .../google/pprof/third_party/d3flamegraph/LICENSE  |  201 +
 .../third_party/d3flamegraph/d3_flame_graph.go     |  711 +++
 .../google/pprof/third_party/d3tip/LICENSE         |    8 +
 .../google/pprof/third_party/d3tip/d3_tip.go       |  328 ++
 .../google/pprof/third_party/svgpan/LICENSE        |   27 +
 .../pprof/third_party/{svg => svgpan}/svgpan.go    |   90 +-
 46 files changed, 7663 insertions(+), 829 deletions(-)

diff --git a/src/cmd/vendor/github.com/google/pprof/.gitignore b/src/cmd/vendor/github.com/google/pprof/.gitignore
deleted file mode 100644
index 5a0c00f159..0000000000
--- a/src/cmd/vendor/github.com/google/pprof/.gitignore
+++ /dev/null
@@ -1,8 +0,0 @@
-.DS_Store
-*~
-*.orig
-*.exe
-.*.swp
-core
-coverage.txt
-pprof
diff --git a/src/cmd/vendor/github.com/google/pprof/CONTRIBUTING.md b/src/cmd/vendor/github.com/google/pprof/CONTRIBUTING.md
index 5976686d73..e793970674 100644
--- a/src/cmd/vendor/github.com/google/pprof/CONTRIBUTING.md
+++ b/src/cmd/vendor/github.com/google/pprof/CONTRIBUTING.md
@@ -1,27 +1,77 @@
-Want to contribute? Great! First, read this page (including the small print at the end).
+Want to contribute? Great: read the page (including the small print at the end).
 
-### Before you contribute
+# Before you contribute
 
-Before we can use your code, you must sign the
-[Google Individual Contributor License Agreement](https://cla.developers.google.com/about/google-individual)
-(CLA), which you can do online. The CLA is necessary mainly because you own the
-copyright to your changes, even after your contribution becomes part of our
-codebase, so we need your permission to use and distribute your code. We also
-need to be sure of various other things—for instance that you'll tell us if you
-know that your code infringes on other people's patents. You don't have to sign
-the CLA until after you've submitted your code for review and a member has
-approved it, but you must do it before we can put your code into our codebase.
-Before you start working on a larger contribution, you should get in touch with
-us first through the issue tracker with your idea so that we can help out and
-possibly guide you. Coordinating up front makes it much easier to avoid
-frustration later on.
+As an individual, sign the [Google Individual Contributor License
+Agreement](https://cla.developers.google.com/about/google-individual) (CLA)
+online. This is required for any of your code to be accepted.
 
-### Code reviews
+Before you start working on a larger contribution, get in touch with us first
+through the issue tracker with your idea so that we can help out and possibly
+guide you. Coordinating up front makes it much easier to avoid frustration later
+on.
 
-All submissions, including submissions by project members, require review.  
-We use Github pull requests for this purpose.
+# Development
 
-### The small print
+Make sure `GOPATH` is set in your current shell. The common way is to have
+something like `export GOPATH=$HOME/gocode` in your `.bashrc` file so that it's
+automatically set in all console sessions.
 
-Contributions made by corporations are covered by a different agreement than the one above,  
-the [Software Grant and Corporate Contributor License Agreement](https://cla.developers.google.com/about/google-corporate).
+To get the source code, run
+
+```
+go get github.com/google/pprof
+```
+
+To run the tests, do
+
+```
+cd $GOPATH/src/github.com/google/pprof
+go test -v ./...
+```
+
+When you wish to work with your own fork of the source (which is required to be
+able to create a pull request), you'll want to get your fork repo as another Git
+remote in the same `github.com/google/pprof` directory. Otherwise, if you'll `go
+get` your fork directly, you'll be getting errors like `use of internal package
+not allowed` when running tests.  To set up the remote do something like
+
+```
+cd $GOPATH/src/github.com/google/pprof
+git remote add aalexand git@github.com:aalexand/pprof.git
+git fetch aalexand
+git checkout -b my-new-feature
+# hack hack hack
+go test -v ./...
+git commit -a -m "Add new feature."
+git push aalexand
+```
+
+where `aalexand` is your GitHub user ID. Then proceed to the GitHub UI to send a
+code review.
+
+# Code reviews
+
+All submissions, including submissions by project members, require review.
+We use GitHub pull requests for this purpose.
+
+The pprof source code is in Go with a bit of JavaScript, CSS and HTML. If you
+are new to Go, read [Effective Go](https://golang.org/doc/effective_go.html) and
+the [summary on typical comments during Go code
+reviews](https://github.com/golang/go/wiki/CodeReviewComments).
+
+Cover all new functionality with tests. Enable Travis on your forked repo,
+enable builds of branches and make sure Travis is happily green for the branch
+with your changes.
+
+The code coverage is measured for each pull request. The code coverage is
+expected to go up with every change.
+
+Pull requests not meeting the above guidelines will get less attention than good
+ones, so make sure your submissions are high quality.
+
+# The small print
+
+Contributions made by corporations are covered by a different agreement than the
+one above, the [Software Grant and Corporate Contributor License
+Agreement](https://cla.developers.google.com/about/google-corporate).
diff --git a/src/cmd/vendor/github.com/google/pprof/CONTRIBUTORS b/src/cmd/vendor/github.com/google/pprof/CONTRIBUTORS
index 2f73c299c8..0ef5e2f240 100644
--- a/src/cmd/vendor/github.com/google/pprof/CONTRIBUTORS
+++ b/src/cmd/vendor/github.com/google/pprof/CONTRIBUTORS
@@ -11,4 +11,5 @@
 Raul Silvera <rsilvera@google.com>
 Tipp Moseley <tipp@google.com>
 Hyoun Kyu Cho <netforce@google.com>
-
+Martin Spier <spiermar@gmail.com>
+Taco de Wolff <tacodewolff@gmail.com>
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/binutils/binutils.go b/src/cmd/vendor/github.com/google/pprof/internal/binutils/binutils.go
index 9a82cb8e92..390f952feb 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/binutils/binutils.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/binutils/binutils.go
@@ -175,20 +175,35 @@ func (bu *Binutils) Open(name string, start, limit, offset uint64) (plugin.ObjFi
 func (b *binrep) openMachO(name string, start, limit, offset uint64) (plugin.ObjFile, error) {
 	of, err := macho.Open(name)
 	if err != nil {
-		return nil, fmt.Errorf("Parsing %s: %v", name, err)
+		return nil, fmt.Errorf("error parsing %s: %v", name, err)
 	}
 	defer of.Close()
 
+	// Subtract the load address of the __TEXT section. Usually 0 for shared
+	// libraries or 0x100000000 for executables. You can check this value by
+	// running `objdump -private-headers <file>`.
+
+	textSegment := of.Segment("__TEXT")
+	if textSegment == nil {
+		return nil, fmt.Errorf("could not identify base for %s: no __TEXT segment", name)
+	}
+	if textSegment.Addr > start {
+		return nil, fmt.Errorf("could not identify base for %s: __TEXT segment address (0x%x) > mapping start address (0x%x)",
+			name, textSegment.Addr, start)
+	}
+
+	base := start - textSegment.Addr
+
 	if b.fast || (!b.addr2lineFound && !b.llvmSymbolizerFound) {
-		return &fileNM{file: file{b: b, name: name}}, nil
+		return &fileNM{file: file{b: b, name: name, base: base}}, nil
 	}
-	return &fileAddr2Line{file: file{b: b, name: name}}, nil
+	return &fileAddr2Line{file: file{b: b, name: name, base: base}}, nil
 }
 
 func (b *binrep) openELF(name string, start, limit, offset uint64) (plugin.ObjFile, error) {
 	ef, err := elf.Open(name)
 	if err != nil {
-		return nil, fmt.Errorf("Parsing %s: %v", name, err)
+		return nil, fmt.Errorf("error parsing %s: %v", name, err)
 	}
 	defer ef.Close()
 
@@ -215,9 +230,9 @@ func (b *binrep) openELF(name string, start, limit, offset uint64) (plugin.ObjFi
 		}
 	}
 
-	base, err := elfexec.GetBase(&ef.FileHeader, nil, stextOffset, start, limit, offset)
+	base, err := elfexec.GetBase(&ef.FileHeader, elfexec.FindTextProgHeader(ef), stextOffset, start, limit, offset)
 	if err != nil {
-		return nil, fmt.Errorf("Could not identify base for %s: %v", name, err)
+		return nil, fmt.Errorf("could not identify base for %s: %v", name, err)
 	}
 
 	buildID := ""
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/binutils/binutils_test.go b/src/cmd/vendor/github.com/google/pprof/internal/binutils/binutils_test.go
index 989a290071..0317cf5126 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/binutils/binutils_test.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/binutils/binutils_test.go
@@ -177,14 +177,20 @@ func TestSetFastSymbolization(t *testing.T) {
 
 func skipUnlessLinuxAmd64(t *testing.T) {
 	if runtime.GOOS != "linux" || runtime.GOARCH != "amd64" {
-		t.Skip("Disasm only tested on x86-64 linux")
+		t.Skip("This test only works on x86-64 Linux")
+	}
+}
+
+func skipUnlessDarwinAmd64(t *testing.T) {
+	if runtime.GOOS != "darwin" || runtime.GOARCH != "amd64" {
+		t.Skip("This test only works on x86-64 Mac")
 	}
 }
 
 func TestDisasm(t *testing.T) {
 	skipUnlessLinuxAmd64(t)
 	bu := &Binutils{}
-	insts, err := bu.Disasm(filepath.Join("testdata", "hello"), 0, math.MaxUint64)
+	insts, err := bu.Disasm(filepath.Join("testdata", "exe_linux_64"), 0, math.MaxUint64)
 	if err != nil {
 		t.Fatalf("Disasm: unexpected error %v", err)
 	}
@@ -199,42 +205,119 @@ func TestDisasm(t *testing.T) {
 	}
 }
 
+func findSymbol(syms []*plugin.Sym, name string) *plugin.Sym {
+	for _, s := range syms {
+		for _, n := range s.Name {
+			if n == name {
+				return s
+			}
+		}
+	}
+	return nil
+}
+
 func TestObjFile(t *testing.T) {
 	skipUnlessLinuxAmd64(t)
-	bu := &Binutils{}
-	f, err := bu.Open(filepath.Join("testdata", "hello"), 0, math.MaxUint64, 0)
-	if err != nil {
-		t.Fatalf("Open: unexpected error %v", err)
-	}
-	defer f.Close()
-	syms, err := f.Symbols(regexp.MustCompile("main"), 0)
-	if err != nil {
-		t.Fatalf("Symbols: unexpected error %v", err)
-	}
+	for _, tc := range []struct {
+		desc                 string
+		start, limit, offset uint64
+		addr                 uint64
+	}{
+		{"fake mapping", 0, math.MaxUint64, 0, 0x40052d},
+		{"fixed load address", 0x400000, 0x4006fc, 0, 0x40052d},
+		// True user-mode ASLR binaries are ET_DYN rather than ET_EXEC so this case
+		// is a bit artificial except that it approximates the
+		// vmlinux-with-kernel-ASLR case where the binary *is* ET_EXEC.
+		{"simulated ASLR address", 0x500000, 0x5006fc, 0, 0x50052d},
+	} {
+		t.Run(tc.desc, func(t *testing.T) {
+			bu := &Binutils{}
+			f, err := bu.Open(filepath.Join("testdata", "exe_linux_64"), tc.start, tc.limit, tc.offset)
+			if err != nil {
+				t.Fatalf("Open: unexpected error %v", err)
+			}
+			defer f.Close()
+			syms, err := f.Symbols(regexp.MustCompile("main"), 0)
+			if err != nil {
+				t.Fatalf("Symbols: unexpected error %v", err)
+			}
 
-	find := func(name string) *plugin.Sym {
-		for _, s := range syms {
-			for _, n := range s.Name {
-				if n == name {
-					return s
+			m := findSymbol(syms, "main")
+			if m == nil {
+				t.Fatalf("Symbols: did not find main")
+			}
+			for _, addr := range []uint64{m.Start + f.Base(), tc.addr} {
+				gotFrames, err := f.SourceLine(addr)
+				if err != nil {
+					t.Fatalf("SourceLine: unexpected error %v", err)
+				}
+				wantFrames := []plugin.Frame{
+					{Func: "main", File: "/tmp/hello.c", Line: 3},
+				}
+				if !reflect.DeepEqual(gotFrames, wantFrames) {
+					t.Fatalf("SourceLine for main: got %v; want %v\n", gotFrames, wantFrames)
 				}
 			}
-		}
-		return nil
-	}
-	m := find("main")
-	if m == nil {
-		t.Fatalf("Symbols: did not find main")
-	}
-	frames, err := f.SourceLine(m.Start)
-	if err != nil {
-		t.Fatalf("SourceLine: unexpected error %v", err)
-	}
-	expect := []plugin.Frame{
-		{Func: "main", File: "/tmp/hello.c", Line: 3},
+		})
 	}
-	if !reflect.DeepEqual(frames, expect) {
-		t.Fatalf("SourceLine for main: expect %v; got %v\n", expect, frames)
+}
+
+func TestMachoFiles(t *testing.T) {
+	skipUnlessDarwinAmd64(t)
+
+	t.Skip("Disabled because of issues with addr2line (see https://github.com/google/pprof/pull/313#issuecomment-364073010)")
+
+	// Load `file`, pretending it was mapped at `start`. Then get the symbol
+	// table. Check that it contains the symbol `sym` and that the address
+	// `addr` gives the `expected` stack trace.
+	for _, tc := range []struct {
+		desc                 string
+		file                 string
+		start, limit, offset uint64
+		addr                 uint64
+		sym                  string
+		expected             []plugin.Frame
+	}{
+		{"normal mapping", "exe_mac_64", 0x100000000, math.MaxUint64, 0,
+			0x100000f50, "_main",
+			[]plugin.Frame{
+				{Func: "main", File: "/tmp/hello.c", Line: 3},
+			}},
+		{"other mapping", "exe_mac_64", 0x200000000, math.MaxUint64, 0,
+			0x200000f50, "_main",
+			[]plugin.Frame{
+				{Func: "main", File: "/tmp/hello.c", Line: 3},
+			}},
+		{"lib normal mapping", "lib_mac_64", 0, math.MaxUint64, 0,
+			0xfa0, "_bar",
+			[]plugin.Frame{
+				{Func: "bar", File: "/tmp/lib.c", Line: 6},
+			}},
+	} {
+		t.Run(tc.desc, func(t *testing.T) {
+			bu := &Binutils{}
+			f, err := bu.Open(filepath.Join("testdata", tc.file), tc.start, tc.limit, tc.offset)
+			if err != nil {
+				t.Fatalf("Open: unexpected error %v", err)
+			}
+			defer f.Close()
+			syms, err := f.Symbols(nil, 0)
+			if err != nil {
+				t.Fatalf("Symbols: unexpected error %v", err)
+			}
+
+			m := findSymbol(syms, tc.sym)
+			if m == nil {
+				t.Fatalf("Symbols: could not find symbol %v", tc.sym)
+			}
+			gotFrames, err := f.SourceLine(tc.addr)
+			if err != nil {
+				t.Fatalf("SourceLine: unexpected error %v", err)
+			}
+			if !reflect.DeepEqual(gotFrames, tc.expected) {
+				t.Fatalf("SourceLine for main: got %v; want %v\n", gotFrames, tc.expected)
+			}
+		})
 	}
 }
 
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/binutils/disasm.go b/src/cmd/vendor/github.com/google/pprof/internal/binutils/disasm.go
index 1a3b6f8d6a..28c89aa163 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/binutils/disasm.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/binutils/disasm.go
@@ -34,24 +34,48 @@ var (
 func findSymbols(syms []byte, file string, r *regexp.Regexp, address uint64) ([]*plugin.Sym, error) {
 	// Collect all symbols from the nm output, grouping names mapped to
 	// the same address into a single symbol.
+
+	// The symbols to return.
 	var symbols []*plugin.Sym
+
+	// The current group of symbol names, and the address they are all at.
 	names, start := []string{}, uint64(0)
+
 	buf := bytes.NewBuffer(syms)
-	for symAddr, name, err := nextSymbol(buf); err == nil; symAddr, name, err = nextSymbol(buf) {
+
+	for {
+		symAddr, name, err := nextSymbol(buf)
+		if err == io.EOF {
+			// Done. If there was an unfinished group, append it.
+			if len(names) != 0 {
+				if match := matchSymbol(names, start, symAddr-1, r, address); match != nil {
+					symbols = append(symbols, &plugin.Sym{Name: match, File: file, Start: start, End: symAddr - 1})
+				}
+			}
+
+			// And return the symbols.
+			return symbols, nil
+		}
+
 		if err != nil {
+			// There was some kind of serious error reading nm's output.
 			return nil, err
 		}
-		if start == symAddr {
+
+		// If this symbol is at the same address as the current group, add it to the group.
+		if symAddr == start {
 			names = append(names, name)
 			continue
 		}
+
+		// Otherwise append the current group to the list of symbols.
 		if match := matchSymbol(names, start, symAddr-1, r, address); match != nil {
 			symbols = append(symbols, &plugin.Sym{Name: match, File: file, Start: start, End: symAddr - 1})
 		}
+
+		// And start a new group.
 		names, start = []string{name}, symAddr
 	}
-
-	return symbols, nil
 }
 
 // matchSymbol checks if a symbol is to be selected by checking its
@@ -62,7 +86,7 @@ func matchSymbol(names []string, start, end uint64, r *regexp.Regexp, address ui
 		return names
 	}
 	for _, name := range names {
-		if r.MatchString(name) {
+		if r == nil || r.MatchString(name) {
 			return []string{name}
 		}
 
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/binutils/testdata/hello b/src/cmd/vendor/github.com/google/pprof/internal/binutils/testdata/exe_linux_64
similarity index 100%
rename from src/cmd/vendor/github.com/google/pprof/internal/binutils/testdata/hello
rename to src/cmd/vendor/github.com/google/pprof/internal/binutils/testdata/exe_linux_64
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/driver/commands.go b/src/cmd/vendor/github.com/google/pprof/internal/driver/commands.go
index 66e5c86b9d..16b0b0a3b5 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/driver/commands.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/driver/commands.go
@@ -28,7 +28,6 @@ import (
 
 	"github.com/google/pprof/internal/plugin"
 	"github.com/google/pprof/internal/report"
-	"github.com/google/pprof/third_party/svg"
 )
 
 // commands describes the commands accepted by pprof.
@@ -398,7 +397,7 @@ func massageDotSVG() PostProcessor {
 		if err := generateSVG(input, baseSVG, ui); err != nil {
 			return err
 		}
-		_, err := output.Write([]byte(svg.Massage(baseSVG.String())))
+		_, err := output.Write([]byte(massageSVG(baseSVG.String())))
 		return err
 	}
 }
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/driver/driver.go b/src/cmd/vendor/github.com/google/pprof/internal/driver/driver.go
index bc5f366128..c2b1cd082b 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/driver/driver.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/driver/driver.go
@@ -54,7 +54,7 @@ func PProf(eo *plugin.Options) error {
 	}
 
 	if src.HTTPHostport != "" {
-		return serveWebInterface(src.HTTPHostport, p, o)
+		return serveWebInterface(src.HTTPHostport, p, o, true)
 	}
 	return interactive(p, o)
 }
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/driver/driver_test.go b/src/cmd/vendor/github.com/google/pprof/internal/driver/driver_test.go
index 1289a096b8..0604da911c 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/driver/driver_test.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/driver/driver_test.go
@@ -1487,8 +1487,14 @@ func (m *mockFile) Symbols(r *regexp.Regexp, addr uint64) ([]*plugin.Sym, error)
 	switch r.String() {
 	case "line[13]":
 		return []*plugin.Sym{
-			{[]string{"line1000"}, m.name, 0x1000, 0x1003},
-			{[]string{"line3000"}, m.name, 0x3000, 0x3004},
+			{
+				Name: []string{"line1000"}, File: m.name,
+				Start: 0x1000, End: 0x1003,
+			},
+			{
+				Name: []string{"line3000"}, File: m.name,
+				Start: 0x3000, End: 0x3004,
+			},
 		}, nil
 	}
 	return nil, fmt.Errorf("unimplemented")
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/driver/fetch_test.go b/src/cmd/vendor/github.com/google/pprof/internal/driver/fetch_test.go
index abce5b5c70..c80a0dbc1d 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/driver/fetch_test.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/driver/fetch_test.go
@@ -423,16 +423,9 @@ func TestHttpsInsecure(t *testing.T) {
 		Timeout:   10,
 		Symbolize: "remote",
 	}
-	rx := "Saved profile in"
-	if runtime.GOOS == "darwin" && (runtime.GOARCH == "arm" || runtime.GOARCH == "arm64") ||
-		runtime.GOOS == "android" {
-		// On iOS, $HOME points to the app root directory and is not writable.
-		// On Android, $HOME points to / which is not writable.
-		rx += "|Could not use temp dir"
-	}
 	o := &plugin.Options{
 		Obj: &binutils.Binutils{},
-		UI:  &proftest.TestUI{T: t, AllowRx: rx},
+		UI:  &proftest.TestUI{T: t, AllowRx: "Saved profile in"},
 	}
 	o.Sym = &symbolizer.Symbolizer{Obj: o.Obj, UI: o.UI}
 	p, err := fetchProfiles(s, o)
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/driver/flamegraph.go b/src/cmd/vendor/github.com/google/pprof/internal/driver/flamegraph.go
new file mode 100644
index 0000000000..10588d6262
--- /dev/null
+++ b/src/cmd/vendor/github.com/google/pprof/internal/driver/flamegraph.go
@@ -0,0 +1,99 @@
+// Copyright 2017 Google Inc. All Rights Reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package driver
+
+import (
+	"encoding/json"
+	"html/template"
+	"net/http"
+	"strings"
+
+	"github.com/google/pprof/internal/graph"
+	"github.com/google/pprof/internal/measurement"
+	"github.com/google/pprof/internal/report"
+)
+
+type treeNode struct {
+	Name      string      `json:"n"`
+	Cum       int64       `json:"v"`
+	CumFormat string      `json:"l"`
+	Percent   string      `json:"p"`
+	Children  []*treeNode `json:"c"`
+}
+
+// flamegraph generates a web page containing a flamegraph.
+func (ui *webInterface) flamegraph(w http.ResponseWriter, req *http.Request) {
+	// Force the call tree so that the graph is a tree.
+	// Also do not trim the tree so that the flame graph contains all functions.
+	rpt, errList := ui.makeReport(w, req, []string{"svg"}, "call_tree", "true", "trim", "false")
+	if rpt == nil {
+		return // error already reported
+	}
+
+	// Generate dot graph.
+	g, config := report.GetDOT(rpt)
+	var nodes []*treeNode
+	nroots := 0
+	rootValue := int64(0)
+	nodeArr := []string{}
+	nodeMap := map[*graph.Node]*treeNode{}
+	// Make all nodes and the map, collect the roots.
+	for _, n := range g.Nodes {
+		v := n.CumValue()
+		node := &treeNode{
+			Name:      n.Info.PrintableName(),
+			Cum:       v,
+			CumFormat: config.FormatValue(v),
+			Percent:   strings.TrimSpace(measurement.Percentage(v, config.Total)),
+		}
+		nodes = append(nodes, node)
+		if len(n.In) == 0 {
+			nodes[nroots], nodes[len(nodes)-1] = nodes[len(nodes)-1], nodes[nroots]
+			nroots++
+			rootValue += v
+		}
+		nodeMap[n] = node
+		// Get all node names into an array.
+		nodeArr = append(nodeArr, n.Info.Name)
+	}
+	// Populate the child links.
+	for _, n := range g.Nodes {
+		node := nodeMap[n]
+		for child := range n.Out {
+			node.Children = append(node.Children, nodeMap[child])
+		}
+	}
+
+	rootNode := &treeNode{
+		Name:      "root",
+		Cum:       rootValue,
+		CumFormat: config.FormatValue(rootValue),
+		Percent:   strings.TrimSpace(measurement.Percentage(rootValue, config.Total)),
+		Children:  nodes[0:nroots],
+	}
+
+	// JSON marshalling flame graph
+	b, err := json.Marshal(rootNode)
+	if err != nil {
+		http.Error(w, "error serializing flame graph", http.StatusInternalServerError)
+		ui.options.UI.PrintErr(err)
+		return
+	}
+
+	ui.render(w, "/flamegraph", "flamegraph", rpt, errList, config.Labels, webArgs{
+		FlameGraph: template.JS(b),
+		Nodes:      nodeArr,
+	})
+}
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/driver/interactive.go b/src/cmd/vendor/github.com/google/pprof/internal/driver/interactive.go
index 2c36b64cc7..b893697b62 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/driver/interactive.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/driver/interactive.go
@@ -42,6 +42,9 @@ func interactive(p *profile.Profile, o *plugin.Options) error {
 	interactiveMode = true
 	shortcuts := profileShortcuts(p)
 
+	// Get all groups in pprofVariables to allow for clearer error messages.
+	groups := groupOptions(pprofVariables)
+
 	greetings(p, o.UI)
 	for {
 		input, err := o.UI.ReadLine("(pprof) ")
@@ -87,6 +90,9 @@ func interactive(p *profile.Profile, o *plugin.Options) error {
 						o.UI.PrintErr(err)
 					}
 					continue
+				} else if okValues := groups[name]; okValues != nil {
+					o.UI.PrintErr(fmt.Errorf("Unrecognized value for %s: %q. Use one of %s", name, value, strings.Join(okValues, ", ")))
+					continue
 				}
 			}
 
@@ -118,6 +124,23 @@ func interactive(p *profile.Profile, o *plugin.Options) error {
 	}
 }
 
+// groupOptions returns a map containing all non-empty groups
+// mapped to an array of the option names in that group in
+// sorted order.
+func groupOptions(vars variables) map[string][]string {
+	groups := make(map[string][]string)
+	for name, option := range vars {
+		group := option.group
+		if group != "" {
+			groups[group] = append(groups[group], name)
+		}
+	}
+	for _, names := range groups {
+		sort.Strings(names)
+	}
+	return groups
+}
+
 var generateReportWrapper = generateReport // For testing purposes.
 
 // greetings prints a brief welcome and some overall profile
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/driver/interactive_test.go b/src/cmd/vendor/github.com/google/pprof/internal/driver/interactive_test.go
index ba80741a35..db26862c7d 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/driver/interactive_test.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/driver/interactive_test.go
@@ -16,12 +16,12 @@ package driver
 
 import (
 	"fmt"
-	"io"
 	"math/rand"
 	"strings"
 	"testing"
 
 	"github.com/google/pprof/internal/plugin"
+	"github.com/google/pprof/internal/proftest"
 	"github.com/google/pprof/internal/report"
 	"github.com/google/pprof/profile"
 )
@@ -70,6 +70,21 @@ func TestShell(t *testing.T) {
 		t.Error("second shortcut attempt:", err)
 	}
 
+	// Group with invalid value
+	pprofVariables = testVariables(savedVariables)
+	ui := &proftest.TestUI{
+		T:       t,
+		Input:   []string{"cumulative=this"},
+		AllowRx: `Unrecognized value for cumulative: "this". Use one of cum, flat`,
+	}
+	o.UI = ui
+	if err := interactive(p, o); err != nil {
+		t.Error("invalid group value:", err)
+	}
+	// Confirm error message written out once.
+	if ui.NumAllowRxMatches != 1 {
+		t.Errorf("want error message to be printed 1 time, got %v", ui.NumAllowRxMatches)
+	}
 	// Verify propagation of IO errors
 	pprofVariables = testVariables(savedVariables)
 	o.UI = newUI(t, []string{"**error**"})
@@ -144,45 +159,10 @@ func makeShortcuts(input []string, seed int) (shortcuts, []string) {
 }
 
 func newUI(t *testing.T, input []string) plugin.UI {
-	return &testUI{
-		t:     t,
-		input: input,
-	}
-}
-
-type testUI struct {
-	t     *testing.T
-	input []string
-	index int
-}
-
-func (ui *testUI) ReadLine(_ string) (string, error) {
-	if ui.index >= len(ui.input) {
-		return "", io.EOF
+	return &proftest.TestUI{
+		T:     t,
+		Input: input,
 	}
-	input := ui.input[ui.index]
-	if input == "**error**" {
-		return "", fmt.Errorf("Error: %s", input)
-	}
-	ui.index++
-	return input, nil
-}
-
-func (ui *testUI) Print(args ...interface{}) {
-}
-
-func (ui *testUI) PrintErr(args ...interface{}) {
-	output := fmt.Sprint(args)
-	if output != "" {
-		ui.t.Error(output)
-	}
-}
-
-func (ui *testUI) IsTerminal() bool {
-	return false
-}
-
-func (ui *testUI) SetAutoComplete(func(string) string) {
 }
 
 func checkValue(p *profile.Profile, cmd []string, vars variables, o *plugin.Options) error {
diff --git a/src/cmd/vendor/github.com/google/pprof/third_party/svg/svg.go b/src/cmd/vendor/github.com/google/pprof/internal/driver/svg.go
similarity index 78%
rename from src/cmd/vendor/github.com/google/pprof/third_party/svg/svg.go
rename to src/cmd/vendor/github.com/google/pprof/internal/driver/svg.go
index e08f8bed82..62767e726d 100644
--- a/src/cmd/vendor/github.com/google/pprof/third_party/svg/svg.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/driver/svg.go
@@ -12,12 +12,13 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-// Package svg provides tools related to handling of SVG files
-package svg
+package driver
 
 import (
 	"regexp"
 	"strings"
+
+	"github.com/google/pprof/third_party/svgpan"
 )
 
 var (
@@ -26,15 +27,15 @@ var (
 	svgClose = regexp.MustCompile(`</svg>`)
 )
 
-// Massage enhances the SVG output from DOT to provide better
-// panning inside a web browser. It uses the SVGPan library, which is
-// embedded into the svgPanJS variable.
-func Massage(svg string) string {
+// massageSVG enhances the SVG output from DOT to provide better
+// panning inside a web browser. It uses the svgpan library, which is
+// embedded into the svgpan.JSSource variable.
+func massageSVG(svg string) string {
 	// Work around for dot bug which misses quoting some ampersands,
 	// resulting on unparsable SVG.
 	svg = strings.Replace(svg, "&;", "&amp;;", -1)
 
-	//Dot's SVG output is
+	// Dot's SVG output is
 	//
 	//    <svg width="___" height="___"
 	//     viewBox="___" xmlns=...>
@@ -48,7 +49,7 @@ func Massage(svg string) string {
 	//    <svg width="100%" height="100%"
 	//     xmlns=...>
 
-	//    <script type="text/ecmascript"><![CDATA[` ..$(svgPanJS)... `]]></script>`
+	//    <script type="text/ecmascript"><![CDATA[` ..$(svgpan.JSSource)... `]]></script>`
 	//    <g id="viewport" transform="translate(0,0)">
 	//    <g id="graph0" transform="...">
 	//    ...
@@ -64,7 +65,7 @@ func Massage(svg string) string {
 
 	if loc := graphID.FindStringIndex(svg); loc != nil {
 		svg = svg[:loc[0]] +
-			`<script type="text/ecmascript"><![CDATA[` + string(svgPanJS) + `]]></script>` +
+			`<script type="text/ecmascript"><![CDATA[` + string(svgpan.JSSource) + `]]></script>` +
 			`<g id="viewport" transform="scale(0.5,0.5) translate(0,0)">` +
 			svg[loc[0]:]
 	}
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/driver/testdata/pprof.cpu.flat.addresses.weblist b/src/cmd/vendor/github.com/google/pprof/internal/driver/testdata/pprof.cpu.flat.addresses.weblist
index befc412db3..0284292745 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/driver/testdata/pprof.cpu.flat.addresses.weblist
+++ b/src/cmd/vendor/github.com/google/pprof/internal/driver/testdata/pprof.cpu.flat.addresses.weblist
@@ -61,7 +61,7 @@ function pprof_toggle_asm(e) {
 
 <div class="legend">File: testbinary<br>
 Type: cpu<br>
-Duration: 10s, Total samples = 1.12s (11.20%)<br>Total: 1.12s</div><h1>line1000</h1>testdata/file1000.src
+Duration: 10s, Total samples = 1.12s (11.20%)<br>Total: 1.12s</div><h2>line1000</h2><p class="filename">testdata/file1000.src</p>
 <pre onClick="pprof_toggle_asm(event)">
   Total:       1.10s      1.10s (flat, cum) 98.21%
 <span class=line>      1</span> <span class=deadsrc>       1.10s      1.10s           line1 </span><span class=asm>               1.10s      1.10s     1000:     instruction one                                                              <span class=unimportant>file1000.src:1</span>
@@ -77,7 +77,7 @@ Duration: 10s, Total samples = 1.12s (11.20%)<br>Total: 1.12s</div><h1>line1000<
 <span class=line>      6</span> <span class=nop>           .          .           line6 </span>
 <span class=line>      7</span> <span class=nop>           .          .           line7 </span>
 </pre>
-<h1>line3000</h1>testdata/file3000.src
+<h2>line3000</h2><p class="filename">testdata/file3000.src</p>
 <pre onClick="pprof_toggle_asm(event)">
   Total:        10ms      1.12s (flat, cum)   100%
 <span class=line>      1</span> <span class=nop>           .          .           line1 </span>
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/driver/webhtml.go b/src/cmd/vendor/github.com/google/pprof/internal/driver/webhtml.go
index 48f0fa1cfa..5d2821cd42 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/driver/webhtml.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/driver/webhtml.go
@@ -16,209 +16,268 @@ package driver
 
 import "html/template"
 
+import "github.com/google/pprof/third_party/d3"
+import "github.com/google/pprof/third_party/d3tip"
+import "github.com/google/pprof/third_party/d3flamegraph"
+
 // addTemplates adds a set of template definitions to templates.
 func addTemplates(templates *template.Template) {
+	template.Must(templates.Parse(`{{define "d3script"}}` + d3.JSSource + `{{end}}`))
+	template.Must(templates.Parse(`{{define "d3tipscript"}}` + d3tip.JSSource + `{{end}}`))
+	template.Must(templates.Parse(`{{define "d3flamegraphscript"}}` + d3flamegraph.JSSource + `{{end}}`))
+	template.Must(templates.Parse(`{{define "d3flamegraphcss"}}` + d3flamegraph.CSSSource + `{{end}}`))
 	template.Must(templates.Parse(`
 {{define "css"}}
 <style type="text/css">
-html {
-  height: 100%;
-  min-height: 100%;
-  margin: 0px;
+* {
+  margin: 0;
+  padding: 0;
+  box-sizing: border-box;
 }
-body {
-  margin: 0px;
-  width: 100%;
+html, body {
   height: 100%;
-  min-height: 100%;
-  overflow: hidden;
 }
-#graphcontainer {
+body {
+  font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
+  font-size: 13px;
+  line-height: 1.4;
   display: flex;
   flex-direction: column;
-  height: 100%;
-  min-height: 100%;
-  width: 100%;
-  min-width: 100%;
-  margin: 0px;
 }
-#graph {
-  flex: 1 1 auto;
-  overflow: hidden;
+a {
+  color: #2a66d9;
+}
+.header {
+  display: flex;
+  align-items: center;
+  height: 44px;
+  min-height: 44px;
+  background-color: #eee;
+  color: #212121;
+  padding: 0 1rem;
+}
+.header > div {
+  margin: 0 0.125em;
+}
+.header .title h1 {
+  font-size: 1.75em;
+  margin-right: 1rem;
+}
+.header .title a {
+  color: #212121;
+  text-decoration: none;
 }
-svg {
+.header .title a:hover {
+  text-decoration: underline;
+}
+.header .description {
   width: 100%;
-  height: auto;
+  text-align: right;
+  white-space: nowrap;
 }
-button {
-  margin-top: 5px;
-  margin-bottom: 5px;
+@media screen and (max-width: 799px) {
+  .header input {
+    display: none;
+  }
 }
-#detailtext {
+#detailsbox {
   display: none;
+  z-index: 1;
   position: fixed;
-  top: 20px;
-  right: 10px;
+  top: 40px;
+  right: 20px;
   background-color: #ffffff;
-  min-width: 160px;
-  border: 1px solid #888;
-  box-shadow: 4px 4px 4px 0px rgba(0,0,0,0.2);
-  z-index: 1;
-}
-#closedetails {
-  float: right;
-  margin: 2px;
+  box-shadow: 0 1px 5px rgba(0,0,0,.3);
+  line-height: 24px;
+  padding: 1em;
+  text-align: left;
 }
-#home {
-  font-size: 14pt;
-  padding-left: 0.5em;
-  padding-right: 0.5em;
-  float: right;
+.header input {
+  background: white url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' style='pointer-events:none;display:block;width:100%25;height:100%25;fill:#757575'%3E%3Cpath d='M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61.0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z'/%3E%3C/svg%3E") no-repeat 4px center/20px 20px;
+  border: 1px solid #d1d2d3;
+  border-radius: 2px 0 0 2px;
+  padding: 0.25em;
+  padding-left: 28px;
+  margin-left: 1em;
+  font-family: 'Roboto', 'Noto', sans-serif;
+  font-size: 1em;
+  line-height: 24px;
+  color: #212121;
 }
-.menubar {
-  display: inline-block;
-  background-color: #f8f8f8;
-  border: 1px solid #ccc;
-  width: 100%;
+.downArrow {
+  border-top: .36em solid #ccc;
+  border-left: .36em solid transparent;
+  border-right: .36em solid transparent;
+  margin-bottom: .05em;
+  margin-left: .5em;
+  transition: border-top-color 200ms;
 }
-.menu-header {
+.menu-item {
+  height: 100%;
+  text-transform: uppercase;
+  font-family: 'Roboto Medium', -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
   position: relative;
-  display: inline-block;
-  padding: 2px 2px;
-  font-size: 14pt;
 }
-.menu {
+.menu-item .menu-name:hover {
+  opacity: 0.75;
+}
+.menu-item .menu-name:hover .downArrow {
+  border-top-color: #666;
+}
+.menu-name {
+  height: 100%;
+  padding: 0 0.5em;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+}
+.submenu {
   display: none;
-  position: absolute;
-  background-color: #f8f8f8;
-  border: 1px solid #888;
-  box-shadow: 4px 4px 4px 0px rgba(0,0,0,0.2);
   z-index: 1;
-  margin-top: 2px;
+  margin-top: -4px;
+  min-width: 10em;
+  position: absolute;
   left: 0px;
-  min-width: 5em;
+  background-color: white;
+  box-shadow: 0 1px 5px rgba(0,0,0,.3);
+  font-size: 100%;
+  text-transform: none;
 }
-.menu-header, .menu {
-  cursor: default;
+.menu-item, .submenu {
   user-select: none;
   -moz-user-select: none;
   -ms-user-select: none;
   -webkit-user-select: none;
 }
-.menu hr {
-  background-color: #fff;
-  margin-top: 0px;
-  margin-bottom: 0px;
+.submenu hr {
+  border: 0;
+  border-top: 2px solid #eee;
 }
-.menu a, .menu button {
+.submenu a {
   display: block;
-  width: 100%;
-  margin: 0px;
-  padding: 2px 0px 2px 0px;
-  text-align: left;
+  padding: .5em 1em;
   text-decoration: none;
-  color: #000;
-  background-color: #f8f8f8;
-  font-size: 12pt;
-  border: none;
-}
-.menu-header:hover {
-  background-color: #ccc;
 }
-.menu a:hover, .menu button:hover {
-  background-color: #ccc;
+.submenu a:hover, .submenu a.active {
+  color: white;
+  background-color: #6b82d6;
 }
-.menu a.disabled {
+.submenu a.disabled {
   color: gray;
   pointer-events: none;
 }
-#searchbox {
-  margin-left: 10pt;
+
+#content {
+  overflow-y: scroll;
+  padding: 1em;
+}
+#top {
+  overflow-y: scroll;
 }
-#bodycontainer {
+#graph {
+  overflow: hidden;
+}
+#graph svg {
   width: 100%;
-  height: 100%;
-  max-height: 100%;
-  overflow: scroll;
-  padding-top: 5px;
+  height: auto;
+  padding: 10px;
+}
+#content.source .filename {
+  margin-top: 0;
+  margin-bottom: 1em;
+  font-size: 120%;
 }
-#toptable {
+#content.source pre {
+  margin-bottom: 3em;
+}
+table {
   border-spacing: 0px;
   width: 100%;
   padding-bottom: 1em;
+  white-space: nowrap;
 }
-#toptable tr th {
-  border-bottom: 1px solid black;
+table thead {
+  font-family: 'Roboto Medium', -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
+}
+table tr th {
+  background-color: #ddd;
   text-align: right;
-  padding-left: 1em;
-  padding-top: 0.2em;
-  padding-bottom: 0.2em;
+  padding: .3em .5em;
 }
-#toptable tr td {
-  padding-left: 1em;
-  font: monospace;
+table tr td {
+  padding: .3em .5em;
   text-align: right;
-  white-space: nowrap;
-  cursor: default;
 }
-#toptable tr th:nth-child(6),
-#toptable tr th:nth-child(7),
-#toptable tr td:nth-child(6),
-#toptable tr td:nth-child(7) {
+#top table tr th:nth-child(6),
+#top table tr th:nth-child(7),
+#top table tr td:nth-child(6),
+#top table tr td:nth-child(7) {
   text-align: left;
 }
-#toptable tr td:nth-child(6) {
-  max-width: 30em;  // Truncate very long names
+#top table tr td:nth-child(6) {
+  width: 100%;
+  text-overflow: ellipsis;
   overflow: hidden;
+  white-space: nowrap;
 }
 #flathdr1, #flathdr2, #cumhdr1, #cumhdr2, #namehdr {
   cursor: ns-resize;
 }
 .hilite {
-  background-color: #ccf;
+  background-color: #ebf5fb; 
+  font-weight: bold;
 }
 </style>
 {{end}}
 
 {{define "header"}}
-<div id="detailtext">
-<button id="closedetails">Close</button>
-{{range .Legend}}<div>{{.}}</div>{{end}}
+<div class="header">
+  <div class="title">
+    <h1><a href="/">pprof</a></h1>
+  </div>
+
+  <div id="view" class="menu-item">
+    <div class="menu-name">
+      View
+      <i class="downArrow"></i>
+    </div>
+    <div class="submenu">
+      <a title="{{.Help.top}}"  href="/top" id="topbtn">Top</a>
+      <a title="{{.Help.graph}}" href="/" id="graphbtn">Graph</a>
+      <a title="{{.Help.flamegraph}}" href="/flamegraph" id="flamegraph">Flame Graph</a>
+      <a title="{{.Help.peek}}" href="/peek" id="peek">Peek</a>
+      <a title="{{.Help.list}}" href="/source" id="list">Source</a>
+      <a title="{{.Help.disasm}}" href="/disasm" id="disasm">Disassemble</a>
+    </div>
+  </div>
+
+  <div id="refine" class="menu-item">
+    <div class="menu-name">
+      Refine
+      <i class="downArrow"></i>
+    </div>
+    <div class="submenu">
+      <a title="{{.Help.focus}}" href="{{.BaseURL}}" id="focus">Focus</a>
+      <a title="{{.Help.ignore}}" href="{{.BaseURL}}" id="ignore">Ignore</a>
+      <a title="{{.Help.hide}}" href="{{.BaseURL}}" id="hide">Hide</a>
+      <a title="{{.Help.show}}" href="{{.BaseURL}}" id="show">Show</a>
+      <hr>
+      <a title="{{.Help.reset}}" href="{{.BaseURL}}">Reset</a>
+    </div>
+  </div>
+
+  <div>
+    <input id="search" type="text" placeholder="Search regexp" autocomplete="off" autocapitalize="none" size=40>
+  </div>
+
+  <div class="description">
+    <a title="{{.Help.details}}" href="#" id="details">{{.Title}}</a>
+    <div id="detailsbox">
+      {{range .Legend}}<div>{{.}}</div>{{end}}
+    </div>
+  </div>
 </div>
 
-<div class="menubar">
-
-<div class="menu-header">
-View
-<div class="menu">
-<a title="{{.Help.top}}"  href="/top" id="topbtn">Top</a>
-<a title="{{.Help.graph}}" href="/" id="graphbtn">Graph</a>
-<a title="{{.Help.peek}}" href="/peek" id="peek">Peek</a>
-<a title="{{.Help.list}}" href="/source" id="list">Source</a>
-<a title="{{.Help.disasm}}" href="/disasm" id="disasm">Disassemble</a>
-<hr>
-<button title="{{.Help.details}}" id="details">Details</button>
-</div>
-</div>
-
-<div class="menu-header">
-Refine
-<div class="menu">
-<a title="{{.Help.focus}}" href="{{.BaseURL}}" id="focus">Focus</a>
-<a title="{{.Help.ignore}}" href="{{.BaseURL}}" id="ignore">Ignore</a>
-<a title="{{.Help.hide}}" href="{{.BaseURL}}" id="hide">Hide</a>
-<a title="{{.Help.show}}" href="{{.BaseURL}}" id="show">Show</a>
-<hr>
-<a title="{{.Help.reset}}" href="{{.BaseURL}}">Reset</a>
-</div>
-</div>
-
-<input id="searchbox" type="text" placeholder="Search regexp" autocomplete="off" autocapitalize="none" size=40>
-
-<span id="home">{{.Title}}</span>
-
-</div> <!-- menubar -->
-
 <div id="errors">{{range .Errors}}<div>{{.}}</div>{{end}}</div>
 {{end}}
 
@@ -226,21 +285,17 @@ Refine
 <!DOCTYPE html>
 <html>
 <head>
-<meta charset="utf-8">
-<title>{{.Title}}</title>
-{{template "css" .}}
+  <meta charset="utf-8">
+  <title>{{.Title}}</title>
+  {{template "css" .}}
 </head>
 <body>
-
-{{template "header" .}}
-<div id="graphcontainer">
-<div id="graph">
-{{.HTMLBody}}
-</div>
-
-</div>
-{{template "script" .}}
-<script>viewer({{.BaseURL}}, {{.Nodes}})</script>
+  {{template "header" .}}
+  <div id="graph">
+    {{.HTMLBody}}
+  </div>
+  {{template "script" .}}
+  <script>viewer({{.BaseURL}}, {{.Nodes}});</script>
 </body>
 </html>
 {{end}}
@@ -253,58 +308,58 @@ function initPanAndZoom(svg, clickHandler) {
   'use strict';
 
   // Current mouse/touch handling mode
-  const IDLE = 0
-  const MOUSEPAN = 1
-  const TOUCHPAN = 2
-  const TOUCHZOOM = 3
-  let mode = IDLE
+  const IDLE = 0;
+  const MOUSEPAN = 1;
+  const TOUCHPAN = 2;
+  const TOUCHZOOM = 3;
+  let mode = IDLE;
 
   // State needed to implement zooming.
-  let currentScale = 1.0
-  const initWidth = svg.viewBox.baseVal.width
-  const initHeight = svg.viewBox.baseVal.height
+  let currentScale = 1.0;
+  const initWidth = svg.viewBox.baseVal.width;
+  const initHeight = svg.viewBox.baseVal.height;
 
   // State needed to implement panning.
-  let panLastX = 0      // Last event X coordinate
-  let panLastY = 0      // Last event Y coordinate
-  let moved = false     // Have we seen significant movement
-  let touchid = null    // Current touch identifier
+  let panLastX = 0;      // Last event X coordinate
+  let panLastY = 0;      // Last event Y coordinate
+  let moved = false;     // Have we seen significant movement
+  let touchid = null;    // Current touch identifier
 
   // State needed for pinch zooming
-  let touchid2 = null     // Second id for pinch zooming
-  let initGap = 1.0       // Starting gap between two touches
-  let initScale = 1.0     // currentScale when pinch zoom started
-  let centerPoint = null  // Center point for scaling
+  let touchid2 = null;     // Second id for pinch zooming
+  let initGap = 1.0;       // Starting gap between two touches
+  let initScale = 1.0;     // currentScale when pinch zoom started
+  let centerPoint = null;  // Center point for scaling
 
   // Convert event coordinates to svg coordinates.
   function toSvg(x, y) {
-    const p = svg.createSVGPoint()
-    p.x = x
-    p.y = y
-    let m = svg.getCTM()
-    if (m == null) m = svg.getScreenCTM()  // Firefox workaround.
-    return p.matrixTransform(m.inverse())
+    const p = svg.createSVGPoint();
+    p.x = x;
+    p.y = y;
+    let m = svg.getCTM();
+    if (m == null) m = svg.getScreenCTM(); // Firefox workaround.
+    return p.matrixTransform(m.inverse());
   }
 
   // Change the scaling for the svg to s, keeping the point denoted
   // by u (in svg coordinates]) fixed at the same screen location.
   function rescale(s, u) {
     // Limit to a good range.
-    if (s < 0.2) s = 0.2
-    if (s > 10.0) s = 10.0
+    if (s < 0.2) s = 0.2;
+    if (s > 10.0) s = 10.0;
 
-    currentScale = s
+    currentScale = s;
 
     // svg.viewBox defines the visible portion of the user coordinate
     // system.  So to magnify by s, divide the visible portion by s,
     // which will then be stretched to fit the viewport.
-    const vb = svg.viewBox
-    const w1 = vb.baseVal.width
-    const w2 = initWidth / s
-    const h1 = vb.baseVal.height
-    const h2 = initHeight / s
-    vb.baseVal.width = w2
-    vb.baseVal.height = h2
+    const vb = svg.viewBox;
+    const w1 = vb.baseVal.width;
+    const w2 = initWidth / s;
+    const h1 = vb.baseVal.height;
+    const h2 = initHeight / s;
+    vb.baseVal.width = w2;
+    vb.baseVal.height = h2;
 
     // We also want to adjust vb.baseVal.x so that u.x remains at same
     // screen X coordinate.  In other words, want to change it from x1 to x2
@@ -313,154 +368,154 @@ function initPanAndZoom(svg, clickHandler) {
     // Simplifying that, we get
     //     (u.x - x1) * (w2 / w1) = u.x - x2
     //     x2 = u.x - (u.x - x1) * (w2 / w1)
-    vb.baseVal.x = u.x - (u.x - vb.baseVal.x) * (w2 / w1)
-    vb.baseVal.y = u.y - (u.y - vb.baseVal.y) * (h2 / h1)
+    vb.baseVal.x = u.x - (u.x - vb.baseVal.x) * (w2 / w1);
+    vb.baseVal.y = u.y - (u.y - vb.baseVal.y) * (h2 / h1);
   }
 
   function handleWheel(e) {
-    if (e.deltaY == 0) return
+    if (e.deltaY == 0) return;
     // Change scale factor by 1.1 or 1/1.1
     rescale(currentScale * (e.deltaY < 0 ? 1.1 : (1/1.1)),
-            toSvg(e.offsetX, e.offsetY))
+            toSvg(e.offsetX, e.offsetY));
   }
 
   function setMode(m) {
-    mode = m
-    touchid = null
-    touchid2 = null
+    mode = m;
+    touchid = null;
+    touchid2 = null;
   }
 
   function panStart(x, y) {
-    moved = false
-    panLastX = x
-    panLastY = y
+    moved = false;
+    panLastX = x;
+    panLastY = y;
   }
 
   function panMove(x, y) {
-    let dx = x - panLastX
-    let dy = y - panLastY
-    if (Math.abs(dx) <= 2 && Math.abs(dy) <= 2) return  // Ignore tiny moves
+    let dx = x - panLastX;
+    let dy = y - panLastY;
+    if (Math.abs(dx) <= 2 && Math.abs(dy) <= 2) return; // Ignore tiny moves
 
-    moved = true
-    panLastX = x
-    panLastY = y
+    moved = true;
+    panLastX = x;
+    panLastY = y;
 
     // Firefox workaround: get dimensions from parentNode.
-    const swidth = svg.clientWidth || svg.parentNode.clientWidth
-    const sheight = svg.clientHeight || svg.parentNode.clientHeight
+    const swidth = svg.clientWidth || svg.parentNode.clientWidth;
+    const sheight = svg.clientHeight || svg.parentNode.clientHeight;
 
     // Convert deltas from screen space to svg space.
-    dx *= (svg.viewBox.baseVal.width / swidth)
-    dy *= (svg.viewBox.baseVal.height / sheight)
+    dx *= (svg.viewBox.baseVal.width / swidth);
+    dy *= (svg.viewBox.baseVal.height / sheight);
 
-    svg.viewBox.baseVal.x -= dx
-    svg.viewBox.baseVal.y -= dy
+    svg.viewBox.baseVal.x -= dx;
+    svg.viewBox.baseVal.y -= dy;
   }
 
   function handleScanStart(e) {
-    if (e.button != 0) return  // Do not catch right-clicks etc.
-    setMode(MOUSEPAN)
-    panStart(e.clientX, e.clientY)
-    e.preventDefault()
-    svg.addEventListener("mousemove", handleScanMove)
+    if (e.button != 0) return; // Do not catch right-clicks etc.
+    setMode(MOUSEPAN);
+    panStart(e.clientX, e.clientY);
+    e.preventDefault();
+    svg.addEventListener('mousemove', handleScanMove);
   }
 
   function handleScanMove(e) {
     if (e.buttons == 0) {
       // Missed an end event, perhaps because mouse moved outside window.
-      setMode(IDLE)
-      svg.removeEventListener("mousemove", handleScanMove)
-      return
+      setMode(IDLE);
+      svg.removeEventListener('mousemove', handleScanMove);
+      return;
     }
-    if (mode == MOUSEPAN) panMove(e.clientX, e.clientY)
+    if (mode == MOUSEPAN) panMove(e.clientX, e.clientY);
   }
 
   function handleScanEnd(e) {
-    if (mode == MOUSEPAN) panMove(e.clientX, e.clientY)
-    setMode(IDLE)
-    svg.removeEventListener("mousemove", handleScanMove)
-    if (!moved) clickHandler(e.target)
+    if (mode == MOUSEPAN) panMove(e.clientX, e.clientY);
+    setMode(IDLE);
+    svg.removeEventListener('mousemove', handleScanMove);
+    if (!moved) clickHandler(e.target);
   }
 
   // Find touch object with specified identifier.
   function findTouch(tlist, id) {
     for (const t of tlist) {
-      if (t.identifier == id) return t
+      if (t.identifier == id) return t;
     }
-    return null
+    return null;
   }
 
- // Return distance between two touch points
+  // Return distance between two touch points
   function touchGap(t1, t2) {
-    const dx = t1.clientX - t2.clientX
-    const dy = t1.clientY - t2.clientY
-    return Math.hypot(dx, dy)
+    const dx = t1.clientX - t2.clientX;
+    const dy = t1.clientY - t2.clientY;
+    return Math.hypot(dx, dy);
   }
 
   function handleTouchStart(e) {
     if (mode == IDLE && e.changedTouches.length == 1) {
       // Start touch based panning
-      const t = e.changedTouches[0]
-      setMode(TOUCHPAN)
-      touchid = t.identifier
-      panStart(t.clientX, t.clientY)
-      e.preventDefault()
+      const t = e.changedTouches[0];
+      setMode(TOUCHPAN);
+      touchid = t.identifier;
+      panStart(t.clientX, t.clientY);
+      e.preventDefault();
     } else if (mode == TOUCHPAN && e.touches.length == 2) {
       // Start pinch zooming
-      setMode(TOUCHZOOM)
-      const t1 = e.touches[0]
-      const t2 = e.touches[1]
-      touchid = t1.identifier
-      touchid2 = t2.identifier
-      initScale = currentScale
-      initGap = touchGap(t1, t2)
+      setMode(TOUCHZOOM);
+      const t1 = e.touches[0];
+      const t2 = e.touches[1];
+      touchid = t1.identifier;
+      touchid2 = t2.identifier;
+      initScale = currentScale;
+      initGap = touchGap(t1, t2);
       centerPoint = toSvg((t1.clientX + t2.clientX) / 2,
-                          (t1.clientY + t2.clientY) / 2)
-      e.preventDefault()
+                          (t1.clientY + t2.clientY) / 2);
+      e.preventDefault();
     }
   }
 
   function handleTouchMove(e) {
     if (mode == TOUCHPAN) {
-      const t = findTouch(e.changedTouches, touchid)
-      if (t == null) return
+      const t = findTouch(e.changedTouches, touchid);
+      if (t == null) return;
       if (e.touches.length != 1) {
-        setMode(IDLE)
-        return
+        setMode(IDLE);
+        return;
       }
-      panMove(t.clientX, t.clientY)
-      e.preventDefault()
+      panMove(t.clientX, t.clientY);
+      e.preventDefault();
     } else if (mode == TOUCHZOOM) {
       // Get two touches; new gap; rescale to ratio.
-      const t1 = findTouch(e.touches, touchid)
-      const t2 = findTouch(e.touches, touchid2)
-      if (t1 == null || t2 == null) return
-      const gap = touchGap(t1, t2)
-      rescale(initScale * gap / initGap, centerPoint)
-      e.preventDefault()
+      const t1 = findTouch(e.touches, touchid);
+      const t2 = findTouch(e.touches, touchid2);
+      if (t1 == null || t2 == null) return;
+      const gap = touchGap(t1, t2);
+      rescale(initScale * gap / initGap, centerPoint);
+      e.preventDefault();
     }
   }
 
   function handleTouchEnd(e) {
     if (mode == TOUCHPAN) {
-      const t = findTouch(e.changedTouches, touchid)
-      if (t == null) return
-      panMove(t.clientX, t.clientY)
-      setMode(IDLE)
-      e.preventDefault()
-      if (!moved) clickHandler(t.target)
+      const t = findTouch(e.changedTouches, touchid);
+      if (t == null) return;
+      panMove(t.clientX, t.clientY);
+      setMode(IDLE);
+      e.preventDefault();
+      if (!moved) clickHandler(t.target);
     } else if (mode == TOUCHZOOM) {
-      setMode(IDLE)
-      e.preventDefault()
+      setMode(IDLE);
+      e.preventDefault();
     }
   }
 
-  svg.addEventListener("mousedown", handleScanStart)
-  svg.addEventListener("mouseup", handleScanEnd)
-  svg.addEventListener("touchstart", handleTouchStart)
-  svg.addEventListener("touchmove", handleTouchMove)
-  svg.addEventListener("touchend", handleTouchEnd)
-  svg.addEventListener("wheel", handleWheel, true)
+  svg.addEventListener('mousedown', handleScanStart);
+  svg.addEventListener('mouseup', handleScanEnd);
+  svg.addEventListener('touchstart', handleTouchStart);
+  svg.addEventListener('touchmove', handleTouchMove);
+  svg.addEventListener('touchend', handleTouchEnd);
+  svg.addEventListener('wheel', handleWheel, true);
 }
 
 function initMenus() {
@@ -471,41 +526,42 @@ function initMenus() {
 
   function cancelActiveMenu() {
     if (activeMenu == null) return;
-    activeMenu.style.display = "none";
+    activeMenu.style.display = 'none';
     activeMenu = null;
     activeMenuHdr = null;
   }
 
   // Set click handlers on every menu header.
-  for (const menu of document.getElementsByClassName("menu")) {
+  for (const menu of document.getElementsByClassName('submenu')) {
     const hdr = menu.parentElement;
     if (hdr == null) return;
+    if (hdr.classList.contains('disabled')) return;
     function showMenu(e) {
       // menu is a child of hdr, so this event can fire for clicks
       // inside menu. Ignore such clicks.
-      if (e.target != hdr) return;
+      if (e.target.parentElement != hdr) return;
       activeMenu = menu;
       activeMenuHdr = hdr;
-      menu.style.display = "block";
+      menu.style.display = 'block';
     }
-    hdr.addEventListener("mousedown", showMenu);
-    hdr.addEventListener("touchstart", showMenu);
+    hdr.addEventListener('mousedown', showMenu);
+    hdr.addEventListener('touchstart', showMenu);
   }
 
   // If there is an active menu and a down event outside, retract the menu.
-  for (const t of ["mousedown", "touchstart"]) {
+  for (const t of ['mousedown', 'touchstart']) {
     document.addEventListener(t, (e) => {
       // Note: to avoid unnecessary flicker, if the down event is inside
       // the active menu header, do not retract the menu.
-      if (activeMenuHdr != e.target.closest(".menu-header")) {
+      if (activeMenuHdr != e.target.closest('.menu-item')) {
         cancelActiveMenu();
       }
     }, { passive: true, capture: true });
   }
 
   // If there is an active menu and an up event inside, retract the menu.
-  document.addEventListener("mouseup", (e) => {
-    if (activeMenu == e.target.closest(".menu")) {
+  document.addEventListener('mouseup', (e) => {
+    if (activeMenu == e.target.closest('.submenu')) {
       cancelActiveMenu();
     }
   }, { passive: true, capture: true });
@@ -515,282 +571,283 @@ function viewer(baseUrl, nodes) {
   'use strict';
 
   // Elements
-  const search = document.getElementById("searchbox")
-  const graph0 = document.getElementById("graph0")
-  const svg = (graph0 == null ? null : graph0.parentElement)
-  const toptable = document.getElementById("toptable")
-
-  let regexpActive = false
-  let selected = new Map()
-  let origFill = new Map()
-  let searchAlarm = null
-  let buttonsEnabled = true
-
-  function handleDetails() {
-    const detailsText = document.getElementById("detailtext")
-    if (detailsText != null) detailsText.style.display = "block"
-  }
-
-  function handleCloseDetails() {
-    const detailsText = document.getElementById("detailtext")
-    if (detailsText != null) detailsText.style.display = "none"
+  const search = document.getElementById('search');
+  const graph0 = document.getElementById('graph0');
+  const svg = (graph0 == null ? null : graph0.parentElement);
+  const toptable = document.getElementById('toptable');
+
+  let regexpActive = false;
+  let selected = new Map();
+  let origFill = new Map();
+  let searchAlarm = null;
+  let buttonsEnabled = true;
+
+  function handleDetails(e) {
+    e.preventDefault();
+    const detailsText = document.getElementById('detailsbox');
+    if (detailsText != null) {
+      if (detailsText.style.display === 'block') {
+        detailsText.style.display = 'none';
+      } else {
+        detailsText.style.display = 'block';
+      }
+    }
   }
 
   function handleKey(e) {
-    if (e.keyCode != 13) return
+    if (e.keyCode != 13) return;
     window.location.href =
-        updateUrl(new URL({{.BaseURL}}, window.location.href), "f")
-    e.preventDefault()
+        updateUrl(new URL({{.BaseURL}}, window.location.href), 'f');
+    e.preventDefault();
   }
 
   function handleSearch() {
     // Delay expensive processing so a flurry of key strokes is handled once.
     if (searchAlarm != null) {
-      clearTimeout(searchAlarm)
+      clearTimeout(searchAlarm);
     }
-    searchAlarm = setTimeout(selectMatching, 300)
+    searchAlarm = setTimeout(selectMatching, 300);
 
-    regexpActive = true
-    updateButtons()
+    regexpActive = true;
+    updateButtons();
   }
 
   function selectMatching() {
-    searchAlarm = null
-    let re = null
-    if (search.value != "") {
+    searchAlarm = null;
+    let re = null;
+    if (search.value != '') {
       try {
-        re = new RegExp(search.value)
+        re = new RegExp(search.value);
       } catch (e) {
         // TODO: Display error state in search box
-        return
+        return;
       }
     }
 
     function match(text) {
-      return re != null && re.test(text)
+      return re != null && re.test(text);
     }
 
     // drop currently selected items that do not match re.
     selected.forEach(function(v, n) {
       if (!match(nodes[n])) {
-        unselect(n, document.getElementById("node" + n))
+        unselect(n, document.getElementById('node' + n));
       }
     })
 
     // add matching items that are not currently selected.
     for (let n = 0; n < nodes.length; n++) {
       if (!selected.has(n) && match(nodes[n])) {
-        select(n, document.getElementById("node" + n))
+        select(n, document.getElementById('node' + n));
       }
     }
 
-    updateButtons()
+    updateButtons();
   }
 
   function toggleSvgSelect(elem) {
     // Walk up to immediate child of graph0
     while (elem != null && elem.parentElement != graph0) {
-      elem = elem.parentElement
+      elem = elem.parentElement;
     }
-    if (!elem) return
+    if (!elem) return;
 
     // Disable regexp mode.
-    regexpActive = false
+    regexpActive = false;
 
-    const n = nodeId(elem)
-    if (n < 0) return
+    const n = nodeId(elem);
+    if (n < 0) return;
     if (selected.has(n)) {
-      unselect(n, elem)
+      unselect(n, elem);
     } else {
-      select(n, elem)
+      select(n, elem);
     }
-    updateButtons()
+    updateButtons();
   }
 
   function unselect(n, elem) {
-    if (elem == null) return
-    selected.delete(n)
-    setBackground(elem, false)
+    if (elem == null) return;
+    selected.delete(n);
+    setBackground(elem, false);
   }
 
   function select(n, elem) {
-    if (elem == null) return
-    selected.set(n, true)
-    setBackground(elem, true)
+    if (elem == null) return;
+    selected.set(n, true);
+    setBackground(elem, true);
   }
 
   function nodeId(elem) {
-    const id = elem.id
-    if (!id) return -1
-    if (!id.startsWith("node")) return -1
-    const n = parseInt(id.slice(4), 10)
-    if (isNaN(n)) return -1
-    if (n < 0 || n >= nodes.length) return -1
-    return n
+    const id = elem.id;
+    if (!id) return -1;
+    if (!id.startsWith('node')) return -1;
+    const n = parseInt(id.slice(4), 10);
+    if (isNaN(n)) return -1;
+    if (n < 0 || n >= nodes.length) return -1;
+    return n;
   }
 
   function setBackground(elem, set) {
     // Handle table row highlighting.
-    if (elem.nodeName == "TR") {
-      elem.classList.toggle("hilite", set)
-      return
+    if (elem.nodeName == 'TR') {
+      elem.classList.toggle('hilite', set);
+      return;
     }
 
     // Handle svg element highlighting.
-    const p = findPolygon(elem)
+    const p = findPolygon(elem);
     if (p != null) {
       if (set) {
-        origFill.set(p, p.style.fill)
-        p.style.fill = "#ccccff"
+        origFill.set(p, p.style.fill);
+        p.style.fill = '#ccccff';
       } else if (origFill.has(p)) {
-        p.style.fill = origFill.get(p)
+        p.style.fill = origFill.get(p);
       }
     }
   }
 
   function findPolygon(elem) {
-    if (elem.localName == "polygon") return elem
+    if (elem.localName == 'polygon') return elem;
     for (const c of elem.children) {
-      const p = findPolygon(c)
-      if (p != null) return p
+      const p = findPolygon(c);
+      if (p != null) return p;
     }
-    return null
+    return null;
   }
 
   // convert a string to a regexp that matches that string.
   function quotemeta(str) {
-    return str.replace(/([\\\.?+*\[\](){}|^$])/g, '\\$1')
+    return str.replace(/([\\\.?+*\[\](){}|^$])/g, '\\$1');
   }
 
   // Update id's href to reflect current selection whenever it is
   // liable to be followed.
   function makeLinkDynamic(id) {
-    const elem = document.getElementById(id)
-    if (elem == null) return
+    const elem = document.getElementById(id);
+    if (elem == null) return;
 
-    // Most links copy current selection into the "f" parameter,
+    // Most links copy current selection into the 'f' parameter,
     // but Refine menu links are different.
-    let param = "f"
-    if (id == "ignore") param = "i"
-    if (id == "hide") param = "h"
-    if (id == "show") param = "s"
+    let param = 'f';
+    if (id == 'ignore') param = 'i';
+    if (id == 'hide') param = 'h';
+    if (id == 'show') param = 's';
 
     // We update on mouseenter so middle-click/right-click work properly.
-    elem.addEventListener("mouseenter", updater)
-    elem.addEventListener("touchstart", updater)
+    elem.addEventListener('mouseenter', updater);
+    elem.addEventListener('touchstart', updater);
 
     function updater() {
-      elem.href = updateUrl(new URL(elem.href), param)
+      elem.href = updateUrl(new URL(elem.href), param);
     }
   }
 
   // Update URL to reflect current selection.
   function updateUrl(url, param) {
-    url.hash = ""
+    url.hash = '';
 
     // The selection can be in one of two modes: regexp-based or
     // list-based.  Construct regular expression depending on mode.
     let re = regexpActive
-        ? search.value
-        : Array.from(selected.keys()).map(key => quotemeta(nodes[key])).join("|")
+      ? search.value
+      : Array.from(selected.keys()).map(key => quotemeta(nodes[key])).join('|');
 
     // Copy params from this page's URL.
-    const params = url.searchParams
+    const params = url.searchParams;
     for (const p of new URLSearchParams(window.location.search)) {
-      params.set(p[0], p[1])
+      params.set(p[0], p[1]);
     }
 
-    if (re != "") {
+    if (re != '') {
       // For focus/show, forget old parameter.  For others, add to re.
-      if (param != "f" && param != "s" && params.has(param)) {
-        const old = params.get(param)
-         if (old != "") {
-          re += "|" + old
+      if (param != 'f' && param != 's' && params.has(param)) {
+        const old = params.get(param);
+         if (old != '') {
+          re += '|' + old;
         }
       }
-      params.set(param, re)
+      params.set(param, re);
     } else {
-      params.delete(param)
+      params.delete(param);
     }
 
-    return url.toString()
+    return url.toString();
   }
 
   function handleTopClick(e) {
     // Walk back until we find TR and then get the Name column (index 5)
-    let elem = e.target
-    while (elem != null && elem.nodeName != "TR") {
-      elem = elem.parentElement
+    let elem = e.target;
+    while (elem != null && elem.nodeName != 'TR') {
+      elem = elem.parentElement;
     }
-    if (elem == null || elem.children.length < 6) return
+    if (elem == null || elem.children.length < 6) return;
 
-    e.preventDefault()
-    const tr = elem
-    const td = elem.children[5]
-    if (td.nodeName != "TD") return
-    const name = td.innerText
-    const index = nodes.indexOf(name)
-    if (index < 0) return
+    e.preventDefault();
+    const tr = elem;
+    const td = elem.children[5];
+    if (td.nodeName != 'TD') return;
+    const name = td.innerText;
+    const index = nodes.indexOf(name);
+    if (index < 0) return;
 
     // Disable regexp mode.
-    regexpActive = false
+    regexpActive = false;
 
     if (selected.has(index)) {
-      unselect(index, elem)
+      unselect(index, elem);
     } else {
-      select(index, elem)
+      select(index, elem);
     }
-    updateButtons()
+    updateButtons();
   }
 
   function updateButtons() {
-    const enable = (search.value != "" || selected.size != 0)
-    if (buttonsEnabled == enable) return
-    buttonsEnabled = enable
-    for (const id of ["focus", "ignore", "hide", "show"]) {
-      const link = document.getElementById(id)
+    const enable = (search.value != '' || selected.size != 0);
+    if (buttonsEnabled == enable) return;
+    buttonsEnabled = enable;
+    for (const id of ['focus', 'ignore', 'hide', 'show']) {
+      const link = document.getElementById(id);
       if (link != null) {
-        link.classList.toggle("disabled", !enable)
+        link.classList.toggle('disabled', !enable);
       }
     }
   }
 
   // Initialize button states
-  updateButtons()
+  updateButtons();
 
   // Setup event handlers
-  initMenus()
+  initMenus();
   if (svg != null) {
-    initPanAndZoom(svg, toggleSvgSelect)
+    initPanAndZoom(svg, toggleSvgSelect);
   }
   if (toptable != null) {
-    toptable.addEventListener("mousedown", handleTopClick)
-    toptable.addEventListener("touchstart", handleTopClick)
+    toptable.addEventListener('mousedown', handleTopClick);
+    toptable.addEventListener('touchstart', handleTopClick);
   }
 
-  const ids = ["topbtn", "graphbtn", "peek", "list", "disasm",
-               "focus", "ignore", "hide", "show"]
-  ids.forEach(makeLinkDynamic)
+  const ids = ['topbtn', 'graphbtn', 'peek', 'list', 'disasm',
+               'focus', 'ignore', 'hide', 'show'];
+  ids.forEach(makeLinkDynamic);
 
   // Bind action to button with specified id.
   function addAction(id, action) {
-    const btn = document.getElementById(id)
+    const btn = document.getElementById(id);
     if (btn != null) {
-      btn.addEventListener("click", action)
-      btn.addEventListener("touchstart", action)
+      btn.addEventListener('click', action);
+      btn.addEventListener('touchstart', action);
     }
   }
 
-  addAction("details", handleDetails)
-  addAction("closedetails", handleCloseDetails)
+  addAction('details', handleDetails);
 
-  search.addEventListener("input", handleSearch)
-  search.addEventListener("keydown", handleKey)
+  search.addEventListener('input', handleSearch);
+  search.addEventListener('keydown', handleKey);
 
   // Give initial focus to main container so it can be scrolled using keys.
-  const main = document.getElementById("bodycontainer")
+  const main = document.getElementById('bodycontainer');
   if (main) {
-    main.focus()
+    main.focus();
   }
 }
 </script>
@@ -800,116 +857,115 @@ function viewer(baseUrl, nodes) {
 <!DOCTYPE html>
 <html>
 <head>
-<meta charset="utf-8">
-<title>{{.Title}}</title>
-{{template "css" .}}
-<style type="text/css">
-</style>
+  <meta charset="utf-8">
+  <title>{{.Title}}</title>
+  {{template "css" .}}
+  <style type="text/css">
+  </style>
 </head>
 <body>
+  {{template "header" .}}
+  <div id="top">
+    <table id="toptable">
+      <thead>
+        <tr>
+          <th id="flathdr1">Flat</th>
+          <th id="flathdr2">Flat%</th>
+          <th>Sum%</th>
+          <th id="cumhdr1">Cum</th>
+          <th id="cumhdr2">Cum%</th>
+          <th id="namehdr">Name</th>
+          <th>Inlined?</th>
+        </tr>
+      </thead>
+      <tbody id="rows"></tbody>
+    </table>
+  </div>
+  {{template "script" .}}
+  <script>
+    function makeTopTable(total, entries) {
+      const rows = document.getElementById('rows');
+      if (rows == null) return;
+
+      // Store initial index in each entry so we have stable node ids for selection.
+      for (let i = 0; i < entries.length; i++) {
+        entries[i].Id = 'node' + i;
+      }
 
-{{template "header" .}}
-
-<div id="bodycontainer">
-<table id="toptable">
-<tr>
-<th id="flathdr1">Flat
-<th id="flathdr2">Flat%
-<th>Sum%
-<th id="cumhdr1">Cum
-<th id="cumhdr2">Cum%
-<th id="namehdr">Name
-<th>Inlined?</tr>
-<tbody id="rows">
-</tbody>
-</table>
-</div>
-
-{{template "script" .}}
-<script>
-function makeTopTable(total, entries) {
-  const rows = document.getElementById("rows")
-  if (rows == null) return
-
-  // Store initial index in each entry so we have stable node ids for selection.
-  for (let i = 0; i < entries.length; i++) {
-    entries[i].Id = "node" + i
-  }
+      // Which column are we currently sorted by and in what order?
+      let currentColumn = '';
+      let descending = false;
+      sortBy('Flat');
+
+      function sortBy(column) {
+        // Update sort criteria
+        if (column == currentColumn) {
+          descending = !descending; // Reverse order
+        } else {
+          currentColumn = column;
+          descending = (column != 'Name');
+        }
 
-  // Which column are we currently sorted by and in what order?
-  let currentColumn = ""
-  let descending = false
-  sortBy("Flat")
+        // Sort according to current criteria.
+        function cmp(a, b) {
+          const av = a[currentColumn];
+          const bv = b[currentColumn];
+          if (av < bv) return -1;
+          if (av > bv) return +1;
+          return 0;
+        }
+        entries.sort(cmp);
+        if (descending) entries.reverse();
 
-  function sortBy(column) {
-    // Update sort criteria
-    if (column == currentColumn) {
-      descending = !descending  // Reverse order
-    } else {
-      currentColumn = column
-      descending = (column != "Name")
-    }
+        function addCell(tr, val) {
+          const td = document.createElement('td');
+          td.textContent = val;
+          tr.appendChild(td);
+        }
 
-    // Sort according to current criteria.
-    function cmp(a, b) {
-      const av = a[currentColumn]
-      const bv = b[currentColumn]
-      if (av < bv) return -1
-      if (av > bv) return +1
-      return 0
-    }
-    entries.sort(cmp)
-    if (descending) entries.reverse()
+        function percent(v) {
+          return (v * 100.0 / total).toFixed(2) + '%';
+        }
 
-    function addCell(tr, val) {
-      const td = document.createElement('td')
-      td.textContent = val
-      tr.appendChild(td)
-    }
+        // Generate rows
+        const fragment = document.createDocumentFragment();
+        let sum = 0;
+        for (const row of entries) {
+          const tr = document.createElement('tr');
+          tr.id = row.Id;
+          sum += row.Flat;
+          addCell(tr, row.FlatFormat);
+          addCell(tr, percent(row.Flat));
+          addCell(tr, percent(sum));
+          addCell(tr, row.CumFormat);
+          addCell(tr, percent(row.Cum));
+          addCell(tr, row.Name);
+          addCell(tr, row.InlineLabel);
+          fragment.appendChild(tr);
+        }
 
-    function percent(v) {
-      return (v * 100.0 / total).toFixed(2) + "%"
-    }
+        rows.textContent = ''; // Remove old rows
+        rows.appendChild(fragment);
+      }
 
-    // Generate rows
-    const fragment = document.createDocumentFragment()
-    let sum = 0
-    for (const row of entries) {
-      const tr = document.createElement('tr')
-      tr.id = row.Id
-      sum += row.Flat
-      addCell(tr, row.FlatFormat)
-      addCell(tr, percent(row.Flat))
-      addCell(tr, percent(sum))
-      addCell(tr, row.CumFormat)
-      addCell(tr, percent(row.Cum))
-      addCell(tr, row.Name)
-      addCell(tr, row.InlineLabel)
-      fragment.appendChild(tr)
+      // Make different column headers trigger sorting.
+      function bindSort(id, column) {
+        const hdr = document.getElementById(id);
+        if (hdr == null) return;
+        const fn = function() { sortBy(column) };
+        hdr.addEventListener('click', fn);
+        hdr.addEventListener('touch', fn);
+      }
+      bindSort('flathdr1', 'Flat');
+      bindSort('flathdr2', 'Flat');
+      bindSort('cumhdr1', 'Cum');
+      bindSort('cumhdr2', 'Cum');
+      bindSort('namehdr', 'Name');
     }
 
-    rows.textContent = ''  // Remove old rows
-    rows.appendChild(fragment)
-  }
-
-  // Make different column headers trigger sorting.
-  function bindSort(id, column) {
-    const hdr = document.getElementById(id)
-    if (hdr == null) return
-    const fn = function() { sortBy(column) }
-    hdr.addEventListener("click", fn)
-    hdr.addEventListener("touch", fn)
-  }
-  bindSort("flathdr1", "Flat")
-  bindSort("flathdr2", "Flat")
-  bindSort("cumhdr1", "Cum")
-  bindSort("cumhdr2", "Cum")
-  bindSort("namehdr", "Name")
-}
-
-viewer({{.BaseURL}}, {{.Nodes}})
-makeTopTable({{.Total}}, {{.Top}})
-</script>
+    viewer({{.BaseURL}}, {{.Nodes}});
+    makeTopTable({{.Total}}, {{.Top}});
+  </script>
 </body>
 </html>
 {{end}}
@@ -918,22 +974,19 @@ makeTopTable({{.Total}}, {{.Top}})
 <!DOCTYPE html>
 <html>
 <head>
-<meta charset="utf-8">
-<title>{{.Title}}</title>
-{{template "css" .}}
-{{template "weblistcss" .}}
-{{template "weblistjs" .}}
+  <meta charset="utf-8">
+  <title>{{.Title}}</title>
+  {{template "css" .}}
+  {{template "weblistcss" .}}
+  {{template "weblistjs" .}}
 </head>
 <body>
-
-{{template "header" .}}
-
-<div id="bodycontainer">
-{{.HTMLBody}}
-</div>
-
-{{template "script" .}}
-<script>viewer({{.BaseURL}}, null)</script>
+  {{template "header" .}}
+  <div id="content" class="source">
+    {{.HTMLBody}}
+  </div>
+  {{template "script" .}}
+  <script>viewer({{.BaseURL}}, null);</script>
 </body>
 </html>
 {{end}}
@@ -942,22 +995,131 @@ makeTopTable({{.Total}}, {{.Top}})
 <!DOCTYPE html>
 <html>
 <head>
-<meta charset="utf-8">
-<title>{{.Title}}</title>
-{{template "css" .}}
+  <meta charset="utf-8">
+  <title>{{.Title}}</title>
+  {{template "css" .}}
+</head>
+<body>
+  {{template "header" .}}
+  <div id="content">
+    <pre>
+      {{.TextBody}}
+    </pre>
+  </div>
+  {{template "script" .}}
+  <script>viewer({{.BaseURL}}, null);</script>
+</body>
+</html>
+{{end}}
+
+{{define "flamegraph" -}}
+<!DOCTYPE html>
+<html>
+<head>
+  <meta charset="utf-8">
+  <title>{{.Title}}</title>
+  {{template "css" .}}
+  <style type="text/css">{{template "d3flamegraphcss" .}}</style>
+  <style type="text/css">
+    .flamegraph-content {
+      width: 90%;
+      min-width: 80%;
+      margin-left: 5%;
+    }
+    .flamegraph-details {
+      height: 1.2em;
+      width: 90%;
+      min-width: 90%;
+      margin-left: 5%;
+      padding-bottom: 41px;
+    }
+  </style>
 </head>
 <body>
+  {{template "header" .}}
+  <div id="bodycontainer">
+    <div class="flamegraph-content">
+      <div id="chart"></div>
+    </div>
+    <div id="flamegraphdetails" class="flamegraph-details"></div>
+  </div>
+  {{template "script" .}}
+  <script>viewer({{.BaseURL}}, {{.Nodes}});</script>
+  <script>{{template "d3script" .}}</script>
+  <script>{{template "d3tipscript" .}}</script>
+  <script>{{template "d3flamegraphscript" .}}</script>
+  <script type="text/javascript">
+    var data = {{.FlameGraph}};
+    var label = function(d) {
+      return d.data.n + ' (' + d.data.p + ', ' + d.data.l + ')';
+    };
+
+    var width = document.getElementById('chart').clientWidth;
+
+    var flameGraph = d3.flameGraph()
+      .width(width)
+      .cellHeight(18)
+      .minFrameSize(1)
+      .transitionDuration(750)
+      .transitionEase(d3.easeCubic)
+      .sort(true)
+      .title('')
+      .label(label)
+      .details(document.getElementById('flamegraphdetails'));
+
+    var tip = d3.tip()
+      .direction('s')
+      .offset([8, 0])
+      .attr('class', 'd3-flame-graph-tip')
+      .html(function(d) { return 'name: ' + d.data.n + ', value: ' + d.data.l; });
+
+    flameGraph.tooltip(tip);
+
+    d3.select('#chart')
+      .datum(data)
+      .call(flameGraph);
+
+    function clear() {
+      flameGraph.clear();
+    }
 
-{{template "header" .}}
+    function resetZoom() {
+      flameGraph.resetZoom();
+    }
 
-<div id="bodycontainer">
-<pre>
-{{.TextBody}}
-</pre>
-</div>
+    window.addEventListener('resize', function() {
+      var width = document.getElementById('chart').clientWidth;
+      var graphs = document.getElementsByClassName('d3-flame-graph');
+      if (graphs.length > 0) {
+        graphs[0].setAttribute('width', width);
+      }
+      flameGraph.width(width);
+      flameGraph.resetZoom();
+    }, true);
+
+    var search = document.getElementById('search');
+    var searchAlarm = null;
+
+    function selectMatching() {
+      searchAlarm = null;
+
+      if (search.value != '') {
+        flameGraph.search(search.value);
+      } else {
+        flameGraph.clear();
+      }
+    }
+
+    function handleSearch() {
+      // Delay expensive processing so a flurry of key strokes is handled once.
+      if (searchAlarm != null) {
+        clearTimeout(searchAlarm);
+      }
+      searchAlarm = setTimeout(selectMatching, 300);
+    }
 
-{{template "script" .}}
-<script>viewer({{.BaseURL}}, null)</script>
+    search.addEventListener('input', handleSearch);
+  </script>
 </body>
 </html>
 {{end}}
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/driver/webui.go b/src/cmd/vendor/github.com/google/pprof/internal/driver/webui.go
index 67ae262882..20d4e025f4 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/driver/webui.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/driver/webui.go
@@ -69,31 +69,24 @@ func (ec *errorCatcher) PrintErr(args ...interface{}) {
 
 // webArgs contains arguments passed to templates in webhtml.go.
 type webArgs struct {
-	BaseURL  string
-	Title    string
-	Errors   []string
-	Total    int64
-	Legend   []string
-	Help     map[string]string
-	Nodes    []string
-	HTMLBody template.HTML
-	TextBody string
-	Top      []report.TextItem
+	BaseURL    string
+	Title      string
+	Errors     []string
+	Total      int64
+	Legend     []string
+	Help       map[string]string
+	Nodes      []string
+	HTMLBody   template.HTML
+	TextBody   string
+	Top        []report.TextItem
+	FlameGraph template.JS
 }
 
-func serveWebInterface(hostport string, p *profile.Profile, o *plugin.Options) error {
-	host, portStr, err := net.SplitHostPort(hostport)
-	if err != nil {
-		return fmt.Errorf("could not split http address: %v", err)
-	}
-	port, err := strconv.Atoi(portStr)
+func serveWebInterface(hostport string, p *profile.Profile, o *plugin.Options, wantBrowser bool) error {
+	host, port, err := getHostAndPort(hostport)
 	if err != nil {
-		return fmt.Errorf("invalid port number: %v", err)
-	}
-	if host == "" {
-		host = "localhost"
+		return err
 	}
-
 	interactiveMode = true
 	ui := makeWebInterface(p, o)
 	for n, c := range pprofCommands {
@@ -111,22 +104,52 @@ func serveWebInterface(hostport string, p *profile.Profile, o *plugin.Options) e
 		server = defaultWebServer
 	}
 	args := &plugin.HTTPServerArgs{
-		Hostport: net.JoinHostPort(host, portStr),
+		Hostport: net.JoinHostPort(host, strconv.Itoa(port)),
 		Host:     host,
 		Port:     port,
 		Handlers: map[string]http.Handler{
-			"/":       http.HandlerFunc(ui.dot),
-			"/top":    http.HandlerFunc(ui.top),
-			"/disasm": http.HandlerFunc(ui.disasm),
-			"/source": http.HandlerFunc(ui.source),
-			"/peek":   http.HandlerFunc(ui.peek),
+			"/":           http.HandlerFunc(ui.dot),
+			"/top":        http.HandlerFunc(ui.top),
+			"/disasm":     http.HandlerFunc(ui.disasm),
+			"/source":     http.HandlerFunc(ui.source),
+			"/peek":       http.HandlerFunc(ui.peek),
+			"/flamegraph": http.HandlerFunc(ui.flamegraph),
 		},
 	}
 
-	go openBrowser("http://"+args.Hostport, o)
+	if wantBrowser {
+		go openBrowser("http://"+args.Hostport, o)
+	}
 	return server(args)
 }
 
+func getHostAndPort(hostport string) (string, int, error) {
+	host, portStr, err := net.SplitHostPort(hostport)
+	if err != nil {
+		return "", 0, fmt.Errorf("could not split http address: %v", err)
+	}
+	if host == "" {
+		host = "localhost"
+	}
+	var port int
+	if portStr == "" {
+		ln, err := net.Listen("tcp", net.JoinHostPort(host, "0"))
+		if err != nil {
+			return "", 0, fmt.Errorf("could not generate random port: %v", err)
+		}
+		port = ln.Addr().(*net.TCPAddr).Port
+		err = ln.Close()
+		if err != nil {
+			return "", 0, fmt.Errorf("could not generate random port: %v", err)
+		}
+	} else {
+		port, err = strconv.Atoi(portStr)
+		if err != nil {
+			return "", 0, fmt.Errorf("invalid port number: %v", err)
+		}
+	}
+	return host, port, nil
+}
 func defaultWebServer(args *plugin.HTTPServerArgs) error {
 	ln, err := net.Listen("tcp", args.Hostport)
 	if err != nil {
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/driver/webui_test.go b/src/cmd/vendor/github.com/google/pprof/internal/driver/webui_test.go
index 96380a01b3..424752fd1f 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/driver/webui_test.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/driver/webui_test.go
@@ -23,24 +23,15 @@ import (
 	"net/url"
 	"os/exec"
 	"regexp"
+	"runtime"
 	"sync"
 	"testing"
-	"time"
-
-	"runtime"
 
 	"github.com/google/pprof/internal/plugin"
 	"github.com/google/pprof/profile"
 )
 
 func TestWebInterface(t *testing.T) {
-	// This test starts a web browser in a background goroutine
-	// after a 500ms delay. Sometimes the test exits before it
-	// can run the browser, but sometimes the browser does open.
-	// That's obviously unacceptable.
-	defer time.Sleep(2 * time.Second) // to see the browser open
-	t.Skip("golang.org/issue/22651")
-
 	if runtime.GOOS == "nacl" {
 		t.Skip("test assumes tcp available")
 	}
@@ -66,7 +57,7 @@ func TestWebInterface(t *testing.T) {
 		Obj:        fakeObjTool{},
 		UI:         &stdUI{},
 		HTTPServer: creator,
-	})
+	}, false)
 	<-serverCreated
 	defer server.Close()
 
@@ -89,6 +80,7 @@ func TestWebInterface(t *testing.T) {
 			[]string{"300ms.*F1", "200ms.*300ms.*F2"}, false},
 		{"/disasm?f=" + url.QueryEscape("F[12]"),
 			[]string{"f1:asm", "f2:asm"}, false},
+		{"/flamegraph", []string{"File: testbin", "\"n\":\"root\"", "\"n\":\"F1\"", "function tip", "function flameGraph", "function hierarchy"}, false},
 	}
 	for _, c := range testcases {
 		if c.needDot && !haveDot {
@@ -127,14 +119,19 @@ func TestWebInterface(t *testing.T) {
 		for count := 0; count < 2; count++ {
 			wg.Add(1)
 			go func() {
-				http.Get(path)
-				wg.Done()
+				defer wg.Done()
+				res, err := http.Get(path)
+				if err != nil {
+					t.Error("could not fetch", c.path, err)
+					return
+				}
+				if _, err = ioutil.ReadAll(res.Body); err != nil {
+					t.Error("could not read response", c.path, err)
+				}
 			}()
 		}
 	}
 	wg.Wait()
-
-	time.Sleep(5 * time.Second)
 }
 
 // Implement fake object file support.
@@ -153,9 +150,18 @@ func (f fakeObj) SourceLine(addr uint64) ([]plugin.Frame, error) {
 }
 func (f fakeObj) Symbols(r *regexp.Regexp, addr uint64) ([]*plugin.Sym, error) {
 	return []*plugin.Sym{
-		{[]string{"F1"}, fakeSource, addrBase, addrBase + 10},
-		{[]string{"F2"}, fakeSource, addrBase + 10, addrBase + 20},
-		{[]string{"F3"}, fakeSource, addrBase + 20, addrBase + 30},
+		{
+			Name: []string{"F1"}, File: fakeSource,
+			Start: addrBase, End: addrBase + 10,
+		},
+		{
+			Name: []string{"F2"}, File: fakeSource,
+			Start: addrBase + 10, End: addrBase + 20,
+		},
+		{
+			Name: []string{"F3"}, File: fakeSource,
+			Start: addrBase + 20, End: addrBase + 30,
+		},
 	}, nil
 }
 
@@ -229,6 +235,41 @@ func makeFakeProfile() *profile.Profile {
 	}
 }
 
+func TestGetHostAndPort(t *testing.T) {
+	if runtime.GOOS == "nacl" {
+		t.Skip("test assumes tcp available")
+	}
+
+	type testCase struct {
+		hostport       string
+		wantHost       string
+		wantPort       int
+		wantRandomPort bool
+	}
+
+	testCases := []testCase{
+		{":", "localhost", 0, true},
+		{":4681", "localhost", 4681, false},
+		{"localhost:4681", "localhost", 4681, false},
+	}
+	for _, tc := range testCases {
+		host, port, err := getHostAndPort(tc.hostport)
+		if err != nil {
+			t.Errorf("could not get host and port for %q: %v", tc.hostport, err)
+		}
+		if got, want := host, tc.wantHost; got != want {
+			t.Errorf("for %s, got host %s, want %s", tc.hostport, got, want)
+			continue
+		}
+		if !tc.wantRandomPort {
+			if got, want := port, tc.wantPort; got != want {
+				t.Errorf("for %s, got port %d, want %d", tc.hostport, got, want)
+				continue
+			}
+		}
+	}
+}
+
 func TestIsLocalHost(t *testing.T) {
 	for _, s := range []string{"localhost:10000", "[::1]:10000", "127.0.0.1:10000"} {
 		host, _, err := net.SplitHostPort(s)
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/elfexec/elfexec.go b/src/cmd/vendor/github.com/google/pprof/internal/elfexec/elfexec.go
index 9b238c5b87..7e42c88d14 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/elfexec/elfexec.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/elfexec/elfexec.go
@@ -259,3 +259,19 @@ func GetBase(fh *elf.FileHeader, loadSegment *elf.ProgHeader, stextOffset *uint6
 	}
 	return 0, fmt.Errorf("Don't know how to handle FileHeader.Type %v", fh.Type)
 }
+
+// FindTextProgHeader finds the program segment header containing the .text
+// section or nil if the segment cannot be found.
+func FindTextProgHeader(f *elf.File) *elf.ProgHeader {
+	for _, s := range f.Sections {
+		if s.Name == ".text" {
+			// Find the LOAD segment containing the .text section.
+			for _, p := range f.Progs {
+				if p.Type == elf.PT_LOAD && p.Flags&elf.PF_X != 0 && s.Addr >= p.Vaddr && s.Addr < p.Vaddr+p.Memsz {
+					return &p.ProgHeader
+				}
+			}
+		}
+	}
+	return nil
+}
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/graph/dotgraph.go b/src/cmd/vendor/github.com/google/pprof/internal/graph/dotgraph.go
index 4e5d12f6cd..f3721e92f5 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/graph/dotgraph.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/graph/dotgraph.go
@@ -154,7 +154,7 @@ func (b *builder) addNode(node *Node, nodeID int, maxFlat float64) {
 	if flat != 0 {
 		label = label + fmt.Sprintf(`%s (%s)`,
 			flatValue,
-			strings.TrimSpace(percentage(flat, b.config.Total)))
+			strings.TrimSpace(measurement.Percentage(flat, b.config.Total)))
 	} else {
 		label = label + "0"
 	}
@@ -168,7 +168,7 @@ func (b *builder) addNode(node *Node, nodeID int, maxFlat float64) {
 		cumValue = b.config.FormatValue(cum)
 		label = label + fmt.Sprintf(`of %s (%s)`,
 			cumValue,
-			strings.TrimSpace(percentage(cum, b.config.Total)))
+			strings.TrimSpace(measurement.Percentage(cum, b.config.Total)))
 	}
 
 	// Scale font sizes from 8 to 24 based on percentage of flat frequency.
@@ -380,23 +380,6 @@ func dotColor(score float64, isBackground bool) string {
 	return fmt.Sprintf("#%02x%02x%02x", uint8(r*255.0), uint8(g*255.0), uint8(b*255.0))
 }
 
-// percentage computes the percentage of total of a value, and encodes
-// it as a string. At least two digits of precision are printed.
-func percentage(value, total int64) string {
-	var ratio float64
-	if total != 0 {
-		ratio = math.Abs(float64(value)/float64(total)) * 100
-	}
-	switch {
-	case math.Abs(ratio) >= 99.95 && math.Abs(ratio) <= 100.05:
-		return "  100%"
-	case math.Abs(ratio) >= 1.0:
-		return fmt.Sprintf("%5.2f%%", ratio)
-	default:
-		return fmt.Sprintf("%5.2g%%", ratio)
-	}
-}
-
 func multilinePrintableName(info *NodeInfo) string {
 	infoCopy := *info
 	infoCopy.Name = strings.Replace(infoCopy.Name, "::", `\n`, -1)
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/measurement/measurement.go b/src/cmd/vendor/github.com/google/pprof/internal/measurement/measurement.go
index 0a60435644..3e3bcb8c25 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/measurement/measurement.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/measurement/measurement.go
@@ -17,6 +17,7 @@ package measurement
 
 import (
 	"fmt"
+	"math"
 	"strings"
 	"time"
 
@@ -154,6 +155,23 @@ func ScaledLabel(value int64, fromUnit, toUnit string) string {
 	return sv + u
 }
 
+// Percentage computes the percentage of total of a value, and encodes
+// it as a string. At least two digits of precision are printed.
+func Percentage(value, total int64) string {
+	var ratio float64
+	if total != 0 {
+		ratio = math.Abs(float64(value)/float64(total)) * 100
+	}
+	switch {
+	case math.Abs(ratio) >= 99.95 && math.Abs(ratio) <= 100.05:
+		return "  100%"
+	case math.Abs(ratio) >= 1.0:
+		return fmt.Sprintf("%5.2f%%", ratio)
+	default:
+		return fmt.Sprintf("%5.2g%%", ratio)
+	}
+}
+
 // isMemoryUnit returns whether a name is recognized as a memory size
 // unit.
 func isMemoryUnit(unit string) bool {
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/proftest/proftest.go b/src/cmd/vendor/github.com/google/pprof/internal/proftest/proftest.go
index 7f9dcab61a..03fac7e330 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/proftest/proftest.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/proftest/proftest.go
@@ -19,6 +19,7 @@ package proftest
 import (
 	"encoding/json"
 	"fmt"
+	"io"
 	"io/ioutil"
 	"os"
 	"os/exec"
@@ -80,11 +81,21 @@ type TestUI struct {
 	Ignore            int
 	AllowRx           string
 	NumAllowRxMatches int
+	Input             []string
+	index             int
 }
 
 // ReadLine returns no input, as no input is expected during testing.
 func (ui *TestUI) ReadLine(_ string) (string, error) {
-	return "", fmt.Errorf("no input")
+	if ui.index >= len(ui.Input) {
+		return "", io.EOF
+	}
+	input := ui.Input[ui.index]
+	ui.index++
+	if input == "**error**" {
+		return "", fmt.Errorf("Error: %s", input)
+	}
+	return input, nil
 }
 
 // Print messages are discarded by the test UI.
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/report/report.go b/src/cmd/vendor/github.com/google/pprof/internal/report/report.go
index f434554dd9..e127f7fcec 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/report/report.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/report/report.go
@@ -19,7 +19,6 @@ package report
 import (
 	"fmt"
 	"io"
-	"math"
 	"path/filepath"
 	"regexp"
 	"sort"
@@ -425,7 +424,7 @@ func PrintAssembly(w io.Writer, rpt *Report, obj plugin.ObjTool, maxFuncs int) e
 		}
 		fmt.Fprintf(w, "%10s %10s (flat, cum) %s of Total\n",
 			rpt.formatValue(flatSum), rpt.formatValue(cumSum),
-			percentage(cumSum, rpt.total))
+			measurement.Percentage(cumSum, rpt.total))
 
 		function, file, line := "", "", 0
 		for _, n := range ns {
@@ -704,7 +703,7 @@ func printTags(w io.Writer, rpt *Report) error {
 		for _, t := range graph.SortTags(tags, true) {
 			f, u := measurement.Scale(t.FlatValue(), o.SampleUnit, o.OutputUnit)
 			if total > 0 {
-				fmt.Fprintf(tabw, " \t%.1f%s (%s):\t %s\n", f, u, percentage(t.FlatValue(), total), t.Name)
+				fmt.Fprintf(tabw, " \t%.1f%s (%s):\t %s\n", f, u, measurement.Percentage(t.FlatValue(), total), t.Name)
 			} else {
 				fmt.Fprintf(tabw, " \t%.1f%s:\t %s\n", f, u, t.Name)
 			}
@@ -789,9 +788,9 @@ func printText(w io.Writer, rpt *Report) error {
 		}
 		flatSum += item.Flat
 		fmt.Fprintf(w, "%10s %s %s %10s %s  %s%s\n",
-			item.FlatFormat, percentage(item.Flat, rpt.total),
-			percentage(flatSum, rpt.total),
-			item.CumFormat, percentage(item.Cum, rpt.total),
+			item.FlatFormat, measurement.Percentage(item.Flat, rpt.total),
+			measurement.Percentage(flatSum, rpt.total),
+			item.CumFormat, measurement.Percentage(item.Cum, rpt.total),
 			item.Name, inl)
 	}
 	return nil
@@ -1030,17 +1029,17 @@ func printTree(w io.Writer, rpt *Report) error {
 				inline = " (inline)"
 			}
 			fmt.Fprintf(w, "%50s %s |   %s%s\n", rpt.formatValue(in.Weight),
-				percentage(in.Weight, cum), in.Src.Info.PrintableName(), inline)
+				measurement.Percentage(in.Weight, cum), in.Src.Info.PrintableName(), inline)
 		}
 
 		// Print current node.
 		flatSum += flat
 		fmt.Fprintf(w, "%10s %s %s %10s %s                | %s\n",
 			rpt.formatValue(flat),
-			percentage(flat, rpt.total),
-			percentage(flatSum, rpt.total),
+			measurement.Percentage(flat, rpt.total),
+			measurement.Percentage(flatSum, rpt.total),
 			rpt.formatValue(cum),
-			percentage(cum, rpt.total),
+			measurement.Percentage(cum, rpt.total),
 			name)
 
 		// Print outgoing edges.
@@ -1051,7 +1050,7 @@ func printTree(w io.Writer, rpt *Report) error {
 				inline = " (inline)"
 			}
 			fmt.Fprintf(w, "%50s %s |   %s%s\n", rpt.formatValue(out.Weight),
-				percentage(out.Weight, cum), out.Dest.Info.PrintableName(), inline)
+				measurement.Percentage(out.Weight, cum), out.Dest.Info.PrintableName(), inline)
 		}
 	}
 	if len(g.Nodes) > 0 {
@@ -1083,23 +1082,6 @@ func printDOT(w io.Writer, rpt *Report) error {
 	return nil
 }
 
-// percentage computes the percentage of total of a value, and encodes
-// it as a string. At least two digits of precision are printed.
-func percentage(value, total int64) string {
-	var ratio float64
-	if total != 0 {
-		ratio = math.Abs(float64(value)/float64(total)) * 100
-	}
-	switch {
-	case math.Abs(ratio) >= 99.95 && math.Abs(ratio) <= 100.05:
-		return "  100%"
-	case math.Abs(ratio) >= 1.0:
-		return fmt.Sprintf("%5.2f%%", ratio)
-	default:
-		return fmt.Sprintf("%5.2g%%", ratio)
-	}
-}
-
 // ProfileLabels returns printable labels for a profile.
 func ProfileLabels(rpt *Report) []string {
 	label := []string{}
@@ -1131,7 +1113,7 @@ func ProfileLabels(rpt *Report) []string {
 		totalNanos, totalUnit := measurement.Scale(rpt.total, o.SampleUnit, "nanoseconds")
 		var ratio string
 		if totalUnit == "ns" && totalNanos != 0 {
-			ratio = "(" + percentage(int64(totalNanos), prof.DurationNanos) + ")"
+			ratio = "(" + measurement.Percentage(int64(totalNanos), prof.DurationNanos) + ")"
 		}
 		label = append(label, fmt.Sprintf("Duration: %s, Total samples = %s %s", duration, rpt.formatValue(rpt.total), ratio))
 	}
@@ -1162,7 +1144,7 @@ func reportLabels(rpt *Report, g *graph.Graph, origCount, droppedNodes, droppedE
 		label = append(label, activeFilters...)
 	}
 
-	label = append(label, fmt.Sprintf("Showing nodes accounting for %s, %s of %s total", rpt.formatValue(flatSum), strings.TrimSpace(percentage(flatSum, rpt.total)), rpt.formatValue(rpt.total)))
+	label = append(label, fmt.Sprintf("Showing nodes accounting for %s, %s of %s total", rpt.formatValue(flatSum), strings.TrimSpace(measurement.Percentage(flatSum, rpt.total)), rpt.formatValue(rpt.total)))
 
 	if rpt.total != 0 {
 		if droppedNodes > 0 {
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/report/report_test.go b/src/cmd/vendor/github.com/google/pprof/internal/report/report_test.go
index e05cf5ad08..c243e20c2b 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/report/report_test.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/report/report_test.go
@@ -68,8 +68,8 @@ func TestSource(t *testing.T) {
 			want: path + "source.dot",
 		},
 	} {
-		b := bytes.NewBuffer(nil)
-		if err := Generate(b, tc.rpt, &binutils.Binutils{}); err != nil {
+		var b bytes.Buffer
+		if err := Generate(&b, tc.rpt, &binutils.Binutils{}); err != nil {
 			t.Fatalf("%s: %v", tc.want, err)
 		}
 
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/report/source.go b/src/cmd/vendor/github.com/google/pprof/internal/report/source.go
index ce82ae55c4..9a98f7460b 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/report/source.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/report/source.go
@@ -28,6 +28,7 @@ import (
 	"strings"
 
 	"github.com/google/pprof/internal/graph"
+	"github.com/google/pprof/internal/measurement"
 	"github.com/google/pprof/internal/plugin"
 )
 
@@ -99,7 +100,7 @@ func printSource(w io.Writer, rpt *Report) error {
 			fmt.Fprintf(w, "ROUTINE ======================== %s in %s\n", name, filename)
 			fmt.Fprintf(w, "%10s %10s (flat, cum) %s of Total\n",
 				rpt.formatValue(flatSum), rpt.formatValue(cumSum),
-				percentage(cumSum, rpt.total))
+				measurement.Percentage(cumSum, rpt.total))
 
 			if err != nil {
 				fmt.Fprintf(w, " Error: %v\n", err)
@@ -337,13 +338,13 @@ func printHeader(w io.Writer, rpt *Report) {
 
 // printFunctionHeader prints a function header for a weblist report.
 func printFunctionHeader(w io.Writer, name, path string, flatSum, cumSum int64, rpt *Report) {
-	fmt.Fprintf(w, `<h1>%s</h1>%s
+	fmt.Fprintf(w, `<h2>%s</h2><p class="filename">%s</p>
 <pre onClick="pprof_toggle_asm(event)">
   Total:  %10s %10s (flat, cum) %s
 `,
 		template.HTMLEscapeString(name), template.HTMLEscapeString(path),
 		rpt.formatValue(flatSum), rpt.formatValue(cumSum),
-		percentage(cumSum, rpt.total))
+		measurement.Percentage(cumSum, rpt.total))
 }
 
 // printFunctionSourceLine prints a source line and the corresponding assembly.
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/report/source_test.go b/src/cmd/vendor/github.com/google/pprof/internal/report/source_test.go
index 9a2b5a21c4..d45d4c5815 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/report/source_test.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/report/source_test.go
@@ -25,8 +25,8 @@ func TestWebList(t *testing.T) {
 		SampleValue:  func(v []int64) int64 { return v[1] },
 		SampleUnit:   cpu.SampleType[1].Unit,
 	})
-	buf := bytes.NewBuffer(nil)
-	if err := Generate(buf, rpt, &binutils.Binutils{}); err != nil {
+	var buf bytes.Buffer
+	if err := Generate(&buf, rpt, &binutils.Binutils{}); err != nil {
 		t.Fatalf("could not generate weblist: %v", err)
 	}
 	output := buf.String()
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/symbolizer/symbolizer.go b/src/cmd/vendor/github.com/google/pprof/internal/symbolizer/symbolizer.go
index 727b7e8c56..5994c11ac7 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/symbolizer/symbolizer.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/symbolizer/symbolizer.go
@@ -168,6 +168,7 @@ func doLocalSymbolize(prof *profile.Profile, fast, force bool, obj plugin.ObjToo
 		}
 
 		l.Line = make([]profile.Line, len(stack))
+		l.IsFolded = false
 		for i, frame := range stack {
 			if frame.Func != "" {
 				m.HasFunctions = true
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/symbolz/symbolz.go b/src/cmd/vendor/github.com/google/pprof/internal/symbolz/symbolz.go
index 34c119c4c2..086c0ccb04 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/symbolz/symbolz.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/symbolz/symbolz.go
@@ -63,10 +63,29 @@ func Symbolize(p *profile.Profile, force bool, sources plugin.MappingSources, sy
 	return nil
 }
 
+// Check whether path ends with one of the suffixes listed in
+// pprof_remote_servers.html from the gperftools distribution
+func hasGperftoolsSuffix(path string) bool {
+	suffixes := []string{
+		"/pprof/heap",
+		"/pprof/growth",
+		"/pprof/profile",
+		"/pprof/pmuprofile",
+		"/pprof/contention",
+	}
+	for _, s := range suffixes {
+		if strings.HasSuffix(path, s) {
+			return true
+		}
+	}
+	return false
+}
+
 // symbolz returns the corresponding symbolz source for a profile URL.
 func symbolz(source string) string {
 	if url, err := url.Parse(source); err == nil && url.Host != "" {
-		if strings.Contains(url.Path, "/debug/pprof/") {
+		// All paths in the net/http/pprof Go package contain /debug/pprof/
+		if strings.Contains(url.Path, "/debug/pprof/") || hasGperftoolsSuffix(url.Path) {
 			url.Path = path.Clean(url.Path + "/../symbol")
 		} else {
 			url.Path = "/symbolz"
diff --git a/src/cmd/vendor/github.com/google/pprof/internal/symbolz/symbolz_test.go b/src/cmd/vendor/github.com/google/pprof/internal/symbolz/symbolz_test.go
index 270a6198c9..2d13c889b6 100644
--- a/src/cmd/vendor/github.com/google/pprof/internal/symbolz/symbolz_test.go
+++ b/src/cmd/vendor/github.com/google/pprof/internal/symbolz/symbolz_test.go
@@ -34,6 +34,17 @@ func TestSymbolzURL(t *testing.T) {
 		"http://host:8000/debug/pprof/profile?seconds=10":                         "http://host:8000/debug/pprof/symbol",
 		"http://host:8000/debug/pprof/heap":                                       "http://host:8000/debug/pprof/symbol",
 		"http://some.host:8080/some/deeper/path/debug/pprof/endpoint?param=value": "http://some.host:8080/some/deeper/path/debug/pprof/symbol",
+		"http://host:8000/pprof/profile":                                          "http://host:8000/pprof/symbol",
+		"http://host:8000/pprof/profile?seconds=15":                               "http://host:8000/pprof/symbol",
+		"http://host:8000/pprof/heap":                                             "http://host:8000/pprof/symbol",
+		"http://host:8000/debug/pprof/block":                                      "http://host:8000/debug/pprof/symbol",
+		"http://host:8000/debug/pprof/trace?seconds=5":                            "http://host:8000/debug/pprof/symbol",
+		"http://host:8000/debug/pprof/mutex":                                      "http://host:8000/debug/pprof/symbol",
+		"http://host/whatever/pprof/heap":                                         "http://host/whatever/pprof/symbol",
+		"http://host/whatever/pprof/growth":                                       "http://host/whatever/pprof/symbol",
+		"http://host/whatever/pprof/profile":                                      "http://host/whatever/pprof/symbol",
+		"http://host/whatever/pprof/pmuprofile":                                   "http://host/whatever/pprof/symbol",
+		"http://host/whatever/pprof/contention":                                   "http://host/whatever/pprof/symbol",
 	} {
 		if got := symbolz(try); got != want {
 			t.Errorf(`symbolz(%s)=%s, want "%s"`, try, got, want)
diff --git a/src/cmd/vendor/github.com/google/pprof/profile/encode.go b/src/cmd/vendor/github.com/google/pprof/profile/encode.go
index 622319484a..1e84c72d43 100644
--- a/src/cmd/vendor/github.com/google/pprof/profile/encode.go
+++ b/src/cmd/vendor/github.com/google/pprof/profile/encode.go
@@ -214,7 +214,12 @@ var profileDecoder = []decoder{
 	// int64 keep_frames = 8
 	func(b *buffer, m message) error { return decodeInt64(b, &m.(*Profile).keepFramesX) },
 	// int64 time_nanos = 9
-	func(b *buffer, m message) error { return decodeInt64(b, &m.(*Profile).TimeNanos) },
+	func(b *buffer, m message) error {
+		if m.(*Profile).TimeNanos != 0 {
+			return errConcatProfile
+		}
+		return decodeInt64(b, &m.(*Profile).TimeNanos)
+	},
 	// int64 duration_nanos = 10
 	func(b *buffer, m message) error { return decodeInt64(b, &m.(*Profile).DurationNanos) },
 	// ValueType period_type = 11
@@ -480,6 +485,7 @@ func (p *Location) encode(b *buffer) {
 	for i := range p.Line {
 		encodeMessage(b, 4, &p.Line[i])
 	}
+	encodeBoolOpt(b, 5, p.IsFolded)
 }
 
 var locationDecoder = []decoder{
@@ -493,6 +499,7 @@ var locationDecoder = []decoder{
 		pp.Line = append(pp.Line, Line{})
 		return decodeMessage(b, &pp.Line[n])
 	},
+	func(b *buffer, m message) error { return decodeBool(b, &m.(*Location).IsFolded) }, // optional bool is_folded = 5;
 }
 
 func (p *Line) decoder() []decoder {
diff --git a/src/cmd/vendor/github.com/google/pprof/profile/merge.go b/src/cmd/vendor/github.com/google/pprof/profile/merge.go
index e00829cc34..a5440b521e 100644
--- a/src/cmd/vendor/github.com/google/pprof/profile/merge.go
+++ b/src/cmd/vendor/github.com/google/pprof/profile/merge.go
@@ -64,7 +64,7 @@ func Merge(srcs []*Profile) (*Profile, error) {
 			// represents the main binary. Take the first Mapping we see,
 			// otherwise the operations below will add mappings in an
 			// arbitrary order.
-			pm.mapMapping(srcs[0].Mapping[0])
+			pm.mapMapping(src.Mapping[0])
 		}
 
 		for _, s := range src.Sample {
@@ -234,10 +234,11 @@ func (pm *profileMerger) mapLocation(src *Location) *Location {
 
 	mi := pm.mapMapping(src.Mapping)
 	l := &Location{
-		ID:      uint64(len(pm.p.Location) + 1),
-		Mapping: mi.m,
-		Address: uint64(int64(src.Address) + mi.offset),
-		Line:    make([]Line, len(src.Line)),
+		ID:       uint64(len(pm.p.Location) + 1),
+		Mapping:  mi.m,
+		Address:  uint64(int64(src.Address) + mi.offset),
+		Line:     make([]Line, len(src.Line)),
+		IsFolded: src.IsFolded,
 	}
 	for i, ln := range src.Line {
 		l.Line[i] = pm.mapLine(ln)
@@ -258,7 +259,8 @@ func (pm *profileMerger) mapLocation(src *Location) *Location {
 // key generates locationKey to be used as a key for maps.
 func (l *Location) key() locationKey {
 	key := locationKey{
-		addr: l.Address,
+		addr:     l.Address,
+		isFolded: l.IsFolded,
 	}
 	if l.Mapping != nil {
 		// Normalizes address to handle address space randomization.
@@ -279,6 +281,7 @@ func (l *Location) key() locationKey {
 type locationKey struct {
 	addr, mappingID uint64
 	lines           string
+	isFolded        bool
 }
 
 func (pm *profileMerger) mapMapping(src *Mapping) mapInfo {
@@ -422,6 +425,7 @@ func combineHeaders(srcs []*Profile) (*Profile, error) {
 
 	var timeNanos, durationNanos, period int64
 	var comments []string
+	seenComments := map[string]bool{}
 	var defaultSampleType string
 	for _, s := range srcs {
 		if timeNanos == 0 || s.TimeNanos < timeNanos {
@@ -431,7 +435,12 @@ func combineHeaders(srcs []*Profile) (*Profile, error) {
 		if period == 0 || period < s.Period {
 			period = s.Period
 		}
-		comments = append(comments, s.Comments...)
+		for _, c := range s.Comments {
+			if seen := seenComments[c]; !seen {
+				comments = append(comments, c)
+				seenComments[c] = true
+			}
+		}
 		if defaultSampleType == "" {
 			defaultSampleType = s.DefaultSampleType
 		}
diff --git a/src/cmd/vendor/github.com/google/pprof/profile/profile.go b/src/cmd/vendor/github.com/google/pprof/profile/profile.go
index a0f53efe3e..350538bf43 100644
--- a/src/cmd/vendor/github.com/google/pprof/profile/profile.go
+++ b/src/cmd/vendor/github.com/google/pprof/profile/profile.go
@@ -109,10 +109,11 @@ type Mapping struct {
 
 // Location corresponds to Profile.Location
 type Location struct {
-	ID      uint64
-	Mapping *Mapping
-	Address uint64
-	Line    []Line
+	ID       uint64
+	Mapping  *Mapping
+	Address  uint64
+	Line     []Line
+	IsFolded bool
 
 	mappingIDX uint64
 }
@@ -163,7 +164,7 @@ func ParseData(data []byte) (*Profile, error) {
 			return nil, fmt.Errorf("decompressing profile: %v", err)
 		}
 	}
-	if p, err = ParseUncompressed(data); err != nil && err != errNoData {
+	if p, err = ParseUncompressed(data); err != nil && err != errNoData && err != errConcatProfile {
 		p, err = parseLegacy(data)
 	}
 
@@ -180,6 +181,7 @@ func ParseData(data []byte) (*Profile, error) {
 var errUnrecognized = fmt.Errorf("unrecognized profile format")
 var errMalformed = fmt.Errorf("malformed profile format")
 var errNoData = fmt.Errorf("empty input file")
+var errConcatProfile = fmt.Errorf("concatenated profiles detected")
 
 func parseLegacy(data []byte) (*Profile, error) {
 	parsers := []func([]byte) (*Profile, error){
@@ -591,6 +593,9 @@ func (l *Location) string() string {
 	if m := l.Mapping; m != nil {
 		locStr = locStr + fmt.Sprintf("M=%d ", m.ID)
 	}
+	if l.IsFolded {
+		locStr = locStr + "[F] "
+	}
 	if len(l.Line) == 0 {
 		ss = append(ss, locStr)
 	}
diff --git a/src/cmd/vendor/github.com/google/pprof/profile/profile_test.go b/src/cmd/vendor/github.com/google/pprof/profile/profile_test.go
index bc2ab8bdd1..ab020275cb 100644
--- a/src/cmd/vendor/github.com/google/pprof/profile/profile_test.go
+++ b/src/cmd/vendor/github.com/google/pprof/profile/profile_test.go
@@ -73,11 +73,11 @@ func TestParse(t *testing.T) {
 		}
 
 		// Reencode and decode.
-		bw := bytes.NewBuffer(nil)
-		if err := p.Write(bw); err != nil {
+		var bw bytes.Buffer
+		if err := p.Write(&bw); err != nil {
 			t.Fatalf("%s: %v", source, err)
 		}
-		if p, err = Parse(bw); err != nil {
+		if p, err = Parse(&bw); err != nil {
 			t.Fatalf("%s: %v", source, err)
 		}
 		js2 := p.String()
@@ -108,6 +108,21 @@ func TestParseError(t *testing.T) {
 	}
 }
 
+func TestParseConcatentated(t *testing.T) {
+	prof := testProfile1.Copy()
+	// Write the profile twice to buffer to create concatented profile.
+	var buf bytes.Buffer
+	prof.Write(&buf)
+	prof.Write(&buf)
+	_, err := Parse(&buf)
+	if err == nil {
+		t.Fatalf("got nil, want error")
+	}
+	if got, want := err.Error(), "parsing profile: concatenated profiles detected"; want != got {
+		t.Fatalf("got error %q, want error %q", got, want)
+	}
+}
+
 func TestCheckValid(t *testing.T) {
 	const path = "testdata/java.cpu"
 
@@ -276,6 +291,7 @@ var cpuL = []*Location{
 }
 
 var testProfile1 = &Profile{
+	TimeNanos:     10000,
 	PeriodType:    &ValueType{Type: "cpu", Unit: "milliseconds"},
 	Period:        1,
 	DurationNanos: 10e9,
@@ -330,6 +346,60 @@ var testProfile1 = &Profile{
 	Mapping:  cpuM,
 }
 
+var testProfile1NoMapping = &Profile{
+	PeriodType:    &ValueType{Type: "cpu", Unit: "milliseconds"},
+	Period:        1,
+	DurationNanos: 10e9,
+	SampleType: []*ValueType{
+		{Type: "samples", Unit: "count"},
+		{Type: "cpu", Unit: "milliseconds"},
+	},
+	Sample: []*Sample{
+		{
+			Location: []*Location{cpuL[0]},
+			Value:    []int64{1000, 1000},
+			Label: map[string][]string{
+				"key1": {"tag1"},
+				"key2": {"tag1"},
+			},
+		},
+		{
+			Location: []*Location{cpuL[1], cpuL[0]},
+			Value:    []int64{100, 100},
+			Label: map[string][]string{
+				"key1": {"tag2"},
+				"key3": {"tag2"},
+			},
+		},
+		{
+			Location: []*Location{cpuL[2], cpuL[0]},
+			Value:    []int64{10, 10},
+			Label: map[string][]string{
+				"key1": {"tag3"},
+				"key2": {"tag2"},
+			},
+		},
+		{
+			Location: []*Location{cpuL[3], cpuL[0]},
+			Value:    []int64{10000, 10000},
+			Label: map[string][]string{
+				"key1": {"tag4"},
+				"key2": {"tag1"},
+			},
+		},
+		{
+			Location: []*Location{cpuL[4], cpuL[0]},
+			Value:    []int64{1, 1},
+			Label: map[string][]string{
+				"key1": {"tag4"},
+				"key2": {"tag1"},
+			},
+		},
+	},
+	Location: cpuL,
+	Function: cpuF,
+}
+
 var testProfile2 = &Profile{
 	PeriodType:    &ValueType{Type: "cpu", Unit: "milliseconds"},
 	Period:        1,
@@ -577,6 +647,7 @@ func TestMerge(t *testing.T) {
 	// location should add up to 0).
 
 	prof := testProfile1.Copy()
+	prof.Comments = []string{"comment1"}
 	p1, err := Merge([]*Profile{prof, prof})
 	if err != nil {
 		t.Errorf("merge error: %v", err)
@@ -586,6 +657,9 @@ func TestMerge(t *testing.T) {
 	if err != nil {
 		t.Errorf("merge error: %v", err)
 	}
+	if got, want := len(prof.Comments), 1; got != want {
+		t.Errorf("len(prof.Comments) = %d, want %d", got, want)
+	}
 
 	// Use aggregation to merge locations at function granularity.
 	if err := prof.Aggregate(false, true, false, false, false); err != nil {
@@ -627,6 +701,39 @@ func TestMergeAll(t *testing.T) {
 	}
 }
 
+func TestIsFoldedMerge(t *testing.T) {
+	testProfile1Folded := testProfile1.Copy()
+	testProfile1Folded.Location[0].IsFolded = true
+	testProfile1Folded.Location[1].IsFolded = true
+
+	for _, tc := range []struct {
+		name            string
+		profs           []*Profile
+		wantLocationLen int
+	}{
+		{
+			name:            "folded and non-folded locations not merged",
+			profs:           []*Profile{testProfile1.Copy(), testProfile1Folded.Copy()},
+			wantLocationLen: 7,
+		},
+		{
+			name:            "identical folded locations are merged",
+			profs:           []*Profile{testProfile1Folded.Copy(), testProfile1Folded.Copy()},
+			wantLocationLen: 5,
+		},
+	} {
+		t.Run(tc.name, func(t *testing.T) {
+			prof, err := Merge(tc.profs)
+			if err != nil {
+				t.Fatalf("merge error: %v", err)
+			}
+			if got, want := len(prof.Location), tc.wantLocationLen; got != want {
+				t.Fatalf("got %d locations, want %d locations", got, want)
+			}
+		})
+	}
+}
+
 func TestNumLabelMerge(t *testing.T) {
 	for _, tc := range []struct {
 		name          string
@@ -684,6 +791,40 @@ func TestNumLabelMerge(t *testing.T) {
 	}
 }
 
+func TestEmptyMappingMerge(t *testing.T) {
+	// Aggregate a profile with itself and once again with a factor of
+	// -2. Should end up with an empty profile (all samples for a
+	// location should add up to 0).
+
+	prof1 := testProfile1.Copy()
+	prof2 := testProfile1NoMapping.Copy()
+	p1, err := Merge([]*Profile{prof2, prof1})
+	if err != nil {
+		t.Errorf("merge error: %v", err)
+	}
+	prof2.Scale(-2)
+	prof, err := Merge([]*Profile{p1, prof2})
+	if err != nil {
+		t.Errorf("merge error: %v", err)
+	}
+
+	// Use aggregation to merge locations at function granularity.
+	if err := prof.Aggregate(false, true, false, false, false); err != nil {
+		t.Errorf("aggregating after merge: %v", err)
+	}
+
+	samples := make(map[string]int64)
+	for _, s := range prof.Sample {
+		tb := locationHash(s)
+		samples[tb] = samples[tb] + s.Value[0]
+	}
+	for s, v := range samples {
+		if v != 0 {
+			t.Errorf("nonzero value for sample %s: %d", s, v)
+		}
+	}
+}
+
 func TestNormalizeBySameProfile(t *testing.T) {
 	pb := testProfile1.Copy()
 	p := testProfile1.Copy()
diff --git a/src/cmd/vendor/github.com/google/pprof/profile/proto_test.go b/src/cmd/vendor/github.com/google/pprof/profile/proto_test.go
index e0832294ac..38b58c586d 100644
--- a/src/cmd/vendor/github.com/google/pprof/profile/proto_test.go
+++ b/src/cmd/vendor/github.com/google/pprof/profile/proto_test.go
@@ -52,6 +52,8 @@ var testF = []*Function{
 	{ID: 1, Name: "func1", SystemName: "func1", Filename: "file1"},
 	{ID: 2, Name: "func2", SystemName: "func2", Filename: "file1"},
 	{ID: 3, Name: "func3", SystemName: "func3", Filename: "file2"},
+	{ID: 4, Name: "func4", SystemName: "func4", Filename: "file3"},
+	{ID: 5, Name: "func5", SystemName: "func5", Filename: "file4"},
 }
 
 var testL = []*Location{
@@ -86,6 +88,22 @@ var testL = []*Location{
 		Mapping: testM[1],
 		Address: 12,
 	},
+	{
+		ID:      4,
+		Mapping: testM[1],
+		Address: 12,
+		Line: []Line{
+			{
+				Function: testF[4],
+				Line:     6,
+			},
+			{
+				Function: testF[4],
+				Line:     6,
+			},
+		},
+		IsFolded: true,
+	},
 }
 
 var all = &Profile{
@@ -133,9 +151,9 @@ var all = &Profile{
 
 func TestMarshalUnmarshal(t *testing.T) {
 	// Write the profile, parse it, and ensure they're equal.
-	buf := bytes.NewBuffer(nil)
-	all.Write(buf)
-	all2, err := Parse(buf)
+	var buf bytes.Buffer
+	all.Write(&buf)
+	all2, err := Parse(&buf)
 	if err != nil {
 		t.Fatal(err)
 	}
diff --git a/src/cmd/vendor/github.com/google/pprof/proto/profile.proto b/src/cmd/vendor/github.com/google/pprof/proto/profile.proto
index 78caf4138b..669f71133e 100644
--- a/src/cmd/vendor/github.com/google/pprof/proto/profile.proto
+++ b/src/cmd/vendor/github.com/google/pprof/proto/profile.proto
@@ -1,3 +1,8 @@
+// Copyright (c) 2016, Google Inc.
+// All rights reserved.
+//
+////////////////////////////////////////////////////////////////////////////////
+
 // Profile is a common stacktrace profile format.
 //
 // Measurements represented with this format should follow the
@@ -151,7 +156,7 @@ message Location {
   // instruction addresses or any integer sequence as ids.
   uint64 id = 1;
   // The id of the corresponding profile.Mapping for this location.
-  // If can be unset if the mapping is unknown or not applicable for
+  // It can be unset if the mapping is unknown or not applicable for
   // this profile type.
   uint64 mapping_id = 2;
   // The instruction address for this location, if available.  It
@@ -168,6 +173,12 @@ message Location {
   //    line[0].function_name == "memcpy"
   //    line[1].function_name == "printf"
   repeated Line line = 4;
+  // Provides an indication that multiple symbols map to this location's
+  // address, for example due to identical code folding by the linker. In that
+  // case the line information above represents one of the multiple
+  // symbols. This field must be recomputed when the symbolization state of the
+  // profile changes.
+  bool is_folded = 5;
 }
 
 message Line {
diff --git a/src/cmd/vendor/github.com/google/pprof/test.sh b/src/cmd/vendor/github.com/google/pprof/test.sh
index 81b9089131..e9aff2b409 100755
--- a/src/cmd/vendor/github.com/google/pprof/test.sh
+++ b/src/cmd/vendor/github.com/google/pprof/test.sh
@@ -1,13 +1,19 @@
 #!/usr/bin/env bash
 
 set -e
+set -x
 MODE=atomic
 echo "mode: $MODE" > coverage.txt
 
-PKG=$(go list ./... | grep -v /vendor/)
+# All packages.
+PKG=$(go list ./...)
 
 staticcheck $PKG
 unused $PKG
+
+# Packages that have any tests.
+PKG=$(go list -f '{{if .TestGoFiles}} {{.ImportPath}} {{end}}' ./...)
+
 go test -v $PKG
 
 for d in $PKG; do
@@ -17,3 +23,4 @@ for d in $PKG; do
     rm profile.out
   fi
 done
+
diff --git a/src/cmd/vendor/github.com/google/pprof/third_party/d3/LICENSE b/src/cmd/vendor/github.com/google/pprof/third_party/d3/LICENSE
new file mode 100644
index 0000000000..1d9d875edb
--- /dev/null
+++ b/src/cmd/vendor/github.com/google/pprof/third_party/d3/LICENSE
@@ -0,0 +1,27 @@
+Copyright 2010-2017 Mike Bostock
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
+
+* Redistributions in binary form must reproduce the above copyright notice,
+  this list of conditions and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+* Neither the name of the author nor the names of contributors may be used to
+  endorse or promote products derived from this software without specific prior
+  written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/src/cmd/vendor/github.com/google/pprof/third_party/d3/README.md b/src/cmd/vendor/github.com/google/pprof/third_party/d3/README.md
new file mode 100644
index 0000000000..53e6eb61eb
--- /dev/null
+++ b/src/cmd/vendor/github.com/google/pprof/third_party/d3/README.md
@@ -0,0 +1,119 @@
+# Building a customized D3.js bundle
+
+The D3.js version distributed with pprof is customized to only include the modules required by pprof.
+
+## Dependencies
+
+First, it's necessary to pull all bundle dependencies. We will use a JavaScript package manager, [npm](https://www.npmjs.com/), to accomplish that. npm dependencies are declared in a `package.json` file, so create one with the following configuration:
+
+```js
+{
+  "name": "d3-pprof",
+  "version": "1.0.0",
+  "description": "A d3.js bundle for pprof.",
+  "scripts": {
+    "prepare": "rollup -c && uglifyjs d3.js -c -m -o d3.min.js"
+  },
+  "license": "Apache-2.0",
+  "devDependencies": {
+    "d3-selection": "1.1.0",
+    "d3-hierarchy": "1.1.5",
+    "d3-scale": "1.0.6",
+    "d3-format": "1.2.0",
+    "d3-ease": "1.0.3",
+    "d3-array": "1.2.1",
+    "d3-collection": "1.0.4",
+    "d3-transition": "1.1.0",
+    "rollup": "0.51.8",
+    "rollup-plugin-node-resolve": "3",
+    "uglify-js": "3.1.10"
+  }
+}
+```
+
+Besides the bundle dependencies, the `package.json` file also specifies a script called `prepare`, which will be executed to create the bundle after `Rollup` is installed.
+
+## Bundler
+
+The simplest way of creating a custom bundle is to use a bundler, such as [Rollup](https://rollupjs.org/) or [Webpack](https://webpack.js.org/). Rollup will be used in this example.
+
+First, create a `rollup.config.js` file, containing the configuration Rollup should use to build the bundle.
+
+```js
+import node from "rollup-plugin-node-resolve";
+
+export default {
+  input: "index.js",
+  output: {
+    format: "umd",
+    file: "d3.js"
+  },
+  name: "d3",
+  plugins: [node()],
+  sourcemap: false
+};
+```
+
+Then create an `index.js` file containing all the functions that need to be exported in the bundle.
+
+```js
+export {
+  select,
+  selection,
+  event,
+} from "d3-selection";
+
+export {
+    hierarchy,
+    partition,
+} from "d3-hierarchy";
+
+export {
+    scaleLinear,
+} from "d3-scale";
+
+export {
+    format,
+} from "d3-format";
+
+export {
+    easeCubic,
+} from "d3-ease";
+
+export {
+    ascending,
+} from "d3-array";
+
+export {
+    map,
+} from "d3-collection";
+
+export {
+    transition,
+} from "d3-transition";
+```
+
+## Building
+
+Once all files were created, execute the following commands to pull all dependencies and build the bundle.
+
+```
+% npm install
+% npm run prepare
+```
+
+This will create two files, `d3.js` and `d3.min.js`, the custom D3.js bundle and its minified version respectively.
+
+# References
+
+## D3 Custom Bundle
+
+A demonstration of building a custom D3 4.0 bundle using ES2015 modules and Rollup. 
+
+[bl.ocks.org/mbostock/bb09af4c39c79cffcde4](https://bl.ocks.org/mbostock/bb09af4c39c79cffcde4)
+
+## d3-pprof
+
+A repository containing all previously mentioned configuration files and the generated custom bundle.
+
+[github.com/spiermar/d3-pprof](https://github.com/spiermar/d3-pprof)
\ No newline at end of file
diff --git a/src/cmd/vendor/github.com/google/pprof/third_party/d3/d3.go b/src/cmd/vendor/github.com/google/pprof/third_party/d3/d3.go
new file mode 100644
index 0000000000..7d217c71bf
--- /dev/null
+++ b/src/cmd/vendor/github.com/google/pprof/third_party/d3/d3.go
@@ -0,0 +1,4675 @@
+// D3.js is a JavaScript library for manipulating documents based on data.
+// https://github.com/d3/d3
+// See LICENSE file for license details
+// Custom build for pprof (https://github.com/spiermar/d3-pprof)
+
+package d3
+
+// JSSource returns the d3.js file
+const JSSource = `
+(function (global, factory) {
+	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
+	typeof define === 'function' && define.amd ? define(['exports'], factory) :
+	(factory((global.d3 = {})));
+}(this, (function (exports) { 'use strict';
+
+var xhtml = "http://www.w3.org/1999/xhtml";
+
+var namespaces = {
+  svg: "http://www.w3.org/2000/svg",
+  xhtml: xhtml,
+  xlink: "http://www.w3.org/1999/xlink",
+  xml: "http://www.w3.org/XML/1998/namespace",
+  xmlns: "http://www.w3.org/2000/xmlns/"
+};
+
+var namespace = function(name) {
+  var prefix = name += "", i = prefix.indexOf(":");
+  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
+  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
+};
+
+function creatorInherit(name) {
+  return function() {
+    var document = this.ownerDocument,
+        uri = this.namespaceURI;
+    return uri === xhtml && document.documentElement.namespaceURI === xhtml
+        ? document.createElement(name)
+        : document.createElementNS(uri, name);
+  };
+}
+
+function creatorFixed(fullname) {
+  return function() {
+    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
+  };
+}
+
+var creator = function(name) {
+  var fullname = namespace(name);
+  return (fullname.local
+      ? creatorFixed
+      : creatorInherit)(fullname);
+};
+
+var matcher = function(selector) {
+  return function() {
+    return this.matches(selector);
+  };
+};
+
+if (typeof document !== "undefined") {
+  var element = document.documentElement;
+  if (!element.matches) {
+    var vendorMatches = element.webkitMatchesSelector
+        || element.msMatchesSelector
+        || element.mozMatchesSelector
+        || element.oMatchesSelector;
+    matcher = function(selector) {
+      return function() {
+        return vendorMatches.call(this, selector);
+      };
+    };
+  }
+}
+
+var matcher$1 = matcher;
+
+var filterEvents = {};
+
+exports.event = null;
+
+if (typeof document !== "undefined") {
+  var element$1 = document.documentElement;
+  if (!("onmouseenter" in element$1)) {
+    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
+  }
+}
+
+function filterContextListener(listener, index, group) {
+  listener = contextListener(listener, index, group);
+  return function(event) {
+    var related = event.relatedTarget;
+    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
+      listener.call(this, event);
+    }
+  };
+}
+
+function contextListener(listener, index, group) {
+  return function(event1) {
+    var event0 = exports.event; // Events can be reentrant (e.g., focus).
+    exports.event = event1;
+    try {
+      listener.call(this, this.__data__, index, group);
+    } finally {
+      exports.event = event0;
+    }
+  };
+}
+
+function parseTypenames(typenames) {
+  return typenames.trim().split(/^|\s+/).map(function(t) {
+    var name = "", i = t.indexOf(".");
+    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
+    return {type: t, name: name};
+  });
+}
+
+function onRemove(typename) {
+  return function() {
+    var on = this.__on;
+    if (!on) return;
+    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
+      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
+        this.removeEventListener(o.type, o.listener, o.capture);
+      } else {
+        on[++i] = o;
+      }
+    }
+    if (++i) on.length = i;
+    else delete this.__on;
+  };
+}
+
+function onAdd(typename, value, capture) {
+  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
+  return function(d, i, group) {
+    var on = this.__on, o, listener = wrap(value, i, group);
+    if (on) for (var j = 0, m = on.length; j < m; ++j) {
+      if ((o = on[j]).type === typename.type && o.name === typename.name) {
+        this.removeEventListener(o.type, o.listener, o.capture);
+        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
+        o.value = value;
+        return;
+      }
+    }
+    this.addEventListener(typename.type, listener, capture);
+    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
+    if (!on) this.__on = [o];
+    else on.push(o);
+  };
+}
+
+var selection_on = function(typename, value, capture) {
+  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;
+
+  if (arguments.length < 2) {
+    var on = this.node().__on;
+    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
+      for (i = 0, o = on[j]; i < n; ++i) {
+        if ((t = typenames[i]).type === o.type && t.name === o.name) {
+          return o.value;
+        }
+      }
+    }
+    return;
+  }
+
+  on = value ? onAdd : onRemove;
+  if (capture == null) capture = false;
+  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
+  return this;
+};
+
+function none() {}
+
+var selector = function(selector) {
+  return selector == null ? none : function() {
+    return this.querySelector(selector);
+  };
+};
+
+var selection_select = function(select) {
+  if (typeof select !== "function") select = selector(select);
+
+  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
+    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
+      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
+        if ("__data__" in node) subnode.__data__ = node.__data__;
+        subgroup[i] = subnode;
+      }
+    }
+  }
+
+  return new Selection(subgroups, this._parents);
+};
+
+function empty() {
+  return [];
+}
+
+var selectorAll = function(selector) {
+  return selector == null ? empty : function() {
+    return this.querySelectorAll(selector);
+  };
+};
+
+var selection_selectAll = function(select) {
+  if (typeof select !== "function") select = selectorAll(select);
+
+  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
+    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
+      if (node = group[i]) {
+        subgroups.push(select.call(node, node.__data__, i, group));
+        parents.push(node);
+      }
+    }
+  }
+
+  return new Selection(subgroups, parents);
+};
+
+var selection_filter = function(match) {
+  if (typeof match !== "function") match = matcher$1(match);
+
+  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
+    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
+      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
+        subgroup.push(node);
+      }
+    }
+  }
+
+  return new Selection(subgroups, this._parents);
+};
+
+var sparse = function(update) {
+  return new Array(update.length);
+};
+
+var selection_enter = function() {
+  return new Selection(this._enter || this._groups.map(sparse), this._parents);
+};
+
+function EnterNode(parent, datum) {
+  this.ownerDocument = parent.ownerDocument;
+  this.namespaceURI = parent.namespaceURI;
+  this._next = null;
+  this._parent = parent;
+  this.__data__ = datum;
+}
+
+EnterNode.prototype = {
+  constructor: EnterNode,
+  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
+  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
+  querySelector: function(selector) { return this._parent.querySelector(selector); },
+  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
+};
+
+var constant = function(x) {
+  return function() {
+    return x;
+  };
+};
+
+var keyPrefix = "$"; // Protect against keys like “__proto__”.
+
+function bindIndex(parent, group, enter, update, exit, data) {
+  var i = 0,
+      node,
+      groupLength = group.length,
+      dataLength = data.length;
+
+  // Put any non-null nodes that fit into update.
+  // Put any null nodes into enter.
+  // Put any remaining data into enter.
+  for (; i < dataLength; ++i) {
+    if (node = group[i]) {
+      node.__data__ = data[i];
+      update[i] = node;
+    } else {
+      enter[i] = new EnterNode(parent, data[i]);
+    }
+  }
+
+  // Put any non-null nodes that don’t fit into exit.
+  for (; i < groupLength; ++i) {
+    if (node = group[i]) {
+      exit[i] = node;
+    }
+  }
+}
+
+function bindKey(parent, group, enter, update, exit, data, key) {
+  var i,
+      node,
+      nodeByKeyValue = {},
+      groupLength = group.length,
+      dataLength = data.length,
+      keyValues = new Array(groupLength),
+      keyValue;
+
+  // Compute the key for each node.
+  // If multiple nodes have the same key, the duplicates are added to exit.
+  for (i = 0; i < groupLength; ++i) {
+    if (node = group[i]) {
+      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
+      if (keyValue in nodeByKeyValue) {
+        exit[i] = node;
+      } else {
+        nodeByKeyValue[keyValue] = node;
+      }
+    }
+  }
+
+  // Compute the key for each datum.
+  // If there a node associated with this key, join and add it to update.
+  // If there is not (or the key is a duplicate), add it to enter.
+  for (i = 0; i < dataLength; ++i) {
+    keyValue = keyPrefix + key.call(parent, data[i], i, data);
+    if (node = nodeByKeyValue[keyValue]) {
+      update[i] = node;
+      node.__data__ = data[i];
+      nodeByKeyValue[keyValue] = null;
+    } else {
+      enter[i] = new EnterNode(parent, data[i]);
+    }
+  }
+
+  // Add any remaining nodes that were not bound to data to exit.
+  for (i = 0; i < groupLength; ++i) {
+    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
+      exit[i] = node;
+    }
+  }
+}
+
+var selection_data = function(value, key) {
+  if (!value) {
+    data = new Array(this.size()), j = -1;
+    this.each(function(d) { data[++j] = d; });
+    return data;
+  }
+
+  var bind = key ? bindKey : bindIndex,
+      parents = this._parents,
+      groups = this._groups;
+
+  if (typeof value !== "function") value = constant(value);
+
+  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
+    var parent = parents[j],
+        group = groups[j],
+        groupLength = group.length,
+        data = value.call(parent, parent && parent.__data__, j, parents),
+        dataLength = data.length,
+        enterGroup = enter[j] = new Array(dataLength),
+        updateGroup = update[j] = new Array(dataLength),
+        exitGroup = exit[j] = new Array(groupLength);
+
+    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
+
+    // Now connect the enter nodes to their following update node, such that
+    // appendChild can insert the materialized enter node before this node,
+    // rather than at the end of the parent node.
+    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
+      if (previous = enterGroup[i0]) {
+        if (i0 >= i1) i1 = i0 + 1;
+        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
+        previous._next = next || null;
+      }
+    }
+  }
+
+  update = new Selection(update, parents);
+  update._enter = enter;
+  update._exit = exit;
+  return update;
+};
+
+var selection_exit = function() {
+  return new Selection(this._exit || this._groups.map(sparse), this._parents);
+};
+
+var selection_merge = function(selection$$1) {
+
+  for (var groups0 = this._groups, groups1 = selection$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
+    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
+      if (node = group0[i] || group1[i]) {
+        merge[i] = node;
+      }
+    }
+  }
+
+  for (; j < m0; ++j) {
+    merges[j] = groups0[j];
+  }
+
+  return new Selection(merges, this._parents);
+};
+
+var selection_order = function() {
+
+  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
+    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
+      if (node = group[i]) {
+        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
+        next = node;
+      }
+    }
+  }
+
+  return this;
+};
+
+var selection_sort = function(compare) {
+  if (!compare) compare = ascending;
+
+  function compareNode(a, b) {
+    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
+  }
+
+  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
+    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
+      if (node = group[i]) {
+        sortgroup[i] = node;
+      }
+    }
+    sortgroup.sort(compareNode);
+  }
+
+  return new Selection(sortgroups, this._parents).order();
+};
+
+function ascending(a, b) {
+  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
+}
+
+var selection_call = function() {
+  var callback = arguments[0];
+  arguments[0] = this;
+  callback.apply(null, arguments);
+  return this;
+};
+
+var selection_nodes = function() {
+  var nodes = new Array(this.size()), i = -1;
+  this.each(function() { nodes[++i] = this; });
+  return nodes;
+};
+
+var selection_node = function() {
+
+  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
+    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
+      var node = group[i];
+      if (node) return node;
+    }
+  }
+
+  return null;
+};
+
+var selection_size = function() {
+  var size = 0;
+  this.each(function() { ++size; });
+  return size;
+};
+
+var selection_empty = function() {
+  return !this.node();
+};
+
+var selection_each = function(callback) {
+
+  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
+    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
+      if (node = group[i]) callback.call(node, node.__data__, i, group);
+    }
+  }
+
+  return this;
+};
+
+function attrRemove(name) {
+  return function() {
+    this.removeAttribute(name);
+  };
+}
+
+function attrRemoveNS(fullname) {
+  return function() {
+    this.removeAttributeNS(fullname.space, fullname.local);
+  };
+}
+
+function attrConstant(name, value) {
+  return function() {
+    this.setAttribute(name, value);
+  };
+}
+
+function attrConstantNS(fullname, value) {
+  return function() {
+    this.setAttributeNS(fullname.space, fullname.local, value);
+  };
+}
+
+function attrFunction(name, value) {
+  return function() {
+    var v = value.apply(this, arguments);
+    if (v == null) this.removeAttribute(name);
+    else this.setAttribute(name, v);
+  };
+}
+
+function attrFunctionNS(fullname, value) {
+  return function() {
+    var v = value.apply(this, arguments);
+    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
+    else this.setAttributeNS(fullname.space, fullname.local, v);
+  };
+}
+
+var selection_attr = function(name, value) {
+  var fullname = namespace(name);
+
+  if (arguments.length < 2) {
+    var node = this.node();
+    return fullname.local
+        ? node.getAttributeNS(fullname.space, fullname.local)
+        : node.getAttribute(fullname);
+  }
+
+  return this.each((value == null
+      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
+      ? (fullname.local ? attrFunctionNS : attrFunction)
+      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
+};
+
+var defaultView = function(node) {
+  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
+      || (node.document && node) // node is a Window
+      || node.defaultView; // node is a Document
+};
+
+function styleRemove(name) {
+  return function() {
+    this.style.removeProperty(name);
+  };
+}
+
+function styleConstant(name, value, priority) {
+  return function() {
+    this.style.setProperty(name, value, priority);
+  };
+}
+
+function styleFunction(name, value, priority) {
+  return function() {
+    var v = value.apply(this, arguments);
+    if (v == null) this.style.removeProperty(name);
+    else this.style.setProperty(name, v, priority);
+  };
+}
+
+var selection_style = function(name, value, priority) {
+  return arguments.length > 1
+      ? this.each((value == null
+            ? styleRemove : typeof value === "function"
+            ? styleFunction
+            : styleConstant)(name, value, priority == null ? "" : priority))
+      : styleValue(this.node(), name);
+};
+
+function styleValue(node, name) {
+  return node.style.getPropertyValue(name)
+      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
+}
+
+function propertyRemove(name) {
+  return function() {
+    delete this[name];
+  };
+}
+
+function propertyConstant(name, value) {
+  return function() {
+    this[name] = value;
+  };
+}
+
+function propertyFunction(name, value) {
+  return function() {
+    var v = value.apply(this, arguments);
+    if (v == null) delete this[name];
+    else this[name] = v;
+  };
+}
+
+var selection_property = function(name, value) {
+  return arguments.length > 1
+      ? this.each((value == null
+          ? propertyRemove : typeof value === "function"
+          ? propertyFunction
+          : propertyConstant)(name, value))
+      : this.node()[name];
+};
+
+function classArray(string) {
+  return string.trim().split(/^|\s+/);
+}
+
+function classList(node) {
+  return node.classList || new ClassList(node);
+}
+
+function ClassList(node) {
+  this._node = node;
+  this._names = classArray(node.getAttribute("class") || "");
+}
+
+ClassList.prototype = {
+  add: function(name) {
+    var i = this._names.indexOf(name);
+    if (i < 0) {
+      this._names.push(name);
+      this._node.setAttribute("class", this._names.join(" "));
+    }
+  },
+  remove: function(name) {
+    var i = this._names.indexOf(name);
+    if (i >= 0) {
+      this._names.splice(i, 1);
+      this._node.setAttribute("class", this._names.join(" "));
+    }
+  },
+  contains: function(name) {
+    return this._names.indexOf(name) >= 0;
+  }
+};
+
+function classedAdd(node, names) {
+  var list = classList(node), i = -1, n = names.length;
+  while (++i < n) list.add(names[i]);
+}
+
+function classedRemove(node, names) {
+  var list = classList(node), i = -1, n = names.length;
+  while (++i < n) list.remove(names[i]);
+}
+
+function classedTrue(names) {
+  return function() {
+    classedAdd(this, names);
+  };
+}
+
+function classedFalse(names) {
+  return function() {
+    classedRemove(this, names);
+  };
+}
+
+function classedFunction(names, value) {
+  return function() {
+    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
+  };
+}
+
+var selection_classed = function(name, value) {
+  var names = classArray(name + "");
+
+  if (arguments.length < 2) {
+    var list = classList(this.node()), i = -1, n = names.length;
+    while (++i < n) if (!list.contains(names[i])) return false;
+    return true;
+  }
+
+  return this.each((typeof value === "function"
+      ? classedFunction : value
+      ? classedTrue
+      : classedFalse)(names, value));
+};
+
+function textRemove() {
+  this.textContent = "";
+}
+
+function textConstant(value) {
+  return function() {
+    this.textContent = value;
+  };
+}
+
+function textFunction(value) {
+  return function() {
+    var v = value.apply(this, arguments);
+    this.textContent = v == null ? "" : v;
+  };
+}
+
+var selection_text = function(value) {
+  return arguments.length
+      ? this.each(value == null
+          ? textRemove : (typeof value === "function"
+          ? textFunction
+          : textConstant)(value))
+      : this.node().textContent;
+};
+
+function htmlRemove() {
+  this.innerHTML = "";
+}
+
+function htmlConstant(value) {
+  return function() {
+    this.innerHTML = value;
+  };
+}
+
+function htmlFunction(value) {
+  return function() {
+    var v = value.apply(this, arguments);
+    this.innerHTML = v == null ? "" : v;
+  };
+}
+
+var selection_html = function(value) {
+  return arguments.length
+      ? this.each(value == null
+          ? htmlRemove : (typeof value === "function"
+          ? htmlFunction
+          : htmlConstant)(value))
+      : this.node().innerHTML;
+};
+
+function raise() {
+  if (this.nextSibling) this.parentNode.appendChild(this);
+}
+
+var selection_raise = function() {
+  return this.each(raise);
+};
+
+function lower() {
+  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
+}
+
+var selection_lower = function() {
+  return this.each(lower);
+};
+
+var selection_append = function(name) {
+  var create = typeof name === "function" ? name : creator(name);
+  return this.select(function() {
+    return this.appendChild(create.apply(this, arguments));
+  });
+};
+
+function constantNull() {
+  return null;
+}
+
+var selection_insert = function(name, before) {
+  var create = typeof name === "function" ? name : creator(name),
+      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
+  return this.select(function() {
+    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
+  });
+};
+
+function remove() {
+  var parent = this.parentNode;
+  if (parent) parent.removeChild(this);
+}
+
+var selection_remove = function() {
+  return this.each(remove);
+};
+
+var selection_datum = function(value) {
+  return arguments.length
+      ? this.property("__data__", value)
+      : this.node().__data__;
+};
+
+function dispatchEvent(node, type, params) {
+  var window = defaultView(node),
+      event = window.CustomEvent;
+
+  if (typeof event === "function") {
+    event = new event(type, params);
+  } else {
+    event = window.document.createEvent("Event");
+    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
+    else event.initEvent(type, false, false);
+  }
+
+  node.dispatchEvent(event);
+}
+
+function dispatchConstant(type, params) {
+  return function() {
+    return dispatchEvent(this, type, params);
+  };
+}
+
+function dispatchFunction(type, params) {
+  return function() {
+    return dispatchEvent(this, type, params.apply(this, arguments));
+  };
+}
+
+var selection_dispatch = function(type, params) {
+  return this.each((typeof params === "function"
+      ? dispatchFunction
+      : dispatchConstant)(type, params));
+};
+
+var root = [null];
+
+function Selection(groups, parents) {
+  this._groups = groups;
+  this._parents = parents;
+}
+
+function selection() {
+  return new Selection([[document.documentElement]], root);
+}
+
+Selection.prototype = selection.prototype = {
+  constructor: Selection,
+  select: selection_select,
+  selectAll: selection_selectAll,
+  filter: selection_filter,
+  data: selection_data,
+  enter: selection_enter,
+  exit: selection_exit,
+  merge: selection_merge,
+  order: selection_order,
+  sort: selection_sort,
+  call: selection_call,
+  nodes: selection_nodes,
+  node: selection_node,
+  size: selection_size,
+  empty: selection_empty,
+  each: selection_each,
+  attr: selection_attr,
+  style: selection_style,
+  property: selection_property,
+  classed: selection_classed,
+  text: selection_text,
+  html: selection_html,
+  raise: selection_raise,
+  lower: selection_lower,
+  append: selection_append,
+  insert: selection_insert,
+  remove: selection_remove,
+  datum: selection_datum,
+  on: selection_on,
+  dispatch: selection_dispatch
+};
+
+var select = function(selector) {
+  return typeof selector === "string"
+      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
+      : new Selection([[selector]], root);
+};
+
+function count(node) {
+  var sum = 0,
+      children = node.children,
+      i = children && children.length;
+  if (!i) sum = 1;
+  else while (--i >= 0) sum += children[i].value;
+  node.value = sum;
+}
+
+var node_count = function() {
+  return this.eachAfter(count);
+};
+
+var node_each = function(callback) {
+  var node = this, current, next = [node], children, i, n;
+  do {
+    current = next.reverse(), next = [];
+    while (node = current.pop()) {
+      callback(node), children = node.children;
+      if (children) for (i = 0, n = children.length; i < n; ++i) {
+        next.push(children[i]);
+      }
+    }
+  } while (next.length);
+  return this;
+};
+
+var node_eachBefore = function(callback) {
+  var node = this, nodes = [node], children, i;
+  while (node = nodes.pop()) {
+    callback(node), children = node.children;
+    if (children) for (i = children.length - 1; i >= 0; --i) {
+      nodes.push(children[i]);
+    }
+  }
+  return this;
+};
+
+var node_eachAfter = function(callback) {
+  var node = this, nodes = [node], next = [], children, i, n;
+  while (node = nodes.pop()) {
+    next.push(node), children = node.children;
+    if (children) for (i = 0, n = children.length; i < n; ++i) {
+      nodes.push(children[i]);
+    }
+  }
+  while (node = next.pop()) {
+    callback(node);
+  }
+  return this;
+};
+
+var node_sum = function(value) {
+  return this.eachAfter(function(node) {
+    var sum = +value(node.data) || 0,
+        children = node.children,
+        i = children && children.length;
+    while (--i >= 0) sum += children[i].value;
+    node.value = sum;
+  });
+};
+
+var node_sort = function(compare) {
+  return this.eachBefore(function(node) {
+    if (node.children) {
+      node.children.sort(compare);
+    }
+  });
+};
+
+var node_path = function(end) {
+  var start = this,
+      ancestor = leastCommonAncestor(start, end),
+      nodes = [start];
+  while (start !== ancestor) {
+    start = start.parent;
+    nodes.push(start);
+  }
+  var k = nodes.length;
+  while (end !== ancestor) {
+    nodes.splice(k, 0, end);
+    end = end.parent;
+  }
+  return nodes;
+};
+
+function leastCommonAncestor(a, b) {
+  if (a === b) return a;
+  var aNodes = a.ancestors(),
+      bNodes = b.ancestors(),
+      c = null;
+  a = aNodes.pop();
+  b = bNodes.pop();
+  while (a === b) {
+    c = a;
+    a = aNodes.pop();
+    b = bNodes.pop();
+  }
+  return c;
+}
+
+var node_ancestors = function() {
+  var node = this, nodes = [node];
+  while (node = node.parent) {
+    nodes.push(node);
+  }
+  return nodes;
+};
+
+var node_descendants = function() {
+  var nodes = [];
+  this.each(function(node) {
+    nodes.push(node);
+  });
+  return nodes;
+};
+
+var node_leaves = function() {
+  var leaves = [];
+  this.eachBefore(function(node) {
+    if (!node.children) {
+      leaves.push(node);
+    }
+  });
+  return leaves;
+};
+
+var node_links = function() {
+  var root = this, links = [];
+  root.each(function(node) {
+    if (node !== root) { // Don’t include the root’s parent, if any.
+      links.push({source: node.parent, target: node});
+    }
+  });
+  return links;
+};
+
+function hierarchy(data, children) {
+  var root = new Node(data),
+      valued = +data.value && (root.value = data.value),
+      node,
+      nodes = [root],
+      child,
+      childs,
+      i,
+      n;
+
+  if (children == null) children = defaultChildren;
+
+  while (node = nodes.pop()) {
+    if (valued) node.value = +node.data.value;
+    if ((childs = children(node.data)) && (n = childs.length)) {
+      node.children = new Array(n);
+      for (i = n - 1; i >= 0; --i) {
+        nodes.push(child = node.children[i] = new Node(childs[i]));
+        child.parent = node;
+        child.depth = node.depth + 1;
+      }
+    }
+  }
+
+  return root.eachBefore(computeHeight);
+}
+
+function node_copy() {
+  return hierarchy(this).eachBefore(copyData);
+}
+
+function defaultChildren(d) {
+  return d.children;
+}
+
+function copyData(node) {
+  node.data = node.data.data;
+}
+
+function computeHeight(node) {
+  var height = 0;
+  do node.height = height;
+  while ((node = node.parent) && (node.height < ++height));
+}
+
+function Node(data) {
+  this.data = data;
+  this.depth =
+  this.height = 0;
+  this.parent = null;
+}
+
+Node.prototype = hierarchy.prototype = {
+  constructor: Node,
+  count: node_count,
+  each: node_each,
+  eachAfter: node_eachAfter,
+  eachBefore: node_eachBefore,
+  sum: node_sum,
+  sort: node_sort,
+  path: node_path,
+  ancestors: node_ancestors,
+  descendants: node_descendants,
+  leaves: node_leaves,
+  links: node_links,
+  copy: node_copy
+};
+
+var roundNode = function(node) {
+  node.x0 = Math.round(node.x0);
+  node.y0 = Math.round(node.y0);
+  node.x1 = Math.round(node.x1);
+  node.y1 = Math.round(node.y1);
+};
+
+var treemapDice = function(parent, x0, y0, x1, y1) {
+  var nodes = parent.children,
+      node,
+      i = -1,
+      n = nodes.length,
+      k = parent.value && (x1 - x0) / parent.value;
+
+  while (++i < n) {
+    node = nodes[i], node.y0 = y0, node.y1 = y1;
+    node.x0 = x0, node.x1 = x0 += node.value * k;
+  }
+};
+
+var partition = function() {
+  var dx = 1,
+      dy = 1,
+      padding = 0,
+      round = false;
+
+  function partition(root) {
+    var n = root.height + 1;
+    root.x0 =
+    root.y0 = padding;
+    root.x1 = dx;
+    root.y1 = dy / n;
+    root.eachBefore(positionNode(dy, n));
+    if (round) root.eachBefore(roundNode);
+    return root;
+  }
+
+  function positionNode(dy, n) {
+    return function(node) {
+      if (node.children) {
+        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
+      }
+      var x0 = node.x0,
+          y0 = node.y0,
+          x1 = node.x1 - padding,
+          y1 = node.y1 - padding;
+      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
+      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
+      node.x0 = x0;
+      node.y0 = y0;
+      node.x1 = x1;
+      node.y1 = y1;
+    };
+  }
+
+  partition.round = function(x) {
+    return arguments.length ? (round = !!x, partition) : round;
+  };
+
+  partition.size = function(x) {
+    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
+  };
+
+  partition.padding = function(x) {
+    return arguments.length ? (padding = +x, partition) : padding;
+  };
+
+  return partition;
+};
+
+var ascending$1 = function(a, b) {
+  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
+};
+
+var bisector = function(compare) {
+  if (compare.length === 1) compare = ascendingComparator(compare);
+  return {
+    left: function(a, x, lo, hi) {
+      if (lo == null) lo = 0;
+      if (hi == null) hi = a.length;
+      while (lo < hi) {
+        var mid = lo + hi >>> 1;
+        if (compare(a[mid], x) < 0) lo = mid + 1;
+        else hi = mid;
+      }
+      return lo;
+    },
+    right: function(a, x, lo, hi) {
+      if (lo == null) lo = 0;
+      if (hi == null) hi = a.length;
+      while (lo < hi) {
+        var mid = lo + hi >>> 1;
+        if (compare(a[mid], x) > 0) hi = mid;
+        else lo = mid + 1;
+      }
+      return lo;
+    }
+  };
+};
+
+function ascendingComparator(f) {
+  return function(d, x) {
+    return ascending$1(f(d), x);
+  };
+}
+
+var ascendingBisect = bisector(ascending$1);
+var bisectRight = ascendingBisect.right;
+
+var e10 = Math.sqrt(50);
+var e5 = Math.sqrt(10);
+var e2 = Math.sqrt(2);
+
+var ticks = function(start, stop, count) {
+  var reverse,
+      i = -1,
+      n,
+      ticks,
+      step;
+
+  stop = +stop, start = +start, count = +count;
+  if (start === stop && count > 0) return [start];
+  if (reverse = stop < start) n = start, start = stop, stop = n;
+  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];
+
+  if (step > 0) {
+    start = Math.ceil(start / step);
+    stop = Math.floor(stop / step);
+    ticks = new Array(n = Math.ceil(stop - start + 1));
+    while (++i < n) ticks[i] = (start + i) * step;
+  } else {
+    start = Math.floor(start * step);
+    stop = Math.ceil(stop * step);
+    ticks = new Array(n = Math.ceil(start - stop + 1));
+    while (++i < n) ticks[i] = (start - i) / step;
+  }
+
+  if (reverse) ticks.reverse();
+
+  return ticks;
+};
+
+function tickIncrement(start, stop, count) {
+  var step = (stop - start) / Math.max(0, count),
+      power = Math.floor(Math.log(step) / Math.LN10),
+      error = step / Math.pow(10, power);
+  return power >= 0
+      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
+      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
+}
+
+function tickStep(start, stop, count) {
+  var step0 = Math.abs(stop - start) / Math.max(0, count),
+      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
+      error = step0 / step1;
+  if (error >= e10) step1 *= 10;
+  else if (error >= e5) step1 *= 5;
+  else if (error >= e2) step1 *= 2;
+  return stop < start ? -step1 : step1;
+}
+
+var prefix = "$";
+
+function Map() {}
+
+Map.prototype = map$1.prototype = {
+  constructor: Map,
+  has: function(key) {
+    return (prefix + key) in this;
+  },
+  get: function(key) {
+    return this[prefix + key];
+  },
+  set: function(key, value) {
+    this[prefix + key] = value;
+    return this;
+  },
+  remove: function(key) {
+    var property = prefix + key;
+    return property in this && delete this[property];
+  },
+  clear: function() {
+    for (var property in this) if (property[0] === prefix) delete this[property];
+  },
+  keys: function() {
+    var keys = [];
+    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
+    return keys;
+  },
+  values: function() {
+    var values = [];
+    for (var property in this) if (property[0] === prefix) values.push(this[property]);
+    return values;
+  },
+  entries: function() {
+    var entries = [];
+    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
+    return entries;
+  },
+  size: function() {
+    var size = 0;
+    for (var property in this) if (property[0] === prefix) ++size;
+    return size;
+  },
+  empty: function() {
+    for (var property in this) if (property[0] === prefix) return false;
+    return true;
+  },
+  each: function(f) {
+    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
+  }
+};
+
+function map$1(object, f) {
+  var map = new Map;
+
+  // Copy constructor.
+  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });
+
+  // Index array by numeric index or specified key function.
+  else if (Array.isArray(object)) {
+    var i = -1,
+        n = object.length,
+        o;
+
+    if (f == null) while (++i < n) map.set(i, object[i]);
+    else while (++i < n) map.set(f(o = object[i], i, object), o);
+  }
+
+  // Convert object to map.
+  else if (object) for (var key in object) map.set(key, object[key]);
+
+  return map;
+}
+
+function Set() {}
+
+var proto = map$1.prototype;
+
+Set.prototype = set.prototype = {
+  constructor: Set,
+  has: proto.has,
+  add: function(value) {
+    value += "";
+    this[prefix + value] = value;
+    return this;
+  },
+  remove: proto.remove,
+  clear: proto.clear,
+  values: proto.keys,
+  size: proto.size,
+  empty: proto.empty,
+  each: proto.each
+};
+
+function set(object, f) {
+  var set = new Set;
+
+  // Copy constructor.
+  if (object instanceof Set) object.each(function(value) { set.add(value); });
+
+  // Otherwise, assume it’s an array.
+  else if (object) {
+    var i = -1, n = object.length;
+    if (f == null) while (++i < n) set.add(object[i]);
+    else while (++i < n) set.add(f(object[i], i, object));
+  }
+
+  return set;
+}
+
+var array$1 = Array.prototype;
+
+var map$3 = array$1.map;
+var slice$2 = array$1.slice;
+
+var define = function(constructor, factory, prototype) {
+  constructor.prototype = factory.prototype = prototype;
+  prototype.constructor = constructor;
+};
+
+function extend(parent, definition) {
+  var prototype = Object.create(parent.prototype);
+  for (var key in definition) prototype[key] = definition[key];
+  return prototype;
+}
+
+function Color() {}
+
+var darker = 0.7;
+var brighter = 1 / darker;
+
+var reI = "\\s*([+-]?\\d+)\\s*";
+var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
+var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
+var reHex3 = /^#([0-9a-f]{3})$/;
+var reHex6 = /^#([0-9a-f]{6})$/;
+var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
+var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
+var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
+var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
+var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
+var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
+
+var named = {
+  aliceblue: 0xf0f8ff,
+  antiquewhite: 0xfaebd7,
+  aqua: 0x00ffff,
+  aquamarine: 0x7fffd4,
+  azure: 0xf0ffff,
+  beige: 0xf5f5dc,
+  bisque: 0xffe4c4,
+  black: 0x000000,
+  blanchedalmond: 0xffebcd,
+  blue: 0x0000ff,
+  blueviolet: 0x8a2be2,
+  brown: 0xa52a2a,
+  burlywood: 0xdeb887,
+  cadetblue: 0x5f9ea0,
+  chartreuse: 0x7fff00,
+  chocolate: 0xd2691e,
+  coral: 0xff7f50,
+  cornflowerblue: 0x6495ed,
+  cornsilk: 0xfff8dc,
+  crimson: 0xdc143c,
+  cyan: 0x00ffff,
+  darkblue: 0x00008b,
+  darkcyan: 0x008b8b,
+  darkgoldenrod: 0xb8860b,
+  darkgray: 0xa9a9a9,
+  darkgreen: 0x006400,
+  darkgrey: 0xa9a9a9,
+  darkkhaki: 0xbdb76b,
+  darkmagenta: 0x8b008b,
+  darkolivegreen: 0x556b2f,
+  darkorange: 0xff8c00,
+  darkorchid: 0x9932cc,
+  darkred: 0x8b0000,
+  darksalmon: 0xe9967a,
+  darkseagreen: 0x8fbc8f,
+  darkslateblue: 0x483d8b,
+  darkslategray: 0x2f4f4f,
+  darkslategrey: 0x2f4f4f,
+  darkturquoise: 0x00ced1,
+  darkviolet: 0x9400d3,
+  deeppink: 0xff1493,
+  deepskyblue: 0x00bfff,
+  dimgray: 0x696969,
+  dimgrey: 0x696969,
+  dodgerblue: 0x1e90ff,
+  firebrick: 0xb22222,
+  floralwhite: 0xfffaf0,
+  forestgreen: 0x228b22,
+  fuchsia: 0xff00ff,
+  gainsboro: 0xdcdcdc,
+  ghostwhite: 0xf8f8ff,
+  gold: 0xffd700,
+  goldenrod: 0xdaa520,
+  gray: 0x808080,
+  green: 0x008000,
+  greenyellow: 0xadff2f,
+  grey: 0x808080,
+  honeydew: 0xf0fff0,
+  hotpink: 0xff69b4,
+  indianred: 0xcd5c5c,
+  indigo: 0x4b0082,
+  ivory: 0xfffff0,
+  khaki: 0xf0e68c,
+  lavender: 0xe6e6fa,
+  lavenderblush: 0xfff0f5,
+  lawngreen: 0x7cfc00,
+  lemonchiffon: 0xfffacd,
+  lightblue: 0xadd8e6,
+  lightcoral: 0xf08080,
+  lightcyan: 0xe0ffff,
+  lightgoldenrodyellow: 0xfafad2,
+  lightgray: 0xd3d3d3,
+  lightgreen: 0x90ee90,
+  lightgrey: 0xd3d3d3,
+  lightpink: 0xffb6c1,
+  lightsalmon: 0xffa07a,
+  lightseagreen: 0x20b2aa,
+  lightskyblue: 0x87cefa,
+  lightslategray: 0x778899,
+  lightslategrey: 0x778899,
+  lightsteelblue: 0xb0c4de,
+  lightyellow: 0xffffe0,
+  lime: 0x00ff00,
+  limegreen: 0x32cd32,
+  linen: 0xfaf0e6,
+  magenta: 0xff00ff,
+  maroon: 0x800000,
+  mediumaquamarine: 0x66cdaa,
+  mediumblue: 0x0000cd,
+  mediumorchid: 0xba55d3,
+  mediumpurple: 0x9370db,
+  mediumseagreen: 0x3cb371,
+  mediumslateblue: 0x7b68ee,
+  mediumspringgreen: 0x00fa9a,
+  mediumturquoise: 0x48d1cc,
+  mediumvioletred: 0xc71585,
+  midnightblue: 0x191970,
+  mintcream: 0xf5fffa,
+  mistyrose: 0xffe4e1,
+  moccasin: 0xffe4b5,
+  navajowhite: 0xffdead,
+  navy: 0x000080,
+  oldlace: 0xfdf5e6,
+  olive: 0x808000,
+  olivedrab: 0x6b8e23,
+  orange: 0xffa500,
+  orangered: 0xff4500,
+  orchid: 0xda70d6,
+  palegoldenrod: 0xeee8aa,
+  palegreen: 0x98fb98,
+  paleturquoise: 0xafeeee,
+  palevioletred: 0xdb7093,
+  papayawhip: 0xffefd5,
+  peachpuff: 0xffdab9,
+  peru: 0xcd853f,
+  pink: 0xffc0cb,
+  plum: 0xdda0dd,
+  powderblue: 0xb0e0e6,
+  purple: 0x800080,
+  rebeccapurple: 0x663399,
+  red: 0xff0000,
+  rosybrown: 0xbc8f8f,
+  royalblue: 0x4169e1,
+  saddlebrown: 0x8b4513,
+  salmon: 0xfa8072,
+  sandybrown: 0xf4a460,
+  seagreen: 0x2e8b57,
+  seashell: 0xfff5ee,
+  sienna: 0xa0522d,
+  silver: 0xc0c0c0,
+  skyblue: 0x87ceeb,
+  slateblue: 0x6a5acd,
+  slategray: 0x708090,
+  slategrey: 0x708090,
+  snow: 0xfffafa,
+  springgreen: 0x00ff7f,
+  steelblue: 0x4682b4,
+  tan: 0xd2b48c,
+  teal: 0x008080,
+  thistle: 0xd8bfd8,
+  tomato: 0xff6347,
+  turquoise: 0x40e0d0,
+  violet: 0xee82ee,
+  wheat: 0xf5deb3,
+  white: 0xffffff,
+  whitesmoke: 0xf5f5f5,
+  yellow: 0xffff00,
+  yellowgreen: 0x9acd32
+};
+
+define(Color, color, {
+  displayable: function() {
+    return this.rgb().displayable();
+  },
+  toString: function() {
+    return this.rgb() + "";
+  }
+});
+
+function color(format) {
+  var m;
+  format = (format + "").trim().toLowerCase();
+  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
+      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
+      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
+      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
+      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
+      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
+      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
+      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
+      : named.hasOwnProperty(format) ? rgbn(named[format])
+      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
+      : null;
+}
+
+function rgbn(n) {
+  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
+}
+
+function rgba(r, g, b, a) {
+  if (a <= 0) r = g = b = NaN;
+  return new Rgb(r, g, b, a);
+}
+
+function rgbConvert(o) {
+  if (!(o instanceof Color)) o = color(o);
+  if (!o) return new Rgb;
+  o = o.rgb();
+  return new Rgb(o.r, o.g, o.b, o.opacity);
+}
+
+function rgb(r, g, b, opacity) {
+  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
+}
+
+function Rgb(r, g, b, opacity) {
+  this.r = +r;
+  this.g = +g;
+  this.b = +b;
+  this.opacity = +opacity;
+}
+
+define(Rgb, rgb, extend(Color, {
+  brighter: function(k) {
+    k = k == null ? brighter : Math.pow(brighter, k);
+    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
+  },
+  darker: function(k) {
+    k = k == null ? darker : Math.pow(darker, k);
+    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
+  },
+  rgb: function() {
+    return this;
+  },
+  displayable: function() {
+    return (0 <= this.r && this.r <= 255)
+        && (0 <= this.g && this.g <= 255)
+        && (0 <= this.b && this.b <= 255)
+        && (0 <= this.opacity && this.opacity <= 1);
+  },
+  toString: function() {
+    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
+    return (a === 1 ? "rgb(" : "rgba(")
+        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
+        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
+        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
+        + (a === 1 ? ")" : ", " + a + ")");
+  }
+}));
+
+function hsla(h, s, l, a) {
+  if (a <= 0) h = s = l = NaN;
+  else if (l <= 0 || l >= 1) h = s = NaN;
+  else if (s <= 0) h = NaN;
+  return new Hsl(h, s, l, a);
+}
+
+function hslConvert(o) {
+  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
+  if (!(o instanceof Color)) o = color(o);
+  if (!o) return new Hsl;
+  if (o instanceof Hsl) return o;
+  o = o.rgb();
+  var r = o.r / 255,
+      g = o.g / 255,
+      b = o.b / 255,
+      min = Math.min(r, g, b),
+      max = Math.max(r, g, b),
+      h = NaN,
+      s = max - min,
+      l = (max + min) / 2;
+  if (s) {
+    if (r === max) h = (g - b) / s + (g < b) * 6;
+    else if (g === max) h = (b - r) / s + 2;
+    else h = (r - g) / s + 4;
+    s /= l < 0.5 ? max + min : 2 - max - min;
+    h *= 60;
+  } else {
+    s = l > 0 && l < 1 ? 0 : h;
+  }
+  return new Hsl(h, s, l, o.opacity);
+}
+
+function hsl(h, s, l, opacity) {
+  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
+}
+
+function Hsl(h, s, l, opacity) {
+  this.h = +h;
+  this.s = +s;
+  this.l = +l;
+  this.opacity = +opacity;
+}
+
+define(Hsl, hsl, extend(Color, {
+  brighter: function(k) {
+    k = k == null ? brighter : Math.pow(brighter, k);
+    return new Hsl(this.h, this.s, this.l * k, this.opacity);
+  },
+  darker: function(k) {
+    k = k == null ? darker : Math.pow(darker, k);
+    return new Hsl(this.h, this.s, this.l * k, this.opacity);
+  },
+  rgb: function() {
+    var h = this.h % 360 + (this.h < 0) * 360,
+        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
+        l = this.l,
+        m2 = l + (l < 0.5 ? l : 1 - l) * s,
+        m1 = 2 * l - m2;
+    return new Rgb(
+      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
+      hsl2rgb(h, m1, m2),
+      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
+      this.opacity
+    );
+  },
+  displayable: function() {
+    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
+        && (0 <= this.l && this.l <= 1)
+        && (0 <= this.opacity && this.opacity <= 1);
+  }
+}));
+
+/* From FvD 13.37, CSS Color Module Level 3 */
+function hsl2rgb(h, m1, m2) {
+  return (h < 60 ? m1 + (m2 - m1) * h / 60
+      : h < 180 ? m2
+      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
+      : m1) * 255;
+}
+
+var deg2rad = Math.PI / 180;
+var rad2deg = 180 / Math.PI;
+
+var Kn = 18;
+var Xn = 0.950470;
+var Yn = 1;
+var Zn = 1.088830;
+var t0 = 4 / 29;
+var t1 = 6 / 29;
+var t2 = 3 * t1 * t1;
+var t3 = t1 * t1 * t1;
+
+function labConvert(o) {
+  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
+  if (o instanceof Hcl) {
+    var h = o.h * deg2rad;
+    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
+  }
+  if (!(o instanceof Rgb)) o = rgbConvert(o);
+  var b = rgb2xyz(o.r),
+      a = rgb2xyz(o.g),
+      l = rgb2xyz(o.b),
+      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
+      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
+      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
+  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
+}
+
+function lab(l, a, b, opacity) {
+  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
+}
+
+function Lab(l, a, b, opacity) {
+  this.l = +l;
+  this.a = +a;
+  this.b = +b;
+  this.opacity = +opacity;
+}
+
+define(Lab, lab, extend(Color, {
+  brighter: function(k) {
+    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
+  },
+  darker: function(k) {
+    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
+  },
+  rgb: function() {
+    var y = (this.l + 16) / 116,
+        x = isNaN(this.a) ? y : y + this.a / 500,
+        z = isNaN(this.b) ? y : y - this.b / 200;
+    y = Yn * lab2xyz(y);
+    x = Xn * lab2xyz(x);
+    z = Zn * lab2xyz(z);
+    return new Rgb(
+      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
+      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),
+      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z),
+      this.opacity
+    );
+  }
+}));
+
+function xyz2lab(t) {
+  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
+}
+
+function lab2xyz(t) {
+  return t > t1 ? t * t * t : t2 * (t - t0);
+}
+
+function xyz2rgb(x) {
+  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
+}
+
+function rgb2xyz(x) {
+  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
+}
+
+function hclConvert(o) {
+  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
+  if (!(o instanceof Lab)) o = labConvert(o);
+  var h = Math.atan2(o.b, o.a) * rad2deg;
+  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
+}
+
+function hcl(h, c, l, opacity) {
+  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
+}
+
+function Hcl(h, c, l, opacity) {
+  this.h = +h;
+  this.c = +c;
+  this.l = +l;
+  this.opacity = +opacity;
+}
+
+define(Hcl, hcl, extend(Color, {
+  brighter: function(k) {
+    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
+  },
+  darker: function(k) {
+    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
+  },
+  rgb: function() {
+    return labConvert(this).rgb();
+  }
+}));
+
+var A = -0.14861;
+var B = +1.78277;
+var C = -0.29227;
+var D = -0.90649;
+var E = +1.97294;
+var ED = E * D;
+var EB = E * B;
+var BC_DA = B * C - D * A;
+
+function cubehelixConvert(o) {
+  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
+  if (!(o instanceof Rgb)) o = rgbConvert(o);
+  var r = o.r / 255,
+      g = o.g / 255,
+      b = o.b / 255,
+      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
+      bl = b - l,
+      k = (E * (g - l) - C * bl) / D,
+      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
+      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
+  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
+}
+
+function cubehelix(h, s, l, opacity) {
+  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
+}
+
+function Cubehelix(h, s, l, opacity) {
+  this.h = +h;
+  this.s = +s;
+  this.l = +l;
+  this.opacity = +opacity;
+}
+
+define(Cubehelix, cubehelix, extend(Color, {
+  brighter: function(k) {
+    k = k == null ? brighter : Math.pow(brighter, k);
+    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
+  },
+  darker: function(k) {
+    k = k == null ? darker : Math.pow(darker, k);
+    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
+  },
+  rgb: function() {
+    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
+        l = +this.l,
+        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
+        cosh = Math.cos(h),
+        sinh = Math.sin(h);
+    return new Rgb(
+      255 * (l + a * (A * cosh + B * sinh)),
+      255 * (l + a * (C * cosh + D * sinh)),
+      255 * (l + a * (E * cosh)),
+      this.opacity
+    );
+  }
+}));
+
+var constant$3 = function(x) {
+  return function() {
+    return x;
+  };
+};
+
+function linear$1(a, d) {
+  return function(t) {
+    return a + t * d;
+  };
+}
+
+function exponential(a, b, y) {
+  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
+    return Math.pow(a + t * b, y);
+  };
+}
+
+function hue(a, b) {
+  var d = b - a;
+  return d ? linear$1(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a) ? b : a);
+}
+
+function gamma(y) {
+  return (y = +y) === 1 ? nogamma : function(a, b) {
+    return b - a ? exponential(a, b, y) : constant$3(isNaN(a) ? b : a);
+  };
+}
+
+function nogamma(a, b) {
+  var d = b - a;
+  return d ? linear$1(a, d) : constant$3(isNaN(a) ? b : a);
+}
+
+var interpolateRgb = (function rgbGamma(y) {
+  var color$$1 = gamma(y);
+
+  function rgb$$1(start, end) {
+    var r = color$$1((start = rgb(start)).r, (end = rgb(end)).r),
+        g = color$$1(start.g, end.g),
+        b = color$$1(start.b, end.b),
+        opacity = nogamma(start.opacity, end.opacity);
+    return function(t) {
+      start.r = r(t);
+      start.g = g(t);
+      start.b = b(t);
+      start.opacity = opacity(t);
+      return start + "";
+    };
+  }
+
+  rgb$$1.gamma = rgbGamma;
+
+  return rgb$$1;
+})(1);
+
+var array$2 = function(a, b) {
+  var nb = b ? b.length : 0,
+      na = a ? Math.min(nb, a.length) : 0,
+      x = new Array(nb),
+      c = new Array(nb),
+      i;
+
+  for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);
+  for (; i < nb; ++i) c[i] = b[i];
+
+  return function(t) {
+    for (i = 0; i < na; ++i) c[i] = x[i](t);
+    return c;
+  };
+};
+
+var date = function(a, b) {
+  var d = new Date;
+  return a = +a, b -= a, function(t) {
+    return d.setTime(a + b * t), d;
+  };
+};
+
+var interpolateNumber = function(a, b) {
+  return a = +a, b -= a, function(t) {
+    return a + b * t;
+  };
+};
+
+var object = function(a, b) {
+  var i = {},
+      c = {},
+      k;
+
+  if (a === null || typeof a !== "object") a = {};
+  if (b === null || typeof b !== "object") b = {};
+
+  for (k in b) {
+    if (k in a) {
+      i[k] = interpolateValue(a[k], b[k]);
+    } else {
+      c[k] = b[k];
+    }
+  }
+
+  return function(t) {
+    for (k in i) c[k] = i[k](t);
+    return c;
+  };
+};
+
+var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
+var reB = new RegExp(reA.source, "g");
+
+function zero(b) {
+  return function() {
+    return b;
+  };
+}
+
+function one(b) {
+  return function(t) {
+    return b(t) + "";
+  };
+}
+
+var interpolateString = function(a, b) {
+  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
+      am, // current match in a
+      bm, // current match in b
+      bs, // string preceding current number in b, if any
+      i = -1, // index in s
+      s = [], // string constants and placeholders
+      q = []; // number interpolators
+
+  // Coerce inputs to strings.
+  a = a + "", b = b + "";
+
+  // Interpolate pairs of numbers in a & b.
+  while ((am = reA.exec(a))
+      && (bm = reB.exec(b))) {
+    if ((bs = bm.index) > bi) { // a string precedes the next number in b
+      bs = b.slice(bi, bs);
+      if (s[i]) s[i] += bs; // coalesce with previous string
+      else s[++i] = bs;
+    }
+    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
+      if (s[i]) s[i] += bm; // coalesce with previous string
+      else s[++i] = bm;
+    } else { // interpolate non-matching numbers
+      s[++i] = null;
+      q.push({i: i, x: interpolateNumber(am, bm)});
+    }
+    bi = reB.lastIndex;
+  }
+
+  // Add remains of b.
+  if (bi < b.length) {
+    bs = b.slice(bi);
+    if (s[i]) s[i] += bs; // coalesce with previous string
+    else s[++i] = bs;
+  }
+
+  // Special optimization for only a single match.
+  // Otherwise, interpolate each of the numbers and rejoin the string.
+  return s.length < 2 ? (q[0]
+      ? one(q[0].x)
+      : zero(b))
+      : (b = q.length, function(t) {
+          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
+          return s.join("");
+        });
+};
+
+var interpolateValue = function(a, b) {
+  var t = typeof b, c;
+  return b == null || t === "boolean" ? constant$3(b)
+      : (t === "number" ? interpolateNumber
+      : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
+      : b instanceof color ? interpolateRgb
+      : b instanceof Date ? date
+      : Array.isArray(b) ? array$2
+      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
+      : interpolateNumber)(a, b);
+};
+
+var interpolateRound = function(a, b) {
+  return a = +a, b -= a, function(t) {
+    return Math.round(a + b * t);
+  };
+};
+
+var degrees = 180 / Math.PI;
+
+var identity$2 = {
+  translateX: 0,
+  translateY: 0,
+  rotate: 0,
+  skewX: 0,
+  scaleX: 1,
+  scaleY: 1
+};
+
+var decompose = function(a, b, c, d, e, f) {
+  var scaleX, scaleY, skewX;
+  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
+  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
+  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
+  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
+  return {
+    translateX: e,
+    translateY: f,
+    rotate: Math.atan2(b, a) * degrees,
+    skewX: Math.atan(skewX) * degrees,
+    scaleX: scaleX,
+    scaleY: scaleY
+  };
+};
+
+var cssNode;
+var cssRoot;
+var cssView;
+var svgNode;
+
+function parseCss(value) {
+  if (value === "none") return identity$2;
+  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
+  cssNode.style.transform = value;
+  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
+  cssRoot.removeChild(cssNode);
+  value = value.slice(7, -1).split(",");
+  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
+}
+
+function parseSvg(value) {
+  if (value == null) return identity$2;
+  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
+  svgNode.setAttribute("transform", value);
+  if (!(value = svgNode.transform.baseVal.consolidate())) return identity$2;
+  value = value.matrix;
+  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
+}
+
+function interpolateTransform(parse, pxComma, pxParen, degParen) {
+
+  function pop(s) {
+    return s.length ? s.pop() + " " : "";
+  }
+
+  function translate(xa, ya, xb, yb, s, q) {
+    if (xa !== xb || ya !== yb) {
+      var i = s.push("translate(", null, pxComma, null, pxParen);
+      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
+    } else if (xb || yb) {
+      s.push("translate(" + xb + pxComma + yb + pxParen);
+    }
+  }
+
+  function rotate(a, b, s, q) {
+    if (a !== b) {
+      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
+      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
+    } else if (b) {
+      s.push(pop(s) + "rotate(" + b + degParen);
+    }
+  }
+
+  function skewX(a, b, s, q) {
+    if (a !== b) {
+      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
+    } else if (b) {
+      s.push(pop(s) + "skewX(" + b + degParen);
+    }
+  }
+
+  function scale(xa, ya, xb, yb, s, q) {
+    if (xa !== xb || ya !== yb) {
+      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
+      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
+    } else if (xb !== 1 || yb !== 1) {
+      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
+    }
+  }
+
+  return function(a, b) {
+    var s = [], // string constants and placeholders
+        q = []; // number interpolators
+    a = parse(a), b = parse(b);
+    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
+    rotate(a.rotate, b.rotate, s, q);
+    skewX(a.skewX, b.skewX, s, q);
+    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
+    a = b = null; // gc
+    return function(t) {
+      var i = -1, n = q.length, o;
+      while (++i < n) s[(o = q[i]).i] = o.x(t);
+      return s.join("");
+    };
+  };
+}
+
+var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
+var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
+
+var rho = Math.SQRT2;
+
+function cubehelix$1(hue$$1) {
+  return (function cubehelixGamma(y) {
+    y = +y;
+
+    function cubehelix$$1(start, end) {
+      var h = hue$$1((start = cubehelix(start)).h, (end = cubehelix(end)).h),
+          s = nogamma(start.s, end.s),
+          l = nogamma(start.l, end.l),
+          opacity = nogamma(start.opacity, end.opacity);
+      return function(t) {
+        start.h = h(t);
+        start.s = s(t);
+        start.l = l(Math.pow(t, y));
+        start.opacity = opacity(t);
+        return start + "";
+      };
+    }
+
+    cubehelix$$1.gamma = cubehelixGamma;
+
+    return cubehelix$$1;
+  })(1);
+}
+
+cubehelix$1(hue);
+var cubehelixLong = cubehelix$1(nogamma);
+
+var constant$4 = function(x) {
+  return function() {
+    return x;
+  };
+};
+
+var number$1 = function(x) {
+  return +x;
+};
+
+var unit = [0, 1];
+
+function deinterpolateLinear(a, b) {
+  return (b -= (a = +a))
+      ? function(x) { return (x - a) / b; }
+      : constant$4(b);
+}
+
+function deinterpolateClamp(deinterpolate) {
+  return function(a, b) {
+    var d = deinterpolate(a = +a, b = +b);
+    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
+  };
+}
+
+function reinterpolateClamp(reinterpolate) {
+  return function(a, b) {
+    var r = reinterpolate(a = +a, b = +b);
+    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
+  };
+}
+
+function bimap(domain, range, deinterpolate, reinterpolate) {
+  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
+  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
+  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
+  return function(x) { return r0(d0(x)); };
+}
+
+function polymap(domain, range, deinterpolate, reinterpolate) {
+  var j = Math.min(domain.length, range.length) - 1,
+      d = new Array(j),
+      r = new Array(j),
+      i = -1;
+
+  // Reverse descending domains.
+  if (domain[j] < domain[0]) {
+    domain = domain.slice().reverse();
+    range = range.slice().reverse();
+  }
+
+  while (++i < j) {
+    d[i] = deinterpolate(domain[i], domain[i + 1]);
+    r[i] = reinterpolate(range[i], range[i + 1]);
+  }
+
+  return function(x) {
+    var i = bisectRight(domain, x, 1, j) - 1;
+    return r[i](d[i](x));
+  };
+}
+
+function copy(source, target) {
+  return target
+      .domain(source.domain())
+      .range(source.range())
+      .interpolate(source.interpolate())
+      .clamp(source.clamp());
+}
+
+// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
+// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
+function continuous(deinterpolate, reinterpolate) {
+  var domain = unit,
+      range = unit,
+      interpolate$$1 = interpolateValue,
+      clamp = false,
+      piecewise,
+      output,
+      input;
+
+  function rescale() {
+    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
+    output = input = null;
+    return scale;
+  }
+
+  function scale(x) {
+    return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate$$1)))(+x);
+  }
+
+  scale.invert = function(y) {
+    return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
+  };
+
+  scale.domain = function(_) {
+    return arguments.length ? (domain = map$3.call(_, number$1), rescale()) : domain.slice();
+  };
+
+  scale.range = function(_) {
+    return arguments.length ? (range = slice$2.call(_), rescale()) : range.slice();
+  };
+
+  scale.rangeRound = function(_) {
+    return range = slice$2.call(_), interpolate$$1 = interpolateRound, rescale();
+  };
+
+  scale.clamp = function(_) {
+    return arguments.length ? (clamp = !!_, rescale()) : clamp;
+  };
+
+  scale.interpolate = function(_) {
+    return arguments.length ? (interpolate$$1 = _, rescale()) : interpolate$$1;
+  };
+
+  return rescale();
+}
+
+// Computes the decimal coefficient and exponent of the specified number x with
+// significant digits p, where x is positive and p is in [1, 21] or undefined.
+// For example, formatDecimal(1.23) returns ["123", 0].
+var formatDecimal = function(x, p) {
+  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
+  var i, coefficient = x.slice(0, i);
+
+  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
+  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
+  return [
+    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
+    +x.slice(i + 1)
+  ];
+};
+
+var exponent = function(x) {
+  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
+};
+
+var formatGroup = function(grouping, thousands) {
+  return function(value, width) {
+    var i = value.length,
+        t = [],
+        j = 0,
+        g = grouping[0],
+        length = 0;
+
+    while (i > 0 && g > 0) {
+      if (length + g + 1 > width) g = Math.max(1, width - length);
+      t.push(value.substring(i -= g, i + g));
+      if ((length += g + 1) > width) break;
+      g = grouping[j = (j + 1) % grouping.length];
+    }
+
+    return t.reverse().join(thousands);
+  };
+};
+
+var formatNumerals = function(numerals) {
+  return function(value) {
+    return value.replace(/[0-9]/g, function(i) {
+      return numerals[+i];
+    });
+  };
+};
+
+var formatDefault = function(x, p) {
+  x = x.toPrecision(p);
+
+  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
+    switch (x[i]) {
+      case ".": i0 = i1 = i; break;
+      case "0": if (i0 === 0) i0 = i; i1 = i; break;
+      case "e": break out;
+      default: if (i0 > 0) i0 = 0; break;
+    }
+  }
+
+  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
+};
+
+var prefixExponent;
+
+var formatPrefixAuto = function(x, p) {
+  var d = formatDecimal(x, p);
+  if (!d) return x + "";
+  var coefficient = d[0],
+      exponent = d[1],
+      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
+      n = coefficient.length;
+  return i === n ? coefficient
+      : i > n ? coefficient + new Array(i - n + 1).join("0")
+      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
+      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
+};
+
+var formatRounded = function(x, p) {
+  var d = formatDecimal(x, p);
+  if (!d) return x + "";
+  var coefficient = d[0],
+      exponent = d[1];
+  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
+      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
+      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
+};
+
+var formatTypes = {
+  "": formatDefault,
+  "%": function(x, p) { return (x * 100).toFixed(p); },
+  "b": function(x) { return Math.round(x).toString(2); },
+  "c": function(x) { return x + ""; },
+  "d": function(x) { return Math.round(x).toString(10); },
+  "e": function(x, p) { return x.toExponential(p); },
+  "f": function(x, p) { return x.toFixed(p); },
+  "g": function(x, p) { return x.toPrecision(p); },
+  "o": function(x) { return Math.round(x).toString(8); },
+  "p": function(x, p) { return formatRounded(x * 100, p); },
+  "r": formatRounded,
+  "s": formatPrefixAuto,
+  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
+  "x": function(x) { return Math.round(x).toString(16); }
+};
+
+// [[fill]align][sign][symbol][0][width][,][.precision][type]
+var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;
+
+function formatSpecifier(specifier) {
+  return new FormatSpecifier(specifier);
+}
+
+formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof
+
+function FormatSpecifier(specifier) {
+  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
+
+  var match,
+      fill = match[1] || " ",
+      align = match[2] || ">",
+      sign = match[3] || "-",
+      symbol = match[4] || "",
+      zero = !!match[5],
+      width = match[6] && +match[6],
+      comma = !!match[7],
+      precision = match[8] && +match[8].slice(1),
+      type = match[9] || "";
+
+  // The "n" type is an alias for ",g".
+  if (type === "n") comma = true, type = "g";
+
+  // Map invalid types to the default format.
+  else if (!formatTypes[type]) type = "";
+
+  // If zero fill is specified, padding goes after sign and before digits.
+  if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";
+
+  this.fill = fill;
+  this.align = align;
+  this.sign = sign;
+  this.symbol = symbol;
+  this.zero = zero;
+  this.width = width;
+  this.comma = comma;
+  this.precision = precision;
+  this.type = type;
+}
+
+FormatSpecifier.prototype.toString = function() {
+  return this.fill
+      + this.align
+      + this.sign
+      + this.symbol
+      + (this.zero ? "0" : "")
+      + (this.width == null ? "" : Math.max(1, this.width | 0))
+      + (this.comma ? "," : "")
+      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
+      + this.type;
+};
+
+var identity$3 = function(x) {
+  return x;
+};
+
+var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];
+
+var formatLocale = function(locale) {
+  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$3,
+      currency = locale.currency,
+      decimal = locale.decimal,
+      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity$3,
+      percent = locale.percent || "%";
+
+  function newFormat(specifier) {
+    specifier = formatSpecifier(specifier);
+
+    var fill = specifier.fill,
+        align = specifier.align,
+        sign = specifier.sign,
+        symbol = specifier.symbol,
+        zero = specifier.zero,
+        width = specifier.width,
+        comma = specifier.comma,
+        precision = specifier.precision,
+        type = specifier.type;
+
+    // Compute the prefix and suffix.
+    // For SI-prefix, the suffix is lazily computed.
+    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
+        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";
+
+    // What format function should we use?
+    // Is this an integer type?
+    // Can this type generate exponential notation?
+    var formatType = formatTypes[type],
+        maybeSuffix = !type || /[defgprs%]/.test(type);
+
+    // Set the default precision if not specified,
+    // or clamp the specified precision to the supported range.
+    // For significant precision, it must be in [1, 21].
+    // For fixed precision, it must be in [0, 20].
+    precision = precision == null ? (type ? 6 : 12)
+        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
+        : Math.max(0, Math.min(20, precision));
+
+    function format(value) {
+      var valuePrefix = prefix,
+          valueSuffix = suffix,
+          i, n, c;
+
+      if (type === "c") {
+        valueSuffix = formatType(value) + valueSuffix;
+        value = "";
+      } else {
+        value = +value;
+
+        // Perform the initial formatting.
+        var valueNegative = value < 0;
+        value = formatType(Math.abs(value), precision);
+
+        // If a negative value rounds to zero during formatting, treat as positive.
+        if (valueNegative && +value === 0) valueNegative = false;
+
+        // Compute the prefix and suffix.
+        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
+        valueSuffix = valueSuffix + (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + (valueNegative && sign === "(" ? ")" : "");
+
+        // Break the formatted value into the integer “value” part that can be
+        // grouped, and fractional or exponential “suffix” part that is not.
+        if (maybeSuffix) {
+          i = -1, n = value.length;
+          while (++i < n) {
+            if (c = value.charCodeAt(i), 48 > c || c > 57) {
+              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
+              value = value.slice(0, i);
+              break;
+            }
+          }
+        }
+      }
+
+      // If the fill character is not "0", grouping is applied before padding.
+      if (comma && !zero) value = group(value, Infinity);
+
+      // Compute the padding.
+      var length = valuePrefix.length + value.length + valueSuffix.length,
+          padding = length < width ? new Array(width - length + 1).join(fill) : "";
+
+      // If the fill character is "0", grouping is applied after padding.
+      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
+
+      // Reconstruct the final output based on the desired alignment.
+      switch (align) {
+        case "<": value = valuePrefix + value + valueSuffix + padding; break;
+        case "=": value = valuePrefix + padding + value + valueSuffix; break;
+        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
+        default: value = padding + valuePrefix + value + valueSuffix; break;
+      }
+
+      return numerals(value);
+    }
+
+    format.toString = function() {
+      return specifier + "";
+    };
+
+    return format;
+  }
+
+  function formatPrefix(specifier, value) {
+    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
+        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
+        k = Math.pow(10, -e),
+        prefix = prefixes[8 + e / 3];
+    return function(value) {
+      return f(k * value) + prefix;
+    };
+  }
+
+  return {
+    format: newFormat,
+    formatPrefix: formatPrefix
+  };
+};
+
+var locale;
+
+var formatPrefix;
+
+defaultLocale({
+  decimal: ".",
+  thousands: ",",
+  grouping: [3],
+  currency: ["$", ""]
+});
+
+function defaultLocale(definition) {
+  locale = formatLocale(definition);
+  exports.format = locale.format;
+  formatPrefix = locale.formatPrefix;
+  return locale;
+}
+
+var precisionFixed = function(step) {
+  return Math.max(0, -exponent(Math.abs(step)));
+};
+
+var precisionPrefix = function(step, value) {
+  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
+};
+
+var precisionRound = function(step, max) {
+  step = Math.abs(step), max = Math.abs(max) - step;
+  return Math.max(0, exponent(max) - exponent(step)) + 1;
+};
+
+var tickFormat = function(domain, count, specifier) {
+  var start = domain[0],
+      stop = domain[domain.length - 1],
+      step = tickStep(start, stop, count == null ? 10 : count),
+      precision;
+  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
+  switch (specifier.type) {
+    case "s": {
+      var value = Math.max(Math.abs(start), Math.abs(stop));
+      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
+      return formatPrefix(specifier, value);
+    }
+    case "":
+    case "e":
+    case "g":
+    case "p":
+    case "r": {
+      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
+      break;
+    }
+    case "f":
+    case "%": {
+      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
+      break;
+    }
+  }
+  return exports.format(specifier);
+};
+
+function linearish(scale) {
+  var domain = scale.domain;
+
+  scale.ticks = function(count) {
+    var d = domain();
+    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
+  };
+
+  scale.tickFormat = function(count, specifier) {
+    return tickFormat(domain(), count, specifier);
+  };
+
+  scale.nice = function(count) {
+    if (count == null) count = 10;
+
+    var d = domain(),
+        i0 = 0,
+        i1 = d.length - 1,
+        start = d[i0],
+        stop = d[i1],
+        step;
+
+    if (stop < start) {
+      step = start, start = stop, stop = step;
+      step = i0, i0 = i1, i1 = step;
+    }
+
+    step = tickIncrement(start, stop, count);
+
+    if (step > 0) {
+      start = Math.floor(start / step) * step;
+      stop = Math.ceil(stop / step) * step;
+      step = tickIncrement(start, stop, count);
+    } else if (step < 0) {
+      start = Math.ceil(start * step) / step;
+      stop = Math.floor(stop * step) / step;
+      step = tickIncrement(start, stop, count);
+    }
+
+    if (step > 0) {
+      d[i0] = Math.floor(start / step) * step;
+      d[i1] = Math.ceil(stop / step) * step;
+      domain(d);
+    } else if (step < 0) {
+      d[i0] = Math.ceil(start * step) / step;
+      d[i1] = Math.floor(stop * step) / step;
+      domain(d);
+    }
+
+    return scale;
+  };
+
+  return scale;
+}
+
+function linear() {
+  var scale = continuous(deinterpolateLinear, interpolateNumber);
+
+  scale.copy = function() {
+    return copy(scale, linear());
+  };
+
+  return linearish(scale);
+}
+
+var t0$1 = new Date;
+var t1$1 = new Date;
+
+function newInterval(floori, offseti, count, field) {
+
+  function interval(date) {
+    return floori(date = new Date(+date)), date;
+  }
+
+  interval.floor = interval;
+
+  interval.ceil = function(date) {
+    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
+  };
+
+  interval.round = function(date) {
+    var d0 = interval(date),
+        d1 = interval.ceil(date);
+    return date - d0 < d1 - date ? d0 : d1;
+  };
+
+  interval.offset = function(date, step) {
+    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
+  };
+
+  interval.range = function(start, stop, step) {
+    var range = [];
+    start = interval.ceil(start);
+    step = step == null ? 1 : Math.floor(step);
+    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
+    do range.push(new Date(+start)); while (offseti(start, step), floori(start), start < stop)
+    return range;
+  };
+
+  interval.filter = function(test) {
+    return newInterval(function(date) {
+      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
+    }, function(date, step) {
+      if (date >= date) {
+        if (step < 0) while (++step <= 0) {
+          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
+        } else while (--step >= 0) {
+          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
+        }
+      }
+    });
+  };
+
+  if (count) {
+    interval.count = function(start, end) {
+      t0$1.setTime(+start), t1$1.setTime(+end);
+      floori(t0$1), floori(t1$1);
+      return Math.floor(count(t0$1, t1$1));
+    };
+
+    interval.every = function(step) {
+      step = Math.floor(step);
+      return !isFinite(step) || !(step > 0) ? null
+          : !(step > 1) ? interval
+          : interval.filter(field
+              ? function(d) { return field(d) % step === 0; }
+              : function(d) { return interval.count(0, d) % step === 0; });
+    };
+  }
+
+  return interval;
+}
+
+var millisecond = newInterval(function() {
+  // noop
+}, function(date, step) {
+  date.setTime(+date + step);
+}, function(start, end) {
+  return end - start;
+});
+
+// An optimized implementation for this simple case.
+millisecond.every = function(k) {
+  k = Math.floor(k);
+  if (!isFinite(k) || !(k > 0)) return null;
+  if (!(k > 1)) return millisecond;
+  return newInterval(function(date) {
+    date.setTime(Math.floor(date / k) * k);
+  }, function(date, step) {
+    date.setTime(+date + step * k);
+  }, function(start, end) {
+    return (end - start) / k;
+  });
+};
+
+var durationSecond$1 = 1e3;
+var durationMinute$1 = 6e4;
+var durationHour$1 = 36e5;
+var durationDay$1 = 864e5;
+var durationWeek$1 = 6048e5;
+
+var second = newInterval(function(date) {
+  date.setTime(Math.floor(date / durationSecond$1) * durationSecond$1);
+}, function(date, step) {
+  date.setTime(+date + step * durationSecond$1);
+}, function(start, end) {
+  return (end - start) / durationSecond$1;
+}, function(date) {
+  return date.getUTCSeconds();
+});
+
+var minute = newInterval(function(date) {
+  date.setTime(Math.floor(date / durationMinute$1) * durationMinute$1);
+}, function(date, step) {
+  date.setTime(+date + step * durationMinute$1);
+}, function(start, end) {
+  return (end - start) / durationMinute$1;
+}, function(date) {
+  return date.getMinutes();
+});
+
+var hour = newInterval(function(date) {
+  var offset = date.getTimezoneOffset() * durationMinute$1 % durationHour$1;
+  if (offset < 0) offset += durationHour$1;
+  date.setTime(Math.floor((+date - offset) / durationHour$1) * durationHour$1 + offset);
+}, function(date, step) {
+  date.setTime(+date + step * durationHour$1);
+}, function(start, end) {
+  return (end - start) / durationHour$1;
+}, function(date) {
+  return date.getHours();
+});
+
+var day = newInterval(function(date) {
+  date.setHours(0, 0, 0, 0);
+}, function(date, step) {
+  date.setDate(date.getDate() + step);
+}, function(start, end) {
+  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationDay$1;
+}, function(date) {
+  return date.getDate() - 1;
+});
+
+function weekday(i) {
+  return newInterval(function(date) {
+    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
+    date.setHours(0, 0, 0, 0);
+  }, function(date, step) {
+    date.setDate(date.getDate() + step * 7);
+  }, function(start, end) {
+    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationWeek$1;
+  });
+}
+
+var sunday = weekday(0);
+var monday = weekday(1);
+var tuesday = weekday(2);
+var wednesday = weekday(3);
+var thursday = weekday(4);
+var friday = weekday(5);
+var saturday = weekday(6);
+
+var month = newInterval(function(date) {
+  date.setDate(1);
+  date.setHours(0, 0, 0, 0);
+}, function(date, step) {
+  date.setMonth(date.getMonth() + step);
+}, function(start, end) {
+  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
+}, function(date) {
+  return date.getMonth();
+});
+
+var year = newInterval(function(date) {
+  date.setMonth(0, 1);
+  date.setHours(0, 0, 0, 0);
+}, function(date, step) {
+  date.setFullYear(date.getFullYear() + step);
+}, function(start, end) {
+  return end.getFullYear() - start.getFullYear();
+}, function(date) {
+  return date.getFullYear();
+});
+
+// An optimized implementation for this simple case.
+year.every = function(k) {
+  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
+    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
+    date.setMonth(0, 1);
+    date.setHours(0, 0, 0, 0);
+  }, function(date, step) {
+    date.setFullYear(date.getFullYear() + step * k);
+  });
+};
+
+var utcMinute = newInterval(function(date) {
+  date.setUTCSeconds(0, 0);
+}, function(date, step) {
+  date.setTime(+date + step * durationMinute$1);
+}, function(start, end) {
+  return (end - start) / durationMinute$1;
+}, function(date) {
+  return date.getUTCMinutes();
+});
+
+var utcHour = newInterval(function(date) {
+  date.setUTCMinutes(0, 0, 0);
+}, function(date, step) {
+  date.setTime(+date + step * durationHour$1);
+}, function(start, end) {
+  return (end - start) / durationHour$1;
+}, function(date) {
+  return date.getUTCHours();
+});
+
+var utcDay = newInterval(function(date) {
+  date.setUTCHours(0, 0, 0, 0);
+}, function(date, step) {
+  date.setUTCDate(date.getUTCDate() + step);
+}, function(start, end) {
+  return (end - start) / durationDay$1;
+}, function(date) {
+  return date.getUTCDate() - 1;
+});
+
+function utcWeekday(i) {
+  return newInterval(function(date) {
+    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
+    date.setUTCHours(0, 0, 0, 0);
+  }, function(date, step) {
+    date.setUTCDate(date.getUTCDate() + step * 7);
+  }, function(start, end) {
+    return (end - start) / durationWeek$1;
+  });
+}
+
+var utcSunday = utcWeekday(0);
+var utcMonday = utcWeekday(1);
+var utcTuesday = utcWeekday(2);
+var utcWednesday = utcWeekday(3);
+var utcThursday = utcWeekday(4);
+var utcFriday = utcWeekday(5);
+var utcSaturday = utcWeekday(6);
+
+var utcMonth = newInterval(function(date) {
+  date.setUTCDate(1);
+  date.setUTCHours(0, 0, 0, 0);
+}, function(date, step) {
+  date.setUTCMonth(date.getUTCMonth() + step);
+}, function(start, end) {
+  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
+}, function(date) {
+  return date.getUTCMonth();
+});
+
+var utcYear = newInterval(function(date) {
+  date.setUTCMonth(0, 1);
+  date.setUTCHours(0, 0, 0, 0);
+}, function(date, step) {
+  date.setUTCFullYear(date.getUTCFullYear() + step);
+}, function(start, end) {
+  return end.getUTCFullYear() - start.getUTCFullYear();
+}, function(date) {
+  return date.getUTCFullYear();
+});
+
+// An optimized implementation for this simple case.
+utcYear.every = function(k) {
+  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
+    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
+    date.setUTCMonth(0, 1);
+    date.setUTCHours(0, 0, 0, 0);
+  }, function(date, step) {
+    date.setUTCFullYear(date.getUTCFullYear() + step * k);
+  });
+};
+
+function localDate(d) {
+  if (0 <= d.y && d.y < 100) {
+    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
+    date.setFullYear(d.y);
+    return date;
+  }
+  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
+}
+
+function utcDate(d) {
+  if (0 <= d.y && d.y < 100) {
+    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
+    date.setUTCFullYear(d.y);
+    return date;
+  }
+  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
+}
+
+function newYear(y) {
+  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
+}
+
+function formatLocale$1(locale) {
+  var locale_dateTime = locale.dateTime,
+      locale_date = locale.date,
+      locale_time = locale.time,
+      locale_periods = locale.periods,
+      locale_weekdays = locale.days,
+      locale_shortWeekdays = locale.shortDays,
+      locale_months = locale.months,
+      locale_shortMonths = locale.shortMonths;
+
+  var periodRe = formatRe(locale_periods),
+      periodLookup = formatLookup(locale_periods),
+      weekdayRe = formatRe(locale_weekdays),
+      weekdayLookup = formatLookup(locale_weekdays),
+      shortWeekdayRe = formatRe(locale_shortWeekdays),
+      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
+      monthRe = formatRe(locale_months),
+      monthLookup = formatLookup(locale_months),
+      shortMonthRe = formatRe(locale_shortMonths),
+      shortMonthLookup = formatLookup(locale_shortMonths);
+
+  var formats = {
+    "a": formatShortWeekday,
+    "A": formatWeekday,
+    "b": formatShortMonth,
+    "B": formatMonth,
+    "c": null,
+    "d": formatDayOfMonth,
+    "e": formatDayOfMonth,
+    "f": formatMicroseconds,
+    "H": formatHour24,
+    "I": formatHour12,
+    "j": formatDayOfYear,
+    "L": formatMilliseconds,
+    "m": formatMonthNumber,
+    "M": formatMinutes,
+    "p": formatPeriod,
+    "Q": formatUnixTimestamp,
+    "s": formatUnixTimestampSeconds,
+    "S": formatSeconds,
+    "u": formatWeekdayNumberMonday,
+    "U": formatWeekNumberSunday,
+    "V": formatWeekNumberISO,
+    "w": formatWeekdayNumberSunday,
+    "W": formatWeekNumberMonday,
+    "x": null,
+    "X": null,
+    "y": formatYear,
+    "Y": formatFullYear,
+    "Z": formatZone,
+    "%": formatLiteralPercent
+  };
+
+  var utcFormats = {
+    "a": formatUTCShortWeekday,
+    "A": formatUTCWeekday,
+    "b": formatUTCShortMonth,
+    "B": formatUTCMonth,
+    "c": null,
+    "d": formatUTCDayOfMonth,
+    "e": formatUTCDayOfMonth,
+    "f": formatUTCMicroseconds,
+    "H": formatUTCHour24,
+    "I": formatUTCHour12,
+    "j": formatUTCDayOfYear,
+    "L": formatUTCMilliseconds,
+    "m": formatUTCMonthNumber,
+    "M": formatUTCMinutes,
+    "p": formatUTCPeriod,
+    "Q": formatUnixTimestamp,
+    "s": formatUnixTimestampSeconds,
+    "S": formatUTCSeconds,
+    "u": formatUTCWeekdayNumberMonday,
+    "U": formatUTCWeekNumberSunday,
+    "V": formatUTCWeekNumberISO,
+    "w": formatUTCWeekdayNumberSunday,
+    "W": formatUTCWeekNumberMonday,
+    "x": null,
+    "X": null,
+    "y": formatUTCYear,
+    "Y": formatUTCFullYear,
+    "Z": formatUTCZone,
+    "%": formatLiteralPercent
+  };
+
+  var parses = {
+    "a": parseShortWeekday,
+    "A": parseWeekday,
+    "b": parseShortMonth,
+    "B": parseMonth,
+    "c": parseLocaleDateTime,
+    "d": parseDayOfMonth,
+    "e": parseDayOfMonth,
+    "f": parseMicroseconds,
+    "H": parseHour24,
+    "I": parseHour24,
+    "j": parseDayOfYear,
+    "L": parseMilliseconds,
+    "m": parseMonthNumber,
+    "M": parseMinutes,
+    "p": parsePeriod,
+    "Q": parseUnixTimestamp,
+    "s": parseUnixTimestampSeconds,
+    "S": parseSeconds,
+    "u": parseWeekdayNumberMonday,
+    "U": parseWeekNumberSunday,
+    "V": parseWeekNumberISO,
+    "w": parseWeekdayNumberSunday,
+    "W": parseWeekNumberMonday,
+    "x": parseLocaleDate,
+    "X": parseLocaleTime,
+    "y": parseYear,
+    "Y": parseFullYear,
+    "Z": parseZone,
+    "%": parseLiteralPercent
+  };
+
+  // These recursive directive definitions must be deferred.
+  formats.x = newFormat(locale_date, formats);
+  formats.X = newFormat(locale_time, formats);
+  formats.c = newFormat(locale_dateTime, formats);
+  utcFormats.x = newFormat(locale_date, utcFormats);
+  utcFormats.X = newFormat(locale_time, utcFormats);
+  utcFormats.c = newFormat(locale_dateTime, utcFormats);
+
+  function newFormat(specifier, formats) {
+    return function(date) {
+      var string = [],
+          i = -1,
+          j = 0,
+          n = specifier.length,
+          c,
+          pad,
+          format;
+
+      if (!(date instanceof Date)) date = new Date(+date);
+
+      while (++i < n) {
+        if (specifier.charCodeAt(i) === 37) {
+          string.push(specifier.slice(j, i));
+          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
+          else pad = c === "e" ? " " : "0";
+          if (format = formats[c]) c = format(date, pad);
+          string.push(c);
+          j = i + 1;
+        }
+      }
+
+      string.push(specifier.slice(j, i));
+      return string.join("");
+    };
+  }
+
+  function newParse(specifier, newDate) {
+    return function(string) {
+      var d = newYear(1900),
+          i = parseSpecifier(d, specifier, string += "", 0),
+          week, day$$1;
+      if (i != string.length) return null;
+
+      // If a UNIX timestamp is specified, return it.
+      if ("Q" in d) return new Date(d.Q);
+
+      // The am-pm flag is 0 for AM, and 1 for PM.
+      if ("p" in d) d.H = d.H % 12 + d.p * 12;
+
+      // Convert day-of-week and week-of-year to day-of-year.
+      if ("V" in d) {
+        if (d.V < 1 || d.V > 53) return null;
+        if (!("w" in d)) d.w = 1;
+        if ("Z" in d) {
+          week = utcDate(newYear(d.y)), day$$1 = week.getUTCDay();
+          week = day$$1 > 4 || day$$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
+          week = utcDay.offset(week, (d.V - 1) * 7);
+          d.y = week.getUTCFullYear();
+          d.m = week.getUTCMonth();
+          d.d = week.getUTCDate() + (d.w + 6) % 7;
+        } else {
+          week = newDate(newYear(d.y)), day$$1 = week.getDay();
+          week = day$$1 > 4 || day$$1 === 0 ? monday.ceil(week) : monday(week);
+          week = day.offset(week, (d.V - 1) * 7);
+          d.y = week.getFullYear();
+          d.m = week.getMonth();
+          d.d = week.getDate() + (d.w + 6) % 7;
+        }
+      } else if ("W" in d || "U" in d) {
+        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
+        day$$1 = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
+        d.m = 0;
+        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$$1 + 5) % 7 : d.w + d.U * 7 - (day$$1 + 6) % 7;
+      }
+
+      // If a time zone is specified, all fields are interpreted as UTC and then
+      // offset according to the specified time zone.
+      if ("Z" in d) {
+        d.H += d.Z / 100 | 0;
+        d.M += d.Z % 100;
+        return utcDate(d);
+      }
+
+      // Otherwise, all fields are in local time.
+      return newDate(d);
+    };
+  }
+
+  function parseSpecifier(d, specifier, string, j) {
+    var i = 0,
+        n = specifier.length,
+        m = string.length,
+        c,
+        parse;
+
+    while (i < n) {
+      if (j >= m) return -1;
+      c = specifier.charCodeAt(i++);
+      if (c === 37) {
+        c = specifier.charAt(i++);
+        parse = parses[c in pads ? specifier.charAt(i++) : c];
+        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
+      } else if (c != string.charCodeAt(j++)) {
+        return -1;
+      }
+    }
+
+    return j;
+  }
+
+  function parsePeriod(d, string, i) {
+    var n = periodRe.exec(string.slice(i));
+    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
+  }
+
+  function parseShortWeekday(d, string, i) {
+    var n = shortWeekdayRe.exec(string.slice(i));
+    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
+  }
+
+  function parseWeekday(d, string, i) {
+    var n = weekdayRe.exec(string.slice(i));
+    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
+  }
+
+  function parseShortMonth(d, string, i) {
+    var n = shortMonthRe.exec(string.slice(i));
+    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
+  }
+
+  function parseMonth(d, string, i) {
+    var n = monthRe.exec(string.slice(i));
+    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
+  }
+
+  function parseLocaleDateTime(d, string, i) {
+    return parseSpecifier(d, locale_dateTime, string, i);
+  }
+
+  function parseLocaleDate(d, string, i) {
+    return parseSpecifier(d, locale_date, string, i);
+  }
+
+  function parseLocaleTime(d, string, i) {
+    return parseSpecifier(d, locale_time, string, i);
+  }
+
+  function formatShortWeekday(d) {
+    return locale_shortWeekdays[d.getDay()];
+  }
+
+  function formatWeekday(d) {
+    return locale_weekdays[d.getDay()];
+  }
+
+  function formatShortMonth(d) {
+    return locale_shortMonths[d.getMonth()];
+  }
+
+  function formatMonth(d) {
+    return locale_months[d.getMonth()];
+  }
+
+  function formatPeriod(d) {
+    return locale_periods[+(d.getHours() >= 12)];
+  }
+
+  function formatUTCShortWeekday(d) {
+    return locale_shortWeekdays[d.getUTCDay()];
+  }
+
+  function formatUTCWeekday(d) {
+    return locale_weekdays[d.getUTCDay()];
+  }
+
+  function formatUTCShortMonth(d) {
+    return locale_shortMonths[d.getUTCMonth()];
+  }
+
+  function formatUTCMonth(d) {
+    return locale_months[d.getUTCMonth()];
+  }
+
+  function formatUTCPeriod(d) {
+    return locale_periods[+(d.getUTCHours() >= 12)];
+  }
+
+  return {
+    format: function(specifier) {
+      var f = newFormat(specifier += "", formats);
+      f.toString = function() { return specifier; };
+      return f;
+    },
+    parse: function(specifier) {
+      var p = newParse(specifier += "", localDate);
+      p.toString = function() { return specifier; };
+      return p;
+    },
+    utcFormat: function(specifier) {
+      var f = newFormat(specifier += "", utcFormats);
+      f.toString = function() { return specifier; };
+      return f;
+    },
+    utcParse: function(specifier) {
+      var p = newParse(specifier, utcDate);
+      p.toString = function() { return specifier; };
+      return p;
+    }
+  };
+}
+
+var pads = {"-": "", "_": " ", "0": "0"};
+var numberRe = /^\s*\d+/;
+var percentRe = /^%/;
+var requoteRe = /[\\^$*+?|[\]().{}]/g;
+
+function pad(value, fill, width) {
+  var sign = value < 0 ? "-" : "",
+      string = (sign ? -value : value) + "",
+      length = string.length;
+  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
+}
+
+function requote(s) {
+  return s.replace(requoteRe, "\\$&");
+}
+
+function formatRe(names) {
+  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
+}
+
+function formatLookup(names) {
+  var map = {}, i = -1, n = names.length;
+  while (++i < n) map[names[i].toLowerCase()] = i;
+  return map;
+}
+
+function parseWeekdayNumberSunday(d, string, i) {
+  var n = numberRe.exec(string.slice(i, i + 1));
+  return n ? (d.w = +n[0], i + n[0].length) : -1;
+}
+
+function parseWeekdayNumberMonday(d, string, i) {
+  var n = numberRe.exec(string.slice(i, i + 1));
+  return n ? (d.u = +n[0], i + n[0].length) : -1;
+}
+
+function parseWeekNumberSunday(d, string, i) {
+  var n = numberRe.exec(string.slice(i, i + 2));
+  return n ? (d.U = +n[0], i + n[0].length) : -1;
+}
+
+function parseWeekNumberISO(d, string, i) {
+  var n = numberRe.exec(string.slice(i, i + 2));
+  return n ? (d.V = +n[0], i + n[0].length) : -1;
+}
+
+function parseWeekNumberMonday(d, string, i) {
+  var n = numberRe.exec(string.slice(i, i + 2));
+  return n ? (d.W = +n[0], i + n[0].length) : -1;
+}
+
+function parseFullYear(d, string, i) {
+  var n = numberRe.exec(string.slice(i, i + 4));
+  return n ? (d.y = +n[0], i + n[0].length) : -1;
+}
+
+function parseYear(d, string, i) {
+  var n = numberRe.exec(string.slice(i, i + 2));
+  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
+}
+
+function parseZone(d, string, i) {
+  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
+  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
+}
+
+function parseMonthNumber(d, string, i) {
+  var n = numberRe.exec(string.slice(i, i + 2));
+  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
+}
+
+function parseDayOfMonth(d, string, i) {
+  var n = numberRe.exec(string.slice(i, i + 2));
+  return n ? (d.d = +n[0], i + n[0].length) : -1;
+}
+
+function parseDayOfYear(d, string, i) {
+  var n = numberRe.exec(string.slice(i, i + 3));
+  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
+}
+
+function parseHour24(d, string, i) {
+  var n = numberRe.exec(string.slice(i, i + 2));
+  return n ? (d.H = +n[0], i + n[0].length) : -1;
+}
+
+function parseMinutes(d, string, i) {
+  var n = numberRe.exec(string.slice(i, i + 2));
+  return n ? (d.M = +n[0], i + n[0].length) : -1;
+}
+
+function parseSeconds(d, string, i) {
+  var n = numberRe.exec(string.slice(i, i + 2));
+  return n ? (d.S = +n[0], i + n[0].length) : -1;
+}
+
+function parseMilliseconds(d, string, i) {
+  var n = numberRe.exec(string.slice(i, i + 3));
+  return n ? (d.L = +n[0], i + n[0].length) : -1;
+}
+
+function parseMicroseconds(d, string, i) {
+  var n = numberRe.exec(string.slice(i, i + 6));
+  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
+}
+
+function parseLiteralPercent(d, string, i) {
+  var n = percentRe.exec(string.slice(i, i + 1));
+  return n ? i + n[0].length : -1;
+}
+
+function parseUnixTimestamp(d, string, i) {
+  var n = numberRe.exec(string.slice(i));
+  return n ? (d.Q = +n[0], i + n[0].length) : -1;
+}
+
+function parseUnixTimestampSeconds(d, string, i) {
+  var n = numberRe.exec(string.slice(i));
+  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
+}
+
+function formatDayOfMonth(d, p) {
+  return pad(d.getDate(), p, 2);
+}
+
+function formatHour24(d, p) {
+  return pad(d.getHours(), p, 2);
+}
+
+function formatHour12(d, p) {
+  return pad(d.getHours() % 12 || 12, p, 2);
+}
+
+function formatDayOfYear(d, p) {
+  return pad(1 + day.count(year(d), d), p, 3);
+}
+
+function formatMilliseconds(d, p) {
+  return pad(d.getMilliseconds(), p, 3);
+}
+
+function formatMicroseconds(d, p) {
+  return formatMilliseconds(d, p) + "000";
+}
+
+function formatMonthNumber(d, p) {
+  return pad(d.getMonth() + 1, p, 2);
+}
+
+function formatMinutes(d, p) {
+  return pad(d.getMinutes(), p, 2);
+}
+
+function formatSeconds(d, p) {
+  return pad(d.getSeconds(), p, 2);
+}
+
+function formatWeekdayNumberMonday(d) {
+  var day$$1 = d.getDay();
+  return day$$1 === 0 ? 7 : day$$1;
+}
+
+function formatWeekNumberSunday(d, p) {
+  return pad(sunday.count(year(d), d), p, 2);
+}
+
+function formatWeekNumberISO(d, p) {
+  var day$$1 = d.getDay();
+  d = (day$$1 >= 4 || day$$1 === 0) ? thursday(d) : thursday.ceil(d);
+  return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
+}
+
+function formatWeekdayNumberSunday(d) {
+  return d.getDay();
+}
+
+function formatWeekNumberMonday(d, p) {
+  return pad(monday.count(year(d), d), p, 2);
+}
+
+function formatYear(d, p) {
+  return pad(d.getFullYear() % 100, p, 2);
+}
+
+function formatFullYear(d, p) {
+  return pad(d.getFullYear() % 10000, p, 4);
+}
+
+function formatZone(d) {
+  var z = d.getTimezoneOffset();
+  return (z > 0 ? "-" : (z *= -1, "+"))
+      + pad(z / 60 | 0, "0", 2)
+      + pad(z % 60, "0", 2);
+}
+
+function formatUTCDayOfMonth(d, p) {
+  return pad(d.getUTCDate(), p, 2);
+}
+
+function formatUTCHour24(d, p) {
+  return pad(d.getUTCHours(), p, 2);
+}
+
+function formatUTCHour12(d, p) {
+  return pad(d.getUTCHours() % 12 || 12, p, 2);
+}
+
+function formatUTCDayOfYear(d, p) {
+  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
+}
+
+function formatUTCMilliseconds(d, p) {
+  return pad(d.getUTCMilliseconds(), p, 3);
+}
+
+function formatUTCMicroseconds(d, p) {
+  return formatUTCMilliseconds(d, p) + "000";
+}
+
+function formatUTCMonthNumber(d, p) {
+  return pad(d.getUTCMonth() + 1, p, 2);
+}
+
+function formatUTCMinutes(d, p) {
+  return pad(d.getUTCMinutes(), p, 2);
+}
+
+function formatUTCSeconds(d, p) {
+  return pad(d.getUTCSeconds(), p, 2);
+}
+
+function formatUTCWeekdayNumberMonday(d) {
+  var dow = d.getUTCDay();
+  return dow === 0 ? 7 : dow;
+}
+
+function formatUTCWeekNumberSunday(d, p) {
+  return pad(utcSunday.count(utcYear(d), d), p, 2);
+}
+
+function formatUTCWeekNumberISO(d, p) {
+  var day$$1 = d.getUTCDay();
+  d = (day$$1 >= 4 || day$$1 === 0) ? utcThursday(d) : utcThursday.ceil(d);
+  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
+}
+
+function formatUTCWeekdayNumberSunday(d) {
+  return d.getUTCDay();
+}
+
+function formatUTCWeekNumberMonday(d, p) {
+  return pad(utcMonday.count(utcYear(d), d), p, 2);
+}
+
+function formatUTCYear(d, p) {
+  return pad(d.getUTCFullYear() % 100, p, 2);
+}
+
+function formatUTCFullYear(d, p) {
+  return pad(d.getUTCFullYear() % 10000, p, 4);
+}
+
+function formatUTCZone() {
+  return "+0000";
+}
+
+function formatLiteralPercent() {
+  return "%";
+}
+
+function formatUnixTimestamp(d) {
+  return +d;
+}
+
+function formatUnixTimestampSeconds(d) {
+  return Math.floor(+d / 1000);
+}
+
+var locale$1;
+var timeFormat;
+var timeParse;
+var utcFormat;
+var utcParse;
+
+defaultLocale$1({
+  dateTime: "%x, %X",
+  date: "%-m/%-d/%Y",
+  time: "%-I:%M:%S %p",
+  periods: ["AM", "PM"],
+  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
+  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
+  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
+  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
+});
+
+function defaultLocale$1(definition) {
+  locale$1 = formatLocale$1(definition);
+  timeFormat = locale$1.format;
+  timeParse = locale$1.parse;
+  utcFormat = locale$1.utcFormat;
+  utcParse = locale$1.utcParse;
+  return locale$1;
+}
+
+var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
+
+function formatIsoNative(date) {
+  return date.toISOString();
+}
+
+var formatIso = Date.prototype.toISOString
+    ? formatIsoNative
+    : utcFormat(isoSpecifier);
+
+function parseIsoNative(string) {
+  var date = new Date(string);
+  return isNaN(date) ? null : date;
+}
+
+var parseIso = +new Date("2000-01-01T00:00:00.000Z")
+    ? parseIsoNative
+    : utcParse(isoSpecifier);
+
+var colors = function(s) {
+  return s.match(/.{6}/g).map(function(x) {
+    return "#" + x;
+  });
+};
+
+colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");
+
+colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");
+
+colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");
+
+colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");
+
+cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));
+
+var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));
+
+var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));
+
+var rainbow = cubehelix();
+
+function ramp(range) {
+  var n = range.length;
+  return function(t) {
+    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
+  };
+}
+
+ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
+
+var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
+
+var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
+
+var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
+
+function cubicInOut(t) {
+  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
+}
+
+var pi = Math.PI;
+
+var tau = 2 * Math.PI;
+
+var noop = {value: function() {}};
+
+function dispatch() {
+  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
+    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
+    _[t] = [];
+  }
+  return new Dispatch(_);
+}
+
+function Dispatch(_) {
+  this._ = _;
+}
+
+function parseTypenames$1(typenames, types) {
+  return typenames.trim().split(/^|\s+/).map(function(t) {
+    var name = "", i = t.indexOf(".");
+    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
+    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
+    return {type: t, name: name};
+  });
+}
+
+Dispatch.prototype = dispatch.prototype = {
+  constructor: Dispatch,
+  on: function(typename, callback) {
+    var _ = this._,
+        T = parseTypenames$1(typename + "", _),
+        t,
+        i = -1,
+        n = T.length;
+
+    // If no callback was specified, return the callback of the given type and name.
+    if (arguments.length < 2) {
+      while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
+      return;
+    }
+
+    // If a type was specified, set the callback for the given type and name.
+    // Otherwise, if a null callback was specified, remove callbacks of the given name.
+    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
+    while (++i < n) {
+      if (t = (typename = T[i]).type) _[t] = set$3(_[t], typename.name, callback);
+      else if (callback == null) for (t in _) _[t] = set$3(_[t], typename.name, null);
+    }
+
+    return this;
+  },
+  copy: function() {
+    var copy = {}, _ = this._;
+    for (var t in _) copy[t] = _[t].slice();
+    return new Dispatch(copy);
+  },
+  call: function(type, that) {
+    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
+    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
+    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
+  },
+  apply: function(type, that, args) {
+    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
+    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
+  }
+};
+
+function get$1(type, name) {
+  for (var i = 0, n = type.length, c; i < n; ++i) {
+    if ((c = type[i]).name === name) {
+      return c.value;
+    }
+  }
+}
+
+function set$3(type, name, callback) {
+  for (var i = 0, n = type.length; i < n; ++i) {
+    if (type[i].name === name) {
+      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
+      break;
+    }
+  }
+  if (callback != null) type.push({name: name, value: callback});
+  return type;
+}
+
+var frame = 0;
+var timeout = 0;
+var interval = 0;
+var pokeDelay = 1000;
+var taskHead;
+var taskTail;
+var clockLast = 0;
+var clockNow = 0;
+var clockSkew = 0;
+var clock = typeof performance === "object" && performance.now ? performance : Date;
+var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };
+
+function now() {
+  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
+}
+
+function clearNow() {
+  clockNow = 0;
+}
+
+function Timer() {
+  this._call =
+  this._time =
+  this._next = null;
+}
+
+Timer.prototype = timer.prototype = {
+  constructor: Timer,
+  restart: function(callback, delay, time) {
+    if (typeof callback !== "function") throw new TypeError("callback is not a function");
+    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
+    if (!this._next && taskTail !== this) {
+      if (taskTail) taskTail._next = this;
+      else taskHead = this;
+      taskTail = this;
+    }
+    this._call = callback;
+    this._time = time;
+    sleep();
+  },
+  stop: function() {
+    if (this._call) {
+      this._call = null;
+      this._time = Infinity;
+      sleep();
+    }
+  }
+};
+
+function timer(callback, delay, time) {
+  var t = new Timer;
+  t.restart(callback, delay, time);
+  return t;
+}
+
+function timerFlush() {
+  now(); // Get the current time, if not already set.
+  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
+  var t = taskHead, e;
+  while (t) {
+    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
+    t = t._next;
+  }
+  --frame;
+}
+
+function wake() {
+  clockNow = (clockLast = clock.now()) + clockSkew;
+  frame = timeout = 0;
+  try {
+    timerFlush();
+  } finally {
+    frame = 0;
+    nap();
+    clockNow = 0;
+  }
+}
+
+function poke() {
+  var now = clock.now(), delay = now - clockLast;
+  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
+}
+
+function nap() {
+  var t0, t1 = taskHead, t2, time = Infinity;
+  while (t1) {
+    if (t1._call) {
+      if (time > t1._time) time = t1._time;
+      t0 = t1, t1 = t1._next;
+    } else {
+      t2 = t1._next, t1._next = null;
+      t1 = t0 ? t0._next = t2 : taskHead = t2;
+    }
+  }
+  taskTail = t0;
+  sleep(time);
+}
+
+function sleep(time) {
+  if (frame) return; // Soonest alarm already set, or will be.
+  if (timeout) timeout = clearTimeout(timeout);
+  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
+  if (delay > 24) {
+    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
+    if (interval) interval = clearInterval(interval);
+  } else {
+    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
+    frame = 1, setFrame(wake);
+  }
+}
+
+var timeout$1 = function(callback, delay, time) {
+  var t = new Timer;
+  delay = delay == null ? 0 : +delay;
+  t.restart(function(elapsed) {
+    t.stop();
+    callback(elapsed + delay);
+  }, delay, time);
+  return t;
+};
+
+var emptyOn = dispatch("start", "end", "interrupt");
+var emptyTween = [];
+
+var CREATED = 0;
+var SCHEDULED = 1;
+var STARTING = 2;
+var STARTED = 3;
+var RUNNING = 4;
+var ENDING = 5;
+var ENDED = 6;
+
+var schedule = function(node, name, id, index, group, timing) {
+  var schedules = node.__transition;
+  if (!schedules) node.__transition = {};
+  else if (id in schedules) return;
+  create(node, id, {
+    name: name,
+    index: index, // For context during callback.
+    group: group, // For context during callback.
+    on: emptyOn,
+    tween: emptyTween,
+    time: timing.time,
+    delay: timing.delay,
+    duration: timing.duration,
+    ease: timing.ease,
+    timer: null,
+    state: CREATED
+  });
+};
+
+function init(node, id) {
+  var schedule = node.__transition;
+  if (!schedule || !(schedule = schedule[id]) || schedule.state > CREATED) throw new Error("too late");
+  return schedule;
+}
+
+function set$2(node, id) {
+  var schedule = node.__transition;
+  if (!schedule || !(schedule = schedule[id]) || schedule.state > STARTING) throw new Error("too late");
+  return schedule;
+}
+
+function get(node, id) {
+  var schedule = node.__transition;
+  if (!schedule || !(schedule = schedule[id])) throw new Error("too late");
+  return schedule;
+}
+
+function create(node, id, self) {
+  var schedules = node.__transition,
+      tween;
+
+  // Initialize the self timer when the transition is created.
+  // Note the actual delay is not known until the first callback!
+  schedules[id] = self;
+  self.timer = timer(schedule, 0, self.time);
+
+  function schedule(elapsed) {
+    self.state = SCHEDULED;
+    self.timer.restart(start, self.delay, self.time);
+
+    // If the elapsed delay is less than our first sleep, start immediately.
+    if (self.delay <= elapsed) start(elapsed - self.delay);
+  }
+
+  function start(elapsed) {
+    var i, j, n, o;
+
+    // If the state is not SCHEDULED, then we previously errored on start.
+    if (self.state !== SCHEDULED) return stop();
+
+    for (i in schedules) {
+      o = schedules[i];
+      if (o.name !== self.name) continue;
+
+      // While this element already has a starting transition during this frame,
+      // defer starting an interrupting transition until that transition has a
+      // chance to tick (and possibly end); see d3/d3-transition#54!
+      if (o.state === STARTED) return timeout$1(start);
+
+      // Interrupt the active transition, if any.
+      // Dispatch the interrupt event.
+      if (o.state === RUNNING) {
+        o.state = ENDED;
+        o.timer.stop();
+        o.on.call("interrupt", node, node.__data__, o.index, o.group);
+        delete schedules[i];
+      }
+
+      // Cancel any pre-empted transitions. No interrupt event is dispatched
+      // because the cancelled transitions never started. Note that this also
+      // removes this transition from the pending list!
+      else if (+i < id) {
+        o.state = ENDED;
+        o.timer.stop();
+        delete schedules[i];
+      }
+    }
+
+    // Defer the first tick to end of the current frame; see d3/d3#1576.
+    // Note the transition may be canceled after start and before the first tick!
+    // Note this must be scheduled before the start event; see d3/d3-transition#16!
+    // Assuming this is successful, subsequent callbacks go straight to tick.
+    timeout$1(function() {
+      if (self.state === STARTED) {
+        self.state = RUNNING;
+        self.timer.restart(tick, self.delay, self.time);
+        tick(elapsed);
+      }
+    });
+
+    // Dispatch the start event.
+    // Note this must be done before the tween are initialized.
+    self.state = STARTING;
+    self.on.call("start", node, node.__data__, self.index, self.group);
+    if (self.state !== STARTING) return; // interrupted
+    self.state = STARTED;
+
+    // Initialize the tween, deleting null tween.
+    tween = new Array(n = self.tween.length);
+    for (i = 0, j = -1; i < n; ++i) {
+      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
+        tween[++j] = o;
+      }
+    }
+    tween.length = j + 1;
+  }
+
+  function tick(elapsed) {
+    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
+        i = -1,
+        n = tween.length;
+
+    while (++i < n) {
+      tween[i].call(null, t);
+    }
+
+    // Dispatch the end event.
+    if (self.state === ENDING) {
+      self.on.call("end", node, node.__data__, self.index, self.group);
+      stop();
+    }
+  }
+
+  function stop() {
+    self.state = ENDED;
+    self.timer.stop();
+    delete schedules[id];
+    for (var i in schedules) return; // eslint-disable-line no-unused-vars
+    delete node.__transition;
+  }
+}
+
+var interrupt = function(node, name) {
+  var schedules = node.__transition,
+      schedule$$1,
+      active,
+      empty = true,
+      i;
+
+  if (!schedules) return;
+
+  name = name == null ? null : name + "";
+
+  for (i in schedules) {
+    if ((schedule$$1 = schedules[i]).name !== name) { empty = false; continue; }
+    active = schedule$$1.state > STARTING && schedule$$1.state < ENDING;
+    schedule$$1.state = ENDED;
+    schedule$$1.timer.stop();
+    if (active) schedule$$1.on.call("interrupt", node, node.__data__, schedule$$1.index, schedule$$1.group);
+    delete schedules[i];
+  }
+
+  if (empty) delete node.__transition;
+};
+
+var selection_interrupt = function(name) {
+  return this.each(function() {
+    interrupt(this, name);
+  });
+};
+
+function tweenRemove(id, name) {
+  var tween0, tween1;
+  return function() {
+    var schedule$$1 = set$2(this, id),
+        tween = schedule$$1.tween;
+
+    // If this node shared tween with the previous node,
+    // just assign the updated shared tween and we’re done!
+    // Otherwise, copy-on-write.
+    if (tween !== tween0) {
+      tween1 = tween0 = tween;
+      for (var i = 0, n = tween1.length; i < n; ++i) {
+        if (tween1[i].name === name) {
+          tween1 = tween1.slice();
+          tween1.splice(i, 1);
+          break;
+        }
+      }
+    }
+
+    schedule$$1.tween = tween1;
+  };
+}
+
+function tweenFunction(id, name, value) {
+  var tween0, tween1;
+  if (typeof value !== "function") throw new Error;
+  return function() {
+    var schedule$$1 = set$2(this, id),
+        tween = schedule$$1.tween;
+
+    // If this node shared tween with the previous node,
+    // just assign the updated shared tween and we’re done!
+    // Otherwise, copy-on-write.
+    if (tween !== tween0) {
+      tween1 = (tween0 = tween).slice();
+      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
+        if (tween1[i].name === name) {
+          tween1[i] = t;
+          break;
+        }
+      }
+      if (i === n) tween1.push(t);
+    }
+
+    schedule$$1.tween = tween1;
+  };
+}
+
+var transition_tween = function(name, value) {
+  var id = this._id;
+
+  name += "";
+
+  if (arguments.length < 2) {
+    var tween = get(this.node(), id).tween;
+    for (var i = 0, n = tween.length, t; i < n; ++i) {
+      if ((t = tween[i]).name === name) {
+        return t.value;
+      }
+    }
+    return null;
+  }
+
+  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
+};
+
+function tweenValue(transition, name, value) {
+  var id = transition._id;
+
+  transition.each(function() {
+    var schedule$$1 = set$2(this, id);
+    (schedule$$1.value || (schedule$$1.value = {}))[name] = value.apply(this, arguments);
+  });
+
+  return function(node) {
+    return get(node, id).value[name];
+  };
+}
+
+var interpolate = function(a, b) {
+  var c;
+  return (typeof b === "number" ? interpolateNumber
+      : b instanceof color ? interpolateRgb
+      : (c = color(b)) ? (b = c, interpolateRgb)
+      : interpolateString)(a, b);
+};
+
+function attrRemove$1(name) {
+  return function() {
+    this.removeAttribute(name);
+  };
+}
+
+function attrRemoveNS$1(fullname) {
+  return function() {
+    this.removeAttributeNS(fullname.space, fullname.local);
+  };
+}
+
+function attrConstant$1(name, interpolate$$1, value1) {
+  var value00,
+      interpolate0;
+  return function() {
+    var value0 = this.getAttribute(name);
+    return value0 === value1 ? null
+        : value0 === value00 ? interpolate0
+        : interpolate0 = interpolate$$1(value00 = value0, value1);
+  };
+}
+
+function attrConstantNS$1(fullname, interpolate$$1, value1) {
+  var value00,
+      interpolate0;
+  return function() {
+    var value0 = this.getAttributeNS(fullname.space, fullname.local);
+    return value0 === value1 ? null
+        : value0 === value00 ? interpolate0
+        : interpolate0 = interpolate$$1(value00 = value0, value1);
+  };
+}
+
+function attrFunction$1(name, interpolate$$1, value) {
+  var value00,
+      value10,
+      interpolate0;
+  return function() {
+    var value0, value1 = value(this);
+    if (value1 == null) return void this.removeAttribute(name);
+    value0 = this.getAttribute(name);
+    return value0 === value1 ? null
+        : value0 === value00 && value1 === value10 ? interpolate0
+        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
+  };
+}
+
+function attrFunctionNS$1(fullname, interpolate$$1, value) {
+  var value00,
+      value10,
+      interpolate0;
+  return function() {
+    var value0, value1 = value(this);
+    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
+    value0 = this.getAttributeNS(fullname.space, fullname.local);
+    return value0 === value1 ? null
+        : value0 === value00 && value1 === value10 ? interpolate0
+        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
+  };
+}
+
+var transition_attr = function(name, value) {
+  var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
+  return this.attrTween(name, typeof value === "function"
+      ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value))
+      : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)
+      : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value + ""));
+};
+
+function attrTweenNS(fullname, value) {
+  function tween() {
+    var node = this, i = value.apply(node, arguments);
+    return i && function(t) {
+      node.setAttributeNS(fullname.space, fullname.local, i(t));
+    };
+  }
+  tween._value = value;
+  return tween;
+}
+
+function attrTween(name, value) {
+  function tween() {
+    var node = this, i = value.apply(node, arguments);
+    return i && function(t) {
+      node.setAttribute(name, i(t));
+    };
+  }
+  tween._value = value;
+  return tween;
+}
+
+var transition_attrTween = function(name, value) {
+  var key = "attr." + name;
+  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
+  if (value == null) return this.tween(key, null);
+  if (typeof value !== "function") throw new Error;
+  var fullname = namespace(name);
+  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
+};
+
+function delayFunction(id, value) {
+  return function() {
+    init(this, id).delay = +value.apply(this, arguments);
+  };
+}
+
+function delayConstant(id, value) {
+  return value = +value, function() {
+    init(this, id).delay = value;
+  };
+}
+
+var transition_delay = function(value) {
+  var id = this._id;
+
+  return arguments.length
+      ? this.each((typeof value === "function"
+          ? delayFunction
+          : delayConstant)(id, value))
+      : get(this.node(), id).delay;
+};
+
+function durationFunction(id, value) {
+  return function() {
+    set$2(this, id).duration = +value.apply(this, arguments);
+  };
+}
+
+function durationConstant(id, value) {
+  return value = +value, function() {
+    set$2(this, id).duration = value;
+  };
+}
+
+var transition_duration = function(value) {
+  var id = this._id;
+
+  return arguments.length
+      ? this.each((typeof value === "function"
+          ? durationFunction
+          : durationConstant)(id, value))
+      : get(this.node(), id).duration;
+};
+
+function easeConstant(id, value) {
+  if (typeof value !== "function") throw new Error;
+  return function() {
+    set$2(this, id).ease = value;
+  };
+}
+
+var transition_ease = function(value) {
+  var id = this._id;
+
+  return arguments.length
+      ? this.each(easeConstant(id, value))
+      : get(this.node(), id).ease;
+};
+
+var transition_filter = function(match) {
+  if (typeof match !== "function") match = matcher$1(match);
+
+  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
+    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
+      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
+        subgroup.push(node);
+      }
+    }
+  }
+
+  return new Transition(subgroups, this._parents, this._name, this._id);
+};
+
+var transition_merge = function(transition$$1) {
+  if (transition$$1._id !== this._id) throw new Error;
+
+  for (var groups0 = this._groups, groups1 = transition$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
+    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
+      if (node = group0[i] || group1[i]) {
+        merge[i] = node;
+      }
+    }
+  }
+
+  for (; j < m0; ++j) {
+    merges[j] = groups0[j];
+  }
+
+  return new Transition(merges, this._parents, this._name, this._id);
+};
+
+function start(name) {
+  return (name + "").trim().split(/^|\s+/).every(function(t) {
+    var i = t.indexOf(".");
+    if (i >= 0) t = t.slice(0, i);
+    return !t || t === "start";
+  });
+}
+
+function onFunction(id, name, listener) {
+  var on0, on1, sit = start(name) ? init : set$2;
+  return function() {
+    var schedule$$1 = sit(this, id),
+        on = schedule$$1.on;
+
+    // If this node shared a dispatch with the previous node,
+    // just assign the updated shared dispatch and we’re done!
+    // Otherwise, copy-on-write.
+    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
+
+    schedule$$1.on = on1;
+  };
+}
+
+var transition_on = function(name, listener) {
+  var id = this._id;
+
+  return arguments.length < 2
+      ? get(this.node(), id).on.on(name)
+      : this.each(onFunction(id, name, listener));
+};
+
+function removeFunction(id) {
+  return function() {
+    var parent = this.parentNode;
+    for (var i in this.__transition) if (+i !== id) return;
+    if (parent) parent.removeChild(this);
+  };
+}
+
+var transition_remove = function() {
+  return this.on("end.remove", removeFunction(this._id));
+};
+
+var transition_select = function(select) {
+  var name = this._name,
+      id = this._id;
+
+  if (typeof select !== "function") select = selector(select);
+
+  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
+    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
+      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
+        if ("__data__" in node) subnode.__data__ = node.__data__;
+        subgroup[i] = subnode;
+        schedule(subgroup[i], name, id, i, subgroup, get(node, id));
+      }
+    }
+  }
+
+  return new Transition(subgroups, this._parents, name, id);
+};
+
+var transition_selectAll = function(select) {
+  var name = this._name,
+      id = this._id;
+
+  if (typeof select !== "function") select = selectorAll(select);
+
+  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
+    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
+      if (node = group[i]) {
+        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
+          if (child = children[k]) {
+            schedule(child, name, id, k, children, inherit);
+          }
+        }
+        subgroups.push(children);
+        parents.push(node);
+      }
+    }
+  }
+
+  return new Transition(subgroups, parents, name, id);
+};
+
+var Selection$1 = selection.prototype.constructor;
+
+var transition_selection = function() {
+  return new Selection$1(this._groups, this._parents);
+};
+
+function styleRemove$1(name, interpolate$$1) {
+  var value00,
+      value10,
+      interpolate0;
+  return function() {
+    var value0 = styleValue(this, name),
+        value1 = (this.style.removeProperty(name), styleValue(this, name));
+    return value0 === value1 ? null
+        : value0 === value00 && value1 === value10 ? interpolate0
+        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
+  };
+}
+
+function styleRemoveEnd(name) {
+  return function() {
+    this.style.removeProperty(name);
+  };
+}
+
+function styleConstant$1(name, interpolate$$1, value1) {
+  var value00,
+      interpolate0;
+  return function() {
+    var value0 = styleValue(this, name);
+    return value0 === value1 ? null
+        : value0 === value00 ? interpolate0
+        : interpolate0 = interpolate$$1(value00 = value0, value1);
+  };
+}
+
+function styleFunction$1(name, interpolate$$1, value) {
+  var value00,
+      value10,
+      interpolate0;
+  return function() {
+    var value0 = styleValue(this, name),
+        value1 = value(this);
+    if (value1 == null) value1 = (this.style.removeProperty(name), styleValue(this, name));
+    return value0 === value1 ? null
+        : value0 === value00 && value1 === value10 ? interpolate0
+        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
+  };
+}
+
+var transition_style = function(name, value, priority) {
+  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
+  return value == null ? this
+          .styleTween(name, styleRemove$1(name, i))
+          .on("end.style." + name, styleRemoveEnd(name))
+      : this.styleTween(name, typeof value === "function"
+          ? styleFunction$1(name, i, tweenValue(this, "style." + name, value))
+          : styleConstant$1(name, i, value + ""), priority);
+};
+
+function styleTween(name, value, priority) {
+  function tween() {
+    var node = this, i = value.apply(node, arguments);
+    return i && function(t) {
+      node.style.setProperty(name, i(t), priority);
+    };
+  }
+  tween._value = value;
+  return tween;
+}
+
+var transition_styleTween = function(name, value, priority) {
+  var key = "style." + (name += "");
+  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
+  if (value == null) return this.tween(key, null);
+  if (typeof value !== "function") throw new Error;
+  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
+};
+
+function textConstant$1(value) {
+  return function() {
+    this.textContent = value;
+  };
+}
+
+function textFunction$1(value) {
+  return function() {
+    var value1 = value(this);
+    this.textContent = value1 == null ? "" : value1;
+  };
+}
+
+var transition_text = function(value) {
+  return this.tween("text", typeof value === "function"
+      ? textFunction$1(tweenValue(this, "text", value))
+      : textConstant$1(value == null ? "" : value + ""));
+};
+
+var transition_transition = function() {
+  var name = this._name,
+      id0 = this._id,
+      id1 = newId();
+
+  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
+    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
+      if (node = group[i]) {
+        var inherit = get(node, id0);
+        schedule(node, name, id1, i, group, {
+          time: inherit.time + inherit.delay + inherit.duration,
+          delay: 0,
+          duration: inherit.duration,
+          ease: inherit.ease
+        });
+      }
+    }
+  }
+
+  return new Transition(groups, this._parents, name, id1);
+};
+
+var id = 0;
+
+function Transition(groups, parents, name, id) {
+  this._groups = groups;
+  this._parents = parents;
+  this._name = name;
+  this._id = id;
+}
+
+function transition(name) {
+  return selection().transition(name);
+}
+
+function newId() {
+  return ++id;
+}
+
+var selection_prototype = selection.prototype;
+
+Transition.prototype = transition.prototype = {
+  constructor: Transition,
+  select: transition_select,
+  selectAll: transition_selectAll,
+  filter: transition_filter,
+  merge: transition_merge,
+  selection: transition_selection,
+  transition: transition_transition,
+  call: selection_prototype.call,
+  nodes: selection_prototype.nodes,
+  node: selection_prototype.node,
+  size: selection_prototype.size,
+  empty: selection_prototype.empty,
+  each: selection_prototype.each,
+  on: transition_on,
+  attr: transition_attr,
+  attrTween: transition_attrTween,
+  style: transition_style,
+  styleTween: transition_styleTween,
+  text: transition_text,
+  remove: transition_remove,
+  tween: transition_tween,
+  delay: transition_delay,
+  duration: transition_duration,
+  ease: transition_ease
+};
+
+var defaultTiming = {
+  time: null, // Set on use.
+  delay: 0,
+  duration: 250,
+  ease: cubicInOut
+};
+
+function inherit(node, id) {
+  var timing;
+  while (!(timing = node.__transition) || !(timing = timing[id])) {
+    if (!(node = node.parentNode)) {
+      return defaultTiming.time = now(), defaultTiming;
+    }
+  }
+  return timing;
+}
+
+var selection_transition = function(name) {
+  var id,
+      timing;
+
+  if (name instanceof Transition) {
+    id = name._id, name = name._name;
+  } else {
+    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
+  }
+
+  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
+    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
+      if (node = group[i]) {
+        schedule(node, name, id, i, group, timing || inherit(node, id));
+      }
+    }
+  }
+
+  return new Transition(groups, this._parents, name, id);
+};
+
+selection.prototype.interrupt = selection_interrupt;
+selection.prototype.transition = selection_transition;
+
+exports.select = select;
+exports.selection = selection;
+exports.hierarchy = hierarchy;
+exports.partition = partition;
+exports.scaleLinear = linear;
+exports.easeCubic = cubicInOut;
+exports.ascending = ascending$1;
+exports.map = map$1;
+exports.transition = transition;
+
+Object.defineProperty(exports, '__esModule', { value: true });
+
+})));
+`
diff --git a/src/cmd/vendor/github.com/google/pprof/third_party/d3flamegraph/LICENSE b/src/cmd/vendor/github.com/google/pprof/third_party/d3flamegraph/LICENSE
new file mode 100644
index 0000000000..8dada3edaf
--- /dev/null
+++ b/src/cmd/vendor/github.com/google/pprof/third_party/d3flamegraph/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "{}"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright {yyyy} {name of copyright owner}
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/src/cmd/vendor/github.com/google/pprof/third_party/d3flamegraph/d3_flame_graph.go b/src/cmd/vendor/github.com/google/pprof/third_party/d3flamegraph/d3_flame_graph.go
new file mode 100644
index 0000000000..d340f7076f
--- /dev/null
+++ b/src/cmd/vendor/github.com/google/pprof/third_party/d3flamegraph/d3_flame_graph.go
@@ -0,0 +1,711 @@
+// A D3.js plugin that produces flame graphs from hierarchical data.
+// https://github.com/spiermar/d3-flame-graph
+// Version 1.0.11
+// See LICENSE file for license details
+
+package d3flamegraph
+
+// JSSource returns the d3.flameGraph.js file
+const JSSource = `
+/**!
+*
+*  Copyright 2017 Martin Spier <spiermar@gmail.com>
+*
+*  Licensed under the Apache License, Version 2.0 (the "License");
+*  you may not use this file except in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing, software
+*  distributed under the License is distributed on an "AS IS" BASIS,
+*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+*  See the License for the specific language governing permissions and
+*  limitations under the License.
+*
+*/
+(function() {
+  'use strict';
+
+  /*jshint eqnull:true */
+  // https://tc39.github.io/ecma262/#sec-array.prototype.find
+  if (!Array.prototype.find) {
+    Object.defineProperty(Array.prototype, 'find', {
+      value: function(predicate) {
+      // 1. Let O be ? ToObject(this value).
+        if (this == null) {
+          throw new TypeError('"this" is null or not defined');
+        }
+
+        var o = Object(this);
+
+        // 2. Let len be ? ToLength(? Get(O, "length")).
+        var len = o.length >>> 0;
+
+        // 3. If IsCallable(predicate) is false, throw a TypeError exception.
+        if (typeof predicate !== 'function') {
+          throw new TypeError('predicate must be a function');
+        }
+
+        // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
+        var thisArg = arguments[1];
+
+        // 5. Let k be 0.
+        var k = 0;
+
+        // 6. Repeat, while k < len
+        while (k < len) {
+          // a. Let Pk be ! ToString(k).
+          // b. Let kValue be ? Get(O, Pk).
+          // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
+          // d. If testResult is true, return kValue.
+          var kValue = o[k];
+          if (predicate.call(thisArg, kValue, k, o)) {
+            return kValue;
+          }
+          // e. Increase k by 1.
+          k++;
+        }
+
+        // 7. Return undefined.
+        return undefined;
+      }
+    });
+  }
+
+  if (!Array.prototype.filter)
+  Array.prototype.filter = function(func, thisArg) {
+    if ( ! ((typeof func === 'function') && this) )
+        throw new TypeError();
+    
+    var len = this.length >>> 0,
+        res = new Array(len), // preallocate array
+        c = 0, i = -1;
+    if (thisArg === undefined)
+      while (++i !== len)
+        // checks to see if the key was set
+        if (i in this)
+          if (func(t[i], i, t))
+            res[c++] = t[i];
+    else
+      while (++i !== len)
+        // checks to see if the key was set
+        if (i in this)
+          if (func.call(thisArg, t[i], i, t))
+            res[c++] = t[i];
+    
+    res.length = c; // shrink down array to proper size
+    return res;
+  };
+  /*jshint eqnull:false */
+
+  // Node/CommonJS - require D3
+  if (typeof(module) !== 'undefined' && typeof(exports) !== 'undefined' && typeof(d3) == 'undefined') {
+      d3 = require('d3');
+  }
+
+  // Node/CommonJS - require d3-tip
+  if (typeof(module) !== 'undefined' && typeof(exports) !== 'undefined' && typeof(d3.tip) == 'undefined') {
+      d3.tip = require('d3-tip');
+  }
+
+  function flameGraph() {
+
+    var w = 960, // graph width
+      h = null, // graph height
+      c = 18, // cell height
+      selection = null, // selection
+      tooltip = true, // enable tooltip
+      title = "", // graph title
+      transitionDuration = 750,
+      transitionEase = d3.easeCubic, // tooltip offset
+      sort = false,
+      reversed = false, // reverse the graph direction
+      clickHandler = null,
+      minFrameSize = 0,
+      details = null;
+
+    var tip = d3.tip()
+      .direction("s")
+      .offset([8, 0])
+      .attr('class', 'd3-flame-graph-tip')
+      .html(function(d) { return label(d); });
+
+    var svg;
+
+    function name(d) {
+      return d.data.n || d.data.name;
+    }
+
+    function children(d) {
+      return d.c || d.children;
+    }
+
+    function value(d) {
+      return d.v || d.value;
+    }
+
+    var label = function(d) {
+      return name(d) + " (" + d3.format(".3f")(100 * (d.x1 - d.x0), 3) + "%, " + value(d) + " samples)";
+    };
+
+    function setDetails(t) {
+      if (details)
+        details.innerHTML = t;
+    }
+
+    var colorMapper = function(d) {
+      return d.highlight ? "#E600E6" : colorHash(name(d));
+    };
+
+    function generateHash(name) {
+      // Return a vector (0.0->1.0) that is a hash of the input string.
+      // The hash is computed to favor early characters over later ones, so
+      // that strings with similar starts have similar vectors. Only the first
+      // 6 characters are considered.
+      var hash = 0, weight = 1, max_hash = 0, mod = 10, max_char = 6;
+      if (name) {
+        for (var i = 0; i < name.length; i++) {
+          if (i > max_char) { break; }
+          hash += weight * (name.charCodeAt(i) % mod);
+          max_hash += weight * (mod - 1);
+          weight *= 0.70;
+        }
+        if (max_hash > 0) { hash = hash / max_hash; }
+      }
+      return hash;
+    }
+
+    function colorHash(name) {
+      // Return an rgb() color string that is a hash of the provided name,
+      // and with a warm palette.
+      var vector = 0;
+      if (name) {
+        var nameArr = name.split('` + "`" + `');
+        if (nameArr.length > 1) {
+          name = nameArr[nameArr.length -1]; // drop module name if present
+        }
+        name = name.split('(')[0]; // drop extra info
+        vector = generateHash(name);
+      }
+      var r = 200 + Math.round(55 * vector);
+      var g = 0 + Math.round(230 * (1 - vector));
+      var b = 0 + Math.round(55 * (1 - vector));
+      return "rgb(" + r + "," + g + "," + b + ")";
+    }
+
+    function hide(d) {
+      d.data.hide = true;
+      if(children(d)) {
+        children(d).forEach(hide);
+      }
+    }
+
+    function show(d) {
+      d.data.fade = false;
+      d.data.hide = false;
+      if(children(d)) {
+        children(d).forEach(show);
+      }
+    }
+
+    function getSiblings(d) {
+      var siblings = [];
+      if (d.parent) {
+        var me = d.parent.children.indexOf(d);
+        siblings = d.parent.children.slice(0);
+        siblings.splice(me, 1);
+      }
+      return siblings;
+    }
+
+    function hideSiblings(d) {
+      var siblings = getSiblings(d);
+      siblings.forEach(function(s) {
+        hide(s);
+      });
+      if(d.parent) {
+        hideSiblings(d.parent);
+      }
+    }
+
+    function fadeAncestors(d) {
+      if(d.parent) {
+        d.parent.data.fade = true;
+        fadeAncestors(d.parent);
+      }
+    }
+
+    function getRoot(d) {
+      if(d.parent) {
+        return getRoot(d.parent);
+      }
+      return d;
+    }
+
+    function zoom(d) {
+      tip.hide(d);
+      hideSiblings(d);
+      show(d);
+      fadeAncestors(d);
+      update();
+      if (typeof clickHandler === 'function') {
+        clickHandler(d);
+      }
+    }
+
+    function searchTree(d, term) {
+      var re = new RegExp(term),
+          searchResults = [];
+
+      function searchInner(d) {
+        var label = name(d);
+
+        if (children(d)) {
+          children(d).forEach(function (child) {
+            searchInner(child);
+          });
+        }
+
+        if (label.match(re)) {
+          d.highlight = true;
+          searchResults.push(d);
+        } else {
+          d.highlight = false;
+        }
+      }
+
+      searchInner(d);
+      return searchResults;
+    }
+
+    function clear(d) {
+      d.highlight = false;
+      if(children(d)) {
+        children(d).forEach(function(child) {
+          clear(child);
+        });
+      }
+    }
+
+    function doSort(a, b) {
+      if (typeof sort === 'function') {
+        return sort(a, b);
+      } else if (sort) {
+        return d3.ascending(name(a), name(b));
+      }
+    }
+
+    var partition = d3.partition();
+
+    function filterNodes(root) {
+      var nodeList = root.descendants();
+      if (minFrameSize > 0) {
+        var kx = w / (root.x1 - root.x0);
+        nodeList = nodeList.filter(function(el) {
+          return ((el.x1 - el.x0) * kx) > minFrameSize;
+        });
+      }
+      return nodeList;
+    }
+
+    function update() {
+      selection.each(function(root) {
+        var x = d3.scaleLinear().range([0, w]),
+            y = d3.scaleLinear().range([0, c]);
+
+        if (sort) root.sort(doSort);
+        root.sum(function(d) {
+          if (d.fade || d.hide) {
+            return 0;
+          }
+          // The node's self value is its total value minus all children.
+          var v = value(d);
+          if (children(d)) {
+            var c = children(d);
+            for (var i = 0; i < c.length; i++) {
+              v -= value(c[i]);
+            }
+          }
+          return v;
+        });
+        partition(root);
+
+        var kx = w / (root.x1 - root.x0);
+        function width(d) { return (d.x1 - d.x0) * kx; }
+
+        var descendants = filterNodes(root);
+        var g = d3.select(this).select("svg").selectAll("g").data(descendants, function(d) { return d.id; });
+
+        g.transition()
+          .duration(transitionDuration)
+          .ease(transitionEase)
+          .attr("transform", function(d) { return "translate(" + x(d.x0) + "," + (reversed ? y(d.depth) : (h - y(d.depth) - c)) + ")"; });
+
+        g.select("rect")
+          .attr("width", width);
+
+        var node = g.enter()
+          .append("svg:g")
+          .attr("transform", function(d) { return "translate(" + x(d.x0) + "," + (reversed ? y(d.depth) : (h - y(d.depth) - c)) + ")"; });
+        
+        node.append("svg:rect")
+          .transition()
+          .delay(transitionDuration / 2)
+          .attr("width", width);
+        
+        if (!tooltip)
+          node.append("svg:title");
+
+        node.append("foreignObject")
+          .append("xhtml:div");
+
+        // Now we have to re-select to see the new elements (why?).
+        g = d3.select(this).select("svg").selectAll("g").data(descendants, function(d) { return d.id; });
+
+        g.attr("width", width)
+          .attr("height", function(d) { return c; })
+          .attr("name", function(d) { return name(d); })
+          .attr("class", function(d) { return d.data.fade ? "frame fade" : "frame"; });
+
+        g.select("rect")
+          .attr("height", function(d) { return c; })
+          .attr("fill", function(d) { return colorMapper(d); });
+
+        if (!tooltip)
+          g.select("title")
+            .text(label);
+
+        g.select("foreignObject")
+          .attr("width", width)
+          .attr("height", function(d) { return c; })
+          .select("div")
+          .attr("class", "d3-flame-graph-label")
+          .style("display", function(d) { return (width(d) < 35) ? "none" : "block";})
+          .transition()
+          .delay(transitionDuration)
+          .text(name);
+
+        g.on('click', zoom);
+
+        g.exit()
+          .remove();
+
+        g.on('mouseover', function(d) {
+          if (tooltip) tip.show(d);
+          setDetails(label(d));
+        }).on('mouseout', function(d) {
+          if (tooltip) tip.hide(d);
+          setDetails("");
+        });
+      });
+    }
+
+    function merge(data, samples) {
+      samples.forEach(function (sample) {
+        var node = data.find(function (element) {
+          return (element.name === sample.name);
+        });
+
+        if (node) {
+          if (node.original) {
+            node.original += sample.value;
+          } else {
+            node.value += sample.value;
+          }
+          if (sample.children) {
+            if (!node.children) {
+              node.children = [];
+            }
+            merge(node.children, sample.children);
+          }
+        } else {
+          data.push(sample);
+        }
+      });
+    }
+
+    function s4() {
+      return Math.floor((1 + Math.random()) * 0x10000)
+        .toString(16)
+        .substring(1);
+    }
+
+    function injectIds(node) {
+      node.id = s4() + "-" + s4() + "-" + "-" + s4() + "-" + s4();
+      var children = node.c || node.children || [];
+      for (var i = 0; i < children.length; i++) {
+        injectIds(children[i]);
+      }
+    }
+
+    function chart(s) {
+      var root = d3.hierarchy(
+        s.datum(), function(d) { return children(d); }
+      );
+      injectIds(root);
+      selection = s.datum(root);
+
+      if (!arguments.length) return chart;
+
+      if (!h) {
+        h = (root.height + 2) * c;
+      }
+
+      selection.each(function(data) {
+
+	      if (!svg) {
+          svg = d3.select(this)
+            .append("svg:svg")
+            .attr("width", w)
+            .attr("height", h)
+            .attr("class", "partition d3-flame-graph")
+            .call(tip);
+
+          svg.append("svg:text")
+            .attr("class", "title")
+            .attr("text-anchor", "middle")
+            .attr("y", "25")
+            .attr("x", w/2)
+            .attr("fill", "#808080")
+            .text(title);
+        }
+      });
+
+      // first draw
+      update();
+    }
+
+    chart.height = function (_) {
+      if (!arguments.length) { return h; }
+      h = _;
+      return chart;
+    };
+
+    chart.width = function (_) {
+      if (!arguments.length) { return w; }
+      w = _;
+      return chart;
+    };
+
+    chart.cellHeight = function (_) {
+      if (!arguments.length) { return c; }
+      c = _;
+      return chart;
+    };
+
+    chart.tooltip = function (_) {
+      if (!arguments.length) { return tooltip; }
+      if (typeof _ === "function") {
+        tip = _;
+      }
+      tooltip = !!_;
+      return chart;
+    };
+
+    chart.title = function (_) {
+      if (!arguments.length) { return title; }
+      title = _;
+      return chart;
+    };
+
+    chart.transitionDuration = function (_) {
+      if (!arguments.length) { return transitionDuration; }
+      transitionDuration = _;
+      return chart;
+    };
+
+    chart.transitionEase = function (_) {
+      if (!arguments.length) { return transitionEase; }
+      transitionEase = _;
+      return chart;
+    };
+
+    chart.sort = function (_) {
+      if (!arguments.length) { return sort; }
+      sort = _;
+      return chart;
+    };
+
+    chart.reversed = function (_) {
+      if (!arguments.length) { return reversed; }
+      reversed = _;
+      return chart;
+    };
+
+    chart.label = function(_) {
+      if (!arguments.length) { return label; }
+      label = _;
+      return chart;
+    };
+
+    chart.search = function(term) {
+      var searchResults = [];
+      selection.each(function(data) {
+        searchResults = searchTree(data, term);
+        update();
+      });
+      return searchResults;
+    };
+
+    chart.clear = function() {
+      selection.each(function(data) {
+        clear(data);
+        update();
+      });
+    };
+
+    chart.zoomTo = function(d) {
+      zoom(d);
+    };
+
+    chart.resetZoom = function() {
+      selection.each(function (data) {
+        zoom(data); // zoom to root
+      });
+    };
+
+    chart.onClick = function(_) {
+      if (!arguments.length) {
+        return clickHandler;
+      }
+      clickHandler = _;
+      return chart;
+    };
+    
+    chart.merge = function(samples) {
+      var newRoot; // Need to re-create hierarchy after data changes.
+      selection.each(function (root) {
+        merge([root.data], [samples]);
+        newRoot = d3.hierarchy(root.data, function(d) { return children(d); });
+        injectIds(newRoot);
+      });
+      selection = selection.datum(newRoot);
+      update();
+    };
+    
+    chart.color = function(_) {
+      if (!arguments.length) { return colorMapper; }
+      colorMapper = _;
+      return chart;
+    };
+
+    chart.minFrameSize = function (_) {
+      if (!arguments.length) { return minFrameSize; }
+      minFrameSize = _;
+      return chart;
+    };
+
+    chart.details = function (_) {
+      if (!arguments.length) { return details; }
+      details = _;
+      return chart;
+    };
+
+    return chart;
+  }
+
+  // Node/CommonJS exports
+  if (typeof(module) !== 'undefined' && typeof(exports) !== 'undefined') {
+    module.exports = flameGraph;
+  } else {
+    d3.flameGraph = flameGraph;
+  }
+})();
+`
+
+// CSSSource returns the d3.flameGraph.css file
+const CSSSource = `
+.d3-flame-graph rect {
+  stroke: #EEEEEE;
+  fill-opacity: .8;
+}
+
+.d3-flame-graph rect:hover {
+  stroke: #474747;
+  stroke-width: 0.5;
+  cursor: pointer;
+}
+
+.d3-flame-graph-label {
+  pointer-events: none;
+  white-space: nowrap;
+  text-overflow: ellipsis;
+  overflow: hidden;
+  font-size: 12px;
+  font-family: Verdana;
+  margin-left: 4px;
+  margin-right: 4px;
+  line-height: 1.5;
+  padding: 0 0 0;
+  font-weight: 400;
+  color: black;
+  text-align: left;
+}
+
+.d3-flame-graph .fade {
+  opacity: 0.6 !important;
+}
+
+.d3-flame-graph .title {
+  font-size: 20px;
+  font-family: Verdana;
+}
+
+.d3-flame-graph-tip {
+  line-height: 1;
+  font-family: Verdana;
+  font-size: 12px;
+  padding: 12px;
+  background: rgba(0, 0, 0, 0.8);
+  color: #fff;
+  border-radius: 2px;
+  pointer-events: none;
+}
+
+/* Creates a small triangle extender for the tooltip */
+.d3-flame-graph-tip:after {
+  box-sizing: border-box;
+  display: inline;
+  font-size: 10px;
+  width: 100%;
+  line-height: 1;
+  color: rgba(0, 0, 0, 0.8);
+  position: absolute;
+  pointer-events: none;
+}
+
+/* Northward tooltips */
+.d3-flame-graph-tip.n:after {
+  content: "\25BC";
+  margin: -1px 0 0 0;
+  top: 100%;
+  left: 0;
+  text-align: center;
+}
+
+/* Eastward tooltips */
+.d3-flame-graph-tip.e:after {
+  content: "\25C0";
+  margin: -4px 0 0 0;
+  top: 50%;
+  left: -8px;
+}
+
+/* Southward tooltips */
+.d3-flame-graph-tip.s:after {
+  content: "\25B2";
+  margin: 0 0 1px 0;
+  top: -8px;
+  left: 0;
+  text-align: center;
+}
+
+/* Westward tooltips */
+.d3-flame-graph-tip.w:after {
+  content: "\25B6";
+  margin: -4px 0 0 -1px;
+  top: 50%;
+  left: 100%;
+}
+`
diff --git a/src/cmd/vendor/github.com/google/pprof/third_party/d3tip/LICENSE b/src/cmd/vendor/github.com/google/pprof/third_party/d3tip/LICENSE
new file mode 100644
index 0000000000..2b5c6194ac
--- /dev/null
+++ b/src/cmd/vendor/github.com/google/pprof/third_party/d3tip/LICENSE
@@ -0,0 +1,8 @@
+The MIT License (MIT)
+Copyright (c) 2013 Justin Palmer
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
\ No newline at end of file
diff --git a/src/cmd/vendor/github.com/google/pprof/third_party/d3tip/d3_tip.go b/src/cmd/vendor/github.com/google/pprof/third_party/d3tip/d3_tip.go
new file mode 100644
index 0000000000..276cde362a
--- /dev/null
+++ b/src/cmd/vendor/github.com/google/pprof/third_party/d3tip/d3_tip.go
@@ -0,0 +1,328 @@
+// Tooltips for d3.js visualizations
+// https://github.com/Caged/d3-tip
+// Version 0.7.1
+// See LICENSE file for license details
+
+package d3tip
+
+// JSSource returns the d3-tip.js file
+const JSSource = `
+(function (root, factory) {
+  if (typeof define === 'function' && define.amd) {
+    // AMD. Register as an anonymous module with d3 as a dependency.
+    define(['d3'], factory)
+  } else if (typeof module === 'object' && module.exports) {
+    // CommonJS
+    var d3 = require('d3')
+    module.exports = factory(d3)
+  } else {
+    // Browser global.
+    root.d3.tip = factory(root.d3)
+  }
+}(this, function (d3) {
+
+  // Public - contructs a new tooltip
+  //
+  // Returns a tip
+  return function() {
+    var direction = d3_tip_direction,
+        offset    = d3_tip_offset,
+        html      = d3_tip_html,
+        node      = initNode(),
+        svg       = null,
+        point     = null,
+        target    = null
+
+    function tip(vis) {
+      svg = getSVGNode(vis)
+      point = svg.createSVGPoint()
+      document.body.appendChild(node)
+    }
+
+    // Public - show the tooltip on the screen
+    //
+    // Returns a tip
+    tip.show = function() {
+      var args = Array.prototype.slice.call(arguments)
+      if(args[args.length - 1] instanceof SVGElement) target = args.pop()
+
+      var content = html.apply(this, args),
+          poffset = offset.apply(this, args),
+          dir     = direction.apply(this, args),
+          nodel   = getNodeEl(),
+          i       = directions.length,
+          coords,
+          scrollTop  = document.documentElement.scrollTop || document.body.scrollTop,
+          scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft
+
+      nodel.html(content)
+        .style('opacity', 1).style('pointer-events', 'all')
+
+      while(i--) nodel.classed(directions[i], false)
+      coords = direction_callbacks.get(dir).apply(this)
+      nodel.classed(dir, true)
+      	.style('top', (coords.top +  poffset[0]) + scrollTop + 'px')
+      	.style('left', (coords.left + poffset[1]) + scrollLeft + 'px')
+
+      return tip;
+    };
+
+    // Public - hide the tooltip
+    //
+    // Returns a tip
+    tip.hide = function() {
+      var nodel = getNodeEl()
+      nodel.style('opacity', 0).style('pointer-events', 'none')
+      return tip
+    }
+
+    // Public: Proxy attr calls to the d3 tip container.  Sets or gets attribute value.
+    //
+    // n - name of the attribute
+    // v - value of the attribute
+    //
+    // Returns tip or attribute value
+    tip.attr = function(n, v) {
+      if (arguments.length < 2 && typeof n === 'string') {
+        return getNodeEl().attr(n)
+      } else {
+        var args =  Array.prototype.slice.call(arguments)
+        d3.selection.prototype.attr.apply(getNodeEl(), args)
+      }
+
+      return tip
+    }
+
+    // Public: Proxy style calls to the d3 tip container.  Sets or gets a style value.
+    //
+    // n - name of the property
+    // v - value of the property
+    //
+    // Returns tip or style property value
+    tip.style = function(n, v) {
+      if (arguments.length < 2 && typeof n === 'string') {
+        return getNodeEl().style(n)
+      } else {
+        var args = Array.prototype.slice.call(arguments)
+        d3.selection.prototype.style.apply(getNodeEl(), args)
+      }
+
+      return tip
+    }
+
+    // Public: Set or get the direction of the tooltip
+    //
+    // v - One of n(north), s(south), e(east), or w(west), nw(northwest),
+    //     sw(southwest), ne(northeast) or se(southeast)
+    //
+    // Returns tip or direction
+    tip.direction = function(v) {
+      if (!arguments.length) return direction
+      direction = v == null ? v : functor(v)
+
+      return tip
+    }
+
+    // Public: Sets or gets the offset of the tip
+    //
+    // v - Array of [x, y] offset
+    //
+    // Returns offset or
+    tip.offset = function(v) {
+      if (!arguments.length) return offset
+      offset = v == null ? v : functor(v)
+
+      return tip
+    }
+
+    // Public: sets or gets the html value of the tooltip
+    //
+    // v - String value of the tip
+    //
+    // Returns html value or tip
+    tip.html = function(v) {
+      if (!arguments.length) return html
+      html = v == null ? v : functor(v)
+
+      return tip
+    }
+
+    // Public: destroys the tooltip and removes it from the DOM
+    //
+    // Returns a tip
+    tip.destroy = function() {
+      if(node) {
+        getNodeEl().remove();
+        node = null;
+      }
+      return tip;
+    }
+
+    function d3_tip_direction() { return 'n' }
+    function d3_tip_offset() { return [0, 0] }
+    function d3_tip_html() { return ' ' }
+
+    var direction_callbacks = d3.map({
+      n:  direction_n,
+      s:  direction_s,
+      e:  direction_e,
+      w:  direction_w,
+      nw: direction_nw,
+      ne: direction_ne,
+      sw: direction_sw,
+      se: direction_se
+    }),
+
+    directions = direction_callbacks.keys()
+
+    function direction_n() {
+      var bbox = getScreenBBox()
+      return {
+        top:  bbox.n.y - node.offsetHeight,
+        left: bbox.n.x - node.offsetWidth / 2
+      }
+    }
+
+    function direction_s() {
+      var bbox = getScreenBBox()
+      return {
+        top:  bbox.s.y,
+        left: bbox.s.x - node.offsetWidth / 2
+      }
+    }
+
+    function direction_e() {
+      var bbox = getScreenBBox()
+      return {
+        top:  bbox.e.y - node.offsetHeight / 2,
+        left: bbox.e.x
+      }
+    }
+
+    function direction_w() {
+      var bbox = getScreenBBox()
+      return {
+        top:  bbox.w.y - node.offsetHeight / 2,
+        left: bbox.w.x - node.offsetWidth
+      }
+    }
+
+    function direction_nw() {
+      var bbox = getScreenBBox()
+      return {
+        top:  bbox.nw.y - node.offsetHeight,
+        left: bbox.nw.x - node.offsetWidth
+      }
+    }
+
+    function direction_ne() {
+      var bbox = getScreenBBox()
+      return {
+        top:  bbox.ne.y - node.offsetHeight,
+        left: bbox.ne.x
+      }
+    }
+
+    function direction_sw() {
+      var bbox = getScreenBBox()
+      return {
+        top:  bbox.sw.y,
+        left: bbox.sw.x - node.offsetWidth
+      }
+    }
+
+    function direction_se() {
+      var bbox = getScreenBBox()
+      return {
+        top:  bbox.se.y,
+        left: bbox.e.x
+      }
+    }
+
+    function initNode() {
+      var node = d3.select(document.createElement('div'));
+      node.style('position', 'absolute').style('top', 0).style('opacity', 0)
+      	.style('pointer-events', 'none').style('box-sizing', 'border-box')
+
+      return node.node()
+    }
+
+    function getSVGNode(el) {
+      el = el.node()
+      if(el.tagName.toLowerCase() === 'svg')
+        return el
+
+      return el.ownerSVGElement
+    }
+
+    function getNodeEl() {
+      if(node === null) {
+        node = initNode();
+        // re-add node to DOM
+        document.body.appendChild(node);
+      };
+      return d3.select(node);
+    }
+
+    // Private - gets the screen coordinates of a shape
+    //
+    // Given a shape on the screen, will return an SVGPoint for the directions
+    // n(north), s(south), e(east), w(west), ne(northeast), se(southeast), nw(northwest),
+    // sw(southwest).
+    //
+    //    +-+-+
+    //    |   |
+    //    +   +
+    //    |   |
+    //    +-+-+
+    //
+    // Returns an Object {n, s, e, w, nw, sw, ne, se}
+    function getScreenBBox() {
+      var targetel   = target || d3.event.target;
+
+      while ('undefined' === typeof targetel.getScreenCTM && 'undefined' === targetel.parentNode) {
+          targetel = targetel.parentNode;
+      }
+
+      var bbox       = {},
+          matrix     = targetel.getScreenCTM(),
+          tbbox      = targetel.getBBox(),
+          width      = tbbox.width,
+          height     = tbbox.height,
+          x          = tbbox.x,
+          y          = tbbox.y
+
+      point.x = x
+      point.y = y
+      bbox.nw = point.matrixTransform(matrix)
+      point.x += width
+      bbox.ne = point.matrixTransform(matrix)
+      point.y += height
+      bbox.se = point.matrixTransform(matrix)
+      point.x -= width
+      bbox.sw = point.matrixTransform(matrix)
+      point.y -= height / 2
+      bbox.w  = point.matrixTransform(matrix)
+      point.x += width
+      bbox.e = point.matrixTransform(matrix)
+      point.x -= width / 2
+      point.y -= height / 2
+      bbox.n = point.matrixTransform(matrix)
+      point.y += height
+      bbox.s = point.matrixTransform(matrix)
+
+      return bbox
+    }
+    
+    // Private - replace D3JS 3.X d3.functor() function
+    function functor(v) {
+    	return typeof v === "function" ? v : function() {
+        return v
+    	}
+    }
+
+    return tip
+  };
+
+}));
+`
diff --git a/src/cmd/vendor/github.com/google/pprof/third_party/svgpan/LICENSE b/src/cmd/vendor/github.com/google/pprof/third_party/svgpan/LICENSE
new file mode 100644
index 0000000000..35bc174556
--- /dev/null
+++ b/src/cmd/vendor/github.com/google/pprof/third_party/svgpan/LICENSE
@@ -0,0 +1,27 @@
+Copyright 2009-2017 Andrea Leofreddi <a.leofreddi@vleo.net>. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are
+permitted provided that the following conditions are met:
+
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+   3. Neither the name of the copyright holder nor the names of its
+      contributors may be used to endorse or promote products derived from
+      this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS
+OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS OR
+CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+The views and conclusions contained in the software and documentation are those of the
+authors and should not be interpreted as representing official policies, either expressed
+or implied, of Andrea Leofreddi.
diff --git a/src/cmd/vendor/github.com/google/pprof/third_party/svg/svgpan.go b/src/cmd/vendor/github.com/google/pprof/third_party/svgpan/svgpan.go
similarity index 77%
rename from src/cmd/vendor/github.com/google/pprof/third_party/svg/svgpan.go
rename to src/cmd/vendor/github.com/google/pprof/third_party/svgpan/svgpan.go
index 4975b103e3..e7639a388e 100644
--- a/src/cmd/vendor/github.com/google/pprof/third_party/svg/svgpan.go
+++ b/src/cmd/vendor/github.com/google/pprof/third_party/svgpan/svgpan.go
@@ -1,17 +1,19 @@
 // SVG pan and zoom library.
 // See copyright notice in string constant below.
 
-package svg
+package svgpan
 
-// https://www.cyberz.org/projects/SVGPan/SVGPan.js
+// https://github.com/aleofreddi/svgpan
 
-const svgPanJS = `
-/** 
- *  SVGPan library 1.2.1
+// JSSource returns the svgpan.js file
+const JSSource = `
+/**
+ *  SVGPan library 1.2.2
  * ======================
  *
- * Given an unique existing element with id "viewport" (or when missing, the first g 
- * element), including the the library into any SVG adds the following capabilities:
+ * Given an unique existing element with id "viewport" (or when missing, the
+ * first g-element), including the the library into any SVG adds the following
+ * capabilities:
  *
  *  - Mouse panning
  *  - Mouse zooming (using the wheel)
@@ -26,6 +28,10 @@ const svgPanJS = `
  *
  * Releases:
  *
+ * 1.2.2, Tue Aug 30 17:21:56 CEST 2011, Andrea Leofreddi
+ *	- Fixed viewBox on root tag (#7)
+ *	- Improved zoom speed (#2)
+ *
  * 1.2.1, Mon Jul  4 00:33:18 CEST 2011, Andrea Leofreddi
  *	- Fixed a regression with mouse wheel (now working on Firefox 5)
  *	- Working with viewBox attribute (#4)
@@ -43,28 +49,30 @@ const svgPanJS = `
  *
  * This code is licensed under the following BSD license:
  *
- * Copyright 2009-2010 Andrea Leofreddi <a.leofreddi@itcharm.com>. All rights reserved.
- * 
+ * Copyright 2009-2017 Andrea Leofreddi <a.leofreddi@vleo.net>. All rights reserved.
+ *
  * Redistribution and use in source and binary forms, with or without modification, are
  * permitted provided that the following conditions are met:
- * 
- *    1. Redistributions of source code must retain the above copyright notice, this list of
- *       conditions and the following disclaimer.
- * 
- *    2. Redistributions in binary form must reproduce the above copyright notice, this list
- *       of conditions and the following disclaimer in the documentation and/or other materials
- *       provided with the distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY Andrea Leofreddi ` + "``AS IS''" + ` AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL Andrea Leofreddi OR
+ *
+ *    1. Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *    2. Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *    3. Neither the name of the copyright holder nor the names of its
+ *       contributors may be used to endorse or promote products derived from
+ *       this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
+ *
  * The views and conclusions contained in the software and documentation are those of the
  * authors and should not be interpreted as representing official policies, either expressed
  * or implied, of Andrea Leofreddi.
@@ -72,19 +80,20 @@ const svgPanJS = `
 
 "use strict";
 
-/// CONFIGURATION 
+/// CONFIGURATION
 /// ====>
 
 var enablePan = 1; // 1 or 0: enable or disable panning (default enabled)
 var enableZoom = 1; // 1 or 0: enable or disable zooming (default enabled)
 var enableDrag = 0; // 1 or 0: enable or disable dragging (default disabled)
+var zoomScale = 0.2; // Zoom sensitivity
 
 /// <====
-/// END OF CONFIGURATION 
+/// END OF CONFIGURATION
 
 var root = document.documentElement;
 
-var state = 'none', svgRoot, stateTarget, stateOrigin, stateTf;
+var state = 'none', svgRoot = null, stateTarget, stateOrigin, stateTf;
 
 setupHandlers(root);
 
@@ -109,22 +118,20 @@ function setupHandlers(root){
  * Retrieves the root element for SVG manipulation. The element is then cached into the svgRoot global variable.
  */
 function getRoot(root) {
-	if(typeof(svgRoot) == "undefined") {
-		var g = null;
-
-		g = root.getElementById("viewport");
+	if(svgRoot == null) {
+		var r = root.getElementById("viewport") ? root.getElementById("viewport") : root.documentElement, t = r;
 
-		if(g == null)
-			g = root.getElementsByTagName('g')[0];
+		while(t != root) {
+			if(t.getAttribute("viewBox")) {
+				setCTM(r, t.getCTM());
 
-		if(g == null)
-			alert('Unable to obtain SVG root element');
+				t.removeAttribute("viewBox");
+			}
 
-		setCTM(g, g.getCTM());
+			t = t.parentNode;
+		}
 
-		g.removeAttribute("viewBox");
-
-		svgRoot = g;
+		svgRoot = r;
 	}
 
 	return svgRoot;
@@ -185,11 +192,11 @@ function handleMouseWheel(evt) {
 	var delta;
 
 	if(evt.wheelDelta)
-		delta = evt.wheelDelta / 3600; // Chrome/Safari
+		delta = evt.wheelDelta / 360; // Chrome/Safari
 	else
-		delta = evt.detail / -90; // Mozilla
+		delta = evt.detail / -9; // Mozilla
 
-	var z = 1 + delta; // Zoom factor: 0.9/1.1
+	var z = Math.pow(1 + zoomScale, delta);
 
 	var g = getRoot(svgDoc);
 	
@@ -250,8 +257,8 @@ function handleMouseDown(evt) {
 	var g = getRoot(svgDoc);
 
 	if(
-		evt.target.tagName == "svg" 
-		|| !enableDrag // Pan anyway when drag is disabled and the user clicked on an element 
+		evt.target.tagName == "svg"
+		|| !enableDrag // Pan anyway when drag is disabled and the user clicked on an element
 	) {
 		// Pan mode
 		state = 'pan';
@@ -287,5 +294,4 @@ function handleMouseUp(evt) {
 		state = '';
 	}
 }
-
 `
