commit e11f833bed1f445a4fd8ccb813fa000386d277e1
Author: Russ Cox <rsc@golang.org>
Date:   Mon Jun 1 22:15:08 2009 -0700

    auto-generated, renamed, and deleted files
    associated with CL 29709.
    
    R=r
    DELTA=6444  (3476 added, 2958 deleted, 10 changed)
    OCL=29710
    CL=29724
---
 src/lib/syscall/Makefile                           |  36 +-
 .../{asm_amd64_darwin.s => asm_darwin_amd64.s}     |   2 +-
 .../{asm_amd64_linux.s => asm_linux_amd64.s}       |   2 +-
 src/lib/syscall/errstr_darwin.go                   | 242 -------
 src/lib/syscall/errstr_linux.go                    | 292 --------
 src/lib/syscall/file_darwin.go                     | 186 -----
 src/lib/syscall/file_linux.go                      | 193 ------
 src/lib/syscall/mkdarwin                           |  34 -
 src/lib/syscall/mksignal                           |  26 -
 src/lib/syscall/{mklinux => mksysnum_linux}        |   0
 src/lib/syscall/proc_darwin.go                     |  20 -
 src/lib/syscall/proc_linux.go                      |  19 -
 src/lib/syscall/signal_amd64_darwin.go             |  43 --
 src/lib/syscall/signal_amd64_linux.go              |  46 --
 src/lib/syscall/socket_darwin.go                   | 114 ---
 src/lib/syscall/socket_linux.go                    | 123 ----
 src/lib/syscall/time_amd64_darwin.go               |  24 -
 src/lib/syscall/time_amd64_linux.go                |  25 -
 src/lib/syscall/types_amd64_darwin.go              | 317 ---------
 src/lib/syscall/types_amd64_linux.go               | 314 ---------
 src/lib/syscall/zerrors_darwin_amd64.go            | 260 +++++++
 src/lib/syscall/zerrors_linux_amd64.go             | 316 +++++++++
 src/lib/syscall/zsyscall_darwin_amd64.go           | 622 +++++++++++++++++
 src/lib/syscall/zsyscall_linux_amd64.go            | 764 +++++++++++++++++++++
 ...all_amd64_darwin.go => zsysnum_darwin_amd64.go} |  10 +-
 ...scall_amd64_linux.go => zsysnum_linux_amd64.go} |   7 +-
 src/lib/syscall/ztypes_darwin_amd64.go             | 248 +++++++
 src/lib/syscall/ztypes_linux_amd64.go              | 300 ++++++++
 28 files changed, 2539 insertions(+), 2046 deletions(-)

diff --git a/src/lib/syscall/Makefile b/src/lib/syscall/Makefile
index 8c28d08ff6..eadde0fb8d 100644
--- a/src/lib/syscall/Makefile
+++ b/src/lib/syscall/Makefile
@@ -3,7 +3,7 @@
 # license that can be found in the LICENSE file.
 
 # DO NOT EDIT.  Automatically generated by gobuild.
-# gobuild -m errstr_${GOOS}.go file_${GOOS}.go socket_${GOOS}.go syscall_${GOARCH}_${GOOS}.go time_${GOARCH}_${GOOS}.go types_${GOARCH}_${GOOS}.go asm_${GOARCH}_${GOOS}.s syscall.go signal_${GOARCH}_${GOOS}.go exec.go proc_${GOOS}.go >Makefile
+# gobuild -m asm_${GOOS}_${GOARCH}.s errstr.go exec.go syscall.go syscall_${GOOS}.go syscall_${GOOS}_${GOARCH}.go zerrors_${GOOS}_${GOARCH}.go zsyscall_${GOOS}_${GOARCH}.go zsysnum_${GOOS}_${GOARCH}.go ztypes_${GOOS}_${GOARCH}.go >Makefile
 
 D=
 
@@ -40,44 +40,49 @@ coverage: packages
 	$(AS) $*.s
 
 O1=\
-	asm_$(GOARCH)_$(GOOS).$O\
-	errstr_$(GOOS).$O\
-	signal_$(GOARCH)_$(GOOS).$O\
+	asm_$(GOOS)_$(GOARCH).$O\
 	syscall.$O\
-	syscall_$(GOARCH)_$(GOOS).$O\
+	zerrors_$(GOOS)_$(GOARCH).$O\
+	zsysnum_$(GOOS)_$(GOARCH).$O\
+	ztypes_$(GOOS)_$(GOARCH).$O\
 
 O2=\
-	types_$(GOARCH)_$(GOOS).$O\
+	errstr.$O\
+	syscall_$(GOOS)_$(GOARCH).$O\
 
 O3=\
-	file_$(GOOS).$O\
-	proc_$(GOOS).$O\
-	socket_$(GOOS).$O\
-	time_$(GOARCH)_$(GOOS).$O\
+	zsyscall_$(GOOS)_$(GOARCH).$O\
 
 O4=\
+	syscall_$(GOOS).$O\
+
+O5=\
 	exec.$O\
 
 
-phases: a1 a2 a3 a4
+phases: a1 a2 a3 a4 a5
 _obj$D/syscall.a: phases
 
 a1: $(O1)
-	$(AR) grc _obj$D/syscall.a asm_$(GOARCH)_$(GOOS).$O errstr_$(GOOS).$O signal_$(GOARCH)_$(GOOS).$O syscall.$O syscall_$(GOARCH)_$(GOOS).$O
+	$(AR) grc _obj$D/syscall.a asm_$(GOOS)_$(GOARCH).$O syscall.$O zerrors_$(GOOS)_$(GOARCH).$O zsysnum_$(GOOS)_$(GOARCH).$O ztypes_$(GOOS)_$(GOARCH).$O
 	rm -f $(O1)
 
 a2: $(O2)
-	$(AR) grc _obj$D/syscall.a types_$(GOARCH)_$(GOOS).$O
+	$(AR) grc _obj$D/syscall.a errstr.$O syscall_$(GOOS)_$(GOARCH).$O
 	rm -f $(O2)
 
 a3: $(O3)
-	$(AR) grc _obj$D/syscall.a file_$(GOOS).$O proc_$(GOOS).$O socket_$(GOOS).$O time_$(GOARCH)_$(GOOS).$O
+	$(AR) grc _obj$D/syscall.a zsyscall_$(GOOS)_$(GOARCH).$O
 	rm -f $(O3)
 
 a4: $(O4)
-	$(AR) grc _obj$D/syscall.a exec.$O
+	$(AR) grc _obj$D/syscall.a syscall_$(GOOS).$O
 	rm -f $(O4)
 
+a5: $(O5)
+	$(AR) grc _obj$D/syscall.a exec.$O
+	rm -f $(O5)
+
 
 newpkg: clean
 	mkdir -p _obj$D
@@ -88,6 +93,7 @@ $(O2): a1
 $(O3): a2
 $(O4): a3
 $(O5): a4
+$(O6): a5
 
 nuke: clean
 	rm -f $(GOROOT)/pkg$D/syscall.a
diff --git a/src/lib/syscall/asm_amd64_darwin.s b/src/lib/syscall/asm_darwin_amd64.s
similarity index 96%
rename from src/lib/syscall/asm_amd64_darwin.s
rename to src/lib/syscall/asm_darwin_amd64.s
index dbc345c19d..e1527977f4 100644
--- a/src/lib/syscall/asm_amd64_darwin.s
+++ b/src/lib/syscall/asm_darwin_amd64.s
@@ -1,4 +1,4 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
+// Copyright 2009 The Go Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
diff --git a/src/lib/syscall/asm_amd64_linux.s b/src/lib/syscall/asm_linux_amd64.s
similarity index 96%
rename from src/lib/syscall/asm_amd64_linux.s
rename to src/lib/syscall/asm_linux_amd64.s
index 2826c1b580..cb93b481ab 100644
--- a/src/lib/syscall/asm_amd64_linux.s
+++ b/src/lib/syscall/asm_linux_amd64.s
@@ -1,4 +1,4 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
+// Copyright 2009 The Go Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
diff --git a/src/lib/syscall/errstr_darwin.go b/src/lib/syscall/errstr_darwin.go
deleted file mode 100644
index abb79b8842..0000000000
--- a/src/lib/syscall/errstr_darwin.go
+++ /dev/null
@@ -1,242 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package syscall
-
-const (
-	ENONE=0;
-	EPERM=1;
-	ENOENT=2;
-	ESRCH=3;
-	EINTR=4;
-	EIO=5;
-	ENXIO=6;
-	E2BIG=7;
-	ENOEXEC=8;
-	EBADF=9;
-	ECHILD=10;
-	EDEADLK=11;
-	ENOMEM=12;
-	EACCES=13;
-	EFAULT=14;
-	ENOTBLK=15;
-	EBUSY=16;
-	EEXIST=17;
-	EXDEV=18;
-	ENODEV=19;
-	ENOTDIR=20;
-	EISDIR=21;
-	EINVAL=22;
-	ENFILE=23;
-	EMFILE=24;
-	ENOTTY=25;
-	ETXTBSY=26;
-	EFBIG=27;
-	ENOSPC=28;
-	ESPIPE=29;
-	EROFS=30;
-	EMLINK=31;
-	EPIPE=32;
-	EDOM=33;
-	ERANGE=34;
-	EAGAIN=35;
-	EINPROGRESS=36;
-	EALREADY=37;
-	ENOTSOCK=38;
-	EDESTADDRREQ=39;
-	EMSGSIZE=40;
-	EPROTOTYPE=41;
-	ENOPROTOOPT=42;
-	EPROTONOSUPPORT=43;
-	ESOCKTNOSUPPORT=44;
-	ENOTSUP=45;
-	EPFNOSUPPORT=46;
-	EAFNOSUPPORT=47;
-	EADDRINUSE=48;
-	EADDRNOTAVAIL=49;
-	ENETDOWN=50;
-	ENETUNREACH=51;
-	ENETRESET=52;
-	ECONNABORTED=53;
-	ECONNRESET=54;
-	ENOBUFS=55;
-	EISCONN=56;
-	ENOTCONN=57;
-	ESHUTDOWN=58;
-	ETOOMANYREFS=59;
-	ETIMEDOUT=60;
-	ECONNREFUSED=61;
-	ELOOP=62;
-	ENAMETOOLONG=63;
-	EHOSTDOWN=64;
-	EHOSTUNREACH=65;
-	ENOTEMPTY=66;
-	EPROCLIM=67;
-	EUSERS=68;
-	EDQUOT=69;
-	ESTALE=70;
-	EREMOTE=71;
-	EBADRPC=72;
-	ERPCMISMATCH=73;
-	EPROGUNAVAIL=74;
-	EPROGMISMATCH=75;
-	EPROCUNAVAIL=76;
-	ENOLCK=77;
-	ENOSYS=78;
-	EFTYPE=79;
-	EAUTH=80;
-	ENEEDAUTH=81;
-	EPWROFF=82;
-	EDEVERR=83;
-	EOVERFLOW=84;
-	EBADEXEC=85;
-	EBADARCH=86;
-	ESHLIBVERS=87;
-	EBADMACHO=88;
-	ECANCELED=89;
-	EIDRM=90;
-	ENOMSG=91;
-	EILSEQ=92;
-	ENOATTR=93;
-	EBADMSG=94;
-	EMULTIHOP=95;
-	ENODATA=96;
-	ENOLINK=97;
-	ENOSR=98;
-	ENOSTR=99;
-	EPROTO=100;
-	ETIME=101;
-	EOPNOTSUPP=102;
-	ELAST=103;
-)
-
-var error [ELAST]string;
-
-func init(){
-	error[ENONE] = "No error";
-	error[EPERM] = "Operation not permitted";
-	error[ENOENT] = "No such file or directory";
-	error[ESRCH] = "No such process";
-	error[EINTR] = "Interrupted system call";
-	error[EIO] = "Input/output error";
-	error[ENXIO] = "Device not configured";
-	error[E2BIG] = "Argument list too long";
-	error[ENOEXEC] = "Exec format error";
-	error[EBADF] = "Bad file descriptor";
-	error[ECHILD] = "No child processes";
-	error[EDEADLK] = "Resource deadlock avoided";
-	error[ENOMEM] = "Cannot allocate memory";
-	error[EACCES] = "Permission denied";
-	error[EFAULT] = "Bad address";
-	error[ENOTBLK] = "Block device required";
-	error[EBUSY] = "Device / Resource busy";
-	error[EEXIST] = "File exists";
-	error[EXDEV] = "Cross-device link";
-	error[ENODEV] = "Operation not supported by device";
-	error[ENOTDIR] = "Not a directory";
-	error[EISDIR] = "Is a directory";
-	error[EINVAL] = "Invalid argument";
-	error[ENFILE] = "Too many open files in system";
-	error[EMFILE] = "Too many open files";
-	error[ENOTTY] = "Inappropriate ioctl for device";
-	error[ETXTBSY] = "Text file busy";
-	error[EFBIG] = "File too large";
-	error[ENOSPC] = "No space left on device";
-	error[ESPIPE] = "Illegal seek";
-	error[EROFS] = "Read-only file system";
-	error[EMLINK] = "Too many links";
-	error[EPIPE] = "Broken pipe";
-	error[EDOM] = "Numerical argument out of domain";
-	error[ERANGE] = "Result too large";
-	error[EAGAIN] = "Resource temporarily unavailable";
-	error[EINPROGRESS] = "Operation now in progress";
-	error[EALREADY] = "Operation already in progress";
-	error[ENOTSOCK] = "Socket operation on non-socket";
-	error[EDESTADDRREQ] = "Destination address required";
-	error[EMSGSIZE] = "Message too long";
-	error[EPROTOTYPE] = "Protocol wrong type for socket";
-	error[ENOPROTOOPT] = "Protocol not available";
-	error[EPROTONOSUPPORT] = "Protocol not supported";
-	error[ESOCKTNOSUPPORT] = "Socket type not supported";
-	error[ENOTSUP] = "Operation not supported";
-	error[EPFNOSUPPORT] = "Protocol family not supported";
-	error[EAFNOSUPPORT] = "Address family not supported by protocol family";
-	error[EADDRINUSE] = "Address already in use";
-	error[EADDRNOTAVAIL] = "Can't assign requested address";
-	error[ENETDOWN] = "Network is down";
-	error[ENETUNREACH] = "Network is unreachable";
-	error[ENETRESET] = "Network dropped connection on reset";
-	error[ECONNABORTED] = "Software caused connection abort";
-	error[ECONNRESET] = "Connection reset by peer";
-	error[ENOBUFS] = "No buffer space available";
-	error[EISCONN] = "Socket is already connected";
-	error[ENOTCONN] = "Socket is not connected";
-	error[ESHUTDOWN] = "Can't send after socket shutdown";
-	error[ETOOMANYREFS] = "Too many references: can't splice";
-	error[ETIMEDOUT] = "Operation timed out";
-	error[ECONNREFUSED] = "Connection refused";
-	error[ELOOP] = "Too many levels of symbolic links";
-	error[ENAMETOOLONG] = "File name too long";
-	error[EHOSTDOWN] = "Host is down";
-	error[EHOSTUNREACH] = "No route to host";
-	error[ENOTEMPTY] = "Directory not empty";
-	error[EPROCLIM] = "Too many processes";
-	error[EUSERS] = "Too many users";
-	error[EDQUOT] = "Disc quota exceeded";
-	error[ESTALE] = "Stale NFS file handle";
-	error[EREMOTE] = "Too many levels of remote in path";
-	error[EBADRPC] = "RPC struct is bad";
-	error[ERPCMISMATCH] = "RPC version wrong";
-	error[EPROGUNAVAIL] = "RPC prog. not avail";
-	error[EPROGMISMATCH] = "Program version wrong";
-	error[EPROCUNAVAIL] = "Bad procedure for program";
-	error[ENOLCK] = "No locks available";
-	error[ENOSYS] = "Function not implemented";
-	error[EFTYPE] = "Inappropriate file type or format";
-	error[EAUTH] = "Authentication error";
-	error[ENEEDAUTH] = "Need authenticator";
-	error[EPWROFF] = "Device power is off";
-	error[EDEVERR] = "Device error, e.g. paper out";
-	error[EOVERFLOW] = "Value too large to be stored in data type";
-	error[EBADEXEC] = "Bad executable";
-	error[EBADARCH] = "Bad CPU type in executable";
-	error[ESHLIBVERS] = "Shared library version mismatch";
-	error[EBADMACHO] = "Malformed Macho file";
-	error[ECANCELED] = "Operation canceled";
-	error[EIDRM] = "Identifier removed";
-	error[ENOMSG] = "No message of desired type";
-	error[EILSEQ] = "Illegal byte sequence";
-	error[ENOATTR] = "Attribute not found";
-	error[EBADMSG] = "Bad message";
-	error[EMULTIHOP] = "Reserved";
-	error[ENODATA] = "No message available on STREAM";
-	error[ENOLINK] = "Reserved";
-	error[ENOSR] = "No STREAM resources";
-	error[ENOSTR] = "Not a STREAM";
-	error[EPROTO] = "Protocol error";
-	error[ETIME] = "STREAM ioctl timeout";
-	error[EOPNOTSUPP] = "Operation not supported on socket";
-}
-
-func str(val int64) string {  // do it here rather than with fmt to avoid dependency
-	if val < 0 {
-		return "-" + str(-val);
-	}
-	var buf [32]byte;  // big enough for int64
-	i := len(buf)-1;
-	for val >= 10 {
-		buf[i] = byte(val%10 + '0');
-		i--;
-		val /= 10;
-	}
-	buf[i] = byte(val + '0');
-	return string(buf[i:len(buf)]);
-}
-
-func Errstr(errno int64) string {
-	if errno < 0 || errno >= int64(len(error)) {
-		return "Error " + str(errno)
-	}
-	return error[errno]
-}
diff --git a/src/lib/syscall/errstr_linux.go b/src/lib/syscall/errstr_linux.go
deleted file mode 100644
index 47b5c6462f..0000000000
--- a/src/lib/syscall/errstr_linux.go
+++ /dev/null
@@ -1,292 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package syscall
-
-const (
-	ENONE=0;
-	EPERM=1;
-	ENOENT=2;
-	ESRCH=3;
-	EINTR=4;
-	EIO=5;
-	ENXIO=6;
-	E2BIG=7;
-	ENOEXEC=8;
-	EBADF=9;
-	ECHILD=10;
-	EAGAIN=11;
-	ENOMEM=12;
-	EACCES=13;
-	EFAULT=14;
-	ENOTBLK=15;
-	EBUSY=16;
-	EEXIST=17;
-	EXDEV=18;
-	ENODEV=19;
-	ENOTDIR=20;
-	EISDIR=21;
-	EINVAL=22;
-	ENFILE=23;
-	EMFILE=24;
-	ENOTTY=25;
-	ETXTBSY=26;
-	EFBIG=27;
-	ENOSPC=28;
-	ESPIPE=29;
-	EROFS=30;
-	EMLINK=31;
-	EPIPE=32;
-	EDOM=33;
-	ERANGE=34;
-	EDEADLK=35;
-	ENAMETOOLONG=36;
-	ENOLCK=37;
-	ENOSYS=38;
-	ENOTEMPTY=39;
-	ELOOP=40;
-	ENOMSG=42;
-	EIDRM=43;
-	ECHRNG=44;
-	EL2NSYNC=45;
-	EL3HLT=46;
-	EL3RST=47;
-	ELNRNG=48;
-	EUNATCH=49;
-	ENOCSI=50;
-	EL2HLT=51;
-	EBADE=52;
-	EBADR=53;
-	EXFULL=54;
-	ENOANO=55;
-	EBADRQC=56;
-	EBADSLT=57;
-	EBFONT=59;
-	ENOSTR=60;
-	ENODATA=61;
-	ETIME=62;
-	ENOSR=63;
-	ENONET=64;
-	ENOPKG=65;
-	EREMOTE=66;
-	ENOLINK=67;
-	EADV=68;
-	ESRMNT=69;
-	ECOMM=70;
-	EPROTO=71;
-	EMULTIHOP=72;
-	EDOTDOT=73;
-	EBADMSG=74;
-	EOVERFLOW=75;
-	ENOTUNIQ=76;
-	EBADFD=77;
-	EREMCHG=78;
-	ELIBACC=79;
-	ELIBBAD=80;
-	ELIBSCN=81;
-	ELIBMAX=82;
-	ELIBEXEC=83;
-	EILSEQ=84;
-	ERESTART=85;
-	ESTRPIPE=86;
-	EUSERS=87;
-	ENOTSOCK=88;
-	EDESTADDRREQ=89;
-	EMSGSIZE=90;
-	EPROTOTYPE=91;
-	ENOPROTOOPT=92;
-	EPROTONOSUPPORT=93;
-	ESOCKTNOSUPPORT=94;
-	EOPNOTSUPP=95;
-	EPFNOSUPPORT=96;
-	EAFNOSUPPORT=97;
-	EADDRINUSE=98;
-	EADDRNOTAVAIL=99;
-	ENETDOWN=100;
-	ENETUNREACH=101;
-	ENETRESET=102;
-	ECONNABORTED=103;
-	ECONNRESET=104;
-	ENOBUFS=105;
-	EISCONN=106;
-	ENOTCONN=107;
-	ESHUTDOWN=108;
-	ETOOMANYREFS=109;
-	ETIMEDOUT=110;
-	ECONNREFUSED=111;
-	EHOSTDOWN=112;
-	EHOSTUNREACH=113;
-	EALREADY=114;
-	EINPROGRESS=115;
-	ESTALE=116;
-	EUCLEAN=117;
-	ENOTNAM=118;
-	ENAVAIL=119;
-	EISNAM=120;
-	EREMOTEIO=121;
-	EDQUOT=122;
-	ENOMEDIUM=123;
-	EMEDIUMTYPE=124;
-	ECANCELED=125;
-	ENOKEY=126;
-	EKEYEXPIRED=127;
-	EKEYREVOKED=128;
-	EKEYREJECTED=129;
-	ELAST=130;
-)
-
-var error [ELAST]string;
-
-func init(){
-	error[ENONE] = "No error";
-	error[EPERM] = "Operation not permitted";
-	error[ENOENT] = "No such file or directory";
-	error[ESRCH] = "No such process";
-	error[EINTR] = "Interrupted system call";
-	error[EIO] = "I/O error";
-	error[ENXIO] = "No such device or address";
-	error[E2BIG] = "Argument list too long";
-	error[ENOEXEC] = "Exec format error";
-	error[EBADF] = "Bad file number";
-	error[ECHILD] = "No child processes";
-	error[EAGAIN] = "Try again";
-	error[ENOMEM] = "Out of memory";
-	error[EACCES] = "Permission denied";
-	error[EFAULT] = "Bad address";
-	error[ENOTBLK] = "Block device required";
-	error[EBUSY] = "Device or resource busy";
-	error[EEXIST] = "File exists";
-	error[EXDEV] = "Cross-device link";
-	error[ENODEV] = "No such device";
-	error[ENOTDIR] = "Not a directory";
-	error[EISDIR] = "Is a directory";
-	error[EINVAL] = "Invalid argument";
-	error[ENFILE] = "File table overflow";
-	error[EMFILE] = "Too many open files";
-	error[ENOTTY] = "Not a typewriter";
-	error[ETXTBSY] = "Text file busy";
-	error[EFBIG] = "File too large";
-	error[ENOSPC] = "No space left on device";
-	error[ESPIPE] = "Illegal seek";
-	error[EROFS] = "Read-only file system";
-	error[EMLINK] = "Too many links";
-	error[EPIPE] = "Broken pipe";
-	error[EDOM] = "Math argument out of domain of func";
-	error[ERANGE] = "Math result not representable";
-	error[EDEADLK] = "Resource deadlock would occur";
-	error[ENAMETOOLONG] = "File name too long";
-	error[ENOLCK] = "No record locks available";
-	error[ENOSYS] = "Function not implemented";
-	error[ENOTEMPTY] = "Directory not empty";
-	error[ELOOP] = "Too many symbolic links encountered";
-	error[ENOMSG] = "No message of desired type";
-	error[EIDRM] = "Identifier removed";
-	error[ECHRNG] = "Channel number out of range";
-	error[EL2NSYNC] = "Level 2 not synchronized";
-	error[EL3HLT] = "Level 3 halted";
-	error[EL3RST] = "Level 3 reset";
-	error[ELNRNG] = "Link number out of range";
-	error[EUNATCH] = "Protocol driver not attached";
-	error[ENOCSI] = "No CSI structure available";
-	error[EL2HLT] = "Level 2 halted";
-	error[EBADE] = "Invalid exchange";
-	error[EBADR] = "Invalid request descriptor";
-	error[EXFULL] = "Exchange full";
-	error[ENOANO] = "No anode";
-	error[EBADRQC] = "Invalid request code";
-	error[EBADSLT] = "Invalid slot";
-	error[EBFONT] = "Bad font file format";
-	error[ENOSTR] = "Device not a stream";
-	error[ENODATA] = "No data available";
-	error[ETIME] = "Timer expired";
-	error[ENOSR] = "Out of streams resources";
-	error[ENONET] = "Machine is not on the network";
-	error[ENOPKG] = "Package not installed";
-	error[EREMOTE] = "Object is remote";
-	error[ENOLINK] = "Link has been severed";
-	error[EADV] = "Advertise error";
-	error[ESRMNT] = "Srmount error";
-	error[ECOMM] = "Communication error on send";
-	error[EPROTO] = "Protocol error";
-	error[EMULTIHOP] = "Multihop attempted";
-	error[EDOTDOT] = "RFS specific error";
-	error[EBADMSG] = "Not a data message";
-	error[EOVERFLOW] = "Value too large for defined data type";
-	error[ENOTUNIQ] = "Name not unique on network";
-	error[EBADFD] = "File descriptor in bad state";
-	error[EREMCHG] = "Remote address changed";
-	error[ELIBACC] = "Can not access a needed shared library";
-	error[ELIBBAD] = "Accessing a corrupted shared library";
-	error[ELIBSCN] = ".lib section in a.out corrupted";
-	error[ELIBMAX] = "Attempting to link in too many shared libraries";
-	error[ELIBEXEC] = "Cannot exec a shared library directly";
-	error[EILSEQ] = "Illegal byte sequence";
-	error[ERESTART] = "Interrupted system call should be restarted";
-	error[ESTRPIPE] = "Streams pipe error";
-	error[EUSERS] = "Too many users";
-	error[ENOTSOCK] = "Socket operation on non-socket";
-	error[EDESTADDRREQ] = "Destination address required";
-	error[EMSGSIZE] = "Message too long";
-	error[EPROTOTYPE] = "Protocol wrong type for socket";
-	error[ENOPROTOOPT] = "Protocol not available";
-	error[EPROTONOSUPPORT] = "Protocol not supported";
-	error[ESOCKTNOSUPPORT] = "Socket type not supported";
-	error[EOPNOTSUPP] = "Operation not supported on transport endpoint";
-	error[EPFNOSUPPORT] = "Protocol family not supported";
-	error[EAFNOSUPPORT] = "Address family not supported by protocol";
-	error[EADDRINUSE] = "Address already in use";
-	error[EADDRNOTAVAIL] = "Cannot assign requested address";
-	error[ENETDOWN] = "Network is down";
-	error[ENETUNREACH] = "Network is unreachable";
-	error[ENETRESET] = "Network dropped connection because of reset";
-	error[ECONNABORTED] = "Software caused connection abort";
-	error[ECONNRESET] = "Connection reset by peer";
-	error[ENOBUFS] = "No buffer space available";
-	error[EISCONN] = "Transport endpoint is already connected";
-	error[ENOTCONN] = "Transport endpoint is not connected";
-	error[ESHUTDOWN] = "Cannot send after transport endpoint shutdown";
-	error[ETOOMANYREFS] = "Too many references: cannot splice";
-	error[ETIMEDOUT] = "Connection timed out";
-	error[ECONNREFUSED] = "Connection refused";
-	error[EHOSTDOWN] = "Host is down";
-	error[EHOSTUNREACH] = "No route to host";
-	error[EALREADY] = "Operation already in progress";
-	error[EINPROGRESS] = "Operation now in progress";
-	error[ESTALE] = "Stale NFS file handle";
-	error[EUCLEAN] = "Structure needs cleaning";
-	error[ENOTNAM] = "Not a XENIX named type file";
-	error[ENAVAIL] = "No XENIX semaphores available";
-	error[EISNAM] = "Is a named type file";
-	error[EREMOTEIO] = "Remote I/O error";
-	error[EDQUOT] = "Quota exceeded";
-	error[ENOMEDIUM] = "No medium found";
-	error[EMEDIUMTYPE] = "Wrong medium type";
-	error[ECANCELED] = "Operation Canceled";
-	error[ENOKEY] = "Required key not available";
-	error[EKEYEXPIRED] = "Key has expired";
-	error[EKEYREVOKED] = "Key has been revoked";
-	error[EKEYREJECTED] = "Key was rejected by service";
-}
-
-func str(val int64) string {  // do it here rather than with fmt to avoid dependency
-	if val < 0 {
-		return "-" + str(-val);
-	}
-	var buf [32]byte;  // big enough for int64
-	i := len(buf)-1;
-	for val >= 10 {
-		buf[i] = byte(val%10 + '0');
-		i--;
-		val /= 10;
-	}
-	buf[i] = byte(val + '0');
-	return string(buf[i:len(buf)]);
-}
-
-func Errstr(errno int64) string {
-	if errno < 0 || errno >= int64(len(error)) {
-		return "Error " + str(errno)
-	}
-	return error[errno]
-}
diff --git a/src/lib/syscall/file_darwin.go b/src/lib/syscall/file_darwin.go
deleted file mode 100644
index 6c4eee6fbb..0000000000
--- a/src/lib/syscall/file_darwin.go
+++ /dev/null
@@ -1,186 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// File operations for Darwin
-
-package syscall
-
-import (
-	"syscall";
-	"unsafe";
-)
-
-const nameBufsize = 512
-
-func Open(name string, mode int64, perm int64) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_OPEN, int64(uintptr(unsafe.Pointer(namebuf))), mode, perm);
-	return r1, err;
-}
-
-func Creat(name string, perm int64) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_OPEN, int64(uintptr(unsafe.Pointer(namebuf))), O_CREAT|O_WRONLY|O_TRUNC, perm);
-	return r1, err;
-}
-
-func Close(fd int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_CLOSE, fd, 0, 0);
-	return r1, err;
-}
-
-func Read(fd int64, buf *byte, nbytes int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_READ, fd, int64(uintptr(unsafe.Pointer(buf))), nbytes);
-	return r1, err;
-}
-
-func Write(fd int64, buf *byte, nbytes int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_WRITE, fd, int64(uintptr(unsafe.Pointer(buf))), nbytes);
-	return r1, err;
-}
-
-func Seek(fd int64, offset int64, whence int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_LSEEK, fd, offset, whence);
-	return r1, err;
-}
-
-func Pipe(fds *[2]int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_PIPE, 0, 0, 0);
-	if r1 < 0 {
-		return r1, err;
-	}
-	fds[0] = r1;
-	fds[1] = r2;
-	return 0, 0;
-}
-
-func Stat(name string, buf *Stat_t) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_STAT64, int64(uintptr(unsafe.Pointer(namebuf))), int64(uintptr(unsafe.Pointer(buf))), 0);
-	return r1, err;
-}
-
-func Lstat(name string, buf *Stat_t) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_LSTAT64, int64(uintptr(unsafe.Pointer(namebuf))), int64(uintptr(unsafe.Pointer(buf))), 0);
-	return r1, err;
-}
-
-func Fstat(fd int64, buf *Stat_t) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_FSTAT64, fd, int64(uintptr(unsafe.Pointer(buf))), 0);
-	return r1, err;
-}
-
-func Unlink(name string) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_UNLINK, int64(uintptr(unsafe.Pointer(namebuf))), 0, 0);
-	return r1, err;
-}
-
-func Rmdir(name string) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_RMDIR, int64(uintptr(unsafe.Pointer(namebuf))), 0, 0);
-	return r1, err;
-}
-
-func Fcntl(fd, cmd, arg int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_FCNTL, fd, cmd, arg);
-	return r1, err
-}
-
-func Mkdir(name string, perm int64) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_MKDIR, int64(uintptr(unsafe.Pointer(namebuf))), perm, 0);
-	return r1, err;
-}
-
-func Dup2(fd1, fd2 int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_DUP2, fd1, fd2, 0);
-	return r1, err;
-}
-
-func Getdirentries(fd int64, buf *byte, nbytes int64, basep *int64) (ret, errno int64) {
-	r1, r2, err := Syscall6(SYS_GETDIRENTRIES64, fd, int64(uintptr(unsafe.Pointer(buf))), nbytes, int64(uintptr(unsafe.Pointer(basep))), 0, 0);
-	return r1, err;
-}
-
-func Chdir(dir string) (ret, errno int64) {
-	namebuf := StringBytePtr(dir);
-	r1, r2, err := Syscall(SYS_CHDIR, int64(uintptr(unsafe.Pointer(namebuf))), 0, 0);
-	return r1, err;
-}
-
-func Fchdir(fd int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_FCHDIR, fd, 0, 0);
-	return r1, err;
-}
-
-func Link(oldname, newname string) (ret, errno int64) {
-	oldbuf := StringBytePtr(oldname);
-	newbuf := StringBytePtr(newname);
-	r1, r2, err := Syscall(SYS_LINK, int64(uintptr(unsafe.Pointer(oldbuf))), int64(uintptr(unsafe.Pointer(newbuf))), 0);
-	return r1, err;
-}
-
-func Symlink(oldname, newname string) (ret, errno int64) {
-	oldbuf := StringBytePtr(oldname);
-	newbuf := StringBytePtr(newname);
-	r1, r2, err := Syscall(SYS_SYMLINK, int64(uintptr(unsafe.Pointer(oldbuf))), int64(uintptr(unsafe.Pointer(newbuf))), 0);
-	return r1, err;
-}
-
-func Readlink(name string, buf *byte, nbytes int64) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_READLINK, int64(uintptr(unsafe.Pointer(namebuf))), int64(uintptr(unsafe.Pointer(buf))), nbytes);
-	return r1, err;
-}
-
-func Chmod(name string, mode int64) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_CHMOD, int64(uintptr(unsafe.Pointer(namebuf))), mode, 0);
-	return r1, err;
-}
-
-func Fchmod(fd, mode int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_FCHMOD, fd, mode, 0);
-	return r1, err;
-}
-
-func Chown(name string, uid, gid int64) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_CHOWN, int64(uintptr(unsafe.Pointer(namebuf))), uid, gid);
-	return r1, err;
-}
-
-func Lchown(name string, uid, gid int64) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_LCHOWN, int64(uintptr(unsafe.Pointer(namebuf))), uid, gid);
-	return r1, err;
-}
-
-func Fchown(fd, uid, gid int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_FCHOWN, fd, uid, gid);
-	return r1, err;
-}
-
-func Truncate(name string, length int64) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_TRUNCATE, int64(uintptr(unsafe.Pointer(namebuf))), length, 0);
-	return r1, err;
-}
-
-func Ftruncate(fd, length int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_FTRUNCATE, fd, length, 0);
-	return r1, err;
-}
-
-// The const provides a compile-time constant so clients
-// can adjust to whether there is a working Getwd and avoid
-// even linking this function into the binary.  See ../os/getwd.go.
-const ImplementsGetwd = false
-
-func Getwd() (string, int64) {
-	return "", ENOTSUP;
-}
-
diff --git a/src/lib/syscall/file_linux.go b/src/lib/syscall/file_linux.go
deleted file mode 100644
index 2f8b9101f4..0000000000
--- a/src/lib/syscall/file_linux.go
+++ /dev/null
@@ -1,193 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package syscall
-
-// File operations for Linux
-
-import (
-	"syscall";
-	"unsafe";
-)
-
-const nameBufsize = 512
-
-func Open(name string, mode int64, perm int64) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_OPEN, int64(uintptr(unsafe.Pointer(namebuf))), mode, perm);
-	return r1, err;
-}
-
-func Creat(name string, perm int64) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_OPEN, int64(uintptr(unsafe.Pointer(namebuf))),  O_CREAT|O_WRONLY|O_TRUNC, perm);
-	return r1, err;
-}
-
-func Close(fd int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_CLOSE, fd, 0, 0);
-	return r1, err;
-}
-
-func Read(fd int64, buf *byte, nbytes int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_READ, fd, int64(uintptr(unsafe.Pointer(buf))), nbytes);
-	return r1, err;
-}
-
-func Write(fd int64, buf *byte, nbytes int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_WRITE, fd, int64(uintptr(unsafe.Pointer(buf))), nbytes);
-	return r1, err;
-}
-
-func Seek(fd int64, offset int64, whence int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_LSEEK, fd, offset, whence);
-	return r1, err;
-}
-
-func Pipe(fds *[2]int64) (ret, errno int64) {
-	var t [2] int32;
-	r1, r2, err := Syscall(SYS_PIPE, int64(uintptr(unsafe.Pointer(&t[0]))), 0, 0);
-	if r1 < 0 {
-		return r1, err;
-	}
-	fds[0] = int64(t[0]);
-	fds[1] = int64(t[1]);
-	return 0, 0;
-}
-
-func Stat(name string, buf *Stat_t) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_STAT, int64(uintptr(unsafe.Pointer(namebuf))), int64(uintptr(unsafe.Pointer(buf))), 0);
-	return r1, err;
-}
-
-func Lstat(name string, buf *Stat_t) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_LSTAT, int64(uintptr(unsafe.Pointer(namebuf))), int64(uintptr(unsafe.Pointer(buf))), 0);
-	return r1, err;
-}
-
-func Fstat(fd int64, buf *Stat_t) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_FSTAT, fd, int64(uintptr(unsafe.Pointer(buf))), 0);
-	return r1, err;
-}
-
-func Unlink(name string) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_UNLINK, int64(uintptr(unsafe.Pointer(namebuf))), 0, 0);
-	return r1, err;
-}
-
-func Rmdir(name string) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_RMDIR, int64(uintptr(unsafe.Pointer(namebuf))), 0, 0);
-	return r1, err;
-}
-
-func Fcntl(fd, cmd, arg int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_FCNTL, fd, cmd, arg);
-	return r1, err
-}
-
-func Mkdir(name string, perm int64) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_MKDIR, int64(uintptr(unsafe.Pointer(namebuf))), perm, 0);
-	return r1, err;
-}
-
-func Dup2(fd1, fd2 int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_DUP2, fd1, fd2, 0);
-	return r1, err;
-}
-
-func Getdents(fd int64, buf *Dirent, nbytes int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_GETDENTS64, fd, int64(uintptr(unsafe.Pointer(buf))), nbytes);
-	return r1, err;
-}
-
-func Chdir(dir string) (ret, errno int64) {
-	namebuf := StringBytePtr(dir);
-	r1, r2, err := Syscall(SYS_CHDIR, int64(uintptr(unsafe.Pointer(namebuf))), 0, 0);
-	return r1, err;
-}
-
-func Fchdir(fd int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_FCHDIR, fd, 0, 0);
-	return r1, err;
-}
-
-const ImplementsGetwd = true
-
-func Getwd() (ret string, errno int64) {
-	var buf [PathMax]byte;
-	r1, r2, err := Syscall(SYS_GETCWD, int64(uintptr(unsafe.Pointer(&buf))), int64(len(buf)), 0);
-	if err != 0 {
-		return "", err;
-	}
-	// SYS_GETCWD returns the number of bytes written to buf, including the NUL.
-	if r1 < 1 || r1 > int64(len(buf)) || buf[r1-1] != 0 {
-		return "", EINVAL;
-	}
-	return string(buf[0:r1-1]), 0
-}
-
-func Link(oldpath, newpath string) (ret, errno int64) {
-	oldbuf := StringBytePtr(oldpath);
-	newbuf := StringBytePtr(newpath);
-	r1, r2, err := Syscall(SYS_LINK, int64(uintptr(unsafe.Pointer(oldbuf))), int64(uintptr(unsafe.Pointer(newbuf))), 0);
-	return r1, err;
-}
-
-func Symlink(oldpath, newpath string) (ret, errno int64) {
-	oldbuf := StringBytePtr(oldpath);
-	newbuf := StringBytePtr(newpath);
-	r1, r2, err := Syscall(SYS_SYMLINK, int64(uintptr(unsafe.Pointer(oldbuf))), int64(uintptr(unsafe.Pointer(newbuf))), 0);
-	return r1, err;
-}
-
-func Readlink(path string, buf *byte, nbytes int64) (ret, errno int64) {
-	pathbuf := StringBytePtr(path);
-	r1, r2, err := Syscall(SYS_READLINK, int64(uintptr(unsafe.Pointer(pathbuf))), int64(uintptr(unsafe.Pointer(buf))), nbytes);
-	return r1, err;
-}
-
-func Chmod(name string, mode int64) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_CHMOD, int64(uintptr(unsafe.Pointer(namebuf))), mode, 0);
-	return r1, err;
-}
-
-func Fchmod(fd, mode int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_FCHMOD, fd, mode, 0);
-	return r1, err;
-}
-
-func Chown(name string, uid, gid int64) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_CHOWN, int64(uintptr(unsafe.Pointer(namebuf))), uid, gid);
-	return r1, err;
-}
-
-func Lchown(name string, uid, gid int64) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_LCHOWN, int64(uintptr(unsafe.Pointer(namebuf))), uid, gid);
-	return r1, err;
-}
-
-func Fchown(fd, uid, gid int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_FCHOWN, fd, uid, gid);
-	return r1, err;
-}
-
-func Truncate(name string, length int64) (ret, errno int64) {
-	namebuf := StringBytePtr(name);
-	r1, r2, err := Syscall(SYS_TRUNCATE, int64(uintptr(unsafe.Pointer(namebuf))), length, 0);
-	return r1, err;
-}
-
-func Ftruncate(fd, length int64) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_FTRUNCATE, fd, length, 0);
-	return r1, err;
-}
-
diff --git a/src/lib/syscall/mkdarwin b/src/lib/syscall/mkdarwin
deleted file mode 100755
index 6536ec120c..0000000000
--- a/src/lib/syscall/mkdarwin
+++ /dev/null
@@ -1,34 +0,0 @@
-# Copyright 2009 The Go Authors.  All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-my $command = "mkdarwin " . join(' ', @ARGV);
-
-print <<EOF;
-// Generated by mkdarwin; DO NOT EDIT.
-// $command
-
-package syscall
-
-const (
-EOF
-
-while(<>){
-	if(/^([0-9]+)\s+ALL\s+({ \S+\s+(\w+).*})/){
-		my $num = $1;
-		my $proto = $2;
-		my $name = "SYS_$3";
-		$name =~ y/a-z/A-Z/;
-
-		# There are multiple entries for nosys(), so comment them out.
-		if($name eq "SYS_NOSYS"){
-			$name = "// $name";
-		}
-
-		print "	$name = $num;  // $proto\n";
-	}
-}
-
-print <<EOF;
-)
-EOF
diff --git a/src/lib/syscall/mksignal b/src/lib/syscall/mksignal
deleted file mode 100755
index 4ee28a2a05..0000000000
--- a/src/lib/syscall/mksignal
+++ /dev/null
@@ -1,26 +0,0 @@
-# Copyright 2009 The Go Authors.  All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-my $command = "mksignal ". join(' ', @ARGV);
-
-print <<EOF;
-// Generated by mksignal; DO NOT EDIT.
-// $command
-
-package syscall
-
-const(
-EOF
-
-while(<>){
-	next if /SIGSTKSZ/;
-	next if /SIGEV_/;
-	if(/^#define\s+(SIG[^_\s]\w*)\s+([0-9]+)/){
-		print "	$1 = $2;\n";
-	}
-}
-
-print <<EOF;
-)
-EOF
diff --git a/src/lib/syscall/mklinux b/src/lib/syscall/mksysnum_linux
similarity index 100%
rename from src/lib/syscall/mklinux
rename to src/lib/syscall/mksysnum_linux
diff --git a/src/lib/syscall/proc_darwin.go b/src/lib/syscall/proc_darwin.go
deleted file mode 100644
index de8d604527..0000000000
--- a/src/lib/syscall/proc_darwin.go
+++ /dev/null
@@ -1,20 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package syscall
-
-// Process operations for Darwin
-// TODO:
-// - getrusage
-// - getrlimit, setrlimit
-
-import (
-	"syscall";
-	"unsafe";
-)
-
-func Getrusage(who int64, usage *Rusage) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_GETRUSAGE, who, int64(uintptr(unsafe.Pointer(usage))), 0);
-	return r1, err
-}
diff --git a/src/lib/syscall/proc_linux.go b/src/lib/syscall/proc_linux.go
deleted file mode 100644
index e4e3760813..0000000000
--- a/src/lib/syscall/proc_linux.go
+++ /dev/null
@@ -1,19 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package syscall
-
-// Process operations for Linux
-// TODO:
-// - getrlimit, setrlimit
-
-import (
-	"syscall";
-	"unsafe";
-)
-
-func Getrusage(who int64, usage *Rusage) (ret, errno int64) {
-	r1, r2, err := Syscall(SYS_GETRUSAGE, who, int64(uintptr(unsafe.Pointer(usage))), 0);
-	return r1, err
-}
diff --git a/src/lib/syscall/signal_amd64_darwin.go b/src/lib/syscall/signal_amd64_darwin.go
deleted file mode 100644
index 3d96b3fdc3..0000000000
--- a/src/lib/syscall/signal_amd64_darwin.go
+++ /dev/null
@@ -1,43 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Generated by mksignal; DO NOT EDIT.
-// mksignal /usr/include/sys/signal.h
-
-package syscall
-
-const(
-	SIGHUP = 1;
-	SIGINT = 2;
-	SIGQUIT = 3;
-	SIGILL = 4;
-	SIGTRAP = 5;
-	SIGABRT = 6;
-	SIGPOLL = 7;
-	SIGEMT = 7;
-	SIGFPE = 8;
-	SIGKILL = 9;
-	SIGBUS = 10;
-	SIGSEGV = 11;
-	SIGSYS = 12;
-	SIGPIPE = 13;
-	SIGALRM = 14;
-	SIGTERM = 15;
-	SIGURG = 16;
-	SIGSTOP = 17;
-	SIGTSTP = 18;
-	SIGCONT = 19;
-	SIGCHLD = 20;
-	SIGTTIN = 21;
-	SIGTTOU = 22;
-	SIGIO = 23;
-	SIGXCPU = 24;
-	SIGXFSZ = 25;
-	SIGVTALRM = 26;
-	SIGPROF = 27;
-	SIGWINCH = 28;
-	SIGINFO = 29;
-	SIGUSR1 = 30;
-	SIGUSR2 = 31;
-)
diff --git a/src/lib/syscall/signal_amd64_linux.go b/src/lib/syscall/signal_amd64_linux.go
deleted file mode 100644
index 500666a8f3..0000000000
--- a/src/lib/syscall/signal_amd64_linux.go
+++ /dev/null
@@ -1,46 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Generated by mksignal; DO NOT EDIT.
-// mksignal /usr/include/asm/signal.h
-
-package syscall
-
-const(
-	SIGHUP = 1;
-	SIGINT = 2;
-	SIGQUIT = 3;
-	SIGILL = 4;
-	SIGTRAP = 5;
-	SIGABRT = 6;
-	SIGIOT = 6;
-	SIGBUS = 7;
-	SIGFPE = 8;
-	SIGKILL = 9;
-	SIGUSR1 = 10;
-	SIGSEGV = 11;
-	SIGUSR2 = 12;
-	SIGPIPE = 13;
-	SIGALRM = 14;
-	SIGTERM = 15;
-	SIGSTKFLT = 16;
-	SIGCHLD = 17;
-	SIGCONT = 18;
-	SIGSTOP = 19;
-	SIGTSTP = 20;
-	SIGTTIN = 21;
-	SIGTTOU = 22;
-	SIGURG = 23;
-	SIGXCPU = 24;
-	SIGXFSZ = 25;
-	SIGVTALRM = 26;
-	SIGPROF = 27;
-	SIGWINCH = 28;
-	SIGIO = 29;
-	SIGLOST = 29;
-	SIGPWR = 30;
-	SIGSYS = 31;
-	SIGUNUSED = 31;
-	SIGRTMIN = 32;
-)
diff --git a/src/lib/syscall/socket_darwin.go b/src/lib/syscall/socket_darwin.go
deleted file mode 100644
index 59ca503109..0000000000
--- a/src/lib/syscall/socket_darwin.go
+++ /dev/null
@@ -1,114 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Low-level socket interface.
-// Only for implementing net package.
-// DO NOT USE DIRECTLY.
-
-package syscall
-import (
-	"syscall";
-	"unsafe";
-)
-
-// For testing: clients can set this flag to force
-// creation of IPv6 sockets to return EAFNOSUPPORT.
-var SocketDisableIPv6 bool
-
-func Socket(domain, proto, typ int64) (ret int64, err int64) {
-	if domain == AF_INET6 && SocketDisableIPv6 {
-		return -1, EAFNOSUPPORT
-	}
-	r1, r2, e := Syscall(SYS_SOCKET, domain, proto, typ);
-	return r1, e
-}
-
-func Connect(fd int64, sa *Sockaddr) (ret int64, err int64) {
-	r1, r2, e := Syscall(SYS_CONNECT, fd, int64(uintptr(unsafe.Pointer(sa))), int64(sa.Len));
-	return r1, e
-}
-
-func Bind(fd int64, sa *Sockaddr) (ret int64, err int64) {
-	r1, r2, e := Syscall(SYS_BIND, fd, int64(uintptr(unsafe.Pointer(sa))), int64(sa.Len));
-	return r1, e
-}
-
-func Listen(fd, n int64) (ret int64, err int64) {
-	r1, r2, e := Syscall(SYS_LISTEN, fd, n, 0);
-	return r1, e
-}
-
-func Accept(fd int64, sa *Sockaddr) (ret int64, err int64) {
-	var n int32 = SizeofSockaddr;
-	r1, r2, e := Syscall(SYS_ACCEPT, fd, int64(uintptr(unsafe.Pointer(sa))), int64(uintptr(unsafe.Pointer(&n))));
-	return r1, e
-}
-
-func Setsockopt(fd, level, opt, valueptr, length int64) (ret int64, err int64) {
-	if fd < 0 {
-		return -1, EINVAL
-	}
-	r1, r2, e := Syscall6(SYS_SETSOCKOPT, fd, level, opt, valueptr, length, 0);
-	return r1, e
-}
-
-func Setsockopt_int(fd, level, opt int64, value int) int64 {
-	var n int32 = int32(opt);
-	r1, e := Setsockopt(fd, level, opt, int64(uintptr(unsafe.Pointer(&n))), 4);
-	return e
-}
-
-func Setsockopt_tv(fd, level, opt, nsec int64) int64 {
-	var tv Timeval;
-	nsec += 999;
-	tv.Sec = int64(nsec/1000000000);
-	tv.Usec = uint32(nsec%1000000000);
-	r1, e := Setsockopt(fd, level, opt, int64(uintptr(unsafe.Pointer(&tv))), 4);
-	return e
-}
-
-func Setsockopt_linger(fd, level, opt int64, sec int) int64 {
-	var l Linger;
-	if sec >= 0 {
-		l.Yes = 1;
-		l.Sec = int32(sec);
-	} else {
-		l.Yes = 0;
-		l.Sec = 0;
-	}
-	r1, err := Setsockopt(fd, level, opt, int64(uintptr(unsafe.Pointer(&l))), 8);
-	return err
-}
-
-/*
-func Getsockopt(fd, level, opt, valueptr, lenptr int64) (ret int64, errno int64) {
-	r1, r2, err := Syscall6(SYS_GETSOCKOPT, fd, level, opt, valueptr, lenptr, 0);
-	return r1, err;
-}
-*/
-
-func Kqueue() (ret int64, errno int64) {
-	r1, r2, err := Syscall(SYS_KQUEUE, 0, 0, 0);
-	return r1, err
-}
-
-func Kevent(kq int64, changes, events []Kevent_t, timeout *Timespec) (ret int64, errno int64) {
-	var nchange, changeptr, nevent, eventptr int64;
-	nchange = 0;
-	changeptr = 0;
-	nevent = 0;
-	eventptr = 0;
-	if len(changes) > 0 {
-		changeptr = int64(uintptr(unsafe.Pointer(&changes[0])));
-		nchange = int64(len(changes))
-	}
-	if len(events) > 0 {
-		eventptr = int64(uintptr(unsafe.Pointer(&events[0])));
-		nevent = int64(len(events))
-	}
-	r1, r2, err := Syscall6(SYS_KEVENT, kq, changeptr, nchange,
-		eventptr, nevent, int64(uintptr(unsafe.Pointer(timeout))));
-	return r1, err
-}
-
diff --git a/src/lib/syscall/socket_linux.go b/src/lib/syscall/socket_linux.go
deleted file mode 100644
index f08fcca7ba..0000000000
--- a/src/lib/syscall/socket_linux.go
+++ /dev/null
@@ -1,123 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Low-level socket interface.
-// Only for implementing net package.
-// DO NOT USE DIRECTLY.
-
-package syscall
-import (
-	"syscall";
-	"unsafe";
-)
-
-// For testing: clients can set this flag to force
-// creation of IPv6 sockets to return EAFNOSUPPORT.
-var SocketDisableIPv6 bool
-
-func saLen(s *Sockaddr) int64 {
-	switch s.Family {
-	case AF_UNIX:
-		sa := (*SockaddrUnix)(unsafe.Pointer(s));
-		return sa.Length;
-	case AF_INET:
-		return SizeofSockaddrInet4;
-	case AF_INET6:
-		return SizeofSockaddrInet6
-	}
-	return 0
-}
-
-func Socket(domain, proto, typ int64) (ret int64, err int64) {
-	if domain == AF_INET6 && SocketDisableIPv6 {
-		return -1, EAFNOSUPPORT
-	}
-	r1, r2, e := Syscall(SYS_SOCKET, domain, proto, typ);
-	return r1, e
-}
-
-func Connect(fd int64, sa *Sockaddr) (ret int64, err int64) {
-	r1, r2, e := Syscall(SYS_CONNECT, fd, int64(uintptr(unsafe.Pointer(sa))), saLen(sa));
-	return r1, e
-}
-
-func Bind(fd int64, sa *Sockaddr) (ret int64, err int64) {
-	r1, r2, e := Syscall(SYS_BIND, fd, int64(uintptr(unsafe.Pointer(sa))), saLen(sa));
-	return r1, e
-}
-
-func Listen(fd, n int64) (ret int64, err int64) {
-	r1, r2, e := Syscall(SYS_LISTEN, fd, n, 0);
-	return r1, e
-}
-
-func Accept(fd int64, sa *Sockaddr) (ret int64, err int64) {
-	var n int32 = SizeofSockaddr;
-	r1, r2, e := Syscall(SYS_ACCEPT, fd, int64(uintptr(unsafe.Pointer(sa))), int64(uintptr(unsafe.Pointer(&n))));
-	return r1, e
-}
-
-func Setsockopt(fd, level, opt, valueptr, length int64) (ret int64, err int64) {
-	if fd < 0 {
-		return -1, EINVAL
-	}
-	r1, r2, e := Syscall6(SYS_SETSOCKOPT, fd, level, opt, valueptr, length, 0);
-	return r1, e
-}
-
-func Setsockopt_int(fd, level, opt int64, value int) int64 {
-	n := int32(opt);
-	r1, e := Setsockopt(fd, level, opt, int64(uintptr(unsafe.Pointer(&n))), 4);
-	return e
-}
-
-func Setsockopt_tv(fd, level, opt, nsec int64) int64 {
-	var tv Timeval;
-	nsec += 999;
-	tv.Sec = int64(nsec/1000000000);
-	tv.Usec = uint64(nsec%1000000000);
-	r1, e := Setsockopt(fd, level, opt, int64(uintptr(unsafe.Pointer(&tv))), 4);
-	return e
-}
-
-func Setsockopt_linger(fd, level, opt int64, sec int) int64 {
-	var l Linger;
-	if sec >= 0 {
-		l.Yes = 1;
-		l.Sec = int32(sec)
-	} else {
-		l.Yes = 0;
-		l.Sec = 0
-	}
-	r1, err := Setsockopt(fd, level, opt, int64(uintptr(unsafe.Pointer(&l))), 8);
-	return err
-}
-
-/*
-func getsockopt(fd, level, opt, valueptr, lenptr int64) (ret int64, errno int64) {
-	r1, r2, err := Syscall6(GETSOCKOPT, fd, level, opt, valueptr, lenptr, 0);
-	return r1, err;
-}
-*/
-
-func Epoll_create(size int64) (ret int64, errno int64) {
-	r1, r2, err := syscall.Syscall(SYS_EPOLL_CREATE, size, 0, 0);
-	return r1, err
-}
-
-func Epoll_ctl(epfd, op, fd int64, ev *EpollEvent) int64 {
-	r1, r2, err := syscall.Syscall6(SYS_EPOLL_CTL, epfd, op, fd, int64(uintptr(unsafe.Pointer(ev))), 0, 0);
-	return err
-}
-
-func Epoll_wait(epfd int64, ev []EpollEvent, msec int64) (ret int64, err int64) {
-	var evptr, nev int64;
-	if ev != nil && len(ev) > 0 {
-		nev = int64(len(ev));
-		evptr = int64(uintptr(unsafe.Pointer(&ev[0])))
-	}
-	r1, r2, err1 := syscall.Syscall6(SYS_EPOLL_WAIT, epfd, evptr, nev, msec, 0, 0);
-	return r1, err1
-}
-
diff --git a/src/lib/syscall/time_amd64_darwin.go b/src/lib/syscall/time_amd64_darwin.go
deleted file mode 100644
index 8253171cac..0000000000
--- a/src/lib/syscall/time_amd64_darwin.go
+++ /dev/null
@@ -1,24 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package syscall
-
-import syscall "syscall"
-
-func Gettimeofday() (sec, nsec, errno int64) {
-	// The "1" in the call is the timeval pointer, which must be
-	// non-zero but is otherwise unused.  The results
-	// are returned in r1, r2.
-	r1, r2, err := Syscall(SYS_GETTIMEOFDAY, 1, 0, 0);
-	if err != 0 {
-		return 0, 0, err
-	}
-	return r1, r2*1000, 0
-}
-
-func Nstotimeval(ns int64, tv *Timeval) {
-	ns += 999;	// round up
-	tv.Sec = int64(ns/1000000000);
-	tv.Usec = uint32(ns%1000000000 / 1000);
-}
diff --git a/src/lib/syscall/time_amd64_linux.go b/src/lib/syscall/time_amd64_linux.go
deleted file mode 100644
index 67fc51231b..0000000000
--- a/src/lib/syscall/time_amd64_linux.go
+++ /dev/null
@@ -1,25 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package syscall
-
-import (
-	"syscall";
-	"unsafe";
-)
-
-func Gettimeofday() (sec, nsec, errno int64) {
-	var tv Timeval;
-	r1, r2, e := Syscall(SYS_GETTIMEOFDAY, int64(uintptr(unsafe.Pointer(&tv))), 0, 0);
-	if e != 0 {
-		return 0, 0, e
-	}
-	return int64(tv.Sec), int64(tv.Usec*1000), 0
-}
-
-func Nstotimeval(ns int64, tv *Timeval) {
-	ns += 999;	// round up
-	tv.Sec = int64(ns/1000000000);
-	tv.Usec = uint64(ns%1000000000 / 1000);
-}
diff --git a/src/lib/syscall/types_amd64_darwin.go b/src/lib/syscall/types_amd64_darwin.go
deleted file mode 100644
index 69a9a85f0d..0000000000
--- a/src/lib/syscall/types_amd64_darwin.go
+++ /dev/null
@@ -1,317 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Types and defined constants.
-// Should be automatically generated, but is not.
-
-package syscall
-
-import "syscall"
-
-const OS = "darwin"
-
-// Time
-
-type Timespec struct {
-	Sec	int64;
-	Nsec	uint64;
-}
-
-type Timeval struct {
-	Sec	int64;
-	Usec	uint32;
-}
-
-
-// Processes
-
-type Rusage struct {
-	Utime	Timeval;
-	Stime	Timeval;
-	Maxrss	int64;
-	Ixrss	int64;
-	Idrss	int64;
-	Isrss	int64;
-	Minflt	int64;
-	Majflt	int64;
-	Nswap	int64;
-	Inblock	int64;
-	Oublock	int64;
-	Msgsnd	int64;
-	Msgrcv	int64;
-	Nsignals	int64;
-	Nvcsw	int64;
-	Nivcsw	int64;
-}
-
-
-// Files
-
-const (
-	O_RDONLY = 0x0;
-	O_WRONLY = 0x1;
-	O_RDWR = 0x2;
-	O_APPEND = 0x8;
-	O_ASYNC = 0x40;
-	O_CREAT = 0x200;
-	O_NOCTTY = 0x20000;
-	O_NONBLOCK = 0x4;
-	O_NDELAY = O_NONBLOCK;
-	O_SYNC = 0x80;
-	O_TRUNC = 0x400;
-	O_CLOEXEC = 0;  // not supported
-
-	F_GETFD = 1;
-	F_SETFD = 2;
-
-	F_GETFL = 3;
-	F_SETFL = 4;
-
-	FD_CLOEXEC = 1;
-
-	NAME_MAX = 255;
-)
-
-// Dir.Mode bits
-const (
-	S_IFMT = 0170000;	      /* type of file */
-		S_IFIFO  = 0010000;  /* named pipe (fifo) */
-		S_IFCHR  = 0020000;  /* character special */
-		S_IFDIR  = 0040000;  /* directory */
-		S_IFBLK  = 0060000;  /* block special */
-		S_IFREG  = 0100000;  /* regular */
-		S_IFLNK  = 0120000;  /* symbolic link */
-		S_IFSOCK = 0140000;  /* socket */
-		S_IFWHT  = 0160000;  /* whiteout */
-	S_ISUID = 0004000;  /* set user id on execution */
-	S_ISGID = 0002000;  /* set group id on execution */
-	S_ISVTX = 0001000;  /* save swapped text even after use */
-	S_IRUSR = 0000400;  /* read permission, owner */
-	S_IWUSR = 0000200;  /* write permission, owner */
-	S_IXUSR = 0000100;  /* execute/search permission, owner */
-)
-
-type Stat_t struct {
-	Dev	uint32;
-	Mode	uint16;
-	Nlink	uint16;
-	Ino	uint64;
-	Uid	uint32;
-	Gid	uint32;
-	Rdev	uint32;
-	Pad1	uint32;
-	Atime	Timespec;
-	Mtime	Timespec;
-	Ctime	Timespec;
-	Birthtime	Timespec;
-	Size	uint64;
-	Blocks	uint64;
-	Blksize	uint32;
-	Flags	uint32;
-	Gen	uint32;
-	Lspare	uint32;
-	Qspare	[2]uint64;
-}
-
-type Dirent struct {
-	Ino	uint64;
-	Off	uint64;
-	Reclen	uint16;
-	Namlen	uint16;
-	Type	uint8;
-	Name	[NAME_MAX+1]byte;
-}
-
-// Sockets
-
-const (
-	AF_UNIX = 1;
-	AF_INET = 2;
-	AF_DATAKIT = 9;
-	AF_INET6 = 30;
-
-	SOCK_STREAM = 1;
-	SOCK_DGRAM = 2;
-	SOCK_RAW = 3;
-	SOCK_RDM = 4;
-	SOCK_SEQPACKET = 5;
-
-	SOL_SOCKET = 0xffff;
-
-	SO_REUSEADDR = 0x0004;
-	SO_KEEPALIVE = 0x0008;
-	SO_DONTROUTE = 0x0010;
-	SO_BROADCAST = 0x0020;
-	SO_USELOOPBACK = 0x0040;
-	SO_LINGER = 0x1080;
-	SO_REUSEPORT = 0x0200;
-	SO_SNDBUF = 0x1001;
-	SO_RCVBUF = 0x1002;
-	SO_SNDTIMEO = 0x1005;
-	SO_RCVTIMEO = 0x1006;
-	SO_NOSIGPIPE = 0x1022;
-
-	IPPROTO_TCP = 6;
-	IPPROTO_UDP = 17;
-
-	TCP_NODELAY = 0x01;
-
-	SOMAXCONN = 128;
-)
-
-type SockaddrUnix struct {
-	Len	byte;
-	Family	byte;
-	Path	[104]byte
-}
-const SizeofSockaddrUnix = 106
-
-type SockaddrInet4 struct {
-	Len	byte;
-	Family	byte;
-	Port	[2]byte;
-	Addr	[4]byte;
-	Zero	[8]byte
-}
-const SizeofSockaddrInet4 = 16
-
-type SockaddrInet6 struct {
-	Len	byte;
-	Family	byte;
-	Port	[2]byte;
-	Flowinfo	[4]byte;
-	Addr	[16]byte;
-	Scopeid	[4]byte;
-}
-const SizeofSockaddrInet6 = 28
-
-type Sockaddr struct {
-	Len	byte;
-	Family	byte;
-	Opaque	[126]byte
-}
-const SizeofSockaddr = 128
-
-type Linger struct {
-	Yes int32;
-	Sec int32;
-}
-
-
-// Events (kqueue, kevent)
-
-const (
-	// filters
-	EVFILT_READ = -1;
-	EVFILT_WRITE = -2;
-	EVFILT_AIO = -3;
-	EVFILT_VNODE = -4;
-	EVFILT_PROC = -5;
-	EVFILT_SIGNAL = -6;
-	EVFILT_TIMER = -7;
-	EVFILT_MACHPORT = -8;
-	EVFILT_FS = -9;
-
-	EVFILT_SYSCOUNT = 9;
-
-	// actions
-	EV_ADD = 0x0001;
-	EV_DELETE = 0x0002;
-	EV_DISABLE = 0x0008;
-	EV_RECEIPT = 0x0040;
-
-	// flags
-	EV_ONESHOT = 0x0010;
-	EV_CLEAR = 0x0020;
-//	EV_RECEIPT = 0x40;
-	EV_SYSFLAGS = 0xF000;
-	EV_FLAG0 = 0x1000;
-	EV_FLAG1 = 0x2000;
-
-	// returned values
-	EV_EOF = 0x8000;
-	EV_ERROR = 0x4000
-)
-
-type Kevent_t struct {
-	Ident int64;
-	Filter int16;
-	Flags uint16;
-	Fflags uint32;
-	Data int64;
-	Udata int64;
-}
-
-
-// Wait status.
-// See /usr/include/bits/waitstatus.h
-
-const (
-	WNOHANG = 1;
-	WUNTRACED = 2;
-	WEXITED = 4;
-	WSTOPPED = 8;
-	WCONTINUED = 0x10;
-	WNOWAIT = 0x20;
-)
-
-type WaitStatus uint32;
-
-// Wait status is 7 bits at bottom, either 0 (exited),
-// 0x7F (stopped), or a signal number that caused an exit.
-// The 0x80 bit is whether there was a core dump.
-// An extra number (exit code, signal causing a stop)
-// is in the high bits.
-
-const (
-	mask = 0x7F;
-	core = 0x80;
-	shift = 8;
-
-	exited = 0;
-	stopped = 0x7F;
-)
-
-func (w WaitStatus) Exited() bool {
-	return w&mask == exited;
-}
-
-func (w WaitStatus) ExitStatus() int {
-	if w&mask != exited {
-		return -1;
-	}
-	return int(w >> shift);
-}
-
-func (w WaitStatus) Signaled() bool {
-	return w&mask != stopped && w&mask != 0;
-}
-
-func (w WaitStatus) Signal() int {
-	sig := int(w & mask);
-	if sig == stopped || sig == 0 {
-		return -1;
-	}
-	return sig;
-}
-
-func (w WaitStatus) CoreDump() bool {
-	return w.Signaled() && w&core != 0;
-}
-
-func (w WaitStatus) Stopped() bool {
-	return w&mask == stopped && w>>shift != SIGSTOP;
-}
-
-func (w WaitStatus) Continued() bool {
-	return w&mask == stopped && w>>shift == SIGSTOP;
-}
-
-func (w WaitStatus) StopSignal() int {
-	if !w.Stopped() {
-		return -1;
-	}
-	return int(w >> shift) & 0xFF;
-}
-
diff --git a/src/lib/syscall/types_amd64_linux.go b/src/lib/syscall/types_amd64_linux.go
deleted file mode 100644
index 218cf769e4..0000000000
--- a/src/lib/syscall/types_amd64_linux.go
+++ /dev/null
@@ -1,314 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Types and defined constants.
-// Should be automatically generated, but is not.
-
-package syscall
-
-import "syscall"
-
-const OS = "linux"
-
-const PathMax = 4096
-
-// Time
-
-type Timespec struct {
-	Sec	int64;
-	Nsec	uint64;
-}
-
-type Timeval struct {
-	Sec	int64;
-	Usec	uint64;
-}
-
-
-// Processes
-
-const (
-	RUSAGE_SELF = 0;
-	RUSAGE_CHILDREN = -1;
-)
-
-type Rusage struct {
-	Utime	Timeval;
-	Stime	Timeval;
-	Maxrss	int64;
-	Ixrss	int64;
-	Idrss	int64;
-	Isrss	int64;
-	Minflt	int64;
-	Majflt	int64;
-	Nswap	int64;
-	Inblock	int64;
-	Oublock	int64;
-	Msgsnd	int64;
-	Msgrcv	int64;
-	Nsignals	int64;
-	Nvcsw	int64;
-	Nivcsw	int64;
-}
-
-
-// Files
-
-const (
-	O_RDONLY = 0x0;
-	O_WRONLY = 0x1;
-	O_RDWR = 0x2;
-	O_APPEND = 0x400;
-	O_ASYNC = 0x2000;
-	O_CREAT = 0x40;
-	O_NOCTTY = 0x100;
-	O_NONBLOCK = 0x800;
-	O_NDELAY = O_NONBLOCK;
-	O_SYNC = 0x1000;
-	O_TRUNC = 0x200;
-	O_CLOEXEC = 0x80000;
-
-	F_GETFD = 1;
-	F_SETFD = 2;
-
-	F_GETFL = 3;
-	F_SETFL = 4;
-
-	FD_CLOEXEC = 1;
-
-	NAME_MAX = 255;
-)
-
-// Dir.Mode bits
-const (
-	S_IFMT = 0170000;	      /* type of file */
-		S_IFIFO  = 0010000;  /* named pipe (fifo) */
-		S_IFCHR  = 0020000;  /* character special */
-		S_IFDIR  = 0040000;  /* directory */
-		S_IFBLK  = 0060000;  /* block special */
-		S_IFREG  = 0100000;  /* regular */
-		S_IFLNK  = 0120000;  /* symbolic link */
-		S_IFSOCK = 0140000;  /* socket */
-	S_ISUID = 0004000;  /* set user id on execution */
-	S_ISGID = 0002000;  /* set group id on execution */
-	S_ISVTX = 0001000;  /* save swapped text even after use */
-	S_IRUSR = 0000400;  /* read permission, owner */
-	S_IWUSR = 0000200;  /* write permission, owner */
-	S_IXUSR = 0000100;  /* execute/search permission, owner */
-)
-
-type Stat_t struct {
-	Dev	uint64;
-	Ino	uint64;
-	Nlink	uint64;
-	Mode	uint32;
-	Uid	uint32;
-	Gid	uint32;
-	_pad0	uint32;
-	Rdev	uint64;
-	Size	int64;
-	Blksize	int64;
-	Blocks	int64;
-	Atime	Timespec;
-	Mtime	Timespec;
-	Ctime	Timespec;
-	_unused	[3]int64
-}
-
-type Dirent struct {
-	Ino	uint64;
-	Off	uint64;
-	Reclen	uint16;
-	Type	uint8;
-	Name	[NAME_MAX+1]byte;
-}
-
-// Sockets
-
-const (
-	AF_UNIX = 1;
-	AF_INET = 2;
-	AF_INET6 = 10;
-
-	SOCK_STREAM = 1;
-	SOCK_DGRAM = 2;
-	SOCK_RAW = 3;
-	SOCK_RDM = 4;
-	SOCK_SEQPACKET = 5;
-
-	SOL_SOCKET = 1;
-
-	SO_DEBUG = 1;
-	SO_REUSEADDR = 2;
-	SO_TYPE = 3;
-	SO_ERROR = 4;
-	SO_DONTROUTE = 5;
-	SO_BROADCAST = 6;
-	SO_SNDBUF = 7;
-	SO_RCVBUF = 8;
-	SO_SNDBUFFORCE = 32;
-	SO_RCVBUFFORCE = 33;
-	SO_KEEPALIVE = 9;
-	SO_OOBINLINE = 10;
-	SO_NO_CHECK = 11;
-	SO_PRIORITY = 12;
-	SO_LINGER = 13;
-	SO_BSDCOMPAT = 14;
-	SO_PASSCRED = 16;
-	SO_PEERCRED = 17;
-	SO_RCVLOWAT = 18;
-	SO_SNDLOWAT = 19;
-	SO_RCVTIMEO = 20;
-	SO_SNDTIMEO = 21;
-	SO_BINDTODEVICE = 25;
-
-	IPPROTO_TCP = 6;
-	IPPROTO_UDP = 17;
-
-	TCP_NODELAY = 0x01;
-
-	SOMAXCONN = 128;
-)
-
-type SockaddrUnix struct {
-	Family	uint16;
-	Path	[108]byte;
-	Length	int64;	// Not part of the kernel structure; used internally
-}
-const SizeofSockaddrUnix = 110
-
-type SockaddrInet4 struct {
-	Family	uint16;
-	Port	[2]byte;
-	Addr	[4]byte;
-	Zero	[8]byte
-}
-const SizeofSockaddrInet4 = 16
-
-type SockaddrInet6 struct {
-	Family	uint16;
-	Port	[2]byte;
-	Flowinfo	[4]byte;
-	Addr	[16]byte;
-	Scopeid	[4]byte;
-}
-const SizeofSockaddrInet6 = 28
-
-type Sockaddr struct {
-	Family	uint16;
-	Opaque	[126]byte
-}
-const SizeofSockaddr = 128
-
-type Linger struct {
-	Yes int32;
-	Sec int32;
-}
-
-
-// Events (epoll)
-
-const (
-	// EpollEvent.events
-	EPOLLIN = 0x1;
-	EPOLLOUT = 0x4;
-	EPOLLRDHUP = 0x2000;
-	EPOLLPRI = 0x2;
-	EPOLLERR = 0x8;
-	EPOLLET = 0x80000000;
-	EPOLLONESHOT = 0x40000000;
-
-	// op
-	EPOLL_CTL_ADD = 0x1;
-	EPOLL_CTL_MOD = 0x3;
-	EPOLL_CTL_DEL = 0x2;
-)
-
-type EpollEvent struct {
-	Events uint32;
-	Fd int32;
-	Pad int32;
-}
-
-
-// Wait status.
-// See /usr/include/bits/waitstatus.h
-
-const (
-	WNOHANG = 1;
-	WUNTRACED = 2;
-	WSTOPPED = 2;	// same as WUNTRACED
-	WEXITED = 4;
-	WCONTINUED = 8;
-	WNOWAIT = 0x01000000;
-	WNOTHREAD = 0x20000000;
-	WALL = 0x40000000;
-	WCLONE = 0x80000000;
-)
-
-type WaitStatus uint32;
-
-// Wait status is 7 bits at bottom, either 0 (exited),
-// 0x7F (stopped), or a signal number that caused an exit.
-// The 0x80 bit is whether there was a core dump.
-// An extra number (exit code, signal causing a stop)
-// is in the high bits.  At least that's the idea.
-// There are various irregularities.  For example, the
-// "continued" status is 0xFFFF, distinguishing itself
-// from stopped via the core dump bit.
-
-const (
-	mask = 0x7F;
-	core = 0x80;
-	exited = 0x00;
-	stopped = 0x7F;
-	shift = 8;
-
-	// types_amd64_darwin.go refers to SIGSTOP.
-	// do the same here so the dependencies are
-	// the same on Linux as on Darwin.
-	__unused = SIGSTOP;
-)
-
-func (w WaitStatus) Exited() bool {
-	return w&mask == exited;
-}
-
-func (w WaitStatus) Signaled() bool {
-	return w&mask != stopped && w&mask != exited;
-}
-
-func (w WaitStatus) Stopped() bool {
-	return w&0xFF == stopped;
-}
-
-func (w WaitStatus) Continued() bool {
-	return w == 0xFFFF;
-}
-
-func (w WaitStatus) CoreDump() bool {
-	return w.Signaled() && w&core != 0;
-}
-
-func (w WaitStatus) ExitStatus() int {
-	if !w.Exited() {
-		return -1;
-	}
-	return int(w >> shift) & 0xFF;
-}
-
-func (w WaitStatus) Signal() int {
-	if !w.Signaled() {
-		return -1;
-	}
-	return int(w & mask);
-}
-
-func (w WaitStatus) StopSignal() int {
-	if !w.Stopped() {
-		return -1;
-	}
-	return int(w >> shift) & 0xFF;
-}
-
diff --git a/src/lib/syscall/zerrors_darwin_amd64.go b/src/lib/syscall/zerrors_darwin_amd64.go
new file mode 100644
index 0000000000..bc2d17656f
--- /dev/null
+++ b/src/lib/syscall/zerrors_darwin_amd64.go
@@ -0,0 +1,260 @@
+// mkerrors
+// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
+
+// godefs -gsyscall _errors.c
+
+// MACHINE GENERATED - DO NOT EDIT.
+
+package syscall
+
+// Constants
+const (
+	EMULTIHOP = 0x5f;
+	EAFNOSUPPORT = 0x2f;
+	EACCES = 0xd;
+	EDESTADDRREQ = 0x27;
+	EILSEQ = 0x5c;
+	ESPIPE = 0x1d;
+	EMLINK = 0x1f;
+	EPROGUNAVAIL = 0x4a;
+	ENOTTY = 0x19;
+	EBADF = 0x9;
+	ERANGE = 0x22;
+	ECANCELED = 0x59;
+	ETXTBSY = 0x1a;
+	ENOMEM = 0xc;
+	EINPROGRESS = 0x24;
+	ENOTEMPTY = 0x42;
+	ENOTBLK = 0xf;
+	EPROTOTYPE = 0x29;
+	ENOMSG = 0x5b;
+	ERPCMISMATCH = 0x49;
+	ENOTDIR = 0x14;
+	EALREADY = 0x25;
+	ETIMEDOUT = 0x3c;
+	ENEEDAUTH = 0x51;
+	ENODATA = 0x60;
+	EINTR = 0x4;
+	ENOLINK = 0x61;
+	EPERM = 0x1;
+	ENETDOWN = 0x32;
+	ESTALE = 0x46;
+	ENOTSOCK = 0x26;
+	ENOSR = 0x62;
+	EAUTH = 0x50;
+	ECHILD = 0xa;
+	EPIPE = 0x20;
+	ENOATTR = 0x5d;
+	EBADMSG = 0x5e;
+	EREMOTE = 0x47;
+	ETOOMANYREFS = 0x3b;
+	EPFNOSUPPORT = 0x2e;
+	EPROCUNAVAIL = 0x4c;
+	EADDRINUSE = 0x30;
+	ENETRESET = 0x34;
+	EISDIR = 0x15;
+	EIDRM = 0x5a;
+	EDEVERR = 0x53;
+	EINVAL = 0x16;
+	ESHUTDOWN = 0x3a;
+	EPWROFF = 0x52;
+	EOVERFLOW = 0x54;
+	EBUSY = 0x10;
+	EPROCLIM = 0x43;
+	EPROTO = 0x64;
+	ENODEV = 0x13;
+	EROFS = 0x1e;
+	E2BIG = 0x7;
+	EDEADLK = 0xb;
+	ECONNRESET = 0x36;
+	EBADMACHO = 0x58;
+	ENXIO = 0x6;
+	EBADRPC = 0x48;
+	ENAMETOOLONG = 0x3f;
+	ELAST = 0x67;
+	ESOCKTNOSUPPORT = 0x2c;
+	EADDRNOTAVAIL = 0x31;
+	ETIME = 0x65;
+	EPROTONOSUPPORT = 0x2b;
+	EIO = 0x5;
+	ENETUNREACH = 0x33;
+	EXDEV = 0x12;
+	EDQUOT = 0x45;
+	ENOSPC = 0x1c;
+	ENOEXEC = 0x8;
+	EMSGSIZE = 0x28;
+	EFTYPE = 0x4f;
+	EDOM = 0x21;
+	ENOSTR = 0x63;
+	EFBIG = 0x1b;
+	ESRCH = 0x3;
+	EHOSTDOWN = 0x40;
+	ENOLCK = 0x4d;
+	ENFILE = 0x17;
+	ENOSYS = 0x4e;
+	EBADARCH = 0x56;
+	ENOTCONN = 0x39;
+	ENOTSUP = 0x2d;
+	ECONNABORTED = 0x35;
+	EISCONN = 0x38;
+	ESHLIBVERS = 0x57;
+	EUSERS = 0x44;
+	ENOPROTOOPT = 0x2a;
+	EMFILE = 0x18;
+	ELOOP = 0x3e;
+	ENOBUFS = 0x37;
+	EFAULT = 0xe;
+	EWOULDBLOCK = 0x23;
+	EBADEXEC = 0x55;
+	ENOPOLICY = 0x67;
+	ECONNREFUSED = 0x3d;
+	EAGAIN = 0x23;
+	EEXIST = 0x11;
+	EPROGMISMATCH = 0x4b;
+	ENOENT = 0x2;
+	EHOSTUNREACH = 0x41;
+	EOPNOTSUPP = 0x66;
+	SIGBUS = 0xa;
+	SIGTTIN = 0x15;
+	SIGPROF = 0x1b;
+	SIGFPE = 0x8;
+	SIGHUP = 0x1;
+	SIGTTOU = 0x16;
+	SIGUSR1 = 0x1e;
+	SIGURG = 0x10;
+	SIGQUIT = 0x3;
+	SIGIO = 0x17;
+	SIGABRT = 0x6;
+	SIGINFO = 0x1d;
+	SIGUSR2 = 0x1f;
+	SIGTRAP = 0x5;
+	SIGVTALRM = 0x1a;
+	SIGSEGV = 0xb;
+	SIGCONT = 0x13;
+	SIGPIPE = 0xd;
+	SIGXFSZ = 0x19;
+	SIGCHLD = 0x14;
+	SIGSYS = 0xc;
+	SIGSTOP = 0x11;
+	SIGALRM = 0xe;
+	SIGTSTP = 0x12;
+	SIGEMT = 0x7;
+	SIGKILL = 0x9;
+	SIGXCPU = 0x18;
+	SIGILL = 0x4;
+	SIGINT = 0x2;
+	SIGIOT = 0x6;
+	SIGTERM = 0xf;
+	SIGWINCH = 0x1c;
+)
+
+// Types
+
+
+// Error table
+var errors = [...]string {
+	95: "EMULTIHOP (Reserved)",
+	47: "address family not supported by protocol family",
+	13: "permission denied",
+	39: "destination address required",
+	92: "illegal byte sequence",
+	29: "illegal seek",
+	31: "too many links",
+	74: "RPC prog. not avail",
+	25: "inappropriate ioctl for device",
+	9: "bad file descriptor",
+	34: "result too large",
+	89: "operation canceled",
+	26: "text file busy",
+	12: "cannot allocate memory",
+	36: "operation now in progress",
+	66: "directory not empty",
+	15: "block device required",
+	41: "protocol wrong type for socket",
+	91: "no message of desired type",
+	73: "RPC version wrong",
+	20: "not a directory",
+	37: "operation already in progress",
+	60: "operation timed out",
+	81: "need authenticator",
+	96: "no message available on STREAM",
+	4: "interrupted system call",
+	97: "ENOLINK (Reserved)",
+	1: "operation not permitted",
+	50: "network is down",
+	70: "stale NFS file handle",
+	38: "socket operation on non-socket",
+	98: "no STREAM resources",
+	80: "authentication error",
+	10: "no child processes",
+	32: "broken pipe",
+	93: "attribute not found",
+	94: "bad message",
+	71: "too many levels of remote in path",
+	59: "too many references: can't splice",
+	46: "protocol family not supported",
+	76: "bad procedure for program",
+	48: "address already in use",
+	52: "network dropped connection on reset",
+	21: "is a directory",
+	90: "identifier removed",
+	83: "device error",
+	22: "invalid argument",
+	58: "can't send after socket shutdown",
+	82: "device power is off",
+	84: "value too large to be stored in data type",
+	16: "resource busy",
+	67: "too many processes",
+	100: "protocol error",
+	19: "operation not supported by device",
+	30: "read-only file system",
+	7: "argument list too long",
+	11: "resource deadlock avoided",
+	54: "connection reset by peer",
+	88: "malformed Mach-o file",
+	6: "device not configured",
+	72: "RPC struct is bad",
+	63: "file name too long",
+	103: "policy not found",
+	44: "socket type not supported",
+	49: "can't assign requested address",
+	101: "STREAM ioctl timeout",
+	43: "protocol not supported",
+	5: "input/output error",
+	51: "network is unreachable",
+	18: "cross-device link",
+	69: "disc quota exceeded",
+	28: "no space left on device",
+	8: "exec format error",
+	40: "message too long",
+	79: "inappropriate file type or format",
+	33: "numerical argument out of domain",
+	99: "not a STREAM",
+	27: "file too large",
+	3: "no such process",
+	64: "host is down",
+	77: "no locks available",
+	23: "too many open files in system",
+	78: "function not implemented",
+	86: "bad CPU type in executable",
+	57: "socket is not connected",
+	45: "operation not supported",
+	53: "software caused connection abort",
+	56: "socket is already connected",
+	87: "shared library version mismatch",
+	68: "too many users",
+	42: "protocol not available",
+	24: "too many open files",
+	62: "too many levels of symbolic links",
+	55: "no buffer space available",
+	14: "bad address",
+	35: "resource temporarily unavailable",
+	85: "bad executable (or shared library)",
+	61: "connection refused",
+	17: "file exists",
+	75: "program version wrong",
+	2: "no such file or directory",
+	65: "no route to host",
+	102: "operation not supported on socket",
+}
+
diff --git a/src/lib/syscall/zerrors_linux_amd64.go b/src/lib/syscall/zerrors_linux_amd64.go
new file mode 100644
index 0000000000..f1e7e011da
--- /dev/null
+++ b/src/lib/syscall/zerrors_linux_amd64.go
@@ -0,0 +1,316 @@
+// mkerrors
+// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
+
+// godefs -gsyscall _errors.c
+
+// MACHINE GENERATED - DO NOT EDIT.
+
+package syscall
+
+// Constants
+const (
+	EMULTIHOP = 0x48;
+	EUNATCH = 0x31;
+	EAFNOSUPPORT = 0x61;
+	EREMCHG = 0x4e;
+	EACCES = 0xd;
+	EL3RST = 0x2f;
+	EDESTADDRREQ = 0x59;
+	EILSEQ = 0x54;
+	ESPIPE = 0x1d;
+	EMLINK = 0x1f;
+	EOWNERDEAD = 0x82;
+	ENOTTY = 0x19;
+	EBADE = 0x34;
+	EBADF = 0x9;
+	EBADR = 0x35;
+	EADV = 0x44;
+	ERANGE = 0x22;
+	ECANCELED = 0x7d;
+	ETXTBSY = 0x1a;
+	ENOMEM = 0xc;
+	EINPROGRESS = 0x73;
+	ENOTBLK = 0xf;
+	EPROTOTYPE = 0x5b;
+	ERESTART = 0x55;
+	EISNAM = 0x78;
+	ENOMSG = 0x2a;
+	EALREADY = 0x72;
+	ETIMEDOUT = 0x6e;
+	ENODATA = 0x3d;
+	EINTR = 0x4;
+	ENOLINK = 0x43;
+	EPERM = 0x1;
+	ELOOP = 0x28;
+	ENETDOWN = 0x64;
+	ESTALE = 0x74;
+	ENOTSOCK = 0x58;
+	ENOSR = 0x3f;
+	ECHILD = 0xa;
+	ELNRNG = 0x30;
+	EPIPE = 0x20;
+	EBADMSG = 0x4a;
+	EBFONT = 0x3b;
+	EREMOTE = 0x42;
+	ETOOMANYREFS = 0x6d;
+	EPFNOSUPPORT = 0x60;
+	ENONET = 0x40;
+	EXFULL = 0x36;
+	EBADSLT = 0x39;
+	ENOTNAM = 0x76;
+	ELIBEXEC = 0x53;
+	ENOCSI = 0x32;
+	ENOTEMPTY = 0x27;
+	EADDRINUSE = 0x62;
+	ENETRESET = 0x66;
+	EISDIR = 0x15;
+	EIDRM = 0x2b;
+	ECOMM = 0x46;
+	EBADFD = 0x4d;
+	EL2HLT = 0x33;
+	ENOKEY = 0x7e;
+	EINVAL = 0x16;
+	ESHUTDOWN = 0x6c;
+	EKEYREJECTED = 0x81;
+	ELIBSCN = 0x51;
+	ENAVAIL = 0x77;
+	ENOSTR = 0x3c;
+	EOVERFLOW = 0x4b;
+	EUCLEAN = 0x75;
+	ENOMEDIUM = 0x7b;
+	EBUSY = 0x10;
+	EPROTO = 0x47;
+	ENODEV = 0x13;
+	EKEYEXPIRED = 0x7f;
+	EROFS = 0x1e;
+	ELIBACC = 0x4f;
+	E2BIG = 0x7;
+	EDEADLK = 0x23;
+	ECONNRESET = 0x68;
+	ENXIO = 0x6;
+	EBADRQC = 0x38;
+	ENAMETOOLONG = 0x24;
+	ESOCKTNOSUPPORT = 0x5e;
+	EDOTDOT = 0x49;
+	EADDRNOTAVAIL = 0x63;
+	ETIME = 0x3e;
+	EPROTONOSUPPORT = 0x5d;
+	ENOTRECOVERABLE = 0x83;
+	EIO = 0x5;
+	ENETUNREACH = 0x65;
+	EXDEV = 0x12;
+	EDQUOT = 0x7a;
+	EREMOTEIO = 0x79;
+	ENOSPC = 0x1c;
+	ENOEXEC = 0x8;
+	EMSGSIZE = 0x5a;
+	EDOM = 0x21;
+	EFBIG = 0x1b;
+	ESRCH = 0x3;
+	ECHRNG = 0x2c;
+	EHOSTDOWN = 0x70;
+	ENOLCK = 0x25;
+	ENFILE = 0x17;
+	ENOSYS = 0x26;
+	ENOTCONN = 0x6b;
+	ENOTSUP = 0x5f;
+	ESRMNT = 0x45;
+	EDEADLOCK = 0x23;
+	ECONNABORTED = 0x67;
+	ENOANO = 0x37;
+	EISCONN = 0x6a;
+	EUSERS = 0x57;
+	ENOPROTOOPT = 0x5c;
+	EMFILE = 0x18;
+	ENOBUFS = 0x69;
+	EL3HLT = 0x2e;
+	EFAULT = 0xe;
+	EWOULDBLOCK = 0xb;
+	ELIBBAD = 0x50;
+	ESTRPIPE = 0x56;
+	ECONNREFUSED = 0x6f;
+	EAGAIN = 0xb;
+	ELIBMAX = 0x52;
+	EEXIST = 0x11;
+	EL2NSYNC = 0x2d;
+	ENOENT = 0x2;
+	ENOPKG = 0x41;
+	EKEYREVOKED = 0x80;
+	EHOSTUNREACH = 0x71;
+	ENOTUNIQ = 0x4c;
+	EOPNOTSUPP = 0x5f;
+	ENOTDIR = 0x14;
+	EMEDIUMTYPE = 0x7c;
+	SIGBUS = 0x7;
+	SIGTTIN = 0x15;
+	SIGPROF = 0x1b;
+	SIGFPE = 0x8;
+	SIGHUP = 0x1;
+	SIGTTOU = 0x16;
+	SIGSTKFLT = 0x10;
+	SIGUSR1 = 0xa;
+	SIGURG = 0x17;
+	SIGQUIT = 0x3;
+	SIGCLD = 0x11;
+	SIGIO = 0x1d;
+	SIGABRT = 0x6;
+	SIGUSR2 = 0xc;
+	SIGTRAP = 0x5;
+	SIGVTALRM = 0x1a;
+	SIGPOLL = 0x1d;
+	SIGSEGV = 0xb;
+	SIGCONT = 0x12;
+	SIGPIPE = 0xd;
+	SIGWINCH = 0x1c;
+	SIGXFSZ = 0x19;
+	SIGCHLD = 0x11;
+	SIGSYS = 0x1f;
+	SIGSTOP = 0x13;
+	SIGALRM = 0xe;
+	SIGTSTP = 0x14;
+	SIGKILL = 0x9;
+	SIGXCPU = 0x18;
+	SIGUNUSED = 0x1f;
+	SIGPWR = 0x1e;
+	SIGILL = 0x4;
+	SIGINT = 0x2;
+	SIGIOT = 0x6;
+	SIGTERM = 0xf;
+)
+
+// Types
+
+
+// Error table
+var errors = [...]string {
+	72: "multihop attempted",
+	49: "protocol driver not attached",
+	97: "address family not supported by protocol",
+	78: "remote address changed",
+	13: "permission denied",
+	47: "level 3 reset",
+	89: "destination address required",
+	84: "invalid or incomplete multibyte or wide character",
+	29: "illegal seek",
+	31: "too many links",
+	130: "owner died",
+	25: "inappropriate ioctl for device",
+	52: "invalid exchange",
+	9: "bad file descriptor",
+	53: "invalid request descriptor",
+	68: "advertise error",
+	34: "numerical result out of range",
+	125: "operation canceled",
+	26: "text file busy",
+	12: "cannot allocate memory",
+	115: "operation now in progress",
+	15: "block device required",
+	91: "protocol wrong type for socket",
+	85: "interrupted system call should be restarted",
+	120: "is a named type file",
+	42: "no message of desired type",
+	114: "operation already in progress",
+	110: "connection timed out",
+	61: "no data available",
+	4: "interrupted system call",
+	67: "link has been severed",
+	1: "operation not permitted",
+	40: "too many levels of symbolic links",
+	100: "network is down",
+	116: "stale NFS file handle",
+	88: "socket operation on non-socket",
+	63: "out of streams resources",
+	10: "no child processes",
+	48: "link number out of range",
+	32: "broken pipe",
+	74: "bad message",
+	59: "bad font file format",
+	66: "object is remote",
+	109: "too many references: cannot splice",
+	96: "protocol family not supported",
+	64: "machine is not on the network",
+	54: "exchange full",
+	57: "invalid slot",
+	118: "not a XENIX named type file",
+	83: "cannot exec a shared library directly",
+	50: "no CSI structure available",
+	39: "directory not empty",
+	98: "address already in use",
+	102: "network dropped connection on reset",
+	21: "is a directory",
+	43: "identifier removed",
+	70: "communication error on send",
+	77: "file descriptor in bad state",
+	51: "level 2 halted",
+	126: "required key not available",
+	22: "invalid argument",
+	108: "cannot send after transport endpoint shutdown",
+	129: "key was rejected by service",
+	81: ".lib section in a.out corrupted",
+	119: "no XENIX semaphores available",
+	60: "device not a stream",
+	75: "value too large for defined data type",
+	117: "structure needs cleaning",
+	123: "no medium found",
+	16: "device or resource busy",
+	71: "protocol error",
+	19: "no such device",
+	127: "key has expired",
+	30: "read-only file system",
+	79: "can not access a needed shared library",
+	7: "argument list too long",
+	35: "resource deadlock avoided",
+	104: "connection reset by peer",
+	6: "no such device or address",
+	56: "invalid request code",
+	36: "file name too long",
+	94: "socket type not supported",
+	73: "RFS specific error",
+	99: "cannot assign requested address",
+	62: "timer expired",
+	93: "protocol not supported",
+	131: "state not recoverable",
+	5: "input/output error",
+	101: "network is unreachable",
+	18: "invalid cross-device link",
+	122: "disk quota exceeded",
+	121: "remote I/O error",
+	28: "no space left on device",
+	8: "exec format error",
+	90: "message too long",
+	33: "numerical argument out of domain",
+	27: "file too large",
+	3: "no such process",
+	44: "channel number out of range",
+	112: "host is down",
+	37: "no locks available",
+	23: "too many open files in system",
+	38: "function not implemented",
+	107: "transport endpoint is not connected",
+	95: "operation not supported",
+	69: "srmount error",
+	103: "software caused connection abort",
+	55: "no anode",
+	106: "transport endpoint is already connected",
+	87: "too many users",
+	92: "protocol not available",
+	24: "too many open files",
+	105: "no buffer space available",
+	46: "level 3 halted",
+	14: "bad address",
+	11: "resource temporarily unavailable",
+	80: "accessing a corrupted shared library",
+	86: "streams pipe error",
+	111: "connection refused",
+	82: "attempting to link in too many shared libraries",
+	17: "file exists",
+	45: "level 2 not synchronized",
+	2: "no such file or directory",
+	65: "package not installed",
+	128: "key has been revoked",
+	113: "no route to host",
+	76: "name not unique on network",
+	20: "not a directory",
+	124: "wrong medium type",
+}
+
diff --git a/src/lib/syscall/zsyscall_darwin_amd64.go b/src/lib/syscall/zsyscall_darwin_amd64.go
new file mode 100644
index 0000000000..463bc4f63d
--- /dev/null
+++ b/src/lib/syscall/zsyscall_darwin_amd64.go
@@ -0,0 +1,622 @@
+// mksyscall syscall_darwin.go syscall_darwin_amd64.go
+// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
+
+package syscall
+
+import (
+	"syscall";
+	"unsafe";
+)
+
+func getfsstat64(buf *Statfs_t, nbuf int, flags int) (n int, errno int) {
+	r0, r1, e1 := Syscall(SYS_GETFSSTAT64, uintptr(unsafe.Pointer(buf)), uintptr(nbuf), uintptr(flags));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func getgroups(ngid int, gid *_Gid_t) (n int, errno int) {
+	r0, r1, e1 := Syscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func setgroups(ngid int, gid *_Gid_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0);
+	errno = int(e1);
+	return;
+}
+
+func wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, errno int) {
+	r0, r1, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0);
+	wpid = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func pipe() (r int, w int, errno int) {
+	r0, r1, e1 := Syscall(SYS_PIPE, 0, 0, 0);
+	r = int(r0);
+	w = int(r1);
+	errno = int(e1);
+	return;
+}
+
+func lseek(fd int, offset int64, whence int) (newoffset uintptr, errno int) {
+	r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(offset >> 32), uintptr(whence), 0, 0);
+	newoffset = uintptr(r0);
+	errno = int(e1);
+	return;
+}
+
+func gettimeofday(tp *Timeval) (sec int64, usec int32, errno int) {
+	r0, r1, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0);
+	sec = int64(r0);
+	usec = int32(r1);
+	errno = int(e1);
+	return;
+}
+
+func accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func bind(s int, addr uintptr, addrlen _Socklen) (errno int) {
+	r0, r1, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen));
+	errno = int(e1);
+	return;
+}
+
+func connect(s int, addr uintptr, addrlen _Socklen) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen));
+	errno = int(e1);
+	return;
+}
+
+func socket(domain int, typ int, proto int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto));
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func setsockopt(s int, level int, name int, val uintptr, vallen int) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0);
+	errno = int(e1);
+	return;
+}
+
+func kevent(kq int, change uintptr, nchange int, event uintptr, nevent int, timeout *Timespec) (n int, errno int) {
+	r0, r1, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func fcntl(fd int, cmd int, arg int) (val int, errno int) {
+	r0, r1, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg));
+	val = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Access(path string, flags int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
+	errno = int(e1);
+	return;
+}
+
+func Adjtime(delta *Timeval, olddelta *Timeval) (errno int) {
+	r0, r1, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Chdir(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Chflags(path string, flags int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
+	errno = int(e1);
+	return;
+}
+
+func Chmod(path string, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Chown(path string, uid int, gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
+	errno = int(e1);
+	return;
+}
+
+func Chroot(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Close(fd int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Dup(fd int) (nfd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0);
+	nfd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Dup2(from int, to int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0);
+	errno = int(e1);
+	return;
+}
+
+func Exchangedata(path1 string, path2 string, options int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_EXCHANGEDATA, uintptr(unsafe.Pointer(StringBytePtr(path1))), uintptr(unsafe.Pointer(StringBytePtr(path2))), uintptr(options));
+	errno = int(e1);
+	return;
+}
+
+func Exit(code int) () {
+	r0, r1, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0);
+	return;
+}
+
+func Fchdir(fd int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Fchflags(path string, flags int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FCHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
+	errno = int(e1);
+	return;
+}
+
+func Fchmod(fd int, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Fchown(fd int, uid int, gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid));
+	errno = int(e1);
+	return;
+}
+
+func Flock(fd int, how int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0);
+	errno = int(e1);
+	return;
+}
+
+func Fpathconf(fd int, name int) (val int, errno int) {
+	r0, r1, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0);
+	val = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Fstat(fd int, stat *Stat_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Fstatfs(fd int, stat *Statfs_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FSTATFS64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Fsync(fd int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Ftruncate(fd int, length int64) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length >> 32));
+	errno = int(e1);
+	return;
+}
+
+func Getdirentries(fd int, buf []byte, basep *uintptr) (n int, errno int) {
+	var _p0 *byte;
+	if len(buf) > 0 { _p0 = &buf[0]; }
+	r0, r1, e1 := Syscall6(SYS_GETDIRENTRIES64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Getdtablesize() (size int) {
+	r0, r1, e1 := Syscall(SYS_GETDTABLESIZE, 0, 0, 0);
+	size = int(r0);
+	return;
+}
+
+func Getegid() (egid int) {
+	r0, r1, e1 := Syscall(SYS_GETEGID, 0, 0, 0);
+	egid = int(r0);
+	return;
+}
+
+func Geteuid() (uid int) {
+	r0, r1, e1 := Syscall(SYS_GETEUID, 0, 0, 0);
+	uid = int(r0);
+	return;
+}
+
+func Getgid() (gid int) {
+	r0, r1, e1 := Syscall(SYS_GETGID, 0, 0, 0);
+	gid = int(r0);
+	return;
+}
+
+func Getpgid(pid int) (pgid int, errno int) {
+	r0, r1, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0);
+	pgid = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Getpgrp() (pgrp int) {
+	r0, r1, e1 := Syscall(SYS_GETPGRP, 0, 0, 0);
+	pgrp = int(r0);
+	return;
+}
+
+func Getpid() (pid int) {
+	r0, r1, e1 := Syscall(SYS_GETPID, 0, 0, 0);
+	pid = int(r0);
+	return;
+}
+
+func Getppid() (ppid int) {
+	r0, r1, e1 := Syscall(SYS_GETPPID, 0, 0, 0);
+	ppid = int(r0);
+	return;
+}
+
+func Getpriority(which int, who int) (prio int, errno int) {
+	r0, r1, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0);
+	prio = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Getrlimit(which int, lim *Rlimit) (errno int) {
+	r0, r1, e1 := Syscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Getrusage(who int, rusage *Rusage) (errno int) {
+	r0, r1, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Getsid(pid int) (sid int, errno int) {
+	r0, r1, e1 := Syscall(SYS_GETSID, uintptr(pid), 0, 0);
+	sid = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Getuid() (uid int) {
+	r0, r1, e1 := Syscall(SYS_GETUID, 0, 0, 0);
+	uid = int(r0);
+	return;
+}
+
+func Issetugid() (tainted bool) {
+	r0, r1, e1 := Syscall(SYS_ISSETUGID, 0, 0, 0);
+	tainted = bool(r0 != 0);
+	return;
+}
+
+func Kill(pid int, signum int, posix int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), uintptr(posix));
+	errno = int(e1);
+	return;
+}
+
+func Kqueue() (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_KQUEUE, 0, 0, 0);
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Lchown(path string, uid int, gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
+	errno = int(e1);
+	return;
+}
+
+func Link(path string, link string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Listen(s int, backlog int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0);
+	errno = int(e1);
+	return;
+}
+
+func Lstat(path string, stat *Stat_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Mkdir(path string, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Mkfifo(path string, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Mknod(path string, mode int, dev int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev));
+	errno = int(e1);
+	return;
+}
+
+func Open(path string, mode int, perm int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm));
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Pathconf(path string, name int) (val int, errno int) {
+	r0, r1, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(name), 0);
+	val = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Pread(fd int, p []byte, offset int64) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset >> 32), 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset >> 32), 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Read(fd int, p []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Readlink(path string, buf []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(buf) > 0 { _p0 = &buf[0]; }
+	r0, r1, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Rename(from string, to string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(from))), uintptr(unsafe.Pointer(StringBytePtr(to))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Revoke(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Rmdir(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setegid(egid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETEGID, uintptr(egid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Seteuid(euid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETEUID, uintptr(euid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setgid(gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETGID, uintptr(gid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setlogin(name string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(StringBytePtr(name))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setpgid(pid int, pgid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setpriority(which int, who int, prio int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio));
+	errno = int(e1);
+	return;
+}
+
+func Setprivexec(flag int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETPRIVEXEC, uintptr(flag), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setregid(rgid int, egid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setreuid(ruid int, euid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setrlimit(which int, lim *Rlimit) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setsid() (pid int, errno int) {
+	r0, r1, e1 := Syscall(SYS_SETSID, 0, 0, 0);
+	pid = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Settimeofday(tp *Timeval) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setuid(uid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Stat(path string, stat *Stat_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Statfs(path string, stat *Statfs_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Symlink(path string, link string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Sync() (errno int) {
+	r0, r1, e1 := Syscall(SYS_SYNC, 0, 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Truncate(path string, length int64) (errno int) {
+	r0, r1, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), uintptr(length >> 32));
+	errno = int(e1);
+	return;
+}
+
+func Umask(newmask int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UMASK, uintptr(newmask), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Undelete(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Unlink(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Unmount(path string, flags int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
+	errno = int(e1);
+	return;
+}
+
+func Write(fd int, p []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func read(fd int, buf *byte, nbuf int) (n int, errno int) {
+	r0, r1, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func write(fd int, buf *byte, nbuf int) (n int, errno int) {
+	r0, r1, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+
+
diff --git a/src/lib/syscall/zsyscall_linux_amd64.go b/src/lib/syscall/zsyscall_linux_amd64.go
new file mode 100644
index 0000000000..92a0ca1ef0
--- /dev/null
+++ b/src/lib/syscall/zsyscall_linux_amd64.go
@@ -0,0 +1,764 @@
+// mksyscall syscall_linux.go syscall_linux_amd64.go
+// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
+
+package syscall
+
+import (
+	"syscall";
+	"unsafe";
+)
+
+func pipe(p *[2]_C_int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func utimes(path string, times *[2]Timeval) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(times)), 0);
+	errno = int(e1);
+	return;
+}
+
+func futimesat(dirfd int, path string, times *[2]Timeval) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(times)));
+	errno = int(e1);
+	return;
+}
+
+func Getcwd(buf []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(buf) > 0 { _p0 = &buf[0]; }
+	r0, r1, e1 := Syscall(SYS_GETCWD, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func getgroups(n int, list *_Gid_t) (nn int, errno int) {
+	r0, r1, e1 := Syscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0);
+	nn = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func setgroups(n int, list *_Gid_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0);
+	errno = int(e1);
+	return;
+}
+
+func wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, errno int) {
+	r0, r1, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0);
+	wpid = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func bind(s int, addr uintptr, addrlen _Socklen) (errno int) {
+	r0, r1, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen));
+	errno = int(e1);
+	return;
+}
+
+func connect(s int, addr uintptr, addrlen _Socklen) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen));
+	errno = int(e1);
+	return;
+}
+
+func socket(domain int, typ int, proto int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto));
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func setsockopt(s int, level int, name int, val uintptr, vallen int) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0);
+	errno = int(e1);
+	return;
+}
+
+func Listen(s int, n int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0);
+	errno = int(e1);
+	return;
+}
+
+func Access(path string, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Acct(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Adjtimex(buf *Timex) (state int, errno int) {
+	r0, r1, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0);
+	state = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Chdir(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Chmod(path string, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Chown(path string, uid int, gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
+	errno = int(e1);
+	return;
+}
+
+func Chroot(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Close(fd int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Creat(path string, mode int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_CREAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Dup(oldfd int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0);
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Dup2(oldfd int, newfd int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0);
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func EpollCreate(size int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0);
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func EpollCtl(epfd int, op int, fd int, event *EpollEvent) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func EpollWait(epfd int, events []EpollEvent, msec int) (n int, errno int) {
+	var _p0 *EpollEvent;
+	if len(events) > 0 { _p0 = &events[0]; }
+	r0, r1, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(unsafe.Pointer(_p0)), uintptr(len(events)), uintptr(msec), 0, 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Exit(code int) () {
+	r0, r1, e1 := Syscall(SYS_EXIT_GROUP, uintptr(code), 0, 0);
+	return;
+}
+
+func Faccessat(dirfd int, path string, mode int, flags int) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(flags), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Fallocate(fd int, mode int, off int64, len int64) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(off >> 32), uintptr(len), uintptr(len >> 32));
+	errno = int(e1);
+	return;
+}
+
+func Fchdir(fd int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Fchmod(fd int, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Fchmodat(dirfd int, path string, mode int, flags int) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(flags), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Fchown(fd int, uid int, gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid));
+	errno = int(e1);
+	return;
+}
+
+func Fchownat(dirfd int, path string, uid int, gid int, flags int) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid), uintptr(flags), 0);
+	errno = int(e1);
+	return;
+}
+
+func fcntl(fd int, cmd int, arg int) (val int, errno int) {
+	r0, r1, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg));
+	val = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Fdatasync(fd int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Fstat(fd int, stat *Stat_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Fstatfs(fd int, buf *Statfs_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Fsync(fd int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Ftruncate(fd int, length int64) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length >> 32));
+	errno = int(e1);
+	return;
+}
+
+func Getdents(fd int, buf []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(buf) > 0 { _p0 = &buf[0]; }
+	r0, r1, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Getegid() (egid int) {
+	r0, r1, e1 := Syscall(SYS_GETEGID, 0, 0, 0);
+	egid = int(r0);
+	return;
+}
+
+func Geteuid() (euid int) {
+	r0, r1, e1 := Syscall(SYS_GETEUID, 0, 0, 0);
+	euid = int(r0);
+	return;
+}
+
+func Getgid() (gid int) {
+	r0, r1, e1 := Syscall(SYS_GETGID, 0, 0, 0);
+	gid = int(r0);
+	return;
+}
+
+func Getpgid(pid int) (pgid int, errno int) {
+	r0, r1, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0);
+	pgid = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Getpgrp() (pid int) {
+	r0, r1, e1 := Syscall(SYS_GETPGRP, 0, 0, 0);
+	pid = int(r0);
+	return;
+}
+
+func Getpid() (pid int) {
+	r0, r1, e1 := Syscall(SYS_GETPID, 0, 0, 0);
+	pid = int(r0);
+	return;
+}
+
+func Getppid() (ppid int) {
+	r0, r1, e1 := Syscall(SYS_GETPPID, 0, 0, 0);
+	ppid = int(r0);
+	return;
+}
+
+func Getrlimit(resource int, rlim *Rlimit) (errno int) {
+	r0, r1, e1 := Syscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Getrusage(who int, rusage *Rusage) (errno int) {
+	r0, r1, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Gettid() (tid int) {
+	r0, r1, e1 := Syscall(SYS_GETTID, 0, 0, 0);
+	tid = int(r0);
+	return;
+}
+
+func Gettimeofday(tv *Timeval) (errno int) {
+	r0, r1, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Getuid() (uid int) {
+	r0, r1, e1 := Syscall(SYS_GETUID, 0, 0, 0);
+	uid = int(r0);
+	return;
+}
+
+func Ioperm(from int, num int, on int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on));
+	errno = int(e1);
+	return;
+}
+
+func Iopl(level int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Kill(pid int, sig int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(sig), 0);
+	errno = int(e1);
+	return;
+}
+
+func Klogctl(typ int, buf []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(buf) > 0 { _p0 = &buf[0]; }
+	r0, r1, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Lchown(path string, uid int, gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
+	errno = int(e1);
+	return;
+}
+
+func Link(oldpath string, newpath string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Lstat(path string, stat *Stat_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Mkdir(path string, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Mkdirat(dirfd int, path string, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode));
+	errno = int(e1);
+	return;
+}
+
+func Mknod(path string, mode int, dev int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev));
+	errno = int(e1);
+	return;
+}
+
+func Mknodat(dirfd int, path string, mode int, dev int) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Nanosleep(time *Timespec, leftover *Timespec) (errno int) {
+	r0, r1, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Open(path string, mode int, perm int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm));
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Openat(dirfd int, path string, flags int, mode int) (fd int, errno int) {
+	r0, r1, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), uintptr(mode), 0, 0);
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Pause() (errno int) {
+	r0, r1, e1 := Syscall(SYS_PAUSE, 0, 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func PivotRoot(newroot string, putold string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(StringBytePtr(newroot))), uintptr(unsafe.Pointer(StringBytePtr(putold))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Pread(fd int, p []byte, offset int64) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset >> 32), 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset >> 32), 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Read(fd int, p []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Readlink(path string, buf []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(buf) > 0 { _p0 = &buf[0]; }
+	r0, r1, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Rename(oldpath string, newpath string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(newdirfd), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Rmdir(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Seek(fd int, offset int64, whence int) (off int64, errno int) {
+	r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(offset >> 32), uintptr(whence), 0, 0);
+	off = int64(r0);
+	errno = int(e1);
+	return;
+}
+
+func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, errno int) {
+	r0, r1, e1 := Syscall6(SYS_SELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Setdomainname(p []byte) (errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setfsgid(gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setfsuid(uid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setgid(gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETGID, uintptr(gid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Sethostname(p []byte) (errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall(SYS_SETHOSTNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setpgid(pid int, pgid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setregid(rgid int, egid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setresgid(rgid int, egid int, sgid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid));
+	errno = int(e1);
+	return;
+}
+
+func Setresuid(ruid int, euid int, suid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid));
+	errno = int(e1);
+	return;
+}
+
+func Setreuid(ruid int, euid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setrlimit(resource int, rlim *Rlimit) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setsid() (pid int) {
+	r0, r1, e1 := Syscall(SYS_SETSID, 0, 0, 0);
+	pid = int(r0);
+	return;
+}
+
+func Settimeofday(tv *Timeval) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setuid(uid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Shutdown(fd int, how int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0);
+	errno = int(e1);
+	return;
+}
+
+func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, errno int) {
+	r0, r1, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags));
+	n = int64(r0);
+	errno = int(e1);
+	return;
+}
+
+func Stat(path string, stat *Stat_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Statfs(path string, buf *Statfs_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(buf)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Symlink(oldpath string, newpath string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Sync() () {
+	r0, r1, e1 := Syscall(SYS_SYNC, 0, 0, 0);
+	return;
+}
+
+func SyncFileRange(fd int, off int64, n int64, flags int) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(off >> 32), uintptr(n), uintptr(n >> 32), uintptr(flags));
+	errno = int(e1);
+	return;
+}
+
+func Sysinfo(info *Sysinfo_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Tee(rfd int, wfd int, len int, flags int) (n int64, errno int) {
+	r0, r1, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0);
+	n = int64(r0);
+	errno = int(e1);
+	return;
+}
+
+func Tgkill(tgid int, tid int, sig int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig));
+	errno = int(e1);
+	return;
+}
+
+func Time(t *Time_t) (tt Time_t, errno int) {
+	r0, r1, e1 := Syscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0);
+	tt = Time_t(r0);
+	errno = int(e1);
+	return;
+}
+
+func Times(tms *Tms) (ticks uintptr, errno int) {
+	r0, r1, e1 := Syscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0);
+	ticks = uintptr(r0);
+	errno = int(e1);
+	return;
+}
+
+func Truncate(path string, length int64) (errno int) {
+	r0, r1, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), uintptr(length >> 32));
+	errno = int(e1);
+	return;
+}
+
+func Umask(mask int) (oldmask int) {
+	r0, r1, e1 := Syscall(SYS_UMASK, uintptr(mask), 0, 0);
+	oldmask = int(r0);
+	return;
+}
+
+func Uname(buf *Utsname) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Unlink(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Unlinkat(dirfd int, path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Unshare(flags int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Ustat(dev int, ubuf *Ustat_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Utime(path string, buf *Utimbuf) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(buf)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Write(fd int, p []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func exitThread(code int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func read(fd int, p *byte, np int) (n int, errno int) {
+	r0, r1, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func write(fd int, p *byte, np int) (n int, errno int) {
+	r0, r1, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+
+
diff --git a/src/lib/syscall/syscall_amd64_darwin.go b/src/lib/syscall/zsysnum_darwin_amd64.go
similarity index 99%
rename from src/lib/syscall/syscall_amd64_darwin.go
rename to src/lib/syscall/zsysnum_darwin_amd64.go
index b378f56e0b..c4c48c2a20 100644
--- a/src/lib/syscall/syscall_amd64_darwin.go
+++ b/src/lib/syscall/zsysnum_darwin_amd64.go
@@ -1,9 +1,5 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Generated by mkdarwin; DO NOT EDIT.
-// mkdarwin /home/rsc/pub/xnu-1228/bsd/kern/syscalls.master
+// mksysnum_darwin /home/rsc/pub/xnu-1228/bsd/kern/syscalls.master
+// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT
 
 package syscall
 
@@ -340,7 +336,7 @@ const (
 	// SYS_NOSYS = 297;  // { int nosys(void); } { old reset_shared_file }
 	// SYS_NOSYS = 298;  // { int nosys(void); } { old new_system_shared_regions }
 	// SYS_ENOSYS = 299;  // { int enosys(void); } { old shared_region_map_file_np }
-	SYS_ENOSYS = 300;  // { int enosys(void); } { old shared_region_make_private_np }
+	// SYS_ENOSYS = 300;  // { int enosys(void); } { old shared_region_make_private_np }
 	SYS___PTHREAD_MUTEX_DESTROY = 301;  // { int __pthread_mutex_destroy(int mutexid); }
 	SYS___PTHREAD_MUTEX_INIT = 302;  // { int __pthread_mutex_init(user_addr_t  mutex, user_addr_t attr); }
 	SYS___PTHREAD_MUTEX_LOCK = 303;  // { int __pthread_mutex_lock(int mutexid); }
diff --git a/src/lib/syscall/syscall_amd64_linux.go b/src/lib/syscall/zsysnum_linux_amd64.go
similarity index 97%
rename from src/lib/syscall/syscall_amd64_linux.go
rename to src/lib/syscall/zsysnum_linux_amd64.go
index cd75cb53cf..94424f3f34 100644
--- a/src/lib/syscall/syscall_amd64_linux.go
+++ b/src/lib/syscall/zsysnum_linux_amd64.go
@@ -1,7 +1,3 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
 // Generated by mklinux; DO NOT EDIT.
 // mklinux /usr/include/asm/unistd_64.h
 
@@ -295,3 +291,6 @@ const(
 	SYS_EVENTFD = 284;
 	SYS_FALLOCATE = 285;
 )
+
+func _darwin_system_call_conflict() {
+}
diff --git a/src/lib/syscall/ztypes_darwin_amd64.go b/src/lib/syscall/ztypes_darwin_amd64.go
new file mode 100644
index 0000000000..0523c50a4b
--- /dev/null
+++ b/src/lib/syscall/ztypes_darwin_amd64.go
@@ -0,0 +1,248 @@
+// godefs -gsyscall -f-m64 types_darwin.c types_darwin_amd64.c
+
+// MACHINE GENERATED - DO NOT EDIT.
+
+package syscall
+
+// Constants
+const (
+	sizeofPtr = 0x8;
+	sizeofShort = 0x2;
+	sizeofInt = 0x4;
+	sizeofLong = 0x8;
+	sizeofLongLong = 0x8;
+	O_RDONLY = 0;
+	O_WRONLY = 0x1;
+	O_RDWR = 0x2;
+	O_APPEND = 0x8;
+	O_ASYNC = 0x40;
+	O_CREAT = 0x200;
+	O_NOCTTY = 0x20000;
+	O_NONBLOCK = 0x4;
+	O_SYNC = 0x80;
+	O_TRUNC = 0x400;
+	O_CLOEXEC = 0;
+	F_GETFD = 0x1;
+	F_SETFD = 0x2;
+	F_GETFL = 0x3;
+	F_SETFL = 0x4;
+	FD_CLOEXEC = 0x1;
+	NAME_MAX = 0xff;
+	S_IFMT = 0xf000;
+	S_IFIFO = 0x1000;
+	S_IFCHR = 0x2000;
+	S_IFDIR = 0x4000;
+	S_IFBLK = 0x6000;
+	S_IFREG = 0x8000;
+	S_IFLNK = 0xa000;
+	S_IFSOCK = 0xc000;
+	S_IFWHT = 0xe000;
+	S_ISUID = 0x800;
+	S_ISGID = 0x400;
+	S_ISVTX = 0x200;
+	S_IRUSR = 0x100;
+	S_IWUSR = 0x80;
+	S_IXUSR = 0x40;
+	WNOHANG = 0x1;
+	WUNTRACED = 0x2;
+	WEXITED = 0x4;
+	WSTOPPED = 0x7f;
+	WCONTINUED = 0x10;
+	WNOWAIT = 0x20;
+	AF_UNIX = 0x1;
+	AF_INET = 0x2;
+	AF_DATAKIT = 0x9;
+	AF_INET6 = 0x1e;
+	SOCK_STREAM = 0x1;
+	SOCK_DGRAM = 0x2;
+	SOCK_RAW = 0x3;
+	SOCK_SEQPACKET = 0x5;
+	SOL_SOCKET = 0xffff;
+	SO_REUSEADDR = 0x4;
+	SO_KEEPALIVE = 0x8;
+	SO_DONTROUTE = 0x10;
+	SO_BROADCAST = 0x20;
+	SO_USELOOPBACK = 0x40;
+	SO_LINGER = 0x80;
+	SO_REUSEPORT = 0x200;
+	SO_SNDBUF = 0x1001;
+	SO_RCVBUF = 0x1002;
+	SO_SNDTIMEO = 0x1005;
+	SO_RCVTIMEO = 0x1006;
+	SO_NOSIGPIPE = 0x1022;
+	IPPROTO_TCP = 0x6;
+	IPPROTO_UDP = 0x11;
+	TCP_NODELAY = 0x1;
+	SOMAXCONN = 0x80;
+	SizeofSockaddrInet4 = 0x10;
+	SizeofSockaddrInet6 = 0x1c;
+	SizeofSockaddrAny = 0x1c;
+	SizeofSockaddrUnix = 0x6a;
+	EVFILT_READ = -0x1;
+	EVFILT_WRITE = -0x2;
+	EVFILT_AIO = -0x3;
+	EVFILT_VNODE = -0x4;
+	EVFILT_PROC = -0x5;
+	EVFILT_SIGNAL = -0x6;
+	EVFILT_TIMER = -0x7;
+	EVFILT_MACHPORT = -0x8;
+	EVFILT_FS = -0x9;
+	EVFILT_SYSCOUNT = 0x9;
+	EV_ADD = 0x1;
+	EV_DELETE = 0x2;
+	EV_DISABLE = 0x8;
+	EV_RECEIPT = 0x40;
+	EV_ONESHOT = 0x10;
+	EV_CLEAR = 0x20;
+	EV_SYSFLAGS = 0xf000;
+	EV_FLAG0 = 0x1000;
+	EV_FLAG1 = 0x2000;
+	EV_EOF = 0x8000;
+	EV_ERROR = 0x4000;
+)
+
+// Types
+
+type Timespec struct {
+	Sec int64;
+	Nsec int64;
+}
+
+type Timeval struct {
+	Sec int64;
+	Usec int32;
+	Pad0 [4]byte;
+}
+
+type Rusage struct {
+	Utime Timeval;
+	Stime Timeval;
+	Maxrss int64;
+	Ixrss int64;
+	Idrss int64;
+	Isrss int64;
+	Minflt int64;
+	Majflt int64;
+	Nswap int64;
+	Inblock int64;
+	Oublock int64;
+	Msgsnd int64;
+	Msgrcv int64;
+	Nsignals int64;
+	Nvcsw int64;
+	Nivcsw int64;
+}
+
+type Rlimit struct {
+	Cur uint64;
+	Max uint64;
+}
+
+type _C_int int32
+
+type _Gid_t uint32
+
+type Stat_t struct {
+	Dev int32;
+	Mode uint16;
+	Nlink uint16;
+	Ino uint64;
+	Uid uint32;
+	Gid uint32;
+	Rdev int32;
+	Pad0 [4]byte;
+	Atimespec Timespec;
+	Mtimespec Timespec;
+	Ctimespec Timespec;
+	Birthtimespec Timespec;
+	Size int64;
+	Blocks int64;
+	Blksize int32;
+	Flags uint32;
+	Gen uint32;
+	Lspare int32;
+	Qspare [2]int64;
+}
+
+type Statfs_t struct {
+	Bsize uint32;
+	Iosize int32;
+	Blocks uint64;
+	Bfree uint64;
+	Bavail uint64;
+	Files uint64;
+	Ffree uint64;
+	Fsid [8]byte /* fsid */;
+	Owner uint32;
+	Type uint32;
+	Flags uint32;
+	Fssubtype uint32;
+	Fstypename [16]int8;
+	Mntonname [1024]int8;
+	Mntfromname [1024]int8;
+	Reserved [8]uint32;
+}
+
+type Dirent struct {
+	Ino uint64;
+	Seekoff uint64;
+	Reclen uint16;
+	Namlen uint16;
+	Type uint8;
+	Name [1024]int8;
+	Pad0 [3]byte;
+}
+
+type RawSockaddrInet4 struct {
+	Len uint8;
+	Family uint8;
+	Port uint16;
+	Addr [4]byte /* in_addr */;
+	Zero [8]int8;
+}
+
+type RawSockaddrInet6 struct {
+	Len uint8;
+	Family uint8;
+	Port uint16;
+	Flowinfo uint32;
+	Addr [16]byte /* in6_addr */;
+	Scope_id uint32;
+}
+
+type RawSockaddrUnix struct {
+	Len uint8;
+	Family uint8;
+	Path [104]int8;
+}
+
+type RawSockaddr struct {
+	Len uint8;
+	Family uint8;
+	Data [14]int8;
+}
+
+type RawSockaddrAny struct {
+	Addr RawSockaddr;
+	Pad [12]int8;
+}
+
+type _Socklen uint32
+
+type Linger struct {
+	Onoff int32;
+	Linger int32;
+}
+
+type Kevent_t struct {
+	Ident uint64;
+	Filter int16;
+	Flags uint16;
+	Fflags uint32;
+	Data int64;
+	Udata *byte;
+}
+
+type FdSet struct {
+	Bits [32]int32;
+}
diff --git a/src/lib/syscall/ztypes_linux_amd64.go b/src/lib/syscall/ztypes_linux_amd64.go
new file mode 100644
index 0000000000..f17ebe1397
--- /dev/null
+++ b/src/lib/syscall/ztypes_linux_amd64.go
@@ -0,0 +1,300 @@
+// godefs -gsyscall -f-m64 types_linux.c types_linux_amd64.c
+
+// MACHINE GENERATED - DO NOT EDIT.
+
+package syscall
+
+// Constants
+const (
+	sizeofPtr = 0x8;
+	sizeofShort = 0x2;
+	sizeofInt = 0x4;
+	sizeofLong = 0x8;
+	sizeofLongLong = 0x8;
+	PathMax = 0x1000;
+	O_RDONLY = 0;
+	O_WRONLY = 0x1;
+	O_RDWR = 0x2;
+	O_APPEND = 0x400;
+	O_ASYNC = 0x2000;
+	O_CREAT = 0x40;
+	O_NOCTTY = 0x100;
+	O_NONBLOCK = 0x800;
+	O_SYNC = 0x1000;
+	O_TRUNC = 0x200;
+	O_CLOEXEC = 0;
+	F_GETFD = 0x1;
+	F_SETFD = 0x2;
+	F_GETFL = 0x3;
+	F_SETFL = 0x4;
+	FD_CLOEXEC = 0x1;
+	NAME_MAX = 0xff;
+	S_IFMT = 0xf000;
+	S_IFIFO = 0x1000;
+	S_IFCHR = 0x2000;
+	S_IFDIR = 0x4000;
+	S_IFBLK = 0x6000;
+	S_IFREG = 0x8000;
+	S_IFLNK = 0xa000;
+	S_IFSOCK = 0xc000;
+	S_ISUID = 0x800;
+	S_ISGID = 0x400;
+	S_ISVTX = 0x200;
+	S_IRUSR = 0x100;
+	S_IWUSR = 0x80;
+	S_IXUSR = 0x40;
+	WNOHANG = 0x1;
+	WUNTRACED = 0x2;
+	WEXITED = 0x4;
+	WSTOPPED = 0x2;
+	WCONTINUED = 0x8;
+	WNOWAIT = 0x1000000;
+	AF_UNIX = 0x1;
+	AF_INET = 0x2;
+	AF_INET6 = 0xa;
+	SOCK_STREAM = 0x1;
+	SOCK_DGRAM = 0x2;
+	SOCK_RAW = 0x3;
+	SOCK_SEQPACKET = 0x5;
+	SOL_SOCKET = 0x1;
+	SO_REUSEADDR = 0x2;
+	SO_KEEPALIVE = 0x9;
+	SO_DONTROUTE = 0x5;
+	SO_BROADCAST = 0x6;
+	SO_LINGER = 0xd;
+	SO_SNDBUF = 0x7;
+	SO_RCVBUF = 0x8;
+	SO_SNDTIMEO = 0x15;
+	SO_RCVTIMEO = 0x14;
+	IPPROTO_TCP = 0x6;
+	IPPROTO_UDP = 0x11;
+	TCP_NODELAY = 0x1;
+	SOMAXCONN = 0x80;
+	SizeofSockaddrInet4 = 0x10;
+	SizeofSockaddrInet6 = 0x1c;
+	SizeofSockaddrAny = 0x1c;
+	SizeofSockaddrUnix = 0x6e;
+	EPOLLIN = 0x1;
+	EPOLLRDHUP = 0x2000;
+	EPOLLOUT = 0x4;
+	EPOLLONESHOT = 0x40000000;
+	EPOLL_CTL_MOD = 0x3;
+	EPOLL_CTL_ADD = 0x1;
+	EPOLL_CTL_DEL = 0x2;
+)
+
+// Types
+
+type Timespec struct {
+	Sec int64;
+	Nsec int64;
+}
+
+type Timeval struct {
+	Sec int64;
+	Usec int64;
+}
+
+type Timex struct {
+	Modes uint32;
+	Pad0 [4]byte;
+	Offset int64;
+	Freq int64;
+	Maxerror int64;
+	Esterror int64;
+	Status int32;
+	Pad1 [4]byte;
+	Constant int64;
+	Precision int64;
+	Tolerance int64;
+	Time Timeval;
+	Tick int64;
+	Ppsfreq int64;
+	Jitter int64;
+	Shift int32;
+	Pad2 [4]byte;
+	Stabil int64;
+	Jitcnt int64;
+	Calcnt int64;
+	Errcnt int64;
+	Stbcnt int64;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+}
+
+type Time_t int64
+
+type Tms struct {
+	Utime int64;
+	Stime int64;
+	Cutime int64;
+	Cstime int64;
+}
+
+type Utimbuf struct {
+	Actime int64;
+	Modtime int64;
+}
+
+type Rusage struct {
+	Utime Timeval;
+	Stime Timeval;
+	Maxrss int64;
+	Ixrss int64;
+	Idrss int64;
+	Isrss int64;
+	Minflt int64;
+	Majflt int64;
+	Nswap int64;
+	Inblock int64;
+	Oublock int64;
+	Msgsnd int64;
+	Msgrcv int64;
+	Nsignals int64;
+	Nvcsw int64;
+	Nivcsw int64;
+}
+
+type Rlimit struct {
+	Cur uint64;
+	Max uint64;
+}
+
+type _C_int int32
+
+type _Gid_t uint32
+
+type Stat_t struct {
+	Dev uint64;
+	Ino uint64;
+	Nlink uint64;
+	Mode uint32;
+	Uid uint32;
+	Gid uint32;
+	Pad0 int32;
+	Rdev uint64;
+	Size int64;
+	Blksize int64;
+	Blocks int64;
+	Atim Timespec;
+	Mtim Timespec;
+	Ctim Timespec;
+	__unused [3]int64;
+}
+
+type Statfs_t struct {
+	Type int64;
+	Bsize int64;
+	Blocks uint64;
+	Bfree uint64;
+	Bavail uint64;
+	Files uint64;
+	Ffree uint64;
+	Fsid [8]byte /* __fsid_t */;
+	Namelen int64;
+	Frsize int64;
+	Spare [5]int64;
+}
+
+type Dirent struct {
+	Ino uint64;
+	Off int64;
+	Reclen uint16;
+	Type uint8;
+	Name [256]int8;
+	Pad0 [5]byte;
+}
+
+type RawSockaddrInet4 struct {
+	Family uint16;
+	Port uint16;
+	Addr [4]byte /* in_addr */;
+	Zero [8]uint8;
+}
+
+type RawSockaddrInet6 struct {
+	Family uint16;
+	Port uint16;
+	Flowinfo uint32;
+	Addr [16]byte /* in6_addr */;
+	Scope_id uint32;
+}
+
+type RawSockaddrUnix struct {
+	Family uint16;
+	Path [108]int8;
+}
+
+type RawSockaddr struct {
+	Family uint16;
+	Data [14]int8;
+}
+
+type RawSockaddrAny struct {
+	Addr RawSockaddr;
+	Pad [12]int8;
+}
+
+type _Socklen uint32
+
+type Linger struct {
+	Onoff int32;
+	Linger int32;
+}
+
+type FdSet struct {
+	__fds_bits [16]int64;
+}
+
+type Sysinfo_t struct {
+	Uptime int64;
+	Loads [3]uint64;
+	Totalram uint64;
+	Freeram uint64;
+	Sharedram uint64;
+	Bufferram uint64;
+	Totalswap uint64;
+	Freeswap uint64;
+	Procs uint16;
+	Pad uint16;
+	Pad0 [4]byte;
+	Totalhigh uint64;
+	Freehigh uint64;
+	Unit uint32;
+	_f [2]int8;
+	Pad1 [4]byte;
+}
+
+type Utsname struct {
+	Sysname [65]int8;
+	Nodename [65]int8;
+	Release [65]int8;
+	Version [65]int8;
+	Machine [65]int8;
+	__domainname [65]int8;
+}
+
+type Ustat_t struct {
+	Tfree int32;
+	Pad0 [4]byte;
+	Tinode uint64;
+	Fname [6]int8;
+	Fpack [6]int8;
+	Pad1 [4]byte;
+}
+
+type EpollEvent struct {
+	Events uint32;
+	Fd int32;
+	Pad int32;
+}
