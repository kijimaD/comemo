commit 6688efd5df1ef82dbe5d1f47b4c9bf4321a44126
Author: Robert Griesemer <gri@golang.org>
Date:   Thu Oct 6 16:21:35 2022 -0700

    cmd/compile/internal/types2: use internal/types/errors instead of local error codes
    
    Change-Id: If9b5c2c5d1b89146250bcd19965797baab315876
    Reviewed-on: https://go-review.googlesource.com/c/go/+/439564
    Run-TryBot: Robert Griesemer <gri@google.com>
    Reviewed-by: Robert Griesemer <gri@google.com>
    Auto-Submit: Robert Griesemer <gri@google.com>
    Reviewed-by: Robert Findley <rfindley@google.com>
    TryBot-Result: Gopher Robot <gobot@golang.org>
---
 src/cmd/compile/internal/types2/assignments.go |   33 +-
 src/cmd/compile/internal/types2/builtins.go    |   71 +-
 src/cmd/compile/internal/types2/call.go        |   41 +-
 src/cmd/compile/internal/types2/check.go       |    5 +-
 src/cmd/compile/internal/types2/conversions.go |    5 +-
 src/cmd/compile/internal/types2/decl.go        |   25 +-
 src/cmd/compile/internal/types2/errorcodes.go  | 1423 ------------------------
 src/cmd/compile/internal/types2/errors.go      |   13 +-
 src/cmd/compile/internal/types2/expr.go        |  139 +--
 src/cmd/compile/internal/types2/index.go       |   27 +-
 src/cmd/compile/internal/types2/infer.go       |   11 +-
 src/cmd/compile/internal/types2/initorder.go   |    5 +-
 src/cmd/compile/internal/types2/instantiate.go |    3 +-
 src/cmd/compile/internal/types2/interface.go   |    7 +-
 src/cmd/compile/internal/types2/labels.go      |   17 +-
 src/cmd/compile/internal/types2/mono.go        |    3 +-
 src/cmd/compile/internal/types2/operand.go     |   21 +-
 src/cmd/compile/internal/types2/resolver.go    |   31 +-
 src/cmd/compile/internal/types2/signature.go   |   19 +-
 src/cmd/compile/internal/types2/stmt.go        |   71 +-
 src/cmd/compile/internal/types2/struct.go      |   11 +-
 src/cmd/compile/internal/types2/typeset.go     |    7 +-
 src/cmd/compile/internal/types2/typexpr.go     |   49 +-
 src/cmd/compile/internal/types2/union.go       |   23 +-
 src/cmd/dist/buildtool.go                      |    1 +
 25 files changed, 333 insertions(+), 1728 deletions(-)

diff --git a/src/cmd/compile/internal/types2/assignments.go b/src/cmd/compile/internal/types2/assignments.go
index e9cb62418e..9120e8ce99 100644
--- a/src/cmd/compile/internal/types2/assignments.go
+++ b/src/cmd/compile/internal/types2/assignments.go
@@ -9,6 +9,7 @@ package types2
 import (
 	"cmd/compile/internal/syntax"
 	"fmt"
+	. "internal/types/errors"
 	"strings"
 )
 
@@ -40,7 +41,7 @@ func (check *Checker) assignment(x *operand, T Type, context string) {
 		// complex, or string constant."
 		if x.isNil() {
 			if T == nil {
-				check.errorf(x, _UntypedNil, "use of untyped nil in %s", context)
+				check.errorf(x, UntypedNilUse, "use of untyped nil in %s", context)
 				x.mode = invalid
 				return
 			}
@@ -51,12 +52,12 @@ func (check *Checker) assignment(x *operand, T Type, context string) {
 		if code != 0 {
 			msg := check.sprintf("cannot use %s as %s value in %s", x, target, context)
 			switch code {
-			case _TruncatedFloat:
+			case TruncatedFloat:
 				msg += " (truncated)"
-			case _NumericOverflow:
+			case NumericOverflow:
 				msg += " (overflows)"
 			default:
-				code = _IncompatibleAssign
+				code = IncompatibleAssign
 			}
 			check.error(x, code, msg)
 			x.mode = invalid
@@ -75,7 +76,7 @@ func (check *Checker) assignment(x *operand, T Type, context string) {
 
 	// A generic (non-instantiated) function value cannot be assigned to a variable.
 	if sig, _ := under(x.typ).(*Signature); sig != nil && sig.TypeParams().Len() > 0 {
-		check.errorf(x, _WrongTypeArgCount, "cannot use generic function %s without instantiation in %s", x, context)
+		check.errorf(x, WrongTypeArgCount, "cannot use generic function %s without instantiation in %s", x, context)
 	}
 
 	// spec: "If a left-hand side is the blank identifier, any typed or
@@ -106,7 +107,7 @@ func (check *Checker) initConst(lhs *Const, x *operand) {
 
 	// rhs must be a constant
 	if x.mode != constant_ {
-		check.errorf(x, _InvalidConstInit, "%s is not constant", x)
+		check.errorf(x, InvalidConstInit, "%s is not constant", x)
 		if lhs.typ == nil {
 			lhs.typ = Typ[Invalid]
 		}
@@ -144,7 +145,7 @@ func (check *Checker) initVar(lhs *Var, x *operand, context string) Type {
 		if isUntyped(typ) {
 			// convert untyped types to default types
 			if typ == Typ[UntypedNil] {
-				check.errorf(x, _UntypedNil, "use of untyped nil in %s", context)
+				check.errorf(x, UntypedNilUse, "use of untyped nil in %s", context)
 				lhs.typ = Typ[Invalid]
 				return nil
 			}
@@ -220,11 +221,11 @@ func (check *Checker) assignVar(lhs syntax.Expr, x *operand) Type {
 			var op operand
 			check.expr(&op, sel.X)
 			if op.mode == mapindex {
-				check.errorf(&z, _UnaddressableFieldAssign, "cannot assign to struct field %s in map", syntax.String(z.expr))
+				check.errorf(&z, UnaddressableFieldAssign, "cannot assign to struct field %s in map", syntax.String(z.expr))
 				return nil
 			}
 		}
-		check.errorf(&z, _UnassignableOperand, "cannot assign to %s", &z)
+		check.errorf(&z, UnassignableOperand, "cannot assign to %s", &z)
 		return nil
 	}
 
@@ -302,11 +303,11 @@ func (check *Checker) assignError(rhs []syntax.Expr, nvars, nvals int) {
 
 	if len(rhs) == 1 {
 		if call, _ := unparen(rhs0).(*syntax.CallExpr); call != nil {
-			check.errorf(rhs0, _WrongAssignCount, "assignment mismatch: %s but %s returns %s", vars, call.Fun, vals)
+			check.errorf(rhs0, WrongAssignCount, "assignment mismatch: %s but %s returns %s", vars, call.Fun, vals)
 			return
 		}
 	}
-	check.errorf(rhs0, _WrongAssignCount, "assignment mismatch: %s but %s", vars, vals)
+	check.errorf(rhs0, WrongAssignCount, "assignment mismatch: %s but %s", vars, vals)
 }
 
 // If returnStmt != nil, initVars is called to type-check the assignment
@@ -338,7 +339,7 @@ func (check *Checker) initVars(lhs []*Var, orig_rhs []syntax.Expr, returnStmt sy
 				at = rhs[len(rhs)-1].expr // report at last value
 			}
 			var err error_
-			err.code = _WrongResultCount
+			err.code = WrongResultCount
 			err.errorf(at, "%s return values", qualifier)
 			err.errorf(nopos, "have %s", check.typesSummary(operandTypes(rhs), false))
 			err.errorf(nopos, "want %s", check.typesSummary(varTypes(lhs), false))
@@ -453,7 +454,7 @@ func (check *Checker) shortVarDecl(pos syntax.Pos, lhs, rhs []syntax.Expr) {
 		ident, _ := lhs.(*syntax.Name)
 		if ident == nil {
 			check.use(lhs)
-			check.errorf(lhs, _BadDecl, "non-name %s on left side of :=", lhs)
+			check.errorf(lhs, BadDecl, "non-name %s on left side of :=", lhs)
 			hasErr = true
 			continue
 		}
@@ -461,7 +462,7 @@ func (check *Checker) shortVarDecl(pos syntax.Pos, lhs, rhs []syntax.Expr) {
 		name := ident.Value
 		if name != "_" {
 			if seen[name] {
-				check.errorf(lhs, _RepeatedDecl, "%s repeated on left side of :=", lhs)
+				check.errorf(lhs, RepeatedDecl, "%s repeated on left side of :=", lhs)
 				hasErr = true
 				continue
 			}
@@ -478,7 +479,7 @@ func (check *Checker) shortVarDecl(pos syntax.Pos, lhs, rhs []syntax.Expr) {
 			if obj, _ := alt.(*Var); obj != nil {
 				lhsVars[i] = obj
 			} else {
-				check.errorf(lhs, _UnassignableOperand, "cannot assign to %s", lhs)
+				check.errorf(lhs, UnassignableOperand, "cannot assign to %s", lhs)
 				hasErr = true
 			}
 			continue
@@ -506,7 +507,7 @@ func (check *Checker) shortVarDecl(pos syntax.Pos, lhs, rhs []syntax.Expr) {
 	check.processDelayed(top)
 
 	if len(newVars) == 0 && !hasErr {
-		check.softErrorf(pos, _NoNewVar, "no new variables on left side of :=")
+		check.softErrorf(pos, NoNewVar, "no new variables on left side of :=")
 		return
 	}
 
diff --git a/src/cmd/compile/internal/types2/builtins.go b/src/cmd/compile/internal/types2/builtins.go
index 9e0a510532..aab4ae95dd 100644
--- a/src/cmd/compile/internal/types2/builtins.go
+++ b/src/cmd/compile/internal/types2/builtins.go
@@ -10,6 +10,7 @@ import (
 	"cmd/compile/internal/syntax"
 	"go/constant"
 	"go/token"
+	. "internal/types/errors"
 )
 
 // builtin type-checks a call to the built-in specified by id and
@@ -21,7 +22,7 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 	bin := predeclaredFuncs[id]
 	if call.HasDots && id != _Append {
 		//check.errorf(call.Ellipsis, invalidOp + "invalid use of ... with built-in %s", bin.name)
-		check.errorf(call, _InvalidDotDotDot, invalidOp+"invalid use of ... with built-in %s", bin.name)
+		check.errorf(call, InvalidDotDotDot, invalidOp+"invalid use of ... with built-in %s", bin.name)
 		check.use(call.ArgList...)
 		return
 	}
@@ -67,7 +68,7 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 			msg = "too many"
 		}
 		if msg != "" {
-			check.errorf(call, _WrongArgCount, invalidOp+"%s arguments for %v (expected %d, found %d)", msg, call, bin.nargs, nargs)
+			check.errorf(call, WrongArgCount, invalidOp+"%s arguments for %v (expected %d, found %d)", msg, call, bin.nargs, nargs)
 			return
 		}
 	}
@@ -98,7 +99,7 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 				cause = check.sprintf("have %s", x)
 			}
 			// don't use invalidArg prefix here as it would repeat "argument" in the error message
-			check.errorf(x, _InvalidAppend, "first argument to append must be a slice; %s", cause)
+			check.errorf(x, InvalidAppend, "first argument to append must be a slice; %s", cause)
 			return
 		}
 
@@ -214,9 +215,9 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 		}
 
 		if mode == invalid && under(x.typ) != Typ[Invalid] {
-			code := _InvalidCap
+			code := InvalidCap
 			if id == _Len {
-				code = _InvalidLen
+				code = InvalidLen
 			}
 			check.errorf(x, code, invalidArg+"%s for %s", x, bin.name)
 			return
@@ -236,11 +237,11 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 		if !underIs(x.typ, func(u Type) bool {
 			uch, _ := u.(*Chan)
 			if uch == nil {
-				check.errorf(x, _InvalidClose, invalidOp+"cannot close non-channel %s", x)
+				check.errorf(x, InvalidClose, invalidOp+"cannot close non-channel %s", x)
 				return false
 			}
 			if uch.dir == RecvOnly {
-				check.errorf(x, _InvalidClose, invalidOp+"cannot close receive-only channel %s", x)
+				check.errorf(x, InvalidClose, invalidOp+"cannot close receive-only channel %s", x)
 				return false
 			}
 			return true
@@ -307,7 +308,7 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 
 		// both argument types must be identical
 		if !Identical(x.typ, y.typ) {
-			check.errorf(x, _InvalidComplex, invalidOp+"%v (mismatched types %s and %s)", call, x.typ, y.typ)
+			check.errorf(x, InvalidComplex, invalidOp+"%v (mismatched types %s and %s)", call, x.typ, y.typ)
 			return
 		}
 
@@ -329,7 +330,7 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 		}
 		resTyp := check.applyTypeFunc(f, x, id)
 		if resTyp == nil {
-			check.errorf(x, _InvalidComplex, invalidArg+"arguments have type %s, expected floating-point", x.typ)
+			check.errorf(x, InvalidComplex, invalidArg+"arguments have type %s, expected floating-point", x.typ)
 			return
 		}
 
@@ -362,12 +363,12 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 		src, _ := src0.(*Slice)
 
 		if dst == nil || src == nil {
-			check.errorf(x, _InvalidCopy, invalidArg+"copy expects slice arguments; found %s and %s", x, &y)
+			check.errorf(x, InvalidCopy, invalidArg+"copy expects slice arguments; found %s and %s", x, &y)
 			return
 		}
 
 		if !Identical(dst.elem, src.elem) {
-			check.errorf(x, _InvalidCopy, invalidArg+"arguments to copy %s and %s have different element types %s and %s", x, &y, dst.elem, src.elem)
+			check.errorf(x, InvalidCopy, invalidArg+"arguments to copy %s and %s have different element types %s and %s", x, &y, dst.elem, src.elem)
 			return
 		}
 
@@ -386,11 +387,11 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 		if !underIs(map_, func(u Type) bool {
 			map_, _ := u.(*Map)
 			if map_ == nil {
-				check.errorf(x, _InvalidDelete, invalidArg+"%s is not a map", x)
+				check.errorf(x, InvalidDelete, invalidArg+"%s is not a map", x)
 				return false
 			}
 			if key != nil && !Identical(map_.key, key) {
-				check.errorf(x, _InvalidDelete, invalidArg+"maps of %s must have identical key types", x)
+				check.errorf(x, InvalidDelete, invalidArg+"maps of %s must have identical key types", x)
 				return false
 			}
 			key = map_.key
@@ -457,9 +458,9 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 		}
 		resTyp := check.applyTypeFunc(f, x, id)
 		if resTyp == nil {
-			code := _InvalidImag
+			code := InvalidImag
 			if id == _Real {
-				code = _InvalidReal
+				code = InvalidReal
 			}
 			check.errorf(x, code, invalidArg+"argument has type %s, expected complex type", x.typ)
 			return
@@ -499,14 +500,14 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 		case *Map, *Chan:
 			min = 1
 		case nil:
-			check.errorf(arg0, _InvalidMake, invalidArg+"cannot make %s: no core type", arg0)
+			check.errorf(arg0, InvalidMake, invalidArg+"cannot make %s: no core type", arg0)
 			return
 		default:
-			check.errorf(arg0, _InvalidMake, invalidArg+"cannot make %s; type must be slice, map, or channel", arg0)
+			check.errorf(arg0, InvalidMake, invalidArg+"cannot make %s; type must be slice, map, or channel", arg0)
 			return
 		}
 		if nargs < min || min+1 < nargs {
-			check.errorf(call, _WrongArgCount, invalidOp+"%v expects %d or %d arguments; found %d", call, min, min+1, nargs)
+			check.errorf(call, WrongArgCount, invalidOp+"%v expects %d or %d arguments; found %d", call, min, min+1, nargs)
 			return
 		}
 
@@ -520,7 +521,7 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 			}
 		}
 		if len(sizes) == 2 && sizes[0] > sizes[1] {
-			check.error(call.ArgList[1], _SwappedMakeArgs, invalidArg+"length and capacity swapped")
+			check.error(call.ArgList[1], SwappedMakeArgs, invalidArg+"length and capacity swapped")
 			// safe to continue
 		}
 		x.mode = value
@@ -614,7 +615,7 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 
 		var y operand
 		arg(&y, 1)
-		if !check.isValidIndex(&y, _InvalidUnsafeAdd, "length", true) {
+		if !check.isValidIndex(&y, InvalidUnsafeAdd, "length", true) {
 			return
 		}
 
@@ -649,7 +650,7 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 		arg0 := call.ArgList[0]
 		selx, _ := unparen(arg0).(*syntax.SelectorExpr)
 		if selx == nil {
-			check.errorf(arg0, _BadOffsetofSyntax, invalidArg+"%s is not a selector expression", arg0)
+			check.errorf(arg0, BadOffsetofSyntax, invalidArg+"%s is not a selector expression", arg0)
 			check.use(arg0)
 			return
 		}
@@ -664,18 +665,18 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 		obj, index, indirect := LookupFieldOrMethod(base, false, check.pkg, sel)
 		switch obj.(type) {
 		case nil:
-			check.errorf(x, _MissingFieldOrMethod, invalidArg+"%s has no single field %s", base, sel)
+			check.errorf(x, MissingFieldOrMethod, invalidArg+"%s has no single field %s", base, sel)
 			return
 		case *Func:
 			// TODO(gri) Using derefStructPtr may result in methods being found
 			// that don't actually exist. An error either way, but the error
 			// message is confusing. See: https://play.golang.org/p/al75v23kUy ,
 			// but go/types reports: "invalid argument: x.m is a method value".
-			check.errorf(arg0, _InvalidOffsetof, invalidArg+"%s is a method value", arg0)
+			check.errorf(arg0, InvalidOffsetof, invalidArg+"%s is a method value", arg0)
 			return
 		}
 		if indirect {
-			check.errorf(x, _InvalidOffsetof, invalidArg+"field %s is embedded via a pointer in %s", sel, base)
+			check.errorf(x, InvalidOffsetof, invalidArg+"field %s is embedded via a pointer in %s", sel, base)
 			return
 		}
 
@@ -735,13 +736,13 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 
 		ptr, _ := under(x.typ).(*Pointer) // TODO(gri) should this be coreType rather than under?
 		if ptr == nil {
-			check.errorf(x, _InvalidUnsafeSlice, invalidArg+"%s is not a pointer", x)
+			check.errorf(x, InvalidUnsafeSlice, invalidArg+"%s is not a pointer", x)
 			return
 		}
 
 		var y operand
 		arg(&y, 1)
-		if !check.isValidIndex(&y, _InvalidUnsafeSlice, "length", false) {
+		if !check.isValidIndex(&y, InvalidUnsafeSlice, "length", false) {
 			return
 		}
 
@@ -760,7 +761,7 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 
 		slice, _ := under(x.typ).(*Slice) // TODO(gri) should this be coreType rather than under?
 		if slice == nil {
-			check.errorf(x, _InvalidUnsafeSliceData, invalidArg+"%s is not a slice", x)
+			check.errorf(x, InvalidUnsafeSliceData, invalidArg+"%s is not a slice", x)
 			return
 		}
 
@@ -784,7 +785,7 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 
 		var y operand
 		arg(&y, 1)
-		if !check.isValidIndex(&y, _InvalidUnsafeString, "length", false) {
+		if !check.isValidIndex(&y, InvalidUnsafeString, "length", false) {
 			return
 		}
 
@@ -817,15 +818,15 @@ func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (
 		// The result of assert is the value of pred if there is no error.
 		// Note: assert is only available in self-test mode.
 		if x.mode != constant_ || !isBoolean(x.typ) {
-			check.errorf(x, _Test, invalidArg+"%s is not a boolean constant", x)
+			check.errorf(x, Test, invalidArg+"%s is not a boolean constant", x)
 			return
 		}
 		if x.val.Kind() != constant.Bool {
-			check.errorf(x, _Test, "internal error: value of %s should be a boolean constant", x)
+			check.errorf(x, Test, "internal error: value of %s should be a boolean constant", x)
 			return
 		}
 		if !constant.BoolVal(x.val) {
-			check.errorf(call, _Test, "%v failed", call)
+			check.errorf(call, Test, "%v failed", call)
 			// compile-time assertion failure - safe to continue
 		}
 		// result is constant - no need to record signature
@@ -923,14 +924,14 @@ func (check *Checker) applyTypeFunc(f func(Type) Type, x *operand, id builtinId)
 		// type parameter for the result. It's not clear what the API
 		// implications are here. Report an error for 1.18 but continue
 		// type-checking.
-		var code errorCode
+		var code Code
 		switch id {
 		case _Real:
-			code = _InvalidReal
+			code = InvalidReal
 		case _Imag:
-			code = _InvalidImag
+			code = InvalidImag
 		case _Complex:
-			code = _InvalidComplex
+			code = InvalidComplex
 		default:
 			unreachable()
 		}
diff --git a/src/cmd/compile/internal/types2/call.go b/src/cmd/compile/internal/types2/call.go
index fb7d5ec553..0f8fbec43d 100644
--- a/src/cmd/compile/internal/types2/call.go
+++ b/src/cmd/compile/internal/types2/call.go
@@ -8,6 +8,7 @@ package types2
 
 import (
 	"cmd/compile/internal/syntax"
+	. "internal/types/errors"
 	"strings"
 	"unicode"
 )
@@ -32,7 +33,7 @@ func (check *Checker) funcInst(x *operand, inst *syntax.IndexExpr) {
 	sig := x.typ.(*Signature)
 	got, want := len(targs), sig.TypeParams().Len()
 	if !useConstraintTypeInference && got != want || got > want {
-		check.errorf(xlist[got-1], _WrongTypeArgCount, "got %d type arguments but want %d", got, want)
+		check.errorf(xlist[got-1], WrongTypeArgCount, "got %d type arguments but want %d", got, want)
 		x.mode = invalid
 		x.expr = inst
 		return
@@ -84,7 +85,7 @@ func (check *Checker) instantiateSignature(pos syntax.Pos, typ *Signature, targs
 			if i < len(xlist) {
 				pos = syntax.StartPos(xlist[i])
 			}
-			check.softErrorf(pos, _InvalidTypeArg, "%s", err)
+			check.softErrorf(pos, InvalidTypeArg, "%s", err)
 		} else {
 			check.mono.recordInstance(check.pkg, pos, tparams, targs, xlist)
 		}
@@ -126,25 +127,25 @@ func (check *Checker) callExpr(x *operand, call *syntax.CallExpr) exprKind {
 		x.mode = invalid
 		switch n := len(call.ArgList); n {
 		case 0:
-			check.errorf(call, _WrongArgCount, "missing argument in conversion to %s", T)
+			check.errorf(call, WrongArgCount, "missing argument in conversion to %s", T)
 		case 1:
 			check.expr(x, call.ArgList[0])
 			if x.mode != invalid {
 				if t, _ := under(T).(*Interface); t != nil && !isTypeParam(T) {
 					if !t.IsMethodSet() {
-						check.errorf(call, _MisplacedConstraintIface, "cannot use interface %s in conversion (contains specific type constraints or is comparable)", T)
+						check.errorf(call, MisplacedConstraintIface, "cannot use interface %s in conversion (contains specific type constraints or is comparable)", T)
 						break
 					}
 				}
 				if call.HasDots {
-					check.errorf(call.ArgList[0], _BadDotDotDotSyntax, "invalid use of ... in conversion to %s", T)
+					check.errorf(call.ArgList[0], BadDotDotDotSyntax, "invalid use of ... in conversion to %s", T)
 					break
 				}
 				check.conversion(x, T)
 			}
 		default:
 			check.use(call.ArgList...)
-			check.errorf(call.ArgList[n-1], _WrongArgCount, "too many arguments in conversion to %s", T)
+			check.errorf(call.ArgList[n-1], WrongArgCount, "too many arguments in conversion to %s", T)
 		}
 		x.expr = call
 		return conversion
@@ -170,7 +171,7 @@ func (check *Checker) callExpr(x *operand, call *syntax.CallExpr) exprKind {
 	// a type parameter may be "called" if all types have the same signature
 	sig, _ := coreType(x.typ).(*Signature)
 	if sig == nil {
-		check.errorf(x, _InvalidCall, invalidOp+"cannot call non-function %s", x)
+		check.errorf(x, InvalidCall, invalidOp+"cannot call non-function %s", x)
 		x.mode = invalid
 		x.expr = call
 		return statement
@@ -193,7 +194,7 @@ func (check *Checker) callExpr(x *operand, call *syntax.CallExpr) exprKind {
 		// check number of type arguments (got) vs number of type parameters (want)
 		got, want := len(targs), sig.TypeParams().Len()
 		if got > want {
-			check.errorf(xlist[want], _WrongTypeArgCount, "got %d type arguments but want %d", got, want)
+			check.errorf(xlist[want], WrongTypeArgCount, "got %d type arguments but want %d", got, want)
 			check.use(call.ArgList...)
 			x.mode = invalid
 			x.expr = call
@@ -315,7 +316,7 @@ func (check *Checker) arguments(call *syntax.CallExpr, sig *Signature, targs []T
 			if len(call.ArgList) == 1 && nargs > 1 {
 				// f()... is not permitted if f() is multi-valued
 				//check.errorf(call.Ellipsis, "cannot use ... with %d-valued %s", nargs, call.ArgList[0])
-				check.errorf(call, _InvalidDotDotDot, "cannot use ... with %d-valued %s", nargs, call.ArgList[0])
+				check.errorf(call, InvalidDotDotDot, "cannot use ... with %d-valued %s", nargs, call.ArgList[0])
 				return
 			}
 		} else {
@@ -343,7 +344,7 @@ func (check *Checker) arguments(call *syntax.CallExpr, sig *Signature, targs []T
 		if ddd {
 			// standard_func(a, b, c...)
 			//check.errorf(call.Ellipsis, "cannot use ... in call to non-variadic %s", call.Fun)
-			check.errorf(call, _NonVariadicDotDotDot, "cannot use ... in call to non-variadic %s", call.Fun)
+			check.errorf(call, NonVariadicDotDotDot, "cannot use ... in call to non-variadic %s", call.Fun)
 			return
 		}
 		// standard_func(a, b, c)
@@ -365,7 +366,7 @@ func (check *Checker) arguments(call *syntax.CallExpr, sig *Signature, targs []T
 			params = sig.params.vars
 		}
 		var err error_
-		err.code = _WrongArgCount
+		err.code = WrongArgCount
 		err.errorf(at, "%s arguments in call to %s", qualifier, call.Fun)
 		err.errorf(nopos, "have %s", check.typesSummary(operandTypes(args), false))
 		err.errorf(nopos, "want %s", check.typesSummary(varTypes(params), sig.variadic))
@@ -465,7 +466,7 @@ func (check *Checker) selector(x *operand, e *syntax.SelectorExpr, def *Named) {
 					}
 				}
 				if exp == nil {
-					check.errorf(e.Sel, _UndeclaredImportedName, "undefined: %s", syntax.Expr(e)) // cast to syntax.Expr to silence vet
+					check.errorf(e.Sel, UndeclaredImportedName, "undefined: %s", syntax.Expr(e)) // cast to syntax.Expr to silence vet
 					goto Error
 				}
 				check.objDecl(exp, nil)
@@ -473,12 +474,12 @@ func (check *Checker) selector(x *operand, e *syntax.SelectorExpr, def *Named) {
 				exp = pkg.scope.Lookup(sel)
 				if exp == nil {
 					if !pkg.fake {
-						check.errorf(e.Sel, _UndeclaredImportedName, "undefined: %s", syntax.Expr(e))
+						check.errorf(e.Sel, UndeclaredImportedName, "undefined: %s", syntax.Expr(e))
 					}
 					goto Error
 				}
 				if !exp.Exported() {
-					check.errorf(e.Sel, _UnexportedName, "%s not exported by package %s", sel, pkg.name)
+					check.errorf(e.Sel, UnexportedName, "%s not exported by package %s", sel, pkg.name)
 					// ok to continue
 				}
 			}
@@ -530,7 +531,7 @@ func (check *Checker) selector(x *operand, e *syntax.SelectorExpr, def *Named) {
 			goto Error
 		}
 	case builtin:
-		check.errorf(e.Pos(), _UncalledBuiltin, "cannot select on %s", x)
+		check.errorf(e.Pos(), UncalledBuiltin, "cannot select on %s", x)
 		goto Error
 	case invalid:
 		goto Error
@@ -545,12 +546,12 @@ func (check *Checker) selector(x *operand, e *syntax.SelectorExpr, def *Named) {
 
 		if index != nil {
 			// TODO(gri) should provide actual type where the conflict happens
-			check.errorf(e.Sel, _AmbiguousSelector, "ambiguous selector %s.%s", x.expr, sel)
+			check.errorf(e.Sel, AmbiguousSelector, "ambiguous selector %s.%s", x.expr, sel)
 			goto Error
 		}
 
 		if indirect {
-			check.errorf(e.Sel, _InvalidMethodExpr, "cannot call pointer method %s on %s", sel, x.typ)
+			check.errorf(e.Sel, InvalidMethodExpr, "cannot call pointer method %s on %s", sel, x.typ)
 			goto Error
 		}
 
@@ -574,7 +575,7 @@ func (check *Checker) selector(x *operand, e *syntax.SelectorExpr, def *Named) {
 				}
 			}
 		}
-		check.errorf(e.Sel, _MissingFieldOrMethod, "%s.%s undefined (%s)", x.expr, sel, why)
+		check.errorf(e.Sel, MissingFieldOrMethod, "%s.%s undefined (%s)", x.expr, sel, why)
 		goto Error
 	}
 
@@ -588,7 +589,7 @@ func (check *Checker) selector(x *operand, e *syntax.SelectorExpr, def *Named) {
 		m, _ := obj.(*Func)
 		if m == nil {
 			// TODO(gri) should check if capitalization of sel matters and provide better error message in that case
-			check.errorf(e.Sel, _MissingFieldOrMethod, "%s.%s undefined (type %s has no method %s)", x.expr, sel, x.typ, sel)
+			check.errorf(e.Sel, MissingFieldOrMethod, "%s.%s undefined (type %s has no method %s)", x.expr, sel, x.typ, sel)
 			goto Error
 		}
 
@@ -596,7 +597,7 @@ func (check *Checker) selector(x *operand, e *syntax.SelectorExpr, def *Named) {
 
 		sig := m.typ.(*Signature)
 		if sig.recv == nil {
-			check.error(e, _InvalidDeclCycle, "illegal cycle in method declaration")
+			check.error(e, InvalidDeclCycle, "illegal cycle in method declaration")
 			goto Error
 		}
 
diff --git a/src/cmd/compile/internal/types2/check.go b/src/cmd/compile/internal/types2/check.go
index 2dc960dfc8..c495293009 100644
--- a/src/cmd/compile/internal/types2/check.go
+++ b/src/cmd/compile/internal/types2/check.go
@@ -11,6 +11,7 @@ import (
 	"errors"
 	"fmt"
 	"go/constant"
+	. "internal/types/errors"
 )
 
 var nopos syntax.Pos
@@ -267,7 +268,7 @@ func (check *Checker) initFiles(files []*syntax.File) {
 			if name != "_" {
 				pkg.name = name
 			} else {
-				check.error(file.PkgName, _BlankPkgName, "invalid package name _")
+				check.error(file.PkgName, BlankPkgName, "invalid package name _")
 			}
 			fallthrough
 
@@ -275,7 +276,7 @@ func (check *Checker) initFiles(files []*syntax.File) {
 			check.files = append(check.files, file)
 
 		default:
-			check.errorf(file, _MismatchedPkgName, "package %s; expected %s", name, pkg.name)
+			check.errorf(file, MismatchedPkgName, "package %s; expected %s", name, pkg.name)
 			// ignore this file
 		}
 	}
diff --git a/src/cmd/compile/internal/types2/conversions.go b/src/cmd/compile/internal/types2/conversions.go
index 8c0607d608..865b49c00f 100644
--- a/src/cmd/compile/internal/types2/conversions.go
+++ b/src/cmd/compile/internal/types2/conversions.go
@@ -8,6 +8,7 @@ package types2
 
 import (
 	"go/constant"
+	. "internal/types/errors"
 	"unicode"
 )
 
@@ -71,9 +72,9 @@ func (check *Checker) conversion(x *operand, T Type) {
 
 	if !ok {
 		if cause != "" {
-			check.errorf(x, _InvalidConversion, "cannot convert %s to type %s: %s", x, T, cause)
+			check.errorf(x, InvalidConversion, "cannot convert %s to type %s: %s", x, T, cause)
 		} else {
-			check.errorf(x, _InvalidConversion, "cannot convert %s to type %s", x, T)
+			check.errorf(x, InvalidConversion, "cannot convert %s to type %s", x, T)
 		}
 		x.mode = invalid
 		return
diff --git a/src/cmd/compile/internal/types2/decl.go b/src/cmd/compile/internal/types2/decl.go
index b99e1dcd77..7c6ecd8b02 100644
--- a/src/cmd/compile/internal/types2/decl.go
+++ b/src/cmd/compile/internal/types2/decl.go
@@ -9,6 +9,7 @@ import (
 	"cmd/compile/internal/syntax"
 	"fmt"
 	"go/constant"
+	. "internal/types/errors"
 )
 
 func (err *error_) recordAltDecl(obj Object) {
@@ -28,7 +29,7 @@ func (check *Checker) declare(scope *Scope, id *syntax.Name, obj Object, pos syn
 	if obj.Name() != "_" {
 		if alt := scope.Insert(obj); alt != nil {
 			var err error_
-			err.code = _DuplicateDecl
+			err.code = DuplicateDecl
 			err.errorf(obj, "%s redeclared in this block", obj.Name())
 			err.recordAltDecl(alt)
 			check.report(&err)
@@ -331,15 +332,15 @@ func (check *Checker) cycleError(cycle []Object) {
 	// report a more concise error for self references
 	if len(cycle) == 1 {
 		if tname != nil {
-			check.errorf(obj, _InvalidDeclCycle, "invalid recursive type: %s refers to itself", objName)
+			check.errorf(obj, InvalidDeclCycle, "invalid recursive type: %s refers to itself", objName)
 		} else {
-			check.errorf(obj, _InvalidDeclCycle, "invalid cycle in declaration: %s refers to itself", objName)
+			check.errorf(obj, InvalidDeclCycle, "invalid cycle in declaration: %s refers to itself", objName)
 		}
 		return
 	}
 
 	var err error_
-	err.code = _InvalidDeclCycle
+	err.code = InvalidDeclCycle
 	if tname != nil {
 		err.errorf(obj, "invalid recursive type %s", objName)
 	} else {
@@ -391,7 +392,7 @@ func (check *Checker) constDecl(obj *Const, typ, init syntax.Expr, inherited boo
 			// don't report an error if the type is an invalid C (defined) type
 			// (issue #22090)
 			if under(t) != Typ[Invalid] {
-				check.errorf(typ, _InvalidConstType, "invalid constant type %s", t)
+				check.errorf(typ, InvalidConstType, "invalid constant type %s", t)
 			}
 			obj.typ = Typ[Invalid]
 			return
@@ -518,7 +519,7 @@ func (check *Checker) typeDecl(obj *TypeName, tdecl *syntax.TypeDecl, def *Named
 	if alias && tdecl.TParamList != nil {
 		// The parser will ensure this but we may still get an invalid AST.
 		// Complain and continue as regular type definition.
-		check.error(tdecl, _BadDecl, "generic type cannot be alias")
+		check.error(tdecl, BadDecl, "generic type cannot be alias")
 		alias = false
 	}
 
@@ -561,7 +562,7 @@ func (check *Checker) typeDecl(obj *TypeName, tdecl *syntax.TypeDecl, def *Named
 	// use its underlying type (like we do for any RHS in a type declaration), and its
 	// underlying type is an interface and the type declaration is well defined.
 	if isTypeParam(rhs) {
-		check.error(tdecl.Type, _MisplacedTypeParam, "cannot use a type parameter as RHS in type declaration")
+		check.error(tdecl.Type, MisplacedTypeParam, "cannot use a type parameter as RHS in type declaration")
 		named.underlying = Typ[Invalid]
 	}
 }
@@ -607,7 +608,7 @@ func (check *Checker) collectTypeParams(dst **TypeParamList, list []*syntax.Fiel
 				// the underlying type and thus type set of a type parameter is.
 				// But we may need some additional form of cycle detection within
 				// type parameter lists.
-				check.error(f.Type, _MisplacedTypeParam, "cannot use a type parameter as constraint")
+				check.error(f.Type, MisplacedTypeParam, "cannot use a type parameter as constraint")
 				bound = Typ[Invalid]
 			}
 		}
@@ -687,9 +688,9 @@ func (check *Checker) collectMethods(obj *TypeName) {
 		assert(m.name != "_")
 		if alt := mset.insert(m); alt != nil {
 			if alt.Pos().IsKnown() {
-				check.errorf(m.pos, _DuplicateMethod, "method %s.%s already declared at %s", obj.Name(), m.name, alt.Pos())
+				check.errorf(m.pos, DuplicateMethod, "method %s.%s already declared at %s", obj.Name(), m.name, alt.Pos())
 			} else {
-				check.errorf(m.pos, _DuplicateMethod, "method %s.%s already declared", obj.Name(), m.name)
+				check.errorf(m.pos, DuplicateMethod, "method %s.%s already declared", obj.Name(), m.name)
 			}
 			continue
 		}
@@ -721,7 +722,7 @@ func (check *Checker) checkFieldUniqueness(base *Named) {
 					// For historical consistency, we report the primary error on the
 					// method, and the alt decl on the field.
 					var err error_
-					err.code = _DuplicateFieldAndMethod
+					err.code = DuplicateFieldAndMethod
 					err.errorf(alt, "field and method with the same name %s", fld.name)
 					err.recordAltDecl(fld)
 					check.report(&err)
@@ -753,7 +754,7 @@ func (check *Checker) funcDecl(obj *Func, decl *declInfo) {
 	obj.color_ = saved
 
 	if len(fdecl.TParamList) > 0 && fdecl.Body == nil {
-		check.softErrorf(fdecl, _BadDecl, "generic function is missing function body")
+		check.softErrorf(fdecl, BadDecl, "generic function is missing function body")
 	}
 
 	// function body must be type-checked after global declarations
diff --git a/src/cmd/compile/internal/types2/errorcodes.go b/src/cmd/compile/internal/types2/errorcodes.go
deleted file mode 100644
index f24388920a..0000000000
--- a/src/cmd/compile/internal/types2/errorcodes.go
+++ /dev/null
@@ -1,1423 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package types2
-
-type errorCode int
-
-// This file defines the error codes that can be produced during type-checking.
-// Collectively, these codes provide an identifier that may be used to
-// implement special handling for certain types of errors.
-//
-// Error code values should not be changed: add new codes at the end.
-//
-// Error codes should be fine-grained enough that the exact nature of the error
-// can be easily determined, but coarse enough that they are not an
-// implementation detail of the type checking algorithm. As a rule-of-thumb,
-// errors should be considered equivalent if there is a theoretical refactoring
-// of the type checker in which they are emitted in exactly one place. For
-// example, the type checker emits different error messages for "too many
-// arguments" and "too few arguments", but one can imagine an alternative type
-// checker where this check instead just emits a single "wrong number of
-// arguments", so these errors should have the same code.
-//
-// Error code names should be as brief as possible while retaining accuracy and
-// distinctiveness. In most cases names should start with an adjective
-// describing the nature of the error (e.g. "invalid", "unused", "misplaced"),
-// and end with a noun identifying the relevant language object. For example,
-// "_DuplicateDecl" or "_InvalidSliceExpr". For brevity, naming follows the
-// convention that "bad" implies a problem with syntax, and "invalid" implies a
-// problem with types.
-
-const (
-	_ errorCode = iota
-
-	// _Test is reserved for errors that only apply while in self-test mode.
-	_Test
-
-	// _BlankPkgName occurs when a package name is the blank identifier "_".
-	//
-	// Per the spec:
-	//  "The PackageName must not be the blank identifier."
-	_BlankPkgName
-
-	// _MismatchedPkgName occurs when a file's package name doesn't match the
-	// package name already established by other files.
-	_MismatchedPkgName
-
-	// _InvalidPkgUse occurs when a package identifier is used outside of a
-	// selector expression.
-	//
-	// Example:
-	//  import "fmt"
-	//
-	//  var _ = fmt
-	_InvalidPkgUse
-
-	// _BadImportPath occurs when an import path is not valid.
-	_BadImportPath
-
-	// _BrokenImport occurs when importing a package fails.
-	//
-	// Example:
-	//  import "amissingpackage"
-	_BrokenImport
-
-	// _ImportCRenamed occurs when the special import "C" is renamed. "C" is a
-	// pseudo-package, and must not be renamed.
-	//
-	// Example:
-	//  import _ "C"
-	_ImportCRenamed
-
-	// _UnusedImport occurs when an import is unused.
-	//
-	// Example:
-	//  import "fmt"
-	//
-	//  func main() {}
-	_UnusedImport
-
-	// _InvalidInitCycle occurs when an invalid cycle is detected within the
-	// initialization graph.
-	//
-	// Example:
-	//  var x int = f()
-	//
-	//  func f() int { return x }
-	_InvalidInitCycle
-
-	// _DuplicateDecl occurs when an identifier is declared multiple times.
-	//
-	// Example:
-	//  var x = 1
-	//  var x = 2
-	_DuplicateDecl
-
-	// _InvalidDeclCycle occurs when a declaration cycle is not valid.
-	//
-	// Example:
-	//  type S struct {
-	//  	S
-	//  }
-	//
-	_InvalidDeclCycle
-
-	// _InvalidTypeCycle occurs when a cycle in type definitions results in a
-	// type that is not well-defined.
-	//
-	// Example:
-	//  import "unsafe"
-	//
-	//  type T [unsafe.Sizeof(T{})]int
-	_InvalidTypeCycle
-
-	// _InvalidConstInit occurs when a const declaration has a non-constant
-	// initializer.
-	//
-	// Example:
-	//  var x int
-	//  const _ = x
-	_InvalidConstInit
-
-	// _InvalidConstVal occurs when a const value cannot be converted to its
-	// target type.
-	//
-	// TODO(findleyr): this error code and example are not very clear. Consider
-	// removing it.
-	//
-	// Example:
-	//  const _ = 1 << "hello"
-	_InvalidConstVal
-
-	// _InvalidConstType occurs when the underlying type in a const declaration
-	// is not a valid constant type.
-	//
-	// Example:
-	//  const c *int = 4
-	_InvalidConstType
-
-	// _UntypedNil occurs when the predeclared (untyped) value nil is used to
-	// initialize a variable declared without an explicit type.
-	//
-	// Example:
-	//  var x = nil
-	_UntypedNil
-
-	// _WrongAssignCount occurs when the number of values on the right-hand side
-	// of an assignment or initialization expression does not match the number
-	// of variables on the left-hand side.
-	//
-	// Example:
-	//  var x = 1, 2
-	_WrongAssignCount
-
-	// _UnassignableOperand occurs when the left-hand side of an assignment is
-	// not assignable.
-	//
-	// Example:
-	//  func f() {
-	//  	const c = 1
-	//  	c = 2
-	//  }
-	_UnassignableOperand
-
-	// _NoNewVar occurs when a short variable declaration (':=') does not declare
-	// new variables.
-	//
-	// Example:
-	//  func f() {
-	//  	x := 1
-	//  	x := 2
-	//  }
-	_NoNewVar
-
-	// _MultiValAssignOp occurs when an assignment operation (+=, *=, etc) does
-	// not have single-valued left-hand or right-hand side.
-	//
-	// Per the spec:
-	//  "In assignment operations, both the left- and right-hand expression lists
-	//  must contain exactly one single-valued expression"
-	//
-	// Example:
-	//  func f() int {
-	//  	x, y := 1, 2
-	//  	x, y += 1
-	//  	return x + y
-	//  }
-	_MultiValAssignOp
-
-	// _InvalidIfaceAssign occurs when a value of type T is used as an
-	// interface, but T does not implement a method of the expected interface.
-	//
-	// Example:
-	//  type I interface {
-	//  	f()
-	//  }
-	//
-	//  type T int
-	//
-	//  var x I = T(1)
-	_InvalidIfaceAssign
-
-	// _InvalidChanAssign occurs when a chan assignment is invalid.
-	//
-	// Per the spec, a value x is assignable to a channel type T if:
-	//  "x is a bidirectional channel value, T is a channel type, x's type V and
-	//  T have identical element types, and at least one of V or T is not a
-	//  defined type."
-	//
-	// Example:
-	//  type T1 chan int
-	//  type T2 chan int
-	//
-	//  var x T1
-	//  // Invalid assignment because both types are named
-	//  var _ T2 = x
-	_InvalidChanAssign
-
-	// _IncompatibleAssign occurs when the type of the right-hand side expression
-	// in an assignment cannot be assigned to the type of the variable being
-	// assigned.
-	//
-	// Example:
-	//  var x []int
-	//  var _ int = x
-	_IncompatibleAssign
-
-	// _UnaddressableFieldAssign occurs when trying to assign to a struct field
-	// in a map value.
-	//
-	// Example:
-	//  func f() {
-	//  	m := make(map[string]struct{i int})
-	//  	m["foo"].i = 42
-	//  }
-	_UnaddressableFieldAssign
-
-	// _NotAType occurs when the identifier used as the underlying type in a type
-	// declaration or the right-hand side of a type alias does not denote a type.
-	//
-	// Example:
-	//  var S = 2
-	//
-	//  type T S
-	_NotAType
-
-	// _InvalidArrayLen occurs when an array length is not a constant value.
-	//
-	// Example:
-	//  var n = 3
-	//  var _ = [n]int{}
-	_InvalidArrayLen
-
-	// _BlankIfaceMethod occurs when a method name is '_'.
-	//
-	// Per the spec:
-	//  "The name of each explicitly specified method must be unique and not
-	//  blank."
-	//
-	// Example:
-	//  type T interface {
-	//  	_(int)
-	//  }
-	_BlankIfaceMethod
-
-	// _IncomparableMapKey occurs when a map key type does not support the == and
-	// != operators.
-	//
-	// Per the spec:
-	//  "The comparison operators == and != must be fully defined for operands of
-	//  the key type; thus the key type must not be a function, map, or slice."
-	//
-	// Example:
-	//  var x map[T]int
-	//
-	//  type T []int
-	_IncomparableMapKey
-
-	// _InvalidIfaceEmbed occurs when a non-interface type is embedded in an
-	// interface (for go 1.17 or earlier).
-	_ // not used anymore
-
-	// _InvalidPtrEmbed occurs when an embedded field is of the pointer form *T,
-	// and T itself is itself a pointer, an unsafe.Pointer, or an interface.
-	//
-	// Per the spec:
-	//  "An embedded field must be specified as a type name T or as a pointer to
-	//  a non-interface type name *T, and T itself may not be a pointer type."
-	//
-	// Example:
-	//  type T *int
-	//
-	//  type S struct {
-	//  	*T
-	//  }
-	_InvalidPtrEmbed
-
-	// _BadRecv occurs when a method declaration does not have exactly one
-	// receiver parameter.
-	//
-	// Example:
-	//  func () _() {}
-	_BadRecv
-
-	// _InvalidRecv occurs when a receiver type expression is not of the form T
-	// or *T, or T is a pointer type.
-	//
-	// Example:
-	//  type T struct {}
-	//
-	//  func (**T) m() {}
-	_InvalidRecv
-
-	// _DuplicateFieldAndMethod occurs when an identifier appears as both a field
-	// and method name.
-	//
-	// Example:
-	//  type T struct {
-	//  	m int
-	//  }
-	//
-	//  func (T) m() {}
-	_DuplicateFieldAndMethod
-
-	// _DuplicateMethod occurs when two methods on the same receiver type have
-	// the same name.
-	//
-	// Example:
-	//  type T struct {}
-	//  func (T) m() {}
-	//  func (T) m(i int) int { return i }
-	_DuplicateMethod
-
-	// _InvalidBlank occurs when a blank identifier is used as a value or type.
-	//
-	// Per the spec:
-	//  "The blank identifier may appear as an operand only on the left-hand side
-	//  of an assignment."
-	//
-	// Example:
-	//  var x = _
-	_InvalidBlank
-
-	// _InvalidIota occurs when the predeclared identifier iota is used outside
-	// of a constant declaration.
-	//
-	// Example:
-	//  var x = iota
-	_InvalidIota
-
-	// _MissingInitBody occurs when an init function is missing its body.
-	//
-	// Example:
-	//  func init()
-	_MissingInitBody
-
-	// _InvalidInitSig occurs when an init function declares parameters or
-	// results.
-	//
-	// Deprecated: no longer emitted by the type checker. _InvalidInitDecl is
-	// used instead.
-	_InvalidInitSig
-
-	// _InvalidInitDecl occurs when init is declared as anything other than a
-	// function.
-	//
-	// Example:
-	//  var init = 1
-	//
-	// Example:
-	//  func init() int { return 1 }
-	_InvalidInitDecl
-
-	// _InvalidMainDecl occurs when main is declared as anything other than a
-	// function, in a main package.
-	_InvalidMainDecl
-
-	// _TooManyValues occurs when a function returns too many values for the
-	// expression context in which it is used.
-	//
-	// Example:
-	//  func ReturnTwo() (int, int) {
-	//  	return 1, 2
-	//  }
-	//
-	//  var x = ReturnTwo()
-	_TooManyValues
-
-	// _NotAnExpr occurs when a type expression is used where a value expression
-	// is expected.
-	//
-	// Example:
-	//  type T struct {}
-	//
-	//  func f() {
-	//  	T
-	//  }
-	_NotAnExpr
-
-	// _TruncatedFloat occurs when a float constant is truncated to an integer
-	// value.
-	//
-	// Example:
-	//  var _ int = 98.6
-	_TruncatedFloat
-
-	// _NumericOverflow occurs when a numeric constant overflows its target type.
-	//
-	// Example:
-	//  var x int8 = 1000
-	_NumericOverflow
-
-	// _UndefinedOp occurs when an operator is not defined for the type(s) used
-	// in an operation.
-	//
-	// Example:
-	//  var c = "a" - "b"
-	_UndefinedOp
-
-	// _MismatchedTypes occurs when operand types are incompatible in a binary
-	// operation.
-	//
-	// Example:
-	//  var a = "hello"
-	//  var b = 1
-	//  var c = a - b
-	_MismatchedTypes
-
-	// _DivByZero occurs when a division operation is provable at compile
-	// time to be a division by zero.
-	//
-	// Example:
-	//  const divisor = 0
-	//  var x int = 1/divisor
-	_DivByZero
-
-	// _NonNumericIncDec occurs when an increment or decrement operator is
-	// applied to a non-numeric value.
-	//
-	// Example:
-	//  func f() {
-	//  	var c = "c"
-	//  	c++
-	//  }
-	_NonNumericIncDec
-
-	// _UnaddressableOperand occurs when the & operator is applied to an
-	// unaddressable expression.
-	//
-	// Example:
-	//  var x = &1
-	_UnaddressableOperand
-
-	// _InvalidIndirection occurs when a non-pointer value is indirected via the
-	// '*' operator.
-	//
-	// Example:
-	//  var x int
-	//  var y = *x
-	_InvalidIndirection
-
-	// _NonIndexableOperand occurs when an index operation is applied to a value
-	// that cannot be indexed.
-	//
-	// Example:
-	//  var x = 1
-	//  var y = x[1]
-	_NonIndexableOperand
-
-	// _InvalidIndex occurs when an index argument is not of integer type,
-	// negative, or out-of-bounds.
-	//
-	// Example:
-	//  var s = [...]int{1,2,3}
-	//  var x = s[5]
-	//
-	// Example:
-	//  var s = []int{1,2,3}
-	//  var _ = s[-1]
-	//
-	// Example:
-	//  var s = []int{1,2,3}
-	//  var i string
-	//  var _ = s[i]
-	_InvalidIndex
-
-	// _SwappedSliceIndices occurs when constant indices in a slice expression
-	// are decreasing in value.
-	//
-	// Example:
-	//  var _ = []int{1,2,3}[2:1]
-	_SwappedSliceIndices
-
-	// _NonSliceableOperand occurs when a slice operation is applied to a value
-	// whose type is not sliceable, or is unaddressable.
-	//
-	// Example:
-	//  var x = [...]int{1, 2, 3}[:1]
-	//
-	// Example:
-	//  var x = 1
-	//  var y = 1[:1]
-	_NonSliceableOperand
-
-	// _InvalidSliceExpr occurs when a three-index slice expression (a[x:y:z]) is
-	// applied to a string.
-	//
-	// Example:
-	//  var s = "hello"
-	//  var x = s[1:2:3]
-	_InvalidSliceExpr
-
-	// _InvalidShiftCount occurs when the right-hand side of a shift operation is
-	// either non-integer, negative, or too large.
-	//
-	// Example:
-	//  var (
-	//  	x string
-	//  	y int = 1 << x
-	//  )
-	_InvalidShiftCount
-
-	// _InvalidShiftOperand occurs when the shifted operand is not an integer.
-	//
-	// Example:
-	//  var s = "hello"
-	//  var x = s << 2
-	_InvalidShiftOperand
-
-	// _InvalidReceive occurs when there is a channel receive from a value that
-	// is either not a channel, or is a send-only channel.
-	//
-	// Example:
-	//  func f() {
-	//  	var x = 1
-	//  	<-x
-	//  }
-	_InvalidReceive
-
-	// _InvalidSend occurs when there is a channel send to a value that is not a
-	// channel, or is a receive-only channel.
-	//
-	// Example:
-	//  func f() {
-	//  	var x = 1
-	//  	x <- "hello!"
-	//  }
-	_InvalidSend
-
-	// _DuplicateLitKey occurs when an index is duplicated in a slice, array, or
-	// map literal.
-	//
-	// Example:
-	//  var _ = []int{0:1, 0:2}
-	//
-	// Example:
-	//  var _ = map[string]int{"a": 1, "a": 2}
-	_DuplicateLitKey
-
-	// _MissingLitKey occurs when a map literal is missing a key expression.
-	//
-	// Example:
-	//  var _ = map[string]int{1}
-	_MissingLitKey
-
-	// _InvalidLitIndex occurs when the key in a key-value element of a slice or
-	// array literal is not an integer constant.
-	//
-	// Example:
-	//  var i = 0
-	//  var x = []string{i: "world"}
-	_InvalidLitIndex
-
-	// _OversizeArrayLit occurs when an array literal exceeds its length.
-	//
-	// Example:
-	//  var _ = [2]int{1,2,3}
-	_OversizeArrayLit
-
-	// _MixedStructLit occurs when a struct literal contains a mix of positional
-	// and named elements.
-	//
-	// Example:
-	//  var _ = struct{i, j int}{i: 1, 2}
-	_MixedStructLit
-
-	// _InvalidStructLit occurs when a positional struct literal has an incorrect
-	// number of values.
-	//
-	// Example:
-	//  var _ = struct{i, j int}{1,2,3}
-	_InvalidStructLit
-
-	// _MissingLitField occurs when a struct literal refers to a field that does
-	// not exist on the struct type.
-	//
-	// Example:
-	//  var _ = struct{i int}{j: 2}
-	_MissingLitField
-
-	// _DuplicateLitField occurs when a struct literal contains duplicated
-	// fields.
-	//
-	// Example:
-	//  var _ = struct{i int}{i: 1, i: 2}
-	_DuplicateLitField
-
-	// _UnexportedLitField occurs when a positional struct literal implicitly
-	// assigns an unexported field of an imported type.
-	_UnexportedLitField
-
-	// _InvalidLitField occurs when a field name is not a valid identifier.
-	//
-	// Example:
-	//  var _ = struct{i int}{1: 1}
-	_InvalidLitField
-
-	// _UntypedLit occurs when a composite literal omits a required type
-	// identifier.
-	//
-	// Example:
-	//  type outer struct{
-	//  	inner struct { i int }
-	//  }
-	//
-	//  var _ = outer{inner: {1}}
-	_UntypedLit
-
-	// _InvalidLit occurs when a composite literal expression does not match its
-	// type.
-	//
-	// Example:
-	//  type P *struct{
-	//  	x int
-	//  }
-	//  var _ = P {}
-	_InvalidLit
-
-	// _AmbiguousSelector occurs when a selector is ambiguous.
-	//
-	// Example:
-	//  type E1 struct { i int }
-	//  type E2 struct { i int }
-	//  type T struct { E1; E2 }
-	//
-	//  var x T
-	//  var _ = x.i
-	_AmbiguousSelector
-
-	// _UndeclaredImportedName occurs when a package-qualified identifier is
-	// undeclared by the imported package.
-	//
-	// Example:
-	//  import "go/types"
-	//
-	//  var _ = types.NotAnActualIdentifier
-	_UndeclaredImportedName
-
-	// _UnexportedName occurs when a selector refers to an unexported identifier
-	// of an imported package.
-	//
-	// Example:
-	//  import "reflect"
-	//
-	//  type _ reflect.flag
-	_UnexportedName
-
-	// _UndeclaredName occurs when an identifier is not declared in the current
-	// scope.
-	//
-	// Example:
-	//  var x T
-	_UndeclaredName
-
-	// _MissingFieldOrMethod occurs when a selector references a field or method
-	// that does not exist.
-	//
-	// Example:
-	//  type T struct {}
-	//
-	//  var x = T{}.f
-	_MissingFieldOrMethod
-
-	// _BadDotDotDotSyntax occurs when a "..." occurs in a context where it is
-	// not valid.
-	//
-	// Example:
-	//  var _ = map[int][...]int{0: {}}
-	_BadDotDotDotSyntax
-
-	// _NonVariadicDotDotDot occurs when a "..." is used on the final argument to
-	// a non-variadic function.
-	//
-	// Example:
-	//  func printArgs(s []string) {
-	//  	for _, a := range s {
-	//  		println(a)
-	//  	}
-	//  }
-	//
-	//  func f() {
-	//  	s := []string{"a", "b", "c"}
-	//  	printArgs(s...)
-	//  }
-	_NonVariadicDotDotDot
-
-	// _MisplacedDotDotDot occurs when a "..." is used somewhere other than the
-	// final argument in a function declaration.
-	//
-	// Example:
-	// 	func f(...int, int)
-	_MisplacedDotDotDot
-
-	_ // _InvalidDotDotDotOperand was removed.
-
-	// _InvalidDotDotDot occurs when a "..." is used in a non-variadic built-in
-	// function.
-	//
-	// Example:
-	//  var s = []int{1, 2, 3}
-	//  var l = len(s...)
-	_InvalidDotDotDot
-
-	// _UncalledBuiltin occurs when a built-in function is used as a
-	// function-valued expression, instead of being called.
-	//
-	// Per the spec:
-	//  "The built-in functions do not have standard Go types, so they can only
-	//  appear in call expressions; they cannot be used as function values."
-	//
-	// Example:
-	//  var _ = copy
-	_UncalledBuiltin
-
-	// _InvalidAppend occurs when append is called with a first argument that is
-	// not a slice.
-	//
-	// Example:
-	//  var _ = append(1, 2)
-	_InvalidAppend
-
-	// _InvalidCap occurs when an argument to the cap built-in function is not of
-	// supported type.
-	//
-	// See https://golang.org/ref/spec#Length_and_capacity for information on
-	// which underlying types are supported as arguments to cap and len.
-	//
-	// Example:
-	//  var s = 2
-	//  var x = cap(s)
-	_InvalidCap
-
-	// _InvalidClose occurs when close(...) is called with an argument that is
-	// not of channel type, or that is a receive-only channel.
-	//
-	// Example:
-	//  func f() {
-	//  	var x int
-	//  	close(x)
-	//  }
-	_InvalidClose
-
-	// _InvalidCopy occurs when the arguments are not of slice type or do not
-	// have compatible type.
-	//
-	// See https://golang.org/ref/spec#Appending_and_copying_slices for more
-	// information on the type requirements for the copy built-in.
-	//
-	// Example:
-	//  func f() {
-	//  	var x []int
-	//  	y := []int64{1,2,3}
-	//  	copy(x, y)
-	//  }
-	_InvalidCopy
-
-	// _InvalidComplex occurs when the complex built-in function is called with
-	// arguments with incompatible types.
-	//
-	// Example:
-	//  var _ = complex(float32(1), float64(2))
-	_InvalidComplex
-
-	// _InvalidDelete occurs when the delete built-in function is called with a
-	// first argument that is not a map.
-	//
-	// Example:
-	//  func f() {
-	//  	m := "hello"
-	//  	delete(m, "e")
-	//  }
-	_InvalidDelete
-
-	// _InvalidImag occurs when the imag built-in function is called with an
-	// argument that does not have complex type.
-	//
-	// Example:
-	//  var _ = imag(int(1))
-	_InvalidImag
-
-	// _InvalidLen occurs when an argument to the len built-in function is not of
-	// supported type.
-	//
-	// See https://golang.org/ref/spec#Length_and_capacity for information on
-	// which underlying types are supported as arguments to cap and len.
-	//
-	// Example:
-	//  var s = 2
-	//  var x = len(s)
-	_InvalidLen
-
-	// _SwappedMakeArgs occurs when make is called with three arguments, and its
-	// length argument is larger than its capacity argument.
-	//
-	// Example:
-	//  var x = make([]int, 3, 2)
-	_SwappedMakeArgs
-
-	// _InvalidMake occurs when make is called with an unsupported type argument.
-	//
-	// See https://golang.org/ref/spec#Making_slices_maps_and_channels for
-	// information on the types that may be created using make.
-	//
-	// Example:
-	//  var x = make(int)
-	_InvalidMake
-
-	// _InvalidReal occurs when the real built-in function is called with an
-	// argument that does not have complex type.
-	//
-	// Example:
-	//  var _ = real(int(1))
-	_InvalidReal
-
-	// _InvalidAssert occurs when a type assertion is applied to a
-	// value that is not of interface type.
-	//
-	// Example:
-	//  var x = 1
-	//  var _ = x.(float64)
-	_InvalidAssert
-
-	// _ImpossibleAssert occurs for a type assertion x.(T) when the value x of
-	// interface cannot have dynamic type T, due to a missing or mismatching
-	// method on T.
-	//
-	// Example:
-	//  type T int
-	//
-	//  func (t *T) m() int { return int(*t) }
-	//
-	//  type I interface { m() int }
-	//
-	//  var x I
-	//  var _ = x.(T)
-	_ImpossibleAssert
-
-	// _InvalidConversion occurs when the argument type cannot be converted to the
-	// target.
-	//
-	// See https://golang.org/ref/spec#Conversions for the rules of
-	// convertibility.
-	//
-	// Example:
-	//  var x float64
-	//  var _ = string(x)
-	_InvalidConversion
-
-	// _InvalidUntypedConversion occurs when there is no valid implicit
-	// conversion from an untyped value satisfying the type constraints of the
-	// context in which it is used.
-	//
-	// Example:
-	//  var _ = 1 + new(int)
-	_InvalidUntypedConversion
-
-	// _BadOffsetofSyntax occurs when unsafe.Offsetof is called with an argument
-	// that is not a selector expression.
-	//
-	// Example:
-	//  import "unsafe"
-	//
-	//  var x int
-	//  var _ = unsafe.Offsetof(x)
-	_BadOffsetofSyntax
-
-	// _InvalidOffsetof occurs when unsafe.Offsetof is called with a method
-	// selector, rather than a field selector, or when the field is embedded via
-	// a pointer.
-	//
-	// Per the spec:
-	//
-	//  "If f is an embedded field, it must be reachable without pointer
-	//  indirections through fields of the struct. "
-	//
-	// Example:
-	//  import "unsafe"
-	//
-	//  type T struct { f int }
-	//  type S struct { *T }
-	//  var s S
-	//  var _ = unsafe.Offsetof(s.f)
-	//
-	// Example:
-	//  import "unsafe"
-	//
-	//  type S struct{}
-	//
-	//  func (S) m() {}
-	//
-	//  var s S
-	//  var _ = unsafe.Offsetof(s.m)
-	_InvalidOffsetof
-
-	// _UnusedExpr occurs when a side-effect free expression is used as a
-	// statement. Such a statement has no effect.
-	//
-	// Example:
-	//  func f(i int) {
-	//  	i*i
-	//  }
-	_UnusedExpr
-
-	// _UnusedVar occurs when a variable is declared but unused.
-	//
-	// Example:
-	//  func f() {
-	//  	x := 1
-	//  }
-	_UnusedVar
-
-	// _MissingReturn occurs when a function with results is missing a return
-	// statement.
-	//
-	// Example:
-	//  func f() int {}
-	_MissingReturn
-
-	// _WrongResultCount occurs when a return statement returns an incorrect
-	// number of values.
-	//
-	// Example:
-	//  func ReturnOne() int {
-	//  	return 1, 2
-	//  }
-	_WrongResultCount
-
-	// _OutOfScopeResult occurs when the name of a value implicitly returned by
-	// an empty return statement is shadowed in a nested scope.
-	//
-	// Example:
-	//  func factor(n int) (i int) {
-	//  	for i := 2; i < n; i++ {
-	//  		if n%i == 0 {
-	//  			return
-	//  		}
-	//  	}
-	//  	return 0
-	//  }
-	_OutOfScopeResult
-
-	// _InvalidCond occurs when an if condition is not a boolean expression.
-	//
-	// Example:
-	//  func checkReturn(i int) {
-	//  	if i {
-	//  		panic("non-zero return")
-	//  	}
-	//  }
-	_InvalidCond
-
-	// _InvalidPostDecl occurs when there is a declaration in a for-loop post
-	// statement.
-	//
-	// Example:
-	//  func f() {
-	//  	for i := 0; i < 10; j := 0 {}
-	//  }
-	_InvalidPostDecl
-
-	_ // _InvalidChanRange was removed.
-
-	// _InvalidIterVar occurs when two iteration variables are used while ranging
-	// over a channel.
-	//
-	// Example:
-	//  func f(c chan int) {
-	//  	for k, v := range c {
-	//  		println(k, v)
-	//  	}
-	//  }
-	_InvalidIterVar
-
-	// _InvalidRangeExpr occurs when the type of a range expression is not array,
-	// slice, string, map, or channel.
-	//
-	// Example:
-	//  func f(i int) {
-	//  	for j := range i {
-	//  		println(j)
-	//  	}
-	//  }
-	_InvalidRangeExpr
-
-	// _MisplacedBreak occurs when a break statement is not within a for, switch,
-	// or select statement of the innermost function definition.
-	//
-	// Example:
-	//  func f() {
-	//  	break
-	//  }
-	_MisplacedBreak
-
-	// _MisplacedContinue occurs when a continue statement is not within a for
-	// loop of the innermost function definition.
-	//
-	// Example:
-	//  func sumeven(n int) int {
-	//  	proceed := func() {
-	//  		continue
-	//  	}
-	//  	sum := 0
-	//  	for i := 1; i <= n; i++ {
-	//  		if i % 2 != 0 {
-	//  			proceed()
-	//  		}
-	//  		sum += i
-	//  	}
-	//  	return sum
-	//  }
-	_MisplacedContinue
-
-	// _MisplacedFallthrough occurs when a fallthrough statement is not within an
-	// expression switch.
-	//
-	// Example:
-	//  func typename(i interface{}) string {
-	//  	switch i.(type) {
-	//  	case int64:
-	//  		fallthrough
-	//  	case int:
-	//  		return "int"
-	//  	}
-	//  	return "unsupported"
-	//  }
-	_MisplacedFallthrough
-
-	// _DuplicateCase occurs when a type or expression switch has duplicate
-	// cases.
-	//
-	// Example:
-	//  func printInt(i int) {
-	//  	switch i {
-	//  	case 1:
-	//  		println("one")
-	//  	case 1:
-	//  		println("One")
-	//  	}
-	//  }
-	_DuplicateCase
-
-	// _DuplicateDefault occurs when a type or expression switch has multiple
-	// default clauses.
-	//
-	// Example:
-	//  func printInt(i int) {
-	//  	switch i {
-	//  	case 1:
-	//  		println("one")
-	//  	default:
-	//  		println("One")
-	//  	default:
-	//  		println("1")
-	//  	}
-	//  }
-	_DuplicateDefault
-
-	// _BadTypeKeyword occurs when a .(type) expression is used anywhere other
-	// than a type switch.
-	//
-	// Example:
-	//  type I interface {
-	//  	m()
-	//  }
-	//  var t I
-	//  var _ = t.(type)
-	_BadTypeKeyword
-
-	// _InvalidTypeSwitch occurs when .(type) is used on an expression that is
-	// not of interface type.
-	//
-	// Example:
-	//  func f(i int) {
-	//  	switch x := i.(type) {}
-	//  }
-	_InvalidTypeSwitch
-
-	// _InvalidExprSwitch occurs when a switch expression is not comparable.
-	//
-	// Example:
-	//  func _() {
-	//  	var a struct{ _ func() }
-	//  	switch a /* ERROR cannot switch on a */ {
-	//  	}
-	//  }
-	_InvalidExprSwitch
-
-	// _InvalidSelectCase occurs when a select case is not a channel send or
-	// receive.
-	//
-	// Example:
-	//  func checkChan(c <-chan int) bool {
-	//  	select {
-	//  	case c:
-	//  		return true
-	//  	default:
-	//  		return false
-	//  	}
-	//  }
-	_InvalidSelectCase
-
-	// _UndeclaredLabel occurs when an undeclared label is jumped to.
-	//
-	// Example:
-	//  func f() {
-	//  	goto L
-	//  }
-	_UndeclaredLabel
-
-	// _DuplicateLabel occurs when a label is declared more than once.
-	//
-	// Example:
-	//  func f() int {
-	//  L:
-	//  L:
-	//  	return 1
-	//  }
-	_DuplicateLabel
-
-	// _MisplacedLabel occurs when a break or continue label is not on a for,
-	// switch, or select statement.
-	//
-	// Example:
-	//  func f() {
-	//  L:
-	//  	a := []int{1,2,3}
-	//  	for _, e := range a {
-	//  		if e > 10 {
-	//  			break L
-	//  		}
-	//  		println(a)
-	//  	}
-	//  }
-	_MisplacedLabel
-
-	// _UnusedLabel occurs when a label is declared and not used.
-	//
-	// Example:
-	//  func f() {
-	//  L:
-	//  }
-	_UnusedLabel
-
-	// _JumpOverDecl occurs when a label jumps over a variable declaration.
-	//
-	// Example:
-	//  func f() int {
-	//  	goto L
-	//  	x := 2
-	//  L:
-	//  	x++
-	//  	return x
-	//  }
-	_JumpOverDecl
-
-	// _JumpIntoBlock occurs when a forward jump goes to a label inside a nested
-	// block.
-	//
-	// Example:
-	//  func f(x int) {
-	//  	goto L
-	//  	if x > 0 {
-	//  	L:
-	//  		print("inside block")
-	//  	}
-	// }
-	_JumpIntoBlock
-
-	// _InvalidMethodExpr occurs when a pointer method is called but the argument
-	// is not addressable.
-	//
-	// Example:
-	//  type T struct {}
-	//
-	//  func (*T) m() int { return 1 }
-	//
-	//  var _ = T.m(T{})
-	_InvalidMethodExpr
-
-	// _WrongArgCount occurs when too few or too many arguments are passed by a
-	// function call.
-	//
-	// Example:
-	//  func f(i int) {}
-	//  var x = f()
-	_WrongArgCount
-
-	// _InvalidCall occurs when an expression is called that is not of function
-	// type.
-	//
-	// Example:
-	//  var x = "x"
-	//  var y = x()
-	_InvalidCall
-
-	// _UnusedResults occurs when a restricted expression-only built-in function
-	// is suspended via go or defer. Such a suspension discards the results of
-	// these side-effect free built-in functions, and therefore is ineffectual.
-	//
-	// Example:
-	//  func f(a []int) int {
-	//  	defer len(a)
-	//  	return i
-	//  }
-	_UnusedResults
-
-	// _InvalidDefer occurs when a deferred expression is not a function call,
-	// for example if the expression is a type conversion.
-	//
-	// Example:
-	//  func f(i int) int {
-	//  	defer int32(i)
-	//  	return i
-	//  }
-	_InvalidDefer
-
-	// _InvalidGo occurs when a go expression is not a function call, for example
-	// if the expression is a type conversion.
-	//
-	// Example:
-	//  func f(i int) int {
-	//  	go int32(i)
-	//  	return i
-	//  }
-	_InvalidGo
-
-	// All codes below were added in Go 1.17.
-
-	// _BadDecl occurs when a declaration has invalid syntax.
-	_BadDecl
-
-	// _RepeatedDecl occurs when an identifier occurs more than once on the left
-	// hand side of a short variable declaration.
-	//
-	// Example:
-	//  func _() {
-	//  	x, y, y := 1, 2, 3
-	//  }
-	_RepeatedDecl
-
-	// _InvalidUnsafeAdd occurs when unsafe.Add is called with a
-	// length argument that is not of integer type.
-	// It also occurs if it is used in a package compiled for a
-	// language version before go1.17.
-	//
-	// Example:
-	//  import "unsafe"
-	//
-	//  var p unsafe.Pointer
-	//  var _ = unsafe.Add(p, float64(1))
-	_InvalidUnsafeAdd
-
-	// _InvalidUnsafeSlice occurs when unsafe.Slice is called with a
-	// pointer argument that is not of pointer type or a length argument
-	// that is not of integer type, negative, or out of bounds.
-	// It also occurs if it is used in a package compiled for a language
-	// version before go1.17.
-	//
-	// Example:
-	//  import "unsafe"
-	//
-	//  var x int
-	//  var _ = unsafe.Slice(x, 1)
-	//
-	// Example:
-	//  import "unsafe"
-	//
-	//  var x int
-	//  var _ = unsafe.Slice(&x, float64(1))
-	//
-	// Example:
-	//  import "unsafe"
-	//
-	//  var x int
-	//  var _ = unsafe.Slice(&x, -1)
-	//
-	// Example:
-	//  import "unsafe"
-	//
-	//  var x int
-	//  var _ = unsafe.Slice(&x, uint64(1) << 63)
-	_InvalidUnsafeSlice
-
-	// All codes below were added in Go 1.18.
-
-	// _UnsupportedFeature occurs when a language feature is used that is not
-	// supported at this Go version.
-	_UnsupportedFeature
-
-	// _NotAGenericType occurs when a non-generic type is used where a generic
-	// type is expected: in type or function instantiation.
-	//
-	// Example:
-	//  type T int
-	//
-	//  var _ T[int]
-	_NotAGenericType
-
-	// _WrongTypeArgCount occurs when a type or function is instantiated with an
-	// incorrent number of type arguments, including when a generic type or
-	// function is used without instantiation.
-	//
-	// Errors inolving failed type inference are assigned other error codes.
-	//
-	// Example:
-	//  type T[p any] int
-	//
-	//  var _ T[int, string]
-	//
-	// Example:
-	//  func f[T any]() {}
-	//
-	//  var x = f
-	_WrongTypeArgCount
-
-	// _CannotInferTypeArgs occurs when type or function type argument inference
-	// fails to infer all type arguments.
-	//
-	// Example:
-	//  func f[T any]() {}
-	//
-	//  func _() {
-	//  	f()
-	//  }
-	_CannotInferTypeArgs
-
-	// _InvalidTypeArg occurs when a type argument does not satisfy its
-	// corresponding type parameter constraints.
-	//
-	// Example:
-	//  type T[P ~int] struct{}
-	//
-	//  var _ T[string]
-	_InvalidTypeArg // arguments? InferenceFailed
-
-	// _InvalidInstanceCycle occurs when an invalid cycle is detected
-	// within the instantiation graph.
-	//
-	// Example:
-	//  func f[T any]() { f[*T]() }
-	_InvalidInstanceCycle
-
-	// _InvalidUnion occurs when an embedded union or approximation element is
-	// not valid.
-	//
-	// Example:
-	//  type _ interface {
-	//   	~int | interface{ m() }
-	//  }
-	_InvalidUnion
-
-	// _MisplacedConstraintIface occurs when a constraint-type interface is used
-	// outside of constraint position.
-	//
-	// Example:
-	//   type I interface { ~int }
-	//
-	//   var _ I
-	_MisplacedConstraintIface
-
-	// _InvalidMethodTypeParams occurs when methods have type parameters.
-	//
-	// It cannot be encountered with an AST parsed using go/parser.
-	_InvalidMethodTypeParams
-
-	// _MisplacedTypeParam occurs when a type parameter is used in a place where
-	// it is not permitted.
-	//
-	// Example:
-	//  type T[P any] P
-	//
-	// Example:
-	//  type T[P any] struct{ *P }
-	_MisplacedTypeParam
-
-	// _InvalidUnsafeSliceData occurs when unsafe.SliceData is called with
-	// an argument that is not of slice type. It also occurs if it is used
-	// in a package compiled for a language version before go1.20.
-	//
-	// Example:
-	//  import "unsafe"
-	//
-	//  var x int
-	//  var _ = unsafe.SliceData(x)
-	_InvalidUnsafeSliceData
-
-	// _InvalidUnsafeString occurs when unsafe.String is called with
-	// a length argument that is not of integer type, negative, or
-	// out of bounds. It also occurs if it is used in a package
-	// compiled for a language version before go1.20.
-	//
-	// Example:
-	//  import "unsafe"
-	//
-	//  var b [10]byte
-	//  var _ = unsafe.String(&b[0], -1)
-	_InvalidUnsafeString
-
-	// _InvalidUnsafeStringData occurs if it is used in a package
-	// compiled for a language version before go1.20.
-	_ // not used anymore
-)
diff --git a/src/cmd/compile/internal/types2/errors.go b/src/cmd/compile/internal/types2/errors.go
index 0906a1b45c..ab9e483681 100644
--- a/src/cmd/compile/internal/types2/errors.go
+++ b/src/cmd/compile/internal/types2/errors.go
@@ -10,6 +10,7 @@ import (
 	"bytes"
 	"cmd/compile/internal/syntax"
 	"fmt"
+	. "internal/types/errors"
 	"runtime"
 	"strconv"
 	"strings"
@@ -35,7 +36,7 @@ func unreachable() {
 // To report an error_, call Checker.report.
 type error_ struct {
 	desc []errorDesc
-	code errorCode
+	code Code
 	soft bool // TODO(gri) eventually determine this from an error code
 }
 
@@ -219,7 +220,7 @@ func (check *Checker) dump(format string, args ...interface{}) {
 	fmt.Println(sprintf(check.qualifier, true, format, args...))
 }
 
-func (check *Checker) err(at poser, code errorCode, msg string, soft bool) {
+func (check *Checker) err(at poser, code Code, msg string, soft bool) {
 	// Cheap trick: Don't report errors with messages containing
 	// "invalid operand" or "invalid type" as those tend to be
 	// follow-on errors which don't add useful information. Only
@@ -268,22 +269,22 @@ type poser interface {
 	Pos() syntax.Pos
 }
 
-func (check *Checker) error(at poser, code errorCode, msg string) {
+func (check *Checker) error(at poser, code Code, msg string) {
 	check.err(at, code, msg, false)
 }
 
-func (check *Checker) errorf(at poser, code errorCode, format string, args ...interface{}) {
+func (check *Checker) errorf(at poser, code Code, format string, args ...interface{}) {
 	check.err(at, code, check.sprintf(format, args...), false)
 }
 
-func (check *Checker) softErrorf(at poser, code errorCode, format string, args ...interface{}) {
+func (check *Checker) softErrorf(at poser, code Code, format string, args ...interface{}) {
 	check.err(at, code, check.sprintf(format, args...), true)
 }
 
 func (check *Checker) versionErrorf(at poser, goVersion string, format string, args ...interface{}) {
 	msg := check.sprintf(format, args...)
 	msg = fmt.Sprintf("%s requires %s or later", msg, goVersion)
-	check.err(at, _UnsupportedFeature, msg, true)
+	check.err(at, UnsupportedFeature, msg, true)
 }
 
 // posFor reports the left (= start) position of at.
diff --git a/src/cmd/compile/internal/types2/expr.go b/src/cmd/compile/internal/types2/expr.go
index 23592a86c7..03040ae1b1 100644
--- a/src/cmd/compile/internal/types2/expr.go
+++ b/src/cmd/compile/internal/types2/expr.go
@@ -11,6 +11,7 @@ import (
 	"fmt"
 	"go/constant"
 	"go/token"
+	. "internal/types/errors"
 	"math"
 )
 
@@ -73,7 +74,7 @@ func init() {
 func (check *Checker) op(m opPredicates, x *operand, op syntax.Operator) bool {
 	if pred := m[op]; pred != nil {
 		if !pred(x.typ) {
-			check.errorf(x, _UndefinedOp, invalidOp+"operator %s not defined on %s", op, x)
+			check.errorf(x, UndefinedOp, invalidOp+"operator %s not defined on %s", op, x)
 			return false
 		}
 	} else {
@@ -93,7 +94,7 @@ func (check *Checker) overflow(x *operand) {
 		// TODO(gri) We should report exactly what went wrong. At the
 		//           moment we don't have the (go/constant) API for that.
 		//           See also TODO in go/constant/value.go.
-		check.error(opPos(x.expr), _InvalidConstVal, "constant result is not representable")
+		check.error(opPos(x.expr), InvalidConstVal, "constant result is not representable")
 		return
 	}
 
@@ -113,7 +114,7 @@ func (check *Checker) overflow(x *operand) {
 		if op != "" {
 			op += " "
 		}
-		check.errorf(opPos(x.expr), _InvalidConstVal, "constant %soverflow", op)
+		check.errorf(opPos(x.expr), InvalidConstVal, "constant %soverflow", op)
 		x.val = constant.MakeUnknown()
 	}
 }
@@ -182,7 +183,7 @@ func (check *Checker) unary(x *operand, e *syntax.Operation) {
 		// spec: "As an exception to the addressability
 		// requirement x may also be a composite literal."
 		if _, ok := unparen(e.X).(*syntax.CompositeLit); !ok && x.mode != variable {
-			check.errorf(x, _UnaddressableOperand, invalidOp+"cannot take address of %s", x)
+			check.errorf(x, UnaddressableOperand, invalidOp+"cannot take address of %s", x)
 			x.mode = invalid
 			return
 		}
@@ -193,18 +194,18 @@ func (check *Checker) unary(x *operand, e *syntax.Operation) {
 	case syntax.Recv:
 		u := coreType(x.typ)
 		if u == nil {
-			check.errorf(x, _InvalidReceive, invalidOp+"cannot receive from %s (no core type)", x)
+			check.errorf(x, InvalidReceive, invalidOp+"cannot receive from %s (no core type)", x)
 			x.mode = invalid
 			return
 		}
 		ch, _ := u.(*Chan)
 		if ch == nil {
-			check.errorf(x, _InvalidReceive, invalidOp+"cannot receive from non-channel %s", x)
+			check.errorf(x, InvalidReceive, invalidOp+"cannot receive from non-channel %s", x)
 			x.mode = invalid
 			return
 		}
 		if ch.dir == SendOnly {
-			check.errorf(x, _InvalidReceive, invalidOp+"cannot receive from send-only channel %s", x)
+			check.errorf(x, InvalidReceive, invalidOp+"cannot receive from send-only channel %s", x)
 			x.mode = invalid
 			return
 		}
@@ -215,7 +216,7 @@ func (check *Checker) unary(x *operand, e *syntax.Operation) {
 
 	case syntax.Tilde:
 		// Provide a better error position and message than what check.op below could do.
-		check.error(e, _UndefinedOp, "cannot use ~ outside of interface or type constraint")
+		check.error(e, UndefinedOp, "cannot use ~ outside of interface or type constraint")
 		x.mode = invalid
 		return
 	}
@@ -452,7 +453,7 @@ func (check *Checker) representable(x *operand, typ *Basic) {
 // basic type typ.
 //
 // If no such representation is possible, it returns a non-zero error code.
-func (check *Checker) representation(x *operand, typ *Basic) (constant.Value, errorCode) {
+func (check *Checker) representation(x *operand, typ *Basic) (constant.Value, Code) {
 	assert(x.mode == constant_)
 	v := x.val
 	if !representableConst(x.val, check, typ, &v) {
@@ -465,22 +466,22 @@ func (check *Checker) representation(x *operand, typ *Basic) (constant.Value, er
 			// float   -> float   : overflows
 			//
 			if !isInteger(x.typ) && isInteger(typ) {
-				return nil, _TruncatedFloat
+				return nil, TruncatedFloat
 			} else {
-				return nil, _NumericOverflow
+				return nil, NumericOverflow
 			}
 		}
-		return nil, _InvalidConstVal
+		return nil, InvalidConstVal
 	}
 	return v, 0
 }
 
-func (check *Checker) invalidConversion(code errorCode, x *operand, target Type) {
+func (check *Checker) invalidConversion(code Code, x *operand, target Type) {
 	msg := "cannot convert %s to type %s"
 	switch code {
-	case _TruncatedFloat:
+	case TruncatedFloat:
 		msg = "%s truncated to %s"
-	case _NumericOverflow:
+	case NumericOverflow:
 		msg = "%s overflows %s"
 	}
 	check.errorf(x, code, msg, x, target)
@@ -616,7 +617,7 @@ func (check *Checker) updateExprType0(parent, x syntax.Expr, typ Type, final boo
 		// We already know from the shift check that it is representable
 		// as an integer if it is a constant.
 		if !allInteger(typ) {
-			check.errorf(x, _InvalidShiftOperand, invalidOp+"shifted operand %s (type %s) must be integer", x, typ)
+			check.errorf(x, InvalidShiftOperand, invalidOp+"shifted operand %s (type %s) must be integer", x, typ)
 			return
 		}
 		// Even if we have an integer, if the value is a constant we
@@ -672,7 +673,7 @@ func (check *Checker) convertUntyped(x *operand, target Type) {
 //
 // If x is a constant operand, the returned constant.Value will be the
 // representation of x in this context.
-func (check *Checker) implicitTypeAndValue(x *operand, target Type) (Type, constant.Value, errorCode) {
+func (check *Checker) implicitTypeAndValue(x *operand, target Type) (Type, constant.Value, Code) {
 	if x.mode == invalid || isTyped(x.typ) || target == Typ[Invalid] {
 		return x.typ, nil, 0
 	}
@@ -686,7 +687,7 @@ func (check *Checker) implicitTypeAndValue(x *operand, target Type) (Type, const
 				return target, nil, 0
 			}
 		} else if xkind != tkind {
-			return nil, nil, _InvalidUntypedConversion
+			return nil, nil, InvalidUntypedConversion
 		}
 		return x.typ, nil, 0
 	}
@@ -696,7 +697,7 @@ func (check *Checker) implicitTypeAndValue(x *operand, target Type) (Type, const
 		if hasNil(target) {
 			return target, nil, 0
 		}
-		return nil, nil, _InvalidUntypedConversion
+		return nil, nil, InvalidUntypedConversion
 	}
 
 	switch u := under(target).(type) {
@@ -715,21 +716,21 @@ func (check *Checker) implicitTypeAndValue(x *operand, target Type) (Type, const
 		switch x.typ.(*Basic).kind {
 		case UntypedBool:
 			if !isBoolean(target) {
-				return nil, nil, _InvalidUntypedConversion
+				return nil, nil, InvalidUntypedConversion
 			}
 		case UntypedInt, UntypedRune, UntypedFloat, UntypedComplex:
 			if !isNumeric(target) {
-				return nil, nil, _InvalidUntypedConversion
+				return nil, nil, InvalidUntypedConversion
 			}
 		case UntypedString:
 			// Non-constant untyped string values are not permitted by the spec and
 			// should not occur during normal typechecking passes, but this path is
 			// reachable via the AssignableTo API.
 			if !isString(target) {
-				return nil, nil, _InvalidUntypedConversion
+				return nil, nil, InvalidUntypedConversion
 			}
 		default:
-			return nil, nil, _InvalidUntypedConversion
+			return nil, nil, InvalidUntypedConversion
 		}
 	case *Interface:
 		if isTypeParam(target) {
@@ -740,7 +741,7 @@ func (check *Checker) implicitTypeAndValue(x *operand, target Type) (Type, const
 				t, _, _ := check.implicitTypeAndValue(x, u)
 				return t != nil
 			}) {
-				return nil, nil, _InvalidUntypedConversion
+				return nil, nil, InvalidUntypedConversion
 			}
 			break
 		}
@@ -748,11 +749,11 @@ func (check *Checker) implicitTypeAndValue(x *operand, target Type) (Type, const
 		// (interface) type: values must have concrete dynamic types.
 		// Untyped nil was handled upfront.
 		if !u.Empty() {
-			return nil, nil, _InvalidUntypedConversion // cannot assign untyped values to non-empty interfaces
+			return nil, nil, InvalidUntypedConversion // cannot assign untyped values to non-empty interfaces
 		}
 		return Default(x.typ), nil, 0 // default type for nil is nil
 	default:
-		return nil, nil, _InvalidUntypedConversion
+		return nil, nil, InvalidUntypedConversion
 	}
 	return target, nil, 0
 }
@@ -774,7 +775,7 @@ func (check *Checker) comparison(x, y *operand, op syntax.Operator, switchCase b
 
 	// spec: "In any comparison, the first operand must be assignable
 	// to the type of the second operand, or vice versa."
-	code := _MismatchedTypes
+	code := MismatchedTypes
 	ok, _ := x.assignableTo(check, y.typ, nil)
 	if !ok {
 		ok, _ = y.assignableTo(check, x.typ, nil)
@@ -789,7 +790,7 @@ func (check *Checker) comparison(x, y *operand, op syntax.Operator, switchCase b
 	}
 
 	// check if comparison is defined for operands
-	code = _UndefinedOp
+	code = UndefinedOp
 	switch op {
 	case syntax.Eql, syntax.Neq:
 		// spec: "The equality operators == and != apply to operands that are comparable."
@@ -932,7 +933,7 @@ func (check *Checker) shift(x, y *operand, e syntax.Expr, op syntax.Operator) {
 		// as an integer. Nothing to do.
 	} else {
 		// shift has no chance
-		check.errorf(x, _InvalidShiftOperand, invalidOp+"shifted operand %s must be integer", x)
+		check.errorf(x, InvalidShiftOperand, invalidOp+"shifted operand %s must be integer", x)
 		x.mode = invalid
 		return
 	}
@@ -946,7 +947,7 @@ func (check *Checker) shift(x, y *operand, e syntax.Expr, op syntax.Operator) {
 		// Provide a good error message for negative shift counts.
 		yval := constant.ToInt(y.val) // consider -1, 1.0, but not -1.1
 		if yval.Kind() == constant.Int && constant.Sign(yval) < 0 {
-			check.errorf(y, _InvalidShiftCount, invalidOp+"negative shift count %s", y)
+			check.errorf(y, InvalidShiftCount, invalidOp+"negative shift count %s", y)
 			x.mode = invalid
 			return
 		}
@@ -978,7 +979,7 @@ func (check *Checker) shift(x, y *operand, e syntax.Expr, op syntax.Operator) {
 				return
 			}
 		default:
-			check.errorf(y, _InvalidShiftCount, invalidOp+"shift count %s must be integer", y)
+			check.errorf(y, InvalidShiftCount, invalidOp+"shift count %s must be integer", y)
 			x.mode = invalid
 			return
 		}
@@ -999,7 +1000,7 @@ func (check *Checker) shift(x, y *operand, e syntax.Expr, op syntax.Operator) {
 			const shiftBound = 1023 - 1 + 52 // so we can express smallestFloat64 (see issue #44057)
 			s, ok := constant.Uint64Val(y.val)
 			if !ok || s > shiftBound {
-				check.errorf(y, _InvalidShiftCount, invalidOp+"invalid shift count %s", y)
+				check.errorf(y, InvalidShiftCount, invalidOp+"invalid shift count %s", y)
 				x.mode = invalid
 				return
 			}
@@ -1050,7 +1051,7 @@ func (check *Checker) shift(x, y *operand, e syntax.Expr, op syntax.Operator) {
 
 	// non-constant shift - lhs must be an integer
 	if !allInteger(x.typ) {
-		check.errorf(x, _InvalidShiftOperand, invalidOp+"shifted operand %s must be integer", x)
+		check.errorf(x, InvalidShiftOperand, invalidOp+"shifted operand %s must be integer", x)
 		x.mode = invalid
 		return
 	}
@@ -1142,9 +1143,9 @@ func (check *Checker) binary(x *operand, e syntax.Expr, lhs, rhs syntax.Expr, op
 		// (otherwise we had an error reported elsewhere already)
 		if x.typ != Typ[Invalid] && y.typ != Typ[Invalid] {
 			if e != nil {
-				check.errorf(x, _MismatchedTypes, invalidOp+"%s (mismatched types %s and %s)", e, x.typ, y.typ)
+				check.errorf(x, MismatchedTypes, invalidOp+"%s (mismatched types %s and %s)", e, x.typ, y.typ)
 			} else {
-				check.errorf(x, _MismatchedTypes, invalidOp+"%s %s= %s (mismatched types %s and %s)", lhs, op, rhs, x.typ, y.typ)
+				check.errorf(x, MismatchedTypes, invalidOp+"%s %s= %s (mismatched types %s and %s)", lhs, op, rhs, x.typ, y.typ)
 			}
 		}
 		x.mode = invalid
@@ -1159,7 +1160,7 @@ func (check *Checker) binary(x *operand, e syntax.Expr, lhs, rhs syntax.Expr, op
 	if op == syntax.Div || op == syntax.Rem {
 		// check for zero divisor
 		if (x.mode == constant_ || allInteger(x.typ)) && y.mode == constant_ && constant.Sign(y.val) == 0 {
-			check.error(&y, _DivByZero, invalidOp+"division by zero")
+			check.error(&y, DivByZero, invalidOp+"division by zero")
 			x.mode = invalid
 			return
 		}
@@ -1169,7 +1170,7 @@ func (check *Checker) binary(x *operand, e syntax.Expr, lhs, rhs syntax.Expr, op
 			re, im := constant.Real(y.val), constant.Imag(y.val)
 			re2, im2 := constant.BinaryOp(re, token.MUL, re), constant.BinaryOp(im, token.MUL, im)
 			if constant.Sign(re2) == 0 && constant.Sign(im2) == 0 {
-				check.error(&y, _DivByZero, invalidOp+"division by zero")
+				check.error(&y, DivByZero, invalidOp+"division by zero")
 				x.mode = invalid
 				return
 			}
@@ -1252,7 +1253,7 @@ func (check *Checker) nonGeneric(x *operand) {
 		}
 	}
 	if what != "" {
-		check.errorf(x.expr, _WrongTypeArgCount, "cannot use generic %s %s without instantiation", what, x.expr)
+		check.errorf(x.expr, WrongTypeArgCount, "cannot use generic %s %s without instantiation", what, x.expr)
 		x.mode = invalid
 		x.typ = Typ[Invalid]
 	}
@@ -1279,7 +1280,7 @@ func (check *Checker) exprInternal(x *operand, e syntax.Expr, hint Type) exprKin
 	case *syntax.DotsType:
 		// dots are handled explicitly where they are legal
 		// (array composite literals and parameter lists)
-		check.error(e, _BadDotDotDotSyntax, "invalid use of '...'")
+		check.error(e, BadDotDotDotSyntax, "invalid use of '...'")
 		goto Error
 
 	case *syntax.BasicLit:
@@ -1300,7 +1301,7 @@ func (check *Checker) exprInternal(x *operand, e syntax.Expr, hint Type) exprKin
 			// allows for separators between all digits.
 			const limit = 10000
 			if len(e.Value) > limit {
-				check.errorf(e, _InvalidConstVal, "excessively long constant: %s... (%d chars)", e.Value[:10], len(e.Value))
+				check.errorf(e, InvalidConstVal, "excessively long constant: %s... (%d chars)", e.Value[:10], len(e.Value))
 				goto Error
 			}
 		}
@@ -1310,7 +1311,7 @@ func (check *Checker) exprInternal(x *operand, e syntax.Expr, hint Type) exprKin
 			// If we reach here it's because of number under-/overflow.
 			// TODO(gri) setConst (and in turn the go/constant package)
 			// should return an error describing the issue.
-			check.errorf(e, _InvalidConstVal, "malformed constant: %s", e.Value)
+			check.errorf(e, InvalidConstVal, "malformed constant: %s", e.Value)
 			goto Error
 		}
 		// Ensure that integer values don't overflow (issue #54280).
@@ -1364,13 +1365,13 @@ func (check *Checker) exprInternal(x *operand, e syntax.Expr, hint Type) exprKin
 			typ = hint
 			base, _ = deref(coreType(typ)) // *T implies &T{}
 			if base == nil {
-				check.errorf(e, _InvalidLit, "invalid composite literal element type %s (no core type)", typ)
+				check.errorf(e, InvalidLit, "invalid composite literal element type %s (no core type)", typ)
 				goto Error
 			}
 
 		default:
 			// TODO(gri) provide better error messages depending on context
-			check.error(e, _UntypedLit, "missing type in composite literal")
+			check.error(e, UntypedLit, "missing type in composite literal")
 			goto Error
 		}
 
@@ -1379,7 +1380,7 @@ func (check *Checker) exprInternal(x *operand, e syntax.Expr, hint Type) exprKin
 			// Prevent crash if the struct referred to is not yet set up.
 			// See analogous comment for *Array.
 			if utyp.fields == nil {
-				check.error(e, _InvalidTypeCycle, "invalid recursive type")
+				check.error(e, InvalidTypeCycle, "invalid recursive type")
 				goto Error
 			}
 			if len(e.ElemList) == 0 {
@@ -1395,7 +1396,7 @@ func (check *Checker) exprInternal(x *operand, e syntax.Expr, hint Type) exprKin
 				for _, e := range e.ElemList {
 					kv, _ := e.(*syntax.KeyValueExpr)
 					if kv == nil {
-						check.error(e, _MixedStructLit, "mixture of field:value and value elements in struct literal")
+						check.error(e, MixedStructLit, "mixture of field:value and value elements in struct literal")
 						continue
 					}
 					key, _ := kv.Key.(*syntax.Name)
@@ -1403,12 +1404,12 @@ func (check *Checker) exprInternal(x *operand, e syntax.Expr, hint Type) exprKin
 					// so we don't drop information on the floor
 					check.expr(x, kv.Value)
 					if key == nil {
-						check.errorf(kv, _InvalidLitField, "invalid field name %s in struct literal", kv.Key)
+						check.errorf(kv, InvalidLitField, "invalid field name %s in struct literal", kv.Key)
 						continue
 					}
 					i := fieldIndex(utyp.fields, check.pkg, key.Value)
 					if i < 0 {
-						check.errorf(kv.Key, _MissingLitField, "unknown field %s in struct literal of type %s", key.Value, base)
+						check.errorf(kv.Key, MissingLitField, "unknown field %s in struct literal of type %s", key.Value, base)
 						continue
 					}
 					fld := fields[i]
@@ -1417,7 +1418,7 @@ func (check *Checker) exprInternal(x *operand, e syntax.Expr, hint Type) exprKin
 					check.assignment(x, etyp, "struct literal")
 					// 0 <= i < len(fields)
 					if visited[i] {
-						check.errorf(kv, _DuplicateLitField, "duplicate field name %s in struct literal", key.Value)
+						check.errorf(kv, DuplicateLitField, "duplicate field name %s in struct literal", key.Value)
 						continue
 					}
 					visited[i] = true
@@ -1426,25 +1427,25 @@ func (check *Checker) exprInternal(x *operand, e syntax.Expr, hint Type) exprKin
 				// no element must have a key
 				for i, e := range e.ElemList {
 					if kv, _ := e.(*syntax.KeyValueExpr); kv != nil {
-						check.error(kv, _MixedStructLit, "mixture of field:value and value elements in struct literal")
+						check.error(kv, MixedStructLit, "mixture of field:value and value elements in struct literal")
 						continue
 					}
 					check.expr(x, e)
 					if i >= len(fields) {
-						check.errorf(x, _InvalidStructLit, "too many values in struct literal of type %s", base)
+						check.errorf(x, InvalidStructLit, "too many values in struct literal of type %s", base)
 						break // cannot continue
 					}
 					// i < len(fields)
 					fld := fields[i]
 					if !fld.Exported() && fld.pkg != check.pkg {
-						check.errorf(x, _UnexportedLitField, "implicit assignment to unexported field %s in struct literal of type %s", fld.name, base)
+						check.errorf(x, UnexportedLitField, "implicit assignment to unexported field %s in struct literal of type %s", fld.name, base)
 						continue
 					}
 					etyp := fld.typ
 					check.assignment(x, etyp, "struct literal")
 				}
 				if len(e.ElemList) < len(fields) {
-					check.errorf(e.Rbrace, _InvalidStructLit, "too few values in struct literal of type %s", base)
+					check.errorf(e.Rbrace, InvalidStructLit, "too few values in struct literal of type %s", base)
 					// ok to continue
 				}
 			}
@@ -1454,7 +1455,7 @@ func (check *Checker) exprInternal(x *operand, e syntax.Expr, hint Type) exprKin
 			// This is a stop-gap solution. Should use Checker.objPath to report entire
 			// path starting with earliest declaration in the source. TODO(gri) fix this.
 			if utyp.elem == nil {
-				check.error(e, _InvalidTypeCycle, "invalid recursive type")
+				check.error(e, InvalidTypeCycle, "invalid recursive type")
 				goto Error
 			}
 			n := check.indexedElts(e.ElemList, utyp.elem, utyp.len)
@@ -1481,7 +1482,7 @@ func (check *Checker) exprInternal(x *operand, e syntax.Expr, hint Type) exprKin
 			// Prevent crash if the slice referred to is not yet set up.
 			// See analogous comment for *Array.
 			if utyp.elem == nil {
-				check.error(e, _InvalidTypeCycle, "invalid recursive type")
+				check.error(e, InvalidTypeCycle, "invalid recursive type")
 				goto Error
 			}
 			check.indexedElts(e.ElemList, utyp.elem, -1)
@@ -1490,7 +1491,7 @@ func (check *Checker) exprInternal(x *operand, e syntax.Expr, hint Type) exprKin
 			// Prevent crash if the map referred to is not yet set up.
 			// See analogous comment for *Array.
 			if utyp.key == nil || utyp.elem == nil {
-				check.error(e, _InvalidTypeCycle, "invalid recursive type")
+				check.error(e, InvalidTypeCycle, "invalid recursive type")
 				goto Error
 			}
 			// If the map key type is an interface (but not a type parameter),
@@ -1501,7 +1502,7 @@ func (check *Checker) exprInternal(x *operand, e syntax.Expr, hint Type) exprKin
 			for _, e := range e.ElemList {
 				kv, _ := e.(*syntax.KeyValueExpr)
 				if kv == nil {
-					check.error(e, _MissingLitKey, "missing key in map literal")
+					check.error(e, MissingLitKey, "missing key in map literal")
 					continue
 				}
 				check.exprWithHint(x, kv.Key, utyp.key)
@@ -1525,7 +1526,7 @@ func (check *Checker) exprInternal(x *operand, e syntax.Expr, hint Type) exprKin
 						visited[xkey] = nil
 					}
 					if duplicate {
-						check.errorf(x, _DuplicateLitKey, "duplicate key %s in map literal", x.val)
+						check.errorf(x, DuplicateLitKey, "duplicate key %s in map literal", x.val)
 						continue
 					}
 				}
@@ -1547,7 +1548,7 @@ func (check *Checker) exprInternal(x *operand, e syntax.Expr, hint Type) exprKin
 			}
 			// if utyp is invalid, an error was reported before
 			if utyp != Typ[Invalid] {
-				check.errorf(e, _InvalidLit, "invalid composite literal type %s", typ)
+				check.errorf(e, InvalidLit, "invalid composite literal type %s", typ)
 				goto Error
 			}
 		}
@@ -1584,11 +1585,11 @@ func (check *Checker) exprInternal(x *operand, e syntax.Expr, hint Type) exprKin
 		}
 		// TODO(gri) we may want to permit type assertions on type parameter values at some point
 		if isTypeParam(x.typ) {
-			check.errorf(x, _InvalidAssert, invalidOp+"cannot use type assertion on type parameter value %s", x)
+			check.errorf(x, InvalidAssert, invalidOp+"cannot use type assertion on type parameter value %s", x)
 			goto Error
 		}
 		if _, ok := under(x.typ).(*Interface); !ok {
-			check.errorf(x, _InvalidAssert, invalidOp+"%s is not an interface", x)
+			check.errorf(x, InvalidAssert, invalidOp+"%s is not an interface", x)
 			goto Error
 		}
 		// x.(type) expressions are encoded via TypeSwitchGuards
@@ -1654,11 +1655,11 @@ func (check *Checker) exprInternal(x *operand, e syntax.Expr, hint Type) exprKin
 					if !underIs(x.typ, func(u Type) bool {
 						p, _ := u.(*Pointer)
 						if p == nil {
-							check.errorf(x, _InvalidIndirection, invalidOp+"cannot indirect %s", x)
+							check.errorf(x, InvalidIndirection, invalidOp+"cannot indirect %s", x)
 							return false
 						}
 						if base != nil && !Identical(p.base, base) {
-							check.errorf(x, _InvalidIndirection, invalidOp+"pointers of %s must have identical base types", x)
+							check.errorf(x, InvalidIndirection, invalidOp+"pointers of %s must have identical base types", x)
 							return false
 						}
 						base = p.base
@@ -1770,11 +1771,11 @@ func (check *Checker) typeAssertion(e syntax.Expr, x *operand, T Type, typeSwitc
 	cause := check.missingMethodCause(T, x.typ, method, alt)
 
 	if typeSwitch {
-		check.errorf(e, _ImpossibleAssert, "impossible type switch case: %s\n\t%s cannot have dynamic type %s %s", e, x, T, cause)
+		check.errorf(e, ImpossibleAssert, "impossible type switch case: %s\n\t%s cannot have dynamic type %s %s", e, x, T, cause)
 		return
 	}
 
-	check.errorf(e, _ImpossibleAssert, "impossible type assertion: %s\n\t%s does not implement %s %s", e, T, x.typ, cause)
+	check.errorf(e, ImpossibleAssert, "impossible type assertion: %s\n\t%s does not implement %s %s", e, T, x.typ, cause)
 }
 
 // expr typechecks expression e and initializes x with the expression value.
@@ -1817,7 +1818,7 @@ func (check *Checker) exprOrType(x *operand, e syntax.Expr, allowGeneric bool) {
 func (check *Checker) exclude(x *operand, modeset uint) {
 	if modeset&(1<<x.mode) != 0 {
 		var msg string
-		var code errorCode
+		var code Code
 		switch x.mode {
 		case novalue:
 			if modeset&(1<<typexpr) != 0 {
@@ -1825,13 +1826,13 @@ func (check *Checker) exclude(x *operand, modeset uint) {
 			} else {
 				msg = "%s used as value or type"
 			}
-			code = _TooManyValues
+			code = TooManyValues
 		case builtin:
 			msg = "%s must be called"
-			code = _UncalledBuiltin
+			code = UncalledBuiltin
 		case typexpr:
 			msg = "%s is not an expression"
-			code = _NotAnExpr
+			code = NotAnExpr
 		default:
 			unreachable()
 		}
@@ -1846,7 +1847,7 @@ func (check *Checker) singleValue(x *operand) {
 		// tuple types are never named - no need for underlying type below
 		if t, ok := x.typ.(*Tuple); ok {
 			assert(t.Len() != 1)
-			check.errorf(x, _TooManyValues, "multiple-value %s in single-value context", x)
+			check.errorf(x, TooManyValues, "multiple-value %s in single-value context", x)
 			x.mode = invalid
 		}
 	}
diff --git a/src/cmd/compile/internal/types2/index.go b/src/cmd/compile/internal/types2/index.go
index b51205634e..71c4152ec5 100644
--- a/src/cmd/compile/internal/types2/index.go
+++ b/src/cmd/compile/internal/types2/index.go
@@ -9,6 +9,7 @@ package types2
 import (
 	"cmd/compile/internal/syntax"
 	"go/constant"
+	. "internal/types/errors"
 )
 
 // If e is a valid function instantiation, indexExpr returns true.
@@ -182,7 +183,7 @@ func (check *Checker) indexExpr(x *operand, e *syntax.IndexExpr) (isFuncInst boo
 	}
 
 	if !valid {
-		check.errorf(e.Pos(), _NonSliceableOperand, invalidOp+"cannot index %s", x)
+		check.errorf(e.Pos(), NonSliceableOperand, invalidOp+"cannot index %s", x)
 		x.mode = invalid
 		return false
 	}
@@ -215,7 +216,7 @@ func (check *Checker) sliceExpr(x *operand, e *syntax.SliceExpr) {
 	length := int64(-1) // valid if >= 0
 	switch u := coreString(x.typ).(type) {
 	case nil:
-		check.errorf(x, _NonSliceableOperand, invalidOp+"cannot slice %s: %s has no core type", x, x.typ)
+		check.errorf(x, NonSliceableOperand, invalidOp+"cannot slice %s: %s has no core type", x, x.typ)
 		x.mode = invalid
 		return
 
@@ -226,7 +227,7 @@ func (check *Checker) sliceExpr(x *operand, e *syntax.SliceExpr) {
 				if at == nil {
 					at = e // e.Index[2] should be present but be careful
 				}
-				check.error(at, _InvalidSliceExpr, invalidOp+"3-index slice of string")
+				check.error(at, InvalidSliceExpr, invalidOp+"3-index slice of string")
 				x.mode = invalid
 				return
 			}
@@ -245,7 +246,7 @@ func (check *Checker) sliceExpr(x *operand, e *syntax.SliceExpr) {
 		valid = true
 		length = u.len
 		if x.mode != variable {
-			check.errorf(x, _NonSliceableOperand, invalidOp+"%s (slice of unaddressable value)", x)
+			check.errorf(x, NonSliceableOperand, invalidOp+"%s (slice of unaddressable value)", x)
 			x.mode = invalid
 			return
 		}
@@ -264,7 +265,7 @@ func (check *Checker) sliceExpr(x *operand, e *syntax.SliceExpr) {
 	}
 
 	if !valid {
-		check.errorf(x, _NonSliceableOperand, invalidOp+"cannot slice %s", x)
+		check.errorf(x, NonSliceableOperand, invalidOp+"cannot slice %s", x)
 		x.mode = invalid
 		return
 	}
@@ -314,7 +315,7 @@ L:
 					// The value y corresponds to the expression e.Index[i+1+j].
 					// Because y >= 0, it must have been set from the expression
 					// when checking indices and thus e.Index[i+1+j] is not nil.
-					check.errorf(e.Index[i+1+j], _SwappedSliceIndices, "invalid slice indices: %d < %d", y, x)
+					check.errorf(e.Index[i+1+j], SwappedSliceIndices, "invalid slice indices: %d < %d", y, x)
 					break L // only report one error, ok to continue
 				}
 			}
@@ -337,7 +338,7 @@ func (check *Checker) singleIndex(e *syntax.IndexExpr) syntax.Expr {
 			return nil
 		}
 		// len(l.ElemList) > 1
-		check.error(l.ElemList[1], _InvalidIndex, invalidOp+"more than one index")
+		check.error(l.ElemList[1], InvalidIndex, invalidOp+"more than one index")
 		index = l.ElemList[0] // continue with first index
 	}
 	return index
@@ -353,7 +354,7 @@ func (check *Checker) index(index syntax.Expr, max int64) (typ Type, val int64)
 
 	var x operand
 	check.expr(&x, index)
-	if !check.isValidIndex(&x, _InvalidIndex, "index", false) {
+	if !check.isValidIndex(&x, InvalidIndex, "index", false) {
 		return
 	}
 
@@ -368,7 +369,7 @@ func (check *Checker) index(index syntax.Expr, max int64) (typ Type, val int64)
 	v, ok := constant.Int64Val(x.val)
 	assert(ok)
 	if max >= 0 && v >= max {
-		check.errorf(&x, _InvalidIndex, invalidArg+"index %s out of bounds [0:%d]", x.val.String(), max)
+		check.errorf(&x, InvalidIndex, invalidArg+"index %s out of bounds [0:%d]", x.val.String(), max)
 		return
 	}
 
@@ -380,7 +381,7 @@ func (check *Checker) index(index syntax.Expr, max int64) (typ Type, val int64)
 // index values. If allowNegative is set, a constant operand may be negative.
 // If the operand is not valid, an error is reported (using what as context)
 // and the result is false.
-func (check *Checker) isValidIndex(x *operand, code errorCode, what string, allowNegative bool) bool {
+func (check *Checker) isValidIndex(x *operand, code Code, what string, allowNegative bool) bool {
 	if x.mode == invalid {
 		return false
 	}
@@ -431,12 +432,12 @@ func (check *Checker) indexedElts(elts []syntax.Expr, typ Type, length int64) in
 					index = i
 					validIndex = true
 				} else {
-					check.errorf(e, _InvalidLitIndex, "index %s must be integer constant", kv.Key)
+					check.errorf(e, InvalidLitIndex, "index %s must be integer constant", kv.Key)
 				}
 			}
 			eval = kv.Value
 		} else if length >= 0 && index >= length {
-			check.errorf(e, _OversizeArrayLit, "index %d is out of bounds (>= %d)", index, length)
+			check.errorf(e, OversizeArrayLit, "index %d is out of bounds (>= %d)", index, length)
 		} else {
 			validIndex = true
 		}
@@ -444,7 +445,7 @@ func (check *Checker) indexedElts(elts []syntax.Expr, typ Type, length int64) in
 		// if we have a valid index, check for duplicate entries
 		if validIndex {
 			if visited[index] {
-				check.errorf(e, _DuplicateLitKey, "duplicate index %d in array or slice literal", index)
+				check.errorf(e, DuplicateLitKey, "duplicate index %d in array or slice literal", index)
 			}
 			visited[index] = true
 		}
diff --git a/src/cmd/compile/internal/types2/infer.go b/src/cmd/compile/internal/types2/infer.go
index e9d367e648..717f7dde28 100644
--- a/src/cmd/compile/internal/types2/infer.go
+++ b/src/cmd/compile/internal/types2/infer.go
@@ -9,6 +9,7 @@ package types2
 import (
 	"cmd/compile/internal/syntax"
 	"fmt"
+	. "internal/types/errors"
 	"strings"
 )
 
@@ -216,7 +217,7 @@ func (check *Checker) infer(pos syntax.Pos, tparams []*TypeParam, targs []Type,
 				}
 			}
 			if allFailed {
-				check.errorf(arg, _CannotInferTypeArgs, "%s %s of %s does not match %s (cannot infer %s)", kind, targ, arg.expr, tpar, typeParamsString(tparams))
+				check.errorf(arg, CannotInferTypeArgs, "%s %s of %s does not match %s (cannot infer %s)", kind, targ, arg.expr, tpar, typeParamsString(tparams))
 				return
 			}
 		}
@@ -227,9 +228,9 @@ func (check *Checker) infer(pos syntax.Pos, tparams []*TypeParam, targs []Type,
 		// _InvalidTypeArg). We can't differentiate these cases, so fall back on
 		// the more general _CannotInferTypeArgs.
 		if inferred != tpar {
-			check.errorf(arg, _CannotInferTypeArgs, "%s %s of %s does not match inferred type %s for %s", kind, targ, arg.expr, inferred, tpar)
+			check.errorf(arg, CannotInferTypeArgs, "%s %s of %s does not match inferred type %s for %s", kind, targ, arg.expr, inferred, tpar)
 		} else {
-			check.errorf(arg, _CannotInferTypeArgs, "%s %s of %s does not match %s", kind, targ, arg.expr, tpar)
+			check.errorf(arg, CannotInferTypeArgs, "%s %s of %s does not match %s", kind, targ, arg.expr, tpar)
 		}
 	}
 
@@ -323,7 +324,7 @@ func (check *Checker) infer(pos syntax.Pos, tparams []*TypeParam, targs []Type,
 	// At least one type argument couldn't be inferred.
 	assert(targs != nil && index >= 0 && targs[index] == nil)
 	tpar := tparams[index]
-	check.errorf(pos, _CannotInferTypeArgs, "cannot infer %s (%s)", tpar.obj.name, tpar.obj.pos)
+	check.errorf(pos, CannotInferTypeArgs, "cannot infer %s (%s)", tpar.obj.name, tpar.obj.pos)
 	return nil
 }
 
@@ -536,7 +537,7 @@ func (check *Checker) inferB(pos syntax.Pos, tparams []*TypeParam, targs []Type)
 						if core.tilde {
 							tilde = "~"
 						}
-						check.errorf(pos, _InvalidTypeArg, "%s does not match %s%s", tpar, tilde, core.typ)
+						check.errorf(pos, InvalidTypeArg, "%s does not match %s%s", tpar, tilde, core.typ)
 						return nil, 0
 					}
 
diff --git a/src/cmd/compile/internal/types2/initorder.go b/src/cmd/compile/internal/types2/initorder.go
index 62184ea870..6e041721e8 100644
--- a/src/cmd/compile/internal/types2/initorder.go
+++ b/src/cmd/compile/internal/types2/initorder.go
@@ -7,6 +7,7 @@ package types2
 import (
 	"container/heap"
 	"fmt"
+	. "internal/types/errors"
 	"sort"
 )
 
@@ -155,12 +156,12 @@ func (check *Checker) reportCycle(cycle []Object) {
 
 	// report a more concise error for self references
 	if len(cycle) == 1 {
-		check.errorf(obj, _InvalidInitCycle, "initialization cycle: %s refers to itself", obj.Name())
+		check.errorf(obj, InvalidInitCycle, "initialization cycle: %s refers to itself", obj.Name())
 		return
 	}
 
 	var err error_
-	err.code = _InvalidInitCycle
+	err.code = InvalidInitCycle
 	err.errorf(obj, "initialization cycle for %s", obj.Name())
 	// subtle loop: print cycle[i] for i = 0, n-1, n-2, ... 1 for len(cycle) = n
 	for i := len(cycle) - 1; i >= 0; i-- {
diff --git a/src/cmd/compile/internal/types2/instantiate.go b/src/cmd/compile/internal/types2/instantiate.go
index 38863e85e4..043db9c24a 100644
--- a/src/cmd/compile/internal/types2/instantiate.go
+++ b/src/cmd/compile/internal/types2/instantiate.go
@@ -11,6 +11,7 @@ import (
 	"cmd/compile/internal/syntax"
 	"errors"
 	"fmt"
+	. "internal/types/errors"
 )
 
 // Instantiate instantiates the type orig with the given type arguments targs.
@@ -156,7 +157,7 @@ func (check *Checker) validateTArgLen(pos syntax.Pos, ntparams, ntargs int) bool
 	if ntargs != ntparams {
 		// TODO(gri) provide better error message
 		if check != nil {
-			check.errorf(pos, _WrongTypeArgCount, "got %d arguments but %d type parameters", ntargs, ntparams)
+			check.errorf(pos, WrongTypeArgCount, "got %d arguments but %d type parameters", ntargs, ntparams)
 			return false
 		}
 		panic(fmt.Sprintf("%v: got %d arguments but %d type parameters", pos, ntargs, ntparams))
diff --git a/src/cmd/compile/internal/types2/interface.go b/src/cmd/compile/internal/types2/interface.go
index d05de8bf4f..b18900888b 100644
--- a/src/cmd/compile/internal/types2/interface.go
+++ b/src/cmd/compile/internal/types2/interface.go
@@ -4,7 +4,10 @@
 
 package types2
 
-import "cmd/compile/internal/syntax"
+import (
+	"cmd/compile/internal/syntax"
+	. "internal/types/errors"
+)
 
 // ----------------------------------------------------------------------------
 // API
@@ -132,7 +135,7 @@ func (check *Checker) interfaceType(ityp *Interface, iface *syntax.InterfaceType
 		// We have a method with name f.Name.
 		name := f.Name.Value
 		if name == "_" {
-			check.error(f.Name, _BlankIfaceMethod, "methods must have a unique non-blank name")
+			check.error(f.Name, BlankIfaceMethod, "methods must have a unique non-blank name")
 			continue // ignore
 		}
 
diff --git a/src/cmd/compile/internal/types2/labels.go b/src/cmd/compile/internal/types2/labels.go
index 9163a58c18..1f67e65abd 100644
--- a/src/cmd/compile/internal/types2/labels.go
+++ b/src/cmd/compile/internal/types2/labels.go
@@ -6,6 +6,7 @@ package types2
 
 import (
 	"cmd/compile/internal/syntax"
+	. "internal/types/errors"
 )
 
 // labels checks correct label use in body.
@@ -21,15 +22,15 @@ func (check *Checker) labels(body *syntax.BlockStmt) {
 	// for the respective gotos.
 	for _, jmp := range fwdJumps {
 		var msg string
-		var code errorCode
+		var code Code
 		name := jmp.Label.Value
 		if alt := all.Lookup(name); alt != nil {
 			msg = "goto %s jumps into block"
 			alt.(*Label).used = true // avoid another error
-			code = _JumpIntoBlock
+			code = JumpIntoBlock
 		} else {
 			msg = "label %s not declared"
-			code = _UndeclaredLabel
+			code = UndeclaredLabel
 		}
 		check.errorf(jmp.Label, code, msg, name)
 	}
@@ -38,7 +39,7 @@ func (check *Checker) labels(body *syntax.BlockStmt) {
 	for name, obj := range all.elems {
 		obj = resolve(name, obj)
 		if lbl := obj.(*Label); !lbl.used {
-			check.softErrorf(lbl.pos, _UnusedLabel, "label %s declared and not used", lbl.name)
+			check.softErrorf(lbl.pos, UnusedLabel, "label %s declared and not used", lbl.name)
 		}
 	}
 }
@@ -133,7 +134,7 @@ func (check *Checker) blockBranches(all *Scope, parent *block, lstmt *syntax.Lab
 				lbl := NewLabel(s.Label.Pos(), check.pkg, name)
 				if alt := all.Insert(lbl); alt != nil {
 					var err error_
-					err.code = _DuplicateLabel
+					err.code = DuplicateLabel
 					err.soft = true
 					err.errorf(lbl.pos, "label %s already declared", name)
 					err.recordAltDecl(alt)
@@ -153,7 +154,7 @@ func (check *Checker) blockBranches(all *Scope, parent *block, lstmt *syntax.Lab
 						if jumpsOverVarDecl(jmp) {
 							check.softErrorf(
 								jmp.Label,
-								_JumpOverDecl,
+								JumpOverDecl,
 								"goto %s jumps over variable declaration at line %d",
 								name,
 								varDeclPos.Line(),
@@ -191,7 +192,7 @@ func (check *Checker) blockBranches(all *Scope, parent *block, lstmt *syntax.Lab
 					}
 				}
 				if !valid {
-					check.errorf(s.Label, _MisplacedLabel, "invalid break label %s", name)
+					check.errorf(s.Label, MisplacedLabel, "invalid break label %s", name)
 					return
 				}
 
@@ -206,7 +207,7 @@ func (check *Checker) blockBranches(all *Scope, parent *block, lstmt *syntax.Lab
 					}
 				}
 				if !valid {
-					check.errorf(s.Label, _MisplacedLabel, "invalid continue label %s", name)
+					check.errorf(s.Label, MisplacedLabel, "invalid continue label %s", name)
 					return
 				}
 
diff --git a/src/cmd/compile/internal/types2/mono.go b/src/cmd/compile/internal/types2/mono.go
index b25f6b0165..eb1d5e7d2e 100644
--- a/src/cmd/compile/internal/types2/mono.go
+++ b/src/cmd/compile/internal/types2/mono.go
@@ -6,6 +6,7 @@ package types2
 
 import (
 	"cmd/compile/internal/syntax"
+	. "internal/types/errors"
 )
 
 // This file implements a check to validate that a Go package doesn't
@@ -137,7 +138,7 @@ func (check *Checker) reportInstanceLoop(v int) {
 	// TODO(mdempsky): Pivot stack so we report the cycle from the top?
 
 	var err error_
-	err.code = _InvalidInstanceCycle
+	err.code = InvalidInstanceCycle
 	obj0 := check.mono.vertices[v].obj
 	err.errorf(obj0, "instantiation cycle:")
 
diff --git a/src/cmd/compile/internal/types2/operand.go b/src/cmd/compile/internal/types2/operand.go
index 07a5d16bbc..7f10b75612 100644
--- a/src/cmd/compile/internal/types2/operand.go
+++ b/src/cmd/compile/internal/types2/operand.go
@@ -12,6 +12,7 @@ import (
 	"fmt"
 	"go/constant"
 	"go/token"
+	. "internal/types/errors"
 )
 
 // An operandMode specifies the (addressing) mode of an operand.
@@ -239,7 +240,7 @@ func (x *operand) isNil() bool { return x.mode == nilvalue }
 // is only valid if the (first) result is false. The check parameter may be nil
 // if assignableTo is invoked through an exported API call, i.e., when all
 // methods have been type-checked.
-func (x *operand) assignableTo(check *Checker, T Type, cause *string) (bool, errorCode) {
+func (x *operand) assignableTo(check *Checker, T Type, cause *string) (bool, Code) {
 	if x.mode == invalid || T == Typ[Invalid] {
 		return true, 0 // avoid spurious errors
 	}
@@ -271,10 +272,10 @@ func (x *operand) assignableTo(check *Checker, T Type, cause *string) (bool, err
 				// don't need to do anything special.
 				newType, _, _ := check.implicitTypeAndValue(x, t.typ)
 				return newType != nil
-			}), _IncompatibleAssign
+			}), IncompatibleAssign
 		}
 		newType, _, _ := check.implicitTypeAndValue(x, T)
-		return newType != nil, _IncompatibleAssign
+		return newType != nil, IncompatibleAssign
 	}
 	// Vu is typed
 
@@ -289,7 +290,7 @@ func (x *operand) assignableTo(check *Checker, T Type, cause *string) (bool, err
 	// Also handle the case where T is a pointer to an interface.
 	if _, ok := Tu.(*Interface); ok && Tp == nil || isInterfacePtr(Tu) {
 		if !check.implements(V, T, cause) {
-			return false, _InvalidIfaceAssign
+			return false, InvalidIfaceAssign
 		}
 		return true, 0
 	}
@@ -301,7 +302,7 @@ func (x *operand) assignableTo(check *Checker, T Type, cause *string) (bool, err
 			if cause != nil {
 				*cause = "need type assertion"
 			}
-			return false, _IncompatibleAssign
+			return false, IncompatibleAssign
 		}
 	}
 
@@ -310,13 +311,13 @@ func (x *operand) assignableTo(check *Checker, T Type, cause *string) (bool, err
 	// and at least one of V or T is not a named type.
 	if Vc, ok := Vu.(*Chan); ok && Vc.dir == SendRecv {
 		if Tc, ok := Tu.(*Chan); ok && Identical(Vc.elem, Tc.elem) {
-			return !hasName(V) || !hasName(T), _InvalidChanAssign
+			return !hasName(V) || !hasName(T), InvalidChanAssign
 		}
 	}
 
 	// optimization: if we don't have type parameters, we're done
 	if Vp == nil && Tp == nil {
-		return false, _IncompatibleAssign
+		return false, IncompatibleAssign
 	}
 
 	errorf := func(format string, args ...interface{}) {
@@ -333,7 +334,7 @@ func (x *operand) assignableTo(check *Checker, T Type, cause *string) (bool, err
 	// x is assignable to each specific type in T's type set.
 	if !hasName(V) && Tp != nil {
 		ok := false
-		code := _IncompatibleAssign
+		code := IncompatibleAssign
 		Tp.is(func(T *term) bool {
 			if T == nil {
 				return false // no specific types
@@ -354,7 +355,7 @@ func (x *operand) assignableTo(check *Checker, T Type, cause *string) (bool, err
 	if Vp != nil && !hasName(T) {
 		x := *x // don't clobber outer x
 		ok := false
-		code := _IncompatibleAssign
+		code := IncompatibleAssign
 		Vp.is(func(V *term) bool {
 			if V == nil {
 				return false // no specific types
@@ -370,7 +371,7 @@ func (x *operand) assignableTo(check *Checker, T Type, cause *string) (bool, err
 		return ok, code
 	}
 
-	return false, _IncompatibleAssign
+	return false, IncompatibleAssign
 }
 
 // kind2tok translates syntax.LitKinds into token.Tokens.
diff --git a/src/cmd/compile/internal/types2/resolver.go b/src/cmd/compile/internal/types2/resolver.go
index f9aa3adad8..2df74ae093 100644
--- a/src/cmd/compile/internal/types2/resolver.go
+++ b/src/cmd/compile/internal/types2/resolver.go
@@ -8,6 +8,7 @@ import (
 	"cmd/compile/internal/syntax"
 	"fmt"
 	"go/constant"
+	. "internal/types/errors"
 	"sort"
 	"strconv"
 	"strings"
@@ -52,7 +53,7 @@ func (check *Checker) arity(pos syntax.Pos, names []*syntax.Name, inits []syntax
 	l := len(names)
 	r := len(inits)
 
-	const code = _WrongAssignCount
+	const code = WrongAssignCount
 	switch {
 	case l < r:
 		n := inits[l]
@@ -92,14 +93,14 @@ func (check *Checker) declarePkgObj(ident *syntax.Name, obj Object, d *declInfo)
 	// spec: "A package-scope or file-scope identifier with name init
 	// may only be declared to be a function with this (func()) signature."
 	if ident.Value == "init" {
-		check.error(ident, _InvalidInitDecl, "cannot declare init - must be func")
+		check.error(ident, InvalidInitDecl, "cannot declare init - must be func")
 		return
 	}
 
 	// spec: "The main package must have package name main and declare
 	// a function main that takes no arguments and returns no value."
 	if ident.Value == "main" && check.pkg.name == "main" {
-		check.error(ident, _InvalidMainDecl, "cannot declare main - must be func")
+		check.error(ident, InvalidMainDecl, "cannot declare main - must be func")
 		return
 	}
 
@@ -159,7 +160,7 @@ func (check *Checker) importPackage(pos syntax.Pos, path, dir string) *Package {
 			imp = nil // create fake package below
 		}
 		if err != nil {
-			check.errorf(pos, _BrokenImport, "could not import %s (%s)", path, err)
+			check.errorf(pos, BrokenImport, "could not import %s (%s)", path, err)
 			if imp == nil {
 				// create a new fake package
 				// come up with a sensible package name (heuristic)
@@ -246,7 +247,7 @@ func (check *Checker) collectObjects() {
 				}
 				path, err := validatedImportPath(s.Path.Value)
 				if err != nil {
-					check.errorf(s.Path, _BadImportPath, "invalid import path (%s)", err)
+					check.errorf(s.Path, BadImportPath, "invalid import path (%s)", err)
 					continue
 				}
 
@@ -261,13 +262,13 @@ func (check *Checker) collectObjects() {
 					name = s.LocalPkgName.Value
 					if path == "C" {
 						// match 1.17 cmd/compile (not prescribed by spec)
-						check.error(s.LocalPkgName, _ImportCRenamed, `cannot rename import "C"`)
+						check.error(s.LocalPkgName, ImportCRenamed, `cannot rename import "C"`)
 						continue
 					}
 				}
 
 				if name == "init" {
-					check.error(s, _InvalidInitDecl, "cannot import package as init - init must be a func")
+					check.error(s, InvalidInitDecl, "cannot import package as init - init must be a func")
 					continue
 				}
 
@@ -314,7 +315,7 @@ func (check *Checker) collectObjects() {
 							// concurrently. See issue #32154.)
 							if alt := fileScope.Lookup(name); alt != nil {
 								var err error_
-								err.code = _DuplicateDecl
+								err.code = DuplicateDecl
 								err.errorf(s.LocalPkgName, "%s redeclared in this block", alt.Name())
 								err.recordAltDecl(alt)
 								check.report(&err)
@@ -418,9 +419,9 @@ func (check *Checker) collectObjects() {
 				if s.Recv == nil {
 					// regular function
 					if name == "init" || name == "main" && pkg.name == "main" {
-						code := _InvalidInitDecl
+						code := InvalidInitDecl
 						if name == "main" {
-							code = _InvalidMainDecl
+							code = InvalidMainDecl
 						}
 						if len(s.TParamList) != 0 {
 							check.softErrorf(s.TParamList[0], code, "func %s must have no type parameters", name)
@@ -437,7 +438,7 @@ func (check *Checker) collectObjects() {
 						// init functions must have a body
 						if s.Body == nil {
 							// TODO(gri) make this error message consistent with the others above
-							check.softErrorf(obj.pos, _MissingInitBody, "missing function body")
+							check.softErrorf(obj.pos, MissingInitBody, "missing function body")
 						}
 					} else {
 						check.declare(pkg.scope, s.Name, obj, nopos)
@@ -477,7 +478,7 @@ func (check *Checker) collectObjects() {
 			if alt := pkg.scope.Lookup(name); alt != nil {
 				obj = resolve(name, obj)
 				var err error_
-				err.code = _DuplicateDecl
+				err.code = DuplicateDecl
 				if pkg, ok := obj.(*PkgName); ok {
 					err.errorf(alt, "%s already declared through import of %s", alt.Name(), pkg.Imported())
 					err.recordAltDecl(pkg)
@@ -551,7 +552,7 @@ L: // unpack receiver type
 				case nil:
 					check.error(ptyp, 0, invalidAST+"parameterized receiver contains nil parameters")
 				default:
-					check.errorf(arg, _BadDecl, "receiver type parameter %s must be an identifier", arg)
+					check.errorf(arg, BadDecl, "receiver type parameter %s must be an identifier", arg)
 				}
 				if par == nil {
 					par = syntax.NewName(arg.Pos(), "_")
@@ -727,9 +728,9 @@ func (check *Checker) errorUnusedPkg(obj *PkgName) {
 		elem = elem[i+1:]
 	}
 	if obj.name == "" || obj.name == "." || obj.name == elem {
-		check.softErrorf(obj, _UnusedImport, "%q imported and not used", path)
+		check.softErrorf(obj, UnusedImport, "%q imported and not used", path)
 	} else {
-		check.softErrorf(obj, _UnusedImport, "%q imported as %s and not used", path, obj.name)
+		check.softErrorf(obj, UnusedImport, "%q imported as %s and not used", path, obj.name)
 	}
 }
 
diff --git a/src/cmd/compile/internal/types2/signature.go b/src/cmd/compile/internal/types2/signature.go
index 47454a3adf..eab18b6b7c 100644
--- a/src/cmd/compile/internal/types2/signature.go
+++ b/src/cmd/compile/internal/types2/signature.go
@@ -7,6 +7,7 @@ package types2
 import (
 	"cmd/compile/internal/syntax"
 	"fmt"
+	. "internal/types/errors"
 )
 
 // ----------------------------------------------------------------------------
@@ -156,7 +157,7 @@ func (check *Checker) funcType(sig *Signature, recvPar *syntax.Field, tparams []
 				// may lead to follow-on errors (see issues #51339, #51343).
 				// TODO(gri) find a better solution
 				got := measure(len(tparams), "type parameter")
-				check.errorf(recvPar, _BadRecv, "got %s, but receiver base type declares %d", got, len(recvTParams))
+				check.errorf(recvPar, BadRecv, "got %s, but receiver base type declares %d", got, len(recvTParams))
 			}
 		}
 	}
@@ -178,7 +179,7 @@ func (check *Checker) funcType(sig *Signature, recvPar *syntax.Field, tparams []
 	results, _ := check.collectParams(scope, ftyp.ResultList, false)
 	scope.Squash(func(obj, alt Object) {
 		var err error_
-		err.code = _DuplicateDecl
+		err.code = DuplicateDecl
 		err.errorf(obj, "%s redeclared in this block", obj.Name())
 		err.recordAltDecl(alt)
 		check.report(&err)
@@ -195,7 +196,7 @@ func (check *Checker) funcType(sig *Signature, recvPar *syntax.Field, tparams []
 			recv = NewParam(nopos, nil, "", Typ[Invalid]) // ignore recv below
 		default:
 			// more than one receiver
-			check.error(recvList[len(recvList)-1].Pos(), _InvalidRecv, "method must have exactly one receiver")
+			check.error(recvList[len(recvList)-1].Pos(), InvalidRecv, "method must have exactly one receiver")
 			fallthrough // continue with first receiver
 		case 1:
 			recv = recvList[0]
@@ -218,11 +219,11 @@ func (check *Checker) funcType(sig *Signature, recvPar *syntax.Field, tparams []
 				// The receiver type may be an instantiated type referred to
 				// by an alias (which cannot have receiver parameters for now).
 				if T.TypeArgs() != nil && sig.RecvTypeParams() == nil {
-					check.errorf(recv, _InvalidRecv, "cannot define new methods on instantiated type %s", rtyp)
+					check.errorf(recv, InvalidRecv, "cannot define new methods on instantiated type %s", rtyp)
 					break
 				}
 				if T.obj.pkg != check.pkg {
-					check.errorf(recv, _InvalidRecv, "cannot define new methods on non-local type %s", rtyp)
+					check.errorf(recv, InvalidRecv, "cannot define new methods on non-local type %s", rtyp)
 					break
 				}
 				var cause string
@@ -240,12 +241,12 @@ func (check *Checker) funcType(sig *Signature, recvPar *syntax.Field, tparams []
 					unreachable()
 				}
 				if cause != "" {
-					check.errorf(recv, _InvalidRecv, "invalid receiver type %s (%s)", rtyp, cause)
+					check.errorf(recv, InvalidRecv, "invalid receiver type %s (%s)", rtyp, cause)
 				}
 			case *Basic:
-				check.errorf(recv, _InvalidRecv, "cannot define new methods on non-local type %s", rtyp)
+				check.errorf(recv, InvalidRecv, "cannot define new methods on non-local type %s", rtyp)
 			default:
-				check.errorf(recv, _InvalidRecv, "invalid receiver type %s", recv.typ)
+				check.errorf(recv, InvalidRecv, "invalid receiver type %s", recv.typ)
 			}
 		}).describef(recv, "validate receiver %s", recv)
 	}
@@ -276,7 +277,7 @@ func (check *Checker) collectParams(scope *Scope, list []*syntax.Field, variadic
 				if variadicOk && i == len(list)-1 {
 					variadic = true
 				} else {
-					check.softErrorf(t, _MisplacedDotDotDot, "can only use ... with final parameter in list")
+					check.softErrorf(t, MisplacedDotDotDot, "can only use ... with final parameter in list")
 					// ignore ... and continue
 				}
 			}
diff --git a/src/cmd/compile/internal/types2/stmt.go b/src/cmd/compile/internal/types2/stmt.go
index 3ff80e8908..c5f801e45f 100644
--- a/src/cmd/compile/internal/types2/stmt.go
+++ b/src/cmd/compile/internal/types2/stmt.go
@@ -9,6 +9,7 @@ package types2
 import (
 	"cmd/compile/internal/syntax"
 	"go/constant"
+	. "internal/types/errors"
 	"sort"
 )
 
@@ -46,7 +47,7 @@ func (check *Checker) funcBody(decl *declInfo, name string, sig *Signature, body
 	}
 
 	if sig.results.Len() > 0 && !check.isTerminating(body, "") {
-		check.error(body.Rbrace, _MissingReturn, "missing return")
+		check.error(body.Rbrace, MissingReturn, "missing return")
 	}
 
 	// spec: "Implementation restriction: A compiler may make it illegal to
@@ -66,7 +67,7 @@ func (check *Checker) usage(scope *Scope) {
 		return unused[i].pos.Cmp(unused[j].pos) < 0
 	})
 	for _, v := range unused {
-		check.softErrorf(v.pos, _UnusedVar, "%s declared and not used", v.name)
+		check.softErrorf(v.pos, UnusedVar, "%s declared and not used", v.name)
 	}
 
 	for _, scope := range scope.children {
@@ -128,7 +129,7 @@ func (check *Checker) multipleSwitchDefaults(list []*syntax.CaseClause) {
 	for _, c := range list {
 		if c.Cases == nil {
 			if first != nil {
-				check.errorf(c, _DuplicateDefault, "multiple defaults (first at %s)", first.Pos())
+				check.errorf(c, DuplicateDefault, "multiple defaults (first at %s)", first.Pos())
 				// TODO(gri) probably ok to bail out after first error (and simplify this code)
 			} else {
 				first = c
@@ -142,7 +143,7 @@ func (check *Checker) multipleSelectDefaults(list []*syntax.CommClause) {
 	for _, c := range list {
 		if c.Comm == nil {
 			if first != nil {
-				check.errorf(c, _DuplicateDefault, "multiple defaults (first at %s)", first.Pos())
+				check.errorf(c, DuplicateDefault, "multiple defaults (first at %s)", first.Pos())
 				// TODO(gri) probably ok to bail out after first error (and simplify this code)
 			} else {
 				first = c
@@ -166,9 +167,9 @@ func (check *Checker) closeScope() {
 }
 
 func (check *Checker) suspendedCall(keyword string, call syntax.Expr) {
-	code := _InvalidDefer
+	code := InvalidDefer
 	if keyword == "go" {
-		code = _InvalidGo
+		code = InvalidGo
 	}
 
 	if _, ok := call.(*syntax.CallExpr); !ok {
@@ -184,7 +185,7 @@ func (check *Checker) suspendedCall(keyword string, call syntax.Expr) {
 		msg = "requires function call, not conversion"
 	case expression:
 		msg = "discards result of"
-		code = _UnusedResults
+		code = UnusedResults
 	case statement:
 		return
 	default:
@@ -263,7 +264,7 @@ L:
 			for _, vt := range seen[val] {
 				if Identical(v.typ, vt.typ) {
 					var err error_
-					err.code = _DuplicateCase
+					err.code = DuplicateCase
 					err.errorf(&v, "duplicate case %s in expression switch", &v)
 					err.errorf(vt.pos, "previous case")
 					check.report(&err)
@@ -310,7 +311,7 @@ L:
 					Ts = TypeString(T, check.qualifier)
 				}
 				var err error_
-				err.code = _DuplicateCase
+				err.code = DuplicateCase
 				err.errorf(e, "duplicate case %s in type switch", Ts)
 				err.errorf(other, "previous case")
 				check.report(&err)
@@ -404,20 +405,20 @@ func (check *Checker) stmt(ctxt stmtContext, s syntax.Stmt) {
 		var x operand
 		kind := check.rawExpr(&x, s.X, nil, false)
 		var msg string
-		var code errorCode
+		var code Code
 		switch x.mode {
 		default:
 			if kind == statement {
 				return
 			}
 			msg = "is not used"
-			code = _UnusedExpr
+			code = UnusedExpr
 		case builtin:
 			msg = "must be called"
-			code = _UncalledBuiltin
+			code = UncalledBuiltin
 		case typexpr:
 			msg = "is not an expression"
-			code = _NotAnExpr
+			code = NotAnExpr
 		}
 		check.errorf(&x, code, "%s %s", &x, msg)
 
@@ -430,16 +431,16 @@ func (check *Checker) stmt(ctxt stmtContext, s syntax.Stmt) {
 		}
 		u := coreType(ch.typ)
 		if u == nil {
-			check.errorf(s, _InvalidSend, invalidOp+"cannot send to %s: no core type", &ch)
+			check.errorf(s, InvalidSend, invalidOp+"cannot send to %s: no core type", &ch)
 			return
 		}
 		uch, _ := u.(*Chan)
 		if uch == nil {
-			check.errorf(s, _InvalidSend, invalidOp+"cannot send to non-channel %s", &ch)
+			check.errorf(s, InvalidSend, invalidOp+"cannot send to non-channel %s", &ch)
 			return
 		}
 		if uch.dir == RecvOnly {
-			check.errorf(s, _InvalidSend, invalidOp+"cannot send to receive-only channel %s", &ch)
+			check.errorf(s, InvalidSend, invalidOp+"cannot send to receive-only channel %s", &ch)
 			return
 		}
 		check.assignment(&val, uch.elem, "send")
@@ -458,7 +459,7 @@ func (check *Checker) stmt(ctxt stmtContext, s syntax.Stmt) {
 				return
 			}
 			if !allNumeric(x.typ) {
-				check.errorf(lhs[0], _NonNumericIncDec, invalidOp+"%s%s%s (non-numeric type %s)", lhs[0], s.Op, s.Op, x.typ)
+				check.errorf(lhs[0], NonNumericIncDec, invalidOp+"%s%s%s (non-numeric type %s)", lhs[0], s.Op, s.Op, x.typ)
 				return
 			}
 			check.assignVar(lhs[0], &x)
@@ -477,7 +478,7 @@ func (check *Checker) stmt(ctxt stmtContext, s syntax.Stmt) {
 
 		// assignment operations
 		if len(lhs) != 1 || len(rhs) != 1 {
-			check.errorf(s, _MultiValAssignOp, "assignment operation %s requires single-valued expressions", s.Op)
+			check.errorf(s, MultiValAssignOp, "assignment operation %s requires single-valued expressions", s.Op)
 			return
 		}
 
@@ -504,7 +505,7 @@ func (check *Checker) stmt(ctxt stmtContext, s syntax.Stmt) {
 			for _, obj := range res.vars {
 				if alt := check.lookup(obj.name); alt != nil && alt != obj {
 					var err error_
-					err.code = _OutOfScopeResult
+					err.code = OutOfScopeResult
 					err.errorf(s, "result parameter %s not in scope at return", obj.name)
 					err.errorf(alt, "inner declaration of %s", obj)
 					check.report(&err)
@@ -530,11 +531,11 @@ func (check *Checker) stmt(ctxt stmtContext, s syntax.Stmt) {
 		switch s.Tok {
 		case syntax.Break:
 			if ctxt&breakOk == 0 {
-				check.error(s, _MisplacedBreak, "break not in for, switch, or select statement")
+				check.error(s, MisplacedBreak, "break not in for, switch, or select statement")
 			}
 		case syntax.Continue:
 			if ctxt&continueOk == 0 {
-				check.error(s, _MisplacedContinue, "continue not in for statement")
+				check.error(s, MisplacedContinue, "continue not in for statement")
 			}
 		case syntax.Fallthrough:
 			if ctxt&fallthroughOk == 0 {
@@ -547,7 +548,7 @@ func (check *Checker) stmt(ctxt stmtContext, s syntax.Stmt) {
 				default:
 					msg = "fallthrough statement out of place"
 				}
-				check.error(s, _MisplacedFallthrough, msg)
+				check.error(s, MisplacedFallthrough, msg)
 			}
 		case syntax.Goto:
 			// goto's must have labels, should have been caught above
@@ -570,7 +571,7 @@ func (check *Checker) stmt(ctxt stmtContext, s syntax.Stmt) {
 		var x operand
 		check.expr(&x, s.Cond)
 		if x.mode != invalid && !allBoolean(x.typ) {
-			check.error(s.Cond, _InvalidCond, "non-boolean condition in if statement")
+			check.error(s.Cond, InvalidCond, "non-boolean condition in if statement")
 		}
 		check.stmt(inner, s.Then)
 		// The parser produces a correct AST but if it was modified
@@ -629,7 +630,7 @@ func (check *Checker) stmt(ctxt stmtContext, s syntax.Stmt) {
 			}
 
 			if !valid {
-				check.error(clause.Comm, _InvalidSelectCase, "select case must be send or receive (possibly with assignment)")
+				check.error(clause.Comm, InvalidSelectCase, "select case must be send or receive (possibly with assignment)")
 				continue
 			}
 			end := s.Rbrace
@@ -660,7 +661,7 @@ func (check *Checker) stmt(ctxt stmtContext, s syntax.Stmt) {
 			var x operand
 			check.expr(&x, s.Cond)
 			if x.mode != invalid && !allBoolean(x.typ) {
-				check.error(s.Cond, _InvalidCond, "non-boolean condition in for statement")
+				check.error(s.Cond, InvalidCond, "non-boolean condition in for statement")
 			}
 		}
 		check.simpleStmt(s.Post)
@@ -687,7 +688,7 @@ func (check *Checker) switchStmt(inner stmtContext, s *syntax.SwitchStmt) {
 		// (as a compiler would), we get all the relevant checks.
 		check.assignment(&x, nil, "switch expression")
 		if x.mode != invalid && !Comparable(x.typ) && !hasNil(x.typ) {
-			check.errorf(&x, _InvalidExprSwitch, "cannot switch on %s (%s is not comparable)", &x, x.typ)
+			check.errorf(&x, InvalidExprSwitch, "cannot switch on %s (%s is not comparable)", &x, x.typ)
 			x.mode = invalid
 		}
 	} else {
@@ -740,7 +741,7 @@ func (check *Checker) typeSwitchStmt(inner stmtContext, s *syntax.SwitchStmt, gu
 	if lhs != nil {
 		if lhs.Value == "_" {
 			// _ := x.(type) is an invalid short variable declaration
-			check.softErrorf(lhs, _NoNewVar, "no new variable on left side of :=")
+			check.softErrorf(lhs, NoNewVar, "no new variable on left side of :=")
 			lhs = nil // avoid declared and not used error below
 		} else {
 			check.recordDef(lhs, nil) // lhs variable is implicitly declared in each cause clause
@@ -757,12 +758,12 @@ func (check *Checker) typeSwitchStmt(inner stmtContext, s *syntax.SwitchStmt, gu
 	// TODO(gri) we may want to permit type switches on type parameter values at some point
 	var sx *operand // switch expression against which cases are compared against; nil if invalid
 	if isTypeParam(x.typ) {
-		check.errorf(&x, _InvalidTypeSwitch, "cannot use type switch on type parameter value %s", &x)
+		check.errorf(&x, InvalidTypeSwitch, "cannot use type switch on type parameter value %s", &x)
 	} else {
 		if _, ok := under(x.typ).(*Interface); ok {
 			sx = &x
 		} else {
-			check.errorf(&x, _InvalidTypeSwitch, "%s is not an interface", &x)
+			check.errorf(&x, InvalidTypeSwitch, "%s is not an interface", &x)
 		}
 	}
 
@@ -824,7 +825,7 @@ func (check *Checker) typeSwitchStmt(inner stmtContext, s *syntax.SwitchStmt, gu
 			v.used = true // avoid usage error when checking entire function
 		}
 		if !used {
-			check.softErrorf(lhs, _UnusedVar, "%s declared and not used", lhs.Value)
+			check.softErrorf(lhs, UnusedVar, "%s declared and not used", lhs.Value)
 		}
 	}
 }
@@ -859,7 +860,7 @@ func (check *Checker) rangeStmt(inner stmtContext, s *syntax.ForStmt, rclause *s
 		u := coreType(x.typ)
 		if t, _ := u.(*Chan); t != nil {
 			if sValue != nil {
-				check.softErrorf(sValue, _InvalidIterVar, "range over %s permits only one iteration variable", &x)
+				check.softErrorf(sValue, InvalidIterVar, "range over %s permits only one iteration variable", &x)
 				// ok to continue
 			}
 			if t.dir == SendOnly {
@@ -867,7 +868,7 @@ func (check *Checker) rangeStmt(inner stmtContext, s *syntax.ForStmt, rclause *s
 			}
 		} else {
 			if sExtra != nil {
-				check.softErrorf(sExtra, _InvalidIterVar, "range clause permits at most two iteration variables")
+				check.softErrorf(sExtra, InvalidIterVar, "range clause permits at most two iteration variables")
 				// ok to continue
 			}
 			if u == nil {
@@ -877,9 +878,9 @@ func (check *Checker) rangeStmt(inner stmtContext, s *syntax.ForStmt, rclause *s
 		key, val = rangeKeyVal(u)
 		if key == nil || cause != "" {
 			if cause == "" {
-				check.softErrorf(&x, _InvalidRangeExpr, "cannot range over %s", &x)
+				check.softErrorf(&x, InvalidRangeExpr, "cannot range over %s", &x)
 			} else {
-				check.softErrorf(&x, _InvalidRangeExpr, "cannot range over %s (%s)", &x, cause)
+				check.softErrorf(&x, InvalidRangeExpr, "cannot range over %s (%s)", &x, cause)
 			}
 			// ok to continue
 		}
@@ -940,7 +941,7 @@ func (check *Checker) rangeStmt(inner stmtContext, s *syntax.ForStmt, rclause *s
 				check.declare(check.scope, nil /* recordDef already called */, obj, scopePos)
 			}
 		} else {
-			check.error(s, _NoNewVar, "no new variables on left side of :=")
+			check.error(s, NoNewVar, "no new variables on left side of :=")
 		}
 	} else {
 		// ordinary assignment
diff --git a/src/cmd/compile/internal/types2/struct.go b/src/cmd/compile/internal/types2/struct.go
index 77f8b6d93b..6d37710724 100644
--- a/src/cmd/compile/internal/types2/struct.go
+++ b/src/cmd/compile/internal/types2/struct.go
@@ -6,6 +6,7 @@ package types2
 
 import (
 	"cmd/compile/internal/syntax"
+	. "internal/types/errors"
 	"strconv"
 )
 
@@ -152,20 +153,20 @@ func (check *Checker) structType(styp *Struct, e *syntax.StructType) {
 					}
 					// unsafe.Pointer is treated like a regular pointer
 					if u.kind == UnsafePointer {
-						check.error(embeddedPos, _InvalidPtrEmbed, "embedded field type cannot be unsafe.Pointer")
+						check.error(embeddedPos, InvalidPtrEmbed, "embedded field type cannot be unsafe.Pointer")
 					}
 				case *Pointer:
-					check.error(embeddedPos, _InvalidPtrEmbed, "embedded field type cannot be a pointer")
+					check.error(embeddedPos, InvalidPtrEmbed, "embedded field type cannot be a pointer")
 				case *Interface:
 					if isTypeParam(t) {
 						// The error code here is inconsistent with other error codes for
 						// invalid embedding, because this restriction may be relaxed in the
 						// future, and so it did not warrant a new error code.
-						check.error(embeddedPos, _MisplacedTypeParam, "embedded field type cannot be a (pointer to a) type parameter")
+						check.error(embeddedPos, MisplacedTypeParam, "embedded field type cannot be a (pointer to a) type parameter")
 						break
 					}
 					if isPtr {
-						check.error(embeddedPos, _InvalidPtrEmbed, "embedded field type cannot be a pointer to an interface")
+						check.error(embeddedPos, InvalidPtrEmbed, "embedded field type cannot be a pointer to an interface")
 					}
 				}
 			}).describef(embeddedPos, "check embedded type %s", embeddedTyp)
@@ -199,7 +200,7 @@ func embeddedFieldIdent(e syntax.Expr) *syntax.Name {
 func (check *Checker) declareInSet(oset *objset, pos syntax.Pos, obj Object) bool {
 	if alt := oset.insert(obj); alt != nil {
 		var err error_
-		err.code = _DuplicateDecl
+		err.code = DuplicateDecl
 		err.errorf(pos, "%s redeclared", obj.Name())
 		err.recordAltDecl(alt)
 		check.report(&err)
diff --git a/src/cmd/compile/internal/types2/typeset.go b/src/cmd/compile/internal/types2/typeset.go
index 79fab12be8..391ea8cd79 100644
--- a/src/cmd/compile/internal/types2/typeset.go
+++ b/src/cmd/compile/internal/types2/typeset.go
@@ -7,6 +7,7 @@ package types2
 import (
 	"cmd/compile/internal/syntax"
 	"fmt"
+	. "internal/types/errors"
 	"sort"
 	"strings"
 )
@@ -226,7 +227,7 @@ func computeInterfaceTypeSet(check *Checker, pos syntax.Pos, ityp *Interface) *_
 			}
 			// check != nil
 			var err error_
-			err.code = _DuplicateDecl
+			err.code = DuplicateDecl
 			err.errorf(pos, "duplicate method %s", m.name)
 			err.errorf(mpos[other.(*Func)], "other declaration of %s", m.name)
 			check.report(&err)
@@ -245,7 +246,7 @@ func computeInterfaceTypeSet(check *Checker, pos syntax.Pos, ityp *Interface) *_
 			check.later(func() {
 				if !check.allowVersion(m.pkg, 1, 14) || !Identical(m.typ, other.Type()) {
 					var err error_
-					err.code = _DuplicateDecl
+					err.code = DuplicateDecl
 					err.errorf(pos, "duplicate method %s", m.name)
 					err.errorf(mpos[other.(*Func)], "other declaration of %s", m.name)
 					check.report(&err)
@@ -423,7 +424,7 @@ func computeUnionTypeSet(check *Checker, unionSets map[*Union]*_TypeSet, pos syn
 		allTerms = allTerms.union(terms)
 		if len(allTerms) > maxTermCount {
 			if check != nil {
-				check.errorf(pos, _InvalidUnion, "cannot handle more than %d union terms (implementation limitation)", maxTermCount)
+				check.errorf(pos, InvalidUnion, "cannot handle more than %d union terms (implementation limitation)", maxTermCount)
 			}
 			unionSets[utyp] = &invalidTypeSet
 			return unionSets[utyp]
diff --git a/src/cmd/compile/internal/types2/typexpr.go b/src/cmd/compile/internal/types2/typexpr.go
index 934336cf49..a85e2d9ce0 100644
--- a/src/cmd/compile/internal/types2/typexpr.go
+++ b/src/cmd/compile/internal/types2/typexpr.go
@@ -10,6 +10,7 @@ import (
 	"cmd/compile/internal/syntax"
 	"fmt"
 	"go/constant"
+	. "internal/types/errors"
 	"strings"
 )
 
@@ -34,10 +35,10 @@ func (check *Checker) ident(x *operand, e *syntax.Name, def *Named, wantType boo
 				x.mode = typexpr
 				x.typ = tpar
 			} else {
-				check.error(e, _InvalidBlank, "cannot use _ as value or type")
+				check.error(e, InvalidBlank, "cannot use _ as value or type")
 			}
 		} else {
-			check.errorf(e, _UndeclaredName, "undefined: %s", e.Value)
+			check.errorf(e, UndeclaredName, "undefined: %s", e.Value)
 		}
 		return
 	case universeAny, universeComparable:
@@ -73,7 +74,7 @@ func (check *Checker) ident(x *operand, e *syntax.Name, def *Named, wantType boo
 
 	switch obj := obj.(type) {
 	case *PkgName:
-		check.errorf(e, _InvalidPkgUse, "use of package %s not in selector", obj.name)
+		check.errorf(e, InvalidPkgUse, "use of package %s not in selector", obj.name)
 		return
 
 	case *Const:
@@ -83,7 +84,7 @@ func (check *Checker) ident(x *operand, e *syntax.Name, def *Named, wantType boo
 		}
 		if obj == universeIota {
 			if check.iota == nil {
-				check.error(e, _InvalidIota, "cannot use iota outside constant declaration")
+				check.error(e, InvalidIota, "cannot use iota outside constant declaration")
 				return
 			}
 			x.val = check.iota
@@ -95,7 +96,7 @@ func (check *Checker) ident(x *operand, e *syntax.Name, def *Named, wantType boo
 
 	case *TypeName:
 		if check.isBrokenAlias(obj) {
-			check.errorf(e, _InvalidDeclCycle, "invalid use of type alias %s in recursive type (see issue #50729)", obj.name)
+			check.errorf(e, InvalidDeclCycle, "invalid use of type alias %s in recursive type (see issue #50729)", obj.name)
 			return
 		}
 		x.mode = typexpr
@@ -163,9 +164,9 @@ func (check *Checker) validVarType(e syntax.Expr, typ Type) {
 			tset := computeInterfaceTypeSet(check, pos, t) // TODO(gri) is this the correct position?
 			if !tset.IsMethodSet() {
 				if tset.comparable {
-					check.softErrorf(pos, _MisplacedConstraintIface, "cannot use type %s outside a type constraint: interface is (or embeds) comparable", typ)
+					check.softErrorf(pos, MisplacedConstraintIface, "cannot use type %s outside a type constraint: interface is (or embeds) comparable", typ)
 				} else {
-					check.softErrorf(pos, _MisplacedConstraintIface, "cannot use type %s outside a type constraint: interface contains type constraints", typ)
+					check.softErrorf(pos, MisplacedConstraintIface, "cannot use type %s outside a type constraint: interface contains type constraints", typ)
 				}
 			}
 		}
@@ -180,7 +181,7 @@ func (check *Checker) definedType(e syntax.Expr, def *Named) Type {
 	typ := check.typInternal(e, def)
 	assert(isTyped(typ))
 	if isGeneric(typ) {
-		check.errorf(e, _WrongTypeArgCount, "cannot use generic type %s without instantiation", typ)
+		check.errorf(e, WrongTypeArgCount, "cannot use generic type %s without instantiation", typ)
 		typ = Typ[Invalid]
 	}
 	check.recordTypeAndValue(e, typexpr, typ, nil)
@@ -248,9 +249,9 @@ func (check *Checker) typInternal(e0 syntax.Expr, def *Named) (T Type) {
 		case invalid:
 			// ignore - error reported before
 		case novalue:
-			check.errorf(&x, _NotAType, "%s used as type", &x)
+			check.errorf(&x, NotAType, "%s used as type", &x)
 		default:
-			check.errorf(&x, _NotAType, "%s is not a type", &x)
+			check.errorf(&x, NotAType, "%s is not a type", &x)
 		}
 
 	case *syntax.SelectorExpr:
@@ -265,9 +266,9 @@ func (check *Checker) typInternal(e0 syntax.Expr, def *Named) (T Type) {
 		case invalid:
 			// ignore - error reported before
 		case novalue:
-			check.errorf(&x, _NotAType, "%s used as type", &x)
+			check.errorf(&x, NotAType, "%s used as type", &x)
 		default:
-			check.errorf(&x, _NotAType, "%s is not a type", &x)
+			check.errorf(&x, NotAType, "%s is not a type", &x)
 		}
 
 	case *syntax.IndexExpr:
@@ -288,7 +289,7 @@ func (check *Checker) typInternal(e0 syntax.Expr, def *Named) (T Type) {
 			typ.len = check.arrayLength(e.Len)
 		} else {
 			// [...]array
-			check.error(e, _BadDotDotDotSyntax, "invalid use of [...] array (outside a composite literal)")
+			check.error(e, BadDotDotDotSyntax, "invalid use of [...] array (outside a composite literal)")
 			typ.len = -1
 		}
 		typ.elem = check.varType(e.Elem)
@@ -306,7 +307,7 @@ func (check *Checker) typInternal(e0 syntax.Expr, def *Named) (T Type) {
 	case *syntax.DotsType:
 		// dots are handled explicitly where they are legal
 		// (array composite literals and parameter lists)
-		check.error(e, _InvalidDotDotDot, "invalid use of '...'")
+		check.error(e, InvalidDotDotDot, "invalid use of '...'")
 		check.use(e.Elem)
 
 	case *syntax.StructType:
@@ -331,7 +332,7 @@ func (check *Checker) typInternal(e0 syntax.Expr, def *Named) (T Type) {
 			return typ
 		}
 
-		check.errorf(e0, _NotAType, "%s is not a type", e0)
+		check.errorf(e0, NotAType, "%s is not a type", e0)
 		check.use(e0)
 
 	case *syntax.FuncType:
@@ -365,7 +366,7 @@ func (check *Checker) typInternal(e0 syntax.Expr, def *Named) (T Type) {
 				if isTypeParam(typ.key) {
 					why = " (missing comparable constraint)"
 				}
-				check.errorf(e.Key, _IncomparableMapKey, "invalid map key type %s%s", typ.key, why)
+				check.errorf(e.Key, IncomparableMapKey, "invalid map key type %s%s", typ.key, why)
 			}
 		}).describef(e.Key, "check map key %s", typ.key)
 
@@ -393,7 +394,7 @@ func (check *Checker) typInternal(e0 syntax.Expr, def *Named) (T Type) {
 		return typ
 
 	default:
-		check.errorf(e0, _NotAType, "%s is not a type", e0)
+		check.errorf(e0, NotAType, "%s is not a type", e0)
 		check.use(e0)
 	}
 
@@ -416,7 +417,7 @@ func (check *Checker) instantiatedType(x syntax.Expr, xlist []syntax.Expr, def *
 	var cause string
 	gtyp := check.genericType(x, &cause)
 	if cause != "" {
-		check.errorf(x, _NotAGenericType, invalidOp+"%s%s (%s)", x, xlist, cause)
+		check.errorf(x, NotAGenericType, invalidOp+"%s%s (%s)", x, xlist, cause)
 	}
 	if gtyp == Typ[Invalid] {
 		return gtyp // error already reported
@@ -452,7 +453,7 @@ func (check *Checker) instantiatedType(x syntax.Expr, xlist []syntax.Expr, def *
 				if i < len(xlist) {
 					pos = syntax.StartPos(xlist[i])
 				}
-				check.softErrorf(pos, _InvalidTypeArg, "%s", err)
+				check.softErrorf(pos, InvalidTypeArg, "%s", err)
 			} else {
 				check.mono.recordInstance(check.pkg, x.Pos(), inst.TypeParams().list(), inst.TypeArgs().list(), xlist)
 			}
@@ -478,11 +479,11 @@ func (check *Checker) arrayLength(e syntax.Expr) int64 {
 	if name, _ := e.(*syntax.Name); name != nil {
 		obj := check.lookup(name.Value)
 		if obj == nil {
-			check.errorf(name, _InvalidArrayLen, "undefined array length %s or missing type constraint", name.Value)
+			check.errorf(name, InvalidArrayLen, "undefined array length %s or missing type constraint", name.Value)
 			return -1
 		}
 		if _, ok := obj.(*Const); !ok {
-			check.errorf(name, _InvalidArrayLen, "invalid array length %s", name.Value)
+			check.errorf(name, InvalidArrayLen, "invalid array length %s", name.Value)
 			return -1
 		}
 	}
@@ -491,7 +492,7 @@ func (check *Checker) arrayLength(e syntax.Expr) int64 {
 	check.expr(&x, e)
 	if x.mode != constant_ {
 		if x.mode != invalid {
-			check.errorf(&x, _InvalidArrayLen, "array length %s must be constant", &x)
+			check.errorf(&x, InvalidArrayLen, "array length %s must be constant", &x)
 		}
 		return -1
 	}
@@ -502,13 +503,13 @@ func (check *Checker) arrayLength(e syntax.Expr) int64 {
 				if n, ok := constant.Int64Val(val); ok && n >= 0 {
 					return n
 				}
-				check.errorf(&x, _InvalidArrayLen, "invalid array length %s", &x)
+				check.errorf(&x, InvalidArrayLen, "invalid array length %s", &x)
 				return -1
 			}
 		}
 	}
 
-	check.errorf(&x, _InvalidArrayLen, "array length %s must be integer", &x)
+	check.errorf(&x, InvalidArrayLen, "array length %s must be integer", &x)
 	return -1
 }
 
diff --git a/src/cmd/compile/internal/types2/union.go b/src/cmd/compile/internal/types2/union.go
index 782e5d2a63..1fafb052c1 100644
--- a/src/cmd/compile/internal/types2/union.go
+++ b/src/cmd/compile/internal/types2/union.go
@@ -4,7 +4,10 @@
 
 package types2
 
-import "cmd/compile/internal/syntax"
+import (
+	"cmd/compile/internal/syntax"
+	. "internal/types/errors"
+)
 
 // ----------------------------------------------------------------------------
 // API
@@ -64,7 +67,7 @@ func parseUnion(check *Checker, uexpr syntax.Expr) Type {
 		}
 		if len(terms) >= maxTermCount {
 			if u != Typ[Invalid] {
-				check.errorf(x, _InvalidUnion, "cannot handle more than %d union terms (implementation limitation)", maxTermCount)
+				check.errorf(x, InvalidUnion, "cannot handle more than %d union terms (implementation limitation)", maxTermCount)
 				u = Typ[Invalid]
 			}
 		} else {
@@ -94,12 +97,12 @@ func parseUnion(check *Checker, uexpr syntax.Expr) Type {
 			f, _ := u.(*Interface)
 			if t.tilde {
 				if f != nil {
-					check.errorf(tlist[i], _InvalidUnion, "invalid use of ~ (%s is an interface)", t.typ)
+					check.errorf(tlist[i], InvalidUnion, "invalid use of ~ (%s is an interface)", t.typ)
 					continue // don't report another error for t
 				}
 
 				if !Identical(u, t.typ) {
-					check.errorf(tlist[i], _InvalidUnion, "invalid use of ~ (underlying type of %s is %s)", t.typ, u)
+					check.errorf(tlist[i], InvalidUnion, "invalid use of ~ (underlying type of %s is %s)", t.typ, u)
 					continue
 				}
 			}
@@ -112,11 +115,11 @@ func parseUnion(check *Checker, uexpr syntax.Expr) Type {
 				tset := f.typeSet()
 				switch {
 				case tset.NumMethods() != 0:
-					check.errorf(tlist[i], _InvalidUnion, "cannot use %s in union (%s contains methods)", t, t)
+					check.errorf(tlist[i], InvalidUnion, "cannot use %s in union (%s contains methods)", t, t)
 				case t.typ == universeComparable.Type():
-					check.error(tlist[i], _InvalidUnion, "cannot use comparable in union")
+					check.error(tlist[i], InvalidUnion, "cannot use comparable in union")
 				case tset.comparable:
-					check.errorf(tlist[i], _InvalidUnion, "cannot use %s in union (%s embeds comparable)", t, t)
+					check.errorf(tlist[i], InvalidUnion, "cannot use %s in union (%s embeds comparable)", t, t)
 				}
 				continue // terms with interface types are not subject to the no-overlap rule
 			}
@@ -124,7 +127,7 @@ func parseUnion(check *Checker, uexpr syntax.Expr) Type {
 			// Report overlapping (non-disjoint) terms such as
 			// a|a, a|~a, ~a|~a, and ~a|A (where under(A) == a).
 			if j := overlappingTerm(terms[:i], t); j >= 0 {
-				check.softErrorf(tlist[i], _InvalidUnion, "overlapping terms %s and %s", t, terms[j])
+				check.softErrorf(tlist[i], InvalidUnion, "overlapping terms %s and %s", t, terms[j])
 			}
 		}
 	}).describef(uexpr, "check term validity %s", uexpr)
@@ -147,9 +150,9 @@ func parseTilde(check *Checker, tx syntax.Expr) *Term {
 	// and since the underlying type is an interface the embedding is well defined.
 	if isTypeParam(typ) {
 		if tilde {
-			check.errorf(x, _MisplacedTypeParam, "type in term %s cannot be a type parameter", tx)
+			check.errorf(x, MisplacedTypeParam, "type in term %s cannot be a type parameter", tx)
 		} else {
-			check.error(x, _MisplacedTypeParam, "term cannot be a type parameter")
+			check.error(x, MisplacedTypeParam, "term cannot be a type parameter")
 		}
 		typ = Typ[Invalid]
 	}
diff --git a/src/cmd/dist/buildtool.go b/src/cmd/dist/buildtool.go
index eee738b43c..e2699f7656 100644
--- a/src/cmd/dist/buildtool.go
+++ b/src/cmd/dist/buildtool.go
@@ -68,6 +68,7 @@ var bootstrapDirs = []string{
 	"internal/race",
 	"internal/saferio",
 	"internal/platform",
+	"internal/types/errors",
 	"internal/unsafeheader",
 	"internal/xcoff",
 	"math/big",
