commit be7e0f8160f173844108a537a988b800c558e652
Author: Rob Pike <r@golang.org>
Date:   Wed Nov 19 15:38:46 2008 -0800

    gotestify regexp
    
    R=rsc
    DELTA=101  (53 added, 25 deleted, 23 changed)
    OCL=19635
    CL=19637
---
 src/lib/regexp/Makefile | 60 +++++++++++++++++++++++++++++++++++--------------
 src/lib/regexp/test.go  | 52 +++++++++++++++++++++---------------------
 2 files changed, 70 insertions(+), 42 deletions(-)

diff --git a/src/lib/regexp/Makefile b/src/lib/regexp/Makefile
index 45ee7d4418..3e82f1c1f6 100644
--- a/src/lib/regexp/Makefile
+++ b/src/lib/regexp/Makefile
@@ -2,28 +2,54 @@
 # Use of this source code is governed by a BSD-style
 # license that can be found in the LICENSE file.
 
-A=6
-G=$(A)g
-L=$(A)l
-PKG=$(GOROOT)/pkg/regexp.$A
+# DO NOT EDIT.  Automatically generated by gobuild.
+# gobuild -m >Makefile
+O=6
+GC=$(O)g
+CC=$(O)c -w
+AS=$(O)a
+AR=$(O)ar
 
-test:	main.$A test.$A
-	$L -o test test.$A
-	./test
+default: packages
 
-install:	regexp.$A
-	cp regexp.$A $(PKG)
+clean:
+	rm -f *.$O *.a $O.out
 
-main:	main.$A
-	$L -o main main.$A
+test: packages
+	gotest
 
-main.$A: regexp.$A
+coverage: packages
+	gotest
+	6cov -g `pwd` | grep -v '^test.*\.go:'
 
-clean:
-	rm -f *.6 test
+%.$O: %.go
+	$(GC) $*.go
+
+%.$O: %.c
+	$(CC) $*.c
+
+%.$O: %.s
+	$(AS) $*.s
+
+O1=\
+	regexp.$O\
+
+regexp.a: a1
+
+a1:	$(O1)
+	$(AR) grc regexp.a regexp.$O
+	rm -f $(O1)
+
+newpkg: clean
+	$(AR) grc regexp.a
+
+$(O1): newpkg
 
 nuke: clean
-	rm -f $(PKG)
+	rm -f $(GOROOT)/pkg/regexp.a
+
+packages: regexp.a
+
+install: packages
+	cp regexp.a $(GOROOT)/pkg/regexp.a
 
-%.6:	%.go
-	$G $<
diff --git a/src/lib/regexp/test.go b/src/lib/regexp/test.go
index 223064c071..dd2e94712d 100644
--- a/src/lib/regexp/test.go
+++ b/src/lib/regexp/test.go
@@ -2,11 +2,12 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package main
+package regexp
 
 import (
 	"os";
 	"regexp";
+	"testing";
 )
 
 var good_re = []string{
@@ -85,11 +86,10 @@ var matches = []Tester {
 	Tester{ `a*(|(b))c*`,	"aacc",	Vec{0,4, 2,2, -1,-1, END} },
 }
 
-func Compile(expr string, error *os.Error) regexp.Regexp {
+func CompileTest(t *testing.T, expr string, error *os.Error) regexp.Regexp {
 	re, err := regexp.Compile(expr);
 	if err != error {
-		print("compiling `", expr, "`; unexpected error: ", err.String(), "\n");
-		sys.exit(1);
+		t.Error("compiling `", expr, "`; unexpected error: ", err.String());
 	}
 	return re
 }
@@ -104,13 +104,13 @@ func MarkedLen(m *[] int) int {
 	return i
 }
 
-func PrintVec(m *[] int) {
+func PrintVec(t *testing.T, m *[] int) {
 	l := MarkedLen(m);
 	if l == 0 {
-		print("<no match>");
+		t.Log("\t<no match>");
 	} else {
 		for i := 0; i < l && m[i] != END; i = i+2 {
-			print(m[i], ",", m[i+1], " ")
+			t.Log("\t", m[i], ",", m[i+1])
 		}
 	}
 }
@@ -128,33 +128,35 @@ func Equal(m1, m2 *[]int) bool {
 	return true
 }
 
-func Match(expr string, str string, match *[]int) {
-	re := Compile(expr, nil);
+func MatchTest(t *testing.T, expr string, str string, match *[]int) {
+	re := CompileTest(t, expr, nil);
+	if re == nil {
+		return
+	}
 	m := re.Execute(str);
 	if !Equal(m, match) {
-		print("failure on `", expr, "` matching `", str, "`:\n");
-		PrintVec(m);
-		print("\nshould be:\n");
-		PrintVec(match);
-		print("\n");
-		sys.exit(1);
+		t.Error("failure on `", expr, "` matching `", str, "`:");
+		PrintVec(t, m);
+		t.Log("should be:");
+		PrintVec(t, match);
 	}
 }
 
-func main() {
-	//regexp.debug = true;
-	if sys.argc() > 1 {
-		Compile(sys.argv(1), nil);
-		sys.exit(0);
-	}
+export func TestGoodCompile(t *testing.T) {
 	for i := 0; i < len(good_re); i++ {
-		Compile(good_re[i], nil);
+		CompileTest(t, good_re[i], nil);
 	}
+}
+
+export func TestBadCompile(t *testing.T) {
 	for i := 0; i < len(bad_re); i++ {
-		Compile(bad_re[i].re, bad_re[i].err)
+		CompileTest(t, bad_re[i].re, bad_re[i].err)
 	}
+}
+
+export func TestMatch(t *testing.T) {
 	for i := 0; i < len(matches); i++ {
-		t := &matches[i];
-		Match(t.re, t.text, &t.match)
+		test := &matches[i];
+		MatchTest(t, test.re, test.text, &test.match)
 	}
 }
