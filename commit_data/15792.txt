commit ee3c88482ba232a34e4b20c8474fdee64a37ca36
Author: Jan Ziak <0xe2.0x9a.0x9b@gmail.com>
Date:   Fri Mar 15 12:37:40 2013 -0400

    runtime: remove struct BitTarget
    
    R=golang-dev
    CC=dvyukov, golang-dev, rsc
    https://golang.org/cl/7845043
---
 src/pkg/runtime/mgc0.c | 38 ++++++++++++--------------------------
 1 file changed, 12 insertions(+), 26 deletions(-)

diff --git a/src/pkg/runtime/mgc0.c b/src/pkg/runtime/mgc0.c
index 4cafda4439..5edaec0024 100644
--- a/src/pkg/runtime/mgc0.c
+++ b/src/pkg/runtime/mgc0.c
@@ -270,7 +270,7 @@ found:
 	return true;
 }
 
-// PtrTarget and BitTarget are structures used by intermediate buffers.
+// PtrTarget is a structure used by intermediate buffers.
 // The intermediate buffers hold GC data before it
 // is moved/flushed to the work buffer (Workbuf).
 // The size of an intermediate buffer is very small,
@@ -282,19 +282,10 @@ struct PtrTarget
 	uintptr ti;
 };
 
-typedef struct BitTarget BitTarget;
-struct BitTarget
-{
-	void *p;
-	uintptr ti;
-	uintptr *bitp, shift;
-};
-
 typedef struct BufferList BufferList;
 struct BufferList
 {
 	PtrTarget ptrtarget[IntermediateBufferCapacity];
-	BitTarget bittarget[IntermediateBufferCapacity];
 	Obj obj[IntermediateBufferCapacity];
 	BufferList *next;
 };
@@ -311,7 +302,6 @@ static void enqueue(Obj obj, Workbuf **_wbuf, Obj **_wp, uintptr *_nobj);
 // and are prepared to be scanned by the garbage collector.
 //
 // _wp, _wbuf, _nobj are input/output parameters and are specifying the work buffer.
-// bitbuf holds temporary data generated by this function.
 //
 // A simplified drawing explaining how the todo-list moves from a structure to another:
 //
@@ -319,14 +309,12 @@ static void enqueue(Obj obj, Workbuf **_wbuf, Obj **_wp, uintptr *_nobj);
 //  (find pointers)
 //    Obj ------> PtrTarget (pointer targets)
 //     ↑          |
-//     |          | flushptrbuf (1st part,
-//     |          | find block start)
-//     |          ↓
-//     `--------- BitTarget (pointer targets and the corresponding locations in bitmap)
-//  flushptrbuf
-//  (2nd part, mark and enqueue)
+//     |          |
+//     `----------'
+//     flushptrbuf
+//  (find block start, mark and enqueue)
 static void
-flushptrbuf(PtrTarget *ptrbuf, PtrTarget **ptrbufpos, Obj **_wp, Workbuf **_wbuf, uintptr *_nobj, BitTarget *bitbuf)
+flushptrbuf(PtrTarget *ptrbuf, PtrTarget **ptrbufpos, Obj **_wp, Workbuf **_wbuf, uintptr *_nobj)
 {
 	byte *p, *arena_start, *obj;
 	uintptr size, *bitp, bits, shift, j, x, xbits, off, nobj, ti, n;
@@ -585,7 +573,6 @@ scanblock(Workbuf *wbuf, Obj *wp, uintptr nobj, bool keepworking)
 	Frame *stack_ptr, stack_top, stack[GC_STACK_CAPACITY+4];
 	BufferList *scanbuffers;
 	PtrTarget *ptrbuf, *ptrbuf_end, *ptrbufpos;
-	BitTarget *bitbuf;
 	Obj *objbuf, *objbuf_end, *objbufpos;
 	Eface *eface;
 	Iface *iface;
@@ -609,7 +596,7 @@ scanblock(Workbuf *wbuf, Obj *wp, uintptr nobj, bool keepworking)
 	precise_type = false;
 	nominal_size = 0;
 
-	// Allocate ptrbuf, bitbuf
+	// Allocate ptrbuf
 	{
 		runtime·lock(&lock);
 
@@ -624,7 +611,6 @@ scanblock(Workbuf *wbuf, Obj *wp, uintptr nobj, bool keepworking)
 
 		ptrbuf = &scanbuffers->ptrtarget[0];
 		ptrbuf_end = &scanbuffers->ptrtarget[0] + nelem(scanbuffers->ptrtarget);
-		bitbuf = &scanbuffers->bittarget[0];
 		objbuf = &scanbuffers->obj[0];
 		objbuf_end = &scanbuffers->obj[0] + nelem(scanbuffers->obj);
 
@@ -794,7 +780,7 @@ scanblock(Workbuf *wbuf, Obj *wp, uintptr nobj, bool keepworking)
 			if((void*)iface->tab >= arena_start && (void*)iface->tab < arena_used) {
 				*ptrbufpos++ = (PtrTarget){iface->tab, (uintptr)itabtype->gc};
 				if(ptrbufpos == ptrbuf_end)
-					flushptrbuf(ptrbuf, &ptrbufpos, &wp, &wbuf, &nobj, bitbuf);
+					flushptrbuf(ptrbuf, &ptrbufpos, &wp, &wbuf, &nobj);
 			}
 
 			// iface->data
@@ -821,7 +807,7 @@ scanblock(Workbuf *wbuf, Obj *wp, uintptr nobj, bool keepworking)
 				if(obj >= arena_start && obj < arena_used) {
 					*ptrbufpos++ = (PtrTarget){obj, 0};
 					if(ptrbufpos == ptrbuf_end)
-						flushptrbuf(ptrbuf, &ptrbufpos, &wp, &wbuf, &nobj, bitbuf);
+						flushptrbuf(ptrbuf, &ptrbufpos, &wp, &wbuf, &nobj);
 				}
 			}
 			goto next_block;
@@ -923,7 +909,7 @@ scanblock(Workbuf *wbuf, Obj *wp, uintptr nobj, bool keepworking)
 			while(hash_gciter_next(&map_iter, &d)) {
 				// buffers: reserve space for 2 objects.
 				if(ptrbufpos+2 >= ptrbuf_end)
-					flushptrbuf(ptrbuf, &ptrbufpos, &wp, &wbuf, &nobj, bitbuf);
+					flushptrbuf(ptrbuf, &ptrbufpos, &wp, &wbuf, &nobj);
 				if(objbufpos+2 >= objbuf_end)
 					flushobjbuf(objbuf, &objbufpos, &wp, &wbuf, &nobj);
 
@@ -989,7 +975,7 @@ scanblock(Workbuf *wbuf, Obj *wp, uintptr nobj, bool keepworking)
 		if(obj >= arena_start && obj < arena_used) {
 			*ptrbufpos++ = (PtrTarget){obj, objti};
 			if(ptrbufpos == ptrbuf_end)
-				flushptrbuf(ptrbuf, &ptrbufpos, &wp, &wbuf, &nobj, bitbuf);
+				flushptrbuf(ptrbuf, &ptrbufpos, &wp, &wbuf, &nobj);
 		}
 	}
 
@@ -998,7 +984,7 @@ scanblock(Workbuf *wbuf, Obj *wp, uintptr nobj, bool keepworking)
 		// the loop by setting b, n, ti to the parameters for the next block.
 
 		if(nobj == 0) {
-			flushptrbuf(ptrbuf, &ptrbufpos, &wp, &wbuf, &nobj, bitbuf);
+			flushptrbuf(ptrbuf, &ptrbufpos, &wp, &wbuf, &nobj);
 			flushobjbuf(objbuf, &objbufpos, &wp, &wbuf, &nobj);
 
 			if(nobj == 0) {
