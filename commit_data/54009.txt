commit 3a067b288ef235fdbc88220ea5bb384e0474f09b
Author: Paul E. Murphy <murp@ibm.com>
Date:   Fri May 21 11:26:01 2021 -0500

    cmd/internal/obj/ppc64: add ISA 3.1 instructions
    
    Use ppc64map (from x/arch) to generate ISA 3.1 support for the
    assembler. A new file asm9_gtables.go is added which contains
    generated code to encode ISA 3.1 instructions, a function to assist
    filling out the oprange structure, a lookup table for the fixed
    bits of each instructions, and a slice of string name. Generated
    functions are shared if their bitwise encoding match, and the
    translation from an obj.Prog structure matches.
    
    The generated file is entirely self-contained, and does not require
    regenerating any other files for changes within it. If opcodes in
    a.out.go are reordered or changed, anames.go must be updated in
    the same way as before.
    
    Future improvements could shrink the generated opcode table
    to 32 bit entries as there is much less variation of the
    encoding of the prefix word, but it is not always identical
    for instructions which share a similar encoding of arguments
    (e.g PLWA and PLWZ).
    
    Updates #44549
    
    Change-Id: Ie83fa02497c9ad2280678d68391043d3aae63175
    Reviewed-on: https://go-review.googlesource.com/c/go/+/419535
    Run-TryBot: Paul Murphy <murp@ibm.com>
    TryBot-Result: Gopher Robot <gobot@golang.org>
    Run-TryBot: Jenny Rakoczy <jenny@golang.org>
    Reviewed-by: Lynn Boger <laboger@linux.vnet.ibm.com>
    Reviewed-by: Jenny Rakoczy <jenny@golang.org>
    Reviewed-by: Michael Pratt <mpratt@google.com>
    Auto-Submit: Jenny Rakoczy <jenny@golang.org>
---
 src/cmd/asm/internal/arch/arch.go             |    5 +
 src/cmd/asm/internal/asm/endtoend_test.go     |    3 +
 src/cmd/asm/internal/asm/testdata/ppc64_p10.s |  266 ++++
 src/cmd/internal/obj/ppc64/a.out.go           |   11 +-
 src/cmd/internal/obj/ppc64/anames.go          |    3 +-
 src/cmd/internal/obj/ppc64/asm9.go            |   59 +-
 src/cmd/internal/obj/ppc64/asm9_gtables.go    | 1616 +++++++++++++++++++++++++
 src/cmd/internal/obj/ppc64/list9.go           |    4 +-
 src/cmd/internal/obj/ppc64/obj9.go            |   12 +
 9 files changed, 1934 insertions(+), 45 deletions(-)

diff --git a/src/cmd/asm/internal/arch/arch.go b/src/cmd/asm/internal/arch/arch.go
index e9c15a1218..740711c40c 100644
--- a/src/cmd/asm/internal/arch/arch.go
+++ b/src/cmd/asm/internal/arch/arch.go
@@ -377,6 +377,11 @@ func archPPC64(linkArch *obj.LinkArch) *Arch {
 			instructions[s] = obj.As(i) + obj.ABasePPC64
 		}
 	}
+	// The opcodes generated by x/arch's ppc64map are listed in
+	// a separate slice, add them too.
+	for i, s := range ppc64.GenAnames {
+		instructions[s] = obj.As(i) + ppc64.AFIRSTGEN
+	}
 	// Annoying aliases.
 	instructions["BR"] = ppc64.ABR
 	instructions["BL"] = ppc64.ABL
diff --git a/src/cmd/asm/internal/asm/endtoend_test.go b/src/cmd/asm/internal/asm/endtoend_test.go
index 78b72ca9c4..d3f17358a8 100644
--- a/src/cmd/asm/internal/asm/endtoend_test.go
+++ b/src/cmd/asm/internal/asm/endtoend_test.go
@@ -455,6 +455,9 @@ func TestLOONG64Encoder(t *testing.T) {
 
 func TestPPC64EndToEnd(t *testing.T) {
 	testEndToEnd(t, "ppc64", "ppc64")
+
+	// The assembler accepts all instructions irrespective of the GOPPC64 value.
+	testEndToEnd(t, "ppc64", "ppc64_p10")
 }
 
 func TestRISCVEndToEnd(t *testing.T) {
diff --git a/src/cmd/asm/internal/asm/testdata/ppc64_p10.s b/src/cmd/asm/internal/asm/testdata/ppc64_p10.s
new file mode 100644
index 0000000000..4573ecba3a
--- /dev/null
+++ b/src/cmd/asm/internal/asm/testdata/ppc64_p10.s
@@ -0,0 +1,266 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// This contains the valid opcode combinations available
+// in cmd/internal/obj/ppc64/asm9.go which exist for
+// POWER10/ISA 3.1.
+
+#include "../../../../../runtime/textflag.h"
+
+TEXT asmtest(SB), DUPOK|NOSPLIT, $0
+	BRD R1, R2                              // 7c220176
+	BRH R1, R2                              // 7c2201b6
+	BRW R1, R2                              // 7c220136
+	CFUGED R1, R2, R3                       // 7c2311b8
+	CNTLZDM R2, R3, R1                      // 7c411876
+	CNTTZDM R2, R3, R1                      // 7c411c76
+	DCFFIXQQ V1, F2                         // fc400fc4
+	DCTFIXQQ F2, V3                         // fc6117c4
+	LXVKQ $0, VS33                          // f03f02d1
+	LXVP 12352(R5), VS6                     // 18c53040
+	LXVPX (R1)(R2), VS4                     // 7c820a9a
+	LXVRBX (R1)(R2), VS4                    // 7c82081a
+	LXVRDX (R1)(R2), VS4                    // 7c8208da
+	LXVRHX (R1)(R2), VS4                    // 7c82085a
+	LXVRWX (R1)(R2), VS4                    // 7c82089a
+	MTVSRBM R1, V1                          // 10300e42
+	MTVSRBMI $5, V1                         // 10220015
+	MTVSRDM R1, V1                          // 10330e42
+	MTVSRHM R1, V1                          // 10310e42
+	MTVSRQM R1, V1                          // 10340e42
+	MTVSRWM R1, V1                          // 10320e42
+	PADDI R3, $1234567890, $1, R4           // 06104996388302d2
+	PADDI R0, $1234567890, $0, R4           // 06004996388002d2
+	PADDI R0, $1234567890, $1, R4           // 06104996388002d2
+	PDEPD R1, R2, R3                        // 7c231138
+	PEXTD R1, R2, R3                        // 7c231178
+	PLBZ 1234(R1), $0, R3                   // 06000000886104d260000000
+	// Note, PLD crosses a 64B boundary, and a nop is inserted between PLBZ and PLD
+	PLD 1234(R1), $0, R3                    // 04000000e46104d2
+	PLFD 1234(R1), $0, F3                   // 06000000c86104d2
+	PLFS 1234567890(R4), $0, F3             // 06004996c06402d2
+	PLFS 1234567890(R0), $1, F3             // 06104996c06002d2
+	PLHA 1234(R1), $0, R3                   // 06000000a86104d2
+	PLHZ 1234(R1), $0, R3                   // 06000000a06104d2
+	PLQ 1234(R1), $0, R4                    // 04000000e08104d2
+	PLWA 1234(R1), $0, R3                   // 04000000a46104d2
+	PLWZ 1234567890(R4), $0, R3             // 06004996806402d2
+	PLWZ 1234567890(R0), $1, R3             // 06104996806002d2
+	PLXSD 1234(R1), $0, V1                  // 04000000a82104d2
+	PLXSSP 5(R1), $0, V2                    // 04000000ac410005
+	PLXSSP 5(R0), $1, V2                    // 04100000ac400005
+	PLXV 12346891(R6), $1, VS44             // 041000bccd86660b
+	PLXVP 12345678(R4), $1, VS4             // 041000bce884614e
+	PMXVBF16GER2 VS1, VS2, $1, $2, $3, A1   // 0790c012ec811198
+	PMXVBF16GER2NN VS1, VS2, $1, $2, $3, A1 // 0790c012ec811790
+	PMXVBF16GER2NP VS1, VS2, $1, $2, $3, A1 // 0790c012ec811390
+	PMXVBF16GER2PN VS1, VS2, $1, $2, $3, A1 // 0790c012ec811590
+	PMXVBF16GER2PP VS1, VS2, $1, $2, $3, A1 // 0790c012ec811190
+	PMXVF16GER2 VS1, VS2, $1, $2, $3, A1    // 0790c012ec811098
+	PMXVF16GER2NN VS1, VS2, $1, $2, $3, A1  // 0790c012ec811690
+	PMXVF16GER2NP VS1, VS2, $1, $2, $3, A1  // 0790c012ec811290
+	PMXVF16GER2PN VS1, VS2, $1, $2, $3, A1  // 0790c012ec811490
+	PMXVF16GER2PP VS1, VS2, $1, $2, $3, A1  // 0790c012ec811090
+	PMXVF32GER VS1, VS2, $1, $2, A1         // 07900012ec8110d8
+	PMXVF32GERNN VS1, VS2, $1, $2, A1       // 07900012ec8116d0
+	PMXVF32GERNP VS1, VS2, $1, $2, A1       // 07900012ec8112d0
+	PMXVF32GERPN VS1, VS2, $1, $2, A1       // 07900012ec8114d0
+	PMXVF32GERPP VS1, VS2, $1, $2, A1       // 07900012ec8110d0
+	PMXVF64GER VS4, VS2, $1, $2, A1         // 07900018ec8411d8
+	PMXVF64GERNN VS4, VS2, $1, $2, A1       // 07900018ec8417d0
+	PMXVF64GERNP VS4, VS2, $1, $2, A1       // 07900018ec8413d0
+	PMXVF64GERPN VS4, VS2, $1, $2, A1       // 07900018ec8415d0
+	PMXVF64GERPP VS4, VS2, $1, $2, A1       // 07900018ec8411d0
+	PMXVI16GER2 VS1, VS2, $1, $2, $3, A1    // 0790c012ec811258
+	PMXVI16GER2PP VS1, VS2, $1, $2, $3, A1  // 0790c012ec811358
+	PMXVI16GER2S VS1, VS2, $1, $2, $3, A1   // 0790c012ec811158
+	PMXVI16GER2SPP VS1, VS2, $1, $2, $3, A1 // 0790c012ec811150
+	PMXVI4GER8 VS1, VS2, $1, $2, $3, A1     // 07900312ec811118
+	PMXVI4GER8PP VS1, VS2, $1, $2, $3, A1   // 07900312ec811110
+	PMXVI8GER4 VS1, VS2, $1, $2, $3, A1     // 07903012ec811018
+	PMXVI8GER4PP VS1, VS2, $1, $2, $3, A1   // 07903012ec811010
+	PMXVI8GER4SPP VS1, VS2, $1, $2, $3, A1  // 07903012ec811318
+	PNOP                                    // 0700000000000000
+	PSTB R1, $1, 12345678(R2)               // 061000bc9822614e
+	PSTD R1, $1, 12345678(R2)               // 041000bcf422614e
+	PSTFD F1, $1, 12345678(R2)              // 061000bcd822614e
+	PSTFS F1, $1, 123456789(R7)             // 0610075bd027cd15
+	PSTH R1, $1, 12345678(R2)               // 061000bcb022614e
+	PSTQ R2, $1, 12345678(R2)               // 041000bcf042614e
+	PSTW R1, $1, 12345678(R2)               // 061000bc9022614e
+	PSTW R24, $0, 45(R13)                   // 06000000930d002d
+	PSTXSD V1, $1, 12345678(R2)             // 041000bcb822614e
+	PSTXSSP V1, $1, 1234567890(R0)          // 04104996bc2002d2
+	PSTXSSP V1, $1, 1234567890(R1)          // 04104996bc2102d2
+	PSTXSSP V1, $0, 1234567890(R3)          // 04004996bc2302d2
+	PSTXV VS6, $1, 1234567890(R5)           // 04104996d8c502d2
+	PSTXVP VS2, $1, 12345678(R2)            // 041000bcf842614e
+	PSTXVP VS62, $0, 5555555(R3)            // 04000054fbe3c563
+	SETBC CR2EQ, R2                         // 7c4a0300
+	SETBCR CR2LT, R2                        // 7c480340
+	SETNBC CR2GT, R2                        // 7c490380
+	SETNBCR CR6SO, R2                       // 7c5b03c0
+	STXVP VS6, 12352(R5)                    // 18c53041
+	STXVPX VS22, (R1)(R2)                   // 7ec20b9a
+	STXVRBX VS2, (R1)(R2)                   // 7c42091a
+	STXVRDX VS2, (R1)(R2)                   // 7c4209da
+	STXVRHX VS2, (R1)(R2)                   // 7c42095a
+	STXVRWX VS2, (R1)(R2)                   // 7c42099a
+	VCFUGED V1, V2, V3                      // 1061154d
+	VCLRLB V1, R2, V3                       // 1061118d
+	VCLRRB V1, R2, V3                       // 106111cd
+	VCLZDM V1, V2, V3                       // 10611784
+	VCMPEQUQ V1, V2, V3                     // 106111c7
+	VCMPEQUQCC V1, V2, V3                   // 106115c7
+	VCMPGTSQ V1, V2, V3                     // 10611387
+	VCMPGTSQCC V1, V2, V3                   // 10611787
+	VCMPGTUQ V1, V2, V3                     // 10611287
+	VCMPGTUQCC V1, V2, V3                   // 10611687
+	VCMPSQ V1, V2, CR2                      // 11011141
+	VCMPUQ V1, V2, CR3                      // 11811101
+	VCNTMBB V1, $1, R3                      // 10790e42
+	VCNTMBD V1, $1, R3                      // 107f0e42
+	VCNTMBH V1, $1, R3                      // 107b0e42
+	VCNTMBW V1, $1, R3                      // 107d0e42
+	VCTZDM V1, V2, V3                       // 106117c4
+	VDIVESD V1, V2, V3                      // 106113cb
+	VDIVESQ V1, V2, V3                      // 1061130b
+	VDIVESW V1, V2, V3                      // 1061138b
+	VDIVEUD V1, V2, V3                      // 106112cb
+	VDIVEUQ V1, V2, V3                      // 1061120b
+	VDIVEUW V1, V2, V3                      // 1061128b
+	VDIVSD V1, V2, V3                       // 106111cb
+	VDIVSQ V1, V2, V3                       // 1061110b
+	VDIVSW V1, V2, V3                       // 1061118b
+	VDIVUD V1, V2, V3                       // 106110cb
+	VDIVUQ V1, V2, V3                       // 1061100b
+	VDIVUW V1, V2, V3                       // 1061108b
+	VEXPANDBM V1, V2                        // 10400e42
+	VEXPANDDM V1, V2                        // 10430e42
+	VEXPANDHM V1, V2                        // 10410e42
+	VEXPANDQM V1, V2                        // 10440e42
+	VEXPANDWM V1, V2                        // 10420e42
+	VEXTDDVLX V1, V2, R3, V4                // 108110de
+	VEXTDDVRX V1, V2, R3, V4                // 108110df
+	VEXTDUBVLX V1, V2, R3, V4               // 108110d8
+	VEXTDUBVRX V1, V2, R3, V4               // 108110d9
+	VEXTDUHVLX V1, V2, R3, V4               // 108110da
+	VEXTDUHVRX V1, V2, R3, V4               // 108110db
+	VEXTDUWVLX V1, V2, R3, V4               // 108110dc
+	VEXTDUWVRX V1, V2, R5, V3               // 1061115d
+	VEXTRACTBM V1, R2                       // 10480e42
+	VEXTRACTDM V1, R2                       // 104b0e42
+	VEXTRACTHM V1, R2                       // 10490e42
+	VEXTRACTQM V1, R2                       // 104c0e42
+	VEXTRACTWM V1, R6                       // 10ca0e42
+	VEXTSD2Q V1, V2                         // 105b0e02
+	VGNB V1, $1, R31                        // 13e10ccc
+	VINSBLX R1, R2, V3                      // 1061120f
+	VINSBRX R1, R2, V3                      // 1061130f
+	VINSBVLX R1, V1, V2                     // 1041080f
+	VINSBVRX R1, V1, V2                     // 1041090f
+	VINSD R1, $2, V2                        // 104209cf
+	VINSDLX R1, R2, V3                      // 106112cf
+	VINSDRX R1, R2, V3                      // 106113cf
+	VINSHLX R1, R2, V3                      // 1061124f
+	VINSHRX R1, R2, V3                      // 1061134f
+	VINSHVLX R1, V2, V3                     // 1061104f
+	VINSHVRX R1, V2, V3                     // 1061114f
+	VINSW R1, $4, V3                        // 106408cf
+	VINSWLX R1, R2, V3                      // 1061128f
+	VINSWRX R1, R2, V3                      // 1061138f
+	VINSWVLX R1, V2, V3                     // 1061108f
+	VINSWVRX R1, V2, V3                     // 1061118f
+	VMODSD V1, V2, V3                       // 106117cb
+	VMODSQ V1, V2, V3                       // 1061170b
+	VMODSW V1, V2, V3                       // 1061178b
+	VMODUD V1, V2, V3                       // 106116cb
+	VMODUQ V1, V2, V3                       // 1061160b
+	VMODUW V1, V2, V3                       // 1061168b
+	VMSUMCUD V1, V2, V3, V4                 // 108110d7
+	VMULESD V1, V2, V3                      // 106113c8
+	VMULEUD V1, V2, V3                      // 106112c8
+	VMULHSD V1, V2, V3                      // 106113c9
+	VMULHSW V1, V2, V3                      // 10611389
+	VMULHUD V1, V2, V3                      // 106112c9
+	VMULHUW V1, V2, V3                      // 10611289
+	VMULLD V1, V2, V3                       // 106111c9
+	VMULOSD V1, V2, V3                      // 106111c8
+	VMULOUD V1, V2, V3                      // 106110c8
+	VPDEPD V1, V2, V3                       // 106115cd
+	VPEXTD V1, V2, V3                       // 1061158d
+	VRLQ V1, V2, V3                         // 10611005
+	VRLQMI V1, V2, V3                       // 10611045
+	VRLQNM V1, V2, V3                       // 10611145
+	VSLDBI V1, V2, $3, V3                   // 106110d6
+	VSLQ V1, V2, V3                         // 10611105
+	VSRAQ V1, V2, V3                        // 10611305
+	VSRDBI V1, V2, $3, V4                   // 108112d6
+	VSRQ V1, V2, V3                         // 10611205
+	VSTRIBL V1, V2                          // 1040080d
+	VSTRIBLCC V1, V2                        // 10400c0d
+	VSTRIBR V1, V2                          // 1041080d
+	VSTRIBRCC V1, V2                        // 10410c0d
+	VSTRIHL V1, V2                          // 1042080d
+	VSTRIHLCC V1, V2                        // 10420c0d
+	VSTRIHR V1, V2                          // 1043080d
+	VSTRIHRCC V1, V2                        // 10430c0d
+	XSCMPEQQP V1, V2, V3                    // fc611088
+	XSCMPGEQP V1, V2, V3                    // fc611188
+	XSCMPGTQP V1, V2, V3                    // fc6111c8
+	XSCVQPSQZ V1, V2                        // fc480e88
+	XSCVQPUQZ V1, V2                        // fc400e88
+	XSCVSQQP V1, V2                         // fc4b0e88
+	XSCVUQQP V2, V3                         // fc631688
+	XSMAXCQP V1, V2, V3                     // fc611548
+	XSMINCQP V1, V2, V4                     // fc8115c8
+	XVBF16GER2 VS1, VS2, A1                 // ec811198
+	XVBF16GER2NN VS1, VS2, A1               // ec811790
+	XVBF16GER2NP VS1, VS2, A1               // ec811390
+	XVBF16GER2PN VS1, VS2, A1               // ec811590
+	XVBF16GER2PP VS1, VS2, A1               // ec811190
+	XVCVBF16SPN VS2, VS3                    // f070176c
+	XVCVSPBF16 VS1, VS4                     // f0910f6c
+	XVF16GER2 VS1, VS2, A1                  // ec811098
+	XVF16GER2NN VS1, VS2, A1                // ec811690
+	XVF16GER2NP VS1, VS2, A1                // ec811290
+	XVF16GER2PN VS1, VS2, A1                // ec811490
+	XVF16GER2PP VS1, VS2, A1                // ec811090
+	XVF32GER VS1, VS2, A1                   // ec8110d8
+	XVF32GERNN VS1, VS2, A1                 // ec8116d0
+	XVF32GERNP VS1, VS2, A1                 // ec8112d0
+	XVF32GERPN VS1, VS2, A1                 // ec8114d0
+	XVF32GERPP VS1, VS2, A1                 // ec8110d0
+	XVF64GER VS2, VS1, A1                   // ec8209d8
+	XVF64GERNN VS2, VS1, A1                 // ec820fd0
+	XVF64GERNP VS2, VS1, A1                 // ec820bd0
+	XVF64GERPN VS2, VS1, A1                 // ec820dd0
+	XVF64GERPP VS2, VS1, A1                 // ec8209d0
+	XVI16GER2 VS1, VS2, A1                  // ec811258
+	XVI16GER2PP VS1, VS2, A1                // ec811358
+	XVI16GER2S VS1, VS2, A1                 // ec811158
+	XVI16GER2SPP VS1, VS2, A1               // ec811150
+	XVI4GER8 VS1, VS2, A1                   // ec811118
+	XVI4GER8PP VS1, VS2, A1                 // ec811110
+	XVI8GER4 VS1, VS2, A1                   // ec811018
+	XVI8GER4PP VS1, VS2, A1                 // ec811010
+	XVI8GER4SPP VS4, VS6, A1                // ec843318
+	XVTLSBB VS1, CR2                        // f1020f6c
+	XXBLENDVB VS1, VS3, VS7, VS11           // 05000000856119c0
+	XXBLENDVD VS1, VS3, VS7, VS11           // 05000000856119f0
+	XXBLENDVH VS1, VS3, VS7, VS11           // 05000000856119d0
+	XXBLENDVW VS1, VS3, VS7, VS11           // 05000000856119e0
+	XXEVAL VS1, VS2, VS3, $2, VS4           // 05000002888110d0
+	XXGENPCVBM V2, $2, VS3                  // f0621728
+	XXGENPCVDM V2, $2, VS3                  // f062176a
+	XXGENPCVHM V2, $2, VS3                  // f062172a
+	XXGENPCVWM V2, $2, VS3                  // f0621768
+	XXMFACC A1                              // 7c800162
+	XXMTACC A1                              // 7c810162
+	XXPERMX VS1, VS34, VS2, $2, VS3         // 0500000288611082
+	XXSETACCZ A1                            // 7c830162
+	XXSPLTI32DX $1, $1234, VS3              // 05000000806204d2
+	XXSPLTIDP $12345678, VS4                // 050000bc8084614e
+	XXSPLTIW $123456, VS3                   // 050000018066e240
+        RET
diff --git a/src/cmd/internal/obj/ppc64/a.out.go b/src/cmd/internal/obj/ppc64/a.out.go
index 38cab4ac75..9e9b395a87 100644
--- a/src/cmd/internal/obj/ppc64/a.out.go
+++ b/src/cmd/internal/obj/ppc64/a.out.go
@@ -1091,13 +1091,10 @@ const (
 	AXVCVSXWSP
 	AXVCVUXDSP
 	AXVCVUXWSP
-
-	/* ISA 3.1 opcodes */
-	APNOP
-
-	ALAST
+	ALASTAOUT // The last instruction in this list. Also the first opcode generated by ppc64map.
 
 	// aliases
-	ABR = obj.AJMP
-	ABL = obj.ACALL
+	ABR   = obj.AJMP
+	ABL   = obj.ACALL
+	ALAST = ALASTGEN // The final enumerated instruction value + 1. This is used to size the oprange table.
 )
diff --git a/src/cmd/internal/obj/ppc64/anames.go b/src/cmd/internal/obj/ppc64/anames.go
index 7521a92ab4..f417ff2855 100644
--- a/src/cmd/internal/obj/ppc64/anames.go
+++ b/src/cmd/internal/obj/ppc64/anames.go
@@ -615,6 +615,5 @@ var Anames = []string{
 	"XVCVSXWSP",
 	"XVCVUXDSP",
 	"XVCVUXWSP",
-	"PNOP",
-	"LAST",
+	"LASTAOUT",
 }
diff --git a/src/cmd/internal/obj/ppc64/asm9.go b/src/cmd/internal/obj/ppc64/asm9.go
index ffc73d7b06..dace5b1279 100644
--- a/src/cmd/internal/obj/ppc64/asm9.go
+++ b/src/cmd/internal/obj/ppc64/asm9.go
@@ -74,6 +74,8 @@ type Optab struct {
 	// prefixed instruction. The prefixed instruction should be written first
 	// (e.g when Optab.size > 8).
 	ispfx bool
+
+	asmout func(*ctxt9, *obj.Prog, *Optab, *[5]uint32)
 }
 
 // optab contains an array to be sliced of accepted operand combinations for an
@@ -524,8 +526,6 @@ var optab = []Optab{
 	{as: ALSW, a1: C_XOREG, a6: C_REG, type_: 45, size: 4},
 	{as: ALSW, a1: C_ZOREG, a3: C_LCON, a6: C_REG, type_: 42, size: 4},
 
-	{as: APNOP, type_: 105, size: 8, ispfx: true},
-
 	{as: obj.AUNDEF, type_: 78, size: 4},
 	{as: obj.APCDATA, a1: C_LCON, a6: C_LCON, type_: 0, size: 0},
 	{as: obj.AFUNCDATA, a1: C_SCON, a6: C_ADDR, type_: 0, size: 0},
@@ -536,8 +536,6 @@ var optab = []Optab{
 	{as: obj.ADUFFZERO, a6: C_LBRA, type_: 11, size: 4}, // same as ABR/ABL
 	{as: obj.ADUFFCOPY, a6: C_LBRA, type_: 11, size: 4}, // same as ABR/ABL
 	{as: obj.APCALIGN, a1: C_LCON, type_: 0, size: 0},   // align code
-
-	{as: obj.AXXX, type_: 0, size: 4},
 }
 
 var oprange [ALAST & obj.AMask][]Optab
@@ -660,7 +658,7 @@ func span9(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
 
 	var otxt int64
 	var q *obj.Prog
-	var out [6]uint32
+	var out [5]uint32
 	var falign int32 // Track increased alignment requirements for prefix.
 	for bflag != 0 {
 		bflag = 0
@@ -679,7 +677,7 @@ func span9(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
 					// and only one extra branch is needed to reach the target.
 					tgt := p.To.Target()
 					p.To.SetTarget(p.Link)
-					c.asmout(p, o, out[:])
+					o.asmout(&c, p, o, &out)
 					p.To.SetTarget(tgt)
 
 					bo := int64(out[0]>>21) & 31
@@ -832,7 +830,7 @@ func span9(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
 				c.ctxt.Arch.ByteOrder.PutUint32(bp, nop)
 				bp = bp[4:]
 			}
-			c.asmout(p, o, out[:])
+			o.asmout(&c, p, o, &out)
 			for i = 0; i < int32(o.size/4); i++ {
 				c.ctxt.Arch.ByteOrder.PutUint32(bp, out[i])
 				bp = bp[4:]
@@ -1206,22 +1204,12 @@ func cmp(a int, b int) bool {
 	return false
 }
 
-type ocmp []Optab
-
-func (x ocmp) Len() int {
-	return len(x)
-}
-
-func (x ocmp) Swap(i, j int) {
-	x[i], x[j] = x[j], x[i]
-}
-
 // Used when sorting the optab. Sorting is
 // done in a way so that the best choice of
 // opcode/operand combination is considered first.
-func (x ocmp) Less(i, j int) bool {
-	p1 := &x[i]
-	p2 := &x[j]
+func optabLess(i, j int) bool {
+	p1 := &optab[i]
+	p2 := &optab[j]
 	n := int(p1.as) - int(p2.as)
 	// same opcode
 	if n != 0 {
@@ -1278,32 +1266,37 @@ func buildop(ctxt *obj.Link) {
 		return
 	}
 
-	var n int
-
 	for i := 0; i < C_NCLASS; i++ {
-		for n = 0; n < C_NCLASS; n++ {
+		for n := 0; n < C_NCLASS; n++ {
 			if cmp(n, i) {
 				xcmp[i][n] = true
 			}
 		}
 	}
-	for n = 0; optab[n].as != obj.AXXX; n++ {
+	for i := range optab {
+		// Use the legacy assembler function if none provided.
+		if optab[i].asmout == nil {
+			optab[i].asmout = asmout
+		}
 	}
-	sort.Sort(ocmp(optab[:n]))
-	for i := 0; i < n; i++ {
+	// Append the generated entries, sort, and fill out oprange.
+	optab = append(optab, optabGen...)
+	sort.Slice(optab, optabLess)
+	for i := 0; i < len(optab); {
 		r := optab[i].as
 		r0 := r & obj.AMask
 		start := i
-		for optab[i].as == r {
+		for i < len(optab) && optab[i].as == r {
 			i++
 		}
 		oprange[r0] = optab[start:i]
-		i--
 
 		switch r {
 		default:
-			ctxt.Diag("unknown op in build: %v", r)
-			log.Fatalf("instruction missing from switch in asm9.go:buildop: %v", r)
+			if !opsetGen(r) {
+				ctxt.Diag("unknown op in build: %v", r)
+				log.Fatalf("instruction missing from switch in asm9.go:buildop: %v", r)
+			}
 
 		case ADCBF: /* unary indexed: op (b+a); op (b) */
 			opset(ADCBI, r0)
@@ -2480,7 +2473,7 @@ func high16adjusted(d int32) uint16 {
 	return uint16(d >> 16)
 }
 
-func (c *ctxt9) asmout(p *obj.Prog, o *Optab, out []uint32) {
+func asmout(c *ctxt9, p *obj.Prog, o *Optab, out *[5]uint32) {
 	o1 := uint32(0)
 	o2 := uint32(0)
 	o3 := uint32(0)
@@ -3768,10 +3761,6 @@ func (c *ctxt9) asmout(p *obj.Prog, o *Optab, out []uint32) {
 	case 104: /* VSX mtvsr* instructions, XX1-form RA,RB,XT */
 		o1 = AOP_XX1(c.oprrr(p.As), uint32(p.To.Reg), uint32(p.From.Reg), uint32(p.Reg))
 
-	case 105: /* PNOP */
-		o1 = 0x07000000
-		o2 = 0x00000000
-
 	case 106: /* MOVD spr, soreg */
 		v := int32(p.From.Reg)
 		o1 = OPVCC(31, 339, 0, 0) /* mfspr */
diff --git a/src/cmd/internal/obj/ppc64/asm9_gtables.go b/src/cmd/internal/obj/ppc64/asm9_gtables.go
new file mode 100644
index 0000000000..938fbaa313
--- /dev/null
+++ b/src/cmd/internal/obj/ppc64/asm9_gtables.go
@@ -0,0 +1,1616 @@
+// DO NOT EDIT
+// generated by: ppc64map -fmt=encoder pp64.csv
+
+package ppc64
+
+import (
+	"cmd/internal/obj"
+)
+
+const (
+	AXXSETACCZ = ALASTAOUT + iota
+	AXXMTACC
+	AXXMFACC
+	AXXGENPCVWM
+	AXXGENPCVHM
+	AXXGENPCVDM
+	AXXGENPCVBM
+	AXVTLSBB
+	AXVI8GER4SPP
+	AXVI8GER4PP
+	AXVI8GER4
+	AXVI4GER8PP
+	AXVI4GER8
+	AXVI16GER2SPP
+	AXVI16GER2S
+	AXVI16GER2PP
+	AXVI16GER2
+	AXVF64GERPP
+	AXVF64GERPN
+	AXVF64GERNP
+	AXVF64GERNN
+	AXVF64GER
+	AXVF32GERPP
+	AXVF32GERPN
+	AXVF32GERNP
+	AXVF32GERNN
+	AXVF32GER
+	AXVF16GER2PP
+	AXVF16GER2PN
+	AXVF16GER2NP
+	AXVF16GER2NN
+	AXVF16GER2
+	AXVCVSPBF16
+	AXVCVBF16SPN
+	AXVBF16GER2PP
+	AXVBF16GER2PN
+	AXVBF16GER2NP
+	AXVBF16GER2NN
+	AXVBF16GER2
+	AXSMINCQP
+	AXSMAXCQP
+	AXSCVUQQP
+	AXSCVSQQP
+	AXSCVQPUQZ
+	AXSCVQPSQZ
+	AXSCMPGTQP
+	AXSCMPGEQP
+	AXSCMPEQQP
+	AVSTRIHRCC
+	AVSTRIHR
+	AVSTRIHLCC
+	AVSTRIHL
+	AVSTRIBRCC
+	AVSTRIBR
+	AVSTRIBLCC
+	AVSTRIBL
+	AVSRQ
+	AVSRDBI
+	AVSRAQ
+	AVSLQ
+	AVSLDBI
+	AVRLQNM
+	AVRLQMI
+	AVRLQ
+	AVPEXTD
+	AVPDEPD
+	AVMULOUD
+	AVMULOSD
+	AVMULLD
+	AVMULHUW
+	AVMULHUD
+	AVMULHSW
+	AVMULHSD
+	AVMULEUD
+	AVMULESD
+	AVMSUMCUD
+	AVMODUW
+	AVMODUQ
+	AVMODUD
+	AVMODSW
+	AVMODSQ
+	AVMODSD
+	AVINSWVRX
+	AVINSWVLX
+	AVINSWRX
+	AVINSWLX
+	AVINSW
+	AVINSHVRX
+	AVINSHVLX
+	AVINSHRX
+	AVINSHLX
+	AVINSDRX
+	AVINSDLX
+	AVINSD
+	AVINSBVRX
+	AVINSBVLX
+	AVINSBRX
+	AVINSBLX
+	AVGNB
+	AVEXTSD2Q
+	AVEXTRACTWM
+	AVEXTRACTQM
+	AVEXTRACTHM
+	AVEXTRACTDM
+	AVEXTRACTBM
+	AVEXTDUWVRX
+	AVEXTDUWVLX
+	AVEXTDUHVRX
+	AVEXTDUHVLX
+	AVEXTDUBVRX
+	AVEXTDUBVLX
+	AVEXTDDVRX
+	AVEXTDDVLX
+	AVEXPANDWM
+	AVEXPANDQM
+	AVEXPANDHM
+	AVEXPANDDM
+	AVEXPANDBM
+	AVDIVUW
+	AVDIVUQ
+	AVDIVUD
+	AVDIVSW
+	AVDIVSQ
+	AVDIVSD
+	AVDIVEUW
+	AVDIVEUQ
+	AVDIVEUD
+	AVDIVESW
+	AVDIVESQ
+	AVDIVESD
+	AVCTZDM
+	AVCNTMBW
+	AVCNTMBH
+	AVCNTMBD
+	AVCNTMBB
+	AVCMPUQ
+	AVCMPSQ
+	AVCMPGTUQCC
+	AVCMPGTUQ
+	AVCMPGTSQCC
+	AVCMPGTSQ
+	AVCMPEQUQCC
+	AVCMPEQUQ
+	AVCLZDM
+	AVCLRRB
+	AVCLRLB
+	AVCFUGED
+	ASTXVRWX
+	ASTXVRHX
+	ASTXVRDX
+	ASTXVRBX
+	ASTXVPX
+	ASTXVP
+	ASETNBCR
+	ASETNBC
+	ASETBCR
+	ASETBC
+	APEXTD
+	APDEPD
+	AMTVSRWM
+	AMTVSRQM
+	AMTVSRHM
+	AMTVSRDM
+	AMTVSRBMI
+	AMTVSRBM
+	ALXVRWX
+	ALXVRHX
+	ALXVRDX
+	ALXVRBX
+	ALXVPX
+	ALXVP
+	ALXVKQ
+	ADCTFIXQQ
+	ADCFFIXQQ
+	ACNTTZDM
+	ACNTLZDM
+	ACFUGED
+	ABRW
+	ABRH
+	ABRD
+	AXXSPLTIW
+	AXXSPLTIDP
+	AXXSPLTI32DX
+	AXXPERMX
+	AXXEVAL
+	AXXBLENDVW
+	AXXBLENDVH
+	AXXBLENDVD
+	AXXBLENDVB
+	APSTXVP
+	APSTXV
+	APSTXSSP
+	APSTXSD
+	APSTW
+	APSTQ
+	APSTH
+	APSTFS
+	APSTFD
+	APSTD
+	APSTB
+	APNOP
+	APMXVI8GER4SPP
+	APMXVI8GER4PP
+	APMXVI8GER4
+	APMXVI4GER8PP
+	APMXVI4GER8
+	APMXVI16GER2SPP
+	APMXVI16GER2S
+	APMXVI16GER2PP
+	APMXVI16GER2
+	APMXVF64GERPP
+	APMXVF64GERPN
+	APMXVF64GERNP
+	APMXVF64GERNN
+	APMXVF64GER
+	APMXVF32GERPP
+	APMXVF32GERPN
+	APMXVF32GERNP
+	APMXVF32GERNN
+	APMXVF32GER
+	APMXVF16GER2PP
+	APMXVF16GER2PN
+	APMXVF16GER2NP
+	APMXVF16GER2NN
+	APMXVF16GER2
+	APMXVBF16GER2PP
+	APMXVBF16GER2PN
+	APMXVBF16GER2NP
+	APMXVBF16GER2NN
+	APMXVBF16GER2
+	APLXVP
+	APLXV
+	APLXSSP
+	APLXSD
+	APLWZ
+	APLWA
+	APLQ
+	APLHZ
+	APLHA
+	APLFS
+	APLFD
+	APLD
+	APLBZ
+	APADDI
+	ALASTGEN
+	AFIRSTGEN = AXXSETACCZ
+)
+
+var GenAnames = []string{
+	"XXSETACCZ",
+	"XXMTACC",
+	"XXMFACC",
+	"XXGENPCVWM",
+	"XXGENPCVHM",
+	"XXGENPCVDM",
+	"XXGENPCVBM",
+	"XVTLSBB",
+	"XVI8GER4SPP",
+	"XVI8GER4PP",
+	"XVI8GER4",
+	"XVI4GER8PP",
+	"XVI4GER8",
+	"XVI16GER2SPP",
+	"XVI16GER2S",
+	"XVI16GER2PP",
+	"XVI16GER2",
+	"XVF64GERPP",
+	"XVF64GERPN",
+	"XVF64GERNP",
+	"XVF64GERNN",
+	"XVF64GER",
+	"XVF32GERPP",
+	"XVF32GERPN",
+	"XVF32GERNP",
+	"XVF32GERNN",
+	"XVF32GER",
+	"XVF16GER2PP",
+	"XVF16GER2PN",
+	"XVF16GER2NP",
+	"XVF16GER2NN",
+	"XVF16GER2",
+	"XVCVSPBF16",
+	"XVCVBF16SPN",
+	"XVBF16GER2PP",
+	"XVBF16GER2PN",
+	"XVBF16GER2NP",
+	"XVBF16GER2NN",
+	"XVBF16GER2",
+	"XSMINCQP",
+	"XSMAXCQP",
+	"XSCVUQQP",
+	"XSCVSQQP",
+	"XSCVQPUQZ",
+	"XSCVQPSQZ",
+	"XSCMPGTQP",
+	"XSCMPGEQP",
+	"XSCMPEQQP",
+	"VSTRIHRCC",
+	"VSTRIHR",
+	"VSTRIHLCC",
+	"VSTRIHL",
+	"VSTRIBRCC",
+	"VSTRIBR",
+	"VSTRIBLCC",
+	"VSTRIBL",
+	"VSRQ",
+	"VSRDBI",
+	"VSRAQ",
+	"VSLQ",
+	"VSLDBI",
+	"VRLQNM",
+	"VRLQMI",
+	"VRLQ",
+	"VPEXTD",
+	"VPDEPD",
+	"VMULOUD",
+	"VMULOSD",
+	"VMULLD",
+	"VMULHUW",
+	"VMULHUD",
+	"VMULHSW",
+	"VMULHSD",
+	"VMULEUD",
+	"VMULESD",
+	"VMSUMCUD",
+	"VMODUW",
+	"VMODUQ",
+	"VMODUD",
+	"VMODSW",
+	"VMODSQ",
+	"VMODSD",
+	"VINSWVRX",
+	"VINSWVLX",
+	"VINSWRX",
+	"VINSWLX",
+	"VINSW",
+	"VINSHVRX",
+	"VINSHVLX",
+	"VINSHRX",
+	"VINSHLX",
+	"VINSDRX",
+	"VINSDLX",
+	"VINSD",
+	"VINSBVRX",
+	"VINSBVLX",
+	"VINSBRX",
+	"VINSBLX",
+	"VGNB",
+	"VEXTSD2Q",
+	"VEXTRACTWM",
+	"VEXTRACTQM",
+	"VEXTRACTHM",
+	"VEXTRACTDM",
+	"VEXTRACTBM",
+	"VEXTDUWVRX",
+	"VEXTDUWVLX",
+	"VEXTDUHVRX",
+	"VEXTDUHVLX",
+	"VEXTDUBVRX",
+	"VEXTDUBVLX",
+	"VEXTDDVRX",
+	"VEXTDDVLX",
+	"VEXPANDWM",
+	"VEXPANDQM",
+	"VEXPANDHM",
+	"VEXPANDDM",
+	"VEXPANDBM",
+	"VDIVUW",
+	"VDIVUQ",
+	"VDIVUD",
+	"VDIVSW",
+	"VDIVSQ",
+	"VDIVSD",
+	"VDIVEUW",
+	"VDIVEUQ",
+	"VDIVEUD",
+	"VDIVESW",
+	"VDIVESQ",
+	"VDIVESD",
+	"VCTZDM",
+	"VCNTMBW",
+	"VCNTMBH",
+	"VCNTMBD",
+	"VCNTMBB",
+	"VCMPUQ",
+	"VCMPSQ",
+	"VCMPGTUQCC",
+	"VCMPGTUQ",
+	"VCMPGTSQCC",
+	"VCMPGTSQ",
+	"VCMPEQUQCC",
+	"VCMPEQUQ",
+	"VCLZDM",
+	"VCLRRB",
+	"VCLRLB",
+	"VCFUGED",
+	"STXVRWX",
+	"STXVRHX",
+	"STXVRDX",
+	"STXVRBX",
+	"STXVPX",
+	"STXVP",
+	"SETNBCR",
+	"SETNBC",
+	"SETBCR",
+	"SETBC",
+	"PEXTD",
+	"PDEPD",
+	"MTVSRWM",
+	"MTVSRQM",
+	"MTVSRHM",
+	"MTVSRDM",
+	"MTVSRBMI",
+	"MTVSRBM",
+	"LXVRWX",
+	"LXVRHX",
+	"LXVRDX",
+	"LXVRBX",
+	"LXVPX",
+	"LXVP",
+	"LXVKQ",
+	"DCTFIXQQ",
+	"DCFFIXQQ",
+	"CNTTZDM",
+	"CNTLZDM",
+	"CFUGED",
+	"BRW",
+	"BRH",
+	"BRD",
+	"XXSPLTIW",
+	"XXSPLTIDP",
+	"XXSPLTI32DX",
+	"XXPERMX",
+	"XXEVAL",
+	"XXBLENDVW",
+	"XXBLENDVH",
+	"XXBLENDVD",
+	"XXBLENDVB",
+	"PSTXVP",
+	"PSTXV",
+	"PSTXSSP",
+	"PSTXSD",
+	"PSTW",
+	"PSTQ",
+	"PSTH",
+	"PSTFS",
+	"PSTFD",
+	"PSTD",
+	"PSTB",
+	"PNOP",
+	"PMXVI8GER4SPP",
+	"PMXVI8GER4PP",
+	"PMXVI8GER4",
+	"PMXVI4GER8PP",
+	"PMXVI4GER8",
+	"PMXVI16GER2SPP",
+	"PMXVI16GER2S",
+	"PMXVI16GER2PP",
+	"PMXVI16GER2",
+	"PMXVF64GERPP",
+	"PMXVF64GERPN",
+	"PMXVF64GERNP",
+	"PMXVF64GERNN",
+	"PMXVF64GER",
+	"PMXVF32GERPP",
+	"PMXVF32GERPN",
+	"PMXVF32GERNP",
+	"PMXVF32GERNN",
+	"PMXVF32GER",
+	"PMXVF16GER2PP",
+	"PMXVF16GER2PN",
+	"PMXVF16GER2NP",
+	"PMXVF16GER2NN",
+	"PMXVF16GER2",
+	"PMXVBF16GER2PP",
+	"PMXVBF16GER2PN",
+	"PMXVBF16GER2NP",
+	"PMXVBF16GER2NN",
+	"PMXVBF16GER2",
+	"PLXVP",
+	"PLXV",
+	"PLXSSP",
+	"PLXSD",
+	"PLWZ",
+	"PLWA",
+	"PLQ",
+	"PLHZ",
+	"PLHA",
+	"PLFS",
+	"PLFD",
+	"PLD",
+	"PLBZ",
+	"PADDI",
+}
+
+var GenOpcodes = [...]uint32{
+	0x7c030162, // AXXSETACCZ
+	0x7c010162, // AXXMTACC
+	0x7c000162, // AXXMFACC
+	0xf0000768, // AXXGENPCVWM
+	0xf000072a, // AXXGENPCVHM
+	0xf000076a, // AXXGENPCVDM
+	0xf0000728, // AXXGENPCVBM
+	0xf002076c, // AXVTLSBB
+	0xec000318, // AXVI8GER4SPP
+	0xec000010, // AXVI8GER4PP
+	0xec000018, // AXVI8GER4
+	0xec000110, // AXVI4GER8PP
+	0xec000118, // AXVI4GER8
+	0xec000150, // AXVI16GER2SPP
+	0xec000158, // AXVI16GER2S
+	0xec000358, // AXVI16GER2PP
+	0xec000258, // AXVI16GER2
+	0xec0001d0, // AXVF64GERPP
+	0xec0005d0, // AXVF64GERPN
+	0xec0003d0, // AXVF64GERNP
+	0xec0007d0, // AXVF64GERNN
+	0xec0001d8, // AXVF64GER
+	0xec0000d0, // AXVF32GERPP
+	0xec0004d0, // AXVF32GERPN
+	0xec0002d0, // AXVF32GERNP
+	0xec0006d0, // AXVF32GERNN
+	0xec0000d8, // AXVF32GER
+	0xec000090, // AXVF16GER2PP
+	0xec000490, // AXVF16GER2PN
+	0xec000290, // AXVF16GER2NP
+	0xec000690, // AXVF16GER2NN
+	0xec000098, // AXVF16GER2
+	0xf011076c, // AXVCVSPBF16
+	0xf010076c, // AXVCVBF16SPN
+	0xec000190, // AXVBF16GER2PP
+	0xec000590, // AXVBF16GER2PN
+	0xec000390, // AXVBF16GER2NP
+	0xec000790, // AXVBF16GER2NN
+	0xec000198, // AXVBF16GER2
+	0xfc0005c8, // AXSMINCQP
+	0xfc000548, // AXSMAXCQP
+	0xfc030688, // AXSCVUQQP
+	0xfc0b0688, // AXSCVSQQP
+	0xfc000688, // AXSCVQPUQZ
+	0xfc080688, // AXSCVQPSQZ
+	0xfc0001c8, // AXSCMPGTQP
+	0xfc000188, // AXSCMPGEQP
+	0xfc000088, // AXSCMPEQQP
+	0x1003040d, // AVSTRIHRCC
+	0x1003000d, // AVSTRIHR
+	0x1002040d, // AVSTRIHLCC
+	0x1002000d, // AVSTRIHL
+	0x1001040d, // AVSTRIBRCC
+	0x1001000d, // AVSTRIBR
+	0x1000040d, // AVSTRIBLCC
+	0x1000000d, // AVSTRIBL
+	0x10000205, // AVSRQ
+	0x10000216, // AVSRDBI
+	0x10000305, // AVSRAQ
+	0x10000105, // AVSLQ
+	0x10000016, // AVSLDBI
+	0x10000145, // AVRLQNM
+	0x10000045, // AVRLQMI
+	0x10000005, // AVRLQ
+	0x1000058d, // AVPEXTD
+	0x100005cd, // AVPDEPD
+	0x100000c8, // AVMULOUD
+	0x100001c8, // AVMULOSD
+	0x100001c9, // AVMULLD
+	0x10000289, // AVMULHUW
+	0x100002c9, // AVMULHUD
+	0x10000389, // AVMULHSW
+	0x100003c9, // AVMULHSD
+	0x100002c8, // AVMULEUD
+	0x100003c8, // AVMULESD
+	0x10000017, // AVMSUMCUD
+	0x1000068b, // AVMODUW
+	0x1000060b, // AVMODUQ
+	0x100006cb, // AVMODUD
+	0x1000078b, // AVMODSW
+	0x1000070b, // AVMODSQ
+	0x100007cb, // AVMODSD
+	0x1000018f, // AVINSWVRX
+	0x1000008f, // AVINSWVLX
+	0x1000038f, // AVINSWRX
+	0x1000028f, // AVINSWLX
+	0x100000cf, // AVINSW
+	0x1000014f, // AVINSHVRX
+	0x1000004f, // AVINSHVLX
+	0x1000034f, // AVINSHRX
+	0x1000024f, // AVINSHLX
+	0x100003cf, // AVINSDRX
+	0x100002cf, // AVINSDLX
+	0x100001cf, // AVINSD
+	0x1000010f, // AVINSBVRX
+	0x1000000f, // AVINSBVLX
+	0x1000030f, // AVINSBRX
+	0x1000020f, // AVINSBLX
+	0x100004cc, // AVGNB
+	0x101b0602, // AVEXTSD2Q
+	0x100a0642, // AVEXTRACTWM
+	0x100c0642, // AVEXTRACTQM
+	0x10090642, // AVEXTRACTHM
+	0x100b0642, // AVEXTRACTDM
+	0x10080642, // AVEXTRACTBM
+	0x1000001d, // AVEXTDUWVRX
+	0x1000001c, // AVEXTDUWVLX
+	0x1000001b, // AVEXTDUHVRX
+	0x1000001a, // AVEXTDUHVLX
+	0x10000019, // AVEXTDUBVRX
+	0x10000018, // AVEXTDUBVLX
+	0x1000001f, // AVEXTDDVRX
+	0x1000001e, // AVEXTDDVLX
+	0x10020642, // AVEXPANDWM
+	0x10040642, // AVEXPANDQM
+	0x10010642, // AVEXPANDHM
+	0x10030642, // AVEXPANDDM
+	0x10000642, // AVEXPANDBM
+	0x1000008b, // AVDIVUW
+	0x1000000b, // AVDIVUQ
+	0x100000cb, // AVDIVUD
+	0x1000018b, // AVDIVSW
+	0x1000010b, // AVDIVSQ
+	0x100001cb, // AVDIVSD
+	0x1000028b, // AVDIVEUW
+	0x1000020b, // AVDIVEUQ
+	0x100002cb, // AVDIVEUD
+	0x1000038b, // AVDIVESW
+	0x1000030b, // AVDIVESQ
+	0x100003cb, // AVDIVESD
+	0x100007c4, // AVCTZDM
+	0x101c0642, // AVCNTMBW
+	0x101a0642, // AVCNTMBH
+	0x101e0642, // AVCNTMBD
+	0x10180642, // AVCNTMBB
+	0x10000101, // AVCMPUQ
+	0x10000141, // AVCMPSQ
+	0x10000687, // AVCMPGTUQCC
+	0x10000287, // AVCMPGTUQ
+	0x10000787, // AVCMPGTSQCC
+	0x10000387, // AVCMPGTSQ
+	0x100005c7, // AVCMPEQUQCC
+	0x100001c7, // AVCMPEQUQ
+	0x10000784, // AVCLZDM
+	0x100001cd, // AVCLRRB
+	0x1000018d, // AVCLRLB
+	0x1000054d, // AVCFUGED
+	0x7c00019a, // ASTXVRWX
+	0x7c00015a, // ASTXVRHX
+	0x7c0001da, // ASTXVRDX
+	0x7c00011a, // ASTXVRBX
+	0x7c00039a, // ASTXVPX
+	0x18000001, // ASTXVP
+	0x7c0003c0, // ASETNBCR
+	0x7c000380, // ASETNBC
+	0x7c000340, // ASETBCR
+	0x7c000300, // ASETBC
+	0x7c000178, // APEXTD
+	0x7c000138, // APDEPD
+	0x10120642, // AMTVSRWM
+	0x10140642, // AMTVSRQM
+	0x10110642, // AMTVSRHM
+	0x10130642, // AMTVSRDM
+	0x10000014, // AMTVSRBMI
+	0x10100642, // AMTVSRBM
+	0x7c00009a, // ALXVRWX
+	0x7c00005a, // ALXVRHX
+	0x7c0000da, // ALXVRDX
+	0x7c00001a, // ALXVRBX
+	0x7c00029a, // ALXVPX
+	0x18000000, // ALXVP
+	0xf01f02d0, // ALXVKQ
+	0xfc0107c4, // ADCTFIXQQ
+	0xfc0007c4, // ADCFFIXQQ
+	0x7c000476, // ACNTTZDM
+	0x7c000076, // ACNTLZDM
+	0x7c0001b8, // ACFUGED
+	0x7c000136, // ABRW
+	0x7c0001b6, // ABRH
+	0x7c000176, // ABRD
+	0x80060000, // AXXSPLTIW
+	0x80040000, // AXXSPLTIDP
+	0x80000000, // AXXSPLTI32DX
+	0x88000000, // AXXPERMX
+	0x88000010, // AXXEVAL
+	0x84000020, // AXXBLENDVW
+	0x84000010, // AXXBLENDVH
+	0x84000030, // AXXBLENDVD
+	0x84000000, // AXXBLENDVB
+	0xf8000000, // APSTXVP
+	0xd8000000, // APSTXV
+	0xbc000000, // APSTXSSP
+	0xb8000000, // APSTXSD
+	0x90000000, // APSTW
+	0xf0000000, // APSTQ
+	0xb0000000, // APSTH
+	0xd0000000, // APSTFS
+	0xd8000000, // APSTFD
+	0xf4000000, // APSTD
+	0x98000000, // APSTB
+	0x00000000, // APNOP
+	0xec000318, // APMXVI8GER4SPP
+	0xec000010, // APMXVI8GER4PP
+	0xec000018, // APMXVI8GER4
+	0xec000110, // APMXVI4GER8PP
+	0xec000118, // APMXVI4GER8
+	0xec000150, // APMXVI16GER2SPP
+	0xec000158, // APMXVI16GER2S
+	0xec000358, // APMXVI16GER2PP
+	0xec000258, // APMXVI16GER2
+	0xec0001d0, // APMXVF64GERPP
+	0xec0005d0, // APMXVF64GERPN
+	0xec0003d0, // APMXVF64GERNP
+	0xec0007d0, // APMXVF64GERNN
+	0xec0001d8, // APMXVF64GER
+	0xec0000d0, // APMXVF32GERPP
+	0xec0004d0, // APMXVF32GERPN
+	0xec0002d0, // APMXVF32GERNP
+	0xec0006d0, // APMXVF32GERNN
+	0xec0000d8, // APMXVF32GER
+	0xec000090, // APMXVF16GER2PP
+	0xec000490, // APMXVF16GER2PN
+	0xec000290, // APMXVF16GER2NP
+	0xec000690, // APMXVF16GER2NN
+	0xec000098, // APMXVF16GER2
+	0xec000190, // APMXVBF16GER2PP
+	0xec000590, // APMXVBF16GER2PN
+	0xec000390, // APMXVBF16GER2NP
+	0xec000790, // APMXVBF16GER2NN
+	0xec000198, // APMXVBF16GER2
+	0xe8000000, // APLXVP
+	0xc8000000, // APLXV
+	0xac000000, // APLXSSP
+	0xa8000000, // APLXSD
+	0x80000000, // APLWZ
+	0xa4000000, // APLWA
+	0xe0000000, // APLQ
+	0xa0000000, // APLHZ
+	0xa8000000, // APLHA
+	0xc0000000, // APLFS
+	0xc8000000, // APLFD
+	0xe4000000, // APLD
+	0x88000000, // APLBZ
+	0x38000000, // APADDI
+}
+
+var GenPfxOpcodes = [...]uint32{
+	0x05000000, // AXXSPLTIW
+	0x05000000, // AXXSPLTIDP
+	0x05000000, // AXXSPLTI32DX
+	0x05000000, // AXXPERMX
+	0x05000000, // AXXEVAL
+	0x05000000, // AXXBLENDVW
+	0x05000000, // AXXBLENDVH
+	0x05000000, // AXXBLENDVD
+	0x05000000, // AXXBLENDVB
+	0x04000000, // APSTXVP
+	0x04000000, // APSTXV
+	0x04000000, // APSTXSSP
+	0x04000000, // APSTXSD
+	0x06000000, // APSTW
+	0x04000000, // APSTQ
+	0x06000000, // APSTH
+	0x06000000, // APSTFS
+	0x06000000, // APSTFD
+	0x04000000, // APSTD
+	0x06000000, // APSTB
+	0x07000000, // APNOP
+	0x07900000, // APMXVI8GER4SPP
+	0x07900000, // APMXVI8GER4PP
+	0x07900000, // APMXVI8GER4
+	0x07900000, // APMXVI4GER8PP
+	0x07900000, // APMXVI4GER8
+	0x07900000, // APMXVI16GER2SPP
+	0x07900000, // APMXVI16GER2S
+	0x07900000, // APMXVI16GER2PP
+	0x07900000, // APMXVI16GER2
+	0x07900000, // APMXVF64GERPP
+	0x07900000, // APMXVF64GERPN
+	0x07900000, // APMXVF64GERNP
+	0x07900000, // APMXVF64GERNN
+	0x07900000, // APMXVF64GER
+	0x07900000, // APMXVF32GERPP
+	0x07900000, // APMXVF32GERPN
+	0x07900000, // APMXVF32GERNP
+	0x07900000, // APMXVF32GERNN
+	0x07900000, // APMXVF32GER
+	0x07900000, // APMXVF16GER2PP
+	0x07900000, // APMXVF16GER2PN
+	0x07900000, // APMXVF16GER2NP
+	0x07900000, // APMXVF16GER2NN
+	0x07900000, // APMXVF16GER2
+	0x07900000, // APMXVBF16GER2PP
+	0x07900000, // APMXVBF16GER2PN
+	0x07900000, // APMXVBF16GER2NP
+	0x07900000, // APMXVBF16GER2NN
+	0x07900000, // APMXVBF16GER2
+	0x04000000, // APLXVP
+	0x04000000, // APLXV
+	0x04000000, // APLXSSP
+	0x04000000, // APLXSD
+	0x06000000, // APLWZ
+	0x04000000, // APLWA
+	0x04000000, // APLQ
+	0x06000000, // APLHZ
+	0x06000000, // APLHA
+	0x06000000, // APLFS
+	0x06000000, // APLFD
+	0x04000000, // APLD
+	0x06000000, // APLBZ
+	0x06000000, // APADDI
+}
+
+var optabGen = []Optab{
+	{as: ABRW, a1: C_REG, a6: C_REG, asmout: type_brw, size: 4},
+	{as: ADCFFIXQQ, a1: C_VREG, a6: C_FREGP, asmout: type_xscvuqqp, size: 4},
+	{as: ADCTFIXQQ, a1: C_FREGP, a6: C_VREG, asmout: type_xscvuqqp, size: 4},
+	{as: ALXVKQ, a1: C_U5CON, a6: C_VSREG, asmout: type_lxvkq, size: 4},
+	{as: ALXVP, a1: C_SOREG, a6: C_VSREGP, asmout: type_lxvp, size: 4},
+	{as: ALXVPX, a1: C_XOREG, a6: C_VSREGP, asmout: type_lxvpx, size: 4},
+	{as: ALXVRWX, a1: C_XOREG, a6: C_VSREG, asmout: type_lxvrwx, size: 4},
+	{as: AMTVSRBMI, a1: C_U16CON, a6: C_VREG, asmout: type_mtvsrbmi, size: 4},
+	{as: AMTVSRWM, a1: C_REG, a6: C_VREG, asmout: type_xscvuqqp, size: 4},
+	{as: APADDI, a1: C_REG, a3: C_S34CON, a4: C_U1CON, a6: C_REG, asmout: type_paddi, ispfx: true, size: 8},
+	{as: APEXTD, a1: C_REG, a2: C_REG, a6: C_REG, asmout: type_pextd, size: 4},
+	{as: APLFS, a1: C_LOREG, a3: C_U1CON, a6: C_FREG, asmout: type_plxssp, ispfx: true, size: 8},
+	{as: APLQ, a1: C_LOREG, a3: C_U1CON, a6: C_REGP, asmout: type_plxssp, ispfx: true, size: 8},
+	{as: APLWZ, a1: C_LOREG, a3: C_U1CON, a6: C_REG, asmout: type_plxssp, ispfx: true, size: 8},
+	{as: APLXSSP, a1: C_LOREG, a3: C_U1CON, a6: C_VREG, asmout: type_plxssp, ispfx: true, size: 8},
+	{as: APLXV, a1: C_LOREG, a3: C_U1CON, a6: C_VSREG, asmout: type_plxv, ispfx: true, size: 8},
+	{as: APLXVP, a1: C_LOREG, a3: C_U1CON, a6: C_VSREGP, asmout: type_plxvp, ispfx: true, size: 8},
+	{as: APMXVF32GERPP, a1: C_VSREG, a2: C_VSREG, a3: C_U4CON, a4: C_U4CON, a6: C_AREG, asmout: type_pmxvf32gerpp, ispfx: true, size: 8},
+	{as: APMXVF64GERPP, a1: C_VSREGP, a2: C_VSREG, a3: C_U4CON, a4: C_U2CON, a6: C_AREG, asmout: type_pmxvf64gerpp, ispfx: true, size: 8},
+	{as: APMXVI16GER2SPP, a1: C_VSREG, a2: C_VSREG, a3: C_U4CON, a4: C_U4CON, a5: C_U2CON, a6: C_AREG, asmout: type_pmxvi16ger2spp, ispfx: true, size: 8},
+	{as: APMXVI4GER8PP, a1: C_VSREG, a2: C_VSREG, a3: C_U4CON, a4: C_U4CON, a5: C_U8CON, a6: C_AREG, asmout: type_pmxvi4ger8pp, ispfx: true, size: 8},
+	{as: APMXVI8GER4SPP, a1: C_VSREG, a2: C_VSREG, a3: C_U4CON, a4: C_U4CON, a5: C_U4CON, a6: C_AREG, asmout: type_pmxvi8ger4spp, ispfx: true, size: 8},
+	{as: APNOP, asmout: type_pnop, ispfx: true, size: 8},
+	{as: APSTFS, a1: C_FREG, a3: C_U1CON, a6: C_LOREG, asmout: type_pstxssp, ispfx: true, size: 8},
+	{as: APSTQ, a1: C_REGP, a3: C_U1CON, a6: C_LOREG, asmout: type_pstxssp, ispfx: true, size: 8},
+	{as: APSTW, a1: C_REG, a3: C_U1CON, a6: C_LOREG, asmout: type_pstxssp, ispfx: true, size: 8},
+	{as: APSTXSSP, a1: C_VREG, a3: C_U1CON, a6: C_LOREG, asmout: type_pstxssp, ispfx: true, size: 8},
+	{as: APSTXV, a1: C_VSREG, a3: C_U1CON, a6: C_LOREG, asmout: type_pstxv, ispfx: true, size: 8},
+	{as: APSTXVP, a1: C_VSREGP, a3: C_U1CON, a6: C_LOREG, asmout: type_pstxvp, ispfx: true, size: 8},
+	{as: ASETNBCR, a1: C_CRBIT, a6: C_REG, asmout: type_setnbcr, size: 4},
+	{as: ASTXVP, a1: C_VSREGP, a6: C_SOREG, asmout: type_stxvp, size: 4},
+	{as: ASTXVPX, a1: C_VSREGP, a6: C_XOREG, asmout: type_stxvpx, size: 4},
+	{as: ASTXVRWX, a1: C_VSREG, a6: C_XOREG, asmout: type_stxvrwx, size: 4},
+	{as: AVCLRRB, a1: C_VREG, a2: C_REG, a6: C_VREG, asmout: type_xsmincqp, size: 4},
+	{as: AVCMPUQ, a1: C_VREG, a2: C_VREG, a6: C_CREG, asmout: type_vcmpuq, size: 4},
+	{as: AVCNTMBW, a1: C_VREG, a3: C_U1CON, a6: C_REG, asmout: type_vcntmbw, size: 4},
+	{as: AVEXTDUWVRX, a1: C_VREG, a2: C_VREG, a3: C_REG, a6: C_VREG, asmout: type_vmsumcud, size: 4},
+	{as: AVEXTRACTWM, a1: C_VREG, a6: C_REG, asmout: type_xscvuqqp, size: 4},
+	{as: AVGNB, a1: C_VREG, a3: C_U3CON, a6: C_REG, asmout: type_vgnb, size: 4},
+	{as: AVINSW, a1: C_REG, a3: C_U4CON, a6: C_VREG, asmout: type_vinsw, size: 4},
+	{as: AVINSWRX, a1: C_REG, a2: C_REG, a6: C_VREG, asmout: type_xsmincqp, size: 4},
+	{as: AVINSWVRX, a1: C_REG, a2: C_VREG, a6: C_VREG, asmout: type_xsmincqp, size: 4},
+	{as: AVMSUMCUD, a1: C_VREG, a2: C_VREG, a3: C_VREG, a6: C_VREG, asmout: type_vmsumcud, size: 4},
+	{as: AVSRDBI, a1: C_VREG, a2: C_VREG, a3: C_U3CON, a6: C_VREG, asmout: type_vsrdbi, size: 4},
+	{as: AXSCVUQQP, a1: C_VREG, a6: C_VREG, asmout: type_xscvuqqp, size: 4},
+	{as: AXSMINCQP, a1: C_VREG, a2: C_VREG, a6: C_VREG, asmout: type_xsmincqp, size: 4},
+	{as: AXVCVSPBF16, a1: C_VSREG, a6: C_VSREG, asmout: type_xvcvspbf16, size: 4},
+	{as: AXVI8GER4SPP, a1: C_VSREG, a2: C_VSREG, a6: C_AREG, asmout: type_xvi8ger4spp, size: 4},
+	{as: AXVTLSBB, a1: C_VSREG, a6: C_CREG, asmout: type_xvtlsbb, size: 4},
+	{as: AXXBLENDVW, a1: C_VSREG, a2: C_VSREG, a3: C_VSREG, a6: C_VSREG, asmout: type_xxblendvw, ispfx: true, size: 8},
+	{as: AXXEVAL, a1: C_VSREG, a2: C_VSREG, a3: C_VSREG, a4: C_U8CON, a6: C_VSREG, asmout: type_xxeval, ispfx: true, size: 8},
+	{as: AXXGENPCVWM, a1: C_VREG, a3: C_U5CON, a6: C_VSREG, asmout: type_xxgenpcvwm, size: 4},
+	{as: AXXPERMX, a1: C_VSREG, a2: C_VSREG, a3: C_VSREG, a4: C_U3CON, a6: C_VSREG, asmout: type_xxpermx, ispfx: true, size: 8},
+	{as: AXXSETACCZ, a6: C_AREG, asmout: type_xxsetaccz, size: 4},
+	{as: AXXSPLTI32DX, a1: C_U1CON, a3: C_U32CON, a6: C_VSREG, asmout: type_xxsplti32dx, ispfx: true, size: 8},
+	{as: AXXSPLTIW, a1: C_U32CON, a6: C_VSREG, asmout: type_xxspltiw, ispfx: true, size: 8},
+}
+
+// brw RA,RS
+func type_brw(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32(p.To.Reg&0x1f) << 16   // RA
+	o0 |= uint32(p.From.Reg&0x1f) << 21 // RS
+	out[0] = o0
+}
+
+// lxvkq XT,UIM
+func type_lxvkq(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32((p.To.Reg>>5)&0x1) << 0   // TX
+	o0 |= uint32(p.To.Reg&0x1f) << 21      // T
+	o0 |= uint32(p.From.Offset&0x1f) << 11 // UIM
+	out[0] = o0
+}
+
+// lxvp XTp,DQ(RA)
+func type_lxvp(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32((p.To.Reg>>5)&0x1) << 21       // TX
+	o0 |= uint32((p.To.Reg>>1)&0xf) << 22       // Tp
+	o0 |= uint32((p.From.Offset>>4)&0xfff) << 4 // DQ
+	o0 |= uint32(p.From.Reg&0x1f) << 16         // RA
+	if p.From.Offset&0xf != 0 {
+		c.ctxt.Diag("Constant 0x%x (%d) is not a multiple of 16\n%v", p.From.Offset, p.From.Offset, p)
+	}
+	out[0] = o0
+}
+
+// lxvpx XTp,RA,RB
+func type_lxvpx(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32((p.To.Reg>>5)&0x1) << 21 // TX
+	o0 |= uint32((p.To.Reg>>1)&0xf) << 22 // Tp
+	o0 |= uint32(p.From.Index&0x1f) << 16 // RA
+	o0 |= uint32(p.From.Reg&0x1f) << 11   // RB
+	out[0] = o0
+}
+
+// lxvrwx XT,RA,RB
+func type_lxvrwx(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32((p.To.Reg>>5)&0x1) << 0  // TX
+	o0 |= uint32(p.To.Reg&0x1f) << 21     // T
+	o0 |= uint32(p.From.Index&0x1f) << 16 // RA
+	o0 |= uint32(p.From.Reg&0x1f) << 11   // RB
+	out[0] = o0
+}
+
+// mtvsrbmi VRT,bm
+func type_mtvsrbmi(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32(p.To.Reg&0x1f) << 21           // VRT
+	o0 |= uint32((p.From.Offset>>6)&0x3ff) << 6 // b0
+	o0 |= uint32((p.From.Offset>>1)&0x1f) << 16 // b1
+	o0 |= uint32(p.From.Offset&0x1) << 0        // b2
+	out[0] = o0
+}
+
+// paddi RT,RA,SI,R
+func type_paddi(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenPfxOpcodes[p.As-AXXSPLTIW]
+	o1 := GenOpcodes[p.As-AXXSETACCZ]
+	o1 |= uint32(p.To.Reg&0x1f) << 21                          // RT
+	o1 |= uint32(p.From.Reg&0x1f) << 16                        // RA
+	o0 |= uint32((p.RestArgs[0].Addr.Offset>>16)&0x3ffff) << 0 // si0
+	o1 |= uint32(p.RestArgs[0].Addr.Offset&0xffff) << 0        // si1
+	o0 |= uint32(p.RestArgs[1].Addr.Offset&0x1) << 20          // R
+	out[1] = o1
+	out[0] = o0
+}
+
+// pextd RA,RS,RB
+func type_pextd(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32(p.To.Reg&0x1f) << 16   // RA
+	o0 |= uint32(p.From.Reg&0x1f) << 21 // RS
+	o0 |= uint32(p.Reg&0x1f) << 11      // RB
+	out[0] = o0
+}
+
+// plxssp VRT,D(RA),R
+func type_plxssp(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenPfxOpcodes[p.As-AXXSPLTIW]
+	o1 := GenOpcodes[p.As-AXXSETACCZ]
+	o1 |= uint32(p.To.Reg&0x1f) << 21                 // VRT
+	o0 |= uint32((p.From.Offset>>16)&0x3ffff) << 0    // d0
+	o1 |= uint32(p.From.Offset&0xffff) << 0           // d1
+	o1 |= uint32(p.From.Reg&0x1f) << 16               // RA
+	o0 |= uint32(p.RestArgs[0].Addr.Offset&0x1) << 20 // R
+	out[1] = o1
+	out[0] = o0
+}
+
+// plxv XT,D(RA),R
+func type_plxv(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenPfxOpcodes[p.As-AXXSPLTIW]
+	o1 := GenOpcodes[p.As-AXXSETACCZ]
+	o1 |= uint32((p.To.Reg>>5)&0x1) << 26             // TX
+	o1 |= uint32(p.To.Reg&0x1f) << 21                 // T
+	o0 |= uint32((p.From.Offset>>16)&0x3ffff) << 0    // d0
+	o1 |= uint32(p.From.Offset&0xffff) << 0           // d1
+	o1 |= uint32(p.From.Reg&0x1f) << 16               // RA
+	o0 |= uint32(p.RestArgs[0].Addr.Offset&0x1) << 20 // R
+	out[1] = o1
+	out[0] = o0
+}
+
+// plxvp XTp,D(RA),R
+func type_plxvp(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenPfxOpcodes[p.As-AXXSPLTIW]
+	o1 := GenOpcodes[p.As-AXXSETACCZ]
+	o1 |= uint32((p.To.Reg>>5)&0x1) << 21             // TX
+	o1 |= uint32((p.To.Reg>>1)&0xf) << 22             // Tp
+	o0 |= uint32((p.From.Offset>>16)&0x3ffff) << 0    // d0
+	o1 |= uint32(p.From.Offset&0xffff) << 0           // d1
+	o1 |= uint32(p.From.Reg&0x1f) << 16               // RA
+	o0 |= uint32(p.RestArgs[0].Addr.Offset&0x1) << 20 // R
+	out[1] = o1
+	out[0] = o0
+}
+
+// pmxvf32gerpp AT,XA,XB,XMSK,YMSK
+func type_pmxvf32gerpp(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenPfxOpcodes[p.As-AXXSPLTIW]
+	o1 := GenOpcodes[p.As-AXXSETACCZ]
+	o1 |= uint32(p.To.Reg&0x7) << 23                 // AT
+	o1 |= uint32((p.From.Reg>>5)&0x1) << 2           // AX
+	o1 |= uint32(p.From.Reg&0x1f) << 16              // A
+	o1 |= uint32((p.Reg>>5)&0x1) << 1                // BX
+	o1 |= uint32(p.Reg&0x1f) << 11                   // B
+	o0 |= uint32(p.RestArgs[0].Addr.Offset&0xf) << 4 // XMSK
+	o0 |= uint32(p.RestArgs[1].Addr.Offset&0xf) << 0 // YMSK
+	out[1] = o1
+	out[0] = o0
+}
+
+// pmxvf64gerpp AT,XAp,XB,XMSK,YMSK
+func type_pmxvf64gerpp(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenPfxOpcodes[p.As-AXXSPLTIW]
+	o1 := GenOpcodes[p.As-AXXSETACCZ]
+	o1 |= uint32(p.To.Reg&0x7) << 23                 // AT
+	o1 |= uint32((p.From.Reg>>5)&0x1) << 2           // AX
+	o1 |= uint32(p.From.Reg&0x1f) << 16              // Ap
+	o1 |= uint32((p.Reg>>5)&0x1) << 1                // BX
+	o1 |= uint32(p.Reg&0x1f) << 11                   // B
+	o0 |= uint32(p.RestArgs[0].Addr.Offset&0xf) << 4 // XMSK
+	o0 |= uint32(p.RestArgs[1].Addr.Offset&0x3) << 2 // YMSK
+	out[1] = o1
+	out[0] = o0
+}
+
+// pmxvi16ger2spp AT,XA,XB,XMSK,YMSK,PMSK
+func type_pmxvi16ger2spp(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenPfxOpcodes[p.As-AXXSPLTIW]
+	o1 := GenOpcodes[p.As-AXXSETACCZ]
+	o1 |= uint32(p.To.Reg&0x7) << 23                  // AT
+	o1 |= uint32((p.From.Reg>>5)&0x1) << 2            // AX
+	o1 |= uint32(p.From.Reg&0x1f) << 16               // A
+	o1 |= uint32((p.Reg>>5)&0x1) << 1                 // BX
+	o1 |= uint32(p.Reg&0x1f) << 11                    // B
+	o0 |= uint32(p.RestArgs[0].Addr.Offset&0xf) << 4  // XMSK
+	o0 |= uint32(p.RestArgs[1].Addr.Offset&0xf) << 0  // YMSK
+	o0 |= uint32(p.RestArgs[2].Addr.Offset&0x3) << 14 // PMSK
+	out[1] = o1
+	out[0] = o0
+}
+
+// pmxvi4ger8pp AT,XA,XB,XMSK,YMSK,PMSK
+func type_pmxvi4ger8pp(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenPfxOpcodes[p.As-AXXSPLTIW]
+	o1 := GenOpcodes[p.As-AXXSETACCZ]
+	o1 |= uint32(p.To.Reg&0x7) << 23                  // AT
+	o1 |= uint32((p.From.Reg>>5)&0x1) << 2            // AX
+	o1 |= uint32(p.From.Reg&0x1f) << 16               // A
+	o1 |= uint32((p.Reg>>5)&0x1) << 1                 // BX
+	o1 |= uint32(p.Reg&0x1f) << 11                    // B
+	o0 |= uint32(p.RestArgs[0].Addr.Offset&0xf) << 4  // XMSK
+	o0 |= uint32(p.RestArgs[1].Addr.Offset&0xf) << 0  // YMSK
+	o0 |= uint32(p.RestArgs[2].Addr.Offset&0xff) << 8 // PMSK
+	out[1] = o1
+	out[0] = o0
+}
+
+// pmxvi8ger4spp AT,XA,XB,XMSK,YMSK,PMSK
+func type_pmxvi8ger4spp(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenPfxOpcodes[p.As-AXXSPLTIW]
+	o1 := GenOpcodes[p.As-AXXSETACCZ]
+	o1 |= uint32(p.To.Reg&0x7) << 23                  // AT
+	o1 |= uint32((p.From.Reg>>5)&0x1) << 2            // AX
+	o1 |= uint32(p.From.Reg&0x1f) << 16               // A
+	o1 |= uint32((p.Reg>>5)&0x1) << 1                 // BX
+	o1 |= uint32(p.Reg&0x1f) << 11                    // B
+	o0 |= uint32(p.RestArgs[0].Addr.Offset&0xf) << 4  // XMSK
+	o0 |= uint32(p.RestArgs[1].Addr.Offset&0xf) << 0  // YMSK
+	o0 |= uint32(p.RestArgs[2].Addr.Offset&0xf) << 12 // PMSK
+	out[1] = o1
+	out[0] = o0
+}
+
+// pnop
+func type_pnop(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenPfxOpcodes[p.As-AXXSPLTIW]
+	o1 := GenOpcodes[p.As-AXXSETACCZ]
+	out[1] = o1
+	out[0] = o0
+}
+
+// pstxssp VRS,D(RA),R
+func type_pstxssp(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenPfxOpcodes[p.As-AXXSPLTIW]
+	o1 := GenOpcodes[p.As-AXXSETACCZ]
+	o1 |= uint32(p.From.Reg&0x1f) << 21               // VRS
+	o0 |= uint32((p.To.Offset>>16)&0x3ffff) << 0      // d0
+	o1 |= uint32(p.To.Offset&0xffff) << 0             // d1
+	o1 |= uint32(p.To.Reg&0x1f) << 16                 // RA
+	o0 |= uint32(p.RestArgs[0].Addr.Offset&0x1) << 20 // R
+	out[1] = o1
+	out[0] = o0
+}
+
+// pstxv XS,D(RA),R
+func type_pstxv(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenPfxOpcodes[p.As-AXXSPLTIW]
+	o1 := GenOpcodes[p.As-AXXSETACCZ]
+	o1 |= uint32((p.From.Reg>>5)&0x1) << 26           // SX
+	o1 |= uint32(p.From.Reg&0x1f) << 21               // S
+	o0 |= uint32((p.To.Offset>>16)&0x3ffff) << 0      // d0
+	o1 |= uint32(p.To.Offset&0xffff) << 0             // d1
+	o1 |= uint32(p.To.Reg&0x1f) << 16                 // RA
+	o0 |= uint32(p.RestArgs[0].Addr.Offset&0x1) << 20 // R
+	out[1] = o1
+	out[0] = o0
+}
+
+// pstxvp XSp,D(RA),R
+func type_pstxvp(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenPfxOpcodes[p.As-AXXSPLTIW]
+	o1 := GenOpcodes[p.As-AXXSETACCZ]
+	o1 |= uint32((p.From.Reg>>5)&0x1) << 21           // SX
+	o1 |= uint32((p.From.Reg>>1)&0xf) << 22           // Sp
+	o0 |= uint32((p.To.Offset>>16)&0x3ffff) << 0      // d0
+	o1 |= uint32(p.To.Offset&0xffff) << 0             // d1
+	o1 |= uint32(p.To.Reg&0x1f) << 16                 // RA
+	o0 |= uint32(p.RestArgs[0].Addr.Offset&0x1) << 20 // R
+	out[1] = o1
+	out[0] = o0
+}
+
+// setnbcr RT,BI
+func type_setnbcr(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32(p.To.Reg&0x1f) << 21   // RT
+	o0 |= uint32(p.From.Reg&0x1f) << 16 // BI
+	out[0] = o0
+}
+
+// stxvp XSp,DQ(RA)
+func type_stxvp(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32((p.From.Reg>>5)&0x1) << 21   // SX
+	o0 |= uint32((p.From.Reg>>1)&0xf) << 22   // Sp
+	o0 |= uint32((p.To.Offset>>4)&0xfff) << 4 // DQ
+	o0 |= uint32(p.To.Reg&0x1f) << 16         // RA
+	if p.To.Offset&0xf != 0 {
+		c.ctxt.Diag("Constant 0x%x (%d) is not a multiple of 16\n%v", p.To.Offset, p.To.Offset, p)
+	}
+	out[0] = o0
+}
+
+// stxvpx XSp,RA,RB
+func type_stxvpx(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32((p.From.Reg>>5)&0x1) << 21 // SX
+	o0 |= uint32((p.From.Reg>>1)&0xf) << 22 // Sp
+	o0 |= uint32(p.To.Index&0x1f) << 16     // RA
+	o0 |= uint32(p.To.Reg&0x1f) << 11       // RB
+	out[0] = o0
+}
+
+// stxvrwx XS,RA,RB
+func type_stxvrwx(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32((p.From.Reg>>5)&0x1) << 0 // SX
+	o0 |= uint32(p.From.Reg&0x1f) << 21    // S
+	o0 |= uint32(p.To.Index&0x1f) << 16    // RA
+	o0 |= uint32(p.To.Reg&0x1f) << 11      // RB
+	out[0] = o0
+}
+
+// vcmpuq BF,VRA,VRB
+func type_vcmpuq(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32(p.To.Reg&0x7) << 23    // BF
+	o0 |= uint32(p.From.Reg&0x1f) << 16 // VRA
+	o0 |= uint32(p.Reg&0x1f) << 11      // VRB
+	out[0] = o0
+}
+
+// vcntmbw RT,VRB,MP
+func type_vcntmbw(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32(p.To.Reg&0x1f) << 21                 // RT
+	o0 |= uint32(p.From.Reg&0x1f) << 11               // VRB
+	o0 |= uint32(p.RestArgs[0].Addr.Offset&0x1) << 16 // MP
+	out[0] = o0
+}
+
+// vgnb RT,VRB,N
+func type_vgnb(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32(p.To.Reg&0x1f) << 21                 // RT
+	o0 |= uint32(p.From.Reg&0x1f) << 11               // VRB
+	o0 |= uint32(p.RestArgs[0].Addr.Offset&0x7) << 16 // N
+	out[0] = o0
+}
+
+// vinsw VRT,RB,UIM
+func type_vinsw(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32(p.To.Reg&0x1f) << 21                 // VRT
+	o0 |= uint32(p.From.Reg&0x1f) << 11               // RB
+	o0 |= uint32(p.RestArgs[0].Addr.Offset&0xf) << 16 // UIM
+	out[0] = o0
+}
+
+// vmsumcud VRT,VRA,VRB,VRC
+func type_vmsumcud(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32(p.To.Reg&0x1f) << 21              // VRT
+	o0 |= uint32(p.From.Reg&0x1f) << 16            // VRA
+	o0 |= uint32(p.Reg&0x1f) << 11                 // VRB
+	o0 |= uint32(p.RestArgs[0].Addr.Reg&0x1f) << 6 // VRC
+	out[0] = o0
+}
+
+// vsrdbi VRT,VRA,VRB,SH
+func type_vsrdbi(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32(p.To.Reg&0x1f) << 21                // VRT
+	o0 |= uint32(p.From.Reg&0x1f) << 16              // VRA
+	o0 |= uint32(p.Reg&0x1f) << 11                   // VRB
+	o0 |= uint32(p.RestArgs[0].Addr.Offset&0x7) << 6 // SH
+	out[0] = o0
+}
+
+// xscvuqqp VRT,VRB
+func type_xscvuqqp(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32(p.To.Reg&0x1f) << 21   // VRT
+	o0 |= uint32(p.From.Reg&0x1f) << 11 // VRB
+	out[0] = o0
+}
+
+// xsmincqp VRT,VRA,VRB
+func type_xsmincqp(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32(p.To.Reg&0x1f) << 21   // VRT
+	o0 |= uint32(p.From.Reg&0x1f) << 16 // VRA
+	o0 |= uint32(p.Reg&0x1f) << 11      // VRB
+	out[0] = o0
+}
+
+// xvcvspbf16 XT,XB
+func type_xvcvspbf16(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32((p.To.Reg>>5)&0x1) << 0   // TX
+	o0 |= uint32(p.To.Reg&0x1f) << 21      // T
+	o0 |= uint32((p.From.Reg>>5)&0x1) << 1 // BX
+	o0 |= uint32(p.From.Reg&0x1f) << 11    // B
+	out[0] = o0
+}
+
+// xvi8ger4spp AT,XA,XB
+func type_xvi8ger4spp(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32(p.To.Reg&0x7) << 23       // AT
+	o0 |= uint32((p.From.Reg>>5)&0x1) << 2 // AX
+	o0 |= uint32(p.From.Reg&0x1f) << 16    // A
+	o0 |= uint32((p.Reg>>5)&0x1) << 1      // BX
+	o0 |= uint32(p.Reg&0x1f) << 11         // B
+	out[0] = o0
+}
+
+// xvtlsbb BF,XB
+func type_xvtlsbb(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32(p.To.Reg&0x7) << 23       // BF
+	o0 |= uint32((p.From.Reg>>5)&0x1) << 1 // BX
+	o0 |= uint32(p.From.Reg&0x1f) << 11    // B
+	out[0] = o0
+}
+
+// xxblendvw XT,XA,XB,XC
+func type_xxblendvw(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenPfxOpcodes[p.As-AXXSPLTIW]
+	o1 := GenOpcodes[p.As-AXXSETACCZ]
+	o1 |= uint32((p.To.Reg>>5)&0x1) << 0               // TX
+	o1 |= uint32(p.To.Reg&0x1f) << 21                  // T
+	o1 |= uint32((p.From.Reg>>5)&0x1) << 2             // AX
+	o1 |= uint32(p.From.Reg&0x1f) << 16                // A
+	o1 |= uint32((p.Reg>>5)&0x1) << 1                  // BX
+	o1 |= uint32(p.Reg&0x1f) << 11                     // B
+	o1 |= uint32((p.RestArgs[0].Addr.Reg>>5)&0x1) << 3 // CX
+	o1 |= uint32(p.RestArgs[0].Addr.Reg&0x1f) << 6     // C
+	out[1] = o1
+	out[0] = o0
+}
+
+// xxeval XT,XA,XB,XC,IMM
+func type_xxeval(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenPfxOpcodes[p.As-AXXSPLTIW]
+	o1 := GenOpcodes[p.As-AXXSETACCZ]
+	o1 |= uint32((p.To.Reg>>5)&0x1) << 0               // TX
+	o1 |= uint32(p.To.Reg&0x1f) << 21                  // T
+	o1 |= uint32((p.From.Reg>>5)&0x1) << 2             // AX
+	o1 |= uint32(p.From.Reg&0x1f) << 16                // A
+	o1 |= uint32((p.Reg>>5)&0x1) << 1                  // BX
+	o1 |= uint32(p.Reg&0x1f) << 11                     // B
+	o1 |= uint32((p.RestArgs[0].Addr.Reg>>5)&0x1) << 3 // CX
+	o1 |= uint32(p.RestArgs[0].Addr.Reg&0x1f) << 6     // C
+	o0 |= uint32(p.RestArgs[1].Addr.Offset&0xff) << 0  // IMM
+	out[1] = o1
+	out[0] = o0
+}
+
+// xxgenpcvwm XT,VRB,IMM
+func type_xxgenpcvwm(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32((p.To.Reg>>5)&0x1) << 0               // TX
+	o0 |= uint32(p.To.Reg&0x1f) << 21                  // T
+	o0 |= uint32(p.From.Reg&0x1f) << 11                // VRB
+	o0 |= uint32(p.RestArgs[0].Addr.Offset&0x1f) << 16 // IMM
+	out[0] = o0
+}
+
+// xxpermx XT,XA,XB,XC,UIM
+func type_xxpermx(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenPfxOpcodes[p.As-AXXSPLTIW]
+	o1 := GenOpcodes[p.As-AXXSETACCZ]
+	o1 |= uint32((p.To.Reg>>5)&0x1) << 0               // TX
+	o1 |= uint32(p.To.Reg&0x1f) << 21                  // T
+	o1 |= uint32((p.From.Reg>>5)&0x1) << 2             // AX
+	o1 |= uint32(p.From.Reg&0x1f) << 16                // A
+	o1 |= uint32((p.Reg>>5)&0x1) << 1                  // BX
+	o1 |= uint32(p.Reg&0x1f) << 11                     // B
+	o1 |= uint32((p.RestArgs[0].Addr.Reg>>5)&0x1) << 3 // CX
+	o1 |= uint32(p.RestArgs[0].Addr.Reg&0x1f) << 6     // C
+	o0 |= uint32(p.RestArgs[1].Addr.Offset&0x7) << 0   // UIM
+	out[1] = o1
+	out[0] = o0
+}
+
+// xxsetaccz AT
+func type_xxsetaccz(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenOpcodes[p.As-AXXSETACCZ]
+	o0 |= uint32(p.To.Reg&0x7) << 23 // AT
+	out[0] = o0
+}
+
+// xxsplti32dx XT,IX,IMM32
+func type_xxsplti32dx(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenPfxOpcodes[p.As-AXXSPLTIW]
+	o1 := GenOpcodes[p.As-AXXSETACCZ]
+	o1 |= uint32((p.To.Reg>>5)&0x1) << 16                     // TX
+	o1 |= uint32(p.To.Reg&0x1f) << 21                         // T
+	o1 |= uint32(p.From.Offset&0x1) << 17                     // IX
+	o0 |= uint32((p.RestArgs[0].Addr.Offset>>16)&0xffff) << 0 // imm0
+	o1 |= uint32(p.RestArgs[0].Addr.Offset&0xffff) << 0       // imm1
+	out[1] = o1
+	out[0] = o0
+}
+
+// xxspltiw XT,IMM32
+func type_xxspltiw(c *ctxt9, p *obj.Prog, t *Optab, out *[5]uint32) {
+	o0 := GenPfxOpcodes[p.As-AXXSPLTIW]
+	o1 := GenOpcodes[p.As-AXXSETACCZ]
+	o1 |= uint32((p.To.Reg>>5)&0x1) << 16         // TX
+	o1 |= uint32(p.To.Reg&0x1f) << 21             // T
+	o0 |= uint32((p.From.Offset>>16)&0xffff) << 0 // imm0
+	o1 |= uint32(p.From.Offset&0xffff) << 0       // imm1
+	out[1] = o1
+	out[0] = o0
+}
+
+func opsetGen(from obj.As) bool {
+	r0 := from & obj.AMask
+	switch from {
+	case ABRW:
+		opset(ABRH, r0)
+		opset(ABRD, r0)
+	case ADCFFIXQQ:
+	case ADCTFIXQQ:
+	case ALXVKQ:
+	case ALXVP:
+	case ALXVPX:
+	case ALXVRWX:
+		opset(ALXVRHX, r0)
+		opset(ALXVRDX, r0)
+		opset(ALXVRBX, r0)
+	case AMTVSRBMI:
+	case AMTVSRWM:
+		opset(AMTVSRQM, r0)
+		opset(AMTVSRHM, r0)
+		opset(AMTVSRDM, r0)
+		opset(AMTVSRBM, r0)
+	case APADDI:
+	case APEXTD:
+		opset(APDEPD, r0)
+		opset(ACNTTZDM, r0)
+		opset(ACNTLZDM, r0)
+		opset(ACFUGED, r0)
+	case APLFS:
+		opset(APLFD, r0)
+	case APLQ:
+	case APLWZ:
+		opset(APLWA, r0)
+		opset(APLHZ, r0)
+		opset(APLHA, r0)
+		opset(APLD, r0)
+		opset(APLBZ, r0)
+	case APLXSSP:
+		opset(APLXSD, r0)
+	case APLXV:
+	case APLXVP:
+	case APMXVF32GERPP:
+		opset(APMXVF32GERPN, r0)
+		opset(APMXVF32GERNP, r0)
+		opset(APMXVF32GERNN, r0)
+		opset(APMXVF32GER, r0)
+	case APMXVF64GERPP:
+		opset(APMXVF64GERPN, r0)
+		opset(APMXVF64GERNP, r0)
+		opset(APMXVF64GERNN, r0)
+		opset(APMXVF64GER, r0)
+	case APMXVI16GER2SPP:
+		opset(APMXVI16GER2S, r0)
+		opset(APMXVI16GER2PP, r0)
+		opset(APMXVI16GER2, r0)
+		opset(APMXVF16GER2PP, r0)
+		opset(APMXVF16GER2PN, r0)
+		opset(APMXVF16GER2NP, r0)
+		opset(APMXVF16GER2NN, r0)
+		opset(APMXVF16GER2, r0)
+		opset(APMXVBF16GER2PP, r0)
+		opset(APMXVBF16GER2PN, r0)
+		opset(APMXVBF16GER2NP, r0)
+		opset(APMXVBF16GER2NN, r0)
+		opset(APMXVBF16GER2, r0)
+	case APMXVI4GER8PP:
+		opset(APMXVI4GER8, r0)
+	case APMXVI8GER4SPP:
+		opset(APMXVI8GER4PP, r0)
+		opset(APMXVI8GER4, r0)
+	case APNOP:
+	case APSTFS:
+		opset(APSTFD, r0)
+	case APSTQ:
+	case APSTW:
+		opset(APSTH, r0)
+		opset(APSTD, r0)
+		opset(APSTB, r0)
+	case APSTXSSP:
+		opset(APSTXSD, r0)
+	case APSTXV:
+	case APSTXVP:
+	case ASETNBCR:
+		opset(ASETNBC, r0)
+		opset(ASETBCR, r0)
+		opset(ASETBC, r0)
+	case ASTXVP:
+	case ASTXVPX:
+	case ASTXVRWX:
+		opset(ASTXVRHX, r0)
+		opset(ASTXVRDX, r0)
+		opset(ASTXVRBX, r0)
+	case AVCLRRB:
+		opset(AVCLRLB, r0)
+	case AVCMPUQ:
+		opset(AVCMPSQ, r0)
+	case AVCNTMBW:
+		opset(AVCNTMBH, r0)
+		opset(AVCNTMBD, r0)
+		opset(AVCNTMBB, r0)
+	case AVEXTDUWVRX:
+		opset(AVEXTDUWVLX, r0)
+		opset(AVEXTDUHVRX, r0)
+		opset(AVEXTDUHVLX, r0)
+		opset(AVEXTDUBVRX, r0)
+		opset(AVEXTDUBVLX, r0)
+		opset(AVEXTDDVRX, r0)
+		opset(AVEXTDDVLX, r0)
+	case AVEXTRACTWM:
+		opset(AVEXTRACTQM, r0)
+		opset(AVEXTRACTHM, r0)
+		opset(AVEXTRACTDM, r0)
+		opset(AVEXTRACTBM, r0)
+	case AVGNB:
+	case AVINSW:
+		opset(AVINSD, r0)
+	case AVINSWRX:
+		opset(AVINSWLX, r0)
+		opset(AVINSHRX, r0)
+		opset(AVINSHLX, r0)
+		opset(AVINSDRX, r0)
+		opset(AVINSDLX, r0)
+		opset(AVINSBRX, r0)
+		opset(AVINSBLX, r0)
+	case AVINSWVRX:
+		opset(AVINSWVLX, r0)
+		opset(AVINSHVRX, r0)
+		opset(AVINSHVLX, r0)
+		opset(AVINSBVRX, r0)
+		opset(AVINSBVLX, r0)
+	case AVMSUMCUD:
+	case AVSRDBI:
+		opset(AVSLDBI, r0)
+	case AXSCVUQQP:
+		opset(AXSCVSQQP, r0)
+		opset(AXSCVQPUQZ, r0)
+		opset(AXSCVQPSQZ, r0)
+		opset(AVSTRIHRCC, r0)
+		opset(AVSTRIHR, r0)
+		opset(AVSTRIHLCC, r0)
+		opset(AVSTRIHL, r0)
+		opset(AVSTRIBRCC, r0)
+		opset(AVSTRIBR, r0)
+		opset(AVSTRIBLCC, r0)
+		opset(AVSTRIBL, r0)
+		opset(AVEXTSD2Q, r0)
+		opset(AVEXPANDWM, r0)
+		opset(AVEXPANDQM, r0)
+		opset(AVEXPANDHM, r0)
+		opset(AVEXPANDDM, r0)
+		opset(AVEXPANDBM, r0)
+	case AXSMINCQP:
+		opset(AXSMAXCQP, r0)
+		opset(AXSCMPGTQP, r0)
+		opset(AXSCMPGEQP, r0)
+		opset(AXSCMPEQQP, r0)
+		opset(AVSRQ, r0)
+		opset(AVSRAQ, r0)
+		opset(AVSLQ, r0)
+		opset(AVRLQNM, r0)
+		opset(AVRLQMI, r0)
+		opset(AVRLQ, r0)
+		opset(AVPEXTD, r0)
+		opset(AVPDEPD, r0)
+		opset(AVMULOUD, r0)
+		opset(AVMULOSD, r0)
+		opset(AVMULLD, r0)
+		opset(AVMULHUW, r0)
+		opset(AVMULHUD, r0)
+		opset(AVMULHSW, r0)
+		opset(AVMULHSD, r0)
+		opset(AVMULEUD, r0)
+		opset(AVMULESD, r0)
+		opset(AVMODUW, r0)
+		opset(AVMODUQ, r0)
+		opset(AVMODUD, r0)
+		opset(AVMODSW, r0)
+		opset(AVMODSQ, r0)
+		opset(AVMODSD, r0)
+		opset(AVDIVUW, r0)
+		opset(AVDIVUQ, r0)
+		opset(AVDIVUD, r0)
+		opset(AVDIVSW, r0)
+		opset(AVDIVSQ, r0)
+		opset(AVDIVSD, r0)
+		opset(AVDIVEUW, r0)
+		opset(AVDIVEUQ, r0)
+		opset(AVDIVEUD, r0)
+		opset(AVDIVESW, r0)
+		opset(AVDIVESQ, r0)
+		opset(AVDIVESD, r0)
+		opset(AVCTZDM, r0)
+		opset(AVCMPGTUQCC, r0)
+		opset(AVCMPGTUQ, r0)
+		opset(AVCMPGTSQCC, r0)
+		opset(AVCMPGTSQ, r0)
+		opset(AVCMPEQUQCC, r0)
+		opset(AVCMPEQUQ, r0)
+		opset(AVCLZDM, r0)
+		opset(AVCFUGED, r0)
+	case AXVCVSPBF16:
+		opset(AXVCVBF16SPN, r0)
+	case AXVI8GER4SPP:
+		opset(AXVI8GER4PP, r0)
+		opset(AXVI8GER4, r0)
+		opset(AXVI4GER8PP, r0)
+		opset(AXVI4GER8, r0)
+		opset(AXVI16GER2SPP, r0)
+		opset(AXVI16GER2S, r0)
+		opset(AXVI16GER2PP, r0)
+		opset(AXVI16GER2, r0)
+		opset(AXVF64GERPP, r0)
+		opset(AXVF64GERPN, r0)
+		opset(AXVF64GERNP, r0)
+		opset(AXVF64GERNN, r0)
+		opset(AXVF64GER, r0)
+		opset(AXVF32GERPP, r0)
+		opset(AXVF32GERPN, r0)
+		opset(AXVF32GERNP, r0)
+		opset(AXVF32GERNN, r0)
+		opset(AXVF32GER, r0)
+		opset(AXVF16GER2PP, r0)
+		opset(AXVF16GER2PN, r0)
+		opset(AXVF16GER2NP, r0)
+		opset(AXVF16GER2NN, r0)
+		opset(AXVF16GER2, r0)
+		opset(AXVBF16GER2PP, r0)
+		opset(AXVBF16GER2PN, r0)
+		opset(AXVBF16GER2NP, r0)
+		opset(AXVBF16GER2NN, r0)
+		opset(AXVBF16GER2, r0)
+	case AXVTLSBB:
+	case AXXBLENDVW:
+		opset(AXXBLENDVH, r0)
+		opset(AXXBLENDVD, r0)
+		opset(AXXBLENDVB, r0)
+	case AXXEVAL:
+	case AXXGENPCVWM:
+		opset(AXXGENPCVHM, r0)
+		opset(AXXGENPCVDM, r0)
+		opset(AXXGENPCVBM, r0)
+	case AXXPERMX:
+	case AXXSETACCZ:
+		opset(AXXMTACC, r0)
+		opset(AXXMFACC, r0)
+	case AXXSPLTI32DX:
+	case AXXSPLTIW:
+		opset(AXXSPLTIDP, r0)
+	default:
+		return false
+	}
+	return true
+}
diff --git a/src/cmd/internal/obj/ppc64/list9.go b/src/cmd/internal/obj/ppc64/list9.go
index 4602b79b86..451c162ff3 100644
--- a/src/cmd/internal/obj/ppc64/list9.go
+++ b/src/cmd/internal/obj/ppc64/list9.go
@@ -36,7 +36,9 @@ import (
 
 func init() {
 	obj.RegisterRegister(obj.RBasePPC64, REG_SPR0+1024, rconv)
-	obj.RegisterOpcode(obj.ABasePPC64, Anames)
+	// Note, the last entry in Anames is "LASTAOUT", it is not a real opcode.
+	obj.RegisterOpcode(obj.ABasePPC64, Anames[:len(Anames)-1])
+	obj.RegisterOpcode(AFIRSTGEN, GenAnames)
 }
 
 func rconv(r int) string {
diff --git a/src/cmd/internal/obj/ppc64/obj9.go b/src/cmd/internal/obj/ppc64/obj9.go
index b6b2a8a9a7..9aa5c87d1f 100644
--- a/src/cmd/internal/obj/ppc64/obj9.go
+++ b/src/cmd/internal/obj/ppc64/obj9.go
@@ -1382,12 +1382,23 @@ func (c *ctxt9) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
 	return p
 }
 
+// MMA accumulator to/from instructions are slightly ambiguous since
+// the argument represents both source and destination, specified as
+// an accumulator. It is treated as a unary destination to simplify
+// the code generation in ppc64map.
+var unaryDst = map[obj.As]bool{
+	AXXSETACCZ: true,
+	AXXMTACC:   true,
+	AXXMFACC:   true,
+}
+
 var Linkppc64 = obj.LinkArch{
 	Arch:           sys.ArchPPC64,
 	Init:           buildop,
 	Preprocess:     preprocess,
 	Assemble:       span9,
 	Progedit:       progedit,
+	UnaryDst:       unaryDst,
 	DWARFRegisters: PPC64DWARFRegisters,
 }
 
@@ -1397,5 +1408,6 @@ var Linkppc64le = obj.LinkArch{
 	Preprocess:     preprocess,
 	Assemble:       span9,
 	Progedit:       progedit,
+	UnaryDst:       unaryDst,
 	DWARFRegisters: PPC64DWARFRegisters,
 }
