commit 330282a3a96099894ac0b6daceee19a483c12bbd
Author: Robert Griesemer <gri@golang.org>
Date:   Thu Aug 25 17:43:18 2022 -0700

    cmd/compile/internal/types2: use go/types/testdata/check tests
    
    Since the check tests are now identical between the two type checkers,
    remove the local copy of the check tests and (for now) use the tests
    in go/types/testdata/check instead. Eventually we may decide to move
    all tests out of the type checker directories and place them in a
    shared space (e.g. internal/types/testdata).
    
    For #54511.
    
    Change-Id: Id3a97593f6c705c5eda4566089ddc7aeb7b47337
    Reviewed-on: https://go-review.googlesource.com/c/go/+/425736
    Reviewed-by: Alan Donovan <adonovan@google.com>
    TryBot-Result: Gopher Robot <gobot@golang.org>
    Run-TryBot: Robert Griesemer <gri@google.com>
    Auto-Submit: Robert Griesemer <gri@google.com>
    Reviewed-by: Robert Griesemer <gri@google.com>
---
 src/cmd/compile/internal/types2/check_test.go      |   7 +-
 .../internal/types2/testdata/check/blank.go        |   5 -
 .../internal/types2/testdata/check/builtins0.go    | 956 --------------------
 .../internal/types2/testdata/check/builtins1.go    | 274 ------
 .../internal/types2/testdata/check/chans.go        |  62 --
 .../internal/types2/testdata/check/compliterals.go |  22 -
 .../internal/types2/testdata/check/const0.go       | 382 --------
 .../internal/types2/testdata/check/const1.go       | 334 -------
 .../internal/types2/testdata/check/constdecl.go    | 160 ----
 .../internal/types2/testdata/check/conversions0.go |  93 --
 .../internal/types2/testdata/check/conversions1.go | 313 -------
 .../internal/types2/testdata/check/cycles0.go      | 175 ----
 .../internal/types2/testdata/check/cycles1.go      |  77 --
 .../internal/types2/testdata/check/cycles2.go      |  98 --
 .../internal/types2/testdata/check/cycles3.go      |  60 --
 .../internal/types2/testdata/check/cycles4.go      | 121 ---
 .../internal/types2/testdata/check/cycles5.go      | 200 -----
 .../internal/types2/testdata/check/decls0.go       | 210 -----
 .../internal/types2/testdata/check/decls1.go       | 146 ---
 .../types2/testdata/check/decls2/decls2a.go        | 111 ---
 .../types2/testdata/check/decls2/decls2b.go        |  75 --
 .../internal/types2/testdata/check/decls3.go       | 309 -------
 .../internal/types2/testdata/check/decls4.go       | 199 -----
 .../internal/types2/testdata/check/decls5.go       |  10 -
 .../internal/types2/testdata/check/errors.go       |  66 --
 .../internal/types2/testdata/check/expr0.go        | 187 ----
 .../internal/types2/testdata/check/expr1.go        | 127 ---
 .../internal/types2/testdata/check/expr2.go        | 260 ------
 .../internal/types2/testdata/check/expr3.go        | 564 ------------
 .../types2/testdata/check/funcinference.go         | 104 ---
 .../internal/types2/testdata/check/go1_12.go       |  36 -
 .../internal/types2/testdata/check/go1_13.go       |  23 -
 .../internal/types2/testdata/check/go1_16.go       |  15 -
 .../internal/types2/testdata/check/go1_8.go        |  12 -
 .../internal/types2/testdata/check/gotos.go        | 560 ------------
 .../internal/types2/testdata/check/importC.go      |  56 --
 .../testdata/check/importdecl0/importdecl0a.go     |  53 --
 .../testdata/check/importdecl0/importdecl0b.go     |  30 -
 .../testdata/check/importdecl1/importdecl1a.go     |  22 -
 .../testdata/check/importdecl1/importdecl1b.go     |  11 -
 .../internal/types2/testdata/check/init0.go        | 106 ---
 .../internal/types2/testdata/check/init1.go        |  97 --
 .../internal/types2/testdata/check/init2.go        | 139 ---
 .../testdata/check/issue25008/issue25008a.go       |  15 -
 .../testdata/check/issue25008/issue25008b.go       |   9 -
 .../internal/types2/testdata/check/issues0.go      | 373 --------
 .../internal/types2/testdata/check/issues1.go      | 250 ------
 .../internal/types2/testdata/check/labels.go       | 207 -----
 .../internal/types2/testdata/check/linalg.go       |  82 --
 .../internal/types2/testdata/check/literals.go     | 111 ---
 .../internal/types2/testdata/check/main0.go        |   9 -
 .../internal/types2/testdata/check/main1.go        |   7 -
 .../compile/internal/types2/testdata/check/map0.go | 113 ---
 .../compile/internal/types2/testdata/check/map1.go | 146 ---
 .../internal/types2/testdata/check/methodsets.go   | 214 -----
 .../internal/types2/testdata/check/shifts.go       | 399 ---------
 .../internal/types2/testdata/check/slices.go       |  68 --
 .../internal/types2/testdata/check/stmt0.go        | 992 ---------------------
 .../internal/types2/testdata/check/stmt1.go        | 259 ------
 .../types2/testdata/check/typeinference.go         |  49 -
 .../internal/types2/testdata/check/typeinst0.go    |  62 --
 .../internal/types2/testdata/check/typeinst1.go    | 282 ------
 .../types2/testdata/check/typeinstcycles.go        |  11 -
 .../internal/types2/testdata/check/typeparams.go   | 508 -----------
 .../internal/types2/testdata/check/unions.go       |  66 --
 .../internal/types2/testdata/check/vardecl.go      | 215 -----
 66 files changed, 5 insertions(+), 11309 deletions(-)

diff --git a/src/cmd/compile/internal/types2/check_test.go b/src/cmd/compile/internal/types2/check_test.go
index 4f032fbd59..3eab464b96 100644
--- a/src/cmd/compile/internal/types2/check_test.go
+++ b/src/cmd/compile/internal/types2/check_test.go
@@ -297,9 +297,12 @@ func TestManual(t *testing.T) {
 
 // TODO(gri) go/types has extra TestLongConstants and TestIndexRepresentability tests
 
-func TestCheck(t *testing.T)     { DefPredeclaredTestFuncs(); testDirFiles(t, "testdata/check", 55, false) } // TODO(gri) narrow column tolerance
+func TestCheck(t *testing.T) {
+	DefPredeclaredTestFuncs()
+	testDirFiles(t, "../../../../go/types/testdata/check", 55, false) // TODO(gri) narrow column tolerance
+}
 func TestSpec(t *testing.T)      { testDirFiles(t, "../../../../go/types/testdata/spec", 0, false) }
-func TestExamples(t *testing.T)  { testDirFiles(t, "../../../../go/types/testdata/examples", 45, false) }
+func TestExamples(t *testing.T)  { testDirFiles(t, "../../../../go/types/testdata/examples", 45, false) } // TODO(gri) narrow column tolerance
 func TestFixedbugs(t *testing.T) { testDirFiles(t, "testdata/fixedbugs", 0, false) }
 
 func testDirFiles(t *testing.T, dir string, colDelta uint, manual bool) {
diff --git a/src/cmd/compile/internal/types2/testdata/check/blank.go b/src/cmd/compile/internal/types2/testdata/check/blank.go
deleted file mode 100644
index 6a2507f482..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/blank.go
+++ /dev/null
@@ -1,5 +0,0 @@
-// Copyright 2014 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package _ /* ERROR invalid package name */
diff --git a/src/cmd/compile/internal/types2/testdata/check/builtins0.go b/src/cmd/compile/internal/types2/testdata/check/builtins0.go
deleted file mode 100644
index f4932a8309..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/builtins0.go
+++ /dev/null
@@ -1,956 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// builtin calls
-
-package builtins
-
-import "unsafe"
-
-func f0() {}
-
-func append1() {
-	var b byte
-	var x int
-	var s []byte
-	_ = append() // ERROR not enough arguments
-	_ = append("foo" /* ERROR must be a slice */ )
-	_ = append(nil /* ERROR must be a slice */ , s)
-	_ = append(x /* ERROR must be a slice */ , s)
-	_ = append(s)
-	_ = append(s, nil...)
-	append /* ERROR not used */ (s)
-
-	_ = append(s, b)
-	_ = append(s, x /* ERROR cannot use x */ )
-	_ = append(s, s /* ERROR cannot use s */ )
-	_ = append(s...) /* ERROR not enough arguments */
-	_ = append(s, b, s /* ERROR too many arguments */ ...)
-	_ = append(s, 1, 2, 3)
-	_ = append(s, 1, 2, 3, x /* ERROR cannot use x */ , 5, 6, 6)
-	_ = append(s, 1, 2 /* ERROR too many arguments */, s...)
-	_ = append([]interface{}(nil), 1, 2, "foo", x, 3.1425, false)
-
-	type S []byte
-	type T string
-	var t T
-	_ = append(s, "foo" /* ERROR cannot use .* in argument to append */ )
-	_ = append(s, "foo"...)
-	_ = append(S(s), "foo" /* ERROR cannot use .* in argument to append */ )
-	_ = append(S(s), "foo"...)
-	_ = append(s, t /* ERROR cannot use t */ )
-	_ = append(s, t...)
-	_ = append(s, T("foo")...)
-	_ = append(S(s), t /* ERROR cannot use t */ )
-	_ = append(S(s), t...)
-	_ = append(S(s), T("foo")...)
-	_ = append([]string{}, t /* ERROR cannot use t */ , "foo")
-	_ = append([]T{}, t, "foo")
-}
-
-// from the spec
-func append2() {
-	s0 := []int{0, 0}
-	s1 := append(s0, 2)                // append a single element     s1 == []int{0, 0, 2}
-	s2 := append(s1, 3, 5, 7)          // append multiple elements    s2 == []int{0, 0, 2, 3, 5, 7}
-	s3 := append(s2, s0...)            // append a slice              s3 == []int{0, 0, 2, 3, 5, 7, 0, 0}
-	s4 := append(s3[3:6], s3[2:]...)   // append overlapping slice    s4 == []int{3, 5, 7, 2, 3, 5, 7, 0, 0}
-
-	var t []interface{}
-	t = append(t, 42, 3.1415, "foo")   //                             t == []interface{}{42, 3.1415, "foo"}
-
-	var b []byte
-	b = append(b, "bar"...)            // append string contents      b == []byte{'b', 'a', 'r' }
-
-	_ = s4
-}
-
-func append3() {
-	f1 := func() (s []int) { return }
-	f2 := func() (s []int, x int) { return }
-	f3 := func() (s []int, x, y int) { return }
-	f5 := func() (s []interface{}, x int, y float32, z string, b bool) { return }
-	ff := func() (int, float32) { return 0, 0 }
-	_ = append(f0 /* ERROR used as value */ ())
-	_ = append(f1())
-	_ = append(f2())
-	_ = append(f3())
-	_ = append(f5())
-	_ = append(ff /* ERROR must be a slice */ ()) // TODO(gri) better error message
-}
-
-func cap1() {
-	var a [10]bool
-	var p *[20]int
-	var c chan string
-	_ = cap() // ERROR not enough arguments
-	_ = cap(1, 2) // ERROR too many arguments
-	_ = cap(42 /* ERROR invalid */)
-	const _3 = cap(a)
-	assert(_3 == 10)
-	const _4 = cap(p)
-	assert(_4 == 20)
-	_ = cap(c)
-	cap /* ERROR not used */ (c)
-
-	// issue 4744
-	type T struct{ a [10]int }
-	const _ = cap(((*T)(nil)).a)
-
-	var s [][]byte
-	_ = cap(s)
-	_ = cap(s... /* ERROR invalid use of \.\.\. */ )
-}
-
-func cap2() {
-	f1a := func() (a [10]int) { return }
-	f1s := func() (s []int) { return }
-	f2 := func() (s []int, x int) { return }
-	_ = cap(f0 /* ERROR used as value */ ())
-	_ = cap(f1a())
-	_ = cap(f1s())
-	_ = cap(f2()) // ERROR too many arguments
-}
-
-// test cases for issue 7387
-func cap3() {
-	var f = func() int { return 0 }
-	var x = f()
-	const (
-		_ = cap([4]int{})
-		_ = cap([4]int{x})
-		_ = cap /* ERROR not constant */ ([4]int{f()})
-		_ = cap /* ERROR not constant */ ([4]int{cap([]int{})})
-		_ = cap([4]int{cap([4]int{})})
-	)
-	var y float64
-	var z complex128
-	const (
-		_ = cap([4]float64{})
-		_ = cap([4]float64{y})
-		_ = cap([4]float64{real(2i)})
-		_ = cap /* ERROR not constant */ ([4]float64{real(z)})
-	)
-	var ch chan [10]int
-	const (
-		_ = cap /* ERROR not constant */ (<-ch)
-		_ = cap /* ERROR not constant */ ([4]int{(<-ch)[0]})
-	)
-}
-
-func close1() {
-	var c chan int
-	var r <-chan int
-	close() // ERROR not enough arguments
-	close(1, 2) // ERROR too many arguments
-	close(42 /* ERROR cannot close non-channel */)
-	close(r /* ERROR receive-only channel */)
-	close(c)
-	_ = close /* ERROR used as value */ (c)
-
-	var s []chan int
-	close(s... /* ERROR invalid use of \.\.\. */ )
-}
-
-func close2() {
-	f1 := func() (ch chan int) { return }
-	f2 := func() (ch chan int, x int) { return }
-	close(f0 /* ERROR used as value */ ())
-	close(f1())
-	close(f2()) // ERROR too many arguments
-}
-
-func complex1() {
-	var i32 int32
-	var f32 float32
-	var f64 float64
-	var c64 complex64
-	var c128 complex128
-	_ = complex() // ERROR not enough arguments
-	_ = complex(1) // ERROR not enough arguments
-	_ = complex(true /* ERROR mismatched types */ , 0)
-	_ = complex(i32 /* ERROR expected floating-point */ , 0)
-	_ = complex("foo" /* ERROR mismatched types */ , 0)
-	_ = complex(c64 /* ERROR expected floating-point */ , 0)
-	_ = complex(0 /* ERROR mismatched types */ , true)
-	_ = complex(0 /* ERROR expected floating-point */ , i32)
-	_ = complex(0 /* ERROR mismatched types */ , "foo")
-	_ = complex(0 /* ERROR expected floating-point */ , c64)
-	_ = complex(f32, f32)
-	_ = complex(f32, 1)
-	_ = complex(f32, 1.0)
-	_ = complex(f32, 'a')
-	_ = complex(f64, f64)
-	_ = complex(f64, 1)
-	_ = complex(f64, 1.0)
-	_ = complex(f64, 'a')
-	_ = complex(f32 /* ERROR mismatched types */ , f64)
-	_ = complex(f64 /* ERROR mismatched types */ , f32)
-	_ = complex(1, 1)
-	_ = complex(1, 1.1)
-	_ = complex(1, 'a')
-	complex /* ERROR not used */ (1, 2)
-
-	var _ complex64 = complex(f32, f32)
-	var _ complex64 = complex /* ERROR cannot use .* in variable declaration */ (f64, f64)
-
-	var _ complex128 = complex /* ERROR cannot use .* in variable declaration */ (f32, f32)
-	var _ complex128 = complex(f64, f64)
-
-	// untyped constants
-	const _ int = complex(1, 0)
-	const _ float32 = complex(1, 0)
-	const _ complex64 = complex(1, 0)
-	const _ complex128 = complex(1, 0)
-	const _ = complex(0i, 0i)
-	const _ = complex(0i, 0)
-	const _ int = 1.0 + complex(1, 0i)
-
-	const _ int = complex /* ERROR int */ (1.1, 0)
-	const _ float32 = complex /* ERROR float32 */ (1, 2)
-
-	// untyped values
-	var s uint
-	_ = complex(1 /* ERROR integer */ <<s, 0)
-	const _ = complex /* ERROR not constant */ (1 /* ERROR integer */ <<s, 0)
-	var _ int = complex /* ERROR cannot use .* in variable declaration */ (1 /* ERROR integer */ <<s, 0)
-
-	// floating-point argument types must be identical
-	type F32 float32
-	type F64 float64
-	var x32 F32
-	var x64 F64
-	c64 = complex(x32, x32)
-	_ = complex(x32 /* ERROR mismatched types */ , f32)
-	_ = complex(f32 /* ERROR mismatched types */ , x32)
-	c128 = complex(x64, x64)
-	_ = c128
-	_ = complex(x64 /* ERROR mismatched types */ , f64)
-	_ = complex(f64 /* ERROR mismatched types */ , x64)
-
-	var t []float32
-	_ = complex(t... /* ERROR invalid use of \.\.\. */ )
-}
-
-func complex2() {
-	f1 := func() (x float32) { return }
-	f2 := func() (x, y float32) { return }
-	f3 := func() (x, y, z float32) { return }
-	_ = complex(f0 /* ERROR used as value */ ())
-	_ = complex(f1()) // ERROR not enough arguments
-	_ = complex(f2())
-	_ = complex(f3()) // ERROR too many arguments
-}
-
-func copy1() {
-	copy() // ERROR not enough arguments
-	copy("foo") // ERROR not enough arguments
-	copy([ /* ERROR copy expects slice arguments */ ...]int{}, []int{})
-	copy([ /* ERROR copy expects slice arguments */ ]int{}, [...]int{})
-	copy([ /* ERROR different element types */ ]int8{}, "foo")
-
-	// spec examples
-	var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
-	var s = make([]int, 6)
-	var b = make([]byte, 5)
-	n1 := copy(s, a[0:])            // n1 == 6, s == []int{0, 1, 2, 3, 4, 5}
-	n2 := copy(s, s[2:])            // n2 == 4, s == []int{2, 3, 4, 5, 4, 5}
-	n3 := copy(b, "Hello, World!")  // n3 == 5, b == []byte("Hello")
-	_, _, _ = n1, n2, n3
-
-	var t [][]int
-	copy(t, t)
-	copy(t /* ERROR copy expects slice arguments */ , nil)
-	copy(nil /* ERROR copy expects slice arguments */ , t)
-	copy(nil /* ERROR copy expects slice arguments */ , nil)
-	copy(t... /* ERROR invalid use of \.\.\. */ )
-}
-
-func copy2() {
-	f1 := func() (a []int) { return }
-	f2 := func() (a, b []int) { return }
-	f3 := func() (a, b, c []int) { return }
-	copy(f0 /* ERROR used as value */ ())
-	copy(f1()) // ERROR not enough arguments
-	copy(f2())
-	copy(f3()) // ERROR too many arguments
-}
-
-func delete1() {
-	var m map[string]int
-	var s string
-	delete() // ERROR not enough arguments
-	delete(1) // ERROR not enough arguments
-	delete(1, 2, 3) // ERROR too many arguments
-	delete(m, 0 /* ERROR cannot use */)
-	delete(m, s)
-	_ = delete /* ERROR used as value */ (m, s)
-
-	var t []map[string]string
-	delete(t... /* ERROR invalid use of \.\.\. */ )
-}
-
-func delete2() {
-	f1 := func() (m map[string]int) { return }
-	f2 := func() (m map[string]int, k string) { return }
-	f3 := func() (m map[string]int, k string, x float32) { return }
-	delete(f0 /* ERROR used as value */ ())
-	delete(f1()) // ERROR not enough arguments
-	delete(f2())
-	delete(f3()) // ERROR too many arguments
-}
-
-func imag1() {
-	var f32 float32
-	var f64 float64
-	var c64 complex64
-	var c128 complex128
-	_ = imag() // ERROR not enough arguments
-	_ = imag(1, 2) // ERROR too many arguments
-	_ = imag(10)
-	_ = imag(2.7182818)
-	_ = imag("foo" /* ERROR expected complex */)
-	_ = imag('a')
-	const _5 = imag(1 + 2i)
-	assert(_5 == 2)
-	f32 = _5
-	f64 = _5
-	const _6 = imag(0i)
-	assert(_6 == 0)
-	f32 = imag(c64)
-	f64 = imag(c128)
-	f32 = imag /* ERROR cannot use .* in assignment */ (c128)
-	f64 = imag /* ERROR cannot use .* in assignment */ (c64)
-	imag /* ERROR not used */ (c64)
-	_, _ = f32, f64
-
-	// complex type may not be predeclared
-	type C64 complex64
-	type C128 complex128
-	var x64 C64
-	var x128 C128
-	f32 = imag(x64)
-	f64 = imag(x128)
-
-	var a []complex64
-	_ = imag(a... /* ERROR invalid use of \.\.\. */ )
-
-	// if argument is untyped, result is untyped
-	const _ byte = imag(1.2 + 3i)
-	const _ complex128 = imag(1.2 + 3i)
-
-	// lhs constant shift operands are typed as complex128
-	var s uint
-	_ = imag(1 /* ERROR must be integer */ << s)
-}
-
-func imag2() {
-	f1 := func() (x complex128) { return }
-	f2 := func() (x, y complex128) { return }
-	_ = imag(f0 /* ERROR used as value */ ())
-	_ = imag(f1())
-	_ = imag(f2()) // ERROR too many arguments
-}
-
-func len1() {
-	const c = "foobar"
-	var a [10]bool
-	var p *[20]int
-	var m map[string]complex128
-	_ = len() // ERROR not enough arguments
-	_ = len(1, 2) // ERROR too many arguments
-	_ = len(42 /* ERROR invalid */)
-	const _3 = len(c)
-	assert(_3 == 6)
-	const _4 = len(a)
-	assert(_4 == 10)
-	const _5 = len(p)
-	assert(_5 == 20)
-	_ = len(m)
-	len /* ERROR not used */ (c)
-
-	// esoteric case
-	var t string
-	var hash map[interface{}][]*[10]int
-	const n = len /* ERROR not constant */ (hash[recover()][len(t)])
-	assert(n == 10) // ok because n has unknown value and no error is reported
-	var ch <-chan int
-	const nn = len /* ERROR not constant */ (hash[<-ch][len(t)])
-
-	// issue 4744
-	type T struct{ a [10]int }
-	const _ = len(((*T)(nil)).a)
-
-	var s [][]byte
-	_ = len(s)
-	_ = len(s... /* ERROR invalid use of \.\.\. */ )
-}
-
-func len2() {
-	f1 := func() (x []int) { return }
-	f2 := func() (x, y []int) { return }
-	_ = len(f0 /* ERROR used as value */ ())
-	_ = len(f1())
-	_ = len(f2()) // ERROR too many arguments
-}
-
-// test cases for issue 7387
-func len3() {
-	var f = func() int { return 0 }
-	var x = f()
-	const (
-		_ = len([4]int{})
-		_ = len([4]int{x})
-		_ = len /* ERROR not constant */ ([4]int{f()})
-		_ = len /* ERROR not constant */ ([4]int{len([]int{})})
-		_ = len([4]int{len([4]int{})})
-	)
-	var y float64
-	var z complex128
-	const (
-		_ = len([4]float64{})
-		_ = len([4]float64{y})
-		_ = len([4]float64{real(2i)})
-		_ = len /* ERROR not constant */ ([4]float64{real(z)})
-	)
-	var ch chan [10]int
-	const (
-		_ = len /* ERROR not constant */ (<-ch)
-		_ = len /* ERROR not constant */ ([4]int{(<-ch)[0]})
-	)
-}
-
-func make1() {
-	var n int
-	var m float32
-	var s uint
-
-	_ = make() // ERROR not enough arguments
-	_ = make(1 /* ERROR not a type */)
-	_ = make(int /* ERROR cannot make */)
-
-	// slices
-	_ = make/* ERROR arguments */ ([]int)
-	_ = make/* ERROR arguments */ ([]int, 2, 3, 4)
-	_ = make([]int, int /* ERROR not an expression */)
-	_ = make([]int, 10, float32 /* ERROR not an expression */)
-	_ = make([]int, "foo" /* ERROR cannot convert */)
-	_ = make([]int, 10, 2.3 /* ERROR truncated */)
-	_ = make([]int, 5, 10.0)
-	_ = make([]int, 0i)
-	_ = make([]int, 1.0)
-	_ = make([]int, 1.0<<s)
-	_ = make([]int, 1.1 /* ERROR int */ <<s)
-	_ = make([]int, - /* ERROR must not be negative */ 1, 10)
-	_ = make([]int, 0, - /* ERROR must not be negative */ 1)
-	_ = make([]int, - /* ERROR must not be negative */ 1, - /* ERROR must not be negative */ 1)
-	_ = make([]int, 1 /* ERROR overflows */ <<100, 1 /* ERROR overflows */ <<100)
-	_ = make([]int, 10 /* ERROR length and capacity swapped */ , 9)
-	_ = make([]int, 1 /* ERROR overflows */ <<100, 12345)
-	_ = make([]int, m /* ERROR must be integer */ )
-        _ = &make /* ERROR cannot take address */ ([]int, 0)
-
-	// maps
-	_ = make /* ERROR arguments */ (map[int]string, 10, 20)
-	_ = make(map[int]float32, int /* ERROR not an expression */)
-	_ = make(map[int]float32, "foo" /* ERROR cannot convert */)
-	_ = make(map[int]float32, 10)
-	_ = make(map[int]float32, n)
-	_ = make(map[int]float32, int64(n))
-	_ = make(map[string]bool, 10.0)
-	_ = make(map[string]bool, 10.0<<s)
-        _ = &make /* ERROR cannot take address */ (map[string]bool)
-
-	// channels
-	_ = make /* ERROR arguments */ (chan int, 10, 20)
-	_ = make(chan int, int /* ERROR not an expression */)
-	_ = make(chan<- int, "foo" /* ERROR cannot convert */)
-	_ = make(chan int, - /* ERROR must not be negative */ 10)
-	_ = make(<-chan float64, 10)
-	_ = make(chan chan int, n)
-	_ = make(chan string, int64(n))
-	_ = make(chan bool, 10.0)
-	_ = make(chan bool, 10.0<<s)
-        _ = &make /* ERROR cannot take address */ (chan bool)
-
-	make /* ERROR not used */ ([]int, 10)
-
-	var t []int
-	_ = make([]int, t[0], t[1])
-	_ = make([]int, t... /* ERROR invalid use of \.\.\. */ )
-}
-
-func make2() {
-	f1 := func() (x []int) { return }
-	_ = make(f0 /* ERROR not a type */ ())
-	_ = make(f1 /* ERROR not a type */ ())
-}
-
-func new1() {
-	_ = new() // ERROR not enough arguments
-	_ = new(1, 2) // ERROR too many arguments
-	_ = new("foo" /* ERROR not a type */)
-	p := new(float64)
-	_ = new(struct{ x, y int })
-	q := new(*float64)
-	_ = *p == **q
-	new /* ERROR not used */ (int)
-        _ = &new /* ERROR cannot take address */ (int)
-
-	_ = new(int... /* ERROR invalid use of \.\.\. */ )
-}
-
-func new2() {
-	f1 := func() (x []int) { return }
-	_ = new(f0 /* ERROR not a type */ ())
-	_ = new(f1 /* ERROR not a type */ ())
-}
-
-func panic1() {
-	panic() // ERROR not enough arguments
-	panic(1, 2) // ERROR too many arguments
-	panic(0)
-	panic("foo")
-	panic(false)
-	panic(1<<10)
-	panic(1 << /* ERROR constant shift overflow */ 1000)
-	_ = panic /* ERROR used as value */ (0)
-
-	var s []byte
-	panic(s)
-	panic(s... /* ERROR invalid use of \.\.\. */ )
-}
-
-func panic2() {
-	f1 := func() (x int) { return }
-	f2 := func() (x, y int) { return }
-	panic(f0 /* ERROR used as value */ ())
-	panic(f1())
-	panic(f2()) // ERROR too many arguments
-}
-
-func print1() {
-	print()
-	print(1)
-	print(1, 2)
-	print("foo")
-	print(2.718281828)
-	print(false)
-	print(1<<10)
-	print(1 << /* ERROR constant shift overflow */ 1000)
-	println(nil /* ERROR untyped nil */ )
-
-	var s []int
-	print(s... /* ERROR invalid use of \.\.\. */ )
-	_ = print /* ERROR used as value */ ()
-}
-
-func print2() {
-	f1 := func() (x int) { return }
-	f2 := func() (x, y int) { return }
-	f3 := func() (x int, y float32, z string) { return }
-	print(f0 /* ERROR used as value */ ())
-	print(f1())
-	print(f2())
-	print(f3())
-}
-
-func println1() {
-	println()
-	println(1)
-	println(1, 2)
-	println("foo")
-	println(2.718281828)
-	println(false)
-	println(1<<10)
-	println(1 << /* ERROR constant shift overflow */ 1000)
-	println(nil /* ERROR untyped nil */ )
-
-	var s []int
-	println(s... /* ERROR invalid use of \.\.\. */ )
-	_ = println /* ERROR used as value */ ()
-}
-
-func println2() {
-	f1 := func() (x int) { return }
-	f2 := func() (x, y int) { return }
-	f3 := func() (x int, y float32, z string) { return }
-	println(f0 /* ERROR used as value */ ())
-	println(f1())
-	println(f2())
-	println(f3())
-}
-
-func real1() {
-	var f32 float32
-	var f64 float64
-	var c64 complex64
-	var c128 complex128
-	_ = real() // ERROR not enough arguments
-	_ = real(1, 2) // ERROR too many arguments
-	_ = real(10)
-	_ = real(2.7182818)
-	_ = real("foo" /* ERROR expected complex */)
-	const _5 = real(1 + 2i)
-	assert(_5 == 1)
-	f32 = _5
-	f64 = _5
-	const _6 = real(0i)
-	assert(_6 == 0)
-	f32 = real(c64)
-	f64 = real(c128)
-	f32 = real /* ERROR cannot use .* in assignment */ (c128)
-	f64 = real /* ERROR cannot use .* in assignment */ (c64)
-	real /* ERROR not used */ (c64)
-
-	// complex type may not be predeclared
-	type C64 complex64
-	type C128 complex128
-	var x64 C64
-	var x128 C128
-	f32 = imag(x64)
-	f64 = imag(x128)
-	_, _ = f32, f64
-
-	var a []complex64
-	_ = real(a... /* ERROR invalid use of \.\.\. */ )
-
-	// if argument is untyped, result is untyped
-	const _ byte = real(1 + 2.3i)
-	const _ complex128 = real(1 + 2.3i)
-
-	// lhs constant shift operands are typed as complex128
-	var s uint
-	_ = real(1 /* ERROR must be integer */ << s)
-}
-
-func real2() {
-	f1 := func() (x complex128) { return }
-	f2 := func() (x, y complex128) { return }
-	_ = real(f0 /* ERROR used as value */ ())
-	_ = real(f1())
-	_ = real(f2()) // ERROR too many arguments
-}
-
-func recover1() {
-	_ = recover()
-	_ = recover(10) // ERROR too many arguments
-	recover()
-
-	var s []int
-	recover(s... /* ERROR invalid use of \.\.\. */ )
-}
-
-func recover2() {
-	f1 := func() (x int) { return }
-	f2 := func() (x, y int) { return }
-	_ = recover(f0 /* ERROR used as value */ ())
-	_ = recover(f1()) // ERROR too many arguments
-	_ = recover(f2()) // ERROR too many arguments
-}
-
-// assuming types.DefaultPtrSize == 8
-type S0 struct{      // offset
-	a bool       //  0
-	b rune       //  4
-	c *int       //  8
-	d bool       // 16
-	e complex128 // 24
-}                    // 40
-
-type S1 struct{   // offset
-	x float32 //  0
-	y string  //  8
-	z *S1     // 24
-	S0        // 32
-}                 // 72
-
-type S2 struct{ // offset
-	*S1     //  0
-}               //  8
-
-type S3 struct { // offset
-	a int64  //  0
-	b int32  //  8
-}                // 12
-
-type S4 struct { // offset
-	S3       //  0
-	int32    // 12
-}                // 16
-
-type S5 struct {   // offset
-	a [3]int32 //  0
-	b int32    // 12
-}                  // 16
-
-func (S2) m() {}
-
-func Alignof1() {
-	var x int
-	_ = unsafe.Alignof() // ERROR not enough arguments
-	_ = unsafe.Alignof(1, 2) // ERROR too many arguments
-	_ = unsafe.Alignof(int /* ERROR not an expression */)
-	_ = unsafe.Alignof(42)
-	_ = unsafe.Alignof(new(struct{}))
-	_ = unsafe.Alignof(1<<10)
-	_ = unsafe.Alignof(1 << /* ERROR constant shift overflow */ 1000)
-	_ = unsafe.Alignof(nil /* ERROR "untyped nil */ )
-	unsafe /* ERROR not used */ .Alignof(x)
-
-	var y S0
-	assert(unsafe.Alignof(y.a) == 1)
-	assert(unsafe.Alignof(y.b) == 4)
-	assert(unsafe.Alignof(y.c) == 8)
-	assert(unsafe.Alignof(y.d) == 1)
-	assert(unsafe.Alignof(y.e) == 8)
-
-	var s []byte
-	_ = unsafe.Alignof(s)
-	_ = unsafe.Alignof(s... /* ERROR invalid use of \.\.\. */ )
-}
-
-func Alignof2() {
-	f1 := func() (x int32) { return }
-	f2 := func() (x, y int32) { return }
-	_ = unsafe.Alignof(f0 /* ERROR used as value */ ())
-	assert(unsafe.Alignof(f1()) == 4)
-	_ = unsafe.Alignof(f2()) // ERROR too many arguments
-}
-
-func Offsetof1() {
-	var x struct{ f int }
-	_ = unsafe.Offsetof() // ERROR not enough arguments
-	_ = unsafe.Offsetof(1, 2) // ERROR too many arguments
-	_ = unsafe.Offsetof(int /* ERROR not a selector expression */ )
-	_ = unsafe.Offsetof(x /* ERROR not a selector expression */ )
-	_ = unsafe.Offsetof(nil /* ERROR not a selector expression */ )
-	_ = unsafe.Offsetof(x.f)
-	_ = unsafe.Offsetof((x.f))
-	_ = unsafe.Offsetof((((((((x))).f)))))
-	unsafe /* ERROR not used */ .Offsetof(x.f)
-
-	var y0 S0
-	assert(unsafe.Offsetof(y0.a) == 0)
-	assert(unsafe.Offsetof(y0.b) == 4)
-	assert(unsafe.Offsetof(y0.c) == 8)
-	assert(unsafe.Offsetof(y0.d) == 16)
-	assert(unsafe.Offsetof(y0.e) == 24)
-
-	var y1 S1
-	assert(unsafe.Offsetof(y1.x) == 0)
-	assert(unsafe.Offsetof(y1.y) == 8)
-	assert(unsafe.Offsetof(y1.z) == 24)
-	assert(unsafe.Offsetof(y1.S0) == 32)
-
-	assert(unsafe.Offsetof(y1.S0.a) == 0) // relative to S0
-	assert(unsafe.Offsetof(y1.a) == 32)   // relative to S1
-	assert(unsafe.Offsetof(y1.b) == 36)   // relative to S1
-	assert(unsafe.Offsetof(y1.c) == 40)   // relative to S1
-	assert(unsafe.Offsetof(y1.d) == 48)   // relative to S1
-	assert(unsafe.Offsetof(y1.e) == 56)   // relative to S1
-
-	var y1p *S1
-	assert(unsafe.Offsetof(y1p.S0) == 32)
-
-	type P *S1
-	var p P = y1p
-	assert(unsafe.Offsetof(p.S0) == 32)
-
-	var y2 S2
-	assert(unsafe.Offsetof(y2.S1) == 0)
-	_ = unsafe.Offsetof(y2 /* ERROR embedded via a pointer */ .x)
-	_ = unsafe.Offsetof(y2 /* ERROR method value */ .m)
-
-	var s []byte
-	_ = unsafe.Offsetof(s... /* ERROR invalid use of \.\.\. */ )
-}
-
-func Offsetof2() {
-	f1 := func() (x int32) { return }
-	f2 := func() (x, y int32) { return }
-	_ = unsafe.Offsetof(f0 /* ERROR not a selector expression */ ())
-	_ = unsafe.Offsetof(f1 /* ERROR not a selector expression */ ())
-	_ = unsafe.Offsetof(f2 /* ERROR not a selector expression */ ())
-}
-
-func Sizeof1() {
-	var x int
-	_ = unsafe.Sizeof() // ERROR not enough arguments
-	_ = unsafe.Sizeof(1, 2) // ERROR too many arguments
-	_ = unsafe.Sizeof(int /* ERROR not an expression */)
-	_ = unsafe.Sizeof(42)
-	_ = unsafe.Sizeof(new(complex128))
-	_ = unsafe.Sizeof(1<<10)
-	_ = unsafe.Sizeof(1 << /* ERROR constant shift overflow */ 1000)
-	_ = unsafe.Sizeof(nil /* ERROR untyped nil */ )
-	unsafe /* ERROR not used */ .Sizeof(x)
-
-	// basic types have size guarantees
-	assert(unsafe.Sizeof(byte(0)) == 1)
-	assert(unsafe.Sizeof(uint8(0)) == 1)
-	assert(unsafe.Sizeof(int8(0)) == 1)
-	assert(unsafe.Sizeof(uint16(0)) == 2)
-	assert(unsafe.Sizeof(int16(0)) == 2)
-	assert(unsafe.Sizeof(uint32(0)) == 4)
-	assert(unsafe.Sizeof(int32(0)) == 4)
-	assert(unsafe.Sizeof(float32(0)) == 4)
-	assert(unsafe.Sizeof(uint64(0)) == 8)
-	assert(unsafe.Sizeof(int64(0)) == 8)
-	assert(unsafe.Sizeof(float64(0)) == 8)
-	assert(unsafe.Sizeof(complex64(0)) == 8)
-	assert(unsafe.Sizeof(complex128(0)) == 16)
-
-	var y0 S0
-	assert(unsafe.Sizeof(y0.a) == 1)
-	assert(unsafe.Sizeof(y0.b) == 4)
-	assert(unsafe.Sizeof(y0.c) == 8)
-	assert(unsafe.Sizeof(y0.d) == 1)
-	assert(unsafe.Sizeof(y0.e) == 16)
-	assert(unsafe.Sizeof(y0) == 40)
-
-	var y1 S1
-	assert(unsafe.Sizeof(y1) == 72)
-
-	var y2 S2
-	assert(unsafe.Sizeof(y2) == 8)
-
-	var y3 S3
-	assert(unsafe.Sizeof(y3) == 12)
-
-	var y4 S4
-	assert(unsafe.Sizeof(y4) == 16)
-
-	var y5 S5
-	assert(unsafe.Sizeof(y5) == 16)
-
-	var a3 [10]S3
-	assert(unsafe.Sizeof(a3) == 156)
-
-	// test case for issue 5670
-	type T struct {
-		a int32
-		_ int32
-		c int32
-	}
-	assert(unsafe.Sizeof(T{}) == 12)
-
-	var s []byte
-	_ = unsafe.Sizeof(s)
-	_ = unsafe.Sizeof(s... /* ERROR invalid use of \.\.\. */ )
-}
-
-func Sizeof2() {
-	f1 := func() (x int64) { return }
-	f2 := func() (x, y int64) { return }
-	_ = unsafe.Sizeof(f0 /* ERROR used as value */ ())
-	assert(unsafe.Sizeof(f1()) == 8)
-	_ = unsafe.Sizeof(f2()) // ERROR too many arguments
-}
-
-func Slice1() {
-	var x int
-	unsafe.Slice()        // ERROR not enough arguments
-	unsafe.Slice(1, 2, 3) // ERROR too many arguments
-	unsafe.Slice(1 /* ERROR is not a pointer */ , 2)
-	unsafe.Slice(nil /* ERROR nil is not a pointer */ , 0)
-	unsafe.Slice(&x, "foo" /* ERROR cannot convert .* to int */ )
-	unsafe.Slice(&x, 1.2 /* ERROR truncated to int */ )
-	unsafe.Slice(&x, - /* ERROR must not be negative */ 1)
-	unsafe /* ERROR not used */ .Slice(&x, 0)
-	var _ []byte = unsafe /* ERROR value of type \[\]int */ .Slice(&x, 0)
-
-	var _ []int = unsafe.Slice(&x, 0)
-	_ = unsafe.Slice(&x, 1.0)
-	_ = unsafe.Slice((*int)(nil), 0)
-}
-
-func SliceData1() {
-	var s []int
-	unsafe.SliceData(0 /* ERROR not a slice */)
-	unsafe /* ERROR not used */ .SliceData(s)
-
-	type S []int
-	_ = unsafe.SliceData(s)
-	_ = unsafe.SliceData(S{})
-}
-
-func String1() {
-	var b byte
-	unsafe.String()        // ERROR not enough arguments
-	unsafe.String(1, 2, 3) // ERROR too many arguments
-	unsafe.String(1 /* ERROR cannot use 1 */ , 2)
-	unsafe.String(&b, "foo" /* ERROR cannot convert .* to int */ )
-	unsafe.String(&b, 1.2 /* ERROR truncated to int */ )
-	unsafe.String(&b, - /* ERROR must not be negative */ 1)
-	unsafe /* ERROR not used */ .String(&b, 0)
-	var _ []byte = unsafe /* ERROR value of type string */ .String(&b, 0)
-
-	var _ string = unsafe.String(&b, 0)
-	_ = unsafe.String(&b, 1.0)
-	_ = unsafe.String(nil, 0) // here we allow nil as ptr argument (in contrast to unsafe.Slice)
-}
-
-func StringData1() {
-	var s string
-	type S string
-	unsafe.StringData(0 /* ERROR cannot use 0 */)
-	unsafe.StringData(S /* ERROR cannot use S */ ("foo"))
-	unsafe /* ERROR not used */ .StringData(s)
-
-	_ = unsafe.StringData(s)
-	_ = unsafe.StringData("foo")
-}
-
-// self-testing only
-func assert1() {
-	var x int
-	assert() /* ERROR not enough arguments */
-	assert(1, 2) /* ERROR too many arguments */
-	assert("foo" /* ERROR boolean constant */ )
-	assert(x /* ERROR boolean constant */)
-	assert(true)
-	assert /* ERROR failed */ (false)
-	_ = assert(true)
-
-	var s []byte
-	assert(s... /* ERROR invalid use of \.\.\. */ )
-}
-
-func assert2() {
-	f1 := func() (x bool) { return }
-	f2 := func() (x bool) { return }
-	assert(f0 /* ERROR used as value */ ())
-	assert(f1 /* ERROR boolean constant */ ())
-	assert(f2 /* ERROR boolean constant */ ())
-}
-
-// self-testing only
-func trace1() {
-	// Uncomment the code below to test trace - will produce console output
-	// _ = trace /* ERROR no value */ ()
-	// _ = trace(1)
-	// _ = trace(true, 1.2, '\'', "foo", 42i, "foo" <= "bar")
-
-	var s []byte
-	trace(s... /* ERROR invalid use of \.\.\. */ )
-}
-
-func trace2() {
-	f1 := func() (x int) { return }
-	f2 := func() (x int, y string) { return }
-	f3 := func() (x int, y string, z []int) { return }
-	_ = f1
-	_ = f2
-	_ = f3
-	// Uncomment the code below to test trace - will produce console output
-	// trace(f0())
-	// trace(f1())
-	// trace(f2())
-	// trace(f3())
-	// trace(f0(), 1)
-	// trace(f1(), 1, 2)
-	// trace(f2(), 1, 2, 3)
-	// trace(f3(), 1, 2, 3, 4)
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/builtins1.go b/src/cmd/compile/internal/types2/testdata/check/builtins1.go
deleted file mode 100644
index 861597399e..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/builtins1.go
+++ /dev/null
@@ -1,274 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// This file tests built-in calls on generic types.
-
-package builtins
-
-import "unsafe"
-
-// close
-
-type C0 interface{ int }
-type C1 interface{ chan int }
-type C2 interface{ chan int | <-chan int }
-type C3 interface{ chan int | chan float32 }
-type C4 interface{ chan int | chan<- int }
-type C5[T any] interface{ ~chan T | chan<- T }
-
-func _[T any](ch T) {
-	close(ch /* ERROR cannot close non-channel */)
-}
-
-func _[T C0](ch T) {
-	close(ch /* ERROR cannot close non-channel */)
-}
-
-func _[T C1](ch T) {
-	close(ch)
-}
-
-func _[T C2](ch T) {
-	close(ch /* ERROR cannot close receive-only channel */)
-}
-
-func _[T C3](ch T) {
-	close(ch)
-}
-
-func _[T C4](ch T) {
-	close(ch)
-}
-
-func _[T C5[X], X any](ch T) {
-	close(ch)
-}
-
-// copy
-
-func _[T any](x, y T) {
-	copy(x /* ERROR copy expects slice arguments */ , y)
-}
-
-func _[T ~[]byte](x, y T) {
-	copy(x, y)
-	copy(x, "foo")
-	copy("foo" /* ERROR expects slice arguments */ , y)
-
-	var x2 []byte
-	copy(x2, y) // element types are identical
-	copy(y, x2) // element types are identical
-
-	type myByte byte
-	var x3 []myByte
-	copy(x3 /* ERROR different element types */ , y)
-	copy(y /* ERROR different element types */ , x3)
-}
-
-func _[T ~[]E, E any](x T, y []E) {
-	copy(x, y)
-	copy(x /* ERROR different element types */ , "foo")
-}
-
-func _[T ~string](x []byte, y T) {
-	copy(x, y)
-	copy(y /* ERROR expects slice arguments */ , x)
-}
-
-func _[T ~[]byte|~string](x T, y []byte) {
-	copy(x /* ERROR expects slice arguments */ , y)
-	copy(y, x)
-}
-
-type L0 []int
-type L1 []int
-
-func _[T L0 | L1](x, y T) {
-	copy(x, y)
-}
-
-// delete
-
-type M0 interface{ int }
-type M1 interface{ map[string]int }
-type M2 interface { map[string]int | map[string]float64 }
-type M3 interface{ map[string]int | map[rune]int }
-type M4[K comparable, V any] interface{ map[K]V | map[rune]V }
-
-func _[T any](m T) {
-	delete(m /* ERROR not a map */, "foo")
-}
-
-func _[T M0](m T) {
-	delete(m /* ERROR not a map */, "foo")
-}
-
-func _[T M1](m T) {
-	delete(m, "foo")
-}
-
-func _[T M2](m T) {
-	delete(m, "foo")
-	delete(m, 0 /* ERROR cannot use .* as string */)
-}
-
-func _[T M3](m T) {
-	delete(m /* ERROR must have identical key types */, "foo")
-}
-
-func _[T M4[rune, V], V any](m T) {
-	delete(m, 'k')
-}
-
-func _[T M4[K, V], K comparable, V any](m T) {
-	delete(m /* ERROR must have identical key types */, "foo")
-}
-
-// make
-
-type myChan chan int
-
-func _[
-	S1 ~[]int,
-	S2 ~[]int | ~chan int,
-
-	M1 ~map[string]int,
-	M2 ~map[string]int | ~chan int,
-
-	C1 ~chan int,
-	C2 ~chan int | ~chan string,
-	C3 chan int | myChan, // single underlying type
-]() {
-	type S0 []int
-	_ = make([]int, 10)
-	_ = make(S0, 10)
-	_ = make(S1, 10)
-	_ = make() /* ERROR not enough arguments */
-	_ = make /* ERROR expects 2 or 3 arguments */ (S1)
-	_ = make(S1, 10, 20)
-	_ = make /* ERROR expects 2 or 3 arguments */ (S1, 10, 20, 30)
-	_ = make(S2 /* ERROR cannot make S2: no core type */ , 10)
-
-	type M0 map[string]int
-	_ = make(map[string]int)
-	_ = make(M0)
-	_ = make(M1)
-	_ = make(M1, 10)
-	_ = make/* ERROR expects 1 or 2 arguments */(M1, 10, 20)
-	_ = make(M2 /* ERROR cannot make M2: no core type */ )
-
-	type C0 chan int
-	_ = make(chan int)
-	_ = make(C0)
-	_ = make(C1)
-	_ = make(C1, 10)
-	_ = make/* ERROR expects 1 or 2 arguments */(C1, 10, 20)
-	_ = make(C2 /* ERROR cannot make C2: no core type */ )
-	_ = make(C3)
-}
-
-// unsafe.Alignof
-
-func _[T comparable]() {
-	var (
-		b int64
-		a [10]T
-		s struct{ f T }
-		p *T
-		l []T
-		f func(T)
-		i interface{ m() T }
-		c chan T
-		m map[T]T
-		t T
-	)
-
-	const bb = unsafe.Alignof(b)
-	assert(bb == 8)
-	const _ = unsafe /* ERROR not constant */ .Alignof(a)
-	const _ = unsafe /* ERROR not constant */ .Alignof(s)
-	const pp = unsafe.Alignof(p)
-	assert(pp == 8)
-	const ll = unsafe.Alignof(l)
-	assert(ll == 8)
-	const ff = unsafe.Alignof(f)
-	assert(ff == 8)
-	const ii = unsafe.Alignof(i)
-	assert(ii == 8)
-	const cc = unsafe.Alignof(c)
-	assert(cc == 8)
-	const mm = unsafe.Alignof(m)
-	assert(mm == 8)
-	const _ = unsafe /* ERROR not constant */ .Alignof(t)
-}
-
-// unsafe.Offsetof
-
-func _[T comparable]() {
-	var (
-		b struct{ _, f int64 }
-		a struct{ _, f [10]T }
-		s struct{ _, f struct{ f T } }
-		p struct{ _, f *T }
-		l struct{ _, f []T }
-		f struct{ _, f func(T) }
-		i struct{ _, f interface{ m() T } }
-		c struct{ _, f chan T }
-		m struct{ _, f map[T]T }
-		t struct{ _, f T }
-	)
-
-	const bb = unsafe.Offsetof(b.f)
-	assert(bb == 8)
-	const _ = unsafe /* ERROR not constant */ .Alignof(a)
-	const _ = unsafe /* ERROR not constant */ .Alignof(s)
-	const pp = unsafe.Offsetof(p.f)
-	assert(pp == 8)
-	const ll = unsafe.Offsetof(l.f)
-	assert(ll == 24)
-	const ff = unsafe.Offsetof(f.f)
-	assert(ff == 8)
-	const ii = unsafe.Offsetof(i.f)
-	assert(ii == 16)
-	const cc = unsafe.Offsetof(c.f)
-	assert(cc == 8)
-	const mm = unsafe.Offsetof(m.f)
-	assert(mm == 8)
-	const _ = unsafe /* ERROR not constant */ .Alignof(t)
-}
-
-// unsafe.Sizeof
-
-func _[T comparable]() {
-	var (
-		b int64
-		a [10]T
-		s struct{ f T }
-		p *T
-		l []T
-		f func(T)
-		i interface{ m() T }
-		c chan T
-		m map[T]T
-		t T
-	)
-
-	const bb = unsafe.Sizeof(b)
-	assert(bb == 8)
-	const _ = unsafe /* ERROR not constant */ .Alignof(a)
-	const _ = unsafe /* ERROR not constant */ .Alignof(s)
-	const pp = unsafe.Sizeof(p)
-	assert(pp == 8)
-	const ll = unsafe.Sizeof(l)
-	assert(ll == 24)
-	const ff = unsafe.Sizeof(f)
-	assert(ff == 8)
-	const ii = unsafe.Sizeof(i)
-	assert(ii == 16)
-	const cc = unsafe.Sizeof(c)
-	assert(cc == 8)
-	const mm = unsafe.Sizeof(m)
-	assert(mm == 8)
-	const _ = unsafe /* ERROR not constant */ .Alignof(t)
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/chans.go b/src/cmd/compile/internal/types2/testdata/check/chans.go
deleted file mode 100644
index fad2bcec9d..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/chans.go
+++ /dev/null
@@ -1,62 +0,0 @@
-package chans
-
-import "runtime"
-
-// Ranger returns a Sender and a Receiver. The Receiver provides a
-// Next method to retrieve values. The Sender provides a Send method
-// to send values and a Close method to stop sending values. The Next
-// method indicates when the Sender has been closed, and the Send
-// method indicates when the Receiver has been freed.
-//
-// This is a convenient way to exit a goroutine sending values when
-// the receiver stops reading them.
-func Ranger[T any]() (*Sender[T], *Receiver[T]) {
-	c := make(chan T)
-	d := make(chan bool)
-	s := &Sender[T]{values: c, done: d}
-	r := &Receiver[T]{values: c, done: d}
-	runtime.SetFinalizer(r, r.finalize)
-	return s, r
-}
-
-// A sender is used to send values to a Receiver.
-type Sender[T any] struct {
-	values chan<- T
-	done <-chan bool
-}
-
-// Send sends a value to the receiver. It returns whether any more
-// values may be sent; if it returns false the value was not sent.
-func (s *Sender[T]) Send(v T) bool {
-	select {
-	case s.values <- v:
-		return true
-	case <-s.done:
-		return false
-	}
-}
-
-// Close tells the receiver that no more values will arrive.
-// After Close is called, the Sender may no longer be used.
-func (s *Sender[T]) Close() {
-	close(s.values)
-}
-
-// A Receiver receives values from a Sender.
-type Receiver[T any] struct {
-	values <-chan T
-	done chan<- bool
-}
-
-// Next returns the next value from the channel. The bool result
-// indicates whether the value is valid, or whether the Sender has
-// been closed and no more values will be received.
-func (r *Receiver[T]) Next() (T, bool) {
-	v, ok := <-r.values
-	return v, ok
-}
-
-// finalize is a finalizer for the receiver.
-func (r *Receiver[T]) finalize() {
-	close(r.done)
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/compliterals.go b/src/cmd/compile/internal/types2/testdata/check/compliterals.go
deleted file mode 100644
index 60eac97a3f..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/compliterals.go
+++ /dev/null
@@ -1,22 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Composite literals with parameterized types
-
-package comp_literals
-
-type myStruct struct {
-	f int
-}
-
-type slice[E any] []E
-
-func struct_literals[S struct{f int}|myStruct]() {
-	_ = S{}
-	_ = S{0}
-	_ = S{f: 0}
-
-        _ = slice[int]{1, 2, 3}
-        _ = slice[S]{{}, {0}, {f:0}}
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/const0.go b/src/cmd/compile/internal/types2/testdata/check/const0.go
deleted file mode 100644
index 229c248643..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/const0.go
+++ /dev/null
@@ -1,382 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// constant declarations
-
-package const0
-
-import "unsafe"
-
-// constants declarations must be initialized by constants
-var x = 0
-const c0 = x /* ERROR "not constant" */
-
-// typed constants must have constant types
-const _ interface /* ERROR invalid constant type */ {} = 0
-
-func _ () {
-	const _ interface /* ERROR invalid constant type */ {} = 0
-	for i := 0; i < 10; i++ {} // don't crash with non-nil iota here
-}
-
-// untyped constants
-const (
-	// boolean values
-	ub0 = false
-	ub1 = true
-	ub2 = 2 < 1
-	ub3 = ui1 == uf1
-	ub4 = true /* ERROR "mismatched types untyped bool and untyped int" */ == 0
-
-	// integer values
-	ui0 = 0
-	ui1 = 1
-	ui2 = 42
-	ui3 = 3141592653589793238462643383279502884197169399375105820974944592307816406286
-	ui4 = -10
-
-	ui5 = ui0 + ui1
-	ui6 = ui1 - ui1
-	ui7 = ui2 * ui1
-	ui8 = ui3 / ui3
-	ui9 = ui3 % ui3
-
-	ui10 = 1 / 0 /* ERROR "division by zero" */
-	ui11 = ui1 / 0 /* ERROR "division by zero" */
-	ui12 = ui3 / ui0 /* ERROR "division by zero" */
-	ui13 = 1 % 0 /* ERROR "division by zero" */
-	ui14 = ui1 % 0 /* ERROR "division by zero" */
-	ui15 = ui3 % ui0 /* ERROR "division by zero" */
-
-	ui16 = ui2 & ui3
-	ui17 = ui2 | ui3
-	ui18 = ui2 ^ ui3
-	ui19 = 1 /* ERROR "invalid operation" */ % 1.0
-
-	// floating point values
-	uf0 = 0.
-	uf1 = 1.
-	uf2 = 4.2e1
-	uf3 = 3.141592653589793238462643383279502884197169399375105820974944592307816406286
-	uf4 = 1e-1
-
-	uf5 = uf0 + uf1
-	uf6 = uf1 - uf1
-	uf7 = uf2 * uf1
-	uf8 = uf3 / uf3
-	uf9 = uf3 /* ERROR "not defined" */ % uf3
-
-	uf10 = 1 / 0 /* ERROR "division by zero" */
-	uf11 = uf1 / 0 /* ERROR "division by zero" */
-	uf12 = uf3 / uf0 /* ERROR "division by zero" */
-
-	uf16 = uf2 /* ERROR "not defined" */ & uf3
-	uf17 = uf2 /* ERROR "not defined" */ | uf3
-	uf18 = uf2 /* ERROR "not defined" */ ^ uf3
-
-	// complex values
-	uc0 = 0.i
-	uc1 = 1.i
-	uc2 = 4.2e1i
-	uc3 = 3.141592653589793238462643383279502884197169399375105820974944592307816406286i
-	uc4 = 1e-1i
-
-	uc5 = uc0 + uc1
-	uc6 = uc1 - uc1
-	uc7 = uc2 * uc1
-	uc8 = uc3 / uc3
-	uc9 = uc3 /* ERROR "not defined" */ % uc3
-
-	uc10 = 1 / 0 /* ERROR "division by zero" */
-	uc11 = uc1 / 0 /* ERROR "division by zero" */
-	uc12 = uc3 / uc0 /* ERROR "division by zero" */
-
-	uc16 = uc2 /* ERROR "not defined" */ & uc3
-	uc17 = uc2 /* ERROR "not defined" */ | uc3
-	uc18 = uc2 /* ERROR "not defined" */ ^ uc3
-)
-
-type (
-	mybool bool
-	myint int
-	myfloat float64
-	mycomplex complex128
-)
-
-// typed constants
-const (
-	// boolean values
-	tb0 bool = false
-	tb1 bool = true
-	tb2 mybool = 2 < 1
-	tb3 mybool = ti1 /* ERROR "mismatched types" */ == tf1
-
-	// integer values
-	ti0 int8 = ui0
-	ti1 int32 = ui1
-	ti2 int64 = ui2
-	ti3 myint = ui3 /* ERROR "overflows" */
-	ti4 myint = ui4
-
-	ti5 = ti0 /* ERROR "mismatched types" */ + ti1
-	ti6 = ti1 - ti1
-	ti7 = ti2 /* ERROR "mismatched types" */ * ti1
-	ti8 = ti3 / ti3
-	ti9 = ti3 % ti3
-
-	ti10 = 1 / 0 /* ERROR "division by zero" */
-	ti11 = ti1 / 0 /* ERROR "division by zero" */
-	ti12 = ti3 /* ERROR "mismatched types" */ / ti0
-	ti13 = 1 % 0 /* ERROR "division by zero" */
-	ti14 = ti1 % 0 /* ERROR "division by zero" */
-	ti15 = ti3 /* ERROR "mismatched types" */ % ti0
-
-	ti16 = ti2 /* ERROR "mismatched types" */ & ti3
-	ti17 = ti2 /* ERROR "mismatched types" */ | ti4
-	ti18 = ti2 ^ ti5 // no mismatched types error because the type of ti5 is unknown
-
-	// floating point values
-	tf0 float32 = 0.
-	tf1 float32 = 1.
-	tf2 float64 = 4.2e1
-	tf3 myfloat = 3.141592653589793238462643383279502884197169399375105820974944592307816406286
-	tf4 myfloat = 1e-1
-
-	tf5 = tf0 + tf1
-	tf6 = tf1 - tf1
-	tf7 = tf2 /* ERROR "mismatched types" */ * tf1
-	tf8 = tf3 / tf3
-	tf9 = tf3 /* ERROR "not defined" */ % tf3
-
-	tf10 = 1 / 0 /* ERROR "division by zero" */
-	tf11 = tf1 / 0 /* ERROR "division by zero" */
-	tf12 = tf3 /* ERROR "mismatched types" */ / tf0
-
-	tf16 = tf2 /* ERROR "mismatched types" */ & tf3
-	tf17 = tf2 /* ERROR "mismatched types" */ | tf3
-	tf18 = tf2 /* ERROR "mismatched types" */ ^ tf3
-
-	// complex values
-	tc0 = 0.i
-	tc1 = 1.i
-	tc2 = 4.2e1i
-	tc3 = 3.141592653589793238462643383279502884197169399375105820974944592307816406286i
-	tc4 = 1e-1i
-
-	tc5 = tc0 + tc1
-	tc6 = tc1 - tc1
-	tc7 = tc2 * tc1
-	tc8 = tc3 / tc3
-	tc9 = tc3 /* ERROR "not defined" */ % tc3
-
-	tc10 = 1 / 0 /* ERROR "division by zero" */
-	tc11 = tc1 / 0 /* ERROR "division by zero" */
-	tc12 = tc3 / tc0 /* ERROR "division by zero" */
-
-	tc16 = tc2 /* ERROR "not defined" */ & tc3
-	tc17 = tc2 /* ERROR "not defined" */ | tc3
-	tc18 = tc2 /* ERROR "not defined" */ ^ tc3
-)
-
-// initialization cycles
-const (
-	a /* ERROR "initialization cycle" */ = a
-	b /* ERROR "initialization cycle" */ , c /* ERROR "initialization cycle" */, d, e = e, d, c, b // TODO(gri) should only have one cycle error
-	f float64 = d
-)
-
-// multiple initialization
-const (
-	a1, a2, a3 = 7, 3.1415926, "foo"
-	b1, b2, b3 = b3, b1, 42
-	c1, c2, c3  /* ERROR "missing init expr for c3" */ = 1, 2
-	d1, d2, d3 = 1, 2, 3, 4 /* ERROR "extra init expr 4" */
-	_p0 = assert(a1 == 7)
-	_p1 = assert(a2 == 3.1415926)
-	_p2 = assert(a3 == "foo")
-	_p3 = assert(b1 == 42)
-	_p4 = assert(b2 == 42)
-	_p5 = assert(b3 == 42)
-)
-
-func _() {
-	const (
-		a1, a2, a3 = 7, 3.1415926, "foo"
-		b1, b2, b3 = b3, b1, 42
-		c1, c2, c3  /* ERROR "missing init expr for c3" */ = 1, 2
-		d1, d2, d3 = 1, 2, 3, 4 /* ERROR "extra init expr 4" */
-		_p0 = assert(a1 == 7)
-		_p1 = assert(a2 == 3.1415926)
-		_p2 = assert(a3 == "foo")
-		_p3 = assert(b1 == 42)
-		_p4 = assert(b2 == 42)
-		_p5 = assert(b3 == 42)
-	)
-}
-
-// iota
-const (
-	iota0 = iota
-	iota1 = iota
-	iota2 = iota*2
-	_a0 = assert(iota0 == 0)
-	_a1 = assert(iota1 == 1)
-	_a2 = assert(iota2 == 4)
-	iota6 = iota*3
-
-	iota7
-	iota8
-	_a3 = assert(iota7 == 21)
-	_a4 = assert(iota8 == 24)
-)
-
-const (
-	_b0 = iota
-	_b1 = assert(iota + iota2 == 5)
-	_b2 = len([iota]int{}) // iota may appear in a type!
-	_b3 = assert(_b2 == 2)
-	_b4 = len(A{})
-)
-
-type A [iota /* ERROR "cannot use iota" */ ]int
-
-// constant expressions with operands across different
-// constant declarations must use the right iota values
-const (
-	_c0 = iota
-	_c1
-	_c2
-	_x = _c2 + _d1 + _e0 // 3
-)
-
-const (
-	_d0 = iota
-	_d1
-)
-
-const (
-	_e0 = iota
-)
-
-var _ = assert(_x == 3)
-
-// special cases
-const (
-	_n0 = nil /* ERROR "not constant" */
-	_n1 = [ /* ERROR "not constant" */ ]int{}
-)
-
-// iotas must not be usable in expressions outside constant declarations
-type _ [iota /* ERROR "iota outside constant decl" */ ]byte
-var _ = iota /* ERROR "iota outside constant decl" */
-func _() {
-	_ = iota /* ERROR "iota outside constant decl" */
-	const _ = iota
-	_ = iota /* ERROR "iota outside constant decl" */
-}
-
-func _() {
-	iota := 123
-	const x = iota /* ERROR "is not constant" */
-	var y = iota
-	_ = y
-}
-
-// iotas are usable inside closures in constant declarations (#22345)
-const (
-	_ = iota
-	_ = len([iota]byte{})
-	_ = unsafe.Sizeof(iota)
-	_ = unsafe.Sizeof(func() { _ = iota })
-	_ = unsafe.Sizeof(func() { var _ = iota })
-	_ = unsafe.Sizeof(func() { const _ = iota })
-	_ = unsafe.Sizeof(func() { type _ [iota]byte })
-	_ = unsafe.Sizeof(func() { func() int { return iota }() })
-)
-
-// verify inner and outer const declarations have distinct iotas
-const (
-	zero = iota
-	one  = iota
-	_    = unsafe.Sizeof(func() {
-		var x [iota]int // [2]int
-		const (
-			Zero = iota
-			One
-			Two
-			_ = unsafe.Sizeof([iota-1]int{} == x) // assert types are equal
-			_ = unsafe.Sizeof([Two]int{} == x)    // assert types are equal
-		)
-		var z [iota]int                           // [2]int
-		_ = unsafe.Sizeof([2]int{} == z)          // assert types are equal
-	})
-	three = iota // the sequence continues
-)
-var _ [three]int = [3]int{} // assert 'three' has correct value
-
-var (
-	_ = iota /* ERROR "iota outside constant decl" */
-	_ = unsafe.Sizeof(iota  /* ERROR "iota outside constant decl" */ )
-	_ = unsafe.Sizeof(func() { _ = iota /* ERROR "iota outside constant decl" */ })
-	_ = unsafe.Sizeof(func() { var _ = iota /* ERROR "iota outside constant decl" */ })
-	_ = unsafe.Sizeof(func() { type _ [iota /* ERROR "iota outside constant decl" */ ]byte })
-	_ = unsafe.Sizeof(func() { func() int { return iota /* ERROR "iota outside constant decl" */ }() })
-)
-
-// constant arithmetic precision and rounding must lead to expected (integer) results
-var _ = []int64{
-	0.0005 * 1e9,
-	0.001 * 1e9,
-	0.005 * 1e9,
-	0.01 * 1e9,
-	0.05 * 1e9,
-	0.1 * 1e9,
-	0.5 * 1e9,
-	1 * 1e9,
-	5 * 1e9,
-}
-
-const _ = unsafe.Sizeof(func() {
-	const _ = 0
-	_ = iota
-
-	const (
-	   zero = iota
-	   one
-	)
-	assert(one == 1)
-	assert(iota == 0)
-})
-
-// issue #52438
-const i1 = iota
-const i2 = iota
-const i3 = iota
-
-func _() {
-	assert(i1 == 0)
-	assert(i2 == 0)
-	assert(i3 == 0)
-
-	const i4 = iota
-	const i5 = iota
-	const i6 = iota
-
-	assert(i4 == 0)
-	assert(i5 == 0)
-	assert(i6 == 0)
-}
-
-// untyped constants must not get arbitrarily large
-const prec = 512 // internal maximum precision for integers
-const maxInt = (1<<(prec/2) - 1) * (1<<(prec/2) + 1) // == 1<<prec - 1
-
-const _ = maxInt + /* ERROR constant addition overflow */ 1
-const _ = -maxInt - /* ERROR constant subtraction overflow */ 1
-const _ = maxInt ^ /* ERROR constant bitwise XOR overflow */ -1
-const _ = maxInt * /* ERROR constant multiplication overflow */ 2
-const _ = maxInt << /* ERROR constant shift overflow */ 2
-const _ = 1 << /* ERROR constant shift overflow */ prec
-
-const _ = ^ /* ERROR constant bitwise complement overflow */ maxInt
diff --git a/src/cmd/compile/internal/types2/testdata/check/const1.go b/src/cmd/compile/internal/types2/testdata/check/const1.go
deleted file mode 100644
index c9128017cf..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/const1.go
+++ /dev/null
@@ -1,334 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// constant conversions
-
-package const1
-
-import "math"
-
-const(
-	mi = ^int(0)
-	mu = ^uint(0)
-	mp = ^uintptr(0)
-
-	logSizeofInt     = uint(mi>>8&1 + mi>>16&1 + mi>>32&1)
-	logSizeofUint    = uint(mu>>8&1 + mu>>16&1 + mu>>32&1)
-	logSizeofUintptr = uint(mp>>8&1 + mp>>16&1 + mp>>32&1)
-)
-
-const (
-	minInt8 = -1<<(8<<iota - 1)
-	minInt16
-	minInt32
-	minInt64
-	minInt = -1<<(8<<logSizeofInt - 1)
-)
-
-const (
-	maxInt8 = 1<<(8<<iota - 1) - 1
-	maxInt16
-	maxInt32
-	maxInt64
-	maxInt = 1<<(8<<logSizeofInt - 1) - 1
-)
-
-const (
-	maxUint8 = 1<<(8<<iota) - 1
-	maxUint16
-	maxUint32
-	maxUint64
-	maxUint    = 1<<(8<<logSizeofUint) - 1
-	maxUintptr = 1<<(8<<logSizeofUintptr) - 1
-)
-
-const (
-	smallestFloat32 = 1.0 / (1<<(127 - 1 + 23))
-	// TODO(gri) The compiler limits integers to 512 bit and thus
-	//           we cannot compute the value (1<<(1023 - 1 + 52))
-	//           without overflow. For now we match the compiler.
-	//           See also issue #44057.
-	// smallestFloat64 = 1.0 / (1<<(1023 - 1 + 52))
-	smallestFloat64 = math.SmallestNonzeroFloat64
-)
-
-const (
-	_ = assert(smallestFloat32 > 0)
-	_ = assert(smallestFloat64 > 0)
-)
-
-const (
-	maxFloat32 = 1<<127 * (1<<24 - 1) / (1.0<<23)
-	// TODO(gri) The compiler limits integers to 512 bit and thus
-	//           we cannot compute the value 1<<1023
-	//           without overflow. For now we match the compiler.
-	//           See also issue #44057.
-	// maxFloat64 = 1<<1023 * (1<<53 - 1) / (1.0<<52)
-	maxFloat64 = math.MaxFloat64
-)
-
-const (
-	_ int8 = minInt8 /* ERROR "overflows" */ - 1
-	_ int8 = minInt8
-	_ int8 = maxInt8
-	_ int8 = maxInt8 /* ERROR "overflows" */ + 1
-	_ int8 = smallestFloat64 /* ERROR "truncated" */
-
-	_ = int8(minInt8 /* ERROR "cannot convert" */ - 1)
-	_ = int8(minInt8)
-	_ = int8(maxInt8)
-	_ = int8(maxInt8 /* ERROR "cannot convert" */ + 1)
-	_ = int8(smallestFloat64 /* ERROR "cannot convert" */)
-)
-
-const (
-	_ int16 = minInt16 /* ERROR "overflows" */ - 1
-	_ int16 = minInt16
-	_ int16 = maxInt16
-	_ int16 = maxInt16 /* ERROR "overflows" */ + 1
-	_ int16 = smallestFloat64 /* ERROR "truncated" */
-
-	_ = int16(minInt16 /* ERROR "cannot convert" */ - 1)
-	_ = int16(minInt16)
-	_ = int16(maxInt16)
-	_ = int16(maxInt16 /* ERROR "cannot convert" */ + 1)
-	_ = int16(smallestFloat64 /* ERROR "cannot convert" */)
-)
-
-const (
-	_ int32 = minInt32 /* ERROR "overflows" */ - 1
-	_ int32 = minInt32
-	_ int32 = maxInt32
-	_ int32 = maxInt32 /* ERROR "overflows" */ + 1
-	_ int32 = smallestFloat64 /* ERROR "truncated" */
-
-	_ = int32(minInt32 /* ERROR "cannot convert" */ - 1)
-	_ = int32(minInt32)
-	_ = int32(maxInt32)
-	_ = int32(maxInt32 /* ERROR "cannot convert" */ + 1)
-	_ = int32(smallestFloat64 /* ERROR "cannot convert" */)
-)
-
-const (
-	_ int64 = minInt64 /* ERROR "overflows" */ - 1
-	_ int64 = minInt64
-	_ int64 = maxInt64
-	_ int64 = maxInt64 /* ERROR "overflows" */ + 1
-	_ int64 = smallestFloat64 /* ERROR "truncated" */
-
-	_ = int64(minInt64 /* ERROR "cannot convert" */ - 1)
-	_ = int64(minInt64)
-	_ = int64(maxInt64)
-	_ = int64(maxInt64 /* ERROR "cannot convert" */ + 1)
-	_ = int64(smallestFloat64 /* ERROR "cannot convert" */)
-)
-
-const (
-	_ int = minInt /* ERROR "overflows" */ - 1
-	_ int = minInt
-	_ int = maxInt
-	_ int = maxInt /* ERROR "overflows" */ + 1
-	_ int = smallestFloat64 /* ERROR "truncated" */
-
-	_ = int(minInt /* ERROR "cannot convert" */ - 1)
-	_ = int(minInt)
-	_ = int(maxInt)
-	_ = int(maxInt /* ERROR "cannot convert" */ + 1)
-	_ = int(smallestFloat64 /* ERROR "cannot convert" */)
-)
-
-const (
-	_ uint8 = 0 /* ERROR "overflows" */ - 1
-	_ uint8 = 0
-	_ uint8 = maxUint8
-	_ uint8 = maxUint8 /* ERROR "overflows" */ + 1
-	_ uint8 = smallestFloat64 /* ERROR "truncated" */
-
-	_ = uint8(0 /* ERROR "cannot convert" */ - 1)
-	_ = uint8(0)
-	_ = uint8(maxUint8)
-	_ = uint8(maxUint8 /* ERROR "cannot convert" */ + 1)
-	_ = uint8(smallestFloat64 /* ERROR "cannot convert" */)
-)
-
-const (
-	_ uint16 = 0 /* ERROR "overflows" */ - 1
-	_ uint16 = 0
-	_ uint16 = maxUint16
-	_ uint16 = maxUint16 /* ERROR "overflows" */ + 1
-	_ uint16 = smallestFloat64 /* ERROR "truncated" */
-
-	_ = uint16(0 /* ERROR "cannot convert" */ - 1)
-	_ = uint16(0)
-	_ = uint16(maxUint16)
-	_ = uint16(maxUint16 /* ERROR "cannot convert" */ + 1)
-	_ = uint16(smallestFloat64 /* ERROR "cannot convert" */)
-)
-
-const (
-	_ uint32 = 0 /* ERROR "overflows" */ - 1
-	_ uint32 = 0
-	_ uint32 = maxUint32
-	_ uint32 = maxUint32 /* ERROR "overflows" */ + 1
-	_ uint32 = smallestFloat64 /* ERROR "truncated" */
-
-	_ = uint32(0 /* ERROR "cannot convert" */ - 1)
-	_ = uint32(0)
-	_ = uint32(maxUint32)
-	_ = uint32(maxUint32 /* ERROR "cannot convert" */ + 1)
-	_ = uint32(smallestFloat64 /* ERROR "cannot convert" */)
-)
-
-const (
-	_ uint64 = 0 /* ERROR "overflows" */ - 1
-	_ uint64 = 0
-	_ uint64 = maxUint64
-	_ uint64 = maxUint64 /* ERROR "overflows" */ + 1
-	_ uint64 = smallestFloat64 /* ERROR "truncated" */
-
-	_ = uint64(0 /* ERROR "cannot convert" */ - 1)
-	_ = uint64(0)
-	_ = uint64(maxUint64)
-	_ = uint64(maxUint64 /* ERROR "cannot convert" */ + 1)
-	_ = uint64(smallestFloat64 /* ERROR "cannot convert" */)
-)
-
-const (
-	_ uint = 0 /* ERROR "overflows" */ - 1
-	_ uint = 0
-	_ uint = maxUint
-	_ uint = maxUint /* ERROR "overflows" */ + 1
-	_ uint = smallestFloat64 /* ERROR "truncated" */
-
-	_ = uint(0 /* ERROR "cannot convert" */ - 1)
-	_ = uint(0)
-	_ = uint(maxUint)
-	_ = uint(maxUint /* ERROR "cannot convert" */ + 1)
-	_ = uint(smallestFloat64 /* ERROR "cannot convert" */)
-)
-
-const (
-	_ uintptr = 0 /* ERROR "overflows" */ - 1
-	_ uintptr = 0
-	_ uintptr = maxUintptr
-	_ uintptr = maxUintptr /* ERROR "overflows" */ + 1
-	_ uintptr = smallestFloat64 /* ERROR "truncated" */
-
-	_ = uintptr(0 /* ERROR "cannot convert" */ - 1)
-	_ = uintptr(0)
-	_ = uintptr(maxUintptr)
-	_ = uintptr(maxUintptr /* ERROR "cannot convert" */ + 1)
-	_ = uintptr(smallestFloat64 /* ERROR "cannot convert" */)
-)
-
-const (
-	_ float32 = minInt64
-	_ float64 = minInt64
-	_ complex64 = minInt64
-	_ complex128 = minInt64
-
-	_ = float32(minInt64)
-	_ = float64(minInt64)
-	_ = complex64(minInt64)
-	_ = complex128(minInt64)
-)
-
-const (
-	_ float32 = maxUint64
-	_ float64 = maxUint64
-	_ complex64 = maxUint64
-	_ complex128 = maxUint64
-
-	_ = float32(maxUint64)
-	_ = float64(maxUint64)
-	_ = complex64(maxUint64)
-	_ = complex128(maxUint64)
-)
-
-// TODO(gri) find smaller deltas below
-
-const delta32 = maxFloat32/(1 << 23)
-
-const (
-	_ float32 = - /* ERROR "overflow" */ (maxFloat32 + delta32)
-	_ float32 = -maxFloat32
-	_ float32 = maxFloat32
-	_ float32 = maxFloat32 /* ERROR "overflow" */ + delta32
-
-	_ = float32(- /* ERROR "cannot convert" */ (maxFloat32 + delta32))
-	_ = float32(-maxFloat32)
-	_ = float32(maxFloat32)
-	_ = float32(maxFloat32 /* ERROR "cannot convert" */ + delta32)
-
-	_ = assert(float32(smallestFloat32) == smallestFloat32)
-	_ = assert(float32(smallestFloat32/2) == 0)
-	_ = assert(float32(smallestFloat64) == 0)
-	_ = assert(float32(smallestFloat64/2) == 0)
-)
-
-const delta64 = maxFloat64/(1 << 52)
-
-const (
-	_ float64 = - /* ERROR "overflow" */ (maxFloat64 + delta64)
-	_ float64 = -maxFloat64
-	_ float64 = maxFloat64
-	_ float64 = maxFloat64 /* ERROR "overflow" */ + delta64
-
-	_ = float64(- /* ERROR "cannot convert" */ (maxFloat64 + delta64))
-	_ = float64(-maxFloat64)
-	_ = float64(maxFloat64)
-	_ = float64(maxFloat64 /* ERROR "cannot convert" */ + delta64)
-
-	_ = assert(float64(smallestFloat32) == smallestFloat32)
-	_ = assert(float64(smallestFloat32/2) == smallestFloat32/2)
-	_ = assert(float64(smallestFloat64) == smallestFloat64)
-	_ = assert(float64(smallestFloat64/2) == 0)
-)
-
-const (
-	_ complex64 = - /* ERROR "overflow" */ (maxFloat32 + delta32)
-	_ complex64 = -maxFloat32
-	_ complex64 = maxFloat32
-	_ complex64 = maxFloat32 /* ERROR "overflow" */ + delta32
-
-	_ = complex64(- /* ERROR "cannot convert" */ (maxFloat32 + delta32))
-	_ = complex64(-maxFloat32)
-	_ = complex64(maxFloat32)
-	_ = complex64(maxFloat32 /* ERROR "cannot convert" */ + delta32)
-)
-
-const (
-	_ complex128 = - /* ERROR "overflow" */ (maxFloat64 + delta64)
-	_ complex128 = -maxFloat64
-	_ complex128 = maxFloat64
-	_ complex128 = maxFloat64 /* ERROR "overflow" */ + delta64
-
-	_ = complex128(- /* ERROR "cannot convert" */ (maxFloat64 + delta64))
-	_ = complex128(-maxFloat64)
-	_ = complex128(maxFloat64)
-	_ = complex128(maxFloat64 /* ERROR "cannot convert" */ + delta64)
-)
-
-// Initialization of typed constant and conversion are the same:
-const (
-	f32 = 1 + smallestFloat32
-	x32 float32 = f32
-	y32 = float32(f32)
-	_ = assert(x32 - y32 == 0)
-)
-
-const (
-	f64 = 1 + smallestFloat64
-	x64 float64 = f64
-	y64 = float64(f64)
-	_ = assert(x64 - y64 == 0)
-)
-
-const (
-	_ = int8(-1) << 7
-	_ = int8 /* ERROR "overflows" */ (-1) << 8
-
-	_ = uint32(1) << 31
-	_ = uint32 /* ERROR "overflows" */ (1) << 32
-)
diff --git a/src/cmd/compile/internal/types2/testdata/check/constdecl.go b/src/cmd/compile/internal/types2/testdata/check/constdecl.go
deleted file mode 100644
index bb07a361fa..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/constdecl.go
+++ /dev/null
@@ -1,160 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package constdecl
-
-import "math"
-import "unsafe"
-
-var v int
-
-// Const decls must be initialized by constants.
-const _ = v /* ERROR "not constant" */
-const _ = math /* ERROR "not constant" */ .Sin(0)
-const _ = int /* ERROR "not an expression" */
-
-func _() {
-	const _ = v /* ERROR "not constant" */
-	const _ = math /* ERROR "not constant" */ .Sin(0)
-	const _ = int /* ERROR "not an expression" */
-}
-
-// Identifier and expression arity must match.
-const _ /* ERROR "missing init expr for _" */
-const _ = 1, 2 /* ERROR "extra init expr 2" */
-
-const _ /* ERROR "missing init expr for _" */ int
-const _ int = 1, 2 /* ERROR "extra init expr 2" */
-
-const (
-	_ /* ERROR "missing init expr for _" */
-	_ = 1, 2 /* ERROR "extra init expr 2" */
-
-	_ /* ERROR "missing init expr for _" */ int
-	_ int = 1, 2 /* ERROR "extra init expr 2" */
-)
-
-const (
-	_ = 1
-	_
-	_, _ /* ERROR "missing init expr for _" */
-	_
-)
-
-const (
-	_, _ = 1, 2
-	_, _
-	_ /* ERROR "extra init expr at" */
-	_, _
-	_, _, _ /* ERROR "missing init expr for _" */
-	_, _
-)
-
-func _() {
-	const _ /* ERROR "missing init expr for _" */
-	const _ = 1, 2 /* ERROR "extra init expr 2" */
-
-	const _ /* ERROR "missing init expr for _" */ int
-	const _ int = 1, 2 /* ERROR "extra init expr 2" */
-
-	const (
-		_ /* ERROR "missing init expr for _" */
-		_ = 1, 2 /* ERROR "extra init expr 2" */
-
-		_ /* ERROR "missing init expr for _" */ int
-		_ int = 1, 2 /* ERROR "extra init expr 2" */
-	)
-
-	const (
-		_ = 1
-		_
-		_, _ /* ERROR "missing init expr for _" */
-		_
-	)
-
-	const (
-		_, _ = 1, 2
-		_, _
-		_ /* ERROR "extra init expr at" */
-		_, _
-		_, _, _ /* ERROR "missing init expr for _" */
-		_, _
-	)
-}
-
-// Test case for constant with invalid initialization.
-// Caused panic because the constant value was not set up (gri - 7/8/2014).
-func _() {
-	const (
-	    x string = missing /* ERROR "undeclared name" */
-	    y = x + ""
-	)
-}
-
-// Test case for constants depending on function literals (see also #22992).
-const A /* ERROR initialization cycle */ = unsafe.Sizeof(func() { _ = A })
-
-func _() {
-	// The function literal below must not see a.
-	const a = unsafe.Sizeof(func() { _ = a /* ERROR "undeclared name" */ })
-	const b = unsafe.Sizeof(func() { _ = a })
-
-	// The function literal below must not see x, y, or z.
-	const x, y, z = 0, 1, unsafe.Sizeof(func() { _ = x /* ERROR "undeclared name" */ + y /* ERROR "undeclared name" */ + z /* ERROR "undeclared name" */ })
-}
-
-// Test cases for errors in inherited constant initialization expressions.
-// Errors related to inherited initialization expressions must appear at
-// the constant identifier being declared, not at the original expression
-// (issues #42991, #42992).
-const (
-	_ byte = 255 + iota
-	/* some gap */
-	_ // ERROR overflows
-	/* some gap */
-	/* some gap */ _ /* ERROR overflows */; _ /* ERROR overflows */
-	/* some gap */
-	_ = 255 + iota
-	_ = byte /* ERROR overflows */ (255) + iota
-	_ /* ERROR overflows */
-)
-
-// Test cases from issue.
-const (
-	ok = byte(iota + 253)
-	bad
-	barn
-	bard // ERROR cannot convert
-)
-
-const (
-	c = len([1 - iota]int{})
-	d
-	e // ERROR invalid array length
-	f // ERROR invalid array length
-)
-
-// Test that identifiers in implicit (omitted) RHS
-// expressions of constant declarations are resolved
-// in the correct context; see issues #49157, #53585.
-const X = 2
-
-func _() {
-	const (
-		A    = iota // 0
-		iota = iota // 1
-		B           // 1 (iota is declared locally on prev. line)
-		C           // 1
-	)
-	assert(A == 0 && B == 1 && C == 1)
-
-	const (
-		X = X + X
-		Y
-		Z = iota
-	)
-	assert(X == 4 && Y == 8 && Z == 1)
-}
-
-// TODO(gri) move extra tests from testdata/const0.src into here
diff --git a/src/cmd/compile/internal/types2/testdata/check/conversions0.go b/src/cmd/compile/internal/types2/testdata/check/conversions0.go
deleted file mode 100644
index e1336c0456..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/conversions0.go
+++ /dev/null
@@ -1,93 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// conversions
-
-package conversions
-
-import "unsafe"
-
-// argument count
-var (
-	_ = int() /* ERROR "missing argument" */
-	_ = int(1, 2 /* ERROR "too many arguments" */ )
-)
-
-// numeric constant conversions are in const1.src.
-
-func string_conversions() {
-	const A = string(65)
-	assert(A == "A")
-	const E = string(-1)
-	assert(E == "\uFFFD")
-	assert(E == string(1234567890))
-
-	type myint int
-	assert(A == string(myint(65)))
-
-	type mystring string
-	const _ mystring = mystring("foo")
-
-	const _ = string(true /* ERROR "cannot convert" */ )
-	const _ = string(1.2 /* ERROR "cannot convert" */ )
-	const _ = string(nil /* ERROR "cannot convert" */ )
-
-	// issues 11357, 11353: argument must be of integer type
-	_ = string(0.0 /* ERROR "cannot convert" */ )
-	_ = string(0i /* ERROR "cannot convert" */ )
-	_ = string(1 /* ERROR "cannot convert" */ + 2i)
-}
-
-func interface_conversions() {
-	type E interface{}
-
-	type I1 interface{
-		m1()
-	}
-
-	type I2 interface{
-		m1()
-		m2(x int)
-	}
-
-	type I3 interface{
-		m1()
-		m2() int
-	}
-
-	var e E
-	var i1 I1
-	var i2 I2
-	var i3 I3
-
-	_ = E(0)
-	_ = E(nil)
-	_ = E(e)
-	_ = E(i1)
-	_ = E(i2)
-
-	_ = I1(0 /* ERROR "cannot convert" */ )
-	_ = I1(nil)
-	_ = I1(i1)
-	_ = I1(e /* ERROR "cannot convert" */ )
-	_ = I1(i2)
-
-	_ = I2(nil)
-	_ = I2(i1 /* ERROR "cannot convert" */ )
-	_ = I2(i2)
-	_ = I2(i3 /* ERROR "cannot convert" */ )
-
-	_ = I3(nil)
-	_ = I3(i1 /* ERROR "cannot convert" */ )
-	_ = I3(i2 /* ERROR "cannot convert" */ )
-	_ = I3(i3)
-
-	// TODO(gri) add more tests, improve error message
-}
-
-func issue6326() {
-	type T unsafe.Pointer
-	var x T
-	_ = uintptr(x) // see issue 6326
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/conversions1.go b/src/cmd/compile/internal/types2/testdata/check/conversions1.go
deleted file mode 100644
index 93a5f182fb..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/conversions1.go
+++ /dev/null
@@ -1,313 +0,0 @@
-// Copyright 2016 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Test various valid and invalid struct assignments and conversions.
-// Does not compile.
-
-package conversions2
-
-type I interface {
-	m()
-}
-
-// conversions between structs
-
-func _() {
-	type S struct{}
-	type T struct{}
-	var s S
-	var t T
-	var u struct{}
-	s = s
-	s = t // ERROR "cannot use .* in assignment"
-	s = u
-	s = S(s)
-	s = S(t)
-	s = S(u)
-	t = u
-	t = T(u)
-}
-
-func _() {
-	type S struct{ x int }
-	type T struct {
-		x int "foo"
-	}
-	var s S
-	var t T
-	var u struct {
-		x int "bar"
-	}
-	s = s
-	s = t // ERROR "cannot use .* in assignment"
-	s = u // ERROR "cannot use .* in assignment"
-	s = S(s)
-	s = S(t)
-	s = S(u)
-	t = u // ERROR "cannot use .* in assignment"
-	t = T(u)
-}
-
-func _() {
-	type E struct{ x int }
-	type S struct{ x E }
-	type T struct {
-		x E "foo"
-	}
-	var s S
-	var t T
-	var u struct {
-		x E "bar"
-	}
-	s = s
-	s = t // ERROR "cannot use .* in assignment"
-	s = u // ERROR "cannot use .* in assignment"
-	s = S(s)
-	s = S(t)
-	s = S(u)
-	t = u // ERROR "cannot use .* in assignment"
-	t = T(u)
-}
-
-func _() {
-	type S struct {
-		x struct {
-			x int "foo"
-		}
-	}
-	type T struct {
-		x struct {
-			x int "bar"
-		} "foo"
-	}
-	var s S
-	var t T
-	var u struct {
-		x struct {
-			x int "bar"
-		} "bar"
-	}
-	s = s
-	s = t // ERROR "cannot use .* in assignment"
-	s = u // ERROR "cannot use .* in assignment"
-	s = S(s)
-	s = S(t)
-	s = S(u)
-	t = u // ERROR "cannot use .* in assignment"
-	t = T(u)
-}
-
-func _() {
-	type E1 struct {
-		x int "foo"
-	}
-	type E2 struct {
-		x int "bar"
-	}
-	type S struct{ x E1 }
-	type T struct {
-		x E2 "foo"
-	}
-	var s S
-	var t T
-	var u struct {
-		x E2 "bar"
-	}
-	s = s
-	s = t // ERROR "cannot use .* in assignment"
-	s = u // ERROR "cannot use .* in assignment"
-	s = S(s)
-	s = S(t /* ERROR "cannot convert" */ )
-	s = S(u /* ERROR "cannot convert" */ )
-	t = u   // ERROR "cannot use .* in assignment"
-	t = T(u)
-}
-
-func _() {
-	type E struct{ x int }
-	type S struct {
-		f func(struct {
-			x int "foo"
-		})
-	}
-	type T struct {
-		f func(struct {
-			x int "bar"
-		})
-	}
-	var s S
-	var t T
-	var u struct{ f func(E) }
-	s = s
-	s = t // ERROR "cannot use .* in assignment"
-	s = u // ERROR "cannot use .* in assignment"
-	s = S(s)
-	s = S(t)
-	s = S(u /* ERROR "cannot convert" */ )
-	t = u   // ERROR "cannot use .* in assignment"
-	t = T(u /* ERROR "cannot convert" */ )
-}
-
-// conversions between pointers to structs
-
-func _() {
-	type S struct{}
-	type T struct{}
-	var s *S
-	var t *T
-	var u *struct{}
-	s = s
-	s = t // ERROR "cannot use .* in assignment"
-	s = u // ERROR "cannot use .* in assignment"
-	s = (*S)(s)
-	s = (*S)(t)
-	s = (*S)(u)
-	t = u // ERROR "cannot use .* in assignment"
-	t = (*T)(u)
-}
-
-func _() {
-	type S struct{ x int }
-	type T struct {
-		x int "foo"
-	}
-	var s *S
-	var t *T
-	var u *struct {
-		x int "bar"
-	}
-	s = s
-	s = t // ERROR "cannot use .* in assignment"
-	s = u // ERROR "cannot use .* in assignment"
-	s = (*S)(s)
-	s = (*S)(t)
-	s = (*S)(u)
-	t = u // ERROR "cannot use .* in assignment"
-	t = (*T)(u)
-}
-
-func _() {
-	type E struct{ x int }
-	type S struct{ x E }
-	type T struct {
-		x E "foo"
-	}
-	var s *S
-	var t *T
-	var u *struct {
-		x E "bar"
-	}
-	s = s
-	s = t // ERROR "cannot use .* in assignment"
-	s = u // ERROR "cannot use .* in assignment"
-	s = (*S)(s)
-	s = (*S)(t)
-	s = (*S)(u)
-	t = u // ERROR "cannot use .* in assignment"
-	t = (*T)(u)
-}
-
-func _() {
-	type S struct {
-		x struct {
-			x int "foo"
-		}
-	}
-	type T struct {
-		x struct {
-			x int "bar"
-		} "foo"
-	}
-	var s *S
-	var t *T
-	var u *struct {
-		x struct {
-			x int "bar"
-		} "bar"
-	}
-	s = s
-	s = t // ERROR "cannot use .* in assignment"
-	s = u // ERROR "cannot use .* in assignment"
-	s = (*S)(s)
-	s = (*S)(t)
-	s = (*S)(u)
-	t = u // ERROR "cannot use .* in assignment"
-	t = (*T)(u)
-}
-
-func _() {
-	type E1 struct {
-		x int "foo"
-	}
-	type E2 struct {
-		x int "bar"
-	}
-	type S struct{ x E1 }
-	type T struct {
-		x E2 "foo"
-	}
-	var s *S
-	var t *T
-	var u *struct {
-		x E2 "bar"
-	}
-	s = s
-	s = t // ERROR "cannot use .* in assignment"
-	s = u // ERROR "cannot use .* in assignment"
-	s = (*S)(s)
-	s = (*S)(t /* ERROR "cannot convert" */ )
-	s = (*S)(u /* ERROR "cannot convert" */ )
-	t = u      // ERROR "cannot use .* in assignment"
-	t = (*T)(u)
-}
-
-func _() {
-	type E struct{ x int }
-	type S struct {
-		f func(struct {
-			x int "foo"
-		})
-	}
-	type T struct {
-		f func(struct {
-			x int "bar"
-		})
-	}
-	var s *S
-	var t *T
-	var u *struct{ f func(E) }
-	s = s
-	s = t // ERROR "cannot use .* in assignment"
-	s = u // ERROR "cannot use .* in assignment"
-	s = (*S)(s)
-	s = (*S)(t)
-	s = (*S)(u /* ERROR "cannot convert" */ )
-	t = u      // ERROR "cannot use .* in assignment"
-	t = (*T)(u /* ERROR "cannot convert" */ )
-}
-
-func _() {
-	type E struct{ x int }
-	type S struct {
-		f func(*struct {
-			x int "foo"
-		})
-	}
-	type T struct {
-		f func(*struct {
-			x int "bar"
-		})
-	}
-	var s *S
-	var t *T
-	var u *struct{ f func(E) }
-	s = s
-	s = t // ERROR "cannot use .* in assignment"
-	s = u // ERROR "cannot use .* in assignment"
-	s = (*S)(s)
-	s = (*S)(t)
-	s = (*S)(u /* ERROR "cannot convert" */ )
-	t = u      // ERROR "cannot use .* in assignment"
-	t = (*T)(u /* ERROR "cannot convert" */ )
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/cycles0.go b/src/cmd/compile/internal/types2/testdata/check/cycles0.go
deleted file mode 100644
index 998f9f7da9..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/cycles0.go
+++ /dev/null
@@ -1,175 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package cycles
-
-import "unsafe"
-
-type (
-	T0 int
-	T1 /* ERROR cycle */ T1
-	T2 *T2
-
-	T3 /* ERROR cycle */ T4
-	T4 T5
-	T5 T3
-
-	T6 T7
-	T7 *T8
-	T8 T6
-
-	// arrays
-	A0 /* ERROR cycle */ [10]A0
-	A1 [10]*A1
-
-	A2 /* ERROR cycle */ [10]A3
-	A3 [10]A4
-	A4 A2
-
-	A5 [10]A6
-	A6 *A5
-
-	// slices
-	L0 []L0
-
-	// structs
-	S0 /* ERROR cycle */ struct{ _ S0 }
-	S1 /* ERROR cycle */ struct{ S1 }
-	S2 struct{ _ *S2 }
-	S3 struct{ *S3 }
-
-	S4 /* ERROR cycle */ struct{ S5 }
-	S5 struct{ S6 }
-	S6 S4
-
-	// pointers
-	P0 *P0
-	PP *struct{ PP.f /* ERROR no field or method f */ }
-
-	// functions
-	F0 func(F0)
-	F1 func() F1
-	F2 func(F2) F2
-
-	// interfaces
-	I0 /* ERROR cycle */ interface{ I0 }
-
-	I1 /* ERROR cycle */ interface{ I2 }
-	I2 interface{ I3 }
-	I3 interface{ I1 }
-
-	I4 interface{ f(I4) }
-
-	// testcase for issue 5090
-	I5 interface{ f(I6) }
-	I6 interface{ I5 }
-
-	// maps
-	M0 map[M0 /* ERROR invalid map key */ ]M0
-
-	// channels
-	C0 chan C0
-)
-
-// test case for issue #34771
-type (
-	AA /* ERROR cycle */ B
-	B C
-	C [10]D
-	D E
-	E AA
-)
-
-func _() {
-	type (
-		t1 /* ERROR cycle */ t1
-		t2 *t2
-
-		t3 t4 /* ERROR undeclared */
-		t4 t5 /* ERROR undeclared */
-		t5 t3
-
-		// arrays
-		a0 /* ERROR cycle */ [10]a0
-		a1 [10]*a1
-
-		// slices
-		l0 []l0
-
-		// structs
-		s0 /* ERROR cycle */ struct{ _ s0 }
-		s1 /* ERROR cycle */ struct{ s1 }
-		s2 struct{ _ *s2 }
-		s3 struct{ *s3 }
-
-		// pointers
-		p0 *p0
-
-		// functions
-		f0 func(f0)
-		f1 func() f1
-		f2 func(f2) f2
-
-		// interfaces
-		i0 /* ERROR cycle */ interface{ i0 }
-
-		// maps
-		m0 map[m0 /* ERROR invalid map key */ ]m0
-
-		// channels
-		c0 chan c0
-	)
-}
-
-// test cases for issue 6667
-
-type A [10]map[A /* ERROR invalid map key */ ]bool
-
-type S struct {
-	m map[S /* ERROR invalid map key */ ]bool
-}
-
-// test cases for issue 7236
-// (cycle detection must not be dependent on starting point of resolution)
-
-type (
-	P1 *T9
-	T9 /* ERROR cycle */ T9
-
-	T10 /* ERROR cycle */ T10
-	P2 *T10
-)
-
-func (T11) m() {}
-
-type T11 /* ERROR cycle */ struct{ T11 }
-
-type T12 /* ERROR cycle */ struct{ T12 }
-
-func (*T12) m() {}
-
-type (
-	P3 *T13
-	T13 /* ERROR cycle */ T13
-)
-
-// test cases for issue 18643
-// (type cycle detection when non-type expressions are involved)
-type (
-	T14 [len(T14 /* ERROR cycle */ {})]int
-	T15 [][len(T15 /* ERROR cycle */ {})]int
-	T16 map[[len(T16 /* ERROR cycle */ {1:2})]int]int
-	T17 map[int][len(T17 /* ERROR cycle */ {1:2})]int
-)
-
-// Test case for types depending on function literals (see also #22992).
-type T20 chan [unsafe.Sizeof(func(ch T20){ _ = <-ch })]byte
-type T22 = chan [unsafe.Sizeof(func(ch T20){ _ = <-ch })]byte
-
-func _() {
-	type T0 func(T0)
-	type T1 /* ERROR cycle */ = func(T1)
-	type T2 chan [unsafe.Sizeof(func(ch T2){ _ = <-ch })]byte
-	type T3 /* ERROR cycle */ = chan [unsafe.Sizeof(func(ch T3){ _ = <-ch })]byte
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/cycles1.go b/src/cmd/compile/internal/types2/testdata/check/cycles1.go
deleted file mode 100644
index ae2b38ebec..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/cycles1.go
+++ /dev/null
@@ -1,77 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package p
-
-type (
-	A interface {
-		a() interface {
-			ABC1
-		}
-	}
-	B interface {
-		b() interface {
-			ABC2
-		}
-	}
-	C interface {
-		c() interface {
-			ABC3
-		}
-	}
-
-	AB interface {
-		A
-		B
-	}
-	BC interface {
-		B
-		C
-	}
-
-	ABC1 interface {
-		A
-		B
-		C
-	}
-	ABC2 interface {
-		AB
-		C
-	}
-	ABC3 interface {
-		A
-		BC
-	}
-)
-
-var (
-	x1 ABC1
-	x2 ABC2
-	x3 ABC3
-)
-
-func _() {
-	// all types have the same method set
-	x1 = x2
-	x2 = x1
-
-	x1 = x3
-	x3 = x1
-
-	x2 = x3
-	x3 = x2
-
-	// all methods return the same type again
-	x1 = x1.a()
-	x1 = x1.b()
-	x1 = x1.c()
-
-	x2 = x2.a()
-	x2 = x2.b()
-	x2 = x2.c()
-
-	x3 = x3.a()
-	x3 = x3.b()
-	x3 = x3.c()
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/cycles2.go b/src/cmd/compile/internal/types2/testdata/check/cycles2.go
deleted file mode 100644
index 1a7f40ae4b..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/cycles2.go
+++ /dev/null
@@ -1,98 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package p
-
-import "unsafe"
-
-// Test case for issue 5090
-
-type t interface {
-	f(u)
-}
-
-type u interface {
-	t
-}
-
-func _() {
-	var t t
-	var u u
-
-	t.f(t)
-	t.f(u)
-
-	u.f(t)
-	u.f(u)
-}
-
-
-// Test case for issues #6589, #33656.
-
-type A interface {
-	a() interface {
-		AB
-	}
-}
-
-type B interface {
-	b() interface {
-		AB
-	}
-}
-
-type AB interface {
-	a() interface {
-		A
-		B
-	}
-	b() interface {
-		A
-		B
-	}
-}
-
-var x AB
-var y interface {
-	A
-	B
-}
-
-var _ = x == y
-
-
-// Test case for issue 6638.
-
-type T interface {
-	m() [T(nil).m /* ERROR undefined */ ()[0]]int
-}
-
-// Variations of this test case.
-
-type T1 /* ERROR cycle */ interface {
-	m() [x1.m()[0]]int
-}
-
-var x1 T1
-
-type T2 /* ERROR cycle */ interface {
-	m() [len(x2.m())]int
-}
-
-var x2 T2
-
-type T3 /* ERROR cycle */ interface {
-	m() [unsafe.Sizeof(x3.m)]int
-}
-
-var x3 T3
-
-type T4 /* ERROR cycle */ interface {
-	m() [unsafe.Sizeof(cast4(x4.m))]int // cast is invalid but we have a cycle, so all bets are off
-}
-
-var x4 T4
-var _ = cast4(x4.m)
-
-type cast4 func()
diff --git a/src/cmd/compile/internal/types2/testdata/check/cycles3.go b/src/cmd/compile/internal/types2/testdata/check/cycles3.go
deleted file mode 100644
index 5e89b627f0..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/cycles3.go
+++ /dev/null
@@ -1,60 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package p
-
-import "unsafe"
-
-var (
-	_ A = A(nil).a().b().c().d().e().f()
-	_ A = A(nil).b().c().d().e().f()
-	_ A = A(nil).c().d().e().f()
-	_ A = A(nil).d().e().f()
-	_ A = A(nil).e().f()
-	_ A = A(nil).f()
-	_ A = A(nil)
-)
-
-type (
-	A interface {
-		a() B
-		B
-	}
-
-	B interface {
-		b() C
-		C
-	}
-
-	C interface {
-		c() D
-		D
-	}
-
-	D interface {
-		d() E
-		E
-	}
-
-	E interface {
-		e() F
-		F
-	}
-
-	F interface {
-		f() A
-	}
-)
-
-type (
-	U /* ERROR cycle */ interface {
-		V
-	}
-
-	V interface {
-		v() [unsafe.Sizeof(u)]int
-	}
-)
-
-var u U
diff --git a/src/cmd/compile/internal/types2/testdata/check/cycles4.go b/src/cmd/compile/internal/types2/testdata/check/cycles4.go
deleted file mode 100644
index 924aabf475..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/cycles4.go
+++ /dev/null
@@ -1,121 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package p
-
-import "unsafe"
-
-// Check that all methods of T are collected before
-// determining the result type of m (which embeds
-// all methods of T).
-
-type T interface {
-	m() interface {T}
-	E
-}
-
-var _ int = T.m(nil).m().e()
-
-type E interface {
-	e() int
-}
-
-// Check that unresolved forward chains are followed
-// (see also comment in resolver.go, checker.typeDecl).
-
-var _ int = C.m(nil).m().e()
-
-type A B
-
-type B interface {
-	m() interface{C}
-	E
-}
-
-type C A
-
-// Check that interface type comparison for identity
-// does not recur endlessly.
-
-type T1 interface {
-	m() interface{T1}
-}
-
-type T2 interface {
-	m() interface{T2}
-}
-
-func _(x T1, y T2) {
-	// Checking for assignability of interfaces must check
-	// if all methods of x are present in y, and that they
-	// have identical signatures. The signatures recur via
-	// the result type, which is an interface that embeds
-	// a single method m that refers to the very interface
-	// that contains it. This requires cycle detection in
-	// identity checks for interface types.
-	x = y
-}
-
-type T3 interface {
-	m() interface{T4}
-}
-
-type T4 interface {
-	m() interface{T3}
-}
-
-func _(x T1, y T3) {
-	x = y
-}
-
-// Check that interfaces are type-checked in order of
-// (embedded interface) dependencies (was issue 7158).
-
-var x1 T5 = T7(nil)
-
-type T5 interface {
-	T6
-}
-
-type T6 interface {
-	m() T7
-}
-type T7 interface {
-	T5
-}
-
-// Actual test case from issue 7158.
-
-func wrapNode() Node {
-	return wrapElement()
-}
-
-func wrapElement() Element {
-	return nil
-}
-
-type EventTarget interface {
-	AddEventListener(Event)
-}
-
-type Node interface {
-	EventTarget
-}
-
-type Element interface {
-	Node
-}
-
-type Event interface {
-	Target() Element
-}
-
-// Check that accessing an interface method too early doesn't lead
-// to follow-on errors due to an incorrectly computed type set.
-
-type T8 interface {
-	m() [unsafe.Sizeof(T8.m /* ERROR undefined */ )]int
-}
-
-var _ = T8.m // no error expected here
diff --git a/src/cmd/compile/internal/types2/testdata/check/cycles5.go b/src/cmd/compile/internal/types2/testdata/check/cycles5.go
deleted file mode 100644
index c932ef92d0..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/cycles5.go
+++ /dev/null
@@ -1,200 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package p
-
-import "unsafe"
-
-// test case from issue #18395
-
-type (
-	A interface { B }
-	B interface { C }
-	C interface { D; F() A }
-	D interface { G() B }
-)
-
-var _ = A(nil).G // G must be found
-
-
-// test case from issue #21804
-
-type sourceBridge interface {
-	listVersions() ([]Version, error)
-}
-
-type Constraint interface {
-	copyTo(*ConstraintMsg)
-}
-
-type ConstraintMsg struct{}
-
-func (m *ConstraintMsg) asUnpairedVersion() UnpairedVersion {
-	return nil
-}
-
-type Version interface {
-	Constraint
-}
-
-type UnpairedVersion interface {
-	Version
-}
-
-var _ Constraint = UnpairedVersion(nil)
-
-
-// derived test case from issue #21804
-
-type (
-	_ interface{ m(B1) }
-	A1 interface{ a(D1) }
-	B1 interface{ A1 }
-	C1 interface{ B1 }
-	D1 interface{ C1 }
-)
-
-var _ A1 = C1(nil)
-
-
-// derived test case from issue #22701
-
-func F(x I4) interface{} {
-	return x.Method()
-}
-
-type Unused interface {
-	RefersToI1(a I1)
-}
-
-type I1 interface {
-	I2
-	I3
-}
-
-type I2 interface {
-	RefersToI4() I4
-}
-
-type I3 interface {
-	Method() interface{}
-}
-
-type I4 interface {
-	I1
-}
-
-
-// check embedding of error interface
-
-type Error interface{ error }
-
-var err Error
-var _ = err.Error()
-
-
-// more esoteric cases
-
-type (
-	T1 interface { T2 }
-	T2 /* ERROR cycle */ T2
-)
-
-type (
-	T3 interface { T4 }
-	T4 /* ERROR cycle */ T5
-	T5 = T6
-	T6 = T7
-	T7 = T4
-)
-
-
-// arbitrary code may appear inside an interface
-
-const n = unsafe.Sizeof(func(){})
-
-type I interface {
-	m([unsafe.Sizeof(func() { I.m(nil, [n]byte{}) })]byte)
-}
-
-
-// test cases for varias alias cycles
-
-type T10 /* ERROR cycle */ = *T10                 // issue #25141
-type T11 /* ERROR cycle */ = interface{ f(T11) }  // issue #23139
-
-// issue #18640
-type (
-	aa = bb
-	bb struct {
-		*aa
-	}
-)
-
-type (
-	a struct{ *b }
-	b = c
-	c struct{ *b /* ERROR invalid use of type alias */ }
-)
-
-// issue #24939
-type (
-	_ interface {
-		M(P)
-	}
-
-	M interface {
-		F() P // ERROR invalid use of type alias
-	}
-
-	P = interface {
-		I() M
-	}
-)
-
-// issue #8699
-type T12 /* ERROR cycle */ [len(a12)]int
-var a12 = makeArray()
-func makeArray() (res T12) { return }
-
-// issue #20770
-var r /* ERROR cycle */ = newReader()
-func newReader() r
-
-// variations of the theme of #8699 and #20770
-var arr /* ERROR cycle */ = f()
-func f() [len(arr)]int
-
-// issue #25790
-func ff(ff /* ERROR not a type */ )
-func gg((gg /* ERROR not a type */ ))
-
-type T13 /* ERROR cycle */ [len(b13)]int
-var b13 T13
-
-func g1() [unsafe.Sizeof(g1)]int
-func g2() [unsafe.Sizeof(x2)]int
-var x2 = g2
-
-// verify that we get the correct sizes for the functions above
-// (note: assert is statically evaluated in go/types test mode)
-func init() {
-	assert(unsafe.Sizeof(g1) == 8)
-	assert(unsafe.Sizeof(x2) == 8)
-}
-
-func h() [h /* ERROR no value */ ()[0]]int { panic(0) }
-
-var c14 /* ERROR cycle */ T14
-type T14 [uintptr(unsafe.Sizeof(&c14))]byte
-
-// issue #34333
-type T15 /* ERROR cycle */ struct {
-	f func() T16
-	b T16
-}
-
-type T16 struct {
-	T15
-}
\ No newline at end of file
diff --git a/src/cmd/compile/internal/types2/testdata/check/decls0.go b/src/cmd/compile/internal/types2/testdata/check/decls0.go
deleted file mode 100644
index 7ba90c0504..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/decls0.go
+++ /dev/null
@@ -1,210 +0,0 @@
-// -lang=go1.17
-
-// Copyright 2011 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// type declarations
-
-package p // don't permit non-interface elements in interfaces
-
-import "unsafe"
-
-const pi = 3.1415
-
-type (
-	N undeclared /* ERROR "undeclared" */
-	B bool
-	I int32
-	A [10]P
-	T struct {
-		x, y P
-	}
-	P *T
-	R (*R)
-	F func(A) I
-	Y interface {
-		f(A) I
-	}
-	S [](((P)))
-	M map[I]F
-	C chan<- I
-
-	// blank types must be typechecked
-	_ pi /* ERROR "not a type" */
-	_ struct{}
-	_ struct{ pi /* ERROR "not a type" */ }
-)
-
-
-// declarations of init
-const _, init /* ERROR "cannot declare init" */ , _ = 0, 1, 2
-type init /* ERROR "cannot declare init" */ struct{}
-var _, init /* ERROR "cannot declare init" */ int
-
-func init() {}
-func init /* ERROR "missing function body" */ ()
-
-func _() { const init = 0 }
-func _() { type init int }
-func _() { var init int; _ = init }
-
-// invalid array types
-type (
-	iA0 [... /* ERROR "invalid use of \[...\] array" */ ]byte
-	// The error message below could be better. At the moment
-	// we believe an integer that is too large is not an integer.
-	// But at least we get an error.
-	iA1 [1 /* ERROR "must be integer" */ <<100]int
-	iA2 [- /* ERROR "invalid array length" */ 1]complex128
-	iA3 ["foo" /* ERROR "must be integer" */ ]string
-	iA4 [float64 /* ERROR "must be integer" */ (0)]int
-)
-
-
-type (
-	p1 pi.foo /* ERROR "no field or method foo" */
-	p2 unsafe.Pointer
-)
-
-
-type (
-	Pi pi /* ERROR "not a type" */
-
-	a /* ERROR "illegal cycle" */ a
-	a /* ERROR "redeclared" */ int
-
-	b /* ERROR "illegal cycle" */ c
-	c d
-	d e
-	e b
-
-	t *t
-
-	U V
-	V *W
-	W U
-
-	P1 *S2
-	P2 P1
-
-	S0 struct {
-	}
-	S1 struct {
-		a, b, c int
-		u, v, a /* ERROR "redeclared" */ float32
-	}
-	S2 struct {
-		S0 // embedded field
-		S0 /* ERROR "redeclared" */ int
-	}
-	S3 struct {
-		x S2
-	}
-	S4/* ERROR "illegal cycle" */ struct {
-		S4
-	}
-	S5 /* ERROR "illegal cycle" */ struct {
-		S6
-	}
-	S6 struct {
-		field S7
-	}
-	S7 struct {
-		S5
-	}
-
-	L1 []L1
-	L2 []int
-
-	A1 [10.0]int
-	A2 /* ERROR "illegal cycle" */ [10]A2
-	A3 /* ERROR "illegal cycle" */ [10]struct {
-		x A4
-	}
-	A4 [10]A3
-
-	F1 func()
-	F2 func(x, y, z float32)
-	F3 func(x, y, x /* ERROR "redeclared" */ float32)
-	F4 func() (x, y, x /* ERROR "redeclared" */ float32)
-	F5 func(x int) (x /* ERROR "redeclared" */ float32)
-	F6 func(x ...int)
-
-	I1 interface{}
-	I2 interface {
-		m1()
-	}
-	I3 interface {
-		m1()
-		m1 /* ERROR "duplicate method" */ ()
-	}
-	I4 interface {
-		m1(x, y, x /* ERROR "redeclared" */ float32)
-		m2() (x, y, x /* ERROR "redeclared" */ float32)
-		m3(x int) (x /* ERROR "redeclared" */ float32)
-	}
-	I5 interface {
-		m1(I5)
-	}
-	I6 interface {
-		S0 /* ERROR "non-interface type S0" */
-	}
-	I7 interface {
-		I1
-		I1
-	}
-	I8 /* ERROR "illegal cycle" */ interface {
-		I8
-	}
-	I9 /* ERROR "illegal cycle" */ interface {
-		I10
-	}
-	I10 interface {
-		I11
-	}
-	I11 interface {
-		I9
-	}
-
-	C1 chan int
-	C2 <-chan int
-	C3 chan<- C3
-	C4 chan C5
-	C5 chan C6
-	C6 chan C4
-
-	M1 map[Last]string
-	M2 map[string]M2
-
-	Last int
-)
-
-// cycles in function/method declarations
-// (test cases for issues #5217, #25790 and variants)
-func f1(x f1 /* ERROR "not a type" */ ) {}
-func f2(x *f2 /* ERROR "not a type" */ ) {}
-func f3() (x f3 /* ERROR "not a type" */ ) { return }
-func f4() (x *f4 /* ERROR "not a type" */ ) { return }
-// TODO(#43215) this should be detected as a cycle error
-func f5([unsafe.Sizeof(f5)]int) {}
-
-func (S0) m1 (x S0 /* ERROR illegal cycle in method declaration */ .m1) {}
-func (S0) m2 (x *S0 /* ERROR illegal cycle in method declaration */ .m2) {}
-func (S0) m3 () (x S0 /* ERROR illegal cycle in method declaration */ .m3) { return }
-func (S0) m4 () (x *S0 /* ERROR illegal cycle in method declaration */ .m4) { return }
-
-// interfaces may not have any blank methods
-type BlankI interface {
-	_ /* ERROR "methods must have a unique non-blank name" */ ()
-	_ /* ERROR "methods must have a unique non-blank name" */ (float32) int
-	m()
-}
-
-// non-interface types may have multiple blank methods
-type BlankT struct{}
-
-func (BlankT) _() {}
-func (BlankT) _(int) {}
-func (BlankT) _() int { return 0 }
-func (BlankT) _(int) int { return 0}
diff --git a/src/cmd/compile/internal/types2/testdata/check/decls1.go b/src/cmd/compile/internal/types2/testdata/check/decls1.go
deleted file mode 100644
index 6fe349b0b2..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/decls1.go
+++ /dev/null
@@ -1,146 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// variable declarations
-
-package decls1
-
-import (
-	"math"
-)
-
-// Global variables without initialization
-var (
-	a, b bool
-	c byte
-	d uint8
-	r rune
-	i int
-	j, k, l int
-	x, y float32
-	xx, yy float64
-	u, v complex64
-	uu, vv complex128
-	s, t string
-	array []byte
-	iface interface{}
-
-	blank _ /* ERROR "cannot use _" */
-)
-
-// Global variables with initialization
-var (
-	s1 = i + j
-	s2 = i /* ERROR "mismatched types" */ + x
-	s3 = c + d
-	s4 = s + t
-	s5 = s /* ERROR "invalid operation" */ / t
-	s6 = array[t1]
-	s7 = array[x /* ERROR "integer" */]
-	s8 = &a
-	s10 = &42 /* ERROR "cannot take address" */
-	s11 = &v
-	s12 = -(u + *t11) / *&v
-	s13 = a /* ERROR "shifted operand" */ << d
-	s14 = i << j
-	s18 = math.Pi * 10.0
-	s19 = s1 /* ERROR "cannot call" */ ()
- 	s20 = f0 /* ERROR "no value" */ ()
-	s21 = f6(1, s1, i)
-	s22 = f6(1, s1, uu /* ERROR "cannot use .* in argument" */ )
-
-	t1 int = i + j
-	t2 int = i /* ERROR "mismatched types" */ + x
-	t3 int = c /* ERROR "cannot use .* variable declaration" */ + d
-	t4 string = s + t
-	t5 string = s /* ERROR "invalid operation" */ / t
-	t6 byte = array[t1]
-	t7 byte = array[x /* ERROR "must be integer" */]
-	t8 *int = & /* ERROR "cannot use .* variable declaration" */ a
-	t10 *int = &42 /* ERROR "cannot take address" */
-	t11 *complex64 = &v
-	t12 complex64 = -(u + *t11) / *&v
-	t13 int = a /* ERROR "shifted operand" */ << d
-	t14 int = i << j
-	t15 math /* ERROR "not in selector" */
-	t16 math.xxx /* ERROR "not declared" */
-	t17 math /* ERROR "not a type" */ .Pi
-	t18 float64 = math.Pi * 10.0
-	t19 int = t1 /* ERROR "cannot call" */ ()
-	t20 int = f0 /* ERROR "no value" */ ()
-	t21 int = a /* ERROR "cannot use .* variable declaration" */
-)
-
-// Various more complex expressions
-var (
-	u1 = x /* ERROR "not an interface" */ .(int)
-	u2 = iface.([]int)
-	u3 = iface.(a /* ERROR "not a type" */ )
-	u4, ok = iface.(int)
-	u5, ok2, ok3 = iface /* ERROR "cannot initialize" */ .(int)
-)
-
-// Constant expression initializations
-var (
-	v1 = 1 /* ERROR "mismatched types untyped int and untyped string" */ + "foo"
-	v2 = c + 255
-	v3 = c + 256 /* ERROR "overflows" */
-	v4 = r + 2147483647
-	v5 = r + 2147483648 /* ERROR "overflows" */
-	v6 = 42
-	v7 = v6 + 9223372036854775807
-	v8 = v6 + 9223372036854775808 /* ERROR "overflows" */
-	v9 = i + 1 << 10
-	v10 byte = 1024 /* ERROR "overflows" */
-	v11 = xx/yy*yy - xx
-	v12 = true && false
-	v13 = nil /* ERROR "use of untyped nil" */
-	v14 string = 257 // ERROR cannot use 257 .* as string value in variable declaration$
-	v15 int8 = 257 // ERROR cannot use 257 .* as int8 value in variable declaration .*overflows
-)
-
-// Multiple assignment expressions
-var (
-	m1a, m1b = 1, 2
-	m2a, m2b, m2c /* ERROR "missing init expr for m2c" */ = 1, 2
-	m3a, m3b = 1, 2, 3 /* ERROR "extra init expr 3" */
-)
-
-func _() {
-	var (
-		m1a, m1b = 1, 2
-		m2a, m2b, m2c /* ERROR "missing init expr for m2c" */ = 1, 2
-		m3a, m3b = 1, 2, 3 /* ERROR "extra init expr 3" */
-	)
-
-	_, _ = m1a, m1b
-	_, _, _ = m2a, m2b, m2c
-	_, _ = m3a, m3b
-}
-
-// Declaration of parameters and results
-func f0() {}
-func f1(a /* ERROR "not a type" */) {}
-func f2(a, b, c d /* ERROR "not a type" */) {}
-
-func f3() int { return 0 }
-func f4() a /* ERROR "not a type" */ { return 0 }
-func f5() (a, b, c d /* ERROR "not a type" */) { return }
-
-func f6(a, b, c int) complex128 { return 0 }
-
-// Declaration of receivers
-type T struct{}
-
-func (T) m0() {}
-func (*T) m1() {}
-func (x T) m2() {}
-func (x *T) m3() {}
-
-// Initialization functions
-func init() {}
-func /* ERROR "no arguments and no return values" */ init(int) {}
-func /* ERROR "no arguments and no return values" */ init() int { return 0 }
-func /* ERROR "no arguments and no return values" */ init(int) int { return 0 }
-func (T) init(int) int { return 0 }
diff --git a/src/cmd/compile/internal/types2/testdata/check/decls2/decls2a.go b/src/cmd/compile/internal/types2/testdata/check/decls2/decls2a.go
deleted file mode 100644
index cccbf29793..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/decls2/decls2a.go
+++ /dev/null
@@ -1,111 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// method declarations
-
-package decls2
-
-import "time"
-import "unsafe"
-
-// T1 declared before its methods.
-type T1 struct{
-	f int
-}
-
-func (T1) m() {}
-func (T1) m /* ERROR "already declared" */ () {}
-func (x *T1) f /* ERROR "field and method" */ () {}
-
-// Conflict between embedded field and method name,
-// with the embedded field being a basic type.
-type T1b struct {
-	int
-}
-
-func (T1b) int /* ERROR "field and method" */ () {}
-
-type T1c struct {
-	time.Time
-}
-
-func (T1c) Time /* ERROR "field and method" */ () int { return 0 }
-
-// Disabled for now: LookupFieldOrMethod will find Pointer even though
-// it's double-declared (it would cost extra in the common case to verify
-// this). But the MethodSet computation will not find it due to the name
-// collision caused by the double-declaration, leading to an internal
-// inconsistency while we are verifying one computation against the other.
-// var _ = T1c{}.Pointer
-
-// T2's method declared before the type.
-func (*T2) f /* ERROR "field and method" */ () {}
-
-type T2 struct {
-	f int
-}
-
-// Methods declared without a declared type.
-func (undeclared /* ERROR "undeclared" */) m() {}
-func (x *undeclared /* ERROR "undeclared" */) m() {}
-
-func (pi /* ERROR "not a type" */) m1() {}
-func (x pi /* ERROR "not a type" */) m2() {}
-func (x *pi /* ERROR "not a type" */ ) m3() {}
-
-// Blank types.
-type _ struct { m int }
-type _ struct { m int }
-
-func (_ /* ERROR "cannot use _" */) m() {}
-func m(_ /* ERROR "cannot use _" */) {}
-
-// Methods with receiver base type declared in another file.
-func (T3) m1() {}
-func (*T3) m2() {}
-func (x T3) m3() {}
-func (x *T3) f /* ERROR "field and method" */ () {}
-
-// Methods of non-struct type.
-type T4 func()
-
-func (self T4) m() func() { return self }
-
-// Methods associated with an interface.
-type T5 interface {
-	m() int
-}
-
-func (T5 /* ERROR "invalid receiver" */ ) m1() {}
-func (T5 /* ERROR "invalid receiver" */ ) m2() {}
-
-// Methods associated with a named pointer type.
-type ptr *int
-func (ptr /* ERROR "invalid receiver" */ ) _() {}
-func (* /* ERROR "invalid receiver" */ ptr) _() {}
-
-// Methods with zero or multiple receivers.
-func ( /* ERROR "method has no receiver" */ ) _() {}
-func (T3, * /* ERROR "method has multiple receivers" */ T3) _() {}
-func (T3, T3, T3 /* ERROR "method has multiple receivers" */ ) _() {}
-func (a, b /* ERROR "method has multiple receivers" */ T3) _() {}
-func (a, b, c /* ERROR "method has multiple receivers" */ T3) _() {}
-
-// Methods associated with non-local or unnamed types.
-func (int /* ERROR "cannot define new methods on non-local type int" */ ) m() {}
-func ([ /* ERROR "invalid receiver" */ ]int) m() {}
-func (time /* ERROR "cannot define new methods on non-local type time\.Time" */ .Time) m() {}
-func (* /* ERROR "cannot define new methods on non-local type time\.Time" */ time.Time) m() {}
-func (x /* ERROR "invalid receiver" */ interface{}) m() {}
-
-// Unsafe.Pointer is treated like a pointer when used as receiver type.
-type UP unsafe.Pointer
-func (UP /* ERROR "invalid" */ ) m1() {}
-func (* /* ERROR "invalid" */ UP) m2() {}
-
-// Double declarations across package files
-const c_double = 0
-type t_double int
-var v_double int
-func f_double() {}
diff --git a/src/cmd/compile/internal/types2/testdata/check/decls2/decls2b.go b/src/cmd/compile/internal/types2/testdata/check/decls2/decls2b.go
deleted file mode 100644
index 5c55750a10..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/decls2/decls2b.go
+++ /dev/null
@@ -1,75 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// method declarations
-
-package decls2
-
-import "io"
-
-const pi = 3.1415
-
-func (T1) m /* ERROR "already declared" */ () {}
-func (T2) m(io.Writer) {}
-
-type T3 struct {
-	f *T3
-}
-
-type T6 struct {
-	x int
-}
-
-func (t *T6) m1() int {
-	return t.x
-}
-
-func f() {
-	var t *T6
-	t.m1()
-}
-
-// Double declarations across package files
-const c_double /* ERROR "redeclared" */ = 0
-type t_double  /* ERROR "redeclared" */ int
-var v_double /* ERROR "redeclared" */ int
-func f_double /* ERROR "redeclared" */ () {}
-
-// Blank methods need to be type-checked.
-// Verify by checking that errors are reported.
-func (T /* ERROR "undeclared" */ ) _() {}
-func (T1) _(undeclared /* ERROR "undeclared" */ ) {}
-func (T1) _() int { return "foo" /* ERROR "cannot use .* in return statement" */ }
-
-// Methods with undeclared receiver type can still be checked.
-// Verify by checking that errors are reported.
-func (Foo /* ERROR "undeclared" */ ) m() {}
-func (Foo /* ERROR "undeclared" */ ) m(undeclared /* ERROR "undeclared" */ ) {}
-func (Foo /* ERROR "undeclared" */ ) m() int { return "foo" /* ERROR "cannot use .* in return statement" */ }
-
-func (Foo /* ERROR "undeclared" */ ) _() {}
-func (Foo /* ERROR "undeclared" */ ) _(undeclared /* ERROR "undeclared" */ ) {}
-func (Foo /* ERROR "undeclared" */ ) _() int { return "foo" /* ERROR "cannot use .* in return statement" */ }
-
-// Receiver declarations are regular parameter lists;
-// receiver types may use parentheses, and the list
-// may have a trailing comma.
-type T7 struct {}
-
-func (T7) m1() {}
-func ((T7)) m2() {}
-func ((*T7)) m3() {}
-func (x *(T7),) m4() {}
-func (x (*(T7)),) m5() {}
-func (x ((*((T7)))),) m6() {}
-
-// Check that methods with parenthesized receiver are actually present (issue #23130).
-var (
-	_ = T7.m1
-	_ = T7.m2
-	_ = (*T7).m3
-	_ = (*T7).m4
-	_ = (*T7).m5
-	_ = (*T7).m6
-)
diff --git a/src/cmd/compile/internal/types2/testdata/check/decls3.go b/src/cmd/compile/internal/types2/testdata/check/decls3.go
deleted file mode 100644
index 01d4ffe4b5..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/decls3.go
+++ /dev/null
@@ -1,309 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// embedded types
-
-package decls3
-
-import "unsafe"
-import "fmt"
-
-// fields with the same name at the same level cancel each other out
-
-func _() {
-	type (
-		T1 struct { X int }
-		T2 struct { X int }
-		T3 struct { T1; T2 } // X is embedded twice at the same level via T1->X, T2->X
-	)
-
-	var t T3
-	_ = t.X /* ERROR "ambiguous selector t.X" */
-}
-
-func _() {
-	type (
-		T1 struct { X int }
-		T2 struct { T1 }
-		T3 struct { T1 }
-		T4 struct { T2; T3 } // X is embedded twice at the same level via T2->T1->X, T3->T1->X
-	)
-
-	var t T4
-	_ = t.X /* ERROR "ambiguous selector t.X" */
-}
-
-func issue4355() {
-	type (
-	    T1 struct {X int}
-	    T2 struct {T1}
-	    T3 struct {T2}
-	    T4 struct {T2}
-	    T5 struct {T3; T4} // X is embedded twice at the same level via T3->T2->T1->X, T4->T2->T1->X
-	)
-
-	var t T5
-	_ = t.X /* ERROR "ambiguous selector t.X" */
-}
-
-func _() {
-	type State int
-	type A struct{ State }
-	type B struct{ fmt.State }
-	type T struct{ A; B }
-
-	var t T
-	_ = t.State /* ERROR "ambiguous selector t.State" */
-}
-
-// Embedded fields can be predeclared types.
-
-func _() {
-	type T0 struct{
-		int
-		float32
-		f int
-	}
-	var x T0
-	_ = x.int
-	_ = x.float32
-	_ = x.f
-
-	type T1 struct{
-		T0
-	}
-	var y T1
-	_ = y.int
-	_ = y.float32
-	_ = y.f
-}
-
-// Restrictions on embedded field types.
-
-func _() {
-	type I1 interface{}
-	type I2 interface{}
-	type P1 *int
-	type P2 *int
-	type UP unsafe.Pointer
-
-	type T1 struct {
-		I1
-		* /* ERROR "cannot be a pointer to an interface" */ I2
-		* /* ERROR "cannot be a pointer to an interface" */ error
-		P1 /* ERROR "cannot be a pointer" */
-		* /* ERROR "cannot be a pointer" */ P2
-	}
-
-	// unsafe.Pointers are treated like regular pointers when embedded
-	type T2 struct {
-		unsafe /* ERROR "cannot be unsafe.Pointer" */ .Pointer
-		*/* ERROR "cannot be unsafe.Pointer" */ /* ERROR "Pointer redeclared" */ unsafe.Pointer
-		UP /* ERROR "cannot be unsafe.Pointer" */
-		* /* ERROR "cannot be unsafe.Pointer" */  /* ERROR "UP redeclared" */ UP
-	}
-}
-
-// Named types that are pointers.
-
-type S struct{ x int }
-func (*S) m() {}
-type P *S
-
-func _() {
-	var s *S
-	_ = s.x
-	_ = s.m
-
-	var p P
-	_ = p.x
-	_ = p.m /* ERROR "no field or method" */
-	_ = P.m /* ERROR "no field or method" */
-}
-
-// Borrowed from the FieldByName test cases in reflect/all_test.go.
-
-type D1 struct {
-	d int
-}
-type D2 struct {
-	d int
-}
-
-type S0 struct {
-	A, B, C int
-	D1
-	D2
-}
-
-type S1 struct {
-	B int
-	S0
-}
-
-type S2 struct {
-	A int
-	*S1
-}
-
-type S1x struct {
-	S1
-}
-
-type S1y struct {
-	S1
-}
-
-type S3 struct {
-	S1x
-	S2
-	D, E int
-	*S1y
-}
-
-type S4 struct {
-	*S4
-	A int
-}
-
-// The X in S6 and S7 annihilate, but they also block the X in S8.S9.
-type S5 struct {
-	S6
-	S7
-	S8
-}
-
-type S6 struct {
-	X int
-}
-
-type S7 S6
-
-type S8 struct {
-	S9
-}
-
-type S9 struct {
-	X int
-	Y int
-}
-
-// The X in S11.S6 and S12.S6 annihilate, but they also block the X in S13.S8.S9.
-type S10 struct {
-	S11
-	S12
-	S13
-}
-
-type S11 struct {
-	S6
-}
-
-type S12 struct {
-	S6
-}
-
-type S13 struct {
-	S8
-}
-
-func _() {
-	_ = struct{}{}.Foo /* ERROR "no field or method" */
-	_ = S0{}.A
-	_ = S0{}.D /* ERROR "no field or method" */
-	_ = S1{}.A
-	_ = S1{}.B
-	_ = S1{}.S0
-	_ = S1{}.C
-	_ = S2{}.A
-	_ = S2{}.S1
-	_ = S2{}.B
-	_ = S2{}.C
-	_ = S2{}.D /* ERROR "no field or method" */
-	_ = S3{}.S1 /* ERROR "ambiguous selector S3{}.S1" */
-	_ = S3{}.A
-	_ = S3{}.B /* ERROR "ambiguous selector" S3{}.B */
-	_ = S3{}.D
-	_ = S3{}.E
-	_ = S4{}.A
-	_ = S4{}.B /* ERROR "no field or method" */
-	_ = S5{}.X /* ERROR "ambiguous selector S5{}.X" */
-	_ = S5{}.Y
-	_ = S10{}.X /* ERROR "ambiguous selector S10{}.X" */
-	_ = S10{}.Y
-}
-
-// Borrowed from the FieldByName benchmark in reflect/all_test.go.
-
-type R0 struct {
-	*R1
-	*R2
-	*R3
-	*R4
-}
-
-type R1 struct {
-	*R5
-	*R6
-	*R7
-	*R8
-}
-
-type R2 R1
-type R3 R1
-type R4 R1
-
-type R5 struct {
-	*R9
-	*R10
-	*R11
-	*R12
-}
-
-type R6 R5
-type R7 R5
-type R8 R5
-
-type R9 struct {
-	*R13
-	*R14
-	*R15
-	*R16
-}
-
-type R10 R9
-type R11 R9
-type R12 R9
-
-type R13 struct {
-	*R17
-	*R18
-	*R19
-	*R20
-}
-
-type R14 R13
-type R15 R13
-type R16 R13
-
-type R17 struct {
-	*R21
-	*R22
-	*R23
-	*R24
-}
-
-type R18 R17
-type R19 R17
-type R20 R17
-
-type R21 struct {
-	X int
-}
-
-type R22 R21
-type R23 R21
-type R24 R21
-
-var _ = R0{}.X /* ERROR "ambiguous selector R0{}.X" */
\ No newline at end of file
diff --git a/src/cmd/compile/internal/types2/testdata/check/decls4.go b/src/cmd/compile/internal/types2/testdata/check/decls4.go
deleted file mode 100644
index 2ce180fbbb..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/decls4.go
+++ /dev/null
@@ -1,199 +0,0 @@
-// Copyright 2016 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// type aliases
-
-package decls4
-
-type (
-	T0 [10]int
-	T1 []byte
-	T2 struct {
-		x int
-	}
-	T3 interface{
-		m() T2
-	}
-	T4 func(int, T0) chan T2
-)
-
-type (
-	Ai = int
-	A0 = T0
-	A1 = T1
-	A2 = T2
-	A3 = T3
-	A4 = T4
-
-	A10 = [10]int
-	A11 = []byte
-	A12 = struct {
-		x int
-	}
-	A13 = interface{
-		m() A2
-	}
-	A14 = func(int, A0) chan A2
-)
-
-// check assignment compatibility due to equality of types
-var (
-	xi_ int
-	ai Ai = xi_
-
-	x0 T0
-	a0 A0 = x0
-
-	x1 T1
-	a1 A1 = x1
-
-	x2 T2
-	a2 A2 = x2
-
-	x3 T3
-	a3 A3 = x3
-
-	x4 T4
-	a4 A4 = x4
-)
-
-// alias receiver types
-func (Ai /* ERROR "cannot define new methods on non-local type int" */) m1() {}
-func (T0) m1() {}
-func (A0) m1 /* ERROR already declared */ () {}
-func (A0) m2 () {}
-func (A3 /* ERROR invalid receiver */ ) m1 () {}
-func (A10 /* ERROR invalid receiver */ ) m1() {}
-
-// x0 has methods m1, m2 declared via receiver type names T0 and A0
-var _ interface{ m1(); m2() } = x0
-
-// alias receiver types (test case for issue #23042)
-type T struct{}
-
-var (
-	_ = T.m
-	_ = T{}.m
-	_ interface{m()} = T{}
-)
-
-var (
-	_ = T.n
-	_ = T{}.n
-	_ interface{m(); n()} = T{}
-)
-
-type U = T
-func (U) m() {}
-
-// alias receiver types (long type declaration chains)
-type (
-	V0 = V1
-	V1 = (V2)
-	V2 = ((V3))
-	V3 = T
-)
-
-func (V0) m /* ERROR already declared */ () {}
-func (V1) n() {}
-
-// alias receiver types (invalid due to cycles)
-type (
-	W0 /* ERROR illegal cycle */ = W1
-	W1 = (W2)
-	W2 = ((W0))
-)
-
-func (W0) m() {} // no error expected (due to above cycle error)
-func (W1) n() {}
-
-// alias receiver types (invalid due to builtin underlying type)
-type (
-	B0 = B1
-	B1 = B2
-	B2 = int
-)
-
-func (B0 /* ERROR cannot define new methods on non-local type int */ ) m() {}
-func (B1 /* ERROR cannot define new methods on non-local type int */ ) n() {}
-
-// cycles
-type (
-	C2 /* ERROR illegal cycle */ = C2
-	C3 /* ERROR illegal cycle */ = C4
-	C4 = C3
-	C5 struct {
-		f *C6
-	}
-	C6 = C5
-	C7 /* ERROR illegal cycle */  struct {
-		f C8
-	}
-	C8 = C7
-)
-
-// embedded fields
-var (
-	s0 struct { T0 }
-	s1 struct { A0 } = s0 /* ERROR cannot use */ // embedded field names are different
-)
-
-// embedding and lookup of fields and methods
-func _(s struct{A0}) { s.A0 = x0 }
-
-type eX struct{xf int}
-
-func (eX) xm()
-
-type eY = struct{eX} // field/method set of eY includes xf, xm
-
-type eZ = *struct{eX} // field/method set of eZ includes xf, xm
-
-type eA struct {
-	eX // eX contributes xf, xm to eA
-}
-
-type eA2 struct {
-	*eX // *eX contributes xf, xm to eA
-}
-
-type eB struct {
-	eY // eY contributes xf, xm to eB
-}
-
-type eB2 struct {
-	*eY // *eY contributes xf, xm to eB
-}
-
-type eC struct {
-	eZ // eZ contributes xf, xm to eC
-}
-
-var (
-	_ = eA{}.xf
-	_ = eA{}.xm
-	_ = eA2{}.xf
-	_ = eA2{}.xm
-	_ = eB{}.xf
-	_ = eB{}.xm
-	_ = eB2{}.xf
-	_ = eB2{}.xm
-	_ = eC{}.xf
-	_ = eC{}.xm
-)
-
-// ambiguous selectors due to embedding via type aliases
-type eD struct {
-	eY
-	eZ
-}
-
-var (
-	_ = eD{}.xf /* ERROR ambiguous selector eD{}.xf */
-	_ = eD{}.xm /* ERROR ambiguous selector eD{}.xm */
-)
-
-var (
-	_ interface{ xm() } = eD /* ERROR missing method xm */ {}
-)
\ No newline at end of file
diff --git a/src/cmd/compile/internal/types2/testdata/check/decls5.go b/src/cmd/compile/internal/types2/testdata/check/decls5.go
deleted file mode 100644
index 88d31946da..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/decls5.go
+++ /dev/null
@@ -1,10 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package main
-
-// declarations of main
-const _, main /* ERROR "cannot declare main" */ , _ = 0, 1, 2
-type main /* ERROR "cannot declare main" */ struct{}
-var _, main /* ERROR "cannot declare main" */ int
diff --git a/src/cmd/compile/internal/types2/testdata/check/errors.go b/src/cmd/compile/internal/types2/testdata/check/errors.go
deleted file mode 100644
index 7cdc5fb5ff..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/errors.go
+++ /dev/null
@@ -1,66 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package errors
-
-// Testing precise operand formatting in error messages
-// (matching messages are regular expressions, hence the \'s).
-func f(x int, m map[string]int) {
-	// no values
-	_ = f /* ERROR f\(0, m\) \(no value\) used as value */ (0, m)
-
-	// built-ins
-	_ = println // ERROR println \(built-in\) must be called
-
-	// types
-	_ = complex128 // ERROR complex128 \(type\) is not an expression
-
-	// constants
-	const c1 = 991
-	const c2 float32 = 0.5
-	const c3 = "foo"
-	0 // ERROR 0 \(untyped int constant\) is not used
-	0.5 // ERROR 0.5 \(untyped float constant\) is not used
-	"foo" // ERROR "foo" \(untyped string constant\) is not used
-	c1 // ERROR c1 \(untyped int constant 991\) is not used
-	c2 // ERROR c2 \(constant 0.5 of type float32\) is not used
-	c1 /* ERROR c1 \+ c2 \(constant 991.5 of type float32\) is not used */ + c2
-	c3 // ERROR c3 \(untyped string constant "foo"\) is not used
-
-	// variables
-	x // ERROR x \(variable of type int\) is not used
-
-	// values
-	nil // ERROR nil is not used
-	( /* ERROR \(\*int\)\(nil\) \(value of type \*int\) is not used */ *int)(nil)
-	x /* ERROR x != x \(untyped bool value\) is not used */ != x
-	x /* ERROR x \+ x \(value of type int\) is not used */ + x
-
-	// value, ok's
-	const s = "foo"
-	m /* ERROR m\[s\] \(map index expression of type int\) is not used */ [s]
-}
-
-// Valid ERROR comments can have a variety of forms.
-func _() {
-	0 /* ERROR "0 .* is not used" */
-	0 /* ERROR 0 .* is not used */
-	0 // ERROR "0 .* is not used"
-	0 // ERROR 0 .* is not used
-}
-
-// Don't report spurious errors as a consequence of earlier errors.
-// Add more tests as needed.
-func _() {
-	if err := foo /* ERROR undeclared */ (); err != nil /* no error here */ {}
-}
-
-// Use unqualified names for package-local objects.
-type T struct{}
-var _ int = T /* ERROR value of type T */ {} // use T in error message rather then errors.T
-
-// Don't report errors containing "invalid type" (issue #24182).
-func _(x *missing /* ERROR undeclared name: missing */ ) {
-	x.m() // there shouldn't be an error here referring to *invalid type
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/expr0.go b/src/cmd/compile/internal/types2/testdata/check/expr0.go
deleted file mode 100644
index 19923777df..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/expr0.go
+++ /dev/null
@@ -1,187 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// unary expressions
-
-package expr0 
-
-type mybool bool
-
-var (
-	// bool
-	b0 = true
-	b1 bool = b0
-	b2 = !true
-	b3 = !b1
-	b4 bool = !true
-	b5 bool = !b4
-	b6 = +b0 /* ERROR "not defined" */
-	b7 = -b0 /* ERROR "not defined" */
-	b8 = ^b0 /* ERROR "not defined" */
-	b9 = *b0 /* ERROR "cannot indirect" */
-	b10 = &true /* ERROR "cannot take address" */
-	b11 = &b0
-	b12 = <-b0 /* ERROR "cannot receive" */
-	b13 = & & /* ERROR "cannot take address" */ b0
-
-	// byte
-	_ = byte(0)
-	_ = byte(- /* ERROR "cannot convert" */ 1)
-	_ = - /* ERROR "-byte\(1\) \(constant -1 of type byte\) overflows byte" */ byte(1) // test for issue 11367
-	_ = byte /* ERROR "overflows byte" */ (0) - byte(1)
-
-	// int
-	i0 = 1
-	i1 int = i0
-	i2 = +1
-	i3 = +i0
-	i4 int = +1
-	i5 int = +i4
-	i6 = -1
-	i7 = -i0
-	i8 int = -1
-	i9 int = -i4
-	i10 = !i0 /* ERROR "not defined" */
-	i11 = ^1
-	i12 = ^i0
-	i13 int = ^1
-	i14 int = ^i4
-	i15 = *i0 /* ERROR "cannot indirect" */
-	i16 = &i0
-	i17 = *i16
-	i18 = <-i16 /* ERROR "cannot receive" */
-
-	// uint
-	u0 = uint(1)
-	u1 uint = u0
-	u2 = +1
-	u3 = +u0
-	u4 uint = +1
-	u5 uint = +u4
-	u6 = -1
-	u7 = -u0
-	u8 uint = - /* ERROR "overflows" */ 1
-	u9 uint = -u4
-	u10 = !u0 /* ERROR "not defined" */
-	u11 = ^1
-	u12 = ^i0
-	u13 uint = ^ /* ERROR "overflows" */ 1
-	u14 uint = ^u4
-	u15 = *u0 /* ERROR "cannot indirect" */
-	u16 = &u0
-	u17 = *u16
-	u18 = <-u16 /* ERROR "cannot receive" */
-	u19 = ^uint(0)
-
-	// float64
-	f0 = float64(1)
-	f1 float64 = f0
-	f2 = +1
-	f3 = +f0
-	f4 float64 = +1
-	f5 float64 = +f4
-	f6 = -1
-	f7 = -f0
-	f8 float64 = -1
-	f9 float64 = -f4
-	f10 = !f0 /* ERROR "not defined" */
-	f11 = ^1
-	f12 = ^i0
-	f13 float64 = ^1
-	f14 float64 = ^f4 /* ERROR "not defined" */
-	f15 = *f0 /* ERROR "cannot indirect" */
-	f16 = &f0
-	f17 = *u16
-	f18 = <-u16 /* ERROR "cannot receive" */
-
-	// complex128
-	c0 = complex128(1)
-	c1 complex128 = c0
-	c2 = +1
-	c3 = +c0
-	c4 complex128 = +1
-	c5 complex128 = +c4
-	c6 = -1
-	c7 = -c0
-	c8 complex128 = -1
-	c9 complex128 = -c4
-	c10 = !c0 /* ERROR "not defined" */
-	c11 = ^1
-	c12 = ^i0
-	c13 complex128 = ^1
-	c14 complex128 = ^c4 /* ERROR "not defined" */
-	c15 = *c0 /* ERROR "cannot indirect" */
-	c16 = &c0
-	c17 = *u16
-	c18 = <-u16 /* ERROR "cannot receive" */
-
-	// string
-	s0 = "foo"
-	s1 = +"foo" /* ERROR "not defined" */
-	s2 = -s0 /* ERROR "not defined" */
-	s3 = !s0 /* ERROR "not defined" */
-	s4 = ^s0 /* ERROR "not defined" */
-	s5 = *s4
-	s6 = &s4
-	s7 = *s6
-	s8 = <-s7
-
-	// channel
-	ch chan int
-	rc <-chan float64
-	sc chan <- string
-	ch0 = +ch /* ERROR "not defined" */
-	ch1 = -ch /* ERROR "not defined" */
-	ch2 = !ch /* ERROR "not defined" */
-	ch3 = ^ch /* ERROR "not defined" */
-	ch4 = *ch /* ERROR "cannot indirect" */
-	ch5 = &ch
-	ch6 = *ch5
-	ch7 = <-ch
-	ch8 = <-rc
-	ch9 = <-sc /* ERROR "cannot receive" */
-	ch10, ok = <-ch
-	// ok is of type bool
-	ch11, myok = <-ch
-	_ mybool = myok /* ERROR "cannot use .* in variable declaration" */
-)
-
-// address of composite literals
-type T struct{x, y int}
-
-func f() T { return T{} }
-
-var (
-	_ = &T{1, 2}
-	_ = &[...]int{}
-	_ = &[]int{}
-	_ = &[]int{}
-	_ = &map[string]T{}
-	_ = &(T{1, 2})
-	_ = &((((T{1, 2}))))
-	_ = &f /* ERROR "cannot take address" */ ()
-)
-
-// recursive pointer types
-type P *P
-
-var (
-	p1 P = new(P)
-	p2 P = *p1
-	p3 P = &p2
-)
-
-func g() (a, b int) { return }
-
-func _() {
-	_ = -g /* ERROR 2-valued g */ ()
-	_ = <-g /* ERROR 2-valued g */ ()
-}
-
-// ~ is accepted as unary operator only permitted in interface type elements
-var (
-	_ = ~ /* ERROR cannot use ~ outside of interface or type constraint */ 0
-	_ = ~ /* ERROR cannot use ~ outside of interface or type constraint */ "foo"
-	_ = ~ /* ERROR cannot use ~ outside of interface or type constraint */ i0
-)
diff --git a/src/cmd/compile/internal/types2/testdata/check/expr1.go b/src/cmd/compile/internal/types2/testdata/check/expr1.go
deleted file mode 100644
index 42b95fbb37..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/expr1.go
+++ /dev/null
@@ -1,127 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// binary expressions
-
-package expr1
-
-type mybool bool
-
-func _(x, y bool, z mybool) {
-	x = x || y
-	x = x || true
-	x = x || false
-	x = x && y
-	x = x && true
-	x = x && false
-
-	z = z /* ERROR mismatched types */ || y
-	z = z || true
-	z = z || false
-	z = z /* ERROR mismatched types */ && y
-	z = z && true
-	z = z && false
-}
-
-type myint int
-
-func _(x, y int, z myint) {
-	x = x + 1
-	x = x + 1.0
-	x = x + 1.1 // ERROR truncated to int
-	x = x + y
-	x = x - y
-	x = x * y
-	x = x / y
-	x = x % y
-	x = x << y
-	x = x >> y
-
-	z = z + 1
-	z = z + 1.0
-	z = z + 1.1 // ERROR truncated to int
-	z = z /* ERROR mismatched types */ + y
-	z = z /* ERROR mismatched types */ - y
-	z = z /* ERROR mismatched types */ * y
-	z = z /* ERROR mismatched types */ / y
-	z = z /* ERROR mismatched types */ % y
-	z = z << y
-	z = z >> y
-}
-
-type myuint uint
-
-func _(x, y uint, z myuint) {
-	x = x + 1
-	x = x + - /* ERROR overflows uint */ 1
-	x = x + 1.0
-	x = x + 1.1 // ERROR truncated to uint
-	x = x + y
-	x = x - y
-	x = x * y
-	x = x / y
-	x = x % y
-	x = x << y
-	x = x >> y
-
-	z = z + 1
-	z = x + - /* ERROR overflows uint */ 1
-	z = z + 1.0
-	z = z + 1.1 // ERROR truncated to uint
-	z = z /* ERROR mismatched types */ + y
-	z = z /* ERROR mismatched types */ - y
-	z = z /* ERROR mismatched types */ * y
-	z = z /* ERROR mismatched types */ / y
-	z = z /* ERROR mismatched types */ % y
-	z = z << y
-	z = z >> y
-}
-
-type myfloat64 float64
-
-func _(x, y float64, z myfloat64) {
-	x = x + 1
-	x = x + -1
-	x = x + 1.0
-	x = x + 1.1
-	x = x + y
-	x = x - y
-	x = x * y
-	x = x / y
-	x = x /* ERROR not defined */ % y
-	x = x /* ERROR operand x .* must be integer */ << y
-	x = x /* ERROR operand x .* must be integer */ >> y
-
-	z = z + 1
-	z = z + -1
-	z = z + 1.0
-	z = z + 1.1
-	z = z /* ERROR mismatched types */ + y
-	z = z /* ERROR mismatched types */ - y
-	z = z /* ERROR mismatched types */ * y
-	z = z /* ERROR mismatched types */ / y
-	z = z /* ERROR mismatched types */ % y
-	z = z /* ERROR operand z .* must be integer */ << y
-	z = z /* ERROR operand z .* must be integer */ >> y
-}
-
-type mystring string
-
-func _(x, y string, z mystring) {
-	x = x + "foo"
-	x = x /* ERROR not defined */ - "foo"
-	x = x /* ERROR mismatched types string and untyped int */ + 1
-	x = x + y
-	x = x /* ERROR not defined */ - y
-	x = x /* ERROR mismatched types string and untyped int */* 10
-}
-
-func f() (a, b int) { return }
-
-func _(x int) {
-	_ = f /* ERROR 2-valued f */ () + 1
-	_ = x + f /* ERROR 2-valued f */ ()
-	_ = f /* ERROR 2-valued f */ () + f
-	_ = f /* ERROR 2-valued f */ () + f /* ERROR 2-valued f */ ()
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/expr2.go b/src/cmd/compile/internal/types2/testdata/check/expr2.go
deleted file mode 100644
index 6133dbb42b..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/expr2.go
+++ /dev/null
@@ -1,260 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// comparisons
-
-package expr2
-
-func _bool() {
-	const t = true == true
-	const f = true == false
-	_ = t /* ERROR cannot compare */ < f
-	_ = 0 /* ERROR mismatched types untyped int and untyped bool */ == t
-	var b bool
-	var x, y float32
-	b = x < y
-	_ = b
-	_ = struct{b bool}{x < y}
-}
-
-// corner cases
-var (
-	v0 = nil == nil // ERROR operator == not defined on untyped nil
-)
-
-func arrays() {
-	// basics
-	var a, b [10]int
-	_ = a == b
-	_ = a != b
-	_ = a /* ERROR < not defined */ < b
-	_ = a /* ERROR cannot compare.*mismatched types */ == nil
-
-	type C [10]int
-	var c C
-	_ = a == c
-
-	type D [10]int
-	var d D
-	_ = c /* ERROR mismatched types */ == d
-
-	var e [10]func() int
-	_ = e /* ERROR \[10\]func\(\) int cannot be compared */ == e
-}
-
-func structs() {
-	// basics
-	var s, t struct {
-		x int
-		a [10]float32
-		_ bool
-	}
-	_ = s == t
-	_ = s != t
-	_ = s /* ERROR < not defined */ < t
-	_ = s /* ERROR cannot compare.*mismatched types */ == nil
-
-	type S struct {
-		x int
-		a [10]float32
-		_ bool
-	}
-	type T struct {
-		x int
-		a [10]float32
-		_ bool
-	}
-	var ss S
-	var tt T
-	_ = s == ss
-	_ = ss /* ERROR mismatched types */ == tt
-
-	var u struct {
-		x int
-		a [10]map[string]int
-	}
-	_ = u /* ERROR cannot compare */ == u
-}
-
-func pointers() {
-	// nil
-	_ = nil == nil // ERROR operator == not defined on untyped nil
-	_ = nil != nil // ERROR operator != not defined on untyped nil
-	_ = nil /* ERROR < not defined */ < nil
-	_ = nil /* ERROR <= not defined */ <= nil
-	_ = nil /* ERROR > not defined */ > nil
-	_ = nil /* ERROR >= not defined */ >= nil
-
-	// basics
-	var p, q *int
-	_ = p == q
-	_ = p != q
-
-	_ = p == nil
-	_ = p != nil
-	_ = nil == q
-	_ = nil != q
-
-	_ = p /* ERROR < not defined */ < q
-	_ = p /* ERROR <= not defined */ <= q
-	_ = p /* ERROR > not defined */ > q
-	_ = p /* ERROR >= not defined */ >= q
-
-	// various element types
-	type (
-		S1 struct{}
-		S2 struct{}
-		P1 *S1
-		P2 *S2
-	)
-	var (
-		ps1 *S1
-		ps2 *S2
-		p1 P1
-		p2 P2
-	)
-	_ = ps1 == ps1
-	_ = ps1 /* ERROR mismatched types */ == ps2
-	_ = ps2 /* ERROR mismatched types */ == ps1
-
-	_ = p1 == p1
-	_ = p1 /* ERROR mismatched types */ == p2
-
-	_ = p1 == ps1
-}
-
-func channels() {
-	// basics
-	var c, d chan int
-	_ = c == d
-	_ = c != d
-	_ = c == nil
-	_ = c /* ERROR < not defined */ < d
-
-	// various element types (named types)
-	type (
-		C1 chan int
-		C1r <-chan int
-		C1s chan<- int
-		C2 chan float32
-	)
-	var (
-		c1 C1
-		c1r C1r
-		c1s C1s
-		c1a chan int
-		c2 C2
-	)
-	_ = c1 == c1
-	_ = c1 /* ERROR mismatched types */ == c1r
-	_ = c1 /* ERROR mismatched types */ == c1s
-	_ = c1r /* ERROR mismatched types */ == c1s
-	_ = c1 == c1a
-	_ = c1a == c1
-	_ = c1 /* ERROR mismatched types */ == c2
-	_ = c1a /* ERROR mismatched types */ == c2
-
-	// various element types (unnamed types)
-	var (
-		d1 chan int
-		d1r <-chan int
-		d1s chan<- int
-		d1a chan<- int
-		d2 chan float32
-	)
-	_ = d1 == d1
-	_ = d1 == d1r
-	_ = d1 == d1s
-	_ = d1r /* ERROR mismatched types */ == d1s
-	_ = d1 == d1a
-	_ = d1a == d1
-	_ = d1 /* ERROR mismatched types */ == d2
-	_ = d1a /* ERROR mismatched types */ == d2
-}
-
-// for interfaces test
-type S1 struct{}
-type S11 struct{}
-type S2 struct{}
-func (*S1) m() int
-func (*S11) m() int
-func (*S11) n()
-func (*S2) m() float32
-
-func interfaces() {
-	// basics
-	var i, j interface{ m() int }
-	_ = i == j
-	_ = i != j
-	_ = i == nil
-	_ = i /* ERROR < not defined */ < j
-
-	// various interfaces
-	var ii interface { m() int; n() }
-	var k interface { m() float32 }
-	_ = i == ii
-	_ = i /* ERROR mismatched types */ == k
-
-	// interfaces vs values
-	var s1 S1
-	var s11 S11
-	var s2 S2
-
-	_ = i == 0 /* ERROR cannot convert */
-	_ = i /* ERROR mismatched types */ == s1
-	_ = i == &s1
-	_ = i == &s11
-
-	_ = i /* ERROR mismatched types */ == s2
-	_ = i /* ERROR mismatched types */ == &s2
-
-	// issue #28164
-	// testcase from issue
-	_ = interface{}(nil) == [ /* ERROR slice can only be compared to nil */ ]int(nil)
-
-	// related cases
-	var e interface{}
-	var s []int
-	var x int
-	_ = e == s // ERROR slice can only be compared to nil
-	_ = s /* ERROR slice can only be compared to nil */ == e
-	_ = e /* ERROR operator < not defined on interface */ < x
-	_ = x < e // ERROR operator < not defined on interface
-}
-
-func slices() {
-	// basics
-	var s []int
-	_ = s == nil
-	_ = s != nil
-	_ = s /* ERROR < not defined */ < nil
-
-	// slices are not otherwise comparable
-	_ = s /* ERROR slice can only be compared to nil */ == s
-	_ = s /* ERROR < not defined */ < s
-}
-
-func maps() {
-	// basics
-	var m map[string]int
-	_ = m == nil
-	_ = m != nil
-	_ = m /* ERROR < not defined */ < nil
-
-	// maps are not otherwise comparable
-	_ = m /* ERROR map can only be compared to nil */ == m
-	_ = m /* ERROR < not defined */ < m
-}
-
-func funcs() {
-	// basics
-	var f func(int) float32
-	_ = f == nil
-	_ = f != nil
-	_ = f /* ERROR < not defined */ < nil
-
-	// funcs are not otherwise comparable
-	_ = f /* ERROR func can only be compared to nil */ == f
-	_ = f /* ERROR < not defined */ < f
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/expr3.go b/src/cmd/compile/internal/types2/testdata/check/expr3.go
deleted file mode 100644
index ba6c7dd314..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/expr3.go
+++ /dev/null
@@ -1,564 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package expr3
-
-import "time"
-
-func indexes() {
-	_ = 1 /* ERROR "cannot index" */ [0]
-	_ = indexes /* ERROR "cannot index" */ [0]
-	_ = ( /* ERROR "cannot slice" */ 12 + 3)[1:2]
-
-	var a [10]int
-	_ = a[true /* ERROR "cannot convert" */ ]
-	_ = a["foo" /* ERROR "cannot convert" */ ]
-	_ = a[1.1 /* ERROR "truncated" */ ]
-	_ = a[1.0]
-	_ = a[- /* ERROR "negative" */ 1]
-	_ = a[- /* ERROR "negative" */ 1 :]
-	_ = a[: - /* ERROR "negative" */ 1]
-	_ = a[: /* ERROR "middle index required" */ : /* ERROR "final index required" */ ]
-	_ = a[0: /* ERROR "middle index required" */ : /* ERROR "final index required" */ ]
-	_ = a[0: /* ERROR "middle index required" */ :10]
-	_ = a[:10:10]
-
-	var a0 int
-	a0 = a[0]
-	_ = a0
-	var a1 int32
-	a1 = a /* ERROR "cannot use .* in assignment" */ [1]
-	_ = a1
-
-	_ = a[9]
-	_ = a[10 /* ERROR "index .* out of bounds" */ ]
-	_ = a[1 /* ERROR "overflows" */ <<100]
-	_ = a[1<< /* ERROR "constant shift overflow" */ 1000] // no out-of-bounds follow-on error
-	_ = a[10:]
-	_ = a[:10]
-	_ = a[10:10]
-	_ = a[11 /* ERROR "index .* out of bounds" */ :]
-	_ = a[: 11 /* ERROR "index .* out of bounds" */ ]
-	_ = a[: 1 /* ERROR "overflows" */ <<100]
-	_ = a[:10:10]
-	_ = a[:11 /* ERROR "index .* out of bounds" */ :10]
-	_ = a[:10:11 /* ERROR "index .* out of bounds" */ ]
-	_ = a[10:0 /* ERROR "invalid slice indices" */ :10]
-	_ = a[0:10:0 /* ERROR "invalid slice indices" */ ]
-	_ = a[10:0 /* ERROR "invalid slice indices" */:0]
-	_ = &a /* ERROR "cannot take address" */ [:10]
-
-	pa := &a
-	_ = pa[9]
-	_ = pa[10 /* ERROR "index .* out of bounds" */ ]
-	_ = pa[1 /* ERROR "overflows" */ <<100]
-	_ = pa[10:]
-	_ = pa[:10]
-	_ = pa[10:10]
-	_ = pa[11 /* ERROR "index .* out of bounds" */ :]
-	_ = pa[: 11 /* ERROR "index .* out of bounds" */ ]
-	_ = pa[: 1 /* ERROR "overflows" */ <<100]
-	_ = pa[:10:10]
-	_ = pa[:11 /* ERROR "index .* out of bounds" */ :10]
-	_ = pa[:10:11 /* ERROR "index .* out of bounds" */ ]
-	_ = pa[10:0 /* ERROR "invalid slice indices" */ :10]
-	_ = pa[0:10:0 /* ERROR "invalid slice indices" */ ]
-	_ = pa[10:0 /* ERROR "invalid slice indices" */ :0]
-	_ = &pa /* ERROR "cannot take address" */ [:10]
-
-	var b [0]int
-	_ = b[0 /* ERROR "index .* out of bounds" */ ]
-	_ = b[:]
-	_ = b[0:]
-	_ = b[:0]
-	_ = b[0:0]
-	_ = b[0:0:0]
-	_ = b[1 /* ERROR "index .* out of bounds" */ :0:0]
-
-	var s []int
-	_ = s[- /* ERROR "negative" */ 1]
-	_ = s[- /* ERROR "negative" */ 1 :]
-	_ = s[: - /* ERROR "negative" */ 1]
-	_ = s[0]
-	_ = s[1:2]
-	_ = s[2:1 /* ERROR "invalid slice indices" */ ]
-	_ = s[2:]
-	_ = s[: 1 /* ERROR "overflows" */ <<100]
-	_ = s[1 /* ERROR "overflows" */ <<100 :]
-	_ = s[1 /* ERROR "overflows" */ <<100 : 1 /* ERROR "overflows" */ <<100]
-	_ = s[: /* ERROR "middle index required" */ :  /* ERROR "final index required" */ ]
-	_ = s[:10:10]
-	_ = s[10:0 /* ERROR "invalid slice indices" */ :10]
-	_ = s[0:10:0 /* ERROR "invalid slice indices" */ ]
-	_ = s[10:0 /* ERROR "invalid slice indices" */ :0]
-	_ = &s /* ERROR "cannot take address" */ [:10]
-
-	var m map[string]int
-	_ = m[0 /* ERROR "cannot use .* in map index" */ ]
-	_ = m /* ERROR "cannot slice" */ ["foo" : "bar"]
-	_ = m["foo"]
-	// ok is of type bool
-	type mybool bool
-	var ok mybool
-	_, ok = m["bar"]
-	_ = ok
-	_ = m/* ERROR "mismatched types int and untyped string" */[0 /* ERROR "cannot use 0" */ ] + "foo"
-
-	var t string
-	_ = t[- /* ERROR "negative" */ 1]
-	_ = t[- /* ERROR "negative" */ 1 :]
-	_ = t[: - /* ERROR "negative" */ 1]
-	_ = t[1:2:3 /* ERROR "3-index slice of string" */ ]
-	_ = "foo"[1:2:3 /* ERROR "3-index slice of string" */ ]
-	var t0 byte
-	t0 = t[0]
-	_ = t0
-	var t1 rune
-	t1 = t /* ERROR "cannot use .* in assignment" */ [2]
-	_ = t1
-	_ = ("foo" + "bar")[5]
-	_ = ("foo" + "bar")[6 /* ERROR "index .* out of bounds" */ ]
-
-	const c = "foo"
-	_ = c[- /* ERROR "negative" */ 1]
-	_ = c[- /* ERROR "negative" */ 1 :]
-	_ = c[: - /* ERROR "negative" */ 1]
-	var c0 byte
-	c0 = c[0]
-	_ = c0
-	var c2 float32
-	c2 = c /* ERROR "cannot use .* in assignment" */ [2]
-	_ = c[3 /* ERROR "index .* out of bounds" */ ]
-	_ = ""[0 /* ERROR "index .* out of bounds" */ ]
-	_ = c2
-
-	_ = s[1<<30] // no compile-time error here
-
-	// issue 4913
-	type mystring string
-	var ss string
-	var ms mystring
-	var i, j int
-	ss = "foo"[1:2]
-	ss = "foo"[i:j]
-	ms = "foo" /* ERROR "cannot use .* in assignment" */ [1:2]
-	ms = "foo" /* ERROR "cannot use .* in assignment" */ [i:j]
-	_, _ = ss, ms
-}
-
-type T struct {
-	x int
-	y func()
-}
-
-func (*T) m() {}
-
-func method_expressions() {
-	_ = T.a /* ERROR "no field or method" */
-	_ = T.x /* ERROR "has no method" */
-	_ = T.m /* ERROR "cannot call pointer method m on T" */
-	_ = (*T).m
-
-	var f func(*T) = T.m /* ERROR "cannot call pointer method m on T" */
-	var g func(*T) = (*T).m
-	_, _ = f, g
-
-	_ = T.y /* ERROR "has no method" */
-	_ = (*T).y /* ERROR "has no method" */
-}
-
-func struct_literals() {
-	type T0 struct {
-		a, b, c int
-	}
-
-	type T1 struct {
-		T0
-		a, b int
-		u float64
-		s string
-	}
-
-	// keyed elements
-	_ = T1{}
-	_ = T1{a: 0, 1 /* ERROR "mixture of .* elements" */ }
-	_ = T1{aa /* ERROR "unknown field" */ : 0}
-	_ = T1{1 /* ERROR "invalid field name" */ : 0}
-	_ = T1{a: 0, s: "foo", u: 0, a /* ERROR "duplicate field" */: 10}
-	_ = T1{a: "foo" /* ERROR "cannot use .* in struct literal" */ }
-	_ = T1{c /* ERROR "unknown field" */ : 0}
-	_ = T1{T0: { /* ERROR "missing type" */ }} // struct literal element type may not be elided
-	_ = T1{T0: T0{}}
-	_ = T1{T0 /* ERROR "invalid field name" */ .a: 0}
-
-	// unkeyed elements
-	_ = T0{1, 2, 3}
-	_ = T0{1, b /* ERROR "mixture" */ : 2, 3}
-	_ = T0{1, 2} /* ERROR "too few values" */
-	_ = T0{1, 2, 3, 4  /* ERROR "too many values" */ }
-	_ = T0{1, "foo" /* ERROR "cannot use .* in struct literal" */, 3.4  /* ERROR "cannot use .*\(truncated\)" */}
-
-	// invalid type
-	type P *struct{
-		x int
-	}
-	_ = P /* ERROR "invalid composite literal type" */ {}
-
-	// unexported fields
-	_ = time.Time{}
-	_ = time.Time{sec /* ERROR "unknown field" */ : 0}
-	_ = time.Time{
-		0 /* ERROR implicit assignment to unexported field wall in time.Time literal */,
-		0 /* ERROR implicit assignment */ ,
-		nil /* ERROR implicit assignment */ ,
-	}
-}
-
-func array_literals() {
-	type A0 [0]int
-	_ = A0{}
-	_ = A0{0 /* ERROR "index .* out of bounds" */}
-	_ = A0{0 /* ERROR "index .* out of bounds" */ : 0}
-
-	type A1 [10]int
-	_ = A1{}
-	_ = A1{0, 1, 2}
-	_ = A1{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
-	_ = A1{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 /* ERROR "index .* out of bounds" */ }
-	_ = A1{- /* ERROR "negative" */ 1: 0}
-	_ = A1{8: 8, 9}
-	_ = A1{8: 8, 9, 10 /* ERROR "index .* out of bounds" */ }
-	_ = A1{0, 1, 2, 0 /* ERROR "duplicate index" */ : 0, 3: 3, 4}
-	_ = A1{5: 5, 6, 7, 3: 3, 4}
-	_ = A1{5: 5, 6, 7, 3: 3, 4, 5 /* ERROR "duplicate index" */ }
-	_ = A1{10 /* ERROR "index .* out of bounds" */ : 10, 10 /* ERROR "index .* out of bounds" */ : 10}
-	_ = A1{5: 5, 6, 7, 3: 3, 1 /* ERROR "overflows" */ <<100: 4, 5 /* ERROR "duplicate index" */ }
-	_ = A1{5: 5, 6, 7, 4: 4, 1 /* ERROR "overflows" */ <<100: 4}
-	_ = A1{2.0}
-	_ = A1{2.1 /* ERROR "truncated" */ }
-	_ = A1{"foo" /* ERROR "cannot use .* in array or slice literal" */ }
-
-	// indices must be integer constants
-	i := 1
-	const f = 2.1
-	const s = "foo"
-	_ = A1{i /* ERROR "index i must be integer constant" */ : 0}
-	_ = A1{f /* ERROR "truncated" */ : 0}
-	_ = A1{s /* ERROR "cannot convert" */ : 0}
-
-	a0 := [...]int{}
-	assert(len(a0) == 0)
-
-	a1 := [...]int{0, 1, 2}
-	assert(len(a1) == 3)
-	var a13 [3]int
-	var a14 [4]int
-	a13 = a1
-	a14 = a1 /* ERROR "cannot use .* in assignment" */
-	_, _ = a13, a14
-
-	a2 := [...]int{- /* ERROR "negative" */ 1: 0}
-	_ = a2
-
-	a3 := [...]int{0, 1, 2, 0 /* ERROR "duplicate index" */ : 0, 3: 3, 4}
-	assert(len(a3) == 5) // somewhat arbitrary
-
-	a4 := [...]complex128{0, 1, 2, 1<<10-2: -1i, 1i, 400: 10, 12, 14}
-	assert(len(a4) == 1024)
-
-	// composite literal element types may be elided
-	type T []int
-	_ = [10]T{T{}, {}, 5: T{1, 2, 3}, 7: {1, 2, 3}}
-	a6 := [...]T{T{}, {}, 5: T{1, 2, 3}, 7: {1, 2, 3}}
-	assert(len(a6) == 8)
-
-	// recursively so
-	_ = [10][10]T{{}, [10]T{{}}, {{1, 2, 3}}}
-
-	// from the spec
-	type Point struct { x, y float32 }
-	_ = [...]Point{Point{1.5, -3.5}, Point{0, 0}}
-	_ = [...]Point{{1.5, -3.5}, {0, 0}}
-	_ = [][]int{[]int{1, 2, 3}, []int{4, 5}}
-	_ = [][]int{{1, 2, 3}, {4, 5}}
-	_ = [...]*Point{&Point{1.5, -3.5}, &Point{0, 0}}
-	_ = [...]*Point{{1.5, -3.5}, {0, 0}}
-}
-
-func slice_literals() {
-	type S0 []int
-	_ = S0{}
-	_ = S0{0, 1, 2}
-	_ = S0{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
-	_ = S0{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
-	_ = S0{- /* ERROR "negative" */ 1: 0}
-	_ = S0{8: 8, 9}
-	_ = S0{8: 8, 9, 10}
-	_ = S0{0, 1, 2, 0 /* ERROR "duplicate index" */ : 0, 3: 3, 4}
-	_ = S0{5: 5, 6, 7, 3: 3, 4}
-	_ = S0{5: 5, 6, 7, 3: 3, 4, 5 /* ERROR "duplicate index" */ }
-	_ = S0{10: 10, 10 /* ERROR "duplicate index" */ : 10}
-	_ = S0{5: 5, 6, 7, 3: 3, 1 /* ERROR "overflows" */ <<100: 4, 5 /* ERROR "duplicate index" */ }
-	_ = S0{5: 5, 6, 7, 4: 4, 1 /* ERROR "overflows" */ <<100: 4}
-	_ = S0{2.0}
-	_ = S0{2.1 /* ERROR "truncated" */ }
-	_ = S0{"foo" /* ERROR "cannot use .* in array or slice literal" */ }
-
-	// indices must be resolved correctly
-	const index1 = 1
-	_ = S0{index1: 1}
-	_ = S0{index2: 2}
-	_ = S0{index3 /* ERROR "undeclared name" */ : 3}
-
-	// indices must be integer constants
-	i := 1
-	const f = 2.1
-	const s = "foo"
-	_ = S0{i /* ERROR "index i must be integer constant" */ : 0}
-	_ = S0{f /* ERROR "truncated" */ : 0}
-	_ = S0{s /* ERROR "cannot convert" */ : 0}
-
-	// composite literal element types may be elided
-	type T []int
-	_ = []T{T{}, {}, 5: T{1, 2, 3}, 7: {1, 2, 3}}
-	_ = [][]int{{1, 2, 3}, {4, 5}}
-
-	// recursively so
-	_ = [][]T{{}, []T{{}}, {{1, 2, 3}}}
-
-	// issue 17954
-	type T0 *struct { s string }
-	_ = []T0{{}}
-	_ = []T0{{"foo"}}
-
-	type T1 *struct{ int }
-	_ = []T1{}
-	_ = []T1{{0}, {1}, {2}}
-
-	type T2 T1
-	_ = []T2{}
-	_ = []T2{{0}, {1}, {2}}
-
-	_ = map[T0]T2{}
-	_ = map[T0]T2{{}: {}}
-}
-
-const index2 int = 2
-
-type N int
-func (N) f() {}
-
-func map_literals() {
-	type M0 map[string]int
-	type M1 map[bool]int
-	type M2 map[*int]int
-
-	_ = M0{}
-	_ = M0{1 /* ERROR "missing key" */ }
-	_ = M0{1 /* ERROR "cannot use .* in map literal" */ : 2}
-	_ = M0{"foo": "bar" /* ERROR "cannot use .* in map literal" */ }
-	_ = M0{"foo": 1, "bar": 2, "foo" /* ERROR "duplicate key" */ : 3 }
-
-	_ = map[interface{}]int{2: 1, 2 /* ERROR "duplicate key" */ : 1}
-	_ = map[interface{}]int{int(2): 1, int16(2): 1}
-	_ = map[interface{}]int{int16(2): 1, int16 /* ERROR "duplicate key" */ (2): 1}
-
-	type S string
-
-	_ = map[interface{}]int{"a": 1, "a" /* ERROR "duplicate key" */ : 1}
-	_ = map[interface{}]int{"a": 1, S("a"): 1}
-	_ = map[interface{}]int{S("a"): 1, S /* ERROR "duplicate key" */ ("a"): 1}
-	_ = map[interface{}]int{1.0: 1, 1.0 /* ERROR "duplicate key" */: 1}
-	_ = map[interface{}]int{int64(-1): 1, int64 /* ERROR "duplicate key" */ (-1) : 1}
-	_ = map[interface{}]int{^uint64(0): 1, ^ /* ERROR "duplicate key" */ uint64(0): 1}
-	_ = map[interface{}]int{complex(1,2): 1, complex /* ERROR "duplicate key" */ (1,2) : 1}
-
-	type I interface {
-		f()
-	}
-
-	_ = map[I]int{N(0): 1, N(2): 1}
-	_ = map[I]int{N(2): 1, N /* ERROR "duplicate key" */ (2): 1}
-
-	// map keys must be resolved correctly
-	key1 := "foo"
-	_ = M0{key1: 1}
-	_ = M0{key2: 2}
-	_ = M0{key3 /* ERROR "undeclared name" */ : 2}
-
-	var value int
-	_ = M1{true: 1, false: 0}
-	_ = M2{nil: 0, &value: 1}
-
-	// composite literal element types may be elided
-	type T [2]int
-	_ = map[int]T{0: T{3, 4}, 1: {5, 6}}
-
-	// recursively so
-	_ = map[int][]T{0: {}, 1: {{}, T{1, 2}}}
-
-	// composite literal key types may be elided
-	_ = map[T]int{T{3, 4}: 0, {5, 6}: 1}
-
-	// recursively so
-	_ = map[[2]T]int{{}: 0, {{}}: 1, [2]T{{}}: 2, {T{1, 2}}: 3}
-
-	// composite literal element and key types may be elided
-	_ = map[T]T{{}: {}, {1, 2}: T{3, 4}, T{4, 5}: {}}
-	_ = map[T]M0{{} : {}, T{1, 2}: M0{"foo": 0}, {1, 3}: {"foo": 1}}
-
-	// recursively so
-	_ = map[[2]T][]T{{}: {}, {{}}: {{}, T{1, 2}}, [2]T{{}}: nil, {T{1, 2}}: {{}, {}}}
-
-	// from the spec
-	type Point struct { x, y float32 }
-	_ = map[string]Point{"orig": {0, 0}}
-	_ = map[*Point]string{{0, 0}: "orig"}
-
-	// issue 17954
-	type T0 *struct{ s string }
-	type T1 *struct{ int }
-	type T2 T1
-
-	_ = map[T0]T2{}
-	_ = map[T0]T2{{}: {}}
-}
-
-var key2 string = "bar"
-
-type I interface {
-	m()
-}
-
-type I2 interface {
-	m(int)
-}
-
-type T1 struct{}
-type T2 struct{}
-
-func (T2) m(int) {}
-
-type mybool bool
-
-func type_asserts() {
-	var x int
-	_ = x /* ERROR "not an interface" */ .(int)
-
-	var e interface{}
-	var ok bool
-	x, ok = e.(int)
-	_ = ok
-
-	// ok value is of type bool
-	var myok mybool
-	_, myok = e.(int)
-	_ = myok
-
-	var t I
-	_ = t /* ERROR "use of .* outside type switch" */ .(type)
-	_ = t /* ERROR "m has pointer receiver" */ .(T)
-	_ = t.(*T)
-	_ = t /* ERROR "missing method m" */ .(T1)
-	_ = t /* ERROR "wrong type for method m" */ .(T2)
-	_ = t /* STRICT "wrong type for method m" */ .(I2) // only an error in strict mode (issue 8561)
-
-	// e doesn't statically have an m, but may have one dynamically.
-	_ = e.(I2)
-}
-
-func f0() {}
-func f1(x int) {}
-func f2(u float32, s string) {}
-func fs(s []byte) {}
-func fv(x ...int) {}
-func fi(x ... interface{}) {}
-func (T) fm(x ...int)
-
-func g0() {}
-func g1() int { return 0}
-func g2() (u float32, s string) { return }
-func gs() []byte { return nil }
-
-func _calls() {
-	var x int
-	var y float32
-	var s []int
-
-	f0()
-	_ = f0 /* ERROR "used as value" */ ()
-	f0(g0 /* ERROR "too many arguments" */ )
-
-	f1(0)
-	f1(x)
-	f1(10.0)
-	f1() /* ERROR "not enough arguments in call to f1\n\thave \(\)\n\twant \(int\)" */
-	f1(x, y /* ERROR "too many arguments in call to f1\n\thave \(int, float32\)\n\twant \(int\)" */ )
-	f1(s /* ERROR "cannot use .* in argument" */ )
-	f1(x ... /* ERROR "cannot use ..." */ )
-	f1(g0 /* ERROR "used as value" */ ())
-	f1(g1())
-	f1(g2 /* ERROR "too many arguments in call to f1\n\thave \(float32, string\)\n\twant \(int\)" */ ())
-
-	f2() /* ERROR "not enough arguments in call to f2\n\thave \(\)\n\twant \(float32, string\)" */
-	f2(3.14) /* ERROR "not enough arguments in call to f2\n\thave \(number\)\n\twant \(float32, string\)" */
-	f2(3.14, "foo")
-	f2(x /* ERROR "cannot use .* in argument" */ , "foo")
-	f2(g0 /* ERROR "used as value" */ ())
-	f2(g1()) /* ERROR "not enough arguments in call to f2\n\thave \(int\)\n\twant \(float32, string\)" */
-	f2(g2())
-
-	fs() /* ERROR "not enough arguments" */
-	fs(g0 /* ERROR "used as value" */ ())
-	fs(g1 /* ERROR "cannot use .* in argument" */ ())
-	fs(g2 /* ERROR "too many arguments" */ ())
-	fs(gs())
-
-	fv()
-	fv(1, 2.0, x)
-	fv(s /* ERROR "cannot use .* in argument" */ )
-	fv(s...)
-	fv(x /* ERROR "cannot use" */ ...)
-	fv(1, s /* ERROR "too many arguments" */ ...)
-	fv(gs /* ERROR "cannot use .* in argument" */ ())
-	fv(gs /* ERROR "cannot use .* in argument" */ ()...)
-
-	var t T
-	t.fm()
-	t.fm(1, 2.0, x)
-	t.fm(s /* ERROR "cannot use .* in argument" */ )
-	t.fm(g1())
-	t.fm(1, s /* ERROR "too many arguments" */ ...)
-	t.fm(gs /* ERROR "cannot use .* in argument" */ ())
-	t.fm(gs /* ERROR "cannot use .* in argument" */ ()...)
-
-	T.fm(t, )
-	T.fm(t, 1, 2.0, x)
-	T.fm(t, s /* ERROR "cannot use .* in argument" */ )
-	T.fm(t, g1())
-	T.fm(t, 1, s /* ERROR "too many arguments" */ ...)
-	T.fm(t, gs /* ERROR "cannot use .* in argument" */ ())
-	T.fm(t, gs /* ERROR "cannot use .* in argument" */ ()...)
-
-	var i interface{ fm(x ...int) } = t
-	i.fm()
-	i.fm(1, 2.0, x)
-	i.fm(s /* ERROR "cannot use .* in argument" */ )
-	i.fm(g1())
-	i.fm(1, s /* ERROR "too many arguments" */ ...)
-	i.fm(gs /* ERROR "cannot use .* in argument" */ ())
-	i.fm(gs /* ERROR "cannot use .* in argument" */ ()...)
-
-	fi()
-	fi(1, 2.0, x, 3.14, "foo")
-	fi(g2())
-	fi(0, g2)
-	fi(0, g2 /* ERROR "2-valued g2" */ ())
-}
-
-func issue6344() {
-	type T []interface{}
-	var x T
-	fi(x...) // ... applies also to named slices
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/funcinference.go b/src/cmd/compile/internal/types2/testdata/check/funcinference.go
deleted file mode 100644
index fedf1991dd..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/funcinference.go
+++ /dev/null
@@ -1,104 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package funcInference
-
-import "strconv"
-
-type any interface{}
-
-func f0[A any, B interface{*C}, C interface{*D}, D interface{*A}](A, B, C, D) {}
-func _() {
-	f := f0[string]
-	f("a", nil, nil, nil)
-	f0("a", nil, nil, nil)
-}
-
-func f1[A any, B interface{*A}](A, B) {}
-func _() {
-	f := f1[int]
-	f(int(0), new(int))
-	f1(int(0), new(int))
-}
-
-func f2[A any, B interface{[]A}](A, B) {}
-func _() {
-	f := f2[byte]
-	f(byte(0), []byte{})
-	f2(byte(0), []byte{})
-}
-
-// Embedding stand-alone type parameters is not permitted for now. Disabled.
-// func f3[A any, B interface{~C}, C interface{~*A}](A, B, C)
-// func _() {
-// 	f := f3[int]
-// 	var x int
-// 	f(x, &x, &x)
-// 	f3(x, &x, &x)
-// }
-
-func f4[A any, B interface{[]C}, C interface{*A}](A, B, C) {}
-func _() {
-	f := f4[int]
-	var x int
-	f(x, []*int{}, &x)
-	f4(x, []*int{}, &x)
-}
-
-func f5[A interface{struct{b B; c C}}, B any, C interface{*B}](x B) A { panic(0) }
-func _() {
-	x := f5(1.2)
-	var _ float64 = x.b
-	var _ float64 = *x.c
-}
-
-func f6[A any, B interface{~struct{f []A}}](B) A { panic(0) }
-func _() {
-	x := f6(struct{f []string}{})
-	var _ string = x
-}
-
-func f7[A interface{*B}, B interface{~*A}]() {}
-
-// More realistic examples
-
-func Double[S interface{ ~[]E }, E interface{ ~int | ~int8 | ~int16 | ~int32 | ~int64 }](s S) S {
-	r := make(S, len(s))
-	for i, v := range s {
-		r[i] = v + v
-	}
-	return r
-}
-
-type MySlice []int
-
-var _ = Double(MySlice{1})
-
-// From the draft design.
-
-type Setter[B any] interface {
-	Set(string)
-	*B
-}
-
-func FromStrings[T interface{}, PT Setter[T]](s []string) []T {
-	result := make([]T, len(s))
-	for i, v := range s {
-		// The type of &result[i] is *T which is in the type set
-		// of Setter, so we can convert it to PT.
-		p := PT(&result[i])
-		// PT has a Set method.
-		p.Set(v)
-	}
-	return result
-}
-
-type Settable int
-
-func (p *Settable) Set(s string) {
-	i, _ := strconv.Atoi(s) // real code should not ignore the error
-	*p = Settable(i)
-}
-
-var _ = FromStrings[Settable]([]string{"1", "2"})
diff --git a/src/cmd/compile/internal/types2/testdata/check/go1_12.go b/src/cmd/compile/internal/types2/testdata/check/go1_12.go
deleted file mode 100644
index 56c6d5a4c9..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/go1_12.go
+++ /dev/null
@@ -1,36 +0,0 @@
-// -lang=go1.12
-
-// Copyright 2021 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Check Go language version-specific errors.
-
-package p
-
-// numeric literals
-const (
-	_ = 1_000 // ERROR "underscores in numeric literals requires go1.13 or later"
-	_ = 0b111 // ERROR "binary literals requires go1.13 or later"
-	_ = 0o567 // ERROR "0o/0O-style octal literals requires go1.13 or later"
-	_ = 0xabc // ok
-	_ = 0x0p1 // ERROR "hexadecimal floating-point literals requires go1.13 or later"
-
-	_ = 0B111 // ERROR "binary"
-	_ = 0O567 // ERROR "octal"
-	_ = 0Xabc // ok
-	_ = 0X0P1 // ERROR "hexadecimal floating-point"
-
-	_ = 1_000i // ERROR "underscores"
-	_ = 0b111i // ERROR "binary"
-	_ = 0o567i // ERROR "octal"
-	_ = 0xabci // ERROR "hexadecimal floating-point"
-	_ = 0x0p1i // ERROR "hexadecimal floating-point"
-)
-
-// signed shift counts
-var (
-	s int
-	_ = 1 << s // ERROR "invalid operation: signed shift count s \(variable of type int\) requires go1.13 or later"
-	_ = 1 >> s // ERROR "signed shift count"
-)
diff --git a/src/cmd/compile/internal/types2/testdata/check/go1_13.go b/src/cmd/compile/internal/types2/testdata/check/go1_13.go
deleted file mode 100644
index cc7861d616..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/go1_13.go
+++ /dev/null
@@ -1,23 +0,0 @@
-// -lang=go1.13
-
-// Copyright 2021 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Check Go language version-specific errors.
-
-package p
-
-// interface embedding
-
-type I interface { m() }
-
-type _ interface {
-	m()
-	I // ERROR "duplicate method m"
-}
-
-type _ interface {
-	I
-	I // ERROR "duplicate method m"
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/go1_16.go b/src/cmd/compile/internal/types2/testdata/check/go1_16.go
deleted file mode 100644
index 81b529044c..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/go1_16.go
+++ /dev/null
@@ -1,15 +0,0 @@
-// -lang=go1.16
-
-// Copyright 2021 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Check Go language version-specific errors.
-
-package p
-
-type Slice []byte
-type Array [8]byte
-
-var s Slice
-var p = (*Array)(s /* ERROR requires go1.17 or later */ )
diff --git a/src/cmd/compile/internal/types2/testdata/check/go1_8.go b/src/cmd/compile/internal/types2/testdata/check/go1_8.go
deleted file mode 100644
index 99f2fd4eb2..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/go1_8.go
+++ /dev/null
@@ -1,12 +0,0 @@
-// -lang=go1.8
-
-// Copyright 2021 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Check Go language version-specific errors.
-
-package p
-
-// type alias declarations
-type any = /* ERROR type aliases requires go1.9 or later */ interface{}
diff --git a/src/cmd/compile/internal/types2/testdata/check/gotos.go b/src/cmd/compile/internal/types2/testdata/check/gotos.go
deleted file mode 100644
index 069a94bbbf..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/gotos.go
+++ /dev/null
@@ -1,560 +0,0 @@
-// Copyright 2011 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// This file is a modified copy of $GOROOT/test/goto.go.
-
-package gotos
-
-var (
-	i, n int
-	x    []int
-	c    chan int
-	m    map[int]int
-	s    string
-)
-
-// goto after declaration okay
-func _() {
-	x := 1
-	goto L
-L:
-	_ = x
-}
-
-// goto before declaration okay
-func _() {
-	goto L
-L:
-	x := 1
-	_ = x
-}
-
-// goto across declaration not okay
-func _() {
-	goto L /* ERROR "goto L jumps over variable declaration at line 36" */
-	x := 1
-	_ = x
-L:
-}
-
-// goto across declaration in inner scope okay
-func _() {
-	goto L
-	{
-		x := 1
-		_ = x
-	}
-L:
-}
-
-// goto across declaration after inner scope not okay
-func _() {
-	goto L /* ERROR "goto L jumps over variable declaration at line 58" */
-	{
-		x := 1
-		_ = x
-	}
-	x := 1
-	_ = x
-L:
-}
-
-// goto across declaration in reverse okay
-func _() {
-L:
-	x := 1
-	_ = x
-	goto L
-}
-
-func _() {
-L: L1:
-	x := 1
-	_ = x
-	goto L
-	goto L1
-}
-
-// error shows first offending variable
-func _() {
-	goto L /* ERROR "goto L jumps over variable declaration at line 84" */
-	x := 1
-	_ = x
-	y := 1
-	_ = y
-L:
-}
-
-// goto not okay even if code path is dead
-func _() {
-	goto L /* ERROR "goto L jumps over variable declaration" */
-	x := 1
-	_ = x
-	y := 1
-	_ = y
-	return
-L:
-}
-
-// goto into outer block okay
-func _() {
-	{
-		goto L
-	}
-L:
-}
-
-func _() {
-	{
-		goto L
-		goto L1
-	}
-L: L1:
-}
-
-// goto backward into outer block okay
-func _() {
-L:
-	{
-		goto L
-	}
-}
-
-func _() {
-L: L1:
-	{
-		goto L
-		goto L1
-	}
-}
-
-// goto into inner block not okay
-func _() {
-	goto L /* ERROR "goto L jumps into block" */
-	{
-	L:
-	}
-}
-
-func _() {
-	goto L /* ERROR "goto L jumps into block" */
-	goto L1 /* ERROR "goto L1 jumps into block" */
-	{
-	L: L1:
-	}
-}
-
-// goto backward into inner block still not okay
-func _() {
-	{
-	L:
-	}
-	goto L /* ERROR "goto L jumps into block" */
-}
-
-func _() {
-	{
-	L: L1:
-	}
-	goto L /* ERROR "goto L jumps into block" */
-	goto L1 /* ERROR "goto L1 jumps into block" */
-}
-
-// error shows first (outermost) offending block
-func _() {
-	goto L /* ERROR "goto L jumps into block" */
-	{
-		{
-			{
-			L:
-			}
-		}
-	}
-}
-
-// error prefers block diagnostic over declaration diagnostic
-func _() {
-	goto L /* ERROR "goto L jumps into block" */
-	x := 1
-	_ = x
-	{
-	L:
-	}
-}
-
-// many kinds of blocks, all invalid to jump into or among,
-// but valid to jump out of
-
-// if
-
-func _() {
-L:
-	if true {
-		goto L
-	}
-}
-
-func _() {
-L:
-	if true {
-		goto L
-	} else {
-	}
-}
-
-func _() {
-L:
-	if false {
-	} else {
-		goto L
-	}
-}
-
-func _() {
-	goto L /* ERROR "goto L jumps into block" */
-	if true {
-	L:
-	}
-}
-
-func _() {
-	goto L /* ERROR "goto L jumps into block" */
-	if true {
-	L:
-	} else {
-	}
-}
-
-func _() {
-	goto L /* ERROR "goto L jumps into block" */
-	if true {
-	} else {
-	L:
-	}
-}
-
-func _() {
-	if false {
-	L:
-	} else {
-		goto L /* ERROR "goto L jumps into block" */
-	}
-}
-
-func _() {
-	if true {
-		goto L /* ERROR "goto L jumps into block" */
-	} else {
-	L:
-	}
-}
-
-func _() {
-	if true {
-		goto L /* ERROR "goto L jumps into block" */
-	} else if false {
-	L:
-	}
-}
-
-func _() {
-	if true {
-		goto L /* ERROR "goto L jumps into block" */
-	} else if false {
-	L:
-	} else {
-	}
-}
-
-func _() {
-	if true {
-		goto L /* ERROR "goto L jumps into block" */
-	} else if false {
-	} else {
-	L:
-	}
-}
-
-func _() {
-	if true {
-		goto L /* ERROR "goto L jumps into block" */
-	} else {
-		L:
-	}
-}
-
-func _() {
-	if true {
-		L:
-	} else {
-		goto L /* ERROR "goto L jumps into block" */
-	}
-}
-
-// for
-
-func _() {
-	for {
-		goto L
-	}
-L:
-}
-
-func _() {
-	for {
-		goto L
-	L:
-	}
-}
-
-func _() {
-	for {
-	L:
-	}
-	goto L /* ERROR "goto L jumps into block" */
-}
-
-func _() {
-	for {
-		goto L
-	L1:
-	}
-L:
-	goto L1 /* ERROR "goto L1 jumps into block" */
-}
-
-func _() {
-	for i < n {
-	L:
-	}
-	goto L /* ERROR "goto L jumps into block" */
-}
-
-func _() {
-	for i = 0; i < n; i++ {
-	L:
-	}
-	goto L /* ERROR "goto L jumps into block" */
-}
-
-func _() {
-	for i = range x {
-	L:
-	}
-	goto L /* ERROR "goto L jumps into block" */
-}
-
-func _() {
-	for i = range c {
-	L:
-	}
-	goto L /* ERROR "goto L jumps into block" */
-}
-
-func _() {
-	for i = range m {
-	L:
-	}
-	goto L /* ERROR "goto L jumps into block" */
-}
-
-func _() {
-	for i = range s {
-	L:
-	}
-	goto L /* ERROR "goto L jumps into block" */
-}
-
-// switch
-
-func _() {
-L:
-	switch i {
-	case 0:
-		goto L
-	}
-}
-
-func _() {
-L:
-	switch i {
-	case 0:
-
-	default:
-		goto L
-	}
-}
-
-func _() {
-	switch i {
-	case 0:
-
-	default:
-	L:
-		goto L
-	}
-}
-
-func _() {
-	switch i {
-	case 0:
-
-	default:
-		goto L
-	L:
-	}
-}
-
-func _() {
-	switch i {
-	case 0:
-		goto L
-	L:
-		;
-	default:
-	}
-}
-
-func _() {
-	goto L /* ERROR "goto L jumps into block" */
-	switch i {
-	case 0:
-	L:
-	}
-}
-
-func _() {
-	goto L /* ERROR "goto L jumps into block" */
-	switch i {
-	case 0:
-	L:
-		;
-	default:
-	}
-}
-
-func _() {
-	goto L /* ERROR "goto L jumps into block" */
-	switch i {
-	case 0:
-	default:
-	L:
-	}
-}
-
-func _() {
-	switch i {
-	default:
-		goto L /* ERROR "goto L jumps into block" */
-	case 0:
-	L:
-	}
-}
-
-func _() {
-	switch i {
-	case 0:
-	L:
-		;
-	default:
-		goto L /* ERROR "goto L jumps into block" */
-	}
-}
-
-// select
-// different from switch.  the statement has no implicit block around it.
-
-func _() {
-L:
-	select {
-	case <-c:
-		goto L
-	}
-}
-
-func _() {
-L:
-	select {
-	case c <- 1:
-
-	default:
-		goto L
-	}
-}
-
-func _() {
-	select {
-	case <-c:
-
-	default:
-	L:
-		goto L
-	}
-}
-
-func _() {
-	select {
-	case c <- 1:
-
-	default:
-		goto L
-	L:
-	}
-}
-
-func _() {
-	select {
-	case <-c:
-		goto L
-	L:
-		;
-	default:
-	}
-}
-
-func _() {
-	goto L /* ERROR "goto L jumps into block" */
-	select {
-	case c <- 1:
-	L:
-	}
-}
-
-func _() {
-	goto L /* ERROR "goto L jumps into block" */
-	select {
-	case c <- 1:
-	L:
-		;
-	default:
-	}
-}
-
-func _() {
-	goto L /* ERROR "goto L jumps into block" */
-	select {
-	case <-c:
-	default:
-	L:
-	}
-}
-
-func _() {
-	select {
-	default:
-		goto L /* ERROR "goto L jumps into block" */
-	case <-c:
-	L:
-	}
-}
-
-func _() {
-	select {
-	case <-c:
-	L:
-		;
-	default:
-		goto L /* ERROR "goto L jumps into block" */
-	}
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/importC.go b/src/cmd/compile/internal/types2/testdata/check/importC.go
deleted file mode 100644
index 807802199f..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/importC.go
+++ /dev/null
@@ -1,56 +0,0 @@
-// -fakeImportC
-
-// Copyright 2015 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package importC
-
-import "C"
-import _ /* ERROR cannot rename import "C" */ "C"
-import foo /* ERROR cannot rename import "C" */ "C"
-import . /* ERROR cannot rename import "C" */ "C"
-
-// Test cases extracted from issue #22090.
-
-import "unsafe"
-
-const _ C.int = 0xff // no error due to invalid constant type
-
-type T struct {
-	Name    string
-	Ordinal int
-}
-
-func _(args []T) {
-	var s string
-	for i, v := range args {
-		cname := C.CString(v.Name)
-		args[i].Ordinal = int(C.sqlite3_bind_parameter_index(s, cname)) // no error due to i not being "used"
-		C.free(unsafe.Pointer(cname))
-	}
-}
-
-type CType C.Type
-
-const _ CType = C.X // no error due to invalid constant type
-const _ = C.X
-
-// Test cases extracted from issue #23712.
-
-func _() {
-	var a [C.ArrayLength]byte
-	_ = a[0] // no index out of bounds error here
-}
-
-// Additional tests to verify fix for #23712.
-
-func _() {
-	var a [C.ArrayLength1]byte
-	_ = 1 / len(a) // no division by zero error here and below
-	_ = 1 / cap(a)
-	_ = uint(unsafe.Sizeof(a)) // must not be negative
-
-	var b [C.ArrayLength2]byte
-	a = b // should be valid
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/importdecl0/importdecl0a.go b/src/cmd/compile/internal/types2/testdata/check/importdecl0/importdecl0a.go
deleted file mode 100644
index 5ceb96e1fa..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/importdecl0/importdecl0a.go
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package importdecl0
-
-import ()
-
-import (
-	// we can have multiple blank imports (was bug)
-	_ "math"
-	_ "net/rpc"
-	init /* ERROR "cannot import package as init" */ "fmt"
-	// reflect defines a type "flag" which shows up in the gc export data
-	"reflect"
-	. /* ERROR "imported but not used" */ "reflect"
-)
-
-import "math" /* ERROR "imported but not used" */
-import m /* ERROR "imported but not used as m" */ "math"
-import _ "math"
-
-import (
-	"math/big" /* ERROR "imported but not used" */
-	b /* ERROR "imported but not used" */ "math/big"
-	_ "math/big"
-)
-
-import "fmt"
-import f1 "fmt"
-import f2 "fmt"
-
-// reflect.flag must not be visible in this package
-type flag int
-type _ reflect.flag /* ERROR "not exported" */
-
-// imported package name may conflict with local objects
-type reflect /* ERROR "reflect already declared" */ int
-
-// dot-imported exported objects may conflict with local objects
-type Value /* ERROR "Value already declared through dot-import of package reflect" */ struct{}
-
-var _ = fmt.Println // use "fmt"
-
-func _() {
-	f1.Println() // use "fmt"
-}
-
-func _() {
-	_ = func() {
-		f2.Println() // use "fmt"
-	}
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/importdecl0/importdecl0b.go b/src/cmd/compile/internal/types2/testdata/check/importdecl0/importdecl0b.go
deleted file mode 100644
index 19b55aff76..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/importdecl0/importdecl0b.go
+++ /dev/null
@@ -1,30 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package importdecl0
-
-import "math"
-import m "math"
-
-import . "testing" // declares T in file scope
-import . /* ERROR .unsafe. imported but not used */ "unsafe"
-import . "fmt"     // declares Println in file scope
-
-import (
-	"" /* ERROR invalid import path */
-	"a!b" /* ERROR invalid import path */
-	"abc\xffdef" /* ERROR invalid import path */
-)
-
-// using "math" in this file doesn't affect its use in other files
-const Pi0 = math.Pi
-const Pi1 = m.Pi
-
-type _ T // use "testing"
-
-func _() func() interface{} {
-	return func() interface{} {
-		return Println // use "fmt"
-	}
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/importdecl1/importdecl1a.go b/src/cmd/compile/internal/types2/testdata/check/importdecl1/importdecl1a.go
deleted file mode 100644
index d377c01638..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/importdecl1/importdecl1a.go
+++ /dev/null
@@ -1,22 +0,0 @@
-// Copyright 2014 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Test case for issue 8969.
-
-package importdecl1
-
-import "go/ast"
-import . "unsafe"
-
-var _ Pointer // use dot-imported package unsafe
-
-// Test cases for issue 23914.
-
-type A interface {
-	// Methods m1, m2 must be type-checked in this file scope
-	// even when embedded in an interface in a different
-	// file of the same package.
-	m1() ast.Node
-	m2() Pointer
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/importdecl1/importdecl1b.go b/src/cmd/compile/internal/types2/testdata/check/importdecl1/importdecl1b.go
deleted file mode 100644
index 43a7bcd753..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/importdecl1/importdecl1b.go
+++ /dev/null
@@ -1,11 +0,0 @@
-// Copyright 2014 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package importdecl1
-
-import . /* ERROR .unsafe. imported but not used */ "unsafe"
-
-type B interface {
-	A
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/init0.go b/src/cmd/compile/internal/types2/testdata/check/init0.go
deleted file mode 100644
index 6e8746afb6..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/init0.go
+++ /dev/null
@@ -1,106 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// initialization cycles
-
-package init0
-
-// initialization cycles (we don't know the types)
-const (
-	s0 /* ERROR initialization cycle */ = s0
-
-	x0 /* ERROR initialization cycle */ = y0
-	y0 = x0
-
-	a0 = b0
-	b0 /* ERROR initialization cycle */ = c0
-	c0 = d0
-	d0 = b0
-)
-
-var (
-	s1 /* ERROR initialization cycle */ = s1
-
-	x1 /* ERROR initialization cycle */ = y1
-	y1 = x1
-
-	a1 = b1
-	b1 /* ERROR initialization cycle */ = c1
-	c1 = d1
-	d1 = b1
-)
-
-// initialization cycles (we know the types)
-const (
-	s2 /* ERROR initialization cycle */ int = s2
-
-	x2 /* ERROR initialization cycle */ int = y2
-	y2 = x2
-
-	a2 = b2
-	b2 /* ERROR initialization cycle */ int = c2
-	c2 = d2
-	d2 = b2
-)
-
-var (
-	s3 /* ERROR initialization cycle */ int = s3
-
-	x3 /* ERROR initialization cycle */ int = y3
-	y3 = x3
-
-	a3 = b3
-	b3 /* ERROR initialization cycle */ int = c3
-	c3 = d3
-	d3 = b3
-)
-
-// cycles via struct fields
-
-type S1 struct {
-	f int
-}
-const cx3 S1 /* ERROR invalid constant type */ = S1{cx3.f}
-var vx3 /* ERROR initialization cycle */ S1 = S1{vx3.f}
-
-// cycles via functions
-
-var x4 = x5
-var x5 /* ERROR initialization cycle */ = f1()
-func f1() int { return x5*10 }
-
-var x6, x7 /* ERROR initialization cycle */ = f2()
-var x8 = x7
-func f2() (int, int) { return f3() + f3(), 0 }
-func f3() int { return x8 }
-
-// cycles via function literals
-
-var x9 /* ERROR initialization cycle */ = func() int { return x9 }()
-
-var x10 /* ERROR initialization cycle */ = f4()
-
-func f4() int {
-	_ = func() {
-		_ = x10
-	}
-	return 0
-}
-
-// cycles via method expressions
-
-type T1 struct{}
-
-func (T1) m() bool { _ = x11; return false }
-
-var x11 /* ERROR initialization cycle */ = T1.m(T1{})
-
-// cycles via method values
-
-type T2 struct{}
-
-func (T2) m() bool { _ = x12; return false }
-
-var t1 T2
-var x12 /* ERROR initialization cycle */ = t1.m
diff --git a/src/cmd/compile/internal/types2/testdata/check/init1.go b/src/cmd/compile/internal/types2/testdata/check/init1.go
deleted file mode 100644
index 39ca31466b..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/init1.go
+++ /dev/null
@@ -1,97 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// initialization cycles
-
-package init1
-
-// issue 6683 (marked as WorkingAsIntended)
-
-type T0 struct{}
-
-func (T0) m() int { return y0 }
-
-var x0 = T0{}
-
-var y0 /* ERROR initialization cycle */ = x0.m()
-
-type T1 struct{}
-
-func (T1) m() int { return y1 }
-
-var x1 interface {
-	m() int
-} = T1{}
-
-var y1 = x1.m() // no cycle reported, x1 is of interface type
-
-// issue 6703 (modified)
-
-var x2 /* ERROR initialization cycle */ = T2.m
-
-var y2 = x2
-
-type T2 struct{}
-
-func (T2) m() int {
-	_ = y2
-	return 0
-}
-
-var x3 /* ERROR initialization cycle */ = T3.m(T3{}) // <<<< added (T3{})
-
-var y3 = x3
-
-type T3 struct{}
-
-func (T3) m() int {
-	_ = y3
-	return 0
-}
-
-var x4 /* ERROR initialization cycle */ = T4{}.m // <<<< added {}
-
-var y4 = x4
-
-type T4 struct{}
-
-func (T4) m() int {
-	_ = y4
-	return 0
-}
-
-var x5 /* ERROR initialization cycle */ = T5{}.m() // <<<< added ()
-
-var y5 = x5
-
-type T5 struct{}
-
-func (T5) m() int {
-	_ = y5
-	return 0
-}
-
-// issue 4847
-// simplified test case
-
-var x6 = f6
-var y6 /* ERROR initialization cycle */ = f6
-func f6() { _ = y6 }
-
-// full test case
-
-type (
-      E int
-      S int
-)
-
-type matcher func(s *S) E
-
-func matchList(s *S) E { return matcher(matchAnyFn)(s) }
-
-var foo = matcher(matchList)
-
-var matchAny /* ERROR initialization cycle */ = matcher(matchList)
-
-func matchAnyFn(s *S) (err E) { return matchAny(s) }
\ No newline at end of file
diff --git a/src/cmd/compile/internal/types2/testdata/check/init2.go b/src/cmd/compile/internal/types2/testdata/check/init2.go
deleted file mode 100644
index 614db6c949..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/init2.go
+++ /dev/null
@@ -1,139 +0,0 @@
-// Copyright 2014 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// initialization cycles
-
-package init2
-
-// cycles through functions
-
-func f1() int { _ = x1; return 0 }
-var x1 /* ERROR initialization cycle */ = f1
-
-func f2() int { _ = x2; return 0 }
-var x2 /* ERROR initialization cycle */ = f2()
-
-// cycles through method expressions
-
-type T3 int
-func (T3) m() int { _ = x3; return 0 }
-var x3 /* ERROR initialization cycle */ = T3.m
-
-type T4 int
-func (T4) m() int { _ = x4; return 0 }
-var x4 /* ERROR initialization cycle */ = T4.m(0)
-
-type T3p int
-func (*T3p) m() int { _ = x3p; return 0 }
-var x3p /* ERROR initialization cycle */ = (*T3p).m
-
-type T4p int
-func (*T4p) m() int { _ = x4p; return 0 }
-var x4p /* ERROR initialization cycle */ = (*T4p).m(nil)
-
-// cycles through method expressions of embedded methods
-
-type T5 struct { E5 }
-type E5 int
-func (E5) m() int { _ = x5; return 0 }
-var x5 /* ERROR initialization cycle */ = T5.m
-
-type T6 struct { E6 }
-type E6 int
-func (E6) m() int { _ = x6; return 0 }
-var x6 /* ERROR initialization cycle */ = T6.m(T6{0})
-
-type T5p struct { E5p }
-type E5p int
-func (*E5p) m() int { _ = x5p; return 0 }
-var x5p /* ERROR initialization cycle */ = (*T5p).m
-
-type T6p struct { E6p }
-type E6p int
-func (*E6p) m() int { _ = x6p; return 0 }
-var x6p /* ERROR initialization cycle */ = (*T6p).m(nil)
-
-// cycles through method values
-
-type T7 int
-func (T7) m() int { _ = x7; return 0 }
-var x7 /* ERROR initialization cycle */ = T7(0).m
-
-type T8 int
-func (T8) m() int { _ = x8; return 0 }
-var x8 /* ERROR initialization cycle */ = T8(0).m()
-
-type T7p int
-func (*T7p) m() int { _ = x7p; return 0 }
-var x7p /* ERROR initialization cycle */ = new(T7p).m
-
-type T8p int
-func (*T8p) m() int { _ = x8p; return 0 }
-var x8p /* ERROR initialization cycle */ = new(T8p).m()
-
-type T7v int
-func (T7v) m() int { _ = x7v; return 0 }
-var x7var T7v
-var x7v /* ERROR initialization cycle */ = x7var.m
-
-type T8v int
-func (T8v) m() int { _ = x8v; return 0 }
-var x8var T8v
-var x8v /* ERROR initialization cycle */ = x8var.m()
-
-type T7pv int
-func (*T7pv) m() int { _ = x7pv; return 0 }
-var x7pvar *T7pv
-var x7pv /* ERROR initialization cycle */ = x7pvar.m
-
-type T8pv int
-func (*T8pv) m() int { _ = x8pv; return 0 }
-var x8pvar *T8pv
-var x8pv /* ERROR initialization cycle */ = x8pvar.m()
-
-// cycles through method values of embedded methods
-
-type T9 struct { E9 }
-type E9 int
-func (E9) m() int { _ = x9; return 0 }
-var x9 /* ERROR initialization cycle */ = T9{0}.m
-
-type T10 struct { E10 }
-type E10 int
-func (E10) m() int { _ = x10; return 0 }
-var x10 /* ERROR initialization cycle */ = T10{0}.m()
-
-type T9p struct { E9p }
-type E9p int
-func (*E9p) m() int { _ = x9p; return 0 }
-var x9p /* ERROR initialization cycle */ = new(T9p).m
-
-type T10p struct { E10p }
-type E10p int
-func (*E10p) m() int { _ = x10p; return 0 }
-var x10p /* ERROR initialization cycle */ = new(T10p).m()
-
-type T9v struct { E9v }
-type E9v int
-func (E9v) m() int { _ = x9v; return 0 }
-var x9var T9v
-var x9v /* ERROR initialization cycle */ = x9var.m
-
-type T10v struct { E10v }
-type E10v int
-func (E10v) m() int { _ = x10v; return 0 }
-var x10var T10v
-var x10v /* ERROR initialization cycle */ = x10var.m()
-
-type T9pv struct { E9pv }
-type E9pv int
-func (*E9pv) m() int { _ = x9pv; return 0 }
-var x9pvar *T9pv
-var x9pv /* ERROR initialization cycle */ = x9pvar.m
-
-type T10pv struct { E10pv }
-type E10pv int
-func (*E10pv) m() int { _ = x10pv; return 0 }
-var x10pvar *T10pv
-var x10pv /* ERROR initialization cycle */ = x10pvar.m()
diff --git a/src/cmd/compile/internal/types2/testdata/check/issue25008/issue25008a.go b/src/cmd/compile/internal/types2/testdata/check/issue25008/issue25008a.go
deleted file mode 100644
index cf71ca10e4..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/issue25008/issue25008a.go
+++ /dev/null
@@ -1,15 +0,0 @@
-// Copyright 2018 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package p
-
-import "io"
-
-type A interface {
-        io.Reader
-}
-
-func f(a A) {
-        a.Read(nil)
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/issue25008/issue25008b.go b/src/cmd/compile/internal/types2/testdata/check/issue25008/issue25008b.go
deleted file mode 100644
index f132b7fab3..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/issue25008/issue25008b.go
+++ /dev/null
@@ -1,9 +0,0 @@
-// Copyright 2018 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package p
-
-type B interface {
-    A
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/issues0.go b/src/cmd/compile/internal/types2/testdata/check/issues0.go
deleted file mode 100644
index 95cfa2a910..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/issues0.go
+++ /dev/null
@@ -1,373 +0,0 @@
-// -lang=go1.17
-
-// Copyright 2014 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package p // don't permit non-interface elements in interfaces
-
-import (
-	"fmt"
-	syn "regexp/syntax"
-	t1 "text/template"
-	t2 "html/template"
-)
-
-func issue7035() {
-	type T struct{ X int }
-	_ = func() {
-		fmt.Println() // must refer to imported fmt rather than the fmt below
-	}
-	fmt := new(T)
-	_ = fmt.X
-}
-
-func issue8066() {
-	const (
-		_ = float32(340282356779733661637539395458142568447)
-		_ = float32(340282356779733661637539395458142568448 /* ERROR cannot convert */ )
-	)
-}
-
-// Check that a missing identifier doesn't lead to a spurious error cascade.
-func issue8799a() {
-	x, ok := missing /* ERROR undeclared */ ()
-	_ = !ok
-	_ = x
-}
-
-func issue8799b(x int, ok bool) {
-	x, ok = missing /* ERROR undeclared */ ()
-	_ = !ok
-	_ = x
-}
-
-func issue9182() {
-	type Point C /* ERROR undeclared */ .Point
-	// no error for composite literal based on unknown type
-	_ = Point{x: 1, y: 2}
-}
-
-func f0() (a []int)         { return }
-func f1() (a []int, b int)  { return }
-func f2() (a, b []int)      { return }
-
-func append_([]int, ...int) {}
-
-func issue9473(a []int, b ...int) {
-	// variadic builtin function
-	_ = append(f0())
-	_ = append(f0(), f0()...)
-	_ = append(f1())
-	_ = append(f2 /* ERROR cannot use .* in argument */ ())
-	_ = append(f2()... /* ERROR cannot use ... */ )
-	_ = append(f0(), f1 /* ERROR 2-valued f1 */ ())
-	_ = append(f0(), f2 /* ERROR 2-valued f2 */ ())
-	_ = append(f0(), f1 /* ERROR 2-valued f1 */ ()...)
-	_ = append(f0(), f2 /* ERROR 2-valued f2 */ ()...)
-
-	// variadic user-defined function
-	append_(f0())
-	append_(f0(), f0()...)
-	append_(f1())
-	append_(f2 /* ERROR cannot use .* in argument */ ())
-	append_(f2()... /* ERROR cannot use ... */ )
-	append_(f0(), f1 /* ERROR 2-valued f1 */ ())
-	append_(f0(), f2 /* ERROR 2-valued f2 */ ())
-	append_(f0(), f1 /* ERROR 2-valued f1 */ ()...)
-	append_(f0(), f2 /* ERROR 2-valued f2 */ ()...)
-}
-
-// Check that embedding a non-interface type in an interface results in a good error message.
-func issue10979() {
-	type _ interface {
-		int /* ERROR non-interface type int */
-	}
-	type T struct{}
-	type _ interface {
-		T /* ERROR non-interface type T */
-	}
-	type _ interface {
-		nosuchtype /* ERROR undeclared name: nosuchtype */
-	}
-	type _ interface {
-		fmt.Nosuchtype /* ERROR Nosuchtype not declared by package fmt */
-	}
-	type _ interface {
-		nosuchpkg /* ERROR undeclared name: nosuchpkg */ .Nosuchtype
-	}
-	type I interface {
-		I.m /* ERROR no field or method m */
-		m()
-	}
-}
-
-// issue11347
-// These should not crash.
-var a1, b1 /* ERROR cycle */ , c1 /* ERROR cycle */ b1 = 0 > 0<<""[""[c1]]>c1
-var a2, b2 /* ERROR cycle */ = 0 /* ERROR cannot initialize */ /* ERROR cannot initialize */ > 0<<""[b2]
-var a3, b3 /* ERROR cycle */ = int /* ERROR cannot initialize */ /* ERROR cannot initialize */ (1<<""[b3])
-
-// issue10260
-// Check that error messages explain reason for interface assignment failures.
-type (
-	I0 interface{}
-	I1 interface{ foo() }
-	I2 interface{ foo(x int) }
-	T0 struct{}
-	T1 struct{}
-	T2 struct{}
-)
-
-func (*T1) foo() {}
-func (*T2) foo(x int) {}
-
-func issue10260() {
-	var (
-		i0 I0
-		i1 I1
-		i2 I2
-		t0 *T0
-		t1 *T1
-		t2 *T2
-	)
-
-	var x I1
-	x = T1 /* ERROR cannot use T1{} .* as I1 value in assignment: T1 does not implement I1 \(method foo has pointer receiver\) */ {}
-	_ = x /* ERROR impossible type assertion: x\.\(T1\)\n\tT1 does not implement I1 \(method foo has pointer receiver\) */ .(T1)
-
-	T1{}.foo /* ERROR cannot call pointer method foo on T1 */ ()
-	x.Foo /* ERROR "x.Foo undefined \(type I1 has no field or method Foo, but does have foo\)" */ ()
-
-	_ = i2 /* ERROR impossible type assertion: i2\.\(\*T1\)\n\t\*T1 does not implement I2 \(wrong type for method foo\)\n\t\thave foo\(\)\n\t\twant foo\(x int\) */ .(*T1)
-
-	i1 = i0 /* ERROR cannot use i0 .* as I1 value in assignment: I0 does not implement I1 \(missing method foo\) */
-	i1 = t0 /* ERROR .* t0 .* as I1 .*: \*T0 does not implement I1 \(missing method foo\) */
-	i1 = i2 /* ERROR .* i2 .* as I1 .*: I2 does not implement I1 \(wrong type for method foo\)\n\t\thave foo\(x int\)\n\t\twant foo\(\) */
-	i1 = t2 /* ERROR .* t2 .* as I1 .*: \*T2 does not implement I1 \(wrong type for method foo\)\n\t\thave foo\(x int\)\n\t\twant foo\(\) */
-	i2 = i1 /* ERROR .* i1 .* as I2 .*: I1 does not implement I2 \(wrong type for method foo\)\n\t\thave foo\(\)\n\t\twant foo\(x int\) */
-	i2 = t1 /* ERROR .* t1 .* as I2 .*: \*T1 does not implement I2 \(wrong type for method foo\)\n\t\thave foo\(\)\n\t\twant foo\(x int\) */
-
-	_ = func() I1 { return i0 /* ERROR cannot use i0 .* as I1 value in return statement: I0 does not implement I1 \(missing method foo\) */ }
-	_ = func() I1 { return t0 /* ERROR .* t0 .* as I1 .*: \*T0 does not implement I1 \(missing method foo\) */ }
-	_ = func() I1 { return i2 /* ERROR .* i2 .* as I1 .*: I2 does not implement I1 \(wrong type for method foo\)\n\t\thave foo\(x int\)\n\t\twant foo\(\) */ }
-	_ = func() I1 { return t2 /* ERROR .* t2 .* as I1 .*: \*T2 does not implement I1 \(wrong type for method foo\)\n\t\thave foo\(x int\)\n\t\twant foo\(\) */ }
-	_ = func() I2 { return i1 /* ERROR .* i1 .* as I2 .*: I1 does not implement I2 \(wrong type for method foo\)\n\t\thave foo\(\)\n\t\twant foo\(x int\) */ }
-	_ = func() I2 { return t1 /* ERROR .* t1 .* as I2 .*: \*T1 does not implement I2 \(wrong type for method foo\)\n\t\thave foo\(\)\n\t\twant foo\(x int\) */ }
-
-	// a few more - less exhaustive now
-
-	f := func(I1, I2){}
-	f(i0 /* ERROR missing method foo */ , i1 /* ERROR wrong type for method foo */ )
-
-	_ = [...]I1{i0 /* ERROR cannot use i0 .* as I1 value in array or slice literal: I0 does not implement I1 \(missing method foo\) */ }
-	_ = [...]I1{i2 /* ERROR cannot use i2 .* as I1 value in array or slice literal: I2 does not implement I1 \(wrong type for method foo\)\n\t\thave foo\(x int\)\n\t\twant foo\(\) */ }
-	_ = []I1{i0 /* ERROR missing method foo */ }
-	_ = []I1{i2 /* ERROR wrong type for method foo */ }
-	_ = map[int]I1{0: i0 /* ERROR missing method foo */ }
-	_ = map[int]I1{0: i2 /* ERROR wrong type for method foo */ }
-
-	make(chan I1) <- i0 /* ERROR missing method foo */
-	make(chan I1) <- i2 /* ERROR wrong type for method foo */
-}
-
-// Check that constants representable as integers are in integer form
-// before being used in operations that are only defined on integers.
-func issue14229() {
-	// from the issue
-	const _ = int64(-1<<63) % 1e6
-
-	// related
-	const (
-		a int = 3
-		b = 4.0
-		_ = a / b
-		_ = a % b
-		_ = b / a
-		_ = b % a
-	)
-}
-
-// Check that in a n:1 variable declaration with type and initialization
-// expression the type is distributed to all variables of the lhs before
-// the initialization expression assignment is checked.
-func issue15755() {
-	// from issue
-	var i interface{}
-	type b bool
-	var x, y b = i.(b)
-	_ = x == y
-
-	// related: we should see an error since the result of f1 is ([]int, int)
-	var u, v []int = f1 /* ERROR cannot use f1 */ ()
-	_ = u
-	_ = v
-}
-
-// Test that we don't get "declared but not used"
-// errors in the context of invalid/C objects.
-func issue20358() {
-	var F C /* ERROR "undeclared" */ .F
-	var A C /* ERROR "undeclared" */ .A
-	var S C /* ERROR "undeclared" */ .S
-	type T C /* ERROR "undeclared" */ .T
-	type P C /* ERROR "undeclared" */ .P
-
-	// these variables must be "used" even though
-	// the LHS expressions/types below in which
-	// context they are used are unknown/invalid
-	var f, a, s1, s2, s3, t, p int
-
-	_ = F(f)
-	_ = A[a]
-	_ = S[s1:s2:s3]
-	_ = T{t}
-	_ = P{f: p}
-}
-
-// Test that we don't declare lhs variables in short variable
-// declarations before we type-check function literals on the
-// rhs.
-func issue24026() {
-	f := func() int { f(0) /* must refer to outer f */; return 0 }
-	_ = f
-
-	_ = func() {
-		f := func() { _ = f() /* must refer to outer f */ }
-		_ = f
-	}
-
-	// b and c must not be visible inside function literal
-	a := 0
-	a, b, c := func() (int, int, int) {
-		return a, b /* ERROR undeclared */ , c /* ERROR undeclared */
-	}()
-	_, _ = b, c
-}
-
-func f(int) {} // for issue24026
-
-// Test that we don't report a "missing return statement" error
-// (due to incorrect context when type-checking interfaces).
-func issue24140(x interface{}) int {
-        switch x.(type) {
-        case interface{}:
-                return 0
-        default:
-                panic(0)
-        }
-}
-
-// Test that we don't crash when the 'if' condition is missing.
-func issue25438() {
-	if { /* ERROR missing condition */ }
-	if x := 0; /* ERROR missing condition */ { _ = x }
-	if
-	{ /* ERROR missing condition */ }
-}
-
-// Test that we can embed alias type names in interfaces.
-type issue25301 interface {
-	E
-}
-
-type E = interface {
-	m()
-}
-
-// Test case from issue.
-// cmd/compile reports a cycle as well.
-type issue25301b /* ERROR cycle */ = interface {
-	m() interface{ issue25301b }
-}
-
-type issue25301c interface {
-	notE // ERROR non-interface type struct\{\}
-}
-
-type notE = struct{}
-
-// Test that method declarations don't introduce artificial cycles
-// (issue #26124).
-const CC TT = 1
-type TT int
-func (TT) MM() [CC]TT
-
-// Reduced test case from issue #26124.
-const preloadLimit LNumber = 128
-type LNumber float64
-func (LNumber) assertFunction() *LFunction
-type LFunction struct {
-	GFunction LGFunction
-}
-type LGFunction func(*LState)
-type LState struct {
-	reg *registry
-}
-type registry struct {
-	alloc *allocator
-}
-type allocator struct {
-	_ [int(preloadLimit)]int
-}
-
-// Test that we don't crash when type-checking composite literals
-// containing errors in the type.
-var issue27346 = [][n /* ERROR undeclared */ ]int{
-	0: {},
-}
-
-var issue22467 = map[int][... /* ERROR invalid use of ... */ ]int{0: {}}
-
-// Test that invalid use of ... in parameter lists is recognized
-// (issue #28281).
-func issue28281a(int, int, ...int)
-func issue28281b(a, b int, c ...int)
-func issue28281c(a, b, c ... /* ERROR can only use ... with final parameter */ int)
-func issue28281d(... /* ERROR can only use ... with final parameter */ int, int)
-func issue28281e(a, b, c  ... /* ERROR can only use ... with final parameter */ int, d int)
-func issue28281f(... /* ERROR can only use ... with final parameter */ int, ... /* ERROR can only use ... with final parameter */ int, int)
-func (... /* ERROR can only use ... with final parameter */ TT) f()
-func issue28281g() (... /* ERROR can only use ... with final parameter */ TT)
-
-// Issue #26234: Make various field/method lookup errors easier to read by matching cmd/compile's output
-func issue26234a(f *syn.Prog) {
-	// The error message below should refer to the actual package name (syntax)
-	// not the local package name (syn).
-	f.foo /* ERROR f\.foo undefined \(type \*syntax\.Prog has no field or method foo\) */
-}
-
-type T struct {
-	x int
-	E1
-	E2
-}
-
-type E1 struct{ f int }
-type E2 struct{ f int }
-
-func issue26234b(x T) {
-	_ = x.f /* ERROR ambiguous selector x.f */
-}
-
-func issue26234c() {
-	T.x /* ERROR T.x undefined \(type T has no method x\) */ ()
-}
-
-func issue35895() {
-	// T is defined in this package, don't qualify its name with the package name.
-	var _ T = 0 // ERROR cannot use 0 \(untyped int constant\) as T
-
-	// There is only one package with name syntax imported, only use the (global) package name in error messages.
-	var _ *syn.Prog = 0 // ERROR cannot use 0 \(untyped int constant\) as \*syntax.Prog
-
-	// Because both t1 and t2 have the same global package name (template),
-	// qualify packages with full path name in this case.
-	var _ t1.Template = t2 /* ERROR cannot use .* \(value of type .html/template.\.Template\) as .text/template.\.Template */ .Template{}
-}
-
-func issue42989(s uint) {
-	var m map[int]string
-	delete(m, 1<<s)
-	delete(m, 1.<<s)
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/issues1.go b/src/cmd/compile/internal/types2/testdata/check/issues1.go
deleted file mode 100644
index 41a19ad637..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/issues1.go
+++ /dev/null
@@ -1,250 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// This file contains regression tests for bugs found.
-
-package p
-
-import "io"
-import "context"
-
-func eql[T comparable](x, y T) bool {
-	return x == y
-}
-
-func _[X comparable, Y interface{comparable; m()}]() {
-	var x X
-	var y Y
-	eql(x, y /* ERROR does not match */ ) // interfaces of different types
-	eql(x, x)
-	eql(y, y)
-	eql(y, nil /* ERROR cannot use nil as Y value in argument to eql */ )
-	eql[io /* ERROR does not implement comparable */ .Reader](nil, nil)
-}
-
-// If we have a receiver of pointer to type parameter type (below: *T)
-// we don't have any methods, like for interfaces.
-type C[T any] interface {
-    m()
-}
-
-// using type bound C
-func _[T C[T]](x *T) {
-	x.m /* ERROR x\.m undefined */ ()
-}
-
-// using an interface literal as bound
-func _[T interface{ m() }](x *T) {
-	x.m /* ERROR x\.m undefined */ ()
-}
-
-func f2[_ interface{ m1(); m2() }]() {}
-
-type T struct{}
-func (T) m1()
-func (*T) m2()
-
-func _() {
-	f2[T /* ERROR m2 has pointer receiver */ ]()
-	f2[*T]()
-}
-
-// When a type parameter is used as an argument to instantiate a parameterized
-// type, the type argument's type set must be a subset of the instantiated type
-// parameter's type set.
-type T1[P interface{~uint}] struct{}
-
-func _[P any]() {
-    _ = T1[P /* ERROR P does not implement interface{~uint} */ ]{}
-}
-
-// This is the original (simplified) program causing the same issue.
-type Unsigned interface {
-	~uint
-}
-
-type T2[U Unsigned] struct {
-    s U
-}
-
-func (u T2[U]) Add1() U {
-    return u.s + 1
-}
-
-func NewT2[U any]() T2[U /* ERROR U does not implement Unsigned */ ] {
-    return T2[U /* ERROR U does not implement Unsigned */ ]{}
-}
-
-func _() {
-    u := NewT2[string]()
-    _ = u.Add1()
-}
-
-// When we encounter an instantiated type such as Elem[T] we must
-// not "expand" the instantiation when the type to be instantiated
-// (Elem in this case) is not yet fully set up.
-type Elem[T any] struct {
-	next *Elem[T]
-	list *List[T]
-}
-
-type List[T any] struct {
-	root Elem[T]
-}
-
-func (l *List[T]) Init() {
-	l.root.next = &l.root
-}
-
-// This is the original program causing the same issue.
-type Element2[TElem any] struct {
-	next, prev *Element2[TElem]
-	list *List2[TElem]
-	Value TElem
-}
-
-type List2[TElem any] struct {
-	root Element2[TElem]
-	len  int
-}
-
-func (l *List2[TElem]) Init() *List2[TElem] {
-	l.root.next = &l.root
-	l.root.prev = &l.root
-	l.len = 0
-	return l
-}
-
-// Self-recursive instantiations must work correctly.
-type A[P any] struct { _ *A[P] }
-
-type AB[P any] struct { _ *BA[P] }
-type BA[P any] struct { _ *AB[P] }
-
-// And a variation that also caused a problem with an
-// unresolved underlying type.
-type Element3[TElem any] struct {
-	next, prev *Element3[TElem]
-	list *List3[TElem]
-	Value TElem
-}
-
-func (e *Element3[TElem]) Next() *Element3[TElem] {
-	if p := e.next; e.list != nil && p != &e.list.root {
-		return p
-	}
-	return nil
-}
-
-type List3[TElem any] struct {
-	root Element3[TElem]
-	len  int
-}
-
-// Infinite generic type declarations must lead to an error.
-type inf1[T any] struct{ _ inf1 /* ERROR illegal cycle */ [T] }
-type inf2[T any] struct{ inf2 /* ERROR illegal cycle */ [T] }
-
-// The implementation of conversions T(x) between integers and floating-point
-// numbers checks that both T and x have either integer or floating-point
-// type. When the type of T or x is a type parameter, the respective simple
-// predicate disjunction in the implementation was wrong because if a type set
-// contains both an integer and a floating-point type, the type parameter is
-// neither an integer or a floating-point number.
-func convert[T1, T2 interface{~int | ~uint | ~float32}](v T1) T2 {
-	return T2(v)
-}
-
-func _() {
-	convert[int, uint](5)
-}
-
-// When testing binary operators, for +, the operand types must either be
-// both numeric, or both strings. The implementation had the same problem
-// with this check as the conversion issue above (issue #39623).
-
-func issue39623[T interface{~int | ~string}](x, y T) T {
-	return x + y
-}
-
-// Simplified, from https://go2goplay.golang.org/p/efS6x6s-9NI:
-func Sum[T interface{~int | ~string}](s []T) (sum T) {
-	for _, v := range s {
-		sum += v
-	}
-	return
-}
-
-// Assignability of an unnamed pointer type to a type parameter that
-// has a matching underlying type.
-func _[T interface{}, PT interface{~*T}] (x T) PT {
-    return &x
-}
-
-// Indexing of type parameters containing type parameters in their constraint terms:
-func at[T interface{ ~[]E }, E interface{}](x T, i int) E {
-        return x[i]
-}
-
-// Conversion of a local type to a type parameter.
-func _[T interface{~int}](x T) {
-	type myint int
-	var _ int = int(x)
-	var _ T = 42
-	var _ T = T(myint(42))
-}
-
-// Indexing a type parameter with an array type bound checks length.
-// (Example by mdempsky@.)
-func _[T interface { ~[10]int }](x T) {
-	_ = x[9] // ok
-	_ = x[20 /* ERROR out of bounds */ ]
-}
-
-// Pointer indirection of a type parameter.
-func _[T interface{ ~*int }](p T) int {
-	return *p
-}
-
-// Channel sends and receives on type parameters.
-func _[T interface{ ~chan int }](ch T) int {
-	ch <- 0
-	return <- ch
-}
-
-// Calling of a generic variable.
-func _[T interface{ ~func() }](f T) {
-	f()
-	go f()
-}
-
-type F1 func()
-type F2 func()
-func _[T interface{ func()|F1|F2 }](f T) {
-	f()
-	go f()
-}
-
-// We must compare against the (possibly underlying) types of term list
-// elements when checking if a constraint is satisfied by a type.
-// The underlying type of each term must be computed after the
-// interface has been instantiated as its constraint may contain
-// a type parameter that was substituted with a defined type.
-// Test case from an (originally) failing example.
-
-type sliceOf[E any] interface{ ~[]E }
-
-func append[T interface{}, S sliceOf[T], T2 interface{}](s S, t ...T2) S { panic(0) }
-
-var f           func()
-var cancelSlice []context.CancelFunc
-var _ = append[context.CancelFunc, []context.CancelFunc, context.CancelFunc](cancelSlice, f)
-
-// A generic function must be instantiated with a type, not a value.
-
-func g[T any](T) T { panic(0) }
-
-var _ = g[int]
-var _ = g[nil /* ERROR is not a type */ ]
-var _ = g(0)
diff --git a/src/cmd/compile/internal/types2/testdata/check/labels.go b/src/cmd/compile/internal/types2/testdata/check/labels.go
deleted file mode 100644
index 9f42406965..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/labels.go
+++ /dev/null
@@ -1,207 +0,0 @@
-// Copyright 2011 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// This file is a modified concatenation of the files
-// $GOROOT/test/label.go and $GOROOT/test/label1.go.
-
-package labels
-
-var x int
-
-func f0() {
-L1 /* ERROR "label L1 declared but not used" */ :
-	for {
-	}
-L2 /* ERROR "label L2 declared but not used" */ :
-	select {
-	}
-L3 /* ERROR "label L3 declared but not used" */ :
-	switch {
-	}
-L4 /* ERROR "label L4 declared but not used" */ :
-	if true {
-	}
-L5 /* ERROR "label L5 declared but not used" */ :
-	f0()
-L6:
-	f0()
-L6 /* ERROR "label L6 already declared" */ :
-	f0()
-	if x == 20 {
-		goto L6
-	}
-
-L7:
-	for {
-		break L7
-		break L8 /* ERROR "invalid break label L8" */
-	}
-
-// A label must be directly associated with a switch, select, or
-// for statement; it cannot be the label of a labeled statement.
-
-L7a /* ERROR "declared but not used" */ : L7b:
-	for {
-		break L7a /* ERROR "invalid break label L7a" */
-		continue L7a /* ERROR "invalid continue label L7a" */
-		continue L7b
-	}
-
-L8:
-	for {
-		if x == 21 {
-			continue L8
-			continue L7 /* ERROR "invalid continue label L7" */
-		}
-	}
-
-L9:
-	switch {
-	case true:
-		break L9
-	defalt /* ERROR "label defalt declared but not used" */ :
-	}
-
-L10:
-	select {
-	default:
-		break L10
-		break L9 /* ERROR "invalid break label L9" */
-	}
-
-	goto L10a
-L10a: L10b:
-	select {
-	default:
-		break L10a /* ERROR "invalid break label L10a" */
-		break L10b
-		continue L10b /* ERROR "invalid continue label L10b" */
-	}
-}
-
-func f1() {
-L1:
-	for {
-		if x == 0 {
-			break L1
-		}
-		if x == 1 {
-			continue L1
-		}
-		goto L1
-	}
-
-L2:
-	select {
-	default:
-		if x == 0 {
-			break L2
-		}
-		if x == 1 {
-			continue L2 /* ERROR "invalid continue label L2" */
-		}
-		goto L2
-	}
-
-L3:
-	switch {
-	case x > 10:
-		if x == 11 {
-			break L3
-		}
-		if x == 12 {
-			continue L3 /* ERROR "invalid continue label L3" */
-		}
-		goto L3
-	}
-
-L4:
-	if true {
-		if x == 13 {
-			break L4 /* ERROR "invalid break label L4" */
-		}
-		if x == 14 {
-			continue L4 /* ERROR "invalid continue label L4" */
-		}
-		if x == 15 {
-			goto L4
-		}
-	}
-
-L5:
-	f1()
-	if x == 16 {
-		break L5 /* ERROR "invalid break label L5" */
-	}
-	if x == 17 {
-		continue L5 /* ERROR "invalid continue label L5" */
-	}
-	if x == 18 {
-		goto L5
-	}
-
-	for {
-		if x == 19 {
-			break L1 /* ERROR "invalid break label L1" */
-		}
-		if x == 20 {
-			continue L1 /* ERROR "invalid continue label L1" */
-		}
-		if x == 21 {
-			goto L1
-		}
-	}
-}
-
-// Additional tests not in the original files.
-
-func f2() {
-L1 /* ERROR "label L1 declared but not used" */ :
-	if x == 0 {
-		for {
-			continue L1 /* ERROR "invalid continue label L1" */
-		}
-	}
-}
-
-func f3() {
-L1:
-L2:
-L3:
-	for {
-		break L1 /* ERROR "invalid break label L1" */
-		break L2 /* ERROR "invalid break label L2" */
-		break L3
-		continue L1 /* ERROR "invalid continue label L1" */
-		continue L2 /* ERROR "invalid continue label L2" */
-		continue L3
-		goto L1
-		goto L2
-		goto L3
-	}
-}
-
-// Blank labels are never declared.
-
-func f4() {
-_:
-_: // multiple blank labels are ok
-	goto _ /* ERROR "label _ not declared" */
-}
-
-func f5() {
-_:
-	for {
-		break _ /* ERROR "invalid break label _" */
-		continue _ /* ERROR "invalid continue label _" */
-	}
-}
-
-func f6() {
-_:
-	switch {
-	default:
-		break _ /* ERROR "invalid break label _" */
-	}
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/linalg.go b/src/cmd/compile/internal/types2/testdata/check/linalg.go
deleted file mode 100644
index f02e773dbe..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/linalg.go
+++ /dev/null
@@ -1,82 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package linalg
-
-// Numeric is type bound that matches any numeric type.
-// It would likely be in a constraints package in the standard library.
-type Numeric interface {
-	~int | ~int8 | ~int16 | ~int32 | ~int64 |
-		~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
-		~float32 | ~float64 |
-		~complex64 | ~complex128
-}
-
-func DotProduct[T Numeric](s1, s2 []T) T {
-	if len(s1) != len(s2) {
-		panic("DotProduct: slices of unequal length")
-	}
-	var r T
-	for i := range s1 {
-		r += s1[i] * s2[i]
-	}
-	return r
-}
-
-// NumericAbs matches numeric types with an Abs method.
-type NumericAbs[T any] interface {
-	Numeric
-
-	Abs() T
-}
-
-// AbsDifference computes the absolute value of the difference of
-// a and b, where the absolute value is determined by the Abs method.
-func AbsDifference[T NumericAbs[T]](a, b T) T {
-	d := a - b
-	return d.Abs()
-}
-
-// OrderedNumeric is a type bound that matches numeric types that support the < operator.
-type OrderedNumeric interface {
-	~int | ~int8 | ~int16 | ~int32 | ~int64 |
-		~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
-		~float32 | ~float64
-}
-
-// Complex is a type bound that matches the two complex types, which do not have a < operator.
-type Complex interface {
-	~complex64 | ~complex128
-}
-
-// For now, a lone type parameter is not permitted as RHS in a type declaration (issue #45639).
-// // OrderedAbs is a helper type that defines an Abs method for
-// // ordered numeric types.
-// type OrderedAbs[T OrderedNumeric] T
-// 
-// func (a OrderedAbs[T]) Abs() OrderedAbs[T] {
-// 	if a < 0 {
-// 		return -a
-// 	}
-// 	return a
-// }
-// 
-// // ComplexAbs is a helper type that defines an Abs method for
-// // complex types.
-// type ComplexAbs[T Complex] T
-// 
-// func (a ComplexAbs[T]) Abs() ComplexAbs[T] {
-// 	r := float64(real(a))
-// 	i := float64(imag(a))
-// 	d := math.Sqrt(r * r + i * i)
-// 	return ComplexAbs[T](complex(d, 0))
-// }
-// 
-// func OrderedAbsDifference[T OrderedNumeric](a, b T) T {
-// 	return T(AbsDifference(OrderedAbs[T](a), OrderedAbs[T](b)))
-// }
-// 
-// func ComplexAbsDifference[T Complex](a, b T) T {
-// 	return T(AbsDifference(ComplexAbs[T](a), ComplexAbs[T](b)))
-// }
diff --git a/src/cmd/compile/internal/types2/testdata/check/literals.go b/src/cmd/compile/internal/types2/testdata/check/literals.go
deleted file mode 100644
index 494a465f48..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/literals.go
+++ /dev/null
@@ -1,111 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// This file tests various representations of literals
-// and compares them with literals or constant expressions
-// of equal values.
-
-package literals
-
-func _() {
-	// 0-octals
-	assert(0_123 == 0123)
-	assert(0123_456 == 0123456)
-
-	// decimals
-	assert(1_234 == 1234)
-	assert(1_234_567 == 1234567)
-
-	// hexadecimals
-	assert(0X_0 == 0)
-	assert(0X_1234 == 0x1234)
-	assert(0X_CAFE_f00d == 0xcafef00d)
-
-	// octals
-	assert(0o0 == 0)
-	assert(0o1234 == 01234)
-	assert(0o01234567 == 01234567)
-
-	assert(0O0 == 0)
-	assert(0O1234 == 01234)
-	assert(0O01234567 == 01234567)
-
-	assert(0o_0 == 0)
-	assert(0o_1234 == 01234)
-	assert(0o0123_4567 == 01234567)
-
-	assert(0O_0 == 0)
-	assert(0O_1234 == 01234)
-	assert(0O0123_4567 == 01234567)
-
-	// binaries
-	assert(0b0 == 0)
-	assert(0b1011 == 0xb)
-	assert(0b00101101 == 0x2d)
-
-	assert(0B0 == 0)
-	assert(0B1011 == 0xb)
-	assert(0B00101101 == 0x2d)
-
-	assert(0b_0 == 0)
-	assert(0b10_11 == 0xb)
-	assert(0b_0010_1101 == 0x2d)
-
-	// decimal floats
-	assert(1_2_3. == 123.)
-	assert(0_123. == 123.)
-
-	assert(0_0e0 == 0.)
-	assert(1_2_3e0 == 123.)
-	assert(0_123e0 == 123.)
-
-	assert(0e-0_0 == 0.)
-	assert(1_2_3E+0 == 123.)
-	assert(0123E1_2_3 == 123e123)
-
-	assert(0.e+1 == 0.)
-	assert(123.E-1_0 == 123e-10)
-	assert(01_23.e123 == 123e123)
-
-	assert(.0e-1 == .0)
-	assert(.123E+10 == .123e10)
-	assert(.0123E123 == .0123e123)
-
-	assert(1_2_3.123 == 123.123)
-	assert(0123.01_23 == 123.0123)
-
-	// hexadecimal floats
-	assert(0x0.p+0 == 0.)
-	assert(0Xdeadcafe.p-10 == 0xdeadcafe/1024.0)
-	assert(0x1234.P84 == 0x1234000000000000000000000)
-
-	assert(0x.1p-0 == 1./16)
-	assert(0X.deadcafep4 == 1.0*0xdeadcafe/0x10000000)
-	assert(0x.1234P+12 == 1.0*0x1234/0x10)
-
-	assert(0x0p0 == 0.)
-	assert(0Xdeadcafep+1 == 0x1bd5b95fc)
-	assert(0x1234P-10 == 0x1234/1024.0)
-
-	assert(0x0.0p0 == 0.)
-	assert(0Xdead.cafep+1 == 1.0*0x1bd5b95fc/0x10000)
-	assert(0x12.34P-10 == 1.0*0x1234/0x40000)
-
-	assert(0Xdead_cafep+1 == 0xdeadcafep+1)
-	assert(0x_1234P-10 == 0x1234p-10)
-
-	assert(0X_dead_cafe.p-10 == 0xdeadcafe.p-10)
-	assert(0x12_34.P1_2_3 == 0x1234.p123)
-
-	assert(1_234i == 1234i)
-	assert(1_234_567i == 1234567i)
-
-	assert(0.i == 0i)
-	assert(123.i == 123i)
-	assert(0123.i == 123i)
-
-	assert(0.e+1i == 0i)
-	assert(123.E-1_0i == 123e-10i)
-	assert(01_23.e123i == 123e123i)
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/main0.go b/src/cmd/compile/internal/types2/testdata/check/main0.go
deleted file mode 100644
index f892938d4a..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/main0.go
+++ /dev/null
@@ -1,9 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package main
-
-func main()
-func /* ERROR "no arguments and no return values" */ main /* ERROR redeclared */ (int)
-func /* ERROR "no arguments and no return values" */ main /* ERROR redeclared */ () int
diff --git a/src/cmd/compile/internal/types2/testdata/check/main1.go b/src/cmd/compile/internal/types2/testdata/check/main1.go
deleted file mode 100644
index fb567a07d0..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/main1.go
+++ /dev/null
@@ -1,7 +0,0 @@
-// Copyright 2021 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package main
-
-func main[T /* ERROR "func main must have no type parameters" */ any]() {}
diff --git a/src/cmd/compile/internal/types2/testdata/check/map0.go b/src/cmd/compile/internal/types2/testdata/check/map0.go
deleted file mode 100644
index 814d9539fd..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/map0.go
+++ /dev/null
@@ -1,113 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Package orderedmap provides an ordered map, implemented as a binary tree.
-package orderedmap
-
-// TODO(gri) fix imports for tests
-import "chans" // ERROR could not import
-
-// Map is an ordered map.
-type Map[K, V any] struct {
-	root    *node[K, V]
-	compare func(K, K) int
-}
-
-// node is the type of a node in the binary tree.
-type node[K, V any] struct {
-	key         K
-	val         V
-	left, right *node[K, V]
-}
-
-// New returns a new map.
-func New[K, V any](compare func(K, K) int) *Map[K, V] {
-        return &Map[K, V]{compare: compare}
-}
-
-// find looks up key in the map, and returns either a pointer
-// to the node holding key, or a pointer to the location where
-// such a node would go.
-func (m *Map[K, V]) find(key K) **node[K, V] {
-	pn := &m.root
-	for *pn != nil {
-		switch cmp := m.compare(key, (*pn).key); {
-		case cmp < 0:
-			pn = &(*pn).left
-		case cmp > 0:
-			pn = &(*pn).right
-		default:
-			return pn
-		}
-	}
-	return pn
-}
-
-// Insert inserts a new key/value into the map.
-// If the key is already present, the value is replaced.
-// Returns true if this is a new key, false if already present.
-func (m *Map[K, V]) Insert(key K, val V) bool {
-	pn := m.find(key)
-	if *pn != nil {
-		(*pn).val = val
-		return false
-	}
-        *pn = &node[K, V]{key: key, val: val}
-	return true
-}
-
-// Find returns the value associated with a key, or zero if not present.
-// The found result reports whether the key was found.
-func (m *Map[K, V]) Find(key K) (V, bool) {
-	pn := m.find(key)
-	if *pn == nil {
-		var zero V // see the discussion of zero values, above
-		return zero, false
-	}
-	return (*pn).val, true
-}
-
-// keyValue is a pair of key and value used when iterating.
-type keyValue[K, V any] struct {
-	key K
-	val V
-}
-
-// InOrder returns an iterator that does an in-order traversal of the map.
-func (m *Map[K, V]) InOrder() *Iterator[K, V] {
-	sender, receiver := chans.Ranger[keyValue[K, V]]()
-	var f func(*node[K, V]) bool
-	f = func(n *node[K, V]) bool {
-		if n == nil {
-			return true
-		}
-		// Stop sending values if sender.Send returns false,
-		// meaning that nothing is listening at the receiver end.
-		return f(n.left) &&
-                        sender.Send(keyValue[K, V]{n.key, n.val}) &&
-			f(n.right)
-	}
-	go func() {
-		f(m.root)
-		sender.Close()
-	}()
-	return &Iterator[K, V]{receiver}
-}
-
-// Iterator is used to iterate over the map.
-type Iterator[K, V any] struct {
-	r *chans.Receiver[keyValue[K, V]]
-}
-
-// Next returns the next key and value pair, and a boolean indicating
-// whether they are valid or whether we have reached the end.
-func (it *Iterator[K, V]) Next() (K, V, bool) {
-	keyval, ok := it.r.Next()
-	if !ok {
-		var zerok K
-		var zerov V
-		return zerok, zerov, false
-	}
-	return keyval.key, keyval.val, true
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/map1.go b/src/cmd/compile/internal/types2/testdata/check/map1.go
deleted file mode 100644
index e13bf33fed..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/map1.go
+++ /dev/null
@@ -1,146 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// This file is like map.go2, but instead if importing chans, it contains
-// the necessary functionality at the end of the file.
-
-// Package orderedmap provides an ordered map, implemented as a binary tree.
-package orderedmap
-
-// Map is an ordered map.
-type Map[K, V any] struct {
-	root    *node[K, V]
-	compare func(K, K) int
-}
-
-// node is the type of a node in the binary tree.
-type node[K, V any] struct {
-	key         K
-	val         V
-	left, right *node[K, V]
-}
-
-// New returns a new map.
-func New[K, V any](compare func(K, K) int) *Map[K, V] {
-        return &Map[K, V]{compare: compare}
-}
-
-// find looks up key in the map, and returns either a pointer
-// to the node holding key, or a pointer to the location where
-// such a node would go.
-func (m *Map[K, V]) find(key K) **node[K, V] {
-	pn := &m.root
-	for *pn != nil {
-		switch cmp := m.compare(key, (*pn).key); {
-		case cmp < 0:
-			pn = &(*pn).left
-		case cmp > 0:
-			pn = &(*pn).right
-		default:
-			return pn
-		}
-	}
-	return pn
-}
-
-// Insert inserts a new key/value into the map.
-// If the key is already present, the value is replaced.
-// Returns true if this is a new key, false if already present.
-func (m *Map[K, V]) Insert(key K, val V) bool {
-	pn := m.find(key)
-	if *pn != nil {
-		(*pn).val = val
-		return false
-	}
-	*pn = &node[K, V]{key: key, val: val}
-	return true
-}
-
-// Find returns the value associated with a key, or zero if not present.
-// The found result reports whether the key was found.
-func (m *Map[K, V]) Find(key K) (V, bool) {
-	pn := m.find(key)
-	if *pn == nil {
-		var zero V // see the discussion of zero values, above
-		return zero, false
-	}
-	return (*pn).val, true
-}
-
-// keyValue is a pair of key and value used when iterating.
-type keyValue[K, V any] struct {
-	key K
-	val V
-}
-
-// InOrder returns an iterator that does an in-order traversal of the map.
-func (m *Map[K, V]) InOrder() *Iterator[K, V] {
-	sender, receiver := chans_Ranger[keyValue[K, V]]()
-	var f func(*node[K, V]) bool
-	f = func(n *node[K, V]) bool {
-		if n == nil {
-			return true
-		}
-		// Stop sending values if sender.Send returns false,
-		// meaning that nothing is listening at the receiver end.
-		return f(n.left) &&
-                        sender.Send(keyValue[K, V]{n.key, n.val}) &&
-			f(n.right)
-	}
-	go func() {
-		f(m.root)
-		sender.Close()
-	}()
-	return &Iterator[K, V]{receiver}
-}
-
-// Iterator is used to iterate over the map.
-type Iterator[K, V any] struct {
-	r *chans_Receiver[keyValue[K, V]]
-}
-
-// Next returns the next key and value pair, and a boolean indicating
-// whether they are valid or whether we have reached the end.
-func (it *Iterator[K, V]) Next() (K, V, bool) {
-	keyval, ok := it.r.Next()
-	if !ok {
-		var zerok K
-		var zerov V
-		return zerok, zerov, false
-	}
-	return keyval.key, keyval.val, true
-}
-
-// chans
-
-func chans_Ranger[T any]() (*chans_Sender[T], *chans_Receiver[T]) { panic(0) }
-
-// A sender is used to send values to a Receiver.
-type chans_Sender[T any] struct {
-	values chan<- T
-	done <-chan bool
-}
-
-func (s *chans_Sender[T]) Send(v T) bool {
-	select {
-	case s.values <- v:
-		return true
-	case <-s.done:
-		return false
-	}
-}
-
-func (s *chans_Sender[T]) Close() {
-	close(s.values)
-}
-
-type chans_Receiver[T any] struct {
-	values <-chan T
-	done chan<- bool
-}
-
-func (r *chans_Receiver[T]) Next() (T, bool) {
-	v, ok := <-r.values
-	return v, ok
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/methodsets.go b/src/cmd/compile/internal/types2/testdata/check/methodsets.go
deleted file mode 100644
index b0eb14cf50..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/methodsets.go
+++ /dev/null
@@ -1,214 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package methodsets
-
-type T0 struct {}
-
-func (T0) v0() {}
-func (*T0) p0() {}
-
-type T1 struct {} // like T0 with different method names
-
-func (T1) v1() {}
-func (*T1) p1() {}
-
-type T2 interface {
-	v2()
-	p2()
-}
-
-type T3 struct {
-	T0
-	*T1
-	T2
-}
-
-// Method expressions
-func _() {
-	var (
-		_ func(T0) = T0.v0
-		_ = T0.p0 /* ERROR "cannot call pointer method p0 on T0" */
-
-		_ func (*T0) = (*T0).v0
-		_ func (*T0) = (*T0).p0
-
-		// T1 is like T0
-
-		_ func(T2) = T2.v2
-		_ func(T2) = T2.p2
-
-		_ func(T3) = T3.v0
-		_ func(T3) = T3.p0 /* ERROR "cannot call pointer method p0 on T3" */
-		_ func(T3) = T3.v1
-		_ func(T3) = T3.p1
-		_ func(T3) = T3.v2
-		_ func(T3) = T3.p2
-
-		_ func(*T3) = (*T3).v0
-		_ func(*T3) = (*T3).p0
-		_ func(*T3) = (*T3).v1
-		_ func(*T3) = (*T3).p1
-		_ func(*T3) = (*T3).v2
-		_ func(*T3) = (*T3).p2
-	)
-}
-
-// Method values with addressable receivers
-func _() {
-	var (
-		v0 T0
-		_ func() = v0.v0
-		_ func() = v0.p0
-	)
-
-	var (
-		p0 *T0
-		_ func() = p0.v0
-		_ func() = p0.p0
-	)
-
-	// T1 is like T0
-
-	var (
-		v2 T2
-		_ func() = v2.v2
-		_ func() = v2.p2
-	)
-
-	var (
-		v4 T3
-		_ func() = v4.v0
-		_ func() = v4.p0
-		_ func() = v4.v1
-		_ func() = v4.p1
-		_ func() = v4.v2
-		_ func() = v4.p2
-	)
-
-	var (
-		p4 *T3
-		_ func() = p4.v0
-		_ func() = p4.p0
-		_ func() = p4.v1
-		_ func() = p4.p1
-		_ func() = p4.v2
-		_ func() = p4.p2
-	)
-}
-
-// Method calls with addressable receivers
-func _() {
-	var v0 T0
-	v0.v0()
-	v0.p0()
-
-	var p0 *T0
-	p0.v0()
-	p0.p0()
-
-	// T1 is like T0
-
-	var v2 T2
-	v2.v2()
-	v2.p2()
-
-	var v4 T3
-	v4.v0()
-	v4.p0()
-	v4.v1()
-	v4.p1()
-	v4.v2()
-	v4.p2()
-
-	var p4 *T3
-	p4.v0()
-	p4.p0()
-	p4.v1()
-	p4.p1()
-	p4.v2()
-	p4.p2()
-}
-
-// Method values with value receivers
-func _() {
-	var (
-		_ func() = T0{}.v0
-		_ func() = T0{}.p0 /* ERROR "cannot call pointer method p0 on T0" */
-
-		_ func() = (&T0{}).v0
-		_ func() = (&T0{}).p0
-
-		// T1 is like T0
-
-		// no values for T2
-
-		_ func() = T3{}.v0
-		_ func() = T3{}.p0 /* ERROR "cannot call pointer method p0 on T3" */
-		_ func() = T3{}.v1
-		_ func() = T3{}.p1
-		_ func() = T3{}.v2
-		_ func() = T3{}.p2
-
-		_ func() = (&T3{}).v0
-		_ func() = (&T3{}).p0
-		_ func() = (&T3{}).v1
-		_ func() = (&T3{}).p1
-		_ func() = (&T3{}).v2
-		_ func() = (&T3{}).p2
-	)
-}
-
-// Method calls with value receivers
-func _() {
-	T0{}.v0()
-	T0{}.p0 /* ERROR "cannot call pointer method p0 on T0" */ ()
-
-	(&T0{}).v0()
-	(&T0{}).p0()
-
-	// T1 is like T0
-
-	// no values for T2
-
-	T3{}.v0()
-	T3{}.p0 /* ERROR "cannot call pointer method p0 on T3" */ ()
-	T3{}.v1()
-	T3{}.p1()
-	T3{}.v2()
-	T3{}.p2()
-
-	(&T3{}).v0()
-	(&T3{}).p0()
-	(&T3{}).v1()
-	(&T3{}).p1()
-	(&T3{}).v2()
-	(&T3{}).p2()
-}
-
-// *T has no methods if T is an interface type
-func issue5918() {
-	var (
-		err error
-		_ = err.Error()
-		_ func() string = err.Error
-		_ func(error) string = error.Error
-
-		perr = &err
-		_ = perr.Error /* ERROR "type \*error is pointer to interface, not interface" */ ()
-		_ func() string = perr.Error /* ERROR "type \*error is pointer to interface, not interface" */
-		_ func(*error) string = (*error).Error /* ERROR "type \*error is pointer to interface, not interface" */
-	)
-
-	type T *interface{ m() int }
-	var (
-		x T
-		_ = (*x).m()
-		_ = (*x).m
-
-		_ = x.m /* ERROR "type T is pointer to interface, not interface" */ ()
-		_ = x.m /* ERROR "type T is pointer to interface, not interface" */
-		_ = T.m /* ERROR "type T is pointer to interface, not interface" */
-	)
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/shifts.go b/src/cmd/compile/internal/types2/testdata/check/shifts.go
deleted file mode 100644
index 5cd0182d52..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/shifts.go
+++ /dev/null
@@ -1,399 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package shifts
-
-func shifts0() {
-	// basic constant shifts
-	const (
-		s = 10
-		_ = 0<<0
-		_ = 1<<s
-		_ = 1<<- /* ERROR "negative shift count" */ 1
-		// For the test below we may decide to convert to int
-		// rather than uint and then report a negative shift
-		// count instead, which might be a better error. The
-		// (minor) difference is that this would restrict the
-		// shift count range by half (from all uint values to
-		// the positive int values).
-		// This depends on the exact spec wording which is not
-		// done yet.
-		// TODO(gri) revisit and adjust when spec change is done
-		_ = 1<<- /* ERROR "negative shift count" */ 1.0
-		_ = 1<<1075 /* ERROR "invalid shift" */
-		_ = 2.0<<1
-		_ = 1<<1.0
-		_ = 1<<(1+0i)
-
-		_ int = 2<<s
-		_ float32 = 2<<s
-		_ complex64 = 2<<s
-
-		_ int = 2.0<<s
-		_ float32 = 2.0<<s
-		_ complex64 = 2.0<<s
-
-		_ int = 'a'<<s
-		_ float32 = 'a'<<s
-		_ complex64 = 'a'<<s
-	)
-}
-
-func shifts1() {
-	// basic non-constant shifts
-	var (
-		i int
-		u uint
-
-		_ = 1<<0
-		_ = 1<<i
-		_ = 1<<u
-		_ = 1<<"foo" /* ERROR "cannot convert" */
-		_ = i<<0
-		_ = i<<- /* ERROR "negative shift count" */ 1
-		_ = i<<1.0
-		_ = 1<<(1+0i)
-		_ = 1 /* ERROR "overflows" */ <<100
-
-		_ uint = 1 << 0
-		_ uint = 1 << u
-		_ float32 = 1 /* ERROR "must be integer" */ << u
-
-		// issue #14822
-		_ = 1<<( /* ERROR "overflows uint" */ 1<<64)
-		_ = 1<<( /* ERROR "invalid shift count" */ 1<<64-1)
-
-		// issue #43697
-		_ = u<<( /* ERROR "overflows uint" */ 1<<64)
-		_ = u<<(1<<64-1)
-	)
-}
-
-func shifts2() {
-	// from the spec
-	var (
-		s uint = 33
-		i = 1<<s           // 1 has type int
-		j int32 = 1<<s     // 1 has type int32; j == 0
-		k = uint64(1<<s)   // 1 has type uint64; k == 1<<33
-		m int = 1.0<<s     // 1.0 has type int
-		n = 1.0<<s != i    // 1.0 has type int; n == false if ints are 32bits in size
-		o = 1<<s == 2<<s   // 1 and 2 have type int; o == true if ints are 32bits in size
-		p = 1<<s == 1<<33  // illegal if ints are 32bits in size: 1 has type int, but 1<<33 overflows int
-		u = 1.0 /* ERROR "must be integer" */ <<s         // illegal: 1.0 has type float64, cannot shift
-		u1 = 1.0 /* ERROR "must be integer" */ <<s != 0   // illegal: 1.0 has type float64, cannot shift
-		u2 = 1 /* ERROR "must be integer" */ <<s != 1.0   // illegal: 1 has type float64, cannot shift
-		v float32 = 1 /* ERROR "must be integer" */ <<s   // illegal: 1 has type float32, cannot shift
-		w int64 = 1.0<<33  // 1.0<<33 is a constant shift expression
-	)
-	_, _, _, _, _, _, _, _, _, _, _, _ = i, j, k, m, n, o, p, u, u1, u2, v, w
-}
-
-func shifts3(a int16, b float32) {
-	// random tests
-	var (
-		s uint = 11
-		u = 1 /* ERROR "must be integer" */ <<s + 1.0
-		v complex128 = 1 /* ERROR "must be integer" */ << s + 1.0 /* ERROR "must be integer" */ << s + 1
-	)
-	x := 1.0 /* ERROR "must be integer" */ <<s + 1
-	shifts3(1.0 << s, 1 /* ERROR "must be integer" */ >> s)
-	_, _, _ = u, v, x
-}
-
-func shifts4() {
-	// shifts in comparisons w/ untyped operands
-	var s uint
-
-	_ = 1<<s == 1
-	_ = 1 /* ERROR "integer" */ <<s == 1.
-	_ = 1. /* ERROR "integer" */ <<s == 1
-	_ = 1. /* ERROR "integer" */ <<s == 1.
-
-	_ = 1<<s + 1 == 1
-	_ = 1 /* ERROR "integer" */ <<s + 1 == 1.
-	_ = 1 /* ERROR "integer" */ <<s + 1. == 1
-	_ = 1 /* ERROR "integer" */ <<s + 1. == 1.
-	_ = 1. /* ERROR "integer" */ <<s + 1 == 1
-	_ = 1. /* ERROR "integer" */ <<s + 1 == 1.
-	_ = 1. /* ERROR "integer" */ <<s + 1. == 1
-	_ = 1. /* ERROR "integer" */ <<s + 1. == 1.
-
-	_ = 1<<s == 1<<s
-	_ = 1 /* ERROR "integer" */ <<s == 1. /* ERROR "integer" */ <<s
-	_ = 1. /* ERROR "integer" */ <<s == 1 /* ERROR "integer" */ <<s
-	_ = 1. /* ERROR "integer" */ <<s == 1. /* ERROR "integer" */ <<s
-
-	_ = 1<<s + 1<<s == 1
-	_ = 1 /* ERROR "integer" */ <<s + 1 /* ERROR "integer" */ <<s == 1.
-	_ = 1 /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s == 1
-	_ = 1 /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s == 1.
-	_ = 1. /* ERROR "integer" */ <<s + 1 /* ERROR "integer" */ <<s == 1
-	_ = 1. /* ERROR "integer" */ <<s + 1 /* ERROR "integer" */ <<s == 1.
-	_ = 1. /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s == 1
-	_ = 1. /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s == 1.
-
-	_ = 1<<s + 1<<s == 1<<s + 1<<s
-	_ = 1 /* ERROR "integer" */ <<s + 1 /* ERROR "integer" */ <<s == 1 /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s
-	_ = 1 /* ERROR "integer" */ <<s + 1 /* ERROR "integer" */ <<s == 1. /* ERROR "integer" */ <<s + 1 /* ERROR "integer" */ <<s
-	_ = 1 /* ERROR "integer" */ <<s + 1 /* ERROR "integer" */ <<s == 1. /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s
-	_ = 1 /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s == 1 /* ERROR "integer" */ <<s + 1 /* ERROR "integer" */ <<s
-	_ = 1 /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s == 1 /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s
-	_ = 1 /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s == 1. /* ERROR "integer" */ <<s + 1 /* ERROR "integer" */ <<s
-	_ = 1 /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s == 1. /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s
-	_ = 1. /* ERROR "integer" */ <<s + 1 /* ERROR "integer" */ <<s == 1 /* ERROR "integer" */ <<s + 1 /* ERROR "integer" */ <<s
-	_ = 1. /* ERROR "integer" */ <<s + 1 /* ERROR "integer" */ <<s == 1 /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s
-	_ = 1. /* ERROR "integer" */ <<s + 1 /* ERROR "integer" */ <<s == 1. /* ERROR "integer" */ <<s + 1 /* ERROR "integer" */ <<s
-	_ = 1. /* ERROR "integer" */ <<s + 1 /* ERROR "integer" */ <<s == 1. /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s
-	_ = 1. /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s == 1 /* ERROR "integer" */ <<s + 1 /* ERROR "integer" */ <<s
-	_ = 1. /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s == 1 /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s
-	_ = 1. /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s == 1. /* ERROR "integer" */ <<s + 1 /* ERROR "integer" */ <<s
-	_ = 1. /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s == 1. /* ERROR "integer" */ <<s + 1. /* ERROR "integer" */ <<s
-}
-
-func shifts5() {
-	// shifts in comparisons w/ typed operands
-	var s uint
-	var x int
-
-	_ = 1<<s == x
-	_ = 1.<<s == x
-	_ = 1.1 /* ERROR "int" */ <<s == x
-
-	_ = 1<<s + x == 1
-	_ = 1<<s + x == 1.
-	_ = 1<<s + x == 1.1 /* ERROR "int" */
-	_ = 1.<<s + x == 1
-	_ = 1.<<s + x == 1.
-	_ = 1.<<s + x == 1.1 /* ERROR "int" */
-	_ = 1.1 /* ERROR "int" */ <<s + x == 1
-	_ = 1.1 /* ERROR "int" */ <<s + x == 1.
-	_ = 1.1 /* ERROR "int" */ <<s + x == 1.1
-
-	_ = 1<<s == x<<s
-	_ = 1.<<s == x<<s
-	_ = 1.1  /* ERROR "int" */ <<s == x<<s
-}
-
-func shifts6() {
-	// shifts as operands in non-arithmetic operations and as arguments
-	var a [10]int
-	var s uint
-
-	_ = a[1<<s]
-	_ = a[1.0]
-	_ = a[1.0<<s]
-
-	_ = make([]int, 1.0)
-	_ = make([]int, 1.0<<s)
-	_ = make([]int, 1.1 /* ERROR "must be integer" */ <<s)
-
-	_ = float32(1)
-	_ = float32(1 /* ERROR "must be integer" */ <<s)
-	_ = float32(1.0)
-	_ = float32(1.0 /* ERROR "must be integer" */ <<s)
-	_ = float32(1.1 /* ERROR "must be integer" */ <<s)
-
-	// TODO(gri) Re-enable these tests once types2 has the go/types fixes.
-	//           Issue #52080.
-	// _ = int32(0x80000000 /* ERROR "overflows int32" */ << s)
-	// TODO(rfindley) Eliminate the redundant error here.
-	// _ = int32(( /* ERROR "truncated to int32" */ 0x80000000 /* ERROR "truncated to int32" */ + 0i) << s)
-
-	_ = int(1+0i<<0)
-	// _ = int((1+0i)<<s)
-	// _ = int(1.0<<s)
-	// _ = int(complex(1, 0)<<s)
-	_ = int(float32/* ERROR "must be integer" */(1.0) <<s)
-	_ = int(1.1 /* ERROR must be integer */ <<s)
-	_ = int(( /* ERROR "must be integer" */ 1+1i)  <<s)
-
-	_ = complex(1 /* ERROR "must be integer" */ <<s, 0)
-
-	var b []int
-	_ = append(b, 1<<s)
-	_ = append(b, 1.0<<s)
-	_ = append(b, (1+0i)<<s)
-	_ = append(b, 1.1 /* ERROR "must be integer" */ <<s)
-	_ = append(b, (1 + 0i) <<s)
-	_ = append(b, ( /* ERROR "must be integer" */ 1 + 1i)  <<s)
-
-	_ = complex(1.0 /* ERROR "must be integer" */ <<s, 0)
-	_ = complex(1.1 /* ERROR "must be integer" */ <<s, 0)
-	_ = complex(0, 1.0 /* ERROR "must be integer" */ <<s)
-	_ = complex(0, 1.1 /* ERROR "must be integer" */ <<s)
-
-	// TODO(gri) The delete below is not type-checked correctly yet.
-	// var m1 map[int]string
-	// delete(m1, 1<<s)
-}
-
-func shifts7() {
-	// shifts of shifts
-	var s uint
-	var x int
-	_ = x
-
-	_ = 1<<(1<<s)
-	_ = 1<<(1.<<s)
-	_ = 1. /* ERROR "integer" */ <<(1<<s)
-	_ = 1. /* ERROR "integer" */ <<(1.<<s)
-
-	x = 1<<(1<<s)
-	x = 1<<(1.<<s)
-	x = 1.<<(1<<s)
-	x = 1.<<(1.<<s)
-
-	_ = (1<<s)<<(1<<s)
-	_ = (1<<s)<<(1.<<s)
-	_ = ( /* ERROR "integer" */ 1.<<s)<<(1<<s)
-	_ = ( /* ERROR "integer" */ 1.<<s)<<(1.<<s)
-
-	x = (1<<s)<<(1<<s)
-	x = (1<<s)<<(1.<<s)
-	x = ( /* ERROR "integer" */ 1.<<s)<<(1<<s)
-	x = ( /* ERROR "integer" */ 1.<<s)<<(1.<<s)
-}
-
-func shifts8() {
-	// shift examples from shift discussion: better error messages
-	var s uint
-	_ = 1.0 /* ERROR "shifted operand 1.0 \(type float64\) must be integer" */ <<s == 1
-	_ = 1.0 /* ERROR "shifted operand 1.0 \(type float64\) must be integer" */ <<s == 1.0
-	_ = 1 /* ERROR "shifted operand 1 \(type float64\) must be integer" */ <<s == 1.0
-	_ = 1 /* ERROR "shifted operand 1 \(type float64\) must be integer" */ <<s + 1.0 == 1
-	_ = 1 /* ERROR "shifted operand 1 \(type float64\) must be integer" */ <<s + 1.1 == 1
-	_ = 1 /* ERROR "shifted operand 1 \(type float64\) must be integer" */ <<s + 1 == 1.0
-
-	// additional cases
-	_ = complex(1.0 /* ERROR "shifted operand 1.0 \(type float64\) must be integer" */ <<s, 1)
-	_ = complex(1.0, 1 /* ERROR "shifted operand 1 \(type float64\) must be integer" */ <<s)
-
-	_ = int(1.<<s)
-	_ = int(1.1 /* ERROR "shifted operand .* must be integer" */ <<s)
-	_ = float32(1 /* ERROR "shifted operand .* must be integer" */ <<s)
-	_ = float32(1. /* ERROR "shifted operand .* must be integer" */ <<s)
-	_ = float32(1.1 /* ERROR "shifted operand .* must be integer" */ <<s)
-	// TODO(gri) the error messages for these two are incorrect - disabled for now
-	// _ = complex64(1<<s)
-	// _ = complex64(1.<<s)
-	_ = complex64(1.1 /* ERROR "shifted operand .* must be integer" */ <<s)
-}
-
-func shifts9() {
-	// various originally failing snippets of code from the std library
-	// from src/compress/lzw/reader.go:90
-	{
-		var d struct {
-			bits     uint32
-			width    uint
-		}
-		_ = uint16(d.bits & (1<<d.width - 1))
-	}
-
-	// from src/debug/dwarf/buf.go:116
-	{
-		var ux uint64
-		var bits uint
-		x := int64(ux)
-		if x&(1<<(bits-1)) != 0 {}
-	}
-
-	// from src/encoding/asn1/asn1.go:160
-	{
-		var bytes []byte
-		if bytes[len(bytes)-1]&((1<<bytes[0])-1) != 0 {}
-	}
-
-	// from src/math/big/rat.go:140
-	{
-		var exp int
-		var mantissa uint64
-		shift := uint64(-1022 - (exp - 1)) // [1..53)
-		_ = mantissa & (1<<shift - 1)
-	}
-
-	// from src/net/interface.go:51
-	{
-		type Flags uint
-		var f Flags
-		var i int
-		if f&(1<<uint(i)) != 0 {}
-	}
-
-	// from src/runtime/softfloat64.go:234
-	{
-		var gm uint64
-		var shift uint
-		_ = gm & (1<<shift - 1)
-	}
-
-	// from src/strconv/atof.go:326
-	{
-		var mant uint64
-		var mantbits uint
-		if mant == 2<<mantbits {}
-	}
-
-	// from src/route_bsd.go:82
-	{
-		var Addrs int32
-		const rtaRtMask = 1
-		var i uint
-		if Addrs&rtaRtMask&(1<<i) == 0 {}
-	}
-
-	// from src/text/scanner/scanner.go:540
-	{
-		var s struct { Whitespace uint64 }
-		var ch rune
-		for s.Whitespace&(1<<uint(ch)) != 0 {}
-	}
-}
-
-func issue5895() {
-	var x = 'a' << 1 // type of x must be rune
-	var _ rune = x
-}
-
-func issue11325() {
-	var _ = 0 >> 1.1 /* ERROR "truncated to uint" */ // example from issue 11325
-	_ = 0 >> 1.1 /* ERROR "truncated to uint" */
-	_ = 0 << 1.1 /* ERROR "truncated to uint" */
-	_ = 0 >> 1.
-	_ = 1 >> 1.1 /* ERROR "truncated to uint" */
-	_ = 1 >> 1.
-	_ = 1. >> 1
-	_ = 1. >> 1.
-	_ = 1.1 /* ERROR "must be integer" */ >> 1
-}
-
-func issue11594() {
-	var _ = complex64 /* ERROR "must be integer" */ (1) << 2 // example from issue 11594
-	_ = float32 /* ERROR "must be integer" */ (0) << 1
-	_ = float64 /* ERROR "must be integer" */ (0) >> 2
-	_ = complex64 /* ERROR "must be integer" */ (0) << 3
-	_ = complex64 /* ERROR "must be integer" */ (0) >> 4
-}
-
-func issue21727() {
-	var s uint
-	var a = make([]int, 1<<s + 1.2 /* ERROR "truncated to int" */ )
-	var _ = a[1<<s - 2.3 /* ERROR "truncated to int" */ ]
-	var _ int = 1<<s + 3.4 /* ERROR "truncated to int" */
-	var _ = string(1 /* ERROR shifted operand 1 .* must be integer */ << s)
-	var _ = string(1.0 /* ERROR "cannot convert" */ << s)
-}
-
-func issue22969() {
-	var s uint
-	var a []byte
-	_ = a[0xffffffffffffffff /* ERROR "overflows int" */ <<s] // example from issue 22969
-	_ = make([]int, 0xffffffffffffffff /* ERROR "overflows int" */ << s)
-	_ = make([]int, 0, 0xffffffffffffffff /* ERROR "overflows int" */ << s)
-	var _ byte = 0x100 /* ERROR "overflows byte" */ << s
-	var _ int8 = 0xff /* ERROR "overflows int8" */ << s
-	var _ int16 = 0xffff /* ERROR "overflows int16" */ << s
-	var _ int32 = 0x80000000 /* ERROR "overflows int32" */ << s
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/slices.go b/src/cmd/compile/internal/types2/testdata/check/slices.go
deleted file mode 100644
index 2bacd1c2aa..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/slices.go
+++ /dev/null
@@ -1,68 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Package slices implements various slice algorithms.
-package slices
-
-// Map turns a []T1 to a []T2 using a mapping function.
-func Map[T1, T2 any](s []T1, f func(T1) T2) []T2 {
-	r := make([]T2, len(s))
-	for i, v := range s {
-		r[i] = f(v)
-	}
-	return r
-}
-
-// Reduce reduces a []T1 to a single value using a reduction function.
-func Reduce[T1, T2 any](s []T1, initializer T2, f func(T2, T1) T2) T2 {
-	r := initializer
-	for _, v := range s {
-		r = f(r, v)
-	}
-	return r
-}
-
-// Filter filters values from a slice using a filter function.
-func Filter[T any](s []T, f func(T) bool) []T {
-	var r []T
-	for _, v := range s {
-		if f(v) {
-			r = append(r, v)
-		}
-	}
-	return r
-}
-
-// Example uses
-
-func limiter(x int) byte {
-	switch {
-	case x < 0:
-		return 0
-	default:
-		return byte(x)
-	case x > 255:
-		return 255
-	}
-}
-
-var input = []int{-4, 68954, 7, 44, 0, -555, 6945}
-var limited1 = Map[int, byte](input, limiter)
-var limited2 = Map(input, limiter) // using type inference
-
-func reducer(x float64, y int) float64 {
-	return x + float64(y)
-}
-
-var reduced1 = Reduce[int, float64](input, 0, reducer)
-var reduced2 = Reduce(input, 1i /* ERROR overflows */, reducer) // using type inference
-var reduced3 = Reduce(input, 1, reducer) // using type inference
-
-func filter(x int) bool {
-	return x&1 != 0
-}
-
-var filtered1 = Filter[int](input, filter)
-var filtered2 = Filter(input, filter) // using type inference
-
diff --git a/src/cmd/compile/internal/types2/testdata/check/stmt0.go b/src/cmd/compile/internal/types2/testdata/check/stmt0.go
deleted file mode 100644
index 0caebcf544..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/stmt0.go
+++ /dev/null
@@ -1,992 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// statements
-
-package stmt0
-
-func assignments0() (int, int) {
-	var a, b, c int
-	var ch chan int
-	f0 := func() {}
-	f1 := func() int { return 1 }
-	f2 := func() (int, int) { return 1, 2 }
-	f3 := func() (int, int, int) { return 1, 2, 3 }
-
-	a, b, c = 1, 2, 3
-	a, b, c = 1 /* ERROR "cannot assign [1-9]+ values to [1-9]+ variables" */ , 2
-	a, b, c = 1 /* ERROR "cannot assign [1-9]+ values to [1-9]+ variables" */ , 2, 3, 4
-	_, _, _ = a, b, c
-
-	a = f0 /* ERROR "used as value" */ ()
-	a = f1()
-	a = f2 /* ERROR "cannot assign [1-9]+ values to [1-9]+ variables" */ ()
-	a, b = f2()
-	a, b, c = f2 /* ERROR "cannot assign [1-9]+ values to [1-9]+ variables" */ ()
-	a, b, c = f3()
-	a, b = f3 /* ERROR "cannot assign [1-9]+ values to [1-9]+ variables" */ ()
-
-	a, b, c = <- /* ERROR "cannot assign [1-9]+ values to [1-9]+ variables" */ ch
-
-	return /* ERROR "not enough return values\n\thave \(\)\n\twant \(int, int\)" */
-	return 1 /* ERROR "not enough return values\n\thave \(number\)\n\twant \(int, int\)" */
-	return 1, 2
-	return 1, 2, 3 /* ERROR "too many return values\n\thave \(number, number, number\)\n\twant \(int, int\)" */
-}
-
-func assignments1() {
-	b, i, f, c, s := false, 1, 1.0, 1i, "foo"
-	b = i /* ERROR "cannot use .* in assignment" */
-	i = f /* ERROR "cannot use .* in assignment" */
-	f = c /* ERROR "cannot use .* in assignment" */
-	c = s /* ERROR "cannot use .* in assignment" */
-	s = b /* ERROR "cannot use .* in assignment" */
-
-	v0, v1, v2 := 1 /* ERROR "cannot initialize" */ , 2, 3, 4
-	_, _, _ = v0, v1, v2
-
-	b = true
-
-	i += 1
-	i /* ERROR "mismatched types int and untyped string" */+= "foo"
-
-	f -= 1
-	f /= 0
-	f = float32(0)/0 /* ERROR "division by zero" */
-	f /* ERROR "mismatched types float64 and untyped string" */-= "foo"
-
-	c *= 1
-	c /= 0
-
-	s += "bar"
-	s /* ERROR "mismatched types string and untyped int" */+= 1
-
-	var u64 uint64
-	u64 += 1<<u64
-
-	undeclared /* ERROR "undeclared" */ = 991
-
-	// test cases for issue 5800
-	var (
-		_ int = nil /* ERROR "cannot use nil as int value in variable declaration" */
-		_ [10]int = nil /* ERROR "cannot use nil as \[10\]int value in variable declaration" */
-		_ []byte = nil
-		_ struct{} = nil /* ERROR "cannot use nil as struct{} value in variable declaration" */
-		_ func() = nil
-		_ map[int]string = nil
-		_ chan int = nil
-	)
-
-	// test cases for issue 5500
-	_ = func() (int, bool) {
-		var m map[int]int
-		return m /* ERROR "not enough return values" */ [0]
-	}
-
-	g := func(int, bool){}
-	var m map[int]int
-	g(m[0]) /* ERROR "not enough arguments" */
-
-	// assignments to _
-	_ = nil /* ERROR "use of untyped nil" */
-	_ = 1  << /* ERROR constant shift overflow */ 1000
-	(_) = 0
-}
-
-func assignments2() {
-	type mybool bool
-	var m map[string][]bool
-	var s []bool
-	var b bool
-	var d mybool
-	_ = s
-	_ = b
-	_ = d
-
-	// assignments to map index expressions are ok
-	s, b = m["foo"]
-	_, d = m["bar"]
-	m["foo"] = nil
-	m["foo"] = nil /* ERROR cannot assign [1-9]+ values to [1-9]+ variables */ , false
-	_ = append(m["foo"])
-	_ = append(m["foo"], true)
-
-	var c chan int
-	_, b = <-c
-	_, d = <-c
-	<- /* ERROR cannot assign */ c = 0
-	<-c = 0 /* ERROR cannot assign [1-9]+ values to [1-9]+ variables */ , false
-
-	var x interface{}
-	_, b = x.(int)
-	x /* ERROR cannot assign */ .(int) = 0
-	x.(int) = 0 /* ERROR cannot assign [1-9]+ values to [1-9]+ variables */ , false
-
-	assignments2 /* ERROR used as value */ () = nil
-	int /* ERROR not an expression */ = 0
-}
-
-func issue6487() {
-	type S struct{x int}
-	_ = &S /* ERROR "cannot take address" */ {}.x
-	_ = &( /* ERROR "cannot take address" */ S{}.x)
-	_ = (&S{}).x
-	S /* ERROR "cannot assign" */ {}.x = 0
-	(&S{}).x = 0
-
-	type M map[string]S
-	var m M
-	m /* ERROR "cannot assign to struct field" */ ["foo"].x = 0
-	_ = &( /* ERROR "cannot take address" */ m["foo"].x)
-	_ = &m /* ERROR "cannot take address" */ ["foo"].x
-}
-
-func issue6766a() {
-	a, a /* ERROR a repeated on left side of := */ := 1, 2
-	_ = a
-	a, b, b /* ERROR b repeated on left side of := */ := 1, 2, 3
-	_ = b
-	c, c /* ERROR c repeated on left side of := */, b := 1, 2, 3
-	_ = c
-	a, b := /* ERROR no new variables */ 1, 2
-}
-
-func shortVarDecls1() {
-	const c = 0
-	type d int
-	a, b, c /* ERROR "cannot assign" */ , d /* ERROR "cannot assign" */  := 1, "zwei", 3.0, 4
-	var _ int = a // a is of type int
-	var _ string = b // b is of type string
-}
-
-func incdecs() {
-	const c = 3.14
-	c /* ERROR "cannot assign" */ ++
-	s := "foo"
-	s /* ERROR "invalid operation" */ --
-	3.14 /* ERROR "cannot assign" */ ++
-	var (
-		x int
-		y float32
-		z complex128
-	)
-	x++
-	y--
-	z++
-}
-
-func sends() {
-	var ch chan int
-	var rch <-chan int
-	var x int
-	x <- /* ERROR "cannot send" */ x
-	rch <- /* ERROR "cannot send" */ x
-	ch <- "foo" /* ERROR "cannot use .* in send" */
-	ch <- x
-}
-
-func selects() {
-	select {}
-	var (
-		ch chan int
-		sc chan <- bool
-	)
-	select {
-	case <-ch:
-	case (<-ch):
-	case t := <-ch:
-		_ = t
-	case t := (<-ch):
-		_ = t
-	case t, ok := <-ch:
-		_, _ = t, ok
-	case t, ok := (<-ch):
-		_, _ = t, ok
-	case <-sc /* ERROR "cannot receive from send-only channel" */ :
-	}
-	select {
-	default:
-	default /* ERROR "multiple defaults" */ :
-	}
-	select {
-	case a, b := <-ch:
-		_, b = a, b
-	case x /* ERROR send or receive */ :
-	case a /* ERROR send or receive */ := ch:
-	}
-
-	// test for issue 9570: ch2 in second case falsely resolved to
-	// ch2 declared in body of first case
-	ch1 := make(chan int)
-	ch2 := make(chan int)
-	select {
-	case <-ch1:
-		var ch2 /* ERROR ch2 declared but not used */ chan bool
-	case i := <-ch2:
-		print(i + 1)
-	}
-}
-
-func gos() {
-	go 1; /* ERROR "must be function call" */
-	go int /* ERROR "go requires function call, not conversion" */ (0)
-	go gos()
-	var c chan int
-	go close(c)
-	go len /* ERROR "go discards result" */ (c)
-}
-
-func defers() {
-	defer 1; /* ERROR "must be function call" */
-	defer int /* ERROR "defer requires function call, not conversion" */ (0)
-	defer defers()
-	var c chan int
-	defer close(c)
-	defer len /* ERROR "defer discards result" */ (c)
-}
-
-func breaks() {
-	var x, y int
-
-	break /* ERROR "break" */
-	{
-		break /* ERROR "break" */
-	}
-	if x < y {
-		break /* ERROR "break" */
-	}
-
-	switch x {
-	case 0:
-		break
-	case 1:
-		if x == y {
-			break
-		}
-	default:
-		break
-		break
-	}
-
-	var z interface{}
-	switch z.(type) {
-	case int:
-		break
-	}
-
-	for {
-		break
-	}
-
-	var a []int
-	for _ = range a {
-		break
-	}
-
-	for {
-		if x == y {
-			break
-		}
-	}
-
-	var ch chan int
-	select {
-	case <-ch:
-		break
-	}
-
-	select {
-	case <-ch:
-		if x == y {
-			break
-		}
-	default:
-		break
-	}
-}
-
-func continues() {
-	var x, y int
-
-	continue /* ERROR "continue" */
-	{
-		continue /* ERROR "continue" */
-	}
-
-	if x < y {
-		continue /* ERROR "continue" */
-	}
-
-	switch x {
-	case 0:
-		continue /* ERROR "continue" */
-	}
-
-	var z interface{}
-	switch z.(type) {
-	case int:
-		continue /* ERROR "continue" */
-	}
-
-	var ch chan int
-	select {
-	case <-ch:
-		continue /* ERROR "continue" */
-	}
-
-	for i := 0; i < 10; i++ {
-		continue
-		if x < y {
-			continue
-			break
-		}
-		switch x {
-		case y:
-			continue
-		default:
-			break
-		}
-		select {
-		case <-ch:
-			continue
-		}
-	}
-
-	var a []int
-	for _ = range a {
-		continue
-		if x < y {
-			continue
-			break
-		}
-		switch x {
-		case y:
-			continue
-		default:
-			break
-		}
-		select {
-		case <-ch:
-			continue
-		}
-	}
-}
-
-func returns0() {
-	return
-	return 0 /* ERROR too many return values */
-}
-
-func returns1(x float64) (int, *float64) {
-	return 0, &x
-	return /* ERROR not enough return values */
-	return "foo" /* ERROR "cannot .* in return statement" */, x /* ERROR "cannot use .* in return statement" */
-	return 0, &x, 1 /* ERROR too many return values */
-}
-
-func returns2() (a, b int) {
-	return
-	return 1, "foo" /* ERROR cannot use .* in return statement */
-	return 1, 2, 3 /* ERROR too many return values */
-	{
-		type a int
-		return 1, 2
-		return /* ERROR a not in scope at return */
-	}
-}
-
-func returns3() (_ int) {
-	return
-	{
-		var _ int // blank (_) identifiers never shadow since they are in no scope
-		return
-	}
-}
-
-func switches0() {
-	var x int
-
-	switch x {
-	}
-
-	switch x {
-	default:
-	default /* ERROR "multiple defaults" */ :
-	}
-
-	switch {
-	case 1  /* ERROR "cannot convert" */ :
-	}
-
-	true := "false"
-	_ = true
-	// A tagless switch is equivalent to the bool
-        // constant true, not the identifier 'true'.
-	switch {
-	case "false" /* ERROR "cannot convert" */:
-	}
-
-	switch int32(x) {
-	case 1, 2:
-	case x /* ERROR "invalid case x in switch on int32\(x\) \(mismatched types int and int32\)" */ :
-	}
-
-	switch x {
-	case 1 /* ERROR "overflows" */ << 100:
-	}
-
-	switch x {
-	case 1:
-	case 1 /* ERROR "duplicate case" */ :
-	case ( /* ERROR "duplicate case" */ 1):
-	case 2, 3, 4:
-	case 5, 1 /* ERROR "duplicate case" */ :
-	}
-
-	switch uint64(x) {
-	case 1<<64 - 1:
-	case 1 /* ERROR duplicate case */ <<64 - 1:
-	case 2, 3, 4:
-	case 5, 1 /* ERROR duplicate case */ <<64 - 1:
-	}
-
-	var y32 float32
-	switch y32 {
-	case 1.1:
-	case 11/10: // integer division!
-	case 11. /* ERROR duplicate case */ /10:
-	case 2, 3.0, 4.1:
-	case 5.2, 1.10 /* ERROR duplicate case */ :
-	}
-
-	var y64 float64
-	switch y64 {
-	case 1.1:
-	case 11/10: // integer division!
-	case 11. /* ERROR duplicate case */ /10:
-	case 2, 3.0, 4.1:
-	case 5.2, 1.10 /* ERROR duplicate case */ :
-	}
-
-	var s string
-	switch s {
-	case "foo":
-	case "foo" /* ERROR duplicate case */ :
-	case "f" /* ERROR duplicate case */ + "oo":
-	case "abc", "def", "ghi":
-	case "jkl", "foo" /* ERROR duplicate case */ :
-	}
-
-	type T int
-	type F float64
-	type S string
-	type B bool
-	var i interface{}
-	switch i {
-	case nil:
-	case nil: // no duplicate detection
-	case (*int)(nil):
-	case (*int)(nil): // do duplicate detection
-	case 1:
-	case byte(1):
-	case int /* ERROR duplicate case */ (1):
-	case T(1):
-	case 1.0:
-	case F(1.0):
-	case F /* ERROR duplicate case */ (1.0):
-	case "hello":
-	case S("hello"):
-	case S /* ERROR duplicate case */ ("hello"):
-	case 1==1, B(false):
-	case false, B(2==2):
-	}
-
-	// switch on array
-	var a [3]int
-	switch a {
-	case [3]int{1, 2, 3}:
-	case [3]int{1, 2, 3}: // no duplicate detection
-	case [ /* ERROR "mismatched types */ 4]int{4, 5, 6}:
-	}
-
-	// switch on channel
-	var c1, c2 chan int
-	switch c1 {
-	case nil:
-	case c1:
-	case c2:
-	case c1, c2: // no duplicate detection
-	}
-}
-
-func switches1() {
-	fallthrough /* ERROR "fallthrough statement out of place" */
-
-	var x int
-	switch x {
-	case 0:
-		fallthrough /* ERROR "fallthrough statement out of place" */
-		break
-	case 1:
-		fallthrough
-	case 2:
-		fallthrough; ; ; // trailing empty statements are ok
-	case 3:
-	default:
-		fallthrough; ;
-	case 4:
-		fallthrough /* ERROR "cannot fallthrough final case in switch" */
-	}
-
-	var y interface{}
-	switch y.(type) {
-	case int:
-		fallthrough /* ERROR "cannot fallthrough in type switch" */ ; ; ;
-	default:
-	}
-
-	switch x {
-	case 0:
-		if x == 0 {
-			fallthrough /* ERROR "fallthrough statement out of place" */
-		}
-	}
-
-	switch x {
-	case 0:
-		goto L1
-		L1: fallthrough; ;
-	case 1:
-		goto L2
-		goto L3
-		goto L4
-		L2: L3: L4: fallthrough
-	default:
-	}
-
-	switch x {
-	case 0:
-		goto L5
-		L5: fallthrough
-	default:
-		goto L6
-		goto L7
-		goto L8
-		L6: L7: L8: fallthrough /* ERROR "cannot fallthrough final case in switch" */
-	}
-
-	switch x {
-	case 0:
-		fallthrough; ;
-	case 1:
-		{
-			fallthrough /* ERROR "fallthrough statement out of place" */
-		}
-	case 2:
-		fallthrough
-	case 3:
-		fallthrough /* ERROR "fallthrough statement out of place" */
-		{ /* empty block is not an empty statement */ }; ;
-	default:
-		fallthrough /* ERROR "cannot fallthrough final case in switch" */
-	}
-
-	switch x {
-	case 0:
-		{
-			fallthrough /* ERROR "fallthrough statement out of place" */
-		}
-	}
-}
-
-func switches2() {
-	// untyped nil is not permitted as switch expression
-	switch nil /* ERROR "use of untyped nil" */ {
-	case 1, 2, "foo": // don't report additional errors here
-	}
-
-	// untyped constants are converted to default types
-	switch 1<<63-1 {
-	}
-	switch 1 /* ERROR "cannot use .* as int value.*\(overflows\)" */ << 63 {
-	}
-	var x int
-	switch 1.0 {
-	case 1.0, 2.0, x /* ERROR "mismatched types int and float64" */ :
-	}
-	switch x {
-	case 1.0:
-	}
-
-	// untyped bools become of type bool
-	type B bool
-	var b B = true
-	switch x == x {
-	case b /* ERROR "mismatched types B and bool" */ :
-	}
-	switch {
-	case b /* ERROR "mismatched types B and bool" */ :
-	}
-}
-
-func issue11667() {
-	switch 9223372036854775808 /* ERROR "cannot use .* as int value.*\(overflows\)" */ {
-	}
-	switch 9223372036854775808 /* ERROR "cannot use .* as int value.*\(overflows\)" */ {
-	case 9223372036854775808:
-	}
-	var x int
-	switch x {
-	case 9223372036854775808 /* ERROR "overflows int" */ :
-	}
-	var y float64
-	switch y {
-	case 9223372036854775808:
-	}
-}
-
-func issue11687() {
-	f := func() (_, _ int) { return }
-	switch f /* ERROR "2-valued f" */ () {
-	}
-	var x int
-	switch f /* ERROR "2-valued f" */ () {
-	case x:
-	}
-	switch x {
-	case f /* ERROR "2-valued f" */ ():
-	}
-}
-
-type I interface {
-	m()
-}
-
-type I2 interface {
-	m(int)
-}
-
-type T struct{}
-type T1 struct{}
-type T2 struct{}
-
-func (T) m() {}
-func (T2) m(int) {}
-
-func typeswitches() {
-	var i int
-	var x interface{}
-
-	switch x.(type) {}
-	switch (x /* ERROR "outside type switch" */ .(type)) {}
-
-	switch x.(type) {
-	default:
-	default /* ERROR "multiple defaults" */ :
-	}
-
-	switch x /* ERROR "declared but not used" */ := x.(type) {}
-	switch _ /* ERROR "no new variable on left side of :=" */ := x.(type) {}
-
-	switch x := x.(type) {
-	case int:
-		var y int = x
-		_ = y
-	}
-
-	switch x /* ERROR "x declared but not used" */ := i /* ERROR "not an interface" */ .(type) {}
-
-	switch t := x.(type) {
-	case nil:
-		var v bool = t /* ERROR "cannot use .* in variable declaration" */
-		_ = v
-	case int:
-		var v int = t
-		_ = v
-	case float32, complex64:
-		var v float32 = t /* ERROR "cannot use .* in variable declaration" */
-		_ = v
-	default:
-		var v float32 = t /* ERROR "cannot use .* in variable declaration" */
-		_ = v
-	}
-
-	var t I
-	switch t.(type) {
-	case T:
-	case T1 /* ERROR "missing method m" */ :
-	case T2 /* ERROR "wrong type for method m" */ :
-	case I2 /* STRICT "wrong type for method m" */ : // only an error in strict mode (issue 8561)
-	}
-
-
-	{
-		x := 1
-		v := 2
-		switch v /* ERROR "v [(]variable of type int[)] is not an interface" */ .(type) {
-		case int:
-			println(x)
-			println(x / 0 /* ERROR "invalid operation: division by zero" */)
-		case 1 /* ERROR "1 is not a type" */:
-		}
-	}
-}
-
-// Test that each case clause uses the correct type of the variable
-// declared by the type switch (issue 5504).
-func typeswitch0() {
-	switch y := interface{}(nil).(type) {
-	case int:
-		func() int { return y + 0 }()
-	case float32:
-		func() float32 { return y }()
-	}
-}
-
-// Test correct scope setup.
-// (no redeclaration errors expected in the type switch)
-func typeswitch1() {
-	var t I
-	switch t := t; t := t.(type) {
-	case nil:
-		var _ I = t
-	case T:
-		var _ T = t
-	default:
-		var _ I = t
-	}
-}
-
-// Test correct typeswitch against interface types.
-type A interface { a() }
-type B interface { b() }
-type C interface { a(int) }
-
-func typeswitch2() {
-	switch A(nil).(type) {
-	case A:
-	case B:
-	case C /* STRICT "cannot have dynamic type" */: // only an error in strict mode (issue 8561)
-	}
-}
-
-func typeswitch3(x interface{}) {
-	switch x.(type) {
-	case int:
-	case float64:
-	case int /* ERROR duplicate case */ :
-	}
-
-	switch x.(type) {
-	case nil:
-	case int:
-	case nil /* ERROR duplicate case */ , nil /* ERROR duplicate case */ :
-	}
-
-	type F func(int)
-	switch x.(type) {
-	case nil:
-	case int, func(int):
-	case float32, func /* ERROR duplicate case */ (x int):
-	case F:
-	}
-}
-
-func fors1() {
-	for {}
-	var i string
-	_ = i
-	for i := 0; i < 10; i++ {}
-	for i := 0; i < 10; j /* ERROR cannot declare */ := 0 {}
-}
-
-func rangeloops1() {
-	var (
-		x int
-		a [10]float32
-		b []string
-		p *[10]complex128
-		pp **[10]complex128
-		s string
-		m map[int]bool
-		c chan int
-		sc chan<- int
-		rc <-chan int
-	)
-
-	for range x /* ERROR "cannot range over" */ {}
-	for _ = range x /* ERROR "cannot range over" */ {}
-	for i := range x /* ERROR "cannot range over" */ {}
-
-	for range a {}
-	for i := range a {
-		var ii int
-		ii = i
-		_ = ii
-	}
-	for i, x := range a {
-		var ii int
-		ii = i
-		_ = ii
-		var xx float64
-		xx = x /* ERROR "cannot use .* in assignment" */
-		_ = xx
-	}
-	var ii int
-	var xx float32
-	for ii, xx = range a {}
-	_, _ = ii, xx
-
-	for range b {}
-	for i := range b {
-		var ii int
-		ii = i
-		_ = ii
-	}
-	for i, x := range b {
-		var ii int
-		ii = i
-		_ = ii
-		var xx string
-		xx = x
-		_ = xx
-	}
-
-	for range s {}
-	for i := range s {
-		var ii int
-		ii = i
-		_ = ii
-	}
-	for i, x := range s {
-		var ii int
-		ii = i
-		_ = ii
-		var xx rune
-		xx = x
-		_ = xx
-	}
-
-	for range p {}
-	for _, x := range p {
-		var xx complex128
-		xx = x
-		_ = xx
-	}
-
-	for range pp /* ERROR "cannot range over" */ {}
-	for _, x := range pp /* ERROR "cannot range over" */ {}
-
-	for range m {}
-	for k := range m {
-		var kk int32
-		kk = k /* ERROR "cannot use .* in assignment" */
-		_ = kk
-	}
-	for k, v := range m {
-		var kk int
-		kk = k
-		_ = kk
-		if v {}
-	}
-
-	for range c {}
-	for _, _ /* ERROR "only one iteration variable" */ = range c {}
-	for e := range c {
-		var ee int
-		ee = e
-		_ = ee
-	}
-	for _ = range sc /* ERROR "cannot range over" */ {}
-	for _ = range rc {}
-
-	// constant strings
-	const cs = "foo"
-	for range cs {}
-	for range "" {}
-	for i, x := range cs { _, _ = i, x }
-	for i, x := range "" {
-		var ii int
-		ii = i
-		_ = ii
-		var xx rune
-		xx = x
-		_ = xx
-	}
-}
-
-func rangeloops2() {
-	type I int
-	type R rune
-
-	var a [10]int
-	var i I
-	_ = i
-	for i /* ERROR cannot use .* in assignment */ = range a {}
-	for i /* ERROR cannot use .* in assignment */ = range &a {}
-	for i /* ERROR cannot use .* in assignment */ = range a[:] {}
-
-	var s string
-	var r R
-	_ = r
-	for i /* ERROR cannot use .* in assignment */ = range s {}
-	for i /* ERROR cannot use .* in assignment */ = range "foo" {}
-	for _, r /* ERROR cannot use .* in assignment */ = range s {}
-	for _, r /* ERROR cannot use .* in assignment */ = range "foo" {}
-}
-
-func issue6766b() {
-	for _ := /* ERROR no new variables */ range "" {}
-	for a, a /* ERROR redeclared */ := range "" { _ = a }
-	var a int
-	_ = a
-	for a, a /* ERROR redeclared */ := range []int{1, 2, 3} { _ = a }
-}
-
-// Test that despite errors in the range clause,
-// the loop body is still type-checked (and thus
-// errors reported).
-func issue10148() {
-	for y /* ERROR declared but not used */ := range "" {
-		_ = "" /* ERROR mismatched types untyped string and untyped int */ + 1
-	}
-	for range 1 /* ERROR cannot range over 1 */ {
-		_ = "" /* ERROR mismatched types untyped string and untyped int */ + 1
-	}
-	for y := range 1 /* ERROR cannot range over 1 */ {
-		_ = "" /* ERROR mismatched types untyped string and untyped int */ + 1
-	}
-}
-
-func labels0() {
-	goto L0
-	goto L1
-	L0:
-	L1:
-	L1 /* ERROR "already declared" */ :
-	if true {
-		goto L2
-		L2:
-		L0 /* ERROR "already declared" */ :
-	}
-	_ = func() {
-		goto L0
-		goto L1
-		goto L2
-		L0:
-		L1:
-		L2:
-	}
-}
-
-func expression_statements(ch chan int) {
-	expression_statements(ch)
-	<-ch
-	println()
-
-	0 /* ERROR "not used" */
-	1 /* ERROR "not used" */ +2
-	cap /* ERROR "not used" */ (ch)
-	println /* ERROR "must be called" */
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/stmt1.go b/src/cmd/compile/internal/types2/testdata/check/stmt1.go
deleted file mode 100644
index f79f92058b..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/stmt1.go
+++ /dev/null
@@ -1,259 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// terminating statements
-
-package stmt1
-
-func _() {}
-
-func _() int {} /* ERROR "missing return" */
-
-func _() int { panic(0) }
-func _() int { (panic(0)) }
-
-// block statements
-func _(x, y int) (z int) {
-	{
-		return
-	}
-}
-
-func _(x, y int) (z int) {
-	{
-		return; ; ; // trailing empty statements are ok
-	}
-	; ; ;
-}
-
-func _(x, y int) (z int) {
-	{
-	}
-} /* ERROR "missing return" */
-
-func _(x, y int) (z int) {
-	{
-		; ; ;
-	}
-	; ; ;
-} /* ERROR "missing return" */
-
-// if statements
-func _(x, y int) (z int) {
-	if x < y { return }
-	return 1
-}
-
-func _(x, y int) (z int) {
-	if x < y { return; ; ; ; }
-	return 1
-}
-
-func _(x, y int) (z int) {
-	if x < y { return }
-	return 1; ;
-}
-
-func _(x, y int) (z int) {
-	if x < y { return }
-} /* ERROR "missing return" */
-
-func _(x, y int) (z int) {
-	if x < y {
-	} else { return 1
-	}
-} /* ERROR "missing return" */
-
-func _(x, y int) (z int) {
-	if x < y { return
-	} else { return
-	}
-}
-
-// for statements
-func _(x, y int) (z int) {
-	for x < y {
-		return
-	}
-} /* ERROR "missing return" */
-
-func _(x, y int) (z int) {
-	for {
-		return
-	}
-}
-
-func _(x, y int) (z int) {
-	for {
-		return; ; ; ;
-	}
-}
-
-func _(x, y int) (z int) {
-	for {
-		return
-		break
-	}
-	; ; ;
-} /* ERROR "missing return" */
-
-func _(x, y int) (z int) {
-	for {
-		for { break }
-		return
-	}
-}
-
-func _(x, y int) (z int) {
-	for {
-		for { break }
-		return ; ;
-	}
-	;
-}
-
-func _(x, y int) (z int) {
-L:	for {
-		for { break L }
-		return
-	}
-} /* ERROR "missing return" */
-
-// switch statements
-func _(x, y int) (z int) {
-	switch x {
-	case 0: return
-	default: return
-	}
-}
-
-func _(x, y int) (z int) {
-	switch x {
-	case 0: return;
-	default: return; ; ;
-	}
-}
-
-func _(x, y int) (z int) {
-	switch x {
-	case 0: return
-	}
-} /* ERROR "missing return" */
-
-func _(x, y int) (z int) {
-	switch x {
-	case 0: return
-	case 1: break
-	}
-} /* ERROR "missing return" */
-
-func _(x, y int) (z int) {
-	switch x {
-	case 0: return
-	default:
-		switch y {
-		case 0: break
-		}
-		panic(0)
-	}
-}
-
-func _(x, y int) (z int) {
-	switch x {
-	case 0: return
-	default:
-		switch y {
-		case 0: break
-		}
-		panic(0); ; ;
-	}
-	;
-}
-
-func _(x, y int) (z int) {
-L:	switch x {
-	case 0: return
-	default:
-		switch y {
-		case 0: break L
-		}
-		panic(0)
-	}
-} /* ERROR "missing return" */
-
-// select statements
-func _(ch chan int) (z int) {
-	select {}
-} // nice!
-
-func _(ch chan int) (z int) {
-	select {}
-	; ;
-}
-
-func _(ch chan int) (z int) {
-	select {
-	default: break
-	}
-} /* ERROR "missing return" */
-
-func _(ch chan int) (z int) {
-	select {
-	case <-ch: return
-	default: break
-	}
-} /* ERROR "missing return" */
-
-func _(ch chan int) (z int) {
-	select {
-	case <-ch: return
-	default:
-		for i := 0; i < 10; i++ {
-			break
-		}
-		return
-	}
-}
-
-func _(ch chan int) (z int) {
-	select {
-	case <-ch: return; ; ;
-	default:
-		for i := 0; i < 10; i++ {
-			break
-		}
-		return; ; ;
-	}
-	; ; ;
-}
-
-func _(ch chan int) (z int) {
-L:	select {
-	case <-ch: return
-	default:
-		for i := 0; i < 10; i++ {
-			break L
-		}
-		return
-	}
-	; ; ;
-} /* ERROR "missing return" */
-
-func parenPanic() int {
-	((((((panic)))(0))))
-}
-
-func issue23218a() int {
-	{
-		panic := func(interface{}){}
-		panic(0)
-	}
-} /* ERROR "missing return" */
-
-func issue23218b() int {
-	{
-		panic := func(interface{}){}
-		((((panic))))(0)
-	}
-} /* ERROR "missing return" */
diff --git a/src/cmd/compile/internal/types2/testdata/check/typeinference.go b/src/cmd/compile/internal/types2/testdata/check/typeinference.go
deleted file mode 100644
index 28f3e286b7..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/typeinference.go
+++ /dev/null
@@ -1,49 +0,0 @@
-// Copyright 2021 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package typeInference
-
-// As of issue #51527, type-type inference has been disabled.
-
-// basic inference
-type Tb[P ~*Q, Q any] int
-func _() {
-	var x Tb /* ERROR got 1 arguments */ [*int]
-	var y Tb[*int, int]
-	x = y /* ERROR cannot use y .* in assignment */
-	_ = x
-}
-
-// recursive inference
-type Tr[A any, B *C, C *D, D *A] int
-func _() {
-	var x Tr /* ERROR got 1 arguments */ [string]
-	var y Tr[string, ***string, **string, *string]
-	var z Tr[int, ***int, **int, *int]
-	x = y /* ERROR cannot use y .* in assignment */
-	x = z // ERROR cannot use z .* as Tr
-	_ = x
-}
-
-// other patterns of inference
-type To0[A any, B []A] int
-type To1[A any, B struct{a A}] int
-type To2[A any, B [][]A] int
-type To3[A any, B [3]*A] int
-type To4[A any, B any, C struct{a A; b B}] int
-func _() {
-	var _ To0 /* ERROR got 1 arguments */ [int]
-	var _ To1 /* ERROR got 1 arguments */ [int]
-	var _ To2 /* ERROR got 1 arguments */ [int]
-	var _ To3 /* ERROR got 1 arguments */ [int]
-	var _ To4 /* ERROR got 2 arguments */ [int, string]
-}
-
-// failed inference
-type Tf0[A, B any] int
-type Tf1[A any, B ~struct{a A; c C}, C any] int
-func _() {
-	var _ Tf0 /* ERROR got 1 arguments but 2 type parameters */ [int]
-	var _ Tf1 /* ERROR got 1 arguments but 3 type parameters */ [int]
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/typeinst0.go b/src/cmd/compile/internal/types2/testdata/check/typeinst0.go
deleted file mode 100644
index 6423cb801f..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/typeinst0.go
+++ /dev/null
@@ -1,62 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package p
-
-type myInt int
-
-// Parameterized type declarations
-
-// For now, a lone type parameter is not permitted as RHS in a type declaration (issue #45639).
-type T1[P any] P // ERROR cannot use a type parameter as RHS in type declaration
-
-type T2[P any] struct {
-        f P
-        g int // int should still be in scope chain
-}
-
-type List[P any] []P
-
-// Alias type declarations cannot have type parameters.
-// Issue #46477 proposses to change that.
-type A1[P any] = /* ERROR cannot be alias */ struct{}
-
-// Pending clarification of #46477 we disallow aliases
-// of generic types.
-type A2 = List // ERROR cannot use generic type
-var _ A2[int]
-var _ A2
-
-type A3 = List[int]
-var _ A3
-
-// Parameterized type instantiations
-
-var x int
-type _ x /* ERROR not a type */ [int]
-
-type _ int /* ERROR not a generic type */ [] // ERROR expected type argument list
-type _ myInt /* ERROR not a generic type */ [] // ERROR expected type argument list
-
-// TODO(gri) better error messages
-type _ T1[] // ERROR expected type argument list
-type _ T1[x /* ERROR not a type */ ]
-type _ T1 /* ERROR got 2 arguments but 1 type parameters */ [int, float32]
-
-var _ T2[int] = T2[int]{}
-
-var _ List[int] = []int{1, 2, 3}
-var _ List[[]int] = [][]int{{1, 2, 3}}
-var _ List[List[List[int]]]
-
-// Parameterized types containing parameterized types
-
-type T3[P any] List[P]
-
-var _ T3[int] = T3[int](List[int]{1, 2, 3})
-
-// Self-recursive generic types are not permitted
-
-type self1[P any] self1 /* ERROR illegal cycle */ [P]
-type self2[P any] *self2[P] // this is ok
diff --git a/src/cmd/compile/internal/types2/testdata/check/typeinst1.go b/src/cmd/compile/internal/types2/testdata/check/typeinst1.go
deleted file mode 100644
index e7b4539ff3..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/typeinst1.go
+++ /dev/null
@@ -1,282 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package p
-
-type List[E any] []E
-var _ List[List[List[int]]]
-var _ List[List[List[int]]] = []List[List[int]]{}
-
-type (
-	T1[P1 any] struct {
-		f1 T2[P1, float32]
-	}
-
-	T2[P2, P3 any] struct {
-		f2 P2
-		f3 P3
-	}
-)
-
-func _() {
-	var x1 T1[int]
-	var x2 T2[int, float32]
-
-	x1.f1.f2 = 0
-	x1.f1 = x2
-}
-
-type T3[P any] T1[T2[P, P]]
-
-func _() {
-	var x1 T3[int]
-	var x2 T2[int, int]
-	x1.f1.f2 = x2
-}
-
-func f[P any] (x P) List[P] {
-	return List[P]{x}
-}
-
-var (
-	_ []int = f(0)
-	_ []float32 = f[float32](10)
-	_ List[complex128] = f(1i)
-	_ []List[int] = f(List[int]{})
-        _ List[List[int]] = []List[int]{}
-        _ = []List[int]{}
-)
-
-// Parameterized types with methods
-
-func (l List[E]) Head() (_ E, _ bool) {
-	if len(l) > 0 {
-		return l[0], true
-	}
-	return
-}
-
-// A test case for instantiating types with other types (extracted from map.go2)
-
-type Pair[K any] struct {
-	key K
-}
-
-type Receiver[T any] struct {
-	values T
-}
-
-type Iterator[K any] struct {
-	r Receiver[Pair[K]]
-}
-
-func Values [T any] (r Receiver[T]) T {
-        return r.values
-}
-
-func (it Iterator[K]) Next() K {
-        return Values[Pair[K]](it.r).key
-}
-
-// A more complex test case testing type bounds (extracted from linalg.go2 and reduced to essence)
-
-type NumericAbs[T any] interface {
-	Abs() T
-}
-
-func AbsDifference[T NumericAbs[T]](x T) { panic(0) }
-
-// For now, a lone type parameter is not permitted as RHS in a type declaration (issue #45639).
-// type OrderedAbs[T any] T
-// 
-// func (a OrderedAbs[T]) Abs() OrderedAbs[T]
-// 
-// func OrderedAbsDifference[T any](x T) {
-// 	AbsDifference(OrderedAbs[T](x))
-// }
-
-// same code, reduced to essence
-
-func g[P interface{ m() P }](x P) { panic(0) }
-
-// For now, a lone type parameter is not permitted as RHS in a type declaration (issue #45639).
-// type T4[P any] P
-// 
-// func (_ T4[P]) m() T4[P]
-// 
-// func _[Q any](x Q) {
-// 	g(T4[Q](x))
-// }
-
-// Another test case that caused  problems in the past
-
-type T5[_ interface { a() }, _ interface{}] struct{}
-
-type A[P any] struct{ x P }
-
-func (_ A[P]) a() {}
-
-var _ T5[A[int], int]
-
-// Invoking methods with parameterized receiver types uses
-// type inference to determine the actual type arguments matching
-// the receiver type parameters from the actual receiver argument.
-// Go does implicit address-taking and dereferenciation depending
-// on the actual receiver and the method's receiver type. To make
-// type inference work, the type-checker matches "pointer-ness"
-// of the actual receiver and the method's receiver type.
-// The following code tests this mechanism.
-
-type R1[A any] struct{}
-func (_ R1[A]) vm()
-func (_ *R1[A]) pm()
-
-func _[T any](r R1[T], p *R1[T]) {
-	r.vm()
-	r.pm()
-	p.vm()
-	p.pm()
-}
-
-type R2[A, B any] struct{}
-func (_ R2[A, B]) vm()
-func (_ *R2[A, B]) pm()
-
-func _[T any](r R2[T, int], p *R2[string, T]) {
-	r.vm()
-	r.pm()
-	p.vm()
-	p.pm()
-}
-
-// It is ok to have multiple embedded unions.
-type _ interface {
-	m0()
-	~int | ~string | ~bool
-	~float32 | ~float64
-	m1()
-	m2()
-	~complex64 | ~complex128
-	~rune
-}
-
-// Type sets may contain each type at most once.
-type _ interface {
-	~int|~ /* ERROR overlapping terms ~int */ int
-	~int|int /* ERROR overlapping terms int */
-	int|int /* ERROR overlapping terms int */
-}
-
-type _ interface {
-	~struct{f int} | ~struct{g int} | ~ /* ERROR overlapping terms */ struct{f int}
-}
-
-// Interface term lists can contain any type, incl. *Named types.
-// Verify that we use the underlying type(s) of the type(s) in the
-// term list when determining if an operation is permitted.
-
-type MyInt int
-func add1[T interface{MyInt}](x T) T {
-	return x + 1
-}
-
-type MyString string
-func double[T interface{MyInt|MyString}](x T) T {
-	return x + x
-}
-
-// Embedding of interfaces with term lists leads to interfaces
-// with term lists that are the intersection of the embedded
-// term lists.
-
-type E0 interface {
-	~int | ~bool | ~string
-}
-
-type E1 interface {
-	~int | ~float64 | ~string
-}
-
-type E2 interface {
-	~float64
-}
-
-type I0 interface {
-	E0
-}
-
-func f0[T I0]() {}
-var _ = f0[int]
-var _ = f0[bool]
-var _ = f0[string]
-var _ = f0[float64 /* ERROR does not implement I0 */ ]
-
-type I01 interface {
-	E0
-	E1
-}
-
-func f01[T I01]() {}
-var _ = f01[int]
-var _ = f01[bool /* ERROR does not implement I0 */ ]
-var _ = f01[string]
-var _ = f01[float64 /* ERROR does not implement I0 */ ]
-
-type I012 interface {
-	E0
-	E1
-	E2
-}
-
-func f012[T I012]() {}
-var _ = f012[int /* ERROR cannot implement I012.*empty type set */ ]
-var _ = f012[bool /* ERROR cannot implement I012.*empty type set */ ]
-var _ = f012[string /* ERROR cannot implement I012.*empty type set */ ]
-var _ = f012[float64 /* ERROR cannot implement I012.*empty type set */ ]
-
-type I12 interface {
-	E1
-	E2
-}
-
-func f12[T I12]() {}
-var _ = f12[int /* ERROR does not implement I12 */ ]
-var _ = f12[bool /* ERROR does not implement I12 */ ]
-var _ = f12[string /* ERROR does not implement I12 */ ]
-var _ = f12[float64]
-
-type I0_ interface {
-	E0
-	~int
-}
-
-func f0_[T I0_]() {}
-var _ = f0_[int]
-var _ = f0_[bool /* ERROR does not implement I0_ */ ]
-var _ = f0_[string /* ERROR does not implement I0_ */ ]
-var _ = f0_[float64 /* ERROR does not implement I0_ */ ]
-
-// Using a function instance as a type is an error.
-var _ f0 // ERROR not a type
-var _ f0 /* ERROR not a type */ [int]
-
-// Empty type sets can only be satisfied by empty type sets.
-type none interface {
-	// force an empty type set
-        int
-        string
-}
-
-func ff[T none]() {}
-func gg[T any]() {}
-func hh[T ~int]() {}
-
-func _[T none]() {
-	_ = ff[int /* ERROR cannot implement none \(empty type set\) */ ]
-	_ = ff[T]  // pathological but ok because T's type set is empty, too
-	_ = gg[int]
-	_ = gg[T]
-	_ = hh[int]
-	_ = hh[T]
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/typeinstcycles.go b/src/cmd/compile/internal/types2/testdata/check/typeinstcycles.go
deleted file mode 100644
index 74fe19195a..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/typeinstcycles.go
+++ /dev/null
@@ -1,11 +0,0 @@
-// Copyright 2021 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package p
-
-import "unsafe"
-
-func F1[T any](_ [unsafe.Sizeof(F1[int])]T) (res T)      { return }
-func F2[T any](_ T) (res [unsafe.Sizeof(F2[string])]int) { return }
-func F3[T any](_ [unsafe.Sizeof(F1[string])]int)         {}
diff --git a/src/cmd/compile/internal/types2/testdata/check/typeparams.go b/src/cmd/compile/internal/types2/testdata/check/typeparams.go
deleted file mode 100644
index 766500c6b9..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/typeparams.go
+++ /dev/null
@@ -1,508 +0,0 @@
-// Copyright 2018 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package p
-
-// import "io" // for type assertion tests
-
-var _ any // ok to use any anywhere
-func _[_ any, _ interface{any}](any) {
-        var _ any
-}
-
-func identity[T any](x T) T { return x }
-
-func _[_ any](x int) int { panic(0) }
-func _[T any](T /* ERROR redeclared */ T)() {}
-func _[T, T /* ERROR redeclared */ any]() {}
-
-// Constraints (incl. any) may be parenthesized.
-func _[_ (any)]() {}
-func _[_ (interface{})]() {}
-
-func reverse[T any](list []T) []T {
-        rlist := make([]T, len(list))
-        i := len(list)
-        for _, x := range list {
-                i--
-                rlist[i] = x
-        }
-        return rlist
-}
-
-var _ = reverse /* ERROR cannot use generic function reverse */
-var _ = reverse[int, float32 /* ERROR got 2 type arguments */ ] ([]int{1, 2, 3})
-var _ = reverse[int]([ /* ERROR cannot use */ ]float32{1, 2, 3})
-var f = reverse[chan int]
-var _ = f(0 /* ERROR cannot use 0 .* as \[\]chan int */ )
-
-func swap[A, B any](a A, b B) (B, A) { return b, a }
-
-var _ = swap /* ERROR single value is expected */ [int, float32](1, 2)
-var f32, i = swap[int, float32](swap[float32, int](1, 2))
-var _ float32 = f32
-var _ int = i
-
-func swapswap[A, B any](a A, b B) (A, B) {
-        return swap[B, A](b, a)
-}
-
-type F[A, B any] func(A, B) (B, A)
-
-func min[T interface{ ~int }](x, y T) T {
-        if x < y {
-                return x
-        }
-        return y
-}
-
-func _[T interface{~int | ~float32}](x, y T) bool { return x < y }
-func _[T any](x, y T) bool { return x /* ERROR cannot compare */ < y }
-func _[T interface{~int | ~float32 | ~bool}](x, y T) bool { return x /* ERROR cannot compare */ < y }
-
-func _[T C1[T]](x, y T) bool { return x /* ERROR cannot compare */ < y }
-func _[T C2[T]](x, y T) bool { return x < y }
-
-type C1[T any] interface{}
-type C2[T any] interface{ ~int | ~float32 }
-
-func new[T any]() *T {
-        var x T
-        return &x
-}
-
-var _ = new /* ERROR cannot use generic function new */
-var _ *int = new[int]()
-
-func _[T any](map[T /* ERROR invalid map key type T \(missing comparable constraint\) */]int) {} // w/o constraint we don't know if T is comparable
-
-func f1[T1 any](struct{T1 /* ERROR cannot be a .* type parameter */ }) int { panic(0) }
-var _ = f1[int](struct{T1}{})
-type T1 = int
-
-func f2[t1 any](struct{t1 /* ERROR cannot be a .* type parameter */ ; x float32}) int { panic(0) }
-var _ = f2[t1](struct{t1; x float32}{})
-type t1 = int
-
-
-func f3[A, B, C any](A, struct{x B}, func(A, struct{x B}, *C)) int { panic(0) }
-
-var _ = f3[int, rune, bool](1, struct{x rune}{}, nil)
-
-// indexing
-
-func _[T any] (x T, i int) { _ = x /* ERROR "cannot index" */ [i] }
-func _[T interface{ ~int }] (x T, i int) { _ = x /* ERROR "cannot index" */ [i] }
-func _[T interface{ ~string }] (x T, i int) { _ = x[i] }
-func _[T interface{ ~[]int }] (x T, i int) { _ = x[i] }
-func _[T interface{ ~[10]int | ~*[20]int | ~map[int]int }] (x T, i int) { _ = x /* ERROR cannot index */ [i] } // map and non-map types
-func _[T interface{ ~string | ~[]byte }] (x T, i int) { _ = x[i] }
-func _[T interface{ ~[]int | ~[1]rune }] (x T, i int) { _ = x /* ERROR "cannot index" */ [i] }
-func _[T interface{ ~string | ~[]rune }] (x T, i int) { _ = x /* ERROR "cannot index" */ [i] }
-
-// indexing with various combinations of map types in type sets (see issue #42616)
-func _[T interface{ ~[]E | ~map[int]E }, E any](x T, i int) { _ = x /* ERROR cannot index */ [i] } // map and non-map types
-func _[T interface{ ~[]E }, E any](x T, i int) { _ = &x[i] }
-func _[T interface{ ~map[int]E }, E any](x T, i int) { _, _ = x[i] } // comma-ok permitted
-func _[T interface{ ~map[int]E }, E any](x T, i int) { _ = &x /* ERROR cannot take address */ [i] }
-func _[T interface{ ~map[int]E | ~map[uint]E }, E any](x T, i int) { _ = x /* ERROR cannot index */ [i] } // different map element types
-func _[T interface{ ~[]E | ~map[string]E }, E any](x T, i int) { _ = x /* ERROR cannot index */ [i] } // map and non-map types
-
-// indexing with various combinations of array and other types in type sets
-func _[T interface{ [10]int }](x T, i int) { _ = x[i]; _ = x[9]; _ = x[10 /* ERROR out of bounds */ ] }
-func _[T interface{ [10]byte | string }](x T, i int) { _ = x[i]; _ = x[9]; _ = x[10 /* ERROR out of bounds */ ] }
-func _[T interface{ [10]int | *[20]int | []int }](x T, i int) { _ = x[i]; _ = x[9]; _ = x[10 /* ERROR out of bounds */ ] }
-
-// indexing with strings and non-variable arrays (assignment not permitted)
-func _[T string](x T) { _ = x[0]; x /* ERROR cannot assign */ [0] = 0 }
-func _[T []byte | string](x T) { x /* ERROR cannot assign */ [0] = 0 }
-func _[T [10]byte]() { f := func() (x T) { return }; f /* ERROR cannot assign */ ()[0] = 0 }
-func _[T [10]byte]() { f := func() (x *T) { return }; f /* ERROR cannot index */ ()[0] = 0 }
-func _[T [10]byte]() { f := func() (x *T) { return }; (*f())[0] = 0 }
-func _[T *[10]byte]() { f := func() (x T) { return }; f()[0] = 0 }
-
-// slicing
-
-func _[T interface{ ~[10]E }, E any] (x T, i, j, k int) { var _ []E = x[i:j] }
-func _[T interface{ ~[10]E }, E any] (x T, i, j, k int) { var _ []E = x[i:j:k] }
-func _[T interface{ ~[]byte }] (x T, i, j, k int) { var _ T = x[i:j] }
-func _[T interface{ ~[]byte }] (x T, i, j, k int) { var _ T = x[i:j:k] }
-func _[T interface{ ~string }] (x T, i, j, k int) { var _ T = x[i:j] }
-func _[T interface{ ~string }] (x T, i, j, k int) { var _ T = x[i:j:k /* ERROR 3-index slice of string */ ] }
-
-type myByte1 []byte
-type myByte2 []byte
-func _[T interface{ []byte | myByte1 | myByte2 }] (x T, i, j, k int) { var _ T = x[i:j:k] }
-func _[T interface{ []byte | myByte1 | []int }] (x T, i, j, k int) { var _ T = x /* ERROR no core type */ [i:j:k] }
-
-func _[T interface{ []byte | myByte1 | myByte2 | string }] (x T, i, j, k int) { var _ T = x[i:j] }
-func _[T interface{ []byte | myByte1 | myByte2 | string }] (x T, i, j, k int) { var _ T = x[i:j:k /* ERROR 3-index slice of string */ ] }
-func _[T interface{ []byte | myByte1 | []int | string }] (x T, i, j, k int) { var _ T = x /* ERROR no core type */ [i:j] }
-
-// len/cap built-ins
-
-func _[T any](x T) { _ = len(x /* ERROR invalid argument */ ) }
-func _[T interface{ ~int }](x T) { _ = len(x /* ERROR invalid argument */ ) }
-func _[T interface{ ~string | ~[]byte | ~int }](x T) { _ = len(x /* ERROR invalid argument */ ) }
-func _[T interface{ ~string }](x T) { _ = len(x) }
-func _[T interface{ ~[10]int }](x T) { _ = len(x) }
-func _[T interface{ ~[]byte }](x T) { _ = len(x) }
-func _[T interface{ ~map[int]int }](x T) { _ = len(x) }
-func _[T interface{ ~chan int }](x T) { _ = len(x) }
-func _[T interface{ ~string | ~[]byte | ~chan int }](x T) { _ = len(x) }
-
-func _[T any](x T) { _ = cap(x /* ERROR invalid argument */ ) }
-func _[T interface{ ~int }](x T) { _ = cap(x /* ERROR invalid argument */ ) }
-func _[T interface{ ~string | ~[]byte | ~int }](x T) { _ = cap(x /* ERROR invalid argument */ ) }
-func _[T interface{ ~string }](x T) { _ = cap(x /* ERROR invalid argument */ ) }
-func _[T interface{ ~[10]int }](x T) { _ = cap(x) }
-func _[T interface{ ~[]byte }](x T) { _ = cap(x) }
-func _[T interface{ ~map[int]int }](x T) { _ = cap(x /* ERROR invalid argument */ ) }
-func _[T interface{ ~chan int }](x T) { _ = cap(x) }
-func _[T interface{ ~[]byte | ~chan int }](x T) { _ = cap(x) }
-
-// range iteration
-
-func _[T interface{}](x T) {
-        for range x /* ERROR cannot range */ {}
-}
-
-type myString string
-
-func _[
-        B1 interface{ string },
-        B2 interface{ string | myString },
-
-        C1 interface{ chan int },
-        C2 interface{ chan int | <-chan int },
-        C3 interface{ chan<- int },
-
-        S1 interface{ []int },
-        S2 interface{ []int | [10]int },
-
-        A1 interface{ [10]int },
-        A2 interface{ [10]int | []int },
-
-        P1 interface{ *[10]int },
-        P2 interface{ *[10]int | *[]int },
-
-        M1 interface{ map[string]int },
-        M2 interface{ map[string]int | map[string]string },
-]() {
-        var b0 string
-        for range b0 {}
-        for _ = range b0 {}
-        for _, _ = range b0 {}
-
-        var b1 B1
-        for range b1 {}
-        for _ = range b1 {}
-        for _, _ = range b1 {}
-
-        var b2 B2
-        for range b2 {}
-
-        var c0 chan int
-        for range c0 {}
-        for _ = range c0 {}
-        for _, _ /* ERROR permits only one iteration variable */ = range c0 {}
-
-        var c1 C1
-        for range c1 {}
-        for _ = range c1 {}
-        for _, _ /* ERROR permits only one iteration variable */ = range c1 {}
-
-        var c2 C2
-        for range c2 {}
-
-        var c3 C3
-        for range c3 /* ERROR receive from send-only channel */ {}
-
-        var s0 []int
-        for range s0 {}
-        for _ = range s0 {}
-        for _, _ = range s0 {}
-
-        var s1 S1
-        for range s1 {}
-        for _ = range s1 {}
-        for _, _ = range s1 {}
-
-        var s2 S2
-        for range s2 /* ERROR cannot range over s2.*no core type */ {}
-
-        var a0 []int
-        for range a0 {}
-        for _ = range a0 {}
-        for _, _ = range a0 {}
-
-        var a1 A1
-        for range a1 {}
-        for _ = range a1 {}
-        for _, _ = range a1 {}
-
-        var a2 A2
-        for range a2 /* ERROR cannot range over a2.*no core type */ {}
-
-        var p0 *[10]int
-        for range p0 {}
-        for _ = range p0 {}
-        for _, _ = range p0 {}
-
-        var p1 P1
-        for range p1 {}
-        for _ = range p1 {}
-        for _, _ = range p1 {}
-
-        var p2 P2
-        for range p2 /* ERROR cannot range over p2.*no core type */ {}
-
-        var m0 map[string]int
-        for range m0 {}
-        for _ = range m0 {}
-        for _, _ = range m0 {}
-
-        var m1 M1
-        for range m1 {}
-        for _ = range m1 {}
-        for _, _ = range m1 {}
-
-        var m2 M2
-        for range m2 /* ERROR cannot range over m2.*no core type */ {}
-}
-
-// type inference checks
-
-var _ = new /* ERROR cannot infer T */ ()
-
-func f4[A, B, C any](A, B) C { panic(0) }
-
-var _ = f4 /* ERROR cannot infer C */ (1, 2)
-var _ = f4[int, float32, complex128](1, 2)
-
-func f5[A, B, C any](A, []*B, struct{f []C}) int { panic(0) }
-
-var _ = f5[int, float32, complex128](0, nil, struct{f []complex128}{})
-var _ = f5 /* ERROR cannot infer */ (0, nil, struct{f []complex128}{})
-var _ = f5(0, []*float32{new[float32]()}, struct{f []complex128}{})
-
-func f6[A any](A, []A) int { panic(0) }
-
-var _ = f6(0, nil)
-
-func f6nil[A any](A) int { panic(0) }
-
-var _ = f6nil /* ERROR cannot infer */ (nil)
-
-// type inference with variadic functions
-
-func f7[T any](...T) T { panic(0) }
-
-var _ int = f7 /* ERROR cannot infer T */ ()
-var _ int = f7(1)
-var _ int = f7(1, 2)
-var _ int = f7([]int{}...)
-var _ int = f7 /* ERROR cannot use */ ([]float64{}...)
-var _ float64 = f7([]float64{}...)
-var _ = f7[float64](1, 2.3)
-var _ = f7(float64(1), 2.3)
-var _ = f7(1, 2.3 /* ERROR does not match */ )
-var _ = f7(1.2, 3 /* ERROR does not match */ )
-
-func f8[A, B any](A, B, ...B) int { panic(0) }
-
-var _ = f8(1) /* ERROR not enough arguments */
-var _ = f8(1, 2.3)
-var _ = f8(1, 2.3, 3.4, 4.5)
-var _ = f8(1, 2.3, 3.4, 4 /* ERROR does not match */ )
-var _ = f8[int, float64](1, 2.3, 3.4, 4)
-
-var _ = f8[int, float64](0, 0, nil...) // test case for #18268
-
-// init functions cannot have type parameters
-
-func init() {}
-func init[_ /* ERROR func init must have no type parameters */ any]() {}
-func init[P /* ERROR func init must have no type parameters */ any]() {}
-
-type T struct {}
-
-func (T) m1() {}
-func (T) m2[ /* ERROR method must have no type parameters */ _ any]() {}
-func (T) m3[ /* ERROR method must have no type parameters */ P any]() {}
-
-// type inference across parameterized types
-
-type S1[P any] struct { f P }
-
-func f9[P any](x S1[P]) {}
-
-func _() {
-        f9[int](S1[int]{42})
-	f9(S1[int]{42})
-}
-
-type S2[A, B, C any] struct{}
-
-func f10[X, Y, Z any](a S2[X, int, Z], b S2[X, Y, bool]) {}
-
-func _[P any]() {
-        f10[int, float32, string](S2[int, int, string]{}, S2[int, float32, bool]{})
-        f10(S2[int, int, string]{}, S2[int, float32, bool]{})
-        f10(S2[P, int, P]{}, S2[P, float32, bool]{})
-}
-
-// corner case for type inference
-// (was bug: after instanting f11, the type-checker didn't mark f11 as non-generic)
-
-func f11[T any]() {}
-
-func _() {
-	f11[int]()
-}
-
-// the previous example was extracted from
-
-// For now, a lone type parameter is not permitted as RHS in a type declaration (issue #45639).
-// func f12[T interface{m() T}]() {}
-// 
-// type A[T any] T
-// 
-// func (a A[T]) m() A[T]
-// 
-// func _[T any]() {
-// 	f12[A[T]]()
-// }
-
-// method expressions
-
-func (_ S1[P]) m()
-
-func _() {
-	m := S1[int].m
-	m(struct { f int }{42})
-}
-
-func _[T any] (x T) {
-        m := S1[T].m
-        m(S1[T]{x})
-}
-
-type I1[A any] interface {
-        m1(A)
-}
-
-var _ I1[int] = r1[int]{}
-
-type r1[T any] struct{}
-
-func (_ r1[T]) m1(T)
-
-type I2[A, B any] interface {
-        m1(A)
-        m2(A) B
-}
-
-var _ I2[int, float32] = R2[int, float32]{}
-
-type R2[P, Q any] struct{}
-
-func (_ R2[X, Y]) m1(X)
-func (_ R2[X, Y]) m2(X) Y
-
-// type assertions and type switches over generic types
-// NOTE: These are currently disabled because it's unclear what the correct
-// approach is, and one can always work around by assigning the variable to
-// an interface first.
-
-// // ReadByte1 corresponds to the ReadByte example in the draft design.
-// func ReadByte1[T io.Reader](r T) (byte, error) {
-// 	if br, ok := r.(io.ByteReader); ok {
-// 		return br.ReadByte()
-// 	}
-// 	var b [1]byte
-// 	_, err := r.Read(b[:])
-// 	return b[0], err
-// }
-//
-// // ReadBytes2 is like ReadByte1 but uses a type switch instead.
-// func ReadByte2[T io.Reader](r T) (byte, error) {
-//         switch br := r.(type) {
-//         case io.ByteReader:
-//                 return br.ReadByte()
-//         }
-// 	var b [1]byte
-// 	_, err := r.Read(b[:])
-// 	return b[0], err
-// }
-//
-// // type assertions and type switches over generic types are strict
-// type I3 interface {
-//         m(int)
-// }
-//
-// type I4 interface {
-//         m() int // different signature from I3.m
-// }
-//
-// func _[T I3](x I3, p T) {
-//         // type assertions and type switches over interfaces are not strict
-//         _ = x.(I4)
-//         switch x.(type) {
-//         case I4:
-//         }
-//
-//         // type assertions and type switches over generic types are strict
-//         _ = p /* ERROR cannot have dynamic type I4 */.(I4)
-//         switch p.(type) {
-//         case I4 /* ERROR cannot have dynamic type I4 */ :
-//         }
-// }
-
-// type assertions and type switches over generic types lead to errors for now
-
-func _[T any](x T) {
-	_ = x /* ERROR cannot use type assertion */ .(int)
-	switch x /* ERROR cannot use type switch */ .(type) {
-	}
-
-	// work-around
-	var t interface{} = x
-	_ = t.(int)
-	switch t.(type) {
-	}
-}
-
-func _[T interface{~int}](x T) {
-	_ = x /* ERROR cannot use type assertion */ .(int)
-	switch x /* ERROR cannot use type switch */ .(type) {
-	}
-
-	// work-around
-	var t interface{} = x
-	_ = t.(int)
-	switch t.(type) {
-	}
-}
-
-// error messages related to type bounds mention those bounds
-type C[P any] interface{}
-
-func _[P C[P]] (x P) {
-	x.m /* ERROR x.m undefined */ ()
-}
-
-type I interface {}
-
-func _[P I] (x P) {
-	x.m /* ERROR type P has no field or method m */ ()
-}
-
-func _[P interface{}] (x P) {
-	x.m /* ERROR type P has no field or method m */ ()
-}
-
-func _[P any] (x P) {
-	x.m /* ERROR type P has no field or method m */ ()
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/unions.go b/src/cmd/compile/internal/types2/testdata/check/unions.go
deleted file mode 100644
index bcd7de6644..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/unions.go
+++ /dev/null
@@ -1,66 +0,0 @@
-// Copyright 2021 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Check that overlong unions don't bog down type checking.
-// Disallow them for now.
-
-package p
-
-type t int
-
-type (
-	t00 t; t01 t; t02 t; t03 t; t04 t; t05 t; t06 t; t07 t; t08 t; t09 t
-	t10 t; t11 t; t12 t; t13 t; t14 t; t15 t; t16 t; t17 t; t18 t; t19 t
-	t20 t; t21 t; t22 t; t23 t; t24 t; t25 t; t26 t; t27 t; t28 t; t29 t
-	t30 t; t31 t; t32 t; t33 t; t34 t; t35 t; t36 t; t37 t; t38 t; t39 t
-	t40 t; t41 t; t42 t; t43 t; t44 t; t45 t; t46 t; t47 t; t48 t; t49 t
-	t50 t; t51 t; t52 t; t53 t; t54 t; t55 t; t56 t; t57 t; t58 t; t59 t
-	t60 t; t61 t; t62 t; t63 t; t64 t; t65 t; t66 t; t67 t; t68 t; t69 t
-	t70 t; t71 t; t72 t; t73 t; t74 t; t75 t; t76 t; t77 t; t78 t; t79 t
-	t80 t; t81 t; t82 t; t83 t; t84 t; t85 t; t86 t; t87 t; t88 t; t89 t
-	t90 t; t91 t; t92 t; t93 t; t94 t; t95 t; t96 t; t97 t; t98 t; t99 t
-)
-
-type u99 interface {
-	t00|t01|t02|t03|t04|t05|t06|t07|t08|t09|
-	t10|t11|t12|t13|t14|t15|t16|t17|t18|t19|
-	t20|t21|t22|t23|t24|t25|t26|t27|t28|t29|
-	t30|t31|t32|t33|t34|t35|t36|t37|t38|t39|
-	t40|t41|t42|t43|t44|t45|t46|t47|t48|t49|
-	t50|t51|t52|t53|t54|t55|t56|t57|t58|t59|
-	t60|t61|t62|t63|t64|t65|t66|t67|t68|t69|
-	t70|t71|t72|t73|t74|t75|t76|t77|t78|t79|
-	t80|t81|t82|t83|t84|t85|t86|t87|t88|t89|
-	t90|t91|t92|t93|t94|t95|t96|t97|t98
-}
-
-type u100a interface {
-	u99|float32
-}
-
-type u100b interface {
-	u99|float64
-}
-
-type u101 interface {
-	t00|t01|t02|t03|t04|t05|t06|t07|t08|t09|
-	t10|t11|t12|t13|t14|t15|t16|t17|t18|t19|
-	t20|t21|t22|t23|t24|t25|t26|t27|t28|t29|
-	t30|t31|t32|t33|t34|t35|t36|t37|t38|t39|
-	t40|t41|t42|t43|t44|t45|t46|t47|t48|t49|
-	t50|t51|t52|t53|t54|t55|t56|t57|t58|t59|
-	t60|t61|t62|t63|t64|t65|t66|t67|t68|t69|
-	t70|t71|t72|t73|t74|t75|t76|t77|t78|t79|
-	t80|t81|t82|t83|t84|t85|t86|t87|t88|t89|
-	t90|t91|t92|t93|t94|t95|t96|t97|t98|t99|
-        int // ERROR cannot handle more than 100 union terms
-}
-
-type u102 interface {
-        int /* ERROR cannot handle more than 100 union terms */ |string|u100a
-}
-
-type u200 interface {
-        u100a /* ERROR cannot handle more than 100 union terms */ |u100b
-}
diff --git a/src/cmd/compile/internal/types2/testdata/check/vardecl.go b/src/cmd/compile/internal/types2/testdata/check/vardecl.go
deleted file mode 100644
index 11591af385..0000000000
--- a/src/cmd/compile/internal/types2/testdata/check/vardecl.go
+++ /dev/null
@@ -1,215 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package vardecl
-
-// Prerequisites.
-import "math"
-func f() {}
-func g() (x, y int) { return }
-var m map[string]int
-
-// Var decls must have a type or an initializer.
-var _ int
-var _, _ int
-
-var _; /* ERROR "expected type" */
-var _, _; /* ERROR "expected type" */
-var _, _, _; /* ERROR "expected type" */
-
-// The initializer must be an expression.
-var _ = int /* ERROR "not an expression" */
-var _ = f /* ERROR "used as value" */ ()
-
-// Identifier and expression arity must match.
-var _, _ = 1, 2
-var _ = 1, 2 /* ERROR "extra init expr 2" */
-var _, _ = 1 /* ERROR "cannot initialize [0-9]+ variables with [0-9]+ values" */
-var _, _, _ /* ERROR "missing init expr for _" */ = 1, 2
-
-var _ = g /* ERROR "2-valued g" */ ()
-var _, _ = g()
-var _, _, _ = g /* ERROR "cannot initialize [0-9]+ variables with [0-9]+ values" */ ()
-
-var _ = m["foo"]
-var _, _ = m["foo"]
-var _, _, _ = m  /* ERROR "cannot initialize [0-9]+ variables with [0-9]+ values" */ ["foo"]
-
-var _, _ int = 1, 2
-var _ int = 1, 2 /* ERROR "extra init expr 2" */
-var _, _ int = 1 /* ERROR "cannot initialize [0-9]+ variables with [0-9]+ values" */
-var _, _, _ /* ERROR "missing init expr for _" */ int = 1, 2
-
-var (
-	_, _ = 1, 2
-	_ = 1, 2 /* ERROR "extra init expr 2" */
-	_, _ = 1 /* ERROR "cannot initialize [0-9]+ variables with [0-9]+ values" */
-	_, _, _ /* ERROR "missing init expr for _" */ = 1, 2
-
-	_ = g /* ERROR "2-valued g" */ ()
-	_, _ = g()
-	_, _, _ = g /* ERROR "cannot initialize [0-9]+ variables with [0-9]+ values" */ ()
-
-	_ = m["foo"]
-	_, _ = m["foo"]
-	_, _, _ = m /* ERROR "cannot initialize [0-9]+ variables with [0-9]+ values" */ ["foo"]
-
-	_, _ int = 1, 2
-	_ int = 1, 2 /* ERROR "extra init expr 2" */
-	_, _ int = 1 /* ERROR "cannot initialize [0-9]+ variables with [0-9]+ values" */
-	_, _, _ /* ERROR "missing init expr for _" */ int = 1, 2
-)
-
-// Variables declared in function bodies must be 'used'.
-type T struct{}
-func (r T) _(a, b, c int) (u, v, w int) {
-	var x1 /* ERROR "declared but not used" */ int
-	var x2 /* ERROR "declared but not used" */ int
-	x1 = 1
-	(x2) = 2
-
-	y1 /* ERROR "declared but not used" */ := 1
-	y2 /* ERROR "declared but not used" */ := 2
-	y1 = 1
-	(y1) = 2
-
-	{
-		var x1 /* ERROR "declared but not used" */ int
-		var x2 /* ERROR "declared but not used" */ int
-		x1 = 1
-		(x2) = 2
-
-		y1 /* ERROR "declared but not used" */ := 1
-		y2 /* ERROR "declared but not used" */ := 2
-		y1 = 1
-		(y1) = 2
-	}
-
-	if x /* ERROR "declared but not used" */ := 0; a < b {}
-
-	switch x /* ERROR "declared but not used" */, y := 0, 1; a {
-	case 0:
-		_ = y
-	case 1:
-		x /* ERROR "declared but not used" */ := 0
-	}
-
-	var t interface{}
-	switch t /* ERROR "declared but not used" */ := t.(type) {}
-
-	switch t /* ERROR "declared but not used" */ := t.(type) {
-	case int:
-	}
-
-	switch t /* ERROR "declared but not used" */ := t.(type) {
-	case int:
-	case float32, complex64:
-		t = nil
-	}
-
-	switch t := t.(type) {
-	case int:
-	case float32, complex64:
-		_ = t
-	}
-
-	switch t := t.(type) {
-	case int:
-	case float32:
-	case string:
-		_ = func() string {
-			return t
-		}
-	}
-
-	switch t := t; t /* ERROR "declared but not used" */ := t.(type) {}
-
-	var z1 /* ERROR "declared but not used" */ int
-	var z2 int
-	_ = func(a, b, c int) (u, v, w int) {
-		z1 = a
-		(z1) = b
-		a = z2
-		return
-	}
-
-	var s []int
-	var i /* ERROR "declared but not used" */ , j int
-	for i, j = range s {
-		_ = j
-	}
-
-	for i, j /* ERROR "declared but not used" */ := range s {
-		_ = func() int {
-			return i
-		}
-	}
-	return
-}
-
-// Unused variables in function literals must lead to only one error (issue #22524).
-func _() {
-	_ = func() {
-		var x /* ERROR declared but not used */ int
-	}
-}
-
-// Invalid variable declarations must not lead to "declared but not used errors".
-// TODO(gri) enable these tests once go/types follows types2 logic for declared but not used variables
-// func _() {
-//	var a x                        // DISABLED_ERROR undeclared name: x
-//	var b = x                      // DISABLED_ERROR undeclared name: x
-//	var c int = x                  // DISABLED_ERROR undeclared name: x
-//	var d, e, f x                  /* DISABLED_ERROR x */ /* DISABLED_ERROR x */ /* DISABLED_ERROR x */
-//	var g, h, i = x, x, x          /* DISABLED_ERROR x */ /* DISABLED_ERROR x */ /* DISABLED_ERROR x */
-//	var j, k, l float32 = x, x, x  /* DISABLED_ERROR x */ /* DISABLED_ERROR x */ /* DISABLED_ERROR x */
-//	// but no "declared but not used" errors
-// }
-
-// Invalid (unused) expressions must not lead to spurious "declared but not used errors".
-func _() {
-	var a, b, c int
-	var x, y int
-	x, y = a /* ERROR cannot assign [0-9]+ values to [0-9]+ variables */ , b, c
-	_ = x
-	_ = y
-}
-
-func _() {
-	var x int
-	return x /* ERROR too many return values */
-	return math /* ERROR too many return values */ .Sin(0)
-}
-
-func _() int {
-	var x, y int
-	return x, y /* ERROR too many return values */
-}
-
-// Short variable declarations must declare at least one new non-blank variable.
-func _() {
-	_ := /* ERROR no new variables */ 0
-	_, a := 0, 1
-	_, a := /* ERROR no new variables */ 0, 1
-	_, a, b := 0, 1, 2
-	_, _, _ := /* ERROR no new variables */ 0, 1, 2
-
-	_ = a
-	_ = b
-}
-
-// Test case for variables depending on function literals (see also #22992).
-var A /* ERROR initialization cycle */ = func() int { return A }()
-
-func _() {
-	// The function literal below must not see a.
-	var a = func() int { return a /* ERROR "undeclared name" */ }()
-	var _ = func() int { return a }()
-
-	// The function literal below must not see x, y, or z.
-	var x, y, z = 0, 1, func() int { return x /* ERROR "undeclared name" */ + y /* ERROR "undeclared name" */ + z /* ERROR "undeclared name" */ }()
-	_, _, _ = x, y, z
-}
-
-// TODO(gri) consolidate other var decl checks in this file
\ No newline at end of file
