commit 839a68469b6f8bf40620a7977041e089bbd0eba3
Author: Russ Cox <rsc@golang.org>
Date:   Tue Jan 20 14:40:40 2009 -0800

    delete export
    
    TBR=r
    OCL=23121
    CL=23127
---
 doc/progs/fd.go                         |  6 +--
 doc/progs/sort.go                       | 24 +++++------
 src/cmd/gc/sys.go                       | 48 ++++++++++-----------
 src/lib/bignum.go                       | 32 +++++++-------
 src/lib/bignum_test.go                  | 36 ++++++++--------
 src/lib/bufio.go                        | 14 +++---
 src/lib/bufio_test.go                   |  6 +--
 src/lib/container/array/array.go        |  8 ++--
 src/lib/container/array/array_test.go   | 12 +++---
 src/lib/container/array/intarray.go     |  4 +-
 src/lib/flag.go                         | 38 ++++++++---------
 src/lib/fmt/fmt_test.go                 | 10 ++---
 src/lib/fmt/format.go                   |  4 +-
 src/lib/fmt/print.go                    | 24 +++++------
 src/lib/hash/adler32.go                 |  4 +-
 src/lib/hash/adler32_test.go            |  2 +-
 src/lib/hash/crc32.go                   | 14 +++---
 src/lib/hash/crc32_test.go              |  2 +-
 src/lib/hash/md5.go                     |  4 +-
 src/lib/hash/md5_test.go                |  2 +-
 src/lib/hash/sha1.go                    |  4 +-
 src/lib/hash/sha1_test.go               |  2 +-
 src/lib/http/conn.go                    |  4 +-
 src/lib/http/request.go                 |  6 +--
 src/lib/http/server.go                  |  4 +-
 src/lib/http/url.go                     | 10 ++---
 src/lib/io/bytebuffer.go                |  5 +--
 src/lib/io/io.go                        | 22 +++++-----
 src/lib/json/generic.go                 | 14 +++---
 src/lib/json/generic_test.go            |  4 +-
 src/lib/json/parse.go                   |  8 ++--
 src/lib/json/struct.go                  |  2 +-
 src/lib/json/struct_test.go             |  2 +-
 src/lib/malloc.go                       | 10 ++---
 src/lib/math/all_test.go                | 24 +++++------
 src/lib/math/asin.go                    |  4 +-
 src/lib/math/atan.go                    |  2 +-
 src/lib/math/atan2.go                   |  2 +-
 src/lib/math/const.go                   |  2 +-
 src/lib/math/exp.go                     |  2 +-
 src/lib/math/fabs.go                    |  2 +-
 src/lib/math/floor.go                   |  4 +-
 src/lib/math/fmod.go                    |  2 +-
 src/lib/math/hypot.go                   |  2 +-
 src/lib/math/log.go                     |  4 +-
 src/lib/math/pow.go                     |  2 +-
 src/lib/math/pow10.go                   |  2 +-
 src/lib/math/sin.go                     |  4 +-
 src/lib/math/sinh.go                    |  4 +-
 src/lib/math/sqrt.go                    |  2 +-
 src/lib/math/tan.go                     |  2 +-
 src/lib/math/tanh.go                    |  2 +-
 src/lib/net/dialgoogle_test.go          |  2 +-
 src/lib/net/dnsclient.go                |  4 +-
 src/lib/net/dnsconfig.go                |  4 +-
 src/lib/net/dnsmsg.go                   | 34 +++++++--------
 src/lib/net/fd.go                       |  4 +-
 src/lib/net/fd_darwin.go                |  4 +-
 src/lib/net/fd_linux.go                 |  4 +-
 src/lib/net/ip.go                       | 20 ++++-----
 src/lib/net/ip_test.go                  |  2 +-
 src/lib/net/net.go                      | 24 +++++------
 src/lib/net/net_darwin.go               | 16 +++----
 src/lib/net/net_linux.go                | 16 +++----
 src/lib/net/parse_test.go               |  2 +-
 src/lib/net/port.go                     |  2 +-
 src/lib/net/port_test.go                |  2 +-
 src/lib/net/tcpserver_test.go           |  2 +-
 src/lib/once.go                         |  2 +-
 src/lib/once_test.go                    |  2 +-
 src/lib/os/os_env.go                    |  4 +-
 src/lib/os/os_error.go                  |  8 ++--
 src/lib/os/os_file.go                   | 14 +++---
 src/lib/os/os_time.go                   |  2 +-
 src/lib/rand.go                         | 24 +++++------
 src/lib/reflect/all_test.go             | 12 +++---
 src/lib/reflect/tostring.go             |  8 ++--
 src/lib/reflect/type.go                 | 30 ++++++-------
 src/lib/reflect/value.go                | 62 +++++++++++++--------------
 src/lib/regexp/all_test.go              | 32 +++++++-------
 src/lib/regexp/regexp.go                | 26 +++++------
 src/lib/sort.go                         | 24 +++++------
 src/lib/sort_test.go                    | 16 +++----
 src/lib/strconv/atof.go                 |  6 +--
 src/lib/strconv/atof_test.go            |  4 +-
 src/lib/strconv/atoi.go                 |  8 ++--
 src/lib/strconv/atoi_test.go            |  8 ++--
 src/lib/strconv/decimal_test.go         |  6 +--
 src/lib/strconv/fp_test.go              |  2 +-
 src/lib/strconv/ftoa.go                 |  8 ++--
 src/lib/strconv/ftoa_test.go            |  2 +-
 src/lib/strconv/itoa.go                 |  4 +-
 src/lib/strconv/itoa_test.go            |  2 +-
 src/lib/strconv/quote.go                |  4 +-
 src/lib/strconv/quote_test.go           |  4 +-
 src/lib/strings.go                      | 10 ++---
 src/lib/strings_test.go                 |  8 ++--
 src/lib/sync/mutex.go                   |  2 +-
 src/lib/sync/mutex_test.go              |  8 ++--
 src/lib/syscall/errstr_darwin.go        |  4 +-
 src/lib/syscall/errstr_linux.go         |  4 +-
 src/lib/syscall/file_darwin.go          | 44 +++++++++----------
 src/lib/syscall/file_linux.go           | 46 ++++++++++----------
 src/lib/syscall/signal_amd64_darwin.go  |  2 +-
 src/lib/syscall/signal_amd64_linux.go   |  2 +-
 src/lib/syscall/socket_darwin.go        | 50 +++++++++++-----------
 src/lib/syscall/socket_linux.go         | 50 +++++++++++-----------
 src/lib/syscall/syscall.go              |  8 ++--
 src/lib/syscall/syscall_amd64_darwin.go |  2 +-
 src/lib/syscall/syscall_amd64_linux.go  |  2 +-
 src/lib/syscall/time_amd64_darwin.go    |  4 +-
 src/lib/syscall/time_amd64_linux.go     |  6 +--
 src/lib/syscall/types_amd64_darwin.go   | 34 +++++++--------
 src/lib/syscall/types_amd64_linux.go    | 34 +++++++--------
 src/lib/tabwriter/tabwriter.go          |  4 +-
 src/lib/tabwriter/tabwriter_test.go     |  2 +-
 src/lib/testing.go                      |  6 +--
 src/lib/time/tick.go                    |  4 +-
 src/lib/time/tick_test.go               |  2 +-
 src/lib/time/time.go                    | 16 +++----
 src/lib/time/time_test.go               |  4 +-
 src/lib/time/zoneinfo.go                |  4 +-
 src/lib/unicode/letter.go               | 12 +++---
 src/lib/unicode/letter_test.go          |  4 +-
 src/lib/utf8.go                         | 18 ++++----
 src/lib/utf8_test.go                    | 12 +++---
 test/235.go                             |  4 +-
 test/bigalg.go                          |  8 ++--
 test/bugs/bug117.go                     |  4 +-
 test/bugs/bug121.go                     |  6 +--
 test/bugs/bug123.go                     |  2 +-
 test/bugs/bug130.go                     |  4 +-
 test/chan/fifo.go                       |  8 ++--
 test/chan/powser1.go                    | 56 ++++++++++++------------
 test/chan/powser2.go                    | 56 ++++++++++++------------
 test/chan/select.go                     |  4 +-
 test/chan/sieve.go                      |  6 +--
 test/complit.go                         |  8 ++--
 test/export.go                          | 12 +++---
 test/fixedbugs/bug007.go                |  2 +-
 test/fixedbugs/bug011.go                |  2 +-
 test/fixedbugs/bug023.go                |  4 +-
 test/fixedbugs/bug025.go                |  2 +-
 test/fixedbugs/bug026.go                |  4 +-
 test/fixedbugs/bug027.go                |  6 +--
 test/fixedbugs/bug028.go                |  2 +-
 test/fixedbugs/bug044.go                |  2 +-
 test/fixedbugs/bug045.go                |  2 +-
 test/fixedbugs/bug046.go                |  2 +-
 test/fixedbugs/bug054.go                |  6 +--
 test/fixedbugs/bug057.go                |  4 +-
 test/fixedbugs/bug058.go                |  2 +-
 test/fixedbugs/bug059.go                |  2 +-
 test/fixedbugs/bug066.go                | 10 ++---
 test/fixedbugs/bug075.go                |  2 +-
 test/fixedbugs/bug083.dir/bug0.go       |  4 +-
 test/fixedbugs/bug084.go                |  2 +-
 test/fixedbugs/bug088.dir/bug0.go       |  6 +--
 test/fixedbugs/bug089.go                |  4 +-
 test/fixedbugs/bug093.go                |  4 +-
 test/fixedbugs/bug096.go                |  4 +-
 test/fixedbugs/bug097.go                |  2 +-
 test/fixedbugs/bug098.go                |  4 +-
 test/fixedbugs/bug099.go                |  8 ++--
 test/fixedbugs/bug106.dir/bug0.go       |  2 +-
 test/fixedbugs/bug111.go                |  4 +-
 test/fixedbugs/bug112.go                |  2 +-
 test/fixedbugs/bug113.go                |  2 +-
 test/fixedbugs/bug114.go                |  6 +--
 test/fixedbugs/bug118.go                |  2 +-
 test/fixedbugs/bug120.go                |  2 +-
 test/func.go                            |  2 +-
 test/hashmap.go                         | 14 +++---
 test/hilbert.go                         | 14 +++---
 test/interface.go                       |  8 ++--
 test/interface1.go                      |  8 ++--
 test/interface2.go                      |  6 +--
 test/interface3.go                      |  8 ++--
 test/interface4.go                      | 14 +++---
 test/interface5.go                      |  4 +-
 test/interface6.go                      | 12 +++---
 test/iota.go                            |  4 +-
 test/ken/chan.go                        |  2 +-
 test/ken/embed.go                       | 16 +++----
 test/ken/interbasic.go                  |  2 +-
 test/ken/interfun.go                    |  6 +--
 test/ken/intervar.go                    |  8 ++--
 test/ken/ptrfun.go                      |  2 +-
 test/ken/rob1.go                        |  8 ++--
 test/ken/rob2.go                        | 28 ++++++------
 test/ken/robfunc.go                     |  2 +-
 test/mallocrand.go                      |  2 +-
 test/mallocrep1.go                      |  4 +-
 test/map.go                             |  2 +-
 test/method.go                          | 14 +++---
 test/method1.go                         |  2 +-
 test/method2.go                         |  6 +--
 test/method3.go                         |  4 +-
 test/nil.go                             |  4 +-
 test/peano.go                           |  2 +-
 test/sieve.go                           |  6 +--
 test/test0.go                           |  2 +-
 test/vectors.go                         |  2 +-
 usr/gri/gosrc/ast.go                    | 36 ++++++++--------
 usr/gri/gosrc/base.go                   | 10 ++---
 usr/gri/gosrc/compilation.go            |  8 ++--
 usr/gri/gosrc/decls.go                  | 22 +++++-----
 usr/gri/gosrc/export.go                 | 28 ++++++------
 usr/gri/gosrc/expr.go                   | 46 ++++++++++----------
 usr/gri/gosrc/globals.go                | 40 ++++++++---------
 usr/gri/gosrc/import.go                 | 28 ++++++------
 usr/gri/gosrc/object.go                 |  4 +-
 usr/gri/gosrc/parser.go                 | 24 +++++------
 usr/gri/gosrc/platform.go               | 10 ++---
 usr/gri/gosrc/printer.go                | 20 ++++-----
 usr/gri/gosrc/scanner.go                |  8 ++--
 usr/gri/gosrc/test/b.go                 |  6 +--
 usr/gri/gosrc/test/c.go                 |  6 +--
 usr/gri/gosrc/test/d.go                 |  8 ++--
 usr/gri/gosrc/type.go                   | 30 ++++++-------
 usr/gri/gosrc/universe.go               | 16 +++----
 usr/gri/gosrc/utils.go                  | 12 +++---
 usr/gri/gosrc/verifier.go               |  4 +-
 usr/gri/pretty/ast.go                   | 76 ++++++++++++++++-----------------
 usr/gri/pretty/compilation.go           |  6 +--
 usr/gri/pretty/parser.go                |  8 ++--
 usr/gri/pretty/platform.go              | 10 ++---
 usr/gri/pretty/printer.go               | 36 ++++++++--------
 usr/gri/pretty/scanner.go               | 14 +++---
 usr/gri/pretty/selftest0.go             |  2 +-
 usr/gri/pretty/selftest2.go             |  6 +--
 usr/gri/pretty/typechecker.go           |  4 +-
 usr/gri/pretty/universe.go              | 16 +++----
 usr/gri/pretty/utils.go                 | 12 +++---
 234 files changed, 1198 insertions(+), 1199 deletions(-)

diff --git a/doc/progs/fd.go b/doc/progs/fd.go
index 8a9eb4eb2a..c99c87777a 100644
--- a/doc/progs/fd.go
+++ b/doc/progs/fd.go
@@ -9,7 +9,7 @@ import (
 	"syscall";
 )
 
-export type FD struct {
+type FD struct {
 	fildes  int64;  // file descriptor number
 	name    string; // file name at Open time
 }
@@ -21,13 +21,13 @@ func newFD(fd int64, name string) *FD {
 	return &FD{fd, name}
 }
 
-export var (
+var (
 	Stdin  = newFD(0, "/dev/stdin");
 	Stdout = newFD(1, "/dev/stdout");
 	Stderr = newFD(2, "/dev/stderr");
 )
 
-export func Open(name string, mode int64, perm int64) (fd *FD, err *os.Error) {
+func Open(name string, mode int64, perm int64) (fd *FD, err *os.Error) {
 	r, e := syscall.Open(name, mode, perm);
 	return newFD(r, name), os.ErrnoToError(e)
 }
diff --git a/doc/progs/sort.go b/doc/progs/sort.go
index 3d4fd98b24..687217a316 100644
--- a/doc/progs/sort.go
+++ b/doc/progs/sort.go
@@ -4,13 +4,13 @@
 
 package sort
 
-export type SortInterface interface {
+type SortInterface interface {
 	Len() int;
 	Less(i, j int) bool;
 	Swap(i, j int);
 }
 
-export func Sort(data SortInterface) {
+func Sort(data SortInterface) {
 	for i := 1; i < data.Len(); i++ {
 		for j := i; j > 0 && data.Less(j, j-1); j-- {
 			data.Swap(j, j-1);
@@ -18,7 +18,7 @@ export func Sort(data SortInterface) {
 	}
 }
 
-export func IsSorted(data SortInterface) bool {
+func IsSorted(data SortInterface) bool {
 	n := data.Len();
 	for i := n - 1; i > 0; i-- {
 		if data.Less(i, i - 1) {
@@ -30,21 +30,21 @@ export func IsSorted(data SortInterface) bool {
 
 // Convenience types for common cases
 
-export type IntArray []int
+type IntArray []int
 
 func (p IntArray) Len() int            { return len(p); }
 func (p IntArray) Less(i, j int) bool  { return p[i] < p[j]; }
 func (p IntArray) Swap(i, j int)       { p[i], p[j] = p[j], p[i]; }
 
 
-export type FloatArray []float
+type FloatArray []float
 
 func (p FloatArray) Len() int            { return len(p); }
 func (p FloatArray) Less(i, j int) bool  { return p[i] < p[j]; }
 func (p FloatArray) Swap(i, j int)       { p[i], p[j] = p[j], p[i]; }
 
 
-export type StringArray []string
+type StringArray []string
 
 func (p StringArray) Len() int            { return len(p); }
 func (p StringArray) Less(i, j int) bool  { return p[i] < p[j]; }
@@ -53,11 +53,11 @@ func (p StringArray) Swap(i, j int)       { p[i], p[j] = p[j], p[i]; }
 
 // Convenience wrappers for common cases
 
-export func SortInts(a []int)        { Sort(IntArray(a)); }
-export func SortFloats(a []float)    { Sort(FloatArray(a)); }
-export func SortStrings(a []string)  { Sort(StringArray(a)); }
+func SortInts(a []int)        { Sort(IntArray(a)); }
+func SortFloats(a []float)    { Sort(FloatArray(a)); }
+func SortStrings(a []string)  { Sort(StringArray(a)); }
 
 
-export func IntsAreSorted(a []int) bool       { return IsSorted(IntArray(a)); }
-export func FloatsAreSorted(a []float) bool   { return IsSorted(FloatArray(a)); }
-export func StringsAreSorted(a []string) bool { return IsSorted(StringArray(a)); }
+func IntsAreSorted(a []int) bool       { return IsSorted(IntArray(a)); }
+func FloatsAreSorted(a []float) bool   { return IsSorted(FloatArray(a)); }
+func StringsAreSorted(a []string) bool { return IsSorted(StringArray(a)); }
diff --git a/src/cmd/gc/sys.go b/src/cmd/gc/sys.go
index 7b2e3ad2e4..28a22fba36 100644
--- a/src/cmd/gc/sys.go
+++ b/src/cmd/gc/sys.go
@@ -69,35 +69,35 @@ func	arrays2d(old *any, nel int) (ary []any);
 
 // used by go programs
 
-export func	Breakpoint();
+func	Breakpoint();
 
-export func	Reflect(i interface { }) (uint64, string, bool);
-export func	Unreflect(uint64, string, bool) (ret interface { });
+func	Reflect(i interface { }) (uint64, string, bool);
+func	Unreflect(uint64, string, bool) (ret interface { });
 
-export var	Args []string;
-export var	Envs []string;
+var	Args []string;
+var	Envs []string;
 
-export func	Frexp(float64) (float64, int);		// break fp into exp,fract
-export func	Ldexp(float64, int) float64;		// make fp from exp,fract
-export func	Modf(float64) (float64, float64);	// break fp into double.double
-export func	IsInf(float64, int) bool;		// test for infinity
-export func	IsNaN(float64) bool;			// test for not-a-number
-export func	Inf(int) float64;			// return signed Inf
-export func	NaN() float64;				// return a NaN
-export func	Float32bits(float32) uint32;		// raw bits
-export func	Float64bits(float64) uint64;		// raw bits
-export func	Float32frombits(uint32) float32;	// raw bits
-export func	Float64frombits(uint64) float64;	// raw bits
+func	Frexp(float64) (float64, int);		// break fp into exp,fract
+func	Ldexp(float64, int) float64;		// make fp from exp,fract
+func	Modf(float64) (float64, float64);	// break fp into double.double
+func	IsInf(float64, int) bool;		// test for infinity
+func	IsNaN(float64) bool;			// test for not-a-number
+func	Inf(int) float64;			// return signed Inf
+func	NaN() float64;				// return a NaN
+func	Float32bits(float32) uint32;		// raw bits
+func	Float64bits(float64) uint64;		// raw bits
+func	Float32frombits(uint32) float32;	// raw bits
+func	Float64frombits(uint64) float64;	// raw bits
 
-export func	Gosched();
-export func	Goexit();
+func	Gosched();
+func	Goexit();
 
-export func	BytesToRune(*byte, int, int) (int, int);	// convert bytes to runes
-export func	StringToRune(string, int) (int, int);	// convert bytes to runes
+func	BytesToRune(*byte, int, int) (int, int);	// convert bytes to runes
+func	StringToRune(string, int) (int, int);	// convert bytes to runes
 
-export func	Exit(int);
+func	Exit(int);
 
-export func	Caller(n int) (pc uint64, file string, line int, ok bool);
+func	Caller(n int) (pc uint64, file string, line int, ok bool);
 
-export func	SemAcquire(sema *int32);
-export func	SemRelease(sema *int32);
+func	SemAcquire(sema *int32);
+func	SemRelease(sema *int32);
diff --git a/src/lib/bignum.go b/src/lib/bignum.go
index fb66ba02ae..078374ad7e 100755
--- a/src/lib/bignum.go
+++ b/src/lib/bignum.go
@@ -52,7 +52,7 @@ import "fmt"
 //    results are packed again. For faster unpacking/packing, the base size
 //    in bits must be even.
 
-export type (
+type (
 	Digit  uint64;
 	Digit2 uint32;  // half-digits for division
 )
@@ -91,7 +91,7 @@ func isSmall(x Digit) bool {
 }
 
 
-export func Dump(x []Digit) {
+func Dump(x []Digit) {
 	print("[", len(x), "]");
 	for i := len(x) - 1; i >= 0; i-- {
 		print(" ", x[i]);
@@ -111,7 +111,7 @@ export func Dump(x []Digit) {
 // n, m   len(x), len(y)
 
 
-export type Natural []Digit;
+type Natural []Digit;
 
 var (
 	natZero Natural = Natural{};
@@ -123,7 +123,7 @@ var (
 
 // Creation
 
-export func Nat(x uint) Natural {
+func Nat(x uint) Natural {
 	switch x {
 	case 0: return natZero;
 	case 1: return natOne;
@@ -696,7 +696,7 @@ func muladd1(x Natural, d, c Digit) Natural {
 
 // Determines base (octal, decimal, hexadecimal) if base == 0.
 // Returns the number and base.
-export func NatFromString(s string, base uint, slen *int) (Natural, uint) {
+func NatFromString(s string, base uint, slen *int) (Natural, uint) {
 	// determine base if necessary
 	i, n := 0, len(s);
 	if base == 0 {
@@ -766,7 +766,7 @@ func (xp Natural) Pow(n uint) Natural {
 }
 
 
-export func MulRange(a, b uint) Natural {
+func MulRange(a, b uint) Natural {
 	switch {
 	case a > b: return Nat(1);
 	case a == b: return Nat(a);
@@ -778,14 +778,14 @@ export func MulRange(a, b uint) Natural {
 }
 
 
-export func Fact(n uint) Natural {
+func Fact(n uint) Natural {
 	// Using MulRange() instead of the basic for-loop
 	// lead to faster factorial computation.
 	return MulRange(2, n);
 }
 
 
-export func Binomial(n, k uint) Natural {
+func Binomial(n, k uint) Natural {
 	return MulRange(n-k+1, n).Div(MulRange(1, k));
 }
 
@@ -806,7 +806,7 @@ func (xp Natural) Gcd(y Natural) Natural {
 // Integers are normalized if the mantissa is normalized and the sign is
 // false for mant == 0. Use MakeInt to create normalized Integers.
 
-export type Integer struct {
+type Integer struct {
 	sign bool;
 	mant Natural;
 }
@@ -814,7 +814,7 @@ export type Integer struct {
 
 // Creation
 
-export func MakeInt(sign bool, mant Natural) *Integer {
+func MakeInt(sign bool, mant Natural) *Integer {
 	if mant.IsZero() {
 		sign = false;  // normalize
 	}
@@ -822,7 +822,7 @@ export func MakeInt(sign bool, mant Natural) *Integer {
 }
 
 
-export func Int(x int) *Integer {
+func Int(x int) *Integer {
 	sign := false;
 	var ux uint;
 	if x < 0 {
@@ -1103,7 +1103,7 @@ func (x *Integer) Format(h fmt.Formatter, c int) {
 
 // Determines base (octal, decimal, hexadecimal) if base == 0.
 // Returns the number and base.
-export func IntFromString(s string, base uint, slen *int) (*Integer, uint) {
+func IntFromString(s string, base uint, slen *int) (*Integer, uint) {
 	// get sign, if any
 	sign := false;
 	if len(s) > 0 && (s[0] == '-' || s[0] == '+') {
@@ -1126,7 +1126,7 @@ export func IntFromString(s string, base uint, slen *int) (*Integer, uint) {
 // ----------------------------------------------------------------------------
 // Rational numbers
 
-export type Rational struct {
+type Rational struct {
 	a *Integer;  // numerator
 	b Natural;  // denominator
 }
@@ -1134,7 +1134,7 @@ export type Rational struct {
 
 // Creation
 
-export func MakeRat(a *Integer, b Natural) *Rational {
+func MakeRat(a *Integer, b Natural) *Rational {
 	f := a.mant.Gcd(b);  // f > 0
 	if f.Cmp(Nat(1)) != 0 {
 		a = MakeInt(a.sign, a.mant.Div(f));
@@ -1144,7 +1144,7 @@ export func MakeRat(a *Integer, b Natural) *Rational {
 }
 
 
-export func Rat(a0 int, b0 int) *Rational {
+func Rat(a0 int, b0 int) *Rational {
 	a, b := Int(a0), Int(b0);
 	if b.sign {
 		a = a.Neg();
@@ -1233,7 +1233,7 @@ func (x *Rational) Format(h fmt.Formatter, c int) {
 
 // Determines base (octal, decimal, hexadecimal) if base == 0.
 // Returns the number and base of the nominator.
-export func RatFromString(s string, base uint, slen *int) (*Rational, uint) {
+func RatFromString(s string, base uint, slen *int) (*Rational, uint) {
 	// read nominator
 	var alen, blen int;
 	a, abase := IntFromString(s, base, &alen);
diff --git a/src/lib/bignum_test.go b/src/lib/bignum_test.go
index f87cfd50a6..d8d214dd78 100644
--- a/src/lib/bignum_test.go
+++ b/src/lib/bignum_test.go
@@ -90,7 +90,7 @@ func rat_eq(n uint, x, y *bignum.Rational) {
 	}
 }
 
-export func TestNatConv(t *testing.T) {
+func TestNatConv(t *testing.T) {
 	tester = t;
 	test_msg = "NatConvA";
 	nat_eq(0, a, bignum.Nat(991));
@@ -122,7 +122,7 @@ export func TestNatConv(t *testing.T) {
 }
 
 
-export func TestIntConv(t *testing.T) {
+func TestIntConv(t *testing.T) {
 	tester = t;
 	test_msg = "IntConv";
 	var slen int;
@@ -140,7 +140,7 @@ export func TestIntConv(t *testing.T) {
 }
 
 
-export func TestRatConv(t *testing.T) {
+func TestRatConv(t *testing.T) {
 	tester = t;
 	test_msg = "RatConv";
 	var slen int;
@@ -176,7 +176,7 @@ func sum(n uint, scale bignum.Natural) bignum.Natural {
 }
 
 
-export func TestNatAdd(t *testing.T) {
+func TestNatAdd(t *testing.T) {
 	tester = t;
 	test_msg = "NatAddA";
 	nat_eq(0, add(nat_zero, nat_zero), nat_zero);
@@ -206,7 +206,7 @@ func mul(x, y bignum.Natural) bignum.Natural {
 }
 
 
-export func TestNatSub(t *testing.T) {
+func TestNatSub(t *testing.T) {
 	tester = t;
 	test_msg = "NatSubA";
 	nat_eq(0, nat_zero.Sub(nat_zero), nat_zero);
@@ -223,7 +223,7 @@ export func TestNatSub(t *testing.T) {
 }
 
 
-export func TestNatMul(t *testing.T) {
+func TestNatMul(t *testing.T) {
 	tester = t;
 	test_msg = "NatMulA";
 	nat_eq(0, mul(c, nat_zero), nat_zero);
@@ -242,7 +242,7 @@ export func TestNatMul(t *testing.T) {
 }
 
 
-export func TestNatDiv(t *testing.T) {
+func TestNatDiv(t *testing.T) {
 	tester = t;
 	test_msg = "NatDivA";
 	nat_eq(0, c.Div(nat_one), c);
@@ -260,7 +260,7 @@ export func TestNatDiv(t *testing.T) {
 }
 
 
-export func TestIntQuoRem(t *testing.T) {
+func TestIntQuoRem(t *testing.T) {
 	tester = t;
 	test_msg = "IntQuoRem";
 	type T struct { x, y, q, r int };
@@ -287,7 +287,7 @@ export func TestIntQuoRem(t *testing.T) {
 }
 
 
-export func TestIntDivMod(t *testing.T) {
+func TestIntDivMod(t *testing.T) {
 	tester = t;
 	test_msg = "IntDivMod";
 	type T struct { x, y, q, r int };
@@ -314,7 +314,7 @@ export func TestIntDivMod(t *testing.T) {
 }
 
 
-export func TestNatMod(t *testing.T) {
+func TestNatMod(t *testing.T) {
 	tester = t;
 	test_msg = "NatModA";
 	for i := uint(0); ; i++ {
@@ -330,7 +330,7 @@ export func TestNatMod(t *testing.T) {
 }
 
 
-export func TestNatShift(t *testing.T) {
+func TestNatShift(t *testing.T) {
 	tester = t;
 	test_msg = "NatShift1L";
 	test(0, b.Shl(0).Cmp(b) == 0);
@@ -365,7 +365,7 @@ export func TestNatShift(t *testing.T) {
 }
 
 
-export func TestIntShift(t *testing.T) {
+func TestIntShift(t *testing.T) {
 	tester = t;
 	test_msg = "IntShift1L";
 	test(0, ip.Shl(0).Cmp(ip) == 0);
@@ -404,7 +404,7 @@ export func TestIntShift(t *testing.T) {
 }
 
 
-export func TestNatCmp(t *testing.T) {
+func TestNatCmp(t *testing.T) {
 	tester = t;
 	test_msg = "NatCmp";
 	test(0, a.Cmp(a) == 0);
@@ -417,14 +417,14 @@ export func TestNatCmp(t *testing.T) {
 }
 
 
-export func TestNatLog2(t *testing.T) {
+func TestNatLog2(t *testing.T) {
 	tester = t;
 	test_msg = "NatLog2A";
 	test(0, nat_one.Log2() == 0);
 	test(1, nat_two.Log2() == 1);
 	test(2, bignum.Nat(3).Log2() == 1);
 	test(3, bignum.Nat(4).Log2() == 2);
-	
+
 	test_msg = "NatLog2B";
 	for i := uint(0); i < 100; i++ {
 		test(i, nat_one.Shl(i).Log2() == i);
@@ -432,7 +432,7 @@ export func TestNatLog2(t *testing.T) {
 }
 
 
-export func TestNatGcd(t *testing.T) {
+func TestNatGcd(t *testing.T) {
 	tester = t;
 	test_msg = "NatGcdA";
 	f := bignum.Nat(99991);
@@ -440,7 +440,7 @@ export func TestNatGcd(t *testing.T) {
 }
 
 
-export func TestNatPow(t *testing.T) {
+func TestNatPow(t *testing.T) {
 	tester = t;
 	test_msg = "NatPowA";
 	nat_eq(0, nat_two.Pow(0), nat_one);
@@ -452,7 +452,7 @@ export func TestNatPow(t *testing.T) {
 }
 
 
-export func TestNatPop(t *testing.T) {
+func TestNatPop(t *testing.T) {
 	tester = t;
 	test_msg = "NatPopA";
 	test(0, nat_zero.Pop() == 0);
diff --git a/src/lib/bufio.go b/src/lib/bufio.go
index 5a712e3f69..6fed9d06e7 100644
--- a/src/lib/bufio.go
+++ b/src/lib/bufio.go
@@ -21,7 +21,7 @@ const (
 	defaultBufSize = 4096
 )
 
-export var (
+var (
 	EndOfFile = os.NewError("end of file");
 	PhaseError = os.NewError("phase error");
 	BufferFull = os.NewError("buffer full");
@@ -39,14 +39,14 @@ func copySlice(dst []byte, src []byte) {
 
 // Buffered input.
 
-export type BufRead struct {
+type BufRead struct {
 	buf []byte;
 	rd io.Read;
 	r, w int;
 	err *os.Error;
 }
 
-export func NewBufReadSize(rd io.Read, size int) (b *BufRead, err *os.Error) {
+func NewBufReadSize(rd io.Read, size int) (b *BufRead, err *os.Error) {
 	if size <= 0 {
 		return nil, BadBufSize
 	}
@@ -56,7 +56,7 @@ export func NewBufReadSize(rd io.Read, size int) (b *BufRead, err *os.Error) {
 	return b, nil
 }
 
-export func NewBufRead(rd io.Read) (b *BufRead, err *os.Error) {
+func NewBufRead(rd io.Read) (b *BufRead, err *os.Error) {
 	return NewBufReadSize(rd, defaultBufSize);
 }
 
@@ -326,14 +326,14 @@ func (b *BufRead) ReadLineString(delim byte, savedelim bool) (line string, err *
 
 // buffered output
 
-export type BufWrite struct {
+type BufWrite struct {
 	err *os.Error;
 	buf []byte;
 	n int;
 	wr io.Write;
 }
 
-export func NewBufWriteSize(wr io.Write, size int) (b *BufWrite, err *os.Error) {
+func NewBufWriteSize(wr io.Write, size int) (b *BufWrite, err *os.Error) {
 	if size <= 0 {
 		return nil, BadBufSize
 	}
@@ -343,7 +343,7 @@ export func NewBufWriteSize(wr io.Write, size int) (b *BufWrite, err *os.Error)
 	return b, nil
 }
 
-export func NewBufWrite(wr io.Write) (b *BufWrite, err *os.Error) {
+func NewBufWrite(wr io.Write) (b *BufWrite, err *os.Error) {
 	return NewBufWriteSize(wr, defaultBufSize);
 }
 
diff --git a/src/lib/bufio_test.go b/src/lib/bufio_test.go
index 4b09a7c3f1..eead927b41 100644
--- a/src/lib/bufio_test.go
+++ b/src/lib/bufio_test.go
@@ -173,7 +173,7 @@ var bufsizes = []int {
 	23, 32, 46, 64, 93, 128, 1024, 4096
 }
 
-export func TestBufReadSimple(t *testing.T) {
+func TestBufReadSimple(t *testing.T) {
 	b, e := NewBufRead(newByteReader(io.StringBytes("hello world")));
 	if s := readBytes(b); s != "hello world" {
 		t.Errorf("simple hello world test failed: got %q", s);
@@ -185,7 +185,7 @@ export func TestBufReadSimple(t *testing.T) {
 	}
 }
 
-export func TestBufRead(t *testing.T) {
+func TestBufRead(t *testing.T) {
 	var texts [31]string;
 	str := "";
 	all := "";
@@ -278,7 +278,7 @@ type writeMaker struct {
 	name string;
 	fn *()writeBuffer;
 }
-export func TestBufWrite(t *testing.T) {
+func TestBufWrite(t *testing.T) {
 	var data [8192]byte;
 
 	var writers = []writeMaker {
diff --git a/src/lib/container/array/array.go b/src/lib/container/array/array.go
index 241e8d9e97..3d5c53249e 100644
--- a/src/lib/container/array/array.go
+++ b/src/lib/container/array/array.go
@@ -4,11 +4,11 @@
 
 package array
 
-export type Element interface {
+type Element interface {
 }
 
 
-export type Array struct {
+type Array struct {
 	// TODO do not export field
 	a []Element
 }
@@ -35,7 +35,7 @@ func (p *Array) Init(initial_len int) *Array {
 }
 
 
-export func New(len int) *Array {
+func New(len int) *Array {
 	return new(Array).Init(len)
 }
 
@@ -112,7 +112,7 @@ func (p *Array) Pop() Element {
 
 // Partial SortInterface support
 
-export type LessInterface interface {
+type LessInterface interface {
 	Less(y Element) bool
 }
 
diff --git a/src/lib/container/array/array_test.go b/src/lib/container/array/array_test.go
index 2c56ba8f02..6deaf4a6e3 100644
--- a/src/lib/container/array/array_test.go
+++ b/src/lib/container/array/array_test.go
@@ -9,7 +9,7 @@ import "testing"
 import "sort"
 
 
-export func TestInit(t *testing.T) {
+func TestInit(t *testing.T) {
 	var a array.Array;
 	if a.Init(0).Len() != 0 { t.Error("A") }
 	if a.Init(1).Len() != 1 { t.Error("B") }
@@ -17,19 +17,19 @@ export func TestInit(t *testing.T) {
 }
 
 
-export func TestNew(t *testing.T) {
+func TestNew(t *testing.T) {
 	if array.New(0).Len() != 0 { t.Error("A") }
 	if array.New(1).Len() != 1 { t.Error("B") }
 	if array.New(10).Len() != 10 { t.Error("C") }
 }
 
 
-export func Val(i int) int {
+func Val(i int) int {
 	return i*991 - 1234
 }
 
 
-export func TestAccess(t *testing.T) {
+func TestAccess(t *testing.T) {
 	const n = 100;
 	var a array.Array;
 	a.Init(n);
@@ -42,7 +42,7 @@ export func TestAccess(t *testing.T) {
 }
 
 
-export func TestInsertRemoveClear(t *testing.T) {
+func TestInsertRemoveClear(t *testing.T) {
 	const n = 100;
 	a := array.New(0);
 
@@ -81,7 +81,7 @@ export func TestInsertRemoveClear(t *testing.T) {
 
 
 /* currently doesn't compile due to linker bug
-export func TestSorting(t *testing.T) {
+func TestSorting(t *testing.T) {
 	const n = 100;
 	a := array.NewIntArray(n);
 	for i := n-1; i >= 0; i-- {
diff --git a/src/lib/container/array/intarray.go b/src/lib/container/array/intarray.go
index eb7e83907a..7aefa78522 100644
--- a/src/lib/container/array/intarray.go
+++ b/src/lib/container/array/intarray.go
@@ -6,7 +6,7 @@ package array
 
 import "array"
 
-export type IntArray struct {
+type IntArray struct {
 	// TODO do not export field
 	array.Array;
 }
@@ -18,7 +18,7 @@ func (p *IntArray) Init(len int) *IntArray {
 }
 
 
-export func NewIntArray(len int) *IntArray {
+func NewIntArray(len int) *IntArray {
 	return new(IntArray).Init(len)
 }
 
diff --git a/src/lib/flag.go b/src/lib/flag.go
index 90784e7116..94bbbb49e5 100644
--- a/src/lib/flag.go
+++ b/src/lib/flag.go
@@ -218,7 +218,7 @@ type _Value interface {
 }
 
 // -- Flag structure (internal)
-export type Flag struct {
+type Flag struct {
 	name	string;
 	usage	string;
 	value	_Value;
@@ -232,13 +232,13 @@ type allFlags struct {
 
 var flags *allFlags = &allFlags{make(map[string] *Flag), make(map[string] *Flag), 1}
 
-export func PrintDefaults() {
+func PrintDefaults() {
 	for k, f := range flags.formal {
 		print("  -", f.name, "=", f.value.str(), ": ", f.usage, "\n");
 	}
 }
 
-export func Usage() {
+func Usage() {
 	if len(sys.Args) > 0 {
 		print("Usage of ", sys.Args[0], ": \n");
 	} else {
@@ -248,11 +248,11 @@ export func Usage() {
 	sys.Exit(1);
 }
 
-export func NFlag() int {
+func NFlag() int {
 	return len(flags.actual)
 }
 
-export func Arg(i int) string {
+func Arg(i int) string {
 	i += flags.first_arg;
 	if i < 0 || i >= len(sys.Args) {
 		return "";
@@ -260,7 +260,7 @@ export func Arg(i int) string {
 	return sys.Args[i]
 }
 
-export func NArg() int {
+func NArg() int {
 	return len(sys.Args) - flags.first_arg
 }
 
@@ -277,63 +277,63 @@ func add(name string, value _Value, usage string) {
 	flags.formal[name] = f;
 }
 
-export func Bool(name string, value bool, usage string) *bool {
+func Bool(name string, value bool, usage string) *bool {
 	p := new(bool);
 	add(name, newBoolValue(value, p), usage);
 	return p;
 }
 
-export func BoolVar(p *bool, name string, value bool, usage string) {
+func BoolVar(p *bool, name string, value bool, usage string) {
 	add(name, newBoolValue(value, p), usage);
 }
 
-export func Int(name string, value int, usage string) *int {
+func Int(name string, value int, usage string) *int {
 	p := new(int);
 	add(name, newIntValue(value, p), usage);
 	return p;
 }
 
-export func IntVar(p *int, name string, value int, usage string) {
+func IntVar(p *int, name string, value int, usage string) {
 	add(name, newIntValue(value, p), usage);
 }
 
-export func Int64(name string, value int64, usage string) *int64 {
+func Int64(name string, value int64, usage string) *int64 {
 	p := new(int64);
 	add(name, newInt64Value(value, p), usage);
 	return p;
 }
 
-export func Int64Var(p *int64, name string, value int64, usage string) {
+func Int64Var(p *int64, name string, value int64, usage string) {
 	add(name, newInt64Value(value, p), usage);
 }
 
-export func Uint(name string, value uint, usage string) *uint {
+func Uint(name string, value uint, usage string) *uint {
 	p := new(uint);
 	add(name, newUintValue(value, p), usage);
 	return p;
 }
 
-export func UintVar(p *uint, name string, value uint, usage string) {
+func UintVar(p *uint, name string, value uint, usage string) {
 	add(name, newUintValue(value, p), usage);
 }
 
-export func Uint64(name string, value uint64, usage string) *uint64 {
+func Uint64(name string, value uint64, usage string) *uint64 {
 	p := new(uint64);
 	add(name, newUint64Value(value, p), usage);
 	return p;
 }
 
-export func Uint64Var(p *uint64, name string, value uint64, usage string) {
+func Uint64Var(p *uint64, name string, value uint64, usage string) {
 	add(name, newUint64Value(value, p), usage);
 }
 
-export func String(name, value string, usage string) *string {
+func String(name, value string, usage string) *string {
 	p := new(string);
 	add(name, newStringValue(value, p), usage);
 	return p;
 }
 
-export func StringVar(p *string, name, value string, usage string) {
+func StringVar(p *string, name, value string, usage string) {
 	add(name, newStringValue(value, p), usage);
 }
 
@@ -432,7 +432,7 @@ func (f *allFlags) ParseOne(index int) (ok bool, next int)
 	return true, index + 1
 }
 
-export func Parse() {
+func Parse() {
 	for i := 1; i < len(sys.Args); {
 		ok, next := flags.ParseOne(i);
 		if next > 0 {
diff --git a/src/lib/fmt/fmt_test.go b/src/lib/fmt/fmt_test.go
index 98bbcff2dc..881fd1a366 100644
--- a/src/lib/fmt/fmt_test.go
+++ b/src/lib/fmt/fmt_test.go
@@ -11,7 +11,7 @@ import (
 	"testing";
 )
 
-export func TestFmtInterface(t *testing.T) {
+func TestFmtInterface(t *testing.T) {
 	var i1 interface{};
 	i1 = "abc";
 	s := fmt.Sprintf("%s", i1);
@@ -150,7 +150,7 @@ var fmttests = []fmtTest{
 	fmtTest{ "%20g",	sys.NaN(),		"                 NaN" },
 }
 
-export func TestSprintf(t *testing.T) {
+func TestSprintf(t *testing.T) {
 	for i := 0; i < len(fmttests); i++ {
 		tt := fmttests[i];
 		s := fmt.Sprintf(tt.fmt, tt.val);
@@ -204,7 +204,7 @@ var flagtests = []flagTest {
 	flagTest{ "%-1.2abc", "[%-1.2a]bc" },
 }
 
-export func TestFlagParser(t *testing.T) {
+func TestFlagParser(t *testing.T) {
 	var flagprinter flagPrinter;
 	for i := 0; i < len(flagtests); i++ {
 		tt := flagtests[i];
@@ -215,7 +215,7 @@ export func TestFlagParser(t *testing.T) {
 	}
 }
 
-export func TestStructPrinter(t *testing.T) {
+func TestStructPrinter(t *testing.T) {
 	var s struct {
 		a string;
 		b string;
@@ -241,7 +241,7 @@ export func TestStructPrinter(t *testing.T) {
 	}
 }
 
-export func TestArrayPrinter(t *testing.T) {
+func TestArrayPrinter(t *testing.T) {
 	a := []int{1, 2, 3, 4, 5};
 	want := "[1 2 3 4 5]";
 	out := fmt.Sprintf("%v", a);
diff --git a/src/lib/fmt/format.go b/src/lib/fmt/format.go
index ef8477764f..e230ec99cd 100644
--- a/src/lib/fmt/format.go
+++ b/src/lib/fmt/format.go
@@ -33,7 +33,7 @@ func init() {
 	}
 }
 
-export type Fmt struct {
+type Fmt struct {
 	buf string;
 	wid int;
 	wid_present bool;
@@ -68,7 +68,7 @@ func (f *Fmt) init() {
 	f.clearflags();
 }
 
-export func New() *Fmt {
+func New() *Fmt {
 	f := new(Fmt);
 	f.init();
 	return f;
diff --git a/src/lib/fmt/print.go b/src/lib/fmt/print.go
index 0e75697313..a75e0fff25 100644
--- a/src/lib/fmt/print.go
+++ b/src/lib/fmt/print.go
@@ -20,7 +20,7 @@ import (
 // Representation of printer state passed to custom formatters.
 // Provides access to the io.Write interface plus information about
 // the active formatting verb.
-export type Formatter interface {
+type Formatter interface {
 	Write(b []byte) (ret int, err *os.Error);
 	Width()	(wid int, ok bool);
 	Precision()	(prec int, ok bool);
@@ -29,11 +29,11 @@ export type Formatter interface {
 	Flag(int)	bool;
 }
 
-export type Format interface {
+type Format interface {
 	Format(f Formatter, c int);
 }
 
-export type String interface {
+type String interface {
 	String() string
 }
 
@@ -129,7 +129,7 @@ func (p *pp) doprint(v reflect.StructValue, addspace, addnewline bool);
 
 // These routines end in 'f' and take a format string.
 
-export func Fprintf(w io.Write, format string, a ...) (n int, error *os.Error) {
+func Fprintf(w io.Write, format string, a ...) (n int, error *os.Error) {
 	v := reflect.NewValue(a).(reflect.PtrValue).Sub().(reflect.StructValue);
 	p := newPrinter();
 	p.doprintf(format, v);
@@ -137,12 +137,12 @@ export func Fprintf(w io.Write, format string, a ...) (n int, error *os.Error) {
 	return n, error;
 }
 
-export func Printf(format string, v ...) (n int, errno *os.Error) {
+func Printf(format string, v ...) (n int, errno *os.Error) {
 	n, errno = Fprintf(os.Stdout, format, v);
 	return n, errno;
 }
 
-export func Sprintf(format string, a ...) string {
+func Sprintf(format string, a ...) string {
 	v := reflect.NewValue(a).(reflect.PtrValue).Sub().(reflect.StructValue);
 	p := newPrinter();
 	p.doprintf(format, v);
@@ -153,7 +153,7 @@ export func Sprintf(format string, a ...) string {
 // These routines do not take a format string and add spaces only
 // when the operand on neither side is a string.
 
-export func Fprint(w io.Write, a ...) (n int, error *os.Error) {
+func Fprint(w io.Write, a ...) (n int, error *os.Error) {
 	v := reflect.NewValue(a).(reflect.PtrValue).Sub().(reflect.StructValue);
 	p := newPrinter();
 	p.doprint(v, false, false);
@@ -161,12 +161,12 @@ export func Fprint(w io.Write, a ...) (n int, error *os.Error) {
 	return n, error;
 }
 
-export func Print(v ...) (n int, errno *os.Error) {
+func Print(v ...) (n int, errno *os.Error) {
 	n, errno = Fprint(os.Stdout, v);
 	return n, errno;
 }
 
-export func Sprint(a ...) string {
+func Sprint(a ...) string {
 	v := reflect.NewValue(a).(reflect.PtrValue).Sub().(reflect.StructValue);
 	p := newPrinter();
 	p.doprint(v, false, false);
@@ -178,7 +178,7 @@ export func Sprint(a ...) string {
 // always add spaces between operands, and add a newline
 // after the last operand.
 
-export func Fprintln(w io.Write, a ...) (n int, error *os.Error) {
+func Fprintln(w io.Write, a ...) (n int, error *os.Error) {
 	v := reflect.NewValue(a).(reflect.PtrValue).Sub().(reflect.StructValue);
 	p := newPrinter();
 	p.doprint(v, true, true);
@@ -186,12 +186,12 @@ export func Fprintln(w io.Write, a ...) (n int, error *os.Error) {
 	return n, error;
 }
 
-export func Println(v ...) (n int, errno *os.Error) {
+func Println(v ...) (n int, errno *os.Error) {
 	n, errno = Fprintln(os.Stdout, v);
 	return n, errno;
 }
 
-export func Sprintln(a ...) string {
+func Sprintln(a ...) string {
 	v := reflect.NewValue(a).(reflect.PtrValue).Sub().(reflect.StructValue);
 	p := newPrinter();
 	p.doprint(v, true, true);
diff --git a/src/lib/hash/adler32.go b/src/lib/hash/adler32.go
index 22d82bc649..07818992ea 100644
--- a/src/lib/hash/adler32.go
+++ b/src/lib/hash/adler32.go
@@ -14,7 +14,7 @@ package adler32
 
 import "os"
 
-export type Digest struct {
+type Digest struct {
 	a, b uint32;
 	n int;
 }
@@ -24,7 +24,7 @@ const (
 	_MaxIter = 5552;  // max mod-free iterations before would overflow uint32
 )
 
-export func NewDigest() *Digest {
+func NewDigest() *Digest {
 	return &Digest{1, 0, 0};
 }
 
diff --git a/src/lib/hash/adler32_test.go b/src/lib/hash/adler32_test.go
index 92aae5760f..97b918f131 100644
--- a/src/lib/hash/adler32_test.go
+++ b/src/lib/hash/adler32_test.go
@@ -49,7 +49,7 @@ var golden = []_Adler32Test {
 	_Adler32Test{ 0x2e5d1316, "How can you write a big system without C++?  -Paul Glick" },
 }
 
-export func TestGolden(t *testing.T) {
+func TestGolden(t *testing.T) {
 	for i := 0; i < len(golden); i++ {
 		g := golden[i];
 		c := NewDigest();
diff --git a/src/lib/hash/crc32.go b/src/lib/hash/crc32.go
index 63e6b8cd69..7bfca39d3f 100644
--- a/src/lib/hash/crc32.go
+++ b/src/lib/hash/crc32.go
@@ -9,7 +9,7 @@ package crc32
 
 import "os"
 
-export const (
+const (
 	// Far and away the most common CRC-32 polynomial.
 	// Used by ethernet (IEEE 802.3), v.42, fddi, gzip, zip, png, mpeg-2, ...
 	IEEE = 0xedb88320;
@@ -26,9 +26,9 @@ export const (
 )
 
 // TODO(rsc): Change to [256]uint32 once 6g can handle it.
-export type Table []uint32
+type Table []uint32
 
-export func MakeTable(poly uint32) Table {
+func MakeTable(poly uint32) Table {
 	t := make(Table, 256);
 	for i := 0; i < 256; i++ {
 		crc := uint32(i);
@@ -44,18 +44,18 @@ export func MakeTable(poly uint32) Table {
 	return t;
 }
 
-export var IEEETable = MakeTable(IEEE);
+var IEEETable = MakeTable(IEEE);
 
-export type Digest struct {
+type Digest struct {
 	crc uint32;
 	tab Table;
 }
 
-export func NewDigest(tab Table) *Digest {
+func NewDigest(tab Table) *Digest {
 	return &Digest{0, tab};
 }
 
-export func NewIEEEDigest() *Digest {
+func NewIEEEDigest() *Digest {
 	return NewDigest(IEEETable);
 }
 
diff --git a/src/lib/hash/crc32_test.go b/src/lib/hash/crc32_test.go
index a5a206f8b3..a2a37cf4ac 100644
--- a/src/lib/hash/crc32_test.go
+++ b/src/lib/hash/crc32_test.go
@@ -49,7 +49,7 @@ var golden = []_Crc32Test {
 	_Crc32Test{ 0x8e0bb443, "How can you write a big system without C++?  -Paul Glick" },
 }
 
-export func TestGolden(t *testing.T) {
+func TestGolden(t *testing.T) {
 	for i := 0; i < len(golden); i++ {
 		g := golden[i];
 		c := NewIEEEDigest();
diff --git a/src/lib/hash/md5.go b/src/lib/hash/md5.go
index b9a79dec34..98dae6f837 100644
--- a/src/lib/hash/md5.go
+++ b/src/lib/hash/md5.go
@@ -17,14 +17,14 @@ const (
 	_Init3 = 0x10325476;
 )
 
-export type Digest struct {
+type Digest struct {
 	s [4]uint32;
 	x [_Chunk]byte;
 	nx int;
 	len uint64;
 }
 
-export func NewDigest() *Digest {
+func NewDigest() *Digest {
 	d := new(Digest);
 	d.s[0] = _Init0;
 	d.s[1] = _Init1;
diff --git a/src/lib/hash/md5_test.go b/src/lib/hash/md5_test.go
index 377df03752..6410346944 100644
--- a/src/lib/hash/md5_test.go
+++ b/src/lib/hash/md5_test.go
@@ -50,7 +50,7 @@ var golden = []md5Test {
 	md5Test{ "132f7619d33b523b1d9e5bd8e0928355", "How can you write a big system without C++?  -Paul Glick" },
 }
 
-export func TestGolden(t *testing.T) {
+func TestGolden(t *testing.T) {
 	for i := 0; i < len(golden); i++ {
 		g := golden[i];
 		c := NewDigest();
diff --git a/src/lib/hash/sha1.go b/src/lib/hash/sha1.go
index 1cb7668403..dab477cd48 100644
--- a/src/lib/hash/sha1.go
+++ b/src/lib/hash/sha1.go
@@ -18,14 +18,14 @@ const (
 	_Init4 = 0xC3D2E1F0;
 )
 
-export type Digest struct {
+type Digest struct {
 	h [5]uint32;
 	x [_Chunk]byte;
 	nx int;
 	len uint64;
 }
 
-export func NewDigest() *Digest {
+func NewDigest() *Digest {
 	d := new(Digest);
 	d.h[0] = _Init0;
 	d.h[1] = _Init1;
diff --git a/src/lib/hash/sha1_test.go b/src/lib/hash/sha1_test.go
index 21194f3460..2dde3973d9 100644
--- a/src/lib/hash/sha1_test.go
+++ b/src/lib/hash/sha1_test.go
@@ -52,7 +52,7 @@ var golden = []sha1Test {
 	sha1Test{ "6627d6904d71420b0bf3886ab629623538689f45", "How can you write a big system without C++?  -Paul Glick" },
 }
 
-export func TestGolden(t *testing.T) {
+func TestGolden(t *testing.T) {
 	for i := 0; i < len(golden); i++ {
 		g := golden[i];
 		c := NewDigest();
diff --git a/src/lib/http/conn.go b/src/lib/http/conn.go
index 15c0707f3e..909863ef58 100644
--- a/src/lib/http/conn.go
+++ b/src/lib/http/conn.go
@@ -12,7 +12,7 @@ import (
 )
 
 // Active HTTP connection (server side).
-export type Conn struct {
+type Conn struct {
 	rwc io.ReadWriteClose;
 	br *bufio.BufRead;
 	bw *bufio.BufWrite;
@@ -21,7 +21,7 @@ export type Conn struct {
 }
 
 // Create new connection from rwc.
-export func NewConn(rwc io.ReadWriteClose) (c *Conn, err *os.Error) {
+func NewConn(rwc io.ReadWriteClose) (c *Conn, err *os.Error) {
 	c = new(Conn);
 	c.rwc = rwc;
 	if c.br, err = bufio.NewBufRead(rwc); err != nil {
diff --git a/src/lib/http/request.go b/src/lib/http/request.go
index 1335c48b42..ba1a7a694f 100644
--- a/src/lib/http/request.go
+++ b/src/lib/http/request.go
@@ -19,7 +19,7 @@ const (
 	_MaxHeaderLines = 1024;
 )
 
-export var (
+var (
 	LineTooLong = os.NewError("http header line too long");
 	ValueTooLong = os.NewError("http header value too long");
 	HeaderTooLong = os.NewError("http header too long");
@@ -29,7 +29,7 @@ export var (
 )
 
 // HTTP Request
-export type Request struct {
+type Request struct {
 	method string;		// GET, PUT,etc.
 	rawurl string;
 	url *URL;		// URI after GET, PUT etc.
@@ -180,7 +180,7 @@ func parseHTTPVersion(vers string) (int, int, bool) {
 }
 
 // Read and parse a request from b.
-export func ReadRequest(b *bufio.BufRead) (req *Request, err *os.Error) {
+func ReadRequest(b *bufio.BufRead) (req *Request, err *os.Error) {
 	req = new(Request);
 
 	// First line: GET /index.html HTTP/1.0
diff --git a/src/lib/http/server.go b/src/lib/http/server.go
index 20bfef43bb..13648ad58f 100644
--- a/src/lib/http/server.go
+++ b/src/lib/http/server.go
@@ -36,7 +36,7 @@ func serveConnection(fd net.Conn, raddr string, f *(*Conn, *Request)) {
 }
 
 // Web server: already listening on l, call f for each request.
-export func Serve(l net.Listener, f *(*Conn, *Request)) *os.Error {
+func Serve(l net.Listener, f *(*Conn, *Request)) *os.Error {
 	// TODO: Make this unnecessary
 	s, e := os.Getenv("GOMAXPROCS");
 	if n, ok := strconv.Atoi(s); n < 3 {
@@ -54,7 +54,7 @@ export func Serve(l net.Listener, f *(*Conn, *Request)) *os.Error {
 }
 
 // Web server: listen on address, call f for each request.
-export func ListenAndServe(addr string, f *(*Conn, *Request)) *os.Error {
+func ListenAndServe(addr string, f *(*Conn, *Request)) *os.Error {
 	l, e := net.Listen("tcp", addr);
 	if e != nil {
 		return e
diff --git a/src/lib/http/url.go b/src/lib/http/url.go
index 865b7864a2..9c1a94e2b9 100644
--- a/src/lib/http/url.go
+++ b/src/lib/http/url.go
@@ -12,7 +12,7 @@ import (
 	"strings"
 )
 
-export var (
+var (
 	BadURL = os.NewError("bad url syntax")
 )
 
@@ -41,7 +41,7 @@ func unhex(c byte) byte {
 }
 
 // Unescape %xx into hex.
-export func URLUnescape(s string) (string, *os.Error) {
+func URLUnescape(s string) (string, *os.Error) {
 	// Count %, check that they're well-formed.
 	n := 0;
 	for i := 0; i < len(s); {
@@ -76,7 +76,7 @@ export func URLUnescape(s string) (string, *os.Error) {
 	return string(t), nil;
 }
 
-export type URL struct {
+type URL struct {
 	raw string;
 	scheme string;
 	rawpath string;
@@ -127,7 +127,7 @@ func split(s string, c byte, cutc bool) (string, string) {
 }
 
 // Parse rawurl into a URL structure.
-export func ParseURL(rawurl string) (url *URL, err *os.Error) {
+func ParseURL(rawurl string) (url *URL, err *os.Error) {
 	if rawurl == "" {
 		return nil, BadURL
 	}
@@ -172,7 +172,7 @@ export func ParseURL(rawurl string) (url *URL, err *os.Error) {
 }
 
 // A URL reference is a URL with #frag potentially added.  Parse it.
-export func ParseURLReference(rawurlref string) (url *URL, err *os.Error) {
+func ParseURLReference(rawurlref string) (url *URL, err *os.Error) {
 	// Cut off #frag.
 	rawurl, frag := split(rawurlref, '#', true);
 	if url, err = ParseURL(rawurl); err != nil {
diff --git a/src/lib/io/bytebuffer.go b/src/lib/io/bytebuffer.go
index 5faeff9eb7..fa11b37ee0 100644
--- a/src/lib/io/bytebuffer.go
+++ b/src/lib/io/bytebuffer.go
@@ -24,7 +24,7 @@ func bytecopy(dst []byte, doff int, src []byte, soff int, count int) {
 	}
 }
 
-export type ByteBuffer struct {
+type ByteBuffer struct {
 	buf	[]byte;
 	off	int;	// Read from here
 	len	int;	// Write to here
@@ -87,8 +87,7 @@ func (b *ByteBuffer) AllData() []byte {
 	return b.buf[0:b.len]
 }
 
-
-export func NewByteBufferFromArray(buf []byte) *ByteBuffer {
+func NewByteBufferFromArray(buf []byte) *ByteBuffer {
 	b := new(ByteBuffer);
 	b.buf = buf;
 	b.off = 0;
diff --git a/src/lib/io/io.go b/src/lib/io/io.go
index 7c57f842f7..cbacbe095e 100644
--- a/src/lib/io/io.go
+++ b/src/lib/io/io.go
@@ -9,28 +9,28 @@ import (
 	"syscall";
 )
 
-export var ErrEOF = os.NewError("EOF")
+var ErrEOF = os.NewError("EOF")
 
-export type Read interface {
+type Read interface {
 	Read(p []byte) (n int, err *os.Error);
 }
 
-export type Write interface {
+type Write interface {
 	Write(p []byte) (n int, err *os.Error);
 }
 
-export type ReadWrite interface {
+type ReadWrite interface {
 	Read(p []byte) (n int, err *os.Error);
 	Write(p []byte) (n int, err *os.Error);
 }
 
-export type ReadWriteClose interface {
+type ReadWriteClose interface {
 	Read(p []byte) (n int, err *os.Error);
 	Write(p []byte) (n int, err *os.Error);
 	Close() *os.Error;
 }
 
-export func WriteString(w Write, s string) (n int, err *os.Error) {
+func WriteString(w Write, s string) (n int, err *os.Error) {
 	b := make([]byte, len(s)+1);
 	if !syscall.StringToBytes(b, s) {
 		return -1, os.EINVAL
@@ -41,7 +41,7 @@ export func WriteString(w Write, s string) (n int, err *os.Error) {
 }
 
 // Read until buffer is full, EOF, or error
-export func Readn(fd Read, buf []byte) (n int, err *os.Error) {
+func Readn(fd Read, buf []byte) (n int, err *os.Error) {
 	n = 0;
 	for n < len(buf) {
 		nn, e := fd.Read(buf[n:len(buf)]);
@@ -69,7 +69,7 @@ func (fd *_FullRead) Read(p []byte) (n int, err *os.Error) {
 	return n, err
 }
 
-export func Make_FullReader(fd Read) Read {
+func Make_FullReader(fd Read) Read {
 	if fr, ok := fd.(*_FullRead); ok {
 		// already a _FullRead
 		return fd
@@ -79,7 +79,7 @@ export func Make_FullReader(fd Read) Read {
 
 // Copies n bytes (or until EOF is reached) from src to dst.
 // Returns the number of bytes copied and the error, if any.
-export func Copyn(src Read, dst Write, n int64) (written int64, err *os.Error) {
+func Copyn(src Read, dst Write, n int64) (written int64, err *os.Error) {
 	buf := make([]byte, 32*1024);
 	for written < n {
 		l := len(buf);
@@ -115,7 +115,7 @@ export func Copyn(src Read, dst Write, n int64) (written int64, err *os.Error) {
 
 // Copies from src to dst until EOF is reached.
 // Returns the number of bytes copied and the error, if any.
-export func Copy(src Read, dst Write) (written int64, err *os.Error) {
+func Copy(src Read, dst Write) (written int64, err *os.Error) {
 	buf := make([]byte, 32*1024);
 	for {
 		nr, er := src.Read(buf);
@@ -147,7 +147,7 @@ export func Copy(src Read, dst Write) (written int64, err *os.Error) {
 // Convert a string to an array of bytes for easy marshaling.
 // Could fill with syscall.StringToBytes but it adds an unnecessary \000
 // so the length would be wrong.
-export func StringBytes(s string) []byte {
+func StringBytes(s string) []byte {
 	b := make([]byte, len(s));
 	for i := 0; i < len(s); i++ {
 		b[i] = s[i];
diff --git a/src/lib/json/generic.go b/src/lib/json/generic.go
index 5333c83202..b57fcb12e2 100644
--- a/src/lib/json/generic.go
+++ b/src/lib/json/generic.go
@@ -15,7 +15,7 @@ import (
 	"strings";
 )
 
-export const (
+const (
 	StringKind = iota;
 	NumberKind;
 	MapKind;		// JSON term is "Object", but in Go, it's a map
@@ -24,7 +24,7 @@ export const (
 	NullKind;
 )
 
-export type Json interface {
+type Json interface {
 	Kind() int;
 	String() string;
 	Number() float64;
@@ -34,7 +34,7 @@ export type Json interface {
 	Len() int;
 }
 
-export func JsonToString(j Json) string {
+func JsonToString(j Json) string {
 	if j == nil {
 		return "null"
 	}
@@ -45,7 +45,7 @@ export func JsonToString(j Json) string {
 }
 
 type _Null struct { }
-export var Null Json = &_Null{}
+var Null Json = &_Null{}
 func (*_Null) Kind() int { return NullKind }
 func (*_Null) String() string { return "null" }
 func (*_Null) Number() float64 { return 0 }
@@ -128,7 +128,7 @@ func (j *_Map) String() string {
 	return s;
 }
 
-export func Walk(j Json, path string) Json {
+func Walk(j Json, path string) Json {
 	for len(path) > 0 {
 		var elem string;
 		if i := strings.Index(path, "/"); i >= 0 {
@@ -154,7 +154,7 @@ export func Walk(j Json, path string) Json {
 	return j
 }
 
-export func Equal(a, b Json) bool {
+func Equal(a, b Json) bool {
 	switch {
 	case a == nil && b == nil:
 		return true;
@@ -290,7 +290,7 @@ func (b *_JsonBuilder) Key(k string) Builder {
 	return bb
 }
 
-export func StringToJson(s string) (json Json, ok bool, errtok string) {
+func StringToJson(s string) (json Json, ok bool, errtok string) {
 	var errindx int;
 	var j Json;
 	b := new(_JsonBuilder);
diff --git a/src/lib/json/generic_test.go b/src/lib/json/generic_test.go
index 41685b405c..ab3e24fb80 100644
--- a/src/lib/json/generic_test.go
+++ b/src/lib/json/generic_test.go
@@ -24,7 +24,7 @@ var jsontests = []string {
 	`{"a":1}`,
 }
 
-export func TestJson(t *testing.T) {
+func TestJson(t *testing.T) {
 	for i := 0; i < len(jsontests); i++ {
 		val, ok, errtok := StringToJson(jsontests[i]);
 		if !ok {
@@ -39,7 +39,7 @@ export func TestJson(t *testing.T) {
 	}
 }
 
-export func TestJsonMap(t *testing.T) {
+func TestJsonMap(t *testing.T) {
 	values := make(map[string]Json);
 	mapstr := "{";
 	for i := 0; i < len(jsontests); i++ {
diff --git a/src/lib/json/parse.go b/src/lib/json/parse.go
index e712655adc..13d345e5ee 100644
--- a/src/lib/json/parse.go
+++ b/src/lib/json/parse.go
@@ -44,7 +44,7 @@ func _UnHex(p string, r, l int) (v int, ok bool) {
 	return v, true;
 }
 
-export func Unquote(s string) (t string, ok bool) {
+func Unquote(s string) (t string, ok bool) {
 	if len(s) < 2 || s[0] != '"' || s[len(s)-1] != '"' {
 		return
 	}
@@ -117,7 +117,7 @@ export func Unquote(s string) (t string, ok bool) {
 	return string(b[0:w]), true
 }
 
-export func Quote(s string) string {
+func Quote(s string) string {
 	chr := make([]byte, utf8.UTFMax);
 	chr0 := chr[0:1];
 	b := new(io.ByteBuffer);
@@ -272,7 +272,7 @@ func (t *_Lexer) Next() {
 
 type _Value interface {}
 
-export type Builder interface {
+type Builder interface {
 	// Set value
 	Int64(i int64);
 	Uint64(i uint64);
@@ -386,7 +386,7 @@ Switch:
 	return ok;
 }
 
-export func Parse(s string, build Builder) (ok bool, errindx int, errtok string) {
+func Parse(s string, build Builder) (ok bool, errindx int, errtok string) {
 	lex := new(_Lexer);
 	lex.s = s;
 	lex.Next();
diff --git a/src/lib/json/struct.go b/src/lib/json/struct.go
index 97a2ad18a9..167fcbff0f 100644
--- a/src/lib/json/struct.go
+++ b/src/lib/json/struct.go
@@ -202,7 +202,7 @@ func (b *_StructBuilder) Key(k string) Builder {
 	return nobuilder
 }
 
-export func Unmarshal(s string, val interface{}) (ok bool, errtok string) {
+func Unmarshal(s string, val interface{}) (ok bool, errtok string) {
 	var errindx int;
 	var val1 interface{};
 	b := &_StructBuilder{ reflect.NewValue(val) };
diff --git a/src/lib/json/struct_test.go b/src/lib/json/struct_test.go
index d0c15c2978..88d9e9ec4d 100644
--- a/src/lib/json/struct_test.go
+++ b/src/lib/json/struct_test.go
@@ -46,7 +46,7 @@ func _Check(t *testing.T, ok bool, name string, v interface{}) {
 	}
 }
 
-export func TestUnmarshal(t *testing.T) {
+func TestUnmarshal(t *testing.T) {
 	var m _MyStruct;
 	m.f = true;
 	ok, errtok := Unmarshal(_Encoded, &m);
diff --git a/src/lib/malloc.go b/src/lib/malloc.go
index 3d3f420d05..e3896e94f2 100644
--- a/src/lib/malloc.go
+++ b/src/lib/malloc.go
@@ -8,12 +8,12 @@
 
 package malloc
 
-export type Stats struct {
+type Stats struct {
 	Alloc	uint64;
 	Sys	uint64;
 };
 
-export func Alloc(uint64) *byte;
-export func Free(*byte);
-export func GetStats() *Stats;
-export func Lookup(*byte) (*byte, uintptr);
+func Alloc(uint64) *byte;
+func Free(*byte);
+func GetStats() *Stats;
+func Lookup(*byte) (*byte, uintptr);
diff --git a/src/lib/math/all_test.go b/src/lib/math/all_test.go
index fa0cc7c869..c5d5c01c41 100644
--- a/src/lib/math/all_test.go
+++ b/src/lib/math/all_test.go
@@ -175,7 +175,7 @@ func veryclose(a,b float64) bool {
 	return tolerance(a, b, 4e-16);
 }
 
-export func TestAsin(t *testing.T) {
+func TestAsin(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		if f := math.Asin(vf[i]/10); !veryclose(asin[i], f) {
 			t.Errorf("math.Asin(%g) = %g, want %g\n", vf[i]/10, f, asin[i]);
@@ -183,7 +183,7 @@ export func TestAsin(t *testing.T) {
 	}
 }
 
-export func TestAtan(t *testing.T) {
+func TestAtan(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		if f := math.Atan(vf[i]); !veryclose(atan[i], f) {
 			t.Errorf("math.Atan(%g) = %g, want %g\n", vf[i], f, atan[i]);
@@ -191,7 +191,7 @@ export func TestAtan(t *testing.T) {
 	}
 }
 
-export func TestExp(t *testing.T) {
+func TestExp(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		if f := math.Exp(vf[i]); !veryclose(exp[i], f) {
 			t.Errorf("math.Exp(%g) = %g, want %g\n", vf[i], f, exp[i]);
@@ -199,7 +199,7 @@ export func TestExp(t *testing.T) {
 	}
 }
 
-export func TestFloor(t *testing.T) {
+func TestFloor(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		if f := math.Floor(vf[i]); floor[i] != f {
 			t.Errorf("math.Floor(%g) = %g, want %g\n", vf[i], f, floor[i]);
@@ -207,7 +207,7 @@ export func TestFloor(t *testing.T) {
 	}
 }
 
-export func TestLog(t *testing.T) {
+func TestLog(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		a := math.Fabs(vf[i]);
 		if f := math.Log(a); log[i] != f {
@@ -219,7 +219,7 @@ export func TestLog(t *testing.T) {
 	}
 }
 
-export func TestPow(t *testing.T) {
+func TestPow(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		if f := math.Pow(10, vf[i]); !close(pow[i], f) {
 			t.Errorf("math.Pow(10, %.17g) = %.17g, want %.17g\n", vf[i], f, pow[i]);
@@ -227,7 +227,7 @@ export func TestPow(t *testing.T) {
 	}
 }
 
-export func TestSin(t *testing.T) {
+func TestSin(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		if f := math.Sin(vf[i]); !close(sin[i], f) {
 			t.Errorf("math.Sin(%g) = %g, want %g\n", vf[i], f, sin[i]);
@@ -235,7 +235,7 @@ export func TestSin(t *testing.T) {
 	}
 }
 
-export func TestSinh(t *testing.T) {
+func TestSinh(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		if f := math.Sinh(vf[i]); !veryclose(sinh[i], f) {
 			t.Errorf("math.Sinh(%g) = %g, want %g\n", vf[i], f, sinh[i]);
@@ -243,7 +243,7 @@ export func TestSinh(t *testing.T) {
 	}
 }
 
-export func TestSqrt(t *testing.T) {
+func TestSqrt(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		a := math.Fabs(vf[i]);
 		if f := math.Sqrt(a); !veryclose(sqrt[i], f) {
@@ -252,7 +252,7 @@ export func TestSqrt(t *testing.T) {
 	}
 }
 
-export func TestTan(t *testing.T) {
+func TestTan(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		if f := math.Tan(vf[i]); !close(tan[i], f) {
 			t.Errorf("math.Tan(%g) = %g, want %g\n", vf[i], f, tan[i]);
@@ -260,7 +260,7 @@ export func TestTan(t *testing.T) {
 	}
 }
 
-export func TestTanh(t *testing.T) {
+func TestTanh(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		if f := math.Tanh(vf[i]); !veryclose(tanh[i], f) {
 			t.Errorf("math.Tanh(%g) = %g, want %g\n", vf[i], f, tanh[i]);
@@ -268,7 +268,7 @@ export func TestTanh(t *testing.T) {
 	}
 }
 
-export func TestHypot(t *testing.T) {
+func TestHypot(t *testing.T) {
 	for i := 0; i < len(vf); i++ {
 		a := math.Fabs(tanh[i]*math.Sqrt(2));
 		if f := math.Hypot(tanh[i], tanh[i]); !veryclose(a, f) {
diff --git a/src/lib/math/asin.go b/src/lib/math/asin.go
index e866d95c66..d39339ea1c 100644
--- a/src/lib/math/asin.go
+++ b/src/lib/math/asin.go
@@ -13,7 +13,7 @@ import "math"
  * Arctan is called after appropriate range reduction.
  */
 
-export func Asin(arg float64) float64 {
+func Asin(arg float64) float64 {
 	var temp, x float64;
 	var sign bool;
 
@@ -40,7 +40,7 @@ export func Asin(arg float64) float64 {
 	return temp;
 }
 
-export func Acos(arg float64) float64 {
+func Acos(arg float64) float64 {
 	if arg > 1 || arg < -1 {
 		return sys.NaN();
 	}
diff --git a/src/lib/math/atan.go b/src/lib/math/atan.go
index 730d50a510..41c1705e09 100644
--- a/src/lib/math/atan.go
+++ b/src/lib/math/atan.go
@@ -57,7 +57,7 @@ func satan(arg float64) float64 {
  *	atan makes its argument positive and
  *	calls the inner routine satan.
  */
-export func Atan(arg float64) float64 {
+func Atan(arg float64) float64 {
 	if arg > 0 {
 		return satan(arg);
 	}
diff --git a/src/lib/math/atan2.go b/src/lib/math/atan2.go
index f8c00aa247..1dc5d325eb 100644
--- a/src/lib/math/atan2.go
+++ b/src/lib/math/atan2.go
@@ -10,7 +10,7 @@ import "math"
  *	atan2 discovers what quadrant the angle
  *	is in and calls atan.
  */
-export func Atan2(arg1, arg2 float64) float64 {
+func Atan2(arg1, arg2 float64) float64 {
 	if arg1+arg2 == arg1 {
 		if arg1 >= 0 {
 			return Pi/2;
diff --git a/src/lib/math/const.go b/src/lib/math/const.go
index 927d6daf2d..21822f90ad 100644
--- a/src/lib/math/const.go
+++ b/src/lib/math/const.go
@@ -4,7 +4,7 @@
 
 package math
 
-export const (
+const (
 	// Mathematical constants.
 	// Reference: http://www.research.att.com/~njas/sequences/Axxxxxx
 
diff --git a/src/lib/math/exp.go b/src/lib/math/exp.go
index b2697195e7..0d06ff9cbe 100644
--- a/src/lib/math/exp.go
+++ b/src/lib/math/exp.go
@@ -82,7 +82,7 @@ import "math"
 // compiler will convert from decimal to binary accurately enough
 // to produce the hexadecimal values shown.
 
-export func Exp(x float64) float64 {
+func Exp(x float64) float64 {
 	const (
 		Ln2Hi	= 6.93147180369123816490e-01;
 		Ln2Lo	= 1.90821492927058770002e-10;
diff --git a/src/lib/math/fabs.go b/src/lib/math/fabs.go
index 7117db0b71..dec9a7feb7 100644
--- a/src/lib/math/fabs.go
+++ b/src/lib/math/fabs.go
@@ -4,7 +4,7 @@
 
 package math
 
-export func Fabs(arg float64) float64 {
+func Fabs(arg float64) float64 {
 	if arg < 0 {
 		return -arg;
 	}
diff --git a/src/lib/math/floor.go b/src/lib/math/floor.go
index 14b3908415..1cbdded47f 100644
--- a/src/lib/math/floor.go
+++ b/src/lib/math/floor.go
@@ -9,7 +9,7 @@ package math
  * (resp least >=)
  */
 
-export func Floor(arg float64) float64 {
+func Floor(arg float64) float64 {
 	if arg < 0 {
 		d, fract := sys.Modf(-arg);
 		if fract != 0.0 {
@@ -21,6 +21,6 @@ export func Floor(arg float64) float64 {
 	return d;
 }
 
-export func Ceil(arg float64) float64 {
+func Ceil(arg float64) float64 {
 	return -Floor(-arg);
 }
diff --git a/src/lib/math/fmod.go b/src/lib/math/fmod.go
index ae35e719fa..f30ae35631 100644
--- a/src/lib/math/fmod.go
+++ b/src/lib/math/fmod.go
@@ -8,7 +8,7 @@ package math
  *	floating-point mod func without infinity or NaN checking
  */
 
-export func Fmod(x, y float64) float64 {
+func Fmod(x, y float64) float64 {
 	if y == 0 {
 		return x;
 	}
diff --git a/src/lib/math/hypot.go b/src/lib/math/hypot.go
index 6295c124ac..c0ea5a1f79 100644
--- a/src/lib/math/hypot.go
+++ b/src/lib/math/hypot.go
@@ -12,7 +12,7 @@ package math
  *	Vol. 27, Number 6, pp. 577-581, Nov. 1983
  */
 
-export func Hypot(p, q float64) float64 {
+func Hypot(p, q float64) float64 {
 	if p < 0 {
 		p = -p;
 	}
diff --git a/src/lib/math/log.go b/src/lib/math/log.go
index 259ecd2023..76b5231e53 100644
--- a/src/lib/math/log.go
+++ b/src/lib/math/log.go
@@ -70,7 +70,7 @@ import "math"
 // compiler will convert from decimal to binary accurately enough
 // to produce the hexadecimal values shown.
 
-export func Log(x float64) float64 {
+func Log(x float64) float64 {
 	const (
 		Ln2Hi = 6.93147180369123816490e-01;	/* 3fe62e42 fee00000 */
 		Ln2Lo = 1.90821492927058770002e-10;	/* 3dea39ef 35793c76 */
@@ -113,7 +113,7 @@ export func Log(x float64) float64 {
 	return k*Ln2Hi - ((hfsq-(s*(hfsq+R)+k*Ln2Lo)) - f);
 }
 
-export func Log10(arg float64) float64 {
+func Log10(arg float64) float64 {
 	if arg <= 0 {
 		return sys.NaN();
 	}
diff --git a/src/lib/math/pow.go b/src/lib/math/pow.go
index b5c67d88c0..3ab218d5ef 100644
--- a/src/lib/math/pow.go
+++ b/src/lib/math/pow.go
@@ -7,7 +7,7 @@ package math
 import "math"
 
 // x^y: exponentiation
-export func Pow(x, y float64) float64 {
+func Pow(x, y float64) float64 {
 	// TODO: x or y NaN, Inf, maybe 0.
 	switch {
 	case y == 0:
diff --git a/src/lib/math/pow10.go b/src/lib/math/pow10.go
index 1d0a0e0cc2..30e5a6ee55 100644
--- a/src/lib/math/pow10.go
+++ b/src/lib/math/pow10.go
@@ -15,7 +15,7 @@ package math
 
 var	pow10tab	[70]float64;
 
-export func Pow10(e int) float64 {
+func Pow10(e int) float64 {
 	if e < 0 {
 		return 1/Pow10(-e);
 	}
diff --git a/src/lib/math/sin.go b/src/lib/math/sin.go
index b6a074242e..fc8a05d4bf 100644
--- a/src/lib/math/sin.go
+++ b/src/lib/math/sin.go
@@ -52,13 +52,13 @@ func sinus(arg float64, quad int) float64 {
 	return temp1/temp2;
 }
 
-export func Cos(arg float64) float64 {
+func Cos(arg float64) float64 {
 	if arg < 0 {
 		arg = -arg;
 	}
 	return sinus(arg, 1);
 }
 
-export func Sin(arg float64) float64 {
+func Sin(arg float64) float64 {
 	return sinus(arg, 0);
 }
diff --git a/src/lib/math/sinh.go b/src/lib/math/sinh.go
index e0201eef31..e79e8161bc 100644
--- a/src/lib/math/sinh.go
+++ b/src/lib/math/sinh.go
@@ -19,7 +19,7 @@ import "math"
  *	all arguments.
  */
 
-export func Sinh(arg float64) float64 {
+func Sinh(arg float64) float64 {
 	// The coefficients are #2029 from Hart & Cheney. (20.36D)
 	const
 	(
@@ -58,7 +58,7 @@ export func Sinh(arg float64) float64 {
 	return temp;
 }
 
-export func Cosh(arg float64) float64 {
+func Cosh(arg float64) float64 {
 	if arg < 0 {
 		arg = - arg;
 	}
diff --git a/src/lib/math/sqrt.go b/src/lib/math/sqrt.go
index 698639781f..cf256b25c4 100644
--- a/src/lib/math/sqrt.go
+++ b/src/lib/math/sqrt.go
@@ -11,7 +11,7 @@ package math
  *	calls frexp
  */
 
-export func Sqrt(arg float64) float64 {
+func Sqrt(arg float64) float64 {
 	if sys.IsInf(arg, 1) {
 		return arg;
 	}
diff --git a/src/lib/math/tan.go b/src/lib/math/tan.go
index bae194bcbe..4910fa3a4c 100644
--- a/src/lib/math/tan.go
+++ b/src/lib/math/tan.go
@@ -10,7 +10,7 @@ import "math"
  *	floating point tangent
  */
 
-export func Tan(arg float64) float64 {
+func Tan(arg float64) float64 {
 	// Coefficients are #4285 from Hart & Cheney. (19.74D)
 	const
 	(
diff --git a/src/lib/math/tanh.go b/src/lib/math/tanh.go
index 45f7723ee9..2e9d74ee4b 100644
--- a/src/lib/math/tanh.go
+++ b/src/lib/math/tanh.go
@@ -14,7 +14,7 @@ import "math"
  *	would cause overflow improperly.
  */
 
-export func Tanh(arg float64) float64 {
+func Tanh(arg float64) float64 {
 	if arg < 0 {
 		arg = -arg;
 		if arg > 21 {
diff --git a/src/lib/net/dialgoogle_test.go b/src/lib/net/dialgoogle_test.go
index c323e1e303..de7158a7bc 100644
--- a/src/lib/net/dialgoogle_test.go
+++ b/src/lib/net/dialgoogle_test.go
@@ -64,7 +64,7 @@ var googleaddrs = []string {
 	"[2001:4860:0:2001::68]:80"	// ipv6.google.com; removed if ipv6 flag not set
 }
 
-export func TestDialGoogle(t *testing.T) {
+func TestDialGoogle(t *testing.T) {
 	// If no ipv6 tunnel, don't try the last address.
 	if !*ipv6 {
 		googleaddrs[len(googleaddrs)-1] = ""
diff --git a/src/lib/net/dnsclient.go b/src/lib/net/dnsclient.go
index 67af9b7524..5c26d51c57 100644
--- a/src/lib/net/dnsclient.go
+++ b/src/lib/net/dnsclient.go
@@ -25,7 +25,7 @@ import (
 	"strings";
 )
 
-export var (
+var (
 	DNS_InternalError = os.NewError("internal dns error");
 	DNS_MissingConfig = os.NewError("no dns configuration");
 	DNS_No_Answer = os.NewError("dns got no answer");
@@ -171,7 +171,7 @@ func _LoadConfig() {
 	cfg = DNS_ReadConfig();
 }
 
-export func LookupHost(name string) (name1 string, addrs []string, err *os.Error) {
+func LookupHost(name string) (name1 string, addrs []string, err *os.Error) {
 	// TODO(rsc): Pick out obvious non-DNS names to avoid
 	// sending stupid requests to the server?
 
diff --git a/src/lib/net/dnsconfig.go b/src/lib/net/dnsconfig.go
index 3de9e2494d..e57ce59c67 100644
--- a/src/lib/net/dnsconfig.go
+++ b/src/lib/net/dnsconfig.go
@@ -13,7 +13,7 @@ import (
 	"strconv";
 )
 
-export type DNS_Config struct {
+type DNS_Config struct {
 	servers []string;	// servers to use
 	search []string;	// suffixes to append to local name
 	ndots int;		// number of dots in name to trigger absolute lookup
@@ -26,7 +26,7 @@ export type DNS_Config struct {
 // TODO(rsc): Supposed to call uname() and chop the beginning
 // of the host name to get the default search domain.
 // We assume it's in resolv.conf anyway.
-export func DNS_ReadConfig() *DNS_Config {
+func DNS_ReadConfig() *DNS_Config {
 	file := _Open("/etc/resolv.conf");
 	if file == nil {
 		return nil
diff --git a/src/lib/net/dnsmsg.go b/src/lib/net/dnsmsg.go
index 159ea7bb25..2cd8b2ffb3 100644
--- a/src/lib/net/dnsmsg.go
+++ b/src/lib/net/dnsmsg.go
@@ -32,7 +32,7 @@ import (
 // _Packet formats
 
 // Wire constants.
-export const (
+const (
 	// valid DNS_RR_Header.rrtype and DNS_Question.qtype
 	DNS_TypeA = 1;
 	DNS_TypeNS = 2;
@@ -90,7 +90,7 @@ const (
 )
 
 // DNS queries.
-export type DNS_Question struct {
+type DNS_Question struct {
 	name string "domain-name";	// "domain-name" specifies encoding; see packers below
 	qtype uint16;
 	qclass uint16;
@@ -99,7 +99,7 @@ export type DNS_Question struct {
 // DNS responses (resource records).
 // There are many types of messages,
 // but they all share the same header.
-export type DNS_RR_Header struct {
+type DNS_RR_Header struct {
 	name string "domain-name";
 	rrtype uint16;
 	class uint16;
@@ -111,62 +111,62 @@ func (h *DNS_RR_Header) Header() *DNS_RR_Header {
 	return h
 }
 
-export type DNS_RR interface {
+type DNS_RR interface {
 	Header() *DNS_RR_Header
 }
 
 
 // Specific DNS RR formats for each query type.
 
-export type DNS_RR_CNAME struct {
+type DNS_RR_CNAME struct {
 	DNS_RR_Header;
 	cname string "domain-name";
 }
 
-export type DNS_RR_HINFO struct {
+type DNS_RR_HINFO struct {
 	DNS_RR_Header;
 	cpu string;
 	os string;
 }
 
-export type DNS_RR_MB struct {
+type DNS_RR_MB struct {
 	DNS_RR_Header;
 	mb string "domain-name";
 }
 
-export type DNS_RR_MG struct {
+type DNS_RR_MG struct {
 	DNS_RR_Header;
 	mg string "domain-name";
 }
 
-export type DNS_RR_MINFO struct {
+type DNS_RR_MINFO struct {
 	DNS_RR_Header;
 	rmail string "domain-name";
 	email string "domain-name";
 }
 
-export type DNS_RR_MR struct {
+type DNS_RR_MR struct {
 	DNS_RR_Header;
 	mr string "domain-name";
 }
 
-export type DNS_RR_MX struct {
+type DNS_RR_MX struct {
 	DNS_RR_Header;
 	pref uint16;
 	mx string "domain-name";
 }
 
-export type DNS_RR_NS struct {
+type DNS_RR_NS struct {
 	DNS_RR_Header;
 	ns string "domain-name";
 }
 
-export type DNS_RR_PTR struct {
+type DNS_RR_PTR struct {
 	DNS_RR_Header;
 	ptr string "domain-name";
 }
 
-export type DNS_RR_SOA struct {
+type DNS_RR_SOA struct {
 	DNS_RR_Header;
 	ns string "domain-name";
 	mbox string "domain-name";
@@ -177,12 +177,12 @@ export type DNS_RR_SOA struct {
 	minttl uint32;
 }
 
-export type DNS_RR_TXT struct {
+type DNS_RR_TXT struct {
 	DNS_RR_Header;
 	txt string;	// not domain name
 }
 
-export type DNS_RR_A struct {
+type DNS_RR_A struct {
 	DNS_RR_Header;
 	a uint32 "ipv4";
 }
@@ -537,7 +537,7 @@ type _DNS_Msg_Top struct {
 	rcode int;
 }
 
-export type DNS_Msg struct {
+type DNS_Msg struct {
 	_DNS_Msg_Top;
 	question []DNS_Question;
 	answer []DNS_RR;
diff --git a/src/lib/net/fd.go b/src/lib/net/fd.go
index b93f04189e..ce18ccabb2 100644
--- a/src/lib/net/fd.go
+++ b/src/lib/net/fd.go
@@ -15,7 +15,7 @@ import (
 
 // Network file descriptor.  Only intended to be used internally,
 // but have to export to make it available in other files implementing package net.
-export type FD struct {
+type FD struct {
 	// immutable until Close
 	fd int64;
 	osfd *os.FD;
@@ -207,7 +207,7 @@ func _StartServer() {
 	pollserver = p
 }
 
-export func NewFD(fd int64) (f *FD, err *os.Error) {
+func NewFD(fd int64) (f *FD, err *os.Error) {
 	if pollserver == nil {
 		once.Do(&_StartServer);
 	}
diff --git a/src/lib/net/fd_darwin.go b/src/lib/net/fd_darwin.go
index 34fd90f0a4..342f9c9d9e 100644
--- a/src/lib/net/fd_darwin.go
+++ b/src/lib/net/fd_darwin.go
@@ -12,13 +12,13 @@ import (
 	"syscall";
 )
 
-export type Pollster struct {
+type Pollster struct {
 	kq int64;
 	eventbuf [10]syscall.Kevent_t;
 	events []syscall.Kevent_t;
 }
 
-export func NewPollster() (p *Pollster, err *os.Error) {
+func NewPollster() (p *Pollster, err *os.Error) {
 	p = new(Pollster);
 	var e int64;
 	if p.kq, e = syscall.Kqueue(); e != 0 {
diff --git a/src/lib/net/fd_linux.go b/src/lib/net/fd_linux.go
index 5060e99cb6..cef0edabcd 100644
--- a/src/lib/net/fd_linux.go
+++ b/src/lib/net/fd_linux.go
@@ -17,14 +17,14 @@ const (
 	writeFlags = syscall.EPOLLOUT
 )
 
-export type Pollster struct {
+type Pollster struct {
 	epfd int64;
 
 	// Events we're already waiting for
 	events map[int64] uint32;
 }
 
-export func NewPollster() (p *Pollster, err *os.Error) {
+func NewPollster() (p *Pollster, err *os.Error) {
 	p = new(Pollster);
 	var e int64;
 
diff --git a/src/lib/net/ip.go b/src/lib/net/ip.go
index 15d09a3d35..89bbeba94a 100644
--- a/src/lib/net/ip.go
+++ b/src/lib/net/ip.go
@@ -16,7 +16,7 @@ import (
 	"net"
 )
 
-export const (
+const (
 	IPv4len = 4;
 	IPv6len = 16
 )
@@ -37,7 +37,7 @@ func _MakeIPv4(a, b, c, d byte) []byte {
 }
 
 // Well-known IP addresses
-export var IPv4bcast, IPv4allsys, IPv4allrouter, IPv4prefix, IPallbits, IPnoaddr []byte
+var IPv4bcast, IPv4allsys, IPv4allrouter, IPv4prefix, IPallbits, IPnoaddr []byte
 
 func init() {
 	IPv4bcast = _MakeIPv4(0xff, 0xff, 0xff, 0xff);
@@ -63,7 +63,7 @@ func _IsZeros(p []byte) bool {
 
 // Is p an IPv4 address (perhaps in IPv6 form)?
 // If so, return the 4-byte V4 array.
-export func ToIPv4(p []byte) []byte {
+func ToIPv4(p []byte) []byte {
 	if len(p) == IPv4len {
 		return p
 	}
@@ -77,7 +77,7 @@ export func ToIPv4(p []byte) []byte {
 }
 
 // Convert p to IPv6 form.
-export func ToIPv6(p []byte) []byte {
+func ToIPv6(p []byte) []byte {
 	if len(p) == IPv4len {
 		return _MakeIPv4(p[0], p[1], p[2], p[3])
 	}
@@ -88,13 +88,13 @@ export func ToIPv6(p []byte) []byte {
 }
 
 // Default route masks for IPv4.
-export var (
+var (
 	ClassAMask = _MakeIPv4(0xff, 0, 0, 0);
 	ClassBMask = _MakeIPv4(0xff, 0xff, 0, 0);
 	ClassCMask = _MakeIPv4(0xff, 0xff, 0xff, 0);
 )
 
-export func DefaultMask(p []byte) []byte {
+func DefaultMask(p []byte) []byte {
 	if p = ToIPv4(p); p == nil {
 		return nil
 	}
@@ -110,7 +110,7 @@ export func DefaultMask(p []byte) []byte {
 }
 
 // Apply mask to ip, returning new address.
-export func Mask(ip []byte, mask []byte) []byte {
+func Mask(ip []byte, mask []byte) []byte {
 	n := len(ip);
 	if n != len(mask) {
 		return nil
@@ -159,7 +159,7 @@ func itox(i uint) string {
 }
 
 // Convert IP address to string.
-export func IPToString(p []byte) string {
+func IPToString(p []byte) string {
 	// If IPv4, use dotted notation.
 	if p4 := ToIPv4(p); len(p4) == 4 {
 		return itod(uint(p4[0]))+"."
@@ -228,7 +228,7 @@ func _SimpleMaskLength(mask []byte) int {
 	return n
 }
 
-export func MaskToString(mask []byte) string {
+func MaskToString(mask []byte) string {
 	switch len(mask) {
 	case 4:
 		n := _SimpleMaskLength(mask);
@@ -377,7 +377,7 @@ L:	for j < IPv6len {
 	return p
 }
 
-export func ParseIP(s string) []byte {
+func ParseIP(s string) []byte {
 	p := _ParseIPv4(s);
 	if p != nil {
 		return p
diff --git a/src/lib/net/ip_test.go b/src/lib/net/ip_test.go
index a6b6c6f2d5..9788db2435 100644
--- a/src/lib/net/ip_test.go
+++ b/src/lib/net/ip_test.go
@@ -43,7 +43,7 @@ var parseiptests = []parseIPTest {
 	parseIPTest{"::ffff:4a7d:1363", _IPv4(74, 125, 19, 99)},
 }
 
-export func TestParseIP(t *testing.T) {
+func TestParseIP(t *testing.T) {
 	for i := 0; i < len(parseiptests); i++ {
 		tt := parseiptests[i];
 		if out := ParseIP(tt.in); !isEqual(out, tt.out) {
diff --git a/src/lib/net/net.go b/src/lib/net/net.go
index 240d5dc585..44172047b6 100644
--- a/src/lib/net/net.go
+++ b/src/lib/net/net.go
@@ -11,7 +11,7 @@ import (
 	"syscall";
 )
 
-export var (
+var (
 	BadAddress = os.NewError("malformed address");
 	MissingAddress = os.NewError("missing address");
 	UnknownNetwork = os.NewError("unknown network");
@@ -21,7 +21,7 @@ export var (
 	Unknown_SocketFamily = os.NewError("unknown socket family");
 )
 
-export func LookupHost(name string) (name1 string, addrs []string, err *os.Error)
+func LookupHost(name string) (name1 string, addrs []string, err *os.Error)
 
 // Split "host:port" into "host" and "port".
 // Host cannot contain colons unless it is bracketed.
@@ -358,7 +358,7 @@ func _InternetSocket(net, laddr, raddr string, proto int64, mode string) (fd *FD
 
 // TCP connections.
 
-export type ConnTCP struct {
+type ConnTCP struct {
 	_ConnBase
 }
 
@@ -377,7 +377,7 @@ func _NewConnTCP(fd *FD, raddr string) *ConnTCP {
 	return c
 }
 
-export func DialTCP(net, laddr, raddr string) (c *ConnTCP, err *os.Error) {
+func DialTCP(net, laddr, raddr string) (c *ConnTCP, err *os.Error) {
 	if raddr == "" {
 		return nil, MissingAddress
 	}
@@ -393,7 +393,7 @@ export func DialTCP(net, laddr, raddr string) (c *ConnTCP, err *os.Error) {
 
 // TODO(rsc): UDP headers mode
 
-export type ConnUDP struct {
+type ConnUDP struct {
 	_ConnBase
 }
 
@@ -404,7 +404,7 @@ func _NewConnUDP(fd *FD, raddr string) *ConnUDP {
 	return c
 }
 
-export func DialUDP(net, laddr, raddr string) (c *ConnUDP, err *os.Error) {
+func DialUDP(net, laddr, raddr string) (c *ConnUDP, err *os.Error) {
 	if raddr == "" {
 		return nil, MissingAddress
 	}
@@ -422,7 +422,7 @@ export func DialUDP(net, laddr, raddr string) (c *ConnUDP, err *os.Error) {
 // TODO: raw ethernet connections
 
 
-export type Conn interface {
+type Conn interface {
 	Read(b []byte) (n int, err *os.Error);
 	Write(b []byte) (n int, err *os.Error);
 	ReadFrom(b []byte) (n int, addr string, err *os.Error);
@@ -450,7 +450,7 @@ export type Conn interface {
 // Eventually, we plan to allow names in addition to IP addresses,
 // but that requires writing a DNS library.
 
-export func Dial(net, laddr, raddr string) (c Conn, err *os.Error) {
+func Dial(net, laddr, raddr string) (c Conn, err *os.Error) {
 	switch net {
 	case "tcp", "tcp4", "tcp6":
 		c, err := DialTCP(net, laddr, raddr);
@@ -477,17 +477,17 @@ export func Dial(net, laddr, raddr string) (c Conn, err *os.Error) {
 }
 
 
-export type Listener interface {
+type Listener interface {
 	Accept() (c Conn, raddr string, err *os.Error);
 	Close() *os.Error;
 }
 
-export type ListenerTCP struct {
+type ListenerTCP struct {
 	fd *FD;
 	laddr string
 }
 
-export func ListenTCP(net, laddr string) (l *ListenerTCP, err *os.Error) {
+func ListenTCP(net, laddr string) (l *ListenerTCP, err *os.Error) {
 	fd, e := _InternetSocket(net, laddr, "", syscall.SOCK_STREAM, "listen");
 	if e != nil {
 		return nil, e
@@ -534,7 +534,7 @@ func (l *ListenerTCP) Close() *os.Error {
 	return l.fd.Close()
 }
 
-export func Listen(net, laddr string) (l Listener, err *os.Error) {
+func Listen(net, laddr string) (l Listener, err *os.Error) {
 	switch net {
 	case "tcp", "tcp4", "tcp6":
 		l, err := ListenTCP(net, laddr);
diff --git a/src/lib/net/net_darwin.go b/src/lib/net/net_darwin.go
index 062f5ea79b..2d5d11ee9d 100644
--- a/src/lib/net/net_darwin.go
+++ b/src/lib/net/net_darwin.go
@@ -11,7 +11,7 @@ import (
 	"unsafe";
 )
 
-export func IPv4ToSockaddr(p []byte, port int) (sa1 *syscall.Sockaddr, err *os.Error) {
+func IPv4ToSockaddr(p []byte, port int) (sa1 *syscall.Sockaddr, err *os.Error) {
 	p = ToIPv4(p);
 	if p == nil || port < 0 || port > 0xFFFF {
 		return nil, os.EINVAL
@@ -24,10 +24,10 @@ export func IPv4ToSockaddr(p []byte, port int) (sa1 *syscall.Sockaddr, err *os.E
 	for i := 0; i < IPv4len; i++ {
 		sa.Addr[i] = p[i]
 	}
-	return unsafe.pointer(sa).(*syscall.Sockaddr), nil
+	return unsafe.Pointer(sa).(*syscall.Sockaddr), nil
 }
 
-export func IPv6ToSockaddr(p []byte, port int) (sa1 *syscall.Sockaddr, err *os.Error) {
+func IPv6ToSockaddr(p []byte, port int) (sa1 *syscall.Sockaddr, err *os.Error) {
 	p = ToIPv6(p);
 	if p == nil || port < 0 || port > 0xFFFF {
 		return nil, os.EINVAL
@@ -40,21 +40,21 @@ export func IPv6ToSockaddr(p []byte, port int) (sa1 *syscall.Sockaddr, err *os.E
 	for i := 0; i < IPv6len; i++ {
 		sa.Addr[i] = p[i]
 	}
-	return unsafe.pointer(sa).(*syscall.Sockaddr), nil
+	return unsafe.Pointer(sa).(*syscall.Sockaddr), nil
 }
 
 
-export func SockaddrToIP(sa1 *syscall.Sockaddr) (p []byte, port int, err *os.Error) {
+func SockaddrToIP(sa1 *syscall.Sockaddr) (p []byte, port int, err *os.Error) {
 	switch sa1.Family {
 	case syscall.AF_INET:
-		sa := unsafe.pointer(sa1).(*syscall.SockaddrInet4);
+		sa := unsafe.Pointer(sa1).(*syscall.SockaddrInet4);
 		a := ToIPv6(sa.Addr);
 		if a == nil {
 			return nil, 0, os.EINVAL
 		}
 		return a, int(sa.Port[0])<<8 + int(sa.Port[1]), nil;
 	case syscall.AF_INET6:
-		sa := unsafe.pointer(sa1).(*syscall.SockaddrInet6);
+		sa := unsafe.Pointer(sa1).(*syscall.SockaddrInet6);
 		a := ToIPv6(sa.Addr);
 		if a == nil {
 			return nil, 0, os.EINVAL
@@ -66,7 +66,7 @@ export func SockaddrToIP(sa1 *syscall.Sockaddr) (p []byte, port int, err *os.Err
 	return nil, 0, nil	// not reached
 }
 
-export func ListenBacklog() int64 {
+func ListenBacklog() int64 {
 	return syscall.SOMAXCONN
 }
 
diff --git a/src/lib/net/net_linux.go b/src/lib/net/net_linux.go
index c384711b15..7538f62bdc 100644
--- a/src/lib/net/net_linux.go
+++ b/src/lib/net/net_linux.go
@@ -11,7 +11,7 @@ import (
 	"unsafe";
 )
 
-export func IPv4ToSockaddr(p []byte, port int) (sa1 *syscall.Sockaddr, err *os.Error) {
+func IPv4ToSockaddr(p []byte, port int) (sa1 *syscall.Sockaddr, err *os.Error) {
 	p = ToIPv4(p);
 	if p == nil || port < 0 || port > 0xFFFF {
 		return nil, os.EINVAL
@@ -23,12 +23,12 @@ export func IPv4ToSockaddr(p []byte, port int) (sa1 *syscall.Sockaddr, err *os.E
 	for i := 0; i < IPv4len; i++ {
 		sa.Addr[i] = p[i]
 	}
-	return unsafe.pointer(sa).(*syscall.Sockaddr), nil
+	return unsafe.Pointer(sa).(*syscall.Sockaddr), nil
 }
 
 var _IPv6zero [16]byte;
 
-export func IPv6ToSockaddr(p []byte, port int) (sa1 *syscall.Sockaddr, err *os.Error) {
+func IPv6ToSockaddr(p []byte, port int) (sa1 *syscall.Sockaddr, err *os.Error) {
 	p = ToIPv6(p);
 	if p == nil || port < 0 || port > 0xFFFF {
 		return nil, os.EINVAL
@@ -48,20 +48,20 @@ export func IPv6ToSockaddr(p []byte, port int) (sa1 *syscall.Sockaddr, err *os.E
 	for i := 0; i < IPv6len; i++ {
 		sa.Addr[i] = p[i]
 	}
-	return unsafe.pointer(sa).(*syscall.Sockaddr), nil
+	return unsafe.Pointer(sa).(*syscall.Sockaddr), nil
 }
 
-export func SockaddrToIP(sa1 *syscall.Sockaddr) (p []byte, port int, err *os.Error) {
+func SockaddrToIP(sa1 *syscall.Sockaddr) (p []byte, port int, err *os.Error) {
 	switch sa1.Family {
 	case syscall.AF_INET:
-		sa := unsafe.pointer(sa1).(*syscall.SockaddrInet4);
+		sa := unsafe.Pointer(sa1).(*syscall.SockaddrInet4);
 		a := ToIPv6(sa.Addr);
 		if a == nil {
 			return nil, 0, os.EINVAL
 		}
 		return a, int(sa.Port[0])<<8 + int(sa.Port[1]), nil;
 	case syscall.AF_INET6:
-		sa := unsafe.pointer(sa1).(*syscall.SockaddrInet6);
+		sa := unsafe.Pointer(sa1).(*syscall.SockaddrInet6);
 		a := ToIPv6(sa.Addr);
 		if a == nil {
 			return nil, 0, os.EINVAL
@@ -73,7 +73,7 @@ export func SockaddrToIP(sa1 *syscall.Sockaddr) (p []byte, port int, err *os.Err
 	return nil, 0, nil	// not reached
 }
 
-export func ListenBacklog() int64 {
+func ListenBacklog() int64 {
 	// TODO: Read the limit from /proc/sys/net/core/somaxconn,
 	// to take advantage of kernels that have raised the limit.
 	return syscall.SOMAXCONN
diff --git a/src/lib/net/parse_test.go b/src/lib/net/parse_test.go
index 874982617d..633a45718d 100644
--- a/src/lib/net/parse_test.go
+++ b/src/lib/net/parse_test.go
@@ -11,7 +11,7 @@ import (
 	"testing";
 )
 
-export func TestReadLine(t *testing.T) {
+func TestReadLine(t *testing.T) {
 	filename := "/etc/services";	// a nice big file
 
 	fd, err := os.Open(filename, os.O_RDONLY, 0);
diff --git a/src/lib/net/port.go b/src/lib/net/port.go
index d8ac8c7e31..03c0ccee2c 100644
--- a/src/lib/net/port.go
+++ b/src/lib/net/port.go
@@ -48,7 +48,7 @@ func _ReadServices() {
 	file.Close();
 }
 
-export func LookupPort(netw, name string) (port int, ok bool) {
+func LookupPort(netw, name string) (port int, ok bool) {
 	once.Do(&_ReadServices);
 
 	switch netw {
diff --git a/src/lib/net/port_test.go b/src/lib/net/port_test.go
index 0bfff496db..f6123fd8d5 100644
--- a/src/lib/net/port_test.go
+++ b/src/lib/net/port_test.go
@@ -48,7 +48,7 @@ var porttests = []portTest {
 	portTest{ "tcp", "--badport--", 0, false },
 }
 
-export func TestLookupPort(t *testing.T) {
+func TestLookupPort(t *testing.T) {
 	for i := 0; i < len(porttests); i++ {
 		tt := porttests[i];
 		if port, ok := LookupPort(tt.netw, tt.name); port != tt.port || ok != tt.ok {
diff --git a/src/lib/net/tcpserver_test.go b/src/lib/net/tcpserver_test.go
index 400374732b..820220b033 100644
--- a/src/lib/net/tcpserver_test.go
+++ b/src/lib/net/tcpserver_test.go
@@ -75,7 +75,7 @@ func doTest(t *testing.T, network, listenaddr, dialaddr string) {
 	<-done;	// make sure server stopped
 }
 
-export func TestTcpServer(t *testing.T) {
+func TestTcpServer(t *testing.T) {
 	doTest(t,  "tcp", "0.0.0.0:9997", "127.0.0.1:9997");
 	doTest(t, "tcp", "[::]:9997", "[::ffff:127.0.0.1]:9997");
 	doTest(t, "tcp", "[::]:9997", "127.0.0.1:9997");
diff --git a/src/lib/once.go b/src/lib/once.go
index 901fa4872a..6019df5154 100644
--- a/src/lib/once.go
+++ b/src/lib/once.go
@@ -42,7 +42,7 @@ func server() {
 	}
 }
 
-export func Do(f *()) {
+func Do(f *()) {
 	// Look for job in map (avoids channel communication).
 	// If not there, ask map server to make one.
 	// TODO: Uncomment use of jobmap[f] once
diff --git a/src/lib/once_test.go b/src/lib/once_test.go
index 865c661da6..a19d34dcac 100644
--- a/src/lib/once_test.go
+++ b/src/lib/once_test.go
@@ -14,7 +14,7 @@ func call() {
 	ncall++
 }
 
-export func TestOnce(t *testing.T) {
+func TestOnce(t *testing.T) {
 	ncall = 0;
 	once.Do(&call);
 	if ncall != 1 {
diff --git a/src/lib/os/os_env.go b/src/lib/os/os_env.go
index 26cb11a476..dd4970dead 100644
--- a/src/lib/os/os_env.go
+++ b/src/lib/os/os_env.go
@@ -9,11 +9,11 @@ package os
 
 import os "os"
 
-export var (
+var (
 	ENOENV = NewError("no such environment variable");
 )
 
-export func Getenv(s string) (v string, err *Error) {
+func Getenv(s string) (v string, err *Error) {
 	n := len(s);
 	if n == 0 {
 		return "", EINVAL
diff --git a/src/lib/os/os_error.go b/src/lib/os/os_error.go
index f01b95db93..63b2dbccac 100644
--- a/src/lib/os/os_error.go
+++ b/src/lib/os/os_error.go
@@ -8,7 +8,7 @@ import syscall "syscall"
 
 // Errors are singleton structures. Use the String() method to get their contents --
 // it handles the nil (no error) case.
-export type Error struct {
+type Error struct {
 	s string
 }
 
@@ -25,7 +25,7 @@ var errorStringTab = make(map[string] *Error);
 // errors simultaneously but the consequences are unimportant.
 
 // Allocate an Error object, but if it's been seen before, share that one.
-export func NewError(s string) *Error {
+func NewError(s string) *Error {
 	if s == "" {
 		return nil
 	}
@@ -39,7 +39,7 @@ export func NewError(s string) *Error {
 }
 
 // Allocate an Error objecct, but if it's been seen before, share that one.
-export func ErrnoToError(errno int64) *Error {
+func ErrnoToError(errno int64) *Error {
 	if errno == 0 {
 		return nil
 	}
@@ -53,7 +53,7 @@ export func ErrnoToError(errno int64) *Error {
 	return err;
 }
 
-export var (
+var (
 	ENONE = ErrnoToError(syscall.ENONE);
 	EPERM = ErrnoToError(syscall.EPERM);
 	ENOENT = ErrnoToError(syscall.ENOENT);
diff --git a/src/lib/os/os_file.go b/src/lib/os/os_file.go
index f875d64d42..71fbbec9cf 100644
--- a/src/lib/os/os_file.go
+++ b/src/lib/os/os_file.go
@@ -8,24 +8,24 @@ import syscall "syscall"
 import os "os"
 
 // FDs are wrappers for file descriptors
-export type FD struct {
+type FD struct {
 	fd int64
 }
 
-export func NewFD(fd int64) *FD {
+func NewFD(fd int64) *FD {
 	if fd < 0 {
 		return nil
 	}
 	return &FD{fd}
 }
 
-export var (
+var (
 	Stdin = NewFD(0);
 	Stdout = NewFD(1);
 	Stderr = NewFD(2);
 )
 
-export const (
+const (
 	O_RDONLY = syscall.O_RDONLY;
 	O_WRONLY = syscall.O_WRONLY;
 	O_RDWR = syscall.O_RDWR;
@@ -39,7 +39,7 @@ export const (
 	O_TRUNC = syscall.O_TRUNC;
 )
 
-export func Open(name string, mode int, flags int) (fd *FD, err *Error) {
+func Open(name string, mode int, flags int) (fd *FD, err *Error) {
 	r, e := syscall.Open(name, int64(mode), int64(flags));
 	return NewFD(r), ErrnoToError(e)
 }
@@ -96,7 +96,7 @@ func (fd *FD) WriteString(s string) (ret int, err *Error) {
 	return int(r), ErrnoToError(e)
 }
 
-export func Pipe() (fd1 *FD, fd2 *FD, err *Error) {
+func Pipe() (fd1 *FD, fd2 *FD, err *Error) {
 	var p [2]int64;
 	r, e := syscall.Pipe(&p);
 	if e != 0 {
@@ -105,7 +105,7 @@ export func Pipe() (fd1 *FD, fd2 *FD, err *Error) {
 	return NewFD(p[0]), NewFD(p[1]), nil
 }
 
-export func Mkdir(name string, perm int) *Error {
+func Mkdir(name string, perm int) *Error {
 	r, e := syscall.Mkdir(name, int64(perm));
 	return ErrnoToError(e)
 }
diff --git a/src/lib/os/os_time.go b/src/lib/os/os_time.go
index b5cc643368..0f5fdfda81 100644
--- a/src/lib/os/os_time.go
+++ b/src/lib/os/os_time.go
@@ -9,7 +9,7 @@ import (
 	"syscall"
 )
 
-export func Time() (sec int64, nsec int64, err *Error) {
+func Time() (sec int64, nsec int64, err *Error) {
 	var errno int64;
 	sec, nsec, errno = syscall.Gettimeofday();
 	if errno != 0 {
diff --git a/src/lib/rand.go b/src/lib/rand.go
index 68f53c5e2b..a22d325938 100644
--- a/src/lib/rand.go
+++ b/src/lib/rand.go
@@ -44,7 +44,7 @@ func seedrand(x int32) int32 {
 	return x;
 }
 
-export func Seed(seed int32) {
+func Seed(seed int32) {
 	rng_tap = 0;
 	rng_feed = _LEN-_TAP;
 
@@ -72,7 +72,7 @@ export func Seed(seed int32) {
 	}
 }
 
-export func Int63() int64 {
+func Int63() int64 {
 	rng_tap--;
 	if rng_tap < 0 {
 		rng_tap += _LEN;
@@ -88,20 +88,20 @@ export func Int63() int64 {
 	return x;
 }
 
-export func Uint32() uint32 {
+func Uint32() uint32 {
 	return uint32(Int63() >> 31);
 }
 
-export func Int31() int32 {
+func Int31() int32 {
 	return int32(Int63() >> 32);
 }
 
-export func Int() int {
+func Int() int {
 	u := uint(Int63());
 	return int(u << 1 >> 1);	// clear sign bit if int == int32
 }
 
-export func Int63n(n int64) int64 {
+func Int63n(n int64) int64 {
 	if n <= 0 {
 		return 0
 	}
@@ -113,15 +113,15 @@ export func Int63n(n int64) int64 {
 	return v % n
 }
 
-export func Int31n(n int32) int32 {
+func Int31n(n int32) int32 {
 	return int32(Int63n(int64(n)))
 }
 
-export func Intn(n int) int {
+func Intn(n int) int {
 	return int(Int63n(int64(n)))
 }
 
-export func Float64() float64 {
+func Float64() float64 {
 	x := float64(Int63()) / float64(_MASK);
 	for x >= 1 {
 		x = float64(Int63()) / float64(_MASK);
@@ -129,16 +129,16 @@ export func Float64() float64 {
 	return x;
 }
 
-export func Float32() float32 {
+func Float32() float32 {
 	return float32(Float64())
 }
 
-export func Float() float
+func Float() float
 {
 	return float(Float64())
 }
 
-export func Perm(n int) []int {
+func Perm(n int) []int {
 	m := make([]int, n);
 	for i:=0; i<n; i++ {
 		m[i] = i;
diff --git a/src/lib/reflect/all_test.go b/src/lib/reflect/all_test.go
index 4ad8abd74e..631a5662c4 100644
--- a/src/lib/reflect/all_test.go
+++ b/src/lib/reflect/all_test.go
@@ -87,9 +87,9 @@ func valuedump(s, t string) {
 	assert(reflect.ValueToString(v), t);
 }
 
-export type T struct { a int; b float64; c string; d *int }
+type T struct { a int; b float64; c string; d *int }
 
-export func TestAll(tt *testing.T) {	// TODO(r): wrap up better
+func TestAll(tt *testing.T) {	// TODO(r): wrap up better
 	var s string;
 	var t reflect.Type;
 
@@ -285,7 +285,7 @@ export func TestAll(tt *testing.T) {	// TODO(r): wrap up better
 	}
 }
 
-export func TestInterfaceGet(t *testing.T) {
+func TestInterfaceGet(t *testing.T) {
 	var inter struct { e interface{ } };
 	inter.e = 123.456;
 	v1 := reflect.NewValue(&inter);
@@ -296,7 +296,7 @@ export func TestInterfaceGet(t *testing.T) {
 	assert(v3.Type().String(), "float");
 }
 
-export func TestCopyArray(t *testing.T) {
+func TestCopyArray(t *testing.T) {
 	a := []int{ 1, 2, 3, 4, 10, 9, 8, 7 };
 	b := []int{ 11, 22, 33, 44, 1010, 99, 88, 77, 66, 55, 44 };
 	c := []int{ 11, 22, 33, 44, 1010, 99, 88, 77, 66, 55, 44 };
@@ -331,7 +331,7 @@ export func TestCopyArray(t *testing.T) {
 	}
 }
 
-export func TestBigUnnamedStruct(t *testing.T) {
+func TestBigUnnamedStruct(t *testing.T) {
 	b := struct{a,b,c,d int64}{1, 2, 3, 4};
 	v := NewValue(b);
 	b1 := v.Interface().(struct{a,b,c,d int64});
@@ -343,7 +343,7 @@ export func TestBigUnnamedStruct(t *testing.T) {
 type big struct {
 	a, b, c, d, e int64
 }
-export func TestBigStruct(t *testing.T) {
+func TestBigStruct(t *testing.T) {
 	b := big{1, 2, 3, 4, 5};
 	v := NewValue(b);
 	b1 := v.Interface().(big);
diff --git a/src/lib/reflect/tostring.go b/src/lib/reflect/tostring.go
index d451e552fe..38d9d9135f 100644
--- a/src/lib/reflect/tostring.go
+++ b/src/lib/reflect/tostring.go
@@ -12,8 +12,8 @@ import (
 	"strconv";
 )
 
-export func TypeToString(typ Type, expand bool) string
-export func ValueToString(val Value) string
+func TypeToString(typ Type, expand bool) string
+func ValueToString(val Value) string
 
 func doubleQuote(s string) string {
 	out := "\"";
@@ -62,7 +62,7 @@ func typeFieldsToString(t hasFields, sep string) string {
 	return str;
 }
 
-export func TypeToString(typ Type, expand bool) string {
+func TypeToString(typ Type, expand bool) string {
 	var str string;
 	if name := typ.Name(); !expand && name != "" {
 		return name
@@ -126,7 +126,7 @@ func integer(v int64) string {
 	return strconv.Itoa64(v);
 }
 
-export func ValueToString(val Value) string {
+func ValueToString(val Value) string {
 	var str string;
 	typ := val.Type();
 	switch(val.Kind()) {
diff --git a/src/lib/reflect/type.go b/src/lib/reflect/type.go
index a7e8f7f317..1095ccb497 100644
--- a/src/lib/reflect/type.go
+++ b/src/lib/reflect/type.go
@@ -12,13 +12,13 @@ import (
 	"sync";
 )
 
-export type Type interface
+type Type interface
 
-export func ExpandType(name string) Type
+func ExpandType(name string) Type
 
 func typestrings() string	// implemented in C; declared here
 
-export const (
+const (
 	MissingKind = iota;
 	ArrayKind;
 	BoolKind;
@@ -54,7 +54,7 @@ var interfacesize int
 var missingString = "$missing$"	// syntactic name for undefined type names
 var dotDotDotString = "..."
 
-export type Type interface {
+type Type interface {
 	Kind()	int;
 	Name()	string;
 	String()	string;
@@ -102,7 +102,7 @@ func newBasicType(name string, kind int, size int) Type {
 }
 
 // Prebuilt basic types
-export var (
+var (
 	Missing = newBasicType(missingString, MissingKind, 1);
 	DotDotDot = newBasicType(dotDotDotString, DotDotDotKind, 16);	// TODO(r): size of interface?
 	Bool = newBasicType("bool", BoolKind, 1); // TODO: need to know how big a bool is
@@ -145,7 +145,7 @@ func (t *stubType) Get() Type {
 
 // -- Pointer
 
-export type PtrType interface {
+type PtrType interface {
 	Sub()	Type
 }
 
@@ -164,7 +164,7 @@ func (t *ptrTypeStruct) Sub() Type {
 
 // -- Array
 
-export type ArrayType interface {
+type ArrayType interface {
 	Open()	bool;
 	Len()	int;
 	Elem()	Type;
@@ -203,7 +203,7 @@ func (t *arrayTypeStruct) Elem() Type {
 
 // -- Map
 
-export type MapType interface {
+type MapType interface {
 	Key()	Type;
 	Elem()	Type;
 }
@@ -228,12 +228,12 @@ func (t *mapTypeStruct) Elem() Type {
 
 // -- Chan
 
-export type ChanType interface {
+type ChanType interface {
 	Dir()	int;
 	Elem()	Type;
 }
 
-export const (	// channel direction
+const (	// channel direction
 	SendDir = 1 << iota;
 	RecvDir;
 	BothDir = SendDir | RecvDir;
@@ -259,7 +259,7 @@ func (t *chanTypeStruct) Elem() Type {
 
 // -- Struct
 
-export type StructType interface {
+type StructType interface {
 	Field(int)	(name string, typ Type, tag string, offset int);
 	Len()	int;
 }
@@ -319,7 +319,7 @@ func (t *structTypeStruct) Len() int {
 
 // -- Interface
 
-export type InterfaceType interface {
+type InterfaceType interface {
 	Field(int)	(name string, typ Type, tag string, offset int);
 	Len()	int;
 }
@@ -345,7 +345,7 @@ var nilInterface = newInterfaceTypeStruct("nil", "", make([]structField, 0));
 
 // -- Func
 
-export type FuncType interface {
+type FuncType interface {
 	In()	StructType;
 	Out()	StructType;
 }
@@ -842,7 +842,7 @@ func (p *typeParser) Type(name string) *stubType {
 	return s;
 }
 
-export func ParseTypeString(name, typestring string) Type {
+func ParseTypeString(name, typestring string) Type {
 	if typestring == "" {
 		// If the typestring is empty, it represents (the type of) a nil interface value
 		return nilInterface
@@ -902,7 +902,7 @@ func typeNameToTypeString(name string) string {
 }
 
 // Type is known by name.  Find (and create if necessary) its real type.
-export func ExpandType(name string) Type {
+func ExpandType(name string) Type {
 	lock();
 	t, ok := types[name];
 	if ok {
diff --git a/src/lib/reflect/value.go b/src/lib/reflect/value.go
index ebd3c5f4ad..f1651a28c8 100644
--- a/src/lib/reflect/value.go
+++ b/src/lib/reflect/value.go
@@ -12,13 +12,13 @@ import (
 	"unsafe";
 )
 
-export type Addr unsafe.pointer
+type Addr unsafe.Pointer
 
 func equalType(a, b Type) bool {
 	return a.String() == b.String()
 }
 
-export type Value interface {
+type Value interface {
 	Kind()	int;
 	Type()	Type;
 	Addr()	Addr;
@@ -65,7 +65,7 @@ type creatorFn *(typ Type, addr Addr) Value
 
 // -- Missing
 
-export type MissingValue interface {
+type MissingValue interface {
 	Kind()	int;
 	Type()	Type;
 	Addr()	Addr;
@@ -81,7 +81,7 @@ func missingCreator(typ Type, addr Addr) Value {
 
 // -- Int
 
-export type IntValue interface {
+type IntValue interface {
 	Kind()	int;
 	Get()	int;
 	Set(int);
@@ -106,7 +106,7 @@ func (v *intValueStruct) Set(i int) {
 
 // -- Int8
 
-export type Int8Value interface {
+type Int8Value interface {
 	Kind()	int;
 	Get()	int8;
 	Set(int8);
@@ -131,7 +131,7 @@ func (v *int8ValueStruct) Set(i int8) {
 
 // -- Int16
 
-export type Int16Value interface {
+type Int16Value interface {
 	Kind()	int;
 	Get()	int16;
 	Set(int16);
@@ -156,7 +156,7 @@ func (v *int16ValueStruct) Set(i int16) {
 
 // -- Int32
 
-export type Int32Value interface {
+type Int32Value interface {
 	Kind()	int;
 	Get()	int32;
 	Set(int32);
@@ -181,7 +181,7 @@ func (v *int32ValueStruct) Set(i int32) {
 
 // -- Int64
 
-export type Int64Value interface {
+type Int64Value interface {
 	Kind()	int;
 	Get()	int64;
 	Set(int64);
@@ -206,7 +206,7 @@ func (v *int64ValueStruct) Set(i int64) {
 
 // -- Uint
 
-export type UintValue interface {
+type UintValue interface {
 	Kind()	int;
 	Get()	uint;
 	Set(uint);
@@ -231,7 +231,7 @@ func (v *uintValueStruct) Set(i uint) {
 
 // -- Uint8
 
-export type Uint8Value interface {
+type Uint8Value interface {
 	Kind()	int;
 	Get()	uint8;
 	Set(uint8);
@@ -256,7 +256,7 @@ func (v *uint8ValueStruct) Set(i uint8) {
 
 // -- Uint16
 
-export type Uint16Value interface {
+type Uint16Value interface {
 	Kind()	int;
 	Get()	uint16;
 	Set(uint16);
@@ -281,7 +281,7 @@ func (v *uint16ValueStruct) Set(i uint16) {
 
 // -- Uint32
 
-export type Uint32Value interface {
+type Uint32Value interface {
 	Kind()	int;
 	Get()	uint32;
 	Set(uint32);
@@ -306,7 +306,7 @@ func (v *uint32ValueStruct) Set(i uint32) {
 
 // -- Uint64
 
-export type Uint64Value interface {
+type Uint64Value interface {
 	Kind()	int;
 	Get()	uint64;
 	Set(uint64);
@@ -331,7 +331,7 @@ func (v *uint64ValueStruct) Set(i uint64) {
 
 // -- Uintptr
 
-export type UintptrValue interface {
+type UintptrValue interface {
 	Kind()	int;
 	Get()	uintptr;
 	Set(uintptr);
@@ -356,7 +356,7 @@ func (v *uintptrValueStruct) Set(i uintptr) {
 
 // -- Float
 
-export type FloatValue interface {
+type FloatValue interface {
 	Kind()	int;
 	Get()	float;
 	Set(float);
@@ -381,7 +381,7 @@ func (v *floatValueStruct) Set(f float) {
 
 // -- Float32
 
-export type Float32Value interface {
+type Float32Value interface {
 	Kind()	int;
 	Get()	float32;
 	Set(float32);
@@ -406,7 +406,7 @@ func (v *float32ValueStruct) Set(f float32) {
 
 // -- Float64
 
-export type Float64Value interface {
+type Float64Value interface {
 	Kind()	int;
 	Get()	float64;
 	Set(float64);
@@ -431,7 +431,7 @@ func (v *float64ValueStruct) Set(f float64) {
 
 // -- Float80
 
-export type Float80Value interface {
+type Float80Value interface {
 	Kind()	int;
 	Get()	float80;
 	Set(float80);
@@ -459,7 +459,7 @@ func (v *Float80ValueStruct) Set(f float80) {
 
 // -- String
 
-export type StringValue interface {
+type StringValue interface {
 	Kind()	int;
 	Get()	string;
 	Set(string);
@@ -484,7 +484,7 @@ func (v *stringValueStruct) Set(s string) {
 
 // -- Bool
 
-export type BoolValue interface {
+type BoolValue interface {
 	Kind()	int;
 	Get()	bool;
 	Set(bool);
@@ -509,7 +509,7 @@ func (v *boolValueStruct) Set(b bool) {
 
 // -- Pointer
 
-export type PtrValue interface {
+type PtrValue interface {
 	Kind()	int;
 	Type()	Type;
 	Sub()	Value;
@@ -545,7 +545,7 @@ func ptrCreator(typ Type, addr Addr) Value {
 
 // -- Array
 
-export type ArrayValue interface {
+type ArrayValue interface {
 	Kind()	int;
 	Type()	Type;
 	Open()	bool;
@@ -652,7 +652,7 @@ func arrayCreator(typ Type, addr Addr) Value {
 
 // -- Map	TODO: finish and test
 
-export type MapValue interface {
+type MapValue interface {
 	Kind()	int;
 	Type()	Type;
 	Len()	int;
@@ -678,7 +678,7 @@ func (v *mapValueStruct) Elem(key Value) Value {
 
 // -- Chan
 
-export type ChanValue interface {
+type ChanValue interface {
 	Kind()	int;
 	Type()	Type;
 }
@@ -693,7 +693,7 @@ func chanCreator(typ Type, addr Addr) Value {
 
 // -- Struct
 
-export type StructValue interface {
+type StructValue interface {
 	Kind()	int;
 	Type()	Type;
 	Len()	int;
@@ -728,7 +728,7 @@ func structCreator(typ Type, addr Addr) Value {
 
 // -- Interface
 
-export type InterfaceValue interface {
+type InterfaceValue interface {
 	Kind()	int;
 	Type()	Type;
 	Get()	interface {};
@@ -748,7 +748,7 @@ func interfaceCreator(typ Type, addr Addr) Value {
 
 // -- Func
 
-export type FuncValue interface {
+type FuncValue interface {
 	Kind()	int;
 	Type()	Type;
 }
@@ -799,7 +799,7 @@ func newValueAddr(typ Type, addr Addr) Value {
 	return c(typ, addr);
 }
 
-export func NewInitValue(typ Type) Value {
+func NewInitValue(typ Type) Value {
 	// Some values cannot be made this way.
 	switch typ.Kind() {
 	case FuncKind:	// must be pointers, at least for now (TODO?)
@@ -825,7 +825,7 @@ export func NewInitValue(typ Type) Value {
 			uint32	cap;		// allocated number of elements
 		};
 */
-export func NewOpenArrayValue(typ ArrayType, len, cap int) ArrayValue {
+func NewOpenArrayValue(typ ArrayType, len, cap int) ArrayValue {
 	if !typ.Open() {
 		return nil
 	}
@@ -843,7 +843,7 @@ export func NewOpenArrayValue(typ ArrayType, len, cap int) ArrayValue {
 	return newValueAddr(typ, Addr(array));
 }
 
-export func CopyArray(dst ArrayValue, src ArrayValue, n int) {
+func CopyArray(dst ArrayValue, src ArrayValue, n int) {
 	if n == 0 {
 		return
 	}
@@ -875,7 +875,7 @@ export func CopyArray(dst ArrayValue, src ArrayValue, n int) {
 }
 
 
-export func NewValue(e interface {}) Value {
+func NewValue(e interface {}) Value {
 	value, typestring, indir := sys.Reflect(e);
 	typ, ok := typecache[typestring];
 	if !ok {
diff --git a/src/lib/regexp/all_test.go b/src/lib/regexp/all_test.go
index f72671ccf0..5e9754934f 100644
--- a/src/lib/regexp/all_test.go
+++ b/src/lib/regexp/all_test.go
@@ -36,16 +36,16 @@ type stringError struct {
 }
 var bad_re = []stringError{
 	stringError{ `*`,	 	regexp.ErrBareClosure },
-	stringError{ `(abc`,	regexp.ErrUnmatchedLpar },	
-	stringError{ `abc)`,	regexp.ErrUnmatchedRpar },	
-	stringError{ `x[a-z`,	regexp.ErrUnmatchedLbkt },	
-	stringError{ `abc]`,	regexp.ErrUnmatchedRbkt },	
-	stringError{ `[z-a]`,	regexp.ErrBadRange },	
-	stringError{ `abc\`,	regexp.ErrExtraneousBackslash },	
-	stringError{ `a**`,	regexp.ErrBadClosure },	
-	stringError{ `a*+`,	regexp.ErrBadClosure },	
-	stringError{ `a??`,	regexp.ErrBadClosure },	
-	stringError{ `*`,	 	regexp.ErrBareClosure },	
+	stringError{ `(abc`,	regexp.ErrUnmatchedLpar },
+	stringError{ `abc)`,	regexp.ErrUnmatchedRpar },
+	stringError{ `x[a-z`,	regexp.ErrUnmatchedLbkt },
+	stringError{ `abc]`,	regexp.ErrUnmatchedRbkt },
+	stringError{ `[z-a]`,	regexp.ErrBadRange },
+	stringError{ `abc\`,	regexp.ErrExtraneousBackslash },
+	stringError{ `a**`,	regexp.ErrBadClosure },
+	stringError{ `a*+`,	regexp.ErrBadClosure },
+	stringError{ `a??`,	regexp.ErrBadClosure },
+	stringError{ `*`,	 	regexp.ErrBareClosure },
 	stringError{ `\x`,	regexp.ErrBadBackslash },
 }
 
@@ -155,19 +155,19 @@ func executeTest(t *testing.T, expr string, str string, match []int) {
 	}
 }
 
-export func TestGoodCompile(t *testing.T) {
+func TestGoodCompile(t *testing.T) {
 	for i := 0; i < len(good_re); i++ {
 		compileTest(t, good_re[i], nil);
 	}
 }
 
-export func TestBadCompile(t *testing.T) {
+func TestBadCompile(t *testing.T) {
 	for i := 0; i < len(bad_re); i++ {
 		compileTest(t, bad_re[i].re, bad_re[i].err)
 	}
 }
 
-export func TestExecute(t *testing.T) {
+func TestExecute(t *testing.T) {
 	for i := 0; i < len(matches); i++ {
 		test := &matches[i];
 		executeTest(t, test.re, test.text, test.match)
@@ -185,7 +185,7 @@ func matchTest(t *testing.T, expr string, str string, match []int) {
 	}
 }
 
-export func TestMatch(t *testing.T) {
+func TestMatch(t *testing.T) {
 	for i := 0; i < len(matches); i++ {
 		test := &matches[i];
 		matchTest(t, test.re, test.text, test.match)
@@ -210,7 +210,7 @@ func matchStringsTest(t *testing.T, expr string, str string, match []int) {
 	}
 }
 
-export func TestMatchStrings(t *testing.T) {
+func TestMatchStrings(t *testing.T) {
 	for i := 0; i < len(matches); i++ {
 		test := &matches[i];
 		matchTest(t, test.re, test.text, test.match)
@@ -227,7 +227,7 @@ func matchFunctionTest(t *testing.T, expr string, str string, match []int) {
 	}
 }
 
-export func TestMatchFunction(t *testing.T) {
+func TestMatchFunction(t *testing.T) {
 	for i := 0; i < len(matches); i++ {
 		test := &matches[i];
 		matchFunctionTest(t, test.re, test.text, test.match)
diff --git a/src/lib/regexp/regexp.go b/src/lib/regexp/regexp.go
index e838603146..b406443f53 100644
--- a/src/lib/regexp/regexp.go
+++ b/src/lib/regexp/regexp.go
@@ -15,16 +15,16 @@ import (
 var debug = false;
 
 
-export var ErrInternal = os.NewError("internal error");
-export var ErrUnmatchedLpar = os.NewError("unmatched '('");
-export var ErrUnmatchedRpar = os.NewError("unmatched ')'");
-export var ErrUnmatchedLbkt = os.NewError("unmatched '['");
-export var ErrUnmatchedRbkt = os.NewError("unmatched ']'");
-export var ErrBadRange = os.NewError("bad range in character class");
-export var ErrExtraneousBackslash = os.NewError("extraneous backslash");
-export var ErrBadClosure = os.NewError("repeated closure (**, ++, etc.)");
-export var ErrBareClosure = os.NewError("closure applies to nothing");
-export var ErrBadBackslash = os.NewError("illegal backslash escape");
+var ErrInternal = os.NewError("internal error");
+var ErrUnmatchedLpar = os.NewError("unmatched '('");
+var ErrUnmatchedRpar = os.NewError("unmatched ')'");
+var ErrUnmatchedLbkt = os.NewError("unmatched '['");
+var ErrUnmatchedRbkt = os.NewError("unmatched ']'");
+var ErrBadRange = os.NewError("bad range in character class");
+var ErrExtraneousBackslash = os.NewError("extraneous backslash");
+var ErrBadClosure = os.NewError("repeated closure (**, ++, etc.)");
+var ErrBareClosure = os.NewError("closure applies to nothing");
+var ErrBadBackslash = os.NewError("illegal backslash escape");
 
 // An instruction executed by the NFA
 type instr interface {
@@ -582,14 +582,14 @@ func compiler(str string, ch chan *_RE) {
 }
 
 // Public interface has only execute functionality
-export type Regexp interface {
+type Regexp interface {
 	Execute(s string) []int;
 	Match(s string) bool;
 	MatchStrings(s string) []string;
 }
 
 // Compile in separate goroutine; wait for result
-export func Compile(str string) (regexp Regexp, error *os.Error) {
+func Compile(str string) (regexp Regexp, error *os.Error) {
 	ch := make(chan *_RE);
 	go compiler(str, ch);
 	re := <-ch;
@@ -739,7 +739,7 @@ func (re *_RE) MatchStrings(s string) []string {
 
 // Exported function for simple boolean check.  Anything more fancy
 // needs a call to Compile.
-export func Match(pattern string, s string) (matched bool, error *os.Error) {
+func Match(pattern string, s string) (matched bool, error *os.Error) {
 	re, err := Compile(pattern);
 	if err != nil {
 		return false, err
diff --git a/src/lib/sort.go b/src/lib/sort.go
index 45726d80a6..0caf4ec125 100644
--- a/src/lib/sort.go
+++ b/src/lib/sort.go
@@ -4,7 +4,7 @@
 
 package sort
 
-export type SortInterface interface {
+type SortInterface interface {
 	Len() int;
 	Less(i, j int) bool;
 	Swap(i, j int);
@@ -116,12 +116,12 @@ func quickSort(data SortInterface, a, b int) {
 	}
 }
 
-export func Sort(data SortInterface) {
+func Sort(data SortInterface) {
 	quickSort(data, 0, data.Len());
 }
 
 
-export func IsSorted(data SortInterface) bool {
+func IsSorted(data SortInterface) bool {
 	n := data.Len();
 	for i := n - 1; i > 0; i-- {
 		if data.Less(i, i - 1) {
@@ -134,21 +134,21 @@ export func IsSorted(data SortInterface) bool {
 
 // Convenience types for common cases
 
-export type IntArray []int
+type IntArray []int
 
 func (p IntArray) Len() int            { return len(p); }
 func (p IntArray) Less(i, j int) bool  { return p[i] < p[j]; }
 func (p IntArray) Swap(i, j int)       { p[i], p[j] = p[j], p[i]; }
 
 
-export type FloatArray  []float
+type FloatArray  []float
 
 func (p FloatArray) Len() int            { return len(p); }
 func (p FloatArray) Less(i, j int) bool  { return p[i] < p[j]; }
 func (p FloatArray) Swap(i, j int)       { p[i], p[j] = p[j], p[i]; }
 
 
-export type StringArray []string
+type StringArray []string
 
 func (p StringArray) Len() int            { return len(p); }
 func (p StringArray) Less(i, j int) bool  { return p[i] < p[j]; }
@@ -157,11 +157,11 @@ func (p StringArray) Swap(i, j int)       { p[i], p[j] = p[j], p[i]; }
 
 // Convenience wrappers for common cases
 
-export func SortInts(a []int)        { Sort(IntArray(a)); }
-export func SortFloats(a []float)    { Sort(FloatArray(a)); }
-export func SortStrings(a []string)  { Sort(StringArray(a)); }
+func SortInts(a []int)        { Sort(IntArray(a)); }
+func SortFloats(a []float)    { Sort(FloatArray(a)); }
+func SortStrings(a []string)  { Sort(StringArray(a)); }
 
 
-export func IntsAreSorted(a []int) bool       { return IsSorted(IntArray(a)); }
-export func FloatsAreSorted(a []float) bool   { return IsSorted(FloatArray(a)); }
-export func StringsAreSorted(a []string) bool { return IsSorted(StringArray(a)); }
+func IntsAreSorted(a []int) bool       { return IsSorted(IntArray(a)); }
+func FloatsAreSorted(a []float) bool   { return IsSorted(FloatArray(a)); }
+func StringsAreSorted(a []string) bool { return IsSorted(StringArray(a)); }
diff --git a/src/lib/sort_test.go b/src/lib/sort_test.go
index d3a8238f6b..aa80aa10e3 100644
--- a/src/lib/sort_test.go
+++ b/src/lib/sort_test.go
@@ -16,7 +16,7 @@ var ints = [...]int{74, 59, 238, -784, 9845, 959, 905, 0, 0, 42, 7586, -5467984,
 var floats = [...]float{74.3, 59.0, 238.2, -784.0, 2.3, 9845.768, -959.7485, 905, 7.8, 7.8}
 var strings = [...]string{"", "Hello", "foo", "bar", "foo", "f00", "%*&^*&^&", "***"}
 
-export func TestSortIntArray(t *testing.T) {
+func TestSortIntArray(t *testing.T) {
 	data := ints;
 	a := IntArray(data);
 	sort.Sort(a);
@@ -26,7 +26,7 @@ export func TestSortIntArray(t *testing.T) {
 	}
 }
 
-export func TestSortFloatArray(t *testing.T) {
+func TestSortFloatArray(t *testing.T) {
 	data := floats;
 	a := FloatArray(data);
 	sort.Sort(a);
@@ -36,7 +36,7 @@ export func TestSortFloatArray(t *testing.T) {
 	}
 }
 
-export func TestSortStringArray(t *testing.T) {
+func TestSortStringArray(t *testing.T) {
 	data := strings;
 	a := StringArray(data);
 	sort.Sort(a);
@@ -46,7 +46,7 @@ export func TestSortStringArray(t *testing.T) {
 	}
 }
 
-export func TestSortInts(t *testing.T) {
+func TestSortInts(t *testing.T) {
 	data := ints;
 	sort.SortInts(data);
 	if !sort.IntsAreSorted(data) {
@@ -55,7 +55,7 @@ export func TestSortInts(t *testing.T) {
 	}
 }
 
-export func TestSortFloats(t *testing.T) {
+func TestSortFloats(t *testing.T) {
 	data := floats;
 	sort.SortFloats(data);
 	if !sort.FloatsAreSorted(data) {
@@ -64,7 +64,7 @@ export func TestSortFloats(t *testing.T) {
 	}
 }
 
-export func TestSortStrings(t *testing.T) {
+func TestSortStrings(t *testing.T) {
 	data := strings;
 	sort.SortStrings(data);
 	if !sort.StringsAreSorted(data) {
@@ -73,7 +73,7 @@ export func TestSortStrings(t *testing.T) {
 	}
 }
 
-export func TestSortLarge_Random(t *testing.T) {
+func TestSortLarge_Random(t *testing.T) {
 	data := make([]int, 1000000);
 	for i := 0; i < len(data); i++ {
 		data[i] = rand.Intn(100);
@@ -133,7 +133,7 @@ func lg(n int) int {
 	return i;
 }
 
-export func TestBentleyMcIlroy(t *testing.T) {
+func TestBentleyMcIlroy(t *testing.T) {
 	sizes := []int{100, 1023, 1024, 1025};
 	dists := []string{"sawtooth", "rand", "stagger", "plateau", "shuffle"};
 	modes := []string{"copy", "reverse", "reverse1", "reverse2", "sort", "dither"};
diff --git a/src/lib/strconv/atof.go b/src/lib/strconv/atof.go
index 147b7955b2..e562bfdb33 100644
--- a/src/lib/strconv/atof.go
+++ b/src/lib/strconv/atof.go
@@ -318,7 +318,7 @@ func decimalAtof32(neg bool, d *decimal, trunc bool) (f float32, ok bool) {
 // If s is syntactically well-formed but is more than 1/2 ULP
 // away from the largest floating point number of the given size,
 // returns f = Inf, err = os.ERANGE.
-export func Atof64(s string) (f float64, err *os.Error) {
+func Atof64(s string) (f float64, err *os.Error) {
 	neg, d, trunc, ok := stringToDecimal(s);
 	if !ok {
 		return 0, os.EINVAL;
@@ -336,7 +336,7 @@ export func Atof64(s string) (f float64, err *os.Error) {
 	return f, err
 }
 
-export func Atof32(s string) (f float32, err *os.Error) {
+func Atof32(s string) (f float32, err *os.Error) {
 	neg, d, trunc, ok := stringToDecimal(s);
 	if !ok {
 		return 0, os.EINVAL;
@@ -354,7 +354,7 @@ export func Atof32(s string) (f float32, err *os.Error) {
 	return f, err
 }
 
-export func Atof(s string) (f float, err *os.Error) {
+func Atof(s string) (f float, err *os.Error) {
 	if FloatSize == 32 {
 		f1, err1 := Atof32(s);
 		return float(f1), err1;
diff --git a/src/lib/strconv/atof_test.go b/src/lib/strconv/atof_test.go
index 493829b570..7f1f0a1312 100644
--- a/src/lib/strconv/atof_test.go
+++ b/src/lib/strconv/atof_test.go
@@ -124,10 +124,10 @@ func testAtof(t *testing.T, opt bool) {
 	strconv.optimize = oldopt;
 }
 
-export func TestAtof(t *testing.T) {
+func TestAtof(t *testing.T) {
 	testAtof(t, true);
 }
 
-export func TestAtofSlow(t *testing.T) {
+func TestAtofSlow(t *testing.T) {
 	testAtof(t, false);
 }
diff --git a/src/lib/strconv/atoi.go b/src/lib/strconv/atoi.go
index 1c5d112cf3..b41d08e147 100644
--- a/src/lib/strconv/atoi.go
+++ b/src/lib/strconv/atoi.go
@@ -15,7 +15,7 @@ func computeIntsize() uint {
 var intsize = computeIntsize();
 
 // Convert decimal string to unsigned integer.
-export func Atoui64(s string) (i uint64, err *os.Error) {
+func Atoui64(s string) (i uint64, err *os.Error) {
 	// empty string bad
 	if len(s) == 0 {
 		return 0, os.EINVAL
@@ -52,7 +52,7 @@ export func Atoui64(s string) (i uint64, err *os.Error) {
 }
 
 // Convert decimal string to integer.
-export func Atoi64(s string) (i int64, err *os.Error) {
+func Atoi64(s string) (i int64, err *os.Error) {
 	// empty string bad
 	if len(s) == 0 {
 		return 0, os.EINVAL
@@ -85,7 +85,7 @@ export func Atoi64(s string) (i int64, err *os.Error) {
 	return n, nil
 }
 
-export func Atoui(s string) (i uint, err *os.Error) {
+func Atoui(s string) (i uint, err *os.Error) {
 	i1, e1 := Atoui64(s);
 	if e1 != nil && e1 != os.ERANGE {
 		return 0, e1
@@ -99,7 +99,7 @@ export func Atoui(s string) (i uint, err *os.Error) {
 	return i, nil
 }
 
-export func Atoi(s string) (i int, err *os.Error) {
+func Atoi(s string) (i int, err *os.Error) {
 	i1, e1 := Atoi64(s);
 	if e1 != nil && e1 != os.ERANGE {
 		return 0, e1
diff --git a/src/lib/strconv/atoi_test.go b/src/lib/strconv/atoi_test.go
index 41a6f4b76f..5ffda142e6 100644
--- a/src/lib/strconv/atoi_test.go
+++ b/src/lib/strconv/atoi_test.go
@@ -103,7 +103,7 @@ var atoi32tests = []atoi32Test {
 	atoi32Test{ "-2147483649", -1<<31, os.ERANGE },
 }
 
-export func TestAtoui64(t *testing.T) {
+func TestAtoui64(t *testing.T) {
 	for i := 0; i < len(atoui64tests); i++ {
 		test := &atoui64tests[i];
 		out, err := strconv.Atoui64(test.in);
@@ -114,7 +114,7 @@ export func TestAtoui64(t *testing.T) {
 	}
 }
 
-export func TestAtoi64(t *testing.T) {
+func TestAtoi64(t *testing.T) {
 	for i := 0; i < len(atoi64test); i++ {
 		test := &atoi64test[i];
 		out, err := strconv.Atoi64(test.in);
@@ -125,7 +125,7 @@ export func TestAtoi64(t *testing.T) {
 	}
 }
 
-export func TestAtoui(t *testing.T) {
+func TestAtoui(t *testing.T) {
 	switch intsize {
 	case 32:
 		for i := 0; i < len(atoui32tests); i++ {
@@ -148,7 +148,7 @@ export func TestAtoui(t *testing.T) {
 	}
 }
 
-export func TestAtoi(t *testing.T) {
+func TestAtoi(t *testing.T) {
 	switch intsize {
 	case 32:
 		for i := 0; i < len(atoi32tests); i++ {
diff --git a/src/lib/strconv/decimal_test.go b/src/lib/strconv/decimal_test.go
index 55fcbdd6b5..bc82861bdd 100644
--- a/src/lib/strconv/decimal_test.go
+++ b/src/lib/strconv/decimal_test.go
@@ -29,7 +29,7 @@ var shifttests = []shiftTest {
 	shiftTest{ 1953125, 9, "1000000000" },
 }
 
-export func TestDecimalShift(t *testing.T) {
+func TestDecimalShift(t *testing.T) {
 	ok := true;
 	for i := 0; i < len(shifttests); i++ {
 		test := &shifttests[i];
@@ -66,7 +66,7 @@ var roundtests = []roundTest {
 	roundTest{ 12999999, 4, "12990000", "13000000", "13000000", 13000000 },
 }
 
-export func TestDecimalRound(t *testing.T) {
+func TestDecimalRound(t *testing.T) {
 	for i := 0; i < len(roundtests); i++ {
 		test := &roundtests[i];
 		s := strconv.newDecimal(test.i).RoundDown(test.nd).String();
@@ -106,7 +106,7 @@ var roundinttests = []roundIntTest {
 	roundIntTest{ 1000, 0, 1000 },
 }
 
-export func TestDecimalRoundedInteger(t *testing.T) {
+func TestDecimalRoundedInteger(t *testing.T) {
 	for i := 0; i < len(roundinttests); i++ {
 		test := roundinttests[i];
 		// TODO: should be able to use int := here.
diff --git a/src/lib/strconv/fp_test.go b/src/lib/strconv/fp_test.go
index f0cfad0bb9..6738ed75e1 100644
--- a/src/lib/strconv/fp_test.go
+++ b/src/lib/strconv/fp_test.go
@@ -92,7 +92,7 @@ func myatof32(s string) (f float32, ok bool) {
 	return f1, true;
 }
 
-export func TestFp(t *testing.T) {
+func TestFp(t *testing.T) {
 	fd, err := os.Open("testfp.txt", os.O_RDONLY, 0);
 	if err != nil {
 		panicln("testfp: open testfp.txt:", err.String());
diff --git a/src/lib/strconv/ftoa.go b/src/lib/strconv/ftoa.go
index 355680fb7b..c4951873d0 100644
--- a/src/lib/strconv/ftoa.go
+++ b/src/lib/strconv/ftoa.go
@@ -38,17 +38,17 @@ func floatsize() int {
 	}
 	return 64;
 }
-export var FloatSize = floatsize()
+var FloatSize = floatsize()
 
-export func Ftoa32(f float32, fmt byte, prec int) string {
+func Ftoa32(f float32, fmt byte, prec int) string {
 	return genericFtoa(uint64(sys.Float32bits(f)), fmt, prec, &float32info);
 }
 
-export func Ftoa64(f float64, fmt byte, prec int) string {
+func Ftoa64(f float64, fmt byte, prec int) string {
 	return genericFtoa(sys.Float64bits(f), fmt, prec, &float64info);
 }
 
-export func Ftoa(f float, fmt byte, prec int) string {
+func Ftoa(f float, fmt byte, prec int) string {
 	if FloatSize == 32 {
 		return Ftoa32(float32(f), fmt, prec);
 	}
diff --git a/src/lib/strconv/ftoa_test.go b/src/lib/strconv/ftoa_test.go
index 61ce38cff1..309f028700 100644
--- a/src/lib/strconv/ftoa_test.go
+++ b/src/lib/strconv/ftoa_test.go
@@ -98,7 +98,7 @@ var ftoatests = []ftoaTest {
 	ftoaTest{ -1, 'b', -1, "-4503599627370496p-52" },
 }
 
-export func TestFtoa(t *testing.T) {
+func TestFtoa(t *testing.T) {
 	if strconv.FloatSize != 32 {
 		panic("floatsize: ", strconv.FloatSize);
 	}
diff --git a/src/lib/strconv/itoa.go b/src/lib/strconv/itoa.go
index 256289ada9..7409d0836b 100644
--- a/src/lib/strconv/itoa.go
+++ b/src/lib/strconv/itoa.go
@@ -4,7 +4,7 @@
 
 package strconv
 
-export func Itoa64(i int64) string {
+func Itoa64(i int64) string {
 	if i == 0 {
 		return "0"
 	}
@@ -31,7 +31,7 @@ export func Itoa64(i int64) string {
 	return string(b[bp:len(b)])
 }
 
-export func Itoa(i int) string {
+func Itoa(i int) string {
 	return Itoa64(int64(i));
 }
 
diff --git a/src/lib/strconv/itoa_test.go b/src/lib/strconv/itoa_test.go
index b0e4ed7fa9..e965a1c167 100644
--- a/src/lib/strconv/itoa_test.go
+++ b/src/lib/strconv/itoa_test.go
@@ -40,7 +40,7 @@ var itoa64tests = []itoa64Test {
 	itoa64Test{ -1<<63, "-9223372036854775808" },
 }
 
-export func TestItoa(t *testing.T) {
+func TestItoa(t *testing.T) {
 	for i := 0; i < len(itoa64tests); i++ {
 		test := itoa64tests[i];
 		s := strconv.Itoa64(test.in);
diff --git a/src/lib/strconv/quote.go b/src/lib/strconv/quote.go
index 9875450528..b11d738175 100644
--- a/src/lib/strconv/quote.go
+++ b/src/lib/strconv/quote.go
@@ -10,7 +10,7 @@ import (
 
 const lowerhex = "0123456789abcdef"
 
-export func Quote(s string) string {
+func Quote(s string) string {
 	t := `"`;
 	for i := 0; i < len(s); i++ {
 		switch {
@@ -67,7 +67,7 @@ export func Quote(s string) string {
 	return t;
 }
 
-export func CanBackquote(s string) bool {
+func CanBackquote(s string) bool {
 	for i := 0; i < len(s); i++ {
 		if s[i] < ' ' || s[i] == '`' {
 			return false;
diff --git a/src/lib/strconv/quote_test.go b/src/lib/strconv/quote_test.go
index ac2c8e7069..8421fcde49 100644
--- a/src/lib/strconv/quote_test.go
+++ b/src/lib/strconv/quote_test.go
@@ -23,7 +23,7 @@ var quotetests = []quoteTest {
 	quoteTest{ "\x04", `"\x04"` },
 }
 
-export func TestQuote(t *testing.T) {
+func TestQuote(t *testing.T) {
 	for i := 0; i < len(quotetests); i++ {
 		tt := quotetests[i];
 		if out := Quote(tt.in); out != tt.out {
@@ -78,7 +78,7 @@ var canbackquotetests = []canBackquoteTest {
 	canBackquoteTest{ ``, true },
 }
 
-export func TestCanBackquote(t *testing.T) {
+func TestCanBackquote(t *testing.T) {
 	for i := 0; i < len(canbackquotetests); i++ {
 		tt := canbackquotetests[i];
 		if out := CanBackquote(tt.in); out != tt.out {
diff --git a/src/lib/strings.go b/src/lib/strings.go
index 2dc386a353..782ecbc5f5 100644
--- a/src/lib/strings.go
+++ b/src/lib/strings.go
@@ -7,7 +7,7 @@ package strings
 import "utf8"
 
 // Split string into array of UTF-8 sequences (still strings)
-export func Explode(s string) []string {
+func Explode(s string) []string {
 	a := make([]string, utf8.RuneCountInString(s, 0, len(s)));
 	j := 0;
 	var size, rune int;
@@ -20,7 +20,7 @@ export func Explode(s string) []string {
 }
 
 // Count non-overlapping instances of sep in s.
-export func Count(s, sep string) int {
+func Count(s, sep string) int {
 	if sep == "" {
 		return utf8.RuneCountInString(s, 0, len(s))+1
 	}
@@ -36,7 +36,7 @@ export func Count(s, sep string) int {
 }
 
 // Return index of first instance of sep in s.
-export func Index(s, sep string) int {
+func Index(s, sep string) int {
 	if sep == "" {
 		return 0
 	}
@@ -50,7 +50,7 @@ export func Index(s, sep string) int {
 }
 
 // Split string into list of strings at separators
-export func Split(s, sep string) []string {
+func Split(s, sep string) []string {
 	if sep == "" {
 		return Explode(s)
 	}
@@ -72,7 +72,7 @@ export func Split(s, sep string) []string {
 }
 
 // Join list of strings with separators between them.
-export func Join(a []string, sep string) string {
+func Join(a []string, sep string) string {
 	if len(a) == 0 {
 		return ""
 	}
diff --git a/src/lib/strings_test.go b/src/lib/strings_test.go
index 3bece666f0..2cbf70b93b 100644
--- a/src/lib/strings_test.go
+++ b/src/lib/strings_test.go
@@ -26,7 +26,7 @@ var faces = "";
 var commas = "1,2,3,4";
 var dots = "1....2....3....4";
 
-export type ExplodeTest struct {
+type ExplodeTest struct {
 	s string;
 	a []string;
 }
@@ -34,7 +34,7 @@ var explodetests = []ExplodeTest {
 	ExplodeTest{ abcd,	[]string{"a", "b", "c", "d"} },
 	ExplodeTest{ faces,	[]string{"", "", "" } },
 }
-export func TestExplode(t *testing.T) {
+func TestExplode(t *testing.T) {
 	for i := 0; i < len(explodetests); i++ {
 		tt := explodetests[i];
 		a := Explode(tt.s);
@@ -49,7 +49,7 @@ export func TestExplode(t *testing.T) {
 	}
 }
 
-export type SplitTest struct {
+type SplitTest struct {
 	s string;
 	sep string;
 	a []string;
@@ -64,7 +64,7 @@ var splittests = []SplitTest {
 	SplitTest{ faces,	"~",	[]string{faces} },
 	SplitTest{ faces,	"",	[]string{"", "", ""} },
 }
-export func TestSplit(t *testing.T) {
+func TestSplit(t *testing.T) {
 	for i := 0; i < len(splittests); i++ {
 		tt := splittests[i];
 		a := Split(tt.s, tt.sep);
diff --git a/src/lib/sync/mutex.go b/src/lib/sync/mutex.go
index 68db0b697a..1269027e11 100644
--- a/src/lib/sync/mutex.go
+++ b/src/lib/sync/mutex.go
@@ -8,7 +8,7 @@ func cas(val *int32, old, new int32) bool
 func semacquire(*int32)
 func semrelease(*int32)
 
-export type Mutex struct {
+type Mutex struct {
 	key int32;
 	sema int32;
 }
diff --git a/src/lib/sync/mutex_test.go b/src/lib/sync/mutex_test.go
index b9c063dbc0..819dbb9de5 100644
--- a/src/lib/sync/mutex_test.go
+++ b/src/lib/sync/mutex_test.go
@@ -11,7 +11,7 @@ import (
 	"testing"
 )
 
-export func HammerSemaphore(s *int32, cdone chan bool) {
+func HammerSemaphore(s *int32, cdone chan bool) {
 	for i := 0; i < 1000; i++ {
 		semacquire(s);
 		semrelease(s);
@@ -19,7 +19,7 @@ export func HammerSemaphore(s *int32, cdone chan bool) {
 	cdone <- true;
 }
 
-export func TestSemaphore(t *testing.T) {
+func TestSemaphore(t *testing.T) {
 	s := new(int32);
 	*s = 1;
 	c := make(chan bool);
@@ -32,7 +32,7 @@ export func TestSemaphore(t *testing.T) {
 }
 
 
-export func HammerMutex(m *Mutex, cdone chan bool) {
+func HammerMutex(m *Mutex, cdone chan bool) {
 	for i := 0; i < 1000; i++ {
 		m.Lock();
 		m.Unlock();
@@ -40,7 +40,7 @@ export func HammerMutex(m *Mutex, cdone chan bool) {
 	cdone <- true;
 }
 
-export func TestMutex(t *testing.T) {
+func TestMutex(t *testing.T) {
 	m := new(Mutex);
 	c := make(chan bool);
 	for i := 0; i < 10; i++ {
diff --git a/src/lib/syscall/errstr_darwin.go b/src/lib/syscall/errstr_darwin.go
index 65f970b674..780ce71b13 100644
--- a/src/lib/syscall/errstr_darwin.go
+++ b/src/lib/syscall/errstr_darwin.go
@@ -4,7 +4,7 @@
 
 package syscall
 
-export const (
+const (
 	ENONE=0;
 	EPERM=1;
 	ENOENT=2;
@@ -234,7 +234,7 @@ func str(val int64) string {  // do it here rather than with fmt to avoid depend
 	return string(buf)[i:len(buf)];
 }
 
-export func Errstr(errno int64) string {
+func Errstr(errno int64) string {
 	if errno < 0 || errno >= len(error) {
 		return "Error " + str(errno)
 	}
diff --git a/src/lib/syscall/errstr_linux.go b/src/lib/syscall/errstr_linux.go
index df1f87e3ef..2a6a5b8138 100644
--- a/src/lib/syscall/errstr_linux.go
+++ b/src/lib/syscall/errstr_linux.go
@@ -4,7 +4,7 @@
 
 package syscall
 
-export const (
+const (
 	ENONE=0;
 	EPERM=1;
 	ENOENT=2;
@@ -284,7 +284,7 @@ func str(val int64) string {  // do it here rather than with fmt to avoid depend
 	return string(buf)[i:len(buf)];
 }
 
-export func Errstr(errno int64) string {
+func Errstr(errno int64) string {
 	if errno < 0 || errno >= len(error) {
 		return "Error " + str(errno)
 	}
diff --git a/src/lib/syscall/file_darwin.go b/src/lib/syscall/file_darwin.go
index f11618226a..f3e6c3163c 100644
--- a/src/lib/syscall/file_darwin.go
+++ b/src/lib/syscall/file_darwin.go
@@ -13,40 +13,40 @@ import (
 
 const nameBufsize = 512
 
-export func Open(name string, mode int64, perm int64) (ret int64, errno int64) {
+func Open(name string, mode int64, perm int64) (ret int64, errno int64) {
 	var namebuf [nameBufsize]byte;
 	if !StringToBytes(namebuf, name) {
 		return -1, ENAMETOOLONG
 	}
-	r1, r2, err := Syscall(SYS_OPEN, int64(uintptr(unsafe.pointer(&namebuf[0]))), mode, perm);
+	r1, r2, err := Syscall(SYS_OPEN, int64(uintptr(unsafe.Pointer(&namebuf[0]))), mode, perm);
 	return r1, err;
 }
 
-export func Creat(name string, perm int64) (ret int64, errno int64) {
+func Creat(name string, perm int64) (ret int64, errno int64) {
 	var namebuf [nameBufsize]byte;
 	if !StringToBytes(namebuf, name) {
 		return -1, ENAMETOOLONG
 	}
-	r1, r2, err := Syscall(SYS_OPEN, int64(uintptr(unsafe.pointer(&namebuf[0]))), O_CREAT|O_WRONLY|O_TRUNC, perm);
+	r1, r2, err := Syscall(SYS_OPEN, int64(uintptr(unsafe.Pointer(&namebuf[0]))), O_CREAT|O_WRONLY|O_TRUNC, perm);
 	return r1, err;
 }
 
-export func Close(fd int64) (ret int64, errno int64) {
+func Close(fd int64) (ret int64, errno int64) {
 	r1, r2, err := Syscall(SYS_CLOSE, fd, 0, 0);
 	return r1, err;
 }
 
-export func Read(fd int64, buf *byte, nbytes int64) (ret int64, errno int64) {
-	r1, r2, err := Syscall(SYS_READ, fd, int64(uintptr(unsafe.pointer(buf))), nbytes);
+func Read(fd int64, buf *byte, nbytes int64) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_READ, fd, int64(uintptr(unsafe.Pointer(buf))), nbytes);
 	return r1, err;
 }
 
-export func Write(fd int64, buf *byte, nbytes int64) (ret int64, errno int64) {
-	r1, r2, err := Syscall(SYS_WRITE, fd, int64(uintptr(unsafe.pointer(buf))), nbytes);
+func Write(fd int64, buf *byte, nbytes int64) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_WRITE, fd, int64(uintptr(unsafe.Pointer(buf))), nbytes);
 	return r1, err;
 }
 
-export func Pipe(fds *[2]int64) (ret int64, errno int64) {
+func Pipe(fds *[2]int64) (ret int64, errno int64) {
 	r1, r2, err := Syscall(SYS_PIPE, 0, 0, 0);
 	if r1 < 0 {
 		return r1, err;
@@ -56,49 +56,49 @@ export func Pipe(fds *[2]int64) (ret int64, errno int64) {
 	return 0, 0;
 }
 
-export func Stat(name string, buf *Stat_t) (ret int64, errno int64) {
+func Stat(name string, buf *Stat_t) (ret int64, errno int64) {
 	var namebuf [nameBufsize]byte;
 	if !StringToBytes(namebuf, name) {
 		return -1, ENAMETOOLONG
 	}
-	r1, r2, err := Syscall(SYS_STAT64, int64(uintptr(unsafe.pointer(&namebuf[0]))), int64(uintptr(unsafe.pointer(buf))), 0);
+	r1, r2, err := Syscall(SYS_STAT64, int64(uintptr(unsafe.Pointer(&namebuf[0]))), int64(uintptr(unsafe.Pointer(buf))), 0);
 	return r1, err;
 }
 
-export func Lstat(name *byte, buf *Stat_t) (ret int64, errno int64) {
-	r1, r2, err := Syscall(SYS_LSTAT, int64(uintptr(unsafe.pointer(name))), int64(uintptr(unsafe.pointer(buf))), 0);
+func Lstat(name *byte, buf *Stat_t) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_LSTAT, int64(uintptr(unsafe.Pointer(name))), int64(uintptr(unsafe.Pointer(buf))), 0);
 	return r1, err;
 }
 
-export func Fstat(fd int64, buf *Stat_t) (ret int64, errno int64) {
-	r1, r2, err := Syscall(SYS_FSTAT, fd, int64(uintptr(unsafe.pointer(buf))), 0);
+func Fstat(fd int64, buf *Stat_t) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_FSTAT, fd, int64(uintptr(unsafe.Pointer(buf))), 0);
 	return r1, err;
 }
 
-export func Unlink(name string) (ret int64, errno int64) {
+func Unlink(name string) (ret int64, errno int64) {
 	var namebuf [nameBufsize]byte;
 	if !StringToBytes(namebuf, name) {
 		return -1, ENAMETOOLONG
 	}
-	r1, r2, err := Syscall(SYS_UNLINK, int64(uintptr(unsafe.pointer(&namebuf[0]))), 0, 0);
+	r1, r2, err := Syscall(SYS_UNLINK, int64(uintptr(unsafe.Pointer(&namebuf[0]))), 0, 0);
 	return r1, err;
 }
 
-export func Fcntl(fd, cmd, arg int64) (ret int64, errno int64) {
+func Fcntl(fd, cmd, arg int64) (ret int64, errno int64) {
 	r1, r2, err := Syscall(SYS_FCNTL, fd, cmd, arg);
 	return r1, err
 }
 
-export func Mkdir(name string, perm int64) (ret int64, errno int64) {
+func Mkdir(name string, perm int64) (ret int64, errno int64) {
 	var namebuf [nameBufsize]byte;
 	if !StringToBytes(namebuf, name) {
 		return -1, ENAMETOOLONG
 	}
-	r1, r2, err := Syscall(SYS_MKDIR, int64(uintptr(unsafe.pointer(&namebuf[0]))), perm, 0);
+	r1, r2, err := Syscall(SYS_MKDIR, int64(uintptr(unsafe.Pointer(&namebuf[0]))), perm, 0);
 	return r1, err;
 }
 
-export func Dup2(fd1, fd2 int64) (ret int64, errno int64) {
+func Dup2(fd1, fd2 int64) (ret int64, errno int64) {
 	r1, r2, err := Syscall(SYS_DUP2, fd1, fd2, 0);
 	return r1, err;
 }
diff --git a/src/lib/syscall/file_linux.go b/src/lib/syscall/file_linux.go
index f048c1b712..ef30faac99 100644
--- a/src/lib/syscall/file_linux.go
+++ b/src/lib/syscall/file_linux.go
@@ -13,42 +13,42 @@ import (
 
 const nameBufsize = 512
 
-export func Open(name string, mode int64, perm int64) (ret int64, errno int64) {
+func Open(name string, mode int64, perm int64) (ret int64, errno int64) {
 	var namebuf [nameBufsize]byte;
 	if !StringToBytes(namebuf, name) {
 		return -1, ENAMETOOLONG
 	}
-	r1, r2, err := Syscall(SYS_OPEN, int64(uintptr(unsafe.pointer(&namebuf[0]))), mode, perm);
+	r1, r2, err := Syscall(SYS_OPEN, int64(uintptr(unsafe.Pointer(&namebuf[0]))), mode, perm);
 	return r1, err;
 }
 
-export func Creat(name string, perm int64) (ret int64, errno int64) {
+func Creat(name string, perm int64) (ret int64, errno int64) {
 	var namebuf [nameBufsize]byte;
 	if !StringToBytes(namebuf, name) {
 		return -1, ENAMETOOLONG
 	}
-	r1, r2, err := Syscall(SYS_OPEN, int64(uintptr(unsafe.pointer(&namebuf[0]))),  O_CREAT|O_WRONLY|O_TRUNC, perm);
+	r1, r2, err := Syscall(SYS_OPEN, int64(uintptr(unsafe.Pointer(&namebuf[0]))),  O_CREAT|O_WRONLY|O_TRUNC, perm);
 	return r1, err;
 }
 
-export func Close(fd int64) (ret int64, errno int64) {
+func Close(fd int64) (ret int64, errno int64) {
 	r1, r2, err := Syscall(SYS_CLOSE, fd, 0, 0);
 	return r1, err;
 }
 
-export func Read(fd int64, buf *byte, nbytes int64) (ret int64, errno int64) {
-	r1, r2, err := Syscall(SYS_READ, fd, int64(uintptr(unsafe.pointer(buf))), nbytes);
+func Read(fd int64, buf *byte, nbytes int64) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_READ, fd, int64(uintptr(unsafe.Pointer(buf))), nbytes);
 	return r1, err;
 }
 
-export func Write(fd int64, buf *byte, nbytes int64) (ret int64, errno int64) {
-	r1, r2, err := Syscall(SYS_WRITE, fd, int64(uintptr(unsafe.pointer(buf))), nbytes);
+func Write(fd int64, buf *byte, nbytes int64) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_WRITE, fd, int64(uintptr(unsafe.Pointer(buf))), nbytes);
 	return r1, err;
 }
 
-export func Pipe(fds *[2]int64) (ret int64, errno int64) {
+func Pipe(fds *[2]int64) (ret int64, errno int64) {
 	var t [2] int32;
-	r1, r2, err := Syscall(SYS_PIPE, int64(uintptr(unsafe.pointer(&t[0]))), 0, 0);
+	r1, r2, err := Syscall(SYS_PIPE, int64(uintptr(unsafe.Pointer(&t[0]))), 0, 0);
 	if r1 < 0 {
 		return r1, err;
 	}
@@ -57,49 +57,49 @@ export func Pipe(fds *[2]int64) (ret int64, errno int64) {
 	return 0, 0;
 }
 
-export func Stat(name string, buf *Stat_t) (ret int64, errno int64) {
+func Stat(name string, buf *Stat_t) (ret int64, errno int64) {
 	var namebuf [nameBufsize]byte;
 	if !StringToBytes(namebuf, name) {
 		return -1, ENAMETOOLONG
 	}
-	r1, r2, err := Syscall(SYS_STAT, int64(uintptr(unsafe.pointer(&namebuf[0]))), int64(uintptr(unsafe.pointer(buf))), 0);
+	r1, r2, err := Syscall(SYS_STAT, int64(uintptr(unsafe.Pointer(&namebuf[0]))), int64(uintptr(unsafe.Pointer(buf))), 0);
 	return r1, err;
 }
 
-export func Lstat(name *byte, buf *Stat_t) (ret int64, errno int64) {
-	r1, r2, err := Syscall(SYS_LSTAT, int64(uintptr(unsafe.pointer(name))), int64(uintptr(unsafe.pointer(buf))), 0);
+func Lstat(name *byte, buf *Stat_t) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_LSTAT, int64(uintptr(unsafe.Pointer(name))), int64(uintptr(unsafe.Pointer(buf))), 0);
 	return r1, err;
 }
 
-export func Fstat(fd int64, buf *Stat_t) (ret int64, errno int64) {
-	r1, r2, err := Syscall(SYS_FSTAT, fd, int64(uintptr(unsafe.pointer(buf))), 0);
+func Fstat(fd int64, buf *Stat_t) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_FSTAT, fd, int64(uintptr(unsafe.Pointer(buf))), 0);
 	return r1, err;
 }
 
-export func Unlink(name string) (ret int64, errno int64) {
+func Unlink(name string) (ret int64, errno int64) {
 	var namebuf [nameBufsize]byte;
 	if !StringToBytes(namebuf, name) {
 		return -1, ENAMETOOLONG
 	}
-	r1, r2, err := Syscall(SYS_UNLINK, int64(uintptr(unsafe.pointer(&namebuf[0]))), 0, 0);
+	r1, r2, err := Syscall(SYS_UNLINK, int64(uintptr(unsafe.Pointer(&namebuf[0]))), 0, 0);
 	return r1, err;
 }
 
-export func Fcntl(fd, cmd, arg int64) (ret int64, errno int64) {
+func Fcntl(fd, cmd, arg int64) (ret int64, errno int64) {
 	r1, r2, err := Syscall(SYS_FCNTL, fd, cmd, arg);
 	return r1, err
 }
 
-export func Mkdir(name string, perm int64) (ret int64, errno int64) {
+func Mkdir(name string, perm int64) (ret int64, errno int64) {
 	var namebuf [nameBufsize]byte;
 	if !StringToBytes(namebuf, name) {
 		return -1, ENAMETOOLONG
 	}
-	r1, r2, err := Syscall(SYS_MKDIR, int64(uintptr(unsafe.pointer(&namebuf[0]))), perm, 0);
+	r1, r2, err := Syscall(SYS_MKDIR, int64(uintptr(unsafe.Pointer(&namebuf[0]))), perm, 0);
 	return r1, err;
 }
 
-export func Dup2(fd1, fd2 int64) (ret int64, errno int64) {
+func Dup2(fd1, fd2 int64) (ret int64, errno int64) {
 	r1, r2, err := Syscall(SYS_DUP2, fd1, fd2, 0);
 	return r1, err;
 }
diff --git a/src/lib/syscall/signal_amd64_darwin.go b/src/lib/syscall/signal_amd64_darwin.go
index 892255eea8..3d96b3fdc3 100644
--- a/src/lib/syscall/signal_amd64_darwin.go
+++ b/src/lib/syscall/signal_amd64_darwin.go
@@ -7,7 +7,7 @@
 
 package syscall
 
-export const(
+const(
 	SIGHUP = 1;
 	SIGINT = 2;
 	SIGQUIT = 3;
diff --git a/src/lib/syscall/signal_amd64_linux.go b/src/lib/syscall/signal_amd64_linux.go
index af55028dcf..500666a8f3 100644
--- a/src/lib/syscall/signal_amd64_linux.go
+++ b/src/lib/syscall/signal_amd64_linux.go
@@ -7,7 +7,7 @@
 
 package syscall
 
-export const(
+const(
 	SIGHUP = 1;
 	SIGINT = 2;
 	SIGQUIT = 3;
diff --git a/src/lib/syscall/socket_darwin.go b/src/lib/syscall/socket_darwin.go
index c4323a6ba5..a0567e5c3a 100644
--- a/src/lib/syscall/socket_darwin.go
+++ b/src/lib/syscall/socket_darwin.go
@@ -12,38 +12,38 @@ import (
 	"unsafe";
 )
 
-export func SockaddrToSockaddrInet4(s *Sockaddr) *SockaddrInet4;
-export func SockaddrToSockaddrInet6(s *Sockaddr) *SockaddrInet6;
-export func SockaddrInet4ToSockaddr(s *SockaddrInet4) *Sockaddr;
-export func SockaddrInet6ToSockaddr(s *SockaddrInet6) *Sockaddr;
+func SockaddrToSockaddrInet4(s *Sockaddr) *SockaddrInet4;
+func SockaddrToSockaddrInet6(s *Sockaddr) *SockaddrInet6;
+func SockaddrInet4ToSockaddr(s *SockaddrInet4) *Sockaddr;
+func SockaddrInet6ToSockaddr(s *SockaddrInet6) *Sockaddr;
 
-export func Socket(domain, proto, typ int64) (ret int64, err int64) {
+func Socket(domain, proto, typ int64) (ret int64, err int64) {
 	r1, r2, e := Syscall(SYS_SOCKET, domain, proto, typ);
 	return r1, e
 }
 
-export func Connect(fd int64, sa *Sockaddr) (ret int64, err int64) {
-	r1, r2, e := Syscall(SYS_CONNECT, fd, int64(uintptr(unsafe.pointer(sa))), int64(sa.Len));
+func Connect(fd int64, sa *Sockaddr) (ret int64, err int64) {
+	r1, r2, e := Syscall(SYS_CONNECT, fd, int64(uintptr(unsafe.Pointer(sa))), int64(sa.Len));
 	return r1, e
 }
 
-export func Bind(fd int64, sa *Sockaddr) (ret int64, err int64) {
-	r1, r2, e := Syscall(SYS_BIND, fd, int64(uintptr(unsafe.pointer(sa))), int64(sa.Len));
+func Bind(fd int64, sa *Sockaddr) (ret int64, err int64) {
+	r1, r2, e := Syscall(SYS_BIND, fd, int64(uintptr(unsafe.Pointer(sa))), int64(sa.Len));
 	return r1, e
 }
 
-export func Listen(fd, n int64) (ret int64, err int64) {
+func Listen(fd, n int64) (ret int64, err int64) {
 	r1, r2, e := Syscall(SYS_LISTEN, fd, n, 0);
 	return r1, e
 }
 
-export func Accept(fd int64, sa *Sockaddr) (ret int64, err int64) {
+func Accept(fd int64, sa *Sockaddr) (ret int64, err int64) {
 	var n int32 = SizeofSockaddr;
-	r1, r2, e := Syscall(SYS_ACCEPT, fd, int64(uintptr(unsafe.pointer(sa))), int64(uintptr(unsafe.pointer(&n))));
+	r1, r2, e := Syscall(SYS_ACCEPT, fd, int64(uintptr(unsafe.Pointer(sa))), int64(uintptr(unsafe.Pointer(&n))));
 	return r1, e
 }
 
-export func Setsockopt(fd, level, opt, valueptr, length int64) (ret int64, err int64) {
+func Setsockopt(fd, level, opt, valueptr, length int64) (ret int64, err int64) {
 	if fd < 0 {
 		return -1, EINVAL
 	}
@@ -51,22 +51,22 @@ export func Setsockopt(fd, level, opt, valueptr, length int64) (ret int64, err i
 	return r1, e
 }
 
-export func Setsockopt_int(fd, level, opt int64, value int) int64 {
+func Setsockopt_int(fd, level, opt int64, value int) int64 {
 	var n int32 = int32(opt);
-	r1, e := Setsockopt(fd, level, opt, int64(uintptr(unsafe.pointer(&n))), 4);
+	r1, e := Setsockopt(fd, level, opt, int64(uintptr(unsafe.Pointer(&n))), 4);
 	return e
 }
 
-export func Setsockopt_tv(fd, level, opt, nsec int64) int64 {
+func Setsockopt_tv(fd, level, opt, nsec int64) int64 {
 	var tv Timeval;
 	nsec += 999;
 	tv.Sec = int64(nsec/1000000000);
 	tv.Usec = uint32(nsec%1000000000);
-	r1, e := Setsockopt(fd, level, opt, int64(uintptr(unsafe.pointer(&tv))), 4);
+	r1, e := Setsockopt(fd, level, opt, int64(uintptr(unsafe.Pointer(&tv))), 4);
 	return e
 }
 
-export func Setsockopt_linger(fd, level, opt int64, sec int) int64 {
+func Setsockopt_linger(fd, level, opt int64, sec int) int64 {
 	var l Linger;
 	if sec != 0 {
 		l.Yes = 1;
@@ -75,38 +75,38 @@ export func Setsockopt_linger(fd, level, opt int64, sec int) int64 {
 		l.Yes = 0;
 		l.Sec = 0;
 	}
-	r1, err := Setsockopt(fd, level, opt, int64(uintptr(unsafe.pointer(&l))), 8);
+	r1, err := Setsockopt(fd, level, opt, int64(uintptr(unsafe.Pointer(&l))), 8);
 	return err
 }
 
 /*
-export func Getsockopt(fd, level, opt, valueptr, lenptr int64) (ret int64, errno int64) {
+func Getsockopt(fd, level, opt, valueptr, lenptr int64) (ret int64, errno int64) {
 	r1, r2, err := Syscall6(SYS_GETSOCKOPT, fd, level, opt, valueptr, lenptr, 0);
 	return r1, err;
 }
 */
 
-export func Kqueue() (ret int64, errno int64) {
+func Kqueue() (ret int64, errno int64) {
 	r1, r2, err := Syscall(SYS_KQUEUE, 0, 0, 0);
 	return r1, err
 }
 
-export func Kevent(kq int64, changes, events []Kevent_t, timeout *Timespec) (ret int64, errno int64) {
+func Kevent(kq int64, changes, events []Kevent_t, timeout *Timespec) (ret int64, errno int64) {
 	var nchange, changeptr, nevent, eventptr int64;
 	nchange = 0;
 	changeptr = 0;
 	nevent = 0;
 	eventptr = 0;
 	if len(changes) > 0 {
-		changeptr = int64(uintptr(unsafe.pointer(&changes[0])));
+		changeptr = int64(uintptr(unsafe.Pointer(&changes[0])));
 		nchange = int64(len(changes))
 	}
 	if len(events) > 0 {
-		eventptr = int64(uintptr(unsafe.pointer(&events[0])));
+		eventptr = int64(uintptr(unsafe.Pointer(&events[0])));
 		nevent = int64(len(events))
 	}
 	r1, r2, err := Syscall6(SYS_KEVENT, kq, changeptr, nchange,
-		eventptr, nevent, int64(uintptr(unsafe.pointer(timeout))));
+		eventptr, nevent, int64(uintptr(unsafe.Pointer(timeout))));
 	return r1, err
 }
 
diff --git a/src/lib/syscall/socket_linux.go b/src/lib/syscall/socket_linux.go
index 458e363f68..a061577847 100644
--- a/src/lib/syscall/socket_linux.go
+++ b/src/lib/syscall/socket_linux.go
@@ -12,10 +12,10 @@ import (
 	"unsafe";
 )
 
-export func SockaddrToSockaddrInet4(s *Sockaddr) *SockaddrInet4;
-export func SockaddrToSockaddrInet6(s *Sockaddr) *SockaddrInet6;
-export func SockaddrInet4ToSockaddr(s *SockaddrInet4) *Sockaddr;
-export func SockaddrInet6ToSockaddr(s *SockaddrInet6) *Sockaddr;
+func SockaddrToSockaddrInet4(s *Sockaddr) *SockaddrInet4;
+func SockaddrToSockaddrInet6(s *Sockaddr) *SockaddrInet6;
+func SockaddrInet4ToSockaddr(s *SockaddrInet4) *Sockaddr;
+func SockaddrInet6ToSockaddr(s *SockaddrInet6) *Sockaddr;
 
 func saLen(s *Sockaddr) int64 {
 	switch s.Family {
@@ -29,33 +29,33 @@ func saLen(s *Sockaddr) int64 {
 	return 0
 }
 
-export func Socket(domain, proto, typ int64) (ret int64, err int64) {
+func Socket(domain, proto, typ int64) (ret int64, err int64) {
 	r1, r2, e := Syscall(SYS_SOCKET, domain, proto, typ);
 	return r1, e
 }
 
-export func Connect(fd int64, sa *Sockaddr) (ret int64, err int64) {
-	r1, r2, e := Syscall(SYS_CONNECT, fd, int64(uintptr(unsafe.pointer(sa))), saLen(sa));
+func Connect(fd int64, sa *Sockaddr) (ret int64, err int64) {
+	r1, r2, e := Syscall(SYS_CONNECT, fd, int64(uintptr(unsafe.Pointer(sa))), saLen(sa));
 	return r1, e
 }
 
-export func Bind(fd int64, sa *Sockaddr) (ret int64, err int64) {
-	r1, r2, e := Syscall(SYS_BIND, fd, int64(uintptr(unsafe.pointer(sa))), saLen(sa));
+func Bind(fd int64, sa *Sockaddr) (ret int64, err int64) {
+	r1, r2, e := Syscall(SYS_BIND, fd, int64(uintptr(unsafe.Pointer(sa))), saLen(sa));
 	return r1, e
 }
 
-export func Listen(fd, n int64) (ret int64, err int64) {
+func Listen(fd, n int64) (ret int64, err int64) {
 	r1, r2, e := Syscall(SYS_LISTEN, fd, n, 0);
 	return r1, e
 }
 
-export func Accept(fd int64, sa *Sockaddr) (ret int64, err int64) {
+func Accept(fd int64, sa *Sockaddr) (ret int64, err int64) {
 	var n int32 = SizeofSockaddr;
-	r1, r2, e := Syscall(SYS_ACCEPT, fd, int64(uintptr(unsafe.pointer(sa))), int64(uintptr(unsafe.pointer(&n))));
+	r1, r2, e := Syscall(SYS_ACCEPT, fd, int64(uintptr(unsafe.Pointer(sa))), int64(uintptr(unsafe.Pointer(&n))));
 	return r1, e
 }
 
-export func Setsockopt(fd, level, opt, valueptr, length int64) (ret int64, err int64) {
+func Setsockopt(fd, level, opt, valueptr, length int64) (ret int64, err int64) {
 	if fd < 0 {
 		return -1, EINVAL
 	}
@@ -63,22 +63,22 @@ export func Setsockopt(fd, level, opt, valueptr, length int64) (ret int64, err i
 	return r1, e
 }
 
-export func Setsockopt_int(fd, level, opt int64, value int) int64 {
+func Setsockopt_int(fd, level, opt int64, value int) int64 {
 	n := int32(opt);
-	r1, e := Setsockopt(fd, level, opt, int64(uintptr(unsafe.pointer(&n))), 4);
+	r1, e := Setsockopt(fd, level, opt, int64(uintptr(unsafe.Pointer(&n))), 4);
 	return e
 }
 
-export func Setsockopt_tv(fd, level, opt, nsec int64) int64 {
+func Setsockopt_tv(fd, level, opt, nsec int64) int64 {
 	var tv Timeval;
 	nsec += 999;
 	tv.Sec = int64(nsec/1000000000);
 	tv.Usec = uint64(nsec%1000000000);
-	r1, e := Setsockopt(fd, level, opt, int64(uintptr(unsafe.pointer(&tv))), 4);
+	r1, e := Setsockopt(fd, level, opt, int64(uintptr(unsafe.Pointer(&tv))), 4);
 	return e
 }
 
-export func Setsockopt_linger(fd, level, opt int64, sec int) int64 {
+func Setsockopt_linger(fd, level, opt int64, sec int) int64 {
 	var l Linger;
 	if sec != 0 {
 		l.Yes = 1;
@@ -87,32 +87,32 @@ export func Setsockopt_linger(fd, level, opt int64, sec int) int64 {
 		l.Yes = 0;
 		l.Sec = 0
 	}
-	r1, err := Setsockopt(fd, level, opt, int64(uintptr(unsafe.pointer(&l))), 8);
+	r1, err := Setsockopt(fd, level, opt, int64(uintptr(unsafe.Pointer(&l))), 8);
 	return err
 }
 
 /*
-export func getsockopt(fd, level, opt, valueptr, lenptr int64) (ret int64, errno int64) {
+func getsockopt(fd, level, opt, valueptr, lenptr int64) (ret int64, errno int64) {
 	r1, r2, err := Syscall6(GETSOCKOPT, fd, level, opt, valueptr, lenptr, 0);
 	return r1, err;
 }
 */
 
-export func Epoll_create(size int64) (ret int64, errno int64) {
+func Epoll_create(size int64) (ret int64, errno int64) {
 	r1, r2, err := syscall.Syscall(SYS_EPOLL_CREATE, size, 0, 0);
 	return r1, err
 }
 
-export func Epoll_ctl(epfd, op, fd int64, ev *EpollEvent) int64 {
-	r1, r2, err := syscall.Syscall6(SYS_EPOLL_CTL, epfd, op, fd, int64(uintptr(unsafe.pointer(ev))), 0, 0);
+func Epoll_ctl(epfd, op, fd int64, ev *EpollEvent) int64 {
+	r1, r2, err := syscall.Syscall6(SYS_EPOLL_CTL, epfd, op, fd, int64(uintptr(unsafe.Pointer(ev))), 0, 0);
 	return err
 }
 
-export func Epoll_wait(epfd int64, ev []EpollEvent, msec int64) (ret int64, err int64) {
+func Epoll_wait(epfd int64, ev []EpollEvent, msec int64) (ret int64, err int64) {
 	var evptr, nev int64;
 	if ev != nil && len(ev) > 0 {
 		nev = int64(len(ev));
-		evptr = int64(uintptr(unsafe.pointer(&ev[0])))
+		evptr = int64(uintptr(unsafe.Pointer(&ev[0])))
 	}
 	r1, r2, err1 := syscall.Syscall6(SYS_EPOLL_WAIT, epfd, evptr, nev, msec, 0, 0);
 	return r1, err1
diff --git a/src/lib/syscall/syscall.go b/src/lib/syscall/syscall.go
index 9cef40d252..780f0f2620 100644
--- a/src/lib/syscall/syscall.go
+++ b/src/lib/syscall/syscall.go
@@ -8,15 +8,15 @@ package syscall
  * Foundation of system call interface.
  */
 
-export func Syscall(trap int64, a1, a2, a3 int64) (r1, r2, err int64);
-export func Syscall6(trap int64, a1, a2, a3, a4, a5, a6 int64) (r1, r2, err int64);
-export func RawSyscall(trap int64, a1, a2, a3 int64) (r1, r2, err int64);
+func Syscall(trap int64, a1, a2, a3 int64) (r1, r2, err int64);
+func Syscall6(trap int64, a1, a2, a3, a4, a5, a6 int64) (r1, r2, err int64);
+func RawSyscall(trap int64, a1, a2, a3 int64) (r1, r2, err int64);
 
 /*
  * Used to convert file names to byte arrays for passing to kernel,
  * but useful elsewhere too.
  */
-export func StringToBytes(b []byte, s string) bool {
+func StringToBytes(b []byte, s string) bool {
 	if len(s) >= len(b) {
 		return false
 	}
diff --git a/src/lib/syscall/syscall_amd64_darwin.go b/src/lib/syscall/syscall_amd64_darwin.go
index c3f72d857f..b378f56e0b 100644
--- a/src/lib/syscall/syscall_amd64_darwin.go
+++ b/src/lib/syscall/syscall_amd64_darwin.go
@@ -7,7 +7,7 @@
 
 package syscall
 
-export const (
+const (
 	// SYS_NOSYS = 0;  // { int nosys(void); }   { indirect syscall }
 	SYS_EXIT = 1;  // { void exit(int rval); }
 	SYS_FORK = 2;  // { int fork(void); }
diff --git a/src/lib/syscall/syscall_amd64_linux.go b/src/lib/syscall/syscall_amd64_linux.go
index 1e1f498dd4..cd75cb53cf 100644
--- a/src/lib/syscall/syscall_amd64_linux.go
+++ b/src/lib/syscall/syscall_amd64_linux.go
@@ -7,7 +7,7 @@
 
 package syscall
 
-export const(
+const(
 	SYS_READ = 0;
 	SYS_WRITE = 1;
 	SYS_OPEN = 2;
diff --git a/src/lib/syscall/time_amd64_darwin.go b/src/lib/syscall/time_amd64_darwin.go
index 4e55c8ddd6..8253171cac 100644
--- a/src/lib/syscall/time_amd64_darwin.go
+++ b/src/lib/syscall/time_amd64_darwin.go
@@ -6,7 +6,7 @@ package syscall
 
 import syscall "syscall"
 
-export func Gettimeofday() (sec, nsec, errno int64) {
+func Gettimeofday() (sec, nsec, errno int64) {
 	// The "1" in the call is the timeval pointer, which must be
 	// non-zero but is otherwise unused.  The results
 	// are returned in r1, r2.
@@ -17,7 +17,7 @@ export func Gettimeofday() (sec, nsec, errno int64) {
 	return r1, r2*1000, 0
 }
 
-export func Nstotimeval(ns int64, tv *Timeval) {
+func Nstotimeval(ns int64, tv *Timeval) {
 	ns += 999;	// round up
 	tv.Sec = int64(ns/1000000000);
 	tv.Usec = uint32(ns%1000000000 / 1000);
diff --git a/src/lib/syscall/time_amd64_linux.go b/src/lib/syscall/time_amd64_linux.go
index 17e8851117..67fc51231b 100644
--- a/src/lib/syscall/time_amd64_linux.go
+++ b/src/lib/syscall/time_amd64_linux.go
@@ -9,16 +9,16 @@ import (
 	"unsafe";
 )
 
-export func Gettimeofday() (sec, nsec, errno int64) {
+func Gettimeofday() (sec, nsec, errno int64) {
 	var tv Timeval;
-	r1, r2, e := Syscall(SYS_GETTIMEOFDAY, int64(uintptr(unsafe.pointer(&tv))), 0, 0);
+	r1, r2, e := Syscall(SYS_GETTIMEOFDAY, int64(uintptr(unsafe.Pointer(&tv))), 0, 0);
 	if e != 0 {
 		return 0, 0, e
 	}
 	return int64(tv.Sec), int64(tv.Usec*1000), 0
 }
 
-export func Nstotimeval(ns int64, tv *Timeval) {
+func Nstotimeval(ns int64, tv *Timeval) {
 	ns += 999;	// round up
 	tv.Sec = int64(ns/1000000000);
 	tv.Usec = uint64(ns%1000000000 / 1000);
diff --git a/src/lib/syscall/types_amd64_darwin.go b/src/lib/syscall/types_amd64_darwin.go
index b5120197e5..963759bc67 100644
--- a/src/lib/syscall/types_amd64_darwin.go
+++ b/src/lib/syscall/types_amd64_darwin.go
@@ -10,12 +10,12 @@ package syscall
 
 // Time
 
-export type Timespec struct {
+type Timespec struct {
 	Sec	int64;
 	Nsec	uint64;
 }
 
-export type Timeval struct {
+type Timeval struct {
 	Sec	int64;
 	Usec	uint32;
 }
@@ -23,7 +23,7 @@ export type Timeval struct {
 
 // Processes
 
-export type Rusage struct {
+type Rusage struct {
 	Utime	Timeval;
 	Stime	Timeval;
 	Maxrss	int64;
@@ -45,7 +45,7 @@ export type Rusage struct {
 
 // Files
 
-export const (
+const (
 	O_RDONLY = 0x0;
 	O_WRONLY = 0x1;
 	O_RDWR = 0x2;
@@ -67,7 +67,7 @@ export const (
 	FD_CLOEXEC = 1;
 )
 
-export type Stat_t struct {
+type Stat_t struct {
 	Dev	uint32;
 	Mode	uint16;
 	Nlink	uint16;
@@ -92,7 +92,7 @@ export type Stat_t struct {
 
 // Sockets
 
-export const (
+const (
 	AF_UNIX = 1;
 	AF_INET = 2;
 	AF_DATAKIT = 9;
@@ -127,23 +127,23 @@ export const (
 	SOMAXCONN = 128;
 )
 
-export type SockaddrUnix struct {
+type SockaddrUnix struct {
 	Len	byte;
 	Family	byte;
 	Path	[104]byte
 }
-export const SizeofSockaddrUnix = 106
+const SizeofSockaddrUnix = 106
 
-export type SockaddrInet4 struct {
+type SockaddrInet4 struct {
 	Len	byte;
 	Family	byte;
 	Port	[2]byte;
 	Addr	[4]byte;
 	Zero	[8]byte
 }
-export const SizeofSockaddrInet4 = 16
+const SizeofSockaddrInet4 = 16
 
-export type SockaddrInet6 struct {
+type SockaddrInet6 struct {
 	Len	byte;
 	Family	byte;
 	Port	[2]byte;
@@ -151,16 +151,16 @@ export type SockaddrInet6 struct {
 	Addr	[16]byte;
 	Scopeid	[4]byte;
 }
-export const SizeofSockaddrInet6 = 28
+const SizeofSockaddrInet6 = 28
 
-export type Sockaddr struct {
+type Sockaddr struct {
 	Len	byte;
 	Family	byte;
 	Opaque	[126]byte
 }
-export const SizeofSockaddr = 128
+const SizeofSockaddr = 128
 
-export type Linger struct {
+type Linger struct {
 	Yes int32;
 	Sec int32;
 }
@@ -168,7 +168,7 @@ export type Linger struct {
 
 // Events (kqueue, kevent)
 
-export const (
+const (
 	// filters
 	EVFILT_READ = -1;
 	EVFILT_WRITE = -2;
@@ -201,7 +201,7 @@ export const (
 	EV_ERROR = 0x4000
 )
 
-export type Kevent_t struct {
+type Kevent_t struct {
 	Ident int64;
 	Filter int16;
 	Flags uint16;
diff --git a/src/lib/syscall/types_amd64_linux.go b/src/lib/syscall/types_amd64_linux.go
index 371f839ab6..2961a338a2 100644
--- a/src/lib/syscall/types_amd64_linux.go
+++ b/src/lib/syscall/types_amd64_linux.go
@@ -10,12 +10,12 @@ package syscall
 
 // Time
 
-export type Timespec struct {
+type Timespec struct {
 	Sec	int64;
 	Nsec	uint64;
 }
 
-export type Timeval struct {
+type Timeval struct {
 	Sec	int64;
 	Usec	uint64;
 }
@@ -23,7 +23,7 @@ export type Timeval struct {
 
 // Processes
 
-export type Rusage struct {
+type Rusage struct {
 	Utime	Timeval;
 	Stime	Timeval;
 	Maxrss	int64;
@@ -45,7 +45,7 @@ export type Rusage struct {
 
 // Files
 
-export const (
+const (
 	O_RDONLY = 0x0;
 	O_WRONLY = 0x1;
 	O_RDWR = 0x2;
@@ -67,7 +67,7 @@ export const (
 	FD_CLOEXEC = 1;
 )
 
-export type Stat_t struct {
+type Stat_t struct {
 	Dev	uint64;
 	Ino	uint64;
 	Nlink	uint64;
@@ -88,7 +88,7 @@ export type Stat_t struct {
 
 // Sockets
 
-export const (
+const (
 	AF_UNIX = 1;
 	AF_INET = 2;
 	AF_INET6 = 10;
@@ -133,36 +133,36 @@ export const (
 	SOMAXCONN = 128;
 )
 
-export type SockaddrUnix struct {
+type SockaddrUnix struct {
 	Family	uint16;
 	Path	[108]byte
 }
-export const SizeofSockaddrUnix = 110
+const SizeofSockaddrUnix = 110
 
-export type SockaddrInet4 struct {
+type SockaddrInet4 struct {
 	Family	uint16;
 	Port	[2]byte;
 	Addr	[4]byte;
 	Zero	[8]byte
 }
-export const SizeofSockaddrInet4 = 16
+const SizeofSockaddrInet4 = 16
 
-export type SockaddrInet6 struct {
+type SockaddrInet6 struct {
 	Family	uint16;
 	Port	[2]byte;
 	Flowinfo	[4]byte;
 	Addr	[16]byte;
 	Scopeid	[4]byte;
 }
-export const SizeofSockaddrInet6 = 28
+const SizeofSockaddrInet6 = 28
 
-export type Sockaddr struct {
+type Sockaddr struct {
 	Family	uint16;
 	Opaque	[126]byte
 }
-export const SizeofSockaddr = 128
+const SizeofSockaddr = 128
 
-export type Linger struct {
+type Linger struct {
 	Yes int32;
 	Sec int32;
 }
@@ -170,7 +170,7 @@ export type Linger struct {
 
 // Events (epoll)
 
-export const (
+const (
 	// EpollEvent.events
 	EPOLLIN = 0x1;
 	EPOLLOUT = 0x4;
@@ -186,7 +186,7 @@ export const (
 	EPOLL_CTL_DEL = 0x2;
 )
 
-export type EpollEvent struct {
+type EpollEvent struct {
 	Events uint32;
 	Fd int32;
 	Pad int32;
diff --git a/src/lib/tabwriter/tabwriter.go b/src/lib/tabwriter/tabwriter.go
index bfd552441f..9a3eeb9a2d 100644
--- a/src/lib/tabwriter/tabwriter.go
+++ b/src/lib/tabwriter/tabwriter.go
@@ -93,7 +93,7 @@ func (b *byteArray) append(s []byte) {
 // filter_html  ignores html tags and handles entities (starting with '&'
 //              and ending in ';') as single characters (width = 1)
 
-export type Writer struct {
+type Writer struct {
 	// TODO should not export any of the fields
 	// configuration
 	writer io.Write;
@@ -445,6 +445,6 @@ func (b *Writer) append(buf []byte) {
 }
 
 
-export func New(writer io.Write, cellwidth, padding int, padchar byte, align_left, filter_html bool) *Writer {
+func New(writer io.Write, cellwidth, padding int, padchar byte, align_left, filter_html bool) *Writer {
 	return new(Writer).Init(writer, cellwidth, padding, padchar, align_left, filter_html)
 }
diff --git a/src/lib/tabwriter/tabwriter_test.go b/src/lib/tabwriter/tabwriter_test.go
index 0647726112..d06c409f58 100644
--- a/src/lib/tabwriter/tabwriter_test.go
+++ b/src/lib/tabwriter/tabwriter_test.go
@@ -103,7 +103,7 @@ func check(t *testing.T, tabwidth, padding int, padchar byte, align_left, filter
 }
 
 
-export func Test(t *testing.T) {
+func Test(t *testing.T) {
 	check(
 		t, 8, 1, '.', true, false,
 		"",
diff --git a/src/lib/testing.go b/src/lib/testing.go
index 01924ef44a..1ab85839b3 100644
--- a/src/lib/testing.go
+++ b/src/lib/testing.go
@@ -21,7 +21,7 @@ func tabify(s string) string {
 	return s
 }
 
-export type T struct {
+type T struct {
 	errors	string;
 	failed	bool;
 	ch	chan *T;
@@ -69,7 +69,7 @@ func (t *T) Fatalf(format string, args ...) {
 	t.FailNow();
 }
 
-export type Test struct {
+type Test struct {
 	Name string;
 	F *(*T);
 }
@@ -79,7 +79,7 @@ func tRunner(t *T, test *Test) {
 	t.ch <- t;
 }
 
-export func Main(tests []Test) {
+func Main(tests []Test) {
 	flag.Parse();
 	ok := true;
 	if len(tests) == 0 {
diff --git a/src/lib/time/tick.go b/src/lib/time/tick.go
index f200f30dd1..814e2bac1f 100644
--- a/src/lib/time/tick.go
+++ b/src/lib/time/tick.go
@@ -43,13 +43,13 @@ func ticker(ns int64, c chan int64) {
 		}
 
 		syscall.Nstotimeval(when - now, &tv);
-		syscall.Syscall6(syscall.SYS_SELECT, 0, 0, 0, 0, int64(uintptr(unsafe.pointer(&tv))), 0);
+		syscall.Syscall6(syscall.SYS_SELECT, 0, 0, 0, 0, int64(uintptr(unsafe.Pointer(&tv))), 0);
 		now = time.Nanoseconds();
 		c <- now;
 	}
 }
 
-export func Tick(ns int64) chan int64 {
+func Tick(ns int64) chan int64 {
 	if ns <= 0 {
 		return nil
 	}
diff --git a/src/lib/time/tick_test.go b/src/lib/time/tick_test.go
index 79038dcf84..0667be679b 100644
--- a/src/lib/time/tick_test.go
+++ b/src/lib/time/tick_test.go
@@ -9,7 +9,7 @@ import (
 	"time";
 )
 
-export func TestTick(t *testing.T) {
+func TestTick(t *testing.T) {
 	const (
 		Delta = 100*1e6;
 		Count = 10;
diff --git a/src/lib/time/time.go b/src/lib/time/time.go
index 9421eeae5b..2af56f453b 100644
--- a/src/lib/time/time.go
+++ b/src/lib/time/time.go
@@ -10,7 +10,7 @@ import (
 )
 
 // Seconds since January 1, 1970 00:00:00 GMT
-export func Seconds() int64 {
+func Seconds() int64 {
 	sec, nsec, err := os.Time();
 	if err != nil {
 		panic("time: os.Time: ", err.String());
@@ -19,7 +19,7 @@ export func Seconds() int64 {
 }
 
 // Nanoseconds since January 1, 1970 00:00:00 GMT
-export func Nanoseconds() int64 {
+func Nanoseconds() int64 {
 	sec, nsec, err := os.Time();
 	if err != nil {
 		panic("time: os.Time: ", err.String());
@@ -27,7 +27,7 @@ export func Nanoseconds() int64 {
 	return sec*1e9 + nsec
 }
 
-export const (
+const (
 	Sunday = iota;
 	Monday;
 	Tuesday;
@@ -37,7 +37,7 @@ export const (
 	Saturday;
 )
 
-export type Time struct {
+type Time struct {
 	year int64;	// 2008 is 2008
 	month, day int;	// Sep-17 is 9, 17
 	hour, minute, second int;	// 10:43:12 is 10, 43, 12
@@ -70,7 +70,7 @@ const (
 	_Days1970To2001 = 31*365+8;
 )
 
-export func SecondsToUTC(sec int64) *Time {
+func SecondsToUTC(sec int64) *Time {
 	t := new(Time);
 
 	// Split into time and day.
@@ -143,12 +143,12 @@ export func SecondsToUTC(sec int64) *Time {
 	return t;
 }
 
-export func UTC() *Time {
+func UTC() *Time {
 	return SecondsToUTC(Seconds())
 }
 
 // TODO: Should this return an error?
-export func SecondsToLocalTime(sec int64) *Time {
+func SecondsToLocalTime(sec int64) *Time {
 	zone, offset, err := time.LookupTimezone(sec);
 	if err != nil {
 		return SecondsToUTC(sec)
@@ -159,7 +159,7 @@ export func SecondsToLocalTime(sec int64) *Time {
 	return t
 }
 
-export func LocalTime() *Time {
+func LocalTime() *Time {
 	return SecondsToLocalTime(Seconds())
 }
 
diff --git a/src/lib/time/time_test.go b/src/lib/time/time_test.go
index 61f0608add..feff13a480 100644
--- a/src/lib/time/time_test.go
+++ b/src/lib/time/time_test.go
@@ -41,7 +41,7 @@ func _Same(t, u *Time) bool {
 		&& t.zone == u.zone
 }
 
-export func TestSecondsToUTC(t *testing.T) {
+func TestSecondsToUTC(t *testing.T) {
 	for i := 0; i < len(utctests); i++ {
 		sec := utctests[i].seconds;
 		golden := &utctests[i].golden;
@@ -58,7 +58,7 @@ export func TestSecondsToUTC(t *testing.T) {
 	}
 }
 
-export func TestSecondsToLocalTime(t *testing.T) {
+func TestSecondsToLocalTime(t *testing.T) {
 	for i := 0; i < len(localtests); i++ {
 		sec := localtests[i].seconds;
 		golden := &localtests[i].golden;
diff --git a/src/lib/time/zoneinfo.go b/src/lib/time/zoneinfo.go
index 6f2a1f3154..e43547c5e9 100644
--- a/src/lib/time/zoneinfo.go
+++ b/src/lib/time/zoneinfo.go
@@ -20,7 +20,7 @@ const (
 	_HeaderSize = 4+16+4*7
 )
 
-export var (
+var (
 	BadZoneinfo = os.NewError("time: malformed zoneinfo");
 	NoZoneinfo = os.NewError("time: unknown time zone")
 )
@@ -250,7 +250,7 @@ func _SetupZone() {
 	zones, zoneerr = readinfofile("/etc/localtime");
 }
 
-export func LookupTimezone(sec int64) (zone string, offset int, err *os.Error) {
+func LookupTimezone(sec int64) (zone string, offset int, err *os.Error) {
 	once.Do(&_SetupZone);
 	if zoneerr != nil || len(zones) == 0 {
 		return "GMT", 0, zoneerr
diff --git a/src/lib/unicode/letter.go b/src/lib/unicode/letter.go
index 6846e3ec27..3b1221b87b 100644
--- a/src/lib/unicode/letter.go
+++ b/src/lib/unicode/letter.go
@@ -12,13 +12,13 @@
 
 package unicode
 
-export type Range struct {
+type Range struct {
 	lo int;
 	hi int;
 	stride int;
 }
 
-export var Upper = []Range{
+var Upper = []Range{
 	Range{0x0041, 0x005a, 1},
 	Range{0x00c0, 0x00d6, 1},
 	Range{0x00d8, 0x00de, 1},
@@ -150,7 +150,7 @@ export var Upper = []Range{
 	Range{0x1d7ca, 0x1d7ca, 1},
 }
 
-export var Letter = []Range {
+var Letter = []Range {
 	Range{0x0041, 0x005a, 1},
 	Range{0x0061, 0x007a, 1},
 	Range{0x00aa, 0x00b5, 11},
@@ -525,7 +525,7 @@ export var Letter = []Range {
 	Range{0x2f800, 0x2fa1d, 1},
 }
 
-export func Is(ranges []Range, rune int) bool {
+func Is(ranges []Range, rune int) bool {
 	// common case: rune is ASCII or Latin-1
 	if rune < 0x100 {
 		for i := 0; i < len(ranges); i++ {
@@ -559,11 +559,11 @@ export func Is(ranges []Range, rune int) bool {
 	return false;
 }
 
-export func IsUpper(rune int) bool {
+func IsUpper(rune int) bool {
 	return Is(Upper, rune);
 }
 
-export func IsLetter(rune int) bool {
+func IsLetter(rune int) bool {
 	return Is(Letter, rune);
 }
 
diff --git a/src/lib/unicode/letter_test.go b/src/lib/unicode/letter_test.go
index 42f5df42ae..d39d74e6b9 100644
--- a/src/lib/unicode/letter_test.go
+++ b/src/lib/unicode/letter_test.go
@@ -92,7 +92,7 @@ var notletter = []int{
 	0x10ffff,
 }
 
-export func TestIsLetter(t *testing.T) {
+func TestIsLetter(t *testing.T) {
 	for i, r := range(upper) {
 		if !IsLetter(r) {
 			t.Errorf("IsLetter(%#x) = false, want true\n", r);
@@ -110,7 +110,7 @@ export func TestIsLetter(t *testing.T) {
 	}
 }
 
-export func TestIsUpper(t *testing.T) {
+func TestIsUpper(t *testing.T) {
 	for i, r := range(upper) {
 		if !IsUpper(r) {
 			t.Errorf("IsUpper(%#x) = false, want true\n", r);
diff --git a/src/lib/utf8.go b/src/lib/utf8.go
index a81988917c..aada1c4174 100644
--- a/src/lib/utf8.go
+++ b/src/lib/utf8.go
@@ -6,7 +6,7 @@
 
 package utf8
 
-export const (
+const (
 	RuneError = 0xFFFD;
 	RuneSelf = 0x80;
 	RuneMax = 0x10FFFF;
@@ -181,29 +181,29 @@ func decodeRuneInStringInternal(s string, i int, n int) (rune, size int, short b
 	return RuneError, 1, false
 }
 
-export func FullRune(p []byte) bool {
+func FullRune(p []byte) bool {
 	rune, size, short := decodeRuneInternal(p);
 	return !short
 }
 
-export func FullRuneInString(s string, i int) bool {
+func FullRuneInString(s string, i int) bool {
 	rune, size, short := decodeRuneInStringInternal(s, i, len(s) - i);
 	return !short
 }
 
-export func DecodeRune(p []byte) (rune, size int) {
+func DecodeRune(p []byte) (rune, size int) {
 	var short bool;
 	rune, size, short = decodeRuneInternal(p);
 	return;
 }
 
-export func DecodeRuneInString(s string, i int) (rune, size int) {
+func DecodeRuneInString(s string, i int) (rune, size int) {
 	var short bool;
 	rune, size, short = decodeRuneInStringInternal(s, i, len(s) - i);
 	return;
 }
 
-export func RuneLen(rune int) int {
+func RuneLen(rune int) int {
 	switch {
 	case rune <= _Rune1Max:
 		return 1;
@@ -217,7 +217,7 @@ export func RuneLen(rune int) int {
 	return -1;
 }
 
-export func EncodeRune(rune int, p []byte) int {
+func EncodeRune(rune int, p []byte) int {
 	if rune <= _Rune1Max {
 		p[0] = byte(rune);
 		return 1;
@@ -247,7 +247,7 @@ export func EncodeRune(rune int, p []byte) int {
 	return 4;
 }
 
-export func RuneCount(p []byte) int {
+func RuneCount(p []byte) int {
 	i := 0;
 	var n int;
 	for n = 0; i < len(p); n++ {
@@ -261,7 +261,7 @@ export func RuneCount(p []byte) int {
 	return n;
 }
 
-export func RuneCountInString(s string, i int, l int) int {
+func RuneCountInString(s string, i int, l int) int {
 	ei := i + l;
 	n := 0;
 	for n = 0; i < ei; n++ {
diff --git a/src/lib/utf8_test.go b/src/lib/utf8_test.go
index 0456649fda..2cb15889ef 100644
--- a/src/lib/utf8_test.go
+++ b/src/lib/utf8_test.go
@@ -11,7 +11,7 @@ import (
 	"utf8";
 )
 
-export type Utf8Map struct {
+type Utf8Map struct {
 	rune int;
 	str string;
 }
@@ -53,7 +53,7 @@ func bytes(s string) []byte {
 	return b[0:len(s)];
 }
 
-export func TestFullRune(t *testing.T) {
+func TestFullRune(t *testing.T) {
 	for i := 0; i < len(utf8map); i++ {
 		m := utf8map[i];
 		b := bytes(m.str);
@@ -87,7 +87,7 @@ func equalBytes(a, b []byte) bool {
 	return true;
 }
 
-export func TestEncodeRune(t *testing.T) {
+func TestEncodeRune(t *testing.T) {
 	for i := 0; i < len(utf8map); i++ {
 		m := utf8map[i];
 		b := bytes(m.str);
@@ -100,7 +100,7 @@ export func TestEncodeRune(t *testing.T) {
 	}
 }
 
-export func TestDecodeRune(t *testing.T) {
+func TestDecodeRune(t *testing.T) {
 	for i := 0; i < len(utf8map); i++ {
 		m := utf8map[i];
 		b := bytes(m.str);
@@ -158,7 +158,7 @@ export func TestDecodeRune(t *testing.T) {
 	}
 }
 
-export type RuneCountTest struct {
+type RuneCountTest struct {
 	in string;
 	out int;
 }
@@ -168,7 +168,7 @@ var runecounttests = []RuneCountTest {
 	RuneCountTest{ "1,2,3,4", 7 },
 	RuneCountTest{ "\xe2\x00", 2 },
 }
-export func TestRuneCount(t *testing.T) {
+func TestRuneCount(t *testing.T) {
 	for i := 0; i < len(runecounttests); i++ {
 		tt := runecounttests[i];
 		if out := utf8.RuneCountInString(tt.in, 0, len(tt.in)); out != tt.out {
diff --git a/test/235.go b/test/235.go
index b0381f35bc..e24106dd00 100644
--- a/test/235.go
+++ b/test/235.go
@@ -6,9 +6,9 @@
 
 package main
 
-export type T chan uint64;
+type T chan uint64;
 
-export func M(f uint64) (in, out T) {
+func M(f uint64) (in, out T) {
 	in = make(T, 100);
 	out = make(T, 100);
 	go func(in, out T, f uint64) {
diff --git a/test/bigalg.go b/test/bigalg.go
index a77a9ec8d1..434eecf5d2 100644
--- a/test/bigalg.go
+++ b/test/bigalg.go
@@ -11,7 +11,7 @@ import (
 	"fmt";
 )
 
-export type T struct {
+type T struct {
 	a float64;
 	b int64;
 	c string;
@@ -19,7 +19,7 @@ export type T struct {
 }
 
 var a = []int{ 1, 2, 3 }
-export var NIL []int;
+var NIL []int;
 
 func arraycmptest() {
 	a1 := a;
@@ -34,7 +34,7 @@ func arraycmptest() {
 	}
 }
 
-export func SameArray(a, b []int) bool {
+func SameArray(a, b []int) bool {
 	if len(a) != len(b) || cap(a) != cap(b) {
 		return false;
 	}
@@ -103,7 +103,7 @@ func chantest() {
 	}
 }
 
-export type E struct { }
+type E struct { }
 var e E
 
 func interfacetest() {
diff --git a/test/bugs/bug117.go b/test/bugs/bug117.go
index 2707350cc6..a18e68849a 100644
--- a/test/bugs/bug117.go
+++ b/test/bugs/bug117.go
@@ -5,8 +5,8 @@
 // license that can be found in the LICENSE file.
 
 package main
-export type S struct { a int }
-export type PS *S
+type S struct { a int }
+type PS *S
 func (p *S) get() int {
   return p.a
 }
diff --git a/test/bugs/bug121.go b/test/bugs/bug121.go
index 815faeffd6..cc960e318c 100644
--- a/test/bugs/bug121.go
+++ b/test/bugs/bug121.go
@@ -6,14 +6,14 @@
 
 package main
 
-export type T ()
+type T ()
 
-export type I interface {
+type I interface {
 	f, g ();
 	h T;  // should only allow FunctionType here
 }
 
-export type S struct {
+type S struct {
 }
 
 func (s *S) f() {}
diff --git a/test/bugs/bug123.go b/test/bugs/bug123.go
index c3b8ff51cd..0576de37d6 100644
--- a/test/bugs/bug123.go
+++ b/test/bugs/bug123.go
@@ -5,7 +5,7 @@
 // license that can be found in the LICENSE file.
 
 package main
-export const ( F = 1 )
+const ( F = 1 )
 func fn(i int) int {
   if i == F() {		// ERROR "function"
     return 0
diff --git a/test/bugs/bug130.go b/test/bugs/bug130.go
index 1bcf05a9d4..aa3f0dd70e 100644
--- a/test/bugs/bug130.go
+++ b/test/bugs/bug130.go
@@ -6,9 +6,9 @@
 
 package main
 
-export type I interface { send(chan <- int) }
+type I interface { send(chan <- int) }
 
-export type S struct { v int }
+type S struct { v int }
 func (p *S) send(c chan <- int) { c <- p.v }
 
 func main() {
diff --git a/test/chan/fifo.go b/test/chan/fifo.go
index 5df4918453..ad53ab6558 100644
--- a/test/chan/fifo.go
+++ b/test/chan/fifo.go
@@ -8,9 +8,9 @@
 
 package main
 
-export const N = 10
+const N = 10
 
-export func AsynchFifo() {
+func AsynchFifo() {
 	ch := make(chan int, N);
 	for i := 0; i < N; i++ {
 		ch <- i
@@ -23,7 +23,7 @@ export func AsynchFifo() {
 	}
 }
 
-export func Chain(ch <-chan int, val int, in <-chan int, out chan<- int) {
+func Chain(ch <-chan int, val int, in <-chan int, out chan<- int) {
 	<-in;
 	if <-ch != val {
 		panic(val)
@@ -32,7 +32,7 @@ export func Chain(ch <-chan int, val int, in <-chan int, out chan<- int) {
 }
 
 // thread together a daisy chain to read the elements in sequence
-export func SynchFifo() {
+func SynchFifo() {
 	ch := make(chan int);
 	in := make(chan int);
 	start := in;
diff --git a/test/chan/powser1.go b/test/chan/powser1.go
index 6326fb241a..3334660918 100644
--- a/test/chan/powser1.go
+++ b/test/chan/powser1.go
@@ -41,7 +41,7 @@ var chnames string
 var chnameserial int
 var seqno int
 
-export func Init();
+func Init();
 
 func mkdch() *dch {
 	c := chnameserial % len(chnames);
@@ -176,11 +176,11 @@ func repeat(dat item, out *dch){
 	}
 }
 
-export type PS *dch;	// power series
-export type PS2 *[2] PS; // pair of power series
+type PS *dch;	// power series
+type PS2 *[2] PS; // pair of power series
 
-export var Ones PS
-export var Twos PS
+var Ones PS
+var Twos PS
 
 func mkPS() *dch {
 	return mkdch()
@@ -266,7 +266,7 @@ func inv(u *rat) *rat{	// invert a rat
 }
 
 // print eval in floating point of PS at x=c to n terms
-export func Evaln(c *rat, U PS, n int)
+func Evaln(c *rat, U PS, n int)
 {
 	xn := float64(1);
 	x := float64(c.num)/float64(c.den);
@@ -283,7 +283,7 @@ export func Evaln(c *rat, U PS, n int)
 }
 
 // Print n terms of a power series
-export func Printn(U PS, n int){
+func Printn(U PS, n int){
 	done := false;
 	for ; !done && n>0; n-- {
 		u := get(U);
@@ -293,7 +293,7 @@ export func Printn(U PS, n int){
 	print(("\n"));
 }
 
-export func Print(U PS){
+func Print(U PS){
 	Printn(U,1000000000);
 }
 
@@ -311,14 +311,14 @@ func eval(c *rat, U PS, n int) *rat{
 
 // Make a pair of power series identical to a given power series
 
-export func Split(U PS) *dch2{
+func Split(U PS) *dch2{
 	UU := mkdch2();
 	go split(U,UU);
 	return UU;
 }
 
 // Add two power series
-export func Add(U, V PS) PS{
+func Add(U, V PS) PS{
 	Z := mkPS();
 	go func(U, V, Z PS){
 		var uv [] *rat;
@@ -343,7 +343,7 @@ export func Add(U, V PS) PS{
 }
 
 // Multiply a power series by a constant
-export func Cmul(c *rat,U PS) PS{
+func Cmul(c *rat,U PS) PS{
 	Z := mkPS();
 	go func(c *rat, U, Z PS){
 		done := false;
@@ -360,13 +360,13 @@ export func Cmul(c *rat,U PS) PS{
 
 // Subtract
 
-export func Sub(U, V PS) PS{
+func Sub(U, V PS) PS{
 	return Add(U, Cmul(neg(one), V));
 }
 
 // Multiply a power series by the monomial x^n
 
-export func Monmul(U PS, n int) PS{
+func Monmul(U PS, n int) PS{
 	Z := mkPS();
 	go func(n int, U PS, Z PS){
 		for ; n>0; n-- { put(zero,Z) }
@@ -377,11 +377,11 @@ export func Monmul(U PS, n int) PS{
 
 // Multiply by x
 
-export func Xmul(U PS) PS{
+func Xmul(U PS) PS{
 	return Monmul(U,1);
 }
 
-export func Rep(c *rat) PS{
+func Rep(c *rat) PS{
 	Z := mkPS();
 	go repeat(c,Z);
 	return Z;
@@ -389,7 +389,7 @@ export func Rep(c *rat) PS{
 
 // Monomial c*x^n
 
-export func Mon(c *rat, n int) PS{
+func Mon(c *rat, n int) PS{
 	Z:=mkPS();
 	go func(c *rat, n int, Z PS){
 		if(c.num!=0) {
@@ -401,7 +401,7 @@ export func Mon(c *rat, n int) PS{
 	return Z;
 }
 
-export func Shift(c *rat, U PS) PS{
+func Shift(c *rat, U PS) PS{
 	Z := mkPS();
 	go func(c *rat, U, Z PS){
 		put(c,Z);
@@ -416,7 +416,7 @@ export func Shift(c *rat, U PS) PS{
 // to a (finite) power series
 
 /* BUG: NEED LEN OF ARRAY
-export func Poly(a [] *rat) PS{
+func Poly(a [] *rat) PS{
 	Z:=mkPS();
 	begin func(a [] *rat, Z PS){
 		j:=0;
@@ -436,7 +436,7 @@ export func Poly(a [] *rat) PS{
 //	let V = v + x*VV
 //	then UV = u*v + x*(u*VV+v*UU) + x*x*UU*VV
 
-export func Mul(U, V PS) PS{
+func Mul(U, V PS) PS{
 	Z:=mkPS();
 	go func(U, V, Z PS){
 		<-Z.req;
@@ -458,7 +458,7 @@ export func Mul(U, V PS) PS{
 
 // Differentiate
 
-export func Diff(U PS) PS{
+func Diff(U PS) PS{
 	Z:=mkPS();
 	go func(U, Z PS){
 		<-Z.req;
@@ -480,7 +480,7 @@ export func Diff(U PS) PS{
 }
 
 // Integrate, with const of integration
-export func Integ(c *rat,U PS) PS{
+func Integ(c *rat,U PS) PS{
 	Z:=mkPS();
 	go func(c *rat, U, Z PS){
 		put(c,Z);
@@ -498,7 +498,7 @@ export func Integ(c *rat,U PS) PS{
 
 // Binomial theorem (1+x)^c
 
-export func Binom(c *rat) PS{
+func Binom(c *rat) PS{
 	Z:=mkPS();
 	go func(c *rat, Z PS){
 		n := 1;
@@ -522,7 +522,7 @@ export func Binom(c *rat) PS{
 //	u*ZZ + z*UU +x*UU*ZZ = 0
 //	ZZ = -UU*(z+x*ZZ)/u;
 
-export func Recip(U PS) PS{
+func Recip(U PS) PS{
 	Z:=mkPS();
 	go func(U, Z PS){
 		ZZ:=mkPS2();
@@ -542,7 +542,7 @@ export func Recip(U PS) PS{
 //	DZ = Z*DU
 //	integrate to get Z
 
-export func Exp(U PS) PS{
+func Exp(U PS) PS{
 	ZZ := mkPS2();
 	split(Integ(one,Mul(ZZ[0],Diff(U))),ZZ);
 	return ZZ[1];
@@ -554,7 +554,7 @@ export func Exp(U PS) PS{
 // 	then S(U,V) = u + VV*S(V,UU)
 // bug: a nonzero constant term is ignored
 
-export func Subst(U, V PS) PS {
+func Subst(U, V PS) PS {
 	Z:= mkPS();
 	go func(U, V, Z PS) {
 		VV := Split(V);
@@ -572,7 +572,7 @@ export func Subst(U, V PS) PS {
 // Monomial Substition: U(c x^n)
 // Each Ui is multiplied by c^i and followed by n-1 zeros
 
-export func MonSubst(U PS, c0 *rat, n int) PS {
+func MonSubst(U PS, c0 *rat, n int) PS {
 	Z:= mkPS();
 	go func(U, Z PS, c0 *rat, n int) {
 		c := one;
@@ -595,7 +595,7 @@ export func MonSubst(U PS, c0 *rat, n int) PS {
 }
 
 
-export func Init() {
+func Init() {
 	chnameserial = -1;
 	seqno = 0;
 	chnames = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
@@ -620,7 +620,7 @@ func check(U PS, c *rat, count int, str string) {
 	}
 }
 
-export const N=10
+const N=10
 func checka(U PS, a []*rat, str string) {
 	for i := 0; i < N; i++ {
 		check(U, a[i], 1, str);
diff --git a/test/chan/powser2.go b/test/chan/powser2.go
index 0867025191..17e2aa2812 100644
--- a/test/chan/powser2.go
+++ b/test/chan/powser2.go
@@ -46,7 +46,7 @@ var chnames string
 var chnameserial int
 var seqno int
 
-export func Init();
+func Init();
 
 func mkdch() *dch {
 	c := chnameserial % len(chnames);
@@ -181,11 +181,11 @@ func repeat(dat item, out *dch){
 	}
 }
 
-export type PS *dch;	// power series
-export type PS2 *[2] PS; // pair of power series
+type PS *dch;	// power series
+type PS2 *[2] PS; // pair of power series
 
-export var Ones PS
-export var Twos PS
+var Ones PS
+var Twos PS
 
 func mkPS() *dch {
 	return mkdch()
@@ -271,7 +271,7 @@ func inv(u *rat) *rat{	// invert a rat
 }
 
 // print eval in floating point of PS at x=c to n terms
-export func Evaln(c *rat, U PS, n int)
+func Evaln(c *rat, U PS, n int)
 {
 	xn := float64(1);
 	x := float64(c.num)/float64(c.den);
@@ -288,7 +288,7 @@ export func Evaln(c *rat, U PS, n int)
 }
 
 // Print n terms of a power series
-export func Printn(U PS, n int){
+func Printn(U PS, n int){
 	done := false;
 	for ; !done && n>0; n-- {
 		u := get(U);
@@ -298,7 +298,7 @@ export func Printn(U PS, n int){
 	print(("\n"));
 }
 
-export func Print(U PS){
+func Print(U PS){
 	Printn(U,1000000000);
 }
 
@@ -316,14 +316,14 @@ func eval(c *rat, U PS, n int) *rat{
 
 // Make a pair of power series identical to a given power series
 
-export func Split(U PS) *dch2{
+func Split(U PS) *dch2{
 	UU := mkdch2();
 	go split(U,UU);
 	return UU;
 }
 
 // Add two power series
-export func Add(U, V PS) PS{
+func Add(U, V PS) PS{
 	Z := mkPS();
 	go func(U, V, Z PS){
 		var uv [] item;
@@ -348,7 +348,7 @@ export func Add(U, V PS) PS{
 }
 
 // Multiply a power series by a constant
-export func Cmul(c *rat,U PS) PS{
+func Cmul(c *rat,U PS) PS{
 	Z := mkPS();
 	go func(c *rat, U, Z PS){
 		done := false;
@@ -365,13 +365,13 @@ export func Cmul(c *rat,U PS) PS{
 
 // Subtract
 
-export func Sub(U, V PS) PS{
+func Sub(U, V PS) PS{
 	return Add(U, Cmul(neg(one), V));
 }
 
 // Multiply a power series by the monomial x^n
 
-export func Monmul(U PS, n int) PS{
+func Monmul(U PS, n int) PS{
 	Z := mkPS();
 	go func(n int, U PS, Z PS){
 		for ; n>0; n-- { put(zero,Z) }
@@ -382,11 +382,11 @@ export func Monmul(U PS, n int) PS{
 
 // Multiply by x
 
-export func Xmul(U PS) PS{
+func Xmul(U PS) PS{
 	return Monmul(U,1);
 }
 
-export func Rep(c *rat) PS{
+func Rep(c *rat) PS{
 	Z := mkPS();
 	go repeat(c,Z);
 	return Z;
@@ -394,7 +394,7 @@ export func Rep(c *rat) PS{
 
 // Monomial c*x^n
 
-export func Mon(c *rat, n int) PS{
+func Mon(c *rat, n int) PS{
 	Z:=mkPS();
 	go func(c *rat, n int, Z PS){
 		if(c.num!=0) {
@@ -406,7 +406,7 @@ export func Mon(c *rat, n int) PS{
 	return Z;
 }
 
-export func Shift(c *rat, U PS) PS{
+func Shift(c *rat, U PS) PS{
 	Z := mkPS();
 	go func(c *rat, U, Z PS){
 		put(c,Z);
@@ -421,7 +421,7 @@ export func Shift(c *rat, U PS) PS{
 // to a (finite) power series
 
 /* BUG: NEED LEN OF ARRAY
-export func Poly(a [] *rat) PS{
+func Poly(a [] *rat) PS{
 	Z:=mkPS();
 	begin func(a [] *rat, Z PS){
 		j:=0;
@@ -441,7 +441,7 @@ export func Poly(a [] *rat) PS{
 //	let V = v + x*VV
 //	then UV = u*v + x*(u*VV+v*UU) + x*x*UU*VV
 
-export func Mul(U, V PS) PS{
+func Mul(U, V PS) PS{
 	Z:=mkPS();
 	go func(U, V, Z PS){
 		<-Z.req;
@@ -463,7 +463,7 @@ export func Mul(U, V PS) PS{
 
 // Differentiate
 
-export func Diff(U PS) PS{
+func Diff(U PS) PS{
 	Z:=mkPS();
 	go func(U, Z PS){
 		<-Z.req;
@@ -485,7 +485,7 @@ export func Diff(U PS) PS{
 }
 
 // Integrate, with const of integration
-export func Integ(c *rat,U PS) PS{
+func Integ(c *rat,U PS) PS{
 	Z:=mkPS();
 	go func(c *rat, U, Z PS){
 		put(c,Z);
@@ -503,7 +503,7 @@ export func Integ(c *rat,U PS) PS{
 
 // Binomial theorem (1+x)^c
 
-export func Binom(c *rat) PS{
+func Binom(c *rat) PS{
 	Z:=mkPS();
 	go func(c *rat, Z PS){
 		n := 1;
@@ -527,7 +527,7 @@ export func Binom(c *rat) PS{
 //	u*ZZ + z*UU +x*UU*ZZ = 0
 //	ZZ = -UU*(z+x*ZZ)/u;
 
-export func Recip(U PS) PS{
+func Recip(U PS) PS{
 	Z:=mkPS();
 	go func(U, Z PS){
 		ZZ:=mkPS2();
@@ -547,7 +547,7 @@ export func Recip(U PS) PS{
 //	DZ = Z*DU
 //	integrate to get Z
 
-export func Exp(U PS) PS{
+func Exp(U PS) PS{
 	ZZ := mkPS2();
 	split(Integ(one,Mul(ZZ[0],Diff(U))),ZZ);
 	return ZZ[1];
@@ -559,7 +559,7 @@ export func Exp(U PS) PS{
 // 	then S(U,V) = u + VV*S(V,UU)
 // bug: a nonzero constant term is ignored
 
-export func Subst(U, V PS) PS {
+func Subst(U, V PS) PS {
 	Z:= mkPS();
 	go func(U, V, Z PS) {
 		VV := Split(V);
@@ -577,7 +577,7 @@ export func Subst(U, V PS) PS {
 // Monomial Substition: U(c x^n)
 // Each Ui is multiplied by c^i and followed by n-1 zeros
 
-export func MonSubst(U PS, c0 *rat, n int) PS {
+func MonSubst(U PS, c0 *rat, n int) PS {
 	Z:= mkPS();
 	go func(U, Z PS, c0 *rat, n int) {
 		c := one;
@@ -600,7 +600,7 @@ export func MonSubst(U PS, c0 *rat, n int) PS {
 }
 
 
-export func Init() {
+func Init() {
 	chnameserial = -1;
 	seqno = 0;
 	chnames = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
@@ -625,7 +625,7 @@ func check(U PS, c *rat, count int, str string) {
 	}
 }
 
-export const N=10
+const N=10
 func checka(U PS, a []*rat, str string) {
 	for i := 0; i < N; i++ {
 		check(U, a[i], 1, str);
diff --git a/test/chan/select.go b/test/chan/select.go
index 009ee35c72..d8a462551a 100644
--- a/test/chan/select.go
+++ b/test/chan/select.go
@@ -9,12 +9,12 @@ package main
 var counter uint
 var shift uint
 
-export func GetValue() uint {
+func GetValue() uint {
   counter++;
   return 1 << shift
 }
 
-export func Send(a, b chan uint) int {
+func Send(a, b chan uint) int {
   var i int;
   LOOP:
     for {
diff --git a/test/chan/sieve.go b/test/chan/sieve.go
index b5330e7f86..0cebdc6412 100644
--- a/test/chan/sieve.go
+++ b/test/chan/sieve.go
@@ -10,7 +10,7 @@
 package main
 
 // Send the sequence 2, 3, 4, ... to channel 'ch'.
-export func Generate(ch chan<- int) {
+func Generate(ch chan<- int) {
 	for i := 2; ; i++ {
 		ch <- i  // Send 'i' to channel 'ch'.
 	}
@@ -18,7 +18,7 @@ export func Generate(ch chan<- int) {
 
 // Copy the values from channel 'in' to channel 'out',
 // removing those divisible by 'prime'.
-export func Filter(in <-chan int, out chan<- int, prime int) {
+func Filter(in <-chan int, out chan<- int, prime int) {
 	for {
 		i := <-in;  // Receive value of new variable 'i' from 'in'.
 		if i % prime != 0 {
@@ -28,7 +28,7 @@ export func Filter(in <-chan int, out chan<- int, prime int) {
 }
 
 // The prime sieve: Daisy-chain Filter processes together.
-export func Sieve(primes chan<- int) {
+func Sieve(primes chan<- int) {
 	ch := make(chan int);  // Create a new channel.
 	go Generate(ch);  // Start Generate() as a subprocess.
 	for {
diff --git a/test/complit.go b/test/complit.go
index 55159be855..d9b9488519 100644
--- a/test/complit.go
+++ b/test/complit.go
@@ -6,9 +6,9 @@
 
 package main
 
-export type T struct { i int; f float; s string; next *T }
+type T struct { i int; f float; s string; next *T }
 
-export type R struct { num int }
+type R struct { num int }
 
 func itor(a int) *R {
 	r := new(R);
@@ -22,8 +22,8 @@ func eq(a []*R) {
 	}
 }
 
-export type P struct { a, b int };
-export func NewP(a, b int) *P {
+type P struct { a, b int };
+func NewP(a, b int) *P {
 	return &P{a, b}
 }
 
diff --git a/test/export.go b/test/export.go
index b1f033a160..8fe76d5f1c 100644
--- a/test/export.go
+++ b/test/export.go
@@ -6,11 +6,11 @@
 
 package main
 
-export type A struct		// ERROR "incomplete"
-export type B interface	// ERROR "incomplete"
+type A struct		// ERROR "incomplete"
+type B interface	// ERROR "incomplete"
 
-export type C struct
-export type D interface
+type C struct
+type D interface
 
-export type C struct { }
-export type D interface { }
+type C struct { }
+type D interface { }
diff --git a/test/fixedbugs/bug007.go b/test/fixedbugs/bug007.go
index 992276c678..bd970de5f9 100644
--- a/test/fixedbugs/bug007.go
+++ b/test/fixedbugs/bug007.go
@@ -6,7 +6,7 @@
 
 package main
 
-export type (
+type (
 	Point struct { x, y float };
 	Polar Point
 )
diff --git a/test/fixedbugs/bug011.go b/test/fixedbugs/bug011.go
index aaa920a6bb..63673c0865 100644
--- a/test/fixedbugs/bug011.go
+++ b/test/fixedbugs/bug011.go
@@ -7,7 +7,7 @@
 package main
 
 
-export type T struct {
+type T struct {
 	x, y int;
 }
 
diff --git a/test/fixedbugs/bug023.go b/test/fixedbugs/bug023.go
index 6a189b4701..cce8c4543e 100644
--- a/test/fixedbugs/bug023.go
+++ b/test/fixedbugs/bug023.go
@@ -6,11 +6,11 @@
 
 package main
 
-export type Type interface {
+type Type interface {
 	TypeName() string;
 }
 
-export type TInt struct {
+type TInt struct {
 }
 
 // TInt
diff --git a/test/fixedbugs/bug025.go b/test/fixedbugs/bug025.go
index 4d4e954bf3..545b171bc7 100644
--- a/test/fixedbugs/bug025.go
+++ b/test/fixedbugs/bug025.go
@@ -6,7 +6,7 @@
 
 package main
 
-export foo
+foo
 
 func main() {}
 
diff --git a/test/fixedbugs/bug026.go b/test/fixedbugs/bug026.go
index d64d0627eb..eacea37459 100644
--- a/test/fixedbugs/bug026.go
+++ b/test/fixedbugs/bug026.go
@@ -6,10 +6,10 @@
 
 package main
 
-export type Element interface {
+type Element interface {
 }
 
-export type Vector struct {
+type Vector struct {
 }
 
 func (v *Vector) Insert(i int, e Element) {
diff --git a/test/fixedbugs/bug027.go b/test/fixedbugs/bug027.go
index 9de26af2fa..16300502b8 100644
--- a/test/fixedbugs/bug027.go
+++ b/test/fixedbugs/bug027.go
@@ -6,15 +6,15 @@
 
 package main
 
-export type Element interface {
+type Element interface {
 }
 
-export type Vector struct {
+type Vector struct {
 	nelem int;
 	elem []Element;
 }
 
-export func New() *Vector {
+func New() *Vector {
 	v := new(Vector);
 	v.nelem = 0;
 	v.elem = make([]Element, 10);
diff --git a/test/fixedbugs/bug028.go b/test/fixedbugs/bug028.go
index 4990ac2866..0488ad2cba 100644
--- a/test/fixedbugs/bug028.go
+++ b/test/fixedbugs/bug028.go
@@ -7,7 +7,7 @@
 package main
 
 
-export func Alloc(i int) int {
+func Alloc(i int) int {
 	switch i {
 	default:
 		return 5;
diff --git a/test/fixedbugs/bug044.go b/test/fixedbugs/bug044.go
index 52ee033084..789237abe6 100644
--- a/test/fixedbugs/bug044.go
+++ b/test/fixedbugs/bug044.go
@@ -6,7 +6,7 @@
 
 package main
 
-export type S struct {
+type S struct {
 };
 
 func (p *S) M1a() ;
diff --git a/test/fixedbugs/bug045.go b/test/fixedbugs/bug045.go
index b4ae6de0a5..88c005d32d 100644
--- a/test/fixedbugs/bug045.go
+++ b/test/fixedbugs/bug045.go
@@ -6,7 +6,7 @@
 
 package main
 
-export type T struct {
+type T struct {
 	i int
 }
 
diff --git a/test/fixedbugs/bug046.go b/test/fixedbugs/bug046.go
index bd3a1e2f90..8a9b797074 100644
--- a/test/fixedbugs/bug046.go
+++ b/test/fixedbugs/bug046.go
@@ -6,7 +6,7 @@
 
 package main
 
-export type T *struct {}
+type T *struct {}
 
 func (x T) M () {}  // ERROR "pointer|receiver"
 
diff --git a/test/fixedbugs/bug054.go b/test/fixedbugs/bug054.go
index 35cfc9204d..0ed5d07082 100644
--- a/test/fixedbugs/bug054.go
+++ b/test/fixedbugs/bug054.go
@@ -6,10 +6,10 @@
 
 package main
 
-export type Element interface {
+type Element interface {
 }
 
-export type Vector struct {
+type Vector struct {
 	elem []Element;
 }
 
@@ -17,7 +17,7 @@ func (v *Vector) At(i int) Element {
 	return v.elem[i];
 }
 
-export type TStruct struct {
+type TStruct struct {
 	name string;
 	fields *Vector;
 }
diff --git a/test/fixedbugs/bug057.go b/test/fixedbugs/bug057.go
index e0a60dc377..1c959b8c83 100644
--- a/test/fixedbugs/bug057.go
+++ b/test/fixedbugs/bug057.go
@@ -6,7 +6,7 @@
 
 package main
 
-export type T struct {
+type T struct {
   s string;
 }
 
@@ -19,6 +19,6 @@ func main() {
 }
 
 /*
-uetli:/home/gri/go/test/bugs gri$ 6g bug057.go 
+uetli:/home/gri/go/test/bugs gri$ 6g bug057.go
 bug057.go:14: syntax error
 */
diff --git a/test/fixedbugs/bug058.go b/test/fixedbugs/bug058.go
index 3765dfc35c..da47ae5687 100644
--- a/test/fixedbugs/bug058.go
+++ b/test/fixedbugs/bug058.go
@@ -6,7 +6,7 @@
 
 package main
 
-export type Box struct {};
+type Box struct {};
 var m map[string] *Box;
 
 func main() {
diff --git a/test/fixedbugs/bug059.go b/test/fixedbugs/bug059.go
index d1f3b13b25..21c078361b 100644
--- a/test/fixedbugs/bug059.go
+++ b/test/fixedbugs/bug059.go
@@ -6,7 +6,7 @@
 
 package main
 
-export func P(a []string) string {
+func P(a []string) string {
 	s := "{";
 	for i := 0; i < 2; i++ {
 		if i > 0 {
diff --git a/test/fixedbugs/bug066.go b/test/fixedbugs/bug066.go
index ce021af3f1..4f64152aec 100644
--- a/test/fixedbugs/bug066.go
+++ b/test/fixedbugs/bug066.go
@@ -6,26 +6,26 @@
 
 package main
 
-export type (
+type (
 	Type struct;
 	Object struct;
 )
 
-export type Scope struct {
+type Scope struct {
 	entries map[string] *Object;
 }
 
 
-export type Type struct {
+type Type struct {
 	scope *Scope;
 }
 
 
-export type Object struct {
+type Object struct {
 	typ *Type;
 }
 
 
-export func Lookup(scope *Scope) *Object {
+func Lookup(scope *Scope) *Object {
 	return scope.entries["foo"];
 }
diff --git a/test/fixedbugs/bug075.go b/test/fixedbugs/bug075.go
index 76b5189343..fceeef8cba 100644
--- a/test/fixedbugs/bug075.go
+++ b/test/fixedbugs/bug075.go
@@ -6,7 +6,7 @@
 
 package main
 
-export type T struct { m map[int]int }
+type T struct { m map[int]int }
 func main() {
 	t := new(T);
 	t.m = make(map[int]int);
diff --git a/test/fixedbugs/bug083.dir/bug0.go b/test/fixedbugs/bug083.dir/bug0.go
index 58c4c49717..67ea271a0d 100644
--- a/test/fixedbugs/bug083.dir/bug0.go
+++ b/test/fixedbugs/bug083.dir/bug0.go
@@ -4,7 +4,7 @@
 
 package bug0
 
-export type T0 struct {
+type T0 struct {
 }
 
-export var V0 T0
+var V0 T0
diff --git a/test/fixedbugs/bug084.go b/test/fixedbugs/bug084.go
index 23e5e00ca3..2897593dcd 100644
--- a/test/fixedbugs/bug084.go
+++ b/test/fixedbugs/bug084.go
@@ -6,7 +6,7 @@
 
 package main
 
-export type Service struct {
+type Service struct {
 	rpc [2]int;
 }
 
diff --git a/test/fixedbugs/bug088.dir/bug0.go b/test/fixedbugs/bug088.dir/bug0.go
index 3536e81cb7..082cce81de 100644
--- a/test/fixedbugs/bug088.dir/bug0.go
+++ b/test/fixedbugs/bug088.dir/bug0.go
@@ -4,6 +4,6 @@
 
 package bug0
 
-export var V0 *() int;
-export var V1 *() (a int);
-export var V2 *() (a, b int);
+var V0 *() int;
+var V1 *() (a int);
+var V2 *() (a, b int);
diff --git a/test/fixedbugs/bug089.go b/test/fixedbugs/bug089.go
index 55d4dfba70..296e9e6d6d 100644
--- a/test/fixedbugs/bug089.go
+++ b/test/fixedbugs/bug089.go
@@ -6,8 +6,8 @@
 
 package main
 
-export type	I1	interface {}
-export type	I2	interface { pr() }
+type	I1	interface {}
+type	I2	interface { pr() }
 
 func	e()	I1;
 
diff --git a/test/fixedbugs/bug093.go b/test/fixedbugs/bug093.go
index 3adbc5abbb..f80eee01fa 100644
--- a/test/fixedbugs/bug093.go
+++ b/test/fixedbugs/bug093.go
@@ -6,14 +6,14 @@
 
 package main
 
-export type S struct {
+type S struct {
 }
 
 func (p *S) M() {
 	print("M\n");
 }
 
-export type I interface {
+type I interface {
 	M();
 }
 
diff --git a/test/fixedbugs/bug096.go b/test/fixedbugs/bug096.go
index 418f9f27c0..81d6c4aada 100644
--- a/test/fixedbugs/bug096.go
+++ b/test/fixedbugs/bug096.go
@@ -6,7 +6,7 @@
 
 package main
 
-export type A []int;
+type A []int;
 
 func main() {
 	a := &A{0};
@@ -16,7 +16,7 @@ func main() {
 /*
 uetli:~/Source/go1/test/bugs gri$ 6g bug096.go && 6l bug096.6 && 6.out
 Trace/BPT trap
-uetli:~/Source/go1/test/bugs gri$ 
+uetli:~/Source/go1/test/bugs gri$
 */
 
 /*
diff --git a/test/fixedbugs/bug097.go b/test/fixedbugs/bug097.go
index cd815d7664..70bd6e2b47 100644
--- a/test/fixedbugs/bug097.go
+++ b/test/fixedbugs/bug097.go
@@ -6,7 +6,7 @@
 
 package main
 
-export type A []int;
+type A []int;
 
 func main() {
 	var a [3]A;
diff --git a/test/fixedbugs/bug098.go b/test/fixedbugs/bug098.go
index 7c20d926be..8e790a709a 100644
--- a/test/fixedbugs/bug098.go
+++ b/test/fixedbugs/bug098.go
@@ -6,8 +6,8 @@
 
 package main
 
-export type A []int;
-export type M map[int] int;
+type A []int;
+type M map[int] int;
 
 func main() {
 	var a *A = &A{0};
diff --git a/test/fixedbugs/bug099.go b/test/fixedbugs/bug099.go
index 9bf3525e64..f76f0e873c 100644
--- a/test/fixedbugs/bug099.go
+++ b/test/fixedbugs/bug099.go
@@ -7,22 +7,22 @@
 package main
 
 // Interface
-export type I interface { F() int }
+type I interface { F() int }
 
 // Implements interface
-export type S struct { }
+type S struct { }
 func (s *S) F() int { return 1 }
 
 // Allocates S but returns I
 // Arg is unused but important:
 // if you take it out (and the 0s below)
 // then the bug goes away.
-export func NewI(i int) I {
+func NewI(i int) I {
 	return new(S)
 }
 
 // Uses interface method.
-export func Use(x I) {
+func Use(x I) {
 	x.F()
 }
 
diff --git a/test/fixedbugs/bug106.dir/bug0.go b/test/fixedbugs/bug106.dir/bug0.go
index 2dfe157cfd..7daf209448 100644
--- a/test/fixedbugs/bug106.dir/bug0.go
+++ b/test/fixedbugs/bug106.dir/bug0.go
@@ -3,4 +3,4 @@
 // license that can be found in the LICENSE file.
 
 package bug0
-export const A = -1
+const A = -1
diff --git a/test/fixedbugs/bug111.go b/test/fixedbugs/bug111.go
index 39da9b4dd6..e72b343ae3 100644
--- a/test/fixedbugs/bug111.go
+++ b/test/fixedbugs/bug111.go
@@ -8,11 +8,11 @@ package main
 
 var ncall int;
 
-export type Iffy interface {
+type Iffy interface {
 	Me() Iffy
 }
 
-export type Stucky struct {
+type Stucky struct {
 	n int
 }
 
diff --git a/test/fixedbugs/bug112.go b/test/fixedbugs/bug112.go
index b8d3357f0d..3c932843c7 100644
--- a/test/fixedbugs/bug112.go
+++ b/test/fixedbugs/bug112.go
@@ -6,7 +6,7 @@
 
 package main
 
-export type T struct { s string }
+type T struct { s string }
 var t = T{"hi"}
 
 func main() {}
diff --git a/test/fixedbugs/bug113.go b/test/fixedbugs/bug113.go
index f2f8ee7b34..ea75260cf2 100644
--- a/test/fixedbugs/bug113.go
+++ b/test/fixedbugs/bug113.go
@@ -5,7 +5,7 @@
 // license that can be found in the LICENSE file.
 
 package main
-export type I interface { };
+type I interface { };
 func foo1(i int) int { return i }
 func foo2(i int32) int32 { return i }
 func main() {
diff --git a/test/fixedbugs/bug114.go b/test/fixedbugs/bug114.go
index 431d7bb2dc..33330fff8e 100644
--- a/test/fixedbugs/bug114.go
+++ b/test/fixedbugs/bug114.go
@@ -6,9 +6,9 @@
 
 package main
 
-export const B32 = 1<<32 - 1
-export const C32 = (-1) & ((1<<32) - 1)
-export const D32 = ^0
+const B32 = 1<<32 - 1
+const C32 = (-1) & ((1<<32) - 1)
+const D32 = ^0
 
 func main() {
 	if B32 != 0xFFFFFFFF {
diff --git a/test/fixedbugs/bug118.go b/test/fixedbugs/bug118.go
index d508d83533..94f5ffd353 100644
--- a/test/fixedbugs/bug118.go
+++ b/test/fixedbugs/bug118.go
@@ -6,7 +6,7 @@
 
 package main
 
-export func Send(c chan int) int {
+func Send(c chan int) int {
   select {
   default:
     return 1;
diff --git a/test/fixedbugs/bug120.go b/test/fixedbugs/bug120.go
index dae78e91cd..10e28034dc 100644
--- a/test/fixedbugs/bug120.go
+++ b/test/fixedbugs/bug120.go
@@ -8,7 +8,7 @@ package main
 
 import "strconv";
 
-export type Test struct {
+type Test struct {
 	f float64;
 	in string;
 	out string;
diff --git a/test/func.go b/test/func.go
index 3a357f895c..ee9414ddc4 100644
--- a/test/func.go
+++ b/test/func.go
@@ -45,7 +45,7 @@ func f8(a int) (x int, y float) {
 	return 8, 8.0;
 }
 
-export type T struct {
+type T struct {
 	x, y int;
 }
 
diff --git a/test/hashmap.go b/test/hashmap.go
index 4fe36f339f..6f70f2b50c 100755
--- a/test/hashmap.go
+++ b/test/hashmap.go
@@ -9,7 +9,7 @@ package main
 // ----------------------------------------------------------------------------
 // Helper functions
 
-export func ASSERT(p bool) {
+func ASSERT(p bool) {
 	if !p {
 		// panic 0;
 	}
@@ -19,18 +19,18 @@ export func ASSERT(p bool) {
 // ----------------------------------------------------------------------------
 // Implementation of the HashMap
 
-export type KeyType interface {
+type KeyType interface {
 	Hash() uint32;
 	Match(other *KeyType) bool
 }
 
 
-export type ValueType interface {
+type ValueType interface {
 	// empty interface
 }
 
 
-export type Entry struct {
+type Entry struct {
 	key *KeyType;
 	value *ValueType;
 }
@@ -39,7 +39,7 @@ export type Entry struct {
 // Using the Array type below doesn't seem to work
 //type Array array [1024] Entry;
 
-export type HashMap struct {
+type HashMap struct {
 	map_ *[1024] Entry;
 	log2_capacity_ uint32;
 	occupancy_ uint32;
@@ -139,7 +139,7 @@ func (m *HashMap) Resize() {
 // ----------------------------------------------------------------------------
 // Test code
 
-export type Number struct {
+type Number struct {
 	x uint32;
 }
 
@@ -156,7 +156,7 @@ func (n *Number) Match(other *KeyType) bool {
 }
 
 
-export func MakeNumber (x uint32) *Number {
+func MakeNumber (x uint32) *Number {
 	var n *Number = new(Number);
 	n.x = x;
 	return n;
diff --git a/test/hilbert.go b/test/hilbert.go
index 311ed9b2c4..163313e852 100644
--- a/test/hilbert.go
+++ b/test/hilbert.go
@@ -21,13 +21,13 @@ func assert(p bool) {
 }
 
 
-export var (
+var (
 	Zero = Big.Rat(0, 1);
 	One = Big.Rat(1, 1);
 )
 
 
-export type Matrix struct {
+type Matrix struct {
 	n, m int;
 	a []*Big.Rational;
 }
@@ -45,7 +45,7 @@ func (a *Matrix) set(i, j int, x *Big.Rational) {
 }
 
 
-export func NewMatrix(n, m int) *Matrix {
+func NewMatrix(n, m int) *Matrix {
 	assert(0 <= n && 0 <= m);
 	a := new(Matrix);
 	a.n = n;
@@ -55,7 +55,7 @@ export func NewMatrix(n, m int) *Matrix {
 }
 
 
-export func NewUnit(n int) *Matrix {
+func NewUnit(n int) *Matrix {
 	a := NewMatrix(n, n);
 	for i := 0; i < n; i++ {
 		for j := 0; j < n; j++ {
@@ -70,7 +70,7 @@ export func NewUnit(n int) *Matrix {
 }
 
 
-export func NewHilbert(n int) *Matrix {
+func NewHilbert(n int) *Matrix {
 	a := NewMatrix(n, n);
 	for i := 0; i < n; i++ {
 		for j := 0; j < n; j++ {
@@ -82,12 +82,12 @@ export func NewHilbert(n int) *Matrix {
 }
 
 
-export func MakeRat(x Big.Natural) *Big.Rational {
+func MakeRat(x Big.Natural) *Big.Rational {
 	return Big.MakeRat(Big.MakeInt(false, x), Big.Nat(1));
 }
 
 
-export func NewInverseHilbert(n int) *Matrix {
+func NewInverseHilbert(n int) *Matrix {
 	a := NewMatrix(n, n);
 	for i := 0; i < n; i++ {
 		for j := 0; j < n; j++ {
diff --git a/test/interface.go b/test/interface.go
index 530d2883fa..ee03f67f03 100644
--- a/test/interface.go
+++ b/test/interface.go
@@ -6,17 +6,17 @@
 
 package main
 
-export type I2 interface
+type I2 interface
 
-export type I1 interface {
+type I1 interface {
 	foo() I2
 }
 
-export type I2 interface {
+type I2 interface {
 	bar() I1
 }
 
-export type T int
+type T int
 func (t T) bar() I1;
 func (t T) foo() I2 { return t }
 func (t T) bar() I1 { return t }
diff --git a/test/interface1.go b/test/interface1.go
index 819829c721..649a955f6d 100644
--- a/test/interface1.go
+++ b/test/interface1.go
@@ -6,23 +6,23 @@
 
 package main
 
-export type Inst interface {
+type Inst interface {
 	Next()	*Inst;
 }
 
-export type Regexp struct {
+type Regexp struct {
 	code []Inst;
 	start	Inst;
 }
 
-export type Start struct {
+type Start struct {
 	foo	*Inst;
 }
 
 func (start *Start) Next() *Inst { return nil }
 
 
-export func AddInst(Inst) *Inst {
+func AddInst(Inst) *Inst {
 	print("ok in addinst\n");
 	return nil
 }
diff --git a/test/interface2.go b/test/interface2.go
index 601c285baf..1db033887f 100644
--- a/test/interface2.go
+++ b/test/interface2.go
@@ -6,9 +6,9 @@
 
 package main
 
-export type S struct
+type S struct
 
-export type I interface {
+type I interface {
 	Foo()
 }
 
@@ -21,5 +21,5 @@ func main() {
 }
 
 // hide S down here to avoid static warning
-export type S struct {
+type S struct {
 }
diff --git a/test/interface3.go b/test/interface3.go
index 85cd02e13d..04af91a029 100644
--- a/test/interface3.go
+++ b/test/interface3.go
@@ -6,14 +6,14 @@
 
 package main
 
-export type S struct { a int }
-export type T struct { b string }
+type S struct { a int }
+type T struct { b string }
 
 func (s *S) Name() int8 { return 1 }
 func (t *T) Name() int64 { return 64 }
 
-export type I1 interface { Name() int8 }
-export type I2 interface { Name() int64 }
+type I1 interface { Name() int8 }
+type I2 interface { Name() int64 }
 
 func main() {
 	var i1 I1;
diff --git a/test/interface4.go b/test/interface4.go
index 9df502b215..a55936df84 100644
--- a/test/interface4.go
+++ b/test/interface4.go
@@ -9,15 +9,15 @@
 
 package main
 
-export type I interface { M() int64 }
+type I interface { M() int64 }
 
-export type BigPtr struct { a, b, c, d int64 }
+type BigPtr struct { a, b, c, d int64 }
 func (z *BigPtr) M() int64 { return z.a+z.b+z.c+z.d }
 
-export type SmallPtr struct { a int32 }
+type SmallPtr struct { a int32 }
 func (z *SmallPtr) M() int64 { return int64(z.a) }
 
-export type IntPtr int32
+type IntPtr int32
 func (z *IntPtr) M() int64 { return int64(*z) }
 
 var bad bool
@@ -43,13 +43,13 @@ func ptrs() {
 	test("&intptr", &intptr);
 }
 
-export type Big struct { a, b, c, d int64 }
+type Big struct { a, b, c, d int64 }
 func (z Big) M() int64 { return z.a+z.b+z.c+z.d }
 
-export type Small struct { a int32 }
+type Small struct { a int32 }
 func (z Small) M() int64 { return int64(z.a) }
 
-export type Int int32
+type Int int32
 func (z Int) M() int64 { return int64(z) }
 
 func nonptrs() {
diff --git a/test/interface5.go b/test/interface5.go
index 3e816abfcc..2e273ddddb 100644
--- a/test/interface5.go
+++ b/test/interface5.go
@@ -6,10 +6,10 @@
 
 package main
 
-export type T struct { a int }
+type T struct { a int }
 var t *T
 
-export type I interface { M() }
+type I interface { M() }
 var i I
 
 func main() {
diff --git a/test/interface6.go b/test/interface6.go
index 27b5740ade..6053e51d64 100644
--- a/test/interface6.go
+++ b/test/interface6.go
@@ -15,9 +15,9 @@ func check(b bool, msg string) {
   }
 }
 
-export type I1 interface { Get() int; Put(int); }
+type I1 interface { Get() int; Put(int); }
 
-export type S1 struct { i int }
+type S1 struct { i int }
 func (p S1) Get() int { return p.i }
 func (p S1) Put(i int) { p.i = i }
 
@@ -45,7 +45,7 @@ func f3() {
   check(s.i == 1, "f3 s");
 }
 
-export type S2 struct { i int }
+type S2 struct { i int }
 func (p *S2) Get() int { return p.i }
 func (p *S2) Put(i int) { p.i = i }
 
@@ -73,9 +73,9 @@ func f6() {
   check(s.i == 2, "f6 s");
 }
 
-export type I2 interface { Get() int64; Put(int64); }
+type I2 interface { Get() int64; Put(int64); }
 
-export type S3 struct { i, j, k, l int64 }
+type S3 struct { i, j, k, l int64 }
 func (p S3) Get() int64 { return p.l }
 func (p S3) Put(i int64) { p.l = i }
 
@@ -103,7 +103,7 @@ func f9() {
   check(s.l == 4, "f9 s");
 }
 
-export type S4 struct { i, j, k, l int64 }
+type S4 struct { i, j, k, l int64 }
 func (p *S4) Get() int64 { return p.l }
 func (p *S4) Put(i int64) { p.l = i }
 
diff --git a/test/iota.go b/test/iota.go
index d6c0026a90..393edac804 100644
--- a/test/iota.go
+++ b/test/iota.go
@@ -21,13 +21,13 @@ const (
 	g float = 4.5 * float(iota);
 )
 
-export const (
+const (
 	X = 0;
 	Y;
 	Z;
 )
 
-export const (
+const (
 	A = 1 << iota;
 	B;
 	C;
diff --git a/test/ken/chan.go b/test/ken/chan.go
index 3bc3094975..e06d9ab40a 100644
--- a/test/ken/chan.go
+++ b/test/ken/chan.go
@@ -19,7 +19,7 @@ nrand(n int) int
 	return randx%n;
 }
 
-export type	Chan
+type	Chan
 struct
 {
 	sc,rc	chan int;	// send and recv chan
diff --git a/test/ken/embed.go b/test/ken/embed.go
index bc8240819b..f0c9f4ec2b 100644
--- a/test/ken/embed.go
+++ b/test/ken/embed.go
@@ -7,7 +7,7 @@
 package main
 
 
-export type
+type
 I	interface
 {
 	test1,
@@ -23,7 +23,7 @@ I	interface
  ******
  ******/
 
-export type
+type
 SubpSubp	struct
 {
 	a7	int;
@@ -45,7 +45,7 @@ testx()
  ******
  ******/
 
-export type
+type
 SubpSub	struct
 {
 	a6	int;
@@ -68,7 +68,7 @@ testx()
  ******
  ******/
 
-export type
+type
 SubSubp	struct
 {
 	a5	int;
@@ -85,7 +85,7 @@ test5() int
  ******
  ******/
 
-export type
+type
 SubSub	struct
 {
 	a4	int;
@@ -102,7 +102,7 @@ test4() int
  ******
  ******/
 
-export type
+type
 Subp	struct
 {
 	a3	int;
@@ -121,7 +121,7 @@ test3() int
  ******
  ******/
 
-export type
+type
 Sub	struct
 {
 	a2	int;
@@ -140,7 +140,7 @@ test2() int
  ******
  ******/
 
-export type
+type
 S	struct
 {
 	a1	int;
diff --git a/test/ken/interbasic.go b/test/ken/interbasic.go
index 54ce6ffbcc..05eea395bb 100644
--- a/test/ken/interbasic.go
+++ b/test/ken/interbasic.go
@@ -8,7 +8,7 @@ package main
 
 type	myint		int;
 type	mystring	string;
-export type	I0		interface {};
+type	I0		interface {};
 
 func
 f()
diff --git a/test/ken/interfun.go b/test/ken/interfun.go
index 55d2d442a0..97db893168 100644
--- a/test/ken/interfun.go
+++ b/test/ken/interfun.go
@@ -6,17 +6,17 @@
 
 package main
 
-export type S struct
+type S struct
 {
 	a,b	int;
 }
 
-export type I1 interface
+type I1 interface
 {
 	f	()int;
 }
 
-export type I2 interface
+type I2 interface
 {
 	g,f	()int;
 }
diff --git a/test/ken/intervar.go b/test/ken/intervar.go
index 31e7d98692..1c3d650006 100644
--- a/test/ken/intervar.go
+++ b/test/ken/intervar.go
@@ -6,14 +6,14 @@
 
 package main
 
-export type	Iputs	interface
+type	Iputs	interface
 {
 	puts	(s string);
 }
 
 // ---------
 
-export type	Print	struct
+type	Print	struct
 {
 	whoami	int;
 	put	Iputs;
@@ -28,7 +28,7 @@ dop()
 
 // ---------
 
-export type	Bio	struct
+type	Bio	struct
 {
 	whoami	int;
 	put	Iputs;
@@ -43,7 +43,7 @@ puts(s string)
 
 // ---------
 
-export type	File	struct
+type	File	struct
 {
 	whoami	int;
 	put	Iputs;
diff --git a/test/ken/ptrfun.go b/test/ken/ptrfun.go
index e2307cf509..e7db3a94d3 100644
--- a/test/ken/ptrfun.go
+++ b/test/ken/ptrfun.go
@@ -7,7 +7,7 @@
 
 package main
 
-export type C struct
+type C struct
 {
 	a	int;
 	x	*(p *C)int;
diff --git a/test/ken/rob1.go b/test/ken/rob1.go
index b6d72c8bdc..a75878b1f5 100644
--- a/test/ken/rob1.go
+++ b/test/ken/rob1.go
@@ -6,18 +6,18 @@
 
 package main
 
-export type Item interface
+type Item interface
 {
 	Print();
 }
 
-export type ListItem struct
+type ListItem struct
 {
 	item    Item;
 	next    *ListItem;
 }
 
-export type List struct
+type List struct
 {
 	head    *ListItem;
 }
@@ -48,7 +48,7 @@ Print()
 }
 
 // Something to put in a list
-export type Integer struct
+type Integer struct
 {
 	val		int;
 }
diff --git a/test/ken/rob2.go b/test/ken/rob2.go
index 313ae586fc..1b4d86e6f2 100644
--- a/test/ken/rob2.go
+++ b/test/ken/rob2.go
@@ -9,24 +9,24 @@ package main
 
 const nilchar = 0;
 
-export type (
+type (
 	Atom struct;
 	List struct;
 	Slist struct;
 )
 
-export type Atom struct {
+type Atom struct {
 	str		string;
 	integer		int;
 	next		*Slist;	/* in hash bucket */
 }
 
-export type List struct {
+type List struct {
 	car		*Slist;
 	cdr*Slist;
 }
 
-export type Slist struct {
+type Slist struct {
 	isatom		bool;
 	isstring	bool;
 	//union {
@@ -67,8 +67,8 @@ func (slist *Slist) Free() {
 //	free(slist);
 }
 
-export func OpenFile();
-export func Parse() *Slist;
+func OpenFile();
+func Parse() *Slist;
 
 //Slist* atom(byte *s, int i);
 
@@ -81,7 +81,7 @@ var inputindex int = 0;
 var tokenbuf [100]byte;
 var tokenlen int = 0;
 
-export const EOF int = -1;
+const EOF int = -1;
 
 func main()
 {
@@ -131,7 +131,7 @@ func (slist *Slist) Print()
 	print("\n");
 }
 
-export func Get() int
+func Get() int
 {
 	var c int;
 
@@ -152,12 +152,12 @@ export func Get() int
 	return c;
 }
 
-export func WhiteSpace(c int) bool
+func WhiteSpace(c int) bool
 {
 	return c == ' ' || c == '\t' || c == '\r' || c == '\n';
 }
 
-export func NextToken()
+func NextToken()
 {
 	var i, c int;
 	var backslash bool;
@@ -199,7 +199,7 @@ export func NextToken()
 	}
 }
 
-export func Expect(c int)
+func Expect(c int)
 {
 	if token != c {
 		print("parse error: expected ", c, "\n");
@@ -209,7 +209,7 @@ export func Expect(c int)
 }
 
 // Parse a non-parenthesized list up to a closing paren or EOF
-export func ParseList() *Slist
+func ParseList() *Slist
 {
 	var slist, retval *Slist;
 
@@ -257,7 +257,7 @@ func atoi() int	// BUG: uses tokenbuf; should take argument
 	return v;
 }
 
-export func Parse() *Slist
+func Parse() *Slist
 {
 	var slist *Slist;
 
@@ -288,7 +288,7 @@ export func Parse() *Slist
 	return nil;
 }
 
-export func OpenFile()
+func OpenFile()
 {
 	input = "(defn foo (add 12 34))\n\x00";
 	inputindex = 0;
diff --git a/test/ken/robfunc.go b/test/ken/robfunc.go
index 5d4cfd2afb..12b4b6d7b6 100644
--- a/test/ken/robfunc.go
+++ b/test/ken/robfunc.go
@@ -44,7 +44,7 @@ func f8(a int) (x int, y float) {
 	return 8, 8.0;
 }
 
-export type T struct {
+type T struct {
 	x, y int;
 }
 
diff --git a/test/mallocrand.go b/test/mallocrand.go
index e4f06cad2b..5fdeced4d9 100644
--- a/test/mallocrand.go
+++ b/test/mallocrand.go
@@ -48,7 +48,7 @@ func prime() {
 func memset(b *byte, c byte, n uint64) {
 	np := uintptr(n);
 	for i := uintptr(0); i < np; i++ {
-		*(b.(unsafe.pointer).(uintptr)+i).(unsafe.pointer).(*byte) = c;
+		*(b.(unsafe.Pointer).(uintptr)+i).(unsafe.Pointer).(*byte) = c;
 	}
 }
 
diff --git a/test/mallocrep1.go b/test/mallocrep1.go
index ebb1741994..5d17dc2c6d 100644
--- a/test/mallocrep1.go
+++ b/test/mallocrep1.go
@@ -22,7 +22,7 @@ var longtest = flag.Bool("l", false, "long test");
 var b []*byte;
 var stats = malloc.GetStats();
 
-export func OkAmount(size, n uintptr) bool {
+func OkAmount(size, n uintptr) bool {
 	if n < size {
 		return false
 	}
@@ -38,7 +38,7 @@ export func OkAmount(size, n uintptr) bool {
 	return true
 }
 
-export func AllocAndFree(size, count int) {
+func AllocAndFree(size, count int) {
 	if *chatty {
 		fmt.Printf("size=%d count=%d ...\n", size, count);
 	}
diff --git a/test/map.go b/test/map.go
index 18a401cf75..51c6fe5f5b 100644
--- a/test/map.go
+++ b/test/map.go
@@ -13,7 +13,7 @@ import (
 
 const arraylen = 2; // BUG: shouldn't need this
 
-export func P(a []string) string {
+func P(a []string) string {
 	s := "{";
 	for i := 0; i < len(a); i++ {
 		if i > 0 {
diff --git a/test/method.go b/test/method.go
index f57c269074..6dba3d1781 100644
--- a/test/method.go
+++ b/test/method.go
@@ -6,12 +6,12 @@
 
 package main
 
-export type S string
-export type S1 string
-export type I int
-export type I1 int
-export type T struct { x int }
-export type T1 T
+type S string
+type S1 string
+type I int
+type I1 int
+type T struct { x int }
+type T1 T
 
 func (s S) val() int { return 1 }
 func (s *S1) val() int { return 2 }
@@ -20,7 +20,7 @@ func (i *I1) val() int { return 4 }
 //func (t T) val() int { return 7 }
 func (t *T1) val() int { return 8 }
 
-export type Val interface {
+type Val interface {
 	val() int
 }
 
diff --git a/test/method1.go b/test/method1.go
index d279c50ddf..c88607d425 100644
--- a/test/method1.go
+++ b/test/method1.go
@@ -6,7 +6,7 @@
 
 package main
 
-export type T struct { }
+type T struct { }
 func (t *T) M(int, string);	// GCCGO_ERROR "previous"
 func (t *T) M(int, float) { }   // ERROR "redeclared|redefinition"
 
diff --git a/test/method2.go b/test/method2.go
index 9a32dd6b6a..3ee0ae1364 100644
--- a/test/method2.go
+++ b/test/method2.go
@@ -6,9 +6,9 @@
 
 package main
 
-export type T struct {a int}
-export type P *T
-export type P1 *T
+type T struct {a int}
+type P *T
+type P1 *T
 
 func (p P) val() int { return 1 }  // ERROR "receiver"
 func (p *P1) val() int { return 1 }  // ERROR "receiver"
diff --git a/test/method3.go b/test/method3.go
index 0b93af0e12..491bcdad33 100644
--- a/test/method3.go
+++ b/test/method3.go
@@ -8,10 +8,10 @@
 
 package main
 
-export type T [] int
+type T [] int
 func (t T) Len() int { return len(t) }
 
-export type I interface {
+type I interface {
 	Len() int
 }
 
diff --git a/test/nil.go b/test/nil.go
index e59d473176..1aef54ba9b 100644
--- a/test/nil.go
+++ b/test/nil.go
@@ -6,11 +6,11 @@
 
 package main
 
-export type T struct {
+type T struct {
 	i int
 }
 
-export type IN interface {
+type IN interface {
 }
 
 func main() {
diff --git a/test/peano.go b/test/peano.go
index 3195761983..07e5f0ed37 100644
--- a/test/peano.go
+++ b/test/peano.go
@@ -6,7 +6,7 @@
 
 package main
 
-export type Number struct {
+type Number struct {
 	next *Number
 }
 
diff --git a/test/sieve.go b/test/sieve.go
index f6a07277fb..e163456176 100644
--- a/test/sieve.go
+++ b/test/sieve.go
@@ -7,7 +7,7 @@
 package main
 
 // Send the sequence 2, 3, 4, ... to channel 'ch'.
-export func Generate(ch chan<- int) {
+func Generate(ch chan<- int) {
 	for i := 2; ; i++ {
 		ch <- i  // Send 'i' to channel 'ch'.
 	}
@@ -15,7 +15,7 @@ export func Generate(ch chan<- int) {
 
 // Copy the values from channel 'in' to channel 'out',
 // removing those divisible by 'prime'.
-export func Filter(in <-chan int, out chan<- int, prime int) {
+func Filter(in <-chan int, out chan<- int, prime int) {
 	for {
 		i := <-in;  // Receive value of new variable 'i' from 'in'.
 		if i % prime != 0 {
@@ -25,7 +25,7 @@ export func Filter(in <-chan int, out chan<- int, prime int) {
 }
 
 // The prime sieve: Daisy-chain Filter processes together.
-export func Sieve() {
+func Sieve() {
 	ch := make(chan int);  // Create a new channel.
 	go Generate(ch);  // Start Generate() as a subprocess.
 	for {
diff --git a/test/test0.go b/test/test0.go
index bb9f10f9cb..95d225444f 100644
--- a/test/test0.go
+++ b/test/test0.go
@@ -18,7 +18,7 @@ const (
   mask4 = 1 << iota;
 )
 
-export type (
+type (
   Empty interface {};
   Point struct {
     x, y int;
diff --git a/test/vectors.go b/test/vectors.go
index f468f4b29a..e5cbde2d53 100644
--- a/test/vectors.go
+++ b/test/vectors.go
@@ -9,7 +9,7 @@ package main
 import "array"
 
 
-export type S struct {
+type S struct {
 	val int
 }
 
diff --git a/usr/gri/gosrc/ast.go b/usr/gri/gosrc/ast.go
index 06c2968fc1..3188755a34 100644
--- a/usr/gri/gosrc/ast.go
+++ b/usr/gri/gosrc/ast.go
@@ -13,7 +13,7 @@ import Universe "universe"
 // ----------------------------------------------------------------------------
 // Expressions
 
-export const /* op */ (
+const /* op */ (
 	LITERAL = iota;
 	OBJECT;
 	DEREF;
@@ -26,7 +26,7 @@ export const /* op */ (
 // ----------------------------------------------------------------------------
 // Literals
 
-export type Literal struct {
+type Literal struct {
 	pos_ int;
 	typ_ *Globals.Type;
 	b bool;
@@ -41,7 +41,7 @@ func (x *Literal) pos() int  { return x.pos_; }
 func (x *Literal) typ() *Globals.Type  { return x.typ_; }
 
 
-export func NewLiteral(pos int, typ *Globals.Type) *Literal {
+func NewLiteral(pos int, typ *Globals.Type) *Literal {
 	x := new(Literal);
 	x.pos_ = pos;
 	x.typ_ = typ;
@@ -49,7 +49,7 @@ export func NewLiteral(pos int, typ *Globals.Type) *Literal {
 }
 
 
-export var Bad, True, False, Nil *Literal;
+var Bad, True, False, Nil *Literal;
 
 
 // ----------------------------------------------------------------------------
@@ -58,7 +58,7 @@ export var Bad, True, False, Nil *Literal;
 // NOTE We could use Globals.Object directly if we'd added a typ()
 // method to its interface. However, this would require renaming the
 // typ field everywhere... - Need to think about accessors again.
-export type Object struct {
+type Object struct {
 	pos_ int;
 	obj *Globals.Object;
 }
@@ -69,7 +69,7 @@ func (x *Object) pos() int  { return x.pos_; }
 func (x *Object) typ() *Globals.Type  { return x.obj.typ; }
 
 
-export func NewObject(pos int, obj* Globals.Object) *Object {
+func NewObject(pos int, obj* Globals.Object) *Object {
 	x := new(Object);
 	x.pos_ = pos;
 	x.obj = obj;
@@ -81,7 +81,7 @@ export func NewObject(pos int, obj* Globals.Object) *Object {
 // Derefs
 
 // TODO model Deref as unary operation?
-export type Deref struct {
+type Deref struct {
 	ptr_ Globals.Expr;
 }
 
@@ -91,7 +91,7 @@ func (x *Deref) pos() int { return x.ptr_.pos(); }
 func (x *Deref) typ() *Globals.Type  { return x.ptr_.typ().elt; }
 
 
-export func NewDeref(ptr Globals.Expr) *Deref {
+func NewDeref(ptr Globals.Expr) *Deref {
 	x := new(Deref);
 	x.ptr_ = ptr;
 	return x;
@@ -102,7 +102,7 @@ export func NewDeref(ptr Globals.Expr) *Deref {
 // Selectors
 
 // TODO model Selector as binary operation?
-export type Selector struct {
+type Selector struct {
 	pos_ int;
 	typ_ *Globals.Type;
 }
@@ -113,7 +113,7 @@ func (x *Selector) pos() int  { return x.pos_; }
 func (x *Selector) typ() *Globals.Type  { return x.typ_; }
 
 
-export func NewSelector(pos int, typ *Globals.Type) *Selector {
+func NewSelector(pos int, typ *Globals.Type) *Selector {
 	x := new(Selector);
 	x.pos_ = pos;
 	x.typ_ = typ;
@@ -124,7 +124,7 @@ export func NewSelector(pos int, typ *Globals.Type) *Selector {
 // ----------------------------------------------------------------------------
 // Calls
 
-export type Call struct {
+type Call struct {
 	recv, callee Globals.Expr;
 	args *Globals.List;
 }
@@ -135,7 +135,7 @@ func (x *Call) pos() int  { return 0; }
 func (x *Call) typ() *Globals.Type  { return nil; }
 
 
-export func NewCall(args *Globals.List) *Call {
+func NewCall(args *Globals.List) *Call {
 	x := new(Call);
 	x.args = args;
 	return x;
@@ -145,7 +145,7 @@ export func NewCall(args *Globals.List) *Call {
 // ----------------------------------------------------------------------------
 // Binary expressions
 
-export type BinaryExpr struct {
+type BinaryExpr struct {
 	op_ int;
 	pos_ int;
 	typ_ *Globals.Type;
@@ -161,7 +161,7 @@ func (x *BinaryExpr) typ() *Globals.Type  {	return x.typ_; }
 // ----------------------------------------------------------------------------
 // Tuples
 
-export type Tuple struct {
+type Tuple struct {
 	typ_ *Globals.Type;
 	list *Globals.List;
 }
@@ -172,7 +172,7 @@ func (x *Tuple) pos() int  { return x.list.first.expr.pos(); }
 func (x *Tuple) typ() *Globals.Type  { return x.typ_; }
 
 
-export func NewTuple(list *Globals.List) *Tuple {
+func NewTuple(list *Globals.List) *Tuple {
 	// make corresponding tuple type
 	scope := Globals.NewScope(nil);
 	for p := list.first; p != nil; p = p.next {
@@ -183,7 +183,7 @@ export func NewTuple(list *Globals.List) *Tuple {
 	}
 	typ := Globals.NewType(Type.TUPLE);
 	typ.scope = scope;
-	
+
 	// create the tuple
 	x := new(Tuple);
 	x.typ_ = typ;
@@ -195,12 +195,12 @@ export func NewTuple(list *Globals.List) *Tuple {
 // ----------------------------------------------------------------------------
 // Statements
 
-export type Block struct {
+type Block struct {
 	// TODO fill in
 }
 
 
-export type IfStat struct {
+type IfStat struct {
 	cond Globals.Expr;
 	then_ Globals.Stat;
 	else_ Globals.Stat;
diff --git a/usr/gri/gosrc/base.go b/usr/gri/gosrc/base.go
index 7a3e5ebdec..9620fbd180 100755
--- a/usr/gri/gosrc/base.go
+++ b/usr/gri/gosrc/base.go
@@ -6,18 +6,18 @@
 
 package base
 
-export type Foo int
+type Foo int
 
-export type Bar *float;
+type Bar *float;
 
-export type Node struct {
+type Node struct {
   left, right *Node;
   val bool;
   f Foo;
 }
 
-export func (p *Node) F(x int) {};
+func (p *Node) F(x int) {};
 
-export type I interface {
+type I interface {
   f();
 }
diff --git a/usr/gri/gosrc/compilation.go b/usr/gri/gosrc/compilation.go
index a186966f2b..bde2d696d3 100644
--- a/usr/gri/gosrc/compilation.go
+++ b/usr/gri/gosrc/compilation.go
@@ -39,7 +39,7 @@ func LineCol(src string, pos int) (line, col int) {
 }
 
 
-export func Error(comp *Globals.Compilation, pos int, msg string) {
+func Error(comp *Globals.Compilation, pos int, msg string) {
 	const errdist = 10;
 	delta := pos - comp.errpos;  // may be negative!
 	if delta < 0 {
@@ -111,7 +111,7 @@ func ReadImport(comp* Globals.Compilation, filename string, update bool) (data s
 }
 
 
-export func Import(comp *Globals.Compilation, pkg_file string) *Globals.Package {
+func Import(comp *Globals.Compilation, pkg_file string) *Globals.Package {
 	data, ok := ReadImport(comp, pkg_file, comp.flags.update_packages);
 	var pkg *Globals.Package;
 	if ok {
@@ -121,7 +121,7 @@ export func Import(comp *Globals.Compilation, pkg_file string) *Globals.Package
 }
 
 
-export func Export(comp *Globals.Compilation, pkg_file string) {
+func Export(comp *Globals.Compilation, pkg_file string) {
 	data := Exporter.Export(comp);
 	ok := Platform.WriteObjectFile(pkg_file, data);
 	if !ok {
@@ -130,7 +130,7 @@ export func Export(comp *Globals.Compilation, pkg_file string) {
 }
 
 
-export func Compile(comp *Globals.Compilation, src_file string) {
+func Compile(comp *Globals.Compilation, src_file string) {
 	// TODO This is incorrect: When compiling with the -r flag, we are
 	// calling this function recursively w/o setting up a new comp - this
 	// is broken and leads to an assertion error (more then one package
diff --git a/usr/gri/gosrc/decls.go b/usr/gri/gosrc/decls.go
index 58b995a5b4..20216f8272 100755
--- a/usr/gri/gosrc/decls.go
+++ b/usr/gri/gosrc/decls.go
@@ -9,8 +9,8 @@ package decls
 import "base"
 import base2 "base"
 
-export const c0 int = 0
-export const c1 float = 1.
+const c0 int = 0
+const c1 float = 1.
 const (
 	c2 byte = 2;
 	c3 int = 3;
@@ -18,18 +18,18 @@ const (
 )
 
 
-export type (
+type (
 	Node0 base.Node
 	Node1 *base2.Node
 )
 
-export type T0 byte
-export type T1 T0
+type T0 byte
+type T1 T0
 type (
 	T2 [10]T0;
 	T3 map [string] int;
 )
-export type T4 struct {
+type T4 struct {
 	f1, f2, f3 int;
 	f4 [] float;
 };
@@ -56,7 +56,7 @@ type T9 struct {
 	f *(x, y *T9) *T9;
 }
 
-export type T11 struct {
+type T11 struct {
 	p *T10;
 }
 
@@ -73,7 +73,7 @@ type I1 interface {
 	Do0(q *I0);
 	Do1(p *I1) bool;
 }
-export type I2 interface {
+type I2 interface {
 	M0();
 	M1(a int);
 	M2(a, b int, c float);
@@ -86,7 +86,7 @@ export type I2 interface {
 var v0 int
 var v1 float = c1
 
-export var (
+var (
 	v2 T2;
 	v3 struct {
 		f1, f2, f3 *M0;
@@ -94,8 +94,8 @@ export var (
 )
 
 
-export func f0() {}
-export func f1(a int) {}
+func f0() {}
+func f1(a int) {}
 func f2(a, b int, c float) {}
 func f3() bool { return false; }
 func f4(a int) (z T5, ok bool) {}
diff --git a/usr/gri/gosrc/export.go b/usr/gri/gosrc/export.go
index 6b5cee21db..8f4f211643 100755
--- a/usr/gri/gosrc/export.go
+++ b/usr/gri/gosrc/export.go
@@ -130,7 +130,7 @@ func (E *Exporter) WriteScope(scope *Globals.Scope) {
 		}
 	}
 	E.WriteObject(nil);
-	
+
 	if E.debug {
 		print(" }");
 	}
@@ -166,23 +166,23 @@ func (E *Exporter) WriteType(typ *Globals.Type) {
 			ident = "." + ident;
 		}
 	}
-	
+
 	E.WriteString(ident);
 	if len(ident) > 0 {
 		// named type
 		E.WritePackage(E.comp.pkg_list[typ.obj.pnolev]);
 	}
-	
+
 	switch typ.form {
 	case Type.VOID:
 		// for now until we have enough of the front-end working.
-		
+
 	case Type.FORWARD:
 		// corresponding package must be forward-declared too
 		if typ.obj == nil || E.comp.pkg_list[typ.obj.pnolev].key != "" {
 			panic("inconsistency in package.type forward declaration");
 		}
-		
+
 	case Type.ALIAS, Type.MAP:
 		E.WriteType(typ.key);
 		E.WriteType(typ.elt);
@@ -202,7 +202,7 @@ func (E *Exporter) WriteType(typ *Globals.Type) {
 		E.WriteInt(typ.len);
 		E.WriteType(typ.elt);
 		E.WriteScope(typ.scope);
-		
+
 	case Type.STRUCT, Type.INTERFACE:
 		E.WriteScope(typ.scope);
 
@@ -240,10 +240,10 @@ func (E *Exporter) WriteObject(obj *Globals.Object) {
 
 	case Object.VAR, Object.FIELD:
 		E.WriteInt(0);  // should be the correct address/offset
-		
+
 	case Object.FUNC:
 		E.WriteInt(0);  // should be the correct address/offset
-		
+
 	default:
 		panic("UNREACHABLE");
 	}
@@ -256,13 +256,13 @@ func (E *Exporter) Export(comp* Globals.Compilation) string {
 	E.buf_pos = 0;
 	E.pkg_ref = 0;
 	E.type_ref = 0;
-	
+
 	// write magic bits
 	magic := Platform.MAGIC_obj_file;  // TODO remove once len(constant) works
 	for i := 0; i < len(magic); i++ {
 		E.WriteByte(magic[i]);
 	}
-	
+
 	// Predeclared types are "pre-exported".
 	// TODO run the loop below only in debug mode
 	{	i := 0;
@@ -274,21 +274,21 @@ func (E *Exporter) Export(comp* Globals.Compilation) string {
 		}
 	}
 	E.type_ref = Universe.types.len;
-	
+
 	// export package 0
 	pkg := comp.pkg_list[0];
 	E.WritePackage(pkg);
 	E.WriteScope(pkg.scope);
-	
+
 	if E.debug {
 		print("\n(", E.buf_pos, " bytes)\n");
 	}
-	
+
 	return string(E.buf)[0 : E.buf_pos];
 }
 
 
-export func Export(comp* Globals.Compilation) string {
+func Export(comp* Globals.Compilation) string {
 	var E Exporter;
 	return (&E).Export(comp);
 }
diff --git a/usr/gri/gosrc/expr.go b/usr/gri/gosrc/expr.go
index 2cf40df268..48681f6b85 100755
--- a/usr/gri/gosrc/expr.go
+++ b/usr/gri/gosrc/expr.go
@@ -21,24 +21,24 @@ func Error(comp *Globals.Compilation, pos int, msg string) {
 }
 
 
-export func Deref(comp *Globals.Compilation, x Globals.Expr) Globals.Expr {
+func Deref(comp *Globals.Compilation, x Globals.Expr) Globals.Expr {
 	switch typ := x.typ(); typ.form {
 	case Type.BAD:
 		// ignore
-		
+
 	case Type.POINTER:
 		x = AST.NewDeref(x);
-		
+
 	default:
 		Error(comp, x.pos(), `"*" not applicable (typ.form = ` + Type.FormStr(typ.form) + `)`);
 		x = AST.Bad;
 	}
-	
+
 	return x;
 }
 
 
-export func Select(comp *Globals.Compilation, x Globals.Expr, pos int, selector string) Globals.Expr {
+func Select(comp *Globals.Compilation, x Globals.Expr, pos int, selector string) Globals.Expr {
 	if x.typ().form == Type.POINTER {
 		x = Deref(comp, x);
 	}
@@ -51,7 +51,7 @@ export func Select(comp *Globals.Compilation, x Globals.Expr, pos int, selector
 		obj := typ.scope.Lookup(selector);
 		if obj != nil {
 			x = AST.NewSelector(x.pos(), obj.typ);
-			
+
 		} else {
 			Error(comp, pos, `no field/method "` + selector + `"`);
 			x = AST.Bad;
@@ -61,17 +61,17 @@ export func Select(comp *Globals.Compilation, x Globals.Expr, pos int, selector
 		Error(comp, pos, `"." not applicable (typ.form = ` + Type.FormStr(typ.form) + `)`);
 		x = AST.Bad;
 	}
-	
+
 	return x;
 }
 
 
-export func AssertType(comp *Globals.Compilation, x Globals.Expr, pos int, typ *Globals.Type) Globals.Expr {
+func AssertType(comp *Globals.Compilation, x Globals.Expr, pos int, typ *Globals.Type) Globals.Expr {
 	return AST.Bad;
 }
 
 
-export func Index(comp *Globals.Compilation, x, i Globals.Expr) Globals.Expr {
+func Index(comp *Globals.Compilation, x, i Globals.Expr) Globals.Expr {
 	if x.typ().form == Type.POINTER {
 		x = Deref(comp, x);
 	}
@@ -79,20 +79,20 @@ export func Index(comp *Globals.Compilation, x, i Globals.Expr) Globals.Expr {
 	switch typ := x.typ(); typ.form {
 	case Type.BAD:
 		// ignore
-		
+
 	case Type.STRING, Type.ARRAY:
 		x = AST.Bad;
-		
+
 	case Type.MAP:
 		if Type.Equal(typ.key, i.typ()) {
 			// x = AST.NewSubscript(x, i1);
 			x = AST.Bad;
-			
+
 		} else {
 			Error(comp, x.pos(), "map key type mismatch");
 			x = AST.Bad;
 		}
-		
+
 	default:
 		Error(comp, x.pos(), `"[]" not applicable (typ.form = ` + Type.FormStr(typ.form) + `)`);
 		x = AST.Bad;
@@ -101,7 +101,7 @@ export func Index(comp *Globals.Compilation, x, i Globals.Expr) Globals.Expr {
 }
 
 
-export func Slice(comp *Globals.Compilation, x, i, j Globals.Expr) Globals.Expr {
+func Slice(comp *Globals.Compilation, x, i, j Globals.Expr) Globals.Expr {
 	if x.typ().form == Type.POINTER {
 		x = Deref(comp, x);
 	}
@@ -112,17 +112,17 @@ export func Slice(comp *Globals.Compilation, x, i, j Globals.Expr) Globals.Expr
 		break;
 	case Type.STRING, Type.ARRAY:
 		x = AST.Bad;
-		
+
 	case Type.MAP:
 		if Type.Equal(typ.key, i.typ()) {
 			// x = AST.NewSubscript(x, i1);
 			x = AST.Bad;
-			
+
 		} else {
 			Error(comp, x.pos(), "map key type mismatch");
 			x = AST.Bad;
 		}
-		
+
 	default:
 		Error(comp, x.pos(), `"[:]" not applicable (typ.form = ` + Type.FormStr(typ.form) + `)`);
 		x = AST.Bad;
@@ -131,30 +131,30 @@ export func Slice(comp *Globals.Compilation, x, i, j Globals.Expr) Globals.Expr
 }
 
 
-export func Call(comp *Globals.Compilation, x Globals.Expr, args *Globals.List) Globals.Expr {
+func Call(comp *Globals.Compilation, x Globals.Expr, args *Globals.List) Globals.Expr {
 	if x.typ().form == Type.POINTER {
 		x = Deref(comp, x);
 	}
-	
+
 	if x.op() == AST.OBJECT && x.(*AST.Object).obj.kind == Object.BUILTIN {
 		panic("builtin call - UNIMPLEMENTED");
 	}
-	
+
 	typ := x.typ();
 	if typ.form == Type.FUNCTION || typ.form == Type.METHOD {
 		// TODO check args against parameters
 	}
-	
+
 	return AST.Bad;
 }
 
 
-export func UnaryExpr(comp *Globals.Compilation, x Globals.Expr) Globals.Expr {
+func UnaryExpr(comp *Globals.Compilation, x Globals.Expr) Globals.Expr {
 	return AST.Bad;
 }
 
 
-export func BinaryExpr(comp *Globals.Compilation, x, y Globals.Expr) Globals.Expr {
+func BinaryExpr(comp *Globals.Compilation, x, y Globals.Expr) Globals.Expr {
 	e := new(AST.BinaryExpr);
 	e.typ_ = x.typ();  // TODO fix this
 	//e.op = P.tok;  // TODO should we use tokens or separate operator constants?
diff --git a/usr/gri/gosrc/globals.go b/usr/gri/gosrc/globals.go
index 15e8d06e2e..7b2fb9cb92 100644
--- a/usr/gri/gosrc/globals.go
+++ b/usr/gri/gosrc/globals.go
@@ -23,7 +23,7 @@ type Compilation struct
 // source code (pos), has a name (ident), a type (typ), and a package number
 // or nesting level (pnolev).
 
-export type Object struct {
+type Object struct {
 	exported bool;
 	pos int;  // source position (< 0 if unknown position)
 	kind int;
@@ -33,7 +33,7 @@ export type Object struct {
 }
 
 
-export type Type struct {
+type Type struct {
 	ref int;  // for exporting only: >= 0 means already exported
 	form int;
 	size int;  // in bytes
@@ -46,7 +46,7 @@ export type Type struct {
 }
 
 
-export type Package struct {
+type Package struct {
 	ref int;  // for exporting only: >= 0 means already exported
 	file_name string;
 	key string;
@@ -55,20 +55,20 @@ export type Package struct {
 }
 
 
-export type List struct {
+type List struct {
 	len int;
 	first, last *Elem;
 };
 
 
-export type Scope struct {
+type Scope struct {
 	parent *Scope;
 	entries *List;
 	// entries map[string] *Object;  // doesn't work properly
 }
 
 
-export type Flags struct {
+type Flags struct {
 	debug bool;
 	object_file string;
 	update_packages bool;
@@ -79,7 +79,7 @@ export type Flags struct {
 }
 
 
-export type Environment struct {
+type Environment struct {
 	Error *(comp *Compilation, pos int, msg string);
 	Import *(comp *Compilation, pkg_file string) *Package;
 	Export *(comp *Compilation, pkg_file string);
@@ -87,26 +87,26 @@ export type Environment struct {
 }
 
 
-export type Compilation struct {
+type Compilation struct {
 	// environment
 	flags *Flags;
 	env *Environment;
-	
+
 	// TODO rethink the need for this here
 	src_file string;
 	src string;
-	
+
 	// Error handling
 	nerrors int;  // number of errors reported
 	errpos int;  // last error position
-	
+
 	// TODO use open arrays eventually
 	pkg_list [256] *Package;  // pkg_list[0] is the current package
 	pkg_ref int;
 }
 
 
-export type Expr interface {
+type Expr interface {
 	op() int;  // node operation
 	pos() int;  // source position
 	typ() *Type;
@@ -114,7 +114,7 @@ export type Expr interface {
 }
 
 
-export type Stat interface {
+type Stat interface {
 	// ... more to come here
 }
 
@@ -122,7 +122,7 @@ export type Stat interface {
 // TODO This is hideous! We need to have a decent way to do lists.
 // Ideally open arrays that allow '+'.
 
-export type Elem struct {
+type Elem struct {
 	next *Elem;
 	val int;
 	str string;
@@ -135,9 +135,9 @@ export type Elem struct {
 // ----------------------------------------------------------------------------
 // Creation
 
-export var Universe_void_t *Type  // initialized by Universe to Universe.void_t
+var Universe_void_t *Type  // initialized by Universe to Universe.void_t
 
-export func NewObject(pos, kind int, ident string) *Object {
+func NewObject(pos, kind int, ident string) *Object {
 	obj := new(Object);
 	obj.exported = false;
 	obj.pos = pos;
@@ -149,7 +149,7 @@ export func NewObject(pos, kind int, ident string) *Object {
 }
 
 
-export func NewType(form int) *Type {
+func NewType(form int) *Type {
 	typ := new(Type);
 	typ.ref = -1;  // not yet exported
 	typ.form = form;
@@ -157,7 +157,7 @@ export func NewType(form int) *Type {
 }
 
 
-export func NewPackage(file_name string, obj *Object, scope *Scope) *Package {
+func NewPackage(file_name string, obj *Object, scope *Scope) *Package {
 	pkg := new(Package);
 	pkg.ref = -1;  // not yet exported
 	pkg.file_name = file_name;
@@ -168,12 +168,12 @@ export func NewPackage(file_name string, obj *Object, scope *Scope) *Package {
 }
 
 
-export func NewList() *List {
+func NewList() *List {
 	return new(List);
 }
 
 
-export func NewScope(parent *Scope) *Scope {
+func NewScope(parent *Scope) *Scope {
 	scope := new(Scope);
 	scope.parent = parent;
 	scope.entries = NewList();
diff --git a/usr/gri/gosrc/import.go b/usr/gri/gosrc/import.go
index 104f3d7e2a..d86d6ef28c 100755
--- a/usr/gri/gosrc/import.go
+++ b/usr/gri/gosrc/import.go
@@ -120,7 +120,7 @@ func (I *Importer) ReadPackage() *Globals.Package {
 	ident := I.ReadString();
 	file_name := I.ReadString();
 	key := I.ReadString();
-	
+
 	// Canonicalize package - if it was imported before,
 	// use the primary import.
 	pkg := I.comp.Lookup(file_name);
@@ -162,7 +162,7 @@ func (I *Importer) ReadScope(scope *Globals.Scope, allow_multiples bool) {
 		}
 		obj = I.ReadObject();
 	}
-	
+
 	if I.debug {
 		print(" }");
 	}
@@ -182,7 +182,7 @@ func (I *Importer) ReadType() *Globals.Type {
 	if len(ident) > 0 {
 		// named type
 		pkg := I.ReadPackage();
-		
+
 		// create corresponding type object
 		obj := Globals.NewObject(0, Object.TYPE, ident);
 		obj.exported = true;
@@ -204,13 +204,13 @@ func (I *Importer) ReadType() *Globals.Type {
 		// for now until we have enough of the front-end working
 		// change the form to BAD to avoid error messages
 		typ.form = Type.BAD;
-		
+
 	case Type.FORWARD:
 		typ.scope = Globals.NewScope(nil);
-		
+
 	case Type.TUPLE:
 		typ.elt = I.ReadType();
-		
+
 	case Type.ALIAS, Type.MAP:
 		typ.key = I.ReadType();
 		typ.elt = I.ReadType();
@@ -249,7 +249,7 @@ func (I *Importer) ReadObject() *Globals.Object {
 	if tag == Object.END {
 		return nil;
 	}
-	
+
 	if tag == Object.TYPE {
 		// named types are handled entirely by ReadType()
 		typ := I.ReadType();
@@ -258,7 +258,7 @@ func (I *Importer) ReadObject() *Globals.Object {
 		}
 		return typ.obj;
 	}
-	
+
 	ident := I.ReadString();
 	obj := Globals.NewObject(0, tag, ident);
 	obj.exported = true;
@@ -273,7 +273,7 @@ func (I *Importer) ReadObject() *Globals.Object {
 
 	case Object.FUNC:
 		I.ReadInt();  // should set the address/offset field
-		
+
 	default:
 		panic("UNREACHABLE");
 	}
@@ -289,12 +289,12 @@ func (I *Importer) Import(comp* Globals.Compilation, data string) *Globals.Packa
 	I.buf_pos = 0;
 	I.pkg_ref = 0;
 	I.type_ref = 0;
-	
+
 	// check magic bits
 	if !Utils.Contains(data, Platform.MAGIC_obj_file, 0) {
 		return nil;
 	}
-	
+
 	// Predeclared types are "pre-imported".
 	for p := Universe.types.first; p != nil; p = p.next {
 		if p.typ.ref != I.type_ref {
@@ -307,16 +307,16 @@ func (I *Importer) Import(comp* Globals.Compilation, data string) *Globals.Packa
 	// import package
 	pkg := I.ReadPackage();
 	I.ReadScope(pkg.scope, true);
-	
+
 	if I.debug {
 		print("\n(", I.buf_pos, " bytes)\n");
 	}
-	
+
 	return pkg;
 }
 
 
-export func Import(comp *Globals.Compilation, data string) *Globals.Package {
+func Import(comp *Globals.Compilation, data string) *Globals.Package {
 	var I Importer;
 	pkg := (&I).Import(comp, data);
 	return pkg;
diff --git a/usr/gri/gosrc/object.go b/usr/gri/gosrc/object.go
index 220f4c8d8b..718796095c 100755
--- a/usr/gri/gosrc/object.go
+++ b/usr/gri/gosrc/object.go
@@ -7,7 +7,7 @@ package Object
 import Globals "globals"
 
 
-export const /* kind */ (
+const /* kind */ (
 	BAD = iota;  // error handling
 	CONST; TYPE; VAR; FIELD; FUNC; BUILTIN; PACKAGE; LABEL;
 	END;  // end of scope (import/export only)
@@ -19,7 +19,7 @@ export const /* kind */ (
 // globals.go.
 
 
-export func KindStr(kind int) string {
+func KindStr(kind int) string {
 	switch kind {
 	case BAD: return "BAD";
 	case CONST: return "CONST";
diff --git a/usr/gri/gosrc/parser.go b/usr/gri/gosrc/parser.go
index 4ba0d99803..a6064316ca 100644
--- a/usr/gri/gosrc/parser.go
+++ b/usr/gri/gosrc/parser.go
@@ -15,13 +15,13 @@ import AST "ast"
 import Expr "expr"
 
 
-export type Parser struct {
+type Parser struct {
 	comp *Globals.Compilation;
 	verbose bool;
 	indent uint;
 	scanner *Scanner.Scanner;
 	tokchan chan *Scanner.Token;
-	
+
 	// Token
 	tok int;  // one token look-ahead
 	pos int;  // token source position
@@ -372,7 +372,7 @@ func (P *Parser) ParseVarType() *Globals.Type {
 		}
 		// open arrays must be pointers
 		fallthrough;
-		
+
 	case Type.MAP, Type.CHANNEL, Type.FUNCTION:
 		P.Error(pos, "must be pointer to this type");
 		typ = Universe.bad_t;
@@ -696,7 +696,7 @@ func (P *Parser) ParsePointerType() *Globals.Type {
 				// TODO introduce dummy package so we can continue safely
 			}
 		}
-		
+
 		P.Next();  // consume package name
 		P.Expect(Scanner.PERIOD);
 		pos, ident := P.ParseIdent(false);
@@ -716,11 +716,11 @@ func (P *Parser) ParsePointerType() *Globals.Type {
 			}
 			elt = obj.typ;
 		}
-		
+
 	} else if P.tok == Scanner.IDENT {
 		if P.Lookup(P.val) == nil {
 			// implicit type forward declaration
-			// create a named forward type 
+			// create a named forward type
 			pos, ident := P.ParseIdent(false);
 			obj := Globals.NewObject(pos, Object.TYPE, ident);
 			elt = Globals.NewType(Type.FORWARD);
@@ -1000,7 +1000,7 @@ func (P *Parser) ParseSelectorOrTypeAssertion(x Globals.Expr) Globals.Expr {
 
 	P.Expect(Scanner.PERIOD);
 	pos := P.pos;
-	
+
 	if P.tok >= Scanner.IDENT {
 		pos, selector := P.ParseIdent(true);
 		x = Expr.Select(P.comp, x, pos, selector);
@@ -1102,7 +1102,7 @@ func (P *Parser) ParseUnaryExpr() Globals.Expr {
 		P.Ecart();
 		return x;  // TODO fix this
 	}
-	
+
 	x := P.ParsePrimaryExpr(-1, "");
 
 	P.Ecart();
@@ -1246,7 +1246,7 @@ func (P *Parser) ParseIdentOrExprList() (pos_list, ident_list, expr_list *Global
 
 	pos_list, ident_list = Globals.NewList(), Globals.NewList();  // "pairs" of (pos, ident)
 	expr_list = Globals.NewList();
-	
+
 	P.ParseIdentOrExpr(pos_list, ident_list, expr_list);
 	for P.tok == Scanner.COMMA {
 		P.Next();
@@ -1336,14 +1336,14 @@ func (P *Parser) ParseSimpleStat() {
 		P.Next();
 		pos := P.pos;
 		val_list := P.ParseNewExpressionList();
-		
+
 		// assign variables
 		if val_list.len == 1 && val_list.first.expr.typ().form == Type.TUPLE {
 			panic("UNIMPLEMENTED");
 		} else {
 			var p, q *Globals.Elem;
 			for p, q = expr_list.first, val_list.first; p != nil && q != nil; p, q = p.next, q.next {
-				
+
 			}
 			if p != nil || q != nil {
 				P.Error(pos, "number of expressions does not match number of variables");
@@ -2016,7 +2016,7 @@ func (P *Parser) ParseProgram() {
 				P.Error(P.pos, `pre-import of package "sys" failed`);
 			}
 		}
-		
+
 		for P.tok == Scanner.IMPORT {
 			P.ParseDecl(false, Scanner.IMPORT);
 			P.Optional(Scanner.SEMICOLON);
diff --git a/usr/gri/gosrc/platform.go b/usr/gri/gosrc/platform.go
index 6e96b4ada1..0e1c09a76c 100644
--- a/usr/gri/gosrc/platform.go
+++ b/usr/gri/gosrc/platform.go
@@ -10,7 +10,7 @@ import Utils "utils"
 // ----------------------------------------------------------------------------
 // Environment
 
-export var
+var
 	GOARCH,
 	GOOS,
 	GOROOT,
@@ -40,14 +40,14 @@ func init() {
 // ----------------------------------------------------------------------------
 // I/O
 
-export const (
+const (
 	MAGIC_obj_file = "@gri-go.7@v0";  // make it clear thar it cannot be a source file
 	src_file_ext = ".go";
 	obj_file_ext = ".7";
 )
 
 
-export func ReadObjectFile(filename string) (data string, ok bool) {
+func ReadObjectFile(filename string) (data string, ok bool) {
 	data, ok = sys.readfile(filename + obj_file_ext);
 	magic := MAGIC_obj_file;  // TODO remove once len(constant) works
 	if ok && len(data) >= len(magic) && data[0 : len(magic)] == magic {
@@ -57,14 +57,14 @@ export func ReadObjectFile(filename string) (data string, ok bool) {
 }
 
 
-export func ReadSourceFile(name string) (data string, ok bool) {
+func ReadSourceFile(name string) (data string, ok bool) {
 	name = Utils.TrimExt(name, src_file_ext) + src_file_ext;
 	data, ok = sys.readfile(name);
 	return data, ok;
 }
 
 
-export func WriteObjectFile(name string, data string) bool {
+func WriteObjectFile(name string, data string) bool {
 	name = Utils.TrimExt(Utils.BaseName(name), src_file_ext) + obj_file_ext;
 	return sys.writefile(name, data);
 }
diff --git a/usr/gri/gosrc/printer.go b/usr/gri/gosrc/printer.go
index c75152b0e3..ce5f5f6cd6 100755
--- a/usr/gri/gosrc/printer.go
+++ b/usr/gri/gosrc/printer.go
@@ -67,7 +67,7 @@ func (P *Printer) PrintSignature(typ *Globals.Type, fun *Globals.Object) {
 	}
 	r0 := p0 + typ.len;
 	l0 := typ.scope.entries.len;
-	
+
 	if P.level == 0 {
 		print("func ");
 
@@ -76,14 +76,14 @@ func (P *Printer) PrintSignature(typ *Globals.Type, fun *Globals.Object) {
 			print(" ");
 		}
 	}
-	
+
 	if fun != nil {
 		P.PrintObject(fun);
 		//print(" ");
 	} else if p0 > 0 {
 		print(". ");
 	}
-	
+
 	P.PrintSigRange(typ, p0, r0);
 
 	if r0 < l0 {
@@ -114,7 +114,7 @@ func (P *Printer) PrintScope(scope *Globals.Scope, delta int) {
 			}
 		}
 	}
-	
+
 	// print the scope
 	const scale = 2;
 	if n > 0 {
@@ -164,7 +164,7 @@ func (P *Printer) PrintObjectStruct(obj *Globals.Object) {
 	case Object.BUILTIN:
 		P.PrintObject(obj);
 		print(" /* builtin */");
-		
+
 	case Object.PACKAGE:
 		print("package ");
 		P.PrintObject(obj);
@@ -174,7 +174,7 @@ func (P *Printer) PrintObjectStruct(obj *Globals.Object) {
 	default:
 		panic("UNREACHABLE");
 	}
-	
+
 	if P.level > 0 {
 		print(";");
 	}
@@ -201,7 +201,7 @@ func (P *Printer) PrintTypeStruct(typ *Globals.Type) {
 	switch typ.form {
 	case Type.VOID:
 		print("void");
-		
+
 	case Type.BAD:
 		print("<bad type>");
 
@@ -224,7 +224,7 @@ func (P *Printer) PrintTypeStruct(typ *Globals.Type) {
 			P.PrintType(typ.key);
 			print(" */");
 		}
-		
+
 	case Type.ARRAY:
 		print("[]");
 		P.PrintType(typ.elt);
@@ -263,7 +263,7 @@ func (P *Printer) PrintTypeStruct(typ *Globals.Type) {
 
 	default:
 		panic("UNREACHABLE");
-		
+
 	}
 }
 
@@ -277,7 +277,7 @@ func (P *Printer) PrintType(typ *Globals.Type) {
 }
 
 
-export func PrintObject(comp *Globals.Compilation, obj *Globals.Object, print_all bool) {
+func PrintObject(comp *Globals.Compilation, obj *Globals.Object, print_all bool) {
 	var P Printer;
 	(&P).Init(comp, print_all);
 	(&P).PrintObjectStruct(obj);
diff --git a/usr/gri/gosrc/scanner.go b/usr/gri/gosrc/scanner.go
index ac3c3fd409..158274e132 100644
--- a/usr/gri/gosrc/scanner.go
+++ b/usr/gri/gosrc/scanner.go
@@ -8,7 +8,7 @@ import Platform "platform"
 import Utils "utils"
 
 
-export const (
+const (
 	ILLEGAL = iota;
 	EOF;
 	INT;
@@ -110,7 +110,7 @@ var Keywords map [string] int;
 var VerboseMsgs bool;  // error message customization
 
 
-export func TokenName(tok int) string {
+func TokenName(tok int) string {
 	switch (tok) {
 	case ILLEGAL: return "illegal";
 	case EOF: return "eof";
@@ -244,7 +244,7 @@ func digit_val(ch int) int {
 }
 
 
-export type Scanner struct {
+type Scanner struct {
 	filename string;  // error reporting only
 	nerrors int;  // number of errors
 	errpos int;  // last error position
@@ -766,7 +766,7 @@ func (S *Scanner) Scan() (tok, pos int, val string) {
 }
 
 
-export type Token struct {
+type Token struct {
 	pos int;
 	tok int;
 	val string;
diff --git a/usr/gri/gosrc/test/b.go b/usr/gri/gosrc/test/b.go
index 4d4b02e06f..a3a6b4363d 100644
--- a/usr/gri/gosrc/test/b.go
+++ b/usr/gri/gosrc/test/b.go
@@ -3,10 +3,10 @@ package B
 import C "c"
 import D "d"
 
-export type T1 C.T1;
-export type T2 D.T2;
+type T1 C.T1;
+type T2 D.T2;
 
-export var (
+var (
 	v0 D.T1;
 	v1 C.T1;
 	v2 *C.F1;
diff --git a/usr/gri/gosrc/test/c.go b/usr/gri/gosrc/test/c.go
index 5f5981aa30..63ad3fb35c 100644
--- a/usr/gri/gosrc/test/c.go
+++ b/usr/gri/gosrc/test/c.go
@@ -2,6 +2,6 @@ package C
 
 import "d"
 
-export type T1 D.T1;
-export type T2 D.T2;
-export type F1 (a D.T1, b *D.T2);
+type T1 D.T1;
+type T2 D.T2;
+type F1 (a D.T1, b *D.T2);
diff --git a/usr/gri/gosrc/test/d.go b/usr/gri/gosrc/test/d.go
index e9d87e8374..9d2eb50c67 100644
--- a/usr/gri/gosrc/test/d.go
+++ b/usr/gri/gosrc/test/d.go
@@ -2,18 +2,18 @@ package D
 
 type T0 int
 
-export type T1 struct {
+type T1 struct {
 	n int;
 	a, b T0;
 }
 
-export type T2 struct {
+type T2 struct {
 	u, v float;
 }
 
-export func (obj *T2) M1(u, v float) {
+func (obj *T2) M1(u, v float) {
 }
 
-export func F0(a int, b T0) int {
+func F0(a int, b T0) int {
 	return a + b;
 }
\ No newline at end of file
diff --git a/usr/gri/gosrc/type.go b/usr/gri/gosrc/type.go
index 5c80ad1a53..ad940dc569 100644
--- a/usr/gri/gosrc/type.go
+++ b/usr/gri/gosrc/type.go
@@ -8,20 +8,20 @@ import Globals "globals"
 import Object "object"
 
 
-export const /* form */ (
+const /* form */ (
 	// internal types
 	// We should never see one of these.
 	UNDEF = iota;
-	
+
 	// VOID types are used when we don't have a type. Never exported.
 	// (exported type forms must be > 0)
 	VOID;
-	
+
 	// BAD types are compatible with any type and don't cause further errors.
 	// They are introduced only as a result of an error in the source code. A
 	// correct program cannot have BAD types.
 	BAD;
-	
+
 	// FORWARD types are forward-declared (incomplete) types. They can only
 	// be used as element types of pointer types and must be resolved before
 	// their internals are accessible.
@@ -30,22 +30,22 @@ export const /* form */ (
 	// TUPLE types represent multi-valued result types of functions and
 	// methods.
 	TUPLE;
-	
+
 	// The type of nil.
 	NIL;
 
 	// basic types
 	BOOL; UINT; INT; FLOAT; STRING; INTEGER;
-	
+
 	// 'any' type  // TODO this should go away eventually
 	ANY;
-	
+
 	// composite types
 	ALIAS; ARRAY; STRUCT; INTERFACE; MAP; CHANNEL; FUNCTION; METHOD; POINTER;
 )
 
 
-export const /* Type.aux */ (
+const /* Type.aux */ (
 	SEND = 1;  // chan>
 	RECV = 2;  // chan<
 )
@@ -56,7 +56,7 @@ export const /* Type.aux */ (
 // globals.go.
 
 
-export func FormStr(form int) string {
+func FormStr(form int) string {
 	switch form {
 	case VOID: return "VOID";
 	case BAD: return "BAD";
@@ -83,7 +83,7 @@ export func FormStr(form int) string {
 }
 
 
-export func Equal(x, y *Globals.Type) bool;
+func Equal(x, y *Globals.Type) bool;
 
 func Equal0(x, y *Globals.Type) bool {
 	if x == y {
@@ -94,7 +94,7 @@ func Equal0(x, y *Globals.Type) bool {
 		return true;  // bad types are always equal (avoid excess error messages)
 	}
 
-	// TODO where to check for *T == nil ?  
+	// TODO where to check for *T == nil ?
 	if x.form != y.form {
 		return false;  // types of different forms are not equal
 	}
@@ -173,7 +173,7 @@ func Equal0(x, y *Globals.Type) bool {
 
 	case POINTER:
 		return Equal(x.elt, y.elt);
-		
+
 	case TUPLE:
 		panic("UNIMPLEMENTED");
 		return false;
@@ -184,7 +184,7 @@ func Equal0(x, y *Globals.Type) bool {
 }
 
 
-export func Equal(x, y *Globals.Type) bool {
+func Equal(x, y *Globals.Type) bool {
 	res := Equal0(x, y);
 	// TODO should do the check below only in debug mode
 	if Equal0(y, x) != res {
@@ -194,11 +194,11 @@ export func Equal(x, y *Globals.Type) bool {
 }
 
 
-export func Assigneable(from, to *Globals.Type) bool {
+func Assigneable(from, to *Globals.Type) bool {
 	if Equal(from, to) {
 		return true;
 	}
-	
+
 	panic("UNIMPLEMENTED");
 	return false;
 }
diff --git a/usr/gri/gosrc/universe.go b/usr/gri/gosrc/universe.go
index a5d11f9ae9..95111fcd4a 100755
--- a/usr/gri/gosrc/universe.go
+++ b/usr/gri/gosrc/universe.go
@@ -9,15 +9,15 @@ import Object "object"
 import Type "type"
 
 
-export var (
+var (
 	scope *Globals.Scope;
 	types *Globals.List;
-	
+
 	// internal types
 	void_t,
 	bad_t,
 	nil_t,
-	
+
 	// basic types
 	bool_t,
 	uint8_t,
@@ -34,7 +34,7 @@ export var (
 	string_t,
 	integer_t,
 	any_t,
-	
+
 	// alias types
 	byte_t,
 	ushort_t,
@@ -46,7 +46,7 @@ export var (
 	float_t,
 	double_t,
 	ptrint_t *Globals.Type;
-	
+
 	true_,
 	false_,
 	iota_,
@@ -93,13 +93,13 @@ func Register(typ *Globals.Type) *Globals.Type {
 func init() {
 	scope = Globals.NewScope(nil);  // universe has no parent
 	types = Globals.NewList();
-	
+
 	// Interal types
 	void_t = Globals.NewType(Type.VOID);
 	Globals.Universe_void_t = void_t;
 	bad_t = Globals.NewType(Type.BAD);
 	nil_t = Globals.NewType(Type.NIL);
-	
+
 	// Basic types
 	bool_t = Register(DeclType(Type.BOOL, "bool", 1));
 	uint8_t = Register(DeclType(Type.UINT, "uint8", 1));
@@ -140,6 +140,6 @@ func init() {
 	DeclObj(Object.BUILTIN, "new", void_t);
 	DeclObj(Object.BUILTIN, "panic", void_t);
 	DeclObj(Object.BUILTIN, "print", void_t);
-	
+
 	// scope.Print();
 }
diff --git a/usr/gri/gosrc/utils.go b/usr/gri/gosrc/utils.go
index 0764a2f8ca..57a8d323a0 100644
--- a/usr/gri/gosrc/utils.go
+++ b/usr/gri/gosrc/utils.go
@@ -5,7 +5,7 @@
 package Utils
 
 
-export func BaseName(s string) string {
+func BaseName(s string) string {
 	// TODO this is not correct for non-ASCII strings!
 	i := len(s) - 1;
 	for i >= 0 && s[i] != '/' {
@@ -18,13 +18,13 @@ export func BaseName(s string) string {
 }
 
 
-export func Contains(s, sub string, pos int) bool {
+func Contains(s, sub string, pos int) bool {
 	end := pos + len(sub);
 	return pos >= 0 && end <= len(s) && s[pos : end] == sub;
 }
 
 
-export func TrimExt(s, ext string) string {
+func TrimExt(s, ext string) string {
 	i := len(s) - len(ext);
 	if i >= 0 && s[i : len(s)] == ext {
 		s = s[0 : i];
@@ -33,7 +33,7 @@ export func TrimExt(s, ext string) string {
 }
 
 
-export func IntToString(x, base int) string {
+func IntToString(x, base int) string {
 	x0 := x;
 	if x < 0 {
 		x = -x;
@@ -53,11 +53,11 @@ export func IntToString(x, base int) string {
 		buf[i] = hex[x % base];
 		x /= base;
 	}
-	
+
 	if x0 < 0 {
 		i--;
 		buf[i] = '-';
 	}
-	
+
 	return string(buf)[i : len(buf)];
 }
diff --git a/usr/gri/gosrc/verifier.go b/usr/gri/gosrc/verifier.go
index 640a8ff742..dbb5ffd245 100644
--- a/usr/gri/gosrc/verifier.go
+++ b/usr/gri/gosrc/verifier.go
@@ -48,7 +48,7 @@ func (V *Verifier) VerifyType(typ *Globals.Type) {
 	case Type.VOID:
 	case Type.BAD:
 		break;  // TODO for now - remove eventually
-		
+
 	case Type.FORWARD:
 		if typ.scope == nil {
 			Error("forward types must have a scope");
@@ -159,7 +159,7 @@ func (V *Verifier) Verify(comp *Globals.Compilation) {
 }
 
 
-export func Verify(comp *Globals.Compilation) {
+func Verify(comp *Globals.Compilation) {
 	V := new(Verifier);
 	V.Verify(comp);
 }
diff --git a/usr/gri/pretty/ast.go b/usr/gri/pretty/ast.go
index 84c404eb78..1790a08510 100644
--- a/usr/gri/pretty/ast.go
+++ b/usr/gri/pretty/ast.go
@@ -12,7 +12,7 @@ import (
 )
 
 
-export type (
+type (
 	Object struct;
 	Type struct;
 
@@ -27,7 +27,7 @@ export type (
 
 // Object represents a language object, such as a constant, variable, type, etc.
 
-export const /* kind */ (
+const /* kind */ (
 	BADOBJ = iota;  // error handling
 	NONE;  // kind unknown
 	CONST; TYPE; VAR; FIELD; FUNC; BUILTIN; PACKAGE; LABEL;
@@ -35,7 +35,7 @@ export const /* kind */ (
 )
 
 
-export func KindStr(kind int) string {
+func KindStr(kind int) string {
 	switch kind {
 	case BADOBJ: return "BADOBJ";
 	case NONE: return "NONE";
@@ -53,7 +53,7 @@ export func KindStr(kind int) string {
 }
 
 
-export type Object struct {
+type Object struct {
 	Id int;  // unique id
 
 	Pos int;  // source position (< 0 if unknown position)
@@ -61,7 +61,7 @@ export type Object struct {
 	Ident string;
 	Typ *Type;  // nil for packages
 	Pnolev int;  // >= 0: package no., <= 0: function nesting level, 0: global level
-	
+
 	// attached values
 	Block *array.Array; End int;  // stats for function literals; end of block pos
 }
@@ -77,14 +77,14 @@ func (obj *Object) IsExported() bool {
 }
 
 
-export var Universe_void_typ *Type  // initialized by Universe to Universe.void_typ
+var Universe_void_typ *Type  // initialized by Universe to Universe.void_typ
 var objectId int;
 
-export func NewObject(pos, kind int, ident string) *Object {
+func NewObject(pos, kind int, ident string) *Object {
 	obj := new(Object);
 	obj.Id = objectId;
 	objectId++;
-	
+
 	obj.Pos = pos;
 	obj.Kind = kind;
 	obj.Ident = ident;
@@ -98,13 +98,13 @@ export func NewObject(pos, kind int, ident string) *Object {
 // ----------------------------------------------------------------------------
 // Scopes
 
-export type Scope struct {
+type Scope struct {
 	Parent *Scope;
 	entries map[string] *Object;
 }
 
 
-export func NewScope(parent *Scope) *Scope {
+func NewScope(parent *Scope) *Scope {
 	scope := new(Scope);
 	scope.Parent = parent;
 	scope.entries = make(map[string]*Object, 8);
@@ -168,7 +168,7 @@ func (scope *Scope) Print() {
 // ----------------------------------------------------------------------------
 // All nodes have a source position and and token.
 
-export type Node struct {
+type Node struct {
 	Pos int;  // source position (< 0 => unknown position)
 	Tok int;  // identifying token
 }
@@ -177,7 +177,7 @@ export type Node struct {
 // ----------------------------------------------------------------------------
 // Expressions
 
-export type Expr struct {
+type Expr struct {
 	Node;
 	X, Y *Expr;  // binary (X, Y) and unary (Y) expressions
 	Obj *Object;
@@ -196,7 +196,7 @@ func (x *Expr) Len() int {
 }
 
 
-export func NewExpr(pos, tok int, x, y *Expr) *Expr {
+func NewExpr(pos, tok int, x, y *Expr) *Expr {
 	if x != nil && x.Tok == Scanner.TYPE || y != nil && y.Tok == Scanner.TYPE {
 		panic("no type expression allowed");
 	}
@@ -207,33 +207,33 @@ export func NewExpr(pos, tok int, x, y *Expr) *Expr {
 
 
 // TODO probably don't need the tok parameter eventually
-export func NewLit(tok int, obj *Object) *Expr {
+func NewLit(tok int, obj *Object) *Expr {
 	e := new(Expr);
 	e.Pos, e.Tok, e.Obj = obj.Pos, tok, obj;
 	return e;
 }
 
 
-export var BadExpr = NewExpr(0, Scanner.ILLEGAL, nil, nil);
+var BadExpr = NewExpr(0, Scanner.ILLEGAL, nil, nil);
 
 
 // ----------------------------------------------------------------------------
 // Types
 
-export const /* form */ (
+const /* form */ (
 	// internal types
 	// We should never see one of these.
 	UNDEF = iota;
-	
+
 	// VOID types are used when we don't have a type. Never exported.
 	// (exported type forms must be > 0)
 	VOID;
-	
+
 	// BADTYPE types are compatible with any type and don't cause further errors.
 	// They are introduced only as a result of an error in the source code. A
 	// correct program cannot have BAD types.
 	BADTYPE;
-	
+
 	// FORWARD types are forward-declared (incomplete) types. They can only
 	// be used as element types of pointer types and must be resolved before
 	// their internals are accessible.
@@ -242,7 +242,7 @@ export const /* form */ (
 	// TUPLE types represent multi-valued result types of functions and
 	// methods.
 	TUPLE;
-	
+
 	// The type of nil.
 	NIL;
 
@@ -251,16 +251,16 @@ export const /* form */ (
 
 	// basic types
 	BOOL; UINT; INT; FLOAT; STRING; INTEGER;
-	
+
 	// composite types
 	ALIAS; ARRAY; STRUCT; INTERFACE; MAP; CHANNEL; FUNCTION; METHOD; POINTER;
-	
+
 	// open-ended parameter type
 	ELLIPSIS
 )
 
 
-export func FormStr(form int) string {
+func FormStr(form int) string {
 	switch form {
 	case VOID: return "VOID";
 	case BADTYPE: return "BADTYPE";
@@ -288,14 +288,14 @@ export func FormStr(form int) string {
 }
 
 
-export const /* channel mode */ (
+const /* channel mode */ (
 	FULL = iota;
 	SEND;
 	RECV;
 )
 
 
-export type Type struct {
+type Type struct {
 	Id int;  // unique id
 
 	Ref int;  // for exporting only: >= 0 means already exported
@@ -317,7 +317,7 @@ export type Type struct {
 
 var typeId int;
 
-export func NewType(pos, form int) *Type {
+func NewType(pos, form int) *Type {
 	typ := new(Type);
 	typ.Id = typeId;
 	typeId++;
@@ -350,20 +350,20 @@ func (t *Type) Nfields() int {
 
 
 // requires complete Type.Pos access
-export func NewTypeExpr(typ *Type) *Expr {
+func NewTypeExpr(typ *Type) *Expr {
 	obj := NewObject(typ.Pos, TYPE, "");
 	obj.Typ = typ;
 	return NewLit(Scanner.TYPE, obj);
 }
 
 
-export var BadType = NewType(0, Scanner.ILLEGAL);
+var BadType = NewType(0, Scanner.ILLEGAL);
 
 
 // ----------------------------------------------------------------------------
 // Statements
 
-export type Stat struct {
+type Stat struct {
 	Node;
 	Init, Post *Stat;
 	Expr *Expr;
@@ -372,20 +372,20 @@ export type Stat struct {
 }
 
 
-export func NewStat(pos, tok int) *Stat {
+func NewStat(pos, tok int) *Stat {
 	s := new(Stat);
 	s.Pos, s.Tok = pos, tok;
 	return s;
 }
 
 
-export var BadStat = NewStat(0, Scanner.ILLEGAL);
+var BadStat = NewStat(0, Scanner.ILLEGAL);
 
 
 // ----------------------------------------------------------------------------
 // Declarations
 
-export type Decl struct {
+type Decl struct {
 	Node;
 	Exported bool;
 	Ident *Expr;  // nil for ()-style declarations
@@ -397,33 +397,33 @@ export type Decl struct {
 }
 
 
-export func NewDecl(pos, tok int, exported bool) *Decl {
+func NewDecl(pos, tok int, exported bool) *Decl {
 	d := new(Decl);
 	d.Pos, d.Tok, d.Exported = pos, tok, exported;
 	return d;
 }
 
 
-export var BadDecl = NewDecl(0, Scanner.ILLEGAL, false);
+var BadDecl = NewDecl(0, Scanner.ILLEGAL, false);
 
 
 // ----------------------------------------------------------------------------
 // Program
 
-export type Comment struct {
+type Comment struct {
 	Pos int;
 	Text string;
 }
 
 
-export func NewComment(pos int, text string) *Comment {
+func NewComment(pos int, text string) *Comment {
 	c := new(Comment);
 	c.Pos, c.Text = pos, text;
 	return c;
 }
 
 
-export type Program struct {
+type Program struct {
 	Pos int;  // tok is Scanner.PACKAGE
 	Ident *Expr;
 	Decls *array.Array;
@@ -431,7 +431,7 @@ export type Program struct {
 }
 
 
-export func NewProgram(pos int) *Program {
+func NewProgram(pos int) *Program {
 	p := new(Program);
 	p.Pos = pos;
 	return p;
diff --git a/usr/gri/pretty/compilation.go b/usr/gri/pretty/compilation.go
index 1d8f3cf1dd..cb4d62aa36 100644
--- a/usr/gri/pretty/compilation.go
+++ b/usr/gri/pretty/compilation.go
@@ -23,7 +23,7 @@ func assert(b bool) {
 }
 
 
-export type Flags struct {
+type Flags struct {
 	Verbose bool;
 	Sixg bool;
 	Deps bool;
@@ -117,7 +117,7 @@ func (h *errorHandler) Warning(pos int, msg string) {
 }
 
 
-export func Compile(src_file string, flags *Flags) (*AST.Program, int) {
+func Compile(src_file string, flags *Flags) (*AST.Program, int) {
 	src, ok := Platform.ReadSourceFile(src_file);
 	if !ok {
 		print("cannot open ", src_file, "\n");
@@ -202,7 +202,7 @@ func addDeps(globalset map [string] bool, wset *array.Array, src_file string, fl
 }
 
 
-export func ComputeDeps(src_file string, flags *Flags) {
+func ComputeDeps(src_file string, flags *Flags) {
 	globalset := make(map [string] bool);
 	wset := array.New(0);
 	wset.Push(src_file);
diff --git a/usr/gri/pretty/parser.go b/usr/gri/pretty/parser.go
index d72eeccd89..10355e878e 100644
--- a/usr/gri/pretty/parser.go
+++ b/usr/gri/pretty/parser.go
@@ -11,7 +11,7 @@ import (
 )
 
 
-export type Parser struct {
+type Parser struct {
 	// Tracing/debugging
 	verbose, sixg, deps, naming bool;
 	indent uint;
@@ -32,7 +32,7 @@ export type Parser struct {
 	// Nesting levels
 	expr_lev int;  // 0 = control clause level, 1 = expr inside ()'s
 	scope_lev int;  // 0 = global scope, 1 = function scope of global functions, etc.
-	
+
 	// Scopes
 	top_scope *AST.Scope;
 };
@@ -266,7 +266,7 @@ func (P *Parser) ParseDeclaration() *AST.Decl;
 // If scope != nil, lookup identifier in scope. Otherwise create one.
 func (P *Parser) ParseIdent(scope *AST.Scope) *AST.Expr {
 	P.Trace("Ident");
-	
+
 	x := AST.BadExpr;
 	if P.tok == Scanner.IDENT {
 		var obj *AST.Object;
@@ -1536,7 +1536,7 @@ func (P *Parser) ParseConstSpec(exported bool, pos int) *AST.Decl {
 		P.Next();
 		d.Val = P.ParseExpressionList();
 	}
-	
+
 	P.Declare(d.Ident, AST.CONST);
 	P.VerifyExport(d.Ident, exported);
 
diff --git a/usr/gri/pretty/platform.go b/usr/gri/pretty/platform.go
index 85fb8eaddb..ef82d9565a 100644
--- a/usr/gri/pretty/platform.go
+++ b/usr/gri/pretty/platform.go
@@ -12,7 +12,7 @@ import Utils "utils"
 // ----------------------------------------------------------------------------
 // Environment
 
-export var
+var
 	GOARCH,
 	GOOS,
 	GOROOT,
@@ -31,7 +31,7 @@ func init() {
 // ----------------------------------------------------------------------------
 // I/O
 
-export const (
+const (
 	MAGIC_obj_file = "@gri-go.7@v0";  // make it clear that it cannot be a source file
 	Src_file_ext = ".go";
 	Obj_file_ext = ".7";
@@ -61,7 +61,7 @@ func writefile(name, data string) *OS.Error {
 	return err1;
 }
 
-export func ReadObjectFile(filename string) (string, bool) {
+func ReadObjectFile(filename string) (string, bool) {
 	data, err := readfile(filename + Obj_file_ext);
 	magic := MAGIC_obj_file;  // TODO remove once len(constant) works
 	if err == nil && len(data) >= len(magic) && data[0 : len(magic)] == magic {
@@ -71,14 +71,14 @@ export func ReadObjectFile(filename string) (string, bool) {
 }
 
 
-export func ReadSourceFile(name string) (string, bool) {
+func ReadSourceFile(name string) (string, bool) {
 	name = Utils.TrimExt(name, Src_file_ext) + Src_file_ext;
 	data, err := readfile(name);
 	return data, err == nil;
 }
 
 
-export func WriteObjectFile(name string, data string) bool {
+func WriteObjectFile(name string, data string) bool {
 	name = Utils.TrimExt(Utils.BaseName(name), Src_file_ext) + Obj_file_ext;
 	return writefile(name, data) != nil;
 }
diff --git a/usr/gri/pretty/printer.go b/usr/gri/pretty/printer.go
index 45ef1a0e74..e502ee0b36 100644
--- a/usr/gri/pretty/printer.go
+++ b/usr/gri/pretty/printer.go
@@ -18,7 +18,7 @@ import (
 
 var (
 	debug = flag.Bool("debug", false, "print debugging information");
-	
+
 	// layout control
 	tabwidth = flag.Int("tabwidth", 8, "tab width");
 	usetabs = flag.Bool("usetabs", true, "align with tabs instead of blanks");
@@ -54,10 +54,10 @@ const (
 )
 
 
-export type Printer struct {
+type Printer struct {
 	// output
 	text io.Write;
-	
+
 	// comments
 	comments *array.Array;  // the list of all comments
 	cindex int;  // the current comments index
@@ -67,11 +67,11 @@ export type Printer struct {
 	lastpos int;  // pos after last string
 	level int;  // scope level
 	indentation int;  // indentation level (may be different from scope level)
-	
+
 	// formatting parameters
 	separator int;  // pending separator
 	newlines int;  // pending newlines
-	
+
 	// semantic state
 	state int;  // current semantic state
 	laststate int;  // state for last string
@@ -96,12 +96,12 @@ func (P *Printer) NextComment() {
 func (P *Printer) Init(text io.Write, comments *array.Array) {
 	// writers
 	P.text = text;
-	
+
 	// comments
 	P.comments = comments;
 	P.cindex = -1;
 	P.NextComment();
-	
+
 	// formatting parameters & semantic state initialized correctly by default
 }
 
@@ -211,7 +211,7 @@ func (P *Printer) TaggedString(pos int, tag, s, endtag string) {
 		// we have a comment/newline that comes before the string
 		comment := P.comments.At(P.cindex).(*AST.Comment);
 		ctext := comment.Text;
-		
+
 		if ctext == "\n" {
 			// found a newline in src - count it
 			nlcount++;
@@ -256,7 +256,7 @@ func (P *Printer) TaggedString(pos int, tag, s, endtag string) {
 					ctext += " ";
 				}
 			}
-			
+
 			// print comment
 			if *debug {
 				P.Printf("[%d]", P.cpos);
@@ -276,7 +276,7 @@ func (P *Printer) TaggedString(pos int, tag, s, endtag string) {
 	// At this point we may have nlcount > 0: In this case we found newlines
 	// that were not followed by a comment. They are recognized (or not) when
 	// printing newlines below.
-	
+
 	// --------------------------------
 	// interpret state
 	// (any pending separator or comment must be printed in previous state)
@@ -373,7 +373,7 @@ func (P *Printer) HtmlPrologue(title string) {
 
 func (P *Printer) HtmlEpilogue() {
 	if *html {
-		P.TaggedString(0, 
+		P.TaggedString(0,
 			"</pre>\n"
 			"</body>\n"
 			"<html>\n",
@@ -551,7 +551,7 @@ func (P *Printer) Expr1(x *AST.Expr, prec1 int) {
 
 	case Scanner.IDENT:
 		P.HtmlIdentifier(x);
-	
+
 	case Scanner.INT, Scanner.STRING, Scanner.FLOAT:
 		// literal
 		P.String(x.Pos, x.Obj.Ident);
@@ -583,7 +583,7 @@ func (P *Printer) Expr1(x *AST.Expr, prec1 int) {
 		} else {
 			P.Expr1(x.Y, Scanner.HighestPrec);
 		}
-		
+
 	case Scanner.LBRACK:
 		// index
 		P.Expr1(x.X, Scanner.HighestPrec);
@@ -604,7 +604,7 @@ func (P *Printer) Expr1(x *AST.Expr, prec1 int) {
 		P.String(x.Pos, "{");
 		P.Expr(x.Y);
 		P.String(0, "}");
-		
+
 	default:
 		// unary and binary expressions including ":" for pairs
 		prec := Scanner.UnaryPrec;
@@ -725,7 +725,7 @@ func (P *Printer) Stat(s *AST.Stat) {
 		P.Token(s.Pos, s.Tok);
 		P.indentation++;
 		P.separator = none;
-		
+
 	case Scanner.CONST, Scanner.TYPE, Scanner.VAR:
 		// declaration
 		P.Declaration(s.Decl, false);
@@ -867,7 +867,7 @@ func (P *Printer) Declaration(d *AST.Decl, parenthesized bool) {
 			P.Error(d.Pos, d.Tok, "decl");
 		}
 	}
-	
+
 	P.newlines = 2;
 }
 
@@ -890,7 +890,7 @@ func (P *Printer) Program(p *AST.Program) {
 // ----------------------------------------------------------------------------
 // External interface
 
-export func Print(prog *AST.Program) {
+func Print(prog *AST.Program) {
 	// setup
 	var P Printer;
 	padchar := byte(' ');
@@ -904,7 +904,7 @@ export func Print(prog *AST.Program) {
 	P.HtmlPrologue("package " + prog.Ident.Obj.Ident);
 	P.Program(prog);
 	P.HtmlEpilogue();
-	
+
 	P.String(0, "");  // flush pending separator/newlines
 	err := text.Flush();
 	if err != nil {
diff --git a/usr/gri/pretty/scanner.go b/usr/gri/pretty/scanner.go
index 87e13e1c74..617460bca8 100644
--- a/usr/gri/pretty/scanner.go
+++ b/usr/gri/pretty/scanner.go
@@ -10,7 +10,7 @@ import (
 	"utils";
 )
 
-export const (
+const (
 	ILLEGAL = iota;
 
 	IDENT;
@@ -113,7 +113,7 @@ export const (
 )
 
 
-export func TokenString(tok int) string {
+func TokenString(tok int) string {
 	switch tok {
 	case ILLEGAL: return "ILLEGAL";
 
@@ -216,14 +216,14 @@ export func TokenString(tok int) string {
 }
 
 
-export const (
+const (
 	LowestPrec = -1;
 	UnaryPrec = 7;
 	HighestPrec = 8;
 )
 
 
-export func Precedence(tok int) int {
+func Precedence(tok int) int {
 	switch tok {
 	case COLON:
 		return 0;
@@ -276,13 +276,13 @@ func digit_val(ch int) int {
 }
 
 
-export type ErrorHandler interface {
+type ErrorHandler interface {
 	Error(pos int, msg string);
 	Warning(pos int, msg string);
 }
 
 
-export type Scanner struct {
+type Scanner struct {
 	// setup
 	err ErrorHandler;
 	src string;  // source
@@ -756,7 +756,7 @@ loop:
 }
 
 
-export type Token struct {
+type Token struct {
 	Pos int;
 	Tok int;
 	Val string;
diff --git a/usr/gri/pretty/selftest0.go b/usr/gri/pretty/selftest0.go
index 4706f8ab66..09b1283db4 100644
--- a/usr/gri/pretty/selftest0.go
+++ b/usr/gri/pretty/selftest0.go
@@ -4,7 +4,7 @@
 
 package main
 
-export type Proto struct {
+type Proto struct {
 	a int "a tag";
 	b, c, d *Proto "bcd" "tag";
 	*Proto "proto tag"
diff --git a/usr/gri/pretty/selftest2.go b/usr/gri/pretty/selftest2.go
index 5b9c8a7af7..7b5fc64945 100644
--- a/usr/gri/pretty/selftest2.go
+++ b/usr/gri/pretty/selftest2.go
@@ -11,7 +11,7 @@ import (
 )
 
 
-export const /* enum1 */ (
+const /* enum1 */ (
 	EnumTag0 = iota;
 	EnumTag1;
 	EnumTag2;
@@ -32,10 +32,10 @@ const /* enum2 */ (
 )
 
 
-export type S struct {}
+type S struct {}
 
 
-export type T struct {
+type T struct {
 	x, y int;
 	s string;
 	next_t *T
diff --git a/usr/gri/pretty/typechecker.go b/usr/gri/pretty/typechecker.go
index d1eccae13e..9835ffbe48 100644
--- a/usr/gri/pretty/typechecker.go
+++ b/usr/gri/pretty/typechecker.go
@@ -59,7 +59,7 @@ func (s *state) CheckDeclaration(d *AST.Decl) {
 		for i := 0; i < d.List.Len(); i++ {
 			s.CheckDeclaration(d.List.At(i).(*AST.Decl))
 		}
-		
+
 	} else {
 		// single declaration
 		switch d.Tok {
@@ -85,7 +85,7 @@ func (s *state) CheckProgram(p *AST.Program) {
 
 // ----------------------------------------------------------------------------
 
-export func CheckProgram(err Scanner.ErrorHandler, p *AST.Program) {
+func CheckProgram(err Scanner.ErrorHandler, p *AST.Program) {
 	var s state;
 	s.Init(err);
 	s.CheckProgram(p);
diff --git a/usr/gri/pretty/universe.go b/usr/gri/pretty/universe.go
index be27e16daf..22ae4266a8 100755
--- a/usr/gri/pretty/universe.go
+++ b/usr/gri/pretty/universe.go
@@ -10,15 +10,15 @@ import (
 )
 
 
-export var (
+var (
 	Scope *AST.Scope;
 	Types array.Array;
-	
+
 	// internal types
 	Void_typ,
 	Bad_typ,
 	Nil_typ,
-	
+
 	// basic types
 	Bool_typ,
 	Uint8_typ,
@@ -34,14 +34,14 @@ export var (
 	Float80_typ,
 	String_typ,
 	Integer_typ,
-	
+
 	// convenience types
 	Byte_typ,
 	Uint_typ,
 	Int_typ,
 	Float_typ,
 	Uintptr_typ *AST.Type;
-	
+
 	True_obj,
 	False_obj,
 	Iota_obj,
@@ -77,13 +77,13 @@ func register(typ *AST.Type) *AST.Type {
 func init() {
 	Scope = AST.NewScope(nil);  // universe has no parent
 	Types.Init(32);
-	
+
 	// Interal types
 	Void_typ = AST.NewType(-1 /* no source pos */, AST.VOID);
 	AST.Universe_void_typ = Void_typ;
 	Bad_typ = AST.NewType(-1 /* no source pos */, AST.BADTYPE);
 	Nil_typ = AST.NewType(-1 /* no source pos */, AST.NIL);
-	
+
 	// Basic types
 	Bool_typ = register(declType(AST.BOOL, "bool", 1));
 	Uint8_typ = register(declType(AST.UINT, "uint8", 1));
@@ -118,6 +118,6 @@ func init() {
 	declObj(AST.BUILTIN, "new", Void_typ);
 	declObj(AST.BUILTIN, "panic", Void_typ);
 	declObj(AST.BUILTIN, "print", Void_typ);
-	
+
 	// scope.Print();
 }
diff --git a/usr/gri/pretty/utils.go b/usr/gri/pretty/utils.go
index 0764a2f8ca..57a8d323a0 100644
--- a/usr/gri/pretty/utils.go
+++ b/usr/gri/pretty/utils.go
@@ -5,7 +5,7 @@
 package Utils
 
 
-export func BaseName(s string) string {
+func BaseName(s string) string {
 	// TODO this is not correct for non-ASCII strings!
 	i := len(s) - 1;
 	for i >= 0 && s[i] != '/' {
@@ -18,13 +18,13 @@ export func BaseName(s string) string {
 }
 
 
-export func Contains(s, sub string, pos int) bool {
+func Contains(s, sub string, pos int) bool {
 	end := pos + len(sub);
 	return pos >= 0 && end <= len(s) && s[pos : end] == sub;
 }
 
 
-export func TrimExt(s, ext string) string {
+func TrimExt(s, ext string) string {
 	i := len(s) - len(ext);
 	if i >= 0 && s[i : len(s)] == ext {
 		s = s[0 : i];
@@ -33,7 +33,7 @@ export func TrimExt(s, ext string) string {
 }
 
 
-export func IntToString(x, base int) string {
+func IntToString(x, base int) string {
 	x0 := x;
 	if x < 0 {
 		x = -x;
@@ -53,11 +53,11 @@ export func IntToString(x, base int) string {
 		buf[i] = hex[x % base];
 		x /= base;
 	}
-	
+
 	if x0 < 0 {
 		i--;
 		buf[i] = '-';
 	}
-	
+
 	return string(buf)[i : len(buf)];
 }
