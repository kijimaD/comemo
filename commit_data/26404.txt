commit 23d5810c8fd2dc079f06c6052f404d81896d74f0
Merge: 90065eaba4 c7754c8f54
Author: Keith Randall <khr@golang.org>
Date:   Tue Jan 19 09:59:21 2016 -0800

    [dev.ssa] Merge remote-tracking branch 'origin/master' into mergebranch
    
    Semi-regular merge from tip to dev.ssa.
    
    Conflicts:
            src/runtime/sys_windows_amd64.s
    
    Change-Id: I5f733130049c810e6ceacd46dad85faebca52b29

 AUTHORS                                            |   5 +
 CONTRIBUTORS                                       |   6 +
 api/go1.6.txt                                      |  11 +-
 doc/asm.html                                       |   7 +
 doc/code.html                                      |  49 +-
 doc/devel/release.html                             |   7 +
 doc/go1.6.html                                     |  27 +
 doc/help.html                                      |  68 +-
 misc/cgo/errors/ptr.go                             |  10 +
 misc/cgo/test/issue7978.go                         |   4 +-
 misc/cgo/testcarchive/main.c                       |  39 ++
 misc/cgo/testcshared/test.bash                     |   2 +-
 src/bootstrap.bash                                 |   2 +-
 src/buildall.bash                                  |   2 +-
 src/cmd/cgo/doc.go                                 |   8 +
 src/cmd/cgo/gcc.go                                 |  56 +-
 src/cmd/compile/internal/amd64/prog.go             |   1 +
 src/cmd/compile/internal/arm/peep.go               |   1 +
 src/cmd/compile/internal/arm/prog.go               |   1 +
 src/cmd/compile/internal/arm64/peep.go             |   1 +
 src/cmd/compile/internal/arm64/prog.go             |   1 +
 src/cmd/compile/internal/gc/const.go               |  19 +-
 src/cmd/compile/internal/gc/esc.go                 |  86 ++-
 src/cmd/compile/internal/gc/float_test.go          | 102 +++
 src/cmd/compile/internal/gc/gen.go                 |   6 +
 src/cmd/compile/internal/gc/gsubr.go               |   2 +-
 src/cmd/compile/internal/gc/lex.go                 |  14 +-
 src/cmd/compile/internal/gc/order.go               |  31 +-
 src/cmd/compile/internal/gc/pgen.go                |  14 +-
 src/cmd/compile/internal/gc/plive.go               |   2 +-
 src/cmd/compile/internal/gc/racewalk.go            |   2 +-
 src/cmd/compile/internal/gc/reg.go                 |   3 +
 src/cmd/compile/internal/gc/ssa.go                 |   9 +
 src/cmd/compile/internal/gc/syntax.go              |   2 +
 src/cmd/compile/internal/gc/typecheck.go           |   5 +-
 src/cmd/compile/internal/gc/walk.go                |   3 +-
 src/cmd/compile/internal/mips64/peep.go            |   1 +
 src/cmd/compile/internal/mips64/prog.go            |   1 +
 src/cmd/compile/internal/ppc64/peep.go             |   1 +
 src/cmd/compile/internal/ppc64/prog.go             |   1 +
 src/cmd/compile/internal/ssa/gen/genericOps.go     |   1 +
 src/cmd/compile/internal/ssa/lower.go              |   2 +-
 src/cmd/compile/internal/ssa/opGen.go              |   5 +
 src/cmd/compile/internal/x86/ggen.go               |   8 +-
 src/cmd/compile/internal/x86/gsubr.go              |  13 +-
 src/cmd/compile/internal/x86/prog.go               |   9 +-
 src/cmd/dist/test.go                               |   8 +-
 src/cmd/dist/util.go                               |   2 +-
 src/cmd/go/build.go                                |  55 +-
 src/cmd/go/go_test.go                              |  10 +
 src/cmd/go/pkg.go                                  |  28 +-
 src/cmd/go/testdata/src/run/bad.go                 |   5 +
 src/cmd/go/testdata/src/run/good.go                |   5 +
 src/cmd/go/testdata/src/run/internal/internal.go   |   1 +
 .../src/run/subdir/internal/private/private.go     |   1 +
 src/cmd/go/testdata/src/vend/dir1/dir1.go          |   1 +
 .../src/vend/vendor/vend/dir1/dir2/dir2.go         |   1 +
 src/cmd/go/testdata/src/vend/x/x.go                |   2 +
 src/cmd/go/vendor_test.go                          |  12 +-
 src/cmd/internal/obj/link.go                       |   7 +
 src/cmd/internal/obj/objfile.go                    |  36 +-
 src/cmd/internal/obj/util.go                       |   3 +-
 src/cmd/internal/obj/x86/a.out.go                  |   6 +
 src/cmd/internal/obj/x86/anames.go                 |   6 +
 src/cmd/internal/obj/x86/asm6.go                   |  29 +-
 src/cmd/link/internal/ld/lib.go                    |   2 +-
 src/cmd/link/internal/ld/macho.go                  |  19 +
 src/cmd/link/internal/ld/pe.go                     |  15 +-
 src/crypto/aes/asm_amd64.s                         |   8 +-
 src/crypto/aes/gcm_amd64.s                         |   8 +-
 src/crypto/cipher/gcm.go                           |  13 +-
 src/crypto/cipher/gcm_test.go                      |  34 +
 src/crypto/tls/conn.go                             |  41 ++
 src/crypto/tls/tls_test.go                         | 102 +++
 src/database/sql/driver/types.go                   |  13 +-
 src/database/sql/fakedb_test.go                    |  27 +-
 src/database/sql/sql.go                            |  14 +-
 src/database/sql/sql_test.go                       |  40 ++
 src/debug/dwarf/testdata/cycle.c                   |   7 +
 src/debug/dwarf/testdata/cycle.elf                 | Bin 0 -> 2624 bytes
 src/debug/dwarf/type.go                            |  34 +-
 src/debug/dwarf/type_test.go                       |  34 +
 src/debug/dwarf/typeunit.go                        |   2 +-
 src/encoding/base64/base64.go                      |  76 ++-
 src/encoding/base64/base64_test.go                 |  25 +
 src/encoding/json/decode.go                        |   1 +
 src/go/build/build.go                              |  26 +-
 src/go/build/build_test.go                         |  22 +-
 src/go/doc/reader.go                               |  19 +-
 src/go/doc/testdata/issue13742.0.golden            |  25 +
 src/go/doc/testdata/issue13742.1.golden            |  25 +
 src/go/doc/testdata/issue13742.2.golden            |  25 +
 src/go/doc/testdata/issue13742.go                  |  18 +
 src/go/importer/importer.go                        |  47 +-
 src/go/internal/gcimporter/bimport.go              |  67 +-
 src/go/internal/gcimporter/gcimporter.go           | 117 ++--
 src/go/internal/gcimporter/gcimporter_test.go      |  68 +-
 src/go/types/api.go                                |  43 +-
 src/go/types/issues_test.go                        |  88 +++
 src/go/types/resolver.go                           |  54 +-
 src/go/types/resolver_test.go                      |  15 +-
 src/hash/crc32/crc32_amd64.s                       |   4 +-
 src/internal/syscall/windows/syscall_windows.go    |   4 +-
 src/internal/syscall/windows/zsyscall_windows.go   |  21 +-
 src/math/big/int.go                                |   2 +-
 src/math/big/int_test.go                           |  10 +-
 src/math/big/nat.go                                |  17 +
 src/net/dial.go                                    |  10 +-
 src/net/dnsclient.go                               |  13 +-
 src/net/dnsclient_unix_test.go                     |   2 +-
 src/net/http/clientserver_test.go                  | 222 ++++++-
 src/net/http/doc.go                                |  15 +
 src/net/http/export_test.go                        |   1 +
 src/net/http/h2_bundle.go                          | 688 ++++++++++++++++-----
 src/net/http/lex.go                                |  14 +
 src/net/http/request.go                            |  28 +-
 src/net/http/response.go                           |   8 +-
 src/net/http/response_test.go                      | 108 +++-
 src/net/http/serve_test.go                         |  73 ++-
 src/net/http/server.go                             |  37 +-
 src/net/http/transport.go                          |  56 +-
 src/net/http/transport_test.go                     |  93 +++
 src/net/lookup_plan9.go                            |  23 +-
 src/net/lookup_test.go                             |  40 +-
 src/net/lookup_windows.go                          |  27 +-
 src/net/lookup_windows_test.go                     |   8 +-
 src/net/net_windows_test.go                        |   2 +
 src/net/non_unix_test.go                           |  13 +-
 src/net/sendfile_solaris.go                        |   2 +
 src/net/textproto/reader.go                        |  16 +-
 src/net/textproto/reader_test.go                   |  29 +
 src/os/file_plan9.go                               |  11 +-
 src/os/file_windows.go                             |  11 +-
 src/os/os_test.go                                  |   3 -
 src/os/signal/doc.go                               |  55 +-
 src/regexp/syntax/parse.go                         |  15 +-
 src/regexp/syntax/parse_test.go                    |   7 +-
 src/regexp/testdata/re2-search.txt                 |   5 +
 src/runtime/asm_386.s                              |   6 +-
 src/runtime/asm_amd64.s                            |   6 +-
 src/runtime/asm_arm.s                              |  10 +-
 src/runtime/asm_arm64.s                            |  10 +-
 src/runtime/asm_mips64x.s                          |  10 +-
 src/runtime/asm_ppc64x.s                           |  14 +-
 src/runtime/cgocall.go                             |  28 +-
 src/runtime/crash_cgo_test.go                      |  13 +
 src/runtime/crash_test.go                          |   2 +-
 src/runtime/crash_unix_test.go                     |   8 +
 src/runtime/export_test.go                         |   8 +
 src/runtime/extern.go                              |  11 +-
 src/runtime/futex_test.go                          |  25 +-
 src/runtime/internal/atomic/atomic_386.go          |   8 +-
 src/runtime/internal/atomic/atomic_amd64x.go       |  10 +-
 src/runtime/internal/atomic/stubs.go               |   2 -
 src/runtime/malloc.go                              |   2 +-
 src/runtime/mbitmap.go                             |   2 +-
 src/runtime/mgc.go                                 |  20 +-
 src/runtime/mgcmark.go                             |  29 +-
 src/runtime/mprof.go                               |   5 +
 src/runtime/os1_darwin.go                          |  21 +-
 src/runtime/os1_dragonfly.go                       |  13 +-
 src/runtime/os1_freebsd.go                         |  12 +-
 src/runtime/os1_linux.go                           |  27 +-
 src/runtime/os1_nacl.go                            |   4 +-
 src/runtime/os1_netbsd.go                          |  12 +-
 src/runtime/os1_openbsd.go                         |  12 +-
 src/runtime/os1_plan9.go                           |   4 +-
 src/runtime/os1_windows.go                         |   2 +-
 src/runtime/os2_dragonfly.go                       |   2 +-
 src/runtime/os3_solaris.go                         |  19 +-
 src/runtime/pprof/pprof_test.go                    |   4 +-
 src/runtime/proc.go                                |  79 ++-
 src/runtime/proc_test.go                           |  18 +
 src/runtime/rt0_darwin_386.s                       |   4 +
 src/runtime/rt0_darwin_amd64.s                     |  24 +-
 src/runtime/rt0_darwin_arm.s                       |   4 +
 src/runtime/rt0_darwin_arm64.s                     |   5 +
 src/runtime/rt0_linux_386.s                        |   4 +
 src/runtime/rt0_linux_amd64.s                      |   4 +
 src/runtime/rt0_linux_arm.s                        |   4 +
 src/runtime/rt0_linux_arm64.s                      |   4 +
 src/runtime/runtime2.go                            |   9 +-
 src/runtime/runtime_test.go                        |   7 +
 src/runtime/signal1_unix.go                        |  29 +-
 src/runtime/signal2_unix.go                        |  16 +
 src/runtime/signal_386.go                          |   4 +
 src/runtime/signal_amd64x.go                       |   4 +
 src/runtime/signal_arm.go                          |   4 +
 src/runtime/signal_arm64.go                        |   4 +
 src/runtime/signal_darwin.go                       |   3 +
 src/runtime/signal_darwin_386.go                   |  22 +
 src/runtime/signal_darwin_amd64.go                 |  22 +
 src/runtime/signal_darwin_arm.go                   |  21 +
 src/runtime/signal_darwin_arm64.go                 |  22 +
 src/runtime/signal_freebsd.go                      |   1 +
 src/runtime/signal_mips64x.go                      |   4 +
 src/runtime/signal_openbsd.go                      |   1 +
 src/runtime/signal_ppc64x.go                       |   4 +
 src/runtime/signal_sigtramp.go                     |   2 +
 src/runtime/signal_windows.go                      |   2 +-
 src/runtime/sigqueue.go                            |  21 +-
 src/runtime/sys_windows_386.s                      |   3 +-
 src/runtime/sys_windows_amd64.s                    |   2 +-
 src/runtime/testdata/testprog/misc.go              |  15 +
 src/runtime/testdata/testprogcgo/dropm.go          |  59 ++
 src/runtime/testdata/testprogcgo/dropm_stub.go     |  11 +
 src/runtime/testdata/testprognet/signal.go         |  26 +
 src/syscall/syscall.go                             |   3 +
 src/time/format.go                                 |   2 +-
 src/time/format_test.go                            |   6 +-
 src/vendor/golang.org/x/net/http2/hpack/hpack.go   |   8 +
 test/bench/go1/jsondata_test.go                    |   2 +-
 test/escape2.go                                    |   2 +-
 test/escape2n.go                                   |   2 +-
 test/fixedbugs/issue13799.go                       | 190 ++++++
 test/fixedbugs/issue13821b.go                      |   2 +
 test/live_syscall.go                               |  28 +
 test/nosplit.go                                    |   5 +-
 218 files changed, 4010 insertions(+), 804 deletions(-)

diff --cc src/cmd/compile/internal/gc/order.go
index 84b96c2d7b,a2e12284d0..05cd53af41
--- a/src/cmd/compile/internal/gc/order.go
+++ b/src/cmd/compile/internal/gc/order.go
@@@ -243,6 -243,12 +243,13 @@@ func cleantempnopop(mark *NodeList, ord
  	var kill *Node
  
  	for l := order.temp; l != mark; l = l.Next {
+ 		if l.N.Name.Keepalive {
+ 			l.N.Name.Keepalive = false
++			l.N.Addrtaken = true // ensure SSA keeps the l.N variable
+ 			kill = Nod(OVARLIVE, l.N, nil)
+ 			typecheck(&kill, Etop)
+ 			*out = list(*out, kill)
+ 		}
  		kill = Nod(OVARKILL, l.N, nil)
  		typecheck(&kill, Etop)
  		*out = list(*out, kill)
diff --cc src/cmd/compile/internal/gc/ssa.go
index 46aaaa7d87,0000000000..be9af60bd8
mode 100644,000000..100644
--- a/src/cmd/compile/internal/gc/ssa.go
+++ b/src/cmd/compile/internal/gc/ssa.go
@@@ -1,4634 -1,0 +1,4643 @@@
 +// Copyright 2015 The Go Authors. All rights reserved.
 +// Use of this source code is governed by a BSD-style
 +// license that can be found in the LICENSE file.
 +
 +package gc
 +
 +import (
 +	"bytes"
 +	"crypto/sha1"
 +	"fmt"
 +	"html"
 +	"math"
 +	"os"
 +	"strings"
 +
 +	"cmd/compile/internal/ssa"
 +	"cmd/internal/obj"
 +	"cmd/internal/obj/x86"
 +)
 +
 +// Smallest possible faulting page at address zero.
 +const minZeroPage = 4096
 +
 +func shouldssa(fn *Node) bool {
 +	if Thearch.Thestring != "amd64" {
 +		return false
 +	}
 +
 +	// Environment variable control of SSA CG
 +	// 1. IF GOSSAFUNC == current function name THEN
 +	//       compile this function with SSA and log output to ssa.html
 +
 +	// 2. IF GOSSAHASH == "" THEN
 +	//       compile this function (and everything else) with SSA
 +
 +	// 3. IF GOSSAHASH == "n" or "N"
 +	//       IF GOSSAPKG == current package name THEN
 +	//          compile this function (and everything in this package) with SSA
 +	//       ELSE
 +	//          use the old back end for this function.
 +	//       This is for compatibility with existing test harness and should go away.
 +
 +	// 4. IF GOSSAHASH is a suffix of the binary-rendered SHA1 hash of the function name THEN
 +	//          compile this function with SSA
 +	//       ELSE
 +	//          compile this function with the old back end.
 +
 +	// Plan is for 3 to be removed when the tests are revised.
 +	// SSA is now default, and is disabled by setting
 +	// GOSSAHASH to n or N, or selectively with strings of
 +	// 0 and 1.
 +
 +	name := fn.Func.Nname.Sym.Name
 +
 +	funcname := os.Getenv("GOSSAFUNC")
 +	if funcname != "" {
 +		// If GOSSAFUNC is set, compile only that function.
 +		return name == funcname
 +	}
 +
 +	pkg := os.Getenv("GOSSAPKG")
 +	if pkg != "" {
 +		// If GOSSAPKG is set, compile only that package.
 +		return localpkg.Name == pkg
 +	}
 +
 +	gossahash := os.Getenv("GOSSAHASH")
 +	if gossahash == "" || gossahash == "y" || gossahash == "Y" {
 +		return true
 +	}
 +	if gossahash == "n" || gossahash == "N" {
 +		return false
 +	}
 +
 +	// Check the hash of the name against a partial input hash.
 +	// We use this feature to do a binary search within a package to
 +	// find a function that is incorrectly compiled.
 +	hstr := ""
 +	for _, b := range sha1.Sum([]byte(name)) {
 +		hstr += fmt.Sprintf("%08b", b)
 +	}
 +
 +	if strings.HasSuffix(hstr, gossahash) {
 +		fmt.Printf("GOSSAHASH triggered %s\n", name)
 +		return true
 +	}
 +
 +	// Iteratively try additional hashes to allow tests for multi-point
 +	// failure.
 +	for i := 0; true; i++ {
 +		ev := fmt.Sprintf("GOSSAHASH%d", i)
 +		evv := os.Getenv(ev)
 +		if evv == "" {
 +			break
 +		}
 +		if strings.HasSuffix(hstr, evv) {
 +			fmt.Printf("%s triggered %s\n", ev, name)
 +			return true
 +		}
 +	}
 +
 +	return false
 +}
 +
 +// buildssa builds an SSA function.
 +func buildssa(fn *Node) *ssa.Func {
 +	name := fn.Func.Nname.Sym.Name
 +	printssa := strings.HasSuffix(name, "_ssa") || strings.Contains(name, "_ssa.") || name == os.Getenv("GOSSAFUNC")
 +	if printssa {
 +		fmt.Println("generating SSA for", name)
 +		dumplist("buildssa-enter", fn.Func.Enter)
 +		dumplist("buildssa-body", fn.Nbody)
 +		dumplist("buildssa-exit", fn.Func.Exit)
 +	}
 +
 +	var s state
 +	s.pushLine(fn.Lineno)
 +	defer s.popLine()
 +
 +	// TODO(khr): build config just once at the start of the compiler binary
 +
 +	var e ssaExport
 +	e.log = printssa
 +	s.config = ssa.NewConfig(Thearch.Thestring, &e, Ctxt)
 +	s.f = s.config.NewFunc()
 +	s.f.Name = name
 +	s.exitCode = fn.Func.Exit
 +	s.panics = map[funcLine]*ssa.Block{}
 +
 +	if name == os.Getenv("GOSSAFUNC") {
 +		// TODO: tempfile? it is handy to have the location
 +		// of this file be stable, so you can just reload in the browser.
 +		s.config.HTML = ssa.NewHTMLWriter("ssa.html", s.config, name)
 +		// TODO: generate and print a mapping from nodes to values and blocks
 +	}
 +	defer func() {
 +		if !printssa {
 +			s.config.HTML.Close()
 +		}
 +	}()
 +
 +	// We construct SSA using an algorithm similar to
 +	// Brau, Buchwald, Hack, LeiÃŸa, Mallon, and Zwinkau
 +	// http://pp.info.uni-karlsruhe.de/uploads/publikationen/braun13cc.pdf
 +	// TODO: check this comment
 +
 +	// Allocate starting block
 +	s.f.Entry = s.f.NewBlock(ssa.BlockPlain)
 +
 +	// Allocate starting values
 +	s.labels = map[string]*ssaLabel{}
 +	s.labeledNodes = map[*Node]*ssaLabel{}
 +	s.startmem = s.entryNewValue0(ssa.OpInitMem, ssa.TypeMem)
 +	s.sp = s.entryNewValue0(ssa.OpSP, Types[TUINTPTR]) // TODO: use generic pointer type (unsafe.Pointer?) instead
 +	s.sb = s.entryNewValue0(ssa.OpSB, Types[TUINTPTR])
 +
 +	s.startBlock(s.f.Entry)
 +	s.vars[&memVar] = s.startmem
 +
 +	s.varsyms = map[*Node]interface{}{}
 +
 +	// Generate addresses of local declarations
 +	s.decladdrs = map[*Node]*ssa.Value{}
 +	for d := fn.Func.Dcl; d != nil; d = d.Next {
 +		n := d.N
 +		switch n.Class {
 +		case PPARAM:
 +			aux := s.lookupSymbol(n, &ssa.ArgSymbol{Typ: n.Type, Node: n})
 +			s.decladdrs[n] = s.entryNewValue1A(ssa.OpAddr, Ptrto(n.Type), aux, s.sp)
 +		case PAUTO | PHEAP:
 +			// TODO this looks wrong for PAUTO|PHEAP, no vardef, but also no definition
 +			aux := s.lookupSymbol(n, &ssa.AutoSymbol{Typ: n.Type, Node: n})
 +			s.decladdrs[n] = s.entryNewValue1A(ssa.OpAddr, Ptrto(n.Type), aux, s.sp)
 +		case PPARAM | PHEAP, PPARAMOUT | PHEAP:
 +		// This ends up wrong, have to do it at the PARAM node instead.
 +		case PAUTO, PPARAMOUT:
 +			// processed at each use, to prevent Addr coming
 +			// before the decl.
 +		case PFUNC:
 +			// local function - already handled by frontend
 +		default:
 +			str := ""
 +			if n.Class&PHEAP != 0 {
 +				str = ",heap"
 +			}
 +			s.Unimplementedf("local variable with class %s%s unimplemented", classnames[n.Class&^PHEAP], str)
 +		}
 +	}
 +
 +	// Convert the AST-based IR to the SSA-based IR
 +	s.stmtList(fn.Func.Enter)
 +	s.stmtList(fn.Nbody)
 +
 +	// fallthrough to exit
 +	if s.curBlock != nil {
 +		s.stmtList(s.exitCode)
 +		m := s.mem()
 +		b := s.endBlock()
 +		b.Kind = ssa.BlockRet
 +		b.Control = m
 +	}
 +
 +	// Check that we used all labels
 +	for name, lab := range s.labels {
 +		if !lab.used() && !lab.reported {
 +			yyerrorl(int(lab.defNode.Lineno), "label %v defined and not used", name)
 +			lab.reported = true
 +		}
 +		if lab.used() && !lab.defined() && !lab.reported {
 +			yyerrorl(int(lab.useNode.Lineno), "label %v not defined", name)
 +			lab.reported = true
 +		}
 +	}
 +
 +	// Check any forward gotos. Non-forward gotos have already been checked.
 +	for _, n := range s.fwdGotos {
 +		lab := s.labels[n.Left.Sym.Name]
 +		// If the label is undefined, we have already have printed an error.
 +		if lab.defined() {
 +			s.checkgoto(n, lab.defNode)
 +		}
 +	}
 +
 +	if nerrors > 0 {
 +		return nil
 +	}
 +
 +	// Link up variable uses to variable definitions
 +	s.linkForwardReferences()
 +
 +	// Don't carry reference this around longer than necessary
 +	s.exitCode = nil
 +
 +	// Main call to ssa package to compile function
 +	ssa.Compile(s.f)
 +
 +	return s.f
 +}
 +
 +type state struct {
 +	// configuration (arch) information
 +	config *ssa.Config
 +
 +	// function we're building
 +	f *ssa.Func
 +
 +	// labels and labeled control flow nodes (OFOR, OSWITCH, OSELECT) in f
 +	labels       map[string]*ssaLabel
 +	labeledNodes map[*Node]*ssaLabel
 +
 +	// gotos that jump forward; required for deferred checkgoto calls
 +	fwdGotos []*Node
 +	// Code that must precede any return
 +	// (e.g., copying value of heap-escaped paramout back to true paramout)
 +	exitCode *NodeList
 +
 +	// unlabeled break and continue statement tracking
 +	breakTo    *ssa.Block // current target for plain break statement
 +	continueTo *ssa.Block // current target for plain continue statement
 +
 +	// current location where we're interpreting the AST
 +	curBlock *ssa.Block
 +
 +	// variable assignments in the current block (map from variable symbol to ssa value)
 +	// *Node is the unique identifier (an ONAME Node) for the variable.
 +	vars map[*Node]*ssa.Value
 +
 +	// all defined variables at the end of each block.  Indexed by block ID.
 +	defvars []map[*Node]*ssa.Value
 +
 +	// addresses of PPARAM and PPARAMOUT variables.
 +	decladdrs map[*Node]*ssa.Value
 +
 +	// symbols for PEXTERN, PAUTO and PPARAMOUT variables so they can be reused.
 +	varsyms map[*Node]interface{}
 +
 +	// starting values.  Memory, stack pointer, and globals pointer
 +	startmem *ssa.Value
 +	sp       *ssa.Value
 +	sb       *ssa.Value
 +
 +	// line number stack.  The current line number is top of stack
 +	line []int32
 +
 +	// list of panic calls by function name and line number.
 +	// Used to deduplicate panic calls.
 +	panics map[funcLine]*ssa.Block
 +}
 +
 +type funcLine struct {
 +	f    *Node
 +	line int32
 +}
 +
 +type ssaLabel struct {
 +	target         *ssa.Block // block identified by this label
 +	breakTarget    *ssa.Block // block to break to in control flow node identified by this label
 +	continueTarget *ssa.Block // block to continue to in control flow node identified by this label
 +	defNode        *Node      // label definition Node (OLABEL)
 +	// Label use Node (OGOTO, OBREAK, OCONTINUE).
 +	// Used only for error detection and reporting.
 +	// There might be multiple uses, but we only need to track one.
 +	useNode  *Node
 +	reported bool // reported indicates whether an error has already been reported for this label
 +}
 +
 +// defined reports whether the label has a definition (OLABEL node).
 +func (l *ssaLabel) defined() bool { return l.defNode != nil }
 +
 +// used reports whether the label has a use (OGOTO, OBREAK, or OCONTINUE node).
 +func (l *ssaLabel) used() bool { return l.useNode != nil }
 +
 +// label returns the label associated with sym, creating it if necessary.
 +func (s *state) label(sym *Sym) *ssaLabel {
 +	lab := s.labels[sym.Name]
 +	if lab == nil {
 +		lab = new(ssaLabel)
 +		s.labels[sym.Name] = lab
 +	}
 +	return lab
 +}
 +
 +func (s *state) Logf(msg string, args ...interface{})   { s.config.Logf(msg, args...) }
 +func (s *state) Fatalf(msg string, args ...interface{}) { s.config.Fatalf(s.peekLine(), msg, args...) }
 +func (s *state) Unimplementedf(msg string, args ...interface{}) {
 +	s.config.Unimplementedf(s.peekLine(), msg, args...)
 +}
 +func (s *state) Warnl(line int, msg string, args ...interface{}) { s.config.Warnl(line, msg, args...) }
 +func (s *state) Debug_checknil() bool                            { return s.config.Debug_checknil() }
 +
 +var (
 +	// dummy node for the memory variable
 +	memVar = Node{Op: ONAME, Class: Pxxx, Sym: &Sym{Name: "mem"}}
 +
 +	// dummy nodes for temporary variables
 +	ptrVar   = Node{Op: ONAME, Class: Pxxx, Sym: &Sym{Name: "ptr"}}
 +	capVar   = Node{Op: ONAME, Class: Pxxx, Sym: &Sym{Name: "cap"}}
 +	typVar   = Node{Op: ONAME, Class: Pxxx, Sym: &Sym{Name: "typ"}}
 +	idataVar = Node{Op: ONAME, Class: Pxxx, Sym: &Sym{Name: "idata"}}
 +	okVar    = Node{Op: ONAME, Class: Pxxx, Sym: &Sym{Name: "ok"}}
 +)
 +
 +// startBlock sets the current block we're generating code in to b.
 +func (s *state) startBlock(b *ssa.Block) {
 +	if s.curBlock != nil {
 +		s.Fatalf("starting block %v when block %v has not ended", b, s.curBlock)
 +	}
 +	s.curBlock = b
 +	s.vars = map[*Node]*ssa.Value{}
 +}
 +
 +// endBlock marks the end of generating code for the current block.
 +// Returns the (former) current block.  Returns nil if there is no current
 +// block, i.e. if no code flows to the current execution point.
 +func (s *state) endBlock() *ssa.Block {
 +	b := s.curBlock
 +	if b == nil {
 +		return nil
 +	}
 +	for len(s.defvars) <= int(b.ID) {
 +		s.defvars = append(s.defvars, nil)
 +	}
 +	s.defvars[b.ID] = s.vars
 +	s.curBlock = nil
 +	s.vars = nil
 +	b.Line = s.peekLine()
 +	return b
 +}
 +
 +// pushLine pushes a line number on the line number stack.
 +func (s *state) pushLine(line int32) {
 +	s.line = append(s.line, line)
 +}
 +
 +// popLine pops the top of the line number stack.
 +func (s *state) popLine() {
 +	s.line = s.line[:len(s.line)-1]
 +}
 +
 +// peekLine peek the top of the line number stack.
 +func (s *state) peekLine() int32 {
 +	return s.line[len(s.line)-1]
 +}
 +
 +func (s *state) Error(msg string, args ...interface{}) {
 +	yyerrorl(int(s.peekLine()), msg, args...)
 +}
 +
 +// newValue0 adds a new value with no arguments to the current block.
 +func (s *state) newValue0(op ssa.Op, t ssa.Type) *ssa.Value {
 +	return s.curBlock.NewValue0(s.peekLine(), op, t)
 +}
 +
 +// newValue0A adds a new value with no arguments and an aux value to the current block.
 +func (s *state) newValue0A(op ssa.Op, t ssa.Type, aux interface{}) *ssa.Value {
 +	return s.curBlock.NewValue0A(s.peekLine(), op, t, aux)
 +}
 +
 +// newValue0I adds a new value with no arguments and an auxint value to the current block.
 +func (s *state) newValue0I(op ssa.Op, t ssa.Type, auxint int64) *ssa.Value {
 +	return s.curBlock.NewValue0I(s.peekLine(), op, t, auxint)
 +}
 +
 +// newValue1 adds a new value with one argument to the current block.
 +func (s *state) newValue1(op ssa.Op, t ssa.Type, arg *ssa.Value) *ssa.Value {
 +	return s.curBlock.NewValue1(s.peekLine(), op, t, arg)
 +}
 +
 +// newValue1A adds a new value with one argument and an aux value to the current block.
 +func (s *state) newValue1A(op ssa.Op, t ssa.Type, aux interface{}, arg *ssa.Value) *ssa.Value {
 +	return s.curBlock.NewValue1A(s.peekLine(), op, t, aux, arg)
 +}
 +
 +// newValue1I adds a new value with one argument and an auxint value to the current block.
 +func (s *state) newValue1I(op ssa.Op, t ssa.Type, aux int64, arg *ssa.Value) *ssa.Value {
 +	return s.curBlock.NewValue1I(s.peekLine(), op, t, aux, arg)
 +}
 +
 +// newValue2 adds a new value with two arguments to the current block.
 +func (s *state) newValue2(op ssa.Op, t ssa.Type, arg0, arg1 *ssa.Value) *ssa.Value {
 +	return s.curBlock.NewValue2(s.peekLine(), op, t, arg0, arg1)
 +}
 +
 +// newValue2I adds a new value with two arguments and an auxint value to the current block.
 +func (s *state) newValue2I(op ssa.Op, t ssa.Type, aux int64, arg0, arg1 *ssa.Value) *ssa.Value {
 +	return s.curBlock.NewValue2I(s.peekLine(), op, t, aux, arg0, arg1)
 +}
 +
 +// newValue3 adds a new value with three arguments to the current block.
 +func (s *state) newValue3(op ssa.Op, t ssa.Type, arg0, arg1, arg2 *ssa.Value) *ssa.Value {
 +	return s.curBlock.NewValue3(s.peekLine(), op, t, arg0, arg1, arg2)
 +}
 +
 +// newValue3I adds a new value with three arguments and an auxint value to the current block.
 +func (s *state) newValue3I(op ssa.Op, t ssa.Type, aux int64, arg0, arg1, arg2 *ssa.Value) *ssa.Value {
 +	return s.curBlock.NewValue3I(s.peekLine(), op, t, aux, arg0, arg1, arg2)
 +}
 +
 +// entryNewValue0 adds a new value with no arguments to the entry block.
 +func (s *state) entryNewValue0(op ssa.Op, t ssa.Type) *ssa.Value {
 +	return s.f.Entry.NewValue0(s.peekLine(), op, t)
 +}
 +
 +// entryNewValue0A adds a new value with no arguments and an aux value to the entry block.
 +func (s *state) entryNewValue0A(op ssa.Op, t ssa.Type, aux interface{}) *ssa.Value {
 +	return s.f.Entry.NewValue0A(s.peekLine(), op, t, aux)
 +}
 +
 +// entryNewValue0I adds a new value with no arguments and an auxint value to the entry block.
 +func (s *state) entryNewValue0I(op ssa.Op, t ssa.Type, auxint int64) *ssa.Value {
 +	return s.f.Entry.NewValue0I(s.peekLine(), op, t, auxint)
 +}
 +
 +// entryNewValue1 adds a new value with one argument to the entry block.
 +func (s *state) entryNewValue1(op ssa.Op, t ssa.Type, arg *ssa.Value) *ssa.Value {
 +	return s.f.Entry.NewValue1(s.peekLine(), op, t, arg)
 +}
 +
 +// entryNewValue1 adds a new value with one argument and an auxint value to the entry block.
 +func (s *state) entryNewValue1I(op ssa.Op, t ssa.Type, auxint int64, arg *ssa.Value) *ssa.Value {
 +	return s.f.Entry.NewValue1I(s.peekLine(), op, t, auxint, arg)
 +}
 +
 +// entryNewValue1A adds a new value with one argument and an aux value to the entry block.
 +func (s *state) entryNewValue1A(op ssa.Op, t ssa.Type, aux interface{}, arg *ssa.Value) *ssa.Value {
 +	return s.f.Entry.NewValue1A(s.peekLine(), op, t, aux, arg)
 +}
 +
 +// entryNewValue2 adds a new value with two arguments to the entry block.
 +func (s *state) entryNewValue2(op ssa.Op, t ssa.Type, arg0, arg1 *ssa.Value) *ssa.Value {
 +	return s.f.Entry.NewValue2(s.peekLine(), op, t, arg0, arg1)
 +}
 +
 +// const* routines add a new const value to the entry block.
 +func (s *state) constBool(c bool) *ssa.Value {
 +	return s.f.ConstBool(s.peekLine(), Types[TBOOL], c)
 +}
 +func (s *state) constInt8(t ssa.Type, c int8) *ssa.Value {
 +	return s.f.ConstInt8(s.peekLine(), t, c)
 +}
 +func (s *state) constInt16(t ssa.Type, c int16) *ssa.Value {
 +	return s.f.ConstInt16(s.peekLine(), t, c)
 +}
 +func (s *state) constInt32(t ssa.Type, c int32) *ssa.Value {
 +	return s.f.ConstInt32(s.peekLine(), t, c)
 +}
 +func (s *state) constInt64(t ssa.Type, c int64) *ssa.Value {
 +	return s.f.ConstInt64(s.peekLine(), t, c)
 +}
 +func (s *state) constFloat32(t ssa.Type, c float64) *ssa.Value {
 +	return s.f.ConstFloat32(s.peekLine(), t, c)
 +}
 +func (s *state) constFloat64(t ssa.Type, c float64) *ssa.Value {
 +	return s.f.ConstFloat64(s.peekLine(), t, c)
 +}
 +func (s *state) constInt(t ssa.Type, c int64) *ssa.Value {
 +	if s.config.IntSize == 8 {
 +		return s.constInt64(t, c)
 +	}
 +	if int64(int32(c)) != c {
 +		s.Fatalf("integer constant too big %d", c)
 +	}
 +	return s.constInt32(t, int32(c))
 +}
 +
 +// ssaStmtList converts the statement n to SSA and adds it to s.
 +func (s *state) stmtList(l *NodeList) {
 +	for ; l != nil; l = l.Next {
 +		s.stmt(l.N)
 +	}
 +}
 +
 +// ssaStmt converts the statement n to SSA and adds it to s.
 +func (s *state) stmt(n *Node) {
 +	s.pushLine(n.Lineno)
 +	defer s.popLine()
 +
 +	// If s.curBlock is nil, then we're about to generate dead code.
 +	// We can't just short-circuit here, though,
 +	// because we check labels and gotos as part of SSA generation.
 +	// Provide a block for the dead code so that we don't have
 +	// to add special cases everywhere else.
 +	if s.curBlock == nil {
 +		dead := s.f.NewBlock(ssa.BlockPlain)
 +		s.startBlock(dead)
 +	}
 +
 +	s.stmtList(n.Ninit)
 +	switch n.Op {
 +
 +	case OBLOCK:
 +		s.stmtList(n.List)
 +
 +	// No-ops
 +	case OEMPTY, ODCLCONST, ODCLTYPE, OFALL:
 +
 +	// Expression statements
 +	case OCALLFUNC, OCALLMETH, OCALLINTER:
 +		s.call(n, callNormal)
 +	case ODEFER:
 +		s.call(n.Left, callDefer)
 +	case OPROC:
 +		s.call(n.Left, callGo)
 +
 +	case OAS2DOTTYPE:
 +		res, resok := s.dottype(n.Rlist.N, true)
 +		s.assign(n.List.N, res, false, n.Lineno)
 +		s.assign(n.List.Next.N, resok, false, n.Lineno)
 +		return
 +
 +	case ODCL:
 +		if n.Left.Class&PHEAP == 0 {
 +			return
 +		}
 +		if compiling_runtime != 0 {
 +			Fatalf("%v escapes to heap, not allowed in runtime.", n)
 +		}
 +
 +		// TODO: the old pass hides the details of PHEAP
 +		// variables behind ONAME nodes. Figure out if it's better
 +		// to rewrite the tree and make the heapaddr construct explicit
 +		// or to keep this detail hidden behind the scenes.
 +		palloc := prealloc[n.Left]
 +		if palloc == nil {
 +			palloc = callnew(n.Left.Type)
 +			prealloc[n.Left] = palloc
 +		}
 +		r := s.expr(palloc)
 +		s.assign(n.Left.Name.Heapaddr, r, false, n.Lineno)
 +
 +	case OLABEL:
 +		sym := n.Left.Sym
 +
 +		if isblanksym(sym) {
 +			// Empty identifier is valid but useless.
 +			// See issues 11589, 11593.
 +			return
 +		}
 +
 +		lab := s.label(sym)
 +
 +		// Associate label with its control flow node, if any
 +		if ctl := n.Name.Defn; ctl != nil {
 +			switch ctl.Op {
 +			case OFOR, OSWITCH, OSELECT:
 +				s.labeledNodes[ctl] = lab
 +			}
 +		}
 +
 +		if !lab.defined() {
 +			lab.defNode = n
 +		} else {
 +			s.Error("label %v already defined at %v", sym, Ctxt.Line(int(lab.defNode.Lineno)))
 +			lab.reported = true
 +		}
 +		// The label might already have a target block via a goto.
 +		if lab.target == nil {
 +			lab.target = s.f.NewBlock(ssa.BlockPlain)
 +		}
 +
 +		// go to that label (we pretend "label:" is preceded by "goto label")
 +		b := s.endBlock()
 +		b.AddEdgeTo(lab.target)
 +		s.startBlock(lab.target)
 +
 +	case OGOTO:
 +		sym := n.Left.Sym
 +
 +		lab := s.label(sym)
 +		if lab.target == nil {
 +			lab.target = s.f.NewBlock(ssa.BlockPlain)
 +		}
 +		if !lab.used() {
 +			lab.useNode = n
 +		}
 +
 +		if lab.defined() {
 +			s.checkgoto(n, lab.defNode)
 +		} else {
 +			s.fwdGotos = append(s.fwdGotos, n)
 +		}
 +
 +		b := s.endBlock()
 +		b.AddEdgeTo(lab.target)
 +
 +	case OAS, OASWB:
 +		// Check whether we can generate static data rather than code.
 +		// If so, ignore n and defer data generation until codegen.
 +		// Failure to do this causes writes to readonly symbols.
 +		if gen_as_init(n, true) {
 +			var data []*Node
 +			if s.f.StaticData != nil {
 +				data = s.f.StaticData.([]*Node)
 +			}
 +			s.f.StaticData = append(data, n)
 +			return
 +		}
 +		var r *ssa.Value
 +		if n.Right != nil {
 +			if n.Right.Op == OSTRUCTLIT || n.Right.Op == OARRAYLIT {
 +				// All literals with nonzero fields have already been
 +				// rewritten during walk.  Any that remain are just T{}
 +				// or equivalents.  Leave r = nil to get zeroing behavior.
 +				if !iszero(n.Right) {
 +					Fatalf("literal with nonzero value in SSA: %v", n.Right)
 +				}
 +			} else {
 +				r = s.expr(n.Right)
 +			}
 +		}
 +		if n.Right != nil && n.Right.Op == OAPPEND {
 +			// Yuck!  The frontend gets rid of the write barrier, but we need it!
 +			// At least, we need it in the case where growslice is called.
 +			// TODO: Do the write barrier on just the growslice branch.
 +			// TODO: just add a ptr graying to the end of growslice?
 +			// TODO: check whether we need to do this for ODOTTYPE and ORECV also.
 +			// They get similar wb-removal treatment in walk.go:OAS.
 +			s.assign(n.Left, r, true, n.Lineno)
 +			return
 +		}
 +		s.assign(n.Left, r, n.Op == OASWB, n.Lineno)
 +
 +	case OIF:
 +		bThen := s.f.NewBlock(ssa.BlockPlain)
 +		bEnd := s.f.NewBlock(ssa.BlockPlain)
 +		var bElse *ssa.Block
 +		if n.Rlist != nil {
 +			bElse = s.f.NewBlock(ssa.BlockPlain)
 +			s.condBranch(n.Left, bThen, bElse, n.Likely)
 +		} else {
 +			s.condBranch(n.Left, bThen, bEnd, n.Likely)
 +		}
 +
 +		s.startBlock(bThen)
 +		s.stmtList(n.Nbody)
 +		if b := s.endBlock(); b != nil {
 +			b.AddEdgeTo(bEnd)
 +		}
 +
 +		if n.Rlist != nil {
 +			s.startBlock(bElse)
 +			s.stmtList(n.Rlist)
 +			if b := s.endBlock(); b != nil {
 +				b.AddEdgeTo(bEnd)
 +			}
 +		}
 +		s.startBlock(bEnd)
 +
 +	case ORETURN:
 +		s.stmtList(n.List)
 +		s.stmtList(s.exitCode)
 +		m := s.mem()
 +		b := s.endBlock()
 +		b.Kind = ssa.BlockRet
 +		b.Control = m
 +	case ORETJMP:
 +		s.stmtList(n.List)
 +		s.stmtList(s.exitCode)
 +		m := s.mem()
 +		b := s.endBlock()
 +		b.Kind = ssa.BlockRetJmp
 +		b.Aux = n.Left.Sym
 +		b.Control = m
 +
 +	case OCONTINUE, OBREAK:
 +		var op string
 +		var to *ssa.Block
 +		switch n.Op {
 +		case OCONTINUE:
 +			op = "continue"
 +			to = s.continueTo
 +		case OBREAK:
 +			op = "break"
 +			to = s.breakTo
 +		}
 +		if n.Left == nil {
 +			// plain break/continue
 +			if to == nil {
 +				s.Error("%s is not in a loop", op)
 +				return
 +			}
 +			// nothing to do; "to" is already the correct target
 +		} else {
 +			// labeled break/continue; look up the target
 +			sym := n.Left.Sym
 +			lab := s.label(sym)
 +			if !lab.used() {
 +				lab.useNode = n.Left
 +			}
 +			if !lab.defined() {
 +				s.Error("%s label not defined: %v", op, sym)
 +				lab.reported = true
 +				return
 +			}
 +			switch n.Op {
 +			case OCONTINUE:
 +				to = lab.continueTarget
 +			case OBREAK:
 +				to = lab.breakTarget
 +			}
 +			if to == nil {
 +				// Valid label but not usable with a break/continue here, e.g.:
 +				// for {
 +				// 	continue abc
 +				// }
 +				// abc:
 +				// for {}
 +				s.Error("invalid %s label %v", op, sym)
 +				lab.reported = true
 +				return
 +			}
 +		}
 +
 +		b := s.endBlock()
 +		b.AddEdgeTo(to)
 +
 +	case OFOR:
 +		// OFOR: for Ninit; Left; Right { Nbody }
 +		bCond := s.f.NewBlock(ssa.BlockPlain)
 +		bBody := s.f.NewBlock(ssa.BlockPlain)
 +		bIncr := s.f.NewBlock(ssa.BlockPlain)
 +		bEnd := s.f.NewBlock(ssa.BlockPlain)
 +
 +		// first, jump to condition test
 +		b := s.endBlock()
 +		b.AddEdgeTo(bCond)
 +
 +		// generate code to test condition
 +		s.startBlock(bCond)
 +		if n.Left != nil {
 +			s.condBranch(n.Left, bBody, bEnd, 1)
 +		} else {
 +			b := s.endBlock()
 +			b.Kind = ssa.BlockPlain
 +			b.AddEdgeTo(bBody)
 +		}
 +
 +		// set up for continue/break in body
 +		prevContinue := s.continueTo
 +		prevBreak := s.breakTo
 +		s.continueTo = bIncr
 +		s.breakTo = bEnd
 +		lab := s.labeledNodes[n]
 +		if lab != nil {
 +			// labeled for loop
 +			lab.continueTarget = bIncr
 +			lab.breakTarget = bEnd
 +		}
 +
 +		// generate body
 +		s.startBlock(bBody)
 +		s.stmtList(n.Nbody)
 +
 +		// tear down continue/break
 +		s.continueTo = prevContinue
 +		s.breakTo = prevBreak
 +		if lab != nil {
 +			lab.continueTarget = nil
 +			lab.breakTarget = nil
 +		}
 +
 +		// done with body, goto incr
 +		if b := s.endBlock(); b != nil {
 +			b.AddEdgeTo(bIncr)
 +		}
 +
 +		// generate incr
 +		s.startBlock(bIncr)
 +		if n.Right != nil {
 +			s.stmt(n.Right)
 +		}
 +		if b := s.endBlock(); b != nil {
 +			b.AddEdgeTo(bCond)
 +		}
 +		s.startBlock(bEnd)
 +
 +	case OSWITCH, OSELECT:
 +		// These have been mostly rewritten by the front end into their Nbody fields.
 +		// Our main task is to correctly hook up any break statements.
 +		bEnd := s.f.NewBlock(ssa.BlockPlain)
 +
 +		prevBreak := s.breakTo
 +		s.breakTo = bEnd
 +		lab := s.labeledNodes[n]
 +		if lab != nil {
 +			// labeled
 +			lab.breakTarget = bEnd
 +		}
 +
 +		// generate body code
 +		s.stmtList(n.Nbody)
 +
 +		s.breakTo = prevBreak
 +		if lab != nil {
 +			lab.breakTarget = nil
 +		}
 +
 +		if b := s.endBlock(); b != nil {
 +			b.AddEdgeTo(bEnd)
 +		}
 +		s.startBlock(bEnd)
 +
 +	case OVARKILL:
 +		// Insert a varkill op to record that a variable is no longer live.
 +		// We only care about liveness info at call sites, so putting the
 +		// varkill in the store chain is enough to keep it correctly ordered
 +		// with respect to call ops.
 +		if !canSSA(n.Left) {
 +			s.vars[&memVar] = s.newValue1A(ssa.OpVarKill, ssa.TypeMem, n.Left, s.mem())
 +		}
 +
++	case OVARLIVE:
++		// Insert a varlive op to record that a variable is still live.
++		if !n.Left.Addrtaken {
++			s.Fatalf("VARLIVE variable %s must have Addrtaken set", n.Left)
++		}
++		s.vars[&memVar] = s.newValue1A(ssa.OpVarLive, ssa.TypeMem, n.Left, s.mem())
++
 +	case OCHECKNIL:
 +		p := s.expr(n.Left)
 +		s.nilCheck(p)
 +
 +	default:
 +		s.Unimplementedf("unhandled stmt %s", opnames[n.Op])
 +	}
 +}
 +
 +type opAndType struct {
 +	op    Op
 +	etype EType
 +}
 +
 +var opToSSA = map[opAndType]ssa.Op{
 +	opAndType{OADD, TINT8}:    ssa.OpAdd8,
 +	opAndType{OADD, TUINT8}:   ssa.OpAdd8,
 +	opAndType{OADD, TINT16}:   ssa.OpAdd16,
 +	opAndType{OADD, TUINT16}:  ssa.OpAdd16,
 +	opAndType{OADD, TINT32}:   ssa.OpAdd32,
 +	opAndType{OADD, TUINT32}:  ssa.OpAdd32,
 +	opAndType{OADD, TPTR32}:   ssa.OpAdd32,
 +	opAndType{OADD, TINT64}:   ssa.OpAdd64,
 +	opAndType{OADD, TUINT64}:  ssa.OpAdd64,
 +	opAndType{OADD, TPTR64}:   ssa.OpAdd64,
 +	opAndType{OADD, TFLOAT32}: ssa.OpAdd32F,
 +	opAndType{OADD, TFLOAT64}: ssa.OpAdd64F,
 +
 +	opAndType{OSUB, TINT8}:    ssa.OpSub8,
 +	opAndType{OSUB, TUINT8}:   ssa.OpSub8,
 +	opAndType{OSUB, TINT16}:   ssa.OpSub16,
 +	opAndType{OSUB, TUINT16}:  ssa.OpSub16,
 +	opAndType{OSUB, TINT32}:   ssa.OpSub32,
 +	opAndType{OSUB, TUINT32}:  ssa.OpSub32,
 +	opAndType{OSUB, TINT64}:   ssa.OpSub64,
 +	opAndType{OSUB, TUINT64}:  ssa.OpSub64,
 +	opAndType{OSUB, TFLOAT32}: ssa.OpSub32F,
 +	opAndType{OSUB, TFLOAT64}: ssa.OpSub64F,
 +
 +	opAndType{ONOT, TBOOL}: ssa.OpNot,
 +
 +	opAndType{OMINUS, TINT8}:    ssa.OpNeg8,
 +	opAndType{OMINUS, TUINT8}:   ssa.OpNeg8,
 +	opAndType{OMINUS, TINT16}:   ssa.OpNeg16,
 +	opAndType{OMINUS, TUINT16}:  ssa.OpNeg16,
 +	opAndType{OMINUS, TINT32}:   ssa.OpNeg32,
 +	opAndType{OMINUS, TUINT32}:  ssa.OpNeg32,
 +	opAndType{OMINUS, TINT64}:   ssa.OpNeg64,
 +	opAndType{OMINUS, TUINT64}:  ssa.OpNeg64,
 +	opAndType{OMINUS, TFLOAT32}: ssa.OpNeg32F,
 +	opAndType{OMINUS, TFLOAT64}: ssa.OpNeg64F,
 +
 +	opAndType{OCOM, TINT8}:   ssa.OpCom8,
 +	opAndType{OCOM, TUINT8}:  ssa.OpCom8,
 +	opAndType{OCOM, TINT16}:  ssa.OpCom16,
 +	opAndType{OCOM, TUINT16}: ssa.OpCom16,
 +	opAndType{OCOM, TINT32}:  ssa.OpCom32,
 +	opAndType{OCOM, TUINT32}: ssa.OpCom32,
 +	opAndType{OCOM, TINT64}:  ssa.OpCom64,
 +	opAndType{OCOM, TUINT64}: ssa.OpCom64,
 +
 +	opAndType{OIMAG, TCOMPLEX64}:  ssa.OpComplexImag,
 +	opAndType{OIMAG, TCOMPLEX128}: ssa.OpComplexImag,
 +	opAndType{OREAL, TCOMPLEX64}:  ssa.OpComplexReal,
 +	opAndType{OREAL, TCOMPLEX128}: ssa.OpComplexReal,
 +
 +	opAndType{OMUL, TINT8}:    ssa.OpMul8,
 +	opAndType{OMUL, TUINT8}:   ssa.OpMul8,
 +	opAndType{OMUL, TINT16}:   ssa.OpMul16,
 +	opAndType{OMUL, TUINT16}:  ssa.OpMul16,
 +	opAndType{OMUL, TINT32}:   ssa.OpMul32,
 +	opAndType{OMUL, TUINT32}:  ssa.OpMul32,
 +	opAndType{OMUL, TINT64}:   ssa.OpMul64,
 +	opAndType{OMUL, TUINT64}:  ssa.OpMul64,
 +	opAndType{OMUL, TFLOAT32}: ssa.OpMul32F,
 +	opAndType{OMUL, TFLOAT64}: ssa.OpMul64F,
 +
 +	opAndType{ODIV, TFLOAT32}: ssa.OpDiv32F,
 +	opAndType{ODIV, TFLOAT64}: ssa.OpDiv64F,
 +
 +	opAndType{OHMUL, TINT8}:   ssa.OpHmul8,
 +	opAndType{OHMUL, TUINT8}:  ssa.OpHmul8u,
 +	opAndType{OHMUL, TINT16}:  ssa.OpHmul16,
 +	opAndType{OHMUL, TUINT16}: ssa.OpHmul16u,
 +	opAndType{OHMUL, TINT32}:  ssa.OpHmul32,
 +	opAndType{OHMUL, TUINT32}: ssa.OpHmul32u,
 +
 +	opAndType{ODIV, TINT8}:   ssa.OpDiv8,
 +	opAndType{ODIV, TUINT8}:  ssa.OpDiv8u,
 +	opAndType{ODIV, TINT16}:  ssa.OpDiv16,
 +	opAndType{ODIV, TUINT16}: ssa.OpDiv16u,
 +	opAndType{ODIV, TINT32}:  ssa.OpDiv32,
 +	opAndType{ODIV, TUINT32}: ssa.OpDiv32u,
 +	opAndType{ODIV, TINT64}:  ssa.OpDiv64,
 +	opAndType{ODIV, TUINT64}: ssa.OpDiv64u,
 +
 +	opAndType{OMOD, TINT8}:   ssa.OpMod8,
 +	opAndType{OMOD, TUINT8}:  ssa.OpMod8u,
 +	opAndType{OMOD, TINT16}:  ssa.OpMod16,
 +	opAndType{OMOD, TUINT16}: ssa.OpMod16u,
 +	opAndType{OMOD, TINT32}:  ssa.OpMod32,
 +	opAndType{OMOD, TUINT32}: ssa.OpMod32u,
 +	opAndType{OMOD, TINT64}:  ssa.OpMod64,
 +	opAndType{OMOD, TUINT64}: ssa.OpMod64u,
 +
 +	opAndType{OAND, TINT8}:   ssa.OpAnd8,
 +	opAndType{OAND, TUINT8}:  ssa.OpAnd8,
 +	opAndType{OAND, TINT16}:  ssa.OpAnd16,
 +	opAndType{OAND, TUINT16}: ssa.OpAnd16,
 +	opAndType{OAND, TINT32}:  ssa.OpAnd32,
 +	opAndType{OAND, TUINT32}: ssa.OpAnd32,
 +	opAndType{OAND, TINT64}:  ssa.OpAnd64,
 +	opAndType{OAND, TUINT64}: ssa.OpAnd64,
 +
 +	opAndType{OOR, TINT8}:   ssa.OpOr8,
 +	opAndType{OOR, TUINT8}:  ssa.OpOr8,
 +	opAndType{OOR, TINT16}:  ssa.OpOr16,
 +	opAndType{OOR, TUINT16}: ssa.OpOr16,
 +	opAndType{OOR, TINT32}:  ssa.OpOr32,
 +	opAndType{OOR, TUINT32}: ssa.OpOr32,
 +	opAndType{OOR, TINT64}:  ssa.OpOr64,
 +	opAndType{OOR, TUINT64}: ssa.OpOr64,
 +
 +	opAndType{OXOR, TINT8}:   ssa.OpXor8,
 +	opAndType{OXOR, TUINT8}:  ssa.OpXor8,
 +	opAndType{OXOR, TINT16}:  ssa.OpXor16,
 +	opAndType{OXOR, TUINT16}: ssa.OpXor16,
 +	opAndType{OXOR, TINT32}:  ssa.OpXor32,
 +	opAndType{OXOR, TUINT32}: ssa.OpXor32,
 +	opAndType{OXOR, TINT64}:  ssa.OpXor64,
 +	opAndType{OXOR, TUINT64}: ssa.OpXor64,
 +
 +	opAndType{OEQ, TBOOL}:      ssa.OpEq8,
 +	opAndType{OEQ, TINT8}:      ssa.OpEq8,
 +	opAndType{OEQ, TUINT8}:     ssa.OpEq8,
 +	opAndType{OEQ, TINT16}:     ssa.OpEq16,
 +	opAndType{OEQ, TUINT16}:    ssa.OpEq16,
 +	opAndType{OEQ, TINT32}:     ssa.OpEq32,
 +	opAndType{OEQ, TUINT32}:    ssa.OpEq32,
 +	opAndType{OEQ, TINT64}:     ssa.OpEq64,
 +	opAndType{OEQ, TUINT64}:    ssa.OpEq64,
 +	opAndType{OEQ, TINTER}:     ssa.OpEqInter,
 +	opAndType{OEQ, TARRAY}:     ssa.OpEqSlice,
 +	opAndType{OEQ, TFUNC}:      ssa.OpEqPtr,
 +	opAndType{OEQ, TMAP}:       ssa.OpEqPtr,
 +	opAndType{OEQ, TCHAN}:      ssa.OpEqPtr,
 +	opAndType{OEQ, TPTR64}:     ssa.OpEqPtr,
 +	opAndType{OEQ, TUINTPTR}:   ssa.OpEqPtr,
 +	opAndType{OEQ, TUNSAFEPTR}: ssa.OpEqPtr,
 +	opAndType{OEQ, TFLOAT64}:   ssa.OpEq64F,
 +	opAndType{OEQ, TFLOAT32}:   ssa.OpEq32F,
 +
 +	opAndType{ONE, TBOOL}:      ssa.OpNeq8,
 +	opAndType{ONE, TINT8}:      ssa.OpNeq8,
 +	opAndType{ONE, TUINT8}:     ssa.OpNeq8,
 +	opAndType{ONE, TINT16}:     ssa.OpNeq16,
 +	opAndType{ONE, TUINT16}:    ssa.OpNeq16,
 +	opAndType{ONE, TINT32}:     ssa.OpNeq32,
 +	opAndType{ONE, TUINT32}:    ssa.OpNeq32,
 +	opAndType{ONE, TINT64}:     ssa.OpNeq64,
 +	opAndType{ONE, TUINT64}:    ssa.OpNeq64,
 +	opAndType{ONE, TINTER}:     ssa.OpNeqInter,
 +	opAndType{ONE, TARRAY}:     ssa.OpNeqSlice,
 +	opAndType{ONE, TFUNC}:      ssa.OpNeqPtr,
 +	opAndType{ONE, TMAP}:       ssa.OpNeqPtr,
 +	opAndType{ONE, TCHAN}:      ssa.OpNeqPtr,
 +	opAndType{ONE, TPTR64}:     ssa.OpNeqPtr,
 +	opAndType{ONE, TUINTPTR}:   ssa.OpNeqPtr,
 +	opAndType{ONE, TUNSAFEPTR}: ssa.OpNeqPtr,
 +	opAndType{ONE, TFLOAT64}:   ssa.OpNeq64F,
 +	opAndType{ONE, TFLOAT32}:   ssa.OpNeq32F,
 +
 +	opAndType{OLT, TINT8}:    ssa.OpLess8,
 +	opAndType{OLT, TUINT8}:   ssa.OpLess8U,
 +	opAndType{OLT, TINT16}:   ssa.OpLess16,
 +	opAndType{OLT, TUINT16}:  ssa.OpLess16U,
 +	opAndType{OLT, TINT32}:   ssa.OpLess32,
 +	opAndType{OLT, TUINT32}:  ssa.OpLess32U,
 +	opAndType{OLT, TINT64}:   ssa.OpLess64,
 +	opAndType{OLT, TUINT64}:  ssa.OpLess64U,
 +	opAndType{OLT, TFLOAT64}: ssa.OpLess64F,
 +	opAndType{OLT, TFLOAT32}: ssa.OpLess32F,
 +
 +	opAndType{OGT, TINT8}:    ssa.OpGreater8,
 +	opAndType{OGT, TUINT8}:   ssa.OpGreater8U,
 +	opAndType{OGT, TINT16}:   ssa.OpGreater16,
 +	opAndType{OGT, TUINT16}:  ssa.OpGreater16U,
 +	opAndType{OGT, TINT32}:   ssa.OpGreater32,
 +	opAndType{OGT, TUINT32}:  ssa.OpGreater32U,
 +	opAndType{OGT, TINT64}:   ssa.OpGreater64,
 +	opAndType{OGT, TUINT64}:  ssa.OpGreater64U,
 +	opAndType{OGT, TFLOAT64}: ssa.OpGreater64F,
 +	opAndType{OGT, TFLOAT32}: ssa.OpGreater32F,
 +
 +	opAndType{OLE, TINT8}:    ssa.OpLeq8,
 +	opAndType{OLE, TUINT8}:   ssa.OpLeq8U,
 +	opAndType{OLE, TINT16}:   ssa.OpLeq16,
 +	opAndType{OLE, TUINT16}:  ssa.OpLeq16U,
 +	opAndType{OLE, TINT32}:   ssa.OpLeq32,
 +	opAndType{OLE, TUINT32}:  ssa.OpLeq32U,
 +	opAndType{OLE, TINT64}:   ssa.OpLeq64,
 +	opAndType{OLE, TUINT64}:  ssa.OpLeq64U,
 +	opAndType{OLE, TFLOAT64}: ssa.OpLeq64F,
 +	opAndType{OLE, TFLOAT32}: ssa.OpLeq32F,
 +
 +	opAndType{OGE, TINT8}:    ssa.OpGeq8,
 +	opAndType{OGE, TUINT8}:   ssa.OpGeq8U,
 +	opAndType{OGE, TINT16}:   ssa.OpGeq16,
 +	opAndType{OGE, TUINT16}:  ssa.OpGeq16U,
 +	opAndType{OGE, TINT32}:   ssa.OpGeq32,
 +	opAndType{OGE, TUINT32}:  ssa.OpGeq32U,
 +	opAndType{OGE, TINT64}:   ssa.OpGeq64,
 +	opAndType{OGE, TUINT64}:  ssa.OpGeq64U,
 +	opAndType{OGE, TFLOAT64}: ssa.OpGeq64F,
 +	opAndType{OGE, TFLOAT32}: ssa.OpGeq32F,
 +
 +	opAndType{OLROT, TUINT8}:  ssa.OpLrot8,
 +	opAndType{OLROT, TUINT16}: ssa.OpLrot16,
 +	opAndType{OLROT, TUINT32}: ssa.OpLrot32,
 +	opAndType{OLROT, TUINT64}: ssa.OpLrot64,
 +
 +	opAndType{OSQRT, TFLOAT64}: ssa.OpSqrt,
 +}
 +
 +func (s *state) concreteEtype(t *Type) EType {
 +	e := t.Etype
 +	switch e {
 +	default:
 +		return e
 +	case TINT:
 +		if s.config.IntSize == 8 {
 +			return TINT64
 +		}
 +		return TINT32
 +	case TUINT:
 +		if s.config.IntSize == 8 {
 +			return TUINT64
 +		}
 +		return TUINT32
 +	case TUINTPTR:
 +		if s.config.PtrSize == 8 {
 +			return TUINT64
 +		}
 +		return TUINT32
 +	}
 +}
 +
 +func (s *state) ssaOp(op Op, t *Type) ssa.Op {
 +	etype := s.concreteEtype(t)
 +	x, ok := opToSSA[opAndType{op, etype}]
 +	if !ok {
 +		s.Unimplementedf("unhandled binary op %s %s", opnames[op], Econv(etype))
 +	}
 +	return x
 +}
 +
 +func floatForComplex(t *Type) *Type {
 +	if t.Size() == 8 {
 +		return Types[TFLOAT32]
 +	} else {
 +		return Types[TFLOAT64]
 +	}
 +}
 +
 +type opAndTwoTypes struct {
 +	op     Op
 +	etype1 EType
 +	etype2 EType
 +}
 +
 +type twoTypes struct {
 +	etype1 EType
 +	etype2 EType
 +}
 +
 +type twoOpsAndType struct {
 +	op1              ssa.Op
 +	op2              ssa.Op
 +	intermediateType EType
 +}
 +
 +var fpConvOpToSSA = map[twoTypes]twoOpsAndType{
 +
 +	twoTypes{TINT8, TFLOAT32}:  twoOpsAndType{ssa.OpSignExt8to32, ssa.OpCvt32to32F, TINT32},
 +	twoTypes{TINT16, TFLOAT32}: twoOpsAndType{ssa.OpSignExt16to32, ssa.OpCvt32to32F, TINT32},
 +	twoTypes{TINT32, TFLOAT32}: twoOpsAndType{ssa.OpCopy, ssa.OpCvt32to32F, TINT32},
 +	twoTypes{TINT64, TFLOAT32}: twoOpsAndType{ssa.OpCopy, ssa.OpCvt64to32F, TINT64},
 +
 +	twoTypes{TINT8, TFLOAT64}:  twoOpsAndType{ssa.OpSignExt8to32, ssa.OpCvt32to64F, TINT32},
 +	twoTypes{TINT16, TFLOAT64}: twoOpsAndType{ssa.OpSignExt16to32, ssa.OpCvt32to64F, TINT32},
 +	twoTypes{TINT32, TFLOAT64}: twoOpsAndType{ssa.OpCopy, ssa.OpCvt32to64F, TINT32},
 +	twoTypes{TINT64, TFLOAT64}: twoOpsAndType{ssa.OpCopy, ssa.OpCvt64to64F, TINT64},
 +
 +	twoTypes{TFLOAT32, TINT8}:  twoOpsAndType{ssa.OpCvt32Fto32, ssa.OpTrunc32to8, TINT32},
 +	twoTypes{TFLOAT32, TINT16}: twoOpsAndType{ssa.OpCvt32Fto32, ssa.OpTrunc32to16, TINT32},
 +	twoTypes{TFLOAT32, TINT32}: twoOpsAndType{ssa.OpCvt32Fto32, ssa.OpCopy, TINT32},
 +	twoTypes{TFLOAT32, TINT64}: twoOpsAndType{ssa.OpCvt32Fto64, ssa.OpCopy, TINT64},
 +
 +	twoTypes{TFLOAT64, TINT8}:  twoOpsAndType{ssa.OpCvt64Fto32, ssa.OpTrunc32to8, TINT32},
 +	twoTypes{TFLOAT64, TINT16}: twoOpsAndType{ssa.OpCvt64Fto32, ssa.OpTrunc32to16, TINT32},
 +	twoTypes{TFLOAT64, TINT32}: twoOpsAndType{ssa.OpCvt64Fto32, ssa.OpCopy, TINT32},
 +	twoTypes{TFLOAT64, TINT64}: twoOpsAndType{ssa.OpCvt64Fto64, ssa.OpCopy, TINT64},
 +	// unsigned
 +	twoTypes{TUINT8, TFLOAT32}:  twoOpsAndType{ssa.OpZeroExt8to32, ssa.OpCvt32to32F, TINT32},
 +	twoTypes{TUINT16, TFLOAT32}: twoOpsAndType{ssa.OpZeroExt16to32, ssa.OpCvt32to32F, TINT32},
 +	twoTypes{TUINT32, TFLOAT32}: twoOpsAndType{ssa.OpZeroExt32to64, ssa.OpCvt64to32F, TINT64}, // go wide to dodge unsigned
 +	twoTypes{TUINT64, TFLOAT32}: twoOpsAndType{ssa.OpCopy, ssa.OpInvalid, TUINT64},            // Cvt64Uto32F, branchy code expansion instead
 +
 +	twoTypes{TUINT8, TFLOAT64}:  twoOpsAndType{ssa.OpZeroExt8to32, ssa.OpCvt32to64F, TINT32},
 +	twoTypes{TUINT16, TFLOAT64}: twoOpsAndType{ssa.OpZeroExt16to32, ssa.OpCvt32to64F, TINT32},
 +	twoTypes{TUINT32, TFLOAT64}: twoOpsAndType{ssa.OpZeroExt32to64, ssa.OpCvt64to64F, TINT64}, // go wide to dodge unsigned
 +	twoTypes{TUINT64, TFLOAT64}: twoOpsAndType{ssa.OpCopy, ssa.OpInvalid, TUINT64},            // Cvt64Uto64F, branchy code expansion instead
 +
 +	twoTypes{TFLOAT32, TUINT8}:  twoOpsAndType{ssa.OpCvt32Fto32, ssa.OpTrunc32to8, TINT32},
 +	twoTypes{TFLOAT32, TUINT16}: twoOpsAndType{ssa.OpCvt32Fto32, ssa.OpTrunc32to16, TINT32},
 +	twoTypes{TFLOAT32, TUINT32}: twoOpsAndType{ssa.OpCvt32Fto64, ssa.OpTrunc64to32, TINT64}, // go wide to dodge unsigned
 +	twoTypes{TFLOAT32, TUINT64}: twoOpsAndType{ssa.OpInvalid, ssa.OpCopy, TUINT64},          // Cvt32Fto64U, branchy code expansion instead
 +
 +	twoTypes{TFLOAT64, TUINT8}:  twoOpsAndType{ssa.OpCvt64Fto32, ssa.OpTrunc32to8, TINT32},
 +	twoTypes{TFLOAT64, TUINT16}: twoOpsAndType{ssa.OpCvt64Fto32, ssa.OpTrunc32to16, TINT32},
 +	twoTypes{TFLOAT64, TUINT32}: twoOpsAndType{ssa.OpCvt64Fto64, ssa.OpTrunc64to32, TINT64}, // go wide to dodge unsigned
 +	twoTypes{TFLOAT64, TUINT64}: twoOpsAndType{ssa.OpInvalid, ssa.OpCopy, TUINT64},          // Cvt64Fto64U, branchy code expansion instead
 +
 +	// float
 +	twoTypes{TFLOAT64, TFLOAT32}: twoOpsAndType{ssa.OpCvt64Fto32F, ssa.OpCopy, TFLOAT32},
 +	twoTypes{TFLOAT64, TFLOAT64}: twoOpsAndType{ssa.OpCopy, ssa.OpCopy, TFLOAT64},
 +	twoTypes{TFLOAT32, TFLOAT32}: twoOpsAndType{ssa.OpCopy, ssa.OpCopy, TFLOAT32},
 +	twoTypes{TFLOAT32, TFLOAT64}: twoOpsAndType{ssa.OpCvt32Fto64F, ssa.OpCopy, TFLOAT64},
 +}
 +
 +var shiftOpToSSA = map[opAndTwoTypes]ssa.Op{
 +	opAndTwoTypes{OLSH, TINT8, TUINT8}:   ssa.OpLsh8x8,
 +	opAndTwoTypes{OLSH, TUINT8, TUINT8}:  ssa.OpLsh8x8,
 +	opAndTwoTypes{OLSH, TINT8, TUINT16}:  ssa.OpLsh8x16,
 +	opAndTwoTypes{OLSH, TUINT8, TUINT16}: ssa.OpLsh8x16,
 +	opAndTwoTypes{OLSH, TINT8, TUINT32}:  ssa.OpLsh8x32,
 +	opAndTwoTypes{OLSH, TUINT8, TUINT32}: ssa.OpLsh8x32,
 +	opAndTwoTypes{OLSH, TINT8, TUINT64}:  ssa.OpLsh8x64,
 +	opAndTwoTypes{OLSH, TUINT8, TUINT64}: ssa.OpLsh8x64,
 +
 +	opAndTwoTypes{OLSH, TINT16, TUINT8}:   ssa.OpLsh16x8,
 +	opAndTwoTypes{OLSH, TUINT16, TUINT8}:  ssa.OpLsh16x8,
 +	opAndTwoTypes{OLSH, TINT16, TUINT16}:  ssa.OpLsh16x16,
 +	opAndTwoTypes{OLSH, TUINT16, TUINT16}: ssa.OpLsh16x16,
 +	opAndTwoTypes{OLSH, TINT16, TUINT32}:  ssa.OpLsh16x32,
 +	opAndTwoTypes{OLSH, TUINT16, TUINT32}: ssa.OpLsh16x32,
 +	opAndTwoTypes{OLSH, TINT16, TUINT64}:  ssa.OpLsh16x64,
 +	opAndTwoTypes{OLSH, TUINT16, TUINT64}: ssa.OpLsh16x64,
 +
 +	opAndTwoTypes{OLSH, TINT32, TUINT8}:   ssa.OpLsh32x8,
 +	opAndTwoTypes{OLSH, TUINT32, TUINT8}:  ssa.OpLsh32x8,
 +	opAndTwoTypes{OLSH, TINT32, TUINT16}:  ssa.OpLsh32x16,
 +	opAndTwoTypes{OLSH, TUINT32, TUINT16}: ssa.OpLsh32x16,
 +	opAndTwoTypes{OLSH, TINT32, TUINT32}:  ssa.OpLsh32x32,
 +	opAndTwoTypes{OLSH, TUINT32, TUINT32}: ssa.OpLsh32x32,
 +	opAndTwoTypes{OLSH, TINT32, TUINT64}:  ssa.OpLsh32x64,
 +	opAndTwoTypes{OLSH, TUINT32, TUINT64}: ssa.OpLsh32x64,
 +
 +	opAndTwoTypes{OLSH, TINT64, TUINT8}:   ssa.OpLsh64x8,
 +	opAndTwoTypes{OLSH, TUINT64, TUINT8}:  ssa.OpLsh64x8,
 +	opAndTwoTypes{OLSH, TINT64, TUINT16}:  ssa.OpLsh64x16,
 +	opAndTwoTypes{OLSH, TUINT64, TUINT16}: ssa.OpLsh64x16,
 +	opAndTwoTypes{OLSH, TINT64, TUINT32}:  ssa.OpLsh64x32,
 +	opAndTwoTypes{OLSH, TUINT64, TUINT32}: ssa.OpLsh64x32,
 +	opAndTwoTypes{OLSH, TINT64, TUINT64}:  ssa.OpLsh64x64,
 +	opAndTwoTypes{OLSH, TUINT64, TUINT64}: ssa.OpLsh64x64,
 +
 +	opAndTwoTypes{ORSH, TINT8, TUINT8}:   ssa.OpRsh8x8,
 +	opAndTwoTypes{ORSH, TUINT8, TUINT8}:  ssa.OpRsh8Ux8,
 +	opAndTwoTypes{ORSH, TINT8, TUINT16}:  ssa.OpRsh8x16,
 +	opAndTwoTypes{ORSH, TUINT8, TUINT16}: ssa.OpRsh8Ux16,
 +	opAndTwoTypes{ORSH, TINT8, TUINT32}:  ssa.OpRsh8x32,
 +	opAndTwoTypes{ORSH, TUINT8, TUINT32}: ssa.OpRsh8Ux32,
 +	opAndTwoTypes{ORSH, TINT8, TUINT64}:  ssa.OpRsh8x64,
 +	opAndTwoTypes{ORSH, TUINT8, TUINT64}: ssa.OpRsh8Ux64,
 +
 +	opAndTwoTypes{ORSH, TINT16, TUINT8}:   ssa.OpRsh16x8,
 +	opAndTwoTypes{ORSH, TUINT16, TUINT8}:  ssa.OpRsh16Ux8,
 +	opAndTwoTypes{ORSH, TINT16, TUINT16}:  ssa.OpRsh16x16,
 +	opAndTwoTypes{ORSH, TUINT16, TUINT16}: ssa.OpRsh16Ux16,
 +	opAndTwoTypes{ORSH, TINT16, TUINT32}:  ssa.OpRsh16x32,
 +	opAndTwoTypes{ORSH, TUINT16, TUINT32}: ssa.OpRsh16Ux32,
 +	opAndTwoTypes{ORSH, TINT16, TUINT64}:  ssa.OpRsh16x64,
 +	opAndTwoTypes{ORSH, TUINT16, TUINT64}: ssa.OpRsh16Ux64,
 +
 +	opAndTwoTypes{ORSH, TINT32, TUINT8}:   ssa.OpRsh32x8,
 +	opAndTwoTypes{ORSH, TUINT32, TUINT8}:  ssa.OpRsh32Ux8,
 +	opAndTwoTypes{ORSH, TINT32, TUINT16}:  ssa.OpRsh32x16,
 +	opAndTwoTypes{ORSH, TUINT32, TUINT16}: ssa.OpRsh32Ux16,
 +	opAndTwoTypes{ORSH, TINT32, TUINT32}:  ssa.OpRsh32x32,
 +	opAndTwoTypes{ORSH, TUINT32, TUINT32}: ssa.OpRsh32Ux32,
 +	opAndTwoTypes{ORSH, TINT32, TUINT64}:  ssa.OpRsh32x64,
 +	opAndTwoTypes{ORSH, TUINT32, TUINT64}: ssa.OpRsh32Ux64,
 +
 +	opAndTwoTypes{ORSH, TINT64, TUINT8}:   ssa.OpRsh64x8,
 +	opAndTwoTypes{ORSH, TUINT64, TUINT8}:  ssa.OpRsh64Ux8,
 +	opAndTwoTypes{ORSH, TINT64, TUINT16}:  ssa.OpRsh64x16,
 +	opAndTwoTypes{ORSH, TUINT64, TUINT16}: ssa.OpRsh64Ux16,
 +	opAndTwoTypes{ORSH, TINT64, TUINT32}:  ssa.OpRsh64x32,
 +	opAndTwoTypes{ORSH, TUINT64, TUINT32}: ssa.OpRsh64Ux32,
 +	opAndTwoTypes{ORSH, TINT64, TUINT64}:  ssa.OpRsh64x64,
 +	opAndTwoTypes{ORSH, TUINT64, TUINT64}: ssa.OpRsh64Ux64,
 +}
 +
 +func (s *state) ssaShiftOp(op Op, t *Type, u *Type) ssa.Op {
 +	etype1 := s.concreteEtype(t)
 +	etype2 := s.concreteEtype(u)
 +	x, ok := shiftOpToSSA[opAndTwoTypes{op, etype1, etype2}]
 +	if !ok {
 +		s.Unimplementedf("unhandled shift op %s etype=%s/%s", opnames[op], Econv(etype1), Econv(etype2))
 +	}
 +	return x
 +}
 +
 +func (s *state) ssaRotateOp(op Op, t *Type) ssa.Op {
 +	etype1 := s.concreteEtype(t)
 +	x, ok := opToSSA[opAndType{op, etype1}]
 +	if !ok {
 +		s.Unimplementedf("unhandled rotate op %s etype=%s", opnames[op], Econv(etype1))
 +	}
 +	return x
 +}
 +
 +// expr converts the expression n to ssa, adds it to s and returns the ssa result.
 +func (s *state) expr(n *Node) *ssa.Value {
 +	s.pushLine(n.Lineno)
 +	defer s.popLine()
 +
 +	s.stmtList(n.Ninit)
 +	switch n.Op {
 +	case OCFUNC:
 +		aux := s.lookupSymbol(n, &ssa.ExternSymbol{n.Type, n.Left.Sym})
 +		return s.entryNewValue1A(ssa.OpAddr, n.Type, aux, s.sb)
 +	case OPARAM:
 +		addr := s.addr(n, false)
 +		return s.newValue2(ssa.OpLoad, n.Left.Type, addr, s.mem())
 +	case ONAME:
 +		if n.Class == PFUNC {
 +			// "value" of a function is the address of the function's closure
 +			sym := funcsym(n.Sym)
 +			aux := &ssa.ExternSymbol{n.Type, sym}
 +			return s.entryNewValue1A(ssa.OpAddr, Ptrto(n.Type), aux, s.sb)
 +		}
 +		if canSSA(n) {
 +			return s.variable(n, n.Type)
 +		}
 +		addr := s.addr(n, false)
 +		return s.newValue2(ssa.OpLoad, n.Type, addr, s.mem())
 +	case OCLOSUREVAR:
 +		addr := s.addr(n, false)
 +		return s.newValue2(ssa.OpLoad, n.Type, addr, s.mem())
 +	case OLITERAL:
 +		switch n.Val().Ctype() {
 +		case CTINT:
 +			i := Mpgetfix(n.Val().U.(*Mpint))
 +			switch n.Type.Size() {
 +			case 1:
 +				return s.constInt8(n.Type, int8(i))
 +			case 2:
 +				return s.constInt16(n.Type, int16(i))
 +			case 4:
 +				return s.constInt32(n.Type, int32(i))
 +			case 8:
 +				return s.constInt64(n.Type, i)
 +			default:
 +				s.Fatalf("bad integer size %d", n.Type.Size())
 +				return nil
 +			}
 +		case CTSTR:
 +			return s.entryNewValue0A(ssa.OpConstString, n.Type, n.Val().U)
 +		case CTBOOL:
 +			return s.constBool(n.Val().U.(bool))
 +		case CTNIL:
 +			t := n.Type
 +			switch {
 +			case t.IsSlice():
 +				return s.entryNewValue0(ssa.OpConstSlice, t)
 +			case t.IsInterface():
 +				return s.entryNewValue0(ssa.OpConstInterface, t)
 +			default:
 +				return s.entryNewValue0(ssa.OpConstNil, t)
 +			}
 +		case CTFLT:
 +			f := n.Val().U.(*Mpflt)
 +			switch n.Type.Size() {
 +			case 4:
 +				// -0.0 literals need to be treated as if they were 0.0, adding 0.0 here
 +				// accomplishes this while not affecting other values.
 +				return s.constFloat32(n.Type, mpgetflt32(f)+0.0)
 +			case 8:
 +				return s.constFloat64(n.Type, mpgetflt(f)+0.0)
 +			default:
 +				s.Fatalf("bad float size %d", n.Type.Size())
 +				return nil
 +			}
 +		case CTCPLX:
 +			c := n.Val().U.(*Mpcplx)
 +			r := &c.Real
 +			i := &c.Imag
 +			switch n.Type.Size() {
 +			case 8:
 +				{
 +					pt := Types[TFLOAT32]
 +					// -0.0 literals need to be treated as if they were 0.0, adding 0.0 here
 +					// accomplishes this while not affecting other values.
 +					return s.newValue2(ssa.OpComplexMake, n.Type,
 +						s.constFloat32(pt, mpgetflt32(r)+0.0),
 +						s.constFloat32(pt, mpgetflt32(i)+0.0))
 +				}
 +			case 16:
 +				{
 +					pt := Types[TFLOAT64]
 +					return s.newValue2(ssa.OpComplexMake, n.Type,
 +						s.constFloat64(pt, mpgetflt(r)+0.0),
 +						s.constFloat64(pt, mpgetflt(i)+0.0))
 +				}
 +			default:
 +				s.Fatalf("bad float size %d", n.Type.Size())
 +				return nil
 +			}
 +
 +		default:
 +			s.Unimplementedf("unhandled OLITERAL %v", n.Val().Ctype())
 +			return nil
 +		}
 +	case OCONVNOP:
 +		to := n.Type
 +		from := n.Left.Type
 +
 +		// Assume everything will work out, so set up our return value.
 +		// Anything interesting that happens from here is a fatal.
 +		x := s.expr(n.Left)
 +
 +		// Special case for not confusing GC and liveness.
 +		// We don't want pointers accidentally classified
 +		// as not-pointers or vice-versa because of copy
 +		// elision.
 +		if to.IsPtr() != from.IsPtr() {
 +			return s.newValue2(ssa.OpConvert, to, x, s.mem())
 +		}
 +
 +		v := s.newValue1(ssa.OpCopy, to, x) // ensure that v has the right type
 +
 +		// CONVNOP closure
 +		if to.Etype == TFUNC && from.IsPtr() {
 +			return v
 +		}
 +
 +		// named <--> unnamed type or typed <--> untyped const
 +		if from.Etype == to.Etype {
 +			return v
 +		}
 +
 +		// unsafe.Pointer <--> *T
 +		if to.Etype == TUNSAFEPTR && from.IsPtr() || from.Etype == TUNSAFEPTR && to.IsPtr() {
 +			return v
 +		}
 +
 +		dowidth(from)
 +		dowidth(to)
 +		if from.Width != to.Width {
 +			s.Fatalf("CONVNOP width mismatch %v (%d) -> %v (%d)\n", from, from.Width, to, to.Width)
 +			return nil
 +		}
 +		if etypesign(from.Etype) != etypesign(to.Etype) {
 +			s.Fatalf("CONVNOP sign mismatch %v (%s) -> %v (%s)\n", from, Econv(from.Etype), to, Econv(to.Etype))
 +			return nil
 +		}
 +
 +		if flag_race != 0 {
 +			// These appear to be fine, but they fail the
 +			// integer constraint below, so okay them here.
 +			// Sample non-integer conversion: map[string]string -> *uint8
 +			return v
 +		}
 +
 +		if etypesign(from.Etype) == 0 {
 +			s.Fatalf("CONVNOP unrecognized non-integer %v -> %v\n", from, to)
 +			return nil
 +		}
 +
 +		// integer, same width, same sign
 +		return v
 +
 +	case OCONV:
 +		x := s.expr(n.Left)
 +		ft := n.Left.Type // from type
 +		tt := n.Type      // to type
 +		if ft.IsInteger() && tt.IsInteger() {
 +			var op ssa.Op
 +			if tt.Size() == ft.Size() {
 +				op = ssa.OpCopy
 +			} else if tt.Size() < ft.Size() {
 +				// truncation
 +				switch 10*ft.Size() + tt.Size() {
 +				case 21:
 +					op = ssa.OpTrunc16to8
 +				case 41:
 +					op = ssa.OpTrunc32to8
 +				case 42:
 +					op = ssa.OpTrunc32to16
 +				case 81:
 +					op = ssa.OpTrunc64to8
 +				case 82:
 +					op = ssa.OpTrunc64to16
 +				case 84:
 +					op = ssa.OpTrunc64to32
 +				default:
 +					s.Fatalf("weird integer truncation %s -> %s", ft, tt)
 +				}
 +			} else if ft.IsSigned() {
 +				// sign extension
 +				switch 10*ft.Size() + tt.Size() {
 +				case 12:
 +					op = ssa.OpSignExt8to16
 +				case 14:
 +					op = ssa.OpSignExt8to32
 +				case 18:
 +					op = ssa.OpSignExt8to64
 +				case 24:
 +					op = ssa.OpSignExt16to32
 +				case 28:
 +					op = ssa.OpSignExt16to64
 +				case 48:
 +					op = ssa.OpSignExt32to64
 +				default:
 +					s.Fatalf("bad integer sign extension %s -> %s", ft, tt)
 +				}
 +			} else {
 +				// zero extension
 +				switch 10*ft.Size() + tt.Size() {
 +				case 12:
 +					op = ssa.OpZeroExt8to16
 +				case 14:
 +					op = ssa.OpZeroExt8to32
 +				case 18:
 +					op = ssa.OpZeroExt8to64
 +				case 24:
 +					op = ssa.OpZeroExt16to32
 +				case 28:
 +					op = ssa.OpZeroExt16to64
 +				case 48:
 +					op = ssa.OpZeroExt32to64
 +				default:
 +					s.Fatalf("weird integer sign extension %s -> %s", ft, tt)
 +				}
 +			}
 +			return s.newValue1(op, n.Type, x)
 +		}
 +
 +		if ft.IsFloat() || tt.IsFloat() {
 +			conv, ok := fpConvOpToSSA[twoTypes{s.concreteEtype(ft), s.concreteEtype(tt)}]
 +			if !ok {
 +				s.Fatalf("weird float conversion %s -> %s", ft, tt)
 +			}
 +			op1, op2, it := conv.op1, conv.op2, conv.intermediateType
 +
 +			if op1 != ssa.OpInvalid && op2 != ssa.OpInvalid {
 +				// normal case, not tripping over unsigned 64
 +				if op1 == ssa.OpCopy {
 +					if op2 == ssa.OpCopy {
 +						return x
 +					}
 +					return s.newValue1(op2, n.Type, x)
 +				}
 +				if op2 == ssa.OpCopy {
 +					return s.newValue1(op1, n.Type, x)
 +				}
 +				return s.newValue1(op2, n.Type, s.newValue1(op1, Types[it], x))
 +			}
 +			// Tricky 64-bit unsigned cases.
 +			if ft.IsInteger() {
 +				// therefore tt is float32 or float64, and ft is also unsigned
 +				if tt.Size() == 4 {
 +					return s.uint64Tofloat32(n, x, ft, tt)
 +				}
 +				if tt.Size() == 8 {
 +					return s.uint64Tofloat64(n, x, ft, tt)
 +				}
 +				s.Fatalf("weird unsigned integer to float conversion %s -> %s", ft, tt)
 +			}
 +			// therefore ft is float32 or float64, and tt is unsigned integer
 +			if ft.Size() == 4 {
 +				return s.float32ToUint64(n, x, ft, tt)
 +			}
 +			if ft.Size() == 8 {
 +				return s.float64ToUint64(n, x, ft, tt)
 +			}
 +			s.Fatalf("weird float to unsigned integer conversion %s -> %s", ft, tt)
 +			return nil
 +		}
 +
 +		if ft.IsComplex() && tt.IsComplex() {
 +			var op ssa.Op
 +			if ft.Size() == tt.Size() {
 +				op = ssa.OpCopy
 +			} else if ft.Size() == 8 && tt.Size() == 16 {
 +				op = ssa.OpCvt32Fto64F
 +			} else if ft.Size() == 16 && tt.Size() == 8 {
 +				op = ssa.OpCvt64Fto32F
 +			} else {
 +				s.Fatalf("weird complex conversion %s -> %s", ft, tt)
 +			}
 +			ftp := floatForComplex(ft)
 +			ttp := floatForComplex(tt)
 +			return s.newValue2(ssa.OpComplexMake, tt,
 +				s.newValue1(op, ttp, s.newValue1(ssa.OpComplexReal, ftp, x)),
 +				s.newValue1(op, ttp, s.newValue1(ssa.OpComplexImag, ftp, x)))
 +		}
 +
 +		s.Unimplementedf("unhandled OCONV %s -> %s", Econv(n.Left.Type.Etype), Econv(n.Type.Etype))
 +		return nil
 +
 +	case ODOTTYPE:
 +		res, _ := s.dottype(n, false)
 +		return res
 +
 +	// binary ops
 +	case OLT, OEQ, ONE, OLE, OGE, OGT:
 +		a := s.expr(n.Left)
 +		b := s.expr(n.Right)
 +		if n.Left.Type.IsComplex() {
 +			pt := floatForComplex(n.Left.Type)
 +			op := s.ssaOp(OEQ, pt)
 +			r := s.newValue2(op, Types[TBOOL], s.newValue1(ssa.OpComplexReal, pt, a), s.newValue1(ssa.OpComplexReal, pt, b))
 +			i := s.newValue2(op, Types[TBOOL], s.newValue1(ssa.OpComplexImag, pt, a), s.newValue1(ssa.OpComplexImag, pt, b))
 +			c := s.newValue2(ssa.OpAnd8, Types[TBOOL], r, i)
 +			switch n.Op {
 +			case OEQ:
 +				return c
 +			case ONE:
 +				return s.newValue1(ssa.OpNot, Types[TBOOL], c)
 +			default:
 +				s.Fatalf("ordered complex compare %s", opnames[n.Op])
 +			}
 +		}
 +		return s.newValue2(s.ssaOp(n.Op, n.Left.Type), Types[TBOOL], a, b)
 +	case OMUL:
 +		a := s.expr(n.Left)
 +		b := s.expr(n.Right)
 +		if n.Type.IsComplex() {
 +			mulop := ssa.OpMul64F
 +			addop := ssa.OpAdd64F
 +			subop := ssa.OpSub64F
 +			pt := floatForComplex(n.Type) // Could be Float32 or Float64
 +			wt := Types[TFLOAT64]         // Compute in Float64 to minimize cancellation error
 +
 +			areal := s.newValue1(ssa.OpComplexReal, pt, a)
 +			breal := s.newValue1(ssa.OpComplexReal, pt, b)
 +			aimag := s.newValue1(ssa.OpComplexImag, pt, a)
 +			bimag := s.newValue1(ssa.OpComplexImag, pt, b)
 +
 +			if pt != wt { // Widen for calculation
 +				areal = s.newValue1(ssa.OpCvt32Fto64F, wt, areal)
 +				breal = s.newValue1(ssa.OpCvt32Fto64F, wt, breal)
 +				aimag = s.newValue1(ssa.OpCvt32Fto64F, wt, aimag)
 +				bimag = s.newValue1(ssa.OpCvt32Fto64F, wt, bimag)
 +			}
 +
 +			xreal := s.newValue2(subop, wt, s.newValue2(mulop, wt, areal, breal), s.newValue2(mulop, wt, aimag, bimag))
 +			ximag := s.newValue2(addop, wt, s.newValue2(mulop, wt, areal, bimag), s.newValue2(mulop, wt, aimag, breal))
 +
 +			if pt != wt { // Narrow to store back
 +				xreal = s.newValue1(ssa.OpCvt64Fto32F, pt, xreal)
 +				ximag = s.newValue1(ssa.OpCvt64Fto32F, pt, ximag)
 +			}
 +
 +			return s.newValue2(ssa.OpComplexMake, n.Type, xreal, ximag)
 +		}
 +		return s.newValue2(s.ssaOp(n.Op, n.Type), a.Type, a, b)
 +
 +	case ODIV:
 +		a := s.expr(n.Left)
 +		b := s.expr(n.Right)
 +		if n.Type.IsComplex() {
 +			// TODO this is not executed because the front-end substitutes a runtime call.
 +			// That probably ought to change; with modest optimization the widen/narrow
 +			// conversions could all be elided in larger expression trees.
 +			mulop := ssa.OpMul64F
 +			addop := ssa.OpAdd64F
 +			subop := ssa.OpSub64F
 +			divop := ssa.OpDiv64F
 +			pt := floatForComplex(n.Type) // Could be Float32 or Float64
 +			wt := Types[TFLOAT64]         // Compute in Float64 to minimize cancellation error
 +
 +			areal := s.newValue1(ssa.OpComplexReal, pt, a)
 +			breal := s.newValue1(ssa.OpComplexReal, pt, b)
 +			aimag := s.newValue1(ssa.OpComplexImag, pt, a)
 +			bimag := s.newValue1(ssa.OpComplexImag, pt, b)
 +
 +			if pt != wt { // Widen for calculation
 +				areal = s.newValue1(ssa.OpCvt32Fto64F, wt, areal)
 +				breal = s.newValue1(ssa.OpCvt32Fto64F, wt, breal)
 +				aimag = s.newValue1(ssa.OpCvt32Fto64F, wt, aimag)
 +				bimag = s.newValue1(ssa.OpCvt32Fto64F, wt, bimag)
 +			}
 +
 +			denom := s.newValue2(addop, wt, s.newValue2(mulop, wt, breal, breal), s.newValue2(mulop, wt, bimag, bimag))
 +			xreal := s.newValue2(addop, wt, s.newValue2(mulop, wt, areal, breal), s.newValue2(mulop, wt, aimag, bimag))
 +			ximag := s.newValue2(subop, wt, s.newValue2(mulop, wt, aimag, breal), s.newValue2(mulop, wt, areal, bimag))
 +
 +			// TODO not sure if this is best done in wide precision or narrow
 +			// Double-rounding might be an issue.
 +			// Note that the pre-SSA implementation does the entire calculation
 +			// in wide format, so wide is compatible.
 +			xreal = s.newValue2(divop, wt, xreal, denom)
 +			ximag = s.newValue2(divop, wt, ximag, denom)
 +
 +			if pt != wt { // Narrow to store back
 +				xreal = s.newValue1(ssa.OpCvt64Fto32F, pt, xreal)
 +				ximag = s.newValue1(ssa.OpCvt64Fto32F, pt, ximag)
 +			}
 +			return s.newValue2(ssa.OpComplexMake, n.Type, xreal, ximag)
 +		}
 +		if n.Type.IsFloat() {
 +			return s.newValue2(s.ssaOp(n.Op, n.Type), a.Type, a, b)
 +		} else {
 +			// do a size-appropriate check for zero
 +			cmp := s.newValue2(s.ssaOp(ONE, n.Type), Types[TBOOL], b, s.zeroVal(n.Type))
 +			s.check(cmp, panicdivide)
 +			return s.newValue2(s.ssaOp(n.Op, n.Type), a.Type, a, b)
 +		}
 +	case OMOD:
 +		a := s.expr(n.Left)
 +		b := s.expr(n.Right)
 +		// do a size-appropriate check for zero
 +		cmp := s.newValue2(s.ssaOp(ONE, n.Type), Types[TBOOL], b, s.zeroVal(n.Type))
 +		s.check(cmp, panicdivide)
 +		return s.newValue2(s.ssaOp(n.Op, n.Type), a.Type, a, b)
 +	case OADD, OSUB:
 +		a := s.expr(n.Left)
 +		b := s.expr(n.Right)
 +		if n.Type.IsComplex() {
 +			pt := floatForComplex(n.Type)
 +			op := s.ssaOp(n.Op, pt)
 +			return s.newValue2(ssa.OpComplexMake, n.Type,
 +				s.newValue2(op, pt, s.newValue1(ssa.OpComplexReal, pt, a), s.newValue1(ssa.OpComplexReal, pt, b)),
 +				s.newValue2(op, pt, s.newValue1(ssa.OpComplexImag, pt, a), s.newValue1(ssa.OpComplexImag, pt, b)))
 +		}
 +		return s.newValue2(s.ssaOp(n.Op, n.Type), a.Type, a, b)
 +	case OAND, OOR, OHMUL, OXOR:
 +		a := s.expr(n.Left)
 +		b := s.expr(n.Right)
 +		return s.newValue2(s.ssaOp(n.Op, n.Type), a.Type, a, b)
 +	case OLSH, ORSH:
 +		a := s.expr(n.Left)
 +		b := s.expr(n.Right)
 +		return s.newValue2(s.ssaShiftOp(n.Op, n.Type, n.Right.Type), a.Type, a, b)
 +	case OLROT:
 +		a := s.expr(n.Left)
 +		i := n.Right.Int()
 +		if i <= 0 || i >= n.Type.Size()*8 {
 +			s.Fatalf("Wrong rotate distance for LROT, expected 1 through %d, saw %d", n.Type.Size()*8-1, i)
 +		}
 +		return s.newValue1I(s.ssaRotateOp(n.Op, n.Type), a.Type, i, a)
 +	case OANDAND, OOROR:
 +		// To implement OANDAND (and OOROR), we introduce a
 +		// new temporary variable to hold the result. The
 +		// variable is associated with the OANDAND node in the
 +		// s.vars table (normally variables are only
 +		// associated with ONAME nodes). We convert
 +		//     A && B
 +		// to
 +		//     var = A
 +		//     if var {
 +		//         var = B
 +		//     }
 +		// Using var in the subsequent block introduces the
 +		// necessary phi variable.
 +		el := s.expr(n.Left)
 +		s.vars[n] = el
 +
 +		b := s.endBlock()
 +		b.Kind = ssa.BlockIf
 +		b.Control = el
 +		// In theory, we should set b.Likely here based on context.
 +		// However, gc only gives us likeliness hints
 +		// in a single place, for plain OIF statements,
 +		// and passing around context is finnicky, so don't bother for now.
 +
 +		bRight := s.f.NewBlock(ssa.BlockPlain)
 +		bResult := s.f.NewBlock(ssa.BlockPlain)
 +		if n.Op == OANDAND {
 +			b.AddEdgeTo(bRight)
 +			b.AddEdgeTo(bResult)
 +		} else if n.Op == OOROR {
 +			b.AddEdgeTo(bResult)
 +			b.AddEdgeTo(bRight)
 +		}
 +
 +		s.startBlock(bRight)
 +		er := s.expr(n.Right)
 +		s.vars[n] = er
 +
 +		b = s.endBlock()
 +		b.AddEdgeTo(bResult)
 +
 +		s.startBlock(bResult)
 +		return s.variable(n, Types[TBOOL])
 +	case OCOMPLEX:
 +		r := s.expr(n.Left)
 +		i := s.expr(n.Right)
 +		return s.newValue2(ssa.OpComplexMake, n.Type, r, i)
 +
 +	// unary ops
 +	case OMINUS:
 +		a := s.expr(n.Left)
 +		if n.Type.IsComplex() {
 +			tp := floatForComplex(n.Type)
 +			negop := s.ssaOp(n.Op, tp)
 +			return s.newValue2(ssa.OpComplexMake, n.Type,
 +				s.newValue1(negop, tp, s.newValue1(ssa.OpComplexReal, tp, a)),
 +				s.newValue1(negop, tp, s.newValue1(ssa.OpComplexImag, tp, a)))
 +		}
 +		return s.newValue1(s.ssaOp(n.Op, n.Type), a.Type, a)
 +	case ONOT, OCOM, OSQRT:
 +		a := s.expr(n.Left)
 +		return s.newValue1(s.ssaOp(n.Op, n.Type), a.Type, a)
 +	case OIMAG, OREAL:
 +		a := s.expr(n.Left)
 +		return s.newValue1(s.ssaOp(n.Op, n.Left.Type), n.Type, a)
 +	case OPLUS:
 +		return s.expr(n.Left)
 +
 +	case OADDR:
 +		return s.addr(n.Left, n.Bounded)
 +
 +	case OINDREG:
 +		if int(n.Reg) != Thearch.REGSP {
 +			s.Unimplementedf("OINDREG of non-SP register %s in expr: %v", obj.Rconv(int(n.Reg)), n)
 +			return nil
 +		}
 +		addr := s.entryNewValue1I(ssa.OpOffPtr, Ptrto(n.Type), n.Xoffset, s.sp)
 +		return s.newValue2(ssa.OpLoad, n.Type, addr, s.mem())
 +
 +	case OIND:
 +		p := s.expr(n.Left)
 +		s.nilCheck(p)
 +		return s.newValue2(ssa.OpLoad, n.Type, p, s.mem())
 +
 +	case ODOT:
 +		// TODO: fix when we can SSA struct types.
 +		p := s.addr(n, false)
 +		return s.newValue2(ssa.OpLoad, n.Type, p, s.mem())
 +
 +	case ODOTPTR:
 +		p := s.expr(n.Left)
 +		s.nilCheck(p)
 +		p = s.newValue2(ssa.OpAddPtr, p.Type, p, s.constInt(Types[TINT], n.Xoffset))
 +		return s.newValue2(ssa.OpLoad, n.Type, p, s.mem())
 +
 +	case OINDEX:
 +		switch {
 +		case n.Left.Type.IsString():
 +			a := s.expr(n.Left)
 +			i := s.expr(n.Right)
 +			i = s.extendIndex(i)
 +			if !n.Bounded {
 +				len := s.newValue1(ssa.OpStringLen, Types[TINT], a)
 +				s.boundsCheck(i, len)
 +			}
 +			ptrtyp := Ptrto(Types[TUINT8])
 +			ptr := s.newValue1(ssa.OpStringPtr, ptrtyp, a)
 +			ptr = s.newValue2(ssa.OpAddPtr, ptrtyp, ptr, i)
 +			return s.newValue2(ssa.OpLoad, Types[TUINT8], ptr, s.mem())
 +		case n.Left.Type.IsSlice():
 +			p := s.addr(n, false)
 +			return s.newValue2(ssa.OpLoad, n.Left.Type.Type, p, s.mem())
 +		case n.Left.Type.IsArray():
 +			// TODO: fix when we can SSA arrays of length 1.
 +			p := s.addr(n, false)
 +			return s.newValue2(ssa.OpLoad, n.Left.Type.Type, p, s.mem())
 +		default:
 +			s.Fatalf("bad type for index %v", n.Left.Type)
 +			return nil
 +		}
 +
 +	case OLEN, OCAP:
 +		switch {
 +		case n.Left.Type.IsSlice():
 +			op := ssa.OpSliceLen
 +			if n.Op == OCAP {
 +				op = ssa.OpSliceCap
 +			}
 +			return s.newValue1(op, Types[TINT], s.expr(n.Left))
 +		case n.Left.Type.IsString(): // string; not reachable for OCAP
 +			return s.newValue1(ssa.OpStringLen, Types[TINT], s.expr(n.Left))
 +		case n.Left.Type.IsMap(), n.Left.Type.IsChan():
 +			return s.referenceTypeBuiltin(n, s.expr(n.Left))
 +		default: // array
 +			return s.constInt(Types[TINT], n.Left.Type.Bound)
 +		}
 +
 +	case OSPTR:
 +		a := s.expr(n.Left)
 +		if n.Left.Type.IsSlice() {
 +			return s.newValue1(ssa.OpSlicePtr, n.Type, a)
 +		} else {
 +			return s.newValue1(ssa.OpStringPtr, n.Type, a)
 +		}
 +
 +	case OITAB:
 +		a := s.expr(n.Left)
 +		return s.newValue1(ssa.OpITab, n.Type, a)
 +
 +	case OEFACE:
 +		tab := s.expr(n.Left)
 +		data := s.expr(n.Right)
 +		// The frontend allows putting things like struct{*byte} in
 +		// the data portion of an eface.  But we don't want struct{*byte}
 +		// as a register type because (among other reasons) the liveness
 +		// analysis is confused by the "fat" variables that result from
 +		// such types being spilled.
 +		// So here we ensure that we are selecting the underlying pointer
 +		// when we build an eface.
 +		for !data.Type.IsPtr() {
 +			switch {
 +			case data.Type.IsArray():
 +				data = s.newValue2(ssa.OpArrayIndex, data.Type.Elem(), data, s.constInt(Types[TINT], 0))
 +			case data.Type.IsStruct():
 +				for i := data.Type.NumFields() - 1; i >= 0; i-- {
 +					f := data.Type.FieldType(i)
 +					if f.Size() == 0 {
 +						// eface type could also be struct{p *byte; q [0]int}
 +						continue
 +					}
 +					data = s.newValue1I(ssa.OpStructSelect, f, data.Type.FieldOff(i), data)
 +					break
 +				}
 +			default:
 +				s.Fatalf("type being put into an eface isn't a pointer")
 +			}
 +		}
 +		return s.newValue2(ssa.OpIMake, n.Type, tab, data)
 +
 +	case OSLICE, OSLICEARR:
 +		v := s.expr(n.Left)
 +		var i, j *ssa.Value
 +		if n.Right.Left != nil {
 +			i = s.extendIndex(s.expr(n.Right.Left))
 +		}
 +		if n.Right.Right != nil {
 +			j = s.extendIndex(s.expr(n.Right.Right))
 +		}
 +		p, l, c := s.slice(n.Left.Type, v, i, j, nil)
 +		return s.newValue3(ssa.OpSliceMake, n.Type, p, l, c)
 +	case OSLICESTR:
 +		v := s.expr(n.Left)
 +		var i, j *ssa.Value
 +		if n.Right.Left != nil {
 +			i = s.extendIndex(s.expr(n.Right.Left))
 +		}
 +		if n.Right.Right != nil {
 +			j = s.extendIndex(s.expr(n.Right.Right))
 +		}
 +		p, l, _ := s.slice(n.Left.Type, v, i, j, nil)
 +		return s.newValue2(ssa.OpStringMake, n.Type, p, l)
 +	case OSLICE3, OSLICE3ARR:
 +		v := s.expr(n.Left)
 +		var i *ssa.Value
 +		if n.Right.Left != nil {
 +			i = s.extendIndex(s.expr(n.Right.Left))
 +		}
 +		j := s.extendIndex(s.expr(n.Right.Right.Left))
 +		k := s.extendIndex(s.expr(n.Right.Right.Right))
 +		p, l, c := s.slice(n.Left.Type, v, i, j, k)
 +		return s.newValue3(ssa.OpSliceMake, n.Type, p, l, c)
 +
 +	case OCALLFUNC, OCALLINTER, OCALLMETH:
 +		return s.call(n, callNormal)
 +
 +	case OGETG:
 +		return s.newValue1(ssa.OpGetG, n.Type, s.mem())
 +
 +	case OAPPEND:
 +		// append(s, e1, e2, e3).  Compile like:
 +		// ptr,len,cap := s
 +		// newlen := len + 3
 +		// if newlen > s.cap {
 +		//     ptr,_,cap = growslice(s, newlen)
 +		// }
 +		// *(ptr+len) = e1
 +		// *(ptr+len+1) = e2
 +		// *(ptr+len+2) = e3
 +		// makeslice(ptr,newlen,cap)
 +
 +		et := n.Type.Type
 +		pt := Ptrto(et)
 +
 +		// Evaluate slice
 +		slice := s.expr(n.List.N)
 +
 +		// Allocate new blocks
 +		grow := s.f.NewBlock(ssa.BlockPlain)
 +		assign := s.f.NewBlock(ssa.BlockPlain)
 +
 +		// Decide if we need to grow
 +		nargs := int64(count(n.List) - 1)
 +		p := s.newValue1(ssa.OpSlicePtr, pt, slice)
 +		l := s.newValue1(ssa.OpSliceLen, Types[TINT], slice)
 +		c := s.newValue1(ssa.OpSliceCap, Types[TINT], slice)
 +		nl := s.newValue2(s.ssaOp(OADD, Types[TINT]), Types[TINT], l, s.constInt(Types[TINT], nargs))
 +		cmp := s.newValue2(s.ssaOp(OGT, Types[TINT]), Types[TBOOL], nl, c)
 +		s.vars[&ptrVar] = p
 +		s.vars[&capVar] = c
 +		b := s.endBlock()
 +		b.Kind = ssa.BlockIf
 +		b.Likely = ssa.BranchUnlikely
 +		b.Control = cmp
 +		b.AddEdgeTo(grow)
 +		b.AddEdgeTo(assign)
 +
 +		// Call growslice
 +		s.startBlock(grow)
 +		taddr := s.newValue1A(ssa.OpAddr, Types[TUINTPTR], &ssa.ExternSymbol{Types[TUINTPTR], typenamesym(n.Type)}, s.sb)
 +
 +		r := s.rtcall(growslice, true, []*Type{pt, Types[TINT], Types[TINT]}, taddr, p, l, c, nl)
 +
 +		s.vars[&ptrVar] = r[0]
 +		// Note: we don't need to read r[1], the result's length.  It will be nl.
 +		// (or maybe we should, we just have to spill/restore nl otherwise?)
 +		s.vars[&capVar] = r[2]
 +		b = s.endBlock()
 +		b.AddEdgeTo(assign)
 +
 +		// assign new elements to slots
 +		s.startBlock(assign)
 +
 +		// Evaluate args
 +		args := make([]*ssa.Value, 0, nargs)
 +		store := make([]bool, 0, nargs)
 +		for l := n.List.Next; l != nil; l = l.Next {
 +			if canSSAType(l.N.Type) {
 +				args = append(args, s.expr(l.N))
 +				store = append(store, true)
 +			} else {
 +				args = append(args, s.addr(l.N, false))
 +				store = append(store, false)
 +			}
 +		}
 +
 +		p = s.variable(&ptrVar, pt)          // generates phi for ptr
 +		c = s.variable(&capVar, Types[TINT]) // generates phi for cap
 +		p2 := s.newValue2(ssa.OpPtrIndex, pt, p, l)
 +		for i, arg := range args {
 +			addr := s.newValue2(ssa.OpPtrIndex, pt, p2, s.constInt(Types[TINT], int64(i)))
 +			if store[i] {
 +				s.vars[&memVar] = s.newValue3I(ssa.OpStore, ssa.TypeMem, et.Size(), addr, arg, s.mem())
 +			} else {
 +				s.vars[&memVar] = s.newValue3I(ssa.OpMove, ssa.TypeMem, et.Size(), addr, arg, s.mem())
 +			}
 +			if haspointers(et) {
 +				// TODO: just one write barrier call for all of these writes?
 +				// TODO: maybe just one writeBarrier.enabled check?
 +				s.insertWB(et, addr, n.Lineno)
 +			}
 +		}
 +
 +		// make result
 +		delete(s.vars, &ptrVar)
 +		delete(s.vars, &capVar)
 +		return s.newValue3(ssa.OpSliceMake, n.Type, p, nl, c)
 +
 +	default:
 +		s.Unimplementedf("unhandled expr %s", opnames[n.Op])
 +		return nil
 +	}
 +}
 +
 +// condBranch evaluates the boolean expression cond and branches to yes
 +// if cond is true and no if cond is false.
 +// This function is intended to handle && and || better than just calling
 +// s.expr(cond) and branching on the result.
 +func (s *state) condBranch(cond *Node, yes, no *ssa.Block, likely int8) {
 +	if cond.Op == OANDAND {
 +		mid := s.f.NewBlock(ssa.BlockPlain)
 +		s.stmtList(cond.Ninit)
 +		s.condBranch(cond.Left, mid, no, max8(likely, 0))
 +		s.startBlock(mid)
 +		s.condBranch(cond.Right, yes, no, likely)
 +		return
 +		// Note: if likely==1, then both recursive calls pass 1.
 +		// If likely==-1, then we don't have enough information to decide
 +		// whether the first branch is likely or not.  So we pass 0 for
 +		// the likeliness of the first branch.
 +		// TODO: have the frontend give us branch prediction hints for
 +		// OANDAND and OOROR nodes (if it ever has such info).
 +	}
 +	if cond.Op == OOROR {
 +		mid := s.f.NewBlock(ssa.BlockPlain)
 +		s.stmtList(cond.Ninit)
 +		s.condBranch(cond.Left, yes, mid, min8(likely, 0))
 +		s.startBlock(mid)
 +		s.condBranch(cond.Right, yes, no, likely)
 +		return
 +		// Note: if likely==-1, then both recursive calls pass -1.
 +		// If likely==1, then we don't have enough info to decide
 +		// the likelihood of the first branch.
 +	}
 +	if cond.Op == ONOT {
 +		s.stmtList(cond.Ninit)
 +		s.condBranch(cond.Left, no, yes, -likely)
 +		return
 +	}
 +	c := s.expr(cond)
 +	b := s.endBlock()
 +	b.Kind = ssa.BlockIf
 +	b.Control = c
 +	b.Likely = ssa.BranchPrediction(likely) // gc and ssa both use -1/0/+1 for likeliness
 +	b.AddEdgeTo(yes)
 +	b.AddEdgeTo(no)
 +}
 +
 +func (s *state) assign(left *Node, right *ssa.Value, wb bool, line int32) {
 +	if left.Op == ONAME && isblank(left) {
 +		return
 +	}
 +	t := left.Type
 +	dowidth(t)
 +	if right == nil {
 +		// right == nil means use the zero value of the assigned type.
 +		if !canSSA(left) {
 +			// if we can't ssa this memory, treat it as just zeroing out the backing memory
 +			addr := s.addr(left, false)
 +			if left.Op == ONAME {
 +				s.vars[&memVar] = s.newValue1A(ssa.OpVarDef, ssa.TypeMem, left, s.mem())
 +			}
 +			s.vars[&memVar] = s.newValue2I(ssa.OpZero, ssa.TypeMem, t.Size(), addr, s.mem())
 +			return
 +		}
 +		right = s.zeroVal(t)
 +	}
 +	if left.Op == ONAME && canSSA(left) {
 +		// Update variable assignment.
 +		s.vars[left] = right
 +		s.addNamedValue(left, right)
 +		return
 +	}
 +	// not ssa-able.  Treat as a store.
 +	addr := s.addr(left, false)
 +	if left.Op == ONAME {
 +		s.vars[&memVar] = s.newValue1A(ssa.OpVarDef, ssa.TypeMem, left, s.mem())
 +	}
 +	s.vars[&memVar] = s.newValue3I(ssa.OpStore, ssa.TypeMem, t.Size(), addr, right, s.mem())
 +	if wb {
 +		s.insertWB(left.Type, addr, line)
 +	}
 +}
 +
 +// zeroVal returns the zero value for type t.
 +func (s *state) zeroVal(t *Type) *ssa.Value {
 +	switch {
 +	case t.IsInteger():
 +		switch t.Size() {
 +		case 1:
 +			return s.constInt8(t, 0)
 +		case 2:
 +			return s.constInt16(t, 0)
 +		case 4:
 +			return s.constInt32(t, 0)
 +		case 8:
 +			return s.constInt64(t, 0)
 +		default:
 +			s.Fatalf("bad sized integer type %s", t)
 +		}
 +	case t.IsFloat():
 +		switch t.Size() {
 +		case 4:
 +			return s.constFloat32(t, 0)
 +		case 8:
 +			return s.constFloat64(t, 0)
 +		default:
 +			s.Fatalf("bad sized float type %s", t)
 +		}
 +	case t.IsComplex():
 +		switch t.Size() {
 +		case 8:
 +			z := s.constFloat32(Types[TFLOAT32], 0)
 +			return s.entryNewValue2(ssa.OpComplexMake, t, z, z)
 +		case 16:
 +			z := s.constFloat64(Types[TFLOAT64], 0)
 +			return s.entryNewValue2(ssa.OpComplexMake, t, z, z)
 +		default:
 +			s.Fatalf("bad sized complex type %s", t)
 +		}
 +
 +	case t.IsString():
 +		return s.entryNewValue0A(ssa.OpConstString, t, "")
 +	case t.IsPtr():
 +		return s.entryNewValue0(ssa.OpConstNil, t)
 +	case t.IsBoolean():
 +		return s.constBool(false)
 +	case t.IsInterface():
 +		return s.entryNewValue0(ssa.OpConstInterface, t)
 +	case t.IsSlice():
 +		return s.entryNewValue0(ssa.OpConstSlice, t)
 +	}
 +	s.Unimplementedf("zero for type %v not implemented", t)
 +	return nil
 +}
 +
 +type callKind int8
 +
 +const (
 +	callNormal callKind = iota
 +	callDefer
 +	callGo
 +)
 +
 +func (s *state) call(n *Node, k callKind) *ssa.Value {
 +	var sym *Sym           // target symbol (if static)
 +	var closure *ssa.Value // ptr to closure to run (if dynamic)
 +	var codeptr *ssa.Value // ptr to target code (if dynamic)
 +	var rcvr *ssa.Value    // receiver to set
 +	fn := n.Left
 +	switch n.Op {
 +	case OCALLFUNC:
 +		if k == callNormal && fn.Op == ONAME && fn.Class == PFUNC {
 +			sym = fn.Sym
 +			break
 +		}
 +		closure = s.expr(fn)
 +		if closure == nil {
 +			return nil // TODO: remove when expr always returns non-nil
 +		}
 +	case OCALLMETH:
 +		if fn.Op != ODOTMETH {
 +			Fatalf("OCALLMETH: n.Left not an ODOTMETH: %v", fn)
 +		}
 +		if fn.Right.Op != ONAME {
 +			Fatalf("OCALLMETH: n.Left.Right not a ONAME: %v", fn.Right)
 +		}
 +		if k == callNormal {
 +			sym = fn.Right.Sym
 +			break
 +		}
 +		n2 := *fn.Right
 +		n2.Class = PFUNC
 +		closure = s.expr(&n2)
 +		// Note: receiver is already assigned in n.List, so we don't
 +		// want to set it here.
 +	case OCALLINTER:
 +		if fn.Op != ODOTINTER {
 +			Fatalf("OCALLINTER: n.Left not an ODOTINTER: %v", Oconv(int(fn.Op), 0))
 +		}
 +		i := s.expr(fn.Left)
 +		itab := s.newValue1(ssa.OpITab, Types[TUINTPTR], i)
 +		itabidx := fn.Xoffset + 3*int64(Widthptr) + 8 // offset of fun field in runtime.itab
 +		itab = s.newValue1I(ssa.OpOffPtr, Types[TUINTPTR], itabidx, itab)
 +		if k == callNormal {
 +			codeptr = s.newValue2(ssa.OpLoad, Types[TUINTPTR], itab, s.mem())
 +		} else {
 +			closure = itab
 +		}
 +		rcvr = s.newValue1(ssa.OpIData, Types[TUINTPTR], i)
 +	}
 +	dowidth(fn.Type)
 +	stksize := fn.Type.Argwid // includes receiver
 +
 +	// Run all argument assignments.  The arg slots have already
 +	// been offset by the appropriate amount (+2*widthptr for go/defer,
 +	// +widthptr for interface calls).
 +	// For OCALLMETH, the receiver is set in these statements.
 +	s.stmtList(n.List)
 +
 +	// Set receiver (for interface calls)
 +	if rcvr != nil {
 +		argStart := Ctxt.FixedFrameSize()
 +		if k != callNormal {
 +			argStart += int64(2 * Widthptr)
 +		}
 +		addr := s.entryNewValue1I(ssa.OpOffPtr, Types[TUINTPTR], argStart, s.sp)
 +		s.vars[&memVar] = s.newValue3I(ssa.OpStore, ssa.TypeMem, int64(Widthptr), addr, rcvr, s.mem())
 +	}
 +
 +	// Defer/go args
 +	if k != callNormal {
 +		// Write argsize and closure (args to Newproc/Deferproc).
 +		argsize := s.constInt32(Types[TUINT32], int32(stksize))
 +		s.vars[&memVar] = s.newValue3I(ssa.OpStore, ssa.TypeMem, 4, s.sp, argsize, s.mem())
 +		addr := s.entryNewValue1I(ssa.OpOffPtr, Ptrto(Types[TUINTPTR]), int64(Widthptr), s.sp)
 +		s.vars[&memVar] = s.newValue3I(ssa.OpStore, ssa.TypeMem, int64(Widthptr), addr, closure, s.mem())
 +		stksize += 2 * int64(Widthptr)
 +	}
 +
 +	// call target
 +	bNext := s.f.NewBlock(ssa.BlockPlain)
 +	var call *ssa.Value
 +	switch {
 +	case k == callDefer:
 +		call = s.newValue1(ssa.OpDeferCall, ssa.TypeMem, s.mem())
 +	case k == callGo:
 +		call = s.newValue1(ssa.OpGoCall, ssa.TypeMem, s.mem())
 +	case closure != nil:
 +		codeptr = s.newValue2(ssa.OpLoad, Types[TUINTPTR], closure, s.mem())
 +		call = s.newValue3(ssa.OpClosureCall, ssa.TypeMem, codeptr, closure, s.mem())
 +	case codeptr != nil:
 +		call = s.newValue2(ssa.OpInterCall, ssa.TypeMem, codeptr, s.mem())
 +	case sym != nil:
 +		call = s.newValue1A(ssa.OpStaticCall, ssa.TypeMem, sym, s.mem())
 +	default:
 +		Fatalf("bad call type %s %v", opnames[n.Op], n)
 +	}
 +	call.AuxInt = stksize // Call operations carry the argsize of the callee along with them
 +
 +	// Finish call block
 +	s.vars[&memVar] = call
 +	b := s.endBlock()
 +	b.Kind = ssa.BlockCall
 +	b.Control = call
 +	b.AddEdgeTo(bNext)
 +
 +	// Read result from stack at the start of the fallthrough block
 +	s.startBlock(bNext)
 +	var titer Iter
 +	fp := Structfirst(&titer, Getoutarg(n.Left.Type))
 +	if fp == nil || k != callNormal {
 +		// call has no return value. Continue with the next statement.
 +		return nil
 +	}
 +	a := s.entryNewValue1I(ssa.OpOffPtr, Ptrto(fp.Type), fp.Width, s.sp)
 +	return s.newValue2(ssa.OpLoad, fp.Type, a, call)
 +}
 +
 +// etypesign returns the signed-ness of e, for integer/pointer etypes.
 +// -1 means signed, +1 means unsigned, 0 means non-integer/non-pointer.
 +func etypesign(e EType) int8 {
 +	switch e {
 +	case TINT8, TINT16, TINT32, TINT64, TINT:
 +		return -1
 +	case TUINT8, TUINT16, TUINT32, TUINT64, TUINT, TUINTPTR, TUNSAFEPTR:
 +		return +1
 +	}
 +	return 0
 +}
 +
 +// lookupSymbol is used to retrieve the symbol (Extern, Arg or Auto) used for a particular node.
 +// This improves the effectiveness of cse by using the same Aux values for the
 +// same symbols.
 +func (s *state) lookupSymbol(n *Node, sym interface{}) interface{} {
 +	switch sym.(type) {
 +	default:
 +		s.Fatalf("sym %v is of uknown type %T", sym, sym)
 +	case *ssa.ExternSymbol, *ssa.ArgSymbol, *ssa.AutoSymbol:
 +		// these are the only valid types
 +	}
 +
 +	if lsym, ok := s.varsyms[n]; ok {
 +		return lsym
 +	} else {
 +		s.varsyms[n] = sym
 +		return sym
 +	}
 +}
 +
 +// addr converts the address of the expression n to SSA, adds it to s and returns the SSA result.
 +// The value that the returned Value represents is guaranteed to be non-nil.
 +// If bounded is true then this address does not require a nil check for its operand
 +// even if that would otherwise be implied.
 +func (s *state) addr(n *Node, bounded bool) *ssa.Value {
 +	t := Ptrto(n.Type)
 +	switch n.Op {
 +	case ONAME:
 +		switch n.Class {
 +		case PEXTERN:
 +			// global variable
 +			aux := s.lookupSymbol(n, &ssa.ExternSymbol{n.Type, n.Sym})
 +			v := s.entryNewValue1A(ssa.OpAddr, t, aux, s.sb)
 +			// TODO: Make OpAddr use AuxInt as well as Aux.
 +			if n.Xoffset != 0 {
 +				v = s.entryNewValue1I(ssa.OpOffPtr, v.Type, n.Xoffset, v)
 +			}
 +			return v
 +		case PPARAM:
 +			// parameter slot
 +			v := s.decladdrs[n]
 +			if v != nil {
 +				return v
 +			}
 +			if n.String() == ".fp" {
 +				// Special arg that points to the frame pointer.
 +				// (Used by the race detector, others?)
 +				aux := s.lookupSymbol(n, &ssa.ArgSymbol{Typ: n.Type, Node: n})
 +				return s.entryNewValue1A(ssa.OpAddr, t, aux, s.sp)
 +			}
 +			s.Fatalf("addr of undeclared ONAME %v. declared: %v", n, s.decladdrs)
 +			return nil
 +		case PAUTO:
 +			// We need to regenerate the address of autos
 +			// at every use.  This prevents LEA instructions
 +			// from occurring before the corresponding VarDef
 +			// op and confusing the liveness analysis into thinking
 +			// the variable is live at function entry.
 +			// TODO: I'm not sure if this really works or we're just
 +			// getting lucky.  We might need a real dependency edge
 +			// between vardef and addr ops.
 +			aux := &ssa.AutoSymbol{Typ: n.Type, Node: n}
 +			return s.newValue1A(ssa.OpAddr, t, aux, s.sp)
 +		case PPARAMOUT: // Same as PAUTO -- cannot generate LEA early.
 +			// ensure that we reuse symbols for out parameters so
 +			// that cse works on their addresses
 +			aux := s.lookupSymbol(n, &ssa.ArgSymbol{Typ: n.Type, Node: n})
 +			return s.newValue1A(ssa.OpAddr, t, aux, s.sp)
 +		case PAUTO | PHEAP, PPARAM | PHEAP, PPARAMOUT | PHEAP, PPARAMREF:
 +			return s.expr(n.Name.Heapaddr)
 +		default:
 +			s.Unimplementedf("variable address class %v not implemented", n.Class)
 +			return nil
 +		}
 +	case OINDREG:
 +		// indirect off a register
 +		// used for storing/loading arguments/returns to/from callees
 +		if int(n.Reg) != Thearch.REGSP {
 +			s.Unimplementedf("OINDREG of non-SP register %s in addr: %v", obj.Rconv(int(n.Reg)), n)
 +			return nil
 +		}
 +		return s.entryNewValue1I(ssa.OpOffPtr, t, n.Xoffset, s.sp)
 +	case OINDEX:
 +		if n.Left.Type.IsSlice() {
 +			a := s.expr(n.Left)
 +			i := s.expr(n.Right)
 +			i = s.extendIndex(i)
 +			len := s.newValue1(ssa.OpSliceLen, Types[TINT], a)
 +			if !n.Bounded {
 +				s.boundsCheck(i, len)
 +			}
 +			p := s.newValue1(ssa.OpSlicePtr, t, a)
 +			return s.newValue2(ssa.OpPtrIndex, t, p, i)
 +		} else { // array
 +			a := s.addr(n.Left, bounded)
 +			i := s.expr(n.Right)
 +			i = s.extendIndex(i)
 +			len := s.constInt(Types[TINT], n.Left.Type.Bound)
 +			if !n.Bounded {
 +				s.boundsCheck(i, len)
 +			}
 +			return s.newValue2(ssa.OpPtrIndex, Ptrto(n.Left.Type.Type), a, i)
 +		}
 +	case OIND:
 +		p := s.expr(n.Left)
 +		if !bounded {
 +			s.nilCheck(p)
 +		}
 +		return p
 +	case ODOT:
 +		p := s.addr(n.Left, bounded)
 +		return s.newValue2(ssa.OpAddPtr, t, p, s.constInt(Types[TINT], n.Xoffset))
 +	case ODOTPTR:
 +		p := s.expr(n.Left)
 +		if !bounded {
 +			s.nilCheck(p)
 +		}
 +		return s.newValue2(ssa.OpAddPtr, t, p, s.constInt(Types[TINT], n.Xoffset))
 +	case OCLOSUREVAR:
 +		return s.newValue2(ssa.OpAddPtr, t,
 +			s.entryNewValue0(ssa.OpGetClosurePtr, Ptrto(Types[TUINT8])),
 +			s.constInt(Types[TINT], n.Xoffset))
 +	case OPARAM:
 +		p := n.Left
 +		if p.Op != ONAME || !(p.Class == PPARAM|PHEAP || p.Class == PPARAMOUT|PHEAP) {
 +			s.Fatalf("OPARAM not of ONAME,{PPARAM,PPARAMOUT}|PHEAP, instead %s", nodedump(p, 0))
 +		}
 +
 +		// Recover original offset to address passed-in param value.
 +		original_p := *p
 +		original_p.Xoffset = n.Xoffset
 +		aux := &ssa.ArgSymbol{Typ: n.Type, Node: &original_p}
 +		return s.entryNewValue1A(ssa.OpAddr, t, aux, s.sp)
 +	case OCONVNOP:
 +		addr := s.addr(n.Left, bounded)
 +		return s.newValue1(ssa.OpCopy, t, addr) // ensure that addr has the right type
 +
 +	default:
 +		s.Unimplementedf("unhandled addr %v", Oconv(int(n.Op), 0))
 +		return nil
 +	}
 +}
 +
 +// canSSA reports whether n is SSA-able.
 +// n must be an ONAME.
 +func canSSA(n *Node) bool {
 +	if n.Op != ONAME {
 +		return false
 +	}
 +	if n.Addrtaken {
 +		return false
 +	}
 +	if n.Class&PHEAP != 0 {
 +		return false
 +	}
 +	switch n.Class {
 +	case PEXTERN, PPARAMOUT, PPARAMREF:
 +		return false
 +	}
 +	if n.Class == PPARAM && n.String() == ".this" {
 +		// wrappers generated by genwrapper need to update
 +		// the .this pointer in place.
 +		return false
 +	}
 +	return canSSAType(n.Type)
 +	// TODO: try to make more variables SSAable?
 +}
 +
 +// canSSA reports whether variables of type t are SSA-able.
 +func canSSAType(t *Type) bool {
 +	dowidth(t)
 +	if t.Width > int64(4*Widthptr) {
 +		// 4*Widthptr is an arbitrary constant.  We want it
 +		// to be at least 3*Widthptr so slices can be registerized.
 +		// Too big and we'll introduce too much register pressure.
 +		return false
 +	}
 +	switch t.Etype {
 +	case TARRAY:
 +		if Isslice(t) {
 +			return true
 +		}
 +		// We can't do arrays because dynamic indexing is
 +		// not supported on SSA variables.
 +		// TODO: maybe allow if length is <=1?  All indexes
 +		// are constant?  Might be good for the arrays
 +		// introduced by the compiler for variadic functions.
 +		return false
 +	case TSTRUCT:
 +		if countfield(t) > 4 {
 +			// 4 is an arbitrary constant.  Same reasoning
 +			// as above, lots of small fields would waste
 +			// register space needed by other values.
 +			return false
 +		}
 +		for t1 := t.Type; t1 != nil; t1 = t1.Down {
 +			if !canSSAType(t1.Type) {
 +				return false
 +			}
 +		}
 +		return false // until it is implemented
 +		//return true
 +	default:
 +		return true
 +	}
 +}
 +
 +// nilCheck generates nil pointer checking code.
 +// Starts a new block on return, unless nil checks are disabled.
 +// Used only for automatically inserted nil checks,
 +// not for user code like 'x != nil'.
 +func (s *state) nilCheck(ptr *ssa.Value) {
 +	if Disable_checknil != 0 {
 +		return
 +	}
 +	chk := s.newValue2(ssa.OpNilCheck, ssa.TypeVoid, ptr, s.mem())
 +	b := s.endBlock()
 +	b.Kind = ssa.BlockCheck
 +	b.Control = chk
 +	bNext := s.f.NewBlock(ssa.BlockPlain)
 +	b.AddEdgeTo(bNext)
 +	s.startBlock(bNext)
 +}
 +
 +// boundsCheck generates bounds checking code.  Checks if 0 <= idx < len, branches to exit if not.
 +// Starts a new block on return.
 +func (s *state) boundsCheck(idx, len *ssa.Value) {
 +	if Debug['B'] != 0 {
 +		return
 +	}
 +	// TODO: convert index to full width?
 +	// TODO: if index is 64-bit and we're compiling to 32-bit, check that high 32 bits are zero.
 +
 +	// bounds check
 +	cmp := s.newValue2(ssa.OpIsInBounds, Types[TBOOL], idx, len)
 +	s.check(cmp, Panicindex)
 +}
 +
 +// sliceBoundsCheck generates slice bounds checking code.  Checks if 0 <= idx <= len, branches to exit if not.
 +// Starts a new block on return.
 +func (s *state) sliceBoundsCheck(idx, len *ssa.Value) {
 +	if Debug['B'] != 0 {
 +		return
 +	}
 +	// TODO: convert index to full width?
 +	// TODO: if index is 64-bit and we're compiling to 32-bit, check that high 32 bits are zero.
 +
 +	// bounds check
 +	cmp := s.newValue2(ssa.OpIsSliceInBounds, Types[TBOOL], idx, len)
 +	s.check(cmp, panicslice)
 +}
 +
 +// If cmp (a bool) is true, panic using the given function.
 +func (s *state) check(cmp *ssa.Value, fn *Node) {
 +	b := s.endBlock()
 +	b.Kind = ssa.BlockIf
 +	b.Control = cmp
 +	b.Likely = ssa.BranchLikely
 +	bNext := s.f.NewBlock(ssa.BlockPlain)
 +	line := s.peekLine()
 +	bPanic := s.panics[funcLine{fn, line}]
 +	if bPanic == nil {
 +		bPanic = s.f.NewBlock(ssa.BlockPlain)
 +		s.panics[funcLine{fn, line}] = bPanic
 +		s.startBlock(bPanic)
 +		// The panic call takes/returns memory to ensure that the right
 +		// memory state is observed if the panic happens.
 +		s.rtcall(fn, false, nil)
 +	}
 +	b.AddEdgeTo(bNext)
 +	b.AddEdgeTo(bPanic)
 +	s.startBlock(bNext)
 +}
 +
 +// rtcall issues a call to the given runtime function fn with the listed args.
 +// Returns a slice of results of the given result types.
 +// The call is added to the end of the current block.
 +// If returns is false, the block is marked as an exit block.
 +// If returns is true, the block is marked as a call block.  A new block
 +// is started to load the return values.
 +func (s *state) rtcall(fn *Node, returns bool, results []*Type, args ...*ssa.Value) []*ssa.Value {
 +	// Write args to the stack
 +	var off int64 // TODO: arch-dependent starting offset?
 +	for _, arg := range args {
 +		t := arg.Type
 +		off = Rnd(off, t.Alignment())
 +		ptr := s.sp
 +		if off != 0 {
 +			ptr = s.newValue1I(ssa.OpOffPtr, Types[TUINTPTR], off, s.sp)
 +		}
 +		size := t.Size()
 +		s.vars[&memVar] = s.newValue3I(ssa.OpStore, ssa.TypeMem, size, ptr, arg, s.mem())
 +		off += size
 +	}
 +	off = Rnd(off, int64(Widthptr))
 +
 +	// Issue call
 +	call := s.newValue1A(ssa.OpStaticCall, ssa.TypeMem, fn.Sym, s.mem())
 +	s.vars[&memVar] = call
 +
 +	// Finish block
 +	b := s.endBlock()
 +	if !returns {
 +		b.Kind = ssa.BlockExit
 +		b.Control = call
 +		call.AuxInt = off
 +		if len(results) > 0 {
 +			Fatalf("panic call can't have results")
 +		}
 +		return nil
 +	}
 +	b.Kind = ssa.BlockCall
 +	b.Control = call
 +	bNext := s.f.NewBlock(ssa.BlockPlain)
 +	b.AddEdgeTo(bNext)
 +	s.startBlock(bNext)
 +
 +	// Load results
 +	res := make([]*ssa.Value, len(results))
 +	for i, t := range results {
 +		off = Rnd(off, t.Alignment())
 +		ptr := s.sp
 +		if off != 0 {
 +			ptr = s.newValue1I(ssa.OpOffPtr, Types[TUINTPTR], off, s.sp)
 +		}
 +		res[i] = s.newValue2(ssa.OpLoad, t, ptr, s.mem())
 +		off += t.Size()
 +	}
 +	off = Rnd(off, int64(Widthptr))
 +
 +	// Remember how much callee stack space we needed.
 +	call.AuxInt = off
 +
 +	return res
 +}
 +
 +// insertWB inserts a write barrier.  A value of type t has already
 +// been stored at location p.  Tell the runtime about this write.
 +// Note: there must be no GC suspension points between the write and
 +// the call that this function inserts.
 +func (s *state) insertWB(t *Type, p *ssa.Value, line int32) {
 +	// if writeBarrier.enabled {
 +	//   typedmemmove_nostore(&t, p)
 +	// }
 +	bThen := s.f.NewBlock(ssa.BlockPlain)
 +
 +	aux := &ssa.ExternSymbol{Types[TBOOL], syslook("writeBarrier", 0).Sym}
 +	flagaddr := s.newValue1A(ssa.OpAddr, Ptrto(Types[TBOOL]), aux, s.sb)
 +	// TODO: select the .enabled field.  It is currently first, so not needed for now.
 +	flag := s.newValue2(ssa.OpLoad, Types[TBOOL], flagaddr, s.mem())
 +	b := s.endBlock()
 +	b.Kind = ssa.BlockIf
 +	b.Likely = ssa.BranchUnlikely
 +	b.Control = flag
 +	b.AddEdgeTo(bThen)
 +
 +	s.startBlock(bThen)
 +	// TODO: writebarrierptr_nostore if just one pointer word (or a few?)
 +	taddr := s.newValue1A(ssa.OpAddr, Types[TUINTPTR], &ssa.ExternSymbol{Types[TUINTPTR], typenamesym(t)}, s.sb)
 +	s.rtcall(typedmemmove_nostore, true, nil, taddr, p)
 +
 +	if Debug_wb > 0 {
 +		Warnl(int(line), "write barrier")
 +	}
 +
 +	b.AddEdgeTo(s.curBlock)
 +}
 +
 +// slice computes the slice v[i:j:k] and returns ptr, len, and cap of result.
 +// i,j,k may be nil, in which case they are set to their default value.
 +// t is a slice, ptr to array, or string type.
 +func (s *state) slice(t *Type, v, i, j, k *ssa.Value) (p, l, c *ssa.Value) {
 +	var elemtype *Type
 +	var ptrtype *Type
 +	var ptr *ssa.Value
 +	var len *ssa.Value
 +	var cap *ssa.Value
 +	zero := s.constInt(Types[TINT], 0)
 +	switch {
 +	case t.IsSlice():
 +		elemtype = t.Type
 +		ptrtype = Ptrto(elemtype)
 +		ptr = s.newValue1(ssa.OpSlicePtr, ptrtype, v)
 +		len = s.newValue1(ssa.OpSliceLen, Types[TINT], v)
 +		cap = s.newValue1(ssa.OpSliceCap, Types[TINT], v)
 +	case t.IsString():
 +		elemtype = Types[TUINT8]
 +		ptrtype = Ptrto(elemtype)
 +		ptr = s.newValue1(ssa.OpStringPtr, ptrtype, v)
 +		len = s.newValue1(ssa.OpStringLen, Types[TINT], v)
 +		cap = len
 +	case t.IsPtr():
 +		if !t.Type.IsArray() {
 +			s.Fatalf("bad ptr to array in slice %v\n", t)
 +		}
 +		elemtype = t.Type.Type
 +		ptrtype = Ptrto(elemtype)
 +		s.nilCheck(v)
 +		ptr = v
 +		len = s.constInt(Types[TINT], t.Type.Bound)
 +		cap = len
 +	default:
 +		s.Fatalf("bad type in slice %v\n", t)
 +	}
 +
 +	// Set default values
 +	if i == nil {
 +		i = zero
 +	}
 +	if j == nil {
 +		j = len
 +	}
 +	if k == nil {
 +		k = cap
 +	}
 +
 +	// Panic if slice indices are not in bounds.
 +	s.sliceBoundsCheck(i, j)
 +	if j != k {
 +		s.sliceBoundsCheck(j, k)
 +	}
 +	if k != cap {
 +		s.sliceBoundsCheck(k, cap)
 +	}
 +
 +	// Generate the following code assuming that indexes are in bounds.
 +	// The conditional is to make sure that we don't generate a slice
 +	// that points to the next object in memory.
 +	// rlen = (Sub64 j i)
 +	// rcap = (Sub64 k i)
 +	// p = ptr
 +	// if rcap != 0 {
 +	//    p = (AddPtr ptr (Mul64 low (Const64 size)))
 +	// }
 +	// result = (SliceMake p size)
 +	subOp := s.ssaOp(OSUB, Types[TINT])
 +	neqOp := s.ssaOp(ONE, Types[TINT])
 +	mulOp := s.ssaOp(OMUL, Types[TINT])
 +	rlen := s.newValue2(subOp, Types[TINT], j, i)
 +	var rcap *ssa.Value
 +	switch {
 +	case t.IsString():
 +		// Capacity of the result is unimportant.  However, we use
 +		// rcap to test if we've generated a zero-length slice.
 +		// Use length of strings for that.
 +		rcap = rlen
 +	case j == k:
 +		rcap = rlen
 +	default:
 +		rcap = s.newValue2(subOp, Types[TINT], k, i)
 +	}
 +
 +	s.vars[&ptrVar] = ptr
 +
 +	// Generate code to test the resulting slice length.
 +	cmp := s.newValue2(neqOp, Types[TBOOL], rcap, s.constInt(Types[TINT], 0))
 +
 +	b := s.endBlock()
 +	b.Kind = ssa.BlockIf
 +	b.Likely = ssa.BranchLikely
 +	b.Control = cmp
 +
 +	// Generate code for non-zero length slice case.
 +	nz := s.f.NewBlock(ssa.BlockPlain)
 +	b.AddEdgeTo(nz)
 +	s.startBlock(nz)
 +	var inc *ssa.Value
 +	if elemtype.Width == 1 {
 +		inc = i
 +	} else {
 +		inc = s.newValue2(mulOp, Types[TINT], i, s.constInt(Types[TINT], elemtype.Width))
 +	}
 +	s.vars[&ptrVar] = s.newValue2(ssa.OpAddPtr, ptrtype, ptr, inc)
 +	s.endBlock()
 +
 +	// All done.
 +	merge := s.f.NewBlock(ssa.BlockPlain)
 +	b.AddEdgeTo(merge)
 +	nz.AddEdgeTo(merge)
 +	s.startBlock(merge)
 +	rptr := s.variable(&ptrVar, ptrtype)
 +	delete(s.vars, &ptrVar)
 +	return rptr, rlen, rcap
 +}
 +
 +type u2fcvtTab struct {
 +	geq, cvt2F, and, rsh, or, add ssa.Op
 +	one                           func(*state, ssa.Type, int64) *ssa.Value
 +}
 +
 +var u64_f64 u2fcvtTab = u2fcvtTab{
 +	geq:   ssa.OpGeq64,
 +	cvt2F: ssa.OpCvt64to64F,
 +	and:   ssa.OpAnd64,
 +	rsh:   ssa.OpRsh64Ux64,
 +	or:    ssa.OpOr64,
 +	add:   ssa.OpAdd64F,
 +	one:   (*state).constInt64,
 +}
 +
 +var u64_f32 u2fcvtTab = u2fcvtTab{
 +	geq:   ssa.OpGeq64,
 +	cvt2F: ssa.OpCvt64to32F,
 +	and:   ssa.OpAnd64,
 +	rsh:   ssa.OpRsh64Ux64,
 +	or:    ssa.OpOr64,
 +	add:   ssa.OpAdd32F,
 +	one:   (*state).constInt64,
 +}
 +
 +// Excess generality on a machine with 64-bit integer registers.
 +// Not used on AMD64.
 +var u32_f32 u2fcvtTab = u2fcvtTab{
 +	geq:   ssa.OpGeq32,
 +	cvt2F: ssa.OpCvt32to32F,
 +	and:   ssa.OpAnd32,
 +	rsh:   ssa.OpRsh32Ux32,
 +	or:    ssa.OpOr32,
 +	add:   ssa.OpAdd32F,
 +	one: func(s *state, t ssa.Type, x int64) *ssa.Value {
 +		return s.constInt32(t, int32(x))
 +	},
 +}
 +
 +func (s *state) uint64Tofloat64(n *Node, x *ssa.Value, ft, tt *Type) *ssa.Value {
 +	return s.uintTofloat(&u64_f64, n, x, ft, tt)
 +}
 +
 +func (s *state) uint64Tofloat32(n *Node, x *ssa.Value, ft, tt *Type) *ssa.Value {
 +	return s.uintTofloat(&u64_f32, n, x, ft, tt)
 +}
 +
 +func (s *state) uintTofloat(cvttab *u2fcvtTab, n *Node, x *ssa.Value, ft, tt *Type) *ssa.Value {
 +	// if x >= 0 {
 +	//    result = (floatY) x
 +	// } else {
 +	// 	  y = uintX(x) ; y = x & 1
 +	// 	  z = uintX(x) ; z = z >> 1
 +	// 	  z = z >> 1
 +	// 	  z = z | y
 +	// 	  result = floatY(z)
 +	// 	  result = result + result
 +	// }
 +	//
 +	// Code borrowed from old code generator.
 +	// What's going on: large 64-bit "unsigned" looks like
 +	// negative number to hardware's integer-to-float
 +	// conversion.  However, because the mantissa is only
 +	// 63 bits, we don't need the LSB, so instead we do an
 +	// unsigned right shift (divide by two), convert, and
 +	// double.  However, before we do that, we need to be
 +	// sure that we do not lose a "1" if that made the
 +	// difference in the resulting rounding.  Therefore, we
 +	// preserve it, and OR (not ADD) it back in.  The case
 +	// that matters is when the eleven discarded bits are
 +	// equal to 10000000001; that rounds up, and the 1 cannot
 +	// be lost else it would round down if the LSB of the
 +	// candidate mantissa is 0.
 +	cmp := s.newValue2(cvttab.geq, Types[TBOOL], x, s.zeroVal(ft))
 +	b := s.endBlock()
 +	b.Kind = ssa.BlockIf
 +	b.Control = cmp
 +	b.Likely = ssa.BranchLikely
 +
 +	bThen := s.f.NewBlock(ssa.BlockPlain)
 +	bElse := s.f.NewBlock(ssa.BlockPlain)
 +	bAfter := s.f.NewBlock(ssa.BlockPlain)
 +
 +	b.AddEdgeTo(bThen)
 +	s.startBlock(bThen)
 +	a0 := s.newValue1(cvttab.cvt2F, tt, x)
 +	s.vars[n] = a0
 +	s.endBlock()
 +	bThen.AddEdgeTo(bAfter)
 +
 +	b.AddEdgeTo(bElse)
 +	s.startBlock(bElse)
 +	one := cvttab.one(s, ft, 1)
 +	y := s.newValue2(cvttab.and, ft, x, one)
 +	z := s.newValue2(cvttab.rsh, ft, x, one)
 +	z = s.newValue2(cvttab.or, ft, z, y)
 +	a := s.newValue1(cvttab.cvt2F, tt, z)
 +	a1 := s.newValue2(cvttab.add, tt, a, a)
 +	s.vars[n] = a1
 +	s.endBlock()
 +	bElse.AddEdgeTo(bAfter)
 +
 +	s.startBlock(bAfter)
 +	return s.variable(n, n.Type)
 +}
 +
 +// referenceTypeBuiltin generates code for the len/cap builtins for maps and channels.
 +func (s *state) referenceTypeBuiltin(n *Node, x *ssa.Value) *ssa.Value {
 +	if !n.Left.Type.IsMap() && !n.Left.Type.IsChan() {
 +		s.Fatalf("node must be a map or a channel")
 +	}
 +	// if n == nil {
 +	//   return 0
 +	// } else {
 +	//   // len
 +	//   return *((*int)n)
 +	//   // cap
 +	//   return *(((*int)n)+1)
 +	// }
 +	lenType := n.Type
 +	nilValue := s.newValue0(ssa.OpConstNil, Types[TUINTPTR])
 +	cmp := s.newValue2(ssa.OpEqPtr, Types[TBOOL], x, nilValue)
 +	b := s.endBlock()
 +	b.Kind = ssa.BlockIf
 +	b.Control = cmp
 +	b.Likely = ssa.BranchUnlikely
 +
 +	bThen := s.f.NewBlock(ssa.BlockPlain)
 +	bElse := s.f.NewBlock(ssa.BlockPlain)
 +	bAfter := s.f.NewBlock(ssa.BlockPlain)
 +
 +	// length/capacity of a nil map/chan is zero
 +	b.AddEdgeTo(bThen)
 +	s.startBlock(bThen)
 +	s.vars[n] = s.zeroVal(lenType)
 +	s.endBlock()
 +	bThen.AddEdgeTo(bAfter)
 +
 +	b.AddEdgeTo(bElse)
 +	s.startBlock(bElse)
 +	if n.Op == OLEN {
 +		// length is stored in the first word for map/chan
 +		s.vars[n] = s.newValue2(ssa.OpLoad, lenType, x, s.mem())
 +	} else if n.Op == OCAP {
 +		// capacity is stored in the second word for chan
 +		sw := s.newValue1I(ssa.OpOffPtr, lenType.PtrTo(), lenType.Width, x)
 +		s.vars[n] = s.newValue2(ssa.OpLoad, lenType, sw, s.mem())
 +	} else {
 +		s.Fatalf("op must be OLEN or OCAP")
 +	}
 +	s.endBlock()
 +	bElse.AddEdgeTo(bAfter)
 +
 +	s.startBlock(bAfter)
 +	return s.variable(n, lenType)
 +}
 +
 +type f2uCvtTab struct {
 +	ltf, cvt2U, subf ssa.Op
 +	value            func(*state, ssa.Type, float64) *ssa.Value
 +}
 +
 +var f32_u64 f2uCvtTab = f2uCvtTab{
 +	ltf:   ssa.OpLess32F,
 +	cvt2U: ssa.OpCvt32Fto64,
 +	subf:  ssa.OpSub32F,
 +	value: (*state).constFloat32,
 +}
 +
 +var f64_u64 f2uCvtTab = f2uCvtTab{
 +	ltf:   ssa.OpLess64F,
 +	cvt2U: ssa.OpCvt64Fto64,
 +	subf:  ssa.OpSub64F,
 +	value: (*state).constFloat64,
 +}
 +
 +func (s *state) float32ToUint64(n *Node, x *ssa.Value, ft, tt *Type) *ssa.Value {
 +	return s.floatToUint(&f32_u64, n, x, ft, tt)
 +}
 +func (s *state) float64ToUint64(n *Node, x *ssa.Value, ft, tt *Type) *ssa.Value {
 +	return s.floatToUint(&f64_u64, n, x, ft, tt)
 +}
 +
 +func (s *state) floatToUint(cvttab *f2uCvtTab, n *Node, x *ssa.Value, ft, tt *Type) *ssa.Value {
 +	// if x < 9223372036854775808.0 {
 +	// 	result = uintY(x)
 +	// } else {
 +	// 	y = x - 9223372036854775808.0
 +	// 	z = uintY(y)
 +	// 	result = z | -9223372036854775808
 +	// }
 +	twoToThe63 := cvttab.value(s, ft, 9223372036854775808.0)
 +	cmp := s.newValue2(cvttab.ltf, Types[TBOOL], x, twoToThe63)
 +	b := s.endBlock()
 +	b.Kind = ssa.BlockIf
 +	b.Control = cmp
 +	b.Likely = ssa.BranchLikely
 +
 +	bThen := s.f.NewBlock(ssa.BlockPlain)
 +	bElse := s.f.NewBlock(ssa.BlockPlain)
 +	bAfter := s.f.NewBlock(ssa.BlockPlain)
 +
 +	b.AddEdgeTo(bThen)
 +	s.startBlock(bThen)
 +	a0 := s.newValue1(cvttab.cvt2U, tt, x)
 +	s.vars[n] = a0
 +	s.endBlock()
 +	bThen.AddEdgeTo(bAfter)
 +
 +	b.AddEdgeTo(bElse)
 +	s.startBlock(bElse)
 +	y := s.newValue2(cvttab.subf, ft, x, twoToThe63)
 +	y = s.newValue1(cvttab.cvt2U, tt, y)
 +	z := s.constInt64(tt, -9223372036854775808)
 +	a1 := s.newValue2(ssa.OpOr64, tt, y, z)
 +	s.vars[n] = a1
 +	s.endBlock()
 +	bElse.AddEdgeTo(bAfter)
 +
 +	s.startBlock(bAfter)
 +	return s.variable(n, n.Type)
 +}
 +
 +// ifaceType returns the value for the word containing the type.
 +// n is the node for the interface expression.
 +// v is the corresponding value.
 +func (s *state) ifaceType(n *Node, v *ssa.Value) *ssa.Value {
 +	byteptr := Ptrto(Types[TUINT8]) // type used in runtime prototypes for runtime type (*byte)
 +
 +	if isnilinter(n.Type) {
 +		// Have *eface. The type is the first word in the struct.
 +		return s.newValue1(ssa.OpITab, byteptr, v)
 +	}
 +
 +	// Have *iface.
 +	// The first word in the struct is the *itab.
 +	// If the *itab is nil, return 0.
 +	// Otherwise, the second word in the *itab is the type.
 +
 +	tab := s.newValue1(ssa.OpITab, byteptr, v)
 +	s.vars[&typVar] = tab
 +	isnonnil := s.newValue2(ssa.OpNeqPtr, Types[TBOOL], tab, s.entryNewValue0(ssa.OpConstNil, byteptr))
 +	b := s.endBlock()
 +	b.Kind = ssa.BlockIf
 +	b.Control = isnonnil
 +	b.Likely = ssa.BranchLikely
 +
 +	bLoad := s.f.NewBlock(ssa.BlockPlain)
 +	bEnd := s.f.NewBlock(ssa.BlockPlain)
 +
 +	b.AddEdgeTo(bLoad)
 +	b.AddEdgeTo(bEnd)
 +	bLoad.AddEdgeTo(bEnd)
 +
 +	s.startBlock(bLoad)
 +	off := s.newValue1I(ssa.OpOffPtr, byteptr, int64(Widthptr), tab)
 +	s.vars[&typVar] = s.newValue2(ssa.OpLoad, byteptr, off, s.mem())
 +	s.endBlock()
 +
 +	s.startBlock(bEnd)
 +	typ := s.variable(&typVar, byteptr)
 +	delete(s.vars, &typVar)
 +	return typ
 +}
 +
 +// dottype generates SSA for a type assertion node.
 +// commaok indicates whether to panic or return a bool.
 +// If commaok is false, resok will be nil.
 +func (s *state) dottype(n *Node, commaok bool) (res, resok *ssa.Value) {
 +	iface := s.expr(n.Left)
 +	typ := s.ifaceType(n.Left, iface)  // actual concrete type
 +	target := s.expr(typename(n.Type)) // target type
 +	if !isdirectiface(n.Type) {
 +		// walk rewrites ODOTTYPE/OAS2DOTTYPE into runtime calls except for this case.
 +		Fatalf("dottype needs a direct iface type %s", n.Type)
 +	}
 +
 +	if Debug_typeassert > 0 {
 +		Warnl(int(n.Lineno), "type assertion inlined")
 +	}
 +
 +	// TODO:  If we have a nonempty interface and its itab field is nil,
 +	// then this test is redundant and ifaceType should just branch directly to bFail.
 +	cond := s.newValue2(ssa.OpEqPtr, Types[TBOOL], typ, target)
 +	b := s.endBlock()
 +	b.Kind = ssa.BlockIf
 +	b.Control = cond
 +	b.Likely = ssa.BranchLikely
 +
 +	byteptr := Ptrto(Types[TUINT8])
 +
 +	bOk := s.f.NewBlock(ssa.BlockPlain)
 +	bFail := s.f.NewBlock(ssa.BlockPlain)
 +	b.AddEdgeTo(bOk)
 +	b.AddEdgeTo(bFail)
 +
 +	if !commaok {
 +		// on failure, panic by calling panicdottype
 +		s.startBlock(bFail)
 +		taddr := s.newValue1A(ssa.OpAddr, byteptr, &ssa.ExternSymbol{byteptr, typenamesym(n.Left.Type)}, s.sb)
 +		s.rtcall(panicdottype, false, nil, typ, target, taddr)
 +
 +		// on success, return idata field
 +		s.startBlock(bOk)
 +		return s.newValue1(ssa.OpIData, n.Type, iface), nil
 +	}
 +
 +	// commaok is the more complicated case because we have
 +	// a control flow merge point.
 +	bEnd := s.f.NewBlock(ssa.BlockPlain)
 +
 +	// type assertion succeeded
 +	s.startBlock(bOk)
 +	s.vars[&idataVar] = s.newValue1(ssa.OpIData, n.Type, iface)
 +	s.vars[&okVar] = s.constBool(true)
 +	s.endBlock()
 +	bOk.AddEdgeTo(bEnd)
 +
 +	// type assertion failed
 +	s.startBlock(bFail)
 +	s.vars[&idataVar] = s.entryNewValue0(ssa.OpConstNil, byteptr)
 +	s.vars[&okVar] = s.constBool(false)
 +	s.endBlock()
 +	bFail.AddEdgeTo(bEnd)
 +
 +	// merge point
 +	s.startBlock(bEnd)
 +	res = s.variable(&idataVar, byteptr)
 +	resok = s.variable(&okVar, Types[TBOOL])
 +	delete(s.vars, &idataVar)
 +	delete(s.vars, &okVar)
 +	return res, resok
 +}
 +
 +// checkgoto checks that a goto from from to to does not
 +// jump into a block or jump over variable declarations.
 +// It is a copy of checkgoto in the pre-SSA backend,
 +// modified only for line number handling.
 +// TODO: document how this works and why it is designed the way it is.
 +func (s *state) checkgoto(from *Node, to *Node) {
 +	if from.Sym == to.Sym {
 +		return
 +	}
 +
 +	nf := 0
 +	for fs := from.Sym; fs != nil; fs = fs.Link {
 +		nf++
 +	}
 +	nt := 0
 +	for fs := to.Sym; fs != nil; fs = fs.Link {
 +		nt++
 +	}
 +	fs := from.Sym
 +	for ; nf > nt; nf-- {
 +		fs = fs.Link
 +	}
 +	if fs != to.Sym {
 +		// decide what to complain about.
 +		// prefer to complain about 'into block' over declarations,
 +		// so scan backward to find most recent block or else dcl.
 +		var block *Sym
 +
 +		var dcl *Sym
 +		ts := to.Sym
 +		for ; nt > nf; nt-- {
 +			if ts.Pkg == nil {
 +				block = ts
 +			} else {
 +				dcl = ts
 +			}
 +			ts = ts.Link
 +		}
 +
 +		for ts != fs {
 +			if ts.Pkg == nil {
 +				block = ts
 +			} else {
 +				dcl = ts
 +			}
 +			ts = ts.Link
 +			fs = fs.Link
 +		}
 +
 +		lno := int(from.Left.Lineno)
 +		if block != nil {
 +			yyerrorl(lno, "goto %v jumps into block starting at %v", from.Left.Sym, Ctxt.Line(int(block.Lastlineno)))
 +		} else {
 +			yyerrorl(lno, "goto %v jumps over declaration of %v at %v", from.Left.Sym, dcl, Ctxt.Line(int(dcl.Lastlineno)))
 +		}
 +	}
 +}
 +
 +// variable returns the value of a variable at the current location.
 +func (s *state) variable(name *Node, t ssa.Type) *ssa.Value {
 +	v := s.vars[name]
 +	if v == nil {
 +		// TODO: get type?  Take Sym as arg?
 +		v = s.newValue0A(ssa.OpFwdRef, t, name)
 +		s.vars[name] = v
 +	}
 +	return v
 +}
 +
 +func (s *state) mem() *ssa.Value {
 +	return s.variable(&memVar, ssa.TypeMem)
 +}
 +
 +func (s *state) linkForwardReferences() {
 +	// Build ssa graph.  Each variable on its first use in a basic block
 +	// leaves a FwdRef in that block representing the incoming value
 +	// of that variable.  This function links that ref up with possible definitions,
 +	// inserting Phi values as needed.  This is essentially the algorithm
 +	// described by Brau, Buchwald, Hack, LeiÃŸa, Mallon, and Zwinkau:
 +	// http://pp.info.uni-karlsruhe.de/uploads/publikationen/braun13cc.pdf
 +	for _, b := range s.f.Blocks {
 +		for _, v := range b.Values {
 +			if v.Op != ssa.OpFwdRef {
 +				continue
 +			}
 +			name := v.Aux.(*Node)
 +			v.Op = ssa.OpCopy
 +			v.Aux = nil
 +			v.SetArgs1(s.lookupVarIncoming(b, v.Type, name))
 +		}
 +	}
 +}
 +
 +// lookupVarIncoming finds the variable's value at the start of block b.
 +func (s *state) lookupVarIncoming(b *ssa.Block, t ssa.Type, name *Node) *ssa.Value {
 +	// TODO(khr): have lookupVarIncoming overwrite the fwdRef or copy it
 +	// will be used in, instead of having the result used in a copy value.
 +	if b == s.f.Entry {
 +		if name == &memVar {
 +			return s.startmem
 +		}
 +		if canSSA(name) {
 +			v := s.entryNewValue0A(ssa.OpArg, t, name)
 +			// v starts with AuxInt == 0.
 +			s.addNamedValue(name, v)
 +			return v
 +		}
 +		// variable is live at the entry block.  Load it.
 +		addr := s.decladdrs[name]
 +		if addr == nil {
 +			// TODO: closure args reach here.
 +			s.Unimplementedf("unhandled closure arg %s at entry to function %s", name, b.Func.Name)
 +		}
 +		if _, ok := addr.Aux.(*ssa.ArgSymbol); !ok {
 +			s.Fatalf("variable live at start of function %s is not an argument %s", b.Func.Name, name)
 +		}
 +		return s.entryNewValue2(ssa.OpLoad, t, addr, s.startmem)
 +	}
 +	var vals []*ssa.Value
 +	for _, p := range b.Preds {
 +		vals = append(vals, s.lookupVarOutgoing(p, t, name))
 +	}
 +	if len(vals) == 0 {
 +		// This block is dead; we have no predecessors and we're not the entry block.
 +		// It doesn't matter what we use here as long as it is well-formed,
 +		// so use the default/zero value.
 +		if name == &memVar {
 +			return s.startmem
 +		}
 +		return s.zeroVal(name.Type)
 +	}
 +	v0 := vals[0]
 +	for i := 1; i < len(vals); i++ {
 +		if vals[i] != v0 {
 +			// need a phi value
 +			v := b.NewValue0(s.peekLine(), ssa.OpPhi, t)
 +			v.AddArgs(vals...)
 +			s.addNamedValue(name, v)
 +			return v
 +		}
 +	}
 +	return v0
 +}
 +
 +// lookupVarOutgoing finds the variable's value at the end of block b.
 +func (s *state) lookupVarOutgoing(b *ssa.Block, t ssa.Type, name *Node) *ssa.Value {
 +	m := s.defvars[b.ID]
 +	if v, ok := m[name]; ok {
 +		return v
 +	}
 +	// The variable is not defined by b and we haven't
 +	// looked it up yet.  Generate v, a copy value which
 +	// will be the outgoing value of the variable.  Then
 +	// look up w, the incoming value of the variable.
 +	// Make v = copy(w).  We need the extra copy to
 +	// prevent infinite recursion when looking up the
 +	// incoming value of the variable.
 +	v := b.NewValue0(s.peekLine(), ssa.OpCopy, t)
 +	m[name] = v
 +	v.AddArg(s.lookupVarIncoming(b, t, name))
 +	return v
 +}
 +
 +// TODO: the above mutually recursive functions can lead to very deep stacks.  Fix that.
 +
 +func (s *state) addNamedValue(n *Node, v *ssa.Value) {
 +	if n.Class == Pxxx {
 +		// Don't track our dummy nodes (&memVar etc.).
 +		return
 +	}
 +	if n.Sym == nil {
 +		// TODO: What the heck is this?
 +		return
 +	}
 +	if strings.HasPrefix(n.Sym.Name, "autotmp_") {
 +		// Don't track autotmp_ variables.
 +		return
 +	}
 +	if n.Class == PAUTO && (v.Type.IsString() || v.Type.IsSlice() || v.Type.IsInterface()) {
 +		// TODO: can't handle auto compound objects with pointers yet.
 +		// The live variable analysis barfs because we don't put VARDEF
 +		// pseudos in the right place when we spill to these nodes.
 +		return
 +	}
 +	if n.Class == PAUTO && n.Xoffset != 0 {
 +		s.Fatalf("AUTO var with offset %s %d", n, n.Xoffset)
 +	}
 +	loc := ssa.LocalSlot{N: n, Type: n.Type, Off: 0}
 +	values, ok := s.f.NamedValues[loc]
 +	if !ok {
 +		s.f.Names = append(s.f.Names, loc)
 +	}
 +	s.f.NamedValues[loc] = append(values, v)
 +}
 +
 +// an unresolved branch
 +type branch struct {
 +	p *obj.Prog  // branch instruction
 +	b *ssa.Block // target
 +}
 +
 +type genState struct {
 +	// branches remembers all the branch instructions we've seen
 +	// and where they would like to go.
 +	branches []branch
 +
 +	// bstart remembers where each block starts (indexed by block ID)
 +	bstart []*obj.Prog
 +
 +	// deferBranches remembers all the defer branches we've seen.
 +	deferBranches []*obj.Prog
 +
 +	// deferTarget remembers the (last) deferreturn call site.
 +	deferTarget *obj.Prog
 +}
 +
 +// genssa appends entries to ptxt for each instruction in f.
 +// gcargs and gclocals are filled in with pointer maps for the frame.
 +func genssa(f *ssa.Func, ptxt *obj.Prog, gcargs, gclocals *Sym) {
 +	var s genState
 +
 +	e := f.Config.Frontend().(*ssaExport)
 +	// We're about to emit a bunch of Progs.
 +	// Since the only way to get here is to explicitly request it,
 +	// just fail on unimplemented instead of trying to unwind our mess.
 +	e.mustImplement = true
 +
 +	// Remember where each block starts.
 +	s.bstart = make([]*obj.Prog, f.NumBlocks())
 +
 +	var valueProgs map[*obj.Prog]*ssa.Value
 +	var blockProgs map[*obj.Prog]*ssa.Block
 +	const logProgs = true
 +	if logProgs {
 +		valueProgs = make(map[*obj.Prog]*ssa.Value, f.NumValues())
 +		blockProgs = make(map[*obj.Prog]*ssa.Block, f.NumBlocks())
 +		f.Logf("genssa %s\n", f.Name)
 +		blockProgs[Pc] = f.Blocks[0]
 +	}
 +
 +	// Emit basic blocks
 +	for i, b := range f.Blocks {
 +		s.bstart[b.ID] = Pc
 +		// Emit values in block
 +		for _, v := range b.Values {
 +			x := Pc
 +			s.genValue(v)
 +			if logProgs {
 +				for ; x != Pc; x = x.Link {
 +					valueProgs[x] = v
 +				}
 +			}
 +		}
 +		// Emit control flow instructions for block
 +		var next *ssa.Block
 +		if i < len(f.Blocks)-1 {
 +			next = f.Blocks[i+1]
 +		}
 +		x := Pc
 +		s.genBlock(b, next)
 +		if logProgs {
 +			for ; x != Pc; x = x.Link {
 +				blockProgs[x] = b
 +			}
 +		}
 +	}
 +
 +	// Resolve branches
 +	for _, br := range s.branches {
 +		br.p.To.Val = s.bstart[br.b.ID]
 +	}
 +	if s.deferBranches != nil && s.deferTarget == nil {
 +		// This can happen when the function has a defer but
 +		// no return (because it has an infinite loop).
 +		s.deferReturn()
 +		Prog(obj.ARET)
 +	}
 +	for _, p := range s.deferBranches {
 +		p.To.Val = s.deferTarget
 +	}
 +
 +	if logProgs {
 +		for p := ptxt; p != nil; p = p.Link {
 +			var s string
 +			if v, ok := valueProgs[p]; ok {
 +				s = v.String()
 +			} else if b, ok := blockProgs[p]; ok {
 +				s = b.String()
 +			} else {
 +				s = "   " // most value and branch strings are 2-3 characters long
 +			}
 +			f.Logf("%s\t%s\n", s, p)
 +		}
 +		if f.Config.HTML != nil {
 +			saved := ptxt.Ctxt.LineHist.PrintFilenameOnly
 +			ptxt.Ctxt.LineHist.PrintFilenameOnly = true
 +			var buf bytes.Buffer
 +			buf.WriteString("<code>")
 +			buf.WriteString("<dl class=\"ssa-gen\">")
 +			for p := ptxt; p != nil; p = p.Link {
 +				buf.WriteString("<dt class=\"ssa-prog-src\">")
 +				if v, ok := valueProgs[p]; ok {
 +					buf.WriteString(v.HTML())
 +				} else if b, ok := blockProgs[p]; ok {
 +					buf.WriteString(b.HTML())
 +				}
 +				buf.WriteString("</dt>")
 +				buf.WriteString("<dd class=\"ssa-prog\">")
 +				buf.WriteString(html.EscapeString(p.String()))
 +				buf.WriteString("</dd>")
 +				buf.WriteString("</li>")
 +			}
 +			buf.WriteString("</dl>")
 +			buf.WriteString("</code>")
 +			f.Config.HTML.WriteColumn("genssa", buf.String())
 +			ptxt.Ctxt.LineHist.PrintFilenameOnly = saved
 +		}
 +	}
 +
 +	// Emit static data
 +	if f.StaticData != nil {
 +		for _, n := range f.StaticData.([]*Node) {
 +			if !gen_as_init(n, false) {
 +				Fatalf("non-static data marked as static: %v\n\n", n, f)
 +			}
 +		}
 +	}
 +
 +	// Allocate stack frame
 +	allocauto(ptxt)
 +
 +	// Generate gc bitmaps.
 +	liveness(Curfn, ptxt, gcargs, gclocals)
 +	gcsymdup(gcargs)
 +	gcsymdup(gclocals)
 +
 +	// Add frame prologue.  Zero ambiguously live variables.
 +	Thearch.Defframe(ptxt)
 +	if Debug['f'] != 0 {
 +		frame(0)
 +	}
 +
 +	// Remove leftover instrumentation from the instruction stream.
 +	removevardef(ptxt)
 +
 +	f.Config.HTML.Close()
 +}
 +
 +// opregreg emits instructions for
 +//     dest := dest(To) op src(From)
 +// and also returns the created obj.Prog so it
 +// may be further adjusted (offset, scale, etc).
 +func opregreg(op int, dest, src int16) *obj.Prog {
 +	p := Prog(op)
 +	p.From.Type = obj.TYPE_REG
 +	p.To.Type = obj.TYPE_REG
 +	p.To.Reg = dest
 +	p.From.Reg = src
 +	return p
 +}
 +
 +func (s *genState) genValue(v *ssa.Value) {
 +	lineno = v.Line
 +	switch v.Op {
 +	case ssa.OpAMD64ADDQ:
 +		// TODO: use addq instead of leaq if target is in the right register.
 +		p := Prog(x86.ALEAQ)
 +		p.From.Type = obj.TYPE_MEM
 +		p.From.Reg = regnum(v.Args[0])
 +		p.From.Scale = 1
 +		p.From.Index = regnum(v.Args[1])
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = regnum(v)
 +	case ssa.OpAMD64ADDL:
 +		p := Prog(x86.ALEAL)
 +		p.From.Type = obj.TYPE_MEM
 +		p.From.Reg = regnum(v.Args[0])
 +		p.From.Scale = 1
 +		p.From.Index = regnum(v.Args[1])
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = regnum(v)
 +	case ssa.OpAMD64ADDW:
 +		p := Prog(x86.ALEAW)
 +		p.From.Type = obj.TYPE_MEM
 +		p.From.Reg = regnum(v.Args[0])
 +		p.From.Scale = 1
 +		p.From.Index = regnum(v.Args[1])
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = regnum(v)
 +	// 2-address opcode arithmetic, symmetric
 +	case ssa.OpAMD64ADDB, ssa.OpAMD64ADDSS, ssa.OpAMD64ADDSD,
 +		ssa.OpAMD64ANDQ, ssa.OpAMD64ANDL, ssa.OpAMD64ANDW, ssa.OpAMD64ANDB,
 +		ssa.OpAMD64ORQ, ssa.OpAMD64ORL, ssa.OpAMD64ORW, ssa.OpAMD64ORB,
 +		ssa.OpAMD64XORQ, ssa.OpAMD64XORL, ssa.OpAMD64XORW, ssa.OpAMD64XORB,
 +		ssa.OpAMD64MULQ, ssa.OpAMD64MULL, ssa.OpAMD64MULW, ssa.OpAMD64MULB,
 +		ssa.OpAMD64MULSS, ssa.OpAMD64MULSD, ssa.OpAMD64PXOR:
 +		r := regnum(v)
 +		x := regnum(v.Args[0])
 +		y := regnum(v.Args[1])
 +		if x != r && y != r {
 +			opregreg(moveByType(v.Type), r, x)
 +			x = r
 +		}
 +		p := Prog(v.Op.Asm())
 +		p.From.Type = obj.TYPE_REG
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = r
 +		if x == r {
 +			p.From.Reg = y
 +		} else {
 +			p.From.Reg = x
 +		}
 +	// 2-address opcode arithmetic, not symmetric
 +	case ssa.OpAMD64SUBQ, ssa.OpAMD64SUBL, ssa.OpAMD64SUBW, ssa.OpAMD64SUBB:
 +		r := regnum(v)
 +		x := regnum(v.Args[0])
 +		y := regnum(v.Args[1])
 +		var neg bool
 +		if y == r {
 +			// compute -(y-x) instead
 +			x, y = y, x
 +			neg = true
 +		}
 +		if x != r {
 +			opregreg(moveByType(v.Type), r, x)
 +		}
 +		opregreg(v.Op.Asm(), r, y)
 +
 +		if neg {
 +			p := Prog(x86.ANEGQ) // TODO: use correct size?  This is mostly a hack until regalloc does 2-address correctly
 +			p.To.Type = obj.TYPE_REG
 +			p.To.Reg = r
 +		}
 +	case ssa.OpAMD64SUBSS, ssa.OpAMD64SUBSD, ssa.OpAMD64DIVSS, ssa.OpAMD64DIVSD:
 +		r := regnum(v)
 +		x := regnum(v.Args[0])
 +		y := regnum(v.Args[1])
 +		if y == r && x != r {
 +			// r/y := x op r/y, need to preserve x and rewrite to
 +			// r/y := r/y op x15
 +			x15 := int16(x86.REG_X15)
 +			// register move y to x15
 +			// register move x to y
 +			// rename y with x15
 +			opregreg(moveByType(v.Type), x15, y)
 +			opregreg(moveByType(v.Type), r, x)
 +			y = x15
 +		} else if x != r {
 +			opregreg(moveByType(v.Type), r, x)
 +		}
 +		opregreg(v.Op.Asm(), r, y)
 +
 +	case ssa.OpAMD64DIVQ, ssa.OpAMD64DIVL, ssa.OpAMD64DIVW,
 +		ssa.OpAMD64DIVQU, ssa.OpAMD64DIVLU, ssa.OpAMD64DIVWU,
 +		ssa.OpAMD64MODQ, ssa.OpAMD64MODL, ssa.OpAMD64MODW,
 +		ssa.OpAMD64MODQU, ssa.OpAMD64MODLU, ssa.OpAMD64MODWU:
 +
 +		// Arg[0] is already in AX as it's the only register we allow
 +		// and AX is the only output
 +		x := regnum(v.Args[1])
 +
 +		// CPU faults upon signed overflow, which occurs when most
 +		// negative int is divided by -1.
 +		var j *obj.Prog
 +		if v.Op == ssa.OpAMD64DIVQ || v.Op == ssa.OpAMD64DIVL ||
 +			v.Op == ssa.OpAMD64DIVW || v.Op == ssa.OpAMD64MODQ ||
 +			v.Op == ssa.OpAMD64MODL || v.Op == ssa.OpAMD64MODW {
 +
 +			var c *obj.Prog
 +			switch v.Op {
 +			case ssa.OpAMD64DIVQ, ssa.OpAMD64MODQ:
 +				c = Prog(x86.ACMPQ)
 +				j = Prog(x86.AJEQ)
 +				// go ahead and sign extend to save doing it later
 +				Prog(x86.ACQO)
 +
 +			case ssa.OpAMD64DIVL, ssa.OpAMD64MODL:
 +				c = Prog(x86.ACMPL)
 +				j = Prog(x86.AJEQ)
 +				Prog(x86.ACDQ)
 +
 +			case ssa.OpAMD64DIVW, ssa.OpAMD64MODW:
 +				c = Prog(x86.ACMPW)
 +				j = Prog(x86.AJEQ)
 +				Prog(x86.ACWD)
 +			}
 +			c.From.Type = obj.TYPE_REG
 +			c.From.Reg = x
 +			c.To.Type = obj.TYPE_CONST
 +			c.To.Offset = -1
 +
 +			j.To.Type = obj.TYPE_BRANCH
 +
 +		}
 +
 +		// for unsigned ints, we sign extend by setting DX = 0
 +		// signed ints were sign extended above
 +		if v.Op == ssa.OpAMD64DIVQU || v.Op == ssa.OpAMD64MODQU ||
 +			v.Op == ssa.OpAMD64DIVLU || v.Op == ssa.OpAMD64MODLU ||
 +			v.Op == ssa.OpAMD64DIVWU || v.Op == ssa.OpAMD64MODWU {
 +			c := Prog(x86.AXORQ)
 +			c.From.Type = obj.TYPE_REG
 +			c.From.Reg = x86.REG_DX
 +			c.To.Type = obj.TYPE_REG
 +			c.To.Reg = x86.REG_DX
 +		}
 +
 +		p := Prog(v.Op.Asm())
 +		p.From.Type = obj.TYPE_REG
 +		p.From.Reg = x
 +
 +		// signed division, rest of the check for -1 case
 +		if j != nil {
 +			j2 := Prog(obj.AJMP)
 +			j2.To.Type = obj.TYPE_BRANCH
 +
 +			var n *obj.Prog
 +			if v.Op == ssa.OpAMD64DIVQ || v.Op == ssa.OpAMD64DIVL ||
 +				v.Op == ssa.OpAMD64DIVW {
 +				// n * -1 = -n
 +				n = Prog(x86.ANEGQ)
 +				n.To.Type = obj.TYPE_REG
 +				n.To.Reg = x86.REG_AX
 +			} else {
 +				// n % -1 == 0
 +				n = Prog(x86.AXORQ)
 +				n.From.Type = obj.TYPE_REG
 +				n.From.Reg = x86.REG_DX
 +				n.To.Type = obj.TYPE_REG
 +				n.To.Reg = x86.REG_DX
 +			}
 +
 +			j.To.Val = n
 +			j2.To.Val = Pc
 +		}
 +
 +	case ssa.OpAMD64HMULL, ssa.OpAMD64HMULW, ssa.OpAMD64HMULB,
 +		ssa.OpAMD64HMULLU, ssa.OpAMD64HMULWU, ssa.OpAMD64HMULBU:
 +		// the frontend rewrites constant division by 8/16/32 bit integers into
 +		// HMUL by a constant
 +
 +		// Arg[0] is already in AX as it's the only register we allow
 +		// and DX is the only output we care about (the high bits)
 +		p := Prog(v.Op.Asm())
 +		p.From.Type = obj.TYPE_REG
 +		p.From.Reg = regnum(v.Args[1])
 +
 +		// IMULB puts the high portion in AH instead of DL,
 +		// so move it to DL for consistency
 +		if v.Type.Size() == 1 {
 +			m := Prog(x86.AMOVB)
 +			m.From.Type = obj.TYPE_REG
 +			m.From.Reg = x86.REG_AH
 +			m.To.Type = obj.TYPE_REG
 +			m.To.Reg = x86.REG_DX
 +		}
 +
 +	case ssa.OpAMD64SHLQ, ssa.OpAMD64SHLL, ssa.OpAMD64SHLW, ssa.OpAMD64SHLB,
 +		ssa.OpAMD64SHRQ, ssa.OpAMD64SHRL, ssa.OpAMD64SHRW, ssa.OpAMD64SHRB,
 +		ssa.OpAMD64SARQ, ssa.OpAMD64SARL, ssa.OpAMD64SARW, ssa.OpAMD64SARB:
 +		x := regnum(v.Args[0])
 +		r := regnum(v)
 +		if x != r {
 +			if r == x86.REG_CX {
 +				v.Fatalf("can't implement %s, target and shift both in CX", v.LongString())
 +			}
 +			p := Prog(moveByType(v.Type))
 +			p.From.Type = obj.TYPE_REG
 +			p.From.Reg = x
 +			p.To.Type = obj.TYPE_REG
 +			p.To.Reg = r
 +		}
 +		p := Prog(v.Op.Asm())
 +		p.From.Type = obj.TYPE_REG
 +		p.From.Reg = regnum(v.Args[1]) // should be CX
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = r
 +	case ssa.OpAMD64ADDQconst, ssa.OpAMD64ADDLconst, ssa.OpAMD64ADDWconst:
 +		// TODO: use addq instead of leaq if target is in the right register.
 +		var asm int
 +		switch v.Op {
 +		case ssa.OpAMD64ADDQconst:
 +			asm = x86.ALEAQ
 +		case ssa.OpAMD64ADDLconst:
 +			asm = x86.ALEAL
 +		case ssa.OpAMD64ADDWconst:
 +			asm = x86.ALEAW
 +		}
 +		p := Prog(asm)
 +		p.From.Type = obj.TYPE_MEM
 +		p.From.Reg = regnum(v.Args[0])
 +		p.From.Offset = v.AuxInt
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = regnum(v)
 +	case ssa.OpAMD64MULQconst, ssa.OpAMD64MULLconst, ssa.OpAMD64MULWconst, ssa.OpAMD64MULBconst:
 +		r := regnum(v)
 +		x := regnum(v.Args[0])
 +		if r != x {
 +			p := Prog(moveByType(v.Type))
 +			p.From.Type = obj.TYPE_REG
 +			p.From.Reg = x
 +			p.To.Type = obj.TYPE_REG
 +			p.To.Reg = r
 +		}
 +		p := Prog(v.Op.Asm())
 +		p.From.Type = obj.TYPE_CONST
 +		p.From.Offset = v.AuxInt
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = r
 +		// TODO: Teach doasm to compile the three-address multiply imul $c, r1, r2
 +		// instead of using the MOVQ above.
 +		//p.From3 = new(obj.Addr)
 +		//p.From3.Type = obj.TYPE_REG
 +		//p.From3.Reg = regnum(v.Args[0])
 +	case ssa.OpAMD64ADDBconst,
 +		ssa.OpAMD64ANDQconst, ssa.OpAMD64ANDLconst, ssa.OpAMD64ANDWconst, ssa.OpAMD64ANDBconst,
 +		ssa.OpAMD64ORQconst, ssa.OpAMD64ORLconst, ssa.OpAMD64ORWconst, ssa.OpAMD64ORBconst,
 +		ssa.OpAMD64XORQconst, ssa.OpAMD64XORLconst, ssa.OpAMD64XORWconst, ssa.OpAMD64XORBconst,
 +		ssa.OpAMD64SUBQconst, ssa.OpAMD64SUBLconst, ssa.OpAMD64SUBWconst, ssa.OpAMD64SUBBconst,
 +		ssa.OpAMD64SHLQconst, ssa.OpAMD64SHLLconst, ssa.OpAMD64SHLWconst, ssa.OpAMD64SHLBconst,
 +		ssa.OpAMD64SHRQconst, ssa.OpAMD64SHRLconst, ssa.OpAMD64SHRWconst, ssa.OpAMD64SHRBconst,
 +		ssa.OpAMD64SARQconst, ssa.OpAMD64SARLconst, ssa.OpAMD64SARWconst, ssa.OpAMD64SARBconst,
 +		ssa.OpAMD64ROLQconst, ssa.OpAMD64ROLLconst, ssa.OpAMD64ROLWconst, ssa.OpAMD64ROLBconst:
 +		// This code compensates for the fact that the register allocator
 +		// doesn't understand 2-address instructions yet.  TODO: fix that.
 +		x := regnum(v.Args[0])
 +		r := regnum(v)
 +		if x != r {
 +			p := Prog(moveByType(v.Type))
 +			p.From.Type = obj.TYPE_REG
 +			p.From.Reg = x
 +			p.To.Type = obj.TYPE_REG
 +			p.To.Reg = r
 +		}
 +		p := Prog(v.Op.Asm())
 +		p.From.Type = obj.TYPE_CONST
 +		p.From.Offset = v.AuxInt
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = r
 +	case ssa.OpAMD64SBBQcarrymask, ssa.OpAMD64SBBLcarrymask:
 +		r := regnum(v)
 +		p := Prog(v.Op.Asm())
 +		p.From.Type = obj.TYPE_REG
 +		p.From.Reg = r
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = r
 +	case ssa.OpAMD64LEAQ1, ssa.OpAMD64LEAQ2, ssa.OpAMD64LEAQ4, ssa.OpAMD64LEAQ8:
 +		p := Prog(x86.ALEAQ)
 +		p.From.Type = obj.TYPE_MEM
 +		p.From.Reg = regnum(v.Args[0])
 +		switch v.Op {
 +		case ssa.OpAMD64LEAQ1:
 +			p.From.Scale = 1
 +		case ssa.OpAMD64LEAQ2:
 +			p.From.Scale = 2
 +		case ssa.OpAMD64LEAQ4:
 +			p.From.Scale = 4
 +		case ssa.OpAMD64LEAQ8:
 +			p.From.Scale = 8
 +		}
 +		p.From.Index = regnum(v.Args[1])
 +		addAux(&p.From, v)
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = regnum(v)
 +	case ssa.OpAMD64LEAQ:
 +		p := Prog(x86.ALEAQ)
 +		p.From.Type = obj.TYPE_MEM
 +		p.From.Reg = regnum(v.Args[0])
 +		addAux(&p.From, v)
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = regnum(v)
 +	case ssa.OpAMD64CMPQ, ssa.OpAMD64CMPL, ssa.OpAMD64CMPW, ssa.OpAMD64CMPB,
 +		ssa.OpAMD64TESTQ, ssa.OpAMD64TESTL, ssa.OpAMD64TESTW, ssa.OpAMD64TESTB:
 +		opregreg(v.Op.Asm(), regnum(v.Args[1]), regnum(v.Args[0]))
 +	case ssa.OpAMD64UCOMISS, ssa.OpAMD64UCOMISD:
 +		// Go assembler has swapped operands for UCOMISx relative to CMP,
 +		// must account for that right here.
 +		opregreg(v.Op.Asm(), regnum(v.Args[0]), regnum(v.Args[1]))
 +	case ssa.OpAMD64CMPQconst, ssa.OpAMD64CMPLconst, ssa.OpAMD64CMPWconst, ssa.OpAMD64CMPBconst,
 +		ssa.OpAMD64TESTQconst, ssa.OpAMD64TESTLconst, ssa.OpAMD64TESTWconst, ssa.OpAMD64TESTBconst:
 +		p := Prog(v.Op.Asm())
 +		p.From.Type = obj.TYPE_REG
 +		p.From.Reg = regnum(v.Args[0])
 +		p.To.Type = obj.TYPE_CONST
 +		p.To.Offset = v.AuxInt
 +	case ssa.OpAMD64MOVBconst, ssa.OpAMD64MOVWconst, ssa.OpAMD64MOVLconst, ssa.OpAMD64MOVQconst:
 +		x := regnum(v)
 +		p := Prog(v.Op.Asm())
 +		p.From.Type = obj.TYPE_CONST
 +		var i int64
 +		switch v.Op {
 +		case ssa.OpAMD64MOVBconst:
 +			i = int64(int8(v.AuxInt))
 +		case ssa.OpAMD64MOVWconst:
 +			i = int64(int16(v.AuxInt))
 +		case ssa.OpAMD64MOVLconst:
 +			i = int64(int32(v.AuxInt))
 +		case ssa.OpAMD64MOVQconst:
 +			i = v.AuxInt
 +		}
 +		p.From.Offset = i
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = x
 +	case ssa.OpAMD64MOVSSconst, ssa.OpAMD64MOVSDconst:
 +		x := regnum(v)
 +		p := Prog(v.Op.Asm())
 +		p.From.Type = obj.TYPE_FCONST
 +		p.From.Val = math.Float64frombits(uint64(v.AuxInt))
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = x
 +	case ssa.OpAMD64MOVQload, ssa.OpAMD64MOVSSload, ssa.OpAMD64MOVSDload, ssa.OpAMD64MOVLload, ssa.OpAMD64MOVWload, ssa.OpAMD64MOVBload, ssa.OpAMD64MOVBQSXload, ssa.OpAMD64MOVBQZXload, ssa.OpAMD64MOVOload:
 +		p := Prog(v.Op.Asm())
 +		p.From.Type = obj.TYPE_MEM
 +		p.From.Reg = regnum(v.Args[0])
 +		addAux(&p.From, v)
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = regnum(v)
 +	case ssa.OpAMD64MOVQloadidx8, ssa.OpAMD64MOVSDloadidx8:
 +		p := Prog(v.Op.Asm())
 +		p.From.Type = obj.TYPE_MEM
 +		p.From.Reg = regnum(v.Args[0])
 +		addAux(&p.From, v)
 +		p.From.Scale = 8
 +		p.From.Index = regnum(v.Args[1])
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = regnum(v)
 +	case ssa.OpAMD64MOVSSloadidx4:
 +		p := Prog(v.Op.Asm())
 +		p.From.Type = obj.TYPE_MEM
 +		p.From.Reg = regnum(v.Args[0])
 +		addAux(&p.From, v)
 +		p.From.Scale = 4
 +		p.From.Index = regnum(v.Args[1])
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = regnum(v)
 +	case ssa.OpAMD64MOVQstore, ssa.OpAMD64MOVSSstore, ssa.OpAMD64MOVSDstore, ssa.OpAMD64MOVLstore, ssa.OpAMD64MOVWstore, ssa.OpAMD64MOVBstore, ssa.OpAMD64MOVOstore:
 +		p := Prog(v.Op.Asm())
 +		p.From.Type = obj.TYPE_REG
 +		p.From.Reg = regnum(v.Args[1])
 +		p.To.Type = obj.TYPE_MEM
 +		p.To.Reg = regnum(v.Args[0])
 +		addAux(&p.To, v)
 +	case ssa.OpAMD64MOVQstoreidx8, ssa.OpAMD64MOVSDstoreidx8:
 +		p := Prog(v.Op.Asm())
 +		p.From.Type = obj.TYPE_REG
 +		p.From.Reg = regnum(v.Args[2])
 +		p.To.Type = obj.TYPE_MEM
 +		p.To.Reg = regnum(v.Args[0])
 +		p.To.Scale = 8
 +		p.To.Index = regnum(v.Args[1])
 +		addAux(&p.To, v)
 +	case ssa.OpAMD64MOVSSstoreidx4:
 +		p := Prog(v.Op.Asm())
 +		p.From.Type = obj.TYPE_REG
 +		p.From.Reg = regnum(v.Args[2])
 +		p.To.Type = obj.TYPE_MEM
 +		p.To.Reg = regnum(v.Args[0])
 +		p.To.Scale = 4
 +		p.To.Index = regnum(v.Args[1])
 +		addAux(&p.To, v)
 +	case ssa.OpAMD64MOVQstoreconst, ssa.OpAMD64MOVLstoreconst, ssa.OpAMD64MOVWstoreconst, ssa.OpAMD64MOVBstoreconst:
 +		p := Prog(v.Op.Asm())
 +		p.From.Type = obj.TYPE_CONST
 +		sc := ssa.StoreConst(v.AuxInt)
 +		i := sc.Val()
 +		switch v.Op {
 +		case ssa.OpAMD64MOVBstoreconst:
 +			i = int64(int8(i))
 +		case ssa.OpAMD64MOVWstoreconst:
 +			i = int64(int16(i))
 +		case ssa.OpAMD64MOVLstoreconst:
 +			i = int64(int32(i))
 +		case ssa.OpAMD64MOVQstoreconst:
 +		}
 +		p.From.Offset = i
 +		p.To.Type = obj.TYPE_MEM
 +		p.To.Reg = regnum(v.Args[0])
 +		addAux2(&p.To, v, sc.Off())
 +	case ssa.OpAMD64MOVLQSX, ssa.OpAMD64MOVWQSX, ssa.OpAMD64MOVBQSX, ssa.OpAMD64MOVLQZX, ssa.OpAMD64MOVWQZX, ssa.OpAMD64MOVBQZX,
 +		ssa.OpAMD64CVTSL2SS, ssa.OpAMD64CVTSL2SD, ssa.OpAMD64CVTSQ2SS, ssa.OpAMD64CVTSQ2SD,
 +		ssa.OpAMD64CVTTSS2SL, ssa.OpAMD64CVTTSD2SL, ssa.OpAMD64CVTTSS2SQ, ssa.OpAMD64CVTTSD2SQ,
 +		ssa.OpAMD64CVTSS2SD, ssa.OpAMD64CVTSD2SS:
 +		opregreg(v.Op.Asm(), regnum(v), regnum(v.Args[0]))
 +	case ssa.OpAMD64DUFFZERO:
 +		p := Prog(obj.ADUFFZERO)
 +		p.To.Type = obj.TYPE_ADDR
 +		p.To.Sym = Linksym(Pkglookup("duffzero", Runtimepkg))
 +		p.To.Offset = v.AuxInt
 +	case ssa.OpAMD64MOVOconst:
 +		if v.AuxInt != 0 {
 +			v.Unimplementedf("MOVOconst can only do constant=0")
 +		}
 +		r := regnum(v)
 +		opregreg(x86.AXORPS, r, r)
 +	case ssa.OpAMD64DUFFCOPY:
 +		p := Prog(obj.ADUFFCOPY)
 +		p.To.Type = obj.TYPE_ADDR
 +		p.To.Sym = Linksym(Pkglookup("duffcopy", Runtimepkg))
 +		p.To.Offset = v.AuxInt
 +
 +	case ssa.OpCopy, ssa.OpAMD64MOVQconvert: // TODO: lower Copy to MOVQ earlier?
 +		if v.Type.IsMemory() {
 +			return
 +		}
 +		x := regnum(v.Args[0])
 +		y := regnum(v)
 +		if x != y {
 +			opregreg(moveByType(v.Type), y, x)
 +		}
 +	case ssa.OpLoadReg:
 +		if v.Type.IsFlags() {
 +			v.Unimplementedf("load flags not implemented: %v", v.LongString())
 +			return
 +		}
 +		p := Prog(loadByType(v.Type))
 +		n, off := autoVar(v.Args[0])
 +		p.From.Type = obj.TYPE_MEM
 +		p.From.Node = n
 +		p.From.Sym = Linksym(n.Sym)
 +		p.From.Offset = off
 +		if n.Class == PPARAM {
 +			p.From.Name = obj.NAME_PARAM
 +			p.From.Offset += n.Xoffset
 +		} else {
 +			p.From.Name = obj.NAME_AUTO
 +		}
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = regnum(v)
 +
 +	case ssa.OpStoreReg:
 +		if v.Type.IsFlags() {
 +			v.Unimplementedf("store flags not implemented: %v", v.LongString())
 +			return
 +		}
 +		p := Prog(storeByType(v.Type))
 +		p.From.Type = obj.TYPE_REG
 +		p.From.Reg = regnum(v.Args[0])
 +		n, off := autoVar(v)
 +		p.To.Type = obj.TYPE_MEM
 +		p.To.Node = n
 +		p.To.Sym = Linksym(n.Sym)
 +		p.To.Offset = off
 +		if n.Class == PPARAM {
 +			p.To.Name = obj.NAME_PARAM
 +			p.To.Offset += n.Xoffset
 +		} else {
 +			p.To.Name = obj.NAME_AUTO
 +		}
 +	case ssa.OpPhi:
 +		// just check to make sure regalloc and stackalloc did it right
 +		if v.Type.IsMemory() {
 +			return
 +		}
 +		f := v.Block.Func
 +		loc := f.RegAlloc[v.ID]
 +		for _, a := range v.Args {
 +			if aloc := f.RegAlloc[a.ID]; aloc != loc { // TODO: .Equal() instead?
 +				v.Fatalf("phi arg at different location than phi: %v @ %v, but arg %v @ %v\n%s\n", v, loc, a, aloc, v.Block.Func)
 +			}
 +		}
 +	case ssa.OpConst8, ssa.OpConst16, ssa.OpConst32, ssa.OpConst64, ssa.OpConstString, ssa.OpConstNil, ssa.OpConstBool,
 +		ssa.OpConst32F, ssa.OpConst64F:
 +		if v.Block.Func.RegAlloc[v.ID] != nil {
 +			v.Fatalf("const value %v shouldn't have a location", v)
 +		}
 +
 +	case ssa.OpInitMem:
 +		// memory arg needs no code
 +	case ssa.OpArg:
 +		// input args need no code
 +	case ssa.OpAMD64LoweredGetClosurePtr:
 +		// Output is hardwired to DX only,
 +		// and DX contains the closure pointer on
 +		// closure entry, and this "instruction"
 +		// is scheduled to the very beginning
 +		// of the entry block.
 +	case ssa.OpAMD64LoweredGetG:
 +		r := regnum(v)
 +		// See the comments in cmd/internal/obj/x86/obj6.go
 +		// near CanUse1InsnTLS for a detailed explanation of these instructions.
 +		if x86.CanUse1InsnTLS(Ctxt) {
 +			// MOVQ (TLS), r
 +			p := Prog(x86.AMOVQ)
 +			p.From.Type = obj.TYPE_MEM
 +			p.From.Reg = x86.REG_TLS
 +			p.To.Type = obj.TYPE_REG
 +			p.To.Reg = r
 +		} else {
 +			// MOVQ TLS, r
 +			// MOVQ (r)(TLS*1), r
 +			p := Prog(x86.AMOVQ)
 +			p.From.Type = obj.TYPE_REG
 +			p.From.Reg = x86.REG_TLS
 +			p.To.Type = obj.TYPE_REG
 +			p.To.Reg = r
 +			q := Prog(x86.AMOVQ)
 +			q.From.Type = obj.TYPE_MEM
 +			q.From.Reg = r
 +			q.From.Index = x86.REG_TLS
 +			q.From.Scale = 1
 +			q.To.Type = obj.TYPE_REG
 +			q.To.Reg = r
 +		}
 +	case ssa.OpAMD64CALLstatic:
 +		p := Prog(obj.ACALL)
 +		p.To.Type = obj.TYPE_MEM
 +		p.To.Name = obj.NAME_EXTERN
 +		p.To.Sym = Linksym(v.Aux.(*Sym))
 +		if Maxarg < v.AuxInt {
 +			Maxarg = v.AuxInt
 +		}
 +	case ssa.OpAMD64CALLclosure:
 +		p := Prog(obj.ACALL)
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = regnum(v.Args[0])
 +		if Maxarg < v.AuxInt {
 +			Maxarg = v.AuxInt
 +		}
 +	case ssa.OpAMD64CALLdefer:
 +		p := Prog(obj.ACALL)
 +		p.To.Type = obj.TYPE_MEM
 +		p.To.Name = obj.NAME_EXTERN
 +		p.To.Sym = Linksym(Deferproc.Sym)
 +		if Maxarg < v.AuxInt {
 +			Maxarg = v.AuxInt
 +		}
 +		// defer returns in rax:
 +		// 0 if we should continue executing
 +		// 1 if we should jump to deferreturn call
 +		p = Prog(x86.ATESTL)
 +		p.From.Type = obj.TYPE_REG
 +		p.From.Reg = x86.REG_AX
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = x86.REG_AX
 +		p = Prog(x86.AJNE)
 +		p.To.Type = obj.TYPE_BRANCH
 +		s.deferBranches = append(s.deferBranches, p)
 +	case ssa.OpAMD64CALLgo:
 +		p := Prog(obj.ACALL)
 +		p.To.Type = obj.TYPE_MEM
 +		p.To.Name = obj.NAME_EXTERN
 +		p.To.Sym = Linksym(Newproc.Sym)
 +		if Maxarg < v.AuxInt {
 +			Maxarg = v.AuxInt
 +		}
 +	case ssa.OpAMD64CALLinter:
 +		p := Prog(obj.ACALL)
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = regnum(v.Args[0])
 +		if Maxarg < v.AuxInt {
 +			Maxarg = v.AuxInt
 +		}
 +	case ssa.OpAMD64NEGQ, ssa.OpAMD64NEGL, ssa.OpAMD64NEGW, ssa.OpAMD64NEGB,
 +		ssa.OpAMD64NOTQ, ssa.OpAMD64NOTL, ssa.OpAMD64NOTW, ssa.OpAMD64NOTB:
 +		x := regnum(v.Args[0])
 +		r := regnum(v)
 +		if x != r {
 +			p := Prog(moveByType(v.Type))
 +			p.From.Type = obj.TYPE_REG
 +			p.From.Reg = x
 +			p.To.Type = obj.TYPE_REG
 +			p.To.Reg = r
 +		}
 +		p := Prog(v.Op.Asm())
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = r
 +	case ssa.OpAMD64SQRTSD:
 +		p := Prog(v.Op.Asm())
 +		p.From.Type = obj.TYPE_REG
 +		p.From.Reg = regnum(v.Args[0])
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = regnum(v)
 +	case ssa.OpSP, ssa.OpSB:
 +		// nothing to do
 +	case ssa.OpAMD64SETEQ, ssa.OpAMD64SETNE,
 +		ssa.OpAMD64SETL, ssa.OpAMD64SETLE,
 +		ssa.OpAMD64SETG, ssa.OpAMD64SETGE,
 +		ssa.OpAMD64SETGF, ssa.OpAMD64SETGEF,
 +		ssa.OpAMD64SETB, ssa.OpAMD64SETBE,
 +		ssa.OpAMD64SETORD, ssa.OpAMD64SETNAN,
 +		ssa.OpAMD64SETA, ssa.OpAMD64SETAE:
 +		p := Prog(v.Op.Asm())
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = regnum(v)
 +
 +	case ssa.OpAMD64SETNEF:
 +		p := Prog(v.Op.Asm())
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = regnum(v)
 +		q := Prog(x86.ASETPS)
 +		q.To.Type = obj.TYPE_REG
 +		q.To.Reg = x86.REG_AX
 +		// TODO AORQ copied from old code generator, why not AORB?
 +		opregreg(x86.AORQ, regnum(v), x86.REG_AX)
 +
 +	case ssa.OpAMD64SETEQF:
 +		p := Prog(v.Op.Asm())
 +		p.To.Type = obj.TYPE_REG
 +		p.To.Reg = regnum(v)
 +		q := Prog(x86.ASETPC)
 +		q.To.Type = obj.TYPE_REG
 +		q.To.Reg = x86.REG_AX
 +		// TODO AANDQ copied from old code generator, why not AANDB?
 +		opregreg(x86.AANDQ, regnum(v), x86.REG_AX)
 +
 +	case ssa.OpAMD64InvertFlags:
 +		v.Fatalf("InvertFlags should never make it to codegen %v", v)
 +	case ssa.OpAMD64FlagEQ, ssa.OpAMD64FlagLT_ULT, ssa.OpAMD64FlagLT_UGT, ssa.OpAMD64FlagGT_ULT, ssa.OpAMD64FlagGT_UGT:
 +		v.Fatalf("Flag* ops should never make it to codegen %v", v)
 +	case ssa.OpAMD64REPSTOSQ:
 +		Prog(x86.AREP)
 +		Prog(x86.ASTOSQ)
 +	case ssa.OpAMD64REPMOVSQ:
 +		Prog(x86.AREP)
 +		Prog(x86.AMOVSQ)
 +	case ssa.OpVarDef:
 +		Gvardef(v.Aux.(*Node))
 +	case ssa.OpVarKill:
 +		gvarkill(v.Aux.(*Node))
++	case ssa.OpVarLive:
++		gvarlive(v.Aux.(*Node))
 +	case ssa.OpAMD64LoweredNilCheck:
 +		// Optimization - if the subsequent block has a load or store
 +		// at the same address, we don't need to issue this instruction.
 +		for _, w := range v.Block.Succs[0].Values {
 +			if len(w.Args) == 0 || !w.Args[len(w.Args)-1].Type.IsMemory() {
 +				// w doesn't use a store - can't be a memory op.
 +				continue
 +			}
 +			if w.Args[len(w.Args)-1] != v.Args[1] {
 +				v.Fatalf("wrong store after nilcheck v=%s w=%s", v, w)
 +			}
 +			switch w.Op {
 +			case ssa.OpAMD64MOVQload, ssa.OpAMD64MOVLload, ssa.OpAMD64MOVWload, ssa.OpAMD64MOVBload,
 +				ssa.OpAMD64MOVQstore, ssa.OpAMD64MOVLstore, ssa.OpAMD64MOVWstore, ssa.OpAMD64MOVBstore:
 +				if w.Args[0] == v.Args[0] && w.Aux == nil && w.AuxInt >= 0 && w.AuxInt < minZeroPage {
 +					return
 +				}
 +			case ssa.OpAMD64MOVQstoreconst, ssa.OpAMD64MOVLstoreconst, ssa.OpAMD64MOVWstoreconst, ssa.OpAMD64MOVBstoreconst:
 +				off := ssa.StoreConst(v.AuxInt).Off()
 +				if w.Args[0] == v.Args[0] && w.Aux == nil && off >= 0 && off < minZeroPage {
 +					return
 +				}
 +			}
 +			if w.Type.IsMemory() {
 +				// We can't delay the nil check past the next store.
 +				break
 +			}
 +		}
 +		// Issue a load which will fault if the input is nil.
 +		// TODO: We currently use the 2-byte instruction TESTB AX, (reg).
 +		// Should we use the 3-byte TESTB $0, (reg) instead?  It is larger
 +		// but it doesn't have false dependency on AX.
 +		// Or maybe allocate an output register and use MOVL (reg),reg2 ?
 +		// That trades clobbering flags for clobbering a register.
 +		p := Prog(x86.ATESTB)
 +		p.From.Type = obj.TYPE_REG
 +		p.From.Reg = x86.REG_AX
 +		p.To.Type = obj.TYPE_MEM
 +		p.To.Reg = regnum(v.Args[0])
 +		addAux(&p.To, v)
 +		if Debug_checknil != 0 && v.Line > 1 { // v.Line==1 in generated wrappers
 +			Warnl(int(v.Line), "generated nil check")
 +		}
 +	default:
 +		v.Unimplementedf("genValue not implemented: %s", v.LongString())
 +	}
 +}
 +
 +// movZero generates a register indirect move with a 0 immediate and keeps track of bytes left and next offset
 +func movZero(as int, width int64, nbytes int64, offset int64, regnum int16) (nleft int64, noff int64) {
 +	p := Prog(as)
 +	// TODO: use zero register on archs that support it.
 +	p.From.Type = obj.TYPE_CONST
 +	p.From.Offset = 0
 +	p.To.Type = obj.TYPE_MEM
 +	p.To.Reg = regnum
 +	p.To.Offset = offset
 +	offset += width
 +	nleft = nbytes - width
 +	return nleft, offset
 +}
 +
 +var blockJump = [...]struct {
 +	asm, invasm int
 +}{
 +	ssa.BlockAMD64EQ:  {x86.AJEQ, x86.AJNE},
 +	ssa.BlockAMD64NE:  {x86.AJNE, x86.AJEQ},
 +	ssa.BlockAMD64LT:  {x86.AJLT, x86.AJGE},
 +	ssa.BlockAMD64GE:  {x86.AJGE, x86.AJLT},
 +	ssa.BlockAMD64LE:  {x86.AJLE, x86.AJGT},
 +	ssa.BlockAMD64GT:  {x86.AJGT, x86.AJLE},
 +	ssa.BlockAMD64ULT: {x86.AJCS, x86.AJCC},
 +	ssa.BlockAMD64UGE: {x86.AJCC, x86.AJCS},
 +	ssa.BlockAMD64UGT: {x86.AJHI, x86.AJLS},
 +	ssa.BlockAMD64ULE: {x86.AJLS, x86.AJHI},
 +	ssa.BlockAMD64ORD: {x86.AJPC, x86.AJPS},
 +	ssa.BlockAMD64NAN: {x86.AJPS, x86.AJPC},
 +}
 +
 +type floatingEQNEJump struct {
 +	jump, index int
 +}
 +
 +var eqfJumps = [2][2]floatingEQNEJump{
 +	{{x86.AJNE, 1}, {x86.AJPS, 1}}, // next == b.Succs[0]
 +	{{x86.AJNE, 1}, {x86.AJPC, 0}}, // next == b.Succs[1]
 +}
 +var nefJumps = [2][2]floatingEQNEJump{
 +	{{x86.AJNE, 0}, {x86.AJPC, 1}}, // next == b.Succs[0]
 +	{{x86.AJNE, 0}, {x86.AJPS, 0}}, // next == b.Succs[1]
 +}
 +
 +func oneFPJump(b *ssa.Block, jumps *floatingEQNEJump, likely ssa.BranchPrediction, branches []branch) []branch {
 +	p := Prog(jumps.jump)
 +	p.To.Type = obj.TYPE_BRANCH
 +	to := jumps.index
 +	branches = append(branches, branch{p, b.Succs[to]})
 +	if to == 1 {
 +		likely = -likely
 +	}
 +	// liblink reorders the instruction stream as it sees fit.
 +	// Pass along what we know so liblink can make use of it.
 +	// TODO: Once we've fully switched to SSA,
 +	// make liblink leave our output alone.
 +	switch likely {
 +	case ssa.BranchUnlikely:
 +		p.From.Type = obj.TYPE_CONST
 +		p.From.Offset = 0
 +	case ssa.BranchLikely:
 +		p.From.Type = obj.TYPE_CONST
 +		p.From.Offset = 1
 +	}
 +	return branches
 +}
 +
 +func genFPJump(s *genState, b, next *ssa.Block, jumps *[2][2]floatingEQNEJump) {
 +	likely := b.Likely
 +	switch next {
 +	case b.Succs[0]:
 +		s.branches = oneFPJump(b, &jumps[0][0], likely, s.branches)
 +		s.branches = oneFPJump(b, &jumps[0][1], likely, s.branches)
 +	case b.Succs[1]:
 +		s.branches = oneFPJump(b, &jumps[1][0], likely, s.branches)
 +		s.branches = oneFPJump(b, &jumps[1][1], likely, s.branches)
 +	default:
 +		s.branches = oneFPJump(b, &jumps[1][0], likely, s.branches)
 +		s.branches = oneFPJump(b, &jumps[1][1], likely, s.branches)
 +		q := Prog(obj.AJMP)
 +		q.To.Type = obj.TYPE_BRANCH
 +		s.branches = append(s.branches, branch{q, b.Succs[1]})
 +	}
 +}
 +
 +func (s *genState) genBlock(b, next *ssa.Block) {
 +	lineno = b.Line
 +
 +	switch b.Kind {
 +	case ssa.BlockPlain, ssa.BlockCall, ssa.BlockCheck:
 +		if b.Succs[0] != next {
 +			p := Prog(obj.AJMP)
 +			p.To.Type = obj.TYPE_BRANCH
 +			s.branches = append(s.branches, branch{p, b.Succs[0]})
 +		}
 +	case ssa.BlockExit:
 +		Prog(obj.AUNDEF) // tell plive.go that we never reach here
 +	case ssa.BlockRet:
 +		if hasdefer {
 +			s.deferReturn()
 +		}
 +		Prog(obj.ARET)
 +	case ssa.BlockRetJmp:
 +		p := Prog(obj.AJMP)
 +		p.To.Type = obj.TYPE_MEM
 +		p.To.Name = obj.NAME_EXTERN
 +		p.To.Sym = Linksym(b.Aux.(*Sym))
 +
 +	case ssa.BlockAMD64EQF:
 +		genFPJump(s, b, next, &eqfJumps)
 +
 +	case ssa.BlockAMD64NEF:
 +		genFPJump(s, b, next, &nefJumps)
 +
 +	case ssa.BlockAMD64EQ, ssa.BlockAMD64NE,
 +		ssa.BlockAMD64LT, ssa.BlockAMD64GE,
 +		ssa.BlockAMD64LE, ssa.BlockAMD64GT,
 +		ssa.BlockAMD64ULT, ssa.BlockAMD64UGT,
 +		ssa.BlockAMD64ULE, ssa.BlockAMD64UGE:
 +		jmp := blockJump[b.Kind]
 +		likely := b.Likely
 +		var p *obj.Prog
 +		switch next {
 +		case b.Succs[0]:
 +			p = Prog(jmp.invasm)
 +			likely *= -1
 +			p.To.Type = obj.TYPE_BRANCH
 +			s.branches = append(s.branches, branch{p, b.Succs[1]})
 +		case b.Succs[1]:
 +			p = Prog(jmp.asm)
 +			p.To.Type = obj.TYPE_BRANCH
 +			s.branches = append(s.branches, branch{p, b.Succs[0]})
 +		default:
 +			p = Prog(jmp.asm)
 +			p.To.Type = obj.TYPE_BRANCH
 +			s.branches = append(s.branches, branch{p, b.Succs[0]})
 +			q := Prog(obj.AJMP)
 +			q.To.Type = obj.TYPE_BRANCH
 +			s.branches = append(s.branches, branch{q, b.Succs[1]})
 +		}
 +
 +		// liblink reorders the instruction stream as it sees fit.
 +		// Pass along what we know so liblink can make use of it.
 +		// TODO: Once we've fully switched to SSA,
 +		// make liblink leave our output alone.
 +		switch likely {
 +		case ssa.BranchUnlikely:
 +			p.From.Type = obj.TYPE_CONST
 +			p.From.Offset = 0
 +		case ssa.BranchLikely:
 +			p.From.Type = obj.TYPE_CONST
 +			p.From.Offset = 1
 +		}
 +
 +	default:
 +		b.Unimplementedf("branch not implemented: %s. Control: %s", b.LongString(), b.Control.LongString())
 +	}
 +}
 +
 +func (s *genState) deferReturn() {
 +	// Deferred calls will appear to be returning to
 +	// the CALL deferreturn(SB) that we are about to emit.
 +	// However, the stack trace code will show the line
 +	// of the instruction byte before the return PC.
 +	// To avoid that being an unrelated instruction,
 +	// insert an actual hardware NOP that will have the right line number.
 +	// This is different from obj.ANOP, which is a virtual no-op
 +	// that doesn't make it into the instruction stream.
 +	s.deferTarget = Pc
 +	Thearch.Ginsnop()
 +	p := Prog(obj.ACALL)
 +	p.To.Type = obj.TYPE_MEM
 +	p.To.Name = obj.NAME_EXTERN
 +	p.To.Sym = Linksym(Deferreturn.Sym)
 +}
 +
 +// addAux adds the offset in the aux fields (AuxInt and Aux) of v to a.
 +func addAux(a *obj.Addr, v *ssa.Value) {
 +	addAux2(a, v, v.AuxInt)
 +}
 +func addAux2(a *obj.Addr, v *ssa.Value, offset int64) {
 +	if a.Type != obj.TYPE_MEM {
 +		v.Fatalf("bad addAux addr %s", a)
 +	}
 +	// add integer offset
 +	a.Offset += offset
 +
 +	// If no additional symbol offset, we're done.
 +	if v.Aux == nil {
 +		return
 +	}
 +	// Add symbol's offset from its base register.
 +	switch sym := v.Aux.(type) {
 +	case *ssa.ExternSymbol:
 +		a.Name = obj.NAME_EXTERN
 +		a.Sym = Linksym(sym.Sym.(*Sym))
 +	case *ssa.ArgSymbol:
 +		n := sym.Node.(*Node)
 +		a.Name = obj.NAME_PARAM
 +		a.Node = n
 +		a.Sym = Linksym(n.Orig.Sym)
 +		a.Offset += n.Xoffset // TODO: why do I have to add this here?  I don't for auto variables.
 +	case *ssa.AutoSymbol:
 +		n := sym.Node.(*Node)
 +		a.Name = obj.NAME_AUTO
 +		a.Node = n
 +		a.Sym = Linksym(n.Sym)
 +	default:
 +		v.Fatalf("aux in %s not implemented %#v", v, v.Aux)
 +	}
 +}
 +
 +// extendIndex extends v to a full int width.
 +func (s *state) extendIndex(v *ssa.Value) *ssa.Value {
 +	size := v.Type.Size()
 +	if size == s.config.IntSize {
 +		return v
 +	}
 +	if size > s.config.IntSize {
 +		// TODO: truncate 64-bit indexes on 32-bit pointer archs.  We'd need to test
 +		// the high word and branch to out-of-bounds failure if it is not 0.
 +		s.Unimplementedf("64->32 index truncation not implemented")
 +		return v
 +	}
 +
 +	// Extend value to the required size
 +	var op ssa.Op
 +	if v.Type.IsSigned() {
 +		switch 10*size + s.config.IntSize {
 +		case 14:
 +			op = ssa.OpSignExt8to32
 +		case 18:
 +			op = ssa.OpSignExt8to64
 +		case 24:
 +			op = ssa.OpSignExt16to32
 +		case 28:
 +			op = ssa.OpSignExt16to64
 +		case 48:
 +			op = ssa.OpSignExt32to64
 +		default:
 +			s.Fatalf("bad signed index extension %s", v.Type)
 +		}
 +	} else {
 +		switch 10*size + s.config.IntSize {
 +		case 14:
 +			op = ssa.OpZeroExt8to32
 +		case 18:
 +			op = ssa.OpZeroExt8to64
 +		case 24:
 +			op = ssa.OpZeroExt16to32
 +		case 28:
 +			op = ssa.OpZeroExt16to64
 +		case 48:
 +			op = ssa.OpZeroExt32to64
 +		default:
 +			s.Fatalf("bad unsigned index extension %s", v.Type)
 +		}
 +	}
 +	return s.newValue1(op, Types[TINT], v)
 +}
 +
 +// ssaRegToReg maps ssa register numbers to obj register numbers.
 +var ssaRegToReg = [...]int16{
 +	x86.REG_AX,
 +	x86.REG_CX,
 +	x86.REG_DX,
 +	x86.REG_BX,
 +	x86.REG_SP,
 +	x86.REG_BP,
 +	x86.REG_SI,
 +	x86.REG_DI,
 +	x86.REG_R8,
 +	x86.REG_R9,
 +	x86.REG_R10,
 +	x86.REG_R11,
 +	x86.REG_R12,
 +	x86.REG_R13,
 +	x86.REG_R14,
 +	x86.REG_R15,
 +	x86.REG_X0,
 +	x86.REG_X1,
 +	x86.REG_X2,
 +	x86.REG_X3,
 +	x86.REG_X4,
 +	x86.REG_X5,
 +	x86.REG_X6,
 +	x86.REG_X7,
 +	x86.REG_X8,
 +	x86.REG_X9,
 +	x86.REG_X10,
 +	x86.REG_X11,
 +	x86.REG_X12,
 +	x86.REG_X13,
 +	x86.REG_X14,
 +	x86.REG_X15,
 +	0, // SB isn't a real register.  We fill an Addr.Reg field with 0 in this case.
 +	// TODO: arch-dependent
 +}
 +
 +// loadByType returns the load instruction of the given type.
 +func loadByType(t ssa.Type) int {
 +	// For x86, there's no difference between load and store opcodes.
 +	return storeByType(t)
 +}
 +
 +// storeByType returns the store instruction of the given type.
 +func storeByType(t ssa.Type) int {
 +	width := t.Size()
 +	if t.IsFloat() {
 +		switch width {
 +		case 4:
 +			return x86.AMOVSS
 +		case 8:
 +			return x86.AMOVSD
 +		}
 +	} else {
 +		switch width {
 +		case 1:
 +			return x86.AMOVB
 +		case 2:
 +			return x86.AMOVW
 +		case 4:
 +			return x86.AMOVL
 +		case 8:
 +			return x86.AMOVQ
 +		}
 +	}
 +	panic("bad store type")
 +}
 +
 +// moveByType returns the reg->reg move instruction of the given type.
 +func moveByType(t ssa.Type) int {
 +	if t.IsFloat() {
 +		// Moving the whole sse2 register is faster
 +		// than moving just the correct low portion of it.
 +		return x86.AMOVAPD
 +	} else {
 +		switch t.Size() {
 +		case 1:
 +			return x86.AMOVB
 +		case 2:
 +			return x86.AMOVW
 +		case 4:
 +			return x86.AMOVL
 +		case 8:
 +			return x86.AMOVQ
 +		default:
 +			panic("bad int register width")
 +		}
 +	}
 +	panic("bad register type")
 +}
 +
 +// regnum returns the register (in cmd/internal/obj numbering) to
 +// which v has been allocated.  Panics if v is not assigned to a
 +// register.
 +// TODO: Make this panic again once it stops happening routinely.
 +func regnum(v *ssa.Value) int16 {
 +	reg := v.Block.Func.RegAlloc[v.ID]
 +	if reg == nil {
 +		v.Unimplementedf("nil regnum for value: %s\n%s\n", v.LongString(), v.Block.Func)
 +		return 0
 +	}
 +	return ssaRegToReg[reg.(*ssa.Register).Num]
 +}
 +
 +// autoVar returns a *Node and int64 representing the auto variable and offset within it
 +// where v should be spilled.
 +func autoVar(v *ssa.Value) (*Node, int64) {
 +	loc := v.Block.Func.RegAlloc[v.ID].(ssa.LocalSlot)
 +	if v.Type.Size() > loc.Type.Size() {
 +		v.Fatalf("spill/restore type %s doesn't fit in slot type %s", v.Type, loc.Type)
 +	}
 +	return loc.N.(*Node), loc.Off
 +}
 +
 +// ssaExport exports a bunch of compiler services for the ssa backend.
 +type ssaExport struct {
 +	log           bool
 +	unimplemented bool
 +	mustImplement bool
 +}
 +
 +func (s *ssaExport) TypeBool() ssa.Type    { return Types[TBOOL] }
 +func (s *ssaExport) TypeInt8() ssa.Type    { return Types[TINT8] }
 +func (s *ssaExport) TypeInt16() ssa.Type   { return Types[TINT16] }
 +func (s *ssaExport) TypeInt32() ssa.Type   { return Types[TINT32] }
 +func (s *ssaExport) TypeInt64() ssa.Type   { return Types[TINT64] }
 +func (s *ssaExport) TypeUInt8() ssa.Type   { return Types[TUINT8] }
 +func (s *ssaExport) TypeUInt16() ssa.Type  { return Types[TUINT16] }
 +func (s *ssaExport) TypeUInt32() ssa.Type  { return Types[TUINT32] }
 +func (s *ssaExport) TypeUInt64() ssa.Type  { return Types[TUINT64] }
 +func (s *ssaExport) TypeFloat32() ssa.Type { return Types[TFLOAT32] }
 +func (s *ssaExport) TypeFloat64() ssa.Type { return Types[TFLOAT64] }
 +func (s *ssaExport) TypeInt() ssa.Type     { return Types[TINT] }
 +func (s *ssaExport) TypeUintptr() ssa.Type { return Types[TUINTPTR] }
 +func (s *ssaExport) TypeString() ssa.Type  { return Types[TSTRING] }
 +func (s *ssaExport) TypeBytePtr() ssa.Type { return Ptrto(Types[TUINT8]) }
 +
 +// StringData returns a symbol (a *Sym wrapped in an interface) which
 +// is the data component of a global string constant containing s.
 +func (*ssaExport) StringData(s string) interface{} {
 +	// TODO: is idealstring correct?  It might not matter...
 +	_, data := stringsym(s)
 +	return &ssa.ExternSymbol{Typ: idealstring, Sym: data}
 +}
 +
 +func (e *ssaExport) Auto(t ssa.Type) ssa.GCNode {
 +	n := temp(t.(*Type))   // Note: adds new auto to Curfn.Func.Dcl list
 +	e.mustImplement = true // This modifies the input to SSA, so we want to make sure we succeed from here!
 +	return n
 +}
 +
 +func (e *ssaExport) CanSSA(t ssa.Type) bool {
 +	return canSSAType(t.(*Type))
 +}
 +
 +// Log logs a message from the compiler.
 +func (e *ssaExport) Logf(msg string, args ...interface{}) {
 +	// If e was marked as unimplemented, anything could happen. Ignore.
 +	if e.log && !e.unimplemented {
 +		fmt.Printf(msg, args...)
 +	}
 +}
 +
 +// Fatal reports a compiler error and exits.
 +func (e *ssaExport) Fatalf(line int32, msg string, args ...interface{}) {
 +	// If e was marked as unimplemented, anything could happen. Ignore.
 +	if !e.unimplemented {
 +		lineno = line
 +		Fatalf(msg, args...)
 +	}
 +}
 +
 +// Unimplemented reports that the function cannot be compiled.
 +// It will be removed once SSA work is complete.
 +func (e *ssaExport) Unimplementedf(line int32, msg string, args ...interface{}) {
 +	if e.mustImplement {
 +		lineno = line
 +		Fatalf(msg, args...)
 +	}
 +	const alwaysLog = false // enable to calculate top unimplemented features
 +	if !e.unimplemented && (e.log || alwaysLog) {
 +		// first implementation failure, print explanation
 +		fmt.Printf("SSA unimplemented: "+msg+"\n", args...)
 +	}
 +	e.unimplemented = true
 +}
 +
 +// Warnl reports a "warning", which is usually flag-triggered
 +// logging output for the benefit of tests.
 +func (e *ssaExport) Warnl(line int, fmt_ string, args ...interface{}) {
 +	Warnl(line, fmt_, args...)
 +}
 +
 +func (e *ssaExport) Debug_checknil() bool {
 +	return Debug_checknil != 0
 +}
 +
 +func (n *Node) Typ() ssa.Type {
 +	return n.Type
 +}
diff --cc src/cmd/compile/internal/ssa/gen/genericOps.go
index e57dd932d8,0000000000..d17f558978
mode 100644,000000..100644
--- a/src/cmd/compile/internal/ssa/gen/genericOps.go
+++ b/src/cmd/compile/internal/ssa/gen/genericOps.go
@@@ -1,405 -1,0 +1,406 @@@
 +// Copyright 2015 The Go Authors. All rights reserved.
 +// Use of this source code is governed by a BSD-style
 +// license that can be found in the LICENSE file.
 +
 +package main
 +
 +var genericOps = []opData{
 +	// 2-input arithmetic
 +	// Types must be consistent with Go typing.  Add, for example, must take two values
 +	// of the same type and produces that same type.
 +	{name: "Add8"}, // arg0 + arg1
 +	{name: "Add16"},
 +	{name: "Add32"},
 +	{name: "Add64"},
 +	{name: "AddPtr"}, // For address calculations.  arg0 is a pointer and arg1 is an int.
 +	{name: "Add32F"},
 +	{name: "Add64F"},
 +	// TODO: Add64C, Add128C
 +
 +	{name: "Sub8"}, // arg0 - arg1
 +	{name: "Sub16"},
 +	{name: "Sub32"},
 +	{name: "Sub64"},
 +	{name: "SubPtr"},
 +	{name: "Sub32F"},
 +	{name: "Sub64F"},
 +
 +	{name: "Mul8"}, // arg0 * arg1
 +	{name: "Mul16"},
 +	{name: "Mul32"},
 +	{name: "Mul64"},
 +	{name: "Mul32F"},
 +	{name: "Mul64F"},
 +
 +	{name: "Div32F"}, // arg0 / arg1
 +	{name: "Div64F"},
 +
 +	{name: "Hmul8"}, // (arg0 * arg1) >> width
 +	{name: "Hmul8u"},
 +	{name: "Hmul16"},
 +	{name: "Hmul16u"},
 +	{name: "Hmul32"},
 +	{name: "Hmul32u"},
 +	// frontend currently doesn't generate a 64 bit hmul
 +
 +	{name: "Div8"}, // arg0 / arg1
 +	{name: "Div8u"},
 +	{name: "Div16"},
 +	{name: "Div16u"},
 +	{name: "Div32"},
 +	{name: "Div32u"},
 +	{name: "Div64"},
 +	{name: "Div64u"},
 +
 +	{name: "Mod8"}, // arg0 % arg1
 +	{name: "Mod8u"},
 +	{name: "Mod16"},
 +	{name: "Mod16u"},
 +	{name: "Mod32"},
 +	{name: "Mod32u"},
 +	{name: "Mod64"},
 +	{name: "Mod64u"},
 +
 +	{name: "And8"}, // arg0 & arg1
 +	{name: "And16"},
 +	{name: "And32"},
 +	{name: "And64"},
 +
 +	{name: "Or8"}, // arg0 | arg1
 +	{name: "Or16"},
 +	{name: "Or32"},
 +	{name: "Or64"},
 +
 +	{name: "Xor8"}, // arg0 ^ arg1
 +	{name: "Xor16"},
 +	{name: "Xor32"},
 +	{name: "Xor64"},
 +
 +	// For shifts, AxB means the shifted value has A bits and the shift amount has B bits.
 +	{name: "Lsh8x8"}, // arg0 << arg1
 +	{name: "Lsh8x16"},
 +	{name: "Lsh8x32"},
 +	{name: "Lsh8x64"},
 +	{name: "Lsh16x8"},
 +	{name: "Lsh16x16"},
 +	{name: "Lsh16x32"},
 +	{name: "Lsh16x64"},
 +	{name: "Lsh32x8"},
 +	{name: "Lsh32x16"},
 +	{name: "Lsh32x32"},
 +	{name: "Lsh32x64"},
 +	{name: "Lsh64x8"},
 +	{name: "Lsh64x16"},
 +	{name: "Lsh64x32"},
 +	{name: "Lsh64x64"},
 +
 +	{name: "Rsh8x8"}, // arg0 >> arg1, signed
 +	{name: "Rsh8x16"},
 +	{name: "Rsh8x32"},
 +	{name: "Rsh8x64"},
 +	{name: "Rsh16x8"},
 +	{name: "Rsh16x16"},
 +	{name: "Rsh16x32"},
 +	{name: "Rsh16x64"},
 +	{name: "Rsh32x8"},
 +	{name: "Rsh32x16"},
 +	{name: "Rsh32x32"},
 +	{name: "Rsh32x64"},
 +	{name: "Rsh64x8"},
 +	{name: "Rsh64x16"},
 +	{name: "Rsh64x32"},
 +	{name: "Rsh64x64"},
 +
 +	{name: "Rsh8Ux8"}, // arg0 >> arg1, unsigned
 +	{name: "Rsh8Ux16"},
 +	{name: "Rsh8Ux32"},
 +	{name: "Rsh8Ux64"},
 +	{name: "Rsh16Ux8"},
 +	{name: "Rsh16Ux16"},
 +	{name: "Rsh16Ux32"},
 +	{name: "Rsh16Ux64"},
 +	{name: "Rsh32Ux8"},
 +	{name: "Rsh32Ux16"},
 +	{name: "Rsh32Ux32"},
 +	{name: "Rsh32Ux64"},
 +	{name: "Rsh64Ux8"},
 +	{name: "Rsh64Ux16"},
 +	{name: "Rsh64Ux32"},
 +	{name: "Rsh64Ux64"},
 +
 +	// (Left) rotates replace pattern matches in the front end
 +	// of (arg0 << arg1) ^ (arg0 >> (A-arg1))
 +	// where A is the bit width of arg0 and result.
 +	// Note that because rotates are pattern-matched from
 +	// shifts, that a rotate of arg1=A+k (k > 0) bits originated from
 +	//    (arg0 << A+k) ^ (arg0 >> -k) =
 +	//    0 ^ arg0>>huge_unsigned =
 +	//    0 ^ 0 = 0
 +	// which is not the same as a rotation by A+k
 +	//
 +	// However, in the specific case of k = 0, the result of
 +	// the shift idiom is the same as the result for the
 +	// rotate idiom, i.e., result=arg0.
 +	// This is different from shifts, where
 +	// arg0 << A is defined to be zero.
 +	//
 +	// Because of this, and also because the primary use case
 +	// for rotates is hashing and crypto code with constant
 +	// distance, rotate instructions are only substituted
 +	// when arg1 is a constant between 1 and A-1, inclusive.
 +	{name: "Lrot8"},
 +	{name: "Lrot16"},
 +	{name: "Lrot32"},
 +	{name: "Lrot64"},
 +
 +	// 2-input comparisons
 +	{name: "Eq8"}, // arg0 == arg1
 +	{name: "Eq16"},
 +	{name: "Eq32"},
 +	{name: "Eq64"},
 +	{name: "EqPtr"},
 +	{name: "EqInter"}, // arg0 or arg1 is nil; other cases handled by frontend
 +	{name: "EqSlice"}, // arg0 or arg1 is nil; other cases handled by frontend
 +	{name: "Eq32F"},
 +	{name: "Eq64F"},
 +
 +	{name: "Neq8"}, // arg0 != arg1
 +	{name: "Neq16"},
 +	{name: "Neq32"},
 +	{name: "Neq64"},
 +	{name: "NeqPtr"},
 +	{name: "NeqInter"}, // arg0 or arg1 is nil; other cases handled by frontend
 +	{name: "NeqSlice"}, // arg0 or arg1 is nil; other cases handled by frontend
 +	{name: "Neq32F"},
 +	{name: "Neq64F"},
 +
 +	{name: "Less8"}, // arg0 < arg1
 +	{name: "Less8U"},
 +	{name: "Less16"},
 +	{name: "Less16U"},
 +	{name: "Less32"},
 +	{name: "Less32U"},
 +	{name: "Less64"},
 +	{name: "Less64U"},
 +	{name: "Less32F"},
 +	{name: "Less64F"},
 +
 +	{name: "Leq8"}, // arg0 <= arg1
 +	{name: "Leq8U"},
 +	{name: "Leq16"},
 +	{name: "Leq16U"},
 +	{name: "Leq32"},
 +	{name: "Leq32U"},
 +	{name: "Leq64"},
 +	{name: "Leq64U"},
 +	{name: "Leq32F"},
 +	{name: "Leq64F"},
 +
 +	{name: "Greater8"}, // arg0 > arg1
 +	{name: "Greater8U"},
 +	{name: "Greater16"},
 +	{name: "Greater16U"},
 +	{name: "Greater32"},
 +	{name: "Greater32U"},
 +	{name: "Greater64"},
 +	{name: "Greater64U"},
 +	{name: "Greater32F"},
 +	{name: "Greater64F"},
 +
 +	{name: "Geq8"}, // arg0 <= arg1
 +	{name: "Geq8U"},
 +	{name: "Geq16"},
 +	{name: "Geq16U"},
 +	{name: "Geq32"},
 +	{name: "Geq32U"},
 +	{name: "Geq64"},
 +	{name: "Geq64U"},
 +	{name: "Geq32F"},
 +	{name: "Geq64F"},
 +
 +	// 1-input ops
 +	{name: "Not"}, // !arg0
 +
 +	{name: "Neg8"}, // -arg0
 +	{name: "Neg16"},
 +	{name: "Neg32"},
 +	{name: "Neg64"},
 +	{name: "Neg32F"},
 +	{name: "Neg64F"},
 +
 +	{name: "Com8"}, // ^arg0
 +	{name: "Com16"},
 +	{name: "Com32"},
 +	{name: "Com64"},
 +
 +	{name: "Sqrt"}, // sqrt(arg0), float64 only
 +
 +	// Data movement
 +	{name: "Phi"},  // select an argument based on which predecessor block we came from
 +	{name: "Copy"}, // output = arg0
 +	// Convert converts between pointers and integers.
 +	// We have a special op for this so as to not confuse GC
 +	// (particularly stack maps).  It takes a memory arg so it
 +	// gets correctly ordered with respect to GC safepoints.
 +	// arg0=ptr/int arg1=mem, output=int/ptr
 +	{name: "Convert"},
 +
 +	// constants.  Constant values are stored in the aux field.
 +	// booleans have a bool aux field, strings have a string aux
 +	// field, and so on.  All integer types store their value
 +	// in the AuxInt field as an int64 (including int, uint64, etc.).
 +	// For integer types smaller than 64 bits, only the low-order
 +	// bits of the AuxInt field matter.
 +	{name: "ConstBool"},
 +	{name: "ConstString"},
 +	{name: "ConstNil", typ: "BytePtr"},
 +	{name: "Const8"},
 +	{name: "Const16"},
 +	{name: "Const32"},
 +	{name: "Const64"},
 +	{name: "Const32F"},
 +	{name: "Const64F"},
 +	{name: "ConstInterface"}, // nil interface
 +	{name: "ConstSlice"},     // nil slice
 +	// TODO: Const32F, ...
 +
 +	// Constant-like things
 +	{name: "InitMem"}, // memory input to the function.
 +	{name: "Arg"},     // argument to the function.  aux=GCNode of arg, off = offset in that arg.
 +
 +	// The address of a variable.  arg0 is the base pointer (SB or SP, depending
 +	// on whether it is a global or stack variable).  The Aux field identifies the
 +	// variable.  It will be either an *ExternSymbol (with arg0=SB), *ArgSymbol (arg0=SP),
 +	// or *AutoSymbol (arg0=SP).
 +	{name: "Addr"}, // Address of a variable.  Arg0=SP or SB.  Aux identifies the variable.
 +
 +	{name: "SP"},                 // stack pointer
 +	{name: "SB", typ: "Uintptr"}, // static base pointer (a.k.a. globals pointer)
 +	{name: "Func"},               // entry address of a function
 +
 +	// Memory operations
 +	{name: "Load"},              // Load from arg0.  arg1=memory
 +	{name: "Store", typ: "Mem"}, // Store arg1 to arg0.  arg2=memory, auxint=size.  Returns memory.
 +	{name: "Move"},              // arg0=destptr, arg1=srcptr, arg2=mem, auxint=size.  Returns memory.
 +	{name: "Zero"},              // arg0=destptr, arg1=mem, auxint=size. Returns memory.
 +
 +	// Function calls.  Arguments to the call have already been written to the stack.
 +	// Return values appear on the stack.  The method receiver, if any, is treated
 +	// as a phantom first argument.
 +	{name: "ClosureCall"}, // arg0=code pointer, arg1=context ptr, arg2=memory.  auxint=arg size.  Returns memory.
 +	{name: "StaticCall"},  // call function aux.(*gc.Sym), arg0=memory.  auxint=arg size.  Returns memory.
 +	{name: "DeferCall"},   // defer call.  arg0=memory, auxint=arg size.  Returns memory.
 +	{name: "GoCall"},      // go call.  arg0=memory, auxint=arg size.  Returns memory.
 +	{name: "InterCall"},   // interface call.  arg0=code pointer, arg1=memory, auxint=arg size.  Returns memory.
 +
 +	// Conversions: signed extensions, zero (unsigned) extensions, truncations
 +	{name: "SignExt8to16", typ: "Int16"},
 +	{name: "SignExt8to32"},
 +	{name: "SignExt8to64"},
 +	{name: "SignExt16to32"},
 +	{name: "SignExt16to64"},
 +	{name: "SignExt32to64"},
 +	{name: "ZeroExt8to16", typ: "UInt16"},
 +	{name: "ZeroExt8to32"},
 +	{name: "ZeroExt8to64"},
 +	{name: "ZeroExt16to32"},
 +	{name: "ZeroExt16to64"},
 +	{name: "ZeroExt32to64"},
 +	{name: "Trunc16to8"},
 +	{name: "Trunc32to8"},
 +	{name: "Trunc32to16"},
 +	{name: "Trunc64to8"},
 +	{name: "Trunc64to16"},
 +	{name: "Trunc64to32"},
 +
 +	{name: "Cvt32to32F"},
 +	{name: "Cvt32to64F"},
 +	{name: "Cvt64to32F"},
 +	{name: "Cvt64to64F"},
 +	{name: "Cvt32Fto32"},
 +	{name: "Cvt32Fto64"},
 +	{name: "Cvt64Fto32"},
 +	{name: "Cvt64Fto64"},
 +	{name: "Cvt32Fto64F"},
 +	{name: "Cvt64Fto32F"},
 +
 +	// Automatically inserted safety checks
 +	{name: "IsNonNil", typ: "Bool"},        // arg0 != nil
 +	{name: "IsInBounds", typ: "Bool"},      // 0 <= arg0 < arg1
 +	{name: "IsSliceInBounds", typ: "Bool"}, // 0 <= arg0 <= arg1
 +	{name: "NilCheck", typ: "Void"},        // arg0=ptr, arg1=mem.  Panics if arg0 is nil, returns void.
 +
 +	// Pseudo-ops
 +	{name: "GetG"},          // runtime.getg() (read g pointer).  arg0=mem
 +	{name: "GetClosurePtr"}, // get closure pointer from dedicated register
 +
 +	// Indexing operations
 +	{name: "ArrayIndex"},   // arg0=array, arg1=index.  Returns a[i]
 +	{name: "PtrIndex"},     // arg0=ptr, arg1=index. Computes ptr+sizeof(*v.type)*index, where index is extended to ptrwidth type
 +	{name: "OffPtr"},       // arg0 + auxint (arg0 and result are pointers)
 +	{name: "StructSelect"}, // arg0=struct, auxint=field offset.  Returns field at that offset (size=size of result type)
 +
 +	// Slices
 +	{name: "SliceMake"},                // arg0=ptr, arg1=len, arg2=cap
 +	{name: "SlicePtr", typ: "BytePtr"}, // ptr(arg0)
 +	{name: "SliceLen"},                 // len(arg0)
 +	{name: "SliceCap"},                 // cap(arg0)
 +
 +	// Complex (part/whole)
 +	{name: "ComplexMake"}, // arg0=real, arg1=imag
 +	{name: "ComplexReal"}, // real(arg0)
 +	{name: "ComplexImag"}, // imag(arg0)
 +
 +	// Strings
 +	{name: "StringMake"}, // arg0=ptr, arg1=len
 +	{name: "StringPtr"},  // ptr(arg0)
 +	{name: "StringLen"},  // len(arg0)
 +
 +	// Interfaces
 +	{name: "IMake"},                // arg0=itab, arg1=data
 +	{name: "ITab", typ: "BytePtr"}, // arg0=interface, returns itable field
 +	{name: "IData"},                // arg0=interface, returns data field
 +
 +	// Spill&restore ops for the register allocator.  These are
 +	// semantically identical to OpCopy; they do not take/return
 +	// stores like regular memory ops do.  We can get away without memory
 +	// args because we know there is no aliasing of spill slots on the stack.
 +	{name: "StoreReg"},
 +	{name: "LoadReg"},
 +
 +	// Used during ssa construction.  Like Copy, but the arg has not been specified yet.
 +	{name: "FwdRef"},
 +
 +	{name: "VarDef", typ: "Mem"}, // aux is a *gc.Node of a variable that is about to be initialized.  arg0=mem, returns mem
 +	{name: "VarKill"},            // aux is a *gc.Node of a variable that is known to be dead.  arg0=mem, returns mem
++	{name: "VarLive"},            // aux is a *gc.Node of a variable that must be kept live.  arg0=mem, returns mem
 +}
 +
 +//     kind           control    successors       implicit exit
 +//   ----------------------------------------------------------
 +//     Exit        return mem                []             yes
 +//      Ret        return mem                []             yes
 +//   RetJmp        return mem                []             yes
 +//    Plain               nil            [next]
 +//       If   a boolean Value      [then, else]
 +//     Call               mem            [next]             yes  (control opcode should be OpCall or OpStaticCall)
 +//    Check              void            [next]             yes  (control opcode should be Op{Lowered}NilCheck)
 +//    First               nil    [always,never]
 +
 +var genericBlocks = []blockData{
 +	{name: "Plain"},  // a single successor
 +	{name: "If"},     // 2 successors, if control goto Succs[0] else goto Succs[1]
 +	{name: "Call"},   // 1 successor, control is call op (of memory type)
 +	{name: "Check"},  // 1 successor, control is nilcheck op (of void type)
 +	{name: "Ret"},    // no successors, control value is memory result
 +	{name: "RetJmp"}, // no successors, jumps to b.Aux.(*gc.Sym)
 +	{name: "Exit"},   // no successors, control value generates a panic
 +
 +	// transient block states used for dead code removal
 +	{name: "First"}, // 2 successors, always takes the first one (second is dead)
 +	{name: "Dead"},  // no successors; determined to be dead but not yet removed
 +}
 +
 +func init() {
 +	archs = append(archs, arch{"generic", genericOps, genericBlocks, nil})
 +}
diff --cc src/cmd/compile/internal/ssa/lower.go
index 1b50eb642b,0000000000..af0ee4cccf
mode 100644,000000..100644
--- a/src/cmd/compile/internal/ssa/lower.go
+++ b/src/cmd/compile/internal/ssa/lower.go
@@@ -1,34 -1,0 +1,34 @@@
 +// Copyright 2015 The Go Authors. All rights reserved.
 +// Use of this source code is governed by a BSD-style
 +// license that can be found in the LICENSE file.
 +
 +package ssa
 +
 +// convert to machine-dependent ops
 +func lower(f *Func) {
 +	// repeat rewrites until we find no more rewrites
 +	applyRewrite(f, f.Config.lowerBlock, f.Config.lowerValue)
 +}
 +
 +// checkLower checks for unlowered opcodes and fails if we find one.
 +func checkLower(f *Func) {
 +	// Needs to be a separate phase because it must run after both
 +	// lowering and a subsequent dead code elimination (because lowering
 +	// rules may leave dead generic ops behind).
 +	for _, b := range f.Blocks {
 +		for _, v := range b.Values {
 +			if !opcodeTable[v.Op].generic {
 +				continue // lowered
 +			}
 +			switch v.Op {
- 			case OpSP, OpSB, OpInitMem, OpArg, OpPhi, OpVarDef, OpVarKill:
++			case OpSP, OpSB, OpInitMem, OpArg, OpPhi, OpVarDef, OpVarKill, OpVarLive:
 +				continue // ok not to lower
 +			}
 +			s := "not lowered: " + v.Op.String() + " " + v.Type.SimpleString()
 +			for _, a := range v.Args {
 +				s += " " + a.Type.SimpleString()
 +			}
 +			f.Unimplementedf("%s", s)
 +		}
 +	}
 +}
diff --cc src/cmd/compile/internal/ssa/opGen.go
index 2fd7f6b7a4,0000000000..433794a03b
mode 100644,000000..100644
--- a/src/cmd/compile/internal/ssa/opGen.go
+++ b/src/cmd/compile/internal/ssa/opGen.go
@@@ -1,4316 -1,0 +1,4321 @@@
 +// autogenerated: do not edit!
 +// generated from gen/*Ops.go
 +package ssa
 +
 +import "cmd/internal/obj/x86"
 +
 +const (
 +	BlockInvalid BlockKind = iota
 +
 +	BlockAMD64EQ
 +	BlockAMD64NE
 +	BlockAMD64LT
 +	BlockAMD64LE
 +	BlockAMD64GT
 +	BlockAMD64GE
 +	BlockAMD64ULT
 +	BlockAMD64ULE
 +	BlockAMD64UGT
 +	BlockAMD64UGE
 +	BlockAMD64EQF
 +	BlockAMD64NEF
 +	BlockAMD64ORD
 +	BlockAMD64NAN
 +
 +	BlockPlain
 +	BlockIf
 +	BlockCall
 +	BlockCheck
 +	BlockRet
 +	BlockRetJmp
 +	BlockExit
 +	BlockFirst
 +	BlockDead
 +)
 +
 +var blockString = [...]string{
 +	BlockInvalid: "BlockInvalid",
 +
 +	BlockAMD64EQ:  "EQ",
 +	BlockAMD64NE:  "NE",
 +	BlockAMD64LT:  "LT",
 +	BlockAMD64LE:  "LE",
 +	BlockAMD64GT:  "GT",
 +	BlockAMD64GE:  "GE",
 +	BlockAMD64ULT: "ULT",
 +	BlockAMD64ULE: "ULE",
 +	BlockAMD64UGT: "UGT",
 +	BlockAMD64UGE: "UGE",
 +	BlockAMD64EQF: "EQF",
 +	BlockAMD64NEF: "NEF",
 +	BlockAMD64ORD: "ORD",
 +	BlockAMD64NAN: "NAN",
 +
 +	BlockPlain:  "Plain",
 +	BlockIf:     "If",
 +	BlockCall:   "Call",
 +	BlockCheck:  "Check",
 +	BlockRet:    "Ret",
 +	BlockRetJmp: "RetJmp",
 +	BlockExit:   "Exit",
 +	BlockFirst:  "First",
 +	BlockDead:   "Dead",
 +}
 +
 +func (k BlockKind) String() string { return blockString[k] }
 +
 +const (
 +	OpInvalid Op = iota
 +
 +	OpAMD64ADDSS
 +	OpAMD64ADDSD
 +	OpAMD64SUBSS
 +	OpAMD64SUBSD
 +	OpAMD64MULSS
 +	OpAMD64MULSD
 +	OpAMD64DIVSS
 +	OpAMD64DIVSD
 +	OpAMD64MOVSSload
 +	OpAMD64MOVSDload
 +	OpAMD64MOVSSconst
 +	OpAMD64MOVSDconst
 +	OpAMD64MOVSSloadidx4
 +	OpAMD64MOVSDloadidx8
 +	OpAMD64MOVSSstore
 +	OpAMD64MOVSDstore
 +	OpAMD64MOVSSstoreidx4
 +	OpAMD64MOVSDstoreidx8
 +	OpAMD64ADDQ
 +	OpAMD64ADDL
 +	OpAMD64ADDW
 +	OpAMD64ADDB
 +	OpAMD64ADDQconst
 +	OpAMD64ADDLconst
 +	OpAMD64ADDWconst
 +	OpAMD64ADDBconst
 +	OpAMD64SUBQ
 +	OpAMD64SUBL
 +	OpAMD64SUBW
 +	OpAMD64SUBB
 +	OpAMD64SUBQconst
 +	OpAMD64SUBLconst
 +	OpAMD64SUBWconst
 +	OpAMD64SUBBconst
 +	OpAMD64MULQ
 +	OpAMD64MULL
 +	OpAMD64MULW
 +	OpAMD64MULB
 +	OpAMD64MULQconst
 +	OpAMD64MULLconst
 +	OpAMD64MULWconst
 +	OpAMD64MULBconst
 +	OpAMD64HMULL
 +	OpAMD64HMULW
 +	OpAMD64HMULB
 +	OpAMD64HMULLU
 +	OpAMD64HMULWU
 +	OpAMD64HMULBU
 +	OpAMD64DIVQ
 +	OpAMD64DIVL
 +	OpAMD64DIVW
 +	OpAMD64DIVQU
 +	OpAMD64DIVLU
 +	OpAMD64DIVWU
 +	OpAMD64MODQ
 +	OpAMD64MODL
 +	OpAMD64MODW
 +	OpAMD64MODQU
 +	OpAMD64MODLU
 +	OpAMD64MODWU
 +	OpAMD64ANDQ
 +	OpAMD64ANDL
 +	OpAMD64ANDW
 +	OpAMD64ANDB
 +	OpAMD64ANDQconst
 +	OpAMD64ANDLconst
 +	OpAMD64ANDWconst
 +	OpAMD64ANDBconst
 +	OpAMD64ORQ
 +	OpAMD64ORL
 +	OpAMD64ORW
 +	OpAMD64ORB
 +	OpAMD64ORQconst
 +	OpAMD64ORLconst
 +	OpAMD64ORWconst
 +	OpAMD64ORBconst
 +	OpAMD64XORQ
 +	OpAMD64XORL
 +	OpAMD64XORW
 +	OpAMD64XORB
 +	OpAMD64XORQconst
 +	OpAMD64XORLconst
 +	OpAMD64XORWconst
 +	OpAMD64XORBconst
 +	OpAMD64CMPQ
 +	OpAMD64CMPL
 +	OpAMD64CMPW
 +	OpAMD64CMPB
 +	OpAMD64CMPQconst
 +	OpAMD64CMPLconst
 +	OpAMD64CMPWconst
 +	OpAMD64CMPBconst
 +	OpAMD64UCOMISS
 +	OpAMD64UCOMISD
 +	OpAMD64TESTQ
 +	OpAMD64TESTL
 +	OpAMD64TESTW
 +	OpAMD64TESTB
 +	OpAMD64TESTQconst
 +	OpAMD64TESTLconst
 +	OpAMD64TESTWconst
 +	OpAMD64TESTBconst
 +	OpAMD64SHLQ
 +	OpAMD64SHLL
 +	OpAMD64SHLW
 +	OpAMD64SHLB
 +	OpAMD64SHLQconst
 +	OpAMD64SHLLconst
 +	OpAMD64SHLWconst
 +	OpAMD64SHLBconst
 +	OpAMD64SHRQ
 +	OpAMD64SHRL
 +	OpAMD64SHRW
 +	OpAMD64SHRB
 +	OpAMD64SHRQconst
 +	OpAMD64SHRLconst
 +	OpAMD64SHRWconst
 +	OpAMD64SHRBconst
 +	OpAMD64SARQ
 +	OpAMD64SARL
 +	OpAMD64SARW
 +	OpAMD64SARB
 +	OpAMD64SARQconst
 +	OpAMD64SARLconst
 +	OpAMD64SARWconst
 +	OpAMD64SARBconst
 +	OpAMD64ROLQconst
 +	OpAMD64ROLLconst
 +	OpAMD64ROLWconst
 +	OpAMD64ROLBconst
 +	OpAMD64NEGQ
 +	OpAMD64NEGL
 +	OpAMD64NEGW
 +	OpAMD64NEGB
 +	OpAMD64NOTQ
 +	OpAMD64NOTL
 +	OpAMD64NOTW
 +	OpAMD64NOTB
 +	OpAMD64SQRTSD
 +	OpAMD64SBBQcarrymask
 +	OpAMD64SBBLcarrymask
 +	OpAMD64SETEQ
 +	OpAMD64SETNE
 +	OpAMD64SETL
 +	OpAMD64SETLE
 +	OpAMD64SETG
 +	OpAMD64SETGE
 +	OpAMD64SETB
 +	OpAMD64SETBE
 +	OpAMD64SETA
 +	OpAMD64SETAE
 +	OpAMD64SETEQF
 +	OpAMD64SETNEF
 +	OpAMD64SETORD
 +	OpAMD64SETNAN
 +	OpAMD64SETGF
 +	OpAMD64SETGEF
 +	OpAMD64MOVBQSX
 +	OpAMD64MOVBQZX
 +	OpAMD64MOVWQSX
 +	OpAMD64MOVWQZX
 +	OpAMD64MOVLQSX
 +	OpAMD64MOVLQZX
 +	OpAMD64MOVBconst
 +	OpAMD64MOVWconst
 +	OpAMD64MOVLconst
 +	OpAMD64MOVQconst
 +	OpAMD64CVTTSD2SL
 +	OpAMD64CVTTSD2SQ
 +	OpAMD64CVTTSS2SL
 +	OpAMD64CVTTSS2SQ
 +	OpAMD64CVTSL2SS
 +	OpAMD64CVTSL2SD
 +	OpAMD64CVTSQ2SS
 +	OpAMD64CVTSQ2SD
 +	OpAMD64CVTSD2SS
 +	OpAMD64CVTSS2SD
 +	OpAMD64PXOR
 +	OpAMD64LEAQ
 +	OpAMD64LEAQ1
 +	OpAMD64LEAQ2
 +	OpAMD64LEAQ4
 +	OpAMD64LEAQ8
 +	OpAMD64MOVBload
 +	OpAMD64MOVBQSXload
 +	OpAMD64MOVBQZXload
 +	OpAMD64MOVWload
 +	OpAMD64MOVLload
 +	OpAMD64MOVQload
 +	OpAMD64MOVQloadidx8
 +	OpAMD64MOVBstore
 +	OpAMD64MOVWstore
 +	OpAMD64MOVLstore
 +	OpAMD64MOVQstore
 +	OpAMD64MOVQstoreidx8
 +	OpAMD64MOVOload
 +	OpAMD64MOVOstore
 +	OpAMD64MOVBstoreconst
 +	OpAMD64MOVWstoreconst
 +	OpAMD64MOVLstoreconst
 +	OpAMD64MOVQstoreconst
 +	OpAMD64DUFFZERO
 +	OpAMD64MOVOconst
 +	OpAMD64REPSTOSQ
 +	OpAMD64CALLstatic
 +	OpAMD64CALLclosure
 +	OpAMD64CALLdefer
 +	OpAMD64CALLgo
 +	OpAMD64CALLinter
 +	OpAMD64DUFFCOPY
 +	OpAMD64REPMOVSQ
 +	OpAMD64InvertFlags
 +	OpAMD64LoweredGetG
 +	OpAMD64LoweredGetClosurePtr
 +	OpAMD64LoweredNilCheck
 +	OpAMD64MOVQconvert
 +	OpAMD64FlagEQ
 +	OpAMD64FlagLT_ULT
 +	OpAMD64FlagLT_UGT
 +	OpAMD64FlagGT_UGT
 +	OpAMD64FlagGT_ULT
 +
 +	OpAdd8
 +	OpAdd16
 +	OpAdd32
 +	OpAdd64
 +	OpAddPtr
 +	OpAdd32F
 +	OpAdd64F
 +	OpSub8
 +	OpSub16
 +	OpSub32
 +	OpSub64
 +	OpSubPtr
 +	OpSub32F
 +	OpSub64F
 +	OpMul8
 +	OpMul16
 +	OpMul32
 +	OpMul64
 +	OpMul32F
 +	OpMul64F
 +	OpDiv32F
 +	OpDiv64F
 +	OpHmul8
 +	OpHmul8u
 +	OpHmul16
 +	OpHmul16u
 +	OpHmul32
 +	OpHmul32u
 +	OpDiv8
 +	OpDiv8u
 +	OpDiv16
 +	OpDiv16u
 +	OpDiv32
 +	OpDiv32u
 +	OpDiv64
 +	OpDiv64u
 +	OpMod8
 +	OpMod8u
 +	OpMod16
 +	OpMod16u
 +	OpMod32
 +	OpMod32u
 +	OpMod64
 +	OpMod64u
 +	OpAnd8
 +	OpAnd16
 +	OpAnd32
 +	OpAnd64
 +	OpOr8
 +	OpOr16
 +	OpOr32
 +	OpOr64
 +	OpXor8
 +	OpXor16
 +	OpXor32
 +	OpXor64
 +	OpLsh8x8
 +	OpLsh8x16
 +	OpLsh8x32
 +	OpLsh8x64
 +	OpLsh16x8
 +	OpLsh16x16
 +	OpLsh16x32
 +	OpLsh16x64
 +	OpLsh32x8
 +	OpLsh32x16
 +	OpLsh32x32
 +	OpLsh32x64
 +	OpLsh64x8
 +	OpLsh64x16
 +	OpLsh64x32
 +	OpLsh64x64
 +	OpRsh8x8
 +	OpRsh8x16
 +	OpRsh8x32
 +	OpRsh8x64
 +	OpRsh16x8
 +	OpRsh16x16
 +	OpRsh16x32
 +	OpRsh16x64
 +	OpRsh32x8
 +	OpRsh32x16
 +	OpRsh32x32
 +	OpRsh32x64
 +	OpRsh64x8
 +	OpRsh64x16
 +	OpRsh64x32
 +	OpRsh64x64
 +	OpRsh8Ux8
 +	OpRsh8Ux16
 +	OpRsh8Ux32
 +	OpRsh8Ux64
 +	OpRsh16Ux8
 +	OpRsh16Ux16
 +	OpRsh16Ux32
 +	OpRsh16Ux64
 +	OpRsh32Ux8
 +	OpRsh32Ux16
 +	OpRsh32Ux32
 +	OpRsh32Ux64
 +	OpRsh64Ux8
 +	OpRsh64Ux16
 +	OpRsh64Ux32
 +	OpRsh64Ux64
 +	OpLrot8
 +	OpLrot16
 +	OpLrot32
 +	OpLrot64
 +	OpEq8
 +	OpEq16
 +	OpEq32
 +	OpEq64
 +	OpEqPtr
 +	OpEqInter
 +	OpEqSlice
 +	OpEq32F
 +	OpEq64F
 +	OpNeq8
 +	OpNeq16
 +	OpNeq32
 +	OpNeq64
 +	OpNeqPtr
 +	OpNeqInter
 +	OpNeqSlice
 +	OpNeq32F
 +	OpNeq64F
 +	OpLess8
 +	OpLess8U
 +	OpLess16
 +	OpLess16U
 +	OpLess32
 +	OpLess32U
 +	OpLess64
 +	OpLess64U
 +	OpLess32F
 +	OpLess64F
 +	OpLeq8
 +	OpLeq8U
 +	OpLeq16
 +	OpLeq16U
 +	OpLeq32
 +	OpLeq32U
 +	OpLeq64
 +	OpLeq64U
 +	OpLeq32F
 +	OpLeq64F
 +	OpGreater8
 +	OpGreater8U
 +	OpGreater16
 +	OpGreater16U
 +	OpGreater32
 +	OpGreater32U
 +	OpGreater64
 +	OpGreater64U
 +	OpGreater32F
 +	OpGreater64F
 +	OpGeq8
 +	OpGeq8U
 +	OpGeq16
 +	OpGeq16U
 +	OpGeq32
 +	OpGeq32U
 +	OpGeq64
 +	OpGeq64U
 +	OpGeq32F
 +	OpGeq64F
 +	OpNot
 +	OpNeg8
 +	OpNeg16
 +	OpNeg32
 +	OpNeg64
 +	OpNeg32F
 +	OpNeg64F
 +	OpCom8
 +	OpCom16
 +	OpCom32
 +	OpCom64
 +	OpSqrt
 +	OpPhi
 +	OpCopy
 +	OpConvert
 +	OpConstBool
 +	OpConstString
 +	OpConstNil
 +	OpConst8
 +	OpConst16
 +	OpConst32
 +	OpConst64
 +	OpConst32F
 +	OpConst64F
 +	OpConstInterface
 +	OpConstSlice
 +	OpInitMem
 +	OpArg
 +	OpAddr
 +	OpSP
 +	OpSB
 +	OpFunc
 +	OpLoad
 +	OpStore
 +	OpMove
 +	OpZero
 +	OpClosureCall
 +	OpStaticCall
 +	OpDeferCall
 +	OpGoCall
 +	OpInterCall
 +	OpSignExt8to16
 +	OpSignExt8to32
 +	OpSignExt8to64
 +	OpSignExt16to32
 +	OpSignExt16to64
 +	OpSignExt32to64
 +	OpZeroExt8to16
 +	OpZeroExt8to32
 +	OpZeroExt8to64
 +	OpZeroExt16to32
 +	OpZeroExt16to64
 +	OpZeroExt32to64
 +	OpTrunc16to8
 +	OpTrunc32to8
 +	OpTrunc32to16
 +	OpTrunc64to8
 +	OpTrunc64to16
 +	OpTrunc64to32
 +	OpCvt32to32F
 +	OpCvt32to64F
 +	OpCvt64to32F
 +	OpCvt64to64F
 +	OpCvt32Fto32
 +	OpCvt32Fto64
 +	OpCvt64Fto32
 +	OpCvt64Fto64
 +	OpCvt32Fto64F
 +	OpCvt64Fto32F
 +	OpIsNonNil
 +	OpIsInBounds
 +	OpIsSliceInBounds
 +	OpNilCheck
 +	OpGetG
 +	OpGetClosurePtr
 +	OpArrayIndex
 +	OpPtrIndex
 +	OpOffPtr
 +	OpStructSelect
 +	OpSliceMake
 +	OpSlicePtr
 +	OpSliceLen
 +	OpSliceCap
 +	OpComplexMake
 +	OpComplexReal
 +	OpComplexImag
 +	OpStringMake
 +	OpStringPtr
 +	OpStringLen
 +	OpIMake
 +	OpITab
 +	OpIData
 +	OpStoreReg
 +	OpLoadReg
 +	OpFwdRef
 +	OpVarDef
 +	OpVarKill
++	OpVarLive
 +)
 +
 +var opcodeTable = [...]opInfo{
 +	{name: "OpInvalid"},
 +
 +	{
 +		name: "ADDSS",
 +		asm:  x86.AADDSS,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +				{1, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "ADDSD",
 +		asm:  x86.AADDSD,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +				{1, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "SUBSS",
 +		asm:  x86.ASUBSS,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 2147418112}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14
 +				{1, 2147418112}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14
 +			},
 +			clobbers: 2147483648, // .X15
 +			outputs: []regMask{
 +				2147418112, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14
 +			},
 +		},
 +	},
 +	{
 +		name: "SUBSD",
 +		asm:  x86.ASUBSD,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 2147418112}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14
 +				{1, 2147418112}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14
 +			},
 +			clobbers: 2147483648, // .X15
 +			outputs: []regMask{
 +				2147418112, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14
 +			},
 +		},
 +	},
 +	{
 +		name: "MULSS",
 +		asm:  x86.AMULSS,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +				{1, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "MULSD",
 +		asm:  x86.AMULSD,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +				{1, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "DIVSS",
 +		asm:  x86.ADIVSS,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 2147418112}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14
 +				{1, 2147418112}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14
 +			},
 +			clobbers: 2147483648, // .X15
 +			outputs: []regMask{
 +				2147418112, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14
 +			},
 +		},
 +	},
 +	{
 +		name: "DIVSD",
 +		asm:  x86.ADIVSD,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 2147418112}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14
 +				{1, 2147418112}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14
 +			},
 +			clobbers: 2147483648, // .X15
 +			outputs: []regMask{
 +				2147418112, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVSSload",
 +		asm:  x86.AMOVSS,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVSDload",
 +		asm:  x86.AMOVSD,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVSSconst",
 +		asm:  x86.AMOVSS,
 +		reg: regInfo{
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVSDconst",
 +		asm:  x86.AMOVSD,
 +		reg: regInfo{
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVSSloadidx4",
 +		asm:  x86.AMOVSS,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 65535},      // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVSDloadidx8",
 +		asm:  x86.AMOVSD,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 65535},      // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVSSstore",
 +		asm:  x86.AMOVSS,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVSDstore",
 +		asm:  x86.AMOVSD,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVSSstoreidx4",
 +		asm:  x86.AMOVSS,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 65535},      // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{2, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVSDstoreidx8",
 +		asm:  x86.AMOVSD,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 65535},      // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{2, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +		},
 +	},
 +	{
 +		name: "ADDQ",
 +		asm:  x86.AADDQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ADDL",
 +		asm:  x86.AADDL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ADDW",
 +		asm:  x86.AADDW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ADDB",
 +		asm:  x86.AADDB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ADDQconst",
 +		asm:  x86.AADDQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ADDLconst",
 +		asm:  x86.AADDL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ADDWconst",
 +		asm:  x86.AADDW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ADDBconst",
 +		asm:  x86.AADDB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SUBQ",
 +		asm:  x86.ASUBQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SUBL",
 +		asm:  x86.ASUBL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SUBW",
 +		asm:  x86.ASUBW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SUBB",
 +		asm:  x86.ASUBB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SUBQconst",
 +		asm:  x86.ASUBQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SUBLconst",
 +		asm:  x86.ASUBL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SUBWconst",
 +		asm:  x86.ASUBW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SUBBconst",
 +		asm:  x86.ASUBB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MULQ",
 +		asm:  x86.AIMULQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MULL",
 +		asm:  x86.AIMULL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MULW",
 +		asm:  x86.AIMULW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MULB",
 +		asm:  x86.AIMULW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MULQconst",
 +		asm:  x86.AIMULQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MULLconst",
 +		asm:  x86.AIMULL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MULWconst",
 +		asm:  x86.AIMULW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MULBconst",
 +		asm:  x86.AIMULW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "HMULL",
 +		asm:  x86.AIMULL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 1},     // .AX
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934593, // .AX .FLAGS
 +			outputs: []regMask{
 +				4, // .DX
 +			},
 +		},
 +	},
 +	{
 +		name: "HMULW",
 +		asm:  x86.AIMULW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 1},     // .AX
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934593, // .AX .FLAGS
 +			outputs: []regMask{
 +				4, // .DX
 +			},
 +		},
 +	},
 +	{
 +		name: "HMULB",
 +		asm:  x86.AIMULB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 1},     // .AX
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934593, // .AX .FLAGS
 +			outputs: []regMask{
 +				4, // .DX
 +			},
 +		},
 +	},
 +	{
 +		name: "HMULLU",
 +		asm:  x86.AMULL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 1},     // .AX
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934593, // .AX .FLAGS
 +			outputs: []regMask{
 +				4, // .DX
 +			},
 +		},
 +	},
 +	{
 +		name: "HMULWU",
 +		asm:  x86.AMULW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 1},     // .AX
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934593, // .AX .FLAGS
 +			outputs: []regMask{
 +				4, // .DX
 +			},
 +		},
 +	},
 +	{
 +		name: "HMULBU",
 +		asm:  x86.AMULB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 1},     // .AX
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934593, // .AX .FLAGS
 +			outputs: []regMask{
 +				4, // .DX
 +			},
 +		},
 +	},
 +	{
 +		name: "DIVQ",
 +		asm:  x86.AIDIVQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 1},     // .AX
 +				{1, 65531}, // .AX .CX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934596, // .DX .FLAGS
 +			outputs: []regMask{
 +				1, // .AX
 +			},
 +		},
 +	},
 +	{
 +		name: "DIVL",
 +		asm:  x86.AIDIVL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 1},     // .AX
 +				{1, 65531}, // .AX .CX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934596, // .DX .FLAGS
 +			outputs: []regMask{
 +				1, // .AX
 +			},
 +		},
 +	},
 +	{
 +		name: "DIVW",
 +		asm:  x86.AIDIVW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 1},     // .AX
 +				{1, 65531}, // .AX .CX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934596, // .DX .FLAGS
 +			outputs: []regMask{
 +				1, // .AX
 +			},
 +		},
 +	},
 +	{
 +		name: "DIVQU",
 +		asm:  x86.ADIVQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 1},     // .AX
 +				{1, 65531}, // .AX .CX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934596, // .DX .FLAGS
 +			outputs: []regMask{
 +				1, // .AX
 +			},
 +		},
 +	},
 +	{
 +		name: "DIVLU",
 +		asm:  x86.ADIVL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 1},     // .AX
 +				{1, 65531}, // .AX .CX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934596, // .DX .FLAGS
 +			outputs: []regMask{
 +				1, // .AX
 +			},
 +		},
 +	},
 +	{
 +		name: "DIVWU",
 +		asm:  x86.ADIVW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 1},     // .AX
 +				{1, 65531}, // .AX .CX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934596, // .DX .FLAGS
 +			outputs: []regMask{
 +				1, // .AX
 +			},
 +		},
 +	},
 +	{
 +		name: "MODQ",
 +		asm:  x86.AIDIVQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 1},     // .AX
 +				{1, 65531}, // .AX .CX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934593, // .AX .FLAGS
 +			outputs: []regMask{
 +				4, // .DX
 +			},
 +		},
 +	},
 +	{
 +		name: "MODL",
 +		asm:  x86.AIDIVL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 1},     // .AX
 +				{1, 65531}, // .AX .CX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934593, // .AX .FLAGS
 +			outputs: []regMask{
 +				4, // .DX
 +			},
 +		},
 +	},
 +	{
 +		name: "MODW",
 +		asm:  x86.AIDIVW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 1},     // .AX
 +				{1, 65531}, // .AX .CX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934593, // .AX .FLAGS
 +			outputs: []regMask{
 +				4, // .DX
 +			},
 +		},
 +	},
 +	{
 +		name: "MODQU",
 +		asm:  x86.ADIVQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 1},     // .AX
 +				{1, 65531}, // .AX .CX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934593, // .AX .FLAGS
 +			outputs: []regMask{
 +				4, // .DX
 +			},
 +		},
 +	},
 +	{
 +		name: "MODLU",
 +		asm:  x86.ADIVL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 1},     // .AX
 +				{1, 65531}, // .AX .CX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934593, // .AX .FLAGS
 +			outputs: []regMask{
 +				4, // .DX
 +			},
 +		},
 +	},
 +	{
 +		name: "MODWU",
 +		asm:  x86.ADIVW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 1},     // .AX
 +				{1, 65531}, // .AX .CX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934593, // .AX .FLAGS
 +			outputs: []regMask{
 +				4, // .DX
 +			},
 +		},
 +	},
 +	{
 +		name: "ANDQ",
 +		asm:  x86.AANDQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ANDL",
 +		asm:  x86.AANDL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ANDW",
 +		asm:  x86.AANDW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ANDB",
 +		asm:  x86.AANDB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ANDQconst",
 +		asm:  x86.AANDQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ANDLconst",
 +		asm:  x86.AANDL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ANDWconst",
 +		asm:  x86.AANDW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ANDBconst",
 +		asm:  x86.AANDB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ORQ",
 +		asm:  x86.AORQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ORL",
 +		asm:  x86.AORL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ORW",
 +		asm:  x86.AORW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ORB",
 +		asm:  x86.AORB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ORQconst",
 +		asm:  x86.AORQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ORLconst",
 +		asm:  x86.AORL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ORWconst",
 +		asm:  x86.AORW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ORBconst",
 +		asm:  x86.AORB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "XORQ",
 +		asm:  x86.AXORQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "XORL",
 +		asm:  x86.AXORL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "XORW",
 +		asm:  x86.AXORW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "XORB",
 +		asm:  x86.AXORB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "XORQconst",
 +		asm:  x86.AXORQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "XORLconst",
 +		asm:  x86.AXORL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "XORWconst",
 +		asm:  x86.AXORW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "XORBconst",
 +		asm:  x86.AXORB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "CMPQ",
 +		asm:  x86.ACMPQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				8589934592, // .FLAGS
 +			},
 +		},
 +	},
 +	{
 +		name: "CMPL",
 +		asm:  x86.ACMPL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				8589934592, // .FLAGS
 +			},
 +		},
 +	},
 +	{
 +		name: "CMPW",
 +		asm:  x86.ACMPW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				8589934592, // .FLAGS
 +			},
 +		},
 +	},
 +	{
 +		name: "CMPB",
 +		asm:  x86.ACMPB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				8589934592, // .FLAGS
 +			},
 +		},
 +	},
 +	{
 +		name: "CMPQconst",
 +		asm:  x86.ACMPQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				8589934592, // .FLAGS
 +			},
 +		},
 +	},
 +	{
 +		name: "CMPLconst",
 +		asm:  x86.ACMPL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				8589934592, // .FLAGS
 +			},
 +		},
 +	},
 +	{
 +		name: "CMPWconst",
 +		asm:  x86.ACMPW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				8589934592, // .FLAGS
 +			},
 +		},
 +	},
 +	{
 +		name: "CMPBconst",
 +		asm:  x86.ACMPB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				8589934592, // .FLAGS
 +			},
 +		},
 +	},
 +	{
 +		name: "UCOMISS",
 +		asm:  x86.AUCOMISS,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +				{1, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +			outputs: []regMask{
 +				8589934592, // .FLAGS
 +			},
 +		},
 +	},
 +	{
 +		name: "UCOMISD",
 +		asm:  x86.AUCOMISD,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +				{1, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +			outputs: []regMask{
 +				8589934592, // .FLAGS
 +			},
 +		},
 +	},
 +	{
 +		name: "TESTQ",
 +		asm:  x86.ATESTQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				8589934592, // .FLAGS
 +			},
 +		},
 +	},
 +	{
 +		name: "TESTL",
 +		asm:  x86.ATESTL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				8589934592, // .FLAGS
 +			},
 +		},
 +	},
 +	{
 +		name: "TESTW",
 +		asm:  x86.ATESTW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				8589934592, // .FLAGS
 +			},
 +		},
 +	},
 +	{
 +		name: "TESTB",
 +		asm:  x86.ATESTB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{1, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				8589934592, // .FLAGS
 +			},
 +		},
 +	},
 +	{
 +		name: "TESTQconst",
 +		asm:  x86.ATESTQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				8589934592, // .FLAGS
 +			},
 +		},
 +	},
 +	{
 +		name: "TESTLconst",
 +		asm:  x86.ATESTL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				8589934592, // .FLAGS
 +			},
 +		},
 +	},
 +	{
 +		name: "TESTWconst",
 +		asm:  x86.ATESTW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				8589934592, // .FLAGS
 +			},
 +		},
 +	},
 +	{
 +		name: "TESTBconst",
 +		asm:  x86.ATESTB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				8589934592, // .FLAGS
 +			},
 +		},
 +	},
 +	{
 +		name: "SHLQ",
 +		asm:  x86.ASHLQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 2},     // .CX
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65517, // .AX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SHLL",
 +		asm:  x86.ASHLL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 2},     // .CX
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65517, // .AX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SHLW",
 +		asm:  x86.ASHLW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 2},     // .CX
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65517, // .AX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SHLB",
 +		asm:  x86.ASHLB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 2},     // .CX
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65517, // .AX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SHLQconst",
 +		asm:  x86.ASHLQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SHLLconst",
 +		asm:  x86.ASHLL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SHLWconst",
 +		asm:  x86.ASHLW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SHLBconst",
 +		asm:  x86.ASHLB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SHRQ",
 +		asm:  x86.ASHRQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 2},     // .CX
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65517, // .AX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SHRL",
 +		asm:  x86.ASHRL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 2},     // .CX
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65517, // .AX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SHRW",
 +		asm:  x86.ASHRW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 2},     // .CX
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65517, // .AX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SHRB",
 +		asm:  x86.ASHRB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 2},     // .CX
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65517, // .AX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SHRQconst",
 +		asm:  x86.ASHRQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SHRLconst",
 +		asm:  x86.ASHRL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SHRWconst",
 +		asm:  x86.ASHRW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SHRBconst",
 +		asm:  x86.ASHRB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SARQ",
 +		asm:  x86.ASARQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 2},     // .CX
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65517, // .AX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SARL",
 +		asm:  x86.ASARL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 2},     // .CX
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65517, // .AX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SARW",
 +		asm:  x86.ASARW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 2},     // .CX
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65517, // .AX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SARB",
 +		asm:  x86.ASARB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 2},     // .CX
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65517, // .AX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SARQconst",
 +		asm:  x86.ASARQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SARLconst",
 +		asm:  x86.ASARL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SARWconst",
 +		asm:  x86.ASARW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SARBconst",
 +		asm:  x86.ASARB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ROLQconst",
 +		asm:  x86.AROLQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ROLLconst",
 +		asm:  x86.AROLL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ROLWconst",
 +		asm:  x86.AROLW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "ROLBconst",
 +		asm:  x86.AROLB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "NEGQ",
 +		asm:  x86.ANEGQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "NEGL",
 +		asm:  x86.ANEGL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "NEGW",
 +		asm:  x86.ANEGW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "NEGB",
 +		asm:  x86.ANEGB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "NOTQ",
 +		asm:  x86.ANOTQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "NOTL",
 +		asm:  x86.ANOTL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "NOTW",
 +		asm:  x86.ANOTW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "NOTB",
 +		asm:  x86.ANOTB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SQRTSD",
 +		asm:  x86.ASQRTSD,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "SBBQcarrymask",
 +		asm:  x86.ASBBQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 8589934592}, // .FLAGS
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SBBLcarrymask",
 +		asm:  x86.ASBBL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 8589934592}, // .FLAGS
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SETEQ",
 +		asm:  x86.ASETEQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 8589934592}, // .FLAGS
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SETNE",
 +		asm:  x86.ASETNE,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 8589934592}, // .FLAGS
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SETL",
 +		asm:  x86.ASETLT,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 8589934592}, // .FLAGS
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SETLE",
 +		asm:  x86.ASETLE,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 8589934592}, // .FLAGS
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SETG",
 +		asm:  x86.ASETGT,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 8589934592}, // .FLAGS
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SETGE",
 +		asm:  x86.ASETGE,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 8589934592}, // .FLAGS
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SETB",
 +		asm:  x86.ASETCS,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 8589934592}, // .FLAGS
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SETBE",
 +		asm:  x86.ASETLS,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 8589934592}, // .FLAGS
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SETA",
 +		asm:  x86.ASETHI,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 8589934592}, // .FLAGS
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SETAE",
 +		asm:  x86.ASETCC,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 8589934592}, // .FLAGS
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SETEQF",
 +		asm:  x86.ASETEQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 8589934592}, // .FLAGS
 +			},
 +			clobbers: 8589934593, // .AX .FLAGS
 +			outputs: []regMask{
 +				65518, // .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SETNEF",
 +		asm:  x86.ASETNE,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 8589934592}, // .FLAGS
 +			},
 +			clobbers: 8589934593, // .AX .FLAGS
 +			outputs: []regMask{
 +				65518, // .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SETORD",
 +		asm:  x86.ASETPC,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 8589934592}, // .FLAGS
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SETNAN",
 +		asm:  x86.ASETPS,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 8589934592}, // .FLAGS
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SETGF",
 +		asm:  x86.ASETHI,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 8589934592}, // .FLAGS
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "SETGEF",
 +		asm:  x86.ASETCC,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 8589934592}, // .FLAGS
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVBQSX",
 +		asm:  x86.AMOVBQSX,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVBQZX",
 +		asm:  x86.AMOVBQZX,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVWQSX",
 +		asm:  x86.AMOVWQSX,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVWQZX",
 +		asm:  x86.AMOVWQZX,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVLQSX",
 +		asm:  x86.AMOVLQSX,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVLQZX",
 +		asm:  x86.AMOVLQZX,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVBconst",
 +		asm:  x86.AMOVB,
 +		reg: regInfo{
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVWconst",
 +		asm:  x86.AMOVW,
 +		reg: regInfo{
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVLconst",
 +		asm:  x86.AMOVL,
 +		reg: regInfo{
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVQconst",
 +		asm:  x86.AMOVQ,
 +		reg: regInfo{
 +			clobbers: 8589934592, // .FLAGS
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "CVTTSD2SL",
 +		asm:  x86.ACVTTSD2SL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "CVTTSD2SQ",
 +		asm:  x86.ACVTTSD2SQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "CVTTSS2SL",
 +		asm:  x86.ACVTTSS2SL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "CVTTSS2SQ",
 +		asm:  x86.ACVTTSS2SQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "CVTSL2SS",
 +		asm:  x86.ACVTSL2SS,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65519}, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "CVTSL2SD",
 +		asm:  x86.ACVTSL2SD,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65519}, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "CVTSQ2SS",
 +		asm:  x86.ACVTSQ2SS,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65519}, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "CVTSQ2SD",
 +		asm:  x86.ACVTSQ2SD,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65519}, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "CVTSD2SS",
 +		asm:  x86.ACVTSD2SS,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "CVTSS2SD",
 +		asm:  x86.ACVTSS2SD,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "PXOR",
 +		asm:  x86.APXOR,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +				{1, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "LEAQ",
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "LEAQ1",
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 65535},      // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "LEAQ2",
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 65535},      // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "LEAQ4",
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 65535},      // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "LEAQ8",
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 65535},      // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVBload",
 +		asm:  x86.AMOVB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVBQSXload",
 +		asm:  x86.AMOVBQSX,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVBQZXload",
 +		asm:  x86.AMOVBQZX,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVWload",
 +		asm:  x86.AMOVW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVLload",
 +		asm:  x86.AMOVL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVQload",
 +		asm:  x86.AMOVQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVQloadidx8",
 +		asm:  x86.AMOVQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 65535},      // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVBstore",
 +		asm:  x86.AMOVB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 65535},      // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVWstore",
 +		asm:  x86.AMOVW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 65535},      // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVLstore",
 +		asm:  x86.AMOVL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 65535},      // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVQstore",
 +		asm:  x86.AMOVQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 65535},      // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVQstoreidx8",
 +		asm:  x86.AMOVQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 65535},      // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{2, 65535},      // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVOload",
 +		asm:  x86.AMOVUPS,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVOstore",
 +		asm:  x86.AMOVUPS,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 4294901760}, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVBstoreconst",
 +		asm:  x86.AMOVB,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVWstoreconst",
 +		asm:  x86.AMOVW,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVLstoreconst",
 +		asm:  x86.AMOVL,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +		},
 +	},
 +	{
 +		name: "MOVQstoreconst",
 +		asm:  x86.AMOVQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 4295032831}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .SB
 +			},
 +		},
 +	},
 +	{
 +		name: "DUFFZERO",
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 128},   // .DI
 +				{1, 65536}, // .X0
 +			},
 +			clobbers: 8589934720, // .DI .FLAGS
 +		},
 +	},
 +	{
 +		name: "MOVOconst",
 +		reg: regInfo{
 +			outputs: []regMask{
 +				4294901760, // .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15
 +			},
 +		},
 +	},
 +	{
 +		name: "REPSTOSQ",
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 128}, // .DI
 +				{1, 2},   // .CX
 +				{2, 1},   // .AX
 +			},
 +			clobbers: 8589934722, // .CX .DI .FLAGS
 +		},
 +	},
 +	{
 +		name: "CALLstatic",
 +		reg: regInfo{
 +			clobbers: 12884901871, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15 .FLAGS
 +		},
 +	},
 +	{
 +		name: "CALLclosure",
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{1, 4},     // .DX
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 12884901871, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15 .FLAGS
 +		},
 +	},
 +	{
 +		name: "CALLdefer",
 +		reg: regInfo{
 +			clobbers: 12884901871, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15 .FLAGS
 +		},
 +	},
 +	{
 +		name: "CALLgo",
 +		reg: regInfo{
 +			clobbers: 12884901871, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15 .FLAGS
 +		},
 +	},
 +	{
 +		name: "CALLinter",
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65519}, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 12884901871, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15 .X0 .X1 .X2 .X3 .X4 .X5 .X6 .X7 .X8 .X9 .X10 .X11 .X12 .X13 .X14 .X15 .FLAGS
 +		},
 +	},
 +	{
 +		name: "DUFFCOPY",
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 128}, // .DI
 +				{1, 64},  // .SI
 +			},
 +			clobbers: 8590000320, // .SI .DI .X0 .FLAGS
 +		},
 +	},
 +	{
 +		name: "REPMOVSQ",
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 128}, // .DI
 +				{1, 64},  // .SI
 +				{2, 2},   // .CX
 +			},
 +			clobbers: 194, // .CX .SI .DI
 +		},
 +	},
 +	{
 +		name: "InvertFlags",
 +		reg:  regInfo{},
 +	},
 +	{
 +		name: "LoweredGetG",
 +		reg: regInfo{
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "LoweredGetClosurePtr",
 +		reg: regInfo{
 +			outputs: []regMask{
 +				4, // .DX
 +			},
 +		},
 +	},
 +	{
 +		name: "LoweredNilCheck",
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			clobbers: 8589934592, // .FLAGS
 +		},
 +	},
 +	{
 +		name: "MOVQconvert",
 +		asm:  x86.AMOVQ,
 +		reg: regInfo{
 +			inputs: []inputInfo{
 +				{0, 65535}, // .AX .CX .DX .BX .SP .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +			outputs: []regMask{
 +				65519, // .AX .CX .DX .BX .BP .SI .DI .R8 .R9 .R10 .R11 .R12 .R13 .R14 .R15
 +			},
 +		},
 +	},
 +	{
 +		name: "FlagEQ",
 +		reg:  regInfo{},
 +	},
 +	{
 +		name: "FlagLT_ULT",
 +		reg:  regInfo{},
 +	},
 +	{
 +		name: "FlagLT_UGT",
 +		reg:  regInfo{},
 +	},
 +	{
 +		name: "FlagGT_UGT",
 +		reg:  regInfo{},
 +	},
 +	{
 +		name: "FlagGT_ULT",
 +		reg:  regInfo{},
 +	},
 +
 +	{
 +		name:    "Add8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Add16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Add32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Add64",
 +		generic: true,
 +	},
 +	{
 +		name:    "AddPtr",
 +		generic: true,
 +	},
 +	{
 +		name:    "Add32F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Add64F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Sub8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Sub16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Sub32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Sub64",
 +		generic: true,
 +	},
 +	{
 +		name:    "SubPtr",
 +		generic: true,
 +	},
 +	{
 +		name:    "Sub32F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Sub64F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Mul8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Mul16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Mul32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Mul64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Mul32F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Mul64F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Div32F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Div64F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Hmul8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Hmul8u",
 +		generic: true,
 +	},
 +	{
 +		name:    "Hmul16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Hmul16u",
 +		generic: true,
 +	},
 +	{
 +		name:    "Hmul32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Hmul32u",
 +		generic: true,
 +	},
 +	{
 +		name:    "Div8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Div8u",
 +		generic: true,
 +	},
 +	{
 +		name:    "Div16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Div16u",
 +		generic: true,
 +	},
 +	{
 +		name:    "Div32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Div32u",
 +		generic: true,
 +	},
 +	{
 +		name:    "Div64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Div64u",
 +		generic: true,
 +	},
 +	{
 +		name:    "Mod8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Mod8u",
 +		generic: true,
 +	},
 +	{
 +		name:    "Mod16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Mod16u",
 +		generic: true,
 +	},
 +	{
 +		name:    "Mod32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Mod32u",
 +		generic: true,
 +	},
 +	{
 +		name:    "Mod64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Mod64u",
 +		generic: true,
 +	},
 +	{
 +		name:    "And8",
 +		generic: true,
 +	},
 +	{
 +		name:    "And16",
 +		generic: true,
 +	},
 +	{
 +		name:    "And32",
 +		generic: true,
 +	},
 +	{
 +		name:    "And64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Or8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Or16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Or32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Or64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Xor8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Xor16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Xor32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Xor64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lsh8x8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lsh8x16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lsh8x32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lsh8x64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lsh16x8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lsh16x16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lsh16x32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lsh16x64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lsh32x8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lsh32x16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lsh32x32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lsh32x64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lsh64x8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lsh64x16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lsh64x32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lsh64x64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh8x8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh8x16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh8x32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh8x64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh16x8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh16x16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh16x32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh16x64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh32x8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh32x16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh32x32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh32x64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh64x8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh64x16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh64x32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh64x64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh8Ux8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh8Ux16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh8Ux32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh8Ux64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh16Ux8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh16Ux16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh16Ux32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh16Ux64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh32Ux8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh32Ux16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh32Ux32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh32Ux64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh64Ux8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh64Ux16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh64Ux32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Rsh64Ux64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lrot8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lrot16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lrot32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Lrot64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Eq8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Eq16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Eq32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Eq64",
 +		generic: true,
 +	},
 +	{
 +		name:    "EqPtr",
 +		generic: true,
 +	},
 +	{
 +		name:    "EqInter",
 +		generic: true,
 +	},
 +	{
 +		name:    "EqSlice",
 +		generic: true,
 +	},
 +	{
 +		name:    "Eq32F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Eq64F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Neq8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Neq16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Neq32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Neq64",
 +		generic: true,
 +	},
 +	{
 +		name:    "NeqPtr",
 +		generic: true,
 +	},
 +	{
 +		name:    "NeqInter",
 +		generic: true,
 +	},
 +	{
 +		name:    "NeqSlice",
 +		generic: true,
 +	},
 +	{
 +		name:    "Neq32F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Neq64F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Less8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Less8U",
 +		generic: true,
 +	},
 +	{
 +		name:    "Less16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Less16U",
 +		generic: true,
 +	},
 +	{
 +		name:    "Less32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Less32U",
 +		generic: true,
 +	},
 +	{
 +		name:    "Less64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Less64U",
 +		generic: true,
 +	},
 +	{
 +		name:    "Less32F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Less64F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Leq8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Leq8U",
 +		generic: true,
 +	},
 +	{
 +		name:    "Leq16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Leq16U",
 +		generic: true,
 +	},
 +	{
 +		name:    "Leq32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Leq32U",
 +		generic: true,
 +	},
 +	{
 +		name:    "Leq64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Leq64U",
 +		generic: true,
 +	},
 +	{
 +		name:    "Leq32F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Leq64F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Greater8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Greater8U",
 +		generic: true,
 +	},
 +	{
 +		name:    "Greater16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Greater16U",
 +		generic: true,
 +	},
 +	{
 +		name:    "Greater32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Greater32U",
 +		generic: true,
 +	},
 +	{
 +		name:    "Greater64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Greater64U",
 +		generic: true,
 +	},
 +	{
 +		name:    "Greater32F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Greater64F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Geq8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Geq8U",
 +		generic: true,
 +	},
 +	{
 +		name:    "Geq16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Geq16U",
 +		generic: true,
 +	},
 +	{
 +		name:    "Geq32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Geq32U",
 +		generic: true,
 +	},
 +	{
 +		name:    "Geq64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Geq64U",
 +		generic: true,
 +	},
 +	{
 +		name:    "Geq32F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Geq64F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Not",
 +		generic: true,
 +	},
 +	{
 +		name:    "Neg8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Neg16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Neg32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Neg64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Neg32F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Neg64F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Com8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Com16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Com32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Com64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Sqrt",
 +		generic: true,
 +	},
 +	{
 +		name:    "Phi",
 +		generic: true,
 +	},
 +	{
 +		name:    "Copy",
 +		generic: true,
 +	},
 +	{
 +		name:    "Convert",
 +		generic: true,
 +	},
 +	{
 +		name:    "ConstBool",
 +		generic: true,
 +	},
 +	{
 +		name:    "ConstString",
 +		generic: true,
 +	},
 +	{
 +		name:    "ConstNil",
 +		generic: true,
 +	},
 +	{
 +		name:    "Const8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Const16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Const32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Const64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Const32F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Const64F",
 +		generic: true,
 +	},
 +	{
 +		name:    "ConstInterface",
 +		generic: true,
 +	},
 +	{
 +		name:    "ConstSlice",
 +		generic: true,
 +	},
 +	{
 +		name:    "InitMem",
 +		generic: true,
 +	},
 +	{
 +		name:    "Arg",
 +		generic: true,
 +	},
 +	{
 +		name:    "Addr",
 +		generic: true,
 +	},
 +	{
 +		name:    "SP",
 +		generic: true,
 +	},
 +	{
 +		name:    "SB",
 +		generic: true,
 +	},
 +	{
 +		name:    "Func",
 +		generic: true,
 +	},
 +	{
 +		name:    "Load",
 +		generic: true,
 +	},
 +	{
 +		name:    "Store",
 +		generic: true,
 +	},
 +	{
 +		name:    "Move",
 +		generic: true,
 +	},
 +	{
 +		name:    "Zero",
 +		generic: true,
 +	},
 +	{
 +		name:    "ClosureCall",
 +		generic: true,
 +	},
 +	{
 +		name:    "StaticCall",
 +		generic: true,
 +	},
 +	{
 +		name:    "DeferCall",
 +		generic: true,
 +	},
 +	{
 +		name:    "GoCall",
 +		generic: true,
 +	},
 +	{
 +		name:    "InterCall",
 +		generic: true,
 +	},
 +	{
 +		name:    "SignExt8to16",
 +		generic: true,
 +	},
 +	{
 +		name:    "SignExt8to32",
 +		generic: true,
 +	},
 +	{
 +		name:    "SignExt8to64",
 +		generic: true,
 +	},
 +	{
 +		name:    "SignExt16to32",
 +		generic: true,
 +	},
 +	{
 +		name:    "SignExt16to64",
 +		generic: true,
 +	},
 +	{
 +		name:    "SignExt32to64",
 +		generic: true,
 +	},
 +	{
 +		name:    "ZeroExt8to16",
 +		generic: true,
 +	},
 +	{
 +		name:    "ZeroExt8to32",
 +		generic: true,
 +	},
 +	{
 +		name:    "ZeroExt8to64",
 +		generic: true,
 +	},
 +	{
 +		name:    "ZeroExt16to32",
 +		generic: true,
 +	},
 +	{
 +		name:    "ZeroExt16to64",
 +		generic: true,
 +	},
 +	{
 +		name:    "ZeroExt32to64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Trunc16to8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Trunc32to8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Trunc32to16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Trunc64to8",
 +		generic: true,
 +	},
 +	{
 +		name:    "Trunc64to16",
 +		generic: true,
 +	},
 +	{
 +		name:    "Trunc64to32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Cvt32to32F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Cvt32to64F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Cvt64to32F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Cvt64to64F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Cvt32Fto32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Cvt32Fto64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Cvt64Fto32",
 +		generic: true,
 +	},
 +	{
 +		name:    "Cvt64Fto64",
 +		generic: true,
 +	},
 +	{
 +		name:    "Cvt32Fto64F",
 +		generic: true,
 +	},
 +	{
 +		name:    "Cvt64Fto32F",
 +		generic: true,
 +	},
 +	{
 +		name:    "IsNonNil",
 +		generic: true,
 +	},
 +	{
 +		name:    "IsInBounds",
 +		generic: true,
 +	},
 +	{
 +		name:    "IsSliceInBounds",
 +		generic: true,
 +	},
 +	{
 +		name:    "NilCheck",
 +		generic: true,
 +	},
 +	{
 +		name:    "GetG",
 +		generic: true,
 +	},
 +	{
 +		name:    "GetClosurePtr",
 +		generic: true,
 +	},
 +	{
 +		name:    "ArrayIndex",
 +		generic: true,
 +	},
 +	{
 +		name:    "PtrIndex",
 +		generic: true,
 +	},
 +	{
 +		name:    "OffPtr",
 +		generic: true,
 +	},
 +	{
 +		name:    "StructSelect",
 +		generic: true,
 +	},
 +	{
 +		name:    "SliceMake",
 +		generic: true,
 +	},
 +	{
 +		name:    "SlicePtr",
 +		generic: true,
 +	},
 +	{
 +		name:    "SliceLen",
 +		generic: true,
 +	},
 +	{
 +		name:    "SliceCap",
 +		generic: true,
 +	},
 +	{
 +		name:    "ComplexMake",
 +		generic: true,
 +	},
 +	{
 +		name:    "ComplexReal",
 +		generic: true,
 +	},
 +	{
 +		name:    "ComplexImag",
 +		generic: true,
 +	},
 +	{
 +		name:    "StringMake",
 +		generic: true,
 +	},
 +	{
 +		name:    "StringPtr",
 +		generic: true,
 +	},
 +	{
 +		name:    "StringLen",
 +		generic: true,
 +	},
 +	{
 +		name:    "IMake",
 +		generic: true,
 +	},
 +	{
 +		name:    "ITab",
 +		generic: true,
 +	},
 +	{
 +		name:    "IData",
 +		generic: true,
 +	},
 +	{
 +		name:    "StoreReg",
 +		generic: true,
 +	},
 +	{
 +		name:    "LoadReg",
 +		generic: true,
 +	},
 +	{
 +		name:    "FwdRef",
 +		generic: true,
 +	},
 +	{
 +		name:    "VarDef",
 +		generic: true,
 +	},
 +	{
 +		name:    "VarKill",
 +		generic: true,
 +	},
++	{
++		name:    "VarLive",
++		generic: true,
++	},
 +}
 +
 +func (o Op) Asm() int       { return opcodeTable[o].asm }
 +func (o Op) String() string { return opcodeTable[o].name }
diff --cc test/nosplit.go
index b49a7ce8e5,3c4ae1079d..2bf7077808
--- a/test/nosplit.go
+++ b/test/nosplit.go
@@@ -303,13 -302,12 +302,13 @@@ TestCases
  				// Instead of rewriting the test cases above, adjust
  				// the first stack frame to use up the extra bytes.
  				if i == 0 {
- 					size += (obj.StackGuard - 128) - 128
 -					size += 592 - 128
++					size += (1024 - 128) - 128
  					// Noopt builds have a larger stackguard.
 -					// See ../cmd/dist/buildruntime.go:stackGuardMultiplier
 +					// See ../src/cmd/dist/buildruntime.go:stackGuardMultiplier
 +					// This increase is included in obj.StackGuard
  					for _, s := range strings.Split(os.Getenv("GO_GCFLAGS"), " ") {
  						if s == "-N" {
- 							size += obj.StackGuard
 -							size += 720
++							size += 1024
  						}
  					}
  				}
