commit f48cbfdf5629526ed49534e55298a5a12216ea0c
Author: Russ Cox <rsc@golang.org>
Date:   Fri Jan 16 16:12:14 2009 -0800

    convert tests; nothing interesting.
    
    R=r
    OCL=23012
    CL=23014
---
 src/lib/malloc.go                 |  4 +--
 test/235.go                       |  4 +--
 test/bigalg.go                    |  8 +++---
 test/bugs/bug041.go               | 10 +++----
 test/bugs/bug117.go               |  4 +--
 test/bugs/bug121.go               |  6 ++---
 test/bugs/bug123.go               |  2 +-
 test/bugs/bug130.go               |  4 +--
 test/chan/fifo.go                 |  8 +++---
 test/chan/powser1.go              | 57 +++++++++++++++++++--------------------
 test/chan/powser2.go              | 57 +++++++++++++++++++--------------------
 test/chan/select.go               |  4 +--
 test/chan/sieve.go                |  6 ++---
 test/complit.go                   |  8 +++---
 test/convlit1.go                  |  4 ++-
 test/export.go                    |  4 +--
 test/fixedbugs/bug007.go          |  2 +-
 test/fixedbugs/bug011.go          |  2 +-
 test/fixedbugs/bug023.go          |  4 +--
 test/fixedbugs/bug025.go          |  4 +--
 test/fixedbugs/bug026.go          |  2 +-
 test/fixedbugs/bug027.go          |  6 ++---
 test/fixedbugs/bug028.go          |  2 +-
 test/fixedbugs/bug044.go          |  2 +-
 test/fixedbugs/bug045.go          |  2 +-
 test/fixedbugs/bug046.go          |  2 +-
 test/fixedbugs/bug054.go          |  6 ++---
 test/fixedbugs/bug057.go          |  2 +-
 test/fixedbugs/bug058.go          |  2 +-
 test/fixedbugs/bug059.go          |  2 +-
 test/fixedbugs/bug066.go          | 10 +++----
 test/fixedbugs/bug075.go          |  2 +-
 test/fixedbugs/bug083.dir/bug0.go |  5 ++--
 test/fixedbugs/bug084.go          |  2 +-
 test/fixedbugs/bug088.dir/bug0.go |  6 ++---
 test/fixedbugs/bug088.dir/bug1.go |  6 ++---
 test/fixedbugs/bug089.go          |  4 +--
 test/fixedbugs/bug093.go          |  4 +--
 test/fixedbugs/bug096.go          |  2 +-
 test/fixedbugs/bug097.go          |  2 +-
 test/fixedbugs/bug098.go          |  4 +--
 test/fixedbugs/bug099.go          |  8 +++---
 test/fixedbugs/bug110.go          |  8 +++---
 test/fixedbugs/bug112.go          |  2 +-
 test/fixedbugs/bug113.go          |  2 +-
 test/fixedbugs/bug114.go          |  6 ++---
 test/fixedbugs/bug120.go          |  2 +-
 test/func.go                      |  2 +-
 test/golden.out                   | 13 ++++-----
 test/hashmap.go                   | 14 +++++-----
 test/hilbert.go                   | 14 +++++-----
 test/interface.go                 |  8 +++---
 test/interface1.go                |  8 +++---
 test/interface2.go                |  6 ++---
 test/interface3.go                |  8 +++---
 test/interface4.go                | 14 +++++-----
 test/interface5.go                |  4 +--
 test/interface6.go                | 12 ++++-----
 test/iota.go                      |  4 +--
 test/ken/array.go                 |  8 +++---
 test/ken/chan.go                  | 10 +++----
 test/ken/embed.go                 | 16 +++++------
 test/ken/interbasic.go            |  2 +-
 test/ken/interfun.go              |  6 ++---
 test/ken/intervar.go              |  8 +++---
 test/ken/ptrfun.go                |  2 +-
 test/ken/rob1.go                  |  8 +++---
 test/ken/rob2.go                  | 28 +++++++++----------
 test/ken/robfunc.go               |  2 +-
 test/mallocrand.go                |  6 ++---
 test/mallocrep.go                 | 14 +++++-----
 test/mallocrep1.go                | 22 +++++++--------
 test/map.go                       |  2 +-
 test/method.go                    | 14 +++++-----
 test/method1.go                   |  2 +-
 test/method2.go                   |  6 ++---
 test/method3.go                   |  4 +--
 test/nil.go                       |  4 +--
 test/peano.go                     |  2 +-
 test/sieve.go                     |  6 ++---
 test/test0.go                     |  2 +-
 test/vectors.go                   |  2 +-
 82 files changed, 292 insertions(+), 296 deletions(-)

diff --git a/src/lib/malloc.go b/src/lib/malloc.go
index 3b81b4ed02..3d3f420d05 100644
--- a/src/lib/malloc.go
+++ b/src/lib/malloc.go
@@ -9,8 +9,8 @@
 package malloc
 
 export type Stats struct {
-	alloc	uint64;
-	sys	uint64;
+	Alloc	uint64;
+	Sys	uint64;
 };
 
 export func Alloc(uint64) *byte;
diff --git a/test/235.go b/test/235.go
index e24106dd00..b0381f35bc 100644
--- a/test/235.go
+++ b/test/235.go
@@ -6,9 +6,9 @@
 
 package main
 
-type T chan uint64;
+export type T chan uint64;
 
-func M(f uint64) (in, out T) {
+export func M(f uint64) (in, out T) {
 	in = make(T, 100);
 	out = make(T, 100);
 	go func(in, out T, f uint64) {
diff --git a/test/bigalg.go b/test/bigalg.go
index 434eecf5d2..a77a9ec8d1 100644
--- a/test/bigalg.go
+++ b/test/bigalg.go
@@ -11,7 +11,7 @@ import (
 	"fmt";
 )
 
-type T struct {
+export type T struct {
 	a float64;
 	b int64;
 	c string;
@@ -19,7 +19,7 @@ type T struct {
 }
 
 var a = []int{ 1, 2, 3 }
-var NIL []int;
+export var NIL []int;
 
 func arraycmptest() {
 	a1 := a;
@@ -34,7 +34,7 @@ func arraycmptest() {
 	}
 }
 
-func SameArray(a, b []int) bool {
+export func SameArray(a, b []int) bool {
 	if len(a) != len(b) || cap(a) != cap(b) {
 		return false;
 	}
@@ -103,7 +103,7 @@ func chantest() {
 	}
 }
 
-type E struct { }
+export type E struct { }
 var e E
 
 func interfacetest() {
diff --git a/test/bugs/bug041.go b/test/bugs/bug041.go
index f565666691..da708ab980 100644
--- a/test/bugs/bug041.go
+++ b/test/bugs/bug041.go
@@ -2,15 +2,15 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// $G $D/$F.go && echo BUG: compilation succeeds incorrectly
+// ! $G $D/$F.go || echo BUG: compilation succeeds incorrectly
 
 package main
 
-type T struct
-type S struct {
-  p *T  // BUG T never declared
+type t struct
+type s struct {
+  p *t  // BUG t never declared
 }
 
 func main() {
-  var s S;
+  var s1 s;
 }
diff --git a/test/bugs/bug117.go b/test/bugs/bug117.go
index a18e68849a..2707350cc6 100644
--- a/test/bugs/bug117.go
+++ b/test/bugs/bug117.go
@@ -5,8 +5,8 @@
 // license that can be found in the LICENSE file.
 
 package main
-type S struct { a int }
-type PS *S
+export type S struct { a int }
+export type PS *S
 func (p *S) get() int {
   return p.a
 }
diff --git a/test/bugs/bug121.go b/test/bugs/bug121.go
index cc960e318c..815faeffd6 100644
--- a/test/bugs/bug121.go
+++ b/test/bugs/bug121.go
@@ -6,14 +6,14 @@
 
 package main
 
-type T ()
+export type T ()
 
-type I interface {
+export type I interface {
 	f, g ();
 	h T;  // should only allow FunctionType here
 }
 
-type S struct {
+export type S struct {
 }
 
 func (s *S) f() {}
diff --git a/test/bugs/bug123.go b/test/bugs/bug123.go
index 0576de37d6..c3b8ff51cd 100644
--- a/test/bugs/bug123.go
+++ b/test/bugs/bug123.go
@@ -5,7 +5,7 @@
 // license that can be found in the LICENSE file.
 
 package main
-const ( F = 1 )
+export const ( F = 1 )
 func fn(i int) int {
   if i == F() {		// ERROR "function"
     return 0
diff --git a/test/bugs/bug130.go b/test/bugs/bug130.go
index aa3f0dd70e..1bcf05a9d4 100644
--- a/test/bugs/bug130.go
+++ b/test/bugs/bug130.go
@@ -6,9 +6,9 @@
 
 package main
 
-type I interface { send(chan <- int) }
+export type I interface { send(chan <- int) }
 
-type S struct { v int }
+export type S struct { v int }
 func (p *S) send(c chan <- int) { c <- p.v }
 
 func main() {
diff --git a/test/chan/fifo.go b/test/chan/fifo.go
index ad53ab6558..5df4918453 100644
--- a/test/chan/fifo.go
+++ b/test/chan/fifo.go
@@ -8,9 +8,9 @@
 
 package main
 
-const N = 10
+export const N = 10
 
-func AsynchFifo() {
+export func AsynchFifo() {
 	ch := make(chan int, N);
 	for i := 0; i < N; i++ {
 		ch <- i
@@ -23,7 +23,7 @@ func AsynchFifo() {
 	}
 }
 
-func Chain(ch <-chan int, val int, in <-chan int, out chan<- int) {
+export func Chain(ch <-chan int, val int, in <-chan int, out chan<- int) {
 	<-in;
 	if <-ch != val {
 		panic(val)
@@ -32,7 +32,7 @@ func Chain(ch <-chan int, val int, in <-chan int, out chan<- int) {
 }
 
 // thread together a daisy chain to read the elements in sequence
-func SynchFifo() {
+export func SynchFifo() {
 	ch := make(chan int);
 	in := make(chan int);
 	start := in;
diff --git a/test/chan/powser1.go b/test/chan/powser1.go
index 3b63891696..6326fb241a 100644
--- a/test/chan/powser1.go
+++ b/test/chan/powser1.go
@@ -41,7 +41,7 @@ var chnames string
 var chnameserial int
 var seqno int
 
-func Init();
+export func Init();
 
 func mkdch() *dch {
 	c := chnameserial % len(chnames);
@@ -176,11 +176,11 @@ func repeat(dat item, out *dch){
 	}
 }
 
-type PS *dch;	// power series
-type PS2 *[2] PS; // pair of power series
+export type PS *dch;	// power series
+export type PS2 *[2] PS; // pair of power series
 
-var Ones PS
-var Twos PS
+export var Ones PS
+export var Twos PS
 
 func mkPS() *dch {
 	return mkdch()
@@ -266,8 +266,7 @@ func inv(u *rat) *rat{	// invert a rat
 }
 
 // print eval in floating point of PS at x=c to n terms
-func
-Evaln(c *rat, U PS, n int)
+export func Evaln(c *rat, U PS, n int)
 {
 	xn := float64(1);
 	x := float64(c.num)/float64(c.den);
@@ -284,7 +283,7 @@ Evaln(c *rat, U PS, n int)
 }
 
 // Print n terms of a power series
-func Printn(U PS, n int){
+export func Printn(U PS, n int){
 	done := false;
 	for ; !done && n>0; n-- {
 		u := get(U);
@@ -294,7 +293,7 @@ func Printn(U PS, n int){
 	print(("\n"));
 }
 
-func Print(U PS){
+export func Print(U PS){
 	Printn(U,1000000000);
 }
 
@@ -312,14 +311,14 @@ func eval(c *rat, U PS, n int) *rat{
 
 // Make a pair of power series identical to a given power series
 
-func Split(U PS) *dch2{
+export func Split(U PS) *dch2{
 	UU := mkdch2();
 	go split(U,UU);
 	return UU;
 }
 
 // Add two power series
-func Add(U, V PS) PS{
+export func Add(U, V PS) PS{
 	Z := mkPS();
 	go func(U, V, Z PS){
 		var uv [] *rat;
@@ -344,7 +343,7 @@ func Add(U, V PS) PS{
 }
 
 // Multiply a power series by a constant
-func Cmul(c *rat,U PS) PS{
+export func Cmul(c *rat,U PS) PS{
 	Z := mkPS();
 	go func(c *rat, U, Z PS){
 		done := false;
@@ -361,13 +360,13 @@ func Cmul(c *rat,U PS) PS{
 
 // Subtract
 
-func Sub(U, V PS) PS{
+export func Sub(U, V PS) PS{
 	return Add(U, Cmul(neg(one), V));
 }
 
 // Multiply a power series by the monomial x^n
 
-func Monmul(U PS, n int) PS{
+export func Monmul(U PS, n int) PS{
 	Z := mkPS();
 	go func(n int, U PS, Z PS){
 		for ; n>0; n-- { put(zero,Z) }
@@ -378,11 +377,11 @@ func Monmul(U PS, n int) PS{
 
 // Multiply by x
 
-func Xmul(U PS) PS{
+export func Xmul(U PS) PS{
 	return Monmul(U,1);
 }
 
-func Rep(c *rat) PS{
+export func Rep(c *rat) PS{
 	Z := mkPS();
 	go repeat(c,Z);
 	return Z;
@@ -390,7 +389,7 @@ func Rep(c *rat) PS{
 
 // Monomial c*x^n
 
-func Mon(c *rat, n int) PS{
+export func Mon(c *rat, n int) PS{
 	Z:=mkPS();
 	go func(c *rat, n int, Z PS){
 		if(c.num!=0) {
@@ -402,7 +401,7 @@ func Mon(c *rat, n int) PS{
 	return Z;
 }
 
-func Shift(c *rat, U PS) PS{
+export func Shift(c *rat, U PS) PS{
 	Z := mkPS();
 	go func(c *rat, U, Z PS){
 		put(c,Z);
@@ -417,7 +416,7 @@ func Shift(c *rat, U PS) PS{
 // to a (finite) power series
 
 /* BUG: NEED LEN OF ARRAY
-func Poly(a [] *rat) PS{
+export func Poly(a [] *rat) PS{
 	Z:=mkPS();
 	begin func(a [] *rat, Z PS){
 		j:=0;
@@ -437,7 +436,7 @@ func Poly(a [] *rat) PS{
 //	let V = v + x*VV
 //	then UV = u*v + x*(u*VV+v*UU) + x*x*UU*VV
 
-func Mul(U, V PS) PS{
+export func Mul(U, V PS) PS{
 	Z:=mkPS();
 	go func(U, V, Z PS){
 		<-Z.req;
@@ -459,7 +458,7 @@ func Mul(U, V PS) PS{
 
 // Differentiate
 
-func Diff(U PS) PS{
+export func Diff(U PS) PS{
 	Z:=mkPS();
 	go func(U, Z PS){
 		<-Z.req;
@@ -481,7 +480,7 @@ func Diff(U PS) PS{
 }
 
 // Integrate, with const of integration
-func Integ(c *rat,U PS) PS{
+export func Integ(c *rat,U PS) PS{
 	Z:=mkPS();
 	go func(c *rat, U, Z PS){
 		put(c,Z);
@@ -499,7 +498,7 @@ func Integ(c *rat,U PS) PS{
 
 // Binomial theorem (1+x)^c
 
-func Binom(c *rat) PS{
+export func Binom(c *rat) PS{
 	Z:=mkPS();
 	go func(c *rat, Z PS){
 		n := 1;
@@ -523,7 +522,7 @@ func Binom(c *rat) PS{
 //	u*ZZ + z*UU +x*UU*ZZ = 0
 //	ZZ = -UU*(z+x*ZZ)/u;
 
-func Recip(U PS) PS{
+export func Recip(U PS) PS{
 	Z:=mkPS();
 	go func(U, Z PS){
 		ZZ:=mkPS2();
@@ -543,7 +542,7 @@ func Recip(U PS) PS{
 //	DZ = Z*DU
 //	integrate to get Z
 
-func Exp(U PS) PS{
+export func Exp(U PS) PS{
 	ZZ := mkPS2();
 	split(Integ(one,Mul(ZZ[0],Diff(U))),ZZ);
 	return ZZ[1];
@@ -555,7 +554,7 @@ func Exp(U PS) PS{
 // 	then S(U,V) = u + VV*S(V,UU)
 // bug: a nonzero constant term is ignored
 
-func Subst(U, V PS) PS {
+export func Subst(U, V PS) PS {
 	Z:= mkPS();
 	go func(U, V, Z PS) {
 		VV := Split(V);
@@ -573,7 +572,7 @@ func Subst(U, V PS) PS {
 // Monomial Substition: U(c x^n)
 // Each Ui is multiplied by c^i and followed by n-1 zeros
 
-func MonSubst(U PS, c0 *rat, n int) PS {
+export func MonSubst(U PS, c0 *rat, n int) PS {
 	Z:= mkPS();
 	go func(U, Z PS, c0 *rat, n int) {
 		c := one;
@@ -596,7 +595,7 @@ func MonSubst(U PS, c0 *rat, n int) PS {
 }
 
 
-func Init() {
+export func Init() {
 	chnameserial = -1;
 	seqno = 0;
 	chnames = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
@@ -621,7 +620,7 @@ func check(U PS, c *rat, count int, str string) {
 	}
 }
 
-const N=10
+export const N=10
 func checka(U PS, a []*rat, str string) {
 	for i := 0; i < N; i++ {
 		check(U, a[i], 1, str);
diff --git a/test/chan/powser2.go b/test/chan/powser2.go
index 094bd2bfe0..0867025191 100644
--- a/test/chan/powser2.go
+++ b/test/chan/powser2.go
@@ -46,7 +46,7 @@ var chnames string
 var chnameserial int
 var seqno int
 
-func Init();
+export func Init();
 
 func mkdch() *dch {
 	c := chnameserial % len(chnames);
@@ -181,11 +181,11 @@ func repeat(dat item, out *dch){
 	}
 }
 
-type PS *dch;	// power series
-type PS2 *[2] PS; // pair of power series
+export type PS *dch;	// power series
+export type PS2 *[2] PS; // pair of power series
 
-var Ones PS
-var Twos PS
+export var Ones PS
+export var Twos PS
 
 func mkPS() *dch {
 	return mkdch()
@@ -271,8 +271,7 @@ func inv(u *rat) *rat{	// invert a rat
 }
 
 // print eval in floating point of PS at x=c to n terms
-func
-Evaln(c *rat, U PS, n int)
+export func Evaln(c *rat, U PS, n int)
 {
 	xn := float64(1);
 	x := float64(c.num)/float64(c.den);
@@ -289,7 +288,7 @@ Evaln(c *rat, U PS, n int)
 }
 
 // Print n terms of a power series
-func Printn(U PS, n int){
+export func Printn(U PS, n int){
 	done := false;
 	for ; !done && n>0; n-- {
 		u := get(U);
@@ -299,7 +298,7 @@ func Printn(U PS, n int){
 	print(("\n"));
 }
 
-func Print(U PS){
+export func Print(U PS){
 	Printn(U,1000000000);
 }
 
@@ -317,14 +316,14 @@ func eval(c *rat, U PS, n int) *rat{
 
 // Make a pair of power series identical to a given power series
 
-func Split(U PS) *dch2{
+export func Split(U PS) *dch2{
 	UU := mkdch2();
 	go split(U,UU);
 	return UU;
 }
 
 // Add two power series
-func Add(U, V PS) PS{
+export func Add(U, V PS) PS{
 	Z := mkPS();
 	go func(U, V, Z PS){
 		var uv [] item;
@@ -349,7 +348,7 @@ func Add(U, V PS) PS{
 }
 
 // Multiply a power series by a constant
-func Cmul(c *rat,U PS) PS{
+export func Cmul(c *rat,U PS) PS{
 	Z := mkPS();
 	go func(c *rat, U, Z PS){
 		done := false;
@@ -366,13 +365,13 @@ func Cmul(c *rat,U PS) PS{
 
 // Subtract
 
-func Sub(U, V PS) PS{
+export func Sub(U, V PS) PS{
 	return Add(U, Cmul(neg(one), V));
 }
 
 // Multiply a power series by the monomial x^n
 
-func Monmul(U PS, n int) PS{
+export func Monmul(U PS, n int) PS{
 	Z := mkPS();
 	go func(n int, U PS, Z PS){
 		for ; n>0; n-- { put(zero,Z) }
@@ -383,11 +382,11 @@ func Monmul(U PS, n int) PS{
 
 // Multiply by x
 
-func Xmul(U PS) PS{
+export func Xmul(U PS) PS{
 	return Monmul(U,1);
 }
 
-func Rep(c *rat) PS{
+export func Rep(c *rat) PS{
 	Z := mkPS();
 	go repeat(c,Z);
 	return Z;
@@ -395,7 +394,7 @@ func Rep(c *rat) PS{
 
 // Monomial c*x^n
 
-func Mon(c *rat, n int) PS{
+export func Mon(c *rat, n int) PS{
 	Z:=mkPS();
 	go func(c *rat, n int, Z PS){
 		if(c.num!=0) {
@@ -407,7 +406,7 @@ func Mon(c *rat, n int) PS{
 	return Z;
 }
 
-func Shift(c *rat, U PS) PS{
+export func Shift(c *rat, U PS) PS{
 	Z := mkPS();
 	go func(c *rat, U, Z PS){
 		put(c,Z);
@@ -422,7 +421,7 @@ func Shift(c *rat, U PS) PS{
 // to a (finite) power series
 
 /* BUG: NEED LEN OF ARRAY
-func Poly(a [] *rat) PS{
+export func Poly(a [] *rat) PS{
 	Z:=mkPS();
 	begin func(a [] *rat, Z PS){
 		j:=0;
@@ -442,7 +441,7 @@ func Poly(a [] *rat) PS{
 //	let V = v + x*VV
 //	then UV = u*v + x*(u*VV+v*UU) + x*x*UU*VV
 
-func Mul(U, V PS) PS{
+export func Mul(U, V PS) PS{
 	Z:=mkPS();
 	go func(U, V, Z PS){
 		<-Z.req;
@@ -464,7 +463,7 @@ func Mul(U, V PS) PS{
 
 // Differentiate
 
-func Diff(U PS) PS{
+export func Diff(U PS) PS{
 	Z:=mkPS();
 	go func(U, Z PS){
 		<-Z.req;
@@ -486,7 +485,7 @@ func Diff(U PS) PS{
 }
 
 // Integrate, with const of integration
-func Integ(c *rat,U PS) PS{
+export func Integ(c *rat,U PS) PS{
 	Z:=mkPS();
 	go func(c *rat, U, Z PS){
 		put(c,Z);
@@ -504,7 +503,7 @@ func Integ(c *rat,U PS) PS{
 
 // Binomial theorem (1+x)^c
 
-func Binom(c *rat) PS{
+export func Binom(c *rat) PS{
 	Z:=mkPS();
 	go func(c *rat, Z PS){
 		n := 1;
@@ -528,7 +527,7 @@ func Binom(c *rat) PS{
 //	u*ZZ + z*UU +x*UU*ZZ = 0
 //	ZZ = -UU*(z+x*ZZ)/u;
 
-func Recip(U PS) PS{
+export func Recip(U PS) PS{
 	Z:=mkPS();
 	go func(U, Z PS){
 		ZZ:=mkPS2();
@@ -548,7 +547,7 @@ func Recip(U PS) PS{
 //	DZ = Z*DU
 //	integrate to get Z
 
-func Exp(U PS) PS{
+export func Exp(U PS) PS{
 	ZZ := mkPS2();
 	split(Integ(one,Mul(ZZ[0],Diff(U))),ZZ);
 	return ZZ[1];
@@ -560,7 +559,7 @@ func Exp(U PS) PS{
 // 	then S(U,V) = u + VV*S(V,UU)
 // bug: a nonzero constant term is ignored
 
-func Subst(U, V PS) PS {
+export func Subst(U, V PS) PS {
 	Z:= mkPS();
 	go func(U, V, Z PS) {
 		VV := Split(V);
@@ -578,7 +577,7 @@ func Subst(U, V PS) PS {
 // Monomial Substition: U(c x^n)
 // Each Ui is multiplied by c^i and followed by n-1 zeros
 
-func MonSubst(U PS, c0 *rat, n int) PS {
+export func MonSubst(U PS, c0 *rat, n int) PS {
 	Z:= mkPS();
 	go func(U, Z PS, c0 *rat, n int) {
 		c := one;
@@ -601,7 +600,7 @@ func MonSubst(U PS, c0 *rat, n int) PS {
 }
 
 
-func Init() {
+export func Init() {
 	chnameserial = -1;
 	seqno = 0;
 	chnames = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
@@ -626,7 +625,7 @@ func check(U PS, c *rat, count int, str string) {
 	}
 }
 
-const N=10
+export const N=10
 func checka(U PS, a []*rat, str string) {
 	for i := 0; i < N; i++ {
 		check(U, a[i], 1, str);
diff --git a/test/chan/select.go b/test/chan/select.go
index d8a462551a..009ee35c72 100644
--- a/test/chan/select.go
+++ b/test/chan/select.go
@@ -9,12 +9,12 @@ package main
 var counter uint
 var shift uint
 
-func GetValue() uint {
+export func GetValue() uint {
   counter++;
   return 1 << shift
 }
 
-func Send(a, b chan uint) int {
+export func Send(a, b chan uint) int {
   var i int;
   LOOP:
     for {
diff --git a/test/chan/sieve.go b/test/chan/sieve.go
index 0cebdc6412..b5330e7f86 100644
--- a/test/chan/sieve.go
+++ b/test/chan/sieve.go
@@ -10,7 +10,7 @@
 package main
 
 // Send the sequence 2, 3, 4, ... to channel 'ch'.
-func Generate(ch chan<- int) {
+export func Generate(ch chan<- int) {
 	for i := 2; ; i++ {
 		ch <- i  // Send 'i' to channel 'ch'.
 	}
@@ -18,7 +18,7 @@ func Generate(ch chan<- int) {
 
 // Copy the values from channel 'in' to channel 'out',
 // removing those divisible by 'prime'.
-func Filter(in <-chan int, out chan<- int, prime int) {
+export func Filter(in <-chan int, out chan<- int, prime int) {
 	for {
 		i := <-in;  // Receive value of new variable 'i' from 'in'.
 		if i % prime != 0 {
@@ -28,7 +28,7 @@ func Filter(in <-chan int, out chan<- int, prime int) {
 }
 
 // The prime sieve: Daisy-chain Filter processes together.
-func Sieve(primes chan<- int) {
+export func Sieve(primes chan<- int) {
 	ch := make(chan int);  // Create a new channel.
 	go Generate(ch);  // Start Generate() as a subprocess.
 	for {
diff --git a/test/complit.go b/test/complit.go
index d9b9488519..55159be855 100644
--- a/test/complit.go
+++ b/test/complit.go
@@ -6,9 +6,9 @@
 
 package main
 
-type T struct { i int; f float; s string; next *T }
+export type T struct { i int; f float; s string; next *T }
 
-type R struct { num int }
+export type R struct { num int }
 
 func itor(a int) *R {
 	r := new(R);
@@ -22,8 +22,8 @@ func eq(a []*R) {
 	}
 }
 
-type P struct { a, b int };
-func NewP(a, b int) *P {
+export type P struct { a, b int };
+export func NewP(a, b int) *P {
 	return &P{a, b}
 }
 
diff --git a/test/convlit1.go b/test/convlit1.go
index 063a1e504d..94d28969b7 100644
--- a/test/convlit1.go
+++ b/test/convlit1.go
@@ -10,6 +10,8 @@ var a = []int { "a" };	// ERROR "conver|incompatible"
 var b = int { 1 };	// ERROR "compos"
 
 
+func f() int
+
 func main() {
-	if sys.argc < 1 { }	// ERROR "conver|incompatible"
+	if f < 1 { }	// ERROR "conver|incompatible"
 }
diff --git a/test/export.go b/test/export.go
index 7ac0424421..b1f033a160 100644
--- a/test/export.go
+++ b/test/export.go
@@ -12,5 +12,5 @@ export type B interface	// ERROR "incomplete"
 export type C struct
 export type D interface
 
-type C struct { }
-type D interface { }
+export type C struct { }
+export type D interface { }
diff --git a/test/fixedbugs/bug007.go b/test/fixedbugs/bug007.go
index bd970de5f9..992276c678 100644
--- a/test/fixedbugs/bug007.go
+++ b/test/fixedbugs/bug007.go
@@ -6,7 +6,7 @@
 
 package main
 
-type (
+export type (
 	Point struct { x, y float };
 	Polar Point
 )
diff --git a/test/fixedbugs/bug011.go b/test/fixedbugs/bug011.go
index 63673c0865..aaa920a6bb 100644
--- a/test/fixedbugs/bug011.go
+++ b/test/fixedbugs/bug011.go
@@ -7,7 +7,7 @@
 package main
 
 
-type T struct {
+export type T struct {
 	x, y int;
 }
 
diff --git a/test/fixedbugs/bug023.go b/test/fixedbugs/bug023.go
index cce8c4543e..6a189b4701 100644
--- a/test/fixedbugs/bug023.go
+++ b/test/fixedbugs/bug023.go
@@ -6,11 +6,11 @@
 
 package main
 
-type Type interface {
+export type Type interface {
 	TypeName() string;
 }
 
-type TInt struct {
+export type TInt struct {
 }
 
 // TInt
diff --git a/test/fixedbugs/bug025.go b/test/fixedbugs/bug025.go
index f8aa68d5dd..4d4e954bf3 100644
--- a/test/fixedbugs/bug025.go
+++ b/test/fixedbugs/bug025.go
@@ -2,11 +2,11 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// ! $G $D/$F.go
+// # ! $G $D/$F.go
 
 package main
 
-export Foo
+export foo
 
 func main() {}
 
diff --git a/test/fixedbugs/bug026.go b/test/fixedbugs/bug026.go
index 1d97c18ae5..d64d0627eb 100644
--- a/test/fixedbugs/bug026.go
+++ b/test/fixedbugs/bug026.go
@@ -6,7 +6,7 @@
 
 package main
 
-type Element interface {
+export type Element interface {
 }
 
 export type Vector struct {
diff --git a/test/fixedbugs/bug027.go b/test/fixedbugs/bug027.go
index 16300502b8..9de26af2fa 100644
--- a/test/fixedbugs/bug027.go
+++ b/test/fixedbugs/bug027.go
@@ -6,15 +6,15 @@
 
 package main
 
-type Element interface {
+export type Element interface {
 }
 
-type Vector struct {
+export type Vector struct {
 	nelem int;
 	elem []Element;
 }
 
-func New() *Vector {
+export func New() *Vector {
 	v := new(Vector);
 	v.nelem = 0;
 	v.elem = make([]Element, 10);
diff --git a/test/fixedbugs/bug028.go b/test/fixedbugs/bug028.go
index 0488ad2cba..4990ac2866 100644
--- a/test/fixedbugs/bug028.go
+++ b/test/fixedbugs/bug028.go
@@ -7,7 +7,7 @@
 package main
 
 
-func Alloc(i int) int {
+export func Alloc(i int) int {
 	switch i {
 	default:
 		return 5;
diff --git a/test/fixedbugs/bug044.go b/test/fixedbugs/bug044.go
index 789237abe6..52ee033084 100644
--- a/test/fixedbugs/bug044.go
+++ b/test/fixedbugs/bug044.go
@@ -6,7 +6,7 @@
 
 package main
 
-type S struct {
+export type S struct {
 };
 
 func (p *S) M1a() ;
diff --git a/test/fixedbugs/bug045.go b/test/fixedbugs/bug045.go
index 88c005d32d..b4ae6de0a5 100644
--- a/test/fixedbugs/bug045.go
+++ b/test/fixedbugs/bug045.go
@@ -6,7 +6,7 @@
 
 package main
 
-type T struct {
+export type T struct {
 	i int
 }
 
diff --git a/test/fixedbugs/bug046.go b/test/fixedbugs/bug046.go
index 8a9b797074..bd3a1e2f90 100644
--- a/test/fixedbugs/bug046.go
+++ b/test/fixedbugs/bug046.go
@@ -6,7 +6,7 @@
 
 package main
 
-type T *struct {}
+export type T *struct {}
 
 func (x T) M () {}  // ERROR "pointer|receiver"
 
diff --git a/test/fixedbugs/bug054.go b/test/fixedbugs/bug054.go
index 0ed5d07082..35cfc9204d 100644
--- a/test/fixedbugs/bug054.go
+++ b/test/fixedbugs/bug054.go
@@ -6,10 +6,10 @@
 
 package main
 
-type Element interface {
+export type Element interface {
 }
 
-type Vector struct {
+export type Vector struct {
 	elem []Element;
 }
 
@@ -17,7 +17,7 @@ func (v *Vector) At(i int) Element {
 	return v.elem[i];
 }
 
-type TStruct struct {
+export type TStruct struct {
 	name string;
 	fields *Vector;
 }
diff --git a/test/fixedbugs/bug057.go b/test/fixedbugs/bug057.go
index dd6df5c315..e0a60dc377 100644
--- a/test/fixedbugs/bug057.go
+++ b/test/fixedbugs/bug057.go
@@ -6,7 +6,7 @@
 
 package main
 
-type T struct {
+export type T struct {
   s string;
 }
 
diff --git a/test/fixedbugs/bug058.go b/test/fixedbugs/bug058.go
index da47ae5687..3765dfc35c 100644
--- a/test/fixedbugs/bug058.go
+++ b/test/fixedbugs/bug058.go
@@ -6,7 +6,7 @@
 
 package main
 
-type Box struct {};
+export type Box struct {};
 var m map[string] *Box;
 
 func main() {
diff --git a/test/fixedbugs/bug059.go b/test/fixedbugs/bug059.go
index 21c078361b..d1f3b13b25 100644
--- a/test/fixedbugs/bug059.go
+++ b/test/fixedbugs/bug059.go
@@ -6,7 +6,7 @@
 
 package main
 
-func P(a []string) string {
+export func P(a []string) string {
 	s := "{";
 	for i := 0; i < 2; i++ {
 		if i > 0 {
diff --git a/test/fixedbugs/bug066.go b/test/fixedbugs/bug066.go
index 4f64152aec..ce021af3f1 100644
--- a/test/fixedbugs/bug066.go
+++ b/test/fixedbugs/bug066.go
@@ -6,26 +6,26 @@
 
 package main
 
-type (
+export type (
 	Type struct;
 	Object struct;
 )
 
-type Scope struct {
+export type Scope struct {
 	entries map[string] *Object;
 }
 
 
-type Type struct {
+export type Type struct {
 	scope *Scope;
 }
 
 
-type Object struct {
+export type Object struct {
 	typ *Type;
 }
 
 
-func Lookup(scope *Scope) *Object {
+export func Lookup(scope *Scope) *Object {
 	return scope.entries["foo"];
 }
diff --git a/test/fixedbugs/bug075.go b/test/fixedbugs/bug075.go
index fceeef8cba..76b5189343 100644
--- a/test/fixedbugs/bug075.go
+++ b/test/fixedbugs/bug075.go
@@ -6,7 +6,7 @@
 
 package main
 
-type T struct { m map[int]int }
+export type T struct { m map[int]int }
 func main() {
 	t := new(T);
 	t.m = make(map[int]int);
diff --git a/test/fixedbugs/bug083.dir/bug0.go b/test/fixedbugs/bug083.dir/bug0.go
index 3636a7aa35..58c4c49717 100644
--- a/test/fixedbugs/bug083.dir/bug0.go
+++ b/test/fixedbugs/bug083.dir/bug0.go
@@ -4,8 +4,7 @@
 
 package bug0
 
-type T0 struct {
+export type T0 struct {
 }
 
-export v0
-var v0 T0
+export var V0 T0
diff --git a/test/fixedbugs/bug084.go b/test/fixedbugs/bug084.go
index 2897593dcd..23e5e00ca3 100644
--- a/test/fixedbugs/bug084.go
+++ b/test/fixedbugs/bug084.go
@@ -6,7 +6,7 @@
 
 package main
 
-type Service struct {
+export type Service struct {
 	rpc [2]int;
 }
 
diff --git a/test/fixedbugs/bug088.dir/bug0.go b/test/fixedbugs/bug088.dir/bug0.go
index 0336e78150..3536e81cb7 100644
--- a/test/fixedbugs/bug088.dir/bug0.go
+++ b/test/fixedbugs/bug088.dir/bug0.go
@@ -4,6 +4,6 @@
 
 package bug0
 
-export var v0 *() int;
-export var v1 *() (a int);
-export var v2 *() (a, b int);
+export var V0 *() int;
+export var V1 *() (a int);
+export var V2 *() (a, b int);
diff --git a/test/fixedbugs/bug088.dir/bug1.go b/test/fixedbugs/bug088.dir/bug1.go
index 7b78ad2459..7c21c25dea 100644
--- a/test/fixedbugs/bug088.dir/bug1.go
+++ b/test/fixedbugs/bug088.dir/bug1.go
@@ -7,9 +7,9 @@ package main
 import P "bug0"
 
 func main() {
-	a0 := P.v0();  // works
-	a1 := P.v1();  // works
-	a2, b2 := P.v2();  // doesn't work
+	a0 := P.V0();  // works
+	a1 := P.V1();  // works
+	a2, b2 := P.V2();  // doesn't work
 }
 
 /*
diff --git a/test/fixedbugs/bug089.go b/test/fixedbugs/bug089.go
index 296e9e6d6d..55d4dfba70 100644
--- a/test/fixedbugs/bug089.go
+++ b/test/fixedbugs/bug089.go
@@ -6,8 +6,8 @@
 
 package main
 
-type	I1	interface {}
-type	I2	interface { pr() }
+export type	I1	interface {}
+export type	I2	interface { pr() }
 
 func	e()	I1;
 
diff --git a/test/fixedbugs/bug093.go b/test/fixedbugs/bug093.go
index f80eee01fa..3adbc5abbb 100644
--- a/test/fixedbugs/bug093.go
+++ b/test/fixedbugs/bug093.go
@@ -6,14 +6,14 @@
 
 package main
 
-type S struct {
+export type S struct {
 }
 
 func (p *S) M() {
 	print("M\n");
 }
 
-type I interface {
+export type I interface {
 	M();
 }
 
diff --git a/test/fixedbugs/bug096.go b/test/fixedbugs/bug096.go
index f66caa5c01..418f9f27c0 100644
--- a/test/fixedbugs/bug096.go
+++ b/test/fixedbugs/bug096.go
@@ -6,7 +6,7 @@
 
 package main
 
-type A []int;
+export type A []int;
 
 func main() {
 	a := &A{0};
diff --git a/test/fixedbugs/bug097.go b/test/fixedbugs/bug097.go
index 70bd6e2b47..cd815d7664 100644
--- a/test/fixedbugs/bug097.go
+++ b/test/fixedbugs/bug097.go
@@ -6,7 +6,7 @@
 
 package main
 
-type A []int;
+export type A []int;
 
 func main() {
 	var a [3]A;
diff --git a/test/fixedbugs/bug098.go b/test/fixedbugs/bug098.go
index 8e790a709a..7c20d926be 100644
--- a/test/fixedbugs/bug098.go
+++ b/test/fixedbugs/bug098.go
@@ -6,8 +6,8 @@
 
 package main
 
-type A []int;
-type M map[int] int;
+export type A []int;
+export type M map[int] int;
 
 func main() {
 	var a *A = &A{0};
diff --git a/test/fixedbugs/bug099.go b/test/fixedbugs/bug099.go
index f76f0e873c..9bf3525e64 100644
--- a/test/fixedbugs/bug099.go
+++ b/test/fixedbugs/bug099.go
@@ -7,22 +7,22 @@
 package main
 
 // Interface
-type I interface { F() int }
+export type I interface { F() int }
 
 // Implements interface
-type S struct { }
+export type S struct { }
 func (s *S) F() int { return 1 }
 
 // Allocates S but returns I
 // Arg is unused but important:
 // if you take it out (and the 0s below)
 // then the bug goes away.
-func NewI(i int) I {
+export func NewI(i int) I {
 	return new(S)
 }
 
 // Uses interface method.
-func Use(x I) {
+export func Use(x I) {
 	x.F()
 }
 
diff --git a/test/fixedbugs/bug110.go b/test/fixedbugs/bug110.go
index 84273b4758..b5e5875919 100644
--- a/test/fixedbugs/bug110.go
+++ b/test/fixedbugs/bug110.go
@@ -6,14 +6,14 @@
 
 package main
 
-const A = 0
+const a = 0
 
 func f() {
-	const A = 5
+	const a = 5
 }
 
 func main() {
-	if A != 0 {
-		panic("A=", A)
+	if a != 0 {
+		panic("a=", a)
 	}
 }
diff --git a/test/fixedbugs/bug112.go b/test/fixedbugs/bug112.go
index 3c932843c7..b8d3357f0d 100644
--- a/test/fixedbugs/bug112.go
+++ b/test/fixedbugs/bug112.go
@@ -6,7 +6,7 @@
 
 package main
 
-type T struct { s string }
+export type T struct { s string }
 var t = T{"hi"}
 
 func main() {}
diff --git a/test/fixedbugs/bug113.go b/test/fixedbugs/bug113.go
index ea75260cf2..f2f8ee7b34 100644
--- a/test/fixedbugs/bug113.go
+++ b/test/fixedbugs/bug113.go
@@ -5,7 +5,7 @@
 // license that can be found in the LICENSE file.
 
 package main
-type I interface { };
+export type I interface { };
 func foo1(i int) int { return i }
 func foo2(i int32) int32 { return i }
 func main() {
diff --git a/test/fixedbugs/bug114.go b/test/fixedbugs/bug114.go
index 33330fff8e..431d7bb2dc 100644
--- a/test/fixedbugs/bug114.go
+++ b/test/fixedbugs/bug114.go
@@ -6,9 +6,9 @@
 
 package main
 
-const B32 = 1<<32 - 1
-const C32 = (-1) & ((1<<32) - 1)
-const D32 = ^0
+export const B32 = 1<<32 - 1
+export const C32 = (-1) & ((1<<32) - 1)
+export const D32 = ^0
 
 func main() {
 	if B32 != 0xFFFFFFFF {
diff --git a/test/fixedbugs/bug120.go b/test/fixedbugs/bug120.go
index 10e28034dc..dae78e91cd 100644
--- a/test/fixedbugs/bug120.go
+++ b/test/fixedbugs/bug120.go
@@ -8,7 +8,7 @@ package main
 
 import "strconv";
 
-type Test struct {
+export type Test struct {
 	f float64;
 	in string;
 	out string;
diff --git a/test/func.go b/test/func.go
index ee9414ddc4..3a357f895c 100644
--- a/test/func.go
+++ b/test/func.go
@@ -45,7 +45,7 @@ func f8(a int) (x int, y float) {
 	return 8, 8.0;
 }
 
-type T struct {
+export type T struct {
 	x, y int;
 }
 
diff --git a/test/golden.out b/test/golden.out
index 326327bbc1..ac8c788b07 100644
--- a/test/golden.out
+++ b/test/golden.out
@@ -19,7 +19,7 @@ errchk: ./convlit.go: unmatched error messages:
 hello, world
 
 =========== ./interface2.go
-cannot convert type *main.S·interface2 to interface main.I·interface2: missing method Foo
+cannot convert type *main.S to interface main.I: missing method Foo
 throw: interface conversion
 SIGSEGV: segmentation violation
 Faulting address: 0x0
@@ -27,7 +27,7 @@ pc: xxx
 
 
 =========== ./interface3.go
-cannot convert type *main.S·interface3 to interface main.I2·interface3: missing method Name
+cannot convert type *main.S to interface main.I2: missing method Name
 throw: interface conversion
 SIGSEGV: segmentation violation
 Faulting address: 0x0
@@ -86,7 +86,7 @@ abcxyz-abcxyz-abcxyz-abcxyz-abcxyz-abcxyz-abcxyz
 PASS
 
 =========== bugs/bug041.go
-BUG: compilation succeeds incorrectly
+bugs/bug041.go:5: export of incomplete type t
 
 =========== bugs/bug064.go
 bugs/bug064.go:15: illegal types for operand: CALL
@@ -149,9 +149,6 @@ BUG: should not compile
 =========== fixedbugs/bug016.go
 fixedbugs/bug016.go:7: overflow converting constant to uint
 
-=========== fixedbugs/bug025.go
-fixedbugs/bug025.go:7: variable exported but not defined: Foo
-
 =========== fixedbugs/bug027.go
 hi
 0 44444
@@ -232,7 +229,7 @@ fixedbugs/bug074.go:7: x: undefined
 fixedbugs/bug081.go:5: no type x
 
 =========== fixedbugs/bug083.go
-fixedbugs/bug083.dir/bug1.go:5: syntax error near T0
+BUG: succeeds incorrectly
 
 =========== fixedbugs/bug086.go
 fixedbugs/bug086.go:5: function ends without a return statement
@@ -261,7 +258,7 @@ M
 fixedbugs/bug103.go:8: function requires a return type
 
 =========== fixedbugs/bug113.go
-main.I·bug113 is int, not int32
+main.I is int, not int32
 throw: interface conversion
 SIGSEGV: segmentation violation
 Faulting address: 0x0
diff --git a/test/hashmap.go b/test/hashmap.go
index 6f70f2b50c..4fe36f339f 100755
--- a/test/hashmap.go
+++ b/test/hashmap.go
@@ -9,7 +9,7 @@ package main
 // ----------------------------------------------------------------------------
 // Helper functions
 
-func ASSERT(p bool) {
+export func ASSERT(p bool) {
 	if !p {
 		// panic 0;
 	}
@@ -19,18 +19,18 @@ func ASSERT(p bool) {
 // ----------------------------------------------------------------------------
 // Implementation of the HashMap
 
-type KeyType interface {
+export type KeyType interface {
 	Hash() uint32;
 	Match(other *KeyType) bool
 }
 
 
-type ValueType interface {
+export type ValueType interface {
 	// empty interface
 }
 
 
-type Entry struct {
+export type Entry struct {
 	key *KeyType;
 	value *ValueType;
 }
@@ -39,7 +39,7 @@ type Entry struct {
 // Using the Array type below doesn't seem to work
 //type Array array [1024] Entry;
 
-type HashMap struct {
+export type HashMap struct {
 	map_ *[1024] Entry;
 	log2_capacity_ uint32;
 	occupancy_ uint32;
@@ -139,7 +139,7 @@ func (m *HashMap) Resize() {
 // ----------------------------------------------------------------------------
 // Test code
 
-type Number struct {
+export type Number struct {
 	x uint32;
 }
 
@@ -156,7 +156,7 @@ func (n *Number) Match(other *KeyType) bool {
 }
 
 
-func MakeNumber (x uint32) *Number {
+export func MakeNumber (x uint32) *Number {
 	var n *Number = new(Number);
 	n.x = x;
 	return n;
diff --git a/test/hilbert.go b/test/hilbert.go
index 163313e852..311ed9b2c4 100644
--- a/test/hilbert.go
+++ b/test/hilbert.go
@@ -21,13 +21,13 @@ func assert(p bool) {
 }
 
 
-var (
+export var (
 	Zero = Big.Rat(0, 1);
 	One = Big.Rat(1, 1);
 )
 
 
-type Matrix struct {
+export type Matrix struct {
 	n, m int;
 	a []*Big.Rational;
 }
@@ -45,7 +45,7 @@ func (a *Matrix) set(i, j int, x *Big.Rational) {
 }
 
 
-func NewMatrix(n, m int) *Matrix {
+export func NewMatrix(n, m int) *Matrix {
 	assert(0 <= n && 0 <= m);
 	a := new(Matrix);
 	a.n = n;
@@ -55,7 +55,7 @@ func NewMatrix(n, m int) *Matrix {
 }
 
 
-func NewUnit(n int) *Matrix {
+export func NewUnit(n int) *Matrix {
 	a := NewMatrix(n, n);
 	for i := 0; i < n; i++ {
 		for j := 0; j < n; j++ {
@@ -70,7 +70,7 @@ func NewUnit(n int) *Matrix {
 }
 
 
-func NewHilbert(n int) *Matrix {
+export func NewHilbert(n int) *Matrix {
 	a := NewMatrix(n, n);
 	for i := 0; i < n; i++ {
 		for j := 0; j < n; j++ {
@@ -82,12 +82,12 @@ func NewHilbert(n int) *Matrix {
 }
 
 
-func MakeRat(x Big.Natural) *Big.Rational {
+export func MakeRat(x Big.Natural) *Big.Rational {
 	return Big.MakeRat(Big.MakeInt(false, x), Big.Nat(1));
 }
 
 
-func NewInverseHilbert(n int) *Matrix {
+export func NewInverseHilbert(n int) *Matrix {
 	a := NewMatrix(n, n);
 	for i := 0; i < n; i++ {
 		for j := 0; j < n; j++ {
diff --git a/test/interface.go b/test/interface.go
index ee03f67f03..530d2883fa 100644
--- a/test/interface.go
+++ b/test/interface.go
@@ -6,17 +6,17 @@
 
 package main
 
-type I2 interface
+export type I2 interface
 
-type I1 interface {
+export type I1 interface {
 	foo() I2
 }
 
-type I2 interface {
+export type I2 interface {
 	bar() I1
 }
 
-type T int
+export type T int
 func (t T) bar() I1;
 func (t T) foo() I2 { return t }
 func (t T) bar() I1 { return t }
diff --git a/test/interface1.go b/test/interface1.go
index 649a955f6d..819829c721 100644
--- a/test/interface1.go
+++ b/test/interface1.go
@@ -6,23 +6,23 @@
 
 package main
 
-type Inst interface {
+export type Inst interface {
 	Next()	*Inst;
 }
 
-type Regexp struct {
+export type Regexp struct {
 	code []Inst;
 	start	Inst;
 }
 
-type Start struct {
+export type Start struct {
 	foo	*Inst;
 }
 
 func (start *Start) Next() *Inst { return nil }
 
 
-func AddInst(Inst) *Inst {
+export func AddInst(Inst) *Inst {
 	print("ok in addinst\n");
 	return nil
 }
diff --git a/test/interface2.go b/test/interface2.go
index 1db033887f..601c285baf 100644
--- a/test/interface2.go
+++ b/test/interface2.go
@@ -6,9 +6,9 @@
 
 package main
 
-type S struct
+export type S struct
 
-type I interface {
+export type I interface {
 	Foo()
 }
 
@@ -21,5 +21,5 @@ func main() {
 }
 
 // hide S down here to avoid static warning
-type S struct {
+export type S struct {
 }
diff --git a/test/interface3.go b/test/interface3.go
index 04af91a029..85cd02e13d 100644
--- a/test/interface3.go
+++ b/test/interface3.go
@@ -6,14 +6,14 @@
 
 package main
 
-type S struct { a int }
-type T struct { b string }
+export type S struct { a int }
+export type T struct { b string }
 
 func (s *S) Name() int8 { return 1 }
 func (t *T) Name() int64 { return 64 }
 
-type I1 interface { Name() int8 }
-type I2 interface { Name() int64 }
+export type I1 interface { Name() int8 }
+export type I2 interface { Name() int64 }
 
 func main() {
 	var i1 I1;
diff --git a/test/interface4.go b/test/interface4.go
index a55936df84..9df502b215 100644
--- a/test/interface4.go
+++ b/test/interface4.go
@@ -9,15 +9,15 @@
 
 package main
 
-type I interface { M() int64 }
+export type I interface { M() int64 }
 
-type BigPtr struct { a, b, c, d int64 }
+export type BigPtr struct { a, b, c, d int64 }
 func (z *BigPtr) M() int64 { return z.a+z.b+z.c+z.d }
 
-type SmallPtr struct { a int32 }
+export type SmallPtr struct { a int32 }
 func (z *SmallPtr) M() int64 { return int64(z.a) }
 
-type IntPtr int32
+export type IntPtr int32
 func (z *IntPtr) M() int64 { return int64(*z) }
 
 var bad bool
@@ -43,13 +43,13 @@ func ptrs() {
 	test("&intptr", &intptr);
 }
 
-type Big struct { a, b, c, d int64 }
+export type Big struct { a, b, c, d int64 }
 func (z Big) M() int64 { return z.a+z.b+z.c+z.d }
 
-type Small struct { a int32 }
+export type Small struct { a int32 }
 func (z Small) M() int64 { return int64(z.a) }
 
-type Int int32
+export type Int int32
 func (z Int) M() int64 { return int64(z) }
 
 func nonptrs() {
diff --git a/test/interface5.go b/test/interface5.go
index 2e273ddddb..3e816abfcc 100644
--- a/test/interface5.go
+++ b/test/interface5.go
@@ -6,10 +6,10 @@
 
 package main
 
-type T struct { a int }
+export type T struct { a int }
 var t *T
 
-type I interface { M() }
+export type I interface { M() }
 var i I
 
 func main() {
diff --git a/test/interface6.go b/test/interface6.go
index 6053e51d64..27b5740ade 100644
--- a/test/interface6.go
+++ b/test/interface6.go
@@ -15,9 +15,9 @@ func check(b bool, msg string) {
   }
 }
 
-type I1 interface { Get() int; Put(int); }
+export type I1 interface { Get() int; Put(int); }
 
-type S1 struct { i int }
+export type S1 struct { i int }
 func (p S1) Get() int { return p.i }
 func (p S1) Put(i int) { p.i = i }
 
@@ -45,7 +45,7 @@ func f3() {
   check(s.i == 1, "f3 s");
 }
 
-type S2 struct { i int }
+export type S2 struct { i int }
 func (p *S2) Get() int { return p.i }
 func (p *S2) Put(i int) { p.i = i }
 
@@ -73,9 +73,9 @@ func f6() {
   check(s.i == 2, "f6 s");
 }
 
-type I2 interface { Get() int64; Put(int64); }
+export type I2 interface { Get() int64; Put(int64); }
 
-type S3 struct { i, j, k, l int64 }
+export type S3 struct { i, j, k, l int64 }
 func (p S3) Get() int64 { return p.l }
 func (p S3) Put(i int64) { p.l = i }
 
@@ -103,7 +103,7 @@ func f9() {
   check(s.l == 4, "f9 s");
 }
 
-type S4 struct { i, j, k, l int64 }
+export type S4 struct { i, j, k, l int64 }
 func (p *S4) Get() int64 { return p.l }
 func (p *S4) Put(i int64) { p.l = i }
 
diff --git a/test/iota.go b/test/iota.go
index 393edac804..d6c0026a90 100644
--- a/test/iota.go
+++ b/test/iota.go
@@ -21,13 +21,13 @@ const (
 	g float = 4.5 * float(iota);
 )
 
-const (
+export const (
 	X = 0;
 	Y;
 	Z;
 )
 
-const (
+export const (
 	A = 1 << iota;
 	B;
 	C;
diff --git a/test/ken/array.go b/test/ken/array.go
index 2969f36693..e1a3aed3a8 100644
--- a/test/ken/array.go
+++ b/test/ken/array.go
@@ -6,7 +6,7 @@
 
 package	main
 
-export func
+func
 setpd(a []int)
 {
 //	print("setpd a=", a, " len=", len(a), " cap=", cap(a), "\n");
@@ -15,7 +15,7 @@ setpd(a []int)
 	}
 }
 
-export func
+func
 sumpd(a []int) int
 {
 //	print("sumpd a=", a, " len=", len(a), " cap=", cap(a), "\n");
@@ -27,7 +27,7 @@ sumpd(a []int) int
 	return t;
 }
 
-export func
+func
 setpf(a *[20]int)
 {
 //	print("setpf a=", a, " len=", len(a), " cap=", cap(a), "\n");
@@ -36,7 +36,7 @@ setpf(a *[20]int)
 	}
 }
 
-export func
+func
 sumpf(a *[20]int) int
 {
 //	print("sumpf a=", a, " len=", len(a), " cap=", cap(a), "\n");
diff --git a/test/ken/chan.go b/test/ken/chan.go
index a272c2bbc8..3bc3094975 100644
--- a/test/ken/chan.go
+++ b/test/ken/chan.go
@@ -19,7 +19,7 @@ nrand(n int) int
 	return randx%n;
 }
 
-type	Chan
+export type	Chan
 struct
 {
 	sc,rc	chan int;	// send and recv chan
@@ -30,7 +30,7 @@ var
 (
 	nproc		int;
 	cval		int;
-	End		int	= 10000;
+	end		int	= 10000;
 	totr,tots	int;
 	nc		*Chan;
 )
@@ -62,7 +62,7 @@ expect(v, v0 int) (newv int)
 {
 	if v == v0 {
 		if v%100 == 75 {
-			return End;
+			return end;
 		}
 		return v+1;
 	}
@@ -75,7 +75,7 @@ send() bool
 //	print("send ", c.sv, "\n");
 	tots++;
 	c.sv = expect(c.sv, c.sv);
-	if c.sv == End {
+	if c.sv == end {
 		c.sc = nil;
 		return true;
 	}
@@ -104,7 +104,7 @@ recv(v int) bool
 //	print("recv ", v, "\n");
 	totr++;
 	c.rv = expect(c.rv, v);
-	if c.rv == End {
+	if c.rv == end {
 		c.rc = nil;
 		return true;
 	}
diff --git a/test/ken/embed.go b/test/ken/embed.go
index f0c9f4ec2b..bc8240819b 100644
--- a/test/ken/embed.go
+++ b/test/ken/embed.go
@@ -7,7 +7,7 @@
 package main
 
 
-type
+export type
 I	interface
 {
 	test1,
@@ -23,7 +23,7 @@ I	interface
  ******
  ******/
 
-type
+export type
 SubpSubp	struct
 {
 	a7	int;
@@ -45,7 +45,7 @@ testx()
  ******
  ******/
 
-type
+export type
 SubpSub	struct
 {
 	a6	int;
@@ -68,7 +68,7 @@ testx()
  ******
  ******/
 
-type
+export type
 SubSubp	struct
 {
 	a5	int;
@@ -85,7 +85,7 @@ test5() int
  ******
  ******/
 
-type
+export type
 SubSub	struct
 {
 	a4	int;
@@ -102,7 +102,7 @@ test4() int
  ******
  ******/
 
-type
+export type
 Subp	struct
 {
 	a3	int;
@@ -121,7 +121,7 @@ test3() int
  ******
  ******/
 
-type
+export type
 Sub	struct
 {
 	a2	int;
@@ -140,7 +140,7 @@ test2() int
  ******
  ******/
 
-type
+export type
 S	struct
 {
 	a1	int;
diff --git a/test/ken/interbasic.go b/test/ken/interbasic.go
index 05eea395bb..54ce6ffbcc 100644
--- a/test/ken/interbasic.go
+++ b/test/ken/interbasic.go
@@ -8,7 +8,7 @@ package main
 
 type	myint		int;
 type	mystring	string;
-type	I0		interface {};
+export type	I0		interface {};
 
 func
 f()
diff --git a/test/ken/interfun.go b/test/ken/interfun.go
index 97db893168..55d2d442a0 100644
--- a/test/ken/interfun.go
+++ b/test/ken/interfun.go
@@ -6,17 +6,17 @@
 
 package main
 
-type S struct
+export type S struct
 {
 	a,b	int;
 }
 
-type I1 interface
+export type I1 interface
 {
 	f	()int;
 }
 
-type I2 interface
+export type I2 interface
 {
 	g,f	()int;
 }
diff --git a/test/ken/intervar.go b/test/ken/intervar.go
index 1c3d650006..31e7d98692 100644
--- a/test/ken/intervar.go
+++ b/test/ken/intervar.go
@@ -6,14 +6,14 @@
 
 package main
 
-type	Iputs	interface
+export type	Iputs	interface
 {
 	puts	(s string);
 }
 
 // ---------
 
-type	Print	struct
+export type	Print	struct
 {
 	whoami	int;
 	put	Iputs;
@@ -28,7 +28,7 @@ dop()
 
 // ---------
 
-type	Bio	struct
+export type	Bio	struct
 {
 	whoami	int;
 	put	Iputs;
@@ -43,7 +43,7 @@ puts(s string)
 
 // ---------
 
-type	File	struct
+export type	File	struct
 {
 	whoami	int;
 	put	Iputs;
diff --git a/test/ken/ptrfun.go b/test/ken/ptrfun.go
index e7db3a94d3..e2307cf509 100644
--- a/test/ken/ptrfun.go
+++ b/test/ken/ptrfun.go
@@ -7,7 +7,7 @@
 
 package main
 
-type C struct
+export type C struct
 {
 	a	int;
 	x	*(p *C)int;
diff --git a/test/ken/rob1.go b/test/ken/rob1.go
index a75878b1f5..b6d72c8bdc 100644
--- a/test/ken/rob1.go
+++ b/test/ken/rob1.go
@@ -6,18 +6,18 @@
 
 package main
 
-type Item interface
+export type Item interface
 {
 	Print();
 }
 
-type ListItem struct
+export type ListItem struct
 {
 	item    Item;
 	next    *ListItem;
 }
 
-type List struct
+export type List struct
 {
 	head    *ListItem;
 }
@@ -48,7 +48,7 @@ Print()
 }
 
 // Something to put in a list
-type Integer struct
+export type Integer struct
 {
 	val		int;
 }
diff --git a/test/ken/rob2.go b/test/ken/rob2.go
index 1b4d86e6f2..313ae586fc 100644
--- a/test/ken/rob2.go
+++ b/test/ken/rob2.go
@@ -9,24 +9,24 @@ package main
 
 const nilchar = 0;
 
-type (
+export type (
 	Atom struct;
 	List struct;
 	Slist struct;
 )
 
-type Atom struct {
+export type Atom struct {
 	str		string;
 	integer		int;
 	next		*Slist;	/* in hash bucket */
 }
 
-type List struct {
+export type List struct {
 	car		*Slist;
 	cdr*Slist;
 }
 
-type Slist struct {
+export type Slist struct {
 	isatom		bool;
 	isstring	bool;
 	//union {
@@ -67,8 +67,8 @@ func (slist *Slist) Free() {
 //	free(slist);
 }
 
-func OpenFile();
-func Parse() *Slist;
+export func OpenFile();
+export func Parse() *Slist;
 
 //Slist* atom(byte *s, int i);
 
@@ -81,7 +81,7 @@ var inputindex int = 0;
 var tokenbuf [100]byte;
 var tokenlen int = 0;
 
-const EOF int = -1;
+export const EOF int = -1;
 
 func main()
 {
@@ -131,7 +131,7 @@ func (slist *Slist) Print()
 	print("\n");
 }
 
-func Get() int
+export func Get() int
 {
 	var c int;
 
@@ -152,12 +152,12 @@ func Get() int
 	return c;
 }
 
-func WhiteSpace(c int) bool
+export func WhiteSpace(c int) bool
 {
 	return c == ' ' || c == '\t' || c == '\r' || c == '\n';
 }
 
-func NextToken()
+export func NextToken()
 {
 	var i, c int;
 	var backslash bool;
@@ -199,7 +199,7 @@ func NextToken()
 	}
 }
 
-func Expect(c int)
+export func Expect(c int)
 {
 	if token != c {
 		print("parse error: expected ", c, "\n");
@@ -209,7 +209,7 @@ func Expect(c int)
 }
 
 // Parse a non-parenthesized list up to a closing paren or EOF
-func ParseList() *Slist
+export func ParseList() *Slist
 {
 	var slist, retval *Slist;
 
@@ -257,7 +257,7 @@ func atoi() int	// BUG: uses tokenbuf; should take argument
 	return v;
 }
 
-func Parse() *Slist
+export func Parse() *Slist
 {
 	var slist *Slist;
 
@@ -288,7 +288,7 @@ func Parse() *Slist
 	return nil;
 }
 
-func OpenFile()
+export func OpenFile()
 {
 	input = "(defn foo (add 12 34))\n\x00";
 	inputindex = 0;
diff --git a/test/ken/robfunc.go b/test/ken/robfunc.go
index 12b4b6d7b6..5d4cfd2afb 100644
--- a/test/ken/robfunc.go
+++ b/test/ken/robfunc.go
@@ -44,7 +44,7 @@ func f8(a int) (x int, y float) {
 	return 8, 8.0;
 }
 
-type T struct {
+export type T struct {
 	x, y int;
 }
 
diff --git a/test/mallocrand.go b/test/mallocrand.go
index aafa90e6a8..e4f06cad2b 100644
--- a/test/mallocrand.go
+++ b/test/mallocrand.go
@@ -20,7 +20,7 @@ var chatty = flag.Bool("v", false, "chatty");
 var footprint uint64;
 var allocated uint64;
 func bigger() {
-	if f := malloc.GetStats().sys; footprint < f {
+	if f := malloc.GetStats().Sys; footprint < f {
 		footprint = f;
 		if *chatty {
 			println("Footprint", footprint, " for ", allocated);
@@ -60,7 +60,7 @@ func main() {
 		if i%(1<<10) == 0 && *chatty {
 			println(i);
 		}
-		b := rand.rand() % len(blocks);
+		b := rand.Int() % len(blocks);
 		if blocks[b].base != nil {
 		//	println("Free", blocks[b].siz, blocks[b].base);
 			malloc.Free(blocks[b].base);
@@ -68,7 +68,7 @@ func main() {
 			allocated -= blocks[b].siz;
 			continue
 		}
-		siz := uint64(rand.rand() >> (11 + rand.urand32() % 20));
+		siz := uint64(rand.Int() >> (11 + rand.Uint32() % 20));
 		base := malloc.Alloc(siz);
 	//	ptr := uint64(syscall.BytePtr(base))+uint64(siz/2);
 	//	obj, size, ref, ok := allocator.find(ptr);
diff --git a/test/mallocrep.go b/test/mallocrep.go
index 26537a0bfc..6aa8fdf8cb 100644
--- a/test/mallocrep.go
+++ b/test/mallocrep.go
@@ -17,12 +17,12 @@ var chatty = flag.Bool("v", false, "chatty");
 
 var oldsys uint64;
 func bigger() {
-	if st := malloc.GetStats(); oldsys < st.sys {
-		oldsys = st.sys;
+	if st := malloc.GetStats(); oldsys < st.Sys {
+		oldsys = st.Sys;
 		if *chatty {
-			println(st.sys, " system bytes for ", st.alloc, " Go bytes");
+			println(st.Sys, " system bytes for ", st.Alloc, " Go bytes");
 		}
-		if st.sys > 1e9 {
+		if st.Sys > 1e9 {
 			panicln("too big");
 		}
 	}
@@ -30,16 +30,16 @@ func bigger() {
 
 func main() {
 	flag.Parse();
-	malloc.GetStats().alloc = 0;	// ignore stacks
+	malloc.GetStats().Alloc = 0;	// ignore stacks
 	for i := 0; i < 1<<8; i++ {
 		for j := 1; j <= 1<<22; j<<=1 {
 			if i == 0 && *chatty {
 				println("First alloc:", j);
 			}
 			b := malloc.Alloc(uint64(j));
-			during := malloc.GetStats().alloc;
+			during := malloc.GetStats().Alloc;
 			malloc.Free(b);
-			if a := malloc.GetStats().alloc; a != 0 {
+			if a := malloc.GetStats().Alloc; a != 0 {
 				panicln("malloc wrong count", a, "after", j, "during", during);
 			}
 			bigger();
diff --git a/test/mallocrep1.go b/test/mallocrep1.go
index 7ae6b36829..ebb1741994 100644
--- a/test/mallocrep1.go
+++ b/test/mallocrep1.go
@@ -22,7 +22,7 @@ var longtest = flag.Bool("l", false, "long test");
 var b []*byte;
 var stats = malloc.GetStats();
 
-func OkAmount(size, n uintptr) bool {
+export func OkAmount(size, n uintptr) bool {
 	if n < size {
 		return false
 	}
@@ -38,45 +38,45 @@ func OkAmount(size, n uintptr) bool {
 	return true
 }
 
-func AllocAndFree(size, count int) {
+export func AllocAndFree(size, count int) {
 	if *chatty {
 		fmt.Printf("size=%d count=%d ...\n", size, count);
 	}
-	n1 := stats.alloc;
+	n1 := stats.Alloc;
 	for i := 0; i < count; i++ {
 		b[i] = malloc.Alloc(uint64(size));
 		base, n := malloc.Lookup(b[i]);
 		if base != b[i] || !OkAmount(uintptr(size), n) {
 			panicln("lookup failed: got", base, n, "for", b[i]);
 		}
-		if malloc.GetStats().sys > 1e9 {
+		if malloc.GetStats().Sys > 1e9 {
 			panicln("too much memory allocated");
 		}
 	}
-	n2 := stats.alloc;
+	n2 := stats.Alloc;
 	if *chatty {
 		fmt.Printf("size=%d count=%d stats=%+v\n", size, count, *stats);
 	}
-	n3 := stats.alloc;
+	n3 := stats.Alloc;
 	for j := 0; j < count; j++ {
 		i := j;
 		if *reverse {
 			i = count - 1 - j;
 		}
-		alloc := stats.alloc;
+		alloc := stats.Alloc;
 		base, n := malloc.Lookup(b[i]);
 		if base != b[i] || !OkAmount(uintptr(size), n) {
 			panicln("lookup failed: got", base, n, "for", b[i]);
 		}
 		malloc.Free(b[i]);
-		if stats.alloc != alloc - uint64(n) {
-			panicln("free alloc got", stats.alloc, "expected", alloc - uint64(n), "after free of", n);
+		if stats.Alloc != alloc - uint64(n) {
+			panicln("free alloc got", stats.Alloc, "expected", alloc - uint64(n), "after free of", n);
 		}
-		if malloc.GetStats().sys > 1e9 {
+		if malloc.GetStats().Sys > 1e9 {
 			panicln("too much memory allocated");
 		}
 	}
-	n4 := stats.alloc;
+	n4 := stats.Alloc;
 
 	if *chatty {
 		fmt.Printf("size=%d count=%d stats=%+v\n", size, count, *stats);
diff --git a/test/map.go b/test/map.go
index 51c6fe5f5b..18a401cf75 100644
--- a/test/map.go
+++ b/test/map.go
@@ -13,7 +13,7 @@ import (
 
 const arraylen = 2; // BUG: shouldn't need this
 
-func P(a []string) string {
+export func P(a []string) string {
 	s := "{";
 	for i := 0; i < len(a); i++ {
 		if i > 0 {
diff --git a/test/method.go b/test/method.go
index 6dba3d1781..f57c269074 100644
--- a/test/method.go
+++ b/test/method.go
@@ -6,12 +6,12 @@
 
 package main
 
-type S string
-type S1 string
-type I int
-type I1 int
-type T struct { x int }
-type T1 T
+export type S string
+export type S1 string
+export type I int
+export type I1 int
+export type T struct { x int }
+export type T1 T
 
 func (s S) val() int { return 1 }
 func (s *S1) val() int { return 2 }
@@ -20,7 +20,7 @@ func (i *I1) val() int { return 4 }
 //func (t T) val() int { return 7 }
 func (t *T1) val() int { return 8 }
 
-type Val interface {
+export type Val interface {
 	val() int
 }
 
diff --git a/test/method1.go b/test/method1.go
index c88607d425..d279c50ddf 100644
--- a/test/method1.go
+++ b/test/method1.go
@@ -6,7 +6,7 @@
 
 package main
 
-type T struct { }
+export type T struct { }
 func (t *T) M(int, string);	// GCCGO_ERROR "previous"
 func (t *T) M(int, float) { }   // ERROR "redeclared|redefinition"
 
diff --git a/test/method2.go b/test/method2.go
index 3ee0ae1364..9a32dd6b6a 100644
--- a/test/method2.go
+++ b/test/method2.go
@@ -6,9 +6,9 @@
 
 package main
 
-type T struct {a int}
-type P *T
-type P1 *T
+export type T struct {a int}
+export type P *T
+export type P1 *T
 
 func (p P) val() int { return 1 }  // ERROR "receiver"
 func (p *P1) val() int { return 1 }  // ERROR "receiver"
diff --git a/test/method3.go b/test/method3.go
index 491bcdad33..0b93af0e12 100644
--- a/test/method3.go
+++ b/test/method3.go
@@ -8,10 +8,10 @@
 
 package main
 
-type T [] int
+export type T [] int
 func (t T) Len() int { return len(t) }
 
-type I interface {
+export type I interface {
 	Len() int
 }
 
diff --git a/test/nil.go b/test/nil.go
index 1aef54ba9b..e59d473176 100644
--- a/test/nil.go
+++ b/test/nil.go
@@ -6,11 +6,11 @@
 
 package main
 
-type T struct {
+export type T struct {
 	i int
 }
 
-type IN interface {
+export type IN interface {
 }
 
 func main() {
diff --git a/test/peano.go b/test/peano.go
index 07e5f0ed37..3195761983 100644
--- a/test/peano.go
+++ b/test/peano.go
@@ -6,7 +6,7 @@
 
 package main
 
-type Number struct {
+export type Number struct {
 	next *Number
 }
 
diff --git a/test/sieve.go b/test/sieve.go
index e163456176..f6a07277fb 100644
--- a/test/sieve.go
+++ b/test/sieve.go
@@ -7,7 +7,7 @@
 package main
 
 // Send the sequence 2, 3, 4, ... to channel 'ch'.
-func Generate(ch chan<- int) {
+export func Generate(ch chan<- int) {
 	for i := 2; ; i++ {
 		ch <- i  // Send 'i' to channel 'ch'.
 	}
@@ -15,7 +15,7 @@ func Generate(ch chan<- int) {
 
 // Copy the values from channel 'in' to channel 'out',
 // removing those divisible by 'prime'.
-func Filter(in <-chan int, out chan<- int, prime int) {
+export func Filter(in <-chan int, out chan<- int, prime int) {
 	for {
 		i := <-in;  // Receive value of new variable 'i' from 'in'.
 		if i % prime != 0 {
@@ -25,7 +25,7 @@ func Filter(in <-chan int, out chan<- int, prime int) {
 }
 
 // The prime sieve: Daisy-chain Filter processes together.
-func Sieve() {
+export func Sieve() {
 	ch := make(chan int);  // Create a new channel.
 	go Generate(ch);  // Start Generate() as a subprocess.
 	for {
diff --git a/test/test0.go b/test/test0.go
index 95d225444f..bb9f10f9cb 100644
--- a/test/test0.go
+++ b/test/test0.go
@@ -18,7 +18,7 @@ const (
   mask4 = 1 << iota;
 )
 
-type (
+export type (
   Empty interface {};
   Point struct {
     x, y int;
diff --git a/test/vectors.go b/test/vectors.go
index e5cbde2d53..f468f4b29a 100644
--- a/test/vectors.go
+++ b/test/vectors.go
@@ -9,7 +9,7 @@ package main
 import "array"
 
 
-type S struct {
+export type S struct {
 	val int
 }
 
