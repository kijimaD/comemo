commit 5dee91001b1dff7a20adb8062da991a7e225b6bf
Author: Robert Griesemer <gri@golang.org>
Date:   Mon Jan 11 12:58:13 2010 -0800

    Remove -oldprinter flag from gofmt; all code is
    now printed using the semicolon-free style.
    
    Removed NoSemis flag and mechanism dealing with
    optional semicolons from go/printer.
    
    Updated all go/printer output files using the
    semi-colon free style.
    
    Changes have no formatting impact on checked in
    go code under src and misc.
    
    R=rsc, r
    CC=golang-dev
    https://golang.org/cl/184068
---
 src/cmd/godoc/godoc.go                          |   2 +-
 src/cmd/gofmt/gofmt.go                          |   6 +-
 src/pkg/go/printer/nodes.go                     |  78 ++---
 src/pkg/go/printer/printer.go                   |   1 -
 src/pkg/go/printer/testdata/comments.golden     |  62 ++--
 src/pkg/go/printer/testdata/comments.x          |  20 +-
 src/pkg/go/printer/testdata/declarations.golden | 368 +++++++++++-----------
 src/pkg/go/printer/testdata/expressions.golden  | 392 ++++++++++++------------
 src/pkg/go/printer/testdata/expressions.raw     | 392 ++++++++++++------------
 src/pkg/go/printer/testdata/linebreaks.golden   |  52 ++--
 src/pkg/go/printer/testdata/statements.golden   |  38 +--
 11 files changed, 684 insertions(+), 727 deletions(-)

diff --git a/src/cmd/godoc/godoc.go b/src/cmd/godoc/godoc.go
index e760d22307..09b110caba 100644
--- a/src/cmd/godoc/godoc.go
+++ b/src/cmd/godoc/godoc.go
@@ -530,7 +530,7 @@ func (p *tconv) Write(data []byte) (n int, err os.Error) {
 
 // Write an AST-node to w; optionally html-escaped.
 func writeNode(w io.Writer, node interface{}, html bool, styler printer.Styler) {
-	mode := printer.TabIndent | printer.UseSpaces | printer.NoSemis
+	mode := printer.TabIndent | printer.UseSpaces
 	if html {
 		mode |= printer.GenHTML
 	}
diff --git a/src/cmd/gofmt/gofmt.go b/src/cmd/gofmt/gofmt.go
index ee3147d4f9..c26ef3dec1 100644
--- a/src/cmd/gofmt/gofmt.go
+++ b/src/cmd/gofmt/gofmt.go
@@ -36,8 +36,7 @@ var (
 	useSpaces = flag.Bool("spaces", true, "align with spaces instead of tabs")
 
 	// semicolon transition
-	useOldParser  = flag.Bool("oldparser", false, "parse old syntax (required semicolons)")
-	useOldPrinter = flag.Bool("oldprinter", false, "print old syntax (required semicolons)")
+	useOldParser = flag.Bool("oldparser", false, "parse old syntax (required semicolons)")
 )
 
 
@@ -81,9 +80,6 @@ func initPrinterMode() {
 	if *useSpaces {
 		printerMode |= printer.UseSpaces
 	}
-	if !*useOldPrinter {
-		printerMode |= printer.NoSemis
-	}
 }
 
 
diff --git a/src/pkg/go/printer/nodes.go b/src/pkg/go/printer/nodes.go
index d5a3be9b0d..226e34572e 100644
--- a/src/pkg/go/printer/nodes.go
+++ b/src/pkg/go/printer/nodes.go
@@ -282,9 +282,8 @@ func (p *printer) parameters(list []*ast.Field, multiLine *bool) {
 }
 
 
-// Returns true if a separating semicolon is optional.
 // Sets multiLine to true if the signature spans multiple lines.
-func (p *printer) signature(params, result []*ast.Field, multiLine *bool) (optSemi bool) {
+func (p *printer) signature(params, result []*ast.Field, multiLine *bool) {
 	p.parameters(params, multiLine)
 	if result != nil {
 		p.print(blank)
@@ -293,7 +292,7 @@ func (p *printer) signature(params, result []*ast.Field, multiLine *bool) (optSe
 			// single anonymous result; no ()'s unless it's a function type
 			f := result[0]
 			if _, isFtyp := f.Type.(*ast.FuncType); !isFtyp {
-				optSemi = p.expr(f.Type, multiLine)
+				p.expr(f.Type, multiLine)
 				return
 			}
 		}
@@ -400,9 +399,6 @@ func (p *printer) fieldList(lbrace token.Position, list []*ast.Field, rbrace tok
 				p.expr(&ast.StringList{f.Tag}, &ml)
 				extraTabs = 0
 			}
-			if p.Mode&NoSemis == 0 {
-				p.print(token.SEMICOLON)
-			}
 			if f.Comment != nil {
 				for ; extraTabs > 0; extraTabs-- {
 					p.print(vtab)
@@ -435,9 +431,6 @@ func (p *printer) fieldList(lbrace token.Position, list []*ast.Field, rbrace tok
 				// embedded interface
 				p.expr(f.Type, &ml)
 			}
-			if p.Mode&NoSemis == 0 {
-				p.print(token.SEMICOLON)
-			}
 			p.lineComment(f.Comment)
 		}
 		if isIncomplete {
@@ -630,9 +623,8 @@ func isBinary(expr ast.Expr) bool {
 }
 
 
-// Returns true if a separating semicolon is optional.
 // Sets multiLine to true if the expression spans multiple lines.
-func (p *printer) expr1(expr ast.Expr, prec1, depth int, ctxt exprContext, multiLine *bool) (optSemi bool) {
+func (p *printer) expr1(expr ast.Expr, prec1, depth int, ctxt exprContext, multiLine *bool) {
 	p.print(expr.Pos())
 
 	switch x := expr.(type) {
@@ -660,12 +652,12 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, ctxt exprContext, multi
 			// parenthesis needed
 			p.print(token.LPAREN)
 			p.print(token.MUL)
-			optSemi = p.expr(x.X, multiLine)
+			p.expr(x.X, multiLine)
 			p.print(token.RPAREN)
 		} else {
 			// no parenthesis needed
 			p.print(token.MUL)
-			optSemi = p.expr(x.X, multiLine)
+			p.expr(x.X, multiLine)
 		}
 
 	case *ast.UnaryExpr:
@@ -743,11 +735,7 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, ctxt exprContext, multi
 		}
 		p.expr1(x.Fun, token.HighestPrec, depth, 0, multiLine)
 		p.print(x.Lparen, token.LPAREN)
-		mode := commaSep
-		if p.Mode&NoSemis != 0 {
-			mode |= commaTerm
-		}
-		p.exprList(x.Lparen, x.Args, depth, mode, multiLine, x.Rparen)
+		p.exprList(x.Lparen, x.Args, depth, commaSep|commaTerm, multiLine, x.Rparen)
 		p.print(x.Rparen, token.RPAREN)
 
 	case *ast.CompositeLit:
@@ -778,27 +766,25 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, ctxt exprContext, multi
 			p.expr(x.Len, multiLine)
 		}
 		p.print(token.RBRACK)
-		optSemi = p.expr(x.Elt, multiLine)
+		p.expr(x.Elt, multiLine)
 
 	case *ast.StructType:
 		p.print(token.STRUCT)
 		p.fieldList(x.Lbrace, x.Fields, x.Rbrace, x.Incomplete, ctxt|structType)
-		optSemi = true
 
 	case *ast.FuncType:
 		p.print(token.FUNC)
-		optSemi = p.signature(x.Params, x.Results, multiLine)
+		p.signature(x.Params, x.Results, multiLine)
 
 	case *ast.InterfaceType:
 		p.print(token.INTERFACE)
 		p.fieldList(x.Lbrace, x.Methods, x.Rbrace, x.Incomplete, ctxt)
-		optSemi = true
 
 	case *ast.MapType:
 		p.print(token.MAP, token.LBRACK)
 		p.expr(x.Key, multiLine)
 		p.print(token.RBRACK)
-		optSemi = p.expr(x.Value, multiLine)
+		p.expr(x.Value, multiLine)
 
 	case *ast.ChanType:
 		switch x.Dir {
@@ -810,7 +796,7 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, ctxt exprContext, multi
 			p.print(token.CHAN, token.ARROW)
 		}
 		p.print(blank)
-		optSemi = p.expr(x.Value, multiLine)
+		p.expr(x.Value, multiLine)
 
 	default:
 		panic("unreachable")
@@ -820,16 +806,15 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, ctxt exprContext, multi
 }
 
 
-func (p *printer) expr0(x ast.Expr, depth int, multiLine *bool) (optSemi bool) {
-	return p.expr1(x, token.LowestPrec, depth, 0, multiLine)
+func (p *printer) expr0(x ast.Expr, depth int, multiLine *bool) {
+	p.expr1(x, token.LowestPrec, depth, 0, multiLine)
 }
 
 
-// Returns true if a separating semicolon is optional.
 // Sets multiLine to true if the expression spans multiple lines.
-func (p *printer) expr(x ast.Expr, multiLine *bool) (optSemi bool) {
+func (p *printer) expr(x ast.Expr, multiLine *bool) {
 	const depth = 1
-	return p.expr1(x, token.LowestPrec, depth, 0, multiLine)
+	p.expr1(x, token.LowestPrec, depth, 0, multiLine)
 }
 
 
@@ -852,9 +837,7 @@ func (p *printer) stmtList(list []ast.Stmt, _indent int) {
 		// in those cases each clause is a new section
 		p.linebreak(s.Pos().Line, 1, maxStmtNewlines, ignore, i == 0 || _indent == 0 || multiLine)
 		multiLine = false
-		if !p.stmt(s, &multiLine) && len(list) > 1 && p.Mode&NoSemis == 0 {
-			p.print(token.SEMICOLON)
-		}
+		p.stmt(s, &multiLine)
 	}
 	if _indent > 0 {
 		p.print(unindent)
@@ -933,9 +916,8 @@ func (p *printer) controlClause(isForStmt bool, init ast.Stmt, expr ast.Expr, po
 }
 
 
-// Returns true if a separating semicolon is optional.
 // Sets multiLine to true if the statements spans multiple lines.
-func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
+func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) {
 	p.print(stmt.Pos())
 
 	switch s := stmt.(type) {
@@ -944,7 +926,6 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 
 	case *ast.DeclStmt:
 		p.decl(s.Decl, inStmtList, multiLine)
-		optSemi = true // decl prints terminating semicolon if necessary
 
 	case *ast.EmptyStmt:
 		// nothing to do
@@ -957,7 +938,7 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 		p.expr(s.Label, multiLine)
 		p.print(token.COLON, vtab, indent)
 		p.linebreak(s.Stmt.Pos().Line, 0, 1, ignore, true)
-		optSemi = p.stmt(s.Stmt, multiLine)
+		p.stmt(s.Stmt, multiLine)
 
 	case *ast.ExprStmt:
 		const depth = 1
@@ -1001,19 +982,17 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 	case *ast.BlockStmt:
 		p.block(s, 1, false)
 		*multiLine = true
-		optSemi = true
 
 	case *ast.IfStmt:
 		p.print(token.IF)
 		p.controlClause(false, s.Init, s.Cond, nil)
 		p.block(s.Body, 1, true)
 		*multiLine = true
-		optSemi = true
 		if s.Else != nil {
 			p.print(blank, token.ELSE, blank)
 			switch s.Else.(type) {
 			case *ast.BlockStmt, *ast.IfStmt:
-				optSemi = p.stmt(s.Else, ignoreMultiLine)
+				p.stmt(s.Else, ignoreMultiLine)
 			default:
 				p.print(token.LBRACE, indent, formfeed)
 				p.stmt(s.Else, ignoreMultiLine)
@@ -1030,14 +1009,12 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 		}
 		p.print(s.Colon, token.COLON)
 		p.stmtList(s.Body, 1)
-		optSemi = true // "block" without {}'s
 
 	case *ast.SwitchStmt:
 		p.print(token.SWITCH)
 		p.controlClause(false, s.Init, s.Tag, nil)
 		p.block(s.Body, 0, true)
 		*multiLine = true
-		optSemi = true
 
 	case *ast.TypeCaseClause:
 		if s.Types != nil {
@@ -1048,7 +1025,6 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 		}
 		p.print(s.Colon, token.COLON)
 		p.stmtList(s.Body, 1)
-		optSemi = true // "block" without {}'s
 
 	case *ast.TypeSwitchStmt:
 		p.print(token.SWITCH)
@@ -1062,7 +1038,6 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 		p.print(blank)
 		p.block(s.Body, 0, true)
 		*multiLine = true
-		optSemi = true
 
 	case *ast.CommClause:
 		if s.Rhs != nil {
@@ -1077,20 +1052,17 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 		}
 		p.print(s.Colon, token.COLON)
 		p.stmtList(s.Body, 1)
-		optSemi = true // "block" without {}'s
 
 	case *ast.SelectStmt:
 		p.print(token.SELECT, blank)
 		p.block(s.Body, 0, false)
 		*multiLine = true
-		optSemi = true
 
 	case *ast.ForStmt:
 		p.print(token.FOR)
 		p.controlClause(true, s.Init, s.Cond, s.Post)
 		p.block(s.Body, 1, true)
 		*multiLine = true
-		optSemi = true
 
 	case *ast.RangeStmt:
 		p.print(token.FOR, blank)
@@ -1104,7 +1076,6 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 		p.print(blank)
 		p.block(s.Body, 1, true)
 		*multiLine = true
-		optSemi = true
 
 	default:
 		panic("unreachable")
@@ -1132,7 +1103,6 @@ const (
 //
 func (p *printer) spec(spec ast.Spec, n int, context declContext, multiLine *bool) {
 	var (
-		optSemi   bool              // true if a semicolon is optional
 		comment   *ast.CommentGroup // a line comment, if any
 		extraTabs int               // number of extra tabs before comment, if any
 	)
@@ -1159,12 +1129,11 @@ func (p *printer) spec(spec ast.Spec, n int, context declContext, multiLine *boo
 		if n == 1 {
 			if s.Type != nil {
 				p.print(blank)
-				optSemi = p.expr(s.Type, multiLine)
+				p.expr(s.Type, multiLine)
 			}
 			if s.Values != nil {
 				p.print(blank, token.ASSIGN)
 				p.exprList(noPos, s.Values, 1, blankStart|commaSep, multiLine, noPos)
-				optSemi = false
 			}
 		} else {
 			extraTabs = 2
@@ -1172,14 +1141,13 @@ func (p *printer) spec(spec ast.Spec, n int, context declContext, multiLine *boo
 				p.print(vtab)
 			}
 			if s.Type != nil {
-				optSemi = p.expr(s.Type, multiLine)
+				p.expr(s.Type, multiLine)
 				extraTabs = 1
 			}
 			if s.Values != nil {
 				p.print(vtab)
 				p.print(token.ASSIGN)
 				p.exprList(noPos, s.Values, 1, blankStart|commaSep, multiLine, noPos)
-				optSemi = false
 				extraTabs = 0
 			}
 		}
@@ -1194,17 +1162,13 @@ func (p *printer) spec(spec ast.Spec, n int, context declContext, multiLine *boo
 		} else {
 			p.print(vtab)
 		}
-		optSemi = p.expr(s.Type, multiLine)
+		p.expr(s.Type, multiLine)
 		comment = s.Comment
 
 	default:
 		panic("unreachable")
 	}
 
-	if (context == inGroup || context == inStmtList && !optSemi) && p.Mode&NoSemis == 0 {
-		p.print(token.SEMICOLON)
-	}
-
 	if comment != nil {
 		for ; extraTabs > 0; extraTabs-- {
 			p.print(vtab)
diff --git a/src/pkg/go/printer/printer.go b/src/pkg/go/printer/printer.go
index 16f61cd080..9e82003564 100644
--- a/src/pkg/go/printer/printer.go
+++ b/src/pkg/go/printer/printer.go
@@ -894,7 +894,6 @@ const (
 	RawFormat      // do not use a tabwriter; if set, UseSpaces is ignored
 	TabIndent      // use tabs for indentation independent of UseSpaces
 	UseSpaces      // use spaces instead of tabs for alignment
-	NoSemis        // don't print semicolons at the end of a line
 )
 
 
diff --git a/src/pkg/go/printer/testdata/comments.golden b/src/pkg/go/printer/testdata/comments.golden
index 04f87a6c46..741500c621 100644
--- a/src/pkg/go/printer/testdata/comments.golden
+++ b/src/pkg/go/printer/testdata/comments.golden
@@ -10,8 +10,8 @@ import "fmt"	// fmt
 
 const c0 = 0	// zero
 const (
-	c1	= iota;	// c1
-	c2;	// c2
+	c1	= iota	// c1
+	c2	// c2
 )
 
 
@@ -20,21 +20,21 @@ type SZ struct{}
 
 // The S0 struct; no field is exported.
 type S0 struct {
-	int;
-	x, y, z	int;	// 3 unexported fields
+	int
+	x, y, z	int	// 3 unexported fields
 }
 
 // The S1 struct; some fields are not exported.
 type S1 struct {
-	S0;
-	A, B, C	float;	// 3 exported fields
-	D, b, c	int;	// 2 unexported fields
+	S0
+	A, B, C	float	// 3 exported fields
+	D, b, c	int	// 2 unexported fields
 }
 
 // The S2 struct; all fields are exported.
 type S2 struct {
-	S1;
-	A, B, C	float;	// 3 exported fields
+	S1
+	A, B, C	float	// 3 exported fields
 }
 
 // The IZ interface; it is empty.
@@ -42,21 +42,21 @@ type SZ interface{}
 
 // The I0 interface; no method is exported.
 type I0 interface {
-	f(x int) int;	// unexported method
+	f(x int) int	// unexported method
 }
 
 // The I1 interface; some methods are not exported.
 type I1 interface {
-	I0;
-	F(x float) float;	// exported methods
-	g(x int) int;		// unexported method
+	I0
+	F(x float) float	// exported methods
+	g(x int) int		// unexported method
 }
 
 // The I2 interface; all methods are exported.
 type I2 interface {
-	I0;
-	F(x float) float;	// exported method
-	G(x float) float;	// exported method
+	I0
+	F(x float) float	// exported method
+	G(x float) float	// exported method
 }
 
 // This comment group should be separated
@@ -71,23 +71,23 @@ var ()
 
 // This comment SHOULD be associated with the next declaration.
 func f0() {
-	const pi = 3.14;	// pi
-	var s1 struct{}		/* an empty struct */	/* foo */
+	const pi = 3.14	// pi
+	var s1 struct{}	/* an empty struct */	/* foo */
 	// a struct constructor
 	// --------------------
-	var s2 struct{} = struct{}{};
-	x := pi;
+	var s2 struct{} = struct{}{}
+	x := pi
 }
 //
 // NO SPACE HERE
 //
 func f1() {
-	f0();
+	f0()
 	/* 1 */
 	// 2
 	/* 3 */
 	/* 4 */
-	f0();
+	f0()
 }
 
 
@@ -100,7 +100,7 @@ func abs(x int) int {
 	if x < 0 {	// the tab printed before this comment's // must not affect the remaining lines
 		return -x	// this statement should be properly indented
 	}
-	return x;
+	return x
 }
 
 
@@ -283,14 +283,14 @@ func _( /* this */ x /* is */ /* an */ int)	{}
 
 // Line comments with tabs
 func _() {
-	var finput *bufio.Reader;	// input file
-	var stderr *bufio.Writer;
-	var ftable *bufio.Writer;	// y.go file
-	var foutput *bufio.Writer;	// y.output file
-
-	var oflag string;	// -o [y.go]		- y.go file
-	var vflag string;	// -v [y.output]	- y.output file
-	var lflag bool;		// -l			- disable line directives
+	var finput *bufio.Reader	// input file
+	var stderr *bufio.Writer
+	var ftable *bufio.Writer	// y.go file
+	var foutput *bufio.Writer	// y.output file
+
+	var oflag string	// -o [y.go]		- y.go file
+	var vflag string	// -v [y.output]	- y.output file
+	var lflag bool		// -l			- disable line directives
 }
 
 
diff --git a/src/pkg/go/printer/testdata/comments.x b/src/pkg/go/printer/testdata/comments.x
index d10eb2e560..19fa017bcf 100644
--- a/src/pkg/go/printer/testdata/comments.x
+++ b/src/pkg/go/printer/testdata/comments.x
@@ -15,17 +15,17 @@ type S0 struct {
 
 // The S1 struct; some fields are not exported.
 type S1 struct {
-	S0;
-	A, B, C	float;	// 3 exported fields
-	D	int;	// 2 unexported fields
+	S0
+	A, B, C	float	// 3 exported fields
+	D	int	// 2 unexported fields
 	// contains unexported fields
 }
 
 
 // The S2 struct; all fields are exported.
 type S2 struct {
-	S1;
-	A, B, C	float;	// 3 exported fields
+	S1
+	A, B, C	float	// 3 exported fields
 }
 
 
@@ -41,15 +41,15 @@ type I0 interface {
 
 // The I1 interface; some methods are not exported.
 type I1 interface {
-	I0;
-	F(x float) float;	// exported methods
+	I0
+	F(x float) float	// exported methods
 	// contains unexported methods
 }
 
 
 // The I2 interface; all methods are exported.
 type I2 interface {
-	I0;
-	F(x float) float;	// exported method
-	G(x float) float;	// exported method
+	I0
+	F(x float) float	// exported method
+	G(x float) float	// exported method
 }
diff --git a/src/pkg/go/printer/testdata/declarations.golden b/src/pkg/go/printer/testdata/declarations.golden
index 1af6005c53..17d8bfaff0 100644
--- a/src/pkg/go/printer/testdata/declarations.golden
+++ b/src/pkg/go/printer/testdata/declarations.golden
@@ -7,22 +7,22 @@ package imports
 import "io"
 
 import (
-	_ "io";
+	_ "io"
 )
 
 import _ "io"
 
 import (
-	"io";
-	"io";
-	"io";
+	"io"
+	"io"
+	"io"
 )
 
 import (
-	"io";
-	aLongRename "io";
+	"io"
+	aLongRename "io"
 
-	b "io";
+	b "io"
 )
 
 // no newlines between consecutive single imports, but
@@ -52,17 +52,17 @@ import (
 		// a comment
 		"bar" +
 		"foo" +	// a comment
-		"bar";	// a comment
+		"bar"	// a comment
 )
 
 // a case that caused problems in the past (comment placement)
 import (
-	. "fmt";
-	"io";
-	"malloc";	// for the malloc count test only
-	"math";
-	"strings";
-	"testing";
+	. "fmt"
+	"io"
+	"malloc"	// for the malloc count test only
+	"math"
+	"strings"
+	"testing"
 )
 
 
@@ -74,19 +74,19 @@ var _ int
 
 func _() {
 	// the following decls need a semicolon at the end
-	type _ int;
-	type _ *int;
-	type _ []int;
-	type _ map[string]int;
-	type _ chan int;
-	type _ func() int;
-
-	var _ int;
-	var _ *int;
-	var _ []int;
-	var _ map[string]int;
-	var _ chan int;
-	var _ func() int;
+	type _ int
+	type _ *int
+	type _ []int
+	type _ map[string]int
+	type _ chan int
+	type _ func() int
+
+	var _ int
+	var _ *int
+	var _ []int
+	var _ map[string]int
+	var _ chan int
+	var _ func() int
 
 	// the following decls don't need a semicolon at the end
 	type _ struct{}
@@ -121,116 +121,116 @@ func _() {
 
 // don't lose blank lines in grouped declarations
 const (
-	_	int	= 0;
-	_	float	= 1;
+	_	int	= 0
+	_	float	= 1
 
-	_	string	= "foo";
+	_	string	= "foo"
 
-	_	= iota;
-	_;
+	_	= iota
+	_
 
 	// a comment
-	_;
+	_
 
-	_;
+	_
 )
 
 
 type (
-	_	int;
-	_	struct{};
+	_	int
+	_	struct{}
 
-	_	interface{};
+	_	interface{}
 
 	// a comment
-	_	map[string]int;
+	_	map[string]int
 )
 
 
 var (
-	_	int	= 0;
-	_	float	= 1;
+	_	int	= 0
+	_	float	= 1
 
-	_	string	= "foo";
+	_	string	= "foo"
 
-	_	bool;
+	_	bool
 
 	// a comment
-	_	bool;
+	_	bool
 )
 
 
 // don't lose blank lines in this struct
 type _ struct {
 	String	struct {
-		Str, Len int;
-	};
+		Str, Len int
+	}
 	Slice	struct {
-		Array, Len, Cap int;
-	};
+		Array, Len, Cap int
+	}
 	Eface	struct {
-		Typ, Ptr int;
-	};
+		Typ, Ptr int
+	}
 
 	UncommonType	struct {
-		Name, PkgPath int;
-	};
+		Name, PkgPath int
+	}
 	CommonType	struct {
-		Size, Hash, Alg, Align, FieldAlign, String, UncommonType int;
-	};
+		Size, Hash, Alg, Align, FieldAlign, String, UncommonType int
+	}
 	Type	struct {
-		Typ, Ptr int;
-	};
+		Typ, Ptr int
+	}
 	StructField	struct {
-		Name, PkgPath, Typ, Tag, Offset int;
-	};
+		Name, PkgPath, Typ, Tag, Offset int
+	}
 	StructType	struct {
-		Fields int;
-	};
+		Fields int
+	}
 	PtrType	struct {
-		Elem int;
-	};
+		Elem int
+	}
 	SliceType	struct {
-		Elem int;
-	};
+		Elem int
+	}
 	ArrayType	struct {
-		Elem, Len int;
-	};
+		Elem, Len int
+	}
 
 	Stktop	struct {
-		Stackguard, Stackbase, Gobuf int;
-	};
+		Stackguard, Stackbase, Gobuf int
+	}
 	Gobuf	struct {
-		Sp, Pc, G int;
-	};
+		Sp, Pc, G int
+	}
 	G	struct {
-		Stackbase, Sched, Status, Alllink int;
-	};
+		Stackbase, Sched, Status, Alllink int
+	}
 }
 
 
 // no tabs for single or ungrouped decls
 func _() {
-	const xxxxxx = 0;
-	type x int;
-	var xxx int;
-	var yyyy float = 3.14;
-	var zzzzz = "bar";
+	const xxxxxx = 0
+	type x int
+	var xxx int
+	var yyyy float = 3.14
+	var zzzzz = "bar"
 
 	const (
-		xxxxxx = 0;
+		xxxxxx = 0
 	)
 	type (
-		x int;
+		x int
 	)
 	var (
-		xxx int;
+		xxx int
 	)
 	var (
-		yyyy float = 3.14;
+		yyyy float = 3.14
 	)
 	var (
-		zzzzz = "bar";
+		zzzzz = "bar"
 	)
 }
 
@@ -238,79 +238,79 @@ func _() {
 func _() {
 	// no entry has a type
 	const (
-		zzzzzz	= 1;
-		z	= 2;
-		zzz	= 3;
+		zzzzzz	= 1
+		z	= 2
+		zzz	= 3
 	)
 	// some entries have a type
 	const (
-		xxxxxx			= 1;
-		x			= 2;
-		xxx			= 3;
-		yyyyyyyy	float	= iota;
-		yyyy			= "bar";
-		yyy;
-		yy	= 2;
+		xxxxxx			= 1
+		x			= 2
+		xxx			= 3
+		yyyyyyyy	float	= iota
+		yyyy			= "bar"
+		yyy
+		yy	= 2
 	)
 }
 
 func _() {
 	// no entry has a type
 	var (
-		zzzzzz	= 1;
-		z	= 2;
-		zzz	= 3;
+		zzzzzz	= 1
+		z	= 2
+		zzz	= 3
 	)
 	// no entry has a value
 	var (
-		_	int;
-		_	float;
-		_	string;
+		_	int
+		_	float
+		_	string
 
-		_	int;	// comment
-		_	float;	// comment
-		_	string;	// comment
+		_	int	// comment
+		_	float	// comment
+		_	string	// comment
 	)
 	// some entries have a type
 	var (
-		xxxxxx		int;
-		x		float;
-		xxx		string;
-		yyyyyyyy	int	= 1234;
-		y		float	= 3.14;
-		yyyy			= "bar";
-		yyy		string	= "foo";
+		xxxxxx		int
+		x		float
+		xxx		string
+		yyyyyyyy	int	= 1234
+		y		float	= 3.14
+		yyyy			= "bar"
+		yyy		string	= "foo"
 	)
 	// mixed entries - all comments should be aligned
 	var (
-		a, b, c			int;
-		x				= 10;
-		d			int;	// comment
-		y				= 20;		// comment
-		f, ff, fff, ffff	int	= 0, 1, 2, 3;	// comment
+		a, b, c			int
+		x				= 10
+		d			int	// comment
+		y				= 20		// comment
+		f, ff, fff, ffff	int	= 0, 1, 2, 3	// comment
 	)
 	// respect original line breaks
 	var _ = []T{
 		T{0x20, "Telugu"},
-	};
+	}
 	var _ = []T{
 		// respect original line breaks
 		T{0x20, "Telugu"},
-	};
+	}
 }
 
 func _() {
 	type (
-		xxxxxx	int;
-		x	float;
-		xxx	string;
-		xxxxx	[]x;
-		xx	struct{};
+		xxxxxx	int
+		x	float
+		xxx	string
+		xxxxx	[]x
+		xx	struct{}
 		xxxxxxx	struct {
-			_, _	int;
-			_	float;
-		};
-		xxxx	chan<- string;
+			_, _	int
+			_	float
+		}
+		xxxx	chan<- string
 	)
 }
 
@@ -325,59 +325,59 @@ type _ struct {
 }
 
 type _ struct {	// this comment must not change indentation
-	f			int;
-	f, ff, fff, ffff	int;
+	f			int
+	f, ff, fff, ffff	int
 }
 
 type _ struct {
-	string;
+	string
 }
 
 type _ struct {
-	string;	// comment
+	string	// comment
 }
 
 type _ struct {
-	string "tag";
+	string "tag"
 }
 
 type _ struct {
-	string "tag";	// comment
+	string "tag"	// comment
 }
 
 type _ struct {
-	f int;
+	f int
 }
 
 type _ struct {
-	f int;	// comment
+	f int	// comment
 }
 
 type _ struct {
-	f int "tag";
+	f int "tag"
 }
 
 type _ struct {
-	f int "tag";	// comment
+	f int "tag"	// comment
 }
 
 type _ struct {
-	bool;
-	a, b, c			int;
-	int			"tag";
-	ES;				// comment
-	float			"tag";	// comment
-	f			int;	// comment
-	f, ff, fff, ffff	int;	// comment
-	g			float	"tag";
-	h			float	"tag";	// comment
+	bool
+	a, b, c			int
+	int			"tag"
+	ES				// comment
+	float			"tag"	// comment
+	f			int	// comment
+	f, ff, fff, ffff	int	// comment
+	g			float	"tag"
+	h			float	"tag"	// comment
 }
 
 
 // difficult cases
 type _ struct {
-	bool;		// comment
-	text	[]byte;	// comment
+	bool		// comment
+	text	[]byte	// comment
 }
 
 
@@ -385,41 +385,41 @@ type _ struct {
 type EI interface{}
 
 type _ interface {
-	EI;
+	EI
 }
 
 type _ interface {
-	f();
-	fffff();
+	f()
+	fffff()
 }
 
 type _ interface {
-	EI;
-	f();
-	fffffg();
+	EI
+	f()
+	fffffg()
 }
 
 type _ interface {	// this comment must not change indentation
-	EI;				// here's a comment
-	f();				// no blank between identifier and ()
-	fffff();			// no blank between identifier and ()
-	gggggggggggg(x, y, z int);	// hurray
+	EI				// here's a comment
+	f()				// no blank between identifier and ()
+	fffff()				// no blank between identifier and ()
+	gggggggggggg(x, y, z int)	// hurray
 }
 
 // formatting of variable declarations
 func _() {
 	type day struct {
-		n		int;
-		short, long	string;
+		n		int
+		short, long	string
 	}
 	var (
-		Sunday		= day{0, "SUN", "Sunday"};
-		Monday		= day{1, "MON", "Monday"};
-		Tuesday		= day{2, "TUE", "Tuesday"};
-		Wednesday	= day{3, "WED", "Wednesday"};
-		Thursday	= day{4, "THU", "Thursday"};
-		Friday		= day{5, "FRI", "Friday"};
-		Saturday	= day{6, "SAT", "Saturday"};
+		Sunday		= day{0, "SUN", "Sunday"}
+		Monday		= day{1, "MON", "Monday"}
+		Tuesday		= day{2, "TUE", "Tuesday"}
+		Wednesday	= day{3, "WED", "Wednesday"}
+		Thursday	= day{4, "THU", "Thursday"}
+		Friday		= day{5, "FRI", "Friday"}
+		Saturday	= day{6, "SAT", "Saturday"}
 	)
 }
 
@@ -464,14 +464,14 @@ func _() {
 			"print": nil,
 			"println": nil,
 		},
-	};
+	}
 }
 
 
 func _() {
 	var _ = T{
 		a,	// must introduce trailing comma
-	};
+	}
 }
 
 
@@ -501,13 +501,10 @@ func _() {	// opening "{" must move up
 	// in the following declarations, a comment must not
 	// introduce a newline and thus cause a semicolon to
 	// be inserted
-	const _ T = x // comment
-	;
-	const _ = x // comment
-	;
+	const _ T = x	// comment
+	const _ = x	// comment
 
-	type _ T // comment
-	;
+	type _ T	// comment
 	type _ struct // comment
 	{
 
@@ -517,20 +514,18 @@ func _() {	// opening "{" must move up
 
 	}
 	type _ * // comment
-	T;
+	T
 	type _ [ // comment
-	]T;
+	]T
 	type _ [ // comment
-	10]T;
+	10]T
 	type _ chan // comment
-	T;
+	T
 	type _ map // comment
-	[T]T;
+	[T]T
 
-	var _ T // comment
-	;
-	var _ T = x // comment
-	;
+	var _ T		// comment
+	var _ T = x	// comment
 	var _ struct // comment
 	{
 
@@ -540,16 +535,15 @@ func _() {	// opening "{" must move up
 
 	}
 	var _ * // comment
-	T;
+	T
 	var _ [ // comment
-	]T;
+	]T
 	var _ [ // comment
-	10]T;
+	10]T
 	var _ chan // comment
-	T;
+	T
 	var _ map // comment
-	[T]T;
+	[T]T
 
-	var _ = x // comment
-	;
+	var _ = x	// comment
 }
diff --git a/src/pkg/go/printer/testdata/expressions.golden b/src/pkg/go/printer/testdata/expressions.golden
index 5701c6df09..deff4243ea 100644
--- a/src/pkg/go/printer/testdata/expressions.golden
+++ b/src/pkg/go/printer/testdata/expressions.golden
@@ -5,233 +5,233 @@
 package expressions
 
 type T struct {
-	x, y, z int;
+	x, y, z int
 }
 
 var (
-	a, b, c, d, e						int;
-	under_bar						int;
-	longIdentifier1, longIdentifier2, longIdentifier3	int;
-	t0, t1, t2						T;
-	s							string;
-	p							*int;
+	a, b, c, d, e						int
+	under_bar						int
+	longIdentifier1, longIdentifier2, longIdentifier3	int
+	t0, t1, t2						T
+	s							string
+	p							*int
 )
 
 
 func _() {
 	// no spaces around simple or parenthesized expressions
-	_ = a + b;
-	_ = a + b + c;
-	_ = a + b - c;
-	_ = a - b - c;
-	_ = a + (b * c);
-	_ = a + (b / c);
-	_ = a - (b % c);
-	_ = 1 + a;
-	_ = a + 1;
-	_ = a + b + 1;
-	_ = s[1:2];
-	_ = s[a:b];
-	_ = s[0:len(s)];
-	_ = s[0] << 1;
-	_ = (s[0] << 1) & 0xf;
-	_ = s[0]<<2 | s[1]>>4;
-	_ = "foo" + s;
-	_ = s + "foo";
-	_ = 'a' + 'b';
-	_ = len(s) / 2;
-	_ = len(t0.x) / a;
+	_ = a + b
+	_ = a + b + c
+	_ = a + b - c
+	_ = a - b - c
+	_ = a + (b * c)
+	_ = a + (b / c)
+	_ = a - (b % c)
+	_ = 1 + a
+	_ = a + 1
+	_ = a + b + 1
+	_ = s[1:2]
+	_ = s[a:b]
+	_ = s[0:len(s)]
+	_ = s[0] << 1
+	_ = (s[0] << 1) & 0xf
+	_ = s[0]<<2 | s[1]>>4
+	_ = "foo" + s
+	_ = s + "foo"
+	_ = 'a' + 'b'
+	_ = len(s) / 2
+	_ = len(t0.x) / a
 
 	// spaces around expressions of different precedence or expressions containing spaces
-	_ = a + -b;
-	_ = a - ^b;
-	_ = a / *p;
-	_ = a + b*c;
-	_ = 1 + b*c;
-	_ = a + 2*c;
-	_ = a + c*2;
-	_ = 1 + 2*3;
-	_ = s[1 : 2*3];
-	_ = s[a : b-c];
-	_ = s[0:];
-	_ = s[a+b];
-	_ = s[a+b:];
-	_ = a[a<<b+1];
-	_ = a[a<<b+1:];
-	_ = s[a+b : len(s)];
-	_ = s[len(s):-a];
-	_ = s[a : len(s)+1];
-	_ = s[a:len(s)+1] + s;
+	_ = a + -b
+	_ = a - ^b
+	_ = a / *p
+	_ = a + b*c
+	_ = 1 + b*c
+	_ = a + 2*c
+	_ = a + c*2
+	_ = 1 + 2*3
+	_ = s[1 : 2*3]
+	_ = s[a : b-c]
+	_ = s[0:]
+	_ = s[a+b]
+	_ = s[a+b:]
+	_ = a[a<<b+1]
+	_ = a[a<<b+1:]
+	_ = s[a+b : len(s)]
+	_ = s[len(s):-a]
+	_ = s[a : len(s)+1]
+	_ = s[a:len(s)+1] + s
 
 	// spaces around operators with equal or lower precedence than comparisons
-	_ = a == b;
-	_ = a != b;
-	_ = a > b;
-	_ = a >= b;
-	_ = a < b;
-	_ = a <= b;
-	_ = a < b && c > d;
-	_ = a < b || c > d;
+	_ = a == b
+	_ = a != b
+	_ = a > b
+	_ = a >= b
+	_ = a < b
+	_ = a <= b
+	_ = a < b && c > d
+	_ = a < b || c > d
 
 	// spaces around "long" operands
-	_ = a + longIdentifier1;
-	_ = longIdentifier1 + a;
-	_ = longIdentifier1 + longIdentifier2*longIdentifier3;
-	_ = s + "a longer string";
+	_ = a + longIdentifier1
+	_ = longIdentifier1 + a
+	_ = longIdentifier1 + longIdentifier2*longIdentifier3
+	_ = s + "a longer string"
 
 	// some selected cases
-	_ = a + t0.x;
-	_ = a + t0.x + t1.x*t2.x;
-	_ = a + b + c + d + e + 2*3;
-	_ = a + b + c + 2*3 + d + e;
-	_ = (a + b + c) * 2;
-	_ = a - b + c - d + (a + b + c) + d&e;
-	_ = under_bar - 1;
-	_ = Open(dpath+"/file", O_WRONLY|O_CREAT, 0666);
-	_ = int(c0&_Mask4)<<18 | int(c1&_Maskx)<<12 | int(c2&_Maskx)<<6 | int(c3&_Maskx);
+	_ = a + t0.x
+	_ = a + t0.x + t1.x*t2.x
+	_ = a + b + c + d + e + 2*3
+	_ = a + b + c + 2*3 + d + e
+	_ = (a + b + c) * 2
+	_ = a - b + c - d + (a + b + c) + d&e
+	_ = under_bar - 1
+	_ = Open(dpath+"/file", O_WRONLY|O_CREAT, 0666)
+	_ = int(c0&_Mask4)<<18 | int(c1&_Maskx)<<12 | int(c2&_Maskx)<<6 | int(c3&_Maskx)
 }
 
 
 func _() {
-	a + b;
-	a + b + c;
-	a + b*c;
-	a + (b * c);
-	(a + b) * c;
-	a + (b * c * d);
-	a + (b*c + d);
-
-	1 << x;
-	-1 << x;
-	1<<x - 1;
-	-1<<x - 1;
-
-	f(a + b);
-	f(a + b + c);
-	f(a + b*c);
-	f(a + (b * c));
-	f(1<<x-1, 1<<x-2);
-
-	1<<d.logWindowSize - 1;
-
-	buf = make(x, 2*cap(b.buf)+n);
-
-	dst[i*3+2] = dbuf[0] << 2;
-	dst[i*3+2] = dbuf[0]<<2 | dbuf[1]>>4;
-
-	b.buf = b.buf[0 : b.off+m+n];
-	b.buf = b.buf[0 : b.off+m*n];
-	f(b.buf[0 : b.off+m+n]);
-
-	signed += ' ' * 8;
-	tw.octal(header[148:155], chksum);
-
-	x > 0 && i >= 0;
-
-	x1, x0 := x>>w2, x&m2;
-	z0 = t1<<w2 + t0;
-	z1 = (t1 + t0>>w2) >> w2;
-	q1, r1 := x1/d1, x1%d1;
-	r1 = r1*b2 | x0>>w2;
-	x1 = (x1 << z) | (x0 >> (uint(w) - z));
-	x1 = x1<<z | x0>>(uint(w)-z);
-
-	buf[0 : len(buf)+1];
-	buf[0 : n+1];
-
-	a, b = b, a;
-	a = b + c;
-	a = b*c + d;
-	a*b + c;
-	a - b - c;
-	a - (b - c);
-	a - b*c;
-	a - (b * c);
-	a * b / c;
-	a / *b;
-	x[a|^b];
-	x[a / *b];
-	a & ^b;
-	a + +b;
-	a - -b;
-	x[a*-b];
-	x[a + +b];
-	x ^ y ^ z;
-	b[a>>24] ^ b[(a>>16)&0xFF] ^ b[(a>>8)&0xFF] ^ b[a&0xFF];
-	len(longVariableName) * 2;
-
-	token(matchType + xlength<<lengthShift + xoffset);
+	a + b
+	a + b + c
+	a + b*c
+	a + (b * c)
+	(a + b) * c
+	a + (b * c * d)
+	a + (b*c + d)
+
+	1 << x
+	-1 << x
+	1<<x - 1
+	-1<<x - 1
+
+	f(a + b)
+	f(a + b + c)
+	f(a + b*c)
+	f(a + (b * c))
+	f(1<<x-1, 1<<x-2)
+
+	1<<d.logWindowSize - 1
+
+	buf = make(x, 2*cap(b.buf)+n)
+
+	dst[i*3+2] = dbuf[0] << 2
+	dst[i*3+2] = dbuf[0]<<2 | dbuf[1]>>4
+
+	b.buf = b.buf[0 : b.off+m+n]
+	b.buf = b.buf[0 : b.off+m*n]
+	f(b.buf[0 : b.off+m+n])
+
+	signed += ' ' * 8
+	tw.octal(header[148:155], chksum)
+
+	x > 0 && i >= 0
+
+	x1, x0 := x>>w2, x&m2
+	z0 = t1<<w2 + t0
+	z1 = (t1 + t0>>w2) >> w2
+	q1, r1 := x1/d1, x1%d1
+	r1 = r1*b2 | x0>>w2
+	x1 = (x1 << z) | (x0 >> (uint(w) - z))
+	x1 = x1<<z | x0>>(uint(w)-z)
+
+	buf[0 : len(buf)+1]
+	buf[0 : n+1]
+
+	a, b = b, a
+	a = b + c
+	a = b*c + d
+	a*b + c
+	a - b - c
+	a - (b - c)
+	a - b*c
+	a - (b * c)
+	a * b / c
+	a / *b
+	x[a|^b]
+	x[a / *b]
+	a & ^b
+	a + +b
+	a - -b
+	x[a*-b]
+	x[a + +b]
+	x ^ y ^ z
+	b[a>>24] ^ b[(a>>16)&0xFF] ^ b[(a>>8)&0xFF] ^ b[a&0xFF]
+	len(longVariableName) * 2
+
+	token(matchType + xlength<<lengthShift + xoffset)
 }
 
 
 func _() {
-	_ = T{};
-	_ = struct{}{};
-	_ = [10]T{};
-	_ = [...]T{};
-	_ = []T{};
-	_ = map[int]T{};
-
-	_ = (T){};
-	_ = (struct{}){};
-	_ = ([10]T){};
-	_ = ([...]T){};
-	_ = ([]T){};
-	_ = (map[int]T){};
+	_ = T{}
+	_ = struct{}{}
+	_ = [10]T{}
+	_ = [...]T{}
+	_ = []T{}
+	_ = map[int]T{}
+
+	_ = (T){}
+	_ = (struct{}){}
+	_ = ([10]T){}
+	_ = ([...]T){}
+	_ = ([]T){}
+	_ = (map[int]T){}
 }
 
 
 // one-line structs/interfaces in composite literals (up to a threshold)
 func _() {
-	_ = struct{}{};
-	_ = struct{ x int }{0};
-	_ = struct{ x, y, z int }{0, 1, 2};
-	_ = struct{ int }{0};
+	_ = struct{}{}
+	_ = struct{ x int }{0}
+	_ = struct{ x, y, z int }{0, 1, 2}
+	_ = struct{ int }{0}
 	_ = struct {
 		s struct {
-			int;
-		};
-	}{struct{ int }{0}};	// compositeLit context not propagated => multiLine result
+			int
+		}
+	}{struct{ int }{0}}	// compositeLit context not propagated => multiLine result
 }
 
 
 func _() {
 	// do not modify literals
-	_ = "tab1	tab2	tab3	end";	// string contains 3 tabs
-	_ = "tab1 tab2 tab3 end";	// same string with 3 blanks - may be unaligned because editors see tabs in strings
-	_ = "";				// this comment should be aligned with the one on the previous line
-	_ = ``;
+	_ = "tab1	tab2	tab3	end"	// string contains 3 tabs
+	_ = "tab1 tab2 tab3 end"	// same string with 3 blanks - may be unaligned because editors see tabs in strings
+	_ = ""				// this comment should be aligned with the one on the previous line
+	_ = ``
 	_ = `
-`;
+`
 	_ = `foo
-		bar`;
+		bar`
 }
 
 
 func _() {
 	// one-line function literals
-	_ = func() {};
-	_ = func() int { return 0 };
-	_ = func(x, y int) bool { return x < y };
+	_ = func() {}
+	_ = func() int { return 0 }
+	_ = func(x, y int) bool { return x < y }
 
-	f(func() {});
-	f(func() int { return 0 });
-	f(func(x, y int) bool { return x < y });
+	f(func() {})
+	f(func() int { return 0 })
+	f(func(x, y int) bool { return x < y })
 }
 
 
 func _() {
 	// do not add extra indentation to multi-line string lists
-	_ = "foo" + "bar";
+	_ = "foo" + "bar"
 	_ = "foo" +
 		"bar" +
-		"bah";
+		"bah"
 	_ = []string{
 		"abc" +
 			"def",
 		"foo" +
 			"bar",
-	};
+	}
 }
 
 
@@ -257,18 +257,18 @@ func _() {
 	_ = F1 +
 		`string = "%s";` +
 		`ptr = *;` +
-		`datafmt.T2 = s ["-" p "-"];`;
+		`datafmt.T2 = s ["-" p "-"];`
 
 	_ =
 		`datafmt "datafmt";` +
 			`default = "%v";` +
 			`array = *;` +
-			`datafmt.T3 = s  {" " a a / ","};`;
+			`datafmt.T3 = s  {" " a a / ","};`
 
 	_ = `datafmt "datafmt";` +
 		`default = "%v";` +
 		`array = *;` +
-		`datafmt.T3 = s  {" " a a / ","};`;
+		`datafmt.T3 = s  {" " a a / ","};`
 }
 
 
@@ -276,24 +276,24 @@ func _() {
 	// respect source lines in multi-line expressions
 	_ = a +
 		b +
-		c;
+		c
 	_ = a < b ||
-		b < a;
+		b < a
 	_ = "933262154439441526816992388562667004907159682643816214685929" +
 		"638952175999932299156089414639761565182862536979208272237582" +
-		"51185210916864000000000000000000000000";	// 100!
-	_ = "170141183460469231731687303715884105727";	// prime
+		"51185210916864000000000000000000000000"	// 100!
+	_ = "170141183460469231731687303715884105727"	// prime
 }
 
 
 // Alignment after overlong lines
 const (
-	_	= "991";
-	_	= "2432902008176640000";	// 20!
+	_	= "991"
+	_	= "2432902008176640000"	// 20!
 	_	= "933262154439441526816992388562667004907159682643816214685929" +
 		"638952175999932299156089414639761565182862536979208272237582" +
-		"51185210916864000000000000000000000000";	// 100!
-	_	= "170141183460469231731687303715884105727";	// prime
+		"51185210916864000000000000000000000000"	// 100!
+	_	= "170141183460469231731687303715884105727"	// prime
 )
 
 
@@ -301,11 +301,11 @@ const (
 func _() {
 	_ = a +	// comment
 		b +	// comment
-		c;
+		c
 	_ = "a" +	// comment
 		"b" +	// comment
-		"c";
-	_ = "ba0408" + "7265717569726564";	// field 71, encoding 2, string "required"
+		"c"
+	_ = "ba0408" + "7265717569726564"	// field 71, encoding 2, string "required"
 }
 
 
@@ -313,25 +313,27 @@ func _() {
 func _() {
 	f(1,
 		2,
-		3);
+		3)
 	f(1,
 		2,
-		3);
+		3,
+	)
 	// TODO(gri) the cases below are not correct yet
 	f(1,
 		2,
-		3);	// comment
+		3)	// comment
 	f(1,
 		2,
-		3	// comment
-	);
+		3,	// comment
+	)
 	f(1,
 		2,
-		3);	// comment
+		3)	// comment
 	f(1,
 		2,
-		3	// comment
-	);
+		3 // comment
+		,
+	)
 }
 
 
@@ -353,8 +355,8 @@ func (p *parser) charClass() {
 	// respect source lines in multi-line expressions
 	if cc.negate && len(cc.ranges) == 2 &&
 		cc.ranges[0] == '\n' && cc.ranges[1] == '\n' {
-		nl := new(_NotNl);
-		p.re.add(nl);
+		nl := new(_NotNl)
+		p.re.add(nl)
 	}
 }
 
diff --git a/src/pkg/go/printer/testdata/expressions.raw b/src/pkg/go/printer/testdata/expressions.raw
index c273932bdd..003e83aeed 100644
--- a/src/pkg/go/printer/testdata/expressions.raw
+++ b/src/pkg/go/printer/testdata/expressions.raw
@@ -5,233 +5,233 @@
 package expressions
 
 type T struct {
-	x, y, z int;
+	x, y, z int
 }
 
 var (
-	a, b, c, d, e	int;
-	under_bar	int;
-	longIdentifier1, longIdentifier2, longIdentifier3	int;
-	t0, t1, t2	T;
-	s	string;
-	p	*int;
+	a, b, c, d, e	int
+	under_bar	int
+	longIdentifier1, longIdentifier2, longIdentifier3	int
+	t0, t1, t2	T
+	s	string
+	p	*int
 )
 
 
 func _() {
 	// no spaces around simple or parenthesized expressions
-	_ = a + b;
-	_ = a + b + c;
-	_ = a + b - c;
-	_ = a - b - c;
-	_ = a + (b * c);
-	_ = a + (b / c);
-	_ = a - (b % c);
-	_ = 1 + a;
-	_ = a + 1;
-	_ = a + b + 1;
-	_ = s[1:2];
-	_ = s[a:b];
-	_ = s[0:len(s)];
-	_ = s[0] << 1;
-	_ = (s[0] << 1) & 0xf;
-	_ = s[0]<<2 | s[1]>>4;
-	_ = "foo" + s;
-	_ = s + "foo";
-	_ = 'a' + 'b';
-	_ = len(s) / 2;
-	_ = len(t0.x) / a;
+	_ = a + b
+	_ = a + b + c
+	_ = a + b - c
+	_ = a - b - c
+	_ = a + (b * c)
+	_ = a + (b / c)
+	_ = a - (b % c)
+	_ = 1 + a
+	_ = a + 1
+	_ = a + b + 1
+	_ = s[1:2]
+	_ = s[a:b]
+	_ = s[0:len(s)]
+	_ = s[0] << 1
+	_ = (s[0] << 1) & 0xf
+	_ = s[0]<<2 | s[1]>>4
+	_ = "foo" + s
+	_ = s + "foo"
+	_ = 'a' + 'b'
+	_ = len(s) / 2
+	_ = len(t0.x) / a
 
 	// spaces around expressions of different precedence or expressions containing spaces
-	_ = a + -b;
-	_ = a - ^b;
-	_ = a / *p;
-	_ = a + b*c;
-	_ = 1 + b*c;
-	_ = a + 2*c;
-	_ = a + c*2;
-	_ = 1 + 2*3;
-	_ = s[1 : 2*3];
-	_ = s[a : b-c];
-	_ = s[0:];
-	_ = s[a+b];
-	_ = s[a+b:];
-	_ = a[a<<b+1];
-	_ = a[a<<b+1:];
-	_ = s[a+b : len(s)];
-	_ = s[len(s):-a];
-	_ = s[a : len(s)+1];
-	_ = s[a:len(s)+1] + s;
+	_ = a + -b
+	_ = a - ^b
+	_ = a / *p
+	_ = a + b*c
+	_ = 1 + b*c
+	_ = a + 2*c
+	_ = a + c*2
+	_ = 1 + 2*3
+	_ = s[1 : 2*3]
+	_ = s[a : b-c]
+	_ = s[0:]
+	_ = s[a+b]
+	_ = s[a+b:]
+	_ = a[a<<b+1]
+	_ = a[a<<b+1:]
+	_ = s[a+b : len(s)]
+	_ = s[len(s):-a]
+	_ = s[a : len(s)+1]
+	_ = s[a:len(s)+1] + s
 
 	// spaces around operators with equal or lower precedence than comparisons
-	_ = a == b;
-	_ = a != b;
-	_ = a > b;
-	_ = a >= b;
-	_ = a < b;
-	_ = a <= b;
-	_ = a < b && c > d;
-	_ = a < b || c > d;
+	_ = a == b
+	_ = a != b
+	_ = a > b
+	_ = a >= b
+	_ = a < b
+	_ = a <= b
+	_ = a < b && c > d
+	_ = a < b || c > d
 
 	// spaces around "long" operands
-	_ = a + longIdentifier1;
-	_ = longIdentifier1 + a;
-	_ = longIdentifier1 + longIdentifier2*longIdentifier3;
-	_ = s + "a longer string";
+	_ = a + longIdentifier1
+	_ = longIdentifier1 + a
+	_ = longIdentifier1 + longIdentifier2*longIdentifier3
+	_ = s + "a longer string"
 
 	// some selected cases
-	_ = a + t0.x;
-	_ = a + t0.x + t1.x*t2.x;
-	_ = a + b + c + d + e + 2*3;
-	_ = a + b + c + 2*3 + d + e;
-	_ = (a + b + c) * 2;
-	_ = a - b + c - d + (a + b + c) + d&e;
-	_ = under_bar - 1;
-	_ = Open(dpath+"/file", O_WRONLY|O_CREAT, 0666);
-	_ = int(c0&_Mask4)<<18 | int(c1&_Maskx)<<12 | int(c2&_Maskx)<<6 | int(c3&_Maskx);
+	_ = a + t0.x
+	_ = a + t0.x + t1.x*t2.x
+	_ = a + b + c + d + e + 2*3
+	_ = a + b + c + 2*3 + d + e
+	_ = (a + b + c) * 2
+	_ = a - b + c - d + (a + b + c) + d&e
+	_ = under_bar - 1
+	_ = Open(dpath+"/file", O_WRONLY|O_CREAT, 0666)
+	_ = int(c0&_Mask4)<<18 | int(c1&_Maskx)<<12 | int(c2&_Maskx)<<6 | int(c3&_Maskx)
 }
 
 
 func _() {
-	a + b;
-	a + b + c;
-	a + b*c;
-	a + (b * c);
-	(a + b) * c;
-	a + (b * c * d);
-	a + (b*c + d);
-
-	1 << x;
-	-1 << x;
-	1<<x - 1;
-	-1<<x - 1;
-
-	f(a + b);
-	f(a + b + c);
-	f(a + b*c);
-	f(a + (b * c));
-	f(1<<x-1, 1<<x-2);
-
-	1<<d.logWindowSize - 1;
-
-	buf = make(x, 2*cap(b.buf)+n);
-
-	dst[i*3+2] = dbuf[0] << 2;
-	dst[i*3+2] = dbuf[0]<<2 | dbuf[1]>>4;
-
-	b.buf = b.buf[0 : b.off+m+n];
-	b.buf = b.buf[0 : b.off+m*n];
-	f(b.buf[0 : b.off+m+n]);
-
-	signed += ' ' * 8;
-	tw.octal(header[148:155], chksum);
-
-	x > 0 && i >= 0;
-
-	x1, x0 := x>>w2, x&m2;
-	z0 = t1<<w2 + t0;
-	z1 = (t1 + t0>>w2) >> w2;
-	q1, r1 := x1/d1, x1%d1;
-	r1 = r1*b2 | x0>>w2;
-	x1 = (x1 << z) | (x0 >> (uint(w) - z));
-	x1 = x1<<z | x0>>(uint(w)-z);
-
-	buf[0 : len(buf)+1];
-	buf[0 : n+1];
-
-	a, b = b, a;
-	a = b + c;
-	a = b*c + d;
-	a*b + c;
-	a - b - c;
-	a - (b - c);
-	a - b*c;
-	a - (b * c);
-	a * b / c;
-	a / *b;
-	x[a|^b];
-	x[a / *b];
-	a & ^b;
-	a + +b;
-	a - -b;
-	x[a*-b];
-	x[a + +b];
-	x ^ y ^ z;
-	b[a>>24] ^ b[(a>>16)&0xFF] ^ b[(a>>8)&0xFF] ^ b[a&0xFF];
-	len(longVariableName) * 2;
-
-	token(matchType + xlength<<lengthShift + xoffset);
+	a + b
+	a + b + c
+	a + b*c
+	a + (b * c)
+	(a + b) * c
+	a + (b * c * d)
+	a + (b*c + d)
+
+	1 << x
+	-1 << x
+	1<<x - 1
+	-1<<x - 1
+
+	f(a + b)
+	f(a + b + c)
+	f(a + b*c)
+	f(a + (b * c))
+	f(1<<x-1, 1<<x-2)
+
+	1<<d.logWindowSize - 1
+
+	buf = make(x, 2*cap(b.buf)+n)
+
+	dst[i*3+2] = dbuf[0] << 2
+	dst[i*3+2] = dbuf[0]<<2 | dbuf[1]>>4
+
+	b.buf = b.buf[0 : b.off+m+n]
+	b.buf = b.buf[0 : b.off+m*n]
+	f(b.buf[0 : b.off+m+n])
+
+	signed += ' ' * 8
+	tw.octal(header[148:155], chksum)
+
+	x > 0 && i >= 0
+
+	x1, x0 := x>>w2, x&m2
+	z0 = t1<<w2 + t0
+	z1 = (t1 + t0>>w2) >> w2
+	q1, r1 := x1/d1, x1%d1
+	r1 = r1*b2 | x0>>w2
+	x1 = (x1 << z) | (x0 >> (uint(w) - z))
+	x1 = x1<<z | x0>>(uint(w)-z)
+
+	buf[0 : len(buf)+1]
+	buf[0 : n+1]
+
+	a, b = b, a
+	a = b + c
+	a = b*c + d
+	a*b + c
+	a - b - c
+	a - (b - c)
+	a - b*c
+	a - (b * c)
+	a * b / c
+	a / *b
+	x[a|^b]
+	x[a / *b]
+	a & ^b
+	a + +b
+	a - -b
+	x[a*-b]
+	x[a + +b]
+	x ^ y ^ z
+	b[a>>24] ^ b[(a>>16)&0xFF] ^ b[(a>>8)&0xFF] ^ b[a&0xFF]
+	len(longVariableName) * 2
+
+	token(matchType + xlength<<lengthShift + xoffset)
 }
 
 
 func _() {
-	_ = T{};
-	_ = struct{}{};
-	_ = [10]T{};
-	_ = [...]T{};
-	_ = []T{};
-	_ = map[int]T{};
-
-	_ = (T){};
-	_ = (struct{}){};
-	_ = ([10]T){};
-	_ = ([...]T){};
-	_ = ([]T){};
-	_ = (map[int]T){};
+	_ = T{}
+	_ = struct{}{}
+	_ = [10]T{}
+	_ = [...]T{}
+	_ = []T{}
+	_ = map[int]T{}
+
+	_ = (T){}
+	_ = (struct{}){}
+	_ = ([10]T){}
+	_ = ([...]T){}
+	_ = ([]T){}
+	_ = (map[int]T){}
 }
 
 
 // one-line structs/interfaces in composite literals (up to a threshold)
 func _() {
-	_ = struct{}{};
-	_ = struct{ x int }{0};
-	_ = struct{ x, y, z int }{0, 1, 2};
-	_ = struct{ int }{0};
+	_ = struct{}{}
+	_ = struct{ x int }{0}
+	_ = struct{ x, y, z int }{0, 1, 2}
+	_ = struct{ int }{0}
 	_ = struct {
 		s struct {
-			int;
-		};
-	}{struct{ int }{0}};	// compositeLit context not propagated => multiLine result
+			int
+		}
+	}{struct{ int }{0}}	// compositeLit context not propagated => multiLine result
 }
 
 
 func _() {
 	// do not modify literals
-	_ = "tab1	tab2	tab3	end";	// string contains 3 tabs
-	_ = "tab1 tab2 tab3 end";	// same string with 3 blanks - may be unaligned because editors see tabs in strings
-	_ = "";	// this comment should be aligned with the one on the previous line
-	_ = ``;
+	_ = "tab1	tab2	tab3	end"	// string contains 3 tabs
+	_ = "tab1 tab2 tab3 end"	// same string with 3 blanks - may be unaligned because editors see tabs in strings
+	_ = ""	// this comment should be aligned with the one on the previous line
+	_ = ``
 	_ = `
-`;
+`
 	_ = `foo
-		bar`;
+		bar`
 }
 
 
 func _() {
 	// one-line function literals
-	_ = func() {};
-	_ = func() int { return 0 };
-	_ = func(x, y int) bool { return x < y };
+	_ = func() {}
+	_ = func() int { return 0 }
+	_ = func(x, y int) bool { return x < y }
 
-	f(func() {});
-	f(func() int { return 0 });
-	f(func(x, y int) bool { return x < y });
+	f(func() {})
+	f(func() int { return 0 })
+	f(func(x, y int) bool { return x < y })
 }
 
 
 func _() {
 	// do not add extra indentation to multi-line string lists
-	_ = "foo" + "bar";
+	_ = "foo" + "bar"
 	_ = "foo" +
 		"bar" +
-		"bah";
+		"bah"
 	_ = []string{
 		"abc" +
 			"def",
 		"foo" +
 			"bar",
-	};
+	}
 }
 
 
@@ -257,18 +257,18 @@ func _() {
 	_ = F1 +
 		`string = "%s";` +
 		`ptr = *;` +
-		`datafmt.T2 = s ["-" p "-"];`;
+		`datafmt.T2 = s ["-" p "-"];`
 
 	_ =
 		`datafmt "datafmt";` +
 			`default = "%v";` +
 			`array = *;` +
-			`datafmt.T3 = s  {" " a a / ","};`;
+			`datafmt.T3 = s  {" " a a / ","};`
 
 	_ = `datafmt "datafmt";` +
 		`default = "%v";` +
 		`array = *;` +
-		`datafmt.T3 = s  {" " a a / ","};`;
+		`datafmt.T3 = s  {" " a a / ","};`
 }
 
 
@@ -276,24 +276,24 @@ func _() {
 	// respect source lines in multi-line expressions
 	_ = a +
 		b +
-		c;
+		c
 	_ = a < b ||
-		b < a;
+		b < a
 	_ = "933262154439441526816992388562667004907159682643816214685929" +
 		"638952175999932299156089414639761565182862536979208272237582" +
-		"51185210916864000000000000000000000000";	// 100!
-	_ = "170141183460469231731687303715884105727";	// prime
+		"51185210916864000000000000000000000000"	// 100!
+	_ = "170141183460469231731687303715884105727"	// prime
 }
 
 
 // Alignment after overlong lines
 const (
-	_		= "991";
-	_		= "2432902008176640000";	// 20!
+	_		= "991"
+	_		= "2432902008176640000"	// 20!
 	_		= "933262154439441526816992388562667004907159682643816214685929" +
 		"638952175999932299156089414639761565182862536979208272237582" +
-		"51185210916864000000000000000000000000";	// 100!
-	_		= "170141183460469231731687303715884105727";	// prime
+		"51185210916864000000000000000000000000"	// 100!
+	_		= "170141183460469231731687303715884105727"	// prime
 )
 
 
@@ -301,11 +301,11 @@ const (
 func _() {
 	_ = a +	// comment
 		b +	// comment
-		c;
+		c
 	_ = "a" +	// comment
 		"b" +	// comment
-		"c";
-	_ = "ba0408" + "7265717569726564";	// field 71, encoding 2, string "required"
+		"c"
+	_ = "ba0408" + "7265717569726564"	// field 71, encoding 2, string "required"
 }
 
 
@@ -313,25 +313,27 @@ func _() {
 func _() {
 	f(1,
 		2,
-		3);
+		3)
 	f(1,
 		2,
-		3);
+		3,
+	)
 	// TODO(gri) the cases below are not correct yet
 	f(1,
 		2,
-		3);	// comment
+		3)	// comment
 	f(1,
 		2,
-		3	// comment
-	);
+		3,	// comment
+	)
 	f(1,
 		2,
-		3);	// comment
+		3)	// comment
 	f(1,
 		2,
-		3	// comment
-	);
+		3 // comment
+		,
+	)
 }
 
 
@@ -353,8 +355,8 @@ func (p *parser) charClass() {
 	// respect source lines in multi-line expressions
 	if cc.negate && len(cc.ranges) == 2 &&
 		cc.ranges[0] == '\n' && cc.ranges[1] == '\n' {
-		nl := new(_NotNl);
-		p.re.add(nl);
+		nl := new(_NotNl)
+		p.re.add(nl)
 	}
 }
 
diff --git a/src/pkg/go/printer/testdata/linebreaks.golden b/src/pkg/go/printer/testdata/linebreaks.golden
index a4602c90ce..01c673f770 100644
--- a/src/pkg/go/printer/testdata/linebreaks.golden
+++ b/src/pkg/go/printer/testdata/linebreaks.golden
@@ -5,23 +5,23 @@
 package linebreaks
 
 import (
-	"bytes";
-	"fmt";
-	"io";
-	"os";
-	"reflect";
-	"strings";
-	"testing";
+	"bytes"
+	"fmt"
+	"io"
+	"os"
+	"reflect"
+	"strings"
+	"testing"
 )
 
 type writerTestEntry struct {
-	header		*Header;
-	contents	string;
+	header		*Header
+	contents	string
 }
 
 type writerTest struct {
-	file	string;	// filename of expected output
-	entries	[]*writerTestEntry;
+	file	string	// filename of expected output
+	entries	[]*writerTestEntry
 }
 
 var writerTests = []*writerTest{
@@ -83,8 +83,8 @@ var writerTests = []*writerTest{
 }
 
 type untarTest struct {
-	file	string;
-	headers	[]*Header;
+	file	string
+	headers	[]*Header
 }
 
 var untarTests = []*untarTest{
@@ -186,36 +186,36 @@ func usage() {
 	fmt.Fprintf(os.Stderr,
 		// TODO(gri): the 2nd string of this string list should not be indented
 		"usage: godoc package [name ...]\n"+
-			"	godoc -http=:6060\n");
-	flag.PrintDefaults();
-	os.Exit(2);
+			"	godoc -http=:6060\n")
+	flag.PrintDefaults()
+	os.Exit(2)
 }
 
 func TestReader(t *testing.T) {
 testLoop:
 	for i, test := range untarTests {
-		f, err := os.Open(test.file, os.O_RDONLY, 0444);
+		f, err := os.Open(test.file, os.O_RDONLY, 0444)
 		if err != nil {
-			t.Errorf("test %d: Unexpected error: %v", i, err);
-			continue;
+			t.Errorf("test %d: Unexpected error: %v", i, err)
+			continue
 		}
-		tr := NewReader(f);
+		tr := NewReader(f)
 		for j, header := range test.headers {
-			hdr, err := tr.Next();
+			hdr, err := tr.Next()
 			if err != nil || hdr == nil {
-				t.Errorf("test %d, entry %d: Didn't get entry: %v", i, j, err);
-				f.Close();
-				continue testLoop;
+				t.Errorf("test %d, entry %d: Didn't get entry: %v", i, j, err)
+				f.Close()
+				continue testLoop
 			}
 			if !reflect.DeepEqual(hdr, header) {
 				t.Errorf("test %d, entry %d: Incorrect header:\nhave %+v\nwant %+v",
 					i, j, *hdr, *header)
 			}
 		}
-		hdr, err := tr.Next();
+		hdr, err := tr.Next()
 		if hdr != nil || err != nil {
 			t.Errorf("test %d: Unexpected entry or error: hdr=%v err=%v", i, err)
 		}
-		f.Close();
+		f.Close()
 	}
 }
diff --git a/src/pkg/go/printer/testdata/statements.golden b/src/pkg/go/printer/testdata/statements.golden
index b09352c4c1..b7d8ad2ea1 100644
--- a/src/pkg/go/printer/testdata/statements.golden
+++ b/src/pkg/go/printer/testdata/statements.golden
@@ -64,16 +64,16 @@ func _() {
 
 	switch x := 0; x {
 	case 1:
-		use(x);
-		use(x);	// followed by an empty line
+		use(x)
+		use(x)	// followed by an empty line
 
 	case 2:	// followed by an empty line
 
 		use(x)	// followed by an empty line
 
 	case 3:	// no empty lines
-		use(x);
-		use(x);
+		use(x)
+		use(x)
 	}
 
 	switch x {
@@ -152,20 +152,20 @@ func _() {
 // line at a time.
 func _() {
 
-	const _ = 0;
+	const _ = 0
 
-	const _ = 1;
-	type _ int;
-	type _ float;
+	const _ = 1
+	type _ int
+	type _ float
 
-	var _ = 0;
-	var x = 1;
+	var _ = 0
+	var x = 1
 
 	// Each use(x) call below should have at most one empty line before and after.
 
 
 
-	use(x);
+	use(x)
 
 	if x < x {
 
@@ -206,9 +206,9 @@ L:	_ = 0
 
 func _() {
 	for {
-	L1:	_ = 0;
+	L1:	_ = 0
 	L2:
-		_ = 0;
+		_ = 0
 	}
 }
 
@@ -216,9 +216,9 @@ func _() {
 func _() {
 	// this comment should be indented
 	for {
-	L1:	_ = 0;
+	L1:	_ = 0
 	L2:
-		_ = 0;
+		_ = 0
 	}
 }
 
@@ -227,14 +227,14 @@ func _() {
 	if {
 		_ = 0
 	}
-	_ = 0;	// the indentation here should not be affected by the long label name
+	_ = 0	// the indentation here should not be affected by the long label name
 AnOverlongLabel:
-	_ = 0;
+	_ = 0
 
 	if {
 		_ = 0
 	}
-	_ = 0;
+	_ = 0
 
-L:	_ = 0;
+L:	_ = 0
 }
