commit 9754521157caffde83f630410781abd9e35f18d5
Author: Austin Clements <austin@google.com>
Date:   Mon Apr 17 15:43:29 2023 -0400

    internal/abi, runtime, cmd: merge funcID_* consts into internal/abi
    
    For #59670.
    
    Change-Id: I517e97ea74cf232e5cfbb77b127fa8804f74d84b
    Reviewed-on: https://go-review.googlesource.com/c/go/+/485495
    Reviewed-by: Michael Pratt <mpratt@google.com>
    TryBot-Result: Gopher Robot <gobot@golang.org>
    Auto-Submit: Austin Clements <austin@google.com>
    Run-TryBot: Austin Clements <austin@google.com>
---
 src/cmd/internal/goobj/funcinfo.go     |  5 +-
 src/cmd/internal/obj/link.go           |  3 +-
 src/cmd/internal/objabi/funcid.go      | 91 ++++++++++++----------------------
 src/cmd/link/internal/ld/pcln.go       |  5 +-
 src/cmd/link/internal/loader/loader.go |  3 +-
 src/internal/abi/symtab.go             | 39 +++++++++++++++
 src/runtime/mgcmark.go                 |  5 +-
 src/runtime/panic.go                   |  3 +-
 src/runtime/race.go                    |  2 +-
 src/runtime/runtime2.go                |  7 +--
 src/runtime/stack.go                   |  4 +-
 src/runtime/symtab.go                  | 39 ++-------------
 src/runtime/symtabinl.go               |  4 +-
 src/runtime/symtabinl_test.go          |  2 +-
 src/runtime/trace.go                   |  5 +-
 src/runtime/traceback.go               | 41 +++++++--------
 16 files changed, 124 insertions(+), 134 deletions(-)

diff --git a/src/cmd/internal/goobj/funcinfo.go b/src/cmd/internal/goobj/funcinfo.go
index fbcf9d9bb5..118c514460 100644
--- a/src/cmd/internal/goobj/funcinfo.go
+++ b/src/cmd/internal/goobj/funcinfo.go
@@ -8,6 +8,7 @@ import (
 	"bytes"
 	"cmd/internal/objabi"
 	"encoding/binary"
+	"internal/abi"
 )
 
 // CUFileIndex is used to index the filenames that are stored in the
@@ -19,7 +20,7 @@ type CUFileIndex uint32
 type FuncInfo struct {
 	Args      uint32
 	Locals    uint32
-	FuncID    objabi.FuncID
+	FuncID    abi.FuncID
 	FuncFlag  objabi.FuncFlag
 	StartLine int32
 	File      []CUFileIndex
@@ -89,7 +90,7 @@ func (*FuncInfo) ReadArgs(b []byte) uint32 { return binary.LittleEndian.Uint32(b
 
 func (*FuncInfo) ReadLocals(b []byte) uint32 { return binary.LittleEndian.Uint32(b[4:]) }
 
-func (*FuncInfo) ReadFuncID(b []byte) objabi.FuncID { return objabi.FuncID(b[8]) }
+func (*FuncInfo) ReadFuncID(b []byte) abi.FuncID { return abi.FuncID(b[8]) }
 
 func (*FuncInfo) ReadFuncFlag(b []byte) objabi.FuncFlag { return objabi.FuncFlag(b[9]) }
 
diff --git a/src/cmd/internal/obj/link.go b/src/cmd/internal/obj/link.go
index 037561db1f..c238070d0e 100644
--- a/src/cmd/internal/obj/link.go
+++ b/src/cmd/internal/obj/link.go
@@ -39,6 +39,7 @@ import (
 	"cmd/internal/sys"
 	"encoding/binary"
 	"fmt"
+	"internal/abi"
 	"sync"
 	"sync/atomic"
 )
@@ -476,7 +477,7 @@ type FuncInfo struct {
 	Args      int32
 	Locals    int32
 	Align     int32
-	FuncID    objabi.FuncID
+	FuncID    abi.FuncID
 	FuncFlag  objabi.FuncFlag
 	StartLine int32
 	Text      *Prog
diff --git a/src/cmd/internal/objabi/funcid.go b/src/cmd/internal/objabi/funcid.go
index c2eb4d545b..65f605d0ff 100644
--- a/src/cmd/internal/objabi/funcid.go
+++ b/src/cmd/internal/objabi/funcid.go
@@ -4,7 +4,10 @@
 
 package objabi
 
-import "strings"
+import (
+	"internal/abi"
+	"strings"
+)
 
 // A FuncFlag records bits about a function, passed to the runtime.
 type FuncFlag uint8
@@ -16,76 +19,44 @@ const (
 	FuncFlag_ASM
 )
 
-// A FuncID identifies particular functions that need to be treated
-// specially by the runtime.
-// Note that in some situations involving plugins, there may be multiple
-// copies of a particular special runtime function.
-type FuncID uint8
-
-// Note: this list must match the list in runtime/symtab.go.
-const (
-	FuncID_normal FuncID = iota // not a special function
-	FuncID_abort
-	FuncID_asmcgocall
-	FuncID_asyncPreempt
-	FuncID_cgocallback
-	FuncID_debugCallV2
-	FuncID_gcBgMarkWorker
-	FuncID_goexit
-	FuncID_gogo
-	FuncID_gopanic
-	FuncID_handleAsyncEvent
-	FuncID_mcall
-	FuncID_morestack
-	FuncID_mstart
-	FuncID_panicwrap
-	FuncID_rt0_go
-	FuncID_runfinq
-	FuncID_runtime_main
-	FuncID_sigpanic
-	FuncID_systemstack
-	FuncID_systemstack_switch
-	FuncID_wrapper // any autogenerated code (hash/eq algorithms, method wrappers, etc.)
-)
-
-var funcIDs = map[string]FuncID{
-	"abort":              FuncID_abort,
-	"asmcgocall":         FuncID_asmcgocall,
-	"asyncPreempt":       FuncID_asyncPreempt,
-	"cgocallback":        FuncID_cgocallback,
-	"debugCallV2":        FuncID_debugCallV2,
-	"gcBgMarkWorker":     FuncID_gcBgMarkWorker,
-	"rt0_go":             FuncID_rt0_go,
-	"goexit":             FuncID_goexit,
-	"gogo":               FuncID_gogo,
-	"gopanic":            FuncID_gopanic,
-	"handleAsyncEvent":   FuncID_handleAsyncEvent,
-	"main":               FuncID_runtime_main,
-	"mcall":              FuncID_mcall,
-	"morestack":          FuncID_morestack,
-	"mstart":             FuncID_mstart,
-	"panicwrap":          FuncID_panicwrap,
-	"runfinq":            FuncID_runfinq,
-	"sigpanic":           FuncID_sigpanic,
-	"systemstack_switch": FuncID_systemstack_switch,
-	"systemstack":        FuncID_systemstack,
+var funcIDs = map[string]abi.FuncID{
+	"abort":              abi.FuncID_abort,
+	"asmcgocall":         abi.FuncID_asmcgocall,
+	"asyncPreempt":       abi.FuncID_asyncPreempt,
+	"cgocallback":        abi.FuncID_cgocallback,
+	"debugCallV2":        abi.FuncID_debugCallV2,
+	"gcBgMarkWorker":     abi.FuncID_gcBgMarkWorker,
+	"rt0_go":             abi.FuncID_rt0_go,
+	"goexit":             abi.FuncID_goexit,
+	"gogo":               abi.FuncID_gogo,
+	"gopanic":            abi.FuncID_gopanic,
+	"handleAsyncEvent":   abi.FuncID_handleAsyncEvent,
+	"main":               abi.FuncID_runtime_main,
+	"mcall":              abi.FuncID_mcall,
+	"morestack":          abi.FuncID_morestack,
+	"mstart":             abi.FuncID_mstart,
+	"panicwrap":          abi.FuncID_panicwrap,
+	"runfinq":            abi.FuncID_runfinq,
+	"sigpanic":           abi.FuncID_sigpanic,
+	"systemstack_switch": abi.FuncID_systemstack_switch,
+	"systemstack":        abi.FuncID_systemstack,
 
 	// Don't show in call stack but otherwise not special.
-	"deferreturn":       FuncID_wrapper,
-	"runOpenDeferFrame": FuncID_wrapper,
-	"deferCallSave":     FuncID_wrapper,
+	"deferreturn":       abi.FuncIDWrapper,
+	"runOpenDeferFrame": abi.FuncIDWrapper,
+	"deferCallSave":     abi.FuncIDWrapper,
 }
 
 // Get the function ID for the named function in the named file.
 // The function should be package-qualified.
-func GetFuncID(name string, isWrapper bool) FuncID {
+func GetFuncID(name string, isWrapper bool) abi.FuncID {
 	if isWrapper {
-		return FuncID_wrapper
+		return abi.FuncIDWrapper
 	}
 	if strings.HasPrefix(name, "runtime.") {
 		if id, ok := funcIDs[name[len("runtime."):]]; ok {
 			return id
 		}
 	}
-	return FuncID_normal
+	return abi.FuncIDNormal
 }
diff --git a/src/cmd/link/internal/ld/pcln.go b/src/cmd/link/internal/ld/pcln.go
index b18a2b4bd4..7a0425d131 100644
--- a/src/cmd/link/internal/ld/pcln.go
+++ b/src/cmd/link/internal/ld/pcln.go
@@ -11,6 +11,7 @@ import (
 	"cmd/link/internal/loader"
 	"cmd/link/internal/sym"
 	"fmt"
+	"internal/abi"
 	"internal/buildcfg"
 	"os"
 	"path/filepath"
@@ -168,7 +169,7 @@ func genInlTreeSym(ctxt *Link, cu *sym.CompilationUnit, fi loader.FuncInfo, arch
 		}
 
 		inlFunc := ldr.FuncInfo(call.Func)
-		var funcID objabi.FuncID
+		var funcID abi.FuncID
 		startLine := int32(0)
 		if inlFunc.Valid() {
 			funcID = inlFunc.FuncID()
@@ -698,7 +699,7 @@ func writeFuncs(ctxt *Link, sb *loader.SymbolBuilder, funcs []loader.Sym, inlSym
 		off = sb.SetUint32(ctxt.Arch, off, uint32(startLine))
 
 		// funcID uint8
-		var funcID objabi.FuncID
+		var funcID abi.FuncID
 		if fi.Valid() {
 			funcID = fi.FuncID()
 		}
diff --git a/src/cmd/link/internal/loader/loader.go b/src/cmd/link/internal/loader/loader.go
index fa8c0c6b20..e72c89f38e 100644
--- a/src/cmd/link/internal/loader/loader.go
+++ b/src/cmd/link/internal/loader/loader.go
@@ -14,6 +14,7 @@ import (
 	"cmd/link/internal/sym"
 	"debug/elf"
 	"fmt"
+	"internal/abi"
 	"io"
 	"log"
 	"math/bits"
@@ -1990,7 +1991,7 @@ func (fi *FuncInfo) Locals() int {
 	return int((*goobj.FuncInfo)(nil).ReadLocals(fi.data))
 }
 
-func (fi *FuncInfo) FuncID() objabi.FuncID {
+func (fi *FuncInfo) FuncID() abi.FuncID {
 	return (*goobj.FuncInfo)(nil).ReadFuncID(fi.data)
 }
 
diff --git a/src/internal/abi/symtab.go b/src/internal/abi/symtab.go
new file mode 100644
index 0000000000..2f8434355f
--- /dev/null
+++ b/src/internal/abi/symtab.go
@@ -0,0 +1,39 @@
+// Copyright 2023 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package abi
+
+// A FuncID identifies particular functions that need to be treated
+// specially by the runtime.
+// Note that in some situations involving plugins, there may be multiple
+// copies of a particular special runtime function.
+type FuncID uint8
+
+const (
+	// If you add a FuncID, you probably also want to add an entry to the map in
+	// ../../cmd/internal/objabi/funcid.go
+
+	FuncIDNormal FuncID = iota // not a special function
+	FuncID_abort
+	FuncID_asmcgocall
+	FuncID_asyncPreempt
+	FuncID_cgocallback
+	FuncID_debugCallV2
+	FuncID_gcBgMarkWorker
+	FuncID_goexit
+	FuncID_gogo
+	FuncID_gopanic
+	FuncID_handleAsyncEvent
+	FuncID_mcall
+	FuncID_morestack
+	FuncID_mstart
+	FuncID_panicwrap
+	FuncID_rt0_go
+	FuncID_runfinq
+	FuncID_runtime_main
+	FuncID_sigpanic
+	FuncID_systemstack
+	FuncID_systemstack_switch
+	FuncIDWrapper // any autogenerated code (hash/eq algorithms, method wrappers, etc.)
+)
diff --git a/src/runtime/mgcmark.go b/src/runtime/mgcmark.go
index d5c981f17a..8ae2256774 100644
--- a/src/runtime/mgcmark.go
+++ b/src/runtime/mgcmark.go
@@ -7,6 +7,7 @@
 package runtime
 
 import (
+	"internal/abi"
 	"internal/goarch"
 	"runtime/internal/atomic"
 	"runtime/internal/sys"
@@ -919,8 +920,8 @@ func scanframeworker(frame *stkframe, state *stackScanState, gcw *gcWork) {
 		print("scanframe ", funcname(frame.fn), "\n")
 	}
 
-	isAsyncPreempt := frame.fn.valid() && frame.fn.funcID == funcID_asyncPreempt
-	isDebugCall := frame.fn.valid() && frame.fn.funcID == funcID_debugCallV2
+	isAsyncPreempt := frame.fn.valid() && frame.fn.funcID == abi.FuncID_asyncPreempt
+	isDebugCall := frame.fn.valid() && frame.fn.funcID == abi.FuncID_debugCallV2
 	if state.conservative || isAsyncPreempt || isDebugCall {
 		if debugScanConservative {
 			println("conservatively scanning function", funcname(frame.fn), "at PC", hex(frame.continpc))
diff --git a/src/runtime/panic.go b/src/runtime/panic.go
index 89070d226c..a68f34f767 100644
--- a/src/runtime/panic.go
+++ b/src/runtime/panic.go
@@ -5,6 +5,7 @@
 package runtime
 
 import (
+	"internal/abi"
 	"internal/goarch"
 	"runtime/internal/atomic"
 	"runtime/internal/sys"
@@ -1400,5 +1401,5 @@ func isAbortPC(pc uintptr) bool {
 	if !f.valid() {
 		return false
 	}
-	return f.funcID == funcID_abort
+	return f.funcID == abi.FuncID_abort
 }
diff --git a/src/runtime/race.go b/src/runtime/race.go
index 33360d192f..f7e99fd940 100644
--- a/src/runtime/race.go
+++ b/src/runtime/race.go
@@ -175,7 +175,7 @@ func raceSymbolizeCode(ctx *symbolizeCodeContext) {
 		u, uf := newInlineUnwinder(fi, pc, nil)
 		for ; uf.valid(); uf = u.next(uf) {
 			sf := u.srcFunc(uf)
-			if sf.funcID == funcID_wrapper {
+			if sf.funcID == abi.FuncIDWrapper {
 				// ignore wrappers
 				continue
 			}
diff --git a/src/runtime/runtime2.go b/src/runtime/runtime2.go
index a9706a642e..616e59c094 100644
--- a/src/runtime/runtime2.go
+++ b/src/runtime/runtime2.go
@@ -5,6 +5,7 @@
 package runtime
 
 import (
+	"internal/abi"
 	"internal/goarch"
 	"runtime/internal/atomic"
 	"runtime/internal/sys"
@@ -899,9 +900,9 @@ type _func struct {
 	pcfile    uint32
 	pcln      uint32
 	npcdata   uint32
-	cuOffset  uint32 // runtime.cutab offset of this function's CU
-	startLine int32  // line number of start of function (func keyword/TEXT directive)
-	funcID    funcID // set for certain special runtime functions
+	cuOffset  uint32     // runtime.cutab offset of this function's CU
+	startLine int32      // line number of start of function (func keyword/TEXT directive)
+	funcID    abi.FuncID // set for certain special runtime functions
 	flag      funcFlag
 	_         [1]byte // pad
 	nfuncdata uint8   // must be last, must end on a uint32-aligned boundary
diff --git a/src/runtime/stack.go b/src/runtime/stack.go
index e1e6c7e82a..a1095382d3 100644
--- a/src/runtime/stack.go
+++ b/src/runtime/stack.go
@@ -663,7 +663,7 @@ func adjustframe(frame *stkframe, adjinfo *adjustinfo) {
 	if stackDebug >= 2 {
 		print("    adjusting ", funcname(f), " frame=[", hex(frame.sp), ",", hex(frame.fp), "] pc=", hex(frame.pc), " continpc=", hex(frame.continpc), "\n")
 	}
-	if f.funcID == funcID_systemstack_switch {
+	if f.funcID == abi.FuncID_systemstack_switch {
 		// A special routine at the bottom of stack of a goroutine that does a systemstack call.
 		// We will allow it to be copied even though we don't
 		// have full GC info for it (because it is written in asm).
@@ -1204,7 +1204,7 @@ func shrinkstack(gp *g) {
 		return
 	}
 	f := findfunc(gp.startpc)
-	if f.valid() && f.funcID == funcID_gcBgMarkWorker {
+	if f.valid() && f.funcID == abi.FuncID_gcBgMarkWorker {
 		// We're not allowed to shrink the gcBgMarkWorker
 		// stack (see gcBgMarkWorker for explanation).
 		return
diff --git a/src/runtime/symtab.go b/src/runtime/symtab.go
index 7bf96c31fc..4d3e2692e9 100644
--- a/src/runtime/symtab.go
+++ b/src/runtime/symtab.go
@@ -5,6 +5,7 @@
 package runtime
 
 import (
+	"internal/abi"
 	"internal/goarch"
 	"runtime/internal/atomic"
 	"runtime/internal/sys"
@@ -199,14 +200,14 @@ func runtime_expandFinalInlineFrame(stk []uintptr) []uintptr {
 	// Treat the previous func as normal. We haven't actually checked, but
 	// since this pc was included in the stack, we know it shouldn't be
 	// elided.
-	calleeID := funcID_normal
+	calleeID := abi.FuncIDNormal
 
 	// Remove pc from stk; we'll re-add it below.
 	stk = stk[:len(stk)-1]
 
 	for ; uf.valid(); uf = u.next(uf) {
 		funcID := u.srcFunc(uf).funcID
-		if funcID == funcID_wrapper && elideWrapperCalling(calleeID) {
+		if funcID == abi.FuncIDWrapper && elideWrapperCalling(calleeID) {
 			// ignore wrappers
 		} else {
 			stk = append(stk, uf.pc+1)
@@ -334,38 +335,6 @@ const (
 	_PCDATA_RestartAtEntry = -5
 )
 
-// A FuncID identifies particular functions that need to be treated
-// specially by the runtime.
-// Note that in some situations involving plugins, there may be multiple
-// copies of a particular special runtime function.
-// Note: this list must match the list in cmd/internal/objabi/funcid.go.
-type funcID uint8
-
-const (
-	funcID_normal funcID = iota // not a special function
-	funcID_abort
-	funcID_asmcgocall
-	funcID_asyncPreempt
-	funcID_cgocallback
-	funcID_debugCallV2
-	funcID_gcBgMarkWorker
-	funcID_goexit
-	funcID_gogo
-	funcID_gopanic
-	funcID_handleAsyncEvent
-	funcID_mcall
-	funcID_morestack
-	funcID_mstart
-	funcID_panicwrap
-	funcID_rt0_go
-	funcID_runfinq
-	funcID_runtime_main
-	funcID_sigpanic
-	funcID_systemstack
-	funcID_systemstack_switch
-	funcID_wrapper // any autogenerated code (hash/eq algorithms, method wrappers, etc.)
-)
-
 // A FuncFlag holds bits about a function.
 // This list must match the list in cmd/internal/objabi/funcid.go.
 type funcFlag uint8
@@ -886,7 +855,7 @@ type srcFunc struct {
 	datap     *moduledata
 	nameOff   int32
 	startLine int32
-	funcID    funcID
+	funcID    abi.FuncID
 }
 
 func (f funcInfo) srcFunc() srcFunc {
diff --git a/src/runtime/symtabinl.go b/src/runtime/symtabinl.go
index 2d4eb94de7..e9cd535a17 100644
--- a/src/runtime/symtabinl.go
+++ b/src/runtime/symtabinl.go
@@ -4,9 +4,11 @@
 
 package runtime
 
+import "internal/abi"
+
 // inlinedCall is the encoding of entries in the FUNCDATA_InlTree table.
 type inlinedCall struct {
-	funcID    funcID // type of the called function
+	funcID    abi.FuncID // type of the called function
 	_         [3]byte
 	nameOff   int32 // offset into pclntab for name of called function
 	parentPc  int32 // position of an instruction whose source position is the call site (offset from entry)
diff --git a/src/runtime/symtabinl_test.go b/src/runtime/symtabinl_test.go
index 7f736c1265..9e75f79281 100644
--- a/src/runtime/symtabinl_test.go
+++ b/src/runtime/symtabinl_test.go
@@ -70,7 +70,7 @@ func XTestInlineUnwinder(t TestingT) {
 			if start != wantStart[name] {
 				t.Errorf("tiuTest+%#x: want startLine %d, got %d", pc-pc1, wantStart[name], start)
 			}
-			if sf.funcID != funcID_normal {
+			if sf.funcID != abi.FuncIDNormal {
 				t.Errorf("tiuTest+%#x: bad funcID %v", pc-pc1, sf.funcID)
 			}
 
diff --git a/src/runtime/trace.go b/src/runtime/trace.go
index d174ee2e4a..2528c18274 100644
--- a/src/runtime/trace.go
+++ b/src/runtime/trace.go
@@ -13,6 +13,7 @@
 package runtime
 
 import (
+	"internal/abi"
 	"internal/goarch"
 	"runtime/internal/atomic"
 	"runtime/internal/sys"
@@ -1286,7 +1287,7 @@ func fpunwindExpand(pcBuf []uintptr) []uintptr {
 
 	var (
 		cache      pcvalueCache
-		lastFuncID = funcID_normal
+		lastFuncID = abi.FuncIDNormal
 		newPCBuf   = make([]uintptr, 0, traceStackSize)
 		skip       = pcBuf[0]
 		// skipOrAdd skips or appends retPC to newPCBuf and returns true if more
@@ -1317,7 +1318,7 @@ outer:
 		u, uf := newInlineUnwinder(fi, callPC, &cache)
 		for ; uf.valid(); uf = u.next(uf) {
 			sf := u.srcFunc(uf)
-			if sf.funcID == funcID_wrapper && elideWrapperCalling(lastFuncID) {
+			if sf.funcID == abi.FuncIDWrapper && elideWrapperCalling(lastFuncID) {
 				// ignore wrappers
 			} else if more := skipOrAdd(uf.pc + 1); !more {
 				break outer
diff --git a/src/runtime/traceback.go b/src/runtime/traceback.go
index 7e7c033d15..2717b763a4 100644
--- a/src/runtime/traceback.go
+++ b/src/runtime/traceback.go
@@ -5,6 +5,7 @@
 package runtime
 
 import (
+	"internal/abi"
 	"internal/bytealg"
 	"internal/goarch"
 	"runtime/internal/sys"
@@ -106,7 +107,7 @@ type unwinder struct {
 
 	// calleeFuncID is the function ID of the caller of the current
 	// frame.
-	calleeFuncID funcID
+	calleeFuncID abi.FuncID
 
 	// flags are the flags to this unwind. Some of these are updated as we
 	// unwind (see the flags documentation).
@@ -217,7 +218,7 @@ func (u *unwinder) initAt(pc0, sp0, lr0 uintptr, gp *g, flags unwindFlags) {
 		frame:        frame,
 		g:            gp.guintptr(),
 		cgoCtxt:      len(gp.cgoCtxt) - 1,
-		calleeFuncID: funcID_normal,
+		calleeFuncID: abi.FuncIDNormal,
 		flags:        flags,
 	}
 
@@ -264,7 +265,7 @@ func (u *unwinder) resolveInternal(innermost, isSyscall bool) {
 
 	// Compute function info flags.
 	flag := f.flag
-	if f.funcID == funcID_cgocallback {
+	if f.funcID == abi.FuncID_cgocallback {
 		// cgocallback does write SP to switch from the g0 to the curg stack,
 		// but it carefully arranges that during the transition BOTH stacks
 		// have cgocallback frame valid for unwinding through.
@@ -288,7 +289,7 @@ func (u *unwinder) resolveInternal(innermost, isSyscall bool) {
 		// This ensures gp.m doesn't change from a stack jump.
 		if u.flags&unwindJumpStack != 0 && gp == gp.m.g0 && gp.m.curg != nil && gp.m.curg.m == gp.m {
 			switch f.funcID {
-			case funcID_morestack:
+			case abi.FuncID_morestack:
 				// morestack does not return normally -- newstack()
 				// gogo's to curg.sched. Match that.
 				// This keeps morestack() from showing up in the backtrace,
@@ -303,7 +304,7 @@ func (u *unwinder) resolveInternal(innermost, isSyscall bool) {
 				frame.lr = gp.sched.lr
 				frame.sp = gp.sched.sp
 				u.cgoCtxt = len(gp.cgoCtxt) - 1
-			case funcID_systemstack:
+			case abi.FuncID_systemstack:
 				// systemstack returns normally, so just follow the
 				// stack transition.
 				if usesLR && funcspdelta(f, frame.pc, &u.cache) == 0 {
@@ -413,7 +414,7 @@ func (u *unwinder) resolveInternal(innermost, isSyscall bool) {
 	// deferproc a second time (if the corresponding deferred func recovers).
 	// In the latter case, use a deferreturn call site as the continuation pc.
 	frame.continpc = frame.pc
-	if u.calleeFuncID == funcID_sigpanic {
+	if u.calleeFuncID == abi.FuncID_sigpanic {
 		if frame.fn.deferreturn != 0 {
 			frame.continpc = frame.fn.entry() + uintptr(frame.fn.deferreturn) + 1
 			// Note: this may perhaps keep return variables alive longer than
@@ -449,7 +450,7 @@ func (u *unwinder) next() {
 		// get everything, so crash loudly.
 		fail := u.flags&(unwindPrintErrors|unwindSilentErrors) == 0
 		doPrint := u.flags&unwindSilentErrors == 0
-		if doPrint && gp.m.incgo && f.funcID == funcID_sigpanic {
+		if doPrint && gp.m.incgo && f.funcID == abi.FuncID_sigpanic {
 			// We can inject sigpanic
 			// calls directly into C code,
 			// in which case we'll see a C
@@ -475,7 +476,7 @@ func (u *unwinder) next() {
 		throw("traceback stuck")
 	}
 
-	injectedCall := f.funcID == funcID_sigpanic || f.funcID == funcID_asyncPreempt || f.funcID == funcID_debugCallV2
+	injectedCall := f.funcID == abi.FuncID_sigpanic || f.funcID == abi.FuncID_asyncPreempt || f.funcID == abi.FuncID_debugCallV2
 	if injectedCall {
 		u.flags |= unwindTrap
 	} else {
@@ -585,7 +586,7 @@ func (u *unwinder) symPC() uintptr {
 // If the current frame is not a cgo frame or if there's no registered cgo
 // unwinder, it returns 0.
 func (u *unwinder) cgoCallers(pcBuf []uintptr) int {
-	if cgoTraceback == nil || u.frame.fn.funcID != funcID_cgocallback || u.cgoCtxt < 0 {
+	if cgoTraceback == nil || u.frame.fn.funcID != abi.FuncID_cgocallback || u.cgoCtxt < 0 {
 		// We don't have a cgo unwinder (typical case), or we do but we're not
 		// in a cgo frame or we're out of cgo context.
 		return 0
@@ -621,7 +622,7 @@ func tracebackPCs(u *unwinder, skip int, pcBuf []uintptr) int {
 		// TODO: Why does &u.cache cause u to escape? (Same in traceback2)
 		for iu, uf := newInlineUnwinder(f, u.symPC(), noEscapePtr(&u.cache)); n < len(pcBuf) && uf.valid(); uf = iu.next(uf) {
 			sf := iu.srcFunc(uf)
-			if sf.funcID == funcID_wrapper && elideWrapperCalling(u.calleeFuncID) {
+			if sf.funcID == abi.FuncIDWrapper && elideWrapperCalling(u.calleeFuncID) {
 				// ignore wrappers
 			} else if skip > 0 {
 				skip--
@@ -748,7 +749,7 @@ func printcreatedby(gp *g) {
 	// Show what created goroutine, except main goroutine (goid 1).
 	pc := gp.gopc
 	f := findfunc(pc)
-	if f.valid() && showframe(f.srcFunc(), gp, false, funcID_normal) && gp.goid != 1 {
+	if f.valid() && showframe(f.srcFunc(), gp, false, abi.FuncIDNormal) && gp.goid != 1 {
 		printcreatedby1(f, pc, gp.parentGoid)
 	}
 }
@@ -1021,7 +1022,7 @@ func printAncestorTraceback(ancestor ancestorInfo) {
 	print("[originating from goroutine ", ancestor.goid, "]:\n")
 	for fidx, pc := range ancestor.pcs {
 		f := findfunc(pc) // f previously validated
-		if showfuncinfo(f.srcFunc(), fidx == 0, funcID_normal) {
+		if showfuncinfo(f.srcFunc(), fidx == 0, abi.FuncIDNormal) {
 			printAncestorTracebackFuncInfo(f, pc)
 		}
 	}
@@ -1030,7 +1031,7 @@ func printAncestorTraceback(ancestor ancestorInfo) {
 	}
 	// Show what created goroutine, except main goroutine (goid 1).
 	f := findfunc(ancestor.gopc)
-	if f.valid() && showfuncinfo(f.srcFunc(), false, funcID_normal) && ancestor.goid != 1 {
+	if f.valid() && showfuncinfo(f.srcFunc(), false, abi.FuncIDNormal) && ancestor.goid != 1 {
 		// In ancestor mode, we'll already print the goroutine ancestor.
 		// Pass 0 for the goid parameter so we don't print it again.
 		printcreatedby1(f, ancestor.gopc, 0)
@@ -1077,7 +1078,7 @@ func gcallers(gp *g, skip int, pcbuf []uintptr) int {
 
 // showframe reports whether the frame with the given characteristics should
 // be printed during a traceback.
-func showframe(sf srcFunc, gp *g, firstFrame bool, calleeID funcID) bool {
+func showframe(sf srcFunc, gp *g, firstFrame bool, calleeID abi.FuncID) bool {
 	mp := getg().m
 	if mp.throwing >= throwTypeRuntime && gp != nil && (gp == mp.curg || gp == mp.caughtsig.ptr()) {
 		return true
@@ -1087,14 +1088,14 @@ func showframe(sf srcFunc, gp *g, firstFrame bool, calleeID funcID) bool {
 
 // showfuncinfo reports whether a function with the given characteristics should
 // be printed during a traceback.
-func showfuncinfo(sf srcFunc, firstFrame bool, calleeID funcID) bool {
+func showfuncinfo(sf srcFunc, firstFrame bool, calleeID abi.FuncID) bool {
 	level, _, _ := gotraceback()
 	if level > 1 {
 		// Show all frames.
 		return true
 	}
 
-	if sf.funcID == funcID_wrapper && elideWrapperCalling(calleeID) {
+	if sf.funcID == abi.FuncIDWrapper && elideWrapperCalling(calleeID) {
 		return false
 	}
 
@@ -1121,10 +1122,10 @@ func isExportedRuntime(name string) bool {
 
 // elideWrapperCalling reports whether a wrapper function that called
 // function id should be elided from stack traces.
-func elideWrapperCalling(id funcID) bool {
+func elideWrapperCalling(id abi.FuncID) bool {
 	// If the wrapper called a panic function instead of the
 	// wrapped function, we want to include it in stacks.
-	return !(id == funcID_gopanic || id == funcID_sigpanic || id == funcID_panicwrap)
+	return !(id == abi.FuncID_gopanic || id == abi.FuncID_sigpanic || id == abi.FuncID_panicwrap)
 }
 
 var gStatusStrings = [...]string{
@@ -1273,10 +1274,10 @@ func isSystemGoroutine(gp *g, fixed bool) bool {
 	if !f.valid() {
 		return false
 	}
-	if f.funcID == funcID_runtime_main || f.funcID == funcID_handleAsyncEvent {
+	if f.funcID == abi.FuncID_runtime_main || f.funcID == abi.FuncID_handleAsyncEvent {
 		return false
 	}
-	if f.funcID == funcID_runfinq {
+	if f.funcID == abi.FuncID_runfinq {
 		// We include the finalizer goroutine if it's calling
 		// back into user code.
 		if fixed {
