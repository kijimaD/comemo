commit 08d6c4c2b96eb3e5012af9b346dc5b325e956844
Author: Michael Anthony Knyszek <mknyszek@google.com>
Date:   Fri May 13 15:30:03 2022 +0000

    runtime: account for idle mark time in the GC CPU limiter
    
    Currently the GC CPU limiter doesn't account for idle application time
    at all. This means that the GC could start thrashing, for example if the
    live heap exceeds the max heap set by the memory limit, but the limiter
    will fail to kick in when there's a lot of available idle time. User
    goroutines will still be assisting at a really high rate because of
    assist pacing rules, but the GC CPU limiter will fail to kick in because
    the actual fraction of GC CPU time will be low if there's a lot of
    otherwise idle time (for example, on an overprovisioned system).
    
    Luckily, that idle time is usually eaten up entirely by idle mark
    workers, at least during the GC cycle. And in these cases where we're
    GCing continuously, that's all of our idle time. So we can take idle
    mark work time and subtract it from the mutator time accumulated in the
    GC CPU limiter, and that will give us a more accurate picture of how
    much CPU is being spent by user goroutines on GC. This will allow the GC
    CPU limiter to kick in, and reduce the impact of the thrashing.
    
    There is a corner case here if the idle mark workers are disabled, for
    example for the periodic GC, but in the case of the periodic GC, I don't
    think it's possible for us to be thrashing at all, so it doesn't really
    matter.
    
    Fixes #52890.
    
    Change-Id: Ie133a7d1f89b603434b415d51eb8733c2708a858
    Reviewed-on: https://go-review.googlesource.com/c/go/+/405898
    Reviewed-by: David Chase <drchase@google.com>
    Run-TryBot: Michael Knyszek <mknyszek@google.com>
    TryBot-Result: Gopher Robot <gobot@golang.org>

 src/runtime/mgc.go      |  7 ++++++-
 src/runtime/mgclimit.go | 38 +++++++++++++++++++++++++++++++++++++-
 2 files changed, 43 insertions(+), 2 deletions(-)
