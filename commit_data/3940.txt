commit baba292998286e5d9011705a9b4173a2ec99c5e0
Author: Robert Griesemer <gri@golang.org>
Date:   Mon Nov 9 21:13:17 2009 -0800

            - replaced gofmt expression formatting algorithm with
              rsc's algorithm
            - applied gofmt -w misc src
            - partial CL (remaining files in other CLs)
    
    R=rsc, r
    http://go/go-review/1026036
---
 src/pkg/compress/flate/deflate.go               |  60 ++---
 src/pkg/compress/flate/deflate_test.go          |   2 +-
 src/pkg/compress/flate/huffman_bit_writer.go    |  54 ++--
 src/pkg/compress/flate/huffman_code.go          |  10 +-
 src/pkg/compress/flate/inflate.go               |  44 ++--
 src/pkg/compress/flate/reverse_bits.go          |   2 +-
 src/pkg/compress/flate/token.go                 |  12 +-
 src/pkg/compress/gzip/gunzip.go                 |  18 +-
 src/pkg/compress/zlib/reader.go                 |   4 +-
 src/pkg/compress/zlib/writer.go                 |   8 +-
 src/pkg/container/heap/heap.go                  |   6 +-
 src/pkg/container/ring/ring.go                  |   2 +-
 src/pkg/container/ring/ring_test.go             |   6 +-
 src/pkg/container/vector/vector.go              |  20 +-
 src/pkg/container/vector/vector_test.go         |   8 +-
 src/pkg/crypto/aes/aes_test.go                  |   4 +-
 src/pkg/crypto/aes/block.go                     |  28 +--
 src/pkg/crypto/aes/cipher.go                    |   2 +-
 src/pkg/crypto/block/cfb.go                     |  10 +-
 src/pkg/crypto/block/cipher.go                  |   4 +-
 src/pkg/crypto/block/cmac.go                    |   4 +-
 src/pkg/crypto/block/ctr.go                     |   2 +-
 src/pkg/crypto/block/eax.go                     |   2 +-
 src/pkg/crypto/block/ecb.go                     |  14 +-
 src/pkg/crypto/block/ecb_test.go                |   6 +-
 src/pkg/crypto/block/xor.go                     |   2 +-
 src/pkg/crypto/block/xor_test.go                |   6 +-
 src/pkg/crypto/hmac/hmac.go                     |   4 +-
 src/pkg/crypto/md5/md5.go                       |  16 +-
 src/pkg/crypto/md5/md5block.go                  |  30 +--
 src/pkg/crypto/rc4/rc4.go                       |   2 +-
 src/pkg/crypto/rsa/pkcs1v15.go                  |  10 +-
 src/pkg/crypto/rsa/pkcs1v15_test.go             |   2 +-
 src/pkg/crypto/rsa/rsa.go                       |  36 +--
 src/pkg/crypto/sha1/sha1.go                     |  16 +-
 src/pkg/crypto/sha1/sha1block.go                |  16 +-
 src/pkg/crypto/subtle/constant_time.go          |  32 +--
 src/pkg/crypto/tls/common.go                    |   2 +-
 src/pkg/crypto/tls/handshake_messages.go        |  60 ++---
 src/pkg/crypto/tls/handshake_messages_test.go   |   4 +-
 src/pkg/crypto/tls/prf.go                       |   8 +-
 src/pkg/crypto/tls/record_process.go            |  14 +-
 src/pkg/crypto/tls/record_write.go              |  20 +-
 src/pkg/debug/dwarf/buf.go                      |   6 +-
 src/pkg/debug/dwarf/entry.go                    |  16 +-
 src/pkg/debug/dwarf/type.go                     |   4 +-
 src/pkg/debug/dwarf/unit.go                     |   2 +-
 src/pkg/debug/elf/elf.go                        |  18 +-
 src/pkg/debug/elf/elf_test.go                   |   4 +-
 src/pkg/debug/elf/file.go                       |  24 +-
 src/pkg/debug/gosym/pclntab.go                  |   6 +-
 src/pkg/debug/gosym/pclntab_test.go             |   8 +-
 src/pkg/debug/gosym/symtab.go                   |  16 +-
 src/pkg/debug/macho/file.go                     |  14 +-
 src/pkg/debug/macho/macho.go                    |   6 +-
 src/pkg/debug/proc/proc_linux.go                |   2 +-
 src/pkg/ebnf/ebnf.go                            |  10 +-
 src/pkg/ebnf/parser.go                          |   6 +-
 src/pkg/encoding/ascii85/ascii85.go             |  34 +--
 src/pkg/encoding/ascii85/ascii85_test.go        |   2 +-
 src/pkg/encoding/base64/base64.go               |  44 ++--
 src/pkg/encoding/base64/base64_test.go          |   2 +-
 src/pkg/encoding/binary/binary.go               |  44 ++--
 src/pkg/encoding/git85/git.go                   |  36 +--
 src/pkg/encoding/git85/git_test.go              |   2 +-
 src/pkg/encoding/hex/hex.go                     |  22 +-
 src/pkg/encoding/pem/pem.go                     |   4 +-
 src/pkg/exec/exec.go                            |   6 +-
 src/pkg/exp/4s/4s.go                            |   4 +-
 src/pkg/exp/4s/xs.go                            |  74 +++---
 src/pkg/exp/datafmt/datafmt.go                  |   8 +-
 src/pkg/exp/datafmt/datafmt_test.go             |   2 +-
 src/pkg/exp/datafmt/parser.go                   |  18 +-
 src/pkg/exp/draw/color.go                       |  22 +-
 src/pkg/exp/draw/draw.go                        |  26 +-
 src/pkg/exp/eval/bridge.go                      |   8 +-
 src/pkg/exp/eval/eval_test.go                   |   2 +-
 src/pkg/exp/eval/expr.go                        |  10 +-
 src/pkg/exp/eval/expr1.go                       | 246 +++++++++---------
 src/pkg/exp/eval/expr_test.go                   |   6 +-
 src/pkg/exp/eval/scope.go                       |   2 +-
 src/pkg/exp/eval/stmt.go                        |   2 +-
 src/pkg/exp/eval/type.go                        |   8 +-
 src/pkg/exp/eval/value.go                       |   8 +-
 src/pkg/exp/iterable/iterable_test.go           |   2 +-
 src/pkg/exp/nacl/av/av.go                       |  20 +-
 src/pkg/exp/nacl/av/event.go                    |   6 +-
 src/pkg/exp/nacl/av/image.go                    |  24 +-
 src/pkg/exp/nacl/srpc/client.go                 |   8 +-
 src/pkg/exp/nacl/srpc/msg.go                    |  30 +--
 src/pkg/exp/ogle/arch.go                        |   4 +-
 src/pkg/exp/ogle/cmd.go                         |   2 +-
 src/pkg/exp/ogle/event.go                       |   2 +-
 src/pkg/exp/ogle/frame.go                       |   6 +-
 src/pkg/exp/ogle/process.go                     |   2 +-
 src/pkg/exp/ogle/rruntime.go                    |   2 +-
 src/pkg/exp/ogle/rtype.go                       |   4 +-
 src/pkg/exp/ogle/rvalue.go                      |   8 +-
 src/pkg/exp/ogle/vars.go                        |   2 +-
 src/pkg/exp/spacewar/pdp1.go                    |  72 +++---
 src/pkg/exp/spacewar/spacewar.go                |  12 +-
 src/pkg/flag/flag.go                            |   8 +-
 src/pkg/fmt/fmt_test.go                         |   4 +-
 src/pkg/fmt/format.go                           |  14 +-
 src/pkg/fmt/print.go                            |  20 +-
 src/pkg/go/ast/ast.go                           |   2 +-
 src/pkg/go/ast/filter.go                        |   4 +-
 src/pkg/go/doc/comment.go                       |  14 +-
 src/pkg/go/doc/doc.go                           |   2 +-
 src/pkg/go/parser/interface.go                  |   2 +-
 src/pkg/go/parser/parser.go                     |  20 +-
 src/pkg/go/printer/nodes.go                     | 315 +++++++++++++++---------
 src/pkg/go/printer/printer.go                   |  28 +--
 src/pkg/go/printer/printer_test.go              |   6 +-
 src/pkg/go/printer/testdata/declarations.golden |   2 +-
 src/pkg/go/printer/testdata/expressions.golden  | 118 +++++++--
 src/pkg/go/printer/testdata/expressions.input   |  72 ++++++
 src/pkg/go/printer/testdata/expressions.raw     | 118 +++++++--
 src/pkg/go/printer/testdata/linebreaks.golden   |   2 +-
 src/pkg/go/scanner/scanner.go                   |  24 +-
 src/pkg/go/scanner/scanner_test.go              |   2 +-
 src/pkg/gob/codec_test.go                       |  14 +-
 src/pkg/gob/decode.go                           |   8 +-
 src/pkg/gob/encode.go                           |  16 +-
 124 files changed, 1357 insertions(+), 1060 deletions(-)

diff --git a/src/pkg/compress/flate/deflate.go b/src/pkg/compress/flate/deflate.go
index 4b6726e304..d861c4872e 100644
--- a/src/pkg/compress/flate/deflate.go
+++ b/src/pkg/compress/flate/deflate.go
@@ -25,11 +25,11 @@ const (
 
 	// The maximum number of tokens we put into a single flat block, just too
 	// stop things from getting too large.
-	maxFlateBlockTokens	= 1<<14;
+	maxFlateBlockTokens	= 1 << 14;
 	maxStoreBlockSize	= 65535;
 	hashBits		= 15;
-	hashSize		= 1<<hashBits;
-	hashMask		= (1<<hashBits)-1;
+	hashSize		= 1 << hashBits;
+	hashMask		= (1 << hashBits) - 1;
 	hashShift		= (hashBits + minMatchLength - 1) / minMatchLength;
 )
 
@@ -126,9 +126,9 @@ func (d *deflater) flush() os.Error {
 
 func (d *deflater) fillWindow(index int) (int, os.Error) {
 	wSize := d.windowMask + 1;
-	if index >= wSize+wSize-(minMatchLength + maxMatchLength) {
+	if index >= wSize+wSize-(minMatchLength+maxMatchLength) {
 		// shift the window by wSize
-		bytes.Copy(d.window, d.window[wSize : 2*wSize]);
+		bytes.Copy(d.window, d.window[wSize:2*wSize]);
 		index -= wSize;
 		d.windowEnd -= wSize;
 		if d.blockStart >= wSize {
@@ -145,7 +145,7 @@ func (d *deflater) fillWindow(index int) (int, os.Error) {
 	}
 	var count int;
 	var err os.Error;
-	count, err = io.ReadAtLeast(d.r, d.window[d.windowEnd : len(d.window)], 1);
+	count, err = io.ReadAtLeast(d.r, d.window[d.windowEnd:len(d.window)], 1);
 	d.windowEnd += count;
 	if err == os.EOF {
 		return index, nil
@@ -157,7 +157,7 @@ func (d *deflater) writeBlock(tokens []token, index int, eof bool) os.Error {
 	if index > 0 || eof {
 		var window []byte;
 		if d.blockStart <= index {
-			window = d.window[d.blockStart : index]
+			window = d.window[d.blockStart:index]
 		}
 		d.blockStart = index;
 		d.w.writeBlock(tokens, eof, window);
@@ -169,7 +169,7 @@ func (d *deflater) writeBlock(tokens []token, index int, eof bool) os.Error {
 // Try to find a match starting at index whose length is greater than prevSize.
 // We only look at chainCount possibilities before giving up.
 func (d *deflater) findMatch(pos int, prevHead int, prevLength int, lookahead int) (length, offset int, ok bool) {
-	win := d.window[0 : pos + min(maxMatchLength, lookahead)];
+	win := d.window[0 : pos+min(maxMatchLength, lookahead)];
 
 	// We quit when we get a match that's at least nice long
 	nice := min(d.niceMatch, len(win)-pos);
@@ -184,7 +184,7 @@ func (d *deflater) findMatch(pos int, prevHead int, prevLength int, lookahead in
 	w0 := win[pos];
 	w1 := win[pos+1];
 	wEnd := win[pos+length];
-	minIndex := pos-(d.windowMask + 1);
+	minIndex := pos - (d.windowMask + 1);
 
 	for i := prevHead; tries > 0; tries-- {
 		if w0 == win[i] && w1 == win[i+1] && wEnd == win[i+length] {
@@ -196,7 +196,7 @@ func (d *deflater) findMatch(pos int, prevHead int, prevLength int, lookahead in
 			}
 			if n > length && (n > 3 || pos-i <= 4096) {
 				length = n;
-				offset = pos-i;
+				offset = pos - i;
 				ok = true;
 				if n >= nice {
 					// The match is good enough that we don't try to find a better one.
@@ -209,7 +209,7 @@ func (d *deflater) findMatch(pos int, prevHead int, prevLength int, lookahead in
 			// hashPrev[i & windowMask] has already been overwritten, so stop now.
 			break
 		}
-		if i = d.hashPrev[i & d.windowMask]; i < minIndex || i < 0 {
+		if i = d.hashPrev[i&d.windowMask]; i < minIndex || i < 0 {
 			break
 		}
 	}
@@ -245,12 +245,12 @@ func (d *deflater) storedDeflate() os.Error {
 
 func (d *deflater) doDeflate() (err os.Error) {
 	// init
-	d.windowMask = 1 << d.logWindowSize - 1;
+	d.windowMask = 1<<d.logWindowSize - 1;
 	d.hashHead = make([]int, hashSize);
-	d.hashPrev = make([]int, 1 << d.logWindowSize);
-	d.window = make([]byte, 2 << d.logWindowSize);
+	d.hashPrev = make([]int, 1<<d.logWindowSize);
+	d.window = make([]byte, 2<<d.logWindowSize);
 	fillInts(d.hashHead, -1);
-	tokens := make([]token, maxFlateBlockTokens, maxFlateBlockTokens + 1);
+	tokens := make([]token, maxFlateBlockTokens, maxFlateBlockTokens+1);
 	l := levels[d.level];
 	d.goodMatch = l.good;
 	d.niceMatch = l.nice;
@@ -273,7 +273,7 @@ func (d *deflater) doDeflate() (err os.Error) {
 
 	hash := int(0);
 	if index < maxInsertIndex {
-		hash = int(d.window[index]) << hashShift + int(d.window[index+1])
+		hash = int(d.window[index])<<hashShift + int(d.window[index+1])
 	}
 	chainHead := -1;
 	for {
@@ -281,7 +281,7 @@ func (d *deflater) doDeflate() (err os.Error) {
 			panic("index > windowEnd")
 		}
 		lookahead := windowEnd - index;
-		if lookahead < minMatchLength + maxMatchLength {
+		if lookahead < minMatchLength+maxMatchLength {
 			if index, err = d.fillWindow(index); err != nil {
 				return
 			}
@@ -297,21 +297,21 @@ func (d *deflater) doDeflate() (err os.Error) {
 		}
 		if index < maxInsertIndex {
 			// Update the hash
-			hash = (hash << hashShift + int(d.window[index+2]))&hashMask;
+			hash = (hash<<hashShift + int(d.window[index+2])) & hashMask;
 			chainHead = d.hashHead[hash];
-			d.hashPrev[index & d.windowMask] = chainHead;
+			d.hashPrev[index&d.windowMask] = chainHead;
 			d.hashHead[hash] = index;
 		}
 		prevLength := length;
 		prevOffset := offset;
-		minIndex := max(index - maxOffset, 0);
+		minIndex := max(index-maxOffset, 0);
 		length = minMatchLength - 1;
 		offset = 0;
 
 		if chainHead >= minIndex &&
-			(isFastDeflate && lookahead > minMatchLength - 1 ||
+			(isFastDeflate && lookahead > minMatchLength-1 ||
 				!isFastDeflate && lookahead > prevLength && prevLength < lazyMatch) {
-			if newLength, newOffset, ok := d.findMatch(index, chainHead, minMatchLength - 1, lookahead); ok {
+			if newLength, newOffset, ok := d.findMatch(index, chainHead, minMatchLength-1, lookahead); ok {
 				length = newLength;
 				offset = newOffset;
 			}
@@ -321,9 +321,9 @@ func (d *deflater) doDeflate() (err os.Error) {
 			// There was a match at the previous step, and the current match is
 			// not better. Output the previous match.
 			if isFastDeflate {
-				tokens[ti] = matchToken(uint32(length - minMatchLength), uint32(offset - minOffsetSize))
+				tokens[ti] = matchToken(uint32(length-minMatchLength), uint32(offset-minOffsetSize))
 			} else {
-				tokens[ti] = matchToken(uint32(prevLength - minMatchLength), uint32(prevOffset - minOffsetSize))
+				tokens[ti] = matchToken(uint32(prevLength-minMatchLength), uint32(prevOffset-minOffsetSize))
 			}
 			ti++;
 			// Insert in the hash table all strings up to the end of the match.
@@ -333,16 +333,16 @@ func (d *deflater) doDeflate() (err os.Error) {
 			if length <= l.fastSkipHashing {
 				var newIndex int;
 				if isFastDeflate {
-					newIndex = index+length
+					newIndex = index + length
 				} else {
 					newIndex = prevLength - 1
 				}
 				for index++; index < newIndex; index++ {
 					if index < maxInsertIndex {
-						hash = (hash << hashShift + int(d.window[index+2]))&hashMask;
+						hash = (hash<<hashShift + int(d.window[index+2])) & hashMask;
 						// Get previous value with the same hash.
 						// Our chain should point to the previous value.
-						d.hashPrev[index & d.windowMask] = d.hashHead[hash];
+						d.hashPrev[index&d.windowMask] = d.hashHead[hash];
 						// Set the head of the hash chain to us.
 						d.hashHead[hash] = index;
 					}
@@ -366,11 +366,11 @@ func (d *deflater) doDeflate() (err os.Error) {
 			}
 		} else {
 			if isFastDeflate || byteAvailable {
-				i := index-1;
+				i := index - 1;
 				if isFastDeflate {
 					i = index
 				}
-				tokens[ti] = literalToken(uint32(d.window[i])&0xFF);
+				tokens[ti] = literalToken(uint32(d.window[i]) & 0xFF);
 				ti++;
 				if ti == maxFlateBlockTokens {
 					if err = d.writeBlock(tokens, i+1, false); err != nil {
@@ -388,7 +388,7 @@ func (d *deflater) doDeflate() (err os.Error) {
 	}
 	if byteAvailable {
 		// There is still one pending token that needs to be flushed
-		tokens[ti] = literalToken(uint32(d.window[index-1])&0xFF);
+		tokens[ti] = literalToken(uint32(d.window[index-1]) & 0xFF);
 		ti++;
 	}
 
diff --git a/src/pkg/compress/flate/deflate_test.go b/src/pkg/compress/flate/deflate_test.go
index 85cc12d383..01e97f34dc 100644
--- a/src/pkg/compress/flate/deflate_test.go
+++ b/src/pkg/compress/flate/deflate_test.go
@@ -72,7 +72,7 @@ var reverseBitsTests = []*reverseBitsTest{
 func getLargeDataChunk() []byte {
 	result := make([]byte, 100000);
 	for i := range result {
-		result[i] = byte(int64(i)*int64(i)&0xFF)
+		result[i] = byte(int64(i) * int64(i) & 0xFF)
 	}
 	return result;
 }
diff --git a/src/pkg/compress/flate/huffman_bit_writer.go b/src/pkg/compress/flate/huffman_bit_writer.go
index 44cb9811b9..a1ef3694cf 100644
--- a/src/pkg/compress/flate/huffman_bit_writer.go
+++ b/src/pkg/compress/flate/huffman_bit_writer.go
@@ -101,7 +101,7 @@ func newHuffmanBitWriter(w io.Writer) *huffmanBitWriter {
 		w: w,
 		literalFreq: make([]int32, maxLit),
 		offsetFreq: make([]int32, extendedOffsetCodeCount),
-		codegen: make([]uint8, maxLit + extendedOffsetCodeCount + 1),
+		codegen: make([]uint8, maxLit+extendedOffsetCodeCount+1),
 		codegenFreq: make([]int32, codegenCodeCount),
 		literalEncoding: newHuffmanEncoder(maxLit),
 		offsetEncoding: newHuffmanEncoder(extendedOffsetCodeCount),
@@ -124,7 +124,7 @@ func (w *huffmanBitWriter) flushBits() {
 	w.nbits -= 16;
 	n := w.nbytes;
 	w.bytes[n] = byte(bits);
-	w.bytes[n+1] = byte(bits>>8);
+	w.bytes[n+1] = byte(bits >> 8);
 	if n += 2; n >= len(w.bytes) {
 		_, w.err = w.w.Write(&w.bytes);
 		n = 0;
@@ -204,9 +204,9 @@ func (w *huffmanBitWriter) generateCodegen(numLiterals int, numOffsets int) {
 	// so far.
 	codegen := w.codegen;	// cache
 	// Copy the concatenated code sizes to codegen.  Put a marker at the end.
-	copyUint8s(codegen[0 : numLiterals], w.literalEncoding.codeBits);
-	copyUint8s(codegen[numLiterals : numLiterals + numOffsets], w.offsetEncoding.codeBits);
-	codegen[numLiterals + numOffsets] = badCode;
+	copyUint8s(codegen[0:numLiterals], w.literalEncoding.codeBits);
+	copyUint8s(codegen[numLiterals:numLiterals+numOffsets], w.offsetEncoding.codeBits);
+	codegen[numLiterals+numOffsets] = badCode;
 
 	size := codegen[0];
 	count := 1;
@@ -229,7 +229,7 @@ func (w *huffmanBitWriter) generateCodegen(numLiterals int, numOffsets int) {
 				n := min(count, 6);
 				codegen[outIndex] = 16;
 				outIndex++;
-				codegen[outIndex] = uint8(n-3);
+				codegen[outIndex] = uint8(n - 3);
 				outIndex++;
 				w.codegenFreq[16]++;
 				count -= n;
@@ -239,7 +239,7 @@ func (w *huffmanBitWriter) generateCodegen(numLiterals int, numOffsets int) {
 				n := min(count, 138);
 				codegen[outIndex] = 18;
 				outIndex++;
-				codegen[outIndex] = uint8(n-11);
+				codegen[outIndex] = uint8(n - 11);
 				outIndex++;
 				w.codegenFreq[18]++;
 				count -= n;
@@ -248,7 +248,7 @@ func (w *huffmanBitWriter) generateCodegen(numLiterals int, numOffsets int) {
 				// count >= 3 && count <= 10
 				codegen[outIndex] = 17;
 				outIndex++;
-				codegen[outIndex] = uint8(count-3);
+				codegen[outIndex] = uint8(count - 3);
 				outIndex++;
 				w.codegenFreq[17]++;
 				count = 0;
@@ -289,15 +289,15 @@ func (w *huffmanBitWriter) writeDynamicHeader(numLiterals int, numOffsets int, n
 		firstBits = 5
 	}
 	w.writeBits(firstBits, 3);
-	w.writeBits(int32(numLiterals - 257), 5);
+	w.writeBits(int32(numLiterals-257), 5);
 	if numOffsets > offsetCodeCount {
 		// Extended version of deflater
-		w.writeBits(int32(offsetCodeCount + ((numOffsets - (1 + offsetCodeCount))>>3)), 5);
-		w.writeBits(int32((numOffsets - (1 + offsetCodeCount))&0x7), 3);
+		w.writeBits(int32(offsetCodeCount+((numOffsets-(1+offsetCodeCount))>>3)), 5);
+		w.writeBits(int32((numOffsets-(1+offsetCodeCount))&0x7), 3);
 	} else {
-		w.writeBits(int32(numOffsets - 1), 5)
+		w.writeBits(int32(numOffsets-1), 5)
 	}
-	w.writeBits(int32(numCodegens - 4), 4);
+	w.writeBits(int32(numCodegens-4), 4);
 
 	for i := 0; i < numCodegens; i++ {
 		value := w.codegenEncoding.codeBits[codegenOrder[i]];
@@ -378,8 +378,8 @@ func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte) {
 		case matchType:
 			length := t.length();
 			offset := t.offset();
-			totalLength += int(length+3);
-			w.literalFreq[lengthCodesStart + lengthCode(length)]++;
+			totalLength += int(length + 3);
+			w.literalFreq[lengthCodesStart+lengthCode(length)]++;
 			w.offsetFreq[offsetCode(offset)]++;
 			break;
 		}
@@ -389,12 +389,12 @@ func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte) {
 
 	// get the number of literals
 	numLiterals := len(w.literalFreq);
-	for w.literalFreq[numLiterals - 1] == 0 {
+	for w.literalFreq[numLiterals-1] == 0 {
 		numLiterals--
 	}
 	// get the number of offsets
 	numOffsets := len(w.offsetFreq);
-	for numOffsets > 1 && w.offsetFreq[numOffsets - 1] == 0 {
+	for numOffsets > 1 && w.offsetFreq[numOffsets-1] == 0 {
 		numOffsets--
 	}
 	storedBytes := 0;
@@ -404,18 +404,18 @@ func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte) {
 	var extraBits int64;
 	var storedSize int64;
 	if storedBytes <= maxStoreBlockSize && input != nil {
-		storedSize = int64((storedBytes + 5)*8);
+		storedSize = int64((storedBytes + 5) * 8);
 		// We only bother calculating the costs of the extra bits required by
 		// the length of offset fields (which will be the same for both fixed
 		// and dynamic encoding), if we need to compare those two encodings
 		// against stored encoding.
 		for lengthCode := lengthCodesStart + 8; lengthCode < numLiterals; lengthCode++ {
 			// First eight length codes have extra size = 0.
-			extraBits += int64(w.literalFreq[lengthCode])*int64(lengthExtraBits[lengthCode - lengthCodesStart])
+			extraBits += int64(w.literalFreq[lengthCode]) * int64(lengthExtraBits[lengthCode-lengthCodesStart])
 		}
 		for offsetCode := 4; offsetCode < numOffsets; offsetCode++ {
 			// First four offset codes have extra size = 0.
-			extraBits += int64(w.offsetFreq[offsetCode])*int64(offsetExtraBits[offsetCode])
+			extraBits += int64(w.offsetFreq[offsetCode]) * int64(offsetExtraBits[offsetCode])
 		}
 	} else {
 		storedSize = math.MaxInt32
@@ -435,28 +435,28 @@ func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte) {
 	w.generateCodegen(numLiterals, numOffsets);
 	w.codegenEncoding.generate(w.codegenFreq, 7);
 	numCodegens := len(w.codegenFreq);
-	for numCodegens > 4 && w.codegenFreq[codegenOrder[numCodegens - 1]] == 0 {
+	for numCodegens > 4 && w.codegenFreq[codegenOrder[numCodegens-1]] == 0 {
 		numCodegens--
 	}
 	extensionSummand := 0;
 	if numOffsets > offsetCodeCount {
 		extensionSummand = 3
 	}
-	dynamicHeader := int64(3+5+5+4+(3 * numCodegens)) +
+	dynamicHeader := int64(3+5+5+4+(3*numCodegens)) +
 		// Following line is an extension.
 		int64(extensionSummand) +
 		w.codegenEncoding.bitLength(w.codegenFreq) +
 		int64(extraBits) +
-		int64(w.codegenFreq[16] * 2) +
-		int64(w.codegenFreq[17] * 3) +
-		int64(w.codegenFreq[18] * 7);
+		int64(w.codegenFreq[16]*2) +
+		int64(w.codegenFreq[17]*3) +
+		int64(w.codegenFreq[18]*7);
 	dynamicSize := dynamicHeader +
 		w.literalEncoding.bitLength(w.literalFreq) +
 		w.offsetEncoding.bitLength(w.offsetFreq);
 
 	if storedSize < fixedSize && storedSize < dynamicSize {
 		w.writeStoredHeader(storedBytes, eof);
-		w.writeBytes(input[0 : storedBytes]);
+		w.writeBytes(input[0:storedBytes]);
 		return;
 	}
 	var literalEncoding *huffmanEncoder;
@@ -483,7 +483,7 @@ func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte) {
 			// Write the length
 			length := t.length();
 			lengthCode := lengthCode(length);
-			w.writeCode(literalEncoding, lengthCode + lengthCodesStart);
+			w.writeCode(literalEncoding, lengthCode+lengthCodesStart);
 			extraLengthBits := int32(lengthExtraBits[lengthCode]);
 			if extraLengthBits > 0 {
 				extraLength := int32(length - lengthBase[lengthCode]);
diff --git a/src/pkg/compress/flate/huffman_code.go b/src/pkg/compress/flate/huffman_code.go
index c3cd482dc9..484f7d6abb 100644
--- a/src/pkg/compress/flate/huffman_code.go
+++ b/src/pkg/compress/flate/huffman_code.go
@@ -73,22 +73,22 @@ func generateFixedLiteralEncoding() *huffmanEncoder {
 		switch {
 		case ch < 144:
 			// size 8, 000110000  .. 10111111
-			bits = ch+48;
+			bits = ch + 48;
 			size = 8;
 			break;
 		case ch < 256:
 			// size 9, 110010000 .. 111111111
-			bits = ch+400-144;
+			bits = ch + 400 - 144;
 			size = 9;
 			break;
 		case ch < 280:
 			// size 7, 0000000 .. 0010111
-			bits = ch-256;
+			bits = ch - 256;
 			size = 7;
 			break;
 		default:
 			// size 8, 11000000 .. 11000111
-			bits = ch+192-280;
+			bits = ch + 192 - 280;
 			size = 8;
 		}
 		codeBits[ch] = size;
@@ -115,7 +115,7 @@ func (h *huffmanEncoder) bitLength(freq []int32) int64 {
 	var total int64;
 	for i, f := range freq {
 		if f != 0 {
-			total += int64(f)*int64(h.codeBits[i])
+			total += int64(f) * int64(h.codeBits[i])
 		}
 	}
 	return total;
diff --git a/src/pkg/compress/flate/inflate.go b/src/pkg/compress/flate/inflate.go
index 5bdd5cfae5..213846688f 100644
--- a/src/pkg/compress/flate/inflate.go
+++ b/src/pkg/compress/flate/inflate.go
@@ -113,10 +113,10 @@ func (h *huffmanDecoder) init(bits []int) bool {
 	for i := min; i <= max; i++ {
 		n := count[i];
 		nextcode[i] = code;
-		h.base[i] = code-seq;
+		h.base[i] = code - seq;
 		code += n;
 		seq += n;
-		h.limit[i] = code-1;
+		h.limit[i] = code - 1;
 		code <<= 1;
 	}
 
@@ -212,7 +212,7 @@ type inflater struct {
 	h1, h2	huffmanDecoder;
 
 	// Length arrays used to define Huffman codes.
-	bits		[maxLit+maxDist]int;
+	bits		[maxLit + maxDist]int;
 	codebits	[numCodes]int;
 
 	// Output history, buffer.
@@ -232,11 +232,11 @@ func (f *inflater) inflate() (err os.Error) {
 				return
 			}
 		}
-		final = f.b & 1 == 1;
+		final = f.b&1 == 1;
 		f.b >>= 1;
 		typ := f.b & 3;
 		f.b >>= 2;
-		f.nb -= 1+2;
+		f.nb -= 1 + 2;
 		switch typ {
 		case 0:
 			err = f.dataBlock()
@@ -268,13 +268,13 @@ func (f *inflater) readHuffman() os.Error {
 			return err
 		}
 	}
-	nlit := int(f.b & 0x1F)+257;
+	nlit := int(f.b&0x1F) + 257;
 	f.b >>= 5;
-	ndist := int(f.b & 0x1F)+1;
+	ndist := int(f.b&0x1F) + 1;
 	f.b >>= 5;
-	nclen := int(f.b & 0xF)+4;
+	nclen := int(f.b&0xF) + 4;
 	f.b >>= 4;
-	f.nb -= 5+5+4;
+	f.nb -= 5 + 5 + 4;
 
 	// (HCLEN+4)*3 bits: code lengths in the magic codeOrder order.
 	for i := 0; i < nclen; i++ {
@@ -335,7 +335,7 @@ func (f *inflater) readHuffman() os.Error {
 				return err
 			}
 		}
-		rep += int(f.b & uint32(1<<nb - 1));
+		rep += int(f.b & uint32(1<<nb-1));
 		f.b >>= nb;
 		f.nb -= nb;
 		if i+rep > n {
@@ -347,7 +347,7 @@ func (f *inflater) readHuffman() os.Error {
 		}
 	}
 
-	if !f.h1.init(f.bits[0:nlit]) || !f.h2.init(f.bits[nlit : nlit+ndist]) {
+	if !f.h1.init(f.bits[0:nlit]) || !f.h2.init(f.bits[nlit:nlit+ndist]) {
 		return CorruptInputError(f.roffset)
 	}
 
@@ -380,7 +380,7 @@ func (f *inflater) decodeBlock(hl, hd *huffmanDecoder) os.Error {
 			return nil
 		// otherwise, reference to older data
 		case v < 265:
-			length = v-(257-3);
+			length = v - (257 - 3);
 			n = 0;
 		case v < 269:
 			length = v*2 - (265*2 - 11);
@@ -407,7 +407,7 @@ func (f *inflater) decodeBlock(hl, hd *huffmanDecoder) os.Error {
 					return err
 				}
 			}
-			length += int(f.b & uint32(1<<n - 1));
+			length += int(f.b & uint32(1<<n-1));
 			f.b >>= n;
 			f.nb -= n;
 		}
@@ -419,7 +419,7 @@ func (f *inflater) decodeBlock(hl, hd *huffmanDecoder) os.Error {
 					return err
 				}
 			}
-			dist = int(reverseByte[(f.b & 0x1F)<<3]);
+			dist = int(reverseByte[(f.b&0x1F)<<3]);
 			f.b >>= 5;
 			f.nb -= 5;
 		} else {
@@ -434,15 +434,15 @@ func (f *inflater) decodeBlock(hl, hd *huffmanDecoder) os.Error {
 		case dist >= 30:
 			return CorruptInputError(f.roffset)
 		default:
-			nb := uint(dist-2)>>1;
+			nb := uint(dist-2) >> 1;
 			// have 1 bit in bottom of dist, need nb more.
-			extra := (dist&1)<<nb;
+			extra := (dist & 1) << nb;
 			for f.nb < nb {
 				if err = f.moreBits(); err != nil {
 					return err
 				}
 			}
-			extra |= int(f.b & uint32(1<<nb - 1));
+			extra |= int(f.b & uint32(1<<nb-1));
 			f.b >>= nb;
 			f.nb -= nb;
 			dist = 1<<(nb+1) + 1 + extra;
@@ -505,7 +505,7 @@ func (f *inflater) dataBlock() os.Error {
 		if m > n {
 			m = n
 		}
-		m, err := io.ReadFull(f.r, f.hist[f.hp : f.hp + m]);
+		m, err := io.ReadFull(f.r, f.hist[f.hp:f.hp+m]);
 		f.roffset += int64(m);
 		if err != nil {
 			return &ReadError{f.roffset, err}
@@ -547,13 +547,13 @@ func (f *inflater) huffSym(h *huffmanDecoder) (int, os.Error) {
 				return 0, err
 			}
 		}
-		v := int(f.b & uint32(1<<n - 1));
-		v <<= 16-n;
+		v := int(f.b & uint32(1<<n-1));
+		v <<= 16 - n;
 		v = int(reverseByte[v>>8]) | int(reverseByte[v&0xFF])<<8;	// reverse bits
 		if v <= lim {
 			f.b >>= n;
 			f.nb -= n;
-			return h.codes[v - h.base[n]], nil;
+			return h.codes[v-h.base[n]], nil;
 		}
 	}
 	return 0, CorruptInputError(f.roffset);
@@ -564,7 +564,7 @@ func (f *inflater) flush() os.Error {
 	if f.hp == 0 {
 		return nil
 	}
-	n, err := f.w.Write(f.hist[0 : f.hp]);
+	n, err := f.w.Write(f.hist[0:f.hp]);
 	if n != f.hp && err == nil {
 		err = io.ErrShortWrite
 	}
diff --git a/src/pkg/compress/flate/reverse_bits.go b/src/pkg/compress/flate/reverse_bits.go
index 8376da32a6..c1a02720d1 100644
--- a/src/pkg/compress/flate/reverse_bits.go
+++ b/src/pkg/compress/flate/reverse_bits.go
@@ -44,5 +44,5 @@ func reverseUint16(v uint16) uint16 {
 }
 
 func reverseBits(number uint16, bitLength byte) uint16 {
-	return reverseUint16(number<<uint8(16 - bitLength))
+	return reverseUint16(number << uint8(16-bitLength))
 }
diff --git a/src/pkg/compress/flate/token.go b/src/pkg/compress/flate/token.go
index 5d4bcefaf5..139e1d0da0 100644
--- a/src/pkg/compress/flate/token.go
+++ b/src/pkg/compress/flate/token.go
@@ -9,10 +9,10 @@ const (
 	// 8 bits:   xlength = length - MIN_MATCH_LENGTH
 	// 22 bits   xoffset = offset - MIN_OFFSET_SIZE, or literal
 	lengthShift	= 22;
-	offsetMask	= 1 << lengthShift - 1;
-	typeMask	= 3<<30;
-	literalType	= 0<<30;
-	matchType	= 1<<30;
+	offsetMask	= 1<<lengthShift - 1;
+	typeMask	= 3 << 30;
+	literalType	= 0 << 30;
+	matchType	= 1 << 30;
 )
 
 // The length code for length X (MIN_MATCH_LENGTH <= X <= MAX_MATCH_LENGTH)
@@ -72,11 +72,11 @@ func literalToken(literal uint32) token	{ return token(literalType + literal) }
 
 // Convert a < xlength, xoffset > pair into a match token.
 func matchToken(xlength uint32, xoffset uint32) token {
-	return token(matchType + xlength << lengthShift + xoffset)
+	return token(matchType + xlength<<lengthShift + xoffset)
 }
 
 // Returns the type of a token
-func (t token) typ() uint32	{ return uint32(t)&typeMask }
+func (t token) typ() uint32	{ return uint32(t) & typeMask }
 
 // Returns the literal of a literal token
 func (t token) literal() uint32	{ return uint32(t - literalType) }
diff --git a/src/pkg/compress/gzip/gunzip.go b/src/pkg/compress/gzip/gunzip.go
index 8dc64fea36..ef84f16fc9 100644
--- a/src/pkg/compress/gzip/gunzip.go
+++ b/src/pkg/compress/gzip/gunzip.go
@@ -19,11 +19,11 @@ const (
 	gzipID1		= 0x1f;
 	gzipID2		= 0x8b;
 	gzipDeflate	= 8;
-	flagText	= 1<<0;
-	flagHdrCrc	= 1<<1;
-	flagExtra	= 1<<2;
-	flagName	= 1<<3;
-	flagComment	= 1<<4;
+	flagText	= 1 << 0;
+	flagHdrCrc	= 1 << 1;
+	flagExtra	= 1 << 2;
+	flagName	= 1 << 3;
+	flagComment	= 1 << 4;
 )
 
 func makeReader(r io.Reader) flate.Reader {
@@ -130,7 +130,7 @@ func (z *Inflater) readHeader(save bool) os.Error {
 	z.digest.Reset();
 	z.digest.Write(z.buf[0:10]);
 
-	if z.flg & flagExtra != 0 {
+	if z.flg&flagExtra != 0 {
 		n, err := z.read2();
 		if err != nil {
 			return err
@@ -145,7 +145,7 @@ func (z *Inflater) readHeader(save bool) os.Error {
 	}
 
 	var s string;
-	if z.flg & flagName != 0 {
+	if z.flg&flagName != 0 {
 		if s, err = z.readString(); err != nil {
 			return err
 		}
@@ -154,7 +154,7 @@ func (z *Inflater) readHeader(save bool) os.Error {
 		}
 	}
 
-	if z.flg & flagComment != 0 {
+	if z.flg&flagComment != 0 {
 		if s, err = z.readString(); err != nil {
 			return err
 		}
@@ -163,7 +163,7 @@ func (z *Inflater) readHeader(save bool) os.Error {
 		}
 	}
 
-	if z.flg & flagHdrCrc != 0 {
+	if z.flg&flagHdrCrc != 0 {
 		n, err := z.read2();
 		if err != nil {
 			return err
diff --git a/src/pkg/compress/zlib/reader.go b/src/pkg/compress/zlib/reader.go
index c002589958..ffe5cbafc7 100644
--- a/src/pkg/compress/zlib/reader.go
+++ b/src/pkg/compress/zlib/reader.go
@@ -44,10 +44,10 @@ func NewInflater(r io.Reader) (io.ReadCloser, os.Error) {
 		return nil, err
 	}
 	h := uint(z.scratch[0])<<8 | uint(z.scratch[1]);
-	if (z.scratch[0] & 0x0f != zlibDeflate) || (h%31 != 0) {
+	if (z.scratch[0]&0x0f != zlibDeflate) || (h%31 != 0) {
 		return nil, HeaderError
 	}
-	if z.scratch[1] & 0x20 != 0 {
+	if z.scratch[1]&0x20 != 0 {
 		// BUG(nigeltao): The zlib package does not implement the FDICT flag.
 		return nil, UnsupportedError
 	}
diff --git a/src/pkg/compress/zlib/writer.go b/src/pkg/compress/zlib/writer.go
index 9b23b22938..25abcde3bf 100644
--- a/src/pkg/compress/zlib/writer.go
+++ b/src/pkg/compress/zlib/writer.go
@@ -97,10 +97,10 @@ func (z *writer) Close() os.Error {
 	}
 	checksum := z.digest.Sum32();
 	// ZLIB (RFC 1950) is big-endian, unlike GZIP (RFC 1952).
-	z.scratch[0] = uint8(checksum>>24);
-	z.scratch[1] = uint8(checksum>>16);
-	z.scratch[2] = uint8(checksum>>8);
-	z.scratch[3] = uint8(checksum>>0);
+	z.scratch[0] = uint8(checksum >> 24);
+	z.scratch[1] = uint8(checksum >> 16);
+	z.scratch[2] = uint8(checksum >> 8);
+	z.scratch[3] = uint8(checksum >> 0);
 	_, z.err = z.w.Write(z.scratch[0:4]);
 	return z.err;
 }
diff --git a/src/pkg/container/heap/heap.go b/src/pkg/container/heap/heap.go
index b80805972d..ecaa7481f6 100644
--- a/src/pkg/container/heap/heap.go
+++ b/src/pkg/container/heap/heap.go
@@ -35,7 +35,7 @@ func Init(h Interface)	{ sort.Sort(h) }
 //
 func Push(h Interface, x interface{}) {
 	h.Push(x);
-	up(h, h.Len() - 1);
+	up(h, h.Len()-1);
 }
 
 
@@ -66,7 +66,7 @@ func Remove(h Interface, i int) interface{} {
 
 func up(h Interface, j int) {
 	for {
-		i := (j-1)/2;
+		i := (j - 1) / 2;
 		if i == j || h.Less(i, j) {
 			break
 		}
@@ -82,7 +82,7 @@ func down(h Interface, i, n int) {
 		if j >= n {
 			break
 		}
-		if j1 := j+1; j1 < n && !h.Less(j, j1) {
+		if j1 := j + 1; j1 < n && !h.Less(j, j1) {
 			j = j1	// = 2*i + 2
 		}
 		if h.Less(i, j) {
diff --git a/src/pkg/container/ring/ring.go b/src/pkg/container/ring/ring.go
index a4b631db0b..5fcdfc366f 100644
--- a/src/pkg/container/ring/ring.go
+++ b/src/pkg/container/ring/ring.go
@@ -119,7 +119,7 @@ func (r *Ring) Unlink(n int) *Ring {
 	if n <= 0 {
 		return nil
 	}
-	return r.Link(r.Move(n+1));
+	return r.Link(r.Move(n + 1));
 }
 
 
diff --git a/src/pkg/container/ring/ring_test.go b/src/pkg/container/ring/ring_test.go
index db6fe42c82..b55f438fa2 100644
--- a/src/pkg/container/ring/ring_test.go
+++ b/src/pkg/container/ring/ring_test.go
@@ -85,8 +85,8 @@ func verify(t *testing.T, r *Ring, N int, sum int) {
 		t.Errorf("r.Move(%d) != r", -N)
 	}
 	for i := 0; i < 10; i++ {
-		ni := N+i;
-		mi := ni%N;
+		ni := N + i;
+		mi := ni % N;
 		if r.Move(ni) != r.Move(mi) {
 			t.Errorf("r.Move(%d) != r.Move(%d)", ni, mi)
 		}
@@ -138,7 +138,7 @@ func sum(r *Ring) int {
 }
 
 
-func sumN(n int) int	{ return (n*n + n)/2 }
+func sumN(n int) int	{ return (n*n + n) / 2 }
 
 
 func TestNew(t *testing.T) {
diff --git a/src/pkg/container/vector/vector.go b/src/pkg/container/vector/vector.go
index 97c917a7e7..714312be48 100644
--- a/src/pkg/container/vector/vector.go
+++ b/src/pkg/container/vector/vector.go
@@ -29,13 +29,13 @@ func copy(dst, src []Element) {
 func expand(a []Element, i, n int) []Element {
 	// make sure we have enough space
 	len0 := len(a);
-	len1 := len0+n;
+	len1 := len0 + n;
 	if len1 < cap(a) {
 		// enough space - just expand
 		a = a[0:len1]
 	} else {
 		// not enough space - double capacity
-		capb := cap(a)*2;
+		capb := cap(a) * 2;
 		if capb < len1 {
 			// still not enough - use required length
 			capb = len1
@@ -47,7 +47,7 @@ func expand(a []Element, i, n int) []Element {
 	}
 
 	// make a hole
-	for j := len0-1; j >= i; j-- {
+	for j := len0 - 1; j >= i; j-- {
 		a[j+n] = a[j]
 	}
 	return a;
@@ -68,12 +68,12 @@ func (p *Vector) Init(initial_len int) *Vector {
 		a = make([]Element, n);
 	} else {
 		// nil out entries
-		for j := len(a)-1; j >= 0; j-- {
+		for j := len(a) - 1; j >= 0; j-- {
 			a[j] = nil
 		}
 	}
 
-	p.a = a[0 : initial_len];
+	p.a = a[0:initial_len];
 	return p;
 }
 
@@ -128,7 +128,7 @@ func (p *Vector) Delete(i int) {
 	a := p.a;
 	n := len(a);
 
-	copy(a[i : n-1], a[i+1 : n]);
+	copy(a[i:n-1], a[i+1:n]);
 	a[n-1] = nil;	// support GC, nil out entry
 	p.a = a[0 : n-1];
 }
@@ -138,7 +138,7 @@ func (p *Vector) Delete(i int) {
 // x such that the 0th element of x appears at index i after insertion.
 func (p *Vector) InsertVector(i int, x *Vector) {
 	p.a = expand(p.a, i, len(x.a));
-	copy(p.a[i : i+len(x.a)], x.a);
+	copy(p.a[i:i+len(x.a)], x.a);
 }
 
 
@@ -146,7 +146,7 @@ func (p *Vector) InsertVector(i int, x *Vector) {
 func (p *Vector) Cut(i, j int) {
 	a := p.a;
 	n := len(a);
-	m := n-(j-i);
+	m := n - (j - i);
 
 	copy(a[i:m], a[j:n]);
 	for k := m; k < n; k++ {
@@ -160,7 +160,7 @@ func (p *Vector) Cut(i, j int) {
 // Slice returns a new Vector by slicing the old one to extract slice [i:j].
 // The elements are copied. The original vector is unchanged.
 func (p *Vector) Slice(i, j int) *Vector {
-	s := New(j-i);	// will fail in Init() if j < j
+	s := New(j - i);	// will fail in Init() if j < j
 	copy(s.a, p.a[i:j]);
 	return s;
 }
@@ -183,7 +183,7 @@ func (p *Vector) Push(x Element)	{ p.Insert(len(p.a), x) }
 
 // Pop deletes the last element of the vector.
 func (p *Vector) Pop() Element {
-	i := len(p.a)-1;
+	i := len(p.a) - 1;
 	x := p.a[i];
 	p.a[i] = nil;	// support GC, nil out entry
 	p.a = p.a[0:i];
diff --git a/src/pkg/container/vector/vector_test.go b/src/pkg/container/vector/vector_test.go
index 4e242601dd..f3c0fdf0c4 100644
--- a/src/pkg/container/vector/vector_test.go
+++ b/src/pkg/container/vector/vector_test.go
@@ -79,7 +79,7 @@ func TestInsertDeleteClear(t *testing.T) {
 			t.Error("B")
 		}
 	}
-	for i := n-1; i >= 0; i-- {
+	for i := n - 1; i >= 0; i-- {
 		if a.Last().(int) != val(0) {
 			t.Error("C")
 		}
@@ -146,7 +146,7 @@ func verify_slice(t *testing.T, x *Vector, elt, i, j int) {
 
 
 func verify_pattern(t *testing.T, x *Vector, a, b, c int) {
-	n := a+b+c;
+	n := a + b + c;
 	if x.Len() != n {
 		t.Errorf("O) wrong len %d (expected %d)", x.Len(), n)
 	}
@@ -194,7 +194,7 @@ func TestSorting(t *testing.T) {
 	const n = 100;
 
 	a := NewIntVector(n);
-	for i := n-1; i >= 0; i-- {
+	for i := n - 1; i >= 0; i-- {
 		a.Set(i, n-1-i)
 	}
 	if sort.IsSorted(a) {
@@ -202,7 +202,7 @@ func TestSorting(t *testing.T) {
 	}
 
 	b := NewStringVector(n);
-	for i := n-1; i >= 0; i-- {
+	for i := n - 1; i >= 0; i-- {
 		b.Set(i, fmt.Sprint(n-1-i))
 	}
 	if sort.IsSorted(b) {
diff --git a/src/pkg/crypto/aes/aes_test.go b/src/pkg/crypto/aes/aes_test.go
index d3a6b2b729..39933a8242 100644
--- a/src/pkg/crypto/aes/aes_test.go
+++ b/src/pkg/crypto/aes/aes_test.go
@@ -278,7 +278,7 @@ var encryptTests = []CryptTest{
 // Test encryptBlock against FIPS 197 examples.
 func TestEncryptBlock(t *testing.T) {
 	for i, tt := range encryptTests {
-		n := len(tt.key)+28;
+		n := len(tt.key) + 28;
 		enc := make([]uint32, n);
 		dec := make([]uint32, n);
 		expandKey(tt.key, enc, dec);
@@ -296,7 +296,7 @@ func TestEncryptBlock(t *testing.T) {
 // Test decryptBlock against FIPS 197 examples.
 func TestDecryptBlock(t *testing.T) {
 	for i, tt := range encryptTests {
-		n := len(tt.key)+28;
+		n := len(tt.key) + 28;
 		enc := make([]uint32, n);
 		dec := make([]uint32, n);
 		expandKey(tt.key, enc, dec);
diff --git a/src/pkg/crypto/aes/block.go b/src/pkg/crypto/aes/block.go
index c8870af1a7..dbd448f8bb 100644
--- a/src/pkg/crypto/aes/block.go
+++ b/src/pkg/crypto/aes/block.go
@@ -56,10 +56,10 @@ func encryptBlock(xk []uint32, src, dst []byte) {
 	nr := len(xk)/4 - 2;	// - 2: one above, one more below
 	k := 4;
 	for r := 0; r < nr; r++ {
-		t0 = xk[k+0]^te[0][s0>>24]^te[1][s1>>16&0xff]^te[2][s2>>8&0xff]^te[3][s3&0xff];
-		t1 = xk[k+1]^te[0][s1>>24]^te[1][s2>>16&0xff]^te[2][s3>>8&0xff]^te[3][s0&0xff];
-		t2 = xk[k+2]^te[0][s2>>24]^te[1][s3>>16&0xff]^te[2][s0>>8&0xff]^te[3][s1&0xff];
-		t3 = xk[k+3]^te[0][s3>>24]^te[1][s0>>16&0xff]^te[2][s1>>8&0xff]^te[3][s2&0xff];
+		t0 = xk[k+0] ^ te[0][s0>>24] ^ te[1][s1>>16&0xff] ^ te[2][s2>>8&0xff] ^ te[3][s3&0xff];
+		t1 = xk[k+1] ^ te[0][s1>>24] ^ te[1][s2>>16&0xff] ^ te[2][s3>>8&0xff] ^ te[3][s0&0xff];
+		t2 = xk[k+2] ^ te[0][s2>>24] ^ te[1][s3>>16&0xff] ^ te[2][s0>>8&0xff] ^ te[3][s1&0xff];
+		t3 = xk[k+3] ^ te[0][s3>>24] ^ te[1][s0>>16&0xff] ^ te[2][s1>>8&0xff] ^ te[3][s2&0xff];
 		k += 4;
 		s0, s1, s2, s3 = t0, t1, t2, t3;
 	}
@@ -101,10 +101,10 @@ func decryptBlock(xk []uint32, src, dst []byte) {
 	nr := len(xk)/4 - 2;	// - 2: one above, one more below
 	k := 4;
 	for r := 0; r < nr; r++ {
-		t0 = xk[k+0]^td[0][s0>>24]^td[1][s3>>16&0xff]^td[2][s2>>8&0xff]^td[3][s1&0xff];
-		t1 = xk[k+1]^td[0][s1>>24]^td[1][s0>>16&0xff]^td[2][s3>>8&0xff]^td[3][s2&0xff];
-		t2 = xk[k+2]^td[0][s2>>24]^td[1][s1>>16&0xff]^td[2][s0>>8&0xff]^td[3][s3&0xff];
-		t3 = xk[k+3]^td[0][s3>>24]^td[1][s2>>16&0xff]^td[2][s1>>8&0xff]^td[3][s0&0xff];
+		t0 = xk[k+0] ^ td[0][s0>>24] ^ td[1][s3>>16&0xff] ^ td[2][s2>>8&0xff] ^ td[3][s1&0xff];
+		t1 = xk[k+1] ^ td[0][s1>>24] ^ td[1][s0>>16&0xff] ^ td[2][s3>>8&0xff] ^ td[3][s2&0xff];
+		t2 = xk[k+2] ^ td[0][s2>>24] ^ td[1][s1>>16&0xff] ^ td[2][s0>>8&0xff] ^ td[3][s3&0xff];
+		t3 = xk[k+3] ^ td[0][s3>>24] ^ td[1][s2>>16&0xff] ^ td[2][s1>>8&0xff] ^ td[3][s0&0xff];
 		k += 4;
 		s0, s1, s2, s3 = t0, t1, t2, t3;
 	}
@@ -142,18 +142,18 @@ func rotw(w uint32) uint32	{ return w<<8 | w>>24 }
 func expandKey(key []byte, enc, dec []uint32) {
 	// Encryption key setup.
 	var i int;
-	nk := len(key)/4;
+	nk := len(key) / 4;
 	for i = 0; i < nk; i++ {
-		enc[i] = uint32(key[4*i])<<24 | uint32(key[4*i + 1])<<16 | uint32(key[4*i + 2])<<8 | uint32(key[4*i + 3])
+		enc[i] = uint32(key[4*i])<<24 | uint32(key[4*i+1])<<16 | uint32(key[4*i+2])<<8 | uint32(key[4*i+3])
 	}
 	for ; i < len(enc); i++ {
 		t := enc[i-1];
 		if i%nk == 0 {
-			t = subw(rotw(t))^(uint32(powx[i/nk - 1])<<24)
+			t = subw(rotw(t)) ^ (uint32(powx[i/nk-1]) << 24)
 		} else if nk > 6 && i%nk == 4 {
 			t = subw(t)
 		}
-		enc[i] = enc[i-nk]^t;
+		enc[i] = enc[i-nk] ^ t;
 	}
 
 	// Derive decryption key from encryption key.
@@ -164,11 +164,11 @@ func expandKey(key []byte, enc, dec []uint32) {
 	}
 	n := len(enc);
 	for i := 0; i < n; i += 4 {
-		ei := n-i-4;
+		ei := n - i - 4;
 		for j := 0; j < 4; j++ {
 			x := enc[ei+j];
 			if i > 0 && i+4 < n {
-				x = td[0][sbox0[x>>24]]^td[1][sbox0[x>>16&0xff]]^td[2][sbox0[x>>8&0xff]]^td[3][sbox0[x&0xff]]
+				x = td[0][sbox0[x>>24]] ^ td[1][sbox0[x>>16&0xff]] ^ td[2][sbox0[x>>8&0xff]] ^ td[3][sbox0[x&0xff]]
 			}
 			dec[i+j] = x;
 		}
diff --git a/src/pkg/crypto/aes/cipher.go b/src/pkg/crypto/aes/cipher.go
index fba5863cf1..651c2651e0 100644
--- a/src/pkg/crypto/aes/cipher.go
+++ b/src/pkg/crypto/aes/cipher.go
@@ -37,7 +37,7 @@ func NewCipher(key []byte) (*Cipher, os.Error) {
 		break
 	}
 
-	n := k+28;
+	n := k + 28;
 	c := &Cipher{make([]uint32, n), make([]uint32, n)};
 	expandKey(key, c.enc, c.dec);
 	return c, nil;
diff --git a/src/pkg/crypto/block/cfb.go b/src/pkg/crypto/block/cfb.go
index b07ea31389..d3c8852d70 100644
--- a/src/pkg/crypto/block/cfb.go
+++ b/src/pkg/crypto/block/cfb.go
@@ -31,7 +31,7 @@ func newCFB(c Cipher, s int, iv []byte) *cfbCipher {
 	b := c.BlockSize();
 	x := new(cfbCipher);
 	x.c = c;
-	x.blockSize = s/8;
+	x.blockSize = s / 8;
 	x.cipherSize = b;
 	x.iv = copy(iv);
 	x.tmp = make([]byte, b);
@@ -48,8 +48,8 @@ func (x *cfbCipher) Encrypt(src, dst []byte) {
 	}
 
 	// Slide unused IV pieces down and insert dst at end.
-	for i := 0; i < x.cipherSize - x.blockSize; i++ {
-		x.iv[i] = x.iv[i + x.blockSize]
+	for i := 0; i < x.cipherSize-x.blockSize; i++ {
+		x.iv[i] = x.iv[i+x.blockSize]
 	}
 	off := x.cipherSize - x.blockSize;
 	for i := off; i < x.cipherSize; i++ {
@@ -65,8 +65,8 @@ func (x *cfbCipher) Decrypt(src, dst []byte) {
 	}
 
 	// Slide unused IV pieces down and insert src at top.
-	for i := 0; i < x.cipherSize - x.blockSize; i++ {
-		x.iv[i] = x.iv[i + x.blockSize]
+	for i := 0; i < x.cipherSize-x.blockSize; i++ {
+		x.iv[i] = x.iv[i+x.blockSize]
 	}
 	off := x.cipherSize - x.blockSize;
 	for i := off; i < x.cipherSize; i++ {
diff --git a/src/pkg/crypto/block/cipher.go b/src/pkg/crypto/block/cipher.go
index 37ffebfa07..2ca15c1296 100644
--- a/src/pkg/crypto/block/cipher.go
+++ b/src/pkg/crypto/block/cipher.go
@@ -29,8 +29,8 @@ type Cipher interface {
 
 func shift1(src, dst []byte) byte {
 	var b byte;
-	for i := len(src)-1; i >= 0; i-- {
-		bb := src[i]>>7;
+	for i := len(src) - 1; i >= 0; i-- {
+		bb := src[i] >> 7;
 		dst[i] = src[i]<<1 | b;
 		b = bb;
 	}
diff --git a/src/pkg/crypto/block/cmac.go b/src/pkg/crypto/block/cmac.go
index 9b29316e6a..5b00b37272 100644
--- a/src/pkg/crypto/block/cmac.go
+++ b/src/pkg/crypto/block/cmac.go
@@ -32,9 +32,9 @@ func NewCMAC(c Cipher) hash.Hash {
 	var r byte;
 	n := c.BlockSize();
 	switch n {
-	case 64/8:
+	case 64 / 8:
 		r = r64
-	case 128/8:
+	case 128 / 8:
 		r = r128
 	default:
 		panic("crypto/block: NewCMAC: invalid cipher block size", n)
diff --git a/src/pkg/crypto/block/ctr.go b/src/pkg/crypto/block/ctr.go
index 1733a8de10..bfb0fc23e7 100644
--- a/src/pkg/crypto/block/ctr.go
+++ b/src/pkg/crypto/block/ctr.go
@@ -35,7 +35,7 @@ func (x *ctrStream) Next() []byte {
 	x.c.Encrypt(x.ctr, x.out);
 
 	// Increment counter
-	for i := len(x.ctr)-1; i >= 0; i-- {
+	for i := len(x.ctr) - 1; i >= 0; i-- {
 		x.ctr[i]++;
 		if x.ctr[i] != 0 {
 			break
diff --git a/src/pkg/crypto/block/eax.go b/src/pkg/crypto/block/eax.go
index 867c74fc73..b739f4ef14 100644
--- a/src/pkg/crypto/block/eax.go
+++ b/src/pkg/crypto/block/eax.go
@@ -184,7 +184,7 @@ func (cr *cmacReader) Read(p []byte) (n int, err os.Error) {
 
 	// copy tag+p into p+tmp and then swap tmp, tag
 	tmp := cr.tmp;
-	for i := n+tagBytes-1; i >= 0; i-- {
+	for i := n + tagBytes - 1; i >= 0; i-- {
 		var c byte;
 		if i < tagBytes {
 			c = tag[i]
diff --git a/src/pkg/crypto/block/ecb.go b/src/pkg/crypto/block/ecb.go
index b6818a72b9..851bdfd706 100644
--- a/src/pkg/crypto/block/ecb.go
+++ b/src/pkg/crypto/block/ecb.go
@@ -38,7 +38,7 @@ func (x *ecbDecrypter) fillCrypt() os.Error {
 	for len(x.crypt) < x.blockSize {
 		off := len(x.crypt);
 		var m int;
-		m, err = x.r.Read(x.crypt[off : x.blockSize]);
+		m, err = x.r.Read(x.crypt[off:x.blockSize]);
 		x.crypt = x.crypt[0 : off+m];
 		if m == 0 {
 			break
@@ -118,8 +118,8 @@ func (x *ecbDecrypter) Read(p []byte) (n int, err os.Error) {
 		return;
 	}
 	var i int;
-	for i = 0; i + x.blockSize <= n; i += x.blockSize {
-		a := p[i : i + x.blockSize];
+	for i = 0; i+x.blockSize <= n; i += x.blockSize {
+		a := p[i : i+x.blockSize];
 		x.c.Decrypt(a, a);
 	}
 
@@ -205,7 +205,7 @@ func (x *ecbEncrypter) slidePlain() {
 func (x *ecbEncrypter) fillPlain(p []byte) int {
 	off := len(x.plain);
 	n := len(p);
-	if max := cap(x.plain)-off; n > max {
+	if max := cap(x.plain) - off; n > max {
 		n = max
 	}
 	x.plain = x.plain[0 : off+n];
@@ -219,8 +219,8 @@ func (x *ecbEncrypter) fillPlain(p []byte) int {
 func (x *ecbEncrypter) encrypt() {
 	var i int;
 	n := len(x.plain);
-	for i = 0; i + x.blockSize <= n; i += x.blockSize {
-		a := x.plain[i : i + x.blockSize];
+	for i = 0; i+x.blockSize <= n; i += x.blockSize {
+		a := x.plain[i : i+x.blockSize];
 		x.c.Encrypt(a, a);
 	}
 	x.crypt = x.plain[0:i];
@@ -271,6 +271,6 @@ func NewECBEncrypter(c Cipher, w io.Writer) io.Writer {
 	x.blockSize = c.BlockSize();
 
 	// Create a buffer that is an integral number of blocks.
-	x.buf = make([]byte, 8192 / x.blockSize * x.blockSize);
+	x.buf = make([]byte, 8192/x.blockSize*x.blockSize);
 	return x;
 }
diff --git a/src/pkg/crypto/block/ecb_test.go b/src/pkg/crypto/block/ecb_test.go
index 57aae7ed2b..d07afbe941 100644
--- a/src/pkg/crypto/block/ecb_test.go
+++ b/src/pkg/crypto/block/ecb_test.go
@@ -61,7 +61,7 @@ func TestECBEncrypter(t *testing.T) {
 			if i%block == 0 {
 				delta++
 			}
-			crypt[i] = plain[i]+delta;
+			crypt[i] = plain[i] + delta;
 		}
 
 		for frag := 0; frag < 2; frag++ {
@@ -115,7 +115,7 @@ func testECBDecrypter(t *testing.T, maxio int) {
 	};
 	var plain, crypt [256]byte;
 	for i := 0; i < len(plain); i++ {
-		plain[i] = byte(255-i)
+		plain[i] = byte(255 - i)
 	}
 	b := new(bytes.Buffer);
 	for block := 1; block <= 64 && block <= maxio; block *= 2 {
@@ -125,7 +125,7 @@ func testECBDecrypter(t *testing.T, maxio int) {
 			if i%block == 0 {
 				delta++
 			}
-			crypt[i] = plain[i]+delta;
+			crypt[i] = plain[i] + delta;
 		}
 
 		for mode := 0; mode < len(readers); mode++ {
diff --git a/src/pkg/crypto/block/xor.go b/src/pkg/crypto/block/xor.go
index 36fc5799bc..f231919753 100644
--- a/src/pkg/crypto/block/xor.go
+++ b/src/pkg/crypto/block/xor.go
@@ -93,7 +93,7 @@ func (x *xorWriter) Write(p []byte) (n int, err os.Error) {
 					buf = x.rand.Next();
 					bp = 0;
 				}
-				x.work[i] = buf[bp]^p[i];
+				x.work[i] = buf[bp] ^ p[i];
 				bp++;
 			}
 			x.buf = buf[bp:len(buf)];
diff --git a/src/pkg/crypto/block/xor_test.go b/src/pkg/crypto/block/xor_test.go
index 7d1decae84..1815be3fcb 100644
--- a/src/pkg/crypto/block/xor_test.go
+++ b/src/pkg/crypto/block/xor_test.go
@@ -46,7 +46,7 @@ func testXorWriter(t *testing.T, maxio int) {
 			if i%block == 0 {
 				n++
 			}
-			crypt[i] = plain[i]^n;
+			crypt[i] = plain[i] ^ n;
 			n++;
 		}
 
@@ -104,7 +104,7 @@ func testXorReader(t *testing.T, maxio int) {
 	};
 	var plain, crypt [256]byte;
 	for i := 0; i < len(plain); i++ {
-		plain[i] = byte(255-i)
+		plain[i] = byte(255 - i)
 	}
 	b := new(bytes.Buffer);
 	for block := 1; block <= 64 && block <= maxio; block *= 2 {
@@ -114,7 +114,7 @@ func testXorReader(t *testing.T, maxio int) {
 			if i%block == 0 {
 				n++
 			}
-			crypt[i] = plain[i]^n;
+			crypt[i] = plain[i] ^ n;
 			n++;
 		}
 
diff --git a/src/pkg/crypto/hmac/hmac.go b/src/pkg/crypto/hmac/hmac.go
index d3be7c4ac7..8a9a4cbb5f 100644
--- a/src/pkg/crypto/hmac/hmac.go
+++ b/src/pkg/crypto/hmac/hmac.go
@@ -42,7 +42,7 @@ type hmac struct {
 
 func (h *hmac) tmpPad(xor byte) {
 	for i, k := range h.key {
-		h.tmp[i] = xor^k
+		h.tmp[i] = xor ^ k
 	}
 	for i := len(h.key); i < padSize; i++ {
 		h.tmp[i] = xor
@@ -86,7 +86,7 @@ func New(h hash.Hash, key []byte) hash.Hash {
 	for i, k := range key {
 		hm.key[i] = k
 	}
-	hm.tmp = make([]byte, padSize + hm.size);
+	hm.tmp = make([]byte, padSize+hm.size);
 	hm.Reset();
 	return hm;
 }
diff --git a/src/pkg/crypto/md5/md5.go b/src/pkg/crypto/md5/md5.go
index 3834665888..5194ccd7cc 100644
--- a/src/pkg/crypto/md5/md5.go
+++ b/src/pkg/crypto/md5/md5.go
@@ -52,11 +52,11 @@ func (d *digest) Write(p []byte) (nn int, err os.Error) {
 	d.len += uint64(nn);
 	if d.nx > 0 {
 		n := len(p);
-		if n > _Chunk - d.nx {
+		if n > _Chunk-d.nx {
 			n = _Chunk - d.nx
 		}
 		for i := 0; i < n; i++ {
-			d.x[d.nx + i] = p[i]
+			d.x[d.nx+i] = p[i]
 		}
 		d.nx += n;
 		if d.nx == _Chunk {
@@ -82,15 +82,15 @@ func (d *digest) Sum() []byte {
 	var tmp [64]byte;
 	tmp[0] = 0x80;
 	if len%64 < 56 {
-		d.Write(tmp[0 : 56 - len%64])
+		d.Write(tmp[0 : 56-len%64])
 	} else {
-		d.Write(tmp[0 : 64 + 56 - len%64])
+		d.Write(tmp[0 : 64+56-len%64])
 	}
 
 	// Length in bits.
 	len <<= 3;
 	for i := uint(0); i < 8; i++ {
-		tmp[i] = byte(len>>(8*i))
+		tmp[i] = byte(len >> (8 * i))
 	}
 	d.Write(tmp[0:8]);
 
@@ -104,11 +104,11 @@ func (d *digest) Sum() []byte {
 		s := d.s[i];
 		p[j] = byte(s);
 		j++;
-		p[j] = byte(s>>8);
+		p[j] = byte(s >> 8);
 		j++;
-		p[j] = byte(s>>16);
+		p[j] = byte(s >> 16);
 		j++;
-		p[j] = byte(s>>24);
+		p[j] = byte(s >> 24);
 		j++;
 	}
 	return p;
diff --git a/src/pkg/crypto/md5/md5block.go b/src/pkg/crypto/md5/md5block.go
index 8b633c77b7..22136942c1 100644
--- a/src/pkg/crypto/md5/md5block.go
+++ b/src/pkg/crypto/md5/md5block.go
@@ -99,7 +99,7 @@ func _Block(dig *digest, p []byte) int {
 		aa, bb, cc, dd := a, b, c, d;
 
 		for i := 0; i < 16; i++ {
-			j := i*4;
+			j := i * 4;
 			X[i] = uint32(p[j]) | uint32(p[j+1])<<8 | uint32(p[j+2])<<16 | uint32(p[j+3])<<24;
 		}
 
@@ -116,8 +116,8 @@ func _Block(dig *digest, p []byte) int {
 			x := i;
 			t := i;
 			s := shift1[i%4];
-			f := ((c^d)&b)^d;
-			a += f+X[x]+table[t];
+			f := ((c ^ d) & b) ^ d;
+			a += f + X[x] + table[t];
 			a = a<<s | a>>(32-s);
 			a += b;
 			a, b, c, d = d, a, b, c;
@@ -125,11 +125,11 @@ func _Block(dig *digest, p []byte) int {
 
 		// Round 2.
 		for i := 0; i < 16; i++ {
-			x := (1 + 5*i)%16;
-			t := 16+i;
+			x := (1 + 5*i) % 16;
+			t := 16 + i;
 			s := shift2[i%4];
-			g := ((b^c)&d)^c;
-			a += g+X[x]+table[t];
+			g := ((b ^ c) & d) ^ c;
+			a += g + X[x] + table[t];
 			a = a<<s | a>>(32-s);
 			a += b;
 			a, b, c, d = d, a, b, c;
@@ -137,11 +137,11 @@ func _Block(dig *digest, p []byte) int {
 
 		// Round 3.
 		for i := 0; i < 16; i++ {
-			x := (5 + 3*i)%16;
-			t := 32+i;
+			x := (5 + 3*i) % 16;
+			t := 32 + i;
 			s := shift3[i%4];
-			h := b^c^d;
-			a += h+X[x]+table[t];
+			h := b ^ c ^ d;
+			a += h + X[x] + table[t];
 			a = a<<s | a>>(32-s);
 			a += b;
 			a, b, c, d = d, a, b, c;
@@ -149,11 +149,11 @@ func _Block(dig *digest, p []byte) int {
 
 		// Round 4.
 		for i := 0; i < 16; i++ {
-			x := (7*i)%16;
+			x := (7 * i) % 16;
 			s := shift4[i%4];
-			t := 48+i;
-			ii := c^(b | ^d);
-			a += ii+X[x]+table[t];
+			t := 48 + i;
+			ii := c ^ (b | ^d);
+			a += ii + X[x] + table[t];
 			a = a<<s | a>>(32-s);
 			a += b;
 			a, b, c, d = d, a, b, c;
diff --git a/src/pkg/crypto/rc4/rc4.go b/src/pkg/crypto/rc4/rc4.go
index 5f770f29b6..d965f827bd 100644
--- a/src/pkg/crypto/rc4/rc4.go
+++ b/src/pkg/crypto/rc4/rc4.go
@@ -52,7 +52,7 @@ func (c *Cipher) XORKeyStream(buf []byte) {
 		c.i += 1;
 		c.j += c.s[c.i];
 		c.s[c.i], c.s[c.j] = c.s[c.j], c.s[c.i];
-		buf[i] ^= c.s[c.s[c.i] + c.s[c.j]];
+		buf[i] ^= c.s[c.s[c.i]+c.s[c.j]];
 	}
 }
 
diff --git a/src/pkg/crypto/rsa/pkcs1v15.go b/src/pkg/crypto/rsa/pkcs1v15.go
index ddfaad5798..96a8c6912d 100644
--- a/src/pkg/crypto/rsa/pkcs1v15.go
+++ b/src/pkg/crypto/rsa/pkcs1v15.go
@@ -19,7 +19,7 @@ import (
 // WARNING: use of this function to encrypt plaintexts other than session keys
 // is dangerous. Use RSA OAEP in new protocols.
 func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, err os.Error) {
-	k := (pub.N.Len() + 7)/8;
+	k := (pub.N.Len() + 7) / 8;
 	if len(msg) > k-11 {
 		err = MessageTooLongError{};
 		return;
@@ -28,7 +28,7 @@ func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, er
 	// EM = 0x02 || PS || 0x00 || M
 	em := make([]byte, k-1);
 	em[0] = 2;
-	ps, mm := em[1 : len(em)-len(msg)-1], em[len(em)-len(msg) : len(em)];
+	ps, mm := em[1:len(em)-len(msg)-1], em[len(em)-len(msg):len(em)];
 	err = nonZeroRandomBytes(ps, rand);
 	if err != nil {
 		return
@@ -67,7 +67,7 @@ func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (out [
 // Encryption Standard PKCS #1'', Daniel Bleichenbacher, Advances in Cryptology
 // (Crypto '98),
 func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []byte, key []byte) (err os.Error) {
-	k := (priv.N.Len() + 7)/8;
+	k := (priv.N.Len() + 7) / 8;
 	if k-(len(key)+3+8) < 0 {
 		err = DecryptionError{};
 		return;
@@ -84,7 +84,7 @@ func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []by
 }
 
 func decryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (valid int, msg []byte, err os.Error) {
-	k := (priv.N.Len() + 7)/8;
+	k := (priv.N.Len() + 7) / 8;
 	if k < 11 {
 		err = DecryptionError{};
 		return;
@@ -109,7 +109,7 @@ func decryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (valid
 
 	for i := 2; i < len(em); i++ {
 		equals0 := subtle.ConstantTimeByteEq(em[i], 0);
-		index = subtle.ConstantTimeSelect(lookingForIndex & equals0, i, index);
+		index = subtle.ConstantTimeSelect(lookingForIndex&equals0, i, index);
 		lookingForIndex = subtle.ConstantTimeSelect(equals0, 0, lookingForIndex);
 	}
 
diff --git a/src/pkg/crypto/rsa/pkcs1v15_test.go b/src/pkg/crypto/rsa/pkcs1v15_test.go
index 549bca4bf1..dbfc64a996 100644
--- a/src/pkg/crypto/rsa/pkcs1v15_test.go
+++ b/src/pkg/crypto/rsa/pkcs1v15_test.go
@@ -66,7 +66,7 @@ func TestEncryptPKCS1v15(t *testing.T) {
 	if err != nil {
 		t.Errorf("Failed to open /dev/urandom")
 	}
-	k := (rsaPrivateKey.N.Len() + 7)/8;
+	k := (rsaPrivateKey.N.Len() + 7) / 8;
 
 	tryEncryptDecrypt := func(in []byte, blind bool) bool {
 		if len(in) > k-11 {
diff --git a/src/pkg/crypto/rsa/rsa.go b/src/pkg/crypto/rsa/rsa.go
index 6aeab041b6..e425cf91cd 100644
--- a/src/pkg/crypto/rsa/rsa.go
+++ b/src/pkg/crypto/rsa/rsa.go
@@ -61,7 +61,7 @@ func randomSafePrime(rand io.Reader, bits int) (p *big.Int, err os.Error) {
 
 // randomNumber returns a uniform random value in [0, max).
 func randomNumber(rand io.Reader, max *big.Int) (n *big.Int, err os.Error) {
-	k := (max.Len() + 7)/8;
+	k := (max.Len() + 7) / 8;
 
 	// r is the number of bits in the used in the most significant byte of
 	// max.
@@ -81,7 +81,7 @@ func randomNumber(rand io.Reader, max *big.Int) (n *big.Int, err os.Error) {
 
 		// Clear bits in the first byte to increase the probability
 		// that the candidate is < max.
-		bytes[0] &= uint8(int(1<<r)-1);
+		bytes[0] &= uint8(int(1<<r) - 1);
 
 		n.SetBytes(bytes);
 		if big.CmpInt(n, max) < 0 {
@@ -259,8 +259,8 @@ func encrypt(c *big.Int, pub *PublicKey, m *big.Int) *big.Int {
 // twice the hash length plus 2.
 func EncryptOAEP(hash hash.Hash, rand io.Reader, pub *PublicKey, msg []byte, label []byte) (out []byte, err os.Error) {
 	hash.Reset();
-	k := (pub.N.Len() + 7)/8;
-	if len(msg) > k - 2 * hash.Size() - 2 {
+	k := (pub.N.Len() + 7) / 8;
+	if len(msg) > k-2*hash.Size()-2 {
 		err = MessageTooLongError{};
 		return;
 	}
@@ -270,12 +270,12 @@ func EncryptOAEP(hash hash.Hash, rand io.Reader, pub *PublicKey, msg []byte, lab
 	hash.Reset();
 
 	em := make([]byte, k);
-	seed := em[1 : 1 + hash.Size()];
-	db := em[1 + hash.Size() : len(em)];
+	seed := em[1 : 1+hash.Size()];
+	db := em[1+hash.Size() : len(em)];
 
-	bytes.Copy(db[0 : hash.Size()], lHash);
+	bytes.Copy(db[0:hash.Size()], lHash);
 	db[len(db)-len(msg)-1] = 1;
-	bytes.Copy(db[len(db)-len(msg) : len(db)], msg);
+	bytes.Copy(db[len(db)-len(msg):len(db)], msg);
 
 	_, err = io.ReadFull(rand, seed);
 	if err != nil {
@@ -359,9 +359,9 @@ func decrypt(rand io.Reader, priv *PrivateKey, c *big.Int) (m *big.Int, err os.E
 // DecryptOAEP decrypts ciphertext using RSA-OAEP.
 // If rand != nil, DecryptOAEP uses RSA blinding to avoid timing side-channel attacks.
 func DecryptOAEP(hash hash.Hash, rand io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) (msg []byte, err os.Error) {
-	k := (priv.N.Len() + 7)/8;
+	k := (priv.N.Len() + 7) / 8;
 	if len(ciphertext) > k ||
-		k < hash.Size() * 2 + 2 {
+		k < hash.Size()*2+2 {
 		err = DecryptionError{};
 		return;
 	}
@@ -386,13 +386,13 @@ func DecryptOAEP(hash hash.Hash, rand io.Reader, priv *PrivateKey, ciphertext []
 
 	firstByteIsZero := subtle.ConstantTimeByteEq(em[0], 0);
 
-	seed := em[1 : hash.Size() + 1];
-	db := em[hash.Size() + 1 : len(em)];
+	seed := em[1 : hash.Size()+1];
+	db := em[hash.Size()+1 : len(em)];
 
 	mgf1XOR(seed, hash, db);
 	mgf1XOR(db, hash, seed);
 
-	lHash2 := db[0 : hash.Size()];
+	lHash2 := db[0:hash.Size()];
 
 	// We have to validate the plaintext in contanst time in order to avoid
 	// attacks like: J. Manger. A Chosen Ciphertext Attack on RSA Optimal
@@ -407,17 +407,17 @@ func DecryptOAEP(hash hash.Hash, rand io.Reader, priv *PrivateKey, ciphertext []
 	//   invalid: 1 iff we saw a non-zero byte before the 0x01.
 	var lookingForIndex, index, invalid int;
 	lookingForIndex = 1;
-	rest := db[hash.Size() : len(db)];
+	rest := db[hash.Size():len(db)];
 
 	for i := 0; i < len(rest); i++ {
 		equals0 := subtle.ConstantTimeByteEq(rest[i], 0);
 		equals1 := subtle.ConstantTimeByteEq(rest[i], 1);
-		index = subtle.ConstantTimeSelect(lookingForIndex & equals1, i, index);
+		index = subtle.ConstantTimeSelect(lookingForIndex&equals1, i, index);
 		lookingForIndex = subtle.ConstantTimeSelect(equals1, 0, lookingForIndex);
-		invalid = subtle.ConstantTimeSelect(lookingForIndex & ^equals0, 1, invalid);
+		invalid = subtle.ConstantTimeSelect(lookingForIndex&^equals0, 1, invalid);
 	}
 
-	if firstByteIsZero & lHash2Good & ^invalid & ^lookingForIndex != 1 {
+	if firstByteIsZero&lHash2Good&^invalid&^lookingForIndex != 1 {
 		err = DecryptionError{};
 		return;
 	}
@@ -434,6 +434,6 @@ func leftPad(input []byte, size int) (out []byte) {
 		n = size
 	}
 	out = make([]byte, size);
-	bytes.Copy(out[len(out)-n : len(out)], input);
+	bytes.Copy(out[len(out)-n:len(out)], input);
 	return;
 }
diff --git a/src/pkg/crypto/sha1/sha1.go b/src/pkg/crypto/sha1/sha1.go
index b14fdbbf13..3201a2faad 100644
--- a/src/pkg/crypto/sha1/sha1.go
+++ b/src/pkg/crypto/sha1/sha1.go
@@ -54,11 +54,11 @@ func (d *digest) Write(p []byte) (nn int, err os.Error) {
 	d.len += uint64(nn);
 	if d.nx > 0 {
 		n := len(p);
-		if n > _Chunk - d.nx {
+		if n > _Chunk-d.nx {
 			n = _Chunk - d.nx
 		}
 		for i := 0; i < n; i++ {
-			d.x[d.nx + i] = p[i]
+			d.x[d.nx+i] = p[i]
 		}
 		d.nx += n;
 		if d.nx == _Chunk {
@@ -84,15 +84,15 @@ func (d *digest) Sum() []byte {
 	var tmp [64]byte;
 	tmp[0] = 0x80;
 	if len%64 < 56 {
-		d.Write(tmp[0 : 56 - len%64])
+		d.Write(tmp[0 : 56-len%64])
 	} else {
-		d.Write(tmp[0 : 64 + 56 - len%64])
+		d.Write(tmp[0 : 64+56-len%64])
 	}
 
 	// Length in bits.
 	len <<= 3;
 	for i := uint(0); i < 8; i++ {
-		tmp[i] = byte(len>>(56 - 8*i))
+		tmp[i] = byte(len >> (56 - 8*i))
 	}
 	d.Write(tmp[0:8]);
 
@@ -104,11 +104,11 @@ func (d *digest) Sum() []byte {
 	j := 0;
 	for i := 0; i < 5; i++ {
 		s := d.h[i];
-		p[j] = byte(s>>24);
+		p[j] = byte(s >> 24);
 		j++;
-		p[j] = byte(s>>16);
+		p[j] = byte(s >> 16);
 		j++;
-		p[j] = byte(s>>8);
+		p[j] = byte(s >> 8);
 		j++;
 		p[j] = byte(s);
 		j++;
diff --git a/src/pkg/crypto/sha1/sha1block.go b/src/pkg/crypto/sha1/sha1block.go
index 356b7625b0..2983bc7058 100644
--- a/src/pkg/crypto/sha1/sha1block.go
+++ b/src/pkg/crypto/sha1/sha1block.go
@@ -24,11 +24,11 @@ func _Block(dig *digest, p []byte) int {
 		// Can interlace the computation of w with the
 		// rounds below if needed for speed.
 		for i := 0; i < 16; i++ {
-			j := i*4;
+			j := i * 4;
 			w[i] = uint32(p[j])<<24 | uint32(p[j+1])<<16 | uint32(p[j+2])<<8 | uint32(p[j+3]);
 		}
 		for i := 16; i < 80; i++ {
-			tmp := w[i-3]^w[i-8]^w[i-14]^w[i-16];
+			tmp := w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16];
 			w[i] = tmp<<1 | tmp>>(32-1);
 		}
 
@@ -41,28 +41,28 @@ func _Block(dig *digest, p []byte) int {
 			f := b&c | (^b)&d;
 			a5 := a<<5 | a>>(32-5);
 			b30 := b<<30 | b>>(32-30);
-			t := a5+f+e+w[i]+_K0;
+			t := a5 + f + e + w[i] + _K0;
 			a, b, c, d, e = t, a, b30, c, d;
 		}
 		for i := 20; i < 40; i++ {
-			f := b^c^d;
+			f := b ^ c ^ d;
 			a5 := a<<5 | a>>(32-5);
 			b30 := b<<30 | b>>(32-30);
-			t := a5+f+e+w[i]+_K1;
+			t := a5 + f + e + w[i] + _K1;
 			a, b, c, d, e = t, a, b30, c, d;
 		}
 		for i := 40; i < 60; i++ {
 			f := b&c | b&d | c&d;
 			a5 := a<<5 | a>>(32-5);
 			b30 := b<<30 | b>>(32-30);
-			t := a5+f+e+w[i]+_K2;
+			t := a5 + f + e + w[i] + _K2;
 			a, b, c, d, e = t, a, b30, c, d;
 		}
 		for i := 60; i < 80; i++ {
-			f := b^c^d;
+			f := b ^ c ^ d;
 			a5 := a<<5 | a>>(32-5);
 			b30 := b<<30 | b>>(32-30);
-			t := a5+f+e+w[i]+_K3;
+			t := a5 + f + e + w[i] + _K3;
 			a, b, c, d, e = t, a, b30, c, d;
 		}
 
diff --git a/src/pkg/crypto/subtle/constant_time.go b/src/pkg/crypto/subtle/constant_time.go
index 8b5e37ee05..edbfa84fb2 100644
--- a/src/pkg/crypto/subtle/constant_time.go
+++ b/src/pkg/crypto/subtle/constant_time.go
@@ -13,7 +13,7 @@ func ConstantTimeCompare(x, y []byte) int {
 	var v byte;
 
 	for i := 0; i < len(x); i++ {
-		v |= x[i]^y[i]
+		v |= x[i] ^ y[i]
 	}
 
 	return ConstantTimeByteEq(v, 0);
@@ -21,35 +21,35 @@ func ConstantTimeCompare(x, y []byte) int {
 
 // ConstantTimeSelect returns x if v is 1 and y if v is 0.
 // Its behavior is undefined if v takes any other value.
-func ConstantTimeSelect(v, x, y int) int	{ return ^(v-1) & x | (v-1)&y }
+func ConstantTimeSelect(v, x, y int) int	{ return ^(v-1)&x | (v-1)&y }
 
 // ConstantTimeByteEq returns 1 if x == x and 0 otherwise.
 func ConstantTimeByteEq(x, y uint8) int {
-	z := ^(x^y);
-	z &= z>>4;
-	z &= z>>2;
-	z &= z>>1;
+	z := ^(x ^ y);
+	z &= z >> 4;
+	z &= z >> 2;
+	z &= z >> 1;
 
 	return int(z);
 }
 
 // ConstantTimeEq returns 1 if x == y and 0 otherwise.
 func ConstantTimeEq(x, y int32) int {
-	z := ^(x^y);
-	z &= z>>16;
-	z &= z>>8;
-	z &= z>>4;
-	z &= z>>2;
-	z &= z>>1;
-
-	return int(z&1);
+	z := ^(x ^ y);
+	z &= z >> 16;
+	z &= z >> 8;
+	z &= z >> 4;
+	z &= z >> 2;
+	z &= z >> 1;
+
+	return int(z & 1);
 }
 
 // ConstantTimeCopy copies the contents of y into x iff v == 1. If v == 0, x is left unchanged.
 // Its behavior is undefined if v takes any other value.
 func ConstantTimeCopy(v int, x, y []byte) {
-	xmask := byte(v-1);
-	ymask := byte(^(v-1));
+	xmask := byte(v - 1);
+	ymask := byte(^(v - 1));
 	for i := 0; i < len(x); i++ {
 		x[i] = x[i]&xmask | y[i]&ymask
 	}
diff --git a/src/pkg/crypto/tls/common.go b/src/pkg/crypto/tls/common.go
index d0ea5f6e24..e295cd4728 100644
--- a/src/pkg/crypto/tls/common.go
+++ b/src/pkg/crypto/tls/common.go
@@ -14,7 +14,7 @@ const (
 	// maxTLSCiphertext is the maximum length of a plaintext payload.
 	maxTLSPlaintext	= 16384;
 	// maxTLSCiphertext is the maximum length payload after compression and encryption.
-	maxTLSCiphertext	= 16384+2048;
+	maxTLSCiphertext	= 16384 + 2048;
 	// maxHandshakeMsg is the largest single handshake message that we'll buffer.
 	maxHandshakeMsg	= 65536;
 )
diff --git a/src/pkg/crypto/tls/handshake_messages.go b/src/pkg/crypto/tls/handshake_messages.go
index 0eb91fe742..b9c4cc36fd 100644
--- a/src/pkg/crypto/tls/handshake_messages.go
+++ b/src/pkg/crypto/tls/handshake_messages.go
@@ -25,22 +25,22 @@ func (m *clientHelloMsg) marshal() []byte {
 	length := 2 + 32 + 1 + len(m.sessionId) + 2 + len(m.cipherSuites)*2 + 1 + len(m.compressionMethods);
 	x := make([]byte, 4+length);
 	x[0] = typeClientHello;
-	x[1] = uint8(length>>16);
-	x[2] = uint8(length>>8);
+	x[1] = uint8(length >> 16);
+	x[2] = uint8(length >> 8);
 	x[3] = uint8(length);
 	x[4] = m.major;
 	x[5] = m.minor;
 	bytes.Copy(x[6:38], m.random);
 	x[38] = uint8(len(m.sessionId));
-	bytes.Copy(x[39 : 39+len(m.sessionId)], m.sessionId);
+	bytes.Copy(x[39:39+len(m.sessionId)], m.sessionId);
 	y := x[39+len(m.sessionId) : len(x)];
-	y[0] = uint8(len(m.cipherSuites)>>7);
-	y[1] = uint8(len(m.cipherSuites)<<1);
+	y[0] = uint8(len(m.cipherSuites) >> 7);
+	y[1] = uint8(len(m.cipherSuites) << 1);
 	for i, suite := range m.cipherSuites {
-		y[2 + i*2] = uint8(suite>>8);
-		y[3 + i*2] = uint8(suite);
+		y[2+i*2] = uint8(suite >> 8);
+		y[3+i*2] = uint8(suite);
 	}
-	z := y[2 + len(m.cipherSuites)*2 : len(y)];
+	z := y[2+len(m.cipherSuites)*2 : len(y)];
 	z[0] = uint8(len(m.compressionMethods));
 	bytes.Copy(z[1:len(z)], m.compressionMethods);
 	m.raw = x;
@@ -57,34 +57,34 @@ func (m *clientHelloMsg) unmarshal(data []byte) bool {
 	m.minor = data[5];
 	m.random = data[6:38];
 	sessionIdLen := int(data[38]);
-	if sessionIdLen > 32 || len(data) < 39 + sessionIdLen {
+	if sessionIdLen > 32 || len(data) < 39+sessionIdLen {
 		return false
 	}
-	m.sessionId = data[39 : 39 + sessionIdLen];
-	data = data[39 + sessionIdLen : len(data)];
+	m.sessionId = data[39 : 39+sessionIdLen];
+	data = data[39+sessionIdLen : len(data)];
 	if len(data) < 2 {
 		return false
 	}
 	// cipherSuiteLen is the number of bytes of cipher suite numbers. Since
 	// they are uint16s, the number must be even.
 	cipherSuiteLen := int(data[0])<<8 | int(data[1]);
-	if cipherSuiteLen % 2 == 1 || len(data) < 2 + cipherSuiteLen {
+	if cipherSuiteLen%2 == 1 || len(data) < 2+cipherSuiteLen {
 		return false
 	}
 	numCipherSuites := cipherSuiteLen / 2;
 	m.cipherSuites = make([]uint16, numCipherSuites);
 	for i := 0; i < numCipherSuites; i++ {
-		m.cipherSuites[i] = uint16(data[2 + 2*i])<<8 | uint16(data[3 + 2*i])
+		m.cipherSuites[i] = uint16(data[2+2*i])<<8 | uint16(data[3+2*i])
 	}
-	data = data[2 + cipherSuiteLen : len(data)];
+	data = data[2+cipherSuiteLen : len(data)];
 	if len(data) < 2 {
 		return false
 	}
 	compressionMethodsLen := int(data[0]);
-	if len(data) < 1 + compressionMethodsLen {
+	if len(data) < 1+compressionMethodsLen {
 		return false
 	}
-	m.compressionMethods = data[1 : 1 + compressionMethodsLen];
+	m.compressionMethods = data[1 : 1+compressionMethodsLen];
 
 	// A ClientHello may be following by trailing data: RFC 4346 section 7.4.1.2
 	return true;
@@ -104,17 +104,17 @@ func (m *serverHelloMsg) marshal() []byte {
 		return m.raw
 	}
 
-	length := 38+len(m.sessionId);
+	length := 38 + len(m.sessionId);
 	x := make([]byte, 4+length);
 	x[0] = typeServerHello;
-	x[1] = uint8(length>>16);
-	x[2] = uint8(length>>8);
+	x[1] = uint8(length >> 16);
+	x[2] = uint8(length >> 8);
 	x[3] = uint8(length);
 	x[4] = m.major;
 	x[5] = m.minor;
 	bytes.Copy(x[6:38], m.random);
 	x[38] = uint8(len(m.sessionId));
-	bytes.Copy(x[39 : 39+len(m.sessionId)], m.sessionId);
+	bytes.Copy(x[39:39+len(m.sessionId)], m.sessionId);
 	z := x[39+len(m.sessionId) : len(x)];
 	z[0] = uint8(m.cipherSuite >> 8);
 	z[1] = uint8(m.cipherSuite);
@@ -142,19 +142,19 @@ func (m *certificateMsg) marshal() (x []byte) {
 	length := 3 + 3*len(m.certificates) + i;
 	x = make([]byte, 4+length);
 	x[0] = typeCertificate;
-	x[1] = uint8(length>>16);
-	x[2] = uint8(length>>8);
+	x[1] = uint8(length >> 16);
+	x[2] = uint8(length >> 8);
 	x[3] = uint8(length);
 
-	certificateOctets := length-3;
+	certificateOctets := length - 3;
 	x[4] = uint8(certificateOctets >> 16);
 	x[5] = uint8(certificateOctets >> 8);
 	x[6] = uint8(certificateOctets);
 
 	y := x[7:len(x)];
 	for _, slice := range m.certificates {
-		y[0] = uint8(len(slice)>>16);
-		y[1] = uint8(len(slice)>>8);
+		y[0] = uint8(len(slice) >> 16);
+		y[1] = uint8(len(slice) >> 8);
 		y[2] = uint8(len(slice));
 		bytes.Copy(y[3:len(y)], slice);
 		y = y[3+len(slice) : len(y)];
@@ -181,13 +181,13 @@ func (m *clientKeyExchangeMsg) marshal() []byte {
 	if m.raw != nil {
 		return m.raw
 	}
-	length := len(m.ciphertext)+2;
+	length := len(m.ciphertext) + 2;
 	x := make([]byte, length+4);
 	x[0] = typeClientKeyExchange;
-	x[1] = uint8(length>>16);
-	x[2] = uint8(length>>8);
+	x[1] = uint8(length >> 16);
+	x[2] = uint8(length >> 8);
 	x[3] = uint8(length);
-	x[4] = uint8(len(m.ciphertext)>>8);
+	x[4] = uint8(len(m.ciphertext) >> 8);
 	x[5] = uint8(len(m.ciphertext));
 	bytes.Copy(x[6:len(x)], m.ciphertext);
 
@@ -201,7 +201,7 @@ func (m *clientKeyExchangeMsg) unmarshal(data []byte) bool {
 		return false
 	}
 	cipherTextLen := int(data[4])<<8 | int(data[5]);
-	if len(data) != 6 + cipherTextLen {
+	if len(data) != 6+cipherTextLen {
 		return false
 	}
 	m.ciphertext = data[6:len(data)];
diff --git a/src/pkg/crypto/tls/handshake_messages_test.go b/src/pkg/crypto/tls/handshake_messages_test.go
index 0fd3e48596..5dafc388bc 100644
--- a/src/pkg/crypto/tls/handshake_messages_test.go
+++ b/src/pkg/crypto/tls/handshake_messages_test.go
@@ -73,11 +73,11 @@ func (*clientHelloMsg) Generate(rand *rand.Rand, size int) reflect.Value {
 	m.minor = uint8(rand.Intn(256));
 	m.random = randomBytes(32, rand);
 	m.sessionId = randomBytes(rand.Intn(32), rand);
-	m.cipherSuites = make([]uint16, rand.Intn(63) + 1);
+	m.cipherSuites = make([]uint16, rand.Intn(63)+1);
 	for i := 0; i < len(m.cipherSuites); i++ {
 		m.cipherSuites[i] = uint16(rand.Int31())
 	}
-	m.compressionMethods = randomBytes(rand.Intn(63) + 1, rand);
+	m.compressionMethods = randomBytes(rand.Intn(63)+1, rand);
 
 	return reflect.NewValue(m);
 }
diff --git a/src/pkg/crypto/tls/prf.go b/src/pkg/crypto/tls/prf.go
index f8f3aa452a..c8cb916e86 100644
--- a/src/pkg/crypto/tls/prf.go
+++ b/src/pkg/crypto/tls/prf.go
@@ -35,9 +35,9 @@ func pHash(result, secret, seed []byte, hash hash.Hash) {
 		b := h.Sum();
 		todo := len(b);
 		if j+todo > len(result) {
-			todo = len(result)-j
+			todo = len(result) - j
 		}
-		bytes.Copy(result[j : j+todo], b);
+		bytes.Copy(result[j:j+todo], b);
 		j += todo;
 
 		h.Reset();
@@ -94,8 +94,8 @@ func keysFromPreMasterSecret11(preMasterSecret, clientRandom, serverRandom []byt
 	pRF11(keyMaterial, masterSecret, keyExpansionLabel, seed[0:len(seed)]);
 	clientMAC = keyMaterial[0:macLen];
 	serverMAC = keyMaterial[macLen : macLen*2];
-	clientKey = keyMaterial[macLen*2 : macLen*2 + keyLen];
-	serverKey = keyMaterial[macLen*2 + keyLen : len(keyMaterial)];
+	clientKey = keyMaterial[macLen*2 : macLen*2+keyLen];
+	serverKey = keyMaterial[macLen*2+keyLen : len(keyMaterial)];
 	return;
 }
 
diff --git a/src/pkg/crypto/tls/record_process.go b/src/pkg/crypto/tls/record_process.go
index 9a20ab68be..3bb0cd4a03 100644
--- a/src/pkg/crypto/tls/record_process.go
+++ b/src/pkg/crypto/tls/record_process.go
@@ -173,22 +173,22 @@ func (p *recordProcessor) processRecord(r *record) {
 		return;
 	}
 
-	fillMACHeader(&p.header, p.seqNum, len(r.payload) - p.mac.Size(), r);
+	fillMACHeader(&p.header, p.seqNum, len(r.payload)-p.mac.Size(), r);
 	p.seqNum++;
 
 	p.mac.Reset();
 	p.mac.Write(p.header[0:13]);
-	p.mac.Write(r.payload[0 : len(r.payload) - p.mac.Size()]);
+	p.mac.Write(r.payload[0 : len(r.payload)-p.mac.Size()]);
 	macBytes := p.mac.Sum();
 
-	if subtle.ConstantTimeCompare(macBytes, r.payload[len(r.payload) - p.mac.Size() : len(r.payload)]) != 1 {
+	if subtle.ConstantTimeCompare(macBytes, r.payload[len(r.payload)-p.mac.Size():len(r.payload)]) != 1 {
 		p.error(alertBadRecordMAC);
 		return;
 	}
 
 	switch r.contentType {
 	case recordTypeHandshake:
-		p.processHandshakeRecord(r.payload[0 : len(r.payload) - p.mac.Size()])
+		p.processHandshakeRecord(r.payload[0 : len(r.payload)-p.mac.Size()])
 	case recordTypeChangeCipherSpec:
 		if len(r.payload) != 1 || r.payload[0] != 1 {
 			p.error(alertUnexpectedMessage);
@@ -237,12 +237,12 @@ func (p *recordProcessor) processHandshakeRecord(data []byte) {
 		handshakeLen := int(p.handshakeBuf[1])<<16 |
 			int(p.handshakeBuf[2])<<8 |
 			int(p.handshakeBuf[3]);
-		if handshakeLen + 4 > len(p.handshakeBuf) {
+		if handshakeLen+4 > len(p.handshakeBuf) {
 			break
 		}
 
-		bytes := p.handshakeBuf[0 : handshakeLen + 4];
-		p.handshakeBuf = p.handshakeBuf[handshakeLen + 4 : len(p.handshakeBuf)];
+		bytes := p.handshakeBuf[0 : handshakeLen+4];
+		p.handshakeBuf = p.handshakeBuf[handshakeLen+4 : len(p.handshakeBuf)];
 		if bytes[0] == typeFinished {
 			// Special case because Finished is synchronous: the
 			// handshake handler has to tell us if it's ok to start
diff --git a/src/pkg/crypto/tls/record_write.go b/src/pkg/crypto/tls/record_write.go
index 7fcc603977..f55a214c3a 100644
--- a/src/pkg/crypto/tls/record_write.go
+++ b/src/pkg/crypto/tls/record_write.go
@@ -89,18 +89,18 @@ func (w *recordWriter) loop(writer io.Writer, appChan <-chan []byte, controlChan
 
 // fillMACHeader generates a MAC header. See RFC 4346, section 6.2.3.1.
 func fillMACHeader(header *[13]byte, seqNum uint64, length int, r *record) {
-	header[0] = uint8(seqNum>>56);
-	header[1] = uint8(seqNum>>48);
-	header[2] = uint8(seqNum>>40);
-	header[3] = uint8(seqNum>>32);
-	header[4] = uint8(seqNum>>24);
-	header[5] = uint8(seqNum>>16);
-	header[6] = uint8(seqNum>>8);
+	header[0] = uint8(seqNum >> 56);
+	header[1] = uint8(seqNum >> 48);
+	header[2] = uint8(seqNum >> 40);
+	header[3] = uint8(seqNum >> 32);
+	header[4] = uint8(seqNum >> 24);
+	header[5] = uint8(seqNum >> 16);
+	header[6] = uint8(seqNum >> 8);
 	header[7] = uint8(seqNum);
 	header[8] = uint8(r.contentType);
 	header[9] = r.major;
 	header[10] = r.minor;
-	header[11] = uint8(length>>8);
+	header[11] = uint8(length >> 8);
 	header[12] = uint8(length);
 }
 
@@ -116,8 +116,8 @@ func (w *recordWriter) writeRecord(r *record) {
 	w.encryptor.XORKeyStream(r.payload);
 	w.encryptor.XORKeyStream(macBytes);
 
-	length := len(r.payload)+len(macBytes);
-	w.header[11] = uint8(length>>8);
+	length := len(r.payload) + len(macBytes);
+	w.header[11] = uint8(length >> 8);
 	w.header[12] = uint8(length);
 	w.writer.Write(w.header[8:13]);
 	w.writer.Write(r.payload);
diff --git a/src/pkg/debug/dwarf/buf.go b/src/pkg/debug/dwarf/buf.go
index 2838c098fd..10a7e5cb8e 100644
--- a/src/pkg/debug/dwarf/buf.go
+++ b/src/pkg/debug/dwarf/buf.go
@@ -56,7 +56,7 @@ func (b *buf) string() string {
 		if b.data[i] == 0 {
 			s := string(b.data[0:i]);
 			b.data = b.data[i+1 : len(b.data)];
-			b.off += Offset(i+1);
+			b.off += Offset(i + 1);
 			return s;
 		}
 	}
@@ -93,10 +93,10 @@ func (b *buf) uint64() uint64 {
 func (b *buf) varint() (c uint64, bits uint) {
 	for i := 0; i < len(b.data); i++ {
 		byte := b.data[i];
-		c |= uint64(byte&0x7F)<<bits;
+		c |= uint64(byte&0x7F) << bits;
 		bits += 7;
 		if byte&0x80 == 0 {
-			b.off += Offset(i+1);
+			b.off += Offset(i + 1);
 			b.data = b.data[i+1 : len(b.data)];
 			return c, bits;
 		}
diff --git a/src/pkg/debug/dwarf/entry.go b/src/pkg/debug/dwarf/entry.go
index 9b2727b26d..2aec1c17e8 100644
--- a/src/pkg/debug/dwarf/entry.go
+++ b/src/pkg/debug/dwarf/entry.go
@@ -190,15 +190,15 @@ func (b *buf) entry(atab abbrevTable, ubase Offset) *Entry {
 		case formRefAddr:
 			val = Offset(b.addr())
 		case formRef1:
-			val = Offset(b.uint8())+ubase
+			val = Offset(b.uint8()) + ubase
 		case formRef2:
-			val = Offset(b.uint16())+ubase
+			val = Offset(b.uint16()) + ubase
 		case formRef4:
-			val = Offset(b.uint32())+ubase
+			val = Offset(b.uint32()) + ubase
 		case formRef8:
-			val = Offset(b.uint64())+ubase
+			val = Offset(b.uint64()) + ubase
 		case formRefUdata:
-			val = Offset(b.uint())+ubase
+			val = Offset(b.uint()) + ubase
 
 		// string
 		case formString:
@@ -267,9 +267,9 @@ func (r *Reader) Seek(off Offset) {
 	var u *unit;
 	for i = range d.unit {
 		u = &d.unit[i];
-		if u.off <= off && off < u.off + Offset(len(u.data)) {
+		if u.off <= off && off < u.off+Offset(len(u.data)) {
 			r.unit = i;
-			r.b = makeBuf(r.d, "info", off, u.data[off - u.off : len(u.data)], u.addrsize);
+			r.b = makeBuf(r.d, "info", off, u.data[off-u.off:len(u.data)], u.addrsize);
 			return;
 		}
 	}
@@ -278,7 +278,7 @@ func (r *Reader) Seek(off Offset) {
 
 // maybeNextUnit advances to the next unit if this one is finished.
 func (r *Reader) maybeNextUnit() {
-	for len(r.b.data) == 0 && r.unit + 1 < len(r.d.unit) {
+	for len(r.b.data) == 0 && r.unit+1 < len(r.d.unit) {
 		r.unit++;
 		u := &r.d.unit[r.unit];
 		r.b = makeBuf(r.d, "info", u.off, u.data, u.addrsize);
diff --git a/src/pkg/debug/dwarf/type.go b/src/pkg/debug/dwarf/type.go
index 2cac2e4fb3..bf57fd4bfa 100644
--- a/src/pkg/debug/dwarf/type.go
+++ b/src/pkg/debug/dwarf/type.go
@@ -339,11 +339,11 @@ func (d *Data) Type(off Offset) (Type, os.Error) {
 					max = -2	// Count == -1, as in x[].
 				}
 				if ndim == 0 {
-					t.Count = max+1
+					t.Count = max + 1
 				} else {
 					// Multidimensional array.
 					// Create new array type underneath this one.
-					t.Type = &ArrayType{Type: t.Type, Count: max+1}
+					t.Type = &ArrayType{Type: t.Type, Count: max + 1}
 				}
 				ndim++;
 			case TagEnumerationType:
diff --git a/src/pkg/debug/dwarf/unit.go b/src/pkg/debug/dwarf/unit.go
index 582fd0cf27..eb4e7656e5 100644
--- a/src/pkg/debug/dwarf/unit.go
+++ b/src/pkg/debug/dwarf/unit.go
@@ -53,7 +53,7 @@ func (d *Data) parseUnits() ([]unit, os.Error) {
 		u.atable = atable;
 		u.addrsize = int(b.uint8());
 		u.off = b.off;
-		u.data = b.bytes(int(n-(2+4+1)));
+		u.data = b.bytes(int(n - (2 + 4 + 1)));
 	}
 	if b.err != nil {
 		return nil, b.err
diff --git a/src/pkg/debug/elf/elf.go b/src/pkg/debug/elf/elf.go
index d0f75355ec..70a11f6f65 100644
--- a/src/pkg/debug/elf/elf.go
+++ b/src/pkg/debug/elf/elf.go
@@ -1351,8 +1351,8 @@ type Rela32 struct {
 	Addend	int32;	/* Addend. */
 }
 
-func R_SYM32(info uint32) uint32	{ return uint32(info>>8) }
-func R_TYPE32(info uint32) uint32	{ return uint32(info&0xff) }
+func R_SYM32(info uint32) uint32	{ return uint32(info >> 8) }
+func R_TYPE32(info uint32) uint32	{ return uint32(info & 0xff) }
 func R_INFO32(sym, typ uint32) uint32	{ return sym<<8 | typ }
 
 // ELF32 Symbol.
@@ -1367,9 +1367,9 @@ type Sym32 struct {
 
 const Sym32Size = 16
 
-func ST_BIND(info uint8) SymBind		{ return SymBind(info>>4) }
+func ST_BIND(info uint8) SymBind		{ return SymBind(info >> 4) }
 func ST_TYPE(bind SymBind, typ SymType) uint8	{ return uint8(bind)<<4 | uint8(typ)&0xf }
-func ST_VISIBILITY(other uint8) SymVis		{ return SymVis(other&3) }
+func ST_VISIBILITY(other uint8) SymVis		{ return SymVis(other & 3) }
 
 /*
  * ELF64
@@ -1454,7 +1454,7 @@ type Rela64 struct {
 	Addend	int64;	/* Addend. */
 }
 
-func R_SYM64(info uint64) uint32	{ return uint32(info>>32) }
+func R_SYM64(info uint64) uint32	{ return uint32(info >> 32) }
 func R_TYPE64(info uint64) uint32	{ return uint32(info) }
 func R_INFO(sym, typ uint32) uint64	{ return uint64(sym)<<32 | uint64(typ) }
 
@@ -1490,14 +1490,14 @@ func stringName(i uint32, names []intName, goSyntax bool) string {
 
 	// second pass - look for smaller to add with.
 	// assume sorted already
-	for j := len(names)-1; j >= 0; j-- {
+	for j := len(names) - 1; j >= 0; j-- {
 		n := names[j];
 		if n.i < i {
 			s := n.s;
 			if goSyntax {
-				s = "elf."+s
+				s = "elf." + s
 			}
-			return s + "+" + strconv.Uitoa64(uint64(i - n.i));
+			return s + "+" + strconv.Uitoa64(uint64(i-n.i));
 		}
 	}
 
@@ -1507,7 +1507,7 @@ func stringName(i uint32, names []intName, goSyntax bool) string {
 func flagName(i uint32, names []intName, goSyntax bool) string {
 	s := "";
 	for _, n := range names {
-		if n.i & i == n.i {
+		if n.i&i == n.i {
 			if len(s) > 0 {
 				s += "+"
 			}
diff --git a/src/pkg/debug/elf/elf_test.go b/src/pkg/debug/elf/elf_test.go
index 50827d2bc3..bc2a4f6875 100644
--- a/src/pkg/debug/elf/elf_test.go
+++ b/src/pkg/debug/elf/elf_test.go
@@ -22,7 +22,7 @@ var nameTests = []nameTest{
 	nameTest{SHT_PROGBITS, "SHT_PROGBITS"},
 	nameTest{SHF_MERGE + SHF_TLS, "SHF_MERGE+SHF_TLS"},
 	nameTest{PT_LOAD, "PT_LOAD"},
-	nameTest{PF_W+PF_R+0x50, "PF_W+PF_R+0x50"},
+	nameTest{PF_W + PF_R + 0x50, "PF_W+PF_R+0x50"},
 	nameTest{DT_SYMBOLIC, "DT_SYMBOLIC"},
 	nameTest{DF_BIND_NOW, "DF_BIND_NOW"},
 	nameTest{NT_FPREGSET, "NT_FPREGSET"},
@@ -35,7 +35,7 @@ var nameTests = []nameTest{
 	nameTest{R_386_GOT32, "R_386_GOT32"},
 	nameTest{R_PPC_GOT16_HI, "R_PPC_GOT16_HI"},
 	nameTest{R_SPARC_GOT22, "R_SPARC_GOT22"},
-	nameTest{ET_LOOS+5, "ET_LOOS+5"},
+	nameTest{ET_LOOS + 5, "ET_LOOS+5"},
 	nameTest{ProgFlag(0x50), "0x50"},
 }
 
diff --git a/src/pkg/debug/elf/file.go b/src/pkg/debug/elf/file.go
index 3d15f29cec..c9e015ae2e 100644
--- a/src/pkg/debug/elf/file.go
+++ b/src/pkg/debug/elf/file.go
@@ -76,7 +76,7 @@ func (s *Section) Data() ([]byte, os.Error) {
 }
 
 // Open returns a new ReadSeeker reading the ELF section.
-func (s *Section) Open() io.ReadSeeker	{ return io.NewSectionReader(s.sr, 0, 1<<63 - 1) }
+func (s *Section) Open() io.ReadSeeker	{ return io.NewSectionReader(s.sr, 0, 1<<63-1) }
 
 // A ProgHeader represents a single ELF program header.
 type ProgHeader struct {
@@ -104,7 +104,7 @@ type Prog struct {
 }
 
 // Open returns a new ReadSeeker reading the ELF program body.
-func (p *Prog) Open() io.ReadSeeker	{ return io.NewSectionReader(p.sr, 0, 1<<63 - 1) }
+func (p *Prog) Open() io.ReadSeeker	{ return io.NewSectionReader(p.sr, 0, 1<<63-1) }
 
 // A Symbol represents an entry in an ELF symbol table section.
 type Symbol struct {
@@ -163,7 +163,7 @@ func (f *File) Close() os.Error {
 // NewFile creates a new File for acecssing an ELF binary in an underlying reader.
 // The ELF binary is expected to start at position 0 in the ReaderAt.
 func NewFile(r io.ReaderAt) (*File, os.Error) {
-	sr := io.NewSectionReader(r, 0, 1<<63 - 1);
+	sr := io.NewSectionReader(r, 0, 1<<63-1);
 	// Read and decode ELF identifier
 	var ident [16]uint8;
 	if _, err := r.ReadAt(&ident, 0); err != nil {
@@ -302,7 +302,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 		var ok bool;
 		s.Name, ok = getString(shstrtab, int(names[i]));
 		if !ok {
-			return nil, &FormatError{shoff+int64(i * shentsize), "bad section name index", names[i]}
+			return nil, &FormatError{shoff + int64(i*shentsize), "bad section name index", names[i]}
 		}
 	}
 
@@ -337,7 +337,7 @@ func (f *File) getSymbols64() ([]Symbol, os.Error) {
 		return nil, os.ErrorString("cannot load symbol section")
 	}
 	symtab := bytes.NewBuffer(data);
-	if symtab.Len() % Sym64Size != 0 {
+	if symtab.Len()%Sym64Size != 0 {
 		return nil, os.ErrorString("length of symbol section is not a multiple of Sym64Size")
 	}
 
@@ -345,7 +345,7 @@ func (f *File) getSymbols64() ([]Symbol, os.Error) {
 	var skip [Sym64Size]byte;
 	symtab.Read(skip[0:len(skip)]);
 
-	symbols := make([]Symbol, symtab.Len() / Sym64Size);
+	symbols := make([]Symbol, symtab.Len()/Sym64Size);
 
 	i := 0;
 	var sym Sym64;
@@ -399,7 +399,7 @@ func (f *File) applyRelocations(dst []byte, rels []byte) os.Error {
 }
 
 func (f *File) applyRelocationsAMD64(dst []byte, rels []byte) os.Error {
-	if len(rels) % Sym64Size != 0 {
+	if len(rels)%Sym64Size != 0 {
 		return os.ErrorString("length of relocation section is not a multiple of Sym64Size")
 	}
 
@@ -420,22 +420,22 @@ func (f *File) applyRelocationsAMD64(dst []byte, rels []byte) os.Error {
 			continue
 		}
 		sym := &symbols[symNo];
-		if SymType(sym.Info & 0xf) != STT_SECTION {
+		if SymType(sym.Info&0xf) != STT_SECTION {
 			// We don't handle non-section relocations for now.
 			continue
 		}
 
 		switch t {
 		case R_X86_64_64:
-			if rela.Off + 8 >= uint64(len(dst)) || rela.Addend < 0 {
+			if rela.Off+8 >= uint64(len(dst)) || rela.Addend < 0 {
 				continue
 			}
-			f.ByteOrder.PutUint64(dst[rela.Off : rela.Off + 8], uint64(rela.Addend));
+			f.ByteOrder.PutUint64(dst[rela.Off:rela.Off+8], uint64(rela.Addend));
 		case R_X86_64_32:
-			if rela.Off + 4 >= uint64(len(dst)) || rela.Addend < 0 {
+			if rela.Off+4 >= uint64(len(dst)) || rela.Addend < 0 {
 				continue
 			}
-			f.ByteOrder.PutUint32(dst[rela.Off : rela.Off + 4], uint32(rela.Addend));
+			f.ByteOrder.PutUint32(dst[rela.Off:rela.Off+4], uint32(rela.Addend));
 		}
 	}
 
diff --git a/src/pkg/debug/gosym/pclntab.go b/src/pkg/debug/gosym/pclntab.go
index cfda629786..2fd93aa8e4 100644
--- a/src/pkg/debug/gosym/pclntab.go
+++ b/src/pkg/debug/gosym/pclntab.go
@@ -44,9 +44,9 @@ func (t *LineTable) parse(targetPC uint64, targetLine int) (b []byte, pc uint64,
 		case code <= 64:
 			line += int(code)
 		case code <= 128:
-			line -= int(code-64)
+			line -= int(code - 64)
 		default:
-			pc += quantum*uint64(code-128);
+			pc += quantum * uint64(code-128);
 			continue;
 		}
 		pc += quantum;
@@ -70,7 +70,7 @@ func (t *LineTable) LineToPC(line int, maxpc uint64) uint64 {
 		return 0
 	}
 	// Subtract quantum from PC to account for post-line increment
-	return pc-quantum;
+	return pc - quantum;
 }
 
 // NewLineTable returns a new PC/line table
diff --git a/src/pkg/debug/gosym/pclntab_test.go b/src/pkg/debug/gosym/pclntab_test.go
index 79a87f4a2e..c30b37e135 100644
--- a/src/pkg/debug/gosym/pclntab_test.go
+++ b/src/pkg/debug/gosym/pclntab_test.go
@@ -77,7 +77,7 @@ func TestLineFromAline(t *testing.T) {
 		// Check for end of object
 		if path == "" {
 			if final == -1 {
-				final = i-1
+				final = i - 1
 			}
 			continue;
 		} else if final != -1 {
@@ -121,7 +121,7 @@ func TestLineAline(t *testing.T) {
 			}
 
 			// cgo files are full of 'Z' symbols, which we don't handle
-			if len(path) > 4 && path[len(path)-4 : len(path)] == ".cgo" {
+			if len(path) > 4 && path[len(path)-4:len(path)] == ".cgo" {
 				continue
 			}
 
@@ -167,7 +167,7 @@ func TestPCLine(t *testing.T) {
 		wantLine += int(textdat[off]);
 		if fn == nil {
 			t.Errorf("failed to get line of PC %#x", pc)
-		} else if len(file) < 12 || file[len(file)-12 : len(file)] != "pclinetest.s" || line != wantLine || fn != sym {
+		} else if len(file) < 12 || file[len(file)-12:len(file)] != "pclinetest.s" || line != wantLine || fn != sym {
 			t.Errorf("expected %s:%d (%s) at PC %#x, got %s:%d (%s)", "pclinetest.s", wantLine, sym.Name, pc, file, line, fn.Name)
 		}
 	}
@@ -177,7 +177,7 @@ func TestPCLine(t *testing.T) {
 	lookupline := -1;
 	wantLine = 0;
 	off := uint64(0);	// TODO(rsc): should not need off; bug in 8g
-	for pc := sym.Value; pc < sym.End; pc += 2+uint64(textdat[off]) {
+	for pc := sym.Value; pc < sym.End; pc += 2 + uint64(textdat[off]) {
 		file, line, fn := tab.PCToLine(pc);
 		off = pc - text.Addr;
 		wantLine += int(textdat[off]);
diff --git a/src/pkg/debug/gosym/symtab.go b/src/pkg/debug/gosym/symtab.go
index ba20c7f385..3c2502e0a5 100644
--- a/src/pkg/debug/gosym/symtab.go
+++ b/src/pkg/debug/gosym/symtab.go
@@ -112,7 +112,7 @@ func walksymtab(data []byte, fn func(sym) os.Error) os.Error {
 		s.value = binary.BigEndian.Uint32(p[0:4]);
 		typ := p[4];
 		if typ&0x80 == 0 {
-			return &DecodingError{len(data)-len(p)+4, "bad symbol type", typ}
+			return &DecodingError{len(data) - len(p) + 4, "bad symbol type", typ}
 		}
 		typ &^= 0x80;
 		s.typ = typ;
@@ -240,13 +240,13 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
 
 			// Count & copy path symbols
 			var end int;
-			for end = i+1; end < len(t.Syms); end++ {
+			for end = i + 1; end < len(t.Syms); end++ {
 				if c := t.Syms[end].Type; c != 'Z' && c != 'z' {
 					break
 				}
 			}
 			obj.Paths = t.Syms[i:end];
-			i = end-1;	// loop will i++
+			i = end - 1;	// loop will i++
 
 			// Record file names
 			depth := 0;
@@ -274,7 +274,7 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
 			var np, na int;
 			var end int;
 		countloop:
-			for end = i+1; end < len(t.Syms); end++ {
+			for end = i + 1; end < len(t.Syms); end++ {
 				switch t.Syms[end].Type {
 				case 'T', 't', 'L', 'l', 'Z', 'z':
 					break countloop
@@ -314,7 +314,7 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
 					fn.Locals[n] = s;
 				}
 			}
-			i = end-1;	// loop will i++
+			i = end - 1;	// loop will i++
 		}
 	}
 	if obj != nil {
@@ -328,7 +328,7 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
 func (t *Table) PCToFunc(pc uint64) *Func {
 	funcs := t.Funcs;
 	for len(funcs) > 0 {
-		m := len(funcs)/2;
+		m := len(funcs) / 2;
 		fn := &funcs[m];
 		switch {
 		case pc < fn.Entry:
@@ -486,14 +486,14 @@ func (o *Obj) alineFromLine(path string, line int) (int, os.Error) {
 			val := int(s.Value);
 			switch {
 			case depth == 1 && val >= line:
-				return line-1, nil
+				return line - 1, nil
 
 			case s.Name == "":
 				depth--;
 				if depth == 0 {
 					break pathloop
 				} else if depth == 1 {
-					line += val-incstart
+					line += val - incstart
 				}
 
 			default:
diff --git a/src/pkg/debug/macho/file.go b/src/pkg/debug/macho/file.go
index 48687849a2..2338710745 100644
--- a/src/pkg/debug/macho/file.go
+++ b/src/pkg/debug/macho/file.go
@@ -75,7 +75,7 @@ func (s *Segment) Data() ([]byte, os.Error) {
 }
 
 // Open returns a new ReadSeeker reading the segment.
-func (s *Segment) Open() io.ReadSeeker	{ return io.NewSectionReader(s.sr, 0, 1<<63 - 1) }
+func (s *Segment) Open() io.ReadSeeker	{ return io.NewSectionReader(s.sr, 0, 1<<63-1) }
 
 type SectionHeader struct {
 	Name	string;
@@ -110,7 +110,7 @@ func (s *Section) Data() ([]byte, os.Error) {
 }
 
 // Open returns a new ReadSeeker reading the Mach-O section.
-func (s *Section) Open() io.ReadSeeker	{ return io.NewSectionReader(s.sr, 0, 1<<63 - 1) }
+func (s *Section) Open() io.ReadSeeker	{ return io.NewSectionReader(s.sr, 0, 1<<63-1) }
 
 
 /*
@@ -163,7 +163,7 @@ func (f *File) Close() os.Error {
 // The Mach-O binary is expected to start at position 0 in the ReaderAt.
 func NewFile(r io.ReaderAt) (*File, os.Error) {
 	f := new(File);
-	sr := io.NewSectionReader(r, 0, 1<<63 - 1);
+	sr := io.NewSectionReader(r, 0, 1<<63-1);
 
 	// Read and decode Mach magic to determine byte order, size.
 	// Magic32 and Magic64 differ only in the bottom bit.
@@ -173,11 +173,11 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 	}
 	be := binary.BigEndian.Uint32(&ident);
 	le := binary.LittleEndian.Uint32(&ident);
-	switch Magic32&^1 {
-	case be&^1:
+	switch Magic32 &^ 1 {
+	case be &^ 1:
 		f.ByteOrder = binary.BigEndian;
 		f.Magic = be;
-	case le&^1:
+	case le &^ 1:
 		f.ByteOrder = binary.LittleEndian;
 		f.Magic = le;
 	}
@@ -302,7 +302,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 func (f *File) pushSection(sh *Section, r io.ReaderAt) {
 	n := len(f.Sections);
 	if n >= cap(f.Sections) {
-		m := (n+1)*2;
+		m := (n + 1) * 2;
 		new := make([]*Section, n, m);
 		for i, sh := range f.Sections {
 			new[i] = sh
diff --git a/src/pkg/debug/macho/macho.go b/src/pkg/debug/macho/macho.go
index fc4924b2f4..abc59c8a6d 100644
--- a/src/pkg/debug/macho/macho.go
+++ b/src/pkg/debug/macho/macho.go
@@ -21,8 +21,8 @@ type FileHeader struct {
 }
 
 const (
-	fileHeaderSize32	= 7*4;
-	fileHeaderSize64	= 8*4;
+	fileHeaderSize32	= 7 * 4;
+	fileHeaderSize64	= 8 * 4;
 )
 
 const (
@@ -208,7 +208,7 @@ func stringName(i uint32, names []intName, goSyntax bool) string {
 func flagName(i uint32, names []intName, goSyntax bool) string {
 	s := "";
 	for _, n := range names {
-		if n.i & i == n.i {
+		if n.i&i == n.i {
 			if len(s) > 0 {
 				s += "+"
 			}
diff --git a/src/pkg/debug/proc/proc_linux.go b/src/pkg/debug/proc/proc_linux.go
index be42022d6b..5619550d18 100644
--- a/src/pkg/debug/proc/proc_linux.go
+++ b/src/pkg/debug/proc/proc_linux.go
@@ -1215,7 +1215,7 @@ func (p *process) attachAllThreads() os.Error {
 			if err != nil {
 				// There could have been a race, or
 				// this process could be a zobmie.
-				statFile, err2 := io.ReadFile(taskPath+"/"+tidStr+"/stat");
+				statFile, err2 := io.ReadFile(taskPath + "/" + tidStr + "/stat");
 				if err2 != nil {
 					switch err2 := err2.(type) {
 					case *os.PathError:
diff --git a/src/pkg/ebnf/ebnf.go b/src/pkg/ebnf/ebnf.go
index 0df330181d..4cf20d957c 100644
--- a/src/pkg/ebnf/ebnf.go
+++ b/src/pkg/ebnf/ebnf.go
@@ -141,7 +141,7 @@ func (v *verifier) push(prod *Production) {
 func (v *verifier) verifyChar(x *Token) int {
 	s := x.String;
 	if utf8.RuneCountInString(s) != 1 {
-		v.Error(x.Pos(), "single char expected, found " + s);
+		v.Error(x.Pos(), "single char expected, found "+s);
 		return 0;
 	}
 	ch, _ := utf8.DecodeRuneInString(s);
@@ -167,12 +167,12 @@ func (v *verifier) verifyExpr(expr Expression, lexical bool) {
 		if prod, found := v.grammar[x.String]; found {
 			v.push(prod)
 		} else {
-			v.Error(x.Pos(), "missing production " + x.String)
+			v.Error(x.Pos(), "missing production "+x.String)
 		}
 		// within a lexical production references
 		// to non-lexical productions are invalid
 		if lexical && !isLexical(x.String) {
-			v.Error(x.Pos(), "reference to non-lexical production " + x.String)
+			v.Error(x.Pos(), "reference to non-lexical production "+x.String)
 		}
 	case *Token:
 		// nothing to do for now
@@ -199,7 +199,7 @@ func (v *verifier) verify(grammar Grammar, start string) {
 	root, found := grammar[start];
 	if !found {
 		var noPos token.Position;
-		v.Error(noPos, "no start production " + start);
+		v.Error(noPos, "no start production "+start);
 		return;
 	}
 
@@ -220,7 +220,7 @@ func (v *verifier) verify(grammar Grammar, start string) {
 	if len(v.reached) < len(v.grammar) {
 		for name, prod := range v.grammar {
 			if _, found := v.reached[name]; !found {
-				v.Error(prod.Pos(), name + " is unreachable")
+				v.Error(prod.Pos(), name+" is unreachable")
 			}
 		}
 	}
diff --git a/src/pkg/ebnf/parser.go b/src/pkg/ebnf/parser.go
index 8c7b0b1410..a08cf821b6 100644
--- a/src/pkg/ebnf/parser.go
+++ b/src/pkg/ebnf/parser.go
@@ -39,7 +39,7 @@ func (p *parser) errorExpected(pos token.Position, msg string) {
 		// make the error message more specific
 		msg += ", found '" + p.tok.String() + "'";
 		if p.tok.IsLiteral() {
-			msg += " "+string(p.lit)
+			msg += " " + string(p.lit)
 		}
 	}
 	p.Error(pos, msg);
@@ -49,7 +49,7 @@ func (p *parser) errorExpected(pos token.Position, msg string) {
 func (p *parser) expect(tok token.Token) token.Position {
 	pos := p.pos;
 	if p.tok != tok {
-		p.errorExpected(pos, "'" + tok.String() + "'")
+		p.errorExpected(pos, "'"+tok.String()+"'")
 	}
 	p.next();	// make progress in any case
 	return pos;
@@ -194,7 +194,7 @@ func (p *parser) parse(filename string, src []byte) Grammar {
 		if _, found := grammar[name]; !found {
 			grammar[name] = prod
 		} else {
-			p.Error(prod.Pos(), name + " declared already")
+			p.Error(prod.Pos(), name+" declared already")
 		}
 	}
 
diff --git a/src/pkg/encoding/ascii85/ascii85.go b/src/pkg/encoding/ascii85/ascii85.go
index 819b263d07..7f6be9a157 100644
--- a/src/pkg/encoding/ascii85/ascii85.go
+++ b/src/pkg/encoding/ascii85/ascii85.go
@@ -46,13 +46,13 @@ func Encode(dst, src []byte) int {
 			v |= uint32(src[3]);
 			fallthrough;
 		case 3:
-			v |= uint32(src[2])<<8;
+			v |= uint32(src[2]) << 8;
 			fallthrough;
 		case 2:
-			v |= uint32(src[1])<<16;
+			v |= uint32(src[1]) << 16;
 			fallthrough;
 		case 1:
-			v |= uint32(src[0])<<24
+			v |= uint32(src[0]) << 24
 		}
 
 		// Special case: zero (!!!!!) shortens to z.
@@ -65,14 +65,14 @@ func Encode(dst, src []byte) int {
 
 		// Otherwise, 5 base 85 digits starting at !.
 		for i := 4; i >= 0; i-- {
-			dst[i] = '!'+byte(v%85);
+			dst[i] = '!' + byte(v%85);
 			v /= 85;
 		}
 
 		// If src was short, discard the low destination bytes.
 		m := 5;
 		if len(src) < 4 {
-			m -= 4-len(src);
+			m -= 4 - len(src);
 			src = nil;
 		} else {
 			src = src[4:len(src)]
@@ -84,7 +84,7 @@ func Encode(dst, src []byte) int {
 }
 
 // MaxEncodedLen returns the maximum length of an encoding of n source bytes.
-func MaxEncodedLen(n int) int	{ return (n+3)/4*5 }
+func MaxEncodedLen(n int) int	{ return (n + 3) / 4 * 5 }
 
 // NewEncoder returns a new ascii85 stream encoder.  Data written to
 // the returned writer will be encoded and then written to w.
@@ -127,11 +127,11 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 
 	// Large interior chunks.
 	for len(p) >= 4 {
-		nn := len(e.out)/5*4;
+		nn := len(e.out) / 5 * 4;
 		if nn > len(p) {
 			nn = len(p)
 		}
-		nn -= nn%4;
+		nn -= nn % 4;
 		if nn > 0 {
 			nout := Encode(&e.out, p[0:nn]);
 			if _, e.err = e.w.Write(e.out[0:nout]); e.err != nil {
@@ -156,7 +156,7 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 func (e *encoder) Close() os.Error {
 	// If there's anything left in the buffer, flush it out
 	if e.err == nil && e.nbuf > 0 {
-		nout := Encode(&e.out, e.buf[0 : e.nbuf]);
+		nout := Encode(&e.out, e.buf[0:e.nbuf]);
 		e.nbuf = 0;
 		_, e.err = e.w.Write(e.out[0:nout]);
 	}
@@ -207,10 +207,10 @@ func Decode(dst, src []byte, flush bool) (ndst, nsrc int, err os.Error) {
 			return 0, 0, CorruptInputError(i)
 		}
 		if nb == 5 {
-			nsrc = i+1;
-			dst[ndst] = byte(v>>24);
-			dst[ndst+1] = byte(v>>16);
-			dst[ndst+2] = byte(v>>8);
+			nsrc = i + 1;
+			dst[ndst] = byte(v >> 24);
+			dst[ndst+1] = byte(v >> 16);
+			dst[ndst+2] = byte(v >> 8);
 			dst[ndst+3] = byte(v);
 			ndst += 4;
 			nb = 0;
@@ -234,7 +234,7 @@ func Decode(dst, src []byte, flush bool) (ndst, nsrc int, err os.Error) {
 				v = v*85 + 84
 			}
 			for i := 0; i < nb-1; i++ {
-				dst[ndst] = byte(v>>24);
+				dst[ndst] = byte(v >> 24);
 				v <<= 8;
 				ndst++;
 			}
@@ -276,10 +276,10 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 		// Decode leftover input from last read.
 		var nn, nsrc, ndst int;
 		if d.nbuf > 0 {
-			ndst, nsrc, d.err = Decode(&d.outbuf, d.buf[0 : d.nbuf], d.readErr != nil);
+			ndst, nsrc, d.err = Decode(&d.outbuf, d.buf[0:d.nbuf], d.readErr != nil);
 			if ndst > 0 {
 				d.out = d.outbuf[0:ndst];
-				d.nbuf = bytes.Copy(&d.buf, d.buf[nsrc : d.nbuf]);
+				d.nbuf = bytes.Copy(&d.buf, d.buf[nsrc:d.nbuf]);
 				continue;	// copy out and return
 			}
 		}
@@ -294,7 +294,7 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 		}
 
 		// Read more data.
-		nn, d.readErr = d.r.Read(d.buf[d.nbuf : len(d.buf)]);
+		nn, d.readErr = d.r.Read(d.buf[d.nbuf:len(d.buf)]);
 		d.nbuf += nn;
 	}
 	panic("unreachable");
diff --git a/src/pkg/encoding/ascii85/ascii85_test.go b/src/pkg/encoding/ascii85/ascii85_test.go
index 36cc019d0d..40bb1a25e8 100644
--- a/src/pkg/encoding/ascii85/ascii85_test.go
+++ b/src/pkg/encoding/ascii85/ascii85_test.go
@@ -83,7 +83,7 @@ func TestEncoderBuffering(t *testing.T) {
 		bb := &bytes.Buffer{};
 		encoder := NewEncoder(bb);
 		for pos := 0; pos < len(input); pos += bs {
-			end := pos+bs;
+			end := pos + bs;
 			if end > len(input) {
 				end = len(input)
 			}
diff --git a/src/pkg/encoding/base64/base64.go b/src/pkg/encoding/base64/base64.go
index 83521ad45c..b0f57f6029 100644
--- a/src/pkg/encoding/base64/base64.go
+++ b/src/pkg/encoding/base64/base64.go
@@ -76,16 +76,16 @@ func (enc *Encoding) Encode(dst, src []byte) {
 		// destination quantum
 		switch len(src) {
 		default:
-			dst[3] |= src[2]&0x3F;
-			dst[2] |= src[2]>>6;
+			dst[3] |= src[2] & 0x3F;
+			dst[2] |= src[2] >> 6;
 			fallthrough;
 		case 2:
-			dst[2] |= (src[1]<<2)&0x3F;
-			dst[1] |= src[1]>>4;
+			dst[2] |= (src[1] << 2) & 0x3F;
+			dst[1] |= src[1] >> 4;
 			fallthrough;
 		case 1:
-			dst[1] |= (src[0]<<4)&0x3F;
-			dst[0] |= src[0]>>2;
+			dst[1] |= (src[0] << 4) & 0x3F;
+			dst[0] |= src[0] >> 2;
 		}
 
 		// Encode 6-bit blocks using the base64 alphabet
@@ -142,11 +142,11 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 
 	// Large interior chunks.
 	for len(p) >= 3 {
-		nn := len(e.out)/4*3;
+		nn := len(e.out) / 4 * 3;
 		if nn > len(p) {
 			nn = len(p)
 		}
-		nn -= nn%3;
+		nn -= nn % 3;
 		if nn > 0 {
 			e.enc.Encode(&e.out, p[0:nn]);
 			if _, e.err = e.w.Write(e.out[0 : nn/3*4]); e.err != nil {
@@ -171,7 +171,7 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 func (e *encoder) Close() os.Error {
 	// If there's anything left in the buffer, flush it out
 	if e.err == nil && e.nbuf > 0 {
-		e.enc.Encode(&e.out, e.buf[0 : e.nbuf]);
+		e.enc.Encode(&e.out, e.buf[0:e.nbuf]);
 		e.nbuf = 0;
 		_, e.err = e.w.Write(e.out[0:4]);
 	}
@@ -189,7 +189,7 @@ func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser {
 
 // EncodedLen returns the length in bytes of the base64 encoding
 // of an input buffer of length n.
-func (enc *Encoding) EncodedLen(n int) int	{ return (n+2)/3*4 }
+func (enc *Encoding) EncodedLen(n int) int	{ return (n + 2) / 3 * 4 }
 
 /*
  * Decoder
@@ -213,11 +213,11 @@ func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err os.Error) {
 
 	dbufloop:
 		for j := 0; j < 4; j++ {
-			in := src[i*4 + j];
-			if in == '=' && j >= 2 && i == len(src)/4 - 1 {
+			in := src[i*4+j];
+			if in == '=' && j >= 2 && i == len(src)/4-1 {
 				// We've reached the end and there's
 				// padding
-				if src[i*4 + 3] != '=' {
+				if src[i*4+3] != '=' {
 					return n, false, CorruptInputError(i*4 + 2)
 				}
 				dlen = j;
@@ -234,15 +234,15 @@ func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err os.Error) {
 		// quantum
 		switch dlen {
 		case 4:
-			dst[i*3 + 2] = dbuf[2]<<6 | dbuf[3];
+			dst[i*3+2] = dbuf[2]<<6 | dbuf[3];
 			fallthrough;
 		case 3:
-			dst[i*3 + 1] = dbuf[1]<<4 | dbuf[2]>>2;
+			dst[i*3+1] = dbuf[1]<<4 | dbuf[2]>>2;
 			fallthrough;
 		case 2:
-			dst[i*3 + 0] = dbuf[0]<<2 | dbuf[1]>>4
+			dst[i*3+0] = dbuf[0]<<2 | dbuf[1]>>4
 		}
-		n += dlen-1;
+		n += dlen - 1;
 	}
 
 	return n, end, nil;
@@ -254,7 +254,7 @@ func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err os.Error) {
 // number of bytes successfully written and CorruptInputError.
 func (enc *Encoding) Decode(dst, src []byte) (n int, err os.Error) {
 	if len(src)%4 != 0 {
-		return 0, CorruptInputError(len(src)/4*4)
+		return 0, CorruptInputError(len(src) / 4 * 4)
 	}
 
 	n, _, err = enc.decode(dst, src);
@@ -269,7 +269,7 @@ type decoder struct {
 	buf	[1024]byte;	// leftover input
 	nbuf	int;
 	out	[]byte;	// leftover decoded output
-	outbuf	[1024/4*3]byte;
+	outbuf	[1024 / 4 * 3]byte;
 }
 
 func (d *decoder) Read(p []byte) (n int, err os.Error) {
@@ -285,14 +285,14 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 	}
 
 	// Read a chunk.
-	nn := len(p)/3*4;
+	nn := len(p) / 3 * 4;
 	if nn < 4 {
 		nn = 4
 	}
 	if nn > len(d.buf) {
 		nn = len(d.buf)
 	}
-	nn, d.err = io.ReadAtLeast(d.r, d.buf[d.nbuf : nn], 4 - d.nbuf);
+	nn, d.err = io.ReadAtLeast(d.r, d.buf[d.nbuf:nn], 4-d.nbuf);
 	d.nbuf += nn;
 	if d.nbuf < 4 {
 		return 0, d.err
@@ -327,4 +327,4 @@ func NewDecoder(enc *Encoding, r io.Reader) io.Reader {
 
 // DecodeLen returns the maximum length in bytes of the decoded data
 // corresponding to n bytes of base64-encoded data.
-func (enc *Encoding) DecodedLen(n int) int	{ return n/4*3 }
+func (enc *Encoding) DecodedLen(n int) int	{ return n / 4 * 3 }
diff --git a/src/pkg/encoding/base64/base64_test.go b/src/pkg/encoding/base64/base64_test.go
index 2eb658bacb..51e40ed7e5 100644
--- a/src/pkg/encoding/base64/base64_test.go
+++ b/src/pkg/encoding/base64/base64_test.go
@@ -83,7 +83,7 @@ func TestEncoderBuffering(t *testing.T) {
 		bb := &bytes.Buffer{};
 		encoder := NewEncoder(StdEncoding, bb);
 		for pos := 0; pos < len(input); pos += bs {
-			end := pos+bs;
+			end := pos + bs;
 			if end > len(input) {
 				end = len(input)
 			}
diff --git a/src/pkg/encoding/binary/binary.go b/src/pkg/encoding/binary/binary.go
index 62d42a6b8c..abf2465cc7 100644
--- a/src/pkg/encoding/binary/binary.go
+++ b/src/pkg/encoding/binary/binary.go
@@ -38,7 +38,7 @@ func (littleEndian) Uint16(b []byte) uint16	{ return uint16(b[0]) | uint16(b[1])
 
 func (littleEndian) PutUint16(b []byte, v uint16) {
 	b[0] = byte(v);
-	b[1] = byte(v>>8);
+	b[1] = byte(v >> 8);
 }
 
 func (littleEndian) Uint32(b []byte) uint32 {
@@ -47,9 +47,9 @@ func (littleEndian) Uint32(b []byte) uint32 {
 
 func (littleEndian) PutUint32(b []byte, v uint32) {
 	b[0] = byte(v);
-	b[1] = byte(v>>8);
-	b[2] = byte(v>>16);
-	b[3] = byte(v>>24);
+	b[1] = byte(v >> 8);
+	b[2] = byte(v >> 16);
+	b[3] = byte(v >> 24);
 }
 
 func (littleEndian) Uint64(b []byte) uint64 {
@@ -59,13 +59,13 @@ func (littleEndian) Uint64(b []byte) uint64 {
 
 func (littleEndian) PutUint64(b []byte, v uint64) {
 	b[0] = byte(v);
-	b[1] = byte(v>>8);
-	b[2] = byte(v>>16);
-	b[3] = byte(v>>24);
-	b[4] = byte(v>>32);
-	b[5] = byte(v>>40);
-	b[6] = byte(v>>48);
-	b[7] = byte(v>>56);
+	b[1] = byte(v >> 8);
+	b[2] = byte(v >> 16);
+	b[3] = byte(v >> 24);
+	b[4] = byte(v >> 32);
+	b[5] = byte(v >> 40);
+	b[6] = byte(v >> 48);
+	b[7] = byte(v >> 56);
 }
 
 func (littleEndian) String() string	{ return "LittleEndian" }
@@ -77,7 +77,7 @@ type bigEndian unused
 func (bigEndian) Uint16(b []byte) uint16	{ return uint16(b[1]) | uint16(b[0])<<8 }
 
 func (bigEndian) PutUint16(b []byte, v uint16) {
-	b[0] = byte(v>>8);
+	b[0] = byte(v >> 8);
 	b[1] = byte(v);
 }
 
@@ -86,9 +86,9 @@ func (bigEndian) Uint32(b []byte) uint32 {
 }
 
 func (bigEndian) PutUint32(b []byte, v uint32) {
-	b[0] = byte(v>>24);
-	b[1] = byte(v>>16);
-	b[2] = byte(v>>8);
+	b[0] = byte(v >> 24);
+	b[1] = byte(v >> 16);
+	b[2] = byte(v >> 8);
 	b[3] = byte(v);
 }
 
@@ -98,13 +98,13 @@ func (bigEndian) Uint64(b []byte) uint64 {
 }
 
 func (bigEndian) PutUint64(b []byte, v uint64) {
-	b[0] = byte(v>>56);
-	b[1] = byte(v>>48);
-	b[2] = byte(v>>40);
-	b[3] = byte(v>>32);
-	b[4] = byte(v>>24);
-	b[5] = byte(v>>16);
-	b[6] = byte(v>>8);
+	b[0] = byte(v >> 56);
+	b[1] = byte(v >> 48);
+	b[2] = byte(v >> 40);
+	b[3] = byte(v >> 32);
+	b[4] = byte(v >> 24);
+	b[5] = byte(v >> 16);
+	b[6] = byte(v >> 8);
 	b[7] = byte(v);
 }
 
diff --git a/src/pkg/encoding/git85/git.go b/src/pkg/encoding/git85/git.go
index d9c72e83c1..cfe6275664 100644
--- a/src/pkg/encoding/git85/git.go
+++ b/src/pkg/encoding/git85/git.go
@@ -56,15 +56,15 @@ func Encode(dst, src []byte) int {
 			n = 52
 		}
 		if n <= 27 {
-			dst[ndst] = byte('A'+n-1)
+			dst[ndst] = byte('A' + n - 1)
 		} else {
-			dst[ndst] = byte('a'+n-26-1)
+			dst[ndst] = byte('a' + n - 26 - 1)
 		}
 		ndst++;
 		for i := 0; i < n; i += 4 {
 			var v uint32;
 			for j := 0; j < 4 && i+j < n; j++ {
-				v |= uint32(src[i+j])<<uint(24 - j*8)
+				v |= uint32(src[i+j]) << uint(24-j*8)
 			}
 			for j := 4; j >= 0; j-- {
 				dst[ndst+j] = encode[v%85];
@@ -103,16 +103,16 @@ func Decode(dst, src []byte) (n int, err os.Error) {
 		var l int;
 		switch ch := int(src[nsrc]); {
 		case 'A' <= ch && ch <= 'Z':
-			l = ch-'A'+1
+			l = ch - 'A' + 1
 		case 'a' <= ch && ch <= 'z':
-			l = ch-'a'+26+1
+			l = ch - 'a' + 26 + 1
 		default:
 			return ndst, CorruptInputError(nsrc)
 		}
 		if nsrc+1+l > len(src) {
 			return ndst, CorruptInputError(nsrc)
 		}
-		el := (l+3)/4*5;	// encoded len
+		el := (l + 3) / 4 * 5;	// encoded len
 		if nsrc+1+el+1 > len(src) || src[nsrc+1+el] != '\n' {
 			return ndst, CorruptInputError(nsrc)
 		}
@@ -122,12 +122,12 @@ func Decode(dst, src []byte) (n int, err os.Error) {
 			for j := 0; j < 5; j++ {
 				ch := decode[line[i+j]];
 				if ch == 0 {
-					return ndst, CorruptInputError(nsrc+1+i+j)
+					return ndst, CorruptInputError(nsrc + 1 + i + j)
 				}
 				v = v*85 + uint32(ch-1);
 			}
 			for j := 0; j < 4; j++ {
-				dst[ndst] = byte(v>>24);
+				dst[ndst] = byte(v >> 24);
 				v <<= 8;
 				ndst++;
 			}
@@ -137,12 +137,12 @@ func Decode(dst, src []byte) (n int, err os.Error) {
 		if l%4 != 0 {
 			ndst -= 4 - l%4
 		}
-		nsrc += 1+el+1;
+		nsrc += 1 + el + 1;
 	}
 	return ndst, nil;
 }
 
-func MaxDecodedLen(n int) int	{ return n/5*4 }
+func MaxDecodedLen(n int) int	{ return n / 5 * 4 }
 
 // NewEncoder returns a new GIT base85 stream encoder.  Data written to
 // the returned writer will be encoded and then written to w.
@@ -186,9 +186,9 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 
 	// Large interior chunks.
 	for len(p) >= 52 {
-		nn := len(e.out)/(1 + 52/4*5 + 1)*52;
+		nn := len(e.out) / (1 + 52/4*5 + 1) * 52;
 		if nn > len(p) {
-			nn = len(p)/52*52
+			nn = len(p) / 52 * 52
 		}
 		if nn > 0 {
 			nout := Encode(&e.out, p[0:nn]);
@@ -212,7 +212,7 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 func (e *encoder) Close() os.Error {
 	// If there's anything left in the buffer, flush it out
 	if e.err == nil && e.nbuf > 0 {
-		nout := Encode(&e.out, e.buf[0 : e.nbuf]);
+		nout := Encode(&e.out, e.buf[0:e.nbuf]);
 		e.nbuf = 0;
 		_, e.err = e.w.Write(e.out[0:nout]);
 	}
@@ -257,21 +257,21 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 
 		// Read and decode more input.
 		var nn int;
-		nn, d.readErr = d.r.Read(d.buf[d.nbuf : len(d.buf)]);
+		nn, d.readErr = d.r.Read(d.buf[d.nbuf:len(d.buf)]);
 		d.nbuf += nn;
 
 		// Send complete lines to Decode.
-		nl := bytes.LastIndex(d.buf[0 : d.nbuf], newline);
+		nl := bytes.LastIndex(d.buf[0:d.nbuf], newline);
 		if nl < 0 {
 			continue
 		}
-		nn, d.err = Decode(&d.outbuf, d.buf[0 : nl+1]);
+		nn, d.err = Decode(&d.outbuf, d.buf[0:nl+1]);
 		if e, ok := d.err.(CorruptInputError); ok {
 			d.err = CorruptInputError(int64(e) + d.off)
 		}
 		d.out = d.outbuf[0:nn];
-		d.nbuf = bytes.Copy(&d.buf, d.buf[nl+1 : d.nbuf]);
-		d.off += int64(nl+1);
+		d.nbuf = bytes.Copy(&d.buf, d.buf[nl+1:d.nbuf]);
+		d.off += int64(nl + 1);
 	}
 	panic("unreacahable");
 }
diff --git a/src/pkg/encoding/git85/git_test.go b/src/pkg/encoding/git85/git_test.go
index d956ed4ae9..713524af28 100644
--- a/src/pkg/encoding/git85/git_test.go
+++ b/src/pkg/encoding/git85/git_test.go
@@ -90,7 +90,7 @@ func TestEncoderBuffering(t *testing.T) {
 		bb := &bytes.Buffer{};
 		encoder := NewEncoder(bb);
 		for pos := 0; pos < len(input); pos += bs {
-			end := pos+bs;
+			end := pos + bs;
 			if end > len(input) {
 				end = len(input)
 			}
diff --git a/src/pkg/encoding/hex/hex.go b/src/pkg/encoding/hex/hex.go
index d97723db1f..17c4ae842e 100644
--- a/src/pkg/encoding/hex/hex.go
+++ b/src/pkg/encoding/hex/hex.go
@@ -14,7 +14,7 @@ import (
 const hextable = "0123456789abcdef"
 
 // EncodedLen returns the length of an encoding of n source bytes.
-func EncodedLen(n int) int	{ return n*2 }
+func EncodedLen(n int) int	{ return n * 2 }
 
 // Encode encodes src into EncodedLen(len(src))
 // bytes of dst.  As a convenience, it returns the number
@@ -23,10 +23,10 @@ func EncodedLen(n int) int	{ return n*2 }
 func Encode(dst, src []byte) int {
 	for i, v := range src {
 		dst[i*2] = hextable[v>>4];
-		dst[i*2 + 1] = hextable[v&0x0f];
+		dst[i*2+1] = hextable[v&0x0f];
 	}
 
-	return len(src)*2;
+	return len(src) * 2;
 }
 
 // OddLengthInputError results from decoding an odd length slice.
@@ -42,7 +42,7 @@ func (e InvalidHexCharError) String() string {
 }
 
 
-func DecodedLen(x int) int	{ return x/2 }
+func DecodedLen(x int) int	{ return x / 2 }
 
 // Decode decodes src into DecodedLen(len(src)) bytes, returning the actual
 // number of bytes written to dst.
@@ -59,25 +59,25 @@ func Decode(dst, src []byte) (int, os.Error) {
 		if !ok {
 			return 0, InvalidHexCharError(src[i*2])
 		}
-		b, ok := fromHexChar(src[i*2 + 1]);
+		b, ok := fromHexChar(src[i*2+1]);
 		if !ok {
-			return 0, InvalidHexCharError(src[i*2 + 1])
+			return 0, InvalidHexCharError(src[i*2+1])
 		}
-		dst[i] = (a<<4)|b;
+		dst[i] = (a << 4) | b;
 	}
 
-	return len(src)/2, nil;
+	return len(src) / 2, nil;
 }
 
 // fromHexChar converts a hex character into its value and a success flag.
 func fromHexChar(c byte) (byte, bool) {
 	switch {
 	case 0 <= c && c <= '9':
-		return c-'0', true
+		return c - '0', true
 	case 'a' <= c && c <= 'f':
-		return c-'a'+10, true
+		return c - 'a' + 10, true
 	case 'A' <= c && c <= 'F':
-		return c-'A'+10, true
+		return c - 'A' + 10, true
 	}
 
 	return 0, false;
diff --git a/src/pkg/encoding/pem/pem.go b/src/pkg/encoding/pem/pem.go
index 640673b3e8..409f07fb0b 100644
--- a/src/pkg/encoding/pem/pem.go
+++ b/src/pkg/encoding/pem/pem.go
@@ -38,7 +38,7 @@ func getLine(data []byte) (line, rest []byte) {
 		i = len(data);
 		j = i;
 	} else {
-		j = i+1;
+		j = i + 1;
 		if i > 0 && data[i-1] == '\r' {
 			i--
 		}
@@ -108,7 +108,7 @@ func Decode(data []byte) (p *Block, rest []byte) {
 		}
 
 		// TODO(agl): need to cope with values that spread across lines.
-		key, val := line[0:i], line[i+1 : len(line)];
+		key, val := line[0:i], line[i+1:len(line)];
 		key = bytes.TrimSpace(key);
 		val = bytes.TrimSpace(val);
 		p.Headers[string(key)] = string(val);
diff --git a/src/pkg/exec/exec.go b/src/pkg/exec/exec.go
index 5f5c33c573..8a19f0e8fa 100644
--- a/src/pkg/exec/exec.go
+++ b/src/pkg/exec/exec.go
@@ -188,7 +188,7 @@ func canExec(file string) bool {
 	if err != nil {
 		return false
 	}
-	return d.IsRegular() && d.Permission() & 0111 != 0;
+	return d.IsRegular() && d.Permission()&0111 != 0;
 }
 
 // LookPath searches for an executable binary named file
@@ -213,8 +213,8 @@ func LookPath(file string) (string, os.Error) {
 			// Unix shell semantics: path element "" means "."
 			dir = "."
 		}
-		if canExec(dir+"/"+file) {
-			return dir+"/"+file, nil
+		if canExec(dir + "/" + file) {
+			return dir + "/" + file, nil
 		}
 	}
 	return "", os.ENOENT;
diff --git a/src/pkg/exp/4s/4s.go b/src/pkg/exp/4s/4s.go
index 9064ac7678..2d22843fc7 100644
--- a/src/pkg/exp/4s/4s.go
+++ b/src/pkg/exp/4s/4s.go
@@ -32,7 +32,7 @@ func main() {
 		p = pieces5
 	}
 	dx, dy := 500, 500;
-	w, err := av.Init(av.SubsystemVideo | av.SubsystemAudio, dx, dy);
+	w, err := av.Init(av.SubsystemVideo|av.SubsystemAudio, dx, dy);
 	if err != nil {
 		log.Exit(err)
 	}
@@ -55,7 +55,7 @@ func audioServer() {
 		b := <-sndc;
 		for len(b)*2 >= n {
 			var a []uint16;
-			a, b = b[0 : n/2], b[n/2 : len(b)];
+			a, b = b[0:n/2], b[n/2:len(b)];
 			n, err = av.AudioStream(a);
 			if err != nil {
 				log.Exit(err)
diff --git a/src/pkg/exp/4s/xs.go b/src/pkg/exp/4s/xs.go
index e8cf48d783..93509ccd88 100644
--- a/src/pkg/exp/4s/xs.go
+++ b/src/pkg/exp/4s/xs.go
@@ -165,7 +165,7 @@ func movemouse() int {
 
 func warp(p draw.Point, x int) int {
 	if !suspended && piece != nil {
-		x = pos.X + piece.sz.X * pcsz / 2;
+		x = pos.X + piece.sz.X*pcsz/2;
 		if p.Y < rboard.Min.Y {
 			p.Y = rboard.Min.Y
 		}
@@ -194,8 +194,8 @@ func initPieces() {
 }
 
 func collide(pt draw.Point, p *Piece) bool {
-	pt.X = (pt.X - rboard.Min.X)/pcsz;
-	pt.Y = (pt.Y - rboard.Min.Y)/pcsz;
+	pt.X = (pt.X - rboard.Min.X) / pcsz;
+	pt.Y = (pt.Y - rboard.Min.Y) / pcsz;
 	for _, q := range p.d {
 		pt.X += q.X;
 		pt.Y += q.Y;
@@ -211,10 +211,10 @@ func collide(pt draw.Point, p *Piece) bool {
 }
 
 func collider(pt, pmax draw.Point) bool {
-	pi := (pt.X - rboard.Min.X)/pcsz;
-	pj := (pt.Y - rboard.Min.Y)/pcsz;
+	pi := (pt.X - rboard.Min.X) / pcsz;
+	pj := (pt.Y - rboard.Min.Y) / pcsz;
 	n := pmax.X / pcsz;
-	m := pmax.Y / pcsz + 1;
+	m := pmax.Y/pcsz + 1;
 	for i := pi; i < pi+n && i < NX; i++ {
 		for j := pj; j < pj+m && j < NY; j++ {
 			if board[j][i] != 0 {
@@ -296,7 +296,7 @@ func rest() {
 
 func canfit(p *Piece) bool {
 	var dx = [...]int{0, -1, 1, -2, 2, -3, 3, 4, -4};
-	j := N+1;
+	j := N + 1;
 	if j >= 4 {
 		j = p.sz.X;
 		if j < p.sz.Y {
@@ -338,12 +338,12 @@ func drawsq(b draw.Image, p draw.Point, ptx int) {
 
 func drawboard() {
 	draw.Border(screen, rboard.Inset(-2), 2, draw.Black, draw.ZP);
-	draw.Draw(screen, draw.Rect(rboard.Min.X, rboard.Min.Y - 2, rboard.Max.X, rboard.Min.Y),
+	draw.Draw(screen, draw.Rect(rboard.Min.X, rboard.Min.Y-2, rboard.Max.X, rboard.Min.Y),
 		draw.White, nil, draw.ZP);
 	for i := 0; i < NY; i++ {
 		for j := 0; j < NX; j++ {
 			if board[i][j] != 0 {
-				drawsq(screen, draw.Pt(rboard.Min.X + j*pcsz, rboard.Min.Y + i*pcsz), int(board[i][j]-16))
+				drawsq(screen, draw.Pt(rboard.Min.X+j*pcsz, rboard.Min.Y+i*pcsz), int(board[i][j]-16))
 			}
 		}
 	}
@@ -359,7 +359,7 @@ func choosepiece() {
 		setpiece(&pieces[i]);
 		pos = rboard.Min;
 		pos.X += rand.Intn(NX) * pcsz;
-		if !collide(draw.Pt(pos.X, pos.Y + pcsz - DY), piece) {
+		if !collide(draw.Pt(pos.X, pos.Y+pcsz-DY), piece) {
 			break
 		}
 	}
@@ -369,7 +369,7 @@ func choosepiece() {
 
 func movepiece() bool {
 	var mask image.Image;
-	if collide(draw.Pt(pos.X, pos.Y + pcsz), piece) {
+	if collide(draw.Pt(pos.X, pos.Y+pcsz), piece) {
 		return false
 	}
 	if collider(pos, br2.Max) {
@@ -463,14 +463,14 @@ func horiz() bool {
 	}
 	r = rboard;
 	for j := 0; j < h; j++ {
-		i := NY-lev[j]-1;
+		i := NY - lev[j] - 1;
 		score(250 + 10*i*i);
 		r.Min.Y = rboard.Min.Y;
 		r.Max.Y = rboard.Min.Y + lev[j]*pcsz;
 		draw.Draw(screen, r.Add(draw.Pt(0, pcsz)), screen, nil, r.Min);
 		r.Max.Y = rboard.Min.Y + pcsz;
 		draw.Draw(screen, r, draw.White, nil, draw.ZP);
-		for k := lev[j]-1; k >= 0; k-- {
+		for k := lev[j] - 1; k >= 0; k-- {
 			board[k+1] = board[k]
 		}
 		board[0] = [NX]byte{};
@@ -480,8 +480,8 @@ func horiz() bool {
 }
 
 func mright() {
-	if !collide(draw.Pt(pos.X + pcsz, pos.Y), piece) &&
-		!collide(draw.Pt(pos.X + pcsz, pos.Y + pcsz - DY), piece) {
+	if !collide(draw.Pt(pos.X+pcsz, pos.Y), piece) &&
+		!collide(draw.Pt(pos.X+pcsz, pos.Y+pcsz-DY), piece) {
 		undrawpiece();
 		pos.X += pcsz;
 		drawpiece();
@@ -490,8 +490,8 @@ func mright() {
 }
 
 func mleft() {
-	if !collide(draw.Pt(pos.X - pcsz, pos.Y), piece) &&
-		!collide(draw.Pt(pos.X - pcsz, pos.Y + pcsz - DY), piece) {
+	if !collide(draw.Pt(pos.X-pcsz, pos.Y), piece) &&
+		!collide(draw.Pt(pos.X-pcsz, pos.Y+pcsz-DY), piece) {
 		undrawpiece();
 		pos.X -= pcsz;
 		drawpiece();
@@ -519,7 +519,7 @@ var fusst = 0
 
 func drop(f bool) bool {
 	if f {
-		score(5*(rboard.Max.Y - pos.Y)/pcsz);
+		score(5 * (rboard.Max.Y - pos.Y) / pcsz);
 		for movepiece() {
 		}
 	}
@@ -561,15 +561,15 @@ func play() {
 				mleft();
 				lastmx = mouse.X;
 			}
-			if mouse.Buttons &^ om.Buttons & 1 == 1 {
+			if mouse.Buttons&^om.Buttons&1 == 1 {
 				rleft()
 			}
-			if mouse.Buttons &^ om.Buttons & 2 == 2 {
+			if mouse.Buttons&^om.Buttons&2 == 2 {
 				if drop(true) {
 					return
 				}
 			}
-			if mouse.Buttons &^ om.Buttons & 4 == 4 {
+			if mouse.Buttons&^om.Buttons&4 == 4 {
 				rright()
 			}
 			om = mouse;
@@ -611,12 +611,12 @@ func play() {
 			dt -= tsleep;
 			if dt < 0 {
 				i := 1;
-				dt = 16*(points + rand.Intn(10000) - 5000)/10000;
+				dt = 16 * (points + rand.Intn(10000) - 5000) / 10000;
 				if dt >= 32 {
-					i += (dt-32)/16;
+					i += (dt - 32) / 16;
 					dt = 32;
 				}
-				dt = 52-dt;
+				dt = 52 - dt;
 				for ; i > 0; i-- {
 					if movepiece() {
 						continue
@@ -670,37 +670,37 @@ func redraw(new bool) {
 	//		sysfatal("can't reattach to window");
 	//	}
 	r := draw.Rect(0, 0, screen.Width(), screen.Height());
-	pos.X = (pos.X - rboard.Min.X)/pcsz;
-	pos.Y = (pos.Y - rboard.Min.Y)/pcsz;
+	pos.X = (pos.X - rboard.Min.X) / pcsz;
+	pos.Y = (pos.Y - rboard.Min.Y) / pcsz;
 	dx := r.Max.X - r.Min.X;
 	dy := r.Max.Y - r.Min.Y - 2*32;
-	DY = dx/NX;
+	DY = dx / NX;
 	if DY > dy/NY {
-		DY = dy/NY
+		DY = dy / NY
 	}
 	DY /= 8;
 	if DY > 4 {
 		DY = 4
 	}
-	pcsz = DY*8;
-	DMOUSE = pcsz/3;
+	pcsz = DY * 8;
+	DMOUSE = pcsz / 3;
 	if pcsz < 8 {
 		log.Exitf("screen too small: %d", pcsz)
 	}
 	rboard = screenr;
-	rboard.Min.X += (dx - pcsz*NX)/2;
-	rboard.Min.Y += (dy - pcsz*NY)/2 + 32;
+	rboard.Min.X += (dx - pcsz*NX) / 2;
+	rboard.Min.Y += (dy-pcsz*NY)/2 + 32;
 	rboard.Max.X = rboard.Min.X + NX*pcsz;
 	rboard.Max.Y = rboard.Min.Y + NY*pcsz;
 	pscore.X = rboard.Min.X + 8;
 	pscore.Y = rboard.Min.Y - 32;
 	//	scoresz = stringsize(font, "000000");
-	pos.X = pos.X * pcsz + rboard.Min.X;
-	pos.Y = pos.Y * pcsz + rboard.Min.Y;
+	pos.X = pos.X*pcsz + rboard.Min.X;
+	pos.Y = pos.Y*pcsz + rboard.Min.Y;
 	bbr = draw.Rect(0, 0, N*pcsz, N*pcsz);
 	bb = image.NewRGBA(bbr.Max.X, bbr.Max.Y);
 	bbmask = image.NewRGBA(bbr.Max.X, bbr.Max.Y);	// actually just a bitmap
-	bb2r = draw.Rect(0, 0, N*pcsz, N*pcsz + DY);
+	bb2r = draw.Rect(0, 0, N*pcsz, N*pcsz+DY);
 	bb2 = image.NewRGBA(bb2r.Dx(), bb2r.Dy());
 	bb2mask = image.NewRGBA(bb2r.Dx(), bb2r.Dy());	// actually just a bitmap
 	draw.Draw(screen, screenr, draw.White, nil, draw.ZP);
@@ -726,10 +726,10 @@ func Play(pp []Piece, ctxt draw.Context) {
 	pieces = pp;
 	N = len(pieces[0].d);
 	initPieces();
-	rand.Seed(int32(time.Nanoseconds() % (1e9-1)));
+	rand.Seed(int32(time.Nanoseconds() % (1e9 - 1)));
 	whitemask = draw.White.SetAlpha(0x7F);
 	tsleep = 50;
-	timerc = time.Tick(int64(tsleep/2)*1e6);
+	timerc = time.Tick(int64(tsleep/2) * 1e6);
 	suspc = make(chan bool);
 	mousec = make(chan draw.Mouse);
 	resizec = ctxt.ResizeChan();
diff --git a/src/pkg/exp/datafmt/datafmt.go b/src/pkg/exp/datafmt/datafmt.go
index b6f596429d..67b6183ad4 100644
--- a/src/pkg/exp/datafmt/datafmt.go
+++ b/src/pkg/exp/datafmt/datafmt.go
@@ -361,14 +361,14 @@ func (s *State) Write(data []byte) (int, os.Error) {
 			// write text segment and indentation
 			n1, _ := s.output.Write(data[i0 : i+1]);
 			n2, _ := s.output.Write(s.indent.Bytes());
-			n += n1+n2;
-			i0 = i+1;
+			n += n1 + n2;
+			i0 = i + 1;
 			s.linePos.Offset = s.output.Len();
 			s.linePos.Line++;
 		}
 	}
 	n3, _ := s.output.Write(data[i0:len(data)]);
-	return n+n3, nil;
+	return n + n3, nil;
 }
 
 
@@ -597,7 +597,7 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {
 		// if the indentation evaluates to nil, the state's output buffer
 		// didn't change - either way it's ok to append the difference to
 		// the current identation
-		s.indent.Write(s.output.Bytes()[mark.outputLen : s.output.Len()]);
+		s.indent.Write(s.output.Bytes()[mark.outputLen:s.output.Len()]);
 		s.restore(mark);
 
 		// format group body
diff --git a/src/pkg/exp/datafmt/datafmt_test.go b/src/pkg/exp/datafmt/datafmt_test.go
index b4e5ed8d28..924250018b 100644
--- a/src/pkg/exp/datafmt/datafmt_test.go
+++ b/src/pkg/exp/datafmt/datafmt_test.go
@@ -43,7 +43,7 @@ func formatter(s *State, value interface{}, rule_name string) bool {
 		s.Write([]byte{' '});
 		return true;
 	case "int":
-		if value.(int) & 1 == 0 {
+		if value.(int)&1 == 0 {
 			fmt.Fprint(s, "even ")
 		} else {
 			fmt.Fprint(s, "odd ")
diff --git a/src/pkg/exp/datafmt/parser.go b/src/pkg/exp/datafmt/parser.go
index e3d5b61346..fe17ba22af 100644
--- a/src/pkg/exp/datafmt/parser.go
+++ b/src/pkg/exp/datafmt/parser.go
@@ -55,7 +55,7 @@ func (p *parser) errorExpected(pos token.Position, msg string) {
 		// make the error message more specific
 		msg += ", found '" + p.tok.String() + "'";
 		if p.tok.IsLiteral() {
-			msg += " "+string(p.lit)
+			msg += " " + string(p.lit)
 		}
 	}
 	p.Error(pos, msg);
@@ -65,7 +65,7 @@ func (p *parser) errorExpected(pos token.Position, msg string) {
 func (p *parser) expect(tok token.Token) token.Position {
 	pos := p.pos;
 	if p.tok != tok {
-		p.errorExpected(pos, "'" + tok.String() + "'")
+		p.errorExpected(pos, "'"+tok.String()+"'")
 	}
 	p.next();	// make progress in any case
 	return pos;
@@ -87,10 +87,10 @@ func (p *parser) parseTypeName() (string, bool) {
 		if importPath, found := p.packs[name]; found {
 			name = importPath
 		} else {
-			p.Error(pos, "package not declared: " + name)
+			p.Error(pos, "package not declared: "+name)
 		}
 		p.next();
-		name, isIdent = name + "." + p.parseIdentifier(), false;
+		name, isIdent = name+"."+p.parseIdentifier(), false;
 	}
 	return name, isIdent;
 }
@@ -306,11 +306,11 @@ func (p *parser) parseFormat() {
 
 			// add package declaration
 			if !isIdent {
-				p.Error(pos, "illegal package name: " + name)
+				p.Error(pos, "illegal package name: "+name)
 			} else if _, found := p.packs[name]; !found {
 				p.packs[name] = importPath
 			} else {
-				p.Error(pos, "package already declared: " + name)
+				p.Error(pos, "package already declared: "+name)
 			}
 
 		case token.ASSIGN:
@@ -322,7 +322,7 @@ func (p *parser) parseFormat() {
 			if _, found := p.rules[name]; !found {
 				p.rules[name] = x
 			} else {
-				p.Error(pos, "format rule already declared: " + name)
+				p.Error(pos, "format rule already declared: "+name)
 			}
 
 		default:
@@ -349,7 +349,7 @@ func remap(p *parser, name string) string {
 			name = importPath + suffix
 		} else {
 			var invalidPos token.Position;
-			p.Error(invalidPos, "package not declared: " + packageName);
+			p.Error(invalidPos, "package not declared: "+packageName);
 		}
 	}
 	return name;
@@ -374,7 +374,7 @@ func Parse(filename string, src []byte, fmap FormatterMap) (Format, os.Error) {
 			p.rules[name] = &custom{name, form}
 		} else {
 			var invalidPos token.Position;
-			p.Error(invalidPos, "formatter already declared: " + name);
+			p.Error(invalidPos, "formatter already declared: "+name);
 		}
 	}
 
diff --git a/src/pkg/exp/draw/color.go b/src/pkg/exp/draw/color.go
index 0d94800de1..1ebb3a21b0 100644
--- a/src/pkg/exp/draw/color.go
+++ b/src/pkg/exp/draw/color.go
@@ -50,14 +50,14 @@ var (
 func (c Color) RGBA() (r, g, b, a uint32) {
 	x := uint32(c);
 	r, g, b, a = x>>24, (x>>16)&0xFF, (x>>8)&0xFF, x&0xFF;
-	r |= r<<8;
-	r |= r<<16;
-	g |= g<<8;
-	g |= g<<16;
-	b |= b<<8;
-	b |= b<<16;
-	a |= a<<8;
-	a |= a<<16;
+	r |= r << 8;
+	r |= r << 16;
+	g |= g << 8;
+	g |= g << 16;
+	b |= b << 8;
+	b |= b << 16;
+	a |= a << 8;
+	a |= a << 16;
 	return;
 }
 
@@ -68,21 +68,21 @@ func (c Color) SetAlpha(a uint8) Color {
 	if oa == 0 {
 		return 0
 	}
-	r = r*Color(a)/oa;
+	r = r * Color(a) / oa;
 	if r < 0 {
 		r = 0
 	}
 	if r > 0xFF {
 		r = 0xFF
 	}
-	g = g*Color(a)/oa;
+	g = g * Color(a) / oa;
 	if g < 0 {
 		g = 0
 	}
 	if g > 0xFF {
 		g = 0xFF
 	}
-	b = b*Color(a)/oa;
+	b = b * Color(a) / oa;
 	if b < 0 {
 		b = 0
 	}
diff --git a/src/pkg/exp/draw/draw.go b/src/pkg/exp/draw/draw.go
index 284211aa2a..d01cdcc163 100644
--- a/src/pkg/exp/draw/draw.go
+++ b/src/pkg/exp/draw/draw.go
@@ -83,11 +83,11 @@ func Draw(dst Image, r Rectangle, src, mask image.Image, pt Point) {
 				sa >>= 16;
 				ma >>= 16;
 				const M = 1<<16 - 1;
-				a := sa*ma/M;
-				dr = (dr*(M-a) + sr*ma)/M;
-				dg = (dg*(M-a) + sg*ma)/M;
-				db = (db*(M-a) + sb*ma)/M;
-				da = (da*(M-a) + sa*ma)/M;
+				a := sa * ma / M;
+				dr = (dr*(M-a) + sr*ma) / M;
+				dg = (dg*(M-a) + sg*ma) / M;
+				db = (db*(M-a) + sb*ma) / M;
+				da = (da*(M-a) + sa*ma) / M;
 				if out == nil {
 					out = new(image.RGBA64Color)
 				}
@@ -109,17 +109,17 @@ func Border(dst Image, r Rectangle, w int, src image.Image, sp Point) {
 	i := w;
 	if i > 0 {
 		// inside r
-		Draw(dst, Rect(r.Min.X, r.Min.Y, r.Max.X, r.Min.Y + i), src, nil, sp);					// top
-		Draw(dst, Rect(r.Min.X, r.Min.Y + i, r.Min.X + i, r.Max.Y - i), src, nil, sp.Add(Pt(0, i)));		// left
-		Draw(dst, Rect(r.Max.X - i, r.Min.Y + i, r.Max.X, r.Max.Y - i), src, nil, sp.Add(Pt(r.Dx() - i, i)));	// right
-		Draw(dst, Rect(r.Min.X, r.Max.Y - i, r.Max.X, r.Max.Y), src, nil, sp.Add(Pt(0, r.Dy() - i)));		// bottom
+		Draw(dst, Rect(r.Min.X, r.Min.Y, r.Max.X, r.Min.Y+i), src, nil, sp);				// top
+		Draw(dst, Rect(r.Min.X, r.Min.Y+i, r.Min.X+i, r.Max.Y-i), src, nil, sp.Add(Pt(0, i)));		// left
+		Draw(dst, Rect(r.Max.X-i, r.Min.Y+i, r.Max.X, r.Max.Y-i), src, nil, sp.Add(Pt(r.Dx()-i, i)));	// right
+		Draw(dst, Rect(r.Min.X, r.Max.Y-i, r.Max.X, r.Max.Y), src, nil, sp.Add(Pt(0, r.Dy()-i)));	// bottom
 		return;
 	}
 
 	// outside r;
 	i = -i;
-	Draw(dst, Rect(r.Min.X - i, r.Min.Y - i, r.Max.X + i, r.Min.Y), src, nil, sp.Add(Pt(-i, -i)));	// top
-	Draw(dst, Rect(r.Min.X - i, r.Min.Y, r.Min.X, r.Max.Y), src, nil, sp.Add(Pt(-i, 0)));		// left
-	Draw(dst, Rect(r.Max.X, r.Min.Y, r.Max.X + i, r.Max.Y), src, nil, sp.Add(Pt(r.Dx(), 0)));	// right
-	Draw(dst, Rect(r.Min.X - i, r.Max.Y, r.Max.X + i, r.Max.Y + i), src, nil, sp.Add(Pt(-i, 0)));	// bottom
+	Draw(dst, Rect(r.Min.X-i, r.Min.Y-i, r.Max.X+i, r.Min.Y), src, nil, sp.Add(Pt(-i, -i)));	// top
+	Draw(dst, Rect(r.Min.X-i, r.Min.Y, r.Min.X, r.Max.Y), src, nil, sp.Add(Pt(-i, 0)));		// left
+	Draw(dst, Rect(r.Max.X, r.Min.Y, r.Max.X+i, r.Max.Y), src, nil, sp.Add(Pt(r.Dx(), 0)));		// right
+	Draw(dst, Rect(r.Min.X-i, r.Max.Y, r.Max.X+i, r.Max.Y+i), src, nil, sp.Add(Pt(-i, 0)));		// bottom
 }
diff --git a/src/pkg/exp/eval/bridge.go b/src/pkg/exp/eval/bridge.go
index 1118ddd089..fed27930f5 100644
--- a/src/pkg/exp/eval/bridge.go
+++ b/src/pkg/exp/eval/bridge.go
@@ -77,7 +77,7 @@ func TypeFromNative(t reflect.Type) Type {
 		// Variadic functions have DotDotDotType at the end
 		varidic := false;
 		if nin > 0 {
-			if _, ok := t.In(nin-1).(*reflect.DotDotDotType); ok {
+			if _, ok := t.In(nin - 1).(*reflect.DotDotDotType); ok {
 				varidic = true;
 				nin--;
 			}
@@ -142,13 +142,11 @@ type nativeFunc struct {
 }
 
 func (f *nativeFunc) NewFrame() *Frame {
-	vars := make([]Value, f.in + f.out);
+	vars := make([]Value, f.in+f.out);
 	return &Frame{nil, vars};
 }
 
-func (f *nativeFunc) Call(t *Thread) {
-	f.fn(t, t.f.Vars[0 : f.in], t.f.Vars[f.in : f.in + f.out])
-}
+func (f *nativeFunc) Call(t *Thread)	{ f.fn(t, t.f.Vars[0:f.in], t.f.Vars[f.in:f.in+f.out]) }
 
 // FuncFromNative creates an interpreter function from a native
 // function that takes its in and out arguments as slices of
diff --git a/src/pkg/exp/eval/eval_test.go b/src/pkg/exp/eval/eval_test.go
index 354ac01984..afd91bfb2c 100644
--- a/src/pkg/exp/eval/eval_test.go
+++ b/src/pkg/exp/eval/eval_test.go
@@ -210,7 +210,7 @@ func (*testFunc) NewFrame() *Frame	{ return &Frame{nil, &[2]Value{}} }
 func (*testFunc) Call(t *Thread) {
 	n := t.f.Vars[0].(IntValue).Get(t);
 
-	res := n+1;
+	res := n + 1;
 
 	t.f.Vars[1].(IntValue).Set(t, res);
 }
diff --git a/src/pkg/exp/eval/expr.go b/src/pkg/exp/eval/expr.go
index d149c284a6..265ba98d2b 100644
--- a/src/pkg/exp/eval/expr.go
+++ b/src/pkg/exp/eval/expr.go
@@ -137,7 +137,7 @@ func (a *expr) convertTo(t Type) *expr {
 		res.eval = func() *bignum.Integer { return f };
 	case *floatType:
 		n, d := rat.Value();
-		v := float64(n.Value())/float64(d.Value());
+		v := float64(n.Value()) / float64(d.Value());
 		res.eval = func(*Thread) float64 { return v };
 	case *idealFloatType:
 		res.eval = func() *bignum.Rational { return rat }
@@ -830,7 +830,7 @@ func (a *exprInfo) compileSelectorExpr(v *expr, name string) *expr {
 		default:
 			log.Crashf("Marked field at depth %d, but already found one at depth %d", depth, bestDepth)
 		}
-		amberr += "\n\t"+pathName[1:len(pathName)];
+		amberr += "\n\t" + pathName[1:len(pathName)];
 	};
 
 	visited := make(map[Type]bool);
@@ -886,7 +886,7 @@ func (a *exprInfo) compileSelectorExpr(v *expr, name string) *expr {
 					sub = func(e *expr) *expr { return e };
 
 				case f.Anonymous:
-					sub = find(f.Type, depth+1, pathName + "." + f.Name);
+					sub = find(f.Type, depth+1, pathName+"."+f.Name);
 					if sub == nil {
 						continue
 					}
@@ -975,7 +975,7 @@ func (a *exprInfo) compileSliceExpr(arr, lo, hi *expr) *expr {
 			if lo > hi || hi > bound || lo < 0 {
 				t.Abort(SliceError{lo, hi, bound})
 			}
-			return Slice{arr.Sub(lo, bound-lo), hi-lo, bound-lo};
+			return Slice{arr.Sub(lo, bound-lo), hi - lo, bound - lo};
 		};
 
 	case *SliceType:
@@ -985,7 +985,7 @@ func (a *exprInfo) compileSliceExpr(arr, lo, hi *expr) *expr {
 			if lo > hi || hi > arr.Cap || lo < 0 {
 				t.Abort(SliceError{lo, hi, arr.Cap})
 			}
-			return Slice{arr.Base.Sub(lo, arr.Cap - lo), hi-lo, arr.Cap - lo};
+			return Slice{arr.Base.Sub(lo, arr.Cap-lo), hi - lo, arr.Cap - lo};
 		};
 
 	case *stringType:
diff --git a/src/pkg/exp/eval/expr1.go b/src/pkg/exp/eval/expr1.go
index c4960abbcb..ed2081c719 100644
--- a/src/pkg/exp/eval/expr1.go
+++ b/src/pkg/exp/eval/expr1.go
@@ -301,35 +301,35 @@ func (a *expr) genBinOpAdd(l, r *expr) {
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l+r;
+				ret = l + r;
 				return uint64(uint8(ret));
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l+r;
+				ret = l + r;
 				return uint64(uint16(ret));
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l+r;
+				ret = l + r;
 				return uint64(uint32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l+r;
+				ret = l + r;
 				return uint64(uint64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l+r;
+				ret = l + r;
 				return uint64(uint(ret));
 			}
 		default:
@@ -343,35 +343,35 @@ func (a *expr) genBinOpAdd(l, r *expr) {
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l+r;
+				ret = l + r;
 				return int64(int8(ret));
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l+r;
+				ret = l + r;
 				return int64(int16(ret));
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l+r;
+				ret = l + r;
 				return int64(int32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l+r;
+				ret = l + r;
 				return int64(int64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l+r;
+				ret = l + r;
 				return int64(int(ret));
 			}
 		default:
@@ -390,21 +390,21 @@ func (a *expr) genBinOpAdd(l, r *expr) {
 			a.eval = func(t *Thread) float64 {
 				l, r := lf(t), rf(t);
 				var ret float64;
-				ret = l+r;
+				ret = l + r;
 				return float64(float32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) float64 {
 				l, r := lf(t), rf(t);
 				var ret float64;
-				ret = l+r;
+				ret = l + r;
 				return float64(float64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) float64 {
 				l, r := lf(t), rf(t);
 				var ret float64;
-				ret = l+r;
+				ret = l + r;
 				return float64(float(ret));
 			}
 		default:
@@ -420,7 +420,7 @@ func (a *expr) genBinOpAdd(l, r *expr) {
 		rf := r.asString();
 		a.eval = func(t *Thread) string {
 			l, r := lf(t), rf(t);
-			return l+r;
+			return l + r;
 		};
 	default:
 		log.Crashf("unexpected type %v at %v", l.t, a.pos)
@@ -437,35 +437,35 @@ func (a *expr) genBinOpSub(l, r *expr) {
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l-r;
+				ret = l - r;
 				return uint64(uint8(ret));
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l-r;
+				ret = l - r;
 				return uint64(uint16(ret));
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l-r;
+				ret = l - r;
 				return uint64(uint32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l-r;
+				ret = l - r;
 				return uint64(uint64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l-r;
+				ret = l - r;
 				return uint64(uint(ret));
 			}
 		default:
@@ -479,35 +479,35 @@ func (a *expr) genBinOpSub(l, r *expr) {
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l-r;
+				ret = l - r;
 				return int64(int8(ret));
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l-r;
+				ret = l - r;
 				return int64(int16(ret));
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l-r;
+				ret = l - r;
 				return int64(int32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l-r;
+				ret = l - r;
 				return int64(int64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l-r;
+				ret = l - r;
 				return int64(int(ret));
 			}
 		default:
@@ -526,21 +526,21 @@ func (a *expr) genBinOpSub(l, r *expr) {
 			a.eval = func(t *Thread) float64 {
 				l, r := lf(t), rf(t);
 				var ret float64;
-				ret = l-r;
+				ret = l - r;
 				return float64(float32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) float64 {
 				l, r := lf(t), rf(t);
 				var ret float64;
-				ret = l-r;
+				ret = l - r;
 				return float64(float64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) float64 {
 				l, r := lf(t), rf(t);
 				var ret float64;
-				ret = l-r;
+				ret = l - r;
 				return float64(float(ret));
 			}
 		default:
@@ -566,35 +566,35 @@ func (a *expr) genBinOpMul(l, r *expr) {
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l*r;
+				ret = l * r;
 				return uint64(uint8(ret));
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l*r;
+				ret = l * r;
 				return uint64(uint16(ret));
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l*r;
+				ret = l * r;
 				return uint64(uint32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l*r;
+				ret = l * r;
 				return uint64(uint64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l*r;
+				ret = l * r;
 				return uint64(uint(ret));
 			}
 		default:
@@ -608,35 +608,35 @@ func (a *expr) genBinOpMul(l, r *expr) {
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l*r;
+				ret = l * r;
 				return int64(int8(ret));
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l*r;
+				ret = l * r;
 				return int64(int16(ret));
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l*r;
+				ret = l * r;
 				return int64(int32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l*r;
+				ret = l * r;
 				return int64(int64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l*r;
+				ret = l * r;
 				return int64(int(ret));
 			}
 		default:
@@ -655,21 +655,21 @@ func (a *expr) genBinOpMul(l, r *expr) {
 			a.eval = func(t *Thread) float64 {
 				l, r := lf(t), rf(t);
 				var ret float64;
-				ret = l*r;
+				ret = l * r;
 				return float64(float32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) float64 {
 				l, r := lf(t), rf(t);
 				var ret float64;
-				ret = l*r;
+				ret = l * r;
 				return float64(float64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) float64 {
 				l, r := lf(t), rf(t);
 				var ret float64;
-				ret = l*r;
+				ret = l * r;
 				return float64(float(ret));
 			}
 		default:
@@ -698,7 +698,7 @@ func (a *expr) genBinOpQuo(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l/r;
+				ret = l / r;
 				return uint64(uint8(ret));
 			}
 		case 16:
@@ -708,7 +708,7 @@ func (a *expr) genBinOpQuo(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l/r;
+				ret = l / r;
 				return uint64(uint16(ret));
 			}
 		case 32:
@@ -718,7 +718,7 @@ func (a *expr) genBinOpQuo(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l/r;
+				ret = l / r;
 				return uint64(uint32(ret));
 			}
 		case 64:
@@ -728,7 +728,7 @@ func (a *expr) genBinOpQuo(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l/r;
+				ret = l / r;
 				return uint64(uint64(ret));
 			}
 		case 0:
@@ -738,7 +738,7 @@ func (a *expr) genBinOpQuo(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l/r;
+				ret = l / r;
 				return uint64(uint(ret));
 			}
 		default:
@@ -755,7 +755,7 @@ func (a *expr) genBinOpQuo(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l/r;
+				ret = l / r;
 				return int64(int8(ret));
 			}
 		case 16:
@@ -765,7 +765,7 @@ func (a *expr) genBinOpQuo(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l/r;
+				ret = l / r;
 				return int64(int16(ret));
 			}
 		case 32:
@@ -775,7 +775,7 @@ func (a *expr) genBinOpQuo(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l/r;
+				ret = l / r;
 				return int64(int32(ret));
 			}
 		case 64:
@@ -785,7 +785,7 @@ func (a *expr) genBinOpQuo(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l/r;
+				ret = l / r;
 				return int64(int64(ret));
 			}
 		case 0:
@@ -795,7 +795,7 @@ func (a *expr) genBinOpQuo(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l/r;
+				ret = l / r;
 				return int64(int(ret));
 			}
 		default:
@@ -817,7 +817,7 @@ func (a *expr) genBinOpQuo(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l/r;
+				ret = l / r;
 				return float64(float32(ret));
 			}
 		case 64:
@@ -827,7 +827,7 @@ func (a *expr) genBinOpQuo(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l/r;
+				ret = l / r;
 				return float64(float64(ret));
 			}
 		case 0:
@@ -837,7 +837,7 @@ func (a *expr) genBinOpQuo(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l/r;
+				ret = l / r;
 				return float64(float(ret));
 			}
 		default:
@@ -866,7 +866,7 @@ func (a *expr) genBinOpRem(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l%r;
+				ret = l % r;
 				return uint64(uint8(ret));
 			}
 		case 16:
@@ -876,7 +876,7 @@ func (a *expr) genBinOpRem(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l%r;
+				ret = l % r;
 				return uint64(uint16(ret));
 			}
 		case 32:
@@ -886,7 +886,7 @@ func (a *expr) genBinOpRem(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l%r;
+				ret = l % r;
 				return uint64(uint32(ret));
 			}
 		case 64:
@@ -896,7 +896,7 @@ func (a *expr) genBinOpRem(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l%r;
+				ret = l % r;
 				return uint64(uint64(ret));
 			}
 		case 0:
@@ -906,7 +906,7 @@ func (a *expr) genBinOpRem(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l%r;
+				ret = l % r;
 				return uint64(uint(ret));
 			}
 		default:
@@ -923,7 +923,7 @@ func (a *expr) genBinOpRem(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l%r;
+				ret = l % r;
 				return int64(int8(ret));
 			}
 		case 16:
@@ -933,7 +933,7 @@ func (a *expr) genBinOpRem(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l%r;
+				ret = l % r;
 				return int64(int16(ret));
 			}
 		case 32:
@@ -943,7 +943,7 @@ func (a *expr) genBinOpRem(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l%r;
+				ret = l % r;
 				return int64(int32(ret));
 			}
 		case 64:
@@ -953,7 +953,7 @@ func (a *expr) genBinOpRem(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l%r;
+				ret = l % r;
 				return int64(int64(ret));
 			}
 		case 0:
@@ -963,7 +963,7 @@ func (a *expr) genBinOpRem(l, r *expr) {
 				if r == 0 {
 					t.Abort(DivByZeroError{})
 				}
-				ret = l%r;
+				ret = l % r;
 				return int64(int(ret));
 			}
 		default:
@@ -989,35 +989,35 @@ func (a *expr) genBinOpAnd(l, r *expr) {
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l&r;
+				ret = l & r;
 				return uint64(uint8(ret));
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l&r;
+				ret = l & r;
 				return uint64(uint16(ret));
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l&r;
+				ret = l & r;
 				return uint64(uint32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l&r;
+				ret = l & r;
 				return uint64(uint64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l&r;
+				ret = l & r;
 				return uint64(uint(ret));
 			}
 		default:
@@ -1031,35 +1031,35 @@ func (a *expr) genBinOpAnd(l, r *expr) {
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l&r;
+				ret = l & r;
 				return int64(int8(ret));
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l&r;
+				ret = l & r;
 				return int64(int16(ret));
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l&r;
+				ret = l & r;
 				return int64(int32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l&r;
+				ret = l & r;
 				return int64(int64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l&r;
+				ret = l & r;
 				return int64(int(ret));
 			}
 		default:
@@ -1085,35 +1085,35 @@ func (a *expr) genBinOpOr(l, r *expr) {
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l|r;
+				ret = l | r;
 				return uint64(uint8(ret));
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l|r;
+				ret = l | r;
 				return uint64(uint16(ret));
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l|r;
+				ret = l | r;
 				return uint64(uint32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l|r;
+				ret = l | r;
 				return uint64(uint64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l|r;
+				ret = l | r;
 				return uint64(uint(ret));
 			}
 		default:
@@ -1127,35 +1127,35 @@ func (a *expr) genBinOpOr(l, r *expr) {
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l|r;
+				ret = l | r;
 				return int64(int8(ret));
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l|r;
+				ret = l | r;
 				return int64(int16(ret));
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l|r;
+				ret = l | r;
 				return int64(int32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l|r;
+				ret = l | r;
 				return int64(int64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l|r;
+				ret = l | r;
 				return int64(int(ret));
 			}
 		default:
@@ -1181,35 +1181,35 @@ func (a *expr) genBinOpXor(l, r *expr) {
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l^r;
+				ret = l ^ r;
 				return uint64(uint8(ret));
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l^r;
+				ret = l ^ r;
 				return uint64(uint16(ret));
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l^r;
+				ret = l ^ r;
 				return uint64(uint32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l^r;
+				ret = l ^ r;
 				return uint64(uint64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l^r;
+				ret = l ^ r;
 				return uint64(uint(ret));
 			}
 		default:
@@ -1223,35 +1223,35 @@ func (a *expr) genBinOpXor(l, r *expr) {
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l^r;
+				ret = l ^ r;
 				return int64(int8(ret));
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l^r;
+				ret = l ^ r;
 				return int64(int16(ret));
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l^r;
+				ret = l ^ r;
 				return int64(int32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l^r;
+				ret = l ^ r;
 				return int64(int64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l^r;
+				ret = l ^ r;
 				return int64(int(ret));
 			}
 		default:
@@ -1277,35 +1277,35 @@ func (a *expr) genBinOpAndNot(l, r *expr) {
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l&^r;
+				ret = l &^ r;
 				return uint64(uint8(ret));
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l&^r;
+				ret = l &^ r;
 				return uint64(uint16(ret));
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l&^r;
+				ret = l &^ r;
 				return uint64(uint32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l&^r;
+				ret = l &^ r;
 				return uint64(uint64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l&^r;
+				ret = l &^ r;
 				return uint64(uint(ret));
 			}
 		default:
@@ -1319,35 +1319,35 @@ func (a *expr) genBinOpAndNot(l, r *expr) {
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l&^r;
+				ret = l &^ r;
 				return int64(int8(ret));
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l&^r;
+				ret = l &^ r;
 				return int64(int16(ret));
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l&^r;
+				ret = l &^ r;
 				return int64(int32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l&^r;
+				ret = l &^ r;
 				return int64(int64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l&^r;
+				ret = l &^ r;
 				return int64(int(ret));
 			}
 		default:
@@ -1373,35 +1373,35 @@ func (a *expr) genBinOpShl(l, r *expr) {
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l<<r;
+				ret = l << r;
 				return uint64(uint8(ret));
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l<<r;
+				ret = l << r;
 				return uint64(uint16(ret));
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l<<r;
+				ret = l << r;
 				return uint64(uint32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l<<r;
+				ret = l << r;
 				return uint64(uint64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l<<r;
+				ret = l << r;
 				return uint64(uint(ret));
 			}
 		default:
@@ -1415,35 +1415,35 @@ func (a *expr) genBinOpShl(l, r *expr) {
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l<<r;
+				ret = l << r;
 				return int64(int8(ret));
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l<<r;
+				ret = l << r;
 				return int64(int16(ret));
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l<<r;
+				ret = l << r;
 				return int64(int32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l<<r;
+				ret = l << r;
 				return int64(int64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l<<r;
+				ret = l << r;
 				return int64(int(ret));
 			}
 		default:
@@ -1464,35 +1464,35 @@ func (a *expr) genBinOpShr(l, r *expr) {
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l>>r;
+				ret = l >> r;
 				return uint64(uint8(ret));
 			}
 		case 16:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l>>r;
+				ret = l >> r;
 				return uint64(uint16(ret));
 			}
 		case 32:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l>>r;
+				ret = l >> r;
 				return uint64(uint32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l>>r;
+				ret = l >> r;
 				return uint64(uint64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) uint64 {
 				l, r := lf(t), rf(t);
 				var ret uint64;
-				ret = l>>r;
+				ret = l >> r;
 				return uint64(uint(ret));
 			}
 		default:
@@ -1506,35 +1506,35 @@ func (a *expr) genBinOpShr(l, r *expr) {
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l>>r;
+				ret = l >> r;
 				return int64(int8(ret));
 			}
 		case 16:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l>>r;
+				ret = l >> r;
 				return int64(int16(ret));
 			}
 		case 32:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l>>r;
+				ret = l >> r;
 				return int64(int32(ret));
 			}
 		case 64:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l>>r;
+				ret = l >> r;
 				return int64(int64(ret));
 			}
 		case 0:
 			a.eval = func(t *Thread) int64 {
 				l, r := lf(t), rf(t);
 				var ret int64;
-				ret = l>>r;
+				ret = l >> r;
 				return int64(int(ret));
 			}
 		default:
diff --git a/src/pkg/exp/eval/expr_test.go b/src/pkg/exp/eval/expr_test.go
index 31ed530be6..4d3e2776a1 100644
--- a/src/pkg/exp/eval/expr_test.go
+++ b/src/pkg/exp/eval/expr_test.go
@@ -230,13 +230,13 @@ var exprTests = []test{
 	Val("2<<u", 2<<1),
 	CErr("2<<f", opTypes),
 
-	Val("-2<<2", bignum.Int(-2 << 2)),
+	Val("-2<<2", bignum.Int(-2<<2)),
 	CErr("-2<<(-1)", constantUnderflows),
 	CErr("-2<<0x10000000000000000", constantOverflows),
 	CErr("-2<<2.5", constantTruncated),
-	Val("-2<<2.0", bignum.Int(-2 << 2.0)),
+	Val("-2<<2.0", bignum.Int(-2<<2.0)),
 	CErr("-2<<i", mustBeUnsigned),
-	Val("-2<<u", -2 << 1),
+	Val("-2<<u", -2<<1),
 	CErr("-2<<f", opTypes),
 
 	Val("0x10000000000000000<<2", hugeInteger.Shl(2)),
diff --git a/src/pkg/exp/eval/scope.go b/src/pkg/exp/eval/scope.go
index e67135c0c0..971b92d53c 100644
--- a/src/pkg/exp/eval/scope.go
+++ b/src/pkg/exp/eval/scope.go
@@ -132,7 +132,7 @@ func (b *block) defineSlot(t Type, temp bool) *Variable {
 		index = b.offset + b.numVars;
 		b.numVars++;
 		if index >= b.scope.maxVars {
-			b.scope.maxVars = index+1
+			b.scope.maxVars = index + 1
 		}
 	}
 	v := &Variable{token.Position{}, index, t, nil};
diff --git a/src/pkg/exp/eval/stmt.go b/src/pkg/exp/eval/stmt.go
index 8820826eb0..815a149f62 100644
--- a/src/pkg/exp/eval/stmt.go
+++ b/src/pkg/exp/eval/stmt.go
@@ -846,7 +846,7 @@ func (a *stmtCompiler) compileReturnStmt(s *ast.ReturnStmt) {
 	nout := len(a.fnType.Out);
 	a.flow.putTerm();
 	a.push(func(t *Thread) {
-		assign(multiV(t.f.Vars[start : start+nout]), t);
+		assign(multiV(t.f.Vars[start:start+nout]), t);
 		t.pc = returnPC;
 	});
 }
diff --git a/src/pkg/exp/eval/type.go b/src/pkg/exp/eval/type.go
index f63220a6b8..47e2285238 100644
--- a/src/pkg/exp/eval/type.go
+++ b/src/pkg/exp/eval/type.go
@@ -82,7 +82,7 @@ type typeArrayMap map[uintptr]*typeArrayMapEntry
 func hashTypeArray(key []Type) uintptr {
 	hash := uintptr(0);
 	for _, t := range key {
-		hash = hash*33;
+		hash = hash * 33;
 		if t == nil {
 			continue
 		}
@@ -631,7 +631,7 @@ func (t *StructType) String() string {
 		}
 		s += f.Type.String();
 	}
-	return s+"}";
+	return s + "}";
 }
 
 func (t *StructType) Zero() Value {
@@ -788,7 +788,7 @@ func (t *FuncType) String() string {
 		}
 		args += "...";
 	}
-	s := "func("+args+")";
+	s := "func(" + args + ")";
 	if len(t.Out) > 0 {
 		s += " (" + typeListString(t.Out, nil) + ")"
 	}
@@ -937,7 +937,7 @@ func (t *InterfaceType) String() string {
 		}
 		s += m.Name + funcTypeString(m.Type, nil, nil);
 	}
-	return s+"}";
+	return s + "}";
 }
 
 // implementedBy tests if o implements t, returning nil, true if it does.
diff --git a/src/pkg/exp/eval/value.go b/src/pkg/exp/eval/value.go
index 4956cf33a6..3f823bb3ed 100644
--- a/src/pkg/exp/eval/value.go
+++ b/src/pkg/exp/eval/value.go
@@ -361,7 +361,7 @@ func (v *arrayV) String() string {
 		}
 		res += e.String();
 	}
-	return res+"}";
+	return res + "}";
 }
 
 func (v *arrayV) Assign(t *Thread, o Value) {
@@ -399,7 +399,7 @@ func (v *structV) String() string {
 		}
 		res += v.String();
 	}
-	return res+"}";
+	return res + "}";
 }
 
 func (v *structV) Assign(t *Thread, o Value) {
@@ -525,7 +525,7 @@ func (v *mapV) String() string {
 		res += fmt.Sprint(key) + ":" + val.String();
 		return true;
 	});
-	return res+"]";
+	return res + "]";
 }
 
 func (v *mapV) Assign(t *Thread, o Value)	{ v.target = o.(MapValue).Get(t) }
@@ -575,7 +575,7 @@ func (v multiV) String() string {
 		}
 		res += v.String();
 	}
-	return res+")";
+	return res + ")";
 }
 
 func (v multiV) Assign(t *Thread, o Value) {
diff --git a/src/pkg/exp/iterable/iterable_test.go b/src/pkg/exp/iterable/iterable_test.go
index bb22334f9e..1580357eeb 100644
--- a/src/pkg/exp/iterable/iterable_test.go
+++ b/src/pkg/exp/iterable/iterable_test.go
@@ -26,7 +26,7 @@ var oneToFive = IntArray{1, 2, 3, 4, 5}
 func isNegative(n interface{}) bool	{ return n.(int) < 0 }
 func isPositive(n interface{}) bool	{ return n.(int) > 0 }
 func isAbove3(n interface{}) bool	{ return n.(int) > 3 }
-func isEven(n interface{}) bool		{ return n.(int) % 2 == 0 }
+func isEven(n interface{}) bool		{ return n.(int)%2 == 0 }
 func doubler(n interface{}) interface{}	{ return n.(int) * 2 }
 func addOne(n interface{}) interface{}	{ return n.(int) + 1 }
 func adder(acc interface{}, n interface{}) interface{} {
diff --git a/src/pkg/exp/nacl/av/av.go b/src/pkg/exp/nacl/av/av.go
index 26844c84f5..b7cb805a7e 100644
--- a/src/pkg/exp/nacl/av/av.go
+++ b/src/pkg/exp/nacl/av/av.go
@@ -27,7 +27,7 @@ var srpcEnabled = srpc.Enabled()
 
 // Subsystem values for Init.
 const (
-	SubsystemVideo	= 1<<iota;
+	SubsystemVideo	= 1 << iota;
 	SubsystemAudio;
 	SubsystemEmbed;
 )
@@ -84,7 +84,7 @@ func Init(subsys int, dx, dy int) (*Window, os.Error) {
 		xsubsys &^= SubsystemVideo | SubsystemEmbed;
 	}
 
-	if xsubsys & SubsystemEmbed != 0 {
+	if xsubsys&SubsystemEmbed != 0 {
 		return nil, os.NewError("not embedded")
 	}
 
@@ -94,7 +94,7 @@ func Init(subsys int, dx, dy int) (*Window, os.Error) {
 		return nil, err
 	}
 
-	if subsys & SubsystemVideo != 0 {
+	if subsys&SubsystemVideo != 0 {
 		if dx, dy, err = videoInit(dx, dy); err != nil {
 			return nil, err
 		}
@@ -105,7 +105,7 @@ func Init(subsys int, dx, dy int) (*Window, os.Error) {
 		w.quitc = make(chan bool);
 	}
 
-	if subsys & SubsystemAudio != 0 {
+	if subsys&SubsystemAudio != 0 {
 		var n int;
 		if n, err = audioInit(AudioFormatStereo44K, 2048); err != nil {
 			return nil, err
@@ -113,7 +113,7 @@ func Init(subsys int, dx, dy int) (*Window, os.Error) {
 		println("audio", n);
 	}
 
-	if subsys & SubsystemVideo != 0 {
+	if subsys&SubsystemVideo != 0 {
 		go w.readEvents()
 	}
 
@@ -159,7 +159,7 @@ func videoPollEvent(ev []byte) (err os.Error) {
 			return noEvents
 		}
 		bytes.Copy(ev, &bridge.share.eq.event[r]);
-		bridge.share.eq.ri = (r+1)%eqsize;
+		bridge.share.eq.ri = (r + 1) % eqsize;
 		return nil;
 	}
 	return os.NewSyscallError("video_poll_event", syscall.VideoPollEvent(&ev[0]));
@@ -242,7 +242,7 @@ type videoShare struct {
 
 // The frame buffer data is videoShareSize bytes after
 // the videoShare begins.
-const videoShareSize = 16*1024
+const videoShareSize = 16 * 1024
 
 type multimediaBridge struct{}
 
@@ -261,7 +261,7 @@ func (multimediaBridge) Run(arg, ret []interface{}, size []int) srpc.Errno {
 	addr, _, errno := syscall.Syscall6(syscall.SYS_MMAP,
 		0,
 		uintptr(st.Size),
-		syscall.PROT_READ | syscall.PROT_WRITE,
+		syscall.PROT_READ|syscall.PROT_WRITE,
 		syscall.MAP_SHARED,
 		uintptr(bridge.displayFd),
 		0);
@@ -274,8 +274,8 @@ func (multimediaBridge) Run(arg, ret []interface{}, size []int) srpc.Errno {
 	// Overestimate frame buffer size
 	// (must use a compile-time constant)
 	// and then reslice.  256 megapixels (1 GB) should be enough.
-	fb := (*[256*1024*1024]Color)(unsafe.Pointer(addr + videoShareSize));
-	bridge.pixel = fb[0 : (st.Size - videoShareSize)/4];
+	fb := (*[256 * 1024 * 1024]Color)(unsafe.Pointer(addr + videoShareSize));
+	bridge.pixel = fb[0 : (st.Size-videoShareSize)/4];
 
 	// Configure RPC connection back to client.
 	var err os.Error;
diff --git a/src/pkg/exp/nacl/av/event.go b/src/pkg/exp/nacl/av/event.go
index 1412153cf0..3b9a0e4d9d 100644
--- a/src/pkg/exp/nacl/av/event.go
+++ b/src/pkg/exp/nacl/av/event.go
@@ -22,7 +22,7 @@ import (
 type eventType uint8
 
 const (
-	eventActive	= 1+iota;
+	eventActive	= 1 + iota;
 	eventExpose;
 	eventKeyDown;
 	eventKeyUp;
@@ -456,14 +456,14 @@ func (w *Window) readEvents() {
 			m.X = int(mbe.X);
 			m.Y = int(mbe.Y);
 			// TODO(rsc): Remove uint cast once 8g bug is fixed.
-			m.Buttons |= 1<<uint(mbe.Button - 1);
+			m.Buttons |= 1 << uint(mbe.Button-1);
 			m.Nsec = time.Nanoseconds();
 			_ = w.mousec <- m;
 		case eventMouseButtonUp:
 			m.X = int(mbe.X);
 			m.Y = int(mbe.Y);
 			// TODO(rsc): Remove uint cast once 8g bug is fixed.
-			m.Buttons &^= 1<<uint(mbe.Button - 1);
+			m.Buttons &^= 1 << uint(mbe.Button-1);
 			m.Nsec = time.Nanoseconds();
 			_ = w.mousec <- m;
 		case eventQuit:
diff --git a/src/pkg/exp/nacl/av/image.go b/src/pkg/exp/nacl/av/image.go
index 0c6099ee3d..8e096d1655 100644
--- a/src/pkg/exp/nacl/av/image.go
+++ b/src/pkg/exp/nacl/av/image.go
@@ -59,18 +59,18 @@ type Color uint32
 
 func (p Color) RGBA() (r, g, b, a uint32) {
 	x := uint32(p);
-	a = x>>24;
-	a |= a<<8;
-	a |= a<<16;
-	r = (x>>16)&0xFF;
-	r |= r<<8;
-	r |= r<<16;
-	g = (x>>8)&0xFF;
-	g |= g<<8;
-	g |= g<<16;
-	b = x&0xFF;
-	b |= b<<8;
-	b |= b<<16;
+	a = x >> 24;
+	a |= a << 8;
+	a |= a << 16;
+	r = (x >> 16) & 0xFF;
+	r |= r << 8;
+	r |= r << 16;
+	g = (x >> 8) & 0xFF;
+	g |= g << 8;
+	g |= g << 16;
+	b = x & 0xFF;
+	b |= b << 8;
+	b |= b << 16;
 	return;
 }
 
diff --git a/src/pkg/exp/nacl/srpc/client.go b/src/pkg/exp/nacl/srpc/client.go
index 251f501615..f0daa0d43c 100644
--- a/src/pkg/exp/nacl/srpc/client.go
+++ b/src/pkg/exp/nacl/srpc/client.go
@@ -172,22 +172,22 @@ func (r *RPC) Start(name string, arg []interface{}) {
 			m.Ret[i] = false
 		case 'C':
 			m.Ret[i] = []byte(nil);
-			m.Size[i] = 1<<30;
+			m.Size[i] = 1 << 30;
 		case 'd':
 			m.Ret[i] = float64(0)
 		case 'D':
 			m.Ret[i] = []float64(nil);
-			m.Size[i] = 1<<30;
+			m.Size[i] = 1 << 30;
 		case 'h':
 			m.Ret[i] = int(-1)
 		case 'i':
 			m.Ret[i] = int32(0)
 		case 'I':
 			m.Ret[i] = []int32(nil);
-			m.Size[i] = 1<<30;
+			m.Size[i] = 1 << 30;
 		case 's':
 			m.Ret[i] = "";
-			m.Size[i] = 1<<30;
+			m.Size[i] = 1 << 30;
 		}
 	}
 
diff --git a/src/pkg/exp/nacl/srpc/msg.go b/src/pkg/exp/nacl/srpc/msg.go
index f158b13856..4370295927 100644
--- a/src/pkg/exp/nacl/srpc/msg.go
+++ b/src/pkg/exp/nacl/srpc/msg.go
@@ -19,7 +19,7 @@ import (
 type Errno uint32
 
 const (
-	OK	Errno	= 256+iota;
+	OK	Errno	= 256 + iota;
 	ErrBreak;
 	ErrMessageTruncated;
 	ErrNoMemory;
@@ -35,8 +35,8 @@ const (
 )
 
 var errstr = [...]string{
-	OK-OK: "ok",
-	ErrBreak-OK: "break",
+	OK - OK: "ok",
+	ErrBreak - OK: "break",
 	ErrMessageTruncated - OK: "message truncated",
 	ErrNoMemory - OK: "out of memory",
 	ErrProtocolMismatch - OK: "protocol mismatch",
@@ -97,7 +97,7 @@ type msg struct {
 // A msgReceiver receives messages from a file descriptor.
 type msgReceiver struct {
 	fd	int;
-	data	[128*1024]byte;
+	data	[128 * 1024]byte;
 	desc	[8]int32;
 	hdr	msgHdr;
 	iov	iov;
@@ -196,7 +196,7 @@ func (m *msg) uint64() uint64 {
 	}
 	b := m.rdata[0:8];
 	x := uint64(uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24);
-	x |= uint64(uint32(b[4]) | uint32(b[5])<<8 | uint32(b[6])<<16 | uint32(b[7])<<24)<<32;
+	x |= uint64(uint32(b[4])|uint32(b[5])<<8|uint32(b[6])<<16|uint32(b[7])<<24) << 32;
 	m.rdata = m.rdata[8:len(m.rdata)];
 	return x;
 }
@@ -231,23 +231,23 @@ func (m *msg) wuint8(x uint8)	{ m.grow(1)[0] = x }
 func (m *msg) wuint32(x uint32) {
 	b := m.grow(4);
 	b[0] = byte(x);
-	b[1] = byte(x>>8);
-	b[2] = byte(x>>16);
-	b[3] = byte(x>>24);
+	b[1] = byte(x >> 8);
+	b[2] = byte(x >> 16);
+	b[3] = byte(x >> 24);
 }
 
 func (m *msg) wuint64(x uint64) {
 	b := m.grow(8);
 	lo := uint32(x);
 	b[0] = byte(lo);
-	b[1] = byte(lo>>8);
-	b[2] = byte(lo>>16);
-	b[3] = byte(lo>>24);
-	hi := uint32(x>>32);
+	b[1] = byte(lo >> 8);
+	b[2] = byte(lo >> 16);
+	b[3] = byte(lo >> 24);
+	hi := uint32(x >> 32);
 	b[4] = byte(hi);
-	b[5] = byte(hi>>8);
-	b[6] = byte(hi>>16);
-	b[7] = byte(hi>>24);
+	b[5] = byte(hi >> 8);
+	b[6] = byte(hi >> 16);
+	b[7] = byte(hi >> 24);
 }
 
 func (m *msg) wbytes(p []byte)	{ bytes.Copy(m.grow(len(p)), p) }
diff --git a/src/pkg/exp/ogle/arch.go b/src/pkg/exp/ogle/arch.go
index 5208a2a01c..867ad4ca69 100644
--- a/src/pkg/exp/ogle/arch.go
+++ b/src/pkg/exp/ogle/arch.go
@@ -56,7 +56,7 @@ type ArchLSB struct{}
 func (ArchLSB) ToWord(data []byte) proc.Word {
 	var v proc.Word;
 	for i, b := range data {
-		v |= proc.Word(b) << (uint(i)*8)
+		v |= proc.Word(b) << (uint(i) * 8)
 	}
 	return v;
 }
@@ -83,7 +83,7 @@ func (ArchLSB) FromFloat64(f float64) uint64	{ return math.Float64bits(f) }
 type ArchAlignedMultiple struct{}
 
 func (ArchAlignedMultiple) Align(offset, width int) int {
-	return ((offset-1)|(width-1))+1
+	return ((offset - 1) | (width - 1)) + 1
 }
 
 type amd64 struct {
diff --git a/src/pkg/exp/ogle/cmd.go b/src/pkg/exp/ogle/cmd.go
index fb01c92cc6..5ea2752e9b 100644
--- a/src/pkg/exp/ogle/cmd.go
+++ b/src/pkg/exp/ogle/cmd.go
@@ -102,7 +102,7 @@ func getCmd(line []byte) (*cmd, []byte) {
 	slit := string(lit);
 	for i := range cmds {
 		if cmds[i].cmd == slit {
-			return &cmds[i], line[pos.Offset + len(lit) : len(line)]
+			return &cmds[i], line[pos.Offset+len(lit) : len(line)]
 		}
 	}
 	return nil, nil;
diff --git a/src/pkg/exp/ogle/event.go b/src/pkg/exp/ogle/event.go
index dc7ae918b3..18f547915f 100644
--- a/src/pkg/exp/ogle/event.go
+++ b/src/pkg/exp/ogle/event.go
@@ -124,7 +124,7 @@ func (h *commonHook) handle(e Event) (EventAction, os.Error) {
 			continue
 		}
 		a, err := l.eh(e);
-		if a & EARemoveSelf == EARemoveSelf {
+		if a&EARemoveSelf == EARemoveSelf {
 			if !l.internal {
 				h.len--
 			}
diff --git a/src/pkg/exp/ogle/frame.go b/src/pkg/exp/ogle/frame.go
index 22fe0552e9..6c93f27c71 100644
--- a/src/pkg/exp/ogle/frame.go
+++ b/src/pkg/exp/ogle/frame.go
@@ -134,7 +134,7 @@ func prepareFrame(a aborter, pc, sp proc.Word, stk remoteStruct, inner *Frame) *
 		spdelta, ok := p.ParseClosure(buf);
 		if ok {
 			sp += proc.Word(spdelta);
-			pc = p.peekUintptr(a, sp - proc.Word(p.PtrSize()));
+			pc = p.peekUintptr(a, sp-proc.Word(p.PtrSize()));
 		}
 	}
 	if fn == nil {
@@ -188,7 +188,7 @@ func (f *Frame) aOuter(a aborter) *Frame {
 		sp += proc.Word(2 * p.PtrSize())
 	}
 
-	pc := p.peekUintptr(a, f.fp - proc.Word(p.PtrSize()));
+	pc := p.peekUintptr(a, f.fp-proc.Word(p.PtrSize()));
 	if pc < 0x1000 {
 		return nil
 	}
@@ -206,7 +206,7 @@ func (f *Frame) Inner() *Frame	{ return f.inner }
 func (f *Frame) String() string {
 	res := f.fn.Name;
 	if f.pc > proc.Word(f.fn.Value) {
-		res += fmt.Sprintf("+%#x", f.pc - proc.Word(f.fn.Entry))
+		res += fmt.Sprintf("+%#x", f.pc-proc.Word(f.fn.Entry))
 	}
 	return res + fmt.Sprintf(" %s:%d", f.path, f.line);
 }
diff --git a/src/pkg/exp/ogle/process.go b/src/pkg/exp/ogle/process.go
index 3a2954f618..6806d69732 100644
--- a/src/pkg/exp/ogle/process.go
+++ b/src/pkg/exp/ogle/process.go
@@ -391,7 +391,7 @@ func (p *Process) causesToEvents() ([]Event, os.Error) {
 // be processed before any currently pending events.
 func (p *Process) postEvent(ev Event) {
 	n := len(p.posted);
-	m := n*2;
+	m := n * 2;
 	if m == 0 {
 		m = 4
 	}
diff --git a/src/pkg/exp/ogle/rruntime.go b/src/pkg/exp/ogle/rruntime.go
index c9e695b247..9b08a6a2f8 100644
--- a/src/pkg/exp/ogle/rruntime.go
+++ b/src/pkg/exp/ogle/rruntime.go
@@ -254,7 +254,7 @@ func fillRuntimeIndexes(runtime *runtimeValues, out *runtimeIndexes) {
 			}
 			name := f.Name;
 			if name[0] >= 'a' && name[0] <= 'z' {
-				name = string(name[0]+'A'-'a')+name[1:len(name)]
+				name = string(name[0]+'A'-'a') + name[1:len(name)]
 			}
 			indexes[name] = j;
 		}
diff --git a/src/pkg/exp/ogle/rtype.go b/src/pkg/exp/ogle/rtype.go
index 74eb9ab15e..8814792ef3 100644
--- a/src/pkg/exp/ogle/rtype.go
+++ b/src/pkg/exp/ogle/rtype.go
@@ -57,7 +57,7 @@ func newManualType(t eval.Type, arch Arch) *remoteType {
 		basicType(eval.Int16Type, mkInt16, 2, 0);
 		basicType(eval.Int32Type, mkInt32, 4, 0);
 		basicType(eval.IntType, mkInt, arch.IntSize(), 0);
-		basicType(eval.StringType, mkString, arch.PtrSize() + arch.IntSize(), arch.PtrSize());
+		basicType(eval.StringType, mkString, arch.PtrSize()+arch.IntSize(), arch.PtrSize());
 	}
 
 	if rt, ok := typeMap[t]; ok {
@@ -83,7 +83,7 @@ func newManualType(t eval.Type, arch Arch) *remoteType {
 	case *eval.SliceType:
 		elem := newManualType(t.Elem, arch);
 		mk := func(r remote) eval.Value { return remoteSlice{r, elem} };
-		rt = &remoteType{t, arch.PtrSize() + 2 * arch.IntSize(), arch.PtrSize(), mk};
+		rt = &remoteType{t, arch.PtrSize() + 2*arch.IntSize(), arch.PtrSize(), mk};
 
 	case *eval.StructType:
 		layout := make([]remoteStructField, len(t.Elems));
diff --git a/src/pkg/exp/ogle/rvalue.go b/src/pkg/exp/ogle/rvalue.go
index ebd6a6f22f..ac5ec2be39 100644
--- a/src/pkg/exp/ogle/rvalue.go
+++ b/src/pkg/exp/ogle/rvalue.go
@@ -323,7 +323,7 @@ func (v remoteArray) String() string {
 		}
 		res += v.elem(i).String();
 	}
-	return res+"}";
+	return res + "}";
 }
 
 func (v remoteArray) Assign(t *eval.Thread, o eval.Value) {
@@ -344,11 +344,11 @@ func (v remoteArray) Elem(t *eval.Thread, i int64) eval.Value {
 }
 
 func (v remoteArray) elem(i int64) eval.Value {
-	return v.elemType.mk(v.r.plus(proc.Word(int64(v.elemType.size)*i)))
+	return v.elemType.mk(v.r.plus(proc.Word(int64(v.elemType.size) * i)))
 }
 
 func (v remoteArray) Sub(i int64, len int64) eval.ArrayValue {
-	return remoteArray{v.r.plus(proc.Word(int64(v.elemType.size)*i)), len, v.elemType}
+	return remoteArray{v.r.plus(proc.Word(int64(v.elemType.size) * i)), len, v.elemType}
 }
 
 /*
@@ -373,7 +373,7 @@ func (v remoteStruct) String() string {
 		}
 		res += v.field(i).String();
 	}
-	return res+"}";
+	return res + "}";
 }
 
 func (v remoteStruct) Assign(t *eval.Thread, o eval.Value) {
diff --git a/src/pkg/exp/ogle/vars.go b/src/pkg/exp/ogle/vars.go
index b881c0ade4..7ceeb5101f 100644
--- a/src/pkg/exp/ogle/vars.go
+++ b/src/pkg/exp/ogle/vars.go
@@ -217,7 +217,7 @@ func (p *Process) typeOfSym(s *gosym.Sym) (*remoteType, os.Error) {
 // The offsets in this struct type are such that the struct can be
 // instantiated at this function's frame pointer.
 func (p *Process) makeFrameType(s *gosym.Func) (*remoteType, os.Error) {
-	n := len(s.Params)+len(s.Locals);
+	n := len(s.Params) + len(s.Locals);
 	fields := make([]eval.StructField, n);
 	layout := make([]remoteStructField, n);
 	i := 0;
diff --git a/src/pkg/exp/spacewar/pdp1.go b/src/pkg/exp/spacewar/pdp1.go
index 3d9dfeb125..5316841731 100644
--- a/src/pkg/exp/spacewar/pdp1.go
+++ b/src/pkg/exp/spacewar/pdp1.go
@@ -133,7 +133,7 @@ func (m *M) Step(t Trapper) os.Error {
 // Normalize actual 32-bit integer i to 18-bit ones-complement integer.
 // Interpret mod 0777777, because 0777777 == -0 == +0 == 0000000.
 func norm(i Word) Word {
-	i += i>>18;
+	i += i >> 18;
 	i &= mask;
 	if i == mask {
 		i = 0
@@ -162,13 +162,13 @@ func (e LoopError) String() string	{ return fmt.Sprintf("indirect load looping a
 
 func (m *M) run(inst Word, t Trapper) os.Error {
 	ib, y := (inst>>12)&1, inst&07777;
-	op := inst>>13;
+	op := inst >> 13;
 	if op < opSKP && op != opCALJDA {
 		for n := 0; ib != 0; n++ {
 			if n > 07777 {
 				return LoopError(m.PC - 1)
 			}
-			ib = (m.Mem[y] >> 12)&1;
+			ib = (m.Mem[y] >> 12) & 1;
 			y = m.Mem[y] & 07777;
 		}
 	}
@@ -189,7 +189,7 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 		}
 		m.Mem[a] = m.AC;
 		m.AC = (m.OV << 17) + m.PC;
-		m.PC = a+1;
+		m.PC = a + 1;
 	case opLAC:
 		m.AC = m.Mem[y]
 	case opLIO:
@@ -197,7 +197,7 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 	case opDAC:
 		m.Mem[y] = m.AC
 	case opDAP:
-		m.Mem[y] = m.Mem[y] & 0770000 | m.AC & 07777
+		m.Mem[y] = m.Mem[y]&0770000 | m.AC&07777
 	case opDIO:
 		m.Mem[y] = m.IO
 	case opDZM:
@@ -207,10 +207,10 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 		m.OV = m.AC >> 18;
 		m.AC = norm(m.AC);
 	case opSUB:
-		diffSigns := (m.AC ^ m.Mem[y])>>17 == 1;
+		diffSigns := (m.AC^m.Mem[y])>>17 == 1;
 		m.AC += m.Mem[y] ^ mask;
 		m.AC = norm(m.AC);
-		if diffSigns && m.Mem[y] >> 17 == m.AC >> 17 {
+		if diffSigns && m.Mem[y]>>17 == m.AC>>17 {
 			m.OV = 1
 		}
 	case opIDX:
@@ -219,7 +219,7 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 	case opISP:
 		m.AC = norm(m.Mem[y] + 1);
 		m.Mem[y] = m.AC;
-		if m.AC & sign == 0 {
+		if m.AC&sign == 0 {
 			m.PC++
 		}
 	case opSAD:
@@ -231,16 +231,16 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 			m.PC++
 		}
 	case opMUS:
-		if m.IO & 1 == 1 {
+		if m.IO&1 == 1 {
 			m.AC += m.Mem[y];
 			m.AC = norm(m.AC);
 		}
-		m.IO = (m.IO >> 1 | m.AC << 17)&mask;
+		m.IO = (m.IO>>1 | m.AC<<17) & mask;
 		m.AC >>= 1;
 	case opDIS:
-		m.AC, m.IO = (m.AC << 1 | m.IO >> 17)&mask,
-			((m.IO << 1 | m.AC >> 17)&mask)^1;
-		if m.IO & 1 == 1 {
+		m.AC, m.IO = (m.AC<<1|m.IO>>17)&mask,
+			((m.IO<<1|m.AC>>17)&mask)^1;
+		if m.IO&1 == 1 {
 			m.AC = m.AC + (m.Mem[y] ^ mask)
 		} else {
 			m.AC = m.AC + 1 + m.Mem[y]
@@ -253,10 +253,10 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 		m.PC = y;
 	case opSKP:
 		cond := y&0100 == 0100 && m.AC == 0 ||
-			y&0200 == 0200 && m.AC >> 17 == 0 ||
-			y&0400 == 0400 && m.AC >> 17 == 1 ||
+			y&0200 == 0200 && m.AC>>17 == 0 ||
+			y&0400 == 0400 && m.AC>>17 == 1 ||
 			y&01000 == 01000 && m.OV == 0 ||
-			y&02000 == 02000 && m.IO >> 17 == 0 ||
+			y&02000 == 02000 && m.IO>>17 == 0 ||
 			y&7 != 0 && !m.Flag[y&7] ||
 			y&070 != 0 && !m.Sense[(y&070)>>3] ||
 			y&070 == 010;
@@ -267,47 +267,47 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 			m.OV = 0
 		}
 	case opSFT:
-		for count := inst&0777; count != 0; count >>= 1 {
+		for count := inst & 0777; count != 0; count >>= 1 {
 			if count&1 == 0 {
 				continue
 			}
-			switch (inst>>9)&017 {
+			switch (inst >> 9) & 017 {
 			case 001:	// rotate AC left
-				m.AC = (m.AC << 1 | m.AC >> 17)&mask
+				m.AC = (m.AC<<1 | m.AC>>17) & mask
 			case 002:	// rotate IO left
-				m.IO = (m.IO << 1 | m.IO >> 17)&mask
+				m.IO = (m.IO<<1 | m.IO>>17) & mask
 			case 003:	// rotate AC and IO left.
 				w := uint64(m.AC)<<18 | uint64(m.IO);
 				w = w<<1 | w>>35;
-				m.AC = Word(w>>18)&mask;
-				m.IO = Word(w)&mask;
+				m.AC = Word(w>>18) & mask;
+				m.IO = Word(w) & mask;
 			case 005:	// shift AC left (excluding sign bit)
-				m.AC = (m.AC << 1 | m.AC >> 17)&mask&^sign | m.AC & sign
+				m.AC = (m.AC<<1|m.AC>>17)&mask&^sign | m.AC&sign
 			case 006:	// shift IO left (excluding sign bit)
-				m.IO = (m.IO << 1 | m.IO >> 17)&mask&^sign | m.IO & sign
+				m.IO = (m.IO<<1|m.IO>>17)&mask&^sign | m.IO&sign
 			case 007:	// shift AC and IO left (excluding AC's sign bit)
 				w := uint64(m.AC)<<18 | uint64(m.IO);
 				w = w<<1 | w>>35;
-				m.AC = Word(w>>18)&mask&^sign | m.AC & sign;
-				m.IO = Word(w)&mask&^sign | m.AC & sign;
+				m.AC = Word(w>>18)&mask&^sign | m.AC&sign;
+				m.IO = Word(w)&mask&^sign | m.AC&sign;
 			case 011:	// rotate AC right
-				m.AC = (m.AC >> 1 | m.AC << 17)&mask
+				m.AC = (m.AC>>1 | m.AC<<17) & mask
 			case 012:	// rotate IO right
-				m.IO = (m.IO >> 1 | m.IO << 17)&mask
+				m.IO = (m.IO>>1 | m.IO<<17) & mask
 			case 013:	// rotate AC and IO right
 				w := uint64(m.AC)<<18 | uint64(m.IO);
 				w = w>>1 | w<<35;
-				m.AC = Word(w>>18)&mask;
-				m.IO = Word(w)&mask;
+				m.AC = Word(w>>18) & mask;
+				m.IO = Word(w) & mask;
 			case 015:	// shift AC right (excluding sign bit)
-				m.AC = m.AC >> 1 | m.AC & sign
+				m.AC = m.AC>>1 | m.AC&sign
 			case 016:	// shift IO right (excluding sign bit)
-				m.IO = m.IO >> 1 | m.IO & sign
+				m.IO = m.IO>>1 | m.IO&sign
 			case 017:	// shift AC and IO right (excluding AC's sign bit)
 				w := uint64(m.AC)<<18 | uint64(m.IO);
-				w = w>>1;
-				m.AC = Word(w>>18) | m.AC & sign;
-				m.IO = Word(w)&mask;
+				w = w >> 1;
+				m.AC = Word(w>>18) | m.AC&sign;
+				m.IO = Word(w) & mask;
 			default:
 				goto Unknown
 			}
@@ -316,7 +316,7 @@ func (m *M) run(inst Word, t Trapper) os.Error {
 		if ib == 0 {
 			m.AC = y
 		} else {
-			m.AC = y^mask
+			m.AC = y ^ mask
 		}
 	case opIOT:
 		t.Trap(y)
diff --git a/src/pkg/exp/spacewar/spacewar.go b/src/pkg/exp/spacewar/spacewar.go
index a09cd8c726..6edbcea587 100644
--- a/src/pkg/exp/spacewar/spacewar.go
+++ b/src/pkg/exp/spacewar/spacewar.go
@@ -116,7 +116,7 @@ func (m *SpacewarPDP1) Init(ctxt draw.Context) {
 }
 
 const (
-	frameDelay = 56*1e6;	// 56 ms
+	frameDelay = 56 * 1e6;	// 56 ms
 )
 
 var ctlBits = [...]pdp1.Word{
@@ -134,10 +134,10 @@ func (m *SpacewarPDP1) Step() os.Error {
 	if m.PC == 02051 {
 		m.pollInput();
 		m.nframe++;
-		if m.nframe & 1 == 0 {
+		if m.nframe&1 == 0 {
 			m.flush();
 			t := time.Nanoseconds();
-			if t >= m.frameTime + 3 * frameDelay {
+			if t >= m.frameTime+3*frameDelay {
 				m.frameTime = t
 			} else {
 				m.frameTime += frameDelay;
@@ -152,10 +152,10 @@ func (m *SpacewarPDP1) Step() os.Error {
 }
 
 func (m *SpacewarPDP1) Trap(y pdp1.Word) {
-	switch y&077 {
+	switch y & 077 {
 	case 7:
-		x := int(m.AC + 0400000)&0777777;
-		y := int(m.IO + 0400000)&0777777;
+		x := int(m.AC+0400000) & 0777777;
+		y := int(m.IO+0400000) & 0777777;
 		x = x * m.dx / 0777777;
 		y = y * m.dy / 0777777;
 		if 0 <= x && x < m.dx && 0 <= y && y < m.dy {
diff --git a/src/pkg/flag/flag.go b/src/pkg/flag/flag.go
index a88b2d1785..ff72c08e24 100644
--- a/src/pkg/flag/flag.go
+++ b/src/pkg/flag/flag.go
@@ -298,7 +298,7 @@ func Arg(i int) string {
 func NArg() int	{ return len(os.Args) - flags.first_arg }
 
 // Args returns the non-flag command-line arguments.
-func Args() []string	{ return os.Args[flags.first_arg : len(os.Args)] }
+func Args() []string	{ return os.Args[flags.first_arg:len(os.Args)] }
 
 func add(name string, value FlagValue, usage string) {
 	// Remember the default value as a string; it won't change.
@@ -440,10 +440,10 @@ func (f *allFlags) parseOne(index int) (ok bool, next int) {
 	if s[1] == '-' {
 		num_minuses++;
 		if len(s) == 2 {	// "--" terminates the flags
-			return false, index+1
+			return false, index + 1
 		}
 	}
-	name := s[num_minuses : len(s)];
+	name := s[num_minuses:len(s)];
 	if len(name) == 0 || name[0] == '-' || name[0] == '=' {
 		fmt.Fprintln(os.Stderr, "bad flag syntax:", s);
 		Usage();
@@ -505,7 +505,7 @@ func (f *allFlags) parseOne(index int) (ok bool, next int) {
 		}
 	}
 	flags.actual[name] = flag;
-	return true, index+1;
+	return true, index + 1;
 }
 
 // Parse parses the command-line flags.  Must be called after all flags are defined
diff --git a/src/pkg/fmt/fmt_test.go b/src/pkg/fmt/fmt_test.go
index 8febdac745..f2c4b19429 100644
--- a/src/pkg/fmt/fmt_test.go
+++ b/src/pkg/fmt/fmt_test.go
@@ -197,14 +197,14 @@ func TestSprintf(t *testing.T) {
 	for _, tt := range fmttests {
 		s := Sprintf(tt.fmt, tt.val);
 		if i := strings.Index(s, "0x"); i >= 0 && strings.Index(tt.out, "PTR") >= 0 {
-			j := i+2;
+			j := i + 2;
 			for ; j < len(s); j++ {
 				c := s[j];
 				if (c < '0' || c > '9') && (c < 'a' || c > 'f') {
 					break
 				}
 			}
-			s = s[0:i]+"PTR"+s[j:len(s)];
+			s = s[0:i] + "PTR" + s[j:len(s)];
 		}
 		if s != tt.out {
 			if _, ok := tt.val.(string); ok {
diff --git a/src/pkg/fmt/format.go b/src/pkg/fmt/format.go
index 79817bfd46..8407fbe0b4 100644
--- a/src/pkg/fmt/format.go
+++ b/src/pkg/fmt/format.go
@@ -138,9 +138,9 @@ func (f *Fmt) pad(s string) {
 				buf[i] = padchar
 			}
 			if left {
-				s = string(buf)+s
+				s = string(buf) + s
 			} else {
-				s = s+string(buf)
+				s = s + string(buf)
 			}
 		}
 	}
@@ -153,14 +153,14 @@ func (f *Fmt) pad(s string) {
 // marginally faster by splitting the 32-bit case out into a separate function
 // but it's not worth the duplication, so val has 64 bits.
 func putint(buf []byte, base, val uint64, digits string) int {
-	i := len(buf)-1;
+	i := len(buf) - 1;
 	for val >= base {
 		buf[i] = digits[val%base];
 		i--;
 		val /= base;
 	}
 	buf[i] = digits[val];
-	return i-1;
+	return i - 1;
 }
 
 // Fmt_boolean formats a boolean.
@@ -209,7 +209,7 @@ func (f *Fmt) integer(a int64, base uint, is_signed bool, digits string) string
 				i--;
 			}
 		case 16:
-			buf[i] = 'x'+digits[10]-'a';
+			buf[i] = 'x' + digits[10] - 'a';
 			i--;
 			buf[i] = '0';
 			i--;
@@ -357,7 +357,7 @@ func (f *Fmt) Fmt_c(v int) *Fmt {
 func (f *Fmt) Fmt_s(s string) *Fmt {
 	if f.prec_present {
 		if f.prec < len(s) {
-			s = s[0 : f.prec]
+			s = s[0:f.prec]
 		}
 	}
 	f.pad(s);
@@ -398,7 +398,7 @@ func (f *Fmt) Fmt_sX(s string) *Fmt {
 func (f *Fmt) Fmt_q(s string) *Fmt {
 	var quoted string;
 	if f.sharp && strconv.CanBackquote(s) {
-		quoted = "`"+s+"`"
+		quoted = "`" + s + "`"
 	} else {
 		quoted = strconv.Quote(s)
 	}
diff --git a/src/pkg/fmt/print.go b/src/pkg/fmt/print.go
index 4d7dd4c7f9..15def46a61 100644
--- a/src/pkg/fmt/print.go
+++ b/src/pkg/fmt/print.go
@@ -211,7 +211,7 @@ func Fprintf(w io.Writer, format string, a ...) (n int, error os.Error) {
 	v := reflect.NewValue(a).(*reflect.StructValue);
 	p := newPrinter();
 	p.doprintf(format, v);
-	n, error = w.Write(p.buf[0 : p.n]);
+	n, error = w.Write(p.buf[0:p.n]);
 	return n, error;
 }
 
@@ -226,7 +226,7 @@ func Sprintf(format string, a ...) string {
 	v := reflect.NewValue(a).(*reflect.StructValue);
 	p := newPrinter();
 	p.doprintf(format, v);
-	s := string(p.buf)[0 : p.n];
+	s := string(p.buf)[0:p.n];
 	return s;
 }
 
@@ -238,7 +238,7 @@ func Fprint(w io.Writer, a ...) (n int, error os.Error) {
 	v := reflect.NewValue(a).(*reflect.StructValue);
 	p := newPrinter();
 	p.doprint(v, false, false);
-	n, error = w.Write(p.buf[0 : p.n]);
+	n, error = w.Write(p.buf[0:p.n]);
 	return n, error;
 }
 
@@ -255,7 +255,7 @@ func Sprint(a ...) string {
 	v := reflect.NewValue(a).(*reflect.StructValue);
 	p := newPrinter();
 	p.doprint(v, false, false);
-	s := string(p.buf)[0 : p.n];
+	s := string(p.buf)[0:p.n];
 	return s;
 }
 
@@ -269,7 +269,7 @@ func Fprintln(w io.Writer, a ...) (n int, error os.Error) {
 	v := reflect.NewValue(a).(*reflect.StructValue);
 	p := newPrinter();
 	p.doprint(v, true, true);
-	n, error = w.Write(p.buf[0 : p.n]);
+	n, error = w.Write(p.buf[0:p.n]);
 	return n, error;
 }
 
@@ -286,7 +286,7 @@ func Sprintln(a ...) string {
 	v := reflect.NewValue(a).(*reflect.StructValue);
 	p := newPrinter();
 	p.doprint(v, true, true);
-	s := string(p.buf)[0 : p.n];
+	s := string(p.buf)[0:p.n];
 	return s;
 }
 
@@ -356,7 +356,7 @@ func getFloat32(v reflect.Value) (val float32, ok bool) {
 	case *reflect.Float32Value:
 		return float32(v.Get()), true
 	case *reflect.FloatValue:
-		if v.Type().Size() * 8 == 32 {
+		if v.Type().Size()*8 == 32 {
 			return float32(v.Get()), true
 		}
 	}
@@ -366,7 +366,7 @@ func getFloat32(v reflect.Value) (val float32, ok bool) {
 func getFloat64(v reflect.Value) (val float64, ok bool) {
 	switch v := v.(type) {
 	case *reflect.FloatValue:
-		if v.Type().Size() * 8 == 64 {
+		if v.Type().Size()*8 == 64 {
 			return float64(v.Get()), true
 		}
 	case *reflect.Float64Value:
@@ -429,7 +429,7 @@ BigSwitch:
 	case *reflect.Float64Value:
 		s = p.fmt.Fmt_g64(f.Get()).Str()
 	case *reflect.FloatValue:
-		if field.Type().Size() * 8 == 32 {
+		if field.Type().Size()*8 == 32 {
 			s = p.fmt.Fmt_g32(float32(f.Get())).Str()
 		} else {
 			s = p.fmt.Fmt_g64(float64(f.Get())).Str()
@@ -600,7 +600,7 @@ BigSwitch:
 
 func (p *pp) doprintf(format string, v *reflect.StructValue) {
 	p.ensure(len(format));	// a good starting size
-	end := len(format)-1;
+	end := len(format) - 1;
 	fieldnum := 0;	// we process one field per non-trivial format
 	for i := 0; i <= end; {
 		c, w := utf8.DecodeRuneInString(format[i:len(format)]);
diff --git a/src/pkg/go/ast/ast.go b/src/pkg/go/ast/ast.go
index b501247cb6..1dfe2a7ea4 100644
--- a/src/pkg/go/ast/ast.go
+++ b/src/pkg/go/ast/ast.go
@@ -237,7 +237,7 @@ type (
 type ChanDir int
 
 const (
-	SEND	ChanDir	= 1<<iota;
+	SEND	ChanDir	= 1 << iota;
 	RECV;
 )
 
diff --git a/src/pkg/go/ast/filter.go b/src/pkg/go/ast/filter.go
index 2e86435bf6..772407400d 100644
--- a/src/pkg/go/ast/filter.go
+++ b/src/pkg/go/ast/filter.go
@@ -203,7 +203,7 @@ func MergePackageFiles(pkg *Package) *File {
 	ndecls := 0;
 	for _, f := range pkg.Files {
 		if f.Doc != nil {
-			ncomments += len(f.Doc.List)+1	// +1 for separator
+			ncomments += len(f.Doc.List) + 1	// +1 for separator
 		}
 		ndecls += len(f.Decls);
 	}
@@ -215,7 +215,7 @@ func MergePackageFiles(pkg *Package) *File {
 	// than drop them on the floor.
 	var doc *CommentGroup;
 	if ncomments > 0 {
-		list := make([]*Comment, ncomments - 1);	// -1: no separator before first group
+		list := make([]*Comment, ncomments-1);	// -1: no separator before first group
 		i := 0;
 		for _, f := range pkg.Files {
 			if f.Doc != nil {
diff --git a/src/pkg/go/doc/comment.go b/src/pkg/go/doc/comment.go
index ba9371439b..cf1452ac92 100644
--- a/src/pkg/go/doc/comment.go
+++ b/src/pkg/go/doc/comment.go
@@ -31,7 +31,7 @@ func CommentText(comment *ast.CommentGroup) string {
 		// Remove comment markers.
 		// The parser has given us exactly the comment text.
 		switch n := len(c); {
-		case n >= 4 && c[0:2] == "/*" && c[n-2 : n] == "*/":
+		case n >= 4 && c[0:2] == "/*" && c[n-2:n] == "*/":
 			c = c[2 : n-2]
 		case n >= 2 && c[0:2] == "//":
 			c = c[2:n];
@@ -95,7 +95,7 @@ func split(text []byte) [][]byte {
 	last := 0;
 	for i, c := range text {
 		if c == '\n' {
-			last = i+1;
+			last = i + 1;
 			n++;
 		}
 	}
@@ -110,7 +110,7 @@ func split(text []byte) [][]byte {
 	for i, c := range text {
 		if c == '\n' {
 			out[n] = text[last : i+1];
-			last = i+1;
+			last = i + 1;
 			n++;
 		}
 	}
@@ -134,7 +134,7 @@ func commentEscape(w io.Writer, s []byte) {
 	for i := 0; i < len(s)-1; i++ {
 		if s[i] == s[i+1] && (s[i] == '`' || s[i] == '\'') {
 			template.HTMLEscape(w, s[last:i]);
-			last = i+2;
+			last = i + 2;
 			switch s[i] {
 			case '`':
 				w.Write(ldquo)
@@ -183,10 +183,10 @@ func unindent(block [][]byte) {
 	}
 
 	// compute maximum common white prefix
-	prefix := block[0][0 : indentLen(block[0])];
+	prefix := block[0][0:indentLen(block[0])];
 	for _, line := range block {
 		if !isBlank(line) {
-			prefix = commonPrefix(prefix, line[0 : indentLen(line)])
+			prefix = commonPrefix(prefix, line[0:indentLen(line)])
 		}
 	}
 	n := len(prefix);
@@ -242,7 +242,7 @@ func ToHTML(w io.Writer, s []byte) {
 			close();
 
 			// count indented or blank lines
-			j := i+1;
+			j := i + 1;
 			for j < len(lines) && (isBlank(lines[j]) || indentLen(lines[j]) > 0) {
 				j++
 			}
diff --git a/src/pkg/go/doc/doc.go b/src/pkg/go/doc/doc.go
index 9c85c20beb..4ef12641b8 100644
--- a/src/pkg/go/doc/doc.go
+++ b/src/pkg/go/doc/doc.go
@@ -135,7 +135,7 @@ func (doc *docReader) addValue(decl *ast.GenDecl) {
 	// determine values list
 	const threshold = 0.75;
 	values := doc.values;
-	if domName != "" && domFreq >= int(float(len(decl.Specs)) * threshold) {
+	if domName != "" && domFreq >= int(float(len(decl.Specs))*threshold) {
 		// typed entries are sufficiently frequent
 		typ := doc.lookupTypeDoc(domName);
 		if typ != nil {
diff --git a/src/pkg/go/parser/interface.go b/src/pkg/go/parser/interface.go
index 50d7dff656..6704894629 100644
--- a/src/pkg/go/parser/interface.go
+++ b/src/pkg/go/parser/interface.go
@@ -154,7 +154,7 @@ func ParsePkgFile(pkgname, filename string, mode uint) (*ast.File, os.Error) {
 	}
 
 	// ignore flags that control partial parsing
-	return ParseFile(filename, src, mode&^(PackageClauseOnly | ImportsOnly));
+	return ParseFile(filename, src, mode&^(PackageClauseOnly|ImportsOnly));
 }
 
 
diff --git a/src/pkg/go/parser/parser.go b/src/pkg/go/parser/parser.go
index 5e0c7307b5..ba91ceb52b 100644
--- a/src/pkg/go/parser/parser.go
+++ b/src/pkg/go/parser/parser.go
@@ -27,7 +27,7 @@ var noPos token.Position
 // parser functionality.
 //
 const (
-	PackageClauseOnly	uint	= 1<<iota;	// parsing stops after package clause
+	PackageClauseOnly	uint	= 1 << iota;	// parsing stops after package clause
 	ImportsOnly;			// parsing stops after import declarations
 	ParseComments;			// parse comments and add them to AST
 	Trace;				// print a trace of parsed productions
@@ -68,7 +68,7 @@ type parser struct {
 
 // scannerMode returns the scanner mode bits given the parser's mode bits.
 func scannerMode(mode uint) uint {
-	if mode & ParseComments != 0 {
+	if mode&ParseComments != 0 {
 		return scanner.ScanComments
 	}
 	return 0;
@@ -127,7 +127,7 @@ func (p *parser) next0() {
 		case p.tok.IsLiteral():
 			p.printTrace(s, string(p.lit))
 		case p.tok.IsOperator(), p.tok.IsKeyword():
-			p.printTrace("\""+s+"\"")
+			p.printTrace("\"" + s + "\"")
 		default:
 			p.printTrace(s)
 		}
@@ -246,7 +246,7 @@ func (p *parser) errorExpected(pos token.Position, msg string) {
 		// make the error message more specific
 		msg += ", found '" + p.tok.String() + "'";
 		if p.tok.IsLiteral() {
-			msg += " "+string(p.lit)
+			msg += " " + string(p.lit)
 		}
 	}
 	p.Error(pos, msg);
@@ -256,7 +256,7 @@ func (p *parser) errorExpected(pos token.Position, msg string) {
 func (p *parser) expect(tok token.Token) token.Position {
 	pos := p.pos;
 	if p.tok != tok {
-		p.errorExpected(pos, "'" + tok.String() + "'")
+		p.errorExpected(pos, "'"+tok.String()+"'")
 	}
 	p.next();	// make progress in any case
 	return pos;
@@ -278,7 +278,7 @@ func close(p *parser)	{ p.topScope = p.topScope.Outer }
 
 func (p *parser) declare(ident *ast.Ident) {
 	if !p.topScope.Declare(ident) {
-		p.Error(p.pos, "'" + ident.Value + "' declared already")
+		p.Error(p.pos, "'"+ident.Value+"' declared already")
 	}
 }
 
@@ -1220,7 +1220,7 @@ func (p *parser) parseBinaryExpr(prec1 int) ast.Expr {
 		for p.tok.Precedence() == prec {
 			pos, op := p.pos, p.tok;
 			p.next();
-			y := p.parseBinaryExpr(prec+1);
+			y := p.parseBinaryExpr(prec + 1);
 			x = &ast.BinaryExpr{p.checkExpr(x), pos, op, p.checkExpr(y)};
 		}
 	}
@@ -1806,7 +1806,7 @@ func parseVarSpec(p *parser, doc *ast.CommentGroup, getSemi bool) (spec ast.Spec
 
 func (p *parser) parseGenDecl(keyword token.Token, f parseSpecFunction, getSemi bool) (decl *ast.GenDecl, gotSemi bool) {
 	if p.trace {
-		defer un(trace(p, keyword.String() + "Decl"))
+		defer un(trace(p, keyword.String()+"Decl"))
 	}
 
 	doc := p.leadComment;
@@ -1977,7 +1977,7 @@ func (p *parser) parseFile() *ast.File {
 	// Don't bother parsing the rest if we had errors already.
 	// Likely not a Go source file at all.
 
-	if p.ErrorCount() == 0 && p.mode & PackageClauseOnly == 0 {
+	if p.ErrorCount() == 0 && p.mode&PackageClauseOnly == 0 {
 		// import decls
 		list := vector.New(0);
 		for p.tok == token.IMPORT {
@@ -1985,7 +1985,7 @@ func (p *parser) parseFile() *ast.File {
 			list.Push(decl);
 		}
 
-		if p.mode & ImportsOnly == 0 {
+		if p.mode&ImportsOnly == 0 {
 			// rest of package body
 			for p.tok != token.EOF {
 				decl, _ := p.parseDecl(true);	// consume optional semicolon
diff --git a/src/pkg/go/printer/nodes.go b/src/pkg/go/printer/nodes.go
index 6397796903..d3c1b40722 100644
--- a/src/pkg/go/printer/nodes.go
+++ b/src/pkg/go/printer/nodes.go
@@ -10,7 +10,6 @@ package printer
 
 import (
 	"bytes";
-	"container/vector";
 	"go/ast";
 	"go/token";
 )
@@ -116,7 +115,7 @@ func (p *printer) identList(list []*ast.Ident, multiLine *bool) {
 	for i, x := range list {
 		xlist[i] = x
 	}
-	p.exprList(noPos, xlist, commaSep, multiLine);
+	p.exprList(noPos, xlist, 1, commaSep, multiLine);
 }
 
 
@@ -127,14 +126,14 @@ func (p *printer) stringList(list []*ast.BasicLit, multiLine *bool) {
 	for i, x := range list {
 		xlist[i] = x
 	}
-	p.exprList(noPos, xlist, stringListMode, multiLine);
+	p.exprList(noPos, xlist, 1, stringListMode, multiLine);
 }
 
 
 type exprListMode uint
 
 const (
-	blankStart	exprListMode	= 1<<iota;	// print a blank before a non-empty list
+	blankStart	exprListMode	= 1 << iota;	// print a blank before a non-empty list
 	blankEnd;			// print a blank after a non-empty list
 	commaSep;			// elements are separated by commas
 	commaTerm;			// elements are terminated by comma
@@ -146,12 +145,12 @@ const (
 // source lines, the original line breaks are respected between
 // expressions. Sets multiLine to true if the list spans multiple
 // lines.
-func (p *printer) exprList(prev token.Position, list []ast.Expr, mode exprListMode, multiLine *bool) {
+func (p *printer) exprList(prev token.Position, list []ast.Expr, depth int, mode exprListMode, multiLine *bool) {
 	if len(list) == 0 {
 		return
 	}
 
-	if mode & blankStart != 0 {
+	if mode&blankStart != 0 {
 		p.print(blank)
 	}
 
@@ -170,7 +169,7 @@ func (p *printer) exprList(prev token.Position, list []ast.Expr, mode exprListMo
 				}
 				p.print(blank);
 			}
-			p.expr(x, multiLine);
+			p.expr0(x, depth, multiLine);
 		}
 		if mode&blankEnd != 0 {
 			p.print(blank)
@@ -209,10 +208,10 @@ func (p *printer) exprList(prev token.Position, list []ast.Expr, mode exprListMo
 				p.print(blank)
 			}
 		}
-		p.expr(x, multiLine);
+		p.expr0(x, depth, multiLine);
 	}
 
-	if mode & commaTerm != 0 {
+	if mode&commaTerm != 0 {
 		p.print(token.COMMA);
 		if ws == ignore && mode&noIndent == 0 {
 			// unindent if we indented
@@ -307,7 +306,7 @@ func (p *printer) isOneLineFieldList(list []*ast.Field) bool {
 
 	}
 	typeSize := p.nodeSize(f.Type, maxSize);
-	return namesSize + typeSize <= maxSize;
+	return namesSize+typeSize <= maxSize;
 }
 
 
@@ -318,7 +317,7 @@ func (p *printer) fieldList(lbrace token.Position, list []*ast.Field, rbrace tok
 			// no blank between keyword and {} in this case
 			p.print(lbrace, token.LBRACE, rbrace, token.RBRACE);
 			return;
-		} else if ctxt&(compositeLit | structType) == compositeLit | structType &&
+		} else if ctxt&(compositeLit|structType) == compositeLit|structType &&
 			p.isOneLineFieldList(list) {	// for now ignore interfaces
 			// small enough - print on one line
 			// (don't use identList and ignore source line breaks)
@@ -341,7 +340,7 @@ func (p *printer) fieldList(lbrace token.Position, list []*ast.Field, rbrace tok
 
 	// at least one entry or incomplete
 	p.print(blank, lbrace, token.LBRACE, indent, formfeed);
-	if ctxt & structType != 0 {
+	if ctxt&structType != 0 {
 
 		sep := vtab;
 		if len(list) == 1 {
@@ -430,111 +429,179 @@ func (p *printer) fieldList(lbrace token.Position, list []*ast.Field, rbrace tok
 type exprContext uint
 
 const (
-	compositeLit	= 1<<iota;
+	compositeLit	= 1 << iota;
 	structType;
 )
 
 
-func needsBlanks(expr ast.Expr) bool {
-	switch x := expr.(type) {
-	case *ast.Ident:
-		// "long" identifiers look better with blanks around them
-		return len(x.Value) > 8
-	case *ast.BasicLit:
-		// "long" literals look better with blanks around them
-		return len(x.Value) > 8
-	case *ast.ParenExpr:
-		// parenthesized expressions don't need blanks around them
-		return false
-	case *ast.IndexExpr:
-		// index expressions don't need blanks if the indexed expressions are simple
-		return needsBlanks(x.X)
-	case *ast.CallExpr:
-		// call expressions need blanks if they have more than one
-		// argument or if the function expression needs blanks
-		return len(x.Args) > 1 || needsBlanks(x.Fun)
+func walkBinary(e *ast.BinaryExpr) (has5, has6 bool, maxProblem int) {
+	switch e.Op.Precedence() {
+	case 5:
+		has5 = true
+	case 6:
+		has6 = true
 	}
-	return true;
+
+	switch l := e.X.(type) {
+	case *ast.BinaryExpr:
+		h5, h6, mp := walkBinary(l);
+		has5 = has5 || h5;
+		has6 = has6 || h6;
+		if maxProblem < mp {
+			maxProblem = mp
+		}
+	}
+
+	switch r := e.Y.(type) {
+	case *ast.BinaryExpr:
+		h5, h6, mp := walkBinary(r);
+		has5 = has5 || h5;
+		has6 = has6 || h6;
+		if maxProblem < mp {
+			maxProblem = mp
+		}
+
+	case *ast.StarExpr:
+		if e.Op.String() == "/" {
+			maxProblem = 6
+		}
+
+	case *ast.UnaryExpr:
+		switch e.Op.String() + r.Op.String() {
+		case "/*":
+			maxProblem = 6
+		case "++", "--":
+			if maxProblem < 5 {
+				maxProblem = 5
+			}
+		}
+	}
+	return;
+}
+
+
+func cutoff(e *ast.BinaryExpr, depth int) int {
+	if depth < 1 {
+		// handle gracefully unless in debug mode
+		if debug {
+			panicln("negative depth:", depth)
+		}
+		depth = 1;
+	}
+	has5, has6, maxProblem := walkBinary(e);
+	if maxProblem > 0 {
+		return maxProblem + 1
+	}
+	if has5 && has6 {
+		if depth == 1 {
+			return 6
+		}
+		return 5;
+	}
+	if depth == 1 {
+		return 7
+	}
+	return 5;
 }
 
 
+func diffPrec(expr ast.Expr, prec int) int {
+	x, ok := expr.(*ast.BinaryExpr);
+	if !ok || prec != x.Op.Precedence() {
+		return 1
+	}
+	return 0;
+}
+
+
+// Format the binary expression: decide the cutoff and then format.
+// Let's call depth == 1 Normal mode, and depth > 1 Compact mode.
+// (Algorithm suggestion by Russ Cox.)
+//
+// The precedences are:
+//	6             *  /  %  <<  >>  &  &^
+//	5             +  -  |  ^
+//	4             ==  !=  <  <=  >  >=
+//	3             <-
+//	2             &&
+//	1             ||
+//
+// The only decision is whether there will be spaces around levels 5 and 6.
+// There are never spaces at level 7 (unary), and always spaces at levels 4 and below.
+//
+// To choose the cutoff, look at the whole expression but excluding primary
+// expressions (function calls, parenthesized exprs), and apply these rules:
+//
+//	1) If there is a binary operator with a right side unary operand
+//	   that would clash without a space, the cutoff must be (in order):
+//
+//		&^	7
+//		/*	7
+//		++	6
+//		--	6
+//
+//	2) If there is a mix of level 6 and level 5 operators, then the cutoff
+//	   is 6 (use spaces to distinguish precedence) in Normal mode
+//	   and 5 (never use spaces) in Compact mode.
+//
+//	3) If there are no level 5 operators or no level 6 operators, then the
+//	   cutoff is 7 (always use spaces) in Normal mode
+//	   and 5 (never use spaces) in Compact mode.
+//
 // Sets multiLine to true if the binary expression spans multiple lines.
-func (p *printer) binaryExpr(x *ast.BinaryExpr, prec1 int, multiLine *bool) {
+func (p *printer) binaryExpr(x *ast.BinaryExpr, prec1, cutoff, depth int, multiLine *bool) {
 	prec := x.Op.Precedence();
 	if prec < prec1 {
 		// parenthesis needed
 		// Note: The parser inserts an ast.ParenExpr node; thus this case
 		//       can only occur if the AST is created in a different way.
+		// parentheses undo one level of depth
+		depth--;
 		p.print(token.LPAREN);
-		p.expr(x, multiLine);
+		p.expr0(x, depth, multiLine);
 		p.print(token.RPAREN);
 		return;
 	}
 
-	// Traverse left, collect all operations at same precedence
-	// and determine if blanks should be printed around operators.
-	//
-	// This algorithm assumes that the right-hand side of a binary
-	// operation has a different (higher) precedence then the current
-	// node, which is how the parser creates the AST.
-	var list vector.Vector;
-	line := x.Y.Pos().Line;
-	printBlanks := prec <= token.EQL.Precedence() || needsBlanks(x.Y);
-	for {
-		list.Push(x);
-		if t, ok := x.X.(*ast.BinaryExpr); ok && t.Op.Precedence() == prec {
-			x = t;
-			prev := line;
-			line = x.Y.Pos().Line;
-			if needsBlanks(x.Y) || prev != line {
-				printBlanks = true
-			}
-		} else {
-			break
-		}
-	}
-	prev := line;
-	line = x.X.Pos().Line;
-	if needsBlanks(x.X) || prev != line {
-		printBlanks = true
-	}
+	printBlank := prec < cutoff;
 
-	// Print collected operations left-to-right, with blanks if necessary.
 	ws := indent;
-	p.expr1(x.X, prec, 0, multiLine);
-	for list.Len() > 0 {
-		x = list.Pop().(*ast.BinaryExpr);
-		prev := line;
-		line = x.Y.Pos().Line;
-		if printBlanks {
-			if prev != line {
-				p.print(blank, x.OpPos, x.Op);
-				// at least one line break, but respect an extra empty line
-				// in the source
-				if p.linebreak(line, 1, 2, ws, true) {
-					ws = ignore;
-					*multiLine = true;
-				}
-			} else {
-				p.print(blank, x.OpPos, x.Op, blank)
-			}
-		} else {
-			if prev != line {
-				panic("internal error")
-			}
-			p.print(x.OpPos, x.Op);
+	p.expr1(x.X, prec, depth+diffPrec(x.X, prec), 0, multiLine);
+	if printBlank {
+		p.print(blank)
+	}
+	xline := p.pos.Line;	// before the operator (it may be on the next line!)
+	yline := x.Y.Pos().Line;
+	p.print(x.OpPos, x.Op);
+	if xline != yline {
+		//println(x.OpPos.String());
+		// at least one line break, but respect an extra empty line
+		// in the source
+		if p.linebreak(yline, 1, 2, ws, true) {
+			ws = ignore;
+			*multiLine = true;
+			printBlank = false;	// no blank after line break
 		}
-		p.expr1(x.Y, prec, 0, multiLine);
 	}
+	if printBlank {
+		p.print(blank)
+	}
+	p.expr1(x.Y, prec, depth+1, 0, multiLine);
 	if ws == ignore {
 		p.print(unindent)
 	}
 }
 
 
+func isBinary(expr ast.Expr) bool {
+	_, ok := expr.(*ast.BinaryExpr);
+	return ok;
+}
+
+
 // Returns true if a separating semicolon is optional.
 // Sets multiLine to true if the expression spans multiple lines.
-func (p *printer) expr1(expr ast.Expr, prec1 int, ctxt exprContext, multiLine *bool) (optSemi bool) {
+func (p *printer) expr1(expr ast.Expr, prec1, depth int, ctxt exprContext, multiLine *bool) (optSemi bool) {
 	p.print(expr.Pos());
 
 	switch x := expr.(type) {
@@ -545,7 +612,7 @@ func (p *printer) expr1(expr ast.Expr, prec1 int, ctxt exprContext, multiLine *b
 		p.print(x)
 
 	case *ast.BinaryExpr:
-		p.binaryExpr(x, prec1, multiLine)
+		p.binaryExpr(x, prec1, cutoff(x, depth), depth, multiLine)
 
 	case *ast.KeyValueExpr:
 		p.expr(x.Key, multiLine);
@@ -569,7 +636,7 @@ func (p *printer) expr1(expr ast.Expr, prec1 int, ctxt exprContext, multiLine *b
 			if x.Op == token.RANGE {
 				p.print(blank)
 			}
-			p.expr1(x.X, prec, 0, multiLine);
+			p.expr1(x.X, prec, depth, 0, multiLine);
 		}
 
 	case *ast.BasicLit:
@@ -583,17 +650,19 @@ func (p *printer) expr1(expr ast.Expr, prec1 int, ctxt exprContext, multiLine *b
 		p.funcBody(x.Body, distance(x.Type.Pos(), p.pos), true, multiLine);
 
 	case *ast.ParenExpr:
+		// parentheses undo one level of depth
+		depth--;
 		p.print(token.LPAREN);
-		p.expr(x.X, multiLine);
+		p.expr0(x.X, depth, multiLine);
 		p.print(x.Rparen, token.RPAREN);
 
 	case *ast.SelectorExpr:
-		p.expr1(x.X, token.HighestPrec, 0, multiLine);
+		p.expr1(x.X, token.HighestPrec, depth, 0, multiLine);
 		p.print(token.PERIOD);
-		p.expr1(x.Sel, token.HighestPrec, 0, multiLine);
+		p.expr1(x.Sel, token.HighestPrec, depth, 0, multiLine);
 
 	case *ast.TypeAssertExpr:
-		p.expr1(x.X, token.HighestPrec, 0, multiLine);
+		p.expr1(x.X, token.HighestPrec, depth, 0, multiLine);
 		p.print(token.PERIOD, token.LPAREN);
 		if x.Type != nil {
 			p.expr(x.Type, multiLine)
@@ -603,29 +672,31 @@ func (p *printer) expr1(expr ast.Expr, prec1 int, ctxt exprContext, multiLine *b
 		p.print(token.RPAREN);
 
 	case *ast.IndexExpr:
-		p.expr1(x.X, token.HighestPrec, 0, multiLine);
+		p.expr1(x.X, token.HighestPrec, 1, 0, multiLine);
 		p.print(token.LBRACK);
-		p.expr1(x.Index, token.LowestPrec, 0, multiLine);
+		p.expr0(x.Index, depth+1, multiLine);
 		if x.End != nil {
-			if needsBlanks(x.Index) || needsBlanks(x.End) {
-				// blanks around ":"
+			// blanks around ":" if either side is a binary expression
+			if depth <= 1 && (isBinary(x.Index) || isBinary(x.End)) {
 				p.print(blank, token.COLON, blank)
 			} else {
-				// no blanks around ":"
 				p.print(token.COLON)
 			}
-			p.expr(x.End, multiLine);
+			p.expr0(x.End, depth+1, multiLine);
 		}
 		p.print(token.RBRACK);
 
 	case *ast.CallExpr:
-		p.expr1(x.Fun, token.HighestPrec, 0, multiLine);
+		if len(x.Args) > 1 {
+			depth++
+		}
+		p.expr1(x.Fun, token.HighestPrec, depth, 0, multiLine);
 		p.print(x.Lparen, token.LPAREN);
-		p.exprList(x.Lparen, x.Args, commaSep, multiLine);
+		p.exprList(x.Lparen, x.Args, depth, commaSep, multiLine);
 		p.print(x.Rparen, token.RPAREN);
 
 	case *ast.CompositeLit:
-		p.expr1(x.Type, token.HighestPrec, compositeLit, multiLine);
+		p.expr1(x.Type, token.HighestPrec, depth, compositeLit, multiLine);
 		mode := commaSep | commaTerm;
 		if compositeLitBlank {
 			// add blank padding around composite literal
@@ -640,7 +711,7 @@ func (p *printer) expr1(expr ast.Expr, prec1 int, ctxt exprContext, multiLine *b
 			}
 		}
 		p.print(x.Lbrace, token.LBRACE);
-		p.exprList(x.Lbrace, x.Elts, mode, multiLine);
+		p.exprList(x.Lbrace, x.Elts, 1, mode, multiLine);
 		p.print(x.Rbrace, token.RBRACE);
 
 	case *ast.Ellipsis:
@@ -656,7 +727,7 @@ func (p *printer) expr1(expr ast.Expr, prec1 int, ctxt exprContext, multiLine *b
 
 	case *ast.StructType:
 		p.print(token.STRUCT);
-		p.fieldList(x.Lbrace, x.Fields, x.Rbrace, x.Incomplete, ctxt | structType);
+		p.fieldList(x.Lbrace, x.Fields, x.Rbrace, x.Incomplete, ctxt|structType);
 		optSemi = true;
 
 	case *ast.FuncType:
@@ -694,10 +765,16 @@ func (p *printer) expr1(expr ast.Expr, prec1 int, ctxt exprContext, multiLine *b
 }
 
 
+func (p *printer) expr0(x ast.Expr, depth int, multiLine *bool) (optSemi bool) {
+	return p.expr1(x, token.LowestPrec, depth, 0, multiLine)
+}
+
+
 // Returns true if a separating semicolon is optional.
 // Sets multiLine to true if the expression spans multiple lines.
 func (p *printer) expr(x ast.Expr, multiLine *bool) (optSemi bool) {
-	return p.expr1(x, token.LowestPrec, 0, multiLine)
+	const depth = 1;
+	return p.expr1(x, token.LowestPrec, depth, 0, multiLine);
 }
 
 
@@ -812,16 +889,22 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 		optSemi = p.stmt(s.Stmt, multiLine);
 
 	case *ast.ExprStmt:
-		p.expr(s.X, multiLine)
+		const depth = 1;
+		p.expr0(s.X, depth, multiLine);
 
 	case *ast.IncDecStmt:
-		p.expr(s.X, multiLine);
+		const depth = 1;
+		p.expr0(s.X, depth+1, multiLine);
 		p.print(s.Tok);
 
 	case *ast.AssignStmt:
-		p.exprList(s.Pos(), s.Lhs, commaSep, multiLine);
+		var depth = 1;
+		if len(s.Lhs) > 1 && len(s.Rhs) > 1 {
+			depth++
+		}
+		p.exprList(s.Pos(), s.Lhs, depth, commaSep, multiLine);
 		p.print(blank, s.TokPos, s.Tok);
-		p.exprList(s.TokPos, s.Rhs, blankStart | commaSep, multiLine);
+		p.exprList(s.TokPos, s.Rhs, depth, blankStart|commaSep, multiLine);
 
 	case *ast.GoStmt:
 		p.print(token.GO, blank);
@@ -834,7 +917,7 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 	case *ast.ReturnStmt:
 		p.print(token.RETURN);
 		if s.Results != nil {
-			p.exprList(s.Pos(), s.Results, blankStart | commaSep, multiLine)
+			p.exprList(s.Pos(), s.Results, 1, blankStart|commaSep, multiLine)
 		}
 
 	case *ast.BranchStmt:
@@ -870,7 +953,7 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 	case *ast.CaseClause:
 		if s.Values != nil {
 			p.print(token.CASE);
-			p.exprList(s.Pos(), s.Values, blankStart | commaSep, multiLine);
+			p.exprList(s.Pos(), s.Values, 1, blankStart|commaSep, multiLine);
 		} else {
 			p.print(token.DEFAULT)
 		}
@@ -888,7 +971,7 @@ func (p *printer) stmt(stmt ast.Stmt, multiLine *bool) (optSemi bool) {
 	case *ast.TypeCaseClause:
 		if s.Types != nil {
 			p.print(token.CASE);
-			p.exprList(s.Pos(), s.Types, blankStart | commaSep, multiLine);
+			p.exprList(s.Pos(), s.Types, 1, blankStart|commaSep, multiLine);
 		} else {
 			p.print(token.DEFAULT)
 		}
@@ -1003,7 +1086,7 @@ func (p *printer) spec(spec ast.Spec, n int, context declContext, multiLine *boo
 			}
 			if s.Values != nil {
 				p.print(blank, token.ASSIGN);
-				p.exprList(noPos, s.Values, blankStart | commaSep, multiLine);
+				p.exprList(noPos, s.Values, 1, blankStart|commaSep, multiLine);
 				optSemi = false;
 			}
 		} else {
@@ -1018,7 +1101,7 @@ func (p *printer) spec(spec ast.Spec, n int, context declContext, multiLine *boo
 			if s.Values != nil {
 				p.print(vtab);
 				p.print(token.ASSIGN);
-				p.exprList(noPos, s.Values, blankStart | commaSep, multiLine);
+				p.exprList(noPos, s.Values, 1, blankStart|commaSep, multiLine);
 				optSemi = false;
 				extraTabs = 0;
 			}
@@ -1089,7 +1172,7 @@ func (p *printer) genDecl(d *ast.GenDecl, context declContext, multiLine *bool)
 // any control chars. Otherwise, the result is > maxSize.
 //
 func (p *printer) nodeSize(n ast.Node, maxSize int) (size int) {
-	size = maxSize+1;	// assume n doesn't fit
+	size = maxSize + 1;	// assume n doesn't fit
 	// nodeSize computation must be indendent of particular
 	// style so that we always get the same decision; print
 	// in RawFormat
@@ -1120,7 +1203,7 @@ func (p *printer) isOneLineFunc(b *ast.BlockStmt, headerSize int) bool {
 		bodySize = p.nodeSize(b.List[0], maxSize)
 	}
 	// require both headers and overall size to be not "too large"
-	return headerSize <= maxSize/2 && headerSize + bodySize <= maxSize;
+	return headerSize <= maxSize/2 && headerSize+bodySize <= maxSize;
 }
 
 
@@ -1158,7 +1241,7 @@ func distance(from, to token.Position) int {
 	if from.IsValid() && to.IsValid() && from.Line == to.Line {
 		return to.Column - from.Column
 	}
-	return 1<<30;
+	return 1 << 30;
 }
 
 
diff --git a/src/pkg/go/printer/printer.go b/src/pkg/go/printer/printer.go
index 4c3511c615..6497fc81ab 100644
--- a/src/pkg/go/printer/printer.go
+++ b/src/pkg/go/printer/printer.go
@@ -127,7 +127,7 @@ func (p *printer) write(data []byte) {
 			p.write0(data[i0 : i+1]);
 
 			// update p.pos
-			p.pos.Offset += i+1-i0;
+			p.pos.Offset += i + 1 - i0;
 			p.pos.Line++;
 			p.pos.Column = 1;
 
@@ -147,10 +147,10 @@ func (p *printer) write(data []byte) {
 			}
 
 			// next segment start
-			i0 = i+1;
+			i0 = i + 1;
 
 		case '"', '\'', '&', '<', '>':
-			if p.Mode & GenHTML != 0 {
+			if p.Mode&GenHTML != 0 {
 				// write segment ending in b
 				p.write0(data[i0:i]);
 
@@ -171,12 +171,12 @@ func (p *printer) write(data []byte) {
 				p.write0(esc);
 
 				// update p.pos
-				d := i+1-i0;
+				d := i + 1 - i0;
 				p.pos.Offset += d;
 				p.pos.Column += d;
 
 				// next segment start
-				i0 = i+1;
+				i0 = i + 1;
 			}
 
 		case tabwriter.Escape:
@@ -188,7 +188,7 @@ func (p *printer) write(data []byte) {
 	p.write0(data[i0:len(data)]);
 
 	// update p.pos
-	d := len(data)-i0;
+	d := len(data) - i0;
 	p.pos.Offset += d;
 	p.pos.Column += d;
 }
@@ -241,7 +241,7 @@ func (p *printer) writeItem(pos token.Position, data []byte, tag HTMLTag) {
 		// do not update p.pos - use write0
 		p.write0(strings.Bytes(fmt.Sprintf("[%d:%d]", pos.Line, pos.Column)))
 	}
-	if p.Mode & GenHTML != 0 {
+	if p.Mode&GenHTML != 0 {
 		// write line tag if on a new line
 		// TODO(gri): should write line tags on each line at the start
 		//            will be more useful (e.g. to show line numbers)
@@ -387,7 +387,7 @@ func split(text []byte) [][]byte {
 	for j, c := range text {
 		if c == '\n' {
 			lines[n] = text[i:j];	// exclude newline
-			i = j+1;		// discard newline
+			i = j + 1;		// discard newline
 			n++;
 		}
 	}
@@ -740,7 +740,7 @@ func (p *printer) print(args ...) {
 			// (note that valid Go programs cannot contain esc ('\xff')
 			// bytes since they do not appear in legal UTF-8 sequences)
 			// TODO(gri): this this more efficiently.
-			data = strings.Bytes("\xff"+string(data)+"\xff");
+			data = strings.Bytes("\xff" + string(data) + "\xff");
 		case token.Token:
 			if p.Styler != nil {
 				data, tag = p.Styler.Token(x)
@@ -884,7 +884,7 @@ func (p *trimmer) Write(data []byte) (n int, err os.Error) {
 
 // General printing is controlled with these Config.Mode flags.
 const (
-	GenHTML		uint	= 1<<iota;	// generate HTML
+	GenHTML		uint	= 1 << iota;	// generate HTML
 	RawFormat;		// do not use a tabwriter; if set, UseSpaces is ignored
 	UseSpaces;		// use spaces instead of tabs for indentation and alignment
 )
@@ -930,13 +930,13 @@ func (cfg *Config) Fprint(output io.Writer, node interface{}) (int, os.Error) {
 
 	// setup tabwriter if needed and redirect output
 	var tw *tabwriter.Writer;
-	if cfg.Mode & RawFormat == 0 {
+	if cfg.Mode&RawFormat == 0 {
 		padchar := byte('\t');
-		if cfg.Mode & UseSpaces != 0 {
+		if cfg.Mode&UseSpaces != 0 {
 			padchar = ' '
 		}
 		twmode := tabwriter.DiscardEmptyColumns;
-		if cfg.Mode & GenHTML != 0 {
+		if cfg.Mode&GenHTML != 0 {
 			twmode |= tabwriter.FilterHTML
 		}
 		tw = tabwriter.NewWriter(output, cfg.Tabwidth, 1, padchar, twmode);
@@ -961,7 +961,7 @@ func (cfg *Config) Fprint(output io.Writer, node interface{}) (int, os.Error) {
 			p.errors <- os.NewError(fmt.Sprintf("printer.Fprint: unsupported node type %T", n));
 			runtime.Goexit();
 		}
-		p.flush(token.Position{Offset: 1<<30, Line: 1<<30}, false);	// flush to "infinity"
+		p.flush(token.Position{Offset: 1 << 30, Line: 1 << 30}, false);	// flush to "infinity"
 		p.errors <- nil;						// no errors
 	}();
 	err := <-p.errors;	// wait for completion of goroutine
diff --git a/src/pkg/go/printer/printer_test.go b/src/pkg/go/printer/printer_test.go
index 6cafc58209..5c10d4a85d 100644
--- a/src/pkg/go/printer/printer_test.go
+++ b/src/pkg/go/printer/printer_test.go
@@ -36,7 +36,7 @@ func lineString(text []byte, i int) string {
 type checkMode uint
 
 const (
-	export	checkMode	= 1<<iota;
+	export	checkMode	= 1 << iota;
 	rawFormat;
 )
 
@@ -57,7 +57,7 @@ func check(t *testing.T, source, golden string, mode checkMode) {
 
 	// determine printer configuration
 	cfg := Config{Tabwidth: tabwidth};
-	if mode & rawFormat != 0 {
+	if mode&rawFormat != 0 {
 		cfg.Mode |= RawFormat
 	}
 
@@ -99,7 +99,7 @@ func check(t *testing.T, source, golden string, mode checkMode) {
 		}
 		if ch == '\n' {
 			line++;
-			offs = i+1;
+			offs = i + 1;
 		}
 	}
 }
diff --git a/src/pkg/go/printer/testdata/declarations.golden b/src/pkg/go/printer/testdata/declarations.golden
index 43ba1fd532..70be9aa2ea 100644
--- a/src/pkg/go/printer/testdata/declarations.golden
+++ b/src/pkg/go/printer/testdata/declarations.golden
@@ -454,5 +454,5 @@ func _()	{}
 func _()	{}
 
 func _()		{ f(1, 2, 3) }
-func _(x int) int	{ return x+1 }
+func _(x int) int	{ return x + 1 }
 func _() int		{ type T struct{} }
diff --git a/src/pkg/go/printer/testdata/expressions.golden b/src/pkg/go/printer/testdata/expressions.golden
index efca110ca5..1d785d91f3 100644
--- a/src/pkg/go/printer/testdata/expressions.golden
+++ b/src/pkg/go/printer/testdata/expressions.golden
@@ -20,27 +20,27 @@ var (
 
 func _() {
 	// no spaces around simple or parenthesized expressions
-	_ = a+b;
-	_ = a+b+c;
-	_ = a+b-c;
-	_ = a-b-c;
-	_ = a+(b*c);
-	_ = a+(b/c);
-	_ = a-(b%c);
-	_ = 1+a;
-	_ = a+1;
-	_ = a+b+1;
+	_ = a + b;
+	_ = a + b + c;
+	_ = a + b - c;
+	_ = a - b - c;
+	_ = a + (b * c);
+	_ = a + (b / c);
+	_ = a - (b % c);
+	_ = 1 + a;
+	_ = a + 1;
+	_ = a + b + 1;
 	_ = s[1:2];
 	_ = s[a:b];
 	_ = s[0:len(s)];
-	_ = s[0]<<1;
-	_ = (s[0]<<1)&0xf;
+	_ = s[0] << 1;
+	_ = (s[0] << 1) & 0xf;
 	_ = s[0]<<2 | s[1]>>4;
-	_ = "foo"+s;
-	_ = s+"foo";
-	_ = 'a'+'b';
-	_ = len(s)/2;
-	_ = len(t0.x)/a;
+	_ = "foo" + s;
+	_ = s + "foo";
+	_ = 'a' + 'b';
+	_ = len(s) / 2;
+	_ = len(t0.x) / a;
 
 	// spaces around expressions of different precedence or expressions containing spaces
 	_ = a + -b;
@@ -54,9 +54,9 @@ func _() {
 	_ = s[1 : 2*3];
 	_ = s[a : b-c];
 	_ = s[a+b : len(s)];
-	_ = s[len(s) : -a];
+	_ = s[len(s):-a];
 	_ = s[a : len(s)+1];
-	_ = s[a : len(s)+1]+s;
+	_ = s[a:len(s)+1] + s;
 
 	// spaces around operators with equal or lower precedence than comparisons
 	_ = a == b;
@@ -71,22 +71,94 @@ func _() {
 	// spaces around "long" operands
 	_ = a + longIdentifier1;
 	_ = longIdentifier1 + a;
-	_ = longIdentifier1 + longIdentifier2 * longIdentifier3;
+	_ = longIdentifier1 + longIdentifier2*longIdentifier3;
 	_ = s + "a longer string";
 
 	// some selected cases
 	_ = a + t0.x;
-	_ = a + t0.x + t1.x * t2.x;
+	_ = a + t0.x + t1.x*t2.x;
 	_ = a + b + c + d + e + 2*3;
 	_ = a + b + c + 2*3 + d + e;
-	_ = (a+b+c)*2;
-	_ = a - b + c - d + (a+b+c) + d&e;
+	_ = (a + b + c) * 2;
+	_ = a - b + c - d + (a + b + c) + d&e;
 	_ = under_bar - 1;
 	_ = Open(dpath+"/file", O_WRONLY|O_CREAT, 0666);
 	_ = int(c0&_Mask4)<<18 | int(c1&_Maskx)<<12 | int(c2&_Maskx)<<6 | int(c3&_Maskx);
 }
 
 
+func _() {
+	a + b;
+	a + b + c;
+	a + b*c;
+	a + (b * c);
+	(a + b) * c;
+	a + (b * c * d);
+	a + (b*c + d);
+
+	1 << x;
+	-1 << x;
+	1<<x - 1;
+	-1<<x - 1;
+
+	f(a + b);
+	f(a + b + c);
+	f(a + b*c);
+	f(a + (b * c));
+	f(1<<x-1, 1<<x-2);
+
+	1<<d.logWindowSize - 1;
+
+	buf = make(x, 2*cap(b.buf)+n);
+
+	dst[i*3+2] = dbuf[0] << 2;
+	dst[i*3+2] = dbuf[0]<<2 | dbuf[1]>>4;
+
+	b.buf = b.buf[0 : b.off+m+n];
+	b.buf = b.buf[0 : b.off+m*n];
+	f(b.buf[0 : b.off+m+n]);
+
+	signed += ' ' * 8;
+	tw.octal(header[148:155], chksum);
+
+	x > 0 && i >= 0;
+
+	x1, x0 := x>>w2, x&m2;
+	z0 = t1<<w2 + t0;
+	z1 = (t1 + t0>>w2) >> w2;
+	q1, r1 := x1/d1, x1%d1;
+	r1 = r1*b2 | x0>>w2;
+	x1 = (x1 << z) | (x0 >> (uint(w) - z));
+	x1 = x1<<z | x0>>(uint(w)-z);
+
+	buf[0 : len(buf)+1];
+	buf[0 : n+1];
+
+	a, b = b, a;
+	a = b + c;
+	a = b*c + d;
+	a*b + c;
+	a - b - c;
+	a - (b - c);
+	a - b*c;
+	a - (b * c);
+	a * b / c;
+	a / *b;
+	x[a|^b];
+	x[a / *b];
+	a & ^b;
+	a + +b;
+	a - -b;
+	x[a*-b];
+	x[a + +b];
+	x ^ y ^ z;
+	b[a>>24] ^ b[(a>>16)&0xFF] ^ b[(a>>8)&0xFF] ^ b[a&0xFF];
+	len(longVariableName) * 2;
+
+	token(matchType + xlength<<lengthShift + xoffset);
+}
+
+
 func _() {
 	_ = T{};
 	_ = struct{}{};
diff --git a/src/pkg/go/printer/testdata/expressions.input b/src/pkg/go/printer/testdata/expressions.input
index 387a1a9769..6ccc9a8335 100644
--- a/src/pkg/go/printer/testdata/expressions.input
+++ b/src/pkg/go/printer/testdata/expressions.input
@@ -87,6 +87,78 @@ func _() {
 }
 
 
+func _() {
+	a+b;
+	a+b+c;
+	a+b*c;
+	a+(b*c);
+	(a+b)*c;
+	a+(b*c*d);
+	a+(b*c+d);
+
+	1<<x;
+	-1<<x;
+	1<<x-1;
+	-1<<x-1;
+
+	f(a+b);
+	f(a+b+c);
+	f(a+b*c);
+	f(a+(b*c));
+	f(1<<x-1, 1<<x-2);
+
+	1<<d.logWindowSize-1;
+
+	buf = make(x, 2*cap(b.buf) + n);
+
+	dst[i*3+2] = dbuf[0]<<2;
+	dst[i*3+2] = dbuf[0]<<2 | dbuf[1]>>4;
+
+	b.buf = b.buf[0:b.off+m+n];
+	b.buf = b.buf[0:b.off+m*n];
+	f(b.buf[0:b.off+m+n]);
+
+	signed += ' '*8;
+	tw.octal(header[148:155], chksum);
+
+	x > 0 && i >= 0;
+
+	x1, x0 := x>>w2, x&m2;
+	z0 = t1<<w2+t0;
+	z1 = (t1+t0>>w2)>>w2;
+	q1, r1 := x1/d1, x1%d1;
+	r1 = r1*b2 | x0>>w2;
+	x1 = (x1<<z)|(x0>>(uint(w)-z));
+	x1 = x1<<z | x0>>(uint(w)-z);
+
+	buf[0:len(buf)+1];
+	buf[0:n+1];
+
+	a,b = b,a;
+	a = b+c;
+	a = b*c+d;
+	a*b+c;
+	a-b-c;
+	a-(b-c);
+	a-b*c;
+	a-(b*c);
+	a*b/c;
+	a/ *b;
+	x[a|^b];
+	x[a/ *b];
+	a& ^b;
+	a+ +b;
+	a- -b;
+	x[a*-b];
+	x[a+ +b];
+	x^y^z;
+	b[a>>24] ^ b[(a>>16)&0xFF] ^ b[(a>>8)&0xFF] ^ b[a&0xFF];
+	len(longVariableName)*2;
+
+	token(matchType + xlength<<lengthShift + xoffset);
+}
+
+
 func _() {
 	_ = T{};
 	_ = struct{}{};
diff --git a/src/pkg/go/printer/testdata/expressions.raw b/src/pkg/go/printer/testdata/expressions.raw
index 29109ba61c..55986e2e62 100644
--- a/src/pkg/go/printer/testdata/expressions.raw
+++ b/src/pkg/go/printer/testdata/expressions.raw
@@ -20,27 +20,27 @@ var (
 
 func _() {
 	// no spaces around simple or parenthesized expressions
-	_ = a+b;
-	_ = a+b+c;
-	_ = a+b-c;
-	_ = a-b-c;
-	_ = a+(b*c);
-	_ = a+(b/c);
-	_ = a-(b%c);
-	_ = 1+a;
-	_ = a+1;
-	_ = a+b+1;
+	_ = a + b;
+	_ = a + b + c;
+	_ = a + b - c;
+	_ = a - b - c;
+	_ = a + (b * c);
+	_ = a + (b / c);
+	_ = a - (b % c);
+	_ = 1 + a;
+	_ = a + 1;
+	_ = a + b + 1;
 	_ = s[1:2];
 	_ = s[a:b];
 	_ = s[0:len(s)];
-	_ = s[0]<<1;
-	_ = (s[0]<<1)&0xf;
+	_ = s[0] << 1;
+	_ = (s[0] << 1) & 0xf;
 	_ = s[0]<<2 | s[1]>>4;
-	_ = "foo"+s;
-	_ = s+"foo";
-	_ = 'a'+'b';
-	_ = len(s)/2;
-	_ = len(t0.x)/a;
+	_ = "foo" + s;
+	_ = s + "foo";
+	_ = 'a' + 'b';
+	_ = len(s) / 2;
+	_ = len(t0.x) / a;
 
 	// spaces around expressions of different precedence or expressions containing spaces
 	_ = a + -b;
@@ -54,9 +54,9 @@ func _() {
 	_ = s[1 : 2*3];
 	_ = s[a : b-c];
 	_ = s[a+b : len(s)];
-	_ = s[len(s) : -a];
+	_ = s[len(s):-a];
 	_ = s[a : len(s)+1];
-	_ = s[a : len(s)+1]+s;
+	_ = s[a:len(s)+1] + s;
 
 	// spaces around operators with equal or lower precedence than comparisons
 	_ = a == b;
@@ -71,22 +71,94 @@ func _() {
 	// spaces around "long" operands
 	_ = a + longIdentifier1;
 	_ = longIdentifier1 + a;
-	_ = longIdentifier1 + longIdentifier2 * longIdentifier3;
+	_ = longIdentifier1 + longIdentifier2*longIdentifier3;
 	_ = s + "a longer string";
 
 	// some selected cases
 	_ = a + t0.x;
-	_ = a + t0.x + t1.x * t2.x;
+	_ = a + t0.x + t1.x*t2.x;
 	_ = a + b + c + d + e + 2*3;
 	_ = a + b + c + 2*3 + d + e;
-	_ = (a+b+c)*2;
-	_ = a - b + c - d + (a+b+c) + d&e;
+	_ = (a + b + c) * 2;
+	_ = a - b + c - d + (a + b + c) + d&e;
 	_ = under_bar - 1;
 	_ = Open(dpath+"/file", O_WRONLY|O_CREAT, 0666);
 	_ = int(c0&_Mask4)<<18 | int(c1&_Maskx)<<12 | int(c2&_Maskx)<<6 | int(c3&_Maskx);
 }
 
 
+func _() {
+	a + b;
+	a + b + c;
+	a + b*c;
+	a + (b * c);
+	(a + b) * c;
+	a + (b * c * d);
+	a + (b*c + d);
+
+	1 << x;
+	-1 << x;
+	1<<x - 1;
+	-1<<x - 1;
+
+	f(a + b);
+	f(a + b + c);
+	f(a + b*c);
+	f(a + (b * c));
+	f(1<<x-1, 1<<x-2);
+
+	1<<d.logWindowSize - 1;
+
+	buf = make(x, 2*cap(b.buf)+n);
+
+	dst[i*3+2] = dbuf[0] << 2;
+	dst[i*3+2] = dbuf[0]<<2 | dbuf[1]>>4;
+
+	b.buf = b.buf[0 : b.off+m+n];
+	b.buf = b.buf[0 : b.off+m*n];
+	f(b.buf[0 : b.off+m+n]);
+
+	signed += ' ' * 8;
+	tw.octal(header[148:155], chksum);
+
+	x > 0 && i >= 0;
+
+	x1, x0 := x>>w2, x&m2;
+	z0 = t1<<w2 + t0;
+	z1 = (t1 + t0>>w2) >> w2;
+	q1, r1 := x1/d1, x1%d1;
+	r1 = r1*b2 | x0>>w2;
+	x1 = (x1 << z) | (x0 >> (uint(w) - z));
+	x1 = x1<<z | x0>>(uint(w)-z);
+
+	buf[0 : len(buf)+1];
+	buf[0 : n+1];
+
+	a, b = b, a;
+	a = b + c;
+	a = b*c + d;
+	a*b + c;
+	a - b - c;
+	a - (b - c);
+	a - b*c;
+	a - (b * c);
+	a * b / c;
+	a / *b;
+	x[a|^b];
+	x[a / *b];
+	a & ^b;
+	a + +b;
+	a - -b;
+	x[a*-b];
+	x[a + +b];
+	x ^ y ^ z;
+	b[a>>24] ^ b[(a>>16)&0xFF] ^ b[(a>>8)&0xFF] ^ b[a&0xFF];
+	len(longVariableName) * 2;
+
+	token(matchType + xlength<<lengthShift + xoffset);
+}
+
+
 func _() {
 	_ = T{};
 	_ = struct{}{};
diff --git a/src/pkg/go/printer/testdata/linebreaks.golden b/src/pkg/go/printer/testdata/linebreaks.golden
index afc5e7b4f1..22ac8dd303 100644
--- a/src/pkg/go/printer/testdata/linebreaks.golden
+++ b/src/pkg/go/printer/testdata/linebreaks.golden
@@ -70,7 +70,7 @@ var writerTests = []*writerTest{
 					Mode: 0640,
 					Uid: 73025,
 					Gid: 5000,
-					Size: 16<<30,
+					Size: 16 << 30,
 					Mtime: 1254699560,
 					Typeflag: '0',
 					Uname: "dsymonds",
diff --git a/src/pkg/go/scanner/scanner.go b/src/pkg/go/scanner/scanner.go
index cc4ff9cc47..8391c693e7 100644
--- a/src/pkg/go/scanner/scanner.go
+++ b/src/pkg/go/scanner/scanner.go
@@ -52,7 +52,7 @@ func (S *Scanner) next() {
 			S.pos.Column = 0;
 		case r >= 0x80:
 			// not ASCII
-			r, w = utf8.DecodeRune(S.src[S.offset : len(S.src)])
+			r, w = utf8.DecodeRune(S.src[S.offset:len(S.src)])
 		}
 		S.offset += w;
 		S.ch = r;
@@ -67,7 +67,7 @@ func (S *Scanner) next() {
 // They control scanner behavior.
 //
 const (
-	ScanComments		= 1<<iota;	// return comments as COMMENT tokens
+	ScanComments		= 1 << iota;	// return comments as COMMENT tokens
 	AllowIllegalChars;	// do not report an error for illegal chars
 )
 
@@ -132,7 +132,7 @@ func (S *Scanner) error(pos token.Position, msg string) {
 
 func (S *Scanner) expect(ch int) {
 	if S.ch != ch {
-		S.error(S.pos, "expected " + charString(ch) + ", found " + charString(S.ch))
+		S.error(S.pos, "expected "+charString(ch)+", found "+charString(S.ch))
 	}
 	S.next();	// always make progress
 }
@@ -151,7 +151,7 @@ func (S *Scanner) scanComment(pos token.Position) {
 				// '\n' is not part of the comment
 				// (the comment ends on the same line where it started)
 				if pos.Column == 1 {
-					text := S.src[pos.Offset + 2 : S.pos.Offset];
+					text := S.src[pos.Offset+2 : S.pos.Offset];
 					if bytes.HasPrefix(text, prefix) {
 						// comment starts at beginning of line with "//line ";
 						// get filename and line number, if any
@@ -202,18 +202,18 @@ func (S *Scanner) scanIdentifier() token.Token {
 	for isLetter(S.ch) || isDigit(S.ch) {
 		S.next()
 	}
-	return token.Lookup(S.src[pos : S.pos.Offset]);
+	return token.Lookup(S.src[pos:S.pos.Offset]);
 }
 
 
 func digitVal(ch int) int {
 	switch {
 	case '0' <= ch && ch <= '9':
-		return ch-'0'
+		return ch - '0'
 	case 'a' <= ch && ch <= 'f':
-		return ch-'a'+10
+		return ch - 'a' + 10
 	case 'A' <= ch && ch <= 'F':
-		return ch-'A'+10
+		return ch - 'A' + 10
 	}
 	return 16;	// larger than any legal digit val
 }
@@ -501,7 +501,7 @@ scan_again:
 			if S.ch == '/' || S.ch == '*' {
 				S.scanComment(pos);
 				tok = token.COMMENT;
-				if S.mode & ScanComments == 0 {
+				if S.mode&ScanComments == 0 {
 					goto scan_again
 				}
 			} else {
@@ -534,13 +534,13 @@ scan_again:
 		case '|':
 			tok = S.switch3(token.OR, token.OR_ASSIGN, '|', token.LOR)
 		default:
-			if S.mode & AllowIllegalChars == 0 {
-				S.error(pos, "illegal character " + charString(ch))
+			if S.mode&AllowIllegalChars == 0 {
+				S.error(pos, "illegal character "+charString(ch))
 			}
 		}
 	}
 
-	return pos, tok, S.src[pos.Offset : S.pos.Offset];
+	return pos, tok, S.src[pos.Offset:S.pos.Offset];
 }
 
 
diff --git a/src/pkg/go/scanner/scanner_test.go b/src/pkg/go/scanner/scanner_test.go
index 3bdd71e64c..be1b44ec72 100644
--- a/src/pkg/go/scanner/scanner_test.go
+++ b/src/pkg/go/scanner/scanner_test.go
@@ -233,7 +233,7 @@ func TestScan(t *testing.T) {
 			if tokenclass(tok) != e.class {
 				t.Errorf("bad class for %s: got %d, expected %d", lit, tokenclass(tok), e.class)
 			}
-			epos.Offset += len(lit)+len(whitespace);
+			epos.Offset += len(lit) + len(whitespace);
 			epos.Line += NewlineCount(lit) + whitespace_linecount;
 			if tok == token.COMMENT && litb[1] == '/' {
 				// correct for unaccounted '/n' in //-style comment
diff --git a/src/pkg/gob/codec_test.go b/src/pkg/gob/codec_test.go
index 4808c1146c..a1491a4a10 100644
--- a/src/pkg/gob/codec_test.go
+++ b/src/pkg/gob/codec_test.go
@@ -34,7 +34,7 @@ var encodeT = []EncodeT{
 	EncodeT{0x1111, []byte{0xFE, 0x11, 0x11}},
 	EncodeT{0x1111111111111111, []byte{0xF8, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11}},
 	EncodeT{0x8888888888888888, []byte{0xF8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88}},
-	EncodeT{1<<63, []byte{0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+	EncodeT{1 << 63, []byte{0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
 }
 
 
@@ -54,7 +54,7 @@ func TestUintCodec(t *testing.T) {
 		}
 	}
 	decState := newDecodeState(b);
-	for u := uint64(0); ; u = (u+1)*7 {
+	for u := uint64(0); ; u = (u + 1) * 7 {
 		b.Reset();
 		encodeUint(encState, u);
 		if encState.err != nil {
@@ -94,7 +94,7 @@ func verifyInt(i int64, t *testing.T) {
 
 // Test basic encode/decode routines for signed integers
 func TestIntCodec(t *testing.T) {
-	for u := uint64(0); ; u = (u+1)*7 {
+	for u := uint64(0); ; u = (u + 1) * 7 {
 		// Do positive and negative values
 		i := int64(u);
 		verifyInt(i, t);
@@ -104,13 +104,13 @@ func TestIntCodec(t *testing.T) {
 			break
 		}
 	}
-	verifyInt(-1 << 63, t);	// a tricky case
+	verifyInt(-1<<63, t);	// a tricky case
 }
 
 // The result of encoding a true boolean with field number 7
 var boolResult = []byte{0x07, 0x01}
 // The result of encoding a number 17 with field number 7
-var signedResult = []byte{0x07, 2*17}
+var signedResult = []byte{0x07, 2 * 17}
 var unsignedResult = []byte{0x07, 17}
 var floatResult = []byte{0x07, 0xFE, 0x31, 0x40}
 // The result of encoding "hello" with field number 6
@@ -326,8 +326,8 @@ func execDec(typ string, instr *decInstr, state *decodeState, t *testing.T, p un
 	if state.err != nil {
 		t.Fatalf("decoding %s field: %v", typ, state.err)
 	}
-	if v + state.fieldnum != 6 {
-		t.Fatalf("decoding field number %d, got %d", 6, v + state.fieldnum)
+	if v+state.fieldnum != 6 {
+		t.Fatalf("decoding field number %d, got %d", 6, v+state.fieldnum)
 	}
 	instr.op(instr, state, decIndirect(p, instr.indir));
 	state.fieldnum = 6;
diff --git a/src/pkg/gob/decode.go b/src/pkg/gob/decode.go
index 2d13318857..a9cdbe684d 100644
--- a/src/pkg/gob/decode.go
+++ b/src/pkg/gob/decode.go
@@ -111,9 +111,9 @@ func decodeInt(state *decodeState) int64 {
 		return 0
 	}
 	if x&1 != 0 {
-		return ^int64(x>>1)
+		return ^int64(x >> 1)
 	}
-	return int64(x>>1);
+	return int64(x >> 1);
 }
 
 type decOp func(i *decInstr, state *decodeState, p unsafe.Pointer)
@@ -279,7 +279,7 @@ func floatFromBits(u uint64) float64 {
 	var v uint64;
 	for i := 0; i < 8; i++ {
 		v <<= 8;
-		v |= u&0xFF;
+		v |= u & 0xFF;
 		u >>= 8;
 	}
 	return math.Float64frombits(v);
@@ -476,7 +476,7 @@ func decodeSlice(atyp *reflect.SliceType, state *decodeState, p uintptr, elemOp
 		p = *(*uintptr)(up);
 	}
 	// Allocate storage for the slice elements, that is, the underlying array.
-	data := make([]byte, length * atyp.Elem().Size());
+	data := make([]byte, length*atyp.Elem().Size());
 	// Always write a header at p.
 	hdrp := (*reflect.SliceHeader)(unsafe.Pointer(p));
 	hdrp.Data = uintptr(unsafe.Pointer(&data[0]));
diff --git a/src/pkg/gob/encode.go b/src/pkg/gob/encode.go
index 4f0e60c86a..d7b4a21c56 100644
--- a/src/pkg/gob/encode.go
+++ b/src/pkg/gob/encode.go
@@ -44,12 +44,12 @@ func encodeUint(state *encoderState, x uint64) {
 	var n, m int;
 	m = uint64Size;
 	for n = 1; x > 0; n++ {
-		state.buf[m] = uint8(x&0xFF);
+		state.buf[m] = uint8(x & 0xFF);
 		x >>= 8;
 		m--;
 	}
-	state.buf[m] = uint8(-(n-1));
-	n, state.err = state.b.Write(state.buf[m : uint64Size + 1]);
+	state.buf[m] = uint8(-(n - 1));
+	n, state.err = state.b.Write(state.buf[m : uint64Size+1]);
 }
 
 // encodeInt writes an encoded signed integer to state.w.
@@ -58,9 +58,9 @@ func encodeUint(state *encoderState, x uint64) {
 func encodeInt(state *encoderState, i int64) {
 	var x uint64;
 	if i < 0 {
-		x = uint64(^i << 1)|1
+		x = uint64(^i<<1) | 1
 	} else {
-		x = uint64(i<<1)
+		x = uint64(i << 1)
 	}
 	encodeUint(state, uint64(x));
 }
@@ -79,7 +79,7 @@ type encInstr struct {
 // If the instruction pointer is nil, do nothing
 func (state *encoderState) update(instr *encInstr) {
 	if instr != nil {
-		encodeUint(state, uint64(instr.field - state.fieldnum));
+		encodeUint(state, uint64(instr.field-state.fieldnum));
 		state.fieldnum = instr.field;
 	}
 }
@@ -206,7 +206,7 @@ func floatBits(f float64) uint64 {
 	var v uint64;
 	for i := 0; i < 8; i++ {
 		v <<= 8;
-		v |= u&0xFF;
+		v |= u & 0xFF;
 		u >>= 8;
 	}
 	return v;
@@ -396,7 +396,7 @@ func compileEnc(rt reflect.Type) (*encEngine, os.Error) {
 		panicln("can't happen: non-struct")
 	}
 	engine := new(encEngine);
-	engine.instr = make([]encInstr, srt.NumField() + 1);	// +1 for terminator
+	engine.instr = make([]encInstr, srt.NumField()+1);	// +1 for terminator
 	for fieldnum := 0; fieldnum < srt.NumField(); fieldnum++ {
 		f := srt.Field(fieldnum);
 		op, indir, err := encOpFor(f.Type);
