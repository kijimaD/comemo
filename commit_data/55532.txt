commit 95be547e0a7d284bc8bbad27f0904d042144ea98
Author: Matthew Dempsky <mdempsky@google.com>
Date:   Thu Feb 16 15:54:25 2023 -0800

    Revert "cmd/compile: use ONAME node directly from generated hash func"
    
    This reverts commit 25f5d9d4a253cb880bff909ebbdc05c8941c4a48.
    
    Causes ICE on valid code.
    
    Updates #58572.
    
    Change-Id: Ib276c87d9b0362bbd2a760ac2a242f82d4e20400
    Reviewed-on: https://go-review.googlesource.com/c/go/+/468879
    Reviewed-by: Cuong Manh Le <cuong.manhle.vn@gmail.com>
    Run-TryBot: Matthew Dempsky <mdempsky@google.com>
    Auto-Submit: Matthew Dempsky <mdempsky@google.com>
    Reviewed-by: Keith Randall <khr@google.com>
    TryBot-Result: Gopher Robot <gobot@golang.org>
---
 src/cmd/compile/internal/reflectdata/alg.go | 31 +++++++++++++++++++----------
 1 file changed, 20 insertions(+), 11 deletions(-)

diff --git a/src/cmd/compile/internal/reflectdata/alg.go b/src/cmd/compile/internal/reflectdata/alg.go
index e793d4920d..9201a1999f 100644
--- a/src/cmd/compile/internal/reflectdata/alg.go
+++ b/src/cmd/compile/internal/reflectdata/alg.go
@@ -134,11 +134,6 @@ func genhash(t *types.Type) *obj.LSym {
 }
 
 func hashFunc(t *types.Type) *ir.Func {
-	sym := TypeSymPrefix(".hash", t)
-	if sym.Def != nil {
-		return sym.Def.(*ir.Name).Func
-	}
-
 	base.Pos = base.AutogeneratedPos // less confusing than end of input
 	typecheck.DeclContext = ir.PEXTERN
 
@@ -149,8 +144,8 @@ func hashFunc(t *types.Type) *ir.Func {
 	}
 	results := []*ir.Field{ir.NewField(base.Pos, nil, types.Types[types.TUINTPTR])}
 
+	sym := TypeSymPrefix(".hash", t)
 	fn := typecheck.DeclFunc(sym, nil, args, results)
-	sym.Def = fn.Nname
 	np := ir.AsNode(fn.Type().Params().Field(0).Nname)
 	nh := ir.AsNode(fn.Type().Params().Field(1).Nname)
 
@@ -236,9 +231,9 @@ func hashFunc(t *types.Type) *ir.Func {
 	fn.SetDupok(true)
 	typecheck.Func(fn)
 
-	ir.WithFunc(fn, func() {
-		typecheck.Stmts(fn.Body)
-	})
+	ir.CurFunc = fn
+	typecheck.Stmts(fn.Body)
+	ir.CurFunc = nil
 
 	fn.SetNilCheckDisabled(true)
 	typecheck.Target.Decls = append(typecheck.Target.Decls, fn)
@@ -254,6 +249,8 @@ func runtimeHashFor(name string, t *types.Type) *ir.Name {
 
 // hashfor returns the function to compute the hash of a value of type t.
 func hashfor(t *types.Type) *ir.Name {
+	var sym *types.Sym
+
 	switch a, _ := types.AlgType(t); a {
 	case types.AMEM:
 		base.Fatalf("hashfor with AMEM type")
@@ -271,10 +268,22 @@ func hashfor(t *types.Type) *ir.Name {
 		return runtimeHashFor("c64hash", t)
 	case types.ACPLX128:
 		return runtimeHashFor("c128hash", t)
+	default:
+		// Note: the caller of hashfor ensured that this symbol
+		// exists and has a body by calling genhash for t.
+		sym = TypeSymPrefix(".hash", t)
 	}
 
-	fn := hashFunc(t)
-	return fn.Nname
+	// TODO(austin): This creates an ir.Name with a nil Func.
+	n := typecheck.NewName(sym)
+	ir.MarkFunc(n)
+	n.SetType(types.NewSignature(nil, []*types.Field{
+		types.NewField(base.Pos, nil, types.NewPtr(t)),
+		types.NewField(base.Pos, nil, types.Types[types.TUINTPTR]),
+	}, []*types.Field{
+		types.NewField(base.Pos, nil, types.Types[types.TUINTPTR]),
+	}))
+	return n
 }
 
 // sysClosure returns a closure which will call the
