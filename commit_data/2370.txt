commit 7f9d2c8264138ff2512595288bc7b0fe5245ab68
Author: Russ Cox <rsc@golang.org>
Date:   Tue Jun 2 23:22:25 2009 -0700

    mechanically-generated syscall files
    
    R=r
    DELTA=1615  (1615 added, 0 deleted, 0 changed)
    OCL=29803
    CL=29810
---
 src/lib/syscall/zerrors_darwin_386.go  | 260 ++++++++++++++
 src/lib/syscall/zsyscall_darwin_386.go | 624 +++++++++++++++++++++++++++++++++
 src/lib/syscall/zsysnum_darwin_386.go  | 485 +++++++++++++++++++++++++
 src/lib/syscall/ztypes_darwin_386.go   | 246 +++++++++++++
 4 files changed, 1615 insertions(+)

diff --git a/src/lib/syscall/zerrors_darwin_386.go b/src/lib/syscall/zerrors_darwin_386.go
new file mode 100644
index 0000000000..bc2d17656f
--- /dev/null
+++ b/src/lib/syscall/zerrors_darwin_386.go
@@ -0,0 +1,260 @@
+// mkerrors
+// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
+
+// godefs -gsyscall _errors.c
+
+// MACHINE GENERATED - DO NOT EDIT.
+
+package syscall
+
+// Constants
+const (
+	EMULTIHOP = 0x5f;
+	EAFNOSUPPORT = 0x2f;
+	EACCES = 0xd;
+	EDESTADDRREQ = 0x27;
+	EILSEQ = 0x5c;
+	ESPIPE = 0x1d;
+	EMLINK = 0x1f;
+	EPROGUNAVAIL = 0x4a;
+	ENOTTY = 0x19;
+	EBADF = 0x9;
+	ERANGE = 0x22;
+	ECANCELED = 0x59;
+	ETXTBSY = 0x1a;
+	ENOMEM = 0xc;
+	EINPROGRESS = 0x24;
+	ENOTEMPTY = 0x42;
+	ENOTBLK = 0xf;
+	EPROTOTYPE = 0x29;
+	ENOMSG = 0x5b;
+	ERPCMISMATCH = 0x49;
+	ENOTDIR = 0x14;
+	EALREADY = 0x25;
+	ETIMEDOUT = 0x3c;
+	ENEEDAUTH = 0x51;
+	ENODATA = 0x60;
+	EINTR = 0x4;
+	ENOLINK = 0x61;
+	EPERM = 0x1;
+	ENETDOWN = 0x32;
+	ESTALE = 0x46;
+	ENOTSOCK = 0x26;
+	ENOSR = 0x62;
+	EAUTH = 0x50;
+	ECHILD = 0xa;
+	EPIPE = 0x20;
+	ENOATTR = 0x5d;
+	EBADMSG = 0x5e;
+	EREMOTE = 0x47;
+	ETOOMANYREFS = 0x3b;
+	EPFNOSUPPORT = 0x2e;
+	EPROCUNAVAIL = 0x4c;
+	EADDRINUSE = 0x30;
+	ENETRESET = 0x34;
+	EISDIR = 0x15;
+	EIDRM = 0x5a;
+	EDEVERR = 0x53;
+	EINVAL = 0x16;
+	ESHUTDOWN = 0x3a;
+	EPWROFF = 0x52;
+	EOVERFLOW = 0x54;
+	EBUSY = 0x10;
+	EPROCLIM = 0x43;
+	EPROTO = 0x64;
+	ENODEV = 0x13;
+	EROFS = 0x1e;
+	E2BIG = 0x7;
+	EDEADLK = 0xb;
+	ECONNRESET = 0x36;
+	EBADMACHO = 0x58;
+	ENXIO = 0x6;
+	EBADRPC = 0x48;
+	ENAMETOOLONG = 0x3f;
+	ELAST = 0x67;
+	ESOCKTNOSUPPORT = 0x2c;
+	EADDRNOTAVAIL = 0x31;
+	ETIME = 0x65;
+	EPROTONOSUPPORT = 0x2b;
+	EIO = 0x5;
+	ENETUNREACH = 0x33;
+	EXDEV = 0x12;
+	EDQUOT = 0x45;
+	ENOSPC = 0x1c;
+	ENOEXEC = 0x8;
+	EMSGSIZE = 0x28;
+	EFTYPE = 0x4f;
+	EDOM = 0x21;
+	ENOSTR = 0x63;
+	EFBIG = 0x1b;
+	ESRCH = 0x3;
+	EHOSTDOWN = 0x40;
+	ENOLCK = 0x4d;
+	ENFILE = 0x17;
+	ENOSYS = 0x4e;
+	EBADARCH = 0x56;
+	ENOTCONN = 0x39;
+	ENOTSUP = 0x2d;
+	ECONNABORTED = 0x35;
+	EISCONN = 0x38;
+	ESHLIBVERS = 0x57;
+	EUSERS = 0x44;
+	ENOPROTOOPT = 0x2a;
+	EMFILE = 0x18;
+	ELOOP = 0x3e;
+	ENOBUFS = 0x37;
+	EFAULT = 0xe;
+	EWOULDBLOCK = 0x23;
+	EBADEXEC = 0x55;
+	ENOPOLICY = 0x67;
+	ECONNREFUSED = 0x3d;
+	EAGAIN = 0x23;
+	EEXIST = 0x11;
+	EPROGMISMATCH = 0x4b;
+	ENOENT = 0x2;
+	EHOSTUNREACH = 0x41;
+	EOPNOTSUPP = 0x66;
+	SIGBUS = 0xa;
+	SIGTTIN = 0x15;
+	SIGPROF = 0x1b;
+	SIGFPE = 0x8;
+	SIGHUP = 0x1;
+	SIGTTOU = 0x16;
+	SIGUSR1 = 0x1e;
+	SIGURG = 0x10;
+	SIGQUIT = 0x3;
+	SIGIO = 0x17;
+	SIGABRT = 0x6;
+	SIGINFO = 0x1d;
+	SIGUSR2 = 0x1f;
+	SIGTRAP = 0x5;
+	SIGVTALRM = 0x1a;
+	SIGSEGV = 0xb;
+	SIGCONT = 0x13;
+	SIGPIPE = 0xd;
+	SIGXFSZ = 0x19;
+	SIGCHLD = 0x14;
+	SIGSYS = 0xc;
+	SIGSTOP = 0x11;
+	SIGALRM = 0xe;
+	SIGTSTP = 0x12;
+	SIGEMT = 0x7;
+	SIGKILL = 0x9;
+	SIGXCPU = 0x18;
+	SIGILL = 0x4;
+	SIGINT = 0x2;
+	SIGIOT = 0x6;
+	SIGTERM = 0xf;
+	SIGWINCH = 0x1c;
+)
+
+// Types
+
+
+// Error table
+var errors = [...]string {
+	95: "EMULTIHOP (Reserved)",
+	47: "address family not supported by protocol family",
+	13: "permission denied",
+	39: "destination address required",
+	92: "illegal byte sequence",
+	29: "illegal seek",
+	31: "too many links",
+	74: "RPC prog. not avail",
+	25: "inappropriate ioctl for device",
+	9: "bad file descriptor",
+	34: "result too large",
+	89: "operation canceled",
+	26: "text file busy",
+	12: "cannot allocate memory",
+	36: "operation now in progress",
+	66: "directory not empty",
+	15: "block device required",
+	41: "protocol wrong type for socket",
+	91: "no message of desired type",
+	73: "RPC version wrong",
+	20: "not a directory",
+	37: "operation already in progress",
+	60: "operation timed out",
+	81: "need authenticator",
+	96: "no message available on STREAM",
+	4: "interrupted system call",
+	97: "ENOLINK (Reserved)",
+	1: "operation not permitted",
+	50: "network is down",
+	70: "stale NFS file handle",
+	38: "socket operation on non-socket",
+	98: "no STREAM resources",
+	80: "authentication error",
+	10: "no child processes",
+	32: "broken pipe",
+	93: "attribute not found",
+	94: "bad message",
+	71: "too many levels of remote in path",
+	59: "too many references: can't splice",
+	46: "protocol family not supported",
+	76: "bad procedure for program",
+	48: "address already in use",
+	52: "network dropped connection on reset",
+	21: "is a directory",
+	90: "identifier removed",
+	83: "device error",
+	22: "invalid argument",
+	58: "can't send after socket shutdown",
+	82: "device power is off",
+	84: "value too large to be stored in data type",
+	16: "resource busy",
+	67: "too many processes",
+	100: "protocol error",
+	19: "operation not supported by device",
+	30: "read-only file system",
+	7: "argument list too long",
+	11: "resource deadlock avoided",
+	54: "connection reset by peer",
+	88: "malformed Mach-o file",
+	6: "device not configured",
+	72: "RPC struct is bad",
+	63: "file name too long",
+	103: "policy not found",
+	44: "socket type not supported",
+	49: "can't assign requested address",
+	101: "STREAM ioctl timeout",
+	43: "protocol not supported",
+	5: "input/output error",
+	51: "network is unreachable",
+	18: "cross-device link",
+	69: "disc quota exceeded",
+	28: "no space left on device",
+	8: "exec format error",
+	40: "message too long",
+	79: "inappropriate file type or format",
+	33: "numerical argument out of domain",
+	99: "not a STREAM",
+	27: "file too large",
+	3: "no such process",
+	64: "host is down",
+	77: "no locks available",
+	23: "too many open files in system",
+	78: "function not implemented",
+	86: "bad CPU type in executable",
+	57: "socket is not connected",
+	45: "operation not supported",
+	53: "software caused connection abort",
+	56: "socket is already connected",
+	87: "shared library version mismatch",
+	68: "too many users",
+	42: "protocol not available",
+	24: "too many open files",
+	62: "too many levels of symbolic links",
+	55: "no buffer space available",
+	14: "bad address",
+	35: "resource temporarily unavailable",
+	85: "bad executable (or shared library)",
+	61: "connection refused",
+	17: "file exists",
+	75: "program version wrong",
+	2: "no such file or directory",
+	65: "no route to host",
+	102: "operation not supported on socket",
+}
+
diff --git a/src/lib/syscall/zsyscall_darwin_386.go b/src/lib/syscall/zsyscall_darwin_386.go
new file mode 100644
index 0000000000..61f7c01db4
--- /dev/null
+++ b/src/lib/syscall/zsyscall_darwin_386.go
@@ -0,0 +1,624 @@
+// mksyscall -l32 syscall_darwin.go syscall_darwin_386.go
+// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
+
+package syscall
+
+import (
+	"syscall";
+	"unsafe";
+)
+
+func getgroups(ngid int, gid *_Gid_t) (n int, errno int) {
+	r0, r1, e1 := Syscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func setgroups(ngid int, gid *_Gid_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0);
+	errno = int(e1);
+	return;
+}
+
+func wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, errno int) {
+	r0, r1, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0);
+	wpid = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func pipe() (r int, w int, errno int) {
+	r0, r1, e1 := Syscall(SYS_PIPE, 0, 0, 0);
+	r = int(r0);
+	w = int(r1);
+	errno = int(e1);
+	return;
+}
+
+func lseek(fd int, offset int64, whence int) (newoffset uintptr, errno int) {
+	r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(offset >> 32), uintptr(whence), 0, 0);
+	newoffset = uintptr(r0);
+	errno = int(e1);
+	return;
+}
+
+func accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func bind(s int, addr uintptr, addrlen _Socklen) (errno int) {
+	r0, r1, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen));
+	errno = int(e1);
+	return;
+}
+
+func connect(s int, addr uintptr, addrlen _Socklen) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen));
+	errno = int(e1);
+	return;
+}
+
+func socket(domain int, typ int, proto int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto));
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func setsockopt(s int, level int, name int, val uintptr, vallen int) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0);
+	errno = int(e1);
+	return;
+}
+
+func kevent(kq int, change uintptr, nchange int, event uintptr, nevent int, timeout *Timespec) (n int, errno int) {
+	r0, r1, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func fcntl(fd int, cmd int, arg int) (val int, errno int) {
+	r0, r1, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg));
+	val = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Access(path string, flags int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
+	errno = int(e1);
+	return;
+}
+
+func Adjtime(delta *Timeval, olddelta *Timeval) (errno int) {
+	r0, r1, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Chdir(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Chflags(path string, flags int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
+	errno = int(e1);
+	return;
+}
+
+func Chmod(path string, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Chown(path string, uid int, gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
+	errno = int(e1);
+	return;
+}
+
+func Chroot(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Close(fd int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Dup(fd int) (nfd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0);
+	nfd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Dup2(from int, to int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0);
+	errno = int(e1);
+	return;
+}
+
+func Exchangedata(path1 string, path2 string, options int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_EXCHANGEDATA, uintptr(unsafe.Pointer(StringBytePtr(path1))), uintptr(unsafe.Pointer(StringBytePtr(path2))), uintptr(options));
+	errno = int(e1);
+	return;
+}
+
+func Exit(code int) () {
+	r0, r1, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0);
+	return;
+}
+
+func Fchdir(fd int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Fchflags(path string, flags int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FCHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
+	errno = int(e1);
+	return;
+}
+
+func Fchmod(fd int, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Fchown(fd int, uid int, gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid));
+	errno = int(e1);
+	return;
+}
+
+func Flock(fd int, how int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0);
+	errno = int(e1);
+	return;
+}
+
+func Fpathconf(fd int, name int) (val int, errno int) {
+	r0, r1, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0);
+	val = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Fstat(fd int, stat *Stat_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Fstatfs(fd int, stat *Statfs_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FSTATFS64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Fsync(fd int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Ftruncate(fd int, length int64) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length >> 32));
+	errno = int(e1);
+	return;
+}
+
+func Getdirentries(fd int, buf []byte, basep *uintptr) (n int, errno int) {
+	var _p0 *byte;
+	if len(buf) > 0 { _p0 = &buf[0]; }
+	r0, r1, e1 := Syscall6(SYS_GETDIRENTRIES64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Getdtablesize() (size int) {
+	r0, r1, e1 := Syscall(SYS_GETDTABLESIZE, 0, 0, 0);
+	size = int(r0);
+	return;
+}
+
+func Getegid() (egid int) {
+	r0, r1, e1 := Syscall(SYS_GETEGID, 0, 0, 0);
+	egid = int(r0);
+	return;
+}
+
+func Geteuid() (uid int) {
+	r0, r1, e1 := Syscall(SYS_GETEUID, 0, 0, 0);
+	uid = int(r0);
+	return;
+}
+
+func Getfsstat(buf []Statfs_t, flags int) (n int, errno int) {
+	var _p0 *Statfs_t;
+	if len(buf) > 0 { _p0 = &buf[0]; }
+	r0, r1, e1 := Syscall(SYS_GETFSSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Getgid() (gid int) {
+	r0, r1, e1 := Syscall(SYS_GETGID, 0, 0, 0);
+	gid = int(r0);
+	return;
+}
+
+func Getpgid(pid int) (pgid int, errno int) {
+	r0, r1, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0);
+	pgid = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Getpgrp() (pgrp int) {
+	r0, r1, e1 := Syscall(SYS_GETPGRP, 0, 0, 0);
+	pgrp = int(r0);
+	return;
+}
+
+func Getpid() (pid int) {
+	r0, r1, e1 := Syscall(SYS_GETPID, 0, 0, 0);
+	pid = int(r0);
+	return;
+}
+
+func Getppid() (ppid int) {
+	r0, r1, e1 := Syscall(SYS_GETPPID, 0, 0, 0);
+	ppid = int(r0);
+	return;
+}
+
+func Getpriority(which int, who int) (prio int, errno int) {
+	r0, r1, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0);
+	prio = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Getrlimit(which int, lim *Rlimit) (errno int) {
+	r0, r1, e1 := Syscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Getrusage(who int, rusage *Rusage) (errno int) {
+	r0, r1, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Getsid(pid int) (sid int, errno int) {
+	r0, r1, e1 := Syscall(SYS_GETSID, uintptr(pid), 0, 0);
+	sid = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Getuid() (uid int) {
+	r0, r1, e1 := Syscall(SYS_GETUID, 0, 0, 0);
+	uid = int(r0);
+	return;
+}
+
+func Issetugid() (tainted bool) {
+	r0, r1, e1 := Syscall(SYS_ISSETUGID, 0, 0, 0);
+	tainted = bool(r0 != 0);
+	return;
+}
+
+func Kill(pid int, signum int, posix int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), uintptr(posix));
+	errno = int(e1);
+	return;
+}
+
+func Kqueue() (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_KQUEUE, 0, 0, 0);
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Lchown(path string, uid int, gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
+	errno = int(e1);
+	return;
+}
+
+func Link(path string, link string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Listen(s int, backlog int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0);
+	errno = int(e1);
+	return;
+}
+
+func Lstat(path string, stat *Stat_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Mkdir(path string, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Mkfifo(path string, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Mknod(path string, mode int, dev int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev));
+	errno = int(e1);
+	return;
+}
+
+func Open(path string, mode int, perm int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm));
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Pathconf(path string, name int) (val int, errno int) {
+	r0, r1, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(name), 0);
+	val = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Pread(fd int, p []byte, offset int64) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset >> 32), 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset >> 32), 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Read(fd int, p []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Readlink(path string, buf []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(buf) > 0 { _p0 = &buf[0]; }
+	r0, r1, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Rename(from string, to string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(from))), uintptr(unsafe.Pointer(StringBytePtr(to))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Revoke(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Rmdir(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setegid(egid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETEGID, uintptr(egid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Seteuid(euid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETEUID, uintptr(euid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setgid(gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETGID, uintptr(gid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setlogin(name string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(StringBytePtr(name))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setpgid(pid int, pgid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setpriority(which int, who int, prio int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio));
+	errno = int(e1);
+	return;
+}
+
+func Setprivexec(flag int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETPRIVEXEC, uintptr(flag), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setregid(rgid int, egid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setreuid(ruid int, euid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setrlimit(which int, lim *Rlimit) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setsid() (pid int, errno int) {
+	r0, r1, e1 := Syscall(SYS_SETSID, 0, 0, 0);
+	pid = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Settimeofday(tp *Timeval) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setuid(uid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Stat(path string, stat *Stat_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Statfs(path string, stat *Statfs_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Symlink(path string, link string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Sync() (errno int) {
+	r0, r1, e1 := Syscall(SYS_SYNC, 0, 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Truncate(path string, length int64) (errno int) {
+	r0, r1, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), uintptr(length >> 32));
+	errno = int(e1);
+	return;
+}
+
+func Umask(newmask int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UMASK, uintptr(newmask), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Undelete(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Unlink(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Unmount(path string, flags int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
+	errno = int(e1);
+	return;
+}
+
+func Write(fd int, p []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func read(fd int, buf *byte, nbuf int) (n int, errno int) {
+	r0, r1, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func write(fd int, buf *byte, nbuf int) (n int, errno int) {
+	r0, r1, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func gettimeofday(tp *Timeval) (sec int64, usec int32, errno int) {
+	r0, r1, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0);
+	sec = int64(r0);
+	usec = int32(r1);
+	errno = int(e1);
+	return;
+}
+
+
+
diff --git a/src/lib/syscall/zsysnum_darwin_386.go b/src/lib/syscall/zsysnum_darwin_386.go
new file mode 100644
index 0000000000..c4c48c2a20
--- /dev/null
+++ b/src/lib/syscall/zsysnum_darwin_386.go
@@ -0,0 +1,485 @@
+// mksysnum_darwin /home/rsc/pub/xnu-1228/bsd/kern/syscalls.master
+// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT
+
+package syscall
+
+const (
+	// SYS_NOSYS = 0;  // { int nosys(void); }   { indirect syscall }
+	SYS_EXIT = 1;  // { void exit(int rval); }
+	SYS_FORK = 2;  // { int fork(void); }
+	SYS_READ = 3;  // { user_ssize_t read(int fd, user_addr_t cbuf, user_size_t nbyte); }
+	SYS_WRITE = 4;  // { user_ssize_t write(int fd, user_addr_t cbuf, user_size_t nbyte); }
+	SYS_OPEN = 5;  // { int open(user_addr_t path, int flags, int mode); }
+	SYS_CLOSE = 6;  // { int close(int fd); }
+	SYS_WAIT4 = 7;  // { int wait4(int pid, user_addr_t status, int options, user_addr_t rusage); }
+	// SYS_NOSYS = 8;  // { int nosys(void); }   { old creat }
+	SYS_LINK = 9;  // { int link(user_addr_t path, user_addr_t link); }
+	SYS_UNLINK = 10;  // { int unlink(user_addr_t path); }
+	// SYS_NOSYS = 11;  // { int nosys(void); }   { old execv }
+	SYS_CHDIR = 12;  // { int chdir(user_addr_t path); }
+	SYS_FCHDIR = 13;  // { int fchdir(int fd); }
+	SYS_MKNOD = 14;  // { int mknod(user_addr_t path, int mode, int dev); }
+	SYS_CHMOD = 15;  // { int chmod(user_addr_t path, int mode); }
+	SYS_CHOWN = 16;  // { int chown(user_addr_t path, int uid, int gid); }
+	SYS_OGETFSSTAT = 18;  // { int ogetfsstat(user_addr_t buf, int bufsize, int flags); }
+	SYS_GETFSSTAT = 18;  // { int getfsstat(user_addr_t buf, int bufsize, int flags); }
+	// SYS_NOSYS = 19;  // { int nosys(void); }   { old lseek }
+	SYS_GETPID = 20;  // { int getpid(void); }
+	// SYS_NOSYS = 21;  // { int nosys(void); }   { old mount }
+	// SYS_NOSYS = 22;  // { int nosys(void); }   { old umount }
+	SYS_SETUID = 23;  // { int setuid(uid_t uid); }
+	SYS_GETUID = 24;  // { int getuid(void); }
+	SYS_GETEUID = 25;  // { int geteuid(void); }
+	SYS_PTRACE = 26;  // { int ptrace(int req, pid_t pid, caddr_t addr, int data); }
+	SYS_RECVMSG = 27;  // { int recvmsg(int s, struct msghdr *msg, int flags); }
+	SYS_SENDMSG = 28;  // { int sendmsg(int s, caddr_t msg, int flags); }
+	SYS_RECVFROM = 29;  // { int recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, int *fromlenaddr); }
+	SYS_ACCEPT = 30;  // { int accept(int s, caddr_t name, socklen_t	*anamelen); }
+	SYS_GETPEERNAME = 31;  // { int getpeername(int fdes, caddr_t asa, socklen_t *alen); }
+	SYS_GETSOCKNAME = 32;  // { int getsockname(int fdes, caddr_t asa, socklen_t *alen); }
+	// SYS_NOSYS = 27;  // { int nosys(void); }
+	// SYS_NOSYS = 28;  // { int nosys(void); }
+	// SYS_NOSYS = 29;  // { int nosys(void); }
+	// SYS_NOSYS = 30;  // { int nosys(void); }
+	// SYS_NOSYS = 31;  // { int nosys(void); }
+	// SYS_NOSYS = 32;  // { int nosys(void); }
+	SYS_ACCESS = 33;  // { int access(user_addr_t path, int flags); }
+	SYS_CHFLAGS = 34;  // { int chflags(char *path, int flags); }
+	SYS_FCHFLAGS = 35;  // { int fchflags(int fd, int flags); }
+	SYS_SYNC = 36;  // { int sync(void); }
+	SYS_KILL = 37;  // { int kill(int pid, int signum, int posix); }
+	// SYS_NOSYS = 38;  // { int nosys(void); }   { old stat  }
+	SYS_GETPPID = 39;  // { int getppid(void); }
+	// SYS_NOSYS = 40;  // { int nosys(void); }   { old lstat }
+	SYS_DUP = 41;  // { int dup(u_int fd); }
+	SYS_PIPE = 42;  // { int pipe(void); }
+	SYS_GETEGID = 43;  // { int getegid(void); }
+	SYS_PROFIL = 44;  // { int profil(short *bufbase, size_t bufsize, u_long pcoffset, u_int pcscale); }
+	// SYS_NOSYS = 45;  // { int nosys(void); } { old ktrace }
+	SYS_SIGACTION = 46;  // { int sigaction(int signum, struct __sigaction *nsa, struct sigaction *osa); }
+	SYS_GETGID = 47;  // { int getgid(void); }
+	SYS_SIGPROCMASK = 48;  // { int sigprocmask(int how, user_addr_t mask, user_addr_t omask); }
+	SYS_GETLOGIN = 49;  // { int getlogin(char *namebuf, u_int namelen); }
+	SYS_SETLOGIN = 50;  // { int setlogin(char *namebuf); }
+	SYS_ACCT = 51;  // { int acct(char *path); }
+	SYS_SIGPENDING = 52;  // { int sigpending(struct sigvec *osv); }
+	SYS_SIGALTSTACK = 53;  // { int sigaltstack(struct sigaltstack *nss, struct sigaltstack *oss); }
+	SYS_IOCTL = 54;  // { int ioctl(int fd, u_long com, caddr_t data); }
+	SYS_REBOOT = 55;  // { int reboot(int opt, char *command); }
+	SYS_REVOKE = 56;  // { int revoke(char *path); }
+	SYS_SYMLINK = 57;  // { int symlink(char *path, char *link); }
+	SYS_READLINK = 58;  // { int readlink(char *path, char *buf, int count); }
+	SYS_EXECVE = 59;  // { int execve(char *fname, char **argp, char **envp); }
+	SYS_UMASK = 60;  // { int umask(int newmask); }
+	SYS_CHROOT = 61;  // { int chroot(user_addr_t path); }
+	// SYS_NOSYS = 62;  // { int nosys(void); }   { old fstat }
+	// SYS_NOSYS = 63;  // { int nosys(void); }   { used internally, reserved }
+	// SYS_NOSYS = 64;  // { int nosys(void); }   { old getpagesize }
+	SYS_MSYNC = 65;  // { int msync(caddr_t addr, size_t len, int flags); }
+	SYS_VFORK = 66;  // { int vfork(void); }
+	// SYS_NOSYS = 67;  // { int nosys(void); }   { old vread }
+	// SYS_NOSYS = 68;  // { int nosys(void); }   { old vwrite }
+	SYS_SBRK = 69;  // { int sbrk(int incr) NO_SYSCALL_STUB; }
+	SYS_SSTK = 70;  // { int sstk(int incr) NO_SYSCALL_STUB; }
+	// SYS_NOSYS = 71;  // { int nosys(void); }   { old mmap }
+	SYS_OVADVISE = 72;  // { int ovadvise(void) NO_SYSCALL_STUB; }   { old vadvise }
+	SYS_MUNMAP = 73;  // { int munmap(caddr_t addr, size_t len); }
+	SYS_MPROTECT = 74;  // { int mprotect(caddr_t addr, size_t len, int prot); }
+	SYS_MADVISE = 75;  // { int madvise(caddr_t addr, size_t len, int behav); }
+	// SYS_NOSYS = 76;  // { int nosys(void); }   { old vhangup }
+	// SYS_NOSYS = 77;  // { int nosys(void); }   { old vlimit }
+	SYS_MINCORE = 78;  // { int mincore(user_addr_t addr, user_size_t len, user_addr_t vec); }
+	SYS_GETGROUPS = 79;  // { int getgroups(u_int gidsetsize, gid_t *gidset); }
+	SYS_SETGROUPS = 80;  // { int setgroups(u_int gidsetsize, gid_t *gidset); }
+	SYS_GETPGRP = 81;  // { int getpgrp(void); }
+	SYS_SETPGID = 82;  // { int setpgid(int pid, int pgid); }
+	SYS_SETITIMER = 83;  // { int setitimer(u_int which, struct itimerval *itv, struct itimerval *oitv); }
+	// SYS_NOSYS = 84;  // { int nosys(void); }   { old wait }
+	SYS_SWAPON = 85;  // { int swapon(void); }
+	SYS_GETITIMER = 86;  // { int getitimer(u_int which, struct itimerval *itv); }
+	// SYS_NOSYS = 87;  // { int nosys(void); }   { old gethostname }
+	// SYS_NOSYS = 88;  // { int nosys(void); }   { old sethostname }
+	SYS_GETDTABLESIZE = 89;  // { int getdtablesize(void); }
+	SYS_DUP2 = 90;  // { int dup2(u_int from, u_int to); }
+	// SYS_NOSYS = 91;  // { int nosys(void); }   { old getdopt }
+	SYS_FCNTL = 92;  // { int fcntl(int fd, int cmd, long arg); }
+	SYS_SELECT = 93;  // { int select(int nd, u_int32_t *in, u_int32_t *ou, u_int32_t *ex, struct timeval *tv); }
+	// SYS_NOSYS = 94;  // { int nosys(void); }   { old setdopt }
+	SYS_FSYNC = 95;  // { int fsync(int fd); }
+	SYS_SETPRIORITY = 96;  // { int setpriority(int which, id_t who, int prio); }
+	SYS_SOCKET = 97;  // { int socket(int domain, int type, int protocol); }
+	SYS_CONNECT = 98;  // { int connect(int s, caddr_t name, socklen_t namelen); }
+	// SYS_NOSYS = 97;  // { int nosys(void); }
+	// SYS_NOSYS = 98;  // { int nosys(void); }
+	// SYS_NOSYS = 99;  // { int nosys(void); }   { old accept }
+	SYS_GETPRIORITY = 100;  // { int getpriority(int which, id_t who); }
+	// SYS_NOSYS = 101;  // { int nosys(void); }   { old send }
+	// SYS_NOSYS = 102;  // { int nosys(void); }   { old recv }
+	// SYS_NOSYS = 103;  // { int nosys(void); }   { old sigreturn }
+	SYS_BIND = 104;  // { int bind(int s, caddr_t name, socklen_t namelen); }
+	SYS_SETSOCKOPT = 105;  // { int setsockopt(int s, int level, int name, caddr_t val, socklen_t valsize); }
+	SYS_LISTEN = 106;  // { int listen(int s, int backlog); }
+	// SYS_NOSYS = 104;  // { int nosys(void); }
+	// SYS_NOSYS = 105;  // { int nosys(void); }
+	// SYS_NOSYS = 106;  // { int nosys(void); }
+	// SYS_NOSYS = 107;  // { int nosys(void); }   { old vtimes }
+	// SYS_NOSYS = 108;  // { int nosys(void); }   { old sigvec }
+	// SYS_NOSYS = 109;  // { int nosys(void); }   { old sigblock }
+	// SYS_NOSYS = 110;  // { int nosys(void); }   { old sigsetmask }
+	SYS_SIGSUSPEND = 111;  // { int sigsuspend(sigset_t mask); }
+	// SYS_NOSYS = 112;  // { int nosys(void); }   { old sigstack }
+	// SYS_NOSYS = 113;  // { int nosys(void); }   { old recvmsg }
+	// SYS_NOSYS = 114;  // { int nosys(void); }   { old sendmsg }
+	// SYS_NOSYS = 113;  // { int nosys(void); }
+	// SYS_NOSYS = 114;  // { int nosys(void); }
+	// SYS_NOSYS = 115;  // { int nosys(void); }   { old vtrace }
+	SYS_GETTIMEOFDAY = 116;  // { int gettimeofday(struct timeval *tp, struct timezone *tzp); }
+	SYS_GETRUSAGE = 117;  // { int getrusage(int who, struct rusage *rusage); }
+	SYS_GETSOCKOPT = 118;  // { int getsockopt(int s, int level, int name, caddr_t val, socklen_t *avalsize); }
+	// SYS_NOSYS = 118;  // { int nosys(void); }
+	// SYS_NOSYS = 119;  // { int nosys(void); }   { old resuba }
+	SYS_READV = 120;  // { user_ssize_t readv(int fd, struct iovec *iovp, u_int iovcnt); }
+	SYS_WRITEV = 121;  // { user_ssize_t writev(int fd, struct iovec *iovp, u_int iovcnt); }
+	SYS_SETTIMEOFDAY = 122;  // { int settimeofday(struct timeval *tv, struct timezone *tzp); }
+	SYS_FCHOWN = 123;  // { int fchown(int fd, int uid, int gid); }
+	SYS_FCHMOD = 124;  // { int fchmod(int fd, int mode); }
+	// SYS_NOSYS = 125;  // { int nosys(void); }   { old recvfrom }
+	SYS_SETREUID = 126;  // { int setreuid(uid_t ruid, uid_t euid); }
+	SYS_SETREGID = 127;  // { int setregid(gid_t rgid, gid_t egid); }
+	SYS_RENAME = 128;  // { int rename(char *from, char *to); }
+	// SYS_NOSYS = 129;  // { int nosys(void); }   { old truncate }
+	// SYS_NOSYS = 130;  // { int nosys(void); }   { old ftruncate }
+	SYS_FLOCK = 131;  // { int flock(int fd, int how); }
+	SYS_MKFIFO = 132;  // { int mkfifo(user_addr_t path, int mode); }
+	SYS_SENDTO = 133;  // { int sendto(int s, caddr_t buf, size_t len, int flags, caddr_t to, socklen_t tolen); }
+	SYS_SHUTDOWN = 134;  // { int shutdown(int s, int how); }
+	SYS_SOCKETPAIR = 135;  // { int socketpair(int domain, int type, int protocol, int *rsv); }
+	// SYS_NOSYS = 133;  // { int nosys(void); }
+	// SYS_NOSYS = 134;  // { int nosys(void); }
+	// SYS_NOSYS = 135;  // { int nosys(void); }
+	SYS_MKDIR = 136;  // { int mkdir(user_addr_t path, int mode); }
+	SYS_RMDIR = 137;  // { int rmdir(char *path); }
+	SYS_UTIMES = 138;  // { int utimes(char *path, struct timeval *tptr); }
+	SYS_FUTIMES = 139;  // { int futimes(int fd, struct timeval *tptr); }
+	SYS_ADJTIME = 140;  // { int adjtime(struct timeval *delta, struct timeval *olddelta); }
+	// SYS_NOSYS = 141;  // { int nosys(void); }   { old getpeername }
+	SYS_GETHOSTUUID = 142;  // { int gethostuuid(unsigned char *uuid_buf, const struct timespec *timeoutp); }
+	// SYS_NOSYS = 143;  // { int nosys(void); }   { old sethostid 	}
+	// SYS_NOSYS = 144;  // { int nosys(void); }   { old getrlimit }
+	// SYS_NOSYS = 145;  // { int nosys(void); }   { old setrlimit }
+	// SYS_NOSYS = 146;  // { int nosys(void); }   { old killpg }
+	SYS_SETSID = 147;  // { int setsid(void); }
+	// SYS_NOSYS = 148;  // { int nosys(void); }   { old setquota }
+	// SYS_NOSYS = 149;  // { int nosys(void); }   { old qquota }
+	// SYS_NOSYS = 150;  // { int nosys(void); }   { old getsockname }
+	SYS_GETPGID = 151;  // { int getpgid(pid_t pid); }
+	SYS_SETPRIVEXEC = 152;  // { int setprivexec(int flag); }
+	SYS_PREAD = 153;  // { user_ssize_t pread(int fd, user_addr_t buf, user_size_t nbyte, off_t offset); }
+	SYS_PWRITE = 154;  // { user_ssize_t pwrite(int fd, user_addr_t buf, user_size_t nbyte, off_t offset); }
+	SYS_NFSSVC = 155;  // { int nfssvc(int flag, caddr_t argp); }
+	// SYS_NOSYS = 155;  // { int nosys(void); }
+	// SYS_NOSYS = 156;  // { int nosys(void); }   { old getdirentries }
+	SYS_STATFS = 157;  // { int statfs(char *path, struct statfs *buf); }
+	SYS_FSTATFS = 158;  // { int fstatfs(int fd, struct statfs *buf); }
+	SYS_UNMOUNT = 159;  // { int unmount(user_addr_t path, int flags); }
+	// SYS_NOSYS = 160;  // { int nosys(void); }   { old async_daemon }
+	SYS_GETFH = 161;  // { int getfh(char *fname, fhandle_t *fhp); }
+	// SYS_NOSYS = 161;  // { int nosys(void); }
+	// SYS_NOSYS = 162;  // { int nosys(void); }   { old getdomainname }
+	// SYS_NOSYS = 163;  // { int nosys(void); }   { old setdomainname }
+	// SYS_NOSYS = 164;  // { int nosys(void); }
+	SYS_QUOTACTL = 165;  // { int quotactl(const char *path, int cmd, int uid, caddr_t arg); }
+	// SYS_NOSYS = 166;  // { int nosys(void); }   { old exportfs }
+	SYS_MOUNT = 167;  // { int mount(char *type, char *path, int flags, caddr_t data); }
+	// SYS_NOSYS = 168;  // { int nosys(void); }   { old ustat }
+	SYS_CSOPS = 169;  // { int csops(pid_t pid, uint32_t ops, user_addr_t useraddr, user_size_t usersize); }
+	// SYS_NOSYS = 171;  // { int nosys(void); }   { old wait3 }
+	// SYS_NOSYS = 172;  // { int nosys(void); }   { old rpause	}
+	SYS_WAITID = 173;  // { int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); }
+	// SYS_NOSYS = 174;  // { int nosys(void); }   { old getdents }
+	// SYS_NOSYS = 175;  // { int nosys(void); }   { old gc_control }
+	SYS_ADD_PROFIL = 176;  // { int add_profil(short *bufbase, size_t bufsize, u_long pcoffset, u_int pcscale); }
+	// SYS_NOSYS = 177;  // { int nosys(void); }
+	// SYS_NOSYS = 178;  // { int nosys(void); }
+	// SYS_NOSYS = 179;  // { int nosys(void); }
+	SYS_KDEBUG_TRACE = 180;  // { int kdebug_trace(int code, int arg1, int arg2, int arg3, int arg4, int arg5) NO_SYSCALL_STUB; }
+	SYS_SETGID = 181;  // { int setgid(gid_t gid); }
+	SYS_SETEGID = 182;  // { int setegid(gid_t egid); }
+	SYS_SETEUID = 183;  // { int seteuid(uid_t euid); }
+	SYS_SIGRETURN = 184;  // { int sigreturn(struct ucontext *uctx, int infostyle); }
+	// SYS_NOSYS = 186;  // { int nosys(void); }
+	// SYS_NOSYS = 187;  // { int nosys(void); }
+	SYS_STAT = 188;  // { int stat(user_addr_t path, user_addr_t ub); }
+	SYS_FSTAT = 189;  // { int fstat(int fd, user_addr_t ub); }
+	SYS_LSTAT = 190;  // { int lstat(user_addr_t path, user_addr_t ub); }
+	SYS_PATHCONF = 191;  // { int pathconf(char *path, int name); }
+	SYS_FPATHCONF = 192;  // { int fpathconf(int fd, int name); }
+	// SYS_NOSYS = 193;  // { int nosys(void); }
+	SYS_GETRLIMIT = 194;  // { int getrlimit(u_int which, struct rlimit *rlp); }
+	SYS_SETRLIMIT = 195;  // { int setrlimit(u_int which, struct rlimit *rlp); }
+	SYS_GETDIRENTRIES = 196;  // { int getdirentries(int fd, char *buf, u_int count, long *basep); }
+	SYS_MMAP = 197;  // { user_addr_t mmap(caddr_t addr, size_t len, int prot, int flags, int fd, off_t pos); }
+	// SYS_NOSYS = 198;  // { int nosys(void); } 	{ __syscall }
+	SYS_LSEEK = 199;  // { off_t lseek(int fd, off_t offset, int whence); }
+	SYS_TRUNCATE = 200;  // { int truncate(char *path, off_t length); }
+	SYS_FTRUNCATE = 201;  // { int ftruncate(int fd, off_t length); }
+	SYS___SYSCTL = 202;  // { int __sysctl(int *name, u_int namelen, void *old, size_t *oldlenp, void *new, size_t newlen); }
+	SYS_MLOCK = 203;  // { int mlock(caddr_t addr, size_t len); }
+	SYS_MUNLOCK = 204;  // { int munlock(caddr_t addr, size_t len); }
+	SYS_UNDELETE = 205;  // { int undelete(user_addr_t path); }
+	SYS_ATSOCKET = 206;  // { int ATsocket(int proto); }
+	// SYS_NOSYS = 213;  // { int nosys(void); } 	{ Reserved for AppleTalk }
+	// SYS_NOSYS = 206;  // { int nosys(void); }
+	// SYS_NOSYS = 207;  // { int nosys(void); }
+	// SYS_NOSYS = 208;  // { int nosys(void); }
+	// SYS_NOSYS = 209;  // { int nosys(void); }
+	// SYS_NOSYS = 210;  // { int nosys(void); }
+	// SYS_NOSYS = 211;  // { int nosys(void); }
+	// SYS_NOSYS = 212;  // { int nosys(void); }
+	// SYS_NOSYS = 213;  // { int nosys(void); } 	{ Reserved for AppleTalk }
+	SYS_KQUEUE_FROM_PORTSET_NP = 214;  // { int kqueue_from_portset_np(int portset); }
+	SYS_KQUEUE_PORTSET_NP = 215;  // { int kqueue_portset_np(int fd); }
+	SYS_GETATTRLIST = 220;  // { int getattrlist(const char *path, struct attrlist *alist, void *attributeBuffer, size_t bufferSize, u_long options); }
+	SYS_SETATTRLIST = 221;  // { int setattrlist(const char *path, struct attrlist *alist, void *attributeBuffer, size_t bufferSize, u_long options); }
+	SYS_GETDIRENTRIESATTR = 222;  // { int getdirentriesattr(int fd, struct attrlist *alist, void *buffer, size_t buffersize, u_long *count, u_long *basep, u_long *newstate, u_long options); }
+	SYS_EXCHANGEDATA = 223;  // { int exchangedata(const char *path1, const char *path2, u_long options); }
+	// SYS_NOSYS = 224;  // { int nosys(void); } { was checkuseraccess }
+	SYS_SEARCHFS = 225;  // { int searchfs(const char *path, struct fssearchblock *searchblock, u_long *nummatches, u_long scriptcode, u_long options, struct searchstate *state); }
+	SYS_DELETE = 226;  // { int delete(user_addr_t path) NO_SYSCALL_STUB; }       { private delete (Carbon semantics) }
+	SYS_COPYFILE = 227;  // { int copyfile(char *from, char *to, int mode, int flags) NO_SYSCALL_STUB; }
+	// SYS_NOSYS = 228;  // { int nosys(void); }
+	// SYS_NOSYS = 229;  // { int nosys(void); }
+	SYS_POLL = 230;  // { int poll(struct pollfd *fds, u_int nfds, int timeout); }
+	SYS_WATCHEVENT = 231;  // { int watchevent(struct eventreq *u_req, int u_eventmask); }
+	SYS_WAITEVENT = 232;  // { int waitevent(struct eventreq *u_req, struct timeval *tv); }
+	SYS_MODWATCH = 233;  // { int modwatch(struct eventreq *u_req, int u_eventmask); }
+	SYS_GETXATTR = 234;  // { user_ssize_t getxattr(user_addr_t path, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
+	SYS_FGETXATTR = 235;  // { user_ssize_t fgetxattr(int fd, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
+	SYS_SETXATTR = 236;  // { int setxattr(user_addr_t path, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
+	SYS_FSETXATTR = 237;  // { int fsetxattr(int fd, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
+	SYS_REMOVEXATTR = 238;  // { int removexattr(user_addr_t path, user_addr_t attrname, int options); }
+	SYS_FREMOVEXATTR = 239;  // { int fremovexattr(int fd, user_addr_t attrname, int options); }
+	SYS_LISTXATTR = 240;  // { user_ssize_t listxattr(user_addr_t path, user_addr_t namebuf, size_t bufsize, int options); }
+	SYS_FLISTXATTR = 241;  // { user_ssize_t flistxattr(int fd, user_addr_t namebuf, size_t bufsize, int options); }
+	SYS_FSCTL = 242;  // { int fsctl(const char *path, u_long cmd, caddr_t data, u_long options); }
+	SYS_INITGROUPS = 243;  // { int initgroups(u_int gidsetsize, gid_t *gidset, int gmuid); }
+	SYS_POSIX_SPAWN = 244;  // { int posix_spawn(pid_t *pid, const char *path, const struct _posix_spawn_args_desc *adesc, char **argv, char **envp); }
+	// SYS_NOSYS = 245;  // { int nosys(void); }
+	// SYS_NOSYS = 246;  // { int nosys(void); }
+	SYS_NFSCLNT = 247;  // { int nfsclnt(int flag, caddr_t argp); }
+	// SYS_NOSYS = 247;  // { int nosys(void); }
+	SYS_FHOPEN = 248;  // { int fhopen(const struct fhandle *u_fhp, int flags); }
+	// SYS_NOSYS = 248;  // { int nosys(void); }
+	// SYS_NOSYS = 249;  // { int nosys(void); }
+	SYS_MINHERIT = 250;  // { int minherit(void *addr, size_t len, int inherit); }
+	SYS_SEMSYS = 251;  // { int semsys(u_int which, int a2, int a3, int a4, int a5); }
+	// SYS_NOSYS = 251;  // { int nosys(void); }
+	SYS_MSGSYS = 252;  // { int msgsys(u_int which, int a2, int a3, int a4, int a5); }
+	// SYS_NOSYS = 252;  // { int nosys(void); }
+	SYS_SHMSYS = 253;  // { int shmsys(u_int which, int a2, int a3, int a4); }
+	// SYS_NOSYS = 253;  // { int nosys(void); }
+	SYS_SEMCTL = 254;  // { int semctl(int semid, int semnum, int cmd, semun_t arg); }
+	SYS_SEMGET = 255;  // { int semget(key_t key, int	nsems, int semflg); }
+	SYS_SEMOP = 256;  // { int semop(int semid, struct sembuf *sops, int nsops); }
+	// SYS_NOSYS = 257;  // { int nosys(void); }
+	// SYS_NOSYS = 254;  // { int nosys(void); }
+	// SYS_NOSYS = 255;  // { int nosys(void); }
+	// SYS_NOSYS = 256;  // { int nosys(void); }
+	// SYS_NOSYS = 257;  // { int nosys(void); }
+	SYS_MSGCTL = 258;  // { int msgctl(int msqid, int cmd, struct	msqid_ds *buf); }
+	SYS_MSGGET = 259;  // { int msgget(key_t key, int msgflg); }
+	SYS_MSGSND = 260;  // { int msgsnd(int msqid, void *msgp, size_t msgsz, int msgflg); }
+	SYS_MSGRCV = 261;  // { user_ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); }
+	// SYS_NOSYS = 258;  // { int nosys(void); }
+	// SYS_NOSYS = 259;  // { int nosys(void); }
+	// SYS_NOSYS = 260;  // { int nosys(void); }
+	// SYS_NOSYS = 261;  // { int nosys(void); }
+	SYS_SHMAT = 262;  // { user_addr_t shmat(int shmid, void *shmaddr, int shmflg); }
+	SYS_SHMCTL = 263;  // { int shmctl(int shmid, int cmd, struct shmid_ds *buf); }
+	SYS_SHMDT = 264;  // { int shmdt(void *shmaddr); }
+	SYS_SHMGET = 265;  // { int shmget(key_t key, size_t size, int shmflg); }
+	// SYS_NOSYS = 262;  // { int nosys(void); }
+	// SYS_NOSYS = 263;  // { int nosys(void); }
+	// SYS_NOSYS = 264;  // { int nosys(void); }
+	// SYS_NOSYS = 265;  // { int nosys(void); }
+	SYS_SHM_OPEN = 266;  // { int shm_open(const char *name, int oflag, int mode); }
+	SYS_SHM_UNLINK = 267;  // { int shm_unlink(const char *name); }
+	SYS_SEM_OPEN = 268;  // { user_addr_t sem_open(const char *name, int oflag, int mode, int value); }
+	SYS_SEM_CLOSE = 269;  // { int sem_close(sem_t *sem); }
+	SYS_SEM_UNLINK = 270;  // { int sem_unlink(const char *name); }
+	SYS_SEM_WAIT = 271;  // { int sem_wait(sem_t *sem); }
+	SYS_SEM_TRYWAIT = 272;  // { int sem_trywait(sem_t *sem); }
+	SYS_SEM_POST = 273;  // { int sem_post(sem_t *sem); }
+	SYS_SEM_GETVALUE = 274;  // { int sem_getvalue(sem_t *sem, int *sval); }
+	SYS_SEM_INIT = 275;  // { int sem_init(sem_t *sem, int phsared, u_int value); }
+	SYS_SEM_DESTROY = 276;  // { int sem_destroy(sem_t *sem); }
+	SYS_OPEN_EXTENDED = 277;  // { int open_extended(user_addr_t path, int flags, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_UMASK_EXTENDED = 278;  // { int umask_extended(int newmask, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_STAT_EXTENDED = 279;  // { int stat_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_LSTAT_EXTENDED = 280;  // { int lstat_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_FSTAT_EXTENDED = 281;  // { int fstat_extended(int fd, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_CHMOD_EXTENDED = 282;  // { int chmod_extended(user_addr_t path, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_FCHMOD_EXTENDED = 283;  // { int fchmod_extended(int fd, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_ACCESS_EXTENDED = 284;  // { int access_extended(user_addr_t entries, size_t size, user_addr_t results, uid_t uid) NO_SYSCALL_STUB; }
+	SYS_SETTID = 285;  // { int settid(uid_t uid, gid_t gid) NO_SYSCALL_STUB; }
+	SYS_GETTID = 286;  // { int gettid(uid_t *uidp, gid_t *gidp) NO_SYSCALL_STUB; }
+	SYS_SETSGROUPS = 287;  // { int setsgroups(int setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
+	SYS_GETSGROUPS = 288;  // { int getsgroups(user_addr_t setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
+	SYS_SETWGROUPS = 289;  // { int setwgroups(int setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
+	SYS_GETWGROUPS = 290;  // { int getwgroups(user_addr_t setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
+	SYS_MKFIFO_EXTENDED = 291;  // { int mkfifo_extended(user_addr_t path, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_MKDIR_EXTENDED = 292;  // { int mkdir_extended(user_addr_t path, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_IDENTITYSVC = 293;  // { int identitysvc(int opcode, user_addr_t message) NO_SYSCALL_STUB; }
+	SYS_SHARED_REGION_CHECK_NP = 294;  // { int shared_region_check_np(uint64_t *start_address) NO_SYSCALL_STUB; }
+	SYS_SHARED_REGION_MAP_NP = 295;  // { int shared_region_map_np(int fd, uint32_t count, const struct shared_file_mapping_np *mappings) NO_SYSCALL_STUB; }
+	// SYS_NOSYS = 296;  // { int nosys(void); } { old load_shared_file }
+	// SYS_NOSYS = 297;  // { int nosys(void); } { old reset_shared_file }
+	// SYS_NOSYS = 298;  // { int nosys(void); } { old new_system_shared_regions }
+	// SYS_ENOSYS = 299;  // { int enosys(void); } { old shared_region_map_file_np }
+	// SYS_ENOSYS = 300;  // { int enosys(void); } { old shared_region_make_private_np }
+	SYS___PTHREAD_MUTEX_DESTROY = 301;  // { int __pthread_mutex_destroy(int mutexid); }
+	SYS___PTHREAD_MUTEX_INIT = 302;  // { int __pthread_mutex_init(user_addr_t  mutex, user_addr_t attr); }
+	SYS___PTHREAD_MUTEX_LOCK = 303;  // { int __pthread_mutex_lock(int mutexid); }
+	SYS___PTHREAD_MUTEX_TRYLOCK = 304;  // { int __pthread_mutex_trylock(int mutexid); }
+	SYS___PTHREAD_MUTEX_UNLOCK = 305;  // { int __pthread_mutex_unlock(int mutexid); }
+	SYS___PTHREAD_COND_INIT = 306;  // { int __pthread_cond_init(user_addr_t cond, user_addr_t attr); }
+	SYS___PTHREAD_COND_DESTROY = 307;  // { int __pthread_cond_destroy(int condid); }
+	SYS___PTHREAD_COND_BROADCAST = 308;  // { int __pthread_cond_broadcast(int condid); }
+	SYS___PTHREAD_COND_SIGNAL = 309;  // { int __pthread_cond_signal(int condid); }
+	SYS_GETSID = 310;  // { int getsid(pid_t pid); }
+	SYS_SETTID_WITH_PID = 311;  // { int settid_with_pid(pid_t pid, int assume) NO_SYSCALL_STUB; }
+	SYS___PTHREAD_COND_TIMEDWAIT = 312;  // { int __pthread_cond_timedwait(int condid, int mutexid, user_addr_t abstime); }
+	SYS_AIO_FSYNC = 313;  // { int aio_fsync(int op, user_addr_t aiocbp); }
+	SYS_AIO_RETURN = 314;  // { user_ssize_t aio_return(user_addr_t aiocbp); }
+	SYS_AIO_SUSPEND = 315;  // { int aio_suspend(user_addr_t aiocblist, int nent, user_addr_t timeoutp); }
+	SYS_AIO_CANCEL = 316;  // { int aio_cancel(int fd, user_addr_t aiocbp); }
+	SYS_AIO_ERROR = 317;  // { int aio_error(user_addr_t aiocbp); }
+	SYS_AIO_READ = 318;  // { int aio_read(user_addr_t aiocbp); }
+	SYS_AIO_WRITE = 319;  // { int aio_write(user_addr_t aiocbp); }
+	SYS_LIO_LISTIO = 320;  // { int lio_listio(int mode, user_addr_t aiocblist, int nent, user_addr_t sigp); }
+	SYS___PTHREAD_COND_WAIT = 321;  // { int __pthread_cond_wait(int condid, int mutexid); }
+	SYS_IOPOLICYSYS = 322;  // { int iopolicysys(int cmd, void *arg) NO_SYSCALL_STUB; }
+	// SYS_NOSYS = 323;  // { int nosys(void); }
+	SYS_MLOCKALL = 324;  // { int mlockall(int how); }
+	SYS_MUNLOCKALL = 325;  // { int munlockall(int how); }
+	// SYS_NOSYS = 326;  // { int nosys(void); }
+	SYS_ISSETUGID = 327;  // { int issetugid(void); }
+	SYS___PTHREAD_KILL = 328;  // { int __pthread_kill(int thread_port, int sig); }
+	SYS___PTHREAD_SIGMASK = 329;  // { int __pthread_sigmask(int how, user_addr_t set, user_addr_t oset); }
+	SYS___SIGWAIT = 330;  // { int __sigwait(user_addr_t set, user_addr_t sig); }
+	SYS___DISABLE_THREADSIGNAL = 331;  // { int __disable_threadsignal(int value); }
+	SYS___PTHREAD_MARKCANCEL = 332;  // { int __pthread_markcancel(int thread_port); }
+	SYS___PTHREAD_CANCELED = 333;  // { int __pthread_canceled(int  action); }
+	SYS___SEMWAIT_SIGNAL = 334;  // { int __semwait_signal(int cond_sem, int mutex_sem, int timeout, int relative, time_t tv_sec, int32_t tv_nsec); }
+	// SYS_NOSYS = 335;  // { int nosys(void); }   { old utrace }
+	SYS_PROC_INFO = 336;  // { int proc_info(int32_t callnum,int32_t pid,uint32_t flavor, uint64_t arg,user_addr_t buffer,int32_t buffersize) NO_SYSCALL_STUB; }
+	SYS_SENDFILE = 337;  // { int sendfile(int fd, int s, off_t offset, off_t *nbytes, struct sf_hdtr *hdtr, int flags); }
+	// SYS_NOSYS = 337;  // { int nosys(void); }
+	SYS_STAT64 = 338;  // { int stat64(user_addr_t path, user_addr_t ub); }
+	SYS_FSTAT64 = 339;  // { int fstat64(int fd, user_addr_t ub); }
+	SYS_LSTAT64 = 340;  // { int lstat64(user_addr_t path, user_addr_t ub); }
+	SYS_STAT64_EXTENDED = 341;  // { int stat64_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_LSTAT64_EXTENDED = 342;  // { int lstat64_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_FSTAT64_EXTENDED = 343;  // { int fstat64_extended(int fd, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_GETDIRENTRIES64 = 344;  // { user_ssize_t getdirentries64(int fd, void *buf, user_size_t bufsize, off_t *position) NO_SYSCALL_STUB; }
+	SYS_STATFS64 = 345;  // { int statfs64(char *path, struct statfs64 *buf); }
+	SYS_FSTATFS64 = 346;  // { int fstatfs64(int fd, struct statfs64 *buf); }
+	SYS_GETFSSTAT64 = 347;  // { int getfsstat64(user_addr_t buf, int bufsize, int flags); }
+	SYS___PTHREAD_CHDIR = 348;  // { int __pthread_chdir(user_addr_t path); }
+	SYS___PTHREAD_FCHDIR = 349;  // { int __pthread_fchdir(int fd); }
+	SYS_AUDIT = 350;  // { int audit(void *record, int length); }
+	SYS_AUDITON = 351;  // { int auditon(int cmd, void *data, int length); }
+	// SYS_NOSYS = 352;  // { int nosys(void); }
+	SYS_GETAUID = 353;  // { int getauid(au_id_t *auid); }
+	SYS_SETAUID = 354;  // { int setauid(au_id_t *auid); }
+	SYS_GETAUDIT = 355;  // { int getaudit(struct auditinfo *auditinfo); }
+	SYS_SETAUDIT = 356;  // { int setaudit(struct auditinfo *auditinfo); }
+	SYS_GETAUDIT_ADDR = 357;  // { int getaudit_addr(struct auditinfo_addr *auditinfo_addr, int length); }
+	SYS_SETAUDIT_ADDR = 358;  // { int setaudit_addr(struct auditinfo_addr *auditinfo_addr, int length); }
+	SYS_AUDITCTL = 359;  // { int auditctl(char *path); }
+	// SYS_NOSYS = 350;  // { int nosys(void); }
+	// SYS_NOSYS = 351;  // { int nosys(void); }
+	// SYS_NOSYS = 352;  // { int nosys(void); }
+	// SYS_NOSYS = 353;  // { int nosys(void); }
+	// SYS_NOSYS = 354;  // { int nosys(void); }
+	// SYS_NOSYS = 355;  // { int nosys(void); }
+	// SYS_NOSYS = 356;  // { int nosys(void); }
+	// SYS_NOSYS = 357;  // { int nosys(void); }
+	// SYS_NOSYS = 358;  // { int nosys(void); }
+	// SYS_NOSYS = 359;  // { int nosys(void); }
+	SYS_BSDTHREAD_CREATE = 360;  // { user_addr_t bsdthread_create(user_addr_t func, user_addr_t func_arg, user_addr_t stack, user_addr_t pthread, uint32_t flags) NO_SYSCALL_STUB; }
+	SYS_BSDTHREAD_TERMINATE = 361;  // { int bsdthread_terminate(user_addr_t stackaddr, size_t freesize, uint32_t port, uint32_t sem) NO_SYSCALL_STUB; }
+	SYS_KQUEUE = 362;  // { int kqueue(void); }
+	SYS_KEVENT = 363;  // { int kevent(int fd, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout); }
+	SYS_LCHOWN = 364;  // { int lchown(user_addr_t path, uid_t owner, gid_t group); }
+	SYS_STACK_SNAPSHOT = 365;  // { int stack_snapshot(pid_t pid, user_addr_t tracebuf, uint32_t tracebuf_size, uint32_t options) NO_SYSCALL_STUB; }
+	SYS_BSDTHREAD_REGISTER = 366;  // { int bsdthread_register(user_addr_t threadstart, user_addr_t wqthread, int pthsize) NO_SYSCALL_STUB; }
+	SYS_WORKQ_OPEN = 367;  // { int workq_open(void) NO_SYSCALL_STUB; }
+	SYS_WORKQ_OPS = 368;  // { int workq_ops(int options, user_addr_t item, int prio) NO_SYSCALL_STUB; }
+	// SYS_NOSYS = 369;  // { int nosys(void); }
+	// SYS_NOSYS = 370;  // { int nosys(void); }
+	// SYS_NOSYS = 371;  // { int nosys(void); }
+	// SYS_NOSYS = 372;  // { int nosys(void); }
+	// SYS_NOSYS = 373;  // { int nosys(void); }
+	// SYS_NOSYS = 374;  // { int nosys(void); }
+	// SYS_NOSYS = 375;  // { int nosys(void); }
+	// SYS_NOSYS = 376;  // { int nosys(void); }
+	// SYS_NOSYS = 377;  // { int nosys(void); }
+	// SYS_NOSYS = 378;  // { int nosys(void); }
+	// SYS_NOSYS = 379;  // { int nosys(void); }
+	SYS___MAC_EXECVE = 380;  // { int __mac_execve(char *fname, char **argp, char **envp, struct mac *mac_p); }
+	SYS___MAC_SYSCALL = 381;  // { int __mac_syscall(char *policy, int call, user_addr_t arg); }
+	SYS___MAC_GET_FILE = 382;  // { int __mac_get_file(char *path_p, struct mac *mac_p); }
+	SYS___MAC_SET_FILE = 383;  // { int __mac_set_file(char *path_p, struct mac *mac_p); }
+	SYS___MAC_GET_LINK = 384;  // { int __mac_get_link(char *path_p, struct mac *mac_p); }
+	SYS___MAC_SET_LINK = 385;  // { int __mac_set_link(char *path_p, struct mac *mac_p); }
+	SYS___MAC_GET_PROC = 386;  // { int __mac_get_proc(struct mac *mac_p); }
+	SYS___MAC_SET_PROC = 387;  // { int __mac_set_proc(struct mac *mac_p); }
+	SYS___MAC_GET_FD = 388;  // { int __mac_get_fd(int fd, struct mac *mac_p); }
+	SYS___MAC_SET_FD = 389;  // { int __mac_set_fd(int fd, struct mac *mac_p); }
+	SYS___MAC_GET_PID = 390;  // { int __mac_get_pid(pid_t pid, struct mac *mac_p); }
+	SYS___MAC_GET_LCID = 391;  // { int __mac_get_lcid(pid_t lcid, struct mac *mac_p); }
+	SYS___MAC_GET_LCTX = 392;  // { int __mac_get_lctx(struct mac *mac_p); }
+	SYS___MAC_SET_LCTX = 393;  // { int __mac_set_lctx(struct mac *mac_p); }
+	SYS_SETLCID = 394;  // { int setlcid(pid_t pid, pid_t lcid) NO_SYSCALL_STUB; }
+	SYS_GETLCID = 395;  // { int getlcid(pid_t pid) NO_SYSCALL_STUB; }
+	SYS_READ_NOCANCEL = 396;  // { user_ssize_t read_nocancel(int fd, user_addr_t cbuf, user_size_t nbyte) NO_SYSCALL_STUB; }
+	SYS_WRITE_NOCANCEL = 397;  // { user_ssize_t write_nocancel(int fd, user_addr_t cbuf, user_size_t nbyte) NO_SYSCALL_STUB; }
+	SYS_OPEN_NOCANCEL = 398;  // { int open_nocancel(user_addr_t path, int flags, int mode) NO_SYSCALL_STUB; }
+	SYS_CLOSE_NOCANCEL = 399;  // { int close_nocancel(int fd) NO_SYSCALL_STUB; }
+	SYS_WAIT4_NOCANCEL = 400;  // { int wait4_nocancel(int pid, user_addr_t status, int options, user_addr_t rusage) NO_SYSCALL_STUB; }
+	SYS_RECVMSG_NOCANCEL = 401;  // { int recvmsg_nocancel(int s, struct msghdr *msg, int flags) NO_SYSCALL_STUB; }
+	SYS_SENDMSG_NOCANCEL = 402;  // { int sendmsg_nocancel(int s, caddr_t msg, int flags) NO_SYSCALL_STUB; }
+	SYS_RECVFROM_NOCANCEL = 403;  // { int recvfrom_nocancel(int s, void *buf, size_t len, int flags, struct sockaddr *from, int *fromlenaddr) NO_SYSCALL_STUB; }
+	SYS_ACCEPT_NOCANCEL = 404;  // { int accept_nocancel(int s, caddr_t name, socklen_t	*anamelen) NO_SYSCALL_STUB; }
+	// SYS_NOSYS = 401;  // { int nosys(void); }
+	// SYS_NOSYS = 402;  // { int nosys(void); }
+	// SYS_NOSYS = 403;  // { int nosys(void); }
+	// SYS_NOSYS = 404;  // { int nosys(void); }
+	SYS_MSYNC_NOCANCEL = 405;  // { int msync_nocancel(caddr_t addr, size_t len, int flags) NO_SYSCALL_STUB; }
+	SYS_FCNTL_NOCANCEL = 406;  // { int fcntl_nocancel(int fd, int cmd, long arg) NO_SYSCALL_STUB; }
+	SYS_SELECT_NOCANCEL = 407;  // { int select_nocancel(int nd, u_int32_t *in, u_int32_t *ou, u_int32_t *ex, struct timeval *tv) NO_SYSCALL_STUB; }
+	SYS_FSYNC_NOCANCEL = 408;  // { int fsync_nocancel(int fd) NO_SYSCALL_STUB; }
+	SYS_CONNECT_NOCANCEL = 409;  // { int connect_nocancel(int s, caddr_t name, socklen_t namelen) NO_SYSCALL_STUB; }
+	// SYS_NOSYS = 409;  // { int nosys(void); }
+	SYS_SIGSUSPEND_NOCANCEL = 410;  // { int sigsuspend_nocancel(sigset_t mask) NO_SYSCALL_STUB; }
+	SYS_READV_NOCANCEL = 411;  // { user_ssize_t readv_nocancel(int fd, struct iovec *iovp, u_int iovcnt) NO_SYSCALL_STUB; }
+	SYS_WRITEV_NOCANCEL = 412;  // { user_ssize_t writev_nocancel(int fd, struct iovec *iovp, u_int iovcnt) NO_SYSCALL_STUB; }
+	SYS_SENDTO_NOCANCEL = 413;  // { int sendto_nocancel(int s, caddr_t buf, size_t len, int flags, caddr_t to, socklen_t tolen) NO_SYSCALL_STUB; }
+	// SYS_NOSYS = 413;  // { int nosys(void); }
+	SYS_PREAD_NOCANCEL = 414;  // { user_ssize_t pread_nocancel(int fd, user_addr_t buf, user_size_t nbyte, off_t offset) NO_SYSCALL_STUB; }
+	SYS_PWRITE_NOCANCEL = 415;  // { user_ssize_t pwrite_nocancel(int fd, user_addr_t buf, user_size_t nbyte, off_t offset) NO_SYSCALL_STUB; }
+	SYS_WAITID_NOCANCEL = 416;  // { int waitid_nocancel(idtype_t idtype, id_t id, siginfo_t *infop, int options) NO_SYSCALL_STUB; }
+	SYS_POLL_NOCANCEL = 417;  // { int poll_nocancel(struct pollfd *fds, u_int nfds, int timeout) NO_SYSCALL_STUB; }
+	SYS_MSGSND_NOCANCEL = 418;  // { int msgsnd_nocancel(int msqid, void *msgp, size_t msgsz, int msgflg) NO_SYSCALL_STUB; }
+	SYS_MSGRCV_NOCANCEL = 419;  // { user_ssize_t msgrcv_nocancel(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg) NO_SYSCALL_STUB; }
+	// SYS_NOSYS = 418;  // { int nosys(void); }
+	// SYS_NOSYS = 419;  // { int nosys(void); }
+	SYS_SEM_WAIT_NOCANCEL = 420;  // { int sem_wait_nocancel(sem_t *sem) NO_SYSCALL_STUB; }
+	SYS_AIO_SUSPEND_NOCANCEL = 421;  // { int aio_suspend_nocancel(user_addr_t aiocblist, int nent, user_addr_t timeoutp) NO_SYSCALL_STUB; }
+	SYS___SIGWAIT_NOCANCEL = 422;  // { int __sigwait_nocancel(user_addr_t set, user_addr_t sig) NO_SYSCALL_STUB; }
+	SYS___SEMWAIT_SIGNAL_NOCANCEL = 423;  // { int __semwait_signal_nocancel(int cond_sem, int mutex_sem, int timeout, int relative, time_t tv_sec, int32_t tv_nsec) NO_SYSCALL_STUB; }
+	SYS___MAC_MOUNT = 424;  // { int __mac_mount(char *type, char *path, int flags, caddr_t data, struct mac *mac_p); }
+	SYS___MAC_GET_MOUNT = 425;  // { int __mac_get_mount(char *path, struct mac *mac_p); }
+	SYS___MAC_GETFSSTAT = 426;  // { int __mac_getfsstat(user_addr_t buf, int bufsize, user_addr_t mac, int macsize, int flags); }
+)
diff --git a/src/lib/syscall/ztypes_darwin_386.go b/src/lib/syscall/ztypes_darwin_386.go
new file mode 100644
index 0000000000..29d0d96763
--- /dev/null
+++ b/src/lib/syscall/ztypes_darwin_386.go
@@ -0,0 +1,246 @@
+// godefs -gsyscall -f-m32 types_darwin.c types_darwin_386.c
+
+// MACHINE GENERATED - DO NOT EDIT.
+
+package syscall
+
+// Constants
+const (
+	sizeofPtr = 0x4;
+	sizeofShort = 0x2;
+	sizeofInt = 0x4;
+	sizeofLong = 0x4;
+	sizeofLongLong = 0x8;
+	O_RDONLY = 0;
+	O_WRONLY = 0x1;
+	O_RDWR = 0x2;
+	O_APPEND = 0x8;
+	O_ASYNC = 0x40;
+	O_CREAT = 0x200;
+	O_NOCTTY = 0x20000;
+	O_NONBLOCK = 0x4;
+	O_SYNC = 0x80;
+	O_TRUNC = 0x400;
+	O_CLOEXEC = 0;
+	F_GETFD = 0x1;
+	F_SETFD = 0x2;
+	F_GETFL = 0x3;
+	F_SETFL = 0x4;
+	FD_CLOEXEC = 0x1;
+	NAME_MAX = 0xff;
+	S_IFMT = 0xf000;
+	S_IFIFO = 0x1000;
+	S_IFCHR = 0x2000;
+	S_IFDIR = 0x4000;
+	S_IFBLK = 0x6000;
+	S_IFREG = 0x8000;
+	S_IFLNK = 0xa000;
+	S_IFSOCK = 0xc000;
+	S_IFWHT = 0xe000;
+	S_ISUID = 0x800;
+	S_ISGID = 0x400;
+	S_ISVTX = 0x200;
+	S_IRUSR = 0x100;
+	S_IWUSR = 0x80;
+	S_IXUSR = 0x40;
+	WNOHANG = 0x1;
+	WUNTRACED = 0x2;
+	WEXITED = 0x4;
+	WSTOPPED = 0x7f;
+	WCONTINUED = 0x10;
+	WNOWAIT = 0x20;
+	AF_UNIX = 0x1;
+	AF_INET = 0x2;
+	AF_DATAKIT = 0x9;
+	AF_INET6 = 0x1e;
+	SOCK_STREAM = 0x1;
+	SOCK_DGRAM = 0x2;
+	SOCK_RAW = 0x3;
+	SOCK_SEQPACKET = 0x5;
+	SOL_SOCKET = 0xffff;
+	SO_REUSEADDR = 0x4;
+	SO_KEEPALIVE = 0x8;
+	SO_DONTROUTE = 0x10;
+	SO_BROADCAST = 0x20;
+	SO_USELOOPBACK = 0x40;
+	SO_LINGER = 0x80;
+	SO_REUSEPORT = 0x200;
+	SO_SNDBUF = 0x1001;
+	SO_RCVBUF = 0x1002;
+	SO_SNDTIMEO = 0x1005;
+	SO_RCVTIMEO = 0x1006;
+	SO_NOSIGPIPE = 0x1022;
+	IPPROTO_TCP = 0x6;
+	IPPROTO_UDP = 0x11;
+	TCP_NODELAY = 0x1;
+	SOMAXCONN = 0x80;
+	SizeofSockaddrInet4 = 0x10;
+	SizeofSockaddrInet6 = 0x1c;
+	SizeofSockaddrAny = 0x1c;
+	SizeofSockaddrUnix = 0x6a;
+	EVFILT_READ = -0x1;
+	EVFILT_WRITE = -0x2;
+	EVFILT_AIO = -0x3;
+	EVFILT_VNODE = -0x4;
+	EVFILT_PROC = -0x5;
+	EVFILT_SIGNAL = -0x6;
+	EVFILT_TIMER = -0x7;
+	EVFILT_MACHPORT = -0x8;
+	EVFILT_FS = -0x9;
+	EVFILT_SYSCOUNT = 0x9;
+	EV_ADD = 0x1;
+	EV_DELETE = 0x2;
+	EV_DISABLE = 0x8;
+	EV_RECEIPT = 0x40;
+	EV_ONESHOT = 0x10;
+	EV_CLEAR = 0x20;
+	EV_SYSFLAGS = 0xf000;
+	EV_FLAG0 = 0x1000;
+	EV_FLAG1 = 0x2000;
+	EV_EOF = 0x8000;
+	EV_ERROR = 0x4000;
+)
+
+// Types
+
+type Timespec struct {
+	Sec int32;
+	Nsec int32;
+}
+
+type Timeval struct {
+	Sec int32;
+	Usec int32;
+}
+
+type Rusage struct {
+	Utime Timeval;
+	Stime Timeval;
+	Maxrss int32;
+	Ixrss int32;
+	Idrss int32;
+	Isrss int32;
+	Minflt int32;
+	Majflt int32;
+	Nswap int32;
+	Inblock int32;
+	Oublock int32;
+	Msgsnd int32;
+	Msgrcv int32;
+	Nsignals int32;
+	Nvcsw int32;
+	Nivcsw int32;
+}
+
+type Rlimit struct {
+	Cur uint64;
+	Max uint64;
+}
+
+type _C_int int32
+
+type _Gid_t uint32
+
+type Stat_t struct {
+	Dev int32;
+	Mode uint16;
+	Nlink uint16;
+	Ino uint64;
+	Uid uint32;
+	Gid uint32;
+	Rdev int32;
+	Atimespec Timespec;
+	Mtimespec Timespec;
+	Ctimespec Timespec;
+	Birthtimespec Timespec;
+	Size int64;
+	Blocks int64;
+	Blksize int32;
+	Flags uint32;
+	Gen uint32;
+	Lspare int32;
+	Qspare [2]int64;
+}
+
+type Statfs_t struct {
+	Bsize uint32;
+	Iosize int32;
+	Blocks uint64;
+	Bfree uint64;
+	Bavail uint64;
+	Files uint64;
+	Ffree uint64;
+	Fsid [8]byte /* fsid */;
+	Owner uint32;
+	Type uint32;
+	Flags uint32;
+	Fssubtype uint32;
+	Fstypename [16]int8;
+	Mntonname [1024]int8;
+	Mntfromname [1024]int8;
+	Reserved [8]uint32;
+}
+
+type Dirent struct {
+	Ino uint64;
+	Seekoff uint64;
+	Reclen uint16;
+	Namlen uint16;
+	Type uint8;
+	Name [1024]int8;
+	Pad0 [3]byte;
+}
+
+type RawSockaddrInet4 struct {
+	Len uint8;
+	Family uint8;
+	Port uint16;
+	Addr [4]byte /* in_addr */;
+	Zero [8]int8;
+}
+
+type RawSockaddrInet6 struct {
+	Len uint8;
+	Family uint8;
+	Port uint16;
+	Flowinfo uint32;
+	Addr [16]byte /* in6_addr */;
+	Scope_id uint32;
+}
+
+type RawSockaddrUnix struct {
+	Len uint8;
+	Family uint8;
+	Path [104]int8;
+}
+
+type RawSockaddr struct {
+	Len uint8;
+	Family uint8;
+	Data [14]int8;
+}
+
+type RawSockaddrAny struct {
+	Addr RawSockaddr;
+	Pad [12]int8;
+}
+
+type _Socklen uint32
+
+type Linger struct {
+	Onoff int32;
+	Linger int32;
+}
+
+type Kevent_t struct {
+	Ident uint32;
+	Filter int16;
+	Flags uint16;
+	Fflags uint32;
+	Data int32;
+	Udata *byte;
+}
+
+type FdSet struct {
+	Bits [32]int32;
+}
