commit 397453f6adc1e352b866d3dd14899da3b2cb7547
Author: cui fliter <imcusg@gmail.com>
Date:   Fri Nov 3 21:29:21 2023 +0800

    strconv: add available godoc link
    
    Change-Id: Iad58155f29a101fb72768b170c0c2c9d76b6041a
    Reviewed-on: https://go-review.googlesource.com/c/go/+/539357
    Reviewed-by: Ian Lance Taylor <iant@google.com>
    Auto-Submit: Ian Lance Taylor <iant@google.com>
    LUCI-TryBot-Result: Go LUCI <golang-scoped@luci-project-accounts.iam.gserviceaccount.com>
    Reviewed-by: qiu laidongfeng2 <2645477756@qq.com>
    Run-TryBot: shuang cui <imcusg@gmail.com>
    TryBot-Result: Gopher Robot <gobot@golang.org>
    Reviewed-by: Dmitri Shuralyov <dmitshur@google.com>
---
 src/strconv/atoc.go  |  4 ++--
 src/strconv/atoi.go  |  8 ++++----
 src/strconv/ctoa.go  |  2 +-
 src/strconv/doc.go   |  2 +-
 src/strconv/ftoa.go  |  2 +-
 src/strconv/itoa.go  |  6 +++---
 src/strconv/quote.go | 28 ++++++++++++++--------------
 7 files changed, 26 insertions(+), 26 deletions(-)

diff --git a/src/strconv/atoc.go b/src/strconv/atoc.go
index f6fdd14e64..8cf975d3e1 100644
--- a/src/strconv/atoc.go
+++ b/src/strconv/atoc.go
@@ -25,13 +25,13 @@ func convErr(err error, s string) (syntax, range_ error) {
 // convertible to complex64 without changing its value.
 //
 // The number represented by s must be of the form N, Ni, or N±Ni, where N stands
-// for a floating-point number as recognized by ParseFloat, and i is the imaginary
+// for a floating-point number as recognized by [ParseFloat], and i is the imaginary
 // component. If the second N is unsigned, a + sign is required between the two components
 // as indicated by the ±. If the second N is NaN, only a + sign is accepted.
 // The form may be parenthesized and cannot contain any spaces.
 // The resulting complex number consists of the two components converted by ParseFloat.
 //
-// The errors that ParseComplex returns have concrete type *NumError
+// The errors that ParseComplex returns have concrete type [*NumError]
 // and include err.Num = s.
 //
 // If s is not syntactically well-formed, ParseComplex returns err.Err = ErrSyntax.
diff --git a/src/strconv/atoi.go b/src/strconv/atoi.go
index 520d826323..45341820cd 100644
--- a/src/strconv/atoi.go
+++ b/src/strconv/atoi.go
@@ -72,7 +72,7 @@ const IntSize = intSize
 
 const maxUint64 = 1<<64 - 1
 
-// ParseUint is like ParseInt but for unsigned numbers.
+// ParseUint is like [ParseInt] but for unsigned numbers.
 //
 // A sign prefix is not permitted.
 func ParseUint(s string, base int, bitSize int) (uint64, error) {
@@ -190,11 +190,11 @@ func ParseUint(s string, base int, bitSize int) (uint64, error) {
 // correspond to int, int8, int16, int32, and int64.
 // If bitSize is below 0 or above 64, an error is returned.
 //
-// The errors that ParseInt returns have concrete type *NumError
+// The errors that ParseInt returns have concrete type [*NumError]
 // and include err.Num = s. If s is empty or contains invalid
-// digits, err.Err = ErrSyntax and the returned value is 0;
+// digits, err.Err = [ErrSyntax] and the returned value is 0;
 // if the value corresponding to s cannot be represented by a
-// signed integer of the given size, err.Err = ErrRange and the
+// signed integer of the given size, err.Err = [ErrRange] and the
 // returned value is the maximum magnitude integer of the
 // appropriate bitSize and sign.
 //
diff --git a/src/strconv/ctoa.go b/src/strconv/ctoa.go
index c16a2e579c..fd7f941d70 100644
--- a/src/strconv/ctoa.go
+++ b/src/strconv/ctoa.go
@@ -8,7 +8,7 @@ package strconv
 // form (a+bi) where a and b are the real and imaginary parts,
 // formatted according to the format fmt and precision prec.
 //
-// The format fmt and precision prec have the same meaning as in FormatFloat.
+// The format fmt and precision prec have the same meaning as in [FormatFloat].
 // It rounds the result assuming that the original was obtained from a complex
 // value of bitSize bits, which must be 64 for complex64 and 128 for complex128.
 func FormatComplex(c complex128, fmt byte, prec, bitSize int) string {
diff --git a/src/strconv/doc.go b/src/strconv/doc.go
index fa20f902d0..51033a62f6 100644
--- a/src/strconv/doc.go
+++ b/src/strconv/doc.go
@@ -7,7 +7,7 @@
 //
 // # Numeric Conversions
 //
-// The most common numeric conversions are Atoi (string to int) and Itoa (int to string).
+// The most common numeric conversions are [Atoi] (string to int) and [Itoa] (int to string).
 //
 //	i, err := strconv.Atoi("-42")
 //	s := strconv.Itoa(-42)
diff --git a/src/strconv/ftoa.go b/src/strconv/ftoa.go
index c514e663da..220869898f 100644
--- a/src/strconv/ftoa.go
+++ b/src/strconv/ftoa.go
@@ -49,7 +49,7 @@ func FormatFloat(f float64, fmt byte, prec, bitSize int) string {
 }
 
 // AppendFloat appends the string form of the floating-point number f,
-// as generated by FormatFloat, to dst and returns the extended buffer.
+// as generated by [FormatFloat], to dst and returns the extended buffer.
 func AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte {
 	return genericFtoa(dst, f, fmt, prec, bitSize)
 }
diff --git a/src/strconv/itoa.go b/src/strconv/itoa.go
index b0c2666e7c..29fec41fe2 100644
--- a/src/strconv/itoa.go
+++ b/src/strconv/itoa.go
@@ -30,13 +30,13 @@ func FormatInt(i int64, base int) string {
 	return s
 }
 
-// Itoa is equivalent to FormatInt(int64(i), 10).
+// Itoa is equivalent to [FormatInt](int64(i), 10).
 func Itoa(i int) string {
 	return FormatInt(int64(i), 10)
 }
 
 // AppendInt appends the string form of the integer i,
-// as generated by FormatInt, to dst and returns the extended buffer.
+// as generated by [FormatInt], to dst and returns the extended buffer.
 func AppendInt(dst []byte, i int64, base int) []byte {
 	if fastSmalls && 0 <= i && i < nSmalls && base == 10 {
 		return append(dst, small(int(i))...)
@@ -46,7 +46,7 @@ func AppendInt(dst []byte, i int64, base int) []byte {
 }
 
 // AppendUint appends the string form of the unsigned integer i,
-// as generated by FormatUint, to dst and returns the extended buffer.
+// as generated by [FormatUint], to dst and returns the extended buffer.
 func AppendUint(dst []byte, i uint64, base int) []byte {
 	if fastSmalls && i < nSmalls && base == 10 {
 		return append(dst, small(int(i))...)
diff --git a/src/strconv/quote.go b/src/strconv/quote.go
index b4d200b0dc..d626cd0837 100644
--- a/src/strconv/quote.go
+++ b/src/strconv/quote.go
@@ -121,47 +121,47 @@ func appendEscapedRune(buf []byte, r rune, quote byte, ASCIIonly, graphicOnly bo
 // Quote returns a double-quoted Go string literal representing s. The
 // returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for
 // control characters and non-printable characters as defined by
-// IsPrint.
+// [IsPrint].
 func Quote(s string) string {
 	return quoteWith(s, '"', false, false)
 }
 
 // AppendQuote appends a double-quoted Go string literal representing s,
-// as generated by Quote, to dst and returns the extended buffer.
+// as generated by [Quote], to dst and returns the extended buffer.
 func AppendQuote(dst []byte, s string) []byte {
 	return appendQuotedWith(dst, s, '"', false, false)
 }
 
 // QuoteToASCII returns a double-quoted Go string literal representing s.
 // The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for
-// non-ASCII characters and non-printable characters as defined by IsPrint.
+// non-ASCII characters and non-printable characters as defined by [IsPrint].
 func QuoteToASCII(s string) string {
 	return quoteWith(s, '"', true, false)
 }
 
 // AppendQuoteToASCII appends a double-quoted Go string literal representing s,
-// as generated by QuoteToASCII, to dst and returns the extended buffer.
+// as generated by [QuoteToASCII], to dst and returns the extended buffer.
 func AppendQuoteToASCII(dst []byte, s string) []byte {
 	return appendQuotedWith(dst, s, '"', true, false)
 }
 
 // QuoteToGraphic returns a double-quoted Go string literal representing s.
 // The returned string leaves Unicode graphic characters, as defined by
-// IsGraphic, unchanged and uses Go escape sequences (\t, \n, \xFF, \u0100)
+// [IsGraphic], unchanged and uses Go escape sequences (\t, \n, \xFF, \u0100)
 // for non-graphic characters.
 func QuoteToGraphic(s string) string {
 	return quoteWith(s, '"', false, true)
 }
 
 // AppendQuoteToGraphic appends a double-quoted Go string literal representing s,
-// as generated by QuoteToGraphic, to dst and returns the extended buffer.
+// as generated by [QuoteToGraphic], to dst and returns the extended buffer.
 func AppendQuoteToGraphic(dst []byte, s string) []byte {
 	return appendQuotedWith(dst, s, '"', false, true)
 }
 
 // QuoteRune returns a single-quoted Go character literal representing the
 // rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100)
-// for control characters and non-printable characters as defined by IsPrint.
+// for control characters and non-printable characters as defined by [IsPrint].
 // If r is not a valid Unicode code point, it is interpreted as the Unicode
 // replacement character U+FFFD.
 func QuoteRune(r rune) string {
@@ -169,7 +169,7 @@ func QuoteRune(r rune) string {
 }
 
 // AppendQuoteRune appends a single-quoted Go character literal representing the rune,
-// as generated by QuoteRune, to dst and returns the extended buffer.
+// as generated by [QuoteRune], to dst and returns the extended buffer.
 func AppendQuoteRune(dst []byte, r rune) []byte {
 	return appendQuotedRuneWith(dst, r, '\'', false, false)
 }
@@ -177,7 +177,7 @@ func AppendQuoteRune(dst []byte, r rune) []byte {
 // QuoteRuneToASCII returns a single-quoted Go character literal representing
 // the rune. The returned string uses Go escape sequences (\t, \n, \xFF,
 // \u0100) for non-ASCII characters and non-printable characters as defined
-// by IsPrint.
+// by [IsPrint].
 // If r is not a valid Unicode code point, it is interpreted as the Unicode
 // replacement character U+FFFD.
 func QuoteRuneToASCII(r rune) string {
@@ -185,14 +185,14 @@ func QuoteRuneToASCII(r rune) string {
 }
 
 // AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune,
-// as generated by QuoteRuneToASCII, to dst and returns the extended buffer.
+// as generated by [QuoteRuneToASCII], to dst and returns the extended buffer.
 func AppendQuoteRuneToASCII(dst []byte, r rune) []byte {
 	return appendQuotedRuneWith(dst, r, '\'', true, false)
 }
 
 // QuoteRuneToGraphic returns a single-quoted Go character literal representing
 // the rune. If the rune is not a Unicode graphic character,
-// as defined by IsGraphic, the returned string will use a Go escape sequence
+// as defined by [IsGraphic], the returned string will use a Go escape sequence
 // (\t, \n, \xFF, \u0100).
 // If r is not a valid Unicode code point, it is interpreted as the Unicode
 // replacement character U+FFFD.
@@ -201,7 +201,7 @@ func QuoteRuneToGraphic(r rune) string {
 }
 
 // AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune,
-// as generated by QuoteRuneToGraphic, to dst and returns the extended buffer.
+// as generated by [QuoteRuneToGraphic], to dst and returns the extended buffer.
 func AppendQuoteRuneToGraphic(dst []byte, r rune) []byte {
 	return appendQuotedRuneWith(dst, r, '\'', false, true)
 }
@@ -367,7 +367,7 @@ func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string,
 	return
 }
 
-// QuotedPrefix returns the quoted string (as understood by Unquote) at the prefix of s.
+// QuotedPrefix returns the quoted string (as understood by [Unquote]) at the prefix of s.
 // If s does not start with a valid quoted string, QuotedPrefix returns an error.
 func QuotedPrefix(s string) (string, error) {
 	out, _, err := unquote(s, false)
@@ -516,7 +516,7 @@ func bsearch[S ~[]E, E ~uint16 | ~uint32](s S, v E) (int, bool) {
 // That would be nice.
 
 // IsPrint reports whether the rune is defined as printable by Go, with
-// the same definition as unicode.IsPrint: letters, numbers, punctuation,
+// the same definition as [unicode.IsPrint]: letters, numbers, punctuation,
 // symbols and ASCII space.
 func IsPrint(r rune) bool {
 	// Fast check for Latin-1
