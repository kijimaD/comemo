commit 6c979d252287b245cc982374400fb968551272fb
Author: Robert Griesemer <gri@golang.org>
Date:   Tue Feb 20 16:14:42 2024 -0800

    go/types: generate typestring.go from types2 source
    
    This CL reduces the amount of code that needs to be maintained
    manually by about 500 LOC.
    
    Change-Id: I643bea15203f7a916ef78b2738f125aa5b312eed
    Reviewed-on: https://go-review.googlesource.com/c/go/+/565438
    Reviewed-by: Robert Findley <rfindley@google.com>
    Reviewed-by: Robert Griesemer <gri@google.com>
    LUCI-TryBot-Result: Go LUCI <golang-scoped@luci-project-accounts.iam.gserviceaccount.com>
    Auto-Submit: Robert Griesemer <gri@google.com>
---
 src/cmd/compile/internal/types2/typestring.go | 20 +++++++++++++-------
 src/go/types/generate_test.go                 |  1 +
 src/go/types/typestring.go                    | 23 ++++++++++++++---------
 3 files changed, 28 insertions(+), 16 deletions(-)

diff --git a/src/cmd/compile/internal/types2/typestring.go b/src/cmd/compile/internal/types2/typestring.go
index 4b410af6b7..723c074e60 100644
--- a/src/cmd/compile/internal/types2/typestring.go
+++ b/src/cmd/compile/internal/types2/typestring.go
@@ -16,18 +16,18 @@ import (
 )
 
 // A Qualifier controls how named package-level objects are printed in
-// calls to TypeString, ObjectString, and SelectionString.
+// calls to [TypeString], [ObjectString], and [SelectionString].
 //
 // These three formatting routines call the Qualifier for each
 // package-level object O, and if the Qualifier returns a non-empty
 // string p, the object is printed in the form p.O.
 // If it returns an empty string, only the object name O is printed.
 //
-// Using a nil Qualifier is equivalent to using (*Package).Path: the
+// Using a nil Qualifier is equivalent to using (*[Package]).Path: the
 // object is qualified by the import path, e.g., "encoding/json.Marshal".
 type Qualifier func(*Package) string
 
-// RelativeTo returns a Qualifier that fully qualifies members of
+// RelativeTo returns a [Qualifier] that fully qualifies members of
 // all packages other than pkg.
 func RelativeTo(pkg *Package) Qualifier {
 	if pkg == nil {
@@ -42,7 +42,7 @@ func RelativeTo(pkg *Package) Qualifier {
 }
 
 // TypeString returns the string representation of typ.
-// The Qualifier controls the printing of
+// The [Qualifier] controls the printing of
 // package-level objects, and may be nil.
 func TypeString(typ Type, qf Qualifier) string {
 	var buf bytes.Buffer
@@ -51,14 +51,14 @@ func TypeString(typ Type, qf Qualifier) string {
 }
 
 // WriteType writes the string representation of typ to buf.
-// The Qualifier controls the printing of
+// The [Qualifier] controls the printing of
 // package-level objects, and may be nil.
 func WriteType(buf *bytes.Buffer, typ Type, qf Qualifier) {
 	newTypeWriter(buf, qf).typ(typ)
 }
 
 // WriteSignature writes the representation of the signature sig to buf,
-// without a leading "func" keyword. The Qualifier controls the printing
+// without a leading "func" keyword. The [Qualifier] controls the printing
 // of package-level objects, and may be nil.
 func WriteSignature(buf *bytes.Buffer, sig *Signature, qf Qualifier) {
 	newTypeWriter(buf, qf).signature(sig)
@@ -322,7 +322,13 @@ func (w *typeWriter) typ(typ Type) {
 			// error messages. This doesn't need to be super-elegant; we just
 			// need a clear indication that this is not a predeclared name.
 			if w.ctxt == nil && Universe.Lookup(t.obj.name) != nil {
-				w.string(fmt.Sprintf(" /* with %s declared at %s */", t.obj.name, t.obj.Pos()))
+				if isTypes2 {
+					w.string(fmt.Sprintf(" /* with %s declared at %v */", t.obj.name, t.obj.Pos()))
+				} else {
+					// Can't print position information because
+					// we don't have a token.FileSet accessible.
+					w.string("/* type parameter */")
+				}
 			}
 		}
 
diff --git a/src/go/types/generate_test.go b/src/go/types/generate_test.go
index 7399acf872..3d1bcc6b7f 100644
--- a/src/go/types/generate_test.go
+++ b/src/go/types/generate_test.go
@@ -146,6 +146,7 @@ var filemap = map[string]action{
 	"typeparam.go":        nil,
 	"typeterm_test.go":    nil,
 	"typeterm.go":         nil,
+	"typestring.go":       nil,
 	"under.go":            nil,
 	"unify.go":            fixSprintf,
 	"universe.go":         fixGlobalTypVarDecl,
diff --git a/src/go/types/typestring.go b/src/go/types/typestring.go
index 23bddb2673..210ab0515f 100644
--- a/src/go/types/typestring.go
+++ b/src/go/types/typestring.go
@@ -1,3 +1,5 @@
+// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
+
 // Copyright 2013 The Go Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
@@ -9,7 +11,6 @@ package types
 import (
 	"bytes"
 	"fmt"
-	"go/token"
 	"sort"
 	"strconv"
 	"strings"
@@ -125,7 +126,7 @@ func (w *typeWriter) typ(typ Type) {
 	case *Basic:
 		// exported basic types go into package unsafe
 		// (currently this is just unsafe.Pointer)
-		if token.IsExported(t.name) {
+		if isExported(t.name) {
 			if obj, _ := Unsafe.scope.Lookup(t.name).(*TypeName); obj != nil {
 				w.typeName(obj)
 				break
@@ -153,7 +154,7 @@ func (w *typeWriter) typ(typ Type) {
 			// If disambiguating one struct for another, look for the first unexported field.
 			// Do this first in case of nested structs; tag the first-outermost field.
 			pkgAnnotate := false
-			if w.qf == nil && w.pkgInfo && !token.IsExported(f.name) {
+			if w.qf == nil && w.pkgInfo && !isExported(f.name) {
 				// note for embedded types, type name is field name, and "string" etc are lower case hence unexported.
 				pkgAnnotate = true
 				w.pkgInfo = false // only tag once
@@ -174,9 +175,9 @@ func (w *typeWriter) typ(typ Type) {
 			}
 			if tag := t.Tag(i); tag != "" {
 				w.byte(' ')
-				// TODO(rfindley) If tag contains blanks, replacing them with '#'
-				//                in Context.TypeHash may produce another tag
-				//                accidentally.
+				// TODO(gri) If tag contains blanks, replacing them with '#'
+				//           in Context.TypeHash may produce another tag
+				//           accidentally.
 				w.string(strconv.Quote(tag))
 			}
 		}
@@ -322,10 +323,14 @@ func (w *typeWriter) typ(typ Type) {
 			// (say int), point out where it is declared to avoid confusing
 			// error messages. This doesn't need to be super-elegant; we just
 			// need a clear indication that this is not a predeclared name.
-			// Note: types2 prints position information here - we can't do
-			//       that because we don't have a token.FileSet accessible.
 			if w.ctxt == nil && Universe.Lookup(t.obj.name) != nil {
-				w.string("/* type parameter */")
+				if isTypes2 {
+					w.string(fmt.Sprintf(" /* with %s declared at %v */", t.obj.name, t.obj.Pos()))
+				} else {
+					// Can't print position information because
+					// we don't have a token.FileSet accessible.
+					w.string("/* type parameter */")
+				}
 			}
 		}
 
