commit e1033d07b454c60623995bf84076b85f70e77225
Author: Peter Froehlich <peter.hans.froehlich@gmail.com>
Date:   Thu Dec 24 08:43:35 2009 +1100

    Add query to find number of subexpressions.
    
    This was convenient for me to have without being forced
    to parse the regexp myself. I'd understand if it's not
    really wanted, but I also think that some meta information
    about compiled regexps would be fine.
    
    R=r, rsc
    CC=golang-dev
    https://golang.org/cl/183044
---
 src/pkg/regexp/all_test.go | 28 ++++++++++++++++++++++++++++
 src/pkg/regexp/regexp.go   |  3 +++
 2 files changed, 31 insertions(+)

diff --git a/src/pkg/regexp/all_test.go b/src/pkg/regexp/all_test.go
index 0c274139b6..05bba73765 100644
--- a/src/pkg/regexp/all_test.go
+++ b/src/pkg/regexp/all_test.go
@@ -454,6 +454,34 @@ func TestAllMatches(t *testing.T) {
 	}
 }
 
+type numSubexpCase struct {
+	input    string
+	expected int
+}
+
+var numSubexpCases = []numSubexpCase{
+	numSubexpCase{``, 0},
+	numSubexpCase{`.*`, 0},
+	numSubexpCase{`abba`, 0},
+	numSubexpCase{`ab(b)a`, 1},
+	numSubexpCase{`ab(.*)a`, 1},
+	numSubexpCase{`(.*)ab(.*)a`, 2},
+	numSubexpCase{`(.*)(ab)(.*)a`, 3},
+	numSubexpCase{`(.*)((a)b)(.*)a`, 4},
+	numSubexpCase{`(.*)(\(ab)(.*)a`, 3},
+	numSubexpCase{`(.*)(\(a\)b)(.*)a`, 3},
+}
+
+func TestNumSubexp(t *testing.T) {
+	for _, c := range numSubexpCases {
+		re, _ := Compile(c.input)
+		n := re.NumSubexp()
+		if n != c.expected {
+			t.Errorf("NumSubexp for %q returned %d, expected %d", c.input, n, c.expected)
+		}
+	}
+}
+
 func BenchmarkLiteral(b *testing.B) {
 	x := strings.Repeat("x", 50)
 	b.StopTimer()
diff --git a/src/pkg/regexp/regexp.go b/src/pkg/regexp/regexp.go
index fd6fbefee8..373d6b1af1 100644
--- a/src/pkg/regexp/regexp.go
+++ b/src/pkg/regexp/regexp.go
@@ -677,6 +677,9 @@ func MustCompile(str string) *Regexp {
 	return regexp
 }
 
+// NumSubexp returns the number of parenthesized subexpressions in this Regexp.
+func (re *Regexp) NumSubexp() int { return re.nbra }
+
 // The match arena allows us to reduce the garbage generated by tossing
 // match vectors away as we execute.  Matches are ref counted and returned
 // to a free list when no longer active.  Increases a simple benchmark by 22X.
