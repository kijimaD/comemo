commit 9786b3f1bd488be4b1c543eddaa2540623ff9730
Author: Robert Griesemer <gri@golang.org>
Date:   Thu Nov 5 14:43:03 2009 -0800

    gofmt-ify 4s, iterable
    
    R=rsc
    http://go/go-review/1016055
---
 src/pkg/exp/4s/4s.go                  |   8 +-
 src/pkg/exp/4s/data.go                | 248 +++++++++++++-------------
 src/pkg/exp/4s/xs.go                  | 316 ++++++++++++++++++----------------
 src/pkg/exp/iterable/iterable.go      |  78 ++++-----
 src/pkg/exp/iterable/iterable_test.go |  89 +++++-----
 5 files changed, 375 insertions(+), 364 deletions(-)

diff --git a/src/pkg/exp/4s/4s.go b/src/pkg/exp/4s/4s.go
index a81d22b591..f5eb14b6ac 100644
--- a/src/pkg/exp/4s/4s.go
+++ b/src/pkg/exp/4s/4s.go
@@ -32,7 +32,7 @@ func main() {
 		p = pieces5;
 	}
 	dx, dy := 500, 500;
-	w, err := av.Init(av.SubsystemVideo|av.SubsystemAudio, dx, dy);
+	w, err := av.Init(av.SubsystemVideo | av.SubsystemAudio, dx, dy);
 	if err != nil {
 		log.Exit(err);
 	}
@@ -55,7 +55,7 @@ func audioServer() {
 		b := <-sndc;
 		for len(b)*2 >= n {
 			var a []uint16;
-			a, b = b[0:n/2], b[n/2:len(b)];
+			a, b = b[0 : n/2], b[n/2 : len(b)];
 			n, err = av.AudioStream(a);
 			if err != nil {
 				log.Exit(err);
@@ -74,6 +74,6 @@ func PlaySound(b []uint16) {
 	sndc <- b;
 }
 
-var whoosh = []uint16 {
-	// Insert your favorite sound samples here.
+var whoosh = []uint16{
+// Insert your favorite sound samples here.
 }
diff --git a/src/pkg/exp/4s/data.go b/src/pkg/exp/4s/data.go
index 421594cc0b..ac30fabf72 100644
--- a/src/pkg/exp/4s/data.go
+++ b/src/pkg/exp/4s/data.go
@@ -13,130 +13,130 @@ package main
 import . "exp/draw"
 
 var pieces4 = []Piece{
-	Piece{ 0, 0, Point{4,1},  []Point{ Point{0,0},  Point{1,0},  Point{1,0},  Point{1,0} }, nil, nil},
-	Piece{ 1, 0, Point{1,4},  []Point{ Point{0,0},  Point{0,1},  Point{0,1},  Point{0,1} }, nil, nil},
-	Piece{ 2, 0, Point{4,1},  []Point{ Point{0,0},  Point{1,0},  Point{1,0},  Point{1,0} }, nil, nil},
-	Piece{ 3, 0, Point{1,4},  []Point{ Point{0,0},  Point{0,1},  Point{0,1},  Point{0,1} }, nil, nil},
-
-	Piece{ 0, 3, Point{2,2},  []Point{ Point{0,1},  Point{1,0},  Point{0,-1}, Point{-1,0}}, nil, nil},
-	Piece{ 1, 3, Point{2,2},  []Point{ Point{0,1},  Point{1,0},  Point{0,-1}, Point{-1,0}}, nil, nil},
-	Piece{ 2, 3, Point{2,2},  []Point{ Point{0,1},  Point{1,0},  Point{0,-1}, Point{-1,0}}, nil, nil},
-	Piece{ 3, 3, Point{2,2},  []Point{ Point{0,1},  Point{1,0},  Point{0,-1}, Point{-1,0}}, nil, nil},
-
-	Piece{ 0, 1, Point{3,2},  []Point{ Point{0,0},  Point{1,0},  Point{1,0},  Point{0,1} }, nil, nil},
-	Piece{ 1, 1, Point{2,3},  []Point{ Point{1,0},  Point{0,1},  Point{0,1}, Point{-1,0} }, nil, nil},
-	Piece{ 2, 1, Point{3,2},  []Point{ Point{0,0},  Point{0,1},  Point{1,0},  Point{1,0} }, nil, nil},
-	Piece{ 3, 1, Point{2,3},  []Point{ Point{0,0},  Point{1,0}, Point{-1,1},  Point{0,1} }, nil, nil},
-
-	Piece{ 0, 2, Point{3,2},  []Point{ Point{0,1},  Point{1,0},  Point{1,0},  Point{0,-1}}, nil, nil},
-	Piece{ 1, 2, Point{2,3},  []Point{ Point{0,0},  Point{0,1},  Point{0,1},  Point{1,0} }, nil, nil},
-	Piece{ 2, 2, Point{3,2},  []Point{ Point{0,0},  Point{1,0},  Point{1,0}, Point{-2,1} }, nil, nil},
-	Piece{ 3, 2, Point{2,3},  []Point{ Point{0,0},  Point{1,0},  Point{0,1},  Point{0,1} }, nil, nil},
-
-	Piece{ 0, 4, Point{3,2},  []Point{ Point{0,0},  Point{1,0},  Point{1,0}, Point{-1,1} }, nil, nil},
-	Piece{ 1, 4, Point{2,3},  []Point{ Point{1,0}, Point{-1,1},  Point{1,0},  Point{0,1} }, nil, nil},
-	Piece{ 2, 4, Point{3,2},  []Point{ Point{1,0}, Point{-1,1},  Point{1,0},  Point{1,0} }, nil, nil},
-	Piece{ 3, 4, Point{2,3},  []Point{ Point{0,0},  Point{0,1},  Point{0,1},  Point{1,-1}}, nil, nil},
-
-	Piece{ 0, 5, Point{3,2},  []Point{ Point{0,0},  Point{1,0},  Point{0,1},  Point{1,0} }, nil, nil},
-	Piece{ 1, 5, Point{2,3},  []Point{ Point{1,0},  Point{0,1},  Point{-1,0}, Point{0,1} }, nil, nil},
-	Piece{ 2, 5, Point{3,2},  []Point{ Point{0,0},  Point{1,0},  Point{0,1},  Point{1,0} }, nil, nil},
-	Piece{ 3, 5, Point{2,3},  []Point{ Point{1,0},  Point{0,1},  Point{-1,0}, Point{0,1} }, nil, nil},
-
-	Piece{ 0, 6, Point{3,2},  []Point{ Point{0,1},  Point{1,0},  Point{0,-1}, Point{1,0} }, nil, nil},
-	Piece{ 1, 6, Point{2,3},  []Point{ Point{0,0},  Point{0,1},  Point{1,0},  Point{0,1} }, nil, nil},
-	Piece{ 2, 6, Point{3,2},  []Point{ Point{0,1},  Point{1,0},  Point{0,-1}, Point{1,0} }, nil, nil},
-	Piece{ 3, 6, Point{2,3},  []Point{ Point{0,0},  Point{0,1},  Point{1,0},  Point{0,1} }, nil, nil},
+	Piece{0, 0, Point{4, 1}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{1, 0}}, nil, nil},
+	Piece{1, 0, Point{1, 4}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{0, 1}}, nil, nil},
+	Piece{2, 0, Point{4, 1}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{1, 0}}, nil, nil},
+	Piece{3, 0, Point{1, 4}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{0, 1}}, nil, nil},
+
+	Piece{0, 3, Point{2, 2}, []Point{Point{0, 1}, Point{1, 0}, Point{0, -1}, Point{-1, 0}}, nil, nil},
+	Piece{1, 3, Point{2, 2}, []Point{Point{0, 1}, Point{1, 0}, Point{0, -1}, Point{-1, 0}}, nil, nil},
+	Piece{2, 3, Point{2, 2}, []Point{Point{0, 1}, Point{1, 0}, Point{0, -1}, Point{-1, 0}}, nil, nil},
+	Piece{3, 3, Point{2, 2}, []Point{Point{0, 1}, Point{1, 0}, Point{0, -1}, Point{-1, 0}}, nil, nil},
+
+	Piece{0, 1, Point{3, 2}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{0, 1}}, nil, nil},
+	Piece{1, 1, Point{2, 3}, []Point{Point{1, 0}, Point{0, 1}, Point{0, 1}, Point{-1, 0}}, nil, nil},
+	Piece{2, 1, Point{3, 2}, []Point{Point{0, 0}, Point{0, 1}, Point{1, 0}, Point{1, 0}}, nil, nil},
+	Piece{3, 1, Point{2, 3}, []Point{Point{0, 0}, Point{1, 0}, Point{-1, 1}, Point{0, 1}}, nil, nil},
+
+	Piece{0, 2, Point{3, 2}, []Point{Point{0, 1}, Point{1, 0}, Point{1, 0}, Point{0, -1}}, nil, nil},
+	Piece{1, 2, Point{2, 3}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{1, 0}}, nil, nil},
+	Piece{2, 2, Point{3, 2}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{-2, 1}}, nil, nil},
+	Piece{3, 2, Point{2, 3}, []Point{Point{0, 0}, Point{1, 0}, Point{0, 1}, Point{0, 1}}, nil, nil},
+
+	Piece{0, 4, Point{3, 2}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{-1, 1}}, nil, nil},
+	Piece{1, 4, Point{2, 3}, []Point{Point{1, 0}, Point{-1, 1}, Point{1, 0}, Point{0, 1}}, nil, nil},
+	Piece{2, 4, Point{3, 2}, []Point{Point{1, 0}, Point{-1, 1}, Point{1, 0}, Point{1, 0}}, nil, nil},
+	Piece{3, 4, Point{2, 3}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{1, -1}}, nil, nil},
+
+	Piece{0, 5, Point{3, 2}, []Point{Point{0, 0}, Point{1, 0}, Point{0, 1}, Point{1, 0}}, nil, nil},
+	Piece{1, 5, Point{2, 3}, []Point{Point{1, 0}, Point{0, 1}, Point{-1, 0}, Point{0, 1}}, nil, nil},
+	Piece{2, 5, Point{3, 2}, []Point{Point{0, 0}, Point{1, 0}, Point{0, 1}, Point{1, 0}}, nil, nil},
+	Piece{3, 5, Point{2, 3}, []Point{Point{1, 0}, Point{0, 1}, Point{-1, 0}, Point{0, 1}}, nil, nil},
+
+	Piece{0, 6, Point{3, 2}, []Point{Point{0, 1}, Point{1, 0}, Point{0, -1}, Point{1, 0}}, nil, nil},
+	Piece{1, 6, Point{2, 3}, []Point{Point{0, 0}, Point{0, 1}, Point{1, 0}, Point{0, 1}}, nil, nil},
+	Piece{2, 6, Point{3, 2}, []Point{Point{0, 1}, Point{1, 0}, Point{0, -1}, Point{1, 0}}, nil, nil},
+	Piece{3, 6, Point{2, 3}, []Point{Point{0, 0}, Point{0, 1}, Point{1, 0}, Point{0, 1}}, nil, nil},
 }
 
 var pieces5 = []Piece{
-	Piece{ 0, 1, Point{5,1},  []Point{ Point{0,0},  Point{1,0},  Point{1,0},  Point{1,0},  Point{1,0} }, nil, nil},
-	Piece{ 1, 1, Point{1,5},  []Point{ Point{0,0},  Point{0,1},  Point{0,1},  Point{0,1},  Point{0,1} }, nil, nil},
-	Piece{ 2, 1, Point{5,1},  []Point{ Point{0,0},  Point{1,0},  Point{1,0},  Point{1,0},  Point{1,0} }, nil, nil},
-	Piece{ 3, 1, Point{1,5},  []Point{ Point{0,0},  Point{0,1},  Point{0,1},  Point{0,1},  Point{0,1} }, nil, nil},
-
-	Piece{ 0, 0, Point{4,2},  []Point{ Point{0,0},  Point{1,0},  Point{1,0},  Point{1,0},  Point{0,1} }, nil, nil},
-	Piece{ 1, 0, Point{2,4},  []Point{ Point{1,0},  Point{0,1},  Point{0,1},  Point{0,1}, Point{-1,0} }, nil, nil},
-	Piece{ 2, 0, Point{4,2},  []Point{ Point{0,0},  Point{0,1},  Point{1,0},  Point{1,0},  Point{1,0} }, nil, nil},
-	Piece{ 3, 0, Point{2,4},  []Point{ Point{0,0},  Point{1,0}, Point{-1,1},  Point{0,1},  Point{0,1} }, nil, nil},
-
-	Piece{ 0, 2, Point{4,2},  []Point{ Point{0,0},  Point{0,1},  Point{1,-1}, Point{1,0},  Point{1,0} }, nil, nil},
-	Piece{ 1, 2, Point{2,4},  []Point{ Point{0,0},  Point{1,0},  Point{0,1},  Point{0,1},  Point{0,1} }, nil, nil},
-	Piece{ 2, 2, Point{4,2},  []Point{ Point{0,1},  Point{1,0},  Point{1,0},  Point{1,0},  Point{0,-1}}, nil, nil},
-	Piece{ 3, 2, Point{2,4},  []Point{ Point{0,0},  Point{0,1},  Point{0,1},  Point{0,1},  Point{1,0} }, nil, nil},
-
-	Piece{ 0, 7, Point{3,3},  []Point{ Point{0,0},  Point{1,0},  Point{1,0},  Point{0,1},  Point{0,1} }, nil, nil},
-	Piece{ 1, 7, Point{3,3},  []Point{ Point{0,2},  Point{1,0},  Point{1,0},  Point{0,-1}, Point{0,-1}}, nil, nil},
-	Piece{ 2, 7, Point{3,3},  []Point{ Point{0,0},  Point{0,1},  Point{0,1},  Point{1,0},  Point{1,0} }, nil, nil},
-	Piece{ 3, 7, Point{3,3},  []Point{ Point{0,2},  Point{0,-1}, Point{0,-1}, Point{1,0},  Point{1,0} }, nil, nil},
-
-	Piece{ 0, 3, Point{3,2},  []Point{ Point{0,0},  Point{1,0},  Point{1,0}, Point{-2,1},  Point{1,0} }, nil, nil},
-	Piece{ 1, 3, Point{2,3},  []Point{ Point{0,0},  Point{1,0}, Point{-1,1},  Point{1,0},  Point{0,1} }, nil, nil},
-	Piece{ 2, 3, Point{3,2},  []Point{ Point{1,0},  Point{1,0}, Point{-2,1},  Point{1,0},  Point{1,0} }, nil, nil},
-	Piece{ 3, 3, Point{2,3},  []Point{ Point{0,0},  Point{0,1},  Point{1,0}, Point{-1,1},  Point{1,0} }, nil, nil},
-
-	Piece{ 0, 4, Point{3,2},  []Point{ Point{0,0},  Point{1,0},  Point{1,0}, Point{-1,1},  Point{1,0} }, nil, nil},
-	Piece{ 1, 4, Point{2,3},  []Point{ Point{1,0}, Point{-1,1},  Point{1,0}, Point{-1,1},  Point{1,0} }, nil, nil},
-	Piece{ 2, 4, Point{3,2},  []Point{ Point{0,0},  Point{1,0}, Point{-1,1},  Point{1,0},  Point{1,0} }, nil, nil},
-	Piece{ 3, 4, Point{2,3},  []Point{ Point{0,0},  Point{1,0}, Point{-1,1},  Point{1,0}, Point{-1,1} }, nil, nil},
-
-	Piece{ 0, 7, Point{3,2},  []Point{ Point{0,0},  Point{2,0}, Point{-2,1},  Point{1,0},  Point{1,0} }, nil, nil},
-	Piece{ 1, 7, Point{2,3},  []Point{ Point{0,0},  Point{1,0}, Point{-1,1},  Point{0,1},  Point{1,0} }, nil, nil},
-	Piece{ 2, 7, Point{3,2},  []Point{ Point{0,0},  Point{1,0},  Point{1,0}, Point{-2,1},  Point{2,0} }, nil, nil},
-	Piece{ 3, 7, Point{2,3},  []Point{ Point{0,0},  Point{1,0},  Point{0,1}, Point{-1,1},  Point{1,0} }, nil, nil},
-
-	Piece{ 0, 5, Point{3,3},  []Point{ Point{0,0},  Point{1,0},  Point{0,1},  Point{1,0}, Point{-1,1} }, nil, nil},
-	Piece{ 1, 5, Point{3,3},  []Point{ Point{2,0}, Point{-2,1},  Point{1,0},  Point{1,0}, Point{-1,1} }, nil, nil},
-	Piece{ 2, 5, Point{3,3},  []Point{ Point{1,0}, Point{-1,1},  Point{1,0},  Point{0,1},  Point{1,0} }, nil, nil},
-	Piece{ 3, 5, Point{3,3},  []Point{ Point{1,0}, Point{-1,1},  Point{1,0},  Point{1,0}, Point{-2,1} }, nil, nil},
-
-	Piece{ 0, 6, Point{3,3},  []Point{ Point{1,0},  Point{1,0}, Point{-2,1},  Point{1,0},  Point{0,1} }, nil, nil},
-	Piece{ 1, 6, Point{3,3},  []Point{ Point{1,0}, Point{-1,1},  Point{1,0},  Point{1,0},  Point{0,1} }, nil, nil},
-	Piece{ 2, 6, Point{3,3},  []Point{ Point{1,0},  Point{0,1},  Point{1,0}, Point{-2,1},  Point{1,0} }, nil, nil},
-	Piece{ 3, 6, Point{3,3},  []Point{ Point{0,0},  Point{0,1},  Point{1,0},  Point{1,0}, Point{-1,1} }, nil, nil},
-
-	Piece{ 0, 0, Point{4,2},  []Point{ Point{0,0},  Point{1,0},  Point{1,0},  Point{1,0}, Point{-2,1} }, nil, nil},
-	Piece{ 1, 0, Point{2,4},  []Point{ Point{1,0}, Point{-1,1},  Point{1,0},  Point{0,1},  Point{0,1} }, nil, nil},
-	Piece{ 2, 0, Point{4,2},  []Point{ Point{2,0}, Point{-2,1},  Point{1,0},  Point{1,0},  Point{1,0} }, nil, nil},
-	Piece{ 3, 0, Point{2,4},  []Point{ Point{0,0},  Point{0,1},  Point{0,1},  Point{1,0}, Point{-1,1} }, nil, nil},
-
-	Piece{ 0, 2, Point{4,2},  []Point{ Point{0,0},  Point{1,0},  Point{1,0},  Point{1,0}, Point{-1,1} }, nil, nil},
-	Piece{ 1, 2, Point{2,4},  []Point{ Point{1,0},  Point{0,1}, Point{-1,1},  Point{1,0},  Point{0,1} }, nil, nil},
-	Piece{ 2, 2, Point{4,2},  []Point{ Point{1,0}, Point{-1,1},  Point{1,0},  Point{1,0},  Point{1,0} }, nil, nil},
-	Piece{ 3, 2, Point{2,4},  []Point{ Point{0,0},  Point{0,1},  Point{1,0}, Point{-1,1},  Point{0,1} }, nil, nil},
-
-	Piece{ 0, 1, Point{3,3},  []Point{ Point{0,0},  Point{1,0},  Point{0,1},  Point{1,0},  Point{0,1} }, nil, nil},
-	Piece{ 1, 1, Point{3,3},  []Point{ Point{2,0}, Point{-1,1},  Point{1,0}, Point{-2,1},  Point{1,0} }, nil, nil},
-	Piece{ 2, 1, Point{3,3},  []Point{ Point{0,0},  Point{0,1},  Point{1,0},  Point{0,1},  Point{1,0} }, nil, nil},
-	Piece{ 3, 1, Point{3,3},  []Point{ Point{1,0},  Point{1,0}, Point{-2,1},  Point{1,0}, Point{-1,1} }, nil, nil},
-
-	Piece{ 0, 3, Point{3,3},  []Point{ Point{0,0},  Point{1,0},  Point{1,0}, Point{-1,1},  Point{0,1} }, nil, nil},
-	Piece{ 1, 3, Point{3,3},  []Point{ Point{2,0}, Point{-2,1},  Point{1,0},  Point{1,0},  Point{0,1} }, nil, nil},
-	Piece{ 2, 3, Point{3,3},  []Point{ Point{1,0},  Point{0,1}, Point{-1,1},  Point{1,0},  Point{1,0} }, nil, nil},
-	Piece{ 3, 3, Point{3,3},  []Point{ Point{0,0},  Point{0,1},  Point{1,0},  Point{1,0}, Point{-2,1} }, nil, nil},
-
-	Piece{ 0, 4, Point{3,3},  []Point{ Point{1,0}, Point{-1,1},  Point{1,0},  Point{1,0}, Point{-1,1} }, nil, nil},
-	Piece{ 1, 4, Point{3,3},  []Point{ Point{1,0}, Point{-1,1},  Point{1,0},  Point{1,0}, Point{-1,1} }, nil, nil},
-	Piece{ 2, 4, Point{3,3},  []Point{ Point{1,0}, Point{-1,1},  Point{1,0},  Point{1,0}, Point{-1,1} }, nil, nil},
-	Piece{ 3, 4, Point{3,3},  []Point{ Point{1,0}, Point{-1,1},  Point{1,0},  Point{1,0}, Point{-1,1} }, nil, nil},
-
-	Piece{ 0, 8, Point{4,2},  []Point{ Point{0,0},  Point{1,0},  Point{0,1},  Point{1,0},  Point{1,0} }, nil, nil},
-	Piece{ 1, 8, Point{2,4},  []Point{ Point{1,0}, Point{-1,1},  Point{1,0}, Point{-1,1},  Point{0,1} }, nil, nil},
-	Piece{ 2, 8, Point{4,2},  []Point{ Point{0,0},  Point{1,0},  Point{1,0},  Point{0,1},  Point{1,0} }, nil, nil},
-	Piece{ 3, 8, Point{2,4},  []Point{ Point{1,0},  Point{0,1}, Point{-1,1},  Point{1,0}, Point{-1,1} }, nil, nil},
-
-	Piece{ 0, 9, Point{4,2},  []Point{ Point{2,0},  Point{1,0}, Point{-3,1},  Point{1,0},  Point{1,0} }, nil, nil},
-	Piece{ 1, 9, Point{2,4},  []Point{ Point{0,0},  Point{0,1},  Point{0,1},  Point{1,0},  Point{0,1} }, nil, nil},
-	Piece{ 2, 9, Point{4,2},  []Point{ Point{1,0},  Point{1,0},  Point{1,0}, Point{-3,1},  Point{1,0} }, nil, nil},
-	Piece{ 3, 9, Point{2,4},  []Point{ Point{0,0},  Point{0,1},  Point{1,0},  Point{0,1},  Point{0,1} }, nil, nil},
-
-	Piece{ 0, 5, Point{3,3},  []Point{ Point{0,0},  Point{0,1},  Point{1,0},  Point{1,0},  Point{0,1} }, nil, nil},
-	Piece{ 1, 5, Point{3,3},  []Point{ Point{1,0},  Point{1,0}, Point{-1,1}, Point{-1,1},  Point{1,0} }, nil, nil},
-	Piece{ 2, 5, Point{3,3},  []Point{ Point{0,0},  Point{0,1},  Point{1,0},  Point{1,0},  Point{0,1} }, nil, nil},
-	Piece{ 3, 5, Point{3,3},  []Point{ Point{1,0},  Point{1,0}, Point{-1,1}, Point{-1,1},  Point{1,0} }, nil, nil},
-
-	Piece{ 0, 6, Point{3,3},  []Point{ Point{2,0}, Point{-2,1},  Point{1,0},  Point{1,0}, Point{-2,1} }, nil, nil},
-	Piece{ 1, 6, Point{3,3},  []Point{ Point{0,0},  Point{1,0},  Point{0,1},  Point{0,1},  Point{1,0} }, nil, nil},
-	Piece{ 2, 6, Point{3,3},  []Point{ Point{2,0}, Point{-2,1},  Point{1,0},  Point{1,0}, Point{-2,1} }, nil, nil},
-	Piece{ 3, 6, Point{3,3},  []Point{ Point{0,0},  Point{1,0},  Point{0,1},  Point{0,1},  Point{1,0} }, nil, nil},
-};
+	Piece{0, 1, Point{5, 1}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{1, 0}, Point{1, 0}}, nil, nil},
+	Piece{1, 1, Point{1, 5}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{0, 1}, Point{0, 1}}, nil, nil},
+	Piece{2, 1, Point{5, 1}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{1, 0}, Point{1, 0}}, nil, nil},
+	Piece{3, 1, Point{1, 5}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{0, 1}, Point{0, 1}}, nil, nil},
+
+	Piece{0, 0, Point{4, 2}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{1, 0}, Point{0, 1}}, nil, nil},
+	Piece{1, 0, Point{2, 4}, []Point{Point{1, 0}, Point{0, 1}, Point{0, 1}, Point{0, 1}, Point{-1, 0}}, nil, nil},
+	Piece{2, 0, Point{4, 2}, []Point{Point{0, 0}, Point{0, 1}, Point{1, 0}, Point{1, 0}, Point{1, 0}}, nil, nil},
+	Piece{3, 0, Point{2, 4}, []Point{Point{0, 0}, Point{1, 0}, Point{-1, 1}, Point{0, 1}, Point{0, 1}}, nil, nil},
+
+	Piece{0, 2, Point{4, 2}, []Point{Point{0, 0}, Point{0, 1}, Point{1, -1}, Point{1, 0}, Point{1, 0}}, nil, nil},
+	Piece{1, 2, Point{2, 4}, []Point{Point{0, 0}, Point{1, 0}, Point{0, 1}, Point{0, 1}, Point{0, 1}}, nil, nil},
+	Piece{2, 2, Point{4, 2}, []Point{Point{0, 1}, Point{1, 0}, Point{1, 0}, Point{1, 0}, Point{0, -1}}, nil, nil},
+	Piece{3, 2, Point{2, 4}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{0, 1}, Point{1, 0}}, nil, nil},
+
+	Piece{0, 7, Point{3, 3}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{0, 1}, Point{0, 1}}, nil, nil},
+	Piece{1, 7, Point{3, 3}, []Point{Point{0, 2}, Point{1, 0}, Point{1, 0}, Point{0, -1}, Point{0, -1}}, nil, nil},
+	Piece{2, 7, Point{3, 3}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{1, 0}, Point{1, 0}}, nil, nil},
+	Piece{3, 7, Point{3, 3}, []Point{Point{0, 2}, Point{0, -1}, Point{0, -1}, Point{1, 0}, Point{1, 0}}, nil, nil},
+
+	Piece{0, 3, Point{3, 2}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{-2, 1}, Point{1, 0}}, nil, nil},
+	Piece{1, 3, Point{2, 3}, []Point{Point{0, 0}, Point{1, 0}, Point{-1, 1}, Point{1, 0}, Point{0, 1}}, nil, nil},
+	Piece{2, 3, Point{3, 2}, []Point{Point{1, 0}, Point{1, 0}, Point{-2, 1}, Point{1, 0}, Point{1, 0}}, nil, nil},
+	Piece{3, 3, Point{2, 3}, []Point{Point{0, 0}, Point{0, 1}, Point{1, 0}, Point{-1, 1}, Point{1, 0}}, nil, nil},
+
+	Piece{0, 4, Point{3, 2}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{-1, 1}, Point{1, 0}}, nil, nil},
+	Piece{1, 4, Point{2, 3}, []Point{Point{1, 0}, Point{-1, 1}, Point{1, 0}, Point{-1, 1}, Point{1, 0}}, nil, nil},
+	Piece{2, 4, Point{3, 2}, []Point{Point{0, 0}, Point{1, 0}, Point{-1, 1}, Point{1, 0}, Point{1, 0}}, nil, nil},
+	Piece{3, 4, Point{2, 3}, []Point{Point{0, 0}, Point{1, 0}, Point{-1, 1}, Point{1, 0}, Point{-1, 1}}, nil, nil},
+
+	Piece{0, 7, Point{3, 2}, []Point{Point{0, 0}, Point{2, 0}, Point{-2, 1}, Point{1, 0}, Point{1, 0}}, nil, nil},
+	Piece{1, 7, Point{2, 3}, []Point{Point{0, 0}, Point{1, 0}, Point{-1, 1}, Point{0, 1}, Point{1, 0}}, nil, nil},
+	Piece{2, 7, Point{3, 2}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{-2, 1}, Point{2, 0}}, nil, nil},
+	Piece{3, 7, Point{2, 3}, []Point{Point{0, 0}, Point{1, 0}, Point{0, 1}, Point{-1, 1}, Point{1, 0}}, nil, nil},
+
+	Piece{0, 5, Point{3, 3}, []Point{Point{0, 0}, Point{1, 0}, Point{0, 1}, Point{1, 0}, Point{-1, 1}}, nil, nil},
+	Piece{1, 5, Point{3, 3}, []Point{Point{2, 0}, Point{-2, 1}, Point{1, 0}, Point{1, 0}, Point{-1, 1}}, nil, nil},
+	Piece{2, 5, Point{3, 3}, []Point{Point{1, 0}, Point{-1, 1}, Point{1, 0}, Point{0, 1}, Point{1, 0}}, nil, nil},
+	Piece{3, 5, Point{3, 3}, []Point{Point{1, 0}, Point{-1, 1}, Point{1, 0}, Point{1, 0}, Point{-2, 1}}, nil, nil},
+
+	Piece{0, 6, Point{3, 3}, []Point{Point{1, 0}, Point{1, 0}, Point{-2, 1}, Point{1, 0}, Point{0, 1}}, nil, nil},
+	Piece{1, 6, Point{3, 3}, []Point{Point{1, 0}, Point{-1, 1}, Point{1, 0}, Point{1, 0}, Point{0, 1}}, nil, nil},
+	Piece{2, 6, Point{3, 3}, []Point{Point{1, 0}, Point{0, 1}, Point{1, 0}, Point{-2, 1}, Point{1, 0}}, nil, nil},
+	Piece{3, 6, Point{3, 3}, []Point{Point{0, 0}, Point{0, 1}, Point{1, 0}, Point{1, 0}, Point{-1, 1}}, nil, nil},
+
+	Piece{0, 0, Point{4, 2}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{1, 0}, Point{-2, 1}}, nil, nil},
+	Piece{1, 0, Point{2, 4}, []Point{Point{1, 0}, Point{-1, 1}, Point{1, 0}, Point{0, 1}, Point{0, 1}}, nil, nil},
+	Piece{2, 0, Point{4, 2}, []Point{Point{2, 0}, Point{-2, 1}, Point{1, 0}, Point{1, 0}, Point{1, 0}}, nil, nil},
+	Piece{3, 0, Point{2, 4}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{1, 0}, Point{-1, 1}}, nil, nil},
+
+	Piece{0, 2, Point{4, 2}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{1, 0}, Point{-1, 1}}, nil, nil},
+	Piece{1, 2, Point{2, 4}, []Point{Point{1, 0}, Point{0, 1}, Point{-1, 1}, Point{1, 0}, Point{0, 1}}, nil, nil},
+	Piece{2, 2, Point{4, 2}, []Point{Point{1, 0}, Point{-1, 1}, Point{1, 0}, Point{1, 0}, Point{1, 0}}, nil, nil},
+	Piece{3, 2, Point{2, 4}, []Point{Point{0, 0}, Point{0, 1}, Point{1, 0}, Point{-1, 1}, Point{0, 1}}, nil, nil},
+
+	Piece{0, 1, Point{3, 3}, []Point{Point{0, 0}, Point{1, 0}, Point{0, 1}, Point{1, 0}, Point{0, 1}}, nil, nil},
+	Piece{1, 1, Point{3, 3}, []Point{Point{2, 0}, Point{-1, 1}, Point{1, 0}, Point{-2, 1}, Point{1, 0}}, nil, nil},
+	Piece{2, 1, Point{3, 3}, []Point{Point{0, 0}, Point{0, 1}, Point{1, 0}, Point{0, 1}, Point{1, 0}}, nil, nil},
+	Piece{3, 1, Point{3, 3}, []Point{Point{1, 0}, Point{1, 0}, Point{-2, 1}, Point{1, 0}, Point{-1, 1}}, nil, nil},
+
+	Piece{0, 3, Point{3, 3}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{-1, 1}, Point{0, 1}}, nil, nil},
+	Piece{1, 3, Point{3, 3}, []Point{Point{2, 0}, Point{-2, 1}, Point{1, 0}, Point{1, 0}, Point{0, 1}}, nil, nil},
+	Piece{2, 3, Point{3, 3}, []Point{Point{1, 0}, Point{0, 1}, Point{-1, 1}, Point{1, 0}, Point{1, 0}}, nil, nil},
+	Piece{3, 3, Point{3, 3}, []Point{Point{0, 0}, Point{0, 1}, Point{1, 0}, Point{1, 0}, Point{-2, 1}}, nil, nil},
+
+	Piece{0, 4, Point{3, 3}, []Point{Point{1, 0}, Point{-1, 1}, Point{1, 0}, Point{1, 0}, Point{-1, 1}}, nil, nil},
+	Piece{1, 4, Point{3, 3}, []Point{Point{1, 0}, Point{-1, 1}, Point{1, 0}, Point{1, 0}, Point{-1, 1}}, nil, nil},
+	Piece{2, 4, Point{3, 3}, []Point{Point{1, 0}, Point{-1, 1}, Point{1, 0}, Point{1, 0}, Point{-1, 1}}, nil, nil},
+	Piece{3, 4, Point{3, 3}, []Point{Point{1, 0}, Point{-1, 1}, Point{1, 0}, Point{1, 0}, Point{-1, 1}}, nil, nil},
+
+	Piece{0, 8, Point{4, 2}, []Point{Point{0, 0}, Point{1, 0}, Point{0, 1}, Point{1, 0}, Point{1, 0}}, nil, nil},
+	Piece{1, 8, Point{2, 4}, []Point{Point{1, 0}, Point{-1, 1}, Point{1, 0}, Point{-1, 1}, Point{0, 1}}, nil, nil},
+	Piece{2, 8, Point{4, 2}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{0, 1}, Point{1, 0}}, nil, nil},
+	Piece{3, 8, Point{2, 4}, []Point{Point{1, 0}, Point{0, 1}, Point{-1, 1}, Point{1, 0}, Point{-1, 1}}, nil, nil},
+
+	Piece{0, 9, Point{4, 2}, []Point{Point{2, 0}, Point{1, 0}, Point{-3, 1}, Point{1, 0}, Point{1, 0}}, nil, nil},
+	Piece{1, 9, Point{2, 4}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{1, 0}, Point{0, 1}}, nil, nil},
+	Piece{2, 9, Point{4, 2}, []Point{Point{1, 0}, Point{1, 0}, Point{1, 0}, Point{-3, 1}, Point{1, 0}}, nil, nil},
+	Piece{3, 9, Point{2, 4}, []Point{Point{0, 0}, Point{0, 1}, Point{1, 0}, Point{0, 1}, Point{0, 1}}, nil, nil},
+
+	Piece{0, 5, Point{3, 3}, []Point{Point{0, 0}, Point{0, 1}, Point{1, 0}, Point{1, 0}, Point{0, 1}}, nil, nil},
+	Piece{1, 5, Point{3, 3}, []Point{Point{1, 0}, Point{1, 0}, Point{-1, 1}, Point{-1, 1}, Point{1, 0}}, nil, nil},
+	Piece{2, 5, Point{3, 3}, []Point{Point{0, 0}, Point{0, 1}, Point{1, 0}, Point{1, 0}, Point{0, 1}}, nil, nil},
+	Piece{3, 5, Point{3, 3}, []Point{Point{1, 0}, Point{1, 0}, Point{-1, 1}, Point{-1, 1}, Point{1, 0}}, nil, nil},
+
+	Piece{0, 6, Point{3, 3}, []Point{Point{2, 0}, Point{-2, 1}, Point{1, 0}, Point{1, 0}, Point{-2, 1}}, nil, nil},
+	Piece{1, 6, Point{3, 3}, []Point{Point{0, 0}, Point{1, 0}, Point{0, 1}, Point{0, 1}, Point{1, 0}}, nil, nil},
+	Piece{2, 6, Point{3, 3}, []Point{Point{2, 0}, Point{-2, 1}, Point{1, 0}, Point{1, 0}, Point{-2, 1}}, nil, nil},
+	Piece{3, 6, Point{3, 3}, []Point{Point{0, 0}, Point{1, 0}, Point{0, 1}, Point{0, 1}, Point{1, 0}}, nil, nil},
+}
diff --git a/src/pkg/exp/4s/xs.go b/src/pkg/exp/4s/xs.go
index ef69e10c95..3b7c1a4b39 100644
--- a/src/pkg/exp/4s/xs.go
+++ b/src/pkg/exp/4s/xs.go
@@ -50,36 +50,36 @@ const (
 )
 
 var (
-	N	int;
-	display	draw.Context;
-	screen	draw.Image;
-	screenr	draw.Rectangle;
-	board	[NY][NX]byte;
-	rboard	draw.Rectangle;
-	pscore	draw.Point;
-	scoresz	draw.Point;
-	pcsz = 32;
-	pos	draw.Point;
-	bbr, bb2r	draw.Rectangle;
-	bb, bbmask, bb2, bb2mask *image.RGBA;
-	whitemask image.Image;
-	br, br2	draw.Rectangle;
-	points	int;
-	dt	int;
-	DY	int;
-	DMOUSE	int;
-	lastmx	int;
-	mouse	draw.Mouse;
-	newscreen	bool;
-	timerc	<-chan int64;
-	suspc	chan bool;
-	mousec	chan draw.Mouse;
-	resizec	<-chan bool;
-	kbdc	chan int;
-	suspended	bool;
-	tsleep	int;
-	piece	*Piece;
-	pieces	[]Piece;
+	N				int;
+	display				draw.Context;
+	screen				draw.Image;
+	screenr				draw.Rectangle;
+	board				[NY][NX]byte;
+	rboard				draw.Rectangle;
+	pscore				draw.Point;
+	scoresz				draw.Point;
+	pcsz				= 32;
+	pos				draw.Point;
+	bbr, bb2r			draw.Rectangle;
+	bb, bbmask, bb2, bb2mask	*image.RGBA;
+	whitemask			image.Image;
+	br, br2				draw.Rectangle;
+	points				int;
+	dt				int;
+	DY				int;
+	DMOUSE				int;
+	lastmx				int;
+	mouse				draw.Mouse;
+	newscreen			bool;
+	timerc				<-chan int64;
+	suspc				chan bool;
+	mousec				chan draw.Mouse;
+	resizec				<-chan bool;
+	kbdc				chan int;
+	suspended			bool;
+	tsleep				int;
+	piece				*Piece;
+	pieces				[]Piece;
 )
 
 type Piece struct {
@@ -92,56 +92,66 @@ type Piece struct {
 }
 
 var txbits = [NCOL][32]byte{
-	[32]byte{0xDD,0xDD,0xFF,0xFF,0x77,0x77,0xFF,0xFF,
-	 0xDD,0xDD,0xFF,0xFF,0x77,0x77,0xFF,0xFF,
-	 0xDD,0xDD,0xFF,0xFF,0x77,0x77,0xFF,0xFF,
-	 0xDD,0xDD,0xFF,0xFF,0x77,0x77,0xFF,0xFF},
-	[32]byte{0xDD,0xDD,0x77,0x77,0xDD,0xDD,0x77,0x77,
-	 0xDD,0xDD,0x77,0x77,0xDD,0xDD,0x77,0x77,
-	 0xDD,0xDD,0x77,0x77,0xDD,0xDD,0x77,0x77,
-	 0xDD,0xDD,0x77,0x77,0xDD,0xDD,0x77,0x77},
-	[32]byte{0xAA,0xAA,0x55,0x55,0xAA,0xAA,0x55,0x55,
-	 0xAA,0xAA,0x55,0x55,0xAA,0xAA,0x55,0x55,
-	 0xAA,0xAA,0x55,0x55,0xAA,0xAA,0x55,0x55,
-	 0xAA,0xAA,0x55,0x55,0xAA,0xAA,0x55,0x55},
-	[32]byte{0xAA,0xAA,0x55,0x55,0xAA,0xAA,0x55,0x55,
-	 0xAA,0xAA,0x55,0x55,0xAA,0xAA,0x55,0x55,
-	 0xAA,0xAA,0x55,0x55,0xAA,0xAA,0x55,0x55,
-	 0xAA,0xAA,0x55,0x55,0xAA,0xAA,0x55,0x55},
-	[32]byte{0x22,0x22,0x88,0x88,0x22,0x22,0x88,0x88,
-	 0x22,0x22,0x88,0x88,0x22,0x22,0x88,0x88,
-	 0x22,0x22,0x88,0x88,0x22,0x22,0x88,0x88,
-	 0x22,0x22,0x88,0x88,0x22,0x22,0x88,0x88},
-	[32]byte{0x22,0x22,0x00,0x00,0x88,0x88,0x00,0x00,
-	 0x22,0x22,0x00,0x00,0x88,0x88,0x00,0x00,
-	 0x22,0x22,0x00,0x00,0x88,0x88,0x00,0x00,
-	 0x22,0x22,0x00,0x00,0x88,0x88,0x00,0x00},
-	[32]byte{0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
-	 0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
-	 0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
-	 0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00},
-	[32]byte{0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
-	 0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
-	 0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
-	 0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00},
-	[32]byte{0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
-	 0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
-	 0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
-	 0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC},
-	[32]byte{0xCC,0xCC,0xCC,0xCC,0x33,0x33,0x33,0x33,
-	 0xCC,0xCC,0xCC,0xCC,0x33,0x33,0x33,0x33,
-	 0xCC,0xCC,0xCC,0xCC,0x33,0x33,0x33,0x33,
-	 0xCC,0xCC,0xCC,0xCC,0x33,0x33,0x33,0x33},
+	[32]byte{0xDD, 0xDD, 0xFF, 0xFF, 0x77, 0x77, 0xFF, 0xFF,
+		0xDD, 0xDD, 0xFF, 0xFF, 0x77, 0x77, 0xFF, 0xFF,
+		0xDD, 0xDD, 0xFF, 0xFF, 0x77, 0x77, 0xFF, 0xFF,
+		0xDD, 0xDD, 0xFF, 0xFF, 0x77, 0x77, 0xFF, 0xFF,
+	},
+	[32]byte{0xDD, 0xDD, 0x77, 0x77, 0xDD, 0xDD, 0x77, 0x77,
+		0xDD, 0xDD, 0x77, 0x77, 0xDD, 0xDD, 0x77, 0x77,
+		0xDD, 0xDD, 0x77, 0x77, 0xDD, 0xDD, 0x77, 0x77,
+		0xDD, 0xDD, 0x77, 0x77, 0xDD, 0xDD, 0x77, 0x77,
+	},
+	[32]byte{0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55,
+		0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55,
+		0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55,
+		0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55,
+	},
+	[32]byte{0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55,
+		0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55,
+		0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55,
+		0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55,
+	},
+	[32]byte{0x22, 0x22, 0x88, 0x88, 0x22, 0x22, 0x88, 0x88,
+		0x22, 0x22, 0x88, 0x88, 0x22, 0x22, 0x88, 0x88,
+		0x22, 0x22, 0x88, 0x88, 0x22, 0x22, 0x88, 0x88,
+		0x22, 0x22, 0x88, 0x88, 0x22, 0x22, 0x88, 0x88,
+	},
+	[32]byte{0x22, 0x22, 0x00, 0x00, 0x88, 0x88, 0x00, 0x00,
+		0x22, 0x22, 0x00, 0x00, 0x88, 0x88, 0x00, 0x00,
+		0x22, 0x22, 0x00, 0x00, 0x88, 0x88, 0x00, 0x00,
+		0x22, 0x22, 0x00, 0x00, 0x88, 0x88, 0x00, 0x00,
+	},
+	[32]byte{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+		0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+		0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+		0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+	},
+	[32]byte{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+		0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+		0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+		0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+	},
+	[32]byte{0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
+		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
+		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
+		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
+	},
+	[32]byte{0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x33, 0x33, 0x33,
+		0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x33, 0x33, 0x33,
+		0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x33, 0x33, 0x33,
+		0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x33, 0x33, 0x33,
+	},
 }
 
 var txpix = [NCOL]draw.Color{
-	draw.Yellow,	/* yellow */
-	draw.Cyan,	/* cyan */
-	draw.Green,	/* lime green */
-	draw.GreyBlue,	/* slate */
-	draw.Red,	/* red */
-	draw.GreyGreen,	/* olive green */
-	draw.Blue,	/* blue */
+	draw.Yellow,		/* yellow */
+	draw.Cyan,		/* cyan */
+	draw.Green,		/* lime green */
+	draw.GreyBlue,		/* slate */
+	draw.Red,		/* red */
+	draw.GreyGreen,		/* olive green */
+	draw.Blue,		/* blue */
 	draw.Color(0xFF55AAFF),	/* pink */
 	draw.Color(0xFFAAFFFF),	/* lavender */
 	draw.Color(0xBB005DFF),	/* maroon */
@@ -155,7 +165,7 @@ func movemouse() int {
 
 func warp(p draw.Point, x int) int {
 	if !suspended && piece != nil {
-		x = pos.X + piece.sz.X*pcsz/2;
+		x = pos.X + piece.sz.X * pcsz / 2;
 		if p.Y < rboard.Min.Y {
 			p.Y = rboard.Min.Y;
 		}
@@ -184,12 +194,12 @@ func initPieces() {
 }
 
 func collide(pt draw.Point, p *Piece) bool {
-	pt.X = (pt.X - rboard.Min.X) / pcsz;
-	pt.Y = (pt.Y - rboard.Min.Y) / pcsz;
+	pt.X = (pt.X - rboard.Min.X)/pcsz;
+	pt.Y = (pt.Y - rboard.Min.Y)/pcsz;
 	for _, q := range p.d {
 		pt.X += q.X;
 		pt.Y += q.Y;
-		if pt.X<0 || pt.X>=NX || pt.Y<0 || pt.Y>=NY {
+		if pt.X < 0 || pt.X >= NX || pt.Y < 0 || pt.Y >= NY {
 			return true;
 			continue;
 		}
@@ -201,8 +211,8 @@ func collide(pt draw.Point, p *Piece) bool {
 }
 
 func collider(pt, pmax draw.Point) bool {
-	pi := (pt.X - rboard.Min.X) / pcsz;
-	pj := (pt.Y - rboard.Min.Y) / pcsz;
+	pi := (pt.X - rboard.Min.X)/pcsz;
+	pj := (pt.Y - rboard.Min.Y)/pcsz;
 	n := pmax.X / pcsz;
 	m := pmax.Y / pcsz + 1;
 	for i := pi; i < pi+n && i < NX; i++ {
@@ -228,8 +238,8 @@ func setpiece(p *Piece) {
 	var r draw.Rectangle;
 	r.Min = bbr.Min;
 	for i, pt := range p.d {
-		r.Min.X += pt.X*pcsz;
-		r.Min.Y += pt.Y*pcsz;
+		r.Min.X += pt.X * pcsz;
+		r.Min.Y += pt.Y * pcsz;
 		r.Max.X = r.Min.X + pcsz;
 		r.Max.Y = r.Min.Y + pcsz;
 		if i == 0 {
@@ -237,7 +247,7 @@ func setpiece(p *Piece) {
 			draw.Draw(bb, r.Inset(1), txpix[piece.tx], nil, draw.ZP);
 			draw.Draw(bbmask, r, draw.Opaque, nil, draw.ZP);
 			op = r.Min;
-		}else{
+		} else {
 			draw.Draw(bb, r, bb, nil, op);
 			draw.Draw(bbmask, r, bbmask, nil, op);
 		}
@@ -249,7 +259,7 @@ func setpiece(p *Piece) {
 		}
 	}
 	br.Max = br.Max.Sub(bbr.Min);
-	delta := draw.Pt(0,DY);
+	delta := draw.Pt(0, DY);
 	br2.Max = br.Max.Add(delta);
 	r = br.Add(bb2r.Min);
 	r2 := br2.Add(bb2r.Min);
@@ -280,26 +290,26 @@ func rest() {
 	for _, p := range piece.d {
 		pt.X += p.X;
 		pt.Y += p.Y;
-		board[pt.Y][pt.X] = byte(piece.tx+16);
+		board[pt.Y][pt.X] = byte(piece.tx + 16);
 	}
 }
 
 func canfit(p *Piece) bool {
 	var dx = [...]int{0, -1, 1, -2, 2, -3, 3, 4, -4};
-	j := N + 1;
+	j := N+1;
 	if j >= 4 {
 		j = p.sz.X;
-		if j<p.sz.Y {
+		if j < p.sz.Y {
 			j = p.sz.Y;
 		}
-		j = 2*j-1;
+		j = 2*j - 1;
 	}
-	for i:=0; i<j; i++ {
+	for i := 0; i < j; i++ {
 		var z draw.Point;
 		z.X = pos.X + dx[i]*pcsz;
 		z.Y = pos.Y;
 		if !collide(z, p) {
-			z.Y = pos.Y + pcsz-1;
+			z.Y = pos.Y + pcsz - 1;
 			if !collide(z, p) {
 				undrawpiece();
 				pos.X = z.X;
@@ -312,28 +322,28 @@ func canfit(p *Piece) bool {
 
 func score(p int) {
 	points += p;
-//	snprint(buf, sizeof(buf), "%.6ld", points);
-//	draw.Draw(screen, draw.Rpt(pscore, pscore.Add(scoresz)), draw.White, nil, draw.ZP);
-//	string(screen, pscore, draw.Black, draw.ZP, font, buf);
+	//	snprint(buf, sizeof(buf), "%.6ld", points);
+	//	draw.Draw(screen, draw.Rpt(pscore, pscore.Add(scoresz)), draw.White, nil, draw.ZP);
+	//	string(screen, pscore, draw.Black, draw.ZP, font, buf);
 }
 
 func drawsq(b draw.Image, p draw.Point, ptx int) {
 	var r draw.Rectangle;
 	r.Min = p;
-	r.Max.X = r.Min.X+pcsz;
-	r.Max.Y = r.Min.Y+pcsz;
+	r.Max.X = r.Min.X + pcsz;
+	r.Max.Y = r.Min.Y + pcsz;
 	draw.Draw(b, r, draw.Black, nil, draw.ZP);
 	draw.Draw(b, r.Inset(1), txpix[ptx], nil, draw.ZP);
 }
 
 func drawboard() {
 	draw.Border(screen, rboard.Inset(-2), 2, draw.Black, draw.ZP);
-	draw.Draw(screen, draw.Rect(rboard.Min.X, rboard.Min.Y-2, rboard.Max.X, rboard.Min.Y),
+	draw.Draw(screen, draw.Rect(rboard.Min.X, rboard.Min.Y - 2, rboard.Max.X, rboard.Min.Y),
 		draw.White, nil, draw.ZP);
-	for i:=0; i<NY; i++ {
-		for j:=0; j<NX; j++ {
+	for i := 0; i < NY; i++ {
+		for j := 0; j < NX; j++ {
 			if board[i][j] != 0 {
-				drawsq(screen, draw.Pt(rboard.Min.X+j*pcsz, rboard.Min.Y+i*pcsz), int(board[i][j]-16));
+				drawsq(screen, draw.Pt(rboard.Min.X + j*pcsz, rboard.Min.Y + i*pcsz), int(board[i][j]-16));
 			}
 		}
 	}
@@ -348,8 +358,8 @@ func choosepiece() {
 		i := rand.Intn(len(pieces));
 		setpiece(&pieces[i]);
 		pos = rboard.Min;
-		pos.X += rand.Intn(NX)*pcsz;
-		if !collide(draw.Pt(pos.X, pos.Y+pcsz-DY), piece) {
+		pos.X += rand.Intn(NX) * pcsz;
+		if !collide(draw.Pt(pos.X, pos.Y + pcsz - DY), piece) {
 			break;
 		}
 	}
@@ -359,7 +369,7 @@ func choosepiece() {
 
 func movepiece() bool {
 	var mask image.Image;
-	if collide(draw.Pt(pos.X, pos.Y+pcsz), piece) {
+	if collide(draw.Pt(pos.X, pos.Y + pcsz), piece) {
 		return false;
 	}
 	if collider(pos, br2.Max) {
@@ -374,11 +384,11 @@ func movepiece() bool {
 func suspend(s bool) {
 	suspended = s;
 	/*
-	if suspended {
-		setcursor(mousectl, &whitearrow);
-	} else {
-		setcursor(mousectl, nil);
-	}
+		if suspended {
+			setcursor(mousectl, &whitearrow);
+		} else {
+			setcursor(mousectl, nil);
+		}
 	*/
 	if !suspended {
 		drawpiece();
@@ -417,8 +427,8 @@ func pause(t int) {
 func horiz() bool {
 	var lev [MAXN]int;
 	h := 0;
-	for i:=0; i<NY; i++ {
-		for j:=0; board[i][j] != 0; j++ {
+	for i := 0; i < NY; i++ {
+		for j := 0; board[i][j] != 0; j++ {
 			if j == NX-1 {
 				lev[h] = i;
 				h++;
@@ -431,20 +441,20 @@ func horiz() bool {
 	}
 	r := rboard;
 	newscreen = false;
-	for j:=0; j<h; j++ {
+	for j := 0; j < h; j++ {
 		r.Min.Y = rboard.Min.Y + lev[j]*pcsz;
 		r.Max.Y = r.Min.Y + pcsz;
 		draw.Draw(screen, r, draw.White, whitemask, draw.ZP);
 		display.FlushImage();
 	}
 	PlaySound(whoosh);
-	for i:=0; i<3; i++ {
+	for i := 0; i < 3; i++ {
 		pause(250);
 		if newscreen {
 			drawboard();
 			break;
 		}
-		for j:=0; j<h; j++ {
+		for j := 0; j < h; j++ {
 			r.Min.Y = rboard.Min.Y + lev[j]*pcsz;
 			r.Max.Y = r.Min.Y + pcsz;
 			draw.Draw(screen, r, draw.White, whitemask, draw.ZP);
@@ -452,13 +462,13 @@ func horiz() bool {
 		display.FlushImage();
 	}
 	r = rboard;
-	for j:=0; j<h; j++ {
-		i := NY - lev[j] - 1;
-		score(250+10*i*i);
+	for j := 0; j < h; j++ {
+		i := NY-lev[j]-1;
+		score(250 + 10*i*i);
 		r.Min.Y = rboard.Min.Y;
-		r.Max.Y = rboard.Min.Y+lev[j]*pcsz;
-		draw.Draw(screen, r.Add(draw.Pt(0,pcsz)), screen, nil, r.Min);
-		r.Max.Y = rboard.Min.Y+pcsz;
+		r.Max.Y = rboard.Min.Y + lev[j]*pcsz;
+		draw.Draw(screen, r.Add(draw.Pt(0, pcsz)), screen, nil, r.Min);
+		r.Max.Y = rboard.Min.Y + pcsz;
 		draw.Draw(screen, r, draw.White, nil, draw.ZP);
 		for k := lev[j]-1; k >= 0; k-- {
 			board[k+1] = board[k];
@@ -470,8 +480,8 @@ func horiz() bool {
 }
 
 func mright() {
-	if !collide(draw.Pt(pos.X+pcsz, pos.Y), piece)
-	&& !collide(draw.Pt(pos.X+pcsz, pos.Y+pcsz-DY), piece) {
+	if !collide(draw.Pt(pos.X + pcsz, pos.Y), piece) &&
+		!collide(draw.Pt(pos.X + pcsz, pos.Y + pcsz - DY), piece) {
 		undrawpiece();
 		pos.X += pcsz;
 		drawpiece();
@@ -480,8 +490,8 @@ func mright() {
 }
 
 func mleft() {
-	if !collide(draw.Pt(pos.X-pcsz, pos.Y), piece)
-	&& !collide(draw.Pt(pos.X-pcsz, pos.Y+pcsz-DY), piece) {
+	if !collide(draw.Pt(pos.X - pcsz, pos.Y), piece) &&
+		!collide(draw.Pt(pos.X - pcsz, pos.Y + pcsz - DY), piece) {
 		undrawpiece();
 		pos.X -= pcsz;
 		drawpiece();
@@ -509,13 +519,13 @@ var fusst = 0
 
 func drop(f bool) bool {
 	if f {
-		score(5*(rboard.Max.Y-pos.Y)/pcsz);
+		score(5*(rboard.Max.Y - pos.Y)/pcsz);
 		for movepiece() {
 		}
 	}
 	fusst = 0;
 	rest();
-	if pos.Y==rboard.Min.Y && !horiz() {
+	if pos.Y == rboard.Min.Y && !horiz() {
 		return true;
 	}
 	horiz();
@@ -536,7 +546,7 @@ func play() {
 	for {
 		select {
 		case mouse = <-mousec:
-			if suspended  {
+			if suspended {
 				om = mouse;
 				break;
 			}
@@ -551,15 +561,15 @@ func play() {
 				mleft();
 				lastmx = mouse.X;
 			}
-			if mouse.Buttons&^om.Buttons&1 == 1 {
+			if mouse.Buttons &^ om.Buttons & 1 == 1 {
 				rleft();
 			}
-			if mouse.Buttons&^om.Buttons&2 == 2 {
+			if mouse.Buttons &^ om.Buttons & 2 == 2 {
 				if drop(true) {
 					return;
 				}
 			}
-			if mouse.Buttons&^om.Buttons&4 == 4 {
+			if mouse.Buttons &^ om.Buttons & 4 == 4 {
 				rright();
 			}
 			om = mouse;
@@ -579,7 +589,7 @@ func play() {
 			if suspended {
 				break;
 			}
-			switch(r){
+			switch r {
 			case 'f', ';':
 				mright();
 			case 'a', 'j':
@@ -601,7 +611,7 @@ func play() {
 			dt -= tsleep;
 			if dt < 0 {
 				i := 1;
-				dt = 16 * (points+rand.Intn(10000)-5000) / 10000;
+				dt = 16*(points + rand.Intn(10000) - 5000)/10000;
 				if dt >= 32 {
 					i += (dt-32)/16;
 					dt = 32;
@@ -656,17 +666,17 @@ func suspproc() {
 }
 
 func redraw(new bool) {
-//	if new && getwindow(display, Refmesg) < 0 {
-//		sysfatal("can't reattach to window");
-//	}
+	//	if new && getwindow(display, Refmesg) < 0 {
+	//		sysfatal("can't reattach to window");
+	//	}
 	r := draw.Rect(0, 0, screen.Width(), screen.Height());
-	pos.X = (pos.X - rboard.Min.X) / pcsz;
-	pos.Y = (pos.Y - rboard.Min.Y) / pcsz;
+	pos.X = (pos.X - rboard.Min.X)/pcsz;
+	pos.Y = (pos.Y - rboard.Min.Y)/pcsz;
 	dx := r.Max.X - r.Min.X;
 	dy := r.Max.Y - r.Min.Y - 2*32;
-	DY = dx / NX;
-	if DY > dy / NY {
-		DY = dy / NY;
+	DY = dx/NX;
+	if DY > dy/NY {
+		DY = dy/NY;
 	}
 	DY /= 8;
 	if DY > 4 {
@@ -678,19 +688,19 @@ func redraw(new bool) {
 		log.Exitf("screen too small: %d", pcsz);
 	}
 	rboard = screenr;
-	rboard.Min.X += (dx-pcsz*NX)/2;
-	rboard.Min.Y += (dy-pcsz*NY)/2+32;
-	rboard.Max.X = rboard.Min.X+NX*pcsz;
-	rboard.Max.Y = rboard.Min.Y+NY*pcsz;
-	pscore.X = rboard.Min.X+8;
-	pscore.Y = rboard.Min.Y-32;
-//	scoresz = stringsize(font, "000000");
-	pos.X = pos.X*pcsz + rboard.Min.X;
-	pos.Y = pos.Y*pcsz + rboard.Min.Y;
+	rboard.Min.X += (dx - pcsz*NX)/2;
+	rboard.Min.Y += (dy - pcsz*NY)/2 + 32;
+	rboard.Max.X = rboard.Min.X + NX*pcsz;
+	rboard.Max.Y = rboard.Min.Y + NY*pcsz;
+	pscore.X = rboard.Min.X + 8;
+	pscore.Y = rboard.Min.Y - 32;
+	//	scoresz = stringsize(font, "000000");
+	pos.X = pos.X * pcsz + rboard.Min.X;
+	pos.Y = pos.Y * pcsz + rboard.Min.Y;
 	bbr = draw.Rect(0, 0, N*pcsz, N*pcsz);
 	bb = image.NewRGBA(bbr.Max.X, bbr.Max.Y);
 	bbmask = image.NewRGBA(bbr.Max.X, bbr.Max.Y);	// actually just a bitmap
-	bb2r = draw.Rect(0, 0, N*pcsz, N*pcsz+DY);
+	bb2r = draw.Rect(0, 0, N*pcsz, N*pcsz + DY);
 	bb2 = image.NewRGBA(bb2r.Dx(), bb2r.Dy());
 	bb2mask = image.NewRGBA(bb2r.Dx(), bb2r.Dy());	// actually just a bitmap
 	draw.Draw(screen, screenr, draw.White, nil, draw.ZP);
@@ -716,10 +726,10 @@ func Play(pp []Piece, ctxt draw.Context) {
 	pieces = pp;
 	N = len(pieces[0].d);
 	initPieces();
-	rand.Seed(int32(time.Nanoseconds()%(1e9-1)));
+	rand.Seed(int32(time.Nanoseconds() % (1e9-1)));
 	whitemask = draw.White.SetAlpha(0x7F);
 	tsleep = 50;
-	timerc = time.Tick(int64(tsleep/2) * 1e6);
+	timerc = time.Tick(int64(tsleep/2)*1e6);
 	suspc = make(chan bool);
 	mousec = make(chan draw.Mouse);
 	resizec = ctxt.ResizeChan();
diff --git a/src/pkg/exp/iterable/iterable.go b/src/pkg/exp/iterable/iterable.go
index bdcce11d0a..8ea0becb89 100644
--- a/src/pkg/exp/iterable/iterable.go
+++ b/src/pkg/exp/iterable/iterable.go
@@ -12,77 +12,77 @@ import "container/vector"
 
 type Iterable interface {
 	// Iter should return a fresh channel each time it is called.
-	Iter() <-chan interface {}
+	Iter() <-chan interface{};
 }
 
-func not(f func(interface {}) bool) (func(interface {}) bool) {
-	return func(e interface {}) bool { return !f(e) }
+func not(f func(interface{}) bool) (func(interface{}) bool) {
+	return func(e interface{}) bool { return !f(e) };
 }
 
 // All tests whether f is true for every element of iter.
-func All(iter Iterable, f func(interface {}) bool) bool {
+func All(iter Iterable, f func(interface{}) bool) bool {
 	for e := range iter.Iter() {
 		if !f(e) {
-			return false
+			return false;
 		}
 	}
-	return true
+	return true;
 }
 
 // Any tests whether f is true for at least one element of iter.
-func Any(iter Iterable, f func(interface {}) bool) bool {
-	return !All(iter, not(f))
+func Any(iter Iterable, f func(interface{}) bool) bool {
+	return !All(iter, not(f));
 }
 
 // Data returns a slice containing the elements of iter.
-func Data(iter Iterable) []interface {} {
+func Data(iter Iterable) []interface{} {
 	vec := vector.New(0);
 	for e := range iter.Iter() {
-		vec.Push(e)
+		vec.Push(e);
 	}
-	return vec.Data()
+	return vec.Data();
 }
 
 // filteredIterable is a struct that implements Iterable with each element
 // passed through a filter.
 type filteredIterable struct {
-	it Iterable;
-	f func(interface {}) bool;
+	it	Iterable;
+	f	func(interface{}) bool;
 }
 
-func (f *filteredIterable) iterate(out chan<- interface {}) {
+func (f *filteredIterable) iterate(out chan<- interface{}) {
 	for e := range f.it.Iter() {
 		if f.f(e) {
-			out <- e
+			out <- e;
 		}
 	}
-	close(out)
+	close(out);
 }
 
-func (f *filteredIterable) Iter() <-chan interface {} {
-	ch := make(chan interface {});
+func (f *filteredIterable) Iter() <-chan interface{} {
+	ch := make(chan interface{});
 	go f.iterate(ch);
 	return ch;
 }
 
 // Filter returns an Iterable that returns the elements of iter that satisfy f.
-func Filter(iter Iterable, f func(interface {}) bool) Iterable {
-	return &filteredIterable{ iter, f }
+func Filter(iter Iterable, f func(interface{}) bool) Iterable {
+	return &filteredIterable{iter, f};
 }
 
 // Find returns the first element of iter that satisfies f.
 // Returns nil if no such element is found.
-func Find(iter Iterable, f func(interface {}) bool) interface {} {
+func Find(iter Iterable, f func(interface{}) bool) interface{} {
 	for e := range Filter(iter, f).Iter() {
-		return e
+		return e;
 	}
-	return nil
+	return nil;
 }
 
 // Injector is a type representing a function that takes two arguments,
 // an accumulated value and an element, and returns the next accumulated value.
 // See the Inject function.
-type Injector func(interface {}, interface {}) interface{};
+type Injector func(interface{}, interface{}) interface{}
 
 // Inject combines the elements of iter by repeatedly calling f with an
 // accumulated value and each element in order. The starting accumulated value
@@ -92,42 +92,42 @@ type Injector func(interface {}, interface {}) interface{};
 //   sum := iterable.Inject(arr, 0,
 //                          func(ax interface {}, x interface {}) interface {} {
 //                            return ax.(int) + x.(int) }).(int)
-func Inject(iter Iterable, initial interface {}, f Injector) interface {} {
+func Inject(iter Iterable, initial interface{}, f Injector) interface{} {
 	acc := initial;
 	for e := range iter.Iter() {
-		acc = f(acc, e)
+		acc = f(acc, e);
 	}
-	return acc
+	return acc;
 }
 
 // mappedIterable is a helper struct that implements Iterable, returned by Map.
 type mappedIterable struct {
-	it Iterable;
-	f func(interface {}) interface {};
+	it	Iterable;
+	f	func(interface{}) interface{};
 }
 
-func (m *mappedIterable) iterate(out chan<- interface {}) {
+func (m *mappedIterable) iterate(out chan<- interface{}) {
 	for e := range m.it.Iter() {
-		out <- m.f(e)
+		out <- m.f(e);
 	}
-	close(out)
+	close(out);
 }
 
-func (m *mappedIterable) Iter() <-chan interface {} {
-	ch := make(chan interface {});
+func (m *mappedIterable) Iter() <-chan interface{} {
+	ch := make(chan interface{});
 	go m.iterate(ch);
-	return ch
+	return ch;
 }
 
 // Map returns an Iterable that returns the result of applying f to each
 // element of iter.
-func Map(iter Iterable, f func(interface {}) interface {}) Iterable {
-	return &mappedIterable{ iter, f }
+func Map(iter Iterable, f func(interface{}) interface{}) Iterable {
+	return &mappedIterable{iter, f};
 }
 
 // Partition(iter, f) returns Filter(iter, f) and Filter(iter, !f).
-func Partition(iter Iterable, f func(interface {}) bool) (Iterable, Iterable)  {
-	return Filter(iter, f), Filter(iter, not(f))
+func Partition(iter Iterable, f func(interface{}) bool) (Iterable, Iterable) {
+	return Filter(iter, f), Filter(iter, not(f));
 }
 
 // TODO:
diff --git a/src/pkg/exp/iterable/iterable_test.go b/src/pkg/exp/iterable/iterable_test.go
index 28bdfb66f7..bc66ff5dde 100644
--- a/src/pkg/exp/iterable/iterable_test.go
+++ b/src/pkg/exp/iterable/iterable_test.go
@@ -8,82 +8,83 @@ import (
 	"testing";
 )
 
-type IntArray []int;
+type IntArray []int
 
-func (arr IntArray) Iter() <-chan interface {} {
-	ch := make(chan interface {});
+func (arr IntArray) Iter() <-chan interface{} {
+	ch := make(chan interface{});
 	go func() {
 		for _, x := range arr {
-			ch <- x
+			ch <- x;
 		}
-		close(ch)
+		close(ch);
 	}();
-	return ch
+	return ch;
 }
 
-var oneToFive = IntArray{ 1, 2, 3, 4, 5 };
+var oneToFive = IntArray{1, 2, 3, 4, 5}
 
-func isNegative(n interface {}) bool {
-	return n.(int) < 0
+func isNegative(n interface{}) bool {
+	return n.(int) < 0;
 }
-func isPositive(n interface {}) bool {
-	return n.(int) > 0
+func isPositive(n interface{}) bool {
+	return n.(int) > 0;
 }
-func isAbove3(n interface {}) bool {
-	return n.(int) > 3
+func isAbove3(n interface{}) bool {
+	return n.(int) > 3;
 }
-func isEven(n interface {}) bool {
-	return n.(int) % 2 == 0
+func isEven(n interface{}) bool {
+	return n.(int) % 2 == 0;
 }
-func doubler(n interface {}) interface {} {
-	return n.(int) * 2
+func doubler(n interface{}) interface{} {
+	return n.(int) * 2;
 }
-func addOne(n interface {}) interface {} {
-	return n.(int) + 1
+func addOne(n interface{}) interface{} {
+	return n.(int) + 1;
 }
-func adder(acc interface {}, n interface {}) interface {} {
-	return acc.(int) + n.(int)
+func adder(acc interface{}, n interface{}) interface{} {
+	return acc.(int) + n.(int);
 }
 
 // A stream of the natural numbers: 0, 1, 2, 3, ...
-type integerStream struct {}
-func (i integerStream) Iter() <-chan interface {} {
-  ch := make(chan interface {});
-  go func() {
-    for i := 0; ; i++ {
-      ch <- i
-    }
-  }();
-  return ch
+type integerStream struct{}
+
+func (i integerStream) Iter() <-chan interface{} {
+	ch := make(chan interface{});
+	go func() {
+		for i := 0; ; i++ {
+			ch <- i;
+		}
+	}();
+	return ch;
 }
 
 func TestAll(t *testing.T) {
 	if !All(oneToFive, isPositive) {
-		t.Error("All(oneToFive, isPositive) == false")
+		t.Error("All(oneToFive, isPositive) == false");
 	}
 	if All(oneToFive, isAbove3) {
-		t.Error("All(oneToFive, isAbove3) == true")
+		t.Error("All(oneToFive, isAbove3) == true");
 	}
 }
 
 func TestAny(t *testing.T) {
 	if Any(oneToFive, isNegative) {
-		t.Error("Any(oneToFive, isNegative) == true")
+		t.Error("Any(oneToFive, isNegative) == true");
 	}
 	if !Any(oneToFive, isEven) {
-		t.Error("Any(oneToFive, isEven) == false")
+		t.Error("Any(oneToFive, isEven) == false");
 	}
 }
 
-func assertArraysAreEqual(t *testing.T, res []interface {}, expected []int) {
+func assertArraysAreEqual(t *testing.T, res []interface{}, expected []int) {
 	if len(res) != len(expected) {
 		t.Errorf("len(res) = %v, want %v", len(res), len(expected));
-		goto missing
+		goto missing;
 	}
 	for i := range res {
 		if v := res[i].(int); v != expected[i] {
 			t.Errorf("res[%v] = %v, want %v", i, v, expected[i]);
-			goto missing
+			goto missing;
 		}
 	}
 	return;
@@ -94,35 +95,35 @@ missing:
 func TestFilter(t *testing.T) {
 	ints := integerStream{};
 	moreInts := Filter(ints, isAbove3).Iter();
-	res := make([]interface {}, 3);
+	res := make([]interface{}, 3);
 	for i := 0; i < 3; i++ {
 		res[i] = <-moreInts;
 	}
-	assertArraysAreEqual(t, res, []int{ 4, 5, 6 })
+	assertArraysAreEqual(t, res, []int{4, 5, 6});
 }
 
 func TestFind(t *testing.T) {
 	ints := integerStream{};
 	first := Find(ints, isAbove3);
 	if first.(int) != 4 {
-		t.Errorf("Find(ints, isAbove3) = %v, want 4", first)
+		t.Errorf("Find(ints, isAbove3) = %v, want 4", first);
 	}
 }
 
 func TestInject(t *testing.T) {
 	res := Inject(oneToFive, 0, adder);
 	if res.(int) != 15 {
-		t.Errorf("Inject(oneToFive, 0, adder) = %v, want 15", res)
+		t.Errorf("Inject(oneToFive, 0, adder) = %v, want 15", res);
 	}
 }
 
 func TestMap(t *testing.T) {
 	res := Data(Map(Map(oneToFive, doubler), addOne));
-	assertArraysAreEqual(t, res, []int{ 3, 5, 7, 9, 11 })
+	assertArraysAreEqual(t, res, []int{3, 5, 7, 9, 11});
 }
 
 func TestPartition(t *testing.T) {
 	ti, fi := Partition(oneToFive, isEven);
-	assertArraysAreEqual(t, Data(ti), []int{ 2, 4 });
-	assertArraysAreEqual(t, Data(fi), []int{ 1, 3, 5 })
+	assertArraysAreEqual(t, Data(ti), []int{2, 4});
+	assertArraysAreEqual(t, Data(fi), []int{1, 3, 5});
 }
