commit 382a19c3dedb1f46a2066510243d30c8ba55eebc
Author: Kai Backman <kaib@golang.org>
Date:   Tue Aug 18 19:20:33 2009 -0700

    pkg/sort compiling and some progress on syscall. mostly
    re-enabling and massaging code.
    
    R=rsc
    APPROVED=rsc
    DELTA=2496  (1880 added, 330 deleted, 286 changed)
    OCL=33487
    CL=33504
---
 src/cmd/5g/cgen.c                     |  33 +-
 src/cmd/5g/gg.h                       |   2 +-
 src/cmd/5g/ggen.c                     | 220 +++++------
 src/cmd/5g/gsubr.c                    | 618 ++++++++---------------------
 src/make-arm.bash                     |   4 +-
 src/pkg/syscall/syscall_linux_arm.go  | 138 +++++++
 src/pkg/syscall/zerrors_linux_arm.go  | 316 +++++++++++++++
 src/pkg/syscall/zsyscall_linux_arm.go | 714 ++++++++++++++++++++++++++++++++++
 src/pkg/syscall/zsysnum_linux_arm.go  | 319 +++++++++++++++
 src/pkg/syscall/ztypes_linux_arm.go   | 368 ++++++++++++++++++
 10 files changed, 2141 insertions(+), 591 deletions(-)

diff --git a/src/cmd/5g/cgen.c b/src/cmd/5g/cgen.c
index e431dc03cf..cee5d78a69 100644
--- a/src/cmd/5g/cgen.c
+++ b/src/cmd/5g/cgen.c
@@ -14,7 +14,7 @@ cgen(Node *n, Node *res)
 {
 	Node *nl, *nr, *r;
 	Node n1, n2;
-	int a;
+	int a, w;
 	Prog *p1, *p2, *p3;
 	Addr addr;
 
@@ -69,7 +69,7 @@ cgen(Node *n, Node *res)
 			goto gen;
 
 		a = optoas(OAS, res->type);
-		if(sudoaddable(a, res, &addr)) {
+		if(sudoaddable(a, res, &addr, &w)) {
 			if(n->op != OREGISTER) {
 				regalloc(&n2, res->type, N);
 				cgen(n, &n2);
@@ -78,6 +78,7 @@ cgen(Node *n, Node *res)
 			} else
 				p1 = gins(a, n, N);
 			p1->to = addr;
+			p1->reg = w;
 			if(debug['g'])
 				print("%P [ignore previous line]\n", p1);
 			sudoclean();
@@ -124,14 +125,16 @@ cgen(Node *n, Node *res)
 	}
 
 	a = optoas(OAS, n->type);
-	if(sudoaddable(a, n, &addr)) {
+	if(sudoaddable(a, n, &addr, &w)) {
 		if(res->op == OREGISTER) {
 			p1 = gins(a, N, res);
 			p1->from = addr;
+			p1->reg = w;
 		} else {
 			regalloc(&n2, n->type, N);
 			p1 = gins(a, N, &n2);
 			p1->from = addr;
+			p1->reg = w;
 			gins(a, &n2, res);
 			regfree(&n2);
 		}
@@ -181,8 +184,11 @@ cgen(Node *n, Node *res)
 		goto ret;
 
 	case OMINUS:
-		a = optoas(n->op, nl->type);
-		goto uop;
+		nr = nl;
+		nl = &n1;
+		nodconst(nl, nr->type, 0);
+		a = optoas(OSUB, nr->type);
+		goto abop;
 
 	// symmetric binary
 	case OAND:
@@ -314,9 +320,10 @@ abop:	// asymmetric binary
 		regalloc(&n1, nl->type, res);
 		cgen(nl, &n1);
 
-		if(sudoaddable(a, nr, &addr)) {
+		if(sudoaddable(a, nr, &addr, &w)) {
 			p1 = gins(a, N, &n1);
 			p1->from = addr;
+			p1->reg = w;
 			gmove(&n1, res);
 			sudoclean();
 			regfree(&n1);
@@ -454,7 +461,7 @@ agen(Node *n, Node *res)
 					n1.op = OINDREG;
 					n1.type = types[tptr];
 					n1.xoffset = Array_nel;
-					nodconst(&n2, types[TUINT64], v);
+					nodconst(&n2, types[TUINT32], v);
 					gins(optoas(OCMP, types[TUINT32]), &n1, &n2);
 					p1 = gbranch(optoas(OGT, types[TUINT32]), T);
 					ginscall(throwindex, 0);
@@ -484,9 +491,9 @@ agen(Node *n, Node *res)
 		}
 
 		// type of the index
-		t = types[TUINT64];
+		t = types[TUINT32];
 		if(issigned[n1.type->etype])
-			t = types[TINT64];
+			t = types[TINT32];
 
 		regalloc(&n2, t, &n1);			// i
 		gmove(&n1, &n2);
@@ -500,7 +507,7 @@ agen(Node *n, Node *res)
 				n1.type = types[tptr];
 				n1.xoffset = Array_nel;
 			} else
-				nodconst(&n1, types[TUINT64], nl->type->bound);
+				nodconst(&n1, types[TUINT32], nl->type->bound);
 			gins(optoas(OCMP, types[TUINT32]), &n2, &n1);
 			p1 = gbranch(optoas(OLT, types[TUINT32]), T);
 			ginscall(throwindex, 0);
@@ -548,7 +555,7 @@ agen(Node *n, Node *res)
 		}
 		cgen(n->heapaddr, res);
 		if(n->xoffset != 0) {
-			nodconst(&n1, types[TINT64], n->xoffset);
+			nodconst(&n1, types[TINT32], n->xoffset);
 			gins(optoas(OADD, types[tptr]), &n1, res);
 		}
 		break;
@@ -560,7 +567,7 @@ agen(Node *n, Node *res)
 	case ODOT:
 		agen(nl, res);
 		if(n->xoffset != 0) {
-			nodconst(&n1, types[TINT64], n->xoffset);
+			nodconst(&n1, types[TINT32], n->xoffset);
 			gins(optoas(OADD, types[tptr]), &n1, res);
 		}
 		break;
@@ -568,7 +575,7 @@ agen(Node *n, Node *res)
 	case ODOTPTR:
 		cgen(nl, res);
 		if(n->xoffset != 0) {
-			nodconst(&n1, types[TINT64], n->xoffset);
+			nodconst(&n1, types[TINT32], n->xoffset);
 			gins(optoas(OADD, types[tptr]), &n1, res);
 		}
 		break;
diff --git a/src/cmd/5g/gg.h b/src/cmd/5g/gg.h
index 82226dce0a..b3186eba95 100644
--- a/src/cmd/5g/gg.h
+++ b/src/cmd/5g/gg.h
@@ -132,7 +132,7 @@ void	buildtxt(void);
 Plist*	newplist(void);
 int	isfat(Type*);
 void	sudoclean(void);
-int	sudoaddable(int, Node*, Addr*);
+int	sudoaddable(int, Node*, Addr*, int*);
 void	afunclit(Addr*);
 void	datagostring(Strlit*, Addr*);
 
diff --git a/src/cmd/5g/ggen.c b/src/cmd/5g/ggen.c
index 3d04ca7f79..5e9806b91a 100644
--- a/src/cmd/5g/ggen.c
+++ b/src/cmd/5g/ggen.c
@@ -147,52 +147,51 @@ ginscall(Node *f, int proc)
 void
 cgen_callinter(Node *n, Node *res, int proc)
 {
-	fatal("cgen_callinter not implemented");
-//	Node *i, *f;
-//	Node tmpi, nodo, nodr, nodsp;
+	Node *i, *f;
+	Node tmpi, nodo, nodr, nodsp;
 
-//	i = n->left;
-//	if(i->op != ODOTINTER)
-//		fatal("cgen_callinter: not ODOTINTER %O", i->op);
+	i = n->left;
+	if(i->op != ODOTINTER)
+		fatal("cgen_callinter: not ODOTINTER %O", i->op);
 
-//	f = i->right;		// field
-//	if(f->op != ONAME)
-//		fatal("cgen_callinter: not ONAME %O", f->op);
+	f = i->right;		// field
+	if(f->op != ONAME)
+		fatal("cgen_callinter: not ONAME %O", f->op);
 
-//	i = i->left;		// interface
+	i = i->left;		// interface
 
-//	if(!i->addable) {
-//		tempname(&tmpi, i->type);
-//		cgen(i, &tmpi);
-//		i = &tmpi;
-//	}
+	if(!i->addable) {
+		tempname(&tmpi, i->type);
+		cgen(i, &tmpi);
+		i = &tmpi;
+	}
 
-//	genlist(n->list);			// args
+	genlist(n->list);			// args
 
-//	regalloc(&nodr, types[tptr], res);
-//	regalloc(&nodo, types[tptr], &nodr);
-//	nodo.op = OINDREG;
+	regalloc(&nodr, types[tptr], res);
+	regalloc(&nodo, types[tptr], &nodr);
+	nodo.op = OINDREG;
 
-//	agen(i, &nodr);		// REG = &inter
+	agen(i, &nodr);		// REG = &inter
 
-//	nodindreg(&nodsp, types[tptr], D_SP);
-//	nodo.xoffset += widthptr;
-//	cgen(&nodo, &nodsp);	// 0(SP) = 8(REG) -- i.s
+	nodindreg(&nodsp, types[tptr], REGSP);
+	nodo.xoffset += widthptr;
+	cgen(&nodo, &nodsp);	// 0(SP) = 8(REG) -- i.s
 
-//	nodo.xoffset -= widthptr;
-//	cgen(&nodo, &nodr);	// REG = 0(REG) -- i.m
+	nodo.xoffset -= widthptr;
+	cgen(&nodo, &nodr);	// REG = 0(REG) -- i.m
 
-//	nodo.xoffset = n->left->xoffset + 4*widthptr;
-//	cgen(&nodo, &nodr);	// REG = 32+offset(REG) -- i.m->fun[f]
+	nodo.xoffset = n->left->xoffset + 4*widthptr;
+	cgen(&nodo, &nodr);	// REG = 32+offset(REG) -- i.m->fun[f]
 
-//	// BOTCH nodr.type = fntype;
-//	nodr.type = n->left->type;
-//	ginscall(&nodr, proc);
+	// BOTCH nodr.type = fntype;
+	nodr.type = n->left->type;
+	ginscall(&nodr, proc);
 
-//	regfree(&nodr);
-//	regfree(&nodo);
+	regfree(&nodr);
+	regfree(&nodo);
 
-//	setmaxarg(n->left->type);
+	setmaxarg(n->left->type);
 }
 
 /*
@@ -289,34 +288,33 @@ cgen_callret(Node *n, Node *res)
 void
 cgen_aret(Node *n, Node *res)
 {
-	fatal("cgen_aret not implemented");
-//	Node nod1, nod2;
-//	Type *fp, *t;
-//	Iter flist;
-
-//	t = n->left->type;
-//	if(isptr[t->etype])
-//		t = t->type;
-
-//	fp = structfirst(&flist, getoutarg(t));
-//	if(fp == T)
-//		fatal("cgen_aret: nil");
-
-//	memset(&nod1, 0, sizeof(nod1));
-//	nod1.op = OINDREG;
-//	nod1.val.u.reg = D_SP;
-//	nod1.addable = 1;
-
-//	nod1.xoffset = fp->width;
-//	nod1.type = fp->type;
-
-//	if(res->op != OREGISTER) {
-//		regalloc(&nod2, types[tptr], res);
-//		gins(ALEAL, &nod1, &nod2);
-//		gins(AMOVL, &nod2, res);
-//		regfree(&nod2);
-//	} else
-//		gins(ALEAL, &nod1, res);
+	Node nod1, nod2;
+	Type *fp, *t;
+	Iter flist;
+
+	t = n->left->type;
+	if(isptr[t->etype])
+		t = t->type;
+
+	fp = structfirst(&flist, getoutarg(t));
+	if(fp == T)
+		fatal("cgen_aret: nil");
+
+	memset(&nod1, 0, sizeof(nod1));
+	nod1.op = OINDREG;
+	nod1.val.u.reg = REGSP;
+	nod1.addable = 1;
+
+	nod1.xoffset = fp->width;
+	nod1.type = fp->type;
+
+	if(res->op != OREGISTER) {
+		regalloc(&nod2, types[tptr], res);
+		agen(&nod1, &nod2);
+		gins(AMOVW, &nod2, res);
+		regfree(&nod2);
+	} else
+		agen(&nod1, res);
 }
 
 /*
@@ -342,7 +340,7 @@ cgen_asop(Node *n)
 	Node *nl, *nr;
 //	Prog *p1;
 	Addr addr;
-	int a;
+	int a, w;
 
 	nl = n->left;
 	nr = n->right;
@@ -380,12 +378,13 @@ cgen_asop(Node *n)
 			goto ret;
 		}
 		if(nr->ullman < UINF)
-		if(sudoaddable(a, nl, &addr)) {
+		if(sudoaddable(a, nl, &addr, &w)) {
 			fatal("cgen_asop sudoaddable not implemented");
 //			regalloc(&n2, nr->type, N);
 //			cgen(nr, &n2);
 //			p1 = gins(a, &n2, N);
 //			p1->to = addr;
+//			p1->reg = w;
 //			regfree(&n2);
 //			sudoclean();
 //			goto ret;
@@ -434,83 +433,40 @@ samereg(Node *a, Node *b)
 }
 
 /*
- * generate division.
- * caller must set:
- *	ax = allocated AX register
- *	dx = allocated DX register
- * generates one of:
+ * generate division according to op, one of:
  *	res = nl / nr
  *	res = nl % nr
- * according to op.
  */
-// TODO(kaib): This probably isn't needed for arm, delete once you complete cgen_div.
+// TODO(kaib): rip out and just insert into cgen
 void
-dodiv(int op, Node *nl, Node *nr, Node *res, Node *ax, Node *dx)
+cgen_div(int op, Node *nl, Node *nr, Node *res)
 {
-	int a;
-	Node n3, n4;
-	Type *t;
-
-	t = nl->type;
-	if(t->width == 1) {
-		if(issigned[t->etype])
-			t = types[TINT32];
-		else
-			t = types[TUINT32];
+	Node nod, nod1;
+	Prog* p;
+	Addr ta;
+	if(res == Z) {
+		// TODO(kaib): add back warning for null
+//		nullwarn(l, r);
+		return;
 	}
-	a = optoas(op, t);
-
-	regalloc(&n3, nr->type, N);
 	if(nl->ullman >= nr->ullman) {
-		cgen(nl, ax);
-		if(!issigned[t->etype]) {
-			nodconst(&n4, t, 0);
-			gmove(&n4, dx);
-		} else
-			gins(optoas(OEXTEND, t), N, N);
-		cgen(nr, &n3);
+		regalloc(&nod, nl->type, res);
+		cgen(nl, &nod);
+		regalloc(&nod1, nr->type, Z);
+		cgen(nr, &nod1);
+		gins(optoas(op, nod1.type), &nod1, &nod);
 	} else {
-		cgen(nr, &n3);
-		cgen(nl, ax);
-		if(!issigned[t->etype]) {
-			nodconst(&n4, t, 0);
-			gmove(&n4, dx);
-		} else
-			gins(optoas(OEXTEND, t), N, N);
+		regalloc(&nod, nr->type, res);
+		cgen(nr, &nod);
+		regalloc(&nod1, nl->type, Z);
+		cgen(nl, &nod1);
+		p = gins(optoas(op, nod.type), &nod, &nod);
+		naddr(&nod1, &ta);
+		p->reg = ta.reg;
 	}
-	gins(a, &n3, N);
-	regfree(&n3);
-
-	if(op == ODIV)
-		gmove(ax, res);
-	else
-		gmove(dx, res);
-}
-
-/*
- * generate division according to op, one of:
- *	res = nl / nr
- *	res = nl % nr
- */
-void
-cgen_div(int op, Node *nl, Node *nr, Node *res)
-{
-	fatal("cgen_div not implemented");
-//	Node ax, dx;
-//	int rax, rdx;
-
-//	rax = reg[D_AX];
-//	rdx = reg[D_DX];
-
-//	nodreg(&ax, types[TINT64], D_AX);
-//	nodreg(&dx, types[TINT64], D_DX);
-//	regalloc(&ax, nl->type, &ax);
-//	regalloc(&dx, nl->type, &dx);
-
-//	dodiv(op, nl, nr, res, &ax, &dx);
-
-//	regfree(&ax);
-//	regfree(&dx);
+	gins(optoas(OAS, nod.type), &nod, res);
+	regfree(&nod);
+	regfree(&nod1);
 }
 
 /*
@@ -518,6 +474,7 @@ cgen_div(int op, Node *nl, Node *nr, Node *res)
  *	res = nl << nr
  *	res = nl >> nr
  */
+// TODO(kaib): rip out and replace with simple isntruction
 void
 cgen_shift(int op, Node *nl, Node *nr, Node *res)
 {
@@ -588,6 +545,7 @@ cgen_shift(int op, Node *nl, Node *nr, Node *res)
  * no byte multiply instruction so have to do
  * 16-bit multiply and take bottom half.
  */
+// TODO(kaib): figure out if we can replace this normal multiply
 void
 cgen_bmul(int op, Node *nl, Node *nr, Node *res)
 {
diff --git a/src/cmd/5g/gsubr.c b/src/cmd/5g/gsubr.c
index 305fd56f5a..ea05e09812 100644
--- a/src/cmd/5g/gsubr.c
+++ b/src/cmd/5g/gsubr.c
@@ -626,324 +626,103 @@ gmove(Node *f, Node *t)
 //		cvt = types[TUINT32];
 //		goto hard;
 
-//	case CASE(TINT32, TINT64):	// sign extend int32
-//	case CASE(TINT32, TUINT64):
-//		fatal("gmove TINT32,INT64 not implemented");
-////		split64(t, &tlo, &thi);
-////		nodreg(&flo, tlo.type, D_AX);
-////		nodreg(&fhi, thi.type, D_DX);
-////		gmove(f, &flo);
-////		gins(ACDQ, N, N);
-////		gins(AMOVL, &flo, &tlo);
-////		gins(AMOVL, &fhi, &thi);
-////		splitclean();
-//		return;
-
-//	case CASE(TUINT32, TINT64):	// zero extend uint32
-//	case CASE(TUINT32, TUINT64):
-//		fatal("gmove TUINT32,INT64 not implemented");
-////		split64(t, &tlo, &thi);
-////		gmove(f, &tlo);
-////		gins(AMOVL, ncon(0), &thi);
-////		splitclean();
-//		return;
-
-//	/*
-//	* float to integer
-//	*/
-//	case CASE(TFLOAT32, TINT16):
-//	case CASE(TFLOAT32, TINT32):
-//	case CASE(TFLOAT32, TINT64):
-//	case CASE(TFLOAT64, TINT16):
-//	case CASE(TFLOAT64, TINT32):
-//	case CASE(TFLOAT64, TINT64):
-//		if(t->op == OREGISTER)
-//			goto hardmem;
-//		nodreg(&r1, types[ft], D_F0);
-//		if(ft == TFLOAT32)
-//			gins(AFMOVF, f, &r1);
-//		else
-//			gins(AFMOVD, f, &r1);
-
-//		// set round to zero mode during conversion
-//		tempalloc(&t1, types[TUINT16]);
-//		tempalloc(&t2, types[TUINT16]);
-//		gins(AFSTCW, N, &t1);
-//		gins(AMOVW, ncon(0xf7f), &t2);
-//		gins(AFLDCW, &t2, N);
-//		if(tt == TINT16)
-//			gins(AFMOVWP, &r1, t);
-//		else if(tt == TINT32)
-//			gins(AFMOVLP, &r1, t);
-//		else
-//			gins(AFMOVVP, &r1, t);
-//		gins(AFLDCW, &t1, N);
-//		tempfree(&t2);
-//		tempfree(&t1);
-//		return;
-
-//	case CASE(TFLOAT32, TINT8):
-//	case CASE(TFLOAT32, TUINT16):
-//	case CASE(TFLOAT32, TUINT8):
-//	case CASE(TFLOAT64, TINT8):
-//	case CASE(TFLOAT64, TUINT16):
-//	case CASE(TFLOAT64, TUINT8):
-//		// convert via int32.
-//		tempalloc(&t1, types[TINT32]);
-//		gmove(f, &t1);
-//		switch(tt) {
-//		default:
-//			fatal("gmove %T", t);
-//		case TINT8:
-//			gins(ACMPL, &t1, ncon(-0x80));
-//			p1 = gbranch(optoas(OLT, types[TINT32]), T);
-//			gins(ACMPL, &t1, ncon(0x7f));
-//			p2 = gbranch(optoas(OGT, types[TINT32]), T);
-//			p3 = gbranch(AJMP, T);
-//			patch(p1, pc);
-//			patch(p2, pc);
-//			gmove(ncon(-0x80), &t1);
-//			patch(p3, pc);
-//			gmove(&t1, t);
-//			break;
-//		case TUINT8:
-//			gins(ATESTL, ncon(0xffffff00), &t1);
-//			p1 = gbranch(AJEQ, T);
-//			gins(AMOVB, ncon(0), &t1);
-//			patch(p1, pc);
-//			gmove(&t1, t);
-//			break;
-//		case TUINT16:
-//			gins(ATESTL, ncon(0xffff0000), &t1);
-//			p1 = gbranch(AJEQ, T);
-//			gins(AMOVW, ncon(0), &t1);
-//			patch(p1, pc);
-//			gmove(&t1, t);
-//			break;
-//		}
-//		tempfree(&t1);
-//		return;
-
-//	case CASE(TFLOAT32, TUINT32):
-//	case CASE(TFLOAT64, TUINT32):
-//		// convert via int64.
-//		tempalloc(&t1, types[TINT64]);
-//		gmove(f, &t1);
-//		split64(&t1, &tlo, &thi);
-//		gins(ACMPL, &thi, ncon(0));
-//		p1 = gbranch(AJEQ, T);
-//		gins(AMOVL, ncon(0), &tlo);
-//		patch(p1, pc);
-//		gmove(&tlo, t);
-//		splitclean();
-//		tempfree(&t1);
-//		return;
-
-//	case CASE(TFLOAT32, TUINT64):
-//	case CASE(TFLOAT64, TUINT64):
-//		bignodes();
-//		nodreg(&f0, types[ft], D_F0);
-//		nodreg(&f1, types[ft], D_F0 + 1);
-//		nodreg(&ax, types[TUINT16], D_AX);
-
-//		gmove(f, &f0);
-
-//		// if 0 > v { answer = 0 }
-//		gmove(&zerof, &f0);
-//		gins(AFUCOMP, &f0, &f1);
-//		gins(AFSTSW, N, &ax);
-//		gins(ASAHF, N, N);
-//		p1 = gbranch(optoas(OGT, types[tt]), T);
-//		// if 1<<64 <= v { answer = 0 too }
-//		gmove(&two64f, &f0);
-//		gins(AFUCOMP, &f0, &f1);
-//		gins(AFSTSW, N, &ax);
-//		gins(ASAHF, N, N);
-//		p2 = gbranch(optoas(OGT, types[tt]), T);
-//		patch(p1, pc);
-//		gins(AFMOVVP, &f0, t);	// don't care about t, but will pop the stack
+	case CASE(TINT32, TINT64):	// sign extend int32
+	case CASE(TINT32, TUINT64):
+		fatal("gmove TINT32,INT64 not implemented");
 //		split64(t, &tlo, &thi);
-//		gins(AMOVL, ncon(0), &tlo);
-//		gins(AMOVL, ncon(0), &thi);
+//		nodreg(&flo, tlo.type, D_AX);
+//		nodreg(&fhi, thi.type, D_DX);
+//		gmove(f, &flo);
+//		gins(ACDQ, N, N);
+//		gins(AMOVL, &flo, &tlo);
+//		gins(AMOVL, &fhi, &thi);
 //		splitclean();
-//		p1 = gbranch(AJMP, T);
-//		patch(p2, pc);
-
-//		// in range; algorithm is:
-//		//	if small enough, use native float64 -> int64 conversion.
-//		//	otherwise, subtract 2^63, convert, and add it back.
-
-//		// set round to zero mode during conversion
-//		tempalloc(&t1, types[TUINT16]);
-//		tempalloc(&t2, types[TUINT16]);
-//		gins(AFSTCW, N, &t1);
-//		gins(AMOVW, ncon(0xf7f), &t2);
-//		gins(AFLDCW, &t2, N);
-//		tempfree(&t2);
-
-//		// actual work
-//		gmove(&two63f, &f0);
-//		gins(AFUCOMP, &f0, &f1);
-//		gins(AFSTSW, N, &ax);
-//		gins(ASAHF, N, N);
-//		p2 = gbranch(optoas(OLE, types[tt]), T);
-//		gins(AFMOVVP, &f0, t);
-//		p3 = gbranch(AJMP, T);
-//		patch(p2, pc);
-//		gmove(&two63f, &f0);
-//		gins(AFSUBDP, &f0, &f1);
-//		gins(AFMOVVP, &f0, t);
+		return;
+
+	case CASE(TUINT32, TINT64):	// zero extend uint32
+	case CASE(TUINT32, TUINT64):
+		fatal("gmove TUINT32,INT64 not implemented");
 //		split64(t, &tlo, &thi);
-//		gins(AXORL, ncon(0x80000000), &thi);	// + 2^63
-//		patch(p3, pc);
-//		patch(p1, pc);
+//		gmove(f, &tlo);
+//		gins(AMOVL, ncon(0), &thi);
 //		splitclean();
+		return;
 
-//		// restore rounding mode
-//		gins(AFLDCW, &t1, N);
-//		tempfree(&t1);
-//		return;
-
-//	/*
-//	 * integer to float
-//	 */
-//	case CASE(TINT16, TFLOAT32):
-//	case CASE(TINT16, TFLOAT64):
-//	case CASE(TINT32, TFLOAT32):
-//	case CASE(TINT32, TFLOAT64):
-//	case CASE(TINT64, TFLOAT32):
-//	case CASE(TINT64, TFLOAT64):
-//		fatal("gmove TINT,TFLOAT not implemented");
-////		if(t->op != OREGISTER)
-////			goto hard;
-////		if(f->op == OREGISTER) {
-////			cvt = f->type;
-////			goto hardmem;
-////		}
-////		switch(ft) {
-////		case TINT16:
-////			a = AFMOVW;
-////			break;
-////		case TINT32:
-////			a = AFMOVL;
-////			break;
-////		default:
-////			a = AFMOVV;
-////			break;
-////		}
-//		break;
+	/*
+	* float to integer
+	*/
+	case CASE(TFLOAT32, TINT8):
+	case CASE(TFLOAT32, TINT16):
+	case CASE(TFLOAT32, TINT32):
+	case CASE(TFLOAT32, TUINT8):
+	case CASE(TFLOAT32, TUINT16):
+	case CASE(TFLOAT32, TUINT32):
+		a = AMOVFW;
+		break;
 
-//	case CASE(TINT8, TFLOAT32):
-//	case CASE(TINT8, TFLOAT64):
-//	case CASE(TUINT16, TFLOAT32):
-//	case CASE(TUINT16, TFLOAT64):
-//	case CASE(TUINT8, TFLOAT32):
-//	case CASE(TUINT8, TFLOAT64):
-//		// convert via int32 memory
-//		cvt = types[TINT32];
-//		goto hardmem;
-
-//	case CASE(TUINT32, TFLOAT32):
-//	case CASE(TUINT32, TFLOAT64):
-//		// convert via int64 memory
-//		cvt = types[TINT64];
-//		goto hardmem;
-
-//	case CASE(TUINT64, TFLOAT32):
-//	case CASE(TUINT64, TFLOAT64):
-//		// algorithm is:
-//		//	if small enough, use native int64 -> uint64 conversion.
-//		//	otherwise, halve (rounding to odd?), convert, and double.
-//		nodreg(&ax, types[TUINT32], D_AX);
-//		nodreg(&dx, types[TUINT32], D_DX);
-//		nodreg(&cx, types[TUINT32], D_CX);
-//		tempalloc(&t1, f->type);
-//		split64(&t1, &tlo, &thi);
-//		gmove(f, &t1);
-//		gins(ACMPL, &thi, ncon(0));
-//		p1 = gbranch(AJLT, T);
-//		// native
-//		t1.type = types[TINT64];
-//		gmove(&t1, t);
-//		p2 = gbranch(AJMP, T);
-//		// simulated
-//		patch(p1, pc);
-//		gmove(&tlo, &ax);
-//		gmove(&thi, &dx);
-//		p1 = gins(ASHRL, ncon(1), &ax);
-//		p1->from.index = D_DX;	// double-width shift DX -> AX
-//		p1->from.scale = 0;
-//		gins(ASETCC, N, &cx);
-//		gins(AORB, &cx, &ax);
-//		gins(ASHRL, ncon(1), &dx);
-//		gmove(&dx, &thi);
-//		gmove(&ax, &tlo);
-//		nodreg(&r1, types[tt], D_F0);
-//		nodreg(&r2, types[tt], D_F0 + 1);
-//		gmove(&t1, &r1);	// t1.type is TINT64 now, set above
-//		gins(AFMOVD, &r1, &r1);
-//		gins(AFADDDP, &r1, &r2);
-//		gmove(&r1, t);
-//		patch(p2, pc);
-//		splitclean();
-//		tempfree(&t1);
-//		return;
-
-//	/*
-//	 * float to float
-//	 */
-//	case CASE(TFLOAT32, TFLOAT32):
-//	case CASE(TFLOAT64, TFLOAT64):
-//		// The way the code generator uses floating-point
-//		// registers, a move from F0 to F0 is intended as a no-op.
-//		// On the x86, it's not: it pushes a second copy of F0
-//		// on the floating point stack.  So toss it away here.
-//		// Also, F0 is the *only* register we ever evaluate
-//		// into, so we should only see register/register as F0/F0.
-//		if(f->op == OREGISTER && t->op == OREGISTER) {
-//			if(f->val.u.reg != D_F0 || t->val.u.reg != D_F0)
-//				goto fatal;
-//			return;
-//		}
-//		if(ismem(f) && ismem(t))
-//			goto hard;
-//		a = AFMOVF;
-//		if(ft == TFLOAT64)
-//			a = AFMOVD;
-//		if(ismem(t)) {
-//			if(f->op != OREGISTER || f->val.u.reg != D_F0)
-//				fatal("gmove %N", f);
-//			a = AFMOVFP;
-//			if(ft == TFLOAT64)
-//				a = AFMOVDP;
-//		}
-//		break;
+	case CASE(TFLOAT64, TINT8):
+	case CASE(TFLOAT64, TINT16):
+	case CASE(TFLOAT64, TINT32):
+	case CASE(TFLOAT64, TUINT8):
+	case CASE(TFLOAT64, TUINT16):
+	case CASE(TFLOAT64, TUINT32):
+		a = AMOVDW;
+		break;
 
-//	case CASE(TFLOAT32, TFLOAT64):
-//		if(f->op == OREGISTER && t->op == OREGISTER) {
-//			if(f->val.u.reg != D_F0 || t->val.u.reg != D_F0)
-//				goto fatal;
-//			return;
-//		}
-//		if(f->op == OREGISTER)
-//			gins(AFMOVDP, f, t);
-//		else
-//			gins(AFMOVF, f, t);
-//		return;
-
-//	case CASE(TFLOAT64, TFLOAT32):
-//		if(f->op == OREGISTER && t->op == OREGISTER) {
-//			tempalloc(&r1, types[TFLOAT32]);
-//			gins(AFMOVFP, f, &r1);
-//			gins(AFMOVF, &r1, t);
-//			tempfree(&r1);
-//			return;
-//		}
-//		if(f->op == OREGISTER)
-//			gins(AFMOVFP, f, t);
-//		else
-//			gins(AFMOVD, f, t);
-//		return;
+	case CASE(TFLOAT32, TINT64):
+	case CASE(TFLOAT32, TUINT64):
+	case CASE(TFLOAT64, TINT64):
+	case CASE(TFLOAT64, TUINT64):
+		fatal("gmove TFLOAT, INT64 not implemented");
+		return;
+
+	/*
+	 * integer to float
+	 */
+	case CASE(TINT8, TFLOAT32):
+	case CASE(TINT16, TFLOAT32):
+	case CASE(TINT32, TFLOAT32):
+	case CASE(TUINT8, TFLOAT32):
+	case CASE(TUINT16, TFLOAT32):
+	case CASE(TUINT32, TFLOAT32):
+		a = AMOVWF;
+		break;
+
+	case CASE(TINT8, TFLOAT64):
+	case CASE(TINT16, TFLOAT64):
+	case CASE(TINT32, TFLOAT64):
+	case CASE(TUINT8, TFLOAT64):
+	case CASE(TUINT16, TFLOAT64):
+	case CASE(TUINT32, TFLOAT64):
+		a = AMOVWD;
+		break;
+
+	case CASE(TINT64, TFLOAT32):
+	case CASE(TINT64, TFLOAT64):
+	case CASE(TUINT64, TFLOAT32):
+	case CASE(TUINT64, TFLOAT64):
+		fatal("gmove INT64, TFLOAT not implemented");
+		return;
+
+
+	/*
+	 * float to float
+	 */
+	case CASE(TFLOAT32, TFLOAT32):
+		a = AMOVF;
+		break;
+
+	case CASE(TFLOAT64, TFLOAT64):
+		a = AMOVD;
+		break;
+
+	case CASE(TFLOAT32, TFLOAT64):
+		a = AMOVFD;
+		break;
+
+	case CASE(TFLOAT64, TFLOAT32):
+		a = AMOVDF;
+		break;
 	}
 
 	gins(a, f, t);
@@ -1204,8 +983,10 @@ naddr(Node *n, Addr *a)
 		if(a->type == D_OREG) {
 			a->type = D_CONST;
 			break;
+		} else if (a->type == D_REG) {
+			break;
 		}
-		fatal("naddr: OADDR\n");
+		fatal("naddr: OADDR %d\n", a->type);
 	}
 }
 
@@ -1353,13 +1134,13 @@ optoas(int op, Type *t)
 //		a = ACMPQ;
 //		break;
 
-//	case CASE(OCMP, TFLOAT32):
-//		a = AUCOMISS;
-//		break;
+	case CASE(OCMP, TFLOAT32):
+		a = ACMPF;
+		break;
 
-//	case CASE(OCMP, TFLOAT64):
-//		a = AUCOMISD;
-//		break;
+	case CASE(OCMP, TFLOAT64):
+		a = ACMPD;
+		break;
 
 	case CASE(OAS, TBOOL):
 	case CASE(OAS, TINT8):
@@ -1384,13 +1165,13 @@ optoas(int op, Type *t)
 //		a = AMOVQ;
 //		break;
 
-//	case CASE(OAS, TFLOAT32):
-//		a = AMOVSS;
-//		break;
+	case CASE(OAS, TFLOAT32):
+		a = AMOVF;
+		break;
 
-//	case CASE(OAS, TFLOAT64):
-//		a = AMOVSD;
-//		break;
+	case CASE(OAS, TFLOAT64):
+		a = AMOVD;
+		break;
 
 	case CASE(OADD, TINT8):
 	case CASE(OADD, TUINT8):
@@ -1408,29 +1189,23 @@ optoas(int op, Type *t)
 //		a = AADDQ;
 //		break;
 
-//	case CASE(OADD, TFLOAT32):
-//		a = AADDSS;
-//		break;
-
-//	case CASE(OADD, TFLOAT64):
-//		a = AADDSD;
-//		break;
-
-//	case CASE(OSUB, TINT8):
-//	case CASE(OSUB, TUINT8):
-//		a = ASUBB;
-//		break;
+	case CASE(OADD, TFLOAT32):
+		a = AADDF;
+		break;
 
-//	case CASE(OSUB, TINT16):
-//	case CASE(OSUB, TUINT16):
-//		a = ASUBW;
-//		break;
+	case CASE(OADD, TFLOAT64):
+		a = AADDD;
+		break;
 
-//	case CASE(OSUB, TINT32):
-//	case CASE(OSUB, TUINT32):
-//	case CASE(OSUB, TPTR32):
-//		a = ASUBL;
-//		break;
+	case CASE(OSUB, TINT8):
+	case CASE(OSUB, TUINT8):
+	case CASE(OSUB, TINT16):
+	case CASE(OSUB, TUINT16):
+	case CASE(OSUB, TINT32):
+	case CASE(OSUB, TUINT32):
+	case CASE(OSUB, TPTR32):
+		a = ASUB;
+		break;
 
 //	case CASE(OSUB, TINT64):
 //	case CASE(OSUB, TUINT64):
@@ -1438,35 +1213,13 @@ optoas(int op, Type *t)
 //		a = ASUBQ;
 //		break;
 
-//	case CASE(OSUB, TFLOAT32):
-//		a = ASUBSS;
-//		break;
-
-//	case CASE(OSUB, TFLOAT64):
-//		a = ASUBSD;
-//		break;
-
-//	case CASE(OMINUS, TINT8):
-//	case CASE(OMINUS, TUINT8):
-//		a = ANEGB;
-//		break;
-
-//	case CASE(OMINUS, TINT16):
-//	case CASE(OMINUS, TUINT16):
-//		a = ANEGW;
-//		break;
-
-//	case CASE(OMINUS, TINT32):
-//	case CASE(OMINUS, TUINT32):
-//	case CASE(OMINUS, TPTR32):
-//		a = ANEGL;
-//		break;
+	case CASE(OSUB, TFLOAT32):
+		a = ASUBF;
+		break;
 
-//	case CASE(OMINUS, TINT64):
-//	case CASE(OMINUS, TUINT64):
-//	case CASE(OMINUS, TPTR64):
-//		a = ANEGQ;
-//		break;
+	case CASE(OSUB, TFLOAT64):
+		a = ASUBD;
+		break;
 
 //	case CASE(OAND, TINT8):
 //	case CASE(OAND, TUINT8):
@@ -1590,21 +1343,15 @@ optoas(int op, Type *t)
 //		a = ASARQ;
 //		break;
 
-//	case CASE(OMUL, TINT8):
-//	case CASE(OMUL, TUINT8):
-//		a = AIMULB;
-//		break;
-
-//	case CASE(OMUL, TINT16):
-//	case CASE(OMUL, TUINT16):
-//		a = AIMULW;
-//		break;
-
-//	case CASE(OMUL, TINT32):
-//	case CASE(OMUL, TUINT32):
-//	case CASE(OMUL, TPTR32):
-//		a = AIMULL;
-//		break;
+	case CASE(OMUL, TINT8):
+	case CASE(OMUL, TUINT8):
+	case CASE(OMUL, TINT16):
+	case CASE(OMUL, TUINT16):
+	case CASE(OMUL, TINT32):
+	case CASE(OMUL, TUINT32):
+	case CASE(OMUL, TPTR32):
+		a = AMUL;
+		break;
 
 //	case CASE(OMUL, TINT64):
 //	case CASE(OMUL, TUINT64):
@@ -1620,37 +1367,25 @@ optoas(int op, Type *t)
 //		a = AMULSD;
 //		break;
 
-//	case CASE(ODIV, TINT8):
-//	case CASE(OMOD, TINT8):
-//		a = AIDIVB;
-//		break;
-
-//	case CASE(ODIV, TUINT8):
-//	case CASE(OMOD, TUINT8):
-//		a = ADIVB;
-//		break;
-
-//	case CASE(ODIV, TINT16):
-//	case CASE(OMOD, TINT16):
-//		a = AIDIVW;
-//		break;
-
-//	case CASE(ODIV, TUINT16):
-//	case CASE(OMOD, TUINT16):
-//		a = ADIVW;
-//		break;
-
-//	case CASE(ODIV, TINT32):
-//	case CASE(OMOD, TINT32):
-//		a = AIDIVL;
-//		break;
+	case CASE(ODIV, TINT8):
+	case CASE(ODIV, TUINT8):
+	case CASE(ODIV, TINT16):
+	case CASE(ODIV, TUINT16):
+	case CASE(ODIV, TINT32):
+	case CASE(ODIV, TUINT32):
+	case CASE(ODIV, TPTR32):
+		a = ADIV;
+		break;
 
-//	case CASE(ODIV, TUINT32):
-//	case CASE(ODIV, TPTR32):
-//	case CASE(OMOD, TUINT32):
-//	case CASE(OMOD, TPTR32):
-//		a = ADIVL;
-//		break;
+	case CASE(OMOD, TINT8):
+	case CASE(OMOD, TUINT8):
+	case CASE(OMOD, TINT16):
+	case CASE(OMOD, TUINT16):
+	case CASE(OMOD, TINT32):
+	case CASE(OMOD, TUINT32):
+	case CASE(OMOD, TPTR32):
+		a = AMOD;
+		break;
 
 //	case CASE(ODIV, TINT64):
 //	case CASE(OMOD, TINT64):
@@ -1719,9 +1454,9 @@ sudoclean(void)
  * to release the register used for a.
  */
 int
-sudoaddable(int as, Node *n, Addr *a)
+sudoaddable(int as, Node *n, Addr *a, int *w)
 {
-	int o, i, w;
+	int o, i;
 	int oary[10];
 	int64 v;
 	Node n1, n2, n3, *nn, *l, *r;
@@ -1761,20 +1496,14 @@ sudoaddable(int as, Node *n, Addr *a)
 	return 0;
 
 lit:
-	fatal("sudoaddable lit not implemented");
-//	switch(as) {
-//	default:
-//		return 0;
-//	case AADDB: case AADDW: case AADDL: case AADDQ:
-//	case ASUBB: case ASUBW: case ASUBL: case ASUBQ:
-//	case AANDB: case AANDW: case AANDL: case AANDQ:
-//	case AORB:  case AORW:  case AORL:  case AORQ:
-//	case AXORB: case AXORW: case AXORL: case AXORQ:
-//	case AINCB: case AINCW: case AINCL: case AINCQ:
-//	case ADECB: case ADECW: case ADECL: case ADECQ:
-//	case AMOVB: case AMOVW: case AMOVL: case AMOVQ:
-//		break;
-//	}
+	switch(as) {
+	default:
+		return 0;
+	case AADD: case ASUB: case AAND: case AORR: case AEOR:
+	case AMOVB: case AMOVBU: case AMOVH: case AMOVHU:
+	case AMOVW:
+		break;
+	}
 
 	cleani += 2;
 	reg = &clean[cleani-1];
@@ -1842,11 +1571,11 @@ oindex:
 			o += ODynam;
 	}
 
-	w = n->type->width;
+	*w = n->type->width;
 	if(isconst(r, CTINT))
 		goto oindex_const;
 
-	switch(w) {
+	switch(*w) {
 	default:
 		goto no;
 	case 1:
@@ -1866,9 +1595,9 @@ oindex:
 	}
 
 	// load the index (reg1)
-	t = types[TUINT64];
+	t = types[TUINT32];
 	if(issigned[r->type->etype])
-		t = types[TINT64];
+		t = types[TINT32];
 	regalloc(reg1, t, N);
 	regalloc(&n3, r->type, reg1);
 	cgen(r, &n3);
@@ -1910,12 +1639,11 @@ oindex:
 		gmove(&n2, reg);
 	}
 
-	fatal("sudoaddable oindex not implemented");
-//	naddr(reg1, a);
-//	a->offset = 0;
-//	a->scale = w;
-//	a->index = a->type;
-//	a->type = reg->val.u.reg + D_INDIR;
+	naddr(reg1, a);
+	a->offset = 0;
+	a->name = a->type;
+	a->type = D_OREG;
+	a->reg = reg->val.u.reg;
 
 	goto yes;
 
@@ -1967,7 +1695,7 @@ oindex_const:
 
 	n2 = *reg;
 	n2.op = OINDREG;
-	n2.xoffset = v*w;
+	n2.xoffset = v * (*w);
 	a->type = D_NONE;
 	a->name = D_NONE;
 	naddr(&n2, a);
diff --git a/src/make-arm.bash b/src/make-arm.bash
index ef41a3c8f6..a857a7dd3c 100755
--- a/src/make-arm.bash
+++ b/src/make-arm.bash
@@ -21,7 +21,9 @@ chmod +x $GOBIN/quietgcc
 
 # TODO(kaib): converge with normal build
 #for i in lib9 libbio libmach libregexp cmd pkg cmd/ebnflint cmd/godoc cmd/gofmt
-for i in lib9 libbio libmach libregexp cmd pkg/runtime
+for i in lib9 libbio libmach libregexp cmd pkg/runtime pkg/sync pkg/once pkg/malloc pkg/sort pkg/unicode
+# pkg/hash
+# pkg/math
 do
 	# The ( ) here are to preserve the current directory
 	# for the next round despite the cd $i below.
diff --git a/src/pkg/syscall/syscall_linux_arm.go b/src/pkg/syscall/syscall_linux_arm.go
new file mode 100644
index 0000000000..dc64ae79f2
--- /dev/null
+++ b/src/pkg/syscall/syscall_linux_arm.go
@@ -0,0 +1,138 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package syscall
+
+import "unsafe"
+
+func Getpagesize() int {
+	return 4096
+}
+
+func TimespecToNsec(ts Timespec) int64 {
+	return int64(ts.Sec)*1e9 + int64(ts.Nsec);
+}
+
+func NsecToTimespec(nsec int64) (ts Timespec) {
+	ts.Sec = int32(nsec / 1e9);
+	ts.Nsec = int32(nsec % 1e9);
+	return;
+}
+
+func TimevalToNsec(tv Timeval) int64 {
+	return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3;
+}
+
+func NsecToTimeval(nsec int64) (tv Timeval) {
+	nsec += 999;	// round up to microsecond
+	tv.Sec = int32(nsec/1e9);
+	tv.Usec = int32(nsec%1e9 / 1e3);
+	return;
+}
+
+// 64-bit file system and 32-bit uid calls
+// (386 default is 32-bit file system and 16-bit uid).
+//sys	Chown(path string, uid int, gid int) (errno int) = SYS_CHOWN32
+//sys	Fchown(fd int, uid int, gid int) (errno int) = SYS_FCHOWN32
+//sys	Fstat(fd int, stat *Stat_t) (errno int) = SYS_FSTAT64
+//sys	Fstatfs(fd int, buf *Statfs_t) (errno int) = SYS_FSTATFS64
+//sys	Getegid() (egid int) = SYS_GETEGID32
+//sys	Geteuid() (euid int) = SYS_GETEUID32
+//sys	Getgid() (gid int) = SYS_GETGID32
+//sys	Getuid() (uid int) = SYS_GETUID32
+//sys	Lchown(path string, uid int, gid int) (errno int) = SYS_LCHOWN32
+//sys	Lstat(path string, stat *Stat_t) (errno int) = SYS_LSTAT64
+//sys	Setfsgid(gid int) (errno int) = SYS_SETFSGID32
+//sys	Setfsuid(uid int) (errno int) = SYS_SETFSUID32
+//sys	Setgid(gid int) (errno int) = SYS_SETGID32
+//sys	Setregid(rgid int, egid int) (errno int) = SYS_SETREGID32
+//sys	Setresgid(rgid int, egid int, sgid int) (errno int) = SYS_SETRESGID32
+//sys	Setresuid(ruid int, euid int, suid int) (errno int) = SYS_SETRESUID32
+//sys	Setreuid(ruid int, euid int) (errno int) = SYS_SETREUID32
+//sys	Stat(path string, stat *Stat_t) (errno int) = SYS_STAT64
+//sys	Statfs(path string, buf *Statfs_t) (errno int) = SYS_STATFS64
+//sys	getgroups(n int, list *_Gid_t) (nn int, errno int) = SYS_GETGROUPS32
+//sys	setgroups(n int, list *_Gid_t) (errno int) = SYS_SETGROUPS32
+
+//sys	Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, errno int) = SYS__NEWSELECT
+
+// Underlying system call writes to newoffset via pointer.
+// Implemented in assembly to avoid allocation.
+func Seek(fd int, offset int64, whence int) (newoffset int64, errno int)
+
+// On x86 Linux, all the socket calls go through an extra indirection,
+// I think because the 5-register system call interface can't handle
+// the 6-argument calls like sendto and recvfrom.  Instead the
+// arguments to the underlying system call are the number below
+// and a pointer to an array of uintptr.  We hide the pointer in the
+// socketcall assembly to avoid allocation on every system call.
+
+const (
+	// see linux/net.h
+	_SOCKET = 1;
+	_BIND = 2;
+	_CONNECT = 3;
+	_LISTEN = 4;
+	_ACCEPT = 5;
+	_GETSOCKNAME = 6;
+	_GETPEERNAME = 7;
+	_SOCKETPAIR = 8;
+	_SEND = 9;
+	_RECV = 10;
+	_SENDTO = 11;
+	_RECVFROM = 12;
+	_SHUTDOWN = 13;
+	_SETSOCKOPT = 14;
+	_GETSOCKOPT = 15;
+	_SENDMSG = 16;
+	_RECVMSG = 17;
+)
+
+func socketcall(call int, a0, a1, a2, a3, a4, a5 uintptr) (n int, errno int)
+
+func accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, errno int) {
+	fd, errno = socketcall(_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0);
+	return;
+}
+
+func getsockname(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
+	var _ int;
+	_, errno = socketcall(_GETSOCKNAME, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0);
+	return;
+}
+
+func getpeername(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
+	var _ int;
+	_, errno = socketcall(_GETPEERNAME, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0);
+	return;
+}
+
+func bind(s int, addr uintptr, addrlen _Socklen) (errno int) {
+	var _ int;
+	_, errno = socketcall(_BIND, uintptr(s), uintptr(addr), uintptr(addrlen), 0, 0, 0);
+	return;
+}
+
+func connect(s int, addr uintptr, addrlen _Socklen) (errno int) {
+	var _ int;
+	_, errno = socketcall(_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen), 0, 0, 0);
+	return;
+}
+
+func socket(domain int, typ int, proto int) (fd int, errno int) {
+	fd, errno = socketcall(_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto), 0, 0, 0);
+	return;
+}
+
+func setsockopt(s int, level int, name int, val uintptr, vallen int) (errno int) {
+	var _ int;
+	_, errno = socketcall(_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0);
+	return;
+}
+
+func Listen(s int, n int) (errno int) {
+	var _ int;
+	_, errno = socketcall(_LISTEN, uintptr(s), uintptr(n), 0, 0, 0, 0);
+	return;
+}
diff --git a/src/pkg/syscall/zerrors_linux_arm.go b/src/pkg/syscall/zerrors_linux_arm.go
new file mode 100644
index 0000000000..95d51e93fc
--- /dev/null
+++ b/src/pkg/syscall/zerrors_linux_arm.go
@@ -0,0 +1,316 @@
+// mkerrors.sh
+// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
+
+// godefs -gsyscall _errors.c
+
+// MACHINE GENERATED - DO NOT EDIT.
+
+package syscall
+
+// Constants
+const (
+	EMULTIHOP = 0x48;
+	EUNATCH = 0x31;
+	EAFNOSUPPORT = 0x61;
+	EREMCHG = 0x4e;
+	EACCES = 0xd;
+	EL3RST = 0x2f;
+	EDESTADDRREQ = 0x59;
+	EILSEQ = 0x54;
+	ESPIPE = 0x1d;
+	EMLINK = 0x1f;
+	EOWNERDEAD = 0x82;
+	ENOTTY = 0x19;
+	EBADE = 0x34;
+	EBADF = 0x9;
+	EBADR = 0x35;
+	EADV = 0x44;
+	ERANGE = 0x22;
+	ECANCELED = 0x7d;
+	ETXTBSY = 0x1a;
+	ENOMEM = 0xc;
+	EINPROGRESS = 0x73;
+	ENOTBLK = 0xf;
+	EPROTOTYPE = 0x5b;
+	ERESTART = 0x55;
+	EISNAM = 0x78;
+	ENOMSG = 0x2a;
+	EALREADY = 0x72;
+	ETIMEDOUT = 0x6e;
+	ENODATA = 0x3d;
+	EINTR = 0x4;
+	ENOLINK = 0x43;
+	EPERM = 0x1;
+	ELOOP = 0x28;
+	ENETDOWN = 0x64;
+	ESTALE = 0x74;
+	ENOTSOCK = 0x58;
+	ENOSR = 0x3f;
+	ECHILD = 0xa;
+	ELNRNG = 0x30;
+	EPIPE = 0x20;
+	EBADMSG = 0x4a;
+	EBFONT = 0x3b;
+	EREMOTE = 0x42;
+	ETOOMANYREFS = 0x6d;
+	EPFNOSUPPORT = 0x60;
+	ENONET = 0x40;
+	EXFULL = 0x36;
+	EBADSLT = 0x39;
+	ENOTNAM = 0x76;
+	ELIBEXEC = 0x53;
+	ENOCSI = 0x32;
+	ENOTEMPTY = 0x27;
+	EADDRINUSE = 0x62;
+	ENETRESET = 0x66;
+	EISDIR = 0x15;
+	EIDRM = 0x2b;
+	ECOMM = 0x46;
+	EBADFD = 0x4d;
+	EL2HLT = 0x33;
+	ENOKEY = 0x7e;
+	EINVAL = 0x16;
+	ESHUTDOWN = 0x6c;
+	EKEYREJECTED = 0x81;
+	ELIBSCN = 0x51;
+	ENAVAIL = 0x77;
+	ENOSTR = 0x3c;
+	EOVERFLOW = 0x4b;
+	EUCLEAN = 0x75;
+	ENOMEDIUM = 0x7b;
+	EBUSY = 0x10;
+	EPROTO = 0x47;
+	ENODEV = 0x13;
+	EKEYEXPIRED = 0x7f;
+	EROFS = 0x1e;
+	ELIBACC = 0x4f;
+	E2BIG = 0x7;
+	EDEADLK = 0x23;
+	ECONNRESET = 0x68;
+	ENXIO = 0x6;
+	EBADRQC = 0x38;
+	ENAMETOOLONG = 0x24;
+	ESOCKTNOSUPPORT = 0x5e;
+	EDOTDOT = 0x49;
+	EADDRNOTAVAIL = 0x63;
+	ETIME = 0x3e;
+	EPROTONOSUPPORT = 0x5d;
+	ENOTRECOVERABLE = 0x83;
+	EIO = 0x5;
+	ENETUNREACH = 0x65;
+	EXDEV = 0x12;
+	EDQUOT = 0x7a;
+	EREMOTEIO = 0x79;
+	ENOSPC = 0x1c;
+	ENOEXEC = 0x8;
+	EMSGSIZE = 0x5a;
+	EDOM = 0x21;
+	EFBIG = 0x1b;
+	ESRCH = 0x3;
+	ECHRNG = 0x2c;
+	EHOSTDOWN = 0x70;
+	ENOLCK = 0x25;
+	ENFILE = 0x17;
+	ENOSYS = 0x26;
+	ENOTCONN = 0x6b;
+	ENOTSUP = 0x5f;
+	ESRMNT = 0x45;
+	EDEADLOCK = 0x23;
+	ECONNABORTED = 0x67;
+	ENOANO = 0x37;
+	EISCONN = 0x6a;
+	EUSERS = 0x57;
+	ENOPROTOOPT = 0x5c;
+	EMFILE = 0x18;
+	ENOBUFS = 0x69;
+	EL3HLT = 0x2e;
+	EFAULT = 0xe;
+	EWOULDBLOCK = 0xb;
+	ELIBBAD = 0x50;
+	ESTRPIPE = 0x56;
+	ECONNREFUSED = 0x6f;
+	EAGAIN = 0xb;
+	ELIBMAX = 0x52;
+	EEXIST = 0x11;
+	EL2NSYNC = 0x2d;
+	ENOENT = 0x2;
+	ENOPKG = 0x41;
+	EKEYREVOKED = 0x80;
+	EHOSTUNREACH = 0x71;
+	ENOTUNIQ = 0x4c;
+	EOPNOTSUPP = 0x5f;
+	ENOTDIR = 0x14;
+	EMEDIUMTYPE = 0x7c;
+	SIGBUS = 0x7;
+	SIGTTIN = 0x15;
+	SIGPROF = 0x1b;
+	SIGFPE = 0x8;
+	SIGHUP = 0x1;
+	SIGTTOU = 0x16;
+	SIGSTKFLT = 0x10;
+	SIGUSR1 = 0xa;
+	SIGURG = 0x17;
+	SIGQUIT = 0x3;
+	SIGCLD = 0x11;
+	SIGIO = 0x1d;
+	SIGABRT = 0x6;
+	SIGUSR2 = 0xc;
+	SIGTRAP = 0x5;
+	SIGVTALRM = 0x1a;
+	SIGPOLL = 0x1d;
+	SIGSEGV = 0xb;
+	SIGCONT = 0x12;
+	SIGPIPE = 0xd;
+	SIGWINCH = 0x1c;
+	SIGXFSZ = 0x19;
+	SIGCHLD = 0x11;
+	SIGSYS = 0x1f;
+	SIGSTOP = 0x13;
+	SIGALRM = 0xe;
+	SIGTSTP = 0x14;
+	SIGKILL = 0x9;
+	SIGXCPU = 0x18;
+	SIGUNUSED = 0x1f;
+	SIGPWR = 0x1e;
+	SIGILL = 0x4;
+	SIGINT = 0x2;
+	SIGIOT = 0x6;
+	SIGTERM = 0xf;
+)
+
+// Types
+
+
+// Error table
+var errors = [...]string {
+	72: "multihop attempted",
+	49: "protocol driver not attached",
+	97: "address family not supported by protocol",
+	78: "remote address changed",
+	13: "permission denied",
+	47: "level 3 reset",
+	89: "destination address required",
+	84: "invalid or incomplete multibyte or wide character",
+	29: "illegal seek",
+	31: "too many links",
+	130: "owner died",
+	25: "inappropriate ioctl for device",
+	52: "invalid exchange",
+	9: "bad file descriptor",
+	53: "invalid request descriptor",
+	68: "advertise error",
+	34: "numerical result out of range",
+	125: "operation canceled",
+	26: "text file busy",
+	12: "cannot allocate memory",
+	115: "operation now in progress",
+	15: "block device required",
+	91: "protocol wrong type for socket",
+	85: "interrupted system call should be restarted",
+	120: "is a named type file",
+	42: "no message of desired type",
+	114: "operation already in progress",
+	110: "connection timed out",
+	61: "no data available",
+	4: "interrupted system call",
+	67: "link has been severed",
+	1: "operation not permitted",
+	40: "too many levels of symbolic links",
+	100: "network is down",
+	116: "stale NFS file handle",
+	88: "socket operation on non-socket",
+	63: "out of streams resources",
+	10: "no child processes",
+	48: "link number out of range",
+	32: "broken pipe",
+	74: "bad message",
+	59: "bad font file format",
+	66: "object is remote",
+	109: "too many references: cannot splice",
+	96: "protocol family not supported",
+	64: "machine is not on the network",
+	54: "exchange full",
+	57: "invalid slot",
+	118: "not a XENIX named type file",
+	83: "cannot exec a shared library directly",
+	50: "no CSI structure available",
+	39: "directory not empty",
+	98: "address already in use",
+	102: "network dropped connection on reset",
+	21: "is a directory",
+	43: "identifier removed",
+	70: "communication error on send",
+	77: "file descriptor in bad state",
+	51: "level 2 halted",
+	126: "required key not available",
+	22: "invalid argument",
+	108: "cannot send after transport endpoint shutdown",
+	129: "key was rejected by service",
+	81: ".lib section in a.out corrupted",
+	119: "no XENIX semaphores available",
+	60: "device not a stream",
+	75: "value too large for defined data type",
+	117: "structure needs cleaning",
+	123: "no medium found",
+	16: "device or resource busy",
+	71: "protocol error",
+	19: "no such device",
+	127: "key has expired",
+	30: "read-only file system",
+	79: "can not access a needed shared library",
+	7: "argument list too long",
+	35: "resource deadlock avoided",
+	104: "connection reset by peer",
+	6: "no such device or address",
+	56: "invalid request code",
+	36: "file name too long",
+	94: "socket type not supported",
+	73: "RFS specific error",
+	99: "cannot assign requested address",
+	62: "timer expired",
+	93: "protocol not supported",
+	131: "state not recoverable",
+	5: "input/output error",
+	101: "network is unreachable",
+	18: "invalid cross-device link",
+	122: "disk quota exceeded",
+	121: "remote I/O error",
+	28: "no space left on device",
+	8: "exec format error",
+	90: "message too long",
+	33: "numerical argument out of domain",
+	27: "file too large",
+	3: "no such process",
+	44: "channel number out of range",
+	112: "host is down",
+	37: "no locks available",
+	23: "too many open files in system",
+	38: "function not implemented",
+	107: "transport endpoint is not connected",
+	95: "operation not supported",
+	69: "srmount error",
+	103: "software caused connection abort",
+	55: "no anode",
+	106: "transport endpoint is already connected",
+	87: "too many users",
+	92: "protocol not available",
+	24: "too many open files",
+	105: "no buffer space available",
+	46: "level 3 halted",
+	14: "bad address",
+	11: "resource temporarily unavailable",
+	80: "accessing a corrupted shared library",
+	86: "streams pipe error",
+	111: "connection refused",
+	82: "attempting to link in too many shared libraries",
+	17: "file exists",
+	45: "level 2 not synchronized",
+	2: "no such file or directory",
+	65: "package not installed",
+	128: "key has been revoked",
+	113: "no route to host",
+	76: "name not unique on network",
+	20: "not a directory",
+	124: "wrong medium type",
+}
+
diff --git a/src/pkg/syscall/zsyscall_linux_arm.go b/src/pkg/syscall/zsyscall_linux_arm.go
new file mode 100644
index 0000000000..8a37b13298
--- /dev/null
+++ b/src/pkg/syscall/zsyscall_linux_arm.go
@@ -0,0 +1,714 @@
+// mksyscall.sh -l32 syscall_linux.go syscall_linux_386.go
+// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
+
+package syscall
+
+import "unsafe"
+
+func pipe(p *[2]_C_int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func utimes(path string, times *[2]Timeval) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(times)), 0);
+	errno = int(e1);
+	return;
+}
+
+func futimesat(dirfd int, path string, times *[2]Timeval) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(times)));
+	errno = int(e1);
+	return;
+}
+
+func Getcwd(buf []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(buf) > 0 { _p0 = &buf[0]; }
+	r0, r1, e1 := Syscall(SYS_GETCWD, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, errno int) {
+	r0, r1, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0);
+	wpid = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func ptrace(request int, pid int, addr uintptr, data uintptr) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Access(path string, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Acct(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Adjtimex(buf *Timex) (state int, errno int) {
+	r0, r1, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0);
+	state = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Chdir(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Chmod(path string, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Chroot(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Close(fd int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Creat(path string, mode int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_CREAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Dup(oldfd int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0);
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Dup2(oldfd int, newfd int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0);
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func EpollCreate(size int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0);
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func EpollCtl(epfd int, op int, fd int, event *EpollEvent) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func EpollWait(epfd int, events []EpollEvent, msec int) (n int, errno int) {
+	var _p0 *EpollEvent;
+	if len(events) > 0 { _p0 = &events[0]; }
+	r0, r1, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(unsafe.Pointer(_p0)), uintptr(len(events)), uintptr(msec), 0, 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Exit(code int) () {
+	r0, r1, e1 := Syscall(SYS_EXIT_GROUP, uintptr(code), 0, 0);
+	return;
+}
+
+func Faccessat(dirfd int, path string, mode int, flags int) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(flags), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Fallocate(fd int, mode int, off int64, len int64) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(off >> 32), uintptr(len), uintptr(len >> 32));
+	errno = int(e1);
+	return;
+}
+
+func Fchdir(fd int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Fchmod(fd int, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Fchmodat(dirfd int, path string, mode int, flags int) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(flags), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Fchownat(dirfd int, path string, uid int, gid int, flags int) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid), uintptr(flags), 0);
+	errno = int(e1);
+	return;
+}
+
+func fcntl(fd int, cmd int, arg int) (val int, errno int) {
+	r0, r1, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg));
+	val = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Fdatasync(fd int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Fsync(fd int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Ftruncate(fd int, length int64) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length >> 32));
+	errno = int(e1);
+	return;
+}
+
+func Getdents(fd int, buf []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(buf) > 0 { _p0 = &buf[0]; }
+	r0, r1, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Getpgid(pid int) (pgid int, errno int) {
+	r0, r1, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0);
+	pgid = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Getpgrp() (pid int) {
+	r0, r1, e1 := Syscall(SYS_GETPGRP, 0, 0, 0);
+	pid = int(r0);
+	return;
+}
+
+func Getpid() (pid int) {
+	r0, r1, e1 := Syscall(SYS_GETPID, 0, 0, 0);
+	pid = int(r0);
+	return;
+}
+
+func Getppid() (ppid int) {
+	r0, r1, e1 := Syscall(SYS_GETPPID, 0, 0, 0);
+	ppid = int(r0);
+	return;
+}
+
+func Getrlimit(resource int, rlim *Rlimit) (errno int) {
+	r0, r1, e1 := Syscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Getrusage(who int, rusage *Rusage) (errno int) {
+	r0, r1, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Gettid() (tid int) {
+	r0, r1, e1 := Syscall(SYS_GETTID, 0, 0, 0);
+	tid = int(r0);
+	return;
+}
+
+func Gettimeofday(tv *Timeval) (errno int) {
+	r0, r1, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Ioperm(from int, num int, on int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on));
+	errno = int(e1);
+	return;
+}
+
+func Iopl(level int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Kill(pid int, sig int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(sig), 0);
+	errno = int(e1);
+	return;
+}
+
+func Klogctl(typ int, buf []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(buf) > 0 { _p0 = &buf[0]; }
+	r0, r1, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Link(oldpath string, newpath string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Mkdir(path string, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Mkdirat(dirfd int, path string, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode));
+	errno = int(e1);
+	return;
+}
+
+func Mknod(path string, mode int, dev int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev));
+	errno = int(e1);
+	return;
+}
+
+func Mknodat(dirfd int, path string, mode int, dev int) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Nanosleep(time *Timespec, leftover *Timespec) (errno int) {
+	r0, r1, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Open(path string, mode int, perm int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm));
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Openat(dirfd int, path string, flags int, mode int) (fd int, errno int) {
+	r0, r1, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), uintptr(mode), 0, 0);
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Pause() (errno int) {
+	r0, r1, e1 := Syscall(SYS_PAUSE, 0, 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func PivotRoot(newroot string, putold string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(StringBytePtr(newroot))), uintptr(unsafe.Pointer(StringBytePtr(putold))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Pread(fd int, p []byte, offset int64) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset >> 32), 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset >> 32), 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Read(fd int, p []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Readlink(path string, buf []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(buf) > 0 { _p0 = &buf[0]; }
+	r0, r1, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Rename(oldpath string, newpath string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(newdirfd), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Rmdir(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setdomainname(p []byte) (errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Sethostname(p []byte) (errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall(SYS_SETHOSTNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setpgid(pid int, pgid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setrlimit(resource int, rlim *Rlimit) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setsid() (pid int) {
+	r0, r1, e1 := Syscall(SYS_SETSID, 0, 0, 0);
+	pid = int(r0);
+	return;
+}
+
+func Settimeofday(tv *Timeval) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setuid(uid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, errno int) {
+	r0, r1, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags));
+	n = int64(int64(r1)<<32 | int64(r0));
+	return;
+}
+
+func Symlink(oldpath string, newpath string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Sync() () {
+	r0, r1, e1 := Syscall(SYS_SYNC, 0, 0, 0);
+	return;
+}
+
+func SyncFileRange(fd int, off int64, n int64, flags int) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(off >> 32), uintptr(n), uintptr(n >> 32), uintptr(flags));
+	errno = int(e1);
+	return;
+}
+
+func Sysinfo(info *Sysinfo_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Tee(rfd int, wfd int, len int, flags int) (n int64, errno int) {
+	r0, r1, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0);
+	n = int64(int64(r1)<<32 | int64(r0));
+	return;
+}
+
+func Tgkill(tgid int, tid int, sig int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig));
+	errno = int(e1);
+	return;
+}
+
+func Time(t *Time_t) (tt Time_t, errno int) {
+	r0, r1, e1 := Syscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0);
+	tt = Time_t(r0);
+	errno = int(e1);
+	return;
+}
+
+func Times(tms *Tms) (ticks uintptr, errno int) {
+	r0, r1, e1 := Syscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0);
+	ticks = uintptr(r0);
+	errno = int(e1);
+	return;
+}
+
+func Truncate(path string, length int64) (errno int) {
+	r0, r1, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), uintptr(length >> 32));
+	errno = int(e1);
+	return;
+}
+
+func Umask(mask int) (oldmask int) {
+	r0, r1, e1 := Syscall(SYS_UMASK, uintptr(mask), 0, 0);
+	oldmask = int(r0);
+	return;
+}
+
+func Uname(buf *Utsname) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Unlink(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Unlinkat(dirfd int, path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Unshare(flags int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Ustat(dev int, ubuf *Ustat_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Utime(path string, buf *Utimbuf) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(buf)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Write(fd int, p []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func exitThread(code int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func read(fd int, p *byte, np int) (n int, errno int) {
+	r0, r1, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func write(fd int, p *byte, np int) (n int, errno int) {
+	r0, r1, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Chown(path string, uid int, gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHOWN32, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
+	errno = int(e1);
+	return;
+}
+
+func Fchown(fd int, uid int, gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FCHOWN32, uintptr(fd), uintptr(uid), uintptr(gid));
+	errno = int(e1);
+	return;
+}
+
+func Fstat(fd int, stat *Stat_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Fstatfs(fd int, buf *Statfs_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FSTATFS64, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Getegid() (egid int) {
+	r0, r1, e1 := Syscall(SYS_GETEGID32, 0, 0, 0);
+	egid = int(r0);
+	return;
+}
+
+func Geteuid() (euid int) {
+	r0, r1, e1 := Syscall(SYS_GETEUID32, 0, 0, 0);
+	euid = int(r0);
+	return;
+}
+
+func Getgid() (gid int) {
+	r0, r1, e1 := Syscall(SYS_GETGID32, 0, 0, 0);
+	gid = int(r0);
+	return;
+}
+
+func Getuid() (uid int) {
+	r0, r1, e1 := Syscall(SYS_GETUID32, 0, 0, 0);
+	uid = int(r0);
+	return;
+}
+
+func Lchown(path string, uid int, gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_LCHOWN32, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
+	errno = int(e1);
+	return;
+}
+
+func Lstat(path string, stat *Stat_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setfsgid(gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETFSGID32, uintptr(gid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setfsuid(uid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETFSUID32, uintptr(uid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setgid(gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETGID32, uintptr(gid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setregid(rgid int, egid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETREGID32, uintptr(rgid), uintptr(egid), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setresgid(rgid int, egid int, sgid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETRESGID32, uintptr(rgid), uintptr(egid), uintptr(sgid));
+	errno = int(e1);
+	return;
+}
+
+func Setresuid(ruid int, euid int, suid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETRESUID32, uintptr(ruid), uintptr(euid), uintptr(suid));
+	errno = int(e1);
+	return;
+}
+
+func Setreuid(ruid int, euid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETREUID32, uintptr(ruid), uintptr(euid), 0);
+	errno = int(e1);
+	return;
+}
+
+func Stat(path string, stat *Stat_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Statfs(path string, buf *Statfs_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(buf)), 0);
+	errno = int(e1);
+	return;
+}
+
+func getgroups(n int, list *_Gid_t) (nn int, errno int) {
+	r0, r1, e1 := Syscall(SYS_GETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0);
+	nn = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func setgroups(n int, list *_Gid_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, errno int) {
+	r0, r1, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+
+
diff --git a/src/pkg/syscall/zsysnum_linux_arm.go b/src/pkg/syscall/zsysnum_linux_arm.go
new file mode 100644
index 0000000000..4ff1102816
--- /dev/null
+++ b/src/pkg/syscall/zsysnum_linux_arm.go
@@ -0,0 +1,319 @@
+// mksysnum_linux.sh /usr/include/asm/unistd_32.h
+// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT
+
+package syscall
+
+const(
+	SYS_RESTART_SYSCALL = 0;
+	SYS_EXIT = 1;
+	SYS_FORK = 2;
+	SYS_READ = 3;
+	SYS_WRITE = 4;
+	SYS_OPEN = 5;
+	SYS_CLOSE = 6;
+	SYS_WAITPID = 7;
+	SYS_CREAT = 8;
+	SYS_LINK = 9;
+	SYS_UNLINK = 10;
+	SYS_EXECVE = 11;
+	SYS_CHDIR = 12;
+	SYS_TIME = 13;
+	SYS_MKNOD = 14;
+	SYS_CHMOD = 15;
+	SYS_LCHOWN = 16;
+	SYS_BREAK = 17;
+	SYS_OLDSTAT = 18;
+	SYS_LSEEK = 19;
+	SYS_GETPID = 20;
+	SYS_MOUNT = 21;
+	SYS_UMOUNT = 22;
+	SYS_SETUID = 23;
+	SYS_GETUID = 24;
+	SYS_STIME = 25;
+	SYS_PTRACE = 26;
+	SYS_ALARM = 27;
+	SYS_OLDFSTAT = 28;
+	SYS_PAUSE = 29;
+	SYS_UTIME = 30;
+	SYS_STTY = 31;
+	SYS_GTTY = 32;
+	SYS_ACCESS = 33;
+	SYS_NICE = 34;
+	SYS_FTIME = 35;
+	SYS_SYNC = 36;
+	SYS_KILL = 37;
+	SYS_RENAME = 38;
+	SYS_MKDIR = 39;
+	SYS_RMDIR = 40;
+	SYS_DUP = 41;
+	SYS_PIPE = 42;
+	SYS_TIMES = 43;
+	SYS_PROF = 44;
+	SYS_BRK = 45;
+	SYS_SETGID = 46;
+	SYS_GETGID = 47;
+	SYS_SIGNAL = 48;
+	SYS_GETEUID = 49;
+	SYS_GETEGID = 50;
+	SYS_ACCT = 51;
+	SYS_UMOUNT2 = 52;
+	SYS_LOCK = 53;
+	SYS_IOCTL = 54;
+	SYS_FCNTL = 55;
+	SYS_MPX = 56;
+	SYS_SETPGID = 57;
+	SYS_ULIMIT = 58;
+	SYS_OLDOLDUNAME = 59;
+	SYS_UMASK = 60;
+	SYS_CHROOT = 61;
+	SYS_USTAT = 62;
+	SYS_DUP2 = 63;
+	SYS_GETPPID = 64;
+	SYS_GETPGRP = 65;
+	SYS_SETSID = 66;
+	SYS_SIGACTION = 67;
+	SYS_SGETMASK = 68;
+	SYS_SSETMASK = 69;
+	SYS_SETREUID = 70;
+	SYS_SETREGID = 71;
+	SYS_SIGSUSPEND = 72;
+	SYS_SIGPENDING = 73;
+	SYS_SETHOSTNAME = 74;
+	SYS_SETRLIMIT = 75;
+	SYS_GETRLIMIT = 76;
+	SYS_GETRUSAGE = 77;
+	SYS_GETTIMEOFDAY = 78;
+	SYS_SETTIMEOFDAY = 79;
+	SYS_GETGROUPS = 80;
+	SYS_SETGROUPS = 81;
+	SYS_SELECT = 82;
+	SYS_SYMLINK = 83;
+	SYS_OLDLSTAT = 84;
+	SYS_READLINK = 85;
+	SYS_USELIB = 86;
+	SYS_SWAPON = 87;
+	SYS_REBOOT = 88;
+	SYS_READDIR = 89;
+	SYS_MMAP = 90;
+	SYS_MUNMAP = 91;
+	SYS_TRUNCATE = 92;
+	SYS_FTRUNCATE = 93;
+	SYS_FCHMOD = 94;
+	SYS_FCHOWN = 95;
+	SYS_GETPRIORITY = 96;
+	SYS_SETPRIORITY = 97;
+	SYS_PROFIL = 98;
+	SYS_STATFS = 99;
+	SYS_FSTATFS = 100;
+	SYS_IOPERM = 101;
+	SYS_SOCKETCALL = 102;
+	SYS_SYSLOG = 103;
+	SYS_SETITIMER = 104;
+	SYS_GETITIMER = 105;
+	SYS_STAT = 106;
+	SYS_LSTAT = 107;
+	SYS_FSTAT = 108;
+	SYS_OLDUNAME = 109;
+	SYS_IOPL = 110;
+	SYS_VHANGUP = 111;
+	SYS_IDLE = 112;
+	SYS_VM86OLD = 113;
+	SYS_WAIT4 = 114;
+	SYS_SWAPOFF = 115;
+	SYS_SYSINFO = 116;
+	SYS_IPC = 117;
+	SYS_FSYNC = 118;
+	SYS_SIGRETURN = 119;
+	SYS_CLONE = 120;
+	SYS_SETDOMAINNAME = 121;
+	SYS_UNAME = 122;
+	SYS_MODIFY_LDT = 123;
+	SYS_ADJTIMEX = 124;
+	SYS_MPROTECT = 125;
+	SYS_SIGPROCMASK = 126;
+	SYS_CREATE_MODULE = 127;
+	SYS_INIT_MODULE = 128;
+	SYS_DELETE_MODULE = 129;
+	SYS_GET_KERNEL_SYMS = 130;
+	SYS_QUOTACTL = 131;
+	SYS_GETPGID = 132;
+	SYS_FCHDIR = 133;
+	SYS_BDFLUSH = 134;
+	SYS_SYSFS = 135;
+	SYS_PERSONALITY = 136;
+	SYS_AFS_SYSCALL = 137;
+	SYS_SETFSUID = 138;
+	SYS_SETFSGID = 139;
+	SYS__LLSEEK = 140;
+	SYS_GETDENTS = 141;
+	SYS__NEWSELECT = 142;
+	SYS_FLOCK = 143;
+	SYS_MSYNC = 144;
+	SYS_READV = 145;
+	SYS_WRITEV = 146;
+	SYS_GETSID = 147;
+	SYS_FDATASYNC = 148;
+	SYS__SYSCTL = 149;
+	SYS_MLOCK = 150;
+	SYS_MUNLOCK = 151;
+	SYS_MLOCKALL = 152;
+	SYS_MUNLOCKALL = 153;
+	SYS_SCHED_SETPARAM = 154;
+	SYS_SCHED_GETPARAM = 155;
+	SYS_SCHED_SETSCHEDULER = 156;
+	SYS_SCHED_GETSCHEDULER = 157;
+	SYS_SCHED_YIELD = 158;
+	SYS_SCHED_GET_PRIORITY_MAX = 159;
+	SYS_SCHED_GET_PRIORITY_MIN = 160;
+	SYS_SCHED_RR_GET_INTERVAL = 161;
+	SYS_NANOSLEEP = 162;
+	SYS_MREMAP = 163;
+	SYS_SETRESUID = 164;
+	SYS_GETRESUID = 165;
+	SYS_VM86 = 166;
+	SYS_QUERY_MODULE = 167;
+	SYS_POLL = 168;
+	SYS_NFSSERVCTL = 169;
+	SYS_SETRESGID = 170;
+	SYS_GETRESGID = 171;
+	SYS_PRCTL = 172;
+	SYS_RT_SIGRETURN = 173;
+	SYS_RT_SIGACTION = 174;
+	SYS_RT_SIGPROCMASK = 175;
+	SYS_RT_SIGPENDING = 176;
+	SYS_RT_SIGTIMEDWAIT = 177;
+	SYS_RT_SIGQUEUEINFO = 178;
+	SYS_RT_SIGSUSPEND = 179;
+	SYS_PREAD64 = 180;
+	SYS_PWRITE64 = 181;
+	SYS_CHOWN = 182;
+	SYS_GETCWD = 183;
+	SYS_CAPGET = 184;
+	SYS_CAPSET = 185;
+	SYS_SIGALTSTACK = 186;
+	SYS_SENDFILE = 187;
+	SYS_GETPMSG = 188;
+	SYS_PUTPMSG = 189;
+	SYS_VFORK = 190;
+	SYS_UGETRLIMIT = 191;
+	SYS_MMAP2 = 192;
+	SYS_TRUNCATE64 = 193;
+	SYS_FTRUNCATE64 = 194;
+	SYS_STAT64 = 195;
+	SYS_LSTAT64 = 196;
+	SYS_FSTAT64 = 197;
+	SYS_LCHOWN32 = 198;
+	SYS_GETUID32 = 199;
+	SYS_GETGID32 = 200;
+	SYS_GETEUID32 = 201;
+	SYS_GETEGID32 = 202;
+	SYS_SETREUID32 = 203;
+	SYS_SETREGID32 = 204;
+	SYS_GETGROUPS32 = 205;
+	SYS_SETGROUPS32 = 206;
+	SYS_FCHOWN32 = 207;
+	SYS_SETRESUID32 = 208;
+	SYS_GETRESUID32 = 209;
+	SYS_SETRESGID32 = 210;
+	SYS_GETRESGID32 = 211;
+	SYS_CHOWN32 = 212;
+	SYS_SETUID32 = 213;
+	SYS_SETGID32 = 214;
+	SYS_SETFSUID32 = 215;
+	SYS_SETFSGID32 = 216;
+	SYS_PIVOT_ROOT = 217;
+	SYS_MINCORE = 218;
+	SYS_MADVISE = 219;
+	SYS_MADVISE1 = 219;
+	SYS_GETDENTS64 = 220;
+	SYS_FCNTL64 = 221;
+	SYS_GETTID = 224;
+	SYS_READAHEAD = 225;
+	SYS_SETXATTR = 226;
+	SYS_LSETXATTR = 227;
+	SYS_FSETXATTR = 228;
+	SYS_GETXATTR = 229;
+	SYS_LGETXATTR = 230;
+	SYS_FGETXATTR = 231;
+	SYS_LISTXATTR = 232;
+	SYS_LLISTXATTR = 233;
+	SYS_FLISTXATTR = 234;
+	SYS_REMOVEXATTR = 235;
+	SYS_LREMOVEXATTR = 236;
+	SYS_FREMOVEXATTR = 237;
+	SYS_TKILL = 238;
+	SYS_SENDFILE64 = 239;
+	SYS_FUTEX = 240;
+	SYS_SCHED_SETAFFINITY = 241;
+	SYS_SCHED_GETAFFINITY = 242;
+	SYS_SET_THREAD_AREA = 243;
+	SYS_GET_THREAD_AREA = 244;
+	SYS_IO_SETUP = 245;
+	SYS_IO_DESTROY = 246;
+	SYS_IO_GETEVENTS = 247;
+	SYS_IO_SUBMIT = 248;
+	SYS_IO_CANCEL = 249;
+	SYS_FADVISE64 = 250;
+	SYS_EXIT_GROUP = 252;
+	SYS_LOOKUP_DCOOKIE = 253;
+	SYS_EPOLL_CREATE = 254;
+	SYS_EPOLL_CTL = 255;
+	SYS_EPOLL_WAIT = 256;
+	SYS_REMAP_FILE_PAGES = 257;
+	SYS_SET_TID_ADDRESS = 258;
+	SYS_TIMER_CREATE = 259;
+	SYS_STATFS64 = 268;
+	SYS_FSTATFS64 = 269;
+	SYS_TGKILL = 270;
+	SYS_UTIMES = 271;
+	SYS_FADVISE64_64 = 272;
+	SYS_VSERVER = 273;
+	SYS_MBIND = 274;
+	SYS_GET_MEMPOLICY = 275;
+	SYS_SET_MEMPOLICY = 276;
+	SYS_MQ_OPEN = 277;
+	SYS_KEXEC_LOAD = 283;
+	SYS_WAITID = 284;
+	SYS_ADD_KEY = 286;
+	SYS_REQUEST_KEY = 287;
+	SYS_KEYCTL = 288;
+	SYS_IOPRIO_SET = 289;
+	SYS_IOPRIO_GET = 290;
+	SYS_INOTIFY_INIT = 291;
+	SYS_INOTIFY_ADD_WATCH = 292;
+	SYS_INOTIFY_RM_WATCH = 293;
+	SYS_MIGRATE_PAGES = 294;
+	SYS_OPENAT = 295;
+	SYS_MKDIRAT = 296;
+	SYS_MKNODAT = 297;
+	SYS_FCHOWNAT = 298;
+	SYS_FUTIMESAT = 299;
+	SYS_FSTATAT64 = 300;
+	SYS_UNLINKAT = 301;
+	SYS_RENAMEAT = 302;
+	SYS_LINKAT = 303;
+	SYS_SYMLINKAT = 304;
+	SYS_READLINKAT = 305;
+	SYS_FCHMODAT = 306;
+	SYS_FACCESSAT = 307;
+	SYS_PSELECT6 = 308;
+	SYS_PPOLL = 309;
+	SYS_UNSHARE = 310;
+	SYS_SET_ROBUST_LIST = 311;
+	SYS_GET_ROBUST_LIST = 312;
+	SYS_SPLICE = 313;
+	SYS_SYNC_FILE_RANGE = 314;
+	SYS_TEE = 315;
+	SYS_VMSPLICE = 316;
+	SYS_MOVE_PAGES = 317;
+	SYS_GETCPU = 318;
+	SYS_EPOLL_PWAIT = 319;
+	SYS_UTIMENSAT = 320;
+	SYS_SIGNALFD = 321;
+	SYS_TIMERFD = 322;
+	SYS_EVENTFD = 323;
+	SYS_FALLOCATE = 324;
+)
+
+func _darwin_system_call_conflict() {
+}
diff --git a/src/pkg/syscall/ztypes_linux_arm.go b/src/pkg/syscall/ztypes_linux_arm.go
new file mode 100644
index 0000000000..a3b1e6b79a
--- /dev/null
+++ b/src/pkg/syscall/ztypes_linux_arm.go
@@ -0,0 +1,368 @@
+// godefs -gsyscall -f-m32 types_linux.c types_linux_386.c
+
+// MACHINE GENERATED - DO NOT EDIT.
+
+package syscall
+
+// Constants
+const (
+	sizeofPtr = 0x4;
+	sizeofShort = 0x2;
+	sizeofInt = 0x4;
+	sizeofLong = 0x4;
+	sizeofLongLong = 0x8;
+	PathMax = 0x1000;
+	O_RDONLY = 0;
+	O_WRONLY = 0x1;
+	O_RDWR = 0x2;
+	O_APPEND = 0x400;
+	O_ASYNC = 0x2000;
+	O_CREAT = 0x40;
+	O_NOCTTY = 0x100;
+	O_NONBLOCK = 0x800;
+	O_SYNC = 0x1000;
+	O_TRUNC = 0x200;
+	O_CLOEXEC = 0;
+	F_GETFD = 0x1;
+	F_SETFD = 0x2;
+	F_GETFL = 0x3;
+	F_SETFL = 0x4;
+	FD_CLOEXEC = 0x1;
+	NAME_MAX = 0xff;
+	S_IFMT = 0xf000;
+	S_IFIFO = 0x1000;
+	S_IFCHR = 0x2000;
+	S_IFDIR = 0x4000;
+	S_IFBLK = 0x6000;
+	S_IFREG = 0x8000;
+	S_IFLNK = 0xa000;
+	S_IFSOCK = 0xc000;
+	S_ISUID = 0x800;
+	S_ISGID = 0x400;
+	S_ISVTX = 0x200;
+	S_IRUSR = 0x100;
+	S_IWUSR = 0x80;
+	S_IXUSR = 0x40;
+	WNOHANG = 0x1;
+	WUNTRACED = 0x2;
+	WEXITED = 0x4;
+	WSTOPPED = 0x2;
+	WCONTINUED = 0x8;
+	WNOWAIT = 0x1000000;
+	WCLONE = 0x80000000;
+	WALL = 0x40000000;
+	WNOTHREAD = 0x20000000;
+	AF_UNIX = 0x1;
+	AF_INET = 0x2;
+	AF_INET6 = 0xa;
+	SOCK_STREAM = 0x1;
+	SOCK_DGRAM = 0x2;
+	SOCK_RAW = 0x3;
+	SOCK_SEQPACKET = 0x5;
+	SOL_SOCKET = 0x1;
+	SO_REUSEADDR = 0x2;
+	SO_KEEPALIVE = 0x9;
+	SO_DONTROUTE = 0x5;
+	SO_BROADCAST = 0x6;
+	SO_LINGER = 0xd;
+	SO_SNDBUF = 0x7;
+	SO_RCVBUF = 0x8;
+	SO_SNDTIMEO = 0x15;
+	SO_RCVTIMEO = 0x14;
+	IPPROTO_TCP = 0x6;
+	IPPROTO_UDP = 0x11;
+	TCP_NODELAY = 0x1;
+	SOMAXCONN = 0x80;
+	SizeofSockaddrInet4 = 0x10;
+	SizeofSockaddrInet6 = 0x1c;
+	SizeofSockaddrAny = 0x1c;
+	SizeofSockaddrUnix = 0x6e;
+	_PTRACE_TRACEME = 0;
+	_PTRACE_PEEKTEXT = 0x1;
+	_PTRACE_PEEKDATA = 0x2;
+	_PTRACE_PEEKUSER = 0x3;
+	_PTRACE_POKETEXT = 0x4;
+	_PTRACE_POKEDATA = 0x5;
+	_PTRACE_POKEUSER = 0x6;
+	_PTRACE_CONT = 0x7;
+	_PTRACE_KILL = 0x8;
+	_PTRACE_SINGLESTEP = 0x9;
+	_PTRACE_GETREGS = 0xc;
+	_PTRACE_SETREGS = 0xd;
+	_PTRACE_GETFPREGS = 0xe;
+	_PTRACE_SETFPREGS = 0xf;
+	_PTRACE_ATTACH = 0x10;
+	_PTRACE_DETACH = 0x11;
+	_PTRACE_GETFPXREGS = 0x12;
+	_PTRACE_SETFPXREGS = 0x13;
+	_PTRACE_SYSCALL = 0x18;
+	_PTRACE_SETOPTIONS = 0x4200;
+	_PTRACE_GETEVENTMSG = 0x4201;
+	_PTRACE_GETSIGINFO = 0x4202;
+	_PTRACE_SETSIGINFO = 0x4203;
+	PTRACE_O_TRACESYSGOOD = 0x1;
+	PTRACE_O_TRACEFORK = 0x2;
+	PTRACE_O_TRACEVFORK = 0x4;
+	PTRACE_O_TRACECLONE = 0x8;
+	PTRACE_O_TRACEEXEC = 0x10;
+	PTRACE_O_TRACEVFORKDONE = 0x20;
+	PTRACE_O_TRACEEXIT = 0x40;
+	PTRACE_O_MASK = 0x7f;
+	PTRACE_EVENT_FORK = 0x1;
+	PTRACE_EVENT_VFORK = 0x2;
+	PTRACE_EVENT_CLONE = 0x3;
+	PTRACE_EVENT_EXEC = 0x4;
+	PTRACE_EVENT_VFORK_DONE = 0x5;
+	PTRACE_EVENT_EXIT = 0x6;
+	EPOLLIN = 0x1;
+	EPOLLRDHUP = 0x2000;
+	EPOLLOUT = 0x4;
+	EPOLLONESHOT = 0x40000000;
+	EPOLL_CTL_MOD = 0x3;
+	EPOLL_CTL_ADD = 0x1;
+	EPOLL_CTL_DEL = 0x2;
+)
+
+// Types
+
+type _C_short int16
+
+type _C_int int32
+
+type _C_long int32
+
+type _C_long_long int64
+
+type Timespec struct {
+	Sec int32;
+	Nsec int32;
+}
+
+type Timeval struct {
+	Sec int32;
+	Usec int32;
+}
+
+type Timex struct {
+	Modes uint32;
+	Offset int32;
+	Freq int32;
+	Maxerror int32;
+	Esterror int32;
+	Status int32;
+	Constant int32;
+	Precision int32;
+	Tolerance int32;
+	Time Timeval;
+	Tick int32;
+	Ppsfreq int32;
+	Jitter int32;
+	Shift int32;
+	Stabil int32;
+	Jitcnt int32;
+	Calcnt int32;
+	Errcnt int32;
+	Stbcnt int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+}
+
+type Time_t int32
+
+type Tms struct {
+	Utime int32;
+	Stime int32;
+	Cutime int32;
+	Cstime int32;
+}
+
+type Utimbuf struct {
+	Actime int32;
+	Modtime int32;
+}
+
+type Rusage struct {
+	Utime Timeval;
+	Stime Timeval;
+	Maxrss int32;
+	Ixrss int32;
+	Idrss int32;
+	Isrss int32;
+	Minflt int32;
+	Majflt int32;
+	Nswap int32;
+	Inblock int32;
+	Oublock int32;
+	Msgsnd int32;
+	Msgrcv int32;
+	Nsignals int32;
+	Nvcsw int32;
+	Nivcsw int32;
+}
+
+type Rlimit struct {
+	Cur uint64;
+	Max uint64;
+}
+
+type _Gid_t uint32
+
+type Stat_t struct {
+	Dev uint64;
+	__pad1 uint16;
+	Pad0 [2]byte;
+	__st_ino uint32;
+	Mode uint32;
+	Nlink uint32;
+	Uid uint32;
+	Gid uint32;
+	Rdev uint64;
+	__pad2 uint16;
+	Pad1 [2]byte;
+	Size int64;
+	Blksize int32;
+	Blocks int64;
+	Atim Timespec;
+	Mtim Timespec;
+	Ctim Timespec;
+	Ino uint64;
+}
+
+type Statfs_t struct {
+	Type int32;
+	Bsize int32;
+	Blocks uint64;
+	Bfree uint64;
+	Bavail uint64;
+	Files uint64;
+	Ffree uint64;
+	Fsid [8]byte /* __fsid_t */;
+	Namelen int32;
+	Frsize int32;
+	Spare [5]int32;
+}
+
+type Dirent struct {
+	Ino uint64;
+	Off int64;
+	Reclen uint16;
+	Type uint8;
+	Name [256]int8;
+	Pad0 [1]byte;
+}
+
+type RawSockaddrInet4 struct {
+	Family uint16;
+	Port uint16;
+	Addr [4]byte /* in_addr */;
+	Zero [8]uint8;
+}
+
+type RawSockaddrInet6 struct {
+	Family uint16;
+	Port uint16;
+	Flowinfo uint32;
+	Addr [16]byte /* in6_addr */;
+	Scope_id uint32;
+}
+
+type RawSockaddrUnix struct {
+	Family uint16;
+	Path [108]int8;
+}
+
+type RawSockaddr struct {
+	Family uint16;
+	Data [14]int8;
+}
+
+type RawSockaddrAny struct {
+	Addr RawSockaddr;
+	Pad [12]int8;
+}
+
+type _Socklen uint32
+
+type Linger struct {
+	Onoff int32;
+	Linger int32;
+}
+
+type PtraceRegs struct {
+	Ebx int32;
+	Ecx int32;
+	Edx int32;
+	Esi int32;
+	Edi int32;
+	Ebp int32;
+	Eax int32;
+	Ds uint16;
+	__ds uint16;
+	Es uint16;
+	__es uint16;
+	Fs uint16;
+	__fs uint16;
+	Gs uint16;
+	__gs uint16;
+	Eax int32;
+	Eip int32;
+	Cs uint16;
+	__cs uint16;
+	Eflags int32;
+	Esp int32;
+	Ss uint16;
+	__ss uint16;
+}
+
+type FdSet struct {
+	Bits [32]int32;
+}
+
+type Sysinfo_t struct {
+	Uptime int32;
+	Loads [3]uint32;
+	Totalram uint32;
+	Freeram uint32;
+	Sharedram uint32;
+	Bufferram uint32;
+	Totalswap uint32;
+	Freeswap uint32;
+	Procs uint16;
+	Pad uint16;
+	Totalhigh uint32;
+	Freehigh uint32;
+	Unit uint32;
+	_f [8]int8;
+}
+
+type Utsname struct {
+	Sysname [65]int8;
+	Nodename [65]int8;
+	Release [65]int8;
+	Version [65]int8;
+	Machine [65]int8;
+	Domainname [65]int8;
+}
+
+type Ustat_t struct {
+	Tfree int32;
+	Tinode uint32;
+	Fname [6]int8;
+	Fpack [6]int8;
+}
+
+type EpollEvent struct {
+	Events uint32;
+	Fd int32;
+	Pad int32;
+}
