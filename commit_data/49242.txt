commit fe73f28dc5e22ab6b54b7433dd6e63caf5c9da72
Author: Matthew Dempsky <mdempsky@google.com>
Date:   Tue Aug 3 10:37:33 2021 -0700

    [dev.typeparams] cmd/compile: set sym.Def to ir.Name for method value wrappers
    
    The code for generating method value wrappers is weird that it sets
    sym.Def to the generated ir.Func, whereas normally sym.Def points to
    ir.Name.
    
    While here, change methodValueWrapper to return the ir.Name too, since
    that's what the caller wants.
    
    Change-Id: I3da5320ca0bf4d32d7b420345454f19075d19a26
    Reviewed-on: https://go-review.googlesource.com/c/go/+/339410
    Trust: Matthew Dempsky <mdempsky@google.com>
    Trust: Cuong Manh Le <cuong.manhle.vn@gmail.com>
    Run-TryBot: Matthew Dempsky <mdempsky@google.com>
    TryBot-Result: Go Bot <gobot@golang.org>
    Reviewed-by: Cuong Manh Le <cuong.manhle.vn@gmail.com>
---
 src/cmd/compile/internal/noder/reader.go |  2 +-
 src/cmd/compile/internal/walk/closure.go | 12 ++++++------
 2 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/src/cmd/compile/internal/noder/reader.go b/src/cmd/compile/internal/noder/reader.go
index 516bf8f1f7..83979a91c8 100644
--- a/src/cmd/compile/internal/noder/reader.go
+++ b/src/cmd/compile/internal/noder/reader.go
@@ -2253,7 +2253,7 @@ func (r *reader) methodValueWrapper(tbase *types.Type, method *types.Field, targ
 	pos := base.AutogeneratedPos
 
 	fn := r.newWrapperFunc(pos, sym, nil, method)
-	sym.Def = fn
+	sym.Def = fn.Nname
 
 	// Declare and initialize variable holding receiver.
 	recv := ir.NewHiddenParam(pos, fn, typecheck.Lookup(".this"), recvType)
diff --git a/src/cmd/compile/internal/walk/closure.go b/src/cmd/compile/internal/walk/closure.go
index 2d0b2dcc0e..902e01ef38 100644
--- a/src/cmd/compile/internal/walk/closure.go
+++ b/src/cmd/compile/internal/walk/closure.go
@@ -179,7 +179,7 @@ func walkMethodValue(n *ir.SelectorExpr, init *ir.Nodes) ir.Node {
 
 	clos := ir.NewCompLitExpr(base.Pos, ir.OCOMPLIT, ir.TypeNode(typ), nil)
 	clos.SetEsc(n.Esc())
-	clos.List = []ir.Node{ir.NewUnaryExpr(base.Pos, ir.OCFUNC, methodValueWrapper(n).Nname), n.X}
+	clos.List = []ir.Node{ir.NewUnaryExpr(base.Pos, ir.OCFUNC, methodValueWrapper(n)), n.X}
 
 	addr := typecheck.NodAddr(clos)
 	addr.SetEsc(n.Esc())
@@ -199,11 +199,11 @@ func walkMethodValue(n *ir.SelectorExpr, init *ir.Nodes) ir.Node {
 	return walkExpr(cfn, init)
 }
 
-// methodValueWrapper returns the DCLFUNC node representing the
+// methodValueWrapper returns the ONAME node representing the
 // wrapper function (*-fm) needed for the given method value. If the
 // wrapper function hasn't already been created yet, it's created and
 // added to typecheck.Target.Decls.
-func methodValueWrapper(dot *ir.SelectorExpr) *ir.Func {
+func methodValueWrapper(dot *ir.SelectorExpr) *ir.Name {
 	if dot.Op() != ir.OMETHVALUE {
 		base.Fatalf("methodValueWrapper: unexpected %v (%v)", dot, dot.Op())
 	}
@@ -214,7 +214,7 @@ func methodValueWrapper(dot *ir.SelectorExpr) *ir.Func {
 	sym := ir.MethodSymSuffix(rcvrtype, meth, "-fm")
 
 	if sym.Uniq() {
-		return sym.Def.(*ir.Func)
+		return sym.Def.(*ir.Name)
 	}
 	sym.SetUniq(true)
 
@@ -262,10 +262,10 @@ func methodValueWrapper(dot *ir.SelectorExpr) *ir.Func {
 	// typecheckslice() requires that Curfn is set when processing an ORETURN.
 	ir.CurFunc = fn
 	typecheck.Stmts(fn.Body)
-	sym.Def = fn
+	sym.Def = fn.Nname
 	typecheck.Target.Decls = append(typecheck.Target.Decls, fn)
 	ir.CurFunc = savecurfn
 	base.Pos = saveLineNo
 
-	return fn
+	return fn.Nname
 }
