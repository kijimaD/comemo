commit 6d7cb594b358b9b22709fb7a7940abc4c9778074
Author: Michael Anthony Knyszek <mknyszek@google.com>
Date:   Fri Feb 14 18:39:29 2025 +0000

    weak: accept linker-allocated objects to Make
    
    Currently Make panics when passed a linker-allocated object. This is
    inconsistent with both runtime.AddCleanup and runtime.SetFinalizer. Not
    panicking in this case is important so that all pointers can be treated
    equally by these APIs. Libraries should not have to worry where a
    pointer came from to still make weak pointers.
    
    Supporting this behavior is a bit complex for weak pointers versus
    finalizers and cleanups. For the latter two, it means a function is
    never called, so we can just drop everything on the floor. For weak
    pointers, we still need to produce pointers that compare as per the API.
    To do this, copy the tiny lock-free trace map implementation and use it
    to store weak handles for "immortal" objects. These paths in the
    runtime should be rare, so it's OK if it's not incredibly fast, but we
    should keep the memory footprint relatively low (at least not have it be
    any worse than specials), so this change tweaks the map implementation a
    little bit to ensure that's the case.
    
    Fixes #71726.
    
    Change-Id: I0c87c9d90656d81659ac8d70f511773d0093ce27
    Reviewed-on: https://go-review.googlesource.com/c/go/+/649460
    Reviewed-by: Cherry Mui <cherryyz@google.com>
    Auto-Submit: Michael Knyszek <mknyszek@google.com>
    LUCI-TryBot-Result: Go LUCI <golang-scoped@luci-project-accounts.iam.gserviceaccount.com>

 src/runtime/mheap.go     | 92 +++++++++++++++++++++++++++++++++++++++++++++++-
 src/weak/pointer_test.go | 39 ++++++++++++++++++++
 2 files changed, 130 insertions(+), 1 deletion(-)
