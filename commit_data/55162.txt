commit d45df06663c88984b75052fd0631974916b1bddb
Author: Robert Griesemer <gri@golang.org>
Date:   Thu Jan 12 11:44:48 2023 -0800

    go/types, types2: more uses of factored functions; generate object_test.go
    
    Change-Id: I7a8366f7dcbd68770b723247ce3e7e81716a8e49
    Reviewed-on: https://go-review.googlesource.com/c/go/+/461680
    Reviewed-by: Robert Findley <rfindley@google.com>
    Reviewed-by: Robert Griesemer <gri@google.com>
    Auto-Submit: Robert Griesemer <gri@google.com>
    Run-TryBot: Robert Griesemer <gri@google.com>
    TryBot-Result: Gopher Robot <gobot@golang.org>
---
 src/cmd/compile/internal/types2/issues_test.go | 13 +++-------
 src/cmd/compile/internal/types2/object_test.go | 10 +------
 src/go/types/generator.go                      |  1 +
 src/go/types/issues_test.go                    | 13 +++-------
 src/go/types/object_test.go                    | 36 ++++++++++----------------
 5 files changed, 22 insertions(+), 51 deletions(-)

diff --git a/src/cmd/compile/internal/types2/issues_test.go b/src/cmd/compile/internal/types2/issues_test.go
index 0ea5df5d5b..1333870dc9 100644
--- a/src/cmd/compile/internal/types2/issues_test.go
+++ b/src/cmd/compile/internal/types2/issues_test.go
@@ -19,9 +19,7 @@ import (
 )
 
 func TestIssue5770(t *testing.T) {
-	f := mustParse("", `package p; type S struct{T}`)
-	var conf Config
-	_, err := conf.Check(f.PkgName.Value, []*syntax.File{f}, nil) // do not crash
+	_, err := typecheck("p", `package p; type S struct{T}`, nil)
 	const want = "undefined: T"
 	if err == nil || !strings.Contains(err.Error(), want) {
 		t.Errorf("got: %v; want: %s", err, want)
@@ -231,13 +229,8 @@ func main() {
 }
 `
 	f := func(test, src string) {
-		f := mustParse("", src)
-		conf := Config{Importer: defaultImporter()}
-		info := Info{Uses: make(map[*syntax.Name]Object)}
-		_, err := conf.Check("main", []*syntax.File{f}, &info)
-		if err != nil {
-			t.Fatal(err)
-		}
+		info := &Info{Uses: make(map[*syntax.Name]Object)}
+		mustTypecheck("main", src, info)
 
 		var pkg *Package
 		count := 0
diff --git a/src/cmd/compile/internal/types2/object_test.go b/src/cmd/compile/internal/types2/object_test.go
index fa036ecf6c..1a0182c885 100644
--- a/src/cmd/compile/internal/types2/object_test.go
+++ b/src/cmd/compile/internal/types2/object_test.go
@@ -5,7 +5,6 @@
 package types2_test
 
 import (
-	"cmd/compile/internal/syntax"
 	"internal/testenv"
 	"strings"
 	"testing"
@@ -57,14 +56,7 @@ func TestIsAlias(t *testing.T) {
 // the same Func Object as the original method. See also issue #34421.
 func TestEmbeddedMethod(t *testing.T) {
 	const src = `package p; type I interface { error }`
-
-	// type-check src
-	f := mustParse("", src)
-	var conf Config
-	pkg, err := conf.Check(f.PkgName.Value, []*syntax.File{f}, nil)
-	if err != nil {
-		t.Fatalf("typecheck failed: %s", err)
-	}
+	pkg := mustTypecheck("p", src, nil)
 
 	// get original error.Error method
 	eface := Universe.Lookup("error")
diff --git a/src/go/types/generator.go b/src/go/types/generator.go
index 1d0863ed12..1e5458bd82 100644
--- a/src/go/types/generator.go
+++ b/src/go/types/generator.go
@@ -96,6 +96,7 @@ var filemap = map[string]action{
 	"map.go":              nil,
 	"named.go":            func(f *ast.File) { fixTokenPos(f); fixTraceSel(f) },
 	"object.go":           func(f *ast.File) { fixTokenPos(f); renameIdent(f, "NewTypeNameLazy", "_NewTypeNameLazy") },
+	"object_test.go":      func(f *ast.File) { renameImportPath(f, `"cmd/compile/internal/types2"`, `"go/types"`) },
 	"objset.go":           nil,
 	"package.go":          nil,
 	"pointer.go":          nil,
diff --git a/src/go/types/issues_test.go b/src/go/types/issues_test.go
index d1e78eded7..472faae0ed 100644
--- a/src/go/types/issues_test.go
+++ b/src/go/types/issues_test.go
@@ -21,9 +21,7 @@ import (
 )
 
 func TestIssue5770(t *testing.T) {
-	f := mustParse(fset, "", `package p; type S struct{T}`)
-	conf := Config{Importer: importer.Default()}
-	_, err := conf.Check(f.Name.Name, fset, []*ast.File{f}, nil) // do not crash
+	_, err := typecheck("p", `package p; type S struct{T}`, nil)
 	const want = "undefined: T"
 	if err == nil || !strings.Contains(err.Error(), want) {
 		t.Errorf("got: %v; want: %s", err, want)
@@ -233,13 +231,8 @@ func main() {
 }
 `
 	f := func(test, src string) {
-		f := mustParse(fset, "", src)
-		cfg := Config{Importer: importer.Default()}
-		info := Info{Uses: make(map[*ast.Ident]Object)}
-		_, err := cfg.Check("main", fset, []*ast.File{f}, &info)
-		if err != nil {
-			t.Fatal(err)
-		}
+		info := &Info{Uses: make(map[*ast.Ident]Object)}
+		mustTypecheck("main", src, info)
 
 		var pkg *Package
 		count := 0
diff --git a/src/go/types/object_test.go b/src/go/types/object_test.go
index 118669b332..5658e38cbe 100644
--- a/src/go/types/object_test.go
+++ b/src/go/types/object_test.go
@@ -1,3 +1,5 @@
+// Code generated by "go run generator.go"; DO NOT EDIT.
+
 // Copyright 2016 The Go Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
@@ -5,8 +7,6 @@
 package types_test
 
 import (
-	"go/ast"
-	"go/token"
 	"internal/testenv"
 	"strings"
 	"testing"
@@ -31,23 +31,23 @@ func TestIsAlias(t *testing.T) {
 
 	// various other types
 	pkg := NewPackage("p", "p")
-	t1 := NewTypeName(0, pkg, "t1", nil)
+	t1 := NewTypeName(nopos, pkg, "t1", nil)
 	n1 := NewNamed(t1, new(Struct), nil)
-	t5 := NewTypeName(0, pkg, "t5", nil)
+	t5 := NewTypeName(nopos, pkg, "t5", nil)
 	NewTypeParam(t5, nil)
 	for _, test := range []struct {
 		name  *TypeName
 		alias bool
 	}{
-		{NewTypeName(0, nil, "t0", nil), false},                       // no type yet
-		{NewTypeName(0, pkg, "t0", nil), false},                       // no type yet
-		{t1, false},                                                   // type name refers to named type and vice versa
-		{NewTypeName(0, nil, "t2", NewInterfaceType(nil, nil)), true}, // type name refers to unnamed type
-		{NewTypeName(0, pkg, "t3", n1), true},                         // type name refers to named type with different type name
-		{NewTypeName(0, nil, "t4", Typ[Int32]), true},                 // type name refers to basic type with different name
-		{NewTypeName(0, nil, "int32", Typ[Int32]), false},             // type name refers to basic type with same name
-		{NewTypeName(0, pkg, "int32", Typ[Int32]), true},              // type name is declared in user-defined package (outside Universe)
-		{NewTypeName(0, nil, "rune", Typ[Rune]), true},                // type name refers to basic type rune which is an alias already
+		{NewTypeName(nopos, nil, "t0", nil), false}, // no type yet
+		{NewTypeName(nopos, pkg, "t0", nil), false}, // no type yet
+		{t1, false}, // type name refers to named type and vice versa
+		{NewTypeName(nopos, nil, "t2", NewInterfaceType(nil, nil)), true}, // type name refers to unnamed type
+		{NewTypeName(nopos, pkg, "t3", n1), true},                         // type name refers to named type with different type name
+		{NewTypeName(nopos, nil, "t4", Typ[Int32]), true},                 // type name refers to basic type with different name
+		{NewTypeName(nopos, nil, "int32", Typ[Int32]), false},             // type name refers to basic type with same name
+		{NewTypeName(nopos, pkg, "int32", Typ[Int32]), true},              // type name is declared in user-defined package (outside Universe)
+		{NewTypeName(nopos, nil, "rune", Typ[Rune]), true},                // type name refers to basic type rune which is an alias already
 		{t5, false}, // type name refers to type parameter and vice versa
 	} {
 		check(test.name, test.alias)
@@ -58,15 +58,7 @@ func TestIsAlias(t *testing.T) {
 // the same Func Object as the original method. See also issue #34421.
 func TestEmbeddedMethod(t *testing.T) {
 	const src = `package p; type I interface { error }`
-
-	// type-check src
-	fset := token.NewFileSet()
-	f := mustParse(fset, "", src)
-	var conf Config
-	pkg, err := conf.Check(f.Name.Name, fset, []*ast.File{f}, nil)
-	if err != nil {
-		t.Fatalf("typecheck failed: %s", err)
-	}
+	pkg := mustTypecheck("p", src, nil)
 
 	// get original error.Error method
 	eface := Universe.Lookup("error")
