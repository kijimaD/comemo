commit 34507e879d31d082eeb5f5722c6c2aceaeb7e052
Author: Xiaodong Liu <liuxiaodong@loongson.cn>
Date:   Thu May 19 20:01:10 2022 +0800

    runtime/cgo: add cgo function call support for loong64
    
    Contributors to the loong64 port are:
      Weining Lu <luweining@loongson.cn>
      Lei Wang <wanglei@loongson.cn>
      Lingqin Gong <gonglingqin@loongson.cn>
      Xiaolin Zhao <zhaoxiaolin@loongson.cn>
      Meidan Li <limeidan@loongson.cn>
      Xiaojuan Zhai <zhaixiaojuan@loongson.cn>
      Qiyuan Pu <puqiyuan@loongson.cn>
      Guoqi Chen <chenguoqi@loongson.cn>
    
    This port has been updated to Go 1.15.6:
      https://github.com/loongson/go
    
    Updates #46229
    
    Change-Id: I8ef0e7f17d6ada3d2f07c81524136b78457e7795
    Reviewed-on: https://go-review.googlesource.com/c/go/+/342319
    Run-TryBot: Ian Lance Taylor <iant@google.com>
    Auto-Submit: Ian Lance Taylor <iant@google.com>
    Run-TryBot: David Chase <drchase@google.com>
    Reviewed-by: Ian Lance Taylor <iant@google.com>
    TryBot-Result: Gopher Robot <gobot@golang.org>
    Reviewed-by: David Chase <drchase@google.com>
---
 src/runtime/cgo/asm_loong64.s       | 67 +++++++++++++++++++++++++++++++++++
 src/runtime/cgo/gcc_linux_loong64.c | 69 +++++++++++++++++++++++++++++++++++++
 src/runtime/cgo/gcc_loong64.S       | 65 ++++++++++++++++++++++++++++++++++
 3 files changed, 201 insertions(+)

diff --git a/src/runtime/cgo/asm_loong64.s b/src/runtime/cgo/asm_loong64.s
new file mode 100644
index 0000000000..961a3dd484
--- /dev/null
+++ b/src/runtime/cgo/asm_loong64.s
@@ -0,0 +1,67 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+#include "textflag.h"
+
+// Called by C code generated by cmd/cgo.
+// func crosscall2(fn, a unsafe.Pointer, n int32, ctxt uintptr)
+// Saves C callee-saved registers and calls cgocallback with three arguments.
+// fn is the PC of a func(a unsafe.Pointer) function.
+TEXT crosscall2(SB),NOSPLIT|NOFRAME,$0
+	/*
+	 * We still need to save all callee save register as before, and then
+	 * push 3 args for fn (R4, R5, R7), skipping R6.
+	 * Also note that at procedure entry in gc world, 8(R29) will be the
+	 *  first arg.
+	 */
+
+	ADDV	$(-8*22), R3
+	MOVV	R4, (8*1)(R3) // fn unsafe.Pointer
+	MOVV	R5, (8*2)(R3) // a unsafe.Pointer
+	MOVV	R7, (8*3)(R3) // ctxt uintptr
+	MOVV	R23, (8*4)(R3)
+	MOVV	R24, (8*5)(R3)
+	MOVV	R25, (8*6)(R3)
+	MOVV	R26, (8*7)(R3)
+	MOVV	R27, (8*8)(R3)
+	MOVV	R28, (8*9)(R3)
+	MOVV	R29, (8*10)(R3)
+	MOVV	R30, (8*11)(R3)
+	MOVV	g, (8*12)(R3)
+	MOVV	R1, (8*13)(R3)
+	MOVD	F24, (8*14)(R3)
+	MOVD	F25, (8*15)(R3)
+	MOVD	F26, (8*16)(R3)
+	MOVD	F27, (8*17)(R3)
+	MOVD	F28, (8*18)(R3)
+	MOVD	F29, (8*19)(R3)
+	MOVD	F30, (8*20)(R3)
+	MOVD	F31, (8*21)(R3)
+
+	// Initialize Go ABI environment
+	JAL	runtime·load_g(SB)
+
+	JAL	runtime·cgocallback(SB)
+
+	MOVV	(8*4)(R3), R23
+	MOVV	(8*5)(R3), R24
+	MOVV	(8*6)(R3), R25
+	MOVV	(8*7)(R3), R26
+	MOVV	(8*8)(R3), R27
+	MOVV	(8*9)(R3), R28
+	MOVV	(8*10)(R3), R29
+	MOVV	(8*11)(R3), R30
+	MOVV	(8*12)(R3), g
+	MOVV	(8*13)(R3), R1
+	MOVD	(8*14)(R3), F24
+	MOVD	(8*15)(R3), F25
+	MOVD	(8*16)(R3), F26
+	MOVD	(8*17)(R3), F27
+	MOVD	(8*18)(R3), F28
+	MOVD	(8*19)(R3), F29
+	MOVD	(8*20)(R3), F30
+	MOVD	(8*21)(R3), F31
+	ADDV	$(8*22), R3
+
+	RET
diff --git a/src/runtime/cgo/gcc_linux_loong64.c b/src/runtime/cgo/gcc_linux_loong64.c
new file mode 100644
index 0000000000..96a06eb960
--- /dev/null
+++ b/src/runtime/cgo/gcc_linux_loong64.c
@@ -0,0 +1,69 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+#include <pthread.h>
+#include <string.h>
+#include <signal.h>
+#include "libcgo.h"
+#include "libcgo_unix.h"
+
+static void *threadentry(void*);
+
+void (*x_cgo_inittls)(void **tlsg, void **tlsbase);
+static void (*setg_gcc)(void*);
+
+void
+_cgo_sys_thread_start(ThreadStart *ts)
+{
+	pthread_attr_t attr;
+	sigset_t ign, oset;
+	pthread_t p;
+	size_t size;
+	int err;
+
+	sigfillset(&ign);
+	pthread_sigmask(SIG_SETMASK, &ign, &oset);
+
+	pthread_attr_init(&attr);
+	pthread_attr_getstacksize(&attr, &size);
+	// Leave stacklo=0 and set stackhi=size; mstart will do the rest.
+	ts->g->stackhi = size;
+	err = _cgo_try_pthread_create(&p, &attr, threadentry, ts);
+
+	pthread_sigmask(SIG_SETMASK, &oset, nil);
+
+	if (err != 0) {
+		fatalf("pthread_create failed: %s", strerror(err));
+	}
+}
+
+extern void crosscall1(void (*fn)(void), void (*setg_gcc)(void*), void *g);
+static void*
+threadentry(void *v)
+{
+	ThreadStart ts;
+
+	ts = *(ThreadStart*)v;
+	free(v);
+
+	crosscall1(ts.fn, setg_gcc, (void*)ts.g);
+	return nil;
+}
+
+void
+x_cgo_init(G *g, void (*setg)(void*), void **tlsg, void **tlsbase)
+{
+	pthread_attr_t attr;
+	size_t size;
+
+	setg_gcc = setg;
+	pthread_attr_init(&attr);
+	pthread_attr_getstacksize(&attr, &size);
+	g->stacklo = (uintptr)&attr - size + 4096;
+	pthread_attr_destroy(&attr);
+
+	if (x_cgo_inittls) {
+		x_cgo_inittls(tlsg, tlsbase);
+	}
+}
diff --git a/src/runtime/cgo/gcc_loong64.S b/src/runtime/cgo/gcc_loong64.S
new file mode 100644
index 0000000000..100aa33cc2
--- /dev/null
+++ b/src/runtime/cgo/gcc_loong64.S
@@ -0,0 +1,65 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+/*
+ * void crosscall1(void (*fn)(void), void (*setg_gcc)(void *g), void *g)
+ *
+ * Calling into the gc tool chain, where all registers are caller save.
+ * Called from standard lp64d ABI, where $r1, $r3, $r23-$r30, and $f24-$f31
+ * are callee-save, so they must be saved explicitly, along with $r1 (LR).
+ */
+.globl crosscall1
+crosscall1:
+	addi.d	$r3, $r3, -160
+	st.d	$r1, $r3, 0
+	st.d	$r23, $r3, 8
+	st.d	$r24, $r3, 16
+	st.d	$r25, $r3, 24
+	st.d	$r26, $r3, 32
+	st.d	$r27, $r3, 40
+	st.d	$r28, $r3, 48
+	st.d	$r29, $r3, 56
+	st.d	$r30, $r3, 64
+	st.d	$r2, $r3, 72
+	st.d	$r22, $r3, 80
+	fst.d	$f24, $r3, 88
+	fst.d	$f25, $r3, 96
+	fst.d	$f26, $r3, 104
+	fst.d	$f27, $r3, 112
+	fst.d	$f28, $r3, 120
+	fst.d	$f29, $r3, 128
+	fst.d	$f30, $r3, 136
+	fst.d	$f31, $r3, 144
+
+	move	$r18, $r4 // save R4
+	move	$r19, $r6
+	jirl	$r1, $r5, 0	// call setg_gcc (clobbers R4)
+	jirl	$r1, $r18, 0	// call fn
+
+	ld.d	$r23, $r3, 8
+	ld.d	$r24, $r3, 16
+	ld.d	$r25, $r3, 24
+	ld.d	$r26, $r3, 32
+	ld.d	$r27, $r3, 40
+	ld.d	$r28, $r3, 48
+	ld.d	$r29, $r3, 56
+	ld.d	$r30, $r3, 64
+	ld.d	$r2, $r3, 72
+	ld.d	$r22, $r3, 80
+	fld.d	$f24, $r3, 88
+	fld.d	$f25, $r3, 96
+	fld.d	$f26, $r3, 104
+	fld.d	$f27, $r3, 112
+	fld.d	$f28, $r3, 120
+	fld.d	$f29, $r3, 128
+	fld.d	$f30, $r3, 136
+	fld.d	$f31, $r3, 144
+	ld.d	$r1, $r3, 0
+	addi.d	$r3, $r3, 160
+	jirl	$r0, $r1, 0
+
+
+#ifdef __ELF__
+.section .note.GNU-stack,"",%progbits
+#endif
