commit a58be734eacd832be27a021b8ffac323061212f2
Author: Ruixin Bao <ruixin.bao@ibm.com>
Date:   Wed Dec 9 13:55:37 2020 -0800

    cmd/compile: fix incorrect shift count type with s390x rules
    
    The type of the shift count must be an unsigned integer. Some s390x
    rules for shift have their auxint type being int8. This results in a
    compilation failure on s390x with an invalid operation when running
    make.bash using older versions of go (e.g: go1.10.4).
    
    This CL adds an auxint type of uint8 and changes the ops for shift and
    rotate to use auxint with type uint8. The related rules are also
    modified to address this change.
    
    Fixes #43090
    
    Change-Id: I594274b6e3d9b23092fc9e9f4b354870164f2f19
    Reviewed-on: https://go-review.googlesource.com/c/go/+/277078
    Reviewed-by: Keith Randall <khr@golang.org>
    Trust: Dmitri Shuralyov <dmitshur@golang.org>
---
 src/cmd/compile/internal/ssa/check.go        |   5 +
 src/cmd/compile/internal/ssa/gen/S390X.rules |  24 +--
 src/cmd/compile/internal/ssa/gen/S390XOps.go |  30 +--
 src/cmd/compile/internal/ssa/gen/rulegen.go  |   4 +-
 src/cmd/compile/internal/ssa/op.go           |   1 +
 src/cmd/compile/internal/ssa/opGen.go        |  14 +-
 src/cmd/compile/internal/ssa/rewriteS390X.go | 290 +++++++++++++--------------
 src/cmd/internal/obj/s390x/rotate.go         |  14 +-
 src/cmd/internal/obj/s390x/rotate_test.go    |   2 +-
 9 files changed, 196 insertions(+), 188 deletions(-)

diff --git a/src/cmd/compile/internal/ssa/check.go b/src/cmd/compile/internal/ssa/check.go
index 5f5dfc328a..2dade7a88d 100644
--- a/src/cmd/compile/internal/ssa/check.go
+++ b/src/cmd/compile/internal/ssa/check.go
@@ -147,6 +147,11 @@ func checkFunc(f *Func) {
 				canHaveAuxInt = true
 			case auxInt128:
 				// AuxInt must be zero, so leave canHaveAuxInt set to false.
+			case auxUInt8:
+				if v.AuxInt != int64(uint8(v.AuxInt)) {
+					f.Fatalf("bad uint8 AuxInt value for %v", v)
+				}
+				canHaveAuxInt = true
 			case auxFloat32:
 				canHaveAuxInt = true
 				if math.IsNaN(v.AuxFloat()) {
diff --git a/src/cmd/compile/internal/ssa/gen/S390X.rules b/src/cmd/compile/internal/ssa/gen/S390X.rules
index 39949edbc2..384f2e807e 100644
--- a/src/cmd/compile/internal/ssa/gen/S390X.rules
+++ b/src/cmd/compile/internal/ssa/gen/S390X.rules
@@ -663,8 +663,8 @@
 ((OR|XOR)W x (MOVDconst [c])) => ((OR|XOR)Wconst [int32(c)] x)
 
 // Constant shifts.
-(S(LD|RD|RAD) x (MOVDconst [c])) => (S(LD|RD|RAD)const x [int8(c&63)])
-(S(LW|RW|RAW) x (MOVDconst [c])) && c&32 == 0 => (S(LW|RW|RAW)const x [int8(c&31)])
+(S(LD|RD|RAD) x (MOVDconst [c])) => (S(LD|RD|RAD)const x [uint8(c&63)])
+(S(LW|RW|RAW) x (MOVDconst [c])) && c&32 == 0 => (S(LW|RW|RAW)const x [uint8(c&31)])
 (S(LW|RW)     _ (MOVDconst [c])) && c&32 != 0 => (MOVDconst [0])
 (SRAW         x (MOVDconst [c])) && c&32 != 0 => (SRAWconst x [31])
 
@@ -685,8 +685,8 @@
 (SRAW x (MOV(W|H|B|WZ|HZ|BZ)reg y)) => (SRAW x y)
 
 // Match rotate by constant.
-(RLLG x (MOVDconst [c])) => (RISBGZ x {s390x.NewRotateParams(0, 63, int8(c&63))})
-(RLL  x (MOVDconst [c])) => (RLLconst x [int8(c&31)])
+(RLLG x (MOVDconst [c])) => (RISBGZ x {s390x.NewRotateParams(0, 63, uint8(c&63))})
+(RLL  x (MOVDconst [c])) => (RLLconst x [uint8(c&31)])
 
 // Match rotate by constant pattern.
 ((ADD|OR|XOR)  (SLDconst x [c]) (SRDconst x [64-c])) => (RISBGZ x {s390x.NewRotateParams(0, 63, c)})
@@ -705,10 +705,10 @@
 (CMP(W|WU) (MOVDconst [c]) x) => (InvertFlags (CMP(W|WU)const x [int32(c)]))
 
 // Match (x >> c) << d to 'rotate then insert selected bits [into zero]'.
-(SLDconst (SRDconst x [c]) [d]) => (RISBGZ x {s390x.NewRotateParams(max8(0, c-d), 63-d, (d-c)&63)})
+(SLDconst (SRDconst x [c]) [d]) => (RISBGZ x {s390x.NewRotateParams(uint8(max8(0, int8(c-d))), 63-d, uint8(int8(d-c)&63))})
 
 // Match (x << c) >> d to 'rotate then insert selected bits [into zero]'.
-(SRDconst (SLDconst x [c]) [d]) => (RISBGZ x {s390x.NewRotateParams(d, min8(63, 63-c+d), (c-d)&63)})
+(SRDconst (SLDconst x [c]) [d]) => (RISBGZ x {s390x.NewRotateParams(d, uint8(min8(63, int8(63-c+d))), uint8(int8(c-d)&63))})
 
 // Absorb input zero extension into 'rotate then insert selected bits [into zero]'.
 (RISBGZ (MOVWZreg x) {r}) && r.InMerge(0xffffffff) != nil => (RISBGZ x {*r.InMerge(0xffffffff)})
@@ -818,18 +818,18 @@
 
 // c = 2ˣ + 2ʸ => c - 2ˣ = 2ʸ
 (MULL(D|W)const <t> x [c]) && isPowerOfTwo32(c&(c-1))
-  => ((ADD|ADDW) (SL(D|W)const <t> x [int8(log32(c&(c-1)))])
-                 (SL(D|W)const <t> x [int8(log32(c&^(c-1)))]))
+  => ((ADD|ADDW) (SL(D|W)const <t> x [uint8(log32(c&(c-1)))])
+                 (SL(D|W)const <t> x [uint8(log32(c&^(c-1)))]))
 
 // c = 2ʸ - 2ˣ => c + 2ˣ = 2ʸ
 (MULL(D|W)const <t> x [c]) && isPowerOfTwo32(c+(c&^(c-1)))
-  => ((SUB|SUBW) (SL(D|W)const <t> x [int8(log32(c+(c&^(c-1))))])
-                 (SL(D|W)const <t> x [int8(log32(c&^(c-1)))]))
+  => ((SUB|SUBW) (SL(D|W)const <t> x [uint8(log32(c+(c&^(c-1))))])
+                 (SL(D|W)const <t> x [uint8(log32(c&^(c-1)))]))
 
 // c = 2ˣ - 2ʸ => -c + 2ˣ = 2ʸ
 (MULL(D|W)const <t> x [c]) && isPowerOfTwo32(-c+(-c&^(-c-1)))
-  => ((SUB|SUBW) (SL(D|W)const <t> x [int8(log32(-c&^(-c-1)))])
-                 (SL(D|W)const <t> x [int8(log32(-c+(-c&^(-c-1))))]))
+  => ((SUB|SUBW) (SL(D|W)const <t> x [uint8(log32(-c&^(-c-1)))])
+                 (SL(D|W)const <t> x [uint8(log32(-c+(-c&^(-c-1))))]))
 
 // Fold ADD into MOVDaddr. Odd offsets from SB shouldn't be folded (LARL can't handle them).
 (ADDconst [c] (MOVDaddr [d] {s} x:(SB))) && ((c+d)&1 == 0) && is32Bit(int64(c)+int64(d)) => (MOVDaddr [c+d] {s} x)
diff --git a/src/cmd/compile/internal/ssa/gen/S390XOps.go b/src/cmd/compile/internal/ssa/gen/S390XOps.go
index f0cf2f2f6e..b24fd61942 100644
--- a/src/cmd/compile/internal/ssa/gen/S390XOps.go
+++ b/src/cmd/compile/internal/ssa/gen/S390XOps.go
@@ -330,27 +330,27 @@ func init() {
 		{name: "LTDBR", argLength: 1, reg: fp1flags, asm: "LTDBR", typ: "Flags"}, // arg0 compare to 0, f64
 		{name: "LTEBR", argLength: 1, reg: fp1flags, asm: "LTEBR", typ: "Flags"}, // arg0 compare to 0, f32
 
-		{name: "SLD", argLength: 2, reg: sh21, asm: "SLD"},                   // arg0 << arg1, shift amount is mod 64
-		{name: "SLW", argLength: 2, reg: sh21, asm: "SLW"},                   // arg0 << arg1, shift amount is mod 64
-		{name: "SLDconst", argLength: 1, reg: gp11, asm: "SLD", aux: "Int8"}, // arg0 << auxint, shift amount 0-63
-		{name: "SLWconst", argLength: 1, reg: gp11, asm: "SLW", aux: "Int8"}, // arg0 << auxint, shift amount 0-31
+		{name: "SLD", argLength: 2, reg: sh21, asm: "SLD"},                    // arg0 << arg1, shift amount is mod 64
+		{name: "SLW", argLength: 2, reg: sh21, asm: "SLW"},                    // arg0 << arg1, shift amount is mod 64
+		{name: "SLDconst", argLength: 1, reg: gp11, asm: "SLD", aux: "UInt8"}, // arg0 << auxint, shift amount 0-63
+		{name: "SLWconst", argLength: 1, reg: gp11, asm: "SLW", aux: "UInt8"}, // arg0 << auxint, shift amount 0-31
 
-		{name: "SRD", argLength: 2, reg: sh21, asm: "SRD"},                   // unsigned arg0 >> arg1, shift amount is mod 64
-		{name: "SRW", argLength: 2, reg: sh21, asm: "SRW"},                   // unsigned uint32(arg0) >> arg1, shift amount is mod 64
-		{name: "SRDconst", argLength: 1, reg: gp11, asm: "SRD", aux: "Int8"}, // unsigned arg0 >> auxint, shift amount 0-63
-		{name: "SRWconst", argLength: 1, reg: gp11, asm: "SRW", aux: "Int8"}, // unsigned uint32(arg0) >> auxint, shift amount 0-31
+		{name: "SRD", argLength: 2, reg: sh21, asm: "SRD"},                    // unsigned arg0 >> arg1, shift amount is mod 64
+		{name: "SRW", argLength: 2, reg: sh21, asm: "SRW"},                    // unsigned uint32(arg0) >> arg1, shift amount is mod 64
+		{name: "SRDconst", argLength: 1, reg: gp11, asm: "SRD", aux: "UInt8"}, // unsigned arg0 >> auxint, shift amount 0-63
+		{name: "SRWconst", argLength: 1, reg: gp11, asm: "SRW", aux: "UInt8"}, // unsigned uint32(arg0) >> auxint, shift amount 0-31
 
 		// Arithmetic shifts clobber flags.
-		{name: "SRAD", argLength: 2, reg: sh21, asm: "SRAD", clobberFlags: true},                   // signed arg0 >> arg1, shift amount is mod 64
-		{name: "SRAW", argLength: 2, reg: sh21, asm: "SRAW", clobberFlags: true},                   // signed int32(arg0) >> arg1, shift amount is mod 64
-		{name: "SRADconst", argLength: 1, reg: gp11, asm: "SRAD", aux: "Int8", clobberFlags: true}, // signed arg0 >> auxint, shift amount 0-63
-		{name: "SRAWconst", argLength: 1, reg: gp11, asm: "SRAW", aux: "Int8", clobberFlags: true}, // signed int32(arg0) >> auxint, shift amount 0-31
+		{name: "SRAD", argLength: 2, reg: sh21, asm: "SRAD", clobberFlags: true},                    // signed arg0 >> arg1, shift amount is mod 64
+		{name: "SRAW", argLength: 2, reg: sh21, asm: "SRAW", clobberFlags: true},                    // signed int32(arg0) >> arg1, shift amount is mod 64
+		{name: "SRADconst", argLength: 1, reg: gp11, asm: "SRAD", aux: "UInt8", clobberFlags: true}, // signed arg0 >> auxint, shift amount 0-63
+		{name: "SRAWconst", argLength: 1, reg: gp11, asm: "SRAW", aux: "UInt8", clobberFlags: true}, // signed int32(arg0) >> auxint, shift amount 0-31
 
 		// Rotate instructions.
 		// Note: no RLLGconst - use RISBGZ instead.
-		{name: "RLLG", argLength: 2, reg: sh21, asm: "RLLG"},                 // arg0 rotate left arg1, rotate amount 0-63
-		{name: "RLL", argLength: 2, reg: sh21, asm: "RLL"},                   // arg0 rotate left arg1, rotate amount 0-31
-		{name: "RLLconst", argLength: 1, reg: gp11, asm: "RLL", aux: "Int8"}, // arg0 rotate left auxint, rotate amount 0-31
+		{name: "RLLG", argLength: 2, reg: sh21, asm: "RLLG"},                  // arg0 rotate left arg1, rotate amount 0-63
+		{name: "RLL", argLength: 2, reg: sh21, asm: "RLL"},                    // arg0 rotate left arg1, rotate amount 0-31
+		{name: "RLLconst", argLength: 1, reg: gp11, asm: "RLL", aux: "UInt8"}, // arg0 rotate left auxint, rotate amount 0-31
 
 		// Rotate then (and|or|xor|insert) selected bits instructions.
 		//
diff --git a/src/cmd/compile/internal/ssa/gen/rulegen.go b/src/cmd/compile/internal/ssa/gen/rulegen.go
index 120ccbbdb3..aaf9101368 100644
--- a/src/cmd/compile/internal/ssa/gen/rulegen.go
+++ b/src/cmd/compile/internal/ssa/gen/rulegen.go
@@ -1395,7 +1395,7 @@ func parseValue(val string, arch arch, loc string) (op opData, oparch, typ, auxi
 
 func opHasAuxInt(op opData) bool {
 	switch op.aux {
-	case "Bool", "Int8", "Int16", "Int32", "Int64", "Int128", "Float32", "Float64",
+	case "Bool", "Int8", "Int16", "Int32", "Int64", "Int128", "UInt8", "Float32", "Float64",
 		"SymOff", "CallOff", "SymValAndOff", "TypSize", "ARM64BitField", "FlagConstant", "CCop":
 		return true
 	}
@@ -1780,6 +1780,8 @@ func (op opData) auxIntType() string {
 		return "int64"
 	case "Int128":
 		return "int128"
+	case "UInt8":
+		return "uint8"
 	case "Float32":
 		return "float32"
 	case "Float64":
diff --git a/src/cmd/compile/internal/ssa/op.go b/src/cmd/compile/internal/ssa/op.go
index 6f029a421e..d1673352bd 100644
--- a/src/cmd/compile/internal/ssa/op.go
+++ b/src/cmd/compile/internal/ssa/op.go
@@ -205,6 +205,7 @@ const (
 	auxInt32                // auxInt is a 32-bit integer
 	auxInt64                // auxInt is a 64-bit integer
 	auxInt128               // auxInt represents a 128-bit integer.  Always 0.
+	auxUInt8                // auxInt is an 8-bit unsigned integer
 	auxFloat32              // auxInt is a float32 (encoded with math.Float64bits)
 	auxFloat64              // auxInt is a float64 (encoded with math.Float64bits)
 	auxFlagConstant         // auxInt is a flagConstant
diff --git a/src/cmd/compile/internal/ssa/opGen.go b/src/cmd/compile/internal/ssa/opGen.go
index eceef1d91a..83d35cf7e1 100644
--- a/src/cmd/compile/internal/ssa/opGen.go
+++ b/src/cmd/compile/internal/ssa/opGen.go
@@ -30569,7 +30569,7 @@ var opcodeTable = [...]opInfo{
 	},
 	{
 		name:    "SLDconst",
-		auxType: auxInt8,
+		auxType: auxUInt8,
 		argLen:  1,
 		asm:     s390x.ASLD,
 		reg: regInfo{
@@ -30583,7 +30583,7 @@ var opcodeTable = [...]opInfo{
 	},
 	{
 		name:    "SLWconst",
-		auxType: auxInt8,
+		auxType: auxUInt8,
 		argLen:  1,
 		asm:     s390x.ASLW,
 		reg: regInfo{
@@ -30625,7 +30625,7 @@ var opcodeTable = [...]opInfo{
 	},
 	{
 		name:    "SRDconst",
-		auxType: auxInt8,
+		auxType: auxUInt8,
 		argLen:  1,
 		asm:     s390x.ASRD,
 		reg: regInfo{
@@ -30639,7 +30639,7 @@ var opcodeTable = [...]opInfo{
 	},
 	{
 		name:    "SRWconst",
-		auxType: auxInt8,
+		auxType: auxUInt8,
 		argLen:  1,
 		asm:     s390x.ASRW,
 		reg: regInfo{
@@ -30683,7 +30683,7 @@ var opcodeTable = [...]opInfo{
 	},
 	{
 		name:         "SRADconst",
-		auxType:      auxInt8,
+		auxType:      auxUInt8,
 		argLen:       1,
 		clobberFlags: true,
 		asm:          s390x.ASRAD,
@@ -30698,7 +30698,7 @@ var opcodeTable = [...]opInfo{
 	},
 	{
 		name:         "SRAWconst",
-		auxType:      auxInt8,
+		auxType:      auxUInt8,
 		argLen:       1,
 		clobberFlags: true,
 		asm:          s390x.ASRAW,
@@ -30741,7 +30741,7 @@ var opcodeTable = [...]opInfo{
 	},
 	{
 		name:    "RLLconst",
-		auxType: auxInt8,
+		auxType: auxUInt8,
 		argLen:  1,
 		asm:     s390x.ARLL,
 		reg: regInfo{
diff --git a/src/cmd/compile/internal/ssa/rewriteS390X.go b/src/cmd/compile/internal/ssa/rewriteS390X.go
index d66113d111..a9722b820c 100644
--- a/src/cmd/compile/internal/ssa/rewriteS390X.go
+++ b/src/cmd/compile/internal/ssa/rewriteS390X.go
@@ -1240,7 +1240,7 @@ func rewriteValueS390X_OpAvg64u(v *Value) bool {
 		y := v_1
 		v.reset(OpS390XADD)
 		v0 := b.NewValue0(v.Pos, OpS390XSRDconst, t)
-		v0.AuxInt = int8ToAuxInt(1)
+		v0.AuxInt = uint8ToAuxInt(1)
 		v1 := b.NewValue0(v.Pos, OpS390XSUB, t)
 		v1.AddArg2(x, y)
 		v0.AddArg(v1)
@@ -1737,7 +1737,7 @@ func rewriteValueS390X_OpHmul32(v *Value) bool {
 		x := v_0
 		y := v_1
 		v.reset(OpS390XSRDconst)
-		v.AuxInt = int8ToAuxInt(32)
+		v.AuxInt = uint8ToAuxInt(32)
 		v0 := b.NewValue0(v.Pos, OpS390XMULLD, typ.Int64)
 		v1 := b.NewValue0(v.Pos, OpS390XMOVWreg, typ.Int64)
 		v1.AddArg(x)
@@ -1759,7 +1759,7 @@ func rewriteValueS390X_OpHmul32u(v *Value) bool {
 		x := v_0
 		y := v_1
 		v.reset(OpS390XSRDconst)
-		v.AuxInt = int8ToAuxInt(32)
+		v.AuxInt = uint8ToAuxInt(32)
 		v0 := b.NewValue0(v.Pos, OpS390XMULLD, typ.Int64)
 		v1 := b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64)
 		v1.AddArg(x)
@@ -5281,9 +5281,9 @@ func rewriteValueS390X_OpS390XADD(v *Value) bool {
 			if v_0.Op != OpS390XSLDconst {
 				continue
 			}
-			c := auxIntToInt8(v_0.AuxInt)
+			c := auxIntToUint8(v_0.AuxInt)
 			x := v_0.Args[0]
-			if v_1.Op != OpS390XSRDconst || auxIntToInt8(v_1.AuxInt) != 64-c || x != v_1.Args[0] {
+			if v_1.Op != OpS390XSRDconst || auxIntToUint8(v_1.AuxInt) != 64-c || x != v_1.Args[0] {
 				continue
 			}
 			v.reset(OpS390XRISBGZ)
@@ -5474,13 +5474,13 @@ func rewriteValueS390X_OpS390XADDW(v *Value) bool {
 			if v_0.Op != OpS390XSLWconst {
 				continue
 			}
-			c := auxIntToInt8(v_0.AuxInt)
+			c := auxIntToUint8(v_0.AuxInt)
 			x := v_0.Args[0]
-			if v_1.Op != OpS390XSRWconst || auxIntToInt8(v_1.AuxInt) != 32-c || x != v_1.Args[0] {
+			if v_1.Op != OpS390XSRWconst || auxIntToUint8(v_1.AuxInt) != 32-c || x != v_1.Args[0] {
 				continue
 			}
 			v.reset(OpS390XRLLconst)
-			v.AuxInt = int8ToAuxInt(c)
+			v.AuxInt = uint8ToAuxInt(c)
 			v.AddArg(x)
 			return true
 		}
@@ -6460,7 +6460,7 @@ func rewriteValueS390X_OpS390XCMPUconst(v *Value) bool {
 		if v_0.Op != OpS390XSRDconst {
 			break
 		}
-		c := auxIntToInt8(v_0.AuxInt)
+		c := auxIntToUint8(v_0.AuxInt)
 		if !(c > 0 && c < 64 && (1<<uint(64-c)) <= uint64(n)) {
 			break
 		}
@@ -6862,7 +6862,7 @@ func rewriteValueS390X_OpS390XCMPWUconst(v *Value) bool {
 		if v_0.Op != OpS390XSRWconst {
 			break
 		}
-		c := auxIntToInt8(v_0.AuxInt)
+		c := auxIntToUint8(v_0.AuxInt)
 		if !(c > 0 && c < 32 && (1<<uint(32-c)) <= uint32(n)) {
 			break
 		}
@@ -6989,7 +6989,7 @@ func rewriteValueS390X_OpS390XCMPWconst(v *Value) bool {
 		if v_0.Op != OpS390XSRWconst {
 			break
 		}
-		c := auxIntToInt8(v_0.AuxInt)
+		c := auxIntToUint8(v_0.AuxInt)
 		if !(c > 0 && n < 0) {
 			break
 		}
@@ -7020,7 +7020,7 @@ func rewriteValueS390X_OpS390XCMPWconst(v *Value) bool {
 		if x.Op != OpS390XSRWconst {
 			break
 		}
-		c := auxIntToInt8(x.AuxInt)
+		c := auxIntToUint8(x.AuxInt)
 		if !(c > 0 && n >= 0) {
 			break
 		}
@@ -7112,7 +7112,7 @@ func rewriteValueS390X_OpS390XCMPconst(v *Value) bool {
 		if v_0.Op != OpS390XSRDconst {
 			break
 		}
-		c := auxIntToInt8(v_0.AuxInt)
+		c := auxIntToUint8(v_0.AuxInt)
 		if !(c > 0 && n < 0) {
 			break
 		}
@@ -7250,7 +7250,7 @@ func rewriteValueS390X_OpS390XCMPconst(v *Value) bool {
 		if x.Op != OpS390XSRDconst {
 			break
 		}
-		c := auxIntToInt8(x.AuxInt)
+		c := auxIntToUint8(x.AuxInt)
 		if !(c > 0 && n >= 0) {
 			break
 		}
@@ -8673,7 +8673,7 @@ func rewriteValueS390X_OpS390XMOVBstore(v *Value) bool {
 			break
 		}
 		x_1 := x.Args[1]
-		if x_1.Op != OpS390XSRDconst || auxIntToInt8(x_1.AuxInt) != 8 || w != x_1.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
+		if x_1.Op != OpS390XSRDconst || auxIntToUint8(x_1.AuxInt) != 8 || w != x_1.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
 			break
 		}
 		v.reset(OpS390XMOVHstore)
@@ -8693,7 +8693,7 @@ func rewriteValueS390X_OpS390XMOVBstore(v *Value) bool {
 		if w0.Op != OpS390XSRDconst {
 			break
 		}
-		j := auxIntToInt8(w0.AuxInt)
+		j := auxIntToUint8(w0.AuxInt)
 		w := w0.Args[0]
 		x := v_2
 		if x.Op != OpS390XMOVBstore || auxIntToInt32(x.AuxInt) != i-1 || auxToSym(x.Aux) != s {
@@ -8704,7 +8704,7 @@ func rewriteValueS390X_OpS390XMOVBstore(v *Value) bool {
 			break
 		}
 		x_1 := x.Args[1]
-		if x_1.Op != OpS390XSRDconst || auxIntToInt8(x_1.AuxInt) != j+8 || w != x_1.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
+		if x_1.Op != OpS390XSRDconst || auxIntToUint8(x_1.AuxInt) != j+8 || w != x_1.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
 			break
 		}
 		v.reset(OpS390XMOVHstore)
@@ -8730,7 +8730,7 @@ func rewriteValueS390X_OpS390XMOVBstore(v *Value) bool {
 			break
 		}
 		x_1 := x.Args[1]
-		if x_1.Op != OpS390XSRWconst || auxIntToInt8(x_1.AuxInt) != 8 || w != x_1.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
+		if x_1.Op != OpS390XSRWconst || auxIntToUint8(x_1.AuxInt) != 8 || w != x_1.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
 			break
 		}
 		v.reset(OpS390XMOVHstore)
@@ -8750,7 +8750,7 @@ func rewriteValueS390X_OpS390XMOVBstore(v *Value) bool {
 		if w0.Op != OpS390XSRWconst {
 			break
 		}
-		j := auxIntToInt8(w0.AuxInt)
+		j := auxIntToUint8(w0.AuxInt)
 		w := w0.Args[0]
 		x := v_2
 		if x.Op != OpS390XMOVBstore || auxIntToInt32(x.AuxInt) != i-1 || auxToSym(x.Aux) != s {
@@ -8761,7 +8761,7 @@ func rewriteValueS390X_OpS390XMOVBstore(v *Value) bool {
 			break
 		}
 		x_1 := x.Args[1]
-		if x_1.Op != OpS390XSRWconst || auxIntToInt8(x_1.AuxInt) != j+8 || w != x_1.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
+		if x_1.Op != OpS390XSRWconst || auxIntToUint8(x_1.AuxInt) != j+8 || w != x_1.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
 			break
 		}
 		v.reset(OpS390XMOVHstore)
@@ -8777,7 +8777,7 @@ func rewriteValueS390X_OpS390XMOVBstore(v *Value) bool {
 		i := auxIntToInt32(v.AuxInt)
 		s := auxToSym(v.Aux)
 		p := v_0
-		if v_1.Op != OpS390XSRDconst || auxIntToInt8(v_1.AuxInt) != 8 {
+		if v_1.Op != OpS390XSRDconst || auxIntToUint8(v_1.AuxInt) != 8 {
 			break
 		}
 		w := v_1.Args[0]
@@ -8805,7 +8805,7 @@ func rewriteValueS390X_OpS390XMOVBstore(v *Value) bool {
 		if v_1.Op != OpS390XSRDconst {
 			break
 		}
-		j := auxIntToInt8(v_1.AuxInt)
+		j := auxIntToUint8(v_1.AuxInt)
 		w := v_1.Args[0]
 		x := v_2
 		if x.Op != OpS390XMOVBstore || auxIntToInt32(x.AuxInt) != i-1 || auxToSym(x.Aux) != s {
@@ -8816,7 +8816,7 @@ func rewriteValueS390X_OpS390XMOVBstore(v *Value) bool {
 			break
 		}
 		w0 := x.Args[1]
-		if w0.Op != OpS390XSRDconst || auxIntToInt8(w0.AuxInt) != j-8 || w != w0.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
+		if w0.Op != OpS390XSRDconst || auxIntToUint8(w0.AuxInt) != j-8 || w != w0.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
 			break
 		}
 		v.reset(OpS390XMOVHBRstore)
@@ -8832,7 +8832,7 @@ func rewriteValueS390X_OpS390XMOVBstore(v *Value) bool {
 		i := auxIntToInt32(v.AuxInt)
 		s := auxToSym(v.Aux)
 		p := v_0
-		if v_1.Op != OpS390XSRWconst || auxIntToInt8(v_1.AuxInt) != 8 {
+		if v_1.Op != OpS390XSRWconst || auxIntToUint8(v_1.AuxInt) != 8 {
 			break
 		}
 		w := v_1.Args[0]
@@ -8860,7 +8860,7 @@ func rewriteValueS390X_OpS390XMOVBstore(v *Value) bool {
 		if v_1.Op != OpS390XSRWconst {
 			break
 		}
-		j := auxIntToInt8(v_1.AuxInt)
+		j := auxIntToUint8(v_1.AuxInt)
 		w := v_1.Args[0]
 		x := v_2
 		if x.Op != OpS390XMOVBstore || auxIntToInt32(x.AuxInt) != i-1 || auxToSym(x.Aux) != s {
@@ -8871,7 +8871,7 @@ func rewriteValueS390X_OpS390XMOVBstore(v *Value) bool {
 			break
 		}
 		w0 := x.Args[1]
-		if w0.Op != OpS390XSRWconst || auxIntToInt8(w0.AuxInt) != j-8 || w != w0.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
+		if w0.Op != OpS390XSRWconst || auxIntToUint8(w0.AuxInt) != j-8 || w != w0.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
 			break
 		}
 		v.reset(OpS390XMOVHBRstore)
@@ -9345,7 +9345,7 @@ func rewriteValueS390X_OpS390XMOVHBRstore(v *Value) bool {
 		i := auxIntToInt32(v.AuxInt)
 		s := auxToSym(v.Aux)
 		p := v_0
-		if v_1.Op != OpS390XSRDconst || auxIntToInt8(v_1.AuxInt) != 16 {
+		if v_1.Op != OpS390XSRDconst || auxIntToUint8(v_1.AuxInt) != 16 {
 			break
 		}
 		w := v_1.Args[0]
@@ -9373,7 +9373,7 @@ func rewriteValueS390X_OpS390XMOVHBRstore(v *Value) bool {
 		if v_1.Op != OpS390XSRDconst {
 			break
 		}
-		j := auxIntToInt8(v_1.AuxInt)
+		j := auxIntToUint8(v_1.AuxInt)
 		w := v_1.Args[0]
 		x := v_2
 		if x.Op != OpS390XMOVHBRstore || auxIntToInt32(x.AuxInt) != i-2 || auxToSym(x.Aux) != s {
@@ -9384,7 +9384,7 @@ func rewriteValueS390X_OpS390XMOVHBRstore(v *Value) bool {
 			break
 		}
 		w0 := x.Args[1]
-		if w0.Op != OpS390XSRDconst || auxIntToInt8(w0.AuxInt) != j-16 || w != w0.Args[0] || !(x.Uses == 1 && clobber(x)) {
+		if w0.Op != OpS390XSRDconst || auxIntToUint8(w0.AuxInt) != j-16 || w != w0.Args[0] || !(x.Uses == 1 && clobber(x)) {
 			break
 		}
 		v.reset(OpS390XMOVWBRstore)
@@ -9400,7 +9400,7 @@ func rewriteValueS390X_OpS390XMOVHBRstore(v *Value) bool {
 		i := auxIntToInt32(v.AuxInt)
 		s := auxToSym(v.Aux)
 		p := v_0
-		if v_1.Op != OpS390XSRWconst || auxIntToInt8(v_1.AuxInt) != 16 {
+		if v_1.Op != OpS390XSRWconst || auxIntToUint8(v_1.AuxInt) != 16 {
 			break
 		}
 		w := v_1.Args[0]
@@ -9428,7 +9428,7 @@ func rewriteValueS390X_OpS390XMOVHBRstore(v *Value) bool {
 		if v_1.Op != OpS390XSRWconst {
 			break
 		}
-		j := auxIntToInt8(v_1.AuxInt)
+		j := auxIntToUint8(v_1.AuxInt)
 		w := v_1.Args[0]
 		x := v_2
 		if x.Op != OpS390XMOVHBRstore || auxIntToInt32(x.AuxInt) != i-2 || auxToSym(x.Aux) != s {
@@ -9439,7 +9439,7 @@ func rewriteValueS390X_OpS390XMOVHBRstore(v *Value) bool {
 			break
 		}
 		w0 := x.Args[1]
-		if w0.Op != OpS390XSRWconst || auxIntToInt8(w0.AuxInt) != j-16 || w != w0.Args[0] || !(x.Uses == 1 && clobber(x)) {
+		if w0.Op != OpS390XSRWconst || auxIntToUint8(w0.AuxInt) != j-16 || w != w0.Args[0] || !(x.Uses == 1 && clobber(x)) {
 			break
 		}
 		v.reset(OpS390XMOVWBRstore)
@@ -10086,7 +10086,7 @@ func rewriteValueS390X_OpS390XMOVHstore(v *Value) bool {
 			break
 		}
 		x_1 := x.Args[1]
-		if x_1.Op != OpS390XSRDconst || auxIntToInt8(x_1.AuxInt) != 16 || w != x_1.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
+		if x_1.Op != OpS390XSRDconst || auxIntToUint8(x_1.AuxInt) != 16 || w != x_1.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
 			break
 		}
 		v.reset(OpS390XMOVWstore)
@@ -10106,7 +10106,7 @@ func rewriteValueS390X_OpS390XMOVHstore(v *Value) bool {
 		if w0.Op != OpS390XSRDconst {
 			break
 		}
-		j := auxIntToInt8(w0.AuxInt)
+		j := auxIntToUint8(w0.AuxInt)
 		w := w0.Args[0]
 		x := v_2
 		if x.Op != OpS390XMOVHstore || auxIntToInt32(x.AuxInt) != i-2 || auxToSym(x.Aux) != s {
@@ -10117,7 +10117,7 @@ func rewriteValueS390X_OpS390XMOVHstore(v *Value) bool {
 			break
 		}
 		x_1 := x.Args[1]
-		if x_1.Op != OpS390XSRDconst || auxIntToInt8(x_1.AuxInt) != j+16 || w != x_1.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
+		if x_1.Op != OpS390XSRDconst || auxIntToUint8(x_1.AuxInt) != j+16 || w != x_1.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
 			break
 		}
 		v.reset(OpS390XMOVWstore)
@@ -10143,7 +10143,7 @@ func rewriteValueS390X_OpS390XMOVHstore(v *Value) bool {
 			break
 		}
 		x_1 := x.Args[1]
-		if x_1.Op != OpS390XSRWconst || auxIntToInt8(x_1.AuxInt) != 16 || w != x_1.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
+		if x_1.Op != OpS390XSRWconst || auxIntToUint8(x_1.AuxInt) != 16 || w != x_1.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
 			break
 		}
 		v.reset(OpS390XMOVWstore)
@@ -10163,7 +10163,7 @@ func rewriteValueS390X_OpS390XMOVHstore(v *Value) bool {
 		if w0.Op != OpS390XSRWconst {
 			break
 		}
-		j := auxIntToInt8(w0.AuxInt)
+		j := auxIntToUint8(w0.AuxInt)
 		w := w0.Args[0]
 		x := v_2
 		if x.Op != OpS390XMOVHstore || auxIntToInt32(x.AuxInt) != i-2 || auxToSym(x.Aux) != s {
@@ -10174,7 +10174,7 @@ func rewriteValueS390X_OpS390XMOVHstore(v *Value) bool {
 			break
 		}
 		x_1 := x.Args[1]
-		if x_1.Op != OpS390XSRWconst || auxIntToInt8(x_1.AuxInt) != j+16 || w != x_1.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
+		if x_1.Op != OpS390XSRWconst || auxIntToUint8(x_1.AuxInt) != j+16 || w != x_1.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
 			break
 		}
 		v.reset(OpS390XMOVWstore)
@@ -10273,7 +10273,7 @@ func rewriteValueS390X_OpS390XMOVWBRstore(v *Value) bool {
 		i := auxIntToInt32(v.AuxInt)
 		s := auxToSym(v.Aux)
 		p := v_0
-		if v_1.Op != OpS390XSRDconst || auxIntToInt8(v_1.AuxInt) != 32 {
+		if v_1.Op != OpS390XSRDconst || auxIntToUint8(v_1.AuxInt) != 32 {
 			break
 		}
 		w := v_1.Args[0]
@@ -10301,7 +10301,7 @@ func rewriteValueS390X_OpS390XMOVWBRstore(v *Value) bool {
 		if v_1.Op != OpS390XSRDconst {
 			break
 		}
-		j := auxIntToInt8(v_1.AuxInt)
+		j := auxIntToUint8(v_1.AuxInt)
 		w := v_1.Args[0]
 		x := v_2
 		if x.Op != OpS390XMOVWBRstore || auxIntToInt32(x.AuxInt) != i-4 || auxToSym(x.Aux) != s {
@@ -10312,7 +10312,7 @@ func rewriteValueS390X_OpS390XMOVWBRstore(v *Value) bool {
 			break
 		}
 		w0 := x.Args[1]
-		if w0.Op != OpS390XSRDconst || auxIntToInt8(w0.AuxInt) != j-32 || w != w0.Args[0] || !(x.Uses == 1 && clobber(x)) {
+		if w0.Op != OpS390XSRDconst || auxIntToUint8(w0.AuxInt) != j-32 || w != w0.Args[0] || !(x.Uses == 1 && clobber(x)) {
 			break
 		}
 		v.reset(OpS390XMOVDBRstore)
@@ -10914,7 +10914,7 @@ func rewriteValueS390X_OpS390XMOVWstore(v *Value) bool {
 		i := auxIntToInt32(v.AuxInt)
 		s := auxToSym(v.Aux)
 		p := v_0
-		if v_1.Op != OpS390XSRDconst || auxIntToInt8(v_1.AuxInt) != 32 {
+		if v_1.Op != OpS390XSRDconst || auxIntToUint8(v_1.AuxInt) != 32 {
 			break
 		}
 		w := v_1.Args[0]
@@ -10943,7 +10943,7 @@ func rewriteValueS390X_OpS390XMOVWstore(v *Value) bool {
 		if w0.Op != OpS390XSRDconst {
 			break
 		}
-		j := auxIntToInt8(w0.AuxInt)
+		j := auxIntToUint8(w0.AuxInt)
 		w := w0.Args[0]
 		x := v_2
 		if x.Op != OpS390XMOVWstore || auxIntToInt32(x.AuxInt) != i-4 || auxToSym(x.Aux) != s {
@@ -10954,7 +10954,7 @@ func rewriteValueS390X_OpS390XMOVWstore(v *Value) bool {
 			break
 		}
 		x_1 := x.Args[1]
-		if x_1.Op != OpS390XSRDconst || auxIntToInt8(x_1.AuxInt) != j+32 || w != x_1.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
+		if x_1.Op != OpS390XSRDconst || auxIntToUint8(x_1.AuxInt) != j+32 || w != x_1.Args[0] || !(p.Op != OpSB && x.Uses == 1 && clobber(x)) {
 			break
 		}
 		v.reset(OpS390XMOVDstore)
@@ -11180,7 +11180,7 @@ func rewriteValueS390X_OpS390XMULLDconst(v *Value) bool {
 	b := v.Block
 	// match: (MULLDconst <t> x [c])
 	// cond: isPowerOfTwo32(c&(c-1))
-	// result: (ADD (SLDconst <t> x [int8(log32(c&(c-1)))]) (SLDconst <t> x [int8(log32(c&^(c-1)))]))
+	// result: (ADD (SLDconst <t> x [uint8(log32(c&(c-1)))]) (SLDconst <t> x [uint8(log32(c&^(c-1)))]))
 	for {
 		t := v.Type
 		c := auxIntToInt32(v.AuxInt)
@@ -11190,17 +11190,17 @@ func rewriteValueS390X_OpS390XMULLDconst(v *Value) bool {
 		}
 		v.reset(OpS390XADD)
 		v0 := b.NewValue0(v.Pos, OpS390XSLDconst, t)
-		v0.AuxInt = int8ToAuxInt(int8(log32(c & (c - 1))))
+		v0.AuxInt = uint8ToAuxInt(uint8(log32(c & (c - 1))))
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpS390XSLDconst, t)
-		v1.AuxInt = int8ToAuxInt(int8(log32(c &^ (c - 1))))
+		v1.AuxInt = uint8ToAuxInt(uint8(log32(c &^ (c - 1))))
 		v1.AddArg(x)
 		v.AddArg2(v0, v1)
 		return true
 	}
 	// match: (MULLDconst <t> x [c])
 	// cond: isPowerOfTwo32(c+(c&^(c-1)))
-	// result: (SUB (SLDconst <t> x [int8(log32(c+(c&^(c-1))))]) (SLDconst <t> x [int8(log32(c&^(c-1)))]))
+	// result: (SUB (SLDconst <t> x [uint8(log32(c+(c&^(c-1))))]) (SLDconst <t> x [uint8(log32(c&^(c-1)))]))
 	for {
 		t := v.Type
 		c := auxIntToInt32(v.AuxInt)
@@ -11210,17 +11210,17 @@ func rewriteValueS390X_OpS390XMULLDconst(v *Value) bool {
 		}
 		v.reset(OpS390XSUB)
 		v0 := b.NewValue0(v.Pos, OpS390XSLDconst, t)
-		v0.AuxInt = int8ToAuxInt(int8(log32(c + (c &^ (c - 1)))))
+		v0.AuxInt = uint8ToAuxInt(uint8(log32(c + (c &^ (c - 1)))))
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpS390XSLDconst, t)
-		v1.AuxInt = int8ToAuxInt(int8(log32(c &^ (c - 1))))
+		v1.AuxInt = uint8ToAuxInt(uint8(log32(c &^ (c - 1))))
 		v1.AddArg(x)
 		v.AddArg2(v0, v1)
 		return true
 	}
 	// match: (MULLDconst <t> x [c])
 	// cond: isPowerOfTwo32(-c+(-c&^(-c-1)))
-	// result: (SUB (SLDconst <t> x [int8(log32(-c&^(-c-1)))]) (SLDconst <t> x [int8(log32(-c+(-c&^(-c-1))))]))
+	// result: (SUB (SLDconst <t> x [uint8(log32(-c&^(-c-1)))]) (SLDconst <t> x [uint8(log32(-c+(-c&^(-c-1))))]))
 	for {
 		t := v.Type
 		c := auxIntToInt32(v.AuxInt)
@@ -11230,10 +11230,10 @@ func rewriteValueS390X_OpS390XMULLDconst(v *Value) bool {
 		}
 		v.reset(OpS390XSUB)
 		v0 := b.NewValue0(v.Pos, OpS390XSLDconst, t)
-		v0.AuxInt = int8ToAuxInt(int8(log32(-c &^ (-c - 1))))
+		v0.AuxInt = uint8ToAuxInt(uint8(log32(-c &^ (-c - 1))))
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpS390XSLDconst, t)
-		v1.AuxInt = int8ToAuxInt(int8(log32(-c + (-c &^ (-c - 1)))))
+		v1.AuxInt = uint8ToAuxInt(uint8(log32(-c + (-c &^ (-c - 1)))))
 		v1.AddArg(x)
 		v.AddArg2(v0, v1)
 		return true
@@ -11407,7 +11407,7 @@ func rewriteValueS390X_OpS390XMULLWconst(v *Value) bool {
 	b := v.Block
 	// match: (MULLWconst <t> x [c])
 	// cond: isPowerOfTwo32(c&(c-1))
-	// result: (ADDW (SLWconst <t> x [int8(log32(c&(c-1)))]) (SLWconst <t> x [int8(log32(c&^(c-1)))]))
+	// result: (ADDW (SLWconst <t> x [uint8(log32(c&(c-1)))]) (SLWconst <t> x [uint8(log32(c&^(c-1)))]))
 	for {
 		t := v.Type
 		c := auxIntToInt32(v.AuxInt)
@@ -11417,17 +11417,17 @@ func rewriteValueS390X_OpS390XMULLWconst(v *Value) bool {
 		}
 		v.reset(OpS390XADDW)
 		v0 := b.NewValue0(v.Pos, OpS390XSLWconst, t)
-		v0.AuxInt = int8ToAuxInt(int8(log32(c & (c - 1))))
+		v0.AuxInt = uint8ToAuxInt(uint8(log32(c & (c - 1))))
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpS390XSLWconst, t)
-		v1.AuxInt = int8ToAuxInt(int8(log32(c &^ (c - 1))))
+		v1.AuxInt = uint8ToAuxInt(uint8(log32(c &^ (c - 1))))
 		v1.AddArg(x)
 		v.AddArg2(v0, v1)
 		return true
 	}
 	// match: (MULLWconst <t> x [c])
 	// cond: isPowerOfTwo32(c+(c&^(c-1)))
-	// result: (SUBW (SLWconst <t> x [int8(log32(c+(c&^(c-1))))]) (SLWconst <t> x [int8(log32(c&^(c-1)))]))
+	// result: (SUBW (SLWconst <t> x [uint8(log32(c+(c&^(c-1))))]) (SLWconst <t> x [uint8(log32(c&^(c-1)))]))
 	for {
 		t := v.Type
 		c := auxIntToInt32(v.AuxInt)
@@ -11437,17 +11437,17 @@ func rewriteValueS390X_OpS390XMULLWconst(v *Value) bool {
 		}
 		v.reset(OpS390XSUBW)
 		v0 := b.NewValue0(v.Pos, OpS390XSLWconst, t)
-		v0.AuxInt = int8ToAuxInt(int8(log32(c + (c &^ (c - 1)))))
+		v0.AuxInt = uint8ToAuxInt(uint8(log32(c + (c &^ (c - 1)))))
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpS390XSLWconst, t)
-		v1.AuxInt = int8ToAuxInt(int8(log32(c &^ (c - 1))))
+		v1.AuxInt = uint8ToAuxInt(uint8(log32(c &^ (c - 1))))
 		v1.AddArg(x)
 		v.AddArg2(v0, v1)
 		return true
 	}
 	// match: (MULLWconst <t> x [c])
 	// cond: isPowerOfTwo32(-c+(-c&^(-c-1)))
-	// result: (SUBW (SLWconst <t> x [int8(log32(-c&^(-c-1)))]) (SLWconst <t> x [int8(log32(-c+(-c&^(-c-1))))]))
+	// result: (SUBW (SLWconst <t> x [uint8(log32(-c&^(-c-1)))]) (SLWconst <t> x [uint8(log32(-c+(-c&^(-c-1))))]))
 	for {
 		t := v.Type
 		c := auxIntToInt32(v.AuxInt)
@@ -11457,10 +11457,10 @@ func rewriteValueS390X_OpS390XMULLWconst(v *Value) bool {
 		}
 		v.reset(OpS390XSUBW)
 		v0 := b.NewValue0(v.Pos, OpS390XSLWconst, t)
-		v0.AuxInt = int8ToAuxInt(int8(log32(-c &^ (-c - 1))))
+		v0.AuxInt = uint8ToAuxInt(uint8(log32(-c &^ (-c - 1))))
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpS390XSLWconst, t)
-		v1.AuxInt = int8ToAuxInt(int8(log32(-c + (-c &^ (-c - 1)))))
+		v1.AuxInt = uint8ToAuxInt(uint8(log32(-c + (-c &^ (-c - 1)))))
 		v1.AddArg(x)
 		v.AddArg2(v0, v1)
 		return true
@@ -11640,9 +11640,9 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 			if v_0.Op != OpS390XSLDconst {
 				continue
 			}
-			c := auxIntToInt8(v_0.AuxInt)
+			c := auxIntToUint8(v_0.AuxInt)
 			x := v_0.Args[0]
-			if v_1.Op != OpS390XSRDconst || auxIntToInt8(v_1.AuxInt) != 64-c || x != v_1.Args[0] {
+			if v_1.Op != OpS390XSRDconst || auxIntToUint8(v_1.AuxInt) != 64-c || x != v_1.Args[0] {
 				continue
 			}
 			v.reset(OpS390XRISBGZ)
@@ -11804,7 +11804,7 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 			mem := x1.Args[1]
 			p := x1.Args[0]
 			sh := v_1
-			if sh.Op != OpS390XSLDconst || auxIntToInt8(sh.AuxInt) != 8 {
+			if sh.Op != OpS390XSLDconst || auxIntToUint8(sh.AuxInt) != 8 {
 				continue
 			}
 			x0 := sh.Args[0]
@@ -11843,7 +11843,7 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 			mem := x1.Args[1]
 			p := x1.Args[0]
 			sh := v_1
-			if sh.Op != OpS390XSLDconst || auxIntToInt8(sh.AuxInt) != 16 {
+			if sh.Op != OpS390XSLDconst || auxIntToUint8(sh.AuxInt) != 16 {
 				continue
 			}
 			x0 := sh.Args[0]
@@ -11882,7 +11882,7 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 			mem := x1.Args[1]
 			p := x1.Args[0]
 			sh := v_1
-			if sh.Op != OpS390XSLDconst || auxIntToInt8(sh.AuxInt) != 32 {
+			if sh.Op != OpS390XSLDconst || auxIntToUint8(sh.AuxInt) != 32 {
 				continue
 			}
 			x0 := sh.Args[0]
@@ -11916,7 +11916,7 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 			if s0.Op != OpS390XSLDconst {
 				continue
 			}
-			j0 := auxIntToInt8(s0.AuxInt)
+			j0 := auxIntToUint8(s0.AuxInt)
 			x0 := s0.Args[0]
 			if x0.Op != OpS390XMOVBZload {
 				continue
@@ -11937,7 +11937,7 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 				if s1.Op != OpS390XSLDconst {
 					continue
 				}
-				j1 := auxIntToInt8(s1.AuxInt)
+				j1 := auxIntToUint8(s1.AuxInt)
 				x1 := s1.Args[0]
 				if x1.Op != OpS390XMOVBZload {
 					continue
@@ -11958,7 +11958,7 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 				v0 := b.NewValue0(x1.Pos, OpS390XOR, v.Type)
 				v.copyOf(v0)
 				v1 := b.NewValue0(x1.Pos, OpS390XSLDconst, v.Type)
-				v1.AuxInt = int8ToAuxInt(j1)
+				v1.AuxInt = uint8ToAuxInt(j1)
 				v2 := b.NewValue0(x1.Pos, OpS390XMOVHZload, typ.UInt16)
 				v2.AuxInt = int32ToAuxInt(i0)
 				v2.Aux = symToAux(s)
@@ -11979,7 +11979,7 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 			if s0.Op != OpS390XSLDconst {
 				continue
 			}
-			j0 := auxIntToInt8(s0.AuxInt)
+			j0 := auxIntToUint8(s0.AuxInt)
 			x0 := s0.Args[0]
 			if x0.Op != OpS390XMOVHZload {
 				continue
@@ -12000,7 +12000,7 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 				if s1.Op != OpS390XSLDconst {
 					continue
 				}
-				j1 := auxIntToInt8(s1.AuxInt)
+				j1 := auxIntToUint8(s1.AuxInt)
 				x1 := s1.Args[0]
 				if x1.Op != OpS390XMOVHZload {
 					continue
@@ -12021,7 +12021,7 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 				v0 := b.NewValue0(x1.Pos, OpS390XOR, v.Type)
 				v.copyOf(v0)
 				v1 := b.NewValue0(x1.Pos, OpS390XSLDconst, v.Type)
-				v1.AuxInt = int8ToAuxInt(j1)
+				v1.AuxInt = uint8ToAuxInt(j1)
 				v2 := b.NewValue0(x1.Pos, OpS390XMOVWZload, typ.UInt32)
 				v2.AuxInt = int32ToAuxInt(i0)
 				v2.Aux = symToAux(s)
@@ -12047,7 +12047,7 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 			mem := x0.Args[1]
 			p := x0.Args[0]
 			sh := v_1
-			if sh.Op != OpS390XSLDconst || auxIntToInt8(sh.AuxInt) != 8 {
+			if sh.Op != OpS390XSLDconst || auxIntToUint8(sh.AuxInt) != 8 {
 				continue
 			}
 			x1 := sh.Args[0]
@@ -12092,7 +12092,7 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 			mem := x0.Args[1]
 			p := x0.Args[0]
 			sh := v_1
-			if sh.Op != OpS390XSLDconst || auxIntToInt8(sh.AuxInt) != 16 {
+			if sh.Op != OpS390XSLDconst || auxIntToUint8(sh.AuxInt) != 16 {
 				continue
 			}
 			r1 := sh.Args[0]
@@ -12141,7 +12141,7 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 			mem := x0.Args[1]
 			p := x0.Args[0]
 			sh := v_1
-			if sh.Op != OpS390XSLDconst || auxIntToInt8(sh.AuxInt) != 32 {
+			if sh.Op != OpS390XSLDconst || auxIntToUint8(sh.AuxInt) != 32 {
 				continue
 			}
 			r1 := sh.Args[0]
@@ -12179,7 +12179,7 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 			if s1.Op != OpS390XSLDconst {
 				continue
 			}
-			j1 := auxIntToInt8(s1.AuxInt)
+			j1 := auxIntToUint8(s1.AuxInt)
 			x1 := s1.Args[0]
 			if x1.Op != OpS390XMOVBZload {
 				continue
@@ -12200,7 +12200,7 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 				if s0.Op != OpS390XSLDconst {
 					continue
 				}
-				j0 := auxIntToInt8(s0.AuxInt)
+				j0 := auxIntToUint8(s0.AuxInt)
 				x0 := s0.Args[0]
 				if x0.Op != OpS390XMOVBZload {
 					continue
@@ -12221,7 +12221,7 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 				v0 := b.NewValue0(x0.Pos, OpS390XOR, v.Type)
 				v.copyOf(v0)
 				v1 := b.NewValue0(x0.Pos, OpS390XSLDconst, v.Type)
-				v1.AuxInt = int8ToAuxInt(j0)
+				v1.AuxInt = uint8ToAuxInt(j0)
 				v2 := b.NewValue0(x0.Pos, OpS390XMOVHZreg, typ.UInt64)
 				v3 := b.NewValue0(x0.Pos, OpS390XMOVHBRload, typ.UInt16)
 				v3.AuxInt = int32ToAuxInt(i0)
@@ -12244,7 +12244,7 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 			if s1.Op != OpS390XSLDconst {
 				continue
 			}
-			j1 := auxIntToInt8(s1.AuxInt)
+			j1 := auxIntToUint8(s1.AuxInt)
 			r1 := s1.Args[0]
 			if r1.Op != OpS390XMOVHZreg {
 				continue
@@ -12269,7 +12269,7 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 				if s0.Op != OpS390XSLDconst {
 					continue
 				}
-				j0 := auxIntToInt8(s0.AuxInt)
+				j0 := auxIntToUint8(s0.AuxInt)
 				r0 := s0.Args[0]
 				if r0.Op != OpS390XMOVHZreg {
 					continue
@@ -12294,7 +12294,7 @@ func rewriteValueS390X_OpS390XOR(v *Value) bool {
 				v0 := b.NewValue0(x0.Pos, OpS390XOR, v.Type)
 				v.copyOf(v0)
 				v1 := b.NewValue0(x0.Pos, OpS390XSLDconst, v.Type)
-				v1.AuxInt = int8ToAuxInt(j0)
+				v1.AuxInt = uint8ToAuxInt(j0)
 				v2 := b.NewValue0(x0.Pos, OpS390XMOVWZreg, typ.UInt64)
 				v3 := b.NewValue0(x0.Pos, OpS390XMOVWBRload, typ.UInt32)
 				v3.AuxInt = int32ToAuxInt(i0)
@@ -12338,13 +12338,13 @@ func rewriteValueS390X_OpS390XORW(v *Value) bool {
 			if v_0.Op != OpS390XSLWconst {
 				continue
 			}
-			c := auxIntToInt8(v_0.AuxInt)
+			c := auxIntToUint8(v_0.AuxInt)
 			x := v_0.Args[0]
-			if v_1.Op != OpS390XSRWconst || auxIntToInt8(v_1.AuxInt) != 32-c || x != v_1.Args[0] {
+			if v_1.Op != OpS390XSRWconst || auxIntToUint8(v_1.AuxInt) != 32-c || x != v_1.Args[0] {
 				continue
 			}
 			v.reset(OpS390XRLLconst)
-			v.AuxInt = int8ToAuxInt(c)
+			v.AuxInt = uint8ToAuxInt(c)
 			v.AddArg(x)
 			return true
 		}
@@ -12428,7 +12428,7 @@ func rewriteValueS390X_OpS390XORW(v *Value) bool {
 			mem := x1.Args[1]
 			p := x1.Args[0]
 			sh := v_1
-			if sh.Op != OpS390XSLWconst || auxIntToInt8(sh.AuxInt) != 8 {
+			if sh.Op != OpS390XSLWconst || auxIntToUint8(sh.AuxInt) != 8 {
 				continue
 			}
 			x0 := sh.Args[0]
@@ -12467,7 +12467,7 @@ func rewriteValueS390X_OpS390XORW(v *Value) bool {
 			mem := x1.Args[1]
 			p := x1.Args[0]
 			sh := v_1
-			if sh.Op != OpS390XSLWconst || auxIntToInt8(sh.AuxInt) != 16 {
+			if sh.Op != OpS390XSLWconst || auxIntToUint8(sh.AuxInt) != 16 {
 				continue
 			}
 			x0 := sh.Args[0]
@@ -12501,7 +12501,7 @@ func rewriteValueS390X_OpS390XORW(v *Value) bool {
 			if s0.Op != OpS390XSLWconst {
 				continue
 			}
-			j0 := auxIntToInt8(s0.AuxInt)
+			j0 := auxIntToUint8(s0.AuxInt)
 			x0 := s0.Args[0]
 			if x0.Op != OpS390XMOVBZload {
 				continue
@@ -12522,7 +12522,7 @@ func rewriteValueS390X_OpS390XORW(v *Value) bool {
 				if s1.Op != OpS390XSLWconst {
 					continue
 				}
-				j1 := auxIntToInt8(s1.AuxInt)
+				j1 := auxIntToUint8(s1.AuxInt)
 				x1 := s1.Args[0]
 				if x1.Op != OpS390XMOVBZload {
 					continue
@@ -12543,7 +12543,7 @@ func rewriteValueS390X_OpS390XORW(v *Value) bool {
 				v0 := b.NewValue0(x1.Pos, OpS390XORW, v.Type)
 				v.copyOf(v0)
 				v1 := b.NewValue0(x1.Pos, OpS390XSLWconst, v.Type)
-				v1.AuxInt = int8ToAuxInt(j1)
+				v1.AuxInt = uint8ToAuxInt(j1)
 				v2 := b.NewValue0(x1.Pos, OpS390XMOVHZload, typ.UInt16)
 				v2.AuxInt = int32ToAuxInt(i0)
 				v2.Aux = symToAux(s)
@@ -12569,7 +12569,7 @@ func rewriteValueS390X_OpS390XORW(v *Value) bool {
 			mem := x0.Args[1]
 			p := x0.Args[0]
 			sh := v_1
-			if sh.Op != OpS390XSLWconst || auxIntToInt8(sh.AuxInt) != 8 {
+			if sh.Op != OpS390XSLWconst || auxIntToUint8(sh.AuxInt) != 8 {
 				continue
 			}
 			x1 := sh.Args[0]
@@ -12614,7 +12614,7 @@ func rewriteValueS390X_OpS390XORW(v *Value) bool {
 			mem := x0.Args[1]
 			p := x0.Args[0]
 			sh := v_1
-			if sh.Op != OpS390XSLWconst || auxIntToInt8(sh.AuxInt) != 16 {
+			if sh.Op != OpS390XSLWconst || auxIntToUint8(sh.AuxInt) != 16 {
 				continue
 			}
 			r1 := sh.Args[0]
@@ -12652,7 +12652,7 @@ func rewriteValueS390X_OpS390XORW(v *Value) bool {
 			if s1.Op != OpS390XSLWconst {
 				continue
 			}
-			j1 := auxIntToInt8(s1.AuxInt)
+			j1 := auxIntToUint8(s1.AuxInt)
 			x1 := s1.Args[0]
 			if x1.Op != OpS390XMOVBZload {
 				continue
@@ -12673,7 +12673,7 @@ func rewriteValueS390X_OpS390XORW(v *Value) bool {
 				if s0.Op != OpS390XSLWconst {
 					continue
 				}
-				j0 := auxIntToInt8(s0.AuxInt)
+				j0 := auxIntToUint8(s0.AuxInt)
 				x0 := s0.Args[0]
 				if x0.Op != OpS390XMOVBZload {
 					continue
@@ -12694,7 +12694,7 @@ func rewriteValueS390X_OpS390XORW(v *Value) bool {
 				v0 := b.NewValue0(x0.Pos, OpS390XORW, v.Type)
 				v.copyOf(v0)
 				v1 := b.NewValue0(x0.Pos, OpS390XSLWconst, v.Type)
-				v1.AuxInt = int8ToAuxInt(j0)
+				v1.AuxInt = uint8ToAuxInt(j0)
 				v2 := b.NewValue0(x0.Pos, OpS390XMOVHZreg, typ.UInt64)
 				v3 := b.NewValue0(x0.Pos, OpS390XMOVHBRload, typ.UInt16)
 				v3.AuxInt = int32ToAuxInt(i0)
@@ -12974,7 +12974,7 @@ func rewriteValueS390X_OpS390XRISBGZ(v *Value) bool {
 		if v_0.Op != OpS390XSLDconst {
 			break
 		}
-		c := auxIntToInt8(v_0.AuxInt)
+		c := auxIntToUint8(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(r.InMerge(^uint64(0)<<c) != nil) {
 			break
@@ -12992,7 +12992,7 @@ func rewriteValueS390X_OpS390XRISBGZ(v *Value) bool {
 		if v_0.Op != OpS390XSRDconst {
 			break
 		}
-		c := auxIntToInt8(v_0.AuxInt)
+		c := auxIntToUint8(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(r.InMerge(^uint64(0)>>c) != nil) {
 			break
@@ -13030,7 +13030,7 @@ func rewriteValueS390X_OpS390XRISBGZ(v *Value) bool {
 			break
 		}
 		v.reset(OpS390XSRDconst)
-		v.AuxInt = int8ToAuxInt(-r.Amount & 63)
+		v.AuxInt = uint8ToAuxInt(-r.Amount & 63)
 		v.AddArg(x)
 		return true
 	}
@@ -13044,7 +13044,7 @@ func rewriteValueS390X_OpS390XRISBGZ(v *Value) bool {
 			break
 		}
 		v.reset(OpS390XSLDconst)
-		v.AuxInt = int8ToAuxInt(r.Amount)
+		v.AuxInt = uint8ToAuxInt(r.Amount)
 		v.AddArg(x)
 		return true
 	}
@@ -13056,7 +13056,7 @@ func rewriteValueS390X_OpS390XRISBGZ(v *Value) bool {
 		if v_0.Op != OpS390XSRADconst {
 			break
 		}
-		c := auxIntToInt8(v_0.AuxInt)
+		c := auxIntToUint8(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(r.Start == r.End && (r.Start+r.Amount)&63 <= c) {
 			break
@@ -13131,7 +13131,7 @@ func rewriteValueS390X_OpS390XRLL(v *Value) bool {
 	v_1 := v.Args[1]
 	v_0 := v.Args[0]
 	// match: (RLL x (MOVDconst [c]))
-	// result: (RLLconst x [int8(c&31)])
+	// result: (RLLconst x [uint8(c&31)])
 	for {
 		x := v_0
 		if v_1.Op != OpS390XMOVDconst {
@@ -13139,7 +13139,7 @@ func rewriteValueS390X_OpS390XRLL(v *Value) bool {
 		}
 		c := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpS390XRLLconst)
-		v.AuxInt = int8ToAuxInt(int8(c & 31))
+		v.AuxInt = uint8ToAuxInt(uint8(c & 31))
 		v.AddArg(x)
 		return true
 	}
@@ -13149,7 +13149,7 @@ func rewriteValueS390X_OpS390XRLLG(v *Value) bool {
 	v_1 := v.Args[1]
 	v_0 := v.Args[0]
 	// match: (RLLG x (MOVDconst [c]))
-	// result: (RISBGZ x {s390x.NewRotateParams(0, 63, int8(c&63))})
+	// result: (RISBGZ x {s390x.NewRotateParams(0, 63, uint8(c&63))})
 	for {
 		x := v_0
 		if v_1.Op != OpS390XMOVDconst {
@@ -13157,7 +13157,7 @@ func rewriteValueS390X_OpS390XRLLG(v *Value) bool {
 		}
 		c := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpS390XRISBGZ)
-		v.Aux = s390xRotateParamsToAux(s390x.NewRotateParams(0, 63, int8(c&63)))
+		v.Aux = s390xRotateParamsToAux(s390x.NewRotateParams(0, 63, uint8(c&63)))
 		v.AddArg(x)
 		return true
 	}
@@ -13169,7 +13169,7 @@ func rewriteValueS390X_OpS390XSLD(v *Value) bool {
 	b := v.Block
 	typ := &b.Func.Config.Types
 	// match: (SLD x (MOVDconst [c]))
-	// result: (SLDconst x [int8(c&63)])
+	// result: (SLDconst x [uint8(c&63)])
 	for {
 		x := v_0
 		if v_1.Op != OpS390XMOVDconst {
@@ -13177,7 +13177,7 @@ func rewriteValueS390X_OpS390XSLD(v *Value) bool {
 		}
 		c := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpS390XSLDconst)
-		v.AuxInt = int8ToAuxInt(int8(c & 63))
+		v.AuxInt = uint8ToAuxInt(uint8(c & 63))
 		v.AddArg(x)
 		return true
 	}
@@ -13317,16 +13317,16 @@ func rewriteValueS390X_OpS390XSLD(v *Value) bool {
 func rewriteValueS390X_OpS390XSLDconst(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (SLDconst (SRDconst x [c]) [d])
-	// result: (RISBGZ x {s390x.NewRotateParams(max8(0, c-d), 63-d, (d-c)&63)})
+	// result: (RISBGZ x {s390x.NewRotateParams(uint8(max8(0, int8(c-d))), 63-d, uint8(int8(d-c)&63))})
 	for {
-		d := auxIntToInt8(v.AuxInt)
+		d := auxIntToUint8(v.AuxInt)
 		if v_0.Op != OpS390XSRDconst {
 			break
 		}
-		c := auxIntToInt8(v_0.AuxInt)
+		c := auxIntToUint8(v_0.AuxInt)
 		x := v_0.Args[0]
 		v.reset(OpS390XRISBGZ)
-		v.Aux = s390xRotateParamsToAux(s390x.NewRotateParams(max8(0, c-d), 63-d, (d-c)&63))
+		v.Aux = s390xRotateParamsToAux(s390x.NewRotateParams(uint8(max8(0, int8(c-d))), 63-d, uint8(int8(d-c)&63)))
 		v.AddArg(x)
 		return true
 	}
@@ -13334,7 +13334,7 @@ func rewriteValueS390X_OpS390XSLDconst(v *Value) bool {
 	// cond: s390x.NewRotateParams(0, 63-c, c).InMerge(r.OutMask()) != nil
 	// result: (RISBGZ x {(*s390x.NewRotateParams(0, 63-c, c).InMerge(r.OutMask())).RotateLeft(r.Amount)})
 	for {
-		c := auxIntToInt8(v.AuxInt)
+		c := auxIntToUint8(v.AuxInt)
 		if v_0.Op != OpS390XRISBGZ {
 			break
 		}
@@ -13351,7 +13351,7 @@ func rewriteValueS390X_OpS390XSLDconst(v *Value) bool {
 	// match: (SLDconst x [0])
 	// result: x
 	for {
-		if auxIntToInt8(v.AuxInt) != 0 {
+		if auxIntToUint8(v.AuxInt) != 0 {
 			break
 		}
 		x := v_0
@@ -13367,7 +13367,7 @@ func rewriteValueS390X_OpS390XSLW(v *Value) bool {
 	typ := &b.Func.Config.Types
 	// match: (SLW x (MOVDconst [c]))
 	// cond: c&32 == 0
-	// result: (SLWconst x [int8(c&31)])
+	// result: (SLWconst x [uint8(c&31)])
 	for {
 		x := v_0
 		if v_1.Op != OpS390XMOVDconst {
@@ -13378,7 +13378,7 @@ func rewriteValueS390X_OpS390XSLW(v *Value) bool {
 			break
 		}
 		v.reset(OpS390XSLWconst)
-		v.AuxInt = int8ToAuxInt(int8(c & 31))
+		v.AuxInt = uint8ToAuxInt(uint8(c & 31))
 		v.AddArg(x)
 		return true
 	}
@@ -13535,7 +13535,7 @@ func rewriteValueS390X_OpS390XSLWconst(v *Value) bool {
 	// match: (SLWconst x [0])
 	// result: x
 	for {
-		if auxIntToInt8(v.AuxInt) != 0 {
+		if auxIntToUint8(v.AuxInt) != 0 {
 			break
 		}
 		x := v_0
@@ -13550,7 +13550,7 @@ func rewriteValueS390X_OpS390XSRAD(v *Value) bool {
 	b := v.Block
 	typ := &b.Func.Config.Types
 	// match: (SRAD x (MOVDconst [c]))
-	// result: (SRADconst x [int8(c&63)])
+	// result: (SRADconst x [uint8(c&63)])
 	for {
 		x := v_0
 		if v_1.Op != OpS390XMOVDconst {
@@ -13558,7 +13558,7 @@ func rewriteValueS390X_OpS390XSRAD(v *Value) bool {
 		}
 		c := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpS390XSRADconst)
-		v.AuxInt = int8ToAuxInt(int8(c & 63))
+		v.AuxInt = uint8ToAuxInt(uint8(c & 63))
 		v.AddArg(x)
 		return true
 	}
@@ -13700,7 +13700,7 @@ func rewriteValueS390X_OpS390XSRADconst(v *Value) bool {
 	// match: (SRADconst x [0])
 	// result: x
 	for {
-		if auxIntToInt8(v.AuxInt) != 0 {
+		if auxIntToUint8(v.AuxInt) != 0 {
 			break
 		}
 		x := v_0
@@ -13710,7 +13710,7 @@ func rewriteValueS390X_OpS390XSRADconst(v *Value) bool {
 	// match: (SRADconst [c] (MOVDconst [d]))
 	// result: (MOVDconst [d>>uint64(c)])
 	for {
-		c := auxIntToInt8(v.AuxInt)
+		c := auxIntToUint8(v.AuxInt)
 		if v_0.Op != OpS390XMOVDconst {
 			break
 		}
@@ -13728,7 +13728,7 @@ func rewriteValueS390X_OpS390XSRAW(v *Value) bool {
 	typ := &b.Func.Config.Types
 	// match: (SRAW x (MOVDconst [c]))
 	// cond: c&32 == 0
-	// result: (SRAWconst x [int8(c&31)])
+	// result: (SRAWconst x [uint8(c&31)])
 	for {
 		x := v_0
 		if v_1.Op != OpS390XMOVDconst {
@@ -13739,7 +13739,7 @@ func rewriteValueS390X_OpS390XSRAW(v *Value) bool {
 			break
 		}
 		v.reset(OpS390XSRAWconst)
-		v.AuxInt = int8ToAuxInt(int8(c & 31))
+		v.AuxInt = uint8ToAuxInt(uint8(c & 31))
 		v.AddArg(x)
 		return true
 	}
@@ -13756,7 +13756,7 @@ func rewriteValueS390X_OpS390XSRAW(v *Value) bool {
 			break
 		}
 		v.reset(OpS390XSRAWconst)
-		v.AuxInt = int8ToAuxInt(31)
+		v.AuxInt = uint8ToAuxInt(31)
 		v.AddArg(x)
 		return true
 	}
@@ -13898,7 +13898,7 @@ func rewriteValueS390X_OpS390XSRAWconst(v *Value) bool {
 	// match: (SRAWconst x [0])
 	// result: x
 	for {
-		if auxIntToInt8(v.AuxInt) != 0 {
+		if auxIntToUint8(v.AuxInt) != 0 {
 			break
 		}
 		x := v_0
@@ -13908,7 +13908,7 @@ func rewriteValueS390X_OpS390XSRAWconst(v *Value) bool {
 	// match: (SRAWconst [c] (MOVDconst [d]))
 	// result: (MOVDconst [int64(int32(d))>>uint64(c)])
 	for {
-		c := auxIntToInt8(v.AuxInt)
+		c := auxIntToUint8(v.AuxInt)
 		if v_0.Op != OpS390XMOVDconst {
 			break
 		}
@@ -13925,7 +13925,7 @@ func rewriteValueS390X_OpS390XSRD(v *Value) bool {
 	b := v.Block
 	typ := &b.Func.Config.Types
 	// match: (SRD x (MOVDconst [c]))
-	// result: (SRDconst x [int8(c&63)])
+	// result: (SRDconst x [uint8(c&63)])
 	for {
 		x := v_0
 		if v_1.Op != OpS390XMOVDconst {
@@ -13933,7 +13933,7 @@ func rewriteValueS390X_OpS390XSRD(v *Value) bool {
 		}
 		c := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpS390XSRDconst)
-		v.AuxInt = int8ToAuxInt(int8(c & 63))
+		v.AuxInt = uint8ToAuxInt(uint8(c & 63))
 		v.AddArg(x)
 		return true
 	}
@@ -14073,16 +14073,16 @@ func rewriteValueS390X_OpS390XSRD(v *Value) bool {
 func rewriteValueS390X_OpS390XSRDconst(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (SRDconst (SLDconst x [c]) [d])
-	// result: (RISBGZ x {s390x.NewRotateParams(d, min8(63, 63-c+d), (c-d)&63)})
+	// result: (RISBGZ x {s390x.NewRotateParams(d, uint8(min8(63, int8(63-c+d))), uint8(int8(c-d)&63))})
 	for {
-		d := auxIntToInt8(v.AuxInt)
+		d := auxIntToUint8(v.AuxInt)
 		if v_0.Op != OpS390XSLDconst {
 			break
 		}
-		c := auxIntToInt8(v_0.AuxInt)
+		c := auxIntToUint8(v_0.AuxInt)
 		x := v_0.Args[0]
 		v.reset(OpS390XRISBGZ)
-		v.Aux = s390xRotateParamsToAux(s390x.NewRotateParams(d, min8(63, 63-c+d), (c-d)&63))
+		v.Aux = s390xRotateParamsToAux(s390x.NewRotateParams(d, uint8(min8(63, int8(63-c+d))), uint8(int8(c-d)&63)))
 		v.AddArg(x)
 		return true
 	}
@@ -14090,7 +14090,7 @@ func rewriteValueS390X_OpS390XSRDconst(v *Value) bool {
 	// cond: s390x.NewRotateParams(c, 63, -c&63).InMerge(r.OutMask()) != nil
 	// result: (RISBGZ x {(*s390x.NewRotateParams(c, 63, -c&63).InMerge(r.OutMask())).RotateLeft(r.Amount)})
 	for {
-		c := auxIntToInt8(v.AuxInt)
+		c := auxIntToUint8(v.AuxInt)
 		if v_0.Op != OpS390XRISBGZ {
 			break
 		}
@@ -14107,7 +14107,7 @@ func rewriteValueS390X_OpS390XSRDconst(v *Value) bool {
 	// match: (SRDconst x [0])
 	// result: x
 	for {
-		if auxIntToInt8(v.AuxInt) != 0 {
+		if auxIntToUint8(v.AuxInt) != 0 {
 			break
 		}
 		x := v_0
@@ -14123,7 +14123,7 @@ func rewriteValueS390X_OpS390XSRW(v *Value) bool {
 	typ := &b.Func.Config.Types
 	// match: (SRW x (MOVDconst [c]))
 	// cond: c&32 == 0
-	// result: (SRWconst x [int8(c&31)])
+	// result: (SRWconst x [uint8(c&31)])
 	for {
 		x := v_0
 		if v_1.Op != OpS390XMOVDconst {
@@ -14134,7 +14134,7 @@ func rewriteValueS390X_OpS390XSRW(v *Value) bool {
 			break
 		}
 		v.reset(OpS390XSRWconst)
-		v.AuxInt = int8ToAuxInt(int8(c & 31))
+		v.AuxInt = uint8ToAuxInt(uint8(c & 31))
 		v.AddArg(x)
 		return true
 	}
@@ -14291,7 +14291,7 @@ func rewriteValueS390X_OpS390XSRWconst(v *Value) bool {
 	// match: (SRWconst x [0])
 	// result: x
 	for {
-		if auxIntToInt8(v.AuxInt) != 0 {
+		if auxIntToUint8(v.AuxInt) != 0 {
 			break
 		}
 		x := v_0
@@ -14339,7 +14339,7 @@ func rewriteValueS390X_OpS390XSTM2(v *Value) bool {
 		i := auxIntToInt32(v.AuxInt)
 		s := auxToSym(v.Aux)
 		p := v_0
-		if v_1.Op != OpS390XSRDconst || auxIntToInt8(v_1.AuxInt) != 32 {
+		if v_1.Op != OpS390XSRDconst || auxIntToUint8(v_1.AuxInt) != 32 {
 			break
 		}
 		x := v_1.Args[0]
@@ -14851,7 +14851,7 @@ func rewriteValueS390X_OpS390XSumBytes2(v *Value) bool {
 		x := v_0
 		v.reset(OpS390XADDW)
 		v0 := b.NewValue0(v.Pos, OpS390XSRWconst, typ.UInt8)
-		v0.AuxInt = int8ToAuxInt(8)
+		v0.AuxInt = uint8ToAuxInt(8)
 		v0.AddArg(x)
 		v.AddArg2(v0, x)
 		return true
@@ -14868,7 +14868,7 @@ func rewriteValueS390X_OpS390XSumBytes4(v *Value) bool {
 		v.reset(OpS390XSumBytes2)
 		v0 := b.NewValue0(v.Pos, OpS390XADDW, typ.UInt16)
 		v1 := b.NewValue0(v.Pos, OpS390XSRWconst, typ.UInt16)
-		v1.AuxInt = int8ToAuxInt(16)
+		v1.AuxInt = uint8ToAuxInt(16)
 		v1.AddArg(x)
 		v0.AddArg2(v1, x)
 		v.AddArg(v0)
@@ -14886,7 +14886,7 @@ func rewriteValueS390X_OpS390XSumBytes8(v *Value) bool {
 		v.reset(OpS390XSumBytes4)
 		v0 := b.NewValue0(v.Pos, OpS390XADDW, typ.UInt32)
 		v1 := b.NewValue0(v.Pos, OpS390XSRDconst, typ.UInt32)
-		v1.AuxInt = int8ToAuxInt(32)
+		v1.AuxInt = uint8ToAuxInt(32)
 		v1.AddArg(x)
 		v0.AddArg2(v1, x)
 		v.AddArg(v0)
@@ -14923,9 +14923,9 @@ func rewriteValueS390X_OpS390XXOR(v *Value) bool {
 			if v_0.Op != OpS390XSLDconst {
 				continue
 			}
-			c := auxIntToInt8(v_0.AuxInt)
+			c := auxIntToUint8(v_0.AuxInt)
 			x := v_0.Args[0]
-			if v_1.Op != OpS390XSRDconst || auxIntToInt8(v_1.AuxInt) != 64-c || x != v_1.Args[0] {
+			if v_1.Op != OpS390XSRDconst || auxIntToUint8(v_1.AuxInt) != 64-c || x != v_1.Args[0] {
 				continue
 			}
 			v.reset(OpS390XRISBGZ)
@@ -15019,13 +15019,13 @@ func rewriteValueS390X_OpS390XXORW(v *Value) bool {
 			if v_0.Op != OpS390XSLWconst {
 				continue
 			}
-			c := auxIntToInt8(v_0.AuxInt)
+			c := auxIntToUint8(v_0.AuxInt)
 			x := v_0.Args[0]
-			if v_1.Op != OpS390XSRWconst || auxIntToInt8(v_1.AuxInt) != 32-c || x != v_1.Args[0] {
+			if v_1.Op != OpS390XSRWconst || auxIntToUint8(v_1.AuxInt) != 32-c || x != v_1.Args[0] {
 				continue
 			}
 			v.reset(OpS390XRLLconst)
-			v.AuxInt = int8ToAuxInt(c)
+			v.AuxInt = uint8ToAuxInt(c)
 			v.AddArg(x)
 			return true
 		}
@@ -15649,7 +15649,7 @@ func rewriteValueS390X_OpSlicemask(v *Value) bool {
 		t := v.Type
 		x := v_0
 		v.reset(OpS390XSRADconst)
-		v.AuxInt = int8ToAuxInt(63)
+		v.AuxInt = uint8ToAuxInt(63)
 		v0 := b.NewValue0(v.Pos, OpS390XNEG, t)
 		v0.AddArg(x)
 		v.AddArg(v0)
diff --git a/src/cmd/internal/obj/s390x/rotate.go b/src/cmd/internal/obj/s390x/rotate.go
index 7dbc45e648..388bd40f41 100644
--- a/src/cmd/internal/obj/s390x/rotate.go
+++ b/src/cmd/internal/obj/s390x/rotate.go
@@ -28,9 +28,9 @@ import (
 // input left by. Note that this rotation is performed
 // before the masked region is used.
 type RotateParams struct {
-	Start  int8 // big-endian start bit index [0..63]
-	End    int8 // big-endian end bit index [0..63]
-	Amount int8 // amount to rotate left
+	Start  uint8 // big-endian start bit index [0..63]
+	End    uint8 // big-endian end bit index [0..63]
+	Amount uint8 // amount to rotate left
 }
 
 // NewRotateParams creates a set of parameters representing a
@@ -39,7 +39,7 @@ type RotateParams struct {
 //
 // The start and end indexes and the rotation amount must all
 // be in the range 0-63 inclusive or this function will panic.
-func NewRotateParams(start, end, amount int8) RotateParams {
+func NewRotateParams(start, end, amount uint8) RotateParams {
 	if start&^63 != 0 {
 		panic("start out of bounds")
 	}
@@ -58,7 +58,7 @@ func NewRotateParams(start, end, amount int8) RotateParams {
 
 // RotateLeft generates a new set of parameters with the rotation amount
 // increased by the given value. The selected bits are left unchanged.
-func (r RotateParams) RotateLeft(amount int8) RotateParams {
+func (r RotateParams) RotateLeft(amount uint8) RotateParams {
 	r.Amount += amount
 	r.Amount &= 63
 	return r
@@ -100,8 +100,8 @@ func (r RotateParams) OutMerge(mask uint64) *RotateParams {
 	}
 
 	// update start and end positions (rotation amount remains the same)
-	r.Start = int8(o+z) & 63
-	r.End = (r.Start + int8(l) - 1) & 63
+	r.Start = uint8(o+z) & 63
+	r.End = (r.Start + uint8(l) - 1) & 63
 	return &r
 }
 
diff --git a/src/cmd/internal/obj/s390x/rotate_test.go b/src/cmd/internal/obj/s390x/rotate_test.go
index fa5b5bdecd..88421b1b83 100644
--- a/src/cmd/internal/obj/s390x/rotate_test.go
+++ b/src/cmd/internal/obj/s390x/rotate_test.go
@@ -10,7 +10,7 @@ import (
 
 func TestRotateParamsMask(t *testing.T) {
 	tests := []struct {
-		start, end, amount int8
+		start, end, amount uint8
 		inMask, outMask    uint64
 	}{
 		// start before end, no rotation
