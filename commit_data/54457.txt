commit 27f094b17cf1e0495515614476ec9137c0ed0a82
Author: Robert Griesemer <gri@golang.org>
Date:   Tue Oct 18 12:34:50 2022 -0700

    go/types, types2: consolidate helper functions for tests (cleanup)
    
    Instead of having various inconsistent helper functions, rely on
    4 helper functions with consistent naming and parameters:
    
    - parse and mustParse
    - typecheck and mustTypecheck
    
    Panic rather than call t.Fatal in the mustX functions to simplify
    their use.
    
    Use the new functions in tests consistently.
    
    Change-Id: Ib19dc5cc470b51512c23c09df32c379dc3eb8f4b
    Reviewed-on: https://go-review.googlesource.com/c/go/+/443757
    Reviewed-by: Robert Griesemer <gri@google.com>
    Run-TryBot: Robert Griesemer <gri@google.com>
    Auto-Submit: Robert Griesemer <gri@google.com>
    TryBot-Result: Gopher Robot <gobot@golang.org>
    Reviewed-by: Robert Findley <rfindley@google.com>
---
 src/cmd/compile/internal/types2/api_test.go        | 178 +++++++--------------
 src/cmd/compile/internal/types2/example_test.go    |  11 +-
 .../compile/internal/types2/instantiate_test.go    |  10 +-
 src/cmd/compile/internal/types2/issues_test.go     |  43 +++--
 src/cmd/compile/internal/types2/named_test.go      |   7 +-
 src/cmd/compile/internal/types2/object_test.go     |   7 +-
 src/cmd/compile/internal/types2/resolver_test.go   |   6 +-
 src/cmd/compile/internal/types2/sizes_test.go      |  14 +-
 src/cmd/compile/internal/types2/stdlib_test.go     |   6 +-
 src/cmd/compile/internal/types2/typestring_test.go |  17 +-
 src/go/types/api_test.go                           | 176 +++++++-------------
 src/go/types/example_test.go                       |  11 +-
 src/go/types/instantiate_test.go                   |  10 +-
 src/go/types/issues_test.go                        |  40 ++---
 src/go/types/methodset_test.go                     |   2 +-
 src/go/types/named_test.go                         |   8 +-
 src/go/types/object_test.go                        |   8 +-
 src/go/types/resolver_test.go                      |   7 +-
 src/go/types/sizes_test.go                         |  15 +-
 src/go/types/stdlib_test.go                        |   6 +-
 src/go/types/typestring_test.go                    |  21 +--
 21 files changed, 197 insertions(+), 406 deletions(-)

diff --git a/src/cmd/compile/internal/types2/api_test.go b/src/cmd/compile/internal/types2/api_test.go
index 9a3e76a07d..ce05cd332e 100644
--- a/src/cmd/compile/internal/types2/api_test.go
+++ b/src/cmd/compile/internal/types2/api_test.go
@@ -18,48 +18,37 @@ import (
 	. "cmd/compile/internal/types2"
 )
 
-// brokenPkg is a source prefix for packages that are not expected to parse
-// or type-check cleanly. They are always parsed assuming that they contain
-// generic code.
-const brokenPkg = "package broken_"
-
-func parseSrc(path, src string) (*syntax.File, error) {
+func parse(path, src string) (*syntax.File, error) {
 	errh := func(error) {} // dummy error handler so that parsing continues in presence of errors
 	return syntax.Parse(syntax.NewFileBase(path), strings.NewReader(src), errh, nil, 0)
 }
 
-func pkgFor(path, source string, info *Info) (*Package, error) {
-	f, err := parseSrc(path, source)
+func mustParse(path, src string) *syntax.File {
+	f, err := parse(path, src)
 	if err != nil {
-		return nil, err
+		panic(err) // so we don't need to pass *testing.T
 	}
-	conf := Config{Importer: defaultImporter()}
-	return conf.Check(f.PkgName.Value, []*syntax.File{f}, info)
-}
-
-func mustTypecheck(t testing.TB, path, source string, info *Info) string {
-	pkg, err := pkgFor(path, source, info)
-	if err != nil {
-		name := path
-		if pkg != nil {
-			name = "package " + pkg.Name()
-		}
-		t.Fatalf("%s: didn't type-check (%s)", name, err)
-	}
-	return pkg.Name()
+	return f
 }
 
-func mayTypecheck(t *testing.T, path, source string, info *Info) (string, error) {
-	f, err := parseSrc(path, source)
+func typecheck(path, src string, info *Info) (*Package, error) {
+	f, err := parse(path, src)
 	if f == nil { // ignore errors unless f is nil
-		t.Fatalf("%s: unable to parse: %s", path, err)
+		return nil, err
 	}
 	conf := Config{
-		Error:    func(err error) {},
+		Error:    func(err error) {}, // collect all errors
 		Importer: defaultImporter(),
 	}
-	pkg, err := conf.Check(f.PkgName.Value, []*syntax.File{f}, info)
-	return pkg.Name(), err
+	return conf.Check(f.PkgName.Value, []*syntax.File{f}, info)
+}
+
+func mustTypecheck(path, src string, info *Info) string {
+	pkg, err := typecheck(path, src, info)
+	if err != nil {
+		panic(err) // so we don't need to pass *testing.T
+	}
+	return pkg.Name()
 }
 
 func TestValuesInfo(t *testing.T) {
@@ -145,7 +134,7 @@ func TestValuesInfo(t *testing.T) {
 		info := Info{
 			Types: make(map[syntax.Expr]TypeAndValue),
 		}
-		name := mustTypecheck(t, "ValuesInfo", test.src, &info)
+		name := mustTypecheck("ValuesInfo", test.src, &info)
 
 		// look for expression
 		var expr syntax.Expr
@@ -181,6 +170,9 @@ func TestValuesInfo(t *testing.T) {
 }
 
 func TestTypesInfo(t *testing.T) {
+	// Test sources that are not expected to typecheck must start with the broken prefix.
+	const brokenPkg = "package broken_"
+
 	var tests = []struct {
 		src  string
 		expr string // expression
@@ -384,14 +376,16 @@ func TestTypesInfo(t *testing.T) {
 		info := Info{Types: make(map[syntax.Expr]TypeAndValue)}
 		var name string
 		if strings.HasPrefix(test.src, brokenPkg) {
-			var err error
-			name, err = mayTypecheck(t, "TypesInfo", test.src, &info)
+			pkg, err := typecheck("TypesInfo", test.src, &info)
 			if err == nil {
-				t.Errorf("package %s: expected to fail but passed", name)
+				t.Errorf("package %s: expected to fail but passed", pkg.Name())
 				continue
 			}
+			if pkg != nil {
+				name = pkg.Name()
+			}
 		} else {
-			name = mustTypecheck(t, "TypesInfo", test.src, &info)
+			name = mustTypecheck("TypesInfo", test.src, &info)
 		}
 
 		// look for expression type
@@ -550,10 +544,7 @@ type T[P any] []P
 		instMap := make(map[*syntax.Name]Instance)
 		useMap := make(map[*syntax.Name]Object)
 		makePkg := func(src string) *Package {
-			f, err := parseSrc("p.go", src)
-			if err != nil {
-				t.Fatal(err)
-			}
+			f := mustParse("p.go", src)
 			pkg, err := conf.Check("", []*syntax.File{f}, &Info{Instances: instMap, Uses: useMap})
 			if err != nil {
 				t.Fatal(err)
@@ -653,7 +644,7 @@ func TestDefsInfo(t *testing.T) {
 		info := Info{
 			Defs: make(map[*syntax.Name]Object),
 		}
-		name := mustTypecheck(t, "DefsInfo", test.src, &info)
+		name := mustTypecheck("DefsInfo", test.src, &info)
 
 		// find object
 		var def Object
@@ -718,7 +709,7 @@ func TestUsesInfo(t *testing.T) {
 		info := Info{
 			Uses: make(map[*syntax.Name]Object),
 		}
-		name := mustTypecheck(t, "UsesInfo", test.src, &info)
+		name := mustTypecheck("UsesInfo", test.src, &info)
 
 		// find object
 		var use Object
@@ -750,10 +741,7 @@ func (r N[B]) m() { r.m(); r.n() }
 
 func (r *N[C]) n() {  }
 `
-	f, err := parseSrc("p.go", src)
-	if err != nil {
-		t.Fatal(err)
-	}
+	f := mustParse("p.go", src)
 	info := Info{
 		Defs:       make(map[*syntax.Name]Object),
 		Uses:       make(map[*syntax.Name]Object),
@@ -861,7 +849,7 @@ func TestImplicitsInfo(t *testing.T) {
 		info := Info{
 			Implicits: make(map[syntax.Node]Object),
 		}
-		name := mustTypecheck(t, "ImplicitsInfo", test.src, &info)
+		name := mustTypecheck("ImplicitsInfo", test.src, &info)
 
 		// the test cases expect at most one Implicits entry
 		if len(info.Implicits) > 1 {
@@ -989,7 +977,7 @@ func TestPredicatesInfo(t *testing.T) {
 
 	for _, test := range tests {
 		info := Info{Types: make(map[syntax.Expr]TypeAndValue)}
-		name := mustTypecheck(t, "PredicatesInfo", test.src, &info)
+		name := mustTypecheck("PredicatesInfo", test.src, &info)
 
 		// look for expression predicates
 		got := "<missing>"
@@ -1081,7 +1069,7 @@ func TestScopesInfo(t *testing.T) {
 
 	for _, test := range tests {
 		info := Info{Scopes: make(map[syntax.Node]*Scope)}
-		name := mustTypecheck(t, "ScopesInfo", test.src, &info)
+		name := mustTypecheck("ScopesInfo", test.src, &info)
 
 		// number of scopes must match
 		if len(info.Scopes) != len(test.scopes) {
@@ -1269,7 +1257,7 @@ func TestInitOrderInfo(t *testing.T) {
 
 	for _, test := range tests {
 		info := Info{}
-		name := mustTypecheck(t, "InitOrderInfo", test.src, &info)
+		name := mustTypecheck("InitOrderInfo", test.src, &info)
 
 		// number of initializers must match
 		if len(info.InitOrder) != len(test.inits) {
@@ -1289,16 +1277,8 @@ func TestInitOrderInfo(t *testing.T) {
 }
 
 func TestMultiFileInitOrder(t *testing.T) {
-	mustParse := func(src string) *syntax.File {
-		f, err := parseSrc("main", src)
-		if err != nil {
-			t.Fatal(err)
-		}
-		return f
-	}
-
-	fileA := mustParse(`package main; var a = 1`)
-	fileB := mustParse(`package main; var b = 2`)
+	fileA := mustParse("", `package main; var a = 1`)
+	fileB := mustParse("", `package main; var b = 2`)
 
 	// The initialization order must not depend on the parse
 	// order of the files, only on the presentation order to
@@ -1335,10 +1315,7 @@ func TestFiles(t *testing.T) {
 
 	for i, src := range sources {
 		filename := fmt.Sprintf("sources%d", i)
-		f, err := parseSrc(filename, src)
-		if err != nil {
-			t.Fatal(err)
-		}
+		f := mustParse(filename, src)
 		if err := check.Files([]*syntax.File{f}); err != nil {
 			t.Error(err)
 		}
@@ -1371,10 +1348,7 @@ func TestSelection(t *testing.T) {
 	imports := make(testImporter)
 	conf := Config{Importer: imports}
 	makePkg := func(path, src string) {
-		f, err := parseSrc(path+".go", src)
-		if err != nil {
-			t.Fatal(err)
-		}
+		f := mustParse(path+".go", src)
 		pkg, err := conf.Check(path, []*syntax.File{f}, &Info{Selections: selections})
 		if err != nil {
 			t.Fatal(err)
@@ -1564,10 +1538,7 @@ func TestIssue8518(t *testing.T) {
 		Importer: imports,
 	}
 	makePkg := func(path, src string) {
-		f, err := parseSrc(path, src)
-		if err != nil {
-			t.Fatal(err)
-		}
+		f := mustParse(path, src)
 		pkg, _ := conf.Check(path, []*syntax.File{f}, nil) // errors logged via conf.Error
 		imports[path] = pkg
 	}
@@ -1655,7 +1626,7 @@ func TestLookupFieldOrMethod(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		pkg, err := pkgFor("test", "package p;"+test.src, nil)
+		pkg, err := typecheck("test", "package p;"+test.src, nil)
 		if err != nil {
 			t.Errorf("%s: incorrect test case: %s", test.src, err)
 			continue
@@ -1704,10 +1675,7 @@ type Node[T any] struct {
 type Instance = *Tree[int]
 `
 
-	f, err := parseSrc("foo.go", src)
-	if err != nil {
-		panic(err)
-	}
+	f := mustParse("foo.go", src)
 	pkg := NewPackage("pkg", f.PkgName.Value)
 	if err := NewChecker(nil, pkg, nil).Files([]*syntax.File{f}); err != nil {
 		panic(err)
@@ -1736,10 +1704,8 @@ func TestScopeLookupParent(t *testing.T) {
 	conf := Config{Importer: imports}
 	var info Info
 	makePkg := func(path, src string) {
-		f, err := parseSrc(path, src)
-		if err != nil {
-			t.Fatal(err)
-		}
+		f := mustParse(path, src)
+		var err error
 		imports[path], err = conf.Check(path, []*syntax.File{f}, &info)
 		if err != nil {
 			t.Fatal(err)
@@ -1946,7 +1912,7 @@ func TestIdentical(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		pkg, err := pkgFor("test", "package p;"+test.src, nil)
+		pkg, err := typecheck("test", "package p;"+test.src, nil)
 		if err != nil {
 			t.Errorf("%s: incorrect test case: %s", test.src, err)
 			continue
@@ -2023,10 +1989,7 @@ func TestIdenticalUnions(t *testing.T) {
 
 func TestIssue15305(t *testing.T) {
 	const src = "package p; func f() int16; var _ = f(undef)"
-	f, err := parseSrc("issue15305.go", src)
-	if err != nil {
-		t.Fatal(err)
-	}
+	f := mustParse("issue15305.go", src)
 	conf := Config{
 		Error: func(err error) {}, // allow errors
 	}
@@ -2061,20 +2024,14 @@ func TestCompositeLitTypes(t *testing.T) {
 		{`struct{}{}`, `struct{}`},
 		{`struct{x, y int; z complex128}{}`, `struct{x int; y int; z complex128}`},
 	} {
-		f, err := parseSrc(test.lit, "package p; var _ = "+test.lit)
-		if err != nil {
-			t.Fatalf("%s: %v", test.lit, err)
-		}
-
-		info := &Info{
-			Types: make(map[syntax.Expr]TypeAndValue),
-		}
-		if _, err = new(Config).Check("p", []*syntax.File{f}, info); err != nil {
+		f := mustParse(test.lit, "package p; var _ = "+test.lit)
+		types := make(map[syntax.Expr]TypeAndValue)
+		if _, err := new(Config).Check("p", []*syntax.File{f}, &Info{Types: types}); err != nil {
 			t.Fatalf("%s: %v", test.lit, err)
 		}
 
 		cmptype := func(x syntax.Expr, want string) {
-			tv, ok := info.Types[x]
+			tv, ok := types[x]
 			if !ok {
 				t.Errorf("%s: no Types entry found", test.lit)
 				return
@@ -2121,15 +2078,12 @@ func (*T1) m2() {}
 func f(x int) { y := x; print(y) }
 `
 
-	f, err := parseSrc("src", src)
-	if err != nil {
-		t.Fatal(err)
-	}
+	f := mustParse("src", src)
 
 	info := &Info{
 		Defs: make(map[*syntax.Name]Object),
 	}
-	if _, err = new(Config).Check("p", []*syntax.File{f}, info); err != nil {
+	if _, err := new(Config).Check("p", []*syntax.File{f}, info); err != nil {
 		t.Fatal(err)
 	}
 
@@ -2182,10 +2136,7 @@ type T = foo.T
 var v T = c
 func f(x T) T { return foo.F(x) }
 `
-	f, err := parseSrc("src", src)
-	if err != nil {
-		t.Fatal(err)
-	}
+	f := mustParse("src", src)
 	files := []*syntax.File{f}
 
 	// type-check using all possible importers
@@ -2240,7 +2191,7 @@ func f(x T) T { return foo.F(x) }
 func TestInstantiate(t *testing.T) {
 	// eventually we like more tests but this is a start
 	const src = "package p; type T[P any] *T[P]"
-	pkg, err := pkgFor(".", src, nil)
+	pkg, err := typecheck(".", src, nil)
 	if err != nil {
 		t.Fatal(err)
 	}
@@ -2278,7 +2229,7 @@ func TestInstantiateErrors(t *testing.T) {
 
 	for _, test := range tests {
 		src := "package p; " + test.src
-		pkg, err := pkgFor(".", src, nil)
+		pkg, err := typecheck(".", src, nil)
 		if err != nil {
 			t.Fatal(err)
 		}
@@ -2319,10 +2270,7 @@ func TestInstanceIdentity(t *testing.T) {
 	imports := make(testImporter)
 	conf := Config{Importer: imports}
 	makePkg := func(src string) {
-		f, err := parseSrc("", src)
-		if err != nil {
-			t.Fatal(err)
-		}
+		f := mustParse("", src)
 		name := f.PkgName.Value
 		pkg, err := conf.Check(name, []*syntax.File{f}, nil)
 		if err != nil {
@@ -2378,10 +2326,7 @@ func fn() {
 	info := &Info{
 		Defs: make(map[*syntax.Name]Object),
 	}
-	f, err := parseSrc("p.go", src)
-	if err != nil {
-		t.Fatal(err)
-	}
+	f := mustParse("p.go", src)
 	conf := Config{}
 	pkg, err := conf.Check(f.PkgName.Value, []*syntax.File{f}, info)
 	if err != nil {
@@ -2512,10 +2457,7 @@ func (N4) m()
 type Bad Bad // invalid type
 `
 
-	f, err := parseSrc("p.go", src)
-	if err != nil {
-		t.Fatal(err)
-	}
+	f := mustParse("p.go", src)
 	conf := Config{Error: func(error) {}}
 	pkg, _ := conf.Check(f.PkgName.Value, []*syntax.File{f}, nil)
 
@@ -2610,7 +2552,7 @@ type V4 struct{}
 func (V4) M()
 `
 
-	pkg, err := pkgFor("p.go", src, nil)
+	pkg, err := typecheck("p.go", src, nil)
 	if err != nil {
 		t.Fatal(err)
 	}
diff --git a/src/cmd/compile/internal/types2/example_test.go b/src/cmd/compile/internal/types2/example_test.go
index 9212c38560..85f5f2a61c 100644
--- a/src/cmd/compile/internal/types2/example_test.go
+++ b/src/cmd/compile/internal/types2/example_test.go
@@ -48,11 +48,7 @@ const Boiling Celsius = 100
 func Unused() { {}; {{ var x int; _ = x }} } // make sure empty block scopes get printed
 `},
 	} {
-		f, err := parseSrc(file.name, file.input)
-		if err != nil {
-			log.Fatal(err)
-		}
-		files = append(files, f)
+		files = append(files, mustParse(file.name, file.input))
 	}
 
 	// Type-check a package consisting of these files.
@@ -123,10 +119,7 @@ func fib(x int) int {
 	}
 	return fib(x-1) - fib(x-2)
 }`
-	f, err := parseSrc("fib.go", input)
-	if err != nil {
-		log.Fatal(err)
-	}
+	f := mustParse("fib.go", input)
 
 	// Type-check the package.
 	// We create an empty map for each kind of input
diff --git a/src/cmd/compile/internal/types2/instantiate_test.go b/src/cmd/compile/internal/types2/instantiate_test.go
index 3c897869fc..1b66d69b47 100644
--- a/src/cmd/compile/internal/types2/instantiate_test.go
+++ b/src/cmd/compile/internal/types2/instantiate_test.go
@@ -107,7 +107,7 @@ func TestInstantiateEquality(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		pkg, err := pkgFor(".", test.src, nil)
+		pkg, err := typecheck(".", test.src, nil)
 		if err != nil {
 			t.Fatal(err)
 		}
@@ -136,11 +136,11 @@ func TestInstantiateEquality(t *testing.T) {
 
 func TestInstantiateNonEquality(t *testing.T) {
 	const src = "package p; type T[P any] int"
-	pkg1, err := pkgFor(".", src, nil)
+	pkg1, err := typecheck(".", src, nil)
 	if err != nil {
 		t.Fatal(err)
 	}
-	pkg2, err := pkgFor(".", src, nil)
+	pkg2, err := typecheck(".", src, nil)
 	if err != nil {
 		t.Fatal(err)
 	}
@@ -188,7 +188,7 @@ var X T[int]
 
 	for _, test := range tests {
 		src := prefix + test.decl
-		pkg, err := pkgFor(".", src, nil)
+		pkg, err := typecheck(".", src, nil)
 		if err != nil {
 			t.Fatal(err)
 		}
@@ -213,7 +213,7 @@ func (T[P]) m() {}
 
 var _ T[int]
 `
-	pkg, err := pkgFor(".", src, nil)
+	pkg, err := typecheck(".", src, nil)
 	if err != nil {
 		t.Fatal(err)
 	}
diff --git a/src/cmd/compile/internal/types2/issues_test.go b/src/cmd/compile/internal/types2/issues_test.go
index f1d402b792..0daef3a795 100644
--- a/src/cmd/compile/internal/types2/issues_test.go
+++ b/src/cmd/compile/internal/types2/issues_test.go
@@ -17,15 +17,8 @@ import (
 	. "cmd/compile/internal/types2"
 )
 
-func mustParse(t *testing.T, src string) *syntax.File {
-	f, err := parseSrc("", src)
-	if err != nil {
-		t.Fatal(err)
-	}
-	return f
-}
 func TestIssue5770(t *testing.T) {
-	f := mustParse(t, `package p; type S struct{T}`)
+	f := mustParse("", `package p; type S struct{T}`)
 	var conf Config
 	_, err := conf.Check(f.PkgName.Value, []*syntax.File{f}, nil) // do not crash
 	const want = "undefined: T"
@@ -47,7 +40,7 @@ var (
 	_ = (interface{})(nil)
 )`
 	types := make(map[syntax.Expr]TypeAndValue)
-	mustTypecheck(t, "p", src, &Info{Types: types})
+	mustTypecheck("p", src, &Info{Types: types})
 
 	for x, tv := range types {
 		var want Type
@@ -86,7 +79,7 @@ func f() int {
 }
 `
 	types := make(map[syntax.Expr]TypeAndValue)
-	mustTypecheck(t, "p", src, &Info{Types: types})
+	mustTypecheck("p", src, &Info{Types: types})
 
 	want := Typ[Int]
 	n := 0
@@ -110,7 +103,7 @@ package p
 func (T) m() (res bool) { return }
 type T struct{} // receiver type after method declaration
 `
-	f := mustParse(t, src)
+	f := mustParse("", src)
 
 	var conf Config
 	defs := make(map[*syntax.Name]Object)
@@ -141,7 +134,7 @@ func _() {
         _, _, _ = x, y, z  // uses x, y, z
 }
 `
-	f := mustParse(t, src)
+	f := mustParse("", src)
 
 	const want = `L3 defs func p._()
 L4 defs const w untyped int
@@ -237,7 +230,7 @@ func main() {
 }
 `
 	f := func(test, src string) {
-		f := mustParse(t, src)
+		f := mustParse("", src)
 		conf := Config{Importer: defaultImporter()}
 		info := Info{Uses: make(map[*syntax.Name]Object)}
 		_, err := conf.Check("main", []*syntax.File{f}, &info)
@@ -267,7 +260,7 @@ func main() {
 }
 
 func TestIssue22525(t *testing.T) {
-	f := mustParse(t, `package p; func f() { var a, b, c, d, e int }`)
+	f := mustParse("", `package p; func f() { var a, b, c, d, e int }`)
 
 	got := "\n"
 	conf := Config{Error: func(err error) { got += err.Error() + "\n" }}
@@ -297,7 +290,7 @@ func TestIssue25627(t *testing.T) {
 		`struct { *I }`,
 		`struct { a int; b Missing; *Missing }`,
 	} {
-		f := mustParse(t, prefix+src)
+		f := mustParse("", prefix+src)
 
 		conf := Config{Importer: defaultImporter(), Error: func(err error) {}}
 		info := &Info{Types: make(map[syntax.Expr]TypeAndValue)}
@@ -334,7 +327,7 @@ func TestIssue28005(t *testing.T) {
 	// compute original file ASTs
 	var orig [len(sources)]*syntax.File
 	for i, src := range sources {
-		orig[i] = mustParse(t, src)
+		orig[i] = mustParse("", src)
 	}
 
 	// run the test for all order permutations of the incoming files
@@ -409,8 +402,8 @@ func TestIssue28282(t *testing.T) {
 }
 
 func TestIssue29029(t *testing.T) {
-	f1 := mustParse(t, `package p; type A interface { M() }`)
-	f2 := mustParse(t, `package p; var B interface { A }`)
+	f1 := mustParse("", `package p; type A interface { M() }`)
+	f2 := mustParse("", `package p; var B interface { A }`)
 
 	// printInfo prints the *Func definitions recorded in info, one *Func per line.
 	printInfo := func(info *Info) string {
@@ -456,12 +449,12 @@ func TestIssue34151(t *testing.T) {
 	const asrc = `package a; type I interface{ M() }; type T struct { F interface { I } }`
 	const bsrc = `package b; import "a"; type T struct { F interface { a.I } }; var _ = a.T(T{})`
 
-	a, err := pkgFor("a", asrc, nil)
+	a, err := typecheck("a", asrc, nil)
 	if err != nil {
 		t.Fatalf("package %s failed to typecheck: %v", a.Name(), err)
 	}
 
-	bast := mustParse(t, bsrc)
+	bast := mustParse("", bsrc)
 	conf := Config{Importer: importHelper{pkg: a}}
 	b, err := conf.Check(bast.PkgName.Value, []*syntax.File{bast}, nil)
 	if err != nil {
@@ -504,7 +497,7 @@ func TestIssue34921(t *testing.T) {
 
 	var pkg *Package
 	for _, src := range sources {
-		f := mustParse(t, src)
+		f := mustParse("", src)
 		conf := Config{Importer: importHelper{pkg: pkg}}
 		res, err := conf.Check(f.PkgName.Value, []*syntax.File{f}, nil)
 		if err != nil {
@@ -571,7 +564,7 @@ func TestIssue43124(t *testing.T) {
 		csrc = `package c; import ("a"; "html/template"); func _() { a.G(template.Template{}) }`
 	)
 
-	a, err := pkgFor("a", asrc, nil)
+	a, err := typecheck("a", asrc, nil)
 	if err != nil {
 		t.Fatalf("package a failed to typecheck: %v", err)
 	}
@@ -579,7 +572,7 @@ func TestIssue43124(t *testing.T) {
 
 	// Packages should be fully qualified when there is ambiguity within the
 	// error string itself.
-	bast := mustParse(t, bsrc)
+	bast := mustParse("", bsrc)
 	_, err = conf.Check(bast.PkgName.Value, []*syntax.File{bast}, nil)
 	if err == nil {
 		t.Fatal("package b had no errors")
@@ -589,7 +582,7 @@ func TestIssue43124(t *testing.T) {
 	}
 
 	// ...and also when there is any ambiguity in reachable packages.
-	cast := mustParse(t, csrc)
+	cast := mustParse("", csrc)
 	_, err = conf.Check(cast.PkgName.Value, []*syntax.File{cast}, nil)
 	if err == nil {
 		t.Fatal("package c had no errors")
@@ -688,7 +681,7 @@ func TestIssue51093(t *testing.T) {
 	for _, test := range tests {
 		src := fmt.Sprintf("package p; func _[P %s]() { _ = P(%s) }", test.typ, test.val)
 		types := make(map[syntax.Expr]TypeAndValue)
-		mustTypecheck(t, "p", src, &Info{Types: types})
+		mustTypecheck("p", src, &Info{Types: types})
 
 		var n int
 		for x, tv := range types {
diff --git a/src/cmd/compile/internal/types2/named_test.go b/src/cmd/compile/internal/types2/named_test.go
index e5e8eddb05..1d1579b9e7 100644
--- a/src/cmd/compile/internal/types2/named_test.go
+++ b/src/cmd/compile/internal/types2/named_test.go
@@ -31,7 +31,7 @@ func (G[P]) N() (p P) { return }
 
 type Inst = G[int]
 	`
-	pkg, err := pkgFor("p", src, nil)
+	pkg, err := typecheck("p", src, nil)
 	if err != nil {
 		b.Fatal(err)
 	}
@@ -95,10 +95,7 @@ func (Node[Q]) M(Q) {}
 type Inst = *Tree[int]
 `
 
-	f, err := parseSrc("foo.go", src)
-	if err != nil {
-		t.Fatal(err)
-	}
+	f := mustParse("foo.go", src)
 	pkg := NewPackage("p", f.PkgName.Value)
 	if err := NewChecker(nil, pkg, nil).Files([]*syntax.File{f}); err != nil {
 		t.Fatal(err)
diff --git a/src/cmd/compile/internal/types2/object_test.go b/src/cmd/compile/internal/types2/object_test.go
index 8f0303d4b2..fa036ecf6c 100644
--- a/src/cmd/compile/internal/types2/object_test.go
+++ b/src/cmd/compile/internal/types2/object_test.go
@@ -59,10 +59,7 @@ func TestEmbeddedMethod(t *testing.T) {
 	const src = `package p; type I interface { error }`
 
 	// type-check src
-	f, err := parseSrc("", src)
-	if err != nil {
-		t.Fatalf("parse failed: %s", err)
-	}
+	f := mustParse("", src)
 	var conf Config
 	pkg, err := conf.Check(f.PkgName.Value, []*syntax.File{f}, nil)
 	if err != nil {
@@ -121,7 +118,7 @@ func TestObjectString(t *testing.T) {
 
 	for _, test := range testObjects {
 		src := "package p; " + test.src
-		pkg, err := makePkg(src)
+		pkg, err := typecheck(filename, src, nil)
 		if err != nil {
 			t.Errorf("%s: %s", src, err)
 			continue
diff --git a/src/cmd/compile/internal/types2/resolver_test.go b/src/cmd/compile/internal/types2/resolver_test.go
index a02abce081..e303d34827 100644
--- a/src/cmd/compile/internal/types2/resolver_test.go
+++ b/src/cmd/compile/internal/types2/resolver_test.go
@@ -117,11 +117,7 @@ func TestResolveIdents(t *testing.T) {
 	// parse package files
 	var files []*syntax.File
 	for i, src := range sources {
-		f, err := parseSrc(fmt.Sprintf("sources[%d]", i), src)
-		if err != nil {
-			t.Fatal(err)
-		}
-		files = append(files, f)
+		files = append(files, mustParse(fmt.Sprintf("sources[%d]", i), src))
 	}
 
 	// resolve and type-check package AST
diff --git a/src/cmd/compile/internal/types2/sizes_test.go b/src/cmd/compile/internal/types2/sizes_test.go
index 824ec838e2..354690c9d4 100644
--- a/src/cmd/compile/internal/types2/sizes_test.go
+++ b/src/cmd/compile/internal/types2/sizes_test.go
@@ -18,12 +18,9 @@ func findStructType(t *testing.T, src string) *types2.Struct {
 }
 
 func findStructTypeConfig(t *testing.T, src string, conf *types2.Config) *types2.Struct {
-	f, err := parseSrc("x.go", src)
-	if err != nil {
-		t.Fatal(err)
-	}
+	f := mustParse("x.go", src)
 	info := types2.Info{Types: make(map[syntax.Expr]types2.TypeAndValue)}
-	_, err = conf.Check("x", []*syntax.File{f}, &info)
+	_, err := conf.Check("x", []*syntax.File{f}, &info)
 	if err != nil {
 		t.Fatal(err)
 	}
@@ -90,16 +87,13 @@ import "unsafe"
 
 const _ = unsafe.Offsetof(struct{ x int64 }{}.x)
 `
-	f, err := parseSrc("x.go", src)
-	if err != nil {
-		t.Fatal(err)
-	}
+	f := mustParse("x.go", src)
 	info := types2.Info{Types: make(map[syntax.Expr]types2.TypeAndValue)}
 	conf := types2.Config{
 		Importer: defaultImporter(),
 		Sizes:    &types2.StdSizes{WordSize: 8, MaxAlign: 8},
 	}
-	_, err = conf.Check("x", []*syntax.File{f}, &info)
+	_, err := conf.Check("x", []*syntax.File{f}, &info)
 	if err != nil {
 		t.Fatal(err)
 	}
diff --git a/src/cmd/compile/internal/types2/stdlib_test.go b/src/cmd/compile/internal/types2/stdlib_test.go
index 5933c29d61..7acb35b688 100644
--- a/src/cmd/compile/internal/types2/stdlib_test.go
+++ b/src/cmd/compile/internal/types2/stdlib_test.go
@@ -29,7 +29,7 @@ func TestStdlib(t *testing.T) {
 
 	pkgCount := 0
 	duration := walkPkgDirs(filepath.Join(testenv.GOROOT(t), "src"), func(dir string, filenames []string) {
-		typecheck(t, dir, filenames)
+		typecheckFiles(t, dir, filenames)
 		pkgCount++
 	}, t.Error)
 
@@ -225,8 +225,8 @@ var excluded = map[string]bool{
 	"crypto/internal/edwards25519/field/_asm": true,
 }
 
-// typecheck typechecks the given package files.
-func typecheck(t *testing.T, path string, filenames []string) {
+// typecheckFiles typechecks the given package files.
+func typecheckFiles(t *testing.T, path string, filenames []string) {
 	// parse package files
 	var files []*syntax.File
 	for _, filename := range filenames {
diff --git a/src/cmd/compile/internal/types2/typestring_test.go b/src/cmd/compile/internal/types2/typestring_test.go
index 42b1f126f5..076fe3751d 100644
--- a/src/cmd/compile/internal/types2/typestring_test.go
+++ b/src/cmd/compile/internal/types2/typestring_test.go
@@ -8,22 +8,11 @@ import (
 	"internal/testenv"
 	"testing"
 
-	"cmd/compile/internal/syntax"
 	. "cmd/compile/internal/types2"
 )
 
 const filename = "<src>"
 
-func makePkg(src string) (*Package, error) {
-	file, err := parseSrc(filename, src)
-	if err != nil {
-		return nil, err
-	}
-	// use the package name as package path
-	conf := Config{Importer: defaultImporter()}
-	return conf.Check(file.PkgName.Value, []*syntax.File{file}, nil)
-}
-
 type testEntry struct {
 	src, str string
 }
@@ -128,7 +117,7 @@ func TestTypeString(t *testing.T) {
 
 	for _, test := range tests {
 		src := `package generic_p; import "io"; type _ io.Writer; type T ` + test.src
-		pkg, err := makePkg(src)
+		pkg, err := typecheck(filename, src, nil)
 		if err != nil {
 			t.Errorf("%s: %s", src, err)
 			continue
@@ -146,8 +135,8 @@ func TestTypeString(t *testing.T) {
 }
 
 func TestQualifiedTypeString(t *testing.T) {
-	p, _ := pkgFor("p.go", "package p; type T int", nil)
-	q, _ := pkgFor("q.go", "package q", nil)
+	p, _ := typecheck("p.go", "package p; type T int", nil)
+	q, _ := typecheck("q.go", "package q", nil)
 
 	pT := p.Scope().Lookup("T").Type()
 	for _, test := range []struct {
diff --git a/src/go/types/api_test.go b/src/go/types/api_test.go
index 4874ab068c..6bdc2d802e 100644
--- a/src/go/types/api_test.go
+++ b/src/go/types/api_test.go
@@ -21,42 +21,37 @@ import (
 	. "go/types"
 )
 
-// pkgFor parses and type checks the package specified by path and source,
-// populating info if provided.
-func pkgFor(path, source string, info *Info) (*Package, error) {
-	fset := token.NewFileSet()
-	f, err := parser.ParseFile(fset, path, source, 0)
-	if err != nil {
-		return nil, err
-	}
-	conf := Config{Importer: importer.Default()}
-	return conf.Check(f.Name.Name, fset, []*ast.File{f}, info)
+func parse(fset *token.FileSet, filename, src string) (*ast.File, error) {
+	return parser.ParseFile(fset, filename, src, 0)
 }
 
-func mustTypecheck(t testing.TB, path, source string, info *Info) string {
-	pkg, err := pkgFor(path, source, info)
+func mustParse(fset *token.FileSet, filename, src string) *ast.File {
+	f, err := parse(fset, filename, src)
 	if err != nil {
-		name := path
-		if pkg != nil {
-			name = "package " + pkg.Name()
-		}
-		t.Fatalf("%s: didn't type-check (%s)", name, err)
+		panic(err) // so we don't need to pass *testing.T
 	}
-	return pkg.Name()
+	return f
 }
 
-func mayTypecheck(t *testing.T, path, source string, info *Info) (string, error) {
+func typecheck(path, src string, info *Info) (*Package, error) {
 	fset := token.NewFileSet()
-	f, err := parser.ParseFile(fset, path, source, 0)
+	f, err := parse(fset, path, src)
 	if f == nil { // ignore errors unless f is nil
-		t.Fatalf("%s: unable to parse: %s", path, err)
+		return nil, err
 	}
 	conf := Config{
-		Error:    func(err error) {},
+		Error:    func(err error) {}, // collect all errors
 		Importer: importer.Default(),
 	}
-	pkg, err := conf.Check(f.Name.Name, fset, []*ast.File{f}, info)
-	return pkg.Name(), err
+	return conf.Check(f.Name.Name, fset, []*ast.File{f}, info)
+}
+
+func mustTypecheck(path, src string, info *Info) string {
+	pkg, err := typecheck(path, src, info)
+	if err != nil {
+		panic(err) // so we don't need to pass *testing.T
+	}
+	return pkg.Name()
 }
 
 func TestValuesInfo(t *testing.T) {
@@ -142,7 +137,7 @@ func TestValuesInfo(t *testing.T) {
 		info := Info{
 			Types: make(map[ast.Expr]TypeAndValue),
 		}
-		name := mustTypecheck(t, "ValuesInfo", test.src, &info)
+		name := mustTypecheck("ValuesInfo", test.src, &info)
 
 		// look for expression
 		var expr ast.Expr
@@ -380,14 +375,16 @@ func TestTypesInfo(t *testing.T) {
 		info := Info{Types: make(map[ast.Expr]TypeAndValue)}
 		var name string
 		if strings.HasPrefix(test.src, broken) {
-			var err error
-			name, err = mayTypecheck(t, "TypesInfo", test.src, &info)
+			pkg, err := typecheck("TypesInfo", test.src, &info)
 			if err == nil {
-				t.Errorf("package %s: expected to fail but passed", name)
+				t.Errorf("package %s: expected to fail but passed", pkg.Name())
 				continue
 			}
+			if pkg != nil {
+				name = pkg.Name()
+			}
 		} else {
-			name = mustTypecheck(t, "TypesInfo", test.src, &info)
+			name = mustTypecheck("TypesInfo", test.src, &info)
 		}
 
 		// look for expression type
@@ -546,10 +543,7 @@ type T[P any] []P
 		instMap := make(map[*ast.Ident]Instance)
 		useMap := make(map[*ast.Ident]Object)
 		makePkg := func(src string) *Package {
-			f, err := parser.ParseFile(fset, "p.go", src, 0)
-			if err != nil {
-				t.Fatal(err)
-			}
+			f := mustParse(fset, "p.go", src)
 			pkg, err := conf.Check("", fset, []*ast.File{f}, &Info{Instances: instMap, Uses: useMap})
 			if err != nil {
 				t.Fatal(err)
@@ -648,7 +642,7 @@ func TestDefsInfo(t *testing.T) {
 		info := Info{
 			Defs: make(map[*ast.Ident]Object),
 		}
-		name := mustTypecheck(t, "DefsInfo", test.src, &info)
+		name := mustTypecheck("DefsInfo", test.src, &info)
 
 		// find object
 		var def Object
@@ -715,7 +709,7 @@ func TestUsesInfo(t *testing.T) {
 		info := Info{
 			Uses: make(map[*ast.Ident]Object),
 		}
-		name := mustTypecheck(t, "UsesInfo", test.src, &info)
+		name := mustTypecheck("UsesInfo", test.src, &info)
 
 		// find object
 		var use Object
@@ -748,10 +742,7 @@ func (r N[B]) m() { r.m(); r.n() }
 func (r *N[C]) n() {  }
 `
 	fset := token.NewFileSet()
-	f, err := parser.ParseFile(fset, "p.go", src, 0)
-	if err != nil {
-		t.Fatal(err)
-	}
+	f := mustParse(fset, "p.go", src)
 	info := Info{
 		Defs:       make(map[*ast.Ident]Object),
 		Uses:       make(map[*ast.Ident]Object),
@@ -859,7 +850,7 @@ func TestImplicitsInfo(t *testing.T) {
 		info := Info{
 			Implicits: make(map[ast.Node]Object),
 		}
-		name := mustTypecheck(t, "ImplicitsInfo", test.src, &info)
+		name := mustTypecheck("ImplicitsInfo", test.src, &info)
 
 		// the test cases expect at most one Implicits entry
 		if len(info.Implicits) > 1 {
@@ -987,7 +978,7 @@ func TestPredicatesInfo(t *testing.T) {
 
 	for _, test := range tests {
 		info := Info{Types: make(map[ast.Expr]TypeAndValue)}
-		name := mustTypecheck(t, "PredicatesInfo", test.src, &info)
+		name := mustTypecheck("PredicatesInfo", test.src, &info)
 
 		// look for expression predicates
 		got := "<missing>"
@@ -1079,7 +1070,7 @@ func TestScopesInfo(t *testing.T) {
 
 	for _, test := range tests {
 		info := Info{Scopes: make(map[ast.Node]*Scope)}
-		name := mustTypecheck(t, "ScopesInfo", test.src, &info)
+		name := mustTypecheck("ScopesInfo", test.src, &info)
 
 		// number of scopes must match
 		if len(info.Scopes) != len(test.scopes) {
@@ -1267,7 +1258,7 @@ func TestInitOrderInfo(t *testing.T) {
 
 	for _, test := range tests {
 		info := Info{}
-		name := mustTypecheck(t, "InitOrderInfo", test.src, &info)
+		name := mustTypecheck("InitOrderInfo", test.src, &info)
 
 		// number of initializers must match
 		if len(info.InitOrder) != len(test.inits) {
@@ -1288,16 +1279,8 @@ func TestInitOrderInfo(t *testing.T) {
 
 func TestMultiFileInitOrder(t *testing.T) {
 	fset := token.NewFileSet()
-	mustParse := func(src string) *ast.File {
-		f, err := parser.ParseFile(fset, "main", src, 0)
-		if err != nil {
-			t.Fatal(err)
-		}
-		return f
-	}
-
-	fileA := mustParse(`package main; var a = 1`)
-	fileB := mustParse(`package main; var b = 2`)
+	fileA := mustParse(fset, "", `package main; var a = 1`)
+	fileB := mustParse(fset, "", `package main; var b = 2`)
 
 	// The initialization order must not depend on the parse
 	// order of the files, only on the presentation order to
@@ -1335,10 +1318,7 @@ func TestFiles(t *testing.T) {
 
 	for i, src := range sources {
 		filename := fmt.Sprintf("sources%d", i)
-		f, err := parser.ParseFile(fset, filename, src, 0)
-		if err != nil {
-			t.Fatal(err)
-		}
+		f := mustParse(fset, filename, src)
 		if err := check.Files([]*ast.File{f}); err != nil {
 			t.Error(err)
 		}
@@ -1372,10 +1352,7 @@ func TestSelection(t *testing.T) {
 	imports := make(testImporter)
 	conf := Config{Importer: imports}
 	makePkg := func(path, src string) {
-		f, err := parser.ParseFile(fset, path+".go", src, 0)
-		if err != nil {
-			t.Fatal(err)
-		}
+		f := mustParse(fset, path+".go", src)
 		pkg, err := conf.Check(path, fset, []*ast.File{f}, &Info{Selections: selections})
 		if err != nil {
 			t.Fatal(err)
@@ -1553,10 +1530,7 @@ func TestIssue8518(t *testing.T) {
 		Importer: imports,
 	}
 	makePkg := func(path, src string) {
-		f, err := parser.ParseFile(fset, path, src, 0)
-		if err != nil {
-			t.Fatal(err)
-		}
+		f := mustParse(fset, path, src)
 		pkg, _ := conf.Check(path, fset, []*ast.File{f}, nil) // errors logged via conf.Error
 		imports[path] = pkg
 	}
@@ -1646,7 +1620,7 @@ func TestLookupFieldOrMethod(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		pkg, err := pkgFor("test", "package p;"+test.src, nil)
+		pkg, err := typecheck("test", "package p;"+test.src, nil)
 		if err != nil {
 			t.Errorf("%s: incorrect test case: %s", test.src, err)
 			continue
@@ -1696,10 +1670,7 @@ type Instance = *Tree[int]
 `
 
 	fset := token.NewFileSet()
-	f, err := parser.ParseFile(fset, "foo.go", src, 0)
-	if err != nil {
-		panic(err)
-	}
+	f := mustParse(fset, "foo.go", src)
 	pkg := NewPackage("pkg", f.Name.Name)
 	if err := NewChecker(nil, fset, pkg, nil).Files([]*ast.File{f}); err != nil {
 		panic(err)
@@ -1727,13 +1698,6 @@ func TestScopeLookupParent(t *testing.T) {
 	fset := token.NewFileSet()
 	imports := make(testImporter)
 	conf := Config{Importer: imports}
-	mustParse := func(src string) *ast.File {
-		f, err := parser.ParseFile(fset, "dummy.go", src, parser.ParseComments)
-		if err != nil {
-			t.Fatal(err)
-		}
-		return f
-	}
 	var info Info
 	makePkg := func(path string, files ...*ast.File) {
 		var err error
@@ -1743,7 +1707,7 @@ func TestScopeLookupParent(t *testing.T) {
 		}
 	}
 
-	makePkg("lib", mustParse("package lib; var X int"))
+	makePkg("lib", mustParse(fset, "", "package lib; var X int"))
 	// Each /*name=kind:line*/ comment makes the test look up the
 	// name at that point and checks that it resolves to a decl of
 	// the specified kind and line number.  "undef" means undefined.
@@ -1787,7 +1751,7 @@ func F(){
 `
 
 	info.Uses = make(map[*ast.Ident]Object)
-	f := mustParse(mainSrc)
+	f := mustParse(fset, "", mainSrc)
 	makePkg("main", f)
 	mainScope := imports["main"].Scope()
 	rx := regexp.MustCompile(`^/\*(\w*)=([\w:]*)\*/$`)
@@ -1939,7 +1903,7 @@ func TestIdentical(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		pkg, err := pkgFor("test", "package p;"+test.src, nil)
+		pkg, err := typecheck("test", "package p;"+test.src, nil)
 		if err != nil {
 			t.Errorf("%s: incorrect test case: %s", test.src, err)
 			continue
@@ -2017,10 +1981,7 @@ func TestIdenticalUnions(t *testing.T) {
 func TestIssue15305(t *testing.T) {
 	const src = "package p; func f() int16; var _ = f(undef)"
 	fset := token.NewFileSet()
-	f, err := parser.ParseFile(fset, "issue15305.go", src, 0)
-	if err != nil {
-		t.Fatal(err)
-	}
+	f := mustParse(fset, "issue15305.go", src)
 	conf := Config{
 		Error: func(err error) {}, // allow errors
 	}
@@ -2056,20 +2017,14 @@ func TestCompositeLitTypes(t *testing.T) {
 		{`struct{x, y int; z complex128}{}`, `struct{x int; y int; z complex128}`},
 	} {
 		fset := token.NewFileSet()
-		f, err := parser.ParseFile(fset, test.lit, "package p; var _ = "+test.lit, 0)
-		if err != nil {
-			t.Fatalf("%s: %v", test.lit, err)
-		}
-
-		info := &Info{
-			Types: make(map[ast.Expr]TypeAndValue),
-		}
-		if _, err = new(Config).Check("p", fset, []*ast.File{f}, info); err != nil {
+		f := mustParse(fset, test.lit, "package p; var _ = "+test.lit)
+		types := make(map[ast.Expr]TypeAndValue)
+		if _, err := new(Config).Check("p", fset, []*ast.File{f}, &Info{Types: types}); err != nil {
 			t.Fatalf("%s: %v", test.lit, err)
 		}
 
 		cmptype := func(x ast.Expr, want string) {
-			tv, ok := info.Types[x]
+			tv, ok := types[x]
 			if !ok {
 				t.Errorf("%s: no Types entry found", test.lit)
 				return
@@ -2117,15 +2072,12 @@ func f(x int) { y := x; print(y) }
 `
 
 	fset := token.NewFileSet()
-	f, err := parser.ParseFile(fset, "src", src, 0)
-	if err != nil {
-		t.Fatal(err)
-	}
+	f := mustParse(fset, "src", src)
 
 	info := &Info{
 		Defs: make(map[*ast.Ident]Object),
 	}
-	if _, err = new(Config).Check("p", fset, []*ast.File{f}, info); err != nil {
+	if _, err := new(Config).Check("p", fset, []*ast.File{f}, info); err != nil {
 		t.Fatal(err)
 	}
 
@@ -2179,10 +2131,7 @@ var v T = c
 func f(x T) T { return foo.F(x) }
 `
 	fset := token.NewFileSet()
-	f, err := parser.ParseFile(fset, "src", src, 0)
-	if err != nil {
-		t.Fatal(err)
-	}
+	f := mustParse(fset, "src", src)
 	files := []*ast.File{f}
 
 	// type-check using all possible importers
@@ -2237,7 +2186,7 @@ func f(x T) T { return foo.F(x) }
 func TestInstantiate(t *testing.T) {
 	// eventually we like more tests but this is a start
 	const src = "package p; type T[P any] *T[P]"
-	pkg, err := pkgFor(".", src, nil)
+	pkg, err := typecheck(".", src, nil)
 	if err != nil {
 		t.Fatal(err)
 	}
@@ -2275,7 +2224,7 @@ func TestInstantiateErrors(t *testing.T) {
 
 	for _, test := range tests {
 		src := "package p; " + test.src
-		pkg, err := pkgFor(".", src, nil)
+		pkg, err := typecheck(".", src, nil)
 		if err != nil {
 			t.Fatal(err)
 		}
@@ -2317,10 +2266,7 @@ func TestInstanceIdentity(t *testing.T) {
 	conf := Config{Importer: imports}
 	makePkg := func(src string) {
 		fset := token.NewFileSet()
-		f, err := parser.ParseFile(fset, "", src, 0)
-		if err != nil {
-			t.Fatal(err)
-		}
+		f := mustParse(fset, "", src)
 		name := f.Name.Name
 		pkg, err := conf.Check(name, fset, []*ast.File{f}, nil)
 		if err != nil {
@@ -2377,10 +2323,7 @@ func fn() {
 		Defs: make(map[*ast.Ident]Object),
 	}
 	fset := token.NewFileSet()
-	f, err := parser.ParseFile(fset, "p.go", src, 0)
-	if err != nil {
-		t.Fatal(err)
-	}
+	f := mustParse(fset, "p.go", src)
 	conf := Config{}
 	pkg, err := conf.Check(f.Name.Name, fset, []*ast.File{f}, info)
 	if err != nil {
@@ -2512,10 +2455,7 @@ type Bad Bad // invalid type
 `
 
 	fset := token.NewFileSet()
-	f, err := parser.ParseFile(fset, "p.go", src, 0)
-	if err != nil {
-		t.Fatal(err)
-	}
+	f := mustParse(fset, "p.go", src)
 	conf := Config{Error: func(error) {}}
 	pkg, _ := conf.Check(f.Name.Name, fset, []*ast.File{f}, nil)
 
@@ -2610,7 +2550,7 @@ type V4 struct{}
 func (V4) M()
 `
 
-	pkg, err := pkgFor("p.go", src, nil)
+	pkg, err := typecheck("p.go", src, nil)
 	if err != nil {
 		t.Fatal(err)
 	}
diff --git a/src/go/types/example_test.go b/src/go/types/example_test.go
index 75233e6dd5..be70e14610 100644
--- a/src/go/types/example_test.go
+++ b/src/go/types/example_test.go
@@ -53,11 +53,7 @@ const Boiling Celsius = 100
 func Unused() { {}; {{ var x int; _ = x }} } // make sure empty block scopes get printed
 `},
 	} {
-		f, err := parser.ParseFile(fset, file.name, file.input, 0)
-		if err != nil {
-			log.Fatal(err)
-		}
-		files = append(files, f)
+		files = append(files, mustParse(fset, file.name, file.input))
 	}
 
 	// Type-check a package consisting of these files.
@@ -185,10 +181,7 @@ func fib(x int) int {
 	return fib(x-1) - fib(x-2)
 }`
 	fset := token.NewFileSet()
-	f, err := parser.ParseFile(fset, "fib.go", input, 0)
-	if err != nil {
-		log.Fatal(err)
-	}
+	f := mustParse(fset, "fib.go", input)
 
 	// Type-check the package.
 	// We create an empty map for each kind of input
diff --git a/src/go/types/instantiate_test.go b/src/go/types/instantiate_test.go
index ee68954a17..b4ff3e4442 100644
--- a/src/go/types/instantiate_test.go
+++ b/src/go/types/instantiate_test.go
@@ -109,7 +109,7 @@ func TestInstantiateEquality(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		pkg, err := pkgFor(".", test.src, nil)
+		pkg, err := typecheck(".", test.src, nil)
 		if err != nil {
 			t.Fatal(err)
 		}
@@ -139,11 +139,11 @@ func TestInstantiateEquality(t *testing.T) {
 func TestInstantiateNonEquality(t *testing.T) {
 	const src = "package p; type T[P any] int"
 
-	pkg1, err := pkgFor(".", src, nil)
+	pkg1, err := typecheck(".", src, nil)
 	if err != nil {
 		t.Fatal(err)
 	}
-	pkg2, err := pkgFor(".", src, nil)
+	pkg2, err := typecheck(".", src, nil)
 	if err != nil {
 		t.Fatal(err)
 	}
@@ -194,7 +194,7 @@ var X T[int]
 
 	for _, test := range tests {
 		src := prefix + test.decl
-		pkg, err := pkgFor(".", src, nil)
+		pkg, err := typecheck(".", src, nil)
 		if err != nil {
 			t.Fatal(err)
 		}
@@ -219,7 +219,7 @@ func (T[P]) m() {}
 
 var _ T[int]
 `
-	pkg, err := pkgFor(".", src, nil)
+	pkg, err := typecheck(".", src, nil)
 	if err != nil {
 		t.Fatal(err)
 	}
diff --git a/src/go/types/issues_test.go b/src/go/types/issues_test.go
index 0045f30148..27b43a0d91 100644
--- a/src/go/types/issues_test.go
+++ b/src/go/types/issues_test.go
@@ -10,7 +10,6 @@ import (
 	"fmt"
 	"go/ast"
 	"go/importer"
-	"go/parser"
 	"go/token"
 	"internal/testenv"
 	"sort"
@@ -20,15 +19,8 @@ import (
 	. "go/types"
 )
 
-func mustParse(t *testing.T, src string) *ast.File {
-	f, err := parser.ParseFile(fset, "", src, 0)
-	if err != nil {
-		t.Fatal(err)
-	}
-	return f
-}
 func TestIssue5770(t *testing.T) {
-	f := mustParse(t, `package p; type S struct{T}`)
+	f := mustParse(fset, "", `package p; type S struct{T}`)
 	conf := Config{Importer: importer.Default()}
 	_, err := conf.Check(f.Name.Name, fset, []*ast.File{f}, nil) // do not crash
 	const want = "undefined: T"
@@ -50,7 +42,7 @@ var (
 	_ = (interface{})(nil)
 )`
 	types := make(map[ast.Expr]TypeAndValue)
-	mustTypecheck(t, "p", src, &Info{Types: types})
+	mustTypecheck("p", src, &Info{Types: types})
 
 	for x, tv := range types {
 		var want Type
@@ -89,7 +81,7 @@ func f() int {
 }
 `
 	types := make(map[ast.Expr]TypeAndValue)
-	mustTypecheck(t, "p", src, &Info{Types: types})
+	mustTypecheck("p", src, &Info{Types: types})
 
 	want := Typ[Int]
 	n := 0
@@ -113,7 +105,7 @@ package p
 func (T) m() (res bool) { return }
 type T struct{} // receiver type after method declaration
 `
-	f := mustParse(t, src)
+	f := mustParse(fset, "", src)
 
 	var conf Config
 	defs := make(map[*ast.Ident]Object)
@@ -144,7 +136,7 @@ func _() {
         _, _, _ = x, y, z  // uses x, y, z
 }
 `
-	f := mustParse(t, src)
+	f := mustParse(fset, "", src)
 
 	const want = `L3 defs func p._()
 L4 defs const w untyped int
@@ -240,7 +232,7 @@ func main() {
 }
 `
 	f := func(test, src string) {
-		f := mustParse(t, src)
+		f := mustParse(fset, "", src)
 		cfg := Config{Importer: importer.Default()}
 		info := Info{Uses: make(map[*ast.Ident]Object)}
 		_, err := cfg.Check("main", fset, []*ast.File{f}, &info)
@@ -270,7 +262,7 @@ func main() {
 }
 
 func TestIssue22525(t *testing.T) {
-	f := mustParse(t, `package p; func f() { var a, b, c, d, e int }`)
+	f := mustParse(fset, "", `package p; func f() { var a, b, c, d, e int }`)
 
 	got := "\n"
 	conf := Config{Error: func(err error) { got += err.Error() + "\n" }}
@@ -300,7 +292,7 @@ func TestIssue25627(t *testing.T) {
 		`struct { *I }`,
 		`struct { a int; b Missing; *Missing }`,
 	} {
-		f := mustParse(t, prefix+src)
+		f := mustParse(fset, "", prefix+src)
 
 		cfg := Config{Importer: importer.Default(), Error: func(err error) {}}
 		info := &Info{Types: make(map[ast.Expr]TypeAndValue)}
@@ -337,7 +329,7 @@ func TestIssue28005(t *testing.T) {
 	// compute original file ASTs
 	var orig [len(sources)]*ast.File
 	for i, src := range sources {
-		orig[i] = mustParse(t, src)
+		orig[i] = mustParse(fset, "", src)
 	}
 
 	// run the test for all order permutations of the incoming files
@@ -411,8 +403,8 @@ func TestIssue28282(t *testing.T) {
 }
 
 func TestIssue29029(t *testing.T) {
-	f1 := mustParse(t, `package p; type A interface { M() }`)
-	f2 := mustParse(t, `package p; var B interface { A }`)
+	f1 := mustParse(fset, "", `package p; type A interface { M() }`)
+	f2 := mustParse(fset, "", `package p; var B interface { A }`)
 
 	// printInfo prints the *Func definitions recorded in info, one *Func per line.
 	printInfo := func(info *Info) string {
@@ -458,12 +450,12 @@ func TestIssue34151(t *testing.T) {
 	const asrc = `package a; type I interface{ M() }; type T struct { F interface { I } }`
 	const bsrc = `package b; import "a"; type T struct { F interface { a.I } }; var _ = a.T(T{})`
 
-	a, err := pkgFor("a", asrc, nil)
+	a, err := typecheck("a", asrc, nil)
 	if err != nil {
 		t.Fatalf("package %s failed to typecheck: %v", a.Name(), err)
 	}
 
-	bast := mustParse(t, bsrc)
+	bast := mustParse(fset, "", bsrc)
 	conf := Config{Importer: importHelper{pkg: a}}
 	b, err := conf.Check(bast.Name.Name, fset, []*ast.File{bast}, nil)
 	if err != nil {
@@ -506,7 +498,7 @@ func TestIssue34921(t *testing.T) {
 
 	var pkg *Package
 	for _, src := range sources {
-		f := mustParse(t, src)
+		f := mustParse(fset, "", src)
 		conf := Config{Importer: importHelper{pkg: pkg}}
 		res, err := conf.Check(f.Name.Name, fset, []*ast.File{f}, nil)
 		if err != nil {
@@ -617,7 +609,7 @@ var _ T = template /* ERROR cannot use.*text/template.* as T value */.Template{}
 `
 	)
 
-	a, err := pkgFor("a", asrc, nil)
+	a, err := typecheck("a", asrc, nil)
 	if err != nil {
 		t.Fatalf("package a failed to typecheck: %v", err)
 	}
@@ -717,7 +709,7 @@ func TestIssue51093(t *testing.T) {
 	for _, test := range tests {
 		src := fmt.Sprintf("package p; func _[P %s]() { _ = P(%s) }", test.typ, test.val)
 		types := make(map[ast.Expr]TypeAndValue)
-		mustTypecheck(t, "p", src, &Info{Types: types})
+		mustTypecheck("p", src, &Info{Types: types})
 
 		var n int
 		for x, tv := range types {
diff --git a/src/go/types/methodset_test.go b/src/go/types/methodset_test.go
index 51303681a3..dba991b1d2 100644
--- a/src/go/types/methodset_test.go
+++ b/src/go/types/methodset_test.go
@@ -84,7 +84,7 @@ func TestNewMethodSet(t *testing.T) {
 	}
 
 	check := func(src string, methods []method, generic bool) {
-		pkg, err := pkgFor("test", "package p;"+src, nil)
+		pkg, err := typecheck("test", "package p;"+src, nil)
 		if err != nil {
 			t.Errorf("%s: incorrect test case: %s", src, err)
 			return
diff --git a/src/go/types/named_test.go b/src/go/types/named_test.go
index 945e25a41d..cbfa8c7f64 100644
--- a/src/go/types/named_test.go
+++ b/src/go/types/named_test.go
@@ -6,7 +6,6 @@ package types_test
 
 import (
 	"go/ast"
-	"go/parser"
 	"go/token"
 	"testing"
 
@@ -33,7 +32,7 @@ func (G[P]) N() (p P) { return }
 
 type Inst = G[int]
 	`
-	pkg, err := pkgFor("p", src, nil)
+	pkg, err := typecheck("p", src, nil)
 	if err != nil {
 		b.Fatal(err)
 	}
@@ -111,10 +110,7 @@ type Inst = *Tree[int]
 `
 
 	fset := token.NewFileSet()
-	f, err := parser.ParseFile(fset, "foo.go", src, 0)
-	if err != nil {
-		t.Fatal(err)
-	}
+	f := mustParse(fset, "foo.go", src)
 	pkg := NewPackage("p", f.Name.Name)
 	if err := NewChecker(nil, fset, pkg, nil).Files([]*ast.File{f}); err != nil {
 		t.Fatal(err)
diff --git a/src/go/types/object_test.go b/src/go/types/object_test.go
index 47c7fcd349..60e7a84ca6 100644
--- a/src/go/types/object_test.go
+++ b/src/go/types/object_test.go
@@ -6,7 +6,6 @@ package types_test
 
 import (
 	"go/ast"
-	"go/parser"
 	"go/token"
 	"internal/testenv"
 	"strings"
@@ -62,10 +61,7 @@ func TestEmbeddedMethod(t *testing.T) {
 
 	// type-check src
 	fset := token.NewFileSet()
-	f, err := parser.ParseFile(fset, "", src, 0)
-	if err != nil {
-		t.Fatalf("parse failed: %s", err)
-	}
+	f := mustParse(fset, "", src)
 	var conf Config
 	pkg, err := conf.Check(f.Name.Name, fset, []*ast.File{f}, nil)
 	if err != nil {
@@ -124,7 +120,7 @@ func TestObjectString(t *testing.T) {
 
 	for _, test := range testObjects {
 		src := "package p; " + test.src
-		pkg, err := makePkg(src)
+		pkg, err := typecheck(filename, src, nil)
 		if err != nil {
 			t.Errorf("%s: %s", src, err)
 			continue
diff --git a/src/go/types/resolver_test.go b/src/go/types/resolver_test.go
index 4bb63b6648..376ecfbea0 100644
--- a/src/go/types/resolver_test.go
+++ b/src/go/types/resolver_test.go
@@ -8,7 +8,6 @@ import (
 	"fmt"
 	"go/ast"
 	"go/importer"
-	"go/parser"
 	"go/token"
 	"internal/testenv"
 	"sort"
@@ -121,11 +120,7 @@ func TestResolveIdents(t *testing.T) {
 	fset := token.NewFileSet()
 	var files []*ast.File
 	for i, src := range sources {
-		f, err := parser.ParseFile(fset, fmt.Sprintf("sources[%d]", i), src, parser.DeclarationErrors)
-		if err != nil {
-			t.Fatal(err)
-		}
-		files = append(files, f)
+		files = append(files, mustParse(fset, fmt.Sprintf("sources[%d]", i), src))
 	}
 
 	// resolve and type-check package AST
diff --git a/src/go/types/sizes_test.go b/src/go/types/sizes_test.go
index 3ac124acf1..c2917591d7 100644
--- a/src/go/types/sizes_test.go
+++ b/src/go/types/sizes_test.go
@@ -9,7 +9,6 @@ package types_test
 import (
 	"go/ast"
 	"go/importer"
-	"go/parser"
 	"go/token"
 	"go/types"
 	"internal/testenv"
@@ -23,12 +22,9 @@ func findStructType(t *testing.T, src string) *types.Struct {
 
 func findStructTypeConfig(t *testing.T, src string, conf *types.Config) *types.Struct {
 	fset := token.NewFileSet()
-	f, err := parser.ParseFile(fset, "x.go", src, 0)
-	if err != nil {
-		t.Fatal(err)
-	}
+	f := mustParse(fset, "x.go", src)
 	info := types.Info{Types: make(map[ast.Expr]types.TypeAndValue)}
-	_, err = conf.Check("x", fset, []*ast.File{f}, &info)
+	_, err := conf.Check("x", fset, []*ast.File{f}, &info)
 	if err != nil {
 		t.Fatal(err)
 	}
@@ -96,16 +92,13 @@ import "unsafe"
 const _ = unsafe.Offsetof(struct{ x int64 }{}.x)
 `
 	fset := token.NewFileSet()
-	f, err := parser.ParseFile(fset, "x.go", src, 0)
-	if err != nil {
-		t.Fatal(err)
-	}
+	f := mustParse(fset, "x.go", src)
 	info := types.Info{Types: make(map[ast.Expr]types.TypeAndValue)}
 	conf := types.Config{
 		Importer: importer.Default(),
 		Sizes:    &types.StdSizes{WordSize: 8, MaxAlign: 8},
 	}
-	_, err = conf.Check("x", fset, []*ast.File{f}, &info)
+	_, err := conf.Check("x", fset, []*ast.File{f}, &info)
 	if err != nil {
 		t.Fatal(err)
 	}
diff --git a/src/go/types/stdlib_test.go b/src/go/types/stdlib_test.go
index 66e75c7251..5f0a72e092 100644
--- a/src/go/types/stdlib_test.go
+++ b/src/go/types/stdlib_test.go
@@ -40,7 +40,7 @@ func TestStdlib(t *testing.T) {
 
 	pkgCount := 0
 	duration := walkPkgDirs(filepath.Join(testenv.GOROOT(t), "src"), func(dir string, filenames []string) {
-		typecheck(t, dir, filenames)
+		typecheckFiles(t, dir, filenames)
 		pkgCount++
 	}, t.Error)
 
@@ -227,8 +227,8 @@ var excluded = map[string]bool{
 	"crypto/internal/edwards25519/field/_asm": true,
 }
 
-// typecheck typechecks the given package files.
-func typecheck(t *testing.T, path string, filenames []string) {
+// typecheckFiles typechecks the given package files.
+func typecheckFiles(t *testing.T, path string, filenames []string) {
 	fset := token.NewFileSet()
 
 	// parse package files
diff --git a/src/go/types/typestring_test.go b/src/go/types/typestring_test.go
index dcbaa47709..260a6f85af 100644
--- a/src/go/types/typestring_test.go
+++ b/src/go/types/typestring_test.go
@@ -5,10 +5,6 @@
 package types_test
 
 import (
-	"go/ast"
-	"go/importer"
-	"go/parser"
-	"go/token"
 	"internal/testenv"
 	"testing"
 
@@ -17,17 +13,6 @@ import (
 
 const filename = "<src>"
 
-func makePkg(src string) (*Package, error) {
-	fset := token.NewFileSet()
-	file, err := parser.ParseFile(fset, filename, src, parser.DeclarationErrors)
-	if err != nil {
-		return nil, err
-	}
-	// use the package name as package path
-	conf := Config{Importer: importer.Default()}
-	return conf.Check(file.Name.Name, fset, []*ast.File{file}, nil)
-}
-
 type testEntry struct {
 	src, str string
 }
@@ -134,7 +119,7 @@ func TestTypeString(t *testing.T) {
 
 	for _, test := range tests {
 		src := `package p; import "io"; type _ io.Writer; type T ` + test.src
-		pkg, err := makePkg(src)
+		pkg, err := typecheck(filename, src, nil)
 		if err != nil {
 			t.Errorf("%s: %s", src, err)
 			continue
@@ -152,8 +137,8 @@ func TestTypeString(t *testing.T) {
 }
 
 func TestQualifiedTypeString(t *testing.T) {
-	p, _ := pkgFor("p.go", "package p; type T int", nil)
-	q, _ := pkgFor("q.go", "package q", nil)
+	p, _ := typecheck("p.go", "package p; type T int", nil)
+	q, _ := typecheck("q.go", "package q", nil)
 
 	pT := p.Scope().Lookup("T").Type()
 	for _, test := range []struct {
