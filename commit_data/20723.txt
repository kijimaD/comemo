commit 904ec0098137f742e0dd96da3bc033d6a0b615d1
Merge: d42328c9f7 c65a47f890
Author: Russ Cox <rsc@golang.org>
Date:   Fri Oct 3 12:22:19 2014 -0400

    [dev.garbage] merge default into dev.garbage

 .hgignore                                          |     5 -
 .hgtags                                            |     4 +-
 AUTHORS                                            |     5 +
 CONTRIBUTORS                                       |     7 +
 doc/devel/release.html                             |    10 +
 doc/go1.4.txt                                      |    12 +-
 doc/go_faq.html                                    |    66 +-
 doc/go_spec.html                                   |   173 +-
 doc/gopher/biplane.jpg                             |   Bin 0 -> 203420 bytes
 include/link.h                                     |     3 +-
 misc/cgo/test/backdoor/backdoor.go                 |     3 +-
 misc/cgo/test/backdoor/runtime.c                   |    18 -
 misc/cgo/test/basic.go                             |     5 +
 misc/cgo/test/callback.go                          |    45 +
 misc/cgo/test/callback_c.c                         |    16 +
 misc/cgo/test/cgo_test.go                          |    96 +-
 misc/cgo/test/issue7695_test.go                    |    30 -
 misc/cgo/test/issue7978.go                         |    99 +
 misc/cgo/test/issue8694.go                         |    32 +
 misc/nacl/README                                   |     6 +-
 src/bufio/scan.go                                  |     4 +-
 src/bufio/scan_test.go                             |    36 +
 src/bytes/bytes.go                                 |     2 +
 src/bytes/bytes.s                                  |     5 -
 src/cmd/5g/gsubr.c                                 |     4 +-
 src/cmd/8g/gsubr.c                                 |     2 +-
 src/cmd/cc/dcl.c                                   |     9 +-
 src/cmd/cc/lex.c                                   |     2 +
 src/cmd/cgo/ast.go                                 |     3 +
 src/cmd/cgo/out.go                                 |    29 +-
 src/cmd/dist/buildruntime.c                        |     2 +
 src/cmd/gc/align.c                                 |     4 +-
 src/cmd/gc/fmt.c                                   |    22 +-
 src/cmd/gc/gen.c                                   |     6 +-
 src/cmd/gc/go.y                                    |     2 +
 src/cmd/gc/lex.c                                   |     8 +-
 src/cmd/gc/order.c                                 |    14 +-
 src/cmd/gc/subr.c                                  |     3 +-
 src/cmd/gc/typecheck.c                             |    35 +-
 src/cmd/gc/y.tab.c                                 |   526 +-
 src/cmd/go/build.go                                |   132 +-
 src/cmd/go/doc.go                                  |    30 +-
 src/cmd/go/get.go                                  |    12 +
 src/cmd/go/go_windows_test.go                      |    55 +
 src/cmd/go/help.go                                 |     3 +-
 src/cmd/go/pkg.go                                  |    28 +-
 src/cmd/go/test.bash                               |   267 +-
 src/cmd/go/test.go                                 |   143 +-
 src/cmd/go/testdata/src/badc/x.c                   |     1 +
 src/cmd/go/testdata/src/badc/x.go                  |     1 +
 src/cmd/go/testdata/src/badtest/badexec/x_test.go  |     5 +
 src/cmd/go/testdata/src/badtest/badsyntax/x.go     |     1 +
 .../go/testdata/src/badtest/badsyntax/x_test.go    |     3 +
 src/cmd/go/testdata/src/badtest/badvar/x.go        |     1 +
 src/cmd/go/testdata/src/badtest/badvar/x_test.go   |     5 +
 src/cmd/go/testflag.go                             |     7 +-
 src/cmd/go/testgo.go                               |    21 +
 src/cmd/go/vcs.go                                  |    92 +-
 src/cmd/gofmt/gofmt.go                             |   184 +-
 src/cmd/gofmt/long_test.go                         |     4 +-
 src/cmd/gofmt/testdata/stdin6.golden               |    19 +
 src/cmd/gofmt/testdata/stdin6.input                |    21 +
 src/cmd/gofmt/testdata/stdin7.golden               |    19 +
 src/cmd/gofmt/testdata/stdin7.input                |    21 +
 src/cmd/internal/rsc.io/arm/armasm/Makefile        |     2 +
 src/cmd/internal/rsc.io/arm/armasm/decode.go       |   567 +
 src/cmd/internal/rsc.io/arm/armasm/decode_test.go  |    69 +
 src/cmd/internal/rsc.io/arm/armasm/ext_test.go     |   614 +
 src/cmd/internal/rsc.io/arm/armasm/gnu.go          |   164 +
 src/cmd/internal/rsc.io/arm/armasm/inst.go         |   438 +
 src/cmd/internal/rsc.io/arm/armasm/objdump_test.go |   258 +
 .../internal/rsc.io/arm/armasm/objdumpext_test.go  |   260 +
 src/cmd/internal/rsc.io/arm/armasm/plan9x.go       |   211 +
 src/cmd/internal/rsc.io/arm/armasm/tables.go       |  9448 +++++++++++++
 .../internal/rsc.io/arm/armasm/testdata/Makefile   |     5 +
 .../internal/rsc.io/arm/armasm/testdata/decode.txt |   306 +
 src/cmd/internal/rsc.io/x86/x86asm/Makefile        |     3 +
 src/cmd/internal/rsc.io/x86/x86asm/decode.go       |  1616 +++
 src/cmd/internal/rsc.io/x86/x86asm/decode_test.go  |    71 +
 src/cmd/internal/rsc.io/x86/x86asm/ext_test.go     |   811 ++
 src/cmd/internal/rsc.io/x86/x86asm/gnu.go          |   926 ++
 src/cmd/internal/rsc.io/x86/x86asm/inst.go         |   641 +
 src/cmd/internal/rsc.io/x86/x86asm/inst_test.go    |    20 +
 src/cmd/internal/rsc.io/x86/x86asm/intel.go        |   518 +
 src/cmd/internal/rsc.io/x86/x86asm/objdump_test.go |   383 +
 .../internal/rsc.io/x86/x86asm/objdumpext_test.go  |   314 +
 .../internal/rsc.io/x86/x86asm/plan9ext_test.go    |   120 +
 src/cmd/internal/rsc.io/x86/x86asm/plan9x.go       |   346 +
 src/cmd/internal/rsc.io/x86/x86asm/plan9x_test.go  |    54 +
 src/cmd/internal/rsc.io/x86/x86asm/tables.go       |  9760 +++++++++++++
 .../internal/rsc.io/x86/x86asm/testdata/Makefile   |    12 +
 .../internal/rsc.io/x86/x86asm/testdata/decode.txt |  6731 +++++++++
 src/cmd/internal/rsc.io/x86/x86asm/xed_test.go     |   211 +
 src/cmd/internal/rsc.io/x86/x86asm/xedext_test.go  |   206 +
 src/cmd/ld/data.c                                  |    21 +-
 src/cmd/ld/lib.c                                   |    10 +-
 src/cmd/ld/pobj.c                                  |     9 +
 src/cmd/objdump/armasm.go                          | 10821 ---------------
 src/cmd/objdump/main.go                            |    11 +-
 src/cmd/objdump/x86.go                             | 13800 -------------------
 src/cmd/pack/doc.go                                |     4 +
 src/cmd/pack/pack.go                               |    50 +-
 src/cmd/pack/pack_test.go                          |    23 +-
 src/cmd/pprof/internal/commands/commands.go        |   197 +
 src/cmd/pprof/internal/driver/driver.go            |  1036 ++
 src/cmd/pprof/internal/driver/interactive.go       |   492 +
 src/cmd/pprof/internal/fetch/fetch.go              |    82 +
 src/cmd/pprof/internal/plugin/plugin.go            |   213 +
 src/cmd/pprof/internal/profile/encode.go           |   470 +
 src/cmd/pprof/internal/profile/filter.go           |   157 +
 src/cmd/pprof/internal/profile/legacy_profile.go   |  1250 ++
 src/cmd/pprof/internal/profile/profile.go          |   567 +
 src/cmd/pprof/internal/profile/proto.go            |   298 +
 src/cmd/pprof/internal/profile/prune.go            |    97 +
 src/cmd/pprof/internal/report/report.go            |  1718 +++
 src/cmd/pprof/internal/report/source.go            |   450 +
 src/cmd/pprof/internal/report/source_html.go       |    77 +
 src/cmd/pprof/internal/svg/svg.go                  |    75 +
 src/cmd/pprof/internal/symbolizer/symbolizer.go    |   191 +
 src/cmd/pprof/internal/symbolz/symbolz.go          |   111 +
 src/cmd/pprof/internal/tempfile/tempfile.go        |    45 +
 src/cmd/pprof/pprof.go                             |   202 +
 src/cmd/yacc/testdata/expr/expr.y                  |     2 +
 src/cmd/yacc/yacc.go                               |    90 +-
 src/compress/bzip2/bzip2.go                        |     2 +
 src/compress/flate/inflate.go                      |     8 +-
 src/compress/gzip/gunzip.go                        |     3 +-
 src/compress/lzw/reader.go                         |     2 +
 src/compress/zlib/reader.go                        |     1 +
 src/crypto/tls/handshake_server.go                 |     4 +
 src/crypto/tls/handshake_server_test.go            |    26 +
 .../testdata/Server-TLSv12-IssueTicketPreDisable   |    87 +
 .../tls/testdata/Server-TLSv12-ResumeDisabled      |    87 +
 src/crypto/tls/ticket.go                           |     3 +-
 src/crypto/x509/pkix/pkix.go                       |     2 +-
 src/crypto/x509/root_unix.go                       |    25 +
 src/crypto/x509/x509.go                            |     2 +-
 src/crypto/x509/x509_test.go                       |    11 +
 src/database/sql/sql.go                            |    41 +-
 src/database/sql/sql_test.go                       |    31 +
 src/debug/dwarf/type.go                            |    11 +
 src/encoding/asn1/asn1.go                          |    12 +-
 src/encoding/asn1/asn1_test.go                     |     5 +
 src/encoding/binary/binary.go                      |    77 +-
 src/encoding/binary/binary_test.go                 |    23 +-
 src/encoding/gob/decode.go                         |    13 +-
 src/encoding/gob/decoder.go                        |     9 +-
 src/encoding/gob/encode.go                         |    77 +-
 src/encoding/gob/encoder.go                        |     4 -
 src/encoding/gob/encoder_test.go                   |    22 +
 src/encoding/gob/type.go                           |    76 +-
 src/encoding/json/decode.go                        |     6 +-
 src/encoding/json/decode_test.go                   |    12 +-
 src/flag/flag.go                                   |    15 +-
 src/flag/flag_test.go                              |    10 +
 src/fmt/doc.go                                     |    24 +-
 src/fmt/fmt_test.go                                |   123 +-
 src/fmt/format.go                                  |    52 +-
 src/fmt/print.go                                   |   179 +-
 src/go/build/build.go                              |     6 +-
 src/go/build/doc.go                                |     1 +
 src/go/doc/exports.go                              |    26 +-
 src/go/doc/testdata/blank.0.golden                 |    37 +
 src/go/doc/testdata/blank.1.golden                 |    46 +
 src/go/doc/testdata/blank.2.golden                 |    37 +
 src/go/doc/testdata/blank.go                       |    38 +
 src/go/format/format.go                            |   221 +-
 src/go/format/format_test.go                       |     6 +-
 src/image/gif/reader.go                            |     7 +-
 src/image/gif/reader_test.go                       |    64 +-
 src/image/gif/writer.go                            |    18 +-
 src/image/gif/writer_test.go                       |    23 +
 src/lib9/tempdir_windows.c                         |    19 +-
 src/liblink/obj5.c                                 |    21 +-
 src/liblink/objfile.c                              |    36 +-
 src/log/syslog/syslog_unix.go                      |     2 +-
 src/math/big/int.go                                |     6 +
 src/math/big/int_test.go                           |    14 +-
 src/math/sincos_amd64.s                            |    13 +-
 src/net/dial_test.go                               |    14 +-
 src/net/dnsclient_unix.go                          |     2 +-
 src/net/dnsconfig_unix.go                          |     2 +-
 src/net/empty.c                                    |     8 -
 src/net/file_stub.go                               |    38 +
 src/net/file_test.go                               |     2 +-
 src/net/file_unix.go                               |     2 +-
 src/net/http/cookie.go                             |    10 +-
 src/net/http/cookie_test.go                        |    32 +
 src/net/http/export_test.go                        |    25 +
 src/net/http/httputil/dump.go                      |    12 +-
 src/net/http/httputil/dump_test.go                 |    30 +-
 src/net/http/{z_last_test.go => main_test.go}      |    30 +-
 src/net/http/request.go                            |     3 +-
 src/net/http/serve_test.go                         |    52 +
 src/net/http/server.go                             |    37 +-
 src/net/http/transport.go                          |    46 +-
 src/net/http/transport_test.go                     |    90 +-
 src/net/ipraw_test.go                              |     5 +
 src/net/lookup_stub.go                             |    49 +
 src/net/lookup_unix.go                             |     2 +-
 src/net/mail/message.go                            |    13 +-
 src/net/mail/message_test.go                       |    10 +
 src/net/net.go                                     |     1 -
 src/net/port_test.go                               |     6 +
 src/net/port_unix.go                               |     2 +-
 src/net/rpc/server.go                              |    25 +-
 src/net/sock_bsd.go                                |     2 +-
 src/net/{sock_solaris.go => sock_stub.go}          |     2 +
 src/net/sockopt_bsd.go                             |     2 +-
 src/net/sockopt_posix.go                           |     2 +-
 src/net/sockopt_stub.go                            |    37 +
 src/net/sockoptip_bsd.go                           |     2 +-
 src/net/sockoptip_posix.go                         |     2 +-
 src/net/sockoptip_stub.go                          |    14 +-
 src/net/tcpsockopt_openbsd.go                      |    16 +
 src/net/tcpsockopt_posix.go                        |     2 +-
 src/net/tcpsockopt_stub.go                         |     8 +-
 src/os/env.go                                      |     5 +
 src/os/env_test.go                                 |    26 +
 src/os/error_plan9.go                              |     2 +-
 src/os/exec/exec_test.go                           |     5 +-
 src/os/os_test.go                                  |    50 +
 src/os/path.go                                     |    10 +-
 src/os/proc.go                                     |    15 +-
 src/os/signal/signal_test.go                       |     6 +-
 src/path/filepath/match.go                         |     8 +-
 src/reflect/all_test.go                            |    68 +
 src/reflect/type.go                                |    18 +-
 src/reflect/value.go                               |     6 +-
 src/regexp/syntax/parse.go                         |    34 +
 src/regexp/syntax/parse_test.go                    |    13 +
 src/run.bash                                       |    15 +-
 src/run.bat                                        |     7 +
 src/runtime/asm_386.s                              |    21 +-
 src/runtime/asm_amd64.s                            |    22 +-
 src/runtime/asm_amd64p32.s                         |     2 -
 src/runtime/asm_arm.s                              |    28 +-
 src/runtime/cgo/callbacks.c                        |     3 +
 src/runtime/cgo/dragonfly.c                        |     4 +
 src/runtime/cgo/freebsd.c                          |     4 +
 src/runtime/cgo/gcc_setenv.c                       |     7 +
 src/runtime/cgo/netbsd.c                           |     4 +
 src/runtime/cgo/openbsd.c                          |     4 +
 src/runtime/cgo/setenv.c                           |     3 +
 src/runtime/cgocall.go                             |    12 +-
 src/runtime/crash_test.go                          |    88 +
 src/runtime/debug.go                               |    30 +-
 src/runtime/debug/{debug.c => debug.s}             |     0
 src/runtime/defs_windows.go                        |     1 -
 src/runtime/defs_windows_386.h                     |     1 -
 src/runtime/defs_windows_amd64.h                   |     1 -
 src/runtime/env_posix.go                           |    13 +-
 src/runtime/error.go                               |    22 -
 src/runtime/heapdump.c                             |    28 +-
 src/runtime/malloc.c                               |    28 +-
 src/runtime/malloc.go                              |     2 +-
 src/runtime/malloc.h                               |     5 +-
 src/runtime/mcache.c                               |    10 +-
 src/runtime/mem.go                                 |    43 +-
 src/runtime/mem_plan9.c                            |     1 +
 src/runtime/mem_windows.c                          |    12 +
 src/runtime/mgc0.c                                 |   157 +-
 src/runtime/mheap.c                                |     4 +
 src/runtime/os_windows.c                           |    12 +-
 src/runtime/os_windows_386.c                       |    28 -
 src/runtime/os_windows_amd64.c                     |    25 -
 src/runtime/panic.go                               |    80 +-
 src/runtime/proc.c                                 |   164 +-
 src/runtime/proc.go                                |     8 +
 src/runtime/rt0_linux_386.s                        |     2 +-
 src/runtime/rt0_linux_arm.s                        |     2 +-
 src/runtime/rt0_plan9_386.s                        |     8 +-
 src/runtime/rt0_plan9_amd64.s                      |     8 +-
 src/runtime/rt0_solaris_amd64.s                    |     2 +-
 src/runtime/rt0_windows_386.s                      |     2 +-
 src/runtime/rt0_windows_amd64.s                    |     2 +-
 src/runtime/runtime.c                              |    47 +-
 src/runtime/runtime.go                             |    11 +
 src/runtime/runtime.h                              |    44 +-
 src/runtime/runtime_test.go                        |    26 +-
 src/runtime/sema.go                                |     5 +
 src/runtime/signals_darwin.h                       |     3 +
 src/runtime/signals_dragonfly.h                    |     3 +
 src/runtime/signals_freebsd.h                      |     3 +
 src/runtime/signals_linux.h                        |     3 +
 src/runtime/signals_nacl.h                         |     3 +
 src/runtime/signals_netbsd.h                       |     3 +
 src/runtime/signals_openbsd.h                      |     3 +
 src/runtime/signals_plan9.h                        |     3 +
 src/runtime/signals_solaris.h                      |     3 +
 src/runtime/stack.c                                |    92 +-
 src/runtime/stack.h                                |    21 +-
 src/runtime/stack_test.go                          |     4 -
 src/runtime/stubs.go                               |     7 +-
 src/runtime/sys_dragonfly_386.s                    |     2 +-
 src/runtime/sys_freebsd_386.s                      |     2 +-
 src/runtime/sys_netbsd_386.s                       |     2 +-
 src/runtime/sys_openbsd_386.s                      |     2 +-
 src/runtime/sys_windows_386.s                      |     2 +-
 src/runtime/sys_windows_amd64.s                    |     2 +-
 src/runtime/syscall_windows_test.go                |     6 +
 src/runtime/thunk.s                                |    20 +-
 src/runtime/tls_arm.s                              |     6 +-
 src/runtime/traceback.go                           |    48 +-
 src/runtime/vdso_linux_amd64.c                     |     9 +-
 src/strings/strings.go                             |     2 +
 src/sync/atomic/64bit_arm.go                       |    12 +
 src/sync/atomic/asm_arm.s                          |     2 +-
 src/sync/atomic/asm_linux_arm.s                    |     2 +-
 src/sync/atomic/export_linux_arm_test.go           |     2 -
 src/sync/atomic/value.go                           |    85 +
 src/sync/atomic/value_test.go                      |   195 +
 src/sync/once.go                                   |     7 +-
 src/sync/once_test.go                              |    26 +-
 src/syscall/asm_darwin_386.s                       |     5 -
 src/syscall/asm_darwin_amd64.s                     |     4 -
 src/syscall/asm_dragonfly_386.s                    |     5 -
 src/syscall/asm_dragonfly_amd64.s                  |     5 -
 src/syscall/asm_freebsd_386.s                      |     5 -
 src/syscall/asm_freebsd_amd64.s                    |     5 -
 src/syscall/asm_freebsd_arm.s                      |     5 -
 src/syscall/asm_linux_386.s                        |     7 -
 src/syscall/asm_linux_amd64.s                      |     5 -
 src/syscall/asm_linux_arm.s                        |     5 -
 src/syscall/asm_nacl_386.s                         |     1 -
 src/syscall/asm_nacl_amd64p32.s                    |     1 -
 src/syscall/asm_nacl_arm.s                         |     1 -
 src/syscall/asm_netbsd_386.s                       |     5 -
 src/syscall/asm_netbsd_amd64.s                     |     5 -
 src/syscall/asm_netbsd_arm.s                       |     5 -
 src/syscall/asm_openbsd_386.s                      |     5 -
 src/syscall/asm_openbsd_amd64.s                    |     5 -
 src/syscall/asm_plan9_386.s                        |     6 -
 src/syscall/asm_plan9_amd64.s                      |     6 -
 src/syscall/env_plan9.go                           |    39 +-
 src/syscall/env_unix.go                            |    48 +-
 src/syscall/env_windows.go                         |     8 +
 src/syscall/exec_linux.go                          |   123 +-
 .../syscall/export_test.go                         |     8 +-
 src/syscall/mksyscall_windows.go                   |    24 +-
 src/syscall/str.go                                 |     6 +-
 src/syscall/syscall_test.go                        |    17 +
 src/syscall/syscall_unix.go                        |     2 +-
 src/syscall/zsyscall_windows.go                    |    15 +-
 src/testing/allocs_test.go                         |    29 +
 src/testing/testing.go                             |    58 +-
 src/testing/testing_test.go                        |    18 +
 src/text/template/doc.go                           |     9 +-
 src/text/template/exec.go                          |     2 +
 src/text/template/exec_test.go                     |    74 +-
 src/text/template/funcs.go                         |    86 +-
 src/time/sleep.go                                  |     1 +
 src/time/time.go                                   |     5 +
 test/escape2.go                                    |     2 +
 test/escape2n.go                                   |  1494 ++
 test/fixedbugs/bug491.go                           |   110 +
 test/fixedbugs/issue4232.go                        |    29 +-
 test/fixedbugs/issue8280.dir/a.go                  |     3 +
 test/fixedbugs/issue8280.dir/b.go                  |     5 +
 test/fixedbugs/issue8280.go                        |     9 +
 test/fixedbugs/issue8311.go                        |    16 +
 test/fixedbugs/issue8507.go                        |    16 +
 test/fixedbugs/issue8761.go                        |    26 +
 test/linkx.go                                      |     2 +-
 test/live.go                                       |    20 +-
 test/live2.go                                      |    10 +-
 test/nosplit.go                                    |    13 +-
 367 files changed, 50092 insertions(+), 26680 deletions(-)

diff --cc src/runtime/mgc0.c
index b4cd3474d7,9b9bc0ef13..39fae9bbe4
--- a/src/runtime/mgc0.c
+++ b/src/runtime/mgc0.c
@@@ -160,174 -155,41 +161,174 @@@ struct WorkData 
  	// Copy of mheap.allspans for marker or sweeper.
  	MSpan**	spans;
  	uint32	nspan;
- } work;
+ };
+ WorkData runtime·work;
  
 -// scanblock scans a block of n bytes starting at pointer b for references
 -// to other objects, scanning any it finds recursively until there are no
 -// unscanned objects left.  Instead of using an explicit recursion, it keeps
 -// a work list in the Workbuf* structures and loops in the main function
 -// body.  Keeping an explicit work list is easier on the stack allocator and
 -// more efficient.
 +// Is address b in the known heap. If it doesn't have a valid gcmap
 +// returns false. For example pointers into stacks will return false.
 +static bool
 +inheap(byte *b)
 +{
 +	MSpan *s;
 +	pageID k;
 +	uintptr x;
 +
 +	if(b == nil || b < runtime·mheap.arena_start || b >= runtime·mheap.arena_used)
 +		return false;
 +	// Not a beginning of a block, consult span table to find the block beginning.
 +	k = (uintptr)b>>PageShift;
 +	x = k;
 +	x -= (uintptr)runtime·mheap.arena_start>>PageShift;
 +	s = runtime·mheap.spans[x];
 +	if(s == nil || k < s->start || b >= s->limit || s->state != MSpanInUse)
 +		return false;
 +	return true;
 +}
 +
 +// Given an address in the heap return the relevant byte from the gcmap. This routine
 +// can be used on addresses to the start of an object or to the interior of the an object.
  static void
 -scanblock(byte *b, uintptr n, byte *ptrmask)
 +slottombits(byte *obj, Markbits *mbits)
  {
 -	byte *obj, *p, *arena_start, *arena_used, **wp, *scanbuf[8], *ptrbitp, *bitp, bits, xbits, shift, cached;
 -	uintptr i, nobj, size, idx, x, off, scanbufpos;
 -	intptr ncached;
 -	Workbuf *wbuf;
 -	Iface *iface;
 -	Eface *eface;
 -	Type *typ;
 +	uintptr off;
 +
 +	off = (uintptr*)((uintptr)obj&~(PtrSize-1)) - (uintptr*)runtime·mheap.arena_start;
 +	mbits->bitp = runtime·mheap.arena_start - off/wordsPerBitmapByte - 1;
 +	mbits->shift = (off % wordsPerBitmapByte) * gcBits;
 +	mbits->xbits = *mbits->bitp;
 +	mbits->bits = (mbits->xbits >> mbits->shift) & bitMask;
 +}
 +
 +// b is a pointer into the heap.
 +// Find the start of the object refered to by b.
 +// Set mbits to the associated bits from the bit map.
 +static byte*
 +objectstart(byte *b, Markbits *mbits)
 +{
 +	byte *obj, *p;
  	MSpan *s;
  	pageID k;
 -	bool keepworking;
 +	uintptr x, size, idx;
  
 -	// Cache memory arena parameters in local vars.
 -	arena_start = runtime·mheap.arena_start;
 -	arena_used = runtime·mheap.arena_used;
 +	obj = (byte*)((uintptr)b&~(PtrSize-1));
 +	for(;;) {
 +		slottombits(obj, mbits);
 +		if(mbits->bits&bitBoundary == bitBoundary)
 +			break;
 +		
 +		// Not a beginning of a block, consult span table to find the block beginning.
 +		k = (uintptr)obj>>PageShift;
 +		x = k;
 +		x -= (uintptr)runtime·mheap.arena_start>>PageShift;
 +		s = runtime·mheap.spans[x];
 +		if(s == nil || k < s->start || obj >= s->limit || s->state != MSpanInUse){
 +			if(s->state == MSpanStack)
 +				break; // This is legit.
 +
 +			// The following is catching some bugs left over from
 +			// us not being rigerous about what data structures are
 +			// hold valid pointers and different parts of the system
 +			// considering different structures as roots. For example
 +			// if there is a pointer into a stack that is left in 
 +			// a global data structure but that part of the runtime knows that 
 +			// those structures will be reinitialized before they are 
 +			// reused. Unfortunately the GC believes these roots are valid.
 +			// Typically a stack gets moved and only the structures that part of
 +			// the system knows are alive are updated. The span is freed
 +			// after the stack copy and the pointer is still alive. This 
 +			// check is catching that bug but for now we will not throw, 
 +			// instead we will simply break out of this routine and depend
 +			// on the caller to recognize that this pointer is not a valid 
 +			// heap pointer. I leave the code that catches the bug so that once
 +			// resolved we can turn this check back on and throw.
 +
 +			//runtime·printf("Runtime: Span weird: obj=%p, k=%p", obj, k);
 +			//if (s == nil)
 +			//	runtime·printf(" s=nil\n");
 +			//else
 +			//	runtime·printf(" s->start=%p s->limit=%p, s->state=%d\n", s->start*PageSize, s->limit, s->state);
 +			//runtime·throw("Blowup on weird span");
 +			break; // We are not in a real block throw??
 +		}
 +		p = (byte*)((uintptr)s->start<<PageShift);
 +		if(s->sizeclass != 0) {
 +			size = s->elemsize;
 +			idx = ((byte*)obj - p)/size;
 +			p = p+idx*size;
 +		}
 +		if(p == obj) {
 +			runtime·printf("runtime: failed to find block beginning for %p s=%p s->limit=%p\n",
 +				       p, s->start*PageSize, s->limit);
 +			runtime·throw("failed to find block beginning");
 +		}
 +		obj = p;
 +	}
 +	// if size(obj.firstfield) < PtrSize, the &obj.secondfield could map to the boundary bit
 +	// Clear any low bits to get to the start of the object.
 +	// greyobject depends on this.
 +	return obj;
 +}
  
 -	wbuf = getempty(nil);
 -	nobj = wbuf->nobj;
 -	wp = &wbuf->obj[nobj];
 -	keepworking = b == nil;
 -	scanbufpos = 0;
 -	for(i = 0; i < nelem(scanbuf); i++)
 -		scanbuf[i] = nil;
 +// obj is the start of an object with mark mbits.
 +// If it isn't already marked, mark it and enqueue into workbuf.
 +// Return possibly new workbuf to use.
 +static Workbuf*
 +greyobject(byte *obj, Markbits *mbits, Workbuf *wbuf) 
 +{
 +	// obj should be start of allocation, and so must be at least pointer-aligned.
 +	if(((uintptr)obj & (PtrSize-1)) != 0)
 +		runtime·throw("greyobject: obj not pointer-aligned");
 +
 +	// If marked we have nothing to do.
 +	if((mbits->bits&bitMarked) != 0)
 +		return wbuf;
 +
 +	// Each byte of GC bitmap holds info for two words.
 +	// If the current object is larger than two words, or if the object is one word
 +	// but the object it shares the byte with is already marked,
 +	// then all the possible concurrent updates are trying to set the same bit,
 +	// so we can use a non-atomic update.
- 	if((mbits->xbits&(bitMask|(bitMask<<gcBits))) != (bitBoundary|(bitBoundary<<gcBits)) ||
- 				work.nproc == 1)
++	if((mbits->xbits&(bitMask|(bitMask<<gcBits))) != (bitBoundary|(bitBoundary<<gcBits)) || runtime·work.nproc == 1)
 +		*mbits->bitp = mbits->xbits | (bitMarked<<mbits->shift);
 +	else
 +		runtime·atomicor8(mbits->bitp, bitMarked<<mbits->shift);
 +	
 +	if(((mbits->xbits>>(mbits->shift+2))&BitsMask) == BitsDead)
 +		return wbuf;  // noscan object
 +
 +	// Queue the obj for scanning. The PREFETCH(obj) logic has been removed but
 +	// seems like a nice optimization that can be added back in.
 +	// There needs to be time between the PREFETCH and the use.
 +	// Previously we put the obj in an 8 element buffer that is drained at a rate
 +	// to give the PREFETCH time to do its work.
 +	// Use of PREFETCHNTA might be more appropriate than PREFETCH
 +
 +	// If workbuf is full, obtain an empty one.
 +	if(wbuf->nobj >= nelem(wbuf->obj)) {
 +		wbuf = getempty(wbuf);
 +	}
 +
 +	wbuf->obj[wbuf->nobj] = obj;
 +	wbuf->nobj++;
 +	return wbuf;                    
 +}
  
 +// Scan the object b of size n, adding pointers to wbuf.
 +// Return possibly new wbuf to use.
 +// If ptrmask != nil, it specifies where pointers are in b.
 +// If ptrmask == nil, the GC bitmap should be consulted.
 +// In this case, n may be an overestimate of the size; the GC bitmap
 +// must also be used to make sure the scan stops at the end of b.
 +static Workbuf*
 +scanobject(byte *b, uintptr n, byte *ptrmask, Workbuf *wbuf)
 +{
 +	byte *obj, *arena_start, *arena_used, *ptrbitp, bits, cshift, cached;
 +	uintptr i;
 +	intptr ncached;
 +	Markbits mbits;
 +
 +	arena_start = (byte*)runtime·mheap.arena_start;
 +	arena_used = runtime·mheap.arena_used;
  	ptrbitp = nil;
  	cached = 0;
  	ncached = 0;
@@@ -424,17 -225,191 +425,17 @@@ scanblock(byte *b, uintptr n, byte *ptr
  		}
  
  		// If another proc wants a pointer, give it some.
- 		if(work.nwait > 0 && wbuf->nobj > 4 && work.full == 0) {
 -		if(runtime·work.nwait > 0 && nobj > 4 && runtime·work.full == 0) {
 -			wbuf->nobj = nobj;
++		if(runtime·work.nwait > 0 && wbuf->nobj > 4 && runtime·work.full == 0) {
  			wbuf = handoff(wbuf);
 -			nobj = wbuf->nobj;
 -			wp = &wbuf->obj[nobj];
 -		}
 -
 -		wp--;
 -		nobj--;
 -		b = *wp;
 -		n = arena_used - b; // scan until next bitBoundary or BitsDead
 -		ptrmask = nil; // use GC bitmap for pointer info
 -
 -	scanobj:
 -		// Find bits of the beginning of the object.
 -		if(ptrmask == nil) {
 -			off = (uintptr*)b - (uintptr*)arena_start;
 -			ptrbitp = arena_start - off/wordsPerBitmapByte - 1;
 -			shift = (off % wordsPerBitmapByte) * gcBits;
 -			cached = *ptrbitp >> shift;
 -			cached &= ~bitBoundary;
 -			ncached = (8 - shift)/gcBits;
 -		}
 -		for(i = 0; i < n; i += PtrSize) {
 -			obj = nil;
 -			// Find bits for this word.
 -			if(ptrmask == nil) {
 -				// Check is we have reached end of span.
 -				if((((uintptr)b+i)%PageSize) == 0 &&
 -					runtime·mheap.spans[(b-arena_start)>>PageShift] != runtime·mheap.spans[(b+i-arena_start)>>PageShift])
 -					break;
 -				// Consult GC bitmap.
 -				if(ncached <= 0) {
 -					// Refill cache.
 -					cached = *--ptrbitp;
 -					ncached = 2;
 -				}
 -				bits = cached;
 -				cached >>= gcBits;
 -				ncached--;
 -				if((bits&bitBoundary) != 0)
 -					break; // reached beginning of the next object
 -				bits = (bits>>2)&BitsMask;
 -				if(bits == BitsDead)
 -					break; // reached no-scan part of the object
 -			} else // dense mask (stack or data)
 -				bits = (ptrmask[(i/PtrSize)/4]>>(((i/PtrSize)%4)*BitsPerPointer))&BitsMask;
 -
 -			if(bits == BitsScalar || bits == BitsDead)
 -				continue;
 -			if(bits == BitsPointer) {
 -				obj = *(byte**)(b+i);
 -				goto markobj;
 -			}
 -
 -			// With those three out of the way, must be multi-word.
 -			if(bits != BitsMultiWord)
 -				runtime·throw("unexpected garbage collection bits");
 -			// Find the next pair of bits.
 -			if(ptrmask == nil) {
 -				if(ncached <= 0) {
 -					// Refill cache.
 -					cached = *--ptrbitp;
 -					ncached = 2;
 -				}
 -				bits = (cached>>2)&BitsMask;
 -			} else
 -				bits = (ptrmask[((i+PtrSize)/PtrSize)/4]>>((((i+PtrSize)/PtrSize)%4)*BitsPerPointer))&BitsMask;
 -
 -			switch(bits) {
 -			default:
 -				runtime·throw("unexpected garbage collection bits");
 -			case BitsIface:
 -				iface = (Iface*)(b+i);
 -				if(iface->tab != nil) {
 -					typ = iface->tab->type;
 -					if(!(typ->kind&KindDirectIface) || !(typ->kind&KindNoPointers))
 -						obj = iface->data;
 -				}
 -				break;
 -			case BitsEface:
 -				eface = (Eface*)(b+i);
 -				typ = eface->type;
 -				if(typ != nil) {
 -					if(!(typ->kind&KindDirectIface) || !(typ->kind&KindNoPointers))
 -						obj = eface->data;
 -				}
 -				break;
 -			}
 -
 -			i += PtrSize;
 -			cached >>= gcBits;
 -			ncached--;
 -
 -		markobj:
 -			// At this point we have extracted the next potential pointer.
 -			// Check if it points into heap.
 -			if(obj == nil || obj < arena_start || obj >= arena_used)
 -				continue;
 -			// Mark the object.
 -			off = (uintptr*)obj - (uintptr*)arena_start;
 -			bitp = arena_start - off/wordsPerBitmapByte - 1;
 -			shift = (off % wordsPerBitmapByte) * gcBits;
 -			xbits = *bitp;
 -			bits = (xbits >> shift) & bitMask;
 -			if((bits&bitBoundary) == 0) {
 -				// Not a beginning of a block, consult span table to find the block beginning.
 -				k = (uintptr)obj>>PageShift;
 -				x = k;
 -				x -= (uintptr)arena_start>>PageShift;
 -				s = runtime·mheap.spans[x];
 -				if(s == nil || k < s->start || obj >= s->limit || s->state != MSpanInUse)
 -					continue;
 -				p = (byte*)((uintptr)s->start<<PageShift);
 -				if(s->sizeclass != 0) {
 -					size = s->elemsize;
 -					idx = ((byte*)obj - p)/size;
 -					p = p+idx*size;
 -				}
 -				if(p == obj) {
 -					runtime·printf("runtime: failed to find block beginning for %p s=%p s->limit=%p\n",
 -						p, s->start*PageSize, s->limit);
 -					runtime·throw("failed to find block beginning");
 -				}
 -				obj = p;
 -				goto markobj;
 -			}
 -
 -			// Now we have bits, bitp, and shift correct for
 -			// obj pointing at the base of the object.
 -			// Only care about not marked objects.
 -			if((bits&bitMarked) != 0)
 -				continue;
 -			// If obj size is greater than 8, then each byte of GC bitmap
 -			// contains info for at most one object. In such case we use
 -			// non-atomic byte store to mark the object. This can lead
 -			// to double enqueue of the object for scanning, but scanning
 -			// is an idempotent operation, so it is OK. This cannot lead
 -			// to bitmap corruption because the single marked bit is the
 -			// only thing that can change in the byte.
 -			// For 8-byte objects we use non-atomic store, if the other
 -			// quadruple is already marked. Otherwise we resort to CAS
 -			// loop for marking.
 -			if((xbits&(bitMask|(bitMask<<gcBits))) != (bitBoundary|(bitBoundary<<gcBits)) ||
 -				runtime·work.nproc == 1)
 -				*bitp = xbits | (bitMarked<<shift);
 -			else
 -				runtime·atomicor8(bitp, bitMarked<<shift);
 -
 -			if(((xbits>>(shift+2))&BitsMask) == BitsDead)
 -				continue;  // noscan object
 -
 -			// Queue the obj for scanning.
 -			PREFETCH(obj);
 -			obj = (byte*)((uintptr)obj & ~(PtrSize-1));
 -			p = scanbuf[scanbufpos];
 -			scanbuf[scanbufpos++] = obj;
 -			if(scanbufpos == nelem(scanbuf))
 -				scanbufpos = 0;
 -			if(p == nil)
 -				continue;
 -
 -			// If workbuf is full, obtain an empty one.
 -			if(nobj >= nelem(wbuf->obj)) {
 -				wbuf->nobj = nobj;
 -				wbuf = getempty(wbuf);
 -				nobj = wbuf->nobj;
 -				wp = &wbuf->obj[nobj];
 -			}
 -			*wp = p;
 -			wp++;
 -			nobj++;
  		}
  
 -		if(Debug && ptrmask == nil) {
 -			// For heap objects ensure that we did not overscan.
 -			n = 0;
 -			p = nil;
 -			if(!runtime·mlookup(b, &p, &n, nil) || b != p || i > n) {
 -				runtime·printf("runtime: scanned (%p,%p), heap object (%p,%p)\n", b, i, p, n);
 -				runtime·throw("scanblock: scanned invalid object");
 -			}
 -		}
 +		// This might be a good place to add prefetch code...
 +		// if(wbuf->nobj > 4) {
 +		//         PREFETCH(wbuf->obj[wbuf->nobj - 3];
 +		//  }
 +		--wbuf->nobj;
 +		b = wbuf->obj[wbuf->nobj];
 +		wbuf = scanobject(b, runtime·mheap.arena_used - b, nil, wbuf);
  	}
  }
  
@@@ -505,9 -479,9 +506,9 @@@ markroot(ParFor *desc, uint32 i
  		gp = runtime·allg[i - RootCount];
  		// remember when we've first observed the G blocked
  		// needed only to output in traceback
 -		status = runtime·readgstatus(gp);
 +		status = runtime·readgstatus(gp); // We are not in a scan state
  		if((status == Gwaiting || status == Gsyscall) && gp->waitsince == 0)
- 			gp->waitsince = work.tstart;
+ 			gp->waitsince = runtime·work.tstart;
  		// Shrink a stack if not much of it is being used.
  		runtime·shrinkstack(gp);
  		if(runtime·readgstatus(gp) == Gdead) 
@@@ -562,13 -512,9 +563,13 @@@ getempty(Workbuf *b
  		c->gcworkbuf = nil;
  	}
  	if(b == nil)
- 		b = (Workbuf*)runtime·lfstackpop(&work.empty);
+ 		b = (Workbuf*)runtime·lfstackpop(&runtime·work.empty);
 -	if(b == nil)
 +	if(b == nil) {
  		b = runtime·persistentalloc(sizeof(*b), CacheLineSize, &mstats.gc_sys);
 +		b->nobj = 0;
 +	}
 +	if(b->nobj != 0) 
 +		runtime·throw("getempty: b->nobj not 0/n");
  	b->nobj = 0;
  	return b;
  }
@@@ -585,87 -529,38 +586,87 @@@ putempty(Workbuf *b
  		c->gcworkbuf = b;
  		return;
  	}
- 	runtime·lfstackpush(&work.empty, &b->node);
+ 	runtime·lfstackpush(&runtime·work.empty, &b->node);
  }
  
 +// Get an partially empty work buffer from the mcache structure
 +// and if non is available get an empty one.
 +static Workbuf*
 +getpartial(void)
 +{
 +	MCache *c;
 +	Workbuf *b;
 +
 +	c = g->m->mcache;
 +	if(c->gcworkbuf != nil) {
 +		b = c->gcworkbuf;
 +		c->gcworkbuf = nil;
 +	} else {
 +		b = getempty(nil);
 +	}
 +	return b;
 +}
 +
 +static void
 +putpartial(Workbuf *b)
 +{
 +	MCache *c;
 +
 +	c = g->m->mcache;
 +	if(c->gcworkbuf == nil) {
 +		c->gcworkbuf = b;
 +		return;
 +	}
 +
 +	runtime·throw("putpartial: c->gcworkbuf is not nil\n");
 +	
- 	runtime·lfstackpush(&work.full, &b->node);
++	runtime·lfstackpush(&runtime·work.full, &b->node);
 +}
 +
  void
 -runtime·gcworkbuffree(void *b)
 +runtime·gcworkbuffree(Workbuf *b)
  {
 -	if(b != nil)
 +	if(b != nil) {
 +		if(b->nobj != 0) 
 +			runtime·throw("gcworkbufferfree: b->nobj not 0\n");
  		putempty(b);
 +	}
  }
  
 +
  // Get a full work buffer off the work.full list, or return nil.
 +// getfull acts as a barrier for work.nproc helpers. As long as one
 +// gchelper is actively marking objects it
 +// may create a workbuffer that the other helpers can work on.
 +// The for loop either exits when a work buffer is found
 +// or when _all_ of the work.nproc gc helpers are in the loop 
 +// looking for work and thus not capable of creating new work.
 +// This is in fact the termination condition for the STW mark 
 +// phase.
  static Workbuf*
  getfull(Workbuf *b)
  {
  	int32 i;
  
 -	if(b != nil)
 +	if(b != nil) {
 +		if(b->nobj != 0) 
 +			runtime·printf("runtime:getfull: b->nobj=%D not 0.", b->nobj);
- 		runtime·lfstackpush(&work.empty, &b->node);
+ 		runtime·lfstackpush(&runtime·work.empty, &b->node);
 +	}
- 	b = (Workbuf*)runtime·lfstackpop(&work.full);
- 	if(b != nil || work.nproc == 1)
+ 	b = (Workbuf*)runtime·lfstackpop(&runtime·work.full);
+ 	if(b != nil || runtime·work.nproc == 1)
  		return b;
  
- 	runtime·xadd(&work.nwait, +1);
+ 	runtime·xadd(&runtime·work.nwait, +1);
  	for(i=0;; i++) {
- 		if(work.full != 0) {
- 			runtime·xadd(&work.nwait, -1);
- 			b = (Workbuf*)runtime·lfstackpop(&work.full);
+ 		if(runtime·work.full != 0) {
+ 			runtime·xadd(&runtime·work.nwait, -1);
+ 			b = (Workbuf*)runtime·lfstackpop(&runtime·work.full);
  			if(b != nil)
  				return b;
- 			runtime·xadd(&work.nwait, +1);
+ 			runtime·xadd(&runtime·work.nwait, +1);
  		}
- 		if(work.nwait == work.nproc)
+ 		if(runtime·work.nwait == runtime·work.nproc)
  			return nil;
  		if(i < 10) {
  			g->m->gcstats.nprocyield++;
@@@ -1236,12 -1121,14 +1239,12 @@@ runtime·gchelper(void
  	gchelperstart();
  
  	// parallel mark for over gc roots
- 	runtime·parfordo(work.markfor);
+ 	runtime·parfordo(runtime·work.markfor);
 -
 -	// help other threads scan secondary blocks
 -	scanblock(nil, 0, nil);
 -
 -	nproc = runtime·work.nproc;  // runtime·work.nproc can change right after we increment runtime·work.ndone
 +	if(runtime·gcphase != GCscan) 
 +		scanblock(nil, 0, nil); // blocks in getfull
- 	nproc = work.nproc;  // work.nproc can change right after we increment work.ndone
- 	if(runtime·xadd(&work.ndone, +1) == nproc-1)
- 		runtime·notewakeup(&work.alldone);
++	nproc = runtime·work.nproc;  // work.nproc can change right after we increment work.ndone
+ 	if(runtime·xadd(&runtime·work.ndone, +1) == nproc-1)
+ 		runtime·notewakeup(&runtime·work.alldone);
  	g->m->traceback = 0;
  }
  
@@@ -1456,24 -1341,21 +1459,24 @@@ gc(struct gc_args *args
  	// Even if this is stop-the-world, a concurrent exitsyscall can allocate a stack from heap.
  	runtime·lock(&runtime·mheap.lock);
  	// Free the old cached sweep array if necessary.
- 	if(work.spans != nil && work.spans != runtime·mheap.allspans)
- 		runtime·SysFree(work.spans, work.nspan*sizeof(work.spans[0]), &mstats.other_sys);
+ 	if(runtime·work.spans != nil && runtime·work.spans != runtime·mheap.allspans)
+ 		runtime·SysFree(runtime·work.spans, runtime·work.nspan*sizeof(runtime·work.spans[0]), &mstats.other_sys);
  	// Cache the current array for marking.
  	runtime·mheap.gcspans = runtime·mheap.allspans;
- 	work.spans = runtime·mheap.allspans;
- 	work.nspan = runtime·mheap.nspan;
+ 	runtime·work.spans = runtime·mheap.allspans;
+ 	runtime·work.nspan = runtime·mheap.nspan;
  	runtime·unlock(&runtime·mheap.lock);
 +	oldphase = runtime·gcphase;
  
- 	work.nwait = 0;
- 	work.ndone = 0;
- 	work.nproc = runtime·gcprocs(); 
+ 	runtime·work.nwait = 0;
+ 	runtime·work.ndone = 0;
 -	runtime·work.nproc = runtime·gcprocs();
++	runtime·work.nproc = runtime·gcprocs(); 
 +	runtime·gcphase = GCmark;              //^^  vv
 +
- 	runtime·parforsetup(work.markfor, work.nproc, RootCount + runtime·allglen, nil, false, markroot);
- 	if(work.nproc > 1) {
- 		runtime·noteclear(&work.alldone);
- 		runtime·helpgc(work.nproc);
+ 	runtime·parforsetup(runtime·work.markfor, runtime·work.nproc, RootCount + runtime·allglen, nil, false, markroot);
+ 	if(runtime·work.nproc > 1) {
+ 		runtime·noteclear(&runtime·work.alldone);
+ 		runtime·helpgc(runtime·work.nproc);
  	}
  
  	t2 = 0;
@@@ -1481,10 -1363,9 +1484,10 @@@
  		t2 = runtime·nanotime();
  
  	gchelperstart();
- 	runtime·parfordo(work.markfor);
+ 	runtime·parfordo(runtime·work.markfor);
 -	scanblock(nil, 0, nil);
  
 +	scanblock(nil, 0, nil);
 +	runtime·gcphase = oldphase;            //^^  vv
  	t3 = 0;
  	if(runtime·debug.gctrace)
  		t3 = runtime·nanotime();
