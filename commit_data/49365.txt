commit 02f932e173c713333693993c509a663b9cb2bc8b
Author: Robert Findley <rfindley@google.com>
Date:   Sun Aug 15 21:04:39 2021 -0400

    go/types: better names for things (cleanup)
    
    This is a port of CL 339891 to go/types.
    
    Change-Id: If4d9bbb3ace45bec0f40082dd42ed2dd249100ec
    Reviewed-on: https://go-review.googlesource.com/c/go/+/342432
    Trust: Robert Findley <rfindley@google.com>
    Run-TryBot: Robert Findley <rfindley@google.com>
    TryBot-Result: Go Bot <gobot@golang.org>
    Reviewed-by: Robert Griesemer <gri@golang.org>
---
 src/go/types/instantiate.go   |  2 +-
 src/go/types/interface.go     |  2 +-
 src/go/types/termlist.go      | 22 ++++++-------
 src/go/types/termlist_test.go | 76 +++++++++++++++++++++----------------------
 src/go/types/typeset.go       | 20 ++++++------
 src/go/types/typeterm.go      | 31 ++++++++----------
 src/go/types/typeterm_test.go | 42 ++++++++++++------------
 src/go/types/universe.go      |  2 +-
 8 files changed, 97 insertions(+), 100 deletions(-)

diff --git a/src/go/types/instantiate.go b/src/go/types/instantiate.go
index 6f10feb206..dc2b29a5f7 100644
--- a/src/go/types/instantiate.go
+++ b/src/go/types/instantiate.go
@@ -176,7 +176,7 @@ func (check *Checker) satisfies(pos token.Pos, targ Type, tpar *TypeParam, smap
 	// if iface is comparable, targ must be comparable
 	// TODO(gri) the error messages needs to be better, here
 	if iface.IsComparable() && !Comparable(targ) {
-		if tpar := asTypeParam(targ); tpar != nil && tpar.iface().typeSet().IsTop() {
+		if tpar := asTypeParam(targ); tpar != nil && tpar.iface().typeSet().IsAll() {
 			check.softErrorf(atPos(pos), _Todo, "%s has no constraints", targ)
 			return false
 		}
diff --git a/src/go/types/interface.go b/src/go/types/interface.go
index a5d19e8265..510c123e97 100644
--- a/src/go/types/interface.go
+++ b/src/go/types/interface.go
@@ -96,7 +96,7 @@ func (t *Interface) NumMethods() int { return t.typeSet().NumMethods() }
 func (t *Interface) Method(i int) *Func { return t.typeSet().Method(i) }
 
 // Empty reports whether t is the empty interface.
-func (t *Interface) Empty() bool { return t.typeSet().IsTop() }
+func (t *Interface) Empty() bool { return t.typeSet().IsAll() }
 
 // IsComparable reports whether each type in interface t's type set is comparable.
 func (t *Interface) IsComparable() bool { return t.typeSet().IsComparable() }
diff --git a/src/go/types/termlist.go b/src/go/types/termlist.go
index 044c6a9466..99114cbf4c 100644
--- a/src/go/types/termlist.go
+++ b/src/go/types/termlist.go
@@ -13,9 +13,9 @@ import "bytes"
 // normal form.
 type termlist []*term
 
-// topTermlist represents the set of all types.
+// allTermlist represents the set of all types.
 // It is in normal form.
-var topTermlist = termlist{new(term)}
+var allTermlist = termlist{new(term)}
 
 // String prints the termlist exactly (without normalization).
 func (xl termlist) String() string {
@@ -45,9 +45,9 @@ func (xl termlist) isEmpty() bool {
 	return true
 }
 
-// isTop reports whether the termlist xl represents the set of all types.
-func (xl termlist) isTop() bool {
-	// If there's a âŠ¤ (top) term, the entire list is âŠ¤ (top).
+// isAll reports whether the termlist xl represents the set of all types.
+func (xl termlist) isAll() bool {
+	// If there's a ğ“¤ term, the entire list is ğ“¤.
 	// If the termlist is in normal form, this requires at most
 	// one iteration.
 	for _, x := range xl {
@@ -74,14 +74,14 @@ func (xl termlist) norm() termlist {
 				continue
 			}
 			if u1, u2 := xi.union(xj); u2 == nil {
-				// If we encounter a âŠ¤ (top) term, the entire
-				// list is âŠ¤ (top). Exit early.
+				// If we encounter a ğ“¤ term, the entire list is ğ“¤.
+				// Exit early.
 				// (Note that this is not just an optimization;
-				// if we continue, we may end up with a âŠ¤ term
+				// if we continue, we may end up with a ğ“¤ term
 				// and other terms and the result would not be
 				// in normal form.)
 				if u1.typ == nil {
-					return topTermlist
+					return allTermlist
 				}
 				xi = u1
 				used[j] = true // xj is now unioned into xi - ignore it in future iterations
@@ -92,11 +92,11 @@ func (xl termlist) norm() termlist {
 	return rl
 }
 
-// If the type set represented by xl is specified by a single (non-âŠ¤) term,
+// If the type set represented by xl is specified by a single (non-ğ“¤) term,
 // structuralType returns that type. Otherwise it returns nil.
 func (xl termlist) structuralType() Type {
 	if nl := xl.norm(); len(nl) == 1 {
-		return nl[0].typ // if nl.isTop() then typ is nil, which is ok
+		return nl[0].typ // if nl.isAll() then typ is nil, which is ok
 	}
 	return nil
 }
diff --git a/src/go/types/termlist_test.go b/src/go/types/termlist_test.go
index eeb820dfd2..92d49ffed8 100644
--- a/src/go/types/termlist_test.go
+++ b/src/go/types/termlist_test.go
@@ -21,7 +21,7 @@ func maketl(s string) termlist {
 }
 
 func TestTermlistTop(t *testing.T) {
-	if !topTermlist.isTop() {
+	if !allTermlist.isAll() {
 		t.Errorf("topTermlist is not top")
 	}
 }
@@ -29,12 +29,12 @@ func TestTermlistTop(t *testing.T) {
 func TestTermlistString(t *testing.T) {
 	for _, want := range []string{
 		"âˆ…",
-		"âŠ¤",
+		"ğ“¤",
 		"int",
 		"~int",
 		"âˆ… âˆª âˆ…",
-		"âŠ¤ âˆª âŠ¤",
-		"âˆ… âˆª âŠ¤ âˆª int",
+		"ğ“¤ âˆª ğ“¤",
+		"âˆ… âˆª ğ“¤ âˆª int",
 	} {
 		if got := maketl(want).String(); got != want {
 			t.Errorf("(%v).String() == %v", want, got)
@@ -46,9 +46,9 @@ func TestTermlistIsEmpty(t *testing.T) {
 	for test, want := range map[string]bool{
 		"âˆ…":         true,
 		"âˆ… âˆª âˆ…":     true,
-		"âˆ… âˆª âˆ… âˆª âŠ¤": false,
-		"âŠ¤":         false,
-		"âŠ¤ âˆª int":   false,
+		"âˆ… âˆª âˆ… âˆª ğ“¤": false,
+		"ğ“¤":         false,
+		"ğ“¤ âˆª int":   false,
 	} {
 		xl := maketl(test)
 		got := xl.isEmpty()
@@ -58,19 +58,19 @@ func TestTermlistIsEmpty(t *testing.T) {
 	}
 }
 
-func TestTermlistIsTop(t *testing.T) {
+func TestTermlistIsAll(t *testing.T) {
 	for test, want := range map[string]bool{
 		"âˆ…":             false,
 		"âˆ… âˆª âˆ…":         false,
 		"int âˆª ~string": false,
-		"âˆ… âˆª âˆ… âˆª âŠ¤":     true,
-		"âŠ¤":             true,
-		"âŠ¤ âˆª int":       true,
+		"âˆ… âˆª âˆ… âˆª ğ“¤":     true,
+		"ğ“¤":             true,
+		"ğ“¤ âˆª int":       true,
 	} {
 		xl := maketl(test)
-		got := xl.isTop()
+		got := xl.isAll()
 		if got != want {
-			t.Errorf("(%v).isTop() == %v; want %v", test, got, want)
+			t.Errorf("(%v).isAll() == %v; want %v", test, got, want)
 		}
 	}
 }
@@ -82,10 +82,10 @@ func TestTermlistNorm(t *testing.T) {
 		{"âˆ…", "âˆ…"},
 		{"âˆ… âˆª âˆ…", "âˆ…"},
 		{"âˆ… âˆª int", "int"},
-		{"âŠ¤ âˆª int", "âŠ¤"},
+		{"ğ“¤ âˆª int", "ğ“¤"},
 		{"~int âˆª int", "~int"},
 		{"int âˆª ~string âˆª int", "int âˆª ~string"},
-		{"~int âˆª string âˆª âŠ¤ âˆª ~string âˆª int", "âŠ¤"},
+		{"~int âˆª string âˆª ğ“¤ âˆª ~string âˆª int", "ğ“¤"},
 	} {
 		xl := maketl(test.xl)
 		got := maketl(test.xl).norm()
@@ -106,7 +106,7 @@ func TestTermlistStructuralType(t *testing.T) {
 
 	for test, want := range map[string]string{
 		"âˆ…":                 "nil",
-		"âŠ¤":                 "nil",
+		"ğ“¤":                 "nil",
 		"int":               "int",
 		"~int":              "int",
 		"~int âˆª string":     "nil",
@@ -128,15 +128,15 @@ func TestTermlistUnion(t *testing.T) {
 	}{
 
 		{"âˆ…", "âˆ…", "âˆ…"},
-		{"âˆ…", "âŠ¤", "âŠ¤"},
+		{"âˆ…", "ğ“¤", "ğ“¤"},
 		{"âˆ…", "int", "int"},
-		{"âŠ¤", "~int", "âŠ¤"},
+		{"ğ“¤", "~int", "ğ“¤"},
 		{"int", "~int", "~int"},
 		{"int", "string", "int âˆª string"},
 		{"int âˆª string", "~string", "int âˆª ~string"},
 		{"~int âˆª string", "~string âˆª int", "~int âˆª ~string"},
 		{"~int âˆª string âˆª âˆ…", "~string âˆª int", "~int âˆª ~string"},
-		{"~int âˆª string âˆª âŠ¤", "~string âˆª int", "âŠ¤"},
+		{"~int âˆª string âˆª ğ“¤", "~string âˆª int", "ğ“¤"},
 	} {
 		xl := maketl(test.xl)
 		yl := maketl(test.yl)
@@ -153,15 +153,15 @@ func TestTermlistIntersect(t *testing.T) {
 	}{
 
 		{"âˆ…", "âˆ…", "âˆ…"},
-		{"âˆ…", "âŠ¤", "âˆ…"},
+		{"âˆ…", "ğ“¤", "âˆ…"},
 		{"âˆ…", "int", "âˆ…"},
-		{"âŠ¤", "~int", "~int"},
+		{"ğ“¤", "~int", "~int"},
 		{"int", "~int", "int"},
 		{"int", "string", "âˆ…"},
 		{"int âˆª string", "~string", "string"},
 		{"~int âˆª string", "~string âˆª int", "int âˆª string"},
 		{"~int âˆª string âˆª âˆ…", "~string âˆª int", "int âˆª string"},
-		{"~int âˆª string âˆª âŠ¤", "~string âˆª int", "int âˆª ~string"},
+		{"~int âˆª string âˆª ğ“¤", "~string âˆª int", "int âˆª ~string"},
 	} {
 		xl := maketl(test.xl)
 		yl := maketl(test.yl)
@@ -178,10 +178,10 @@ func TestTermlistEqual(t *testing.T) {
 		want   bool
 	}{
 		{"âˆ…", "âˆ…", true},
-		{"âˆ…", "âŠ¤", false},
-		{"âŠ¤", "âŠ¤", true},
-		{"âŠ¤ âˆª int", "âŠ¤", true},
-		{"âŠ¤ âˆª int", "string âˆª âŠ¤", true},
+		{"âˆ…", "ğ“¤", false},
+		{"ğ“¤", "ğ“¤", true},
+		{"ğ“¤ âˆª int", "ğ“¤", true},
+		{"ğ“¤ âˆª int", "string âˆª ğ“¤", true},
 		{"int âˆª ~string", "string âˆª int", false},
 		{"int âˆª ~string âˆª âˆ…", "string âˆª int âˆª ~string", true},
 	} {
@@ -200,14 +200,14 @@ func TestTermlistIncludes(t *testing.T) {
 		want    bool
 	}{
 		{"âˆ…", "int", false},
-		{"âŠ¤", "int", true},
+		{"ğ“¤", "int", true},
 		{"~int", "int", true},
 		{"int", "string", false},
 		{"~int", "string", false},
 		{"int âˆª string", "string", true},
 		{"~int âˆª string", "int", true},
 		{"~int âˆª string âˆª âˆ…", "string", true},
-		{"~string âˆª âˆ… âˆª âŠ¤", "int", true},
+		{"~string âˆª âˆ… âˆª ğ“¤", "int", true},
 	} {
 		xl := maketl(test.xl)
 		yl := testTerm(test.typ).typ
@@ -224,12 +224,12 @@ func TestTermlistSupersetOf(t *testing.T) {
 		want    bool
 	}{
 		{"âˆ…", "âˆ…", true},
-		{"âˆ…", "âŠ¤", false},
+		{"âˆ…", "ğ“¤", false},
 		{"âˆ…", "int", false},
-		{"âŠ¤", "âˆ…", true},
-		{"âŠ¤", "âŠ¤", true},
-		{"âŠ¤", "int", true},
-		{"âŠ¤", "~int", true},
+		{"ğ“¤", "âˆ…", true},
+		{"ğ“¤", "ğ“¤", true},
+		{"ğ“¤", "int", true},
+		{"ğ“¤", "~int", true},
 		{"~int", "int", true},
 		{"~int", "~int", true},
 		{"int", "~int", false},
@@ -239,7 +239,7 @@ func TestTermlistSupersetOf(t *testing.T) {
 		{"int âˆª string", "~string", false},
 		{"~int âˆª string", "int", true},
 		{"~int âˆª string âˆª âˆ…", "string", true},
-		{"~string âˆª âˆ… âˆª âŠ¤", "int", true},
+		{"~string âˆª âˆ… âˆª ğ“¤", "int", true},
 	} {
 		xl := maketl(test.xl)
 		y := testTerm(test.typ)
@@ -256,16 +256,16 @@ func TestTermlistSubsetOf(t *testing.T) {
 		want   bool
 	}{
 		{"âˆ…", "âˆ…", true},
-		{"âˆ…", "âŠ¤", true},
-		{"âŠ¤", "âˆ…", false},
-		{"âŠ¤", "âŠ¤", true},
+		{"âˆ…", "ğ“¤", true},
+		{"ğ“¤", "âˆ…", false},
+		{"ğ“¤", "ğ“¤", true},
 		{"int", "int âˆª string", true},
 		{"~int", "int âˆª string", false},
 		{"~int", "string âˆª string âˆª int âˆª ~int", true},
 		{"int âˆª string", "string", false},
 		{"int âˆª string", "string âˆª int", true},
 		{"int âˆª ~string", "string âˆª int", false},
-		{"int âˆª ~string", "string âˆª int âˆª âŠ¤", true},
+		{"int âˆª ~string", "string âˆª int âˆª ğ“¤", true},
 		{"int âˆª ~string", "string âˆª int âˆª âˆ… âˆª string", false},
 	} {
 		xl := maketl(test.xl)
diff --git a/src/go/types/typeset.go b/src/go/types/typeset.go
index 307dae3aed..f0fce50263 100644
--- a/src/go/types/typeset.go
+++ b/src/go/types/typeset.go
@@ -25,17 +25,17 @@ type _TypeSet struct {
 // IsEmpty reports whether type set s is the empty set.
 func (s *_TypeSet) IsEmpty() bool { return s.terms.isEmpty() }
 
-// IsTop reports whether type set s is the set of all types (corresponding to the empty interface).
-func (s *_TypeSet) IsTop() bool { return !s.comparable && len(s.methods) == 0 && s.terms.isTop() }
+// IsAll reports whether type set s is the set of all types (corresponding to the empty interface).
+func (s *_TypeSet) IsAll() bool { return !s.comparable && len(s.methods) == 0 && s.terms.isAll() }
 
 // TODO(gri) IsMethodSet is not a great name for this predicate. Find a better one.
 
 // IsMethodSet reports whether the type set s is described by a single set of methods.
-func (s *_TypeSet) IsMethodSet() bool { return !s.comparable && s.terms.isTop() }
+func (s *_TypeSet) IsMethodSet() bool { return !s.comparable && s.terms.isAll() }
 
 // IsComparable reports whether each type in the set is comparable.
 func (s *_TypeSet) IsComparable() bool {
-	if s.terms.isTop() {
+	if s.terms.isAll() {
 		return s.comparable
 	}
 	return s.is(func(t *term) bool {
@@ -67,8 +67,8 @@ func (s *_TypeSet) String() string {
 	switch {
 	case s.IsEmpty():
 		return "âˆ…"
-	case s.IsTop():
-		return "âŠ¤"
+	case s.IsAll():
+		return "ğ“¤"
 	}
 
 	hasMethods := len(s.methods) > 0
@@ -103,7 +103,7 @@ func (s *_TypeSet) String() string {
 // ----------------------------------------------------------------------------
 // Implementation
 
-func (s *_TypeSet) hasTerms() bool              { return !s.terms.isTop() }
+func (s *_TypeSet) hasTerms() bool              { return !s.terms.isAll() }
 func (s *_TypeSet) structuralType() Type        { return s.terms.structuralType() }
 func (s *_TypeSet) includes(t Type) bool        { return s.terms.includes(t) }
 func (s1 *_TypeSet) subsetOf(s2 *_TypeSet) bool { return s1.terms.subsetOf(s2.terms) }
@@ -156,7 +156,7 @@ func (s *_TypeSet) underIs(f func(Type) bool) bool {
 }
 
 // topTypeSet may be used as type set for the empty interface.
-var topTypeSet = _TypeSet{terms: topTermlist}
+var topTypeSet = _TypeSet{terms: allTermlist}
 
 // computeInterfaceTypeSet may be called with check == nil.
 func computeInterfaceTypeSet(check *Checker, pos token.Pos, ityp *Interface) *_TypeSet {
@@ -199,7 +199,7 @@ func computeInterfaceTypeSet(check *Checker, pos token.Pos, ityp *Interface) *_T
 	// have valid interfaces. Mark the interface as complete to avoid
 	// infinite recursion if the validType check occurs later for some
 	// reason.
-	ityp.tset = &_TypeSet{terms: topTermlist} // TODO(gri) is this sufficient?
+	ityp.tset = &_TypeSet{terms: allTermlist} // TODO(gri) is this sufficient?
 
 	// Methods of embedded interfaces are collected unchanged; i.e., the identity
 	// of a method I.m's Func Object of an interface I is the same as that of
@@ -256,7 +256,7 @@ func computeInterfaceTypeSet(check *Checker, pos token.Pos, ityp *Interface) *_T
 	}
 
 	// collect embedded elements
-	var allTerms = topTermlist
+	var allTerms = allTermlist
 	for i, typ := range ityp.embeddeds {
 		// The embedding position is nil for imported interfaces
 		// and also for interface copies after substitution (but
diff --git a/src/go/types/typeterm.go b/src/go/types/typeterm.go
index dbd055a580..171e8f21b6 100644
--- a/src/go/types/typeterm.go
+++ b/src/go/types/typeterm.go
@@ -4,13 +4,10 @@
 
 package types
 
-// TODO(gri) use a different symbol instead of âŠ¤ for the set of all types
-//           (âŠ¤ is hard to distinguish from T in some fonts)
-
 // A term describes elementary type sets:
 //
 //   âˆ…:  (*term)(nil)     == âˆ…                      // set of no types (empty set)
-//   âŠ¤:  &term{}          == âŠ¤                      // set of all types
+//   ğ“¤:  &term{}          == ğ“¤                      // set of all types (ğ“¤niverse)
 //   T:  &term{false, T}  == {T}                    // set of type T
 //  ~t:  &term{true, t}   == {t' | under(t') == t}  // set of types with underlying type t
 //
@@ -24,7 +21,7 @@ func (x *term) String() string {
 	case x == nil:
 		return "âˆ…"
 	case x.typ == nil:
-		return "âŠ¤"
+		return "ğ“¤"
 	case x.tilde:
 		return "~" + x.typ.String()
 	default:
@@ -41,7 +38,7 @@ func (x *term) equal(y *term) bool {
 	case x.typ == nil || y.typ == nil:
 		return x.typ == y.typ
 	}
-	// âˆ… âŠ‚ x, y âŠ‚ âŠ¤
+	// âˆ… âŠ‚ x, y âŠ‚ ğ“¤
 
 	return x.tilde == y.tilde && Identical(x.typ, y.typ)
 }
@@ -57,11 +54,11 @@ func (x *term) union(y *term) (_, _ *term) {
 	case y == nil:
 		return x, nil // x âˆª âˆ… == x
 	case x.typ == nil:
-		return x, nil // âŠ¤ âˆª y == âŠ¤
+		return x, nil // ğ“¤ âˆª y == ğ“¤
 	case y.typ == nil:
-		return y, nil // x âˆª âŠ¤ == âŠ¤
+		return y, nil // x âˆª ğ“¤ == ğ“¤
 	}
-	// âˆ… âŠ‚ x, y âŠ‚ âŠ¤
+	// âˆ… âŠ‚ x, y âŠ‚ ğ“¤
 
 	if x.disjoint(y) {
 		return x, y // x âˆª y == (x, y) if x âˆ© y == âˆ…
@@ -85,11 +82,11 @@ func (x *term) intersect(y *term) *term {
 	case x == nil || y == nil:
 		return nil // âˆ… âˆ© y == âˆ… and âˆ© âˆ… == âˆ…
 	case x.typ == nil:
-		return y // âŠ¤ âˆ© y == y
+		return y // ğ“¤ âˆ© y == y
 	case y.typ == nil:
-		return x // x âˆ© âŠ¤ == x
+		return x // x âˆ© ğ“¤ == x
 	}
-	// âˆ… âŠ‚ x, y âŠ‚ âŠ¤
+	// âˆ… âŠ‚ x, y âŠ‚ ğ“¤
 
 	if x.disjoint(y) {
 		return nil // x âˆ© y == âˆ… if x âˆ© y == âˆ…
@@ -113,9 +110,9 @@ func (x *term) includes(t Type) bool {
 	case x == nil:
 		return false // t âˆˆ âˆ… == false
 	case x.typ == nil:
-		return true // t âˆˆ âŠ¤ == true
+		return true // t âˆˆ ğ“¤ == true
 	}
-	// âˆ… âŠ‚ x âŠ‚ âŠ¤
+	// âˆ… âŠ‚ x âŠ‚ ğ“¤
 
 	u := t
 	if x.tilde {
@@ -133,11 +130,11 @@ func (x *term) subsetOf(y *term) bool {
 	case y == nil:
 		return false // x âŠ† âˆ… == false since x != âˆ…
 	case y.typ == nil:
-		return true // x âŠ† âŠ¤ == true
+		return true // x âŠ† ğ“¤ == true
 	case x.typ == nil:
-		return false // âŠ¤ âŠ† y == false since y != âŠ¤
+		return false // ğ“¤ âŠ† y == false since y != ğ“¤
 	}
-	// âˆ… âŠ‚ x, y âŠ‚ âŠ¤
+	// âˆ… âŠ‚ x, y âŠ‚ ğ“¤
 
 	if x.disjoint(y) {
 		return false // x âŠ† y == false if x âˆ© y == âˆ…
diff --git a/src/go/types/typeterm_test.go b/src/go/types/typeterm_test.go
index 391ff3e05f..26a679dd09 100644
--- a/src/go/types/typeterm_test.go
+++ b/src/go/types/typeterm_test.go
@@ -11,7 +11,7 @@ import (
 
 var testTerms = map[string]*term{
 	"âˆ…":       nil,
-	"âŠ¤":       {},
+	"ğ“¤":       {},
 	"int":     {false, Typ[Int]},
 	"~int":    {true, Typ[Int]},
 	"string":  {false, Typ[String]},
@@ -46,14 +46,14 @@ func testTerm(name string) *term {
 func TestTermEqual(t *testing.T) {
 	for _, test := range []string{
 		"âˆ… âˆ… T",
-		"âŠ¤ âŠ¤ T",
+		"ğ“¤ ğ“¤ T",
 		"int int T",
 		"~int ~int T",
-		"âˆ… âŠ¤ F",
+		"âˆ… ğ“¤ F",
 		"âˆ… int F",
 		"âˆ… ~int F",
-		"âŠ¤ int F",
-		"âŠ¤ ~int F",
+		"ğ“¤ int F",
+		"ğ“¤ ~int F",
 		"int ~int F",
 	} {
 		args := split(test, 3)
@@ -74,12 +74,12 @@ func TestTermEqual(t *testing.T) {
 func TestTermUnion(t *testing.T) {
 	for _, test := range []string{
 		"âˆ… âˆ… âˆ… âˆ…",
-		"âˆ… âŠ¤ âŠ¤ âˆ…",
+		"âˆ… ğ“¤ ğ“¤ âˆ…",
 		"âˆ… int int âˆ…",
 		"âˆ… ~int ~int âˆ…",
-		"âŠ¤ âŠ¤ âŠ¤ âˆ…",
-		"âŠ¤ int âŠ¤ âˆ…",
-		"âŠ¤ ~int âŠ¤ âˆ…",
+		"ğ“¤ ğ“¤ ğ“¤ âˆ…",
+		"ğ“¤ int ğ“¤ âˆ…",
+		"ğ“¤ ~int ğ“¤ âˆ…",
 		"int int int âˆ…",
 		"int ~int ~int âˆ…",
 		"int string int string",
@@ -87,11 +87,11 @@ func TestTermUnion(t *testing.T) {
 		"~int ~string ~int ~string",
 
 		// union is symmetric, but the result order isn't - repeat symmetric cases explictly
-		"âŠ¤ âˆ… âŠ¤ âˆ…",
+		"ğ“¤ âˆ… ğ“¤ âˆ…",
 		"int âˆ… int âˆ…",
 		"~int âˆ… ~int âˆ…",
-		"int âŠ¤ âŠ¤ âˆ…",
-		"~int âŠ¤ âŠ¤ âˆ…",
+		"int ğ“¤ ğ“¤ âˆ…",
+		"~int ğ“¤ ğ“¤ âˆ…",
 		"~int int ~int âˆ…",
 		"string int string int",
 		"~string int ~string int",
@@ -111,12 +111,12 @@ func TestTermUnion(t *testing.T) {
 func TestTermIntersection(t *testing.T) {
 	for _, test := range []string{
 		"âˆ… âˆ… âˆ…",
-		"âˆ… âŠ¤ âˆ…",
+		"âˆ… ğ“¤ âˆ…",
 		"âˆ… int âˆ…",
 		"âˆ… ~int âˆ…",
-		"âŠ¤ âŠ¤ âŠ¤",
-		"âŠ¤ int int",
-		"âŠ¤ ~int ~int",
+		"ğ“¤ ğ“¤ ğ“¤",
+		"ğ“¤ int int",
+		"ğ“¤ ~int ~int",
 		"int int int",
 		"int ~int int",
 		"int string âˆ…",
@@ -141,7 +141,7 @@ func TestTermIntersection(t *testing.T) {
 func TestTermIncludes(t *testing.T) {
 	for _, test := range []string{
 		"âˆ… int F",
-		"âŠ¤ int T",
+		"ğ“¤ int T",
 		"int int T",
 		"~int int T",
 		"string int F",
@@ -160,14 +160,14 @@ func TestTermIncludes(t *testing.T) {
 func TestTermSubsetOf(t *testing.T) {
 	for _, test := range []string{
 		"âˆ… âˆ… T",
-		"âŠ¤ âŠ¤ T",
+		"ğ“¤ ğ“¤ T",
 		"int int T",
 		"~int ~int T",
-		"âˆ… âŠ¤ T",
+		"âˆ… ğ“¤ T",
 		"âˆ… int T",
 		"âˆ… ~int T",
-		"âŠ¤ int F",
-		"âŠ¤ ~int F",
+		"ğ“¤ int F",
+		"ğ“¤ ~int F",
 		"int ~int T",
 	} {
 		args := split(test, 3)
diff --git a/src/go/types/universe.go b/src/go/types/universe.go
index b8bf0a0db1..a2acfb5f69 100644
--- a/src/go/types/universe.go
+++ b/src/go/types/universe.go
@@ -100,7 +100,7 @@ func defPredeclaredTypes() {
 	{
 		obj := NewTypeName(token.NoPos, nil, "comparable", nil)
 		obj.setColor(black)
-		ityp := &Interface{obj, nil, nil, nil, true, &_TypeSet{true, nil, topTermlist}}
+		ityp := &Interface{obj, nil, nil, nil, true, &_TypeSet{true, nil, allTermlist}}
 		NewNamed(obj, ityp, nil)
 		def(obj)
 	}
