commit 27e3778793c4ae4e54d27185f6955bc5c180151b
Author: Cherry Zhang <cherryyz@google.com>
Date:   Sun Aug 2 19:36:28 2020 -0400

    [dev.link] cmd: remove "2", another round
    
    Rename the goobj2 package to goobj.
    
    Change-Id: Iff97b5575cbac45ac44de96b6bd9d555b9a4a12a
    Reviewed-on: https://go-review.googlesource.com/c/go/+/246444
    Run-TryBot: Cherry Zhang <cherryyz@google.com>
    TryBot-Result: Gobot Gobot <gobot@golang.org>
    Reviewed-by: Austin Clements <austin@google.com>
---
 src/cmd/compile/internal/gc/iexport.go             |   4 +-
 src/cmd/compile/internal/gc/iimport.go             |   4 +-
 src/cmd/compile/internal/gc/main.go                |   4 +-
 src/cmd/dist/buildtool.go                          |   2 +-
 src/cmd/internal/archive/read.go                   |   4 +-
 src/cmd/internal/{goobj2 => goobj}/builtin.go      |   2 +-
 src/cmd/internal/{goobj2 => goobj}/builtinlist.go  |   2 +-
 src/cmd/internal/{goobj2 => goobj}/funcinfo.go     |   2 +-
 src/cmd/internal/{goobj2 => goobj}/mkbuiltin.go    |   2 +-
 src/cmd/internal/{goobj2 => goobj}/objfile.go      |   2 +-
 src/cmd/internal/{goobj2 => goobj}/objfile_test.go |   2 +-
 src/cmd/internal/obj/line.go                       |   6 +-
 src/cmd/internal/obj/link.go                       |  10 +-
 src/cmd/internal/obj/objfile2.go                   | 152 ++++++++++-----------
 src/cmd/internal/obj/objfile_test.go               |   6 +-
 src/cmd/internal/obj/pcln.go                       |   6 +-
 src/cmd/internal/obj/sym.go                        |  18 +--
 src/cmd/internal/objfile/goobj.go                  |  34 ++---
 src/cmd/link/internal/ld/deadcode.go               |   4 +-
 src/cmd/link/internal/ld/ld.go                     |   6 +-
 src/cmd/link/internal/ld/lib.go                    |   6 +-
 src/cmd/link/internal/ld/main.go                   |   4 +-
 src/cmd/link/internal/ld/pcln.go                   |   4 +-
 src/cmd/link/internal/loader/loader.go             | 132 +++++++++---------
 src/cmd/link/internal/loader/loader_test.go        |   6 +-
 src/cmd/link/internal/loader/symbolbuilder.go      |   8 +-
 src/cmd/link/internal/sym/library.go               |   6 +-
 27 files changed, 219 insertions(+), 219 deletions(-)

diff --git a/src/cmd/compile/internal/gc/iexport.go b/src/cmd/compile/internal/gc/iexport.go
index 7a7dbdeac1..b3f50b63af 100644
--- a/src/cmd/compile/internal/gc/iexport.go
+++ b/src/cmd/compile/internal/gc/iexport.go
@@ -205,7 +205,7 @@ import (
 	"bufio"
 	"bytes"
 	"cmd/compile/internal/types"
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"cmd/internal/src"
 	"crypto/md5"
 	"encoding/binary"
@@ -1004,7 +1004,7 @@ func (w *exportWriter) linkname(s *types.Sym) {
 
 func (w *exportWriter) symIdx(s *types.Sym) {
 	lsym := s.Linksym()
-	if lsym.PkgIdx > goobj2.PkgIdxSelf || (lsym.PkgIdx == goobj2.PkgIdxInvalid && !lsym.Indexed()) || s.Linkname != "" {
+	if lsym.PkgIdx > goobj.PkgIdxSelf || (lsym.PkgIdx == goobj.PkgIdxInvalid && !lsym.Indexed()) || s.Linkname != "" {
 		// Don't export index for non-package symbols, linkname'd symbols,
 		// and symbols without an index. They can only be referenced by
 		// name.
diff --git a/src/cmd/compile/internal/gc/iimport.go b/src/cmd/compile/internal/gc/iimport.go
index 29bb1e57a4..0eeb047c06 100644
--- a/src/cmd/compile/internal/gc/iimport.go
+++ b/src/cmd/compile/internal/gc/iimport.go
@@ -10,7 +10,7 @@ package gc
 import (
 	"cmd/compile/internal/types"
 	"cmd/internal/bio"
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"cmd/internal/obj"
 	"cmd/internal/src"
 	"encoding/binary"
@@ -97,7 +97,7 @@ func (r *intReader) uint64() uint64 {
 	return i
 }
 
-func iimport(pkg *types.Pkg, in *bio.Reader) (fingerprint goobj2.FingerprintType) {
+func iimport(pkg *types.Pkg, in *bio.Reader) (fingerprint goobj.FingerprintType) {
 	ir := &intReader{in, pkg}
 
 	version := ir.uint64()
diff --git a/src/cmd/compile/internal/gc/main.go b/src/cmd/compile/internal/gc/main.go
index 4417e70616..eedfc4bb25 100644
--- a/src/cmd/compile/internal/gc/main.go
+++ b/src/cmd/compile/internal/gc/main.go
@@ -14,7 +14,7 @@ import (
 	"cmd/compile/internal/types"
 	"cmd/internal/bio"
 	"cmd/internal/dwarf"
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"cmd/internal/obj"
 	"cmd/internal/objabi"
 	"cmd/internal/src"
@@ -1280,7 +1280,7 @@ func importfile(f *Val) *types.Pkg {
 		c, _ = imp.ReadByte()
 	}
 
-	var fingerprint goobj2.FingerprintType
+	var fingerprint goobj.FingerprintType
 	switch c {
 	case '\n':
 		yyerror("cannot import %s: old export format no longer supported (recompile library)", path_)
diff --git a/src/cmd/dist/buildtool.go b/src/cmd/dist/buildtool.go
index 9502dac4eb..40d28b535b 100644
--- a/src/cmd/dist/buildtool.go
+++ b/src/cmd/dist/buildtool.go
@@ -56,7 +56,7 @@ var bootstrapDirs = []string{
 	"cmd/internal/gcprog",
 	"cmd/internal/dwarf",
 	"cmd/internal/edit",
-	"cmd/internal/goobj2",
+	"cmd/internal/goobj",
 	"cmd/internal/objabi",
 	"cmd/internal/obj",
 	"cmd/internal/obj/arm",
diff --git a/src/cmd/internal/archive/read.go b/src/cmd/internal/archive/read.go
index 6875dbce75..e67f06d69b 100644
--- a/src/cmd/internal/archive/read.go
+++ b/src/cmd/internal/archive/read.go
@@ -10,7 +10,7 @@ import (
 	"bufio"
 	"bytes"
 	"cmd/internal/bio"
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"errors"
 	"fmt"
 	"io"
@@ -318,7 +318,7 @@ func (r *objReader) parseObject(o *GoObj, size int64) error {
 	if err != nil {
 		return err
 	}
-	if !bytes.Equal(p, []byte(goobj2.Magic)) {
+	if !bytes.Equal(p, []byte(goobj.Magic)) {
 		return r.error(errCorruptObject)
 	}
 	r.skip(o.Size)
diff --git a/src/cmd/internal/goobj2/builtin.go b/src/cmd/internal/goobj/builtin.go
similarity index 98%
rename from src/cmd/internal/goobj2/builtin.go
rename to src/cmd/internal/goobj/builtin.go
index 65f9dd5d95..e7d612aeb7 100644
--- a/src/cmd/internal/goobj2/builtin.go
+++ b/src/cmd/internal/goobj/builtin.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package goobj2
+package goobj
 
 // Builtin (compiler-generated) function references appear
 // frequently. We assign special indices for them, so they
diff --git a/src/cmd/internal/goobj2/builtinlist.go b/src/cmd/internal/goobj/builtinlist.go
similarity index 99%
rename from src/cmd/internal/goobj2/builtinlist.go
rename to src/cmd/internal/goobj/builtinlist.go
index 171f57f15f..0cca752332 100644
--- a/src/cmd/internal/goobj2/builtinlist.go
+++ b/src/cmd/internal/goobj/builtinlist.go
@@ -1,6 +1,6 @@
 // Code generated by mkbuiltin.go. DO NOT EDIT.
 
-package goobj2
+package goobj
 
 var builtins = [...]struct {
 	name string
diff --git a/src/cmd/internal/goobj2/funcinfo.go b/src/cmd/internal/goobj/funcinfo.go
similarity index 99%
rename from src/cmd/internal/goobj2/funcinfo.go
rename to src/cmd/internal/goobj/funcinfo.go
index 9d2522d3c2..e0e6068b4b 100644
--- a/src/cmd/internal/goobj2/funcinfo.go
+++ b/src/cmd/internal/goobj/funcinfo.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package goobj2
+package goobj
 
 import (
 	"bytes"
diff --git a/src/cmd/internal/goobj2/mkbuiltin.go b/src/cmd/internal/goobj/mkbuiltin.go
similarity index 99%
rename from src/cmd/internal/goobj2/mkbuiltin.go
rename to src/cmd/internal/goobj/mkbuiltin.go
index 4838fa2a67..07c3406681 100644
--- a/src/cmd/internal/goobj2/mkbuiltin.go
+++ b/src/cmd/internal/goobj/mkbuiltin.go
@@ -32,7 +32,7 @@ func main() {
 	var b bytes.Buffer
 	fmt.Fprintln(&b, "// Code generated by mkbuiltin.go. DO NOT EDIT.")
 	fmt.Fprintln(&b)
-	fmt.Fprintln(&b, "package goobj2")
+	fmt.Fprintln(&b, "package goobj")
 
 	mkbuiltin(&b)
 
diff --git a/src/cmd/internal/goobj2/objfile.go b/src/cmd/internal/goobj/objfile.go
similarity index 99%
rename from src/cmd/internal/goobj2/objfile.go
rename to src/cmd/internal/goobj/objfile.go
index 49f45a7736..5d4a253024 100644
--- a/src/cmd/internal/goobj2/objfile.go
+++ b/src/cmd/internal/goobj/objfile.go
@@ -4,7 +4,7 @@
 
 // Go new object file format, reading and writing.
 
-package goobj2 // TODO: replace the goobj package?
+package goobj
 
 import (
 	"bytes"
diff --git a/src/cmd/internal/goobj2/objfile_test.go b/src/cmd/internal/goobj/objfile_test.go
similarity index 99%
rename from src/cmd/internal/goobj2/objfile_test.go
rename to src/cmd/internal/goobj/objfile_test.go
index 9fd121f9e6..c6fd427c15 100644
--- a/src/cmd/internal/goobj2/objfile_test.go
+++ b/src/cmd/internal/goobj/objfile_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package goobj2
+package goobj
 
 import (
 	"bufio"
diff --git a/src/cmd/internal/obj/line.go b/src/cmd/internal/obj/line.go
index 54b9c4748c..87cd32ba7e 100644
--- a/src/cmd/internal/obj/line.go
+++ b/src/cmd/internal/obj/line.go
@@ -5,13 +5,13 @@
 package obj
 
 import (
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"cmd/internal/src"
 )
 
 // AddImport adds a package to the list of imported packages.
-func (ctxt *Link) AddImport(pkg string, fingerprint goobj2.FingerprintType) {
-	ctxt.Imports = append(ctxt.Imports, goobj2.ImportedPkg{Pkg: pkg, Fingerprint: fingerprint})
+func (ctxt *Link) AddImport(pkg string, fingerprint goobj.FingerprintType) {
+	ctxt.Imports = append(ctxt.Imports, goobj.ImportedPkg{Pkg: pkg, Fingerprint: fingerprint})
 }
 
 func linkgetlineFromPos(ctxt *Link, xpos src.XPos) (f string, l int32) {
diff --git a/src/cmd/internal/obj/link.go b/src/cmd/internal/obj/link.go
index 62943a7cb3..dc47e51be9 100644
--- a/src/cmd/internal/obj/link.go
+++ b/src/cmd/internal/obj/link.go
@@ -33,7 +33,7 @@ package obj
 import (
 	"bufio"
 	"cmd/internal/dwarf"
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"cmd/internal/objabi"
 	"cmd/internal/src"
 	"cmd/internal/sys"
@@ -631,8 +631,8 @@ type Pcln struct {
 	Pcdata      []Pcdata
 	Funcdata    []*LSym
 	Funcdataoff []int64
-	UsedFiles   map[goobj2.CUFileIndex]struct{} // file indices used while generating pcfile
-	InlTree     InlTree                         // per-function inlining tree extracted from the global tree
+	UsedFiles   map[goobj.CUFileIndex]struct{} // file indices used while generating pcfile
+	InlTree     InlTree                        // per-function inlining tree extracted from the global tree
 }
 
 type Reloc struct {
@@ -678,7 +678,7 @@ type Link struct {
 	PosTable           src.PosTable
 	InlTree            InlTree // global inlining tree used by gc/inl.go
 	DwFixups           *DwarfFixupTable
-	Imports            []goobj2.ImportedPkg
+	Imports            []goobj.ImportedPkg
 	DiagFunc           func(string, ...interface{})
 	DiagFlush          func()
 	DebugInfo          func(fn *LSym, info *LSym, curfn interface{}) ([]dwarf.Scope, dwarf.InlCalls) // if non-nil, curfn is a *gc.Node
@@ -720,7 +720,7 @@ type Link struct {
 	nonpkgdefs   []*LSym // list of defined non-package symbols
 	nonpkgrefs   []*LSym // list of referenced non-package symbols
 
-	Fingerprint goobj2.FingerprintType // fingerprint of symbol indices, to catch index mismatch
+	Fingerprint goobj.FingerprintType // fingerprint of symbol indices, to catch index mismatch
 }
 
 func (ctxt *Link) Diag(format string, args ...interface{}) {
diff --git a/src/cmd/internal/obj/objfile2.go b/src/cmd/internal/obj/objfile2.go
index ae1a3646b1..f9720f0e57 100644
--- a/src/cmd/internal/obj/objfile2.go
+++ b/src/cmd/internal/obj/objfile2.go
@@ -9,7 +9,7 @@ package obj
 import (
 	"bytes"
 	"cmd/internal/bio"
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"cmd/internal/objabi"
 	"crypto/sha1"
 	"encoding/binary"
@@ -28,7 +28,7 @@ func WriteObjFile(ctxt *Link, b *bio.Writer) {
 	genFuncInfoSyms(ctxt)
 
 	w := writer{
-		Writer:  goobj2.NewWriter(b),
+		Writer:  goobj.NewWriter(b),
 		ctxt:    ctxt,
 		pkgpath: objabi.PathToPrefix(ctxt.Pkgpath),
 	}
@@ -40,16 +40,16 @@ func WriteObjFile(ctxt *Link, b *bio.Writer) {
 	// We just reserve the space. We'll fill in the offsets later.
 	flags := uint32(0)
 	if ctxt.Flag_shared {
-		flags |= goobj2.ObjFlagShared
+		flags |= goobj.ObjFlagShared
 	}
 	if w.pkgpath == "" {
-		flags |= goobj2.ObjFlagNeedNameExpansion
+		flags |= goobj.ObjFlagNeedNameExpansion
 	}
 	if ctxt.IsAsm {
-		flags |= goobj2.ObjFlagFromAssembly
+		flags |= goobj.ObjFlagFromAssembly
 	}
-	h := goobj2.Header{
-		Magic:       goobj2.Magic,
+	h := goobj.Header{
+		Magic:       goobj.Magic,
 		Fingerprint: ctxt.Fingerprint,
 		Flags:       flags,
 	}
@@ -59,70 +59,70 @@ func WriteObjFile(ctxt *Link, b *bio.Writer) {
 	w.StringTable()
 
 	// Autolib
-	h.Offsets[goobj2.BlkAutolib] = w.Offset()
+	h.Offsets[goobj.BlkAutolib] = w.Offset()
 	for i := range ctxt.Imports {
 		ctxt.Imports[i].Write(w.Writer)
 	}
 
 	// Package references
-	h.Offsets[goobj2.BlkPkgIdx] = w.Offset()
+	h.Offsets[goobj.BlkPkgIdx] = w.Offset()
 	for _, pkg := range w.pkglist {
 		w.StringRef(pkg)
 	}
 
 	// File table (for DWARF and pcln generation).
-	h.Offsets[goobj2.BlkFile] = w.Offset()
+	h.Offsets[goobj.BlkFile] = w.Offset()
 	for _, f := range ctxt.PosTable.FileTable() {
 		w.StringRef(filepath.ToSlash(f))
 	}
 
 	// Symbol definitions
-	h.Offsets[goobj2.BlkSymdef] = w.Offset()
+	h.Offsets[goobj.BlkSymdef] = w.Offset()
 	for _, s := range ctxt.defs {
 		w.Sym(s)
 	}
 
 	// Short hashed symbol definitions
-	h.Offsets[goobj2.BlkHashed64def] = w.Offset()
+	h.Offsets[goobj.BlkHashed64def] = w.Offset()
 	for _, s := range ctxt.hashed64defs {
 		w.Sym(s)
 	}
 
 	// Hashed symbol definitions
-	h.Offsets[goobj2.BlkHasheddef] = w.Offset()
+	h.Offsets[goobj.BlkHasheddef] = w.Offset()
 	for _, s := range ctxt.hasheddefs {
 		w.Sym(s)
 	}
 
 	// Non-pkg symbol definitions
-	h.Offsets[goobj2.BlkNonpkgdef] = w.Offset()
+	h.Offsets[goobj.BlkNonpkgdef] = w.Offset()
 	for _, s := range ctxt.nonpkgdefs {
 		w.Sym(s)
 	}
 
 	// Non-pkg symbol references
-	h.Offsets[goobj2.BlkNonpkgref] = w.Offset()
+	h.Offsets[goobj.BlkNonpkgref] = w.Offset()
 	for _, s := range ctxt.nonpkgrefs {
 		w.Sym(s)
 	}
 
 	// Referenced package symbol flags
-	h.Offsets[goobj2.BlkRefFlags] = w.Offset()
+	h.Offsets[goobj.BlkRefFlags] = w.Offset()
 	w.refFlags()
 
 	// Hashes
-	h.Offsets[goobj2.BlkHash64] = w.Offset()
+	h.Offsets[goobj.BlkHash64] = w.Offset()
 	for _, s := range ctxt.hashed64defs {
 		w.Hash64(s)
 	}
-	h.Offsets[goobj2.BlkHash] = w.Offset()
+	h.Offsets[goobj.BlkHash] = w.Offset()
 	for _, s := range ctxt.hasheddefs {
 		w.Hash(s)
 	}
 	// TODO: hashedrefs unused/unsupported for now
 
 	// Reloc indexes
-	h.Offsets[goobj2.BlkRelocIdx] = w.Offset()
+	h.Offsets[goobj.BlkRelocIdx] = w.Offset()
 	nreloc := uint32(0)
 	lists := [][]*LSym{ctxt.defs, ctxt.hashed64defs, ctxt.hasheddefs, ctxt.nonpkgdefs}
 	for _, list := range lists {
@@ -134,7 +134,7 @@ func WriteObjFile(ctxt *Link, b *bio.Writer) {
 	w.Uint32(nreloc)
 
 	// Symbol Info indexes
-	h.Offsets[goobj2.BlkAuxIdx] = w.Offset()
+	h.Offsets[goobj.BlkAuxIdx] = w.Offset()
 	naux := uint32(0)
 	for _, list := range lists {
 		for _, s := range list {
@@ -145,7 +145,7 @@ func WriteObjFile(ctxt *Link, b *bio.Writer) {
 	w.Uint32(naux)
 
 	// Data indexes
-	h.Offsets[goobj2.BlkDataIdx] = w.Offset()
+	h.Offsets[goobj.BlkDataIdx] = w.Offset()
 	dataOff := uint32(0)
 	for _, list := range lists {
 		for _, s := range list {
@@ -156,7 +156,7 @@ func WriteObjFile(ctxt *Link, b *bio.Writer) {
 	w.Uint32(dataOff)
 
 	// Relocs
-	h.Offsets[goobj2.BlkReloc] = w.Offset()
+	h.Offsets[goobj.BlkReloc] = w.Offset()
 	for _, list := range lists {
 		for _, s := range list {
 			for i := range s.R {
@@ -166,7 +166,7 @@ func WriteObjFile(ctxt *Link, b *bio.Writer) {
 	}
 
 	// Aux symbol info
-	h.Offsets[goobj2.BlkAux] = w.Offset()
+	h.Offsets[goobj.BlkAux] = w.Offset()
 	for _, list := range lists {
 		for _, s := range list {
 			w.Aux(s)
@@ -174,7 +174,7 @@ func WriteObjFile(ctxt *Link, b *bio.Writer) {
 	}
 
 	// Data
-	h.Offsets[goobj2.BlkData] = w.Offset()
+	h.Offsets[goobj.BlkData] = w.Offset()
 	for _, list := range lists {
 		for _, s := range list {
 			w.Bytes(s.P)
@@ -182,7 +182,7 @@ func WriteObjFile(ctxt *Link, b *bio.Writer) {
 	}
 
 	// Pcdata
-	h.Offsets[goobj2.BlkPcdata] = w.Offset()
+	h.Offsets[goobj.BlkPcdata] = w.Offset()
 	for _, s := range ctxt.Text { // iteration order must match genFuncInfoSyms
 		if s.Func != nil {
 			pc := &s.Func.Pcln
@@ -199,10 +199,10 @@ func WriteObjFile(ctxt *Link, b *bio.Writer) {
 	// Blocks used only by tools (objdump, nm).
 
 	// Referenced symbol names from other packages
-	h.Offsets[goobj2.BlkRefName] = w.Offset()
+	h.Offsets[goobj.BlkRefName] = w.Offset()
 	w.refNames()
 
-	h.Offsets[goobj2.BlkEnd] = w.Offset()
+	h.Offsets[goobj.BlkEnd] = w.Offset()
 
 	// Fix up block offsets in the header
 	end := start + int64(w.Offset())
@@ -212,7 +212,7 @@ func WriteObjFile(ctxt *Link, b *bio.Writer) {
 }
 
 type writer struct {
-	*goobj2.Writer
+	*goobj.Writer
 	ctxt    *Link
 	pkgpath string   // the package import path (escaped), "" if unknown
 	pkglist []string // list of packages referenced, indexed by ctxt.pkgIdx
@@ -244,7 +244,7 @@ func (w *writer) StringTable() {
 		}
 		// Don't put names of builtins into the string table (to save
 		// space).
-		if s.PkgIdx == goobj2.PkgIdxBuiltin {
+		if s.PkgIdx == goobj.PkgIdxBuiltin {
 			return
 		}
 		w.AddString(s.Name)
@@ -259,39 +259,39 @@ func (w *writer) StringTable() {
 func (w *writer) Sym(s *LSym) {
 	abi := uint16(s.ABI())
 	if s.Static() {
-		abi = goobj2.SymABIstatic
+		abi = goobj.SymABIstatic
 	}
 	flag := uint8(0)
 	if s.DuplicateOK() {
-		flag |= goobj2.SymFlagDupok
+		flag |= goobj.SymFlagDupok
 	}
 	if s.Local() {
-		flag |= goobj2.SymFlagLocal
+		flag |= goobj.SymFlagLocal
 	}
 	if s.MakeTypelink() {
-		flag |= goobj2.SymFlagTypelink
+		flag |= goobj.SymFlagTypelink
 	}
 	if s.Leaf() {
-		flag |= goobj2.SymFlagLeaf
+		flag |= goobj.SymFlagLeaf
 	}
 	if s.NoSplit() {
-		flag |= goobj2.SymFlagNoSplit
+		flag |= goobj.SymFlagNoSplit
 	}
 	if s.ReflectMethod() {
-		flag |= goobj2.SymFlagReflectMethod
+		flag |= goobj.SymFlagReflectMethod
 	}
 	if s.TopFrame() {
-		flag |= goobj2.SymFlagTopFrame
+		flag |= goobj.SymFlagTopFrame
 	}
 	if strings.HasPrefix(s.Name, "type.") && s.Name[5] != '.' && s.Type == objabi.SRODATA {
-		flag |= goobj2.SymFlagGoType
+		flag |= goobj.SymFlagGoType
 	}
 	flag2 := uint8(0)
 	if s.UsedInIface() {
-		flag2 |= goobj2.SymFlagUsedInIface
+		flag2 |= goobj.SymFlagUsedInIface
 	}
 	if strings.HasPrefix(s.Name, "go.itab.") && s.Type == objabi.SRODATA {
-		flag2 |= goobj2.SymFlagItab
+		flag2 |= goobj.SymFlagItab
 	}
 	name := s.Name
 	if strings.HasPrefix(name, "gofile..") {
@@ -320,7 +320,7 @@ func (w *writer) Sym(s *LSym) {
 			// don't bother setting align to 1.
 		}
 	}
-	var o goobj2.Sym
+	var o goobj.Sym
 	o.SetName(name, w.Writer)
 	o.SetABI(abi)
 	o.SetType(uint8(s.Type))
@@ -347,8 +347,8 @@ func (w *writer) Hash(s *LSym) {
 	w.Bytes(b[:])
 }
 
-func contentHash64(s *LSym) goobj2.Hash64Type {
-	var b goobj2.Hash64Type
+func contentHash64(s *LSym) goobj.Hash64Type {
+	var b goobj.Hash64Type
 	copy(b[:], s.P)
 	return b
 }
@@ -369,7 +369,7 @@ func contentHash64(s *LSym) goobj2.Hash64Type {
 //
 // For now, we assume there is no circular dependencies among
 // hashed symbols.
-func (w *writer) contentHash(s *LSym) goobj2.HashType {
+func (w *writer) contentHash(s *LSym) goobj.HashType {
 	h := sha1.New()
 	// The compiler trims trailing zeros _sometimes_. We just do
 	// it always.
@@ -384,22 +384,22 @@ func (w *writer) contentHash(s *LSym) goobj2.HashType {
 		h.Write(tmp[:])
 		rs := r.Sym
 		switch rs.PkgIdx {
-		case goobj2.PkgIdxHashed64:
+		case goobj.PkgIdxHashed64:
 			h.Write([]byte{0})
 			t := contentHash64(rs)
 			h.Write(t[:])
-		case goobj2.PkgIdxHashed:
+		case goobj.PkgIdxHashed:
 			h.Write([]byte{1})
 			t := w.contentHash(rs)
 			h.Write(t[:])
-		case goobj2.PkgIdxNone:
+		case goobj.PkgIdxNone:
 			h.Write([]byte{2})
 			io.WriteString(h, rs.Name) // name is already expanded at this point
-		case goobj2.PkgIdxBuiltin:
+		case goobj.PkgIdxBuiltin:
 			h.Write([]byte{3})
 			binary.LittleEndian.PutUint32(tmp[:4], uint32(rs.SymIdx))
 			h.Write(tmp[:4])
-		case goobj2.PkgIdxSelf:
+		case goobj.PkgIdxSelf:
 			io.WriteString(h, w.pkgpath)
 			binary.LittleEndian.PutUint32(tmp[:4], uint32(rs.SymIdx))
 			h.Write(tmp[:4])
@@ -409,24 +409,24 @@ func (w *writer) contentHash(s *LSym) goobj2.HashType {
 			h.Write(tmp[:4])
 		}
 	}
-	var b goobj2.HashType
+	var b goobj.HashType
 	copy(b[:], h.Sum(nil))
 	return b
 }
 
-func makeSymRef(s *LSym) goobj2.SymRef {
+func makeSymRef(s *LSym) goobj.SymRef {
 	if s == nil {
-		return goobj2.SymRef{}
+		return goobj.SymRef{}
 	}
 	if s.PkgIdx == 0 || !s.Indexed() {
 		fmt.Printf("unindexed symbol reference: %v\n", s)
 		panic("unindexed symbol reference")
 	}
-	return goobj2.SymRef{PkgIdx: uint32(s.PkgIdx), SymIdx: uint32(s.SymIdx)}
+	return goobj.SymRef{PkgIdx: uint32(s.PkgIdx), SymIdx: uint32(s.SymIdx)}
 }
 
 func (w *writer) Reloc(r *Reloc) {
-	var o goobj2.Reloc
+	var o goobj.Reloc
 	o.SetOff(r.Off)
 	o.SetSiz(r.Siz)
 	o.SetType(uint8(r.Type))
@@ -436,7 +436,7 @@ func (w *writer) Reloc(r *Reloc) {
 }
 
 func (w *writer) aux1(typ uint8, rs *LSym) {
-	var o goobj2.Aux
+	var o goobj.Aux
 	o.SetType(typ)
 	o.SetSym(makeSymRef(rs))
 	o.Write(w.Writer)
@@ -444,26 +444,26 @@ func (w *writer) aux1(typ uint8, rs *LSym) {
 
 func (w *writer) Aux(s *LSym) {
 	if s.Gotype != nil {
-		w.aux1(goobj2.AuxGotype, s.Gotype)
+		w.aux1(goobj.AuxGotype, s.Gotype)
 	}
 	if s.Func != nil {
-		w.aux1(goobj2.AuxFuncInfo, s.Func.FuncInfoSym)
+		w.aux1(goobj.AuxFuncInfo, s.Func.FuncInfoSym)
 
 		for _, d := range s.Func.Pcln.Funcdata {
-			w.aux1(goobj2.AuxFuncdata, d)
+			w.aux1(goobj.AuxFuncdata, d)
 		}
 
 		if s.Func.dwarfInfoSym != nil && s.Func.dwarfInfoSym.Size != 0 {
-			w.aux1(goobj2.AuxDwarfInfo, s.Func.dwarfInfoSym)
+			w.aux1(goobj.AuxDwarfInfo, s.Func.dwarfInfoSym)
 		}
 		if s.Func.dwarfLocSym != nil && s.Func.dwarfLocSym.Size != 0 {
-			w.aux1(goobj2.AuxDwarfLoc, s.Func.dwarfLocSym)
+			w.aux1(goobj.AuxDwarfLoc, s.Func.dwarfLocSym)
 		}
 		if s.Func.dwarfRangesSym != nil && s.Func.dwarfRangesSym.Size != 0 {
-			w.aux1(goobj2.AuxDwarfRanges, s.Func.dwarfRangesSym)
+			w.aux1(goobj.AuxDwarfRanges, s.Func.dwarfRangesSym)
 		}
 		if s.Func.dwarfDebugLinesSym != nil && s.Func.dwarfDebugLinesSym.Size != 0 {
-			w.aux1(goobj2.AuxDwarfLines, s.Func.dwarfDebugLinesSym)
+			w.aux1(goobj.AuxDwarfLines, s.Func.dwarfDebugLinesSym)
 		}
 	}
 }
@@ -473,9 +473,9 @@ func (w *writer) refFlags() {
 	seen := make(map[*LSym]bool)
 	w.ctxt.traverseSyms(traverseRefs, func(rs *LSym) { // only traverse refs, not auxs, as tools don't need auxs
 		switch rs.PkgIdx {
-		case goobj2.PkgIdxNone, goobj2.PkgIdxHashed64, goobj2.PkgIdxHashed, goobj2.PkgIdxBuiltin, goobj2.PkgIdxSelf: // not an external indexed reference
+		case goobj.PkgIdxNone, goobj.PkgIdxHashed64, goobj.PkgIdxHashed, goobj.PkgIdxBuiltin, goobj.PkgIdxSelf: // not an external indexed reference
 			return
-		case goobj2.PkgIdxInvalid:
+		case goobj.PkgIdxInvalid:
 			panic("unindexed symbol reference")
 		}
 		if seen[rs] {
@@ -485,12 +485,12 @@ func (w *writer) refFlags() {
 		symref := makeSymRef(rs)
 		flag2 := uint8(0)
 		if rs.UsedInIface() {
-			flag2 |= goobj2.SymFlagUsedInIface
+			flag2 |= goobj.SymFlagUsedInIface
 		}
 		if flag2 == 0 {
 			return // no need to write zero flags
 		}
-		var o goobj2.RefFlags
+		var o goobj.RefFlags
 		o.SetSym(symref)
 		o.SetFlag2(flag2)
 		o.Write(w.Writer)
@@ -503,9 +503,9 @@ func (w *writer) refNames() {
 	seen := make(map[*LSym]bool)
 	w.ctxt.traverseSyms(traverseRefs, func(rs *LSym) { // only traverse refs, not auxs, as tools don't need auxs
 		switch rs.PkgIdx {
-		case goobj2.PkgIdxNone, goobj2.PkgIdxHashed64, goobj2.PkgIdxHashed, goobj2.PkgIdxBuiltin, goobj2.PkgIdxSelf: // not an external indexed reference
+		case goobj.PkgIdxNone, goobj.PkgIdxHashed64, goobj.PkgIdxHashed, goobj.PkgIdxBuiltin, goobj.PkgIdxSelf: // not an external indexed reference
 			return
-		case goobj2.PkgIdxInvalid:
+		case goobj.PkgIdxInvalid:
 			panic("unindexed symbol reference")
 		}
 		if seen[rs] {
@@ -513,7 +513,7 @@ func (w *writer) refNames() {
 		}
 		seen[rs] = true
 		symref := makeSymRef(rs)
-		var o goobj2.RefName
+		var o goobj.RefName
 		o.SetSym(symref)
 		o.SetName(rs.Name, w.Writer)
 		o.Write(w.Writer)
@@ -560,7 +560,7 @@ func genFuncInfoSyms(ctxt *Link) {
 		if s.Func == nil {
 			continue
 		}
-		o := goobj2.FuncInfo{
+		o := goobj.FuncInfo{
 			Args:   uint32(s.Func.Args),
 			Locals: uint32(s.Func.Locals),
 			FuncID: objabi.FuncID(s.Func.FuncID),
@@ -585,18 +585,18 @@ func genFuncInfoSyms(ctxt *Link) {
 			o.Funcdataoff[i] = uint32(x)
 		}
 		i := 0
-		o.File = make([]goobj2.CUFileIndex, len(pc.UsedFiles))
+		o.File = make([]goobj.CUFileIndex, len(pc.UsedFiles))
 		for f := range pc.UsedFiles {
 			o.File[i] = f
 			i++
 		}
 		sort.Slice(o.File, func(i, j int) bool { return o.File[i] < o.File[j] })
-		o.InlTree = make([]goobj2.InlTreeNode, len(pc.InlTree.nodes))
+		o.InlTree = make([]goobj.InlTreeNode, len(pc.InlTree.nodes))
 		for i, inl := range pc.InlTree.nodes {
 			f, l := getFileIndexAndLine(ctxt, inl.Pos)
-			o.InlTree[i] = goobj2.InlTreeNode{
+			o.InlTree[i] = goobj.InlTreeNode{
 				Parent:   int32(inl.Parent),
-				File:     goobj2.CUFileIndex(f),
+				File:     goobj.CUFileIndex(f),
 				Line:     l,
 				Func:     makeSymRef(inl.Func),
 				ParentPC: inl.ParentPC,
@@ -606,7 +606,7 @@ func genFuncInfoSyms(ctxt *Link) {
 		o.Write(&b)
 		isym := &LSym{
 			Type:   objabi.SDATA, // for now, I don't think it matters
-			PkgIdx: goobj2.PkgIdxSelf,
+			PkgIdx: goobj.PkgIdxSelf,
 			SymIdx: symidx,
 			P:      append([]byte(nil), b.Bytes()...),
 		}
@@ -621,7 +621,7 @@ func genFuncInfoSyms(ctxt *Link) {
 			if s == nil || s.Size == 0 {
 				continue
 			}
-			s.PkgIdx = goobj2.PkgIdxSelf
+			s.PkgIdx = goobj.PkgIdxSelf
 			s.SymIdx = symidx
 			s.Set(AttrIndexed, true)
 			symidx++
diff --git a/src/cmd/internal/obj/objfile_test.go b/src/cmd/internal/obj/objfile_test.go
index ed3be20760..155701fa4e 100644
--- a/src/cmd/internal/obj/objfile_test.go
+++ b/src/cmd/internal/obj/objfile_test.go
@@ -5,7 +5,7 @@
 package obj
 
 import (
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"cmd/internal/sys"
 	"testing"
 )
@@ -43,7 +43,7 @@ func TestContentHash(t *testing.T) {
 	}
 	for _, s := range syms {
 		s.Set(AttrContentAddressable, true)
-		s.PkgIdx = goobj2.PkgIdxHashed
+		s.PkgIdx = goobj.PkgIdxHashed
 	}
 	// s3 references s0
 	r := Addrel(syms[3])
@@ -59,7 +59,7 @@ func TestContentHash(t *testing.T) {
 	r.Sym = syms[2]
 
 	// compute hashes
-	h := make([]goobj2.HashType, len(syms))
+	h := make([]goobj.HashType, len(syms))
 	w := &writer{}
 	for i := range h {
 		h[i] = w.contentHash(syms[i])
diff --git a/src/cmd/internal/obj/pcln.go b/src/cmd/internal/obj/pcln.go
index b9d58e7ca3..1f7ccf47ef 100644
--- a/src/cmd/internal/obj/pcln.go
+++ b/src/cmd/internal/obj/pcln.go
@@ -5,7 +5,7 @@
 package obj
 
 import (
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"encoding/binary"
 	"log"
 )
@@ -136,7 +136,7 @@ func pctofileline(ctxt *Link, sym *LSym, oldval int32, p *Prog, phase int32, arg
 		return l
 	}
 	pcln := arg.(*Pcln)
-	pcln.UsedFiles[goobj2.CUFileIndex(f)] = struct{}{}
+	pcln.UsedFiles[goobj.CUFileIndex(f)] = struct{}{}
 	return int32(f)
 }
 
@@ -249,7 +249,7 @@ func pctopcdata(ctxt *Link, sym *LSym, oldval int32, p *Prog, phase int32, arg i
 
 func linkpcln(ctxt *Link, cursym *LSym) {
 	pcln := &cursym.Func.Pcln
-	pcln.UsedFiles = make(map[goobj2.CUFileIndex]struct{})
+	pcln.UsedFiles = make(map[goobj.CUFileIndex]struct{})
 
 	npcdata := 0
 	nfuncdata := 0
diff --git a/src/cmd/internal/obj/sym.go b/src/cmd/internal/obj/sym.go
index f62e1f5e58..cf78849cda 100644
--- a/src/cmd/internal/obj/sym.go
+++ b/src/cmd/internal/obj/sym.go
@@ -32,7 +32,7 @@
 package obj
 
 import (
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"cmd/internal/objabi"
 	"fmt"
 	"log"
@@ -206,7 +206,7 @@ func (ctxt *Link) NumberSyms() {
 		// may reference named symbols whose names are not fully expanded.
 		if s.ContentAddressable() && (ctxt.Pkgpath != "" || len(s.R) == 0) {
 			if len(s.P) <= 8 && len(s.R) == 0 { // we can use short hash only for symbols without relocations
-				s.PkgIdx = goobj2.PkgIdxHashed64
+				s.PkgIdx = goobj.PkgIdxHashed64
 				s.SymIdx = hashed64idx
 				if hashed64idx != int32(len(ctxt.hashed64defs)) {
 					panic("bad index")
@@ -214,7 +214,7 @@ func (ctxt *Link) NumberSyms() {
 				ctxt.hashed64defs = append(ctxt.hashed64defs, s)
 				hashed64idx++
 			} else {
-				s.PkgIdx = goobj2.PkgIdxHashed
+				s.PkgIdx = goobj.PkgIdxHashed
 				s.SymIdx = hashedidx
 				if hashedidx != int32(len(ctxt.hasheddefs)) {
 					panic("bad index")
@@ -223,7 +223,7 @@ func (ctxt *Link) NumberSyms() {
 				hashedidx++
 			}
 		} else if isNonPkgSym(ctxt, s) {
-			s.PkgIdx = goobj2.PkgIdxNone
+			s.PkgIdx = goobj.PkgIdxNone
 			s.SymIdx = nonpkgidx
 			if nonpkgidx != int32(len(ctxt.nonpkgdefs)) {
 				panic("bad index")
@@ -231,7 +231,7 @@ func (ctxt *Link) NumberSyms() {
 			ctxt.nonpkgdefs = append(ctxt.nonpkgdefs, s)
 			nonpkgidx++
 		} else {
-			s.PkgIdx = goobj2.PkgIdxSelf
+			s.PkgIdx = goobj.PkgIdxSelf
 			s.SymIdx = idx
 			if idx != int32(len(ctxt.defs)) {
 				panic("bad index")
@@ -245,15 +245,15 @@ func (ctxt *Link) NumberSyms() {
 	ipkg := int32(1) // 0 is invalid index
 	nonpkgdef := nonpkgidx
 	ctxt.traverseSyms(traverseRefs|traverseAux, func(rs *LSym) {
-		if rs.PkgIdx != goobj2.PkgIdxInvalid {
+		if rs.PkgIdx != goobj.PkgIdxInvalid {
 			return
 		}
 		if !ctxt.Flag_linkshared {
 			// Assign special index for builtin symbols.
 			// Don't do it when linking against shared libraries, as the runtime
 			// may be in a different library.
-			if i := goobj2.BuiltinIdx(rs.Name, int(rs.ABI())); i != -1 {
-				rs.PkgIdx = goobj2.PkgIdxBuiltin
+			if i := goobj.BuiltinIdx(rs.Name, int(rs.ABI())); i != -1 {
+				rs.PkgIdx = goobj.PkgIdxBuiltin
 				rs.SymIdx = int32(i)
 				rs.Set(AttrIndexed, true)
 				return
@@ -265,7 +265,7 @@ func (ctxt *Link) NumberSyms() {
 			panic("hashed refs unsupported for now")
 		}
 		if pkg == "" || pkg == "\"\"" || pkg == "_" || !rs.Indexed() {
-			rs.PkgIdx = goobj2.PkgIdxNone
+			rs.PkgIdx = goobj.PkgIdxNone
 			rs.SymIdx = nonpkgidx
 			rs.Set(AttrIndexed, true)
 			if nonpkgidx != nonpkgdef+int32(len(ctxt.nonpkgrefs)) {
diff --git a/src/cmd/internal/objfile/goobj.go b/src/cmd/internal/objfile/goobj.go
index 6bf9d3bf21..5708f5ee18 100644
--- a/src/cmd/internal/objfile/goobj.go
+++ b/src/cmd/internal/objfile/goobj.go
@@ -8,7 +8,7 @@ package objfile
 
 import (
 	"cmd/internal/archive"
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"debug/dwarf"
@@ -22,7 +22,7 @@ import (
 
 type goobjFile struct {
 	goobj *archive.GoObj
-	r     *goobj2.Reader
+	r     *goobj.Reader
 	f     *os.File
 }
 
@@ -44,7 +44,7 @@ L:
 			if err != nil {
 				return nil, err
 			}
-			r := goobj2.NewReaderFromBytes(b, false)
+			r := goobj.NewReaderFromBytes(b, false)
 			entries = append(entries, &Entry{
 				name: e.Name,
 				raw:  &goobjFile{e.Obj, r, f},
@@ -103,7 +103,7 @@ func (f *goobjFile) symbols() ([]Sym, error) {
 
 	// Name of referenced indexed symbols.
 	nrefName := r.NRefName()
-	refNames := make(map[goobj2.SymRef]string, nrefName)
+	refNames := make(map[goobj.SymRef]string, nrefName)
 	for i := 0; i < nrefName; i++ {
 		rn := r.RefName(i)
 		refNames[rn.Sym()] = rn.Name(r)
@@ -111,31 +111,31 @@ func (f *goobjFile) symbols() ([]Sym, error) {
 
 	abiToVer := func(abi uint16) int {
 		var ver int
-		if abi == goobj2.SymABIstatic {
+		if abi == goobj.SymABIstatic {
 			// Static symbol
 			ver = 1
 		}
 		return ver
 	}
 
-	resolveSymRef := func(s goobj2.SymRef) string {
+	resolveSymRef := func(s goobj.SymRef) string {
 		var i uint32
 		switch p := s.PkgIdx; p {
-		case goobj2.PkgIdxInvalid:
+		case goobj.PkgIdxInvalid:
 			if s.SymIdx != 0 {
 				panic("bad sym ref")
 			}
 			return ""
-		case goobj2.PkgIdxHashed64:
+		case goobj.PkgIdxHashed64:
 			i = s.SymIdx + uint32(r.NSym())
-		case goobj2.PkgIdxHashed:
+		case goobj.PkgIdxHashed:
 			i = s.SymIdx + uint32(r.NSym()+r.NHashed64def())
-		case goobj2.PkgIdxNone:
+		case goobj.PkgIdxNone:
 			i = s.SymIdx + uint32(r.NSym()+r.NHashed64def()+r.NHasheddef())
-		case goobj2.PkgIdxBuiltin:
-			name, abi := goobj2.BuiltinName(int(s.SymIdx))
+		case goobj.PkgIdxBuiltin:
+			name, abi := goobj.BuiltinName(int(s.SymIdx))
 			return goobjName(name, abi)
-		case goobj2.PkgIdxSelf:
+		case goobj.PkgIdxSelf:
 			i = s.SymIdx
 		default:
 			return refNames[s]
@@ -166,7 +166,7 @@ func (f *goobjFile) symbols() ([]Sym, error) {
 		case objabi.SBSS, objabi.SNOPTRBSS, objabi.STLSBSS:
 			code = 'B'
 		}
-		if ver >= goobj2.SymABIstatic {
+		if ver >= goobj.SymABIstatic {
 			code += 'a' - 'A'
 		}
 
@@ -248,10 +248,10 @@ func (f *goobjFile) PCToLine(pc uint64) (string, int, *gosym.Func) {
 		auxs := r.Auxs(i)
 		for j := range auxs {
 			a := &auxs[j]
-			if a.Type() != goobj2.AuxFuncInfo {
+			if a.Type() != goobj.AuxFuncInfo {
 				continue
 			}
-			if a.Sym().PkgIdx != goobj2.PkgIdxSelf {
+			if a.Sym().PkgIdx != goobj.PkgIdxSelf {
 				panic("funcinfo symbol not defined in current package")
 			}
 			isym = a.Sym().SymIdx
@@ -260,7 +260,7 @@ func (f *goobjFile) PCToLine(pc uint64) (string, int, *gosym.Func) {
 			continue
 		}
 		b := r.BytesAt(r.DataOff(isym), r.DataSize(isym))
-		var info *goobj2.FuncInfo
+		var info *goobj.FuncInfo
 		lengths := info.ReadFuncInfoLengths(b)
 		off, end := info.ReadPcline(b)
 		pcline := r.BytesAt(pcdataBase+off, int(end-off))
diff --git a/src/cmd/link/internal/ld/deadcode.go b/src/cmd/link/internal/ld/deadcode.go
index a169772dde..0269429723 100644
--- a/src/cmd/link/internal/ld/deadcode.go
+++ b/src/cmd/link/internal/ld/deadcode.go
@@ -5,7 +5,7 @@
 package ld
 
 import (
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"cmd/link/internal/loader"
@@ -161,7 +161,7 @@ func (d *deadcodePass) flood() {
 		naux := d.ldr.NAux(symIdx)
 		for i := 0; i < naux; i++ {
 			a := d.ldr.Aux(symIdx, i)
-			if a.Type() == goobj2.AuxGotype && !d.ctxt.linkShared {
+			if a.Type() == goobj.AuxGotype && !d.ctxt.linkShared {
 				// A symbol being reachable doesn't imply we need its
 				// type descriptor. Don't mark it.
 				// TODO: when -linkshared, the GCProg generation code
diff --git a/src/cmd/link/internal/ld/ld.go b/src/cmd/link/internal/ld/ld.go
index 71e1ccdd96..7ff9c41f96 100644
--- a/src/cmd/link/internal/ld/ld.go
+++ b/src/cmd/link/internal/ld/ld.go
@@ -32,7 +32,7 @@
 package ld
 
 import (
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"cmd/link/internal/loader"
 	"cmd/link/internal/sym"
 	"io/ioutil"
@@ -156,7 +156,7 @@ func findlib(ctxt *Link, lib string) (string, bool) {
 	return pname, isshlib
 }
 
-func addlib(ctxt *Link, src, obj, lib string, fingerprint goobj2.FingerprintType) *sym.Library {
+func addlib(ctxt *Link, src, obj, lib string, fingerprint goobj.FingerprintType) *sym.Library {
 	pkg := pkgname(ctxt, lib)
 
 	// already loaded?
@@ -192,7 +192,7 @@ func addlib(ctxt *Link, src, obj, lib string, fingerprint goobj2.FingerprintType
  *	fingerprint: if not 0, expected fingerprint for import from srcref
  *	             fingerprint is 0 if the library is not imported (e.g. main)
  */
-func addlibpath(ctxt *Link, srcref, objref, file, pkg, shlib string, fingerprint goobj2.FingerprintType) *sym.Library {
+func addlibpath(ctxt *Link, srcref, objref, file, pkg, shlib string, fingerprint goobj.FingerprintType) *sym.Library {
 	if l := ctxt.LibraryByPkg[pkg]; l != nil {
 		return l
 	}
diff --git a/src/cmd/link/internal/ld/lib.go b/src/cmd/link/internal/ld/lib.go
index 5271b8f348..09c7bbfb53 100644
--- a/src/cmd/link/internal/ld/lib.go
+++ b/src/cmd/link/internal/ld/lib.go
@@ -33,7 +33,7 @@ package ld
 import (
 	"bytes"
 	"cmd/internal/bio"
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"cmd/internal/obj"
 	"cmd/internal/objabi"
 	"cmd/internal/sys"
@@ -404,7 +404,7 @@ func errorexit() {
 }
 
 func loadinternal(ctxt *Link, name string) *sym.Library {
-	zerofp := goobj2.FingerprintType{}
+	zerofp := goobj.FingerprintType{}
 	if ctxt.linkShared && ctxt.PackageShlib != nil {
 		if shlib := ctxt.PackageShlib[name]; shlib != "" {
 			return addlibpath(ctxt, "internal", "internal", "", name, shlib, zerofp)
@@ -1899,7 +1899,7 @@ func ldobj(ctxt *Link, f *bio.Reader, lib *sym.Library, length int64, pn string,
 	return nil
 }
 
-func checkFingerprint(lib *sym.Library, libfp goobj2.FingerprintType, src string, srcfp goobj2.FingerprintType) {
+func checkFingerprint(lib *sym.Library, libfp goobj.FingerprintType, src string, srcfp goobj.FingerprintType) {
 	if libfp != srcfp {
 		Exitf("fingerprint mismatch: %s has %x, import from %s expecting %x", lib, libfp, src, srcfp)
 	}
diff --git a/src/cmd/link/internal/ld/main.go b/src/cmd/link/internal/ld/main.go
index 4885c4f57e..6f4ccbfb7a 100644
--- a/src/cmd/link/internal/ld/main.go
+++ b/src/cmd/link/internal/ld/main.go
@@ -32,7 +32,7 @@ package ld
 
 import (
 	"bufio"
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"cmd/link/internal/benchmark"
@@ -205,7 +205,7 @@ func Main(arch *sys.Arch, theArch Arch) {
 		ctxt.Logf("HEADER = -H%d -T0x%x -R0x%x\n", ctxt.HeadType, uint64(*FlagTextAddr), uint32(*FlagRound))
 	}
 
-	zerofp := goobj2.FingerprintType{}
+	zerofp := goobj.FingerprintType{}
 	switch ctxt.BuildMode {
 	case BuildModeShared:
 		for i := 0; i < flag.NArg(); i++ {
diff --git a/src/cmd/link/internal/ld/pcln.go b/src/cmd/link/internal/ld/pcln.go
index e5dfa837ba..30e0bdc839 100644
--- a/src/cmd/link/internal/ld/pcln.go
+++ b/src/cmd/link/internal/ld/pcln.go
@@ -5,7 +5,7 @@
 package ld
 
 import (
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"cmd/internal/obj"
 	"cmd/internal/objabi"
 	"cmd/internal/src"
@@ -157,7 +157,7 @@ func ftabaddstring(ftab *loader.SymbolBuilder, s string) int32 {
 // This funciton looks at a CU's file at index [i], and if it's a new filename,
 // stores that filename in the global file table, and adds it to the map lookup
 // for renumbering pcfile.
-func (state *oldPclnState) numberfile(cu *sym.CompilationUnit, i goobj2.CUFileIndex) int64 {
+func (state *oldPclnState) numberfile(cu *sym.CompilationUnit, i goobj.CUFileIndex) int64 {
 	file := cu.FileTable[i]
 	if val, ok := state.numberedFiles[file]; ok {
 		return val
diff --git a/src/cmd/link/internal/loader/loader.go b/src/cmd/link/internal/loader/loader.go
index 882799e123..8fd10b0848 100644
--- a/src/cmd/link/internal/loader/loader.go
+++ b/src/cmd/link/internal/loader/loader.go
@@ -7,7 +7,7 @@ package loader
 import (
 	"bytes"
 	"cmd/internal/bio"
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"cmd/internal/obj"
 	"cmd/internal/objabi"
 	"cmd/internal/sys"
@@ -30,7 +30,7 @@ type Sym int
 // Relocs encapsulates the set of relocations on a given symbol; an
 // instance of this type is returned by the Loader Relocs() method.
 type Relocs struct {
-	rs []goobj2.Reloc
+	rs []goobj.Reloc
 
 	li uint32   // local index of symbol whose relocs we're examining
 	r  *oReader // object reader for containing package
@@ -48,21 +48,21 @@ type ExtReloc struct {
 // Reloc holds a "handle" to access a relocation record from an
 // object file.
 type Reloc struct {
-	*goobj2.Reloc
+	*goobj.Reloc
 	r *oReader
 	l *Loader
 
 	// External reloc types may not fit into a uint8 which the Go object file uses.
-	// Store it here, instead of in the byte of goobj2.Reloc.
+	// Store it here, instead of in the byte of goobj.Reloc.
 	// For Go symbols this will always be zero.
-	// goobj2.Reloc.Type() + typ is always the right type, for both Go and external
+	// goobj.Reloc.Type() + typ is always the right type, for both Go and external
 	// symbols.
 	typ objabi.RelocType
 }
 
 func (rel Reloc) Type() objabi.RelocType { return objabi.RelocType(rel.Reloc.Type()) + rel.typ }
 func (rel Reloc) Sym() Sym               { return rel.l.resolve(rel.r, rel.Reloc.Sym()) }
-func (rel Reloc) SetSym(s Sym)           { rel.Reloc.SetSym(goobj2.SymRef{PkgIdx: 0, SymIdx: uint32(s)}) }
+func (rel Reloc) SetSym(s Sym)           { rel.Reloc.SetSym(goobj.SymRef{PkgIdx: 0, SymIdx: uint32(s)}) }
 
 func (rel Reloc) SetType(t objabi.RelocType) {
 	if t != objabi.RelocType(uint8(t)) {
@@ -78,7 +78,7 @@ func (rel Reloc) SetType(t objabi.RelocType) {
 // Aux holds a "handle" to access an aux symbol record from an
 // object file.
 type Aux struct {
-	*goobj2.Aux
+	*goobj.Aux
 	r *oReader
 	l *Loader
 }
@@ -88,15 +88,15 @@ func (a Aux) Sym() Sym { return a.l.resolve(a.r, a.Aux.Sym()) }
 // oReader is a wrapper type of obj.Reader, along with some
 // extra information.
 type oReader struct {
-	*goobj2.Reader
+	*goobj.Reader
 	unit         *sym.CompilationUnit
 	version      int    // version of static symbol
 	flags        uint32 // read from object file
 	pkgprefix    string
 	syms         []Sym  // Sym's global index, indexed by local index
-	ndef         int    // cache goobj2.Reader.NSym()
-	nhashed64def int    // cache goobj2.Reader.NHashed64Def()
-	nhasheddef   int    // cache goobj2.Reader.NHashedDef()
+	ndef         int    // cache goobj.Reader.NSym()
+	nhashed64def int    // cache goobj.Reader.NHashed64Def()
+	nhasheddef   int    // cache goobj.Reader.NHashedDef()
 	objidx       uint32 // index of this reader in the objs slice
 }
 
@@ -311,10 +311,10 @@ type extSymPayload struct {
 	ver      int
 	kind     sym.SymKind
 	objidx   uint32 // index of original object if sym made by cloneToExternal
-	relocs   []goobj2.Reloc
+	relocs   []goobj.Reloc
 	reltypes []objabi.RelocType // relocation types
 	data     []byte
-	auxs     []goobj2.Aux
+	auxs     []goobj.Aux
 }
 
 const (
@@ -323,7 +323,7 @@ const (
 )
 
 func NewLoader(flags uint32, elfsetstring elfsetstringFunc, reporter *ErrorReporter) *Loader {
-	nbuiltin := goobj2.NBuiltin()
+	nbuiltin := goobj.NBuiltin()
 	extReader := &oReader{objidx: extObj}
 	ldr := &Loader{
 		start:                make(map[*oReader]Sym),
@@ -383,7 +383,7 @@ func (l *Loader) addObj(pkg string, r *oReader) Sym {
 
 // Add a symbol from an object file, return the global index.
 // If the symbol already exist, it returns the index of that symbol.
-func (st *loadState) addSym(name string, ver int, r *oReader, li uint32, kind int, osym *goobj2.Sym) Sym {
+func (st *loadState) addSym(name string, ver int, r *oReader, li uint32, kind int, osym *goobj.Sym) Sym {
 	l := st.l
 	if l.extStart != 0 {
 		panic("addSym called after external symbol is created")
@@ -420,8 +420,8 @@ func (st *loadState) addSym(name string, ver int, r *oReader, li uint32, kind in
 		// check, as same hash indicates same content.
 		var checkHash func() (symAndSize, bool)
 		var addToHashMap func(symAndSize)
-		var h64 uint64         // only used for hashed64Def
-		var h *goobj2.HashType // only used for hashedDef
+		var h64 uint64        // only used for hashed64Def
+		var h *goobj.HashType // only used for hashedDef
 		if kind == hashed64Def {
 			checkHash = func() (symAndSize, bool) {
 				h64 = r.Hash64(li - uint32(r.ndef))
@@ -607,10 +607,10 @@ func (l *Loader) toLocal(i Sym) (*oReader, uint32) {
 }
 
 // Resolve a local symbol reference. Return global index.
-func (l *Loader) resolve(r *oReader, s goobj2.SymRef) Sym {
+func (l *Loader) resolve(r *oReader, s goobj.SymRef) Sym {
 	var rr *oReader
 	switch p := s.PkgIdx; p {
-	case goobj2.PkgIdxInvalid:
+	case goobj.PkgIdxInvalid:
 		// {0, X} with non-zero X is never a valid sym reference from a Go object.
 		// We steal this space for symbol references from external objects.
 		// In this case, X is just the global index.
@@ -621,18 +621,18 @@ func (l *Loader) resolve(r *oReader, s goobj2.SymRef) Sym {
 			panic("bad sym ref")
 		}
 		return 0
-	case goobj2.PkgIdxHashed64:
+	case goobj.PkgIdxHashed64:
 		i := int(s.SymIdx) + r.ndef
 		return r.syms[i]
-	case goobj2.PkgIdxHashed:
+	case goobj.PkgIdxHashed:
 		i := int(s.SymIdx) + r.ndef + r.nhashed64def
 		return r.syms[i]
-	case goobj2.PkgIdxNone:
+	case goobj.PkgIdxNone:
 		i := int(s.SymIdx) + r.ndef + r.nhashed64def + r.nhasheddef
 		return r.syms[i]
-	case goobj2.PkgIdxBuiltin:
+	case goobj.PkgIdxBuiltin:
 		return l.builtinSyms[s.SymIdx]
-	case goobj2.PkgIdxSelf:
+	case goobj.PkgIdxSelf:
 		rr = r
 	default:
 		pkg := r.Pkg(int(p))
@@ -1143,22 +1143,22 @@ func (l *Loader) AttrSubSymbol(i Sym) bool {
 
 // Returns whether the i-th symbol has ReflectMethod attribute set.
 func (l *Loader) IsReflectMethod(i Sym) bool {
-	return l.SymAttr(i)&goobj2.SymFlagReflectMethod != 0
+	return l.SymAttr(i)&goobj.SymFlagReflectMethod != 0
 }
 
 // Returns whether the i-th symbol is nosplit.
 func (l *Loader) IsNoSplit(i Sym) bool {
-	return l.SymAttr(i)&goobj2.SymFlagNoSplit != 0
+	return l.SymAttr(i)&goobj.SymFlagNoSplit != 0
 }
 
 // Returns whether this is a Go type symbol.
 func (l *Loader) IsGoType(i Sym) bool {
-	return l.SymAttr(i)&goobj2.SymFlagGoType != 0
+	return l.SymAttr(i)&goobj.SymFlagGoType != 0
 }
 
 // Returns whether this symbol should be included in typelink.
 func (l *Loader) IsTypelink(i Sym) bool {
-	return l.SymAttr(i)&goobj2.SymFlagTypelink != 0
+	return l.SymAttr(i)&goobj.SymFlagTypelink != 0
 }
 
 // Returns whether this symbol is an itab symbol.
@@ -1503,7 +1503,7 @@ func (l *Loader) DynidSyms() []Sym {
 // if it helps speed things up).
 func (l *Loader) SymGoType(i Sym) Sym {
 	var r *oReader
-	var auxs []goobj2.Aux
+	var auxs []goobj.Aux
 	if l.IsExternal(i) {
 		pp := l.getPayload(i)
 		r = l.objs[pp.objidx].r
@@ -1516,7 +1516,7 @@ func (l *Loader) SymGoType(i Sym) Sym {
 	for j := range auxs {
 		a := &auxs[j]
 		switch a.Type() {
-		case goobj2.AuxGotype:
+		case goobj.AuxGotype:
 			return l.resolve(r, a.Sym())
 		}
 	}
@@ -1629,22 +1629,22 @@ func (l *Loader) GetFuncDwarfAuxSyms(fnSymIdx Sym) (auxDwarfInfo, auxDwarfLoc, a
 	for i := range auxs {
 		a := &auxs[i]
 		switch a.Type() {
-		case goobj2.AuxDwarfInfo:
+		case goobj.AuxDwarfInfo:
 			auxDwarfInfo = l.resolve(r, a.Sym())
 			if l.SymType(auxDwarfInfo) != sym.SDWARFFCN {
 				panic("aux dwarf info sym with wrong type")
 			}
-		case goobj2.AuxDwarfLoc:
+		case goobj.AuxDwarfLoc:
 			auxDwarfLoc = l.resolve(r, a.Sym())
 			if l.SymType(auxDwarfLoc) != sym.SDWARFLOC {
 				panic("aux dwarf loc sym with wrong type")
 			}
-		case goobj2.AuxDwarfRanges:
+		case goobj.AuxDwarfRanges:
 			auxDwarfRanges = l.resolve(r, a.Sym())
 			if l.SymType(auxDwarfRanges) != sym.SDWARFRANGE {
 				panic("aux dwarf ranges sym with wrong type")
 			}
-		case goobj2.AuxDwarfLines:
+		case goobj.AuxDwarfLines:
 			auxDwarfLines = l.resolve(r, a.Sym())
 			if l.SymType(auxDwarfLines) != sym.SDWARFLINES {
 				panic("aux dwarf lines sym with wrong type")
@@ -1840,7 +1840,7 @@ func (l *Loader) Relocs(i Sym) Relocs {
 
 // Relocs returns a Relocs object given a local sym index and reader.
 func (l *Loader) relocs(r *oReader, li uint32) Relocs {
-	var rs []goobj2.Reloc
+	var rs []goobj.Reloc
 	if l.isExtReader(r) {
 		pp := l.payloads[li]
 		rs = pp.relocs
@@ -1855,55 +1855,55 @@ func (l *Loader) relocs(r *oReader, li uint32) Relocs {
 	}
 }
 
-// FuncInfo provides hooks to access goobj2.FuncInfo in the objects.
+// FuncInfo provides hooks to access goobj.FuncInfo in the objects.
 type FuncInfo struct {
 	l       *Loader
 	r       *oReader
 	data    []byte
-	auxs    []goobj2.Aux
-	lengths goobj2.FuncInfoLengths
+	auxs    []goobj.Aux
+	lengths goobj.FuncInfoLengths
 }
 
 func (fi *FuncInfo) Valid() bool { return fi.r != nil }
 
 func (fi *FuncInfo) Args() int {
-	return int((*goobj2.FuncInfo)(nil).ReadArgs(fi.data))
+	return int((*goobj.FuncInfo)(nil).ReadArgs(fi.data))
 }
 
 func (fi *FuncInfo) Locals() int {
-	return int((*goobj2.FuncInfo)(nil).ReadLocals(fi.data))
+	return int((*goobj.FuncInfo)(nil).ReadLocals(fi.data))
 }
 
 func (fi *FuncInfo) FuncID() objabi.FuncID {
-	return objabi.FuncID((*goobj2.FuncInfo)(nil).ReadFuncID(fi.data))
+	return objabi.FuncID((*goobj.FuncInfo)(nil).ReadFuncID(fi.data))
 }
 
 func (fi *FuncInfo) Pcsp() []byte {
-	pcsp, end := (*goobj2.FuncInfo)(nil).ReadPcsp(fi.data)
+	pcsp, end := (*goobj.FuncInfo)(nil).ReadPcsp(fi.data)
 	return fi.r.BytesAt(fi.r.PcdataBase()+pcsp, int(end-pcsp))
 }
 
 func (fi *FuncInfo) Pcfile() []byte {
-	pcf, end := (*goobj2.FuncInfo)(nil).ReadPcfile(fi.data)
+	pcf, end := (*goobj.FuncInfo)(nil).ReadPcfile(fi.data)
 	return fi.r.BytesAt(fi.r.PcdataBase()+pcf, int(end-pcf))
 }
 
 func (fi *FuncInfo) Pcline() []byte {
-	pcln, end := (*goobj2.FuncInfo)(nil).ReadPcline(fi.data)
+	pcln, end := (*goobj.FuncInfo)(nil).ReadPcline(fi.data)
 	return fi.r.BytesAt(fi.r.PcdataBase()+pcln, int(end-pcln))
 }
 
 // Preload has to be called prior to invoking the various methods
 // below related to pcdata, funcdataoff, files, and inltree nodes.
 func (fi *FuncInfo) Preload() {
-	fi.lengths = (*goobj2.FuncInfo)(nil).ReadFuncInfoLengths(fi.data)
+	fi.lengths = (*goobj.FuncInfo)(nil).ReadFuncInfoLengths(fi.data)
 }
 
 func (fi *FuncInfo) Pcinline() []byte {
 	if !fi.lengths.Initialized {
 		panic("need to call Preload first")
 	}
-	pcinl, end := (*goobj2.FuncInfo)(nil).ReadPcinline(fi.data, fi.lengths.PcdataOff)
+	pcinl, end := (*goobj.FuncInfo)(nil).ReadPcinline(fi.data, fi.lengths.PcdataOff)
 	return fi.r.BytesAt(fi.r.PcdataBase()+pcinl, int(end-pcinl))
 }
 
@@ -1918,7 +1918,7 @@ func (fi *FuncInfo) Pcdata(k int) []byte {
 	if !fi.lengths.Initialized {
 		panic("need to call Preload first")
 	}
-	pcdat, end := (*goobj2.FuncInfo)(nil).ReadPcdata(fi.data, fi.lengths.PcdataOff, uint32(k))
+	pcdat, end := (*goobj.FuncInfo)(nil).ReadPcdata(fi.data, fi.lengths.PcdataOff, uint32(k))
 	return fi.r.BytesAt(fi.r.PcdataBase()+pcdat, int(end-pcdat))
 }
 
@@ -1933,7 +1933,7 @@ func (fi *FuncInfo) Funcdataoff(k int) int64 {
 	if !fi.lengths.Initialized {
 		panic("need to call Preload first")
 	}
-	return (*goobj2.FuncInfo)(nil).ReadFuncdataoff(fi.data, fi.lengths.FuncdataoffOff, uint32(k))
+	return (*goobj.FuncInfo)(nil).ReadFuncdataoff(fi.data, fi.lengths.FuncdataoffOff, uint32(k))
 }
 
 func (fi *FuncInfo) Funcdata(syms []Sym) []Sym {
@@ -1947,7 +1947,7 @@ func (fi *FuncInfo) Funcdata(syms []Sym) []Sym {
 	}
 	for j := range fi.auxs {
 		a := &fi.auxs[j]
-		if a.Type() == goobj2.AuxFuncdata {
+		if a.Type() == goobj.AuxFuncdata {
 			syms = append(syms, fi.l.resolve(fi.r, a.Sym()))
 		}
 	}
@@ -1961,16 +1961,16 @@ func (fi *FuncInfo) NumFile() uint32 {
 	return fi.lengths.NumFile
 }
 
-func (fi *FuncInfo) File(k int) goobj2.CUFileIndex {
+func (fi *FuncInfo) File(k int) goobj.CUFileIndex {
 	if !fi.lengths.Initialized {
 		panic("need to call Preload first")
 	}
-	return (*goobj2.FuncInfo)(nil).ReadFile(fi.data, fi.lengths.FileOff, uint32(k))
+	return (*goobj.FuncInfo)(nil).ReadFile(fi.data, fi.lengths.FileOff, uint32(k))
 }
 
 type InlTreeNode struct {
 	Parent   int32
-	File     goobj2.CUFileIndex
+	File     goobj.CUFileIndex
 	Line     int32
 	Func     Sym
 	ParentPC int32
@@ -1987,7 +1987,7 @@ func (fi *FuncInfo) InlTree(k int) InlTreeNode {
 	if !fi.lengths.Initialized {
 		panic("need to call Preload first")
 	}
-	node := (*goobj2.FuncInfo)(nil).ReadInlTree(fi.data, fi.lengths.InlTreeOff, uint32(k))
+	node := (*goobj.FuncInfo)(nil).ReadInlTree(fi.data, fi.lengths.InlTreeOff, uint32(k))
 	return InlTreeNode{
 		Parent:   node.Parent,
 		File:     node.File,
@@ -1999,7 +1999,7 @@ func (fi *FuncInfo) InlTree(k int) InlTreeNode {
 
 func (l *Loader) FuncInfo(i Sym) FuncInfo {
 	var r *oReader
-	var auxs []goobj2.Aux
+	var auxs []goobj.Aux
 	if l.IsExternal(i) {
 		pp := l.getPayload(i)
 		if pp.objidx == 0 {
@@ -2014,9 +2014,9 @@ func (l *Loader) FuncInfo(i Sym) FuncInfo {
 	}
 	for j := range auxs {
 		a := &auxs[j]
-		if a.Type() == goobj2.AuxFuncInfo {
+		if a.Type() == goobj.AuxFuncInfo {
 			b := r.Data(a.Sym().SymIdx)
-			return FuncInfo{l, r, b, auxs, goobj2.FuncInfoLengths{}}
+			return FuncInfo{l, r, b, auxs, goobj.FuncInfoLengths{}}
 		}
 	}
 	return FuncInfo{}
@@ -2026,12 +2026,12 @@ func (l *Loader) FuncInfo(i Sym) FuncInfo {
 // Does not add non-package symbols yet, which will be done in LoadNonpkgSyms.
 // Does not read symbol data.
 // Returns the fingerprint of the object.
-func (l *Loader) Preload(localSymVersion int, f *bio.Reader, lib *sym.Library, unit *sym.CompilationUnit, length int64) goobj2.FingerprintType {
+func (l *Loader) Preload(localSymVersion int, f *bio.Reader, lib *sym.Library, unit *sym.CompilationUnit, length int64) goobj.FingerprintType {
 	roObject, readonly, err := f.Slice(uint64(length)) // TODO: no need to map blocks that are for tools only (e.g. RefName)
 	if err != nil {
 		log.Fatal("cannot read object file:", err)
 	}
-	r := goobj2.NewReaderFromBytes(roObject, readonly)
+	r := goobj.NewReaderFromBytes(roObject, readonly)
 	if r == nil {
 		if len(roObject) >= 8 && bytes.Equal(roObject[:8], []byte("\x00go114ld")) {
 			log.Fatalf("found object file %s in old format", f.File().Name())
@@ -2078,8 +2078,8 @@ func (l *Loader) Preload(localSymVersion int, f *bio.Reader, lib *sym.Library, u
 // Holds the loader along with temporary states for loading symbols.
 type loadState struct {
 	l            *Loader
-	hashed64Syms map[uint64]symAndSize          // short hashed (content-addressable) symbols, keyed by content hash
-	hashedSyms   map[goobj2.HashType]symAndSize // hashed (content-addressable) symbols, keyed by content hash
+	hashed64Syms map[uint64]symAndSize         // short hashed (content-addressable) symbols, keyed by content hash
+	hashedSyms   map[goobj.HashType]symAndSize // hashed (content-addressable) symbols, keyed by content hash
 }
 
 // Preload symbols of given kind from an object.
@@ -2139,7 +2139,7 @@ func (st *loadState) preloadSyms(r *oReader, kind int) {
 		}
 		if strings.HasPrefix(name, "runtime.") ||
 			(loadingRuntimePkg && strings.HasPrefix(name, "type.")) {
-			if bi := goobj2.BuiltinIdx(name, v); bi != -1 {
+			if bi := goobj.BuiltinIdx(name, v); bi != -1 {
 				// This is a definition of a builtin symbol. Record where it is.
 				l.builtinSyms[bi] = gi
 			}
@@ -2160,7 +2160,7 @@ func (l *Loader) LoadNonpkgSyms(arch *sys.Arch) {
 	st := loadState{
 		l:            l,
 		hashed64Syms: make(map[uint64]symAndSize, 10000),
-		hashedSyms:   make(map[goobj2.HashType]symAndSize, 15000),
+		hashedSyms:   make(map[goobj.HashType]symAndSize, 15000),
 	}
 	for _, o := range l.objs[goObjStart:] {
 		st.preloadSyms(o.r, hashed64Def)
@@ -2199,7 +2199,7 @@ func loadObjRefs(l *Loader, r *oReader, arch *sys.Arch) {
 	for i, n := 0, r.NRefFlags(); i < n; i++ {
 		rf := r.RefFlags(i)
 		gi := l.resolve(r, rf.Sym())
-		if rf.Flag2()&goobj2.SymFlagUsedInIface != 0 {
+		if rf.Flag2()&goobj.SymFlagUsedInIface != 0 {
 			l.SetAttrUsedInIface(gi, true)
 		}
 	}
@@ -2207,7 +2207,7 @@ func loadObjRefs(l *Loader, r *oReader, arch *sys.Arch) {
 
 func abiToVer(abi uint16, localSymVersion int) int {
 	var v int
-	if abi == goobj2.SymABIstatic {
+	if abi == goobj.SymABIstatic {
 		// Static
 		v = localSymVersion
 	} else if abiver := sym.ABIToVersion(obj.ABI(abi)); abiver != -1 {
@@ -2297,13 +2297,13 @@ func (l *Loader) cloneToExternal(symIdx Sym) {
 
 		// Copy relocations
 		relocs := l.Relocs(symIdx)
-		pp.relocs = make([]goobj2.Reloc, relocs.Count())
+		pp.relocs = make([]goobj.Reloc, relocs.Count())
 		pp.reltypes = make([]objabi.RelocType, relocs.Count())
 		for i := range pp.relocs {
 			// Copy the relocs slice.
 			// Convert local reference to global reference.
 			rel := relocs.At(i)
-			pp.relocs[i].Set(rel.Off(), rel.Siz(), 0, rel.Add(), goobj2.SymRef{PkgIdx: 0, SymIdx: uint32(rel.Sym())})
+			pp.relocs[i].Set(rel.Off(), rel.Siz(), 0, rel.Add(), goobj.SymRef{PkgIdx: 0, SymIdx: uint32(rel.Sym())})
 			pp.reltypes[i] = rel.Type()
 		}
 
diff --git a/src/cmd/link/internal/loader/loader_test.go b/src/cmd/link/internal/loader/loader_test.go
index af66752f5c..1371c2a541 100644
--- a/src/cmd/link/internal/loader/loader_test.go
+++ b/src/cmd/link/internal/loader/loader_test.go
@@ -6,7 +6,7 @@ package loader
 
 import (
 	"bytes"
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"cmd/link/internal/sym"
@@ -22,7 +22,7 @@ import (
 func addDummyObjSym(t *testing.T, ldr *Loader, or *oReader, name string) Sym {
 	idx := uint32(len(ldr.objSyms))
 	st := loadState{l: ldr}
-	return st.addSym(name, 0, or, idx, nonPkgDef, &goobj2.Sym{})
+	return st.addSym(name, 0, or, idx, nonPkgDef, &goobj.Sym{})
 }
 
 func mkLoader() *Loader {
@@ -237,7 +237,7 @@ func sameRelocSlice(s1 *Relocs, s2 []Reloc) bool {
 type addFunc func(l *Loader, s Sym, s2 Sym) Sym
 
 func mkReloc(l *Loader, typ objabi.RelocType, off int32, siz uint8, add int64, sym Sym) Reloc {
-	r := Reloc{&goobj2.Reloc{}, l.extReader, l, typ}
+	r := Reloc{&goobj.Reloc{}, l.extReader, l, typ}
 	r.SetOff(off)
 	r.SetSiz(siz)
 	r.SetAdd(add)
diff --git a/src/cmd/link/internal/loader/symbolbuilder.go b/src/cmd/link/internal/loader/symbolbuilder.go
index d8b800f375..e14d89a927 100644
--- a/src/cmd/link/internal/loader/symbolbuilder.go
+++ b/src/cmd/link/internal/loader/symbolbuilder.go
@@ -5,7 +5,7 @@
 package loader
 
 import (
-	"cmd/internal/goobj2"
+	"cmd/internal/goobj"
 	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"cmd/link/internal/sym"
@@ -132,7 +132,7 @@ func (sb *SymbolBuilder) SetRelocType(i int, t objabi.RelocType) {
 
 // SetRelocSym sets the target sym of the 'i'-th relocation on this sym to 's'
 func (sb *SymbolBuilder) SetRelocSym(i int, tgt Sym) {
-	sb.relocs[i].SetSym(goobj2.SymRef{PkgIdx: 0, SymIdx: uint32(tgt)})
+	sb.relocs[i].SetSym(goobj.SymRef{PkgIdx: 0, SymIdx: uint32(tgt)})
 }
 
 // SetRelocAdd sets the addend of the 'i'-th relocation on this sym to 'a'
@@ -142,7 +142,7 @@ func (sb *SymbolBuilder) SetRelocAdd(i int, a int64) {
 
 // Add n relocations, return a handle to the relocations.
 func (sb *SymbolBuilder) AddRelocs(n int) Relocs {
-	sb.relocs = append(sb.relocs, make([]goobj2.Reloc, n)...)
+	sb.relocs = append(sb.relocs, make([]goobj.Reloc, n)...)
 	sb.reltypes = append(sb.reltypes, make([]objabi.RelocType, n)...)
 	return sb.l.Relocs(sb.symIdx)
 }
@@ -151,7 +151,7 @@ func (sb *SymbolBuilder) AddRelocs(n int) Relocs {
 // (to set other fields).
 func (sb *SymbolBuilder) AddRel(typ objabi.RelocType) (Reloc, int) {
 	j := len(sb.relocs)
-	sb.relocs = append(sb.relocs, goobj2.Reloc{})
+	sb.relocs = append(sb.relocs, goobj.Reloc{})
 	sb.reltypes = append(sb.reltypes, typ)
 	relocs := sb.Relocs()
 	return relocs.At(j), j
diff --git a/src/cmd/link/internal/sym/library.go b/src/cmd/link/internal/sym/library.go
index 7f6e63c020..876b5ff153 100644
--- a/src/cmd/link/internal/sym/library.go
+++ b/src/cmd/link/internal/sym/library.go
@@ -4,7 +4,7 @@
 
 package sym
 
-import "cmd/internal/goobj2"
+import "cmd/internal/goobj"
 
 type Library struct {
 	Objref      string
@@ -12,8 +12,8 @@ type Library struct {
 	File        string
 	Pkg         string
 	Shlib       string
-	Fingerprint goobj2.FingerprintType
-	Autolib     []goobj2.ImportedPkg
+	Fingerprint goobj.FingerprintType
+	Autolib     []goobj.ImportedPkg
 	Imports     []*Library
 	Main        bool
 	Units       []*CompilationUnit
