commit a11f256436a386c81e3a34378b37bc51fb2d5f61
Author: Austin Clements <austin@google.com>
Date:   Fri Nov 14 12:08:46 2014 -0500

    [dev.power64] liblink: generate dnames[5689] for D_* constants
    
    This is more complicated than the other enums because the D_*
    enums are full of explicit initializers and repeated values.
    This tries its best.  (This will get much cleaner once we
    tease these constants apart better.)
    
    LGTM=rsc
    R=rsc
    CC=golang-codereviews
    https://golang.org/cl/166700043
---
 include/link.h         |  5 +++
 src/cmd/dist/buildgc.c | 85 ++++++++++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 87 insertions(+), 3 deletions(-)

diff --git a/include/link.h b/include/link.h
index 06f3ebb489..225c6f95df 100644
--- a/include/link.h
+++ b/include/link.h
@@ -626,6 +626,11 @@ extern	char*	anames9[];
 extern	char*	cnames5[];
 extern	char*	cnames9[];
 
+extern	char*	dnames5[];
+extern	char*	dnames6[];
+extern	char*	dnames8[];
+extern	char*	dnames9[];
+
 extern	LinkArch	link386;
 extern	LinkArch	linkamd64;
 extern	LinkArch	linkamd64p32;
diff --git a/src/cmd/dist/buildgc.c b/src/cmd/dist/buildgc.c
index 1c33297587..39679fb724 100644
--- a/src/cmd/dist/buildgc.c
+++ b/src/cmd/dist/buildgc.c
@@ -63,22 +63,36 @@ gcopnames(char *dir, char *file)
 	vfree(&fields);
 }
 
+static int
+xatoi(char *s, char **end)
+{
+	int val = 0;
+	for(; *s && *s >= '0' && *s <= '9'; ++s)
+		val = val * 10 + (*s - '0');
+	*end = s;
+	return val;
+}
+
 // mkanames reads [5689].out.h and writes anames[5689].c
 // The format is much the same as the Go opcodes above.
-// it also writes out cnames array for C_* constants.
+// It also writes out cnames array for C_* constants and the dnames
+// array for D_* constants.
 void
 mkanames(char *dir, char *file)
 {
-	int i, j, ch;
+	int i, j, ch, n, unknown;
 	Buf in, b, out, out2;
 	Vec lines;
-	char *p;
+	char *p, *p2;
+	Vec dnames[128];
 
 	binit(&b);
 	binit(&in);
 	binit(&out);
 	binit(&out2);
 	vinit(&lines);
+	for(i=0; i<nelem(dnames); i++)
+		vinit(&dnames[i]);
 
 	ch = file[xstrlen(file)-3];
 	bprintf(&b, "%s/../cmd/%cl/%c.out.h", dir, ch, ch);
@@ -87,10 +101,12 @@ mkanames(char *dir, char *file)
 	
 	// Include link.h so that the extern declaration there is
 	// checked against the non-extern declaration we are generating.
+	bwritestr(&out, bprintf(&b, "// auto generated by go tool dist\n"));
 	bwritestr(&out, bprintf(&b, "#include <u.h>\n"));
 	bwritestr(&out, bprintf(&b, "#include <libc.h>\n"));
 	bwritestr(&out, bprintf(&b, "#include <bio.h>\n"));
 	bwritestr(&out, bprintf(&b, "#include <link.h>\n"));
+	bwritestr(&out, bprintf(&b, "#include \"../cmd/%cl/%c.out.h\"\n", ch, ch));
 	bwritestr(&out, bprintf(&b, "\n"));
 
 	bwritestr(&out, bprintf(&b, "char*	anames%c[] = {\n", ch));
@@ -127,6 +143,67 @@ mkanames(char *dir, char *file)
 	if(j>0)
 		bwriteb(&out, &out2);
 
+	j=unknown=0;
+	n=-1;
+	for(i=0; i<lines.len; i++) {
+		if(hasprefix(lines.p[i], "\tD_")) {
+			p = xstrstr(lines.p[i], ",");
+			if(p)
+				*p = '\0';
+			p = xstrstr(lines.p[i], "\n");
+			if(p)
+				*p = '\0';
+
+			// Parse explicit value, if any
+			p = xstrstr(lines.p[i], "=");
+			if(p) {
+				// Skip space after '='
+				p2 = p + 1;
+				while(*p2 == ' ' || *p2 == '\t')
+					p2++;
+				n = xatoi(p2, &p2);
+				// We can't do anything about
+				// non-numeric values or anything that
+				// follows
+				while(*p2 == ' ' || *p2 == '\t')
+					p2++;
+				if(*p2 != 0) {
+					unknown = 1;
+					continue;
+				}
+				// Truncate space before '='
+				while(*(p-1) == ' ' || *(p-1) == '\t')
+					p--;
+				*p = '\0';
+				unknown = 0;
+			} else {
+				n++;
+			}
+
+			if(unknown || n >= nelem(dnames))
+				continue;
+
+			p = lines.p[i] + 3;
+			vadd(&dnames[n], p);
+			j++;
+		}
+	}
+	if(j>0){
+		bwritestr(&out, bprintf(&b, "char*	dnames%c[] = {\n", ch));
+		for(i=0; i<nelem(dnames); i++) {
+			if(dnames[i].len == 0)
+				continue;
+			bwritestr(&out, bprintf(&b, "\t[D_%s] = \"", dnames[i].p[0]));
+			for(j=0; j<dnames[i].len; j++) {
+				if(j != 0)
+					bwritestr(&out, "/");
+				bwritestr(&out, dnames[i].p[j]);
+			}
+			bwritestr(&out, "\",\n");
+		}
+		bwritestr(&out, "};\n");
+	}
+
 	writefile(&out, file, 0);
 
 	bfree(&b);
@@ -134,4 +211,6 @@ mkanames(char *dir, char *file)
 	bfree(&out);
 	bfree(&out2);
 	vfree(&lines);
+	for(i=0; i<nelem(dnames); i++)
+		vfree(&dnames[i]);
 }
