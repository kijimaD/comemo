commit ebaf8db4f62af36c7215735891f014dc4bb4e2ba
Author: Russ Cox <rsc@golang.org>
Date:   Wed Jan 21 14:48:18 2015 -0500

    [dev.cc] cmd/internal/obj: export more symbols, rename Type_ to Type
    
    For new assembler, reconvert using rsc.io/c2go rev f9db76e.
    - Removes trailing _ from Go keywords that are exported.
    - Export regstr as Register, anames[5689] as Anames.
    
    Also update clients.
    
    Change-Id: I41c8fd2d14490236f548b4aa0ed0b9bd7571d2d7
    Reviewed-on: https://go-review.googlesource.com/3151
    Reviewed-by: Rob Pike <r@golang.org>
---
 src/cmd/internal/obj/arm/anames5.go   |   2 +-
 src/cmd/internal/obj/arm/asm5.go      |  88 +++++++--------
 src/cmd/internal/obj/arm/list5.go     |  14 +--
 src/cmd/internal/obj/arm/obj5.go      | 196 +++++++++++++++++-----------------
 src/cmd/internal/obj/data.go          |  40 +++----
 src/cmd/internal/obj/i386/anames8.go  |   2 +-
 src/cmd/internal/obj/i386/asm8.go     | 126 +++++++++++-----------
 src/cmd/internal/obj/i386/list8.go    |  14 +--
 src/cmd/internal/obj/i386/obj8.go     | 164 ++++++++++++++--------------
 src/cmd/internal/obj/link.go          |   8 +-
 src/cmd/internal/obj/objfile.go       |  44 ++++----
 src/cmd/internal/obj/pass.go          |   6 +-
 src/cmd/internal/obj/pcln.go          |   2 +-
 src/cmd/internal/obj/ppc64/anames9.go |   2 +-
 src/cmd/internal/obj/ppc64/asm9.go    |  48 ++++-----
 src/cmd/internal/obj/ppc64/list9.go   |  18 ++--
 src/cmd/internal/obj/ppc64/obj9.go    | 170 ++++++++++++++---------------
 src/cmd/internal/obj/sym.go           |   2 +-
 src/cmd/internal/obj/x86/anames6.go   |   2 +-
 src/cmd/internal/obj/x86/asm6.go      | 140 ++++++++++++------------
 src/cmd/internal/obj/x86/list6.go     |  14 +--
 src/cmd/internal/obj/x86/obj6.go      | 180 +++++++++++++++----------------
 src/cmd/new5a/a.y                     |  72 ++++++-------
 src/cmd/new5a/lex.go                  |   2 +-
 src/cmd/new5a/y.go                    |  72 ++++++-------
 src/cmd/new6a/a.y                     |  72 ++++++-------
 src/cmd/new6a/lex.go                  |   2 +-
 src/cmd/new6a/y.go                    |  72 ++++++-------
 src/cmd/new8a/a.y                     |  74 ++++++-------
 src/cmd/new8a/lex.go                  |   2 +-
 src/cmd/new8a/y.go                    |  74 ++++++-------
 src/cmd/new9a/a.y                     |  68 ++++++------
 src/cmd/new9a/lex.go                  |   2 +-
 src/cmd/new9a/y.go                    |  68 ++++++------
 src/cmd/objwriter/main.go             |   6 +-
 35 files changed, 934 insertions(+), 934 deletions(-)

diff --git a/src/cmd/internal/obj/arm/anames5.go b/src/cmd/internal/obj/arm/anames5.go
index 4c82a2d2e3..dd7b12aa13 100644
--- a/src/cmd/internal/obj/arm/anames5.go
+++ b/src/cmd/internal/obj/arm/anames5.go
@@ -1,6 +1,6 @@
 package arm
 
-var anames5 = []string{
+var Anames = []string{
 	"XXX",
 	"AND",
 	"EOR",
diff --git a/src/cmd/internal/obj/arm/asm5.go b/src/cmd/internal/obj/arm/asm5.go
index 6a20cc8aae..466e30bc3c 100644
--- a/src/cmd/internal/obj/arm/asm5.go
+++ b/src/cmd/internal/obj/arm/asm5.go
@@ -276,14 +276,14 @@ var zprg = obj.Prog{
 	Scond: C_SCOND_NONE,
 	Reg:   NREG,
 	From: obj.Addr{
-		Name:  D_NONE,
-		Type_: D_NONE,
-		Reg:   NREG,
+		Name: D_NONE,
+		Type: D_NONE,
+		Reg:  NREG,
 	},
 	To: obj.Addr{
-		Name:  D_NONE,
-		Type_: D_NONE,
-		Reg:   NREG,
+		Name: D_NONE,
+		Type: D_NONE,
+		Reg:  NREG,
 	},
 }
 
@@ -362,7 +362,7 @@ func asmoutnacl(ctxt *obj.Link, origPC int32, p *obj.Prog, o *Optab, out []uint3
 
 	case AB,
 		ABL:
-		if p.To.Type_ != D_OREG {
+		if p.To.Type != D_OREG {
 			if out != nil {
 				asmout(ctxt, p, o, out)
 			}
@@ -414,7 +414,7 @@ func asmoutnacl(ctxt *obj.Link, origPC int32, p *obj.Prog, o *Optab, out []uint3
 		AMOVW,
 		ASTREX,
 		ASTREXD:
-		if p.To.Type_ == D_REG && p.To.Reg == 15 && p.From.Reg == 13 { // MOVW.W x(R13), PC
+		if p.To.Type == D_REG && p.To.Reg == 15 && p.From.Reg == 13 { // MOVW.W x(R13), PC
 			if out != nil {
 				asmout(ctxt, p, o, out)
 			}
@@ -454,11 +454,11 @@ func asmoutnacl(ctxt *obj.Link, origPC int32, p *obj.Prog, o *Optab, out []uint3
 			}
 		}
 
-		if p.To.Type_ == D_REG && p.To.Reg == 15 {
+		if p.To.Type == D_REG && p.To.Reg == 15 {
 			ctxt.Diag("unsupported instruction (move to another register and use indirect jump instead): %v", p)
 		}
 
-		if p.To.Type_ == D_OREG && p.To.Reg == 13 && (p.Scond&C_WBIT != 0) && size > 4 {
+		if p.To.Type == D_OREG && p.To.Reg == 13 && (p.Scond&C_WBIT != 0) && size > 4 {
 			// function prolog with very large frame size: MOVW.W R14,-100004(R13)
 			// split it into two instructions:
 			// 	ADD $-100004, R13
@@ -468,7 +468,7 @@ func asmoutnacl(ctxt *obj.Link, origPC int32, p *obj.Prog, o *Optab, out []uint3
 			p.Scond &^= C_WBIT
 			*q = *p
 			a = &p.To
-			if p.To.Type_ == D_OREG {
+			if p.To.Type == D_OREG {
 				a2 = &q.To
 			} else {
 
@@ -488,16 +488,16 @@ func asmoutnacl(ctxt *obj.Link, origPC int32, p *obj.Prog, o *Optab, out []uint3
 
 			p.From = *a
 			p.From.Reg = NREG
-			p.From.Type_ = D_CONST
+			p.From.Type = D_CONST
 			p.To = zprg.To
-			p.To.Type_ = D_REG
+			p.To.Type = D_REG
 			p.To.Reg = 13
 
 			// make q into p but load/store from 0(R13)
 			q.Spadj = 0
 
 			*a2 = zprg.From
-			a2.Type_ = D_OREG
+			a2.Type = D_OREG
 			a2.Reg = 13
 			a2.Sym = nil
 			a2.Offset = 0
@@ -505,8 +505,8 @@ func asmoutnacl(ctxt *obj.Link, origPC int32, p *obj.Prog, o *Optab, out []uint3
 			break
 		}
 
-		if (p.To.Type_ == D_OREG && p.To.Reg != 13 && p.To.Reg != 9) || (p.From.Type_ == D_OREG && p.From.Reg != 13 && p.From.Reg != 9) { // MOVW Rx, X(Ry), y != 13 && y != 9 // MOVW X(Rx), Ry, x != 13 && x != 9
-			if p.To.Type_ == D_OREG {
+		if (p.To.Type == D_OREG && p.To.Reg != 13 && p.To.Reg != 9) || (p.From.Type == D_OREG && p.From.Reg != 13 && p.From.Reg != 9) { // MOVW Rx, X(Ry), y != 13 && y != 9 // MOVW X(Rx), Ry, x != 13 && x != 9
+			if p.To.Type == D_OREG {
 				a = &p.To
 			} else {
 
@@ -548,7 +548,7 @@ func asmoutnacl(ctxt *obj.Link, origPC int32, p *obj.Prog, o *Optab, out []uint3
 				}
 				q = ctxt.Arch.Prg()
 				*q = *p
-				if p.To.Type_ == D_OREG {
+				if p.To.Type == D_OREG {
 					a2 = &q.To
 				} else {
 
@@ -567,15 +567,15 @@ func asmoutnacl(ctxt *obj.Link, origPC int32, p *obj.Prog, o *Optab, out []uint3
 				p.As = AMOVW
 
 				p.From = *a
-				p.From.Type_ = D_CONST
+				p.From.Type = D_CONST
 				p.To = zprg.To
-				p.To.Type_ = D_REG
+				p.To.Type = D_REG
 				p.To.Reg = 11
 
 				// make q into p but load/store from 0(R11)
 				*a2 = zprg.From
 
-				a2.Type_ = D_OREG
+				a2.Type = D_OREG
 				a2.Reg = 11
 				a2.Sym = nil
 				a2.Offset = 0
@@ -589,7 +589,7 @@ func asmoutnacl(ctxt *obj.Link, origPC int32, p *obj.Prog, o *Optab, out []uint3
 	}
 
 	// destination register specific
-	if p.To.Type_ == D_REG {
+	if p.To.Type == D_REG {
 
 		switch p.To.Reg {
 		case 9:
@@ -701,7 +701,7 @@ func span5(ctxt *obj.Link, cursym *obj.LSym) {
 			break
 		}
 
-		if p.As == AMOVW && p.To.Type_ == D_REG && p.To.Reg == REGPC && p.Scond&C_SCOND == C_SCOND_NONE {
+		if p.As == AMOVW && p.To.Type == D_REG && p.To.Reg == REGPC && p.Scond&C_SCOND == C_SCOND_NONE {
 			flushpool(ctxt, p, 0, 0)
 		}
 		c += int32(m)
@@ -896,7 +896,7 @@ func flushpool(ctxt *obj.Link, p *obj.Prog, skip int, force int) int {
 			}
 			q = ctxt.Arch.Prg()
 			q.As = AB
-			q.To.Type_ = D_BRANCH
+			q.To.Type = D_BRANCH
 			q.Pcond = p.Link
 			q.Link = ctxt.Blitrl
 			q.Lineno = p.Lineno
@@ -950,7 +950,7 @@ func addpool(ctxt *obj.Link, p *obj.Prog, a *obj.Addr) {
 	default:
 		t.To.Offset = a.Offset
 		t.To.Sym = a.Sym
-		t.To.Type_ = a.Type_
+		t.To.Type = a.Type
 		t.To.Name = a.Name
 
 		if ctxt.Flag_shared != 0 && t.To.Sym != nil {
@@ -967,7 +967,7 @@ func addpool(ctxt *obj.Link, p *obj.Prog, a *obj.Addr) {
 		C_SAUTO,
 		C_LAUTO,
 		C_LACON:
-		t.To.Type_ = D_CONST
+		t.To.Type = D_CONST
 		t.To.Offset = ctxt.Instoffset
 		break
 	}
@@ -1064,7 +1064,7 @@ func aclass(ctxt *obj.Link, a *obj.Addr) int {
 	var s *obj.LSym
 	var t int
 
-	switch a.Type_ {
+	switch a.Type {
 	case D_NONE:
 		return C_NONE
 
@@ -1291,7 +1291,7 @@ func oplook(ctxt *obj.Link, p *obj.Prog) *Optab {
 
 	if false { /*debug['O']*/
 		fmt.Printf("oplook %v %v %v %v\n", Aconv(int(p.As)), DRconv(a1), DRconv(a2), DRconv(a3))
-		fmt.Printf("\t\t%d %d\n", p.From.Type_, p.To.Type_)
+		fmt.Printf("\t\t%d %d\n", p.From.Type, p.To.Type)
 	}
 
 	e = oprange[r].stop
@@ -1308,8 +1308,8 @@ func oplook(ctxt *obj.Link, p *obj.Prog) *Optab {
 		}
 	}
 
-	ctxt.Diag("illegal combination %v; %v %v %v, %d %d", p, DRconv(a1), DRconv(a2), DRconv(a3), p.From.Type_, p.To.Type_)
-	ctxt.Diag("from %d %d to %d %d\n", p.From.Type_, p.From.Name, p.To.Type_, p.To.Name)
+	ctxt.Diag("illegal combination %v; %v %v %v, %d %d", p, DRconv(a1), DRconv(a2), DRconv(a3), p.From.Type, p.To.Type)
+	ctxt.Diag("from %d %d to %d %d\n", p.From.Type, p.From.Name, p.To.Type, p.To.Name)
 	prasm(p)
 	if o == nil {
 		o = optab
@@ -1627,7 +1627,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 		rf = int(p.From.Reg)
 		rt = int(p.To.Reg)
 		r = int(p.Reg)
-		if p.To.Type_ == D_NONE {
+		if p.To.Type == D_NONE {
 			rt = 0
 		}
 		if p.As == AMOVB || p.As == AMOVH || p.As == AMOVW || p.As == AMVN {
@@ -1644,7 +1644,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 		o1 |= uint32(immrot(uint32(ctxt.Instoffset)))
 		rt = int(p.To.Reg)
 		r = int(p.Reg)
-		if p.To.Type_ == D_NONE {
+		if p.To.Type == D_NONE {
 			rt = 0
 		}
 		if p.As == AMOVW || p.As == AMVN {
@@ -1680,7 +1680,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 			rel.Sym = p.To.Sym
 			v += int32(p.To.Offset)
 			rel.Add = int64(o1) | (int64(v)>>2)&0xffffff
-			rel.Type_ = obj.R_CALLARM
+			rel.Type = obj.R_CALLARM
 			break
 		}
 
@@ -1708,7 +1708,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 		rel = obj.Addrel(ctxt.Cursym)
 		rel.Off = int32(ctxt.Pc)
 		rel.Siz = 0
-		rel.Type_ = obj.R_CALLIND
+		rel.Type = obj.R_CALLIND
 
 	case 8: /* sll $c,[R],R -> mov (R<<$c),R */
 		aclass(ctxt, &p.From)
@@ -1736,7 +1736,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 	case 10: /* swi [$con] */
 		o1 = oprrr(ctxt, int(p.As), int(p.Scond))
 
-		if p.To.Type_ != D_NONE {
+		if p.To.Type != D_NONE {
 			aclass(ctxt, &p.To)
 			o1 |= uint32(ctxt.Instoffset & 0xffffff)
 		}
@@ -1761,18 +1761,18 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 			// Emit a TLS relocation instead of a standard one.
 			if rel.Sym == ctxt.Tlsg {
 
-				rel.Type_ = obj.R_TLS
+				rel.Type = obj.R_TLS
 				if ctxt.Flag_shared != 0 {
 					rel.Add += ctxt.Pc - p.Pcrel.Pc - 8 - int64(rel.Siz)
 				}
 				rel.Xadd = rel.Add
 				rel.Xsym = rel.Sym
 			} else if ctxt.Flag_shared != 0 {
-				rel.Type_ = obj.R_PCREL
+				rel.Type = obj.R_PCREL
 				rel.Add += ctxt.Pc - p.Pcrel.Pc - 8
 			} else {
 
-				rel.Type_ = obj.R_ADDR
+				rel.Type = obj.R_ADDR
 			}
 			o1 = 0
 		}
@@ -1799,7 +1799,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 			r = int(p.To.Reg)
 		}
 		o2 |= uint32(r) << 16
-		if p.To.Type_ != D_NONE {
+		if p.To.Type != D_NONE {
 			o2 |= uint32(p.To.Reg) << 12
 		}
 
@@ -1926,7 +1926,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 			r = int(o.param)
 		}
 		o2 |= uint32(r) << 16
-		if p.To.Type_ != D_NONE {
+		if p.To.Type != D_NONE {
 			o2 |= uint32(p.To.Reg) << 12
 		}
 
@@ -2088,7 +2088,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 		o1 |= uint32(immrot(0xff))
 		rt = int(p.To.Reg)
 		r = int(p.From.Reg)
-		if p.To.Type_ == D_NONE {
+		if p.To.Type == D_NONE {
 			rt = 0
 		}
 		if r == NREG {
@@ -2157,7 +2157,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 			rel = obj.Addrel(ctxt.Cursym)
 			rel.Off = int32(ctxt.Pc)
 			rel.Siz = 4
-			if p.To.Sym != nil && p.To.Sym.Type_ != 0 {
+			if p.To.Sym != nil && p.To.Sym.Type != 0 {
 				rel.Sym = p.To.Sym
 				rel.Add = p.To.Offset
 			} else {
@@ -2167,11 +2167,11 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 			}
 
 			if o.flag&LPCREL != 0 {
-				rel.Type_ = obj.R_PCREL
+				rel.Type = obj.R_PCREL
 				rel.Add += ctxt.Pc - p.Pcrel.Pc - 16 + int64(rel.Siz)
 			} else {
 
-				rel.Type_ = obj.R_ADDR
+				rel.Type = obj.R_ADDR
 			}
 			o1 = 0
 		}
@@ -2550,7 +2550,7 @@ func mov(ctxt *obj.Link, p *obj.Prog) uint32 {
 	o1 |= uint32(p.From.Offset)
 	rt = int(p.To.Reg)
 	r = int(p.Reg)
-	if p.To.Type_ == D_NONE {
+	if p.To.Type == D_NONE {
 		rt = 0
 	}
 	if p.As == AMOVW || p.As == AMVN {
diff --git a/src/cmd/internal/obj/arm/list5.go b/src/cmd/internal/obj/arm/list5.go
index 1c817bb134..ee9e53e904 100644
--- a/src/cmd/internal/obj/arm/list5.go
+++ b/src/cmd/internal/obj/arm/list5.go
@@ -84,9 +84,9 @@ func Pconv(p *obj.Prog) string {
 		sc += ".U"
 	}
 	if a == AMOVM {
-		if p.From.Type_ == D_CONST {
+		if p.From.Type == D_CONST {
 			str = fmt.Sprintf("%.5d (%v)\t%v%s\t%v,%v", p.Pc, p.Line(), Aconv(a), sc, RAconv(&p.From), Dconv(p, 0, &p.To))
-		} else if p.To.Type_ == D_CONST {
+		} else if p.To.Type == D_CONST {
 			str = fmt.Sprintf("%.5d (%v)\t%v%s\t%v,%v", p.Pc, p.Line(), Aconv(a), sc, Dconv(p, 0, &p.From), RAconv(&p.To))
 		} else {
 
@@ -98,7 +98,7 @@ func Pconv(p *obj.Prog) string {
 		str = fmt.Sprintf("%.5d (%v)\t%v\t%v,%d,%v", p.Pc, p.Line(), Aconv(a), Dconv(p, 0, &p.From), p.Reg, Dconv(p, 0, &p.To))
 	} else if p.Reg == NREG {
 		str = fmt.Sprintf("%.5d (%v)\t%v%s\t%v,%v", p.Pc, p.Line(), Aconv(a), sc, Dconv(p, 0, &p.From), Dconv(p, 0, &p.To))
-	} else if p.From.Type_ != D_FREG {
+	} else if p.From.Type != D_FREG {
 		str = fmt.Sprintf("%.5d (%v)\t%v%s\t%v,R%d,%v", p.Pc, p.Line(), Aconv(a), sc, Dconv(p, 0, &p.From), p.Reg, Dconv(p, 0, &p.To))
 	} else {
 
@@ -115,7 +115,7 @@ func Aconv(a int) string {
 
 	s = "???"
 	if a >= AXXX && a < ALAST {
-		s = anames5[a]
+		s = Anames[a]
 	}
 	fp += s
 	return fp
@@ -128,9 +128,9 @@ func Dconv(p *obj.Prog, flag int, a *obj.Addr) string {
 	var op string
 	var v int
 
-	switch a.Type_ {
+	switch a.Type {
 	default:
-		str = fmt.Sprintf("GOK-type(%d)", a.Type_)
+		str = fmt.Sprintf("GOK-type(%d)", a.Type)
 
 	case D_NONE:
 		str = ""
@@ -220,7 +220,7 @@ func RAconv(a *obj.Addr) string {
 	var v int
 
 	str = fmt.Sprintf("GOK-reglist")
-	switch a.Type_ {
+	switch a.Type {
 	case D_CONST,
 		D_CONST2:
 		if a.Reg != NREG {
diff --git a/src/cmd/internal/obj/arm/obj5.go b/src/cmd/internal/obj/arm/obj5.go
index 6905376778..e8d4a5fc67 100644
--- a/src/cmd/internal/obj/arm/obj5.go
+++ b/src/cmd/internal/obj/arm/obj5.go
@@ -43,14 +43,14 @@ var zprg5 = obj.Prog{
 	Scond: C_SCOND_NONE,
 	Reg:   NREG,
 	From: obj.Addr{
-		Name:  D_NONE,
-		Type_: D_NONE,
-		Reg:   NREG,
+		Name: D_NONE,
+		Type: D_NONE,
+		Reg:  NREG,
 	},
 	To: obj.Addr{
-		Name:  D_NONE,
-		Type_: D_NONE,
-		Reg:   NREG,
+		Name: D_NONE,
+		Type: D_NONE,
+		Reg:  NREG,
 	},
 }
 
@@ -93,8 +93,8 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 		ABL,
 		ADUFFZERO,
 		ADUFFCOPY:
-		if p.To.Type_ == D_OREG && (p.To.Name == D_EXTERN || p.To.Name == D_STATIC) && p.To.Sym != nil {
-			p.To.Type_ = D_BRANCH
+		if p.To.Type == D_OREG && (p.To.Name == D_EXTERN || p.To.Name == D_STATIC) && p.To.Sym != nil {
+			p.To.Type = D_BRANCH
 		}
 		break
 	}
@@ -123,16 +123,16 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 				// MOVW	LR, R11
 				p.As = AMOVW
 
-				p.From.Type_ = D_REG
+				p.From.Type = D_REG
 				p.From.Reg = REGLINK
-				p.To.Type_ = D_REG
+				p.To.Type = D_REG
 				p.To.Reg = REGTMP
 
 				// BL	runtime.read_tls_fallback(SB)
 				p = obj.Appendp(ctxt, p)
 
 				p.As = ABL
-				p.To.Type_ = D_BRANCH
+				p.To.Type = D_BRANCH
 				p.To.Sym = tlsfallback
 				p.To.Offset = 0
 
@@ -140,9 +140,9 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 				p = obj.Appendp(ctxt, p)
 
 				p.As = AMOVW
-				p.From.Type_ = D_REG
+				p.From.Type = D_REG
 				p.From.Reg = REGTMP
-				p.To.Type_ = D_REG
+				p.To.Type = D_REG
 				p.To.Reg = REGLINK
 				break
 			}
@@ -158,38 +158,38 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 	switch p.As {
 
 	case AMOVF:
-		if p.From.Type_ == D_FCONST && chipfloat5(ctxt, p.From.U.Dval) < 0 && (chipzero5(ctxt, p.From.U.Dval) < 0 || p.Scond&C_SCOND != C_SCOND_NONE) {
+		if p.From.Type == D_FCONST && chipfloat5(ctxt, p.From.U.Dval) < 0 && (chipzero5(ctxt, p.From.U.Dval) < 0 || p.Scond&C_SCOND != C_SCOND_NONE) {
 			var i32 uint32
 			var f32 float32
 			f32 = float32(p.From.U.Dval)
 			i32 = math.Float32bits(f32)
 			literal = fmt.Sprintf("$f32.%08x", i32)
 			s = obj.Linklookup(ctxt, literal, 0)
-			if s.Type_ == 0 {
-				s.Type_ = obj.SRODATA
+			if s.Type == 0 {
+				s.Type = obj.SRODATA
 				obj.Adduint32(ctxt, s, i32)
 				s.Reachable = 0
 			}
 
-			p.From.Type_ = D_OREG
+			p.From.Type = D_OREG
 			p.From.Sym = s
 			p.From.Name = D_EXTERN
 			p.From.Offset = 0
 		}
 
 	case AMOVD:
-		if p.From.Type_ == D_FCONST && chipfloat5(ctxt, p.From.U.Dval) < 0 && (chipzero5(ctxt, p.From.U.Dval) < 0 || p.Scond&C_SCOND != C_SCOND_NONE) {
+		if p.From.Type == D_FCONST && chipfloat5(ctxt, p.From.U.Dval) < 0 && (chipzero5(ctxt, p.From.U.Dval) < 0 || p.Scond&C_SCOND != C_SCOND_NONE) {
 			var i64 uint64
 			i64 = math.Float64bits(p.From.U.Dval)
 			literal = fmt.Sprintf("$f64.%016x", i64)
 			s = obj.Linklookup(ctxt, literal, 0)
-			if s.Type_ == 0 {
-				s.Type_ = obj.SRODATA
+			if s.Type == 0 {
+				s.Type = obj.SRODATA
 				obj.Adduint64(ctxt, s, i64)
 				s.Reachable = 0
 			}
 
-			p.From.Type_ = D_OREG
+			p.From.Type = D_OREG
 			p.From.Sym = s
 			p.From.Name = D_EXTERN
 			p.From.Offset = 0
@@ -209,11 +209,11 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 			ctxt.Tlsg = obj.Linklookup(ctxt, "runtime.tlsg", 0)
 		}
 
-		if p.From.Type_ == D_CONST && p.From.Name == D_EXTERN && p.From.Sym == ctxt.Tlsg {
-			p.From.Type_ = D_OREG
+		if p.From.Type == D_CONST && p.From.Name == D_EXTERN && p.From.Sym == ctxt.Tlsg {
+			p.From.Type = D_OREG
 		}
-		if p.To.Type_ == D_CONST && p.To.Name == D_EXTERN && p.To.Sym == ctxt.Tlsg {
-			p.To.Type_ = D_OREG
+		if p.To.Type == D_CONST && p.To.Name == D_EXTERN && p.To.Sym == ctxt.Tlsg {
+			p.To.Type = D_OREG
 		}
 	}
 }
@@ -295,29 +295,29 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 			p = obj.Appendp(ctxt, p)
 
 			p.As = AMOVW
-			p.From.Type_ = D_CONST
+			p.From.Type = D_CONST
 			p.From.Reg = 13
 			p.From.Offset = 4
-			p.To.Type_ = D_REG
+			p.To.Type = D_REG
 			p.To.Reg = 1
 
 			// MOVW $n(R13), R2
 			p = obj.Appendp(ctxt, p)
 
 			p.As = AMOVW
-			p.From.Type_ = D_CONST
+			p.From.Type = D_CONST
 			p.From.Reg = 13
 			p.From.Offset = 4 + int64(autoffset)
-			p.To.Type_ = D_REG
+			p.To.Type = D_REG
 			p.To.Reg = 2
 
 			// MOVW $0, R3
 			p = obj.Appendp(ctxt, p)
 
 			p.As = AMOVW
-			p.From.Type_ = D_CONST
+			p.From.Type = D_CONST
 			p.From.Offset = 0
-			p.To.Type_ = D_REG
+			p.To.Type = D_REG
 			p.To.Reg = 3
 
 			// L:
@@ -328,22 +328,22 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 			p = pl
 
 			p.As = AMOVW
-			p.From.Type_ = D_REG
+			p.From.Type = D_REG
 			p.From.Reg = 3
-			p.To.Type_ = D_OREG
+			p.To.Type = D_OREG
 			p.To.Reg = 1
 			p.To.Offset = 4
 			p.Scond |= C_PBIT
 
 			p = obj.Appendp(ctxt, p)
 			p.As = ACMP
-			p.From.Type_ = D_REG
+			p.From.Type = D_REG
 			p.From.Reg = 1
 			p.Reg = 2
 
 			p = obj.Appendp(ctxt, p)
 			p.As = ABNE
-			p.To.Type_ = D_BRANCH
+			p.To.Type = D_BRANCH
 			p.Pcond = pl
 		}
 	}
@@ -463,9 +463,9 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 
 			p.As = AMOVW
 			p.Scond |= C_WBIT
-			p.From.Type_ = D_REG
+			p.From.Type = D_REG
 			p.From.Reg = REGLINK
-			p.To.Type_ = D_OREG
+			p.To.Type = D_OREG
 			p.To.Offset = int64(-autosize)
 			p.To.Reg = REGSP
 			p.Spadj = autosize
@@ -491,63 +491,63 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 				p = obj.Appendp(ctxt, p)
 
 				p.As = AMOVW
-				p.From.Type_ = D_OREG
+				p.From.Type = D_OREG
 				p.From.Reg = REGG
 				p.From.Offset = 4 * int64(ctxt.Arch.Ptrsize) // G.panic
-				p.To.Type_ = D_REG
+				p.To.Type = D_REG
 				p.To.Reg = 1
 
 				p = obj.Appendp(ctxt, p)
 				p.As = ACMP
-				p.From.Type_ = D_CONST
+				p.From.Type = D_CONST
 				p.From.Offset = 0
 				p.Reg = 1
 
 				p = obj.Appendp(ctxt, p)
 				p.As = ABEQ
-				p.To.Type_ = D_BRANCH
+				p.To.Type = D_BRANCH
 				p1 = p
 
 				p = obj.Appendp(ctxt, p)
 				p.As = AMOVW
-				p.From.Type_ = D_OREG
+				p.From.Type = D_OREG
 				p.From.Reg = 1
 				p.From.Offset = 0 // Panic.argp
-				p.To.Type_ = D_REG
+				p.To.Type = D_REG
 				p.To.Reg = 2
 
 				p = obj.Appendp(ctxt, p)
 				p.As = AADD
-				p.From.Type_ = D_CONST
+				p.From.Type = D_CONST
 				p.From.Offset = int64(autosize) + 4
 				p.Reg = 13
-				p.To.Type_ = D_REG
+				p.To.Type = D_REG
 				p.To.Reg = 3
 
 				p = obj.Appendp(ctxt, p)
 				p.As = ACMP
-				p.From.Type_ = D_REG
+				p.From.Type = D_REG
 				p.From.Reg = 2
 				p.Reg = 3
 
 				p = obj.Appendp(ctxt, p)
 				p.As = ABNE
-				p.To.Type_ = D_BRANCH
+				p.To.Type = D_BRANCH
 				p2 = p
 
 				p = obj.Appendp(ctxt, p)
 				p.As = AADD
-				p.From.Type_ = D_CONST
+				p.From.Type = D_CONST
 				p.From.Offset = 4
 				p.Reg = 13
-				p.To.Type_ = D_REG
+				p.To.Type = D_REG
 				p.To.Reg = 4
 
 				p = obj.Appendp(ctxt, p)
 				p.As = AMOVW
-				p.From.Type_ = D_REG
+				p.From.Type = D_REG
 				p.From.Reg = 4
-				p.To.Type_ = D_OREG
+				p.To.Type = D_OREG
 				p.To.Reg = 1
 				p.To.Offset = 0 // Panic.argp
 
@@ -565,10 +565,10 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 					p.As = AB
 					p.From = zprg5.From
 					if p.To.Sym != nil { // retjmp
-						p.To.Type_ = D_BRANCH
+						p.To.Type = D_BRANCH
 					} else {
 
-						p.To.Type_ = D_OREG
+						p.To.Type = D_OREG
 						p.To.Offset = 0
 						p.To.Reg = REGLINK
 					}
@@ -579,10 +579,10 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 
 			p.As = AMOVW
 			p.Scond |= C_PBIT
-			p.From.Type_ = D_OREG
+			p.From.Type = D_OREG
 			p.From.Offset = int64(autosize)
 			p.From.Reg = REGSP
-			p.To.Type_ = D_REG
+			p.To.Type = D_REG
 			p.To.Reg = REGPC
 
 			// If there are instructions following
@@ -592,19 +592,19 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 				p.To.Reg = REGLINK
 				q2 = obj.Appendp(ctxt, p)
 				q2.As = AB
-				q2.To.Type_ = D_BRANCH
+				q2.To.Type = D_BRANCH
 				q2.To.Sym = p.To.Sym
 				p.To.Sym = nil
 				p = q2
 			}
 
 		case AADD:
-			if p.From.Type_ == D_CONST && p.From.Reg == NREG && p.To.Type_ == D_REG && p.To.Reg == REGSP {
+			if p.From.Type == D_CONST && p.From.Reg == NREG && p.To.Type == D_REG && p.To.Reg == REGSP {
 				p.Spadj = int32(-p.From.Offset)
 			}
 
 		case ASUB:
-			if p.From.Type_ == D_CONST && p.From.Reg == NREG && p.To.Type_ == D_REG && p.To.Reg == REGSP {
+			if p.From.Type == D_CONST && p.From.Reg == NREG && p.To.Type == D_REG && p.To.Reg == REGSP {
 				p.Spadj = int32(p.From.Offset)
 			}
 
@@ -615,10 +615,10 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 			if ctxt.Debugdivmod != 0 {
 				break
 			}
-			if p.From.Type_ != D_REG {
+			if p.From.Type != D_REG {
 				break
 			}
-			if p.To.Type_ != D_REG {
+			if p.To.Type != D_REG {
 				break
 			}
 			q1 = p
@@ -628,9 +628,9 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 
 			p.As = AMOVW
 			p.Lineno = q1.Lineno
-			p.From.Type_ = D_REG
+			p.From.Type = D_REG
 			p.From.Reg = q1.From.Reg
-			p.To.Type_ = D_OREG
+			p.To.Type = D_OREG
 			p.To.Reg = REGSP
 			p.To.Offset = 4
 
@@ -639,12 +639,12 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 
 			p.As = AMOVW
 			p.Lineno = q1.Lineno
-			p.From.Type_ = D_REG
+			p.From.Type = D_REG
 			p.From.Reg = int8(q1.Reg)
 			if q1.Reg == NREG {
 				p.From.Reg = q1.To.Reg
 			}
-			p.To.Type_ = D_REG
+			p.To.Type = D_REG
 			p.To.Reg = REGTMP
 			p.To.Offset = 0
 
@@ -653,7 +653,7 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 
 			p.As = ABL
 			p.Lineno = q1.Lineno
-			p.To.Type_ = D_BRANCH
+			p.To.Type = D_BRANCH
 			switch o {
 			case ADIV:
 				p.To.Sym = ctxt.Sym_div
@@ -674,10 +674,10 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 
 			p.As = AMOVW
 			p.Lineno = q1.Lineno
-			p.From.Type_ = D_REG
+			p.From.Type = D_REG
 			p.From.Reg = REGTMP
 			p.From.Offset = 0
-			p.To.Type_ = D_REG
+			p.To.Type = D_REG
 			p.To.Reg = q1.To.Reg
 
 			/* ADD $8,SP */
@@ -685,11 +685,11 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 
 			p.As = AADD
 			p.Lineno = q1.Lineno
-			p.From.Type_ = D_CONST
+			p.From.Type = D_CONST
 			p.From.Reg = NREG
 			p.From.Offset = 8
 			p.Reg = NREG
-			p.To.Type_ = D_REG
+			p.To.Type = D_REG
 			p.To.Reg = REGSP
 			p.Spadj = -8
 
@@ -698,34 +698,34 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 			/* TODO: Remove SP adjustments; see issue 6699. */
 			q1.As = AMOVW
 
-			q1.From.Type_ = D_OREG
+			q1.From.Type = D_OREG
 			q1.From.Reg = REGSP
 			q1.From.Offset = 0
 			q1.Reg = NREG
-			q1.To.Type_ = D_REG
+			q1.To.Type = D_REG
 			q1.To.Reg = REGTMP
 
 			/* SUB $8,SP */
 			q1 = obj.Appendp(ctxt, q1)
 
 			q1.As = AMOVW
-			q1.From.Type_ = D_REG
+			q1.From.Type = D_REG
 			q1.From.Reg = REGTMP
 			q1.Reg = NREG
-			q1.To.Type_ = D_OREG
+			q1.To.Type = D_OREG
 			q1.To.Reg = REGSP
 			q1.To.Offset = -8
 			q1.Scond |= C_WBIT
 			q1.Spadj = 8
 
 		case AMOVW:
-			if (p.Scond&C_WBIT != 0) && p.To.Type_ == D_OREG && p.To.Reg == REGSP {
+			if (p.Scond&C_WBIT != 0) && p.To.Type == D_OREG && p.To.Reg == REGSP {
 				p.Spadj = int32(-p.To.Offset)
 			}
-			if (p.Scond&C_PBIT != 0) && p.From.Type_ == D_OREG && p.From.Reg == REGSP && p.To.Reg != REGPC {
+			if (p.Scond&C_PBIT != 0) && p.From.Type == D_OREG && p.From.Reg == REGSP && p.To.Reg != REGPC {
 				p.Spadj = int32(-p.From.Offset)
 			}
-			if p.From.Type_ == D_CONST && p.From.Reg == REGSP && p.To.Type_ == D_REG && p.To.Reg == REGSP {
+			if p.From.Type == D_CONST && p.From.Reg == REGSP && p.To.Type == D_REG && p.To.Reg == REGSP {
 				p.Spadj = int32(-p.From.Offset)
 			}
 			break
@@ -754,7 +754,7 @@ func softfloat(ctxt *obj.Link, cursym *obj.LSym) {
 	for p = cursym.Text; p != nil; p = p.Link {
 		switch p.As {
 		case AMOVW:
-			if p.To.Type_ == D_FREG || p.From.Type_ == D_FREG {
+			if p.To.Type == D_FREG || p.From.Type == D_FREG {
 				goto soft
 			}
 			goto notsoft
@@ -797,7 +797,7 @@ func softfloat(ctxt *obj.Link, cursym *obj.LSym) {
 
 			p.Link = next
 			p.As = ABL
-			p.To.Type_ = D_BRANCH
+			p.To.Type = D_BRANCH
 			p.To.Sym = symsfloat
 			p.Lineno = next.Lineno
 
@@ -817,13 +817,13 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int) *obj.P
 	p = obj.Appendp(ctxt, p)
 
 	p.As = AMOVW
-	p.From.Type_ = D_OREG
+	p.From.Type = D_OREG
 	p.From.Reg = REGG
 	p.From.Offset = 2 * int64(ctxt.Arch.Ptrsize) // G.stackguard0
 	if ctxt.Cursym.Cfunc != 0 {
 		p.From.Offset = 3 * int64(ctxt.Arch.Ptrsize) // G.stackguard1
 	}
-	p.To.Type_ = D_REG
+	p.To.Type = D_REG
 	p.To.Reg = 1
 
 	if framesize <= obj.StackSmall {
@@ -832,7 +832,7 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int) *obj.P
 		p = obj.Appendp(ctxt, p)
 
 		p.As = ACMP
-		p.From.Type_ = D_REG
+		p.From.Type = D_REG
 		p.From.Reg = 1
 		p.Reg = REGSP
 	} else if framesize <= obj.StackBig {
@@ -842,15 +842,15 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int) *obj.P
 		p = obj.Appendp(ctxt, p)
 
 		p.As = AMOVW
-		p.From.Type_ = D_CONST
+		p.From.Type = D_CONST
 		p.From.Reg = REGSP
 		p.From.Offset = int64(-framesize)
-		p.To.Type_ = D_REG
+		p.To.Type = D_REG
 		p.To.Reg = 2
 
 		p = obj.Appendp(ctxt, p)
 		p.As = ACMP
-		p.From.Type_ = D_REG
+		p.From.Type = D_REG
 		p.From.Reg = 1
 		p.Reg = 2
 	} else {
@@ -868,38 +868,38 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int) *obj.P
 		p = obj.Appendp(ctxt, p)
 
 		p.As = ACMP
-		p.From.Type_ = D_CONST
+		p.From.Type = D_CONST
 		p.From.Offset = int64(uint32(obj.StackPreempt & (1<<32 - 1)))
 		p.Reg = 1
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AMOVW
-		p.From.Type_ = D_CONST
+		p.From.Type = D_CONST
 		p.From.Reg = REGSP
 		p.From.Offset = obj.StackGuard
-		p.To.Type_ = D_REG
+		p.To.Type = D_REG
 		p.To.Reg = 2
 		p.Scond = C_SCOND_NE
 
 		p = obj.Appendp(ctxt, p)
 		p.As = ASUB
-		p.From.Type_ = D_REG
+		p.From.Type = D_REG
 		p.From.Reg = 1
-		p.To.Type_ = D_REG
+		p.To.Type = D_REG
 		p.To.Reg = 2
 		p.Scond = C_SCOND_NE
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AMOVW
-		p.From.Type_ = D_CONST
+		p.From.Type = D_CONST
 		p.From.Offset = int64(framesize) + (obj.StackGuard - obj.StackSmall)
-		p.To.Type_ = D_REG
+		p.To.Type = D_REG
 		p.To.Reg = 3
 		p.Scond = C_SCOND_NE
 
 		p = obj.Appendp(ctxt, p)
 		p.As = ACMP
-		p.From.Type_ = D_REG
+		p.From.Type = D_REG
 		p.From.Reg = 3
 		p.Reg = 2
 		p.Scond = C_SCOND_NE
@@ -910,9 +910,9 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int) *obj.P
 
 	p.As = AMOVW
 	p.Scond = C_SCOND_LS
-	p.From.Type_ = D_REG
+	p.From.Type = D_REG
 	p.From.Reg = REGLINK
-	p.To.Type_ = D_REG
+	p.To.Type = D_REG
 	p.To.Reg = 3
 
 	// BL.LS		runtime.morestack(SB) // modifies LR, returns with LO still asserted
@@ -920,7 +920,7 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int) *obj.P
 
 	p.As = ABL
 	p.Scond = C_SCOND_LS
-	p.To.Type_ = D_BRANCH
+	p.To.Type = D_BRANCH
 	if ctxt.Cursym.Cfunc != 0 {
 		p.To.Sym = obj.Linklookup(ctxt, "runtime.morestackc", 0)
 	} else {
@@ -932,7 +932,7 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int) *obj.P
 	p = obj.Appendp(ctxt, p)
 
 	p.As = ABLS
-	p.To.Type_ = D_BRANCH
+	p.To.Type = D_BRANCH
 	p.Pcond = ctxt.Cursym.Text.Link
 
 	return p
@@ -997,7 +997,7 @@ func relinv(a int) int {
 		return ABGT
 	}
 
-	log.Fatalf("unknown relation: %s", anames5[a])
+	log.Fatalf("unknown relation: %s", Anames[a])
 	return 0
 }
 
@@ -1086,7 +1086,7 @@ loop:
 		q = ctxt.Arch.Prg()
 		q.As = int16(a)
 		q.Lineno = p.Lineno
-		q.To.Type_ = D_BRANCH
+		q.To.Type = D_BRANCH
 		q.To.Offset = p.Pc
 		q.Pcond = p
 		p = q
diff --git a/src/cmd/internal/obj/data.go b/src/cmd/internal/obj/data.go
index 9130e30664..35d5182db8 100644
--- a/src/cmd/internal/obj/data.go
+++ b/src/cmd/internal/obj/data.go
@@ -67,7 +67,7 @@ func savedata(ctxt *Link, s *LSym, p *Prog, pn string) {
 	}
 	Symgrow(ctxt, s, int64(off+siz))
 
-	switch int(p.To.Type_) {
+	switch int(p.To.Type) {
 	default:
 		ctxt.Diag("bad data: %P", p)
 
@@ -89,12 +89,12 @@ func savedata(ctxt *Link, s *LSym, p *Prog, pn string) {
 		copy(s.P[off:off+siz], p.To.U.Sval)
 
 	case ctxt.Arch.D_CONST, ctxt.Arch.D_ADDR:
-		if p.To.Sym != nil || int(p.To.Type_) == ctxt.Arch.D_ADDR {
+		if p.To.Sym != nil || int(p.To.Type) == ctxt.Arch.D_ADDR {
 			r := Addrel(s)
 			r.Off = off
 			r.Siz = uint8(siz)
 			r.Sym = p.To.Sym
-			r.Type_ = R_ADDR
+			r.Type = R_ADDR
 			r.Add = p.To.Offset
 			break
 		}
@@ -120,8 +120,8 @@ func Addrel(s *LSym) *Reloc {
 }
 
 func setuintxx(ctxt *Link, s *LSym, off int64, v uint64, wid int64) int64 {
-	if s.Type_ == 0 {
-		s.Type_ = SDATA
+	if s.Type == 0 {
+		s.Type = SDATA
 	}
 	s.Reachable = 1
 	if s.Size < off+wid {
@@ -187,8 +187,8 @@ func addaddrplus(ctxt *Link, s *LSym, t *LSym, add int64) int64 {
 	var i int64
 	var r *Reloc
 
-	if s.Type_ == 0 {
-		s.Type_ = SDATA
+	if s.Type == 0 {
+		s.Type = SDATA
 	}
 	s.Reachable = 1
 	i = s.Size
@@ -198,7 +198,7 @@ func addaddrplus(ctxt *Link, s *LSym, t *LSym, add int64) int64 {
 	r.Sym = t
 	r.Off = int32(i)
 	r.Siz = uint8(ctxt.Arch.Ptrsize)
-	r.Type_ = R_ADDR
+	r.Type = R_ADDR
 	r.Add = add
 	return i + int64(r.Siz)
 }
@@ -207,8 +207,8 @@ func addpcrelplus(ctxt *Link, s *LSym, t *LSym, add int64) int64 {
 	var i int64
 	var r *Reloc
 
-	if s.Type_ == 0 {
-		s.Type_ = SDATA
+	if s.Type == 0 {
+		s.Type = SDATA
 	}
 	s.Reachable = 1
 	i = s.Size
@@ -218,7 +218,7 @@ func addpcrelplus(ctxt *Link, s *LSym, t *LSym, add int64) int64 {
 	r.Sym = t
 	r.Off = int32(i)
 	r.Add = add
-	r.Type_ = R_PCREL
+	r.Type = R_PCREL
 	r.Siz = 4
 	return i + int64(r.Siz)
 }
@@ -230,8 +230,8 @@ func addaddr(ctxt *Link, s *LSym, t *LSym) int64 {
 func setaddrplus(ctxt *Link, s *LSym, off int64, t *LSym, add int64) int64 {
 	var r *Reloc
 
-	if s.Type_ == 0 {
-		s.Type_ = SDATA
+	if s.Type == 0 {
+		s.Type = SDATA
 	}
 	s.Reachable = 1
 	if off+int64(ctxt.Arch.Ptrsize) > s.Size {
@@ -243,7 +243,7 @@ func setaddrplus(ctxt *Link, s *LSym, off int64, t *LSym, add int64) int64 {
 	r.Sym = t
 	r.Off = int32(off)
 	r.Siz = uint8(ctxt.Arch.Ptrsize)
-	r.Type_ = R_ADDR
+	r.Type = R_ADDR
 	r.Add = add
 	return off + int64(r.Siz)
 }
@@ -256,8 +256,8 @@ func addsize(ctxt *Link, s *LSym, t *LSym) int64 {
 	var i int64
 	var r *Reloc
 
-	if s.Type_ == 0 {
-		s.Type_ = SDATA
+	if s.Type == 0 {
+		s.Type = SDATA
 	}
 	s.Reachable = 1
 	i = s.Size
@@ -267,7 +267,7 @@ func addsize(ctxt *Link, s *LSym, t *LSym) int64 {
 	r.Sym = t
 	r.Off = int32(i)
 	r.Siz = uint8(ctxt.Arch.Ptrsize)
-	r.Type_ = R_SIZE
+	r.Type = R_SIZE
 	return i + int64(r.Siz)
 }
 
@@ -275,8 +275,8 @@ func addaddrplus4(ctxt *Link, s *LSym, t *LSym, add int64) int64 {
 	var i int64
 	var r *Reloc
 
-	if s.Type_ == 0 {
-		s.Type_ = SDATA
+	if s.Type == 0 {
+		s.Type = SDATA
 	}
 	s.Reachable = 1
 	i = s.Size
@@ -286,7 +286,7 @@ func addaddrplus4(ctxt *Link, s *LSym, t *LSym, add int64) int64 {
 	r.Sym = t
 	r.Off = int32(i)
 	r.Siz = 4
-	r.Type_ = R_ADDR
+	r.Type = R_ADDR
 	r.Add = add
 	return i + int64(r.Siz)
 }
diff --git a/src/cmd/internal/obj/i386/anames8.go b/src/cmd/internal/obj/i386/anames8.go
index 7815abb433..dd6103641f 100644
--- a/src/cmd/internal/obj/i386/anames8.go
+++ b/src/cmd/internal/obj/i386/anames8.go
@@ -3,7 +3,7 @@ package i386
 /*
  * this is the ranlib header
  */
-var anames8 = []string{
+var Anames = []string{
 	"XXX",
 	"AAA",
 	"AAD",
diff --git a/src/cmd/internal/obj/i386/asm8.go b/src/cmd/internal/obj/i386/asm8.go
index d23f3ba7e2..2c3c637e5f 100644
--- a/src/cmd/internal/obj/i386/asm8.go
+++ b/src/cmd/internal/obj/i386/asm8.go
@@ -1709,7 +1709,7 @@ func span8(ctxt *obj.Link, s *obj.LSym) {
 
 	for p = s.Text; p != nil; p = p.Link {
 		n = 0
-		if p.To.Type_ == D_BRANCH {
+		if p.To.Type == D_BRANCH {
 			if p.Pcond == nil {
 				p.Pcond = p
 			}
@@ -1722,7 +1722,7 @@ func span8(ctxt *obj.Link, s *obj.LSym) {
 		}
 		p.Back = uint8(n)
 		if p.As == AADJSP {
-			p.To.Type_ = D_SP
+			p.To.Type = D_SP
 			v = int32(-p.From.Offset)
 			p.From.Offset = int64(v)
 			p.As = AADDL
@@ -1747,7 +1747,7 @@ func span8(ctxt *obj.Link, s *obj.LSym) {
 
 		if p.As == AADJSP {
 
-			p.To.Type_ = D_SP
+			p.To.Type = D_SP
 			v = int32(-p.From.Offset)
 			p.From.Offset = int64(v)
 			p.As = AADDL
@@ -1980,7 +1980,7 @@ func instinit() {
 }
 
 func prefixof(ctxt *obj.Link, a *obj.Addr) int {
-	switch a.Type_ {
+	switch a.Type {
 	case D_INDIR + D_CS:
 		return 0x2e
 
@@ -2023,9 +2023,9 @@ func prefixof(ctxt *obj.Link, a *obj.Addr) int {
 func oclass(a *obj.Addr) int {
 	var v int32
 
-	if (a.Type_ >= D_INDIR && a.Type_ < 2*D_INDIR) || a.Index != D_NONE {
+	if (a.Type >= D_INDIR && a.Type < 2*D_INDIR) || a.Index != D_NONE {
 		if a.Index != D_NONE && a.Scale == 0 {
-			if a.Type_ == D_ADDR {
+			if a.Type == D_ADDR {
 				switch a.Index {
 				case D_EXTERN,
 					D_STATIC:
@@ -2047,7 +2047,7 @@ func oclass(a *obj.Addr) int {
 		return Ym
 	}
 
-	switch a.Type_ {
+	switch a.Type {
 	case D_AL:
 		return Yal
 
@@ -2315,7 +2315,7 @@ func vaddr(ctxt *obj.Link, p *obj.Prog, a *obj.Addr, r *obj.Reloc) int32 {
 		*r = obj.Reloc{}
 	}
 
-	t = int(a.Type_)
+	t = int(a.Type)
 	v = int32(a.Offset)
 	if t == D_ADDR {
 		t = int(a.Index)
@@ -2330,7 +2330,7 @@ func vaddr(ctxt *obj.Link, p *obj.Prog, a *obj.Addr, r *obj.Reloc) int32 {
 				log.Fatalf("bad code")
 			}
 
-			r.Type_ = obj.R_ADDR
+			r.Type = obj.R_ADDR
 			r.Siz = 4
 			r.Off = -1
 			r.Sym = s
@@ -2344,7 +2344,7 @@ func vaddr(ctxt *obj.Link, p *obj.Prog, a *obj.Addr, r *obj.Reloc) int32 {
 			log.Fatalf("bad code")
 		}
 
-		r.Type_ = obj.R_TLS_LE
+		r.Type = obj.R_TLS_LE
 		r.Siz = 4
 		r.Off = -1 // caller must fill in
 		r.Add = int64(v)
@@ -2362,7 +2362,7 @@ func asmand(ctxt *obj.Link, p *obj.Prog, a *obj.Addr, r int) {
 	var rel obj.Reloc
 
 	v = int32(a.Offset)
-	t = int(a.Type_)
+	t = int(a.Type)
 	rel.Siz = 0
 	if a.Index != D_NONE && a.Index != D_TLS {
 		if t < D_INDIR || t >= 2*D_INDIR {
@@ -2425,7 +2425,7 @@ func asmand(ctxt *obj.Link, p *obj.Prog, a *obj.Addr, r int) {
 
 	scale = int(a.Scale)
 	if t < D_INDIR || t >= 2*D_INDIR {
-		switch a.Type_ {
+		switch a.Type {
 		default:
 			goto bad
 
@@ -2481,7 +2481,7 @@ func asmand(ctxt *obj.Link, p *obj.Prog, a *obj.Addr, r int) {
 	if t >= D_AX && t <= D_DI {
 		if a.Index == D_TLS {
 			rel = obj.Reloc{}
-			rel.Type_ = obj.R_TLS_IE
+			rel.Type = obj.R_TLS_IE
 			rel.Siz = 4
 			rel.Sym = nil
 			rel.Add = int64(v)
@@ -3133,7 +3133,7 @@ func byteswapreg(ctxt *obj.Link, a *obj.Addr) int {
 	canb = canc
 	cana = canb
 
-	switch a.Type_ {
+	switch a.Type {
 	case D_NONE:
 		cand = 0
 		cana = cand
@@ -3202,13 +3202,13 @@ func subreg(p *obj.Prog, from int, to int) {
 		fmt.Printf("\n%v\ts/%v/%v/\n", p, Rconv(from), Rconv(to))
 	}
 
-	if int(p.From.Type_) == from {
-		p.From.Type_ = int16(to)
+	if int(p.From.Type) == from {
+		p.From.Type = int16(to)
 		p.Ft = 0
 	}
 
-	if int(p.To.Type_) == from {
-		p.To.Type_ = int16(to)
+	if int(p.To.Type) == from {
+		p.To.Type = int16(to)
 		p.Tt = 0
 	}
 
@@ -3223,13 +3223,13 @@ func subreg(p *obj.Prog, from int, to int) {
 	}
 
 	from += D_INDIR
-	if int(p.From.Type_) == from {
-		p.From.Type_ = int16(to + D_INDIR)
+	if int(p.From.Type) == from {
+		p.From.Type = int16(to + D_INDIR)
 		p.Ft = 0
 	}
 
-	if int(p.To.Type_) == from {
-		p.To.Type_ = int16(to + D_INDIR)
+	if int(p.To.Type) == from {
+		p.To.Type = int16(to + D_INDIR)
 		p.Tt = 0
 	}
 
@@ -3382,27 +3382,27 @@ found:
 			ctxt.Andptr[0] = byte(op)
 			ctxt.Andptr = ctxt.Andptr[1:]
 		}
-		asmand(ctxt, p, &p.From, reg[p.To.Type_])
+		asmand(ctxt, p, &p.From, reg[p.To.Type])
 
 	case Zm_r:
 		ctxt.Andptr[0] = byte(op)
 		ctxt.Andptr = ctxt.Andptr[1:]
-		asmand(ctxt, p, &p.From, reg[p.To.Type_])
+		asmand(ctxt, p, &p.From, reg[p.To.Type])
 
 	case Zm2_r:
 		ctxt.Andptr[0] = byte(op)
 		ctxt.Andptr = ctxt.Andptr[1:]
 		ctxt.Andptr[0] = byte(o.op[z+1])
 		ctxt.Andptr = ctxt.Andptr[1:]
-		asmand(ctxt, p, &p.From, reg[p.To.Type_])
+		asmand(ctxt, p, &p.From, reg[p.To.Type])
 
 	case Zm_r_xm:
 		mediaop(ctxt, o, op, int(t[3]), z)
-		asmand(ctxt, p, &p.From, reg[p.To.Type_])
+		asmand(ctxt, p, &p.From, reg[p.To.Type])
 
 	case Zm_r_i_xm:
 		mediaop(ctxt, o, op, int(t[3]), z)
-		asmand(ctxt, p, &p.From, reg[p.To.Type_])
+		asmand(ctxt, p, &p.From, reg[p.To.Type])
 		ctxt.Andptr[0] = byte(p.To.Offset)
 		ctxt.Andptr = ctxt.Andptr[1:]
 
@@ -3417,22 +3417,22 @@ found:
 			ctxt.Andptr[0] = byte(op)
 			ctxt.Andptr = ctxt.Andptr[1:]
 		}
-		asmand(ctxt, p, &p.From, reg[p.To.Type_])
+		asmand(ctxt, p, &p.From, reg[p.To.Type])
 		ctxt.Andptr[0] = byte(p.To.Offset)
 		ctxt.Andptr = ctxt.Andptr[1:]
 
 	case Zaut_r:
 		ctxt.Andptr[0] = 0x8d
 		ctxt.Andptr = ctxt.Andptr[1:] /* leal */
-		if p.From.Type_ != D_ADDR {
+		if p.From.Type != D_ADDR {
 			ctxt.Diag("asmins: Zaut sb type ADDR")
 		}
-		p.From.Type_ = int16(p.From.Index)
+		p.From.Type = int16(p.From.Index)
 		p.From.Index = D_NONE
 		p.Ft = 0
-		asmand(ctxt, p, &p.From, reg[p.To.Type_])
-		p.From.Index = uint8(p.From.Type_)
-		p.From.Type_ = D_ADDR
+		asmand(ctxt, p, &p.From, reg[p.To.Type])
+		p.From.Index = uint8(p.From.Type)
+		p.From.Type = D_ADDR
 		p.Ft = 0
 
 	case Zm_o:
@@ -3443,22 +3443,22 @@ found:
 	case Zr_m:
 		ctxt.Andptr[0] = byte(op)
 		ctxt.Andptr = ctxt.Andptr[1:]
-		asmand(ctxt, p, &p.To, reg[p.From.Type_])
+		asmand(ctxt, p, &p.To, reg[p.From.Type])
 
 	case Zr_m_xm:
 		mediaop(ctxt, o, op, int(t[3]), z)
-		asmand(ctxt, p, &p.To, reg[p.From.Type_])
+		asmand(ctxt, p, &p.To, reg[p.From.Type])
 
 	case Zr_m_i_xm:
 		mediaop(ctxt, o, op, int(t[3]), z)
-		asmand(ctxt, p, &p.To, reg[p.From.Type_])
+		asmand(ctxt, p, &p.To, reg[p.From.Type])
 		ctxt.Andptr[0] = byte(p.From.Offset)
 		ctxt.Andptr = ctxt.Andptr[1:]
 
 	case Zcallindreg:
 		r = obj.Addrel(ctxt.Cursym)
 		r.Off = int32(p.Pc)
-		r.Type_ = obj.R_CALLIND
+		r.Type = obj.R_CALLIND
 		r.Siz = 0
 		fallthrough
 
@@ -3498,13 +3498,13 @@ found:
 		ctxt.Andptr = ctxt.Andptr[1:]
 
 	case Zib_rp:
-		ctxt.Andptr[0] = byte(op + reg[p.To.Type_])
+		ctxt.Andptr[0] = byte(op + reg[p.To.Type])
 		ctxt.Andptr = ctxt.Andptr[1:]
 		ctxt.Andptr[0] = byte(vaddr(ctxt, p, &p.From, nil))
 		ctxt.Andptr = ctxt.Andptr[1:]
 
 	case Zil_rp:
-		ctxt.Andptr[0] = byte(op + reg[p.To.Type_])
+		ctxt.Andptr[0] = byte(op + reg[p.To.Type])
 		ctxt.Andptr = ctxt.Andptr[1:]
 		if o.prefix == Pe {
 			v = vaddr(ctxt, p, &p.From, nil)
@@ -3520,7 +3520,7 @@ found:
 	case Zib_rr:
 		ctxt.Andptr[0] = byte(op)
 		ctxt.Andptr = ctxt.Andptr[1:]
-		asmand(ctxt, p, &p.To, reg[p.To.Type_])
+		asmand(ctxt, p, &p.To, reg[p.To.Type])
 		ctxt.Andptr[0] = byte(vaddr(ctxt, p, &p.From, nil))
 		ctxt.Andptr = ctxt.Andptr[1:]
 
@@ -3572,7 +3572,7 @@ found:
 	case Zil_rr:
 		ctxt.Andptr[0] = byte(op)
 		ctxt.Andptr = ctxt.Andptr[1:]
-		asmand(ctxt, p, &p.To, reg[p.To.Type_])
+		asmand(ctxt, p, &p.To, reg[p.To.Type])
 		if o.prefix == Pe {
 			v = vaddr(ctxt, p, &p.From, nil)
 			ctxt.Andptr[0] = byte(v)
@@ -3585,17 +3585,17 @@ found:
 		}
 
 	case Z_rp:
-		ctxt.Andptr[0] = byte(op + reg[p.To.Type_])
+		ctxt.Andptr[0] = byte(op + reg[p.To.Type])
 		ctxt.Andptr = ctxt.Andptr[1:]
 
 	case Zrp_:
-		ctxt.Andptr[0] = byte(op + reg[p.From.Type_])
+		ctxt.Andptr[0] = byte(op + reg[p.From.Type])
 		ctxt.Andptr = ctxt.Andptr[1:]
 
 	case Zclr:
 		ctxt.Andptr[0] = byte(op)
 		ctxt.Andptr = ctxt.Andptr[1:]
-		asmand(ctxt, p, &p.To, reg[p.To.Type_])
+		asmand(ctxt, p, &p.To, reg[p.To.Type])
 
 	case Zcall:
 		if p.To.Sym == nil {
@@ -3607,7 +3607,7 @@ found:
 		ctxt.Andptr = ctxt.Andptr[1:]
 		r = obj.Addrel(ctxt.Cursym)
 		r.Off = int32(p.Pc + int64(-cap(ctxt.Andptr)+cap(ctxt.And[:])))
-		r.Type_ = obj.R_CALL
+		r.Type = obj.R_CALL
 		r.Siz = 4
 		r.Sym = p.To.Sym
 		r.Add = p.To.Offset
@@ -3627,7 +3627,7 @@ found:
 			r = obj.Addrel(ctxt.Cursym)
 			r.Off = int32(p.Pc + int64(-cap(ctxt.Andptr)+cap(ctxt.And[:])))
 			r.Sym = p.To.Sym
-			r.Type_ = obj.R_PCREL
+			r.Type = obj.R_PCREL
 			r.Siz = 4
 			put4(ctxt, 0)
 			break
@@ -3724,7 +3724,7 @@ found:
 		}
 		r = obj.Addrel(ctxt.Cursym)
 		r.Off = int32(p.Pc + int64(-cap(ctxt.Andptr)+cap(ctxt.And[:])))
-		r.Type_ = obj.R_PCREL
+		r.Type = obj.R_PCREL
 		r.Siz = 4
 		r.Add = p.To.Offset
 		put4(ctxt, 0)
@@ -3736,7 +3736,7 @@ found:
 		ctxt.Andptr = ctxt.Andptr[1:]
 		r = obj.Addrel(ctxt.Cursym)
 		r.Off = int32(p.Pc + int64(-cap(ctxt.Andptr)+cap(ctxt.And[:])))
-		r.Type_ = obj.R_ADDR
+		r.Type = obj.R_ADDR
 		r.Siz = 4
 		r.Add = p.To.Offset
 		r.Sym = p.To.Sym
@@ -3791,7 +3791,7 @@ domov:
 bad:
 	pp = *p
 
-	z = int(p.From.Type_)
+	z = int(p.From.Type)
 	if z >= D_BP && z <= D_DI {
 		breg = byteswapreg(ctxt, &p.To)
 		if breg != D_AX {
@@ -3816,7 +3816,7 @@ bad:
 		return
 	}
 
-	z = int(p.To.Type_)
+	z = int(p.To.Type)
 	if z >= D_BP && z <= D_DI {
 		breg = byteswapreg(ctxt, &p.From)
 		if breg != D_AX {
@@ -3841,7 +3841,7 @@ bad:
 		return
 	}
 
-	ctxt.Diag("doasm: notfound t2=%x from=%x to=%x %v", t[2], uint16(p.From.Type_), uint16(p.To.Type_), p)
+	ctxt.Diag("doasm: notfound t2=%x from=%x to=%x %v", t[2], uint16(p.From.Type), uint16(p.To.Type), p)
 	return
 
 mfound:
@@ -3922,10 +3922,10 @@ mfound:
 			break
 		}
 
-		asmand(ctxt, p, &p.From, reg[p.To.Type_])
+		asmand(ctxt, p, &p.From, reg[p.To.Type])
 
 	case 6: /* double shift */
-		z = int(p.From.Type_)
+		z = int(p.From.Type)
 
 		switch z {
 		default:
@@ -3964,7 +3964,7 @@ mfound:
 		}
 		ctxt.Andptr[0] = t[5]
 		ctxt.Andptr = ctxt.Andptr[1:]
-		asmand(ctxt, p, &p.From, reg[p.To.Type_])
+		asmand(ctxt, p, &p.From, reg[p.To.Type])
 
 		// NOTE: The systems listed here are the ones that use the "TLS initial exec" model,
 	// where you load the TLS base register into a register and then index off that
@@ -3981,7 +3981,7 @@ mfound:
 			obj.Hnacl:
 			pp.From = p.From
 
-			pp.From.Type_ = D_INDIR + D_GS
+			pp.From.Type = D_INDIR + D_GS
 			pp.From.Offset = 0
 			pp.From.Index = D_NONE
 			pp.From.Scale = 0
@@ -3989,26 +3989,26 @@ mfound:
 			ctxt.Andptr = ctxt.Andptr[1:] // GS
 			ctxt.Andptr[0] = 0x8B
 			ctxt.Andptr = ctxt.Andptr[1:]
-			asmand(ctxt, p, &pp.From, reg[p.To.Type_])
+			asmand(ctxt, p, &pp.From, reg[p.To.Type])
 
 		case obj.Hplan9:
 			if ctxt.Plan9privates == nil {
 				ctxt.Plan9privates = obj.Linklookup(ctxt, "_privates", 0)
 			}
 			pp.From = obj.Addr{}
-			pp.From.Type_ = D_EXTERN
+			pp.From.Type = D_EXTERN
 			pp.From.Sym = ctxt.Plan9privates
 			pp.From.Offset = 0
 			pp.From.Index = D_NONE
 			ctxt.Andptr[0] = 0x8B
 			ctxt.Andptr = ctxt.Andptr[1:]
-			asmand(ctxt, p, &pp.From, reg[p.To.Type_])
+			asmand(ctxt, p, &pp.From, reg[p.To.Type])
 
 			// Windows TLS base is always 0x14(FS).
 		case obj.Hwindows:
 			pp.From = p.From
 
-			pp.From.Type_ = D_INDIR + D_FS
+			pp.From.Type = D_INDIR + D_FS
 			pp.From.Offset = 0x14
 			pp.From.Index = D_NONE
 			pp.From.Scale = 0
@@ -4016,7 +4016,7 @@ mfound:
 			ctxt.Andptr = ctxt.Andptr[1:] // FS
 			ctxt.Andptr[0] = 0x8B
 			ctxt.Andptr = ctxt.Andptr[1:]
-			asmand(ctxt, p, &pp.From, reg[p.To.Type_])
+			asmand(ctxt, p, &pp.From, reg[p.To.Type])
 			break
 		}
 
@@ -4043,7 +4043,7 @@ func asmins(ctxt *obj.Link, p *obj.Prog) {
 		r = obj.Addrel(ctxt.Cursym)
 		r.Off = 0
 		r.Sym = p.From.Sym
-		r.Type_ = obj.R_USEFIELD
+		r.Type = obj.R_USEFIELD
 		r.Siz = 0
 		return
 	}
@@ -4057,10 +4057,10 @@ func asmins(ctxt *obj.Link, p *obj.Prog) {
 
 		case ACALL,
 			AJMP:
-			if D_AX <= p.To.Type_ && p.To.Type_ <= D_DI {
+			if D_AX <= p.To.Type && p.To.Type <= D_DI {
 				ctxt.Andptr[0] = 0x83
 				ctxt.Andptr = ctxt.Andptr[1:]
-				ctxt.Andptr[0] = byte(0xe0 | (p.To.Type_ - D_AX))
+				ctxt.Andptr[0] = byte(0xe0 | (p.To.Type - D_AX))
 				ctxt.Andptr = ctxt.Andptr[1:]
 				ctxt.Andptr[0] = 0xe0
 				ctxt.Andptr = ctxt.Andptr[1:]
diff --git a/src/cmd/internal/obj/i386/list8.go b/src/cmd/internal/obj/i386/list8.go
index 07083c06b8..5a55890582 100644
--- a/src/cmd/internal/obj/i386/list8.go
+++ b/src/cmd/internal/obj/i386/list8.go
@@ -69,7 +69,7 @@ func Pconv(p *obj.Prog) string {
 func Aconv(i int) string {
 	var fp string
 
-	fp += anames8[i]
+	fp += Anames[i]
 	return fp
 }
 
@@ -80,7 +80,7 @@ func Dconv(p *obj.Prog, flag int, a *obj.Addr) string {
 
 	var i int
 
-	i = int(a.Type_)
+	i = int(a.Type)
 
 	if flag&fmtLong != 0 /*untyped*/ {
 		if i == D_CONST2 {
@@ -166,11 +166,11 @@ func Dconv(p *obj.Prog, flag int, a *obj.Addr) string {
 		str = fmt.Sprintf("$\"%q\"", a.U.Sval)
 
 	case D_ADDR:
-		a.Type_ = int16(a.Index)
+		a.Type = int16(a.Index)
 		a.Index = D_NONE
 		str = fmt.Sprintf("$%v", Dconv(p, 0, a))
-		a.Index = uint8(a.Type_)
-		a.Type_ = D_ADDR
+		a.Index = uint8(a.Type)
+		a.Type = D_ADDR
 		goto conv
 	}
 
@@ -185,7 +185,7 @@ conv:
 	return fp
 }
 
-var regstr = []string{
+var Register = []string{
 	"AL", /* [D_AL] */
 	"CL",
 	"DL",
@@ -262,7 +262,7 @@ func Rconv(r int) string {
 	var fp string
 
 	if r >= D_AL && r <= D_NONE {
-		str = fmt.Sprintf("%s", regstr[r-D_AL])
+		str = fmt.Sprintf("%s", Register[r-D_AL])
 	} else {
 
 		str = fmt.Sprintf("gok(%d)", r)
diff --git a/src/cmd/internal/obj/i386/obj8.go b/src/cmd/internal/obj/i386/obj8.go
index 8089f14247..1cf5510eea 100644
--- a/src/cmd/internal/obj/i386/obj8.go
+++ b/src/cmd/internal/obj/i386/obj8.go
@@ -42,12 +42,12 @@ var zprg = obj.Prog{
 	Back: 2,
 	As:   AGOK,
 	From: obj.Addr{
-		Type_: D_NONE,
+		Type:  D_NONE,
 		Index: D_NONE,
 		Scale: 1,
 	},
 	To: obj.Addr{
-		Type_: D_NONE,
+		Type:  D_NONE,
 		Index: D_NONE,
 		Scale: 1,
 	},
@@ -56,7 +56,7 @@ var zprg = obj.Prog{
 func symtype(a *obj.Addr) int {
 	var t int
 
-	t = int(a.Type_)
+	t = int(a.Type)
 	if t == D_ADDR {
 		t = int(a.Index)
 	}
@@ -110,21 +110,21 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 		// become
 		//	NOP
 		//	... off(TLS) ...
-		if p.As == AMOVL && p.From.Type_ == D_TLS && D_AX <= p.To.Type_ && p.To.Type_ <= D_DI {
+		if p.As == AMOVL && p.From.Type == D_TLS && D_AX <= p.To.Type && p.To.Type <= D_DI {
 
 			p.As = ANOP
-			p.From.Type_ = D_NONE
-			p.To.Type_ = D_NONE
+			p.From.Type = D_NONE
+			p.To.Type = D_NONE
 		}
 
-		if p.From.Index == D_TLS && D_INDIR+D_AX <= p.From.Type_ && p.From.Type_ <= D_INDIR+D_DI {
-			p.From.Type_ = D_INDIR + D_TLS
+		if p.From.Index == D_TLS && D_INDIR+D_AX <= p.From.Type && p.From.Type <= D_INDIR+D_DI {
+			p.From.Type = D_INDIR + D_TLS
 			p.From.Scale = 0
 			p.From.Index = D_NONE
 		}
 
-		if p.To.Index == D_TLS && D_INDIR+D_AX <= p.To.Type_ && p.To.Type_ <= D_INDIR+D_DI {
-			p.To.Type_ = D_INDIR + D_TLS
+		if p.To.Index == D_TLS && D_INDIR+D_AX <= p.To.Type && p.To.Type <= D_INDIR+D_DI {
+			p.To.Type = D_INDIR + D_TLS
 			p.To.Scale = 0
 			p.To.Index = D_NONE
 		}
@@ -137,16 +137,16 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 		//	MOVL TLS, BX
 		//	MOVL off(BX)(TLS*1), BX
 		// This allows the C compilers to emit references to m and g using the direct off(TLS) form.
-		if p.As == AMOVL && p.From.Type_ == D_INDIR+D_TLS && D_AX <= p.To.Type_ && p.To.Type_ <= D_DI {
+		if p.As == AMOVL && p.From.Type == D_INDIR+D_TLS && D_AX <= p.To.Type && p.To.Type <= D_DI {
 
 			q = obj.Appendp(ctxt, p)
 			q.As = p.As
 			q.From = p.From
-			q.From.Type_ = D_INDIR + p.To.Type_
+			q.From.Type = D_INDIR + p.To.Type
 			q.From.Index = D_TLS
 			q.From.Scale = 2 // TODO: use 1
 			q.To = p.To
-			p.From.Type_ = D_TLS
+			p.From.Type = D_TLS
 			p.From.Index = D_NONE
 			p.From.Offset = 0
 		}
@@ -169,8 +169,8 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 	case ACALL,
 		AJMP,
 		ARET:
-		if (p.To.Type_ == D_EXTERN || p.To.Type_ == D_STATIC) && p.To.Sym != nil {
-			p.To.Type_ = D_BRANCH
+		if (p.To.Type == D_EXTERN || p.To.Type == D_STATIC) && p.To.Sym != nil {
+			p.To.Type = D_BRANCH
 		}
 		break
 	}
@@ -180,13 +180,13 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 
 	// Convert AMOVSS $(0), Xx to AXORPS Xx, Xx
 	case AMOVSS:
-		if p.From.Type_ == D_FCONST {
+		if p.From.Type == D_FCONST {
 
 			if p.From.U.Dval == 0 {
-				if p.To.Type_ >= D_X0 {
-					if p.To.Type_ <= D_X7 {
+				if p.To.Type >= D_X0 {
+					if p.To.Type <= D_X7 {
 						p.As = AXORPS
-						p.From.Type_ = p.To.Type_
+						p.From.Type = p.To.Type
 						p.From.Index = p.To.Index
 						break
 					}
@@ -212,7 +212,7 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 		ADIVSS,
 		ACOMISS,
 		AUCOMISS:
-		if p.From.Type_ == D_FCONST {
+		if p.From.Type == D_FCONST {
 
 			var i32 uint32
 			var f32 float32
@@ -220,26 +220,26 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 			i32 = math.Float32bits(f32)
 			literal = fmt.Sprintf("$f32.%08x", i32)
 			s = obj.Linklookup(ctxt, literal, 0)
-			if s.Type_ == 0 {
-				s.Type_ = obj.SRODATA
+			if s.Type == 0 {
+				s.Type = obj.SRODATA
 				obj.Adduint32(ctxt, s, i32)
 				s.Reachable = 0
 			}
 
-			p.From.Type_ = D_EXTERN
+			p.From.Type = D_EXTERN
 			p.From.Sym = s
 			p.From.Offset = 0
 		}
 
 		// Convert AMOVSD $(0), Xx to AXORPS Xx, Xx
 	case AMOVSD:
-		if p.From.Type_ == D_FCONST {
+		if p.From.Type == D_FCONST {
 
 			if p.From.U.Dval == 0 {
-				if p.To.Type_ >= D_X0 {
-					if p.To.Type_ <= D_X7 {
+				if p.To.Type >= D_X0 {
+					if p.To.Type <= D_X7 {
 						p.As = AXORPS
-						p.From.Type_ = p.To.Type_
+						p.From.Type = p.To.Type
 						p.From.Index = p.To.Index
 						break
 					}
@@ -265,19 +265,19 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 		ADIVSD,
 		ACOMISD,
 		AUCOMISD:
-		if p.From.Type_ == D_FCONST {
+		if p.From.Type == D_FCONST {
 
 			var i64 uint64
 			i64 = math.Float64bits(p.From.U.Dval)
 			literal = fmt.Sprintf("$f64.%016x", i64)
 			s = obj.Linklookup(ctxt, literal, 0)
-			if s.Type_ == 0 {
-				s.Type_ = obj.SRODATA
+			if s.Type == 0 {
+				s.Type = obj.SRODATA
 				obj.Adduint64(ctxt, s, i64)
 				s.Reachable = 0
 			}
 
-			p.From.Type_ = D_EXTERN
+			p.From.Type = D_EXTERN
 			p.From.Sym = s
 			p.From.Offset = 0
 		}
@@ -342,7 +342,7 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AADJSP
-		p.From.Type_ = D_CONST
+		p.From.Type = D_CONST
 		p.From.Offset = int64(autoffset)
 		p.Spadj = autoffset
 	} else {
@@ -383,41 +383,41 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 		p = obj.Appendp(ctxt, p)
 
 		p.As = AMOVL
-		p.From.Type_ = D_INDIR + D_CX
+		p.From.Type = D_INDIR + D_CX
 		p.From.Offset = 4 * int64(ctxt.Arch.Ptrsize) // G.panic
-		p.To.Type_ = D_BX
+		p.To.Type = D_BX
 
 		p = obj.Appendp(ctxt, p)
 		p.As = ATESTL
-		p.From.Type_ = D_BX
-		p.To.Type_ = D_BX
+		p.From.Type = D_BX
+		p.To.Type = D_BX
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AJEQ
-		p.To.Type_ = D_BRANCH
+		p.To.Type = D_BRANCH
 		p1 = p
 
 		p = obj.Appendp(ctxt, p)
 		p.As = ALEAL
-		p.From.Type_ = D_INDIR + D_SP
+		p.From.Type = D_INDIR + D_SP
 		p.From.Offset = int64(autoffset) + 4
-		p.To.Type_ = D_DI
+		p.To.Type = D_DI
 
 		p = obj.Appendp(ctxt, p)
 		p.As = ACMPL
-		p.From.Type_ = D_INDIR + D_BX
+		p.From.Type = D_INDIR + D_BX
 		p.From.Offset = 0 // Panic.argp
-		p.To.Type_ = D_DI
+		p.To.Type = D_DI
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AJNE
-		p.To.Type_ = D_BRANCH
+		p.To.Type = D_BRANCH
 		p2 = p
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AMOVL
-		p.From.Type_ = D_SP
-		p.To.Type_ = D_INDIR + D_BX
+		p.From.Type = D_SP
+		p.To.Type = D_INDIR + D_BX
 		p.To.Offset = 0 // Panic.argp
 
 		p = obj.Appendp(ctxt, p)
@@ -434,20 +434,20 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 		p = obj.Appendp(ctxt, p)
 
 		p.As = AMOVL
-		p.From.Type_ = D_SP
-		p.To.Type_ = D_DI
+		p.From.Type = D_SP
+		p.To.Type = D_DI
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AMOVL
-		p.From.Type_ = D_CONST
+		p.From.Type = D_CONST
 		p.From.Offset = int64(autoffset) / 4
-		p.To.Type_ = D_CX
+		p.To.Type = D_CX
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AMOVL
-		p.From.Type_ = D_CONST
+		p.From.Type = D_CONST
 		p.From.Offset = 0
-		p.To.Type_ = D_AX
+		p.To.Type = D_AX
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AREP
@@ -457,14 +457,14 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 	}
 
 	for ; p != nil; p = p.Link {
-		a = int(p.From.Type_)
+		a = int(p.From.Type)
 		if a == D_AUTO {
 			p.From.Offset += int64(deltasp)
 		}
 		if a == D_PARAM {
 			p.From.Offset += int64(deltasp) + 4
 		}
-		a = int(p.To.Type_)
+		a = int(p.To.Type)
 		if a == D_AUTO {
 			p.To.Offset += int64(deltasp)
 		}
@@ -510,7 +510,7 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 
 		if autoffset != 0 {
 			p.As = AADJSP
-			p.From.Type_ = D_CONST
+			p.From.Type = D_CONST
 			p.From.Offset = int64(-autoffset)
 			p.Spadj = -autoffset
 			p = obj.Appendp(ctxt, p)
@@ -539,9 +539,9 @@ func load_g_cx(ctxt *obj.Link, p *obj.Prog) *obj.Prog {
 	var next *obj.Prog
 
 	p.As = AMOVL
-	p.From.Type_ = D_INDIR + D_TLS
+	p.From.Type = D_INDIR + D_TLS
 	p.From.Offset = 0
-	p.To.Type_ = D_CX
+	p.To.Type = D_CX
 
 	next = p.Link
 	progedit(ctxt, p)
@@ -576,19 +576,19 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int, jmpok
 		p = obj.Appendp(ctxt, p)
 
 		p.As = ACMPL
-		p.From.Type_ = D_INDIR + D_CX
+		p.From.Type = D_INDIR + D_CX
 		p.From.Offset = 4
-		p.To.Type_ = D_SP
+		p.To.Type = D_SP
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AJCC
-		p.To.Type_ = D_BRANCH
+		p.To.Type = D_BRANCH
 		p.To.Offset = 4
 		q1 = p
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AINT
-		p.From.Type_ = D_CONST
+		p.From.Type = D_CONST
 		p.From.Offset = 3
 
 		p = obj.Appendp(ctxt, p)
@@ -604,8 +604,8 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int, jmpok
 		p = obj.Appendp(ctxt, p)
 
 		p.As = ACMPL
-		p.From.Type_ = D_SP
-		p.To.Type_ = D_INDIR + D_CX
+		p.From.Type = D_SP
+		p.To.Type = D_INDIR + D_CX
 		p.To.Offset = 2 * int64(ctxt.Arch.Ptrsize) // G.stackguard0
 		if ctxt.Cursym.Cfunc != 0 {
 			p.To.Offset = 3 * int64(ctxt.Arch.Ptrsize) // G.stackguard1
@@ -617,14 +617,14 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int, jmpok
 		p = obj.Appendp(ctxt, p)
 
 		p.As = ALEAL
-		p.From.Type_ = D_INDIR + D_SP
+		p.From.Type = D_INDIR + D_SP
 		p.From.Offset = -(int64(framesize) - obj.StackSmall)
-		p.To.Type_ = D_AX
+		p.To.Type = D_AX
 
 		p = obj.Appendp(ctxt, p)
 		p.As = ACMPL
-		p.From.Type_ = D_AX
-		p.To.Type_ = D_INDIR + D_CX
+		p.From.Type = D_AX
+		p.To.Type = D_INDIR + D_CX
 		p.To.Offset = 2 * int64(ctxt.Arch.Ptrsize) // G.stackguard0
 		if ctxt.Cursym.Cfunc != 0 {
 			p.To.Offset = 3 * int64(ctxt.Arch.Ptrsize) // G.stackguard1
@@ -648,41 +648,41 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int, jmpok
 		p = obj.Appendp(ctxt, p)
 
 		p.As = AMOVL
-		p.From.Type_ = D_INDIR + D_CX
+		p.From.Type = D_INDIR + D_CX
 		p.From.Offset = 0
 		p.From.Offset = 2 * int64(ctxt.Arch.Ptrsize) // G.stackguard0
 		if ctxt.Cursym.Cfunc != 0 {
 			p.From.Offset = 3 * int64(ctxt.Arch.Ptrsize) // G.stackguard1
 		}
-		p.To.Type_ = D_SI
+		p.To.Type = D_SI
 
 		p = obj.Appendp(ctxt, p)
 		p.As = ACMPL
-		p.From.Type_ = D_SI
-		p.To.Type_ = D_CONST
+		p.From.Type = D_SI
+		p.To.Type = D_CONST
 		p.To.Offset = int64(uint32(obj.StackPreempt & (1<<32 - 1)))
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AJEQ
-		p.To.Type_ = D_BRANCH
+		p.To.Type = D_BRANCH
 		q1 = p
 
 		p = obj.Appendp(ctxt, p)
 		p.As = ALEAL
-		p.From.Type_ = D_INDIR + D_SP
+		p.From.Type = D_INDIR + D_SP
 		p.From.Offset = obj.StackGuard
-		p.To.Type_ = D_AX
+		p.To.Type = D_AX
 
 		p = obj.Appendp(ctxt, p)
 		p.As = ASUBL
-		p.From.Type_ = D_SI
+		p.From.Type = D_SI
 		p.From.Offset = 0
-		p.To.Type_ = D_AX
+		p.To.Type = D_AX
 
 		p = obj.Appendp(ctxt, p)
 		p.As = ACMPL
-		p.From.Type_ = D_AX
-		p.To.Type_ = D_CONST
+		p.From.Type = D_AX
+		p.To.Type = D_CONST
 		p.To.Offset = int64(framesize) + (obj.StackGuard - obj.StackSmall)
 	}
 
@@ -690,13 +690,13 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int, jmpok
 	p = obj.Appendp(ctxt, p)
 
 	p.As = AJHI
-	p.To.Type_ = D_BRANCH
+	p.To.Type = D_BRANCH
 	p.To.Offset = 4
 	q = p
 
 	p = obj.Appendp(ctxt, p)
 	p.As = ACALL
-	p.To.Type_ = D_BRANCH
+	p.To.Type = D_BRANCH
 	if ctxt.Cursym.Cfunc != 0 {
 		p.To.Sym = obj.Linklookup(ctxt, "runtime.morestackc", 0)
 	} else {
@@ -706,7 +706,7 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int, jmpok
 
 	p = obj.Appendp(ctxt, p)
 	p.As = AJMP
-	p.To.Type_ = D_BRANCH
+	p.To.Type = D_BRANCH
 	p.Pcond = ctxt.Cursym.Text.Link
 
 	if q != nil {
@@ -798,7 +798,7 @@ func relinv(a int) int {
 		return AJOS
 	}
 
-	log.Fatalf("unknown relation: %s", anames8[a])
+	log.Fatalf("unknown relation: %s", Anames[a])
 	return 0
 }
 
@@ -885,7 +885,7 @@ loop:
 		q = ctxt.Arch.Prg()
 		q.As = AJMP
 		q.Lineno = p.Lineno
-		q.To.Type_ = D_BRANCH
+		q.To.Type = D_BRANCH
 		q.To.Offset = p.Pc
 		q.Pcond = p
 		p = q
@@ -918,7 +918,7 @@ loop:
 		if q != nil {
 			p.Link = q
 		}
-		if p.From.Type_ == D_CONST {
+		if p.From.Type == D_CONST {
 			if p.From.Offset == 1 {
 				/*
 				 * expect conditional jump to be taken.
diff --git a/src/cmd/internal/obj/link.go b/src/cmd/internal/obj/link.go
index 7404b37ddc..26a11484fa 100644
--- a/src/cmd/internal/obj/link.go
+++ b/src/cmd/internal/obj/link.go
@@ -41,7 +41,7 @@ type Addr struct {
 	}
 	Sym     *LSym
 	Gotype  *LSym
-	Type_   int16
+	Type    int16
 	Index   uint8
 	Scale   int8
 	Reg     int8
@@ -85,7 +85,7 @@ type Prog struct {
 type LSym struct {
 	Name        string
 	Extname     string
-	Type_       int16
+	Type        int16
 	Version     int16
 	Dupok       uint8
 	Cfunc       uint8
@@ -137,7 +137,7 @@ type Reloc struct {
 	Off     int32
 	Siz     uint8
 	Done    uint8
-	Type_   int32
+	Type    int32
 	Variant int32
 	Add     int64
 	Xadd    int64
@@ -149,7 +149,7 @@ type Auto struct {
 	Asym    *LSym
 	Link    *Auto
 	Aoffset int32
-	Type_   int16
+	Type    int16
 	Gotype  *LSym
 }
 
diff --git a/src/cmd/internal/obj/objfile.go b/src/cmd/internal/obj/objfile.go
index 7b33ff907c..f1e1701f0f 100644
--- a/src/cmd/internal/obj/objfile.go
+++ b/src/cmd/internal/obj/objfile.go
@@ -72,7 +72,7 @@ func Writeobjdirect(ctxt *Link, b *Biobuf) {
 				a = new(Auto)
 				a.Asym = p.From.Sym
 				a.Aoffset = int32(p.From.Offset)
-				a.Type_ = int16(ctxt.Arch.Symtype(&p.From))
+				a.Type = int16(ctxt.Arch.Symtype(&p.From))
 				a.Gotype = p.From.Gotype
 				a.Link = curtext.Autom
 				curtext.Autom = a
@@ -98,17 +98,17 @@ func Writeobjdirect(ctxt *Link, b *Biobuf) {
 				}
 				s.Next = nil
 				s.Size = p.To.Offset
-				if s.Type_ == 0 || s.Type_ == SXREF {
-					s.Type_ = SBSS
+				if s.Type == 0 || s.Type == SXREF {
+					s.Type = SBSS
 				}
 				flag = ctxt.Arch.Textflag(p)
 				if flag&DUPOK != 0 {
 					s.Dupok = 1
 				}
 				if flag&RODATA != 0 {
-					s.Type_ = SRODATA
+					s.Type = SRODATA
 				} else if flag&NOPTR != 0 {
-					s.Type_ = SNOPTRBSS
+					s.Type = SNOPTRBSS
 				}
 				edata = s
 				continue
@@ -150,7 +150,7 @@ func Writeobjdirect(ctxt *Link, b *Biobuf) {
 					s.Nosplit = 1
 				}
 				s.Next = nil
-				s.Type_ = STEXT
+				s.Type = STEXT
 				s.Text = p
 				s.Etext = p
 				curtext = s
@@ -163,7 +163,7 @@ func Writeobjdirect(ctxt *Link, b *Biobuf) {
 					continue
 				}
 				if p.To.Sym.Name == "go_args_stackmap" {
-					if int(p.From.Type_) != ctxt.Arch.D_CONST || p.From.Offset != FUNCDATA_ArgsPointerMaps {
+					if int(p.From.Type) != ctxt.Arch.D_CONST || p.From.Offset != FUNCDATA_ArgsPointerMaps {
 						ctxt.Diag("FUNCDATA use of go_args_stackmap(SB) without FUNCDATA_ArgsPointerMaps")
 					}
 					p.To.Sym = Linklookup(ctxt, string(fmt.Sprintf("%s.args_stackmap", curtext.Name)), int(curtext.Version))
@@ -187,7 +187,7 @@ func Writeobjdirect(ctxt *Link, b *Biobuf) {
 		}
 		found = 0
 		for p = s.Text; p != nil; p = p.Link {
-			if int(p.As) == ctxt.Arch.AFUNCDATA && int(p.From.Type_) == ctxt.Arch.D_CONST && p.From.Offset == FUNCDATA_ArgsPointerMaps {
+			if int(p.As) == ctxt.Arch.AFUNCDATA && int(p.From.Type) == ctxt.Arch.D_CONST && p.From.Offset == FUNCDATA_ArgsPointerMaps {
 				found = 1
 				break
 			}
@@ -196,13 +196,13 @@ func Writeobjdirect(ctxt *Link, b *Biobuf) {
 		if !(found != 0) {
 			p = Appendp(ctxt, s.Text)
 			p.As = int16(ctxt.Arch.AFUNCDATA)
-			p.From.Type_ = int16(ctxt.Arch.D_CONST)
+			p.From.Type = int16(ctxt.Arch.D_CONST)
 			p.From.Offset = FUNCDATA_ArgsPointerMaps
 			if ctxt.Arch.Thechar == '6' || ctxt.Arch.Thechar == '8' {
-				p.To.Type_ = int16(ctxt.Arch.D_EXTERN)
+				p.To.Type = int16(ctxt.Arch.D_EXTERN)
 			} else {
 
-				p.To.Type_ = int16(ctxt.Arch.D_OREG)
+				p.To.Type = int16(ctxt.Arch.D_OREG)
 				p.To.Name = int8(ctxt.Arch.D_EXTERN)
 			}
 
@@ -269,8 +269,8 @@ func writesym(ctxt *Link, b *Biobuf, s *LSym) {
 		if s.Version != 0 {
 			fmt.Fprintf(ctxt.Bso, "v=%d ", s.Version)
 		}
-		if s.Type_ != 0 {
-			fmt.Fprintf(ctxt.Bso, "t=%d ", s.Type_)
+		if s.Type != 0 {
+			fmt.Fprintf(ctxt.Bso, "t=%d ", s.Type)
 		}
 		if s.Dupok != 0 {
 			fmt.Fprintf(ctxt.Bso, "dupok ")
@@ -282,7 +282,7 @@ func writesym(ctxt *Link, b *Biobuf, s *LSym) {
 			fmt.Fprintf(ctxt.Bso, "nosplit ")
 		}
 		fmt.Fprintf(ctxt.Bso, "size=%d value=%d", int64(s.Size), int64(s.Value))
-		if s.Type_ == STEXT {
+		if s.Type == STEXT {
 			fmt.Fprintf(ctxt.Bso, " args=%#x locals=%#x", uint64(s.Args), uint64(s.Locals))
 			if s.Leaf != 0 {
 				fmt.Fprintf(ctxt.Bso, " leaf")
@@ -323,16 +323,16 @@ func writesym(ctxt *Link, b *Biobuf, s *LSym) {
 				name = r.Sym.Name
 			}
 			if ctxt.Arch.Thechar == '5' || ctxt.Arch.Thechar == '9' {
-				fmt.Fprintf(ctxt.Bso, "\trel %d+%d t=%d %s+%x\n", int(r.Off), r.Siz, r.Type_, name, uint64(int64(r.Add)))
+				fmt.Fprintf(ctxt.Bso, "\trel %d+%d t=%d %s+%x\n", int(r.Off), r.Siz, r.Type, name, uint64(int64(r.Add)))
 			} else {
 
-				fmt.Fprintf(ctxt.Bso, "\trel %d+%d t=%d %s+%d\n", int(r.Off), r.Siz, r.Type_, name, int64(r.Add))
+				fmt.Fprintf(ctxt.Bso, "\trel %d+%d t=%d %s+%d\n", int(r.Off), r.Siz, r.Type, name, int64(r.Add))
 			}
 		}
 	}
 
 	Bputc(b, 0xfe)
-	wrint(b, int64(s.Type_))
+	wrint(b, int64(s.Type))
 	wrstring(b, s.Name)
 	wrint(b, int64(s.Version))
 	wrint(b, int64(s.Dupok))
@@ -345,14 +345,14 @@ func writesym(ctxt *Link, b *Biobuf, s *LSym) {
 		r = &s.R[i]
 		wrint(b, int64(r.Off))
 		wrint(b, int64(r.Siz))
-		wrint(b, int64(r.Type_))
+		wrint(b, int64(r.Type))
 		wrint(b, r.Add)
 		wrint(b, r.Xadd)
 		wrsym(b, r.Sym)
 		wrsym(b, r.Xsym)
 	}
 
-	if s.Type_ == STEXT {
+	if s.Type == STEXT {
 		wrint(b, int64(s.Args))
 		wrint(b, int64(s.Locals))
 		wrint(b, int64(s.Nosplit))
@@ -365,13 +365,13 @@ func writesym(ctxt *Link, b *Biobuf, s *LSym) {
 		for a = s.Autom; a != nil; a = a.Link {
 			wrsym(b, a.Asym)
 			wrint(b, int64(a.Aoffset))
-			if int(a.Type_) == ctxt.Arch.D_AUTO {
+			if int(a.Type) == ctxt.Arch.D_AUTO {
 				wrint(b, A_AUTO)
-			} else if int(a.Type_) == ctxt.Arch.D_PARAM {
+			} else if int(a.Type) == ctxt.Arch.D_PARAM {
 				wrint(b, A_PARAM)
 			} else {
 
-				log.Fatalf("%s: invalid local variable type %d", s.Name, a.Type_)
+				log.Fatalf("%s: invalid local variable type %d", s.Name, a.Type)
 			}
 			wrsym(b, a.Gotype)
 		}
diff --git a/src/cmd/internal/obj/pass.go b/src/cmd/internal/obj/pass.go
index 9918cffada..a8c1c77d83 100644
--- a/src/cmd/internal/obj/pass.go
+++ b/src/cmd/internal/obj/pass.go
@@ -76,7 +76,7 @@ func linkpatch(ctxt *Link, sym *LSym) {
 		if ctxt.Arch.Progedit != nil {
 			ctxt.Arch.Progedit(ctxt, p)
 		}
-		if int(p.To.Type_) != ctxt.Arch.D_BRANCH {
+		if int(p.To.Type) != ctxt.Arch.D_BRANCH {
 			continue
 		}
 		if p.To.U.Branch != nil {
@@ -108,7 +108,7 @@ func linkpatch(ctxt *Link, sym *LSym) {
 				name = p.To.Sym.Name
 			}
 			ctxt.Diag("branch out of range (%#x)\n%v [%s]", uint32(c), p, name)
-			p.To.Type_ = int16(ctxt.Arch.D_NONE)
+			p.To.Type = int16(ctxt.Arch.D_NONE)
 		}
 
 		p.To.U.Branch = q
@@ -120,7 +120,7 @@ func linkpatch(ctxt *Link, sym *LSym) {
 		if p.Pcond != nil {
 			p.Pcond = brloop(ctxt, p.Pcond)
 			if p.Pcond != nil {
-				if int(p.To.Type_) == ctxt.Arch.D_BRANCH {
+				if int(p.To.Type) == ctxt.Arch.D_BRANCH {
 					p.To.Offset = p.Pcond.Pc
 				}
 			}
diff --git a/src/cmd/internal/obj/pcln.go b/src/cmd/internal/obj/pcln.go
index ce36050853..32d9498fef 100644
--- a/src/cmd/internal/obj/pcln.go
+++ b/src/cmd/internal/obj/pcln.go
@@ -293,7 +293,7 @@ func linkpcln(ctxt *Link, cursym *LSym) {
 			if int(p.As) == ctxt.Arch.AFUNCDATA {
 				i = int(p.From.Offset)
 				pcln.Funcdataoff[i] = p.To.Offset
-				if int(p.To.Type_) != ctxt.Arch.D_CONST {
+				if int(p.To.Type) != ctxt.Arch.D_CONST {
 					// TODO: Dedup.
 					//funcdata_bytes += p->to.sym->size;
 					pcln.Funcdata[i] = p.To.Sym
diff --git a/src/cmd/internal/obj/ppc64/anames9.go b/src/cmd/internal/obj/ppc64/anames9.go
index 205845ecf5..431c3fa31e 100644
--- a/src/cmd/internal/obj/ppc64/anames9.go
+++ b/src/cmd/internal/obj/ppc64/anames9.go
@@ -5,7 +5,7 @@ package ppc64
 /*
  * this is the ranlib header
  */
-var anames9 = []string{
+var Anames = []string{
 	"XXX",
 	"ADD",
 	"ADDCC",
diff --git a/src/cmd/internal/obj/ppc64/asm9.go b/src/cmd/internal/obj/ppc64/asm9.go
index 947cbac620..a98ae61d21 100644
--- a/src/cmd/internal/obj/ppc64/asm9.go
+++ b/src/cmd/internal/obj/ppc64/asm9.go
@@ -479,14 +479,14 @@ func span9(ctxt *obj.Link, cursym *obj.LSym) {
 					q.Link = p.Link
 					p.Link = q
 					q.As = ABR
-					q.To.Type_ = D_BRANCH
+					q.To.Type = D_BRANCH
 					q.Pcond = p.Pcond
 					p.Pcond = q
 					q = ctxt.Arch.Prg()
 					q.Link = p.Link
 					p.Link = q
 					q.As = ABR
-					q.To.Type_ = D_BRANCH
+					q.To.Type = D_BRANCH
 					q.Pcond = q.Link.Link
 
 					//addnop(p->link);
@@ -549,7 +549,7 @@ func isuint32(v uint64) int {
 func aclass(ctxt *obj.Link, a *obj.Addr) int {
 	var s *obj.LSym
 
-	switch a.Type_ {
+	switch a.Type {
 	case D_NONE:
 		return C_NONE
 
@@ -652,7 +652,7 @@ func aclass(ctxt *obj.Link, a *obj.Addr) int {
 			if s == nil {
 				break
 			}
-			if s.Type_ == obj.SCONST {
+			if s.Type == obj.SCONST {
 				ctxt.Instoffset = s.Value + a.Offset
 				goto consize
 			}
@@ -1405,7 +1405,7 @@ func addaddrreloc(ctxt *obj.Link, s *obj.LSym, o1 *uint32, o2 *uint32) {
 	rel.Siz = 8
 	rel.Sym = s
 	rel.Add = int64(uint64(*o1)<<32 | uint64(uint32(*o2)))
-	rel.Type_ = obj.R_ADDRPOWER
+	rel.Type = obj.R_ADDRPOWER
 }
 
 /*
@@ -1543,7 +1543,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 		break
 
 	case 1: /* mov r1,r2 ==> OR Rs,Rs,Ra */
-		if p.To.Reg == REGZERO && p.From.Type_ == D_CONST {
+		if p.To.Reg == REGZERO && p.From.Type == D_CONST {
 
 			v = regoff(ctxt, &p.From)
 			if r0iszero != 0 /*TypeKind(100016)*/ && v != 0 {
@@ -1630,7 +1630,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 			r = int(o.param)
 		}
 		v = regoff(ctxt, &p.To)
-		if p.To.Type_ == D_OREG && p.Reg != NREG {
+		if p.To.Type == D_OREG && p.Reg != NREG {
 			if v != 0 {
 				ctxt.Diag("illegal indexed instruction\n%v", p)
 			}
@@ -1650,7 +1650,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 			r = int(o.param)
 		}
 		v = regoff(ctxt, &p.From)
-		if p.From.Type_ == D_OREG && p.Reg != NREG {
+		if p.From.Type == D_OREG && p.Reg != NREG {
 			if v != 0 {
 				ctxt.Diag("illegal indexed instruction\n%v", p)
 			}
@@ -1670,7 +1670,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 			r = int(o.param)
 		}
 		v = regoff(ctxt, &p.From)
-		if p.From.Type_ == D_OREG && p.Reg != NREG {
+		if p.From.Type == D_OREG && p.Reg != NREG {
 			if v != 0 {
 				ctxt.Diag("illegal indexed instruction\n%v", p)
 			}
@@ -1717,11 +1717,11 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 			}
 
 			rel.Add = int64(v)
-			rel.Type_ = obj.R_CALLPOWER
+			rel.Type = obj.R_CALLPOWER
 		}
 
 	case 12: /* movb r,r (extsb); movw r,r (extsw) */
-		if p.To.Reg == REGZERO && p.From.Type_ == D_CONST {
+		if p.To.Reg == REGZERO && p.From.Type == D_CONST {
 
 			v = regoff(ctxt, &p.From)
 			if r0iszero != 0 /*TypeKind(100016)*/ && v != 0 {
@@ -1792,7 +1792,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 		16: /* bc bo,bi,sbra */
 		a = 0
 
-		if p.From.Type_ == D_CONST {
+		if p.From.Type == D_CONST {
 			a = int(regoff(ctxt, &p.From))
 		}
 		r = int(p.Reg)
@@ -2080,7 +2080,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 			rel.Siz = 8
 			rel.Sym = p.From.Sym
 			rel.Add = p.From.Offset
-			rel.Type_ = obj.R_ADDR
+			rel.Type = obj.R_ADDR
 			o2 = 0
 			o1 = o2
 		}
@@ -2188,7 +2188,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 		o1 = LOP_RRR(uint32(oprrr(ctxt, int(p.As))), uint32(p.To.Reg), uint32(r), 0)
 
 	case 49: /* op Rb; op $n, Rb */
-		if p.From.Type_ != D_REG { /* tlbie $L, rB */
+		if p.From.Type != D_REG { /* tlbie $L, rB */
 			v = regoff(ctxt, &p.From) & 1
 			o1 = AOP_RRR(uint32(oprrr(ctxt, int(p.As))), 0, 0, uint32(p.To.Reg)) | uint32(v)<<21
 		} else {
@@ -2342,7 +2342,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 		o1 |= (uint32(mask[0])&31)<<6 | (uint32(mask[1])&31)<<1
 
 	case 64: /* mtfsf fr[, $m] {,fpcsr} */
-		if p.From3.Type_ != D_NONE {
+		if p.From3.Type != D_NONE {
 
 			v = regoff(ctxt, &p.From3) & 255
 		} else {
@@ -2359,11 +2359,11 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 		o1 = OP_MTFSFI | (uint32(p.To.Reg)&15)<<23 | (uint32(regoff(ctxt, &p.From))&31)<<12
 
 	case 66: /* mov spr,r1; mov r1,spr, also dcr */
-		if p.From.Type_ == D_REG {
+		if p.From.Type == D_REG {
 
 			r = int(p.From.Reg)
 			v = int32(p.To.Offset)
-			if p.To.Type_ == D_DCR {
+			if p.To.Type == D_DCR {
 				o1 = OPVCC(31, 451, 0, 0) /* mtdcr */
 			} else {
 
@@ -2373,7 +2373,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 
 			r = int(p.To.Reg)
 			v = int32(p.From.Offset)
-			if p.From.Type_ == D_DCR {
+			if p.From.Type == D_DCR {
 				o1 = OPVCC(31, 323, 0, 0) /* mfdcr */
 			} else {
 
@@ -2384,14 +2384,14 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 		o1 = AOP_RRR(o1, uint32(r), 0, 0) | (uint32(v)&0x1f)<<16 | ((uint32(v)>>5)&0x1f)<<11
 
 	case 67: /* mcrf crfD,crfS */
-		if p.From.Type_ != D_CREG || p.From.Reg == NREG || p.To.Type_ != D_CREG || p.To.Reg == NREG {
+		if p.From.Type != D_CREG || p.From.Reg == NREG || p.To.Type != D_CREG || p.To.Reg == NREG {
 
 			ctxt.Diag("illegal CR field number\n%v", p)
 		}
 		o1 = AOP_RRR(OP_MCRF, ((uint32(p.To.Reg) & 7) << 2), ((uint32(p.From.Reg) & 7) << 2), 0)
 
 	case 68: /* mfcr rD; mfocrf CRM,rD */
-		if p.From.Type_ == D_CREG && p.From.Reg != NREG {
+		if p.From.Type == D_CREG && p.From.Reg != NREG {
 
 			v = 1 << uint(7-(p.To.Reg&7))                                         /* CR(n) */
 			o1 = AOP_RRR(OP_MFCR, uint32(p.To.Reg), 0, 0) | 1<<20 | uint32(v)<<12 /* new form, mfocrf */
@@ -2401,7 +2401,7 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 		}
 
 	case 69: /* mtcrf CRM,rS */
-		if p.From3.Type_ != D_NONE {
+		if p.From3.Type != D_NONE {
 
 			if p.To.Reg != NREG {
 				ctxt.Diag("can't use both mask and CR(n)\n%v", p)
@@ -2443,20 +2443,20 @@ func asmout(ctxt *obj.Link, p *obj.Prog, o *Optab, out []uint32) {
 		o1 = AOP_RRR(uint32(oprrr(ctxt, int(p.As))), uint32(p.From.Reg), 0, uint32(p.To.Reg))
 
 	case 73: /* mcrfs crfD,crfS */
-		if p.From.Type_ != D_FPSCR || p.From.Reg == NREG || p.To.Type_ != D_CREG || p.To.Reg == NREG {
+		if p.From.Type != D_FPSCR || p.From.Reg == NREG || p.To.Type != D_CREG || p.To.Reg == NREG {
 
 			ctxt.Diag("illegal FPSCR/CR field number\n%v", p)
 		}
 		o1 = AOP_RRR(OP_MCRFS, ((uint32(p.To.Reg) & 7) << 2), ((uint32(p.From.Reg) & 7) << 2), 0)
 
 	case 77: /* syscall $scon, syscall Rx */
-		if p.From.Type_ == D_CONST {
+		if p.From.Type == D_CONST {
 
 			if p.From.Offset > BIG || p.From.Offset < -BIG {
 				ctxt.Diag("illegal syscall, sysnum too large: %v", p)
 			}
 			o1 = AOP_IRR(OP_ADDI, REGZERO, REGZERO, uint32(p.From.Offset))
-		} else if p.From.Type_ == D_REG {
+		} else if p.From.Type == D_REG {
 			o1 = LOP_RRR(OP_OR, REGZERO, uint32(p.From.Reg), uint32(p.From.Reg))
 		} else {
 
diff --git a/src/cmd/internal/obj/ppc64/list9.go b/src/cmd/internal/obj/ppc64/list9.go
index 227d42f933..1722231a58 100644
--- a/src/cmd/internal/obj/ppc64/list9.go
+++ b/src/cmd/internal/obj/ppc64/list9.go
@@ -84,24 +84,24 @@ func Pconv(p *obj.Prog) string {
 		if p.Mark&NOSCHED != 0 {
 			str += fmt.Sprintf("*")
 		}
-		if p.Reg == NREG && p.From3.Type_ == D_NONE {
+		if p.Reg == NREG && p.From3.Type == D_NONE {
 			str += fmt.Sprintf("%.5d (%v)\t%v\t%v,%v", p.Pc, p.Line(), Aconv(a), Dconv(p, 0, &p.From), Dconv(p, 0, &p.To))
-		} else if a != ATEXT && p.From.Type_ == D_OREG {
+		} else if a != ATEXT && p.From.Type == D_OREG {
 			str += fmt.Sprintf("%.5d (%v)\t%v\t%d(R%d+R%d),%v", p.Pc, p.Line(), Aconv(a), p.From.Offset, p.From.Reg, p.Reg, Dconv(p, 0, &p.To))
-		} else if p.To.Type_ == D_OREG {
+		} else if p.To.Type == D_OREG {
 			str += fmt.Sprintf("%.5d (%v)\t%v\t%v,%d(R%d+R%d)", p.Pc, p.Line(), Aconv(a), Dconv(p, 0, &p.From), p.To.Offset, p.To.Reg, p.Reg)
 		} else {
 
 			str += fmt.Sprintf("%.5d (%v)\t%v\t%v", p.Pc, p.Line(), Aconv(a), Dconv(p, 0, &p.From))
 			if p.Reg != NREG {
 				ch = 'R'
-				if p.From.Type_ == D_FREG {
+				if p.From.Type == D_FREG {
 					ch = 'F'
 				}
 				str += fmt.Sprintf(",%c%d", ch, p.Reg)
 			}
 
-			if p.From3.Type_ != D_NONE {
+			if p.From3.Type != D_NONE {
 				str += fmt.Sprintf(",%v", Dconv(p, 0, &p.From3))
 			}
 			str += fmt.Sprintf(",%v", Dconv(p, 0, &p.To))
@@ -123,7 +123,7 @@ func Aconv(a int) string {
 
 	s = "???"
 	if a >= AXXX && a < ALAST {
-		s = anames9[a]
+		s = Anames[a]
 	}
 	fp += s
 	return fp
@@ -136,7 +136,7 @@ func Dconv(p *obj.Prog, flag int, a *obj.Addr) string {
 	var v int32
 
 	if flag&fmtLong != 0 /*untyped*/ {
-		if a.Type_ == D_CONST {
+		if a.Type == D_CONST {
 			str = fmt.Sprintf("$%d-%d", int32(a.Offset), int32(a.Offset>>32))
 		} else {
 
@@ -147,9 +147,9 @@ func Dconv(p *obj.Prog, flag int, a *obj.Addr) string {
 		goto ret
 	}
 
-	switch a.Type_ {
+	switch a.Type {
 	default:
-		str = fmt.Sprintf("GOK-type(%d)", a.Type_)
+		str = fmt.Sprintf("GOK-type(%d)", a.Type)
 
 	case D_NONE:
 		str = ""
diff --git a/src/cmd/internal/obj/ppc64/obj9.go b/src/cmd/internal/obj/ppc64/obj9.go
index 7455c6be83..01fa768df4 100644
--- a/src/cmd/internal/obj/ppc64/obj9.go
+++ b/src/cmd/internal/obj/ppc64/obj9.go
@@ -40,19 +40,19 @@ var zprg = obj.Prog{
 	As:  AGOK,
 	Reg: NREG,
 	From: obj.Addr{
-		Name:  D_NONE,
-		Type_: D_NONE,
-		Reg:   NREG,
+		Name: D_NONE,
+		Type: D_NONE,
+		Reg:  NREG,
 	},
 	From3: obj.Addr{
-		Name:  D_NONE,
-		Type_: D_NONE,
-		Reg:   NREG,
+		Name: D_NONE,
+		Type: D_NONE,
+		Reg:  NREG,
 	},
 	To: obj.Addr{
-		Name:  D_NONE,
-		Type_: D_NONE,
-		Reg:   NREG,
+		Name: D_NONE,
+		Type: D_NONE,
+		Reg:  NREG,
 	},
 }
 
@@ -96,7 +96,7 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 		ADUFFZERO,
 		ADUFFCOPY:
 		if p.To.Sym != nil {
-			p.To.Type_ = D_BRANCH
+			p.To.Type = D_BRANCH
 		}
 		break
 	}
@@ -105,7 +105,7 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 	switch p.As {
 
 	case AFMOVS:
-		if p.From.Type_ == D_FCONST {
+		if p.From.Type == D_FCONST {
 			var i32 uint32
 			var f32 float32
 			f32 = float32(p.From.U.Dval)
@@ -113,20 +113,20 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 			literal = fmt.Sprintf("$f32.%08x", i32)
 			s = obj.Linklookup(ctxt, literal, 0)
 			s.Size = 4
-			p.From.Type_ = D_OREG
+			p.From.Type = D_OREG
 			p.From.Sym = s
 			p.From.Name = D_EXTERN
 			p.From.Offset = 0
 		}
 
 	case AFMOVD:
-		if p.From.Type_ == D_FCONST {
+		if p.From.Type == D_FCONST {
 			var i64 uint64
 			i64 = math.Float64bits(p.From.U.Dval)
 			literal = fmt.Sprintf("$f64.%016x", i64)
 			s = obj.Linklookup(ctxt, literal, 0)
 			s.Size = 8
-			p.From.Type_ = D_OREG
+			p.From.Type = D_OREG
 			p.From.Sym = s
 			p.From.Name = D_EXTERN
 			p.From.Offset = 0
@@ -134,12 +134,12 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 
 		// Put >32-bit constants in memory and load them
 	case AMOVD:
-		if p.From.Type_ == D_CONST && p.From.Name == D_NONE && p.From.Reg == NREG && int64(int32(p.From.Offset)) != p.From.Offset {
+		if p.From.Type == D_CONST && p.From.Name == D_NONE && p.From.Reg == NREG && int64(int32(p.From.Offset)) != p.From.Offset {
 
 			literal = fmt.Sprintf("$i64.%016x", uint64(p.From.Offset))
 			s = obj.Linklookup(ctxt, literal, 0)
 			s.Size = 8
-			p.From.Type_ = D_OREG
+			p.From.Type = D_OREG
 			p.From.Sym = s
 			p.From.Name = D_EXTERN
 			p.From.Offset = 0
@@ -150,19 +150,19 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 	switch p.As {
 
 	case ASUBC:
-		if p.From.Type_ == D_CONST {
+		if p.From.Type == D_CONST {
 			p.From.Offset = -p.From.Offset
 			p.As = AADDC
 		}
 
 	case ASUBCCC:
-		if p.From.Type_ == D_CONST {
+		if p.From.Type == D_CONST {
 			p.From.Offset = -p.From.Offset
 			p.As = AADDCCC
 		}
 
 	case ASUB:
-		if p.From.Type_ == D_CONST {
+		if p.From.Type == D_CONST {
 			p.From.Offset = -p.From.Offset
 			p.As = AADD
 		}
@@ -241,7 +241,7 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 
 		case ANOR:
 			q = p
-			if p.To.Type_ == D_REG {
+			if p.To.Type == D_REG {
 				if p.To.Reg == REGZERO {
 					p.Mark |= LABEL | SYNC
 				}
@@ -284,7 +284,7 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 			AMOVWZ,
 			AMOVD:
 			q = p
-			switch p.From.Type_ {
+			switch p.From.Type {
 			case D_MSR,
 				D_SPR,
 				D_FPSCR,
@@ -293,7 +293,7 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 				p.Mark |= LABEL | SYNC
 			}
 
-			switch p.To.Type_ {
+			switch p.To.Type {
 			case D_MSR,
 				D_SPR,
 				D_FPSCR,
@@ -440,9 +440,9 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 					q = obj.Appendp(ctxt, p)
 					q.As = AADD
 					q.Lineno = p.Lineno
-					q.From.Type_ = D_CONST
+					q.From.Type = D_CONST
 					q.From.Offset = int64(-autosize)
-					q.To.Type_ = D_REG
+					q.To.Type = D_REG
 					q.To.Reg = REGSP
 					q.Spadj = +autosize
 				}
@@ -463,17 +463,17 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 			q = obj.Appendp(ctxt, q)
 			q.As = AMOVD
 			q.Lineno = p.Lineno
-			q.From.Type_ = D_SPR
+			q.From.Type = D_SPR
 			q.From.Offset = D_LR
-			q.To.Type_ = D_REG
+			q.To.Type = D_REG
 			q.To.Reg = REGTMP
 
 			q = obj.Appendp(ctxt, q)
 			q.As = int16(mov)
 			q.Lineno = p.Lineno
-			q.From.Type_ = D_REG
+			q.From.Type = D_REG
 			q.From.Reg = REGTMP
-			q.To.Type_ = D_OREG
+			q.To.Type = D_OREG
 			q.To.Offset = int64(aoffset)
 			q.To.Reg = REGSP
 			if q.As == AMOVDU {
@@ -501,65 +501,65 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 				q = obj.Appendp(ctxt, q)
 
 				q.As = AMOVD
-				q.From.Type_ = D_OREG
+				q.From.Type = D_OREG
 				q.From.Reg = REGG
 				q.From.Offset = 4 * int64(ctxt.Arch.Ptrsize) // G.panic
-				q.To.Type_ = D_REG
+				q.To.Type = D_REG
 				q.To.Reg = 3
 
 				q = obj.Appendp(ctxt, q)
 				q.As = ACMP
-				q.From.Type_ = D_REG
+				q.From.Type = D_REG
 				q.From.Reg = 0
-				q.To.Type_ = D_REG
+				q.To.Type = D_REG
 				q.To.Reg = 3
 
 				q = obj.Appendp(ctxt, q)
 				q.As = ABEQ
-				q.To.Type_ = D_BRANCH
+				q.To.Type = D_BRANCH
 				p1 = q
 
 				q = obj.Appendp(ctxt, q)
 				q.As = AMOVD
-				q.From.Type_ = D_OREG
+				q.From.Type = D_OREG
 				q.From.Reg = 3
 				q.From.Offset = 0 // Panic.argp
-				q.To.Type_ = D_REG
+				q.To.Type = D_REG
 				q.To.Reg = 4
 
 				q = obj.Appendp(ctxt, q)
 				q.As = AADD
-				q.From.Type_ = D_CONST
+				q.From.Type = D_CONST
 				q.From.Offset = int64(autosize) + 8
 				q.Reg = REGSP
-				q.To.Type_ = D_REG
+				q.To.Type = D_REG
 				q.To.Reg = 5
 
 				q = obj.Appendp(ctxt, q)
 				q.As = ACMP
-				q.From.Type_ = D_REG
+				q.From.Type = D_REG
 				q.From.Reg = 4
-				q.To.Type_ = D_REG
+				q.To.Type = D_REG
 				q.To.Reg = 5
 
 				q = obj.Appendp(ctxt, q)
 				q.As = ABNE
-				q.To.Type_ = D_BRANCH
+				q.To.Type = D_BRANCH
 				p2 = q
 
 				q = obj.Appendp(ctxt, q)
 				q.As = AADD
-				q.From.Type_ = D_CONST
+				q.From.Type = D_CONST
 				q.From.Offset = 8
 				q.Reg = REGSP
-				q.To.Type_ = D_REG
+				q.To.Type = D_REG
 				q.To.Reg = 6
 
 				q = obj.Appendp(ctxt, q)
 				q.As = AMOVD
-				q.From.Type_ = D_REG
+				q.From.Type = D_REG
 				q.From.Reg = 6
-				q.To.Type_ = D_OREG
+				q.To.Type = D_OREG
 				q.To.Reg = 3
 				q.To.Offset = 0 // Panic.argp
 
@@ -571,14 +571,14 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 			}
 
 		case ARETURN:
-			if p.From.Type_ == D_CONST {
+			if p.From.Type == D_CONST {
 				ctxt.Diag("using BECOME (%v) is not supported!", p)
 				break
 			}
 
 			if p.To.Sym != nil { // retjmp
 				p.As = ABR
-				p.To.Type_ = D_BRANCH
+				p.To.Type = D_BRANCH
 				break
 			}
 
@@ -586,23 +586,23 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 				if !(autosize != 0) {
 					p.As = ABR
 					p.From = zprg.From
-					p.To.Type_ = D_SPR
+					p.To.Type = D_SPR
 					p.To.Offset = D_LR
 					p.Mark |= BRANCH
 					break
 				}
 
 				p.As = AADD
-				p.From.Type_ = D_CONST
+				p.From.Type = D_CONST
 				p.From.Offset = int64(autosize)
-				p.To.Type_ = D_REG
+				p.To.Type = D_REG
 				p.To.Reg = REGSP
 				p.Spadj = -autosize
 
 				q = ctxt.Arch.Prg()
 				q.As = ABR
 				q.Lineno = p.Lineno
-				q.To.Type_ = D_SPR
+				q.To.Type = D_SPR
 				q.To.Offset = D_LR
 				q.Mark |= BRANCH
 				q.Spadj = +autosize
@@ -613,18 +613,18 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 			}
 
 			p.As = AMOVD
-			p.From.Type_ = D_OREG
+			p.From.Type = D_OREG
 			p.From.Offset = 0
 			p.From.Reg = REGSP
-			p.To.Type_ = D_REG
+			p.To.Type = D_REG
 			p.To.Reg = REGTMP
 
 			q = ctxt.Arch.Prg()
 			q.As = AMOVD
 			q.Lineno = p.Lineno
-			q.From.Type_ = D_REG
+			q.From.Type = D_REG
 			q.From.Reg = REGTMP
-			q.To.Type_ = D_SPR
+			q.To.Type = D_SPR
 			q.To.Offset = D_LR
 
 			q.Link = p.Link
@@ -637,10 +637,10 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 
 				q.As = AMOVD
 				q.Lineno = p.Lineno
-				q.From.Type_ = D_OREG
+				q.From.Type = D_OREG
 				q.From.Offset = 0
 				q.From.Reg = REGTMP
-				q.To.Type_ = D_REG
+				q.To.Type = D_REG
 				q.To.Reg = REGTMP
 
 				q.Link = p.Link
@@ -652,9 +652,9 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 				q = ctxt.Arch.Prg()
 				q.As = AADD
 				q.Lineno = p.Lineno
-				q.From.Type_ = D_CONST
+				q.From.Type = D_CONST
 				q.From.Offset = int64(autosize)
-				q.To.Type_ = D_REG
+				q.To.Type = D_REG
 				q.To.Reg = REGSP
 				q.Spadj = -autosize
 
@@ -665,7 +665,7 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 			q1 = ctxt.Arch.Prg()
 			q1.As = ABR
 			q1.Lineno = p.Lineno
-			q1.To.Type_ = D_SPR
+			q1.To.Type = D_SPR
 			q1.To.Offset = D_LR
 			q1.Mark |= BRANCH
 			q1.Spadj = +autosize
@@ -674,7 +674,7 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 			q.Link = q1
 
 		case AADD:
-			if p.To.Type_ == D_REG && p.To.Reg == REGSP && p.From.Type_ == D_CONST {
+			if p.To.Type == D_REG && p.To.Reg == REGSP && p.From.Type == D_CONST {
 				p.Spadj = int32(-p.From.Offset)
 			}
 			break
@@ -736,13 +736,13 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int) *obj.P
 	p = obj.Appendp(ctxt, p)
 
 	p.As = AMOVD
-	p.From.Type_ = D_OREG
+	p.From.Type = D_OREG
 	p.From.Reg = REGG
 	p.From.Offset = 2 * int64(ctxt.Arch.Ptrsize) // G.stackguard0
 	if ctxt.Cursym.Cfunc != 0 {
 		p.From.Offset = 3 * int64(ctxt.Arch.Ptrsize) // G.stackguard1
 	}
-	p.To.Type_ = D_REG
+	p.To.Type = D_REG
 	p.To.Reg = 3
 
 	q = nil
@@ -752,9 +752,9 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int) *obj.P
 		p = obj.Appendp(ctxt, p)
 
 		p.As = ACMPU
-		p.From.Type_ = D_REG
+		p.From.Type = D_REG
 		p.From.Reg = 3
-		p.To.Type_ = D_REG
+		p.To.Type = D_REG
 		p.To.Reg = REGSP
 	} else if framesize <= obj.StackBig {
 		// large stack: SP-framesize < stackguard-StackSmall
@@ -763,17 +763,17 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int) *obj.P
 		p = obj.Appendp(ctxt, p)
 
 		p.As = AADD
-		p.From.Type_ = D_CONST
+		p.From.Type = D_CONST
 		p.From.Offset = int64(-framesize)
 		p.Reg = REGSP
-		p.To.Type_ = D_REG
+		p.To.Type = D_REG
 		p.To.Reg = 4
 
 		p = obj.Appendp(ctxt, p)
 		p.As = ACMPU
-		p.From.Type_ = D_REG
+		p.From.Type = D_REG
 		p.From.Reg = 3
-		p.To.Type_ = D_REG
+		p.To.Type = D_REG
 		p.To.Reg = 4
 	} else {
 
@@ -795,43 +795,43 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int) *obj.P
 		p = obj.Appendp(ctxt, p)
 
 		p.As = ACMP
-		p.From.Type_ = D_REG
+		p.From.Type = D_REG
 		p.From.Reg = 3
-		p.To.Type_ = D_CONST
+		p.To.Type = D_CONST
 		p.To.Offset = obj.StackPreempt
 
 		p = obj.Appendp(ctxt, p)
 		q = p
 		p.As = ABEQ
-		p.To.Type_ = D_BRANCH
+		p.To.Type = D_BRANCH
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AADD
-		p.From.Type_ = D_CONST
+		p.From.Type = D_CONST
 		p.From.Offset = obj.StackGuard
 		p.Reg = REGSP
-		p.To.Type_ = D_REG
+		p.To.Type = D_REG
 		p.To.Reg = 4
 
 		p = obj.Appendp(ctxt, p)
 		p.As = ASUB
-		p.From.Type_ = D_REG
+		p.From.Type = D_REG
 		p.From.Reg = 3
-		p.To.Type_ = D_REG
+		p.To.Type = D_REG
 		p.To.Reg = 4
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AMOVD
-		p.From.Type_ = D_CONST
+		p.From.Type = D_CONST
 		p.From.Offset = int64(framesize) + obj.StackGuard - obj.StackSmall
-		p.To.Type_ = D_REG
+		p.To.Type = D_REG
 		p.To.Reg = REGTMP
 
 		p = obj.Appendp(ctxt, p)
 		p.As = ACMPU
-		p.From.Type_ = D_REG
+		p.From.Type = D_REG
 		p.From.Reg = REGTMP
-		p.To.Type_ = D_REG
+		p.To.Type = D_REG
 		p.To.Reg = 4
 	}
 
@@ -840,15 +840,15 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int) *obj.P
 	q1 = p
 
 	p.As = ABLT
-	p.To.Type_ = D_BRANCH
+	p.To.Type = D_BRANCH
 
 	// MOVD	LR, R5
 	p = obj.Appendp(ctxt, p)
 
 	p.As = AMOVD
-	p.From.Type_ = D_SPR
+	p.From.Type = D_SPR
 	p.From.Offset = D_LR
-	p.To.Type_ = D_REG
+	p.To.Type = D_REG
 	p.To.Reg = 5
 	if q != nil {
 		q.Pcond = p
@@ -858,7 +858,7 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int) *obj.P
 	p = obj.Appendp(ctxt, p)
 
 	p.As = ABL
-	p.To.Type_ = D_BRANCH
+	p.To.Type = D_BRANCH
 	if ctxt.Cursym.Cfunc != 0 {
 		p.To.Sym = obj.Linklookup(ctxt, "runtime.morestackc", 0)
 	} else {
@@ -870,7 +870,7 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, noctxt int) *obj.P
 	p = obj.Appendp(ctxt, p)
 
 	p.As = ABR
-	p.To.Type_ = D_BRANCH
+	p.To.Type = D_BRANCH
 	p.Pcond = ctxt.Cursym.Text.Link
 
 	// placeholder for q1's jump target
@@ -1019,7 +1019,7 @@ loop:
 		q = ctxt.Arch.Prg()
 		q.As = int16(a)
 		q.Lineno = p.Lineno
-		q.To.Type_ = D_BRANCH
+		q.To.Type = D_BRANCH
 		q.To.Offset = p.Pc
 		q.Pcond = p
 		p = q
diff --git a/src/cmd/internal/obj/sym.go b/src/cmd/internal/obj/sym.go
index 42d95bc9ee..855aeea8ec 100644
--- a/src/cmd/internal/obj/sym.go
+++ b/src/cmd/internal/obj/sym.go
@@ -234,7 +234,7 @@ func linknewsym(ctxt *Link, symb string, v int) *LSym {
 	s.Plt = -1
 	s.Got = -1
 	s.Name = symb
-	s.Type_ = 0
+	s.Type = 0
 	s.Version = int16(v)
 	s.Value = 0
 	s.Sig = 0
diff --git a/src/cmd/internal/obj/x86/anames6.go b/src/cmd/internal/obj/x86/anames6.go
index 9f5247122a..4d8a0b0346 100644
--- a/src/cmd/internal/obj/x86/anames6.go
+++ b/src/cmd/internal/obj/x86/anames6.go
@@ -3,7 +3,7 @@ package x86
 /*
  * this is the ranlib header
  */
-var anames6 = []string{
+var Anames = []string{
 	"XXX",
 	"AAA",
 	"AAD",
diff --git a/src/cmd/internal/obj/x86/asm6.go b/src/cmd/internal/obj/x86/asm6.go
index 82cd67a00a..0665a08754 100644
--- a/src/cmd/internal/obj/x86/asm6.go
+++ b/src/cmd/internal/obj/x86/asm6.go
@@ -2194,7 +2194,7 @@ func span6(ctxt *obj.Link, s *obj.LSym) {
 
 	for p = ctxt.Cursym.Text; p != nil; p = p.Link {
 		n = 0
-		if p.To.Type_ == D_BRANCH {
+		if p.To.Type == D_BRANCH {
 			if p.Pcond == nil {
 				p.Pcond = p
 			}
@@ -2207,7 +2207,7 @@ func span6(ctxt *obj.Link, s *obj.LSym) {
 		}
 		p.Back = uint8(n)
 		if p.As == AADJSP {
-			p.To.Type_ = D_SP
+			p.To.Type = D_SP
 			v = int32(-p.From.Offset)
 			p.From.Offset = int64(v)
 			p.As = int16(spadjop(ctxt, p, AADDL, AADDQ))
@@ -2232,7 +2232,7 @@ func span6(ctxt *obj.Link, s *obj.LSym) {
 		}
 
 		if p.As == AADJSP {
-			p.To.Type_ = D_SP
+			p.To.Type = D_SP
 			v = int32(-p.From.Offset)
 			p.From.Offset = int64(v)
 			p.As = int16(spadjop(ctxt, p, AADDL, AADDQ))
@@ -2519,7 +2519,7 @@ func instinit() {
 }
 
 func prefixof(ctxt *obj.Link, a *obj.Addr) int {
-	switch a.Type_ {
+	switch a.Type {
 	case D_INDIR + D_CS:
 		return 0x2e
 
@@ -2584,9 +2584,9 @@ func oclass(ctxt *obj.Link, a *obj.Addr) int {
 	var v int64
 	var l int32
 
-	if a.Type_ >= D_INDIR || a.Index != D_NONE {
+	if a.Type >= D_INDIR || a.Index != D_NONE {
 		if a.Index != D_NONE && a.Scale == 0 {
-			if a.Type_ == D_ADDR {
+			if a.Type == D_ADDR {
 				switch a.Index {
 				case D_EXTERN,
 					D_STATIC:
@@ -2609,7 +2609,7 @@ func oclass(ctxt *obj.Link, a *obj.Addr) int {
 		return Ym
 	}
 
-	switch a.Type_ {
+	switch a.Type {
 	case D_AL:
 		return Yal
 
@@ -2996,7 +2996,7 @@ func vaddr(ctxt *obj.Link, p *obj.Prog, a *obj.Addr, r *obj.Reloc) int64 {
 		*r = obj.Reloc{}
 	}
 
-	t = int(a.Type_)
+	t = int(a.Type)
 	v = a.Offset
 	if t == D_ADDR {
 		t = int(a.Index)
@@ -3012,20 +3012,20 @@ func vaddr(ctxt *obj.Link, p *obj.Prog, a *obj.Addr, r *obj.Reloc) int64 {
 
 		if isextern(s) != 0 {
 			r.Siz = 4
-			r.Type_ = obj.R_ADDR
+			r.Type = obj.R_ADDR
 		} else {
 
 			r.Siz = 4
-			r.Type_ = obj.R_PCREL
+			r.Type = obj.R_PCREL
 		}
 
 		r.Off = -1 // caller must fill in
 		r.Sym = s
 		r.Add = v
 		v = 0
-		if s.Type_ == obj.STLSBSS {
+		if s.Type == obj.STLSBSS {
 			r.Xadd = r.Add - int64(r.Siz)
-			r.Type_ = obj.R_TLS
+			r.Type = obj.R_TLS
 			r.Xsym = s
 		}
 
@@ -3035,7 +3035,7 @@ func vaddr(ctxt *obj.Link, p *obj.Prog, a *obj.Addr, r *obj.Reloc) int64 {
 			log.Fatalf("reloc")
 		}
 
-		r.Type_ = obj.R_TLS_LE
+		r.Type = obj.R_TLS_LE
 		r.Siz = 4
 		r.Off = -1 // caller must fill in
 		r.Add = v
@@ -3054,7 +3054,7 @@ func asmandsz(ctxt *obj.Link, p *obj.Prog, a *obj.Addr, r int, rex int, m64 int)
 
 	rex &= 0x40 | Rxr
 	v = int32(a.Offset)
-	t = int(a.Type_)
+	t = int(a.Type)
 	rel.Siz = 0
 	if a.Index != D_NONE && a.Index != D_TLS {
 		if t < D_INDIR {
@@ -3121,7 +3121,7 @@ func asmandsz(ctxt *obj.Link, p *obj.Prog, a *obj.Addr, r int, rex int, m64 int)
 
 	scale = int(a.Scale)
 	if t < D_INDIR {
-		switch a.Type_ {
+		switch a.Type {
 		default:
 			goto bad
 
@@ -3147,7 +3147,7 @@ func asmandsz(ctxt *obj.Link, p *obj.Prog, a *obj.Addr, r int, rex int, m64 int)
 
 	ctxt.Rexflag |= regrex[t]&Rxb | rex
 	if t == D_NONE || (D_CS <= t && t <= D_GS) || t == D_TLS {
-		if (a.Sym == nil || !(isextern(a.Sym) != 0)) && t == D_NONE && (a.Type_ == D_STATIC || a.Type_ == D_EXTERN) || ctxt.Asmode != 64 {
+		if (a.Sym == nil || !(isextern(a.Sym) != 0)) && t == D_NONE && (a.Type == D_STATIC || a.Type == D_EXTERN) || ctxt.Asmode != 64 {
 			ctxt.Andptr[0] = byte(0<<6 | 5<<0 | r<<3)
 			ctxt.Andptr = ctxt.Andptr[1:]
 			goto putrelv
@@ -3187,7 +3187,7 @@ func asmandsz(ctxt *obj.Link, p *obj.Prog, a *obj.Addr, r int, rex int, m64 int)
 	if t >= D_AX && t <= D_R15 {
 		if a.Index == D_TLS {
 			rel = obj.Reloc{}
-			rel.Type_ = obj.R_TLS_IE
+			rel.Type = obj.R_TLS_IE
 			rel.Siz = 4
 			rel.Sym = nil
 			rel.Add = int64(v)
@@ -3237,7 +3237,7 @@ bad:
 }
 
 func asmand(ctxt *obj.Link, p *obj.Prog, a *obj.Addr, ra *obj.Addr) {
-	asmandsz(ctxt, p, a, reg[ra.Type_], regrex[ra.Type_], 0)
+	asmandsz(ctxt, p, a, reg[ra.Type], regrex[ra.Type], 0)
 }
 
 func asmando(ctxt *obj.Link, p *obj.Prog, a *obj.Addr, o int) {
@@ -3245,8 +3245,8 @@ func asmando(ctxt *obj.Link, p *obj.Prog, a *obj.Addr, o int) {
 }
 
 func bytereg(a *obj.Addr, t *uint8) {
-	if a.Index == D_NONE && (a.Type_ >= D_AX && a.Type_ <= D_R15) {
-		a.Type_ = D_AL + (a.Type_ - D_AX)
+	if a.Index == D_NONE && (a.Type >= D_AX && a.Type <= D_R15) {
+		a.Type = D_AL + (a.Type - D_AX)
 		*t = 0
 	}
 }
@@ -3382,7 +3382,7 @@ var ymovtab = []Movtab{
 }
 
 func isax(a *obj.Addr) int {
-	switch a.Type_ {
+	switch a.Type {
 	case D_AX,
 		D_AL,
 		D_AH,
@@ -3401,11 +3401,11 @@ func subreg(p *obj.Prog, from int, to int) {
 		fmt.Printf("\n%v\ts/%v/%v/\n", p, Rconv(from), Rconv(to))
 	}
 
-	if int(p.From.Type_) == from {
-		p.From.Type_ = int16(to)
+	if int(p.From.Type) == from {
+		p.From.Type = int16(to)
 	}
-	if int(p.To.Type_) == from {
-		p.To.Type_ = int16(to)
+	if int(p.To.Type) == from {
+		p.To.Type = int16(to)
 	}
 
 	if int(p.From.Index) == from {
@@ -3416,11 +3416,11 @@ func subreg(p *obj.Prog, from int, to int) {
 	}
 
 	from += D_INDIR
-	if int(p.From.Type_) == from {
-		p.From.Type_ = int16(to + D_INDIR)
+	if int(p.From.Type) == from {
+		p.From.Type = int16(to + D_INDIR)
 	}
-	if int(p.To.Type_) == from {
-		p.To.Type_ = int16(to + D_INDIR)
+	if int(p.To.Type) == from {
+		p.To.Type = int16(to + D_INDIR)
 	}
 
 	if false { /*debug['Q']*/
@@ -3684,14 +3684,14 @@ found:
 	case Zaut_r:
 		ctxt.Andptr[0] = 0x8d
 		ctxt.Andptr = ctxt.Andptr[1:] /* leal */
-		if p.From.Type_ != D_ADDR {
+		if p.From.Type != D_ADDR {
 			ctxt.Diag("asmins: Zaut sb type ADDR")
 		}
-		p.From.Type_ = int16(p.From.Index)
+		p.From.Type = int16(p.From.Index)
 		p.From.Index = D_NONE
 		asmand(ctxt, p, &p.From, &p.To)
-		p.From.Index = uint8(p.From.Type_)
-		p.From.Type_ = D_ADDR
+		p.From.Index = uint8(p.From.Type)
+		p.From.Type = D_ADDR
 
 	case Zm_o:
 		ctxt.Andptr[0] = byte(op)
@@ -3726,7 +3726,7 @@ found:
 	case Zcallindreg:
 		r = obj.Addrel(ctxt.Cursym)
 		r.Off = int32(p.Pc)
-		r.Type_ = obj.R_CALLIND
+		r.Type = obj.R_CALLIND
 		r.Siz = 0
 		fallthrough
 
@@ -3771,15 +3771,15 @@ found:
 		ctxt.Andptr = ctxt.Andptr[1:]
 
 	case Zib_rp:
-		ctxt.Rexflag |= regrex[p.To.Type_] & (Rxb | 0x40)
-		ctxt.Andptr[0] = byte(op + reg[p.To.Type_])
+		ctxt.Rexflag |= regrex[p.To.Type] & (Rxb | 0x40)
+		ctxt.Andptr[0] = byte(op + reg[p.To.Type])
 		ctxt.Andptr = ctxt.Andptr[1:]
 		ctxt.Andptr[0] = byte(vaddr(ctxt, p, &p.From, nil))
 		ctxt.Andptr = ctxt.Andptr[1:]
 
 	case Zil_rp:
-		ctxt.Rexflag |= regrex[p.To.Type_] & Rxb
-		ctxt.Andptr[0] = byte(op + reg[p.To.Type_])
+		ctxt.Rexflag |= regrex[p.To.Type] & Rxb
+		ctxt.Andptr[0] = byte(op + reg[p.To.Type])
 		ctxt.Andptr = ctxt.Andptr[1:]
 		if o.prefix == Pe {
 			v = vaddr(ctxt, p, &p.From, nil)
@@ -3795,7 +3795,7 @@ found:
 	case Zo_iw:
 		ctxt.Andptr[0] = byte(op)
 		ctxt.Andptr = ctxt.Andptr[1:]
-		if p.From.Type_ != D_NONE {
+		if p.From.Type != D_NONE {
 			v = vaddr(ctxt, p, &p.From, nil)
 			ctxt.Andptr[0] = byte(v)
 			ctxt.Andptr = ctxt.Andptr[1:]
@@ -3811,10 +3811,10 @@ found:
 			//print("zero: %llux %P\n", v, p);
 			ctxt.Rexflag &^= (0x40 | Rxw)
 
-			ctxt.Rexflag |= regrex[p.To.Type_] & Rxb
-			ctxt.Andptr[0] = byte(0xb8 + reg[p.To.Type_])
+			ctxt.Rexflag |= regrex[p.To.Type] & Rxb
+			ctxt.Andptr[0] = byte(0xb8 + reg[p.To.Type])
 			ctxt.Andptr = ctxt.Andptr[1:]
-			if rel.Type_ != 0 {
+			if rel.Type != 0 {
 				r = obj.Addrel(ctxt.Cursym)
 				*r = rel
 				r.Off = int32(p.Pc + int64(-cap(ctxt.Andptr)+cap(ctxt.And[:])))
@@ -3833,11 +3833,11 @@ found:
 		} else {
 
 			//print("all: %llux %P\n", v, p);
-			ctxt.Rexflag |= regrex[p.To.Type_] & Rxb
+			ctxt.Rexflag |= regrex[p.To.Type] & Rxb
 
-			ctxt.Andptr[0] = byte(op + reg[p.To.Type_])
+			ctxt.Andptr[0] = byte(op + reg[p.To.Type])
 			ctxt.Andptr = ctxt.Andptr[1:]
-			if rel.Type_ != 0 {
+			if rel.Type != 0 {
 				r = obj.Addrel(ctxt.Cursym)
 				*r = rel
 				r.Off = int32(p.Pc + int64(-cap(ctxt.Andptr)+cap(ctxt.And[:])))
@@ -3914,13 +3914,13 @@ found:
 		}
 
 	case Z_rp:
-		ctxt.Rexflag |= regrex[p.To.Type_] & (Rxb | 0x40)
-		ctxt.Andptr[0] = byte(op + reg[p.To.Type_])
+		ctxt.Rexflag |= regrex[p.To.Type] & (Rxb | 0x40)
+		ctxt.Andptr[0] = byte(op + reg[p.To.Type])
 		ctxt.Andptr = ctxt.Andptr[1:]
 
 	case Zrp_:
-		ctxt.Rexflag |= regrex[p.From.Type_] & (Rxb | 0x40)
-		ctxt.Andptr[0] = byte(op + reg[p.From.Type_])
+		ctxt.Rexflag |= regrex[p.From.Type] & (Rxb | 0x40)
+		ctxt.Andptr[0] = byte(op + reg[p.From.Type])
 		ctxt.Andptr = ctxt.Andptr[1:]
 
 	case Zclr:
@@ -3941,7 +3941,7 @@ found:
 		r.Off = int32(p.Pc + int64(-cap(ctxt.Andptr)+cap(ctxt.And[:])))
 		r.Sym = p.To.Sym
 		r.Add = p.To.Offset
-		r.Type_ = obj.R_CALL
+		r.Type = obj.R_CALL
 		r.Siz = 4
 		put4(ctxt, 0)
 
@@ -3961,7 +3961,7 @@ found:
 			r = obj.Addrel(ctxt.Cursym)
 			r.Off = int32(p.Pc + int64(-cap(ctxt.Andptr)+cap(ctxt.And[:])))
 			r.Sym = p.To.Sym
-			r.Type_ = obj.R_PCREL
+			r.Type = obj.R_PCREL
 			r.Siz = 4
 			put4(ctxt, 0)
 			break
@@ -4129,9 +4129,9 @@ bad:
 		 */
 		pp = *p
 
-		z = int(p.From.Type_)
+		z = int(p.From.Type)
 		if z >= D_BP && z <= D_DI {
-			if isax(&p.To) != 0 || p.To.Type_ == D_NONE {
+			if isax(&p.To) != 0 || p.To.Type == D_NONE {
 				// We certainly don't want to exchange
 				// with AX if the op is MUL or DIV.
 				ctxt.Andptr[0] = 0x87
@@ -4155,7 +4155,7 @@ bad:
 			return
 		}
 
-		z = int(p.To.Type_)
+		z = int(p.To.Type)
 		if z >= D_BP && z <= D_DI {
 			if isax(&p.From) != 0 {
 				ctxt.Andptr[0] = 0x87
@@ -4180,7 +4180,7 @@ bad:
 		}
 	}
 
-	ctxt.Diag("doasm: notfound from=%x to=%x %v", uint16(p.From.Type_), uint16(p.To.Type_), p)
+	ctxt.Diag("doasm: notfound from=%x to=%x %v", uint16(p.From.Type), uint16(p.To.Type), p)
 	return
 
 mfound:
@@ -4214,7 +4214,7 @@ mfound:
 		ctxt.Andptr[0] = t[1]
 		ctxt.Andptr = ctxt.Andptr[1:]
 		asmando(ctxt, p, &p.To, int(t[2]))
-		ctxt.Rexflag |= regrex[p.From.Type_] & (Rxr | 0x40)
+		ctxt.Rexflag |= regrex[p.From.Type] & (Rxr | 0x40)
 
 	case 4: /* m,r - 2op */
 		ctxt.Andptr[0] = t[0]
@@ -4223,7 +4223,7 @@ mfound:
 		ctxt.Andptr[0] = t[1]
 		ctxt.Andptr = ctxt.Andptr[1:]
 		asmando(ctxt, p, &p.From, int(t[2]))
-		ctxt.Rexflag |= regrex[p.To.Type_] & (Rxr | 0x40)
+		ctxt.Rexflag |= regrex[p.To.Type] & (Rxr | 0x40)
 
 	case 5: /* load full pointer, trash heap */
 		if t[0] != 0 {
@@ -4279,7 +4279,7 @@ mfound:
 			t = t[1:]
 		}
 
-		z = int(p.From.Type_)
+		z = int(p.From.Type)
 		switch z {
 		default:
 			goto bad
@@ -4318,7 +4318,7 @@ mfound:
 				ctxt.Plan9privates = obj.Linklookup(ctxt, "_privates", 0)
 			}
 			pp.From = obj.Addr{}
-			pp.From.Type_ = D_EXTERN
+			pp.From.Type = D_EXTERN
 			pp.From.Sym = ctxt.Plan9privates
 			pp.From.Offset = 0
 			pp.From.Index = D_NONE
@@ -4331,7 +4331,7 @@ mfound:
 		case obj.Hsolaris: // TODO(rsc): Delete Hsolaris from list. Should not use this code. See progedit in obj6.c.
 			pp.From = p.From
 
-			pp.From.Type_ = D_INDIR + D_NONE
+			pp.From.Type = D_INDIR + D_NONE
 			pp.From.Offset = 0
 			pp.From.Index = D_NONE
 			pp.From.Scale = 0
@@ -4346,7 +4346,7 @@ mfound:
 		case obj.Hwindows:
 			pp.From = p.From
 
-			pp.From.Type_ = D_INDIR + D_GS
+			pp.From.Type = D_INDIR + D_GS
 			pp.From.Offset = 0x28
 			pp.From.Index = D_NONE
 			pp.From.Scale = 0
@@ -4432,7 +4432,7 @@ func asmins(ctxt *obj.Link, p *obj.Prog) {
 		r.Off = 0
 		r.Siz = 0
 		r.Sym = p.From.Sym
-		r.Type_ = obj.R_USEFIELD
+		r.Type = obj.R_USEFIELD
 		return
 	}
 
@@ -4469,12 +4469,12 @@ func asmins(ctxt *obj.Link, p *obj.Prog) {
 
 		case ACALL,
 			AJMP:
-			if D_AX <= p.To.Type_ && p.To.Type_ <= D_DI {
+			if D_AX <= p.To.Type && p.To.Type <= D_DI {
 				// ANDL $~31, reg
 				ctxt.Andptr[0] = 0x83
 				ctxt.Andptr = ctxt.Andptr[1:]
 
-				ctxt.Andptr[0] = byte(0xe0 | (p.To.Type_ - D_AX))
+				ctxt.Andptr[0] = byte(0xe0 | (p.To.Type - D_AX))
 				ctxt.Andptr = ctxt.Andptr[1:]
 				ctxt.Andptr[0] = 0xe0
 				ctxt.Andptr = ctxt.Andptr[1:]
@@ -4485,18 +4485,18 @@ func asmins(ctxt *obj.Link, p *obj.Prog) {
 
 				ctxt.Andptr[0] = 0x01
 				ctxt.Andptr = ctxt.Andptr[1:]
-				ctxt.Andptr[0] = byte(0xf8 | (p.To.Type_ - D_AX))
+				ctxt.Andptr[0] = byte(0xf8 | (p.To.Type - D_AX))
 				ctxt.Andptr = ctxt.Andptr[1:]
 			}
 
-			if D_R8 <= p.To.Type_ && p.To.Type_ <= D_R15 {
+			if D_R8 <= p.To.Type && p.To.Type <= D_R15 {
 				// ANDL $~31, reg
 				ctxt.Andptr[0] = 0x41
 				ctxt.Andptr = ctxt.Andptr[1:]
 
 				ctxt.Andptr[0] = 0x83
 				ctxt.Andptr = ctxt.Andptr[1:]
-				ctxt.Andptr[0] = byte(0xe0 | (p.To.Type_ - D_R8))
+				ctxt.Andptr[0] = byte(0xe0 | (p.To.Type - D_R8))
 				ctxt.Andptr = ctxt.Andptr[1:]
 				ctxt.Andptr[0] = 0xe0
 				ctxt.Andptr = ctxt.Andptr[1:]
@@ -4507,7 +4507,7 @@ func asmins(ctxt *obj.Link, p *obj.Prog) {
 
 				ctxt.Andptr[0] = 0x01
 				ctxt.Andptr = ctxt.Andptr[1:]
-				ctxt.Andptr[0] = byte(0xf8 | (p.To.Type_ - D_R8))
+				ctxt.Andptr[0] = byte(0xf8 | (p.To.Type - D_R8))
 				ctxt.Andptr = ctxt.Andptr[1:]
 			}
 
@@ -4593,13 +4593,13 @@ func asmins(ctxt *obj.Link, p *obj.Prog) {
 		if ctxt.Rexflag != 0 {
 			r.Off++
 		}
-		if r.Type_ == obj.R_PCREL || r.Type_ == obj.R_CALL {
+		if r.Type == obj.R_PCREL || r.Type == obj.R_CALL {
 			r.Add -= p.Pc + int64(n) - (int64(r.Off) + int64(r.Siz))
 		}
 	}
 
 	if ctxt.Headtype == obj.Hnacl && p.As != ACMPL && p.As != ACMPQ {
-		switch p.To.Type_ {
+		switch p.To.Type {
 		case D_SP:
 			copy(ctxt.Andptr, naclspfix)
 			ctxt.Andptr = ctxt.Andptr[len(naclspfix):]
diff --git a/src/cmd/internal/obj/x86/list6.go b/src/cmd/internal/obj/x86/list6.go
index 985d921993..df061c75e2 100644
--- a/src/cmd/internal/obj/x86/list6.go
+++ b/src/cmd/internal/obj/x86/list6.go
@@ -82,7 +82,7 @@ func Pconv(p *obj.Prog) string {
 func Aconv(i int) string {
 	var fp string
 
-	fp += anames6[i]
+	fp += Anames[i]
 	return fp
 }
 
@@ -93,7 +93,7 @@ func Dconv(p *obj.Prog, flag int, a *obj.Addr) string {
 
 	var i int
 
-	i = int(a.Type_)
+	i = int(a.Type)
 
 	if flag&fmtLong != 0 /*untyped*/ {
 		if i == D_CONST {
@@ -173,11 +173,11 @@ func Dconv(p *obj.Prog, flag int, a *obj.Addr) string {
 		str = fmt.Sprintf("$\"%q\"", a.U.Sval)
 
 	case D_ADDR:
-		a.Type_ = int16(a.Index)
+		a.Type = int16(a.Index)
 		a.Index = D_NONE
 		str = fmt.Sprintf("$%v", Dconv(p, 0, a))
-		a.Index = uint8(a.Type_)
-		a.Type_ = D_ADDR
+		a.Index = uint8(a.Type)
+		a.Type = D_ADDR
 		goto conv
 	}
 
@@ -192,7 +192,7 @@ conv:
 	return fp
 }
 
-var regstr = []string{
+var Register = []string{
 	"AL", /* [D_AL] */
 	"CL",
 	"DL",
@@ -313,7 +313,7 @@ func Rconv(r int) string {
 	var fp string
 
 	if r >= D_AL && r <= D_NONE {
-		str = fmt.Sprintf("%s", regstr[r-D_AL])
+		str = fmt.Sprintf("%s", Register[r-D_AL])
 	} else {
 
 		str = fmt.Sprintf("gok(%d)", r)
diff --git a/src/cmd/internal/obj/x86/obj6.go b/src/cmd/internal/obj/x86/obj6.go
index bf9037d1d2..aacc2564b9 100644
--- a/src/cmd/internal/obj/x86/obj6.go
+++ b/src/cmd/internal/obj/x86/obj6.go
@@ -42,25 +42,25 @@ var zprg = obj.Prog{
 	Back: 2,
 	As:   AGOK,
 	From: obj.Addr{
-		Type_: D_NONE,
+		Type:  D_NONE,
 		Index: D_NONE,
 	},
 	To: obj.Addr{
-		Type_: D_NONE,
+		Type:  D_NONE,
 		Index: D_NONE,
 	},
 }
 
 func nopout(p *obj.Prog) {
 	p.As = ANOP
-	p.From.Type_ = D_NONE
-	p.To.Type_ = D_NONE
+	p.From.Type = D_NONE
+	p.To.Type = D_NONE
 }
 
 func symtype(a *obj.Addr) int {
 	var t int
 
-	t = int(a.Type_)
+	t = int(a.Type)
 	if t == D_ADDR {
 		t = int(a.Index)
 	}
@@ -148,18 +148,18 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 		// TODO(rsc): Remove the Hsolaris special case. It exists only to
 		// guarantee we are producing byte-identical binaries as before this code.
 		// But it should be unnecessary.
-		if (p.As == AMOVQ || p.As == AMOVL) && p.From.Type_ == D_TLS && D_AX <= p.To.Type_ && p.To.Type_ <= D_R15 && ctxt.Headtype != obj.Hsolaris {
+		if (p.As == AMOVQ || p.As == AMOVL) && p.From.Type == D_TLS && D_AX <= p.To.Type && p.To.Type <= D_R15 && ctxt.Headtype != obj.Hsolaris {
 
 			nopout(p)
 		}
-		if p.From.Index == D_TLS && D_INDIR+D_AX <= p.From.Type_ && p.From.Type_ <= D_INDIR+D_R15 {
-			p.From.Type_ = D_INDIR + D_TLS
+		if p.From.Index == D_TLS && D_INDIR+D_AX <= p.From.Type && p.From.Type <= D_INDIR+D_R15 {
+			p.From.Type = D_INDIR + D_TLS
 			p.From.Scale = 0
 			p.From.Index = D_NONE
 		}
 
-		if p.To.Index == D_TLS && D_INDIR+D_AX <= p.To.Type_ && p.To.Type_ <= D_INDIR+D_R15 {
-			p.To.Type_ = D_INDIR + D_TLS
+		if p.To.Index == D_TLS && D_INDIR+D_AX <= p.To.Type && p.To.Type <= D_INDIR+D_R15 {
+			p.To.Type = D_INDIR + D_TLS
 			p.To.Scale = 0
 			p.To.Index = D_NONE
 		}
@@ -172,16 +172,16 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 		//	MOVQ TLS, BX
 		//	MOVQ off(BX)(TLS*1), BX
 		// This allows the C compilers to emit references to m and g using the direct off(TLS) form.
-		if (p.As == AMOVQ || p.As == AMOVL) && p.From.Type_ == D_INDIR+D_TLS && D_AX <= p.To.Type_ && p.To.Type_ <= D_R15 {
+		if (p.As == AMOVQ || p.As == AMOVL) && p.From.Type == D_INDIR+D_TLS && D_AX <= p.To.Type && p.To.Type <= D_R15 {
 
 			q = obj.Appendp(ctxt, p)
 			q.As = p.As
 			q.From = p.From
-			q.From.Type_ = D_INDIR + p.To.Type_
+			q.From.Type = D_INDIR + p.To.Type
 			q.From.Index = D_TLS
 			q.From.Scale = 2 // TODO: use 1
 			q.To = p.To
-			p.From.Type_ = D_TLS
+			p.From.Type = D_TLS
 			p.From.Index = D_NONE
 			p.From.Offset = 0
 		}
@@ -212,7 +212,7 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 
 	switch p.As {
 	case AMODE:
-		if p.From.Type_ == D_CONST || p.From.Type_ == D_INDIR+D_NONE {
+		if p.From.Type == D_CONST || p.From.Type == D_INDIR+D_NONE {
 			switch int(p.From.Offset) {
 			case 16,
 				32,
@@ -232,8 +232,8 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 	case ACALL,
 		AJMP,
 		ARET:
-		if (p.To.Type_ == D_EXTERN || p.To.Type_ == D_STATIC) && p.To.Sym != nil {
-			p.To.Type_ = D_BRANCH
+		if (p.To.Type == D_EXTERN || p.To.Type == D_STATIC) && p.To.Sym != nil {
+			p.To.Type = D_BRANCH
 		}
 		break
 	}
@@ -243,13 +243,13 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 
 	// Convert AMOVSS $(0), Xx to AXORPS Xx, Xx
 	case AMOVSS:
-		if p.From.Type_ == D_FCONST {
+		if p.From.Type == D_FCONST {
 
 			if p.From.U.Dval == 0 {
-				if p.To.Type_ >= D_X0 {
-					if p.To.Type_ <= D_X15 {
+				if p.To.Type >= D_X0 {
+					if p.To.Type <= D_X15 {
 						p.As = AXORPS
-						p.From.Type_ = p.To.Type_
+						p.From.Type = p.To.Type
 						p.From.Index = p.To.Index
 						break
 					}
@@ -275,7 +275,7 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 		ADIVSS,
 		ACOMISS,
 		AUCOMISS:
-		if p.From.Type_ == D_FCONST {
+		if p.From.Type == D_FCONST {
 
 			var i32 uint32
 			var f32 float32
@@ -283,26 +283,26 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 			i32 = math.Float32bits(f32)
 			literal = fmt.Sprintf("$f32.%08x", i32)
 			s = obj.Linklookup(ctxt, literal, 0)
-			if s.Type_ == 0 {
-				s.Type_ = obj.SRODATA
+			if s.Type == 0 {
+				s.Type = obj.SRODATA
 				obj.Adduint32(ctxt, s, i32)
 				s.Reachable = 0
 			}
 
-			p.From.Type_ = D_EXTERN
+			p.From.Type = D_EXTERN
 			p.From.Sym = s
 			p.From.Offset = 0
 		}
 
 		// Convert AMOVSD $(0), Xx to AXORPS Xx, Xx
 	case AMOVSD:
-		if p.From.Type_ == D_FCONST {
+		if p.From.Type == D_FCONST {
 
 			if p.From.U.Dval == 0 {
-				if p.To.Type_ >= D_X0 {
-					if p.To.Type_ <= D_X15 {
+				if p.To.Type >= D_X0 {
+					if p.To.Type <= D_X15 {
 						p.As = AXORPS
-						p.From.Type_ = p.To.Type_
+						p.From.Type = p.To.Type
 						p.From.Index = p.To.Index
 						break
 					}
@@ -327,19 +327,19 @@ func progedit(ctxt *obj.Link, p *obj.Prog) {
 		ADIVSD,
 		ACOMISD,
 		AUCOMISD:
-		if p.From.Type_ == D_FCONST {
+		if p.From.Type == D_FCONST {
 
 			var i64 uint64
 			i64 = math.Float64bits(p.From.U.Dval)
 			literal = fmt.Sprintf("$f64.%016x", i64)
 			s = obj.Linklookup(ctxt, literal, 0)
-			if s.Type_ == 0 {
-				s.Type_ = obj.SRODATA
+			if s.Type == 0 {
+				s.Type = obj.SRODATA
 				obj.Adduint64(ctxt, s, i64)
 				s.Reachable = 0
 			}
 
-			p.From.Type_ = D_EXTERN
+			p.From.Type = D_EXTERN
 			p.From.Sym = s
 			p.From.Offset = 0
 		}
@@ -353,18 +353,18 @@ func nacladdr(ctxt *obj.Link, p *obj.Prog, a *obj.Addr) {
 		return
 	}
 
-	if a.Type_ == D_BP || a.Type_ == D_INDIR+D_BP {
+	if a.Type == D_BP || a.Type == D_INDIR+D_BP {
 		ctxt.Diag("invalid address: %v", p)
 		return
 	}
 
-	if a.Type_ == D_INDIR+D_TLS {
-		a.Type_ = D_INDIR + D_BP
-	} else if a.Type_ == D_TLS {
-		a.Type_ = D_BP
+	if a.Type == D_INDIR+D_TLS {
+		a.Type = D_INDIR + D_BP
+	} else if a.Type == D_TLS {
+		a.Type = D_BP
 	}
-	if D_INDIR <= a.Type_ && a.Type_ <= D_INDIR+D_INDIR {
-		switch a.Type_ {
+	if D_INDIR <= a.Type && a.Type <= D_INDIR+D_INDIR {
+		switch a.Type {
 		// all ok
 		case D_INDIR + D_BP,
 			D_INDIR + D_SP,
@@ -375,11 +375,11 @@ func nacladdr(ctxt *obj.Link, p *obj.Prog, a *obj.Addr) {
 			if a.Index != D_NONE {
 				ctxt.Diag("invalid address %v", p)
 			}
-			a.Index = uint8(a.Type_ - D_INDIR)
+			a.Index = uint8(a.Type - D_INDIR)
 			if a.Index != D_NONE {
 				a.Scale = 1
 			}
-			a.Type_ = D_INDIR + D_R15
+			a.Type = D_INDIR + D_R15
 			break
 		}
 	}
@@ -469,7 +469,7 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 		}
 		p = obj.Appendp(ctxt, p)
 		p.As = AADJSP
-		p.From.Type_ = D_CONST
+		p.From.Type = D_CONST
 		p.From.Offset = int64(autoffset)
 		p.Spadj = autoffset
 	} else {
@@ -510,63 +510,63 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 		p = obj.Appendp(ctxt, p)
 
 		p.As = AMOVQ
-		p.From.Type_ = D_INDIR + D_CX
+		p.From.Type = D_INDIR + D_CX
 		p.From.Offset = 4 * int64(ctxt.Arch.Ptrsize) // G.panic
-		p.To.Type_ = D_BX
+		p.To.Type = D_BX
 		if ctxt.Headtype == obj.Hnacl {
 			p.As = AMOVL
-			p.From.Type_ = D_INDIR + D_R15
+			p.From.Type = D_INDIR + D_R15
 			p.From.Scale = 1
 			p.From.Index = D_CX
 		}
 
 		p = obj.Appendp(ctxt, p)
 		p.As = ATESTQ
-		p.From.Type_ = D_BX
-		p.To.Type_ = D_BX
+		p.From.Type = D_BX
+		p.To.Type = D_BX
 		if ctxt.Headtype == obj.Hnacl {
 			p.As = ATESTL
 		}
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AJEQ
-		p.To.Type_ = D_BRANCH
+		p.To.Type = D_BRANCH
 		p1 = p
 
 		p = obj.Appendp(ctxt, p)
 		p.As = ALEAQ
-		p.From.Type_ = D_INDIR + D_SP
+		p.From.Type = D_INDIR + D_SP
 		p.From.Offset = int64(autoffset) + 8
-		p.To.Type_ = D_DI
+		p.To.Type = D_DI
 		if ctxt.Headtype == obj.Hnacl {
 			p.As = ALEAL
 		}
 
 		p = obj.Appendp(ctxt, p)
 		p.As = ACMPQ
-		p.From.Type_ = D_INDIR + D_BX
+		p.From.Type = D_INDIR + D_BX
 		p.From.Offset = 0 // Panic.argp
-		p.To.Type_ = D_DI
+		p.To.Type = D_DI
 		if ctxt.Headtype == obj.Hnacl {
 			p.As = ACMPL
-			p.From.Type_ = D_INDIR + D_R15
+			p.From.Type = D_INDIR + D_R15
 			p.From.Scale = 1
 			p.From.Index = D_BX
 		}
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AJNE
-		p.To.Type_ = D_BRANCH
+		p.To.Type = D_BRANCH
 		p2 = p
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AMOVQ
-		p.From.Type_ = D_SP
-		p.To.Type_ = D_INDIR + D_BX
+		p.From.Type = D_SP
+		p.To.Type = D_INDIR + D_BX
 		p.To.Offset = 0 // Panic.argp
 		if ctxt.Headtype == obj.Hnacl {
 			p.As = AMOVL
-			p.To.Type_ = D_INDIR + D_R15
+			p.To.Type = D_INDIR + D_R15
 			p.To.Scale = 1
 			p.To.Index = D_BX
 		}
@@ -584,20 +584,20 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 		p = obj.Appendp(ctxt, p)
 
 		p.As = AMOVQ
-		p.From.Type_ = D_SP
-		p.To.Type_ = D_DI
+		p.From.Type = D_SP
+		p.To.Type = D_DI
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AMOVQ
-		p.From.Type_ = D_CONST
+		p.From.Type = D_CONST
 		p.From.Offset = int64(autoffset) / 8
-		p.To.Type_ = D_CX
+		p.To.Type = D_CX
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AMOVQ
-		p.From.Type_ = D_CONST
+		p.From.Type = D_CONST
 		p.From.Offset = 0
-		p.To.Type_ = D_AX
+		p.To.Type = D_AX
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AREP
@@ -608,14 +608,14 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 
 	for ; p != nil; p = p.Link {
 		pcsize = int(p.Mode) / 8
-		a = int(p.From.Type_)
+		a = int(p.From.Type)
 		if a == D_AUTO {
 			p.From.Offset += int64(deltasp)
 		}
 		if a == D_PARAM {
 			p.From.Offset += int64(deltasp) + int64(pcsize)
 		}
-		a = int(p.To.Type_)
+		a = int(p.To.Type)
 		if a == D_AUTO {
 			p.To.Offset += int64(deltasp)
 		}
@@ -673,7 +673,7 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 
 		if autoffset != 0 {
 			p.As = AADJSP
-			p.From.Type_ = D_CONST
+			p.From.Type = D_CONST
 			p.From.Offset = int64(-autoffset)
 			p.Spadj = -autoffset
 			p = obj.Appendp(ctxt, p)
@@ -694,13 +694,13 @@ func addstacksplit(ctxt *obj.Link, cursym *obj.LSym) {
 
 func indir_cx(ctxt *obj.Link, a *obj.Addr) {
 	if ctxt.Headtype == obj.Hnacl {
-		a.Type_ = D_INDIR + D_R15
+		a.Type = D_INDIR + D_R15
 		a.Index = D_CX
 		a.Scale = 1
 		return
 	}
 
-	a.Type_ = D_INDIR + D_CX
+	a.Type = D_INDIR + D_CX
 }
 
 // Append code to p to load g into cx.
@@ -716,9 +716,9 @@ func load_g_cx(ctxt *obj.Link, p *obj.Prog) *obj.Prog {
 	if ctxt.Arch.Ptrsize == 4 {
 		p.As = AMOVL
 	}
-	p.From.Type_ = D_INDIR + D_TLS
+	p.From.Type = D_INDIR + D_TLS
 	p.From.Offset = 0
-	p.To.Type_ = D_CX
+	p.To.Type = D_CX
 
 	next = p.Link
 	progedit(ctxt, p)
@@ -767,7 +767,7 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, textarg int32, noc
 		p = obj.Appendp(ctxt, p)
 
 		p.As = int16(cmp)
-		p.From.Type_ = D_SP
+		p.From.Type = D_SP
 		indir_cx(ctxt, &p.To)
 		p.To.Offset = 2 * int64(ctxt.Arch.Ptrsize) // G.stackguard0
 		if ctxt.Cursym.Cfunc != 0 {
@@ -780,13 +780,13 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, textarg int32, noc
 		p = obj.Appendp(ctxt, p)
 
 		p.As = int16(lea)
-		p.From.Type_ = D_INDIR + D_SP
+		p.From.Type = D_INDIR + D_SP
 		p.From.Offset = -(int64(framesize) - obj.StackSmall)
-		p.To.Type_ = D_AX
+		p.To.Type = D_AX
 
 		p = obj.Appendp(ctxt, p)
 		p.As = int16(cmp)
-		p.From.Type_ = D_AX
+		p.From.Type = D_AX
 		indir_cx(ctxt, &p.To)
 		p.To.Offset = 2 * int64(ctxt.Arch.Ptrsize) // G.stackguard0
 		if ctxt.Cursym.Cfunc != 0 {
@@ -817,34 +817,34 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, textarg int32, noc
 		if ctxt.Cursym.Cfunc != 0 {
 			p.From.Offset = 3 * int64(ctxt.Arch.Ptrsize) // G.stackguard1
 		}
-		p.To.Type_ = D_SI
+		p.To.Type = D_SI
 
 		p = obj.Appendp(ctxt, p)
 		p.As = int16(cmp)
-		p.From.Type_ = D_SI
-		p.To.Type_ = D_CONST
+		p.From.Type = D_SI
+		p.To.Type = D_CONST
 		p.To.Offset = obj.StackPreempt
 
 		p = obj.Appendp(ctxt, p)
 		p.As = AJEQ
-		p.To.Type_ = D_BRANCH
+		p.To.Type = D_BRANCH
 		q1 = p
 
 		p = obj.Appendp(ctxt, p)
 		p.As = int16(lea)
-		p.From.Type_ = D_INDIR + D_SP
+		p.From.Type = D_INDIR + D_SP
 		p.From.Offset = obj.StackGuard
-		p.To.Type_ = D_AX
+		p.To.Type = D_AX
 
 		p = obj.Appendp(ctxt, p)
 		p.As = int16(sub)
-		p.From.Type_ = D_SI
-		p.To.Type_ = D_AX
+		p.From.Type = D_SI
+		p.To.Type = D_AX
 
 		p = obj.Appendp(ctxt, p)
 		p.As = int16(cmp)
-		p.From.Type_ = D_AX
-		p.To.Type_ = D_CONST
+		p.From.Type = D_AX
+		p.To.Type = D_CONST
 		p.To.Offset = int64(framesize) + (obj.StackGuard - obj.StackSmall)
 	}
 
@@ -852,12 +852,12 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, textarg int32, noc
 	p = obj.Appendp(ctxt, p)
 
 	p.As = AJHI
-	p.To.Type_ = D_BRANCH
+	p.To.Type = D_BRANCH
 	q = p
 
 	p = obj.Appendp(ctxt, p)
 	p.As = ACALL
-	p.To.Type_ = D_BRANCH
+	p.To.Type = D_BRANCH
 	if ctxt.Cursym.Cfunc != 0 {
 		p.To.Sym = obj.Linklookup(ctxt, "runtime.morestackc", 0)
 	} else {
@@ -867,7 +867,7 @@ func stacksplit(ctxt *obj.Link, p *obj.Prog, framesize int32, textarg int32, noc
 
 	p = obj.Appendp(ctxt, p)
 	p.As = AJMP
-	p.To.Type_ = D_BRANCH
+	p.To.Type = D_BRANCH
 	p.Pcond = ctxt.Cursym.Text.Link
 
 	if q != nil {
@@ -967,7 +967,7 @@ func relinv(a int) int {
 		return AJOS
 	}
 
-	log.Fatalf("unknown relation: %s", anames6[a])
+	log.Fatalf("unknown relation: %s", Anames[a])
 	return 0
 }
 
@@ -1054,7 +1054,7 @@ loop:
 		q = ctxt.Arch.Prg()
 		q.As = AJMP
 		q.Lineno = p.Lineno
-		q.To.Type_ = D_BRANCH
+		q.To.Type = D_BRANCH
 		q.To.Offset = p.Pc
 		q.Pcond = p
 		p = q
@@ -1087,7 +1087,7 @@ loop:
 		if q != nil {
 			p.Link = q
 		}
-		if p.From.Type_ == D_CONST {
+		if p.From.Type == D_CONST {
 			if p.From.Offset == 1 {
 				/*
 				 * expect conditional jump to be taken.
diff --git a/src/cmd/new5a/a.y b/src/cmd/new5a/a.y
index 2ef3907f72..03ea6bf861 100644
--- a/src/cmd/new5a/a.y
+++ b/src/cmd/new5a/a.y
@@ -179,7 +179,7 @@ inst:
 		var g obj.Addr
 
 		g = nullgen;
-		g.Type_ = D_CONST;
+		g.Type = D_CONST;
 		g.Offset = int64($6);
 		outcode($1, $2, &$3, NREG, &g);
 	}
@@ -188,7 +188,7 @@ inst:
 		var g obj.Addr
 
 		g = nullgen;
-		g.Type_ = D_CONST;
+		g.Type = D_CONST;
 		g.Offset = int64($4);
 		outcode($1, $2, &g, NREG, &$7);
 	}
@@ -220,21 +220,21 @@ inst:
 |	LTYPEB name ',' imm
 	{
 		asm.Settext($2.Sym);
-		$4.Type_ = D_CONST2;
+		$4.Type = D_CONST2;
 		$4.Offset2 = -obj.ArgsSizeUnknown;
 		outcode($1, Always, &$2, 0, &$4);
 	}
 |	LTYPEB name ',' con ',' imm
 	{
 		asm.Settext($2.Sym);
-		$6.Type_ = D_CONST2;
+		$6.Type = D_CONST2;
 		$6.Offset2 = -obj.ArgsSizeUnknown;
 		outcode($1, Always, &$2, $4, &$6);
 	}
 |	LTYPEB name ',' con ',' imm '-' con
 	{
 		asm.Settext($2.Sym);
-		$6.Type_ = D_CONST2;
+		$6.Type = D_CONST2;
 		$6.Offset2 = $8;
 		outcode($1, Always, &$2, $4, &$6);
 	}
@@ -286,7 +286,7 @@ inst:
 		var g obj.Addr
 
 		g = nullgen;
-		g.Type_ = D_CONST;
+		g.Type = D_CONST;
 		g.Offset = int64(
 			(0xe << 24) |		/* opcode */
 			($1 << 20) |		/* MCR/MRC */
@@ -313,7 +313,7 @@ inst:
  */
 |	LTYPEN cond reg ',' reg ',' reg ',' spreg
 	{
-		$7.Type_ = D_REGREG2;
+		$7.Type = D_REGREG2;
 		$7.Offset = int64($9);
 		outcode($1, $2, &$3, int32($5.Reg), &$7);
 	}
@@ -329,7 +329,7 @@ inst:
  */
 |	LTYPEPC gen ',' gen
 	{
-		if $2.Type_ != D_CONST || $4.Type_ != D_CONST {
+		if $2.Type != D_CONST || $4.Type != D_CONST {
 			yyerror("arguments to PCDATA must be integer constants")
 		}
 		outcode($1, Always, &$2, NREG, &$4);
@@ -339,10 +339,10 @@ inst:
  */
 |	LTYPEF gen ',' gen
 	{
-		if $2.Type_ != D_CONST {
+		if $2.Type != D_CONST {
 			yyerror("index for FUNCDATA must be integer constant")
 		}
-		if $4.Type_ != D_EXTERN && $4.Type_ != D_STATIC && $4.Type_ != D_OREG {
+		if $4.Type != D_EXTERN && $4.Type != D_STATIC && $4.Type != D_OREG {
 			yyerror("value for FUNCDATA must be symbol reference")
 		}
  		outcode($1, Always, &$2, NREG, &$4);
@@ -375,7 +375,7 @@ rel:
 	con '(' LPC ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_BRANCH;
+		$$.Type = D_BRANCH;
 		$$.Offset = int64($1) + int64(asm.PC);
 	}
 |	LNAME offset
@@ -385,30 +385,30 @@ rel:
 		if asm.Pass == 2 && $1.Type != LLAB {
 			yyerror("undefined label: %s", $1.Labelname)
 		}
-		$$.Type_ = D_BRANCH;
+		$$.Type = D_BRANCH;
 		$$.Offset = $1.Value + int64($2);
 	}
 
 ximm:	'$' con
 	{
 		$$ = nullgen;
-		$$.Type_ = D_CONST;
+		$$.Type = D_CONST;
 		$$.Offset = int64($2);
 	}
 |	'$' oreg
 	{
 		$$ = $2;
-		$$.Type_ = D_CONST;
+		$$.Type = D_CONST;
 	}
 |	'$' '*' '$' oreg
 	{
 		$$ = $4;
-		$$.Type_ = D_OCONST;
+		$$.Type = D_OCONST;
 	}
 |	'$' LSCONST
 	{
 		$$ = nullgen;
-		$$.Type_ = D_SCONST;
+		$$.Type = D_SCONST;
 		$$.U.Sval = $2
 	}
 |	fcon
@@ -417,13 +417,13 @@ fcon:
 	'$' LFCONST
 	{
 		$$ = nullgen;
-		$$.Type_ = D_FCONST;
+		$$.Type = D_FCONST;
 		$$.U.Dval = $2;
 	}
 |	'$' '-' LFCONST
 	{
 		$$ = nullgen;
-		$$.Type_ = D_FCONST;
+		$$.Type = D_FCONST;
 		$$.U.Dval = -$3;
 	}
 
@@ -459,19 +459,19 @@ gen:
 |	LPSR
 	{
 		$$ = nullgen;
-		$$.Type_ = D_PSR;
+		$$.Type = D_PSR;
 		$$.Reg = int8($1);
 	}
 |	LFCR
 	{
 		$$ = nullgen;
-		$$.Type_ = D_FPCR;
+		$$.Type = D_FPCR;
 		$$.Reg = int8($1);
 	}
 |	con
 	{
 		$$ = nullgen;
-		$$.Type_ = D_OREG;
+		$$.Type = D_OREG;
 		$$.Offset = int64($1);
 	}
 |	oreg
@@ -490,7 +490,7 @@ ireg:
 	'(' spreg ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_OREG;
+		$$.Type = D_OREG;
 		$$.Reg = int8($2);
 		$$.Offset = 0;
 	}
@@ -500,7 +500,7 @@ ioreg:
 |	con '(' sreg ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_OREG;
+		$$.Type = D_OREG;
 		$$.Reg = int8($3);
 		$$.Offset = int64($1);
 	}
@@ -510,7 +510,7 @@ oreg:
 |	name '(' sreg ')'
 	{
 		$$ = $1;
-		$$.Type_ = D_OREG;
+		$$.Type = D_OREG;
 		$$.Reg = int8($3);
 	}
 |	ioreg
@@ -523,7 +523,7 @@ imsr:
 imm:	'$' con
 	{
 		$$ = nullgen;
-		$$.Type_ = D_CONST;
+		$$.Type = D_CONST;
 		$$.Offset = int64($2);
 	}
 
@@ -531,7 +531,7 @@ reg:
 	spreg
 	{
 		$$ = nullgen;
-		$$.Type_ = D_REG;
+		$$.Type = D_REG;
 		$$.Reg = int8($1);
 	}
 
@@ -539,7 +539,7 @@ regreg:
 	'(' spreg ',' spreg ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_REGREG;
+		$$.Type = D_REGREG;
 		$$.Reg = int8($2);
 		$$.Offset = int64($4);
 	}
@@ -548,25 +548,25 @@ shift:
 	spreg '<' '<' rcon
 	{
 		$$ = nullgen;
-		$$.Type_ = D_SHIFT;
+		$$.Type = D_SHIFT;
 		$$.Offset = int64($1) | int64($4) | (0 << 5);
 	}
 |	spreg '>' '>' rcon
 	{
 		$$ = nullgen;
-		$$.Type_ = D_SHIFT;
+		$$.Type = D_SHIFT;
 		$$.Offset = int64($1) | int64($4) | (1 << 5);
 	}
 |	spreg '-' '>' rcon
 	{
 		$$ = nullgen;
-		$$.Type_ = D_SHIFT;
+		$$.Type = D_SHIFT;
 		$$.Offset = int64($1) | int64($4) | (2 << 5);
 	}
 |	spreg LAT '>' rcon
 	{
 		$$ = nullgen;
-		$$.Type_ = D_SHIFT;
+		$$.Type = D_SHIFT;
 		$$.Offset = int64($1) | int64($4) | (3 << 5);
 	}
 
@@ -625,13 +625,13 @@ freg:
 	LFREG
 	{
 		$$ = nullgen;
-		$$.Type_ = D_FREG;
+		$$.Type = D_FREG;
 		$$.Reg = int8($1);
 	}
 |	LF '(' con ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_FREG;
+		$$.Type = D_FREG;
 		$$.Reg = int8($3);
 	}
 
@@ -639,7 +639,7 @@ name:
 	con '(' pointer ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_OREG;
+		$$.Type = D_OREG;
 		$$.Name = int8($3);
 		$$.Sym = nil;
 		$$.Offset = int64($1);
@@ -647,7 +647,7 @@ name:
 |	LNAME offset '(' pointer ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_OREG;
+		$$.Type = D_OREG;
 		$$.Name = int8($4);
 		$$.Sym = obj.Linklookup(asm.Ctxt, $1.Name, 0);
 		$$.Offset = int64($2);
@@ -655,7 +655,7 @@ name:
 |	LNAME '<' '>' offset '(' LSB ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_OREG;
+		$$.Type = D_OREG;
 		$$.Name = D_STATIC;
 		$$.Sym = obj.Linklookup(asm.Ctxt, $1.Name, 1);
 		$$.Offset = int64($4);
diff --git a/src/cmd/new5a/lex.go b/src/cmd/new5a/lex.go
index 81cd2268d6..cc7d25e4cf 100644
--- a/src/cmd/new5a/lex.go
+++ b/src/cmd/new5a/lex.go
@@ -298,7 +298,7 @@ var lexinit = []asm.Lextab{
 }
 
 func cinit() {
-	nullgen.Type_ = arm.D_NONE
+	nullgen.Type = arm.D_NONE
 	nullgen.Name = arm.D_NONE
 	nullgen.Reg = arm.NREG
 }
diff --git a/src/cmd/new5a/y.go b/src/cmd/new5a/y.go
index b40c3bd883..f63badefc1 100644
--- a/src/cmd/new5a/y.go
+++ b/src/cmd/new5a/y.go
@@ -726,7 +726,7 @@ yydefault:
 			var g obj.Addr
 
 			g = nullgen
-			g.Type_ = D_CONST
+			g.Type = D_CONST
 			g.Offset = int64(yyS[yypt-1].lval)
 			outcode(yyS[yypt-6].lval, yyS[yypt-5].lval, &yyS[yypt-4].addr, NREG, &g)
 		}
@@ -736,7 +736,7 @@ yydefault:
 			var g obj.Addr
 
 			g = nullgen
-			g.Type_ = D_CONST
+			g.Type = D_CONST
 			g.Offset = int64(yyS[yypt-3].lval)
 			outcode(yyS[yypt-6].lval, yyS[yypt-5].lval, &g, NREG, &yyS[yypt-0].addr)
 		}
@@ -764,7 +764,7 @@ yydefault:
 		//line a.y:221
 		{
 			asm.Settext(yyS[yypt-2].addr.Sym)
-			yyS[yypt-0].addr.Type_ = D_CONST2
+			yyS[yypt-0].addr.Type = D_CONST2
 			yyS[yypt-0].addr.Offset2 = -obj.ArgsSizeUnknown
 			outcode(yyS[yypt-3].lval, Always, &yyS[yypt-2].addr, 0, &yyS[yypt-0].addr)
 		}
@@ -772,7 +772,7 @@ yydefault:
 		//line a.y:228
 		{
 			asm.Settext(yyS[yypt-4].addr.Sym)
-			yyS[yypt-0].addr.Type_ = D_CONST2
+			yyS[yypt-0].addr.Type = D_CONST2
 			yyS[yypt-0].addr.Offset2 = -obj.ArgsSizeUnknown
 			outcode(yyS[yypt-5].lval, Always, &yyS[yypt-4].addr, yyS[yypt-2].lval, &yyS[yypt-0].addr)
 		}
@@ -780,7 +780,7 @@ yydefault:
 		//line a.y:235
 		{
 			asm.Settext(yyS[yypt-6].addr.Sym)
-			yyS[yypt-2].addr.Type_ = D_CONST2
+			yyS[yypt-2].addr.Type = D_CONST2
 			yyS[yypt-2].addr.Offset2 = yyS[yypt-0].lval
 			outcode(yyS[yypt-7].lval, Always, &yyS[yypt-6].addr, yyS[yypt-4].lval, &yyS[yypt-2].addr)
 		}
@@ -825,7 +825,7 @@ yydefault:
 			var g obj.Addr
 
 			g = nullgen
-			g.Type_ = D_CONST
+			g.Type = D_CONST
 			g.Offset = int64(
 				(0xe << 24) | /* opcode */
 					(yyS[yypt-11].lval << 20) | /* MCR/MRC */
@@ -847,7 +847,7 @@ yydefault:
 	case 40:
 		//line a.y:305
 		{
-			yyS[yypt-2].addr.Type_ = D_REGREG2
+			yyS[yypt-2].addr.Type = D_REGREG2
 			yyS[yypt-2].addr.Offset = int64(yyS[yypt-0].lval)
 			outcode(yyS[yypt-8].lval, yyS[yypt-7].lval, &yyS[yypt-6].addr, int32(yyS[yypt-4].addr.Reg), &yyS[yypt-2].addr)
 		}
@@ -859,7 +859,7 @@ yydefault:
 	case 42:
 		//line a.y:321
 		{
-			if yyS[yypt-2].addr.Type_ != D_CONST || yyS[yypt-0].addr.Type_ != D_CONST {
+			if yyS[yypt-2].addr.Type != D_CONST || yyS[yypt-0].addr.Type != D_CONST {
 				yyerror("arguments to PCDATA must be integer constants")
 			}
 			outcode(yyS[yypt-3].lval, Always, &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
@@ -867,10 +867,10 @@ yydefault:
 	case 43:
 		//line a.y:331
 		{
-			if yyS[yypt-2].addr.Type_ != D_CONST {
+			if yyS[yypt-2].addr.Type != D_CONST {
 				yyerror("index for FUNCDATA must be integer constant")
 			}
-			if yyS[yypt-0].addr.Type_ != D_EXTERN && yyS[yypt-0].addr.Type_ != D_STATIC && yyS[yypt-0].addr.Type_ != D_OREG {
+			if yyS[yypt-0].addr.Type != D_EXTERN && yyS[yypt-0].addr.Type != D_STATIC && yyS[yypt-0].addr.Type != D_OREG {
 				yyerror("value for FUNCDATA must be symbol reference")
 			}
 			outcode(yyS[yypt-3].lval, Always, &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
@@ -899,7 +899,7 @@ yydefault:
 		//line a.y:366
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_BRANCH
+			yyVAL.addr.Type = D_BRANCH
 			yyVAL.addr.Offset = int64(yyS[yypt-3].lval) + int64(asm.PC)
 		}
 	case 51:
@@ -910,33 +910,33 @@ yydefault:
 			if asm.Pass == 2 && yyS[yypt-1].sym.Type != LLAB {
 				yyerror("undefined label: %s", yyS[yypt-1].sym.Labelname)
 			}
-			yyVAL.addr.Type_ = D_BRANCH
+			yyVAL.addr.Type = D_BRANCH
 			yyVAL.addr.Offset = yyS[yypt-1].sym.Value + int64(yyS[yypt-0].lval)
 		}
 	case 52:
 		//line a.y:383
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_CONST
+			yyVAL.addr.Type = D_CONST
 			yyVAL.addr.Offset = int64(yyS[yypt-0].lval)
 		}
 	case 53:
 		//line a.y:389
 		{
 			yyVAL.addr = yyS[yypt-0].addr
-			yyVAL.addr.Type_ = D_CONST
+			yyVAL.addr.Type = D_CONST
 		}
 	case 54:
 		//line a.y:394
 		{
 			yyVAL.addr = yyS[yypt-0].addr
-			yyVAL.addr.Type_ = D_OCONST
+			yyVAL.addr.Type = D_OCONST
 		}
 	case 55:
 		//line a.y:399
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_SCONST
+			yyVAL.addr.Type = D_SCONST
 			yyVAL.addr.U.Sval = yyS[yypt-0].sval
 		}
 	case 56:
@@ -945,14 +945,14 @@ yydefault:
 		//line a.y:408
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_FCONST
+			yyVAL.addr.Type = D_FCONST
 			yyVAL.addr.U.Dval = yyS[yypt-0].dval
 		}
 	case 58:
 		//line a.y:414
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_FCONST
+			yyVAL.addr.Type = D_FCONST
 			yyVAL.addr.U.Dval = -yyS[yypt-0].dval
 		}
 	case 59:
@@ -992,21 +992,21 @@ yydefault:
 		//line a.y:450
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_PSR
+			yyVAL.addr.Type = D_PSR
 			yyVAL.addr.Reg = int8(yyS[yypt-0].lval)
 		}
 	case 67:
 		//line a.y:456
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_FPCR
+			yyVAL.addr.Type = D_FPCR
 			yyVAL.addr.Reg = int8(yyS[yypt-0].lval)
 		}
 	case 68:
 		//line a.y:462
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Type = D_OREG
 			yyVAL.addr.Offset = int64(yyS[yypt-0].lval)
 		}
 	case 69:
@@ -1026,7 +1026,7 @@ yydefault:
 		//line a.y:481
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Type = D_OREG
 			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
 			yyVAL.addr.Offset = 0
 		}
@@ -1036,7 +1036,7 @@ yydefault:
 		//line a.y:491
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Type = D_OREG
 			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
 			yyVAL.addr.Offset = int64(yyS[yypt-3].lval)
 		}
@@ -1046,7 +1046,7 @@ yydefault:
 		//line a.y:501
 		{
 			yyVAL.addr = yyS[yypt-3].addr
-			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Type = D_OREG
 			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
 		}
 	case 78:
@@ -1061,21 +1061,21 @@ yydefault:
 		//line a.y:514
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_CONST
+			yyVAL.addr.Type = D_CONST
 			yyVAL.addr.Offset = int64(yyS[yypt-0].lval)
 		}
 	case 83:
 		//line a.y:522
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_REG
+			yyVAL.addr.Type = D_REG
 			yyVAL.addr.Reg = int8(yyS[yypt-0].lval)
 		}
 	case 84:
 		//line a.y:530
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_REGREG
+			yyVAL.addr.Type = D_REGREG
 			yyVAL.addr.Reg = int8(yyS[yypt-3].lval)
 			yyVAL.addr.Offset = int64(yyS[yypt-1].lval)
 		}
@@ -1083,28 +1083,28 @@ yydefault:
 		//line a.y:539
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_SHIFT
+			yyVAL.addr.Type = D_SHIFT
 			yyVAL.addr.Offset = int64(yyS[yypt-3].lval) | int64(yyS[yypt-0].lval) | (0 << 5)
 		}
 	case 86:
 		//line a.y:545
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_SHIFT
+			yyVAL.addr.Type = D_SHIFT
 			yyVAL.addr.Offset = int64(yyS[yypt-3].lval) | int64(yyS[yypt-0].lval) | (1 << 5)
 		}
 	case 87:
 		//line a.y:551
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_SHIFT
+			yyVAL.addr.Type = D_SHIFT
 			yyVAL.addr.Offset = int64(yyS[yypt-3].lval) | int64(yyS[yypt-0].lval) | (2 << 5)
 		}
 	case 88:
 		//line a.y:557
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_SHIFT
+			yyVAL.addr.Type = D_SHIFT
 			yyVAL.addr.Offset = int64(yyS[yypt-3].lval) | int64(yyS[yypt-0].lval) | (3 << 5)
 		}
 	case 89:
@@ -1163,21 +1163,21 @@ yydefault:
 		//line a.y:616
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_FREG
+			yyVAL.addr.Type = D_FREG
 			yyVAL.addr.Reg = int8(yyS[yypt-0].lval)
 		}
 	case 101:
 		//line a.y:622
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_FREG
+			yyVAL.addr.Type = D_FREG
 			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
 		}
 	case 102:
 		//line a.y:630
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Type = D_OREG
 			yyVAL.addr.Name = int8(yyS[yypt-1].lval)
 			yyVAL.addr.Sym = nil
 			yyVAL.addr.Offset = int64(yyS[yypt-3].lval)
@@ -1186,7 +1186,7 @@ yydefault:
 		//line a.y:638
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Type = D_OREG
 			yyVAL.addr.Name = int8(yyS[yypt-1].lval)
 			yyVAL.addr.Sym = obj.Linklookup(asm.Ctxt, yyS[yypt-4].sym.Name, 0)
 			yyVAL.addr.Offset = int64(yyS[yypt-3].lval)
@@ -1195,7 +1195,7 @@ yydefault:
 		//line a.y:646
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Type = D_OREG
 			yyVAL.addr.Name = D_STATIC
 			yyVAL.addr.Sym = obj.Linklookup(asm.Ctxt, yyS[yypt-6].sym.Name, 1)
 			yyVAL.addr.Offset = int64(yyS[yypt-3].lval)
diff --git a/src/cmd/new6a/a.y b/src/cmd/new6a/a.y
index f9217a00cd..03a6c2d409 100644
--- a/src/cmd/new6a/a.y
+++ b/src/cmd/new6a/a.y
@@ -289,7 +289,7 @@ spec9:	/* shufl */
 	{
 		$$.from = $3;
 		$$.to = $5;
-		if $1.Type_ != x86.D_CONST {
+		if $1.Type != x86.D_CONST {
 			yyerror("illegal constant");
 		}
 		$$.to.Offset = $1.Offset;
@@ -322,7 +322,7 @@ spec11:	/* GLOBL */
 spec12:	/* asm.PCDATA */
 	rim ',' rim
 	{
-		if $1.Type_ != x86.D_CONST || $3.Type_ != x86.D_CONST {
+		if $1.Type != x86.D_CONST || $3.Type != x86.D_CONST {
 			yyerror("arguments to asm.PCDATA must be integer constants");
 		}
 		$$.from = $1;
@@ -332,10 +332,10 @@ spec12:	/* asm.PCDATA */
 spec13:	/* FUNCDATA */
 	rim ',' rim
 	{
-		if $1.Type_ != x86.D_CONST {
+		if $1.Type != x86.D_CONST {
 			yyerror("index for FUNCDATA must be integer constant");
 		}
-		if $3.Type_ != x86.D_EXTERN && $3.Type_ != x86.D_STATIC {
+		if $3.Type != x86.D_EXTERN && $3.Type != x86.D_STATIC {
 			yyerror("value for FUNCDATA must be symbol reference");
 		}
 		$$.from = $1;
@@ -368,7 +368,7 @@ rel:
 	con '(' LPC ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = x86.D_BRANCH;
+		$$.Type = x86.D_BRANCH;
 		$$.Offset = $1 + int64(asm.PC);
 	}
 |	LNAME offset
@@ -378,7 +378,7 @@ rel:
 		if asm.Pass == 2 && $1.Type != LLAB {
 			yyerror("undefined label: %s", $1.Labelname);
 		}
-		$$.Type_ = x86.D_BRANCH;
+		$$.Type = x86.D_BRANCH;
 		$$.Offset = $1.Value + $2;
 	}
 
@@ -386,43 +386,43 @@ reg:
 	LBREG
 	{
 		$$ = nullgen;
-		$$.Type_ = int16($1);
+		$$.Type = int16($1);
 	}
 |	LFREG
 	{
 		$$ = nullgen;
-		$$.Type_ = int16($1);
+		$$.Type = int16($1);
 	}
 |	LLREG
 	{
 		$$ = nullgen;
-		$$.Type_ = int16($1);
+		$$.Type = int16($1);
 	}
 |	LMREG
 	{
 		$$ = nullgen;
-		$$.Type_ = int16($1);
+		$$.Type = int16($1);
 	}
 |	LSP
 	{
 		$$ = nullgen;
-		$$.Type_ = x86.D_SP;
+		$$.Type = x86.D_SP;
 	}
 |	LSREG
 	{
 		$$ = nullgen;
-		$$.Type_ = int16($1);
+		$$.Type = int16($1);
 	}
 |	LXREG
 	{
 		$$ = nullgen;
-		$$.Type_ = int16($1);
+		$$.Type = int16($1);
 	}
 imm2:
 	'$' con2
 	{
 		$$ = nullgen;
-		$$.Type_ = x86.D_CONST;
+		$$.Type = x86.D_CONST;
 		$$.Offset = $2;
 	}
 
@@ -430,16 +430,16 @@ imm:
 	'$' con
 	{
 		$$ = nullgen;
-		$$.Type_ = x86.D_CONST;
+		$$.Type = x86.D_CONST;
 		$$.Offset = $2;
 	}
 |	'$' nam
 	{
 		$$ = $2;
-		$$.Index = uint8($2.Type_);
-		$$.Type_ = x86.D_ADDR;
+		$$.Index = uint8($2.Type);
+		$$.Type = x86.D_ADDR;
 		/*
-		if($2.Type_ == x86.D_AUTO || $2.Type_ == x86.D_PARAM)
+		if($2.Type == x86.D_AUTO || $2.Type == x86.D_PARAM)
 			yyerror("constant cannot be automatic: %s",
 				$2.sym.Name);
 		 */
@@ -447,31 +447,31 @@ imm:
 |	'$' LSCONST
 	{
 		$$ = nullgen;
-		$$.Type_ = x86.D_SCONST;
+		$$.Type = x86.D_SCONST;
 		$$.U.Sval = ($2+"\x00\x00\x00\x00\x00\x00\x00\x00")[:8]
 	}
 |	'$' LFCONST
 	{
 		$$ = nullgen;
-		$$.Type_ = x86.D_FCONST;
+		$$.Type = x86.D_FCONST;
 		$$.U.Dval = $2;
 	}
 |	'$' '(' LFCONST ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = x86.D_FCONST;
+		$$.Type = x86.D_FCONST;
 		$$.U.Dval = $3;
 	}
 |	'$' '(' '-' LFCONST ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = x86.D_FCONST;
+		$$.Type = x86.D_FCONST;
 		$$.U.Dval = -$4;
 	}
 |	'$' '-' LFCONST
 	{
 		$$ = nullgen;
-		$$.Type_ = x86.D_FCONST;
+		$$.Type = x86.D_FCONST;
 		$$.U.Dval = -$3;
 	}
 
@@ -483,31 +483,31 @@ omem:
 	con
 	{
 		$$ = nullgen;
-		$$.Type_ = x86.D_INDIR+x86.D_NONE;
+		$$.Type = x86.D_INDIR+x86.D_NONE;
 		$$.Offset = $1;
 	}
 |	con '(' LLREG ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16(x86.D_INDIR+$3);
+		$$.Type = int16(x86.D_INDIR+$3);
 		$$.Offset = $1;
 	}
 |	con '(' LSP ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16(x86.D_INDIR+x86.D_SP);
+		$$.Type = int16(x86.D_INDIR+x86.D_SP);
 		$$.Offset = $1;
 	}
 |	con '(' LSREG ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16(x86.D_INDIR+$3);
+		$$.Type = int16(x86.D_INDIR+$3);
 		$$.Offset = $1;
 	}
 |	con '(' LLREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16(x86.D_INDIR+x86.D_NONE);
+		$$.Type = int16(x86.D_INDIR+x86.D_NONE);
 		$$.Offset = $1;
 		$$.Index = uint8($3);
 		$$.Scale = int8($5);
@@ -516,7 +516,7 @@ omem:
 |	con '(' LLREG ')' '(' LLREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16(x86.D_INDIR+$3);
+		$$.Type = int16(x86.D_INDIR+$3);
 		$$.Offset = $1;
 		$$.Index = uint8($6);
 		$$.Scale = int8($8);
@@ -525,7 +525,7 @@ omem:
 |	con '(' LLREG ')' '(' LSREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16(x86.D_INDIR+$3);
+		$$.Type = int16(x86.D_INDIR+$3);
 		$$.Offset = $1;
 		$$.Index = uint8($6);
 		$$.Scale = int8($8);
@@ -534,17 +534,17 @@ omem:
 |	'(' LLREG ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16(x86.D_INDIR+$2);
+		$$.Type = int16(x86.D_INDIR+$2);
 	}
 |	'(' LSP ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16(x86.D_INDIR+x86.D_SP);
+		$$.Type = int16(x86.D_INDIR+x86.D_SP);
 	}
 |	'(' LLREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16(x86.D_INDIR+x86.D_NONE);
+		$$.Type = int16(x86.D_INDIR+x86.D_NONE);
 		$$.Index = uint8($2);
 		$$.Scale = int8($4);
 		checkscale($$.Scale);
@@ -552,7 +552,7 @@ omem:
 |	'(' LLREG ')' '(' LLREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16(x86.D_INDIR+$2);
+		$$.Type = int16(x86.D_INDIR+$2);
 		$$.Index = uint8($5);
 		$$.Scale = int8($7);
 		checkscale($$.Scale);
@@ -575,14 +575,14 @@ nam:
 	LNAME offset '(' pointer ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16($4);
+		$$.Type = int16($4);
 		$$.Sym = obj.Linklookup(asm.Ctxt, $1.Name, 0);
 		$$.Offset = $2;
 	}
 |	LNAME '<' '>' offset '(' LSB ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = x86.D_STATIC;
+		$$.Type = x86.D_STATIC;
 		$$.Sym = obj.Linklookup(asm.Ctxt, $1.Name, 1);
 		$$.Offset = $4;
 	}
diff --git a/src/cmd/new6a/lex.go b/src/cmd/new6a/lex.go
index 4a61f63195..98a039ee07 100644
--- a/src/cmd/new6a/lex.go
+++ b/src/cmd/new6a/lex.go
@@ -915,7 +915,7 @@ var lexinit = []asm.Lextab{
 }
 
 func cinit() {
-	nullgen.Type_ = x86.D_NONE
+	nullgen.Type = x86.D_NONE
 	nullgen.Index = x86.D_NONE
 }
 
diff --git a/src/cmd/new6a/y.go b/src/cmd/new6a/y.go
index 505efc0524..16ce70a132 100644
--- a/src/cmd/new6a/y.go
+++ b/src/cmd/new6a/y.go
@@ -866,7 +866,7 @@ yydefault:
 		{
 			yyVAL.addr2.from = yyS[yypt-2].addr
 			yyVAL.addr2.to = yyS[yypt-0].addr
-			if yyS[yypt-4].addr.Type_ != x86.D_CONST {
+			if yyS[yypt-4].addr.Type != x86.D_CONST {
 				yyerror("illegal constant")
 			}
 			yyVAL.addr2.to.Offset = yyS[yypt-4].addr.Offset
@@ -899,7 +899,7 @@ yydefault:
 	case 61:
 		//line a.y:324
 		{
-			if yyS[yypt-2].addr.Type_ != x86.D_CONST || yyS[yypt-0].addr.Type_ != x86.D_CONST {
+			if yyS[yypt-2].addr.Type != x86.D_CONST || yyS[yypt-0].addr.Type != x86.D_CONST {
 				yyerror("arguments to asm.PCDATA must be integer constants")
 			}
 			yyVAL.addr2.from = yyS[yypt-2].addr
@@ -908,10 +908,10 @@ yydefault:
 	case 62:
 		//line a.y:334
 		{
-			if yyS[yypt-2].addr.Type_ != x86.D_CONST {
+			if yyS[yypt-2].addr.Type != x86.D_CONST {
 				yyerror("index for FUNCDATA must be integer constant")
 			}
-			if yyS[yypt-0].addr.Type_ != x86.D_EXTERN && yyS[yypt-0].addr.Type_ != x86.D_STATIC {
+			if yyS[yypt-0].addr.Type != x86.D_EXTERN && yyS[yypt-0].addr.Type != x86.D_STATIC {
 				yyerror("value for FUNCDATA must be symbol reference")
 			}
 			yyVAL.addr2.from = yyS[yypt-2].addr
@@ -947,7 +947,7 @@ yydefault:
 		//line a.y:369
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = x86.D_BRANCH
+			yyVAL.addr.Type = x86.D_BRANCH
 			yyVAL.addr.Offset = yyS[yypt-3].lval + int64(asm.PC)
 		}
 	case 74:
@@ -958,73 +958,73 @@ yydefault:
 			if asm.Pass == 2 && yyS[yypt-1].sym.Type != LLAB {
 				yyerror("undefined label: %s", yyS[yypt-1].sym.Labelname)
 			}
-			yyVAL.addr.Type_ = x86.D_BRANCH
+			yyVAL.addr.Type = x86.D_BRANCH
 			yyVAL.addr.Offset = yyS[yypt-1].sym.Value + yyS[yypt-0].lval
 		}
 	case 75:
 		//line a.y:387
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+			yyVAL.addr.Type = int16(yyS[yypt-0].lval)
 		}
 	case 76:
 		//line a.y:392
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+			yyVAL.addr.Type = int16(yyS[yypt-0].lval)
 		}
 	case 77:
 		//line a.y:397
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+			yyVAL.addr.Type = int16(yyS[yypt-0].lval)
 		}
 	case 78:
 		//line a.y:402
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+			yyVAL.addr.Type = int16(yyS[yypt-0].lval)
 		}
 	case 79:
 		//line a.y:407
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = x86.D_SP
+			yyVAL.addr.Type = x86.D_SP
 		}
 	case 80:
 		//line a.y:412
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+			yyVAL.addr.Type = int16(yyS[yypt-0].lval)
 		}
 	case 81:
 		//line a.y:417
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+			yyVAL.addr.Type = int16(yyS[yypt-0].lval)
 		}
 	case 82:
 		//line a.y:423
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = x86.D_CONST
+			yyVAL.addr.Type = x86.D_CONST
 			yyVAL.addr.Offset = yyS[yypt-0].lval
 		}
 	case 83:
 		//line a.y:431
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = x86.D_CONST
+			yyVAL.addr.Type = x86.D_CONST
 			yyVAL.addr.Offset = yyS[yypt-0].lval
 		}
 	case 84:
 		//line a.y:437
 		{
 			yyVAL.addr = yyS[yypt-0].addr
-			yyVAL.addr.Index = uint8(yyS[yypt-0].addr.Type_)
-			yyVAL.addr.Type_ = x86.D_ADDR
+			yyVAL.addr.Index = uint8(yyS[yypt-0].addr.Type)
+			yyVAL.addr.Type = x86.D_ADDR
 			/*
-				if($2.Type_ == x86.D_AUTO || $2.Type_ == x86.D_PARAM)
+				if($2.Type == x86.D_AUTO || $2.Type == x86.D_PARAM)
 					yyerror("constant cannot be automatic: %s",
 						$2.sym.Name);
 			*/
@@ -1033,35 +1033,35 @@ yydefault:
 		//line a.y:447
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = x86.D_SCONST
+			yyVAL.addr.Type = x86.D_SCONST
 			yyVAL.addr.U.Sval = (yyS[yypt-0].sval + "\x00\x00\x00\x00\x00\x00\x00\x00")[:8]
 		}
 	case 86:
 		//line a.y:453
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = x86.D_FCONST
+			yyVAL.addr.Type = x86.D_FCONST
 			yyVAL.addr.U.Dval = yyS[yypt-0].dval
 		}
 	case 87:
 		//line a.y:459
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = x86.D_FCONST
+			yyVAL.addr.Type = x86.D_FCONST
 			yyVAL.addr.U.Dval = yyS[yypt-1].dval
 		}
 	case 88:
 		//line a.y:465
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = x86.D_FCONST
+			yyVAL.addr.Type = x86.D_FCONST
 			yyVAL.addr.U.Dval = -yyS[yypt-1].dval
 		}
 	case 89:
 		//line a.y:471
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = x86.D_FCONST
+			yyVAL.addr.Type = x86.D_FCONST
 			yyVAL.addr.U.Dval = -yyS[yypt-0].dval
 		}
 	case 90:
@@ -1072,35 +1072,35 @@ yydefault:
 		//line a.y:483
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = x86.D_INDIR + x86.D_NONE
+			yyVAL.addr.Type = x86.D_INDIR + x86.D_NONE
 			yyVAL.addr.Offset = yyS[yypt-0].lval
 		}
 	case 93:
 		//line a.y:489
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(x86.D_INDIR + yyS[yypt-1].lval)
+			yyVAL.addr.Type = int16(x86.D_INDIR + yyS[yypt-1].lval)
 			yyVAL.addr.Offset = yyS[yypt-3].lval
 		}
 	case 94:
 		//line a.y:495
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(x86.D_INDIR + x86.D_SP)
+			yyVAL.addr.Type = int16(x86.D_INDIR + x86.D_SP)
 			yyVAL.addr.Offset = yyS[yypt-3].lval
 		}
 	case 95:
 		//line a.y:501
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(x86.D_INDIR + yyS[yypt-1].lval)
+			yyVAL.addr.Type = int16(x86.D_INDIR + yyS[yypt-1].lval)
 			yyVAL.addr.Offset = yyS[yypt-3].lval
 		}
 	case 96:
 		//line a.y:507
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(x86.D_INDIR + x86.D_NONE)
+			yyVAL.addr.Type = int16(x86.D_INDIR + x86.D_NONE)
 			yyVAL.addr.Offset = yyS[yypt-5].lval
 			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
 			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
@@ -1110,7 +1110,7 @@ yydefault:
 		//line a.y:516
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(x86.D_INDIR + yyS[yypt-6].lval)
+			yyVAL.addr.Type = int16(x86.D_INDIR + yyS[yypt-6].lval)
 			yyVAL.addr.Offset = yyS[yypt-8].lval
 			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
 			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
@@ -1120,7 +1120,7 @@ yydefault:
 		//line a.y:525
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(x86.D_INDIR + yyS[yypt-6].lval)
+			yyVAL.addr.Type = int16(x86.D_INDIR + yyS[yypt-6].lval)
 			yyVAL.addr.Offset = yyS[yypt-8].lval
 			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
 			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
@@ -1130,19 +1130,19 @@ yydefault:
 		//line a.y:534
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(x86.D_INDIR + yyS[yypt-1].lval)
+			yyVAL.addr.Type = int16(x86.D_INDIR + yyS[yypt-1].lval)
 		}
 	case 100:
 		//line a.y:539
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(x86.D_INDIR + x86.D_SP)
+			yyVAL.addr.Type = int16(x86.D_INDIR + x86.D_SP)
 		}
 	case 101:
 		//line a.y:544
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(x86.D_INDIR + x86.D_NONE)
+			yyVAL.addr.Type = int16(x86.D_INDIR + x86.D_NONE)
 			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
 			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
 			checkscale(yyVAL.addr.Scale)
@@ -1151,7 +1151,7 @@ yydefault:
 		//line a.y:552
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(x86.D_INDIR + yyS[yypt-6].lval)
+			yyVAL.addr.Type = int16(x86.D_INDIR + yyS[yypt-6].lval)
 			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
 			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
 			checkscale(yyVAL.addr.Scale)
@@ -1173,7 +1173,7 @@ yydefault:
 		//line a.y:575
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(yyS[yypt-1].lval)
+			yyVAL.addr.Type = int16(yyS[yypt-1].lval)
 			yyVAL.addr.Sym = obj.Linklookup(asm.Ctxt, yyS[yypt-4].sym.Name, 0)
 			yyVAL.addr.Offset = yyS[yypt-3].lval
 		}
@@ -1181,7 +1181,7 @@ yydefault:
 		//line a.y:582
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = x86.D_STATIC
+			yyVAL.addr.Type = x86.D_STATIC
 			yyVAL.addr.Sym = obj.Linklookup(asm.Ctxt, yyS[yypt-6].sym.Name, 1)
 			yyVAL.addr.Offset = yyS[yypt-3].lval
 		}
diff --git a/src/cmd/new8a/a.y b/src/cmd/new8a/a.y
index 65081dd102..878420a48b 100644
--- a/src/cmd/new8a/a.y
+++ b/src/cmd/new8a/a.y
@@ -228,8 +228,8 @@ spec3:	/* JMP/CALL */
 	{
 		$$.from = nullgen;
 		$$.to = $2;
-		$$.to.Index = uint8($2.Type_)
-		$$.to.Type_ = D_INDIR+D_ADDR;
+		$$.to.Index = uint8($2.Type)
+		$$.to.Type = D_INDIR+D_ADDR;
 	}
 
 spec4:	/* NOP */
@@ -311,7 +311,7 @@ spec10:	/* PINSRD */
 	{
 		$$.from = $3;
 		$$.to = $5;
-		if $1.Type_ != D_CONST {
+		if $1.Type != D_CONST {
 			yyerror("illegal constant")
 		}
 		$$.to.Offset = $1.Offset;
@@ -320,7 +320,7 @@ spec10:	/* PINSRD */
 spec11:	/* PCDATA */
 	rim ',' rim
 	{
-		if $1.Type_ != D_CONST || $3.Type_ != D_CONST {
+		if $1.Type != D_CONST || $3.Type != D_CONST {
 			yyerror("arguments to PCDATA must be integer constants");
 		}
 		$$.from = $1;
@@ -330,10 +330,10 @@ spec11:	/* PCDATA */
 spec12:	/* FUNCDATA */
 	rim ',' rim
 	{
-		if $1.Type_ != D_CONST {
+		if $1.Type != D_CONST {
 			yyerror("index for FUNCDATA must be integer constant");
 		}
-		if $3.Type_ != D_EXTERN && $3.Type_ != D_STATIC {
+		if $3.Type != D_EXTERN && $3.Type != D_STATIC {
 			yyerror("value for FUNCDATA must be symbol reference");
 		}
  		$$.from = $1;
@@ -367,7 +367,7 @@ rel:
 	con '(' LPC ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_BRANCH;
+		$$.Type = D_BRANCH;
 		$$.Offset = $1 + int64(asm.PC);
 	}
 |	LNAME offset
@@ -377,7 +377,7 @@ rel:
 		if asm.Pass == 2 && $1.Type != LLAB {
 			yyerror("undefined label: %s", $1.Labelname);
 		}
-		$$.Type_ = D_BRANCH;
+		$$.Type = D_BRANCH;
 		$$.Offset = $1.Value + $2;
 	}
 
@@ -385,48 +385,48 @@ reg:
 	LBREG
 	{
 		$$ = nullgen;
-		$$.Type_ = int16($1);
+		$$.Type = int16($1);
 	}
 |	LFREG
 	{
 		$$ = nullgen;
-		$$.Type_ = int16($1);
+		$$.Type = int16($1);
 	}
 |	LLREG
 	{
 		$$ = nullgen;
-		$$.Type_ = int16($1);
+		$$.Type = int16($1);
 	}
 |	LXREG
 	{
 		$$ = nullgen;
-		$$.Type_ = int16($1);
+		$$.Type = int16($1);
 	}
 |	LSP
 	{
 		$$ = nullgen;
-		$$.Type_ = D_SP;
+		$$.Type = D_SP;
 	}
 |	LSREG
 	{
 		$$ = nullgen;
-		$$.Type_ = int16($1);
+		$$.Type = int16($1);
 	}
 
 imm:
 	'$' con
 	{
 		$$ = nullgen;
-		$$.Type_ = D_CONST;
+		$$.Type = D_CONST;
 		$$.Offset = $2;
 	}
 |	'$' nam
 	{
 		$$ = $2;
-		$$.Index = uint8($2.Type_);
-		$$.Type_ = D_ADDR;
+		$$.Index = uint8($2.Type);
+		$$.Type = D_ADDR;
 		/*
-		if($2.Type_ == D_AUTO || $2.Type_ == D_PARAM)
+		if($2.Type == D_AUTO || $2.Type == D_PARAM)
 			yyerror("constant cannot be automatic: %s",
 				$2.Sym.name);
 		 */
@@ -434,31 +434,31 @@ imm:
 |	'$' LSCONST
 	{
 		$$ = nullgen;
-		$$.Type_ = D_SCONST;
+		$$.Type = D_SCONST;
 		$$.U.Sval = $2
 	}
 |	'$' LFCONST
 	{
 		$$ = nullgen;
-		$$.Type_ = D_FCONST;
+		$$.Type = D_FCONST;
 		$$.U.Dval = $2;
 	}
 |	'$' '(' LFCONST ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_FCONST;
+		$$.Type = D_FCONST;
 		$$.U.Dval = $3;
 	}
 |	'$' '(' '-' LFCONST ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_FCONST;
+		$$.Type = D_FCONST;
 		$$.U.Dval = -$4;
 	}
 |	'$' '-' LFCONST
 	{
 		$$ = nullgen;
-		$$.Type_ = D_FCONST;
+		$$.Type = D_FCONST;
 		$$.U.Dval = -$3;
 	}
 
@@ -466,7 +466,7 @@ imm2:
 	'$' con2
 	{
 		$$ = nullgen;
-		$$.Type_ = D_CONST2;
+		$$.Type = D_CONST2;
 		$$.Offset = int64($2.v1);
 		$$.Offset2 = int32($2.v2);
 	}
@@ -501,25 +501,25 @@ omem:
 	con
 	{
 		$$ = nullgen;
-		$$.Type_ = D_INDIR+D_NONE;
+		$$.Type = D_INDIR+D_NONE;
 		$$.Offset = $1;
 	}
 |	con '(' LLREG ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16(D_INDIR+$3);
+		$$.Type = int16(D_INDIR+$3);
 		$$.Offset = $1;
 	}
 |	con '(' LSP ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_INDIR+D_SP;
+		$$.Type = D_INDIR+D_SP;
 		$$.Offset = $1;
 	}
 |	con '(' LLREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_INDIR+D_NONE;
+		$$.Type = D_INDIR+D_NONE;
 		$$.Offset = $1;
 		$$.Index = uint8($3);
 		$$.Scale = int8($5);
@@ -528,7 +528,7 @@ omem:
 |	con '(' LLREG ')' '(' LLREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16(D_INDIR+$3);
+		$$.Type = int16(D_INDIR+$3);
 		$$.Offset = $1;
 		$$.Index = uint8($6);
 		$$.Scale = int8($8);
@@ -537,7 +537,7 @@ omem:
 |	con '(' LLREG ')' '(' LSREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16(D_INDIR+$3);
+		$$.Type = int16(D_INDIR+$3);
 		$$.Offset = $1;
 		$$.Index = uint8($6);
 		$$.Scale = int8($8);
@@ -546,23 +546,23 @@ omem:
 |	'(' LLREG ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16(D_INDIR+$2);
+		$$.Type = int16(D_INDIR+$2);
 	}
 |	'(' LSP ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_INDIR+D_SP;
+		$$.Type = D_INDIR+D_SP;
 	}
 |	con '(' LSREG ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16(D_INDIR+$3);
+		$$.Type = int16(D_INDIR+$3);
 		$$.Offset = $1;
 	}
 |	'(' LLREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_INDIR+D_NONE;
+		$$.Type = D_INDIR+D_NONE;
 		$$.Index = uint8($2);
 		$$.Scale = int8($4);
 		checkscale($$.Scale);
@@ -570,7 +570,7 @@ omem:
 |	'(' LLREG ')' '(' LLREG '*' con ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16(D_INDIR+$2);
+		$$.Type = int16(D_INDIR+$2);
 		$$.Index = uint8($5);
 		$$.Scale = int8($7);
 		checkscale($$.Scale);
@@ -593,14 +593,14 @@ nam:
 	LNAME offset '(' pointer ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16($4);
+		$$.Type = int16($4);
 		$$.Sym = obj.Linklookup(asm.Ctxt, $1.Name, 0);
 		$$.Offset = $2;
 	}
 |	LNAME '<' '>' offset '(' LSB ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_STATIC;
+		$$.Type = D_STATIC;
 		$$.Sym = obj.Linklookup(asm.Ctxt, $1.Name, 1);
 		$$.Offset = $4;
 	}
diff --git a/src/cmd/new8a/lex.go b/src/cmd/new8a/lex.go
index 3aebe6b2ec..cf75953038 100644
--- a/src/cmd/new8a/lex.go
+++ b/src/cmd/new8a/lex.go
@@ -702,7 +702,7 @@ var lexinit = []asm.Lextab{
 }
 
 func cinit() {
-	nullgen.Type_ = i386.D_NONE
+	nullgen.Type = i386.D_NONE
 	nullgen.Index = i386.D_NONE
 }
 
diff --git a/src/cmd/new8a/y.go b/src/cmd/new8a/y.go
index e1ac614018..b286f53b9f 100644
--- a/src/cmd/new8a/y.go
+++ b/src/cmd/new8a/y.go
@@ -801,8 +801,8 @@ yydefault:
 		{
 			yyVAL.addr2.from = nullgen
 			yyVAL.addr2.to = yyS[yypt-0].addr
-			yyVAL.addr2.to.Index = uint8(yyS[yypt-0].addr.Type_)
-			yyVAL.addr2.to.Type_ = D_INDIR + D_ADDR
+			yyVAL.addr2.to.Index = uint8(yyS[yypt-0].addr.Type)
+			yyVAL.addr2.to.Type = D_INDIR + D_ADDR
 		}
 	case 46:
 		yyVAL.addr2 = yyS[yypt-0].addr2
@@ -883,7 +883,7 @@ yydefault:
 		{
 			yyVAL.addr2.from = yyS[yypt-2].addr
 			yyVAL.addr2.to = yyS[yypt-0].addr
-			if yyS[yypt-4].addr.Type_ != D_CONST {
+			if yyS[yypt-4].addr.Type != D_CONST {
 				yyerror("illegal constant")
 			}
 			yyVAL.addr2.to.Offset = yyS[yypt-4].addr.Offset
@@ -891,7 +891,7 @@ yydefault:
 	case 59:
 		//line a.y:322
 		{
-			if yyS[yypt-2].addr.Type_ != D_CONST || yyS[yypt-0].addr.Type_ != D_CONST {
+			if yyS[yypt-2].addr.Type != D_CONST || yyS[yypt-0].addr.Type != D_CONST {
 				yyerror("arguments to PCDATA must be integer constants")
 			}
 			yyVAL.addr2.from = yyS[yypt-2].addr
@@ -900,10 +900,10 @@ yydefault:
 	case 60:
 		//line a.y:332
 		{
-			if yyS[yypt-2].addr.Type_ != D_CONST {
+			if yyS[yypt-2].addr.Type != D_CONST {
 				yyerror("index for FUNCDATA must be integer constant")
 			}
-			if yyS[yypt-0].addr.Type_ != D_EXTERN && yyS[yypt-0].addr.Type_ != D_STATIC {
+			if yyS[yypt-0].addr.Type != D_EXTERN && yyS[yypt-0].addr.Type != D_STATIC {
 				yyerror("value for FUNCDATA must be symbol reference")
 			}
 			yyVAL.addr2.from = yyS[yypt-2].addr
@@ -941,7 +941,7 @@ yydefault:
 		//line a.y:368
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_BRANCH
+			yyVAL.addr.Type = D_BRANCH
 			yyVAL.addr.Offset = yyS[yypt-3].lval + int64(asm.PC)
 		}
 	case 73:
@@ -952,60 +952,60 @@ yydefault:
 			if asm.Pass == 2 && yyS[yypt-1].sym.Type != LLAB {
 				yyerror("undefined label: %s", yyS[yypt-1].sym.Labelname)
 			}
-			yyVAL.addr.Type_ = D_BRANCH
+			yyVAL.addr.Type = D_BRANCH
 			yyVAL.addr.Offset = yyS[yypt-1].sym.Value + yyS[yypt-0].lval
 		}
 	case 74:
 		//line a.y:386
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+			yyVAL.addr.Type = int16(yyS[yypt-0].lval)
 		}
 	case 75:
 		//line a.y:391
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+			yyVAL.addr.Type = int16(yyS[yypt-0].lval)
 		}
 	case 76:
 		//line a.y:396
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+			yyVAL.addr.Type = int16(yyS[yypt-0].lval)
 		}
 	case 77:
 		//line a.y:401
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+			yyVAL.addr.Type = int16(yyS[yypt-0].lval)
 		}
 	case 78:
 		//line a.y:406
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_SP
+			yyVAL.addr.Type = D_SP
 		}
 	case 79:
 		//line a.y:411
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(yyS[yypt-0].lval)
+			yyVAL.addr.Type = int16(yyS[yypt-0].lval)
 		}
 	case 80:
 		//line a.y:418
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_CONST
+			yyVAL.addr.Type = D_CONST
 			yyVAL.addr.Offset = yyS[yypt-0].lval
 		}
 	case 81:
 		//line a.y:424
 		{
 			yyVAL.addr = yyS[yypt-0].addr
-			yyVAL.addr.Index = uint8(yyS[yypt-0].addr.Type_)
-			yyVAL.addr.Type_ = D_ADDR
+			yyVAL.addr.Index = uint8(yyS[yypt-0].addr.Type)
+			yyVAL.addr.Type = D_ADDR
 			/*
-				if($2.Type_ == D_AUTO || $2.Type_ == D_PARAM)
+				if($2.Type == D_AUTO || $2.Type == D_PARAM)
 					yyerror("constant cannot be automatic: %s",
 						$2.Sym.name);
 			*/
@@ -1014,42 +1014,42 @@ yydefault:
 		//line a.y:434
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_SCONST
+			yyVAL.addr.Type = D_SCONST
 			yyVAL.addr.U.Sval = yyS[yypt-0].sval
 		}
 	case 83:
 		//line a.y:440
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_FCONST
+			yyVAL.addr.Type = D_FCONST
 			yyVAL.addr.U.Dval = yyS[yypt-0].dval
 		}
 	case 84:
 		//line a.y:446
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_FCONST
+			yyVAL.addr.Type = D_FCONST
 			yyVAL.addr.U.Dval = yyS[yypt-1].dval
 		}
 	case 85:
 		//line a.y:452
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_FCONST
+			yyVAL.addr.Type = D_FCONST
 			yyVAL.addr.U.Dval = -yyS[yypt-1].dval
 		}
 	case 86:
 		//line a.y:458
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_FCONST
+			yyVAL.addr.Type = D_FCONST
 			yyVAL.addr.U.Dval = -yyS[yypt-0].dval
 		}
 	case 87:
 		//line a.y:466
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_CONST2
+			yyVAL.addr.Type = D_CONST2
 			yyVAL.addr.Offset = int64(yyS[yypt-0].con2.v1)
 			yyVAL.addr.Offset2 = int32(yyS[yypt-0].con2.v2)
 		}
@@ -1085,28 +1085,28 @@ yydefault:
 		//line a.y:501
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_INDIR + D_NONE
+			yyVAL.addr.Type = D_INDIR + D_NONE
 			yyVAL.addr.Offset = yyS[yypt-0].lval
 		}
 	case 95:
 		//line a.y:507
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(D_INDIR + yyS[yypt-1].lval)
+			yyVAL.addr.Type = int16(D_INDIR + yyS[yypt-1].lval)
 			yyVAL.addr.Offset = yyS[yypt-3].lval
 		}
 	case 96:
 		//line a.y:513
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_INDIR + D_SP
+			yyVAL.addr.Type = D_INDIR + D_SP
 			yyVAL.addr.Offset = yyS[yypt-3].lval
 		}
 	case 97:
 		//line a.y:519
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_INDIR + D_NONE
+			yyVAL.addr.Type = D_INDIR + D_NONE
 			yyVAL.addr.Offset = yyS[yypt-5].lval
 			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
 			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
@@ -1116,7 +1116,7 @@ yydefault:
 		//line a.y:528
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(D_INDIR + yyS[yypt-6].lval)
+			yyVAL.addr.Type = int16(D_INDIR + yyS[yypt-6].lval)
 			yyVAL.addr.Offset = yyS[yypt-8].lval
 			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
 			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
@@ -1126,7 +1126,7 @@ yydefault:
 		//line a.y:537
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(D_INDIR + yyS[yypt-6].lval)
+			yyVAL.addr.Type = int16(D_INDIR + yyS[yypt-6].lval)
 			yyVAL.addr.Offset = yyS[yypt-8].lval
 			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
 			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
@@ -1136,26 +1136,26 @@ yydefault:
 		//line a.y:546
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(D_INDIR + yyS[yypt-1].lval)
+			yyVAL.addr.Type = int16(D_INDIR + yyS[yypt-1].lval)
 		}
 	case 101:
 		//line a.y:551
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_INDIR + D_SP
+			yyVAL.addr.Type = D_INDIR + D_SP
 		}
 	case 102:
 		//line a.y:556
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(D_INDIR + yyS[yypt-1].lval)
+			yyVAL.addr.Type = int16(D_INDIR + yyS[yypt-1].lval)
 			yyVAL.addr.Offset = yyS[yypt-3].lval
 		}
 	case 103:
 		//line a.y:562
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_INDIR + D_NONE
+			yyVAL.addr.Type = D_INDIR + D_NONE
 			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
 			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
 			checkscale(yyVAL.addr.Scale)
@@ -1164,7 +1164,7 @@ yydefault:
 		//line a.y:570
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(D_INDIR + yyS[yypt-6].lval)
+			yyVAL.addr.Type = int16(D_INDIR + yyS[yypt-6].lval)
 			yyVAL.addr.Index = uint8(yyS[yypt-3].lval)
 			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
 			checkscale(yyVAL.addr.Scale)
@@ -1186,7 +1186,7 @@ yydefault:
 		//line a.y:593
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(yyS[yypt-1].lval)
+			yyVAL.addr.Type = int16(yyS[yypt-1].lval)
 			yyVAL.addr.Sym = obj.Linklookup(asm.Ctxt, yyS[yypt-4].sym.Name, 0)
 			yyVAL.addr.Offset = yyS[yypt-3].lval
 		}
@@ -1194,7 +1194,7 @@ yydefault:
 		//line a.y:600
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_STATIC
+			yyVAL.addr.Type = D_STATIC
 			yyVAL.addr.Sym = obj.Linklookup(asm.Ctxt, yyS[yypt-6].sym.Name, 1)
 			yyVAL.addr.Offset = yyS[yypt-3].lval
 		}
diff --git a/src/cmd/new9a/a.y b/src/cmd/new9a/a.y
index 25b3ca689a..cdc15fcde8 100644
--- a/src/cmd/new9a/a.y
+++ b/src/cmd/new9a/a.y
@@ -408,7 +408,7 @@ inst:
 	{
 		var g obj.Addr
 		g = nullgen;
-		g.Type_ = D_CONST;
+		g.Type = D_CONST;
 		g.Offset = $2;
 		outcode(int($1), &g, int($4), &$6);
 	}
@@ -416,7 +416,7 @@ inst:
 	{
 		var g obj.Addr
 		g = nullgen;
-		g.Type_ = D_CONST;
+		g.Type = D_CONST;
 		g.Offset = $2;
 		outcode(int($1), &g, int($4), &$6);
 	}
@@ -424,7 +424,7 @@ inst:
 	{
 		var g obj.Addr
 		g = nullgen;
-		g.Type_ = D_CONST;
+		g.Type = D_CONST;
 		g.Offset = $2;
 		outcode(int($1), &g, int($4), &$7);
 	}
@@ -598,7 +598,7 @@ inst:
  */
 |	LPCDAT imm ',' imm
 	{
-		if $2.Type_ != D_CONST || $4.Type_ != D_CONST {
+		if $2.Type != D_CONST || $4.Type != D_CONST {
 			yyerror("arguments to PCDATA must be integer constants")
 		}
 		outcode(int($1), &$2, NREG, &$4);
@@ -608,10 +608,10 @@ inst:
  */
 |	LFUNCDAT imm ',' addr
 	{
-		if $2.Type_ != D_CONST {
+		if $2.Type != D_CONST {
 			yyerror("index for FUNCDATA must be integer constant")
 		}
-		if $4.Type_ != D_EXTERN && $4.Type_ != D_STATIC && $4.Type_ != D_OREG {
+		if $4.Type != D_EXTERN && $4.Type != D_STATIC && $4.Type != D_OREG {
 			yyerror("value for FUNCDATA must be symbol reference")
 		}
  		outcode(int($1), &$2, NREG, &$4);
@@ -672,7 +672,7 @@ rel:
 	con '(' LPC ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_BRANCH;
+		$$.Type = D_BRANCH;
 		$$.Offset = $1 + int64(asm.PC);
 	}
 |	LNAME offset
@@ -682,7 +682,7 @@ rel:
 		if asm.Pass == 2 && $1.Type != LLAB {
 			yyerror("undefined label: %s", $1.Labelname)
 		}
-		$$.Type_ = D_BRANCH;
+		$$.Type = D_BRANCH;
 		$$.Offset = $1.Value + $2;
 	}
 
@@ -690,7 +690,7 @@ rreg:
 	sreg
 	{
 		$$ = nullgen;
-		$$.Type_ = D_REG;
+		$$.Type = D_REG;
 		$$.Reg = int8($1);
 	}
 
@@ -702,7 +702,7 @@ lr:
 	LLR
 	{
 		$$ = nullgen;
-		$$.Type_ = D_SPR;
+		$$.Type = D_SPR;
 		$$.Offset = $1;
 	}
 
@@ -710,7 +710,7 @@ lcr:
 	LCR
 	{
 		$$ = nullgen;
-		$$.Type_ = D_CREG;
+		$$.Type = D_CREG;
 		$$.Reg = NREG;	/* whole register */
 	}
 
@@ -718,7 +718,7 @@ ctr:
 	LCTR
 	{
 		$$ = nullgen;
-		$$.Type_ = D_SPR;
+		$$.Type = D_SPR;
 		$$.Offset = $1;
 	}
 
@@ -726,20 +726,20 @@ msr:
 	LMSR
 	{
 		$$ = nullgen;
-		$$.Type_ = D_MSR;
+		$$.Type = D_MSR;
 	}
 
 psr:
 	LSPREG
 	{
 		$$ = nullgen;
-		$$.Type_ = D_SPR;
+		$$.Type = D_SPR;
 		$$.Offset = $1;
 	}
 |	LSPR '(' con ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = int16($1);
+		$$.Type = int16($1);
 		$$.Offset = $3;
 	}
 |	msr
@@ -748,7 +748,7 @@ fpscr:
 	LFPSCR
 	{
 		$$ = nullgen;
-		$$.Type_ = D_FPSCR;
+		$$.Type = D_FPSCR;
 		$$.Reg = NREG;
 	}
 
@@ -756,7 +756,7 @@ fpscrf:
 	LFPSCR '(' con ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_FPSCR;
+		$$.Type = D_FPSCR;
 		$$.Reg = int8($3);
 	}
 
@@ -764,13 +764,13 @@ freg:
 	LFREG
 	{
 		$$ = nullgen;
-		$$.Type_ = D_FREG;
+		$$.Type = D_FREG;
 		$$.Reg = int8($1);
 	}
 |	LF '(' con ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_FREG;
+		$$.Type = D_FREG;
 		$$.Reg = int8($3);
 	}
 
@@ -778,13 +778,13 @@ creg:
 	LCREG
 	{
 		$$ = nullgen;
-		$$.Type_ = D_CREG;
+		$$.Type = D_CREG;
 		$$.Reg = int8($1);
 	}
 |	LCR '(' con ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_CREG;
+		$$.Type = D_CREG;
 		$$.Reg = int8($3);
 	}
 
@@ -792,7 +792,7 @@ creg:
 cbit:	con
 	{
 		$$ = nullgen;
-		$$.Type_ = D_REG;
+		$$.Type = D_REG;
 		$$.Reg = int8($1);
 	}
 
@@ -803,7 +803,7 @@ mask:
 		var v uint32
 
 		$$ = nullgen;
-		$$.Type_ = D_CONST;
+		$$.Type = D_CONST;
 		mb = int($1);
 		me = int($3);
 		if(mb < 0 || mb > 31 || me < 0 || me > 31){
@@ -823,12 +823,12 @@ ximm:
 	'$' addr
 	{
 		$$ = $2;
-		$$.Type_ = D_CONST;
+		$$.Type = D_CONST;
 	}
 |	'$' LSCONST
 	{
 		$$ = nullgen;
-		$$.Type_ = D_SCONST;
+		$$.Type = D_SCONST;
 		$$.U.Sval = $2
 	}
 
@@ -836,20 +836,20 @@ fimm:
 	'$' LFCONST
 	{
 		$$ = nullgen;
-		$$.Type_ = D_FCONST;
+		$$.Type = D_FCONST;
 		$$.U.Dval = $2;
 	}
 |	'$' '-' LFCONST
 	{
 		$$ = nullgen;
-		$$.Type_ = D_FCONST;
+		$$.Type = D_FCONST;
 		$$.U.Dval = -$3;
 	}
 
 imm:	'$' con
 	{
 		$$ = nullgen;
-		$$.Type_ = D_CONST;
+		$$.Type = D_CONST;
 		$$.Offset = $2;
 	}
 
@@ -867,14 +867,14 @@ regaddr:
 	'(' sreg ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_OREG;
+		$$.Type = D_OREG;
 		$$.Reg = int8($2);
 		$$.Offset = 0;
 	}
 |	'(' sreg '+' sreg ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_OREG;
+		$$.Type = D_OREG;
 		$$.Reg = int8($2);
 		$$.Scale = int8($4);
 		$$.Offset = 0;
@@ -885,7 +885,7 @@ addr:
 |	con '(' sreg ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_OREG;
+		$$.Type = D_OREG;
 		$$.Reg = int8($3);
 		$$.Offset = $1;
 	}
@@ -894,7 +894,7 @@ name:
 	con '(' pointer ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_OREG;
+		$$.Type = D_OREG;
 		$$.Name = int8($3);
 		$$.Sym = nil;
 		$$.Offset = $1;
@@ -902,7 +902,7 @@ name:
 |	LNAME offset '(' pointer ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_OREG;
+		$$.Type = D_OREG;
 		$$.Name = int8($4);
 		$$.Sym = obj.Linklookup(asm.Ctxt, $1.Name, 0);
 		$$.Offset = $2;
@@ -910,7 +910,7 @@ name:
 |	LNAME '<' '>' offset '(' LSB ')'
 	{
 		$$ = nullgen;
-		$$.Type_ = D_OREG;
+		$$.Type = D_OREG;
 		$$.Name = D_STATIC;
 		$$.Sym = obj.Linklookup(asm.Ctxt, $1.Name, 0);
 		$$.Offset = $4;
diff --git a/src/cmd/new9a/lex.go b/src/cmd/new9a/lex.go
index 1cc835f98d..42896ae299 100644
--- a/src/cmd/new9a/lex.go
+++ b/src/cmd/new9a/lex.go
@@ -465,7 +465,7 @@ var lexinit = []asm.Lextab{
 }
 
 func cinit() {
-	nullgen.Type_ = ppc64.D_NONE
+	nullgen.Type = ppc64.D_NONE
 	nullgen.Name = ppc64.D_NONE
 	nullgen.Reg = ppc64.NREG
 	nullgen.Scale = ppc64.NREG // replaced Gen.xreg with Prog.scale
diff --git a/src/cmd/new9a/y.go b/src/cmd/new9a/y.go
index bb844ff152..43aa429e0a 100644
--- a/src/cmd/new9a/y.go
+++ b/src/cmd/new9a/y.go
@@ -1085,7 +1085,7 @@ yydefault:
 		{
 			var g obj.Addr
 			g = nullgen
-			g.Type_ = D_CONST
+			g.Type = D_CONST
 			g.Offset = yyS[yypt-4].lval
 			outcode(int(yyS[yypt-5].lval), &g, int(yyS[yypt-2].lval), &yyS[yypt-0].addr)
 		}
@@ -1094,7 +1094,7 @@ yydefault:
 		{
 			var g obj.Addr
 			g = nullgen
-			g.Type_ = D_CONST
+			g.Type = D_CONST
 			g.Offset = yyS[yypt-4].lval
 			outcode(int(yyS[yypt-5].lval), &g, int(yyS[yypt-2].lval), &yyS[yypt-0].addr)
 		}
@@ -1103,7 +1103,7 @@ yydefault:
 		{
 			var g obj.Addr
 			g = nullgen
-			g.Type_ = D_CONST
+			g.Type = D_CONST
 			g.Offset = yyS[yypt-6].lval
 			outcode(int(yyS[yypt-7].lval), &g, int(yyS[yypt-4].lval), &yyS[yypt-1].addr)
 		}
@@ -1285,7 +1285,7 @@ yydefault:
 	case 114:
 		//line a.y:600
 		{
-			if yyS[yypt-2].addr.Type_ != D_CONST || yyS[yypt-0].addr.Type_ != D_CONST {
+			if yyS[yypt-2].addr.Type != D_CONST || yyS[yypt-0].addr.Type != D_CONST {
 				yyerror("arguments to PCDATA must be integer constants")
 			}
 			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
@@ -1293,10 +1293,10 @@ yydefault:
 	case 115:
 		//line a.y:610
 		{
-			if yyS[yypt-2].addr.Type_ != D_CONST {
+			if yyS[yypt-2].addr.Type != D_CONST {
 				yyerror("index for FUNCDATA must be integer constant")
 			}
-			if yyS[yypt-0].addr.Type_ != D_EXTERN && yyS[yypt-0].addr.Type_ != D_STATIC && yyS[yypt-0].addr.Type_ != D_OREG {
+			if yyS[yypt-0].addr.Type != D_EXTERN && yyS[yypt-0].addr.Type != D_STATIC && yyS[yypt-0].addr.Type != D_OREG {
 				yyerror("value for FUNCDATA must be symbol reference")
 			}
 			outcode(int(yyS[yypt-3].lval), &yyS[yypt-2].addr, NREG, &yyS[yypt-0].addr)
@@ -1352,7 +1352,7 @@ yydefault:
 		//line a.y:673
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_BRANCH
+			yyVAL.addr.Type = D_BRANCH
 			yyVAL.addr.Offset = yyS[yypt-3].lval + int64(asm.PC)
 		}
 	case 125:
@@ -1363,14 +1363,14 @@ yydefault:
 			if asm.Pass == 2 && yyS[yypt-1].sym.Type != LLAB {
 				yyerror("undefined label: %s", yyS[yypt-1].sym.Labelname)
 			}
-			yyVAL.addr.Type_ = D_BRANCH
+			yyVAL.addr.Type = D_BRANCH
 			yyVAL.addr.Offset = yyS[yypt-1].sym.Value + yyS[yypt-0].lval
 		}
 	case 126:
 		//line a.y:691
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_REG
+			yyVAL.addr.Type = D_REG
 			yyVAL.addr.Reg = int8(yyS[yypt-0].lval)
 		}
 	case 127:
@@ -1381,41 +1381,41 @@ yydefault:
 		//line a.y:703
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_SPR
+			yyVAL.addr.Type = D_SPR
 			yyVAL.addr.Offset = yyS[yypt-0].lval
 		}
 	case 130:
 		//line a.y:711
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_CREG
+			yyVAL.addr.Type = D_CREG
 			yyVAL.addr.Reg = NREG /* whole register */
 		}
 	case 131:
 		//line a.y:718
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_SPR
+			yyVAL.addr.Type = D_SPR
 			yyVAL.addr.Offset = yyS[yypt-0].lval
 		}
 	case 132:
 		//line a.y:726
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_MSR
+			yyVAL.addr.Type = D_MSR
 		}
 	case 133:
 		//line a.y:733
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_SPR
+			yyVAL.addr.Type = D_SPR
 			yyVAL.addr.Offset = yyS[yypt-0].lval
 		}
 	case 134:
 		//line a.y:739
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = int16(yyS[yypt-3].lval)
+			yyVAL.addr.Type = int16(yyS[yypt-3].lval)
 			yyVAL.addr.Offset = yyS[yypt-1].lval
 		}
 	case 135:
@@ -1424,49 +1424,49 @@ yydefault:
 		//line a.y:748
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_FPSCR
+			yyVAL.addr.Type = D_FPSCR
 			yyVAL.addr.Reg = NREG
 		}
 	case 137:
 		//line a.y:756
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_FPSCR
+			yyVAL.addr.Type = D_FPSCR
 			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
 		}
 	case 138:
 		//line a.y:764
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_FREG
+			yyVAL.addr.Type = D_FREG
 			yyVAL.addr.Reg = int8(yyS[yypt-0].lval)
 		}
 	case 139:
 		//line a.y:770
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_FREG
+			yyVAL.addr.Type = D_FREG
 			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
 		}
 	case 140:
 		//line a.y:778
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_CREG
+			yyVAL.addr.Type = D_CREG
 			yyVAL.addr.Reg = int8(yyS[yypt-0].lval)
 		}
 	case 141:
 		//line a.y:784
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_CREG
+			yyVAL.addr.Type = D_CREG
 			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
 		}
 	case 142:
 		//line a.y:792
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_REG
+			yyVAL.addr.Type = D_REG
 			yyVAL.addr.Reg = int8(yyS[yypt-0].lval)
 		}
 	case 143:
@@ -1476,7 +1476,7 @@ yydefault:
 			var v uint32
 
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_CONST
+			yyVAL.addr.Type = D_CONST
 			mb = int(yyS[yypt-2].lval)
 			me = int(yyS[yypt-0].lval)
 			if mb < 0 || mb > 31 || me < 0 || me > 31 {
@@ -1495,34 +1495,34 @@ yydefault:
 		//line a.y:823
 		{
 			yyVAL.addr = yyS[yypt-0].addr
-			yyVAL.addr.Type_ = D_CONST
+			yyVAL.addr.Type = D_CONST
 		}
 	case 145:
 		//line a.y:828
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_SCONST
+			yyVAL.addr.Type = D_SCONST
 			yyVAL.addr.U.Sval = yyS[yypt-0].sval
 		}
 	case 146:
 		//line a.y:836
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_FCONST
+			yyVAL.addr.Type = D_FCONST
 			yyVAL.addr.U.Dval = yyS[yypt-0].dval
 		}
 	case 147:
 		//line a.y:842
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_FCONST
+			yyVAL.addr.Type = D_FCONST
 			yyVAL.addr.U.Dval = -yyS[yypt-0].dval
 		}
 	case 148:
 		//line a.y:849
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_CONST
+			yyVAL.addr.Type = D_CONST
 			yyVAL.addr.Offset = yyS[yypt-0].lval
 		}
 	case 149:
@@ -1539,7 +1539,7 @@ yydefault:
 		//line a.y:867
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Type = D_OREG
 			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
 			yyVAL.addr.Offset = 0
 		}
@@ -1547,7 +1547,7 @@ yydefault:
 		//line a.y:874
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Type = D_OREG
 			yyVAL.addr.Reg = int8(yyS[yypt-3].lval)
 			yyVAL.addr.Scale = int8(yyS[yypt-1].lval)
 			yyVAL.addr.Offset = 0
@@ -1558,7 +1558,7 @@ yydefault:
 		//line a.y:885
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Type = D_OREG
 			yyVAL.addr.Reg = int8(yyS[yypt-1].lval)
 			yyVAL.addr.Offset = yyS[yypt-3].lval
 		}
@@ -1566,7 +1566,7 @@ yydefault:
 		//line a.y:894
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Type = D_OREG
 			yyVAL.addr.Name = int8(yyS[yypt-1].lval)
 			yyVAL.addr.Sym = nil
 			yyVAL.addr.Offset = yyS[yypt-3].lval
@@ -1575,7 +1575,7 @@ yydefault:
 		//line a.y:902
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Type = D_OREG
 			yyVAL.addr.Name = int8(yyS[yypt-1].lval)
 			yyVAL.addr.Sym = obj.Linklookup(asm.Ctxt, yyS[yypt-4].sym.Name, 0)
 			yyVAL.addr.Offset = yyS[yypt-3].lval
@@ -1584,7 +1584,7 @@ yydefault:
 		//line a.y:910
 		{
 			yyVAL.addr = nullgen
-			yyVAL.addr.Type_ = D_OREG
+			yyVAL.addr.Type = D_OREG
 			yyVAL.addr.Name = D_STATIC
 			yyVAL.addr.Sym = obj.Linklookup(asm.Ctxt, yyS[yypt-6].sym.Name, 0)
 			yyVAL.addr.Offset = yyS[yypt-3].lval
diff --git a/src/cmd/objwriter/main.go b/src/cmd/objwriter/main.go
index 27c2fb7636..c53089d7ad 100644
--- a/src/cmd/objwriter/main.go
+++ b/src/cmd/objwriter/main.go
@@ -298,7 +298,7 @@ func readsym(b *bufio.Reader, s *obj.LSym) {
 	delete(undef, s)
 	s.Name = rdstring(b)
 	s.Extname = rdstring(b)
-	s.Type_ = int16(rdint(b))
+	s.Type = int16(rdint(b))
 	s.Version = int16(rdint(b))
 	s.Dupok = uint8(rdint(b))
 	s.External = uint8(rdint(b))
@@ -347,7 +347,7 @@ func readsym(b *bufio.Reader, s *obj.LSym) {
 		r.Off = int32(rdint(b))
 		r.Siz = uint8(rdint(b))
 		r.Done = uint8(rdint(b))
-		r.Type_ = int32(rdint(b))
+		r.Type = int32(rdint(b))
 		r.Add = rdint(b)
 		r.Xadd = rdint(b)
 		r.Sym = rdsym(b)
@@ -384,7 +384,7 @@ func readaddr(b *bufio.Reader, a *obj.Addr) {
 	a.U.Branch = rdprog(b)
 	a.Sym = rdsym(b)
 	a.Gotype = rdsym(b)
-	a.Type_ = int16(rdint(b))
+	a.Type = int16(rdint(b))
 	a.Index = uint8(rdint(b))
 	a.Scale = int8(rdint(b))
 	a.Reg = int8(rdint(b))
