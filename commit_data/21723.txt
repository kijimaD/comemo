commit da47902d02c4eb11547241ca32542709341bba7d
Author: Russ Cox <rsc@golang.org>
Date:   Mon Jan 26 15:16:03 2015 -0500

    cmd/9a, cmd/9g, cmd/9l, liblink: update for portable Prog, Addr
    
    Change-Id: I55afed0eabf3c38e72ff105294782ac36446b66b
    Reviewed-on: https://go-review.googlesource.com/3519
    Reviewed-by: Aram Hăvărneanu <aram@mgk.ro>
---
 src/cmd/9a/a.y      |  271 +++++-----
 src/cmd/9a/lex.c    |  192 +++----
 src/cmd/9a/y.tab.c  | 1440 +++++++++++++++++++++++++--------------------------
 src/cmd/9g/cgen.c   |   26 +-
 src/cmd/9g/galign.c |   11 -
 src/cmd/9g/ggen.c   |  116 ++---
 src/cmd/9g/gobj.c   |   48 +-
 src/cmd/9g/gsubr.c  |  171 +++---
 src/cmd/9g/peep.c   |   98 ++--
 src/cmd/9g/prog.c   |   16 +-
 src/cmd/9g/reg.c    |  101 ++--
 src/cmd/9l/9.out.h  |  176 ++++---
 src/liblink/asm9.c  |  213 ++++----
 src/liblink/list9.c |  157 +++---
 src/liblink/obj9.c  |  282 ++++------
 15 files changed, 1574 insertions(+), 1744 deletions(-)

diff --git a/src/cmd/9a/a.y b/src/cmd/9a/a.y
index b366146156..6ca161484b 100644
--- a/src/cmd/9a/a.y
+++ b/src/cmd/9a/a.y
@@ -61,7 +61,7 @@
 %token	<sym>	LNAME LLAB LVAR
 %type	<lval>	con expr pointer offset sreg
 %type	<addr>	addr rreg regaddr name creg freg xlreg lr ctr
-%type	<addr>	imm ximm fimm rel psr lcr cbit fpscr fpscrf msr mask
+%type	<addr>	imm ximm fimm rel psr lcr cbit fpscr msr mask
 %%
 prog:
 |	prog line
@@ -101,107 +101,103 @@ inst:
  */
 	LMOVW rreg ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVW addr ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVW regaddr ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVB rreg ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVB addr ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVB regaddr ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 /*
  * load floats
  */
 |	LFMOV addr ',' freg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LFMOV regaddr ',' freg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LFMOV fimm ',' freg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LFMOV freg ',' freg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LFMOV freg ',' addr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LFMOV freg ',' regaddr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 /*
  * store ints and bytes
  */
 |	LMOVW rreg ',' addr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVW rreg ',' regaddr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVB rreg ',' addr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVB rreg ',' regaddr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 /*
  * store floats
  */
 |	LMOVW freg ',' addr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVW freg ',' regaddr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 /*
  * floating point status
  */
 |	LMOVW fpscr ',' freg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVW freg ','  fpscr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVW freg ',' imm ',' fpscr
 	{
-		outgcode($1, &$2, NREG, &$4, &$6);
+		outgcode($1, &$2, 0, &$4, &$6);
 	}
 |	LMOVW fpscr ',' creg
 	{
-		outcode($1, &$2, NREG, &$4);
-	}
-|	LMOVW imm ',' fpscrf
-	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMTFSB imm ',' con
 	{
@@ -212,15 +208,15 @@ inst:
  */
 |	LMOVW rreg ',' imm ',' lcr
 	{
-		outgcode($1, &$2, NREG, &$4, &$6);
+		outgcode($1, &$2, 0, &$4, &$6);
 	}
 |	LMOVW rreg ',' creg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVW rreg ',' lcr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 /*
  * integer operations
@@ -238,15 +234,15 @@ inst:
 	}
 |	LADDW rreg ',' imm ',' rreg
 	{
-		outgcode($1, &$2, NREG, &$4, &$6);
+		outgcode($1, &$2, 0, &$4, &$6);
 	}
 |	LADDW rreg ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LADDW imm ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LLOGW rreg ',' sreg ',' rreg
 	{
@@ -254,7 +250,7 @@ inst:
 	}
 |	LLOGW rreg ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LSHW rreg ',' sreg ',' rreg
 	{
@@ -262,7 +258,7 @@ inst:
 	}
 |	LSHW rreg ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LSHW imm ',' sreg ',' rreg
 	{
@@ -270,15 +266,15 @@ inst:
 	}
 |	LSHW imm ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LABS rreg ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LABS rreg
 	{
-		outcode($1, &$2, NREG, &$2);
+		outcode($1, &$2, 0, &$2);
 	}
 /*
  * multiply-accumulate
@@ -292,11 +288,11 @@ inst:
  */
 |	LMOVW imm ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVW ximm ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 /*
  * condition register operations
@@ -315,35 +311,35 @@ inst:
  */
 |	LMOVW creg ',' creg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVW psr ',' creg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVW lcr ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVW psr ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVW xlreg ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVW rreg ',' xlreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVW creg ',' psr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVW rreg ',' psr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 /*
  * branch, branch conditional
@@ -352,39 +348,39 @@ inst:
  */
 |	LBRA rel
 	{
-		outcode($1, &nullgen, NREG, &$2);
+		outcode($1, &nullgen, 0, &$2);
 	}
 |	LBRA addr
 	{
-		outcode($1, &nullgen, NREG, &$2);
+		outcode($1, &nullgen, 0, &$2);
 	}
 |	LBRA '(' xlreg ')'
 	{
-		outcode($1, &nullgen, NREG, &$3);
+		outcode($1, &nullgen, 0, &$3);
 	}
 |	LBRA ',' rel
 	{
-		outcode($1, &nullgen, NREG, &$3);
+		outcode($1, &nullgen, 0, &$3);
 	}
 |	LBRA ',' addr
 	{
-		outcode($1, &nullgen, NREG, &$3);
+		outcode($1, &nullgen, 0, &$3);
 	}
 |	LBRA ',' '(' xlreg ')'
 	{
-		outcode($1, &nullgen, NREG, &$4);
+		outcode($1, &nullgen, 0, &$4);
 	}
 |	LBRA creg ',' rel
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LBRA creg ',' addr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LBRA creg ',' '(' xlreg ')'
 	{
-		outcode($1, &$2, NREG, &$5);
+		outcode($1, &$2, 0, &$5);
 	}
 |	LBRA con ',' rel
 	{
@@ -402,25 +398,25 @@ inst:
 	{
 		Addr g;
 		g = nullgen;
-		g.type = D_CONST;
+		g.type = TYPE_CONST;
 		g.offset = $2;
-		outcode($1, &g, $4, &$6);
+		outcode($1, &g, REG_R0+$4, &$6);
 	}
 |	LBRA con ',' con ',' addr
 	{
 		Addr g;
 		g = nullgen;
-		g.type = D_CONST;
+		g.type = TYPE_CONST;
 		g.offset = $2;
-		outcode($1, &g, $4, &$6);
+		outcode($1, &g, REG_R0+$4, &$6);
 	}
 |	LBRA con ',' con ',' '(' xlreg ')'
 	{
 		Addr g;
 		g = nullgen;
-		g.type = D_CONST;
+		g.type = TYPE_CONST;
 		g.offset = $2;
-		outcode($1, &g, $4, &$7);
+		outcode($1, &g, REG_R0+$4, &$7);
 	}
 /*
  * conditional trap
@@ -435,22 +431,22 @@ inst:
 	}
 |	LTRAP rreg comma
 	{
-		outcode($1, &$2, NREG, &nullgen);
+		outcode($1, &$2, 0, &nullgen);
 	}
 |	LTRAP comma
 	{
-		outcode($1, &nullgen, NREG, &nullgen);
+		outcode($1, &nullgen, 0, &nullgen);
 	}
 /*
  * floating point operate
  */
 |	LFCONV freg ',' freg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LFADD freg ',' freg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LFADD freg ',' freg ',' freg
 	{
@@ -462,7 +458,7 @@ inst:
 	}
 |	LFCMP freg ',' freg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LFCMP freg ',' freg ',' creg
 	{
@@ -473,11 +469,11 @@ inst:
  */
 |	LCMP rreg ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LCMP rreg ',' imm
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LCMP rreg ',' rreg ',' creg
 	{
@@ -511,11 +507,11 @@ inst:
  */
 |	LMOVMW addr ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LMOVMW rreg ',' addr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 /*
  * various indexed load/store
@@ -523,96 +519,96 @@ inst:
  */
 |	LXLD regaddr ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LXLD regaddr ',' imm ',' rreg
 	{
-		outgcode($1, &$2, NREG, &$4, &$6);
+		outgcode($1, &$2, 0, &$4, &$6);
 	}
 |	LXST rreg ',' regaddr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LXST rreg ',' imm ',' regaddr
 	{
-		outgcode($1, &$2, NREG, &$4, &$6);
+		outgcode($1, &$2, 0, &$4, &$6);
 	}
 |	LXMV regaddr ',' rreg
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LXMV rreg ',' regaddr
 	{
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LXOP regaddr
 	{
-		outcode($1, &$2, NREG, &nullgen);
+		outcode($1, &$2, 0, &nullgen);
 	}
 /*
  * NOP
  */
 |	LNOP comma
 	{
-		outcode($1, &nullgen, NREG, &nullgen);
+		outcode($1, &nullgen, 0, &nullgen);
 	}
 |	LNOP rreg comma
 	{
-		outcode($1, &$2, NREG, &nullgen);
+		outcode($1, &$2, 0, &nullgen);
 	}
 |	LNOP freg comma
 	{
-		outcode($1, &$2, NREG, &nullgen);
+		outcode($1, &$2, 0, &nullgen);
 	}
 |	LNOP ',' rreg
 	{
-		outcode($1, &nullgen, NREG, &$3);
+		outcode($1, &nullgen, 0, &$3);
 	}
 |	LNOP ',' freg
 	{
-		outcode($1, &nullgen, NREG, &$3);
+		outcode($1, &nullgen, 0, &$3);
 	}
 |	LNOP imm /* SYSCALL $num: load $num to R0 before syscall and restore R0 to 0 afterwards. */
 	{
-		outcode($1, &$2, NREG, &nullgen);
+		outcode($1, &$2, 0, &nullgen);
 	}
 /*
  * word
  */
 |	LWORD imm comma
 	{
-		outcode($1, &$2, NREG, &nullgen);
+		outcode($1, &$2, 0, &nullgen);
 	}
 |	LWORD ximm comma
 	{
-		outcode($1, &$2, NREG, &nullgen);
+		outcode($1, &$2, 0, &nullgen);
 	}
 /*
  * PCDATA
  */
 |	LPCDAT imm ',' imm
 	{
-		if($2.type != D_CONST || $4.type != D_CONST)
+		if($2.type != TYPE_CONST || $4.type != TYPE_CONST)
 			yyerror("arguments to PCDATA must be integer constants");
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 /*
  * FUNCDATA
  */
 |	LFUNCDAT imm ',' addr
 	{
-		if($2.type != D_CONST)
+		if($2.type != TYPE_CONST)
 			yyerror("index for FUNCDATA must be integer constant");
-		if($4.type != D_EXTERN && $4.type != D_STATIC && $4.type != D_OREG)
+		if($4.type != NAME_EXTERN && $4.type != NAME_STATIC && $4.type != TYPE_MEM)
 			yyerror("value for FUNCDATA must be symbol reference");
- 		outcode($1, &$2, NREG, &$4);
+ 		outcode($1, &$2, 0, &$4);
 	}
 /*
  * END
  */
 |	LEND comma
 	{
-		outcode($1, &nullgen, NREG, &nullgen);
+		outcode($1, &nullgen, 0, &nullgen);
 	}
 /*
  * TEXT/GLOBL
@@ -620,7 +616,7 @@ inst:
 |	LTEXT name ',' imm
 	{
 		settext($2.sym);
-		outcode($1, &$2, NREG, &$4);
+		outcode($1, &$2, 0, &$4);
 	}
 |	LTEXT name ',' con ',' imm
 	{
@@ -656,14 +652,14 @@ inst:
  */
 |	LRETRN	comma
 	{
-		outcode($1, &nullgen, NREG, &nullgen);
+		outcode($1, &nullgen, 0, &nullgen);
 	}
 
 rel:
 	con '(' LPC ')'
 	{
 		$$ = nullgen;
-		$$.type = D_BRANCH;
+		$$.type = TYPE_BRANCH;
 		$$.offset = $1 + pc;
 	}
 |	LNAME offset
@@ -672,7 +668,7 @@ rel:
 		$$ = nullgen;
 		if(pass == 2 && $1->type != LLAB)
 			yyerror("undefined label: %s", $1->labelname);
-		$$.type = D_BRANCH;
+		$$.type = TYPE_BRANCH;
 		$$.offset = $1->value + $2;
 	}
 
@@ -680,7 +676,7 @@ rreg:
 	sreg
 	{
 		$$ = nullgen;
-		$$.type = D_REG;
+		$$.type = TYPE_REG;
 		$$.reg = $1;
 	}
 
@@ -692,45 +688,48 @@ lr:
 	LLR
 	{
 		$$ = nullgen;
-		$$.type = D_SPR;
-		$$.offset = $1;
+		$$.type = TYPE_REG;
+		$$.reg = $1;
 	}
 
 lcr:
 	LCR
 	{
 		$$ = nullgen;
-		$$.type = D_CREG;
-		$$.reg = NREG;	/* whole register */
+		$$.type = TYPE_REG;
+		$$.reg = $1;	/* whole register */
 	}
 
 ctr:
 	LCTR
 	{
 		$$ = nullgen;
-		$$.type = D_SPR;
-		$$.offset = $1;
+		$$.type = TYPE_REG;
+		$$.reg = $1;
 	}
 
 msr:
 	LMSR
 	{
 		$$ = nullgen;
-		$$.type = D_MSR;
+		$$.type = TYPE_REG;
+		$$.reg = $1;
 	}
 
 psr:
 	LSPREG
 	{
 		$$ = nullgen;
-		$$.type = D_SPR;
-		$$.offset = $1;
+		$$.type = TYPE_REG;
+		$$.reg = $1;
 	}
 |	LSPR '(' con ')'
 	{
+		if($3 < 0 || $3 >= 1024)
+			yyerror("SPR/DCR out of range");
 		$$ = nullgen;
-		$$.type = $1;
-		$$.offset = $3;
+		$$.type = TYPE_REG;
+		$$.reg = $1 + $3;
 	}
 |	msr
 
@@ -738,51 +737,43 @@ fpscr:
 	LFPSCR
 	{
 		$$ = nullgen;
-		$$.type = D_FPSCR;
-		$$.reg = NREG;
-	}
-
-fpscrf:
-	LFPSCR '(' con ')'
-	{
-		$$ = nullgen;
-		$$.type = D_FPSCR;
-		$$.reg = $3;
+		$$.type = TYPE_REG;
+		$$.reg = $1;
 	}
 
 freg:
 	LFREG
 	{
 		$$ = nullgen;
-		$$.type = D_FREG;
+		$$.type = TYPE_REG;
 		$$.reg = $1;
 	}
 |	LF '(' con ')'
 	{
 		$$ = nullgen;
-		$$.type = D_FREG;
-		$$.reg = $3;
+		$$.type = TYPE_REG;
+		$$.reg = REG_F0 + $3;
 	}
 
 creg:
 	LCREG
 	{
 		$$ = nullgen;
-		$$.type = D_CREG;
+		$$.type = TYPE_REG;
 		$$.reg = $1;
 	}
 |	LCR '(' con ')'
 	{
 		$$ = nullgen;
-		$$.type = D_CREG;
-		$$.reg = $3;
+		$$.type = TYPE_REG;
+		$$.reg = REG_C0 + $3;
 	}
 
 
 cbit:	con
 	{
 		$$ = nullgen;
-		$$.type = D_REG;
+		$$.type = TYPE_REG;
 		$$.reg = $1;
 	}
 
@@ -793,7 +784,7 @@ mask:
 		uint32 v;
 
 		$$ = nullgen;
-		$$.type = D_CONST;
+		$$.type = TYPE_CONST;
 		mb = $1;
 		me = $3;
 		if(mb < 0 || mb > 31 || me < 0 || me > 31){
@@ -811,12 +802,12 @@ ximm:
 	'$' addr
 	{
 		$$ = $2;
-		$$.type = D_CONST;
+		$$.type = TYPE_CONST;
 	}
 |	'$' LSCONST
 	{
 		$$ = nullgen;
-		$$.type = D_SCONST;
+		$$.type = TYPE_SCONST;
 		memcpy($$.u.sval, $2, sizeof($$.u.sval));
 	}
 
@@ -824,20 +815,20 @@ fimm:
 	'$' LFCONST
 	{
 		$$ = nullgen;
-		$$.type = D_FCONST;
+		$$.type = TYPE_FCONST;
 		$$.u.dval = $2;
 	}
 |	'$' '-' LFCONST
 	{
 		$$ = nullgen;
-		$$.type = D_FCONST;
+		$$.type = TYPE_FCONST;
 		$$.u.dval = -$3;
 	}
 
 imm:	'$' con
 	{
 		$$ = nullgen;
-		$$.type = D_CONST;
+		$$.type = TYPE_CONST;
 		$$.offset = $2;
 	}
 
@@ -847,21 +838,21 @@ sreg:
 	{
 		if($$ < 0 || $$ >= NREG)
 			print("register value out of range\n");
-		$$ = $3;
+		$$ = REG_R0 + $3;
 	}
 
 regaddr:
 	'(' sreg ')'
 	{
 		$$ = nullgen;
-		$$.type = D_OREG;
+		$$.type = TYPE_MEM;
 		$$.reg = $2;
 		$$.offset = 0;
 	}
 |	'(' sreg '+' sreg ')'
 	{
 		$$ = nullgen;
-		$$.type = D_OREG;
+		$$.type = TYPE_MEM;
 		$$.reg = $2;
 		$$.scale = $4;
 		$$.offset = 0;
@@ -872,7 +863,7 @@ addr:
 |	con '(' sreg ')'
 	{
 		$$ = nullgen;
-		$$.type = D_OREG;
+		$$.type = TYPE_MEM;
 		$$.reg = $3;
 		$$.offset = $1;
 	}
@@ -881,7 +872,7 @@ name:
 	con '(' pointer ')'
 	{
 		$$ = nullgen;
-		$$.type = D_OREG;
+		$$.type = TYPE_MEM;
 		$$.name = $3;
 		$$.sym = nil;
 		$$.offset = $1;
@@ -889,7 +880,7 @@ name:
 |	LNAME offset '(' pointer ')'
 	{
 		$$ = nullgen;
-		$$.type = D_OREG;
+		$$.type = TYPE_MEM;
 		$$.name = $4;
 		$$.sym = linklookup(ctxt, $1->name, 0);
 		$$.offset = $2;
@@ -897,8 +888,8 @@ name:
 |	LNAME '<' '>' offset '(' LSB ')'
 	{
 		$$ = nullgen;
-		$$.type = D_OREG;
-		$$.name = D_STATIC;
+		$$.type = TYPE_MEM;
+		$$.name = NAME_STATIC;
 		$$.sym = linklookup(ctxt, $1->name, 0);
 		$$.offset = $4;
 	}
diff --git a/src/cmd/9a/lex.c b/src/cmd/9a/lex.c
index e93365909e..210e3dfc12 100644
--- a/src/cmd/9a/lex.c
+++ b/src/cmd/9a/lex.c
@@ -197,97 +197,97 @@ struct
 	ushort	value;
 } itab[] =
 {
-	"SP",		LSP,	D_AUTO,
-	"SB",		LSB,	D_EXTERN,
-	"FP",		LFP,	D_PARAM,
-	"PC",		LPC,	D_BRANCH,
-
-	"LR",		LLR,	D_LR,
-	"CTR",		LCTR,	D_CTR,
-
-	"XER",		LSPREG,	D_XER,
-	"MSR",		LMSR,	D_MSR,
-	"FPSCR",	LFPSCR,	D_FPSCR,
-	"SPR",		LSPR,	D_SPR,
-	"DCR",		LSPR,	D_DCR,
-
-	"CR",		LCR,	0,
-	"CR0",		LCREG,	0,
-	"CR1",		LCREG,	1,
-	"CR2",		LCREG,	2,
-	"CR3",		LCREG,	3,
-	"CR4",		LCREG,	4,
-	"CR5",		LCREG,	5,
-	"CR6",		LCREG,	6,
-	"CR7",		LCREG,	7,
+	"SP",		LSP,	NAME_AUTO,
+	"SB",		LSB,	NAME_EXTERN,
+	"FP",		LFP,	NAME_PARAM,
+	"PC",		LPC,	TYPE_BRANCH,
+
+	"LR",		LLR,	REG_LR,
+	"CTR",		LCTR,	REG_CTR,
+
+	"XER",		LSPREG,	REG_XER,
+	"MSR",		LMSR,	REG_MSR,
+	"FPSCR",	LFPSCR,	REG_FPSCR,
+	"SPR",		LSPR,	REG_SPR0,
+	"DCR",		LSPR,	REG_DCR0,
+
+	"CR",		LCR,	REG_CR,
+	"CR0",		LCREG,	REG_C0,
+	"CR1",		LCREG,	REG_C1,
+	"CR2",		LCREG,	REG_C2,
+	"CR3",		LCREG,	REG_C3,
+	"CR4",		LCREG,	REG_C4,
+	"CR5",		LCREG,	REG_C5,
+	"CR6",		LCREG,	REG_C6,
+	"CR7",		LCREG,	REG_C7,
 
 	"R",		LR,	0,
-	"R0",		LREG,	0,
-	"R1",		LREG,	1,
-	"R2",		LREG,	2,
-	"R3",		LREG,	3,
-	"R4",		LREG,	4,
-	"R5",		LREG,	5,
-	"R6",		LREG,	6,
-	"R7",		LREG,	7,
-	"R8",		LREG,	8,
-	"R9",		LREG,	9,
-	"R10",		LREG,	10,
-	"R11",		LREG,	11,
-	"R12",		LREG,	12,
-	"R13",		LREG,	13,
-	"R14",		LREG,	14,
-	"R15",		LREG,	15,
-	"R16",		LREG,	16,
-	"R17",		LREG,	17,
-	"R18",		LREG,	18,
-	"R19",		LREG,	19,
-	"R20",		LREG,	20,
-	"R21",		LREG,	21,
-	"R22",		LREG,	22,
-	"R23",		LREG,	23,
-	"R24",		LREG,	24,
-	"R25",		LREG,	25,
-	"R26",		LREG,	26,
-	"R27",		LREG,	27,
-	"R28",		LREG,	28,
-	"R29",		LREG,	29,
-	"g",		LREG,	30, // avoid unintentionally clobbering g using R30
-	"R31",		LREG,	31,
+	"R0",		LREG,	REG_R0,
+	"R1",		LREG,	REG_R1,
+	"R2",		LREG,	REG_R2,
+	"R3",		LREG,	REG_R3,
+	"R4",		LREG,	REG_R4,
+	"R5",		LREG,	REG_R5,
+	"R6",		LREG,	REG_R6,
+	"R7",		LREG,	REG_R7,
+	"R8",		LREG,	REG_R8,
+	"R9",		LREG,	REG_R9,
+	"R10",		LREG,	REG_R10,
+	"R11",		LREG,	REG_R11,
+	"R12",		LREG,	REG_R12,
+	"R13",		LREG,	REG_R13,
+	"R14",		LREG,	REG_R14,
+	"R15",		LREG,	REG_R15,
+	"R16",		LREG,	REG_R16,
+	"R17",		LREG,	REG_R17,
+	"R18",		LREG,	REG_R18,
+	"R19",		LREG,	REG_R19,
+	"R20",		LREG,	REG_R20,
+	"R21",		LREG,	REG_R21,
+	"R22",		LREG,	REG_R22,
+	"R23",		LREG,	REG_R23,
+	"R24",		LREG,	REG_R24,
+	"R25",		LREG,	REG_R25,
+	"R26",		LREG,	REG_R26,
+	"R27",		LREG,	REG_R27,
+	"R28",		LREG,	REG_R28,
+	"R29",		LREG,	REG_R29,
+	"g",		LREG,	REG_R30, // avoid unintentionally clobbering g using R30
+	"R31",		LREG,	REG_R31,
 
 	"F",		LF,	0,
-	"F0",		LFREG,	0,
-	"F1",		LFREG,	1,
-	"F2",		LFREG,	2,
-	"F3",		LFREG,	3,
-	"F4",		LFREG,	4,
-	"F5",		LFREG,	5,
-	"F6",		LFREG,	6,
-	"F7",		LFREG,	7,
-	"F8",		LFREG,	8,
-	"F9",		LFREG,	9,
-	"F10",		LFREG,	10,
-	"F11",		LFREG,	11,
-	"F12",		LFREG,	12,
-	"F13",		LFREG,	13,
-	"F14",		LFREG,	14,
-	"F15",		LFREG,	15,
-	"F16",		LFREG,	16,
-	"F17",		LFREG,	17,
-	"F18",		LFREG,	18,
-	"F19",		LFREG,	19,
-	"F20",		LFREG,	20,
-	"F21",		LFREG,	21,
-	"F22",		LFREG,	22,
-	"F23",		LFREG,	23,
-	"F24",		LFREG,	24,
-	"F25",		LFREG,	25,
-	"F26",		LFREG,	26,
-	"F27",		LFREG,	27,
-	"F28",		LFREG,	28,
-	"F29",		LFREG,	29,
-	"F30",		LFREG,	30,
-	"F31",		LFREG,	31,
+	"F0",		LFREG,	REG_F0,
+	"F1",		LFREG,	REG_F1,
+	"F2",		LFREG,	REG_F2,
+	"F3",		LFREG,	REG_F3,
+	"F4",		LFREG,	REG_F4,
+	"F5",		LFREG,	REG_F5,
+	"F6",		LFREG,	REG_F6,
+	"F7",		LFREG,	REG_F7,
+	"F8",		LFREG,	REG_F8,
+	"F9",		LFREG,	REG_F9,
+	"F10",		LFREG,	REG_F10,
+	"F11",		LFREG,	REG_F11,
+	"F12",		LFREG,	REG_F12,
+	"F13",		LFREG,	REG_F13,
+	"F14",		LFREG,	REG_F14,
+	"F15",		LFREG,	REG_F15,
+	"F16",		LFREG,	REG_F16,
+	"F17",		LFREG,	REG_F17,
+	"F18",		LFREG,	REG_F18,
+	"F19",		LFREG,	REG_F19,
+	"F20",		LFREG,	REG_F20,
+	"F21",		LFREG,	REG_F21,
+	"F22",		LFREG,	REG_F22,
+	"F23",		LFREG,	REG_F23,
+	"F24",		LFREG,	REG_F24,
+	"F25",		LFREG,	REG_F25,
+	"F26",		LFREG,	REG_F26,
+	"F27",		LFREG,	REG_F27,
+	"F28",		LFREG,	REG_F28,
+	"F29",		LFREG,	REG_F29,
+	"F30",		LFREG,	REG_F30,
+	"F31",		LFREG,	REG_F31,
 
 	"CREQV",	LCROP, ACREQV,
 	"CRXOR",	LCROP, ACRXOR,
@@ -616,10 +616,10 @@ cinit(void)
 	Sym *s;
 	int i;
 
-	nullgen.type = D_NONE;
-	nullgen.name = D_NONE;
-	nullgen.reg = NREG;
-	nullgen.scale = NREG; // replaced Gen.xreg with Prog.scale
+	nullgen.type = TYPE_NONE;
+	nullgen.name = NAME_NONE;
+	nullgen.reg = 0;
+	nullgen.scale = 0; // replaced Gen.xreg with Prog.scale
 
 	nerrors = 0;
 	iostack = I;
@@ -647,7 +647,7 @@ void
 cclean(void)
 {
 
-	outcode(AEND, &nullgen, NREG, &nullgen);
+	outcode(AEND, &nullgen, 0, &nullgen);
 }
 
 static Prog *lastpc;
@@ -661,13 +661,13 @@ outcode(int a, Addr *g1, int reg, Addr *g2)
 	if(pass == 1)
 		goto out;
 
-	if(g1->scale != NREG) {
-		if(reg != NREG || g2->scale != NREG)
+	if(g1->scale != 0) {
+		if(reg != 0 || g2->scale != 0)
 			yyerror("bad addressing modes");
 		reg = g1->scale;
 	} else
-	if(g2->scale != NREG) {
-		if(reg != NREG)
+	if(g2->scale != 0) {
+		if(reg != 0)
 			yyerror("bad addressing modes");
 		reg = g2->scale;
 	}
diff --git a/src/cmd/9a/y.tab.c b/src/cmd/9a/y.tab.c
index 6025a2402c..9fbe0a914e 100644
--- a/src/cmd/9a/y.tab.c
+++ b/src/cmd/9a/y.tab.c
@@ -465,11 +465,11 @@ union yyalloc
 /* YYNTOKENS -- Number of terminals.  */
 #define YYNTOKENS  81
 /* YYNNTS -- Number of nonterminals.  */
-#define YYNNTS  31
+#define YYNNTS  30
 /* YYNRULES -- Number of rules.  */
-#define YYNRULES  183
+#define YYNRULES  181
 /* YYNRULES -- Number of states.  */
-#define YYNSTATES  453
+#define YYNSTATES  448
 
 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
 #define YYUNDEFTOK  2
@@ -523,112 +523,111 @@ static const yytype_uint16 yyprhs[] =
        0,     0,     3,     4,     7,     8,    13,    18,    23,    26,
       28,    31,    34,    39,    44,    49,    54,    59,    64,    69,
       74,    79,    84,    89,    94,    99,   104,   109,   114,   119,
-     124,   129,   134,   141,   146,   151,   156,   163,   168,   173,
-     180,   187,   194,   199,   204,   211,   216,   223,   228,   235,
-     240,   245,   248,   255,   260,   265,   270,   277,   282,   287,
-     292,   297,   302,   307,   312,   317,   320,   323,   328,   332,
-     336,   342,   347,   352,   359,   364,   369,   376,   383,   390,
-     399,   404,   409,   413,   416,   421,   426,   433,   442,   447,
-     454,   459,   464,   471,   478,   487,   496,   505,   514,   519,
-     524,   529,   536,   541,   548,   553,   558,   561,   564,   568,
-     572,   576,   580,   583,   587,   591,   596,   601,   604,   609,
-     616,   625,   632,   639,   646,   649,   654,   657,   659,   661,
-     663,   665,   667,   669,   671,   673,   678,   680,   682,   687,
-     689,   694,   696,   701,   703,   707,   710,   713,   716,   720,
-     723,   725,   730,   734,   740,   742,   747,   752,   758,   766,
-     767,   769,   770,   773,   776,   778,   780,   782,   784,   786,
-     789,   792,   795,   799,   801,   805,   809,   813,   817,   821,
-     826,   831,   835,   839
+     124,   129,   134,   141,   146,   151,   158,   163,   168,   175,
+     182,   189,   194,   199,   206,   211,   218,   223,   230,   235,
+     240,   243,   250,   255,   260,   265,   272,   277,   282,   287,
+     292,   297,   302,   307,   312,   315,   318,   323,   327,   331,
+     337,   342,   347,   354,   359,   364,   371,   378,   385,   394,
+     399,   404,   408,   411,   416,   421,   428,   437,   442,   449,
+     454,   459,   466,   473,   482,   491,   500,   509,   514,   519,
+     524,   531,   536,   543,   548,   553,   556,   559,   563,   567,
+     571,   575,   578,   582,   586,   591,   596,   599,   604,   611,
+     620,   627,   634,   641,   644,   649,   652,   654,   656,   658,
+     660,   662,   664,   666,   668,   673,   675,   677,   679,   684,
+     686,   691,   693,   697,   700,   703,   706,   710,   713,   715,
+     720,   724,   730,   732,   737,   742,   748,   756,   757,   759,
+     760,   763,   766,   768,   770,   772,   774,   776,   779,   782,
+     785,   789,   791,   795,   799,   803,   807,   811,   816,   821,
+     825,   829
 };
 
 /* YYRHS -- A `-1'-separated list of the rules' RHS.  */
 static const yytype_int8 yyrhs[] =
 {
       82,     0,    -1,    -1,    82,    83,    -1,    -1,    70,    73,
-      84,    83,    -1,    70,    74,   111,    75,    -1,    72,    74,
-     111,    75,    -1,    57,    75,    -1,    75,    -1,    85,    75,
+      84,    83,    -1,    70,    74,   110,    75,    -1,    72,    74,
+     110,    75,    -1,    57,    75,    -1,    75,    -1,    85,    75,
       -1,     1,    75,    -1,    13,    87,    76,    87,    -1,    13,
-     105,    76,    87,    -1,    13,   104,    76,    87,    -1,    14,
-      87,    76,    87,    -1,    14,   105,    76,    87,    -1,    14,
-     104,    76,    87,    -1,    22,   105,    76,    96,    -1,    22,
-     104,    76,    96,    -1,    22,   101,    76,    96,    -1,    22,
-      96,    76,    96,    -1,    22,    96,    76,   105,    -1,    22,
-      96,    76,   104,    -1,    13,    87,    76,   105,    -1,    13,
-      87,    76,   104,    -1,    14,    87,    76,   105,    -1,    14,
-      87,    76,   104,    -1,    13,    96,    76,   105,    -1,    13,
-      96,    76,   104,    -1,    13,    94,    76,    96,    -1,    13,
-      96,    76,    94,    -1,    13,    96,    76,   102,    76,    94,
-      -1,    13,    94,    76,    97,    -1,    13,   102,    76,    95,
-      -1,    66,   102,    76,   110,    -1,    13,    87,    76,   102,
-      76,    90,    -1,    13,    87,    76,    97,    -1,    13,    87,
-      76,    90,    -1,    18,    87,    76,   103,    76,    87,    -1,
-      18,   102,    76,   103,    76,    87,    -1,    18,    87,    76,
-     102,    76,    87,    -1,    18,    87,    76,    87,    -1,    18,
-     102,    76,    87,    -1,    16,    87,    76,   103,    76,    87,
-      -1,    16,    87,    76,    87,    -1,    17,    87,    76,   103,
-      76,    87,    -1,    17,    87,    76,    87,    -1,    17,   102,
-      76,   103,    76,    87,    -1,    17,   102,    76,    87,    -1,
-      15,    87,    76,    87,    -1,    15,    87,    -1,    67,    87,
-      76,   103,    76,    87,    -1,    13,   102,    76,    87,    -1,
-      13,   100,    76,    87,    -1,    20,    98,    76,    98,    -1,
-      20,    98,    76,   110,    76,    98,    -1,    13,    97,    76,
-      97,    -1,    13,    93,    76,    97,    -1,    13,    90,    76,
-      87,    -1,    13,    93,    76,    87,    -1,    13,    88,    76,
-      87,    -1,    13,    87,    76,    88,    -1,    13,    97,    76,
-      93,    -1,    13,    87,    76,    93,    -1,    21,    86,    -1,
-      21,   105,    -1,    21,    77,    88,    78,    -1,    21,    76,
-      86,    -1,    21,    76,   105,    -1,    21,    76,    77,    88,
-      78,    -1,    21,    97,    76,    86,    -1,    21,    97,    76,
-     105,    -1,    21,    97,    76,    77,    88,    78,    -1,    21,
-     110,    76,    86,    -1,    21,   110,    76,   105,    -1,    21,
-     110,    76,    77,    88,    78,    -1,    21,   110,    76,   110,
-      76,    86,    -1,    21,   110,    76,   110,    76,   105,    -1,
-      21,   110,    76,   110,    76,    77,    88,    78,    -1,    27,
-      87,    76,   103,    -1,    27,   102,    76,   103,    -1,    27,
-      87,   107,    -1,    27,   107,    -1,    23,    96,    76,    96,
-      -1,    25,    96,    76,    96,    -1,    25,    96,    76,    96,
-      76,    96,    -1,    26,    96,    76,    96,    76,    96,    76,
-      96,    -1,    24,    96,    76,    96,    -1,    24,    96,    76,
-      96,    76,    97,    -1,    19,    87,    76,    87,    -1,    19,
-      87,    76,   102,    -1,    19,    87,    76,    87,    76,    97,
-      -1,    19,    87,    76,   102,    76,    97,    -1,    62,   102,
-      76,    87,    76,   102,    76,    87,    -1,    62,   102,    76,
-      87,    76,    99,    76,    87,    -1,    62,    87,    76,    87,
-      76,   102,    76,    87,    -1,    62,    87,    76,    87,    76,
-      99,    76,    87,    -1,    63,   105,    76,    87,    -1,    63,
-      87,    76,   105,    -1,    58,   104,    76,    87,    -1,    58,
-     104,    76,   102,    76,    87,    -1,    59,    87,    76,   104,
-      -1,    59,    87,    76,   102,    76,   104,    -1,    61,   104,
-      76,    87,    -1,    61,    87,    76,   104,    -1,    60,   104,
-      -1,    29,   107,    -1,    29,    87,   107,    -1,    29,    96,
-     107,    -1,    29,    76,    87,    -1,    29,    76,    96,    -1,
-      29,   102,    -1,    32,   102,   107,    -1,    32,   100,   107,
-      -1,    55,   102,    76,   102,    -1,    56,   102,    76,   105,
-      -1,    30,   107,    -1,    33,   106,    76,   102,    -1,    33,
-     106,    76,   110,    76,   102,    -1,    33,   106,    76,   110,
-      76,   102,     9,   110,    -1,    34,   106,    11,   110,    76,
-     102,    -1,    34,   106,    11,   110,    76,   100,    -1,    34,
-     106,    11,   110,    76,   101,    -1,    35,   107,    -1,   110,
-      77,    40,    78,    -1,    70,   108,    -1,   103,    -1,    89,
-      -1,    91,    -1,    49,    -1,    46,    -1,    50,    -1,    54,
-      -1,    52,    -1,    51,    77,   110,    78,    -1,    92,    -1,
-      48,    -1,    48,    77,   110,    78,    -1,    44,    -1,    47,
-      77,   110,    78,    -1,    41,    -1,    46,    77,   110,    78,
-      -1,   110,    -1,   110,    76,   110,    -1,    79,   105,    -1,
+     104,    76,    87,    -1,    13,   103,    76,    87,    -1,    14,
+      87,    76,    87,    -1,    14,   104,    76,    87,    -1,    14,
+     103,    76,    87,    -1,    22,   104,    76,    95,    -1,    22,
+     103,    76,    95,    -1,    22,   100,    76,    95,    -1,    22,
+      95,    76,    95,    -1,    22,    95,    76,   104,    -1,    22,
+      95,    76,   103,    -1,    13,    87,    76,   104,    -1,    13,
+      87,    76,   103,    -1,    14,    87,    76,   104,    -1,    14,
+      87,    76,   103,    -1,    13,    95,    76,   104,    -1,    13,
+      95,    76,   103,    -1,    13,    94,    76,    95,    -1,    13,
+      95,    76,    94,    -1,    13,    95,    76,   101,    76,    94,
+      -1,    13,    94,    76,    96,    -1,    66,   101,    76,   109,
+      -1,    13,    87,    76,   101,    76,    90,    -1,    13,    87,
+      76,    96,    -1,    13,    87,    76,    90,    -1,    18,    87,
+      76,   102,    76,    87,    -1,    18,   101,    76,   102,    76,
+      87,    -1,    18,    87,    76,   101,    76,    87,    -1,    18,
+      87,    76,    87,    -1,    18,   101,    76,    87,    -1,    16,
+      87,    76,   102,    76,    87,    -1,    16,    87,    76,    87,
+      -1,    17,    87,    76,   102,    76,    87,    -1,    17,    87,
+      76,    87,    -1,    17,   101,    76,   102,    76,    87,    -1,
+      17,   101,    76,    87,    -1,    15,    87,    76,    87,    -1,
+      15,    87,    -1,    67,    87,    76,   102,    76,    87,    -1,
+      13,   101,    76,    87,    -1,    13,    99,    76,    87,    -1,
+      20,    97,    76,    97,    -1,    20,    97,    76,   109,    76,
+      97,    -1,    13,    96,    76,    96,    -1,    13,    93,    76,
+      96,    -1,    13,    90,    76,    87,    -1,    13,    93,    76,
+      87,    -1,    13,    88,    76,    87,    -1,    13,    87,    76,
+      88,    -1,    13,    96,    76,    93,    -1,    13,    87,    76,
+      93,    -1,    21,    86,    -1,    21,   104,    -1,    21,    77,
+      88,    78,    -1,    21,    76,    86,    -1,    21,    76,   104,
+      -1,    21,    76,    77,    88,    78,    -1,    21,    96,    76,
+      86,    -1,    21,    96,    76,   104,    -1,    21,    96,    76,
+      77,    88,    78,    -1,    21,   109,    76,    86,    -1,    21,
+     109,    76,   104,    -1,    21,   109,    76,    77,    88,    78,
+      -1,    21,   109,    76,   109,    76,    86,    -1,    21,   109,
+      76,   109,    76,   104,    -1,    21,   109,    76,   109,    76,
+      77,    88,    78,    -1,    27,    87,    76,   102,    -1,    27,
+     101,    76,   102,    -1,    27,    87,   106,    -1,    27,   106,
+      -1,    23,    95,    76,    95,    -1,    25,    95,    76,    95,
+      -1,    25,    95,    76,    95,    76,    95,    -1,    26,    95,
+      76,    95,    76,    95,    76,    95,    -1,    24,    95,    76,
+      95,    -1,    24,    95,    76,    95,    76,    96,    -1,    19,
+      87,    76,    87,    -1,    19,    87,    76,   101,    -1,    19,
+      87,    76,    87,    76,    96,    -1,    19,    87,    76,   101,
+      76,    96,    -1,    62,   101,    76,    87,    76,   101,    76,
+      87,    -1,    62,   101,    76,    87,    76,    98,    76,    87,
+      -1,    62,    87,    76,    87,    76,   101,    76,    87,    -1,
+      62,    87,    76,    87,    76,    98,    76,    87,    -1,    63,
+     104,    76,    87,    -1,    63,    87,    76,   104,    -1,    58,
+     103,    76,    87,    -1,    58,   103,    76,   101,    76,    87,
+      -1,    59,    87,    76,   103,    -1,    59,    87,    76,   101,
+      76,   103,    -1,    61,   103,    76,    87,    -1,    61,    87,
+      76,   103,    -1,    60,   103,    -1,    29,   106,    -1,    29,
+      87,   106,    -1,    29,    95,   106,    -1,    29,    76,    87,
+      -1,    29,    76,    95,    -1,    29,   101,    -1,    32,   101,
+     106,    -1,    32,    99,   106,    -1,    55,   101,    76,   101,
+      -1,    56,   101,    76,   104,    -1,    30,   106,    -1,    33,
+     105,    76,   101,    -1,    33,   105,    76,   109,    76,   101,
+      -1,    33,   105,    76,   109,    76,   101,     9,   109,    -1,
+      34,   105,    11,   109,    76,   101,    -1,    34,   105,    11,
+     109,    76,    99,    -1,    34,   105,    11,   109,    76,   100,
+      -1,    35,   106,    -1,   109,    77,    40,    78,    -1,    70,
+     107,    -1,   102,    -1,    89,    -1,    91,    -1,    49,    -1,
+      46,    -1,    50,    -1,    54,    -1,    52,    -1,    51,    77,
+     109,    78,    -1,    92,    -1,    48,    -1,    44,    -1,    47,
+      77,   109,    78,    -1,    41,    -1,    46,    77,   109,    78,
+      -1,   109,    -1,   109,    76,   109,    -1,    79,   104,    -1,
       79,    69,    -1,    79,    68,    -1,    79,     9,    68,    -1,
-      79,   110,    -1,    43,    -1,    45,    77,   110,    78,    -1,
-      77,   103,    78,    -1,    77,   103,     8,   103,    78,    -1,
-     106,    -1,   110,    77,   103,    78,    -1,   110,    77,   109,
-      78,    -1,    70,   108,    77,   109,    78,    -1,    70,     6,
-       7,   108,    77,    38,    78,    -1,    -1,    76,    -1,    -1,
-       8,   110,    -1,     9,   110,    -1,    38,    -1,    37,    -1,
-      39,    -1,    36,    -1,    72,    -1,     9,   110,    -1,     8,
-     110,    -1,    80,   110,    -1,    77,   111,    78,    -1,   110,
-      -1,   111,     8,   111,    -1,   111,     9,   111,    -1,   111,
-      10,   111,    -1,   111,    11,   111,    -1,   111,    12,   111,
-      -1,   111,     6,     6,   111,    -1,   111,     7,     7,   111,
-      -1,   111,     5,   111,    -1,   111,     4,   111,    -1,   111,
-       3,   111,    -1
+      79,   109,    -1,    43,    -1,    45,    77,   109,    78,    -1,
+      77,   102,    78,    -1,    77,   102,     8,   102,    78,    -1,
+     105,    -1,   109,    77,   102,    78,    -1,   109,    77,   108,
+      78,    -1,    70,   107,    77,   108,    78,    -1,    70,     6,
+       7,   107,    77,    38,    78,    -1,    -1,    76,    -1,    -1,
+       8,   109,    -1,     9,   109,    -1,    38,    -1,    37,    -1,
+      39,    -1,    36,    -1,    72,    -1,     9,   109,    -1,     8,
+     109,    -1,    80,   109,    -1,    77,   110,    78,    -1,   109,
+      -1,   110,     8,   110,    -1,   110,     9,   110,    -1,   110,
+      10,   110,    -1,   110,    11,   110,    -1,   110,    12,   110,
+      -1,   110,     6,     6,   110,    -1,   110,     7,     7,   110,
+      -1,   110,     5,   110,    -1,   110,     4,   110,    -1,   110,
+       3,   110,    -1
 };
 
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
@@ -637,22 +636,22 @@ static const yytype_uint16 yyrline[] =
        0,    66,    66,    67,    71,    70,    79,    84,    90,    94,
       95,    96,   102,   106,   110,   114,   118,   122,   129,   133,
      137,   141,   145,   149,   156,   160,   164,   168,   175,   179,
-     186,   190,   194,   198,   202,   206,   213,   217,   221,   231,
+     186,   190,   194,   198,   202,   209,   213,   217,   227,   231,
      235,   239,   243,   247,   251,   255,   259,   263,   267,   271,
-     275,   279,   286,   293,   297,   304,   308,   316,   320,   324,
-     328,   332,   336,   340,   344,   353,   357,   361,   365,   369,
-     373,   377,   381,   385,   389,   393,   397,   401,   409,   417,
-     428,   432,   436,   440,   447,   451,   455,   459,   463,   467,
-     474,   478,   482,   486,   493,   497,   501,   505,   512,   516,
-     524,   528,   532,   536,   540,   544,   548,   555,   559,   563,
-     567,   571,   575,   582,   586,   593,   602,   613,   620,   625,
-     632,   642,   646,   650,   657,   663,   669,   680,   688,   689,
-     692,   700,   708,   716,   723,   729,   735,   738,   746,   754,
-     760,   768,   774,   782,   790,   811,   816,   824,   830,   837,
-     845,   846,   854,   861,   871,   872,   881,   889,   897,   906,
-     907,   910,   913,   917,   923,   924,   925,   928,   929,   933,
-     937,   941,   945,   951,   952,   956,   960,   964,   968,   972,
-     976,   980,   984,   988
+     275,   282,   289,   293,   300,   304,   312,   316,   320,   324,
+     328,   332,   336,   340,   349,   353,   357,   361,   365,   369,
+     373,   377,   381,   385,   389,   393,   397,   405,   413,   424,
+     428,   432,   436,   443,   447,   451,   455,   459,   463,   470,
+     474,   478,   482,   489,   493,   497,   501,   508,   512,   520,
+     524,   528,   532,   536,   540,   544,   551,   555,   559,   563,
+     567,   571,   578,   582,   589,   598,   609,   616,   621,   628,
+     638,   642,   646,   653,   659,   665,   676,   684,   685,   688,
+     696,   704,   712,   720,   726,   734,   737,   745,   751,   759,
+     765,   773,   781,   802,   807,   815,   821,   828,   836,   837,
+     845,   852,   862,   863,   872,   880,   888,   897,   898,   901,
+     904,   908,   914,   915,   916,   919,   920,   924,   928,   932,
+     936,   942,   943,   947,   951,   955,   959,   963,   967,   971,
+     975,   979
 };
 #endif
 
@@ -672,9 +671,8 @@ static const char *const yytname[] =
   "LMA", "LFCONST", "LSCONST", "LNAME", "LLAB", "LVAR", "':'", "'='",
   "';'", "','", "'('", "')'", "'$'", "'~'", "$accept", "prog", "line",
   "@1", "inst", "rel", "rreg", "xlreg", "lr", "lcr", "ctr", "msr", "psr",
-  "fpscr", "fpscrf", "freg", "creg", "cbit", "mask", "ximm", "fimm", "imm",
-  "sreg", "regaddr", "addr", "name", "comma", "offset", "pointer", "con",
-  "expr", 0
+  "fpscr", "freg", "creg", "cbit", "mask", "ximm", "fimm", "imm", "sreg",
+  "regaddr", "addr", "name", "comma", "offset", "pointer", "con", "expr", 0
 };
 #endif
 
@@ -710,13 +708,13 @@ static const yytype_uint8 yyr1[] =
       85,    85,    85,    85,    85,    85,    85,    85,    85,    85,
       85,    85,    85,    85,    85,    85,    85,    85,    85,    85,
       85,    85,    85,    85,    85,    85,    85,    85,    85,    85,
-      85,    85,    85,    85,    85,    86,    86,    87,    88,    88,
-      89,    90,    91,    92,    93,    93,    93,    94,    95,    96,
-      96,    97,    97,    98,    99,   100,   100,   101,   101,   102,
-     103,   103,   104,   104,   105,   105,   106,   106,   106,   107,
-     107,   108,   108,   108,   109,   109,   109,   110,   110,   110,
-     110,   110,   110,   111,   111,   111,   111,   111,   111,   111,
-     111,   111,   111,   111
+      85,    85,    85,    85,    86,    86,    87,    88,    88,    89,
+      90,    91,    92,    93,    93,    93,    94,    95,    95,    96,
+      96,    97,    98,    99,    99,   100,   100,   101,   102,   102,
+     103,   103,   104,   104,   105,   105,   105,   106,   106,   107,
+     107,   107,   108,   108,   108,   109,   109,   109,   109,   109,
+     109,   110,   110,   110,   110,   110,   110,   110,   110,   110,
+     110,   110
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
@@ -725,22 +723,22 @@ static const yytype_uint8 yyr2[] =
        0,     2,     0,     2,     0,     4,     4,     4,     2,     1,
        2,     2,     4,     4,     4,     4,     4,     4,     4,     4,
        4,     4,     4,     4,     4,     4,     4,     4,     4,     4,
-       4,     4,     6,     4,     4,     4,     6,     4,     4,     6,
-       6,     6,     4,     4,     6,     4,     6,     4,     6,     4,
-       4,     2,     6,     4,     4,     4,     6,     4,     4,     4,
-       4,     4,     4,     4,     4,     2,     2,     4,     3,     3,
-       5,     4,     4,     6,     4,     4,     6,     6,     6,     8,
-       4,     4,     3,     2,     4,     4,     6,     8,     4,     6,
-       4,     4,     6,     6,     8,     8,     8,     8,     4,     4,
-       4,     6,     4,     6,     4,     4,     2,     2,     3,     3,
-       3,     3,     2,     3,     3,     4,     4,     2,     4,     6,
-       8,     6,     6,     6,     2,     4,     2,     1,     1,     1,
-       1,     1,     1,     1,     1,     4,     1,     1,     4,     1,
-       4,     1,     4,     1,     3,     2,     2,     2,     3,     2,
-       1,     4,     3,     5,     1,     4,     4,     5,     7,     0,
-       1,     0,     2,     2,     1,     1,     1,     1,     1,     2,
-       2,     2,     3,     1,     3,     3,     3,     3,     3,     4,
-       4,     3,     3,     3
+       4,     4,     6,     4,     4,     6,     4,     4,     6,     6,
+       6,     4,     4,     6,     4,     6,     4,     6,     4,     4,
+       2,     6,     4,     4,     4,     6,     4,     4,     4,     4,
+       4,     4,     4,     4,     2,     2,     4,     3,     3,     5,
+       4,     4,     6,     4,     4,     6,     6,     6,     8,     4,
+       4,     3,     2,     4,     4,     6,     8,     4,     6,     4,
+       4,     6,     6,     8,     8,     8,     8,     4,     4,     4,
+       6,     4,     6,     4,     4,     2,     2,     3,     3,     3,
+       3,     2,     3,     3,     4,     4,     2,     4,     6,     8,
+       6,     6,     6,     2,     4,     2,     1,     1,     1,     1,
+       1,     1,     1,     1,     4,     1,     1,     1,     4,     1,
+       4,     1,     3,     2,     2,     2,     3,     2,     1,     4,
+       3,     5,     1,     4,     4,     5,     7,     0,     1,     0,
+       2,     2,     1,     1,     1,     1,     1,     2,     2,     2,
+       3,     1,     3,     3,     3,     3,     3,     4,     4,     3,
+       3,     3
 };
 
 /* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
@@ -749,122 +747,118 @@ static const yytype_uint8 yyr2[] =
 static const yytype_uint8 yydefact[] =
 {
        2,     0,     1,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,   159,   159,
-     159,     0,     0,     0,   159,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,   157,   157,
+     157,     0,     0,     0,   157,     0,     0,     0,     0,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     9,     3,
-       0,    11,     0,     0,   167,   141,   150,   139,     0,   131,
-       0,   137,   130,   132,     0,   134,   133,   161,   168,     0,
-       0,     0,     0,     0,   128,     0,   129,   136,     0,     0,
-       0,     0,     0,     0,   127,     0,     0,   154,     0,     0,
-       0,     0,    51,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,   143,     0,   161,     0,     0,    65,     0,    66,
+       0,    11,     0,     0,   165,   139,   148,   137,     0,   130,
+       0,   136,   129,   131,     0,   133,   132,   159,   166,     0,
+       0,     0,     0,     0,   127,     0,   128,   135,     0,     0,
+       0,     0,     0,     0,   126,     0,     0,   152,     0,     0,
+       0,     0,    50,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,   141,     0,   159,     0,     0,    64,     0,    65,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-     160,   159,     0,    83,   160,   159,   159,   112,   107,   117,
-     159,   159,     0,     0,     0,   124,     0,     0,     8,     0,
-       0,     0,   106,     0,     0,     0,     0,     0,     0,     0,
-       0,     4,     0,     0,    10,   170,   169,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,   173,     0,   146,   145,
-     149,   171,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,   149,
-       0,     0,     0,     0,     0,     0,   126,     0,    68,    69,
-       0,     0,     0,     0,     0,     0,   147,     0,     0,     0,
-       0,     0,     0,     0,     0,   160,    82,     0,   110,   111,
-     108,   109,   114,   113,     0,     0,     0,     0,     0,     0,
+     158,   157,     0,    82,   158,   157,   157,   111,   106,   116,
+     157,   157,     0,     0,     0,   123,     0,     0,     8,     0,
+       0,     0,   105,     0,     0,     0,     0,     0,     0,     0,
+       0,     4,     0,     0,    10,   168,   167,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,   171,     0,   144,   143,
+     147,   169,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,   147,
+       0,     0,     0,     0,     0,     0,   125,     0,    67,    68,
+       0,     0,     0,     0,     0,     0,   145,     0,     0,     0,
+       0,     0,     0,     0,     0,   158,    81,     0,   109,   110,
+     107,   108,   113,   112,     0,     0,     0,     0,     0,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,   161,   162,   163,     0,
-       0,   152,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,   172,    12,    62,    38,    64,    37,     0,    25,
-      24,    61,    59,    60,    58,    30,    33,    31,     0,    29,
-      28,    63,    57,    54,     0,    53,    34,    14,    13,   165,
-     164,   166,     0,     0,    15,    27,    26,    17,    16,    50,
-      45,   127,    47,   127,    49,   127,    42,     0,   127,    43,
-     127,    90,    91,    55,   143,     0,    67,     0,    71,    72,
-       0,    74,    75,     0,     0,   148,    21,    23,    22,    20,
-      19,    18,    84,    88,    85,     0,    80,    81,   118,     0,
-       0,   115,   116,   100,     0,     0,   102,   105,   104,     0,
-       0,    99,    98,    35,     0,     5,     6,     7,   151,   142,
-     140,   135,     0,     0,     0,   183,   182,   181,     0,     0,
-     174,   175,   176,   177,   178,     0,     0,     0,   155,   156,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,    70,
-       0,     0,     0,   125,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,   157,   153,   179,   180,   131,
-      36,    32,     0,    44,    46,    48,    41,    39,    40,    92,
-      93,    56,    73,    76,     0,    77,    78,    89,    86,     0,
-     119,     0,   122,   123,   121,   101,   103,     0,     0,     0,
-       0,     0,    52,     0,   138,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,   158,    79,    87,   120,    97,    96,
-     144,    95,    94
+       0,     0,     0,     0,     0,     0,   159,   160,   161,     0,
+       0,   150,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,   170,    12,    61,    37,    63,    36,     0,    25,
+      24,    60,    58,    59,    57,    30,    33,    31,     0,    29,
+      28,    62,    56,    53,    52,    14,    13,   163,   162,   164,
+       0,     0,    15,    27,    26,    17,    16,    49,    44,   126,
+      46,   126,    48,   126,    41,     0,   126,    42,   126,    89,
+      90,    54,   141,     0,    66,     0,    70,    71,     0,    73,
+      74,     0,     0,   146,    21,    23,    22,    20,    19,    18,
+      83,    87,    84,     0,    79,    80,   117,     0,     0,   114,
+     115,    99,     0,     0,   101,   104,   103,     0,     0,    98,
+      97,    34,     0,     5,     6,     7,   149,   140,   138,   134,
+       0,     0,     0,   181,   180,   179,     0,     0,   172,   173,
+     174,   175,   176,     0,     0,   153,   154,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    69,     0,     0,     0,
+     124,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,   155,   151,   177,   178,   130,    35,    32,    43,
+      45,    47,    40,    38,    39,    91,    92,    55,    72,    75,
+       0,    76,    77,    88,    85,     0,   118,     0,   121,   122,
+     120,   100,   102,     0,     0,     0,     0,     0,    51,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,   156,
+      78,    86,   119,    96,    95,   142,    94,    93
 };
 
 /* YYDEFGOTO[NTERM-NUM].  */
 static const yytype_int16 yydefgoto[] =
 {
       -1,     1,    39,   229,    40,    97,    62,    63,    64,    65,
-      66,    67,    68,    69,   276,    70,    71,    91,   427,    72,
-     103,    73,    74,    75,   159,    77,   113,   154,   283,   156,
-     157
+      66,    67,    68,    69,    70,    71,    91,   423,    72,   103,
+      73,    74,    75,   159,    77,   113,   154,   281,   156,   157
 };
 
 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
-#define YYPACT_NINF -176
+#define YYPACT_NINF -178
 static const yytype_int16 yypact[] =
 {
-    -176,   464,  -176,   -63,   560,   637,    97,    97,   -24,   -24,
-      97,   556,   317,   618,    12,    12,    12,    12,   -27,    47,
-     -47,   -29,   725,   725,   -47,   -26,   -26,   -43,   -17,    97,
-     -17,   -23,   -24,   658,   -26,    97,    51,   -11,  -176,  -176,
-      -2,  -176,   556,   556,  -176,  -176,  -176,  -176,    -1,     2,
-      11,  -176,  -176,  -176,    24,  -176,  -176,    91,  -176,    26,
-     716,   556,    57,    65,  -176,    85,  -176,  -176,    92,    98,
-     104,   110,   119,   134,  -176,   155,   160,  -176,    69,   162,
-     165,   170,   172,   176,   556,   179,   180,   182,   183,   185,
-     556,   187,  -176,     2,    91,   736,   326,  -176,   196,  -176,
-      52,     6,   197,   198,   202,   203,   215,   216,   217,   222,
-    -176,   223,   235,  -176,    73,   -47,   -47,  -176,  -176,  -176,
-     -47,   -47,   239,    79,   178,  -176,   240,   246,  -176,    97,
-     247,   248,  -176,   252,   253,   255,   262,   263,   266,   267,
-     268,  -176,   556,   556,  -176,  -176,  -176,   556,   556,   556,
-     556,   193,   556,   556,   166,     9,  -176,   278,  -176,  -176,
-      69,  -176,   607,    97,    97,   109,    20,   683,    61,    97,
-      27,    97,    97,   340,   637,    97,    97,    97,    97,  -176,
-      97,    97,   -24,    97,   -24,   556,   166,   326,  -176,  -176,
-     199,   152,   742,   762,   153,   283,  -176,   696,    12,    12,
-      12,    12,    12,    12,    12,    97,  -176,    97,  -176,  -176,
-    -176,  -176,  -176,  -176,   382,     4,   556,   -26,   725,   -24,
-      72,   -17,    97,    97,    97,   725,    97,   556,    97,   527,
-     436,   567,   274,   276,   277,   279,   154,  -176,  -176,     4,
-      97,  -176,   556,   556,   556,   353,   339,   556,   556,   556,
-     556,   556,  -176,  -176,  -176,  -176,  -176,  -176,   284,  -176,
-    -176,  -176,  -176,  -176,  -176,  -176,  -176,  -176,   295,  -176,
-    -176,  -176,  -176,  -176,   303,  -176,  -176,  -176,  -176,  -176,
-    -176,  -176,   304,   308,  -176,  -176,  -176,  -176,  -176,  -176,
-    -176,   305,  -176,   316,  -176,   323,  -176,   325,   333,  -176,
-     334,   335,   336,  -176,   343,   342,  -176,   326,  -176,  -176,
-     326,  -176,  -176,   139,   344,  -176,  -176,  -176,  -176,  -176,
-    -176,  -176,  -176,   345,   348,   349,  -176,  -176,  -176,   354,
-     355,  -176,  -176,  -176,   356,   357,  -176,  -176,  -176,   360,
-     373,  -176,  -176,  -176,   374,  -176,  -176,  -176,  -176,  -176,
-    -176,  -176,   327,   377,   379,   298,   612,   506,   556,   556,
-     125,   125,  -176,  -176,  -176,   405,   410,   556,  -176,  -176,
-      97,    97,    97,    97,    97,    97,    -8,    -8,   556,  -176,
-     385,   388,   782,  -176,    -8,    12,    12,   -26,   381,    97,
-     -17,   382,   382,    97,   429,  -176,  -176,   498,   498,  -176,
-    -176,  -176,   390,  -176,  -176,  -176,  -176,  -176,  -176,  -176,
-    -176,  -176,  -176,  -176,   326,  -176,  -176,  -176,  -176,   393,
-     462,   712,  -176,  -176,  -176,  -176,  -176,   398,   399,   416,
-     419,   426,  -176,   451,  -176,   454,    12,   556,   328,    97,
-      97,   556,    97,    97,  -176,  -176,  -176,  -176,  -176,  -176,
-    -176,  -176,  -176
+    -178,   460,  -178,   -25,   556,   306,   -11,   -11,   -24,   -24,
+     -11,   419,   615,   632,   -22,   -22,   -22,   -22,   -10,   -27,
+     -23,   -17,   267,   267,   -23,     0,     0,     1,    15,   -11,
+      15,    11,   -24,   654,     0,   -11,   -32,    52,  -178,  -178,
+      54,  -178,   419,   419,  -178,  -178,  -178,  -178,    74,    78,
+      79,  -178,  -178,  -178,    84,  -178,  -178,    55,  -178,   692,
+      51,   419,    68,    86,  -178,    87,  -178,  -178,    92,    98,
+     104,   110,   119,   120,  -178,   127,   137,  -178,   123,   139,
+     140,   146,   147,   150,   419,   165,   169,   170,   172,   178,
+     419,   179,  -178,    78,    55,   724,   706,  -178,   180,  -178,
+      41,     3,   182,   185,   187,   196,   197,   201,   204,   205,
+    -178,   210,   216,  -178,    56,   -23,   -23,  -178,  -178,  -178,
+     -23,   -23,   217,   218,   286,  -178,   223,   225,  -178,   -11,
+     226,   231,  -178,   232,   234,   245,   247,   248,   249,   252,
+     253,  -178,   419,   419,  -178,  -178,  -178,   419,   419,   419,
+     419,   302,   419,   419,   257,     7,  -178,   384,  -178,  -178,
+     123,  -178,   603,   -11,   -11,    48,    26,    66,   233,   -11,
+     -11,   -11,   -11,   251,   306,   -11,   -11,   -11,   -11,  -178,
+     -11,   -11,   -24,   -11,   -24,   419,   257,   706,  -178,  -178,
+     261,   262,   735,   739,   199,   273,  -178,   669,   -22,   -22,
+     -22,   -22,   -22,   -22,   -22,   -11,  -178,   -11,  -178,  -178,
+    -178,  -178,  -178,  -178,   745,    73,   419,     0,   267,   -24,
+      70,    15,   -11,   -11,   -11,   267,   -11,   419,   -11,   523,
+     431,   563,   265,   268,   272,   274,   124,  -178,  -178,    73,
+     -11,  -178,   419,   419,   419,   348,   352,   419,   419,   419,
+     419,   419,  -178,  -178,  -178,  -178,  -178,  -178,   284,  -178,
+    -178,  -178,  -178,  -178,  -178,  -178,  -178,  -178,   285,  -178,
+    -178,  -178,  -178,  -178,  -178,  -178,  -178,  -178,  -178,  -178,
+     290,   293,  -178,  -178,  -178,  -178,  -178,  -178,  -178,   296,
+    -178,   297,  -178,   298,  -178,   299,   301,  -178,   303,   308,
+     321,  -178,   322,   323,  -178,   706,  -178,  -178,   706,  -178,
+    -178,    63,   324,  -178,  -178,  -178,  -178,  -178,  -178,  -178,
+    -178,   328,   329,   330,  -178,  -178,  -178,   331,   332,  -178,
+    -178,  -178,   333,   340,  -178,  -178,  -178,   341,   342,  -178,
+    -178,  -178,   343,  -178,  -178,  -178,  -178,  -178,  -178,  -178,
+     344,   353,   366,   609,   502,   832,   419,   419,    96,    96,
+    -178,  -178,  -178,   354,   351,  -178,  -178,   -11,   -11,   -11,
+     -11,   -11,   -11,    -3,    -3,   419,  -178,   367,   368,   757,
+    -178,    -3,   -22,   -22,     0,   369,   -11,    15,   745,   745,
+     -11,   409,  -178,  -178,   181,   181,  -178,  -178,  -178,  -178,
+    -178,  -178,  -178,  -178,  -178,  -178,  -178,  -178,  -178,  -178,
+     706,  -178,  -178,  -178,  -178,   346,   442,   650,  -178,  -178,
+    -178,  -178,  -178,   377,   378,   380,   381,   382,  -178,   385,
+     386,   -22,   419,   782,   -11,   -11,   419,   -11,   -11,  -178,
+    -178,  -178,  -178,  -178,  -178,  -178,  -178,  -178
 };
 
 /* YYPGOTO[NTERM-NUM].  */
 static const yytype_int16 yypgoto[] =
 {
-    -176,  -176,   306,  -176,  -176,   -88,    -5,   -73,  -176,  -154,
-    -176,  -176,  -137,  -158,  -176,    67,    39,  -175,   141,   -15,
-     149,   113,   167,    80,    32,   200,   124,   -83,   299,    35,
-      70
+    -178,  -178,   230,  -178,  -178,   -88,    -5,   -65,  -178,  -153,
+    -178,  -178,  -139,  -156,    67,    39,  -177,    76,   -15,    81,
+     116,   175,    85,    32,   131,   211,   -84,   258,    35,    69
 };
 
 /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
@@ -874,183 +868,183 @@ static const yytype_int16 yypgoto[] =
 #define YYTABLE_NINF -1
 static const yytype_uint16 yytable[] =
 {
-      79,    82,    83,    85,    87,    89,   120,   188,   255,   267,
-     303,   186,    41,   111,   115,   195,    46,   240,    48,    46,
-      46,    48,    48,   191,   131,   256,   133,   135,   137,   110,
-     140,   271,   128,    45,    42,    43,    76,    81,    93,    78,
-      78,   279,   280,   281,    99,   105,    92,   100,    78,   110,
-      60,    98,    84,    84,   129,    84,    47,   123,   123,    50,
-     129,    45,    44,   143,    47,   138,    93,    50,    78,    46,
-      46,    48,    48,   144,   196,   274,   147,   145,   146,   148,
-     102,   106,   107,   108,   109,    80,   116,   241,   149,   254,
-      46,    47,    48,   104,    50,   160,   161,   151,    58,   152,
-     153,   150,    45,    90,   308,   311,    61,    93,   130,   208,
-     132,   134,    54,    55,   305,    56,    46,    47,    48,   179,
-      50,    86,    88,   114,   141,   142,    84,   189,   193,   194,
-     190,   112,   117,   162,   121,   249,   250,   251,   126,   127,
-      46,   163,    48,   118,   119,   136,   173,   139,   125,   129,
-      45,    84,    46,   352,    48,    93,   215,   253,   261,   262,
-     263,   164,   152,   153,   273,   275,   277,   278,   165,   284,
-     287,   288,   289,   290,   166,   292,   294,   296,   299,   301,
-     167,   209,   232,   233,   234,   235,   168,   237,   238,   216,
-     279,   280,   281,   314,   260,   169,    46,    78,    48,   270,
-     236,   257,    78,   411,   264,   266,   286,   272,   401,    78,
-     170,   400,   230,   231,   333,   382,   194,   338,   339,   340,
-     304,   342,   122,   124,   309,   312,   155,   190,   313,   318,
-     306,   171,    78,   265,   380,   206,   172,   381,   174,   210,
-     211,   175,   259,   239,   212,   213,   176,   269,   177,   329,
-     332,   330,   178,    78,   285,   180,   181,   341,   182,   183,
-      78,   184,   343,   185,   316,   319,   320,   321,   322,   323,
-     324,   325,   192,   197,   198,   258,   194,   317,   199,   200,
-     268,   242,   243,   244,   245,   246,   247,   248,   249,   250,
-     251,   201,   202,   203,   415,   297,   155,   302,   204,   205,
-     336,   337,   243,   244,   245,   246,   247,   248,   249,   250,
-     251,   207,   355,   356,   357,   214,   217,   360,   361,   362,
-     363,   364,   218,   219,   220,    42,    43,   328,   221,   222,
-     331,   223,   334,   335,    42,    43,    42,    43,   224,   225,
-     282,   435,   226,   227,   228,   291,   359,   293,   295,   298,
-     300,   315,   348,    44,   349,   350,   252,   351,    45,   358,
-     365,   282,    44,    93,    44,   403,   404,   405,   406,   407,
-     408,   366,   326,   422,   327,    52,    53,   279,   280,   281,
-     367,   370,   368,    46,   425,    48,   369,    94,   432,    58,
-      42,    43,   371,    95,    96,   344,   315,    61,    58,   372,
-      58,   373,   402,    90,   394,    90,    61,   354,    61,   374,
-     375,   376,   377,    92,   416,   409,   410,   190,    44,   378,
-     379,   384,   383,   417,   385,   386,   429,   429,   397,   398,
-     387,   388,   389,   390,   448,   449,   391,   451,   452,   242,
-     243,   244,   245,   246,   247,   248,   249,   250,   251,   392,
-     393,   399,   418,   419,    58,   395,   160,   396,    51,    90,
-     421,    84,    61,   412,     2,     3,   413,   433,   434,   436,
-     426,   437,   447,   146,   439,   440,   450,     4,     5,     6,
-       7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
-      17,    18,   441,    19,    20,   442,    21,    22,    23,    24,
-     420,   424,   443,   446,   428,   431,   247,   248,   249,   250,
-     251,   346,   245,   246,   247,   248,   249,   250,   251,    25,
-      26,    27,    28,    29,    30,    31,    32,    33,     3,   444,
-      34,    35,   445,   430,    36,   345,    37,   423,   353,    38,
-       4,     5,     6,     7,     8,     9,    10,    11,    12,    13,
-      14,    15,    16,    17,    18,     0,    19,    20,     0,    21,
-      22,    23,    24,     0,    42,    43,     0,     0,    42,    43,
-     242,   243,   244,   245,   246,   247,   248,   249,   250,   251,
-       0,     0,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,     0,    44,    34,    35,     0,    44,    36,     0,    37,
-       0,    45,    38,    46,    47,    48,    49,    50,    51,    52,
-      53,    54,    55,     0,    56,    42,    43,   244,   245,   246,
-     247,   248,   249,   250,   251,     0,    42,    43,    58,     0,
-      57,     0,    58,    90,     0,     0,    61,    59,     0,    60,
-      61,     0,   347,    44,     0,    42,    43,     0,    45,     0,
-      46,     0,    48,    49,    44,     0,    52,    53,    54,    55,
-       0,    56,    47,     0,     0,    50,    42,    43,     0,     0,
-       0,     0,     0,    44,     0,     0,     0,    57,     0,    58,
-      46,     0,    48,     0,    59,     0,    84,    61,    57,     0,
-      58,    42,    43,     0,    44,    59,     0,   101,    61,     0,
-       0,    46,     0,    48,    42,    43,     0,    57,     0,    58,
-       0,     0,     0,     0,    59,     0,     0,    61,     0,    44,
-      42,   438,     0,     0,    42,    43,     0,     0,    57,     0,
-      58,    51,    44,    42,    43,    90,     0,     0,    61,     0,
-      47,     0,     0,    50,    42,    43,     0,     0,    44,     0,
-      42,    43,    44,    57,     0,    58,     0,     0,     0,     0,
-      59,    44,    84,    61,     0,     0,    57,     0,    58,     0,
-      42,    43,    44,    59,     0,     0,    61,     0,    44,     0,
-     196,   158,    57,     0,    58,   158,    57,     0,    58,    90,
-      42,    43,    61,    90,     0,    57,    61,    58,    44,     0,
-       0,     0,    90,     0,     0,    61,    94,     0,    58,     0,
-       0,     0,    94,   187,    58,     0,    61,     0,    44,   307,
-       0,     0,    61,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,    94,     0,    58,     0,     0,     0,     0,   310,
-       0,     0,    61,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,    94,     0,    58,     0,     0,     0,     0,   414,
+      79,    82,    83,    85,    87,    89,   120,   188,   301,   255,
+     186,   267,   195,   111,   115,   240,    46,    47,    48,    46,
+      50,    48,    47,   256,   131,    50,   133,   135,   137,   271,
+     140,   191,    46,    46,    48,    48,    76,    81,    45,    78,
+      78,   141,   142,    93,    99,   105,    92,   100,    78,   114,
+      41,    98,    84,   110,    46,    84,    48,   123,   123,    42,
+      43,   151,    60,   152,   153,   138,   110,    45,    78,    84,
+      47,   196,    93,    50,    42,    43,   128,   145,   146,    84,
+     102,   106,   107,   108,   109,   241,   116,    44,   129,    45,
+      80,    46,   129,    48,    93,   160,   161,   254,   104,    46,
+      47,    48,    44,    50,   306,   309,   249,   250,   251,   208,
+     277,   278,   279,   130,    51,   132,   134,   193,   194,   179,
+     158,    57,   303,    58,    86,    88,   143,   189,    90,   144,
+     190,    61,   152,   153,   112,   117,    57,   121,    58,   379,
+     194,   126,   127,    59,   162,    84,    61,   129,   136,    84,
+     139,   147,   350,   122,   124,   148,   149,   253,   261,   262,
+     263,   150,   163,   164,   273,   274,   275,   276,   165,   282,
+     285,   286,   287,   288,   166,   290,   292,   294,   297,   299,
+     167,   209,   232,   233,   234,   235,   168,   237,   238,   247,
+     248,   249,   250,   251,   260,   169,   170,    78,   407,   270,
+     173,   257,    78,   171,   264,   266,   284,   272,   398,    78,
+     397,   230,   231,   172,   331,   174,   175,   336,   337,   338,
+     302,   340,   176,   177,   307,   310,   178,   190,   311,   316,
+     118,   119,    78,   265,   155,   125,   277,   278,   279,   312,
+     377,   180,    46,   378,    48,   181,   182,   259,   183,   327,
+     330,   328,   269,    78,   184,   185,   192,   339,   197,   283,
+      78,   198,   341,   199,   314,   317,   318,   319,   320,   321,
+     322,   323,   200,   201,    45,    42,    43,   202,   258,    93,
+     203,   204,   315,   268,    54,    55,   205,    56,   277,   278,
+     279,   411,   207,   214,    46,   215,    48,   216,   295,   217,
+     300,   218,   219,    44,   155,   334,   335,   220,   221,   236,
+     222,   353,   354,   355,    42,    43,   358,   359,   360,   361,
+     362,   223,   206,   224,   225,   226,   210,   211,   227,   228,
+     326,   212,   213,   329,   239,   332,   333,    57,   194,    58,
+     304,   313,    44,   346,    90,   430,   347,    61,   280,    46,
+     348,    48,   349,   289,   356,   291,   293,   296,   298,   357,
+     363,   364,   399,   400,   401,   402,   403,   404,   365,   280,
+     418,   366,   367,   368,   369,   370,    57,   371,    58,   372,
+     324,   421,   325,    59,   373,   428,    61,   242,   243,   244,
+     245,   246,   247,   248,   249,   250,   251,   374,   375,    51,
+     396,   376,   380,   342,   381,   382,   383,   384,   385,   386,
+      92,   412,   405,   406,   190,   352,   387,   388,   389,   390,
+     413,   391,   431,   425,   425,   394,   395,    42,    43,   443,
+     444,   392,   446,   447,   242,   243,   244,   245,   246,   247,
+     248,   249,   250,   251,   393,   408,   409,   429,   417,   414,
+     415,   432,   160,   434,   435,    44,   436,   437,   438,   343,
+       2,     3,   252,   439,   440,   426,   419,   442,   146,     0,
+       0,   445,   422,     4,     5,     6,     7,     8,     9,    10,
+      11,    12,    13,    14,    15,    16,    17,    18,     0,    19,
+      20,    58,    21,    22,    23,    24,    90,   351,   441,    61,
+     416,   420,     0,     0,   424,   427,   344,   244,   245,   246,
+     247,   248,   249,   250,   251,    25,    26,    27,    28,    29,
+      30,    31,    32,    33,     3,     0,    34,    35,     0,     0,
+      36,     0,    37,     0,     0,    38,     4,     5,     6,     7,
+       8,     9,    10,    11,    12,    13,    14,    15,    16,    17,
+      18,     0,    19,    20,     0,    21,    22,    23,    24,     0,
+       0,     0,     0,     0,    42,    43,   242,   243,   244,   245,
+     246,   247,   248,   249,   250,   251,     0,     0,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,     0,     0,    34,
+      35,     0,    44,    36,     0,    37,     0,    45,    38,    46,
+      47,    48,    49,    50,    51,    52,    53,    54,    55,     0,
+      56,    42,    43,   243,   244,   245,   246,   247,   248,   249,
+     250,   251,     0,    42,    43,     0,    57,     0,    58,     0,
+       0,     0,     0,    59,     0,    60,    61,     0,   345,    44,
+      42,    43,     0,     0,    45,     0,    46,     0,    48,    49,
+       0,    44,    52,    53,    54,    55,    45,    56,    42,   433,
+       0,    93,    42,    43,     0,     0,     0,     0,    44,     0,
+       0,     0,     0,    57,     0,    58,    47,    42,    43,    50,
+      59,     0,    84,    61,     0,    94,    44,    58,     0,     0,
+      44,    95,    96,     0,     0,    61,     0,    46,     0,    48,
+      42,    43,    57,     0,    58,    44,     0,     0,     0,    59,
+       0,   101,    61,    47,    42,    43,    50,     0,   196,   158,
+      57,     0,    58,     0,    57,     0,    58,    90,    44,     0,
+      61,    90,    42,    43,    61,    46,     0,    48,     0,    57,
+       0,    58,    44,    42,    43,     0,    59,    42,    43,    61,
+       0,     0,     0,    42,    43,    52,    53,     0,     0,     0,
+      44,     0,     0,     0,    58,    42,    43,     0,     0,    90,
+       0,    44,    61,     0,     0,    44,     0,     0,    58,     0,
+       0,    44,     0,    90,     0,     0,    61,     0,     0,     0,
+      42,    43,     0,    44,    94,     0,    58,     0,     0,     0,
+       0,   187,     0,     0,    61,    94,     0,    58,     0,    94,
+       0,    58,   305,     0,     0,    61,   308,    58,    44,    61,
+       0,     0,    90,     0,    84,    61,     0,    94,     0,    58,
+       0,     0,     0,     0,   410,     0,     0,    61,   245,   246,
+     247,   248,   249,   250,   251,     0,     0,     0,     0,     0,
+     313,     0,     0,     0,    58,     0,     0,     0,     0,    90,
        0,     0,    61
 };
 
 static const yytype_int16 yycheck[] =
 {
-       5,     6,     7,     8,     9,    10,    21,    95,   162,   167,
-     185,    94,    75,    18,    19,     9,    43,     8,    45,    43,
-      43,    45,    45,    96,    29,   162,    31,    32,    33,    76,
-      35,   168,    75,    41,     8,     9,     4,     5,    46,     4,
-       5,    37,    38,    39,    12,    13,    11,    12,    13,    76,
-      79,    12,    79,    79,    77,    79,    44,    22,    23,    47,
-      77,    41,    36,    74,    44,    33,    46,    47,    33,    43,
-      43,    45,    45,    75,    68,    48,    77,    42,    43,    77,
-      13,    14,    15,    16,    17,     5,    19,    78,    77,   162,
-      43,    44,    45,    13,    47,    60,    61,     6,    72,     8,
-       9,    77,    41,    77,   192,   193,    80,    46,    28,   114,
-      30,    31,    51,    52,   187,    54,    43,    44,    45,    84,
-      47,     8,     9,    76,    73,    74,    79,    95,    76,    77,
-      95,    18,    19,    76,    21,    10,    11,    12,    25,    26,
-      43,    76,    45,    19,    20,    32,    77,    34,    24,    77,
-      41,    79,    43,   236,    45,    46,    77,   162,   163,   164,
-     165,    76,     8,     9,   169,   170,   171,   172,    76,   174,
+       5,     6,     7,     8,     9,    10,    21,    95,   185,   162,
+      94,   167,     9,    18,    19,     8,    43,    44,    45,    43,
+      47,    45,    44,   162,    29,    47,    31,    32,    33,   168,
+      35,    96,    43,    43,    45,    45,     4,     5,    41,     4,
+       5,    73,    74,    46,    12,    13,    11,    12,    13,    76,
+      75,    12,    79,    76,    43,    79,    45,    22,    23,     8,
+       9,     6,    79,     8,     9,    33,    76,    41,    33,    79,
+      44,    68,    46,    47,     8,     9,    75,    42,    43,    79,
+      13,    14,    15,    16,    17,    78,    19,    36,    77,    41,
+       5,    43,    77,    45,    46,    60,    61,   162,    13,    43,
+      44,    45,    36,    47,   192,   193,    10,    11,    12,   114,
+      37,    38,    39,    28,    48,    30,    31,    76,    77,    84,
+      69,    70,   187,    72,     8,     9,    74,    95,    77,    75,
+      95,    80,     8,     9,    18,    19,    70,    21,    72,    76,
+      77,    25,    26,    77,    76,    79,    80,    77,    32,    79,
+      34,    77,   236,    22,    23,    77,    77,   162,   163,   164,
+     165,    77,    76,    76,   169,   170,   171,   172,    76,   174,
      175,   176,   177,   178,    76,   180,   181,   182,   183,   184,
-      76,   114,   147,   148,   149,   150,    76,   152,   153,    11,
-      37,    38,    39,    40,   162,    76,    43,   162,    45,   167,
-       7,   162,   167,   378,   165,   166,   174,   168,   366,   174,
-      76,   365,   142,   143,   219,    76,    77,   222,   223,   224,
-     185,   226,    22,    23,   192,   193,    59,   192,   193,   197,
-      78,    76,   197,   166,   307,   111,    76,   310,    76,   115,
-     116,    76,   162,    77,   120,   121,    76,   167,    76,   214,
-     218,   216,    76,   218,   174,    76,    76,   225,    76,    76,
+      76,   114,   147,   148,   149,   150,    76,   152,   153,     8,
+       9,    10,    11,    12,   162,    76,    76,   162,   375,   167,
+      77,   162,   167,    76,   165,   166,   174,   168,   364,   174,
+     363,   142,   143,    76,   219,    76,    76,   222,   223,   224,
+     185,   226,    76,    76,   192,   193,    76,   192,   193,   197,
+      19,    20,   197,   166,    59,    24,    37,    38,    39,    40,
+     305,    76,    43,   308,    45,    76,    76,   162,    76,   214,
+     218,   216,   167,   218,    76,    76,    76,   225,    76,   174,
      225,    76,   227,    76,   197,   198,   199,   200,   201,   202,
-     203,   204,    76,    76,    76,   162,    77,   197,    76,    76,
-     167,     3,     4,     5,     6,     7,     8,     9,    10,    11,
-      12,    76,    76,    76,   382,   182,   129,   184,    76,    76,
-     220,   221,     4,     5,     6,     7,     8,     9,    10,    11,
-      12,    76,   242,   243,   244,    76,    76,   247,   248,   249,
-     250,   251,    76,    76,    76,     8,     9,   214,    76,    76,
-     217,    76,   219,   220,     8,     9,     8,     9,    76,    76,
-     173,   414,    76,    76,    76,   178,     7,   180,   181,   182,
-     183,    68,    78,    36,    78,    78,    78,    78,    41,     6,
-      76,   194,    36,    46,    36,   370,   371,   372,   373,   374,
-     375,    76,   205,   388,   207,    49,    50,    37,    38,    39,
-      77,    76,    78,    43,   389,    45,    78,    70,   393,    72,
-       8,     9,    76,    76,    77,   228,    68,    80,    72,    76,
-      72,    76,   367,    77,    77,    77,    80,   240,    80,    76,
-      76,    76,    76,   378,   382,   376,   377,   382,    36,    76,
-      78,    76,    78,   384,    76,    76,   391,   392,   358,   359,
-      76,    76,    76,    76,   439,   440,    76,   442,   443,     3,
-       4,     5,     6,     7,     8,     9,    10,    11,    12,    76,
-      76,    46,   385,   386,    72,    78,   421,    78,    48,    77,
-      79,    79,    80,    78,     0,     1,    78,    38,    78,    76,
-     390,     9,   437,   438,    76,    76,   441,    13,    14,    15,
-      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
-      26,    27,    76,    29,    30,    76,    32,    33,    34,    35,
-     387,   388,    76,   436,   391,   392,     8,     9,    10,    11,
-      12,    75,     6,     7,     8,     9,    10,    11,    12,    55,
-      56,    57,    58,    59,    60,    61,    62,    63,     1,    78,
-      66,    67,    78,   392,    70,   229,    72,   388,   239,    75,
-      13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
-      23,    24,    25,    26,    27,    -1,    29,    30,    -1,    32,
-      33,    34,    35,    -1,     8,     9,    -1,    -1,     8,     9,
-       3,     4,     5,     6,     7,     8,     9,    10,    11,    12,
-      -1,    -1,    55,    56,    57,    58,    59,    60,    61,    62,
-      63,    -1,    36,    66,    67,    -1,    36,    70,    -1,    72,
-      -1,    41,    75,    43,    44,    45,    46,    47,    48,    49,
-      50,    51,    52,    -1,    54,     8,     9,     5,     6,     7,
-       8,     9,    10,    11,    12,    -1,     8,     9,    72,    -1,
-      70,    -1,    72,    77,    -1,    -1,    80,    77,    -1,    79,
-      80,    -1,    75,    36,    -1,     8,     9,    -1,    41,    -1,
-      43,    -1,    45,    46,    36,    -1,    49,    50,    51,    52,
-      -1,    54,    44,    -1,    -1,    47,     8,     9,    -1,    -1,
-      -1,    -1,    -1,    36,    -1,    -1,    -1,    70,    -1,    72,
-      43,    -1,    45,    -1,    77,    -1,    79,    80,    70,    -1,
-      72,     8,     9,    -1,    36,    77,    -1,    79,    80,    -1,
-      -1,    43,    -1,    45,     8,     9,    -1,    70,    -1,    72,
-      -1,    -1,    -1,    -1,    77,    -1,    -1,    80,    -1,    36,
-       8,     9,    -1,    -1,     8,     9,    -1,    -1,    70,    -1,
-      72,    48,    36,     8,     9,    77,    -1,    -1,    80,    -1,
-      44,    -1,    -1,    47,     8,     9,    -1,    -1,    36,    -1,
-       8,     9,    36,    70,    -1,    72,    -1,    -1,    -1,    -1,
-      77,    36,    79,    80,    -1,    -1,    70,    -1,    72,    -1,
-       8,     9,    36,    77,    -1,    -1,    80,    -1,    36,    -1,
-      68,    69,    70,    -1,    72,    69,    70,    -1,    72,    77,
-       8,     9,    80,    77,    -1,    70,    80,    72,    36,    -1,
-      -1,    -1,    77,    -1,    -1,    80,    70,    -1,    72,    -1,
-      -1,    -1,    70,    77,    72,    -1,    80,    -1,    36,    77,
-      -1,    -1,    80,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    70,    -1,    72,    -1,    -1,    -1,    -1,    77,
-      -1,    -1,    80,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    70,    -1,    72,    -1,    -1,    -1,    -1,    77,
+     203,   204,    76,    76,    41,     8,     9,    76,   162,    46,
+      76,    76,   197,   167,    51,    52,    76,    54,    37,    38,
+      39,   379,    76,    76,    43,    77,    45,    11,   182,    76,
+     184,    76,    76,    36,   129,   220,   221,    76,    76,     7,
+      76,   242,   243,   244,     8,     9,   247,   248,   249,   250,
+     251,    76,   111,    76,    76,    76,   115,   116,    76,    76,
+     214,   120,   121,   217,    77,   219,   220,    70,    77,    72,
+      78,    68,    36,    78,    77,   410,    78,    80,   173,    43,
+      78,    45,    78,   178,     6,   180,   181,   182,   183,     7,
+      76,    76,   367,   368,   369,   370,   371,   372,    78,   194,
+     385,    78,    76,    76,    76,    76,    70,    76,    72,    76,
+     205,   386,   207,    77,    76,   390,    80,     3,     4,     5,
+       6,     7,     8,     9,    10,    11,    12,    76,    76,    48,
+      46,    78,    78,   228,    76,    76,    76,    76,    76,    76,
+     375,   379,   373,   374,   379,   240,    76,    76,    76,    76,
+     381,    77,    76,   388,   389,   356,   357,     8,     9,   434,
+     435,    78,   437,   438,     3,     4,     5,     6,     7,     8,
+       9,    10,    11,    12,    78,    78,    78,    38,    79,   382,
+     383,     9,   417,    76,    76,    36,    76,    76,    76,   229,
+       0,     1,    78,    78,    78,   389,   385,   432,   433,    -1,
+      -1,   436,   387,    13,    14,    15,    16,    17,    18,    19,
+      20,    21,    22,    23,    24,    25,    26,    27,    -1,    29,
+      30,    72,    32,    33,    34,    35,    77,   239,   431,    80,
+     384,   385,    -1,    -1,   388,   389,    75,     5,     6,     7,
+       8,     9,    10,    11,    12,    55,    56,    57,    58,    59,
+      60,    61,    62,    63,     1,    -1,    66,    67,    -1,    -1,
+      70,    -1,    72,    -1,    -1,    75,    13,    14,    15,    16,
+      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+      27,    -1,    29,    30,    -1,    32,    33,    34,    35,    -1,
+      -1,    -1,    -1,    -1,     8,     9,     3,     4,     5,     6,
+       7,     8,     9,    10,    11,    12,    -1,    -1,    55,    56,
+      57,    58,    59,    60,    61,    62,    63,    -1,    -1,    66,
+      67,    -1,    36,    70,    -1,    72,    -1,    41,    75,    43,
+      44,    45,    46,    47,    48,    49,    50,    51,    52,    -1,
+      54,     8,     9,     4,     5,     6,     7,     8,     9,    10,
+      11,    12,    -1,     8,     9,    -1,    70,    -1,    72,    -1,
+      -1,    -1,    -1,    77,    -1,    79,    80,    -1,    75,    36,
+       8,     9,    -1,    -1,    41,    -1,    43,    -1,    45,    46,
+      -1,    36,    49,    50,    51,    52,    41,    54,     8,     9,
+      -1,    46,     8,     9,    -1,    -1,    -1,    -1,    36,    -1,
+      -1,    -1,    -1,    70,    -1,    72,    44,     8,     9,    47,
+      77,    -1,    79,    80,    -1,    70,    36,    72,    -1,    -1,
+      36,    76,    77,    -1,    -1,    80,    -1,    43,    -1,    45,
+       8,     9,    70,    -1,    72,    36,    -1,    -1,    -1,    77,
+      -1,    79,    80,    44,     8,     9,    47,    -1,    68,    69,
+      70,    -1,    72,    -1,    70,    -1,    72,    77,    36,    -1,
+      80,    77,     8,     9,    80,    43,    -1,    45,    -1,    70,
+      -1,    72,    36,     8,     9,    -1,    77,     8,     9,    80,
+      -1,    -1,    -1,     8,     9,    49,    50,    -1,    -1,    -1,
+      36,    -1,    -1,    -1,    72,     8,     9,    -1,    -1,    77,
+      -1,    36,    80,    -1,    -1,    36,    -1,    -1,    72,    -1,
+      -1,    36,    -1,    77,    -1,    -1,    80,    -1,    -1,    -1,
+       8,     9,    -1,    36,    70,    -1,    72,    -1,    -1,    -1,
+      -1,    77,    -1,    -1,    80,    70,    -1,    72,    -1,    70,
+      -1,    72,    77,    -1,    -1,    80,    77,    72,    36,    80,
+      -1,    -1,    77,    -1,    79,    80,    -1,    70,    -1,    72,
+      -1,    -1,    -1,    -1,    77,    -1,    -1,    80,     6,     7,
+       8,     9,    10,    11,    12,    -1,    -1,    -1,    -1,    -1,
+      68,    -1,    -1,    -1,    72,    -1,    -1,    -1,    -1,    77,
       -1,    -1,    80
 };
 
@@ -1065,45 +1059,44 @@ static const yytype_uint8 yystos[] =
       85,    75,     8,     9,    36,    41,    43,    44,    45,    46,
       47,    48,    49,    50,    51,    52,    54,    70,    72,    77,
       79,    80,    87,    88,    89,    90,    91,    92,    93,    94,
-      96,    97,   100,   102,   103,   104,   105,   106,   110,    87,
-     104,   105,    87,    87,    79,    87,   102,    87,   102,    87,
-      77,    98,   110,    46,    70,    76,    77,    86,    97,   105,
-     110,    79,    96,   101,   104,   105,    96,    96,    96,    96,
-      76,    87,   102,   107,    76,    87,    96,   102,   107,   107,
-     100,   102,   106,   110,   106,   107,   102,   102,    75,    77,
-     104,    87,   104,    87,   104,    87,   102,    87,   105,   102,
-      87,    73,    74,    74,    75,   110,   110,    77,    77,    77,
-      77,     6,     8,     9,   108,   103,   110,   111,    69,   105,
-     110,   110,    76,    76,    76,    76,    76,    76,    76,    76,
-      76,    76,    76,    77,    76,    76,    76,    76,    76,   110,
-      76,    76,    76,    76,    76,    76,   108,    77,    86,   105,
-     110,    88,    76,    76,    77,     9,    68,    76,    76,    76,
-      76,    76,    76,    76,    76,    76,   107,    76,    87,    96,
-     107,   107,   107,   107,    76,    77,    11,    76,    76,    76,
+      95,    96,    99,   101,   102,   103,   104,   105,   109,    87,
+     103,   104,    87,    87,    79,    87,   101,    87,   101,    87,
+      77,    97,   109,    46,    70,    76,    77,    86,    96,   104,
+     109,    79,    95,   100,   103,   104,    95,    95,    95,    95,
+      76,    87,   101,   106,    76,    87,    95,   101,   106,   106,
+      99,   101,   105,   109,   105,   106,   101,   101,    75,    77,
+     103,    87,   103,    87,   103,    87,   101,    87,   104,   101,
+      87,    73,    74,    74,    75,   109,   109,    77,    77,    77,
+      77,     6,     8,     9,   107,   102,   109,   110,    69,   104,
+     109,   109,    76,    76,    76,    76,    76,    76,    76,    76,
+      76,    76,    76,    77,    76,    76,    76,    76,    76,   109,
+      76,    76,    76,    76,    76,    76,   107,    77,    86,   104,
+     109,    88,    76,    76,    77,     9,    68,    76,    76,    76,
+      76,    76,    76,    76,    76,    76,   106,    76,    87,    95,
+     106,   106,   106,   106,    76,    77,    11,    76,    76,    76,
       76,    76,    76,    76,    76,    76,    76,    76,    76,    84,
-     111,   111,   110,   110,   110,   110,     7,   110,   110,    77,
+     110,   110,   109,   109,   109,   109,     7,   109,   109,    77,
        8,    78,     3,     4,     5,     6,     7,     8,     9,    10,
-      11,    12,    78,    87,    88,    90,    93,    97,   102,   104,
-     105,    87,    87,    87,    97,    96,    97,    94,   102,   104,
-     105,    93,    97,    87,    48,    87,    95,    87,    87,    37,
-      38,    39,   103,   109,    87,   104,   105,    87,    87,    87,
-      87,   103,    87,   103,    87,   103,    87,   102,   103,    87,
-     103,    87,   102,    98,   110,    88,    78,    77,    86,   105,
-      77,    86,   105,   110,    40,    68,    96,   104,   105,    96,
-      96,    96,    96,    96,    96,    96,   103,   103,   102,   110,
-     110,   102,   105,    87,   102,   102,   104,   104,    87,    87,
-      87,   105,    87,   110,   103,    83,    75,    75,    78,    78,
-      78,    78,   108,   109,   103,   111,   111,   111,     6,     7,
-     111,   111,   111,   111,   111,    76,    76,    77,    78,    78,
-      76,    76,    76,    76,    76,    76,    76,    76,    76,    78,
-      88,    88,    76,    78,    76,    76,    76,    76,    76,    76,
-      76,    76,    76,    76,    77,    78,    78,   111,   111,    46,
-      90,    94,   110,    87,    87,    87,    87,    87,    87,    97,
-      97,    98,    78,    78,    77,    86,   105,    97,    96,    96,
-     102,    79,   100,   101,   102,    87,   104,    99,   102,   110,
-      99,   102,    87,    38,    78,    88,    76,     9,     9,    76,
-      76,    76,    76,    76,    78,    78,    96,   110,    87,    87,
-     110,    87,    87
+      11,    12,    78,    87,    88,    90,    93,    96,   101,   103,
+     104,    87,    87,    87,    96,    95,    96,    94,   101,   103,
+     104,    93,    96,    87,    87,    87,    87,    37,    38,    39,
+     102,   108,    87,   103,   104,    87,    87,    87,    87,   102,
+      87,   102,    87,   102,    87,   101,   102,    87,   102,    87,
+     101,    97,   109,    88,    78,    77,    86,   104,    77,    86,
+     104,   109,    40,    68,    95,   103,   104,    95,    95,    95,
+      95,    95,    95,    95,   102,   102,   101,   109,   109,   101,
+     104,    87,   101,   101,   103,   103,    87,    87,    87,   104,
+      87,   109,   102,    83,    75,    75,    78,    78,    78,    78,
+     107,   108,   102,   110,   110,   110,     6,     7,   110,   110,
+     110,   110,   110,    76,    76,    78,    78,    76,    76,    76,
+      76,    76,    76,    76,    76,    76,    78,    88,    88,    76,
+      78,    76,    76,    76,    76,    76,    76,    76,    76,    76,
+      76,    77,    78,    78,   110,   110,    46,    90,    94,    87,
+      87,    87,    87,    87,    87,    96,    96,    97,    78,    78,
+      77,    86,   104,    96,    95,    95,   101,    79,    99,   100,
+     101,    87,   103,    98,   101,   109,    98,   101,    87,    38,
+      88,    76,     9,     9,    76,    76,    76,    76,    76,    78,
+      78,    95,   109,    87,    87,   109,    87,    87
 };
 
 #define yyerrok		(yyerrstatus = 0)
@@ -1955,189 +1948,189 @@ yyreduce:
   case 12:
 #line 103 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 13:
 #line 107 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 14:
 #line 111 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 15:
 #line 115 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 16:
 #line 119 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 17:
 #line 123 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 18:
 #line 130 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 19:
 #line 134 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 20:
 #line 138 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 21:
 #line 142 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 22:
 #line 146 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 23:
 #line 150 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 24:
 #line 157 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 25:
 #line 161 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 26:
 #line 165 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 27:
 #line 169 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 28:
 #line 176 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 29:
 #line 180 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 30:
 #line 187 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 31:
 #line 191 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 32:
 #line 195 "a.y"
     {
-		outgcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), NREG, &(yyvsp[(4) - (6)].addr), &(yyvsp[(6) - (6)].addr));
+		outgcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), 0, &(yyvsp[(4) - (6)].addr), &(yyvsp[(6) - (6)].addr));
 	}
     break;
 
   case 33:
 #line 199 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 34:
 #line 203 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), (yyvsp[(4) - (4)].lval), &nullgen);
 	}
     break;
 
   case 35:
-#line 207 "a.y"
+#line 210 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), (yyvsp[(4) - (4)].lval), &nullgen);
+		outgcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), 0, &(yyvsp[(4) - (6)].addr), &(yyvsp[(6) - (6)].addr));
 	}
     break;
 
   case 36:
 #line 214 "a.y"
     {
-		outgcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), NREG, &(yyvsp[(4) - (6)].addr), &(yyvsp[(6) - (6)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 37:
 #line 218 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 38:
-#line 222 "a.y"
+#line 228 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
 	}
     break;
 
@@ -2151,238 +2144,238 @@ yyreduce:
   case 40:
 #line 236 "a.y"
     {
-		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
+		outgcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), 0, &(yyvsp[(4) - (6)].addr), &(yyvsp[(6) - (6)].addr));
 	}
     break;
 
   case 41:
 #line 240 "a.y"
     {
-		outgcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), NREG, &(yyvsp[(4) - (6)].addr), &(yyvsp[(6) - (6)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 42:
 #line 244 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 43:
 #line 248 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
 	}
     break;
 
   case 44:
 #line 252 "a.y"
     {
-		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 45:
 #line 256 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
 	}
     break;
 
   case 46:
 #line 260 "a.y"
     {
-		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 47:
 #line 264 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
 	}
     break;
 
   case 48:
 #line 268 "a.y"
     {
-		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 49:
 #line 272 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 50:
 #line 276 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr), 0, &(yyvsp[(2) - (2)].addr));
 	}
     break;
 
   case 51:
-#line 280 "a.y"
+#line 283 "a.y"
     {
-		outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr), NREG, &(yyvsp[(2) - (2)].addr));
+		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
 	}
     break;
 
   case 52:
-#line 287 "a.y"
+#line 290 "a.y"
     {
-		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 53:
 #line 294 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 54:
-#line 298 "a.y"
+#line 301 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), (yyvsp[(4) - (4)].addr).reg, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 55:
 #line 305 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), (yyvsp[(4) - (4)].addr).reg, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
 	}
     break;
 
   case 56:
-#line 309 "a.y"
+#line 313 "a.y"
     {
-		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 57:
 #line 317 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 58:
 #line 321 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 59:
 #line 325 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 60:
 #line 329 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 61:
 #line 333 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 62:
 #line 337 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 63:
 #line 341 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 64:
-#line 345 "a.y"
+#line 350 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (2)].lval), &nullgen, 0, &(yyvsp[(2) - (2)].addr));
 	}
     break;
 
   case 65:
 #line 354 "a.y"
     {
-		outcode((yyvsp[(1) - (2)].lval), &nullgen, NREG, &(yyvsp[(2) - (2)].addr));
+		outcode((yyvsp[(1) - (2)].lval), &nullgen, 0, &(yyvsp[(2) - (2)].addr));
 	}
     break;
 
   case 66:
 #line 358 "a.y"
     {
-		outcode((yyvsp[(1) - (2)].lval), &nullgen, NREG, &(yyvsp[(2) - (2)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &nullgen, 0, &(yyvsp[(3) - (4)].addr));
 	}
     break;
 
   case 67:
 #line 362 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &nullgen, NREG, &(yyvsp[(3) - (4)].addr));
+		outcode((yyvsp[(1) - (3)].lval), &nullgen, 0, &(yyvsp[(3) - (3)].addr));
 	}
     break;
 
   case 68:
 #line 366 "a.y"
     {
-		outcode((yyvsp[(1) - (3)].lval), &nullgen, NREG, &(yyvsp[(3) - (3)].addr));
+		outcode((yyvsp[(1) - (3)].lval), &nullgen, 0, &(yyvsp[(3) - (3)].addr));
 	}
     break;
 
   case 69:
 #line 370 "a.y"
     {
-		outcode((yyvsp[(1) - (3)].lval), &nullgen, NREG, &(yyvsp[(3) - (3)].addr));
+		outcode((yyvsp[(1) - (5)].lval), &nullgen, 0, &(yyvsp[(4) - (5)].addr));
 	}
     break;
 
   case 70:
 #line 374 "a.y"
     {
-		outcode((yyvsp[(1) - (5)].lval), &nullgen, NREG, &(yyvsp[(4) - (5)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 71:
 #line 378 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 72:
 #line 382 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), 0, &(yyvsp[(5) - (6)].addr));
 	}
     break;
 
   case 73:
 #line 386 "a.y"
     {
-		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), NREG, &(yyvsp[(5) - (6)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &nullgen, (yyvsp[(2) - (4)].lval), &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
@@ -2396,47 +2389,47 @@ yyreduce:
   case 75:
 #line 394 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &nullgen, (yyvsp[(2) - (4)].lval), &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (6)].lval), &nullgen, (yyvsp[(2) - (6)].lval), &(yyvsp[(5) - (6)].addr));
 	}
     break;
 
   case 76:
 #line 398 "a.y"
     {
-		outcode((yyvsp[(1) - (6)].lval), &nullgen, (yyvsp[(2) - (6)].lval), &(yyvsp[(5) - (6)].addr));
+		Addr g;
+		g = nullgen;
+		g.type = TYPE_CONST;
+		g.offset = (yyvsp[(2) - (6)].lval);
+		outcode((yyvsp[(1) - (6)].lval), &g, REG_R0+(yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
 	}
     break;
 
   case 77:
-#line 402 "a.y"
+#line 406 "a.y"
     {
 		Addr g;
 		g = nullgen;
-		g.type = D_CONST;
+		g.type = TYPE_CONST;
 		g.offset = (yyvsp[(2) - (6)].lval);
-		outcode((yyvsp[(1) - (6)].lval), &g, (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
+		outcode((yyvsp[(1) - (6)].lval), &g, REG_R0+(yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
 	}
     break;
 
   case 78:
-#line 410 "a.y"
+#line 414 "a.y"
     {
 		Addr g;
 		g = nullgen;
-		g.type = D_CONST;
-		g.offset = (yyvsp[(2) - (6)].lval);
-		outcode((yyvsp[(1) - (6)].lval), &g, (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
+		g.type = TYPE_CONST;
+		g.offset = (yyvsp[(2) - (8)].lval);
+		outcode((yyvsp[(1) - (8)].lval), &g, REG_R0+(yyvsp[(4) - (8)].lval), &(yyvsp[(7) - (8)].addr));
 	}
     break;
 
   case 79:
-#line 418 "a.y"
+#line 425 "a.y"
     {
-		Addr g;
-		g = nullgen;
-		g.type = D_CONST;
-		g.offset = (yyvsp[(2) - (8)].lval);
-		outcode((yyvsp[(1) - (8)].lval), &g, (yyvsp[(4) - (8)].lval), &(yyvsp[(7) - (8)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), (yyvsp[(4) - (4)].lval), &nullgen);
 	}
     break;
 
@@ -2450,77 +2443,77 @@ yyreduce:
   case 81:
 #line 433 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), (yyvsp[(4) - (4)].lval), &nullgen);
+		outcode((yyvsp[(1) - (3)].lval), &(yyvsp[(2) - (3)].addr), 0, &nullgen);
 	}
     break;
 
   case 82:
 #line 437 "a.y"
     {
-		outcode((yyvsp[(1) - (3)].lval), &(yyvsp[(2) - (3)].addr), NREG, &nullgen);
+		outcode((yyvsp[(1) - (2)].lval), &nullgen, 0, &nullgen);
 	}
     break;
 
   case 83:
-#line 441 "a.y"
+#line 444 "a.y"
     {
-		outcode((yyvsp[(1) - (2)].lval), &nullgen, NREG, &nullgen);
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 84:
 #line 448 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 85:
 #line 452 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(4) - (6)].addr).reg, &(yyvsp[(6) - (6)].addr));
 	}
     break;
 
   case 86:
 #line 456 "a.y"
     {
-		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(4) - (6)].addr).reg, &(yyvsp[(6) - (6)].addr));
+		outgcode((yyvsp[(1) - (8)].lval), &(yyvsp[(2) - (8)].addr), (yyvsp[(4) - (8)].addr).reg, &(yyvsp[(6) - (8)].addr), &(yyvsp[(8) - (8)].addr));
 	}
     break;
 
   case 87:
 #line 460 "a.y"
     {
-		outgcode((yyvsp[(1) - (8)].lval), &(yyvsp[(2) - (8)].addr), (yyvsp[(4) - (8)].addr).reg, &(yyvsp[(6) - (8)].addr), &(yyvsp[(8) - (8)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 88:
 #line 464 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(6) - (6)].addr).reg, &(yyvsp[(4) - (6)].addr));
 	}
     break;
 
   case 89:
-#line 468 "a.y"
+#line 471 "a.y"
     {
-		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(6) - (6)].addr).reg, &(yyvsp[(4) - (6)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 90:
 #line 475 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 91:
 #line 479 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(6) - (6)].addr).reg, &(yyvsp[(4) - (6)].addr));
 	}
     break;
 
@@ -2532,9 +2525,9 @@ yyreduce:
     break;
 
   case 93:
-#line 487 "a.y"
+#line 490 "a.y"
     {
-		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(6) - (6)].addr).reg, &(yyvsp[(4) - (6)].addr));
+		outgcode((yyvsp[(1) - (8)].lval), &(yyvsp[(2) - (8)].addr), (yyvsp[(4) - (8)].addr).reg, &(yyvsp[(6) - (8)].addr), &(yyvsp[(8) - (8)].addr));
 	}
     break;
 
@@ -2560,168 +2553,161 @@ yyreduce:
     break;
 
   case 97:
-#line 506 "a.y"
+#line 509 "a.y"
     {
-		outgcode((yyvsp[(1) - (8)].lval), &(yyvsp[(2) - (8)].addr), (yyvsp[(4) - (8)].addr).reg, &(yyvsp[(6) - (8)].addr), &(yyvsp[(8) - (8)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 98:
 #line 513 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 99:
-#line 517 "a.y"
+#line 521 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 100:
 #line 525 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outgcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), 0, &(yyvsp[(4) - (6)].addr), &(yyvsp[(6) - (6)].addr));
 	}
     break;
 
   case 101:
 #line 529 "a.y"
     {
-		outgcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), NREG, &(yyvsp[(4) - (6)].addr), &(yyvsp[(6) - (6)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 102:
 #line 533 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outgcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), 0, &(yyvsp[(4) - (6)].addr), &(yyvsp[(6) - (6)].addr));
 	}
     break;
 
   case 103:
 #line 537 "a.y"
     {
-		outgcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), NREG, &(yyvsp[(4) - (6)].addr), &(yyvsp[(6) - (6)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 104:
 #line 541 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
   case 105:
 #line 545 "a.y"
     {
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr), 0, &nullgen);
 	}
     break;
 
   case 106:
-#line 549 "a.y"
+#line 552 "a.y"
     {
-		outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr), NREG, &nullgen);
+		outcode((yyvsp[(1) - (2)].lval), &nullgen, 0, &nullgen);
 	}
     break;
 
   case 107:
 #line 556 "a.y"
     {
-		outcode((yyvsp[(1) - (2)].lval), &nullgen, NREG, &nullgen);
+		outcode((yyvsp[(1) - (3)].lval), &(yyvsp[(2) - (3)].addr), 0, &nullgen);
 	}
     break;
 
   case 108:
 #line 560 "a.y"
     {
-		outcode((yyvsp[(1) - (3)].lval), &(yyvsp[(2) - (3)].addr), NREG, &nullgen);
+		outcode((yyvsp[(1) - (3)].lval), &(yyvsp[(2) - (3)].addr), 0, &nullgen);
 	}
     break;
 
   case 109:
 #line 564 "a.y"
     {
-		outcode((yyvsp[(1) - (3)].lval), &(yyvsp[(2) - (3)].addr), NREG, &nullgen);
+		outcode((yyvsp[(1) - (3)].lval), &nullgen, 0, &(yyvsp[(3) - (3)].addr));
 	}
     break;
 
   case 110:
 #line 568 "a.y"
     {
-		outcode((yyvsp[(1) - (3)].lval), &nullgen, NREG, &(yyvsp[(3) - (3)].addr));
+		outcode((yyvsp[(1) - (3)].lval), &nullgen, 0, &(yyvsp[(3) - (3)].addr));
 	}
     break;
 
   case 111:
 #line 572 "a.y"
     {
-		outcode((yyvsp[(1) - (3)].lval), &nullgen, NREG, &(yyvsp[(3) - (3)].addr));
+		outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr), 0, &nullgen);
 	}
     break;
 
   case 112:
-#line 576 "a.y"
+#line 579 "a.y"
     {
-		outcode((yyvsp[(1) - (2)].lval), &(yyvsp[(2) - (2)].addr), NREG, &nullgen);
+		outcode((yyvsp[(1) - (3)].lval), &(yyvsp[(2) - (3)].addr), 0, &nullgen);
 	}
     break;
 
   case 113:
 #line 583 "a.y"
     {
-		outcode((yyvsp[(1) - (3)].lval), &(yyvsp[(2) - (3)].addr), NREG, &nullgen);
+		outcode((yyvsp[(1) - (3)].lval), &(yyvsp[(2) - (3)].addr), 0, &nullgen);
 	}
     break;
 
   case 114:
-#line 587 "a.y"
-    {
-		outcode((yyvsp[(1) - (3)].lval), &(yyvsp[(2) - (3)].addr), NREG, &nullgen);
-	}
-    break;
-
-  case 115:
-#line 594 "a.y"
+#line 590 "a.y"
     {
-		if((yyvsp[(2) - (4)].addr).type != D_CONST || (yyvsp[(4) - (4)].addr).type != D_CONST)
+		if((yyvsp[(2) - (4)].addr).type != TYPE_CONST || (yyvsp[(4) - (4)].addr).type != TYPE_CONST)
 			yyerror("arguments to PCDATA must be integer constants");
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
-  case 116:
-#line 603 "a.y"
+  case 115:
+#line 599 "a.y"
     {
-		if((yyvsp[(2) - (4)].addr).type != D_CONST)
+		if((yyvsp[(2) - (4)].addr).type != TYPE_CONST)
 			yyerror("index for FUNCDATA must be integer constant");
-		if((yyvsp[(4) - (4)].addr).type != D_EXTERN && (yyvsp[(4) - (4)].addr).type != D_STATIC && (yyvsp[(4) - (4)].addr).type != D_OREG)
+		if((yyvsp[(4) - (4)].addr).type != NAME_EXTERN && (yyvsp[(4) - (4)].addr).type != NAME_STATIC && (yyvsp[(4) - (4)].addr).type != TYPE_MEM)
 			yyerror("value for FUNCDATA must be symbol reference");
- 		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+ 		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
-  case 117:
-#line 614 "a.y"
+  case 116:
+#line 610 "a.y"
     {
-		outcode((yyvsp[(1) - (2)].lval), &nullgen, NREG, &nullgen);
+		outcode((yyvsp[(1) - (2)].lval), &nullgen, 0, &nullgen);
 	}
     break;
 
-  case 118:
-#line 621 "a.y"
+  case 117:
+#line 617 "a.y"
     {
 		settext((yyvsp[(2) - (4)].addr).sym);
-		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), NREG, &(yyvsp[(4) - (4)].addr));
+		outcode((yyvsp[(1) - (4)].lval), &(yyvsp[(2) - (4)].addr), 0, &(yyvsp[(4) - (4)].addr));
 	}
     break;
 
-  case 119:
-#line 626 "a.y"
+  case 118:
+#line 622 "a.y"
     {
 		settext((yyvsp[(2) - (6)].addr).sym);
 		(yyvsp[(6) - (6)].addr).offset &= 0xffffffffull;
@@ -2730,8 +2716,8 @@ yyreduce:
 	}
     break;
 
-  case 120:
-#line 633 "a.y"
+  case 119:
+#line 629 "a.y"
     {
 		settext((yyvsp[(2) - (8)].addr).sym);
 		(yyvsp[(6) - (8)].addr).offset &= 0xffffffffull;
@@ -2740,6 +2726,13 @@ yyreduce:
 	}
     break;
 
+  case 120:
+#line 639 "a.y"
+    {
+		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
+	}
+    break;
+
   case 121:
 #line 643 "a.y"
     {
@@ -2755,173 +2748,160 @@ yyreduce:
     break;
 
   case 123:
-#line 651 "a.y"
+#line 654 "a.y"
     {
-		outcode((yyvsp[(1) - (6)].lval), &(yyvsp[(2) - (6)].addr), (yyvsp[(4) - (6)].lval), &(yyvsp[(6) - (6)].addr));
+		outcode((yyvsp[(1) - (2)].lval), &nullgen, 0, &nullgen);
 	}
     break;
 
   case 124:
-#line 658 "a.y"
+#line 660 "a.y"
     {
-		outcode((yyvsp[(1) - (2)].lval), &nullgen, NREG, &nullgen);
+		(yyval.addr) = nullgen;
+		(yyval.addr).type = TYPE_BRANCH;
+		(yyval.addr).offset = (yyvsp[(1) - (4)].lval) + pc;
 	}
     break;
 
   case 125:
-#line 664 "a.y"
+#line 666 "a.y"
     {
+		(yyvsp[(1) - (2)].sym) = labellookup((yyvsp[(1) - (2)].sym));
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_BRANCH;
-		(yyval.addr).offset = (yyvsp[(1) - (4)].lval) + pc;
+		if(pass == 2 && (yyvsp[(1) - (2)].sym)->type != LLAB)
+			yyerror("undefined label: %s", (yyvsp[(1) - (2)].sym)->labelname);
+		(yyval.addr).type = TYPE_BRANCH;
+		(yyval.addr).offset = (yyvsp[(1) - (2)].sym)->value + (yyvsp[(2) - (2)].lval);
 	}
     break;
 
   case 126:
-#line 670 "a.y"
+#line 677 "a.y"
     {
-		(yyvsp[(1) - (2)].sym) = labellookup((yyvsp[(1) - (2)].sym));
 		(yyval.addr) = nullgen;
-		if(pass == 2 && (yyvsp[(1) - (2)].sym)->type != LLAB)
-			yyerror("undefined label: %s", (yyvsp[(1) - (2)].sym)->labelname);
-		(yyval.addr).type = D_BRANCH;
-		(yyval.addr).offset = (yyvsp[(1) - (2)].sym)->value + (yyvsp[(2) - (2)].lval);
+		(yyval.addr).type = TYPE_REG;
+		(yyval.addr).reg = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
-  case 127:
-#line 681 "a.y"
+  case 129:
+#line 689 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_REG;
+		(yyval.addr).type = TYPE_REG;
 		(yyval.addr).reg = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 130:
-#line 693 "a.y"
+#line 697 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_SPR;
-		(yyval.addr).offset = (yyvsp[(1) - (1)].lval);
+		(yyval.addr).type = TYPE_REG;
+		(yyval.addr).reg = (yyvsp[(1) - (1)].lval);	/* whole register */
 	}
     break;
 
   case 131:
-#line 701 "a.y"
+#line 705 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_CREG;
-		(yyval.addr).reg = NREG;	/* whole register */
+		(yyval.addr).type = TYPE_REG;
+		(yyval.addr).reg = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 132:
-#line 709 "a.y"
+#line 713 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_SPR;
-		(yyval.addr).offset = (yyvsp[(1) - (1)].lval);
+		(yyval.addr).type = TYPE_REG;
+		(yyval.addr).reg = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 133:
-#line 717 "a.y"
+#line 721 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_MSR;
+		(yyval.addr).type = TYPE_REG;
+		(yyval.addr).reg = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 134:
-#line 724 "a.y"
+#line 727 "a.y"
     {
+		if((yyvsp[(3) - (4)].lval) < 0 || (yyvsp[(3) - (4)].lval) >= 1024)
+			yyerror("SPR/DCR out of range");
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_SPR;
-		(yyval.addr).offset = (yyvsp[(1) - (1)].lval);
+		(yyval.addr).type = TYPE_REG;
+		(yyval.addr).reg = (yyvsp[(1) - (4)].lval) + (yyvsp[(3) - (4)].lval);
 	}
     break;
 
-  case 135:
-#line 730 "a.y"
+  case 136:
+#line 738 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = (yyvsp[(1) - (4)].lval);
-		(yyval.addr).offset = (yyvsp[(3) - (4)].lval);
+		(yyval.addr).type = TYPE_REG;
+		(yyval.addr).reg = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 137:
-#line 739 "a.y"
+#line 746 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_FPSCR;
-		(yyval.addr).reg = NREG;
+		(yyval.addr).type = TYPE_REG;
+		(yyval.addr).reg = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 138:
-#line 747 "a.y"
+#line 752 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_FPSCR;
-		(yyval.addr).reg = (yyvsp[(3) - (4)].lval);
+		(yyval.addr).type = TYPE_REG;
+		(yyval.addr).reg = REG_F0 + (yyvsp[(3) - (4)].lval);
 	}
     break;
 
   case 139:
-#line 755 "a.y"
+#line 760 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_FREG;
+		(yyval.addr).type = TYPE_REG;
 		(yyval.addr).reg = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 140:
-#line 761 "a.y"
+#line 766 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_FREG;
-		(yyval.addr).reg = (yyvsp[(3) - (4)].lval);
+		(yyval.addr).type = TYPE_REG;
+		(yyval.addr).reg = REG_C0 + (yyvsp[(3) - (4)].lval);
 	}
     break;
 
   case 141:
-#line 769 "a.y"
+#line 774 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_CREG;
+		(yyval.addr).type = TYPE_REG;
 		(yyval.addr).reg = (yyvsp[(1) - (1)].lval);
 	}
     break;
 
   case 142:
-#line 775 "a.y"
-    {
-		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_CREG;
-		(yyval.addr).reg = (yyvsp[(3) - (4)].lval);
-	}
-    break;
-
-  case 143:
-#line 783 "a.y"
-    {
-		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_REG;
-		(yyval.addr).reg = (yyvsp[(1) - (1)].lval);
-	}
-    break;
-
-  case 144:
-#line 791 "a.y"
+#line 782 "a.y"
     {
 		int mb, me;
 		uint32 v;
 
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_CONST;
+		(yyval.addr).type = TYPE_CONST;
 		mb = (yyvsp[(1) - (3)].lval);
 		me = (yyvsp[(3) - (3)].lval);
 		if(mb < 0 || mb > 31 || me < 0 || me > 31){
@@ -2936,244 +2916,244 @@ yyreduce:
 	}
     break;
 
-  case 145:
-#line 812 "a.y"
+  case 143:
+#line 803 "a.y"
     {
 		(yyval.addr) = (yyvsp[(2) - (2)].addr);
-		(yyval.addr).type = D_CONST;
+		(yyval.addr).type = TYPE_CONST;
 	}
     break;
 
-  case 146:
-#line 817 "a.y"
+  case 144:
+#line 808 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_SCONST;
+		(yyval.addr).type = TYPE_SCONST;
 		memcpy((yyval.addr).u.sval, (yyvsp[(2) - (2)].sval), sizeof((yyval.addr).u.sval));
 	}
     break;
 
-  case 147:
-#line 825 "a.y"
+  case 145:
+#line 816 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_FCONST;
+		(yyval.addr).type = TYPE_FCONST;
 		(yyval.addr).u.dval = (yyvsp[(2) - (2)].dval);
 	}
     break;
 
-  case 148:
-#line 831 "a.y"
+  case 146:
+#line 822 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_FCONST;
+		(yyval.addr).type = TYPE_FCONST;
 		(yyval.addr).u.dval = -(yyvsp[(3) - (3)].dval);
 	}
     break;
 
-  case 149:
-#line 838 "a.y"
+  case 147:
+#line 829 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_CONST;
+		(yyval.addr).type = TYPE_CONST;
 		(yyval.addr).offset = (yyvsp[(2) - (2)].lval);
 	}
     break;
 
-  case 151:
-#line 847 "a.y"
+  case 149:
+#line 838 "a.y"
     {
 		if((yyval.lval) < 0 || (yyval.lval) >= NREG)
 			print("register value out of range\n");
-		(yyval.lval) = (yyvsp[(3) - (4)].lval);
+		(yyval.lval) = REG_R0 + (yyvsp[(3) - (4)].lval);
 	}
     break;
 
-  case 152:
-#line 855 "a.y"
+  case 150:
+#line 846 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_OREG;
+		(yyval.addr).type = TYPE_MEM;
 		(yyval.addr).reg = (yyvsp[(2) - (3)].lval);
 		(yyval.addr).offset = 0;
 	}
     break;
 
-  case 153:
-#line 862 "a.y"
+  case 151:
+#line 853 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_OREG;
+		(yyval.addr).type = TYPE_MEM;
 		(yyval.addr).reg = (yyvsp[(2) - (5)].lval);
 		(yyval.addr).scale = (yyvsp[(4) - (5)].lval);
 		(yyval.addr).offset = 0;
 	}
     break;
 
-  case 155:
-#line 873 "a.y"
+  case 153:
+#line 864 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_OREG;
+		(yyval.addr).type = TYPE_MEM;
 		(yyval.addr).reg = (yyvsp[(3) - (4)].lval);
 		(yyval.addr).offset = (yyvsp[(1) - (4)].lval);
 	}
     break;
 
-  case 156:
-#line 882 "a.y"
+  case 154:
+#line 873 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_OREG;
+		(yyval.addr).type = TYPE_MEM;
 		(yyval.addr).name = (yyvsp[(3) - (4)].lval);
 		(yyval.addr).sym = nil;
 		(yyval.addr).offset = (yyvsp[(1) - (4)].lval);
 	}
     break;
 
-  case 157:
-#line 890 "a.y"
+  case 155:
+#line 881 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_OREG;
+		(yyval.addr).type = TYPE_MEM;
 		(yyval.addr).name = (yyvsp[(4) - (5)].lval);
 		(yyval.addr).sym = linklookup(ctxt, (yyvsp[(1) - (5)].sym)->name, 0);
 		(yyval.addr).offset = (yyvsp[(2) - (5)].lval);
 	}
     break;
 
-  case 158:
-#line 898 "a.y"
+  case 156:
+#line 889 "a.y"
     {
 		(yyval.addr) = nullgen;
-		(yyval.addr).type = D_OREG;
-		(yyval.addr).name = D_STATIC;
+		(yyval.addr).type = TYPE_MEM;
+		(yyval.addr).name = NAME_STATIC;
 		(yyval.addr).sym = linklookup(ctxt, (yyvsp[(1) - (7)].sym)->name, 0);
 		(yyval.addr).offset = (yyvsp[(4) - (7)].lval);
 	}
     break;
 
-  case 161:
-#line 910 "a.y"
+  case 159:
+#line 901 "a.y"
     {
 		(yyval.lval) = 0;
 	}
     break;
 
-  case 162:
-#line 914 "a.y"
+  case 160:
+#line 905 "a.y"
     {
 		(yyval.lval) = (yyvsp[(2) - (2)].lval);
 	}
     break;
 
-  case 163:
-#line 918 "a.y"
+  case 161:
+#line 909 "a.y"
     {
 		(yyval.lval) = -(yyvsp[(2) - (2)].lval);
 	}
     break;
 
-  case 168:
-#line 930 "a.y"
+  case 166:
+#line 921 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (1)].sym)->value;
 	}
     break;
 
-  case 169:
-#line 934 "a.y"
+  case 167:
+#line 925 "a.y"
     {
 		(yyval.lval) = -(yyvsp[(2) - (2)].lval);
 	}
     break;
 
-  case 170:
-#line 938 "a.y"
+  case 168:
+#line 929 "a.y"
     {
 		(yyval.lval) = (yyvsp[(2) - (2)].lval);
 	}
     break;
 
-  case 171:
-#line 942 "a.y"
+  case 169:
+#line 933 "a.y"
     {
 		(yyval.lval) = ~(yyvsp[(2) - (2)].lval);
 	}
     break;
 
-  case 172:
-#line 946 "a.y"
+  case 170:
+#line 937 "a.y"
     {
 		(yyval.lval) = (yyvsp[(2) - (3)].lval);
 	}
     break;
 
-  case 174:
-#line 953 "a.y"
+  case 172:
+#line 944 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) + (yyvsp[(3) - (3)].lval);
 	}
     break;
 
-  case 175:
-#line 957 "a.y"
+  case 173:
+#line 948 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) - (yyvsp[(3) - (3)].lval);
 	}
     break;
 
-  case 176:
-#line 961 "a.y"
+  case 174:
+#line 952 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) * (yyvsp[(3) - (3)].lval);
 	}
     break;
 
-  case 177:
-#line 965 "a.y"
+  case 175:
+#line 956 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) / (yyvsp[(3) - (3)].lval);
 	}
     break;
 
-  case 178:
-#line 969 "a.y"
+  case 176:
+#line 960 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) % (yyvsp[(3) - (3)].lval);
 	}
     break;
 
-  case 179:
-#line 973 "a.y"
+  case 177:
+#line 964 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (4)].lval) << (yyvsp[(4) - (4)].lval);
 	}
     break;
 
-  case 180:
-#line 977 "a.y"
+  case 178:
+#line 968 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (4)].lval) >> (yyvsp[(4) - (4)].lval);
 	}
     break;
 
-  case 181:
-#line 981 "a.y"
+  case 179:
+#line 972 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) & (yyvsp[(3) - (3)].lval);
 	}
     break;
 
-  case 182:
-#line 985 "a.y"
+  case 180:
+#line 976 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) ^ (yyvsp[(3) - (3)].lval);
 	}
     break;
 
-  case 183:
-#line 989 "a.y"
+  case 181:
+#line 980 "a.y"
     {
 		(yyval.lval) = (yyvsp[(1) - (3)].lval) | (yyvsp[(3) - (3)].lval);
 	}
@@ -3181,7 +3161,7 @@ yyreduce:
 
 
 /* Line 1267 of yacc.c.  */
-#line 3185 "y.tab.c"
+#line 3165 "y.tab.c"
       default: break;
     }
   YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
diff --git a/src/cmd/9g/cgen.c b/src/cmd/9g/cgen.c
index e389360016..d1f1976ce8 100644
--- a/src/cmd/9g/cgen.c
+++ b/src/cmd/9g/cgen.c
@@ -731,7 +731,7 @@ agenr(Node *n, Node *a, Node *res)
 				else {
 					regalloc(&n4, types[TUINT64], N);
 					p1 = gins(AMOVD, N, &n4);
-					p1->from.type = D_CONST;
+					p1->from.type = TYPE_CONST;
 					p1->from.offset = nl->type->bound;
 				}
 			}
@@ -749,7 +749,7 @@ agenr(Node *n, Node *a, Node *res)
 			regalloc(&n3, types[tptr], res);
 			p1 = gins(AMOVD, N, &n3);
 			datastring(nl->val.u.sval->s, nl->val.u.sval->len, &p1->from);
-			p1->from.type = D_CONST;
+			p1->from.type = TYPE_CONST;
 		} else if(isslice(nl->type) || nl->type->etype == TSTRING) {
 			n1 = n3;
 			n1.op = OINDREG;
@@ -968,7 +968,7 @@ igen(Node *n, Node *a, Node *res)
 	case OINDREG:
 		// Increase the refcount of the register so that igen's caller
 		// has to call regfree.
-		if(n->val.u.reg != D_R0+REGSP)
+		if(n->val.u.reg != REGSP)
 			reg[n->val.u.reg]++;
 		*a = *n;
 		return;
@@ -1006,7 +1006,7 @@ igen(Node *n, Node *a, Node *res)
 		fp = structfirst(&flist, getoutarg(n->left->type));
 		memset(a, 0, sizeof *a);
 		a->op = OINDREG;
-		a->val.u.reg = D_R0+REGSP;
+		a->val.u.reg = REGSP;
 		a->addable = 1;
 		a->xoffset = fp->width + widthptr; // +widthptr: saved lr at 0(SP)
 		a->type = n->type;
@@ -1465,25 +1465,25 @@ sgen(Node *n, Node *ns, int64 w)
 		}
 
 		p = gins(AADD, N, &src);
-		p->from.type = D_CONST;
+		p->from.type = TYPE_CONST;
 		p->from.offset = w;
 
 		p = gins(AADD, N, &dst);
-		p->from.type = D_CONST;
+		p->from.type = TYPE_CONST;
 		p->from.offset = w;
 	} else {
 		p = gins(AADD, N, &src);
-		p->from.type = D_CONST;
+		p->from.type = TYPE_CONST;
 		p->from.offset = -dir;
 
 		p = gins(AADD, N, &dst);
-		p->from.type = D_CONST;
+		p->from.type = TYPE_CONST;
 		p->from.offset = -dir;
 
 		if(c >= 4) {
 			regalloc(&nend, types[tptr], N);
 			p = gins(AMOVD, &src, &nend);
-			p->from.type = D_CONST;
+			p->from.type = TYPE_CONST;
 			p->from.offset = w;
 		}
 	}
@@ -1493,12 +1493,12 @@ sgen(Node *n, Node *ns, int64 w)
 	// TODO: enable duffcopy for larger copies.
 	if(c >= 4) {
 		p = gins(op, &src, &tmp);
-		p->from.type = D_OREG;
+		p->from.type = TYPE_MEM;
 		p->from.offset = dir;
 		ploop = p;
 
 		p = gins(op, &tmp, &dst);
-		p->to.type = D_OREG;
+		p->to.type = TYPE_MEM;
 		p->to.offset = dir;
 
 		p = gins(ACMP, &src, &nend);
@@ -1508,11 +1508,11 @@ sgen(Node *n, Node *ns, int64 w)
 	} else {
 		while(c-- > 0) {
 			p = gins(op, &src, &tmp);
-			p->from.type = D_OREG;
+			p->from.type = TYPE_MEM;
 			p->from.offset = dir;
 	
 			p = gins(op, &tmp, &dst);
-			p->to.type = D_OREG;
+			p->to.type = TYPE_MEM;
 			p->to.offset = dir;
 		}
 	}
diff --git a/src/cmd/9g/galign.c b/src/cmd/9g/galign.c
index a4aa332282..5559e03a53 100644
--- a/src/cmd/9g/galign.c
+++ b/src/cmd/9g/galign.c
@@ -43,14 +43,7 @@ betypeinit(void)
 	widthint = 8;
 	widthreg = 8;
 
-	zprog.link = P;
 	zprog.as = AGOK;
-	zprog.reg = NREG;
-	zprog.from.name = D_NONE;
-	zprog.from.type = D_NONE;
-	zprog.from.reg = NREG;
-	zprog.to = zprog.from;
-	zprog.from3 = zprog.from;
 	arch.zprog = zprog;
 
 	listinit9();
@@ -80,10 +73,6 @@ main(int argc, char **argv)
 	arch.AUNDEF = AUNDEF;
 	arch.AVARDEF = AVARDEF;
 	arch.AVARKILL = AVARKILL;
-	arch.D_AUTO = D_AUTO;
-	arch.D_BRANCH = D_BRANCH;
-	arch.D_NONE = D_NONE;
-	arch.D_PARAM = D_PARAM;
 	arch.MAXWIDTH = MAXWIDTH;
 	arch.afunclit = afunclit;
 	arch.anyregalloc = anyregalloc;
diff --git a/src/cmd/9g/ggen.c b/src/cmd/9g/ggen.c
index 3e72adf6b0..2ee4541fa6 100644
--- a/src/cmd/9g/ggen.c
+++ b/src/cmd/9g/ggen.c
@@ -72,25 +72,25 @@ zerorange(Prog *p, vlong frame, vlong lo, vlong hi)
 		return p;
 	if(cnt < 4*widthptr) {
 		for(i = 0; i < cnt; i += widthptr)
-			p = appendpp(p, AMOVD, D_REG, REGZERO, 0, D_OREG, REGSP, 8+frame+lo+i);
+			p = appendpp(p, AMOVD, TYPE_REG, REGZERO, 0, TYPE_MEM, REGSP, 8+frame+lo+i);
 	} else if(cnt <= 128*widthptr) {
-		p = appendpp(p, AADD, D_CONST, NREG, 8+frame+lo-8, D_REG, REGRT1, 0);
+		p = appendpp(p, AADD, TYPE_CONST, 0, 8+frame+lo-8, TYPE_REG, REGRT1, 0);
 		p->reg = REGSP;
-		p = appendpp(p, ADUFFZERO, D_NONE, NREG, 0, D_OREG, NREG, 0);
+		p = appendpp(p, ADUFFZERO, TYPE_NONE, 0, 0, TYPE_MEM, 0, 0);
 		f = sysfunc("duffzero");
 		naddr(f, &p->to, 1);
 		afunclit(&p->to, f);
 		p->to.offset = 4*(128-cnt/widthptr);
 	} else {
-		p = appendpp(p, AMOVD, D_CONST, NREG, 8+frame+lo-8, D_REG, REGTMP, 0);
-		p = appendpp(p, AADD, D_REG, REGTMP, 0, D_REG, REGRT1, 0);
+		p = appendpp(p, AMOVD, TYPE_CONST, 0, 8+frame+lo-8, TYPE_REG, REGTMP, 0);
+		p = appendpp(p, AADD, TYPE_REG, REGTMP, 0, TYPE_REG, REGRT1, 0);
 		p->reg = REGSP;
-		p = appendpp(p, AMOVD, D_CONST, NREG, cnt, D_REG, REGTMP, 0);
-		p = appendpp(p, AADD, D_REG, REGTMP, 0, D_REG, REGRT2, 0);
+		p = appendpp(p, AMOVD, TYPE_CONST, 0, cnt, TYPE_REG, REGTMP, 0);
+		p = appendpp(p, AADD, TYPE_REG, REGTMP, 0, TYPE_REG, REGRT2, 0);
 		p->reg = REGRT1;
-		p1 = p = appendpp(p, AMOVDU, D_REG, REGZERO, 0, D_OREG, REGRT1, widthptr);
-		p = appendpp(p, ACMP, D_REG, REGRT1, 0, D_REG, REGRT2, 0);
-		p = appendpp(p, ABNE, D_NONE, NREG, 0, D_BRANCH, NREG, 0);
+		p1 = p = appendpp(p, AMOVDU, TYPE_REG, REGZERO, 0, TYPE_MEM, REGRT1, widthptr);
+		p = appendpp(p, ACMP, TYPE_REG, REGRT1, 0, TYPE_REG, REGRT2, 0);
+		p = appendpp(p, ABNE, TYPE_NONE, 0, 0, TYPE_BRANCH, 0, 0);
 		patch(p, p1);
 	}
 	return p;
@@ -138,7 +138,7 @@ fixautoused(Prog *p)
 	Prog **lp;
 
 	for (lp=&p; (p=*lp) != P; ) {
-		if (p->as == ATYPE && p->from.node && p->from.name == D_AUTO && !((Node*)(p->from.node))->used) {
+		if (p->as == ATYPE && p->from.node && p->from.name == NAME_AUTO && !((Node*)(p->from.node))->used) {
 			*lp = p->link;
 			continue;
 		}
@@ -147,15 +147,13 @@ fixautoused(Prog *p)
 			// VARDEFs are interspersed with other code, and a jump might be using the
 			// VARDEF as a target. Replace with a no-op instead. A later pass will remove
 			// the no-ops.
-			p->to.type = D_NONE;
-			p->to.node = N;
-			p->as = ANOP;
+			nopout(p);
 			continue;
 		}
-		if (p->from.name == D_AUTO && p->from.node)
+		if (p->from.name == NAME_AUTO && p->from.node)
 			p->from.offset += ((Node*)(p->from.node))->stkdelta;
 
-		if (p->to.name == D_AUTO && p->to.node)
+		if (p->to.name == NAME_AUTO && p->to.node)
 			p->to.offset += ((Node*)(p->to.node))->stkdelta;
 
 		lp = &p->link;
@@ -172,11 +170,11 @@ ginsBL(Node *reg, Node *f)
 {
 	Prog *p;
 	p = gins(AMOVD, f, N);
-	p->to.type = D_SPR;
-	p->to.offset = D_CTR;
+	p->to.type = TYPE_REG;
+	p->to.reg = REG_CTR;
 	p = gins(ABL, reg, N);
-	p->to.type = D_SPR;
-	p->to.offset = D_CTR;
+	p->to.type = TYPE_REG;
+	p->to.reg = REG_CTR;
 }
 
 /*
@@ -221,7 +219,7 @@ ginscall(Node *f, int proc)
 				// The ppc64 NOP is really or r0, r0, r0; use that description
 				// because the NOP pseudo-instruction would be removed by
 				// the linker.
-				nodreg(&reg, types[TINT], D_R0);
+				nodreg(&reg, types[TINT], REG_R0);
 				gins(AOR, &reg, &reg);
 			}
 			p = gins(ABL, N, f);
@@ -230,8 +228,8 @@ ginscall(Node *f, int proc)
 				gins(AUNDEF, N, N);
 			break;
 		}
-		nodreg(&reg, types[tptr], D_R0+REGENV);
-		nodreg(&r1, types[tptr], D_R0+3);
+		nodreg(&reg, types[tptr], REGENV);
+		nodreg(&r1, types[tptr], REG_R3);
 		gmove(f, &reg);
 		reg.op = OINDREG;
 		gmove(&reg, &r1);
@@ -246,18 +244,18 @@ ginscall(Node *f, int proc)
 	case 1:	// call in new proc (go)
 	case 2:	// deferred call (defer)
 		nodconst(&con, types[TINT64], argsize(f->type));
-		nodreg(&reg, types[TINT64], D_R0+3);
-		nodreg(&reg2, types[TINT64], D_R0+4);
+		nodreg(&reg, types[TINT64], REG_R3);
+		nodreg(&reg2, types[TINT64], REG_R4);
 		gmove(f, &reg);
 
 		gmove(&con, &reg2);
 		p = gins(AMOVW, &reg2, N);
-		p->to.type = D_OREG;
+		p->to.type = TYPE_MEM;
 		p->to.reg = REGSP;
 		p->to.offset = 8;
 
 		p = gins(AMOVD, &reg, N);
-		p->to.type = D_OREG;
+		p->to.type = TYPE_MEM;
 		p->to.reg = REGSP;
 		p->to.offset = 16;
 
@@ -270,10 +268,10 @@ ginscall(Node *f, int proc)
 		}
 
 		if(proc == 2) {
-			nodreg(&reg, types[TINT64], D_R0+3);
+			nodreg(&reg, types[TINT64], REG_R3);
 			p = gins(ACMP, &reg, N);
-			p->to.type = D_REG;
-			p->to.reg = D_R0;
+			p->to.type = TYPE_REG;
+			p->to.reg = REG_R0;
 			p = gbranch(ABEQ, T, +1);
 			cgen_ret(N);
 			patch(p, pc);
@@ -315,7 +313,7 @@ cgen_callinter(Node *n, Node *res, int proc)
 	// register to hold its address.
 	igen(i, &nodi, res);		// REG = &inter
 
-	nodindreg(&nodsp, types[tptr], D_R0+REGSP);
+	nodindreg(&nodsp, types[tptr], REGSP);
 	nodsp.xoffset = widthptr;
 	if(proc != 0)
 		nodsp.xoffset += 2 * widthptr; // leave room for size & fn
@@ -342,7 +340,7 @@ cgen_callinter(Node *n, Node *res, int proc)
 	} else {
 		// go/defer. generate go func value.
 		p = gins(AMOVD, &nodo, &nodr);	// REG = &(32+offset(REG)) -- i.tab->fun[f]
-		p->from.type = D_CONST;
+		p->from.type = TYPE_CONST;
 	}
 
 	nodr.type = n->left->type;
@@ -424,7 +422,7 @@ cgen_callret(Node *n, Node *res)
 
 	memset(&nod, 0, sizeof(nod));
 	nod.op = OINDREG;
-	nod.val.u.reg = D_R0+REGSP;
+	nod.val.u.reg = REGSP;
 	nod.addable = 1;
 
 	nod.xoffset = fp->width + widthptr; // +widthptr: saved LR at 0(R1)
@@ -454,7 +452,7 @@ cgen_aret(Node *n, Node *res)
 
 	memset(&nod1, 0, sizeof(nod1));
 	nod1.op = OINDREG;
-	nod1.val.u.reg = D_R0 + REGSP;
+	nod1.val.u.reg = REGSP;
 	nod1.addable = 1;
 
 	nod1.xoffset = fp->width + widthptr; // +widthptr: saved lr at 0(SP)
@@ -485,8 +483,8 @@ cgen_ret(Node *n)
 	genlist(curfn->exit);
 	p = gins(ARET, N, N);
 	if(n != N && n->op == ORETJMP) {
-		p->to.name = D_EXTERN;
-		p->to.type = D_CONST;
+		p->to.name = NAME_EXTERN;
+		p->to.type = TYPE_CONST;
 		p->to.sym = linksym(n->left->sym);
 	}
 }
@@ -575,7 +573,7 @@ dodiv(int op, Node *nl, Node *nr, Node *res)
 
 	// Handle divide-by-zero panic.
 	p1 = gins(optoas(OCMP, t), &tr, N);
-	p1->to.type = D_REG;
+	p1->to.type = TYPE_REG;
 	p1->to.reg = REGZERO;
 	p1 = gbranch(optoas(ONE, t), T, +1);
 	if(panicdiv == N)
@@ -774,7 +772,7 @@ cgen_hmul(Node *nl, Node *nr, Node *res)
 	case TINT32:
 		gins(optoas(OMUL, t), &n2, &n1);
 		p = gins(ASRAD, N, &n1);
-		p->from.type = D_CONST;
+		p->from.type = TYPE_CONST;
 		p->from.offset = w;
 		break;
 	case TUINT8:
@@ -782,7 +780,7 @@ cgen_hmul(Node *nl, Node *nr, Node *res)
 	case TUINT32:
 		gins(optoas(OMUL, t), &n2, &n1);
 		p = gins(ASRD, N, &n1);
-		p->from.type = D_CONST;
+		p->from.type = TYPE_CONST;
 		p->from.offset = w;
 		break;
 	case TINT64:
@@ -915,23 +913,23 @@ clearfat(Node *nl)
 	if(reg[REGRT1] > 0)
 		fatal("R%d in use during clearfat", REGRT1);
 
-	nodreg(&r0, types[TUINT64], 0); // r0 is always zero
-	nodreg(&dst, types[tptr], D_R0+REGRT1);
+	nodreg(&r0, types[TUINT64], REG_R0); // r0 is always zero
+	nodreg(&dst, types[tptr], REGRT1);
 	reg[REGRT1]++;
 	agen(nl, &dst);
 
 	if(q > 128) {
 		p = gins(ASUB, N, &dst);
-		p->from.type = D_CONST;
+		p->from.type = TYPE_CONST;
 		p->from.offset = 8;
 
 		regalloc(&end, types[tptr], N);
 		p = gins(AMOVD, &dst, &end);
-		p->from.type = D_CONST;
+		p->from.type = TYPE_CONST;
 		p->from.offset = q*8;
 
 		p = gins(AMOVDU, &r0, &dst);
-		p->to.type = D_OREG;
+		p->to.type = TYPE_MEM;
 		p->to.offset = 8;
 		pl = p;
 
@@ -943,7 +941,7 @@ clearfat(Node *nl)
 		boff = 8;
 	} else if(q >= 4) {
 		p = gins(ASUB, N, &dst);
-		p->from.type = D_CONST;
+		p->from.type = TYPE_CONST;
 		p->from.offset = 8;
 		f = sysfunc("duffzero");
 		p = gins(ADUFFZERO, N, f);
@@ -955,7 +953,7 @@ clearfat(Node *nl)
 	} else {
 		for(t = 0; t < q; t++) {
 			p = gins(AMOVD, &r0, &dst);
-			p->to.type = D_OREG;
+			p->to.type = TYPE_MEM;
 			p->to.offset = 8*t;
 		}
 		boff = 8*q;
@@ -963,7 +961,7 @@ clearfat(Node *nl)
 
 	for(t = 0; t < c; t++) {
 		p = gins(AMOVB, &r0, &dst);
-		p->to.type = D_OREG;
+		p->to.type = TYPE_MEM;
 		p->to.offset = t+boff;
 	}
 	reg[REGRT1]--;
@@ -983,7 +981,7 @@ expandchecks(Prog *firstp)
 			continue;
 		if(debug_checknil && p->lineno > 1) // p->lineno==1 in generated wrappers
 			warnl(p->lineno, "generated nil check");
-		if(p->from.type != D_REG)
+		if(p->from.type != TYPE_REG)
 			fatal("invalid nil check %P\n", p);
 		/*
 		// check is
@@ -994,11 +992,11 @@ expandchecks(Prog *firstp)
 		reg = p->from.reg;
 		p->as = ATD;
 		p->from = p->to = p->from3 = zprog.from;
-		p->from.type = D_CONST;
+		p->from.type = TYPE_CONST;
 		p->from.offset = 4;
-		p->from.reg = NREG;
-		p->reg = 0;
-		p->to.type = D_REG;
+		p->from.reg = 0;
+		p->reg = REG_R0;
+		p->to.type = TYPE_REG;
 		p->to.reg = reg;
 		*/
 		// check is
@@ -1017,19 +1015,19 @@ expandchecks(Prog *firstp)
 		p1->pc = 9999;
 		p2->pc = 9999;
 		p->as = ACMP;
-		p->to.type = D_REG;
+		p->to.type = TYPE_REG;
 		p->to.reg = REGZERO;
 		p1->as = ABNE;
-		//p1->from.type = D_CONST;
+		//p1->from.type = TYPE_CONST;
 		//p1->from.offset = 1; // likely
-		p1->to.type = D_BRANCH;
+		p1->to.type = TYPE_BRANCH;
 		p1->to.u.branch = p2->link;
 		// crash by write to memory address 0.
 		p2->as = AMOVD;
-		p2->from.type = D_REG;
-		p2->from.reg = 0;
-		p2->to.type = D_OREG;
-		p2->to.reg = 0;
+		p2->from.type = TYPE_REG;
+		p2->from.reg = REG_R0;
+		p2->to.type = TYPE_MEM;
+		p2->to.reg = REG_R0;
 		p2->to.offset = 0;
 	}
 }
diff --git a/src/cmd/9g/gobj.c b/src/cmd/9g/gobj.c
index cda0b0e714..b970405ca2 100644
--- a/src/cmd/9g/gobj.c
+++ b/src/cmd/9g/gobj.c
@@ -38,17 +38,15 @@ dsname(Sym *s, int off, char *t, int n)
 	Prog *p;
 
 	p = gins(ADATA, N, N);
-	p->from.type = D_OREG;
-	p->from.name = D_EXTERN;
+	p->from.type = TYPE_MEM;
+	p->from.name = NAME_EXTERN;
 	p->from.offset = off;
-	p->from.reg = NREG;
 	p->from.sym = linksym(s);
 
 	p->reg = n;
 	
-	p->to.type = D_SCONST;
-	p->to.name = D_NONE;
-	p->to.reg = NREG;
+	p->to.type = TYPE_SCONST;
+	p->to.name = NAME_NONE;
 	p->to.offset = 0;
 	memmove(p->to.u.sval, t, n);
 	return off + n;
@@ -64,11 +62,11 @@ datastring(char *s, int len, Addr *a)
 	Sym *sym;
 	
 	sym = stringsym(s, len);
-	a->type = D_OREG;
-	a->name = D_EXTERN;
+	a->type = TYPE_MEM;
+	a->name = NAME_EXTERN;
 	a->etype = simtype[TINT];
 	a->offset = widthptr+widthint;  // skip header
-	a->reg = NREG;
+	a->reg = 0;
 	a->sym = linksym(sym);
 	a->node = sym->def;
 }
@@ -83,10 +81,10 @@ datagostring(Strlit *sval, Addr *a)
 	Sym *sym;
 
 	sym = stringsym(sval->s, sval->len);
-	a->type = D_OREG;
-	a->name = D_EXTERN;
+	a->type = TYPE_MEM;
+	a->name = NAME_EXTERN;
 	a->sym = linksym(sym);
-	a->reg = NREG;
+	a->reg = 0;
 	a->node = sym->def;
 	a->offset = 0;  // header
 	a->etype = TSTRING;
@@ -122,13 +120,13 @@ gdatacomplex(Node *nam, Mpcplx *cval)
 
 	p = gins(ADATA, nam, N);
 	p->reg = w;
-	p->to.type = D_FCONST;
+	p->to.type = TYPE_FCONST;
 	p->to.u.dval = mpgetflt(&cval->real);
 
 	p = gins(ADATA, nam, N);
 	p->reg = w;
 	p->from.offset += w;
-	p->to.type = D_FCONST;
+	p->to.type = TYPE_FCONST;
 	p->to.u.dval = mpgetflt(&cval->imag);
 }
 
@@ -141,7 +139,7 @@ gdatastring(Node *nam, Strlit *sval)
 	p = gins(ADATA, nam, N);
 	datastring(sval->s, sval->len, &p->to);
 	p->reg = types[tptr]->width;
-	p->to.type = D_CONST;
+	p->to.type = TYPE_CONST;
 	p->to.etype = simtype[tptr];
 
 	nodconst(&nod1, types[TINT], sval->len);
@@ -157,14 +155,14 @@ dstringptr(Sym *s, int off, char *str)
 
 	off = rnd(off, widthptr);
 	p = gins(ADATA, N, N);
-	p->from.type = D_OREG;
-	p->from.name = D_EXTERN;
+	p->from.type = TYPE_MEM;
+	p->from.name = NAME_EXTERN;
 	p->from.sym = linksym(s);
 	p->from.offset = off;
 	p->reg = widthptr;
 
 	datastring(str, strlen(str)+1, &p->to);
-	p->to.type = D_CONST;
+	p->to.type = TYPE_CONST;
 	p->to.etype = simtype[TINT];
 	off += widthptr;
 
@@ -181,13 +179,13 @@ dgostrlitptr(Sym *s, int off, Strlit *lit)
 
 	off = rnd(off, widthptr);
 	p = gins(ADATA, N, N);
-	p->from.type = D_OREG;
-	p->from.name = D_EXTERN;
+	p->from.type = TYPE_MEM;
+	p->from.name = NAME_EXTERN;
 	p->from.sym = linksym(s);
 	p->from.offset = off;
 	p->reg = widthptr;
 	datagostring(lit, &p->to);
-	p->to.type = D_CONST;
+	p->to.type = TYPE_CONST;
 	p->to.etype = simtype[TINT];
 	off += widthptr;
 
@@ -218,13 +216,13 @@ dsymptr(Sym *s, int off, Sym *x, int xoff)
 	off = rnd(off, widthptr);
 
 	p = gins(ADATA, N, N);
-	p->from.type = D_OREG;
-	p->from.name = D_EXTERN;
+	p->from.type = TYPE_MEM;
+	p->from.name = NAME_EXTERN;
 	p->from.sym = linksym(s);
 	p->from.offset = off;
 	p->reg = widthptr;
-	p->to.type = D_CONST;
-	p->to.name = D_EXTERN;
+	p->to.type = TYPE_CONST;
+	p->to.name = NAME_EXTERN;
 	p->to.sym = linksym(x);
 	p->to.offset = xoff;
 	off += widthptr;
diff --git a/src/cmd/9g/gsubr.c b/src/cmd/9g/gsubr.c
index 8abbde4531..bafc26c03e 100644
--- a/src/cmd/9g/gsubr.c
+++ b/src/cmd/9g/gsubr.c
@@ -116,14 +116,14 @@ gbranch(int as, Type *t, int likely)
 	USED(t);
 
 	p = prog(as);
-	p->to.type = D_BRANCH;
+	p->to.type = TYPE_BRANCH;
 	p->to.u.branch = P;
 	// TODO(minux): Enable this code.
 	// Note: liblink used Bcc CR0, label form, so we need another way
 	// to set likely/unlikely flag. Also note the y bit is not exactly
 	// likely/unlikely bit.
 	if(0 && as != ABR && likely != 0) {
-		p->from.type = D_CONST;
+		p->from.type = TYPE_CONST;
 		p->from.offset = likely > 0;
 	}
 	return p;
@@ -135,7 +135,7 @@ gbranch(int as, Type *t, int likely)
 void
 patch(Prog *p, Prog *to)
 {
-	if(p->to.type != D_BRANCH)
+	if(p->to.type != TYPE_BRANCH)
 		fatal("patch: not a branch");
 	p->to.u.branch = to;
 	p->to.offset = to->pc;
@@ -146,7 +146,7 @@ unpatch(Prog *p)
 {
 	Prog *q;
 
-	if(p->to.type != D_BRANCH)
+	if(p->to.type != TYPE_BRANCH)
 		fatal("unpatch: not a branch");
 	q = p->to.u.branch;
 	p->to.u.branch = P;
@@ -197,7 +197,7 @@ ggloblnod(Node *nam)
 	p->lineno = nam->lineno;
 	p->from.sym->gotype = linksym(ngotype(nam));
 	p->to.sym = nil;
-	p->to.type = D_CONST;
+	p->to.type = TYPE_CONST;
 	p->to.offset = nam->type->width;
 	if(nam->readonly)
 		p->reg = RODATA;
@@ -211,8 +211,8 @@ gtrack(Sym *s)
 	Prog *p;
 	
 	p = gins(AUSEFIELD, N, N);
-	p->from.type = D_OREG;
-	p->from.name = D_EXTERN;
+	p->from.type = TYPE_MEM;
+	p->from.name = NAME_EXTERN;
 	p->from.sym = linksym(s);
 }
 
@@ -222,11 +222,11 @@ ggloblsym(Sym *s, int32 width, int8 flags)
 	Prog *p;
 
 	p = gins(AGLOBL, N, N);
-	p->from.type = D_OREG;
-	p->from.name = D_EXTERN;
+	p->from.type = TYPE_MEM;
+	p->from.name = NAME_EXTERN;
 	p->from.sym = linksym(s);
-	p->to.type = D_CONST;
-	p->to.name = D_NONE;
+	p->to.type = TYPE_CONST;
+	p->to.name = NAME_NONE;
 	p->to.offset = width;
 	p->reg = flags;
 }
@@ -253,8 +253,8 @@ isfat(Type *t)
 void
 afunclit(Addr *a, Node *n)
 {
-	if(a->type == D_CONST && a->name == D_EXTERN) {
-		a->type = D_OREG;
+	if(a->type == TYPE_CONST && a->name == NAME_EXTERN) {
+		a->type = TYPE_MEM;
 		a->sym = linksym(n->sym);
 	}
 }
@@ -272,11 +272,11 @@ static	int	resvd[] =
 	// TODO(austin): Consolidate REGTLS and REGG?
 	REGG,
 	REGTMP,	// REGTMP
-	FREGCVI+NREG,
-	FREGZERO+NREG,
-	FREGHALF+NREG,
-	FREGONE+NREG,
-	FREGTWO+NREG,
+	FREGCVI,
+	FREGZERO,
+	FREGHALF,
+	FREGONE,
+	FREGTWO,
 };
 
 void
@@ -286,13 +286,11 @@ ginit(void)
 
 	for(i=0; i<nelem(reg); i++)
 		reg[i] = 1;
-	for(i=0; i<NREG; i++)
-		reg[i] = 0;
-	for(i=NREG; i<NREG+NREG; i++)
+	for(i=0; i<NREG+NFREG; i++)
 		reg[i] = 0;
 
 	for(i=0; i<nelem(resvd); i++)
-		reg[resvd[i]]++;
+		reg[resvd[i] - REG_R0]++;
 }
 
 static	uintptr	regpc[nelem(reg)];
@@ -303,11 +301,11 @@ gclean(void)
 	int i;
 
 	for(i=0; i<nelem(resvd); i++)
-		reg[resvd[i]]--;
+		reg[resvd[i] - REG_R0]--;
 
 	for(i=0; i<nelem(reg); i++)
 		if(reg[i])
-			yyerror("reg %R left allocated, %p\n", i, regpc[i]);
+			yyerror("reg %R left allocated, %p\n", i+REG_R0, regpc[i]);
 }
 
 int32
@@ -345,9 +343,9 @@ regalloc(Node *n, Type *t, Node *o)
 	if(debug['r']) {
 		fixfree = 0;
 		fltfree = 0;
-		for(i = D_R0; i < D_F0+NREG; i++)
-			if(reg[i] == 0) {
-				if(i < D_F0)
+		for(i = REG_R0; i < REG_F31; i++)
+			if(reg[i - REG_R0] == 0) {
+				if(i < REG_F0)
 					fixfree++;
 				else
 					fltfree++;
@@ -369,34 +367,34 @@ regalloc(Node *n, Type *t, Node *o)
 	case TBOOL:
 		if(o != N && o->op == OREGISTER) {
 			i = o->val.u.reg;
-			if(i >= D_R0+REGMIN && i <= D_R0+REGMAX)
+			if(i >= REGMIN && i <= REGMAX)
 				goto out;
 		}
-		for(i=D_R0+REGMIN; i<=D_R0+REGMAX; i++)
-			if(reg[i] == 0) {
-				regpc[i] = (uintptr)getcallerpc(&n);
+		for(i=REGMIN; i<=REGMAX; i++)
+			if(reg[i - REG_R0] == 0) {
+				regpc[i - REG_R0] = (uintptr)getcallerpc(&n);
 				goto out;
 			}
 		flusherrors();
-		for(i=D_R0; i<D_R0+NREG; i++)
-			print("R%d %p\n", i, regpc[i]);
+		for(i=REG_R0; i<REG_R0+NREG; i++)
+			print("R%d %p\n", i, regpc[i - REG_R0]);
 		fatal("out of fixed registers");
 
 	case TFLOAT32:
 	case TFLOAT64:
 		if(o != N && o->op == OREGISTER) {
 			i = o->val.u.reg;
-			if(i >= D_F0+FREGMIN && i <= D_F0+FREGMAX)
+			if(i >= FREGMIN && i <= FREGMAX)
 				goto out;
 		}
-		for(i=D_F0+FREGMIN; i<=D_F0+FREGMAX; i++)
-			if(reg[i] == 0) {
-				regpc[i] = (uintptr)getcallerpc(&n);
+		for(i=FREGMIN; i<=FREGMAX; i++)
+			if(reg[i - REG_R0] == 0) {
+				regpc[i - REG_R0] = (uintptr)getcallerpc(&n);
 				goto out;
 			}
 		flusherrors();
-		for(i=D_F0; i<D_F0+NREG; i++)
-			print("F%d %p\n", i, regpc[i]);
+		for(i=REG_F0; i<REG_F0+NREG; i++)
+			print("F%d %p\n", i, regpc[i - REG_R0]);
 		fatal("out of floating registers");
 
 	case TCOMPLEX64:
@@ -408,7 +406,7 @@ regalloc(Node *n, Type *t, Node *o)
 	return;
 
 out:
-	reg[i]++;
+	reg[i - REG_R0]++;
 	nodreg(n, t, i);
 }
 
@@ -421,8 +419,8 @@ regfree(Node *n)
 		return;
 	if(n->op != OREGISTER && n->op != OINDREG)
 		fatal("regfree: not a register");
-	i = n->val.u.reg;
-	if(i == D_R0 + REGSP)
+	i = n->val.u.reg - REG_R0;
+	if(i == REGSP - REG_R0)
 		return;
 	if(i < 0 || i >= nelem(reg))
 		fatal("regfree: reg out of range");
@@ -517,7 +515,7 @@ fp:
 
 	case 0:		// output arg for calling another function
 		n->op = OINDREG;
-		n->val.u.reg = D_R0+REGSP;
+		n->val.u.reg = REGSP;
 		n->xoffset += 8;
 		break;
 
@@ -528,7 +526,7 @@ fp:
 	case 2:		// offset output arg
 fatal("shouldn't be used");
 		n->op = OINDREG;
-		n->val.u.reg = D_R0 + REGSP;
+		n->val.u.reg = REGSP;
 		n->xoffset += types[tptr]->width;
 		break;
 	}
@@ -883,18 +881,18 @@ gmove(Node *f, Node *t)
 		regalloc(&r3, types[TINT64], t);
 		gins(AFCTIDZ, &r1, &r2);
 		p1 = gins(AFMOVD, &r2, N);
-		p1->to.type = D_OREG;
+		p1->to.type = TYPE_MEM;
 		p1->to.reg = REGSP;
 		p1->to.offset = -8;
 		p1 = gins(AMOVD, N, &r3);
-		p1->from.type = D_OREG;
+		p1->from.type = TYPE_MEM;
 		p1->from.reg = REGSP;
 		p1->from.offset = -8;
 		regfree(&r2);
 		regfree(&r1);
 		if(tt == TUINT64) {
 			p1 = gbranch(optoas(OLT, types[TFLOAT64]), T, +1); // use CR0 here again
-			nodreg(&r1, types[TINT64], D_R0+REGTMP);
+			nodreg(&r1, types[TINT64], REGTMP);
 			gins(AMOVD, &bigi, &r1);
 			gins(AADD, &r1, &r3);
 			patch(p1, pc);
@@ -931,29 +929,29 @@ gmove(Node *f, Node *t)
 		regalloc(&r1, types[TINT64], N);
 		gmove(f, &r1);
 		if(ft == TUINT64) {
-			nodreg(&r2, types[TUINT64], D_R0+REGTMP);
+			nodreg(&r2, types[TUINT64], REGTMP);
 			gmove(&bigi, &r2);
 			gins(ACMPU, &r1, &r2);
 			p1 = gbranch(optoas(OLT, types[TUINT64]), T, +1);
 			p2 = gins(ASRD, N, &r1);
-			p2->from.type = D_CONST;
+			p2->from.type = TYPE_CONST;
 			p2->from.offset = 1;
 			patch(p1, pc);
 		}
 		regalloc(&r2, types[TFLOAT64], t);
 		p1 = gins(AMOVD, &r1, N);
-		p1->to.type = D_OREG;
+		p1->to.type = TYPE_MEM;
 		p1->to.reg = REGSP;
 		p1->to.offset = -8;
 		p1 = gins(AFMOVD, N, &r2);
-		p1->from.type = D_OREG;
+		p1->from.type = TYPE_MEM;
 		p1->from.reg = REGSP;
 		p1->from.offset = -8;
 		gins(AFCFID, &r2, &r2);
 		regfree(&r1);
 		if(ft == TUINT64) {
 			p1 = gbranch(optoas(OLT, types[TUINT64]), T, +1); // use CR0 here again
-			nodreg(&r1, types[TFLOAT64], D_F0+FREGTWO);
+			nodreg(&r1, types[TFLOAT64], FREGTWO);
 			gins(AFMUL, &r1, &r2);
 			patch(p1, pc);
 		}
@@ -1026,8 +1024,6 @@ gins(int as, Node *f, Node *t)
 		p->from = af;
 	if(t != N)
 		p->to = at;
-	if(as == ATEXT)
-		p->reg = 0;
 	if(debug['g'])
 		print("%P\n", p);
 
@@ -1053,12 +1049,12 @@ gins(int as, Node *f, Node *t)
 		break;
 	case AMOVD:
 	case AMOVDU:
-		if(af.type == D_CONST)
+		if(af.type == TYPE_CONST)
 			break;
 		w = 8;
 		break;
 	}
-	if(w != 0 && ((f != N && af.width < w) || (t != N && at.type != D_REG && at.width > w))) {
+	if(w != 0 && ((f != N && af.width < w) || (t != N && at.type != TYPE_REG && at.width > w))) {
 		dump("f", f);
 		dump("t", t);
 		fatal("bad width: %P (%d, %d)\n", p, af.width, at.width);
@@ -1076,7 +1072,7 @@ fixlargeoffset(Node *n)
 		return;
 	if(n->op != OINDREG)
 		return;
-	if(n->val.u.reg == D_R0+REGSP) // stack offset cannot be large
+	if(n->val.u.reg == REGSP) // stack offset cannot be large
 		return;
 	if(n->xoffset != (int32)n->xoffset) {
 		// TODO(minux): offset too large, move into R31 and add to R31 instead.
@@ -1102,9 +1098,9 @@ naddr(Node *n, Addr *a, int canemitcode)
 {
 	Sym *s;
 
-	a->type = D_NONE;
-	a->name = D_NONE;
-	a->reg = NREG;
+	a->type = TYPE_NONE;
+	a->name = NAME_NONE;
+	a->reg = 0;
 	a->gotype = nil;
 	a->node = N;
 	a->etype = 0;
@@ -1124,7 +1120,7 @@ naddr(Node *n, Addr *a, int canemitcode)
 
 	case ONAME:
 		a->etype = 0;
-		a->reg = NREG;
+		a->reg = 0;
 		if(n->type != T)
 			a->etype = simtype[n->type->etype];
 		a->offset = n->xoffset;
@@ -1141,23 +1137,23 @@ naddr(Node *n, Addr *a, int canemitcode)
 				s = pkglookup(s->name, n->type->sym->pkg);
 		}
 
-		a->type = D_OREG;
+		a->type = TYPE_MEM;
 		switch(n->class) {
 		default:
 			fatal("naddr: ONAME class %S %d\n", n->sym, n->class);
 		case PEXTERN:
-			a->name = D_EXTERN;
+			a->name = NAME_EXTERN;
 			break;
 		case PAUTO:
-			a->name = D_AUTO;
+			a->name = NAME_AUTO;
 			break;
 		case PPARAM:
 		case PPARAMOUT:
-			a->name = D_PARAM;
+			a->name = NAME_PARAM;
 			break;
 		case PFUNC:
-			a->name = D_EXTERN;
-			a->type = D_CONST;
+			a->name = NAME_EXTERN;
+			a->type = TYPE_CONST;
 			a->width = widthptr;
 			s = funcsym(s);
 			break;
@@ -1171,13 +1167,13 @@ naddr(Node *n, Addr *a, int canemitcode)
 			fatal("naddr: const %lT", n->type);
 			break;
 		case CTFLT:
-			a->type = D_FCONST;
+			a->type = TYPE_FCONST;
 			a->u.dval = mpgetflt(n->val.u.fval);
 			break;
 		case CTINT:
 		case CTRUNE:
 			a->sym = nil;
-			a->type = D_CONST;
+			a->type = TYPE_CONST;
 			a->offset = mpgetfix(n->val.u.xval);
 			break;
 		case CTSTR:
@@ -1185,30 +1181,25 @@ naddr(Node *n, Addr *a, int canemitcode)
 			break;
 		case CTBOOL:
 			a->sym = nil;
-			a->type = D_CONST;
+			a->type = TYPE_CONST;
 			a->offset = n->val.u.bval;
 			break;
 		case CTNIL:
 			a->sym = nil;
-			a->type = D_CONST;
+			a->type = TYPE_CONST;
 			a->offset = 0;
 			break;
 		}
 		break;
 
 	case OREGISTER:
-		if(n->val.u.reg < D_F0) {
-			a->type = D_REG;
-			a->reg = n->val.u.reg;
-		} else {
-			a->type = D_FREG;
-			a->reg = n->val.u.reg - D_F0;
-		}
+		a->type = TYPE_REG;
+		a->reg = n->val.u.reg;
 		a->sym = nil;
 		break;
 
 	case OINDREG:
-		a->type = D_OREG;
+		a->type = TYPE_MEM;
 		a->reg = n->val.u.reg;
 		a->sym = linksym(n->sym);
 		a->offset = n->xoffset;
@@ -1223,15 +1214,15 @@ naddr(Node *n, Addr *a, int canemitcode)
 		a->width = n->left->type->width;
 		a->offset = n->xoffset;
 		a->sym = linksym(n->left->sym);
-		a->type = D_OREG;
-		a->name = D_PARAM;
+		a->type = TYPE_MEM;
+		a->name = NAME_PARAM;
 		a->node = n->left->orig;
 		break;
 
 	case OCLOSUREVAR:
 		if(!curfn->needctxt)
 			fatal("closurevar without needctxt");
-		a->type = D_OREG;
+		a->type = TYPE_MEM;
 		a->reg = REGENV;
 		a->offset = n->xoffset;
 		a->sym = nil;
@@ -1246,7 +1237,7 @@ naddr(Node *n, Addr *a, int canemitcode)
 		// itable of interface value
 		naddr(n->left, a, canemitcode);
 		a->etype = simtype[tptr];
-		if(a->type == D_CONST && a->offset == 0)
+		if(a->type == TYPE_CONST && a->offset == 0)
 			break;	// itab(nil)
 		a->width = widthptr;
 		break;
@@ -1255,7 +1246,7 @@ naddr(Node *n, Addr *a, int canemitcode)
 		// pointer in a string or slice
 		naddr(n->left, a, canemitcode);
 		a->etype = simtype[tptr];
-		if(a->type == D_CONST && a->offset == 0)
+		if(a->type == TYPE_CONST && a->offset == 0)
 			break;	// ptr(nil)
 		a->offset += Array_array;
 		a->width = widthptr;
@@ -1265,7 +1256,7 @@ naddr(Node *n, Addr *a, int canemitcode)
 		// len of string or slice
 		naddr(n->left, a, canemitcode);
 		a->etype = simtype[TINT];
-		if(a->type == D_CONST && a->offset == 0)
+		if(a->type == TYPE_CONST && a->offset == 0)
 			break;	// len(nil)
 		a->offset += Array_nel;
 		a->width = widthint;
@@ -1275,7 +1266,7 @@ naddr(Node *n, Addr *a, int canemitcode)
 		// cap of string or slice
 		naddr(n->left, a, canemitcode);
 		a->etype = simtype[TINT];
-		if(a->type == D_CONST && a->offset == 0)
+		if(a->type == TYPE_CONST && a->offset == 0)
 			break;	// cap(nil)
 		a->offset += Array_cap;
 		a->width = widthint;
@@ -1285,12 +1276,12 @@ naddr(Node *n, Addr *a, int canemitcode)
 		naddr(n->left, a, canemitcode);
 		a->etype = tptr;
 		switch(a->type) {
-		case D_OREG:
-			a->type = D_CONST;
+		case TYPE_MEM:
+			a->type = TYPE_CONST;
 			break;
 
-		case D_REG:
-		case D_CONST:
+		case TYPE_REG:
+		case TYPE_CONST:
 			break;
 
 		default:
diff --git a/src/cmd/9g/peep.c b/src/cmd/9g/peep.c
index 11a6b591a2..36ee095984 100644
--- a/src/cmd/9g/peep.c
+++ b/src/cmd/9g/peep.c
@@ -88,8 +88,8 @@ loop1:
 			// Convert uses to $0 to uses of R0 and
 			// propagate R0
 			if(regzer(&p->from))
-			if(p->to.type == D_REG) {
-				p->from.type = D_REG;
+			if(p->to.type == TYPE_REG) {
+				p->from.type = TYPE_REG;
 				p->from.reg = REGZERO;
 				if(copyprop(r)) {
 					excise(r);
@@ -119,7 +119,7 @@ loop1:
 		case AMOVBZ:
 		case AMOVW:
 		case AMOVWZ:
-			if(p->to.type != D_REG)
+			if(p->to.type != TYPE_REG)
 				continue;
 			break;
 		}
@@ -129,9 +129,9 @@ loop1:
 		p1 = r1->prog;
 		if(p1->as != p->as)
 			continue;
-		if(p1->from.type != D_REG || p1->from.reg != p->to.reg)
+		if(p1->from.type != TYPE_REG || p1->from.reg != p->to.reg)
 			continue;
-		if(p1->to.type != D_REG || p1->to.reg != p->to.reg)
+		if(p1->to.type != TYPE_REG || p1->to.reg != p->to.reg)
 			continue;
 		excise(r1);
 	}
@@ -177,7 +177,7 @@ loop1:
 			if(r1 == nil)
 				continue;
 			p1 = r1->prog;
-			if(p1->to.type != D_REG || p1->to.reg != p->from.reg)
+			if(p1->to.type != TYPE_REG || p1->to.reg != p->from.reg)
 				continue;
 			switch(p1->as) {
 			case ASUB:
@@ -185,7 +185,7 @@ loop1:
 			case AXOR:
 			case AOR:
 				/* irregular instructions */
-				if(p1->from.type == D_CONST)
+				if(p1->from.type == TYPE_CONST)
 					continue;
 				break;
 			}
@@ -194,7 +194,7 @@ loop1:
 				continue;
 			case AMOVW:
 			case AMOVD:
-				if(p1->from.type != D_REG)
+				if(p1->from.type != TYPE_REG)
 					continue;
 				continue;
 			case AANDCC:
@@ -342,11 +342,11 @@ excise(Flow *r)
 static int
 regzer(Addr *a)
 {
-	if(a->type == D_CONST)
-		if(a->sym == nil && a->reg == NREG)
+	if(a->type == TYPE_CONST)
+		if(a->sym == nil && a->reg == 0)
 			if(a->offset == 0)
 				return 1;
-	if(a->type == D_REG)
+	if(a->type == TYPE_REG)
 		if(a->reg == REGZERO)
 			return 1;
 	return 0;
@@ -355,15 +355,8 @@ regzer(Addr *a)
 int
 regtyp(Adr *a)
 {
-	switch(a->type) {
-	default:
-		return 0;
-	case D_REG:
-		if(a->reg == REGZERO)
-			return 0;
-	case D_FREG:
-		return 1;
-	}
+	// TODO(rsc): Floating point register exclusions?
+	return a->type == TYPE_REG && REG_R0 <= a->reg && a->reg <= REG_F31 && a->reg != REGZERO;
 }
 
 /*
@@ -578,7 +571,7 @@ copy1(Addr *v1, Addr *v2, Flow *r, int f)
 int
 copyu(Prog *p, Addr *v, Addr *s)
 {
-	if(p->from3.type != D_NONE)
+	if(p->from3.type != TYPE_NONE)
 		// 9g never generates a from3
 		print("copyu: from3 (%D) not implemented\n", p->from3);
 
@@ -630,7 +623,7 @@ copyu(Prog *p, Addr *v, Addr *s)
 		}
 		if(copyas(&p->to, v)) {
 			// Fix up implicit from
-			if(p->from.type == D_NONE)
+			if(p->from.type == TYPE_NONE)
 				p->from = p->to;
 			if(copyau(&p->from, v))
 				return 4;
@@ -649,7 +642,7 @@ copyu(Prog *p, Addr *v, Addr *s)
 	case AMOVHZU:
 	case AMOVWZU:
 	case AMOVDU:
-		if(p->from.type == D_OREG) {
+		if(p->from.type == TYPE_MEM) {
 			if(copyas(&p->from, v))
 				// No s!=nil check; need to fail
 				// anyway in that case
@@ -661,7 +654,7 @@ copyu(Prog *p, Addr *v, Addr *s)
 			}
 			if(copyas(&p->to, v))
 				return 3;
-		} else if (p->to.type == D_OREG) {
+		} else if (p->to.type == TYPE_MEM) {
 			if(copyas(&p->to, v))
 				return 2;
 			if(s != nil) {
@@ -740,7 +733,7 @@ copyu(Prog *p, Addr *v, Addr *s)
 			return 0;
 		}
 		if(copyas(&p->to, v)) {
-			if(p->reg == NREG)
+			if(p->reg == 0)
 				// Fix up implicit reg (e.g., ADD
 				// R3,R4 -> ADD R3,R4,R4) so we can
 				// update reg and to separately.
@@ -808,17 +801,20 @@ copyu(Prog *p, Addr *v, Addr *s)
 		return 3;
 
 	case ABL:	/* funny */
-		if(v->type == D_REG) {
-			if(v->reg <= REGEXT && v->reg > exregoffset)
+		if(v->type == TYPE_REG) {
+			// TODO(rsc): REG_R0 and REG_F0 used to be
+			// (when register numbers started at 0) exregoffset and exfregoffset,
+			// which are unset entirely. 
+			// It's strange that this handles R0 and F0 differently from the other
+			// registers. Possible failure to optimize?
+			if(REG_R0 < v->reg && v->reg <= REGEXT)
 				return 2;
 			if(v->reg == REGARG)
 				return 2;
-		}
-		if(v->type == D_FREG) {
-			if(v->reg <= FREGEXT && v->reg > exfregoffset)
+			if(REG_F0 < v->reg && v->reg <= FREGEXT)
 				return 2;
 		}
-		if(p->from.type == D_REG && v->type == D_REG && p->from.reg == v->reg)
+		if(p->from.type == TYPE_REG && v->type == TYPE_REG && p->from.reg == v->reg)
 			return 2;
 
 		if(s != nil) {
@@ -833,7 +829,7 @@ copyu(Prog *p, Addr *v, Addr *s)
 	case ADUFFZERO:
 		// R0 is zero, used by DUFFZERO, cannot be substituted.
 		// R3 is ptr to memory, used and set, cannot be substituted.
-		if(v->type == D_REG) {
+		if(v->type == TYPE_REG) {
 			if(v->reg == 0)
 				return 1;
 			if(v->reg == 3)
@@ -844,7 +840,7 @@ copyu(Prog *p, Addr *v, Addr *s)
 	case ADUFFCOPY:
 		// R3, R4 are ptr to src, dst, used and set, cannot be substituted.
 		// R5 is scratch, set by DUFFCOPY, cannot be substituted.
-		if(v->type == D_REG) {
+		if(v->type == TYPE_REG) {
 			if(v->reg == 3 || v->reg == 4)
 				return 2;
 			if(v->reg == 5)
@@ -853,7 +849,7 @@ copyu(Prog *p, Addr *v, Addr *s)
 		return 0;
 
 	case ATEXT:	/* funny */
-		if(v->type == D_REG)
+		if(v->type == TYPE_REG)
 			if(v->reg == REGARG)
 				return 3;
 		return 0;
@@ -866,18 +862,6 @@ copyu(Prog *p, Addr *v, Addr *s)
 	}
 }
 
-int
-a2type(Prog *p)
-{
-	ProgInfo info;
-	proginfo(&info, p);
-	if(info.flags & (SizeB|SizeW|SizeL|SizeQ))
-		return D_REG;
-	if(info.flags & (SizeF|SizeD))
-		return D_FREG;
-	return D_NONE;
-}
-
 // copyas returns 1 if a and v address the same register.
 //
 // If a is the from operand, this means this operation reads the
@@ -905,8 +889,8 @@ copyau(Addr *a, Addr *v)
 {
 	if(copyas(a, v))
 		return 1;
-	if(v->type == D_REG)
-		if(a->type == D_OREG || (a->type == D_CONST && a->reg != NREG))
+	if(v->type == TYPE_REG)
+		if(a->type == TYPE_MEM || (a->type == TYPE_CONST && a->reg != 0))
 			if(v->reg == a->reg)
 				return 1;
 	return 0;
@@ -917,17 +901,9 @@ copyau(Addr *a, Addr *v)
 static int
 copyau1(Prog *p, Addr *v)
 {
-	if(regtyp(v))
-		if(p->from.type == v->type || p->to.type == v->type)
-		if(p->reg == v->reg) {
-			// Whether p->reg is a GPR or an FPR is
-			// implied by the instruction (both are
-			// numbered from 0).  But the type should
-			// match v->type.  Sanity check this.
-			if(a2type(p) != v->type)
-				print("botch a2type %P\n", p);
+	if(regtyp(v) && v->reg != 0)
+		if(p->reg == v->reg)
 			return 1;
-		}
 	return 0;
 }
 
@@ -960,7 +936,7 @@ sameaddr(Addr *a, Addr *v)
 		return 0;
 	if(regtyp(v) && a->reg == v->reg)
 		return 1;
-	if(v->type == D_AUTO || v->type == D_PARAM)
+	if(v->type == NAME_AUTO || v->type == NAME_PARAM)
 		if(v->offset == a->offset)
 			return 1;
 	return 0;
@@ -969,7 +945,7 @@ sameaddr(Addr *a, Addr *v)
 int
 smallindir(Addr *a, Addr *reg)
 {
-	return reg->type == D_REG && a->type == D_OREG &&
+	return reg->type == TYPE_REG && a->type == TYPE_MEM &&
 		a->reg == reg->reg &&
 		0 <= a->offset && a->offset < 4096;
 }
@@ -977,5 +953,5 @@ smallindir(Addr *a, Addr *reg)
 int
 stackaddr(Addr *a)
 {
-	return a->type == D_REG && a->reg == REGSP;
+	return a->type == TYPE_REG && a->reg == REGSP;
 }
diff --git a/src/cmd/9g/prog.c b/src/cmd/9g/prog.c
index 7c0f0c7959..9bcf381d95 100644
--- a/src/cmd/9g/prog.c
+++ b/src/cmd/9g/prog.c
@@ -137,37 +137,37 @@ proginfo(ProgInfo *info, Prog *p)
 		fatal("proginfo: unknown instruction %P", p);
 	}
 
-	if((info->flags & RegRead) && p->reg == NREG) {
+	if((info->flags & RegRead) && p->reg == 0) {
 		info->flags &= ~RegRead;
 		info->flags |= /*CanRegRead |*/ RightRead;
 	}
 
-	if((p->from.type == D_OREG || p->from.type == D_CONST) && p->from.reg != NREG) {
+	if((p->from.type == TYPE_MEM || p->from.type == TYPE_CONST) && p->from.reg != 0) {
 		info->regindex |= RtoB(p->from.reg);
 		if(info->flags & PostInc) {
 			info->regset |= RtoB(p->from.reg);
 		}
 	}
-	if((p->to.type == D_OREG || p->to.type == D_CONST) && p->to.reg != NREG) {
+	if((p->to.type == TYPE_MEM || p->to.type == TYPE_CONST) && p->to.reg != 0) {
 		info->regindex |= RtoB(p->to.reg);
 		if(info->flags & PostInc) {
 			info->regset |= RtoB(p->to.reg);
 		}
 	}
 
-	if(p->from.type == D_CONST && p->from.sym != nil && (info->flags & LeftRead)) {
+	if(p->from.type == TYPE_CONST && p->from.sym != nil && (info->flags & LeftRead)) {
 		info->flags &= ~LeftRead;
 		info->flags |= LeftAddr;
 	}
 
 	if(p->as == ADUFFZERO) {
-		info->reguse |= (1<<D_R0) | RtoB(3);
-		info->regset |= RtoB(3);
+		info->reguse |= (1<<0) | RtoB(REG_R3);
+		info->regset |= RtoB(REG_R3);
 	}
 	if(p->as == ADUFFCOPY) {
 		// TODO(austin) Revisit when duffcopy is implemented
-		info->reguse |= RtoB(3) | RtoB(4) | RtoB(5);
-		info->regset |= RtoB(3) | RtoB(4);
+		info->reguse |= RtoB(REG_R3) | RtoB(REG_R4) | RtoB(REG_R5);
+		info->regset |= RtoB(REG_R3) | RtoB(REG_R4);
 	}
 }
 
diff --git a/src/cmd/9g/reg.c b/src/cmd/9g/reg.c
index 47e6dd2d4a..bb522d5485 100644
--- a/src/cmd/9g/reg.c
+++ b/src/cmd/9g/reg.c
@@ -185,9 +185,9 @@ regopt(Prog *firstp)
 	}
 
 	// Exclude registers with fixed functions
-	regbits = (1<<D_R0)|RtoB(REGSP)|RtoB(REGG)|RtoB(REGTLS);
+	regbits = (1<<0)|RtoB(REGSP)|RtoB(REGG)|RtoB(REGTLS);
 	// Also exclude floating point registers with fixed constants
-	regbits |= FtoB(D_F0+27)|FtoB(D_F0+28)|FtoB(D_F0+29)|FtoB(D_F0+30)|FtoB(D_F0+31);
+	regbits |= RtoB(REG_F27)|RtoB(REG_F28)|RtoB(REG_F29)|RtoB(REG_F30)|RtoB(REG_F31);
 	externs = zbits;
 	params = zbits;
 	consts = zbits;
@@ -217,7 +217,7 @@ regopt(Prog *firstp)
 		proginfo(&info, p);
 
 		// Avoid making variables for direct-called functions.
-		if(p->as == ABL && p->to.name == D_EXTERN)
+		if(p->as == ABL && p->to.name == NAME_EXTERN)
 			continue;
 
 		// from vs to doesn't matter for registers
@@ -233,16 +233,12 @@ regopt(Prog *firstp)
 				r->use1.b[z] |= bit.b[z];
 
 		// Compute used register for reg
-		if(info.flags & RegRead) {
-			if(p->from.type != D_FREG)
-				r->use1.b[0] |= RtoB(p->reg);
-			else
-				r->use1.b[0] |= FtoB(D_F0+p->reg);
-		}
+		if(info.flags & RegRead)
+			r->use1.b[0] |= RtoB(p->reg);
 
 		// Currently we never generate three register forms.
 		// If we do, this will need to change.
-		if(p->from3.type != D_NONE)
+		if(p->from3.type != TYPE_NONE)
 			fatal("regopt not implemented for from3");
 
 		// Compute used register for to
@@ -484,7 +480,7 @@ brk:
 	for(p=firstp; p!=P; p=p->link) {
 		while(p->link != P && p->link->as == ANOP)
 			p->link = p->link->link;
-		if(p->to.type == D_BRANCH)
+		if(p->to.type == TYPE_BRANCH)
 			while(p->to.u.branch != P && p->to.u.branch->as == ANOP)
 				p->to.u.branch = p->to.u.branch->link;
 	}
@@ -556,7 +552,7 @@ addmove(Reg *r, int bn, int rn, int f)
 	// If there's a stack fixup coming (ADD $n,R1 after BL newproc or BL deferproc),
 	// delay the load until after the fixup.
 	p2 = p->link;
-	if(p2 && p2->as == AADD && p2->to.reg == REGSP && p2->to.type == D_REG)
+	if(p2 && p2->as == AADD && p2->to.reg == REGSP && p2->to.type == TYPE_REG)
 		p = p2;
 
 	p1->link = p->link;
@@ -571,9 +567,9 @@ addmove(Reg *r, int bn, int rn, int f)
 	a->sym = linksym(v->node->sym);
 	a->offset = v->offset;
 	a->etype = v->etype;
-	a->type = D_OREG;
+	a->type = TYPE_MEM;
 	if(a->etype == TARRAY || a->sym == nil)
-		a->type = D_CONST;
+		a->type = TYPE_CONST;
 
 	if(v->addr)
 		fatal("addmove: shouldn't be doing this %A\n", a);
@@ -616,21 +612,13 @@ addmove(Reg *r, int bn, int rn, int f)
 		break;
 	}
 
-	p1->from.type = D_REG;
+	p1->from.type = TYPE_REG;
 	p1->from.reg = rn;
-	if(rn >= NREG) {
-		p1->from.type = D_FREG;
-		p1->from.reg = rn-NREG;
-	}
 	if(!f) {
 		p1->from = *a;
 		*a = zprog.from;
-		a->type = D_REG;
+		a->type = TYPE_REG;
 		a->reg = rn;
-		if(rn >= NREG) {
-			a->type = D_FREG;
-			a->reg = rn-NREG;
-		}
 		if(v->etype == TUINT8 || v->etype == TBOOL)
 			p1->as = AMOVBZ;
 		if(v->etype == TUINT16)
@@ -673,42 +661,33 @@ mkvar(Reg *r, Adr *a)
 		print("type %d %d %D\n", t, a->name, a);
 		goto none;
 
-	case D_NONE:
+	case TYPE_NONE:
 		goto none;
 
-	case D_BRANCH:
-	case D_CONST:
-	case D_FCONST:
-	case D_SCONST:
-	case D_SPR:
-	case D_OREG:
+	case TYPE_BRANCH:
+	case TYPE_CONST:
+	case TYPE_FCONST:
+	case TYPE_SCONST:
+	case TYPE_MEM:
 		break;
 
-	case D_REG:
-		if(a->reg != NREG) {
+	case TYPE_REG:
+		if(a->reg != 0) {
 			bit = zbits;
 			bit.b[0] = RtoB(a->reg);
 			return bit;
 		}
 		break;
-
-	case D_FREG:
-		if(a->reg != NREG) {
-			bit = zbits;
-			bit.b[0] = FtoB(D_F0+a->reg);
-			return bit;
-		}
-		break;
 	}
 
 	switch(a->name) {
 	default:
 		goto none;
 
-	case D_EXTERN:
-	case D_STATIC:
-	case D_AUTO:
-	case D_PARAM:
+	case NAME_EXTERN:
+	case NAME_STATIC:
+	case NAME_AUTO:
+	case NAME_PARAM:
 		n = a->name;
 		break;
 	}
@@ -784,10 +763,10 @@ mkvar(Reg *r, Adr *a)
 	node->opt = v;
 
 	bit = blsh(i);
-	if(n == D_EXTERN || n == D_STATIC)
+	if(n == NAME_EXTERN || n == NAME_STATIC)
 		for(z=0; z<BITS; z++)
 			externs.b[z] |= bit.b[z];
-	if(n == D_PARAM)
+	if(n == NAME_PARAM)
 		for(z=0; z<BITS; z++)
 			params.b[z] |= bit.b[z];
 
@@ -1014,7 +993,7 @@ allreg(uint64 b, Rgn *r)
 		i = BtoF(~b);
 		if(i && r->cost > 0) {
 			r->regno = i;
-			return FtoB(i);
+			return RtoB(i);
 		}
 		break;
 	}
@@ -1213,13 +1192,9 @@ addreg(Adr *a, int rn)
 {
 	a->sym = nil;
 	a->node = nil;
-	a->name = D_NONE;
-	a->type = D_REG;
+	a->name = NAME_NONE;
+	a->type = TYPE_REG;
 	a->reg = rn;
-	if(rn >= NREG) {
-		a->type = D_FREG;
-		a->reg = rn-NREG;
-	}
 
 	ostats.ncvtreg++;
 }
@@ -1239,8 +1214,10 @@ addreg(Adr *a, int rn)
 uint64
 RtoB(int r)
 {
-	if(r > D_R0 && r <= D_R0+31)
-		return 1ULL << (r - D_R0);
+	if(r > REG_R0 && r <= REG_R31)
+		return 1ULL << (r - REG_R0);
+	if(r >= REG_F0 && r <= REG_F31)
+		return 1ULL << (32 + r - REG_F0);
 	return 0;
 }
 
@@ -1250,15 +1227,7 @@ BtoR(uint64 b)
 	b &= 0xffffffffull;
 	if(b == 0)
 		return 0;
-	return bitno(b) + D_R0;
-}
-
-uint64
-FtoB(int r)
-{
-	if(r >= D_F0 && r <= D_F0+31)
-		return 1ULL << (32 + r - D_F0);
-	return 0;
+	return bitno(b) + REG_R0;
 }
 
 int
@@ -1267,7 +1236,7 @@ BtoF(uint64 b)
 	b >>= 32;
 	if(b == 0)
 		return 0;
-	return bitno(b) + D_F0;
+	return bitno(b) + REG_F0;
 }
 
 void
diff --git a/src/cmd/9l/9.out.h b/src/cmd/9l/9.out.h
index dbb2e0a768..0616e32556 100644
--- a/src/cmd/9l/9.out.h
+++ b/src/cmd/9l/9.out.h
@@ -42,30 +42,118 @@ enum
 
 enum
 {
-	REGZERO		= 0,	/* set to zero */
-	REGSP		= 1,
-	REGSB		= 2,
-	REGRET		= 3,
+	REG_R0 = 32,
+	REG_R1,
+	REG_R2,
+	REG_R3,
+	REG_R4,
+	REG_R5,
+	REG_R6,
+	REG_R7,
+	REG_R8,
+	REG_R9,
+	REG_R10,
+	REG_R11,
+	REG_R12,
+	REG_R13,
+	REG_R14,
+	REG_R15,
+	REG_R16,
+	REG_R17,
+	REG_R18,
+	REG_R19,
+	REG_R20,
+	REG_R21,
+	REG_R22,
+	REG_R23,
+	REG_R24,
+	REG_R25,
+	REG_R26,
+	REG_R27,
+	REG_R28,
+	REG_R29,
+	REG_R30,
+	REG_R31,
+
+	REG_F0 = 64,
+	REG_F1,
+	REG_F2,
+	REG_F3,
+	REG_F4,
+	REG_F5,
+	REG_F6,
+	REG_F7,
+	REG_F8,
+	REG_F9,
+	REG_F10,
+	REG_F11,
+	REG_F12,
+	REG_F13,
+	REG_F14,
+	REG_F15,
+	REG_F16,
+	REG_F17,
+	REG_F18,
+	REG_F19,
+	REG_F20,
+	REG_F21,
+	REG_F22,
+	REG_F23,
+	REG_F24,
+	REG_F25,
+	REG_F26,
+	REG_F27,
+	REG_F28,
+	REG_F29,
+	REG_F30,
+	REG_F31,
+	
+	REG_SPECIAL = 96,
+
+	REG_C0 = 96,
+	REG_C1,
+	REG_C2,
+	REG_C3,
+	REG_C4,
+	REG_C5,
+	REG_C6,
+	REG_C7,
+	
+	REG_MSR = 104,
+	REG_FPSCR,
+	REG_CR,
+
+	REG_SPR0 = 1024, // first of 1024 registers
+	REG_DCR0 = 2048, // first of 1024 registers
+	
+	REG_XER = REG_SPR0 + 1,
+	REG_LR = REG_SPR0 + 8,
+	REG_CTR = REG_SPR0 + 9,
+
+	REGZERO		= REG_R0,	/* set to zero */
+	REGSP		= REG_R1,
+	REGSB		= REG_R2,
+	REGRET		= REG_R3,
 	REGARG		= -1,	/* -1 disables passing the first argument in register */
-	REGRT1		= 3,	/* reserved for runtime, duffzero and duffcopy */
-	REGRT2		= 4,	/* reserved for runtime, duffcopy */
-	REGMIN		= 7,	/* register variables allocated from here to REGMAX */
-	REGENV		= 11,	/* environment for closures */
-	REGTLS		= 13,	/* C ABI TLS base pointer */
-	REGMAX		= 27,
-	REGEXT		= 30,	/* external registers allocated from here down */
-	REGG		= 30,	/* G */
-	REGTMP		= 31,	/* used by the linker */
+	REGRT1		= REG_R3,	/* reserved for runtime, duffzero and duffcopy */
+	REGRT2		= REG_R4,	/* reserved for runtime, duffcopy */
+	REGMIN		= REG_R7,	/* register variables allocated from here to REGMAX */
+	REGENV		= REG_R11,	/* environment for closures */
+	REGTLS		= REG_R13,	/* C ABI TLS base pointer */
+	REGMAX		= REG_R27,
+	REGEXT		= REG_R30,	/* external registers allocated from here down */
+	REGG		= REG_R30,	/* G */
+	REGTMP		= REG_R31,	/* used by the linker */
 
-	FREGRET		= 0,
-	FREGMIN		= 17,	/* first register variable */
-	FREGMAX		= 26,	/* last register variable for 9g only */
-	FREGEXT		= 26,	/* first external register */
-	FREGCVI		= 27,	/* floating conversion constant */
-	FREGZERO	= 28,	/* both float and double */
-	FREGHALF	= 29,	/* double */
-	FREGONE		= 30,	/* double */
-	FREGTWO		= 31	/* double */
+	FREGRET		= REG_F0,
+	FREGMIN		= REG_F17,	/* first register variable */
+	FREGMAX		= REG_F26,	/* last register variable for 9g only */
+	FREGEXT		= REG_F26,	/* first external register */
+	FREGCVI		= REG_F27,	/* floating conversion constant */
+	FREGZERO	= REG_F28,	/* both float and double */
+	FREGHALF	= REG_F29,	/* double */
+	FREGONE		= REG_F30,	/* double */
+	FREGTWO		= REG_F31	/* double */
 /*
  * GENERAL:
  *
@@ -471,50 +559,6 @@ enum
 	ALAST
 };
 
-/* type/name */
-enum
-{
-	D_GOK	= 0,
-	D_NONE,
-
-/* name */
-	D_EXTERN,
-	D_STATIC,
-	D_AUTO,
-	D_PARAM,
-
-/* type */
-	D_BRANCH,
-	D_OREG,
-	D_CONST,
-	D_FCONST,
-	D_SCONST,
-	D_REG,
-	D_FPSCR,
-	D_MSR,
-	D_FREG,
-	D_CREG,
-	D_SPR,
-	D_OPT,	/* branch/trap option */
-	D_FILE,
-	D_FILE1,
-	D_DCR,	/* device control register */
-	D_DCONST,
-	D_ADDR, // not used, use D_CONST with non-empty sym.
-
-	D_LAST,
-
-/* reg names for 9g OREGISTER */
-	D_R0 = 0, // type is D_REG
-	D_F0 = D_R0+NREG, // type is D_FREG
-
-/* reg names in offset field iff type is D_SPR */
-	D_XER	= 1,
-	D_LR	= 8,
-	D_CTR	= 9
-	/* and many supervisor level registers */
-};
-
 /*
  * this is the ranlib header
  */
diff --git a/src/liblink/asm9.c b/src/liblink/asm9.c
index f604395a7a..3ae8c48442 100644
--- a/src/liblink/asm9.c
+++ b/src/liblink/asm9.c
@@ -543,14 +543,14 @@ span9(Link *ctxt, LSym *cursym)
 					q->link = p->link;
 					p->link = q;
 					q->as = ABR;
-					q->to.type = D_BRANCH;
+					q->to.type = TYPE_BRANCH;
 					q->pcond = p->pcond;
 					p->pcond = q;
 					q = ctxt->arch->prg();
 					q->link = p->link;
 					p->link = q;
 					q->as = ABR;
-					q->to.type = D_BRANCH;
+					q->to.type = TYPE_BRANCH;
 					q->pcond = q->link->link;
 					//addnop(p->link);
 					//addnop(p);
@@ -614,57 +614,56 @@ aclass(Link *ctxt, Addr *a)
 	LSym *s;
 
 	switch(a->type) {
-	case D_NONE:
+	case TYPE_NONE:
 		return C_NONE;
 
-	case D_REG:
-		return C_REG;
-
-	case D_FREG:
-		return C_FREG;
-
-	case D_CREG:
-		return C_CREG;
-
-	case D_SPR:
-		if(a->offset == D_LR)
-			return C_LR;
-		if(a->offset == D_XER)
-			return C_XER;
-		if(a->offset == D_CTR)
-			return C_CTR;
-		return C_SPR;
-
-	case D_DCR:
-		return C_SPR;
-
-	case D_FPSCR:
-		return C_FPSCR;
-
-	case D_MSR:
-		return C_MSR;
+	case TYPE_REG:
+		if(REG_R0 <= a->reg && a->reg <= REG_R31)
+			return C_REG;
+		if(REG_F0 <= a->reg && a->reg <= REG_F31)
+			return C_FREG;
+		if(REG_C0 <= a->reg && a->reg <= REG_C7 || a->reg == REG_CR)
+			return C_CREG;
+		if(REG_SPR0 <= a->reg && a->reg <= REG_SPR0+1023) {
+			switch(a->reg) {
+			case REG_LR:
+				return C_LR;
+			case REG_XER:
+				return C_XER;
+			case REG_CTR:
+				return C_CTR;
+			}
+			return C_SPR;
+		}
+		if(REG_DCR0 <= a->reg && a->reg <= REG_DCR0+1023)
+			return C_SPR;
+		if(a->reg == REG_FPSCR)
+			return C_FPSCR;
+		if(a->reg == REG_MSR)
+			return C_MSR;
+		return C_GOK;
 
-	case D_OREG:
+	case TYPE_MEM:
 		switch(a->name) {
-		case D_EXTERN:
-		case D_STATIC:
+		case NAME_EXTERN:
+		case NAME_STATIC:
 			if(a->sym == nil)
 				break;
 			ctxt->instoffset = a->offset;
 			if(a->sym != nil) // use relocation
 				return C_ADDR;
 			return C_LEXT;
-		case D_AUTO:
+		case NAME_AUTO:
 			ctxt->instoffset = ctxt->autosize + a->offset;
 			if(ctxt->instoffset >= -BIG && ctxt->instoffset < BIG)
 				return C_SAUTO;
 			return C_LAUTO;
-		case D_PARAM:
+		case NAME_PARAM:
 			ctxt->instoffset = ctxt->autosize + a->offset + 8L;
 			if(ctxt->instoffset >= -BIG && ctxt->instoffset < BIG)
 				return C_SAUTO;
 			return C_LAUTO;
-		case D_NONE:
+		case TYPE_NONE:
 			ctxt->instoffset = a->offset;
 			if(ctxt->instoffset == 0)
 				return C_ZOREG;
@@ -674,17 +673,11 @@ aclass(Link *ctxt, Addr *a)
 		}
 		return C_GOK;
 
-	case D_OPT:
-		ctxt->instoffset = a->offset & 31L;
-		if(a->name == D_NONE)
-			return C_SCON;
-		return C_GOK;
-
-	case D_CONST:
+	case TYPE_CONST:
 		switch(a->name) {
-		case D_NONE:
+		case TYPE_NONE:
 			ctxt->instoffset = a->offset;
-			if(a->reg != NREG) {
+			if(a->reg != 0) {
 				if(-BIG <= ctxt->instoffset && ctxt->instoffset <= BIG)
 					return C_SACON;
 				if(isint32(ctxt->instoffset))
@@ -693,8 +686,8 @@ aclass(Link *ctxt, Addr *a)
 			}
 			goto consize;
 
-		case D_EXTERN:
-		case D_STATIC:
+		case NAME_EXTERN:
+		case NAME_STATIC:
 			s = a->sym;
 			if(s == nil)
 				break;
@@ -706,13 +699,13 @@ aclass(Link *ctxt, Addr *a)
 			/* not sure why this barfs */
 			return C_LCON;
 
-		case D_AUTO:
+		case NAME_AUTO:
 			ctxt->instoffset = ctxt->autosize + a->offset;
 			if(ctxt->instoffset >= -BIG && ctxt->instoffset < BIG)
 				return C_SACON;
 			return C_LACON;
 
-		case D_PARAM:
+		case NAME_PARAM:
 			ctxt->instoffset = ctxt->autosize + a->offset + 8L;
 			if(ctxt->instoffset >= -BIG && ctxt->instoffset < BIG)
 				return C_SACON;
@@ -742,7 +735,7 @@ aclass(Link *ctxt, Addr *a)
 			return C_LCON;
 		return C_DCON;
 
-	case D_BRANCH:
+	case TYPE_BRANCH:
 		return C_SBRA;
 	}
 	return C_GOK;
@@ -783,7 +776,7 @@ oplook(Link *ctxt, Prog *p)
 	}
 	a4--;
 	a2 = C_NONE;
-	if(p->reg != NREG)
+	if(p->reg != 0)
 		a2 = C_REG;
 //print("oplook %P %d %d %d %d\n", p, a1, a2, a3, a4);
 	r = p->as;
@@ -1515,7 +1508,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 		break;
 
 	case 1:		/* mov r1,r2 ==> OR Rs,Rs,Ra */
-		if(p->to.reg == REGZERO && p->from.type == D_CONST) {
+		if(p->to.reg == REGZERO && p->from.type == TYPE_CONST) {
 			v = regoff(ctxt, &p->from);
 			if(r0iszero && v != 0) {
 				//nerrors--;
@@ -1529,7 +1522,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 
 	case 2:		/* int/cr/fp op Rb,[Ra],Rd */
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = p->to.reg;
 		o1 = AOP_RRR(oprrr(ctxt, p->as), p->to.reg, r, p->from.reg);
 		break;
@@ -1538,7 +1531,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 		d = vregoff(ctxt, &p->from);
 		v = d;
 		r = p->from.reg;
-		if(r == NREG)
+		if(r == 0)
 			r = o->param;
 		if(r0iszero && p->to.reg == 0 && (r != 0 || v != 0))
 			ctxt->diag("literal operation on R0\n%P", p);
@@ -1562,7 +1555,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 	case 4:		/* add/mul $scon,[r1],r2 */
 		v = regoff(ctxt, &p->from);
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = p->to.reg;
 		if(r0iszero && p->to.reg == 0)
 			ctxt->diag("literal operation on R0\n%P", p);
@@ -1577,17 +1570,17 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 
 	case 6:		/* logical op Rb,[Rs,]Ra; no literal */
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = p->to.reg;
 		o1 = LOP_RRR(oprrr(ctxt, p->as), p->to.reg, r, p->from.reg);
 		break;
 
 	case 7:		/* mov r, soreg ==> stw o(r) */
 		r = p->to.reg;
-		if(r == NREG)
+		if(r == 0)
 			r = o->param;
 		v = regoff(ctxt, &p->to);
-		if(p->to.type == D_OREG && p->reg != NREG) {
+		if(p->to.type == TYPE_MEM && p->reg != 0) {
 			if(v)
 				ctxt->diag("illegal indexed instruction\n%P", p);
 			o1 = AOP_RRR(opstorex(ctxt, p->as), p->from.reg, p->reg, r);
@@ -1600,10 +1593,10 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 
 	case 8:		/* mov soreg, r ==> lbz/lhz/lwz o(r) */
 		r = p->from.reg;
-		if(r == NREG)
+		if(r == 0)
 			r = o->param;
 		v = regoff(ctxt, &p->from);
-		if(p->from.type == D_OREG && p->reg != NREG) {
+		if(p->from.type == TYPE_MEM && p->reg != 0) {
 			if(v)
 				ctxt->diag("illegal indexed instruction\n%P", p);
 			o1 = AOP_RRR(oploadx(ctxt, p->as), p->to.reg, p->reg, r);
@@ -1616,10 +1609,10 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 
 	case 9:		/* movb soreg, r ==> lbz o(r),r2; extsb r2,r2 */
 		r = p->from.reg;
-		if(r == NREG)
+		if(r == 0)
 			r = o->param;
 		v = regoff(ctxt, &p->from);
-		if(p->from.type == D_OREG && p->reg != NREG) {
+		if(p->from.type == TYPE_MEM && p->reg != 0) {
 			if(v)
 				ctxt->diag("illegal indexed instruction\n%P", p);
 			o1 = AOP_RRR(oploadx(ctxt, p->as), p->to.reg, p->reg, r);
@@ -1630,7 +1623,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 
 	case 10:		/* sub Ra,[Rb],Rd => subf Rd,Ra,Rb */
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = p->to.reg;
 		o1 = AOP_RRR(oprrr(ctxt, p->as), p->to.reg, p->from.reg, r);
 		break;
@@ -1663,7 +1656,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 		break;
 
 	case 12:	/* movb r,r (extsb); movw r,r (extsw) */
-		if(p->to.reg == REGZERO && p->from.type == D_CONST) {
+		if(p->to.reg == REGZERO && p->from.type == TYPE_CONST) {
 			v = regoff(ctxt, &p->from);
 			if(r0iszero && v != 0) {
 				ctxt->diag("literal operation on R0\n%P", p);
@@ -1692,7 +1685,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 
 	case 14:	/* rldc[lr] Rb,Rs,$mask,Ra -- left, right give different masks */
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = p->to.reg;
 		d = vregoff(ctxt, &p->from3);
 		maskgen64(ctxt, p, mask, d);
@@ -1720,10 +1713,10 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 	case 17:	/* bc bo,bi,lbra (same for now) */
 	case 16:	/* bc bo,bi,sbra */
 		a = 0;
-		if(p->from.type == D_CONST)
+		if(p->from.type == TYPE_CONST)
 			a = regoff(ctxt, &p->from);
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = 0;
 		v = 0;
 		if(p->pcond)
@@ -1743,9 +1736,9 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 		else
 			v = 20;	/* unconditional */
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = 0;
-		o1 = AOP_RRR(OP_MTSPR, p->to.reg, 0, 0) | ((D_LR&0x1f)<<16) | (((D_LR>>5)&0x1f)<<11);
+		o1 = AOP_RRR(OP_MTSPR, p->to.reg, 0, 0) | ((REG_LR&0x1f)<<16) | (((REG_LR>>5)&0x1f)<<11);
 		o2 = OPVCC(19, 16, 0, 0);
 		if(p->as == ABL || p->as == ABCL)
 			o2 |= 1;
@@ -1758,7 +1751,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 		else
 			v = 20;	/* unconditional */
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = 0;
 		switch(oclass(&p->to)) {
 		case C_CTR:
@@ -1792,7 +1785,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 	case 20:	/* add $ucon,,r */
 		v = regoff(ctxt, &p->from);
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = p->to.reg;
 		if(p->as == AADD && (!r0iszero && p->reg == 0 || r0iszero && p->to.reg == 0))
 			ctxt->diag("literal operation on R0\n%P", p);
@@ -1806,7 +1799,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 		o1 = loadu32(REGTMP, d);
 		o2 = LOP_IRR(OP_ORI, REGTMP, REGTMP, (int32)d);
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = p->to.reg;
 		o3 = AOP_RRR(oprrr(ctxt, p->as), p->to.reg, REGTMP, r);
 		if(p->from.sym != nil)
@@ -1821,7 +1814,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 		o1 = loadu32(REGTMP, d);
 		o2 = LOP_IRR(OP_ORI, REGTMP, REGTMP, (int32)d);
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = p->to.reg;
 		o3 = LOP_RRR(oprrr(ctxt, p->as), p->to.reg, REGTMP, r);
 		if(p->from.sym != nil)
@@ -1837,7 +1830,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 		else if(v > 63)
 			v = 63;
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = p->to.reg;
 		switch(p->as){
 		case ASLD: case ASLDCC:
@@ -1869,7 +1862,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 			ctxt->diag("can't synthesize large constant\n%P", p);
 		v = regoff(ctxt, &p->from);
 		r = p->from.reg;
-		if(r == NREG)
+		if(r == 0)
 			r = o->param;
 		o1 = AOP_IRR(OP_ADDIS, REGTMP, r, high16adjusted(v));
 		o2 = AOP_IRR(OP_ADDI, p->to.reg, REGTMP, v);
@@ -1961,7 +1954,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 
 	case 32:	/* fmul frc,fra,frd */
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = p->to.reg;
 		o1 = AOP_RRR(oprrr(ctxt, p->as), p->to.reg, r, 0)|((p->from.reg&31L)<<6);
 		break;
@@ -1980,7 +1973,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 	case 35:	/* mov r,lext/lauto/loreg ==> cau $(v>>16),sb,r'; store o(r') */
 		v = regoff(ctxt, &p->to);
 		r = p->to.reg;
-		if(r == NREG)
+		if(r == 0)
 			r = o->param;
 		o1 = AOP_IRR(OP_ADDIS, REGTMP, r, high16adjusted(v));
 		o2 = AOP_IRR(opstore(ctxt, p->as), p->from.reg, REGTMP, v);
@@ -1989,7 +1982,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 	case 36:	/* mov bz/h/hz lext/lauto/lreg,r ==> lbz/lha/lhz etc */
 		v = regoff(ctxt, &p->from);
 		r = p->from.reg;
-		if(r == NREG)
+		if(r == 0)
 			r = o->param;
 		o1 = AOP_IRR(OP_ADDIS, REGTMP, r, high16adjusted(v));
 		o2 = AOP_IRR(opload(ctxt, p->as), p->to.reg, REGTMP, v);
@@ -1998,7 +1991,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 	case 37:	/* movb lext/lauto/lreg,r ==> lbz o(reg),r; extsb r */
 		v = regoff(ctxt, &p->from);
 		r = p->from.reg;
-		if(r == NREG)
+		if(r == 0)
 			r = o->param;
 		o1 = AOP_IRR(OP_ADDIS, REGTMP, r, high16adjusted(v));
 		o2 = AOP_IRR(opload(ctxt, p->as), p->to.reg, REGTMP, v);
@@ -2019,20 +2012,20 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 
 	case 43:	/* unary indexed source: dcbf (b); dcbf (a+b) */
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = 0;
 		o1 = AOP_RRR(oprrr(ctxt, p->as), 0, r, p->from.reg);
 		break;
 
 	case 44:	/* indexed store */
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = 0;
 		o1 = AOP_RRR(opstorex(ctxt, p->as), p->from.reg, r, p->to.reg);
 		break;
 	case 45:	/* indexed load */
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = 0;
 		o1 = AOP_RRR(oploadx(ctxt, p->as), p->to.reg, r, p->from.reg);
 		break;
@@ -2043,20 +2036,20 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 
 	case 47:	/* op Ra, Rd; also op [Ra,] Rd */
 		r = p->from.reg;
-		if(r == NREG)
+		if(r == 0)
 			r = p->to.reg;
 		o1 = AOP_RRR(oprrr(ctxt, p->as), p->to.reg, r, 0);
 		break;
 
 	case 48:	/* op Rs, Ra */
 		r = p->from.reg;
-		if(r == NREG)
+		if(r == 0)
 			r = p->to.reg;
 		o1 = LOP_RRR(oprrr(ctxt, p->as), p->to.reg, r, 0);
 		break;
 
 	case 49:	/* op Rb; op $n, Rb */
-		if(p->from.type != D_REG){	/* tlbie $L, rB */
+		if(p->from.type != TYPE_REG){	/* tlbie $L, rB */
 			v = regoff(ctxt, &p->from) & 1;
 			o1 = AOP_RRR(oprrr(ctxt, p->as), 0, 0, p->to.reg) | (v<<21);
 		}else
@@ -2065,7 +2058,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 
 	case 50:	/* rem[u] r1[,r2],r3 */
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = p->to.reg;
 		v = oprrr(ctxt, p->as);
 		t = v & ((1<<10)|1);	/* OE|Rc */
@@ -2081,7 +2074,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 
 	case 51:	/* remd[u] r1[,r2],r3 */
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = p->to.reg;
 		v = oprrr(ctxt, p->as);
 		t = v & ((1<<10)|1);	/* OE|Rc */
@@ -2116,7 +2109,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 	case 56:	/* sra $sh,[s,]a; srd $sh,[s,]a */
 		v = regoff(ctxt, &p->from);
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = p->to.reg;
 		o1 = AOP_RRR(opirr(ctxt, p->as), r, p->to.reg, v&31L);
 		if(p->as == ASRAD && (v&0x20))
@@ -2126,7 +2119,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 	case 57:	/* slw $sh,[s,]a -> rlwinm ... */
 		v = regoff(ctxt, &p->from);
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = p->to.reg;
 		/*
 		 * Let user (gs) shoot himself in the foot. 
@@ -2155,7 +2148,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 	case 58:		/* logical $andcon,[s],a */
 		v = regoff(ctxt, &p->from);
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = p->to.reg;
 		o1 = LOP_IRR(opirr(ctxt, p->as), p->to.reg, r, v);
 		break;
@@ -2163,7 +2156,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 	case 59:	/* or/and $ucon,,r */
 		v = regoff(ctxt, &p->from);
 		r = p->reg;
-		if(r == NREG)
+		if(r == 0)
 			r = p->to.reg;
 		o1 = LOP_IRR(opirr(ctxt, p->as+AEND), p->to.reg, r, v>>16);	/* oris, xoris, andis */
 		break;
@@ -2193,7 +2186,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 		break;
 
 	case 64:	/* mtfsf fr[, $m] {,fpcsr} */
-		if(p->from3.type != D_NONE)
+		if(p->from3.type != TYPE_NONE)
 			v = regoff(ctxt, &p->from3)&255L;
 		else
 			v = 255;
@@ -2201,23 +2194,23 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 		break;
 
 	case 65:	/* MOVFL $imm,FPSCR(n) => mtfsfi crfd,imm */
-		if(p->to.reg == NREG)
+		if(p->to.reg == 0)
 			ctxt->diag("must specify FPSCR(n)\n%P", p);
 		o1 = OP_MTFSFI | ((p->to.reg&15L)<<23) | ((regoff(ctxt, &p->from)&31L)<<12);
 		break;
 
 	case 66:	/* mov spr,r1; mov r1,spr, also dcr */
-		if(p->from.type == D_REG) {
+		if(REG_R0 <= p->from.reg && p->from.reg <= REG_R31) {
 			r = p->from.reg;
-			v = p->to.offset;
-			if(p->to.type == D_DCR)
+			v = p->to.reg;
+			if(REG_DCR0 <= v && v <= REG_DCR0+1023)
 				o1 = OPVCC(31,451,0,0);	/* mtdcr */
 			else
 				o1 = OPVCC(31,467,0,0); /* mtspr */
 		} else {
 			r = p->to.reg;
-			v = p->from.offset;
-			if(p->from.type == D_DCR)
+			v = p->from.reg;
+			if(REG_DCR0 <= v && v <= REG_DCR0+1023)
 				o1 = OPVCC(31,323,0,0);	/* mfdcr */
 			else
 				o1 = OPVCC(31,339,0,0);	/* mfspr */
@@ -2226,14 +2219,14 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 		break;
 
 	case 67:	/* mcrf crfD,crfS */
-		if(p->from.type != D_CREG || p->from.reg == NREG ||
-		   p->to.type != D_CREG || p->to.reg == NREG)
+		if(p->from.type != TYPE_REG || p->from.reg < REG_C0 || REG_C7 < p->from.reg ||
+		   p->to.type != TYPE_REG || p->to.reg < REG_C0 || REG_C7 < p->to.reg)
 			ctxt->diag("illegal CR field number\n%P", p);
 		o1 = AOP_RRR(OP_MCRF, ((p->to.reg&7L)<<2), ((p->from.reg&7)<<2), 0);
 		break;
 
 	case 68:	/* mfcr rD; mfocrf CRM,rD */
-		if(p->from.type == D_CREG && p->from.reg != NREG){
+		if(p->from.type == TYPE_REG && REG_C0 <= p->from.reg && p->from.reg <= REG_C7) {
 			v = 1<<(7-(p->to.reg&7));	/* CR(n) */
 			o1 = AOP_RRR(OP_MFCR, p->to.reg, 0, 0) | (1<<20) | (v<<12);	/* new form, mfocrf */
 		}else
@@ -2241,12 +2234,12 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 		break;
 
 	case 69:	/* mtcrf CRM,rS */
-		if(p->from3.type != D_NONE) {
-			if(p->to.reg != NREG)
+		if(p->from3.type != TYPE_NONE) {
+			if(p->to.reg != 0)
 				ctxt->diag("can't use both mask and CR(n)\n%P", p);
 			v = regoff(ctxt, &p->from3) & 0xff;
 		} else {
-			if(p->to.reg == NREG)
+			if(p->to.reg == 0)
 				v = 0xff;	/* CR */
 			else
 				v = 1<<(7-(p->to.reg&7));	/* CR(n) */
@@ -2255,7 +2248,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 		break;
 
 	case 70:	/* [f]cmp r,r,cr*/
-		if(p->reg == NREG)
+		if(p->reg == 0)
 			r = 0;
 		else
 			r = (p->reg&7)<<2;
@@ -2263,7 +2256,7 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 		break;
 
 	case 71:	/* cmp[l] r,i,cr*/
-		if(p->reg == NREG)
+		if(p->reg == 0)
 			r = 0;
 		else
 			r = (p->reg&7)<<2;
@@ -2275,18 +2268,18 @@ asmout(Link *ctxt, Prog *p, Optab *o, uint32 *out)
 		break;
 
 	case 73:	/* mcrfs crfD,crfS */
-		if(p->from.type != D_FPSCR || p->from.reg == NREG ||
-		   p->to.type != D_CREG || p->to.reg == NREG)
+		if(p->from.type != TYPE_REG || p->from.reg != REG_FPSCR ||
+		   p->to.type != TYPE_REG || p->to.reg < REG_C0 || REG_C7 < p->to.reg)
 			ctxt->diag("illegal FPSCR/CR field number\n%P", p);
-		o1 = AOP_RRR(OP_MCRFS, ((p->to.reg&7L)<<2), ((p->from.reg&7)<<2), 0);
+		o1 = AOP_RRR(OP_MCRFS, ((p->to.reg&7L)<<2), ((0&7)<<2), 0);
 		break;
 
 	case 77:	/* syscall $scon, syscall Rx */
-		if(p->from.type == D_CONST) {
+		if(p->from.type == TYPE_CONST) {
 			if(p->from.offset > BIG || p->from.offset < -BIG)
 				ctxt->diag("illegal syscall, sysnum too large: %P", p);
 			o1 = AOP_IRR(OP_ADDI, REGZERO, REGZERO, p->from.offset);
-		} else if(p->from.type == D_REG) {
+		} else if(p->from.type == TYPE_REG) {
 			o1 = LOP_RRR(OP_OR, REGZERO, p->from.reg, p->from.reg);
 		} else {
 			ctxt->diag("illegal syscall: %P", p);
diff --git a/src/liblink/list9.c b/src/liblink/list9.c
index ce0fb4b295..f688b50751 100644
--- a/src/liblink/list9.c
+++ b/src/liblink/list9.c
@@ -86,7 +86,7 @@ Pconv(Fmt *fp)
 {
 	char str[STRINGSZ];
 	Prog *p;
-	int a, ch;
+	int a;
 
 	p = va_arg(fp->args, Prog*);
 	bigP = p;
@@ -108,25 +108,21 @@ Pconv(Fmt *fp)
 	} else {
 		if(p->mark & NOSCHED)
 			sprint(strchr(str, 0), "*");
-		if(p->reg == NREG && p->from3.type == D_NONE)
+		if(p->reg == 0 && p->from3.type == TYPE_NONE)
 			sprint(strchr(str, 0), "%.5lld (%L)	%A	%D,%D", p->pc, p->lineno, a, &p->from, &p->to);
 		else
-		if(a != ATEXT && p->from.type == D_OREG) {
-			sprint(strchr(str, 0), "%.5lld (%L)	%A	%lld(R%d+R%d),%D", p->pc, p->lineno, a,
+		if(a != ATEXT && p->from.type == TYPE_MEM) {
+			sprint(strchr(str, 0), "%.5lld (%L)	%A	%lld(%R+%R),%D", p->pc, p->lineno, a,
 				p->from.offset, p->from.reg, p->reg, &p->to);
 		} else
-		if(p->to.type == D_OREG) {
-			sprint(strchr(str, 0), "%.5lld (%L)	%A	%D,%lld(R%d+R%d)", p->pc, p->lineno, a,
+		if(p->to.type == TYPE_MEM) {
+			sprint(strchr(str, 0), "%.5lld (%L)	%A	%D,%lld(%R+%R)", p->pc, p->lineno, a,
 					&p->from, p->to.offset, p->to.reg, p->reg);
 		} else {
 			sprint(strchr(str, 0), "%.5lld (%L)	%A	%D", p->pc, p->lineno, a, &p->from);
-			if(p->reg != NREG) {
-				ch = 'R';
-				if(p->from.type == D_FREG)
-					ch = 'F';
-				sprint(strchr(str, 0), ",%c%d", ch, p->reg);
-			}
-			if(p->from3.type != D_NONE)
+			if(p->reg != 0)
+				sprint(strchr(str, 0), ",%R", p->reg);
+			if(p->from3.type != TYPE_NONE)
 				sprint(strchr(str, 0), ",%D", &p->from3);
 			sprint(strchr(str, 0), ",%D", &p->to);
 		}
@@ -159,7 +155,7 @@ Dconv(Fmt *fp)
 	a = va_arg(fp->args, Addr*);
 
 	if(fp->flags & FmtLong) {
-		if(a->type == D_CONST)
+		if(a->type == TYPE_CONST)
 			sprint(str, "$%d-%d", (int32)a->offset, (int32)(a->offset>>32));
 		else {
 			// ATEXT dst is not constant
@@ -173,89 +169,33 @@ Dconv(Fmt *fp)
 		sprint(str, "GOK-type(%d)", a->type);
 		break;
 
-	case D_NONE:
+	case TYPE_NONE:
 		str[0] = 0;
-		if(a->name != D_NONE || a->reg != NREG || a->sym != nil)
-			sprint(str, "%M(R%d)(NONE)", a, a->reg);
+		if(a->name != TYPE_NONE || a->reg != 0 || a->sym != nil)
+			sprint(str, "%M(%R)(NONE)", a, a->reg);
 		break;
 
-	case D_CONST:
-	case D_DCONST:
-		if(a->reg != NREG)
-			sprint(str, "$%M(R%d)", a, a->reg);
+	case TYPE_CONST:
+		if(a->reg != 0)
+			sprint(str, "$%M(%R)", a, a->reg);
 		else
 			sprint(str, "$%M", a);
 		break;
 
-	case D_OREG:
-		if(a->reg != NREG)
-			sprint(str, "%M(R%d)", a, a->reg);
+	case TYPE_MEM:
+		if(a->reg != 0)
+			sprint(str, "%M(%R)", a, a->reg);
 		else
 			sprint(str, "%M", a);
 		break;
 
-	case D_REG:
-		sprint(str, "R%d", a->reg);
-		if(a->name != D_NONE || a->sym != nil)
-			sprint(str, "%M(R%d)(REG)", a, a->reg);
-		break;
-
-	case D_FREG:
-		sprint(str, "F%d", a->reg);
-		if(a->name != D_NONE || a->sym != nil)
-			sprint(str, "%M(F%d)(REG)", a, a->reg);
-		break;
-
-	case D_CREG:
-		if(a->reg == NREG)
-			strcpy(str, "CR");
-		else
-			sprint(str, "CR%d", a->reg);
-		if(a->name != D_NONE || a->sym != nil)
-			sprint(str, "%M(C%d)(REG)", a, a->reg);
-		break;
-
-	case D_SPR:
-		if(a->name == D_NONE && a->sym == nil) {
-			switch((ulong)a->offset) {
-			case D_XER: sprint(str, "XER"); break;
-			case D_LR: sprint(str, "LR"); break;
-			case D_CTR: sprint(str, "CTR"); break;
-			default: sprint(str, "SPR(%lld)", a->offset); break;
-			}
-			break;
-		}
-		sprint(str, "SPR-GOK(%d)", a->reg);
-		if(a->name != D_NONE || a->sym != nil)
-			sprint(str, "%M(SPR-GOK%d)(REG)", a, a->reg);
-		break;
-
-	case D_DCR:
-		if(a->name == D_NONE && a->sym == nil) {
-			sprint(str, "DCR(%lld)", a->offset);
-			break;
-		}
-		sprint(str, "DCR-GOK(%d)", a->reg);
-		if(a->name != D_NONE || a->sym != nil)
-			sprint(str, "%M(DCR-GOK%d)(REG)", a, a->reg);
+	case TYPE_REG:
+		sprint(str, "%R", a->reg);
+		if(a->name != TYPE_NONE || a->sym != nil)
+			sprint(str, "%M(%R)(REG)", a, a->reg);
 		break;
 
-	case D_OPT:
-		sprint(str, "OPT(%d)", a->reg);
-		break;
-
-	case D_FPSCR:
-		if(a->reg == NREG)
-			strcpy(str, "FPSCR");
-		else
-			sprint(str, "FPSCR(%d)", a->reg);
-		break;
-
-	case D_MSR:
-		sprint(str, "MSR");
-		break;
-
-	case D_BRANCH:
+	case TYPE_BRANCH:
 		if(bigP->pcond != nil) {
 			v = bigP->pcond->pc;
 			//if(v >= INITTEXT)
@@ -272,12 +212,12 @@ Dconv(Fmt *fp)
 			sprint(str, "%lld(APC)", a->offset);
 		break;
 
-	case D_FCONST:
+	case TYPE_FCONST:
 		//sprint(str, "$%lux-%lux", a->ieee.h, a->ieee.l);
 		sprint(str, "$%.17g", a->u.dval);
 		break;
 
-	case D_SCONST:
+	case TYPE_SCONST:
 		sprint(str, "$\"%$\"", a->u.sval);
 		break;
 	}
@@ -309,7 +249,7 @@ Mconv(Fmt *fp)
 		sprint(str, "GOK-name(%d)", a->name);
 		break;
 
-	case D_NONE:
+	case TYPE_NONE:
 		l = a->offset;
 		if((vlong)l != a->offset)
 			sprint(str, "0x%llux", a->offset);
@@ -317,25 +257,25 @@ Mconv(Fmt *fp)
 			sprint(str, "%lld", a->offset);
 		break;
 
-	case D_EXTERN:
+	case NAME_EXTERN:
 		if(a->offset != 0)
 			sprint(str, "%s+%lld(SB)", s->name, a->offset);
 		else
 			sprint(str, "%s(SB)", s->name);
 		break;
 
-	case D_STATIC:
+	case NAME_STATIC:
 		sprint(str, "%s<>+%lld(SB)", s->name, a->offset);
 		break;
 
-	case D_AUTO:
+	case NAME_AUTO:
 		if(s == nil)
 			sprint(str, "%lld(SP)", -a->offset);
 		else
 			sprint(str, "%s-%lld(SP)", s->name, -a->offset);
 		break;
 
-	case D_PARAM:
+	case NAME_PARAM:
 		if(s == nil)
 			sprint(str, "%lld(FP)", a->offset);
 		else
@@ -349,15 +289,38 @@ Mconv(Fmt *fp)
 static int
 Rconv(Fmt *fp)
 {
-	char str[STRINGSZ];
 	int r;
 
 	r = va_arg(fp->args, int);
-	if(r < NREG)
-		sprint(str, "r%d", r);
-	else
-		sprint(str, "f%d", r-NREG);
-	return fmtstrcpy(fp, str);
+	if(r == 0)
+		return fmtstrcpy(fp, "NONE");
+	if(REG_R0 <= r && r <= REG_R31)
+		return fmtprint(fp, "R%d", r-REG_R0);
+	if(REG_F0 <= r && r <= REG_F31)
+		return fmtprint(fp, "F%d", r-REG_F0);
+	if(REG_C0 <= r && r <= REG_C7)
+		return fmtprint(fp, "C%d", r-REG_C0);
+	if(r == REG_CR)
+		return fmtstrcpy(fp, "CR");
+	if(REG_SPR0 <= r && r <= REG_SPR0+1023) {
+		switch(r) {
+		case REG_XER:
+			return fmtstrcpy(fp, "XER");
+		case REG_LR:
+			return fmtstrcpy(fp, "LR");
+		case REG_CTR:
+			return fmtstrcpy(fp, "CTR");
+		}
+		return fmtprint(fp, "SPR(%d)", r-REG_SPR0);
+	}
+	if(REG_DCR0 <= r && r <= REG_DCR0+1023)
+		return fmtprint(fp, "DCR(%d)", r-REG_DCR0);
+	if(r == REG_FPSCR)
+		return fmtstrcpy(fp, "FPSCR");
+	if(r == REG_MSR)
+		return fmtstrcpy(fp, "MSR");
+
+	return fmtprint(fp, "badreg(%d)", r);
 }
 
 static int
diff --git a/src/liblink/obj9.c b/src/liblink/obj9.c
index 5ac575593d..93c63722f8 100644
--- a/src/liblink/obj9.c
+++ b/src/liblink/obj9.c
@@ -37,30 +37,8 @@
 
 static Prog zprg = {
 	.as = AGOK,
-	.reg = NREG,
-	.from = {
-		.name = D_NONE,
-		.type = D_NONE,
-		.reg = NREG,
-	},
-	.from3 = {
-		.name = D_NONE,
-		.type = D_NONE,
-		.reg = NREG,
-	},
-	.to = {
-		.name = D_NONE,
-		.type = D_NONE,
-		.reg = NREG,
-	},
 };
 
-static int
-symtype(Addr *a)
-{
-	return a->name;
-}
-
 static int
 isdata(Prog *p)
 {
@@ -102,7 +80,7 @@ progedit(Link *ctxt, Prog *p)
 	p->from.class = 0;
 	p->to.class = 0;
 
-	// Rewrite BR/BL to symbol as D_BRANCH.
+	// Rewrite BR/BL to symbol as TYPE_BRANCH.
 	switch(p->as) {
 	case ABR:
 	case ABL:
@@ -110,14 +88,14 @@ progedit(Link *ctxt, Prog *p)
 	case ADUFFZERO:
 	case ADUFFCOPY:
 		if(p->to.sym != nil)
-			p->to.type = D_BRANCH;
+			p->to.type = TYPE_BRANCH;
 		break;
 	}
 
 	// Rewrite float constants to values stored in memory.
 	switch(p->as) {
 	case AFMOVS:
-		if(p->from.type == D_FCONST) {
+		if(p->from.type == TYPE_FCONST) {
 			uint32 i32;
 			float32 f32;
 			f32 = p->from.u.dval;
@@ -125,34 +103,34 @@ progedit(Link *ctxt, Prog *p)
 			sprint(literal, "$f32.%08ux", i32);
 			s = linklookup(ctxt, literal, 0);
 			s->size = 4;
-			p->from.type = D_OREG;
+			p->from.type = TYPE_MEM;
 			p->from.sym = s;
-			p->from.name = D_EXTERN;
+			p->from.name = NAME_EXTERN;
 			p->from.offset = 0;
 		}
 		break;
 	case AFMOVD:
-		if(p->from.type == D_FCONST) {
+		if(p->from.type == TYPE_FCONST) {
 			uint64 i64;
 			memmove(&i64, &p->from.u.dval, 8);
 			sprint(literal, "$f64.%016llux", i64);
 			s = linklookup(ctxt, literal, 0);
 			s->size = 8;
-			p->from.type = D_OREG;
+			p->from.type = TYPE_MEM;
 			p->from.sym = s;
-			p->from.name = D_EXTERN;
+			p->from.name = NAME_EXTERN;
 			p->from.offset = 0;
 		}
 		break;
 	case AMOVD:
 		// Put >32-bit constants in memory and load them
-		if(p->from.type == D_CONST && p->from.name == D_NONE && p->from.reg == NREG && (int32)p->from.offset != p->from.offset) {
+		if(p->from.type == TYPE_CONST && p->from.name == NAME_NONE && p->from.reg == 0 && (int32)p->from.offset != p->from.offset) {
 			sprint(literal, "$i64.%016llux", (uvlong)p->from.offset);
 			s = linklookup(ctxt, literal, 0);
 			s->size = 8;
-			p->from.type = D_OREG;
+			p->from.type = TYPE_MEM;
 			p->from.sym = s;
-			p->from.name = D_EXTERN;
+			p->from.name = NAME_EXTERN;
 			p->from.offset = 0;
 		}
 	}
@@ -160,21 +138,21 @@ progedit(Link *ctxt, Prog *p)
 	// Rewrite SUB constants into ADD.
 	switch(p->as) {
 	case ASUBC:
-		if(p->from.type == D_CONST) {
+		if(p->from.type == TYPE_CONST) {
 			p->from.offset = -p->from.offset;
 			p->as = AADDC;
 		}
 		break;
 
 	case ASUBCCC:
-		if(p->from.type == D_CONST) {
+		if(p->from.type == TYPE_CONST) {
 			p->from.offset = -p->from.offset;
 			p->as = AADDCCC;
 		}
 		break;
 
 	case ASUB:
-		if(p->from.type == D_CONST) {
+		if(p->from.type == TYPE_CONST) {
 			p->from.offset = -p->from.offset;
 			p->as = AADD;
 		}
@@ -198,7 +176,7 @@ parsetextconst(vlong arg, vlong *textstksiz, vlong *textarg)
 }
 
 static void
-addstacksplit(Link *ctxt, LSym *cursym)
+preprocess(Link *ctxt, LSym *cursym)
 {
 	Prog *p, *q, *p1, *p2, *q1;
 	int o, mov, aoffset;
@@ -246,7 +224,7 @@ addstacksplit(Link *ctxt, LSym *cursym)
 
 		case ANOR:
 			q = p;
-			if(p->to.type == D_REG)
+			if(p->to.type == TYPE_REG)
 				if(p->to.reg == REGZERO)
 					p->mark |= LABEL|SYNC;
 			break;
@@ -288,22 +266,8 @@ addstacksplit(Link *ctxt, LSym *cursym)
 		case AMOVWZ:
 		case AMOVD:
 			q = p;
-			switch(p->from.type) {
-			case D_MSR:
-			case D_SPR:
-			case D_FPSCR:
-			case D_CREG:
-			case D_DCR:
+			if(p->from.reg >= REG_SPECIAL || p->to.reg >= REG_SPECIAL)
 				p->mark |= LABEL|SYNC;
-			}
-			switch(p->to.type) {
-			case D_MSR:
-			case D_SPR:
-			case D_FPSCR:
-			case D_CREG:
-			case D_DCR:
-				p->mark |= LABEL|SYNC;
-			}
 			continue;
 
 		case AFABS:
@@ -429,9 +393,9 @@ addstacksplit(Link *ctxt, LSym *cursym)
 					q = appendp(ctxt, p);
 					q->as = AADD;
 					q->lineno = p->lineno;
-					q->from.type = D_CONST;
+					q->from.type = TYPE_CONST;
 					q->from.offset = -autosize;
-					q->to.type = D_REG;
+					q->to.type = TYPE_REG;
 					q->to.reg = REGSP;
 					q->spadj = +autosize;
 				}
@@ -453,17 +417,17 @@ addstacksplit(Link *ctxt, LSym *cursym)
 			q = appendp(ctxt, q);
 			q->as = AMOVD;
 			q->lineno = p->lineno;
-			q->from.type = D_SPR;
-			q->from.offset = D_LR;
-			q->to.type = D_REG;
+			q->from.type = TYPE_REG;
+			q->from.reg = REG_LR;
+			q->to.type = TYPE_REG;
 			q->to.reg = REGTMP;
 
 			q = appendp(ctxt, q);
 			q->as = mov;
 			q->lineno = p->lineno;
-			q->from.type = D_REG;
+			q->from.type = TYPE_REG;
 			q->from.reg = REGTMP;
-			q->to.type = D_OREG;
+			q->to.type = TYPE_MEM;
 			q->to.offset = aoffset;
 			q->to.reg = REGSP;
 			if(q->as == AMOVDU)
@@ -490,66 +454,66 @@ addstacksplit(Link *ctxt, LSym *cursym)
 
 				q = appendp(ctxt, q);
 				q->as = AMOVD;
-				q->from.type = D_OREG;
+				q->from.type = TYPE_MEM;
 				q->from.reg = REGG;
 				q->from.offset = 4*ctxt->arch->ptrsize; // G.panic
-				q->to.type = D_REG;
-				q->to.reg = 3;
+				q->to.type = TYPE_REG;
+				q->to.reg = REG_R3;
 
 				q = appendp(ctxt, q);
 				q->as = ACMP;
-				q->from.type = D_REG;
-				q->from.reg = 0;
-				q->to.type = D_REG;
-				q->to.reg = 3;
+				q->from.type = TYPE_REG;
+				q->from.reg = REG_R0;
+				q->to.type = TYPE_REG;
+				q->to.reg = REG_R3;
 
 				q = appendp(ctxt, q);
 				q->as = ABEQ;
-				q->to.type = D_BRANCH;
+				q->to.type = TYPE_BRANCH;
 				p1 = q;
 
 				q = appendp(ctxt, q);
 				q->as = AMOVD;
-				q->from.type = D_OREG;
-				q->from.reg = 3;
+				q->from.type = TYPE_MEM;
+				q->from.reg = REG_R3;
 				q->from.offset = 0; // Panic.argp
-				q->to.type = D_REG;
-				q->to.reg = 4;
+				q->to.type = TYPE_REG;
+				q->to.reg = REG_R4;
 
 				q = appendp(ctxt, q);
 				q->as = AADD;
-				q->from.type = D_CONST;
+				q->from.type = TYPE_CONST;
 				q->from.offset = autosize+8;
 				q->reg = REGSP;
-				q->to.type = D_REG;
-				q->to.reg = 5;
+				q->to.type = TYPE_REG;
+				q->to.reg = REG_R5;
 
 				q = appendp(ctxt, q);
 				q->as = ACMP;
-				q->from.type = D_REG;
-				q->from.reg = 4;
-				q->to.type = D_REG;
-				q->to.reg = 5;
+				q->from.type = TYPE_REG;
+				q->from.reg = REG_R4;
+				q->to.type = TYPE_REG;
+				q->to.reg = REG_R5;
 
 				q = appendp(ctxt, q);
 				q->as = ABNE;
-				q->to.type = D_BRANCH;
+				q->to.type = TYPE_BRANCH;
 				p2 = q;
 
 				q = appendp(ctxt, q);
 				q->as = AADD;
-				q->from.type = D_CONST;
+				q->from.type = TYPE_CONST;
 				q->from.offset = 8;
 				q->reg = REGSP;
-				q->to.type = D_REG;
-				q->to.reg = 6;
+				q->to.type = TYPE_REG;
+				q->to.reg = REG_R6;
 
 				q = appendp(ctxt, q);
 				q->as = AMOVD;
-				q->from.type = D_REG;
-				q->from.reg = 6;
-				q->to.type = D_OREG;
-				q->to.reg = 3;
+				q->from.type = TYPE_REG;
+				q->from.reg = REG_R6;
+				q->to.type = TYPE_MEM;
+				q->to.reg = REG_R3;
 				q->to.offset = 0; // Panic.argp
 
 				q = appendp(ctxt, q);
@@ -561,37 +525,37 @@ addstacksplit(Link *ctxt, LSym *cursym)
 			break;
 
 		case ARETURN:
-			if(p->from.type == D_CONST) {
+			if(p->from.type == TYPE_CONST) {
 				ctxt->diag("using BECOME (%P) is not supported!", p);
 				break;
 			}
 			if(p->to.sym) { // retjmp
 				p->as = ABR;
-				p->to.type = D_BRANCH;
+				p->to.type = TYPE_BRANCH;
 				break;
 			}
 			if(cursym->text->mark & LEAF) {
 				if(!autosize) {
 					p->as = ABR;
 					p->from = zprg.from;
-					p->to.type = D_SPR;
-					p->to.offset = D_LR;
+					p->to.type = TYPE_REG;
+					p->to.reg = REG_LR;
 					p->mark |= BRANCH;
 					break;
 				}
 
 				p->as = AADD;
-				p->from.type = D_CONST;
+				p->from.type = TYPE_CONST;
 				p->from.offset = autosize;
-				p->to.type = D_REG;
+				p->to.type = TYPE_REG;
 				p->to.reg = REGSP;
 				p->spadj = -autosize;
 
 				q = ctxt->arch->prg();
 				q->as = ABR;
 				q->lineno = p->lineno;
-				q->to.type = D_SPR;
-				q->to.offset = D_LR;
+				q->to.type = TYPE_REG;
+				q->to.reg = REG_LR;
 				q->mark |= BRANCH;
 				q->spadj = +autosize;
 
@@ -601,19 +565,19 @@ addstacksplit(Link *ctxt, LSym *cursym)
 			}
 
 			p->as = AMOVD;
-			p->from.type = D_OREG;
+			p->from.type = TYPE_MEM;
 			p->from.offset = 0;
 			p->from.reg = REGSP;
-			p->to.type = D_REG;
+			p->to.type = TYPE_REG;
 			p->to.reg = REGTMP;
 
 			q = ctxt->arch->prg();
 			q->as = AMOVD;
 			q->lineno = p->lineno;
-			q->from.type = D_REG;
+			q->from.type = TYPE_REG;
 			q->from.reg = REGTMP;
-			q->to.type = D_SPR;
-			q->to.offset = D_LR;
+			q->to.type = TYPE_REG;
+			q->to.reg = REG_LR;
 
 			q->link = p->link;
 			p->link = q;
@@ -624,10 +588,10 @@ addstacksplit(Link *ctxt, LSym *cursym)
 				q = ctxt->arch->prg();
 				q->as = AMOVD;
 				q->lineno = p->lineno;
-				q->from.type = D_OREG;
+				q->from.type = TYPE_MEM;
 				q->from.offset = 0;
 				q->from.reg = REGTMP;
-				q->to.type = D_REG;
+				q->to.type = TYPE_REG;
 				q->to.reg = REGTMP;
 
 				q->link = p->link;
@@ -639,9 +603,9 @@ addstacksplit(Link *ctxt, LSym *cursym)
 				q = ctxt->arch->prg();
 				q->as = AADD;
 				q->lineno = p->lineno;
-				q->from.type = D_CONST;
+				q->from.type = TYPE_CONST;
 				q->from.offset = autosize;
-				q->to.type = D_REG;
+				q->to.type = TYPE_REG;
 				q->to.reg = REGSP;
 				q->spadj = -autosize;
 
@@ -652,8 +616,8 @@ addstacksplit(Link *ctxt, LSym *cursym)
 			q1 = ctxt->arch->prg();
 			q1->as = ABR;
 			q1->lineno = p->lineno;
-			q1->to.type = D_SPR;
-			q1->to.offset = D_LR;
+			q1->to.type = TYPE_REG;
+			q1->to.reg = REG_LR;
 			q1->mark |= BRANCH;
 			q1->spadj = +autosize;
 
@@ -662,7 +626,7 @@ addstacksplit(Link *ctxt, LSym *cursym)
 			break;
 
 		case AADD:
-			if(p->to.type == D_REG && p->to.reg == REGSP && p->from.type == D_CONST)
+			if(p->to.type == TYPE_REG && p->to.reg == REGSP && p->from.type == TYPE_CONST)
 				p->spadj = -p->from.offset;
 			break;
 		}
@@ -723,13 +687,13 @@ stacksplit(Link *ctxt, Prog *p, int32 framesize, int noctxt)
 	// MOVD	g_stackguard(g), R3
 	p = appendp(ctxt, p);
 	p->as = AMOVD;
-	p->from.type = D_OREG;
+	p->from.type = TYPE_MEM;
 	p->from.reg = REGG;
 	p->from.offset = 2*ctxt->arch->ptrsize;	// G.stackguard0
 	if(ctxt->cursym->cfunc)
 		p->from.offset = 3*ctxt->arch->ptrsize;	// G.stackguard1
-	p->to.type = D_REG;
-	p->to.reg = 3;
+	p->to.type = TYPE_REG;
+	p->to.reg = REG_R3;
 
 	q = nil;
 	if(framesize <= StackSmall) {
@@ -737,9 +701,9 @@ stacksplit(Link *ctxt, Prog *p, int32 framesize, int noctxt)
 		//	CMP	stackguard, SP
 		p = appendp(ctxt, p);
 		p->as = ACMPU;
-		p->from.type = D_REG;
-		p->from.reg = 3;
-		p->to.type = D_REG;
+		p->from.type = TYPE_REG;
+		p->from.reg = REG_R3;
+		p->to.type = TYPE_REG;
 		p->to.reg = REGSP;
 	} else if(framesize <= StackBig) {
 		// large stack: SP-framesize < stackguard-StackSmall
@@ -747,18 +711,18 @@ stacksplit(Link *ctxt, Prog *p, int32 framesize, int noctxt)
 		//	CMP stackguard, R4
 		p = appendp(ctxt, p);
 		p->as = AADD;
-		p->from.type = D_CONST;
+		p->from.type = TYPE_CONST;
 		p->from.offset = -framesize;
 		p->reg = REGSP;
-		p->to.type = D_REG;
-		p->to.reg = 4;
+		p->to.type = TYPE_REG;
+		p->to.reg = REG_R4;
 
 		p = appendp(ctxt, p);
 		p->as = ACMPU;
-		p->from.type = D_REG;
-		p->from.reg = 3;
-		p->to.type = D_REG;
-		p->to.reg = 4;
+		p->from.type = TYPE_REG;
+		p->from.reg = REG_R3;
+		p->to.type = TYPE_REG;
+		p->to.reg = REG_R4;
 	} else {
 		// Such a large stack we need to protect against wraparound.
 		// If SP is close to zero:
@@ -777,64 +741,64 @@ stacksplit(Link *ctxt, Prog *p, int32 framesize, int noctxt)
 		//	CMPU	R31, R4
 		p = appendp(ctxt, p);
 		p->as = ACMP;
-		p->from.type = D_REG;
-		p->from.reg = 3;
-		p->to.type = D_CONST;
+		p->from.type = TYPE_REG;
+		p->from.reg = REG_R3;
+		p->to.type = TYPE_CONST;
 		p->to.offset = StackPreempt;
 
 		q = p = appendp(ctxt, p);
 		p->as = ABEQ;
-		p->to.type = D_BRANCH;
+		p->to.type = TYPE_BRANCH;
 
 		p = appendp(ctxt, p);
 		p->as = AADD;
-		p->from.type = D_CONST;
+		p->from.type = TYPE_CONST;
 		p->from.offset = StackGuard;
 		p->reg = REGSP;
-		p->to.type = D_REG;
-		p->to.reg = 4;
+		p->to.type = TYPE_REG;
+		p->to.reg = REG_R4;
 
 		p = appendp(ctxt, p);
 		p->as = ASUB;
-		p->from.type = D_REG;
-		p->from.reg = 3;
-		p->to.type = D_REG;
-		p->to.reg = 4;
+		p->from.type = TYPE_REG;
+		p->from.reg = REG_R3;
+		p->to.type = TYPE_REG;
+		p->to.reg = REG_R4;
 
 		p = appendp(ctxt, p);
 		p->as = AMOVD;
-		p->from.type = D_CONST;
+		p->from.type = TYPE_CONST;
 		p->from.offset = framesize + StackGuard - StackSmall;
-		p->to.type = D_REG;
+		p->to.type = TYPE_REG;
 		p->to.reg = REGTMP;
 
 		p = appendp(ctxt, p);
 		p->as = ACMPU;
-		p->from.type = D_REG;
+		p->from.type = TYPE_REG;
 		p->from.reg = REGTMP;
-		p->to.type = D_REG;
-		p->to.reg = 4;
+		p->to.type = TYPE_REG;
+		p->to.reg = REG_R4;
 	}
 
 	// q1: BLT	done
 	q1 = p = appendp(ctxt, p);
 	p->as = ABLT;
-	p->to.type = D_BRANCH;
+	p->to.type = TYPE_BRANCH;
 
 	// MOVD	LR, R5
 	p = appendp(ctxt, p);
 	p->as = AMOVD;
-	p->from.type = D_SPR;
-	p->from.offset = D_LR;
-	p->to.type = D_REG;
-	p->to.reg = 5;
+	p->from.type = TYPE_REG;
+	p->from.reg = REG_LR;
+	p->to.type = TYPE_REG;
+	p->to.reg = REG_R5;
 	if(q)
 		q->pcond = p;
 
 	// BL	runtime.morestack(SB)
 	p = appendp(ctxt, p);
 	p->as = ABL;
-	p->to.type = D_BRANCH;
+	p->to.type = TYPE_BRANCH;
 	if(ctxt->cursym->cfunc)
 		p->to.sym = linklookup(ctxt, "runtime.morestackc", 0);
 	else
@@ -843,7 +807,7 @@ stacksplit(Link *ctxt, Prog *p, int32 framesize, int noctxt)
 	// BR	start
 	p = appendp(ctxt, p);
 	p->as = ABR;
-	p->to.type = D_BRANCH;
+	p->to.type = TYPE_BRANCH;
 	p->pcond = ctxt->cursym->text->link;
 
 	// placeholder for q1's jump target
@@ -969,7 +933,7 @@ loop:
 		q = ctxt->arch->prg();
 		q->as = a;
 		q->lineno = p->lineno;
-		q->to.type = D_BRANCH;
+		q->to.type = TYPE_BRANCH;
 		q->to.offset = p->pc;
 		q->pcond = p;
 		p = q;
@@ -1011,7 +975,7 @@ LinkArch linkppc64 = {
 	.thechar = '9',
 	.endian = BigEndian,
 
-	.addstacksplit = addstacksplit,
+	.preprocess = preprocess,
 	.assemble = span9,
 	.datasize = datasize,
 	.follow = follow,
@@ -1020,25 +984,12 @@ LinkArch linkppc64 = {
 	.prg = prg,
 	.progedit = progedit,
 	.settextflag = settextflag,
-	.symtype = symtype,
 	.textflag = textflag,
 
 	.minlc = 4,
 	.ptrsize = 8,
 	.regsize = 8,
 
-	.D_ADDR = D_ADDR,
-	.D_AUTO = D_AUTO,
-	.D_BRANCH = D_BRANCH,
-	.D_CONST = D_CONST,
-	.D_EXTERN = D_EXTERN,
-	.D_FCONST = D_FCONST,
-	.D_NONE = D_NONE,
-	.D_PARAM = D_PARAM,
-	.D_SCONST = D_SCONST,
-	.D_STATIC = D_STATIC,
-	.D_OREG = D_OREG,
-
 	.ACALL = ABL,
 	.ADATA = ADATA,
 	.AEND = AEND,
@@ -1058,7 +1009,7 @@ LinkArch linkppc64le = {
 	.thechar = '9',
 	.endian = LittleEndian,
 
-	.addstacksplit = addstacksplit,
+	.preprocess = preprocess,
 	.assemble = span9,
 	.datasize = datasize,
 	.follow = follow,
@@ -1067,25 +1018,12 @@ LinkArch linkppc64le = {
 	.prg = prg,
 	.progedit = progedit,
 	.settextflag = settextflag,
-	.symtype = symtype,
 	.textflag = textflag,
 
 	.minlc = 4,
 	.ptrsize = 8,
 	.regsize = 8,
 
-	.D_ADDR = D_ADDR,
-	.D_AUTO = D_AUTO,
-	.D_BRANCH = D_BRANCH,
-	.D_CONST = D_CONST,
-	.D_EXTERN = D_EXTERN,
-	.D_FCONST = D_FCONST,
-	.D_NONE = D_NONE,
-	.D_PARAM = D_PARAM,
-	.D_SCONST = D_SCONST,
-	.D_STATIC = D_STATIC,
-	.D_OREG = D_OREG,
-
 	.ACALL = ABL,
 	.ADATA = ADATA,
 	.AEND = AEND,
