commit d7012ca282092e876c3f12b758e12d6eabc8cc3c
Author: Dave Cheney <dave@cheney.net>
Date:   Thu Sep 15 15:45:10 2016 +1000

    cmd/compile/internal/gc: unexport more helper functions
    
    After the removal of the old backend many types are no longer referenced
    outside internal/gc. Make these functions private so that tools like
    honnef.co/go/unused can spot when they become dead code. In doing so
    this CL identified several previously public helpers which are no longer
    used, so removes them.
    
    This should be the last of the public functions.
    
    Change-Id: I7e9c4e72f86f391b428b9dddb6f0d516529706c3
    Reviewed-on: https://go-review.googlesource.com/29134
    Run-TryBot: Dave Cheney <dave@cheney.net>
    TryBot-Result: Gobot Gobot <gobot@golang.org>
    Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org>
---
 src/cmd/compile/internal/gc/alg.go       |  32 +--
 src/cmd/compile/internal/gc/align.go     |  14 +-
 src/cmd/compile/internal/gc/bimport.go   |  10 +-
 src/cmd/compile/internal/gc/closure.go   |  26 +--
 src/cmd/compile/internal/gc/const.go     |  43 ++--
 src/cmd/compile/internal/gc/dcl.go       |  66 +++---
 src/cmd/compile/internal/gc/esc.go       |  12 +-
 src/cmd/compile/internal/gc/export.go    |   8 +-
 src/cmd/compile/internal/gc/fmt.go       |  10 +-
 src/cmd/compile/internal/gc/gen.go       |  10 +-
 src/cmd/compile/internal/gc/gsubr.go     |  12 +-
 src/cmd/compile/internal/gc/init.go      |  10 +-
 src/cmd/compile/internal/gc/inl.go       |   8 +-
 src/cmd/compile/internal/gc/lex.go       |  70 +++---
 src/cmd/compile/internal/gc/main.go      |  38 ++--
 src/cmd/compile/internal/gc/mpfloat.go   |   8 +-
 src/cmd/compile/internal/gc/mpint.go     |  44 ++--
 src/cmd/compile/internal/gc/noder.go     |  26 +--
 src/cmd/compile/internal/gc/obj.go       |   2 +-
 src/cmd/compile/internal/gc/order.go     |   8 +-
 src/cmd/compile/internal/gc/parser.go    |  66 +++---
 src/cmd/compile/internal/gc/pgen.go      |  10 +-
 src/cmd/compile/internal/gc/plive.go     |   6 +-
 src/cmd/compile/internal/gc/racewalk.go  |  10 +-
 src/cmd/compile/internal/gc/range.go     |  24 +--
 src/cmd/compile/internal/gc/reflect.go   |  46 ++--
 src/cmd/compile/internal/gc/select.go    |  40 ++--
 src/cmd/compile/internal/gc/sinit.go     |  10 +-
 src/cmd/compile/internal/gc/ssa.go       |  96 ++++-----
 src/cmd/compile/internal/gc/subr.go      | 126 +++++------
 src/cmd/compile/internal/gc/swt.go       |  50 ++---
 src/cmd/compile/internal/gc/type.go      |  14 +-
 src/cmd/compile/internal/gc/typecheck.go | 352 +++++++++++++++----------------
 src/cmd/compile/internal/gc/universe.go  |  18 +-
 src/cmd/compile/internal/gc/unsafe.go    |  10 +-
 src/cmd/compile/internal/gc/util.go      |   6 +-
 src/cmd/compile/internal/gc/walk.go      |  92 ++++----
 37 files changed, 713 insertions(+), 720 deletions(-)

diff --git a/src/cmd/compile/internal/gc/alg.go b/src/cmd/compile/internal/gc/alg.go
index 4ee9ff1c9c..8ae01f0ced 100644
--- a/src/cmd/compile/internal/gc/alg.go
+++ b/src/cmd/compile/internal/gc/alg.go
@@ -198,10 +198,10 @@ func genhash(sym *Sym, t *Type) {
 	tfn := Nod(OTFUNC, nil, nil)
 	fn.Func.Nname.Name.Param.Ntype = tfn
 
-	n := Nod(ODCLFIELD, newname(Lookup("p")), typenod(Ptrto(t)))
+	n := Nod(ODCLFIELD, newname(lookup("p")), typenod(ptrto(t)))
 	tfn.List.Append(n)
 	np := n.Left
-	n = Nod(ODCLFIELD, newname(Lookup("h")), typenod(Types[TUINTPTR]))
+	n = Nod(ODCLFIELD, newname(lookup("h")), typenod(Types[TUINTPTR]))
 	tfn.List.Append(n)
 	nh := n.Left
 	n = Nod(ODCLFIELD, nil, typenod(Types[TUINTPTR])) // return value
@@ -224,7 +224,7 @@ func genhash(sym *Sym, t *Type) {
 		hashel := hashfor(t.Elem())
 
 		n := Nod(ORANGE, nil, Nod(OIND, np, nil))
-		ni := newname(Lookup("i"))
+		ni := newname(lookup("i"))
 		ni.Type = Types[TINT]
 		n.List.Set1(ni)
 		n.Colas = true
@@ -260,7 +260,7 @@ func genhash(sym *Sym, t *Type) {
 			if !f.Type.IsRegularMemory() {
 				hashel := hashfor(f.Type)
 				call := Nod(OCALL, hashel, nil)
-				nx := NodSym(OXDOT, np, f.Sym) // TODO: fields from other packages?
+				nx := nodSym(OXDOT, np, f.Sym) // TODO: fields from other packages?
 				na := Nod(OADDR, nx, nil)
 				na.Etype = 1 // no escape to heap
 				call.List.Append(na)
@@ -276,7 +276,7 @@ func genhash(sym *Sym, t *Type) {
 			// h = hashel(&p.first, size, h)
 			hashel := hashmem(f.Type)
 			call := Nod(OCALL, hashel, nil)
-			nx := NodSym(OXDOT, np, f.Sym) // TODO: fields from other packages?
+			nx := nodSym(OXDOT, np, f.Sym) // TODO: fields from other packages?
 			na := Nod(OADDR, nx, nil)
 			na.Etype = 1 // no escape to heap
 			call.List.Append(na)
@@ -347,7 +347,7 @@ func hashfor(t *Type) *Node {
 	n := newname(sym)
 	n.Class = PFUNC
 	tfn := Nod(OTFUNC, nil, nil)
-	tfn.List.Append(Nod(ODCLFIELD, nil, typenod(Ptrto(t))))
+	tfn.List.Append(Nod(ODCLFIELD, nil, typenod(ptrto(t))))
 	tfn.List.Append(Nod(ODCLFIELD, nil, typenod(Types[TUINTPTR])))
 	tfn.Rlist.Append(Nod(ODCLFIELD, nil, typenod(Types[TUINTPTR])))
 	tfn = typecheck(tfn, Etype)
@@ -374,10 +374,10 @@ func geneq(sym *Sym, t *Type) {
 	tfn := Nod(OTFUNC, nil, nil)
 	fn.Func.Nname.Name.Param.Ntype = tfn
 
-	n := Nod(ODCLFIELD, newname(Lookup("p")), typenod(Ptrto(t)))
+	n := Nod(ODCLFIELD, newname(lookup("p")), typenod(ptrto(t)))
 	tfn.List.Append(n)
 	np := n.Left
-	n = Nod(ODCLFIELD, newname(Lookup("q")), typenod(Ptrto(t)))
+	n = Nod(ODCLFIELD, newname(lookup("q")), typenod(ptrto(t)))
 	tfn.List.Append(n)
 	nq := n.Left
 	n = Nod(ODCLFIELD, nil, typenod(Types[TBOOL]))
@@ -401,7 +401,7 @@ func geneq(sym *Sym, t *Type) {
 		// unrolling.
 		nrange := Nod(ORANGE, nil, Nod(OIND, np, nil))
 
-		ni := newname(Lookup("i"))
+		ni := newname(lookup("i"))
 		ni.Type = Types[TINT]
 		nrange.List.Set1(ni)
 		nrange.Colas = true
@@ -418,14 +418,14 @@ func geneq(sym *Sym, t *Type) {
 		nif := Nod(OIF, nil, nil)
 		nif.Left = Nod(ONE, nx, ny)
 		r := Nod(ORETURN, nil, nil)
-		r.List.Append(Nodbool(false))
+		r.List.Append(nodbool(false))
 		nif.Nbody.Append(r)
 		nrange.Nbody.Append(nif)
 		fn.Nbody.Append(nrange)
 
 		// return true
 		ret := Nod(ORETURN, nil, nil)
-		ret.List.Append(Nodbool(true))
+		ret.List.Append(nodbool(true))
 		fn.Nbody.Append(ret)
 
 	case TSTRUCT:
@@ -474,7 +474,7 @@ func geneq(sym *Sym, t *Type) {
 		}
 
 		if cond == nil {
-			cond = Nodbool(true)
+			cond = nodbool(true)
 		}
 
 		ret := Nod(ORETURN, nil, nil)
@@ -518,8 +518,8 @@ func geneq(sym *Sym, t *Type) {
 // eqfield returns the node
 // 	p.field == q.field
 func eqfield(p *Node, q *Node, field *Sym) *Node {
-	nx := NodSym(OXDOT, p, field)
-	ny := NodSym(OXDOT, q, field)
+	nx := nodSym(OXDOT, p, field)
+	ny := nodSym(OXDOT, q, field)
 	ne := Nod(OEQ, nx, ny)
 	return ne
 }
@@ -527,9 +527,9 @@ func eqfield(p *Node, q *Node, field *Sym) *Node {
 // eqmem returns the node
 // 	memequal(&p.field, &q.field [, size])
 func eqmem(p *Node, q *Node, field *Sym, size int64) *Node {
-	nx := Nod(OADDR, NodSym(OXDOT, p, field), nil)
+	nx := Nod(OADDR, nodSym(OXDOT, p, field), nil)
 	nx.Etype = 1 // does not escape
-	ny := Nod(OADDR, NodSym(OXDOT, q, field), nil)
+	ny := Nod(OADDR, nodSym(OXDOT, q, field), nil)
 	ny.Etype = 1 // does not escape
 	nx = typecheck(nx, Erv)
 	ny = typecheck(ny, Erv)
diff --git a/src/cmd/compile/internal/gc/align.go b/src/cmd/compile/internal/gc/align.go
index d01122fbe4..173a11feb8 100644
--- a/src/cmd/compile/internal/gc/align.go
+++ b/src/cmd/compile/internal/gc/align.go
@@ -21,7 +21,7 @@ func offmod(t *Type) {
 		f.Offset = int64(o)
 		o += int32(Widthptr)
 		if int64(o) >= Thearch.MAXWIDTH {
-			Yyerror("interface too large")
+			yyerror("interface too large")
 			o = int32(Widthptr)
 		}
 	}
@@ -75,7 +75,7 @@ func widstruct(errtype *Type, t *Type, o int64, flag int) int64 {
 		}
 		o += w
 		if o >= Thearch.MAXWIDTH {
-			Yyerror("type %L too large", errtype)
+			yyerror("type %L too large", errtype)
 			o = 8 // small but nonzero
 		}
 	}
@@ -208,7 +208,7 @@ func dowidth(t *Type) {
 		t1 := t.ChanArgs()
 		dowidth(t1) // just in case
 		if t1.Elem().Width >= 1<<16 {
-			Yyerror("channel element type too large (>64kB)")
+			yyerror("channel element type too large (>64kB)")
 		}
 		t.Width = 1
 
@@ -219,7 +219,7 @@ func dowidth(t *Type) {
 
 	case TFORW: // should have been filled in
 		if !t.Broke {
-			Yyerror("invalid recursive type %v", t)
+			yyerror("invalid recursive type %v", t)
 		}
 		w = 1 // anything will do
 
@@ -243,7 +243,7 @@ func dowidth(t *Type) {
 		}
 		if t.isDDDArray() {
 			if !t.Broke {
-				Yyerror("use of [...] array outside of array literal")
+				yyerror("use of [...] array outside of array literal")
 				t.Broke = true
 			}
 			break
@@ -253,7 +253,7 @@ func dowidth(t *Type) {
 		if t.Elem().Width != 0 {
 			cap := (uint64(Thearch.MAXWIDTH) - 1) / uint64(t.Elem().Width)
 			if uint64(t.NumElem()) > cap {
-				Yyerror("type %L larger than address space", t)
+				yyerror("type %L larger than address space", t)
 			}
 		}
 		w = t.NumElem() * t.Elem().Width
@@ -295,7 +295,7 @@ func dowidth(t *Type) {
 	}
 
 	if Widthptr == 4 && w != int64(int32(w)) {
-		Yyerror("type %v too large", t)
+		yyerror("type %v too large", t)
 	}
 
 	t.Width = w
diff --git a/src/cmd/compile/internal/gc/bimport.go b/src/cmd/compile/internal/gc/bimport.go
index 8a10f2af58..07b4925c30 100644
--- a/src/cmd/compile/internal/gc/bimport.go
+++ b/src/cmd/compile/internal/gc/bimport.go
@@ -225,7 +225,7 @@ func formatErrorf(format string, args ...interface{}) {
 		Fatalf(format, args...)
 	}
 
-	Yyerror("cannot import %q due to version skew - reinstall package (%s)",
+	yyerror("cannot import %q due to version skew - reinstall package (%s)",
 		importpkg.Path, fmt.Sprintf(format, args...))
 	errorexit()
 }
@@ -287,10 +287,10 @@ func (p *importer) pkg() *Pkg {
 		pkg.Name = name
 		numImport[name]++
 	} else if pkg.Name != name {
-		Yyerror("conflicting package names %s and %s for path %q", pkg.Name, name, path)
+		yyerror("conflicting package names %s and %s for path %q", pkg.Name, name, path)
 	}
 	if myimportpath != "" && path == myimportpath {
-		Yyerror("import %q: package depends on %q (import cycle)", importpkg.Path, path)
+		yyerror("import %q: package depends on %q (import cycle)", importpkg.Path, path)
 		errorexit()
 	}
 	p.pkgList = append(p.pkgList, pkg)
@@ -405,7 +405,7 @@ func (p *importer) importtype(pt, t *Type) {
 			// Collect the types and verify identity later.
 			p.cmpList = append(p.cmpList, struct{ pt, t *Type }{pt, t})
 		} else if !eqtype(pt.Orig, t) {
-			Yyerror("inconsistent definition for type %v during import\n\t%L (in %q)\n\t%L (in %q)", pt.Sym, pt, pt.Sym.Importdef.Path, t, importpkg.Path)
+			yyerror("inconsistent definition for type %v during import\n\t%L (in %q)\n\t%L (in %q)", pt.Sym, pt, pt.Sym.Importdef.Path, t, importpkg.Path)
 		}
 	}
 
@@ -905,7 +905,7 @@ func (p *importer) node() *Node {
 
 	case OXDOT:
 		// see parser.new_dotname
-		return NodSym(OXDOT, p.expr(), p.fieldSym())
+		return nodSym(OXDOT, p.expr(), p.fieldSym())
 
 	// case ODOTTYPE, ODOTTYPE2:
 	// 	unreachable - mapped to case ODOTTYPE below by exporter
diff --git a/src/cmd/compile/internal/gc/closure.go b/src/cmd/compile/internal/gc/closure.go
index 898bdad4cd..64c99e6db4 100644
--- a/src/cmd/compile/internal/gc/closure.go
+++ b/src/cmd/compile/internal/gc/closure.go
@@ -195,7 +195,7 @@ func closurename(n *Node) *Sym {
 	default:
 		Fatalf("closurename called for %S", n)
 	}
-	n.Sym = Lookupf("%s.%s%d", outer, prefix, gen)
+	n.Sym = lookupf("%s.%s%d", outer, prefix, gen)
 	return n.Sym
 }
 
@@ -342,8 +342,8 @@ func transformclosure(xfunc *Node) {
 				// we introduce function param &v *T
 				// and v remains PAUTOHEAP with &v heapaddr
 				// (accesses will implicitly deref &v).
-				addr := newname(Lookupf("&%s", v.Sym.Name))
-				addr.Type = Ptrto(v.Type)
+				addr := newname(lookupf("&%s", v.Sym.Name))
+				addr.Type = ptrto(v.Type)
 				addr.Class = PPARAM
 				v.Name.Heapaddr = addr
 				fld.Nname = addr
@@ -382,7 +382,7 @@ func transformclosure(xfunc *Node) {
 
 			cv.Type = v.Type
 			if !v.Name.Byval {
-				cv.Type = Ptrto(v.Type)
+				cv.Type = ptrto(v.Type)
 			}
 			offset = Rnd(offset, int64(cv.Type.Align))
 			cv.Xoffset = offset
@@ -397,7 +397,7 @@ func transformclosure(xfunc *Node) {
 			} else {
 				// Declare variable holding addresses taken from closure
 				// and initialize in entry prologue.
-				addr := newname(Lookupf("&%s", v.Sym.Name))
+				addr := newname(lookupf("&%s", v.Sym.Name))
 				addr.Name.Param.Ntype = Nod(OIND, typenod(v.Type), nil)
 				addr.Class = PAUTO
 				addr.Used = true
@@ -476,7 +476,7 @@ func walkclosure(func_ *Node, init *Nodes) *Node {
 
 	typ := Nod(OTSTRUCT, nil, nil)
 
-	typ.List.Set1(Nod(ODCLFIELD, newname(Lookup(".F")), typenod(Types[TUINTPTR])))
+	typ.List.Set1(Nod(ODCLFIELD, newname(lookup(".F")), typenod(Types[TUINTPTR])))
 	for _, v := range func_.Func.Cvars.Slice() {
 		if v.Op == OXXX {
 			continue
@@ -580,7 +580,7 @@ func makepartialcall(fn *Node, t0 *Type, meth *Sym) *Node {
 	xfunc := Nod(ODCLFUNC, nil, nil)
 	Curfn = xfunc
 	for i, t := range t0.Params().Fields().Slice() {
-		n := newname(LookupN("a", i))
+		n := newname(lookupN("a", i))
 		n.Class = PPARAM
 		xfunc.Func.Dcl = append(xfunc.Func.Dcl, n)
 		callargs = append(callargs, n)
@@ -597,7 +597,7 @@ func makepartialcall(fn *Node, t0 *Type, meth *Sym) *Node {
 	l = nil
 	var retargs []*Node
 	for i, t := range t0.Results().Fields().Slice() {
-		n := newname(LookupN("r", i))
+		n := newname(lookupN("r", i))
 		n.Class = PPARAMOUT
 		xfunc.Func.Dcl = append(xfunc.Func.Dcl, n)
 		retargs = append(retargs, n)
@@ -623,7 +623,7 @@ func makepartialcall(fn *Node, t0 *Type, meth *Sym) *Node {
 		cv.Xoffset = int64(cv.Type.Align)
 	}
 	ptr := Nod(ONAME, nil, nil)
-	ptr.Sym = Lookup("rcvr")
+	ptr.Sym = lookup("rcvr")
 	ptr.Class = PAUTO
 	ptr.Addable = true
 	ptr.Ullman = 1
@@ -636,11 +636,11 @@ func makepartialcall(fn *Node, t0 *Type, meth *Sym) *Node {
 		ptr.Name.Param.Ntype = typenod(rcvrtype)
 		body = append(body, Nod(OAS, ptr, cv))
 	} else {
-		ptr.Name.Param.Ntype = typenod(Ptrto(rcvrtype))
+		ptr.Name.Param.Ntype = typenod(ptrto(rcvrtype))
 		body = append(body, Nod(OAS, ptr, Nod(OADDR, cv, nil)))
 	}
 
-	call := Nod(OCALL, NodSym(OXDOT, ptr, meth), nil)
+	call := Nod(OCALL, nodSym(OXDOT, ptr, meth), nil)
 	call.List.Set(callargs)
 	call.Isddd = ddd
 	if t0.Results().NumFields() == 0 {
@@ -681,8 +681,8 @@ func walkpartialcall(n *Node, init *Nodes) *Node {
 	}
 
 	typ := Nod(OTSTRUCT, nil, nil)
-	typ.List.Set1(Nod(ODCLFIELD, newname(Lookup("F")), typenod(Types[TUINTPTR])))
-	typ.List.Append(Nod(ODCLFIELD, newname(Lookup("R")), typenod(n.Left.Type)))
+	typ.List.Set1(Nod(ODCLFIELD, newname(lookup("F")), typenod(Types[TUINTPTR])))
+	typ.List.Append(Nod(ODCLFIELD, newname(lookup("R")), typenod(n.Left.Type)))
 
 	clos := Nod(OCOMPLIT, nil, Nod(OIND, typ, nil))
 	clos.Esc = n.Esc
diff --git a/src/cmd/compile/internal/gc/const.go b/src/cmd/compile/internal/gc/const.go
index 75ee446768..deb2a7b1d9 100644
--- a/src/cmd/compile/internal/gc/const.go
+++ b/src/cmd/compile/internal/gc/const.go
@@ -190,13 +190,6 @@ func truncfltlit(oldv *Mpflt, t *Type) *Mpflt {
 	return fv
 }
 
-// NegOne returns a Node of type t with value -1.
-func NegOne(t *Type) *Node {
-	n := nodintconst(-1)
-	n = convlit(n, t)
-	return n
-}
-
 // canReuseNode indicates whether it is known to be safe
 // to reuse a Node.
 type canReuseNode bool
@@ -265,7 +258,7 @@ func convlit1(n *Node, t *Type, explicit bool, reuse canReuseNode) *Node {
 			n.SetVal(toint(n.Val()))
 		}
 		if t != nil && !t.IsInteger() {
-			Yyerror("invalid operation: %v (shift of type %v)", n, t)
+			yyerror("invalid operation: %v (shift of type %v)", n, t)
 			t = nil
 		}
 
@@ -412,7 +405,7 @@ func convlit1(n *Node, t *Type, explicit bool, reuse canReuseNode) *Node {
 bad:
 	if n.Diag == 0 {
 		if !t.Broke {
-			Yyerror("cannot convert %v to type %v", n, t)
+			yyerror("cannot convert %v to type %v", n, t)
 		}
 		n.Diag = 1
 	}
@@ -475,7 +468,7 @@ func toflt(v Val) Val {
 		f := newMpflt()
 		f.Set(&u.Real)
 		if u.Imag.CmpFloat64(0) != 0 {
-			Yyerror("constant %v%vi truncated to real", fconv(&u.Real, FmtSharp), fconv(&u.Imag, FmtSharp|FmtSign))
+			yyerror("constant %v%vi truncated to real", fconv(&u.Real, FmtSharp), fconv(&u.Imag, FmtSharp|FmtSign))
 		}
 		v.U = f
 	}
@@ -500,17 +493,17 @@ func toint(v Val) Val {
 			if u.Val.IsInt() {
 				msg = "constant %v overflows integer"
 			}
-			Yyerror(msg, fconv(u, FmtSharp))
+			yyerror(msg, fconv(u, FmtSharp))
 		}
 		v.U = i
 
 	case *Mpcplx:
 		i := new(Mpint)
 		if i.SetFloat(&u.Real) < 0 {
-			Yyerror("constant %v%vi truncated to integer", fconv(&u.Real, FmtSharp), fconv(&u.Imag, FmtSharp|FmtSign))
+			yyerror("constant %v%vi truncated to integer", fconv(&u.Real, FmtSharp), fconv(&u.Imag, FmtSharp|FmtSign))
 		}
 		if u.Imag.CmpFloat64(0) != 0 {
-			Yyerror("constant %v%vi truncated to real", fconv(&u.Real, FmtSharp), fconv(&u.Imag, FmtSharp|FmtSign))
+			yyerror("constant %v%vi truncated to real", fconv(&u.Real, FmtSharp), fconv(&u.Imag, FmtSharp|FmtSign))
 		}
 		v.U = i
 	}
@@ -556,7 +549,7 @@ func overflow(v Val, t *Type) {
 	}
 
 	if doesoverflow(v, t) {
-		Yyerror("constant %v overflows %v", v, t)
+		yyerror("constant %v overflows %v", v, t)
 	}
 }
 
@@ -744,7 +737,7 @@ func evconst(n *Node) {
 		switch uint32(n.Op)<<16 | uint32(v.Ctype()) {
 		default:
 			if n.Diag == 0 {
-				Yyerror("illegal constant expression %v %v", n.Op, nl.Type)
+				yyerror("illegal constant expression %v %v", n.Op, nl.Type)
 				n.Diag = 1
 			}
 			return
@@ -939,7 +932,7 @@ func evconst(n *Node) {
 	case ODIV_ | CTINT_,
 		ODIV_ | CTRUNE_:
 		if rv.U.(*Mpint).CmpInt64(0) == 0 {
-			Yyerror("division by zero")
+			yyerror("division by zero")
 			v.U.(*Mpint).SetOverflow()
 			break
 		}
@@ -949,7 +942,7 @@ func evconst(n *Node) {
 	case OMOD_ | CTINT_,
 		OMOD_ | CTRUNE_:
 		if rv.U.(*Mpint).CmpInt64(0) == 0 {
-			Yyerror("division by zero")
+			yyerror("division by zero")
 			v.U.(*Mpint).SetOverflow()
 			break
 		}
@@ -991,7 +984,7 @@ func evconst(n *Node) {
 
 	case ODIV_ | CTFLT_:
 		if rv.U.(*Mpflt).CmpFloat64(0) == 0 {
-			Yyerror("division by zero")
+			yyerror("division by zero")
 			v.U.(*Mpflt).SetFloat64(1.0)
 			break
 		}
@@ -1002,7 +995,7 @@ func evconst(n *Node) {
 	// which is not quite an ideal error.
 	case OMOD_ | CTFLT_:
 		if n.Diag == 0 {
-			Yyerror("illegal constant expression: floating-point %% operation")
+			yyerror("illegal constant expression: floating-point %% operation")
 			n.Diag = 1
 		}
 
@@ -1021,7 +1014,7 @@ func evconst(n *Node) {
 
 	case ODIV_ | CTCPLX_:
 		if rv.U.(*Mpcplx).Real.CmpFloat64(0) == 0 && rv.U.(*Mpcplx).Imag.CmpFloat64(0) == 0 {
-			Yyerror("complex division by zero")
+			yyerror("complex division by zero")
 			rv.U.(*Mpcplx).Real.SetFloat64(1.0)
 			rv.U.(*Mpcplx).Imag.SetFloat64(0.0)
 			break
@@ -1209,7 +1202,7 @@ ret:
 	return
 
 settrue:
-	nn = Nodbool(true)
+	nn = nodbool(true)
 	nn.Orig = saveorig(n)
 	if !iscmp[n.Op] {
 		nn.Type = nl.Type
@@ -1218,7 +1211,7 @@ settrue:
 	return
 
 setfalse:
-	nn = Nodbool(false)
+	nn = nodbool(false)
 	nn.Orig = saveorig(n)
 	if !iscmp[n.Op] {
 		nn.Type = nl.Type
@@ -1228,7 +1221,7 @@ setfalse:
 
 illegal:
 	if n.Diag == 0 {
-		Yyerror("illegal constant expression: %v %v %v", nl.Type, n.Op, nr.Type)
+		yyerror("illegal constant expression: %v %v %v", nl.Type, n.Op, nr.Type)
 		n.Diag = 1
 	}
 }
@@ -1369,7 +1362,7 @@ func defaultlitreuse(n *Node, t *Type, reuse canReuseNode) *Node {
 		if n.Val().Ctype() == CTNIL {
 			lineno = lno
 			if n.Diag == 0 {
-				Yyerror("use of untyped nil")
+				yyerror("use of untyped nil")
 				n.Diag = 1
 			}
 
@@ -1383,7 +1376,7 @@ func defaultlitreuse(n *Node, t *Type, reuse canReuseNode) *Node {
 			break
 		}
 
-		Yyerror("defaultlit: unknown literal: %v", n)
+		yyerror("defaultlit: unknown literal: %v", n)
 
 	case CTxxx:
 		Fatalf("defaultlit: idealkind is CTxxx: %+v", n)
diff --git a/src/cmd/compile/internal/gc/dcl.go b/src/cmd/compile/internal/gc/dcl.go
index 9d3eda9445..66300f0926 100644
--- a/src/cmd/compile/internal/gc/dcl.go
+++ b/src/cmd/compile/internal/gc/dcl.go
@@ -106,7 +106,7 @@ func testdclstack() {
 			if nerrors != 0 {
 				errorexit()
 			}
-			Yyerror("mark left on the stack")
+			yyerror("mark left on the stack")
 		}
 	}
 }
@@ -121,7 +121,7 @@ func redeclare(s *Sym, where string) {
 			tmp = s.Pkg.Path
 		}
 		pkgstr := tmp
-		Yyerror("%v redeclared %s\n"+
+		yyerror("%v redeclared %s\n"+
 			"\tprevious declaration during import %q", s, where, pkgstr)
 	} else {
 		line1 := lineno
@@ -167,11 +167,11 @@ func declare(n *Node, ctxt Class) {
 
 	// kludgy: typecheckok means we're past parsing. Eg genwrapper may declare out of package names later.
 	if importpkg == nil && !typecheckok && s.Pkg != localpkg {
-		Yyerror("cannot declare name %v", s)
+		yyerror("cannot declare name %v", s)
 	}
 
 	if ctxt == PEXTERN && s.Name == "init" {
-		Yyerror("cannot declare init - must be func")
+		yyerror("cannot declare init - must be func")
 	}
 
 	gen := 0
@@ -255,7 +255,7 @@ func variter(vl []*Node, t *Node, el []*Node) []*Node {
 		var e *Node
 		if doexpr {
 			if len(el) == 0 {
-				Yyerror("missing expression in var declaration")
+				yyerror("missing expression in var declaration")
 				break
 			}
 			e = el[0]
@@ -279,7 +279,7 @@ func variter(vl []*Node, t *Node, el []*Node) []*Node {
 	}
 
 	if len(el) != 0 {
-		Yyerror("extra expression in var declaration")
+		yyerror("extra expression in var declaration")
 	}
 	return init
 }
@@ -290,7 +290,7 @@ func constiter(vl []*Node, t *Node, cl []*Node) []*Node {
 	lno := int32(0) // default is to leave line number alone in listtreecopy
 	if len(cl) == 0 {
 		if t != nil {
-			Yyerror("const declaration cannot have type without expression")
+			yyerror("const declaration cannot have type without expression")
 		}
 		cl = lastconst
 		t = lasttype
@@ -304,7 +304,7 @@ func constiter(vl []*Node, t *Node, cl []*Node) []*Node {
 	var vv []*Node
 	for _, v := range vl {
 		if len(clcopy) == 0 {
-			Yyerror("missing value in const declaration")
+			yyerror("missing value in const declaration")
 			break
 		}
 
@@ -321,7 +321,7 @@ func constiter(vl []*Node, t *Node, cl []*Node) []*Node {
 	}
 
 	if len(clcopy) != 0 {
-		Yyerror("extra expression in const declaration")
+		yyerror("extra expression in const declaration")
 	}
 	iota_ += 1
 	return vv
@@ -504,7 +504,7 @@ func ifacedcl(n *Node) {
 	}
 
 	if isblank(n.Left) {
-		Yyerror("methods must have a unique non-blank name")
+		yyerror("methods must have a unique non-blank name")
 	}
 
 	n.Func = new(Func)
@@ -603,7 +603,7 @@ func funcargs(nt *Node) {
 
 		if n.Left == nil {
 			// Name so that escape analysis can track it. ~r stands for 'result'.
-			n.Left = newname(LookupN("~r", gen))
+			n.Left = newname(lookupN("~r", gen))
 			gen++
 		}
 
@@ -621,7 +621,7 @@ func funcargs(nt *Node) {
 			// Having multiple names causes too much confusion in later passes.
 			nn := *n.Left
 			nn.Orig = &nn
-			nn.Sym = LookupN("~b", gen)
+			nn.Sym = lookupN("~b", gen)
 			gen++
 			n.Left = &nn
 		}
@@ -726,12 +726,12 @@ func checkembeddedtype(t *Type) {
 	if t.Sym == nil && t.IsPtr() {
 		t = t.Elem()
 		if t.IsInterface() {
-			Yyerror("embedded type cannot be a pointer to interface")
+			yyerror("embedded type cannot be a pointer to interface")
 		}
 	}
 
 	if t.IsPtr() || t.IsUnsafePtr() {
-		Yyerror("embedded type cannot be a pointer")
+		yyerror("embedded type cannot be a pointer")
 	} else if t.Etype == TFORW && t.ForwardType().Embedlineno == 0 {
 		t.ForwardType().Embedlineno = lineno
 	}
@@ -770,7 +770,7 @@ func structfield(n *Node) *Field {
 	case string:
 		f.Note = u
 	default:
-		Yyerror("field annotation must be string")
+		yyerror("field annotation must be string")
 	case nil:
 		// noop
 	}
@@ -798,7 +798,7 @@ func checkdupfields(what string, ts ...*Type) {
 			}
 			if seen[f.Sym] {
 				lineno = f.Nname.Lineno
-				Yyerror("duplicate %s %s", what, f.Sym.Name)
+				yyerror("duplicate %s %s", what, f.Sym.Name)
 				continue
 			}
 			seen[f.Sym] = true
@@ -869,7 +869,7 @@ func interfacefield(n *Node) *Field {
 	}
 
 	if n.Val().Ctype() != CTxxx {
-		Yyerror("interface method cannot have annotation")
+		yyerror("interface method cannot have annotation")
 	}
 
 	f := newField()
@@ -904,11 +904,11 @@ func interfacefield(n *Node) *Field {
 					break
 
 				case TFORW:
-					Yyerror("interface type loop involving %v", n.Type)
+					yyerror("interface type loop involving %v", n.Type)
 					f.Broke = true
 
 				default:
-					Yyerror("interface contains embedded non-interface %v", n.Type)
+					yyerror("interface contains embedded non-interface %v", n.Type)
 					f.Broke = true
 				}
 			}
@@ -984,7 +984,7 @@ func embedded(s *Sym, pkg *Pkg) *Node {
 
 	var n *Node
 	if exportname(name) {
-		n = newname(Lookup(name))
+		n = newname(lookup(name))
 	} else if s.Pkg == builtinpkg {
 		// The name of embedded builtins belongs to pkg.
 		n = newname(Pkglookup(name, pkg))
@@ -997,7 +997,7 @@ func embedded(s *Sym, pkg *Pkg) *Node {
 }
 
 func fakethis() *Node {
-	n := Nod(ODCLFIELD, nil, typenod(Ptrto(typ(TSTRUCT))))
+	n := Nod(ODCLFIELD, nil, typenod(ptrto(typ(TSTRUCT))))
 	return n
 }
 
@@ -1084,7 +1084,7 @@ func methodsym(nsym *Sym, t0 *Type, iface int) *Sym {
 	// if t0 == *t and t0 has a sym,
 	// we want to see *t, not t0, in the method name.
 	if t != t0 && t0.Sym != nil {
-		t0 = Ptrto(t)
+		t0 = ptrto(t)
 	}
 
 	suffix = ""
@@ -1121,7 +1121,7 @@ func methodsym(nsym *Sym, t0 *Type, iface int) *Sym {
 	return s
 
 bad:
-	Yyerror("illegal receiver type: %v", t0)
+	yyerror("illegal receiver type: %v", t0)
 	return nil
 }
 
@@ -1144,7 +1144,7 @@ func methodname(n *Node, t *Node) *Node {
 	}
 
 	if exportname(t.Sym.Name) {
-		n = newfuncname(Lookup(p))
+		n = newfuncname(lookup(p))
 	} else {
 		n = newfuncname(Pkglookup(p, t.Sym.Pkg))
 	}
@@ -1164,7 +1164,7 @@ func addmethod(msym *Sym, t *Type, local, nointerface bool) {
 	// get parent type sym
 	rf := t.Recv() // ptr to this structure
 	if rf == nil {
-		Yyerror("missing receiver")
+		yyerror("missing receiver")
 		return
 	}
 
@@ -1174,7 +1174,7 @@ func addmethod(msym *Sym, t *Type, local, nointerface bool) {
 		t := pa
 		if t != nil && t.IsPtr() {
 			if t.Sym != nil {
-				Yyerror("invalid receiver type %v (%v is a pointer type)", pa, t)
+				yyerror("invalid receiver type %v (%v is a pointer type)", pa, t)
 				return
 			}
 			t = t.Elem()
@@ -1184,21 +1184,21 @@ func addmethod(msym *Sym, t *Type, local, nointerface bool) {
 		case t == nil || t.Broke:
 			// rely on typecheck having complained before
 		case t.Sym == nil:
-			Yyerror("invalid receiver type %v (%v is an unnamed type)", pa, t)
+			yyerror("invalid receiver type %v (%v is an unnamed type)", pa, t)
 		case t.IsPtr():
-			Yyerror("invalid receiver type %v (%v is a pointer type)", pa, t)
+			yyerror("invalid receiver type %v (%v is a pointer type)", pa, t)
 		case t.IsInterface():
-			Yyerror("invalid receiver type %v (%v is an interface type)", pa, t)
+			yyerror("invalid receiver type %v (%v is an interface type)", pa, t)
 		default:
 			// Should have picked off all the reasons above,
 			// but just in case, fall back to generic error.
-			Yyerror("invalid receiver type %v (%L / %L)", pa, pa, t)
+			yyerror("invalid receiver type %v (%L / %L)", pa, pa, t)
 		}
 		return
 	}
 
 	if local && !mt.Local {
-		Yyerror("cannot define new methods on non-local type %v", mt)
+		yyerror("cannot define new methods on non-local type %v", mt)
 		return
 	}
 
@@ -1209,7 +1209,7 @@ func addmethod(msym *Sym, t *Type, local, nointerface bool) {
 	if mt.IsStruct() {
 		for _, f := range mt.Fields().Slice() {
 			if f.Sym == msym {
-				Yyerror("type %v has both field and method named %v", mt, msym)
+				yyerror("type %v has both field and method named %v", mt, msym)
 				return
 			}
 		}
@@ -1225,7 +1225,7 @@ func addmethod(msym *Sym, t *Type, local, nointerface bool) {
 		// eqtype only checks that incoming and result parameters match,
 		// so explicitly check that the receiver parameters match too.
 		if !eqtype(t, f.Type) || !eqtype(t.Recv().Type, f.Type.Recv().Type) {
-			Yyerror("method redeclared: %v.%v\n\t%v\n\t%v", mt, msym, f.Type, t)
+			yyerror("method redeclared: %v.%v\n\t%v\n\t%v", mt, msym, f.Type, t)
 		}
 		return
 	}
diff --git a/src/cmd/compile/internal/gc/esc.go b/src/cmd/compile/internal/gc/esc.go
index a06f3999b2..9f927c9e23 100644
--- a/src/cmd/compile/internal/gc/esc.go
+++ b/src/cmd/compile/internal/gc/esc.go
@@ -451,7 +451,7 @@ func escAnalyze(all []*Node, recursive bool) {
 	e.theSink.Op = ONAME
 	e.theSink.Orig = &e.theSink
 	e.theSink.Class = PEXTERN
-	e.theSink.Sym = Lookup(".sink")
+	e.theSink.Sym = lookup(".sink")
 	e.nodeEscState(&e.theSink).Escloopdepth = -1
 	e.recursive = recursive
 
@@ -1097,7 +1097,7 @@ func escassign(e *EscState, dst, src *Node, step *EscStep) {
 		a := Nod(OADDR, src, nil)
 		a.Lineno = src.Lineno
 		e.nodeEscState(a).Escloopdepth = e.nodeEscState(src).Escloopdepth
-		a.Type = Ptrto(src.Type)
+		a.Type = ptrto(src.Type)
 		escflows(e, dst, a, e.stepAssign(nil, originalDst, src, dstwhy))
 
 	// Flowing multiple returns to a single dst happens when
@@ -1392,7 +1392,7 @@ func initEscretval(e *EscState, n *Node, fntype *Type) {
 		src := Nod(ONAME, nil, nil)
 		buf := fmt.Sprintf(".out%d", i)
 		i++
-		src.Sym = Lookup(buf)
+		src.Sym = lookup(buf)
 		src.Type = t.Type
 		src.Class = PAUTO
 		src.Name.Curfn = Curfn
@@ -1502,7 +1502,7 @@ func esccall(e *EscState, n *Node, up *Node) {
 					// Introduce ODDDARG node to represent ... allocation.
 					src = Nod(ODDDARG, nil, nil)
 					arr := typArray(n2.Type.Elem(), int64(len(lls)))
-					src.Type = Ptrto(arr) // make pointer so it will be tracked
+					src.Type = ptrto(arr) // make pointer so it will be tracked
 					src.Lineno = n.Lineno
 					e.track(src)
 					n.Right = src
@@ -1558,7 +1558,7 @@ func esccall(e *EscState, n *Node, up *Node) {
 	note := ""
 	i := 0
 	lls := ll.Slice()
-	for t, it := IterFields(fntype.Params()); i < len(lls); i++ {
+	for t, it := iterFields(fntype.Params()); i < len(lls); i++ {
 		src = lls[i]
 		note = t.Note
 		if t.Isddd && !n.Isddd {
@@ -1566,7 +1566,7 @@ func esccall(e *EscState, n *Node, up *Node) {
 			src = Nod(ODDDARG, nil, nil)
 			src.Lineno = n.Lineno
 			arr := typArray(t.Type.Elem(), int64(len(lls)-i))
-			src.Type = Ptrto(arr) // make pointer so it will be tracked
+			src.Type = ptrto(arr) // make pointer so it will be tracked
 			e.track(src)
 			n.Right = src
 		}
diff --git a/src/cmd/compile/internal/gc/export.go b/src/cmd/compile/internal/gc/export.go
index 142a817fc7..972101f910 100644
--- a/src/cmd/compile/internal/gc/export.go
+++ b/src/cmd/compile/internal/gc/export.go
@@ -35,7 +35,7 @@ func exportsym(n *Node) {
 	}
 	if n.Sym.Flags&(SymExport|SymPackage) != 0 {
 		if n.Sym.Flags&SymPackage != 0 {
-			Yyerror("export/package mismatch: %v", n.Sym)
+			yyerror("export/package mismatch: %v", n.Sym)
 		}
 		return
 	}
@@ -291,7 +291,7 @@ func pkgtype(s *Sym) *Type {
 	}
 
 	if s.Def.Type == nil {
-		Yyerror("pkgtype %v", s)
+		yyerror("pkgtype %v", s)
 	}
 	return s.Def.Type
 }
@@ -306,7 +306,7 @@ func importconst(s *Sym, t *Type, n *Node) {
 	}
 
 	if n.Op != OLITERAL {
-		Yyerror("expression must be a constant")
+		yyerror("expression must be a constant")
 		return
 	}
 
@@ -331,7 +331,7 @@ func importvar(s *Sym, t *Type) {
 		if eqtype(t, s.Def.Type) {
 			return
 		}
-		Yyerror("inconsistent definition for var %v during import\n\t%v (in %q)\n\t%v (in %q)", s, s.Def.Type, s.Importdef.Path, t, importpkg.Path)
+		yyerror("inconsistent definition for var %v during import\n\t%v (in %q)\n\t%v (in %q)", s, s.Def.Type, s.Importdef.Path, t, importpkg.Path)
 	}
 
 	n := newname(s)
diff --git a/src/cmd/compile/internal/gc/fmt.go b/src/cmd/compile/internal/gc/fmt.go
index 0563d88b49..3b746344e6 100644
--- a/src/cmd/compile/internal/gc/fmt.go
+++ b/src/cmd/compile/internal/gc/fmt.go
@@ -738,7 +738,7 @@ func (t *Type) typefmt(flag FmtFlag) string {
 				return "map.iter[" + m.Key().String() + "]" + m.Val().String()
 			}
 
-			Yyerror("unknown internal map type")
+			yyerror("unknown internal map type")
 		}
 
 		buf := make([]byte, 0, 64)
@@ -752,7 +752,7 @@ func (t *Type) typefmt(flag FmtFlag) string {
 				if i != 0 {
 					buf = append(buf, ", "...)
 				}
-				buf = append(buf, Fldconv(f, flag1)...)
+				buf = append(buf, fldconv(f, flag1)...)
 			}
 			buf = append(buf, ')')
 		} else {
@@ -762,7 +762,7 @@ func (t *Type) typefmt(flag FmtFlag) string {
 					buf = append(buf, ';')
 				}
 				buf = append(buf, ' ')
-				buf = append(buf, Fldconv(f, FmtLong)...)
+				buf = append(buf, fldconv(f, FmtLong)...)
 			}
 			if t.NumFields() != 0 {
 				buf = append(buf, ' ')
@@ -1600,7 +1600,7 @@ func (t *Type) String() string {
 	return t.tconv(0)
 }
 
-func Fldconv(f *Field, flag FmtFlag) string {
+func fldconv(f *Field, flag FmtFlag) string {
 	if f == nil {
 		return "<T>"
 	}
@@ -1628,7 +1628,7 @@ func Fldconv(f *Field, flag FmtFlag) string {
 					if s.Name[1] == 'r' { // originally an unnamed result
 						s = nil
 					} else if s.Name[1] == 'b' { // originally the blank identifier _
-						s = Lookup("_")
+						s = lookup("_")
 					}
 				}
 			} else {
diff --git a/src/cmd/compile/internal/gc/gen.go b/src/cmd/compile/internal/gc/gen.go
index 3d91e2f894..0f2c982283 100644
--- a/src/cmd/compile/internal/gc/gen.go
+++ b/src/cmd/compile/internal/gc/gen.go
@@ -105,7 +105,7 @@ func moveToHeap(n *Node) {
 		Dump("MOVE", n)
 	}
 	if compiling_runtime {
-		Yyerror("%v escapes to heap, not allowed in runtime.", n)
+		yyerror("%v escapes to heap, not allowed in runtime.", n)
 	}
 	if n.Class == PAUTOHEAP {
 		Dump("n", n)
@@ -114,8 +114,8 @@ func moveToHeap(n *Node) {
 
 	// Allocate a local stack variable to hold the pointer to the heap copy.
 	// temp will add it to the function declaration list automatically.
-	heapaddr := temp(Ptrto(n.Type))
-	heapaddr.Sym = Lookup("&" + n.Sym.Name)
+	heapaddr := temp(ptrto(n.Type))
+	heapaddr.Sym = lookup("&" + n.Sym.Name)
 	heapaddr.Orig.Sym = heapaddr.Sym
 
 	// Parameters have a local stack copy used at function start/end
@@ -200,13 +200,13 @@ func tempname(nn *Node, t *Type) {
 	}
 
 	if t == nil {
-		Yyerror("tempname called with nil type")
+		yyerror("tempname called with nil type")
 		t = Types[TINT32]
 	}
 
 	// give each tmp a different name so that there
 	// a chance to registerizer them
-	s := LookupN("autotmp_", statuniqgen)
+	s := lookupN("autotmp_", statuniqgen)
 	statuniqgen++
 	n := Nod(ONAME, nil, nil)
 	n.Sym = s
diff --git a/src/cmd/compile/internal/gc/gsubr.go b/src/cmd/compile/internal/gc/gsubr.go
index 918c311f41..97975b09fd 100644
--- a/src/cmd/compile/internal/gc/gsubr.go
+++ b/src/cmd/compile/internal/gc/gsubr.go
@@ -286,7 +286,7 @@ func Naddr(a *obj.Addr, n *Node) {
 		a.Sym = Linksym(n.Sym)
 		a.Offset = n.Xoffset
 		if a.Offset != int64(int32(a.Offset)) {
-			Yyerror("offset %d too large for OINDREG", a.Offset)
+			yyerror("offset %d too large for OINDREG", a.Offset)
 		}
 		if Thearch.LinkArch.Family == sys.I386 { // TODO(rsc): Never clear a->width.
 			a.Width = 0
@@ -317,7 +317,7 @@ func Naddr(a *obj.Addr, n *Node) {
 		//if(a->node >= (Node*)&n)
 		//	fatal("stack node");
 		if s == nil {
-			s = Lookup(".noname")
+			s = lookup(".noname")
 		}
 		if n.Name.Method && n.Type != nil && n.Type.Sym != nil && n.Type.Sym.Pkg != nil {
 			s = Pkglookup(s.Name, n.Type.Sym.Pkg)
@@ -503,7 +503,7 @@ func nodarg(t interface{}, fp int) *Node {
 
 		// Build fake variable name for whole arg struct.
 		n = Nod(ONAME, nil, nil)
-		n.Sym = Lookup(".args")
+		n.Sym = lookup(".args")
 		n.Type = t
 		first := t.Field(0)
 		if first == nil {
@@ -566,7 +566,7 @@ func nodarg(t interface{}, fp int) *Node {
 	// or else the assignment to _ will be
 	// discarded during code generation.
 	if isblank(n) {
-		n.Sym = Lookup("__")
+		n.Sym = lookup("__")
 	}
 
 	switch fp {
@@ -648,7 +648,7 @@ Switch:
 				break Switch
 			}
 		}
-		Flusherrors()
+		flusherrors()
 		regdump()
 		Fatalf("out of fixed registers")
 
@@ -668,7 +668,7 @@ Switch:
 				break Switch
 			}
 		}
-		Flusherrors()
+		flusherrors()
 		regdump()
 		Fatalf("out of floating registers")
 
diff --git a/src/cmd/compile/internal/gc/init.go b/src/cmd/compile/internal/gc/init.go
index 1ab0d80e75..827525d3ac 100644
--- a/src/cmd/compile/internal/gc/init.go
+++ b/src/cmd/compile/internal/gc/init.go
@@ -27,7 +27,7 @@ var renameinit_initgen int
 
 func renameinit() *Sym {
 	renameinit_initgen++
-	return LookupN("init.", renameinit_initgen)
+	return lookupN("init.", renameinit_initgen)
 }
 
 // hand-craft the following initialization code
@@ -70,7 +70,7 @@ func anyinit(n []*Node) bool {
 	}
 
 	// is there an explicit init function
-	s := Lookup("init.1")
+	s := lookup("init.1")
 
 	if s.Def != nil {
 		return true
@@ -101,14 +101,14 @@ func fninit(n []*Node) {
 	var r []*Node
 
 	// (1)
-	gatevar := newname(Lookup("initdone·"))
+	gatevar := newname(lookup("initdone·"))
 	addvar(gatevar, Types[TUINT8], PEXTERN)
 
 	// (2)
 	Maxarg = 0
 
 	fn := Nod(ODCLFUNC, nil, nil)
-	initsym := Lookup("init")
+	initsym := lookup("init")
 	fn.Func.Nname = newname(initsym)
 	fn.Func.Nname.Name.Defn = fn
 	fn.Func.Nname.Name.Param.Ntype = Nod(OTFUNC, nil, nil)
@@ -153,7 +153,7 @@ func fninit(n []*Node) {
 	// (8)
 	// could check that it is fn of no args/returns
 	for i := 1; ; i++ {
-		s := LookupN("init.", i)
+		s := lookupN("init.", i)
 		if s.Def == nil {
 			break
 		}
diff --git a/src/cmd/compile/internal/gc/inl.go b/src/cmd/compile/internal/gc/inl.go
index 18a294214d..6832cddeb4 100644
--- a/src/cmd/compile/internal/gc/inl.go
+++ b/src/cmd/compile/internal/gc/inl.go
@@ -722,7 +722,7 @@ func mkinlcall1(n *Node, fn *Node, isddd bool) *Node {
 		}
 	} else {
 		// match arguments except final variadic (unless the call is dotted itself)
-		t, it := IterFields(fn.Type.Params())
+		t, it := iterFields(fn.Type.Params())
 		for t != nil {
 			if li >= n.List.Len() {
 				break
@@ -870,7 +870,7 @@ func inlvar(var_ *Node) *Node {
 
 // Synthesize a variable to store the inlined function's results in.
 func retvar(t *Field, i int) *Node {
-	n := newname(LookupN("~r", i))
+	n := newname(lookupN("~r", i))
 	n.Type = t.Type
 	n.Class = PAUTO
 	n.Used = true
@@ -882,7 +882,7 @@ func retvar(t *Field, i int) *Node {
 // Synthesize a variable to store the inlined function's arguments
 // when they come from a multiple return call.
 func argvar(t *Type, i int) *Node {
-	n := newname(LookupN("~arg", i))
+	n := newname(lookupN("~arg", i))
 	n.Type = t.Elem()
 	n.Class = PAUTO
 	n.Used = true
@@ -969,7 +969,7 @@ func (subst *inlsubst) node(n *Node) *Node {
 		*m = *n
 		m.Ninit.Set(nil)
 		p := fmt.Sprintf("%s·%d", n.Left.Sym.Name, inlgen)
-		m.Left = newname(Lookup(p))
+		m.Left = newname(lookup(p))
 
 		return m
 	default:
diff --git a/src/cmd/compile/internal/gc/lex.go b/src/cmd/compile/internal/gc/lex.go
index 0d49b239fd..39026fc83f 100644
--- a/src/cmd/compile/internal/gc/lex.go
+++ b/src/cmd/compile/internal/gc/lex.go
@@ -76,7 +76,7 @@ const (
 	UintptrEscapes           // pointers converted to uintptr escape
 )
 
-func PragmaValue(verb string) Pragma {
+func pragmaValue(verb string) Pragma {
 	switch verb {
 	case "go:nointerface":
 		if obj.Fieldtrack_enabled != 0 {
@@ -92,17 +92,17 @@ func PragmaValue(verb string) Pragma {
 		return Noinline
 	case "go:systemstack":
 		if !compiling_runtime {
-			Yyerror("//go:systemstack only allowed in runtime")
+			yyerror("//go:systemstack only allowed in runtime")
 		}
 		return Systemstack
 	case "go:nowritebarrier":
 		if !compiling_runtime {
-			Yyerror("//go:nowritebarrier only allowed in runtime")
+			yyerror("//go:nowritebarrier only allowed in runtime")
 		}
 		return Nowritebarrier
 	case "go:nowritebarrierrec":
 		if !compiling_runtime {
-			Yyerror("//go:nowritebarrierrec only allowed in runtime")
+			yyerror("//go:nowritebarrierrec only allowed in runtime")
 		}
 		return Nowritebarrierrec | Nowritebarrier // implies Nowritebarrier
 	case "go:cgo_unsafe_args":
@@ -355,7 +355,7 @@ l0:
 					continue
 				}
 				if c == EOF {
-					Yyerror("eof in comment")
+					yyerror("eof in comment")
 					errorexit()
 				}
 				c = l.getr()
@@ -520,7 +520,7 @@ l0:
 
 	default:
 		// anything else is illegal
-		Yyerror("syntax error: illegal character %#U", c)
+		yyerror("syntax error: illegal character %#U", c)
 		goto l0
 	}
 
@@ -581,10 +581,10 @@ func (l *lexer) ident(c rune) {
 		if c >= utf8.RuneSelf {
 			if unicode.IsLetter(c) || c == '_' || unicode.IsDigit(c) {
 				if cp.Len() == 0 && unicode.IsDigit(c) {
-					Yyerror("identifier cannot begin with digit %#U", c)
+					yyerror("identifier cannot begin with digit %#U", c)
 				}
 			} else {
-				Yyerror("invalid identifier character %#U", c)
+				yyerror("invalid identifier character %#U", c)
 			}
 			cp.WriteRune(c)
 		} else if isLetter(c) || isDigit(c) {
@@ -614,7 +614,7 @@ func (l *lexer) ident(c rune) {
 		}
 	}
 
-	s := LookupBytes(name)
+	s := lookupBytes(name)
 	if Debug['x'] != 0 {
 		fmt.Printf("lex: ident %v\n", s)
 	}
@@ -686,7 +686,7 @@ func (l *lexer) number(c rune) {
 					c = l.getr()
 				}
 				if lexbuf.Len() == 2 {
-					Yyerror("malformed hex constant")
+					yyerror("malformed hex constant")
 				}
 			} else {
 				// decimal 0, octal, or float
@@ -727,7 +727,7 @@ func (l *lexer) number(c rune) {
 				c = l.getr()
 			}
 			if !isDigit(c) {
-				Yyerror("malformed floating point constant exponent")
+				yyerror("malformed floating point constant exponent")
 			}
 			for isDigit(c) {
 				cp.WriteByte(byte(c))
@@ -742,7 +742,7 @@ func (l *lexer) number(c rune) {
 			x.Real.SetFloat64(0.0)
 			x.Imag.SetString(str)
 			if x.Imag.Val.IsInf() {
-				Yyerror("overflow in imaginary constant")
+				yyerror("overflow in imaginary constant")
 				x.Imag.SetFloat64(0.0)
 			}
 			l.val.U = x
@@ -758,14 +758,14 @@ func (l *lexer) number(c rune) {
 
 	if isInt {
 		if malformedOctal {
-			Yyerror("malformed octal constant")
+			yyerror("malformed octal constant")
 		}
 
 		str = lexbuf.String()
 		x := new(Mpint)
 		x.SetString(str)
 		if x.Ovf {
-			Yyerror("overflow in constant")
+			yyerror("overflow in constant")
 			x.SetInt64(0)
 		}
 		l.val.U = x
@@ -780,7 +780,7 @@ func (l *lexer) number(c rune) {
 		x := newMpflt()
 		x.SetString(str)
 		if x.Val.IsInf() {
-			Yyerror("overflow in float constant")
+			yyerror("overflow in float constant")
 			x.SetFloat64(0.0)
 		}
 		l.val.U = x
@@ -837,7 +837,7 @@ func (l *lexer) rawString() {
 			continue
 		}
 		if c == EOF {
-			Yyerror("eof in string")
+			yyerror("eof in string")
 			break
 		}
 		if c == '`' {
@@ -858,7 +858,7 @@ func (l *lexer) rawString() {
 func (l *lexer) rune() {
 	r, b, ok := l.onechar('\'')
 	if !ok {
-		Yyerror("empty character literal or unescaped ' in character literal")
+		yyerror("empty character literal or unescaped ' in character literal")
 		r = '\''
 	}
 	if r == 0 {
@@ -866,7 +866,7 @@ func (l *lexer) rune() {
 	}
 
 	if c := l.getr(); c != '\'' {
-		Yyerror("missing '")
+		yyerror("missing '")
 		l.ungetr()
 	}
 
@@ -929,16 +929,16 @@ func (l *lexer) getlinepragma() rune {
 		switch verb {
 		case "go:linkname":
 			if !imported_unsafe {
-				Yyerror("//go:linkname only allowed in Go files that import \"unsafe\"")
+				yyerror("//go:linkname only allowed in Go files that import \"unsafe\"")
 			}
 			f := strings.Fields(text)
 			if len(f) != 3 {
-				Yyerror("usage: //go:linkname localname linkname")
+				yyerror("usage: //go:linkname localname linkname")
 				break
 			}
-			Lookup(f[1]).Linkname = f[2]
+			lookup(f[1]).Linkname = f[2]
 		default:
-			l.pragma |= PragmaValue(verb)
+			l.pragma |= pragmaValue(verb)
 		}
 		return c
 	}
@@ -984,7 +984,7 @@ func (l *lexer) getlinepragma() rune {
 		return c // todo: make this an error instead? it is almost certainly a bug.
 	}
 	if n > 1e8 {
-		Yyerror("line number out of range")
+		yyerror("line number out of range")
 		errorexit()
 	}
 	if n <= 0 {
@@ -1012,7 +1012,7 @@ func pragcgo(text string) string {
 			return fmt.Sprintln(verb, local, remote)
 
 		default:
-			Yyerror(`usage: //go:%s local [remote]`, verb)
+			yyerror(`usage: //go:%s local [remote]`, verb)
 		}
 	case "cgo_import_dynamic":
 		switch {
@@ -1032,7 +1032,7 @@ func pragcgo(text string) string {
 			return fmt.Sprintln(verb, local, remote, library)
 
 		default:
-			Yyerror(`usage: //go:cgo_import_dynamic local [remote ["library"]]`)
+			yyerror(`usage: //go:cgo_import_dynamic local [remote ["library"]]`)
 		}
 	case "cgo_import_static":
 		switch {
@@ -1041,7 +1041,7 @@ func pragcgo(text string) string {
 			return fmt.Sprintln(verb, local)
 
 		default:
-			Yyerror(`usage: //go:cgo_import_static local`)
+			yyerror(`usage: //go:cgo_import_static local`)
 		}
 	case "cgo_dynamic_linker":
 		switch {
@@ -1050,7 +1050,7 @@ func pragcgo(text string) string {
 			return fmt.Sprintln(verb, path)
 
 		default:
-			Yyerror(`usage: //go:cgo_dynamic_linker "path"`)
+			yyerror(`usage: //go:cgo_dynamic_linker "path"`)
 		}
 	case "cgo_ldflag":
 		switch {
@@ -1059,7 +1059,7 @@ func pragcgo(text string) string {
 			return fmt.Sprintln(verb, arg)
 
 		default:
-			Yyerror(`usage: //go:cgo_ldflag "arg"`)
+			yyerror(`usage: //go:cgo_ldflag "arg"`)
 		}
 	}
 	return ""
@@ -1143,12 +1143,12 @@ func (l *lexer) onechar(quote rune) (r rune, b byte, ok bool) {
 	c := l.getr()
 	switch c {
 	case EOF:
-		Yyerror("eof in string")
+		yyerror("eof in string")
 		l.ungetr()
 		return
 
 	case '\n':
-		Yyerror("newline in string")
+		yyerror("newline in string")
 		l.ungetr()
 		return
 
@@ -1182,12 +1182,12 @@ func (l *lexer) onechar(quote rune) (r rune, b byte, ok bool) {
 				continue
 			}
 
-			Yyerror("non-octal character in escape sequence: %c", c)
+			yyerror("non-octal character in escape sequence: %c", c)
 			l.ungetr()
 		}
 
 		if x > 255 {
-			Yyerror("octal escape value > 255: %d", x)
+			yyerror("octal escape value > 255: %d", x)
 		}
 
 		return 0, byte(x), true
@@ -1211,7 +1211,7 @@ func (l *lexer) onechar(quote rune) (r rune, b byte, ok bool) {
 
 	default:
 		if c != quote {
-			Yyerror("unknown escape sequence: %c", c)
+			yyerror("unknown escape sequence: %c", c)
 		}
 	}
 
@@ -1221,7 +1221,7 @@ func (l *lexer) onechar(quote rune) (r rune, b byte, ok bool) {
 func (l *lexer) unichar(n int) rune {
 	x := l.hexchar(n)
 	if x > utf8.MaxRune || 0xd800 <= x && x < 0xe000 {
-		Yyerror("invalid Unicode code point in escape sequence: %#x", x)
+		yyerror("invalid Unicode code point in escape sequence: %#x", x)
 		x = utf8.RuneError
 	}
 	return rune(x)
@@ -1240,7 +1240,7 @@ func (l *lexer) hexchar(n int) uint32 {
 		case 'A' <= c && c <= 'F':
 			d = uint32(c - 'A' + 10)
 		default:
-			Yyerror("non-hex character in escape sequence: %c", c)
+			yyerror("non-hex character in escape sequence: %c", c)
 			l.ungetr()
 			return x
 		}
diff --git a/src/cmd/compile/internal/gc/main.go b/src/cmd/compile/internal/gc/main.go
index c12664c660..89c9e1c394 100644
--- a/src/cmd/compile/internal/gc/main.go
+++ b/src/cmd/compile/internal/gc/main.go
@@ -106,7 +106,7 @@ func Main() {
 	defer hidePanic()
 
 	Ctxt = obj.Linknew(Thearch.LinkArch)
-	Ctxt.DiagFunc = Yyerror
+	Ctxt.DiagFunc = yyerror
 	Ctxt.Bso = bufio.NewWriter(os.Stdout)
 
 	localpkg = mkpkg("")
@@ -506,7 +506,7 @@ func Main() {
 		errorexit()
 	}
 
-	Flusherrors()
+	flusherrors()
 	timings.Stop()
 
 	if benchfile != "" {
@@ -631,7 +631,7 @@ func findpkg(name string) (file string, ok bool) {
 	// don't want to see "encoding/../encoding/base64"
 	// as different from "encoding/base64".
 	if q := path.Clean(name); q != name {
-		Yyerror("non-canonical import path %q (should be %q)", name, q)
+		yyerror("non-canonical import path %q (should be %q)", name, q)
 		return "", false
 	}
 
@@ -698,12 +698,12 @@ func importfile(f *Val, indent []byte) {
 
 	path_, ok := f.U.(string)
 	if !ok {
-		Yyerror("import statement not a string")
+		yyerror("import statement not a string")
 		return
 	}
 
 	if len(path_) == 0 {
-		Yyerror("import path is empty")
+		yyerror("import path is empty")
 		return
 	}
 
@@ -716,12 +716,12 @@ func importfile(f *Val, indent []byte) {
 	// the main package, just as we reserve the import
 	// path "math" to identify the standard math package.
 	if path_ == "main" {
-		Yyerror("cannot import \"main\"")
+		yyerror("cannot import \"main\"")
 		errorexit()
 	}
 
 	if myimportpath != "" && path_ == myimportpath {
-		Yyerror("import %q while compiling that package (import cycle)", path_)
+		yyerror("import %q while compiling that package (import cycle)", path_)
 		errorexit()
 	}
 
@@ -731,7 +731,7 @@ func importfile(f *Val, indent []byte) {
 
 	if path_ == "unsafe" {
 		if safemode {
-			Yyerror("cannot import package unsafe")
+			yyerror("cannot import package unsafe")
 			errorexit()
 		}
 
@@ -742,7 +742,7 @@ func importfile(f *Val, indent []byte) {
 
 	if islocalname(path_) {
 		if path_[0] == '/' {
-			Yyerror("import path cannot be absolute path")
+			yyerror("import path cannot be absolute path")
 			return
 		}
 
@@ -759,7 +759,7 @@ func importfile(f *Val, indent []byte) {
 
 	file, found := findpkg(path_)
 	if !found {
-		Yyerror("can't find import: %q", path_)
+		yyerror("can't find import: %q", path_)
 		errorexit()
 	}
 
@@ -773,7 +773,7 @@ func importfile(f *Val, indent []byte) {
 
 	impf, err := os.Open(file)
 	if err != nil {
-		Yyerror("can't open import: %q: %v", path_, err)
+		yyerror("can't open import: %q: %v", path_, err)
 		errorexit()
 	}
 	defer impf.Close()
@@ -781,7 +781,7 @@ func importfile(f *Val, indent []byte) {
 
 	if strings.HasSuffix(file, ".a") {
 		if !skiptopkgdef(imp) {
-			Yyerror("import %s: not a package file", file)
+			yyerror("import %s: not a package file", file)
 			errorexit()
 		}
 	}
@@ -797,13 +797,13 @@ func importfile(f *Val, indent []byte) {
 
 	if p != "empty archive" {
 		if !strings.HasPrefix(p, "go object ") {
-			Yyerror("import %s: not a go object file: %s", file, p)
+			yyerror("import %s: not a go object file: %s", file, p)
 			errorexit()
 		}
 
 		q := fmt.Sprintf("%s %s %s %s", obj.GOOS, obj.GOARCH, obj.Version, obj.Expstring())
 		if p[10:] != q {
-			Yyerror("import %s: object is [%s] expected [%s]", file, p[10:], q)
+			yyerror("import %s: object is [%s] expected [%s]", file, p[10:], q)
 			errorexit()
 		}
 	}
@@ -824,7 +824,7 @@ func importfile(f *Val, indent []byte) {
 		}
 	}
 	if safemode && !safe {
-		Yyerror("cannot import unsafe package %q", importpkg.Path)
+		yyerror("cannot import unsafe package %q", importpkg.Path)
 	}
 
 	// assume files move (get installed)
@@ -857,7 +857,7 @@ func importfile(f *Val, indent []byte) {
 
 	switch c {
 	case '\n':
-		Yyerror("cannot import %s: old export format no longer supported (recompile library)", path_)
+		yyerror("cannot import %s: old export format no longer supported (recompile library)", path_)
 
 	case 'B':
 		if Debug_export != 0 {
@@ -867,7 +867,7 @@ func importfile(f *Val, indent []byte) {
 		Import(imp)
 
 	default:
-		Yyerror("no import in %q", path_)
+		yyerror("no import in %q", path_)
 		errorexit()
 	}
 }
@@ -893,12 +893,12 @@ func pkgnotused(lineno int32, path string, name string) {
 func mkpackage(pkgname string) {
 	if localpkg.Name == "" {
 		if pkgname == "_" {
-			Yyerror("invalid package name _")
+			yyerror("invalid package name _")
 		}
 		localpkg.Name = pkgname
 	} else {
 		if pkgname != localpkg.Name {
-			Yyerror("package %s; expected %s", pkgname, localpkg.Name)
+			yyerror("package %s; expected %s", pkgname, localpkg.Name)
 		}
 		for _, s := range localpkg.Syms {
 			if s.Def == nil {
diff --git a/src/cmd/compile/internal/gc/mpfloat.go b/src/cmd/compile/internal/gc/mpfloat.go
index a0f15a95c8..31d35d64b3 100644
--- a/src/cmd/compile/internal/gc/mpfloat.go
+++ b/src/cmd/compile/internal/gc/mpfloat.go
@@ -128,7 +128,7 @@ func (a *Mpflt) Float64() float64 {
 
 	// check for overflow
 	if math.IsInf(x, 0) && nsavederrors+nerrors == 0 {
-		Yyerror("mpgetflt ovf")
+		yyerror("mpgetflt ovf")
 	}
 
 	return x + 0 // avoid -0 (should not be needed, but be conservative)
@@ -140,7 +140,7 @@ func (a *Mpflt) Float32() float64 {
 
 	// check for overflow
 	if math.IsInf(x, 0) && nsavederrors+nerrors == 0 {
-		Yyerror("mpgetflt32 ovf")
+		yyerror("mpgetflt32 ovf")
 	}
 
 	return x + 0 // avoid -0 (should not be needed, but be conservative)
@@ -187,13 +187,13 @@ func (a *Mpflt) SetString(as string) {
 		// - constant exponent out of range
 		// - decimal point and binary point in constant
 		// TODO(gri) use different conversion function or check separately
-		Yyerror("malformed constant: %s", as)
+		yyerror("malformed constant: %s", as)
 		a.Val.SetFloat64(0)
 		return
 	}
 
 	if f.IsInf() {
-		Yyerror("constant too large: %s", as)
+		yyerror("constant too large: %s", as)
 		a.Val.SetFloat64(0)
 		return
 	}
diff --git a/src/cmd/compile/internal/gc/mpint.go b/src/cmd/compile/internal/gc/mpint.go
index fe37baa1e3..3ae4deeec8 100644
--- a/src/cmd/compile/internal/gc/mpint.go
+++ b/src/cmd/compile/internal/gc/mpint.go
@@ -71,7 +71,7 @@ func (a *Mpint) SetFloat(b *Mpflt) int {
 func (a *Mpint) Add(b *Mpint) {
 	if a.Ovf || b.Ovf {
 		if nsavederrors+nerrors == 0 {
-			Yyerror("ovf in mpaddfixfix")
+			yyerror("ovf in mpaddfixfix")
 		}
 		a.SetOverflow()
 		return
@@ -80,14 +80,14 @@ func (a *Mpint) Add(b *Mpint) {
 	a.Val.Add(&a.Val, &b.Val)
 
 	if a.checkOverflow(0) {
-		Yyerror("constant addition overflow")
+		yyerror("constant addition overflow")
 	}
 }
 
 func (a *Mpint) Sub(b *Mpint) {
 	if a.Ovf || b.Ovf {
 		if nsavederrors+nerrors == 0 {
-			Yyerror("ovf in mpsubfixfix")
+			yyerror("ovf in mpsubfixfix")
 		}
 		a.SetOverflow()
 		return
@@ -96,14 +96,14 @@ func (a *Mpint) Sub(b *Mpint) {
 	a.Val.Sub(&a.Val, &b.Val)
 
 	if a.checkOverflow(0) {
-		Yyerror("constant subtraction overflow")
+		yyerror("constant subtraction overflow")
 	}
 }
 
 func (a *Mpint) Mul(b *Mpint) {
 	if a.Ovf || b.Ovf {
 		if nsavederrors+nerrors == 0 {
-			Yyerror("ovf in mpmulfixfix")
+			yyerror("ovf in mpmulfixfix")
 		}
 		a.SetOverflow()
 		return
@@ -112,14 +112,14 @@ func (a *Mpint) Mul(b *Mpint) {
 	a.Val.Mul(&a.Val, &b.Val)
 
 	if a.checkOverflow(0) {
-		Yyerror("constant multiplication overflow")
+		yyerror("constant multiplication overflow")
 	}
 }
 
 func (a *Mpint) Quo(b *Mpint) {
 	if a.Ovf || b.Ovf {
 		if nsavederrors+nerrors == 0 {
-			Yyerror("ovf in mpdivfixfix")
+			yyerror("ovf in mpdivfixfix")
 		}
 		a.SetOverflow()
 		return
@@ -129,14 +129,14 @@ func (a *Mpint) Quo(b *Mpint) {
 
 	if a.checkOverflow(0) {
 		// can only happen for div-0 which should be checked elsewhere
-		Yyerror("constant division overflow")
+		yyerror("constant division overflow")
 	}
 }
 
 func (a *Mpint) Rem(b *Mpint) {
 	if a.Ovf || b.Ovf {
 		if nsavederrors+nerrors == 0 {
-			Yyerror("ovf in mpmodfixfix")
+			yyerror("ovf in mpmodfixfix")
 		}
 		a.SetOverflow()
 		return
@@ -146,14 +146,14 @@ func (a *Mpint) Rem(b *Mpint) {
 
 	if a.checkOverflow(0) {
 		// should never happen
-		Yyerror("constant modulo overflow")
+		yyerror("constant modulo overflow")
 	}
 }
 
 func (a *Mpint) Or(b *Mpint) {
 	if a.Ovf || b.Ovf {
 		if nsavederrors+nerrors == 0 {
-			Yyerror("ovf in mporfixfix")
+			yyerror("ovf in mporfixfix")
 		}
 		a.SetOverflow()
 		return
@@ -165,7 +165,7 @@ func (a *Mpint) Or(b *Mpint) {
 func (a *Mpint) And(b *Mpint) {
 	if a.Ovf || b.Ovf {
 		if nsavederrors+nerrors == 0 {
-			Yyerror("ovf in mpandfixfix")
+			yyerror("ovf in mpandfixfix")
 		}
 		a.SetOverflow()
 		return
@@ -177,7 +177,7 @@ func (a *Mpint) And(b *Mpint) {
 func (a *Mpint) AndNot(b *Mpint) {
 	if a.Ovf || b.Ovf {
 		if nsavederrors+nerrors == 0 {
-			Yyerror("ovf in mpandnotfixfix")
+			yyerror("ovf in mpandnotfixfix")
 		}
 		a.SetOverflow()
 		return
@@ -189,7 +189,7 @@ func (a *Mpint) AndNot(b *Mpint) {
 func (a *Mpint) Xor(b *Mpint) {
 	if a.Ovf || b.Ovf {
 		if nsavederrors+nerrors == 0 {
-			Yyerror("ovf in mpxorfixfix")
+			yyerror("ovf in mpxorfixfix")
 		}
 		a.SetOverflow()
 		return
@@ -201,7 +201,7 @@ func (a *Mpint) Xor(b *Mpint) {
 func (a *Mpint) Lsh(b *Mpint) {
 	if a.Ovf || b.Ovf {
 		if nsavederrors+nerrors == 0 {
-			Yyerror("ovf in mplshfixfix")
+			yyerror("ovf in mplshfixfix")
 		}
 		a.SetOverflow()
 		return
@@ -213,13 +213,13 @@ func (a *Mpint) Lsh(b *Mpint) {
 		if s < 0 {
 			msg = "invalid negative shift count"
 		}
-		Yyerror("%s: %d", msg, s)
+		yyerror("%s: %d", msg, s)
 		a.SetInt64(0)
 		return
 	}
 
 	if a.checkOverflow(int(s)) {
-		Yyerror("constant shift overflow")
+		yyerror("constant shift overflow")
 		return
 	}
 	a.Val.Lsh(&a.Val, uint(s))
@@ -228,7 +228,7 @@ func (a *Mpint) Lsh(b *Mpint) {
 func (a *Mpint) Rsh(b *Mpint) {
 	if a.Ovf || b.Ovf {
 		if nsavederrors+nerrors == 0 {
-			Yyerror("ovf in mprshfixfix")
+			yyerror("ovf in mprshfixfix")
 		}
 		a.SetOverflow()
 		return
@@ -236,7 +236,7 @@ func (a *Mpint) Rsh(b *Mpint) {
 
 	s := b.Int64()
 	if s < 0 {
-		Yyerror("invalid negative shift count: %d", s)
+		yyerror("invalid negative shift count: %d", s)
 		if a.Val.Sign() < 0 {
 			a.SetInt64(-1)
 		} else {
@@ -266,7 +266,7 @@ func (a *Mpint) Neg() {
 func (a *Mpint) Int64() int64 {
 	if a.Ovf {
 		if nsavederrors+nerrors == 0 {
-			Yyerror("constant overflow")
+			yyerror("constant overflow")
 		}
 		return 0
 	}
@@ -288,12 +288,12 @@ func (a *Mpint) SetString(as string) {
 		// - malformed octal constant
 		// - malformed decimal constant
 		// TODO(gri) use different conversion function
-		Yyerror("malformed integer constant: %s", as)
+		yyerror("malformed integer constant: %s", as)
 		a.Val.SetUint64(0)
 		return
 	}
 	if a.checkOverflow(0) {
-		Yyerror("constant too large: %s", as)
+		yyerror("constant too large: %s", as)
 	}
 }
 
diff --git a/src/cmd/compile/internal/gc/noder.go b/src/cmd/compile/internal/gc/noder.go
index a42d92a86d..db403f9769 100644
--- a/src/cmd/compile/internal/gc/noder.go
+++ b/src/cmd/compile/internal/gc/noder.go
@@ -119,7 +119,7 @@ func (p *noder) importDecl(imp *syntax.ImportDecl) {
 	if imp.LocalPkgName != nil {
 		my = p.name(imp.LocalPkgName)
 	} else {
-		my = Lookup(ipkg.Name)
+		my = lookup(ipkg.Name)
 	}
 
 	pack := p.nod(imp, OPACK, nil, nil)
@@ -222,7 +222,7 @@ func (p *noder) funcDecl(fun *syntax.FuncDecl) *Node {
 	f.Nbody.Set(body)
 	f.Noescape = pragma&Noescape != 0
 	if f.Noescape && len(body) != 0 {
-		Yyerror("can only use //go:noescape with external func implementations")
+		yyerror("can only use //go:noescape with external func implementations")
 	}
 	f.Func.Pragma = pragma
 	lineno = p.baseline + int32(fun.EndLine) - 1
@@ -243,13 +243,13 @@ func (p *noder) funcHeader(fun *syntax.FuncDecl) *Node {
 		if name.Name == "init" {
 			name = renameinit()
 			if t.List.Len() > 0 || t.Rlist.Len() > 0 {
-				Yyerror("func init must have no arguments and no return values")
+				yyerror("func init must have no arguments and no return values")
 			}
 		}
 
 		if localpkg.Name == "main" && name.Name == "main" {
 			if t.List.Len() > 0 || t.Rlist.Len() > 0 {
-				Yyerror("func main must have no arguments and no return values")
+				yyerror("func main must have no arguments and no return values")
 			}
 		}
 
@@ -300,9 +300,9 @@ func (p *noder) param(param *syntax.Field, dddOk, final bool) *Node {
 	// rewrite ...T parameter
 	if typ.Op == ODDD {
 		if !dddOk {
-			Yyerror("cannot use ... in receiver or result parameter list")
+			yyerror("cannot use ... in receiver or result parameter list")
 		} else if !final {
-			Yyerror("can only use ... with final parameter in list")
+			yyerror("can only use ... with final parameter in list")
 		}
 		typ.Op = OTARRAY
 		typ.Right = typ.Left
@@ -371,7 +371,7 @@ func (p *noder) expr(expr syntax.Expr) *Node {
 			obj.Used = true
 			return oldname(s)
 		}
-		return p.setlineno(expr, NodSym(OXDOT, obj, sel))
+		return p.setlineno(expr, nodSym(OXDOT, obj, sel))
 	case *syntax.IndexExpr:
 		return p.nod(expr, OINDEX, p.expr(expr.X), p.expr(expr.Index))
 	case *syntax.SliceExpr:
@@ -449,7 +449,7 @@ func (p *noder) expr(expr syntax.Expr) *Node {
 		if expr.Lhs != nil {
 			n.Left = p.declName(expr.Lhs)
 			if isblank(n.Left) {
-				Yyerror("invalid variable name %v in type switch", n.Left)
+				yyerror("invalid variable name %v in type switch", n.Left)
 			}
 		}
 		return n
@@ -530,7 +530,7 @@ func (p *noder) packname(expr syntax.Expr) *Sym {
 		s := p.name(expr.Sel)
 		var pkg *Pkg
 		if name.Def == nil || name.Def.Op != OPACK {
-			Yyerror("%v is not a package", name)
+			yyerror("%v is not a package", name)
 			pkg = localpkg
 		} else {
 			name.Def.Used = true
@@ -666,7 +666,7 @@ func (p *noder) stmt(stmt syntax.Stmt) *Node {
 					break
 				}
 				if ln.Sym.Def != ln {
-					Yyerror("%s is shadowed during return", ln.Sym.Name)
+					yyerror("%s is shadowed during return", ln.Sym.Name)
 				}
 			}
 		}
@@ -948,7 +948,7 @@ func (p *noder) basicLit(lit *syntax.BasicLit) Val {
 }
 
 func (p *noder) name(name *syntax.Name) *Sym {
-	return Lookup(name.Value)
+	return lookup(name.Value)
 }
 
 func (p *noder) mkname(name *syntax.Name) *Node {
@@ -1034,7 +1034,7 @@ func (p *noder) pragma(pos, line int, text string) syntax.Pragma {
 			p.error(pos, line, "usage: //go:linkname localname linkname")
 			break
 		}
-		Lookup(f[1]).Linkname = f[2]
+		lookup(f[1]).Linkname = f[2]
 
 	case strings.HasPrefix(text, "go:cgo_"):
 		pragcgobuf += pragcgo(text)
@@ -1044,7 +1044,7 @@ func (p *noder) pragma(pos, line int, text string) syntax.Pragma {
 		if i := strings.Index(text, " "); i >= 0 {
 			verb = verb[:i]
 		}
-		return syntax.Pragma(PragmaValue(verb))
+		return syntax.Pragma(pragmaValue(verb))
 	}
 
 	return 0
diff --git a/src/cmd/compile/internal/gc/obj.go b/src/cmd/compile/internal/gc/obj.go
index 7f462010c3..64f8a91f54 100644
--- a/src/cmd/compile/internal/gc/obj.go
+++ b/src/cmd/compile/internal/gc/obj.go
@@ -53,7 +53,7 @@ func dumpobj1(outfile string, mode int) {
 	var err error
 	bout, err = bio.Create(outfile)
 	if err != nil {
-		Flusherrors()
+		flusherrors()
 		fmt.Printf("can't create %s: %v\n", outfile, err)
 		errorexit()
 	}
diff --git a/src/cmd/compile/internal/gc/order.go b/src/cmd/compile/internal/gc/order.go
index 9fa5365a5e..6fcd56e1a1 100644
--- a/src/cmd/compile/internal/gc/order.go
+++ b/src/cmd/compile/internal/gc/order.go
@@ -363,7 +363,7 @@ func ordercall(n *Node, order *Order) {
 	ordercallargs(&n.List, order)
 
 	if n.Op == OCALLFUNC {
-		t, it := IterFields(n.Left.Type.Params())
+		t, it := iterFields(n.Left.Type.Params())
 		for i := range n.List.Slice() {
 			// Check for "unsafe-uintptr" tag provided by escape analysis.
 			// If present and the argument is really a pointer being converted
@@ -815,7 +815,7 @@ func orderstmt(n *Node, order *Order) {
 			if r != nil {
 				switch r.Op {
 				default:
-					Yyerror("unknown op in select %v", r.Op)
+					yyerror("unknown op in select %v", r.Op)
 					Dump("select case", r)
 
 				// If this is case x := <-ch or case x, y := <-ch, the case has
@@ -837,7 +837,7 @@ func orderstmt(n *Node, order *Order) {
 					}
 
 					if r.Ninit.Len() != 0 {
-						Yyerror("ninit on select recv")
+						yyerror("ninit on select recv")
 						dumplist("ninit", r.Ninit)
 					}
 
@@ -899,7 +899,7 @@ func orderstmt(n *Node, order *Order) {
 
 				case OSEND:
 					if r.Ninit.Len() != 0 {
-						Yyerror("ninit on select send")
+						yyerror("ninit on select send")
 						dumplist("ninit", r.Ninit)
 					}
 
diff --git a/src/cmd/compile/internal/gc/parser.go b/src/cmd/compile/internal/gc/parser.go
index 157308d642..f87f167513 100644
--- a/src/cmd/compile/internal/gc/parser.go
+++ b/src/cmd/compile/internal/gc/parser.go
@@ -93,7 +93,7 @@ func (p *parser) syntax_error(msg string) {
 		msg = ", " + msg
 	default:
 		// plain error - we don't care about current token
-		Yyerror("syntax error: %s", msg)
+		yyerror("syntax error: %s", msg)
 		return
 	}
 
@@ -121,7 +121,7 @@ func (p *parser) syntax_error(msg string) {
 		tok = tokstring(p.tok)
 	}
 
-	Yyerror("syntax error: unexpected %s", tok+msg)
+	yyerror("syntax error: unexpected %s", tok+msg)
 }
 
 // Like syntax_error, but reports error at given line rather than current lexer line.
@@ -328,7 +328,7 @@ func (p *parser) importdcl() {
 
 	case '.':
 		// import into my name space
-		my = Lookup(".")
+		my = lookup(".")
 		p.next()
 	}
 
@@ -358,7 +358,7 @@ func (p *parser) importdcl() {
 	ipkg.Direct = true
 
 	if my == nil {
-		my = Lookup(ipkg.Name)
+		my = lookup(ipkg.Name)
 	}
 
 	pack := Nod(OPACK, nil, nil)
@@ -372,7 +372,7 @@ func (p *parser) importdcl() {
 	}
 	if my.Name == "init" {
 		lineno = line
-		Yyerror("cannot import package as init - init must be a func")
+		yyerror("cannot import package as init - init must be a func")
 		return
 	}
 	if my.Name == "_" {
@@ -607,12 +607,12 @@ func (p *parser) simple_stmt(labelOk, rangeOk bool) *Node {
 		if rhs[0].Op == OTYPESW {
 			ts := Nod(OTYPESW, nil, rhs[0].Right)
 			if len(rhs) > 1 {
-				Yyerror("expr.(type) must be alone in list")
+				yyerror("expr.(type) must be alone in list")
 			}
 			if len(lhs) > 1 {
-				Yyerror("argument count mismatch: %d = %d", len(lhs), 1)
+				yyerror("argument count mismatch: %d = %d", len(lhs), 1)
 			} else if (lhs[0].Op != ONAME && lhs[0].Op != OTYPE && lhs[0].Op != ONONAME && (lhs[0].Op != OLITERAL || lhs[0].Name == nil)) || isblank(lhs[0]) {
-				Yyerror("invalid variable name %v in type switch", lhs[0])
+				yyerror("invalid variable name %v in type switch", lhs[0])
 			} else {
 				ts.Left = dclname(lhs[0].Sym)
 			} // it's a colas, so must not re-use an oldname
@@ -866,7 +866,7 @@ func (p *parser) for_header() *Node {
 	if init != nil || post != nil {
 		// init ; test ; incr
 		if post != nil && post.Colas {
-			Yyerror("cannot declare in the for-increment")
+			yyerror("cannot declare in the for-increment")
 		}
 		h := Nod(OFOR, nil, nil)
 		if init != nil {
@@ -932,7 +932,7 @@ func (p *parser) header(for_stmt bool) (init, cond, post *Node) {
 		// accept potential vardcl but complain
 		// (for test/syntax/forvar.go)
 		if for_stmt && p.tok == LVAR {
-			Yyerror("var declaration not allowed in for initializer")
+			yyerror("var declaration not allowed in for initializer")
 			p.next()
 		}
 		init = p.simple_stmt(false, for_stmt)
@@ -992,7 +992,7 @@ func (p *parser) if_stmt() *Node {
 
 	stmt := p.if_header()
 	if stmt.Left == nil {
-		Yyerror("missing condition in if statement")
+		yyerror("missing condition in if statement")
 	}
 
 	stmt.Nbody.Set(p.loop_body("if clause"))
@@ -1192,10 +1192,10 @@ func (p *parser) pseudocall() *Node {
 	case OCALL:
 		return x
 	case OPAREN:
-		Yyerror("expression in go/defer must not be parenthesized")
+		yyerror("expression in go/defer must not be parenthesized")
 		// already progressed, no need to advance
 	default:
-		Yyerror("expression in go/defer must be function call")
+		yyerror("expression in go/defer must be function call")
 		// already progressed, no need to advance
 	}
 	return nil
@@ -1365,7 +1365,7 @@ loop:
 			case 0:
 				i := index[0]
 				if i == nil {
-					Yyerror("missing index in index expression")
+					yyerror("missing index in index expression")
 				}
 				x = Nod(OINDEX, x, i)
 			case 1:
@@ -1373,10 +1373,10 @@ loop:
 				x.SetSliceBounds(index[0], index[1], nil)
 			case 2:
 				if index[1] == nil {
-					Yyerror("middle index required in 3-index slice")
+					yyerror("middle index required in 3-index slice")
 				}
 				if index[2] == nil {
-					Yyerror("final index required in 3-index slice")
+					yyerror("final index required in 3-index slice")
 				}
 				x = Nod(OSLICE3, x, nil)
 				x.SetSliceBounds(index[0], index[1], index[2])
@@ -1581,7 +1581,7 @@ func (p *parser) dotdotdot() *Node {
 		return Nod(ODDD, typ, nil)
 	}
 
-	Yyerror("final argument in variadic function missing type")
+	yyerror("final argument in variadic function missing type")
 	return Nod(ODDD, typenod(typ(TINTER)), nil)
 }
 
@@ -1737,7 +1737,7 @@ func (p *parser) new_dotname(obj *Node) *Node {
 		obj.Used = true
 		return oldname(s)
 	}
-	return NodSym(OXDOT, obj, sel)
+	return nodSym(OXDOT, obj, sel)
 }
 
 func (p *parser) dotname() *Node {
@@ -1815,7 +1815,7 @@ func (p *parser) xfndcl() *Node {
 	f.Nbody.Set(body)
 	f.Noescape = p.pragma&Noescape != 0
 	if f.Noescape && len(body) != 0 {
-		Yyerror("can only use //go:noescape with external func implementations")
+		yyerror("can only use //go:noescape with external func implementations")
 	}
 	f.Func.Pragma = p.pragma
 	f.Func.Endlineno = lineno
@@ -1844,13 +1844,13 @@ func (p *parser) fndcl() *Node {
 		if name.Name == "init" {
 			name = renameinit()
 			if t.List.Len() > 0 || t.Rlist.Len() > 0 {
-				Yyerror("func init must have no arguments and no return values")
+				yyerror("func init must have no arguments and no return values")
 			}
 		}
 
 		if localpkg.Name == "main" && name.Name == "main" {
 			if t.List.Len() > 0 || t.Rlist.Len() > 0 {
-				Yyerror("func main must have no arguments and no return values")
+				yyerror("func main must have no arguments and no return values")
 			}
 		}
 
@@ -1875,17 +1875,17 @@ func (p *parser) fndcl() *Node {
 
 		// check after parsing header for fault-tolerance
 		if recv == nil {
-			Yyerror("method has no receiver")
+			yyerror("method has no receiver")
 			return nil
 		}
 
 		if len(rparam) > 1 {
-			Yyerror("method has multiple receivers")
+			yyerror("method has multiple receivers")
 			return nil
 		}
 
 		if recv.Op != ODCLFIELD {
-			Yyerror("bad receiver in method")
+			yyerror("bad receiver in method")
 			return nil
 		}
 
@@ -2026,7 +2026,7 @@ func (p *parser) structdcl() []*Node {
 
 			field.Right = Nod(OIND, field.Right, nil)
 			field.SetVal(tag)
-			Yyerror("cannot parenthesize embedded type")
+			yyerror("cannot parenthesize embedded type")
 			return []*Node{field}
 
 		} else {
@@ -2036,7 +2036,7 @@ func (p *parser) structdcl() []*Node {
 			tag := p.oliteral()
 
 			field.SetVal(tag)
-			Yyerror("cannot parenthesize embedded type")
+			yyerror("cannot parenthesize embedded type")
 			return []*Node{field}
 		}
 
@@ -2050,7 +2050,7 @@ func (p *parser) structdcl() []*Node {
 
 			field.Right = Nod(OIND, field.Right, nil)
 			field.SetVal(tag)
-			Yyerror("cannot parenthesize embedded type")
+			yyerror("cannot parenthesize embedded type")
 			return []*Node{field}
 
 		} else {
@@ -2100,7 +2100,7 @@ func (p *parser) packname(name *Sym) *Sym {
 
 		var pkg *Pkg
 		if name.Def == nil || name.Def.Op != OPACK {
-			Yyerror("%v is not a package", name)
+			yyerror("%v is not a package", name)
 			pkg = localpkg
 		} else {
 			name.Def.Used = true
@@ -2168,7 +2168,7 @@ func (p *parser) interfacedcl() *Node {
 		pname := p.packname(nil)
 		p.want(')')
 		n := Nod(ODCLFIELD, nil, oldname(pname))
-		Yyerror("cannot parenthesize embedded type")
+		yyerror("cannot parenthesize embedded type")
 		return n
 
 	default:
@@ -2287,7 +2287,7 @@ func (p *parser) param_list(dddOk bool) []*Node {
 				p.typ = T
 			}
 			if T == nil {
-				Yyerror("mixed named and unnamed function parameters")
+				yyerror("mixed named and unnamed function parameters")
 				break
 			}
 		}
@@ -2314,9 +2314,9 @@ func (p *parser) param_list(dddOk bool) []*Node {
 		// rewrite ...T parameter
 		if typ != nil && typ.Op == ODDD {
 			if !dddOk {
-				Yyerror("cannot use ... in receiver or result parameter list")
+				yyerror("cannot use ... in receiver or result parameter list")
 			} else if i+1 < len(params) {
-				Yyerror("can only use ... with final parameter in list")
+				yyerror("can only use ... with final parameter in list")
 			}
 			typ.Op = OTARRAY
 			typ.Right = typ.Left
@@ -2418,7 +2418,7 @@ func (p *parser) stmt() *Node {
 					break
 				}
 				if ln.Sym.Def != ln {
-					Yyerror("%s is shadowed during return", ln.Sym.Name)
+					yyerror("%s is shadowed during return", ln.Sym.Name)
 				}
 			}
 		}
diff --git a/src/cmd/compile/internal/gc/pgen.go b/src/cmd/compile/internal/gc/pgen.go
index aa81ed2b7e..bf6dc89de6 100644
--- a/src/cmd/compile/internal/gc/pgen.go
+++ b/src/cmd/compile/internal/gc/pgen.go
@@ -19,7 +19,7 @@ var makefuncdatasym_nsym int
 func makefuncdatasym(nameprefix string, funcdatakind int64) *Sym {
 	var nod Node
 
-	sym := LookupN(nameprefix, makefuncdatasym_nsym)
+	sym := lookupN(nameprefix, makefuncdatasym_nsym)
 	makefuncdatasym_nsym++
 	pnod := newname(sym)
 	pnod.Class = PEXTERN
@@ -89,7 +89,7 @@ func gvardefx(n *Node, as obj.As) {
 		Fatalf("gvardef nil")
 	}
 	if n.Op != ONAME {
-		Yyerror("gvardef %#v; %v", n.Op, n)
+		yyerror("gvardef %#v; %v", n.Op, n)
 		return
 	}
 
@@ -132,7 +132,7 @@ func emitptrargsmap() {
 	if Curfn.Func.Nname.Sym.Name == "_" {
 		return
 	}
-	sym := Lookup(fmt.Sprintf("%s.args_stackmap", Curfn.Func.Nname.Sym.Name))
+	sym := lookup(fmt.Sprintf("%s.args_stackmap", Curfn.Func.Nname.Sym.Name))
 
 	nptr := int(Curfn.Type.ArgWidth() / int64(Widthptr))
 	bv := bvalloc(int32(nptr) * 2)
@@ -281,7 +281,7 @@ func allocauto(ptxt *obj.Prog) {
 		}
 		if Stksize >= 1<<31 {
 			setlineno(Curfn)
-			Yyerror("stack frame too large (>2GB)")
+			yyerror("stack frame too large (>2GB)")
 		}
 
 		stkdelta[n] = -Stksize - n.Xoffset
@@ -325,7 +325,7 @@ func compile(fn *Node) {
 
 	if fn.Nbody.Len() == 0 {
 		if pure_go || strings.HasPrefix(fn.Func.Nname.Sym.Name, "init.") {
-			Yyerror("missing function body for %q", fn.Func.Nname.Sym.Name)
+			yyerror("missing function body for %q", fn.Func.Nname.Sym.Name)
 			return
 		}
 
diff --git a/src/cmd/compile/internal/gc/plive.go b/src/cmd/compile/internal/gc/plive.go
index a19a5fc0a6..de59583d8a 100644
--- a/src/cmd/compile/internal/gc/plive.go
+++ b/src/cmd/compile/internal/gc/plive.go
@@ -806,7 +806,7 @@ func checkauto(fn *Node, p *obj.Prog, n *Node) {
 	for _, ln := range fn.Func.Dcl {
 		fmt.Printf("\t%v (%p; class=%d)\n", ln, ln, ln.Class)
 	}
-	Yyerror("checkauto: invariant lost")
+	yyerror("checkauto: invariant lost")
 }
 
 func checkparam(fn *Node, p *obj.Prog, n *Node) {
@@ -823,7 +823,7 @@ func checkparam(fn *Node, p *obj.Prog, n *Node) {
 	for _, ln := range fn.Func.Dcl {
 		fmt.Printf("\t%v (%p; class=%d)\n", ln, ln, ln.Class)
 	}
-	Yyerror("checkparam: invariant lost")
+	yyerror("checkparam: invariant lost")
 }
 
 func checkprog(fn *Node, p *obj.Prog) {
@@ -1423,7 +1423,7 @@ func livenessepilogue(lv *Liveness) {
 		}
 	}
 
-	Flusherrors()
+	flusherrors()
 }
 
 // FNV-1 hash function constants.
diff --git a/src/cmd/compile/internal/gc/racewalk.go b/src/cmd/compile/internal/gc/racewalk.go
index 5f2b1f6e4b..274cdec8b2 100644
--- a/src/cmd/compile/internal/gc/racewalk.go
+++ b/src/cmd/compile/internal/gc/racewalk.go
@@ -230,7 +230,7 @@ func instrumentnode(np **Node, init *Nodes, wr int, skip int) {
 		instrumentnode(&n.Left, init, 0, 0)
 		if n.Left.Type.IsMap() {
 			n1 := Nod(OCONVNOP, n.Left, nil)
-			n1.Type = Ptrto(Types[TUINT8])
+			n1.Type = ptrto(Types[TUINT8])
 			n1 = Nod(OIND, n1, nil)
 			n1 = typecheck(n1, Erv)
 			callinstr(&n1, init, 0, skip)
@@ -375,17 +375,17 @@ func instrumentnode(np **Node, init *Nodes, wr int, skip int) {
 		OAS2RECV,
 		OAS2MAPR,
 		OASOP:
-		Yyerror("instrument: %v must be lowered by now", n.Op)
+		yyerror("instrument: %v must be lowered by now", n.Op)
 
 		goto ret
 
 		// impossible nodes: only appear in backend.
 	case ORROTC, OEXTEND:
-		Yyerror("instrument: %v cannot exist now", n.Op)
+		yyerror("instrument: %v cannot exist now", n.Op)
 		goto ret
 
 	case OGETG:
-		Yyerror("instrument: OGETG can happen only in runtime which we don't instrument")
+		yyerror("instrument: OGETG can happen only in runtime which we don't instrument")
 		goto ret
 
 	case OFOR:
@@ -587,7 +587,7 @@ func uintptraddr(n *Node) *Node {
 
 func detachexpr(n *Node, init *Nodes) *Node {
 	addr := Nod(OADDR, n, nil)
-	l := temp(Ptrto(n.Type))
+	l := temp(ptrto(n.Type))
 	as := Nod(OAS, l, addr)
 	as = typecheck(as, Etop)
 	as = walkexpr(as, init)
diff --git a/src/cmd/compile/internal/gc/range.go b/src/cmd/compile/internal/gc/range.go
index a2d44756cc..9042643837 100644
--- a/src/cmd/compile/internal/gc/range.go
+++ b/src/cmd/compile/internal/gc/range.go
@@ -48,7 +48,7 @@ func typecheckrange(n *Node) {
 	toomany = 0
 	switch t.Etype {
 	default:
-		Yyerror("cannot range over %L", n.Right)
+		yyerror("cannot range over %L", n.Right)
 		goto out
 
 	case TARRAY, TSLICE:
@@ -61,7 +61,7 @@ func typecheckrange(n *Node) {
 
 	case TCHAN:
 		if !t.ChanDir().CanRecv() {
-			Yyerror("invalid operation: range %v (receive from send-only type %v)", n.Right, n.Right.Type)
+			yyerror("invalid operation: range %v (receive from send-only type %v)", n.Right, n.Right.Type)
 			goto out
 		}
 
@@ -77,7 +77,7 @@ func typecheckrange(n *Node) {
 	}
 
 	if n.List.Len() > 2 || toomany != 0 {
-		Yyerror("too many variables in range")
+		yyerror("too many variables in range")
 	}
 
 	v1 = nil
@@ -104,7 +104,7 @@ func typecheckrange(n *Node) {
 		if v1.Name != nil && v1.Name.Defn == n {
 			v1.Type = t1
 		} else if v1.Type != nil && assignop(t1, v1.Type, &why) == 0 {
-			Yyerror("cannot assign type %v to %L in range%s", t1, v1, why)
+			yyerror("cannot assign type %v to %L in range%s", t1, v1, why)
 		}
 		checkassign(n, v1)
 	}
@@ -113,7 +113,7 @@ func typecheckrange(n *Node) {
 		if v2.Name != nil && v2.Name.Defn == n {
 			v2.Type = t2
 		} else if v2.Type != nil && assignop(t2, v2.Type, &why) == 0 {
-			Yyerror("cannot assign type %v to %L in range%s", t2, v2, why)
+			yyerror("cannot assign type %v to %L in range%s", t2, v2, why)
 		}
 		checkassign(n, v2)
 	}
@@ -182,7 +182,7 @@ func walkrange(n *Node) {
 		init = append(init, Nod(OAS, hv1, nil))
 		init = append(init, Nod(OAS, hn, Nod(OLEN, ha, nil)))
 		if v2 != nil {
-			hp = temp(Ptrto(n.Type.Elem()))
+			hp = temp(ptrto(n.Type.Elem()))
 			tmp := Nod(OINDEX, ha, nodintconst(0))
 			tmp.Bounded = true
 			init = append(init, Nod(OAS, hp, Nod(OADDR, tmp, nil)))
@@ -235,20 +235,20 @@ func walkrange(n *Node) {
 
 		fn = substArgTypes(fn, t.Key(), t.Val(), th)
 		init = append(init, mkcall1(fn, nil, nil, typename(t), ha, Nod(OADDR, hit, nil)))
-		n.Left = Nod(ONE, NodSym(ODOT, hit, keysym), nodnil())
+		n.Left = Nod(ONE, nodSym(ODOT, hit, keysym), nodnil())
 
 		fn = syslook("mapiternext")
 		fn = substArgTypes(fn, th)
 		n.Right = mkcall1(fn, nil, nil, Nod(OADDR, hit, nil))
 
-		key := NodSym(ODOT, hit, keysym)
+		key := nodSym(ODOT, hit, keysym)
 		key = Nod(OIND, key, nil)
 		if v1 == nil {
 			body = nil
 		} else if v2 == nil {
 			body = []*Node{Nod(OAS, v1, key)}
 		} else {
-			val := NodSym(ODOT, hit, valsym)
+			val := nodSym(ODOT, hit, valsym)
 			val = Nod(OIND, val, nil)
 			a := Nod(OAS2, nil, nil)
 			a.List.Set([]*Node{v1, v2})
@@ -269,7 +269,7 @@ func walkrange(n *Node) {
 		}
 		hb := temp(Types[TBOOL])
 
-		n.Left = Nod(ONE, hb, Nodbool(false))
+		n.Left = Nod(ONE, hb, nodbool(false))
 		a := Nod(OAS2RECV, nil, nil)
 		a.Typecheck = 1
 		a.List.Set([]*Node{hv1, hb})
@@ -406,13 +406,13 @@ func memclrrange(n, v1, v2, a *Node) bool {
 	n.Left = Nod(ONE, Nod(OLEN, a, nil), nodintconst(0))
 
 	// hp = &a[0]
-	hp := temp(Ptrto(Types[TUINT8]))
+	hp := temp(ptrto(Types[TUINT8]))
 
 	tmp := Nod(OINDEX, a, nodintconst(0))
 	tmp.Bounded = true
 	tmp = Nod(OADDR, tmp, nil)
 	tmp = Nod(OCONVNOP, tmp, nil)
-	tmp.Type = Ptrto(Types[TUINT8])
+	tmp.Type = ptrto(Types[TUINT8])
 	n.Nbody.Append(Nod(OAS, hp, tmp))
 
 	// hn = len(a) * sizeof(elem(a))
diff --git a/src/cmd/compile/internal/gc/reflect.go b/src/cmd/compile/internal/gc/reflect.go
index 916487c42f..020242c07d 100644
--- a/src/cmd/compile/internal/gc/reflect.go
+++ b/src/cmd/compile/internal/gc/reflect.go
@@ -102,10 +102,10 @@ func mapbucket(t *Type) *Type {
 	dowidth(keytype)
 	dowidth(valtype)
 	if keytype.Width > MAXKEYSIZE {
-		keytype = Ptrto(keytype)
+		keytype = ptrto(keytype)
 	}
 	if valtype.Width > MAXVALSIZE {
-		valtype = Ptrto(valtype)
+		valtype = ptrto(valtype)
 	}
 
 	field := make([]*Field, 0, 5)
@@ -149,7 +149,7 @@ func mapbucket(t *Type) *Type {
 	// Arrange for the bucket to have no pointers by changing
 	// the type of the overflow field to uintptr in this case.
 	// See comment on hmap.overflow in ../../../../runtime/hashmap.go.
-	otyp := Ptrto(bucket)
+	otyp := ptrto(bucket)
 	if !haspointers(t.Val()) && !haspointers(t.Key()) && t.Val().Width <= MAXVALSIZE && t.Key().Width <= MAXKEYSIZE {
 		otyp = Types[TUINTPTR]
 	}
@@ -165,7 +165,7 @@ func mapbucket(t *Type) *Type {
 	// Double-check that overflow field is final memory in struct,
 	// with no padding at end. See comment above.
 	if ovf.Offset != bucket.Width-int64(Widthptr) {
-		Yyerror("bad math in mapbucket for %v", t)
+		yyerror("bad math in mapbucket for %v", t)
 	}
 
 	t.MapType().Bucket = bucket
@@ -188,8 +188,8 @@ func hmap(t *Type) *Type {
 		makefield("B", Types[TUINT8]),
 		makefield("noverflow", Types[TUINT16]),
 		makefield("hash0", Types[TUINT32]),
-		makefield("buckets", Ptrto(bucket)),
-		makefield("oldbuckets", Ptrto(bucket)),
+		makefield("buckets", ptrto(bucket)),
+		makefield("oldbuckets", ptrto(bucket)),
 		makefield("nevacuate", Types[TUINTPTR]),
 		makefield("overflow", Types[TUNSAFEPTR]),
 	}
@@ -226,12 +226,12 @@ func hiter(t *Type) *Type {
 	// }
 	// must match ../../../../runtime/hashmap.go:hiter.
 	var field [12]*Field
-	field[0] = makefield("key", Ptrto(t.Key()))
-	field[1] = makefield("val", Ptrto(t.Val()))
-	field[2] = makefield("t", Ptrto(Types[TUINT8]))
-	field[3] = makefield("h", Ptrto(hmap(t)))
-	field[4] = makefield("buckets", Ptrto(mapbucket(t)))
-	field[5] = makefield("bptr", Ptrto(mapbucket(t)))
+	field[0] = makefield("key", ptrto(t.Key()))
+	field[1] = makefield("val", ptrto(t.Val()))
+	field[2] = makefield("t", ptrto(Types[TUINT8]))
+	field[3] = makefield("h", ptrto(hmap(t)))
+	field[4] = makefield("buckets", ptrto(mapbucket(t)))
+	field[5] = makefield("bptr", ptrto(mapbucket(t)))
 	field[6] = makefield("overflow0", Types[TUNSAFEPTR])
 	field[7] = makefield("overflow1", Types[TUNSAFEPTR])
 	field[8] = makefield("startBucket", Types[TUINTPTR])
@@ -245,7 +245,7 @@ func hiter(t *Type) *Type {
 	i.SetFields(field[:])
 	dowidth(i)
 	if i.Width != int64(12*Widthptr) {
-		Yyerror("hash_iter size not correct %d %d", i.Width, 12*Widthptr)
+		yyerror("hash_iter size not correct %d %d", i.Width, 12*Widthptr)
 	}
 	t.MapType().Hiter = i
 	i.StructType().Map = t
@@ -301,7 +301,7 @@ func methods(t *Type) []*Sig {
 	it := t
 
 	if !isdirectiface(it) {
-		it = Ptrto(t)
+		it = ptrto(t)
 	}
 
 	// make list of methods for t,
@@ -830,7 +830,7 @@ func dcommontype(s *Sym, ot int, t *Type) int {
 	}
 
 	var sptr *Sym
-	tptr := Ptrto(t)
+	tptr := ptrto(t)
 	if !t.IsPtr() && (t.Sym != nil || methods(tptr) != nil) {
 		sptr = dtypesym(tptr)
 	}
@@ -972,7 +972,7 @@ func typenamesym(t *Type) *Sym {
 func typename(t *Type) *Node {
 	s := typenamesym(t)
 	n := Nod(OADDR, s.Def, nil)
-	n.Type = Ptrto(s.Def.Type)
+	n.Type = ptrto(s.Def.Type)
 	n.Addable = true
 	n.Ullman = 2
 	n.Typecheck = 1
@@ -995,7 +995,7 @@ func itabname(t, itype *Type) *Node {
 	}
 
 	n := Nod(OADDR, s.Def, nil)
-	n.Type = Ptrto(s.Def.Type)
+	n.Type = ptrto(s.Def.Type)
 	n.Addable = true
 	n.Ullman = 2
 	n.Typecheck = 1
@@ -1385,7 +1385,7 @@ func dumptypestructs() {
 		t := n.Type
 		dtypesym(t)
 		if t.Sym != nil {
-			dtypesym(Ptrto(t))
+			dtypesym(ptrto(t))
 		}
 	}
 
@@ -1458,14 +1458,14 @@ func dumptypestructs() {
 	// but using runtime means fewer copies in .6 files.
 	if myimportpath == "runtime" {
 		for i := EType(1); i <= TBOOL; i++ {
-			dtypesym(Ptrto(Types[i]))
+			dtypesym(ptrto(Types[i]))
 		}
-		dtypesym(Ptrto(Types[TSTRING]))
-		dtypesym(Ptrto(Types[TUNSAFEPTR]))
+		dtypesym(ptrto(Types[TSTRING]))
+		dtypesym(ptrto(Types[TUNSAFEPTR]))
 
 		// emit type structs for error and func(error) string.
 		// The latter is the type of an auto-generated wrapper.
-		dtypesym(Ptrto(errortype))
+		dtypesym(ptrto(errortype))
 
 		dtypesym(functype(nil, []*Node{Nod(ODCLFIELD, nil, typenod(errortype))}, []*Node{Nod(ODCLFIELD, nil, typenod(Types[TSTRING]))}))
 
@@ -1770,7 +1770,7 @@ func zeroaddr(size int64) *Node {
 		s.Def = x
 	}
 	z := Nod(OADDR, s.Def, nil)
-	z.Type = Ptrto(Types[TUINT8])
+	z.Type = ptrto(Types[TUINT8])
 	z.Addable = true
 	z.Typecheck = 1
 	return z
diff --git a/src/cmd/compile/internal/gc/select.go b/src/cmd/compile/internal/gc/select.go
index 41eab334f1..069ac8ad01 100644
--- a/src/cmd/compile/internal/gc/select.go
+++ b/src/cmd/compile/internal/gc/select.go
@@ -24,12 +24,12 @@ func typecheckselect(sel *Node) {
 		if ncase.List.Len() == 0 {
 			// default
 			if def != nil {
-				Yyerror("multiple defaults in select (first at %v)", def.Line())
+				yyerror("multiple defaults in select (first at %v)", def.Line())
 			} else {
 				def = ncase
 			}
 		} else if ncase.List.Len() > 1 {
-			Yyerror("select cases cannot be lists")
+			yyerror("select cases cannot be lists")
 		} else {
 			ncase.List.SetIndex(0, typecheck(ncase.List.Index(0), Etop))
 			n = ncase.List.Index(0)
@@ -38,7 +38,7 @@ func typecheckselect(sel *Node) {
 			setlineno(n)
 			switch n.Op {
 			default:
-				Yyerror("select case must be receive, send or assign recv")
+				yyerror("select case must be receive, send or assign recv")
 
 				// convert x = <-c into OSELRECV(x, <-c).
 			// remove implicit conversions; the eventual assignment
@@ -49,7 +49,7 @@ func typecheckselect(sel *Node) {
 				}
 
 				if n.Right.Op != ORECV {
-					Yyerror("select assignment must have receive on right hand side")
+					yyerror("select assignment must have receive on right hand side")
 					break
 				}
 
@@ -58,7 +58,7 @@ func typecheckselect(sel *Node) {
 				// convert x, ok = <-c into OSELRECV2(x, <-c) with ntest=ok
 			case OAS2RECV:
 				if n.Rlist.First().Op != ORECV {
-					Yyerror("select assignment must have receive on right hand side")
+					yyerror("select assignment must have receive on right hand side")
 					break
 				}
 
@@ -260,7 +260,7 @@ func walkselect(sel *Node) {
 	r = Nod(OAS, selv, nil)
 	r = typecheck(r, Etop)
 	init = append(init, r)
-	var_ = conv(conv(Nod(OADDR, selv, nil), Types[TUNSAFEPTR]), Ptrto(Types[TUINT8]))
+	var_ = conv(conv(Nod(OADDR, selv, nil), Types[TUNSAFEPTR]), ptrto(Types[TUINT8]))
 	r = mkcall("newselect", nil, nil, var_, nodintconst(selv.Type.Width), nodintconst(sel.Xoffset))
 	r = typecheck(r, Etop)
 	init = append(init, r)
@@ -324,28 +324,28 @@ func selecttype(size int32) *Type {
 	// and then cache; and also cache Select per size.
 
 	scase := Nod(OTSTRUCT, nil, nil)
-	scase.List.Append(Nod(ODCLFIELD, newname(Lookup("elem")), typenod(Ptrto(Types[TUINT8]))))
-	scase.List.Append(Nod(ODCLFIELD, newname(Lookup("chan")), typenod(Ptrto(Types[TUINT8]))))
-	scase.List.Append(Nod(ODCLFIELD, newname(Lookup("pc")), typenod(Types[TUINTPTR])))
-	scase.List.Append(Nod(ODCLFIELD, newname(Lookup("kind")), typenod(Types[TUINT16])))
-	scase.List.Append(Nod(ODCLFIELD, newname(Lookup("so")), typenod(Types[TUINT16])))
-	scase.List.Append(Nod(ODCLFIELD, newname(Lookup("receivedp")), typenod(Ptrto(Types[TUINT8]))))
-	scase.List.Append(Nod(ODCLFIELD, newname(Lookup("releasetime")), typenod(Types[TUINT64])))
+	scase.List.Append(Nod(ODCLFIELD, newname(lookup("elem")), typenod(ptrto(Types[TUINT8]))))
+	scase.List.Append(Nod(ODCLFIELD, newname(lookup("chan")), typenod(ptrto(Types[TUINT8]))))
+	scase.List.Append(Nod(ODCLFIELD, newname(lookup("pc")), typenod(Types[TUINTPTR])))
+	scase.List.Append(Nod(ODCLFIELD, newname(lookup("kind")), typenod(Types[TUINT16])))
+	scase.List.Append(Nod(ODCLFIELD, newname(lookup("so")), typenod(Types[TUINT16])))
+	scase.List.Append(Nod(ODCLFIELD, newname(lookup("receivedp")), typenod(ptrto(Types[TUINT8]))))
+	scase.List.Append(Nod(ODCLFIELD, newname(lookup("releasetime")), typenod(Types[TUINT64])))
 	scase = typecheck(scase, Etype)
 	scase.Type.Noalg = true
 	scase.Type.Local = true
 
 	sel := Nod(OTSTRUCT, nil, nil)
-	sel.List.Append(Nod(ODCLFIELD, newname(Lookup("tcase")), typenod(Types[TUINT16])))
-	sel.List.Append(Nod(ODCLFIELD, newname(Lookup("ncase")), typenod(Types[TUINT16])))
-	sel.List.Append(Nod(ODCLFIELD, newname(Lookup("pollorder")), typenod(Ptrto(Types[TUINT8]))))
-	sel.List.Append(Nod(ODCLFIELD, newname(Lookup("lockorder")), typenod(Ptrto(Types[TUINT8]))))
+	sel.List.Append(Nod(ODCLFIELD, newname(lookup("tcase")), typenod(Types[TUINT16])))
+	sel.List.Append(Nod(ODCLFIELD, newname(lookup("ncase")), typenod(Types[TUINT16])))
+	sel.List.Append(Nod(ODCLFIELD, newname(lookup("pollorder")), typenod(ptrto(Types[TUINT8]))))
+	sel.List.Append(Nod(ODCLFIELD, newname(lookup("lockorder")), typenod(ptrto(Types[TUINT8]))))
 	arr := Nod(OTARRAY, nodintconst(int64(size)), scase)
-	sel.List.Append(Nod(ODCLFIELD, newname(Lookup("scase")), arr))
+	sel.List.Append(Nod(ODCLFIELD, newname(lookup("scase")), arr))
 	arr = Nod(OTARRAY, nodintconst(int64(size)), typenod(Types[TUINT16]))
-	sel.List.Append(Nod(ODCLFIELD, newname(Lookup("lockorderarr")), arr))
+	sel.List.Append(Nod(ODCLFIELD, newname(lookup("lockorderarr")), arr))
 	arr = Nod(OTARRAY, nodintconst(int64(size)), typenod(Types[TUINT16]))
-	sel.List.Append(Nod(ODCLFIELD, newname(Lookup("pollorderarr")), arr))
+	sel.List.Append(Nod(ODCLFIELD, newname(lookup("pollorderarr")), arr))
 	sel = typecheck(sel, Etype)
 	sel.Type.Noalg = true
 	sel.Type.Local = true
diff --git a/src/cmd/compile/internal/gc/sinit.go b/src/cmd/compile/internal/gc/sinit.go
index 93b3bc3dce..8ca0acde51 100644
--- a/src/cmd/compile/internal/gc/sinit.go
+++ b/src/cmd/compile/internal/gc/sinit.go
@@ -162,7 +162,7 @@ func foundinitloop(node, visited *Node) {
 	// those errors probably confused us and
 	// there might not be a loop. Let the user
 	// fix those first.
-	Flusherrors()
+	flusherrors()
 	if nerrors > 0 {
 		errorexit()
 	}
@@ -533,7 +533,7 @@ func staticassign(l *Node, r *Node, out *[]*Node) bool {
 				*out = append(*out, Nod(OAS, a, val))
 			}
 			ptr := Nod(OADDR, a, nil)
-			n.Type = Ptrto(val.Type)
+			n.Type = ptrto(val.Type)
 			gdata(&n, ptr, Widthptr)
 		}
 
@@ -571,7 +571,7 @@ const (
 // Callers should set n.Name.Readonly = true on the
 // returned node for readonly nodes.
 func staticname(t *Type) *Node {
-	n := newname(LookupN("statictmp_", statuniqgen))
+	n := newname(lookupN("statictmp_", statuniqgen))
 	statuniqgen++
 	addvar(n, t, PEXTERN)
 	return n
@@ -694,7 +694,7 @@ func fixedlit(ctxt initContext, kind initKind, n *Node, var_ *Node, init *Nodes)
 	case OARRAYLIT, OSLICELIT:
 		indexnode = func(index *Node) *Node { return Nod(OINDEX, var_, index) }
 	case OSTRUCTLIT:
-		indexnode = func(index *Node) *Node { return NodSym(ODOT, var_, index.Sym) }
+		indexnode = func(index *Node) *Node { return nodSym(ODOT, var_, index.Sym) }
 	default:
 		Fatalf("fixedlit bad op: %v", n.Op)
 	}
@@ -805,7 +805,7 @@ func slicelit(ctxt initContext, n *Node, var_ *Node, init *Nodes) {
 	}
 
 	// make new auto *array (3 declare)
-	vauto := temp(Ptrto(t))
+	vauto := temp(ptrto(t))
 
 	// set auto to point at new temp or heap (3 assign)
 	var a *Node
diff --git a/src/cmd/compile/internal/gc/ssa.go b/src/cmd/compile/internal/gc/ssa.go
index f06c440d88..22fe16e801 100644
--- a/src/cmd/compile/internal/gc/ssa.go
+++ b/src/cmd/compile/internal/gc/ssa.go
@@ -98,7 +98,7 @@ func buildssa(fn *Node) *ssa.Func {
 		switch n.Class {
 		case PPARAM, PPARAMOUT:
 			aux := s.lookupSymbol(n, &ssa.ArgSymbol{Typ: n.Type, Node: n})
-			s.decladdrs[n] = s.entryNewValue1A(ssa.OpAddr, Ptrto(n.Type), aux, s.sp)
+			s.decladdrs[n] = s.entryNewValue1A(ssa.OpAddr, ptrto(n.Type), aux, s.sp)
 			if n.Class == PPARAMOUT && s.canSSA(n) {
 				// Save ssa-able PPARAMOUT variables so we can
 				// store them back to the stack at the end of
@@ -1412,7 +1412,7 @@ func (s *state) expr(n *Node) *ssa.Value {
 	switch n.Op {
 	case OARRAYBYTESTRTMP:
 		slice := s.expr(n.Left)
-		ptr := s.newValue1(ssa.OpSlicePtr, Ptrto(Types[TUINT8]), slice)
+		ptr := s.newValue1(ssa.OpSlicePtr, ptrto(Types[TUINT8]), slice)
 		len := s.newValue1(ssa.OpSliceLen, Types[TINT], slice)
 		return s.newValue2(ssa.OpStringMake, n.Type, ptr, len)
 	case OCFUNC:
@@ -1423,7 +1423,7 @@ func (s *state) expr(n *Node) *ssa.Value {
 			// "value" of a function is the address of the function's closure
 			sym := funcsym(n.Sym)
 			aux := &ssa.ExternSymbol{Typ: n.Type, Sym: sym}
-			return s.entryNewValue1A(ssa.OpAddr, Ptrto(n.Type), aux, s.sb)
+			return s.entryNewValue1A(ssa.OpAddr, ptrto(n.Type), aux, s.sb)
 		}
 		if s.canSSA(n) {
 			return s.variable(n, n.Type)
@@ -1912,7 +1912,7 @@ func (s *state) expr(n *Node) *ssa.Value {
 			s.Fatalf("OINDREG of non-SP register %s in expr: %v", obj.Rconv(int(n.Reg)), n)
 			return nil
 		}
-		addr := s.entryNewValue1I(ssa.OpOffPtr, Ptrto(n.Type), n.Xoffset, s.sp)
+		addr := s.entryNewValue1I(ssa.OpOffPtr, ptrto(n.Type), n.Xoffset, s.sp)
 		return s.newValue2(ssa.OpLoad, n.Type, addr, s.mem())
 
 	case OIND:
@@ -1943,7 +1943,7 @@ func (s *state) expr(n *Node) *ssa.Value {
 				len := s.newValue1(ssa.OpStringLen, Types[TINT], a)
 				s.boundsCheck(i, len)
 			}
-			ptrtyp := Ptrto(Types[TUINT8])
+			ptrtyp := ptrto(Types[TUINT8])
 			ptr := s.newValue1(ssa.OpStringPtr, ptrtyp, a)
 			if Isconst(n.Right, CTINT) {
 				ptr = s.newValue1I(ssa.OpOffPtr, ptrtyp, n.Right.Int64(), ptr)
@@ -2118,7 +2118,7 @@ func (s *state) append(n *Node, inplace bool) *ssa.Value {
 	// *(ptr+len+2) = e3
 
 	et := n.Type.Elem()
-	pt := Ptrto(et)
+	pt := ptrto(et)
 
 	// Evaluate slice
 	sn := n.List.First() // the slice node is the first in the list
@@ -2234,7 +2234,7 @@ func (s *state) append(n *Node, inplace bool) *ssa.Value {
 			if haspointers(et) {
 				s.insertWBmove(et, addr, arg.v, n.Lineno, arg.isVolatile)
 			} else {
-				s.vars[&memVar] = s.newValue3I(ssa.OpMove, ssa.TypeMem, SizeAlignAuxInt(et), addr, arg.v, s.mem())
+				s.vars[&memVar] = s.newValue3I(ssa.OpMove, ssa.TypeMem, sizeAlignAuxInt(et), addr, arg.v, s.mem())
 			}
 		}
 	}
@@ -2367,14 +2367,14 @@ func (s *state) assign(left *Node, right *ssa.Value, wb, deref bool, line int32,
 	if deref {
 		// Treat as a mem->mem move.
 		if right == nil {
-			s.vars[&memVar] = s.newValue2I(ssa.OpZero, ssa.TypeMem, SizeAlignAuxInt(t), addr, s.mem())
+			s.vars[&memVar] = s.newValue2I(ssa.OpZero, ssa.TypeMem, sizeAlignAuxInt(t), addr, s.mem())
 			return
 		}
 		if wb {
 			s.insertWBmove(t, addr, right, line, rightIsVolatile)
 			return
 		}
-		s.vars[&memVar] = s.newValue3I(ssa.OpMove, ssa.TypeMem, SizeAlignAuxInt(t), addr, right, s.mem())
+		s.vars[&memVar] = s.newValue3I(ssa.OpMove, ssa.TypeMem, sizeAlignAuxInt(t), addr, right, s.mem())
 		return
 	}
 	// Treat as a store.
@@ -2527,7 +2527,7 @@ func intrinsicInit() {
 			// for the backend instead of slicebytetostringtmp calls
 			// when not instrumenting.
 			slice := s.intrinsicFirstArg(n)
-			ptr := s.newValue1(ssa.OpSlicePtr, Ptrto(Types[TUINT8]), slice)
+			ptr := s.newValue1(ssa.OpSlicePtr, ptrto(Types[TUINT8]), slice)
 			len := s.newValue1(ssa.OpSliceLen, Types[TINT], slice)
 			return s.newValue2(ssa.OpStringMake, n.Type, ptr, len)
 		})),
@@ -2558,9 +2558,9 @@ func intrinsicInit() {
 			return s.newValue1(ssa.OpSelect0, Types[TUINT64], v)
 		}, sys.AMD64, sys.ARM64),
 		intrinsicKey{"runtime/internal/atomic", "Loadp"}: enableOnArch(func(s *state, n *Node) *ssa.Value {
-			v := s.newValue2(ssa.OpAtomicLoadPtr, ssa.MakeTuple(Ptrto(Types[TUINT8]), ssa.TypeMem), s.intrinsicArg(n, 0), s.mem())
+			v := s.newValue2(ssa.OpAtomicLoadPtr, ssa.MakeTuple(ptrto(Types[TUINT8]), ssa.TypeMem), s.intrinsicArg(n, 0), s.mem())
 			s.vars[&memVar] = s.newValue1(ssa.OpSelect1, ssa.TypeMem, v)
-			return s.newValue1(ssa.OpSelect0, Ptrto(Types[TUINT8]), v)
+			return s.newValue1(ssa.OpSelect0, ptrto(Types[TUINT8]), v)
 		}, sys.AMD64, sys.ARM64),
 
 		intrinsicKey{"runtime/internal/atomic", "Store"}: enableOnArch(func(s *state, n *Node) *ssa.Value {
@@ -2818,7 +2818,7 @@ func (s *state) call(n *Node, k callKind) *ssa.Value {
 			s.nilCheck(itab)
 		}
 		itabidx := fn.Xoffset + 3*int64(Widthptr) + 8 // offset of fun field in runtime.itab
-		itab = s.newValue1I(ssa.OpOffPtr, Ptrto(Types[TUINTPTR]), itabidx, itab)
+		itab = s.newValue1I(ssa.OpOffPtr, ptrto(Types[TUINTPTR]), itabidx, itab)
 		if k == callNormal {
 			codeptr = s.newValue2(ssa.OpLoad, Types[TUINTPTR], itab, s.mem())
 		} else {
@@ -2841,7 +2841,7 @@ func (s *state) call(n *Node, k callKind) *ssa.Value {
 		if k != callNormal {
 			argStart += int64(2 * Widthptr)
 		}
-		addr := s.entryNewValue1I(ssa.OpOffPtr, Ptrto(Types[TUINTPTR]), argStart, s.sp)
+		addr := s.entryNewValue1I(ssa.OpOffPtr, ptrto(Types[TUINTPTR]), argStart, s.sp)
 		s.vars[&memVar] = s.newValue3I(ssa.OpStore, ssa.TypeMem, int64(Widthptr), addr, rcvr, s.mem())
 	}
 
@@ -2850,9 +2850,9 @@ func (s *state) call(n *Node, k callKind) *ssa.Value {
 		// Write argsize and closure (args to Newproc/Deferproc).
 		argStart := Ctxt.FixedFrameSize()
 		argsize := s.constInt32(Types[TUINT32], int32(stksize))
-		addr := s.entryNewValue1I(ssa.OpOffPtr, Ptrto(Types[TUINT32]), argStart, s.sp)
+		addr := s.entryNewValue1I(ssa.OpOffPtr, ptrto(Types[TUINT32]), argStart, s.sp)
 		s.vars[&memVar] = s.newValue3I(ssa.OpStore, ssa.TypeMem, 4, addr, argsize, s.mem())
-		addr = s.entryNewValue1I(ssa.OpOffPtr, Ptrto(Types[TUINTPTR]), argStart+int64(Widthptr), s.sp)
+		addr = s.entryNewValue1I(ssa.OpOffPtr, ptrto(Types[TUINTPTR]), argStart+int64(Widthptr), s.sp)
 		s.vars[&memVar] = s.newValue3I(ssa.OpStore, ssa.TypeMem, int64(Widthptr), addr, closure, s.mem())
 		stksize += 2 * int64(Widthptr)
 	}
@@ -2904,7 +2904,7 @@ func (s *state) call(n *Node, k callKind) *ssa.Value {
 		return nil
 	}
 	fp := res.Field(0)
-	return s.entryNewValue1I(ssa.OpOffPtr, Ptrto(fp.Type), fp.Offset+Ctxt.FixedFrameSize(), s.sp)
+	return s.entryNewValue1I(ssa.OpOffPtr, ptrto(fp.Type), fp.Offset+Ctxt.FixedFrameSize(), s.sp)
 }
 
 // etypesign returns the signed-ness of e, for integer/pointer etypes.
@@ -2945,7 +2945,7 @@ func (s *state) lookupSymbol(n *Node, sym interface{}) interface{} {
 // If bounded is true then this address does not require a nil check for its operand
 // even if that would otherwise be implied.
 func (s *state) addr(n *Node, bounded bool) (*ssa.Value, bool) {
-	t := Ptrto(n.Type)
+	t := ptrto(n.Type)
 	switch n.Op {
 	case ONAME:
 		switch n.Class {
@@ -3011,7 +3011,7 @@ func (s *state) addr(n *Node, bounded bool) (*ssa.Value, bool) {
 			if !n.Bounded {
 				s.boundsCheck(i, len)
 			}
-			return s.newValue2(ssa.OpPtrIndex, Ptrto(n.Left.Type.Elem()), a, i), isVolatile
+			return s.newValue2(ssa.OpPtrIndex, ptrto(n.Left.Type.Elem()), a, i), isVolatile
 		}
 	case OIND:
 		return s.exprPtr(n.Left, bounded, n.Lineno), false
@@ -3023,7 +3023,7 @@ func (s *state) addr(n *Node, bounded bool) (*ssa.Value, bool) {
 		return s.newValue1I(ssa.OpOffPtr, t, n.Xoffset, p), false
 	case OCLOSUREVAR:
 		return s.newValue1I(ssa.OpOffPtr, t, n.Xoffset,
-			s.entryNewValue0(ssa.OpGetClosurePtr, Ptrto(Types[TUINT8]))), false
+			s.entryNewValue0(ssa.OpGetClosurePtr, ptrto(Types[TUINT8]))), false
 	case OCONVNOP:
 		addr, isVolatile := s.addr(n.Left, bounded)
 		return s.newValue1(ssa.OpCopy, t, addr), isVolatile // ensure that addr has the right type
@@ -3255,7 +3255,7 @@ func (s *state) rtcall(fn *Node, returns bool, results []*Type, args ...*ssa.Val
 		off = Rnd(off, t.Alignment())
 		ptr := s.sp
 		if off != 0 {
-			ptr = s.newValue1I(ssa.OpOffPtr, Ptrto(t), off, s.sp)
+			ptr = s.newValue1I(ssa.OpOffPtr, ptrto(t), off, s.sp)
 		}
 		res[i] = s.newValue2(ssa.OpLoad, t, ptr, s.mem())
 		off += t.Size()
@@ -3288,7 +3288,7 @@ func (s *state) insertWBmove(t *Type, left, right *ssa.Value, line int32, rightI
 	bEnd := s.f.NewBlock(ssa.BlockPlain)
 
 	aux := &ssa.ExternSymbol{Typ: Types[TBOOL], Sym: syslook("writeBarrier").Sym}
-	flagaddr := s.newValue1A(ssa.OpAddr, Ptrto(Types[TUINT32]), aux, s.sb)
+	flagaddr := s.newValue1A(ssa.OpAddr, ptrto(Types[TUINT32]), aux, s.sb)
 	// Load word, test word, avoiding partial register write from load byte.
 	flag := s.newValue2(ssa.OpLoad, Types[TUINT32], flagaddr, s.mem())
 	flag = s.newValue2(ssa.OpNeq32, Types[TBOOL], flag, s.constInt32(Types[TUINT32], 0))
@@ -3312,7 +3312,7 @@ func (s *state) insertWBmove(t *Type, left, right *ssa.Value, line int32, rightI
 		tmp := temp(t)
 		s.vars[&memVar] = s.newValue1A(ssa.OpVarDef, ssa.TypeMem, tmp, s.mem())
 		tmpaddr, _ := s.addr(tmp, true)
-		s.vars[&memVar] = s.newValue3I(ssa.OpMove, ssa.TypeMem, SizeAlignAuxInt(t), tmpaddr, right, s.mem())
+		s.vars[&memVar] = s.newValue3I(ssa.OpMove, ssa.TypeMem, sizeAlignAuxInt(t), tmpaddr, right, s.mem())
 		// Issue typedmemmove call.
 		taddr := s.newValue1A(ssa.OpAddr, Types[TUINTPTR], &ssa.ExternSymbol{Typ: Types[TUINTPTR], Sym: typenamesym(t)}, s.sb)
 		s.rtcall(typedmemmove, true, nil, taddr, left, tmpaddr)
@@ -3322,7 +3322,7 @@ func (s *state) insertWBmove(t *Type, left, right *ssa.Value, line int32, rightI
 	s.endBlock().AddEdgeTo(bEnd)
 
 	s.startBlock(bElse)
-	s.vars[&memVar] = s.newValue3I(ssa.OpMove, ssa.TypeMem, SizeAlignAuxInt(t), left, right, s.mem())
+	s.vars[&memVar] = s.newValue3I(ssa.OpMove, ssa.TypeMem, sizeAlignAuxInt(t), left, right, s.mem())
 	s.endBlock().AddEdgeTo(bEnd)
 
 	s.startBlock(bEnd)
@@ -3355,7 +3355,7 @@ func (s *state) insertWBstore(t *Type, left, right *ssa.Value, line int32, skip
 	bEnd := s.f.NewBlock(ssa.BlockPlain)
 
 	aux := &ssa.ExternSymbol{Typ: Types[TBOOL], Sym: syslook("writeBarrier").Sym}
-	flagaddr := s.newValue1A(ssa.OpAddr, Ptrto(Types[TUINT32]), aux, s.sb)
+	flagaddr := s.newValue1A(ssa.OpAddr, ptrto(Types[TUINT32]), aux, s.sb)
 	// Load word, test word, avoiding partial register write from load byte.
 	flag := s.newValue2(ssa.OpLoad, Types[TUINT32], flagaddr, s.mem())
 	flag = s.newValue2(ssa.OpNeq32, Types[TBOOL], flag, s.constInt32(Types[TUINT32], 0))
@@ -3395,22 +3395,22 @@ func (s *state) storeTypeScalars(t *Type, left, right *ssa.Value, skip skipMask)
 			return
 		}
 		len := s.newValue1(ssa.OpStringLen, Types[TINT], right)
-		lenAddr := s.newValue1I(ssa.OpOffPtr, Ptrto(Types[TINT]), s.config.IntSize, left)
+		lenAddr := s.newValue1I(ssa.OpOffPtr, ptrto(Types[TINT]), s.config.IntSize, left)
 		s.vars[&memVar] = s.newValue3I(ssa.OpStore, ssa.TypeMem, s.config.IntSize, lenAddr, len, s.mem())
 	case t.IsSlice():
 		if skip&skipLen == 0 {
 			len := s.newValue1(ssa.OpSliceLen, Types[TINT], right)
-			lenAddr := s.newValue1I(ssa.OpOffPtr, Ptrto(Types[TINT]), s.config.IntSize, left)
+			lenAddr := s.newValue1I(ssa.OpOffPtr, ptrto(Types[TINT]), s.config.IntSize, left)
 			s.vars[&memVar] = s.newValue3I(ssa.OpStore, ssa.TypeMem, s.config.IntSize, lenAddr, len, s.mem())
 		}
 		if skip&skipCap == 0 {
 			cap := s.newValue1(ssa.OpSliceCap, Types[TINT], right)
-			capAddr := s.newValue1I(ssa.OpOffPtr, Ptrto(Types[TINT]), 2*s.config.IntSize, left)
+			capAddr := s.newValue1I(ssa.OpOffPtr, ptrto(Types[TINT]), 2*s.config.IntSize, left)
 			s.vars[&memVar] = s.newValue3I(ssa.OpStore, ssa.TypeMem, s.config.IntSize, capAddr, cap, s.mem())
 		}
 	case t.IsInterface():
 		// itab field doesn't need a write barrier (even though it is a pointer).
-		itab := s.newValue1(ssa.OpITab, Ptrto(Types[TUINT8]), right)
+		itab := s.newValue1(ssa.OpITab, ptrto(Types[TUINT8]), right)
 		s.vars[&memVar] = s.newValue3I(ssa.OpStore, ssa.TypeMem, s.config.IntSize, left, itab, s.mem())
 	case t.IsStruct():
 		n := t.NumFields()
@@ -3431,15 +3431,15 @@ func (s *state) storeTypePtrs(t *Type, left, right *ssa.Value) {
 	case t.IsPtrShaped():
 		s.vars[&memVar] = s.newValue3I(ssa.OpStore, ssa.TypeMem, s.config.PtrSize, left, right, s.mem())
 	case t.IsString():
-		ptr := s.newValue1(ssa.OpStringPtr, Ptrto(Types[TUINT8]), right)
+		ptr := s.newValue1(ssa.OpStringPtr, ptrto(Types[TUINT8]), right)
 		s.vars[&memVar] = s.newValue3I(ssa.OpStore, ssa.TypeMem, s.config.PtrSize, left, ptr, s.mem())
 	case t.IsSlice():
-		ptr := s.newValue1(ssa.OpSlicePtr, Ptrto(Types[TUINT8]), right)
+		ptr := s.newValue1(ssa.OpSlicePtr, ptrto(Types[TUINT8]), right)
 		s.vars[&memVar] = s.newValue3I(ssa.OpStore, ssa.TypeMem, s.config.PtrSize, left, ptr, s.mem())
 	case t.IsInterface():
 		// itab field is treated as a scalar.
-		idata := s.newValue1(ssa.OpIData, Ptrto(Types[TUINT8]), right)
-		idataAddr := s.newValue1I(ssa.OpOffPtr, Ptrto(Types[TUINT8]), s.config.PtrSize, left)
+		idata := s.newValue1(ssa.OpIData, ptrto(Types[TUINT8]), right)
+		idataAddr := s.newValue1I(ssa.OpOffPtr, ptrto(Types[TUINT8]), s.config.PtrSize, left)
 		s.vars[&memVar] = s.newValue3I(ssa.OpStore, ssa.TypeMem, s.config.PtrSize, idataAddr, idata, s.mem())
 	case t.IsStruct():
 		n := t.NumFields()
@@ -3463,14 +3463,14 @@ func (s *state) storeTypePtrsWB(t *Type, left, right *ssa.Value) {
 	case t.IsPtrShaped():
 		s.rtcall(writebarrierptr, true, nil, left, right)
 	case t.IsString():
-		ptr := s.newValue1(ssa.OpStringPtr, Ptrto(Types[TUINT8]), right)
+		ptr := s.newValue1(ssa.OpStringPtr, ptrto(Types[TUINT8]), right)
 		s.rtcall(writebarrierptr, true, nil, left, ptr)
 	case t.IsSlice():
-		ptr := s.newValue1(ssa.OpSlicePtr, Ptrto(Types[TUINT8]), right)
+		ptr := s.newValue1(ssa.OpSlicePtr, ptrto(Types[TUINT8]), right)
 		s.rtcall(writebarrierptr, true, nil, left, ptr)
 	case t.IsInterface():
-		idata := s.newValue1(ssa.OpIData, Ptrto(Types[TUINT8]), right)
-		idataAddr := s.newValue1I(ssa.OpOffPtr, Ptrto(Types[TUINT8]), s.config.PtrSize, left)
+		idata := s.newValue1(ssa.OpIData, ptrto(Types[TUINT8]), right)
+		idataAddr := s.newValue1I(ssa.OpOffPtr, ptrto(Types[TUINT8]), s.config.PtrSize, left)
 		s.rtcall(writebarrierptr, true, nil, idataAddr, idata)
 	case t.IsStruct():
 		n := t.NumFields()
@@ -3501,13 +3501,13 @@ func (s *state) slice(t *Type, v, i, j, k *ssa.Value) (p, l, c *ssa.Value) {
 	switch {
 	case t.IsSlice():
 		elemtype = t.Elem()
-		ptrtype = Ptrto(elemtype)
+		ptrtype = ptrto(elemtype)
 		ptr = s.newValue1(ssa.OpSlicePtr, ptrtype, v)
 		len = s.newValue1(ssa.OpSliceLen, Types[TINT], v)
 		cap = s.newValue1(ssa.OpSliceCap, Types[TINT], v)
 	case t.IsString():
 		elemtype = Types[TUINT8]
-		ptrtype = Ptrto(elemtype)
+		ptrtype = ptrto(elemtype)
 		ptr = s.newValue1(ssa.OpStringPtr, ptrtype, v)
 		len = s.newValue1(ssa.OpStringLen, Types[TINT], v)
 		cap = len
@@ -3516,7 +3516,7 @@ func (s *state) slice(t *Type, v, i, j, k *ssa.Value) (p, l, c *ssa.Value) {
 			s.Fatalf("bad ptr to array in slice %v\n", t)
 		}
 		elemtype = t.Elem().Elem()
-		ptrtype = Ptrto(elemtype)
+		ptrtype = ptrto(elemtype)
 		s.nilCheck(v)
 		ptr = v
 		len = s.constInt(Types[TINT], t.Elem().NumElem())
@@ -3821,7 +3821,7 @@ func (s *state) floatToUint(cvttab *f2uCvtTab, n *Node, x *ssa.Value, ft, tt *Ty
 // n is the node for the interface expression.
 // v is the corresponding value.
 func (s *state) ifaceType(n *Node, v *ssa.Value) *ssa.Value {
-	byteptr := Ptrto(Types[TUINT8]) // type used in runtime prototypes for runtime type (*byte)
+	byteptr := ptrto(Types[TUINT8]) // type used in runtime prototypes for runtime type (*byte)
 
 	if n.Type.IsEmptyInterface() {
 		// Have *eface. The type is the first word in the struct.
@@ -3883,7 +3883,7 @@ func (s *state) dottype(n *Node, commaok bool) (res, resok *ssa.Value) {
 	b.SetControl(cond)
 	b.Likely = ssa.BranchLikely
 
-	byteptr := Ptrto(Types[TUINT8])
+	byteptr := ptrto(Types[TUINT8])
 
 	bOk := s.f.NewBlock(ssa.BlockPlain)
 	bFail := s.f.NewBlock(ssa.BlockPlain)
@@ -4402,8 +4402,8 @@ func AddAux2(a *obj.Addr, v *ssa.Value, offset int64) {
 	}
 }
 
-// SizeAlignAuxInt returns an AuxInt encoding the size and alignment of type t.
-func SizeAlignAuxInt(t *Type) int64 {
+// sizeAlignAuxInt returns an AuxInt encoding the size and alignment of type t.
+func sizeAlignAuxInt(t *Type) int64 {
 	return ssa.MakeSizeAndAlign(t.Size(), t.Alignment()).Int64()
 }
 
@@ -4604,7 +4604,7 @@ func (s *ssaExport) TypeFloat64() ssa.Type { return Types[TFLOAT64] }
 func (s *ssaExport) TypeInt() ssa.Type     { return Types[TINT] }
 func (s *ssaExport) TypeUintptr() ssa.Type { return Types[TUINTPTR] }
 func (s *ssaExport) TypeString() ssa.Type  { return Types[TSTRING] }
-func (s *ssaExport) TypeBytePtr() ssa.Type { return Ptrto(Types[TUINT8]) }
+func (s *ssaExport) TypeBytePtr() ssa.Type { return ptrto(Types[TUINT8]) }
 
 // StringData returns a symbol (a *Sym wrapped in an interface) which
 // is the data component of a global string constant containing s.
@@ -4621,7 +4621,7 @@ func (e *ssaExport) Auto(t ssa.Type) ssa.GCNode {
 
 func (e *ssaExport) SplitString(name ssa.LocalSlot) (ssa.LocalSlot, ssa.LocalSlot) {
 	n := name.N.(*Node)
-	ptrType := Ptrto(Types[TUINT8])
+	ptrType := ptrto(Types[TUINT8])
 	lenType := Types[TINT]
 	if n.Class == PAUTO && !n.Addrtaken {
 		// Split this string up into two separate variables.
@@ -4635,7 +4635,7 @@ func (e *ssaExport) SplitString(name ssa.LocalSlot) (ssa.LocalSlot, ssa.LocalSlo
 
 func (e *ssaExport) SplitInterface(name ssa.LocalSlot) (ssa.LocalSlot, ssa.LocalSlot) {
 	n := name.N.(*Node)
-	t := Ptrto(Types[TUINT8])
+	t := ptrto(Types[TUINT8])
 	if n.Class == PAUTO && !n.Addrtaken {
 		// Split this interface up into two separate variables.
 		f := ".itab"
@@ -4652,7 +4652,7 @@ func (e *ssaExport) SplitInterface(name ssa.LocalSlot) (ssa.LocalSlot, ssa.Local
 
 func (e *ssaExport) SplitSlice(name ssa.LocalSlot) (ssa.LocalSlot, ssa.LocalSlot, ssa.LocalSlot) {
 	n := name.N.(*Node)
-	ptrType := Ptrto(name.Type.ElemType().(*Type))
+	ptrType := ptrto(name.Type.ElemType().(*Type))
 	lenType := Types[TINT]
 	if n.Class == PAUTO && !n.Addrtaken {
 		// Split this slice up into three separate variables.
diff --git a/src/cmd/compile/internal/gc/subr.go b/src/cmd/compile/internal/gc/subr.go
index 48ae1a42d6..06d033fad1 100644
--- a/src/cmd/compile/internal/gc/subr.go
+++ b/src/cmd/compile/internal/gc/subr.go
@@ -27,7 +27,7 @@ type Error struct {
 var errors []Error
 
 func errorexit() {
-	Flusherrors()
+	flusherrors()
 	if outfile != "" {
 		os.Remove(outfile)
 	}
@@ -58,7 +58,7 @@ func (x byLineno) Len() int           { return len(x) }
 func (x byLineno) Less(i, j int) bool { return x[i].lineno < x[j].lineno }
 func (x byLineno) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
 
-func Flusherrors() {
+func flusherrors() {
 	Ctxt.Bso.Flush()
 	if len(errors) == 0 {
 		return
@@ -74,7 +74,7 @@ func Flusherrors() {
 
 func hcrash() {
 	if Debug['h'] != 0 {
-		Flusherrors()
+		flusherrors()
 		if outfile != "" {
 			os.Remove(outfile)
 		}
@@ -108,7 +108,7 @@ func yyerrorl(line int32, format string, args ...interface{}) {
 		lasterror.syntax = line
 	} else {
 		// only one of multiple equal non-syntax errors per line
-		// (Flusherrors shows only one of them, so we filter them
+		// (flusherrors shows only one of them, so we filter them
 		// here as best as we can (they may not appear in order)
 		// so that we don't count them here and exit early, and
 		// then have nothing to show for.)
@@ -124,13 +124,13 @@ func yyerrorl(line int32, format string, args ...interface{}) {
 	hcrash()
 	nerrors++
 	if nsavederrors+nerrors >= 10 && Debug['e'] == 0 {
-		Flusherrors()
+		flusherrors()
 		fmt.Printf("%v: too many errors\n", linestr(line))
 		errorexit()
 	}
 }
 
-func Yyerror(format string, args ...interface{}) {
+func yyerror(format string, args ...interface{}) {
 	yyerrorl(lineno, format, args...)
 }
 
@@ -143,12 +143,12 @@ func Warn(fmt_ string, args ...interface{}) {
 func Warnl(line int32, fmt_ string, args ...interface{}) {
 	adderr(line, fmt_, args...)
 	if Debug['m'] != 0 {
-		Flusherrors()
+		flusherrors()
 	}
 }
 
 func Fatalf(fmt_ string, args ...interface{}) {
-	Flusherrors()
+	flusherrors()
 
 	fmt.Printf("%v: internal compiler error: ", linestr(lineno))
 	fmt.Printf(fmt_, args...)
@@ -225,25 +225,25 @@ func setlineno(n *Node) int32 {
 	return lno
 }
 
-func Lookup(name string) *Sym {
+func lookup(name string) *Sym {
 	return localpkg.Lookup(name)
 }
 
-func Lookupf(format string, a ...interface{}) *Sym {
-	return Lookup(fmt.Sprintf(format, a...))
+func lookupf(format string, a ...interface{}) *Sym {
+	return lookup(fmt.Sprintf(format, a...))
 }
 
-func LookupBytes(name []byte) *Sym {
+func lookupBytes(name []byte) *Sym {
 	return localpkg.LookupBytes(name)
 }
 
-// LookupN looks up the symbol starting with prefix and ending with
-// the decimal n. If prefix is too long, LookupN panics.
-func LookupN(prefix string, n int) *Sym {
+// lookupN looks up the symbol starting with prefix and ending with
+// the decimal n. If prefix is too long, lookupN panics.
+func lookupN(prefix string, n int) *Sym {
 	var buf [20]byte // plenty long enough for all current users
 	copy(buf[:], prefix)
 	b := strconv.AppendInt(buf[:len(prefix)], int64(n), 10)
-	return LookupBytes(b)
+	return lookupBytes(b)
 }
 
 // autolabel generates a new Name node for use with
@@ -262,7 +262,7 @@ func autolabel(prefix string) *Node {
 	}
 	n := fn.Func.Label
 	fn.Func.Label++
-	return newname(LookupN(prefix, int(n)))
+	return newname(lookupN(prefix, int(n)))
 }
 
 var initSyms []*Sym
@@ -307,7 +307,7 @@ func Pkglookup(name string, pkg *Pkg) *Sym {
 
 func restrictlookup(name string, pkg *Pkg) *Sym {
 	if !exportname(name) && pkg != localpkg {
-		Yyerror("cannot refer to unexported name %s.%s", pkg.Name, name)
+		yyerror("cannot refer to unexported name %s.%s", pkg.Name, name)
 	}
 	return Pkglookup(name, pkg)
 }
@@ -326,7 +326,7 @@ func importdot(opkg *Pkg, pack *Node) {
 		if !exportname(s.Name) || strings.ContainsRune(s.Name, 0xb7) { // 0xb7 = center dot
 			continue
 		}
-		s1 = Lookup(s.Name)
+		s1 = lookup(s.Name)
 		if s1.Def != nil {
 			pkgerror = fmt.Sprintf("during import %q", opkg.Path)
 			redeclare(s1, pkgerror)
@@ -381,9 +381,9 @@ func Nod(op Op, nleft *Node, nright *Node) *Node {
 	return n
 }
 
-// NodSym makes a Node with Op op and with the Left field set to left
+// nodSym makes a Node with Op op and with the Left field set to left
 // and the Sym field set to sym. This is for ODOT and friends.
-func NodSym(op Op, left *Node, sym *Sym) *Node {
+func nodSym(op Op, left *Node, sym *Sym) *Node {
 	n := Nod(op, left, nil)
 	n.Sym = sym
 	return n
@@ -468,7 +468,7 @@ func nodnil() *Node {
 	return c
 }
 
-func Nodbool(b bool) *Node {
+func nodbool(b bool) *Node {
 	c := nodintconst(0)
 	c.SetVal(Val{b})
 	c.Type = idealbool
@@ -482,13 +482,13 @@ func aindex(b *Node, t *Type) *Type {
 	if b != nil {
 		switch consttype(b) {
 		default:
-			Yyerror("array bound must be an integer expression")
+			yyerror("array bound must be an integer expression")
 
 		case CTINT, CTRUNE:
 			hasbound = true
 			bound = b.Int64()
 			if bound < 0 {
-				Yyerror("array bound must be non negative")
+				yyerror("array bound must be non negative")
 			}
 		}
 	}
@@ -526,7 +526,7 @@ func treecopy(n *Node, lineno int32) *Node {
 		return &m
 
 	case ONONAME:
-		if n.Sym == Lookup("iota") {
+		if n.Sym == lookup("iota") {
 			// Not sure yet whether this is the real iota,
 			// but make a copy of the Node* just in case,
 			// so that all the copies of this const definition
@@ -681,8 +681,8 @@ func eqtype1(t1, t2 *Type, assumedEqual map[typePair]struct{}) bool {
 
 	switch t1.Etype {
 	case TINTER, TSTRUCT:
-		t1, i1 := IterFields(t1)
-		t2, i2 := IterFields(t2)
+		t1, i1 := iterFields(t1)
+		t2, i2 := iterFields(t2)
 		for ; t1 != nil && t2 != nil; t1, t2 = i1.Next(), i2.Next() {
 			if t1.Sym != t2.Sym || t1.Embedded != t2.Embedded || !eqtype1(t1.Type, t2.Type, assumedEqual) || t1.Note != t2.Note {
 				return false
@@ -700,8 +700,8 @@ func eqtype1(t1, t2 *Type, assumedEqual map[typePair]struct{}) bool {
 		// equality, because they're never relevant.
 		for _, f := range paramsResults {
 			// Loop over fields in structs, ignoring argument names.
-			ta, ia := IterFields(f(t1))
-			tb, ib := IterFields(f(t2))
+			ta, ia := iterFields(f(t1))
+			tb, ib := iterFields(f(t2))
 			for ; ta != nil && tb != nil; ta, tb = ia.Next(), ib.Next() {
 				if ta.Isddd != tb.Isddd || !eqtype1(ta.Type, tb.Type, assumedEqual) {
 					return false
@@ -741,8 +741,8 @@ func eqtypenoname(t1 *Type, t2 *Type) bool {
 		return false
 	}
 
-	f1, i1 := IterFields(t1)
-	f2, i2 := IterFields(t2)
+	f1, i1 := iterFields(t1)
+	f2, i2 := iterFields(t2)
 	for {
 		if !eqtype(f1.Type, f2.Type) {
 			return false
@@ -766,7 +766,7 @@ func assignop(src *Type, dst *Type, why *string) Op {
 	// TODO(rsc,lvd): This behaves poorly in the presence of inlining.
 	// https://golang.org/issue/2795
 	if safemode && importpkg == nil && src != nil && src.Etype == TUNSAFEPTR {
-		Yyerror("cannot use unsafe.Pointer")
+		yyerror("cannot use unsafe.Pointer")
 		errorexit()
 	}
 
@@ -985,7 +985,7 @@ func assignconvfn(n *Node, t *Type, context func() string) *Node {
 	}
 
 	if t.Etype == TBLANK && n.Type.Etype == TNIL {
-		Yyerror("use of untyped nil")
+		yyerror("use of untyped nil")
 	}
 
 	old := n
@@ -1015,7 +1015,7 @@ func assignconvfn(n *Node, t *Type, context func() string) *Node {
 	var why string
 	op := assignop(n.Type, t, &why)
 	if op == 0 {
-		Yyerror("cannot use %L as type %v in %s%s", n, t, context(), why)
+		yyerror("cannot use %L as type %v in %s%s", n, t, context(), why)
 		op = OCONV
 	}
 
@@ -1135,9 +1135,9 @@ func initPtrto() {
 	ptrToInt32 = typPtr(Types[TINT32])
 }
 
-// Ptrto returns the Type *t.
+// ptrto returns the Type *t.
 // The returned struct must not be modified.
-func Ptrto(t *Type) *Type {
+func ptrto(t *Type) *Type {
 	if Tptr == 0 {
 		Fatalf("ptrto: no tptr")
 	}
@@ -1268,12 +1268,12 @@ func badtype(op Op, tl *Type, tr *Type) {
 	}
 
 	s := fmt_
-	Yyerror("illegal types for operand: %v%s", op, s)
+	yyerror("illegal types for operand: %v%s", op, s)
 }
 
-// Brcom returns !(op).
-// For example, Brcom(==) is !=.
-func Brcom(op Op) Op {
+// brcom returns !(op).
+// For example, brcom(==) is !=.
+func brcom(op Op) Op {
 	switch op {
 	case OEQ:
 		return ONE
@@ -1292,9 +1292,9 @@ func Brcom(op Op) Op {
 	return op
 }
 
-// Brrev returns reverse(op).
+// brrev returns reverse(op).
 // For example, Brrev(<) is >.
-func Brrev(op Op) Op {
+func brrev(op Op) Op {
 	switch op {
 	case OEQ:
 		return OEQ
@@ -1553,11 +1553,11 @@ func adddot(n *Node) *Node {
 	case path != nil:
 		// rebuild elided dots
 		for c := len(path) - 1; c >= 0; c-- {
-			n.Left = NodSym(ODOT, n.Left, path[c].field.Sym)
+			n.Left = nodSym(ODOT, n.Left, path[c].field.Sym)
 			n.Left.Implicit = true
 		}
 	case ambig:
-		Yyerror("ambiguous selector %v", n)
+		yyerror("ambiguous selector %v", n)
 		n.Left = nil
 	}
 
@@ -1702,7 +1702,7 @@ func structargs(tl *Type, mustname bool) []*Node {
 			// invent a name so that we can refer to it in the trampoline
 			buf := fmt.Sprintf(".anon%d", gen)
 			gen++
-			n = newname(Lookup(buf))
+			n = newname(lookup(buf))
 		} else if t.Sym != nil {
 			n = newname(t.Sym)
 		}
@@ -1758,7 +1758,7 @@ func genwrapper(rcvr *Type, method *Field, newnam *Sym, iface int) {
 	dclcontext = PEXTERN
 	markdcl()
 
-	this := Nod(ODCLFIELD, newname(Lookup(".this")), typenod(rcvr))
+	this := Nod(ODCLFIELD, newname(lookup(".this")), typenod(rcvr))
 	this.Left.Name.Param.Ntype = this.Right
 	in := structargs(method.Type.Params(), true)
 	out := structargs(method.Type.Results(), false)
@@ -1772,7 +1772,7 @@ func genwrapper(rcvr *Type, method *Field, newnam *Sym, iface int) {
 		// Add a dummy padding argument after the
 		// receiver to make up the difference.
 		tpad := typArray(Types[TUINT8], Types[Tptr].Width-rcvr.Width)
-		pad := Nod(ODCLFIELD, newname(Lookup(".pad")), typenod(tpad))
+		pad := Nod(ODCLFIELD, newname(lookup(".pad")), typenod(tpad))
 		l = append(l, pad)
 	}
 
@@ -1821,7 +1821,7 @@ func genwrapper(rcvr *Type, method *Field, newnam *Sym, iface int) {
 		fn.Nbody.Append(n)
 	}
 
-	dot := adddot(NodSym(OXDOT, this.Left, method.Sym))
+	dot := adddot(nodSym(OXDOT, this.Left, method.Sym))
 
 	// generate call
 	// It's not possible to use a tail call when dynamic linking on ppc64le. The
@@ -1886,7 +1886,7 @@ func hashmem(t *Type) *Node {
 	n := newname(sym)
 	n.Class = PFUNC
 	tfn := Nod(OTFUNC, nil, nil)
-	tfn.List.Append(Nod(ODCLFIELD, nil, typenod(Ptrto(t))))
+	tfn.List.Append(Nod(ODCLFIELD, nil, typenod(ptrto(t))))
 	tfn.List.Append(Nod(ODCLFIELD, nil, typenod(Types[TUINTPTR])))
 	tfn.List.Append(Nod(ODCLFIELD, nil, typenod(Types[TUINTPTR])))
 	tfn.Rlist.Append(Nod(ODCLFIELD, nil, typenod(Types[TUINTPTR])))
@@ -1906,7 +1906,7 @@ func ifacelookdot(s *Sym, t *Type, followptr *bool, ignorecase bool) *Field {
 	path, ambig := dotpath(s, t, &m, ignorecase)
 	if path == nil {
 		if ambig {
-			Yyerror("%v.%v is ambiguous", t, s)
+			yyerror("%v.%v is ambiguous", t, s)
 		}
 		return nil
 	}
@@ -1919,7 +1919,7 @@ func ifacelookdot(s *Sym, t *Type, followptr *bool, ignorecase bool) *Field {
 	}
 
 	if m.Type.Etype != TFUNC || m.Type.Recv() == nil {
-		Yyerror("%v.%v is a field, not a method", t, s)
+		yyerror("%v.%v is a field, not a method", t, s)
 		return nil
 	}
 
@@ -1986,7 +1986,7 @@ func implements(t, iface *Type, m, samename **Field, ptr *int) bool {
 
 		if rcvr.IsPtr() && !t0.IsPtr() && !followptr && !isifacemethod(tm.Type) {
 			if false && Debug['r'] != 0 {
-				Yyerror("interface pointer mismatch")
+				yyerror("interface pointer mismatch")
 			}
 
 			*m = im
@@ -2154,40 +2154,40 @@ var reservedimports = []string{
 
 func isbadimport(path string) bool {
 	if strings.Contains(path, "\x00") {
-		Yyerror("import path contains NUL")
+		yyerror("import path contains NUL")
 		return true
 	}
 
 	for _, ri := range reservedimports {
 		if path == ri {
-			Yyerror("import path %q is reserved and cannot be used", path)
+			yyerror("import path %q is reserved and cannot be used", path)
 			return true
 		}
 	}
 
 	for _, r := range path {
 		if r == utf8.RuneError {
-			Yyerror("import path contains invalid UTF-8 sequence: %q", path)
+			yyerror("import path contains invalid UTF-8 sequence: %q", path)
 			return true
 		}
 
 		if r < 0x20 || r == 0x7f {
-			Yyerror("import path contains control character: %q", path)
+			yyerror("import path contains control character: %q", path)
 			return true
 		}
 
 		if r == '\\' {
-			Yyerror("import path contains backslash; use slash: %q", path)
+			yyerror("import path contains backslash; use slash: %q", path)
 			return true
 		}
 
 		if unicode.IsSpace(r) {
-			Yyerror("import path contains space character: %q", path)
+			yyerror("import path contains space character: %q", path)
 			return true
 		}
 
 		if strings.ContainsRune("!\"#$%&'()*,:;<=>?[]^`{|}", r) {
-			Yyerror("import path contains invalid character '%c': %q", r, path)
+			yyerror("import path contains invalid character '%c': %q", r, path)
 			return true
 		}
 	}
@@ -2233,8 +2233,8 @@ func isdirectiface(t *Type) bool {
 
 // itabType loads the _type field from a runtime.itab struct.
 func itabType(itab *Node) *Node {
-	typ := NodSym(ODOTPTR, itab, nil)
-	typ.Type = Ptrto(Types[TUINT8])
+	typ := nodSym(ODOTPTR, itab, nil)
+	typ.Type = ptrto(Types[TUINT8])
 	typ.Typecheck = 1
 	typ.Xoffset = int64(Widthptr) // offset of _type in runtime.itab
 	typ.Bounded = true            // guaranteed not to fault
@@ -2245,13 +2245,13 @@ func itabType(itab *Node) *Node {
 // The concrete type must be known to have type t.
 // It follows the pointer if !isdirectiface(t).
 func ifaceData(n *Node, t *Type) *Node {
-	ptr := NodSym(OIDATA, n, nil)
+	ptr := nodSym(OIDATA, n, nil)
 	if isdirectiface(t) {
 		ptr.Type = t
 		ptr.Typecheck = 1
 		return ptr
 	}
-	ptr.Type = Ptrto(t)
+	ptr.Type = ptrto(t)
 	ptr.Bounded = true
 	ptr.Typecheck = 1
 	ind := Nod(OIND, ptr, nil)
diff --git a/src/cmd/compile/internal/gc/swt.go b/src/cmd/compile/internal/gc/swt.go
index 4af0de368f..9c984ee1ec 100644
--- a/src/cmd/compile/internal/gc/swt.go
+++ b/src/cmd/compile/internal/gc/swt.go
@@ -68,7 +68,7 @@ func typecheckswitch(n *Node) {
 		n.Left.Right = typecheck(n.Left.Right, Erv)
 		t = n.Left.Right.Type
 		if t != nil && !t.IsInterface() {
-			Yyerror("cannot type switch on non-interface value %L", n.Left.Right)
+			yyerror("cannot type switch on non-interface value %L", n.Left.Right)
 		}
 	} else {
 		// expression switch
@@ -83,14 +83,14 @@ func typecheckswitch(n *Node) {
 		if t != nil {
 			switch {
 			case !okforeq[t.Etype]:
-				Yyerror("cannot switch on %L", n.Left)
+				yyerror("cannot switch on %L", n.Left)
 			case t.IsSlice():
 				nilonly = "slice"
 			case t.IsArray() && !t.IsComparable():
-				Yyerror("cannot switch on %L", n.Left)
+				yyerror("cannot switch on %L", n.Left)
 			case t.IsStruct():
 				if f := t.IncomparableField(); f != nil {
-					Yyerror("cannot switch on %L (struct containing %v cannot be compared)", n.Left, f.Type)
+					yyerror("cannot switch on %L (struct containing %v cannot be compared)", n.Left, f.Type)
 				}
 			case t.Etype == TFUNC:
 				nilonly = "func"
@@ -109,7 +109,7 @@ func typecheckswitch(n *Node) {
 			// default
 			if def != nil {
 				setlineno(ncase)
-				Yyerror("multiple defaults in switch (first at %v)", def.Line())
+				yyerror("multiple defaults in switch (first at %v)", def.Line())
 			} else {
 				def = ncase
 			}
@@ -130,17 +130,17 @@ func typecheckswitch(n *Node) {
 					n1 = ls[i1]
 					switch {
 					case n1.Op == OTYPE:
-						Yyerror("type %v is not an expression", n1.Type)
+						yyerror("type %v is not an expression", n1.Type)
 					case n1.Type != nil && assignop(n1.Type, t, nil) == 0 && assignop(t, n1.Type, nil) == 0:
 						if n.Left != nil {
-							Yyerror("invalid case %v in switch on %v (mismatched types %v and %v)", n1, n.Left, n1.Type, t)
+							yyerror("invalid case %v in switch on %v (mismatched types %v and %v)", n1, n.Left, n1.Type, t)
 						} else {
-							Yyerror("invalid case %v in switch (mismatched types %v and bool)", n1, n1.Type)
+							yyerror("invalid case %v in switch (mismatched types %v and bool)", n1, n1.Type)
 						}
 					case nilonly != "" && !isnil(n1):
-						Yyerror("invalid case %v in switch (can only compare %s %v to nil)", n1, nilonly, n.Left)
+						yyerror("invalid case %v in switch (can only compare %s %v to nil)", n1, nilonly, n.Left)
 					case t.IsInterface() && !n1.Type.IsInterface() && !n1.Type.IsComparable():
-						Yyerror("invalid case %L in switch (incomparable type)", n1)
+						yyerror("invalid case %L in switch (incomparable type)", n1)
 					}
 
 				// type switch
@@ -151,21 +151,21 @@ func typecheckswitch(n *Node) {
 					case n1.Op == OLITERAL && n1.Type.IsKind(TNIL):
 						// case nil:
 						if niltype != nil {
-							Yyerror("multiple nil cases in type switch (first at %v)", niltype.Line())
+							yyerror("multiple nil cases in type switch (first at %v)", niltype.Line())
 						} else {
 							niltype = ncase
 						}
 					case n1.Op != OTYPE && n1.Type != nil: // should this be ||?
-						Yyerror("%L is not a type", n1)
+						yyerror("%L is not a type", n1)
 						// reset to original type
 						n1 = n.Left.Right
 						ls[i1] = n1
 					case !n1.Type.IsInterface() && t.IsInterface() && !implements(n1.Type, t, &missing, &have, &ptr):
 						if have != nil && !missing.Broke && !have.Broke {
-							Yyerror("impossible type switch case: %L cannot have dynamic type %v"+
+							yyerror("impossible type switch case: %L cannot have dynamic type %v"+
 								" (wrong type for %v method)\n\thave %v%S\n\twant %v%S", n.Left.Right, n1.Type, missing.Sym, have.Sym, have.Type, missing.Sym, missing.Type)
 						} else if !missing.Broke {
-							Yyerror("impossible type switch case: %L cannot have dynamic type %v"+
+							yyerror("impossible type switch case: %L cannot have dynamic type %v"+
 								" (missing %v method)", n.Left.Right, n1.Type, missing.Sym)
 						}
 					}
@@ -200,7 +200,7 @@ func typecheckswitch(n *Node) {
 func walkswitch(sw *Node) {
 	// convert switch {...} to switch true {...}
 	if sw.Left == nil {
-		sw.Left = Nodbool(true)
+		sw.Left = nodbool(true)
 		sw.Left = typecheck(sw.Left, Erv)
 	}
 
@@ -241,7 +241,7 @@ func (s *exprSwitch) walk(sw *Node) {
 	// convert the switch into OIF statements
 	var cas []*Node
 	if s.kind == switchKindTrue || s.kind == switchKindFalse {
-		s.exprname = Nodbool(s.kind == switchKindTrue)
+		s.exprname = nodbool(s.kind == switchKindTrue)
 	} else if consttype(cond) >= 0 {
 		// leave constants to enable dead code elimination (issue 9608)
 		s.exprname = cond
@@ -378,7 +378,7 @@ func casebody(sw *Node, typeswvar *Node) {
 		case 0:
 			// default
 			if def != nil {
-				Yyerror("more than one default case")
+				yyerror("more than one default case")
 			}
 			// reuse original default case
 			n.Right = jmp
@@ -454,12 +454,12 @@ func casebody(sw *Node, typeswvar *Node) {
 		if last.Xoffset == n.Xoffset && last.Op == OXFALL {
 			if typeswvar != nil {
 				setlineno(last)
-				Yyerror("cannot fallthrough in type switch")
+				yyerror("cannot fallthrough in type switch")
 			}
 
 			if i+1 >= sw.List.Len() {
 				setlineno(last)
-				Yyerror("cannot fallthrough final case in switch")
+				yyerror("cannot fallthrough final case in switch")
 			}
 
 			last.Op = OFALL
@@ -609,7 +609,7 @@ func (s *exprSwitch) checkDupCases(cc []caseClause) {
 					continue
 				}
 				setlineno(c.node)
-				Yyerror("duplicate case %v in switch\n\tprevious case at %v", prev.Left, prev.Line())
+				yyerror("duplicate case %v in switch\n\tprevious case at %v", prev.Left, prev.Line())
 				continue
 			}
 			if c.node.List.Len() == 2 {
@@ -623,7 +623,7 @@ func (s *exprSwitch) checkDupCases(cc []caseClause) {
 						continue
 					}
 					setlineno(c.node)
-					Yyerror("duplicate case %v in switch\n\tprevious case at %v", prev.Left, prev.Line())
+					yyerror("duplicate case %v in switch\n\tprevious case at %v", prev.Left, prev.Line())
 				}
 				continue
 			}
@@ -655,7 +655,7 @@ func (s *exprSwitch) checkDupCases(cc []caseClause) {
 			continue
 		}
 		setlineno(c.node)
-		Yyerror("duplicate case %v in switch\n\tprevious case at %v", prev.Left, prev.Line())
+		yyerror("duplicate case %v in switch\n\tprevious case at %v", prev.Left, prev.Line())
 	}
 }
 
@@ -674,13 +674,13 @@ func (s *typeSwitch) walk(sw *Node) {
 	}
 	if cond.Right == nil {
 		setlineno(sw)
-		Yyerror("type switch must have an assignment")
+		yyerror("type switch must have an assignment")
 		return
 	}
 
 	cond.Right = walkexpr(cond.Right, &sw.Ninit)
 	if !cond.Right.Type.IsInterface() {
-		Yyerror("type switch must be on an interface")
+		yyerror("type switch must be on an interface")
 		return
 	}
 
@@ -739,7 +739,7 @@ func (s *typeSwitch) walk(sw *Node) {
 		typ = itabType(typ)
 	}
 	// Load hash from type.
-	h := NodSym(ODOTPTR, typ, nil)
+	h := nodSym(ODOTPTR, typ, nil)
 	h.Type = Types[TUINT32]
 	h.Typecheck = 1
 	h.Xoffset = int64(2 * Widthptr) // offset of hash in runtime._type
diff --git a/src/cmd/compile/internal/gc/type.go b/src/cmd/compile/internal/gc/type.go
index 71f514dc35..0ec173a058 100644
--- a/src/cmd/compile/internal/gc/type.go
+++ b/src/cmd/compile/internal/gc/type.go
@@ -637,9 +637,9 @@ type Iter struct {
 	s []*Field
 }
 
-// IterFields returns the first field or method in struct or interface type t
+// iterFields returns the first field or method in struct or interface type t
 // and an Iter value to continue iterating across the rest.
-func IterFields(t *Type) (*Field, Iter) {
+func iterFields(t *Type) (*Field, Iter) {
 	return t.Fields().Iter()
 }
 
@@ -978,8 +978,8 @@ func (t *Type) cmp(x *Type) ssa.Cmp {
 
 		fallthrough
 	case TINTER:
-		t1, ti := IterFields(t)
-		x1, xi := IterFields(x)
+		t1, ti := iterFields(t)
+		x1, xi := iterFields(x)
 		for ; t1 != nil && x1 != nil; t1, x1 = ti.Next(), xi.Next() {
 			if t1.Embedded != x1.Embedded {
 				return cmpForNe(t1.Embedded < x1.Embedded)
@@ -1002,8 +1002,8 @@ func (t *Type) cmp(x *Type) ssa.Cmp {
 	case TFUNC:
 		for _, f := range recvsParamsResults {
 			// Loop over fields in structs, ignoring argument names.
-			ta, ia := IterFields(f(t))
-			tb, ib := IterFields(f(x))
+			ta, ia := iterFields(f(t))
+			tb, ib := iterFields(f(x))
 			for ; ta != nil && tb != nil; ta, tb = ia.Next(), ib.Next() {
 				if ta.Isddd != tb.Isddd {
 					return cmpForNe(!ta.Isddd)
@@ -1152,7 +1152,7 @@ func (t *Type) ElemType() ssa.Type {
 	return t.Elem()
 }
 func (t *Type) PtrTo() ssa.Type {
-	return Ptrto(t)
+	return ptrto(t)
 }
 
 func (t *Type) NumFields() int {
diff --git a/src/cmd/compile/internal/gc/typecheck.go b/src/cmd/compile/internal/gc/typecheck.go
index 08b9507330..75aac3136d 100644
--- a/src/cmd/compile/internal/gc/typecheck.go
+++ b/src/cmd/compile/internal/gc/typecheck.go
@@ -157,12 +157,12 @@ func typecheck(n *Node, top int) *Node {
 		// We can already diagnose variables used as types.
 		case ONAME:
 			if top&(Erv|Etype) == Etype {
-				Yyerror("%v is not a type", n)
+				yyerror("%v is not a type", n)
 			}
 
 		case OLITERAL:
 			if top&(Erv|Etype) == Etype {
-				Yyerror("%v is not a type", n)
+				yyerror("%v is not a type", n)
 				break
 			}
 			sprint_depchain(&fmt_, typecheck_tcstack, n, n)
@@ -175,7 +175,7 @@ func typecheck(n *Node, top int) *Node {
 				x := typecheck_tcstack[i]
 				fmt_ += fmt.Sprintf("\n\t%v %v", x.Line(), x)
 			}
-			Yyerror("typechecking loop involving %v%s", n, fmt_)
+			yyerror("typechecking loop involving %v%s", n, fmt_)
 		}
 
 		lineno = lno
@@ -258,7 +258,7 @@ func typecheck1(n *Node, top int) *Node {
 	default:
 		if n.Sym != nil {
 			if n.Op == ONAME && n.Etype != 0 && top&Ecall == 0 {
-				Yyerror("use of builtin %v not in function call", n.Sym)
+				yyerror("use of builtin %v not in function call", n.Sym)
 				n.Type = nil
 				return n
 			}
@@ -305,7 +305,7 @@ OpSwitch:
 		if top&Easgn == 0 {
 			// not a write to the variable
 			if isblank(n) {
-				Yyerror("cannot use _ as value")
+				yyerror("cannot use _ as value")
 				n.Type = nil
 				return n
 			}
@@ -314,7 +314,7 @@ OpSwitch:
 		}
 
 		if top&Ecall == 0 && isunsafebuiltin(n) {
-			Yyerror("%v is not an expression, must be called", n)
+			yyerror("%v is not an expression, must be called", n)
 			n.Type = nil
 			return n
 		}
@@ -323,7 +323,7 @@ OpSwitch:
 		break OpSwitch
 
 	case OPACK:
-		Yyerror("use of package %v without selector", n.Sym)
+		yyerror("use of package %v without selector", n.Sym)
 		n.Type = nil
 		return n
 
@@ -356,7 +356,7 @@ OpSwitch:
 			if top&Ecomplit == 0 && n.Diag == 0 {
 				t.Broke = true
 				n.Diag = 1
-				Yyerror("use of [...] array outside of array literal")
+				yyerror("use of [...] array outside of array literal")
 			}
 		} else {
 			n.Left = typecheck(n.Left, Erv)
@@ -371,22 +371,22 @@ OpSwitch:
 
 			default:
 				if l.Type != nil && l.Type.IsInteger() && l.Op != OLITERAL {
-					Yyerror("non-constant array bound %v", l)
+					yyerror("non-constant array bound %v", l)
 				} else {
-					Yyerror("invalid array bound %v", l)
+					yyerror("invalid array bound %v", l)
 				}
 				n.Type = nil
 				return n
 			}
 
 			if doesoverflow(v, Types[TINT]) {
-				Yyerror("array bound is too large")
+				yyerror("array bound is too large")
 				n.Type = nil
 				return n
 			}
 			bound := v.U.(*Mpint).Int64()
 			if bound < 0 {
-				Yyerror("array bound must be non-negative")
+				yyerror("array bound must be non-negative")
 				n.Type = nil
 				return n
 			}
@@ -422,7 +422,7 @@ OpSwitch:
 				mapqueue = append(mapqueue, mapqueueval{l, n.Lineno})
 			} else if bad.Etype != TANY {
 				// no need to queue, key is already bad
-				Yyerror("invalid map key type %v", l.Type)
+				yyerror("invalid map key type %v", l.Type)
 			}
 		}
 		n.Left = nil
@@ -483,14 +483,14 @@ OpSwitch:
 		if l.Op == OTYPE {
 			ok |= Etype
 			n.Op = OTYPE
-			n.Type = Ptrto(l.Type)
+			n.Type = ptrto(l.Type)
 			n.Left = nil
 			break OpSwitch
 		}
 
 		if !t.IsPtr() {
 			if top&(Erv|Etop) != 0 {
-				Yyerror("invalid indirect of %L", n.Left)
+				yyerror("invalid indirect of %L", n.Left)
 				n.Type = nil
 				return n
 			}
@@ -539,7 +539,7 @@ OpSwitch:
 				return n
 			}
 			if n.Implicit && !okforarith[l.Type.Etype] {
-				Yyerror("invalid operation: %v (non-numeric type %v)", n, l.Type)
+				yyerror("invalid operation: %v (non-numeric type %v)", n, l.Type)
 				n.Type = nil
 				return n
 			}
@@ -562,14 +562,14 @@ OpSwitch:
 			n.Right = r
 			t := r.Type
 			if !t.IsInteger() || t.IsSigned() {
-				Yyerror("invalid operation: %v (shift count type %v, must be unsigned integer)", n, r.Type)
+				yyerror("invalid operation: %v (shift count type %v, must be unsigned integer)", n, r.Type)
 				n.Type = nil
 				return n
 			}
 
 			t = l.Type
 			if t != nil && t.Etype != TIDEAL && !t.IsInteger() {
-				Yyerror("invalid operation: %v (shift of type %v)", n, t)
+				yyerror("invalid operation: %v (shift of type %v)", n, t)
 				n.Type = nil
 				return n
 			}
@@ -611,7 +611,7 @@ OpSwitch:
 				aop = assignop(l.Type, r.Type, nil)
 				if aop != 0 {
 					if r.Type.IsInterface() && !l.Type.IsInterface() && !l.Type.IsComparable() {
-						Yyerror("invalid operation: %v (operator %v not defined on %s)", n, op, typekind(l.Type))
+						yyerror("invalid operation: %v (operator %v not defined on %s)", n, op, typekind(l.Type))
 						n.Type = nil
 						return n
 					}
@@ -633,7 +633,7 @@ OpSwitch:
 				aop = assignop(r.Type, l.Type, nil)
 				if aop != 0 {
 					if l.Type.IsInterface() && !r.Type.IsInterface() && !r.Type.IsComparable() {
-						Yyerror("invalid operation: %v (operator %v not defined on %s)", n, op, typekind(r.Type))
+						yyerror("invalid operation: %v (operator %v not defined on %s)", n, op, typekind(r.Type))
 						n.Type = nil
 						return n
 					}
@@ -657,14 +657,14 @@ OpSwitch:
 		if t.Etype != TIDEAL && !eqtype(l.Type, r.Type) {
 			l, r = defaultlit2(l, r, true)
 			if r.Type.IsInterface() == l.Type.IsInterface() || aop == 0 {
-				Yyerror("invalid operation: %v (mismatched types %v and %v)", n, l.Type, r.Type)
+				yyerror("invalid operation: %v (mismatched types %v and %v)", n, l.Type, r.Type)
 				n.Type = nil
 				return n
 			}
 		}
 
 		if !okfor[op][et] {
-			Yyerror("invalid operation: %v (operator %v not defined on %s)", n, op, typekind(t))
+			yyerror("invalid operation: %v (operator %v not defined on %s)", n, op, typekind(t))
 			n.Type = nil
 			return n
 		}
@@ -672,32 +672,32 @@ OpSwitch:
 		// okfor allows any array == array, map == map, func == func.
 		// restrict to slice/map/func == nil and nil == slice/map/func.
 		if l.Type.IsArray() && !l.Type.IsComparable() {
-			Yyerror("invalid operation: %v (%v cannot be compared)", n, l.Type)
+			yyerror("invalid operation: %v (%v cannot be compared)", n, l.Type)
 			n.Type = nil
 			return n
 		}
 
 		if l.Type.IsSlice() && !isnil(l) && !isnil(r) {
-			Yyerror("invalid operation: %v (slice can only be compared to nil)", n)
+			yyerror("invalid operation: %v (slice can only be compared to nil)", n)
 			n.Type = nil
 			return n
 		}
 
 		if l.Type.IsMap() && !isnil(l) && !isnil(r) {
-			Yyerror("invalid operation: %v (map can only be compared to nil)", n)
+			yyerror("invalid operation: %v (map can only be compared to nil)", n)
 			n.Type = nil
 			return n
 		}
 
 		if l.Type.Etype == TFUNC && !isnil(l) && !isnil(r) {
-			Yyerror("invalid operation: %v (func can only be compared to nil)", n)
+			yyerror("invalid operation: %v (func can only be compared to nil)", n)
 			n.Type = nil
 			return n
 		}
 
 		if l.Type.IsStruct() {
 			if f := l.Type.IncomparableField(); f != nil {
-				Yyerror("invalid operation: %v (struct containing %v cannot be compared)", n, f.Type)
+				yyerror("invalid operation: %v (struct containing %v cannot be compared)", n, f.Type)
 				n.Type = nil
 				return n
 			}
@@ -755,7 +755,7 @@ OpSwitch:
 
 		if (op == ODIV || op == OMOD) && Isconst(r, CTINT) {
 			if r.Val().U.(*Mpint).CmpInt64(0) == 0 {
-				Yyerror("division by zero")
+				yyerror("division by zero")
 				n.Type = nil
 				return n
 			}
@@ -774,7 +774,7 @@ OpSwitch:
 			return n
 		}
 		if !okfor[n.Op][t.Etype] {
-			Yyerror("invalid operation: %v %v", n.Op, t)
+			yyerror("invalid operation: %v %v", n.Op, t)
 			n.Type = nil
 			return n
 		}
@@ -815,7 +815,7 @@ OpSwitch:
 			n.Type = nil
 			return n
 		}
-		n.Type = Ptrto(t)
+		n.Type = ptrto(t)
 		break OpSwitch
 
 	case OCOMPLIT:
@@ -852,16 +852,16 @@ OpSwitch:
 		if n.Left.Op == OTYPE {
 			if !looktypedot(n, t, 0) {
 				if looktypedot(n, t, 1) {
-					Yyerror("%v undefined (cannot refer to unexported method %v)", n, n.Sym)
+					yyerror("%v undefined (cannot refer to unexported method %v)", n, n.Sym)
 				} else {
-					Yyerror("%v undefined (type %v has no method %v)", n, t, n.Sym)
+					yyerror("%v undefined (type %v has no method %v)", n, t, n.Sym)
 				}
 				n.Type = nil
 				return n
 			}
 
 			if n.Type.Etype != TFUNC || !n.IsMethod() {
-				Yyerror("type %v has no method %S", n.Left.Type, n.Right.Sym)
+				yyerror("type %v has no method %S", n.Left.Type, n.Right.Sym)
 				n.Type = nil
 				return n
 			}
@@ -889,7 +889,7 @@ OpSwitch:
 		}
 
 		if isblanksym(n.Sym) {
-			Yyerror("cannot refer to blank field or method")
+			yyerror("cannot refer to blank field or method")
 			n.Type = nil
 			return n
 		}
@@ -898,21 +898,21 @@ OpSwitch:
 			// Legitimate field or method lookup failed, try to explain the error
 			switch {
 			case t.IsEmptyInterface():
-				Yyerror("%v undefined (type %v is interface with no methods)", n, n.Left.Type)
+				yyerror("%v undefined (type %v is interface with no methods)", n, n.Left.Type)
 
 			case t.IsPtr() && t.Elem().IsInterface():
 				// Pointer to interface is almost always a mistake.
-				Yyerror("%v undefined (type %v is pointer to interface, not interface)", n, n.Left.Type)
+				yyerror("%v undefined (type %v is pointer to interface, not interface)", n, n.Left.Type)
 
 			case lookdot(n, t, 1) != nil:
 				// Field or method matches by name, but it is not exported.
-				Yyerror("%v undefined (cannot refer to unexported field or method %v)", n, n.Sym)
+				yyerror("%v undefined (cannot refer to unexported field or method %v)", n, n.Sym)
 
 			default:
 				if mt := lookdot(n, t, 2); mt != nil { // Case-insensitive lookup.
-					Yyerror("%v undefined (type %v has no field or method %v, but does have %v)", n, n.Left.Type, n.Sym, mt.Sym)
+					yyerror("%v undefined (type %v has no field or method %v, but does have %v)", n, n.Left.Type, n.Sym, mt.Sym)
 				} else {
-					Yyerror("%v undefined (type %v has no field or method %v)", n, n.Left.Type, n.Sym)
+					yyerror("%v undefined (type %v has no field or method %v)", n, n.Left.Type, n.Sym)
 				}
 			}
 			n.Type = nil
@@ -945,7 +945,7 @@ OpSwitch:
 			return n
 		}
 		if !t.IsInterface() {
-			Yyerror("invalid type assertion: %v (non-interface type %v on left)", n, t)
+			yyerror("invalid type assertion: %v (non-interface type %v on left)", n, t)
 			n.Type = nil
 			return n
 		}
@@ -964,15 +964,15 @@ OpSwitch:
 			var ptr int
 			if !implements(n.Type, t, &missing, &have, &ptr) {
 				if have != nil && have.Sym == missing.Sym {
-					Yyerror("impossible type assertion:\n\t%v does not implement %v (wrong type for %v method)\n"+
+					yyerror("impossible type assertion:\n\t%v does not implement %v (wrong type for %v method)\n"+
 						"\t\thave %v%0S\n\t\twant %v%0S", n.Type, t, missing.Sym, have.Sym, have.Type, missing.Sym, missing.Type)
 				} else if ptr != 0 {
-					Yyerror("impossible type assertion:\n\t%v does not implement %v (%v method has pointer receiver)", n.Type, t, missing.Sym)
+					yyerror("impossible type assertion:\n\t%v does not implement %v (%v method has pointer receiver)", n.Type, t, missing.Sym)
 				} else if have != nil {
-					Yyerror("impossible type assertion:\n\t%v does not implement %v (missing %v method)\n"+
+					yyerror("impossible type assertion:\n\t%v does not implement %v (missing %v method)\n"+
 						"\t\thave %v%0S\n\t\twant %v%0S", n.Type, t, missing.Sym, have.Sym, have.Type, missing.Sym, missing.Type)
 				} else {
-					Yyerror("impossible type assertion:\n\t%v does not implement %v (missing %v method)", n.Type, t, missing.Sym)
+					yyerror("impossible type assertion:\n\t%v does not implement %v (missing %v method)", n.Type, t, missing.Sym)
 				}
 				n.Type = nil
 				return n
@@ -996,7 +996,7 @@ OpSwitch:
 		}
 		switch t.Etype {
 		default:
-			Yyerror("invalid operation: %v (type %v does not support indexing)", n, t)
+			yyerror("invalid operation: %v (type %v does not support indexing)", n, t)
 			n.Type = nil
 			return n
 
@@ -1015,20 +1015,20 @@ OpSwitch:
 			}
 
 			if n.Right.Type != nil && !n.Right.Type.IsInteger() {
-				Yyerror("non-integer %s index %v", why, n.Right)
+				yyerror("non-integer %s index %v", why, n.Right)
 				break
 			}
 
 			if !n.Bounded && Isconst(n.Right, CTINT) {
 				x := n.Right.Int64()
 				if x < 0 {
-					Yyerror("invalid %s index %v (index must be non-negative)", why, n.Right)
+					yyerror("invalid %s index %v (index must be non-negative)", why, n.Right)
 				} else if t.IsArray() && x >= t.NumElem() {
-					Yyerror("invalid array index %v (out of bounds for %d-element array)", n.Right, t.NumElem())
+					yyerror("invalid array index %v (out of bounds for %d-element array)", n.Right, t.NumElem())
 				} else if Isconst(n.Left, CTSTR) && x >= int64(len(n.Left.Val().U.(string))) {
-					Yyerror("invalid string index %v (out of bounds for %d-byte string)", n.Right, len(n.Left.Val().U.(string)))
+					yyerror("invalid string index %v (out of bounds for %d-byte string)", n.Right, len(n.Left.Val().U.(string)))
 				} else if n.Right.Val().U.(*Mpint).Cmp(Maxintval[TINT]) > 0 {
-					Yyerror("invalid %s index %v (index too large)", why, n.Right)
+					yyerror("invalid %s index %v (index too large)", why, n.Right)
 				}
 			}
 
@@ -1055,13 +1055,13 @@ OpSwitch:
 			return n
 		}
 		if !t.IsChan() {
-			Yyerror("invalid operation: %v (receive from non-chan type %v)", n, t)
+			yyerror("invalid operation: %v (receive from non-chan type %v)", n, t)
 			n.Type = nil
 			return n
 		}
 
 		if !t.ChanDir().CanRecv() {
-			Yyerror("invalid operation: %v (receive from send-only type %v)", n, t)
+			yyerror("invalid operation: %v (receive from send-only type %v)", n, t)
 			n.Type = nil
 			return n
 		}
@@ -1082,13 +1082,13 @@ OpSwitch:
 			return n
 		}
 		if !t.IsChan() {
-			Yyerror("invalid operation: %v (send to non-chan type %v)", n, t)
+			yyerror("invalid operation: %v (send to non-chan type %v)", n, t)
 			n.Type = nil
 			return n
 		}
 
 		if !t.ChanDir().CanSend() {
-			Yyerror("invalid operation: %v (send to receive-only type %v)", n, t)
+			yyerror("invalid operation: %v (send to receive-only type %v)", n, t)
 			n.Type = nil
 			return n
 		}
@@ -1123,7 +1123,7 @@ OpSwitch:
 		l := n.Left
 		if l.Type.IsArray() {
 			if !islvalue(n.Left) {
-				Yyerror("invalid operation %v (slice of unaddressable value)", n)
+				yyerror("invalid operation %v (slice of unaddressable value)", n)
 				n.Type = nil
 				return n
 			}
@@ -1142,7 +1142,7 @@ OpSwitch:
 		var tp *Type
 		if t.IsString() {
 			if hasmax {
-				Yyerror("invalid operation %v (3-index slice of string)", n)
+				yyerror("invalid operation %v (3-index slice of string)", n)
 				n.Type = nil
 				return n
 			}
@@ -1160,7 +1160,7 @@ OpSwitch:
 		} else if t.IsSlice() {
 			n.Type = t
 		} else {
-			Yyerror("cannot slice %v (type %v)", l, t)
+			yyerror("cannot slice %v (type %v)", l, t)
 			n.Type = nil
 			return n
 		}
@@ -1191,7 +1191,7 @@ OpSwitch:
 			r := unsafenmagic(n)
 			if r != nil {
 				if n.Isddd {
-					Yyerror("invalid use of ... with builtin %v", l)
+					yyerror("invalid use of ... with builtin %v", l)
 				}
 				n = r
 				n = typecheck1(n, top)
@@ -1205,7 +1205,7 @@ OpSwitch:
 		if l.Op == ONAME && l.Etype != 0 {
 			// TODO(marvin): Fix Node.EType type union.
 			if n.Isddd && Op(l.Etype) != OAPPEND {
-				Yyerror("invalid use of ... with builtin %v", l)
+				yyerror("invalid use of ... with builtin %v", l)
 			}
 
 			// builtin: OLEN, OCAP, etc.
@@ -1223,7 +1223,7 @@ OpSwitch:
 		if l.Op == OTYPE {
 			if n.Isddd || l.Type.isDDDArray() {
 				if !l.Type.Broke {
-					Yyerror("invalid use of ... in type conversion to %v", l.Type)
+					yyerror("invalid use of ... in type conversion to %v", l.Type)
 				}
 				n.Diag = 1
 			}
@@ -1276,7 +1276,7 @@ OpSwitch:
 		default:
 			n.Op = OCALLFUNC
 			if t.Etype != TFUNC {
-				Yyerror("cannot call non-function %v (type %v)", l, t)
+				yyerror("cannot call non-function %v (type %v)", l, t)
 				n.Type = nil
 				return n
 			}
@@ -1306,7 +1306,7 @@ OpSwitch:
 
 		// multiple return
 		if top&(Efnstruct|Etop) == 0 {
-			Yyerror("multiple-value %v() in single-value context", l)
+			yyerror("multiple-value %v() in single-value context", l)
 			break OpSwitch
 		}
 
@@ -1382,7 +1382,7 @@ OpSwitch:
 		break OpSwitch
 
 	badcall1:
-		Yyerror("invalid argument %L for %v", n.Left, n.Op)
+		yyerror("invalid argument %L for %v", n.Left, n.Op)
 		n.Type = nil
 		return n
 
@@ -1393,7 +1393,7 @@ OpSwitch:
 		if n.List.Len() == 1 {
 			typecheckslice(n.List.Slice(), Efnstruct)
 			if n.List.First().Op != OCALLFUNC && n.List.First().Op != OCALLMETH {
-				Yyerror("invalid operation: complex expects two arguments")
+				yyerror("invalid operation: complex expects two arguments")
 				n.Type = nil
 				return n
 			}
@@ -1404,7 +1404,7 @@ OpSwitch:
 				return n
 			}
 			if t.Results().NumFields() != 2 {
-				Yyerror("invalid operation: complex expects two arguments, %v returns %d results", n.List.First(), t.Results().NumFields())
+				yyerror("invalid operation: complex expects two arguments, %v returns %d results", n.List.First(), t.Results().NumFields())
 				n.Type = nil
 				return n
 			}
@@ -1435,7 +1435,7 @@ OpSwitch:
 		}
 
 		if !eqtype(l.Type, r.Type) {
-			Yyerror("invalid operation: %v (mismatched types %v and %v)", n, l.Type, r.Type)
+			yyerror("invalid operation: %v (mismatched types %v and %v)", n, l.Type, r.Type)
 			n.Type = nil
 			return n
 		}
@@ -1443,7 +1443,7 @@ OpSwitch:
 		var t *Type
 		switch l.Type.Etype {
 		default:
-			Yyerror("invalid operation: %v (arguments have type %v, expected floating-point)", n, l.Type)
+			yyerror("invalid operation: %v (arguments have type %v, expected floating-point)", n, l.Type)
 			n.Type = nil
 			return n
 
@@ -1482,13 +1482,13 @@ OpSwitch:
 			return n
 		}
 		if !t.IsChan() {
-			Yyerror("invalid operation: %v (non-chan type %v)", n, t)
+			yyerror("invalid operation: %v (non-chan type %v)", n, t)
 			n.Type = nil
 			return n
 		}
 
 		if !t.ChanDir().CanSend() {
-			Yyerror("invalid operation: %v (cannot close receive-only channel)", n)
+			yyerror("invalid operation: %v (cannot close receive-only channel)", n)
 			n.Type = nil
 			return n
 		}
@@ -1499,19 +1499,19 @@ OpSwitch:
 	case ODELETE:
 		args := n.List
 		if args.Len() == 0 {
-			Yyerror("missing arguments to delete")
+			yyerror("missing arguments to delete")
 			n.Type = nil
 			return n
 		}
 
 		if args.Len() == 1 {
-			Yyerror("missing second (key) argument to delete")
+			yyerror("missing second (key) argument to delete")
 			n.Type = nil
 			return n
 		}
 
 		if args.Len() != 2 {
-			Yyerror("too many arguments to delete")
+			yyerror("too many arguments to delete")
 			n.Type = nil
 			return n
 		}
@@ -1521,7 +1521,7 @@ OpSwitch:
 		l := args.First()
 		r := args.Second()
 		if l.Type != nil && !l.Type.IsMap() {
-			Yyerror("first argument to delete must be map; have %L", l.Type)
+			yyerror("first argument to delete must be map; have %L", l.Type)
 			n.Type = nil
 			return n
 		}
@@ -1533,7 +1533,7 @@ OpSwitch:
 		ok |= Erv
 		args := n.List
 		if args.Len() == 0 {
-			Yyerror("missing arguments to append")
+			yyerror("missing arguments to append")
 			n.Type = nil
 			return n
 		}
@@ -1560,25 +1560,25 @@ OpSwitch:
 		n.Type = t
 		if !t.IsSlice() {
 			if Isconst(args.First(), CTNIL) {
-				Yyerror("first argument to append must be typed slice; have untyped nil")
+				yyerror("first argument to append must be typed slice; have untyped nil")
 				n.Type = nil
 				return n
 			}
 
-			Yyerror("first argument to append must be slice; have %L", t)
+			yyerror("first argument to append must be slice; have %L", t)
 			n.Type = nil
 			return n
 		}
 
 		if n.Isddd {
 			if args.Len() == 1 {
-				Yyerror("cannot use ... on first argument to append")
+				yyerror("cannot use ... on first argument to append")
 				n.Type = nil
 				return n
 			}
 
 			if args.Len() != 2 {
-				Yyerror("too many arguments to append")
+				yyerror("too many arguments to append")
 				n.Type = nil
 				return n
 			}
@@ -1593,10 +1593,10 @@ OpSwitch:
 		}
 
 		if funarg != nil {
-			_, it := IterFields(funarg) // Skip first field
+			_, it := iterFields(funarg) // Skip first field
 			for t := it.Next(); t != nil; t = it.Next() {
 				if assignop(t.Type, n.Type.Elem(), nil) == 0 {
-					Yyerror("cannot append %v value to []%v", t.Type, n.Type.Elem())
+					yyerror("cannot append %v value to []%v", t.Type, n.Type.Elem())
 				}
 			}
 		} else {
@@ -1615,13 +1615,13 @@ OpSwitch:
 		ok |= Etop | Erv
 		args := n.List
 		if args.Len() < 2 {
-			Yyerror("missing arguments to copy")
+			yyerror("missing arguments to copy")
 			n.Type = nil
 			return n
 		}
 
 		if args.Len() > 2 {
-			Yyerror("too many arguments to copy")
+			yyerror("too many arguments to copy")
 			n.Type = nil
 			return n
 		}
@@ -1648,25 +1648,25 @@ OpSwitch:
 			if eqtype(n.Left.Type.Elem(), bytetype) {
 				break OpSwitch
 			}
-			Yyerror("arguments to copy have different element types: %L and string", n.Left.Type)
+			yyerror("arguments to copy have different element types: %L and string", n.Left.Type)
 			n.Type = nil
 			return n
 		}
 
 		if !n.Left.Type.IsSlice() || !n.Right.Type.IsSlice() {
 			if !n.Left.Type.IsSlice() && !n.Right.Type.IsSlice() {
-				Yyerror("arguments to copy must be slices; have %L, %L", n.Left.Type, n.Right.Type)
+				yyerror("arguments to copy must be slices; have %L, %L", n.Left.Type, n.Right.Type)
 			} else if !n.Left.Type.IsSlice() {
-				Yyerror("first argument to copy should be slice; have %L", n.Left.Type)
+				yyerror("first argument to copy should be slice; have %L", n.Left.Type)
 			} else {
-				Yyerror("second argument to copy should be slice or string; have %L", n.Right.Type)
+				yyerror("second argument to copy should be slice or string; have %L", n.Right.Type)
 			}
 			n.Type = nil
 			return n
 		}
 
 		if !eqtype(n.Left.Type.Elem(), n.Right.Type.Elem()) {
-			Yyerror("arguments to copy have different element types: %L and %L", n.Left.Type, n.Right.Type)
+			yyerror("arguments to copy have different element types: %L and %L", n.Left.Type, n.Right.Type)
 			n.Type = nil
 			return n
 		}
@@ -1687,7 +1687,7 @@ OpSwitch:
 		n.Op = convertop(t, n.Type, &why)
 		if n.Op == 0 {
 			if n.Diag == 0 && !n.Type.Broke {
-				Yyerror("cannot convert %L to type %v%s", n.Left, n.Type, why)
+				yyerror("cannot convert %L to type %v%s", n.Left, n.Type, why)
 				n.Diag = 1
 			}
 
@@ -1722,7 +1722,7 @@ OpSwitch:
 		ok |= Erv
 		args := n.List.Slice()
 		if len(args) == 0 {
-			Yyerror("missing argument to make")
+			yyerror("missing argument to make")
 			n.Type = nil
 			return n
 		}
@@ -1739,13 +1739,13 @@ OpSwitch:
 		i := 1
 		switch t.Etype {
 		default:
-			Yyerror("cannot make type %v", t)
+			yyerror("cannot make type %v", t)
 			n.Type = nil
 			return n
 
 		case TSLICE:
 			if i >= len(args) {
-				Yyerror("missing len argument to make(%v)", t)
+				yyerror("missing len argument to make(%v)", t)
 				n.Type = nil
 				return n
 			}
@@ -1769,7 +1769,7 @@ OpSwitch:
 				return n
 			}
 			if Isconst(l, CTINT) && r != nil && Isconst(r, CTINT) && l.Val().U.(*Mpint).Cmp(r.Val().U.(*Mpint)) > 0 {
-				Yyerror("len larger than cap in make(%v)", t)
+				yyerror("len larger than cap in make(%v)", t)
 				n.Type = nil
 				return n
 			}
@@ -1821,7 +1821,7 @@ OpSwitch:
 		}
 
 		if i < len(args) {
-			Yyerror("too many arguments to make(%v)", t)
+			yyerror("too many arguments to make(%v)", t)
 			n.Op = OMAKE
 			n.Type = nil
 			return n
@@ -1834,7 +1834,7 @@ OpSwitch:
 		ok |= Erv
 		args := n.List
 		if args.Len() == 0 {
-			Yyerror("missing argument to new")
+			yyerror("missing argument to new")
 			n.Type = nil
 			return n
 		}
@@ -1847,13 +1847,13 @@ OpSwitch:
 			return n
 		}
 		if args.Len() > 1 {
-			Yyerror("too many arguments to new(%v)", t)
+			yyerror("too many arguments to new(%v)", t)
 			n.Type = nil
 			return n
 		}
 
 		n.Left = l
-		n.Type = Ptrto(t)
+		n.Type = ptrto(t)
 		break OpSwitch
 
 	case OPRINT, OPRINTN:
@@ -1888,7 +1888,7 @@ OpSwitch:
 	case ORECOVER:
 		ok |= Erv | Etop
 		if n.List.Len() != 0 {
-			Yyerror("too many arguments to recover")
+			yyerror("too many arguments to recover")
 			n.Type = nil
 			return n
 		}
@@ -1915,7 +1915,7 @@ OpSwitch:
 		if !t.IsInterface() {
 			Fatalf("OITAB of %v", t)
 		}
-		n.Type = Ptrto(Types[TUINTPTR])
+		n.Type = ptrto(Types[TUINTPTR])
 		break OpSwitch
 
 	case OIDATA:
@@ -1936,9 +1936,9 @@ OpSwitch:
 			Fatalf("OSPTR of %v", t)
 		}
 		if t.IsString() {
-			n.Type = Ptrto(Types[TUINT8])
+			n.Type = ptrto(Types[TUINT8])
 		} else {
-			n.Type = Ptrto(t.Elem())
+			n.Type = ptrto(t.Elem())
 		}
 		break OpSwitch
 
@@ -2012,7 +2012,7 @@ OpSwitch:
 		if n.Left != nil {
 			t := n.Left.Type
 			if t != nil && !t.IsBoolean() {
-				Yyerror("non-bool %L used as for condition", n.Left)
+				yyerror("non-bool %L used as for condition", n.Left)
 			}
 		}
 		n.Right = typecheck(n.Right, Etop)
@@ -2027,7 +2027,7 @@ OpSwitch:
 		if n.Left != nil {
 			t := n.Left.Type
 			if t != nil && !t.IsBoolean() {
-				Yyerror("non-bool %L used as if condition", n.Left)
+				yyerror("non-bool %L used as if condition", n.Left)
 			}
 		}
 		typecheckslice(n.Nbody.Slice(), Etop)
@@ -2042,7 +2042,7 @@ OpSwitch:
 			typecheckslice(n.List.Slice(), Erv)
 		}
 		if Curfn == nil {
-			Yyerror("return outside function")
+			yyerror("return outside function")
 			n.Type = nil
 			return n
 		}
@@ -2073,7 +2073,7 @@ OpSwitch:
 		break OpSwitch
 
 	case OTYPESW:
-		Yyerror("use of .(type) outside type switch")
+		yyerror("use of .(type) outside type switch")
 		n.Type = nil
 		return n
 
@@ -2113,32 +2113,32 @@ OpSwitch:
 	}
 
 	if safemode && importpkg == nil && compiling_wrappers == 0 && t != nil && t.Etype == TUNSAFEPTR {
-		Yyerror("cannot use unsafe.Pointer")
+		yyerror("cannot use unsafe.Pointer")
 	}
 
 	evconst(n)
 	if n.Op == OTYPE && top&Etype == 0 {
-		Yyerror("type %v is not an expression", n.Type)
+		yyerror("type %v is not an expression", n.Type)
 		n.Type = nil
 		return n
 	}
 
 	if top&(Erv|Etype) == Etype && n.Op != OTYPE {
-		Yyerror("%v is not a type", n)
+		yyerror("%v is not a type", n)
 		n.Type = nil
 		return n
 	}
 
 	// TODO(rsc): simplify
 	if (top&(Ecall|Erv|Etype) != 0) && top&Etop == 0 && ok&(Erv|Etype|Ecall) == 0 {
-		Yyerror("%v used as value", n)
+		yyerror("%v used as value", n)
 		n.Type = nil
 		return n
 	}
 
 	if (top&Etop != 0) && top&(Ecall|Erv|Etype) == 0 && ok&Etop == 0 {
 		if n.Diag == 0 {
-			Yyerror("%v evaluated but not used", n)
+			yyerror("%v evaluated but not used", n)
 			n.Diag = 1
 		}
 
@@ -2159,22 +2159,22 @@ func checksliceindex(l *Node, r *Node, tp *Type) bool {
 		return false
 	}
 	if !t.IsInteger() {
-		Yyerror("invalid slice index %v (type %v)", r, t)
+		yyerror("invalid slice index %v (type %v)", r, t)
 		return false
 	}
 
 	if r.Op == OLITERAL {
 		if r.Int64() < 0 {
-			Yyerror("invalid slice index %v (index must be non-negative)", r)
+			yyerror("invalid slice index %v (index must be non-negative)", r)
 			return false
 		} else if tp != nil && tp.NumElem() > 0 && r.Int64() > tp.NumElem() {
-			Yyerror("invalid slice index %v (out of bounds for %d-element array)", r, tp.NumElem())
+			yyerror("invalid slice index %v (out of bounds for %d-element array)", r, tp.NumElem())
 			return false
 		} else if Isconst(l, CTSTR) && r.Int64() > int64(len(l.Val().U.(string))) {
-			Yyerror("invalid slice index %v (out of bounds for %d-byte string)", r, len(l.Val().U.(string)))
+			yyerror("invalid slice index %v (out of bounds for %d-byte string)", r, len(l.Val().U.(string)))
 			return false
 		} else if r.Val().U.(*Mpint).Cmp(Maxintval[TINT]) > 0 {
-			Yyerror("invalid slice index %v (index too large)", r)
+			yyerror("invalid slice index %v (index too large)", r)
 			return false
 		}
 	}
@@ -2184,7 +2184,7 @@ func checksliceindex(l *Node, r *Node, tp *Type) bool {
 
 func checksliceconst(lo *Node, hi *Node) bool {
 	if lo != nil && hi != nil && lo.Op == OLITERAL && hi.Op == OLITERAL && lo.Val().U.(*Mpint).Cmp(hi.Val().U.(*Mpint)) > 0 {
-		Yyerror("invalid slice index: %v > %v", lo, hi)
+		yyerror("invalid slice index: %v > %v", lo, hi)
 		return false
 	}
 
@@ -2226,7 +2226,7 @@ func checkdefergo(n *Node) {
 		if n.Left.Orig != nil && n.Left.Orig.Op == OCONV {
 			break
 		}
-		Yyerror("%s discards result of %v", what, n.Left)
+		yyerror("%s discards result of %v", what, n.Left)
 		return
 	}
 
@@ -2241,7 +2241,7 @@ func checkdefergo(n *Node) {
 		// a conversion.
 		n.Diag = 1
 
-		Yyerror("%s requires function call, not conversion", what)
+		yyerror("%s requires function call, not conversion", what)
 	}
 }
 
@@ -2272,13 +2272,13 @@ func onearg(n *Node, f string, args ...interface{}) bool {
 	}
 	if n.List.Len() == 0 {
 		p := fmt.Sprintf(f, args...)
-		Yyerror("missing argument to %s: %v", p, n)
+		yyerror("missing argument to %s: %v", p, n)
 		return false
 	}
 
 	if n.List.Len() > 1 {
 		p := fmt.Sprintf(f, args...)
-		Yyerror("too many arguments to %s: %v", p, n)
+		yyerror("too many arguments to %s: %v", p, n)
 		n.Left = n.List.First()
 		n.List.Set(nil)
 		return false
@@ -2294,19 +2294,19 @@ func twoarg(n *Node) bool {
 		return true
 	}
 	if n.List.Len() == 0 {
-		Yyerror("missing argument to %v - %v", n.Op, n)
+		yyerror("missing argument to %v - %v", n.Op, n)
 		return false
 	}
 
 	n.Left = n.List.First()
 	if n.List.Len() == 1 {
-		Yyerror("missing argument to %v - %v", n.Op, n)
+		yyerror("missing argument to %v - %v", n.Op, n)
 		n.List.Set(nil)
 		return false
 	}
 
 	if n.List.Len() > 2 {
-		Yyerror("too many arguments to %v - %v", n.Op, n)
+		yyerror("too many arguments to %v - %v", n.Op, n)
 		n.List.Set(nil)
 		return false
 	}
@@ -2330,11 +2330,11 @@ func lookdot1(errnode *Node, s *Sym, t *Type, fs *Fields, dostrcmp int) *Field {
 		}
 		if r != nil {
 			if errnode != nil {
-				Yyerror("ambiguous selector %v", errnode)
+				yyerror("ambiguous selector %v", errnode)
 			} else if t.IsPtr() {
-				Yyerror("ambiguous selector (%v).%v", t, s)
+				yyerror("ambiguous selector (%v).%v", t, s)
 			} else {
-				Yyerror("ambiguous selector %v.%v", t, s)
+				yyerror("ambiguous selector %v.%v", t, s)
 			}
 			break
 		}
@@ -2376,7 +2376,7 @@ func looktypedot(n *Node, t *Type, dostrcmp int) bool {
 
 	// disallow T.m if m requires *T receiver
 	if f2.Type.Recv().Type.IsPtr() && !t.IsPtr() && f2.Embedded != 2 && !isifacemethod(f2.Type) {
-		Yyerror("invalid method expression %v (needs pointer receiver: (*%v).%S)", n, t, f2.Sym)
+		yyerror("invalid method expression %v (needs pointer receiver: (*%v).%S)", n, t, f2.Sym)
 		return false
 	}
 
@@ -2428,7 +2428,7 @@ func lookdot(n *Node, t *Type, dostrcmp int) *Field {
 			return f1
 		}
 		if f2 != nil {
-			Yyerror("%v is both field and method", n.Sym)
+			yyerror("%v is both field and method", n.Sym)
 		}
 		if f1.Offset == BADWIDTH {
 			Fatalf("lookdot badwidth %v %p", f1, f1)
@@ -2470,7 +2470,7 @@ func lookdot(n *Node, t *Type, dostrcmp int) *Field {
 				n.Left.Implicit = true
 				n.Left = typecheck(n.Left, Etype|Erv)
 			} else if tt.Etype == Tptr && tt.Elem().Etype == Tptr && eqtype(derefall(tt), derefall(rcvr)) {
-				Yyerror("calling method %v with receiver %L requires explicit dereference", n.Sym, n.Left)
+				yyerror("calling method %v with receiver %L requires explicit dereference", n.Sym, n.Left)
 				for tt.Etype == Tptr {
 					// Stop one level early for method with pointer receiver.
 					if rcvr.Etype == Tptr && tt.Elem().Etype != Tptr {
@@ -2561,16 +2561,16 @@ func typecheckaste(op Op, call *Node, isddd bool, tstruct *Type, nl Nodes, desc
 					}
 				}
 
-				tn, it := IterFields(n.Type)
+				tn, it := iterFields(n.Type)
 				var why string
 				for _, tl := range tstruct.Fields().Slice() {
 					if tl.Isddd {
 						for ; tn != nil; tn = it.Next() {
 							if assignop(tn.Type, tl.Type.Elem(), &why) == 0 {
 								if call != nil {
-									Yyerror("cannot use %v as type %v in argument to %v%s", tn.Type, tl.Type.Elem(), call, why)
+									yyerror("cannot use %v as type %v in argument to %v%s", tn.Type, tl.Type.Elem(), call, why)
 								} else {
-									Yyerror("cannot use %v as type %v in %s%s", tn.Type, tl.Type.Elem(), desc(), why)
+									yyerror("cannot use %v as type %v in %s%s", tn.Type, tl.Type.Elem(), desc(), why)
 								}
 							}
 						}
@@ -2583,9 +2583,9 @@ func typecheckaste(op Op, call *Node, isddd bool, tstruct *Type, nl Nodes, desc
 					}
 					if assignop(tn.Type, tl.Type, &why) == 0 {
 						if call != nil {
-							Yyerror("cannot use %v as type %v in argument to %v%s", tn.Type, tl.Type, call, why)
+							yyerror("cannot use %v as type %v in argument to %v%s", tn.Type, tl.Type, call, why)
 						} else {
-							Yyerror("cannot use %v as type %v in %s%s", tn.Type, tl.Type, desc(), why)
+							yyerror("cannot use %v as type %v in %s%s", tn.Type, tl.Type, desc(), why)
 						}
 					}
 
@@ -2670,9 +2670,9 @@ func typecheckaste(op Op, call *Node, isddd bool, tstruct *Type, nl Nodes, desc
 	}
 	if isddd {
 		if call != nil {
-			Yyerror("invalid use of ... in call to %v", call)
+			yyerror("invalid use of ... in call to %v", call)
 		} else {
-			Yyerror("invalid use of ... in %v", op)
+			yyerror("invalid use of ... in %v", op)
 		}
 	}
 
@@ -2687,12 +2687,12 @@ notenough:
 			// Method expressions have the form T.M, and the compiler has
 			// rewritten those to ONAME nodes but left T in Left.
 			if call.Op == ONAME && call.Left != nil && call.Left.Op == OTYPE {
-				Yyerror("not enough arguments in call to method expression %v", call)
+				yyerror("not enough arguments in call to method expression %v", call)
 			} else {
-				Yyerror("not enough arguments in call to %v", call)
+				yyerror("not enough arguments in call to %v", call)
 			}
 		} else {
-			Yyerror("not enough arguments to %v", op)
+			yyerror("not enough arguments to %v", op)
 		}
 		if n != nil {
 			n.Diag = 1
@@ -2703,9 +2703,9 @@ notenough:
 
 toomany:
 	if call != nil {
-		Yyerror("too many arguments in call to %v", call)
+		yyerror("too many arguments in call to %v", call)
 	} else {
-		Yyerror("too many arguments to %v", op)
+		yyerror("too many arguments to %v", op)
 	}
 	goto out
 }
@@ -2717,7 +2717,7 @@ func fielddup(n *Node, hash map[string]bool) {
 	}
 	name := n.Sym.Name
 	if hash[name] {
-		Yyerror("duplicate field name in struct literal: %s", name)
+		yyerror("duplicate field name in struct literal: %s", name)
 		return
 	}
 	hash[name] = true
@@ -2773,7 +2773,7 @@ func keydup(n *Node, hash map[uint32][]*Node) {
 			continue
 		}
 		if cmp.Val().U.(bool) {
-			Yyerror("duplicate key %v in map literal", n)
+			yyerror("duplicate key %v in map literal", n)
 			return
 		}
 	}
@@ -2788,7 +2788,7 @@ func indexdup(n *Node, hash map[int64]*Node) {
 
 	v := n.Int64()
 	if hash[v] != nil {
-		Yyerror("duplicate index in array literal: %d", v)
+		yyerror("duplicate index in array literal: %d", v)
 		return
 	}
 	hash[v] = n
@@ -2843,7 +2843,7 @@ func typecheckcomplit(n *Node) *Node {
 		if n.List.Len() != 0 {
 			setlineno(n.List.First())
 		}
-		Yyerror("missing type in composite literal")
+		yyerror("missing type in composite literal")
 		n.Type = nil
 		return n
 	}
@@ -2868,14 +2868,14 @@ func typecheckcomplit(n *Node) *Node {
 		// For better or worse, we don't allow pointers as the composite literal type,
 		// except when using the &T syntax, which sets implicit on the OIND.
 		if !n.Right.Implicit {
-			Yyerror("invalid pointer type %v for composite literal (use &%v instead)", t, t.Elem())
+			yyerror("invalid pointer type %v for composite literal (use &%v instead)", t, t.Elem())
 			n.Type = nil
 			return n
 		}
 
 		// Also, the underlying type must be a struct, map, slice, or array.
 		if !iscomptype(t) {
-			Yyerror("invalid pointer type %v for composite literal", t)
+			yyerror("invalid pointer type %v for composite literal", t)
 			n.Type = nil
 			return n
 		}
@@ -2886,7 +2886,7 @@ func typecheckcomplit(n *Node) *Node {
 	var r *Node
 	switch t.Etype {
 	default:
-		Yyerror("invalid type for composite literal: %v", t)
+		yyerror("invalid type for composite literal: %v", t)
 		n.Type = nil
 
 	case TARRAY, TSLICE:
@@ -2915,7 +2915,7 @@ func typecheckcomplit(n *Node) *Node {
 			evconst(l.Left)
 			i = nonnegconst(l.Left)
 			if i < 0 && l.Left.Diag == 0 {
-				Yyerror("index must be non-negative integer constant")
+				yyerror("index must be non-negative integer constant")
 				l.Left.Diag = 1
 				i = -(1 << 30) // stay negative for a while
 			}
@@ -2928,7 +2928,7 @@ func typecheckcomplit(n *Node) *Node {
 				length = int64(i)
 				if checkBounds && length > t.NumElem() {
 					setlineno(l)
-					Yyerror("array index %d out of bounds [0:%d]", length-1, t.NumElem())
+					yyerror("array index %d out of bounds [0:%d]", length-1, t.NumElem())
 					checkBounds = false
 				}
 			}
@@ -2958,7 +2958,7 @@ func typecheckcomplit(n *Node) *Node {
 			setlineno(l)
 			if l.Op != OKEY {
 				n.List.SetIndex(i3, typecheck(n.List.Index(i3), Erv))
-				Yyerror("missing key in map literal")
+				yyerror("missing key in map literal")
 				continue
 			}
 
@@ -2987,7 +2987,7 @@ func typecheckcomplit(n *Node) *Node {
 		bad := 0
 		if n.List.Len() != 0 && nokeys(n.List) {
 			// simple list of variables
-			f, it := IterFields(t)
+			f, it := iterFields(t)
 
 			var s *Sym
 			ls := n.List.Slice()
@@ -2997,7 +2997,7 @@ func typecheckcomplit(n *Node) *Node {
 				n1 = ls[i1]
 				if f == nil {
 					if bad == 0 {
-						Yyerror("too many values in struct initializer")
+						yyerror("too many values in struct initializer")
 					}
 					bad++
 					continue
@@ -3005,7 +3005,7 @@ func typecheckcomplit(n *Node) *Node {
 
 				s = f.Sym
 				if s != nil && !exportname(s.Name) && s.Pkg != localpkg {
-					Yyerror("implicit assignment of unexported field '%s' in %v literal", s.Name, t)
+					yyerror("implicit assignment of unexported field '%s' in %v literal", s.Name, t)
 				}
 				// No pushtype allowed here. Must name fields for that.
 				n1 = assignconv(n1, f.Type, "field value")
@@ -3018,7 +3018,7 @@ func typecheckcomplit(n *Node) *Node {
 			}
 
 			if f != nil {
-				Yyerror("too few values in struct initializer")
+				yyerror("too few values in struct initializer")
 			}
 		} else {
 			hash := make(map[string]bool)
@@ -3029,7 +3029,7 @@ func typecheckcomplit(n *Node) *Node {
 				setlineno(l)
 				if l.Op != OKEY {
 					if bad == 0 {
-						Yyerror("mixture of field:value and value initializers")
+						yyerror("mixture of field:value and value initializers")
 					}
 					bad++
 					ls[i] = typecheck(ls[i], Erv)
@@ -3043,7 +3043,7 @@ func typecheckcomplit(n *Node) *Node {
 				// so s will be non-nil, but an OXDOT
 				// is never a valid struct literal key.
 				if s == nil || l.Left.Op == OXDOT {
-					Yyerror("invalid field name %v in struct initializer", l.Left)
+					yyerror("invalid field name %v in struct initializer", l.Left)
 					l.Right = typecheck(l.Right, Erv)
 					continue
 				}
@@ -3052,7 +3052,7 @@ func typecheckcomplit(n *Node) *Node {
 				// package, because of import dot. Redirect to correct sym
 				// before we do the lookup.
 				if s.Pkg != localpkg && exportname(s.Name) {
-					s1 := Lookup(s.Name)
+					s1 := lookup(s.Name)
 					if s1.Origpkg == s.Pkg {
 						s = s1
 					}
@@ -3060,7 +3060,7 @@ func typecheckcomplit(n *Node) *Node {
 
 				f := lookdot1(nil, s, t, t.Fields(), 0)
 				if f == nil {
-					Yyerror("unknown %v field '%v' in struct literal", t, s)
+					yyerror("unknown %v field '%v' in struct literal", t, s)
 					continue
 				}
 
@@ -3129,7 +3129,7 @@ func islvalue(n *Node) bool {
 
 func checklvalue(n *Node, verb string) {
 	if !islvalue(n) {
-		Yyerror("cannot %s %v", verb, n)
+		yyerror("cannot %s %v", verb, n)
 	}
 }
 
@@ -3165,11 +3165,11 @@ func checkassign(stmt *Node, n *Node) {
 	}
 
 	if n.Op == ODOT && n.Left.Op == OINDEXMAP {
-		Yyerror("cannot assign to struct field %v in map", n)
+		yyerror("cannot assign to struct field %v in map", n)
 		return
 	}
 
-	Yyerror("cannot assign to %v", n)
+	yyerror("cannot assign to %v", n)
 }
 
 func checkassignlist(stmt *Node, l Nodes) {
@@ -3254,7 +3254,7 @@ func checkassignto(src *Type, dst *Node) {
 	var why string
 
 	if assignop(src, dst.Type, &why) == 0 {
-		Yyerror("cannot assign %v to %L in multiple assignment%s", src, dst, why)
+		yyerror("cannot assign %v to %L in multiple assignment%s", src, dst, why)
 		return
 	}
 }
@@ -3318,7 +3318,7 @@ func typecheckas2(n *Node) {
 				goto mismatch
 			}
 			n.Op = OAS2FUNC
-			t, s := IterFields(r.Type)
+			t, s := iterFields(r.Type)
 			for _, n3 := range n.List.Slice() {
 				if t.Type != nil && n3.Type != nil {
 					checkassignto(t.Type, n3)
@@ -3370,7 +3370,7 @@ func typecheckas2(n *Node) {
 	}
 
 mismatch:
-	Yyerror("assignment count mismatch: %d = %d", cl, cr)
+	yyerror("assignment count mismatch: %d = %d", cl, cr)
 
 	// second half of dance
 out:
@@ -3511,7 +3511,7 @@ func copytype(n *Node, t *Type) {
 	if embedlineno != 0 {
 		lineno = embedlineno
 		if t.IsPtr() || t.IsUnsafePtr() {
-			Yyerror("embedded type cannot be a pointer")
+			yyerror("embedded type cannot be a pointer")
 		}
 	}
 
@@ -3563,7 +3563,7 @@ ret:
 		for _, e := range mapqueue {
 			lineno = e.lno
 			if !e.n.Type.IsComparable() {
-				Yyerror("invalid map key type %v", e.n.Type)
+				yyerror("invalid map key type %v", e.n.Type)
 			}
 		}
 		mapqueue = nil
@@ -3595,7 +3595,7 @@ func typecheckdef(n *Node) *Node {
 
 			// Note: adderrorname looks for this string and
 			// adds context about the outer expression
-			Yyerror("undefined: %v", n.Sym)
+			yyerror("undefined: %v", n.Sym)
 		}
 
 		return n
@@ -3607,7 +3607,7 @@ func typecheckdef(n *Node) *Node {
 
 	typecheckdefstack = append(typecheckdefstack, n)
 	if n.Walkdef == 2 {
-		Flusherrors()
+		flusherrors()
 		fmt.Printf("typecheckdef loop:")
 		for i := len(typecheckdefstack) - 1; i >= 0; i-- {
 			n := typecheckdefstack[i]
@@ -3647,18 +3647,18 @@ func typecheckdef(n *Node) *Node {
 		if e == nil {
 			lineno = n.Lineno
 			Dump("typecheckdef nil defn", n)
-			Yyerror("xxx")
+			yyerror("xxx")
 		}
 
 		e = typecheck(e, Erv)
 		if Isconst(e, CTNIL) {
-			Yyerror("const initializer cannot be nil")
+			yyerror("const initializer cannot be nil")
 			goto ret
 		}
 
 		if e.Type != nil && e.Op != OLITERAL || !isgoconst(e) {
 			if e.Diag == 0 {
-				Yyerror("const initializer %v is not a constant", e)
+				yyerror("const initializer %v is not a constant", e)
 				e.Diag = 1
 			}
 
@@ -3668,12 +3668,12 @@ func typecheckdef(n *Node) *Node {
 		t := n.Type
 		if t != nil {
 			if !okforconst[t.Etype] {
-				Yyerror("invalid constant type %v", t)
+				yyerror("invalid constant type %v", t)
 				goto ret
 			}
 
 			if !e.Type.IsUntyped() && !eqtype(t, e.Type) {
-				Yyerror("cannot use %L as type %v in const initializer", e, t)
+				yyerror("cannot use %L as type %v in const initializer", e, t)
 				goto ret
 			}
 
@@ -3761,7 +3761,7 @@ ret:
 
 func checkmake(t *Type, arg string, n *Node) bool {
 	if !n.Type.IsInteger() && n.Type.Etype != TIDEAL {
-		Yyerror("non-integer %s argument in make(%v) - %v", arg, t, n.Type)
+		yyerror("non-integer %s argument in make(%v) - %v", arg, t, n.Type)
 		return false
 	}
 
@@ -3770,12 +3770,12 @@ func checkmake(t *Type, arg string, n *Node) bool {
 		case CTINT, CTRUNE, CTFLT, CTCPLX:
 			n.SetVal(toint(n.Val()))
 			if n.Val().U.(*Mpint).CmpInt64(0) < 0 {
-				Yyerror("negative %s argument in make(%v)", arg, t)
+				yyerror("negative %s argument in make(%v)", arg, t)
 				return false
 			}
 
 			if n.Val().U.(*Mpint).Cmp(Maxintval[TINT]) > 0 {
-				Yyerror("%s argument too large in make(%v)", arg, t)
+				yyerror("%s argument too large in make(%v)", arg, t)
 				return false
 			}
 
diff --git a/src/cmd/compile/internal/gc/universe.go b/src/cmd/compile/internal/gc/universe.go
index 9ca205ce6a..4c374c622e 100644
--- a/src/cmd/compile/internal/gc/universe.go
+++ b/src/cmd/compile/internal/gc/universe.go
@@ -103,18 +103,18 @@ func lexinit() {
 	idealbool = typ(TBOOL)
 
 	s := Pkglookup("true", builtinpkg)
-	s.Def = Nodbool(true)
-	s.Def.Sym = Lookup("true")
+	s.Def = nodbool(true)
+	s.Def.Sym = lookup("true")
 	s.Def.Name = new(Name)
 	s.Def.Type = idealbool
 
 	s = Pkglookup("false", builtinpkg)
-	s.Def = Nodbool(false)
-	s.Def.Sym = Lookup("false")
+	s.Def = nodbool(false)
+	s.Def.Sym = lookup("false")
 	s.Def.Name = new(Name)
 	s.Def.Type = idealbool
 
-	s = Lookup("_")
+	s = lookup("_")
 	s.Block = -100
 	s.Def = Nod(ONAME, nil, nil)
 	s.Def.Sym = s
@@ -361,7 +361,7 @@ func makeErrorInterface() *Type {
 	rcvr := typ(TSTRUCT)
 	rcvr.StructType().Funarg = FunargRcvr
 	field := newField()
-	field.Type = Ptrto(typ(TSTRUCT))
+	field.Type = ptrto(typ(TSTRUCT))
 	rcvr.SetFields([]*Field{field})
 
 	in := typ(TSTRUCT)
@@ -380,7 +380,7 @@ func makeErrorInterface() *Type {
 
 	t := typ(TINTER)
 	field = newField()
-	field.Sym = Lookup("Error")
+	field.Sym = lookup("Error")
 	field.Type = f
 	t.SetFields([]*Field{field})
 
@@ -448,7 +448,7 @@ func finishUniverse() {
 		if s.Def == nil || (s.Name == "any" && Debug['A'] == 0) {
 			continue
 		}
-		s1 := Lookup(s.Name)
+		s1 := lookup(s.Name)
 		if s1.Def != nil {
 			continue
 		}
@@ -461,5 +461,5 @@ func finishUniverse() {
 	nodfp.Type = Types[TINT32]
 	nodfp.Xoffset = 0
 	nodfp.Class = PPARAM
-	nodfp.Sym = Lookup(".fp")
+	nodfp.Sym = lookup(".fp")
 }
diff --git a/src/cmd/compile/internal/gc/unsafe.go b/src/cmd/compile/internal/gc/unsafe.go
index fc6ed1fe92..aca9759388 100644
--- a/src/cmd/compile/internal/gc/unsafe.go
+++ b/src/cmd/compile/internal/gc/unsafe.go
@@ -21,7 +21,7 @@ func unsafenmagic(nn *Node) *Node {
 	}
 
 	if args.Len() == 0 {
-		Yyerror("missing argument for %v", s)
+		yyerror("missing argument for %v", s)
 		return nil
 	}
 
@@ -60,7 +60,7 @@ func unsafenmagic(nn *Node) *Node {
 		case ODOT, ODOTPTR:
 			break
 		case OCALLPART:
-			Yyerror("invalid expression %v: argument is a method value", nn)
+			yyerror("invalid expression %v: argument is a method value", nn)
 			goto ret
 		default:
 			goto bad
@@ -74,7 +74,7 @@ func unsafenmagic(nn *Node) *Node {
 				// but accessing f must not otherwise involve
 				// indirection via embedded pointer types.
 				if r1.Left != base {
-					Yyerror("invalid expression %v: selector implies indirection of embedded %v", nn, r1.Left)
+					yyerror("invalid expression %v: selector implies indirection of embedded %v", nn, r1.Left)
 					goto ret
 				}
 				fallthrough
@@ -92,12 +92,12 @@ func unsafenmagic(nn *Node) *Node {
 	}
 
 	if args.Len() > 1 {
-		Yyerror("extra arguments for %v", s)
+		yyerror("extra arguments for %v", s)
 	}
 	goto ret
 
 bad:
-	Yyerror("invalid expression %v", nn)
+	yyerror("invalid expression %v", nn)
 
 ret:
 	// any side effects disappear; ignore init
diff --git a/src/cmd/compile/internal/gc/util.go b/src/cmd/compile/internal/gc/util.go
index 18e990a91a..3786769a24 100644
--- a/src/cmd/compile/internal/gc/util.go
+++ b/src/cmd/compile/internal/gc/util.go
@@ -16,7 +16,7 @@ func (n *Node) Line() string {
 
 var atExitFuncs []func()
 
-func AtExit(f func()) {
+func atExit(f func()) {
 	atExitFuncs = append(atExitFuncs, f)
 }
 
@@ -44,7 +44,7 @@ func startProfile() {
 		if err := pprof.StartCPUProfile(f); err != nil {
 			Fatalf("%v", err)
 		}
-		AtExit(pprof.StopCPUProfile)
+		atExit(pprof.StopCPUProfile)
 	}
 	if memprofile != "" {
 		if memprofilerate != 0 {
@@ -54,7 +54,7 @@ func startProfile() {
 		if err != nil {
 			Fatalf("%v", err)
 		}
-		AtExit(func() {
+		atExit(func() {
 			runtime.GC() // profile all outstanding allocations
 			if err := pprof.WriteHeapProfile(f); err != nil {
 				Fatalf("%v", err)
diff --git a/src/cmd/compile/internal/gc/walk.go b/src/cmd/compile/internal/gc/walk.go
index c443f6b396..749770d4a5 100644
--- a/src/cmd/compile/internal/gc/walk.go
+++ b/src/cmd/compile/internal/gc/walk.go
@@ -50,11 +50,11 @@ func walk(fn *Node) {
 				continue
 			}
 			lineno = defn.Left.Lineno
-			Yyerror("%v declared and not used", ln.Sym)
+			yyerror("%v declared and not used", ln.Sym)
 			defn.Left.Used = true // suppress repeats
 		} else {
 			lineno = ln.Lineno
-			Yyerror("%v declared and not used", ln.Sym)
+			yyerror("%v declared and not used", ln.Sym)
 		}
 	}
 
@@ -119,7 +119,7 @@ func adjustargs(n *Node, adjust int) {
 	callfunc := n.Left
 	for _, arg = range callfunc.List.Slice() {
 		if arg.Op != OAS {
-			Yyerror("call arg not assignment")
+			yyerror("call arg not assignment")
 		}
 		lhs = arg.Left
 		if lhs.Op == ONAME {
@@ -129,7 +129,7 @@ func adjustargs(n *Node, adjust int) {
 		}
 
 		if lhs.Op != OINDREG {
-			Yyerror("call argument store does not use OINDREG")
+			yyerror("call argument store does not use OINDREG")
 		}
 
 		// can't really check this in machine-indep code.
@@ -156,9 +156,9 @@ func walkstmt(n *Node) *Node {
 	switch n.Op {
 	default:
 		if n.Op == ONAME {
-			Yyerror("%v is not a top level statement", n.Sym)
+			yyerror("%v is not a top level statement", n.Sym)
 		} else {
-			Yyerror("%v is not a top level statement", n.Op)
+			yyerror("%v is not a top level statement", n.Op)
 		}
 		Dump("nottop", n)
 
@@ -226,7 +226,7 @@ func walkstmt(n *Node) *Node {
 		v := n.Left
 		if v.Class == PAUTOHEAP {
 			if compiling_runtime {
-				Yyerror("%v escapes to heap, not allowed in runtime.", v)
+				yyerror("%v escapes to heap, not allowed in runtime.", v)
 			}
 			if prealloc[v] == nil {
 				prealloc[v] = callnew(v.Type)
@@ -241,7 +241,7 @@ func walkstmt(n *Node) *Node {
 		walkstmtlist(n.List.Slice())
 
 	case OXCASE:
-		Yyerror("case statement out of place")
+		yyerror("case statement out of place")
 		n.Op = OCASE
 		fallthrough
 
@@ -361,7 +361,7 @@ func walkstmt(n *Node) *Node {
 		walkrange(n)
 
 	case OXFALL:
-		Yyerror("fallthrough statement out of place")
+		yyerror("fallthrough statement out of place")
 		n.Op = OFALL
 	}
 
@@ -907,7 +907,7 @@ opswitch:
 
 		// don't generate a = *var if a is _
 		if !isblank(a) {
-			var_ := temp(Ptrto(t.Val()))
+			var_ := temp(ptrto(t.Val()))
 			var_.Typecheck = 1
 			var_.NonNil = true // mapaccess always returns a non-nil pointer
 			n.List.SetIndex(0, var_)
@@ -980,7 +980,7 @@ opswitch:
 				tab := Nod(OITAB, from, nil)
 				if fromKind == 'E' {
 					typ := Nod(OCONVNOP, typename(t), nil)
-					typ.Type = Ptrto(Types[TUINTPTR])
+					typ.Type = ptrto(Types[TUINTPTR])
 					fast = Nod(OEQ, tab, typ)
 					break
 				}
@@ -1253,7 +1253,7 @@ opswitch:
 				Warn("index bounds check elided")
 			}
 			if smallintconst(n.Right) && !n.Bounded {
-				Yyerror("index out of bounds")
+				yyerror("index out of bounds")
 			}
 		} else if Isconst(n.Left, CTSTR) {
 			n.Bounded = bounded(r, int64(len(n.Left.Val().U.(string))))
@@ -1262,7 +1262,7 @@ opswitch:
 			}
 			if smallintconst(n.Right) {
 				if !n.Bounded {
-					Yyerror("index out of bounds")
+					yyerror("index out of bounds")
 				} else {
 					// replace "abc"[1] with 'b'.
 					// delayed until now because "abc"[1] is not
@@ -1277,7 +1277,7 @@ opswitch:
 
 		if Isconst(n.Right, CTINT) {
 			if n.Right.Val().U.(*Mpint).CmpInt64(0) < 0 || n.Right.Val().U.(*Mpint).Cmp(Maxintval[TINT]) > 0 {
-				Yyerror("index out of bounds")
+				yyerror("index out of bounds")
 			}
 		}
 
@@ -1313,11 +1313,11 @@ opswitch:
 		}
 
 		if w := t.Val().Width; w <= 1024 { // 1024 must match ../../../../runtime/hashmap.go:maxZero
-			n = mkcall1(mapfn(p, t), Ptrto(t.Val()), init, typename(t), n.Left, key)
+			n = mkcall1(mapfn(p, t), ptrto(t.Val()), init, typename(t), n.Left, key)
 		} else {
 			p = "mapaccess1_fat"
 			z := zeroaddr(w)
-			n = mkcall1(mapfn(p, t), Ptrto(t.Val()), init, typename(t), n.Left, key, z)
+			n = mkcall1(mapfn(p, t), ptrto(t.Val()), init, typename(t), n.Left, key, z)
 		}
 		n.NonNil = true // mapaccess always returns a non-nil pointer
 		n = Nod(OIND, n, nil)
@@ -1758,7 +1758,7 @@ func ascompatee(op Op, nl, nr []*Node, init *Nodes) []*Node {
 		var nln, nrn Nodes
 		nln.Set(nl)
 		nrn.Set(nr)
-		Yyerror("error in shape across %+v %v %+v / %d %d [%s]", nln, op, nrn, len(nl), len(nr), Curfn.Func.Nname.Sym.Name)
+		yyerror("error in shape across %+v %v %+v / %d %d [%s]", nln, op, nrn, len(nl), len(nr), Curfn.Func.Nname.Sym.Name)
 	}
 	return nn
 }
@@ -1785,7 +1785,7 @@ func fncall(l *Node, rt *Type) bool {
 // a expression list. called in
 //	expr-list = func()
 func ascompatet(op Op, nl Nodes, nr *Type, fp int, init *Nodes) []*Node {
-	r, saver := IterFields(nr)
+	r, saver := iterFields(nr)
 
 	var nn, mm []*Node
 	var ullmanOverflow bool
@@ -1825,7 +1825,7 @@ func ascompatet(op Op, nl Nodes, nr *Type, fp int, init *Nodes) []*Node {
 	}
 
 	if i < nl.Len() || r != nil {
-		Yyerror("ascompatet: assignment count mismatch: %d = %d", nl.Len(), nr.NumFields())
+		yyerror("ascompatet: assignment count mismatch: %d = %d", nl.Len(), nr.NumFields())
 	}
 
 	if ullmanOverflow {
@@ -1874,7 +1874,7 @@ func dumptypes(nl *Type, what string) string {
 		if s != "" {
 			s += ", "
 		}
-		s += Fldconv(l, 0)
+		s += fldconv(l, 0)
 	}
 	if s == "" {
 		s = fmt.Sprintf("[no arguments %s]", what)
@@ -1902,7 +1902,7 @@ func dumpnodetypes(l []*Node, what string) string {
 //	func(expr-list)
 func ascompatte(op Op, call *Node, isddd bool, nl *Type, lr []*Node, fp int, init *Nodes) []*Node {
 	lr0 := lr
-	l, savel := IterFields(nl)
+	l, savel := iterFields(nl)
 	var r *Node
 	if len(lr) > 0 {
 		r = lr[0]
@@ -1937,7 +1937,7 @@ func ascompatte(op Op, call *Node, isddd bool, nl *Type, lr []*Node, fp int, ini
 		init.Append(a)
 		lr = alist
 		r = lr[0]
-		l, savel = IterFields(nl)
+		l, savel = iterFields(nl)
 	}
 
 	for {
@@ -1946,7 +1946,7 @@ func ascompatte(op Op, call *Node, isddd bool, nl *Type, lr []*Node, fp int, ini
 			ll := savel.Next()
 
 			if ll != nil {
-				Yyerror("... must be last argument")
+				yyerror("... must be last argument")
 			}
 
 			// special case --
@@ -1973,9 +1973,9 @@ func ascompatte(op Op, call *Node, isddd bool, nl *Type, lr []*Node, fp int, ini
 				l1 := dumptypes(nl, "expected")
 				l2 := dumpnodetypes(lr0, "given")
 				if l != nil {
-					Yyerror("not enough arguments to %v\n\t%s\n\t%s", op, l1, l2)
+					yyerror("not enough arguments to %v\n\t%s\n\t%s", op, l1, l2)
 				} else {
-					Yyerror("too many arguments to %v\n\t%s\n\t%s", op, l1, l2)
+					yyerror("too many arguments to %v\n\t%s\n\t%s", op, l1, l2)
 				}
 			}
 
@@ -2118,7 +2118,7 @@ func callnew(t *Type) *Node {
 	dowidth(t)
 	fn := syslook("newobject")
 	fn = substArgTypes(fn, t)
-	v := mkcall1(fn, Ptrto(t), nil, typename(t))
+	v := mkcall1(fn, ptrto(t), nil, typename(t))
 	v.NonNil = true
 	return v
 }
@@ -2793,7 +2793,7 @@ func addstr(n *Node, init *Nodes) *Node {
 	c := n.List.Len()
 
 	if c < 2 {
-		Yyerror("addstr count %d too small", c)
+		yyerror("addstr count %d too small", c)
 	}
 
 	buf := nodnil()
@@ -3140,8 +3140,8 @@ func eqfor(t *Type, needsize *int) *Node {
 		n := newname(sym)
 		n.Class = PFUNC
 		ntype := Nod(OTFUNC, nil, nil)
-		ntype.List.Append(Nod(ODCLFIELD, nil, typenod(Ptrto(t))))
-		ntype.List.Append(Nod(ODCLFIELD, nil, typenod(Ptrto(t))))
+		ntype.List.Append(Nod(ODCLFIELD, nil, typenod(ptrto(t))))
+		ntype.List.Append(Nod(ODCLFIELD, nil, typenod(ptrto(t))))
 		ntype.Rlist.Append(Nod(ODCLFIELD, nil, typenod(Types[TBOOL])))
 		ntype = typecheck(ntype, Etype)
 		n.Type = ntype.Type
@@ -3186,11 +3186,11 @@ func walkcompare(n *Node, init *Nodes) *Node {
 		tab := Nod(OITAB, l, nil)
 		rtyp := typename(r.Type)
 		if l.Type.IsEmptyInterface() {
-			tab.Type = Ptrto(Types[TUINT8])
+			tab.Type = ptrto(Types[TUINT8])
 			tab.Typecheck = 1
 			eqtype = Nod(eq, tab, rtyp)
 		} else {
-			nonnil := Nod(Brcom(eq), nodnil(), tab)
+			nonnil := Nod(brcom(eq), nodnil(), tab)
 			match := Nod(eq, itabType(tab), rtyp)
 			eqtype = Nod(andor, nonnil, match)
 		}
@@ -3233,13 +3233,13 @@ func walkcompare(n *Node, init *Nodes) *Node {
 	// Chose not to inline. Call equality function directly.
 	if !inline {
 		// eq algs take pointers
-		pl := temp(Ptrto(t))
+		pl := temp(ptrto(t))
 		al := Nod(OAS, pl, Nod(OADDR, cmpl, nil))
 		al.Right.Etype = 1 // addr does not escape
 		al = typecheck(al, Etop)
 		init.Append(al)
 
-		pr := temp(Ptrto(t))
+		pr := temp(ptrto(t))
 		ar := Nod(OAS, pr, Nod(OADDR, cmpr, nil))
 		ar.Right.Etype = 1 // addr does not escape
 		ar = typecheck(ar, Etop)
@@ -3283,8 +3283,8 @@ func walkcompare(n *Node, init *Nodes) *Node {
 				continue
 			}
 			compare(
-				NodSym(OXDOT, cmpl, sym),
-				NodSym(OXDOT, cmpr, sym),
+				nodSym(OXDOT, cmpl, sym),
+				nodSym(OXDOT, cmpr, sym),
 			)
 		}
 	} else {
@@ -3296,7 +3296,7 @@ func walkcompare(n *Node, init *Nodes) *Node {
 		}
 	}
 	if expr == nil {
-		expr = Nodbool(n.Op == OEQ)
+		expr = nodbool(n.Op == OEQ)
 	}
 	n = finishcompare(n, expr, init)
 	return n
@@ -3448,9 +3448,9 @@ func walkinrange(n *Node, init *Nodes) *Node {
 			return n
 		}
 		if i&1 == 0 {
-			a, opl, b = b, Brrev(opl), a
+			a, opl, b = b, brrev(opl), a
 		} else {
-			x, opr, c = c, Brrev(opr), x
+			x, opr, c = c, brrev(opr), x
 		}
 	}
 
@@ -3459,8 +3459,8 @@ func walkinrange(n *Node, init *Nodes) *Node {
 	// Henceforth assume &&.
 	negateResult := n.Op == OOROR
 	if negateResult {
-		opl = Brcom(opl)
-		opr = Brcom(opr)
+		opl = brcom(opl)
+		opr = brcom(opr)
 	}
 
 	cmpdir := func(o Op) int {
@@ -3484,7 +3484,7 @@ func walkinrange(n *Node, init *Nodes) *Node {
 		// Switch and reverse ops and rename constants,
 		// to make it look like a ≤ b && b < c.
 		a, c = c, a
-		opl, opr = Brrev(opr), Brrev(opl)
+		opl, opr = brrev(opr), brrev(opl)
 	}
 
 	// We must ensure that c-a is non-negative.
@@ -3525,7 +3525,7 @@ func walkinrange(n *Node, init *Nodes) *Node {
 	rhs := nodintconst(bound)
 	if negateResult {
 		// Negate top level.
-		opr = Brcom(opr)
+		opr = brcom(opr)
 	}
 	cmp := Nod(opr, lhs, rhs)
 	cmp.Lineno = n.Lineno
@@ -4006,10 +4006,10 @@ func usefield(n *Node) {
 		outer = outer.Elem()
 	}
 	if outer.Sym == nil {
-		Yyerror("tracked field must be in named struct type")
+		yyerror("tracked field must be in named struct type")
 	}
 	if !exportname(field.Sym.Name) {
-		Yyerror("tracked field must be exported (upper case)")
+		yyerror("tracked field must be exported (upper case)")
 	}
 
 	sym := tracksym(outer, field)
@@ -4148,7 +4148,7 @@ func walkprintfunc(n *Node, init *Nodes) *Node {
 	for _, n1 := range n.List.Slice() {
 		buf = fmt.Sprintf("a%d", num)
 		num++
-		a = Nod(ODCLFIELD, newname(Lookup(buf)), typenod(n1.Type))
+		a = Nod(ODCLFIELD, newname(lookup(buf)), typenod(n1.Type))
 		t.List.Append(a)
 		printargs = append(printargs, a.Left)
 	}
@@ -4156,7 +4156,7 @@ func walkprintfunc(n *Node, init *Nodes) *Node {
 	fn := Nod(ODCLFUNC, nil, nil)
 	walkprintfunc_prgen++
 	buf = fmt.Sprintf("print·%d", walkprintfunc_prgen)
-	fn.Func.Nname = newname(Lookup(buf))
+	fn.Func.Nname = newname(lookup(buf))
 	fn.Func.Nname.Name.Defn = fn
 	fn.Func.Nname.Name.Param.Ntype = t
 	declare(fn.Func.Nname, PFUNC)
