commit a790388afb85f04ed65d3795eb22edee44df69af
Author: David Symonds <dsymonds@golang.org>
Date:   Mon Aug 19 13:47:43 2013 +1000

    cmd/gc: regenerate y.tab.{c,h} with Bison 2.5.
    
    R=golang-dev, r
    CC=golang-dev
    https://golang.org/cl/12744048
---
 src/cmd/gc/y.tab.c | 1256 ++++++++++++++++++++++++++++++++++++++--------------
 src/cmd/gc/y.tab.h |   46 +-
 2 files changed, 953 insertions(+), 349 deletions(-)

diff --git a/src/cmd/gc/y.tab.c b/src/cmd/gc/y.tab.c
index 8df7a0bee9..5c6ee43d76 100644
--- a/src/cmd/gc/y.tab.c
+++ b/src/cmd/gc/y.tab.c
@@ -1,24 +1,21 @@
-/* A Bison parser, made by GNU Bison 2.3.  */
+/* A Bison parser, made by GNU Bison 2.5.  */
 
-/* Skeleton implementation for Bison's Yacc-like parsers in C
-
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
-   Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
+/* Bison implementation for Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-
+   
    You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -29,7 +26,7 @@
    special exception, which will cause the skeleton and the resulting
    Bison output files to be licensed under the GNU General Public
    License without this special exception.
-
+   
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
@@ -47,7 +44,7 @@
 #define YYBISON 1
 
 /* Bison version.  */
-#define YYBISON_VERSION "2.3"
+#define YYBISON_VERSION "2.5"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -55,11 +52,54 @@
 /* Pure parsers.  */
 #define YYPURE 0
 
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
 /* Using locations.  */
 #define YYLSP_NEEDED 0
 
 
 
+/* Copy the first part of user declarations.  */
+
+/* Line 268 of yacc.c  */
+#line 20 "go.y"
+
+#include <u.h>
+#include <stdio.h>	/* if we don't, bison will, and go.h re-#defines getc */
+#include <libc.h>
+#include "go.h"
+
+static int isrelease = -1;
+
+static void fixlbrace(int);
+
+
+/* Line 268 of yacc.c  */
+#line 83 "y.tab.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 1
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
 /* Tokens.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
@@ -171,63 +211,36 @@
 
 
 
-/* Copy the first part of user declarations.  */
-#line 20 "go.y"
-
-#include <u.h>
-#include <stdio.h>	/* if we don't, bison will, and go.h re-#defines getc */
-#include <libc.h>
-#include "go.h"
-
-static int isrelease = -1;
-
-static void fixlbrace(int);
-
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 1
-#endif
-
-/* Enabling the token table.  */
-#ifndef YYTOKEN_TABLE
-# define YYTOKEN_TABLE 0
-#endif
-
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-#line 30 "go.y"
 {
+
+/* Line 293 of yacc.c  */
+#line 30 "go.y"
+
 	Node*		node;
 	NodeList*		list;
 	Type*		type;
 	Sym*		sym;
 	struct	Val	val;
 	int		i;
-}
-/* Line 193 of yacc.c.  */
-#line 218 "y.tab.c"
-	YYSTYPE;
+
+
+
+/* Line 293 of yacc.c  */
+#line 232 "y.tab.c"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
 #endif
 
 
-
 /* Copy the second part of user declarations.  */
 
 
-/* Line 216 of yacc.c.  */
-#line 231 "y.tab.c"
+/* Line 343 of yacc.c  */
+#line 244 "y.tab.c"
 
 #ifdef short
 # undef short
@@ -302,14 +315,14 @@ typedef short int yytype_int16;
 #if (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 static int
-YYID (int i)
+YYID (int yyi)
 #else
 static int
-YYID (i)
-    int i;
+YYID (yyi)
+    int yyi;
 #endif
 {
-  return i;
+  return yyi;
 }
 #endif
 
@@ -330,11 +343,11 @@ YYID (i)
 #    define alloca _alloca
 #   else
 #    define YYSTACK_ALLOC alloca
-#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 #     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#     ifndef _STDLIB_H
-#      define _STDLIB_H 1
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
 #     endif
 #    endif
 #   endif
@@ -357,24 +370,24 @@ YYID (i)
 #  ifndef YYSTACK_ALLOC_MAXIMUM
 #   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
 #  endif
-#  if (defined __cplusplus && ! defined _STDLIB_H \
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
        && ! ((defined YYMALLOC || defined malloc) \
 	     && (defined YYFREE || defined free)))
 #   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   ifndef _STDLIB_H
-#    define _STDLIB_H 1
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
 #   endif
 #  endif
 #  ifndef YYMALLOC
 #   define YYMALLOC malloc
-#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+#   if ! defined malloc && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
 #  ifndef YYFREE
 #   define YYFREE free
-#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+#   if ! defined free && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 void free (void *); /* INFRINGES ON USER NAME SPACE */
 #   endif
@@ -390,9 +403,9 @@ void free (void *); /* INFRINGES ON USER NAME SPACE */
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  yytype_int16 yyss;
-  YYSTYPE yyvs;
-  };
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
 
 /* The size of the maximum gap between one aligned stack and the next.  */
 # define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
@@ -403,6 +416,27 @@ union yyalloc
      ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
 # ifndef YYCOPY
@@ -420,24 +454,7 @@ union yyalloc
       while (YYID (0))
 #  endif
 # endif
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (YYID (0))
-
-#endif
+#endif /* !YYCOPY_NEEDED */
 
 /* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  4
@@ -714,16 +731,16 @@ const char *yytname[] =
   "'/'", "'%'", "'&'", "NotPackage", "NotParen", "'('", "')'",
   "PreferToRightParen", "';'", "'.'", "'$'", "'='", "':'", "'{'", "'}'",
   "'!'", "'~'", "'['", "']'", "'?'", "'@'", "','", "$accept", "file",
-  "package", "loadsys", "@1", "imports", "import", "import_stmt",
+  "package", "loadsys", "$@1", "imports", "import", "import_stmt",
   "import_stmt_list", "import_here", "import_package", "import_safety",
-  "import_there", "@2", "xdcl", "common_dcl", "lconst", "vardcl",
+  "import_there", "$@2", "xdcl", "common_dcl", "lconst", "vardcl",
   "constdcl", "constdcl1", "typedclname", "typedcl", "simple_stmt", "case",
-  "compound_stmt", "@3", "caseblock", "@4", "caseblock_list", "loop_body",
-  "@5", "range_stmt", "for_header", "for_body", "for_stmt", "@6",
-  "if_header", "if_stmt", "@7", "@8", "@9", "elseif", "@10", "elseif_list",
-  "else", "switch_stmt", "@11", "@12", "select_stmt", "@13", "expr",
-  "uexpr", "pseudocall", "pexpr_no_paren", "start_complit", "keyval",
-  "bare_complitexpr", "complitexpr", "pexpr", "expr_or_type",
+  "compound_stmt", "$@3", "caseblock", "$@4", "caseblock_list",
+  "loop_body", "$@5", "range_stmt", "for_header", "for_body", "for_stmt",
+  "$@6", "if_header", "if_stmt", "$@7", "$@8", "$@9", "elseif", "$@10",
+  "elseif_list", "else", "switch_stmt", "$@11", "$@12", "select_stmt",
+  "$@13", "expr", "uexpr", "pseudocall", "pexpr_no_paren", "start_complit",
+  "keyval", "bare_complitexpr", "complitexpr", "pexpr", "expr_or_type",
   "name_or_type", "lbrace", "new_name", "dcl_name", "onew_name", "sym",
   "hidden_importsym", "name", "labelname", "dotdotdot", "ntype",
   "non_expr_type", "non_recvchantype", "convtype", "comptype",
@@ -733,7 +750,7 @@ const char *yytname[] =
   "vardcl_list", "constdcl_list", "typedcl_list", "structdcl_list",
   "interfacedcl_list", "structdcl", "packname", "embed", "interfacedcl",
   "indcl", "arg_type", "arg_type_list", "oarg_type_list_ocomma", "stmt",
-  "non_dcl_stmt", "@14", "stmt_list", "new_name_list", "dcl_name_list",
+  "non_dcl_stmt", "$@14", "stmt_list", "new_name_list", "dcl_name_list",
   "expr_list", "expr_or_type_list", "keyval_list", "braced_keyval_list",
   "osemi", "ocomma", "oexpr", "oexpr_list", "osimple_stmt",
   "ohidden_funarg_list", "ohidden_structdcl_list",
@@ -846,8 +863,8 @@ static const yytype_uint8 yyr2[] =
        3
 };
 
-/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
-   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
+   Performed when YYTABLE doesn't specify something else to do.  Zero
    means the default is an error.  */
 static const yytype_uint16 yydefact[] =
 {
@@ -1036,8 +1053,7 @@ static const yytype_int16 yypgoto[] =
 
 /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
    positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, syntax error.  */
+   number is the opposite.  If YYTABLE_NINF, syntax error.  */
 #define YYTABLE_NINF -276
 static const yytype_int16 yytable[] =
 {
@@ -1263,6 +1279,12 @@ static const yytype_int16 yytable[] =
      189,   190,   191,   192,   193,   194,   195,   196,   197
 };
 
+#define yypact_value_is_default(yystate) \
+  ((yystate) == (-552))
+
+#define yytable_value_is_error(yytable_value) \
+  YYID (0)
+
 static const yytype_int16 yycheck[] =
 {
       37,    37,    61,   142,    67,    37,    37,   201,   250,   143,
@@ -1572,9 +1594,18 @@ static const yytype_uint8 yystos[] =
 
 /* Like YYERROR except do call yyerror.  This remains here temporarily
    to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
+   Once GCC version 2 has supplanted version 1, this can go.  However,
+   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
+   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
+   discussed.  */
 
 #define YYFAIL		goto yyerrlab
+#if defined YYFAIL
+  /* This is here to suppress warnings from the GCC cpp's
+     -Wunused-macros.  Normally we don't worry about that warning, but
+     some users do, and we want to make it easy for users to remove
+     YYFAIL uses, which will produce warnings from Bison 2.5.  */
+#endif
 
 #define YYRECOVERING()  (!!yyerrstatus)
 
@@ -1584,7 +1615,6 @@ do								\
     {								\
       yychar = (Token);						\
       yylval = (Value);						\
-      yytoken = YYTRANSLATE (yychar);				\
       YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
@@ -1626,19 +1656,10 @@ while (YYID (0))
 #endif
 
 
-/* YY_LOCATION_PRINT -- Print the location on the stream.
-   This macro was not mandated originally: define only if we know
-   we won't break user code: when these are the locations we know.  */
+/* This macro is provided for backward compatibility. */
 
 #ifndef YY_LOCATION_PRINT
-# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
-#  define YY_LOCATION_PRINT(File, Loc)			\
-     fprintf (File, "%d.%d-%d.%d",			\
-	      (Loc).first_line, (Loc).first_column,	\
-	      (Loc).last_line,  (Loc).last_column)
-# else
-#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
-# endif
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
 #endif
 
 
@@ -1742,17 +1763,20 @@ yy_symbol_print (yyoutput, yytype, yyvaluep)
 #if (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 static void
-yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
 #else
 static void
-yy_stack_print (bottom, top)
-    yytype_int16 *bottom;
-    yytype_int16 *top;
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
 #endif
 {
   YYFPRINTF (stderr, "Stack now");
-  for (; bottom <= top; ++bottom)
-    YYFPRINTF (stderr, " %d", *bottom);
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
   YYFPRINTF (stderr, "\n");
 }
 
@@ -1786,11 +1810,11 @@ yy_reduce_print (yyvsp, yyrule)
   /* The symbols being reduced.  */
   for (yyi = 0; yyi < yynrhs; yyi++)
     {
-      fprintf (stderr, "   $%d = ", yyi + 1);
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
       yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
 		       &(yyvsp[(yyi + 1) - (yynrhs)])
 		       		       );
-      fprintf (stderr, "\n");
+      YYFPRINTF (stderr, "\n");
     }
 }
 
@@ -1827,7 +1851,6 @@ int yydebug;
 # define YYMAXDEPTH 10000
 #endif
 
-
 
 #if YYERROR_VERBOSE
 
@@ -1930,115 +1953,142 @@ yytnamerr (char *yyres, const char *yystr)
 }
 # endif
 
-/* Copy into YYRESULT an error message about the unexpected token
-   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
-   including the terminating null byte.  If YYRESULT is null, do not
-   copy anything; just return the number of bytes that would be
-   copied.  As a special case, return 0 if an ordinary "syntax error"
-   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
-   size calculation.  */
-static YYSIZE_T
-yysyntax_error (char *yyresult, int yystate, int yychar)
-{
-  int yyn = yypact[yystate];
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
 
-  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
-    return 0;
-  else
-    {
-      int yytype = YYTRANSLATE (yychar);
-      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
-      YYSIZE_T yysize = yysize0;
-      YYSIZE_T yysize1;
-      int yysize_overflow = 0;
-      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-      int yyx;
-
-# if 0
-      /* This is so xgettext sees the translatable formats that are
-	 constructed on the fly.  */
-      YY_("syntax error, unexpected %s");
-      YY_("syntax error, unexpected %s, expecting %s");
-      YY_("syntax error, unexpected %s, expecting %s or %s");
-      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
-      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
-# endif
-      char *yyfmt;
-      char const *yyf;
-      static char const yyunexpected[] = "syntax error, unexpected %s";
-      static char const yyexpecting[] = ", expecting %s";
-      static char const yyor[] = " or %s";
-      char yyformat[sizeof yyunexpected
-		    + sizeof yyexpecting - 1
-		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
-		       * (sizeof yyor - 1))];
-      char const *yyprefix = yyexpecting;
-
-      /* Start YYX at -YYN if negative to avoid negative indexes in
-	 YYCHECK.  */
-      int yyxbegin = yyn < 0 ? -yyn : 0;
-
-      /* Stay within bounds of both yycheck and yytname.  */
-      int yychecklim = YYLAST - yyn + 1;
-      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-      int yycount = 1;
-
-      yyarg[0] = yytname[yytype];
-      yyfmt = yystpcpy (yyformat, yyunexpected);
-
-      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	  {
-	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-	      {
-		yycount = 1;
-		yysize = yysize0;
-		yyformat[sizeof yyunexpected - 1] = '\0';
-		break;
-	      }
-	    yyarg[yycount++] = yytname[yyx];
-	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
-	    yysize_overflow |= (yysize1 < yysize);
-	    yysize = yysize1;
-	    yyfmt = yystpcpy (yyfmt, yyprefix);
-	    yyprefix = yyor;
-	  }
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  YYSIZE_T yysize1;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = 0;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - Assume YYFAIL is not used.  It's too flawed to consider.  See
+       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
+       for details.  YYERROR is fine as it does not invoke this
+       function.
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+                if (! (yysize <= yysize1
+                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                  return 2;
+                yysize = yysize1;
+              }
+        }
+    }
 
-      yyf = YY_(yyformat);
-      yysize1 = yysize + yystrlen (yyf);
-      yysize_overflow |= (yysize1 < yysize);
-      yysize = yysize1;
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
 
-      if (yysize_overflow)
-	return YYSIZE_MAXIMUM;
+  yysize1 = yysize + yystrlen (yyformat);
+  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+    return 2;
+  yysize = yysize1;
 
-      if (yyresult)
-	{
-	  /* Avoid sprintf, as that infringes on the user's name space.
-	     Don't have undefined behavior even if the translation
-	     produced a string with the wrong number of "%s"s.  */
-	  char *yyp = yyresult;
-	  int yyi = 0;
-	  while ((*yyp = *yyf) != '\0')
-	    {
-	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
-		{
-		  yyp += yytnamerr (yyp, yyarg[yyi++]);
-		  yyf += 2;
-		}
-	      else
-		{
-		  yyp++;
-		  yyf++;
-		}
-	    }
-	}
-      return yysize;
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
     }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
 }
 #endif /* YYERROR_VERBOSE */
-
 
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
@@ -2070,10 +2120,9 @@ yydestruct (yymsg, yytype, yyvaluep)
 	break;
     }
 }
-
 
-/* Prevent warnings from -Wmissing-prototypes.  */
 
+/* Prevent warnings from -Wmissing-prototypes.  */
 #ifdef YYPARSE_PARAM
 #if defined __STDC__ || defined __cplusplus
 int yyparse (void *YYPARSE_PARAM);
@@ -2089,18 +2138,16 @@ int yyparse ();
 #endif /* ! YYPARSE_PARAM */
 
 
-
-/* The look-ahead symbol.  */
+/* The lookahead symbol.  */
 int yychar, yystate;
 
-/* The semantic value of the look-ahead symbol.  */
+/* The semantic value of the lookahead symbol.  */
 YYSTYPE yylval;
 
 /* Number of syntax errors so far.  */
 int yynerrs;
 
 
-
 /*----------.
 | yyparse.  |
 `----------*/
@@ -2127,65 +2174,65 @@ yyparse ()
 #endif
 #endif
 {
-  
-  int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Look-ahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-#if YYERROR_VERBOSE
-  /* Buffer for error messages, and its allocated size.  */
-  char yymsgbuf[128];
-  char *yymsg = yymsgbuf;
-  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
-#endif
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
 
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
 
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
 
-  /* The state stack.  */
-  yytype_int16 yyssa[YYINITDEPTH];
-  yytype_int16 *yyss = yyssa;
-  yytype_int16 *yyssp;
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
 
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  YYSTYPE *yyvsp;
-
-
-
-#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
 
-  YYSIZE_T yystacksize = YYINITDEPTH;
+    YYSIZE_T yystacksize;
 
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
   /* The variables used to return semantic value and location from the
      action routines.  */
   YYSTYPE yyval;
 
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
   /* The number of symbols on the RHS of the reduced rule.
      Keep to zero when no symbol should be popped.  */
   int yylen = 0;
 
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
   YYDPRINTF ((stderr, "Starting parse\n"));
 
   yystate = 0;
   yyerrstatus = 0;
   yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
+  yychar = YYEMPTY; /* Cause a token to be read.  */
 
   /* Initialize stack pointers.
      Waste one element of value and location stack
      so that they stay on the same level as the state stack.
      The wasted elements are never initialized.  */
-
   yyssp = yyss;
   yyvsp = yyvs;
 
@@ -2215,7 +2262,6 @@ yyparse ()
 	YYSTYPE *yyvs1 = yyvs;
 	yytype_int16 *yyss1 = yyss;
 
-
 	/* Each stack pointer address is followed by the size of the
 	   data in use in that stack, in bytes.  This used to be a
 	   conditional around just the two extra args, but that might
@@ -2223,7 +2269,6 @@ yyparse ()
 	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
-
 		    &yystacksize);
 
 	yyss = yyss1;
@@ -2246,9 +2291,8 @@ yyparse ()
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
 	  goto yyexhaustedlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
 #  undef YYSTACK_RELOCATE
 	if (yyss1 != yyssa)
 	  YYSTACK_FREE (yyss1);
@@ -2259,7 +2303,6 @@ yyparse ()
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
 
-
       YYDPRINTF ((stderr, "Stack size increased to %lu\n",
 		  (unsigned long int) yystacksize));
 
@@ -2269,6 +2312,9 @@ yyparse ()
 
   YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
   goto yybackup;
 
 /*-----------.
@@ -2277,16 +2323,16 @@ yyparse ()
 yybackup:
 
   /* Do appropriate processing given the current state.  Read a
-     look-ahead token if we need one and don't already have one.  */
+     lookahead token if we need one and don't already have one.  */
 
-  /* First try to decide what to do without reference to look-ahead token.  */
+  /* First try to decide what to do without reference to lookahead token.  */
   yyn = yypact[yystate];
-  if (yyn == YYPACT_NINF)
+  if (yypact_value_is_default (yyn))
     goto yydefault;
 
-  /* Not known => get a look-ahead token if don't already have one.  */
+  /* Not known => get a lookahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
@@ -2312,26 +2358,22 @@ yybackup:
   yyn = yytable[yyn];
   if (yyn <= 0)
     {
-      if (yyn == 0 || yyn == YYTABLE_NINF)
-	goto yyerrlab;
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
 
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
-  /* Shift the look-ahead token.  */
+  /* Shift the lookahead token.  */
   YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
 
-  /* Discard the shifted token unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
 
   yystate = yyn;
   *++yyvsp = yylval;
@@ -2371,6 +2413,8 @@ yyreduce:
   switch (yyn)
     {
         case 2:
+
+/* Line 1806 of yacc.c  */
 #line 130 "go.y"
     {
 		xtop = concat(xtop, (yyvsp[(4) - (4)].list));
@@ -2378,6 +2422,8 @@ yyreduce:
     break;
 
   case 3:
+
+/* Line 1806 of yacc.c  */
 #line 136 "go.y"
     {
 		prevlineno = lineno;
@@ -2387,6 +2433,8 @@ yyreduce:
     break;
 
   case 4:
+
+/* Line 1806 of yacc.c  */
 #line 142 "go.y"
     {
 		mkpackage((yyvsp[(2) - (3)].sym)->name);
@@ -2394,6 +2442,8 @@ yyreduce:
     break;
 
   case 5:
+
+/* Line 1806 of yacc.c  */
 #line 152 "go.y"
     {
 		importpkg = runtimepkg;
@@ -2407,6 +2457,8 @@ yyreduce:
     break;
 
   case 6:
+
+/* Line 1806 of yacc.c  */
 #line 163 "go.y"
     {
 		importpkg = nil;
@@ -2414,6 +2466,8 @@ yyreduce:
     break;
 
   case 12:
+
+/* Line 1806 of yacc.c  */
 #line 177 "go.y"
     {
 		Pkg *ipkg;
@@ -2454,6 +2508,8 @@ yyreduce:
     break;
 
   case 13:
+
+/* Line 1806 of yacc.c  */
 #line 214 "go.y"
     {
 		// When an invalid import path is passed to importfile,
@@ -2466,6 +2522,8 @@ yyreduce:
     break;
 
   case 16:
+
+/* Line 1806 of yacc.c  */
 #line 229 "go.y"
     {
 		// import with original name
@@ -2476,6 +2534,8 @@ yyreduce:
     break;
 
   case 17:
+
+/* Line 1806 of yacc.c  */
 #line 236 "go.y"
     {
 		// import with given name
@@ -2486,6 +2546,8 @@ yyreduce:
     break;
 
   case 18:
+
+/* Line 1806 of yacc.c  */
 #line 243 "go.y"
     {
 		// import into my name space
@@ -2496,6 +2558,8 @@ yyreduce:
     break;
 
   case 19:
+
+/* Line 1806 of yacc.c  */
 #line 252 "go.y"
     {
 		if(importpkg->name == nil) {
@@ -2512,6 +2576,8 @@ yyreduce:
     break;
 
   case 21:
+
+/* Line 1806 of yacc.c  */
 #line 267 "go.y"
     {
 		if(strcmp((yyvsp[(1) - (1)].sym)->name, "safe") == 0)
@@ -2520,6 +2586,8 @@ yyreduce:
     break;
 
   case 22:
+
+/* Line 1806 of yacc.c  */
 #line 273 "go.y"
     {
 		defercheckwidth();
@@ -2527,6 +2595,8 @@ yyreduce:
     break;
 
   case 23:
+
+/* Line 1806 of yacc.c  */
 #line 277 "go.y"
     {
 		resumecheckwidth();
@@ -2535,6 +2605,8 @@ yyreduce:
     break;
 
   case 24:
+
+/* Line 1806 of yacc.c  */
 #line 286 "go.y"
     {
 		yyerror("empty top-level declaration");
@@ -2543,6 +2615,8 @@ yyreduce:
     break;
 
   case 26:
+
+/* Line 1806 of yacc.c  */
 #line 292 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -2550,6 +2624,8 @@ yyreduce:
     break;
 
   case 27:
+
+/* Line 1806 of yacc.c  */
 #line 296 "go.y"
     {
 		yyerror("non-declaration statement outside function body");
@@ -2558,6 +2634,8 @@ yyreduce:
     break;
 
   case 28:
+
+/* Line 1806 of yacc.c  */
 #line 301 "go.y"
     {
 		(yyval.list) = nil;
@@ -2565,6 +2643,8 @@ yyreduce:
     break;
 
   case 29:
+
+/* Line 1806 of yacc.c  */
 #line 307 "go.y"
     {
 		(yyval.list) = (yyvsp[(2) - (2)].list);
@@ -2572,6 +2652,8 @@ yyreduce:
     break;
 
   case 30:
+
+/* Line 1806 of yacc.c  */
 #line 311 "go.y"
     {
 		(yyval.list) = (yyvsp[(3) - (5)].list);
@@ -2579,6 +2661,8 @@ yyreduce:
     break;
 
   case 31:
+
+/* Line 1806 of yacc.c  */
 #line 315 "go.y"
     {
 		(yyval.list) = nil;
@@ -2586,6 +2670,8 @@ yyreduce:
     break;
 
   case 32:
+
+/* Line 1806 of yacc.c  */
 #line 319 "go.y"
     {
 		(yyval.list) = (yyvsp[(2) - (2)].list);
@@ -2595,6 +2681,8 @@ yyreduce:
     break;
 
   case 33:
+
+/* Line 1806 of yacc.c  */
 #line 325 "go.y"
     {
 		(yyval.list) = (yyvsp[(3) - (5)].list);
@@ -2604,6 +2692,8 @@ yyreduce:
     break;
 
   case 34:
+
+/* Line 1806 of yacc.c  */
 #line 331 "go.y"
     {
 		(yyval.list) = concat((yyvsp[(3) - (7)].list), (yyvsp[(5) - (7)].list));
@@ -2613,6 +2703,8 @@ yyreduce:
     break;
 
   case 35:
+
+/* Line 1806 of yacc.c  */
 #line 337 "go.y"
     {
 		(yyval.list) = nil;
@@ -2621,6 +2713,8 @@ yyreduce:
     break;
 
   case 36:
+
+/* Line 1806 of yacc.c  */
 #line 342 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(2) - (2)].node));
@@ -2628,6 +2722,8 @@ yyreduce:
     break;
 
   case 37:
+
+/* Line 1806 of yacc.c  */
 #line 346 "go.y"
     {
 		(yyval.list) = (yyvsp[(3) - (5)].list);
@@ -2635,6 +2731,8 @@ yyreduce:
     break;
 
   case 38:
+
+/* Line 1806 of yacc.c  */
 #line 350 "go.y"
     {
 		(yyval.list) = nil;
@@ -2642,6 +2740,8 @@ yyreduce:
     break;
 
   case 39:
+
+/* Line 1806 of yacc.c  */
 #line 356 "go.y"
     {
 		iota = 0;
@@ -2649,6 +2749,8 @@ yyreduce:
     break;
 
   case 40:
+
+/* Line 1806 of yacc.c  */
 #line 362 "go.y"
     {
 		(yyval.list) = variter((yyvsp[(1) - (2)].list), (yyvsp[(2) - (2)].node), nil);
@@ -2656,6 +2758,8 @@ yyreduce:
     break;
 
   case 41:
+
+/* Line 1806 of yacc.c  */
 #line 366 "go.y"
     {
 		(yyval.list) = variter((yyvsp[(1) - (4)].list), (yyvsp[(2) - (4)].node), (yyvsp[(4) - (4)].list));
@@ -2663,6 +2767,8 @@ yyreduce:
     break;
 
   case 42:
+
+/* Line 1806 of yacc.c  */
 #line 370 "go.y"
     {
 		(yyval.list) = variter((yyvsp[(1) - (3)].list), nil, (yyvsp[(3) - (3)].list));
@@ -2670,6 +2776,8 @@ yyreduce:
     break;
 
   case 43:
+
+/* Line 1806 of yacc.c  */
 #line 376 "go.y"
     {
 		(yyval.list) = constiter((yyvsp[(1) - (4)].list), (yyvsp[(2) - (4)].node), (yyvsp[(4) - (4)].list));
@@ -2677,6 +2785,8 @@ yyreduce:
     break;
 
   case 44:
+
+/* Line 1806 of yacc.c  */
 #line 380 "go.y"
     {
 		(yyval.list) = constiter((yyvsp[(1) - (3)].list), N, (yyvsp[(3) - (3)].list));
@@ -2684,6 +2794,8 @@ yyreduce:
     break;
 
   case 46:
+
+/* Line 1806 of yacc.c  */
 #line 387 "go.y"
     {
 		(yyval.list) = constiter((yyvsp[(1) - (2)].list), (yyvsp[(2) - (2)].node), nil);
@@ -2691,6 +2803,8 @@ yyreduce:
     break;
 
   case 47:
+
+/* Line 1806 of yacc.c  */
 #line 391 "go.y"
     {
 		(yyval.list) = constiter((yyvsp[(1) - (1)].list), N, nil);
@@ -2698,6 +2812,8 @@ yyreduce:
     break;
 
   case 48:
+
+/* Line 1806 of yacc.c  */
 #line 397 "go.y"
     {
 		// different from dclname because the name
@@ -2708,6 +2824,8 @@ yyreduce:
     break;
 
   case 49:
+
+/* Line 1806 of yacc.c  */
 #line 406 "go.y"
     {
 		(yyval.node) = typedcl1((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].node), 1);
@@ -2715,6 +2833,8 @@ yyreduce:
     break;
 
   case 50:
+
+/* Line 1806 of yacc.c  */
 #line 412 "go.y"
     {
 		(yyval.node) = (yyvsp[(1) - (1)].node);
@@ -2736,6 +2856,8 @@ yyreduce:
     break;
 
   case 51:
+
+/* Line 1806 of yacc.c  */
 #line 430 "go.y"
     {
 		(yyval.node) = nod(OASOP, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -2744,6 +2866,8 @@ yyreduce:
     break;
 
   case 52:
+
+/* Line 1806 of yacc.c  */
 #line 435 "go.y"
     {
 		if((yyvsp[(1) - (3)].list)->next == nil && (yyvsp[(3) - (3)].list)->next == nil) {
@@ -2759,6 +2883,8 @@ yyreduce:
     break;
 
   case 53:
+
+/* Line 1806 of yacc.c  */
 #line 447 "go.y"
     {
 		if((yyvsp[(3) - (3)].list)->n->op == OTYPESW) {
@@ -2778,6 +2904,8 @@ yyreduce:
     break;
 
   case 54:
+
+/* Line 1806 of yacc.c  */
 #line 463 "go.y"
     {
 		(yyval.node) = nod(OASOP, (yyvsp[(1) - (2)].node), nodintconst(1));
@@ -2786,6 +2914,8 @@ yyreduce:
     break;
 
   case 55:
+
+/* Line 1806 of yacc.c  */
 #line 468 "go.y"
     {
 		(yyval.node) = nod(OASOP, (yyvsp[(1) - (2)].node), nodintconst(1));
@@ -2794,6 +2924,8 @@ yyreduce:
     break;
 
   case 56:
+
+/* Line 1806 of yacc.c  */
 #line 475 "go.y"
     {
 		Node *n, *nn;
@@ -2817,6 +2949,8 @@ yyreduce:
     break;
 
   case 57:
+
+/* Line 1806 of yacc.c  */
 #line 495 "go.y"
     {
 		Node *n;
@@ -2838,6 +2972,8 @@ yyreduce:
     break;
 
   case 58:
+
+/* Line 1806 of yacc.c  */
 #line 513 "go.y"
     {
 		// will be converted to OCASE
@@ -2850,6 +2986,8 @@ yyreduce:
     break;
 
   case 59:
+
+/* Line 1806 of yacc.c  */
 #line 522 "go.y"
     {
 		Node *n, *nn;
@@ -2869,6 +3007,8 @@ yyreduce:
     break;
 
   case 60:
+
+/* Line 1806 of yacc.c  */
 #line 540 "go.y"
     {
 		markdcl();
@@ -2876,6 +3016,8 @@ yyreduce:
     break;
 
   case 61:
+
+/* Line 1806 of yacc.c  */
 #line 544 "go.y"
     {
 		if((yyvsp[(3) - (4)].list) == nil)
@@ -2887,6 +3029,8 @@ yyreduce:
     break;
 
   case 62:
+
+/* Line 1806 of yacc.c  */
 #line 554 "go.y"
     {
 		// If the last token read by the lexer was consumed
@@ -2900,6 +3044,8 @@ yyreduce:
     break;
 
   case 63:
+
+/* Line 1806 of yacc.c  */
 #line 564 "go.y"
     {
 		int last;
@@ -2922,6 +3068,8 @@ yyreduce:
     break;
 
   case 64:
+
+/* Line 1806 of yacc.c  */
 #line 584 "go.y"
     {
 		(yyval.list) = nil;
@@ -2929,6 +3077,8 @@ yyreduce:
     break;
 
   case 65:
+
+/* Line 1806 of yacc.c  */
 #line 588 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (2)].list), (yyvsp[(2) - (2)].node));
@@ -2936,6 +3086,8 @@ yyreduce:
     break;
 
   case 66:
+
+/* Line 1806 of yacc.c  */
 #line 594 "go.y"
     {
 		markdcl();
@@ -2943,6 +3095,8 @@ yyreduce:
     break;
 
   case 67:
+
+/* Line 1806 of yacc.c  */
 #line 598 "go.y"
     {
 		(yyval.list) = (yyvsp[(3) - (4)].list);
@@ -2951,6 +3105,8 @@ yyreduce:
     break;
 
   case 68:
+
+/* Line 1806 of yacc.c  */
 #line 605 "go.y"
     {
 		(yyval.node) = nod(ORANGE, N, (yyvsp[(4) - (4)].node));
@@ -2960,6 +3116,8 @@ yyreduce:
     break;
 
   case 69:
+
+/* Line 1806 of yacc.c  */
 #line 611 "go.y"
     {
 		(yyval.node) = nod(ORANGE, N, (yyvsp[(4) - (4)].node));
@@ -2970,6 +3128,8 @@ yyreduce:
     break;
 
   case 70:
+
+/* Line 1806 of yacc.c  */
 #line 620 "go.y"
     {
 		// init ; test ; incr
@@ -2984,6 +3144,8 @@ yyreduce:
     break;
 
   case 71:
+
+/* Line 1806 of yacc.c  */
 #line 631 "go.y"
     {
 		// normal test
@@ -2993,6 +3155,8 @@ yyreduce:
     break;
 
   case 73:
+
+/* Line 1806 of yacc.c  */
 #line 640 "go.y"
     {
 		(yyval.node) = (yyvsp[(1) - (2)].node);
@@ -3001,6 +3165,8 @@ yyreduce:
     break;
 
   case 74:
+
+/* Line 1806 of yacc.c  */
 #line 647 "go.y"
     {
 		markdcl();
@@ -3008,6 +3174,8 @@ yyreduce:
     break;
 
   case 75:
+
+/* Line 1806 of yacc.c  */
 #line 651 "go.y"
     {
 		(yyval.node) = (yyvsp[(3) - (3)].node);
@@ -3016,6 +3184,8 @@ yyreduce:
     break;
 
   case 76:
+
+/* Line 1806 of yacc.c  */
 #line 658 "go.y"
     {
 		// test
@@ -3025,6 +3195,8 @@ yyreduce:
     break;
 
   case 77:
+
+/* Line 1806 of yacc.c  */
 #line 664 "go.y"
     {
 		// init ; test
@@ -3036,6 +3208,8 @@ yyreduce:
     break;
 
   case 78:
+
+/* Line 1806 of yacc.c  */
 #line 675 "go.y"
     {
 		markdcl();
@@ -3043,6 +3217,8 @@ yyreduce:
     break;
 
   case 79:
+
+/* Line 1806 of yacc.c  */
 #line 679 "go.y"
     {
 		if((yyvsp[(3) - (3)].node)->ntest == N)
@@ -3051,6 +3227,8 @@ yyreduce:
     break;
 
   case 80:
+
+/* Line 1806 of yacc.c  */
 #line 684 "go.y"
     {
 		(yyvsp[(3) - (5)].node)->nbody = (yyvsp[(5) - (5)].list);
@@ -3058,6 +3236,8 @@ yyreduce:
     break;
 
   case 81:
+
+/* Line 1806 of yacc.c  */
 #line 688 "go.y"
     {
 		Node *n;
@@ -3076,6 +3256,8 @@ yyreduce:
     break;
 
   case 82:
+
+/* Line 1806 of yacc.c  */
 #line 705 "go.y"
     {
 		markdcl();
@@ -3083,6 +3265,8 @@ yyreduce:
     break;
 
   case 83:
+
+/* Line 1806 of yacc.c  */
 #line 709 "go.y"
     {
 		if((yyvsp[(4) - (5)].node)->ntest == N)
@@ -3093,6 +3277,8 @@ yyreduce:
     break;
 
   case 84:
+
+/* Line 1806 of yacc.c  */
 #line 717 "go.y"
     {
 		(yyval.list) = nil;
@@ -3100,6 +3286,8 @@ yyreduce:
     break;
 
   case 85:
+
+/* Line 1806 of yacc.c  */
 #line 721 "go.y"
     {
 		(yyval.list) = concat((yyvsp[(1) - (2)].list), (yyvsp[(2) - (2)].list));
@@ -3107,6 +3295,8 @@ yyreduce:
     break;
 
   case 86:
+
+/* Line 1806 of yacc.c  */
 #line 726 "go.y"
     {
 		(yyval.list) = nil;
@@ -3114,6 +3304,8 @@ yyreduce:
     break;
 
   case 87:
+
+/* Line 1806 of yacc.c  */
 #line 730 "go.y"
     {
 		NodeList *node;
@@ -3126,6 +3318,8 @@ yyreduce:
     break;
 
   case 88:
+
+/* Line 1806 of yacc.c  */
 #line 741 "go.y"
     {
 		markdcl();
@@ -3133,6 +3327,8 @@ yyreduce:
     break;
 
   case 89:
+
+/* Line 1806 of yacc.c  */
 #line 745 "go.y"
     {
 		Node *n;
@@ -3144,6 +3340,8 @@ yyreduce:
     break;
 
   case 90:
+
+/* Line 1806 of yacc.c  */
 #line 753 "go.y"
     {
 		(yyval.node) = (yyvsp[(3) - (7)].node);
@@ -3155,6 +3353,8 @@ yyreduce:
     break;
 
   case 91:
+
+/* Line 1806 of yacc.c  */
 #line 763 "go.y"
     {
 		typesw = nod(OXXX, typesw, N);
@@ -3162,6 +3362,8 @@ yyreduce:
     break;
 
   case 92:
+
+/* Line 1806 of yacc.c  */
 #line 767 "go.y"
     {
 		(yyval.node) = nod(OSELECT, N, N);
@@ -3172,6 +3374,8 @@ yyreduce:
     break;
 
   case 94:
+
+/* Line 1806 of yacc.c  */
 #line 780 "go.y"
     {
 		(yyval.node) = nod(OOROR, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3179,6 +3383,8 @@ yyreduce:
     break;
 
   case 95:
+
+/* Line 1806 of yacc.c  */
 #line 784 "go.y"
     {
 		(yyval.node) = nod(OANDAND, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3186,6 +3392,8 @@ yyreduce:
     break;
 
   case 96:
+
+/* Line 1806 of yacc.c  */
 #line 788 "go.y"
     {
 		(yyval.node) = nod(OEQ, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3193,6 +3401,8 @@ yyreduce:
     break;
 
   case 97:
+
+/* Line 1806 of yacc.c  */
 #line 792 "go.y"
     {
 		(yyval.node) = nod(ONE, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3200,6 +3410,8 @@ yyreduce:
     break;
 
   case 98:
+
+/* Line 1806 of yacc.c  */
 #line 796 "go.y"
     {
 		(yyval.node) = nod(OLT, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3207,6 +3419,8 @@ yyreduce:
     break;
 
   case 99:
+
+/* Line 1806 of yacc.c  */
 #line 800 "go.y"
     {
 		(yyval.node) = nod(OLE, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3214,6 +3428,8 @@ yyreduce:
     break;
 
   case 100:
+
+/* Line 1806 of yacc.c  */
 #line 804 "go.y"
     {
 		(yyval.node) = nod(OGE, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3221,6 +3437,8 @@ yyreduce:
     break;
 
   case 101:
+
+/* Line 1806 of yacc.c  */
 #line 808 "go.y"
     {
 		(yyval.node) = nod(OGT, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3228,6 +3446,8 @@ yyreduce:
     break;
 
   case 102:
+
+/* Line 1806 of yacc.c  */
 #line 812 "go.y"
     {
 		(yyval.node) = nod(OADD, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3235,6 +3455,8 @@ yyreduce:
     break;
 
   case 103:
+
+/* Line 1806 of yacc.c  */
 #line 816 "go.y"
     {
 		(yyval.node) = nod(OSUB, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3242,6 +3464,8 @@ yyreduce:
     break;
 
   case 104:
+
+/* Line 1806 of yacc.c  */
 #line 820 "go.y"
     {
 		(yyval.node) = nod(OOR, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3249,6 +3473,8 @@ yyreduce:
     break;
 
   case 105:
+
+/* Line 1806 of yacc.c  */
 #line 824 "go.y"
     {
 		(yyval.node) = nod(OXOR, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3256,6 +3482,8 @@ yyreduce:
     break;
 
   case 106:
+
+/* Line 1806 of yacc.c  */
 #line 828 "go.y"
     {
 		(yyval.node) = nod(OMUL, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3263,6 +3491,8 @@ yyreduce:
     break;
 
   case 107:
+
+/* Line 1806 of yacc.c  */
 #line 832 "go.y"
     {
 		(yyval.node) = nod(ODIV, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3270,6 +3500,8 @@ yyreduce:
     break;
 
   case 108:
+
+/* Line 1806 of yacc.c  */
 #line 836 "go.y"
     {
 		(yyval.node) = nod(OMOD, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3277,6 +3509,8 @@ yyreduce:
     break;
 
   case 109:
+
+/* Line 1806 of yacc.c  */
 #line 840 "go.y"
     {
 		(yyval.node) = nod(OAND, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3284,6 +3518,8 @@ yyreduce:
     break;
 
   case 110:
+
+/* Line 1806 of yacc.c  */
 #line 844 "go.y"
     {
 		(yyval.node) = nod(OANDNOT, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3291,6 +3527,8 @@ yyreduce:
     break;
 
   case 111:
+
+/* Line 1806 of yacc.c  */
 #line 848 "go.y"
     {
 		(yyval.node) = nod(OLSH, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3298,6 +3536,8 @@ yyreduce:
     break;
 
   case 112:
+
+/* Line 1806 of yacc.c  */
 #line 852 "go.y"
     {
 		(yyval.node) = nod(ORSH, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3305,6 +3545,8 @@ yyreduce:
     break;
 
   case 113:
+
+/* Line 1806 of yacc.c  */
 #line 857 "go.y"
     {
 		(yyval.node) = nod(OSEND, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3312,6 +3554,8 @@ yyreduce:
     break;
 
   case 115:
+
+/* Line 1806 of yacc.c  */
 #line 864 "go.y"
     {
 		(yyval.node) = nod(OIND, (yyvsp[(2) - (2)].node), N);
@@ -3319,6 +3563,8 @@ yyreduce:
     break;
 
   case 116:
+
+/* Line 1806 of yacc.c  */
 #line 868 "go.y"
     {
 		if((yyvsp[(2) - (2)].node)->op == OCOMPLIT) {
@@ -3333,6 +3579,8 @@ yyreduce:
     break;
 
   case 117:
+
+/* Line 1806 of yacc.c  */
 #line 879 "go.y"
     {
 		(yyval.node) = nod(OPLUS, (yyvsp[(2) - (2)].node), N);
@@ -3340,6 +3588,8 @@ yyreduce:
     break;
 
   case 118:
+
+/* Line 1806 of yacc.c  */
 #line 883 "go.y"
     {
 		(yyval.node) = nod(OMINUS, (yyvsp[(2) - (2)].node), N);
@@ -3347,6 +3597,8 @@ yyreduce:
     break;
 
   case 119:
+
+/* Line 1806 of yacc.c  */
 #line 887 "go.y"
     {
 		(yyval.node) = nod(ONOT, (yyvsp[(2) - (2)].node), N);
@@ -3354,6 +3606,8 @@ yyreduce:
     break;
 
   case 120:
+
+/* Line 1806 of yacc.c  */
 #line 891 "go.y"
     {
 		yyerror("the bitwise complement operator is ^");
@@ -3362,6 +3616,8 @@ yyreduce:
     break;
 
   case 121:
+
+/* Line 1806 of yacc.c  */
 #line 896 "go.y"
     {
 		(yyval.node) = nod(OCOM, (yyvsp[(2) - (2)].node), N);
@@ -3369,6 +3625,8 @@ yyreduce:
     break;
 
   case 122:
+
+/* Line 1806 of yacc.c  */
 #line 900 "go.y"
     {
 		(yyval.node) = nod(ORECV, (yyvsp[(2) - (2)].node), N);
@@ -3376,6 +3634,8 @@ yyreduce:
     break;
 
   case 123:
+
+/* Line 1806 of yacc.c  */
 #line 910 "go.y"
     {
 		(yyval.node) = nod(OCALL, (yyvsp[(1) - (3)].node), N);
@@ -3383,6 +3643,8 @@ yyreduce:
     break;
 
   case 124:
+
+/* Line 1806 of yacc.c  */
 #line 914 "go.y"
     {
 		(yyval.node) = nod(OCALL, (yyvsp[(1) - (5)].node), N);
@@ -3391,6 +3653,8 @@ yyreduce:
     break;
 
   case 125:
+
+/* Line 1806 of yacc.c  */
 #line 919 "go.y"
     {
 		(yyval.node) = nod(OCALL, (yyvsp[(1) - (6)].node), N);
@@ -3400,6 +3664,8 @@ yyreduce:
     break;
 
   case 126:
+
+/* Line 1806 of yacc.c  */
 #line 927 "go.y"
     {
 		(yyval.node) = nodlit((yyvsp[(1) - (1)].val));
@@ -3407,6 +3673,8 @@ yyreduce:
     break;
 
   case 128:
+
+/* Line 1806 of yacc.c  */
 #line 932 "go.y"
     {
 		if((yyvsp[(1) - (3)].node)->op == OPACK) {
@@ -3421,6 +3689,8 @@ yyreduce:
     break;
 
   case 129:
+
+/* Line 1806 of yacc.c  */
 #line 943 "go.y"
     {
 		(yyval.node) = nod(ODOTTYPE, (yyvsp[(1) - (5)].node), (yyvsp[(4) - (5)].node));
@@ -3428,6 +3698,8 @@ yyreduce:
     break;
 
   case 130:
+
+/* Line 1806 of yacc.c  */
 #line 947 "go.y"
     {
 		(yyval.node) = nod(OTYPESW, N, (yyvsp[(1) - (5)].node));
@@ -3435,6 +3707,8 @@ yyreduce:
     break;
 
   case 131:
+
+/* Line 1806 of yacc.c  */
 #line 951 "go.y"
     {
 		(yyval.node) = nod(OINDEX, (yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].node));
@@ -3442,6 +3716,8 @@ yyreduce:
     break;
 
   case 132:
+
+/* Line 1806 of yacc.c  */
 #line 955 "go.y"
     {
 		(yyval.node) = nod(OSLICE, (yyvsp[(1) - (6)].node), nod(OKEY, (yyvsp[(3) - (6)].node), (yyvsp[(5) - (6)].node)));
@@ -3449,6 +3725,8 @@ yyreduce:
     break;
 
   case 133:
+
+/* Line 1806 of yacc.c  */
 #line 959 "go.y"
     {
 		// Make sure we don't accidentally release this experimental feature.
@@ -3467,6 +3745,8 @@ yyreduce:
     break;
 
   case 135:
+
+/* Line 1806 of yacc.c  */
 #line 975 "go.y"
     {
 		// conversion
@@ -3476,6 +3756,8 @@ yyreduce:
     break;
 
   case 136:
+
+/* Line 1806 of yacc.c  */
 #line 981 "go.y"
     {
 		(yyval.node) = (yyvsp[(3) - (5)].node);
@@ -3486,6 +3768,8 @@ yyreduce:
     break;
 
   case 137:
+
+/* Line 1806 of yacc.c  */
 #line 988 "go.y"
     {
 		(yyval.node) = (yyvsp[(3) - (5)].node);
@@ -3495,6 +3779,8 @@ yyreduce:
     break;
 
   case 138:
+
+/* Line 1806 of yacc.c  */
 #line 994 "go.y"
     {
 		yyerror("cannot parenthesize type in composite literal");
@@ -3505,6 +3791,8 @@ yyreduce:
     break;
 
   case 140:
+
+/* Line 1806 of yacc.c  */
 #line 1003 "go.y"
     {
 		// composite expression.
@@ -3514,6 +3802,8 @@ yyreduce:
     break;
 
   case 141:
+
+/* Line 1806 of yacc.c  */
 #line 1011 "go.y"
     {
 		(yyval.node) = nod(OKEY, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
@@ -3521,6 +3811,8 @@ yyreduce:
     break;
 
   case 142:
+
+/* Line 1806 of yacc.c  */
 #line 1017 "go.y"
     {
 		// These nodes do not carry line numbers.
@@ -3541,6 +3833,8 @@ yyreduce:
     break;
 
   case 143:
+
+/* Line 1806 of yacc.c  */
 #line 1034 "go.y"
     {
 		(yyval.node) = (yyvsp[(2) - (4)].node);
@@ -3549,6 +3843,8 @@ yyreduce:
     break;
 
   case 145:
+
+/* Line 1806 of yacc.c  */
 #line 1042 "go.y"
     {
 		(yyval.node) = (yyvsp[(2) - (4)].node);
@@ -3557,6 +3853,8 @@ yyreduce:
     break;
 
   case 147:
+
+/* Line 1806 of yacc.c  */
 #line 1050 "go.y"
     {
 		(yyval.node) = (yyvsp[(2) - (3)].node);
@@ -3577,6 +3875,8 @@ yyreduce:
     break;
 
   case 151:
+
+/* Line 1806 of yacc.c  */
 #line 1076 "go.y"
     {
 		(yyval.i) = LBODY;
@@ -3584,6 +3884,8 @@ yyreduce:
     break;
 
   case 152:
+
+/* Line 1806 of yacc.c  */
 #line 1080 "go.y"
     {
 		(yyval.i) = '{';
@@ -3591,6 +3893,8 @@ yyreduce:
     break;
 
   case 153:
+
+/* Line 1806 of yacc.c  */
 #line 1091 "go.y"
     {
 		if((yyvsp[(1) - (1)].sym) == S)
@@ -3601,6 +3905,8 @@ yyreduce:
     break;
 
   case 154:
+
+/* Line 1806 of yacc.c  */
 #line 1100 "go.y"
     {
 		(yyval.node) = dclname((yyvsp[(1) - (1)].sym));
@@ -3608,6 +3914,8 @@ yyreduce:
     break;
 
   case 155:
+
+/* Line 1806 of yacc.c  */
 #line 1105 "go.y"
     {
 		(yyval.node) = N;
@@ -3615,6 +3923,8 @@ yyreduce:
     break;
 
   case 157:
+
+/* Line 1806 of yacc.c  */
 #line 1112 "go.y"
     {
 		(yyval.sym) = (yyvsp[(1) - (1)].sym);
@@ -3625,6 +3935,8 @@ yyreduce:
     break;
 
   case 159:
+
+/* Line 1806 of yacc.c  */
 #line 1120 "go.y"
     {
 		(yyval.sym) = S;
@@ -3632,6 +3944,8 @@ yyreduce:
     break;
 
   case 160:
+
+/* Line 1806 of yacc.c  */
 #line 1126 "go.y"
     {
 		Pkg *p;
@@ -3648,6 +3962,8 @@ yyreduce:
     break;
 
   case 161:
+
+/* Line 1806 of yacc.c  */
 #line 1141 "go.y"
     {
 		(yyval.node) = oldname((yyvsp[(1) - (1)].sym));
@@ -3657,6 +3973,8 @@ yyreduce:
     break;
 
   case 163:
+
+/* Line 1806 of yacc.c  */
 #line 1161 "go.y"
     {
 		yyerror("final argument in variadic function missing type");
@@ -3665,6 +3983,8 @@ yyreduce:
     break;
 
   case 164:
+
+/* Line 1806 of yacc.c  */
 #line 1166 "go.y"
     {
 		(yyval.node) = nod(ODDD, (yyvsp[(2) - (2)].node), N);
@@ -3672,6 +3992,8 @@ yyreduce:
     break;
 
   case 170:
+
+/* Line 1806 of yacc.c  */
 #line 1177 "go.y"
     {
 		(yyval.node) = nod(OTPAREN, (yyvsp[(2) - (3)].node), N);
@@ -3679,6 +4001,8 @@ yyreduce:
     break;
 
   case 174:
+
+/* Line 1806 of yacc.c  */
 #line 1186 "go.y"
     {
 		(yyval.node) = nod(OIND, (yyvsp[(2) - (2)].node), N);
@@ -3686,6 +4010,8 @@ yyreduce:
     break;
 
   case 179:
+
+/* Line 1806 of yacc.c  */
 #line 1196 "go.y"
     {
 		(yyval.node) = nod(OTPAREN, (yyvsp[(2) - (3)].node), N);
@@ -3693,6 +4019,8 @@ yyreduce:
     break;
 
   case 189:
+
+/* Line 1806 of yacc.c  */
 #line 1217 "go.y"
     {
 		if((yyvsp[(1) - (3)].node)->op == OPACK) {
@@ -3707,6 +4035,8 @@ yyreduce:
     break;
 
   case 190:
+
+/* Line 1806 of yacc.c  */
 #line 1230 "go.y"
     {
 		(yyval.node) = nod(OTARRAY, (yyvsp[(2) - (4)].node), (yyvsp[(4) - (4)].node));
@@ -3714,6 +4044,8 @@ yyreduce:
     break;
 
   case 191:
+
+/* Line 1806 of yacc.c  */
 #line 1234 "go.y"
     {
 		// array literal of nelem
@@ -3722,6 +4054,8 @@ yyreduce:
     break;
 
   case 192:
+
+/* Line 1806 of yacc.c  */
 #line 1239 "go.y"
     {
 		(yyval.node) = nod(OTCHAN, (yyvsp[(2) - (2)].node), N);
@@ -3730,6 +4064,8 @@ yyreduce:
     break;
 
   case 193:
+
+/* Line 1806 of yacc.c  */
 #line 1244 "go.y"
     {
 		(yyval.node) = nod(OTCHAN, (yyvsp[(3) - (3)].node), N);
@@ -3738,6 +4074,8 @@ yyreduce:
     break;
 
   case 194:
+
+/* Line 1806 of yacc.c  */
 #line 1249 "go.y"
     {
 		(yyval.node) = nod(OTMAP, (yyvsp[(3) - (5)].node), (yyvsp[(5) - (5)].node));
@@ -3745,6 +4083,8 @@ yyreduce:
     break;
 
   case 197:
+
+/* Line 1806 of yacc.c  */
 #line 1257 "go.y"
     {
 		(yyval.node) = nod(OIND, (yyvsp[(2) - (2)].node), N);
@@ -3752,6 +4092,8 @@ yyreduce:
     break;
 
   case 198:
+
+/* Line 1806 of yacc.c  */
 #line 1263 "go.y"
     {
 		(yyval.node) = nod(OTCHAN, (yyvsp[(3) - (3)].node), N);
@@ -3760,6 +4102,8 @@ yyreduce:
     break;
 
   case 199:
+
+/* Line 1806 of yacc.c  */
 #line 1270 "go.y"
     {
 		(yyval.node) = nod(OTSTRUCT, N, N);
@@ -3769,6 +4113,8 @@ yyreduce:
     break;
 
   case 200:
+
+/* Line 1806 of yacc.c  */
 #line 1276 "go.y"
     {
 		(yyval.node) = nod(OTSTRUCT, N, N);
@@ -3777,6 +4123,8 @@ yyreduce:
     break;
 
   case 201:
+
+/* Line 1806 of yacc.c  */
 #line 1283 "go.y"
     {
 		(yyval.node) = nod(OTINTER, N, N);
@@ -3786,6 +4134,8 @@ yyreduce:
     break;
 
   case 202:
+
+/* Line 1806 of yacc.c  */
 #line 1289 "go.y"
     {
 		(yyval.node) = nod(OTINTER, N, N);
@@ -3794,6 +4144,8 @@ yyreduce:
     break;
 
   case 203:
+
+/* Line 1806 of yacc.c  */
 #line 1300 "go.y"
     {
 		(yyval.node) = (yyvsp[(2) - (3)].node);
@@ -3809,6 +4161,8 @@ yyreduce:
     break;
 
   case 204:
+
+/* Line 1806 of yacc.c  */
 #line 1314 "go.y"
     {
 		Node *t;
@@ -3841,6 +4195,8 @@ yyreduce:
     break;
 
   case 205:
+
+/* Line 1806 of yacc.c  */
 #line 1343 "go.y"
     {
 		Node *rcvr, *t;
@@ -3882,6 +4238,8 @@ yyreduce:
     break;
 
   case 206:
+
+/* Line 1806 of yacc.c  */
 #line 1383 "go.y"
     {
 		Sym *s;
@@ -3910,6 +4268,8 @@ yyreduce:
     break;
 
   case 207:
+
+/* Line 1806 of yacc.c  */
 #line 1408 "go.y"
     {
 		(yyval.node) = methodname1(newname((yyvsp[(4) - (8)].sym)), (yyvsp[(2) - (8)].list)->n->right); 
@@ -3929,6 +4289,8 @@ yyreduce:
     break;
 
   case 208:
+
+/* Line 1806 of yacc.c  */
 #line 1426 "go.y"
     {
 		(yyvsp[(3) - (5)].list) = checkarglist((yyvsp[(3) - (5)].list), 1);
@@ -3939,6 +4301,8 @@ yyreduce:
     break;
 
   case 209:
+
+/* Line 1806 of yacc.c  */
 #line 1434 "go.y"
     {
 		(yyval.list) = nil;
@@ -3946,6 +4310,8 @@ yyreduce:
     break;
 
   case 210:
+
+/* Line 1806 of yacc.c  */
 #line 1438 "go.y"
     {
 		(yyval.list) = (yyvsp[(2) - (3)].list);
@@ -3955,6 +4321,8 @@ yyreduce:
     break;
 
   case 211:
+
+/* Line 1806 of yacc.c  */
 #line 1446 "go.y"
     {
 		(yyval.list) = nil;
@@ -3962,6 +4330,8 @@ yyreduce:
     break;
 
   case 212:
+
+/* Line 1806 of yacc.c  */
 #line 1450 "go.y"
     {
 		(yyval.list) = list1(nod(ODCLFIELD, N, (yyvsp[(1) - (1)].node)));
@@ -3969,6 +4339,8 @@ yyreduce:
     break;
 
   case 213:
+
+/* Line 1806 of yacc.c  */
 #line 1454 "go.y"
     {
 		(yyvsp[(2) - (3)].list) = checkarglist((yyvsp[(2) - (3)].list), 0);
@@ -3977,6 +4349,8 @@ yyreduce:
     break;
 
   case 214:
+
+/* Line 1806 of yacc.c  */
 #line 1461 "go.y"
     {
 		closurehdr((yyvsp[(1) - (1)].node));
@@ -3984,6 +4358,8 @@ yyreduce:
     break;
 
   case 215:
+
+/* Line 1806 of yacc.c  */
 #line 1467 "go.y"
     {
 		(yyval.node) = closurebody((yyvsp[(3) - (4)].list));
@@ -3992,6 +4368,8 @@ yyreduce:
     break;
 
   case 216:
+
+/* Line 1806 of yacc.c  */
 #line 1472 "go.y"
     {
 		(yyval.node) = closurebody(nil);
@@ -3999,6 +4377,8 @@ yyreduce:
     break;
 
   case 217:
+
+/* Line 1806 of yacc.c  */
 #line 1483 "go.y"
     {
 		(yyval.list) = nil;
@@ -4006,6 +4386,8 @@ yyreduce:
     break;
 
   case 218:
+
+/* Line 1806 of yacc.c  */
 #line 1487 "go.y"
     {
 		(yyval.list) = concat((yyvsp[(1) - (3)].list), (yyvsp[(2) - (3)].list));
@@ -4017,6 +4399,8 @@ yyreduce:
     break;
 
   case 220:
+
+/* Line 1806 of yacc.c  */
 #line 1498 "go.y"
     {
 		(yyval.list) = concat((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].list));
@@ -4024,6 +4408,8 @@ yyreduce:
     break;
 
   case 222:
+
+/* Line 1806 of yacc.c  */
 #line 1505 "go.y"
     {
 		(yyval.list) = concat((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].list));
@@ -4031,6 +4417,8 @@ yyreduce:
     break;
 
   case 223:
+
+/* Line 1806 of yacc.c  */
 #line 1511 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4038,6 +4426,8 @@ yyreduce:
     break;
 
   case 224:
+
+/* Line 1806 of yacc.c  */
 #line 1515 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4045,6 +4435,8 @@ yyreduce:
     break;
 
   case 226:
+
+/* Line 1806 of yacc.c  */
 #line 1522 "go.y"
     {
 		(yyval.list) = concat((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].list));
@@ -4052,6 +4444,8 @@ yyreduce:
     break;
 
   case 227:
+
+/* Line 1806 of yacc.c  */
 #line 1528 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4059,6 +4453,8 @@ yyreduce:
     break;
 
   case 228:
+
+/* Line 1806 of yacc.c  */
 #line 1532 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4066,6 +4462,8 @@ yyreduce:
     break;
 
   case 229:
+
+/* Line 1806 of yacc.c  */
 #line 1538 "go.y"
     {
 		NodeList *l;
@@ -4092,6 +4490,8 @@ yyreduce:
     break;
 
   case 230:
+
+/* Line 1806 of yacc.c  */
 #line 1561 "go.y"
     {
 		(yyvsp[(1) - (2)].node)->val = (yyvsp[(2) - (2)].val);
@@ -4100,6 +4500,8 @@ yyreduce:
     break;
 
   case 231:
+
+/* Line 1806 of yacc.c  */
 #line 1566 "go.y"
     {
 		(yyvsp[(2) - (4)].node)->val = (yyvsp[(4) - (4)].val);
@@ -4109,6 +4511,8 @@ yyreduce:
     break;
 
   case 232:
+
+/* Line 1806 of yacc.c  */
 #line 1572 "go.y"
     {
 		(yyvsp[(2) - (3)].node)->right = nod(OIND, (yyvsp[(2) - (3)].node)->right, N);
@@ -4118,6 +4522,8 @@ yyreduce:
     break;
 
   case 233:
+
+/* Line 1806 of yacc.c  */
 #line 1578 "go.y"
     {
 		(yyvsp[(3) - (5)].node)->right = nod(OIND, (yyvsp[(3) - (5)].node)->right, N);
@@ -4128,6 +4534,8 @@ yyreduce:
     break;
 
   case 234:
+
+/* Line 1806 of yacc.c  */
 #line 1585 "go.y"
     {
 		(yyvsp[(3) - (5)].node)->right = nod(OIND, (yyvsp[(3) - (5)].node)->right, N);
@@ -4138,6 +4546,8 @@ yyreduce:
     break;
 
   case 235:
+
+/* Line 1806 of yacc.c  */
 #line 1594 "go.y"
     {
 		Node *n;
@@ -4150,6 +4560,8 @@ yyreduce:
     break;
 
   case 236:
+
+/* Line 1806 of yacc.c  */
 #line 1603 "go.y"
     {
 		Pkg *pkg;
@@ -4166,6 +4578,8 @@ yyreduce:
     break;
 
   case 237:
+
+/* Line 1806 of yacc.c  */
 #line 1618 "go.y"
     {
 		(yyval.node) = embedded((yyvsp[(1) - (1)].sym));
@@ -4173,6 +4587,8 @@ yyreduce:
     break;
 
   case 238:
+
+/* Line 1806 of yacc.c  */
 #line 1624 "go.y"
     {
 		(yyval.node) = nod(ODCLFIELD, (yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].node));
@@ -4181,6 +4597,8 @@ yyreduce:
     break;
 
   case 239:
+
+/* Line 1806 of yacc.c  */
 #line 1629 "go.y"
     {
 		(yyval.node) = nod(ODCLFIELD, N, oldname((yyvsp[(1) - (1)].sym)));
@@ -4188,6 +4606,8 @@ yyreduce:
     break;
 
   case 240:
+
+/* Line 1806 of yacc.c  */
 #line 1633 "go.y"
     {
 		(yyval.node) = nod(ODCLFIELD, N, oldname((yyvsp[(2) - (3)].sym)));
@@ -4196,6 +4616,8 @@ yyreduce:
     break;
 
   case 241:
+
+/* Line 1806 of yacc.c  */
 #line 1640 "go.y"
     {
 		// without func keyword
@@ -4207,6 +4629,8 @@ yyreduce:
     break;
 
   case 243:
+
+/* Line 1806 of yacc.c  */
 #line 1654 "go.y"
     {
 		(yyval.node) = nod(ONONAME, N, N);
@@ -4216,6 +4640,8 @@ yyreduce:
     break;
 
   case 244:
+
+/* Line 1806 of yacc.c  */
 #line 1660 "go.y"
     {
 		(yyval.node) = nod(ONONAME, N, N);
@@ -4225,6 +4651,8 @@ yyreduce:
     break;
 
   case 246:
+
+/* Line 1806 of yacc.c  */
 #line 1669 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4232,6 +4660,8 @@ yyreduce:
     break;
 
   case 247:
+
+/* Line 1806 of yacc.c  */
 #line 1673 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4239,6 +4669,8 @@ yyreduce:
     break;
 
   case 248:
+
+/* Line 1806 of yacc.c  */
 #line 1678 "go.y"
     {
 		(yyval.list) = nil;
@@ -4246,6 +4678,8 @@ yyreduce:
     break;
 
   case 249:
+
+/* Line 1806 of yacc.c  */
 #line 1682 "go.y"
     {
 		(yyval.list) = (yyvsp[(1) - (2)].list);
@@ -4253,6 +4687,8 @@ yyreduce:
     break;
 
   case 250:
+
+/* Line 1806 of yacc.c  */
 #line 1690 "go.y"
     {
 		(yyval.node) = N;
@@ -4260,6 +4696,8 @@ yyreduce:
     break;
 
   case 252:
+
+/* Line 1806 of yacc.c  */
 #line 1695 "go.y"
     {
 		(yyval.node) = liststmt((yyvsp[(1) - (1)].list));
@@ -4267,6 +4705,8 @@ yyreduce:
     break;
 
   case 254:
+
+/* Line 1806 of yacc.c  */
 #line 1700 "go.y"
     {
 		(yyval.node) = N;
@@ -4274,6 +4714,8 @@ yyreduce:
     break;
 
   case 260:
+
+/* Line 1806 of yacc.c  */
 #line 1711 "go.y"
     {
 		(yyvsp[(1) - (2)].node) = nod(OLABEL, (yyvsp[(1) - (2)].node), N);
@@ -4282,6 +4724,8 @@ yyreduce:
     break;
 
   case 261:
+
+/* Line 1806 of yacc.c  */
 #line 1716 "go.y"
     {
 		NodeList *l;
@@ -4295,6 +4739,8 @@ yyreduce:
     break;
 
   case 262:
+
+/* Line 1806 of yacc.c  */
 #line 1726 "go.y"
     {
 		// will be converted to OFALL
@@ -4303,6 +4749,8 @@ yyreduce:
     break;
 
   case 263:
+
+/* Line 1806 of yacc.c  */
 #line 1731 "go.y"
     {
 		(yyval.node) = nod(OBREAK, (yyvsp[(2) - (2)].node), N);
@@ -4310,6 +4758,8 @@ yyreduce:
     break;
 
   case 264:
+
+/* Line 1806 of yacc.c  */
 #line 1735 "go.y"
     {
 		(yyval.node) = nod(OCONTINUE, (yyvsp[(2) - (2)].node), N);
@@ -4317,6 +4767,8 @@ yyreduce:
     break;
 
   case 265:
+
+/* Line 1806 of yacc.c  */
 #line 1739 "go.y"
     {
 		(yyval.node) = nod(OPROC, (yyvsp[(2) - (2)].node), N);
@@ -4324,6 +4776,8 @@ yyreduce:
     break;
 
   case 266:
+
+/* Line 1806 of yacc.c  */
 #line 1743 "go.y"
     {
 		(yyval.node) = nod(ODEFER, (yyvsp[(2) - (2)].node), N);
@@ -4331,6 +4785,8 @@ yyreduce:
     break;
 
   case 267:
+
+/* Line 1806 of yacc.c  */
 #line 1747 "go.y"
     {
 		(yyval.node) = nod(OGOTO, (yyvsp[(2) - (2)].node), N);
@@ -4339,6 +4795,8 @@ yyreduce:
     break;
 
   case 268:
+
+/* Line 1806 of yacc.c  */
 #line 1752 "go.y"
     {
 		(yyval.node) = nod(ORETURN, N, N);
@@ -4359,6 +4817,8 @@ yyreduce:
     break;
 
   case 269:
+
+/* Line 1806 of yacc.c  */
 #line 1771 "go.y"
     {
 		(yyval.list) = nil;
@@ -4368,6 +4828,8 @@ yyreduce:
     break;
 
   case 270:
+
+/* Line 1806 of yacc.c  */
 #line 1777 "go.y"
     {
 		(yyval.list) = (yyvsp[(1) - (3)].list);
@@ -4377,6 +4839,8 @@ yyreduce:
     break;
 
   case 271:
+
+/* Line 1806 of yacc.c  */
 #line 1785 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4384,6 +4848,8 @@ yyreduce:
     break;
 
   case 272:
+
+/* Line 1806 of yacc.c  */
 #line 1789 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4391,6 +4857,8 @@ yyreduce:
     break;
 
   case 273:
+
+/* Line 1806 of yacc.c  */
 #line 1795 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4398,6 +4866,8 @@ yyreduce:
     break;
 
   case 274:
+
+/* Line 1806 of yacc.c  */
 #line 1799 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4405,6 +4875,8 @@ yyreduce:
     break;
 
   case 275:
+
+/* Line 1806 of yacc.c  */
 #line 1805 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4412,6 +4884,8 @@ yyreduce:
     break;
 
   case 276:
+
+/* Line 1806 of yacc.c  */
 #line 1809 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4419,6 +4893,8 @@ yyreduce:
     break;
 
   case 277:
+
+/* Line 1806 of yacc.c  */
 #line 1815 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4426,6 +4902,8 @@ yyreduce:
     break;
 
   case 278:
+
+/* Line 1806 of yacc.c  */
 #line 1819 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4433,6 +4911,8 @@ yyreduce:
     break;
 
   case 279:
+
+/* Line 1806 of yacc.c  */
 #line 1828 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4440,6 +4920,8 @@ yyreduce:
     break;
 
   case 280:
+
+/* Line 1806 of yacc.c  */
 #line 1832 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4447,6 +4929,8 @@ yyreduce:
     break;
 
   case 281:
+
+/* Line 1806 of yacc.c  */
 #line 1836 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4454,6 +4938,8 @@ yyreduce:
     break;
 
   case 282:
+
+/* Line 1806 of yacc.c  */
 #line 1840 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4461,6 +4947,8 @@ yyreduce:
     break;
 
   case 283:
+
+/* Line 1806 of yacc.c  */
 #line 1845 "go.y"
     {
 		(yyval.list) = nil;
@@ -4468,6 +4956,8 @@ yyreduce:
     break;
 
   case 284:
+
+/* Line 1806 of yacc.c  */
 #line 1849 "go.y"
     {
 		(yyval.list) = (yyvsp[(1) - (2)].list);
@@ -4475,6 +4965,8 @@ yyreduce:
     break;
 
   case 289:
+
+/* Line 1806 of yacc.c  */
 #line 1863 "go.y"
     {
 		(yyval.node) = N;
@@ -4482,6 +4974,8 @@ yyreduce:
     break;
 
   case 291:
+
+/* Line 1806 of yacc.c  */
 #line 1869 "go.y"
     {
 		(yyval.list) = nil;
@@ -4489,6 +4983,8 @@ yyreduce:
     break;
 
   case 293:
+
+/* Line 1806 of yacc.c  */
 #line 1875 "go.y"
     {
 		(yyval.node) = N;
@@ -4496,6 +4992,8 @@ yyreduce:
     break;
 
   case 295:
+
+/* Line 1806 of yacc.c  */
 #line 1881 "go.y"
     {
 		(yyval.list) = nil;
@@ -4503,6 +5001,8 @@ yyreduce:
     break;
 
   case 297:
+
+/* Line 1806 of yacc.c  */
 #line 1887 "go.y"
     {
 		(yyval.list) = nil;
@@ -4510,6 +5010,8 @@ yyreduce:
     break;
 
   case 299:
+
+/* Line 1806 of yacc.c  */
 #line 1893 "go.y"
     {
 		(yyval.list) = nil;
@@ -4517,6 +5019,8 @@ yyreduce:
     break;
 
   case 301:
+
+/* Line 1806 of yacc.c  */
 #line 1899 "go.y"
     {
 		(yyval.val).ctype = CTxxx;
@@ -4524,6 +5028,8 @@ yyreduce:
     break;
 
   case 303:
+
+/* Line 1806 of yacc.c  */
 #line 1909 "go.y"
     {
 		importimport((yyvsp[(2) - (4)].sym), (yyvsp[(3) - (4)].val).u.sval);
@@ -4531,6 +5037,8 @@ yyreduce:
     break;
 
   case 304:
+
+/* Line 1806 of yacc.c  */
 #line 1913 "go.y"
     {
 		importvar((yyvsp[(2) - (4)].sym), (yyvsp[(3) - (4)].type));
@@ -4538,6 +5046,8 @@ yyreduce:
     break;
 
   case 305:
+
+/* Line 1806 of yacc.c  */
 #line 1917 "go.y"
     {
 		importconst((yyvsp[(2) - (5)].sym), types[TIDEAL], (yyvsp[(4) - (5)].node));
@@ -4545,6 +5055,8 @@ yyreduce:
     break;
 
   case 306:
+
+/* Line 1806 of yacc.c  */
 #line 1921 "go.y"
     {
 		importconst((yyvsp[(2) - (6)].sym), (yyvsp[(3) - (6)].type), (yyvsp[(5) - (6)].node));
@@ -4552,6 +5064,8 @@ yyreduce:
     break;
 
   case 307:
+
+/* Line 1806 of yacc.c  */
 #line 1925 "go.y"
     {
 		importtype((yyvsp[(2) - (4)].type), (yyvsp[(3) - (4)].type));
@@ -4559,6 +5073,8 @@ yyreduce:
     break;
 
   case 308:
+
+/* Line 1806 of yacc.c  */
 #line 1929 "go.y"
     {
 		if((yyvsp[(2) - (4)].node) == N) {
@@ -4580,6 +5096,8 @@ yyreduce:
     break;
 
   case 309:
+
+/* Line 1806 of yacc.c  */
 #line 1949 "go.y"
     {
 		(yyval.sym) = (yyvsp[(1) - (1)].sym);
@@ -4588,6 +5106,8 @@ yyreduce:
     break;
 
   case 310:
+
+/* Line 1806 of yacc.c  */
 #line 1956 "go.y"
     {
 		(yyval.type) = pkgtype((yyvsp[(1) - (1)].sym));
@@ -4596,6 +5116,8 @@ yyreduce:
     break;
 
   case 316:
+
+/* Line 1806 of yacc.c  */
 #line 1976 "go.y"
     {
 		(yyval.type) = pkgtype((yyvsp[(1) - (1)].sym));
@@ -4603,6 +5125,8 @@ yyreduce:
     break;
 
   case 317:
+
+/* Line 1806 of yacc.c  */
 #line 1980 "go.y"
     {
 		// predefined name like uint8
@@ -4616,6 +5140,8 @@ yyreduce:
     break;
 
   case 318:
+
+/* Line 1806 of yacc.c  */
 #line 1990 "go.y"
     {
 		(yyval.type) = aindex(N, (yyvsp[(3) - (3)].type));
@@ -4623,6 +5149,8 @@ yyreduce:
     break;
 
   case 319:
+
+/* Line 1806 of yacc.c  */
 #line 1994 "go.y"
     {
 		(yyval.type) = aindex(nodlit((yyvsp[(2) - (4)].val)), (yyvsp[(4) - (4)].type));
@@ -4630,6 +5158,8 @@ yyreduce:
     break;
 
   case 320:
+
+/* Line 1806 of yacc.c  */
 #line 1998 "go.y"
     {
 		(yyval.type) = maptype((yyvsp[(3) - (5)].type), (yyvsp[(5) - (5)].type));
@@ -4637,6 +5167,8 @@ yyreduce:
     break;
 
   case 321:
+
+/* Line 1806 of yacc.c  */
 #line 2002 "go.y"
     {
 		(yyval.type) = tostruct((yyvsp[(3) - (4)].list));
@@ -4644,6 +5176,8 @@ yyreduce:
     break;
 
   case 322:
+
+/* Line 1806 of yacc.c  */
 #line 2006 "go.y"
     {
 		(yyval.type) = tointerface((yyvsp[(3) - (4)].list));
@@ -4651,6 +5185,8 @@ yyreduce:
     break;
 
   case 323:
+
+/* Line 1806 of yacc.c  */
 #line 2010 "go.y"
     {
 		(yyval.type) = ptrto((yyvsp[(2) - (2)].type));
@@ -4658,6 +5194,8 @@ yyreduce:
     break;
 
   case 324:
+
+/* Line 1806 of yacc.c  */
 #line 2014 "go.y"
     {
 		(yyval.type) = typ(TCHAN);
@@ -4667,6 +5205,8 @@ yyreduce:
     break;
 
   case 325:
+
+/* Line 1806 of yacc.c  */
 #line 2020 "go.y"
     {
 		(yyval.type) = typ(TCHAN);
@@ -4676,6 +5216,8 @@ yyreduce:
     break;
 
   case 326:
+
+/* Line 1806 of yacc.c  */
 #line 2026 "go.y"
     {
 		(yyval.type) = typ(TCHAN);
@@ -4685,6 +5227,8 @@ yyreduce:
     break;
 
   case 327:
+
+/* Line 1806 of yacc.c  */
 #line 2034 "go.y"
     {
 		(yyval.type) = typ(TCHAN);
@@ -4694,6 +5238,8 @@ yyreduce:
     break;
 
   case 328:
+
+/* Line 1806 of yacc.c  */
 #line 2042 "go.y"
     {
 		(yyval.type) = functype(nil, (yyvsp[(3) - (5)].list), (yyvsp[(5) - (5)].list));
@@ -4701,6 +5247,8 @@ yyreduce:
     break;
 
   case 329:
+
+/* Line 1806 of yacc.c  */
 #line 2048 "go.y"
     {
 		(yyval.node) = nod(ODCLFIELD, N, typenod((yyvsp[(2) - (3)].type)));
@@ -4711,6 +5259,8 @@ yyreduce:
     break;
 
   case 330:
+
+/* Line 1806 of yacc.c  */
 #line 2055 "go.y"
     {
 		Type *t;
@@ -4728,6 +5278,8 @@ yyreduce:
     break;
 
   case 331:
+
+/* Line 1806 of yacc.c  */
 #line 2071 "go.y"
     {
 		Sym *s;
@@ -4747,6 +5299,8 @@ yyreduce:
     break;
 
   case 332:
+
+/* Line 1806 of yacc.c  */
 #line 2089 "go.y"
     {
 		(yyval.node) = nod(ODCLFIELD, newname((yyvsp[(1) - (5)].sym)), typenod(functype(fakethis(), (yyvsp[(3) - (5)].list), (yyvsp[(5) - (5)].list))));
@@ -4754,6 +5308,8 @@ yyreduce:
     break;
 
   case 333:
+
+/* Line 1806 of yacc.c  */
 #line 2093 "go.y"
     {
 		(yyval.node) = nod(ODCLFIELD, N, typenod((yyvsp[(1) - (1)].type)));
@@ -4761,6 +5317,8 @@ yyreduce:
     break;
 
   case 334:
+
+/* Line 1806 of yacc.c  */
 #line 2098 "go.y"
     {
 		(yyval.list) = nil;
@@ -4768,6 +5326,8 @@ yyreduce:
     break;
 
   case 336:
+
+/* Line 1806 of yacc.c  */
 #line 2105 "go.y"
     {
 		(yyval.list) = (yyvsp[(2) - (3)].list);
@@ -4775,6 +5335,8 @@ yyreduce:
     break;
 
   case 337:
+
+/* Line 1806 of yacc.c  */
 #line 2109 "go.y"
     {
 		(yyval.list) = list1(nod(ODCLFIELD, N, typenod((yyvsp[(1) - (1)].type))));
@@ -4782,6 +5344,8 @@ yyreduce:
     break;
 
   case 338:
+
+/* Line 1806 of yacc.c  */
 #line 2119 "go.y"
     {
 		(yyval.node) = nodlit((yyvsp[(1) - (1)].val));
@@ -4789,6 +5353,8 @@ yyreduce:
     break;
 
   case 339:
+
+/* Line 1806 of yacc.c  */
 #line 2123 "go.y"
     {
 		(yyval.node) = nodlit((yyvsp[(2) - (2)].val));
@@ -4807,6 +5373,8 @@ yyreduce:
     break;
 
   case 340:
+
+/* Line 1806 of yacc.c  */
 #line 2138 "go.y"
     {
 		(yyval.node) = oldname(pkglookup((yyvsp[(1) - (1)].sym)->name, builtinpkg));
@@ -4816,6 +5384,8 @@ yyreduce:
     break;
 
   case 342:
+
+/* Line 1806 of yacc.c  */
 #line 2147 "go.y"
     {
 		if((yyvsp[(2) - (5)].node)->val.ctype == CTRUNE && (yyvsp[(4) - (5)].node)->val.ctype == CTINT) {
@@ -4830,6 +5400,8 @@ yyreduce:
     break;
 
   case 345:
+
+/* Line 1806 of yacc.c  */
 #line 2163 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4837,6 +5409,8 @@ yyreduce:
     break;
 
   case 346:
+
+/* Line 1806 of yacc.c  */
 #line 2167 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4844,6 +5418,8 @@ yyreduce:
     break;
 
   case 347:
+
+/* Line 1806 of yacc.c  */
 #line 2173 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4851,6 +5427,8 @@ yyreduce:
     break;
 
   case 348:
+
+/* Line 1806 of yacc.c  */
 #line 2177 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4858,6 +5436,8 @@ yyreduce:
     break;
 
   case 349:
+
+/* Line 1806 of yacc.c  */
 #line 2183 "go.y"
     {
 		(yyval.list) = list1((yyvsp[(1) - (1)].node));
@@ -4865,6 +5445,8 @@ yyreduce:
     break;
 
   case 350:
+
+/* Line 1806 of yacc.c  */
 #line 2187 "go.y"
     {
 		(yyval.list) = list((yyvsp[(1) - (3)].list), (yyvsp[(3) - (3)].node));
@@ -4872,10 +5454,22 @@ yyreduce:
     break;
 
 
-/* Line 1267 of yacc.c.  */
-#line 4878 "y.tab.c"
+
+/* Line 1806 of yacc.c  */
+#line 5461 "y.tab.c"
       default: break;
     }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
   YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
   YYPOPSTACK (yylen);
@@ -4884,7 +5478,6 @@ yyreduce:
 
   *++yyvsp = yyval;
 
-
   /* Now `shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
      number reduced by.  */
@@ -4904,6 +5497,10 @@ yyreduce:
 | yyerrlab -- here on detecting error |
 `------------------------------------*/
 yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
   /* If not already recovering from an error, report this error.  */
   if (!yyerrstatus)
     {
@@ -4911,37 +5508,36 @@ yyerrlab:
 #if ! YYERROR_VERBOSE
       yyerror (YY_("syntax error"));
 #else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
       {
-	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
-	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
-	  {
-	    YYSIZE_T yyalloc = 2 * yysize;
-	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
-	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
-	    if (yymsg != yymsgbuf)
-	      YYSTACK_FREE (yymsg);
-	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
-	    if (yymsg)
-	      yymsg_alloc = yyalloc;
-	    else
-	      {
-		yymsg = yymsgbuf;
-		yymsg_alloc = sizeof yymsgbuf;
-	      }
-	  }
-
-	if (0 < yysize && yysize <= yymsg_alloc)
-	  {
-	    (void) yysyntax_error (yymsg, yystate, yychar);
-	    yyerror (yymsg);
-	  }
-	else
-	  {
-	    yyerror (YY_("syntax error"));
-	    if (yysize != 0)
-	      goto yyexhaustedlab;
-	  }
+        char *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
       }
+# undef YYSYNTAX_ERROR
 #endif
     }
 
@@ -4949,7 +5545,7 @@ yyerrlab:
 
   if (yyerrstatus == 3)
     {
-      /* If just tried and failed to reuse look-ahead token after an
+      /* If just tried and failed to reuse lookahead token after an
 	 error, discard it.  */
 
       if (yychar <= YYEOF)
@@ -4966,7 +5562,7 @@ yyerrlab:
 	}
     }
 
-  /* Else will try to reuse look-ahead token after shifting the error
+  /* Else will try to reuse lookahead token after shifting the error
      token.  */
   goto yyerrlab1;
 
@@ -5000,7 +5596,7 @@ yyerrlab1:
   for (;;)
     {
       yyn = yypact[yystate];
-      if (yyn != YYPACT_NINF)
+      if (!yypact_value_is_default (yyn))
 	{
 	  yyn += YYTERROR;
 	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
@@ -5023,9 +5619,6 @@ yyerrlab1:
       YY_STACK_PRINT (yyss, yyssp);
     }
 
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
   *++yyvsp = yylval;
 
 
@@ -5050,7 +5643,7 @@ yyabortlab:
   yyresult = 1;
   goto yyreturn;
 
-#ifndef yyoverflow
+#if !defined(yyoverflow) || YYERROR_VERBOSE
 /*-------------------------------------------------.
 | yyexhaustedlab -- memory exhaustion comes here.  |
 `-------------------------------------------------*/
@@ -5061,9 +5654,14 @@ yyexhaustedlab:
 #endif
 
 yyreturn:
-  if (yychar != YYEOF && yychar != YYEMPTY)
-     yydestruct ("Cleanup: discarding lookahead",
-		 yytoken, &yylval);
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
+    }
   /* Do not reclaim the symbols of the rule which action triggered
      this YYABORT or YYACCEPT.  */
   YYPOPSTACK (yylen);
@@ -5087,6 +5685,8 @@ yyreturn:
 }
 
 
+
+/* Line 2067 of yacc.c  */
 #line 2191 "go.y"
 
 
diff --git a/src/cmd/gc/y.tab.h b/src/cmd/gc/y.tab.h
index b8e9d41b66..05259b1d49 100644
--- a/src/cmd/gc/y.tab.h
+++ b/src/cmd/gc/y.tab.h
@@ -1,24 +1,21 @@
-/* A Bison parser, made by GNU Bison 2.3.  */
+/* A Bison parser, made by GNU Bison 2.5.  */
 
-/* Skeleton interface for Bison's Yacc-like parsers in C
-
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
-   Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
+/* Bison interface for Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-
+   
    You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -29,10 +26,11 @@
    special exception, which will cause the skeleton and the resulting
    Bison output files to be licensed under the GNU General Public
    License without this special exception.
-
+   
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
+
 /* Tokens.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
@@ -146,22 +144,28 @@
 
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-#line 30 "go.y"
 {
+
+/* Line 2068 of yacc.c  */
+#line 30 "go.y"
+
 	Node*		node;
 	NodeList*		list;
 	Type*		type;
 	Sym*		sym;
 	struct	Val	val;
 	int		i;
-}
-/* Line 1529 of yacc.c.  */
-#line 160 "y.tab.h"
-	YYSTYPE;
+
+
+
+/* Line 2068 of yacc.c  */
+#line 163 "y.tab.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
 #endif
 
 extern YYSTYPE yylval;
 
+
