commit 28edaf4584c4cbfb0ed03692108ebc90db039d17
Author: Lynn Boger <laboger@linux.vnet.ibm.com>
Date:   Thu Mar 1 11:40:36 2018 -0500

    cmd/compile,test: combine byte loads and stores on ppc64le
    
    CL 74410 added rules to combine consecutive byte loads and
    stores when the byte order was little endian for ppc64le. This
    is the corresponding change for bytes that are in big endian order.
    These rules are all intended for a little endian target arch.
    
    This adds new testcases in test/codegen/memcombine.go
    
    Fixes #22496
    Updates #24242
    
    Benchmark improvement for encoding/binary:
    name                      old time/op    new time/op    delta
    ReadSlice1000Int32s-16      11.0µs ± 0%     9.0µs ± 0%  -17.47%  (p=0.029 n=4+4)
    ReadStruct-16               2.47µs ± 1%    2.48µs ± 0%   +0.67%  (p=0.114 n=4+4)
    ReadInts-16                  642ns ± 1%     630ns ± 1%   -2.02%  (p=0.029 n=4+4)
    WriteInts-16                 654ns ± 0%     653ns ± 1%   -0.08%  (p=0.629 n=4+4)
    WriteSlice1000Int32s-16     8.75µs ± 0%    8.20µs ± 0%   -6.19%  (p=0.029 n=4+4)
    PutUint16-16                1.16ns ± 0%    0.93ns ± 0%  -19.83%  (p=0.029 n=4+4)
    PutUint32-16                1.16ns ± 0%    0.93ns ± 0%  -19.83%  (p=0.029 n=4+4)
    PutUint64-16                1.85ns ± 0%    0.93ns ± 0%  -49.73%  (p=0.029 n=4+4)
    LittleEndianPutUint16-16    1.03ns ± 0%    0.93ns ± 0%   -9.71%  (p=0.029 n=4+4)
    LittleEndianPutUint32-16    0.93ns ± 0%    0.93ns ± 0%     ~     (all equal)
    LittleEndianPutUint64-16    0.93ns ± 0%    0.93ns ± 0%     ~     (all equal)
    PutUvarint32-16             43.0ns ± 0%    43.1ns ± 0%   +0.12%  (p=0.429 n=4+4)
    PutUvarint64-16              174ns ± 0%     175ns ± 0%   +0.29%  (p=0.429 n=4+4)
    
    Updates made to functions in gcm.go to enable their matching. An existing
    testcase prevents these functions from being replaced by those in encoding/binary
    due to import dependencies.
    
    Change-Id: Idb3bd1e6e7b12d86cd828fb29cb095848a3e485a
    Reviewed-on: https://go-review.googlesource.com/98136
    Run-TryBot: Lynn Boger <laboger@linux.vnet.ibm.com>
    TryBot-Result: Gobot Gobot <gobot@golang.org>
    Reviewed-by: Keith Randall <khr@golang.org>
---
 src/cmd/compile/internal/ppc64/ssa.go        |    62 +-
 src/cmd/compile/internal/ssa/gen/PPC64.rules |   232 +-
 src/cmd/compile/internal/ssa/gen/PPC64Ops.go |    77 +-
 src/cmd/compile/internal/ssa/opGen.go        |    98 +-
 src/cmd/compile/internal/ssa/regalloc.go     |     2 +-
 src/cmd/compile/internal/ssa/rewritePPC64.go | 12026 +++++++++++++++++++++++--
 src/cmd/internal/obj/ppc64/asm9.go           |     2 +
 src/crypto/cipher/gcm.go                     |     2 +
 test/codegen/memcombine.go                   |    16 +-
 9 files changed, 11707 insertions(+), 810 deletions(-)

diff --git a/src/cmd/compile/internal/ppc64/ssa.go b/src/cmd/compile/internal/ppc64/ssa.go
index 9f6febd903..fd226a2e98 100644
--- a/src/cmd/compile/internal/ppc64/ssa.go
+++ b/src/cmd/compile/internal/ppc64/ssa.go
@@ -619,35 +619,31 @@ func ssaGenValue(s *gc.SSAGenState, v *ssa.Value) {
 		p.To.Reg = ppc64.REGTMP // discard result
 
 	case ssa.OpPPC64MOVDaddr:
-		p := s.Prog(ppc64.AMOVD)
-		p.From.Type = obj.TYPE_ADDR
-		p.From.Reg = v.Args[0].Reg()
-		p.To.Type = obj.TYPE_REG
-		p.To.Reg = v.Reg()
-
-		var wantreg string
-		// Suspect comment, copied from ARM code
-		// MOVD $sym+off(base), R
-		// the assembler expands it as the following:
-		// - base is SP: add constant offset to SP
-		//               when constant is large, tmp register (R11) may be used
-		// - base is SB: load external address from constant pool (use relocation)
 		switch v.Aux.(type) {
 		default:
-			v.Fatalf("aux is of unknown type %T", v.Aux)
-		case *obj.LSym:
-			wantreg = "SB"
-			gc.AddAux(&p.From, v)
-		case *gc.Node:
-			wantreg = "SP"
-			gc.AddAux(&p.From, v)
+			v.Fatalf("aux in MOVDaddr is of unknown type %T", v.Aux)
 		case nil:
-			// No sym, just MOVD $off(SP), R
-			wantreg = "SP"
-			p.From.Offset = v.AuxInt
-		}
-		if reg := v.Args[0].RegName(); reg != wantreg {
-			v.Fatalf("bad reg %s for symbol type %T, want %s", reg, v.Aux, wantreg)
+			// If aux offset and aux int are both 0, and the same
+			// input and output regs are used, no instruction
+			// needs to be generated, since it would just be
+			// addi rx, rx, 0.
+			if v.AuxInt != 0 || v.Args[0].Reg() != v.Reg() {
+				p := s.Prog(ppc64.AMOVD)
+				p.From.Type = obj.TYPE_ADDR
+				p.From.Reg = v.Args[0].Reg()
+				p.From.Offset = v.AuxInt
+				p.To.Type = obj.TYPE_REG
+				p.To.Reg = v.Reg()
+			}
+
+		case *obj.LSym, *gc.Node:
+			p := s.Prog(ppc64.AMOVD)
+			p.From.Type = obj.TYPE_ADDR
+			p.From.Reg = v.Args[0].Reg()
+			p.To.Type = obj.TYPE_REG
+			p.To.Reg = v.Reg()
+			gc.AddAux(&p.From, v)
+
 		}
 
 	case ssa.OpPPC64MOVDconst:
@@ -729,6 +725,20 @@ func ssaGenValue(s *gc.SSAGenState, v *ssa.Value) {
 		p.To.Type = obj.TYPE_REG
 		p.To.Reg = v.Reg()
 
+	case ssa.OpPPC64MOVDBRload, ssa.OpPPC64MOVWBRload, ssa.OpPPC64MOVHBRload:
+		p := s.Prog(v.Op.Asm())
+		p.From.Type = obj.TYPE_MEM
+		p.From.Reg = v.Args[0].Reg()
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = v.Reg()
+
+	case ssa.OpPPC64MOVDBRstore, ssa.OpPPC64MOVWBRstore, ssa.OpPPC64MOVHBRstore:
+		p := s.Prog(v.Op.Asm())
+		p.To.Type = obj.TYPE_MEM
+		p.To.Reg = v.Args[0].Reg()
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Args[1].Reg()
+
 	case ssa.OpPPC64FMOVDload, ssa.OpPPC64FMOVSload:
 		p := s.Prog(v.Op.Asm())
 		p.From.Type = obj.TYPE_MEM
diff --git a/src/cmd/compile/internal/ssa/gen/PPC64.rules b/src/cmd/compile/internal/ssa/gen/PPC64.rules
index c97bbe2963..a668b61093 100644
--- a/src/cmd/compile/internal/ssa/gen/PPC64.rules
+++ b/src/cmd/compile/internal/ssa/gen/PPC64.rules
@@ -678,6 +678,7 @@
 
 (MOVHZreg y:(MOVHZreg _)) -> y // repeat
 (MOVHZreg y:(MOVBZreg _)) -> y // wide of narrow
+(MOVHZreg y:(MOVHBRload _ _)) -> y
 
 (MOVHreg y:(MOVHreg _)) -> y // repeat
 (MOVHreg y:(MOVBreg _)) -> y // wide of narrow
@@ -690,6 +691,8 @@
 (MOVWZreg y:(MOVWZreg _)) -> y // repeat
 (MOVWZreg y:(MOVHZreg _)) -> y // wide of narrow
 (MOVWZreg y:(MOVBZreg _)) -> y // wide of narrow
+(MOVWZreg y:(MOVHBRload _ _)) -> y
+(MOVWZreg y:(MOVWBRload _ _)) -> y
 
 (MOVWreg y:(MOVWreg _)) -> y // repeat
 (MOVWreg y:(MOVHreg _)) -> y // wide of narrow
@@ -870,6 +873,8 @@
 (MOVWstore [off] {sym} ptr (MOV(W|WZ)reg x) mem) -> (MOVWstore [off] {sym} ptr x mem)
 (MOVBstore [off] {sym} ptr (SRWconst (MOV(H|HZ)reg x) [c]) mem) && c <= 8 -> (MOVBstore [off] {sym} ptr (SRWconst <typ.UInt32> x [c]) mem)
 (MOVBstore [off] {sym} ptr (SRWconst (MOV(W|WZ)reg x) [c]) mem) && c <= 24 -> (MOVBstore [off] {sym} ptr (SRWconst <typ.UInt32> x [c]) mem)
+(MOVHBRstore {sym} ptr (MOV(H|HZ|W|WZ)reg x) mem) -> (MOVHBRstore {sym} ptr x mem)
+(MOVWBRstore {sym} ptr (MOV(W|WZ)reg x) mem) -> (MOVWBRstore {sym} ptr x mem)
 
 // Lose W-widening ops fed to compare-W
 (CMPW x (MOVWreg y)) -> (CMPW x y)
@@ -902,13 +907,14 @@
 (FSUBS (FMULS x y) z) -> (FMSUBS x y z)
 
 
-// The following rules are intended to match statements as are found in encoding/binary
-// functions UintXX (load) and PutUintXX (store), combining multi-byte loads and stores
-// into wider loads and stores.
-// Initial implementation handles only little endian loads and stores on little endian
-// targets.
-// TODO implement big endian loads and stores for little endian machines (using byte reverse
-// loads and stores).
+// The following statements are found in encoding/binary functions UintXX (load) and PutUintXX (store)
+// and convert the statements in these functions from multiple single byte loads or stores to
+// the single largest possible load or store.
+// Some are marked big or little endian based on the order in which the bytes are loaded or stored,
+// not on the ordering of the machine. These are intended for little endian machines.
+// To implement for big endian machines, most rules would have to be duplicated but the
+// resulting rule would be reversed, i. e., MOVHZload on little endian would be MOVHBRload on big endian
+// and vice versa.
 // b[0] | b[1]<<8 -> load 16-bit Little endian
 (OR <t> x0:(MOVBZload [i0] {s} p mem)
 	o1:(SL(W|D)const x1:(MOVBZload [i1] {s} p mem) [8]))
@@ -920,9 +926,39 @@
 	&& clobber(x0) && clobber(x1) && clobber(o1)
 	 -> @mergePoint(b,x0,x1) (MOVHZload <t> {s} [i0] p mem)
 
+// b[0]<<8 | b[1] -> load 16-bit Big endian on Little endian arch.
+// Use byte-reverse indexed load for 2 bytes.
+(OR <t> x0:(MOVBZload [i1] {s} p mem)
+	o1:(SL(W|D)const x1:(MOVBZload [i0] {s} p mem) [8]))
+	&& !config.BigEndian
+	&& i1 == i0+1
+	&& x0.Uses ==1 && x1.Uses == 1
+	&& o1.Uses == 1
+	&& mergePoint(b, x0, x1) != nil
+	&& clobber(x0) && clobber(x1) && clobber(o1)
+	  -> @mergePoint(b,x0,x1) (MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+
+// b[0]<<n+8 | b[1]<<n -> load 16-bit Big endian (where n%8== 0)
+// Use byte-reverse indexed load for 2 bytes,
+// then shift left to the correct position. Used to match subrules
+// from longer rules.
+(OR <t> s0:(SL(W|D)const x0:(MOVBZload [i1] {s} p mem) [n1])
+	s1:(SL(W|D)const x1:(MOVBZload [i0] {s} p mem) [n2]))
+	&& !config.BigEndian
+	&& i1 == i0+1
+	&& n1%8 == 0
+	&& n2 == n1+8
+	&& x0.Uses == 1 && x1.Uses == 1
+	&& s0.Uses == 1 && s1.Uses == 1
+	&& mergePoint(b, x0, x1) != nil
+	&& clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1)
+	  -> @mergePoint(b,x0,x1) (SLDconst <t> (MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [n1])
+
 // b[0] | b[1]<<8 | b[2]<<16 | b[3]<<24 -> load 32-bit Little endian
+// Use byte-reverse indexed load for 4 bytes.
 (OR <t> s1:(SL(W|D)const x2:(MOVBZload [i3] {s} p mem) [24])
-	o0:(OR <t> s0:(SL(W|D)const x1:(MOVBZload [i2] {s} p mem) [16]) x0:(MOVHZload [i0] {s} p mem)))
+	o0:(OR <t> s0:(SL(W|D)const x1:(MOVBZload [i2] {s} p mem) [16])
+	x0:(MOVHZload [i0] {s} p mem)))
 	&& !config.BigEndian
 	&& i2 == i0+2
 	&& i3 == i0+3
@@ -935,9 +971,81 @@
 	&& clobber(o0)
 	 -> @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
 
+// b[0]<<24 | b[1]<<16 | b[2]<<8 | b[3] -> load 32-bit Big endian order on Little endian arch
+// Use byte-reverse indexed load for 4 bytes with computed address.
+// Could be used to match subrules of a longer rule.
+(OR <t> s1:(SL(W|D)const x2:(MOVBZload [i0] {s} p mem) [24])
+	o0:(OR <t> s0:(SL(W|D)const x1:(MOVBZload [i1] {s} p mem) [16])
+	x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i2] {s} p) mem)))
+	&& !config.BigEndian
+	&& i1 == i0+1
+	&& i2 == i0+2
+	&& x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1
+	&& o0.Uses == 1
+	&& s0.Uses == 1 && s1.Uses == 1
+	&& mergePoint(b, x0, x1, x2) != nil
+	&& clobber(x0) && clobber(x1) && clobber(x2)
+	&& clobber(s0) && clobber(s1)
+	&& clobber(o0)
+	  -> @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+
+// b[3] | b[2]<<8 | b[1]<<16 | b[0]<<24 -> load 32-bit Big endian order on Little endian arch
+// Use byte-reverse indexed load for 4 bytes with computed address.
+// Could be used to match subrules of a longer rule.
+(OR <t> x0:(MOVBZload [i3] {s} p mem)
+	o0:(OR <t> s0:(SL(W|D)const x1:(MOVBZload [i2] {s} p mem) [8])
+	s1:(SL(W|D)const x2:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [16])))
+	&& !config.BigEndian
+	&& i2 == i0+2
+	&& i3 == i0+3
+	&& x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1
+	&& o0.Uses == 1
+	&& s0.Uses == 1 && s1.Uses == 1
+	&& mergePoint(b, x0, x1, x2) != nil
+	&& clobber(x0) && clobber(x1) && clobber(x2)
+	&& clobber(s0) && clobber(s1)
+	&& clobber(o0)
+	  -> @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+
+// b[0]<<56 | b[1]<<48 | b[2]<<40 | b[3]<<32 -> load 32-bit Big endian order on Little endian arch
+// Use byte-reverse indexed load to for 4 bytes with computed address.
+// Used to match longer rules.
+(OR <t> s2:(SLDconst x2:(MOVBZload [i3] {s} p mem) [32])
+	o0:(OR <t> s1:(SLDconst x1:(MOVBZload [i2] {s} p mem) [40])
+	s0:(SLDconst x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [48])))
+	&& !config.BigEndian
+	&& i2 == i0+2
+	&& i3 == i0+3
+	&& x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1
+	&& o0.Uses == 1
+	&& s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1
+	&& mergePoint(b, x0, x1, x2) != nil
+	&& clobber(x0) && clobber(x1) && clobber(x2)
+	&& clobber(s0) && clobber(s1) && clobber(s2)
+	&& clobber(o0)
+	  -> @mergePoint(b,x0,x1,x2) (SLDconst <t> (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])
+
+// b[3]<<32 | b[2]<<40 | b[1]<<48 | b[0]<<56 -> load 32-bit Big endian order on Little endian arch
+// Use byte-reverse indexed load for 4 bytes with constant address.
+// Used to match longer rules.
+(OR <t> s2:(SLDconst x2:(MOVBZload [i0] {s} p mem) [56])
+        o0:(OR <t> s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48])
+        s0:(SLDconst x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i2] {s} p) mem) [32])))
+        && !config.BigEndian
+        && i1 == i0+1
+        && i2 == i0+2
+        && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1
+        && o0.Uses == 1
+        && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1
+        && mergePoint(b, x0, x1, x2) != nil
+        && clobber(x0) && clobber(x1) && clobber(x2)
+        && clobber(s0) && clobber(s1) && clobber(s2)
+        && clobber(o0)
+          -> @mergePoint(b,x0,x1,x2) (SLDconst <t> (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])
+
 // b[0] | b[1]<<8 | b[2]<<16 | b[3]<<24 | b[4] <<32 | b[5]<<40 | b[6]<<48 | b[7]<<56 -> load 64-bit Little endian
-// Note: long rules with commutative ops will result in very large functions in rewritePPC64,
-// so shorter rules which make use of previously defined rules are preferred.
+// Rules with commutative ops and many operands will result in extremely large functions in rewritePPC64,
+// so matching shorter previously defined subrules is important.
 // Offset must be multiple of 4 for MOVD
 (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56])
 	o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])
@@ -959,10 +1067,56 @@
 	&& clobber(o3) && clobber(o4) && clobber(o5)
 	  -> @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
+// b[7] | b[6]<<8 | b[5]<<16 | b[4]<<24 | b[3]<<32 | b[2]<<40 | b[1]<<48 | b[0]<<56 load 64-bit Big endian ordered bytes on Little endian arch
+// Use byte-reverse indexed load of 8 bytes.
+// Rules with commutative ops and many operands can result in extremely large functions in rewritePPC64,
+// so matching shorter previously defined subrules is important.
+(OR <t> s0:(SLDconst x0:(MOVBZload [i0] {s} p mem) [56])
+	o0:(OR <t> s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48])
+	o1:(OR <t> s2:(SLDconst x2:(MOVBZload [i2] {s} p mem) [40])
+	o2:(OR <t> s3:(SLDconst x3:(MOVBZload [i3] {s} p mem) [32])
+	x4:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i4] p) mem)))))
+	&& !config.BigEndian
+	&& i1 == i0+1
+	&& i2 == i0+2
+	&& i3 == i0+3
+	&& i4 == i0+4
+	&& x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1
+	&& o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1
+	&& s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1
+	&& mergePoint(b, x0, x1, x2, x3, x4) != nil
+	&& clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4)
+	&& clobber(o0) && clobber(o1) && clobber(o2)
+	&& clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)
+	  -> @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+
+// b[0]<<56 | b[1]<<48 | b[2]<<40 | b[3]<<32 | b[4]<<24 | b[5]<<16 | b[6]<<8 | b[7] -> load 64-bit Big endian ordered bytes on Little endian arch
+// Use byte-reverse indexed load of 8 bytes.
+// Rules with commutative ops and many operands can result in extremely large functions in rewritePPC64,
+// so matching shorter previously defined subrules is important.
+(OR <t> x7:(MOVBZload [i7] {s} p mem)
+	o5:(OR <t> s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8])
+	o4:(OR <t> s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16])
+	o3:(OR <t> s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24])
+	s0:(SL(W|D)const x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])))))
+	&& !config.BigEndian
+	&& i4 == i0+4
+	&& i5 == i0+5
+	&& i6 == i0+6
+	&& i7 == i0+7
+	&& x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1
+	&& o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1
+	&& s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1
+	&& mergePoint(b, x3, x4, x5, x6, x7) != nil
+	&& clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)
+	&& clobber(o3) && clobber(o4) && clobber(o5)
+	&& clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	-> @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+
 // 2 byte store Little endian as in:
 //      b[0] = byte(v >> 16)
 //      b[1] = byte(v >> 24)
-// Added mainly to use when matching longer rules below
+// Added for use in matching longer rules.
 (MOVBstore [i1] {s} p (SR(W|D)const w [24])
         x0:(MOVBstore [i0] {s} p (SR(W|D)const w [16]) mem))
         && !config.BigEndian
@@ -993,6 +1147,38 @@
 	&& clobber(x0)
 	  -> (MOVWstore [i0] {s} p w mem)
 
+// 4 byte store Big endian as in:
+//     b[0] = byte(v >> 24)
+//     b[1] = byte(v >> 16)
+//     b[2] = byte(v >> 8)
+//     b[3] = byte(v)
+// Use byte-reverse indexed 4 byte store.
+(MOVBstore [i3] {s} p w
+	x0:(MOVBstore [i2] {s} p (SRWconst w [8])
+	x1:(MOVBstore [i1] {s} p (SRWconst w [16])
+	x2:(MOVBstore [i0] {s} p (SRWconst w [24]) mem))))
+	&& !config.BigEndian
+	&& x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1
+	&& i1 == i0+1 && i2 == i0+2 && i3 == i0+3
+	&& clobber(x0) && clobber(x1) && clobber(x2)
+	  -> (MOVWBRstore (MOVDaddr <typ.Uintptr> [i0] {s} p) w mem)
+
+// The 2 byte store appears after the 4 byte store so that the
+// match for the 2 byte store is not done first.
+// If the 4 byte store is based on the 2 byte store then there are 
+// variations on the MOVDaddr subrule that would require additional
+// rules to be written.
+
+// 2 byte store Big endian as in:
+//      b[0] = byte(v >> 8)
+//      b[1] = byte(v)
+(MOVBstore [i1] {s} p w x0:(MOVBstore [i0] {s} p (SRWconst w [8]) mem))
+	&& !config.BigEndian
+	&& x0.Uses == 1
+	&& i1 == i0+1
+	&& clobber(x0)
+	  -> (MOVHBRstore (MOVDaddr <typ.Uintptr> [i0] {s} p) w mem)
+
 // 8 byte store Little endian as in:
 //	b[0] = byte(v)
 //	b[1] = byte(v >> 8)
@@ -1015,3 +1201,27 @@
 	&& i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7
 	&& clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3)
 	  -> (MOVDstore [i0] {s} p w mem)
+
+// 8 byte store Big endian as in:
+//      b[0] = byte(v >> 56)
+//      b[1] = byte(v >> 48)
+//      b[2] = byte(v >> 40)
+//      b[3] = byte(v >> 32)
+//      b[4] = byte(v >> 24)
+//      b[5] = byte(v >> 16)
+//      b[6] = byte(v >> 8)
+//      b[7] = byte(v)
+// Use byte-reverse indexed 8 byte store.
+(MOVBstore [i7] {s} p w
+        x0:(MOVBstore [i6] {s} p (SRDconst w [8])
+        x1:(MOVBstore [i5] {s} p (SRDconst w [16])
+        x2:(MOVBstore [i4] {s} p (SRDconst w [24])
+        x3:(MOVBstore [i3] {s} p (SRDconst w [32])
+        x4:(MOVBstore [i2] {s} p (SRDconst w [40])
+        x5:(MOVBstore [i1] {s} p (SRDconst w [48])
+        x6:(MOVBstore [i0] {s} p (SRDconst w [56]) mem))))))))
+        && !config.BigEndian
+        && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1
+        && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7
+        && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6)
+          -> (MOVDBRstore (MOVDaddr <typ.Uintptr> [i0] {s} p) w mem)
diff --git a/src/cmd/compile/internal/ssa/gen/PPC64Ops.go b/src/cmd/compile/internal/ssa/gen/PPC64Ops.go
index fde88056d3..ce5d552375 100644
--- a/src/cmd/compile/internal/ssa/gen/PPC64Ops.go
+++ b/src/cmd/compile/internal/ssa/gen/PPC64Ops.go
@@ -259,34 +259,55 @@ func init() {
 		{name: "ANDconst", argLength: 1, reg: regInfo{inputs: []regMask{gp | sp | sb}, outputs: []regMask{gp}}, asm: "ANDCC", aux: "Int64", clobberFlags: true}, // arg0&aux // and-immediate sets CC on PPC, always.
 		{name: "ANDCCconst", argLength: 1, reg: regInfo{inputs: []regMask{gp | sp | sb}}, asm: "ANDCC", aux: "Int64", typ: "Flags"},                             // arg0&aux == 0 // and-immediate sets CC on PPC, always.
 
-		{name: "MOVBreg", argLength: 1, reg: gp11, asm: "MOVB", typ: "Int64"},                                                               // sign extend int8 to int64
-		{name: "MOVBZreg", argLength: 1, reg: gp11, asm: "MOVBZ", typ: "Int64"},                                                             // zero extend uint8 to uint64
-		{name: "MOVHreg", argLength: 1, reg: gp11, asm: "MOVH", typ: "Int64"},                                                               // sign extend int16 to int64
-		{name: "MOVHZreg", argLength: 1, reg: gp11, asm: "MOVHZ", typ: "Int64"},                                                             // zero extend uint16 to uint64
-		{name: "MOVWreg", argLength: 1, reg: gp11, asm: "MOVW", typ: "Int64"},                                                               // sign extend int32 to int64
-		{name: "MOVWZreg", argLength: 1, reg: gp11, asm: "MOVWZ", typ: "Int64"},                                                             // zero extend uint32 to uint64
-		{name: "MOVBZload", argLength: 2, reg: gpload, asm: "MOVBZ", aux: "SymOff", typ: "UInt8", faultOnNilArg0: true, symEffect: "Read"},  // zero extend uint8 to uint64
-		{name: "MOVHload", argLength: 2, reg: gpload, asm: "MOVH", aux: "SymOff", typ: "Int16", faultOnNilArg0: true, symEffect: "Read"},    // sign extend int16 to int64
-		{name: "MOVHZload", argLength: 2, reg: gpload, asm: "MOVHZ", aux: "SymOff", typ: "UInt16", faultOnNilArg0: true, symEffect: "Read"}, // zero extend uint16 to uint64
-		{name: "MOVWload", argLength: 2, reg: gpload, asm: "MOVW", aux: "SymOff", typ: "Int32", faultOnNilArg0: true, symEffect: "Read"},    // sign extend int32 to int64
-		{name: "MOVWZload", argLength: 2, reg: gpload, asm: "MOVWZ", aux: "SymOff", typ: "UInt32", faultOnNilArg0: true, symEffect: "Read"}, // zero extend uint32 to uint64
-		{name: "MOVDload", argLength: 2, reg: gpload, asm: "MOVD", aux: "SymOff", typ: "Int64", faultOnNilArg0: true, symEffect: "Read"},
-
-		{name: "FMOVDload", argLength: 2, reg: fpload, asm: "FMOVD", aux: "SymOff", typ: "Float64", faultOnNilArg0: true, symEffect: "Read"},
-		{name: "FMOVSload", argLength: 2, reg: fpload, asm: "FMOVS", aux: "SymOff", typ: "Float32", faultOnNilArg0: true, symEffect: "Read"},
-		{name: "MOVBstore", argLength: 3, reg: gpstore, asm: "MOVB", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"},
-		{name: "MOVHstore", argLength: 3, reg: gpstore, asm: "MOVH", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"},
-		{name: "MOVWstore", argLength: 3, reg: gpstore, asm: "MOVW", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"},
-		{name: "MOVDstore", argLength: 3, reg: gpstore, asm: "MOVD", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"},
-		{name: "FMOVDstore", argLength: 3, reg: fpstore, asm: "FMOVD", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"},
-		{name: "FMOVSstore", argLength: 3, reg: fpstore, asm: "FMOVS", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"},
-
-		{name: "MOVBstorezero", argLength: 2, reg: gpstorezero, asm: "MOVB", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store zero byte to arg0+aux.  arg1=mem
-		{name: "MOVHstorezero", argLength: 2, reg: gpstorezero, asm: "MOVH", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store zero 2 bytes to ...
-		{name: "MOVWstorezero", argLength: 2, reg: gpstorezero, asm: "MOVW", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store zero 4 bytes to ...
-		{name: "MOVDstorezero", argLength: 2, reg: gpstorezero, asm: "MOVD", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store zero 8 bytes to ...
-
-		{name: "MOVDaddr", argLength: 1, reg: regInfo{inputs: []regMask{sp | sb}, outputs: []regMask{gp}}, aux: "SymOff", asm: "MOVD", rematerializeable: true, symEffect: "Addr"}, // arg0 + auxInt + aux.(*gc.Sym), arg0=SP/SB
+		{name: "MOVBreg", argLength: 1, reg: gp11, asm: "MOVB", typ: "Int64"},   // sign extend int8 to int64
+		{name: "MOVBZreg", argLength: 1, reg: gp11, asm: "MOVBZ", typ: "Int64"}, // zero extend uint8 to uint64
+		{name: "MOVHreg", argLength: 1, reg: gp11, asm: "MOVH", typ: "Int64"},   // sign extend int16 to int64
+		{name: "MOVHZreg", argLength: 1, reg: gp11, asm: "MOVHZ", typ: "Int64"}, // zero extend uint16 to uint64
+		{name: "MOVWreg", argLength: 1, reg: gp11, asm: "MOVW", typ: "Int64"},   // sign extend int32 to int64
+		{name: "MOVWZreg", argLength: 1, reg: gp11, asm: "MOVWZ", typ: "Int64"}, // zero extend uint32 to uint64
+
+		// Load bytes in the endian order of the arch from arg0+aux+auxint into a 64 bit register.
+		{name: "MOVBZload", argLength: 2, reg: gpload, asm: "MOVBZ", aux: "SymOff", typ: "UInt8", faultOnNilArg0: true, symEffect: "Read"},  // load byte zero extend
+		{name: "MOVHload", argLength: 2, reg: gpload, asm: "MOVH", aux: "SymOff", typ: "Int16", faultOnNilArg0: true, symEffect: "Read"},    // load 2 bytes sign extend
+		{name: "MOVHZload", argLength: 2, reg: gpload, asm: "MOVHZ", aux: "SymOff", typ: "UInt16", faultOnNilArg0: true, symEffect: "Read"}, // load 2 bytes zero extend
+		{name: "MOVWload", argLength: 2, reg: gpload, asm: "MOVW", aux: "SymOff", typ: "Int32", faultOnNilArg0: true, symEffect: "Read"},    // load 4 bytes sign extend
+		{name: "MOVWZload", argLength: 2, reg: gpload, asm: "MOVWZ", aux: "SymOff", typ: "UInt32", faultOnNilArg0: true, symEffect: "Read"}, // load 4 bytes zero extend
+		{name: "MOVDload", argLength: 2, reg: gpload, asm: "MOVD", aux: "SymOff", typ: "Int64", faultOnNilArg0: true, symEffect: "Read"},    // load 8 bytes
+
+		// Load bytes in reverse endian order of the arch from arg0 into a 64 bit register, all zero extend.
+		// The generated instructions are indexed loads with no offset field in the instruction so the aux fields are not used.
+		// In these cases the index register field is set to 0 and the full address is in the base register.
+		{name: "MOVDBRload", argLength: 2, reg: gpload, asm: "MOVDBR", aux: "SymOff", typ: "Int64", faultOnNilArg0: true, symEffect: "Read"}, // load 8 bytes reverse order
+		{name: "MOVWBRload", argLength: 2, reg: gpload, asm: "MOVWBR", aux: "SymOff", typ: "Int32", faultOnNilArg0: true, symEffect: "Read"}, // load 4 bytes zero extend reverse order
+		{name: "MOVHBRload", argLength: 2, reg: gpload, asm: "MOVHBR", aux: "SymOff", typ: "Int16", faultOnNilArg0: true, symEffect: "Read"}, // load 2 bytes zero extend reverse order
+
+		// Store bytes in the reverse endian order of the arch into arg0.
+		// These are indexes stores with no offset field in the instruction so the aux fields are not used.
+		{name: "MOVDBRstore", argLength: 3, reg: gpstore, asm: "MOVDBR", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store 8 bytes reverse order
+		{name: "MOVWBRstore", argLength: 3, reg: gpstore, asm: "MOVWBR", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store 4 bytes reverse order
+		{name: "MOVHBRstore", argLength: 3, reg: gpstore, asm: "MOVHBR", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store 2 bytes reverse order
+
+		// Floating point loads from arg0+aux+auxint
+		{name: "FMOVDload", argLength: 2, reg: fpload, asm: "FMOVD", aux: "SymOff", typ: "Float64", faultOnNilArg0: true, symEffect: "Read"}, // load double float
+		{name: "FMOVSload", argLength: 2, reg: fpload, asm: "FMOVS", aux: "SymOff", typ: "Float32", faultOnNilArg0: true, symEffect: "Read"}, // load single float
+
+		// Store bytes in the endian order of the arch into arg0+aux+auxint
+		{name: "MOVBstore", argLength: 3, reg: gpstore, asm: "MOVB", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store byte
+		{name: "MOVHstore", argLength: 3, reg: gpstore, asm: "MOVH", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store 2 bytes
+		{name: "MOVWstore", argLength: 3, reg: gpstore, asm: "MOVW", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store 4 bytes
+		{name: "MOVDstore", argLength: 3, reg: gpstore, asm: "MOVD", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store 8 bytes
+
+		// Store floating point value into arg0+aux+auxint
+		{name: "FMOVDstore", argLength: 3, reg: fpstore, asm: "FMOVD", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store double flot
+		{name: "FMOVSstore", argLength: 3, reg: fpstore, asm: "FMOVS", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store single float
+
+		// The following ops store 0 into arg0+aux+auxint arg1=mem
+		{name: "MOVBstorezero", argLength: 2, reg: gpstorezero, asm: "MOVB", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store zero 1 byte
+		{name: "MOVHstorezero", argLength: 2, reg: gpstorezero, asm: "MOVH", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store zero 2 bytes
+		{name: "MOVWstorezero", argLength: 2, reg: gpstorezero, asm: "MOVW", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store zero 4 bytes
+		{name: "MOVDstorezero", argLength: 2, reg: gpstorezero, asm: "MOVD", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store zero 8 bytes
+
+		{name: "MOVDaddr", argLength: 1, reg: regInfo{inputs: []regMask{sp | sb | gp}, outputs: []regMask{gp}}, aux: "SymOff", asm: "MOVD", rematerializeable: true, symEffect: "Addr"}, // arg0 + auxInt + aux.(*gc.Sym), arg0=SP/SB/GP
 
 		{name: "MOVDconst", argLength: 0, reg: gp01, aux: "Int64", asm: "MOVD", typ: "Int64", rematerializeable: true}, //
 		{name: "FMOVDconst", argLength: 0, reg: fp01, aux: "Float64", asm: "FMOVD", rematerializeable: true},           //
diff --git a/src/cmd/compile/internal/ssa/opGen.go b/src/cmd/compile/internal/ssa/opGen.go
index 0e7a8fccdd..4ddbec61e7 100644
--- a/src/cmd/compile/internal/ssa/opGen.go
+++ b/src/cmd/compile/internal/ssa/opGen.go
@@ -1586,6 +1586,12 @@ const (
 	OpPPC64MOVWload
 	OpPPC64MOVWZload
 	OpPPC64MOVDload
+	OpPPC64MOVDBRload
+	OpPPC64MOVWBRload
+	OpPPC64MOVHBRload
+	OpPPC64MOVDBRstore
+	OpPPC64MOVWBRstore
+	OpPPC64MOVHBRstore
 	OpPPC64FMOVDload
 	OpPPC64FMOVSload
 	OpPPC64MOVBstore
@@ -20957,6 +20963,96 @@ var opcodeTable = [...]opInfo{
 			},
 		},
 	},
+	{
+		name:           "MOVDBRload",
+		auxType:        auxSymOff,
+		argLen:         2,
+		faultOnNilArg0: true,
+		symEffect:      SymRead,
+		asm:            ppc64.AMOVDBR,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1073733630}, // SP SB R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R14 R15 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29
+			},
+			outputs: []outputInfo{
+				{0, 1073733624}, // R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R14 R15 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29
+			},
+		},
+	},
+	{
+		name:           "MOVWBRload",
+		auxType:        auxSymOff,
+		argLen:         2,
+		faultOnNilArg0: true,
+		symEffect:      SymRead,
+		asm:            ppc64.AMOVWBR,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1073733630}, // SP SB R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R14 R15 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29
+			},
+			outputs: []outputInfo{
+				{0, 1073733624}, // R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R14 R15 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29
+			},
+		},
+	},
+	{
+		name:           "MOVHBRload",
+		auxType:        auxSymOff,
+		argLen:         2,
+		faultOnNilArg0: true,
+		symEffect:      SymRead,
+		asm:            ppc64.AMOVHBR,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1073733630}, // SP SB R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R14 R15 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29
+			},
+			outputs: []outputInfo{
+				{0, 1073733624}, // R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R14 R15 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29
+			},
+		},
+	},
+	{
+		name:           "MOVDBRstore",
+		auxType:        auxSymOff,
+		argLen:         3,
+		faultOnNilArg0: true,
+		symEffect:      SymWrite,
+		asm:            ppc64.AMOVDBR,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1073733630}, // SP SB R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R14 R15 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29
+				{1, 1073733630}, // SP SB R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R14 R15 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29
+			},
+		},
+	},
+	{
+		name:           "MOVWBRstore",
+		auxType:        auxSymOff,
+		argLen:         3,
+		faultOnNilArg0: true,
+		symEffect:      SymWrite,
+		asm:            ppc64.AMOVWBR,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1073733630}, // SP SB R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R14 R15 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29
+				{1, 1073733630}, // SP SB R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R14 R15 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29
+			},
+		},
+	},
+	{
+		name:           "MOVHBRstore",
+		auxType:        auxSymOff,
+		argLen:         3,
+		faultOnNilArg0: true,
+		symEffect:      SymWrite,
+		asm:            ppc64.AMOVHBR,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1073733630}, // SP SB R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R14 R15 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29
+				{1, 1073733630}, // SP SB R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R14 R15 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29
+			},
+		},
+	},
 	{
 		name:           "FMOVDload",
 		auxType:        auxSymOff,
@@ -21134,7 +21230,7 @@ var opcodeTable = [...]opInfo{
 		asm:               ppc64.AMOVD,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 6}, // SP SB
+				{0, 1073733630}, // SP SB R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R14 R15 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29
 			},
 			outputs: []outputInfo{
 				{0, 1073733624}, // R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R14 R15 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29
diff --git a/src/cmd/compile/internal/ssa/regalloc.go b/src/cmd/compile/internal/ssa/regalloc.go
index f8a0e940b3..9c5486c954 100644
--- a/src/cmd/compile/internal/ssa/regalloc.go
+++ b/src/cmd/compile/internal/ssa/regalloc.go
@@ -375,7 +375,7 @@ func (s *regAllocState) allocReg(mask regMask, v *Value) register {
 	mask &= s.allocatable
 	mask &^= s.nospill
 	if mask == 0 {
-		s.f.Fatalf("no register available for %s", v)
+		s.f.Fatalf("no register available for %s", v.LongString())
 	}
 
 	// Pick an unused register if one is available.
diff --git a/src/cmd/compile/internal/ssa/rewritePPC64.go b/src/cmd/compile/internal/ssa/rewritePPC64.go
index 8f2c16cd6b..8dc3d008b0 100644
--- a/src/cmd/compile/internal/ssa/rewritePPC64.go
+++ b/src/cmd/compile/internal/ssa/rewritePPC64.go
@@ -452,7 +452,7 @@ func rewriteValuePPC64(v *Value) bool {
 	case OpPPC64MOVBreg:
 		return rewriteValuePPC64_OpPPC64MOVBreg_0(v)
 	case OpPPC64MOVBstore:
-		return rewriteValuePPC64_OpPPC64MOVBstore_0(v) || rewriteValuePPC64_OpPPC64MOVBstore_10(v)
+		return rewriteValuePPC64_OpPPC64MOVBstore_0(v) || rewriteValuePPC64_OpPPC64MOVBstore_10(v) || rewriteValuePPC64_OpPPC64MOVBstore_20(v)
 	case OpPPC64MOVBstorezero:
 		return rewriteValuePPC64_OpPPC64MOVBstorezero_0(v)
 	case OpPPC64MOVDload:
@@ -461,6 +461,8 @@ func rewriteValuePPC64(v *Value) bool {
 		return rewriteValuePPC64_OpPPC64MOVDstore_0(v)
 	case OpPPC64MOVDstorezero:
 		return rewriteValuePPC64_OpPPC64MOVDstorezero_0(v)
+	case OpPPC64MOVHBRstore:
+		return rewriteValuePPC64_OpPPC64MOVHBRstore_0(v)
 	case OpPPC64MOVHZload:
 		return rewriteValuePPC64_OpPPC64MOVHZload_0(v)
 	case OpPPC64MOVHZreg:
@@ -473,6 +475,8 @@ func rewriteValuePPC64(v *Value) bool {
 		return rewriteValuePPC64_OpPPC64MOVHstore_0(v)
 	case OpPPC64MOVHstorezero:
 		return rewriteValuePPC64_OpPPC64MOVHstorezero_0(v)
+	case OpPPC64MOVWBRstore:
+		return rewriteValuePPC64_OpPPC64MOVWBRstore_0(v)
 	case OpPPC64MOVWZload:
 		return rewriteValuePPC64_OpPPC64MOVWZload_0(v)
 	case OpPPC64MOVWZreg:
@@ -492,7 +496,7 @@ func rewriteValuePPC64(v *Value) bool {
 	case OpPPC64NotEqual:
 		return rewriteValuePPC64_OpPPC64NotEqual_0(v)
 	case OpPPC64OR:
-		return rewriteValuePPC64_OpPPC64OR_0(v) || rewriteValuePPC64_OpPPC64OR_10(v) || rewriteValuePPC64_OpPPC64OR_20(v) || rewriteValuePPC64_OpPPC64OR_30(v)
+		return rewriteValuePPC64_OpPPC64OR_0(v) || rewriteValuePPC64_OpPPC64OR_10(v) || rewriteValuePPC64_OpPPC64OR_20(v) || rewriteValuePPC64_OpPPC64OR_30(v) || rewriteValuePPC64_OpPPC64OR_40(v) || rewriteValuePPC64_OpPPC64OR_50(v) || rewriteValuePPC64_OpPPC64OR_60(v) || rewriteValuePPC64_OpPPC64OR_70(v) || rewriteValuePPC64_OpPPC64OR_80(v) || rewriteValuePPC64_OpPPC64OR_90(v) || rewriteValuePPC64_OpPPC64OR_100(v) || rewriteValuePPC64_OpPPC64OR_110(v)
 	case OpPPC64ORN:
 		return rewriteValuePPC64_OpPPC64ORN_0(v)
 	case OpPPC64ORconst:
@@ -7719,6 +7723,140 @@ func rewriteValuePPC64_OpPPC64MOVBstore_10(v *Value) bool {
 		v.AddArg(mem)
 		return true
 	}
+	// match: (MOVBstore [i3] {s} p w x0:(MOVBstore [i2] {s} p (SRWconst w [8]) x1:(MOVBstore [i1] {s} p (SRWconst w [16]) x2:(MOVBstore [i0] {s} p (SRWconst w [24]) mem))))
+	// cond: !config.BigEndian && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && clobber(x0) && clobber(x1) && clobber(x2)
+	// result: (MOVWBRstore (MOVDaddr <typ.Uintptr> [i0] {s} p) w mem)
+	for {
+		i3 := v.AuxInt
+		s := v.Aux
+		_ = v.Args[2]
+		p := v.Args[0]
+		w := v.Args[1]
+		x0 := v.Args[2]
+		if x0.Op != OpPPC64MOVBstore {
+			break
+		}
+		i2 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[2]
+		if p != x0.Args[0] {
+			break
+		}
+		x0_1 := x0.Args[1]
+		if x0_1.Op != OpPPC64SRWconst {
+			break
+		}
+		if x0_1.AuxInt != 8 {
+			break
+		}
+		if w != x0_1.Args[0] {
+			break
+		}
+		x1 := x0.Args[2]
+		if x1.Op != OpPPC64MOVBstore {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[2]
+		if p != x1.Args[0] {
+			break
+		}
+		x1_1 := x1.Args[1]
+		if x1_1.Op != OpPPC64SRWconst {
+			break
+		}
+		if x1_1.AuxInt != 16 {
+			break
+		}
+		if w != x1_1.Args[0] {
+			break
+		}
+		x2 := x1.Args[2]
+		if x2.Op != OpPPC64MOVBstore {
+			break
+		}
+		i0 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[2]
+		if p != x2.Args[0] {
+			break
+		}
+		x2_1 := x2.Args[1]
+		if x2_1.Op != OpPPC64SRWconst {
+			break
+		}
+		if x2_1.AuxInt != 24 {
+			break
+		}
+		if w != x2_1.Args[0] {
+			break
+		}
+		mem := x2.Args[2]
+		if !(!config.BigEndian && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && clobber(x0) && clobber(x1) && clobber(x2)) {
+			break
+		}
+		v.reset(OpPPC64MOVWBRstore)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v.AddArg(v0)
+		v.AddArg(w)
+		v.AddArg(mem)
+		return true
+	}
+	// match: (MOVBstore [i1] {s} p w x0:(MOVBstore [i0] {s} p (SRWconst w [8]) mem))
+	// cond: !config.BigEndian && x0.Uses == 1 && i1 == i0+1 && clobber(x0)
+	// result: (MOVHBRstore (MOVDaddr <typ.Uintptr> [i0] {s} p) w mem)
+	for {
+		i1 := v.AuxInt
+		s := v.Aux
+		_ = v.Args[2]
+		p := v.Args[0]
+		w := v.Args[1]
+		x0 := v.Args[2]
+		if x0.Op != OpPPC64MOVBstore {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[2]
+		if p != x0.Args[0] {
+			break
+		}
+		x0_1 := x0.Args[1]
+		if x0_1.Op != OpPPC64SRWconst {
+			break
+		}
+		if x0_1.AuxInt != 8 {
+			break
+		}
+		if w != x0_1.Args[0] {
+			break
+		}
+		mem := x0.Args[2]
+		if !(!config.BigEndian && x0.Uses == 1 && i1 == i0+1 && clobber(x0)) {
+			break
+		}
+		v.reset(OpPPC64MOVHBRstore)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v.AddArg(v0)
+		v.AddArg(w)
+		v.AddArg(mem)
+		return true
+	}
 	// match: (MOVBstore [i7] {s} p (SRDconst w [56]) x0:(MOVBstore [i6] {s} p (SRDconst w [48]) x1:(MOVBstore [i5] {s} p (SRDconst w [40]) x2:(MOVBstore [i4] {s} p (SRDconst w [32]) x3:(MOVWstore [i0] {s} p w mem)))))
 	// cond: !config.BigEndian && i0%4 == 0 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3)
 	// result: (MOVDstore [i0] {s} p w mem)
@@ -7830,6 +7968,192 @@ func rewriteValuePPC64_OpPPC64MOVBstore_10(v *Value) bool {
 	}
 	return false
 }
+func rewriteValuePPC64_OpPPC64MOVBstore_20(v *Value) bool {
+	b := v.Block
+	_ = b
+	config := b.Func.Config
+	_ = config
+	typ := &b.Func.Config.Types
+	_ = typ
+	// match: (MOVBstore [i7] {s} p w x0:(MOVBstore [i6] {s} p (SRDconst w [8]) x1:(MOVBstore [i5] {s} p (SRDconst w [16]) x2:(MOVBstore [i4] {s} p (SRDconst w [24]) x3:(MOVBstore [i3] {s} p (SRDconst w [32]) x4:(MOVBstore [i2] {s} p (SRDconst w [40]) x5:(MOVBstore [i1] {s} p (SRDconst w [48]) x6:(MOVBstore [i0] {s} p (SRDconst w [56]) mem))))))))
+	// cond: !config.BigEndian && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6)
+	// result: (MOVDBRstore (MOVDaddr <typ.Uintptr> [i0] {s} p) w mem)
+	for {
+		i7 := v.AuxInt
+		s := v.Aux
+		_ = v.Args[2]
+		p := v.Args[0]
+		w := v.Args[1]
+		x0 := v.Args[2]
+		if x0.Op != OpPPC64MOVBstore {
+			break
+		}
+		i6 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[2]
+		if p != x0.Args[0] {
+			break
+		}
+		x0_1 := x0.Args[1]
+		if x0_1.Op != OpPPC64SRDconst {
+			break
+		}
+		if x0_1.AuxInt != 8 {
+			break
+		}
+		if w != x0_1.Args[0] {
+			break
+		}
+		x1 := x0.Args[2]
+		if x1.Op != OpPPC64MOVBstore {
+			break
+		}
+		i5 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[2]
+		if p != x1.Args[0] {
+			break
+		}
+		x1_1 := x1.Args[1]
+		if x1_1.Op != OpPPC64SRDconst {
+			break
+		}
+		if x1_1.AuxInt != 16 {
+			break
+		}
+		if w != x1_1.Args[0] {
+			break
+		}
+		x2 := x1.Args[2]
+		if x2.Op != OpPPC64MOVBstore {
+			break
+		}
+		i4 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[2]
+		if p != x2.Args[0] {
+			break
+		}
+		x2_1 := x2.Args[1]
+		if x2_1.Op != OpPPC64SRDconst {
+			break
+		}
+		if x2_1.AuxInt != 24 {
+			break
+		}
+		if w != x2_1.Args[0] {
+			break
+		}
+		x3 := x2.Args[2]
+		if x3.Op != OpPPC64MOVBstore {
+			break
+		}
+		i3 := x3.AuxInt
+		if x3.Aux != s {
+			break
+		}
+		_ = x3.Args[2]
+		if p != x3.Args[0] {
+			break
+		}
+		x3_1 := x3.Args[1]
+		if x3_1.Op != OpPPC64SRDconst {
+			break
+		}
+		if x3_1.AuxInt != 32 {
+			break
+		}
+		if w != x3_1.Args[0] {
+			break
+		}
+		x4 := x3.Args[2]
+		if x4.Op != OpPPC64MOVBstore {
+			break
+		}
+		i2 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[2]
+		if p != x4.Args[0] {
+			break
+		}
+		x4_1 := x4.Args[1]
+		if x4_1.Op != OpPPC64SRDconst {
+			break
+		}
+		if x4_1.AuxInt != 40 {
+			break
+		}
+		if w != x4_1.Args[0] {
+			break
+		}
+		x5 := x4.Args[2]
+		if x5.Op != OpPPC64MOVBstore {
+			break
+		}
+		i1 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[2]
+		if p != x5.Args[0] {
+			break
+		}
+		x5_1 := x5.Args[1]
+		if x5_1.Op != OpPPC64SRDconst {
+			break
+		}
+		if x5_1.AuxInt != 48 {
+			break
+		}
+		if w != x5_1.Args[0] {
+			break
+		}
+		x6 := x5.Args[2]
+		if x6.Op != OpPPC64MOVBstore {
+			break
+		}
+		i0 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[2]
+		if p != x6.Args[0] {
+			break
+		}
+		x6_1 := x6.Args[1]
+		if x6_1.Op != OpPPC64SRDconst {
+			break
+		}
+		if x6_1.AuxInt != 56 {
+			break
+		}
+		if w != x6_1.Args[0] {
+			break
+		}
+		mem := x6.Args[2]
+		if !(!config.BigEndian && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6)) {
+			break
+		}
+		v.reset(OpPPC64MOVDBRstore)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v.AddArg(v0)
+		v.AddArg(w)
+		v.AddArg(mem)
+		return true
+	}
+	return false
+}
 func rewriteValuePPC64_OpPPC64MOVBstorezero_0(v *Value) bool {
 	// match: (MOVBstorezero [off1] {sym} (ADDconst [off2] x) mem)
 	// cond: is16Bit(off1+off2)
@@ -8115,6 +8439,89 @@ func rewriteValuePPC64_OpPPC64MOVDstorezero_0(v *Value) bool {
 	}
 	return false
 }
+func rewriteValuePPC64_OpPPC64MOVHBRstore_0(v *Value) bool {
+	// match: (MOVHBRstore {sym} ptr (MOVHreg x) mem)
+	// cond:
+	// result: (MOVHBRstore {sym} ptr x mem)
+	for {
+		sym := v.Aux
+		_ = v.Args[2]
+		ptr := v.Args[0]
+		v_1 := v.Args[1]
+		if v_1.Op != OpPPC64MOVHreg {
+			break
+		}
+		x := v_1.Args[0]
+		mem := v.Args[2]
+		v.reset(OpPPC64MOVHBRstore)
+		v.Aux = sym
+		v.AddArg(ptr)
+		v.AddArg(x)
+		v.AddArg(mem)
+		return true
+	}
+	// match: (MOVHBRstore {sym} ptr (MOVHZreg x) mem)
+	// cond:
+	// result: (MOVHBRstore {sym} ptr x mem)
+	for {
+		sym := v.Aux
+		_ = v.Args[2]
+		ptr := v.Args[0]
+		v_1 := v.Args[1]
+		if v_1.Op != OpPPC64MOVHZreg {
+			break
+		}
+		x := v_1.Args[0]
+		mem := v.Args[2]
+		v.reset(OpPPC64MOVHBRstore)
+		v.Aux = sym
+		v.AddArg(ptr)
+		v.AddArg(x)
+		v.AddArg(mem)
+		return true
+	}
+	// match: (MOVHBRstore {sym} ptr (MOVWreg x) mem)
+	// cond:
+	// result: (MOVHBRstore {sym} ptr x mem)
+	for {
+		sym := v.Aux
+		_ = v.Args[2]
+		ptr := v.Args[0]
+		v_1 := v.Args[1]
+		if v_1.Op != OpPPC64MOVWreg {
+			break
+		}
+		x := v_1.Args[0]
+		mem := v.Args[2]
+		v.reset(OpPPC64MOVHBRstore)
+		v.Aux = sym
+		v.AddArg(ptr)
+		v.AddArg(x)
+		v.AddArg(mem)
+		return true
+	}
+	// match: (MOVHBRstore {sym} ptr (MOVWZreg x) mem)
+	// cond:
+	// result: (MOVHBRstore {sym} ptr x mem)
+	for {
+		sym := v.Aux
+		_ = v.Args[2]
+		ptr := v.Args[0]
+		v_1 := v.Args[1]
+		if v_1.Op != OpPPC64MOVWZreg {
+			break
+		}
+		x := v_1.Args[0]
+		mem := v.Args[2]
+		v.reset(OpPPC64MOVHBRstore)
+		v.Aux = sym
+		v.AddArg(ptr)
+		v.AddArg(x)
+		v.AddArg(mem)
+		return true
+	}
+	return false
+}
 func rewriteValuePPC64_OpPPC64MOVHZload_0(v *Value) bool {
 	// match: (MOVHZload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
 	// cond: canMergeSym(sym1,sym2) && (ptr.Op != OpSB || p.Uses == 1)
@@ -8211,6 +8618,20 @@ func rewriteValuePPC64_OpPPC64MOVHZreg_0(v *Value) bool {
 		v.AddArg(y)
 		return true
 	}
+	// match: (MOVHZreg y:(MOVHBRload _ _))
+	// cond:
+	// result: y
+	for {
+		y := v.Args[0]
+		if y.Op != OpPPC64MOVHBRload {
+			break
+		}
+		_ = y.Args[1]
+		v.reset(OpCopy)
+		v.Type = y.Type
+		v.AddArg(y)
+		return true
+	}
 	// match: (MOVHZreg y:(MOVHreg x))
 	// cond:
 	// result: (MOVHZreg x)
@@ -8701,6 +9122,49 @@ func rewriteValuePPC64_OpPPC64MOVHstorezero_0(v *Value) bool {
 	}
 	return false
 }
+func rewriteValuePPC64_OpPPC64MOVWBRstore_0(v *Value) bool {
+	// match: (MOVWBRstore {sym} ptr (MOVWreg x) mem)
+	// cond:
+	// result: (MOVWBRstore {sym} ptr x mem)
+	for {
+		sym := v.Aux
+		_ = v.Args[2]
+		ptr := v.Args[0]
+		v_1 := v.Args[1]
+		if v_1.Op != OpPPC64MOVWreg {
+			break
+		}
+		x := v_1.Args[0]
+		mem := v.Args[2]
+		v.reset(OpPPC64MOVWBRstore)
+		v.Aux = sym
+		v.AddArg(ptr)
+		v.AddArg(x)
+		v.AddArg(mem)
+		return true
+	}
+	// match: (MOVWBRstore {sym} ptr (MOVWZreg x) mem)
+	// cond:
+	// result: (MOVWBRstore {sym} ptr x mem)
+	for {
+		sym := v.Aux
+		_ = v.Args[2]
+		ptr := v.Args[0]
+		v_1 := v.Args[1]
+		if v_1.Op != OpPPC64MOVWZreg {
+			break
+		}
+		x := v_1.Args[0]
+		mem := v.Args[2]
+		v.reset(OpPPC64MOVWBRstore)
+		v.Aux = sym
+		v.AddArg(ptr)
+		v.AddArg(x)
+		v.AddArg(mem)
+		return true
+	}
+	return false
+}
 func rewriteValuePPC64_OpPPC64MOVWZload_0(v *Value) bool {
 	// match: (MOVWZload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
 	// cond: canMergeSym(sym1,sym2) && (ptr.Op != OpSB || p.Uses == 1)
@@ -8854,6 +9318,34 @@ func rewriteValuePPC64_OpPPC64MOVWZreg_0(v *Value) bool {
 		v.AddArg(y)
 		return true
 	}
+	// match: (MOVWZreg y:(MOVHBRload _ _))
+	// cond:
+	// result: y
+	for {
+		y := v.Args[0]
+		if y.Op != OpPPC64MOVHBRload {
+			break
+		}
+		_ = y.Args[1]
+		v.reset(OpCopy)
+		v.Type = y.Type
+		v.AddArg(y)
+		return true
+	}
+	// match: (MOVWZreg y:(MOVWBRload _ _))
+	// cond:
+	// result: y
+	for {
+		y := v.Args[0]
+		if y.Op != OpPPC64MOVWBRload {
+			break
+		}
+		_ = y.Args[1]
+		v.reset(OpCopy)
+		v.Type = y.Type
+		v.AddArg(y)
+		return true
+	}
 	// match: (MOVWZreg y:(MOVWreg x))
 	// cond:
 	// result: (MOVWZreg x)
@@ -9745,6 +10237,8 @@ func rewriteValuePPC64_OpPPC64OR_10(v *Value) bool {
 	_ = b
 	config := b.Func.Config
 	_ = config
+	typ := &b.Func.Config.Types
+	_ = typ
 	// match: (OR x (MOVDconst [c]))
 	// cond: isU32Bit(c)
 	// result: (ORconst [c] x)
@@ -9983,63 +10477,85 @@ func rewriteValuePPC64_OpPPC64OR_10(v *Value) bool {
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> s1:(SLWconst x2:(MOVBZload [i3] {s} p mem) [24]) o0:(OR <t> s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [16]) x0:(MOVHZload [i0] {s} p mem)))
-	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
-	// result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
+	// match: (OR <t> x0:(MOVBZload [i1] {s} p mem) o1:(SLWconst x1:(MOVBZload [i0] {s} p mem) [8]))
+	// cond: !config.BigEndian && i1 == i0+1 && x0.Uses ==1 && x1.Uses == 1 && o1.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(o1)
+	// result: @mergePoint(b,x0,x1) (MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
-		s1 := v.Args[0]
-		if s1.Op != OpPPC64SLWconst {
+		x0 := v.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
 			break
 		}
-		if s1.AuxInt != 24 {
+		i1 := x0.AuxInt
+		s := x0.Aux
+		_ = x0.Args[1]
+		p := x0.Args[0]
+		mem := x0.Args[1]
+		o1 := v.Args[1]
+		if o1.Op != OpPPC64SLWconst {
 			break
 		}
-		x2 := s1.Args[0]
-		if x2.Op != OpPPC64MOVBZload {
+		if o1.AuxInt != 8 {
 			break
 		}
-		i3 := x2.AuxInt
-		s := x2.Aux
-		_ = x2.Args[1]
-		p := x2.Args[0]
-		mem := x2.Args[1]
-		o0 := v.Args[1]
-		if o0.Op != OpPPC64OR {
+		x1 := o1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
 			break
 		}
-		if o0.Type != t {
+		i0 := x1.AuxInt
+		if x1.Aux != s {
 			break
 		}
-		_ = o0.Args[1]
-		s0 := o0.Args[0]
-		if s0.Op != OpPPC64SLWconst {
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
 			break
 		}
-		if s0.AuxInt != 16 {
+		if mem != x1.Args[1] {
 			break
 		}
-		x1 := s0.Args[0]
-		if x1.Op != OpPPC64MOVBZload {
+		if !(!config.BigEndian && i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && o1.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(o1)) {
 			break
 		}
-		i2 := x1.AuxInt
-		if x1.Aux != s {
+		b = mergePoint(b, x0, x1)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVHBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o1:(SLWconst x1:(MOVBZload [i0] {s} p mem) [8]) x0:(MOVBZload [i1] {s} p mem))
+	// cond: !config.BigEndian && i1 == i0+1 && x0.Uses ==1 && x1.Uses == 1 && o1.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(o1)
+	// result: @mergePoint(b,x0,x1) (MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o1 := v.Args[0]
+		if o1.Op != OpPPC64SLWconst {
 			break
 		}
-		_ = x1.Args[1]
-		if p != x1.Args[0] {
+		if o1.AuxInt != 8 {
 			break
 		}
-		if mem != x1.Args[1] {
+		x1 := o1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
 			break
 		}
-		x0 := o0.Args[1]
-		if x0.Op != OpPPC64MOVHZload {
+		i0 := x1.AuxInt
+		s := x1.Aux
+		_ = x1.Args[1]
+		p := x1.Args[0]
+		mem := x1.Args[1]
+		x0 := v.Args[1]
+		if x0.Op != OpPPC64MOVBZload {
 			break
 		}
-		i0 := x0.AuxInt
+		i1 := x0.AuxInt
 		if x0.Aux != s {
 			break
 		}
@@ -10050,214 +10566,280 @@ func rewriteValuePPC64_OpPPC64OR_10(v *Value) bool {
 		if mem != x0.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+		if !(!config.BigEndian && i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && o1.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(o1)) {
 			break
 		}
-		b = mergePoint(b, x0, x1, x2)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVWZload, t)
+		b = mergePoint(b, x0, x1)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVHBRload, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> s1:(SLWconst x2:(MOVBZload [i3] {s} p mem) [24]) o0:(OR <t> x0:(MOVHZload [i0] {s} p mem) s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [16])))
-	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
-	// result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
+	// match: (OR <t> x0:(MOVBZload [i1] {s} p mem) o1:(SLDconst x1:(MOVBZload [i0] {s} p mem) [8]))
+	// cond: !config.BigEndian && i1 == i0+1 && x0.Uses ==1 && x1.Uses == 1 && o1.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(o1)
+	// result: @mergePoint(b,x0,x1) (MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
-		s1 := v.Args[0]
-		if s1.Op != OpPPC64SLWconst {
+		x0 := v.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
 			break
 		}
-		if s1.AuxInt != 24 {
+		i1 := x0.AuxInt
+		s := x0.Aux
+		_ = x0.Args[1]
+		p := x0.Args[0]
+		mem := x0.Args[1]
+		o1 := v.Args[1]
+		if o1.Op != OpPPC64SLDconst {
 			break
 		}
-		x2 := s1.Args[0]
-		if x2.Op != OpPPC64MOVBZload {
+		if o1.AuxInt != 8 {
 			break
 		}
-		i3 := x2.AuxInt
-		s := x2.Aux
-		_ = x2.Args[1]
-		p := x2.Args[0]
-		mem := x2.Args[1]
-		o0 := v.Args[1]
-		if o0.Op != OpPPC64OR {
+		x1 := o1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
 			break
 		}
-		if o0.Type != t {
+		i0 := x1.AuxInt
+		if x1.Aux != s {
 			break
 		}
-		_ = o0.Args[1]
-		x0 := o0.Args[0]
-		if x0.Op != OpPPC64MOVHZload {
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		if mem != x1.Args[1] {
 			break
 		}
-		_ = x0.Args[1]
-		if p != x0.Args[0] {
+		if !(!config.BigEndian && i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && o1.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(o1)) {
 			break
 		}
-		if mem != x0.Args[1] {
+		b = mergePoint(b, x0, x1)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVHBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o1:(SLDconst x1:(MOVBZload [i0] {s} p mem) [8]) x0:(MOVBZload [i1] {s} p mem))
+	// cond: !config.BigEndian && i1 == i0+1 && x0.Uses ==1 && x1.Uses == 1 && o1.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(o1)
+	// result: @mergePoint(b,x0,x1) (MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o1 := v.Args[0]
+		if o1.Op != OpPPC64SLDconst {
 			break
 		}
-		s0 := o0.Args[1]
-		if s0.Op != OpPPC64SLWconst {
+		if o1.AuxInt != 8 {
 			break
 		}
-		if s0.AuxInt != 16 {
+		x1 := o1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
 			break
 		}
-		x1 := s0.Args[0]
-		if x1.Op != OpPPC64MOVBZload {
+		i0 := x1.AuxInt
+		s := x1.Aux
+		_ = x1.Args[1]
+		p := x1.Args[0]
+		mem := x1.Args[1]
+		x0 := v.Args[1]
+		if x0.Op != OpPPC64MOVBZload {
 			break
 		}
-		i2 := x1.AuxInt
-		if x1.Aux != s {
+		i1 := x0.AuxInt
+		if x0.Aux != s {
 			break
 		}
-		_ = x1.Args[1]
-		if p != x1.Args[0] {
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
 			break
 		}
-		if mem != x1.Args[1] {
+		if mem != x0.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+		if !(!config.BigEndian && i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && o1.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(o1)) {
 			break
 		}
-		b = mergePoint(b, x0, x1, x2)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVWZload, t)
+		b = mergePoint(b, x0, x1)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVHBRload, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> o0:(OR <t> s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [16]) x0:(MOVHZload [i0] {s} p mem)) s1:(SLWconst x2:(MOVBZload [i3] {s} p mem) [24]))
-	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
-	// result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
+	return false
+}
+func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
+	b := v.Block
+	_ = b
+	config := b.Func.Config
+	_ = config
+	typ := &b.Func.Config.Types
+	_ = typ
+	// match: (OR <t> s0:(SLWconst x0:(MOVBZload [i1] {s} p mem) [n1]) s1:(SLWconst x1:(MOVBZload [i0] {s} p mem) [n2]))
+	// cond: !config.BigEndian && i1 == i0+1 && n1%8 == 0 && n2 == n1+8 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1)
+	// result: @mergePoint(b,x0,x1) (SLDconst <t> (MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [n1])
 	for {
 		t := v.Type
 		_ = v.Args[1]
-		o0 := v.Args[0]
-		if o0.Op != OpPPC64OR {
+		s0 := v.Args[0]
+		if s0.Op != OpPPC64SLWconst {
 			break
 		}
-		if o0.Type != t {
+		n1 := s0.AuxInt
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
 			break
 		}
-		_ = o0.Args[1]
-		s0 := o0.Args[0]
-		if s0.Op != OpPPC64SLWconst {
+		i1 := x0.AuxInt
+		s := x0.Aux
+		_ = x0.Args[1]
+		p := x0.Args[0]
+		mem := x0.Args[1]
+		s1 := v.Args[1]
+		if s1.Op != OpPPC64SLWconst {
 			break
 		}
-		if s0.AuxInt != 16 {
+		n2 := s1.AuxInt
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
 			break
 		}
-		x1 := s0.Args[0]
-		if x1.Op != OpPPC64MOVBZload {
+		i0 := x1.AuxInt
+		if x1.Aux != s {
 			break
 		}
-		i2 := x1.AuxInt
-		s := x1.Aux
 		_ = x1.Args[1]
-		p := x1.Args[0]
-		mem := x1.Args[1]
-		x0 := o0.Args[1]
-		if x0.Op != OpPPC64MOVHZload {
+		if p != x1.Args[0] {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		if mem != x1.Args[1] {
 			break
 		}
-		_ = x0.Args[1]
-		if p != x0.Args[0] {
+		if !(!config.BigEndian && i1 == i0+1 && n1%8 == 0 && n2 == n1+8 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1)) {
 			break
 		}
-		if mem != x0.Args[1] {
+		b = mergePoint(b, x0, x1)
+		v0 := b.NewValue0(v.Pos, OpPPC64SLDconst, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = n1
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVHBRload, t)
+		v2 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v2.AuxInt = i0
+		v2.Aux = s
+		v2.AddArg(p)
+		v1.AddArg(v2)
+		v1.AddArg(mem)
+		v0.AddArg(v1)
+		return true
+	}
+	// match: (OR <t> s1:(SLWconst x1:(MOVBZload [i0] {s} p mem) [n2]) s0:(SLWconst x0:(MOVBZload [i1] {s} p mem) [n1]))
+	// cond: !config.BigEndian && i1 == i0+1 && n1%8 == 0 && n2 == n1+8 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1)
+	// result: @mergePoint(b,x0,x1) (SLDconst <t> (MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [n1])
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s1 := v.Args[0]
+		if s1.Op != OpPPC64SLWconst {
 			break
 		}
-		s1 := v.Args[1]
-		if s1.Op != OpPPC64SLWconst {
+		n2 := s1.AuxInt
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
 			break
 		}
-		if s1.AuxInt != 24 {
+		i0 := x1.AuxInt
+		s := x1.Aux
+		_ = x1.Args[1]
+		p := x1.Args[0]
+		mem := x1.Args[1]
+		s0 := v.Args[1]
+		if s0.Op != OpPPC64SLWconst {
 			break
 		}
-		x2 := s1.Args[0]
-		if x2.Op != OpPPC64MOVBZload {
+		n1 := s0.AuxInt
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
 			break
 		}
-		i3 := x2.AuxInt
-		if x2.Aux != s {
+		i1 := x0.AuxInt
+		if x0.Aux != s {
 			break
 		}
-		_ = x2.Args[1]
-		if p != x2.Args[0] {
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
 			break
 		}
-		if mem != x2.Args[1] {
+		if mem != x0.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+		if !(!config.BigEndian && i1 == i0+1 && n1%8 == 0 && n2 == n1+8 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1)) {
 			break
 		}
-		b = mergePoint(b, x0, x1, x2)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVWZload, t)
+		b = mergePoint(b, x0, x1)
+		v0 := b.NewValue0(v.Pos, OpPPC64SLDconst, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
-		v0.AddArg(mem)
+		v0.AuxInt = n1
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVHBRload, t)
+		v2 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v2.AuxInt = i0
+		v2.Aux = s
+		v2.AddArg(p)
+		v1.AddArg(v2)
+		v1.AddArg(mem)
+		v0.AddArg(v1)
 		return true
 	}
-	// match: (OR <t> o0:(OR <t> x0:(MOVHZload [i0] {s} p mem) s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [16])) s1:(SLWconst x2:(MOVBZload [i3] {s} p mem) [24]))
-	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
-	// result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
+	// match: (OR <t> s0:(SLDconst x0:(MOVBZload [i1] {s} p mem) [n1]) s1:(SLDconst x1:(MOVBZload [i0] {s} p mem) [n2]))
+	// cond: !config.BigEndian && i1 == i0+1 && n1%8 == 0 && n2 == n1+8 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1)
+	// result: @mergePoint(b,x0,x1) (SLDconst <t> (MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [n1])
 	for {
 		t := v.Type
 		_ = v.Args[1]
-		o0 := v.Args[0]
-		if o0.Op != OpPPC64OR {
-			break
-		}
-		if o0.Type != t {
+		s0 := v.Args[0]
+		if s0.Op != OpPPC64SLDconst {
 			break
 		}
-		_ = o0.Args[1]
-		x0 := o0.Args[0]
-		if x0.Op != OpPPC64MOVHZload {
+		n1 := s0.AuxInt
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
 			break
 		}
-		i0 := x0.AuxInt
+		i1 := x0.AuxInt
 		s := x0.Aux
 		_ = x0.Args[1]
 		p := x0.Args[0]
 		mem := x0.Args[1]
-		s0 := o0.Args[1]
-		if s0.Op != OpPPC64SLWconst {
-			break
-		}
-		if s0.AuxInt != 16 {
+		s1 := v.Args[1]
+		if s1.Op != OpPPC64SLDconst {
 			break
 		}
-		x1 := s0.Args[0]
+		n2 := s1.AuxInt
+		x1 := s1.Args[0]
 		if x1.Op != OpPPC64MOVBZload {
 			break
 		}
-		i2 := x1.AuxInt
+		i0 := x1.AuxInt
 		if x1.Aux != s {
 			break
 		}
@@ -10268,56 +10850,90 @@ func rewriteValuePPC64_OpPPC64OR_10(v *Value) bool {
 		if mem != x1.Args[1] {
 			break
 		}
-		s1 := v.Args[1]
-		if s1.Op != OpPPC64SLWconst {
+		if !(!config.BigEndian && i1 == i0+1 && n1%8 == 0 && n2 == n1+8 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1)) {
 			break
 		}
-		if s1.AuxInt != 24 {
+		b = mergePoint(b, x0, x1)
+		v0 := b.NewValue0(v.Pos, OpPPC64SLDconst, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = n1
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVHBRload, t)
+		v2 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v2.AuxInt = i0
+		v2.Aux = s
+		v2.AddArg(p)
+		v1.AddArg(v2)
+		v1.AddArg(mem)
+		v0.AddArg(v1)
+		return true
+	}
+	// match: (OR <t> s1:(SLDconst x1:(MOVBZload [i0] {s} p mem) [n2]) s0:(SLDconst x0:(MOVBZload [i1] {s} p mem) [n1]))
+	// cond: !config.BigEndian && i1 == i0+1 && n1%8 == 0 && n2 == n1+8 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1)
+	// result: @mergePoint(b,x0,x1) (SLDconst <t> (MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [n1])
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s1 := v.Args[0]
+		if s1.Op != OpPPC64SLDconst {
 			break
 		}
-		x2 := s1.Args[0]
-		if x2.Op != OpPPC64MOVBZload {
+		n2 := s1.AuxInt
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
 			break
 		}
-		i3 := x2.AuxInt
-		if x2.Aux != s {
+		i0 := x1.AuxInt
+		s := x1.Aux
+		_ = x1.Args[1]
+		p := x1.Args[0]
+		mem := x1.Args[1]
+		s0 := v.Args[1]
+		if s0.Op != OpPPC64SLDconst {
 			break
 		}
-		_ = x2.Args[1]
-		if p != x2.Args[0] {
+		n1 := s0.AuxInt
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
 			break
 		}
-		if mem != x2.Args[1] {
+		i1 := x0.AuxInt
+		if x0.Aux != s {
 			break
 		}
-		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
 			break
 		}
-		b = mergePoint(b, x0, x1, x2)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVWZload, t)
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && n1%8 == 0 && n2 == n1+8 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1)) {
+			break
+		}
+		b = mergePoint(b, x0, x1)
+		v0 := b.NewValue0(v.Pos, OpPPC64SLDconst, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
-		v0.AddArg(mem)
+		v0.AuxInt = n1
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVHBRload, t)
+		v2 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v2.AuxInt = i0
+		v2.Aux = s
+		v2.AddArg(p)
+		v1.AddArg(v2)
+		v1.AddArg(mem)
+		v0.AddArg(v1)
 		return true
 	}
-	return false
-}
-func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
-	b := v.Block
-	_ = b
-	config := b.Func.Config
-	_ = config
-	// match: (OR <t> s1:(SLDconst x2:(MOVBZload [i3] {s} p mem) [24]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i2] {s} p mem) [16]) x0:(MOVHZload [i0] {s} p mem)))
+	// match: (OR <t> s1:(SLWconst x2:(MOVBZload [i3] {s} p mem) [24]) o0:(OR <t> s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [16]) x0:(MOVHZload [i0] {s} p mem)))
 	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
 	// result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
 		s1 := v.Args[0]
-		if s1.Op != OpPPC64SLDconst {
+		if s1.Op != OpPPC64SLWconst {
 			break
 		}
 		if s1.AuxInt != 24 {
@@ -10341,7 +10957,7 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 		}
 		_ = o0.Args[1]
 		s0 := o0.Args[0]
-		if s0.Op != OpPPC64SLDconst {
+		if s0.Op != OpPPC64SLWconst {
 			break
 		}
 		if s0.AuxInt != 16 {
@@ -10390,14 +11006,14 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> s1:(SLDconst x2:(MOVBZload [i3] {s} p mem) [24]) o0:(OR <t> x0:(MOVHZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i2] {s} p mem) [16])))
+	// match: (OR <t> s1:(SLWconst x2:(MOVBZload [i3] {s} p mem) [24]) o0:(OR <t> x0:(MOVHZload [i0] {s} p mem) s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [16])))
 	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
 	// result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
 		s1 := v.Args[0]
-		if s1.Op != OpPPC64SLDconst {
+		if s1.Op != OpPPC64SLWconst {
 			break
 		}
 		if s1.AuxInt != 24 {
@@ -10436,7 +11052,7 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 			break
 		}
 		s0 := o0.Args[1]
-		if s0.Op != OpPPC64SLDconst {
+		if s0.Op != OpPPC64SLWconst {
 			break
 		}
 		if s0.AuxInt != 16 {
@@ -10470,7 +11086,7 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i2] {s} p mem) [16]) x0:(MOVHZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i3] {s} p mem) [24]))
+	// match: (OR <t> o0:(OR <t> s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [16]) x0:(MOVHZload [i0] {s} p mem)) s1:(SLWconst x2:(MOVBZload [i3] {s} p mem) [24]))
 	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
 	// result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
 	for {
@@ -10485,7 +11101,7 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 		}
 		_ = o0.Args[1]
 		s0 := o0.Args[0]
-		if s0.Op != OpPPC64SLDconst {
+		if s0.Op != OpPPC64SLWconst {
 			break
 		}
 		if s0.AuxInt != 16 {
@@ -10516,7 +11132,7 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 			break
 		}
 		s1 := v.Args[1]
-		if s1.Op != OpPPC64SLDconst {
+		if s1.Op != OpPPC64SLWconst {
 			break
 		}
 		if s1.AuxInt != 24 {
@@ -10550,7 +11166,7 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> o0:(OR <t> x0:(MOVHZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i2] {s} p mem) [16])) s1:(SLDconst x2:(MOVBZload [i3] {s} p mem) [24]))
+	// match: (OR <t> o0:(OR <t> x0:(MOVHZload [i0] {s} p mem) s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [16])) s1:(SLWconst x2:(MOVBZload [i3] {s} p mem) [24]))
 	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
 	// result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
 	for {
@@ -10574,7 +11190,7 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 		p := x0.Args[0]
 		mem := x0.Args[1]
 		s0 := o0.Args[1]
-		if s0.Op != OpPPC64SLDconst {
+		if s0.Op != OpPPC64SLWconst {
 			break
 		}
 		if s0.AuxInt != 16 {
@@ -10596,7 +11212,7 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 			break
 		}
 		s1 := v.Args[1]
-		if s1.Op != OpPPC64SLDconst {
+		if s1.Op != OpPPC64SLWconst {
 			break
 		}
 		if s1.AuxInt != 24 {
@@ -10630,17 +11246,4867 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) x0:(MOVWZload {s} [i0] p mem)))))
-	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
-	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	// match: (OR <t> s1:(SLDconst x2:(MOVBZload [i3] {s} p mem) [24]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i2] {s} p mem) [16]) x0:(MOVHZload [i0] {s} p mem)))
+	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
-		s6 := v.Args[0]
-		if s6.Op != OpPPC64SLDconst {
+		s1 := v.Args[0]
+		if s1.Op != OpPPC64SLDconst {
 			break
 		}
-		if s6.AuxInt != 56 {
+		if s1.AuxInt != 24 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x2.AuxInt
+		s := x2.Aux
+		_ = x2.Args[1]
+		p := x2.Args[0]
+		mem := x2.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s0 := o0.Args[0]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 16 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		x0 := o0.Args[1]
+		if x0.Op != OpPPC64MOVHZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWZload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s1:(SLDconst x2:(MOVBZload [i3] {s} p mem) [24]) o0:(OR <t> x0:(MOVHZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i2] {s} p mem) [16])))
+	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s1 := v.Args[0]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 24 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x2.AuxInt
+		s := x2.Aux
+		_ = x2.Args[1]
+		p := x2.Args[0]
+		mem := x2.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		x0 := o0.Args[0]
+		if x0.Op != OpPPC64MOVHZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s0 := o0.Args[1]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 16 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWZload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	return false
+}
+func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
+	b := v.Block
+	_ = b
+	config := b.Func.Config
+	_ = config
+	typ := &b.Func.Config.Types
+	_ = typ
+	// match: (OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i2] {s} p mem) [16]) x0:(MOVHZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i3] {s} p mem) [24]))
+	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s0 := o0.Args[0]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 16 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x1.AuxInt
+		s := x1.Aux
+		_ = x1.Args[1]
+		p := x1.Args[0]
+		mem := x1.Args[1]
+		x0 := o0.Args[1]
+		if x0.Op != OpPPC64MOVHZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s1 := v.Args[1]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 24 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWZload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> x0:(MOVHZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i2] {s} p mem) [16])) s1:(SLDconst x2:(MOVBZload [i3] {s} p mem) [24]))
+	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		x0 := o0.Args[0]
+		if x0.Op != OpPPC64MOVHZload {
+			break
+		}
+		i0 := x0.AuxInt
+		s := x0.Aux
+		_ = x0.Args[1]
+		p := x0.Args[0]
+		mem := x0.Args[1]
+		s0 := o0.Args[1]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 16 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		s1 := v.Args[1]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 24 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWZload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s1:(SLWconst x2:(MOVBZload [i0] {s} p mem) [24]) o0:(OR <t> s0:(SLWconst x1:(MOVBZload [i1] {s} p mem) [16]) x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i2] {s} p) mem)))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s1 := v.Args[0]
+		if s1.Op != OpPPC64SLWconst {
+			break
+		}
+		if s1.AuxInt != 24 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x2.AuxInt
+		s := x2.Aux
+		_ = x2.Args[1]
+		p := x2.Args[0]
+		mem := x2.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s0 := o0.Args[0]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 16 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		x0 := o0.Args[1]
+		if x0.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x0.Type != t {
+			break
+		}
+		_ = x0.Args[1]
+		x0_0 := x0.Args[0]
+		if x0_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x0_0.Type != typ.Uintptr {
+			break
+		}
+		i2 := x0_0.AuxInt
+		if x0_0.Aux != s {
+			break
+		}
+		if p != x0_0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s1:(SLWconst x2:(MOVBZload [i0] {s} p mem) [24]) o0:(OR <t> x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i2] {s} p) mem) s0:(SLWconst x1:(MOVBZload [i1] {s} p mem) [16])))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s1 := v.Args[0]
+		if s1.Op != OpPPC64SLWconst {
+			break
+		}
+		if s1.AuxInt != 24 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x2.AuxInt
+		s := x2.Aux
+		_ = x2.Args[1]
+		p := x2.Args[0]
+		mem := x2.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		x0 := o0.Args[0]
+		if x0.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x0.Type != t {
+			break
+		}
+		_ = x0.Args[1]
+		x0_0 := x0.Args[0]
+		if x0_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x0_0.Type != typ.Uintptr {
+			break
+		}
+		i2 := x0_0.AuxInt
+		if x0_0.Aux != s {
+			break
+		}
+		if p != x0_0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s0 := o0.Args[1]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 16 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> s0:(SLWconst x1:(MOVBZload [i1] {s} p mem) [16]) x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i2] {s} p) mem)) s1:(SLWconst x2:(MOVBZload [i0] {s} p mem) [24]))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s0 := o0.Args[0]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 16 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		s := x1.Aux
+		_ = x1.Args[1]
+		p := x1.Args[0]
+		mem := x1.Args[1]
+		x0 := o0.Args[1]
+		if x0.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x0.Type != t {
+			break
+		}
+		_ = x0.Args[1]
+		x0_0 := x0.Args[0]
+		if x0_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x0_0.Type != typ.Uintptr {
+			break
+		}
+		i2 := x0_0.AuxInt
+		if x0_0.Aux != s {
+			break
+		}
+		if p != x0_0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s1 := v.Args[1]
+		if s1.Op != OpPPC64SLWconst {
+			break
+		}
+		if s1.AuxInt != 24 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i2] {s} p) mem) s0:(SLWconst x1:(MOVBZload [i1] {s} p mem) [16])) s1:(SLWconst x2:(MOVBZload [i0] {s} p mem) [24]))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		x0 := o0.Args[0]
+		if x0.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x0.Type != t {
+			break
+		}
+		_ = x0.Args[1]
+		x0_0 := x0.Args[0]
+		if x0_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x0_0.Type != typ.Uintptr {
+			break
+		}
+		i2 := x0_0.AuxInt
+		s := x0_0.Aux
+		p := x0_0.Args[0]
+		mem := x0.Args[1]
+		s0 := o0.Args[1]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 16 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		s1 := v.Args[1]
+		if s1.Op != OpPPC64SLWconst {
+			break
+		}
+		if s1.AuxInt != 24 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s1:(SLDconst x2:(MOVBZload [i0] {s} p mem) [24]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [16]) x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i2] {s} p) mem)))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s1 := v.Args[0]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 24 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x2.AuxInt
+		s := x2.Aux
+		_ = x2.Args[1]
+		p := x2.Args[0]
+		mem := x2.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s0 := o0.Args[0]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 16 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		x0 := o0.Args[1]
+		if x0.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x0.Type != t {
+			break
+		}
+		_ = x0.Args[1]
+		x0_0 := x0.Args[0]
+		if x0_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x0_0.Type != typ.Uintptr {
+			break
+		}
+		i2 := x0_0.AuxInt
+		if x0_0.Aux != s {
+			break
+		}
+		if p != x0_0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s1:(SLDconst x2:(MOVBZload [i0] {s} p mem) [24]) o0:(OR <t> x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i2] {s} p) mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [16])))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s1 := v.Args[0]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 24 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x2.AuxInt
+		s := x2.Aux
+		_ = x2.Args[1]
+		p := x2.Args[0]
+		mem := x2.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		x0 := o0.Args[0]
+		if x0.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x0.Type != t {
+			break
+		}
+		_ = x0.Args[1]
+		x0_0 := x0.Args[0]
+		if x0_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x0_0.Type != typ.Uintptr {
+			break
+		}
+		i2 := x0_0.AuxInt
+		if x0_0.Aux != s {
+			break
+		}
+		if p != x0_0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s0 := o0.Args[1]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 16 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [16]) x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i2] {s} p) mem)) s1:(SLDconst x2:(MOVBZload [i0] {s} p mem) [24]))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s0 := o0.Args[0]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 16 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		s := x1.Aux
+		_ = x1.Args[1]
+		p := x1.Args[0]
+		mem := x1.Args[1]
+		x0 := o0.Args[1]
+		if x0.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x0.Type != t {
+			break
+		}
+		_ = x0.Args[1]
+		x0_0 := x0.Args[0]
+		if x0_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x0_0.Type != typ.Uintptr {
+			break
+		}
+		i2 := x0_0.AuxInt
+		if x0_0.Aux != s {
+			break
+		}
+		if p != x0_0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s1 := v.Args[1]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 24 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i2] {s} p) mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [16])) s1:(SLDconst x2:(MOVBZload [i0] {s} p mem) [24]))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		x0 := o0.Args[0]
+		if x0.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x0.Type != t {
+			break
+		}
+		_ = x0.Args[1]
+		x0_0 := x0.Args[0]
+		if x0_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x0_0.Type != typ.Uintptr {
+			break
+		}
+		i2 := x0_0.AuxInt
+		s := x0_0.Aux
+		p := x0_0.Args[0]
+		mem := x0.Args[1]
+		s0 := o0.Args[1]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 16 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		s1 := v.Args[1]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 24 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	return false
+}
+func rewriteValuePPC64_OpPPC64OR_40(v *Value) bool {
+	b := v.Block
+	_ = b
+	config := b.Func.Config
+	_ = config
+	typ := &b.Func.Config.Types
+	_ = typ
+	// match: (OR <t> x0:(MOVBZload [i3] {s} p mem) o0:(OR <t> s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [8]) s1:(SLWconst x2:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [16])))
+	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		x0 := v.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x0.AuxInt
+		s := x0.Aux
+		_ = x0.Args[1]
+		p := x0.Args[0]
+		mem := x0.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s0 := o0.Args[0]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 8 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		s1 := o0.Args[1]
+		if s1.Op != OpPPC64SLWconst {
+			break
+		}
+		if s1.AuxInt != 16 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x2.Type != t {
+			break
+		}
+		_ = x2.Args[1]
+		x2_0 := x2.Args[0]
+		if x2_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x2_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x2_0.AuxInt
+		if x2_0.Aux != s {
+			break
+		}
+		if p != x2_0.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> x0:(MOVBZload [i3] {s} p mem) o0:(OR <t> s1:(SLWconst x2:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [16]) s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [8])))
+	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		x0 := v.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x0.AuxInt
+		s := x0.Aux
+		_ = x0.Args[1]
+		p := x0.Args[0]
+		mem := x0.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s1 := o0.Args[0]
+		if s1.Op != OpPPC64SLWconst {
+			break
+		}
+		if s1.AuxInt != 16 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x2.Type != t {
+			break
+		}
+		_ = x2.Args[1]
+		x2_0 := x2.Args[0]
+		if x2_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x2_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x2_0.AuxInt
+		if x2_0.Aux != s {
+			break
+		}
+		if p != x2_0.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		s0 := o0.Args[1]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 8 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [8]) s1:(SLWconst x2:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [16])) x0:(MOVBZload [i3] {s} p mem))
+	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s0 := o0.Args[0]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 8 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x1.AuxInt
+		s := x1.Aux
+		_ = x1.Args[1]
+		p := x1.Args[0]
+		mem := x1.Args[1]
+		s1 := o0.Args[1]
+		if s1.Op != OpPPC64SLWconst {
+			break
+		}
+		if s1.AuxInt != 16 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x2.Type != t {
+			break
+		}
+		_ = x2.Args[1]
+		x2_0 := x2.Args[0]
+		if x2_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x2_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x2_0.AuxInt
+		if x2_0.Aux != s {
+			break
+		}
+		if p != x2_0.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		x0 := v.Args[1]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> s1:(SLWconst x2:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [16]) s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [8])) x0:(MOVBZload [i3] {s} p mem))
+	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s1 := o0.Args[0]
+		if s1.Op != OpPPC64SLWconst {
+			break
+		}
+		if s1.AuxInt != 16 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x2.Type != t {
+			break
+		}
+		_ = x2.Args[1]
+		x2_0 := x2.Args[0]
+		if x2_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x2_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x2_0.AuxInt
+		s := x2_0.Aux
+		p := x2_0.Args[0]
+		mem := x2.Args[1]
+		s0 := o0.Args[1]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 8 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		x0 := v.Args[1]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> x0:(MOVBZload [i3] {s} p mem) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i2] {s} p mem) [8]) s1:(SLDconst x2:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [16])))
+	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		x0 := v.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x0.AuxInt
+		s := x0.Aux
+		_ = x0.Args[1]
+		p := x0.Args[0]
+		mem := x0.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s0 := o0.Args[0]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 8 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		s1 := o0.Args[1]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 16 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x2.Type != t {
+			break
+		}
+		_ = x2.Args[1]
+		x2_0 := x2.Args[0]
+		if x2_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x2_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x2_0.AuxInt
+		if x2_0.Aux != s {
+			break
+		}
+		if p != x2_0.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> x0:(MOVBZload [i3] {s} p mem) o0:(OR <t> s1:(SLDconst x2:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [16]) s0:(SLDconst x1:(MOVBZload [i2] {s} p mem) [8])))
+	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		x0 := v.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x0.AuxInt
+		s := x0.Aux
+		_ = x0.Args[1]
+		p := x0.Args[0]
+		mem := x0.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s1 := o0.Args[0]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 16 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x2.Type != t {
+			break
+		}
+		_ = x2.Args[1]
+		x2_0 := x2.Args[0]
+		if x2_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x2_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x2_0.AuxInt
+		if x2_0.Aux != s {
+			break
+		}
+		if p != x2_0.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		s0 := o0.Args[1]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 8 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i2] {s} p mem) [8]) s1:(SLDconst x2:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [16])) x0:(MOVBZload [i3] {s} p mem))
+	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s0 := o0.Args[0]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 8 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x1.AuxInt
+		s := x1.Aux
+		_ = x1.Args[1]
+		p := x1.Args[0]
+		mem := x1.Args[1]
+		s1 := o0.Args[1]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 16 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x2.Type != t {
+			break
+		}
+		_ = x2.Args[1]
+		x2_0 := x2.Args[0]
+		if x2_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x2_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x2_0.AuxInt
+		if x2_0.Aux != s {
+			break
+		}
+		if p != x2_0.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		x0 := v.Args[1]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> s1:(SLDconst x2:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [16]) s0:(SLDconst x1:(MOVBZload [i2] {s} p mem) [8])) x0:(MOVBZload [i3] {s} p mem))
+	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s1 := o0.Args[0]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 16 {
+			break
+		}
+		x2 := s1.Args[0]
+		if x2.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x2.Type != t {
+			break
+		}
+		_ = x2.Args[1]
+		x2_0 := x2.Args[0]
+		if x2_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x2_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x2_0.AuxInt
+		s := x2_0.Aux
+		p := x2_0.Args[0]
+		mem := x2.Args[1]
+		s0 := o0.Args[1]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 8 {
+			break
+		}
+		x1 := s0.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		x0 := v.Args[1]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s2:(SLDconst x2:(MOVBZload [i3] {s} p mem) [32]) o0:(OR <t> s1:(SLDconst x1:(MOVBZload [i2] {s} p mem) [40]) s0:(SLDconst x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [48])))
+	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (SLDconst <t> (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s2 := v.Args[0]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 32 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x2.AuxInt
+		s := x2.Aux
+		_ = x2.Args[1]
+		p := x2.Args[0]
+		mem := x2.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s1 := o0.Args[0]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 40 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		s0 := o0.Args[1]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 48 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x0.Type != t {
+			break
+		}
+		_ = x0.Args[1]
+		x0_0 := x0.Args[0]
+		if x0_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x0_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x0_0.AuxInt
+		if x0_0.Aux != s {
+			break
+		}
+		if p != x0_0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64SLDconst, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = 32
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v2 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v2.AuxInt = i0
+		v2.Aux = s
+		v2.AddArg(p)
+		v1.AddArg(v2)
+		v1.AddArg(mem)
+		v0.AddArg(v1)
+		return true
+	}
+	// match: (OR <t> s2:(SLDconst x2:(MOVBZload [i3] {s} p mem) [32]) o0:(OR <t> s0:(SLDconst x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [48]) s1:(SLDconst x1:(MOVBZload [i2] {s} p mem) [40])))
+	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (SLDconst <t> (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s2 := v.Args[0]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 32 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x2.AuxInt
+		s := x2.Aux
+		_ = x2.Args[1]
+		p := x2.Args[0]
+		mem := x2.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s0 := o0.Args[0]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 48 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x0.Type != t {
+			break
+		}
+		_ = x0.Args[1]
+		x0_0 := x0.Args[0]
+		if x0_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x0_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x0_0.AuxInt
+		if x0_0.Aux != s {
+			break
+		}
+		if p != x0_0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s1 := o0.Args[1]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 40 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64SLDconst, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = 32
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v2 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v2.AuxInt = i0
+		v2.Aux = s
+		v2.AddArg(p)
+		v1.AddArg(v2)
+		v1.AddArg(mem)
+		v0.AddArg(v1)
+		return true
+	}
+	return false
+}
+func rewriteValuePPC64_OpPPC64OR_50(v *Value) bool {
+	b := v.Block
+	_ = b
+	config := b.Func.Config
+	_ = config
+	typ := &b.Func.Config.Types
+	_ = typ
+	// match: (OR <t> o0:(OR <t> s1:(SLDconst x1:(MOVBZload [i2] {s} p mem) [40]) s0:(SLDconst x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [48])) s2:(SLDconst x2:(MOVBZload [i3] {s} p mem) [32]))
+	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (SLDconst <t> (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s1 := o0.Args[0]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 40 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x1.AuxInt
+		s := x1.Aux
+		_ = x1.Args[1]
+		p := x1.Args[0]
+		mem := x1.Args[1]
+		s0 := o0.Args[1]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 48 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x0.Type != t {
+			break
+		}
+		_ = x0.Args[1]
+		x0_0 := x0.Args[0]
+		if x0_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x0_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x0_0.AuxInt
+		if x0_0.Aux != s {
+			break
+		}
+		if p != x0_0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s2 := v.Args[1]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 32 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64SLDconst, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = 32
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v2 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v2.AuxInt = i0
+		v2.Aux = s
+		v2.AddArg(p)
+		v1.AddArg(v2)
+		v1.AddArg(mem)
+		v0.AddArg(v1)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> s0:(SLDconst x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [48]) s1:(SLDconst x1:(MOVBZload [i2] {s} p mem) [40])) s2:(SLDconst x2:(MOVBZload [i3] {s} p mem) [32]))
+	// cond: !config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (SLDconst <t> (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s0 := o0.Args[0]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 48 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x0.Type != t {
+			break
+		}
+		_ = x0.Args[1]
+		x0_0 := x0.Args[0]
+		if x0_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x0_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x0_0.AuxInt
+		s := x0_0.Aux
+		p := x0_0.Args[0]
+		mem := x0.Args[1]
+		s1 := o0.Args[1]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 40 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		s2 := v.Args[1]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 32 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64SLDconst, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = 32
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v2 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v2.AuxInt = i0
+		v2.Aux = s
+		v2.AddArg(p)
+		v1.AddArg(v2)
+		v1.AddArg(mem)
+		v0.AddArg(v1)
+		return true
+	}
+	// match: (OR <t> s2:(SLDconst x2:(MOVBZload [i0] {s} p mem) [56]) o0:(OR <t> s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48]) s0:(SLDconst x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i2] {s} p) mem) [32])))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (SLDconst <t> (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s2 := v.Args[0]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 56 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x2.AuxInt
+		s := x2.Aux
+		_ = x2.Args[1]
+		p := x2.Args[0]
+		mem := x2.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s1 := o0.Args[0]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		s0 := o0.Args[1]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x0.Type != t {
+			break
+		}
+		_ = x0.Args[1]
+		x0_0 := x0.Args[0]
+		if x0_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x0_0.Type != typ.Uintptr {
+			break
+		}
+		i2 := x0_0.AuxInt
+		if x0_0.Aux != s {
+			break
+		}
+		if p != x0_0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64SLDconst, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = 32
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v2 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v2.AuxInt = i0
+		v2.Aux = s
+		v2.AddArg(p)
+		v1.AddArg(v2)
+		v1.AddArg(mem)
+		v0.AddArg(v1)
+		return true
+	}
+	// match: (OR <t> s2:(SLDconst x2:(MOVBZload [i0] {s} p mem) [56]) o0:(OR <t> s0:(SLDconst x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i2] {s} p) mem) [32]) s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48])))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (SLDconst <t> (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s2 := v.Args[0]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 56 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x2.AuxInt
+		s := x2.Aux
+		_ = x2.Args[1]
+		p := x2.Args[0]
+		mem := x2.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s0 := o0.Args[0]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x0.Type != t {
+			break
+		}
+		_ = x0.Args[1]
+		x0_0 := x0.Args[0]
+		if x0_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x0_0.Type != typ.Uintptr {
+			break
+		}
+		i2 := x0_0.AuxInt
+		if x0_0.Aux != s {
+			break
+		}
+		if p != x0_0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s1 := o0.Args[1]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64SLDconst, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = 32
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v2 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v2.AuxInt = i0
+		v2.Aux = s
+		v2.AddArg(p)
+		v1.AddArg(v2)
+		v1.AddArg(mem)
+		v0.AddArg(v1)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48]) s0:(SLDconst x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i2] {s} p) mem) [32])) s2:(SLDconst x2:(MOVBZload [i0] {s} p mem) [56]))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (SLDconst <t> (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s1 := o0.Args[0]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		s := x1.Aux
+		_ = x1.Args[1]
+		p := x1.Args[0]
+		mem := x1.Args[1]
+		s0 := o0.Args[1]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x0.Type != t {
+			break
+		}
+		_ = x0.Args[1]
+		x0_0 := x0.Args[0]
+		if x0_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x0_0.Type != typ.Uintptr {
+			break
+		}
+		i2 := x0_0.AuxInt
+		if x0_0.Aux != s {
+			break
+		}
+		if p != x0_0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s2 := v.Args[1]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 56 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64SLDconst, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = 32
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v2 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v2.AuxInt = i0
+		v2.Aux = s
+		v2.AddArg(p)
+		v1.AddArg(v2)
+		v1.AddArg(mem)
+		v0.AddArg(v1)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> s0:(SLDconst x0:(MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i2] {s} p) mem) [32]) s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48])) s2:(SLDconst x2:(MOVBZload [i0] {s} p mem) [56]))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(o0)
+	// result: @mergePoint(b,x0,x1,x2) (SLDconst <t> (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s0 := o0.Args[0]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVHBRload {
+			break
+		}
+		if x0.Type != t {
+			break
+		}
+		_ = x0.Args[1]
+		x0_0 := x0.Args[0]
+		if x0_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x0_0.Type != typ.Uintptr {
+			break
+		}
+		i2 := x0_0.AuxInt
+		s := x0_0.Aux
+		p := x0_0.Args[0]
+		mem := x0.Args[1]
+		s1 := o0.Args[1]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		s2 := v.Args[1]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 56 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(o0)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2)
+		v0 := b.NewValue0(v.Pos, OpPPC64SLDconst, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = 32
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVWBRload, t)
+		v2 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v2.AuxInt = i0
+		v2.Aux = s
+		v2.AddArg(p)
+		v1.AddArg(v2)
+		v1.AddArg(mem)
+		v0.AddArg(v1)
+		return true
+	}
+	// match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) x0:(MOVWZload {s} [i0] p mem)))))
+	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
+	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s6 := v.Args[0]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 56 {
+			break
+		}
+		x7 := s6.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		s := x7.Aux
+		_ = x7.Args[1]
+		p := x7.Args[0]
+		mem := x7.Args[1]
+		o5 := v.Args[1]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		s5 := o5.Args[0]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 48 {
+			break
+		}
+		x6 := s5.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		o4 := o5.Args[1]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		s4 := o4.Args[0]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 40 {
+			break
+		}
+		x5 := s4.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		o3 := o4.Args[1]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s3 := o3.Args[0]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x4 := s3.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		x0 := o3.Args[1]
+		if x0.Op != OpPPC64MOVWZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+			break
+		}
+		b = mergePoint(b, x0, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> x0:(MOVWZload {s} [i0] p mem) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))))
+	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
+	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s6 := v.Args[0]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 56 {
+			break
+		}
+		x7 := s6.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		s := x7.Aux
+		_ = x7.Args[1]
+		p := x7.Args[0]
+		mem := x7.Args[1]
+		o5 := v.Args[1]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		s5 := o5.Args[0]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 48 {
+			break
+		}
+		x6 := s5.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		o4 := o5.Args[1]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		s4 := o4.Args[0]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 40 {
+			break
+		}
+		x5 := s4.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		o3 := o4.Args[1]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		x0 := o3.Args[0]
+		if x0.Op != OpPPC64MOVWZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s3 := o3.Args[1]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x4 := s3.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+			break
+		}
+		b = mergePoint(b, x0, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) x0:(MOVWZload {s} [i0] p mem)) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
+	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
+	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s6 := v.Args[0]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 56 {
+			break
+		}
+		x7 := s6.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		s := x7.Aux
+		_ = x7.Args[1]
+		p := x7.Args[0]
+		mem := x7.Args[1]
+		o5 := v.Args[1]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		s5 := o5.Args[0]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 48 {
+			break
+		}
+		x6 := s5.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		o4 := o5.Args[1]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		o3 := o4.Args[0]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s3 := o3.Args[0]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x4 := s3.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		x0 := o3.Args[1]
+		if x0.Op != OpPPC64MOVWZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s4 := o4.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 40 {
+			break
+		}
+		x5 := s4.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+			break
+		}
+		b = mergePoint(b, x0, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> x0:(MOVWZload {s} [i0] p mem) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
+	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
+	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s6 := v.Args[0]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 56 {
+			break
+		}
+		x7 := s6.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		s := x7.Aux
+		_ = x7.Args[1]
+		p := x7.Args[0]
+		mem := x7.Args[1]
+		o5 := v.Args[1]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		s5 := o5.Args[0]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 48 {
+			break
+		}
+		x6 := s5.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		o4 := o5.Args[1]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		o3 := o4.Args[0]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		x0 := o3.Args[0]
+		if x0.Op != OpPPC64MOVWZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s3 := o3.Args[1]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x4 := s3.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s4 := o4.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 40 {
+			break
+		}
+		x5 := s4.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+			break
+		}
+		b = mergePoint(b, x0, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	return false
+}
+func rewriteValuePPC64_OpPPC64OR_60(v *Value) bool {
+	b := v.Block
+	_ = b
+	config := b.Func.Config
+	_ = config
+	// match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) x0:(MOVWZload {s} [i0] p mem))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
+	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
+	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s6 := v.Args[0]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 56 {
+			break
+		}
+		x7 := s6.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		s := x7.Aux
+		_ = x7.Args[1]
+		p := x7.Args[0]
+		mem := x7.Args[1]
+		o5 := v.Args[1]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		o4 := o5.Args[0]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		s4 := o4.Args[0]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 40 {
+			break
+		}
+		x5 := s4.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		o3 := o4.Args[1]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s3 := o3.Args[0]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x4 := s3.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		x0 := o3.Args[1]
+		if x0.Op != OpPPC64MOVWZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s5 := o5.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 48 {
+			break
+		}
+		x6 := s5.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+			break
+		}
+		b = mergePoint(b, x0, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> x0:(MOVWZload {s} [i0] p mem) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
+	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
+	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s6 := v.Args[0]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 56 {
+			break
+		}
+		x7 := s6.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		s := x7.Aux
+		_ = x7.Args[1]
+		p := x7.Args[0]
+		mem := x7.Args[1]
+		o5 := v.Args[1]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		o4 := o5.Args[0]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		s4 := o4.Args[0]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 40 {
+			break
+		}
+		x5 := s4.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		o3 := o4.Args[1]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		x0 := o3.Args[0]
+		if x0.Op != OpPPC64MOVWZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s3 := o3.Args[1]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x4 := s3.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s5 := o5.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 48 {
+			break
+		}
+		x6 := s5.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+			break
+		}
+		b = mergePoint(b, x0, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) x0:(MOVWZload {s} [i0] p mem)) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
+	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
+	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s6 := v.Args[0]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 56 {
+			break
+		}
+		x7 := s6.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		s := x7.Aux
+		_ = x7.Args[1]
+		p := x7.Args[0]
+		mem := x7.Args[1]
+		o5 := v.Args[1]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		o4 := o5.Args[0]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		o3 := o4.Args[0]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s3 := o3.Args[0]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x4 := s3.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		x0 := o3.Args[1]
+		if x0.Op != OpPPC64MOVWZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s4 := o4.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 40 {
+			break
+		}
+		x5 := s4.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		s5 := o5.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 48 {
+			break
+		}
+		x6 := s5.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+			break
+		}
+		b = mergePoint(b, x0, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> x0:(MOVWZload {s} [i0] p mem) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
+	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
+	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s6 := v.Args[0]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 56 {
+			break
+		}
+		x7 := s6.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		s := x7.Aux
+		_ = x7.Args[1]
+		p := x7.Args[0]
+		mem := x7.Args[1]
+		o5 := v.Args[1]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		o4 := o5.Args[0]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		o3 := o4.Args[0]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		x0 := o3.Args[0]
+		if x0.Op != OpPPC64MOVWZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s3 := o3.Args[1]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x4 := s3.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s4 := o4.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 40 {
+			break
+		}
+		x5 := s4.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		s5 := o5.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 48 {
+			break
+		}
+		x6 := s5.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+			break
+		}
+		b = mergePoint(b, x0, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) x0:(MOVWZload {s} [i0] p mem)))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
+	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
+	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o5 := v.Args[0]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		s5 := o5.Args[0]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 48 {
+			break
+		}
+		x6 := s5.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		s := x6.Aux
+		_ = x6.Args[1]
+		p := x6.Args[0]
+		mem := x6.Args[1]
+		o4 := o5.Args[1]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		s4 := o4.Args[0]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 40 {
+			break
+		}
+		x5 := s4.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		o3 := o4.Args[1]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s3 := o3.Args[0]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x4 := s3.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		x0 := o3.Args[1]
+		if x0.Op != OpPPC64MOVWZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s6 := v.Args[1]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 56 {
+			break
+		}
+		x7 := s6.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		if x7.Aux != s {
+			break
+		}
+		_ = x7.Args[1]
+		if p != x7.Args[0] {
+			break
+		}
+		if mem != x7.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+			break
+		}
+		b = mergePoint(b, x0, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> x0:(MOVWZload {s} [i0] p mem) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
+	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
+	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o5 := v.Args[0]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		s5 := o5.Args[0]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 48 {
+			break
+		}
+		x6 := s5.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		s := x6.Aux
+		_ = x6.Args[1]
+		p := x6.Args[0]
+		mem := x6.Args[1]
+		o4 := o5.Args[1]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		s4 := o4.Args[0]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 40 {
+			break
+		}
+		x5 := s4.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		o3 := o4.Args[1]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		x0 := o3.Args[0]
+		if x0.Op != OpPPC64MOVWZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s3 := o3.Args[1]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x4 := s3.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s6 := v.Args[1]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 56 {
+			break
+		}
+		x7 := s6.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		if x7.Aux != s {
+			break
+		}
+		_ = x7.Args[1]
+		if p != x7.Args[0] {
+			break
+		}
+		if mem != x7.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+			break
+		}
+		b = mergePoint(b, x0, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) x0:(MOVWZload {s} [i0] p mem)) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
+	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
+	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o5 := v.Args[0]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		s5 := o5.Args[0]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 48 {
+			break
+		}
+		x6 := s5.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		s := x6.Aux
+		_ = x6.Args[1]
+		p := x6.Args[0]
+		mem := x6.Args[1]
+		o4 := o5.Args[1]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		o3 := o4.Args[0]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s3 := o3.Args[0]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x4 := s3.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		x0 := o3.Args[1]
+		if x0.Op != OpPPC64MOVWZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s4 := o4.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 40 {
+			break
+		}
+		x5 := s4.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		s6 := v.Args[1]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 56 {
+			break
+		}
+		x7 := s6.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		if x7.Aux != s {
+			break
+		}
+		_ = x7.Args[1]
+		if p != x7.Args[0] {
+			break
+		}
+		if mem != x7.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+			break
+		}
+		b = mergePoint(b, x0, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> x0:(MOVWZload {s} [i0] p mem) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
+	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
+	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o5 := v.Args[0]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		s5 := o5.Args[0]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 48 {
+			break
+		}
+		x6 := s5.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		s := x6.Aux
+		_ = x6.Args[1]
+		p := x6.Args[0]
+		mem := x6.Args[1]
+		o4 := o5.Args[1]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		o3 := o4.Args[0]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		x0 := o3.Args[0]
+		if x0.Op != OpPPC64MOVWZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s3 := o3.Args[1]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x4 := s3.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s4 := o4.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 40 {
+			break
+		}
+		x5 := s4.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		s6 := v.Args[1]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 56 {
+			break
+		}
+		x7 := s6.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		if x7.Aux != s {
+			break
+		}
+		_ = x7.Args[1]
+		if p != x7.Args[0] {
+			break
+		}
+		if mem != x7.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+			break
+		}
+		b = mergePoint(b, x0, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) x0:(MOVWZload {s} [i0] p mem))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
+	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
+	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o5 := v.Args[0]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		o4 := o5.Args[0]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		s4 := o4.Args[0]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 40 {
+			break
+		}
+		x5 := s4.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		s := x5.Aux
+		_ = x5.Args[1]
+		p := x5.Args[0]
+		mem := x5.Args[1]
+		o3 := o4.Args[1]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s3 := o3.Args[0]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x4 := s3.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		x0 := o3.Args[1]
+		if x0.Op != OpPPC64MOVWZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s5 := o5.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 48 {
+			break
+		}
+		x6 := s5.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		s6 := v.Args[1]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 56 {
+			break
+		}
+		x7 := s6.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		if x7.Aux != s {
+			break
+		}
+		_ = x7.Args[1]
+		if p != x7.Args[0] {
+			break
+		}
+		if mem != x7.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+			break
+		}
+		b = mergePoint(b, x0, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> x0:(MOVWZload {s} [i0] p mem) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
+	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
+	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o5 := v.Args[0]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		o4 := o5.Args[0]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		s4 := o4.Args[0]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 40 {
+			break
+		}
+		x5 := s4.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		s := x5.Aux
+		_ = x5.Args[1]
+		p := x5.Args[0]
+		mem := x5.Args[1]
+		o3 := o4.Args[1]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		x0 := o3.Args[0]
+		if x0.Op != OpPPC64MOVWZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s3 := o3.Args[1]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x4 := s3.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s5 := o5.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 48 {
+			break
+		}
+		x6 := s5.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		s6 := v.Args[1]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 56 {
+			break
+		}
+		x7 := s6.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		if x7.Aux != s {
+			break
+		}
+		_ = x7.Args[1]
+		if p != x7.Args[0] {
+			break
+		}
+		if mem != x7.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+			break
+		}
+		b = mergePoint(b, x0, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	return false
+}
+func rewriteValuePPC64_OpPPC64OR_70(v *Value) bool {
+	b := v.Block
+	_ = b
+	config := b.Func.Config
+	_ = config
+	typ := &b.Func.Config.Types
+	_ = typ
+	// match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) x0:(MOVWZload {s} [i0] p mem)) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
+	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
+	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o5 := v.Args[0]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		o4 := o5.Args[0]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		o3 := o4.Args[0]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s3 := o3.Args[0]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x4 := s3.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		s := x4.Aux
+		_ = x4.Args[1]
+		p := x4.Args[0]
+		mem := x4.Args[1]
+		x0 := o3.Args[1]
+		if x0.Op != OpPPC64MOVWZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		s4 := o4.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 40 {
+			break
+		}
+		x5 := s4.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		s5 := o5.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 48 {
+			break
+		}
+		x6 := s5.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		s6 := v.Args[1]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 56 {
+			break
+		}
+		x7 := s6.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		if x7.Aux != s {
+			break
+		}
+		_ = x7.Args[1]
+		if p != x7.Args[0] {
+			break
+		}
+		if mem != x7.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+			break
+		}
+		b = mergePoint(b, x0, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> x0:(MOVWZload {s} [i0] p mem) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
+	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
+	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o5 := v.Args[0]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		o4 := o5.Args[0]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		o3 := o4.Args[0]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		x0 := o3.Args[0]
+		if x0.Op != OpPPC64MOVWZload {
+			break
+		}
+		i0 := x0.AuxInt
+		s := x0.Aux
+		_ = x0.Args[1]
+		p := x0.Args[0]
+		mem := x0.Args[1]
+		s3 := o3.Args[1]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x4 := s3.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s4 := o4.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 40 {
+			break
+		}
+		x5 := s4.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		s5 := o5.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 48 {
+			break
+		}
+		x6 := s5.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		s6 := v.Args[1]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 56 {
 			break
 		}
 		x7 := s6.Args[0]
@@ -10648,6 +16114,4883 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 			break
 		}
 		i7 := x7.AuxInt
+		if x7.Aux != s {
+			break
+		}
+		_ = x7.Args[1]
+		if p != x7.Args[0] {
+			break
+		}
+		if mem != x7.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+			break
+		}
+		b = mergePoint(b, x0, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v0.AuxInt = i0
+		v0.Aux = s
+		v0.AddArg(p)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s0:(SLDconst x0:(MOVBZload [i0] {s} p mem) [56]) o0:(OR <t> s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48]) o1:(OR <t> s2:(SLDconst x2:(MOVBZload [i2] {s} p mem) [40]) o2:(OR <t> s3:(SLDconst x3:(MOVBZload [i3] {s} p mem) [32]) x4:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i4] p) mem)))))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)
+	// result: @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s0 := v.Args[0]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 56 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x0.AuxInt
+		s := x0.Aux
+		_ = x0.Args[1]
+		p := x0.Args[0]
+		mem := x0.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s1 := o0.Args[0]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		o1 := o0.Args[1]
+		if o1.Op != OpPPC64OR {
+			break
+		}
+		if o1.Type != t {
+			break
+		}
+		_ = o1.Args[1]
+		s2 := o1.Args[0]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 40 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		o2 := o1.Args[1]
+		if o2.Op != OpPPC64OR {
+			break
+		}
+		if o2.Type != t {
+			break
+		}
+		_ = o2.Args[1]
+		s3 := o2.Args[0]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x3 := s3.Args[0]
+		if x3.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x3.AuxInt
+		if x3.Aux != s {
+			break
+		}
+		_ = x3.Args[1]
+		if p != x3.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		x4 := o2.Args[1]
+		if x4.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x4.Type != t {
+			break
+		}
+		_ = x4.Args[1]
+		x4_0 := x4.Args[0]
+		if x4_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x4_0.Type != typ.Uintptr {
+			break
+		}
+		i4 := x4_0.AuxInt
+		if p != x4_0.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2, x3, x4)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s0:(SLDconst x0:(MOVBZload [i0] {s} p mem) [56]) o0:(OR <t> s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48]) o1:(OR <t> s2:(SLDconst x2:(MOVBZload [i2] {s} p mem) [40]) o2:(OR <t> x4:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i4] p) mem) s3:(SLDconst x3:(MOVBZload [i3] {s} p mem) [32])))))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)
+	// result: @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s0 := v.Args[0]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 56 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x0.AuxInt
+		s := x0.Aux
+		_ = x0.Args[1]
+		p := x0.Args[0]
+		mem := x0.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s1 := o0.Args[0]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		o1 := o0.Args[1]
+		if o1.Op != OpPPC64OR {
+			break
+		}
+		if o1.Type != t {
+			break
+		}
+		_ = o1.Args[1]
+		s2 := o1.Args[0]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 40 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		o2 := o1.Args[1]
+		if o2.Op != OpPPC64OR {
+			break
+		}
+		if o2.Type != t {
+			break
+		}
+		_ = o2.Args[1]
+		x4 := o2.Args[0]
+		if x4.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x4.Type != t {
+			break
+		}
+		_ = x4.Args[1]
+		x4_0 := x4.Args[0]
+		if x4_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x4_0.Type != typ.Uintptr {
+			break
+		}
+		i4 := x4_0.AuxInt
+		if p != x4_0.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s3 := o2.Args[1]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x3 := s3.Args[0]
+		if x3.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x3.AuxInt
+		if x3.Aux != s {
+			break
+		}
+		_ = x3.Args[1]
+		if p != x3.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2, x3, x4)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s0:(SLDconst x0:(MOVBZload [i0] {s} p mem) [56]) o0:(OR <t> s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48]) o1:(OR <t> o2:(OR <t> s3:(SLDconst x3:(MOVBZload [i3] {s} p mem) [32]) x4:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i4] p) mem)) s2:(SLDconst x2:(MOVBZload [i2] {s} p mem) [40]))))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)
+	// result: @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s0 := v.Args[0]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 56 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x0.AuxInt
+		s := x0.Aux
+		_ = x0.Args[1]
+		p := x0.Args[0]
+		mem := x0.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s1 := o0.Args[0]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		o1 := o0.Args[1]
+		if o1.Op != OpPPC64OR {
+			break
+		}
+		if o1.Type != t {
+			break
+		}
+		_ = o1.Args[1]
+		o2 := o1.Args[0]
+		if o2.Op != OpPPC64OR {
+			break
+		}
+		if o2.Type != t {
+			break
+		}
+		_ = o2.Args[1]
+		s3 := o2.Args[0]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x3 := s3.Args[0]
+		if x3.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x3.AuxInt
+		if x3.Aux != s {
+			break
+		}
+		_ = x3.Args[1]
+		if p != x3.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		x4 := o2.Args[1]
+		if x4.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x4.Type != t {
+			break
+		}
+		_ = x4.Args[1]
+		x4_0 := x4.Args[0]
+		if x4_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x4_0.Type != typ.Uintptr {
+			break
+		}
+		i4 := x4_0.AuxInt
+		if p != x4_0.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s2 := o1.Args[1]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 40 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2, x3, x4)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s0:(SLDconst x0:(MOVBZload [i0] {s} p mem) [56]) o0:(OR <t> s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48]) o1:(OR <t> o2:(OR <t> x4:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i4] p) mem) s3:(SLDconst x3:(MOVBZload [i3] {s} p mem) [32])) s2:(SLDconst x2:(MOVBZload [i2] {s} p mem) [40]))))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)
+	// result: @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s0 := v.Args[0]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 56 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x0.AuxInt
+		s := x0.Aux
+		_ = x0.Args[1]
+		p := x0.Args[0]
+		mem := x0.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s1 := o0.Args[0]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		o1 := o0.Args[1]
+		if o1.Op != OpPPC64OR {
+			break
+		}
+		if o1.Type != t {
+			break
+		}
+		_ = o1.Args[1]
+		o2 := o1.Args[0]
+		if o2.Op != OpPPC64OR {
+			break
+		}
+		if o2.Type != t {
+			break
+		}
+		_ = o2.Args[1]
+		x4 := o2.Args[0]
+		if x4.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x4.Type != t {
+			break
+		}
+		_ = x4.Args[1]
+		x4_0 := x4.Args[0]
+		if x4_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x4_0.Type != typ.Uintptr {
+			break
+		}
+		i4 := x4_0.AuxInt
+		if p != x4_0.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s3 := o2.Args[1]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x3 := s3.Args[0]
+		if x3.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x3.AuxInt
+		if x3.Aux != s {
+			break
+		}
+		_ = x3.Args[1]
+		if p != x3.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s2 := o1.Args[1]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 40 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2, x3, x4)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s0:(SLDconst x0:(MOVBZload [i0] {s} p mem) [56]) o0:(OR <t> o1:(OR <t> s2:(SLDconst x2:(MOVBZload [i2] {s} p mem) [40]) o2:(OR <t> s3:(SLDconst x3:(MOVBZload [i3] {s} p mem) [32]) x4:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i4] p) mem))) s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48])))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)
+	// result: @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s0 := v.Args[0]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 56 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x0.AuxInt
+		s := x0.Aux
+		_ = x0.Args[1]
+		p := x0.Args[0]
+		mem := x0.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		o1 := o0.Args[0]
+		if o1.Op != OpPPC64OR {
+			break
+		}
+		if o1.Type != t {
+			break
+		}
+		_ = o1.Args[1]
+		s2 := o1.Args[0]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 40 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		o2 := o1.Args[1]
+		if o2.Op != OpPPC64OR {
+			break
+		}
+		if o2.Type != t {
+			break
+		}
+		_ = o2.Args[1]
+		s3 := o2.Args[0]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x3 := s3.Args[0]
+		if x3.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x3.AuxInt
+		if x3.Aux != s {
+			break
+		}
+		_ = x3.Args[1]
+		if p != x3.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		x4 := o2.Args[1]
+		if x4.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x4.Type != t {
+			break
+		}
+		_ = x4.Args[1]
+		x4_0 := x4.Args[0]
+		if x4_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x4_0.Type != typ.Uintptr {
+			break
+		}
+		i4 := x4_0.AuxInt
+		if p != x4_0.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s1 := o0.Args[1]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2, x3, x4)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s0:(SLDconst x0:(MOVBZload [i0] {s} p mem) [56]) o0:(OR <t> o1:(OR <t> s2:(SLDconst x2:(MOVBZload [i2] {s} p mem) [40]) o2:(OR <t> x4:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i4] p) mem) s3:(SLDconst x3:(MOVBZload [i3] {s} p mem) [32]))) s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48])))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)
+	// result: @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s0 := v.Args[0]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 56 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x0.AuxInt
+		s := x0.Aux
+		_ = x0.Args[1]
+		p := x0.Args[0]
+		mem := x0.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		o1 := o0.Args[0]
+		if o1.Op != OpPPC64OR {
+			break
+		}
+		if o1.Type != t {
+			break
+		}
+		_ = o1.Args[1]
+		s2 := o1.Args[0]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 40 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		o2 := o1.Args[1]
+		if o2.Op != OpPPC64OR {
+			break
+		}
+		if o2.Type != t {
+			break
+		}
+		_ = o2.Args[1]
+		x4 := o2.Args[0]
+		if x4.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x4.Type != t {
+			break
+		}
+		_ = x4.Args[1]
+		x4_0 := x4.Args[0]
+		if x4_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x4_0.Type != typ.Uintptr {
+			break
+		}
+		i4 := x4_0.AuxInt
+		if p != x4_0.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s3 := o2.Args[1]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x3 := s3.Args[0]
+		if x3.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x3.AuxInt
+		if x3.Aux != s {
+			break
+		}
+		_ = x3.Args[1]
+		if p != x3.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s1 := o0.Args[1]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2, x3, x4)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s0:(SLDconst x0:(MOVBZload [i0] {s} p mem) [56]) o0:(OR <t> o1:(OR <t> o2:(OR <t> s3:(SLDconst x3:(MOVBZload [i3] {s} p mem) [32]) x4:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i4] p) mem)) s2:(SLDconst x2:(MOVBZload [i2] {s} p mem) [40])) s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48])))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)
+	// result: @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s0 := v.Args[0]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 56 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x0.AuxInt
+		s := x0.Aux
+		_ = x0.Args[1]
+		p := x0.Args[0]
+		mem := x0.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		o1 := o0.Args[0]
+		if o1.Op != OpPPC64OR {
+			break
+		}
+		if o1.Type != t {
+			break
+		}
+		_ = o1.Args[1]
+		o2 := o1.Args[0]
+		if o2.Op != OpPPC64OR {
+			break
+		}
+		if o2.Type != t {
+			break
+		}
+		_ = o2.Args[1]
+		s3 := o2.Args[0]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x3 := s3.Args[0]
+		if x3.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x3.AuxInt
+		if x3.Aux != s {
+			break
+		}
+		_ = x3.Args[1]
+		if p != x3.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		x4 := o2.Args[1]
+		if x4.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x4.Type != t {
+			break
+		}
+		_ = x4.Args[1]
+		x4_0 := x4.Args[0]
+		if x4_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x4_0.Type != typ.Uintptr {
+			break
+		}
+		i4 := x4_0.AuxInt
+		if p != x4_0.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s2 := o1.Args[1]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 40 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		s1 := o0.Args[1]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2, x3, x4)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> s0:(SLDconst x0:(MOVBZload [i0] {s} p mem) [56]) o0:(OR <t> o1:(OR <t> o2:(OR <t> x4:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i4] p) mem) s3:(SLDconst x3:(MOVBZload [i3] {s} p mem) [32])) s2:(SLDconst x2:(MOVBZload [i2] {s} p mem) [40])) s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48])))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)
+	// result: @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		s0 := v.Args[0]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 56 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x0.AuxInt
+		s := x0.Aux
+		_ = x0.Args[1]
+		p := x0.Args[0]
+		mem := x0.Args[1]
+		o0 := v.Args[1]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		o1 := o0.Args[0]
+		if o1.Op != OpPPC64OR {
+			break
+		}
+		if o1.Type != t {
+			break
+		}
+		_ = o1.Args[1]
+		o2 := o1.Args[0]
+		if o2.Op != OpPPC64OR {
+			break
+		}
+		if o2.Type != t {
+			break
+		}
+		_ = o2.Args[1]
+		x4 := o2.Args[0]
+		if x4.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x4.Type != t {
+			break
+		}
+		_ = x4.Args[1]
+		x4_0 := x4.Args[0]
+		if x4_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x4_0.Type != typ.Uintptr {
+			break
+		}
+		i4 := x4_0.AuxInt
+		if p != x4_0.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s3 := o2.Args[1]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x3 := s3.Args[0]
+		if x3.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x3.AuxInt
+		if x3.Aux != s {
+			break
+		}
+		_ = x3.Args[1]
+		if p != x3.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s2 := o1.Args[1]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 40 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		s1 := o0.Args[1]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2, x3, x4)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	return false
+}
+func rewriteValuePPC64_OpPPC64OR_80(v *Value) bool {
+	b := v.Block
+	_ = b
+	config := b.Func.Config
+	_ = config
+	typ := &b.Func.Config.Types
+	_ = typ
+	// match: (OR <t> o0:(OR <t> s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48]) o1:(OR <t> s2:(SLDconst x2:(MOVBZload [i2] {s} p mem) [40]) o2:(OR <t> s3:(SLDconst x3:(MOVBZload [i3] {s} p mem) [32]) x4:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i4] p) mem)))) s0:(SLDconst x0:(MOVBZload [i0] {s} p mem) [56]))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)
+	// result: @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s1 := o0.Args[0]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		s := x1.Aux
+		_ = x1.Args[1]
+		p := x1.Args[0]
+		mem := x1.Args[1]
+		o1 := o0.Args[1]
+		if o1.Op != OpPPC64OR {
+			break
+		}
+		if o1.Type != t {
+			break
+		}
+		_ = o1.Args[1]
+		s2 := o1.Args[0]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 40 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		o2 := o1.Args[1]
+		if o2.Op != OpPPC64OR {
+			break
+		}
+		if o2.Type != t {
+			break
+		}
+		_ = o2.Args[1]
+		s3 := o2.Args[0]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x3 := s3.Args[0]
+		if x3.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x3.AuxInt
+		if x3.Aux != s {
+			break
+		}
+		_ = x3.Args[1]
+		if p != x3.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		x4 := o2.Args[1]
+		if x4.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x4.Type != t {
+			break
+		}
+		_ = x4.Args[1]
+		x4_0 := x4.Args[0]
+		if x4_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x4_0.Type != typ.Uintptr {
+			break
+		}
+		i4 := x4_0.AuxInt
+		if p != x4_0.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s0 := v.Args[1]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 56 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2, x3, x4)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48]) o1:(OR <t> s2:(SLDconst x2:(MOVBZload [i2] {s} p mem) [40]) o2:(OR <t> x4:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i4] p) mem) s3:(SLDconst x3:(MOVBZload [i3] {s} p mem) [32])))) s0:(SLDconst x0:(MOVBZload [i0] {s} p mem) [56]))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)
+	// result: @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s1 := o0.Args[0]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		s := x1.Aux
+		_ = x1.Args[1]
+		p := x1.Args[0]
+		mem := x1.Args[1]
+		o1 := o0.Args[1]
+		if o1.Op != OpPPC64OR {
+			break
+		}
+		if o1.Type != t {
+			break
+		}
+		_ = o1.Args[1]
+		s2 := o1.Args[0]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 40 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		o2 := o1.Args[1]
+		if o2.Op != OpPPC64OR {
+			break
+		}
+		if o2.Type != t {
+			break
+		}
+		_ = o2.Args[1]
+		x4 := o2.Args[0]
+		if x4.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x4.Type != t {
+			break
+		}
+		_ = x4.Args[1]
+		x4_0 := x4.Args[0]
+		if x4_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x4_0.Type != typ.Uintptr {
+			break
+		}
+		i4 := x4_0.AuxInt
+		if p != x4_0.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s3 := o2.Args[1]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x3 := s3.Args[0]
+		if x3.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x3.AuxInt
+		if x3.Aux != s {
+			break
+		}
+		_ = x3.Args[1]
+		if p != x3.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s0 := v.Args[1]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 56 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2, x3, x4)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48]) o1:(OR <t> o2:(OR <t> s3:(SLDconst x3:(MOVBZload [i3] {s} p mem) [32]) x4:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i4] p) mem)) s2:(SLDconst x2:(MOVBZload [i2] {s} p mem) [40]))) s0:(SLDconst x0:(MOVBZload [i0] {s} p mem) [56]))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)
+	// result: @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s1 := o0.Args[0]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		s := x1.Aux
+		_ = x1.Args[1]
+		p := x1.Args[0]
+		mem := x1.Args[1]
+		o1 := o0.Args[1]
+		if o1.Op != OpPPC64OR {
+			break
+		}
+		if o1.Type != t {
+			break
+		}
+		_ = o1.Args[1]
+		o2 := o1.Args[0]
+		if o2.Op != OpPPC64OR {
+			break
+		}
+		if o2.Type != t {
+			break
+		}
+		_ = o2.Args[1]
+		s3 := o2.Args[0]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x3 := s3.Args[0]
+		if x3.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x3.AuxInt
+		if x3.Aux != s {
+			break
+		}
+		_ = x3.Args[1]
+		if p != x3.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		x4 := o2.Args[1]
+		if x4.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x4.Type != t {
+			break
+		}
+		_ = x4.Args[1]
+		x4_0 := x4.Args[0]
+		if x4_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x4_0.Type != typ.Uintptr {
+			break
+		}
+		i4 := x4_0.AuxInt
+		if p != x4_0.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s2 := o1.Args[1]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 40 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		s0 := v.Args[1]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 56 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2, x3, x4)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48]) o1:(OR <t> o2:(OR <t> x4:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i4] p) mem) s3:(SLDconst x3:(MOVBZload [i3] {s} p mem) [32])) s2:(SLDconst x2:(MOVBZload [i2] {s} p mem) [40]))) s0:(SLDconst x0:(MOVBZload [i0] {s} p mem) [56]))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)
+	// result: @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		s1 := o0.Args[0]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		s := x1.Aux
+		_ = x1.Args[1]
+		p := x1.Args[0]
+		mem := x1.Args[1]
+		o1 := o0.Args[1]
+		if o1.Op != OpPPC64OR {
+			break
+		}
+		if o1.Type != t {
+			break
+		}
+		_ = o1.Args[1]
+		o2 := o1.Args[0]
+		if o2.Op != OpPPC64OR {
+			break
+		}
+		if o2.Type != t {
+			break
+		}
+		_ = o2.Args[1]
+		x4 := o2.Args[0]
+		if x4.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x4.Type != t {
+			break
+		}
+		_ = x4.Args[1]
+		x4_0 := x4.Args[0]
+		if x4_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x4_0.Type != typ.Uintptr {
+			break
+		}
+		i4 := x4_0.AuxInt
+		if p != x4_0.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s3 := o2.Args[1]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x3 := s3.Args[0]
+		if x3.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x3.AuxInt
+		if x3.Aux != s {
+			break
+		}
+		_ = x3.Args[1]
+		if p != x3.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s2 := o1.Args[1]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 40 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		s0 := v.Args[1]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 56 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2, x3, x4)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> o1:(OR <t> s2:(SLDconst x2:(MOVBZload [i2] {s} p mem) [40]) o2:(OR <t> s3:(SLDconst x3:(MOVBZload [i3] {s} p mem) [32]) x4:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i4] p) mem))) s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48])) s0:(SLDconst x0:(MOVBZload [i0] {s} p mem) [56]))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)
+	// result: @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		o1 := o0.Args[0]
+		if o1.Op != OpPPC64OR {
+			break
+		}
+		if o1.Type != t {
+			break
+		}
+		_ = o1.Args[1]
+		s2 := o1.Args[0]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 40 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x2.AuxInt
+		s := x2.Aux
+		_ = x2.Args[1]
+		p := x2.Args[0]
+		mem := x2.Args[1]
+		o2 := o1.Args[1]
+		if o2.Op != OpPPC64OR {
+			break
+		}
+		if o2.Type != t {
+			break
+		}
+		_ = o2.Args[1]
+		s3 := o2.Args[0]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x3 := s3.Args[0]
+		if x3.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x3.AuxInt
+		if x3.Aux != s {
+			break
+		}
+		_ = x3.Args[1]
+		if p != x3.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		x4 := o2.Args[1]
+		if x4.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x4.Type != t {
+			break
+		}
+		_ = x4.Args[1]
+		x4_0 := x4.Args[0]
+		if x4_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x4_0.Type != typ.Uintptr {
+			break
+		}
+		i4 := x4_0.AuxInt
+		if p != x4_0.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s1 := o0.Args[1]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		s0 := v.Args[1]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 56 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2, x3, x4)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> o1:(OR <t> s2:(SLDconst x2:(MOVBZload [i2] {s} p mem) [40]) o2:(OR <t> x4:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i4] p) mem) s3:(SLDconst x3:(MOVBZload [i3] {s} p mem) [32]))) s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48])) s0:(SLDconst x0:(MOVBZload [i0] {s} p mem) [56]))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)
+	// result: @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		o1 := o0.Args[0]
+		if o1.Op != OpPPC64OR {
+			break
+		}
+		if o1.Type != t {
+			break
+		}
+		_ = o1.Args[1]
+		s2 := o1.Args[0]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 40 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x2.AuxInt
+		s := x2.Aux
+		_ = x2.Args[1]
+		p := x2.Args[0]
+		mem := x2.Args[1]
+		o2 := o1.Args[1]
+		if o2.Op != OpPPC64OR {
+			break
+		}
+		if o2.Type != t {
+			break
+		}
+		_ = o2.Args[1]
+		x4 := o2.Args[0]
+		if x4.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x4.Type != t {
+			break
+		}
+		_ = x4.Args[1]
+		x4_0 := x4.Args[0]
+		if x4_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x4_0.Type != typ.Uintptr {
+			break
+		}
+		i4 := x4_0.AuxInt
+		if p != x4_0.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s3 := o2.Args[1]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x3 := s3.Args[0]
+		if x3.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x3.AuxInt
+		if x3.Aux != s {
+			break
+		}
+		_ = x3.Args[1]
+		if p != x3.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s1 := o0.Args[1]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		s0 := v.Args[1]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 56 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2, x3, x4)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> o1:(OR <t> o2:(OR <t> s3:(SLDconst x3:(MOVBZload [i3] {s} p mem) [32]) x4:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i4] p) mem)) s2:(SLDconst x2:(MOVBZload [i2] {s} p mem) [40])) s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48])) s0:(SLDconst x0:(MOVBZload [i0] {s} p mem) [56]))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)
+	// result: @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		o1 := o0.Args[0]
+		if o1.Op != OpPPC64OR {
+			break
+		}
+		if o1.Type != t {
+			break
+		}
+		_ = o1.Args[1]
+		o2 := o1.Args[0]
+		if o2.Op != OpPPC64OR {
+			break
+		}
+		if o2.Type != t {
+			break
+		}
+		_ = o2.Args[1]
+		s3 := o2.Args[0]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x3 := s3.Args[0]
+		if x3.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x3.AuxInt
+		s := x3.Aux
+		_ = x3.Args[1]
+		p := x3.Args[0]
+		mem := x3.Args[1]
+		x4 := o2.Args[1]
+		if x4.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x4.Type != t {
+			break
+		}
+		_ = x4.Args[1]
+		x4_0 := x4.Args[0]
+		if x4_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x4_0.Type != typ.Uintptr {
+			break
+		}
+		i4 := x4_0.AuxInt
+		if p != x4_0.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s2 := o1.Args[1]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 40 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		s1 := o0.Args[1]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		s0 := v.Args[1]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 56 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2, x3, x4)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o0:(OR <t> o1:(OR <t> o2:(OR <t> x4:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i4] p) mem) s3:(SLDconst x3:(MOVBZload [i3] {s} p mem) [32])) s2:(SLDconst x2:(MOVBZload [i2] {s} p mem) [40])) s1:(SLDconst x1:(MOVBZload [i1] {s} p mem) [48])) s0:(SLDconst x0:(MOVBZload [i0] {s} p mem) [56]))
+	// cond: !config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)
+	// result: @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o0 := v.Args[0]
+		if o0.Op != OpPPC64OR {
+			break
+		}
+		if o0.Type != t {
+			break
+		}
+		_ = o0.Args[1]
+		o1 := o0.Args[0]
+		if o1.Op != OpPPC64OR {
+			break
+		}
+		if o1.Type != t {
+			break
+		}
+		_ = o1.Args[1]
+		o2 := o1.Args[0]
+		if o2.Op != OpPPC64OR {
+			break
+		}
+		if o2.Type != t {
+			break
+		}
+		_ = o2.Args[1]
+		x4 := o2.Args[0]
+		if x4.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x4.Type != t {
+			break
+		}
+		_ = x4.Args[1]
+		x4_0 := x4.Args[0]
+		if x4_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x4_0.Type != typ.Uintptr {
+			break
+		}
+		i4 := x4_0.AuxInt
+		p := x4_0.Args[0]
+		mem := x4.Args[1]
+		s3 := o2.Args[1]
+		if s3.Op != OpPPC64SLDconst {
+			break
+		}
+		if s3.AuxInt != 32 {
+			break
+		}
+		x3 := s3.Args[0]
+		if x3.Op != OpPPC64MOVBZload {
+			break
+		}
+		i3 := x3.AuxInt
+		s := x3.Aux
+		_ = x3.Args[1]
+		if p != x3.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s2 := o1.Args[1]
+		if s2.Op != OpPPC64SLDconst {
+			break
+		}
+		if s2.AuxInt != 40 {
+			break
+		}
+		x2 := s2.Args[0]
+		if x2.Op != OpPPC64MOVBZload {
+			break
+		}
+		i2 := x2.AuxInt
+		if x2.Aux != s {
+			break
+		}
+		_ = x2.Args[1]
+		if p != x2.Args[0] {
+			break
+		}
+		if mem != x2.Args[1] {
+			break
+		}
+		s1 := o0.Args[1]
+		if s1.Op != OpPPC64SLDconst {
+			break
+		}
+		if s1.AuxInt != 48 {
+			break
+		}
+		x1 := s1.Args[0]
+		if x1.Op != OpPPC64MOVBZload {
+			break
+		}
+		i1 := x1.AuxInt
+		if x1.Aux != s {
+			break
+		}
+		_ = x1.Args[1]
+		if p != x1.Args[0] {
+			break
+		}
+		if mem != x1.Args[1] {
+			break
+		}
+		s0 := v.Args[1]
+		if s0.Op != OpPPC64SLDconst {
+			break
+		}
+		if s0.AuxInt != 56 {
+			break
+		}
+		x0 := s0.Args[0]
+		if x0.Op != OpPPC64MOVBZload {
+			break
+		}
+		i0 := x0.AuxInt
+		if x0.Aux != s {
+			break
+		}
+		_ = x0.Args[1]
+		if p != x0.Args[0] {
+			break
+		}
+		if mem != x0.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3)) {
+			break
+		}
+		b = mergePoint(b, x0, x1, x2, x3, x4)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> x7:(MOVBZload [i7] {s} p mem) o5:(OR <t> s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8]) o4:(OR <t> s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]) o3:(OR <t> s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]) s0:(SLWconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])))))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		x7 := v.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		s := x7.Aux
+		_ = x7.Args[1]
+		p := x7.Args[0]
+		mem := x7.Args[1]
+		o5 := v.Args[1]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		s6 := o5.Args[0]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 8 {
+			break
+		}
+		x6 := s6.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		o4 := o5.Args[1]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		s5 := o4.Args[0]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		o3 := o4.Args[1]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s4 := o3.Args[0]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s0 := o3.Args[1]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x3.Type != t {
+			break
+		}
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x3_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
+			break
+		}
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> x7:(MOVBZload [i7] {s} p mem) o5:(OR <t> s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8]) o4:(OR <t> s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]) o3:(OR <t> s0:(SLWconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]) s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24])))))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		x7 := v.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		s := x7.Aux
+		_ = x7.Args[1]
+		p := x7.Args[0]
+		mem := x7.Args[1]
+		o5 := v.Args[1]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		s6 := o5.Args[0]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 8 {
+			break
+		}
+		x6 := s6.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		o4 := o5.Args[1]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		s5 := o4.Args[0]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		o3 := o4.Args[1]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s0 := o3.Args[0]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x3.Type != t {
+			break
+		}
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x3_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s4 := o3.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
+			break
+		}
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	return false
+}
+func rewriteValuePPC64_OpPPC64OR_90(v *Value) bool {
+	b := v.Block
+	_ = b
+	config := b.Func.Config
+	_ = config
+	typ := &b.Func.Config.Types
+	_ = typ
+	// match: (OR <t> x7:(MOVBZload [i7] {s} p mem) o5:(OR <t> s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8]) o4:(OR <t> o3:(OR <t> s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]) s0:(SLWconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])) s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]))))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		x7 := v.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		s := x7.Aux
+		_ = x7.Args[1]
+		p := x7.Args[0]
+		mem := x7.Args[1]
+		o5 := v.Args[1]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		s6 := o5.Args[0]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 8 {
+			break
+		}
+		x6 := s6.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		o4 := o5.Args[1]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		o3 := o4.Args[0]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s4 := o3.Args[0]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s0 := o3.Args[1]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x3.Type != t {
+			break
+		}
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x3_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s5 := o4.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
+			break
+		}
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> x7:(MOVBZload [i7] {s} p mem) o5:(OR <t> s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8]) o4:(OR <t> o3:(OR <t> s0:(SLWconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]) s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24])) s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]))))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		x7 := v.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		s := x7.Aux
+		_ = x7.Args[1]
+		p := x7.Args[0]
+		mem := x7.Args[1]
+		o5 := v.Args[1]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		s6 := o5.Args[0]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 8 {
+			break
+		}
+		x6 := s6.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		o4 := o5.Args[1]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		o3 := o4.Args[0]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s0 := o3.Args[0]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x3.Type != t {
+			break
+		}
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x3_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s4 := o3.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s5 := o4.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
+			break
+		}
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> x7:(MOVBZload [i7] {s} p mem) o5:(OR <t> o4:(OR <t> s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]) o3:(OR <t> s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]) s0:(SLWconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]))) s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8])))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		x7 := v.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		s := x7.Aux
+		_ = x7.Args[1]
+		p := x7.Args[0]
+		mem := x7.Args[1]
+		o5 := v.Args[1]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		o4 := o5.Args[0]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		s5 := o4.Args[0]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		o3 := o4.Args[1]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s4 := o3.Args[0]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s0 := o3.Args[1]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x3.Type != t {
+			break
+		}
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x3_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s6 := o5.Args[1]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 8 {
+			break
+		}
+		x6 := s6.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
+			break
+		}
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> x7:(MOVBZload [i7] {s} p mem) o5:(OR <t> o4:(OR <t> s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]) o3:(OR <t> s0:(SLWconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]) s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]))) s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8])))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		x7 := v.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		s := x7.Aux
+		_ = x7.Args[1]
+		p := x7.Args[0]
+		mem := x7.Args[1]
+		o5 := v.Args[1]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		o4 := o5.Args[0]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		s5 := o4.Args[0]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		o3 := o4.Args[1]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s0 := o3.Args[0]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x3.Type != t {
+			break
+		}
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x3_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s4 := o3.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s6 := o5.Args[1]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 8 {
+			break
+		}
+		x6 := s6.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
+			break
+		}
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> x7:(MOVBZload [i7] {s} p mem) o5:(OR <t> o4:(OR <t> o3:(OR <t> s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]) s0:(SLWconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])) s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16])) s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8])))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		x7 := v.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		s := x7.Aux
+		_ = x7.Args[1]
+		p := x7.Args[0]
+		mem := x7.Args[1]
+		o5 := v.Args[1]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		o4 := o5.Args[0]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		o3 := o4.Args[0]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s4 := o3.Args[0]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s0 := o3.Args[1]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x3.Type != t {
+			break
+		}
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x3_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s5 := o4.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		s6 := o5.Args[1]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 8 {
+			break
+		}
+		x6 := s6.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
+			break
+		}
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> x7:(MOVBZload [i7] {s} p mem) o5:(OR <t> o4:(OR <t> o3:(OR <t> s0:(SLWconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]) s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24])) s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16])) s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8])))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		x7 := v.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		s := x7.Aux
+		_ = x7.Args[1]
+		p := x7.Args[0]
+		mem := x7.Args[1]
+		o5 := v.Args[1]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		o4 := o5.Args[0]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		o3 := o4.Args[0]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s0 := o3.Args[0]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x3.Type != t {
+			break
+		}
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x3_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s4 := o3.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s5 := o4.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		s6 := o5.Args[1]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 8 {
+			break
+		}
+		x6 := s6.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
+			break
+		}
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o5:(OR <t> s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8]) o4:(OR <t> s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]) o3:(OR <t> s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]) s0:(SLWconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])))) x7:(MOVBZload [i7] {s} p mem))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o5 := v.Args[0]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		s6 := o5.Args[0]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 8 {
+			break
+		}
+		x6 := s6.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		s := x6.Aux
+		_ = x6.Args[1]
+		p := x6.Args[0]
+		mem := x6.Args[1]
+		o4 := o5.Args[1]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		s5 := o4.Args[0]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		o3 := o4.Args[1]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s4 := o3.Args[0]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s0 := o3.Args[1]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x3.Type != t {
+			break
+		}
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x3_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		x7 := v.Args[1]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		if x7.Aux != s {
+			break
+		}
+		_ = x7.Args[1]
+		if p != x7.Args[0] {
+			break
+		}
+		if mem != x7.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
+			break
+		}
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o5:(OR <t> s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8]) o4:(OR <t> s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]) o3:(OR <t> s0:(SLWconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]) s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24])))) x7:(MOVBZload [i7] {s} p mem))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o5 := v.Args[0]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		s6 := o5.Args[0]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 8 {
+			break
+		}
+		x6 := s6.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		s := x6.Aux
+		_ = x6.Args[1]
+		p := x6.Args[0]
+		mem := x6.Args[1]
+		o4 := o5.Args[1]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		s5 := o4.Args[0]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		o3 := o4.Args[1]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s0 := o3.Args[0]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x3.Type != t {
+			break
+		}
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x3_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s4 := o3.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		x7 := v.Args[1]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		if x7.Aux != s {
+			break
+		}
+		_ = x7.Args[1]
+		if p != x7.Args[0] {
+			break
+		}
+		if mem != x7.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
+			break
+		}
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o5:(OR <t> s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8]) o4:(OR <t> o3:(OR <t> s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]) s0:(SLWconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])) s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]))) x7:(MOVBZload [i7] {s} p mem))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o5 := v.Args[0]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		s6 := o5.Args[0]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 8 {
+			break
+		}
+		x6 := s6.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		s := x6.Aux
+		_ = x6.Args[1]
+		p := x6.Args[0]
+		mem := x6.Args[1]
+		o4 := o5.Args[1]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		o3 := o4.Args[0]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s4 := o3.Args[0]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s0 := o3.Args[1]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x3.Type != t {
+			break
+		}
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x3_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s5 := o4.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		x7 := v.Args[1]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		if x7.Aux != s {
+			break
+		}
+		_ = x7.Args[1]
+		if p != x7.Args[0] {
+			break
+		}
+		if mem != x7.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
+			break
+		}
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o5:(OR <t> s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8]) o4:(OR <t> o3:(OR <t> s0:(SLWconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]) s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24])) s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]))) x7:(MOVBZload [i7] {s} p mem))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o5 := v.Args[0]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		s6 := o5.Args[0]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 8 {
+			break
+		}
+		x6 := s6.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		s := x6.Aux
+		_ = x6.Args[1]
+		p := x6.Args[0]
+		mem := x6.Args[1]
+		o4 := o5.Args[1]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		o3 := o4.Args[0]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s0 := o3.Args[0]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x3.Type != t {
+			break
+		}
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x3_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s4 := o3.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s5 := o4.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		x7 := v.Args[1]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		if x7.Aux != s {
+			break
+		}
+		_ = x7.Args[1]
+		if p != x7.Args[0] {
+			break
+		}
+		if mem != x7.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
+			break
+		}
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	return false
+}
+func rewriteValuePPC64_OpPPC64OR_100(v *Value) bool {
+	b := v.Block
+	_ = b
+	config := b.Func.Config
+	_ = config
+	typ := &b.Func.Config.Types
+	_ = typ
+	// match: (OR <t> o5:(OR <t> o4:(OR <t> s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]) o3:(OR <t> s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]) s0:(SLWconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]))) s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8])) x7:(MOVBZload [i7] {s} p mem))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o5 := v.Args[0]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		o4 := o5.Args[0]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		s5 := o4.Args[0]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		s := x5.Aux
+		_ = x5.Args[1]
+		p := x5.Args[0]
+		mem := x5.Args[1]
+		o3 := o4.Args[1]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s4 := o3.Args[0]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s0 := o3.Args[1]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x3.Type != t {
+			break
+		}
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x3_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s6 := o5.Args[1]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 8 {
+			break
+		}
+		x6 := s6.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		x7 := v.Args[1]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		if x7.Aux != s {
+			break
+		}
+		_ = x7.Args[1]
+		if p != x7.Args[0] {
+			break
+		}
+		if mem != x7.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
+			break
+		}
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o5:(OR <t> o4:(OR <t> s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]) o3:(OR <t> s0:(SLWconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]) s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]))) s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8])) x7:(MOVBZload [i7] {s} p mem))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o5 := v.Args[0]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		o4 := o5.Args[0]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		s5 := o4.Args[0]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		s := x5.Aux
+		_ = x5.Args[1]
+		p := x5.Args[0]
+		mem := x5.Args[1]
+		o3 := o4.Args[1]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s0 := o3.Args[0]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x3.Type != t {
+			break
+		}
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x3_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s4 := o3.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s6 := o5.Args[1]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 8 {
+			break
+		}
+		x6 := s6.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		x7 := v.Args[1]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		if x7.Aux != s {
+			break
+		}
+		_ = x7.Args[1]
+		if p != x7.Args[0] {
+			break
+		}
+		if mem != x7.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
+			break
+		}
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]) s0:(SLWconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])) s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16])) s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8])) x7:(MOVBZload [i7] {s} p mem))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o5 := v.Args[0]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		o4 := o5.Args[0]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		o3 := o4.Args[0]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s4 := o3.Args[0]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		s := x4.Aux
+		_ = x4.Args[1]
+		p := x4.Args[0]
+		mem := x4.Args[1]
+		s0 := o3.Args[1]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x3.Type != t {
+			break
+		}
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x3_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s5 := o4.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		s6 := o5.Args[1]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 8 {
+			break
+		}
+		x6 := s6.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		x7 := v.Args[1]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		if x7.Aux != s {
+			break
+		}
+		_ = x7.Args[1]
+		if p != x7.Args[0] {
+			break
+		}
+		if mem != x7.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
+			break
+		}
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s0:(SLWconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]) s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24])) s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16])) s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8])) x7:(MOVBZload [i7] {s} p mem))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		o5 := v.Args[0]
+		if o5.Op != OpPPC64OR {
+			break
+		}
+		if o5.Type != t {
+			break
+		}
+		_ = o5.Args[1]
+		o4 := o5.Args[0]
+		if o4.Op != OpPPC64OR {
+			break
+		}
+		if o4.Type != t {
+			break
+		}
+		_ = o4.Args[1]
+		o3 := o4.Args[0]
+		if o3.Op != OpPPC64OR {
+			break
+		}
+		if o3.Type != t {
+			break
+		}
+		_ = o3.Args[1]
+		s0 := o3.Args[0]
+		if s0.Op != OpPPC64SLWconst {
+			break
+		}
+		if s0.AuxInt != 32 {
+			break
+		}
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x3.Type != t {
+			break
+		}
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x3_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x3_0.AuxInt
+		s := x3_0.Aux
+		p := x3_0.Args[0]
+		mem := x3.Args[1]
+		s4 := o3.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
+		if x4.Op != OpPPC64MOVBZload {
+			break
+		}
+		i4 := x4.AuxInt
+		if x4.Aux != s {
+			break
+		}
+		_ = x4.Args[1]
+		if p != x4.Args[0] {
+			break
+		}
+		if mem != x4.Args[1] {
+			break
+		}
+		s5 := o4.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
+		if x5.Op != OpPPC64MOVBZload {
+			break
+		}
+		i5 := x5.AuxInt
+		if x5.Aux != s {
+			break
+		}
+		_ = x5.Args[1]
+		if p != x5.Args[0] {
+			break
+		}
+		if mem != x5.Args[1] {
+			break
+		}
+		s6 := o5.Args[1]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 8 {
+			break
+		}
+		x6 := s6.Args[0]
+		if x6.Op != OpPPC64MOVBZload {
+			break
+		}
+		i6 := x6.AuxInt
+		if x6.Aux != s {
+			break
+		}
+		_ = x6.Args[1]
+		if p != x6.Args[0] {
+			break
+		}
+		if mem != x6.Args[1] {
+			break
+		}
+		x7 := v.Args[1]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
+		if x7.Aux != s {
+			break
+		}
+		_ = x7.Args[1]
+		if p != x7.Args[0] {
+			break
+		}
+		if mem != x7.Args[1] {
+			break
+		}
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
+			break
+		}
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
+		v.reset(OpCopy)
+		v.AddArg(v0)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
+		v0.AddArg(mem)
+		return true
+	}
+	// match: (OR <t> x7:(MOVBZload [i7] {s} p mem) o5:(OR <t> s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8]) o4:(OR <t> s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]) o3:(OR <t> s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]) s0:(SLDconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])))))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	for {
+		t := v.Type
+		_ = v.Args[1]
+		x7 := v.Args[0]
+		if x7.Op != OpPPC64MOVBZload {
+			break
+		}
+		i7 := x7.AuxInt
 		s := x7.Aux
 		_ = x7.Args[1]
 		p := x7.Args[0]
@@ -10660,14 +21003,14 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 			break
 		}
 		_ = o5.Args[1]
-		s5 := o5.Args[0]
-		if s5.Op != OpPPC64SLDconst {
+		s6 := o5.Args[0]
+		if s6.Op != OpPPC64SLDconst {
 			break
 		}
-		if s5.AuxInt != 48 {
+		if s6.AuxInt != 8 {
 			break
 		}
-		x6 := s5.Args[0]
+		x6 := s6.Args[0]
 		if x6.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -10690,14 +21033,14 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 			break
 		}
 		_ = o4.Args[1]
-		s4 := o4.Args[0]
-		if s4.Op != OpPPC64SLDconst {
+		s5 := o4.Args[0]
+		if s5.Op != OpPPC64SLDconst {
 			break
 		}
-		if s4.AuxInt != 40 {
+		if s5.AuxInt != 16 {
 			break
 		}
-		x5 := s4.Args[0]
+		x5 := s5.Args[0]
 		if x5.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -10720,14 +21063,14 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 			break
 		}
 		_ = o3.Args[1]
-		s3 := o3.Args[0]
-		if s3.Op != OpPPC64SLDconst {
+		s4 := o3.Args[0]
+		if s4.Op != OpPPC64SLDconst {
 			break
 		}
-		if s3.AuxInt != 32 {
+		if s4.AuxInt != 24 {
 			break
 		}
-		x4 := s3.Args[0]
+		x4 := s4.Args[0]
 		if x4.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -10742,48 +21085,60 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 		if mem != x4.Args[1] {
 			break
 		}
-		x0 := o3.Args[1]
-		if x0.Op != OpPPC64MOVWZload {
+		s0 := o3.Args[1]
+		if s0.Op != OpPPC64SLDconst {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		if s0.AuxInt != 32 {
 			break
 		}
-		_ = x0.Args[1]
-		if p != x0.Args[0] {
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
+			break
+		}
+		if x3.Type != t {
+			break
+		}
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x3_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
 			break
 		}
-		if mem != x0.Args[1] {
+		if mem != x3.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
 			break
 		}
-		b = mergePoint(b, x0, x4, x5, x6, x7)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> x0:(MOVWZload {s} [i0] p mem) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))))
-	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
-	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	// match: (OR <t> x7:(MOVBZload [i7] {s} p mem) o5:(OR <t> s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8]) o4:(OR <t> s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]) o3:(OR <t> s0:(SLDconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]) s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24])))))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
-		s6 := v.Args[0]
-		if s6.Op != OpPPC64SLDconst {
-			break
-		}
-		if s6.AuxInt != 56 {
-			break
-		}
-		x7 := s6.Args[0]
+		x7 := v.Args[0]
 		if x7.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -10800,14 +21155,14 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 			break
 		}
 		_ = o5.Args[1]
-		s5 := o5.Args[0]
-		if s5.Op != OpPPC64SLDconst {
+		s6 := o5.Args[0]
+		if s6.Op != OpPPC64SLDconst {
 			break
 		}
-		if s5.AuxInt != 48 {
+		if s6.AuxInt != 8 {
 			break
 		}
-		x6 := s5.Args[0]
+		x6 := s6.Args[0]
 		if x6.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -10830,14 +21185,14 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 			break
 		}
 		_ = o4.Args[1]
-		s4 := o4.Args[0]
-		if s4.Op != OpPPC64SLDconst {
+		s5 := o4.Args[0]
+		if s5.Op != OpPPC64SLDconst {
 			break
 		}
-		if s4.AuxInt != 40 {
+		if s5.AuxInt != 16 {
 			break
 		}
-		x5 := s4.Args[0]
+		x5 := s5.Args[0]
 		if x5.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -10860,29 +21215,46 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 			break
 		}
 		_ = o3.Args[1]
-		x0 := o3.Args[0]
-		if x0.Op != OpPPC64MOVWZload {
+		s0 := o3.Args[0]
+		if s0.Op != OpPPC64SLDconst {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		if s0.AuxInt != 32 {
 			break
 		}
-		_ = x0.Args[1]
-		if p != x0.Args[0] {
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
 			break
 		}
-		if mem != x0.Args[1] {
+		if x3.Type != t {
 			break
 		}
-		s3 := o3.Args[1]
-		if s3.Op != OpPPC64SLDconst {
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
 			break
 		}
-		if s3.AuxInt != 32 {
+		if x3_0.Type != typ.Uintptr {
 			break
 		}
-		x4 := s3.Args[0]
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s4 := o3.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
 		if x4.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -10897,33 +21269,28 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 		if mem != x4.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
 			break
 		}
-		b = mergePoint(b, x0, x4, x5, x6, x7)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) x0:(MOVWZload {s} [i0] p mem)) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
-	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
-	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	// match: (OR <t> x7:(MOVBZload [i7] {s} p mem) o5:(OR <t> s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8]) o4:(OR <t> o3:(OR <t> s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]) s0:(SLDconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])) s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]))))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
-		s6 := v.Args[0]
-		if s6.Op != OpPPC64SLDconst {
-			break
-		}
-		if s6.AuxInt != 56 {
-			break
-		}
-		x7 := s6.Args[0]
+		x7 := v.Args[0]
 		if x7.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -10940,14 +21307,14 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 			break
 		}
 		_ = o5.Args[1]
-		s5 := o5.Args[0]
-		if s5.Op != OpPPC64SLDconst {
+		s6 := o5.Args[0]
+		if s6.Op != OpPPC64SLDconst {
 			break
 		}
-		if s5.AuxInt != 48 {
+		if s6.AuxInt != 8 {
 			break
 		}
-		x6 := s5.Args[0]
+		x6 := s6.Args[0]
 		if x6.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -10978,14 +21345,14 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 			break
 		}
 		_ = o3.Args[1]
-		s3 := o3.Args[0]
-		if s3.Op != OpPPC64SLDconst {
+		s4 := o3.Args[0]
+		if s4.Op != OpPPC64SLDconst {
 			break
 		}
-		if s3.AuxInt != 32 {
+		if s4.AuxInt != 24 {
 			break
 		}
-		x4 := s3.Args[0]
+		x4 := s4.Args[0]
 		if x4.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11000,29 +21367,46 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 		if mem != x4.Args[1] {
 			break
 		}
-		x0 := o3.Args[1]
-		if x0.Op != OpPPC64MOVWZload {
+		s0 := o3.Args[1]
+		if s0.Op != OpPPC64SLDconst {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		if s0.AuxInt != 32 {
 			break
 		}
-		_ = x0.Args[1]
-		if p != x0.Args[0] {
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
 			break
 		}
-		if mem != x0.Args[1] {
+		if x3.Type != t {
 			break
 		}
-		s4 := o4.Args[1]
-		if s4.Op != OpPPC64SLDconst {
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
 			break
 		}
-		if s4.AuxInt != 40 {
+		if x3_0.Type != typ.Uintptr {
 			break
 		}
-		x5 := s4.Args[0]
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s5 := o4.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
 		if x5.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11037,33 +21421,28 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 		if mem != x5.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
 			break
 		}
-		b = mergePoint(b, x0, x4, x5, x6, x7)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> x0:(MOVWZload {s} [i0] p mem) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
-	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
-	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	// match: (OR <t> x7:(MOVBZload [i7] {s} p mem) o5:(OR <t> s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8]) o4:(OR <t> o3:(OR <t> s0:(SLDconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]) s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24])) s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]))))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
-		s6 := v.Args[0]
-		if s6.Op != OpPPC64SLDconst {
-			break
-		}
-		if s6.AuxInt != 56 {
-			break
-		}
-		x7 := s6.Args[0]
+		x7 := v.Args[0]
 		if x7.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11080,14 +21459,14 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 			break
 		}
 		_ = o5.Args[1]
-		s5 := o5.Args[0]
-		if s5.Op != OpPPC64SLDconst {
+		s6 := o5.Args[0]
+		if s6.Op != OpPPC64SLDconst {
 			break
 		}
-		if s5.AuxInt != 48 {
+		if s6.AuxInt != 8 {
 			break
 		}
-		x6 := s5.Args[0]
+		x6 := s6.Args[0]
 		if x6.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11118,29 +21497,46 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 			break
 		}
 		_ = o3.Args[1]
-		x0 := o3.Args[0]
-		if x0.Op != OpPPC64MOVWZload {
+		s0 := o3.Args[0]
+		if s0.Op != OpPPC64SLDconst {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		if s0.AuxInt != 32 {
 			break
 		}
-		_ = x0.Args[1]
-		if p != x0.Args[0] {
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
 			break
 		}
-		if mem != x0.Args[1] {
+		if x3.Type != t {
 			break
 		}
-		s3 := o3.Args[1]
-		if s3.Op != OpPPC64SLDconst {
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
 			break
 		}
-		if s3.AuxInt != 32 {
+		if x3_0.Type != typ.Uintptr {
 			break
 		}
-		x4 := s3.Args[0]
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s4 := o3.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
 		if x4.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11155,14 +21551,14 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 		if mem != x4.Args[1] {
 			break
 		}
-		s4 := o4.Args[1]
-		if s4.Op != OpPPC64SLDconst {
+		s5 := o4.Args[1]
+		if s5.Op != OpPPC64SLDconst {
 			break
 		}
-		if s4.AuxInt != 40 {
+		if s5.AuxInt != 16 {
 			break
 		}
-		x5 := s4.Args[0]
+		x5 := s5.Args[0]
 		if x5.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11177,33 +21573,28 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 		if mem != x5.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
 			break
 		}
-		b = mergePoint(b, x0, x4, x5, x6, x7)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) x0:(MOVWZload {s} [i0] p mem))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
-	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
-	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	// match: (OR <t> x7:(MOVBZload [i7] {s} p mem) o5:(OR <t> o4:(OR <t> s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]) o3:(OR <t> s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]) s0:(SLDconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]))) s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8])))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
-		s6 := v.Args[0]
-		if s6.Op != OpPPC64SLDconst {
-			break
-		}
-		if s6.AuxInt != 56 {
-			break
-		}
-		x7 := s6.Args[0]
+		x7 := v.Args[0]
 		if x7.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11228,14 +21619,14 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 			break
 		}
 		_ = o4.Args[1]
-		s4 := o4.Args[0]
-		if s4.Op != OpPPC64SLDconst {
+		s5 := o4.Args[0]
+		if s5.Op != OpPPC64SLDconst {
 			break
 		}
-		if s4.AuxInt != 40 {
+		if s5.AuxInt != 16 {
 			break
 		}
-		x5 := s4.Args[0]
+		x5 := s5.Args[0]
 		if x5.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11258,14 +21649,14 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 			break
 		}
 		_ = o3.Args[1]
-		s3 := o3.Args[0]
-		if s3.Op != OpPPC64SLDconst {
+		s4 := o3.Args[0]
+		if s4.Op != OpPPC64SLDconst {
 			break
 		}
-		if s3.AuxInt != 32 {
+		if s4.AuxInt != 24 {
 			break
 		}
-		x4 := s3.Args[0]
+		x4 := s4.Args[0]
 		if x4.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11280,29 +21671,46 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 		if mem != x4.Args[1] {
 			break
 		}
-		x0 := o3.Args[1]
-		if x0.Op != OpPPC64MOVWZload {
+		s0 := o3.Args[1]
+		if s0.Op != OpPPC64SLDconst {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		if s0.AuxInt != 32 {
 			break
 		}
-		_ = x0.Args[1]
-		if p != x0.Args[0] {
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
 			break
 		}
-		if mem != x0.Args[1] {
+		if x3.Type != t {
 			break
 		}
-		s5 := o5.Args[1]
-		if s5.Op != OpPPC64SLDconst {
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
 			break
 		}
-		if s5.AuxInt != 48 {
+		if x3_0.Type != typ.Uintptr {
 			break
 		}
-		x6 := s5.Args[0]
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s6 := o5.Args[1]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 8 {
+			break
+		}
+		x6 := s6.Args[0]
 		if x6.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11317,33 +21725,28 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 		if mem != x6.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
 			break
 		}
-		b = mergePoint(b, x0, x4, x5, x6, x7)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> x0:(MOVWZload {s} [i0] p mem) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
-	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
-	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	// match: (OR <t> x7:(MOVBZload [i7] {s} p mem) o5:(OR <t> o4:(OR <t> s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]) o3:(OR <t> s0:(SLDconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]) s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]))) s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8])))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
-		s6 := v.Args[0]
-		if s6.Op != OpPPC64SLDconst {
-			break
-		}
-		if s6.AuxInt != 56 {
-			break
-		}
-		x7 := s6.Args[0]
+		x7 := v.Args[0]
 		if x7.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11368,14 +21771,14 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 			break
 		}
 		_ = o4.Args[1]
-		s4 := o4.Args[0]
-		if s4.Op != OpPPC64SLDconst {
+		s5 := o4.Args[0]
+		if s5.Op != OpPPC64SLDconst {
 			break
 		}
-		if s4.AuxInt != 40 {
+		if s5.AuxInt != 16 {
 			break
 		}
-		x5 := s4.Args[0]
+		x5 := s5.Args[0]
 		if x5.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11398,29 +21801,46 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 			break
 		}
 		_ = o3.Args[1]
-		x0 := o3.Args[0]
-		if x0.Op != OpPPC64MOVWZload {
+		s0 := o3.Args[0]
+		if s0.Op != OpPPC64SLDconst {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		if s0.AuxInt != 32 {
 			break
 		}
-		_ = x0.Args[1]
-		if p != x0.Args[0] {
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
 			break
 		}
-		if mem != x0.Args[1] {
+		if x3.Type != t {
 			break
 		}
-		s3 := o3.Args[1]
-		if s3.Op != OpPPC64SLDconst {
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
 			break
 		}
-		if s3.AuxInt != 32 {
+		if x3_0.Type != typ.Uintptr {
 			break
 		}
-		x4 := s3.Args[0]
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s4 := o3.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
 		if x4.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11435,14 +21855,14 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 		if mem != x4.Args[1] {
 			break
 		}
-		s5 := o5.Args[1]
-		if s5.Op != OpPPC64SLDconst {
+		s6 := o5.Args[1]
+		if s6.Op != OpPPC64SLDconst {
 			break
 		}
-		if s5.AuxInt != 48 {
+		if s6.AuxInt != 8 {
 			break
 		}
-		x6 := s5.Args[0]
+		x6 := s6.Args[0]
 		if x6.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11457,40 +21877,37 @@ func rewriteValuePPC64_OpPPC64OR_20(v *Value) bool {
 		if mem != x6.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
 			break
 		}
-		b = mergePoint(b, x0, x4, x5, x6, x7)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
 		v0.AddArg(mem)
 		return true
 	}
 	return false
 }
-func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
+func rewriteValuePPC64_OpPPC64OR_110(v *Value) bool {
 	b := v.Block
 	_ = b
 	config := b.Func.Config
 	_ = config
-	// match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) x0:(MOVWZload {s} [i0] p mem)) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
-	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
-	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	typ := &b.Func.Config.Types
+	_ = typ
+	// match: (OR <t> x7:(MOVBZload [i7] {s} p mem) o5:(OR <t> o4:(OR <t> o3:(OR <t> s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]) s0:(SLDconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])) s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16])) s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8])))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
-		s6 := v.Args[0]
-		if s6.Op != OpPPC64SLDconst {
-			break
-		}
-		if s6.AuxInt != 56 {
-			break
-		}
-		x7 := s6.Args[0]
+		x7 := v.Args[0]
 		if x7.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11523,14 +21940,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 			break
 		}
 		_ = o3.Args[1]
-		s3 := o3.Args[0]
-		if s3.Op != OpPPC64SLDconst {
+		s4 := o3.Args[0]
+		if s4.Op != OpPPC64SLDconst {
 			break
 		}
-		if s3.AuxInt != 32 {
+		if s4.AuxInt != 24 {
 			break
 		}
-		x4 := s3.Args[0]
+		x4 := s4.Args[0]
 		if x4.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11545,29 +21962,46 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x4.Args[1] {
 			break
 		}
-		x0 := o3.Args[1]
-		if x0.Op != OpPPC64MOVWZload {
+		s0 := o3.Args[1]
+		if s0.Op != OpPPC64SLDconst {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		if s0.AuxInt != 32 {
 			break
 		}
-		_ = x0.Args[1]
-		if p != x0.Args[0] {
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
 			break
 		}
-		if mem != x0.Args[1] {
+		if x3.Type != t {
 			break
 		}
-		s4 := o4.Args[1]
-		if s4.Op != OpPPC64SLDconst {
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
 			break
 		}
-		if s4.AuxInt != 40 {
+		if x3_0.Type != typ.Uintptr {
 			break
 		}
-		x5 := s4.Args[0]
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s5 := o4.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
 		if x5.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11582,14 +22016,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x5.Args[1] {
 			break
 		}
-		s5 := o5.Args[1]
-		if s5.Op != OpPPC64SLDconst {
+		s6 := o5.Args[1]
+		if s6.Op != OpPPC64SLDconst {
 			break
 		}
-		if s5.AuxInt != 48 {
+		if s6.AuxInt != 8 {
 			break
 		}
-		x6 := s5.Args[0]
+		x6 := s6.Args[0]
 		if x6.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11604,33 +22038,28 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x6.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
 			break
 		}
-		b = mergePoint(b, x0, x4, x5, x6, x7)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> x0:(MOVWZload {s} [i0] p mem) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
-	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
-	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	// match: (OR <t> x7:(MOVBZload [i7] {s} p mem) o5:(OR <t> o4:(OR <t> o3:(OR <t> s0:(SLDconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]) s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24])) s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16])) s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8])))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
-		s6 := v.Args[0]
-		if s6.Op != OpPPC64SLDconst {
-			break
-		}
-		if s6.AuxInt != 56 {
-			break
-		}
-		x7 := s6.Args[0]
+		x7 := v.Args[0]
 		if x7.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11663,29 +22092,46 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 			break
 		}
 		_ = o3.Args[1]
-		x0 := o3.Args[0]
-		if x0.Op != OpPPC64MOVWZload {
+		s0 := o3.Args[0]
+		if s0.Op != OpPPC64SLDconst {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		if s0.AuxInt != 32 {
 			break
 		}
-		_ = x0.Args[1]
-		if p != x0.Args[0] {
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
 			break
 		}
-		if mem != x0.Args[1] {
+		if x3.Type != t {
 			break
 		}
-		s3 := o3.Args[1]
-		if s3.Op != OpPPC64SLDconst {
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
 			break
 		}
-		if s3.AuxInt != 32 {
+		if x3_0.Type != typ.Uintptr {
 			break
 		}
-		x4 := s3.Args[0]
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s4 := o3.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
 		if x4.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11700,14 +22146,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x4.Args[1] {
 			break
 		}
-		s4 := o4.Args[1]
-		if s4.Op != OpPPC64SLDconst {
+		s5 := o4.Args[1]
+		if s5.Op != OpPPC64SLDconst {
 			break
 		}
-		if s4.AuxInt != 40 {
+		if s5.AuxInt != 16 {
 			break
 		}
-		x5 := s4.Args[0]
+		x5 := s5.Args[0]
 		if x5.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11722,14 +22168,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x5.Args[1] {
 			break
 		}
-		s5 := o5.Args[1]
-		if s5.Op != OpPPC64SLDconst {
+		s6 := o5.Args[1]
+		if s6.Op != OpPPC64SLDconst {
 			break
 		}
-		if s5.AuxInt != 48 {
+		if s6.AuxInt != 8 {
 			break
 		}
-		x6 := s5.Args[0]
+		x6 := s6.Args[0]
 		if x6.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11744,22 +22190,24 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x6.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
 			break
 		}
-		b = mergePoint(b, x0, x4, x5, x6, x7)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) x0:(MOVWZload {s} [i0] p mem)))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
-	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
-	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	// match: (OR <t> o5:(OR <t> s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8]) o4:(OR <t> s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]) o3:(OR <t> s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]) s0:(SLDconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])))) x7:(MOVBZload [i7] {s} p mem))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
@@ -11771,14 +22219,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 			break
 		}
 		_ = o5.Args[1]
-		s5 := o5.Args[0]
-		if s5.Op != OpPPC64SLDconst {
+		s6 := o5.Args[0]
+		if s6.Op != OpPPC64SLDconst {
 			break
 		}
-		if s5.AuxInt != 48 {
+		if s6.AuxInt != 8 {
 			break
 		}
-		x6 := s5.Args[0]
+		x6 := s6.Args[0]
 		if x6.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11795,14 +22243,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 			break
 		}
 		_ = o4.Args[1]
-		s4 := o4.Args[0]
-		if s4.Op != OpPPC64SLDconst {
+		s5 := o4.Args[0]
+		if s5.Op != OpPPC64SLDconst {
 			break
 		}
-		if s4.AuxInt != 40 {
+		if s5.AuxInt != 16 {
 			break
 		}
-		x5 := s4.Args[0]
+		x5 := s5.Args[0]
 		if x5.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11825,14 +22273,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 			break
 		}
 		_ = o3.Args[1]
-		s3 := o3.Args[0]
-		if s3.Op != OpPPC64SLDconst {
+		s4 := o3.Args[0]
+		if s4.Op != OpPPC64SLDconst {
 			break
 		}
-		if s3.AuxInt != 32 {
+		if s4.AuxInt != 24 {
 			break
 		}
-		x4 := s3.Args[0]
+		x4 := s4.Args[0]
 		if x4.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11847,29 +22295,39 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x4.Args[1] {
 			break
 		}
-		x0 := o3.Args[1]
-		if x0.Op != OpPPC64MOVWZload {
+		s0 := o3.Args[1]
+		if s0.Op != OpPPC64SLDconst {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		if s0.AuxInt != 32 {
 			break
 		}
-		_ = x0.Args[1]
-		if p != x0.Args[0] {
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
 			break
 		}
-		if mem != x0.Args[1] {
+		if x3.Type != t {
 			break
 		}
-		s6 := v.Args[1]
-		if s6.Op != OpPPC64SLDconst {
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
 			break
 		}
-		if s6.AuxInt != 56 {
+		if x3_0.Type != typ.Uintptr {
 			break
 		}
-		x7 := s6.Args[0]
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		x7 := v.Args[1]
 		if x7.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11884,22 +22342,24 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x7.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
 			break
 		}
-		b = mergePoint(b, x0, x4, x5, x6, x7)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> x0:(MOVWZload {s} [i0] p mem) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
-	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
-	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	// match: (OR <t> o5:(OR <t> s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8]) o4:(OR <t> s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]) o3:(OR <t> s0:(SLDconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]) s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24])))) x7:(MOVBZload [i7] {s} p mem))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
@@ -11911,14 +22371,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 			break
 		}
 		_ = o5.Args[1]
-		s5 := o5.Args[0]
-		if s5.Op != OpPPC64SLDconst {
+		s6 := o5.Args[0]
+		if s6.Op != OpPPC64SLDconst {
 			break
 		}
-		if s5.AuxInt != 48 {
+		if s6.AuxInt != 8 {
 			break
 		}
-		x6 := s5.Args[0]
+		x6 := s6.Args[0]
 		if x6.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11935,14 +22395,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 			break
 		}
 		_ = o4.Args[1]
-		s4 := o4.Args[0]
-		if s4.Op != OpPPC64SLDconst {
+		s5 := o4.Args[0]
+		if s5.Op != OpPPC64SLDconst {
 			break
 		}
-		if s4.AuxInt != 40 {
+		if s5.AuxInt != 16 {
 			break
 		}
-		x5 := s4.Args[0]
+		x5 := s5.Args[0]
 		if x5.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -11965,29 +22425,46 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 			break
 		}
 		_ = o3.Args[1]
-		x0 := o3.Args[0]
-		if x0.Op != OpPPC64MOVWZload {
+		s0 := o3.Args[0]
+		if s0.Op != OpPPC64SLDconst {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		if s0.AuxInt != 32 {
 			break
 		}
-		_ = x0.Args[1]
-		if p != x0.Args[0] {
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
 			break
 		}
-		if mem != x0.Args[1] {
+		if x3.Type != t {
 			break
 		}
-		s3 := o3.Args[1]
-		if s3.Op != OpPPC64SLDconst {
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
 			break
 		}
-		if s3.AuxInt != 32 {
+		if x3_0.Type != typ.Uintptr {
 			break
 		}
-		x4 := s3.Args[0]
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s4 := o3.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
 		if x4.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12002,14 +22479,7 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x4.Args[1] {
 			break
 		}
-		s6 := v.Args[1]
-		if s6.Op != OpPPC64SLDconst {
-			break
-		}
-		if s6.AuxInt != 56 {
-			break
-		}
-		x7 := s6.Args[0]
+		x7 := v.Args[1]
 		if x7.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12024,22 +22494,24 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x7.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
 			break
 		}
-		b = mergePoint(b, x0, x4, x5, x6, x7)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) x0:(MOVWZload {s} [i0] p mem)) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
-	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
-	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	// match: (OR <t> o5:(OR <t> s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8]) o4:(OR <t> o3:(OR <t> s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]) s0:(SLDconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])) s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]))) x7:(MOVBZload [i7] {s} p mem))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
@@ -12051,14 +22523,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 			break
 		}
 		_ = o5.Args[1]
-		s5 := o5.Args[0]
-		if s5.Op != OpPPC64SLDconst {
+		s6 := o5.Args[0]
+		if s6.Op != OpPPC64SLDconst {
 			break
 		}
-		if s5.AuxInt != 48 {
+		if s6.AuxInt != 8 {
 			break
 		}
-		x6 := s5.Args[0]
+		x6 := s6.Args[0]
 		if x6.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12083,14 +22555,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 			break
 		}
 		_ = o3.Args[1]
-		s3 := o3.Args[0]
-		if s3.Op != OpPPC64SLDconst {
+		s4 := o3.Args[0]
+		if s4.Op != OpPPC64SLDconst {
 			break
 		}
-		if s3.AuxInt != 32 {
+		if s4.AuxInt != 24 {
 			break
 		}
-		x4 := s3.Args[0]
+		x4 := s4.Args[0]
 		if x4.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12105,29 +22577,46 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x4.Args[1] {
 			break
 		}
-		x0 := o3.Args[1]
-		if x0.Op != OpPPC64MOVWZload {
+		s0 := o3.Args[1]
+		if s0.Op != OpPPC64SLDconst {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		if s0.AuxInt != 32 {
 			break
 		}
-		_ = x0.Args[1]
-		if p != x0.Args[0] {
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
 			break
 		}
-		if mem != x0.Args[1] {
+		if x3.Type != t {
 			break
 		}
-		s4 := o4.Args[1]
-		if s4.Op != OpPPC64SLDconst {
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
 			break
 		}
-		if s4.AuxInt != 40 {
+		if x3_0.Type != typ.Uintptr {
 			break
 		}
-		x5 := s4.Args[0]
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s5 := o4.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
 		if x5.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12142,14 +22631,7 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x5.Args[1] {
 			break
 		}
-		s6 := v.Args[1]
-		if s6.Op != OpPPC64SLDconst {
-			break
-		}
-		if s6.AuxInt != 56 {
-			break
-		}
-		x7 := s6.Args[0]
+		x7 := v.Args[1]
 		if x7.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12164,22 +22646,24 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x7.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
 			break
 		}
-		b = mergePoint(b, x0, x4, x5, x6, x7)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> x0:(MOVWZload {s} [i0] p mem) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
-	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
-	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	// match: (OR <t> o5:(OR <t> s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8]) o4:(OR <t> o3:(OR <t> s0:(SLDconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]) s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24])) s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]))) x7:(MOVBZload [i7] {s} p mem))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
@@ -12191,14 +22675,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 			break
 		}
 		_ = o5.Args[1]
-		s5 := o5.Args[0]
-		if s5.Op != OpPPC64SLDconst {
+		s6 := o5.Args[0]
+		if s6.Op != OpPPC64SLDconst {
 			break
 		}
-		if s5.AuxInt != 48 {
+		if s6.AuxInt != 8 {
 			break
 		}
-		x6 := s5.Args[0]
+		x6 := s6.Args[0]
 		if x6.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12223,29 +22707,46 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 			break
 		}
 		_ = o3.Args[1]
-		x0 := o3.Args[0]
-		if x0.Op != OpPPC64MOVWZload {
+		s0 := o3.Args[0]
+		if s0.Op != OpPPC64SLDconst {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		if s0.AuxInt != 32 {
 			break
 		}
-		_ = x0.Args[1]
-		if p != x0.Args[0] {
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
 			break
 		}
-		if mem != x0.Args[1] {
+		if x3.Type != t {
 			break
 		}
-		s3 := o3.Args[1]
-		if s3.Op != OpPPC64SLDconst {
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
 			break
 		}
-		if s3.AuxInt != 32 {
+		if x3_0.Type != typ.Uintptr {
 			break
 		}
-		x4 := s3.Args[0]
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s4 := o3.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
 		if x4.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12260,14 +22761,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x4.Args[1] {
 			break
 		}
-		s4 := o4.Args[1]
-		if s4.Op != OpPPC64SLDconst {
+		s5 := o4.Args[1]
+		if s5.Op != OpPPC64SLDconst {
 			break
 		}
-		if s4.AuxInt != 40 {
+		if s5.AuxInt != 16 {
 			break
 		}
-		x5 := s4.Args[0]
+		x5 := s5.Args[0]
 		if x5.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12282,14 +22783,7 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x5.Args[1] {
 			break
 		}
-		s6 := v.Args[1]
-		if s6.Op != OpPPC64SLDconst {
-			break
-		}
-		if s6.AuxInt != 56 {
-			break
-		}
-		x7 := s6.Args[0]
+		x7 := v.Args[1]
 		if x7.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12304,22 +22798,24 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x7.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
 			break
 		}
-		b = mergePoint(b, x0, x4, x5, x6, x7)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) x0:(MOVWZload {s} [i0] p mem))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
-	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
-	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	// match: (OR <t> o5:(OR <t> o4:(OR <t> s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]) o3:(OR <t> s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]) s0:(SLDconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]))) s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8])) x7:(MOVBZload [i7] {s} p mem))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
@@ -12339,14 +22835,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 			break
 		}
 		_ = o4.Args[1]
-		s4 := o4.Args[0]
-		if s4.Op != OpPPC64SLDconst {
+		s5 := o4.Args[0]
+		if s5.Op != OpPPC64SLDconst {
 			break
 		}
-		if s4.AuxInt != 40 {
+		if s5.AuxInt != 16 {
 			break
 		}
-		x5 := s4.Args[0]
+		x5 := s5.Args[0]
 		if x5.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12363,14 +22859,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 			break
 		}
 		_ = o3.Args[1]
-		s3 := o3.Args[0]
-		if s3.Op != OpPPC64SLDconst {
+		s4 := o3.Args[0]
+		if s4.Op != OpPPC64SLDconst {
 			break
 		}
-		if s3.AuxInt != 32 {
+		if s4.AuxInt != 24 {
 			break
 		}
-		x4 := s3.Args[0]
+		x4 := s4.Args[0]
 		if x4.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12385,29 +22881,46 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x4.Args[1] {
 			break
 		}
-		x0 := o3.Args[1]
-		if x0.Op != OpPPC64MOVWZload {
+		s0 := o3.Args[1]
+		if s0.Op != OpPPC64SLDconst {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		if s0.AuxInt != 32 {
 			break
 		}
-		_ = x0.Args[1]
-		if p != x0.Args[0] {
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
 			break
 		}
-		if mem != x0.Args[1] {
+		if x3.Type != t {
 			break
 		}
-		s5 := o5.Args[1]
-		if s5.Op != OpPPC64SLDconst {
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
 			break
 		}
-		if s5.AuxInt != 48 {
+		if x3_0.Type != typ.Uintptr {
 			break
 		}
-		x6 := s5.Args[0]
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s6 := o5.Args[1]
+		if s6.Op != OpPPC64SLDconst {
+			break
+		}
+		if s6.AuxInt != 8 {
+			break
+		}
+		x6 := s6.Args[0]
 		if x6.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12422,14 +22935,7 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x6.Args[1] {
 			break
 		}
-		s6 := v.Args[1]
-		if s6.Op != OpPPC64SLDconst {
-			break
-		}
-		if s6.AuxInt != 56 {
-			break
-		}
-		x7 := s6.Args[0]
+		x7 := v.Args[1]
 		if x7.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12444,22 +22950,24 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x7.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
 			break
 		}
-		b = mergePoint(b, x0, x4, x5, x6, x7)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> x0:(MOVWZload {s} [i0] p mem) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
-	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
-	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	// match: (OR <t> o5:(OR <t> o4:(OR <t> s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16]) o3:(OR <t> s0:(SLDconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]) s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]))) s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8])) x7:(MOVBZload [i7] {s} p mem))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
@@ -12479,14 +22987,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 			break
 		}
 		_ = o4.Args[1]
-		s4 := o4.Args[0]
-		if s4.Op != OpPPC64SLDconst {
+		s5 := o4.Args[0]
+		if s5.Op != OpPPC64SLDconst {
 			break
 		}
-		if s4.AuxInt != 40 {
+		if s5.AuxInt != 16 {
 			break
 		}
-		x5 := s4.Args[0]
+		x5 := s5.Args[0]
 		if x5.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12503,29 +23011,46 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 			break
 		}
 		_ = o3.Args[1]
-		x0 := o3.Args[0]
-		if x0.Op != OpPPC64MOVWZload {
+		s0 := o3.Args[0]
+		if s0.Op != OpPPC64SLDconst {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		if s0.AuxInt != 32 {
 			break
 		}
-		_ = x0.Args[1]
-		if p != x0.Args[0] {
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
 			break
 		}
-		if mem != x0.Args[1] {
+		if x3.Type != t {
 			break
 		}
-		s3 := o3.Args[1]
-		if s3.Op != OpPPC64SLDconst {
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
 			break
 		}
-		if s3.AuxInt != 32 {
+		if x3_0.Type != typ.Uintptr {
 			break
 		}
-		x4 := s3.Args[0]
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s4 := o3.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
 		if x4.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12540,14 +23065,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x4.Args[1] {
 			break
 		}
-		s5 := o5.Args[1]
-		if s5.Op != OpPPC64SLDconst {
+		s6 := o5.Args[1]
+		if s6.Op != OpPPC64SLDconst {
 			break
 		}
-		if s5.AuxInt != 48 {
+		if s6.AuxInt != 8 {
 			break
 		}
-		x6 := s5.Args[0]
+		x6 := s6.Args[0]
 		if x6.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12562,14 +23087,7 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x6.Args[1] {
 			break
 		}
-		s6 := v.Args[1]
-		if s6.Op != OpPPC64SLDconst {
-			break
-		}
-		if s6.AuxInt != 56 {
-			break
-		}
-		x7 := s6.Args[0]
+		x7 := v.Args[1]
 		if x7.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12584,22 +23102,24 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x7.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
 			break
 		}
-		b = mergePoint(b, x0, x4, x5, x6, x7)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) x0:(MOVWZload {s} [i0] p mem)) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
-	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
-	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	// match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24]) s0:(SLDconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])) s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16])) s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8])) x7:(MOVBZload [i7] {s} p mem))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
@@ -12627,14 +23147,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 			break
 		}
 		_ = o3.Args[1]
-		s3 := o3.Args[0]
-		if s3.Op != OpPPC64SLDconst {
+		s4 := o3.Args[0]
+		if s4.Op != OpPPC64SLDconst {
 			break
 		}
-		if s3.AuxInt != 32 {
+		if s4.AuxInt != 24 {
 			break
 		}
-		x4 := s3.Args[0]
+		x4 := s4.Args[0]
 		if x4.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12643,29 +23163,46 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		_ = x4.Args[1]
 		p := x4.Args[0]
 		mem := x4.Args[1]
-		x0 := o3.Args[1]
-		if x0.Op != OpPPC64MOVWZload {
+		s0 := o3.Args[1]
+		if s0.Op != OpPPC64SLDconst {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		if s0.AuxInt != 32 {
 			break
 		}
-		_ = x0.Args[1]
-		if p != x0.Args[0] {
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
 			break
 		}
-		if mem != x0.Args[1] {
+		if x3.Type != t {
 			break
 		}
-		s4 := o4.Args[1]
-		if s4.Op != OpPPC64SLDconst {
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
 			break
 		}
-		if s4.AuxInt != 40 {
+		if x3_0.Type != typ.Uintptr {
 			break
 		}
-		x5 := s4.Args[0]
+		i0 := x3_0.AuxInt
+		if x3_0.Aux != s {
+			break
+		}
+		if p != x3_0.Args[0] {
+			break
+		}
+		if mem != x3.Args[1] {
+			break
+		}
+		s5 := o4.Args[1]
+		if s5.Op != OpPPC64SLDconst {
+			break
+		}
+		if s5.AuxInt != 16 {
+			break
+		}
+		x5 := s5.Args[0]
 		if x5.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12680,14 +23217,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x5.Args[1] {
 			break
 		}
-		s5 := o5.Args[1]
-		if s5.Op != OpPPC64SLDconst {
+		s6 := o5.Args[1]
+		if s6.Op != OpPPC64SLDconst {
 			break
 		}
-		if s5.AuxInt != 48 {
+		if s6.AuxInt != 8 {
 			break
 		}
-		x6 := s5.Args[0]
+		x6 := s6.Args[0]
 		if x6.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12702,14 +23239,7 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x6.Args[1] {
 			break
 		}
-		s6 := v.Args[1]
-		if s6.Op != OpPPC64SLDconst {
-			break
-		}
-		if s6.AuxInt != 56 {
-			break
-		}
-		x7 := s6.Args[0]
+		x7 := v.Args[1]
 		if x7.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12724,22 +23254,24 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x7.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
 			break
 		}
-		b = mergePoint(b, x0, x4, x5, x6, x7)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
 		v0.AddArg(mem)
 		return true
 	}
-	// match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> x0:(MOVWZload {s} [i0] p mem) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
-	// cond: !config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6) && clobber(o3) && clobber(o4) && clobber(o5)
-	// result: @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	// match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s0:(SLDconst x3:(MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32]) s4:(SLDconst x4:(MOVBZload [i4] {s} p mem) [24])) s5:(SLDconst x5:(MOVBZload [i5] {s} p mem) [16])) s6:(SLDconst x6:(MOVBZload [i6] {s} p mem) [8])) x7:(MOVBZload [i7] {s} p mem))
+	// cond: !config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)
+	// result: @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 	for {
 		t := v.Type
 		_ = v.Args[1]
@@ -12767,23 +23299,40 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 			break
 		}
 		_ = o3.Args[1]
-		x0 := o3.Args[0]
-		if x0.Op != OpPPC64MOVWZload {
+		s0 := o3.Args[0]
+		if s0.Op != OpPPC64SLDconst {
 			break
 		}
-		i0 := x0.AuxInt
-		s := x0.Aux
-		_ = x0.Args[1]
-		p := x0.Args[0]
-		mem := x0.Args[1]
-		s3 := o3.Args[1]
-		if s3.Op != OpPPC64SLDconst {
+		if s0.AuxInt != 32 {
 			break
 		}
-		if s3.AuxInt != 32 {
+		x3 := s0.Args[0]
+		if x3.Op != OpPPC64MOVWBRload {
 			break
 		}
-		x4 := s3.Args[0]
+		if x3.Type != t {
+			break
+		}
+		_ = x3.Args[1]
+		x3_0 := x3.Args[0]
+		if x3_0.Op != OpPPC64MOVDaddr {
+			break
+		}
+		if x3_0.Type != typ.Uintptr {
+			break
+		}
+		i0 := x3_0.AuxInt
+		s := x3_0.Aux
+		p := x3_0.Args[0]
+		mem := x3.Args[1]
+		s4 := o3.Args[1]
+		if s4.Op != OpPPC64SLDconst {
+			break
+		}
+		if s4.AuxInt != 24 {
+			break
+		}
+		x4 := s4.Args[0]
 		if x4.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12798,14 +23347,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x4.Args[1] {
 			break
 		}
-		s4 := o4.Args[1]
-		if s4.Op != OpPPC64SLDconst {
+		s5 := o4.Args[1]
+		if s5.Op != OpPPC64SLDconst {
 			break
 		}
-		if s4.AuxInt != 40 {
+		if s5.AuxInt != 16 {
 			break
 		}
-		x5 := s4.Args[0]
+		x5 := s5.Args[0]
 		if x5.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12820,14 +23369,14 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x5.Args[1] {
 			break
 		}
-		s5 := o5.Args[1]
-		if s5.Op != OpPPC64SLDconst {
+		s6 := o5.Args[1]
+		if s6.Op != OpPPC64SLDconst {
 			break
 		}
-		if s5.AuxInt != 48 {
+		if s6.AuxInt != 8 {
 			break
 		}
-		x6 := s5.Args[0]
+		x6 := s6.Args[0]
 		if x6.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12842,14 +23391,7 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x6.Args[1] {
 			break
 		}
-		s6 := v.Args[1]
-		if s6.Op != OpPPC64SLDconst {
-			break
-		}
-		if s6.AuxInt != 56 {
-			break
-		}
-		x7 := s6.Args[0]
+		x7 := v.Args[1]
 		if x7.Op != OpPPC64MOVBZload {
 			break
 		}
@@ -12864,16 +23406,18 @@ func rewriteValuePPC64_OpPPC64OR_30(v *Value) bool {
 		if mem != x7.Args[1] {
 			break
 		}
-		if !(!config.BigEndian && i0%4 == 0 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x0.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x0, x4, x5, x6, x7) != nil && clobber(x0) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o3) && clobber(o4) && clobber(o5)) {
+		if !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(o3) && clobber(o4) && clobber(o5) && clobber(s0) && clobber(s4) && clobber(s5) && clobber(s6)) {
 			break
 		}
-		b = mergePoint(b, x0, x4, x5, x6, x7)
-		v0 := b.NewValue0(v.Pos, OpPPC64MOVDload, t)
+		b = mergePoint(b, x3, x4, x5, x6, x7)
+		v0 := b.NewValue0(v.Pos, OpPPC64MOVDBRload, t)
 		v.reset(OpCopy)
 		v.AddArg(v0)
-		v0.AuxInt = i0
-		v0.Aux = s
-		v0.AddArg(p)
+		v1 := b.NewValue0(v.Pos, OpPPC64MOVDaddr, typ.Uintptr)
+		v1.AuxInt = i0
+		v1.Aux = s
+		v1.AddArg(p)
+		v0.AddArg(v1)
 		v0.AddArg(mem)
 		return true
 	}
diff --git a/src/cmd/internal/obj/ppc64/asm9.go b/src/cmd/internal/obj/ppc64/asm9.go
index cf27a49cd0..756170bc55 100644
--- a/src/cmd/internal/obj/ppc64/asm9.go
+++ b/src/cmd/internal/obj/ppc64/asm9.go
@@ -4973,6 +4973,8 @@ func (c *ctxt9) opstorex(a obj.As) uint32 {
 		return OPVCC(31, 661, 0, 0) /* stswx */
 	case AMOVWBR:
 		return OPVCC(31, 662, 0, 0) /* stwbrx */
+	case AMOVDBR:
+		return OPVCC(31, 660, 0, 0) /* stdbrx */
 	case ASTBCCC:
 		return OPVCC(31, 694, 0, 1) /* stbcx. */
 	case ASTWCCC:
diff --git a/src/crypto/cipher/gcm.go b/src/crypto/cipher/gcm.go
index dd2cb9ce31..0ea053428c 100644
--- a/src/crypto/cipher/gcm.go
+++ b/src/crypto/cipher/gcm.go
@@ -413,6 +413,7 @@ func (g *gcm) auth(out, ciphertext, additionalData []byte, tagMask *[gcmTagSize]
 }
 
 func getUint64(data []byte) uint64 {
+	_ = data[7] // bounds check hint to compiler; see golang.org/issue/14808
 	r := uint64(data[0])<<56 |
 		uint64(data[1])<<48 |
 		uint64(data[2])<<40 |
@@ -425,6 +426,7 @@ func getUint64(data []byte) uint64 {
 }
 
 func putUint64(out []byte, v uint64) {
+	_ = out[7] // bounds check hint to compiler; see golang.org/issue/14808
 	out[0] = byte(v >> 56)
 	out[1] = byte(v >> 48)
 	out[2] = byte(v >> 40)
diff --git a/test/codegen/memcombine.go b/test/codegen/memcombine.go
index 08d2d91128..908da16fd8 100644
--- a/test/codegen/memcombine.go
+++ b/test/codegen/memcombine.go
@@ -69,6 +69,7 @@ func load_be64(b []byte) {
 	// amd64:`BSWAPQ`
 	// s390x:`MOVD\s\(.*\),`
 	// arm64:`REV`,`MOVD\s\(R[0-9]+\),`,-`MOV[BHW]`,-`REVW`,-`REV16W`
+	// ppc64le:`MOVDBR`
 	sink64 = binary.BigEndian.Uint64(b)
 }
 
@@ -76,6 +77,7 @@ func load_be64_idx(b []byte, idx int) {
 	// amd64:`BSWAPQ`
 	// s390x:`MOVD\s\(.*\)\(.*\*1\),`
 	// arm64:`REV`,`MOVD\s\(R[0-9]+\)\(R[0-9]+\),`,-`MOV[WHB]`,-`REVW`,-`REV16W`
+	// ppc64le:`MOVDBR`
 	sink64 = binary.BigEndian.Uint64(b[idx:])
 }
 
@@ -83,6 +85,7 @@ func load_be32(b []byte) {
 	// amd64:`BSWAPL`
 	// s390x:`MOVWZ\s\(.*\),`
 	// arm64:`REVW`,`MOVWU\s\(R[0-9]+\),`,-`MOV[BH]`,-`REV16W`
+	// ppc64le:`MOVWBR`
 	sink32 = binary.BigEndian.Uint32(b)
 }
 
@@ -90,18 +93,21 @@ func load_be32_idx(b []byte, idx int) {
 	// amd64:`BSWAPL`
 	// s390x:`MOVWZ\s\(.*\)\(.*\*1\),`
 	// arm64:`REVW`,`MOVWU\s\(R[0-9]+\)\(R[0-9]+\),`,-`MOV[HB]`,-`REV16W`
+	// ppc64le:`MOVWBR`
 	sink32 = binary.BigEndian.Uint32(b[idx:])
 }
 
 func load_be16(b []byte) {
 	// amd64:`ROLW\s\$8`
 	// arm64: `REV16W`,`MOVHU\s\(R[0-9]+\),`,-`MOVB`
+	// ppc64le:`MOVHBR`
 	sink16 = binary.BigEndian.Uint16(b)
 }
 
 func load_be16_idx(b []byte, idx int) {
 	// amd64:`ROLW\s\$8`
 	// arm64: `REV16W`,`MOVHU\s\(R[0-9]+\)\(R[0-9]+\),`,-`MOVB`
+	// ppc64le:`MOVHBR`
 	sink16 = binary.BigEndian.Uint16(b[idx:])
 }
 
@@ -203,50 +209,56 @@ func store_le32_idx(b []byte, idx int) {
 func store_le16(b []byte) {
 	// amd64:`MOVW\s`
 	// arm64:`MOVH`,-`MOVB`
-	// ppc64le(DISABLED):`MOVH\s`
+	// ppc64le:`MOVH\s`
 	binary.LittleEndian.PutUint16(b, sink16)
 }
 
 func store_le16_idx(b []byte, idx int) {
 	// amd64:`MOVW\s`
 	// arm64:`MOVH\sR[0-9]+,\s\(R[0-9]+\)\(R[0-9]+\)`,-`MOVB`
-	// ppc64le(DISABLED):`MOVH\s`
+	// ppc64le:`MOVH\s`
 	binary.LittleEndian.PutUint16(b[idx:], sink16)
 }
 
 func store_be64(b []byte) {
 	// amd64:`BSWAPQ`,-`SHR.`
 	// arm64:`MOVD`,`REV`,-`MOV[WBH]`,-`REVW`,-`REV16W`
+	// ppc64le:`MOVDBR`
 	binary.BigEndian.PutUint64(b, sink64)
 }
 
 func store_be64_idx(b []byte, idx int) {
 	// amd64:`BSWAPQ`,-`SHR.`
 	// arm64:`REV`,`MOVD\sR[0-9]+,\s\(R[0-9]+\)\(R[0-9]+\)`,-`MOV[BHW]`,-`REV16W`,-`REVW`
+	// ppc64le:`MOVDBR`
 	binary.BigEndian.PutUint64(b[idx:], sink64)
 }
 
 func store_be32(b []byte) {
 	// amd64:`BSWAPL`,-`SHR.`
 	// arm64:`MOVW`,`REVW`,-`MOV[BH]`,-`REV16W`
+	// ppc64le:`MOVWBR`
 	binary.BigEndian.PutUint32(b, sink32)
 }
 
 func store_be32_idx(b []byte, idx int) {
 	// amd64:`BSWAPL`,-`SHR.`
 	// arm64:`REVW`,`MOVW\sR[0-9]+,\s\(R[0-9]+\)\(R[0-9]+\)`,-`MOV[BH]`,-`REV16W`
+	// ppc64le:`MOVWBR`
 	binary.BigEndian.PutUint32(b[idx:], sink32)
 }
 
 func store_be16(b []byte) {
 	// amd64:`ROLW\s\$8`,-`SHR.`
 	// arm64:`MOVH`,`REV16W`,-`MOVB`
+	// ppc64le:`MOVHBR`
 	binary.BigEndian.PutUint16(b, sink16)
 }
 
 func store_be16_idx(b []byte, idx int) {
 	// amd64:`ROLW\s\$8`,-`SHR.`
 	// arm64:`MOVH\sR[0-9]+,\s\(R[0-9]+\)\(R[0-9]+\)`,`REV16W`,-`MOVB`
+	// ppc64le:`MOVHBR`
 	binary.BigEndian.PutUint16(b[idx:], sink16)
 }
 
