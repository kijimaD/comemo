commit ae26d57f96f38159bba8fed535879d5eb6188655
Author: Keith Randall <khr@google.com>
Date:   Tue Apr 24 13:05:53 2018 -0700

    cmd/compile: update SSA TODO file
    
    Get rid of a bunch of stuff we've already done.
    
    Change-Id: Ibae4be7535ddb58590a072a2390c5f3e948c2fd7
    Reviewed-on: https://go-review.googlesource.com/109136
    Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org>
---
 src/cmd/compile/internal/ssa/TODO | 30 ++++--------------------------
 1 file changed, 4 insertions(+), 26 deletions(-)

diff --git a/src/cmd/compile/internal/ssa/TODO b/src/cmd/compile/internal/ssa/TODO
index dad4880994..f4e438258c 100644
--- a/src/cmd/compile/internal/ssa/TODO
+++ b/src/cmd/compile/internal/ssa/TODO
@@ -1,28 +1,16 @@
-This is a list of things that need to be worked on.  It will hopefully
-be complete soon.
-
-Correctness
------------
-- Debugging info (check & fix as much as we can)
+This is a list of possible improvements to the SSA pass of the compiler.
 
 Optimizations (better compiled code)
 ------------------------------------
 - Reduce register pressure in scheduler
-- More strength reduction: multiply -> shift/add combos (Worth doing?)
-- Add a value range propagation pass (for bounds elim & bitwidth reduction)
 - Make dead store pass inter-block
 - If there are a lot of MOVQ $0, ..., then load
-  0 into a register and use the register as the source instead.
-- Allow arrays of length 1 (or longer, with all constant indexes?) to be SSAable.
+   0 into a register and use the register as the source instead.
+- Allow large structs to be SSAable (issue 24416)
+- Allow arrays of length >1 to be SSAable
 - If strings are being passed around without being interpreted (ptr
   and len fields being accessed) pass them in xmm registers?
   Same for interfaces?
-- Non-constant rotate detection.
-- Do 0 <= x && x < n with one unsigned compare
-- nil-check removal in indexed load/store case:
-    lea    (%rdx,%rax,1),%rcx
-    test   %al,(%rcx)           // nil check
-    mov    (%rdx,%rax,1),%cl    // load to same address
 - any pointer generated by unsafe arithmetic must be non-nil?
   (Of course that may not be true in general, but it is for all uses
    in the runtime, and we can play games with unsafe.)
@@ -33,14 +21,4 @@ Optimizations (better compiler)
 
 Regalloc
 --------
-- Make less arch-dependent
-- Handle 2-address instructions
 - Make liveness analysis non-quadratic
-
-Future/other
-------------
-- Start another architecture (arm?)
-- 64-bit ops on 32-bit machines
-- Should we get rid of named types in favor of underlying types during SSA generation?
-- Infrastructure for enabling/disabling/configuring passes
-- Modify logging for at least pass=1, to be Warnl compatible
