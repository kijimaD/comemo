commit 3d0397a4f4f4034f4cb330ec7e5b05a359a86196
Author: Russ Cox <rsc@golang.org>
Date:   Tue Mar 3 18:47:44 2015 -0500

    cmd/internal/obj/x86: change SHRQ to store second source in From3, not jammed into From
    
    SHRQ CX, DX:AX is changing to SHRQ CX, AX, DX.
    This is the first step: using SHRQ From=CX, From3=AX, To=DX
    as the preferred encoding.
    Once the assemblers and 6g have been updated,
    support for the old encoding can be removed.
    
    Change-Id: Ie603fb8ac25a6df78e42f7ddcae078a7684a7c26
    Reviewed-on: https://go-review.googlesource.com/6693
    Reviewed-by: Rob Pike <r@golang.org>
---
 src/cmd/internal/obj/x86/asm6.go | 58 ++++++++++++++++++++++++++++------------
 1 file changed, 41 insertions(+), 17 deletions(-)

diff --git a/src/cmd/internal/obj/x86/asm6.go b/src/cmd/internal/obj/x86/asm6.go
index ee73fb9717..7230ae86ae 100644
--- a/src/cmd/internal/obj/x86/asm6.go
+++ b/src/cmd/internal/obj/x86/asm6.go
@@ -69,7 +69,7 @@ type Movtab struct {
 }
 
 const (
-	Yxxx = 0 + iota
+	Yxxx = iota
 	Ynone
 	Yi0
 	Yi1
@@ -91,7 +91,6 @@ const (
 	Yml
 	Ym
 	Ybr
-	Ycol
 	Ycs
 	Yss
 	Yds
@@ -136,8 +135,12 @@ const (
 	Yxm
 	Ytls
 	Ytextsize
+	Yreg2
 	Ymax
-	Zxxx = 0 + iota - 68
+)
+
+const (
+	Zxxx = iota
 	Zlit
 	Zlitm_r
 	Z_rp
@@ -183,6 +186,9 @@ const (
 	Zclr
 	Zbyte
 	Zmax
+)
+
+const (
 	Px     = 0
 	P32    = 0x32
 	Pe     = 0x66
@@ -1908,9 +1914,27 @@ func oclass(ctxt *obj.Link, p *obj.Prog, a *obj.Addr) int {
 	// TODO(rsc): This special case is for SHRQ $3, AX:DX,
 	// which encodes as SHRQ $32(DX*0), AX.
 	// Similarly SHRQ CX, AX:DX is really SHRQ CX(DX*0), AX.
-	// Change encoding and remove.
-	if (a.Type == obj.TYPE_CONST || a.Type == obj.TYPE_REG) && a.Index != REG_NONE && a.Scale == 0 {
-		return Ycol
+	// Change encoding generated by assemblers and remove.
+	if a == &p.From && (a.Type == obj.TYPE_CONST || a.Type == obj.TYPE_REG) && a.Index != REG_NONE && a.Scale == 0 {
+		p.From3.Type = obj.TYPE_REG
+		p.From3.Reg = a.Index
+		a.Index = 0
+	}
+
+	// To avoid changing tables, the info about p.From and p.From3 are returned together.
+	if a == &p.From && p.From3.Type != obj.TYPE_NONE {
+		if (a.Type == obj.TYPE_CONST || a.Type == obj.TYPE_REG) && p.From3.Type == obj.TYPE_REG {
+			return Yreg2
+		}
+
+		switch p.As {
+		case obj.ATEXT, obj.ADATA, obj.AGLOBL:
+			// we know these use From3 - ignore that
+		default:
+			// unexpected use of From3. report invalid argument
+			ctxt.Diag("unexpected argument: %v", obj.Dconv(p, &p.From3))
+			return Yxxx
+		}
 	}
 
 	switch a.Type {
@@ -2684,17 +2708,18 @@ var ymovtab = []Movtab{
 	Movtab{AMOVW, Yml, Ytask, 4, [4]uint8{0x0f, 0x00, 3, 0}},
 	Movtab{AMOVW, Ytask, Yml, 3, [4]uint8{0x0f, 0x00, 1, 0}},
 
-	/* load full pointer */
+	/* load full pointer - unsupported
 	Movtab{AMOVL, Yml, Ycol, 5, [4]uint8{0, 0, 0, 0}},
 	Movtab{AMOVW, Yml, Ycol, 5, [4]uint8{Pe, 0, 0, 0}},
+	*/
 
 	/* double shift */
-	Movtab{ASHLL, Ycol, Yml, 6, [4]uint8{0xa4, 0xa5, 0, 0}},
-	Movtab{ASHRL, Ycol, Yml, 6, [4]uint8{0xac, 0xad, 0, 0}},
-	Movtab{ASHLQ, Ycol, Yml, 6, [4]uint8{Pw, 0xa4, 0xa5, 0}},
-	Movtab{ASHRQ, Ycol, Yml, 6, [4]uint8{Pw, 0xac, 0xad, 0}},
-	Movtab{ASHLW, Ycol, Yml, 6, [4]uint8{Pe, 0xa4, 0xa5, 0}},
-	Movtab{ASHRW, Ycol, Yml, 6, [4]uint8{Pe, 0xac, 0xad, 0}},
+	Movtab{ASHLL, Yreg2, Yml, 6, [4]uint8{0xa4, 0xa5, 0, 0}},
+	Movtab{ASHRL, Yreg2, Yml, 6, [4]uint8{0xac, 0xad, 0, 0}},
+	Movtab{ASHLQ, Yreg2, Yml, 6, [4]uint8{Pw, 0xa4, 0xa5, 0}},
+	Movtab{ASHRQ, Yreg2, Yml, 6, [4]uint8{Pw, 0xac, 0xad, 0}},
+	Movtab{ASHLW, Yreg2, Yml, 6, [4]uint8{Pe, 0xa4, 0xa5, 0}},
+	Movtab{ASHRW, Yreg2, Yml, 6, [4]uint8{Pe, 0xac, 0xad, 0}},
 
 	/* load TLS base */
 	Movtab{AMOVQ, Ytls, Yrl, 7, [4]uint8{0, 0, 0, 0}},
@@ -3490,7 +3515,7 @@ func doasm(ctxt *obj.Link, p *obj.Prog) {
 							ctxt.Andptr = ctxt.Andptr[1:]
 							ctxt.Andptr[0] = t[0]
 							ctxt.Andptr = ctxt.Andptr[1:]
-							asmandsz(ctxt, p, &p.To, reg[int(p.From.Index)], regrex[int(p.From.Index)], 0)
+							asmandsz(ctxt, p, &p.To, reg[p.From3.Reg], regrex[p.From3.Reg], 0)
 							ctxt.Andptr[0] = byte(p.From.Offset)
 							ctxt.Andptr = ctxt.Andptr[1:]
 
@@ -3499,13 +3524,12 @@ func doasm(ctxt *obj.Link, p *obj.Prog) {
 							default:
 								goto bad
 
-							case REG_CL,
-								REG_CX:
+							case REG_CL, REG_CX:
 								ctxt.Andptr[0] = 0x0f
 								ctxt.Andptr = ctxt.Andptr[1:]
 								ctxt.Andptr[0] = t[1]
 								ctxt.Andptr = ctxt.Andptr[1:]
-								asmandsz(ctxt, p, &p.To, reg[int(p.From.Index)], regrex[int(p.From.Index)], 0)
+								asmandsz(ctxt, p, &p.To, reg[p.From3.Reg], regrex[p.From3.Reg], 0)
 							}
 						}
 
