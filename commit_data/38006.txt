commit 01b7c2db156cc40e928bb95ec7f980f0ab22aa26
Author: Brad Fitzpatrick <bradfitz@golang.org>
Date:   Mon Sep 24 19:12:54 2018 +0000

    cmd/vendor: update golang.org/x/sys/windows for windows/arm support
    
    Updates to golang.org/x/sys git rev 90868a75f.
    
    Updates golang/go#26148
    
    Change-Id: Ic687e7e0e171690e8d937c7bb29b0e55316f874a
    Reviewed-on: https://go-review.googlesource.com/137015
    Reviewed-by: Ian Lance Taylor <iant@golang.org>
---
 src/cmd/vendor/golang.org/x/sys/windows/aliases.go |  13 ++
 .../golang.org/x/sys/windows/asm_windows_arm.s     |  11 ++
 .../x/sys/windows/registry/zsyscall_windows.go     |   2 +-
 .../golang.org/x/sys/windows/security_windows.go   |   4 +-
 src/cmd/vendor/golang.org/x/sys/windows/service.go |  18 +++
 .../golang.org/x/sys/windows/svc/mgr/config.go     |  38 +++--
 .../golang.org/x/sys/windows/svc/mgr/mgr_test.go   | 113 +++++++++++++
 .../golang.org/x/sys/windows/svc/mgr/recovery.go   | 135 ++++++++++++++++
 .../vendor/golang.org/x/sys/windows/svc/sys_arm.s  |  38 +++++
 .../golang.org/x/sys/windows/syscall_windows.go    |  60 ++++++-
 .../x/sys/windows/syscall_windows_test.go          |   6 +
 .../golang.org/x/sys/windows/types_windows.go      | 180 ++++++++++++++++++---
 .../golang.org/x/sys/windows/types_windows_arm.go  |  22 +++
 .../golang.org/x/sys/windows/zsyscall_windows.go   |   2 +-
 src/cmd/vendor/vendor.json                         |  32 ++--
 15 files changed, 613 insertions(+), 61 deletions(-)

diff --git a/src/cmd/vendor/golang.org/x/sys/windows/aliases.go b/src/cmd/vendor/golang.org/x/sys/windows/aliases.go
new file mode 100644
index 0000000000..af3af60db9
--- /dev/null
+++ b/src/cmd/vendor/golang.org/x/sys/windows/aliases.go
@@ -0,0 +1,13 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build windows
+// +build go1.9
+
+package windows
+
+import "syscall"
+
+type Errno = syscall.Errno
+type SysProcAttr = syscall.SysProcAttr
diff --git a/src/cmd/vendor/golang.org/x/sys/windows/asm_windows_arm.s b/src/cmd/vendor/golang.org/x/sys/windows/asm_windows_arm.s
new file mode 100644
index 0000000000..55d8b91a28
--- /dev/null
+++ b/src/cmd/vendor/golang.org/x/sys/windows/asm_windows_arm.s
@@ -0,0 +1,11 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+#include "textflag.h"
+
+TEXT 路getprocaddress(SB),NOSPLIT,$0
+	B	syscall路getprocaddress(SB)
+
+TEXT 路loadlibrary(SB),NOSPLIT,$0
+	B	syscall路loadlibrary(SB)
diff --git a/src/cmd/vendor/golang.org/x/sys/windows/registry/zsyscall_windows.go b/src/cmd/vendor/golang.org/x/sys/windows/registry/zsyscall_windows.go
index ceebdd7726..3778075da0 100644
--- a/src/cmd/vendor/golang.org/x/sys/windows/registry/zsyscall_windows.go
+++ b/src/cmd/vendor/golang.org/x/sys/windows/registry/zsyscall_windows.go
@@ -1,4 +1,4 @@
-// MACHINE GENERATED BY 'go generate' COMMAND; DO NOT EDIT
+// Code generated by 'go generate'; DO NOT EDIT.
 
 package registry
 
diff --git a/src/cmd/vendor/golang.org/x/sys/windows/security_windows.go b/src/cmd/vendor/golang.org/x/sys/windows/security_windows.go
index f1ec5dc4ee..4f17a3331f 100644
--- a/src/cmd/vendor/golang.org/x/sys/windows/security_windows.go
+++ b/src/cmd/vendor/golang.org/x/sys/windows/security_windows.go
@@ -296,6 +296,7 @@ const (
 	TOKEN_ADJUST_PRIVILEGES
 	TOKEN_ADJUST_GROUPS
 	TOKEN_ADJUST_DEFAULT
+	TOKEN_ADJUST_SESSIONID
 
 	TOKEN_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED |
 		TOKEN_ASSIGN_PRIMARY |
@@ -305,7 +306,8 @@ const (
 		TOKEN_QUERY_SOURCE |
 		TOKEN_ADJUST_PRIVILEGES |
 		TOKEN_ADJUST_GROUPS |
-		TOKEN_ADJUST_DEFAULT
+		TOKEN_ADJUST_DEFAULT |
+		TOKEN_ADJUST_SESSIONID
 	TOKEN_READ  = STANDARD_RIGHTS_READ | TOKEN_QUERY
 	TOKEN_WRITE = STANDARD_RIGHTS_WRITE |
 		TOKEN_ADJUST_PRIVILEGES |
diff --git a/src/cmd/vendor/golang.org/x/sys/windows/service.go b/src/cmd/vendor/golang.org/x/sys/windows/service.go
index 24aa90bbbe..62fc31b40b 100644
--- a/src/cmd/vendor/golang.org/x/sys/windows/service.go
+++ b/src/cmd/vendor/golang.org/x/sys/windows/service.go
@@ -43,6 +43,11 @@ const (
 
 	SC_STATUS_PROCESS_INFO = 0
 
+	SC_ACTION_NONE        = 0
+	SC_ACTION_RESTART     = 1
+	SC_ACTION_REBOOT      = 2
+	SC_ACTION_RUN_COMMAND = 3
+
 	SERVICE_STOPPED          = 1
 	SERVICE_START_PENDING    = 2
 	SERVICE_STOP_PENDING     = 3
@@ -148,6 +153,19 @@ type ENUM_SERVICE_STATUS_PROCESS struct {
 	ServiceStatusProcess SERVICE_STATUS_PROCESS
 }
 
+type SERVICE_FAILURE_ACTIONS struct {
+	ResetPeriod  uint32
+	RebootMsg    *uint16
+	Command      *uint16
+	ActionsCount uint32
+	Actions      *SC_ACTION
+}
+
+type SC_ACTION struct {
+	Type  uint32
+	Delay uint32
+}
+
 //sys	CloseServiceHandle(handle Handle) (err error) = advapi32.CloseServiceHandle
 //sys	CreateService(mgr Handle, serviceName *uint16, displayName *uint16, access uint32, srvType uint32, startType uint32, errCtl uint32, pathName *uint16, loadOrderGroup *uint16, tagId *uint32, dependencies *uint16, serviceStartName *uint16, password *uint16) (handle Handle, err error) [failretval==0] = advapi32.CreateServiceW
 //sys	OpenService(mgr Handle, serviceName *uint16, access uint32) (handle Handle, err error) [failretval==0] = advapi32.OpenServiceW
diff --git a/src/cmd/vendor/golang.org/x/sys/windows/svc/mgr/config.go b/src/cmd/vendor/golang.org/x/sys/windows/svc/mgr/config.go
index 03bf41f516..d804e31f1f 100644
--- a/src/cmd/vendor/golang.org/x/sys/windows/svc/mgr/config.go
+++ b/src/cmd/vendor/golang.org/x/sys/windows/svc/mgr/config.go
@@ -88,23 +88,11 @@ func (s *Service) Config() (Config, error) {
 		}
 	}
 
-	var p2 *windows.SERVICE_DESCRIPTION
-	n = uint32(1024)
-	for {
-		b := make([]byte, n)
-		p2 = (*windows.SERVICE_DESCRIPTION)(unsafe.Pointer(&b[0]))
-		err := windows.QueryServiceConfig2(s.Handle,
-			windows.SERVICE_CONFIG_DESCRIPTION, &b[0], n, &n)
-		if err == nil {
-			break
-		}
-		if err.(syscall.Errno) != syscall.ERROR_INSUFFICIENT_BUFFER {
-			return Config{}, err
-		}
-		if n <= uint32(len(b)) {
-			return Config{}, err
-		}
+	b, err := s.queryServiceConfig2(windows.SERVICE_CONFIG_DESCRIPTION)
+	if err != nil {
+		return Config{}, err
 	}
+	p2 := (*windows.SERVICE_DESCRIPTION)(unsafe.Pointer(&b[0]))
 
 	return Config{
 		ServiceType:      p.ServiceType,
@@ -137,3 +125,21 @@ func (s *Service) UpdateConfig(c Config) error {
 	}
 	return updateDescription(s.Handle, c.Description)
 }
+
+// queryServiceConfig2 calls Windows QueryServiceConfig2 with infoLevel parameter and returns retrieved service configuration information.
+func (s *Service) queryServiceConfig2(infoLevel uint32) ([]byte, error) {
+	n := uint32(1024)
+	for {
+		b := make([]byte, n)
+		err := windows.QueryServiceConfig2(s.Handle, infoLevel, &b[0], n, &n)
+		if err == nil {
+			return b, nil
+		}
+		if err.(syscall.Errno) != syscall.ERROR_INSUFFICIENT_BUFFER {
+			return nil, err
+		}
+		if n <= uint32(len(b)) {
+			return nil, err
+		}
+	}
+}
diff --git a/src/cmd/vendor/golang.org/x/sys/windows/svc/mgr/mgr_test.go b/src/cmd/vendor/golang.org/x/sys/windows/svc/mgr/mgr_test.go
index 1569a22177..9171f5bcf1 100644
--- a/src/cmd/vendor/golang.org/x/sys/windows/svc/mgr/mgr_test.go
+++ b/src/cmd/vendor/golang.org/x/sys/windows/svc/mgr/mgr_test.go
@@ -95,6 +95,113 @@ func testConfig(t *testing.T, s *mgr.Service, should mgr.Config) mgr.Config {
 	return is
 }
 
+func testRecoveryActions(t *testing.T, s *mgr.Service, should []mgr.RecoveryAction) {
+	is, err := s.RecoveryActions()
+	if err != nil {
+		t.Fatalf("RecoveryActions failed: %s", err)
+	}
+	if len(should) != len(is) {
+		t.Errorf("recovery action mismatch: contains %v actions, but should have %v", len(is), len(should))
+	}
+	for i, _ := range is {
+		if should[i].Type != is[i].Type {
+			t.Errorf("recovery action mismatch: Type is %v, but should have %v", is[i].Type, should[i].Type)
+		}
+		if should[i].Delay != is[i].Delay {
+			t.Errorf("recovery action mismatch: Delay is %v, but should have %v", is[i].Delay, should[i].Delay)
+		}
+	}
+}
+
+func testResetPeriod(t *testing.T, s *mgr.Service, should uint32) {
+	is, err := s.ResetPeriod()
+	if err != nil {
+		t.Fatalf("ResetPeriod failed: %s", err)
+	}
+	if should != is {
+		t.Errorf("reset period mismatch: reset period is %v, but should have %v", is, should)
+	}
+}
+
+func testSetRecoveryActions(t *testing.T, s *mgr.Service) {
+	r := []mgr.RecoveryAction{
+		mgr.RecoveryAction{
+			Type:  mgr.NoAction,
+			Delay: 60000 * time.Millisecond,
+		},
+		mgr.RecoveryAction{
+			Type:  mgr.ServiceRestart,
+			Delay: 4 * time.Minute,
+		},
+		mgr.RecoveryAction{
+			Type:  mgr.ServiceRestart,
+			Delay: time.Minute,
+		},
+		mgr.RecoveryAction{
+			Type:  mgr.RunCommand,
+			Delay: 4000 * time.Millisecond,
+		},
+	}
+
+	// 4 recovery actions with reset period
+	err := s.SetRecoveryActions(r, uint32(10000))
+	if err != nil {
+		t.Fatalf("SetRecoveryActions failed: %v", err)
+	}
+	testRecoveryActions(t, s, r)
+	testResetPeriod(t, s, uint32(10000))
+
+	// Infinite reset period
+	err = s.SetRecoveryActions(r, syscall.INFINITE)
+	if err != nil {
+		t.Fatalf("SetRecoveryActions failed: %v", err)
+	}
+	testRecoveryActions(t, s, r)
+	testResetPeriod(t, s, syscall.INFINITE)
+
+	// nil recovery actions
+	err = s.SetRecoveryActions(nil, 0)
+	if err.Error() != "recoveryActions cannot be nil" {
+		t.Fatalf("SetRecoveryActions failed with unexpected error message of %q", err)
+	}
+
+	// Delete all recovery actions and reset period
+	err = s.ResetRecoveryActions()
+	if err != nil {
+		t.Fatalf("ResetRecoveryActions failed: %v", err)
+	}
+	testRecoveryActions(t, s, nil)
+	testResetPeriod(t, s, 0)
+}
+
+func testRebootMessage(t *testing.T, s *mgr.Service, should string) {
+	err := s.SetRebootMessage(should)
+	if err != nil {
+		t.Fatalf("SetRebootMessage failed: %v", err)
+	}
+	is, err := s.RebootMessage()
+	if err != nil {
+		t.Fatalf("RebootMessage failed: %v", err)
+	}
+	if should != is {
+		t.Errorf("reboot message mismatch: message is %q, but should have %q", is, should)
+	}
+}
+
+func testRecoveryCommand(t *testing.T, s *mgr.Service, should string) {
+	err := s.SetRecoveryCommand(should)
+	if err != nil {
+		t.Fatalf("SetRecoveryCommand failed: %v", err)
+	}
+	is, err := s.RecoveryCommand()
+	if err != nil {
+		t.Fatalf("RecoveryCommand failed: %v", err)
+	}
+	if should != is {
+		t.Errorf("recovery command mismatch: command is %q, but should have %q", is, should)
+	}
+}
+
 func remove(t *testing.T, s *mgr.Service) {
 	err := s.Delete()
 	if err != nil {
@@ -165,5 +272,11 @@ func TestMyService(t *testing.T) {
 		t.Errorf("ListServices failed to find %q service", name)
 	}
 
+	testSetRecoveryActions(t, s)
+	testRebootMessage(t, s, "myservice failed")
+	testRebootMessage(t, s, "") // delete reboot message
+	testRecoveryCommand(t, s, "sc query myservice")
+	testRecoveryCommand(t, s, "") // delete recovery command
+
 	remove(t, s)
 }
diff --git a/src/cmd/vendor/golang.org/x/sys/windows/svc/mgr/recovery.go b/src/cmd/vendor/golang.org/x/sys/windows/svc/mgr/recovery.go
new file mode 100644
index 0000000000..71ce2b8199
--- /dev/null
+++ b/src/cmd/vendor/golang.org/x/sys/windows/svc/mgr/recovery.go
@@ -0,0 +1,135 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build windows
+
+package mgr
+
+import (
+	"errors"
+	"syscall"
+	"time"
+	"unsafe"
+
+	"golang.org/x/sys/windows"
+)
+
+const (
+	// Possible recovery actions that the service control manager can perform.
+	NoAction       = windows.SC_ACTION_NONE        // no action
+	ComputerReboot = windows.SC_ACTION_REBOOT      // reboot the computer
+	ServiceRestart = windows.SC_ACTION_RESTART     // restart the service
+	RunCommand     = windows.SC_ACTION_RUN_COMMAND // run a command
+)
+
+// RecoveryAction represents an action that the service control manager can perform when service fails.
+// A service is considered failed when it terminates without reporting a status of SERVICE_STOPPED to the service controller.
+type RecoveryAction struct {
+	Type  int           // one of NoAction, ComputerReboot, ServiceRestart or RunCommand
+	Delay time.Duration // the time to wait before performing the specified action
+}
+
+// SetRecoveryActions sets actions that service controller performs when service fails and
+// the time after which to reset the service failure count to zero if there are no failures, in seconds.
+// Specify INFINITE to indicate that service failure count should never be reset.
+func (s *Service) SetRecoveryActions(recoveryActions []RecoveryAction, resetPeriod uint32) error {
+	if recoveryActions == nil {
+		return errors.New("recoveryActions cannot be nil")
+	}
+	actions := []windows.SC_ACTION{}
+	for _, a := range recoveryActions {
+		action := windows.SC_ACTION{
+			Type:  uint32(a.Type),
+			Delay: uint32(a.Delay.Nanoseconds() / 1000000),
+		}
+		actions = append(actions, action)
+	}
+	rActions := windows.SERVICE_FAILURE_ACTIONS{
+		ActionsCount: uint32(len(actions)),
+		Actions:      &actions[0],
+		ResetPeriod:  resetPeriod,
+	}
+	return windows.ChangeServiceConfig2(s.Handle, windows.SERVICE_CONFIG_FAILURE_ACTIONS, (*byte)(unsafe.Pointer(&rActions)))
+}
+
+// RecoveryActions returns actions that service controller performs when service fails.
+// The service control manager counts the number of times service s has failed since the system booted.
+// The count is reset to 0 if the service has not failed for ResetPeriod seconds.
+// When the service fails for the Nth time, the service controller performs the action specified in element [N-1] of returned slice.
+// If N is greater than slice length, the service controller repeats the last action in the slice.
+func (s *Service) RecoveryActions() ([]RecoveryAction, error) {
+	b, err := s.queryServiceConfig2(windows.SERVICE_CONFIG_FAILURE_ACTIONS)
+	if err != nil {
+		return nil, err
+	}
+	p := (*windows.SERVICE_FAILURE_ACTIONS)(unsafe.Pointer(&b[0]))
+	if p.Actions == nil {
+		return nil, err
+	}
+
+	var recoveryActions []RecoveryAction
+	actions := (*[1024]windows.SC_ACTION)(unsafe.Pointer(p.Actions))[:p.ActionsCount]
+	for _, action := range actions {
+		recoveryActions = append(recoveryActions, RecoveryAction{Type: int(action.Type), Delay: time.Duration(action.Delay) * time.Millisecond})
+	}
+	return recoveryActions, nil
+}
+
+// ResetRecoveryActions deletes both reset period and array of failure actions.
+func (s *Service) ResetRecoveryActions() error {
+	actions := make([]windows.SC_ACTION, 1)
+	rActions := windows.SERVICE_FAILURE_ACTIONS{
+		Actions: &actions[0],
+	}
+	return windows.ChangeServiceConfig2(s.Handle, windows.SERVICE_CONFIG_FAILURE_ACTIONS, (*byte)(unsafe.Pointer(&rActions)))
+}
+
+// ResetPeriod is the time after which to reset the service failure
+// count to zero if there are no failures, in seconds.
+func (s *Service) ResetPeriod() (uint32, error) {
+	b, err := s.queryServiceConfig2(windows.SERVICE_CONFIG_FAILURE_ACTIONS)
+	if err != nil {
+		return 0, err
+	}
+	p := (*windows.SERVICE_FAILURE_ACTIONS)(unsafe.Pointer(&b[0]))
+	return p.ResetPeriod, nil
+}
+
+// SetRebootMessage sets service s reboot message.
+// If msg is "", the reboot message is deleted and no message is broadcast.
+func (s *Service) SetRebootMessage(msg string) error {
+	rActions := windows.SERVICE_FAILURE_ACTIONS{
+		RebootMsg: syscall.StringToUTF16Ptr(msg),
+	}
+	return windows.ChangeServiceConfig2(s.Handle, windows.SERVICE_CONFIG_FAILURE_ACTIONS, (*byte)(unsafe.Pointer(&rActions)))
+}
+
+// RebootMessage is broadcast to server users before rebooting in response to the ComputerReboot service controller action.
+func (s *Service) RebootMessage() (string, error) {
+	b, err := s.queryServiceConfig2(windows.SERVICE_CONFIG_FAILURE_ACTIONS)
+	if err != nil {
+		return "", err
+	}
+	p := (*windows.SERVICE_FAILURE_ACTIONS)(unsafe.Pointer(&b[0]))
+	return toString(p.RebootMsg), nil
+}
+
+// SetRecoveryCommand sets the command line of the process to execute in response to the RunCommand service controller action.
+// If cmd is "", the command is deleted and no program is run when the service fails.
+func (s *Service) SetRecoveryCommand(cmd string) error {
+	rActions := windows.SERVICE_FAILURE_ACTIONS{
+		Command: syscall.StringToUTF16Ptr(cmd),
+	}
+	return windows.ChangeServiceConfig2(s.Handle, windows.SERVICE_CONFIG_FAILURE_ACTIONS, (*byte)(unsafe.Pointer(&rActions)))
+}
+
+// RecoveryCommand is the command line of the process to execute in response to the RunCommand service controller action. This process runs under the same account as the service.
+func (s *Service) RecoveryCommand() (string, error) {
+	b, err := s.queryServiceConfig2(windows.SERVICE_CONFIG_FAILURE_ACTIONS)
+	if err != nil {
+		return "", err
+	}
+	p := (*windows.SERVICE_FAILURE_ACTIONS)(unsafe.Pointer(&b[0]))
+	return toString(p.Command), nil
+}
diff --git a/src/cmd/vendor/golang.org/x/sys/windows/svc/sys_arm.s b/src/cmd/vendor/golang.org/x/sys/windows/svc/sys_arm.s
new file mode 100644
index 0000000000..33c692a8de
--- /dev/null
+++ b/src/cmd/vendor/golang.org/x/sys/windows/svc/sys_arm.s
@@ -0,0 +1,38 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build windows
+
+#include "textflag.h"
+
+// func servicemain(argc uint32, argv **uint16)
+TEXT 路servicemain(SB),NOSPLIT|NOFRAME,$0
+	MOVM.DB.W [R4, R14], (R13)	// push {r4, lr}
+	MOVW    R13, R4
+	BIC     $0x7, R13		// alignment for ABI
+
+	MOVW	R0, 路sArgc(SB)
+	MOVW	R1, 路sArgv(SB)
+
+	MOVW	路sName(SB), R0
+	MOVW	路ctlHandlerExProc(SB), R1
+	MOVW	$0, R2
+	MOVW	路cRegisterServiceCtrlHandlerExW(SB), R3
+	BL      (R3)
+	CMP     $0, R0
+	BEQ     exit
+	MOVW	R0, 路ssHandle(SB)
+
+	MOVW	路goWaitsH(SB), R0
+	MOVW	路cSetEvent(SB), R1
+	BL      (R1)
+
+	MOVW	路cWaitsH(SB), R0
+	MOVW	$-1, R1
+	MOVW	路cWaitForSingleObject(SB), R2
+	BL      (R2)
+
+exit:
+	MOVW	R4, R13			// free extra stack space
+	MOVM.IA.W (R13), [R4, R15]	// pop {r4, pc}
diff --git a/src/cmd/vendor/golang.org/x/sys/windows/syscall_windows.go b/src/cmd/vendor/golang.org/x/sys/windows/syscall_windows.go
index 1e9f4bb4a3..8a00b71f1d 100644
--- a/src/cmd/vendor/golang.org/x/sys/windows/syscall_windows.go
+++ b/src/cmd/vendor/golang.org/x/sys/windows/syscall_windows.go
@@ -112,12 +112,14 @@ func Getpagesize() int { return 4096 }
 
 // NewCallback converts a Go function to a function pointer conforming to the stdcall calling convention.
 // This is useful when interoperating with Windows code requiring callbacks.
+// The argument is expected to be a function with with one uintptr-sized result. The function must not have arguments with size larger than the size of uintptr.
 func NewCallback(fn interface{}) uintptr {
 	return syscall.NewCallback(fn)
 }
 
 // NewCallbackCDecl converts a Go function to a function pointer conforming to the cdecl calling convention.
 // This is useful when interoperating with Windows code requiring callbacks.
+// The argument is expected to be a function with with one uintptr-sized result. The function must not have arguments with size larger than the size of uintptr.
 func NewCallbackCDecl(fn interface{}) uintptr {
 	return syscall.NewCallbackCDecl(fn)
 }
@@ -653,7 +655,7 @@ type RawSockaddr struct {
 
 type RawSockaddrAny struct {
 	Addr RawSockaddr
-	Pad  [96]int8
+	Pad  [100]int8
 }
 
 type Sockaddr interface {
@@ -702,19 +704,69 @@ func (sa *SockaddrInet6) sockaddr() (unsafe.Pointer, int32, error) {
 	return unsafe.Pointer(&sa.raw), int32(unsafe.Sizeof(sa.raw)), nil
 }
 
+type RawSockaddrUnix struct {
+	Family uint16
+	Path   [UNIX_PATH_MAX]int8
+}
+
 type SockaddrUnix struct {
 	Name string
+	raw  RawSockaddrUnix
 }
 
 func (sa *SockaddrUnix) sockaddr() (unsafe.Pointer, int32, error) {
-	// TODO(brainman): implement SockaddrUnix.sockaddr()
-	return nil, 0, syscall.EWINDOWS
+	name := sa.Name
+	n := len(name)
+	if n > len(sa.raw.Path) {
+		return nil, 0, syscall.EINVAL
+	}
+	if n == len(sa.raw.Path) && name[0] != '@' {
+		return nil, 0, syscall.EINVAL
+	}
+	sa.raw.Family = AF_UNIX
+	for i := 0; i < n; i++ {
+		sa.raw.Path[i] = int8(name[i])
+	}
+	// length is family (uint16), name, NUL.
+	sl := int32(2)
+	if n > 0 {
+		sl += int32(n) + 1
+	}
+	if sa.raw.Path[0] == '@' {
+		sa.raw.Path[0] = 0
+		// Don't count trailing NUL for abstract address.
+		sl--
+	}
+
+	return unsafe.Pointer(&sa.raw), sl, nil
 }
 
 func (rsa *RawSockaddrAny) Sockaddr() (Sockaddr, error) {
 	switch rsa.Addr.Family {
 	case AF_UNIX:
-		return nil, syscall.EWINDOWS
+		pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))
+		sa := new(SockaddrUnix)
+		if pp.Path[0] == 0 {
+			// "Abstract" Unix domain socket.
+			// Rewrite leading NUL as @ for textual display.
+			// (This is the standard convention.)
+			// Not friendly to overwrite in place,
+			// but the callers below don't care.
+			pp.Path[0] = '@'
+		}
+
+		// Assume path ends at NUL.
+		// This is not technically the Linux semantics for
+		// abstract Unix domain sockets--they are supposed
+		// to be uninterpreted fixed-size binary blobs--but
+		// everyone uses this convention.
+		n := 0
+		for n < len(pp.Path) && pp.Path[n] != 0 {
+			n++
+		}
+		bytes := (*[10000]byte)(unsafe.Pointer(&pp.Path[0]))[0:n]
+		sa.Name = string(bytes)
+		return sa, nil
 
 	case AF_INET:
 		pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))
diff --git a/src/cmd/vendor/golang.org/x/sys/windows/syscall_windows_test.go b/src/cmd/vendor/golang.org/x/sys/windows/syscall_windows_test.go
index 9c7133cc41..0e27464e8c 100644
--- a/src/cmd/vendor/golang.org/x/sys/windows/syscall_windows_test.go
+++ b/src/cmd/vendor/golang.org/x/sys/windows/syscall_windows_test.go
@@ -105,3 +105,9 @@ func ExampleLoadLibrary() {
 	build := uint16(r >> 16)
 	print("windows version ", major, ".", minor, " (Build ", build, ")\n")
 }
+
+func TestTOKEN_ALL_ACCESS(t *testing.T) {
+	if windows.TOKEN_ALL_ACCESS != 0xF01FF {
+		t.Errorf("TOKEN_ALL_ACCESS = %x, want 0xF01FF", windows.TOKEN_ALL_ACCESS)
+	}
+}
diff --git a/src/cmd/vendor/golang.org/x/sys/windows/types_windows.go b/src/cmd/vendor/golang.org/x/sys/windows/types_windows.go
index 52c2037b68..141ca81bd7 100644
--- a/src/cmd/vendor/golang.org/x/sys/windows/types_windows.go
+++ b/src/cmd/vendor/golang.org/x/sys/windows/types_windows.go
@@ -94,16 +94,29 @@ const (
 	FILE_APPEND_DATA      = 0x00000004
 	FILE_WRITE_ATTRIBUTES = 0x00000100
 
-	FILE_SHARE_READ              = 0x00000001
-	FILE_SHARE_WRITE             = 0x00000002
-	FILE_SHARE_DELETE            = 0x00000004
-	FILE_ATTRIBUTE_READONLY      = 0x00000001
-	FILE_ATTRIBUTE_HIDDEN        = 0x00000002
-	FILE_ATTRIBUTE_SYSTEM        = 0x00000004
-	FILE_ATTRIBUTE_DIRECTORY     = 0x00000010
-	FILE_ATTRIBUTE_ARCHIVE       = 0x00000020
-	FILE_ATTRIBUTE_NORMAL        = 0x00000080
-	FILE_ATTRIBUTE_REPARSE_POINT = 0x00000400
+	FILE_SHARE_READ   = 0x00000001
+	FILE_SHARE_WRITE  = 0x00000002
+	FILE_SHARE_DELETE = 0x00000004
+
+	FILE_ATTRIBUTE_READONLY              = 0x00000001
+	FILE_ATTRIBUTE_HIDDEN                = 0x00000002
+	FILE_ATTRIBUTE_SYSTEM                = 0x00000004
+	FILE_ATTRIBUTE_DIRECTORY             = 0x00000010
+	FILE_ATTRIBUTE_ARCHIVE               = 0x00000020
+	FILE_ATTRIBUTE_DEVICE                = 0x00000040
+	FILE_ATTRIBUTE_NORMAL                = 0x00000080
+	FILE_ATTRIBUTE_TEMPORARY             = 0x00000100
+	FILE_ATTRIBUTE_SPARSE_FILE           = 0x00000200
+	FILE_ATTRIBUTE_REPARSE_POINT         = 0x00000400
+	FILE_ATTRIBUTE_COMPRESSED            = 0x00000800
+	FILE_ATTRIBUTE_OFFLINE               = 0x00001000
+	FILE_ATTRIBUTE_NOT_CONTENT_INDEXED   = 0x00002000
+	FILE_ATTRIBUTE_ENCRYPTED             = 0x00004000
+	FILE_ATTRIBUTE_INTEGRITY_STREAM      = 0x00008000
+	FILE_ATTRIBUTE_VIRTUAL               = 0x00010000
+	FILE_ATTRIBUTE_NO_SCRUB_DATA         = 0x00020000
+	FILE_ATTRIBUTE_RECALL_ON_OPEN        = 0x00040000
+	FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS = 0x00400000
 
 	INVALID_FILE_ATTRIBUTES = 0xffffffff
 
@@ -257,15 +270,87 @@ const (
 	USAGE_MATCH_TYPE_AND = 0
 	USAGE_MATCH_TYPE_OR  = 1
 
+	/* msgAndCertEncodingType values for CertOpenStore function */
 	X509_ASN_ENCODING   = 0x00000001
 	PKCS_7_ASN_ENCODING = 0x00010000
 
-	CERT_STORE_PROV_MEMORY = 2
-
-	CERT_STORE_ADD_ALWAYS = 4
-
+	/* storeProvider values for CertOpenStore function */
+	CERT_STORE_PROV_MSG               = 1
+	CERT_STORE_PROV_MEMORY            = 2
+	CERT_STORE_PROV_FILE              = 3
+	CERT_STORE_PROV_REG               = 4
+	CERT_STORE_PROV_PKCS7             = 5
+	CERT_STORE_PROV_SERIALIZED        = 6
+	CERT_STORE_PROV_FILENAME_A        = 7
+	CERT_STORE_PROV_FILENAME_W        = 8
+	CERT_STORE_PROV_FILENAME          = CERT_STORE_PROV_FILENAME_W
+	CERT_STORE_PROV_SYSTEM_A          = 9
+	CERT_STORE_PROV_SYSTEM_W          = 10
+	CERT_STORE_PROV_SYSTEM            = CERT_STORE_PROV_SYSTEM_W
+	CERT_STORE_PROV_COLLECTION        = 11
+	CERT_STORE_PROV_SYSTEM_REGISTRY_A = 12
+	CERT_STORE_PROV_SYSTEM_REGISTRY_W = 13
+	CERT_STORE_PROV_SYSTEM_REGISTRY   = CERT_STORE_PROV_SYSTEM_REGISTRY_W
+	CERT_STORE_PROV_PHYSICAL_W        = 14
+	CERT_STORE_PROV_PHYSICAL          = CERT_STORE_PROV_PHYSICAL_W
+	CERT_STORE_PROV_SMART_CARD_W      = 15
+	CERT_STORE_PROV_SMART_CARD        = CERT_STORE_PROV_SMART_CARD_W
+	CERT_STORE_PROV_LDAP_W            = 16
+	CERT_STORE_PROV_LDAP              = CERT_STORE_PROV_LDAP_W
+	CERT_STORE_PROV_PKCS12            = 17
+
+	/* store characteristics (low WORD of flag) for CertOpenStore function */
+	CERT_STORE_NO_CRYPT_RELEASE_FLAG            = 0x00000001
+	CERT_STORE_SET_LOCALIZED_NAME_FLAG          = 0x00000002
 	CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG = 0x00000004
-
+	CERT_STORE_DELETE_FLAG                      = 0x00000010
+	CERT_STORE_UNSAFE_PHYSICAL_FLAG             = 0x00000020
+	CERT_STORE_SHARE_STORE_FLAG                 = 0x00000040
+	CERT_STORE_SHARE_CONTEXT_FLAG               = 0x00000080
+	CERT_STORE_MANIFOLD_FLAG                    = 0x00000100
+	CERT_STORE_ENUM_ARCHIVED_FLAG               = 0x00000200
+	CERT_STORE_UPDATE_KEYID_FLAG                = 0x00000400
+	CERT_STORE_BACKUP_RESTORE_FLAG              = 0x00000800
+	CERT_STORE_MAXIMUM_ALLOWED_FLAG             = 0x00001000
+	CERT_STORE_CREATE_NEW_FLAG                  = 0x00002000
+	CERT_STORE_OPEN_EXISTING_FLAG               = 0x00004000
+	CERT_STORE_READONLY_FLAG                    = 0x00008000
+
+	/* store locations (high WORD of flag) for CertOpenStore function */
+	CERT_SYSTEM_STORE_CURRENT_USER               = 0x00010000
+	CERT_SYSTEM_STORE_LOCAL_MACHINE              = 0x00020000
+	CERT_SYSTEM_STORE_CURRENT_SERVICE            = 0x00040000
+	CERT_SYSTEM_STORE_SERVICES                   = 0x00050000
+	CERT_SYSTEM_STORE_USERS                      = 0x00060000
+	CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY  = 0x00070000
+	CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY = 0x00080000
+	CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE   = 0x00090000
+	CERT_SYSTEM_STORE_UNPROTECTED_FLAG           = 0x40000000
+	CERT_SYSTEM_STORE_RELOCATE_FLAG              = 0x80000000
+
+	/* Miscellaneous high-WORD flags for CertOpenStore function */
+	CERT_REGISTRY_STORE_REMOTE_FLAG      = 0x00010000
+	CERT_REGISTRY_STORE_SERIALIZED_FLAG  = 0x00020000
+	CERT_REGISTRY_STORE_ROAMING_FLAG     = 0x00040000
+	CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG = 0x00080000
+	CERT_REGISTRY_STORE_LM_GPT_FLAG      = 0x01000000
+	CERT_REGISTRY_STORE_CLIENT_GPT_FLAG  = 0x80000000
+	CERT_FILE_STORE_COMMIT_ENABLE_FLAG   = 0x00010000
+	CERT_LDAP_STORE_SIGN_FLAG            = 0x00010000
+	CERT_LDAP_STORE_AREC_EXCLUSIVE_FLAG  = 0x00020000
+	CERT_LDAP_STORE_OPENED_FLAG          = 0x00040000
+	CERT_LDAP_STORE_UNBIND_FLAG          = 0x00080000
+
+	/* addDisposition values for CertAddCertificateContextToStore function */
+	CERT_STORE_ADD_NEW                                 = 1
+	CERT_STORE_ADD_USE_EXISTING                        = 2
+	CERT_STORE_ADD_REPLACE_EXISTING                    = 3
+	CERT_STORE_ADD_ALWAYS                              = 4
+	CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES = 5
+	CERT_STORE_ADD_NEWER                               = 6
+	CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES            = 7
+
+	/* ErrorStatus values for CertTrustStatus struct */
 	CERT_TRUST_NO_ERROR                          = 0x00000000
 	CERT_TRUST_IS_NOT_TIME_VALID                 = 0x00000001
 	CERT_TRUST_IS_REVOKED                        = 0x00000004
@@ -282,11 +367,31 @@ const (
 	CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT   = 0x00002000
 	CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT = 0x00004000
 	CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT      = 0x00008000
+	CERT_TRUST_IS_PARTIAL_CHAIN                  = 0x00010000
+	CERT_TRUST_CTL_IS_NOT_TIME_VALID             = 0x00020000
+	CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID        = 0x00040000
+	CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE        = 0x00080000
+	CERT_TRUST_HAS_WEAK_SIGNATURE                = 0x00100000
 	CERT_TRUST_IS_OFFLINE_REVOCATION             = 0x01000000
 	CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY          = 0x02000000
 	CERT_TRUST_IS_EXPLICIT_DISTRUST              = 0x04000000
 	CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT    = 0x08000000
 
+	/* InfoStatus values for CertTrustStatus struct */
+	CERT_TRUST_HAS_EXACT_MATCH_ISSUER        = 0x00000001
+	CERT_TRUST_HAS_KEY_MATCH_ISSUER          = 0x00000002
+	CERT_TRUST_HAS_NAME_MATCH_ISSUER         = 0x00000004
+	CERT_TRUST_IS_SELF_SIGNED                = 0x00000008
+	CERT_TRUST_HAS_PREFERRED_ISSUER          = 0x00000100
+	CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY     = 0x00000400
+	CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS    = 0x00000400
+	CERT_TRUST_IS_PEER_TRUSTED               = 0x00000800
+	CERT_TRUST_HAS_CRL_VALIDITY_EXTENDED     = 0x00001000
+	CERT_TRUST_IS_FROM_EXCLUSIVE_TRUST_STORE = 0x00002000
+	CERT_TRUST_IS_CA_TRUSTED                 = 0x00004000
+	CERT_TRUST_IS_COMPLEX_CHAIN              = 0x00010000
+
+	/* policyOID values for CertVerifyCertificateChainPolicy function */
 	CERT_CHAIN_POLICY_BASE              = 1
 	CERT_CHAIN_POLICY_AUTHENTICODE      = 2
 	CERT_CHAIN_POLICY_AUTHENTICODE_TS   = 3
@@ -295,6 +400,7 @@ const (
 	CERT_CHAIN_POLICY_NT_AUTH           = 6
 	CERT_CHAIN_POLICY_MICROSOFT_ROOT    = 7
 	CERT_CHAIN_POLICY_EV                = 8
+	CERT_CHAIN_POLICY_SSL_F12           = 9
 
 	CERT_E_EXPIRED       = 0x800B0101
 	CERT_E_ROLE          = 0x800B0103
@@ -302,8 +408,16 @@ const (
 	CERT_E_UNTRUSTEDROOT = 0x800B0109
 	CERT_E_CN_NO_MATCH   = 0x800B010F
 
+	/* AuthType values for SSLExtraCertChainPolicyPara struct */
 	AUTHTYPE_CLIENT = 1
 	AUTHTYPE_SERVER = 2
+
+	/* Checks values for SSLExtraCertChainPolicyPara struct */
+	SECURITY_FLAG_IGNORE_REVOCATION        = 0x00000080
+	SECURITY_FLAG_IGNORE_UNKNOWN_CA        = 0x00000100
+	SECURITY_FLAG_IGNORE_WRONG_USAGE       = 0x00000200
+	SECURITY_FLAG_IGNORE_CERT_CN_INVALID   = 0x00001000
+	SECURITY_FLAG_IGNORE_CERT_DATE_INVALID = 0x00002000
 )
 
 var (
@@ -312,6 +426,14 @@ var (
 	OID_SGC_NETSCAPE        = []byte("2.16.840.1.113730.4.1\x00")
 )
 
+// Pointer represents a pointer to an arbitrary Windows type.
+//
+// Pointer-typed fields may point to one of many different types. It's
+// up to the caller to provide a pointer to the appropriate type, cast
+// to Pointer. The caller must obey the unsafe.Pointer rules while
+// doing so.
+type Pointer *struct{}
+
 // Invented values to support what package os expects.
 type Timeval struct {
 	Sec  int32
@@ -880,11 +1002,15 @@ type MibIfRow struct {
 	Descr           [MAXLEN_IFDESCR]byte
 }
 
+type CertInfo struct {
+	// Not implemented
+}
+
 type CertContext struct {
 	EncodingType uint32
 	EncodedCert  *byte
 	Length       uint32
-	CertInfo     uintptr
+	CertInfo     *CertInfo
 	Store        Handle
 }
 
@@ -899,12 +1025,16 @@ type CertChainContext struct {
 	RevocationFreshnessTime    uint32
 }
 
+type CertTrustListInfo struct {
+	// Not implemented
+}
+
 type CertSimpleChain struct {
 	Size                       uint32
 	TrustStatus                CertTrustStatus
 	NumElements                uint32
 	Elements                   **CertChainElement
-	TrustListInfo              uintptr
+	TrustListInfo              *CertTrustListInfo
 	HasRevocationFreshnessTime uint32
 	RevocationFreshnessTime    uint32
 }
@@ -919,14 +1049,18 @@ type CertChainElement struct {
 	ExtendedErrorInfo *uint16
 }
 
+type CertRevocationCrlInfo struct {
+	// Not implemented
+}
+
 type CertRevocationInfo struct {
 	Size             uint32
 	RevocationResult uint32
 	RevocationOid    *byte
-	OidSpecificInfo  uintptr
+	OidSpecificInfo  Pointer
 	HasFreshnessTime uint32
 	FreshnessTime    uint32
-	CrlInfo          uintptr // *CertRevocationCrlInfo
+	CrlInfo          *CertRevocationCrlInfo
 }
 
 type CertTrustStatus struct {
@@ -957,7 +1091,7 @@ type CertChainPara struct {
 type CertChainPolicyPara struct {
 	Size            uint32
 	Flags           uint32
-	ExtraPolicyPara uintptr
+	ExtraPolicyPara Pointer
 }
 
 type SSLExtraCertChainPolicyPara struct {
@@ -972,7 +1106,7 @@ type CertChainPolicyStatus struct {
 	Error             uint32
 	ChainIndex        uint32
 	ElementIndex      uint32
-	ExtraPolicyStatus uintptr
+	ExtraPolicyStatus Pointer
 }
 
 const (
@@ -1319,7 +1453,7 @@ type SmallRect struct {
 	Bottom int16
 }
 
-// Used with GetConsoleScreenBuffer to retreive information about a console
+// Used with GetConsoleScreenBuffer to retrieve information about a console
 // screen buffer. See
 // https://docs.microsoft.com/en-us/windows/console/console-screen-buffer-info-str
 // for details.
@@ -1331,3 +1465,5 @@ type ConsoleScreenBufferInfo struct {
 	Window            SmallRect
 	MaximumWindowSize Coord
 }
+
+const UNIX_PATH_MAX = 108 // defined in afunix.h
diff --git a/src/cmd/vendor/golang.org/x/sys/windows/types_windows_arm.go b/src/cmd/vendor/golang.org/x/sys/windows/types_windows_arm.go
new file mode 100644
index 0000000000..74571e3600
--- /dev/null
+++ b/src/cmd/vendor/golang.org/x/sys/windows/types_windows_arm.go
@@ -0,0 +1,22 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package windows
+
+type WSAData struct {
+	Version      uint16
+	HighVersion  uint16
+	Description  [WSADESCRIPTION_LEN + 1]byte
+	SystemStatus [WSASYS_STATUS_LEN + 1]byte
+	MaxSockets   uint16
+	MaxUdpDg     uint16
+	VendorInfo   *byte
+}
+
+type Servent struct {
+	Name    *byte
+	Aliases **byte
+	Port    uint16
+	Proto   *byte
+}
diff --git a/src/cmd/vendor/golang.org/x/sys/windows/zsyscall_windows.go b/src/cmd/vendor/golang.org/x/sys/windows/zsyscall_windows.go
index 318c61634e..fc56aec035 100644
--- a/src/cmd/vendor/golang.org/x/sys/windows/zsyscall_windows.go
+++ b/src/cmd/vendor/golang.org/x/sys/windows/zsyscall_windows.go
@@ -1,4 +1,4 @@
-// MACHINE GENERATED BY 'go generate' COMMAND; DO NOT EDIT
+// Code generated by 'go generate'; DO NOT EDIT.
 
 package windows
 
diff --git a/src/cmd/vendor/vendor.json b/src/cmd/vendor/vendor.json
index 8009661879..6e077e4ae1 100644
--- a/src/cmd/vendor/vendor.json
+++ b/src/cmd/vendor/vendor.json
@@ -131,40 +131,40 @@
 			"revisionTime": "2018-06-27T13:57:12Z"
 		},
 		{
-			"checksumSHA1": "y0x0I9zDxnxn9nCxwP/MdPyq1E8=",
+			"checksumSHA1": "s+lofQ+SCdhmy0cQp9FpdQncuuI=",
 			"path": "golang.org/x/sys/windows",
-			"revision": "c11f84a56e43e20a78cee75a7c034031ecf57d1f",
-			"revisionTime": "2018-05-25T13:55:20Z"
+			"revision": "90868a75fefd03942536221d7c0e2f84ec62a668",
+			"revisionTime": "2018-08-01T20:46:00Z"
 		},
 		{
-			"checksumSHA1": "BnZkq/3Ejb7961bDhybRraW6jzI=",
+			"checksumSHA1": "yEg3f1MGwuyDh5NrNEGkWKlTyqY=",
 			"path": "golang.org/x/sys/windows/registry",
-			"revision": "c11f84a56e43e20a78cee75a7c034031ecf57d1f",
-			"revisionTime": "2018-05-25T13:55:20Z"
+			"revision": "90868a75fefd03942536221d7c0e2f84ec62a668",
+			"revisionTime": "2018-08-01T20:46:00Z"
 		},
 		{
-			"checksumSHA1": "dQbFeoiAxfB3WFFVcAdeSwSgeDk=",
+			"checksumSHA1": "ZDwqsuoZqQq/XMQ0R0dJ4oK41lU=",
 			"path": "golang.org/x/sys/windows/svc",
-			"revision": "c11f84a56e43e20a78cee75a7c034031ecf57d1f",
-			"revisionTime": "2018-05-25T13:55:20Z"
+			"revision": "90868a75fefd03942536221d7c0e2f84ec62a668",
+			"revisionTime": "2018-08-01T20:46:00Z"
 		},
 		{
 			"checksumSHA1": "e9KJPWrdqg5PMkbE2w60Io8rY4M=",
 			"path": "golang.org/x/sys/windows/svc/debug",
-			"revision": "c11f84a56e43e20a78cee75a7c034031ecf57d1f",
-			"revisionTime": "2018-05-25T13:55:20Z"
+			"revision": "90868a75fefd03942536221d7c0e2f84ec62a668",
+			"revisionTime": "2018-08-01T20:46:00Z"
 		},
 		{
 			"checksumSHA1": "dz53pQfqAnXG8HdJj+nazXN9YRw=",
 			"path": "golang.org/x/sys/windows/svc/eventlog",
-			"revision": "c11f84a56e43e20a78cee75a7c034031ecf57d1f",
-			"revisionTime": "2018-05-25T13:55:20Z"
+			"revision": "90868a75fefd03942536221d7c0e2f84ec62a668",
+			"revisionTime": "2018-08-01T20:46:00Z"
 		},
 		{
-			"checksumSHA1": "wz+0tf0Z7cVBaz/35P1m1cAiI7k=",
+			"checksumSHA1": "vV6Mr/b+1GaHiHLnq2zEejQJVec=",
 			"path": "golang.org/x/sys/windows/svc/mgr",
-			"revision": "c11f84a56e43e20a78cee75a7c034031ecf57d1f",
-			"revisionTime": "2018-05-25T13:55:20Z"
+			"revision": "90868a75fefd03942536221d7c0e2f84ec62a668",
+			"revisionTime": "2018-08-01T20:46:00Z"
 		}
 	],
 	"rootPath": "/cmd"
