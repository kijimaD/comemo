commit eaf02e1fc9d5f22415233783c02bb0b687d216ec
Author: Robert Griesemer <gri@golang.org>
Date:   Fri Apr 21 11:11:15 2017 -0700

    cmd/compile/internal/types: remove unused lineno arguments for PushDcl/MarkDcl
    
    More steps towards simpler symbol handling:
    
    - Pushdcl's incoming pos argument, saved in a newly pushed *Sym, was always
      immediately overwritten by the Lastlineno value of the saved *Sym.
    
    - Markdcl's incoming pos argument, saved in the stack mark *Sym, was not
      restored when the stack mark was popped.
    
    - Popdcl always maintained the most recent Lastlineno for a *Sym given
      by package and name, making it unnecessary to save Lastlineno in the
      first place. Removed Lastlineno from the set of fields that need saving,
      and simplified Popdcl.
    
    Change-Id: Ie93da1fbd780dcafc2703044e781c0c6298df569
    Reviewed-on: https://go-review.googlesource.com/41390
    Run-TryBot: Robert Griesemer <gri@golang.org>
    Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org>
    Reviewed-by: Matthew Dempsky <mdempsky@google.com>
---
 src/cmd/compile/internal/gc/alg.go      |  4 ++--
 src/cmd/compile/internal/gc/bimport.go  | 10 ++++----
 src/cmd/compile/internal/gc/dcl.go      |  4 ++--
 src/cmd/compile/internal/gc/noder.go    | 12 +++++-----
 src/cmd/compile/internal/gc/subr.go     |  2 +-
 src/cmd/compile/internal/types/scope.go | 41 +++++++++++----------------------
 src/cmd/compile/internal/types/sym.go   | 14 +++++------
 7 files changed, 36 insertions(+), 51 deletions(-)

diff --git a/src/cmd/compile/internal/gc/alg.go b/src/cmd/compile/internal/gc/alg.go
index fada9a115b..c410a8da2e 100644
--- a/src/cmd/compile/internal/gc/alg.go
+++ b/src/cmd/compile/internal/gc/alg.go
@@ -191,7 +191,7 @@ func genhash(sym *types.Sym, t *types.Type) {
 
 	lineno = autogeneratedPos // less confusing than end of input
 	dclcontext = PEXTERN
-	types.Markdcl(lineno)
+	types.Markdcl()
 
 	// func sym(p *T, h uintptr) uintptr
 	tfn := nod(OTFUNC, nil, nil)
@@ -362,7 +362,7 @@ func geneq(sym *types.Sym, t *types.Type) {
 
 	lineno = autogeneratedPos // less confusing than end of input
 	dclcontext = PEXTERN
-	types.Markdcl(lineno)
+	types.Markdcl()
 
 	// func sym(p, q *T) bool
 	tfn := nod(OTFUNC, nil, nil)
diff --git a/src/cmd/compile/internal/gc/bimport.go b/src/cmd/compile/internal/gc/bimport.go
index baae4bdd9a..7766a5617a 100644
--- a/src/cmd/compile/internal/gc/bimport.go
+++ b/src/cmd/compile/internal/gc/bimport.go
@@ -1091,7 +1091,7 @@ func (p *importer) node() *Node {
 		return nodl(p.pos(), op, p.expr(), nil)
 
 	case OIF:
-		types.Markdcl(lineno)
+		types.Markdcl()
 		n := nodl(p.pos(), OIF, nil, nil)
 		n.Ninit.Set(p.stmtList())
 		n.Left = p.expr()
@@ -1101,7 +1101,7 @@ func (p *importer) node() *Node {
 		return n
 
 	case OFOR:
-		types.Markdcl(lineno)
+		types.Markdcl()
 		n := nodl(p.pos(), OFOR, nil, nil)
 		n.Ninit.Set(p.stmtList())
 		n.Left, n.Right = p.exprsOrNil()
@@ -1110,7 +1110,7 @@ func (p *importer) node() *Node {
 		return n
 
 	case ORANGE:
-		types.Markdcl(lineno)
+		types.Markdcl()
 		n := nodl(p.pos(), ORANGE, nil, nil)
 		n.List.Set(p.stmtList())
 		n.Right = p.expr()
@@ -1119,7 +1119,7 @@ func (p *importer) node() *Node {
 		return n
 
 	case OSELECT, OSWITCH:
-		types.Markdcl(lineno)
+		types.Markdcl()
 		n := nodl(p.pos(), op, nil, nil)
 		n.Ninit.Set(p.stmtList())
 		n.Left, _ = p.exprsOrNil()
@@ -1131,7 +1131,7 @@ func (p *importer) node() *Node {
 	// 	unreachable - mapped to OXCASE case below by exporter
 
 	case OXCASE:
-		types.Markdcl(lineno)
+		types.Markdcl()
 		n := nodl(p.pos(), OXCASE, nil, nil)
 		n.Xoffset = int64(types.Block)
 		n.List.Set(p.exprList())
diff --git a/src/cmd/compile/internal/gc/dcl.go b/src/cmd/compile/internal/gc/dcl.go
index 93f52f3af2..99e05e79b1 100644
--- a/src/cmd/compile/internal/gc/dcl.go
+++ b/src/cmd/compile/internal/gc/dcl.go
@@ -104,7 +104,7 @@ func declare(n *Node, ctxt Class) {
 			vargen++
 			gen = vargen
 		}
-		types.Pushdcl(s, lineno)
+		types.Pushdcl(s)
 		n.Name.Curfn = Curfn
 	}
 
@@ -510,7 +510,7 @@ var funcdepth int32   // len(funcstack) during parsing, but then forced to be th
 // start the function.
 // called before funcargs; undone at end of funcbody.
 func funcstart(n *Node) {
-	types.Markdcl(lineno)
+	types.Markdcl()
 	funcstack = append(funcstack, Curfn)
 	funcdepth++
 	Curfn = n
diff --git a/src/cmd/compile/internal/gc/noder.go b/src/cmd/compile/internal/gc/noder.go
index f0c501b155..d4c00c8042 100644
--- a/src/cmd/compile/internal/gc/noder.go
+++ b/src/cmd/compile/internal/gc/noder.go
@@ -774,14 +774,14 @@ func (p *noder) stmt(stmt syntax.Stmt) *Node {
 }
 
 func (p *noder) blockStmt(stmt *syntax.BlockStmt) []*Node {
-	types.Markdcl(lineno)
+	types.Markdcl()
 	nodes := p.stmts(stmt.List)
 	types.Popdcl()
 	return nodes
 }
 
 func (p *noder) ifStmt(stmt *syntax.IfStmt) *Node {
-	types.Markdcl(lineno)
+	types.Markdcl()
 	n := p.nod(stmt, OIF, nil, nil)
 	if stmt.Init != nil {
 		n.Ninit.Set1(p.stmt(stmt.Init))
@@ -803,7 +803,7 @@ func (p *noder) ifStmt(stmt *syntax.IfStmt) *Node {
 }
 
 func (p *noder) forStmt(stmt *syntax.ForStmt) *Node {
-	types.Markdcl(lineno)
+	types.Markdcl()
 	var n *Node
 	if r, ok := stmt.Init.(*syntax.RangeClause); ok {
 		if stmt.Cond != nil || stmt.Post != nil {
@@ -837,7 +837,7 @@ func (p *noder) forStmt(stmt *syntax.ForStmt) *Node {
 }
 
 func (p *noder) switchStmt(stmt *syntax.SwitchStmt) *Node {
-	types.Markdcl(lineno)
+	types.Markdcl()
 	n := p.nod(stmt, OSWITCH, nil, nil)
 	if stmt.Init != nil {
 		n.Ninit.Set1(p.stmt(stmt.Init))
@@ -861,7 +861,7 @@ func (p *noder) caseClauses(clauses []*syntax.CaseClause, tswitch *Node) []*Node
 	var nodes []*Node
 	for _, clause := range clauses {
 		p.lineno(clause)
-		types.Markdcl(lineno)
+		types.Markdcl()
 		n := p.nod(clause, OXCASE, nil, nil)
 		if clause.Cases != nil {
 			n.List.Set(p.exprList(clause.Cases))
@@ -891,7 +891,7 @@ func (p *noder) commClauses(clauses []*syntax.CommClause) []*Node {
 	var nodes []*Node
 	for _, clause := range clauses {
 		p.lineno(clause)
-		types.Markdcl(lineno)
+		types.Markdcl()
 		n := p.nod(clause, OXCASE, nil, nil)
 		if clause.Comm != nil {
 			n.List.Set1(p.stmt(clause.Comm))
diff --git a/src/cmd/compile/internal/gc/subr.go b/src/cmd/compile/internal/gc/subr.go
index 1d94147230..fad935e92b 100644
--- a/src/cmd/compile/internal/gc/subr.go
+++ b/src/cmd/compile/internal/gc/subr.go
@@ -1684,7 +1684,7 @@ func genwrapper(rcvr *types.Type, method *types.Field, newnam *types.Sym, iface
 	lineno = autogeneratedPos
 
 	dclcontext = PEXTERN
-	types.Markdcl(lineno)
+	types.Markdcl()
 
 	this := namedfield(".this", rcvr)
 	this.Left.Name.Param.Ntype = this.Right
diff --git a/src/cmd/compile/internal/types/scope.go b/src/cmd/compile/internal/types/scope.go
index 80e87eb486..64b1b18141 100644
--- a/src/cmd/compile/internal/types/scope.go
+++ b/src/cmd/compile/internal/types/scope.go
@@ -4,15 +4,13 @@
 
 package types
 
-import "cmd/internal/src"
-
 // Declaration stack & operations
 
 var blockgen int32 = 1 // max block number
 var Block int32        // current block number
 
 // dclstack maintains a stack of shadowed symbol declarations so that
-// popdcl can restore their declarations when a block scope ends.
+// Popdcl can restore their declarations when a block scope ends.
 //
 // The Syms on this stack are not "real" Syms as they don't actually
 // represent object names. Sym is just a convenient type for saving shadowed
@@ -24,52 +22,39 @@ func dcopy(a, b *Sym) {
 	a.Name = b.Name
 	a.Def = b.Def
 	a.Block = b.Block
-	a.Lastlineno = b.Lastlineno
 }
 
-func push(pos src.XPos) *Sym {
+func push() *Sym {
 	d := new(Sym)
-	d.Lastlineno = pos
 	dclstack = append(dclstack, d)
 	return d
 }
 
 // Pushdcl pushes the current declaration for symbol s (if any) so that
 // it can be shadowed by a new declaration within a nested block scope.
-func Pushdcl(s *Sym, pos src.XPos) {
-	d := push(pos)
-	dcopy(d, s)
+func Pushdcl(s *Sym) {
+	dcopy(push(), s)
 }
 
 // Popdcl pops the innermost block scope and restores all symbol declarations
 // to their previous state.
 func Popdcl() {
-	i := len(dclstack)
-	for ; i > 0; i-- {
+	for i := len(dclstack); i > 0; i-- {
 		d := dclstack[i-1]
 		if d.Name == "" {
-			break
+			// pop stack mark
+			Block = d.Block
+			dclstack = dclstack[:i-1]
+			return
 		}
-		s := d.Pkg.Lookup(d.Name)
-		lno := s.Lastlineno
-		dcopy(s, d)
-		d.Lastlineno = lno
-	}
-
-	if i == 0 {
-		Fatalf("popdcl: no mark")
+		dcopy(d.Pkg.Lookup(d.Name), d)
 	}
-
-	Block = dclstack[i-1].Block
-	dclstack = dclstack[:i-1] // pop mark
+	Fatalf("popdcl: no stack mark")
 }
 
 // Markdcl records the start of a new block scope for declarations.
-func Markdcl(lineno src.XPos) {
-	d := push(lineno)
-	d.Name = "" // used as stack mark
-	d.Block = Block
-
+func Markdcl() {
+	push().Block = Block // stack mark (Name == "")
 	blockgen++
 	Block = blockgen
 }
diff --git a/src/cmd/compile/internal/types/sym.go b/src/cmd/compile/internal/types/sym.go
index c969f96b47..e316e99ce7 100644
--- a/src/cmd/compile/internal/types/sym.go
+++ b/src/cmd/compile/internal/types/sym.go
@@ -18,15 +18,15 @@ import (
 // allows using Sym pointer equality to test for Go identifier uniqueness when
 // handling selector expressions.
 type Sym struct {
-	Importdef *Pkg   // where imported definition was found
-	Linkname  string // link name
+	Importdef  *Pkg     // where imported definition was found
+	Linkname   string   // link name
+	Lastlineno src.XPos // last declaration for diagnostic
 
 	// saved and restored by dcopy
-	Pkg        *Pkg
-	Name       string   // object name
-	Def        *Node    // definition: ONAME OTYPE OPACK or OLITERAL
-	Lastlineno src.XPos // last declaration for diagnostic
-	Block      int32    // blocknumber to catch redeclaration
+	Pkg   *Pkg
+	Name  string // object name
+	Def   *Node  // definition: ONAME OTYPE OPACK or OLITERAL
+	Block int32  // blocknumber to catch redeclaration
 
 	flags   bitset8
 	Label   *Node // corresponding label (ephemeral)
