commit 98e0556231b43d26e8b22936299c49c4b794ced0
Author: Mikio Hara <mikioh.mikioh@gmail.com>
Date:   Tue Apr 28 21:17:46 2015 +0900

    net: deflake timeout, deadline tests
    
    This change deflakes timeout, deadline tests, especially fixes socket
    and goroutine leaks. Also adds a few missing tests that use features
    introduced after go1 release.
    
    Change-Id: Ibf73a4859f8d4a0ee494ca2fd180cbce72a7a2c7
    Reviewed-on: https://go-review.googlesource.com/9464
    Reviewed-by: Ian Lance Taylor <iant@golang.org>
---
 src/net/error_plan9_test.go |    5 +-
 src/net/error_posix_test.go |    5 +-
 src/net/error_test.go       |   16 +-
 src/net/mockserver_test.go  |   71 +++
 src/net/timeout_test.go     | 1107 +++++++++++++++++++++----------------------
 src/net/udp_test.go         |    3 +-
 6 files changed, 638 insertions(+), 569 deletions(-)

diff --git a/src/net/error_plan9_test.go b/src/net/error_plan9_test.go
index 349d07d2d2..495ea96534 100644
--- a/src/net/error_plan9_test.go
+++ b/src/net/error_plan9_test.go
@@ -6,7 +6,10 @@ package net
 
 import "syscall"
 
-var errOpNotSupported = syscall.EPLAN9
+var (
+	errTimedout       = syscall.ETIMEDOUT
+	errOpNotSupported = syscall.EPLAN9
+)
 
 func isPlatformError(err error) bool {
 	_, ok := err.(syscall.ErrorString)
diff --git a/src/net/error_posix_test.go b/src/net/error_posix_test.go
index 4f97e07a79..a642e29227 100644
--- a/src/net/error_posix_test.go
+++ b/src/net/error_posix_test.go
@@ -8,7 +8,10 @@ package net
 
 import "syscall"
 
-var errOpNotSupported = syscall.EOPNOTSUPP
+var (
+	errTimedout       = syscall.ETIMEDOUT
+	errOpNotSupported = syscall.EOPNOTSUPP
+)
 
 func isPlatformError(err error) bool {
 	_, ok := err.(syscall.Errno)
diff --git a/src/net/error_test.go b/src/net/error_test.go
index 75b125d435..356fad87d3 100644
--- a/src/net/error_test.go
+++ b/src/net/error_test.go
@@ -15,16 +15,6 @@ import (
 	"time"
 )
 
-func isTimeoutError(err error) bool {
-	nerr, ok := err.(Error)
-	return ok && nerr.Timeout()
-}
-
-func isTemporaryError(err error) bool {
-	nerr, ok := err.(Error)
-	return ok && nerr.Temporary()
-}
-
 func (e *OpError) isValid() error {
 	if e.Op == "" {
 		return fmt.Errorf("OpError.Op is empty: %v", e)
@@ -467,7 +457,7 @@ func TestAcceptError(t *testing.T) {
 				if c != nil {
 					t.Errorf("Accept returned non-nil interface %T(%v) with err != nil", c, c)
 				}
-				if !isTimeoutError(err) && !isTemporaryError(err) {
+				if nerr, ok := err.(Error); !ok || (!nerr.Timeout() && !nerr.Temporary()) {
 					return
 				}
 				continue
@@ -521,6 +511,10 @@ second:
 		nestedErr = err.Err
 		goto third
 	}
+	switch nestedErr {
+	case errClosing:
+		return nil
+	}
 	return fmt.Errorf("unexpected type on 2nd nested level: %T", nestedErr)
 
 third:
diff --git a/src/net/mockserver_test.go b/src/net/mockserver_test.go
index 07ffd63386..884467e950 100644
--- a/src/net/mockserver_test.go
+++ b/src/net/mockserver_test.go
@@ -9,6 +9,7 @@ import (
 	"io/ioutil"
 	"os"
 	"sync"
+	"testing"
 	"time"
 )
 
@@ -250,6 +251,54 @@ func transceiver(c Conn, wb []byte, ch chan<- error) {
 	}
 }
 
+func timeoutReceiver(c Conn, d, min, max time.Duration, ch chan<- error) {
+	var err error
+	defer func() { ch <- err }()
+
+	t0 := time.Now()
+	if err = c.SetReadDeadline(time.Now().Add(d)); err != nil {
+		return
+	}
+	b := make([]byte, 256)
+	var n int
+	n, err = c.Read(b)
+	t1 := time.Now()
+	if n != 0 || err == nil || !err.(Error).Timeout() {
+		err = fmt.Errorf("Read did not return (0, timeout): (%d, %v)", n, err)
+		return
+	}
+	if dt := t1.Sub(t0); min > dt || dt > max && !testing.Short() {
+		err = fmt.Errorf("Read took %s; expected %s", dt, d)
+		return
+	}
+}
+
+func timeoutTransmitter(c Conn, d, min, max time.Duration, ch chan<- error) {
+	var err error
+	defer func() { ch <- err }()
+
+	t0 := time.Now()
+	if err = c.SetWriteDeadline(time.Now().Add(d)); err != nil {
+		return
+	}
+	var n int
+	for {
+		n, err = c.Write([]byte("TIMEOUT TRANSMITTER"))
+		if err != nil {
+			break
+		}
+	}
+	t1 := time.Now()
+	if err == nil || !err.(Error).Timeout() {
+		err = fmt.Errorf("Write did not return (any, timeout): (%d, %v)", n, err)
+		return
+	}
+	if dt := t1.Sub(t0); min > dt || dt > max && !testing.Short() {
+		err = fmt.Errorf("Write took %s; expected %s", dt, d)
+		return
+	}
+}
+
 func newLocalPacketListener(network string) (PacketConn, error) {
 	switch network {
 	case "udp", "udp4", "udp6":
@@ -380,3 +429,25 @@ func packetTransceiver(c PacketConn, wb []byte, dst Addr, ch chan<- error) {
 		ch <- fmt.Errorf("read %d; want %d", n, len(wb))
 	}
 }
+
+func timeoutPacketReceiver(c PacketConn, d, min, max time.Duration, ch chan<- error) {
+	var err error
+	defer func() { ch <- err }()
+
+	t0 := time.Now()
+	if err = c.SetReadDeadline(time.Now().Add(d)); err != nil {
+		return
+	}
+	b := make([]byte, 256)
+	var n int
+	n, _, err = c.ReadFrom(b)
+	t1 := time.Now()
+	if n != 0 || err == nil || !err.(Error).Timeout() {
+		err = fmt.Errorf("ReadFrom did not return (0, timeout): (%d, %v)", n, err)
+		return
+	}
+	if dt := t1.Sub(t0); min > dt || dt > max && !testing.Short() {
+		err = fmt.Errorf("ReadFrom took %s; expected %s", dt, d)
+		return
+	}
+}
diff --git a/src/net/timeout_test.go b/src/net/timeout_test.go
index c9a826e106..792b5a42d3 100644
--- a/src/net/timeout_test.go
+++ b/src/net/timeout_test.go
@@ -10,66 +10,96 @@ import (
 	"io/ioutil"
 	"net/internal/socktest"
 	"runtime"
+	"sync"
 	"testing"
 	"time"
 )
 
-func TestDialTimeout(t *testing.T) {
-	const T = 100 * time.Millisecond
-
-	switch runtime.GOOS {
-	case "plan9", "windows":
-		origTestHookDialChannel := testHookDialChannel
-		testHookDialChannel = func() { time.Sleep(2 * T) }
-		defer func() { testHookDialChannel = origTestHookDialChannel }()
-		if runtime.GOOS == "plan9" {
-			break
-		}
-		fallthrough
-	default:
-		sw.Set(socktest.FilterConnect, func(so *socktest.Status) (socktest.AfterFilter, error) {
-			time.Sleep(2 * T)
-			return nil, errTimeout
-		})
-		defer sw.Set(socktest.FilterConnect, nil)
-	}
+var dialTimeoutTests = []struct {
+	timeout time.Duration
+	delta   time.Duration // for deadline
+
+	guard time.Duration
+	max   time.Duration
+}{
+	// Tests that dial timeouts, deadlines in the past work.
+	{-5 * time.Second, 0, -5 * time.Second, 100 * time.Millisecond},
+	{0, -5 * time.Second, -5 * time.Second, 100 * time.Millisecond},
+	{-5 * time.Second, 5 * time.Second, -5 * time.Second, 100 * time.Millisecond}, // timeout over deadline
+
+	{50 * time.Millisecond, 0, 100 * time.Millisecond, time.Second},
+	{0, 50 * time.Millisecond, 100 * time.Millisecond, time.Second},
+	{50 * time.Millisecond, 5 * time.Second, 100 * time.Millisecond, time.Second}, // timeout over deadline
+}
 
-	ch := make(chan error)
-	go func() {
-		// This dial never starts to send any SYN segment
-		// because of above socket filter and test hook.
-		c, err := DialTimeout("tcp", "127.0.0.1:0", T)
-		if err == nil {
-			err = fmt.Errorf("unexpectedly established: tcp:%s->%s", c.LocalAddr(), c.RemoteAddr())
-			c.Close()
+func TestDialTimeout(t *testing.T) {
+	origTestHookDialChannel := testHookDialChannel
+	defer func() { testHookDialChannel = origTestHookDialChannel }()
+	defer sw.Set(socktest.FilterConnect, nil)
+
+	for i, tt := range dialTimeoutTests {
+		switch runtime.GOOS {
+		case "plan9", "windows":
+			testHookDialChannel = func() { time.Sleep(tt.guard) }
+			if runtime.GOOS == "plan9" {
+				break
+			}
+			fallthrough
+		default:
+			sw.Set(socktest.FilterConnect, func(so *socktest.Status) (socktest.AfterFilter, error) {
+				time.Sleep(tt.guard)
+				return nil, errTimedout
+			})
 		}
-		ch <- err
-	}()
-	tmo := time.NewTimer(3 * T)
-	defer tmo.Stop()
-	select {
-	case <-tmo.C:
-		t.Fatal("dial has not returned")
-	case err := <-ch:
-		if perr := parseDialError(err); perr != nil {
-			t.Error(perr)
+
+		ch := make(chan error)
+		d := Dialer{Timeout: tt.timeout}
+		if tt.delta != 0 {
+			d.Deadline = time.Now().Add(tt.delta)
 		}
-		if !isTimeoutError(err) {
-			t.Fatalf("got %v; want timeout", err)
+		max := time.NewTimer(tt.max)
+		defer max.Stop()
+		go func() {
+			// This dial never starts to send any TCP SYN
+			// segment because of above socket filter and
+			// test hook.
+			c, err := d.Dial("tcp", "127.0.0.1:0")
+			if err == nil {
+				err = fmt.Errorf("unexpectedly established: tcp:%s->%s", c.LocalAddr(), c.RemoteAddr())
+				c.Close()
+			}
+			ch <- err
+		}()
+
+		select {
+		case <-max.C:
+			t.Fatalf("#%d: Dial didn't return in an expected time", i)
+		case err := <-ch:
+			if perr := parseDialError(err); perr != nil {
+				t.Errorf("#%d: %v", i, perr)
+			}
+			if nerr, ok := err.(Error); !ok || !nerr.Timeout() {
+				t.Fatalf("#%d: %v", i, err)
+			}
 		}
 	}
 }
 
-type copyRes struct {
-	n   int64
-	err error
-	d   time.Duration
+var acceptTimeoutTests = []struct {
+	timeout time.Duration
+	xerrs   [2]error // expected errors in transition
+}{
+	// Tests that accept deadlines in the past work, even if
+	// there's incoming connections available.
+	{-5 * time.Second, [2]error{errTimeout, errTimeout}},
+
+	{50 * time.Millisecond, [2]error{nil, errTimeout}},
 }
 
 func TestAcceptTimeout(t *testing.T) {
 	switch runtime.GOOS {
 	case "plan9":
-		t.Skipf("skipping test on %q", runtime.GOOS)
+		t.Skipf("not supported on %s", runtime.GOOS)
 	}
 
 	ln, err := newLocalListener("tcp")
@@ -77,55 +107,94 @@ func TestAcceptTimeout(t *testing.T) {
 		t.Fatal(err)
 	}
 	defer ln.Close()
-	ln.(*TCPListener).SetDeadline(time.Now().Add(-1 * time.Second))
-	if _, err := ln.Accept(); !isTimeoutError(err) {
-		t.Fatalf("Accept: expected err %v, got %v", errTimeout, err)
-	}
-	if perr := parseAcceptError(err); perr != nil {
-		t.Error(perr)
-	}
-	if _, err := ln.Accept(); !isTimeoutError(err) {
-		t.Fatalf("Accept: expected err %v, got %v", errTimeout, err)
-	}
-	if perr := parseAcceptError(err); perr != nil {
-		t.Error(perr)
-	}
-	ln.(*TCPListener).SetDeadline(time.Now().Add(100 * time.Millisecond))
-	if _, err := ln.Accept(); !isTimeoutError(err) {
-		t.Fatalf("Accept: expected err %v, got %v", errTimeout, err)
-	}
-	if perr := parseAcceptError(err); perr != nil {
-		t.Error(perr)
+
+	for i, tt := range acceptTimeoutTests {
+		if tt.timeout < 0 {
+			go func() {
+				c, err := Dial(ln.Addr().Network(), ln.Addr().String())
+				if err != nil {
+					t.Error(err)
+					return
+				}
+				var b [1]byte
+				c.Read(b[:])
+				c.Close()
+			}()
+		}
+
+		if err := ln.(*TCPListener).SetDeadline(time.Now().Add(tt.timeout)); err != nil {
+			t.Fatalf("$%d: %v", i, err)
+		}
+		for j, xerr := range tt.xerrs {
+			for {
+				c, err := ln.Accept()
+				if xerr != nil {
+					if perr := parseAcceptError(err); perr != nil {
+						t.Errorf("#%d/%d: %v", i, j, perr)
+					}
+					if nerr, ok := err.(Error); !ok || !nerr.Timeout() {
+						t.Fatalf("#%d/%d: %v", i, j, err)
+					}
+				}
+				if err == nil {
+					c.Close()
+					time.Sleep(tt.timeout / 3)
+					continue
+				}
+				break
+			}
+		}
 	}
-	if _, err := ln.Accept(); !isTimeoutError(err) {
-		t.Fatalf("Accept: expected err %v, got %v", errTimeout, err)
+}
+
+func TestAcceptTimeoutMustReturn(t *testing.T) {
+	switch runtime.GOOS {
+	case "plan9":
+		t.Skipf("not supported on %s", runtime.GOOS)
 	}
-	if perr := parseAcceptError(err); perr != nil {
-		t.Error(perr)
+
+	ln, err := newLocalListener("tcp")
+	if err != nil {
+		t.Fatal(err)
 	}
-	ln.(*TCPListener).SetDeadline(noDeadline)
-	errc := make(chan error)
+	defer ln.Close()
+
+	max := time.NewTimer(time.Second)
+	defer max.Stop()
+	ch := make(chan error)
 	go func() {
-		_, err := ln.Accept()
-		errc <- err
+		if err := ln.(*TCPListener).SetDeadline(noDeadline); err != nil {
+			t.Error(err)
+		}
+		if err := ln.(*TCPListener).SetDeadline(time.Now().Add(10 * time.Millisecond)); err != nil {
+			t.Error(err)
+		}
+		c, err := ln.Accept()
+		if err == nil {
+			c.Close()
+		}
+		ch <- err
 	}()
-	time.Sleep(100 * time.Millisecond)
+
 	select {
-	case err := <-errc:
-		t.Fatalf("Expected Accept() to not return, but it returned with %v\n", err)
-	default:
-	}
-	ln.Close()
-	err = <-errc
-	if perr := parseAcceptError(err); perr != nil {
-		t.Error(perr)
+	case <-max.C:
+		ln.Close()
+		<-ch // wait for tester goroutine to stop
+		t.Fatal("Accept didn't return in an expected time")
+	case err := <-ch:
+		if perr := parseAcceptError(err); perr != nil {
+			t.Error(perr)
+		}
+		if nerr, ok := err.(Error); !ok || !nerr.Timeout() {
+			t.Fatal(err)
+		}
 	}
 }
 
-func TestReadTimeout(t *testing.T) {
+func TestAcceptTimeoutMustNotReturn(t *testing.T) {
 	switch runtime.GOOS {
 	case "plan9":
-		t.Skipf("skipping test on %q", runtime.GOOS)
+		t.Skipf("not supported on %s", runtime.GOOS)
 	}
 
 	ln, err := newLocalListener("tcp")
@@ -133,249 +202,279 @@ func TestReadTimeout(t *testing.T) {
 		t.Fatal(err)
 	}
 	defer ln.Close()
-	c, err := DialTCP("tcp", nil, ln.Addr().(*TCPAddr))
-	if err != nil {
-		t.Fatalf("Connect: %v", err)
-	}
-	defer c.Close()
-	c.SetDeadline(time.Now().Add(time.Hour))
-	c.SetReadDeadline(time.Now().Add(-1 * time.Second))
-	buf := make([]byte, 1)
-	if _, err = c.Read(buf); !isTimeoutError(err) {
-		t.Fatalf("Read: expected err %v, got %v", errTimeout, err)
-	}
-	if perr := parseReadError(err); perr != nil {
-		t.Error(perr)
-	}
-	if _, err = c.Read(buf); !isTimeoutError(err) {
-		t.Fatalf("Read: expected err %v, got %v", errTimeout, err)
-	}
-	if perr := parseReadError(err); perr != nil {
-		t.Error(perr)
-	}
-	c.SetDeadline(time.Now().Add(100 * time.Millisecond))
-	if _, err = c.Read(buf); !isTimeoutError(err) {
-		t.Fatalf("Read: expected err %v, got %v", errTimeout, err)
-	}
-	if perr := parseReadError(err); perr != nil {
-		t.Error(perr)
-	}
-	if _, err = c.Read(buf); !isTimeoutError(err) {
-		t.Fatalf("Read: expected err %v, got %v", errTimeout, err)
-	}
-	if perr := parseReadError(err); perr != nil {
-		t.Error(perr)
-	}
-	c.SetReadDeadline(noDeadline)
-	c.SetWriteDeadline(time.Now().Add(-1 * time.Second))
-	errc := make(chan error)
+
+	max := time.NewTimer(100 * time.Millisecond)
+	defer max.Stop()
+	ch := make(chan error)
 	go func() {
-		_, err := c.Read(buf)
-		errc <- err
-	}()
-	time.Sleep(100 * time.Millisecond)
-	select {
-	case err := <-errc:
-		t.Fatalf("Expected Read() to not return, but it returned with %v\n", err)
-	default:
-	}
-	c.Close()
-	switch nerr := <-errc; err := nerr.(type) {
-	case *OpError:
-		if perr := parseReadError(err); perr != nil {
-			t.Error(perr)
+		if err := ln.(*TCPListener).SetDeadline(time.Now().Add(-5 * time.Second)); err != nil {
+			t.Error(err)
 		}
-	default:
-		if err == io.EOF && runtime.GOOS == "nacl" { // close enough; golang.org/issue/8044
-			break
+		if err := ln.(*TCPListener).SetDeadline(noDeadline); err != nil {
+			t.Error(err)
 		}
-		if perr := parseReadError(err); perr != nil {
+		_, err := ln.Accept()
+		ch <- err
+	}()
+
+	select {
+	case err := <-ch:
+		if perr := parseAcceptError(err); perr != nil {
 			t.Error(perr)
 		}
+		t.Fatalf("expected Accept to not return, but it returned with %v", err)
+	case <-max.C:
+		ln.Close()
+		<-ch // wait for tester goroutine to stop
 	}
 }
 
-func TestWriteTimeout(t *testing.T) {
+var readTimeoutTests = []struct {
+	timeout time.Duration
+	xerrs   [2]error // expected errors in transition
+}{
+	// Tests that read deadlines work, even if there's data ready
+	// to be read.
+	{-5 * time.Second, [2]error{errTimeout, errTimeout}},
+
+	{50 * time.Millisecond, [2]error{nil, errTimeout}},
+}
+
+func TestReadTimeout(t *testing.T) {
 	switch runtime.GOOS {
 	case "plan9":
-		t.Skipf("skipping test on %q", runtime.GOOS)
+		t.Skipf("not supported on %s", runtime.GOOS)
 	}
 
-	ln, err := newLocalListener("tcp")
+	handler := func(ls *localServer, ln Listener) {
+		c, err := ln.Accept()
+		if err != nil {
+			t.Error(err)
+			return
+		}
+		c.Write([]byte("READ TIMEOUT TEST"))
+		defer c.Close()
+	}
+	ls, err := newLocalServer("tcp")
 	if err != nil {
 		t.Fatal(err)
 	}
-	defer ln.Close()
-	c, err := DialTCP("tcp", nil, ln.Addr().(*TCPAddr))
+	defer ls.teardown()
+	if err := ls.buildup(handler); err != nil {
+		t.Fatal(err)
+	}
+
+	c, err := Dial(ls.Listener.Addr().Network(), ls.Listener.Addr().String())
 	if err != nil {
-		t.Fatalf("Connect: %v", err)
+		t.Fatal(err)
 	}
 	defer c.Close()
-	c.SetDeadline(time.Now().Add(time.Hour))
-	c.SetWriteDeadline(time.Now().Add(-1 * time.Second))
-	buf := make([]byte, 4096)
-	writeUntilTimeout := func() {
-		for {
-			_, err := c.Write(buf)
-			if perr := parseWriteError(err); perr != nil {
-				t.Error(perr)
-			}
-			if err != nil {
-				if isTimeoutError(err) {
-					return
+
+	for i, tt := range readTimeoutTests {
+		if err := c.SetReadDeadline(time.Now().Add(tt.timeout)); err != nil {
+			t.Fatalf("#%d: %v", i, err)
+		}
+		var b [1]byte
+		for j, xerr := range tt.xerrs {
+			for {
+				n, err := c.Read(b[:])
+				if xerr != nil {
+					if perr := parseReadError(err); perr != nil {
+						t.Errorf("#%d/%d: %v", i, j, perr)
+					}
+					if nerr, ok := err.(Error); !ok || !nerr.Timeout() {
+						t.Fatalf("#%d/%d: %v", i, j, err)
+					}
+				}
+				if err == nil {
+					time.Sleep(tt.timeout / 3)
+					continue
+				}
+				if n != 0 {
+					t.Fatalf("#%d/%d: read %d; want 0", i, j, n)
 				}
-				t.Fatalf("Write: expected err %v, got %v", errTimeout, err)
+				break
 			}
 		}
 	}
-	writeUntilTimeout()
-	c.SetDeadline(time.Now().Add(10 * time.Millisecond))
-	writeUntilTimeout()
-	writeUntilTimeout()
-	c.SetWriteDeadline(noDeadline)
-	c.SetReadDeadline(time.Now().Add(-1 * time.Second))
-	errc := make(chan error)
-	go func() {
-		for {
-			_, err := c.Write(buf)
-			if err != nil {
-				errc <- err
-			}
-		}
-	}()
-	time.Sleep(100 * time.Millisecond)
-	select {
-	case err := <-errc:
-		t.Fatalf("Expected Write() to not return, but it returned with %v\n", err)
-	default:
+}
+
+func TestReadTimeoutMustNotReturn(t *testing.T) {
+	switch runtime.GOOS {
+	case "plan9":
+		t.Skipf("not supported on %s", runtime.GOOS)
 	}
-	c.Close()
-	err = <-errc
-	if perr := parseWriteError(err); perr != nil {
-		t.Error(perr)
+
+	ln, err := newLocalListener("tcp")
+	if err != nil {
+		t.Fatal(err)
 	}
-}
+	defer ln.Close()
 
-func testTimeout(t *testing.T, net, addr string, readFrom bool) {
-	c, err := Dial(net, addr)
+	c, err := Dial(ln.Addr().Network(), ln.Addr().String())
 	if err != nil {
-		t.Errorf("Dial(%q, %q) failed: %v", net, addr, err)
-		return
+		t.Fatal(err)
 	}
 	defer c.Close()
-	what := "Read"
-	if readFrom {
-		what = "ReadFrom"
-	}
 
-	errc := make(chan error, 1)
+	max := time.NewTimer(100 * time.Millisecond)
+	defer max.Stop()
+	ch := make(chan error)
 	go func() {
-		t0 := time.Now()
-		c.SetReadDeadline(time.Now().Add(100 * time.Millisecond))
-		var b [100]byte
-		var n int
-		var err error
-		if readFrom {
-			n, _, err = c.(PacketConn).ReadFrom(b[0:])
-		} else {
-			n, err = c.Read(b[0:])
-		}
-		t1 := time.Now()
-		if n != 0 || err == nil || !err.(Error).Timeout() {
-			errc <- fmt.Errorf("%s(%q, %q) did not return 0, timeout: %v, %v", what, net, addr, n, err)
-			return
+		if err := c.SetDeadline(time.Now().Add(-5 * time.Second)); err != nil {
+			t.Error(err)
 		}
-		if dt := t1.Sub(t0); dt < 50*time.Millisecond || !testing.Short() && dt > 250*time.Millisecond {
-			errc <- fmt.Errorf("%s(%q, %q) took %s, expected 0.1s", what, net, addr, dt)
-			return
+		if err := c.SetWriteDeadline(time.Now().Add(-5 * time.Second)); err != nil {
+			t.Error(err)
+		}
+		if err := c.SetReadDeadline(noDeadline); err != nil {
+			t.Error(err)
 		}
-		errc <- nil
+		var b [1]byte
+		_, err := c.Read(b[:])
+		ch <- err
 	}()
+
 	select {
-	case err := <-errc:
-		if err != nil {
-			t.Error(err)
+	case err := <-ch:
+		if perr := parseReadError(err); perr != nil {
+			t.Error(perr)
+		}
+		t.Fatalf("expected Read to not return, but it returned with %v", err)
+	case <-max.C:
+		c.Close()
+		err := <-ch // wait for tester goroutine to stop
+		if perr := parseReadError(err); perr != nil {
+			t.Error(perr)
+		}
+		if err == io.EOF && runtime.GOOS == "nacl" { // see golang.org/issue/8044
+			return
+		}
+		if nerr, ok := err.(Error); !ok || nerr.Timeout() || nerr.Temporary() {
+			t.Fatal(err)
 		}
-	case <-time.After(1 * time.Second):
-		t.Errorf("%s(%q, %q) took over 1 second, expected 0.1s", what, net, addr)
 	}
 }
 
-func TestTimeoutUDP(t *testing.T) {
+var writeTimeoutTests = []struct {
+	timeout time.Duration
+	xerrs   [2]error // expected errors in transition
+}{
+	// Tests that write deadlines work, even if there's buffer
+	// space available to write.
+	{-5 * time.Second, [2]error{errTimeout, errTimeout}},
+
+	{10 * time.Millisecond, [2]error{nil, errTimeout}},
+}
+
+func TestWriteTimeout(t *testing.T) {
 	switch runtime.GOOS {
 	case "plan9":
-		t.Skipf("skipping test on %q", runtime.GOOS)
+		t.Skipf("not supported on %s", runtime.GOOS)
 	}
 
-	c, err := newLocalPacketListener("udp") // a listener that won't talk back
+	ln, err := newLocalListener("tcp")
 	if err != nil {
 		t.Fatal(err)
 	}
+	defer ln.Close()
 
-	testTimeout(t, "udp", c.LocalAddr().String(), false)
-	testTimeout(t, "udp", c.LocalAddr().String(), true)
-	c.Close()
-}
-
-func TestTimeoutTCP(t *testing.T) {
-	switch runtime.GOOS {
-	case "plan9":
-		t.Skipf("skipping test on %q", runtime.GOOS)
-	}
+	for i, tt := range writeTimeoutTests {
+		c, err := Dial(ln.Addr().Network(), ln.Addr().String())
+		if err != nil {
+			t.Fatal(err)
+		}
+		defer c.Close()
 
-	handler := func(ls *localServer, ln Listener) { // a listener that won't talk back
-		for {
-			c, err := ln.Accept()
-			if err != nil {
+		if err := c.SetWriteDeadline(time.Now().Add(tt.timeout)); err != nil {
+			t.Fatalf("#%d: %v", i, err)
+		}
+		for j, xerr := range tt.xerrs {
+			for {
+				n, err := c.Write([]byte("WRITE TIMEOUT TEST"))
+				if xerr != nil {
+					if perr := parseWriteError(err); perr != nil {
+						t.Errorf("#%d/%d: %v", i, j, perr)
+					}
+					if nerr, ok := err.(Error); !ok || !nerr.Timeout() {
+						t.Fatalf("#%d/%d: %v", i, j, err)
+					}
+				}
+				if err == nil {
+					time.Sleep(tt.timeout / 3)
+					continue
+				}
+				if n != 0 {
+					t.Fatalf("#%d/%d: wrote %d; want 0", i, j, n)
+				}
 				break
 			}
-			defer c.Close()
 		}
 	}
-	ls, err := newLocalServer("tcp")
-	if err != nil {
-		t.Fatal(err)
-	}
-	defer ls.teardown()
-	if err := ls.buildup(handler); err != nil {
-		t.Fatal(err)
-	}
-
-	testTimeout(t, "tcp", ls.Listener.Addr().String(), false)
 }
 
-func TestDeadlineReset(t *testing.T) {
+func TestWriteTimeoutMustNotReturn(t *testing.T) {
 	switch runtime.GOOS {
 	case "plan9":
-		t.Skipf("skipping test on %q", runtime.GOOS)
+		t.Skipf("not supported on %s", runtime.GOOS)
 	}
-	ln, err := Listen("tcp", "127.0.0.1:0")
+
+	ln, err := newLocalListener("tcp")
 	if err != nil {
 		t.Fatal(err)
 	}
 	defer ln.Close()
-	tl := ln.(*TCPListener)
-	tl.SetDeadline(time.Now().Add(1 * time.Minute))
-	tl.SetDeadline(noDeadline) // reset it
-	errc := make(chan error, 1)
+
+	c, err := Dial(ln.Addr().Network(), ln.Addr().String())
+	if err != nil {
+		t.Fatal(err)
+	}
+	defer c.Close()
+
+	max := time.NewTimer(100 * time.Millisecond)
+	defer max.Stop()
+	ch := make(chan error)
 	go func() {
-		_, err := ln.Accept()
-		errc <- err
+		if err := c.SetDeadline(time.Now().Add(-5 * time.Second)); err != nil {
+			t.Error(err)
+		}
+		if err := c.SetReadDeadline(time.Now().Add(-5 * time.Second)); err != nil {
+			t.Error(err)
+		}
+		if err := c.SetWriteDeadline(noDeadline); err != nil {
+			t.Error(err)
+		}
+		var b [1]byte
+		for {
+			if _, err := c.Write(b[:]); err != nil {
+				ch <- err
+				break
+			}
+		}
 	}()
+
 	select {
-	case <-time.After(50 * time.Millisecond):
-		// Pass.
-	case err := <-errc:
-		// Accept should never return; we never
-		// connected to it.
-		t.Errorf("unexpected return from Accept; err=%v", err)
+	case err := <-ch:
+		if perr := parseWriteError(err); perr != nil {
+			t.Error(perr)
+		}
+		t.Fatalf("expected Write to not return, but it returned with %v", err)
+	case <-max.C:
+		c.Close()
+		err := <-ch // wait for tester goroutine to stop
+		if perr := parseWriteError(err); perr != nil {
+			t.Error(perr)
+		}
+		if nerr, ok := err.(Error); !ok || nerr.Timeout() || nerr.Temporary() {
+			t.Fatal(err)
+		}
 	}
 }
 
-func TestConcurrentAcceptTimeout(t *testing.T) {
+func TestReadTimeoutFluctuation(t *testing.T) {
 	switch runtime.GOOS {
 	case "plan9":
-		t.Skipf("skipping test on %q", runtime.GOOS)
+		t.Skipf("not supported on %s", runtime.GOOS)
 	}
 
 	ln, err := newLocalListener("tcp")
@@ -383,111 +482,101 @@ func TestConcurrentAcceptTimeout(t *testing.T) {
 		t.Fatal(err)
 	}
 	defer ln.Close()
-	ln.(*TCPListener).SetDeadline(time.Now().Add(100 * time.Millisecond))
-	errc := make(chan error, 1)
-	go func() {
-		_, err := ln.Accept()
-		errc <- err
-	}()
+
+	c, err := Dial(ln.Addr().Network(), ln.Addr().String())
+	if err != nil {
+		t.Fatal(err)
+	}
+	defer c.Close()
+
+	max := time.NewTimer(time.Second)
+	defer max.Stop()
+	ch := make(chan error)
+	go timeoutReceiver(c, 100*time.Millisecond, 50*time.Millisecond, 250*time.Millisecond, ch)
+
 	select {
-	case <-time.After(1 * time.Second):
-		// Accept shouldn't block indefinitely
-		t.Error("Accept didn't return in an expected time")
-	case err := <-errc:
-		if perr := parseAcceptError(err); perr != nil {
+	case <-max.C:
+		t.Fatal("Read took over 1s; expected 0.1s")
+	case err := <-ch:
+		if perr := parseReadError(err); perr != nil {
 			t.Error(perr)
 		}
+		if nerr, ok := err.(Error); !ok || !nerr.Timeout() {
+			t.Fatal(err)
+		}
 	}
 }
 
-func TestReadWriteDeadline(t *testing.T) {
+func TestReadFromTimeoutFluctuation(t *testing.T) {
 	switch runtime.GOOS {
 	case "plan9":
-		t.Skipf("skipping test on %q", runtime.GOOS)
+		t.Skipf("not supported on %s", runtime.GOOS)
 	}
 
-	const (
-		readTimeout  = 50 * time.Millisecond
-		writeTimeout = 250 * time.Millisecond
-	)
-	checkTimeout := func(command string, start time.Time, should time.Duration) {
-		is := time.Now().Sub(start)
-		d := is - should
-		if d < -30*time.Millisecond || !testing.Short() && 150*time.Millisecond < d {
-			t.Errorf("%s timeout test failed: is=%v should=%v\n", command, is, should)
-		}
+	c1, err := newLocalPacketListener("udp")
+	if err != nil {
+		t.Fatal(err)
 	}
+	defer c1.Close()
 
-	ln, err := Listen("tcp", "127.0.0.1:0")
+	c2, err := Dial(c1.LocalAddr().Network(), c1.LocalAddr().String())
 	if err != nil {
-		t.Fatalf("ListenTCP on :0: %v", err)
+		t.Fatal(err)
 	}
-	defer ln.Close()
+	defer c2.Close()
 
-	lnquit := make(chan bool)
+	max := time.NewTimer(time.Second)
+	defer max.Stop()
+	ch := make(chan error)
+	go timeoutPacketReceiver(c2.(PacketConn), 100*time.Millisecond, 50*time.Millisecond, 250*time.Millisecond, ch)
 
-	go func() {
-		c, err := ln.Accept()
-		if err != nil {
-			t.Errorf("Accept: %v", err)
-			return
+	select {
+	case <-max.C:
+		t.Fatal("ReadFrom took over 1s; expected 0.1s")
+	case err := <-ch:
+		if perr := parseReadError(err); perr != nil {
+			t.Error(perr)
 		}
-		defer c.Close()
-		lnquit <- true
-	}()
+		if nerr, ok := err.(Error); !ok || !nerr.Timeout() {
+			t.Fatal(err)
+		}
+	}
+}
 
-	c, err := Dial("tcp", ln.Addr().String())
-	if err != nil {
-		t.Fatalf("Dial: %v", err)
+func TestWriteTimeoutFluctuation(t *testing.T) {
+	switch runtime.GOOS {
+	case "plan9":
+		t.Skipf("not supported on %s", runtime.GOOS)
 	}
-	defer c.Close()
 
-	start := time.Now()
-	err = c.SetReadDeadline(start.Add(readTimeout))
+	ln, err := newLocalListener("tcp")
 	if err != nil {
-		t.Fatalf("SetReadDeadline: %v", err)
+		t.Fatal(err)
 	}
-	err = c.SetWriteDeadline(start.Add(writeTimeout))
+	defer ln.Close()
+
+	c, err := Dial(ln.Addr().Network(), ln.Addr().String())
 	if err != nil {
-		t.Fatalf("SetWriteDeadline: %v", err)
+		t.Fatal(err)
 	}
+	defer c.Close()
 
-	quit := make(chan bool)
+	max := time.NewTimer(time.Second)
+	defer max.Stop()
+	ch := make(chan error)
+	go timeoutTransmitter(c, 100*time.Millisecond, 50*time.Millisecond, 250*time.Millisecond, ch)
 
-	go func() {
-		var buf [10]byte
-		_, err := c.Read(buf[:])
-		if err == nil {
-			t.Errorf("Read should not succeed")
+	select {
+	case <-max.C:
+		t.Fatal("Write took over 1s; expected 0.1s")
+	case err := <-ch:
+		if perr := parseWriteError(err); perr != nil {
+			t.Error(perr)
 		}
-		checkTimeout("Read", start, readTimeout)
-		quit <- true
-	}()
-
-	go func() {
-		var buf [10000]byte
-		for {
-			_, err := c.Write(buf[:])
-			if err != nil {
-				break
-			}
+		if nerr, ok := err.(Error); !ok || !nerr.Timeout() {
+			t.Fatal(err)
 		}
-		checkTimeout("Write", start, writeTimeout)
-		quit <- true
-	}()
-
-	<-quit
-	<-quit
-	<-lnquit
-}
-
-type neverEnding byte
-
-func (b neverEnding) Read(p []byte) (n int, err error) {
-	for i := range p {
-		p[i] = byte(b)
 	}
-	return len(p), nil
 }
 
 func TestVariousDeadlines1Proc(t *testing.T) {
@@ -498,31 +587,46 @@ func TestVariousDeadlines4Proc(t *testing.T) {
 	testVariousDeadlines(t, 4)
 }
 
+type neverEnding byte
+
+func (b neverEnding) Read(p []byte) (int, error) {
+	for i := range p {
+		p[i] = byte(b)
+	}
+	return len(p), nil
+}
+
 func testVariousDeadlines(t *testing.T, maxProcs int) {
 	switch runtime.GOOS {
 	case "plan9":
-		t.Skipf("skipping test on %q", runtime.GOOS)
+		t.Skipf("not supported on %s", runtime.GOOS)
 	}
 
 	defer runtime.GOMAXPROCS(runtime.GOMAXPROCS(maxProcs))
 
-	acceptc := make(chan error, 1)
-	// The server, with no timeouts of its own, sending bytes to clients
-	// as fast as it can.
-	servec := make(chan copyRes)
+	type result struct {
+		n   int64
+		err error
+		d   time.Duration
+	}
+
+	ch := make(chan error, 1)
+	pasvch := make(chan result)
 	handler := func(ls *localServer, ln Listener) {
 		for {
 			c, err := ln.Accept()
 			if err != nil {
-				acceptc <- err
+				ch <- err
 				return
 			}
+			// The server, with no timeouts of its own,
+			// sending bytes to clients as fast as it can.
 			go func() {
 				t0 := time.Now()
 				n, err := io.Copy(c, neverEnding('a'))
-				d := time.Since(t0)
+				dt := time.Since(t0)
 				c.Close()
-				servec <- copyRes{n, err, d}
+				pasvch <- result{n, err, dt}
 			}()
 		}
 	}
@@ -567,237 +671,106 @@ func testVariousDeadlines(t *testing.T, maxProcs int) {
 			name := fmt.Sprintf("%v run %d/%d", timeout, run+1, numRuns)
 			t.Log(name)
 
-			c, err := Dial("tcp", ls.Listener.Addr().String())
+			c, err := Dial(ls.Listener.Addr().Network(), ls.Listener.Addr().String())
 			if err != nil {
-				t.Fatalf("Dial: %v", err)
+				t.Fatal(err)
 			}
-			clientc := make(chan copyRes)
+
+			tooLong := 5 * time.Second
+			max := time.NewTimer(tooLong)
+			defer max.Stop()
+			actvch := make(chan result)
 			go func() {
 				t0 := time.Now()
-				c.SetDeadline(t0.Add(timeout))
+				if err := c.SetDeadline(t0.Add(timeout)); err != nil {
+					t.Error(err)
+				}
 				n, err := io.Copy(ioutil.Discard, c)
-				d := time.Since(t0)
+				dt := time.Since(t0)
 				c.Close()
-				clientc <- copyRes{n, err, d}
+				actvch <- result{n, err, dt}
 			}()
 
-			tooLong := 5 * time.Second
 			select {
-			case res := <-clientc:
-				if isTimeoutError(res.err) {
+			case res := <-actvch:
+				if nerr, ok := res.err.(Error); ok && nerr.Timeout() {
 					t.Logf("for %v, good client timeout after %v, reading %d bytes", name, res.d, res.n)
 				} else {
-					t.Fatalf("for %v: client Copy = %d, %v (want timeout)", name, res.n, res.err)
+					t.Fatalf("for %v, client Copy = %d, %v; want timeout", name, res.n, res.err)
 				}
-			case <-time.After(tooLong):
-				t.Fatalf("for %v: timeout (%v) waiting for client to timeout (%v) reading", name, tooLong, timeout)
+			case <-max.C:
+				t.Fatalf("for %v, timeout (%v) waiting for client to timeout (%v) reading", name, tooLong, timeout)
 			}
 
 			select {
-			case res := <-servec:
-				t.Logf("for %v: server in %v wrote %d, %v", name, res.d, res.n, res.err)
-			case err := <-acceptc:
-				t.Fatalf("for %v: server Accept = %v", name, err)
-			case <-time.After(tooLong):
+			case res := <-pasvch:
+				t.Logf("for %v, server in %v wrote %d: %v", name, res.d, res.n, res.err)
+			case err := <-ch:
+				t.Fatalf("for %v, Accept = %v", name, err)
+			case <-max.C:
 				t.Fatalf("for %v, timeout waiting for server to finish writing", name)
 			}
 		}
 	}
 }
 
-// TestReadDeadlineDataAvailable tests that read deadlines work, even
-// if there's data ready to be read.
-func TestReadDeadlineDataAvailable(t *testing.T) {
+// TestReadWriteProlongedTimeout tests concurrent deadline
+// modification. Known to cause data races in the past.
+func TestReadWriteProlongedTimeout(t *testing.T) {
 	switch runtime.GOOS {
 	case "plan9":
-		t.Skipf("skipping test on %q", runtime.GOOS)
+		t.Skipf("not supported on %s", runtime.GOOS)
 	}
 
-	servec := make(chan copyRes)
-	const msg = "data client shouldn't read, even though it'll be waiting"
 	handler := func(ls *localServer, ln Listener) {
 		c, err := ln.Accept()
 		if err != nil {
-			t.Errorf("Accept: %v", err)
-			return
-		}
-		defer c.Close()
-		n, err := c.Write([]byte(msg))
-		servec <- copyRes{n: int64(n), err: err}
-	}
-	ls, err := newLocalServer("tcp")
-	if err != nil {
-		t.Fatal(err)
-	}
-	defer ls.teardown()
-	if err := ls.buildup(handler); err != nil {
-		t.Fatal(err)
-	}
-
-	c, err := Dial("tcp", ls.Listener.Addr().String())
-	if err != nil {
-		t.Fatalf("Dial: %v", err)
-	}
-	defer c.Close()
-	if res := <-servec; res.err != nil || res.n != int64(len(msg)) {
-		t.Fatalf("unexpected server Write: n=%d, err=%v; want n=%d, err=nil", res.n, res.err, len(msg))
-	}
-	c.SetReadDeadline(time.Now().Add(-5 * time.Second)) // in the psat.
-	buf := make([]byte, len(msg)/2)
-	n, err := c.Read(buf)
-	if perr := parseReadError(err); perr != nil {
-		t.Error(perr)
-	}
-	if n > 0 || !isTimeoutError(err) {
-		t.Fatalf("client read = %d (%q) err=%v; want 0, timeout", n, buf[:n], err)
-	}
-}
-
-// TestWriteDeadlineBufferAvailable tests that write deadlines work, even
-// if there's buffer space available to write.
-func TestWriteDeadlineBufferAvailable(t *testing.T) {
-	switch runtime.GOOS {
-	case "plan9":
-		t.Skipf("skipping test on %q", runtime.GOOS)
-	}
-
-	servec := make(chan copyRes)
-	handler := func(ls *localServer, ln Listener) {
-		c, err := ln.Accept()
-		if err != nil {
-			t.Errorf("Accept: %v", err)
-			return
-		}
-		defer c.Close()
-		c.SetWriteDeadline(time.Now().Add(-5 * time.Second)) // in the past
-		n, err := c.Write([]byte{'x'})
-		servec <- copyRes{n: int64(n), err: err}
-	}
-	ls, err := newLocalServer("tcp")
-	if err != nil {
-		t.Fatal(err)
-	}
-	defer ls.teardown()
-	if err := ls.buildup(handler); err != nil {
-		t.Fatal(err)
-	}
-
-	c, err := Dial("tcp", ls.Listener.Addr().String())
-	if err != nil {
-		t.Fatalf("Dial: %v", err)
-	}
-	defer c.Close()
-	res := <-servec
-	if res.n != 0 {
-		t.Errorf("Write = %d; want 0", res.n)
-	}
-	if perr := parseWriteError(res.err); perr != nil {
-		t.Error(perr)
-	}
-	if !isTimeoutError(res.err) {
-		t.Errorf("Write error = %v; want timeout", res.err)
-	}
-}
-
-// TestAcceptDeadlineConnectionAvailable tests that accept deadlines work, even
-// if there's incoming connections available.
-func TestAcceptDeadlineConnectionAvailable(t *testing.T) {
-	switch runtime.GOOS {
-	case "plan9":
-		t.Skipf("skipping test on %q", runtime.GOOS)
-	}
-
-	ln, err := newLocalListener("tcp")
-	if err != nil {
-		t.Fatal(err)
-	}
-	defer ln.Close()
-
-	go func() {
-		c, err := Dial("tcp", ln.Addr().String())
-		if err != nil {
-			t.Errorf("Dial: %v", err)
+			t.Error(err)
 			return
 		}
 		defer c.Close()
-		var buf [1]byte
-		c.Read(buf[:]) // block until the connection or listener is closed
-	}()
-	time.Sleep(10 * time.Millisecond)
-	ln.(*TCPListener).SetDeadline(time.Now().Add(-5 * time.Second)) // in the past
-	c, err := ln.Accept()
-	if err == nil {
-		defer c.Close()
-	}
-	if !isTimeoutError(err) {
-		t.Fatalf("Accept: got %v; want timeout", err)
-	}
-}
 
-// TestConnectDeadlineInThePast tests that connect deadlines work, even
-// if the connection can be established w/o blocking.
-func TestConnectDeadlineInThePast(t *testing.T) {
-	ln, err := newLocalListener("tcp")
-	if err != nil {
-		t.Fatal(err)
-	}
-	defer ln.Close()
-
-	go func() {
-		c, err := ln.Accept()
-		if err == nil {
-			defer c.Close()
-		}
-	}()
-	time.Sleep(10 * time.Millisecond)
-	c, err := DialTimeout("tcp", ln.Addr().String(), -5*time.Second) // in the past
-	if err == nil {
-		defer c.Close()
-	}
-	if perr := parseDialError(err); perr != nil {
-		t.Error(perr)
-	}
-	if !isTimeoutError(err) {
-		t.Fatalf("got %v; want timeout", err)
-	}
-}
-
-// TestProlongTimeout tests concurrent deadline modification.
-// Known to cause data races in the past.
-func TestProlongTimeout(t *testing.T) {
-	switch runtime.GOOS {
-	case "plan9":
-		t.Skipf("skipping test on %q", runtime.GOOS)
-	}
-
-	connected := make(chan bool)
-	handler := func(ls *localServer, ln Listener) {
-		s, err := ln.Accept()
-		connected <- true
-		if err != nil {
-			t.Errorf("ln.Accept: %v", err)
-			return
-		}
-		defer s.Close()
-		s.SetDeadline(time.Now().Add(time.Hour))
+		var wg sync.WaitGroup
+		wg.Add(2)
 		go func() {
-			var buf [4096]byte
+			defer wg.Done()
+			var b [1]byte
 			for {
-				_, err := s.Write(buf[:])
-				if err != nil {
-					break
+				if err := c.SetReadDeadline(time.Now().Add(time.Hour)); err != nil {
+					if perr := parseCommonError(err); perr != nil {
+						t.Error(perr)
+					}
+					t.Error(err)
+					return
+				}
+				if _, err := c.Read(b[:]); err != nil {
+					if perr := parseReadError(err); perr != nil {
+						t.Error(perr)
+					}
+					return
 				}
-				s.SetDeadline(time.Now().Add(time.Hour))
 			}
 		}()
-		buf := make([]byte, 1)
-		for {
-			_, err := s.Read(buf)
-			if err != nil {
-				break
+		go func() {
+			defer wg.Done()
+			var b [1]byte
+			for {
+				if err := c.SetWriteDeadline(time.Now().Add(time.Hour)); err != nil {
+					if perr := parseCommonError(err); perr != nil {
+						t.Error(perr)
+					}
+					t.Error(err)
+					return
+				}
+				if _, err := c.Write(b[:]); err != nil {
+					if perr := parseWriteError(err); perr != nil {
+						t.Error(perr)
+					}
+					return
+				}
 			}
-			s.SetDeadline(time.Now().Add(time.Hour))
-		}
+		}()
+		wg.Wait()
 	}
 	ls, err := newLocalServer("tcp")
 	if err != nil {
@@ -808,22 +781,23 @@ func TestProlongTimeout(t *testing.T) {
 		t.Fatal(err)
 	}
 
-	c, err := Dial("tcp", ls.Listener.Addr().String())
+	c, err := Dial(ls.Listener.Addr().Network(), ls.Listener.Addr().String())
 	if err != nil {
-		t.Fatalf("DialTCP: %v", err)
+		t.Fatal(err)
 	}
 	defer c.Close()
-	<-connected
-	for i := 0; i < 1024; i++ {
-		var buf [1]byte
-		c.Write(buf[:])
+
+	var b [1]byte
+	for i := 0; i < 1000; i++ {
+		c.Write(b[:])
+		c.Read(b[:])
 	}
 }
 
-func TestDeadlineRace(t *testing.T) {
+func TestReadWriteDeadlineRace(t *testing.T) {
 	switch runtime.GOOS {
 	case "nacl", "plan9":
-		t.Skipf("skipping test on %q", runtime.GOOS)
+		t.Skipf("not supported on %s", runtime.GOOS)
 	}
 
 	N := 1000
@@ -831,31 +805,54 @@ func TestDeadlineRace(t *testing.T) {
 		N = 50
 	}
 	defer runtime.GOMAXPROCS(runtime.GOMAXPROCS(4))
+
 	ln, err := newLocalListener("tcp")
 	if err != nil {
 		t.Fatal(err)
 	}
 	defer ln.Close()
-	c, err := Dial("tcp", ln.Addr().String())
+
+	c, err := Dial(ln.Addr().Network(), ln.Addr().String())
 	if err != nil {
-		t.Fatalf("Dial: %v", err)
+		t.Fatal(err)
 	}
 	defer c.Close()
-	done := make(chan bool)
+
+	var wg sync.WaitGroup
+	wg.Add(3)
 	go func() {
-		t := time.NewTicker(2 * time.Microsecond).C
+		defer wg.Done()
+		tic := time.NewTicker(2 * time.Microsecond)
+		defer tic.Stop()
 		for i := 0; i < N; i++ {
-			if err := c.SetDeadline(time.Now().Add(2 * time.Microsecond)); err != nil {
+			if err := c.SetReadDeadline(time.Now().Add(2 * time.Microsecond)); err != nil {
+				if perr := parseCommonError(err); perr != nil {
+					t.Error(perr)
+				}
+				break
+			}
+			if err := c.SetWriteDeadline(time.Now().Add(2 * time.Microsecond)); err != nil {
+				if perr := parseCommonError(err); perr != nil {
+					t.Error(perr)
+				}
 				break
 			}
-			<-t
+			<-tic.C
 		}
-		done <- true
 	}()
-	var buf [1]byte
-	for i := 0; i < N; i++ {
-		c.Read(buf[:]) // ignore possible timeout errors
-	}
-	c.Close()
-	<-done
+	go func() {
+		defer wg.Done()
+		var b [1]byte
+		for i := 0; i < N; i++ {
+			c.Read(b[:]) // ignore possible timeout errors
+		}
+	}()
+	go func() {
+		defer wg.Done()
+		var b [1]byte
+		for i := 0; i < N; i++ {
+			c.Write(b[:]) // ignore possible timeout errors
+		}
+	}()
+	wg.Wait() // wait for tester goroutine to stop
 }
diff --git a/src/net/udp_test.go b/src/net/udp_test.go
index 383c6b5f17..d95a54fb0e 100644
--- a/src/net/udp_test.go
+++ b/src/net/udp_test.go
@@ -95,7 +95,8 @@ func TestReadFromUDP(t *testing.T) {
 	_, _, err = c.ReadFromUDP(b)
 	if err == nil {
 		t.Fatal("ReadFromUDP should fail")
-	} else if !isTimeoutError(err) {
+	}
+	if nerr, ok := err.(Error); !ok || !nerr.Timeout() {
 		t.Fatal(err)
 	}
 }
