commit d8921c5294cd0698184dc05b2af949ae1b147d12
Author: Russ Cox <rsc@golang.org>
Date:   Sun Feb 15 14:18:39 2009 -0800

    cleanups:
            get rid of _ on private names in net.
            fix os_test file name list.
            newline not needed on Errorf.
    
    R=r
    DELTA=305  (34 added, 2 deleted, 269 changed)
    OCL=25047
    CL=25047
---
 src/lib/net/dnsclient.go  |  16 +++---
 src/lib/net/dnsconfig.go  |  15 ++---
 src/lib/net/dnsmsg.go     |  92 +++++++++++++++----------------
 src/lib/net/fd.go         | 114 +++++++++++++++++++++-----------------
 src/lib/net/ip.go         |  44 +++++++--------
 src/lib/net/ip_test.go    |  10 ++--
 src/lib/net/net.go        | 137 +++++++++++++++++++++++++---------------------
 src/lib/net/net_linux.go  |   4 +-
 src/lib/net/parse.go      |  42 +++++++-------
 src/lib/net/parse_test.go |   7 ++-
 src/lib/net/port.go       |  17 +++---
 src/lib/os/os_test.go     |  17 +++---
 src/run.bash              |   1 +
 13 files changed, 274 insertions(+), 242 deletions(-)

diff --git a/src/lib/net/dnsclient.go b/src/lib/net/dnsclient.go
index 22d2684aa7..499d3663a9 100644
--- a/src/lib/net/dnsclient.go
+++ b/src/lib/net/dnsclient.go
@@ -84,7 +84,7 @@ func _Exchange(cfg *DNS_Config, c Conn, name string) (m *DNS_Msg, err *os.Error)
 // Find answer for name in dns message.
 // On return, if err == nil, addrs != nil.
 // TODO(rsc): Maybe return [][]byte (==[]IPAddr) instead?
-func _Answer(name string, dns *DNS_Msg) (addrs []string, err *os.Error) {
+func answer(name string, dns *DNS_Msg) (addrs []string, err *os.Error) {
 	addrs = make([]string, 0, len(dns.answer));
 
 	if dns.rcode == DNS_RcodeNameError && dns.authoritative {
@@ -134,8 +134,8 @@ Cname:
 }
 
 // Do a lookup for a single name, which must be rooted
-// (otherwise _Answer will not find the answers).
-func _TryOneName(cfg *DNS_Config, name string) (addrs []string, err *os.Error) {
+// (otherwise answer will not find the answers).
+func tryOneName(cfg *DNS_Config, name string) (addrs []string, err *os.Error) {
 	err = DNS_NoServers;
 	for i := 0; i < len(cfg.servers); i++ {
 		// Calling Dial here is scary -- we have to be sure
@@ -155,7 +155,7 @@ func _TryOneName(cfg *DNS_Config, name string) (addrs []string, err *os.Error) {
 			err = merr;
 			continue;
 		}
-		addrs, aerr := _Answer(name, msg);
+		addrs, aerr := answer(name, msg);
 		if aerr != nil && aerr != DNS_NameNotFound {
 			err = aerr;
 			continue;
@@ -167,7 +167,7 @@ func _TryOneName(cfg *DNS_Config, name string) (addrs []string, err *os.Error) {
 
 var cfg *DNS_Config
 
-func _LoadConfig() {
+func loadConfig() {
 	cfg = DNS_ReadConfig();
 }
 
@@ -175,7 +175,7 @@ func LookupHost(name string) (name1 string, addrs []string, err *os.Error) {
 	// TODO(rsc): Pick out obvious non-DNS names to avoid
 	// sending stupid requests to the server?
 
-	once.Do(_LoadConfig);
+	once.Do(loadConfig);
 	if cfg == nil {
 		err = DNS_MissingConfig;
 		return;
@@ -190,7 +190,7 @@ func LookupHost(name string) (name1 string, addrs []string, err *os.Error) {
 			rname += ".";
 		}
 		// Can try as ordinary name.
-		addrs, aerr := _TryOneName(cfg, rname);
+		addrs, aerr := tryOneName(cfg, rname);
 		if aerr == nil {
 			return rname, addrs, nil;
 		}
@@ -206,7 +206,7 @@ func LookupHost(name string) (name1 string, addrs []string, err *os.Error) {
 		if newname[len(newname)-1] != '.' {
 			newname += "."
 		}
-		addrs, aerr := _TryOneName(cfg, newname);
+		addrs, aerr := tryOneName(cfg, newname);
 		if aerr == nil {
 			return newname, addrs, nil;
 		}
diff --git a/src/lib/net/dnsconfig.go b/src/lib/net/dnsconfig.go
index e57ce59c67..7937f56bb7 100644
--- a/src/lib/net/dnsconfig.go
+++ b/src/lib/net/dnsconfig.go
@@ -27,7 +27,8 @@ type DNS_Config struct {
 // of the host name to get the default search domain.
 // We assume it's in resolv.conf anyway.
 func DNS_ReadConfig() *DNS_Config {
-	file := _Open("/etc/resolv.conf");
+	// TODO(rsc): 6g won't let me use "file :="
+	var file = open("/etc/resolv.conf");
 	if file == nil {
 		return nil
 	}
@@ -39,8 +40,8 @@ func DNS_ReadConfig() *DNS_Config {
 	conf.attempts = 1;
 	conf.rotate = false;
 	var err *os.Error;
-	for line, ok := file.ReadLine(); ok; line, ok = file.ReadLine() {
-		f := _GetFields(line);
+	for line, ok := file.readLine(); ok; line, ok = file.readLine() {
+		f := getFields(line);
 		if len(f) < 1 {
 			continue;
 		}
@@ -79,19 +80,19 @@ func DNS_ReadConfig() *DNS_Config {
 				s := f[i];
 				switch {
 				case len(s) >= 6 && s[0:6] == "ndots:":
-					n, i, ok := _Dtoi(s, 6);
+					n, i, ok := dtoi(s, 6);
 					if n < 1 {
 						n = 1
 					}
 					conf.ndots = n;
 				case len(s) >= 8 && s[0:8] == "timeout:":
-					n, i, ok := _Dtoi(s, 8);
+					n, i, ok := dtoi(s, 8);
 					if n < 1 {
 						n = 1
 					}
 					conf.timeout = n;
 				case len(s) >= 8 && s[0:9] == "attempts:":
-					n, i, ok := _Dtoi(s, 9);
+					n, i, ok := dtoi(s, 9);
 					if n < 1 {
 						n = 1
 					}
@@ -102,7 +103,7 @@ func DNS_ReadConfig() *DNS_Config {
 			}
 		}
 	}
-	file.Close();
+	file.close();
 
 	return conf
 }
diff --git a/src/lib/net/dnsmsg.go b/src/lib/net/dnsmsg.go
index c82f345d26..245991d249 100644
--- a/src/lib/net/dnsmsg.go
+++ b/src/lib/net/dnsmsg.go
@@ -29,7 +29,7 @@ import (
 	"reflect";
 )
 
-// _Packet formats
+// Packet formats
 
 // Wire constants.
 const (
@@ -188,7 +188,7 @@ type DNS_RR_A struct {
 }
 
 
-// _Packing and unpacking.
+// Packing and unpacking.
 //
 // All the packers and unpackers take a (msg []byte, off int)
 // and return (off1 int, ok bool).  If they return ok==false, they
@@ -212,10 +212,10 @@ var rr_mk = map[int] func()DNS_RR (
 	DNS_TypeA: func() DNS_RR { return new(DNS_RR_A) },
 )
 
-// _Pack a domain name s into msg[off:].
+// Pack a domain name s into msg[off:].
 // Domain names are a sequence of counted strings
 // split at the dots.  They end with a zero-length string.
-func _PackDomainName(s string, msg []byte, off int) (off1 int, ok bool) {
+func packDomainName(s string, msg []byte, off int) (off1 int, ok bool) {
 	// Add trailing dot to canonicalize name.
 	if n := len(s); n == 0 || s[n-1] != '.' {
 		s += ".";
@@ -251,7 +251,7 @@ func _PackDomainName(s string, msg []byte, off int) (off1 int, ok bool) {
 	return off, true
 }
 
-// _Unpack a domain name.
+// Unpack a domain name.
 // In addition to the simple sequences of counted strings above,
 // domain names are allowed to refer to strings elsewhere in the
 // packet, to avoid repeating common suffixes when returning
@@ -264,7 +264,7 @@ func _PackDomainName(s string, msg []byte, off int) (off1 int, ok bool) {
 // which is where the next record will start.
 // In theory, the pointers are only allowed to jump backward.
 // We let them jump anywhere and stop jumping after a while.
-func _UnpackDomainName(msg []byte, off int) (s string, off1 int, ok bool) {
+func unpackDomainName(msg []byte, off int) (s string, off1 int, ok bool) {
 	s = "";
 	ptr := 0;	// number of pointers followed
 Loop:
@@ -315,9 +315,9 @@ Loop:
 	return s, off1, true
 }
 
-// _Pack a reflect.StructValue into msg.  Struct members can only be uint16, uint32, string,
+// Pack a reflect.StructValue into msg.  Struct members can only be uint16, uint32, string,
 // and other (often anonymous) structs.
-func _PackStructValue(val reflect.StructValue, msg []byte, off int) (off1 int, ok bool) {
+func packStructValue(val reflect.StructValue, msg []byte, off int) (off1 int, ok bool) {
 	for i := 0; i < val.Len(); i++ {
 		fld := val.Field(i);
 		name, typ, tag, xxx := val.Type().(reflect.StructType).Field(i);
@@ -326,7 +326,7 @@ func _PackStructValue(val reflect.StructValue, msg []byte, off int) (off1 int, o
 			fmt.Fprintf(os.Stderr, "net: dns: unknown packing type %v", fld.Type());
 			return len(msg), false;
 		case reflect.StructKind:
-			off, ok = _PackStructValue(fld.(reflect.StructValue), msg, off);
+			off, ok = packStructValue(fld.(reflect.StructValue), msg, off);
 		case reflect.Uint16Kind:
 			i := fld.(reflect.Uint16Value).Get();
 			if off+2 > len(msg) {
@@ -354,7 +354,7 @@ func _PackStructValue(val reflect.StructValue, msg []byte, off int) (off1 int, o
 				fmt.Fprintf(os.Stderr, "net: dns: unknown string tag %v", tag);
 				return len(msg), false;
 			case "domain-name":
-				off, ok = _PackDomainName(s, msg, off);
+				off, ok = packDomainName(s, msg, off);
 				if !ok {
 					return len(msg), false
 				}
@@ -375,15 +375,15 @@ func _PackStructValue(val reflect.StructValue, msg []byte, off int) (off1 int, o
 	return off, true
 }
 
-func _PackStruct(any interface{}, msg []byte, off int) (off1 int, ok bool) {
+func packStruct(any interface{}, msg []byte, off int) (off1 int, ok bool) {
 	val := reflect.NewValue(any).(reflect.PtrValue).Sub().(reflect.StructValue);
-	off, ok = _PackStructValue(val, msg, off);
+	off, ok = packStructValue(val, msg, off);
 	return off, ok
 }
 
-// _Unpack a reflect.StructValue from msg.
-// Same restrictions as _PackStructValue.
-func _UnpackStructValue(val reflect.StructValue, msg []byte, off int) (off1 int, ok bool) {
+// Unpack a reflect.StructValue from msg.
+// Same restrictions as packStructValue.
+func unpackStructValue(val reflect.StructValue, msg []byte, off int) (off1 int, ok bool) {
 	for i := 0; i < val.Len(); i++ {
 		name, typ, tag, xxx := val.Type().(reflect.StructType).Field(i);
 		fld := val.Field(i);
@@ -392,7 +392,7 @@ func _UnpackStructValue(val reflect.StructValue, msg []byte, off int) (off1 int,
 			fmt.Fprintf(os.Stderr, "net: dns: unknown packing type %v", fld.Type());
 			return len(msg), false;
 		case reflect.StructKind:
-			off, ok = _UnpackStructValue(fld.(reflect.StructValue), msg, off);
+			off, ok = unpackStructValue(fld.(reflect.StructValue), msg, off);
 		case reflect.Uint16Kind:
 			if off+2 > len(msg) {
 				return len(msg), false
@@ -414,7 +414,7 @@ func _UnpackStructValue(val reflect.StructValue, msg []byte, off int) (off1 int,
 				fmt.Fprintf(os.Stderr, "net: dns: unknown string tag %v", tag);
 				return len(msg), false;
 			case "domain-name":
-				s, off, ok = _UnpackDomainName(msg, off);
+				s, off, ok = unpackDomainName(msg, off);
 				if !ok {
 					return len(msg), false
 				}
@@ -437,9 +437,9 @@ func _UnpackStructValue(val reflect.StructValue, msg []byte, off int) (off1 int,
 	return off, true
 }
 
-func _UnpackStruct(any interface{}, msg []byte, off int) (off1 int, ok bool) {
+func unpackStruct(any interface{}, msg []byte, off int) (off1 int, ok bool) {
 	val := reflect.NewValue(any).(reflect.PtrValue).Sub().(reflect.StructValue);
-	off, ok = _UnpackStructValue(val, msg, off);
+	off, ok = unpackStructValue(val, msg, off);
 	return off, ok
 }
 
@@ -447,7 +447,7 @@ func _UnpackStruct(any interface{}, msg []byte, off int) (off1 int, ok bool) {
 // Doesn't care about the string tag "domain-name",
 // but does look for an "ipv4" tag on uint32 variables,
 // printing them as IP addresses.
-func _PrintStructValue(val reflect.StructValue) string {
+func printStructValue(val reflect.StructValue) string {
 	s := "{";
 	for i := 0; i < val.Len(); i++ {
 		if i > 0 {
@@ -461,7 +461,7 @@ func _PrintStructValue(val reflect.StructValue) string {
 		kind := fld.Kind();
 		switch {
 		case kind == reflect.StructKind:
-			s += _PrintStructValue(fld.(reflect.StructValue));
+			s += printStructValue(fld.(reflect.StructValue));
 		case kind == reflect.Uint32Kind && tag == "ipv4":
 			i := fld.(reflect.Uint32Value).Get();
 			s += fmt.Sprintf("%d.%d.%d.%d", (i>>24)&0xFF, (i>>16)&0xFF, (i>>8)&0xFF, i&0xFF);
@@ -473,37 +473,37 @@ func _PrintStructValue(val reflect.StructValue) string {
 	return s;
 }
 
-func _PrintStruct(any interface{}) string {
+func printStruct(any interface{}) string {
 	val := reflect.NewValue(any).(reflect.PtrValue).Sub().(reflect.StructValue);
-	s := _PrintStructValue(val);
+	s := printStructValue(val);
 	return s
 }
 
 // Resource record packer.
-func _PackRR(rr DNS_RR, msg []byte, off int) (off2 int, ok bool) {
+func packRR(rr DNS_RR, msg []byte, off int) (off2 int, ok bool) {
 	var off1 int;
 	// pack twice, once to find end of header
 	// and again to find end of packet.
 	// a bit inefficient but this doesn't need to be fast.
 	// off1 is end of header
 	// off2 is end of rr
-	off1, ok = _PackStruct(rr.Header(), msg, off);
-	off2, ok = _PackStruct(rr, msg, off);
+	off1, ok = packStruct(rr.Header(), msg, off);
+	off2, ok = packStruct(rr, msg, off);
 	if !ok {
 		return len(msg), false
 	}
 	// pack a third time; redo header with correct data length
 	rr.Header().rdlength = uint16(off2 - off1);
-	_PackStruct(rr.Header(), msg, off);
+	packStruct(rr.Header(), msg, off);
 	return off2, true
 }
 
 // Resource record unpacker.
-func _UnpackRR(msg []byte, off int) (rr DNS_RR, off1 int, ok bool) {
+func unpackRR(msg []byte, off int) (rr DNS_RR, off1 int, ok bool) {
 	// unpack just the header, to find the rr type and length
 	var h DNS_RR_Header;
 	off0 := off;
-	if off, ok = _UnpackStruct(&h, msg, off); !ok {
+	if off, ok = unpackStruct(&h, msg, off); !ok {
 		return nil, len(msg), false
 	}
 	end := off+int(h.rdlength);
@@ -515,7 +515,7 @@ func _UnpackRR(msg []byte, off int) (rr DNS_RR, off1 int, ok bool) {
 		return &h, end, true
 	}
 	rr = mk();
-	off, ok = _UnpackStruct(rr, msg, off0);
+	off, ok = unpackStruct(rr, msg, off0);
 	if off != end {
 		return &h, end, true
 	}
@@ -584,20 +584,20 @@ func (dns *DNS_Msg) Pack() (msg []byte, ok bool) {
 	// big enough to hurt the allocator.
 	msg = make([]byte, 2000);
 
-	// _Pack it in: header and then the pieces.
+	// Pack it in: header and then the pieces.
 	off := 0;
-	off, ok = _PackStruct(&dh, msg, off);
+	off, ok = packStruct(&dh, msg, off);
 	for i := 0; i < len(question); i++ {
-		off, ok = _PackStruct(&question[i], msg, off);
+		off, ok = packStruct(&question[i], msg, off);
 	}
 	for i := 0; i < len(answer); i++ {
-		off, ok = _PackStruct(answer[i], msg, off);
+		off, ok = packStruct(answer[i], msg, off);
 	}
 	for i := 0; i < len(ns); i++ {
-		off, ok = _PackStruct(ns[i], msg, off);
+		off, ok = packStruct(ns[i], msg, off);
 	}
 	for i := 0; i < len(extra); i++ {
-		off, ok = _PackStruct(extra[i], msg, off);
+		off, ok = packStruct(extra[i], msg, off);
 	}
 	if !ok {
 		return nil, false
@@ -610,7 +610,7 @@ func (dns *DNS_Msg) Unpack(msg []byte) bool {
 	var dh _DNS_Header;
 	off := 0;
 	var ok bool;
-	if off, ok = _UnpackStruct(&dh, msg, off); !ok {
+	if off, ok = unpackStruct(&dh, msg, off); !ok {
 		return false
 	}
 	dns.id = dh.id;
@@ -629,16 +629,16 @@ func (dns *DNS_Msg) Unpack(msg []byte) bool {
 	dns.extra = make([]DNS_RR, dh.arcount);
 
 	for i := 0; i < len(dns.question); i++ {
-		off, ok = _UnpackStruct(&dns.question[i], msg, off);
+		off, ok = unpackStruct(&dns.question[i], msg, off);
 	}
 	for i := 0; i < len(dns.answer); i++ {
-		dns.answer[i], off, ok = _UnpackRR(msg, off);
+		dns.answer[i], off, ok = unpackRR(msg, off);
 	}
 	for i := 0; i < len(dns.ns); i++ {
-		dns.ns[i], off, ok = _UnpackRR(msg, off);
+		dns.ns[i], off, ok = unpackRR(msg, off);
 	}
 	for i := 0; i < len(dns.extra); i++ {
-		dns.extra[i], off, ok = _UnpackRR(msg, off);
+		dns.extra[i], off, ok = unpackRR(msg, off);
 	}
 	if !ok {
 		return false
@@ -650,29 +650,29 @@ func (dns *DNS_Msg) Unpack(msg []byte) bool {
 }
 
 func (dns *DNS_Msg) String() string {
-	s := "DNS: "+_PrintStruct(&dns._DNS_Msg_Top)+"\n";
+	s := "DNS: "+printStruct(&dns._DNS_Msg_Top)+"\n";
 	if len(dns.question) > 0 {
 		s += "-- Questions\n";
 		for i := 0; i < len(dns.question); i++ {
-			s += _PrintStruct(&dns.question[i])+"\n";
+			s += printStruct(&dns.question[i])+"\n";
 		}
 	}
 	if len(dns.answer) > 0 {
 		s += "-- Answers\n";
 		for i := 0; i < len(dns.answer); i++ {
-			s += _PrintStruct(dns.answer[i])+"\n";
+			s += printStruct(dns.answer[i])+"\n";
 		}
 	}
 	if len(dns.ns) > 0 {
 		s += "-- Name servers\n";
 		for i := 0; i < len(dns.ns); i++ {
-			s += _PrintStruct(dns.ns[i])+"\n";
+			s += printStruct(dns.ns[i])+"\n";
 		}
 	}
 	if len(dns.extra) > 0 {
 		s += "-- Extra\n";
 		for i := 0; i < len(dns.extra); i++ {
-			s += _PrintStruct(dns.extra[i])+"\n";
+			s += printStruct(dns.extra[i])+"\n";
 		}
 	}
 	return s;
diff --git a/src/lib/net/fd.go b/src/lib/net/fd.go
index 45269c81a0..1ec0d8af9e 100644
--- a/src/lib/net/fd.go
+++ b/src/lib/net/fd.go
@@ -13,21 +13,23 @@ import (
 	"syscall";
 )
 
-// Network file descriptor.  Only intended to be used internally,
-// but have to export to make it available in other files implementing package net.
-type FD struct {
+// Network file descriptor.
+type netFD struct {
 	// immutable until Close
 	fd int64;
 	osfd *os.FD;
-	cr chan *FD;
-	cw chan *FD;
+	cr chan *netFD;
+	cw chan *netFD;
+	net string;
+	laddr string;
+	raddr string;
 
 	// owned by fd wait server
 	ncr, ncw int;
 }
 
 // Make reads and writes on fd return EAGAIN instead of blocking.
-func _SetNonblock(fd int64) *os.Error {
+func setNonblock(fd int64) *os.Error {
 	flags, e := syscall.Fcntl(fd, syscall.F_GETFL, 0);
 	if e != 0 {
 		return os.ErrnoToError(e)
@@ -40,11 +42,11 @@ func _SetNonblock(fd int64) *os.Error {
 }
 
 
-// A _PollServer helps FDs determine when to retry a non-blocking
+// A pollServer helps FDs determine when to retry a non-blocking
 // read or write after they get EAGAIN.  When an FD needs to wait,
 // send the fd on s.cr (for a read) or s.cw (for a write) to pass the
 // request to the poll server.  Then receive on fd.cr/fd.cw.
-// When the _PollServer finds that i/o on FD should be possible
+// When the pollServer finds that i/o on FD should be possible
 // again, it will send fd on fd.cr/fd.cw to wake any waiting processes.
 // This protocol is implemented as s.WaitRead() and s.WaitWrite().
 //
@@ -54,8 +56,8 @@ func _SetNonblock(fd int64) *os.Error {
 // To resolve this, the poll server waits not just on the FDs it has
 // been given but also its own pipe.  After sending on the
 // buffered channel s.cr/s.cw, WaitRead/WaitWrite writes a
-// byte to the pipe, causing the _PollServer's poll system call to
-// return.  In response to the pipe being readable, the _PollServer
+// byte to the pipe, causing the pollServer's poll system call to
+// return.  In response to the pipe being readable, the pollServer
 // re-polls its request channels.
 //
 // Note that the ordering is "send request" and then "wake up server".
@@ -65,32 +67,32 @@ func _SetNonblock(fd int64) *os.Error {
 // to send the request.  Because the send must complete before the wakeup,
 // the request channel must be buffered.  A buffer of size 1 is sufficient
 // for any request load.  If many processes are trying to submit requests,
-// one will succeed, the _PollServer will read the request, and then the
+// one will succeed, the pollServer will read the request, and then the
 // channel will be empty for the next process's request.  A larger buffer
 // might help batch requests.
 
-type _PollServer struct {
-	cr, cw chan *FD;	// buffered >= 1
+type pollServer struct {
+	cr, cw chan *netFD;	// buffered >= 1
 	pr, pw *os.FD;
-	pending map[int64] *FD;
+	pending map[int64] *netFD;
 	poll *Pollster;	// low-level OS hooks
 }
-func (s *_PollServer) Run();
+func (s *pollServer) Run();
 
-func _NewPollServer() (s *_PollServer, err *os.Error) {
-	s = new(_PollServer);
-	s.cr = make(chan *FD, 1);
-	s.cw = make(chan *FD, 1);
+func newPollServer() (s *pollServer, err *os.Error) {
+	s = new(pollServer);
+	s.cr = make(chan *netFD, 1);
+	s.cw = make(chan *netFD, 1);
 	if s.pr, s.pw, err = os.Pipe(); err != nil {
 		return nil, err
 	}
-	if err = _SetNonblock(s.pr.Fd()); err != nil {
+	if err = setNonblock(s.pr.Fd()); err != nil {
 	Error:
 		s.pr.Close();
 		s.pw.Close();
 		return nil, err
 	}
-	if err = _SetNonblock(s.pw.Fd()); err != nil {
+	if err = setNonblock(s.pw.Fd()); err != nil {
 		goto Error
 	}
 	if s.poll, err = NewPollster(); err != nil {
@@ -100,14 +102,14 @@ func _NewPollServer() (s *_PollServer, err *os.Error) {
 		s.poll.Close();
 		goto Error
 	}
-	s.pending = make(map[int64] *FD);
+	s.pending = make(map[int64] *netFD);
 	go s.Run();
 	return s, nil
 }
 
-func (s *_PollServer) AddFD(fd *FD, mode int) {
+func (s *pollServer) AddFD(fd *netFD, mode int) {
 	if err := s.poll.AddFD(fd.fd, mode, false); err != nil {
-		print("_PollServer AddFD: ", err.String(), "\n");
+		print("pollServer AddFD: ", err.String(), "\n");
 		return
 	}
 
@@ -121,7 +123,7 @@ func (s *_PollServer) AddFD(fd *FD, mode int) {
 	s.pending[key] = fd
 }
 
-func (s *_PollServer) LookupFD(fd int64, mode int) *FD {
+func (s *pollServer) LookupFD(fd int64, mode int) *netFD {
 	key := fd << 1;
 	if mode == 'w' {
 		key++;
@@ -134,12 +136,12 @@ func (s *_PollServer) LookupFD(fd int64, mode int) *FD {
 	return netfd
 }
 
-func (s *_PollServer) Run() {
+func (s *pollServer) Run() {
 	var scratch [100]byte;
 	for {
 		fd, mode, err := s.poll.WaitFD();
 		if err != nil {
-			print("_PollServer WaitFD: ", err.String(), "\n");
+			print("pollServer WaitFD: ", err.String(), "\n");
 			return
 		}
 		if fd == s.pr.Fd() {
@@ -158,7 +160,7 @@ func (s *_PollServer) Run() {
 		} else {
 			netfd := s.LookupFD(fd, mode);
 			if netfd == nil {
-				print("_PollServer: unexpected wakeup for fd=", netfd, " mode=", string(mode), "\n");
+				print("pollServer: unexpected wakeup for fd=", netfd, " mode=", string(mode), "\n");
 				continue
 			}
 			if mode == 'r' {
@@ -176,18 +178,18 @@ func (s *_PollServer) Run() {
 	}
 }
 
-func (s *_PollServer) Wakeup() {
+func (s *pollServer) Wakeup() {
 	var b [1]byte;
 	s.pw.Write(b)
 }
 
-func (s *_PollServer) WaitRead(fd *FD) {
+func (s *pollServer) WaitRead(fd *netFD) {
 	s.cr <- fd;
 	s.Wakeup();
 	<-fd.cr
 }
 
-func (s *_PollServer) WaitWrite(fd *FD) {
+func (s *pollServer) WaitWrite(fd *netFD) {
 	s.cr <- fd;
 	s.Wakeup();
 	<-fd.cr
@@ -195,34 +197,37 @@ func (s *_PollServer) WaitWrite(fd *FD) {
 
 
 // Network FD methods.
-// All the network FDs use a single _PollServer.
+// All the network FDs use a single pollServer.
 
-var pollserver *_PollServer
+var pollserver *pollServer
 
 func _StartServer() {
-	p, err := _NewPollServer();
+	p, err := newPollServer();
 	if err != nil {
-		print("Start _PollServer: ", err.String(), "\n")
+		print("Start pollServer: ", err.String(), "\n")
 	}
 	pollserver = p
 }
 
-func NewFD(fd int64) (f *FD, err *os.Error) {
+func newFD(fd int64, net, laddr, raddr string) (f *netFD, err *os.Error) {
 	if pollserver == nil {
 		once.Do(_StartServer);
 	}
-	if err = _SetNonblock(fd); err != nil {
+	if err = setNonblock(fd); err != nil {
 		return nil, err
 	}
-	f = new(FD);
+	f = new(netFD);
 	f.fd = fd;
-	f.osfd = os.NewFD(fd, "socket");
-	f.cr = make(chan *FD, 1);
-	f.cw = make(chan *FD, 1);
+	f.net = net;
+	f.laddr = laddr;
+	f.raddr = raddr;
+	f.osfd = os.NewFD(fd, "net: " + net + " " + laddr + " " + raddr);
+	f.cr = make(chan *netFD, 1);
+	f.cw = make(chan *netFD, 1);
 	return f, nil
 }
 
-func (fd *FD) Close() *os.Error {
+func (fd *netFD) Close() *os.Error {
 	if fd == nil || fd.osfd == nil {
 		return os.EINVAL
 	}
@@ -232,7 +237,7 @@ func (fd *FD) Close() *os.Error {
 	return e
 }
 
-func (fd *FD) Read(p []byte) (n int, err *os.Error) {
+func (fd *netFD) Read(p []byte) (n int, err *os.Error) {
 	if fd == nil || fd.osfd == nil {
 		return -1, os.EINVAL
 	}
@@ -244,7 +249,7 @@ func (fd *FD) Read(p []byte) (n int, err *os.Error) {
 	return n, err
 }
 
-func (fd *FD) Write(p []byte) (n int, err *os.Error) {
+func (fd *netFD) Write(p []byte) (n int, err *os.Error) {
 	if fd == nil || fd.osfd == nil {
 		return -1, os.EINVAL
 	}
@@ -268,19 +273,30 @@ func (fd *FD) Write(p []byte) (n int, err *os.Error) {
 	return nn, err
 }
 
-func (fd *FD) Accept(sa *syscall.Sockaddr) (nfd *FD, err *os.Error) {
+func sockaddrToHostPort(sa *syscall.Sockaddr) (hostport string, err *os.Error)
+
+func (fd *netFD) Accept(sa *syscall.Sockaddr) (nfd *netFD, err *os.Error) {
 	if fd == nil || fd.osfd == nil {
 		return nil, os.EINVAL
 	}
-	s, e := syscall.Accept(fd.fd, sa);
-	for e == syscall.EAGAIN {
+
+	var s, e int64;
+	for {
+		s, e = syscall.Accept(fd.fd, sa);
+		if e != syscall.EAGAIN {
+			break;
+		}
 		pollserver.WaitRead(fd);
-		s, e = syscall.Accept(fd.fd, sa)
 	}
 	if e != 0 {
 		return nil, os.ErrnoToError(e)
 	}
-	if nfd, err = NewFD(s); err != nil {
+
+	raddr, err1 := sockaddrToHostPort(sa);
+	if err1 != nil {
+		raddr = "invalid-address";
+	}
+	if nfd, err = newFD(s, fd.net, fd.laddr, raddr); err != nil {
 		syscall.Close(s);
 		return nil, err
 	}
diff --git a/src/lib/net/ip.go b/src/lib/net/ip.go
index 89bbeba94a..b56b52870c 100644
--- a/src/lib/net/ip.go
+++ b/src/lib/net/ip.go
@@ -22,7 +22,7 @@ const (
 )
 
 // Make the 4 bytes into an IPv4 address (in IPv6 form)
-func _MakeIPv4(a, b, c, d byte) []byte {
+func makeIPv4(a, b, c, d byte) []byte {
 	p := make([]byte, IPv6len);
 	for i := 0; i < 10; i++ {
 		p[i] = 0
@@ -40,10 +40,10 @@ func _MakeIPv4(a, b, c, d byte) []byte {
 var IPv4bcast, IPv4allsys, IPv4allrouter, IPv4prefix, IPallbits, IPnoaddr []byte
 
 func init() {
-	IPv4bcast = _MakeIPv4(0xff, 0xff, 0xff, 0xff);
-	IPv4allsys = _MakeIPv4(0xe0, 0x00, 0x00, 0x01);
-	IPv4allrouter = _MakeIPv4(0xe0, 0x00, 0x00, 0x02);
-	IPv4prefix = _MakeIPv4(0, 0, 0, 0);
+	IPv4bcast = makeIPv4(0xff, 0xff, 0xff, 0xff);
+	IPv4allsys = makeIPv4(0xe0, 0x00, 0x00, 0x01);
+	IPv4allrouter = makeIPv4(0xe0, 0x00, 0x00, 0x02);
+	IPv4prefix = makeIPv4(0, 0, 0, 0);
 	IPallbits = make([]byte, IPv6len);
 	for i := 0; i < IPv6len; i++ {
 		IPallbits[i] = 0xff
@@ -52,7 +52,7 @@ func init() {
 }
 
 // Is p all zeros?
-func _IsZeros(p []byte) bool {
+func isZeros(p []byte) bool {
 	for i := 0; i < len(p); i++ {
 		if p[i] != 0 {
 			return false
@@ -68,7 +68,7 @@ func ToIPv4(p []byte) []byte {
 		return p
 	}
 	if len(p) == IPv6len
-	&& _IsZeros(p[0:10])
+	&& isZeros(p[0:10])
 	&& p[10] == 0xff
 	&& p[11] == 0xff {
 		return p[12:16]
@@ -79,7 +79,7 @@ func ToIPv4(p []byte) []byte {
 // Convert p to IPv6 form.
 func ToIPv6(p []byte) []byte {
 	if len(p) == IPv4len {
-		return _MakeIPv4(p[0], p[1], p[2], p[3])
+		return makeIPv4(p[0], p[1], p[2], p[3])
 	}
 	if len(p) == IPv6len {
 		return p
@@ -89,9 +89,9 @@ func ToIPv6(p []byte) []byte {
 
 // Default route masks for IPv4.
 var (
-	ClassAMask = _MakeIPv4(0xff, 0, 0, 0);
-	ClassBMask = _MakeIPv4(0xff, 0xff, 0, 0);
-	ClassCMask = _MakeIPv4(0xff, 0xff, 0xff, 0);
+	ClassAMask = makeIPv4(0xff, 0, 0, 0);
+	ClassBMask = makeIPv4(0xff, 0xff, 0, 0);
+	ClassCMask = makeIPv4(0xff, 0xff, 0xff, 0);
 )
 
 func DefaultMask(p []byte) []byte {
@@ -204,7 +204,7 @@ func IPToString(p []byte) string {
 
 // If mask is a sequence of 1 bits followed by 0 bits,
 // return the number of 1 bits.
-func _SimpleMaskLength(mask []byte) int {
+func simpleMaskLength(mask []byte) int {
 	var i int;
 	for i = 0; i < len(mask); i++ {
 		if mask[i] != 0xFF {
@@ -231,12 +231,12 @@ func _SimpleMaskLength(mask []byte) int {
 func MaskToString(mask []byte) string {
 	switch len(mask) {
 	case 4:
-		n := _SimpleMaskLength(mask);
+		n := simpleMaskLength(mask);
 		if n >= 0 {
 			return itod(uint(n+(IPv6len-IPv4len)*8))
 		}
 	case 16:
-		n := _SimpleMaskLength(mask);
+		n := simpleMaskLength(mask);
 		if n >= 0 {
 			return itod(uint(n))
 		}
@@ -245,7 +245,7 @@ func MaskToString(mask []byte) string {
 }
 
 // Parse IPv4 address (d.d.d.d).
-func _ParseIPv4(s string) []byte {
+func parseIPv4(s string) []byte {
 	var p [IPv4len]byte;
 	i := 0;
 	for j := 0; j < IPv4len; j++ {
@@ -259,7 +259,7 @@ func _ParseIPv4(s string) []byte {
 			n int;
 			ok bool
 		)
-		n, i, ok = _Dtoi(s, i);
+		n, i, ok = dtoi(s, i);
 		if !ok || n > 0xFF {
 			return nil
 		}
@@ -268,7 +268,7 @@ func _ParseIPv4(s string) []byte {
 	if i != len(s) {
 		return nil
 	}
-	return _MakeIPv4(p[0], p[1], p[2], p[3])
+	return makeIPv4(p[0], p[1], p[2], p[3])
 }
 
 // Parse IPv6 address.  Many forms.
@@ -279,7 +279,7 @@ func _ParseIPv4(s string) []byte {
 //	* A run of zeros can be replaced with "::".
 //	* The last 32 bits can be in IPv4 form.
 // Thus, ::ffff:1.2.3.4 is the IPv4 address 1.2.3.4.
-func _ParseIPv6(s string) []byte {
+func parseIPv6(s string) []byte {
 	p := make([]byte, 16);
 	ellipsis := -1;	// position of ellipsis in p
 	i := 0;	// index in string s
@@ -298,7 +298,7 @@ func _ParseIPv6(s string) []byte {
 	j := 0;
 L:	for j < IPv6len {
 		// Hex number.
-		n, i1, ok := _Xtoi(s, i);
+		n, i1, ok := xtoi(s, i);
 		if !ok || n > 0xFFFF {
 			return nil
 		}
@@ -313,7 +313,7 @@ L:	for j < IPv6len {
 				// Not enough room.
 				return nil
 			}
-			p4 := _ParseIPv4(s[i:len(s)]);
+			p4 := parseIPv4(s[i:len(s)]);
 			if p4 == nil {
 				return nil
 			}
@@ -378,10 +378,10 @@ L:	for j < IPv6len {
 }
 
 func ParseIP(s string) []byte {
-	p := _ParseIPv4(s);
+	p := parseIPv4(s);
 	if p != nil {
 		return p
 	}
-	return _ParseIPv6(s)
+	return parseIPv6(s)
 }
 
diff --git a/src/lib/net/ip_test.go b/src/lib/net/ip_test.go
index f8d8bd2ba6..c67a7dd1b1 100644
--- a/src/lib/net/ip_test.go
+++ b/src/lib/net/ip_test.go
@@ -9,7 +9,7 @@ import (
 	"testing"
 )
 
-func _IPv4(a, b, c, d byte) []byte {
+func ipv4(a, b, c, d byte) []byte {
 	return []byte( 0,0,0,0, 0,0,0,0, 0,0,255,255, a,b,c,d )
 }
 
@@ -33,14 +33,14 @@ type parseIPTest struct {
 	out []byte;
 }
 var parseiptests = []parseIPTest (
-	parseIPTest("127.0.1.2", _IPv4(127, 0, 1, 2)),
-	parseIPTest("127.0.0.1", _IPv4(127, 0, 0, 1)),
+	parseIPTest("127.0.1.2", ipv4(127, 0, 1, 2)),
+	parseIPTest("127.0.0.1", ipv4(127, 0, 0, 1)),
 	parseIPTest("127.0.0.256", nil),
 	parseIPTest("abc", nil),
-	parseIPTest("::ffff:127.0.0.1", _IPv4(127, 0, 0, 1)),
+	parseIPTest("::ffff:127.0.0.1", ipv4(127, 0, 0, 1)),
 	parseIPTest("2001:4860:0:2001::68",
 		[]byte(0x20,0x01, 0x48,0x60, 0,0, 0x20,0x01, 0,0, 0,0, 0,0, 0x00,0x68)),
-	parseIPTest("::ffff:4a7d:1363", _IPv4(74, 125, 19, 99)),
+	parseIPTest("::ffff:4a7d:1363", ipv4(74, 125, 19, 99)),
 )
 
 func TestParseIP(t *testing.T) {
diff --git a/src/lib/net/net.go b/src/lib/net/net.go
index 5d9550cc8f..b81e99268a 100644
--- a/src/lib/net/net.go
+++ b/src/lib/net/net.go
@@ -18,14 +18,14 @@ var (
 	UnknownHost = os.NewError("unknown host");
 	DNS_Error = os.NewError("dns error looking up host");
 	UnknownPort = os.NewError("unknown port");
-	Unknown_SocketFamily = os.NewError("unknown socket family");
+	UnknownsocketFamily = os.NewError("unknown socket family");
 )
 
 func LookupHost(name string) (name1 string, addrs []string, err *os.Error)
 
 // Split "host:port" into "host" and "port".
 // Host cannot contain colons unless it is bracketed.
-func _SplitHostPort(hostport string) (host, port string, err *os.Error) {
+func splitHostPort(hostport string) (host, port string, err *os.Error) {
 	// The port starts after the last colon.
 	var i int;
 	for i = len(hostport)-1; i >= 0; i-- {
@@ -45,7 +45,7 @@ func _SplitHostPort(hostport string) (host, port string, err *os.Error) {
 		host = host[1:len(host)-1]
 	} else {
 		// ... but if there are no brackets, no colons.
-		if _ByteIndex(host, ':') >= 0 {
+		if byteIndex(host, ':') >= 0 {
 			return "", "", BadAddress
 		}
 	}
@@ -54,9 +54,9 @@ func _SplitHostPort(hostport string) (host, port string, err *os.Error) {
 
 // Join "host" and "port" into "host:port".
 // If host contains colons, will join into "[host]:port".
-func _JoinHostPort(host, port string) string {
+func joinHostPort(host, port string) string {
 	// If host has colons, have to bracket it.
-	if _ByteIndex(host, ':') >= 0 {
+	if byteIndex(host, ':') >= 0 {
 		return "[" + host + "]:" + port
 	}
 	return host + ":" + port
@@ -65,9 +65,9 @@ func _JoinHostPort(host, port string) string {
 // Convert "host:port" into IP address and port.
 // For now, host and port must be numeric literals.
 // Eventually, we'll have name resolution.
-func _HostPortToIP(net, hostport, mode string) (ip []byte, iport int, err *os.Error) {
+func hostPortToIP(net, hostport, mode string) (ip []byte, iport int, err *os.Error) {
 	var host, port string;
-	host, port, err = _SplitHostPort(hostport);
+	host, port, err = splitHostPort(hostport);
 	if err != nil {
 		return nil, 0, err
 	}
@@ -101,7 +101,7 @@ func _HostPortToIP(net, hostport, mode string) (ip []byte, iport int, err *os.Er
 		}
 	}
 
-	p, i, ok := _Dtoi(port, 0);
+	p, i, ok := dtoi(port, 0);
 	if !ok || i != len(port) {
 		p, ok = LookupPort(net, port);
 		if !ok {
@@ -116,7 +116,7 @@ func _HostPortToIP(net, hostport, mode string) (ip []byte, iport int, err *os.Er
 }
 
 // Convert socket address into "host:port".
-func _SockaddrToHostPort(sa *syscall.Sockaddr) (hostport string, err *os.Error) {
+func sockaddrToHostPort(sa *syscall.Sockaddr) (hostport string, err *os.Error) {
 	switch sa.Family {
 	case syscall.AF_INET, syscall.AF_INET6:
 		addr, port, e := SockaddrToIP(sa);
@@ -124,9 +124,9 @@ func _SockaddrToHostPort(sa *syscall.Sockaddr) (hostport string, err *os.Error)
 			return "", e
 		}
 		host := IPToString(addr);
-		return _JoinHostPort(host, strconv.Itoa(port)), nil;
+		return joinHostPort(host, strconv.Itoa(port)), nil;
 	default:
-		return "", Unknown_SocketFamily
+		return "", UnknownsocketFamily
 	}
 	return "", nil // not reached
 }
@@ -139,8 +139,10 @@ func boolint(b bool) int {
 	return 0
 }
 
-// Generic _Socket creation.
-func _Socket(f, p, t int64, la, ra *syscall.Sockaddr) (fd *FD, err *os.Error) {
+// Generic socket creation.
+func socket(net, laddr, raddr string, f, p, t int64, la, ra *syscall.Sockaddr)
+	(fd *netFD, err *os.Error)
+{
 	s, e := syscall.Socket(f, p, t);
 	if e != 0 {
 		return nil, os.ErrnoToError(e)
@@ -166,7 +168,7 @@ func _Socket(f, p, t int64, la, ra *syscall.Sockaddr) (fd *FD, err *os.Error) {
 		}
 	}
 
-	fd, err = NewFD(s);
+	fd, err = newFD(s, net, laddr, raddr);
 	if err != nil {
 		syscall.Close(s);
 		return nil, err
@@ -177,29 +179,36 @@ func _Socket(f, p, t int64, la, ra *syscall.Sockaddr) (fd *FD, err *os.Error) {
 
 
 // Generic implementation of Conn interface; not exported.
-type _ConnBase struct {
-	fd *FD;
+type connBase struct {
+	fd *netFD;
 	raddr string;
 }
 
-func (c *_ConnBase) FD() int64 {
+func (c *connBase) FD() *os.FD {
+	if c == nil {
+		return nil
+	}
+	return c.fd.osfd;
+}
+
+func (c *connBase) sysFD() int64 {
 	if c == nil || c.fd == nil {
-		return -1
+		return -1;
 	}
-	return c.fd.fd
+	return c.fd.fd;
 }
 
-func (c *_ConnBase) Read(b []byte) (n int, err *os.Error) {
+func (c *connBase) Read(b []byte) (n int, err *os.Error) {
 	n, err = c.fd.Read(b);
 	return n, err
 }
 
-func (c *_ConnBase) Write(b []byte) (n int, err *os.Error) {
+func (c *connBase) Write(b []byte) (n int, err *os.Error) {
 	n, err = c.fd.Write(b);
 	return n, err
 }
 
-func (c *_ConnBase) ReadFrom(b []byte) (n int, raddr string, err *os.Error) {
+func (c *connBase) ReadFrom(b []byte) (n int, raddr string, err *os.Error) {
 	if c == nil {
 		return -1, "", os.EINVAL
 	}
@@ -207,7 +216,7 @@ func (c *_ConnBase) ReadFrom(b []byte) (n int, raddr string, err *os.Error) {
 	return n, c.raddr, err
 }
 
-func (c *_ConnBase) WriteTo(raddr string, b []byte) (n int, err *os.Error) {
+func (c *connBase) WriteTo(raddr string, b []byte) (n int, err *os.Error) {
 	if c == nil {
 		return -1, os.EINVAL
 	}
@@ -218,7 +227,7 @@ func (c *_ConnBase) WriteTo(raddr string, b []byte) (n int, err *os.Error) {
 	return n, err
 }
 
-func (c *_ConnBase) Close() *os.Error {
+func (c *connBase) Close() *os.Error {
 	if c == nil {
 		return os.EINVAL
 	}
@@ -234,48 +243,48 @@ func setsockopt_tv(fd, level, opt int64, nsec int64) *os.Error {
 	return os.ErrnoToError(syscall.Setsockopt_tv(fd, level, opt, nsec));
 }
 
-func (c *_ConnBase) SetReadBuffer(bytes int) *os.Error {
-	return setsockopt_int(c.FD(), syscall.SOL_SOCKET, syscall.SO_RCVBUF, bytes);
+func (c *connBase) SetReadBuffer(bytes int) *os.Error {
+	return setsockopt_int(c.sysFD(), syscall.SOL_SOCKET, syscall.SO_RCVBUF, bytes);
 }
 
-func (c *_ConnBase) SetWriteBuffer(bytes int) *os.Error {
-	return setsockopt_int(c.FD(), syscall.SOL_SOCKET, syscall.SO_SNDBUF, bytes);
+func (c *connBase) SetWriteBuffer(bytes int) *os.Error {
+	return setsockopt_int(c.sysFD(), syscall.SOL_SOCKET, syscall.SO_SNDBUF, bytes);
 }
 
-func (c *_ConnBase) SetReadTimeout(nsec int64) *os.Error {
-	return setsockopt_tv(c.FD(), syscall.SOL_SOCKET, syscall.SO_RCVTIMEO, nsec);
+func (c *connBase) SetReadTimeout(nsec int64) *os.Error {
+	return setsockopt_tv(c.sysFD(), syscall.SOL_SOCKET, syscall.SO_RCVTIMEO, nsec);
 }
 
-func (c *_ConnBase) SetWriteTimeout(nsec int64) *os.Error {
-	return setsockopt_tv(c.FD(), syscall.SOL_SOCKET, syscall.SO_SNDTIMEO, nsec);
+func (c *connBase) SetWriteTimeout(nsec int64) *os.Error {
+	return setsockopt_tv(c.sysFD(), syscall.SOL_SOCKET, syscall.SO_SNDTIMEO, nsec);
 }
 
-func (c *_ConnBase) SetTimeout(nsec int64) *os.Error {
+func (c *connBase) SetTimeout(nsec int64) *os.Error {
 	if e := c.SetReadTimeout(nsec); e != nil {
 		return e
 	}
 	return c.SetWriteTimeout(nsec)
 }
 
-func (c *_ConnBase) SetReuseAddr(reuse bool) *os.Error {
-	return setsockopt_int(c.FD(), syscall.SOL_SOCKET, syscall.SO_REUSEADDR, boolint(reuse));
+func (c *connBase) SetReuseAddr(reuse bool) *os.Error {
+	return setsockopt_int(c.sysFD(), syscall.SOL_SOCKET, syscall.SO_REUSEADDR, boolint(reuse));
 }
 
-func (c *_ConnBase) BindToDevice(dev string) *os.Error {
-	// TODO: call setsockopt with null-terminated string pointer
+func (c *connBase) BindToDevice(dev string) *os.Error {
+	// TODO(rsc): call setsockopt with null-terminated string pointer
 	return os.EINVAL
 }
 
-func (c *_ConnBase) SetDontRoute(dontroute bool) *os.Error {
-	return setsockopt_int(c.FD(), syscall.SOL_SOCKET, syscall.SO_DONTROUTE, boolint(dontroute));
+func (c *connBase) SetDontRoute(dontroute bool) *os.Error {
+	return setsockopt_int(c.sysFD(), syscall.SOL_SOCKET, syscall.SO_DONTROUTE, boolint(dontroute));
 }
 
-func (c *_ConnBase) SetKeepAlive(keepalive bool) *os.Error {
-	return setsockopt_int(c.FD(), syscall.SOL_SOCKET, syscall.SO_KEEPALIVE, boolint(keepalive));
+func (c *connBase) SetKeepAlive(keepalive bool) *os.Error {
+	return setsockopt_int(c.sysFD(), syscall.SOL_SOCKET, syscall.SO_KEEPALIVE, boolint(keepalive));
 }
 
-func (c *_ConnBase) SetLinger(sec int) *os.Error {
-	e := syscall.Setsockopt_linger(c.FD(), syscall.SOL_SOCKET, syscall.SO_LINGER, sec);
+func (c *connBase) SetLinger(sec int) *os.Error {
+	e := syscall.Setsockopt_linger(c.sysFD(), syscall.SOL_SOCKET, syscall.SO_LINGER, sec);
 	return os.ErrnoToError(e);
 }
 
@@ -287,23 +296,25 @@ func (c *_ConnBase) SetLinger(sec int) *os.Error {
 // understands IPv6, it's okay to pass IPv4 addresses to the IPv6
 // interface.  That simplifies our code and is most general.
 // If we need to build on a system without IPv6 support, setting
-// _PreferIPv4 here should fall back to the IPv4 socket interface when possible.
-const _PreferIPv4 = false
+// preferIPv4 here should fall back to the IPv4 socket interface when possible.
+const preferIPv4 = false
 
-func _InternetSocket(net, laddr, raddr string, proto int64, mode string) (fd *FD, err *os.Error) {
+func internetSocket(net, laddr, raddr string, proto int64, mode string)
+	(fd *netFD, err *os.Error)
+{
 	// Parse addresses (unless they are empty).
 	var lip, rip []byte;
 	var lport, rport int;
 	var lerr, rerr *os.Error;
 
 	if laddr != "" {
-		lip, lport, lerr = _HostPortToIP(net, laddr, mode);
+		lip, lport, lerr = hostPortToIP(net, laddr, mode);
 		if lerr != nil {
 			return nil, lerr
 		}
 	}
 	if raddr != "" {
-		rip, rport, rerr = _HostPortToIP(net, raddr, mode);
+		rip, rport, rerr = hostPortToIP(net, raddr, mode);
 		if rerr != nil {
 			return nil, rerr
 		}
@@ -320,7 +331,7 @@ func _InternetSocket(net, laddr, raddr string, proto int64, mode string) (fd *FD
 	default:
 		// Otherwise, guess.
 		// If the addresses are IPv4 and we prefer IPv4, use 4; else 6.
-		if _PreferIPv4 && ToIPv4(lip) != nil && ToIPv4(rip) != nil {
+		if preferIPv4 && ToIPv4(lip) != nil && ToIPv4(rip) != nil {
 			vers = 4
 		} else {
 			vers = 6
@@ -351,7 +362,7 @@ func _InternetSocket(net, laddr, raddr string, proto int64, mode string) (fd *FD
 		}
 	}
 
-	fd, err = _Socket(family, proto, 0, la, ra);
+	fd, err = socket(net, laddr, raddr, family, proto, 0, la, ra);
 	return fd, err
 }
 
@@ -359,17 +370,17 @@ func _InternetSocket(net, laddr, raddr string, proto int64, mode string) (fd *FD
 // TCP connections.
 
 type ConnTCP struct {
-	_ConnBase
+	connBase
 }
 
 func (c *ConnTCP) SetNoDelay(nodelay bool) *os.Error {
 	if c == nil {
 		return os.EINVAL
 	}
-	return setsockopt_int(c.FD(), syscall.IPPROTO_TCP, syscall.TCP_NODELAY, boolint(nodelay))
+	return setsockopt_int(c.sysFD(), syscall.IPPROTO_TCP, syscall.TCP_NODELAY, boolint(nodelay))
 }
 
-func _NewConnTCP(fd *FD, raddr string) *ConnTCP {
+func newConnTCP(fd *netFD, raddr string) *ConnTCP {
 	c := new(ConnTCP);
 	c.fd = fd;
 	c.raddr = raddr;
@@ -381,11 +392,11 @@ func DialTCP(net, laddr, raddr string) (c *ConnTCP, err *os.Error) {
 	if raddr == "" {
 		return nil, MissingAddress
 	}
-	fd, e := _InternetSocket(net, laddr, raddr, syscall.SOCK_STREAM, "dial");
+	fd, e := internetSocket(net, laddr, raddr, syscall.SOCK_STREAM, "dial");
 	if e != nil {
 		return nil, e
 	}
-	return _NewConnTCP(fd, raddr), nil
+	return newConnTCP(fd, raddr), nil
 }
 
 
@@ -394,10 +405,10 @@ func DialTCP(net, laddr, raddr string) (c *ConnTCP, err *os.Error) {
 // TODO(rsc): UDP headers mode
 
 type ConnUDP struct {
-	_ConnBase
+	connBase
 }
 
-func _NewConnUDP(fd *FD, raddr string) *ConnUDP {
+func newConnUDP(fd *netFD, raddr string) *ConnUDP {
 	c := new(ConnUDP);
 	c.fd = fd;
 	c.raddr = raddr;
@@ -408,11 +419,11 @@ func DialUDP(net, laddr, raddr string) (c *ConnUDP, err *os.Error) {
 	if raddr == "" {
 		return nil, MissingAddress
 	}
-	fd, e := _InternetSocket(net, laddr, raddr, syscall.SOCK_DGRAM, "dial");
+	fd, e := internetSocket(net, laddr, raddr, syscall.SOCK_DGRAM, "dial");
 	if e != nil {
 		return nil, e
 	}
-	return _NewConnUDP(fd, raddr), nil
+	return newConnUDP(fd, raddr), nil
 }
 
 
@@ -483,12 +494,12 @@ type Listener interface {
 }
 
 type ListenerTCP struct {
-	fd *FD;
+	fd *netFD;
 	laddr string
 }
 
 func ListenTCP(net, laddr string) (l *ListenerTCP, err *os.Error) {
-	fd, e := _InternetSocket(net, laddr, "", syscall.SOCK_STREAM, "listen");
+	fd, e := internetSocket(net, laddr, "", syscall.SOCK_STREAM, "listen");
 	if e != nil {
 		return nil, e
 	}
@@ -511,12 +522,12 @@ func (l *ListenerTCP) AcceptTCP() (c *ConnTCP, raddr string, err *os.Error) {
 	if e != nil {
 		return nil, "", e
 	}
-	raddr, err = _SockaddrToHostPort(&sa);
+	raddr, err = sockaddrToHostPort(&sa);
 	if err != nil {
 		fd.Close();
 		return nil, "", err
 	}
-	return _NewConnTCP(fd, raddr), raddr, nil
+	return newConnTCP(fd, raddr), raddr, nil
 }
 
 func (l *ListenerTCP) Accept() (c Conn, raddr string, err *os.Error) {
diff --git a/src/lib/net/net_linux.go b/src/lib/net/net_linux.go
index 7538f62bdc..01274c92f3 100644
--- a/src/lib/net/net_linux.go
+++ b/src/lib/net/net_linux.go
@@ -26,7 +26,7 @@ func IPv4ToSockaddr(p []byte, port int) (sa1 *syscall.Sockaddr, err *os.Error) {
 	return unsafe.Pointer(sa).(*syscall.Sockaddr), nil
 }
 
-var _IPv6zero [16]byte;
+var ipv6zero [16]byte;
 
 func IPv6ToSockaddr(p []byte, port int) (sa1 *syscall.Sockaddr, err *os.Error) {
 	p = ToIPv6(p);
@@ -38,7 +38,7 @@ func IPv6ToSockaddr(p []byte, port int) (sa1 *syscall.Sockaddr, err *os.Error) {
 	// In IPv6 mode, Linux treats that as meaning "announce on 0.0.0.0",
 	// which it refuses to do.  Rewrite to the IPv6 all zeros.
 	if p4 := ToIPv4(p); p4 != nil && p4[0] == 0 && p4[1] == 0 && p4[2] == 0 && p4[3] == 0 {
-		p = _IPv6zero;
+		p = ipv6zero;
 	}
 
 	sa := new(syscall.SockaddrInet6);
diff --git a/src/lib/net/parse.go b/src/lib/net/parse.go
index a1cf10c4a1..b8a13e32d9 100644
--- a/src/lib/net/parse.go
+++ b/src/lib/net/parse.go
@@ -12,16 +12,16 @@ import (
 	"os";
 )
 
-type _File struct {
+type file struct {
 	fd *os.FD;
 	data []byte;
 }
 
-func (f *_File) Close() {
+func (f *file) close() {
 	f.fd.Close()
 }
 
-func (f *_File) GetLineFromData() (s string, ok bool) {
+func (f *file) getLineFromData() (s string, ok bool) {
 	data := f.data;
 	for i := 0; i < len(data); i++ {
 		if data[i] == '\n' {
@@ -40,8 +40,8 @@ func (f *_File) GetLineFromData() (s string, ok bool) {
 	return
 }
 
-func (f *_File) ReadLine() (s string, ok bool) {
-	if s, ok = f.GetLineFromData(); ok {
+func (f *file) readLine() (s string, ok bool) {
+	if s, ok = f.getLineFromData(); ok {
 		return
 	}
 	if len(f.data) < cap(f.data) {
@@ -51,19 +51,19 @@ func (f *_File) ReadLine() (s string, ok bool) {
 			f.data = f.data[0:ln+n];
 		}
 	}
-	s, ok = f.GetLineFromData();
+	s, ok = f.getLineFromData();
 	return
 }
 
-func _Open(name string) *_File {
+func open(name string) *file {
 	fd, err := os.Open(name, os.O_RDONLY, 0);
 	if err != nil {
 		return nil
 	}
-	return &_File(fd, make([]byte, 1024)[0:0]);
+	return &file(fd, make([]byte, 1024)[0:0]);
 }
 
-func _ByteIndex(s string, c byte) int {
+func byteIndex(s string, c byte) int {
 	for i := 0; i < len(s); i++ {
 		if s[i] == c {
 			return i
@@ -73,10 +73,10 @@ func _ByteIndex(s string, c byte) int {
 }
 
 // Count occurrences in s of any bytes in t.
-func _CountAnyByte(s string, t string) int {
+func countAnyByte(s string, t string) int {
 	n := 0;
 	for i := 0; i < len(s); i++ {
-		if _ByteIndex(t, s[i]) >= 0 {
+		if byteIndex(t, s[i]) >= 0 {
 			n++;
 		}
 	}
@@ -84,12 +84,12 @@ func _CountAnyByte(s string, t string) int {
 }
 
 // Split s at any bytes in t.
-func _SplitAtBytes(s string, t string) []string {
-	a := make([]string, 1+_CountAnyByte(s, t));
+func splitAtBytes(s string, t string) []string {
+	a := make([]string, 1+countAnyByte(s, t));
 	n := 0;
 	last := 0;
 	for i := 0; i < len(s); i++ {
-		if _ByteIndex(t, s[i]) >= 0 {
+		if byteIndex(t, s[i]) >= 0 {
 			if last < i {
 				a[n] = string(s[last:i]);
 				n++;
@@ -104,20 +104,20 @@ func _SplitAtBytes(s string, t string) []string {
 	return a[0:n];
 }
 
-func _GetFields(s string) []string {
-	return _SplitAtBytes(s, " \r\t\n");
+func getFields(s string) []string {
+	return splitAtBytes(s, " \r\t\n");
 }
 
 // Bigger than we need, not too big to worry about overflow
-const _Big = 0xFFFFFF
+const big = 0xFFFFFF
 
 // Decimal to integer starting at &s[i0].
 // Returns number, new offset, success.
-func _Dtoi(s string, i0 int) (n int, i int, ok bool) {
+func dtoi(s string, i0 int) (n int, i int, ok bool) {
 	n = 0;
 	for i = i0; i < len(s) && '0' <= s[i] && s[i] <= '9'; i++ {
 		n = n*10 + int(s[i] - '0');
-		if n >= _Big {
+		if n >= big {
 			return 0, i, false
 		}
 	}
@@ -129,7 +129,7 @@ func _Dtoi(s string, i0 int) (n int, i int, ok bool) {
 
 // Hexadecimal to integer starting at &s[i0].
 // Returns number, new offset, success.
-func _Xtoi(s string, i0 int) (n int, i int, ok bool) {
+func xtoi(s string, i0 int) (n int, i int, ok bool) {
 	n = 0;
 	for i = i0; i < len(s); i++ {
 		if '0' <= s[i] && s[i] <= '9' {
@@ -144,7 +144,7 @@ func _Xtoi(s string, i0 int) (n int, i int, ok bool) {
 		} else {
 			break
 		}
-		if n >= _Big {
+		if n >= big {
 			return 0, i, false
 		}
 	}
diff --git a/src/lib/net/parse_test.go b/src/lib/net/parse_test.go
index 57a68ee804..fc01ad5dea 100644
--- a/src/lib/net/parse_test.go
+++ b/src/lib/net/parse_test.go
@@ -20,16 +20,17 @@ func TestReadLine(t *testing.T) {
 	}
 	br := bufio.NewBufRead(fd);
 
-	file := _Open(filename);
+	// TODO(rsc): 6g rejects "file :="
+	var file = open(filename);
 	if file == nil {
-		t.Fatalf("net._Open(%s) = nil", filename);
+		t.Fatalf("net.open(%s) = nil", filename);
 	}
 
 	lineno := 1;
 	byteno := 0;
 	for {
 		bline, berr := br.ReadLineString('\n', false);
-		line, ok := file.ReadLine();
+		line, ok := file.readLine();
 		if (berr != nil) != !ok || bline != line {
 			t.Fatalf("%s:%d (#%d)\nbufio => %q, %v\nnet => %q, %v",
 				filename, lineno, byteno, bline, berr, line, ok);
diff --git a/src/lib/net/port.go b/src/lib/net/port.go
index b64b353950..528264ad66 100644
--- a/src/lib/net/port.go
+++ b/src/lib/net/port.go
@@ -16,20 +16,21 @@ import (
 
 var services map[string] map[string] int
 
-func _ReadServices() {
+func readServices() {
 	services = make(map[string] map[string] int);
-	file := _Open("/etc/services");
-	for line, ok := file.ReadLine(); ok; line, ok = file.ReadLine() {
+	// TODO(rsc): 6g won't let me do "file := "
+	var file = open("/etc/services");
+	for line, ok := file.readLine(); ok; line, ok = file.readLine() {
 		// "http 80/tcp www www-http # World Wide Web HTTP"
-		if i := _ByteIndex(line, '#'); i >= 0 {
+		if i := byteIndex(line, '#'); i >= 0 {
 			line = line[0:i];
 		}
-		f := _GetFields(line);
+		f := getFields(line);
 		if len(f) < 2 {
 			continue;
 		}
 		portnet := f[1];	// "tcp/80"
-		port, j, ok := _Dtoi(portnet, 0);
+		port, j, ok := dtoi(portnet, 0);
 		if !ok || port <= 0 || j >= len(portnet) || portnet[j] != '/' {
 			continue
 		}
@@ -45,11 +46,11 @@ func _ReadServices() {
 			}
 		}
 	}
-	file.Close();
+	file.close();
 }
 
 func LookupPort(netw, name string) (port int, ok bool) {
-	once.Do(_ReadServices);
+	once.Do(readServices);
 
 	switch netw {
 	case "tcp4", "tcp6":
diff --git a/src/lib/os/os_test.go b/src/lib/os/os_test.go
index 91b401808c..354d7c4eed 100644
--- a/src/lib/os/os_test.go
+++ b/src/lib/os/os_test.go
@@ -13,12 +13,12 @@ import (
 var dot = []string(
 	"dir_amd64_darwin.go",
 	"dir_amd64_linux.go",
-	"os_env.go",
-	"os_error.go",
-	"os_file.go",
+	"env.go",
+	"error.go",
+	"file.go",
 	"os_test.go",
-	"os_time.go",
-	"os_types.go",
+	"time.go",
+	"types.go",
 	"stat_amd64_darwin.go",
 	"stat_amd64_linux.go"
 )
@@ -101,7 +101,7 @@ func testReaddirnames(dir string, contents []string, t *testing.T) {
 	fd, err := Open(dir, O_RDONLY, 0);
 	defer fd.Close();
 	if err != nil {
-		t.Fatalf("open %q failed: %v\n", dir, err);
+		t.Fatalf("open %q failed: %v", dir, err);
 	}
 	s, err2 := Readdirnames(fd, -1);
 	if err2 != nil {
@@ -192,12 +192,13 @@ func TestReaddirnamesOneAtATime(t *testing.T) {
 	}
 	fd1, err2 := Open(dir, O_RDONLY, 0);
 	if err2 != nil {
-		t.Fatalf("open %q failed: %v\n", dir, err2);
+		t.Fatalf("open %q failed: %v", dir, err2);
 	}
 	small := smallReaddirnames(fd1, len(all)+100, t);	// +100 in case we screw up
 	for i, n := range all {
 		if small[i] != n {
-			t.Errorf("small read %q %q mismatch: %v\n", small[i], n);
+			t.Errorf("small read %q %q mismatch: %v", small[i], n);
 		}
 	}
 }
+
diff --git a/src/run.bash b/src/run.bash
index 64a6170617..250b9efbdb 100755
--- a/src/run.bash
+++ b/src/run.bash
@@ -29,6 +29,7 @@ maketest \
 	lib/json\
 	lib/math\
 	lib/net\
+	lib/os\
 	lib/reflect\
 	lib/regexp\
 	lib/strconv\
