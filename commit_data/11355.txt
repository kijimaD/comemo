commit da6d835b90a52d9f86aaf526903fb491b7bb41a6
Author: Brad Fitzpatrick <bradfitz@golang.org>
Date:   Tue Jan 24 08:32:43 2012 -0800

    crypto: rename some FooError to ErrFoo
    
    Also, add an explicit error type when the right hand side is an unexported
    function.
    
    R=golang-dev, gri, rogpeppe, agl, rsc
    CC=golang-dev
    https://golang.org/cl/5564048
---
 src/pkg/crypto/dsa/dsa.go                                |  6 +++---
 src/pkg/crypto/openpgp/errors/errors.go                  |  4 ++--
 src/pkg/crypto/openpgp/packet/symmetrically_encrypted.go |  2 +-
 src/pkg/crypto/openpgp/read.go                           | 16 ++++++++--------
 src/pkg/crypto/openpgp/read_test.go                      |  6 +++---
 5 files changed, 17 insertions(+), 17 deletions(-)

diff --git a/src/pkg/crypto/dsa/dsa.go b/src/pkg/crypto/dsa/dsa.go
index be47846845..7aaad1ca19 100644
--- a/src/pkg/crypto/dsa/dsa.go
+++ b/src/pkg/crypto/dsa/dsa.go
@@ -35,11 +35,11 @@ func (invalidPublicKeyError) Error() string {
 	return "crypto/dsa: invalid public key"
 }
 
-// InvalidPublicKeyError results when a public key is not usable by this code.
+// ErrInvalidPublicKey results when a public key is not usable by this code.
 // FIPS is quite strict about the format of DSA keys, but other code may be
 // less so. Thus, when using keys which may have been generated by other code,
 // this error must be handled.
-var InvalidPublicKeyError = invalidPublicKeyError(0)
+var ErrInvalidPublicKey error = invalidPublicKeyError(0)
 
 // ParameterSizes is a enumeration of the acceptable bit lengths of the primes
 // in a set of DSA parameters. See FIPS 186-3, section 4.2.
@@ -194,7 +194,7 @@ func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err err
 
 	n := priv.Q.BitLen()
 	if n&7 != 0 {
-		err = InvalidPublicKeyError
+		err = ErrInvalidPublicKey
 		return
 	}
 	n >>= 3
diff --git a/src/pkg/crypto/openpgp/errors/errors.go b/src/pkg/crypto/openpgp/errors/errors.go
index c434b764c9..b9016bd42d 100644
--- a/src/pkg/crypto/openpgp/errors/errors.go
+++ b/src/pkg/crypto/openpgp/errors/errors.go
@@ -47,7 +47,7 @@ func (ki keyIncorrectError) Error() string {
 	return "the given key was incorrect"
 }
 
-var KeyIncorrectError = keyIncorrectError(0)
+var ErrKeyIncorrect error = keyIncorrectError(0)
 
 type unknownIssuerError int
 
@@ -55,7 +55,7 @@ func (unknownIssuerError) Error() string {
 	return "signature make by unknown entity"
 }
 
-var UnknownIssuerError = unknownIssuerError(0)
+var ErrUnknownIssuer error = unknownIssuerError(0)
 
 type UnknownPacketTypeError uint8
 
diff --git a/src/pkg/crypto/openpgp/packet/symmetrically_encrypted.go b/src/pkg/crypto/openpgp/packet/symmetrically_encrypted.go
index e99a23b9fb..f2133ac27f 100644
--- a/src/pkg/crypto/openpgp/packet/symmetrically_encrypted.go
+++ b/src/pkg/crypto/openpgp/packet/symmetrically_encrypted.go
@@ -71,7 +71,7 @@ func (se *SymmetricallyEncrypted) Decrypt(c CipherFunction, key []byte) (io.Read
 
 	s := cipher.NewOCFBDecrypter(c.new(key), se.prefix, ocfbResync)
 	if s == nil {
-		return nil, errors.KeyIncorrectError
+		return nil, errors.ErrKeyIncorrect
 	}
 
 	plaintext := cipher.StreamReader{S: s, R: se.contents}
diff --git a/src/pkg/crypto/openpgp/read.go b/src/pkg/crypto/openpgp/read.go
index 1d23434704..1a6e27c5a6 100644
--- a/src/pkg/crypto/openpgp/read.go
+++ b/src/pkg/crypto/openpgp/read.go
@@ -161,7 +161,7 @@ FindKey:
 					continue
 				}
 				decrypted, err = se.Decrypt(pk.encryptedKey.CipherFunc, pk.encryptedKey.Key)
-				if err != nil && err != errors.KeyIncorrectError {
+				if err != nil && err != errors.ErrKeyIncorrect {
 					return nil, err
 				}
 				if decrypted != nil {
@@ -179,11 +179,11 @@ FindKey:
 		}
 
 		if len(candidates) == 0 && len(symKeys) == 0 {
-			return nil, errors.KeyIncorrectError
+			return nil, errors.ErrKeyIncorrect
 		}
 
 		if prompt == nil {
-			return nil, errors.KeyIncorrectError
+			return nil, errors.ErrKeyIncorrect
 		}
 
 		passphrase, err := prompt(candidates, len(symKeys) != 0)
@@ -197,7 +197,7 @@ FindKey:
 				err = s.Decrypt(passphrase)
 				if err == nil && !s.Encrypted {
 					decrypted, err = se.Decrypt(s.CipherFunc, s.Key)
-					if err != nil && err != errors.KeyIncorrectError {
+					if err != nil && err != errors.ErrKeyIncorrect {
 						return nil, err
 					}
 					if decrypted != nil {
@@ -353,8 +353,8 @@ func (scr *signatureCheckReader) Read(buf []byte) (n int, err error) {
 }
 
 // CheckDetachedSignature takes a signed file and a detached signature and
-// returns the signer if the signature is valid. If the signer isn't know,
-// UnknownIssuerError is returned.
+// returns the signer if the signature is valid. If the signer isn't known,
+// ErrUnknownIssuer is returned.
 func CheckDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signer *Entity, err error) {
 	p, err := packet.Read(signature)
 	if err != nil {
@@ -372,7 +372,7 @@ func CheckDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signe
 
 	keys := keyring.KeysById(*sig.IssuerKeyId)
 	if len(keys) == 0 {
-		return nil, errors.UnknownIssuerError
+		return nil, errors.ErrUnknownIssuer
 	}
 
 	h, wrappedHash, err := hashForSignature(sig.Hash, sig.SigType)
@@ -399,7 +399,7 @@ func CheckDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signe
 		return
 	}
 
-	return nil, errors.UnknownIssuerError
+	return nil, errors.ErrUnknownIssuer
 }
 
 // CheckArmoredDetachedSignature performs the same actions as
diff --git a/src/pkg/crypto/openpgp/read_test.go b/src/pkg/crypto/openpgp/read_test.go
index d1ecad3817..1a449f5d3e 100644
--- a/src/pkg/crypto/openpgp/read_test.go
+++ b/src/pkg/crypto/openpgp/read_test.go
@@ -161,18 +161,18 @@ func TestSignedEncryptedMessage(t *testing.T) {
 		prompt := func(keys []Key, symmetric bool) ([]byte, error) {
 			if symmetric {
 				t.Errorf("prompt: message was marked as symmetrically encrypted")
-				return nil, errors.KeyIncorrectError
+				return nil, errors.ErrKeyIncorrect
 			}
 
 			if len(keys) == 0 {
 				t.Error("prompt: no keys requested")
-				return nil, errors.KeyIncorrectError
+				return nil, errors.ErrKeyIncorrect
 			}
 
 			err := keys[0].PrivateKey.Decrypt([]byte("passphrase"))
 			if err != nil {
 				t.Errorf("prompt: error decrypting key: %s", err)
-				return nil, errors.KeyIncorrectError
+				return nil, errors.ErrKeyIncorrect
 			}
 
 			return nil, nil
