commit 23f3ea82b998e60c500e711dab340852c967ec41
Author: Cherry Zhang <cherryyz@google.com>
Date:   Sat May 11 20:26:18 2019 -0400

    cmd/compile: correct the argument type in SETXXstore -> MOVBstore rules on AMD64
    
    MOVBstore's value argument is a value, not a flag. We are storing
    a byte so just use UInt8.
    
    Fixes #31915.
    
    Change-Id: Id799e5f44efc3a9c3d8480f6f25ad032c2a631bb
    Reviewed-on: https://go-review.googlesource.com/c/go/+/176719
    Run-TryBot: Cherry Zhang <cherryyz@google.com>
    Reviewed-by: Keith Randall <khr@golang.org>
---
 src/cmd/compile/internal/ssa/gen/AMD64.rules | 118 +++----
 src/cmd/compile/internal/ssa/rewriteAMD64.go | 510 ++++++++++++++-------------
 test/fixedbugs/issue31915.go                 |  23 ++
 3 files changed, 342 insertions(+), 309 deletions(-)

diff --git a/src/cmd/compile/internal/ssa/gen/AMD64.rules b/src/cmd/compile/internal/ssa/gen/AMD64.rules
index cdb0e671f7..5e59f7def2 100644
--- a/src/cmd/compile/internal/ssa/gen/AMD64.rules
+++ b/src/cmd/compile/internal/ssa/gen/AMD64.rules
@@ -1369,65 +1369,65 @@
 ((SETNE|SETG|SETGE|SETA|SETAE)   (FlagGT_UGT)) -> (MOVLconst [1])
 ((SETEQ|SETL|SETLE|SETB|SETBE)   (FlagGT_UGT)) -> (MOVLconst [0])
 
-(SETEQstore [off] {sym} ptr x:(FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETEQstore [off] {sym} ptr x:(FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETEQstore [off] {sym} ptr x:(FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETEQstore [off] {sym} ptr x:(FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETEQstore [off] {sym} ptr x:(FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-
-(SETNEstore [off] {sym} ptr x:(FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETNEstore [off] {sym} ptr x:(FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETNEstore [off] {sym} ptr x:(FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETNEstore [off] {sym} ptr x:(FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETNEstore [off] {sym} ptr x:(FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-
-(SETLstore  [off] {sym} ptr x:(FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETLstore  [off] {sym} ptr x:(FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETLstore  [off] {sym} ptr x:(FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETLstore  [off] {sym} ptr x:(FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETLstore  [off] {sym} ptr x:(FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-
-(SETLEstore [off] {sym} ptr x:(FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETLEstore [off] {sym} ptr x:(FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETLEstore [off] {sym} ptr x:(FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETLEstore [off] {sym} ptr x:(FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETLEstore [off] {sym} ptr x:(FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-
-(SETGstore  [off] {sym} ptr x:(FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETGstore  [off] {sym} ptr x:(FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETGstore  [off] {sym} ptr x:(FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETGstore  [off] {sym} ptr x:(FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETGstore  [off] {sym} ptr x:(FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-
-(SETGEstore [off] {sym} ptr x:(FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETGEstore [off] {sym} ptr x:(FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETGEstore [off] {sym} ptr x:(FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETGEstore [off] {sym} ptr x:(FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETGEstore [off] {sym} ptr x:(FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-
-(SETBstore  [off] {sym} ptr x:(FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETBstore  [off] {sym} ptr x:(FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETBstore  [off] {sym} ptr x:(FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETBstore  [off] {sym} ptr x:(FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETBstore  [off] {sym} ptr x:(FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-
-(SETBEstore [off] {sym} ptr x:(FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETBEstore [off] {sym} ptr x:(FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETBEstore [off] {sym} ptr x:(FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETBEstore [off] {sym} ptr x:(FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETBEstore [off] {sym} ptr x:(FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-
-(SETAstore  [off] {sym} ptr x:(FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETAstore  [off] {sym} ptr x:(FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETAstore  [off] {sym} ptr x:(FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETAstore  [off] {sym} ptr x:(FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETAstore  [off] {sym} ptr x:(FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-
-(SETAEstore [off] {sym} ptr x:(FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETAEstore [off] {sym} ptr x:(FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETAEstore [off] {sym} ptr x:(FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
-(SETAEstore [off] {sym} ptr x:(FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
-(SETAEstore [off] {sym} ptr x:(FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+(SETEQstore [off] {sym} ptr (FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETEQstore [off] {sym} ptr (FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETEQstore [off] {sym} ptr (FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETEQstore [off] {sym} ptr (FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETEQstore [off] {sym} ptr (FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+
+(SETNEstore [off] {sym} ptr (FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETNEstore [off] {sym} ptr (FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETNEstore [off] {sym} ptr (FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETNEstore [off] {sym} ptr (FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETNEstore [off] {sym} ptr (FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+
+(SETLstore  [off] {sym} ptr (FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETLstore  [off] {sym} ptr (FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETLstore  [off] {sym} ptr (FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETLstore  [off] {sym} ptr (FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETLstore  [off] {sym} ptr (FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+
+(SETLEstore [off] {sym} ptr (FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETLEstore [off] {sym} ptr (FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETLEstore [off] {sym} ptr (FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETLEstore [off] {sym} ptr (FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETLEstore [off] {sym} ptr (FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+
+(SETGstore  [off] {sym} ptr (FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETGstore  [off] {sym} ptr (FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETGstore  [off] {sym} ptr (FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETGstore  [off] {sym} ptr (FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETGstore  [off] {sym} ptr (FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+
+(SETGEstore [off] {sym} ptr (FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETGEstore [off] {sym} ptr (FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETGEstore [off] {sym} ptr (FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETGEstore [off] {sym} ptr (FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETGEstore [off] {sym} ptr (FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+
+(SETBstore  [off] {sym} ptr (FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETBstore  [off] {sym} ptr (FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETBstore  [off] {sym} ptr (FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETBstore  [off] {sym} ptr (FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETBstore  [off] {sym} ptr (FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+
+(SETBEstore [off] {sym} ptr (FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETBEstore [off] {sym} ptr (FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETBEstore [off] {sym} ptr (FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETBEstore [off] {sym} ptr (FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETBEstore [off] {sym} ptr (FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+
+(SETAstore  [off] {sym} ptr (FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETAstore  [off] {sym} ptr (FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETAstore  [off] {sym} ptr (FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETAstore  [off] {sym} ptr (FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETAstore  [off] {sym} ptr (FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+
+(SETAEstore [off] {sym} ptr (FlagEQ)     mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETAEstore [off] {sym} ptr (FlagLT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETAEstore [off] {sym} ptr (FlagLT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
+(SETAEstore [off] {sym} ptr (FlagGT_ULT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
+(SETAEstore [off] {sym} ptr (FlagGT_UGT) mem) -> (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 
 // Remove redundant *const ops
 (ADDQconst [0] x) -> x
diff --git a/src/cmd/compile/internal/ssa/rewriteAMD64.go b/src/cmd/compile/internal/ssa/rewriteAMD64.go
index d45d23087d..4ffa317a06 100644
--- a/src/cmd/compile/internal/ssa/rewriteAMD64.go
+++ b/src/cmd/compile/internal/ssa/rewriteAMD64.go
@@ -47057,6 +47057,7 @@ func rewriteValueAMD64_OpAMD64SETAE_0(v *Value) bool {
 }
 func rewriteValueAMD64_OpAMD64SETAEstore_0(v *Value) bool {
 	b := v.Block
+	typ := &b.Func.Config.Types
 	// match: (SETAEstore [off] {sym} ptr (InvertFlags x) mem)
 	// cond:
 	// result: (SETBEstore [off] {sym} ptr x mem)
@@ -47129,111 +47130,111 @@ func rewriteValueAMD64_OpAMD64SETAEstore_0(v *Value) bool {
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETAEstore [off] {sym} ptr x:(FlagEQ) mem)
+	// match: (SETAEstore [off] {sym} ptr (FlagEQ) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagEQ {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagEQ {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETAEstore [off] {sym} ptr x:(FlagLT_ULT) mem)
+	// match: (SETAEstore [off] {sym} ptr (FlagLT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETAEstore [off] {sym} ptr x:(FlagLT_UGT) mem)
+	// match: (SETAEstore [off] {sym} ptr (FlagLT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETAEstore [off] {sym} ptr x:(FlagGT_ULT) mem)
+	// match: (SETAEstore [off] {sym} ptr (FlagGT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETAEstore [off] {sym} ptr x:(FlagGT_UGT) mem)
+	// match: (SETAEstore [off] {sym} ptr (FlagGT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
@@ -47243,6 +47244,7 @@ func rewriteValueAMD64_OpAMD64SETAEstore_0(v *Value) bool {
 }
 func rewriteValueAMD64_OpAMD64SETAstore_0(v *Value) bool {
 	b := v.Block
+	typ := &b.Func.Config.Types
 	// match: (SETAstore [off] {sym} ptr (InvertFlags x) mem)
 	// cond:
 	// result: (SETBstore [off] {sym} ptr x mem)
@@ -47315,111 +47317,111 @@ func rewriteValueAMD64_OpAMD64SETAstore_0(v *Value) bool {
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETAstore [off] {sym} ptr x:(FlagEQ) mem)
+	// match: (SETAstore [off] {sym} ptr (FlagEQ) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagEQ {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagEQ {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETAstore [off] {sym} ptr x:(FlagLT_ULT) mem)
+	// match: (SETAstore [off] {sym} ptr (FlagLT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETAstore [off] {sym} ptr x:(FlagLT_UGT) mem)
+	// match: (SETAstore [off] {sym} ptr (FlagLT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETAstore [off] {sym} ptr x:(FlagGT_ULT) mem)
+	// match: (SETAstore [off] {sym} ptr (FlagGT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETAstore [off] {sym} ptr x:(FlagGT_UGT) mem)
+	// match: (SETAstore [off] {sym} ptr (FlagGT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
@@ -47581,6 +47583,7 @@ func rewriteValueAMD64_OpAMD64SETBE_0(v *Value) bool {
 }
 func rewriteValueAMD64_OpAMD64SETBEstore_0(v *Value) bool {
 	b := v.Block
+	typ := &b.Func.Config.Types
 	// match: (SETBEstore [off] {sym} ptr (InvertFlags x) mem)
 	// cond:
 	// result: (SETAEstore [off] {sym} ptr x mem)
@@ -47653,111 +47656,111 @@ func rewriteValueAMD64_OpAMD64SETBEstore_0(v *Value) bool {
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETBEstore [off] {sym} ptr x:(FlagEQ) mem)
+	// match: (SETBEstore [off] {sym} ptr (FlagEQ) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagEQ {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagEQ {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETBEstore [off] {sym} ptr x:(FlagLT_ULT) mem)
+	// match: (SETBEstore [off] {sym} ptr (FlagLT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETBEstore [off] {sym} ptr x:(FlagLT_UGT) mem)
+	// match: (SETBEstore [off] {sym} ptr (FlagLT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETBEstore [off] {sym} ptr x:(FlagGT_ULT) mem)
+	// match: (SETBEstore [off] {sym} ptr (FlagGT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETBEstore [off] {sym} ptr x:(FlagGT_UGT) mem)
+	// match: (SETBEstore [off] {sym} ptr (FlagGT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
@@ -47767,6 +47770,7 @@ func rewriteValueAMD64_OpAMD64SETBEstore_0(v *Value) bool {
 }
 func rewriteValueAMD64_OpAMD64SETBstore_0(v *Value) bool {
 	b := v.Block
+	typ := &b.Func.Config.Types
 	// match: (SETBstore [off] {sym} ptr (InvertFlags x) mem)
 	// cond:
 	// result: (SETAstore [off] {sym} ptr x mem)
@@ -47839,111 +47843,111 @@ func rewriteValueAMD64_OpAMD64SETBstore_0(v *Value) bool {
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETBstore [off] {sym} ptr x:(FlagEQ) mem)
+	// match: (SETBstore [off] {sym} ptr (FlagEQ) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagEQ {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagEQ {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETBstore [off] {sym} ptr x:(FlagLT_ULT) mem)
+	// match: (SETBstore [off] {sym} ptr (FlagLT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETBstore [off] {sym} ptr x:(FlagLT_UGT) mem)
+	// match: (SETBstore [off] {sym} ptr (FlagLT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETBstore [off] {sym} ptr x:(FlagGT_ULT) mem)
+	// match: (SETBstore [off] {sym} ptr (FlagGT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETBstore [off] {sym} ptr x:(FlagGT_UGT) mem)
+	// match: (SETBstore [off] {sym} ptr (FlagGT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
@@ -49459,6 +49463,7 @@ func rewriteValueAMD64_OpAMD64SETEQstore_10(v *Value) bool {
 func rewriteValueAMD64_OpAMD64SETEQstore_20(v *Value) bool {
 	b := v.Block
 	config := b.Func.Config
+	typ := &b.Func.Config.Types
 	// match: (SETEQstore [off] {sym} ptr (TESTL z1:(SHRLconst [31] x) z2) mem)
 	// cond: z1==z2 && !config.nacl
 	// result: (SETAEstore [off] {sym} ptr (BTLconst [31] x) mem)
@@ -49602,111 +49607,111 @@ func rewriteValueAMD64_OpAMD64SETEQstore_20(v *Value) bool {
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETEQstore [off] {sym} ptr x:(FlagEQ) mem)
+	// match: (SETEQstore [off] {sym} ptr (FlagEQ) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagEQ {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagEQ {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETEQstore [off] {sym} ptr x:(FlagLT_ULT) mem)
+	// match: (SETEQstore [off] {sym} ptr (FlagLT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETEQstore [off] {sym} ptr x:(FlagLT_UGT) mem)
+	// match: (SETEQstore [off] {sym} ptr (FlagLT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETEQstore [off] {sym} ptr x:(FlagGT_ULT) mem)
+	// match: (SETEQstore [off] {sym} ptr (FlagGT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETEQstore [off] {sym} ptr x:(FlagGT_UGT) mem)
+	// match: (SETEQstore [off] {sym} ptr (FlagGT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
@@ -49868,6 +49873,7 @@ func rewriteValueAMD64_OpAMD64SETGE_0(v *Value) bool {
 }
 func rewriteValueAMD64_OpAMD64SETGEstore_0(v *Value) bool {
 	b := v.Block
+	typ := &b.Func.Config.Types
 	// match: (SETGEstore [off] {sym} ptr (InvertFlags x) mem)
 	// cond:
 	// result: (SETLEstore [off] {sym} ptr x mem)
@@ -49940,111 +49946,111 @@ func rewriteValueAMD64_OpAMD64SETGEstore_0(v *Value) bool {
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETGEstore [off] {sym} ptr x:(FlagEQ) mem)
+	// match: (SETGEstore [off] {sym} ptr (FlagEQ) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagEQ {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagEQ {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETGEstore [off] {sym} ptr x:(FlagLT_ULT) mem)
+	// match: (SETGEstore [off] {sym} ptr (FlagLT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETGEstore [off] {sym} ptr x:(FlagLT_UGT) mem)
+	// match: (SETGEstore [off] {sym} ptr (FlagLT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETGEstore [off] {sym} ptr x:(FlagGT_ULT) mem)
+	// match: (SETGEstore [off] {sym} ptr (FlagGT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETGEstore [off] {sym} ptr x:(FlagGT_UGT) mem)
+	// match: (SETGEstore [off] {sym} ptr (FlagGT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
@@ -50054,6 +50060,7 @@ func rewriteValueAMD64_OpAMD64SETGEstore_0(v *Value) bool {
 }
 func rewriteValueAMD64_OpAMD64SETGstore_0(v *Value) bool {
 	b := v.Block
+	typ := &b.Func.Config.Types
 	// match: (SETGstore [off] {sym} ptr (InvertFlags x) mem)
 	// cond:
 	// result: (SETLstore [off] {sym} ptr x mem)
@@ -50126,111 +50133,111 @@ func rewriteValueAMD64_OpAMD64SETGstore_0(v *Value) bool {
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETGstore [off] {sym} ptr x:(FlagEQ) mem)
+	// match: (SETGstore [off] {sym} ptr (FlagEQ) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagEQ {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagEQ {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETGstore [off] {sym} ptr x:(FlagLT_ULT) mem)
+	// match: (SETGstore [off] {sym} ptr (FlagLT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETGstore [off] {sym} ptr x:(FlagLT_UGT) mem)
+	// match: (SETGstore [off] {sym} ptr (FlagLT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETGstore [off] {sym} ptr x:(FlagGT_ULT) mem)
+	// match: (SETGstore [off] {sym} ptr (FlagGT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETGstore [off] {sym} ptr x:(FlagGT_UGT) mem)
+	// match: (SETGstore [off] {sym} ptr (FlagGT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
@@ -50392,6 +50399,7 @@ func rewriteValueAMD64_OpAMD64SETLE_0(v *Value) bool {
 }
 func rewriteValueAMD64_OpAMD64SETLEstore_0(v *Value) bool {
 	b := v.Block
+	typ := &b.Func.Config.Types
 	// match: (SETLEstore [off] {sym} ptr (InvertFlags x) mem)
 	// cond:
 	// result: (SETGEstore [off] {sym} ptr x mem)
@@ -50464,111 +50472,111 @@ func rewriteValueAMD64_OpAMD64SETLEstore_0(v *Value) bool {
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETLEstore [off] {sym} ptr x:(FlagEQ) mem)
+	// match: (SETLEstore [off] {sym} ptr (FlagEQ) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagEQ {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagEQ {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETLEstore [off] {sym} ptr x:(FlagLT_ULT) mem)
+	// match: (SETLEstore [off] {sym} ptr (FlagLT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETLEstore [off] {sym} ptr x:(FlagLT_UGT) mem)
+	// match: (SETLEstore [off] {sym} ptr (FlagLT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETLEstore [off] {sym} ptr x:(FlagGT_ULT) mem)
+	// match: (SETLEstore [off] {sym} ptr (FlagGT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETLEstore [off] {sym} ptr x:(FlagGT_UGT) mem)
+	// match: (SETLEstore [off] {sym} ptr (FlagGT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
@@ -50578,6 +50586,7 @@ func rewriteValueAMD64_OpAMD64SETLEstore_0(v *Value) bool {
 }
 func rewriteValueAMD64_OpAMD64SETLstore_0(v *Value) bool {
 	b := v.Block
+	typ := &b.Func.Config.Types
 	// match: (SETLstore [off] {sym} ptr (InvertFlags x) mem)
 	// cond:
 	// result: (SETGstore [off] {sym} ptr x mem)
@@ -50650,111 +50659,111 @@ func rewriteValueAMD64_OpAMD64SETLstore_0(v *Value) bool {
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETLstore [off] {sym} ptr x:(FlagEQ) mem)
+	// match: (SETLstore [off] {sym} ptr (FlagEQ) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagEQ {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagEQ {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETLstore [off] {sym} ptr x:(FlagLT_ULT) mem)
+	// match: (SETLstore [off] {sym} ptr (FlagLT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETLstore [off] {sym} ptr x:(FlagLT_UGT) mem)
+	// match: (SETLstore [off] {sym} ptr (FlagLT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETLstore [off] {sym} ptr x:(FlagGT_ULT) mem)
+	// match: (SETLstore [off] {sym} ptr (FlagGT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETLstore [off] {sym} ptr x:(FlagGT_UGT) mem)
+	// match: (SETLstore [off] {sym} ptr (FlagGT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
@@ -52270,6 +52279,7 @@ func rewriteValueAMD64_OpAMD64SETNEstore_10(v *Value) bool {
 func rewriteValueAMD64_OpAMD64SETNEstore_20(v *Value) bool {
 	b := v.Block
 	config := b.Func.Config
+	typ := &b.Func.Config.Types
 	// match: (SETNEstore [off] {sym} ptr (TESTL z1:(SHRLconst [31] x) z2) mem)
 	// cond: z1==z2 && !config.nacl
 	// result: (SETBstore [off] {sym} ptr (BTLconst [31] x) mem)
@@ -52413,111 +52423,111 @@ func rewriteValueAMD64_OpAMD64SETNEstore_20(v *Value) bool {
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETNEstore [off] {sym} ptr x:(FlagEQ) mem)
+	// match: (SETNEstore [off] {sym} ptr (FlagEQ) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [0]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagEQ {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagEQ {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 0
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETNEstore [off] {sym} ptr x:(FlagLT_ULT) mem)
+	// match: (SETNEstore [off] {sym} ptr (FlagLT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETNEstore [off] {sym} ptr x:(FlagLT_UGT) mem)
+	// match: (SETNEstore [off] {sym} ptr (FlagLT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagLT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagLT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETNEstore [off] {sym} ptr x:(FlagGT_ULT) mem)
+	// match: (SETNEstore [off] {sym} ptr (FlagGT_ULT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_ULT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_ULT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
 		return true
 	}
-	// match: (SETNEstore [off] {sym} ptr x:(FlagGT_UGT) mem)
+	// match: (SETNEstore [off] {sym} ptr (FlagGT_UGT) mem)
 	// cond:
-	// result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
+	// result: (MOVBstore [off] {sym} ptr (MOVLconst <typ.UInt8> [1]) mem)
 	for {
 		off := v.AuxInt
 		sym := v.Aux
 		mem := v.Args[2]
 		ptr := v.Args[0]
-		x := v.Args[1]
-		if x.Op != OpAMD64FlagGT_UGT {
+		v_1 := v.Args[1]
+		if v_1.Op != OpAMD64FlagGT_UGT {
 			break
 		}
 		v.reset(OpAMD64MOVBstore)
 		v.AuxInt = off
 		v.Aux = sym
 		v.AddArg(ptr)
-		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type)
+		v0 := b.NewValue0(v.Pos, OpAMD64MOVLconst, typ.UInt8)
 		v0.AuxInt = 1
 		v.AddArg(v0)
 		v.AddArg(mem)
diff --git a/test/fixedbugs/issue31915.go b/test/fixedbugs/issue31915.go
new file mode 100644
index 0000000000..96af175e23
--- /dev/null
+++ b/test/fixedbugs/issue31915.go
@@ -0,0 +1,23 @@
+// compile -d=ssa/check/on
+
+// Copyright 2019 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package p
+
+func f()
+
+func g() {
+	var a []int
+	var b bool
+	for {
+		b = (b && b) != (b && b)
+		for b && b == b || true {
+			f()
+			_ = a[0]
+		}
+		_ = &b
+		a = []int{}
+	}
+}
