commit 837bc4e502e324abe062999fea1a8a07d0f0bdb8
Author: Shenghou Ma <minux@golang.org>
Date:   Thu Jul 10 15:15:06 2014 -0400

    syscall: nacl/arm support.
    
    LGTM=dave, rsc
    R=rsc, iant, dave
    CC=golang-codereviews
    https://golang.org/cl/101620043
---
 src/pkg/syscall/asm_nacl_arm.s       | 43 ++++++++++++++++++++++++
 src/pkg/syscall/syscall_nacl_arm.go  | 32 ++++++++++++++++++
 src/pkg/syscall/time_nacl_arm.s      | 11 +++++++
 src/pkg/syscall/zsyscall_nacl_arm.go | 63 ++++++++++++++++++++++++++++++++++++
 4 files changed, 149 insertions(+)

diff --git a/src/pkg/syscall/asm_nacl_arm.s b/src/pkg/syscall/asm_nacl_arm.s
new file mode 100644
index 0000000000..ffc48ceaa8
--- /dev/null
+++ b/src/pkg/syscall/asm_nacl_arm.s
@@ -0,0 +1,43 @@
+// Copyright 2014 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+#include "../../cmd/ld/textflag.h"
+#include "../runtime/syscall_nacl.h"
+
+//
+// System call support for ARM, Native Client
+//
+
+#define NACL_SYSCALL(code) \
+	MOVW $(0x10000 + ((code)<<5)), R8; BL (R8)
+
+#define NACL_SYSJMP(code) \
+	MOVW $(0x10000 + ((code)<<5)), R8; B (R8)
+
+TEXT syscall·Syscall(SB),NOSPLIT,$0-28
+	BL	runtime·entersyscall(SB)
+	MOVW	trap+0(FP), R8
+	MOVW	a1+4(FP), R0
+	MOVW	a2+8(FP), R1
+	MOVW	a3+12(FP), R2
+	// more args would use R3, and then stack.
+	MOVW	$0x10000, R7
+	ADD	R8<<5, R7
+	BL	(R7)
+	CMP	$0, R0
+	BGE	ok
+	MOVW	$-1, R1
+	MOVW	R1, r1+16(FP)
+	MOVW	R1, r2+20(FP)
+	RSB	$0, R0
+	MOVW	R0, err+24(FP)
+	BL	runtime·exitsyscall(SB)
+	RET
+ok:
+	MOVW	R0, r1+16(FP)
+	MOVW	R1, r2+20(FP)
+	MOVW	$0, R2
+	MOVW	R2, err+24(FP)
+	BL	runtime·exitsyscall(SB)
+	RET	
diff --git a/src/pkg/syscall/syscall_nacl_arm.go b/src/pkg/syscall/syscall_nacl_arm.go
new file mode 100644
index 0000000000..fc0cdda5da
--- /dev/null
+++ b/src/pkg/syscall/syscall_nacl_arm.go
@@ -0,0 +1,32 @@
+// Copyright 2014 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package syscall
+
+type Timespec struct {
+	Sec  int64
+	Nsec int32
+}
+
+type Timeval struct {
+	Sec  int64
+	Usec int32
+}
+
+func TimespecToNsec(ts Timespec) int64 { return int64(ts.Sec)*1e9 + int64(ts.Nsec) }
+
+func NsecToTimespec(nsec int64) (ts Timespec) {
+	ts.Sec = int64(nsec / 1e9)
+	ts.Nsec = int32(nsec % 1e9)
+	return
+}
+
+func TimevalToNsec(tv Timeval) int64 { return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }
+
+func NsecToTimeval(nsec int64) (tv Timeval) {
+	nsec += 999 // round up to microsecond
+	tv.Usec = int32(nsec % 1e9 / 1e3)
+	tv.Sec = int64(nsec / 1e9)
+	return
+}
diff --git a/src/pkg/syscall/time_nacl_arm.s b/src/pkg/syscall/time_nacl_arm.s
new file mode 100644
index 0000000000..99baaf59b6
--- /dev/null
+++ b/src/pkg/syscall/time_nacl_arm.s
@@ -0,0 +1,11 @@
+// Copyright 2014 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+#include "../../cmd/ld/textflag.h"
+
+TEXT ·startTimer(SB),NOSPLIT,$0
+	B time·startTimer(SB)
+
+TEXT ·stopTimer(SB),NOSPLIT,$0
+	B time·stopTimer(SB)
diff --git a/src/pkg/syscall/zsyscall_nacl_arm.go b/src/pkg/syscall/zsyscall_nacl_arm.go
new file mode 100644
index 0000000000..adbaed0e7d
--- /dev/null
+++ b/src/pkg/syscall/zsyscall_nacl_arm.go
@@ -0,0 +1,63 @@
+// mksyscall.pl -l32 -nacl -arm syscall_nacl.go syscall_nacl_arm.go
+// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
+
+package syscall
+
+import "unsafe"
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func naclClose(fd int) (err error) {
+	_, _, e1 := Syscall(sys_close, uintptr(fd), 0, 0)
+	if e1 != 0 {
+		err = e1
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Exit(code int) (err error) {
+	_, _, e1 := Syscall(sys_exit, uintptr(code), 0, 0)
+	if e1 != 0 {
+		err = e1
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func naclFstat(fd int, stat *Stat_t) (err error) {
+	_, _, e1 := Syscall(sys_fstat, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
+	if e1 != 0 {
+		err = e1
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func naclRead(fd int, b []byte) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(b) > 0 {
+		_p0 = unsafe.Pointer(&b[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall(sys_read, uintptr(fd), uintptr(_p0), uintptr(len(b)))
+	n = int(r0)
+	if e1 != 0 {
+		err = e1
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func naclSeek(fd int, off *int64, whence int) (err error) {
+	_, _, e1 := Syscall(sys_lseek, uintptr(fd), uintptr(unsafe.Pointer(off)), uintptr(whence))
+	if e1 != 0 {
+		err = e1
+	}
+	return
+}
