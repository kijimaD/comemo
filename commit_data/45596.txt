commit 676ad56095c819751ae9f61354cf0fa356e71cb6
Author: Rob Findley <rfindley@google.com>
Date:   Fri Oct 30 11:35:48 2020 -0400

    go/types: reorganize error codes into categories
    
    In CL 264179, some reorganization of error codes was deferred in order
    to minimize diffs between patch-sets.
    
    This CL reorganizes the error codes as discussed. It is a pure
    reordering, with no material changes other than the changing of internal
    const values.
    
    For #42290
    
    Change-Id: I0e9b421a92e96b19e53039652f8de898c5255290
    Reviewed-on: https://go-review.googlesource.com/c/go/+/266637
    Run-TryBot: Robert Findley <rfindley@google.com>
    Trust: Robert Findley <rfindley@google.com>
    Trust: Robert Griesemer <gri@golang.org>
    TryBot-Result: Go Bot <gobot@golang.org>
    Reviewed-by: Robert Griesemer <gri@golang.org>
---
 src/go/types/errorcodes.go | 1504 ++++++++++++++++++++++----------------------
 1 file changed, 748 insertions(+), 756 deletions(-)

diff --git a/src/go/types/errorcodes.go b/src/go/types/errorcodes.go
index 56c2995cff..ba6e2f908b 100644
--- a/src/go/types/errorcodes.go
+++ b/src/go/types/errorcodes.go
@@ -46,14 +46,42 @@ const (
 	// package name already established by other files.
 	_MismatchedPkgName
 
-	/* initialization */
+	// _InvalidPkgUse occurs when a package identifier is used outside of a
+	// selector expression.
+	//
+	// Example:
+	//  import "fmt"
+	//
+	//  var _ = fmt
+	_InvalidPkgUse
 
-	// _DuplicateDecl occurs when an identifier is declared multiple times.
+	/* imports */
+
+	// _BadImportPath occurs when an import path is not valid.
+	_BadImportPath
+
+	// _BrokenImport occurs when importing a package fails.
 	//
 	// Example:
-	//  var x = 1
-	//  var x = 2
-	_DuplicateDecl
+	//  import "amissingpackage"
+	_BrokenImport
+
+	// _ImportCRenamed occurs when the special import "C" is renamed. "C" is a
+	// pseudo-package, and must not be renamed.
+	//
+	// Example:
+	//  import _ "C"
+	_ImportCRenamed
+
+	// _UnusedImport occurs when an import is unused.
+	//
+	// Example:
+	//  import "fmt"
+	//
+	//  func main() {}
+	_UnusedImport
+
+	/* initialization */
 
 	// _InvalidInitCycle occurs when an invalid cycle is detected within the
 	// initialization graph.
@@ -64,6 +92,15 @@ const (
 	//  func f() int { return x }
 	_InvalidInitCycle
 
+	/* decls */
+
+	// _DuplicateDecl occurs when an identifier is declared multiple times.
+	//
+	// Example:
+	//  var x = 1
+	//  var x = 2
+	_DuplicateDecl
+
 	// _InvalidDeclCycle occurs when a declaration cycle is not valid.
 	//
 	// Example:
@@ -76,20 +113,16 @@ const (
 	//  var n = unsafe.Sizeof(T{})
 	_InvalidDeclCycle
 
-	/* consts */
-
-	// _TruncatedFloat occurs when a float constant is truncated to an integer
-	// value.
+	// _InvalidTypeCycle occurs when a cycle in type definitions results in a
+	// type that is not well-defined.
 	//
 	// Example:
-	//  var _ int = 98.6
-	_TruncatedFloat
-
-	// _NumericOverflow occurs when a numeric constant overflows its target type.
+	//  import "unsafe"
 	//
-	// Example:
-	//  var x int8 = 1000
-	_NumericOverflow
+	//  type T [unsafe.Sizeof(T{})]int
+	_InvalidTypeCycle
+
+	/* decls > const */
 
 	// _InvalidConstInit occurs when a const declaration has a non-constant
 	// initializer.
@@ -113,283 +146,194 @@ const (
 	//  const c *int = 4
 	_InvalidConstType
 
-	/* operators */
-
-	/* operators > general */
-
-	// _UndefinedOp occurs when an operator is not defined for the type(s) used
-	// in an operation.
-	//
-	// Example:
-	//  var c = "a" - "b"
-	_UndefinedOp
-
-	// _MismatchedTypes occurs when operand types are incompatible in a binary
-	// operation.
-	//
-	// Example:
-	//  var a = "hello"
-	//  var b = 1
-	//  var c = a - b
-	_MismatchedTypes
-
-	/* operators > shift */
+	/* decls > var (+ other variable assignment codes) */
 
-	// _InvalidShiftCount occurs when the right-hand side of a shift operation is
-	// either non-integer, negative, or too large.
+	// _UntypedNil occurs when the predeclared (untyped) value nil is used to
+	// initialize a variable declared without an explicit type.
 	//
 	// Example:
-	//  var (
-	//  	x string
-	//  	y int = 1 << x
-	//  )
-	_InvalidShiftCount
+	//  var x = nil
+	_UntypedNil
 
-	// _InvalidShiftOperand occurs when the shifted operand is not an integer.
+	// _WrongAssignCount occurs when the number of values on the right-hand side
+	// of an assignment or or initialization expression does not match the number
+	// of variables on the left-hand side.
 	//
 	// Example:
-	//  var s = "hello"
-	//  var x = s << 2
-	_InvalidShiftOperand
-
-	/* operators > chan */
+	//  var x = 1, 2
+	_WrongAssignCount
 
-	// _InvalidReceive occurs when there is a channel receive from a value that
-	// is either not a channel, or is a send-only channel.
+	// _UnassignableOperand occurs when the left-hand side of an assignment is
+	// not assignable.
 	//
 	// Example:
 	//  func f() {
-	//  	var x = 1
-	//  	<-x
+	//  	const c = 1
+	//  	c = 2
 	//  }
-	_InvalidReceive
+	_UnassignableOperand
 
-	// _InvalidSend occurs when there is a channel send to a value that is not a
-	// channel, or is a receive-only channel.
+	// _NoNewVar occurs when a short variable declaration (':=') does not declare
+	// new variables.
 	//
 	// Example:
 	//  func f() {
-	//  	var x = 1
-	//  	x <- "hello!"
+	//  	x := 1
+	//  	x := 2
 	//  }
-	_InvalidSend
-
-	/* operators > & */
+	_NoNewVar
 
-	// _UnaddressableOperand occurs when the & operator is applied to an
-	// unaddressable expression.
+	// _MultiValAssignOp occurs when an assignment operation (+=, *=, etc) does
+	// not have single-valued left-hand or right-hand side.
 	//
-	// Example:
-	//  var x = &1
-	_UnaddressableOperand
-
-	/* operators > * */
-
-	// _InvalidIndirection occurs when a non-pointer value is indirected via the
-	// '*' operator.
+	// Per the spec:
+	//  "In assignment operations, both the left- and right-hand expression lists
+	//  must contain exactly one single-valued expression"
 	//
 	// Example:
-	//  var x int
-	//  var y = *x
-	_InvalidIndirection
-
-	/* operators > index */
+	//  func f() int {
+	//  	x, y := 1, 2
+	//  	x, y += 1
+	//  	return x + y
+	//  }
+	_MultiValAssignOp
 
-	// _NonIndexableOperand occurs when an index operation is applied to a value
-	// that cannot be indexed.
+	// _InvalidIfaceAssign occurs when a value of type T is used as an
+	// interface, but T does not implement a method of the expected interface.
 	//
 	// Example:
-	//  var x = 1
-	//  var y = x[1]
-	_NonIndexableOperand
+	//  type I interface {
+	//  	f()
+	//  }
+	//
+	//  type T int
+	//
+	//  var x I = T(1)
+	_InvalidIfaceAssign
 
-	// _InvalidIndex occurs when an index argument is not of integer type,
-	// negative, or out-of-bounds.
+	// _InvalidChanAssign occurs when a chan assignment is invalid.
 	//
-	// Example:
-	//  var s = [...]int{1,2,3}
-	//  var x = s[5]
+	// Per the spec, a value x is assignable to a channel type T if:
+	//  "x is a bidirectional channel value, T is a channel type, x's type V and
+	//  T have identical element types, and at least one of V or T is not a
+	//  defined type."
 	//
 	// Example:
-	//  var s = []int{1,2,3}
-	//  var _ = s[-1]
+	//  type T1 chan int
+	//  type T2 chan int
 	//
-	// Example:
-	//  var s = []int{1,2,3}
-	//  var i string
-	//  var _ = s[i]
-	_InvalidIndex
+	//  var x T1
+	//  // Invalid assignment because both types are named
+	//  var _ T2 = x
+	_InvalidChanAssign
 
-	// _InvalidSliceExpr occurs when a three-index slice expression (a[x:y:z]) is
-	// applied to a string.
+	// _IncompatibleAssign occurs when the type of the right-hand side expression
+	// in an assignment cannot be assigned to the type of the variable being
+	// assigned.
 	//
 	// Example:
-	//  var s = "hello"
-	//  var x = s[1:2:3]
-	_InvalidSliceExpr
+	//  var x []int
+	//  var _ int = x
+	_IncompatibleAssign
 
-	// _SwappedSliceIndices occurs when constant indices in a slice expression
-	// are decreasing in value.
+	// _UnaddressableFieldAssign occurs when trying to assign to a struct field
+	// in a map value.
 	//
 	// Example:
-	//  var _ = []int{1,2,3}[2:1]
-	_SwappedSliceIndices
+	//  func f() {
+	//  	m := make(map[string]struct{i int})
+	//  	m["foo"].i = 42
+	//  }
+	_UnaddressableFieldAssign
 
-	/* operators > slice */
+	/* decls > type (+ other type expression codes) */
 
-	// _NonSliceableOperand occurs when a slice operation is applied to a value
-	// whose type is not sliceable, or is unaddressable.
+	// _NotAType occurs when the identifier used as the underlying type in a type
+	// declaration or the right-hand side of a type alias does not denote a type.
 	//
 	// Example:
-	//  var x = [...]int{1, 2, 3}[:1]
+	//  var S = 2
 	//
-	// Example:
-	//  var x = 1
-	//  var y = 1[:1]
-	_NonSliceableOperand
-
-	/* operators > division */
+	//  type T S
+	_NotAType
 
-	// _DivByZero occurs when a division operation is provable at compile
-	// time to be a division by zero.
+	// _InvalidArrayLen occurs when an array length is not a constant value.
 	//
 	// Example:
-	//  const divisor = 0
-	//  var x int = 1/divisor
-	_DivByZero
-
-	/* operators > inc/dec */
+	//  var n = 3
+	//  var _ = [n]int{}
+	_InvalidArrayLen
 
-	// _NonNumericIncDec occurs when an increment or decrement operator is
-	// applied to a non-numeric value.
+	// _BlankIfaceMethod occurs when a method name is '_'.
+	//
+	// Per the spec:
+	//  "The name of each explicitly specified method must be unique and not
+	//  blank."
 	//
 	// Example:
-	//  func f() {
-	//  	var c = "c"
-	//  	c++
+	//  type T interface {
+	//  	_(int)
 	//  }
-	_NonNumericIncDec
-
-	/* offsetof */
+	_BlankIfaceMethod
 
-	// _BadOffsetofSyntax occurs when unsafe.Offsetof is called with an argument
-	// that is not a selector expression.
+	// _IncomparableMapKey occurs when a map key type does not support the == and
+	// != operators.
+	//
+	// Per the spec:
+	//  "The comparison operators == and != must be fully defined for operands of
+	//  the key type; thus the key type must not be a function, map, or slice."
 	//
 	// Example:
-	//  import "unsafe"
+	//  var x map[T]int
 	//
-	//  var x int
-	//  var _ = unsafe.Offsetof(x)
-	_BadOffsetofSyntax
+	//  type T []int
+	_IncomparableMapKey
 
-	// _InvalidOffsetof occurs when unsafe.Offsetof is called with a method
-	// selector, rather than a field selector, or when the field is embedded via
-	// a pointer.
-	//
-	// Per the spec:
-	//
-	//  "If f is an embedded field, it must be reachable without pointer
-	//  indirections through fields of the struct. "
-	//
-	// Example:
-	//  import "unsafe"
-	//
-	//  type T struct { f int }
-	//  type S struct { *T }
-	//  var s S
-	//  var _ = unsafe.Offsetof(s.f)
+	// _InvalidIfaceEmbed occurs when a non-interface type is embedded in an
+	// interface.
 	//
 	// Example:
-	//  import "unsafe"
-	//
-	//  type S struct{}
-	//
-	//  func (S) m() {}
+	//  type T struct {}
 	//
-	//  var s S
-	//  var _ = unsafe.Offsetof(s.m)
-	_InvalidOffsetof
-
-	// _UnaddressableFieldAssign occurs when trying to assign to a struct field
-	// in a map value.
+	//  func (T) m()
 	//
-	// Example:
-	//  func f() {
-	//  	m := make(map[string]struct{i int})
-	//  	m["foo"].i = 42
+	//  type I interface {
+	//  	T
 	//  }
-	_UnaddressableFieldAssign
-
-	/* Labels */
+	_InvalidIfaceEmbed
 
-	// _UndeclaredLabel occurs when an undeclared label is jumped to.
+	// _InvalidPtrEmbed occurs when an embedded field is of the pointer form *T,
+	// and T itself is itself a pointer, an unsafe.Pointer, or an interface.
 	//
-	// Example:
-	//  func f() {
-	//  	goto L
-	//  }
-	_UndeclaredLabel
-
-	// _DuplicateLabel occurs when a label is declared more than once.
+	// Per the spec:
+	//  "An embedded field must be specified as a type name T or as a pointer to
+	//  a non-interface type name *T, and T itself may not be a pointer type."
 	//
 	// Example:
-	//  func f() int {
-	//  L:
-	//  L:
-	//  	return 1
-	//  }
-	_DuplicateLabel
-
-	// _UnusedLabel occurs when a label is declared but not used.
+	//  type T *int
 	//
-	// Example:
-	//  func f() {
-	//  L:
+	//  type S struct {
+	//  	*T
 	//  }
-	_UnusedLabel
+	_InvalidPtrEmbed
 
-	// _MisplacedLabel occurs when a break or continue label is not on a for,
-	// switch, or select statement.
-	//
-	// Example:
-	//  func f() {
-	//  L:
-	//  	a := []int{1,2,3}
-	//  	for _, e := range a {
-	//  		if e > 10 {
-	//  			break L
-	//  		}
-	//  		println(a)
-	//  	}
-	//  }
-	_MisplacedLabel
+	/* decls > func and method */
 
-	// _JumpOverDecl occurs when a label jumps over a variable declaration.
+	// _BadRecv occurs when a method declaration does not have exactly one
+	// receiver parameter.
 	//
 	// Example:
-	//  func f() int {
-	//  	goto L
-	//  	x := 2
-	//  L:
-	//  	x++
-	//  	return x
-	//  }
-	_JumpOverDecl
+	//  func () _() {}
+	_BadRecv
 
-	// _JumpIntoBlock occurs when a forward jump goes to a label inside a nested
-	// block.
+	// _InvalidRecv occurs when a receiver type expression is not of the form T
+	// or *T, or T is a pointer type.
 	//
 	// Example:
-	//  func f(x int) {
-	//  	goto L
-	//  	if x > 0 {
-	//  	L:
-	//  		print("inside block")
-	//  	}
-	// }
-	_JumpIntoBlock
-
-	/* type declarations */
+	//  type T struct {}
+	//
+	//  func (**T) m() {}
+	_InvalidRecv
 
 	// _DuplicateFieldAndMethod occurs when an identifier appears as both a field
 	// and method name.
@@ -411,366 +355,383 @@ const (
 	//  func (T) m(i int) int { return i }
 	_DuplicateMethod
 
-	// _InvalidArrayLen occurs when an array length is not a constant value.
-	//
-	// Example:
-	//  var n = 3
-	//  var _ = [n]int{}
-	_InvalidArrayLen
+	/* decls > special */
 
-	// _BlankIfaceMethod occurs when a method name is '_'.
+	// _InvalidBlank occurs when a blank identifier is used as a value or type.
 	//
 	// Per the spec:
-	//  "The name of each explicitly specified method must be unique and not
-	//  blank."
+	//  "The blank identifier may appear as an operand only on the left-hand side
+	//  of an assignment."
 	//
 	// Example:
-	//  type T interface {
-	//  	_(int)
-	//  }
-	_BlankIfaceMethod
+	//  var x = _
+	_InvalidBlank
 
-	// _NotAType occurs when the identifier used as the underlying type in a type
-	// declaration or the right-hand side of a type alias does not denote a type.
+	// _InvalidIota occurs when the predeclared identifier iota is used outside
+	// of a constant declaration.
 	//
 	// Example:
-	//  var S = 2
+	//  var x = iota
+	_InvalidIota
+
+	// _MissingInitBody occurs when an init function is missing its body.
 	//
-	//  type T S
-	_NotAType
+	// Example:
+	//  func init()
+	_MissingInitBody
 
-	// _IncomparableMapKey occurs when a map key type does not support the == and
-	// != operators.
+	// _InvalidInitSig occurs when an init function declares parameters or
+	// results.
 	//
-	// Per the spec:
-	//  "The comparison operators == and != must be fully defined for operands of
-	//  the key type; thus the key type must not be a function, map, or slice."
+	// Example:
+	//  func init() int { return 1 }
+	_InvalidInitSig
+
+	// _InvalidInitDecl occurs when init is declared as anything other than a
+	// function.
 	//
 	// Example:
-	//  var x map[T]int
+	//  var init = 1
+	_InvalidInitDecl
+
+	// _InvalidMainDecl occurs when main is declared as anything other than a
+	// function, in a main package.
+	_InvalidMainDecl
+
+	/* exprs */
+
+	// _TooManyValues occurs when a function returns too many values for the
+	// expression context in which it is used.
 	//
-	//  type T []int
-	_IncomparableMapKey
+	// Example:
+	//  func ReturnTwo() (int, int) {
+	//  	return 1, 2
+	//  }
+	//
+	//  var x = ReturnTwo()
+	_TooManyValues
 
-	// _InvalidIfaceEmbed occurs when a non-interface type is embedded in an
-	// interface.
+	// _NotAnExpr occurs when a type expression is used where a value expression
+	// is expected.
 	//
 	// Example:
 	//  type T struct {}
 	//
-	//  func (T) m()
-	//
-	//  type I interface {
+	//  func f() {
 	//  	T
 	//  }
-	_InvalidIfaceEmbed
+	_NotAnExpr
 
-	// _InvalidPtrEmbed occurs when an embedded field is of the pointer form *T,
-	// and T itself is itself a pointer, an unsafe.Pointer, or an interface.
-	//
-	// Per the spec:
-	//  "An embedded field must be specified as a type name T or as a pointer to
-	//  a non-interface type name *T, and T itself may not be a pointer type."
+	/* exprs > const */
+
+	// _TruncatedFloat occurs when a float constant is truncated to an integer
+	// value.
 	//
 	// Example:
-	//  type T *int
-	//
-	//  type S struct {
-	//  	*T
-	//  }
-	_InvalidPtrEmbed
+	//  var _ int = 98.6
+	_TruncatedFloat
 
-	// _InvalidTypeCycle occurs when a cycle in type definitions results in a
-	// type that is not well-defined.
+	// _NumericOverflow occurs when a numeric constant overflows its target type.
 	//
 	// Example:
-	//  import "unsafe"
-	//
-	//  type T [unsafe.Sizeof(T{})]int
-	_InvalidTypeCycle
+	//  var x int8 = 1000
+	_NumericOverflow
 
-	/* function declarations */
+	/* exprs > operation */
 
-	// _MissingInitBody occurs when an init function is missing its body.
+	// _UndefinedOp occurs when an operator is not defined for the type(s) used
+	// in an operation.
 	//
 	// Example:
-	//  func init()
-	_MissingInitBody
+	//  var c = "a" - "b"
+	_UndefinedOp
 
-	// _BadRecv occurs when a method declaration does not have exactly one
-	// receiver parameter.
+	// _MismatchedTypes occurs when operand types are incompatible in a binary
+	// operation.
 	//
 	// Example:
-	//  func () _() {}
-	_BadRecv
+	//  var a = "hello"
+	//  var b = 1
+	//  var c = a - b
+	_MismatchedTypes
 
-	// _InvalidRecv occurs when a receiver type expression is not of the form T
-	// or *T, or T is a pointer type.
+	// _DivByZero occurs when a division operation is provable at compile
+	// time to be a division by zero.
 	//
 	// Example:
-	//  type T struct {}
-	//
-	//  func (**T) m() {}
-	_InvalidRecv
+	//  const divisor = 0
+	//  var x int = 1/divisor
+	_DivByZero
 
-	// _MissingReturn occurs when a function with results is missing a return
-	// statement.
+	// _NonNumericIncDec occurs when an increment or decrement operator is
+	// applied to a non-numeric value.
 	//
 	// Example:
-	//  func f() int {}
-	_MissingReturn
-
-	// _WrongResultCount occurs when a return statement returns an incorrect
-	// number of values.
-	//
-	// Example:
-	//  func ReturnOne() int {
-	//  	return 1, 2
+	//  func f() {
+	//  	var c = "c"
+	//  	c++
 	//  }
-	_WrongResultCount
+	_NonNumericIncDec
 
-	// _OutOfScopeResult occurs when the name of a value implicitly returned by
-	// an empty return statement is shadowed in a nested scope.
-	//
-	// Example:
-	//  func factor(n int) (i int) {
-	//  	for i := 2; i < n; i++ {
-	//  		if n%i == 0 {
-	//  			return
-	//  		}
-	//  	}
-	//  	return 0
-	//  }
-	_OutOfScopeResult
+	/* exprs > ptr */
 
-	// _InvalidInitDecl occurs when init is declared as anything other than a
-	// function.
+	// _UnaddressableOperand occurs when the & operator is applied to an
+	// unaddressable expression.
 	//
 	// Example:
-	//  var init = 1
-	_InvalidInitDecl
-
-	// _InvalidMainDecl occurs when main is declared as anything other than a
-	// function, in a main package.
-	_InvalidMainDecl
+	//  var x = &1
+	_UnaddressableOperand
 
-	// _InvalidInitSig occurs when an init function declares parameters or
-	// results.
+	// _InvalidIndirection occurs when a non-pointer value is indirected via the
+	// '*' operator.
 	//
 	// Example:
-	//  func init() int { return 1 }
-	_InvalidInitSig
+	//  var x int
+	//  var y = *x
+	_InvalidIndirection
 
-	/* imports */
+	/* exprs > [] */
 
-	// _BadImportPath occurs when an import path is not valid.
-	_BadImportPath
-
-	// _BrokenImport occurs when importing a package fails.
+	// _NonIndexableOperand occurs when an index operation is applied to a value
+	// that cannot be indexed.
 	//
 	// Example:
-	//  import "amissingpackage"
-	_BrokenImport
+	//  var x = 1
+	//  var y = x[1]
+	_NonIndexableOperand
 
-	// _UnusedImport occurs when an import is unused.
+	// _InvalidIndex occurs when an index argument is not of integer type,
+	// negative, or out-of-bounds.
 	//
 	// Example:
-	//  import "fmt"
+	//  var s = [...]int{1,2,3}
+	//  var x = s[5]
 	//
-	//  func main() {}
-	_UnusedImport
-
-	// _ImportCRenamed occurs when the special import "C" is renamed. "C" is a
-	// pseudo-package, and must not be renamed.
+	// Example:
+	//  var s = []int{1,2,3}
+	//  var _ = s[-1]
 	//
 	// Example:
-	//  import _ "C"
-	_ImportCRenamed
+	//  var s = []int{1,2,3}
+	//  var i string
+	//  var _ = s[i]
+	_InvalidIndex
 
-	// _UndeclaredImportedName occurs when a package-qualified identifier is
-	// undeclared by the imported package.
+	// _SwappedSliceIndices occurs when constant indices in a slice expression
+	// are decreasing in value.
 	//
 	// Example:
-	//  import "go/types"
-	//
-	//  var _ = types.NotAnActualIdentifier
-	_UndeclaredImportedName
+	//  var _ = []int{1,2,3}[2:1]
+	_SwappedSliceIndices
 
-	// _UnexportedName occurs when a selector refers to an unexported identifier
-	// of an imported package.
+	/* operators > slice */
+
+	// _NonSliceableOperand occurs when a slice operation is applied to a value
+	// whose type is not sliceable, or is unaddressable.
 	//
 	// Example:
-	//  import "reflect"
+	//  var x = [...]int{1, 2, 3}[:1]
 	//
-	//  type _ reflect.flag
-	_UnexportedName
+	// Example:
+	//  var x = 1
+	//  var y = 1[:1]
+	_NonSliceableOperand
 
-	// _InvalidPkgUse occurs when a package identifier is used outside of a
-	// selector expression.
+	// _InvalidSliceExpr occurs when a three-index slice expression (a[x:y:z]) is
+	// applied to a string.
 	//
 	// Example:
-	//  import "fmt"
-	//
-	//  var _ = fmt
-	_InvalidPkgUse
+	//  var s = "hello"
+	//  var x = s[1:2:3]
+	_InvalidSliceExpr
 
-	/* assignment */
+	/* exprs > shift */
 
-	// _WrongAssignCount occurs when the number of values on the right-hand side
-	// of an assignment or or initialization expression does not match the number
-	// of variables on the left-hand side.
+	// _InvalidShiftCount occurs when the right-hand side of a shift operation is
+	// either non-integer, negative, or too large.
 	//
 	// Example:
-	//  var x = 1, 2
-	_WrongAssignCount
+	//  var (
+	//  	x string
+	//  	y int = 1 << x
+	//  )
+	_InvalidShiftCount
 
-	// _UntypedNil occurs when the predeclared (untyped) value nil is used to
-	// initialize a variable declared without an explicit type.
+	// _InvalidShiftOperand occurs when the shifted operand is not an integer.
 	//
 	// Example:
-	//  var x = nil
-	_UntypedNil
+	//  var s = "hello"
+	//  var x = s << 2
+	_InvalidShiftOperand
 
-	// _TooManyValues occurs when a function returns too many values for the
-	// expression context in which it is used.
+	/* exprs > chan */
+
+	// _InvalidReceive occurs when there is a channel receive from a value that
+	// is either not a channel, or is a send-only channel.
 	//
 	// Example:
-	//  func ReturnTwo() (int, int) {
-	//  	return 1, 2
+	//  func f() {
+	//  	var x = 1
+	//  	<-x
 	//  }
-	//
-	//  var x = ReturnTwo()
-	_TooManyValues
+	_InvalidReceive
 
-	// _MultiValAssignOp occurs when an assignment operation (+=, *=, etc) does
-	// not have single-valued left-hand or right-hand side.
-	//
-	// Per the spec:
-	//  "In assignment operations, both the left- and right-hand expression lists
-	//  must contain exactly one single-valued expression"
+	// _InvalidSend occurs when there is a channel send to a value that is not a
+	// channel, or is a receive-only channel.
 	//
 	// Example:
-	//  func f() int {
-	//  	x, y := 1, 2
-	//  	x, y += 1
-	//  	return x + y
+	//  func f() {
+	//  	var x = 1
+	//  	x <- "hello!"
 	//  }
-	_MultiValAssignOp
+	_InvalidSend
 
-	// _InvalidIfaceAssign occurs when a value of type T is used as an
-	// interface, but T does not implement a method of the expected interface.
+	/* exprs > literal */
+
+	// _DuplicateLitKey occurs when an index is duplicated in a slice, array, or
+	// map literal.
 	//
 	// Example:
-	//  type I interface {
-	//  	f()
-	//  }
+	//  var _ = []int{0:1, 0:2}
 	//
-	//  type T int
+	// Example:
+	//  var _ = map[string]int{"a": 1, "a": 2}
+	_DuplicateLitKey
+
+	// _MissingLitKey occurs when a map literal is missing a key expression.
 	//
-	//  var x I = T(1)
-	_InvalidIfaceAssign
+	// Example:
+	//  var _ = map[string]int{1}
+	_MissingLitKey
 
-	// _InvalidChanAssign occurs when a chan assignment is invalid.
+	// _InvalidLitIndex occurs when the key in a key-value element of a slice or
+	// array literal is not an integer constant.
 	//
-	// Per the spec, a value x is assignable to a channel type T if:
-	//  "x is a bidirectional channel value, T is a channel type, x's type V and
-	//  T have identical element types, and at least one of V or T is not a
-	//  defined type."
+	// Example:
+	//  var i = 0
+	//  var x = []string{i: "world"}
+	_InvalidLitIndex
+
+	// _OversizeArrayLit occurs when an array literal exceeds its length.
 	//
 	// Example:
-	//  type T1 chan int
-	//  type T2 chan int
+	//  var _ = [2]int{1,2,3}
+	_OversizeArrayLit
+
+	// _MixedStructLit occurs when a struct literal contains a mix of positional
+	// and named elements.
 	//
-	//  var x T1
-	//  // Invalid assignment because both types are named
-	//  var _ T2 = x
-	_InvalidChanAssign
+	// Example:
+	//  var _ = struct{i, j int}{i: 1, 2}
+	_MixedStructLit
 
-	// _IncompatibleAssign occurs when the type of the right-hand side expression
-	// in an assignment cannot be assigned to the type of the variable being
-	// assigned.
+	// _InvalidStructLit occurs when a positional struct literal has an incorrect
+	// number of values.
 	//
 	// Example:
-	//  var x []int
-	//  var _ int = x
-	_IncompatibleAssign
+	//  var _ = struct{i, j int}{1,2,3}
+	_InvalidStructLit
 
-	/* assertions */
+	// _MissingLitField occurs when a struct literal refers to a field that does
+	// not exist on the struct type.
+	//
+	// Example:
+	//  var _ = struct{i int}{j: 2}
+	_MissingLitField
 
-	// _InvalidAssert occurs when a type assertion is applied to a
-	// value that is not of interface type.
+	// _DuplicateLitField occurs when a struct literal contains duplicated
+	// fields.
 	//
 	// Example:
-	//  var x = 1
-	//  var _ = x.(float64)
-	_InvalidAssert
+	//  var _ = struct{i int}{i: 1, i: 2}
+	_DuplicateLitField
 
-	// _ImpossibleAssert occurs for a type assertion x.(T) when the value x of
-	// interface cannot have dynamic type T, due to a missing or mismatching
-	// method on T.
+	// _UnexportedLitField occurs when a positional struct literal implicitly
+	// assigns an unexported field of an imported type.
+	_UnexportedLitField
+
+	// _InvalidLitField occurs when a field name is not a valid identifier.
 	//
 	// Example:
-	//  type T int
+	//  var _ = struct{i int}{1: 1}
+	_InvalidLitField
+
+	// _UntypedLit occurs when a composite literal omits a required type
+	// identifier.
 	//
-	//  func (t *T) m() int { return int(*t) }
+	// Example:
+	//  type outer struct{
+	//  	inner struct { i int }
+	//  }
 	//
-	//  type I interface { m() int }
+	//  var _ = outer{inner: {1}}
+	_UntypedLit
+
+	// _InvalidLit occurs when a composite literal expression does not match its
+	// type.
 	//
-	//  var x I
-	//  var _ = x.(T)
-	_ImpossibleAssert
+	// Example:
+	//  type P *struct{
+	//  	x int
+	//  }
+	//  var _ = P {}
+	_InvalidLit
 
-	/* conversions */
+	/* exprs > selector */
 
-	// _InvalidConversion occurs when the argument type cannot be converted to the
-	// target.
-	//
-	// See https://golang.org/ref/spec#Conversions for the rules of
-	// convertibility.
+	// _AmbiguousSelector occurs when a selector is ambiguous.
 	//
 	// Example:
-	//  var x float64
-	//  var _ = string(x)
-	_InvalidConversion
+	//  type E1 struct { i int }
+	//  type E2 struct { i int }
+	//  type T struct { E1; E2 }
+	//
+	//  var x T
+	//  var _ = x.i
+	_AmbiguousSelector
 
-	// _UnassignableOperand occurs when the left-hand side of an assignment is
-	// not assignable.
+	// _UndeclaredImportedName occurs when a package-qualified identifier is
+	// undeclared by the imported package.
 	//
 	// Example:
-	//  func f() {
-	//  	const c = 1
-	//  	c = 2
-	//  }
-	_UnassignableOperand
+	//  import "go/types"
+	//
+	//  var _ = types.NotAnActualIdentifier
+	_UndeclaredImportedName
 
-	// _InvalidPostDecl occurs when there is a declaration in a for-loop post
-	// statement.
+	// _UnexportedName occurs when a selector refers to an unexported identifier
+	// of an imported package.
 	//
 	// Example:
-	//  func f() {
-	//  	for i := 0; i < 10; j := 0 {}
-	//  }
-	_InvalidPostDecl
+	//  import "reflect"
+	//
+	//  type _ reflect.flag
+	_UnexportedName
 
-	// _UnusedVar occurs when a variable is declared but unused.
+	// _UndeclaredName occurs when an identifier is not declared in the current
+	// scope.
 	//
 	// Example:
-	//  func f() {
-	//  	x := 1
-	//  }
-	_UnusedVar
+	//  var x T
+	_UndeclaredName
 
-	// _NoNewVar occurs when a short variable declaration (':=') does not declare
-	// new variables.
+	// _MissingFieldOrMethod occurs when a selector references a field or method
+	// that does not exist.
 	//
 	// Example:
-	//  func f() {
-	//  	x := 1
-	//  	x := 2
-	//  }
-	_NoNewVar
+	//  type T struct {}
+	//
+	//  var x = T{}.f
+	_MissingFieldOrMethod
 
-	/* dot dot dot */
+	/* exprs > ... */
+
+	// _BadDotDotDotSyntax occurs when a "..." occurs in a context where it is
+	// not valid.
+	//
+	// Example:
+	//  var _ = map[int][...]int{0: {}}
+	_BadDotDotDotSyntax
 
 	// _NonVariadicDotDotDot occurs when a "..." is used on the final argument to
 	// a non-variadic function.
@@ -803,123 +764,47 @@ const (
 	//  	printArgs(0, a...)
 	//  }
 	_MisplacedDotDotDot
-
-	// _InvalidDotDotDotOperand occurs when a "..." operator is applied to a
-	// single-valued operand.
-	//
-	// Example:
-	//  func printArgs(args ...int) {
-	//  	for _, a := range args {
-	//  		println(a)
-	//  	}
-	//  }
-	//
-	//  func f() {
-	//  	a := 1
-	//  	printArgs(a...)
-	//  }
-	//
-	// Example:
-	//  func args() (int, int) {
-	//  	return 1, 2
-	//  }
-	//
-	//  func printArgs(args ...int) {
-	//  	for _, a := range args {
-	//  		println(a)
-	//  	}
-	//  }
-	//
-	//  func g() {
-	//  	printArgs(args()...)
-	//  }
-	_InvalidDotDotDotOperand
-
-	/* selectors */
-
-	// _MissingFieldOrMethod occurs when a selector references a field or method
-	// that does not exist.
-	//
-	// Example:
-	//  type T struct {}
-	//
-	//  var x = T{}.f
-	_MissingFieldOrMethod
-
-	// _AmbiguousSelector occurs when a selector is ambiguous.
-	//
-	// Example:
-	//  type E1 struct { i int }
-	//  type E2 struct { i int }
-	//  type T struct { E1; E2 }
-	//
-	//  var x T
-	//  var _ = x.i
-	_AmbiguousSelector
-
-	/* calls */
-
-	// _InvalidMethodExpr occurs when a pointer method is called but the argument
-	// is not addressable.
-	//
-	// Example:
-	//  type T struct {}
-	//
-	//  func (*T) m() int { return 1 }
-	//
-	//  var _ = T.m(T{})
-	_InvalidMethodExpr
-
-	// _InvalidCall occurs when an expression is called that is not of function
-	// type.
-	//
-	// Example:
-	//  var x = "x"
-	//  var y = x()
-	_InvalidCall
-
-	// _WrongArgCount occurs when too few or too many arguments are passed by a
-	// function call.
-	//
-	// Example:
-	//  func f(i int) {}
-	//  var x = f()
-	_WrongArgCount
-
-	/* suspended calls */
-
-	// _InvalidDefer occurs when a deferred expression is not a function call,
-	// for example if the expression is a type conversion.
+
+	// _InvalidDotDotDotOperand occurs when a "..." operator is applied to a
+	// single-valued operand.
 	//
 	// Example:
-	//  func f(i int) int {
-	//  	defer int32(i)
-	//  	return i
+	//  func printArgs(args ...int) {
+	//  	for _, a := range args {
+	//  		println(a)
+	//  	}
+	//  }
+	//
+	//  func f() {
+	//  	a := 1
+	//  	printArgs(a...)
 	//  }
-	_InvalidDefer
-
-	// _InvalidGo occurs when a go expression is not a function call, for example
-	// if the expression is a type conversion.
 	//
 	// Example:
-	//  func f(i int) int {
-	//  	go int32(i)
-	//  	return i
+	//  func args() (int, int) {
+	//  	return 1, 2
 	//  }
-	_InvalidGo
+	//
+	//  func printArgs(args ...int) {
+	//  	for _, a := range args {
+	//  		println(a)
+	//  	}
+	//  }
+	//
+	//  func g() {
+	//  	printArgs(args()...)
+	//  }
+	_InvalidDotDotDotOperand
 
-	// _UnusedResults occurs when a restricted expression-only built-in function
-	// is suspended via go or defer. Such a suspension discards the results of
-	// these side-effect free built-in functions, and therefore is ineffectual.
+	// _InvalidDotDotDot occurs when a "..." is used in a non-variadic built-in
+	// function.
 	//
 	// Example:
-	//  func f(a []int) int {
-	//  	defer len(a)
-	//  	return i
-	//  }
-	_UnusedResults
+	//  var s = []int{1, 2, 3}
+	//  var l = len(s...)
+	_InvalidDotDotDot
 
-	/* built-in functions */
+	/* exprs > built-in */
 
 	// _UncalledBuiltin occurs when a built-in function is used as a
 	// function-valued expression, instead of being called.
@@ -932,15 +817,33 @@ const (
 	//  var _ = copy
 	_UncalledBuiltin
 
-	// _InvalidDotDotDot occurs when a "..." is used in a non-variadic built-in
-	// function.
+	// _InvalidAppend occurs when append is called with a first argument that is
+	// not a slice.
 	//
 	// Example:
-	//  var s = []int{1, 2, 3}
-	//  var l = len(s...)
-	_InvalidDotDotDot
+	//  var _ = append(1, 2)
+	_InvalidAppend
+
+	// _InvalidCap occurs when an argument to the cap built-in function is not of
+	// supported type.
+	//
+	// See https://golang.org/ref/spec#Length_and_capacity for information on
+	// which underlying types are supported as arguments to cap and len.
+	//
+	// Example:
+	//  var s = 2
+	//  var x = cap(s)
+	_InvalidCap
 
-	/* built-ins > copy */
+	// _InvalidClose occurs when close(...) is called with an argument that is
+	// not of channel type, or that is a receive-only channel.
+	//
+	// Example:
+	//  func f() {
+	//  	var x int
+	//  	close(x)
+	//  }
+	_InvalidClose
 
 	// _InvalidCopy occurs when the arguments are not of slice type or do not
 	// have compatible type.
@@ -956,18 +859,29 @@ const (
 	//  }
 	_InvalidCopy
 
-	/* built-ins > cap/len */
+	// _InvalidComplex occurs when the complex built-in function is called with
+	// arguments with incompatible types.
+	//
+	// Example:
+	//  var _ = complex(float32(1), float64(2))
+	_InvalidComplex
 
-	// _InvalidCap occurs when an argument to the cap built-in function is not of
-	// supported type.
+	// _InvalidDelete occurs when the delete built-in function is called with a
+	// first argument that is not a map.
 	//
-	// See https://golang.org/ref/spec#Length_and_capacity for information on
-	// which underlying types are supported as arguments to cap and len.
+	// Example:
+	//  func f() {
+	//  	m := "hello"
+	//  	delete(m, "e")
+	//  }
+	_InvalidDelete
+
+	// _InvalidImag occurs when the imag built-in function is called with an
+	// argument that does not have complex type.
 	//
 	// Example:
-	//  var s = 2
-	//  var x = cap(s)
-	_InvalidCap
+	//  var _ = imag(int(1))
+	_InvalidImag
 
 	// _InvalidLen occurs when an argument to the len built-in function is not of
 	// supported type.
@@ -980,20 +894,6 @@ const (
 	//  var x = len(s)
 	_InvalidLen
 
-	/* built-ins > close */
-
-	// _InvalidClose occurs when close(...) is called with an argument that is
-	// not of channel type, or that is a receive-only channel.
-	//
-	// Example:
-	//  func f() {
-	//  	var x int
-	//  	close(x)
-	//  }
-	_InvalidClose
-
-	/* built-ins > make */
-
 	// _SwappedMakeArgs occurs when make is called with three arguments, and its
 	// length argument is larger than its capacity argument.
 	//
@@ -1010,139 +910,206 @@ const (
 	//  var x = make(int)
 	_InvalidMake
 
-	/* built-ins > delete */
-
-	// _InvalidDelete occurs when the delete built-in function is called with a
-	// first argument that is not a map.
+	// _InvalidReal occurs when the real built-in function is called with an
+	// argument that does not have complex type.
 	//
 	// Example:
-	//  func f() {
-	//  	m := "hello"
-	//  	delete(m, "e")
-	//  }
-	_InvalidDelete
+	//  var _ = real(int(1))
+	_InvalidReal
 
-	/* built-ins > complex/imag/real */
+	/* exprs > assertion */
 
-	// _InvalidImag occurs when the imag built-in function is called with an
-	// argument that does not have complex type.
+	// _InvalidAssert occurs when a type assertion is applied to a
+	// value that is not of interface type.
 	//
 	// Example:
-	//  var _ = imag(int(1))
-	_InvalidImag
+	//  var x = 1
+	//  var _ = x.(float64)
+	_InvalidAssert
 
-	// _InvalidReal occurs when the real built-in function is called with an
-	// argument that does not have complex type.
+	// _ImpossibleAssert occurs for a type assertion x.(T) when the value x of
+	// interface cannot have dynamic type T, due to a missing or mismatching
+	// method on T.
 	//
 	// Example:
-	//  var _ = real(int(1))
-	_InvalidReal
+	//  type T int
+	//
+	//  func (t *T) m() int { return int(*t) }
+	//
+	//  type I interface { m() int }
+	//
+	//  var x I
+	//  var _ = x.(T)
+	_ImpossibleAssert
 
-	// _InvalidComplex occurs when the complex built-in function is called with
-	// arguments with incompatible types.
+	/* exprs > conversion */
+
+	// _InvalidConversion occurs when the argument type cannot be converted to the
+	// target.
+	//
+	// See https://golang.org/ref/spec#Conversions for the rules of
+	// convertibility.
 	//
 	// Example:
-	//  var _ = complex(float32(1), float64(2))
-	_InvalidComplex
-
-	/* built-ins > append */
+	//  var x float64
+	//  var _ = string(x)
+	_InvalidConversion
 
-	// _InvalidAppend occurs when append is called with a first argument that is
-	// not a slice.
+	// _InvalidUntypedConversion occurs when an there is no valid implicit
+	// conversion from an untyped value satisfying the type constraints of the
+	// context in which it is used.
 	//
 	// Example:
-	//  var _ = append(1, 2)
-	_InvalidAppend
+	//  var _ = 1 + ""
+	_InvalidUntypedConversion
 
-	/* literals */
+	/* offsetof */
 
-	// _InvalidLitIndex occurs when the key in a key-value element of a slice or
-	// array literal is not an integer constant.
+	// _BadOffsetofSyntax occurs when unsafe.Offsetof is called with an argument
+	// that is not a selector expression.
 	//
 	// Example:
-	//  var i = 0
-	//  var x = []string{i: "world"}
-	_InvalidLitIndex
+	//  import "unsafe"
+	//
+	//  var x int
+	//  var _ = unsafe.Offsetof(x)
+	_BadOffsetofSyntax
 
-	// _OversizeArrayLit occurs when an array literal exceeds its length.
+	// _InvalidOffsetof occurs when unsafe.Offsetof is called with a method
+	// selector, rather than a field selector, or when the field is embedded via
+	// a pointer.
+	//
+	// Per the spec:
+	//
+	//  "If f is an embedded field, it must be reachable without pointer
+	//  indirections through fields of the struct. "
 	//
 	// Example:
-	//  var _ = [2]int{1,2,3}
-	_OversizeArrayLit
-
-	// _DuplicateLitKey occurs when an index is duplicated in a slice, array, or
-	// map literal.
+	//  import "unsafe"
+	//
+	//  type T struct { f int }
+	//  type S struct { *T }
+	//  var s S
+	//  var _ = unsafe.Offsetof(s.f)
 	//
 	// Example:
-	//  var _ = []int{0:1, 0:2}
+	//  import "unsafe"
+	//
+	//  type S struct{}
+	//
+	//  func (S) m() {}
+	//
+	//  var s S
+	//  var _ = unsafe.Offsetof(s.m)
+	_InvalidOffsetof
+
+	/* control flow > scope */
+
+	// _UnusedExpr occurs when a side-effect free expression is used as a
+	// statement. Such a statement has no effect.
 	//
 	// Example:
-	//  var _ = map[string]int{"a": 1, "a": 2}
-	_DuplicateLitKey
+	//  func f(i int) {
+	//  	i*i
+	//  }
+	_UnusedExpr
 
-	// _BadDotDotDotSyntax occurs when a "..." occurs in a context where it is
-	// not valid.
+	// _UnusedVar occurs when a variable is declared but unused.
 	//
 	// Example:
-	//  var _ = map[int][...]int{0: {}}
-	_BadDotDotDotSyntax
+	//  func f() {
+	//  	x := 1
+	//  }
+	_UnusedVar
 
-	// _MissingLitKey occurs when a map literal is missing a key expression.
+	// _MissingReturn occurs when a function with results is missing a return
+	// statement.
 	//
 	// Example:
-	//  var _ = map[string]int{1}
-	_MissingLitKey
+	//  func f() int {}
+	_MissingReturn
 
-	// _InvalidStructLit occurs when a positional struct literal has an incorrect
+	// _WrongResultCount occurs when a return statement returns an incorrect
 	// number of values.
 	//
 	// Example:
-	//  var _ = struct{i, j int}{1,2,3}
-	_InvalidStructLit
+	//  func ReturnOne() int {
+	//  	return 1, 2
+	//  }
+	_WrongResultCount
+
+	// _OutOfScopeResult occurs when the name of a value implicitly returned by
+	// an empty return statement is shadowed in a nested scope.
+	//
+	// Example:
+	//  func factor(n int) (i int) {
+	//  	for i := 2; i < n; i++ {
+	//  		if n%i == 0 {
+	//  			return
+	//  		}
+	//  	}
+	//  	return 0
+	//  }
+	_OutOfScopeResult
 
-	// _UntypedLit occurs when a composite literal omits a required type
-	// identifier.
+	/* control flow > if */
+
+	// _InvalidCond occurs when an if condition is not a boolean expression.
 	//
 	// Example:
-	//  type outer struct{
-	//  	inner struct { i int }
+	//  func checkReturn(i int) {
+	//  	if i {
+	//  		panic("non-zero return")
+	//  	}
 	//  }
-	//
-	//  var _ = outer{inner: {1}}
-	_UntypedLit
+	_InvalidCond
 
-	// _MixedStructLit occurs when a struct literal contains a mix of positional
-	// and named elements.
+	/* control flow > for */
+
+	// _InvalidPostDecl occurs when there is a declaration in a for-loop post
+	// statement.
 	//
 	// Example:
-	//  var _ = struct{i, j int}{i: 1, 2}
-	_MixedStructLit
+	//  func f() {
+	//  	for i := 0; i < 10; j := 0 {}
+	//  }
+	_InvalidPostDecl
 
-	// _InvalidLitField occurs when a field name is not a valid identifier.
+	// _InvalidChanRange occurs when a send-only channel used in a range
+	// expression.
 	//
 	// Example:
-	//  var _ = struct{i int}{1: 1}
-	_InvalidLitField
+	//  func sum(c chan<- int) {
+	//  	s := 0
+	//  	for i := range c {
+	//  		s += i
+	//  	}
+	//  }
+	_InvalidChanRange
 
-	// _MissingLitField occurs when a struct literal refers to a field that does
-	// not exist on the struct type.
+	// _InvalidIterVar occurs when two iteration variables are used while ranging
+	// over a channel.
 	//
 	// Example:
-	//  var _ = struct{i int}{j: 2}
-	_MissingLitField
+	//  func f(c chan int) {
+	//  	for k, v := range c {
+	//  		println(k, v)
+	//  	}
+	//  }
+	_InvalidIterVar
 
-	// _DuplicateLitField occurs when a struct literal contains duplicated
-	// fields.
+	// _InvalidRangeExpr occurs when the type of a range expression is not array,
+	// slice, string, map, or channel.
 	//
 	// Example:
-	//  var _ = struct{i int}{i: 1, i: 2}
-	_DuplicateLitField
-
-	// _UnexportedLitField occurs when a positional struct literal implicitly
-	// assigns an unexported field of an imported type.
-	_UnexportedLitField
+	//  func f(i int) {
+	//  	for j := range i {
+	//  		println(j)
+	//  	}
+	//  }
+	_InvalidRangeExpr
 
-	/* control flow */
+	/* control flow > switch */
 
 	// _MisplacedBreak occurs when a break statement is not within a for, switch,
 	// or select statement of the innermost function definition.
@@ -1228,134 +1195,159 @@ const (
 	//  var _ = t.(type)
 	_BadTypeKeyword
 
-	// _InvalidCond occurs when an if condition is not a boolean expression.
+	// _InvalidTypeSwitch occurs when .(type) is used on an expression that is
+	// not of interface type.
 	//
 	// Example:
-	//  func checkReturn(i int) {
-	//  	if i {
-	//  		panic("non-zero return")
-	//  	}
+	//  func f(i int) {
+	//  	switch x := i.(type) {}
 	//  }
-	_InvalidCond
+	_InvalidTypeSwitch
 
-	// _InvalidChanRange occurs when a send-only channel used in a range
-	// expression.
+	/* control flow > select */
+
+	// _InvalidSelectCase occurs when a select case is not a channel send or
+	// receive.
 	//
 	// Example:
-	//  func sum(c chan<- int) {
-	//  	s := 0
-	//  	for i := range c {
-	//  		s += i
+	//  func checkChan(c <-chan int) bool {
+	//  	select {
+	//  	case c:
+	//  		return true
+	//  	default:
+	//  		return false
 	//  	}
 	//  }
-	_InvalidChanRange
+	_InvalidSelectCase
 
-	// _InvalidIterVar occurs when two iteration variables are used while ranging
-	// over a channel.
+	/* control flow > labels and jumps */
+
+	// _UndeclaredLabel occurs when an undeclared label is jumped to.
 	//
 	// Example:
-	//  func f(c chan int) {
-	//  	for k, v := range c {
-	//  		println(k, v)
-	//  	}
+	//  func f() {
+	//  	goto L
 	//  }
-	_InvalidIterVar
+	_UndeclaredLabel
 
-	// _InvalidRangeExpr occurs when the type of a range expression is not array,
-	// slice, string, map, or channel.
+	// _DuplicateLabel occurs when a label is declared more than once.
 	//
 	// Example:
-	//  func f(i int) {
-	//  	for j := range i {
-	//  		println(j)
-	//  	}
+	//  func f() int {
+	//  L:
+	//  L:
+	//  	return 1
 	//  }
-	_InvalidRangeExpr
+	_DuplicateLabel
 
-	// _InvalidSelectCase occurs when a select case is not a channel send or
-	// receive.
+	// _MisplacedLabel occurs when a break or continue label is not on a for,
+	// switch, or select statement.
 	//
 	// Example:
-	//  func checkChan(c <-chan int) bool {
-	//  	select {
-	//  	case c:
-	//  		return true
-	//  	default:
-	//  		return false
+	//  func f() {
+	//  L:
+	//  	a := []int{1,2,3}
+	//  	for _, e := range a {
+	//  		if e > 10 {
+	//  			break L
+	//  		}
+	//  		println(a)
 	//  	}
 	//  }
-	_InvalidSelectCase
+	_MisplacedLabel
 
-	// _InvalidTypeSwitch occurs when .(type) is used on an expression that is
-	// not of interface type.
+	// _UnusedLabel occurs when a label is declared but not used.
 	//
 	// Example:
-	//  func f(i int) {
-	//  	switch x := i.(type) {}
+	//  func f() {
+	//  L:
 	//  }
-	_InvalidTypeSwitch
+	_UnusedLabel
 
-	// _InvalidLit occurs when a composite literal expression does not match its
-	// type.
+	// _JumpOverDecl occurs when a label jumps over a variable declaration.
 	//
 	// Example:
-	//  type P *struct{
-	//  	x int
+	//  func f() int {
+	//  	goto L
+	//  	x := 2
+	//  L:
+	//  	x++
+	//  	return x
 	//  }
-	//  var _ = P {}
-	_InvalidLit
+	_JumpOverDecl
+
+	// _JumpIntoBlock occurs when a forward jump goes to a label inside a nested
+	// block.
+	//
+	// Example:
+	//  func f(x int) {
+	//  	goto L
+	//  	if x > 0 {
+	//  	L:
+	//  		print("inside block")
+	//  	}
+	// }
+	_JumpIntoBlock
 
-	/* miscellaneous codes */
+	/* control flow > calls */
 
-	// _NotAnExpr occurs when a type expression is used where a value expression
-	// is expected.
+	// _InvalidMethodExpr occurs when a pointer method is called but the argument
+	// is not addressable.
 	//
 	// Example:
 	//  type T struct {}
 	//
-	//  func f() {
-	//  	T
-	//  }
-	_NotAnExpr
+	//  func (*T) m() int { return 1 }
+	//
+	//  var _ = T.m(T{})
+	_InvalidMethodExpr
 
-	// _UnusedExpr occurs when a side-effect free expression is used as a
-	// statement. Such a statement has no effect.
+	// _WrongArgCount occurs when too few or too many arguments are passed by a
+	// function call.
 	//
 	// Example:
-	//  func f(i int) {
-	//  	i*i
-	//  }
-	_UnusedExpr
+	//  func f(i int) {}
+	//  var x = f()
+	_WrongArgCount
 
-	// _UndeclaredName occurs when an identifier is not declared in the current
-	// scope.
+	// _InvalidCall occurs when an expression is called that is not of function
+	// type.
 	//
 	// Example:
-	//  var x T
-	_UndeclaredName
+	//  var x = "x"
+	//  var y = x()
+	_InvalidCall
 
-	// _InvalidBlank occurs when a blank identifier is used as a value or type.
-	//
-	// Per the spec:
-	//  "The blank identifier may appear as an operand only on the left-hand side
-	//  of an assignment."
+	/* control flow > suspended */
+
+	// _UnusedResults occurs when a restricted expression-only built-in function
+	// is suspended via go or defer. Such a suspension discards the results of
+	// these side-effect free built-in functions, and therefore is ineffectual.
 	//
 	// Example:
-	//  var x = _
-	_InvalidBlank
+	//  func f(a []int) int {
+	//  	defer len(a)
+	//  	return i
+	//  }
+	_UnusedResults
 
-	// _InvalidIota occurs when the predeclared identifier iota is used outside
-	// of a constant declaration.
+	// _InvalidDefer occurs when a deferred expression is not a function call,
+	// for example if the expression is a type conversion.
 	//
 	// Example:
-	//  var x = iota
-	_InvalidIota
+	//  func f(i int) int {
+	//  	defer int32(i)
+	//  	return i
+	//  }
+	_InvalidDefer
 
-	// _InvalidUntypedConversion occurs when an there is no valid implicit
-	// conversion from an untyped value satisfying the type constraints of the
-	// context in which it is used.
+	// _InvalidGo occurs when a go expression is not a function call, for example
+	// if the expression is a type conversion.
 	//
 	// Example:
-	//  var _ = 1 + ""
-	_InvalidUntypedConversion
+	//  func f(i int) int {
+	//  	go int32(i)
+	//  	return i
+	//  }
+	_InvalidGo
 )
