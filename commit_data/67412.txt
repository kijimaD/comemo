commit 61c1183342897ed5544c0d37ad58d9038d50e3ea
Author: Junyang Shao <shaojunyang@google.com>
Date:   Fri Jun 20 18:57:51 2025 +0000

    [dev.simd] simd: add test wrappers
    
    This CL adds test wrappers for unit tests, and change the existing
    Add/Sub test to be using wrappers.
    
    This CL is generated by CL 683455.
    
    Change-Id: Ibd388d82632ce56aad7a1ab5fff62db232819bb5
    Reviewed-on: https://go-review.googlesource.com/c/go/+/683015
    Auto-Submit: Junyang Shao <shaojunyang@google.com>
    Reviewed-by: David Chase <drchase@google.com>
    LUCI-TryBot-Result: Go LUCI <golang-scoped@luci-project-accounts.iam.gserviceaccount.com>
---
 src/simd/simd_test.go         |   76 +-
 src/simd/simd_wrapped_test.go | 6739 +++++++++++++++++++++++++++++++++++++++++
 src/simd/stubs_amd64.go       |   16 +-
 3 files changed, 6755 insertions(+), 76 deletions(-)

diff --git a/src/simd/simd_test.go b/src/simd/simd_test.go
index 8658631e45..6df634b428 100644
--- a/src/simd/simd_test.go
+++ b/src/simd/simd_test.go
@@ -96,22 +96,6 @@ func TestReflectMethod(t *testing.T) {
 	}
 }
 
-func TestAdd(t *testing.T) {
-	xv := [4]int32{1, 2, 3, 4}
-	yv := [4]int32{5, 6, 7, 8}
-	want := []int32{6, 8, 10, 12}
-	x := simd.LoadInt32x4(&xv)
-	y := simd.LoadInt32x4(&yv)
-	x = x.Add(y)
-	got := [4]int32{}
-	x.Store(&got)
-	for i := range 4 {
-		if want[i] != got[i] {
-			t.Errorf("Result at %d incorrect: want %d, got %d", i, want[i], got[i])
-		}
-	}
-}
-
 func TestVectorConversion(t *testing.T) {
 	if !simd.HasAVX512() {
 		t.Skip("Test requires HasAVX512, not available on this hardware")
@@ -151,64 +135,20 @@ func TestMaskConversion(t *testing.T) {
 	}
 }
 
-func TestMaskedAdd(t *testing.T) {
-	if !simd.HasAVX512() {
-		t.Skip("Test requires HasAVX512, not available on this hardware")
-		return
-	}
-	xv := [4]int32{1, 2, 3, 4}
-	yv := [4]int32{5, 6, 7, 8}
-	// masking elements 1 and 2.
-	maskv := [4]int32{-1, -1, 0, 0}
-	want := []int32{6, 8, 0, 0}
-	x := simd.LoadInt32x4(&xv)
-	y := simd.LoadInt32x4(&yv)
-	mask := simd.LoadInt32x4(&maskv).AsMask32x4()
-	x = x.MaskedAdd(y, mask)
-	got := [4]int32{}
-	x.Store(&got)
-	for i := range 4 {
-		if want[i] != got[i] {
-			t.Errorf("Result at %d incorrect: want %d, got %d", i, want[i], got[i])
-		}
-	}
+func TestAdd(t *testing.T) {
+	testInt32x4Binary(t, []int32{1, 2, 3, 4}, []int32{5, 6, 7, 8}, []int32{6, 8, 10, 12}, "Add")
 }
 
-func TestCompare(t *testing.T) {
-	xv := [4]int32{5, 1, 5, 3}
-	yv := [4]int32{3, 3, 3, 3}
-	want := []int32{8, 0, 8, 0}
-	x := simd.LoadInt32x4(&xv)
-	y := simd.LoadInt32x4(&yv)
+func TestSub(t *testing.T) {
+	testInt32x4Binary(t, []int32{5, 5, 5, 3}, []int32{3, 3, 3, 3}, []int32{2, 2, 2, 0}, "Sub")
+}
+
+func TestMaskedAdd(t *testing.T) {
 	if !simd.HasAVX512() {
 		t.Skip("Test requires HasAVX512, not available on this hardware")
 		return
 	}
-	mask := x.Greater(y)
-	x = x.MaskedAdd(y, mask)
-	got := [4]int32{}
-	x.Store(&got)
-	for i := range 4 {
-		if want[i] != got[i] {
-			t.Errorf("Result at %d incorrect: want %d, got %d", i, want[i], got[i])
-		}
-	}
-}
-
-func TestSub(t *testing.T) {
-	xv := [4]int32{5, 5, 5, 3}
-	yv := [4]int32{3, 3, 3, 3}
-	want := []int32{2, 2, 2, 0}
-	x := simd.LoadInt32x4(&xv)
-	y := simd.LoadInt32x4(&yv)
-	x = x.Sub(y)
-	got := [4]int32{}
-	x.Store(&got)
-	for i := range 4 {
-		if want[i] != got[i] {
-			t.Errorf("Result at %d incorrect: want %d, got %d", i, want[i], got[i])
-		}
-	}
+	testInt32x4BinaryMasked(t, []int32{1, 2, 3, 4}, []int32{5, 6, 7, 8}, []int32{-1, -1, 0, 0}, []int32{6, 8, 0, 0}, "MaskedAdd")
 }
 
 // checkInt8Slices ensures that b and a are equal, to the end of b.
diff --git a/src/simd/simd_wrapped_test.go b/src/simd/simd_wrapped_test.go
new file mode 100644
index 0000000000..8761097c44
--- /dev/null
+++ b/src/simd/simd_wrapped_test.go
@@ -0,0 +1,6739 @@
+// Code generated by x/arch/internal/simdgen using 'go run . -xedPath $XED_PATH -o godefs -goroot $GOROOT go.yaml types.yaml categories.yaml'; DO NOT EDIT.
+
+//go:build goexperiment.simd
+
+package simd_test
+
+import (
+	"simd"
+	"testing"
+)
+
+func testFloat32x16Binary(t *testing.T, v0 []float32, v1 []float32, want []float32, which string) {
+	t.Helper()
+	var gotv simd.Float32x16
+	got := make([]float32, len(want))
+	vec0 := simd.LoadFloat32x16Slice(v0)
+	vec1 := simd.LoadFloat32x16Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Div":
+		gotv = vec0.Div(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "Mul":
+		gotv = vec0.Mul(vec1)
+	case "MulByPowOf2":
+		gotv = vec0.MulByPowOf2(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Float32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x16BinaryMasked(t *testing.T, v0 []float32, v1 []float32, v2 []int32, want []float32, which string) {
+	t.Helper()
+	var gotv simd.Float32x16
+	got := make([]float32, len(want))
+	vec0 := simd.LoadFloat32x16Slice(v0)
+	vec1 := simd.LoadFloat32x16Slice(v1)
+	vec2 := simd.LoadInt32x16Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask32x16())
+	case "MaskedAnd":
+		gotv = vec0.MaskedAnd(vec1, vec2.AsMask32x16())
+	case "MaskedAndNot":
+		gotv = vec0.MaskedAndNot(vec1, vec2.AsMask32x16())
+	case "MaskedDiv":
+		gotv = vec0.MaskedDiv(vec1, vec2.AsMask32x16())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask32x16())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask32x16())
+	case "MaskedMul":
+		gotv = vec0.MaskedMul(vec1, vec2.AsMask32x16())
+	case "MaskedMulByPowOf2":
+		gotv = vec0.MaskedMulByPowOf2(vec1, vec2.AsMask32x16())
+	case "MaskedOr":
+		gotv = vec0.MaskedOr(vec1, vec2.AsMask32x16())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask32x16())
+	case "MaskedXor":
+		gotv = vec0.MaskedXor(vec1, vec2.AsMask32x16())
+
+	default:
+		t.Errorf("Unknown method: Float32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x16Compare(t *testing.T, v0 []float32, v1 []float32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x16
+	got := make([]int32, len(want))
+	vec0 := simd.LoadFloat32x16Slice(v0)
+	vec1 := simd.LoadFloat32x16Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt32x16()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt32x16()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt32x16()
+	case "IsNan":
+		gotv = vec0.IsNan(vec1).AsInt32x16()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt32x16()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt32x16()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt32x16()
+
+	default:
+		t.Errorf("Unknown method: Float32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x16MaskedCompare(t *testing.T, v0 []float32, v1 []float32, v2 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x16
+	got := make([]int32, len(want))
+	vec0 := simd.LoadFloat32x16Slice(v0)
+	vec1 := simd.LoadFloat32x16Slice(v1)
+	vec2 := simd.LoadInt32x16Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask32x16()).AsInt32x16()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask32x16()).AsInt32x16()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask32x16()).AsInt32x16()
+	case "MaskedIsNan":
+		gotv = vec0.MaskedIsNan(vec1, vec2.AsMask32x16()).AsInt32x16()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask32x16()).AsInt32x16()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask32x16()).AsInt32x16()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask32x16()).AsInt32x16()
+
+	default:
+		t.Errorf("Unknown method: Float32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x16Ternary(t *testing.T, v0 []float32, v1 []float32, v2 []float32, want []float32, which string) {
+	t.Helper()
+	var gotv simd.Float32x16
+	got := make([]float32, len(want))
+	vec0 := simd.LoadFloat32x16Slice(v0)
+	vec1 := simd.LoadFloat32x16Slice(v1)
+	vec2 := simd.LoadFloat32x16Slice(v2)
+	switch which {
+	case "FusedMultiplyAdd":
+		gotv = vec0.FusedMultiplyAdd(vec1, vec2)
+	case "FusedMultiplyAddSub":
+		gotv = vec0.FusedMultiplyAddSub(vec1, vec2)
+	case "FusedMultiplySubAdd":
+		gotv = vec0.FusedMultiplySubAdd(vec1, vec2)
+
+	default:
+		t.Errorf("Unknown method: Float32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x16TernaryMasked(t *testing.T, v0 []float32, v1 []float32, v2 []float32, v3 []int32, want []float32, which string) {
+	t.Helper()
+	var gotv simd.Float32x16
+	got := make([]float32, len(want))
+	vec0 := simd.LoadFloat32x16Slice(v0)
+	vec1 := simd.LoadFloat32x16Slice(v1)
+	vec2 := simd.LoadFloat32x16Slice(v2)
+	vec3 := simd.LoadInt32x16Slice(v3)
+	switch which {
+	case "MaskedFusedMultiplyAdd":
+		gotv = vec0.MaskedFusedMultiplyAdd(vec1, vec2, vec3.AsMask32x16())
+	case "MaskedFusedMultiplyAddSub":
+		gotv = vec0.MaskedFusedMultiplyAddSub(vec1, vec2, vec3.AsMask32x16())
+	case "MaskedFusedMultiplySubAdd":
+		gotv = vec0.MaskedFusedMultiplySubAdd(vec1, vec2, vec3.AsMask32x16())
+
+	default:
+		t.Errorf("Unknown method: Float32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x16Unary(t *testing.T, v0 []float32, want []float32, which string) {
+	t.Helper()
+	var gotv simd.Float32x16
+	got := make([]float32, len(want))
+	vec0 := simd.LoadFloat32x16Slice(v0)
+	switch which {
+	case "ApproximateReciprocal":
+		gotv = vec0.ApproximateReciprocal()
+	case "ApproximateReciprocalOfSqrt":
+		gotv = vec0.ApproximateReciprocalOfSqrt()
+	case "Sqrt":
+		gotv = vec0.Sqrt()
+
+	default:
+		t.Errorf("Unknown method: Float32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x16UnaryMasked(t *testing.T, v0 []float32, v1 []int32, want []float32, which string) {
+	t.Helper()
+	var gotv simd.Float32x16
+	got := make([]float32, len(want))
+	vec0 := simd.LoadFloat32x16Slice(v0)
+	vec1 := simd.LoadInt32x16Slice(v1)
+	switch which {
+	case "MaskedApproximateReciprocal":
+		gotv = vec0.MaskedApproximateReciprocal(vec1.AsMask32x16())
+	case "MaskedApproximateReciprocalOfSqrt":
+		gotv = vec0.MaskedApproximateReciprocalOfSqrt(vec1.AsMask32x16())
+	case "MaskedSqrt":
+		gotv = vec0.MaskedSqrt(vec1.AsMask32x16())
+
+	default:
+		t.Errorf("Unknown method: Float32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x4Binary(t *testing.T, v0 []float32, v1 []float32, want []float32, which string) {
+	t.Helper()
+	var gotv simd.Float32x4
+	got := make([]float32, len(want))
+	vec0 := simd.LoadFloat32x4Slice(v0)
+	vec1 := simd.LoadFloat32x4Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "AddSub":
+		gotv = vec0.AddSub(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Div":
+		gotv = vec0.Div(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "Mul":
+		gotv = vec0.Mul(vec1)
+	case "MulByPowOf2":
+		gotv = vec0.MulByPowOf2(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "PairwiseAdd":
+		gotv = vec0.PairwiseAdd(vec1)
+	case "PairwiseSub":
+		gotv = vec0.PairwiseSub(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Float32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x4BinaryMasked(t *testing.T, v0 []float32, v1 []float32, v2 []int32, want []float32, which string) {
+	t.Helper()
+	var gotv simd.Float32x4
+	got := make([]float32, len(want))
+	vec0 := simd.LoadFloat32x4Slice(v0)
+	vec1 := simd.LoadFloat32x4Slice(v1)
+	vec2 := simd.LoadInt32x4Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask32x4())
+	case "MaskedAnd":
+		gotv = vec0.MaskedAnd(vec1, vec2.AsMask32x4())
+	case "MaskedAndNot":
+		gotv = vec0.MaskedAndNot(vec1, vec2.AsMask32x4())
+	case "MaskedDiv":
+		gotv = vec0.MaskedDiv(vec1, vec2.AsMask32x4())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask32x4())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask32x4())
+	case "MaskedMul":
+		gotv = vec0.MaskedMul(vec1, vec2.AsMask32x4())
+	case "MaskedMulByPowOf2":
+		gotv = vec0.MaskedMulByPowOf2(vec1, vec2.AsMask32x4())
+	case "MaskedOr":
+		gotv = vec0.MaskedOr(vec1, vec2.AsMask32x4())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask32x4())
+	case "MaskedXor":
+		gotv = vec0.MaskedXor(vec1, vec2.AsMask32x4())
+
+	default:
+		t.Errorf("Unknown method: Float32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x4Compare(t *testing.T, v0 []float32, v1 []float32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x4
+	got := make([]int32, len(want))
+	vec0 := simd.LoadFloat32x4Slice(v0)
+	vec1 := simd.LoadFloat32x4Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt32x4()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt32x4()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt32x4()
+	case "IsNan":
+		gotv = vec0.IsNan(vec1).AsInt32x4()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt32x4()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt32x4()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt32x4()
+
+	default:
+		t.Errorf("Unknown method: Float32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x4MaskedCompare(t *testing.T, v0 []float32, v1 []float32, v2 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x4
+	got := make([]int32, len(want))
+	vec0 := simd.LoadFloat32x4Slice(v0)
+	vec1 := simd.LoadFloat32x4Slice(v1)
+	vec2 := simd.LoadInt32x4Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask32x4()).AsInt32x4()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask32x4()).AsInt32x4()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask32x4()).AsInt32x4()
+	case "MaskedIsNan":
+		gotv = vec0.MaskedIsNan(vec1, vec2.AsMask32x4()).AsInt32x4()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask32x4()).AsInt32x4()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask32x4()).AsInt32x4()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask32x4()).AsInt32x4()
+
+	default:
+		t.Errorf("Unknown method: Float32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x4Ternary(t *testing.T, v0 []float32, v1 []float32, v2 []float32, want []float32, which string) {
+	t.Helper()
+	var gotv simd.Float32x4
+	got := make([]float32, len(want))
+	vec0 := simd.LoadFloat32x4Slice(v0)
+	vec1 := simd.LoadFloat32x4Slice(v1)
+	vec2 := simd.LoadFloat32x4Slice(v2)
+	switch which {
+	case "FusedMultiplyAdd":
+		gotv = vec0.FusedMultiplyAdd(vec1, vec2)
+	case "FusedMultiplyAddSub":
+		gotv = vec0.FusedMultiplyAddSub(vec1, vec2)
+	case "FusedMultiplySubAdd":
+		gotv = vec0.FusedMultiplySubAdd(vec1, vec2)
+
+	default:
+		t.Errorf("Unknown method: Float32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x4TernaryMasked(t *testing.T, v0 []float32, v1 []float32, v2 []float32, v3 []int32, want []float32, which string) {
+	t.Helper()
+	var gotv simd.Float32x4
+	got := make([]float32, len(want))
+	vec0 := simd.LoadFloat32x4Slice(v0)
+	vec1 := simd.LoadFloat32x4Slice(v1)
+	vec2 := simd.LoadFloat32x4Slice(v2)
+	vec3 := simd.LoadInt32x4Slice(v3)
+	switch which {
+	case "MaskedFusedMultiplyAdd":
+		gotv = vec0.MaskedFusedMultiplyAdd(vec1, vec2, vec3.AsMask32x4())
+	case "MaskedFusedMultiplyAddSub":
+		gotv = vec0.MaskedFusedMultiplyAddSub(vec1, vec2, vec3.AsMask32x4())
+	case "MaskedFusedMultiplySubAdd":
+		gotv = vec0.MaskedFusedMultiplySubAdd(vec1, vec2, vec3.AsMask32x4())
+
+	default:
+		t.Errorf("Unknown method: Float32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x4Unary(t *testing.T, v0 []float32, want []float32, which string) {
+	t.Helper()
+	var gotv simd.Float32x4
+	got := make([]float32, len(want))
+	vec0 := simd.LoadFloat32x4Slice(v0)
+	switch which {
+	case "ApproximateReciprocal":
+		gotv = vec0.ApproximateReciprocal()
+	case "ApproximateReciprocalOfSqrt":
+		gotv = vec0.ApproximateReciprocalOfSqrt()
+	case "Ceil":
+		gotv = vec0.Ceil()
+	case "Floor":
+		gotv = vec0.Floor()
+	case "Round":
+		gotv = vec0.Round()
+	case "Sqrt":
+		gotv = vec0.Sqrt()
+	case "Trunc":
+		gotv = vec0.Trunc()
+
+	default:
+		t.Errorf("Unknown method: Float32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x4UnaryMasked(t *testing.T, v0 []float32, v1 []int32, want []float32, which string) {
+	t.Helper()
+	var gotv simd.Float32x4
+	got := make([]float32, len(want))
+	vec0 := simd.LoadFloat32x4Slice(v0)
+	vec1 := simd.LoadInt32x4Slice(v1)
+	switch which {
+	case "MaskedApproximateReciprocal":
+		gotv = vec0.MaskedApproximateReciprocal(vec1.AsMask32x4())
+	case "MaskedApproximateReciprocalOfSqrt":
+		gotv = vec0.MaskedApproximateReciprocalOfSqrt(vec1.AsMask32x4())
+	case "MaskedSqrt":
+		gotv = vec0.MaskedSqrt(vec1.AsMask32x4())
+
+	default:
+		t.Errorf("Unknown method: Float32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x8Binary(t *testing.T, v0 []float32, v1 []float32, want []float32, which string) {
+	t.Helper()
+	var gotv simd.Float32x8
+	got := make([]float32, len(want))
+	vec0 := simd.LoadFloat32x8Slice(v0)
+	vec1 := simd.LoadFloat32x8Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "AddSub":
+		gotv = vec0.AddSub(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Div":
+		gotv = vec0.Div(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "Mul":
+		gotv = vec0.Mul(vec1)
+	case "MulByPowOf2":
+		gotv = vec0.MulByPowOf2(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "PairwiseAdd":
+		gotv = vec0.PairwiseAdd(vec1)
+	case "PairwiseSub":
+		gotv = vec0.PairwiseSub(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Float32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x8BinaryMasked(t *testing.T, v0 []float32, v1 []float32, v2 []int32, want []float32, which string) {
+	t.Helper()
+	var gotv simd.Float32x8
+	got := make([]float32, len(want))
+	vec0 := simd.LoadFloat32x8Slice(v0)
+	vec1 := simd.LoadFloat32x8Slice(v1)
+	vec2 := simd.LoadInt32x8Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask32x8())
+	case "MaskedAnd":
+		gotv = vec0.MaskedAnd(vec1, vec2.AsMask32x8())
+	case "MaskedAndNot":
+		gotv = vec0.MaskedAndNot(vec1, vec2.AsMask32x8())
+	case "MaskedDiv":
+		gotv = vec0.MaskedDiv(vec1, vec2.AsMask32x8())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask32x8())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask32x8())
+	case "MaskedMul":
+		gotv = vec0.MaskedMul(vec1, vec2.AsMask32x8())
+	case "MaskedMulByPowOf2":
+		gotv = vec0.MaskedMulByPowOf2(vec1, vec2.AsMask32x8())
+	case "MaskedOr":
+		gotv = vec0.MaskedOr(vec1, vec2.AsMask32x8())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask32x8())
+	case "MaskedXor":
+		gotv = vec0.MaskedXor(vec1, vec2.AsMask32x8())
+
+	default:
+		t.Errorf("Unknown method: Float32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x8Compare(t *testing.T, v0 []float32, v1 []float32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x8
+	got := make([]int32, len(want))
+	vec0 := simd.LoadFloat32x8Slice(v0)
+	vec1 := simd.LoadFloat32x8Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt32x8()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt32x8()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt32x8()
+	case "IsNan":
+		gotv = vec0.IsNan(vec1).AsInt32x8()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt32x8()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt32x8()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt32x8()
+
+	default:
+		t.Errorf("Unknown method: Float32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x8MaskedCompare(t *testing.T, v0 []float32, v1 []float32, v2 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x8
+	got := make([]int32, len(want))
+	vec0 := simd.LoadFloat32x8Slice(v0)
+	vec1 := simd.LoadFloat32x8Slice(v1)
+	vec2 := simd.LoadInt32x8Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask32x8()).AsInt32x8()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask32x8()).AsInt32x8()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask32x8()).AsInt32x8()
+	case "MaskedIsNan":
+		gotv = vec0.MaskedIsNan(vec1, vec2.AsMask32x8()).AsInt32x8()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask32x8()).AsInt32x8()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask32x8()).AsInt32x8()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask32x8()).AsInt32x8()
+
+	default:
+		t.Errorf("Unknown method: Float32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x8Ternary(t *testing.T, v0 []float32, v1 []float32, v2 []float32, want []float32, which string) {
+	t.Helper()
+	var gotv simd.Float32x8
+	got := make([]float32, len(want))
+	vec0 := simd.LoadFloat32x8Slice(v0)
+	vec1 := simd.LoadFloat32x8Slice(v1)
+	vec2 := simd.LoadFloat32x8Slice(v2)
+	switch which {
+	case "FusedMultiplyAdd":
+		gotv = vec0.FusedMultiplyAdd(vec1, vec2)
+	case "FusedMultiplyAddSub":
+		gotv = vec0.FusedMultiplyAddSub(vec1, vec2)
+	case "FusedMultiplySubAdd":
+		gotv = vec0.FusedMultiplySubAdd(vec1, vec2)
+
+	default:
+		t.Errorf("Unknown method: Float32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x8TernaryMasked(t *testing.T, v0 []float32, v1 []float32, v2 []float32, v3 []int32, want []float32, which string) {
+	t.Helper()
+	var gotv simd.Float32x8
+	got := make([]float32, len(want))
+	vec0 := simd.LoadFloat32x8Slice(v0)
+	vec1 := simd.LoadFloat32x8Slice(v1)
+	vec2 := simd.LoadFloat32x8Slice(v2)
+	vec3 := simd.LoadInt32x8Slice(v3)
+	switch which {
+	case "MaskedFusedMultiplyAdd":
+		gotv = vec0.MaskedFusedMultiplyAdd(vec1, vec2, vec3.AsMask32x8())
+	case "MaskedFusedMultiplyAddSub":
+		gotv = vec0.MaskedFusedMultiplyAddSub(vec1, vec2, vec3.AsMask32x8())
+	case "MaskedFusedMultiplySubAdd":
+		gotv = vec0.MaskedFusedMultiplySubAdd(vec1, vec2, vec3.AsMask32x8())
+
+	default:
+		t.Errorf("Unknown method: Float32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x8Unary(t *testing.T, v0 []float32, want []float32, which string) {
+	t.Helper()
+	var gotv simd.Float32x8
+	got := make([]float32, len(want))
+	vec0 := simd.LoadFloat32x8Slice(v0)
+	switch which {
+	case "ApproximateReciprocal":
+		gotv = vec0.ApproximateReciprocal()
+	case "ApproximateReciprocalOfSqrt":
+		gotv = vec0.ApproximateReciprocalOfSqrt()
+	case "Ceil":
+		gotv = vec0.Ceil()
+	case "Floor":
+		gotv = vec0.Floor()
+	case "Round":
+		gotv = vec0.Round()
+	case "Sqrt":
+		gotv = vec0.Sqrt()
+	case "Trunc":
+		gotv = vec0.Trunc()
+
+	default:
+		t.Errorf("Unknown method: Float32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat32x8UnaryMasked(t *testing.T, v0 []float32, v1 []int32, want []float32, which string) {
+	t.Helper()
+	var gotv simd.Float32x8
+	got := make([]float32, len(want))
+	vec0 := simd.LoadFloat32x8Slice(v0)
+	vec1 := simd.LoadInt32x8Slice(v1)
+	switch which {
+	case "MaskedApproximateReciprocal":
+		gotv = vec0.MaskedApproximateReciprocal(vec1.AsMask32x8())
+	case "MaskedApproximateReciprocalOfSqrt":
+		gotv = vec0.MaskedApproximateReciprocalOfSqrt(vec1.AsMask32x8())
+	case "MaskedSqrt":
+		gotv = vec0.MaskedSqrt(vec1.AsMask32x8())
+
+	default:
+		t.Errorf("Unknown method: Float32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x2Binary(t *testing.T, v0 []float64, v1 []float64, want []float64, which string) {
+	t.Helper()
+	var gotv simd.Float64x2
+	got := make([]float64, len(want))
+	vec0 := simd.LoadFloat64x2Slice(v0)
+	vec1 := simd.LoadFloat64x2Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "AddSub":
+		gotv = vec0.AddSub(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Div":
+		gotv = vec0.Div(vec1)
+	case "DotProdBroadcast":
+		gotv = vec0.DotProdBroadcast(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "Mul":
+		gotv = vec0.Mul(vec1)
+	case "MulByPowOf2":
+		gotv = vec0.MulByPowOf2(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "PairwiseAdd":
+		gotv = vec0.PairwiseAdd(vec1)
+	case "PairwiseSub":
+		gotv = vec0.PairwiseSub(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Float64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x2BinaryMasked(t *testing.T, v0 []float64, v1 []float64, v2 []int64, want []float64, which string) {
+	t.Helper()
+	var gotv simd.Float64x2
+	got := make([]float64, len(want))
+	vec0 := simd.LoadFloat64x2Slice(v0)
+	vec1 := simd.LoadFloat64x2Slice(v1)
+	vec2 := simd.LoadInt64x2Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask64x2())
+	case "MaskedAnd":
+		gotv = vec0.MaskedAnd(vec1, vec2.AsMask64x2())
+	case "MaskedAndNot":
+		gotv = vec0.MaskedAndNot(vec1, vec2.AsMask64x2())
+	case "MaskedDiv":
+		gotv = vec0.MaskedDiv(vec1, vec2.AsMask64x2())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask64x2())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask64x2())
+	case "MaskedMul":
+		gotv = vec0.MaskedMul(vec1, vec2.AsMask64x2())
+	case "MaskedMulByPowOf2":
+		gotv = vec0.MaskedMulByPowOf2(vec1, vec2.AsMask64x2())
+	case "MaskedOr":
+		gotv = vec0.MaskedOr(vec1, vec2.AsMask64x2())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask64x2())
+	case "MaskedXor":
+		gotv = vec0.MaskedXor(vec1, vec2.AsMask64x2())
+
+	default:
+		t.Errorf("Unknown method: Float64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x2Compare(t *testing.T, v0 []float64, v1 []float64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x2
+	got := make([]int64, len(want))
+	vec0 := simd.LoadFloat64x2Slice(v0)
+	vec1 := simd.LoadFloat64x2Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt64x2()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt64x2()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt64x2()
+	case "IsNan":
+		gotv = vec0.IsNan(vec1).AsInt64x2()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt64x2()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt64x2()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt64x2()
+
+	default:
+		t.Errorf("Unknown method: Float64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x2MaskedCompare(t *testing.T, v0 []float64, v1 []float64, v2 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x2
+	got := make([]int64, len(want))
+	vec0 := simd.LoadFloat64x2Slice(v0)
+	vec1 := simd.LoadFloat64x2Slice(v1)
+	vec2 := simd.LoadInt64x2Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask64x2()).AsInt64x2()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask64x2()).AsInt64x2()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask64x2()).AsInt64x2()
+	case "MaskedIsNan":
+		gotv = vec0.MaskedIsNan(vec1, vec2.AsMask64x2()).AsInt64x2()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask64x2()).AsInt64x2()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask64x2()).AsInt64x2()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask64x2()).AsInt64x2()
+
+	default:
+		t.Errorf("Unknown method: Float64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x2Ternary(t *testing.T, v0 []float64, v1 []float64, v2 []float64, want []float64, which string) {
+	t.Helper()
+	var gotv simd.Float64x2
+	got := make([]float64, len(want))
+	vec0 := simd.LoadFloat64x2Slice(v0)
+	vec1 := simd.LoadFloat64x2Slice(v1)
+	vec2 := simd.LoadFloat64x2Slice(v2)
+	switch which {
+	case "FusedMultiplyAdd":
+		gotv = vec0.FusedMultiplyAdd(vec1, vec2)
+	case "FusedMultiplyAddSub":
+		gotv = vec0.FusedMultiplyAddSub(vec1, vec2)
+	case "FusedMultiplySubAdd":
+		gotv = vec0.FusedMultiplySubAdd(vec1, vec2)
+
+	default:
+		t.Errorf("Unknown method: Float64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x2TernaryMasked(t *testing.T, v0 []float64, v1 []float64, v2 []float64, v3 []int64, want []float64, which string) {
+	t.Helper()
+	var gotv simd.Float64x2
+	got := make([]float64, len(want))
+	vec0 := simd.LoadFloat64x2Slice(v0)
+	vec1 := simd.LoadFloat64x2Slice(v1)
+	vec2 := simd.LoadFloat64x2Slice(v2)
+	vec3 := simd.LoadInt64x2Slice(v3)
+	switch which {
+	case "MaskedFusedMultiplyAdd":
+		gotv = vec0.MaskedFusedMultiplyAdd(vec1, vec2, vec3.AsMask64x2())
+	case "MaskedFusedMultiplyAddSub":
+		gotv = vec0.MaskedFusedMultiplyAddSub(vec1, vec2, vec3.AsMask64x2())
+	case "MaskedFusedMultiplySubAdd":
+		gotv = vec0.MaskedFusedMultiplySubAdd(vec1, vec2, vec3.AsMask64x2())
+
+	default:
+		t.Errorf("Unknown method: Float64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x2Unary(t *testing.T, v0 []float64, want []float64, which string) {
+	t.Helper()
+	var gotv simd.Float64x2
+	got := make([]float64, len(want))
+	vec0 := simd.LoadFloat64x2Slice(v0)
+	switch which {
+	case "ApproximateReciprocal":
+		gotv = vec0.ApproximateReciprocal()
+	case "ApproximateReciprocalOfSqrt":
+		gotv = vec0.ApproximateReciprocalOfSqrt()
+	case "Ceil":
+		gotv = vec0.Ceil()
+	case "Floor":
+		gotv = vec0.Floor()
+	case "Round":
+		gotv = vec0.Round()
+	case "Sqrt":
+		gotv = vec0.Sqrt()
+	case "Trunc":
+		gotv = vec0.Trunc()
+
+	default:
+		t.Errorf("Unknown method: Float64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x2UnaryMasked(t *testing.T, v0 []float64, v1 []int64, want []float64, which string) {
+	t.Helper()
+	var gotv simd.Float64x2
+	got := make([]float64, len(want))
+	vec0 := simd.LoadFloat64x2Slice(v0)
+	vec1 := simd.LoadInt64x2Slice(v1)
+	switch which {
+	case "MaskedApproximateReciprocal":
+		gotv = vec0.MaskedApproximateReciprocal(vec1.AsMask64x2())
+	case "MaskedApproximateReciprocalOfSqrt":
+		gotv = vec0.MaskedApproximateReciprocalOfSqrt(vec1.AsMask64x2())
+	case "MaskedSqrt":
+		gotv = vec0.MaskedSqrt(vec1.AsMask64x2())
+
+	default:
+		t.Errorf("Unknown method: Float64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x4Binary(t *testing.T, v0 []float64, v1 []float64, want []float64, which string) {
+	t.Helper()
+	var gotv simd.Float64x4
+	got := make([]float64, len(want))
+	vec0 := simd.LoadFloat64x4Slice(v0)
+	vec1 := simd.LoadFloat64x4Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "AddSub":
+		gotv = vec0.AddSub(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Div":
+		gotv = vec0.Div(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "Mul":
+		gotv = vec0.Mul(vec1)
+	case "MulByPowOf2":
+		gotv = vec0.MulByPowOf2(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "PairwiseAdd":
+		gotv = vec0.PairwiseAdd(vec1)
+	case "PairwiseSub":
+		gotv = vec0.PairwiseSub(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Float64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x4BinaryMasked(t *testing.T, v0 []float64, v1 []float64, v2 []int64, want []float64, which string) {
+	t.Helper()
+	var gotv simd.Float64x4
+	got := make([]float64, len(want))
+	vec0 := simd.LoadFloat64x4Slice(v0)
+	vec1 := simd.LoadFloat64x4Slice(v1)
+	vec2 := simd.LoadInt64x4Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask64x4())
+	case "MaskedAnd":
+		gotv = vec0.MaskedAnd(vec1, vec2.AsMask64x4())
+	case "MaskedAndNot":
+		gotv = vec0.MaskedAndNot(vec1, vec2.AsMask64x4())
+	case "MaskedDiv":
+		gotv = vec0.MaskedDiv(vec1, vec2.AsMask64x4())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask64x4())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask64x4())
+	case "MaskedMul":
+		gotv = vec0.MaskedMul(vec1, vec2.AsMask64x4())
+	case "MaskedMulByPowOf2":
+		gotv = vec0.MaskedMulByPowOf2(vec1, vec2.AsMask64x4())
+	case "MaskedOr":
+		gotv = vec0.MaskedOr(vec1, vec2.AsMask64x4())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask64x4())
+	case "MaskedXor":
+		gotv = vec0.MaskedXor(vec1, vec2.AsMask64x4())
+
+	default:
+		t.Errorf("Unknown method: Float64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x4Compare(t *testing.T, v0 []float64, v1 []float64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x4
+	got := make([]int64, len(want))
+	vec0 := simd.LoadFloat64x4Slice(v0)
+	vec1 := simd.LoadFloat64x4Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt64x4()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt64x4()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt64x4()
+	case "IsNan":
+		gotv = vec0.IsNan(vec1).AsInt64x4()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt64x4()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt64x4()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt64x4()
+
+	default:
+		t.Errorf("Unknown method: Float64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x4MaskedCompare(t *testing.T, v0 []float64, v1 []float64, v2 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x4
+	got := make([]int64, len(want))
+	vec0 := simd.LoadFloat64x4Slice(v0)
+	vec1 := simd.LoadFloat64x4Slice(v1)
+	vec2 := simd.LoadInt64x4Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask64x4()).AsInt64x4()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask64x4()).AsInt64x4()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask64x4()).AsInt64x4()
+	case "MaskedIsNan":
+		gotv = vec0.MaskedIsNan(vec1, vec2.AsMask64x4()).AsInt64x4()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask64x4()).AsInt64x4()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask64x4()).AsInt64x4()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask64x4()).AsInt64x4()
+
+	default:
+		t.Errorf("Unknown method: Float64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x4Ternary(t *testing.T, v0 []float64, v1 []float64, v2 []float64, want []float64, which string) {
+	t.Helper()
+	var gotv simd.Float64x4
+	got := make([]float64, len(want))
+	vec0 := simd.LoadFloat64x4Slice(v0)
+	vec1 := simd.LoadFloat64x4Slice(v1)
+	vec2 := simd.LoadFloat64x4Slice(v2)
+	switch which {
+	case "FusedMultiplyAdd":
+		gotv = vec0.FusedMultiplyAdd(vec1, vec2)
+	case "FusedMultiplyAddSub":
+		gotv = vec0.FusedMultiplyAddSub(vec1, vec2)
+	case "FusedMultiplySubAdd":
+		gotv = vec0.FusedMultiplySubAdd(vec1, vec2)
+
+	default:
+		t.Errorf("Unknown method: Float64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x4TernaryMasked(t *testing.T, v0 []float64, v1 []float64, v2 []float64, v3 []int64, want []float64, which string) {
+	t.Helper()
+	var gotv simd.Float64x4
+	got := make([]float64, len(want))
+	vec0 := simd.LoadFloat64x4Slice(v0)
+	vec1 := simd.LoadFloat64x4Slice(v1)
+	vec2 := simd.LoadFloat64x4Slice(v2)
+	vec3 := simd.LoadInt64x4Slice(v3)
+	switch which {
+	case "MaskedFusedMultiplyAdd":
+		gotv = vec0.MaskedFusedMultiplyAdd(vec1, vec2, vec3.AsMask64x4())
+	case "MaskedFusedMultiplyAddSub":
+		gotv = vec0.MaskedFusedMultiplyAddSub(vec1, vec2, vec3.AsMask64x4())
+	case "MaskedFusedMultiplySubAdd":
+		gotv = vec0.MaskedFusedMultiplySubAdd(vec1, vec2, vec3.AsMask64x4())
+
+	default:
+		t.Errorf("Unknown method: Float64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x4Unary(t *testing.T, v0 []float64, want []float64, which string) {
+	t.Helper()
+	var gotv simd.Float64x4
+	got := make([]float64, len(want))
+	vec0 := simd.LoadFloat64x4Slice(v0)
+	switch which {
+	case "ApproximateReciprocal":
+		gotv = vec0.ApproximateReciprocal()
+	case "ApproximateReciprocalOfSqrt":
+		gotv = vec0.ApproximateReciprocalOfSqrt()
+	case "Ceil":
+		gotv = vec0.Ceil()
+	case "Floor":
+		gotv = vec0.Floor()
+	case "Round":
+		gotv = vec0.Round()
+	case "Sqrt":
+		gotv = vec0.Sqrt()
+	case "Trunc":
+		gotv = vec0.Trunc()
+
+	default:
+		t.Errorf("Unknown method: Float64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x4UnaryMasked(t *testing.T, v0 []float64, v1 []int64, want []float64, which string) {
+	t.Helper()
+	var gotv simd.Float64x4
+	got := make([]float64, len(want))
+	vec0 := simd.LoadFloat64x4Slice(v0)
+	vec1 := simd.LoadInt64x4Slice(v1)
+	switch which {
+	case "MaskedApproximateReciprocal":
+		gotv = vec0.MaskedApproximateReciprocal(vec1.AsMask64x4())
+	case "MaskedApproximateReciprocalOfSqrt":
+		gotv = vec0.MaskedApproximateReciprocalOfSqrt(vec1.AsMask64x4())
+	case "MaskedSqrt":
+		gotv = vec0.MaskedSqrt(vec1.AsMask64x4())
+
+	default:
+		t.Errorf("Unknown method: Float64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x8Binary(t *testing.T, v0 []float64, v1 []float64, want []float64, which string) {
+	t.Helper()
+	var gotv simd.Float64x8
+	got := make([]float64, len(want))
+	vec0 := simd.LoadFloat64x8Slice(v0)
+	vec1 := simd.LoadFloat64x8Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Div":
+		gotv = vec0.Div(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "Mul":
+		gotv = vec0.Mul(vec1)
+	case "MulByPowOf2":
+		gotv = vec0.MulByPowOf2(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Float64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x8BinaryMasked(t *testing.T, v0 []float64, v1 []float64, v2 []int64, want []float64, which string) {
+	t.Helper()
+	var gotv simd.Float64x8
+	got := make([]float64, len(want))
+	vec0 := simd.LoadFloat64x8Slice(v0)
+	vec1 := simd.LoadFloat64x8Slice(v1)
+	vec2 := simd.LoadInt64x8Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask64x8())
+	case "MaskedAnd":
+		gotv = vec0.MaskedAnd(vec1, vec2.AsMask64x8())
+	case "MaskedAndNot":
+		gotv = vec0.MaskedAndNot(vec1, vec2.AsMask64x8())
+	case "MaskedDiv":
+		gotv = vec0.MaskedDiv(vec1, vec2.AsMask64x8())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask64x8())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask64x8())
+	case "MaskedMul":
+		gotv = vec0.MaskedMul(vec1, vec2.AsMask64x8())
+	case "MaskedMulByPowOf2":
+		gotv = vec0.MaskedMulByPowOf2(vec1, vec2.AsMask64x8())
+	case "MaskedOr":
+		gotv = vec0.MaskedOr(vec1, vec2.AsMask64x8())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask64x8())
+	case "MaskedXor":
+		gotv = vec0.MaskedXor(vec1, vec2.AsMask64x8())
+
+	default:
+		t.Errorf("Unknown method: Float64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x8Compare(t *testing.T, v0 []float64, v1 []float64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x8
+	got := make([]int64, len(want))
+	vec0 := simd.LoadFloat64x8Slice(v0)
+	vec1 := simd.LoadFloat64x8Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt64x8()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt64x8()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt64x8()
+	case "IsNan":
+		gotv = vec0.IsNan(vec1).AsInt64x8()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt64x8()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt64x8()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt64x8()
+
+	default:
+		t.Errorf("Unknown method: Float64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x8MaskedCompare(t *testing.T, v0 []float64, v1 []float64, v2 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x8
+	got := make([]int64, len(want))
+	vec0 := simd.LoadFloat64x8Slice(v0)
+	vec1 := simd.LoadFloat64x8Slice(v1)
+	vec2 := simd.LoadInt64x8Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask64x8()).AsInt64x8()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask64x8()).AsInt64x8()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask64x8()).AsInt64x8()
+	case "MaskedIsNan":
+		gotv = vec0.MaskedIsNan(vec1, vec2.AsMask64x8()).AsInt64x8()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask64x8()).AsInt64x8()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask64x8()).AsInt64x8()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask64x8()).AsInt64x8()
+
+	default:
+		t.Errorf("Unknown method: Float64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x8Ternary(t *testing.T, v0 []float64, v1 []float64, v2 []float64, want []float64, which string) {
+	t.Helper()
+	var gotv simd.Float64x8
+	got := make([]float64, len(want))
+	vec0 := simd.LoadFloat64x8Slice(v0)
+	vec1 := simd.LoadFloat64x8Slice(v1)
+	vec2 := simd.LoadFloat64x8Slice(v2)
+	switch which {
+	case "FusedMultiplyAdd":
+		gotv = vec0.FusedMultiplyAdd(vec1, vec2)
+	case "FusedMultiplyAddSub":
+		gotv = vec0.FusedMultiplyAddSub(vec1, vec2)
+	case "FusedMultiplySubAdd":
+		gotv = vec0.FusedMultiplySubAdd(vec1, vec2)
+
+	default:
+		t.Errorf("Unknown method: Float64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x8TernaryMasked(t *testing.T, v0 []float64, v1 []float64, v2 []float64, v3 []int64, want []float64, which string) {
+	t.Helper()
+	var gotv simd.Float64x8
+	got := make([]float64, len(want))
+	vec0 := simd.LoadFloat64x8Slice(v0)
+	vec1 := simd.LoadFloat64x8Slice(v1)
+	vec2 := simd.LoadFloat64x8Slice(v2)
+	vec3 := simd.LoadInt64x8Slice(v3)
+	switch which {
+	case "MaskedFusedMultiplyAdd":
+		gotv = vec0.MaskedFusedMultiplyAdd(vec1, vec2, vec3.AsMask64x8())
+	case "MaskedFusedMultiplyAddSub":
+		gotv = vec0.MaskedFusedMultiplyAddSub(vec1, vec2, vec3.AsMask64x8())
+	case "MaskedFusedMultiplySubAdd":
+		gotv = vec0.MaskedFusedMultiplySubAdd(vec1, vec2, vec3.AsMask64x8())
+
+	default:
+		t.Errorf("Unknown method: Float64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x8Unary(t *testing.T, v0 []float64, want []float64, which string) {
+	t.Helper()
+	var gotv simd.Float64x8
+	got := make([]float64, len(want))
+	vec0 := simd.LoadFloat64x8Slice(v0)
+	switch which {
+	case "ApproximateReciprocal":
+		gotv = vec0.ApproximateReciprocal()
+	case "ApproximateReciprocalOfSqrt":
+		gotv = vec0.ApproximateReciprocalOfSqrt()
+	case "Sqrt":
+		gotv = vec0.Sqrt()
+
+	default:
+		t.Errorf("Unknown method: Float64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testFloat64x8UnaryMasked(t *testing.T, v0 []float64, v1 []int64, want []float64, which string) {
+	t.Helper()
+	var gotv simd.Float64x8
+	got := make([]float64, len(want))
+	vec0 := simd.LoadFloat64x8Slice(v0)
+	vec1 := simd.LoadInt64x8Slice(v1)
+	switch which {
+	case "MaskedApproximateReciprocal":
+		gotv = vec0.MaskedApproximateReciprocal(vec1.AsMask64x8())
+	case "MaskedApproximateReciprocalOfSqrt":
+		gotv = vec0.MaskedApproximateReciprocalOfSqrt(vec1.AsMask64x8())
+	case "MaskedSqrt":
+		gotv = vec0.MaskedSqrt(vec1.AsMask64x8())
+
+	default:
+		t.Errorf("Unknown method: Float64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x16Binary(t *testing.T, v0 []int16, v1 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x16
+	got := make([]int16, len(want))
+	vec0 := simd.LoadInt16x16Slice(v0)
+	vec1 := simd.LoadInt16x16Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "MulHigh":
+		gotv = vec0.MulHigh(vec1)
+	case "MulLow":
+		gotv = vec0.MulLow(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "PairwiseAdd":
+		gotv = vec0.PairwiseAdd(vec1)
+	case "PairwiseSub":
+		gotv = vec0.PairwiseSub(vec1)
+	case "SaturatedAdd":
+		gotv = vec0.SaturatedAdd(vec1)
+	case "SaturatedPairwiseAdd":
+		gotv = vec0.SaturatedPairwiseAdd(vec1)
+	case "SaturatedPairwiseSub":
+		gotv = vec0.SaturatedPairwiseSub(vec1)
+	case "SaturatedSub":
+		gotv = vec0.SaturatedSub(vec1)
+	case "Sign":
+		gotv = vec0.Sign(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Int16x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x16BinaryMasked(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x16
+	got := make([]int16, len(want))
+	vec0 := simd.LoadInt16x16Slice(v0)
+	vec1 := simd.LoadInt16x16Slice(v1)
+	vec2 := simd.LoadInt16x16Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask16x16())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask16x16())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask16x16())
+	case "MaskedMulHigh":
+		gotv = vec0.MaskedMulHigh(vec1, vec2.AsMask16x16())
+	case "MaskedMulLow":
+		gotv = vec0.MaskedMulLow(vec1, vec2.AsMask16x16())
+	case "MaskedSaturatedAdd":
+		gotv = vec0.MaskedSaturatedAdd(vec1, vec2.AsMask16x16())
+	case "MaskedSaturatedSub":
+		gotv = vec0.MaskedSaturatedSub(vec1, vec2.AsMask16x16())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask16x16())
+
+	default:
+		t.Errorf("Unknown method: Int16x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x16BinaryMaskedWiden(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x8
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt16x16Slice(v0)
+	vec1 := simd.LoadInt16x16Slice(v1)
+	vec2 := simd.LoadInt16x16Slice(v2)
+	switch which {
+	case "MaskedPairDotProd":
+		gotv = vec0.MaskedPairDotProd(vec1, vec2.AsMask16x16())
+
+	default:
+		t.Errorf("Unknown method: Int16x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x16BinaryWiden(t *testing.T, v0 []int16, v1 []int16, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x8
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt16x16Slice(v0)
+	vec1 := simd.LoadInt16x16Slice(v1)
+	switch which {
+	case "PairDotProd":
+		gotv = vec0.PairDotProd(vec1)
+
+	default:
+		t.Errorf("Unknown method: Int16x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x16Compare(t *testing.T, v0 []int16, v1 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x16
+	got := make([]int16, len(want))
+	vec0 := simd.LoadInt16x16Slice(v0)
+	vec1 := simd.LoadInt16x16Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt16x16()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt16x16()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt16x16()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt16x16()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt16x16()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt16x16()
+
+	default:
+		t.Errorf("Unknown method: Int16x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x16MaskedCompare(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x16
+	got := make([]int16, len(want))
+	vec0 := simd.LoadInt16x16Slice(v0)
+	vec1 := simd.LoadInt16x16Slice(v1)
+	vec2 := simd.LoadInt16x16Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask16x16()).AsInt16x16()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask16x16()).AsInt16x16()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask16x16()).AsInt16x16()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask16x16()).AsInt16x16()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask16x16()).AsInt16x16()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask16x16()).AsInt16x16()
+
+	default:
+		t.Errorf("Unknown method: Int16x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x16Unary(t *testing.T, v0 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x16
+	got := make([]int16, len(want))
+	vec0 := simd.LoadInt16x16Slice(v0)
+	switch which {
+	case "Absolute":
+		gotv = vec0.Absolute()
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Int16x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x16UnaryMasked(t *testing.T, v0 []int16, v1 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x16
+	got := make([]int16, len(want))
+	vec0 := simd.LoadInt16x16Slice(v0)
+	vec1 := simd.LoadInt16x16Slice(v1)
+	switch which {
+	case "MaskedAbsolute":
+		gotv = vec0.MaskedAbsolute(vec1.AsMask16x16())
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask16x16())
+
+	default:
+		t.Errorf("Unknown method: Int16x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x32Binary(t *testing.T, v0 []int16, v1 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x32
+	got := make([]int16, len(want))
+	vec0 := simd.LoadInt16x32Slice(v0)
+	vec1 := simd.LoadInt16x32Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "MulHigh":
+		gotv = vec0.MulHigh(vec1)
+	case "MulLow":
+		gotv = vec0.MulLow(vec1)
+	case "SaturatedAdd":
+		gotv = vec0.SaturatedAdd(vec1)
+	case "SaturatedSub":
+		gotv = vec0.SaturatedSub(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+
+	default:
+		t.Errorf("Unknown method: Int16x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x32BinaryMasked(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x32
+	got := make([]int16, len(want))
+	vec0 := simd.LoadInt16x32Slice(v0)
+	vec1 := simd.LoadInt16x32Slice(v1)
+	vec2 := simd.LoadInt16x32Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask16x32())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask16x32())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask16x32())
+	case "MaskedMulHigh":
+		gotv = vec0.MaskedMulHigh(vec1, vec2.AsMask16x32())
+	case "MaskedMulLow":
+		gotv = vec0.MaskedMulLow(vec1, vec2.AsMask16x32())
+	case "MaskedSaturatedAdd":
+		gotv = vec0.MaskedSaturatedAdd(vec1, vec2.AsMask16x32())
+	case "MaskedSaturatedSub":
+		gotv = vec0.MaskedSaturatedSub(vec1, vec2.AsMask16x32())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask16x32())
+
+	default:
+		t.Errorf("Unknown method: Int16x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x32BinaryMaskedWiden(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x16
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt16x32Slice(v0)
+	vec1 := simd.LoadInt16x32Slice(v1)
+	vec2 := simd.LoadInt16x32Slice(v2)
+	switch which {
+	case "MaskedPairDotProd":
+		gotv = vec0.MaskedPairDotProd(vec1, vec2.AsMask16x32())
+
+	default:
+		t.Errorf("Unknown method: Int16x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x32BinaryWiden(t *testing.T, v0 []int16, v1 []int16, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x16
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt16x32Slice(v0)
+	vec1 := simd.LoadInt16x32Slice(v1)
+	switch which {
+	case "PairDotProd":
+		gotv = vec0.PairDotProd(vec1)
+
+	default:
+		t.Errorf("Unknown method: Int16x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x32Compare(t *testing.T, v0 []int16, v1 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x32
+	got := make([]int16, len(want))
+	vec0 := simd.LoadInt16x32Slice(v0)
+	vec1 := simd.LoadInt16x32Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt16x32()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt16x32()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt16x32()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt16x32()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt16x32()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt16x32()
+
+	default:
+		t.Errorf("Unknown method: Int16x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x32MaskedCompare(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x32
+	got := make([]int16, len(want))
+	vec0 := simd.LoadInt16x32Slice(v0)
+	vec1 := simd.LoadInt16x32Slice(v1)
+	vec2 := simd.LoadInt16x32Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask16x32()).AsInt16x32()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask16x32()).AsInt16x32()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask16x32()).AsInt16x32()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask16x32()).AsInt16x32()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask16x32()).AsInt16x32()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask16x32()).AsInt16x32()
+
+	default:
+		t.Errorf("Unknown method: Int16x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x32Unary(t *testing.T, v0 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x32
+	got := make([]int16, len(want))
+	vec0 := simd.LoadInt16x32Slice(v0)
+	switch which {
+	case "Absolute":
+		gotv = vec0.Absolute()
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Int16x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x32UnaryMasked(t *testing.T, v0 []int16, v1 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x32
+	got := make([]int16, len(want))
+	vec0 := simd.LoadInt16x32Slice(v0)
+	vec1 := simd.LoadInt16x32Slice(v1)
+	switch which {
+	case "MaskedAbsolute":
+		gotv = vec0.MaskedAbsolute(vec1.AsMask16x32())
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask16x32())
+
+	default:
+		t.Errorf("Unknown method: Int16x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x8Binary(t *testing.T, v0 []int16, v1 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x8
+	got := make([]int16, len(want))
+	vec0 := simd.LoadInt16x8Slice(v0)
+	vec1 := simd.LoadInt16x8Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "MulHigh":
+		gotv = vec0.MulHigh(vec1)
+	case "MulLow":
+		gotv = vec0.MulLow(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "PairwiseAdd":
+		gotv = vec0.PairwiseAdd(vec1)
+	case "PairwiseSub":
+		gotv = vec0.PairwiseSub(vec1)
+	case "SaturatedAdd":
+		gotv = vec0.SaturatedAdd(vec1)
+	case "SaturatedPairwiseAdd":
+		gotv = vec0.SaturatedPairwiseAdd(vec1)
+	case "SaturatedPairwiseSub":
+		gotv = vec0.SaturatedPairwiseSub(vec1)
+	case "SaturatedSub":
+		gotv = vec0.SaturatedSub(vec1)
+	case "Sign":
+		gotv = vec0.Sign(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Int16x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x8BinaryMasked(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x8
+	got := make([]int16, len(want))
+	vec0 := simd.LoadInt16x8Slice(v0)
+	vec1 := simd.LoadInt16x8Slice(v1)
+	vec2 := simd.LoadInt16x8Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask16x8())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask16x8())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask16x8())
+	case "MaskedMulHigh":
+		gotv = vec0.MaskedMulHigh(vec1, vec2.AsMask16x8())
+	case "MaskedMulLow":
+		gotv = vec0.MaskedMulLow(vec1, vec2.AsMask16x8())
+	case "MaskedSaturatedAdd":
+		gotv = vec0.MaskedSaturatedAdd(vec1, vec2.AsMask16x8())
+	case "MaskedSaturatedSub":
+		gotv = vec0.MaskedSaturatedSub(vec1, vec2.AsMask16x8())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask16x8())
+
+	default:
+		t.Errorf("Unknown method: Int16x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x8BinaryMaskedWiden(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x4
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt16x8Slice(v0)
+	vec1 := simd.LoadInt16x8Slice(v1)
+	vec2 := simd.LoadInt16x8Slice(v2)
+	switch which {
+	case "MaskedPairDotProd":
+		gotv = vec0.MaskedPairDotProd(vec1, vec2.AsMask16x8())
+
+	default:
+		t.Errorf("Unknown method: Int16x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x8BinaryWiden(t *testing.T, v0 []int16, v1 []int16, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x4
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt16x8Slice(v0)
+	vec1 := simd.LoadInt16x8Slice(v1)
+	switch which {
+	case "PairDotProd":
+		gotv = vec0.PairDotProd(vec1)
+
+	default:
+		t.Errorf("Unknown method: Int16x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x8Compare(t *testing.T, v0 []int16, v1 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x8
+	got := make([]int16, len(want))
+	vec0 := simd.LoadInt16x8Slice(v0)
+	vec1 := simd.LoadInt16x8Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt16x8()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt16x8()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt16x8()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt16x8()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt16x8()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt16x8()
+
+	default:
+		t.Errorf("Unknown method: Int16x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x8MaskedCompare(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x8
+	got := make([]int16, len(want))
+	vec0 := simd.LoadInt16x8Slice(v0)
+	vec1 := simd.LoadInt16x8Slice(v1)
+	vec2 := simd.LoadInt16x8Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask16x8()).AsInt16x8()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask16x8()).AsInt16x8()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask16x8()).AsInt16x8()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask16x8()).AsInt16x8()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask16x8()).AsInt16x8()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask16x8()).AsInt16x8()
+
+	default:
+		t.Errorf("Unknown method: Int16x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x8Unary(t *testing.T, v0 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x8
+	got := make([]int16, len(want))
+	vec0 := simd.LoadInt16x8Slice(v0)
+	switch which {
+	case "Absolute":
+		gotv = vec0.Absolute()
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Int16x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt16x8UnaryMasked(t *testing.T, v0 []int16, v1 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x8
+	got := make([]int16, len(want))
+	vec0 := simd.LoadInt16x8Slice(v0)
+	vec1 := simd.LoadInt16x8Slice(v1)
+	switch which {
+	case "MaskedAbsolute":
+		gotv = vec0.MaskedAbsolute(vec1.AsMask16x8())
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask16x8())
+
+	default:
+		t.Errorf("Unknown method: Int16x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x16Binary(t *testing.T, v0 []int32, v1 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x16
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x16Slice(v0)
+	vec1 := simd.LoadInt32x16Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "MulLow":
+		gotv = vec0.MulLow(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Int32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x16BinaryMasked(t *testing.T, v0 []int32, v1 []int32, v2 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x16
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x16Slice(v0)
+	vec1 := simd.LoadInt32x16Slice(v1)
+	vec2 := simd.LoadInt32x16Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask32x16())
+	case "MaskedAnd":
+		gotv = vec0.MaskedAnd(vec1, vec2.AsMask32x16())
+	case "MaskedAndNot":
+		gotv = vec0.MaskedAndNot(vec1, vec2.AsMask32x16())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask32x16())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask32x16())
+	case "MaskedMulLow":
+		gotv = vec0.MaskedMulLow(vec1, vec2.AsMask32x16())
+	case "MaskedOr":
+		gotv = vec0.MaskedOr(vec1, vec2.AsMask32x16())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask32x16())
+	case "MaskedXor":
+		gotv = vec0.MaskedXor(vec1, vec2.AsMask32x16())
+
+	default:
+		t.Errorf("Unknown method: Int32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x16Compare(t *testing.T, v0 []int32, v1 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x16
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x16Slice(v0)
+	vec1 := simd.LoadInt32x16Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt32x16()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt32x16()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt32x16()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt32x16()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt32x16()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt32x16()
+
+	default:
+		t.Errorf("Unknown method: Int32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x16Int16x32Int16x32Int32x16(t *testing.T, v0 []int32, v1 []int16, v2 []int16, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x16
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x16Slice(v0)
+	vec1 := simd.LoadInt16x32Slice(v1)
+	vec2 := simd.LoadInt16x32Slice(v2)
+	switch which {
+	case "PairDotProdAccumulate":
+		gotv = vec0.PairDotProdAccumulate(vec1, vec2)
+	case "SaturatedPairDotProdAccumulate":
+		gotv = vec0.SaturatedPairDotProdAccumulate(vec1, vec2)
+
+	default:
+		t.Errorf("Unknown method: Int32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x16Int16x32Int16x32Mask32x16Int32x16(t *testing.T, v0 []int32, v1 []int16, v2 []int16, v3 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x16
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x16Slice(v0)
+	vec1 := simd.LoadInt16x32Slice(v1)
+	vec2 := simd.LoadInt16x32Slice(v2)
+	vec3 := simd.LoadInt32x16Slice(v3)
+	switch which {
+	case "MaskedPairDotProdAccumulate":
+		gotv = vec0.MaskedPairDotProdAccumulate(vec1, vec2, vec3.AsMask32x16())
+	case "MaskedSaturatedPairDotProdAccumulate":
+		gotv = vec0.MaskedSaturatedPairDotProdAccumulate(vec1, vec2, vec3.AsMask32x16())
+
+	default:
+		t.Errorf("Unknown method: Int32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x16MaskedCompare(t *testing.T, v0 []int32, v1 []int32, v2 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x16
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x16Slice(v0)
+	vec1 := simd.LoadInt32x16Slice(v1)
+	vec2 := simd.LoadInt32x16Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask32x16()).AsInt32x16()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask32x16()).AsInt32x16()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask32x16()).AsInt32x16()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask32x16()).AsInt32x16()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask32x16()).AsInt32x16()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask32x16()).AsInt32x16()
+
+	default:
+		t.Errorf("Unknown method: Int32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x16Uint8x64Int8x64Int32x16(t *testing.T, v0 []int32, v1 []uint8, v2 []int8, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x16
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x16Slice(v0)
+	vec1 := simd.LoadUint8x64Slice(v1)
+	vec2 := simd.LoadInt8x64Slice(v2)
+	switch which {
+	case "SaturatedUnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.SaturatedUnsignedSignedQuadDotProdAccumulate(vec1, vec2)
+	case "UnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.UnsignedSignedQuadDotProdAccumulate(vec1, vec2)
+
+	default:
+		t.Errorf("Unknown method: Int32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x16Uint8x64Int8x64Mask32x16Int32x16(t *testing.T, v0 []int32, v1 []uint8, v2 []int8, v3 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x16
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x16Slice(v0)
+	vec1 := simd.LoadUint8x64Slice(v1)
+	vec2 := simd.LoadInt8x64Slice(v2)
+	vec3 := simd.LoadInt32x16Slice(v3)
+	switch which {
+	case "MaskedSaturatedUnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.MaskedSaturatedUnsignedSignedQuadDotProdAccumulate(vec1, vec2, vec3.AsMask32x16())
+	case "MaskedUnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.MaskedUnsignedSignedQuadDotProdAccumulate(vec1, vec2, vec3.AsMask32x16())
+
+	default:
+		t.Errorf("Unknown method: Int32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x16Unary(t *testing.T, v0 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x16
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x16Slice(v0)
+	switch which {
+	case "Absolute":
+		gotv = vec0.Absolute()
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Int32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x16UnaryMasked(t *testing.T, v0 []int32, v1 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x16
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x16Slice(v0)
+	vec1 := simd.LoadInt32x16Slice(v1)
+	switch which {
+	case "MaskedAbsolute":
+		gotv = vec0.MaskedAbsolute(vec1.AsMask32x16())
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask32x16())
+
+	default:
+		t.Errorf("Unknown method: Int32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x4Binary(t *testing.T, v0 []int32, v1 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x4
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x4Slice(v0)
+	vec1 := simd.LoadInt32x4Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "MulLow":
+		gotv = vec0.MulLow(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "PairwiseAdd":
+		gotv = vec0.PairwiseAdd(vec1)
+	case "PairwiseSub":
+		gotv = vec0.PairwiseSub(vec1)
+	case "Sign":
+		gotv = vec0.Sign(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Int32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x4BinaryMasked(t *testing.T, v0 []int32, v1 []int32, v2 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x4
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x4Slice(v0)
+	vec1 := simd.LoadInt32x4Slice(v1)
+	vec2 := simd.LoadInt32x4Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask32x4())
+	case "MaskedAnd":
+		gotv = vec0.MaskedAnd(vec1, vec2.AsMask32x4())
+	case "MaskedAndNot":
+		gotv = vec0.MaskedAndNot(vec1, vec2.AsMask32x4())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask32x4())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask32x4())
+	case "MaskedMulLow":
+		gotv = vec0.MaskedMulLow(vec1, vec2.AsMask32x4())
+	case "MaskedOr":
+		gotv = vec0.MaskedOr(vec1, vec2.AsMask32x4())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask32x4())
+	case "MaskedXor":
+		gotv = vec0.MaskedXor(vec1, vec2.AsMask32x4())
+
+	default:
+		t.Errorf("Unknown method: Int32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x4BinaryWiden(t *testing.T, v0 []int32, v1 []int32, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x2
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt32x4Slice(v0)
+	vec1 := simd.LoadInt32x4Slice(v1)
+	switch which {
+	case "MulEvenWiden":
+		gotv = vec0.MulEvenWiden(vec1)
+
+	default:
+		t.Errorf("Unknown method: Int32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x4Compare(t *testing.T, v0 []int32, v1 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x4
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x4Slice(v0)
+	vec1 := simd.LoadInt32x4Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt32x4()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt32x4()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt32x4()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt32x4()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt32x4()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt32x4()
+
+	default:
+		t.Errorf("Unknown method: Int32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x4Int16x8Int16x8Int32x4(t *testing.T, v0 []int32, v1 []int16, v2 []int16, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x4
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x4Slice(v0)
+	vec1 := simd.LoadInt16x8Slice(v1)
+	vec2 := simd.LoadInt16x8Slice(v2)
+	switch which {
+	case "PairDotProdAccumulate":
+		gotv = vec0.PairDotProdAccumulate(vec1, vec2)
+	case "SaturatedPairDotProdAccumulate":
+		gotv = vec0.SaturatedPairDotProdAccumulate(vec1, vec2)
+
+	default:
+		t.Errorf("Unknown method: Int32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x4Int16x8Int16x8Mask32x4Int32x4(t *testing.T, v0 []int32, v1 []int16, v2 []int16, v3 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x4
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x4Slice(v0)
+	vec1 := simd.LoadInt16x8Slice(v1)
+	vec2 := simd.LoadInt16x8Slice(v2)
+	vec3 := simd.LoadInt32x4Slice(v3)
+	switch which {
+	case "MaskedPairDotProdAccumulate":
+		gotv = vec0.MaskedPairDotProdAccumulate(vec1, vec2, vec3.AsMask32x4())
+	case "MaskedSaturatedPairDotProdAccumulate":
+		gotv = vec0.MaskedSaturatedPairDotProdAccumulate(vec1, vec2, vec3.AsMask32x4())
+
+	default:
+		t.Errorf("Unknown method: Int32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x4MaskedCompare(t *testing.T, v0 []int32, v1 []int32, v2 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x4
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x4Slice(v0)
+	vec1 := simd.LoadInt32x4Slice(v1)
+	vec2 := simd.LoadInt32x4Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask32x4()).AsInt32x4()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask32x4()).AsInt32x4()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask32x4()).AsInt32x4()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask32x4()).AsInt32x4()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask32x4()).AsInt32x4()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask32x4()).AsInt32x4()
+
+	default:
+		t.Errorf("Unknown method: Int32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x4Uint8x16Int8x16Int32x4(t *testing.T, v0 []int32, v1 []uint8, v2 []int8, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x4
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x4Slice(v0)
+	vec1 := simd.LoadUint8x16Slice(v1)
+	vec2 := simd.LoadInt8x16Slice(v2)
+	switch which {
+	case "SaturatedUnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.SaturatedUnsignedSignedQuadDotProdAccumulate(vec1, vec2)
+	case "UnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.UnsignedSignedQuadDotProdAccumulate(vec1, vec2)
+
+	default:
+		t.Errorf("Unknown method: Int32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x4Uint8x16Int8x16Mask32x4Int32x4(t *testing.T, v0 []int32, v1 []uint8, v2 []int8, v3 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x4
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x4Slice(v0)
+	vec1 := simd.LoadUint8x16Slice(v1)
+	vec2 := simd.LoadInt8x16Slice(v2)
+	vec3 := simd.LoadInt32x4Slice(v3)
+	switch which {
+	case "MaskedSaturatedUnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.MaskedSaturatedUnsignedSignedQuadDotProdAccumulate(vec1, vec2, vec3.AsMask32x4())
+	case "MaskedUnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.MaskedUnsignedSignedQuadDotProdAccumulate(vec1, vec2, vec3.AsMask32x4())
+
+	default:
+		t.Errorf("Unknown method: Int32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x4Unary(t *testing.T, v0 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x4
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x4Slice(v0)
+	switch which {
+	case "Absolute":
+		gotv = vec0.Absolute()
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Int32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x4UnaryMasked(t *testing.T, v0 []int32, v1 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x4
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x4Slice(v0)
+	vec1 := simd.LoadInt32x4Slice(v1)
+	switch which {
+	case "MaskedAbsolute":
+		gotv = vec0.MaskedAbsolute(vec1.AsMask32x4())
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask32x4())
+
+	default:
+		t.Errorf("Unknown method: Int32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x8Binary(t *testing.T, v0 []int32, v1 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x8
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x8Slice(v0)
+	vec1 := simd.LoadInt32x8Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "MulLow":
+		gotv = vec0.MulLow(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "PairwiseAdd":
+		gotv = vec0.PairwiseAdd(vec1)
+	case "PairwiseSub":
+		gotv = vec0.PairwiseSub(vec1)
+	case "Sign":
+		gotv = vec0.Sign(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Int32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x8BinaryMasked(t *testing.T, v0 []int32, v1 []int32, v2 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x8
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x8Slice(v0)
+	vec1 := simd.LoadInt32x8Slice(v1)
+	vec2 := simd.LoadInt32x8Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask32x8())
+	case "MaskedAnd":
+		gotv = vec0.MaskedAnd(vec1, vec2.AsMask32x8())
+	case "MaskedAndNot":
+		gotv = vec0.MaskedAndNot(vec1, vec2.AsMask32x8())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask32x8())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask32x8())
+	case "MaskedMulLow":
+		gotv = vec0.MaskedMulLow(vec1, vec2.AsMask32x8())
+	case "MaskedOr":
+		gotv = vec0.MaskedOr(vec1, vec2.AsMask32x8())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask32x8())
+	case "MaskedXor":
+		gotv = vec0.MaskedXor(vec1, vec2.AsMask32x8())
+
+	default:
+		t.Errorf("Unknown method: Int32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x8BinaryWiden(t *testing.T, v0 []int32, v1 []int32, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x4
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt32x8Slice(v0)
+	vec1 := simd.LoadInt32x8Slice(v1)
+	switch which {
+	case "MulEvenWiden":
+		gotv = vec0.MulEvenWiden(vec1)
+
+	default:
+		t.Errorf("Unknown method: Int32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x8Compare(t *testing.T, v0 []int32, v1 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x8
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x8Slice(v0)
+	vec1 := simd.LoadInt32x8Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt32x8()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt32x8()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt32x8()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt32x8()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt32x8()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt32x8()
+
+	default:
+		t.Errorf("Unknown method: Int32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x8Int16x16Int16x16Int32x8(t *testing.T, v0 []int32, v1 []int16, v2 []int16, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x8
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x8Slice(v0)
+	vec1 := simd.LoadInt16x16Slice(v1)
+	vec2 := simd.LoadInt16x16Slice(v2)
+	switch which {
+	case "PairDotProdAccumulate":
+		gotv = vec0.PairDotProdAccumulate(vec1, vec2)
+	case "SaturatedPairDotProdAccumulate":
+		gotv = vec0.SaturatedPairDotProdAccumulate(vec1, vec2)
+
+	default:
+		t.Errorf("Unknown method: Int32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x8Int16x16Int16x16Mask32x8Int32x8(t *testing.T, v0 []int32, v1 []int16, v2 []int16, v3 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x8
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x8Slice(v0)
+	vec1 := simd.LoadInt16x16Slice(v1)
+	vec2 := simd.LoadInt16x16Slice(v2)
+	vec3 := simd.LoadInt32x8Slice(v3)
+	switch which {
+	case "MaskedPairDotProdAccumulate":
+		gotv = vec0.MaskedPairDotProdAccumulate(vec1, vec2, vec3.AsMask32x8())
+	case "MaskedSaturatedPairDotProdAccumulate":
+		gotv = vec0.MaskedSaturatedPairDotProdAccumulate(vec1, vec2, vec3.AsMask32x8())
+
+	default:
+		t.Errorf("Unknown method: Int32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x8MaskedCompare(t *testing.T, v0 []int32, v1 []int32, v2 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x8
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x8Slice(v0)
+	vec1 := simd.LoadInt32x8Slice(v1)
+	vec2 := simd.LoadInt32x8Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask32x8()).AsInt32x8()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask32x8()).AsInt32x8()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask32x8()).AsInt32x8()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask32x8()).AsInt32x8()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask32x8()).AsInt32x8()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask32x8()).AsInt32x8()
+
+	default:
+		t.Errorf("Unknown method: Int32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x8Uint8x32Int8x32Int32x8(t *testing.T, v0 []int32, v1 []uint8, v2 []int8, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x8
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x8Slice(v0)
+	vec1 := simd.LoadUint8x32Slice(v1)
+	vec2 := simd.LoadInt8x32Slice(v2)
+	switch which {
+	case "SaturatedUnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.SaturatedUnsignedSignedQuadDotProdAccumulate(vec1, vec2)
+	case "UnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.UnsignedSignedQuadDotProdAccumulate(vec1, vec2)
+
+	default:
+		t.Errorf("Unknown method: Int32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x8Uint8x32Int8x32Mask32x8Int32x8(t *testing.T, v0 []int32, v1 []uint8, v2 []int8, v3 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x8
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x8Slice(v0)
+	vec1 := simd.LoadUint8x32Slice(v1)
+	vec2 := simd.LoadInt8x32Slice(v2)
+	vec3 := simd.LoadInt32x8Slice(v3)
+	switch which {
+	case "MaskedSaturatedUnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.MaskedSaturatedUnsignedSignedQuadDotProdAccumulate(vec1, vec2, vec3.AsMask32x8())
+	case "MaskedUnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.MaskedUnsignedSignedQuadDotProdAccumulate(vec1, vec2, vec3.AsMask32x8())
+
+	default:
+		t.Errorf("Unknown method: Int32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x8Unary(t *testing.T, v0 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x8
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x8Slice(v0)
+	switch which {
+	case "Absolute":
+		gotv = vec0.Absolute()
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Int32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt32x8UnaryMasked(t *testing.T, v0 []int32, v1 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x8
+	got := make([]int32, len(want))
+	vec0 := simd.LoadInt32x8Slice(v0)
+	vec1 := simd.LoadInt32x8Slice(v1)
+	switch which {
+	case "MaskedAbsolute":
+		gotv = vec0.MaskedAbsolute(vec1.AsMask32x8())
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask32x8())
+
+	default:
+		t.Errorf("Unknown method: Int32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt64x2Binary(t *testing.T, v0 []int64, v1 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x2
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt64x2Slice(v0)
+	vec1 := simd.LoadInt64x2Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "MulEvenWiden":
+		gotv = vec0.MulEvenWiden(vec1)
+	case "MulLow":
+		gotv = vec0.MulLow(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Int64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt64x2BinaryMasked(t *testing.T, v0 []int64, v1 []int64, v2 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x2
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt64x2Slice(v0)
+	vec1 := simd.LoadInt64x2Slice(v1)
+	vec2 := simd.LoadInt64x2Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask64x2())
+	case "MaskedAnd":
+		gotv = vec0.MaskedAnd(vec1, vec2.AsMask64x2())
+	case "MaskedAndNot":
+		gotv = vec0.MaskedAndNot(vec1, vec2.AsMask64x2())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask64x2())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask64x2())
+	case "MaskedMulEvenWiden":
+		gotv = vec0.MaskedMulEvenWiden(vec1, vec2.AsMask64x2())
+	case "MaskedMulLow":
+		gotv = vec0.MaskedMulLow(vec1, vec2.AsMask64x2())
+	case "MaskedOr":
+		gotv = vec0.MaskedOr(vec1, vec2.AsMask64x2())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask64x2())
+	case "MaskedXor":
+		gotv = vec0.MaskedXor(vec1, vec2.AsMask64x2())
+
+	default:
+		t.Errorf("Unknown method: Int64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt64x2Compare(t *testing.T, v0 []int64, v1 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x2
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt64x2Slice(v0)
+	vec1 := simd.LoadInt64x2Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt64x2()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt64x2()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt64x2()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt64x2()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt64x2()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt64x2()
+
+	default:
+		t.Errorf("Unknown method: Int64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt64x2MaskedCompare(t *testing.T, v0 []int64, v1 []int64, v2 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x2
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt64x2Slice(v0)
+	vec1 := simd.LoadInt64x2Slice(v1)
+	vec2 := simd.LoadInt64x2Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask64x2()).AsInt64x2()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask64x2()).AsInt64x2()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask64x2()).AsInt64x2()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask64x2()).AsInt64x2()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask64x2()).AsInt64x2()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask64x2()).AsInt64x2()
+
+	default:
+		t.Errorf("Unknown method: Int64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt64x2Unary(t *testing.T, v0 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x2
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt64x2Slice(v0)
+	switch which {
+	case "Absolute":
+		gotv = vec0.Absolute()
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Int64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt64x2UnaryMasked(t *testing.T, v0 []int64, v1 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x2
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt64x2Slice(v0)
+	vec1 := simd.LoadInt64x2Slice(v1)
+	switch which {
+	case "MaskedAbsolute":
+		gotv = vec0.MaskedAbsolute(vec1.AsMask64x2())
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask64x2())
+
+	default:
+		t.Errorf("Unknown method: Int64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt64x4Binary(t *testing.T, v0 []int64, v1 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x4
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt64x4Slice(v0)
+	vec1 := simd.LoadInt64x4Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "MulEvenWiden":
+		gotv = vec0.MulEvenWiden(vec1)
+	case "MulLow":
+		gotv = vec0.MulLow(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Int64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt64x4BinaryMasked(t *testing.T, v0 []int64, v1 []int64, v2 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x4
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt64x4Slice(v0)
+	vec1 := simd.LoadInt64x4Slice(v1)
+	vec2 := simd.LoadInt64x4Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask64x4())
+	case "MaskedAnd":
+		gotv = vec0.MaskedAnd(vec1, vec2.AsMask64x4())
+	case "MaskedAndNot":
+		gotv = vec0.MaskedAndNot(vec1, vec2.AsMask64x4())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask64x4())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask64x4())
+	case "MaskedMulEvenWiden":
+		gotv = vec0.MaskedMulEvenWiden(vec1, vec2.AsMask64x4())
+	case "MaskedMulLow":
+		gotv = vec0.MaskedMulLow(vec1, vec2.AsMask64x4())
+	case "MaskedOr":
+		gotv = vec0.MaskedOr(vec1, vec2.AsMask64x4())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask64x4())
+	case "MaskedXor":
+		gotv = vec0.MaskedXor(vec1, vec2.AsMask64x4())
+
+	default:
+		t.Errorf("Unknown method: Int64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt64x4Compare(t *testing.T, v0 []int64, v1 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x4
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt64x4Slice(v0)
+	vec1 := simd.LoadInt64x4Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt64x4()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt64x4()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt64x4()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt64x4()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt64x4()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt64x4()
+
+	default:
+		t.Errorf("Unknown method: Int64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt64x4MaskedCompare(t *testing.T, v0 []int64, v1 []int64, v2 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x4
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt64x4Slice(v0)
+	vec1 := simd.LoadInt64x4Slice(v1)
+	vec2 := simd.LoadInt64x4Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask64x4()).AsInt64x4()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask64x4()).AsInt64x4()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask64x4()).AsInt64x4()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask64x4()).AsInt64x4()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask64x4()).AsInt64x4()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask64x4()).AsInt64x4()
+
+	default:
+		t.Errorf("Unknown method: Int64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt64x4Unary(t *testing.T, v0 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x4
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt64x4Slice(v0)
+	switch which {
+	case "Absolute":
+		gotv = vec0.Absolute()
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Int64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt64x4UnaryMasked(t *testing.T, v0 []int64, v1 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x4
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt64x4Slice(v0)
+	vec1 := simd.LoadInt64x4Slice(v1)
+	switch which {
+	case "MaskedAbsolute":
+		gotv = vec0.MaskedAbsolute(vec1.AsMask64x4())
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask64x4())
+
+	default:
+		t.Errorf("Unknown method: Int64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt64x8Binary(t *testing.T, v0 []int64, v1 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x8
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt64x8Slice(v0)
+	vec1 := simd.LoadInt64x8Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "MulEvenWiden":
+		gotv = vec0.MulEvenWiden(vec1)
+	case "MulLow":
+		gotv = vec0.MulLow(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Int64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt64x8BinaryMasked(t *testing.T, v0 []int64, v1 []int64, v2 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x8
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt64x8Slice(v0)
+	vec1 := simd.LoadInt64x8Slice(v1)
+	vec2 := simd.LoadInt64x8Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask64x8())
+	case "MaskedAnd":
+		gotv = vec0.MaskedAnd(vec1, vec2.AsMask64x8())
+	case "MaskedAndNot":
+		gotv = vec0.MaskedAndNot(vec1, vec2.AsMask64x8())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask64x8())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask64x8())
+	case "MaskedMulEvenWiden":
+		gotv = vec0.MaskedMulEvenWiden(vec1, vec2.AsMask64x8())
+	case "MaskedMulLow":
+		gotv = vec0.MaskedMulLow(vec1, vec2.AsMask64x8())
+	case "MaskedOr":
+		gotv = vec0.MaskedOr(vec1, vec2.AsMask64x8())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask64x8())
+	case "MaskedXor":
+		gotv = vec0.MaskedXor(vec1, vec2.AsMask64x8())
+
+	default:
+		t.Errorf("Unknown method: Int64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt64x8Compare(t *testing.T, v0 []int64, v1 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x8
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt64x8Slice(v0)
+	vec1 := simd.LoadInt64x8Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt64x8()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt64x8()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt64x8()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt64x8()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt64x8()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt64x8()
+
+	default:
+		t.Errorf("Unknown method: Int64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt64x8MaskedCompare(t *testing.T, v0 []int64, v1 []int64, v2 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x8
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt64x8Slice(v0)
+	vec1 := simd.LoadInt64x8Slice(v1)
+	vec2 := simd.LoadInt64x8Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask64x8()).AsInt64x8()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask64x8()).AsInt64x8()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask64x8()).AsInt64x8()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask64x8()).AsInt64x8()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask64x8()).AsInt64x8()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask64x8()).AsInt64x8()
+
+	default:
+		t.Errorf("Unknown method: Int64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt64x8Unary(t *testing.T, v0 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x8
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt64x8Slice(v0)
+	switch which {
+	case "Absolute":
+		gotv = vec0.Absolute()
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Int64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt64x8UnaryMasked(t *testing.T, v0 []int64, v1 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x8
+	got := make([]int64, len(want))
+	vec0 := simd.LoadInt64x8Slice(v0)
+	vec1 := simd.LoadInt64x8Slice(v1)
+	switch which {
+	case "MaskedAbsolute":
+		gotv = vec0.MaskedAbsolute(vec1.AsMask64x8())
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask64x8())
+
+	default:
+		t.Errorf("Unknown method: Int64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt8x16Binary(t *testing.T, v0 []int8, v1 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x16
+	got := make([]int8, len(want))
+	vec0 := simd.LoadInt8x16Slice(v0)
+	vec1 := simd.LoadInt8x16Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "SaturatedAdd":
+		gotv = vec0.SaturatedAdd(vec1)
+	case "SaturatedSub":
+		gotv = vec0.SaturatedSub(vec1)
+	case "Sign":
+		gotv = vec0.Sign(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Int8x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt8x16BinaryMasked(t *testing.T, v0 []int8, v1 []int8, v2 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x16
+	got := make([]int8, len(want))
+	vec0 := simd.LoadInt8x16Slice(v0)
+	vec1 := simd.LoadInt8x16Slice(v1)
+	vec2 := simd.LoadInt8x16Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask8x16())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask8x16())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask8x16())
+	case "MaskedSaturatedAdd":
+		gotv = vec0.MaskedSaturatedAdd(vec1, vec2.AsMask8x16())
+	case "MaskedSaturatedSub":
+		gotv = vec0.MaskedSaturatedSub(vec1, vec2.AsMask8x16())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask8x16())
+
+	default:
+		t.Errorf("Unknown method: Int8x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt8x16Compare(t *testing.T, v0 []int8, v1 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x16
+	got := make([]int8, len(want))
+	vec0 := simd.LoadInt8x16Slice(v0)
+	vec1 := simd.LoadInt8x16Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt8x16()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt8x16()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt8x16()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt8x16()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt8x16()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt8x16()
+
+	default:
+		t.Errorf("Unknown method: Int8x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt8x16MaskedCompare(t *testing.T, v0 []int8, v1 []int8, v2 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x16
+	got := make([]int8, len(want))
+	vec0 := simd.LoadInt8x16Slice(v0)
+	vec1 := simd.LoadInt8x16Slice(v1)
+	vec2 := simd.LoadInt8x16Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask8x16()).AsInt8x16()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask8x16()).AsInt8x16()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask8x16()).AsInt8x16()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask8x16()).AsInt8x16()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask8x16()).AsInt8x16()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask8x16()).AsInt8x16()
+
+	default:
+		t.Errorf("Unknown method: Int8x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt8x16Unary(t *testing.T, v0 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x16
+	got := make([]int8, len(want))
+	vec0 := simd.LoadInt8x16Slice(v0)
+	switch which {
+	case "Absolute":
+		gotv = vec0.Absolute()
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Int8x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt8x16UnaryMasked(t *testing.T, v0 []int8, v1 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x16
+	got := make([]int8, len(want))
+	vec0 := simd.LoadInt8x16Slice(v0)
+	vec1 := simd.LoadInt8x16Slice(v1)
+	switch which {
+	case "MaskedAbsolute":
+		gotv = vec0.MaskedAbsolute(vec1.AsMask8x16())
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask8x16())
+
+	default:
+		t.Errorf("Unknown method: Int8x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt8x32Binary(t *testing.T, v0 []int8, v1 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x32
+	got := make([]int8, len(want))
+	vec0 := simd.LoadInt8x32Slice(v0)
+	vec1 := simd.LoadInt8x32Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "SaturatedAdd":
+		gotv = vec0.SaturatedAdd(vec1)
+	case "SaturatedSub":
+		gotv = vec0.SaturatedSub(vec1)
+	case "Sign":
+		gotv = vec0.Sign(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Int8x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt8x32BinaryMasked(t *testing.T, v0 []int8, v1 []int8, v2 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x32
+	got := make([]int8, len(want))
+	vec0 := simd.LoadInt8x32Slice(v0)
+	vec1 := simd.LoadInt8x32Slice(v1)
+	vec2 := simd.LoadInt8x32Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask8x32())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask8x32())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask8x32())
+	case "MaskedSaturatedAdd":
+		gotv = vec0.MaskedSaturatedAdd(vec1, vec2.AsMask8x32())
+	case "MaskedSaturatedSub":
+		gotv = vec0.MaskedSaturatedSub(vec1, vec2.AsMask8x32())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask8x32())
+
+	default:
+		t.Errorf("Unknown method: Int8x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt8x32Compare(t *testing.T, v0 []int8, v1 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x32
+	got := make([]int8, len(want))
+	vec0 := simd.LoadInt8x32Slice(v0)
+	vec1 := simd.LoadInt8x32Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt8x32()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt8x32()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt8x32()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt8x32()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt8x32()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt8x32()
+
+	default:
+		t.Errorf("Unknown method: Int8x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt8x32MaskedCompare(t *testing.T, v0 []int8, v1 []int8, v2 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x32
+	got := make([]int8, len(want))
+	vec0 := simd.LoadInt8x32Slice(v0)
+	vec1 := simd.LoadInt8x32Slice(v1)
+	vec2 := simd.LoadInt8x32Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask8x32()).AsInt8x32()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask8x32()).AsInt8x32()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask8x32()).AsInt8x32()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask8x32()).AsInt8x32()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask8x32()).AsInt8x32()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask8x32()).AsInt8x32()
+
+	default:
+		t.Errorf("Unknown method: Int8x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt8x32Unary(t *testing.T, v0 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x32
+	got := make([]int8, len(want))
+	vec0 := simd.LoadInt8x32Slice(v0)
+	switch which {
+	case "Absolute":
+		gotv = vec0.Absolute()
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Int8x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt8x32UnaryMasked(t *testing.T, v0 []int8, v1 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x32
+	got := make([]int8, len(want))
+	vec0 := simd.LoadInt8x32Slice(v0)
+	vec1 := simd.LoadInt8x32Slice(v1)
+	switch which {
+	case "MaskedAbsolute":
+		gotv = vec0.MaskedAbsolute(vec1.AsMask8x32())
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask8x32())
+
+	default:
+		t.Errorf("Unknown method: Int8x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt8x64Binary(t *testing.T, v0 []int8, v1 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x64
+	got := make([]int8, len(want))
+	vec0 := simd.LoadInt8x64Slice(v0)
+	vec1 := simd.LoadInt8x64Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "SaturatedAdd":
+		gotv = vec0.SaturatedAdd(vec1)
+	case "SaturatedSub":
+		gotv = vec0.SaturatedSub(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+
+	default:
+		t.Errorf("Unknown method: Int8x64.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt8x64BinaryMasked(t *testing.T, v0 []int8, v1 []int8, v2 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x64
+	got := make([]int8, len(want))
+	vec0 := simd.LoadInt8x64Slice(v0)
+	vec1 := simd.LoadInt8x64Slice(v1)
+	vec2 := simd.LoadInt8x64Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask8x64())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask8x64())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask8x64())
+	case "MaskedSaturatedAdd":
+		gotv = vec0.MaskedSaturatedAdd(vec1, vec2.AsMask8x64())
+	case "MaskedSaturatedSub":
+		gotv = vec0.MaskedSaturatedSub(vec1, vec2.AsMask8x64())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask8x64())
+
+	default:
+		t.Errorf("Unknown method: Int8x64.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt8x64Compare(t *testing.T, v0 []int8, v1 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x64
+	got := make([]int8, len(want))
+	vec0 := simd.LoadInt8x64Slice(v0)
+	vec1 := simd.LoadInt8x64Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt8x64()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt8x64()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt8x64()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt8x64()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt8x64()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt8x64()
+
+	default:
+		t.Errorf("Unknown method: Int8x64.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt8x64MaskedCompare(t *testing.T, v0 []int8, v1 []int8, v2 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x64
+	got := make([]int8, len(want))
+	vec0 := simd.LoadInt8x64Slice(v0)
+	vec1 := simd.LoadInt8x64Slice(v1)
+	vec2 := simd.LoadInt8x64Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask8x64()).AsInt8x64()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask8x64()).AsInt8x64()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask8x64()).AsInt8x64()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask8x64()).AsInt8x64()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask8x64()).AsInt8x64()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask8x64()).AsInt8x64()
+
+	default:
+		t.Errorf("Unknown method: Int8x64.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt8x64Unary(t *testing.T, v0 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x64
+	got := make([]int8, len(want))
+	vec0 := simd.LoadInt8x64Slice(v0)
+	switch which {
+	case "Absolute":
+		gotv = vec0.Absolute()
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Int8x64.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testInt8x64UnaryMasked(t *testing.T, v0 []int8, v1 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x64
+	got := make([]int8, len(want))
+	vec0 := simd.LoadInt8x64Slice(v0)
+	vec1 := simd.LoadInt8x64Slice(v1)
+	switch which {
+	case "MaskedAbsolute":
+		gotv = vec0.MaskedAbsolute(vec1.AsMask8x64())
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask8x64())
+
+	default:
+		t.Errorf("Unknown method: Int8x64.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint16x16Binary(t *testing.T, v0 []uint16, v1 []uint16, want []uint16, which string) {
+	t.Helper()
+	var gotv simd.Uint16x16
+	got := make([]uint16, len(want))
+	vec0 := simd.LoadUint16x16Slice(v0)
+	vec1 := simd.LoadUint16x16Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Average":
+		gotv = vec0.Average(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "MulHigh":
+		gotv = vec0.MulHigh(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "PairwiseAdd":
+		gotv = vec0.PairwiseAdd(vec1)
+	case "PairwiseSub":
+		gotv = vec0.PairwiseSub(vec1)
+	case "SaturatedAdd":
+		gotv = vec0.SaturatedAdd(vec1)
+	case "SaturatedSub":
+		gotv = vec0.SaturatedSub(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Uint16x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint16x16BinaryMasked(t *testing.T, v0 []uint16, v1 []uint16, v2 []int16, want []uint16, which string) {
+	t.Helper()
+	var gotv simd.Uint16x16
+	got := make([]uint16, len(want))
+	vec0 := simd.LoadUint16x16Slice(v0)
+	vec1 := simd.LoadUint16x16Slice(v1)
+	vec2 := simd.LoadInt16x16Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask16x16())
+	case "MaskedAverage":
+		gotv = vec0.MaskedAverage(vec1, vec2.AsMask16x16())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask16x16())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask16x16())
+	case "MaskedMulHigh":
+		gotv = vec0.MaskedMulHigh(vec1, vec2.AsMask16x16())
+	case "MaskedSaturatedAdd":
+		gotv = vec0.MaskedSaturatedAdd(vec1, vec2.AsMask16x16())
+	case "MaskedSaturatedSub":
+		gotv = vec0.MaskedSaturatedSub(vec1, vec2.AsMask16x16())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask16x16())
+
+	default:
+		t.Errorf("Unknown method: Uint16x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint16x16Compare(t *testing.T, v0 []uint16, v1 []uint16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x16
+	got := make([]int16, len(want))
+	vec0 := simd.LoadUint16x16Slice(v0)
+	vec1 := simd.LoadUint16x16Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt16x16()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt16x16()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt16x16()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt16x16()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt16x16()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt16x16()
+
+	default:
+		t.Errorf("Unknown method: Uint16x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint16x16MaskedCompare(t *testing.T, v0 []uint16, v1 []uint16, v2 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x16
+	got := make([]int16, len(want))
+	vec0 := simd.LoadUint16x16Slice(v0)
+	vec1 := simd.LoadUint16x16Slice(v1)
+	vec2 := simd.LoadInt16x16Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask16x16()).AsInt16x16()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask16x16()).AsInt16x16()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask16x16()).AsInt16x16()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask16x16()).AsInt16x16()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask16x16()).AsInt16x16()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask16x16()).AsInt16x16()
+
+	default:
+		t.Errorf("Unknown method: Uint16x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint16x16Unary(t *testing.T, v0 []uint16, want []uint16, which string) {
+	t.Helper()
+	var gotv simd.Uint16x16
+	got := make([]uint16, len(want))
+	vec0 := simd.LoadUint16x16Slice(v0)
+	switch which {
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Uint16x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint16x16UnaryMasked(t *testing.T, v0 []uint16, v1 []int16, want []uint16, which string) {
+	t.Helper()
+	var gotv simd.Uint16x16
+	got := make([]uint16, len(want))
+	vec0 := simd.LoadUint16x16Slice(v0)
+	vec1 := simd.LoadInt16x16Slice(v1)
+	switch which {
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask16x16())
+
+	default:
+		t.Errorf("Unknown method: Uint16x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint16x32Binary(t *testing.T, v0 []uint16, v1 []uint16, want []uint16, which string) {
+	t.Helper()
+	var gotv simd.Uint16x32
+	got := make([]uint16, len(want))
+	vec0 := simd.LoadUint16x32Slice(v0)
+	vec1 := simd.LoadUint16x32Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "Average":
+		gotv = vec0.Average(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "MulHigh":
+		gotv = vec0.MulHigh(vec1)
+	case "SaturatedAdd":
+		gotv = vec0.SaturatedAdd(vec1)
+	case "SaturatedSub":
+		gotv = vec0.SaturatedSub(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+
+	default:
+		t.Errorf("Unknown method: Uint16x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint16x32BinaryMasked(t *testing.T, v0 []uint16, v1 []uint16, v2 []int16, want []uint16, which string) {
+	t.Helper()
+	var gotv simd.Uint16x32
+	got := make([]uint16, len(want))
+	vec0 := simd.LoadUint16x32Slice(v0)
+	vec1 := simd.LoadUint16x32Slice(v1)
+	vec2 := simd.LoadInt16x32Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask16x32())
+	case "MaskedAverage":
+		gotv = vec0.MaskedAverage(vec1, vec2.AsMask16x32())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask16x32())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask16x32())
+	case "MaskedMulHigh":
+		gotv = vec0.MaskedMulHigh(vec1, vec2.AsMask16x32())
+	case "MaskedSaturatedAdd":
+		gotv = vec0.MaskedSaturatedAdd(vec1, vec2.AsMask16x32())
+	case "MaskedSaturatedSub":
+		gotv = vec0.MaskedSaturatedSub(vec1, vec2.AsMask16x32())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask16x32())
+
+	default:
+		t.Errorf("Unknown method: Uint16x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint16x32Compare(t *testing.T, v0 []uint16, v1 []uint16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x32
+	got := make([]int16, len(want))
+	vec0 := simd.LoadUint16x32Slice(v0)
+	vec1 := simd.LoadUint16x32Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt16x32()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt16x32()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt16x32()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt16x32()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt16x32()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt16x32()
+
+	default:
+		t.Errorf("Unknown method: Uint16x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint16x32MaskedCompare(t *testing.T, v0 []uint16, v1 []uint16, v2 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x32
+	got := make([]int16, len(want))
+	vec0 := simd.LoadUint16x32Slice(v0)
+	vec1 := simd.LoadUint16x32Slice(v1)
+	vec2 := simd.LoadInt16x32Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask16x32()).AsInt16x32()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask16x32()).AsInt16x32()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask16x32()).AsInt16x32()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask16x32()).AsInt16x32()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask16x32()).AsInt16x32()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask16x32()).AsInt16x32()
+
+	default:
+		t.Errorf("Unknown method: Uint16x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint16x32Unary(t *testing.T, v0 []uint16, want []uint16, which string) {
+	t.Helper()
+	var gotv simd.Uint16x32
+	got := make([]uint16, len(want))
+	vec0 := simd.LoadUint16x32Slice(v0)
+	switch which {
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Uint16x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint16x32UnaryMasked(t *testing.T, v0 []uint16, v1 []int16, want []uint16, which string) {
+	t.Helper()
+	var gotv simd.Uint16x32
+	got := make([]uint16, len(want))
+	vec0 := simd.LoadUint16x32Slice(v0)
+	vec1 := simd.LoadInt16x32Slice(v1)
+	switch which {
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask16x32())
+
+	default:
+		t.Errorf("Unknown method: Uint16x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint16x8Binary(t *testing.T, v0 []uint16, v1 []uint16, want []uint16, which string) {
+	t.Helper()
+	var gotv simd.Uint16x8
+	got := make([]uint16, len(want))
+	vec0 := simd.LoadUint16x8Slice(v0)
+	vec1 := simd.LoadUint16x8Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Average":
+		gotv = vec0.Average(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "MulHigh":
+		gotv = vec0.MulHigh(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "PairwiseAdd":
+		gotv = vec0.PairwiseAdd(vec1)
+	case "PairwiseSub":
+		gotv = vec0.PairwiseSub(vec1)
+	case "SaturatedAdd":
+		gotv = vec0.SaturatedAdd(vec1)
+	case "SaturatedSub":
+		gotv = vec0.SaturatedSub(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Uint16x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint16x8BinaryMasked(t *testing.T, v0 []uint16, v1 []uint16, v2 []int16, want []uint16, which string) {
+	t.Helper()
+	var gotv simd.Uint16x8
+	got := make([]uint16, len(want))
+	vec0 := simd.LoadUint16x8Slice(v0)
+	vec1 := simd.LoadUint16x8Slice(v1)
+	vec2 := simd.LoadInt16x8Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask16x8())
+	case "MaskedAverage":
+		gotv = vec0.MaskedAverage(vec1, vec2.AsMask16x8())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask16x8())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask16x8())
+	case "MaskedMulHigh":
+		gotv = vec0.MaskedMulHigh(vec1, vec2.AsMask16x8())
+	case "MaskedSaturatedAdd":
+		gotv = vec0.MaskedSaturatedAdd(vec1, vec2.AsMask16x8())
+	case "MaskedSaturatedSub":
+		gotv = vec0.MaskedSaturatedSub(vec1, vec2.AsMask16x8())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask16x8())
+
+	default:
+		t.Errorf("Unknown method: Uint16x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint16x8Compare(t *testing.T, v0 []uint16, v1 []uint16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x8
+	got := make([]int16, len(want))
+	vec0 := simd.LoadUint16x8Slice(v0)
+	vec1 := simd.LoadUint16x8Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt16x8()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt16x8()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt16x8()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt16x8()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt16x8()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt16x8()
+
+	default:
+		t.Errorf("Unknown method: Uint16x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint16x8MaskedCompare(t *testing.T, v0 []uint16, v1 []uint16, v2 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x8
+	got := make([]int16, len(want))
+	vec0 := simd.LoadUint16x8Slice(v0)
+	vec1 := simd.LoadUint16x8Slice(v1)
+	vec2 := simd.LoadInt16x8Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask16x8()).AsInt16x8()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask16x8()).AsInt16x8()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask16x8()).AsInt16x8()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask16x8()).AsInt16x8()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask16x8()).AsInt16x8()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask16x8()).AsInt16x8()
+
+	default:
+		t.Errorf("Unknown method: Uint16x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint16x8Unary(t *testing.T, v0 []uint16, want []uint16, which string) {
+	t.Helper()
+	var gotv simd.Uint16x8
+	got := make([]uint16, len(want))
+	vec0 := simd.LoadUint16x8Slice(v0)
+	switch which {
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Uint16x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint16x8UnaryMasked(t *testing.T, v0 []uint16, v1 []int16, want []uint16, which string) {
+	t.Helper()
+	var gotv simd.Uint16x8
+	got := make([]uint16, len(want))
+	vec0 := simd.LoadUint16x8Slice(v0)
+	vec1 := simd.LoadInt16x8Slice(v1)
+	switch which {
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask16x8())
+
+	default:
+		t.Errorf("Unknown method: Uint16x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x16Binary(t *testing.T, v0 []uint32, v1 []uint32, want []uint32, which string) {
+	t.Helper()
+	var gotv simd.Uint32x16
+	got := make([]uint32, len(want))
+	vec0 := simd.LoadUint32x16Slice(v0)
+	vec1 := simd.LoadUint32x16Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Uint32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x16BinaryMasked(t *testing.T, v0 []uint32, v1 []uint32, v2 []int32, want []uint32, which string) {
+	t.Helper()
+	var gotv simd.Uint32x16
+	got := make([]uint32, len(want))
+	vec0 := simd.LoadUint32x16Slice(v0)
+	vec1 := simd.LoadUint32x16Slice(v1)
+	vec2 := simd.LoadInt32x16Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask32x16())
+	case "MaskedAnd":
+		gotv = vec0.MaskedAnd(vec1, vec2.AsMask32x16())
+	case "MaskedAndNot":
+		gotv = vec0.MaskedAndNot(vec1, vec2.AsMask32x16())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask32x16())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask32x16())
+	case "MaskedOr":
+		gotv = vec0.MaskedOr(vec1, vec2.AsMask32x16())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask32x16())
+	case "MaskedXor":
+		gotv = vec0.MaskedXor(vec1, vec2.AsMask32x16())
+
+	default:
+		t.Errorf("Unknown method: Uint32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x16Compare(t *testing.T, v0 []uint32, v1 []uint32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x16
+	got := make([]int32, len(want))
+	vec0 := simd.LoadUint32x16Slice(v0)
+	vec1 := simd.LoadUint32x16Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt32x16()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt32x16()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt32x16()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt32x16()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt32x16()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt32x16()
+
+	default:
+		t.Errorf("Unknown method: Uint32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x16MaskedCompare(t *testing.T, v0 []uint32, v1 []uint32, v2 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x16
+	got := make([]int32, len(want))
+	vec0 := simd.LoadUint32x16Slice(v0)
+	vec1 := simd.LoadUint32x16Slice(v1)
+	vec2 := simd.LoadInt32x16Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask32x16()).AsInt32x16()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask32x16()).AsInt32x16()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask32x16()).AsInt32x16()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask32x16()).AsInt32x16()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask32x16()).AsInt32x16()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask32x16()).AsInt32x16()
+
+	default:
+		t.Errorf("Unknown method: Uint32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x16Uint8x64Int8x64Mask32x16Uint32x16(t *testing.T, v0 []uint32, v1 []uint8, v2 []int8, v3 []int32, want []uint32, which string) {
+	t.Helper()
+	var gotv simd.Uint32x16
+	got := make([]uint32, len(want))
+	vec0 := simd.LoadUint32x16Slice(v0)
+	vec1 := simd.LoadUint8x64Slice(v1)
+	vec2 := simd.LoadInt8x64Slice(v2)
+	vec3 := simd.LoadInt32x16Slice(v3)
+	switch which {
+	case "MaskedSaturatedUnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.MaskedSaturatedUnsignedSignedQuadDotProdAccumulate(vec1, vec2, vec3.AsMask32x16())
+	case "MaskedUnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.MaskedUnsignedSignedQuadDotProdAccumulate(vec1, vec2, vec3.AsMask32x16())
+
+	default:
+		t.Errorf("Unknown method: Uint32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x16Uint8x64Int8x64Uint32x16(t *testing.T, v0 []uint32, v1 []uint8, v2 []int8, want []uint32, which string) {
+	t.Helper()
+	var gotv simd.Uint32x16
+	got := make([]uint32, len(want))
+	vec0 := simd.LoadUint32x16Slice(v0)
+	vec1 := simd.LoadUint8x64Slice(v1)
+	vec2 := simd.LoadInt8x64Slice(v2)
+	switch which {
+	case "SaturatedUnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.SaturatedUnsignedSignedQuadDotProdAccumulate(vec1, vec2)
+	case "UnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.UnsignedSignedQuadDotProdAccumulate(vec1, vec2)
+
+	default:
+		t.Errorf("Unknown method: Uint32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x16Unary(t *testing.T, v0 []uint32, want []uint32, which string) {
+	t.Helper()
+	var gotv simd.Uint32x16
+	got := make([]uint32, len(want))
+	vec0 := simd.LoadUint32x16Slice(v0)
+	switch which {
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Uint32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x16UnaryMasked(t *testing.T, v0 []uint32, v1 []int32, want []uint32, which string) {
+	t.Helper()
+	var gotv simd.Uint32x16
+	got := make([]uint32, len(want))
+	vec0 := simd.LoadUint32x16Slice(v0)
+	vec1 := simd.LoadInt32x16Slice(v1)
+	switch which {
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask32x16())
+
+	default:
+		t.Errorf("Unknown method: Uint32x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x4Binary(t *testing.T, v0 []uint32, v1 []uint32, want []uint32, which string) {
+	t.Helper()
+	var gotv simd.Uint32x4
+	got := make([]uint32, len(want))
+	vec0 := simd.LoadUint32x4Slice(v0)
+	vec1 := simd.LoadUint32x4Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "PairwiseAdd":
+		gotv = vec0.PairwiseAdd(vec1)
+	case "PairwiseSub":
+		gotv = vec0.PairwiseSub(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Uint32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x4BinaryMasked(t *testing.T, v0 []uint32, v1 []uint32, v2 []int32, want []uint32, which string) {
+	t.Helper()
+	var gotv simd.Uint32x4
+	got := make([]uint32, len(want))
+	vec0 := simd.LoadUint32x4Slice(v0)
+	vec1 := simd.LoadUint32x4Slice(v1)
+	vec2 := simd.LoadInt32x4Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask32x4())
+	case "MaskedAnd":
+		gotv = vec0.MaskedAnd(vec1, vec2.AsMask32x4())
+	case "MaskedAndNot":
+		gotv = vec0.MaskedAndNot(vec1, vec2.AsMask32x4())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask32x4())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask32x4())
+	case "MaskedOr":
+		gotv = vec0.MaskedOr(vec1, vec2.AsMask32x4())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask32x4())
+	case "MaskedXor":
+		gotv = vec0.MaskedXor(vec1, vec2.AsMask32x4())
+
+	default:
+		t.Errorf("Unknown method: Uint32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x4BinaryWiden(t *testing.T, v0 []uint32, v1 []uint32, want []uint64, which string) {
+	t.Helper()
+	var gotv simd.Uint64x2
+	got := make([]uint64, len(want))
+	vec0 := simd.LoadUint32x4Slice(v0)
+	vec1 := simd.LoadUint32x4Slice(v1)
+	switch which {
+	case "MulEvenWiden":
+		gotv = vec0.MulEvenWiden(vec1)
+
+	default:
+		t.Errorf("Unknown method: Uint32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x4Compare(t *testing.T, v0 []uint32, v1 []uint32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x4
+	got := make([]int32, len(want))
+	vec0 := simd.LoadUint32x4Slice(v0)
+	vec1 := simd.LoadUint32x4Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt32x4()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt32x4()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt32x4()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt32x4()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt32x4()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt32x4()
+
+	default:
+		t.Errorf("Unknown method: Uint32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x4MaskedCompare(t *testing.T, v0 []uint32, v1 []uint32, v2 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x4
+	got := make([]int32, len(want))
+	vec0 := simd.LoadUint32x4Slice(v0)
+	vec1 := simd.LoadUint32x4Slice(v1)
+	vec2 := simd.LoadInt32x4Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask32x4()).AsInt32x4()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask32x4()).AsInt32x4()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask32x4()).AsInt32x4()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask32x4()).AsInt32x4()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask32x4()).AsInt32x4()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask32x4()).AsInt32x4()
+
+	default:
+		t.Errorf("Unknown method: Uint32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x4Uint8x16Int8x16Mask32x4Uint32x4(t *testing.T, v0 []uint32, v1 []uint8, v2 []int8, v3 []int32, want []uint32, which string) {
+	t.Helper()
+	var gotv simd.Uint32x4
+	got := make([]uint32, len(want))
+	vec0 := simd.LoadUint32x4Slice(v0)
+	vec1 := simd.LoadUint8x16Slice(v1)
+	vec2 := simd.LoadInt8x16Slice(v2)
+	vec3 := simd.LoadInt32x4Slice(v3)
+	switch which {
+	case "MaskedSaturatedUnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.MaskedSaturatedUnsignedSignedQuadDotProdAccumulate(vec1, vec2, vec3.AsMask32x4())
+	case "MaskedUnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.MaskedUnsignedSignedQuadDotProdAccumulate(vec1, vec2, vec3.AsMask32x4())
+
+	default:
+		t.Errorf("Unknown method: Uint32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x4Uint8x16Int8x16Uint32x4(t *testing.T, v0 []uint32, v1 []uint8, v2 []int8, want []uint32, which string) {
+	t.Helper()
+	var gotv simd.Uint32x4
+	got := make([]uint32, len(want))
+	vec0 := simd.LoadUint32x4Slice(v0)
+	vec1 := simd.LoadUint8x16Slice(v1)
+	vec2 := simd.LoadInt8x16Slice(v2)
+	switch which {
+	case "SaturatedUnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.SaturatedUnsignedSignedQuadDotProdAccumulate(vec1, vec2)
+	case "UnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.UnsignedSignedQuadDotProdAccumulate(vec1, vec2)
+
+	default:
+		t.Errorf("Unknown method: Uint32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x4Unary(t *testing.T, v0 []uint32, want []uint32, which string) {
+	t.Helper()
+	var gotv simd.Uint32x4
+	got := make([]uint32, len(want))
+	vec0 := simd.LoadUint32x4Slice(v0)
+	switch which {
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Uint32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x4UnaryMasked(t *testing.T, v0 []uint32, v1 []int32, want []uint32, which string) {
+	t.Helper()
+	var gotv simd.Uint32x4
+	got := make([]uint32, len(want))
+	vec0 := simd.LoadUint32x4Slice(v0)
+	vec1 := simd.LoadInt32x4Slice(v1)
+	switch which {
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask32x4())
+
+	default:
+		t.Errorf("Unknown method: Uint32x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x8Binary(t *testing.T, v0 []uint32, v1 []uint32, want []uint32, which string) {
+	t.Helper()
+	var gotv simd.Uint32x8
+	got := make([]uint32, len(want))
+	vec0 := simd.LoadUint32x8Slice(v0)
+	vec1 := simd.LoadUint32x8Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "PairwiseAdd":
+		gotv = vec0.PairwiseAdd(vec1)
+	case "PairwiseSub":
+		gotv = vec0.PairwiseSub(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Uint32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x8BinaryMasked(t *testing.T, v0 []uint32, v1 []uint32, v2 []int32, want []uint32, which string) {
+	t.Helper()
+	var gotv simd.Uint32x8
+	got := make([]uint32, len(want))
+	vec0 := simd.LoadUint32x8Slice(v0)
+	vec1 := simd.LoadUint32x8Slice(v1)
+	vec2 := simd.LoadInt32x8Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask32x8())
+	case "MaskedAnd":
+		gotv = vec0.MaskedAnd(vec1, vec2.AsMask32x8())
+	case "MaskedAndNot":
+		gotv = vec0.MaskedAndNot(vec1, vec2.AsMask32x8())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask32x8())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask32x8())
+	case "MaskedOr":
+		gotv = vec0.MaskedOr(vec1, vec2.AsMask32x8())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask32x8())
+	case "MaskedXor":
+		gotv = vec0.MaskedXor(vec1, vec2.AsMask32x8())
+
+	default:
+		t.Errorf("Unknown method: Uint32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x8BinaryWiden(t *testing.T, v0 []uint32, v1 []uint32, want []uint64, which string) {
+	t.Helper()
+	var gotv simd.Uint64x4
+	got := make([]uint64, len(want))
+	vec0 := simd.LoadUint32x8Slice(v0)
+	vec1 := simd.LoadUint32x8Slice(v1)
+	switch which {
+	case "MulEvenWiden":
+		gotv = vec0.MulEvenWiden(vec1)
+
+	default:
+		t.Errorf("Unknown method: Uint32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x8Compare(t *testing.T, v0 []uint32, v1 []uint32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x8
+	got := make([]int32, len(want))
+	vec0 := simd.LoadUint32x8Slice(v0)
+	vec1 := simd.LoadUint32x8Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt32x8()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt32x8()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt32x8()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt32x8()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt32x8()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt32x8()
+
+	default:
+		t.Errorf("Unknown method: Uint32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x8MaskedCompare(t *testing.T, v0 []uint32, v1 []uint32, v2 []int32, want []int32, which string) {
+	t.Helper()
+	var gotv simd.Int32x8
+	got := make([]int32, len(want))
+	vec0 := simd.LoadUint32x8Slice(v0)
+	vec1 := simd.LoadUint32x8Slice(v1)
+	vec2 := simd.LoadInt32x8Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask32x8()).AsInt32x8()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask32x8()).AsInt32x8()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask32x8()).AsInt32x8()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask32x8()).AsInt32x8()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask32x8()).AsInt32x8()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask32x8()).AsInt32x8()
+
+	default:
+		t.Errorf("Unknown method: Uint32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x8Uint8x32Int8x32Mask32x8Uint32x8(t *testing.T, v0 []uint32, v1 []uint8, v2 []int8, v3 []int32, want []uint32, which string) {
+	t.Helper()
+	var gotv simd.Uint32x8
+	got := make([]uint32, len(want))
+	vec0 := simd.LoadUint32x8Slice(v0)
+	vec1 := simd.LoadUint8x32Slice(v1)
+	vec2 := simd.LoadInt8x32Slice(v2)
+	vec3 := simd.LoadInt32x8Slice(v3)
+	switch which {
+	case "MaskedSaturatedUnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.MaskedSaturatedUnsignedSignedQuadDotProdAccumulate(vec1, vec2, vec3.AsMask32x8())
+	case "MaskedUnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.MaskedUnsignedSignedQuadDotProdAccumulate(vec1, vec2, vec3.AsMask32x8())
+
+	default:
+		t.Errorf("Unknown method: Uint32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x8Uint8x32Int8x32Uint32x8(t *testing.T, v0 []uint32, v1 []uint8, v2 []int8, want []uint32, which string) {
+	t.Helper()
+	var gotv simd.Uint32x8
+	got := make([]uint32, len(want))
+	vec0 := simd.LoadUint32x8Slice(v0)
+	vec1 := simd.LoadUint8x32Slice(v1)
+	vec2 := simd.LoadInt8x32Slice(v2)
+	switch which {
+	case "SaturatedUnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.SaturatedUnsignedSignedQuadDotProdAccumulate(vec1, vec2)
+	case "UnsignedSignedQuadDotProdAccumulate":
+		gotv = vec0.UnsignedSignedQuadDotProdAccumulate(vec1, vec2)
+
+	default:
+		t.Errorf("Unknown method: Uint32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x8Unary(t *testing.T, v0 []uint32, want []uint32, which string) {
+	t.Helper()
+	var gotv simd.Uint32x8
+	got := make([]uint32, len(want))
+	vec0 := simd.LoadUint32x8Slice(v0)
+	switch which {
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Uint32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint32x8UnaryMasked(t *testing.T, v0 []uint32, v1 []int32, want []uint32, which string) {
+	t.Helper()
+	var gotv simd.Uint32x8
+	got := make([]uint32, len(want))
+	vec0 := simd.LoadUint32x8Slice(v0)
+	vec1 := simd.LoadInt32x8Slice(v1)
+	switch which {
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask32x8())
+
+	default:
+		t.Errorf("Unknown method: Uint32x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint64x2Binary(t *testing.T, v0 []uint64, v1 []uint64, want []uint64, which string) {
+	t.Helper()
+	var gotv simd.Uint64x2
+	got := make([]uint64, len(want))
+	vec0 := simd.LoadUint64x2Slice(v0)
+	vec1 := simd.LoadUint64x2Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "MulEvenWiden":
+		gotv = vec0.MulEvenWiden(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Uint64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint64x2BinaryMasked(t *testing.T, v0 []uint64, v1 []uint64, v2 []int64, want []uint64, which string) {
+	t.Helper()
+	var gotv simd.Uint64x2
+	got := make([]uint64, len(want))
+	vec0 := simd.LoadUint64x2Slice(v0)
+	vec1 := simd.LoadUint64x2Slice(v1)
+	vec2 := simd.LoadInt64x2Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask64x2())
+	case "MaskedAnd":
+		gotv = vec0.MaskedAnd(vec1, vec2.AsMask64x2())
+	case "MaskedAndNot":
+		gotv = vec0.MaskedAndNot(vec1, vec2.AsMask64x2())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask64x2())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask64x2())
+	case "MaskedMulEvenWiden":
+		gotv = vec0.MaskedMulEvenWiden(vec1, vec2.AsMask64x2())
+	case "MaskedOr":
+		gotv = vec0.MaskedOr(vec1, vec2.AsMask64x2())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask64x2())
+	case "MaskedXor":
+		gotv = vec0.MaskedXor(vec1, vec2.AsMask64x2())
+
+	default:
+		t.Errorf("Unknown method: Uint64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint64x2Compare(t *testing.T, v0 []uint64, v1 []uint64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x2
+	got := make([]int64, len(want))
+	vec0 := simd.LoadUint64x2Slice(v0)
+	vec1 := simd.LoadUint64x2Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt64x2()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt64x2()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt64x2()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt64x2()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt64x2()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt64x2()
+
+	default:
+		t.Errorf("Unknown method: Uint64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint64x2MaskedCompare(t *testing.T, v0 []uint64, v1 []uint64, v2 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x2
+	got := make([]int64, len(want))
+	vec0 := simd.LoadUint64x2Slice(v0)
+	vec1 := simd.LoadUint64x2Slice(v1)
+	vec2 := simd.LoadInt64x2Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask64x2()).AsInt64x2()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask64x2()).AsInt64x2()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask64x2()).AsInt64x2()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask64x2()).AsInt64x2()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask64x2()).AsInt64x2()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask64x2()).AsInt64x2()
+
+	default:
+		t.Errorf("Unknown method: Uint64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint64x2Unary(t *testing.T, v0 []uint64, want []uint64, which string) {
+	t.Helper()
+	var gotv simd.Uint64x2
+	got := make([]uint64, len(want))
+	vec0 := simd.LoadUint64x2Slice(v0)
+	switch which {
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Uint64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint64x2UnaryMasked(t *testing.T, v0 []uint64, v1 []int64, want []uint64, which string) {
+	t.Helper()
+	var gotv simd.Uint64x2
+	got := make([]uint64, len(want))
+	vec0 := simd.LoadUint64x2Slice(v0)
+	vec1 := simd.LoadInt64x2Slice(v1)
+	switch which {
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask64x2())
+
+	default:
+		t.Errorf("Unknown method: Uint64x2.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint64x4Binary(t *testing.T, v0 []uint64, v1 []uint64, want []uint64, which string) {
+	t.Helper()
+	var gotv simd.Uint64x4
+	got := make([]uint64, len(want))
+	vec0 := simd.LoadUint64x4Slice(v0)
+	vec1 := simd.LoadUint64x4Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "MulEvenWiden":
+		gotv = vec0.MulEvenWiden(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Uint64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint64x4BinaryMasked(t *testing.T, v0 []uint64, v1 []uint64, v2 []int64, want []uint64, which string) {
+	t.Helper()
+	var gotv simd.Uint64x4
+	got := make([]uint64, len(want))
+	vec0 := simd.LoadUint64x4Slice(v0)
+	vec1 := simd.LoadUint64x4Slice(v1)
+	vec2 := simd.LoadInt64x4Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask64x4())
+	case "MaskedAnd":
+		gotv = vec0.MaskedAnd(vec1, vec2.AsMask64x4())
+	case "MaskedAndNot":
+		gotv = vec0.MaskedAndNot(vec1, vec2.AsMask64x4())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask64x4())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask64x4())
+	case "MaskedMulEvenWiden":
+		gotv = vec0.MaskedMulEvenWiden(vec1, vec2.AsMask64x4())
+	case "MaskedOr":
+		gotv = vec0.MaskedOr(vec1, vec2.AsMask64x4())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask64x4())
+	case "MaskedXor":
+		gotv = vec0.MaskedXor(vec1, vec2.AsMask64x4())
+
+	default:
+		t.Errorf("Unknown method: Uint64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint64x4Compare(t *testing.T, v0 []uint64, v1 []uint64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x4
+	got := make([]int64, len(want))
+	vec0 := simd.LoadUint64x4Slice(v0)
+	vec1 := simd.LoadUint64x4Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt64x4()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt64x4()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt64x4()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt64x4()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt64x4()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt64x4()
+
+	default:
+		t.Errorf("Unknown method: Uint64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint64x4MaskedCompare(t *testing.T, v0 []uint64, v1 []uint64, v2 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x4
+	got := make([]int64, len(want))
+	vec0 := simd.LoadUint64x4Slice(v0)
+	vec1 := simd.LoadUint64x4Slice(v1)
+	vec2 := simd.LoadInt64x4Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask64x4()).AsInt64x4()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask64x4()).AsInt64x4()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask64x4()).AsInt64x4()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask64x4()).AsInt64x4()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask64x4()).AsInt64x4()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask64x4()).AsInt64x4()
+
+	default:
+		t.Errorf("Unknown method: Uint64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint64x4Unary(t *testing.T, v0 []uint64, want []uint64, which string) {
+	t.Helper()
+	var gotv simd.Uint64x4
+	got := make([]uint64, len(want))
+	vec0 := simd.LoadUint64x4Slice(v0)
+	switch which {
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Uint64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint64x4UnaryMasked(t *testing.T, v0 []uint64, v1 []int64, want []uint64, which string) {
+	t.Helper()
+	var gotv simd.Uint64x4
+	got := make([]uint64, len(want))
+	vec0 := simd.LoadUint64x4Slice(v0)
+	vec1 := simd.LoadInt64x4Slice(v1)
+	switch which {
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask64x4())
+
+	default:
+		t.Errorf("Unknown method: Uint64x4.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint64x8Binary(t *testing.T, v0 []uint64, v1 []uint64, want []uint64, which string) {
+	t.Helper()
+	var gotv simd.Uint64x8
+	got := make([]uint64, len(want))
+	vec0 := simd.LoadUint64x8Slice(v0)
+	vec1 := simd.LoadUint64x8Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "MulEvenWiden":
+		gotv = vec0.MulEvenWiden(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Uint64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint64x8BinaryMasked(t *testing.T, v0 []uint64, v1 []uint64, v2 []int64, want []uint64, which string) {
+	t.Helper()
+	var gotv simd.Uint64x8
+	got := make([]uint64, len(want))
+	vec0 := simd.LoadUint64x8Slice(v0)
+	vec1 := simd.LoadUint64x8Slice(v1)
+	vec2 := simd.LoadInt64x8Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask64x8())
+	case "MaskedAnd":
+		gotv = vec0.MaskedAnd(vec1, vec2.AsMask64x8())
+	case "MaskedAndNot":
+		gotv = vec0.MaskedAndNot(vec1, vec2.AsMask64x8())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask64x8())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask64x8())
+	case "MaskedMulEvenWiden":
+		gotv = vec0.MaskedMulEvenWiden(vec1, vec2.AsMask64x8())
+	case "MaskedOr":
+		gotv = vec0.MaskedOr(vec1, vec2.AsMask64x8())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask64x8())
+	case "MaskedXor":
+		gotv = vec0.MaskedXor(vec1, vec2.AsMask64x8())
+
+	default:
+		t.Errorf("Unknown method: Uint64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint64x8Compare(t *testing.T, v0 []uint64, v1 []uint64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x8
+	got := make([]int64, len(want))
+	vec0 := simd.LoadUint64x8Slice(v0)
+	vec1 := simd.LoadUint64x8Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt64x8()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt64x8()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt64x8()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt64x8()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt64x8()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt64x8()
+
+	default:
+		t.Errorf("Unknown method: Uint64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint64x8MaskedCompare(t *testing.T, v0 []uint64, v1 []uint64, v2 []int64, want []int64, which string) {
+	t.Helper()
+	var gotv simd.Int64x8
+	got := make([]int64, len(want))
+	vec0 := simd.LoadUint64x8Slice(v0)
+	vec1 := simd.LoadUint64x8Slice(v1)
+	vec2 := simd.LoadInt64x8Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask64x8()).AsInt64x8()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask64x8()).AsInt64x8()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask64x8()).AsInt64x8()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask64x8()).AsInt64x8()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask64x8()).AsInt64x8()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask64x8()).AsInt64x8()
+
+	default:
+		t.Errorf("Unknown method: Uint64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint64x8Unary(t *testing.T, v0 []uint64, want []uint64, which string) {
+	t.Helper()
+	var gotv simd.Uint64x8
+	got := make([]uint64, len(want))
+	vec0 := simd.LoadUint64x8Slice(v0)
+	switch which {
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Uint64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint64x8UnaryMasked(t *testing.T, v0 []uint64, v1 []int64, want []uint64, which string) {
+	t.Helper()
+	var gotv simd.Uint64x8
+	got := make([]uint64, len(want))
+	vec0 := simd.LoadUint64x8Slice(v0)
+	vec1 := simd.LoadInt64x8Slice(v1)
+	switch which {
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask64x8())
+
+	default:
+		t.Errorf("Unknown method: Uint64x8.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x16Binary(t *testing.T, v0 []uint8, v1 []uint8, want []uint8, which string) {
+	t.Helper()
+	var gotv simd.Uint8x16
+	got := make([]uint8, len(want))
+	vec0 := simd.LoadUint8x16Slice(v0)
+	vec1 := simd.LoadUint8x16Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Average":
+		gotv = vec0.Average(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "SaturatedAdd":
+		gotv = vec0.SaturatedAdd(vec1)
+	case "SaturatedSub":
+		gotv = vec0.SaturatedSub(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Uint8x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x16BinaryMasked(t *testing.T, v0 []uint8, v1 []uint8, v2 []int8, want []uint8, which string) {
+	t.Helper()
+	var gotv simd.Uint8x16
+	got := make([]uint8, len(want))
+	vec0 := simd.LoadUint8x16Slice(v0)
+	vec1 := simd.LoadUint8x16Slice(v1)
+	vec2 := simd.LoadInt8x16Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask8x16())
+	case "MaskedAverage":
+		gotv = vec0.MaskedAverage(vec1, vec2.AsMask8x16())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask8x16())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask8x16())
+	case "MaskedSaturatedAdd":
+		gotv = vec0.MaskedSaturatedAdd(vec1, vec2.AsMask8x16())
+	case "MaskedSaturatedSub":
+		gotv = vec0.MaskedSaturatedSub(vec1, vec2.AsMask8x16())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask8x16())
+
+	default:
+		t.Errorf("Unknown method: Uint8x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x16Compare(t *testing.T, v0 []uint8, v1 []uint8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x16
+	got := make([]int8, len(want))
+	vec0 := simd.LoadUint8x16Slice(v0)
+	vec1 := simd.LoadUint8x16Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt8x16()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt8x16()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt8x16()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt8x16()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt8x16()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt8x16()
+
+	default:
+		t.Errorf("Unknown method: Uint8x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x16Int8x16Int16x8(t *testing.T, v0 []uint8, v1 []int8, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x8
+	got := make([]int16, len(want))
+	vec0 := simd.LoadUint8x16Slice(v0)
+	vec1 := simd.LoadInt8x16Slice(v1)
+	switch which {
+	case "SaturatedUnsignedSignedPairDotProd":
+		gotv = vec0.SaturatedUnsignedSignedPairDotProd(vec1)
+
+	default:
+		t.Errorf("Unknown method: Uint8x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x16Int8x16Mask16x8Int16x8(t *testing.T, v0 []uint8, v1 []int8, v2 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x8
+	got := make([]int16, len(want))
+	vec0 := simd.LoadUint8x16Slice(v0)
+	vec1 := simd.LoadInt8x16Slice(v1)
+	vec2 := simd.LoadInt16x8Slice(v2)
+	switch which {
+	case "MaskedSaturatedUnsignedSignedPairDotProd":
+		gotv = vec0.MaskedSaturatedUnsignedSignedPairDotProd(vec1, vec2.AsMask16x8())
+
+	default:
+		t.Errorf("Unknown method: Uint8x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x16MaskedCompare(t *testing.T, v0 []uint8, v1 []uint8, v2 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x16
+	got := make([]int8, len(want))
+	vec0 := simd.LoadUint8x16Slice(v0)
+	vec1 := simd.LoadUint8x16Slice(v1)
+	vec2 := simd.LoadInt8x16Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask8x16()).AsInt8x16()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask8x16()).AsInt8x16()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask8x16()).AsInt8x16()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask8x16()).AsInt8x16()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask8x16()).AsInt8x16()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask8x16()).AsInt8x16()
+
+	default:
+		t.Errorf("Unknown method: Uint8x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x16Unary(t *testing.T, v0 []uint8, want []uint8, which string) {
+	t.Helper()
+	var gotv simd.Uint8x16
+	got := make([]uint8, len(want))
+	vec0 := simd.LoadUint8x16Slice(v0)
+	switch which {
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Uint8x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x16UnaryMasked(t *testing.T, v0 []uint8, v1 []int8, want []uint8, which string) {
+	t.Helper()
+	var gotv simd.Uint8x16
+	got := make([]uint8, len(want))
+	vec0 := simd.LoadUint8x16Slice(v0)
+	vec1 := simd.LoadInt8x16Slice(v1)
+	switch which {
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask8x16())
+
+	default:
+		t.Errorf("Unknown method: Uint8x16.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x32Binary(t *testing.T, v0 []uint8, v1 []uint8, want []uint8, which string) {
+	t.Helper()
+	var gotv simd.Uint8x32
+	got := make([]uint8, len(want))
+	vec0 := simd.LoadUint8x32Slice(v0)
+	vec1 := simd.LoadUint8x32Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "And":
+		gotv = vec0.And(vec1)
+	case "AndNot":
+		gotv = vec0.AndNot(vec1)
+	case "Average":
+		gotv = vec0.Average(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "Or":
+		gotv = vec0.Or(vec1)
+	case "SaturatedAdd":
+		gotv = vec0.SaturatedAdd(vec1)
+	case "SaturatedSub":
+		gotv = vec0.SaturatedSub(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+	case "Xor":
+		gotv = vec0.Xor(vec1)
+
+	default:
+		t.Errorf("Unknown method: Uint8x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x32BinaryMasked(t *testing.T, v0 []uint8, v1 []uint8, v2 []int8, want []uint8, which string) {
+	t.Helper()
+	var gotv simd.Uint8x32
+	got := make([]uint8, len(want))
+	vec0 := simd.LoadUint8x32Slice(v0)
+	vec1 := simd.LoadUint8x32Slice(v1)
+	vec2 := simd.LoadInt8x32Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask8x32())
+	case "MaskedAverage":
+		gotv = vec0.MaskedAverage(vec1, vec2.AsMask8x32())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask8x32())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask8x32())
+	case "MaskedSaturatedAdd":
+		gotv = vec0.MaskedSaturatedAdd(vec1, vec2.AsMask8x32())
+	case "MaskedSaturatedSub":
+		gotv = vec0.MaskedSaturatedSub(vec1, vec2.AsMask8x32())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask8x32())
+
+	default:
+		t.Errorf("Unknown method: Uint8x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x32Compare(t *testing.T, v0 []uint8, v1 []uint8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x32
+	got := make([]int8, len(want))
+	vec0 := simd.LoadUint8x32Slice(v0)
+	vec1 := simd.LoadUint8x32Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt8x32()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt8x32()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt8x32()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt8x32()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt8x32()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt8x32()
+
+	default:
+		t.Errorf("Unknown method: Uint8x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x32Int8x32Int16x16(t *testing.T, v0 []uint8, v1 []int8, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x16
+	got := make([]int16, len(want))
+	vec0 := simd.LoadUint8x32Slice(v0)
+	vec1 := simd.LoadInt8x32Slice(v1)
+	switch which {
+	case "SaturatedUnsignedSignedPairDotProd":
+		gotv = vec0.SaturatedUnsignedSignedPairDotProd(vec1)
+
+	default:
+		t.Errorf("Unknown method: Uint8x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x32Int8x32Mask16x16Int16x16(t *testing.T, v0 []uint8, v1 []int8, v2 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x16
+	got := make([]int16, len(want))
+	vec0 := simd.LoadUint8x32Slice(v0)
+	vec1 := simd.LoadInt8x32Slice(v1)
+	vec2 := simd.LoadInt16x16Slice(v2)
+	switch which {
+	case "MaskedSaturatedUnsignedSignedPairDotProd":
+		gotv = vec0.MaskedSaturatedUnsignedSignedPairDotProd(vec1, vec2.AsMask16x16())
+
+	default:
+		t.Errorf("Unknown method: Uint8x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x32MaskedCompare(t *testing.T, v0 []uint8, v1 []uint8, v2 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x32
+	got := make([]int8, len(want))
+	vec0 := simd.LoadUint8x32Slice(v0)
+	vec1 := simd.LoadUint8x32Slice(v1)
+	vec2 := simd.LoadInt8x32Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask8x32()).AsInt8x32()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask8x32()).AsInt8x32()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask8x32()).AsInt8x32()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask8x32()).AsInt8x32()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask8x32()).AsInt8x32()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask8x32()).AsInt8x32()
+
+	default:
+		t.Errorf("Unknown method: Uint8x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x32Unary(t *testing.T, v0 []uint8, want []uint8, which string) {
+	t.Helper()
+	var gotv simd.Uint8x32
+	got := make([]uint8, len(want))
+	vec0 := simd.LoadUint8x32Slice(v0)
+	switch which {
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Uint8x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x32UnaryMasked(t *testing.T, v0 []uint8, v1 []int8, want []uint8, which string) {
+	t.Helper()
+	var gotv simd.Uint8x32
+	got := make([]uint8, len(want))
+	vec0 := simd.LoadUint8x32Slice(v0)
+	vec1 := simd.LoadInt8x32Slice(v1)
+	switch which {
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask8x32())
+
+	default:
+		t.Errorf("Unknown method: Uint8x32.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x64Binary(t *testing.T, v0 []uint8, v1 []uint8, want []uint8, which string) {
+	t.Helper()
+	var gotv simd.Uint8x64
+	got := make([]uint8, len(want))
+	vec0 := simd.LoadUint8x64Slice(v0)
+	vec1 := simd.LoadUint8x64Slice(v1)
+	switch which {
+	case "Add":
+		gotv = vec0.Add(vec1)
+	case "Average":
+		gotv = vec0.Average(vec1)
+	case "Max":
+		gotv = vec0.Max(vec1)
+	case "Min":
+		gotv = vec0.Min(vec1)
+	case "SaturatedAdd":
+		gotv = vec0.SaturatedAdd(vec1)
+	case "SaturatedSub":
+		gotv = vec0.SaturatedSub(vec1)
+	case "Sub":
+		gotv = vec0.Sub(vec1)
+
+	default:
+		t.Errorf("Unknown method: Uint8x64.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x64BinaryMasked(t *testing.T, v0 []uint8, v1 []uint8, v2 []int8, want []uint8, which string) {
+	t.Helper()
+	var gotv simd.Uint8x64
+	got := make([]uint8, len(want))
+	vec0 := simd.LoadUint8x64Slice(v0)
+	vec1 := simd.LoadUint8x64Slice(v1)
+	vec2 := simd.LoadInt8x64Slice(v2)
+	switch which {
+	case "MaskedAdd":
+		gotv = vec0.MaskedAdd(vec1, vec2.AsMask8x64())
+	case "MaskedAverage":
+		gotv = vec0.MaskedAverage(vec1, vec2.AsMask8x64())
+	case "MaskedMax":
+		gotv = vec0.MaskedMax(vec1, vec2.AsMask8x64())
+	case "MaskedMin":
+		gotv = vec0.MaskedMin(vec1, vec2.AsMask8x64())
+	case "MaskedSaturatedAdd":
+		gotv = vec0.MaskedSaturatedAdd(vec1, vec2.AsMask8x64())
+	case "MaskedSaturatedSub":
+		gotv = vec0.MaskedSaturatedSub(vec1, vec2.AsMask8x64())
+	case "MaskedSub":
+		gotv = vec0.MaskedSub(vec1, vec2.AsMask8x64())
+
+	default:
+		t.Errorf("Unknown method: Uint8x64.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x64Compare(t *testing.T, v0 []uint8, v1 []uint8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x64
+	got := make([]int8, len(want))
+	vec0 := simd.LoadUint8x64Slice(v0)
+	vec1 := simd.LoadUint8x64Slice(v1)
+	switch which {
+	case "Equal":
+		gotv = vec0.Equal(vec1).AsInt8x64()
+	case "Greater":
+		gotv = vec0.Greater(vec1).AsInt8x64()
+	case "GreaterEqual":
+		gotv = vec0.GreaterEqual(vec1).AsInt8x64()
+	case "Less":
+		gotv = vec0.Less(vec1).AsInt8x64()
+	case "LessEqual":
+		gotv = vec0.LessEqual(vec1).AsInt8x64()
+	case "NotEqual":
+		gotv = vec0.NotEqual(vec1).AsInt8x64()
+
+	default:
+		t.Errorf("Unknown method: Uint8x64.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x64Int8x64Int16x32(t *testing.T, v0 []uint8, v1 []int8, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x32
+	got := make([]int16, len(want))
+	vec0 := simd.LoadUint8x64Slice(v0)
+	vec1 := simd.LoadInt8x64Slice(v1)
+	switch which {
+	case "SaturatedUnsignedSignedPairDotProd":
+		gotv = vec0.SaturatedUnsignedSignedPairDotProd(vec1)
+
+	default:
+		t.Errorf("Unknown method: Uint8x64.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x64Int8x64Mask16x32Int16x32(t *testing.T, v0 []uint8, v1 []int8, v2 []int16, want []int16, which string) {
+	t.Helper()
+	var gotv simd.Int16x32
+	got := make([]int16, len(want))
+	vec0 := simd.LoadUint8x64Slice(v0)
+	vec1 := simd.LoadInt8x64Slice(v1)
+	vec2 := simd.LoadInt16x32Slice(v2)
+	switch which {
+	case "MaskedSaturatedUnsignedSignedPairDotProd":
+		gotv = vec0.MaskedSaturatedUnsignedSignedPairDotProd(vec1, vec2.AsMask16x32())
+
+	default:
+		t.Errorf("Unknown method: Uint8x64.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x64MaskedCompare(t *testing.T, v0 []uint8, v1 []uint8, v2 []int8, want []int8, which string) {
+	t.Helper()
+	var gotv simd.Int8x64
+	got := make([]int8, len(want))
+	vec0 := simd.LoadUint8x64Slice(v0)
+	vec1 := simd.LoadUint8x64Slice(v1)
+	vec2 := simd.LoadInt8x64Slice(v2)
+	switch which {
+	case "MaskedEqual":
+		gotv = vec0.MaskedEqual(vec1, vec2.AsMask8x64()).AsInt8x64()
+	case "MaskedGreater":
+		gotv = vec0.MaskedGreater(vec1, vec2.AsMask8x64()).AsInt8x64()
+	case "MaskedGreaterEqual":
+		gotv = vec0.MaskedGreaterEqual(vec1, vec2.AsMask8x64()).AsInt8x64()
+	case "MaskedLess":
+		gotv = vec0.MaskedLess(vec1, vec2.AsMask8x64()).AsInt8x64()
+	case "MaskedLessEqual":
+		gotv = vec0.MaskedLessEqual(vec1, vec2.AsMask8x64()).AsInt8x64()
+	case "MaskedNotEqual":
+		gotv = vec0.MaskedNotEqual(vec1, vec2.AsMask8x64()).AsInt8x64()
+
+	default:
+		t.Errorf("Unknown method: Uint8x64.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x64Unary(t *testing.T, v0 []uint8, want []uint8, which string) {
+	t.Helper()
+	var gotv simd.Uint8x64
+	got := make([]uint8, len(want))
+	vec0 := simd.LoadUint8x64Slice(v0)
+	switch which {
+	case "PopCount":
+		gotv = vec0.PopCount()
+
+	default:
+		t.Errorf("Unknown method: Uint8x64.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
+
+func testUint8x64UnaryMasked(t *testing.T, v0 []uint8, v1 []int8, want []uint8, which string) {
+	t.Helper()
+	var gotv simd.Uint8x64
+	got := make([]uint8, len(want))
+	vec0 := simd.LoadUint8x64Slice(v0)
+	vec1 := simd.LoadInt8x64Slice(v1)
+	switch which {
+	case "MaskedPopCount":
+		gotv = vec0.MaskedPopCount(vec1.AsMask8x64())
+
+	default:
+		t.Errorf("Unknown method: Uint8x64.%s", which)
+	}
+	gotv.StoreSlice(got)
+	for i := range len(want) {
+		if got[i] != want[i] {
+			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
+		}
+	}
+}
diff --git a/src/simd/stubs_amd64.go b/src/simd/stubs_amd64.go
index aeb8c6bda7..ceccf1cf61 100644
--- a/src/simd/stubs_amd64.go
+++ b/src/simd/stubs_amd64.go
@@ -7244,42 +7244,42 @@ func (x Uint32x16) SaturatedUnsignedSignedQuadDotProdAccumulate(y Uint8x64, z In
 
 /* SetElem */
 
-// SetElem sets a single constant-indexed element's value
+// SetElem sets a single constant-indexed element's value.
 //
 // Asm: VPINSRB, CPU Feature: AVX
 func (x Int8x16) SetElem(imm uint8, y int8) Int8x16
 
-// SetElem sets a single constant-indexed element's value
+// SetElem sets a single constant-indexed element's value.
 //
 // Asm: VPINSRW, CPU Feature: AVX
 func (x Int16x8) SetElem(imm uint8, y int16) Int16x8
 
-// SetElem sets a single constant-indexed element's value
+// SetElem sets a single constant-indexed element's value.
 //
 // Asm: VPINSRD, CPU Feature: AVX
 func (x Int32x4) SetElem(imm uint8, y int8) Int32x4
 
-// SetElem sets a single constant-indexed element's value
+// SetElem sets a single constant-indexed element's value.
 //
 // Asm: VPINSRQ, CPU Feature: AVX
 func (x Int64x2) SetElem(imm uint8, y int64) Int64x2
 
-// SetElem sets a single constant-indexed element's value
+// SetElem sets a single constant-indexed element's value.
 //
 // Asm: VPINSRB, CPU Feature: AVX
 func (x Uint8x16) SetElem(imm uint8, y uint8) Uint8x16
 
-// SetElem sets a single constant-indexed element's value
+// SetElem sets a single constant-indexed element's value.
 //
 // Asm: VPINSRW, CPU Feature: AVX
 func (x Uint16x8) SetElem(imm uint8, y uint16) Uint16x8
 
-// SetElem sets a single constant-indexed element's value
+// SetElem sets a single constant-indexed element's value.
 //
 // Asm: VPINSRD, CPU Feature: AVX
 func (x Uint32x4) SetElem(imm uint8, y uint8) Uint32x4
 
-// SetElem sets a single constant-indexed element's value
+// SetElem sets a single constant-indexed element's value.
 //
 // Asm: VPINSRQ, CPU Feature: AVX
 func (x Uint64x2) SetElem(imm uint8, y uint64) Uint64x2
