commit 48151b3f0ffda8a38ca71c8f1b8a72d5f90d7061
Author: Cherry Zhang <cherryyz@google.com>
Date:   Tue Sep 24 18:12:55 2019 -0400

    [dev.link] cmd/link: add symbols to Textp after deadcode pass
    
    Currently we add all text symbols to ctxt.Textp at load time,
    then the deadcode pass filters out unreachable ones. This CL
    delays adding symbols to ctxt.Textp to the end of the deadcode
    pass, where we only add reachable ones.
    
    Change-Id: Ie83b2958f915c5aaa004b8c5ed1f1bc275f4d1db
    Reviewed-on: https://go-review.googlesource.com/c/go/+/197257
    Run-TryBot: Cherry Zhang <cherryyz@google.com>
    TryBot-Result: Gobot Gobot <gobot@golang.org>
    Reviewed-by: Than McIntosh <thanm@google.com>
---
 src/cmd/link/internal/ld/deadcode.go | 62 ++++++++++++++++++++++++++++++------
 src/cmd/link/internal/ld/lib.go      | 38 ----------------------
 2 files changed, 53 insertions(+), 47 deletions(-)

diff --git a/src/cmd/link/internal/ld/deadcode.go b/src/cmd/link/internal/ld/deadcode.go
index c880c0da01..cadb92b43c 100644
--- a/src/cmd/link/internal/ld/deadcode.go
+++ b/src/cmd/link/internal/ld/deadcode.go
@@ -118,22 +118,66 @@ func deadcode(ctxt *Link) {
 		}
 	}
 
-	for _, lib := range ctxt.Library {
-		lib.Textp = lib.Textp[:0]
-	}
-
 	// Remove dead text but keep file information (z symbols).
-	textp := make([]*sym.Symbol, 0, len(ctxt.Textp))
+	textp := []*sym.Symbol{}
 	for _, s := range ctxt.Textp {
 		if s.Attr.Reachable() {
-			if s.Unit != nil {
-				s.Unit.Lib.Textp = append(s.Unit.Lib.Textp, s)
-				s.Unit.Textp = append(s.Unit.Textp, s)
-			}
 			textp = append(textp, s)
 		}
 	}
+
+	// Put reachable text symbols into Textp.
+	// do it in postorder so that packages are laid down in dependency order
+	// internal first, then everything else
+	ctxt.Library = postorder(ctxt.Library)
+	for _, doInternal := range [2]bool{true, false} {
+		for _, lib := range ctxt.Library {
+			if isRuntimeDepPkg(lib.Pkg) != doInternal {
+				continue
+			}
+			libtextp := lib.Textp[:0]
+			for _, s := range lib.Textp {
+				if s.Attr.Reachable() {
+					textp = append(textp, s)
+					libtextp = append(libtextp, s)
+					if s.Unit != nil {
+						s.Unit.Textp = append(s.Unit.Textp, s)
+					}
+				}
+			}
+			for _, s := range lib.DupTextSyms {
+				if s.Attr.Reachable() && !s.Attr.OnList() {
+					textp = append(textp, s)
+					libtextp = append(libtextp, s)
+					if s.Unit != nil {
+						s.Unit.Textp = append(s.Unit.Textp, s)
+					}
+					s.Attr |= sym.AttrOnList
+					// dupok symbols may be defined in multiple packages. its
+					// associated package is chosen sort of arbitrarily (the
+					// first containing package that the linker loads). canonicalize
+					// it here to the package with which it will be laid down
+					// in text.
+					s.File = objabi.PathToPrefix(lib.Pkg)
+				}
+			}
+			lib.Textp = libtextp
+		}
+	}
 	ctxt.Textp = textp
+
+	if len(ctxt.Shlibs) > 0 {
+		// We might have overwritten some functions above (this tends to happen for the
+		// autogenerated type equality/hashing functions) and we don't want to generated
+		// pcln table entries for these any more so remove them from Textp.
+		textp := make([]*sym.Symbol, 0, len(ctxt.Textp))
+		for _, s := range ctxt.Textp {
+			if s.Type != sym.SDYNIMPORT {
+				textp = append(textp, s)
+			}
+		}
+		ctxt.Textp = textp
+	}
 }
 
 // methodref holds the relocations from a receiver type symbol to its
diff --git a/src/cmd/link/internal/ld/lib.go b/src/cmd/link/internal/ld/lib.go
index 5ab43cca70..f11adbcfb6 100644
--- a/src/cmd/link/internal/ld/lib.go
+++ b/src/cmd/link/internal/ld/lib.go
@@ -538,44 +538,6 @@ func (ctxt *Link) loadlib() {
 	}
 
 	importcycles()
-
-	// put symbols into Textp
-	// do it in postorder so that packages are laid down in dependency order
-	// internal first, then everything else
-	ctxt.Library = postorder(ctxt.Library)
-	for _, doInternal := range [2]bool{true, false} {
-		for _, lib := range ctxt.Library {
-			if isRuntimeDepPkg(lib.Pkg) != doInternal {
-				continue
-			}
-			ctxt.Textp = append(ctxt.Textp, lib.Textp...)
-			for _, s := range lib.DupTextSyms {
-				if !s.Attr.OnList() {
-					ctxt.Textp = append(ctxt.Textp, s)
-					s.Attr |= sym.AttrOnList
-					// dupok symbols may be defined in multiple packages. its
-					// associated package is chosen sort of arbitrarily (the
-					// first containing package that the linker loads). canonicalize
-					// it here to the package with which it will be laid down
-					// in text.
-					s.File = objabi.PathToPrefix(lib.Pkg)
-				}
-			}
-		}
-	}
-
-	if len(ctxt.Shlibs) > 0 {
-		// We might have overwritten some functions above (this tends to happen for the
-		// autogenerated type equality/hashing functions) and we don't want to generated
-		// pcln table entries for these any more so remove them from Textp.
-		textp := make([]*sym.Symbol, 0, len(ctxt.Textp))
-		for _, s := range ctxt.Textp {
-			if s.Type != sym.SDYNIMPORT {
-				textp = append(textp, s)
-			}
-		}
-		ctxt.Textp = textp
-	}
 }
 
 // Set up flags and special symbols depending on the platform build mode.
