commit bb91a7e2fd11a071dc32a6a65c185fbe0151145a
Author: Russ Cox <rsc@golang.org>
Date:   Wed Jan 6 12:29:10 2016 -0500

    test/bench/shootout: delete
    
    We don't use these for benchmarking anymore.
    Now we have the go1 dir and the benchmarks subrepo.
    Some have problematic copyright notices, so move out of main repo.
    
    Preserved in golang.org/x/exp/shootout.
    
    Fixes #12688.
    Fixes #13584.
    
    Change-Id: Ic0b71191ca1a286d33d7813aca94bab1617a1c82
    Reviewed-on: https://go-review.googlesource.com/18320
    Reviewed-by: Ian Lance Taylor <iant@golang.org>
---
 src/cmd/dist/test.go                          |   28 +-
 test/bench/shootout/binary-tree-freelist.go   |  129 ---
 test/bench/shootout/binary-tree-freelist.txt  |    8 -
 test/bench/shootout/binary-tree.c             |  164 ----
 test/bench/shootout/binary-tree.go            |   92 --
 test/bench/shootout/binary-tree.txt           |    8 -
 test/bench/shootout/chameneosredux.c          |  330 -------
 test/bench/shootout/chameneosredux.go         |  180 ----
 test/bench/shootout/chameneosredux.txt        |   29 -
 test/bench/shootout/fannkuch-parallel.go      |  224 -----
 test/bench/shootout/fannkuch-parallel.txt     |   31 -
 test/bench/shootout/fannkuch.c                |  134 ---
 test/bench/shootout/fannkuch.go               |  122 ---
 test/bench/shootout/fannkuch.txt              |   31 -
 test/bench/shootout/fasta-1000.txt            |  171 ----
 test/bench/shootout/fasta.c                   |  219 -----
 test/bench/shootout/fasta.go                  |  205 ----
 test/bench/shootout/fasta.txt                 |  171 ----
 test/bench/shootout/k-nucleotide-parallel.go  |  157 ----
 test/bench/shootout/k-nucleotide-parallel.txt |   27 -
 test/bench/shootout/k-nucleotide.c            |  228 -----
 test/bench/shootout/k-nucleotide.go           |  140 ---
 test/bench/shootout/k-nucleotide.txt          |   27 -
 test/bench/shootout/mandelbrot.c              |   91 --
 test/bench/shootout/mandelbrot.go             |   95 --
 test/bench/shootout/mandelbrot.txt            |  Bin 5011 -> 0 bytes
 test/bench/shootout/meteor-contest.c          |  626 ------------
 test/bench/shootout/meteor-contest.go         |  656 -------------
 test/bench/shootout/meteor-contest.txt        |   24 -
 test/bench/shootout/nbody.c                   |  170 ----
 test/bench/shootout/nbody.go                  |  177 ----
 test/bench/shootout/nbody.txt                 |    2 -
 test/bench/shootout/pidigits.c                |  123 ---
 test/bench/shootout/pidigits.go               |  135 ---
 test/bench/shootout/pidigits.txt              |    3 -
 test/bench/shootout/regex-dna-parallel.go     |  124 ---
 test/bench/shootout/regex-dna-parallel.txt    |   13 -
 test/bench/shootout/regex-dna.c               |  154 ---
 test/bench/shootout/regex-dna.go              |  106 ---
 test/bench/shootout/regex-dna.txt             |   13 -
 test/bench/shootout/reverse-complement.c      |  100 --
 test/bench/shootout/reverse-complement.go     |  105 ---
 test/bench/shootout/reverse-complement.txt    |  171 ----
 test/bench/shootout/spectral-norm-parallel.go |  111 ---
 test/bench/shootout/spectral-norm.c           |   82 --
 test/bench/shootout/spectral-norm.go          |   93 --
 test/bench/shootout/spectral-norm.txt         |    1 -
 test/bench/shootout/threadring.c              |  113 ---
 test/bench/shootout/threadring.go             |   71 --
 test/bench/shootout/threadring.txt            |    1 -
 test/bench/shootout/timing.log                | 1254 -------------------------
 test/bench/shootout/timing.sh                 |  252 -----
 52 files changed, 1 insertion(+), 7720 deletions(-)

diff --git a/src/cmd/dist/test.go b/src/cmd/dist/test.go
index eeec7e3a9d..679c23bb22 100644
--- a/src/cmd/dist/test.go
+++ b/src/cmd/dist/test.go
@@ -9,7 +9,6 @@ import (
 	"errors"
 	"flag"
 	"fmt"
-	"io/ioutil"
 	"log"
 	"os"
 	"os/exec"
@@ -502,25 +501,12 @@ func (t *tester) registerTests() {
 		}
 	}
 
-	// Doc and shootout tests only run on builders.
+	// Doc tests only run on builders.
 	// They find problems approximately never.
 	if t.hasBash() && t.goos != "nacl" && t.goos != "android" && !t.iOS() && os.Getenv("GO_BUILDER_NAME") != "" {
 		t.registerTest("doc_progs", "../doc/progs", "time", "go", "run", "run.go")
 		t.registerTest("wiki", "../doc/articles/wiki", "./test.bash")
 		t.registerTest("codewalk", "../doc/codewalk", "time", "./run")
-		for _, name := range t.shootoutTests() {
-			if name == "spectralnorm" {
-				switch os.Getenv("GO_BUILDER_NAME") {
-				case "linux-arm-arm5", "linux-mips64-minux":
-					// Heavy on floating point and takes over 20 minutes with
-					// softfloat on arm5 builder and over 33 minutes on MIPS64
-					// builder with kernel FPU emulator.
-					// Disabled per Issue 12688.
-					continue
-				}
-			}
-			t.registerSeqTest("shootout:"+name, "../test/bench/shootout", "time", "./timing.sh", "-test", name)
-		}
 	}
 
 	if t.goos != "android" && !t.iOS() {
@@ -994,18 +980,6 @@ func (t *tester) testDirTest(dt *distTest, shard, shards int) error {
 	return nil
 }
 
-func (t *tester) shootoutTests() []string {
-	sh, err := ioutil.ReadFile(filepath.Join(t.goroot, "test", "bench", "shootout", "timing.sh"))
-	if err != nil {
-		log.Fatal(err)
-	}
-	m := regexp.MustCompile(`(?m)^\s+run="([\w+ ]+)"\s*$`).FindSubmatch(sh)
-	if m == nil {
-		log.Fatal("failed to find run=\"...\" line in test/bench/shootout/timing.sh")
-	}
-	return strings.Fields(string(m[1]))
-}
-
 // mergeEnvLists merges the two environment lists such that
 // variables with the same name in "in" replace those in "out".
 // out may be mutated.
diff --git a/test/bench/shootout/binary-tree-freelist.go b/test/bench/shootout/binary-tree-freelist.go
deleted file mode 100644
index 071a4e06e7..0000000000
--- a/test/bench/shootout/binary-tree-freelist.go
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by The Go Authors.
- * based on C program by Kevin Carson
- */
-
-package main
-
-import (
-	"flag"
-	"fmt"
-)
-
-var n = flag.Int("n", 15, "depth")
-
-type Node struct {
-	item        int
-	left, right *Node
-}
-
-type Arena struct {
-	head *Node
-}
-
-var arena Arena
-
-func (n *Node) free() {
-	if n.left != nil {
-		n.left.free()
-	}
-	if n.right != nil {
-		n.right.free()
-	}
-	n.left = arena.head
-	arena.head = n
-}
-
-func (a *Arena) New(item int, left, right *Node) *Node {
-	if a.head == nil {
-		nodes := make([]Node, 3<<uint(*n))
-		for i := 0; i < len(nodes)-1; i++ {
-			nodes[i].left = &nodes[i+1]
-		}
-		a.head = &nodes[0]
-	}
-	n := a.head
-	a.head = a.head.left
-	n.item = item
-	n.left = left
-	n.right = right
-	return n
-}
-
-func bottomUpTree(item, depth int) *Node {
-	if depth <= 0 {
-		return arena.New(item, nil, nil)
-	}
-	return arena.New(item, bottomUpTree(2*item-1, depth-1), bottomUpTree(2*item, depth-1))
-}
-
-func (n *Node) itemCheck() int {
-	if n.left == nil {
-		return n.item
-	}
-	return n.item + n.left.itemCheck() - n.right.itemCheck()
-}
-
-const minDepth = 4
-
-func main() {
-	flag.Parse()
-
-	maxDepth := *n
-	if minDepth+2 > *n {
-		maxDepth = minDepth + 2
-	}
-	stretchDepth := maxDepth + 1
-
-	check := bottomUpTree(0, stretchDepth).itemCheck()
-	fmt.Printf("stretch tree of depth %d\t check: %d\n", stretchDepth, check)
-
-	longLivedTree := bottomUpTree(0, maxDepth)
-
-	for depth := minDepth; depth <= maxDepth; depth += 2 {
-		iterations := 1 << uint(maxDepth-depth+minDepth)
-		check = 0
-
-		for i := 1; i <= iterations; i++ {
-			t := bottomUpTree(i, depth)
-			check += t.itemCheck()
-			t.free()
-			t = bottomUpTree(-i, depth)
-			check += t.itemCheck()
-			t.free()
-		}
-		fmt.Printf("%d\t trees of depth %d\t check: %d\n", iterations*2, depth, check)
-	}
-	fmt.Printf("long lived tree of depth %d\t check: %d\n", maxDepth, longLivedTree.itemCheck())
-}
diff --git a/test/bench/shootout/binary-tree-freelist.txt b/test/bench/shootout/binary-tree-freelist.txt
deleted file mode 100644
index f8286dd88b..0000000000
--- a/test/bench/shootout/binary-tree-freelist.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-stretch tree of depth 16	 check: -1
-65536	 trees of depth 4	 check: -65536
-16384	 trees of depth 6	 check: -16384
-4096	 trees of depth 8	 check: -4096
-1024	 trees of depth 10	 check: -1024
-256	 trees of depth 12	 check: -256
-64	 trees of depth 14	 check: -64
-long lived tree of depth 15	 check: -1
diff --git a/test/bench/shootout/binary-tree.c b/test/bench/shootout/binary-tree.c
deleted file mode 100644
index 9c35ac52a9..0000000000
--- a/test/bench/shootout/binary-tree.c
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Shootout Benchmarks
-   http://shootout.alioth.debian.org/
-
-   contributed by Kevin Carson
-   compilation:
-       gcc -O3 -fomit-frame-pointer -funroll-loops -static binary-trees.c -lm
-       icc -O3 -ip -unroll -static binary-trees.c -lm
-*/
-
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-
-typedef struct tn {
-    struct tn*    left;
-    struct tn*    right;
-    long          item;
-} treeNode;
-
-
-treeNode* NewTreeNode(treeNode* left, treeNode* right, long item)
-{
-    treeNode*    new;
-
-    new = (treeNode*)malloc(sizeof(treeNode));
-
-    new->left = left;
-    new->right = right;
-    new->item = item;
-
-    return new;
-} /* NewTreeNode() */
-
-
-long ItemCheck(treeNode* tree)
-{
-    if (tree->left == NULL)
-        return tree->item;
-    else
-        return tree->item + ItemCheck(tree->left) - ItemCheck(tree->right);
-} /* ItemCheck() */
-
-
-treeNode* BottomUpTree(long item, unsigned depth)
-{
-    if (depth > 0)
-        return NewTreeNode
-        (
-            BottomUpTree(2 * item - 1, depth - 1),
-            BottomUpTree(2 * item, depth - 1),
-            item
-        );
-    else
-        return NewTreeNode(NULL, NULL, item);
-} /* BottomUpTree() */
-
-
-void DeleteTree(treeNode* tree)
-{
-    if (tree->left != NULL)
-    {
-        DeleteTree(tree->left);
-        DeleteTree(tree->right);
-    }
-
-    free(tree);
-} /* DeleteTree() */
-
-
-int main(int argc, char* argv[])
-{
-    unsigned   N, depth, minDepth, maxDepth, stretchDepth;
-    treeNode   *stretchTree, *longLivedTree, *tempTree;
-
-    N = atol(argv[1]);
-
-    minDepth = 4;
-
-    if ((minDepth + 2) > N)
-        maxDepth = minDepth + 2;
-    else
-        maxDepth = N;
-
-    stretchDepth = maxDepth + 1;
-
-    stretchTree = BottomUpTree(0, stretchDepth);
-    printf
-    (
-        "stretch tree of depth %u\t check: %li\n",
-        stretchDepth,
-        ItemCheck(stretchTree)
-    );
-
-    DeleteTree(stretchTree);
-
-    longLivedTree = BottomUpTree(0, maxDepth);
-
-    for (depth = minDepth; depth <= maxDepth; depth += 2)
-    {
-        long    i, iterations, check;
-
-        iterations = pow(2, maxDepth - depth + minDepth);
-
-        check = 0;
-
-        for (i = 1; i <= iterations; i++)
-        {
-            tempTree = BottomUpTree(i, depth);
-            check += ItemCheck(tempTree);
-            DeleteTree(tempTree);
-
-            tempTree = BottomUpTree(-i, depth);
-            check += ItemCheck(tempTree);
-            DeleteTree(tempTree);
-        } /* for(i = 1...) */
-
-        printf
-        (
-            "%li\t trees of depth %u\t check: %li\n",
-            iterations * 2,
-            depth,
-            check
-        );
-    } /* for(depth = minDepth...) */
-
-    printf
-    (
-        "long lived tree of depth %u\t check: %li\n",
-        maxDepth,
-        ItemCheck(longLivedTree)
-    );
-
-    return 0;
-} /* main() */
diff --git a/test/bench/shootout/binary-tree.go b/test/bench/shootout/binary-tree.go
deleted file mode 100644
index 9f867d11a7..0000000000
--- a/test/bench/shootout/binary-tree.go
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by The Go Authors.
- * based on C program by Kevin Carson
- */
-
-package main
-
-import (
-	"flag"
-	"fmt"
-)
-
-var n = flag.Int("n", 15, "depth")
-
-type Node struct {
-	item        int
-	left, right *Node
-}
-
-func bottomUpTree(item, depth int) *Node {
-	if depth <= 0 {
-		return &Node{item: item}
-	}
-	return &Node{item, bottomUpTree(2*item-1, depth-1), bottomUpTree(2*item, depth-1)}
-}
-
-func (n *Node) itemCheck() int {
-	if n.left == nil {
-		return n.item
-	}
-	return n.item + n.left.itemCheck() - n.right.itemCheck()
-}
-
-const minDepth = 4
-
-func main() {
-	flag.Parse()
-
-	maxDepth := *n
-	if minDepth+2 > *n {
-		maxDepth = minDepth + 2
-	}
-	stretchDepth := maxDepth + 1
-
-	check := bottomUpTree(0, stretchDepth).itemCheck()
-	fmt.Printf("stretch tree of depth %d\t check: %d\n", stretchDepth, check)
-
-	longLivedTree := bottomUpTree(0, maxDepth)
-
-	for depth := minDepth; depth <= maxDepth; depth += 2 {
-		iterations := 1 << uint(maxDepth-depth+minDepth)
-		check = 0
-
-		for i := 1; i <= iterations; i++ {
-			check += bottomUpTree(i, depth).itemCheck()
-			check += bottomUpTree(-i, depth).itemCheck()
-		}
-		fmt.Printf("%d\t trees of depth %d\t check: %d\n", iterations*2, depth, check)
-	}
-	fmt.Printf("long lived tree of depth %d\t check: %d\n", maxDepth, longLivedTree.itemCheck())
-}
diff --git a/test/bench/shootout/binary-tree.txt b/test/bench/shootout/binary-tree.txt
deleted file mode 100644
index f8286dd88b..0000000000
--- a/test/bench/shootout/binary-tree.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-stretch tree of depth 16	 check: -1
-65536	 trees of depth 4	 check: -65536
-16384	 trees of depth 6	 check: -16384
-4096	 trees of depth 8	 check: -4096
-1024	 trees of depth 10	 check: -1024
-256	 trees of depth 12	 check: -256
-64	 trees of depth 14	 check: -64
-long lived tree of depth 15	 check: -1
diff --git a/test/bench/shootout/chameneosredux.c b/test/bench/shootout/chameneosredux.c
deleted file mode 100644
index ed78c31d7b..0000000000
--- a/test/bench/shootout/chameneosredux.c
+++ /dev/null
@@ -1,330 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
-   http://shootout.alioth.debian.org/
-
-   contributed by Michael Barker
-   based on a Java contribution by Luzius Meisser
-
-   convert to C by dualamd
-*/
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <pthread.h>
-
-
-enum Colour
-{
-   blue      = 0,
-   red      = 1,
-   yellow   = 2,
-   Invalid   = 3
-};
-
-const char* ColourName[] = {"blue", "red", "yellow"};
-const int STACK_SIZE   = 32*1024;
-
-typedef unsigned int BOOL;
-const BOOL TRUE = 1;
-const BOOL FALSE = 0;
-
-int CreatureID = 0;
-
-
-enum Colour doCompliment(enum Colour c1, enum Colour c2)
-{
-   switch (c1)
-   {
-   case blue:
-      switch (c2)
-      {
-      case blue:
-         return blue;
-      case red:
-         return yellow;
-      case yellow:
-         return red;
-      default:
-         goto errlb;
-      }
-   case red:
-      switch (c2)
-      {
-      case blue:
-         return yellow;
-      case red:
-         return red;
-      case yellow:
-         return blue;
-      default:
-         goto errlb;
-      }
-   case yellow:
-      switch (c2)
-      {
-      case blue:
-         return red;
-      case red:
-         return blue;
-      case yellow:
-         return yellow;
-      default:
-         goto errlb;
-      }
-   default:
-      break;
-   }
-
-errlb:
-   printf("Invalid colour\n");
-   exit( 1 );
-}
-
-/* convert integer to number string: 1234 -> "one two three four" */
-char* formatNumber(int n, char* outbuf)
-{
-   int ochar = 0, ichar = 0;
-   int i;
-   char tmp[64];
-
-   const char* NUMBERS[] =
-   {
-      "zero", "one", "two", "three", "four", "five",
-      "six", "seven", "eight", "nine"
-   };
-
-   ichar = sprintf(tmp, "%d", n);
-
-   for (i = 0; i < ichar; i++)
-      ochar += sprintf( outbuf + ochar, " %s", NUMBERS[ tmp[i] - '0' ] );
-
-   return outbuf;
-}
-
-
-struct MeetingPlace
-{
-   pthread_mutex_t   mutex;
-   int             meetingsLeft;
-   struct Creature*   firstCreature;
-};
-
-struct Creature
-{
-   pthread_t         ht;
-   pthread_attr_t      stack_att;
-
-   struct MeetingPlace* place;
-   int         count;
-   int         sameCount;
-
-   enum Colour   colour;
-   int          id;
-
-   BOOL      two_met;
-   BOOL      sameid;
-};
-
-
-void MeetingPlace_Init(struct MeetingPlace* m, int meetings )
-{
-   pthread_mutex_init( &m->mutex, 0 );
-   m->meetingsLeft = meetings;
-   m->firstCreature = 0;
-}
-
-
-BOOL Meet( struct Creature* cr)
-{
-   BOOL retval = TRUE;
-
-   struct MeetingPlace* mp = cr->place;
-   pthread_mutex_lock( &(mp->mutex) );
-
-   if ( mp->meetingsLeft > 0 )
-   {
-      if ( mp->firstCreature == 0 )
-      {
-         cr->two_met = FALSE;
-         mp->firstCreature = cr;
-      }
-      else
-      {
-         struct Creature* first;
-         enum Colour newColour;
-
-         first = mp->firstCreature;
-         newColour = doCompliment( cr->colour, first->colour );
-
-         cr->sameid = cr->id == first->id;
-         cr->colour = newColour;
-         cr->two_met = TRUE;
-
-         first->sameid = cr->sameid;
-         first->colour = newColour;
-         first->two_met = TRUE;
-
-         mp->firstCreature = 0;
-         mp->meetingsLeft--;
-      }
-   }
-   else
-      retval = FALSE;
-
-   pthread_mutex_unlock( &(mp->mutex) );
-   return retval;
-}
-
-
-void* CreatureThreadRun(void* param)
-{
-   struct Creature* cr = (struct Creature*)param;
-
-   while (TRUE)
-   {
-      if ( Meet(cr) )
-      {
-         while (cr->two_met == FALSE)
-            sched_yield();
-
-         if (cr->sameid)
-            cr->sameCount++;
-         cr->count++;
-      }
-      else
-         break;
-   }
-
-   return 0;
-}
-
-void Creature_Init( struct Creature *cr, struct MeetingPlace* place, enum Colour colour )
-{
-   cr->place = place;
-   cr->count = cr->sameCount = 0;
-
-   cr->id = ++CreatureID;
-   cr->colour = colour;
-   cr->two_met = FALSE;
-
-   pthread_attr_init( &cr->stack_att );
-   pthread_attr_setstacksize( &cr->stack_att, STACK_SIZE );
-   pthread_create( &cr->ht, &cr->stack_att, &CreatureThreadRun, (void*)(cr) );
-}
-
-/* format meeting times of each creature to string */
-char* Creature_getResult(struct Creature* cr, char* str)
-{
-   char numstr[256];
-   formatNumber(cr->sameCount, numstr);
-
-   sprintf( str, "%u%s", cr->count, numstr );
-   return str;
-}
-
-
-void runGame( int n_meeting, int ncolor, const enum Colour* colours )
-{
-   int i;
-   int total = 0;
-   char str[256];
-
-   struct MeetingPlace place;
-   struct Creature *creatures = (struct Creature*) calloc( ncolor, sizeof(struct Creature) );
-
-   MeetingPlace_Init( &place, n_meeting );
-
-   /* print initial color of each creature */
-   for (i = 0; i < ncolor; i++)
-   {
-      printf( "%s ", ColourName[ colours[i] ] );
-      Creature_Init( &(creatures[i]), &place, colours[i] );
-   }
-   printf("\n");
-
-   /* wait for them to meet */
-   for (i = 0; i < ncolor; i++)
-      pthread_join( creatures[i].ht, 0 );
-
-   /* print meeting times of each creature */
-   for (i = 0; i < ncolor; i++)
-   {
-      printf( "%s\n", Creature_getResult(&(creatures[i]), str) );
-      total += creatures[i].count;
-   }
-
-   /* print total meeting times, should equal n_meeting */
-   printf( "%s\n\n", formatNumber(total, str) );
-
-   /* cleaup & quit */
-   pthread_mutex_destroy( &place.mutex );
-   free( creatures );
-}
-
-
-void printColours( enum Colour c1, enum Colour c2 )
-{
-   printf( "%s + %s -> %s\n",
-      ColourName[c1],
-      ColourName[c2],
-      ColourName[doCompliment(c1, c2)]   );
-}
-
-void printColoursTable(void)
-{
-   printColours(blue, blue);
-   printColours(blue, red);
-   printColours(blue, yellow);
-   printColours(red, blue);
-   printColours(red, red);
-   printColours(red, yellow);
-   printColours(yellow, blue);
-   printColours(yellow, red);
-   printColours(yellow, yellow);
-}
-
-int main(int argc, char** argv)
-{
-   int n = (argc == 2) ? atoi(argv[1]) : 600;
-
-   printColoursTable();
-   printf("\n");
-
-   const enum Colour r1[] = {   blue, red, yellow   };
-   const enum Colour r2[] = {   blue, red, yellow,
-               red, yellow, blue,
-               red, yellow, red, blue   };
-
-   runGame( n, sizeof(r1) / sizeof(r1[0]), r1 );
-   runGame( n, sizeof(r2) / sizeof(r2[0]), r2 );
-
-   return 0;
-}
diff --git a/test/bench/shootout/chameneosredux.go b/test/bench/shootout/chameneosredux.go
deleted file mode 100644
index 72ce7dd138..0000000000
--- a/test/bench/shootout/chameneosredux.go
+++ /dev/null
@@ -1,180 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by The Go Authors.
- */
-
-package main
-
-import (
-	"flag"
-	"fmt"
-	"strconv"
-)
-
-const (
-	blue = iota
-	red
-	yellow
-	ncol
-)
-
-var complement = [...]int{
-	red | red<<2:       red,
-	red | yellow<<2:    blue,
-	red | blue<<2:      yellow,
-	yellow | red<<2:    blue,
-	yellow | yellow<<2: yellow,
-	yellow | blue<<2:   red,
-	blue | red<<2:      yellow,
-	blue | yellow<<2:   red,
-	blue | blue<<2:     blue,
-}
-
-var colname = [...]string{
-	blue:   "blue",
-	red:    "red",
-	yellow: "yellow",
-}
-
-// information about the current state of a creature.
-type info struct {
-	colour int // creature's current colour.
-	name   int // creature's name.
-}
-
-// exclusive access data-structure kept inside meetingplace.
-// if mate is nil, it indicates there's no creature currently waiting;
-// otherwise the creature's info is stored in info, and
-// it is waiting to receive its mate's information on the mate channel.
-type rendez struct {
-	n    int         // current number of encounters.
-	mate chan<- info // creature waiting when non-nil.
-	info info        // info about creature waiting.
-}
-
-// result sent by each creature at the end of processing.
-type result struct {
-	met  int
-	same int
-}
-
-var n = 600
-
-func main() {
-	flag.Parse()
-	if flag.NArg() > 0 {
-		n, _ = strconv.Atoi(flag.Arg(0))
-	}
-
-	for c0 := 0; c0 < ncol; c0++ {
-		for c1 := 0; c1 < ncol; c1++ {
-			fmt.Printf("%s + %s -> %s\n", colname[c0], colname[c1], colname[complement[c0|c1<<2]])
-		}
-	}
-	fmt.Print("\n")
-
-	pallmall([]int{blue, red, yellow})
-	pallmall([]int{blue, red, yellow, red, yellow, blue, red, yellow, red, blue})
-}
-
-func pallmall(cols []int) {
-
-	// invariant: meetingplace always contains a value unless a creature
-	// is currently dealing with it (whereupon it must put it back).
-	meetingplace := make(chan rendez, 1)
-	meetingplace <- rendez{n: 0}
-
-	ended := make(chan result)
-	msg := ""
-	for i, col := range cols {
-		go creature(info{col, i}, meetingplace, ended)
-		msg += " " + colname[col]
-	}
-	fmt.Println(msg)
-	tot := 0
-	// wait for all results
-	for range cols {
-		result := <-ended
-		tot += result.met
-		fmt.Printf("%v%v\n", result.met, spell(result.same, true))
-	}
-	fmt.Printf("%v\n\n", spell(tot, true))
-}
-
-// in this function, variables ending in 0 refer to the local creature,
-// variables ending in 1 to the creature we've met.
-func creature(info0 info, meetingplace chan rendez, ended chan result) {
-	c0 := make(chan info)
-	met := 0
-	same := 0
-	for {
-		var othername int
-		// get access to rendez data and decide what to do.
-		switch r := <-meetingplace; {
-		case r.n >= n:
-			// if no more meetings left, then send our result data and exit.
-			meetingplace <- rendez{n: r.n}
-			ended <- result{met, same}
-			return
-		case r.mate == nil:
-			// no creature waiting; wait for someone to meet us,
-			// get their info and send our info in reply.
-			meetingplace <- rendez{n: r.n, info: info0, mate: c0}
-			info1 := <-c0
-			othername = info1.name
-			info0.colour = complement[info0.colour|info1.colour<<2]
-		default:
-			// another creature is waiting for us with its info;
-			// increment meeting count,
-			// send them our info in reply.
-			r.n++
-			meetingplace <- rendez{n: r.n, mate: nil}
-			r.mate <- info0
-			othername = r.info.name
-			info0.colour = complement[info0.colour|r.info.colour<<2]
-		}
-		if othername == info0.name {
-			same++
-		}
-		met++
-	}
-}
-
-var digits = [...]string{"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}
-
-func spell(n int, required bool) string {
-	if n == 0 && !required {
-		return ""
-	}
-	return spell(n/10, false) + " " + digits[n%10]
-}
diff --git a/test/bench/shootout/chameneosredux.txt b/test/bench/shootout/chameneosredux.txt
deleted file mode 100644
index 6016d59a8c..0000000000
--- a/test/bench/shootout/chameneosredux.txt
+++ /dev/null
@@ -1,29 +0,0 @@
-blue + blue -> blue
-blue + red -> yellow
-blue + yellow -> red
-red + blue -> yellow
-red + red -> red
-red + yellow -> blue
-yellow + blue -> red
-yellow + red -> blue
-yellow + yellow -> yellow
-
- blue red yellow
-400 zero
-400 zero
-400 zero
- one two zero zero
-
- blue red yellow red yellow blue red yellow red blue
-120 zero
-120 zero
-120 zero
-120 zero
-120 zero
-120 zero
-120 zero
-120 zero
-120 zero
-120 zero
- one two zero zero
-
diff --git a/test/bench/shootout/fannkuch-parallel.go b/test/bench/shootout/fannkuch-parallel.go
deleted file mode 100644
index 7e9b98d505..0000000000
--- a/test/bench/shootout/fannkuch-parallel.go
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*
- * The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by The Go Authors.
- * Based on fannkuch.scala by Rex Kerr
- */
-
-package main
-
-import (
-	"flag"
-	"fmt"
-	"runtime"
-)
-
-var n = flag.Int("n", 7, "count")
-var nCPU = flag.Int("ncpu", 4, "number of cpus")
-
-type Job struct {
-	start []int
-	n     int
-}
-
-type Found struct {
-	who *Kucher
-	k   int
-}
-
-type Kucher struct {
-	perm []int
-	temp []int
-	flip []int
-	in   chan Job
-}
-
-func NewKucher(length int) *Kucher {
-	return &Kucher{
-		perm: make([]int, length),
-		temp: make([]int, length),
-		flip: make([]int, length),
-		in:   make(chan Job),
-	}
-}
-
-func (k *Kucher) permute(n int) bool {
-	i := 0
-	for ; i < n-1 && k.flip[i] == 0; i++ {
-		t := k.perm[0]
-		j := 0
-		for ; j <= i; j++ {
-			k.perm[j] = k.perm[j+1]
-		}
-		k.perm[j] = t
-	}
-	k.flip[i]--
-	for i > 0 {
-		i--
-		k.flip[i] = i
-	}
-	return k.flip[n-1] >= 0
-}
-
-func (k *Kucher) count() int {
-	K := 0
-	copy(k.temp, k.perm)
-	for k.temp[0] != 0 {
-		m := k.temp[0]
-		for i := 0; i < m; i++ {
-			k.temp[i], k.temp[m] = k.temp[m], k.temp[i]
-			m--
-		}
-		K++
-	}
-	return K
-}
-
-func (k *Kucher) Run(foreman chan<- Found) {
-	for job := range k.in {
-		verbose := 30
-		copy(k.perm, job.start)
-		for i, v := range k.perm {
-			if v != i {
-				verbose = 0
-			}
-			k.flip[i] = i
-		}
-		K := 0
-		for {
-			if verbose > 0 {
-				for _, p := range k.perm {
-					fmt.Print(p + 1)
-				}
-				fmt.Println()
-				verbose--
-			}
-			count := k.count()
-			if count > K {
-				K = count
-			}
-			if !k.permute(job.n) {
-				break
-			}
-		}
-		foreman <- Found{k, K}
-	}
-}
-
-type Fanner struct {
-	jobind   int
-	jobsdone int
-	k        int
-	jobs     []Job
-	workers  []*Kucher
-	in       chan Found
-	result   chan int
-}
-
-func NewFanner(jobs []Job, workers []*Kucher) *Fanner {
-	return &Fanner{
-		jobs: jobs, workers: workers,
-		in:     make(chan Found),
-		result: make(chan int),
-	}
-}
-
-func (f *Fanner) Run(N int) {
-	for msg := range f.in {
-		if msg.k > f.k {
-			f.k = msg.k
-		}
-		if msg.k >= 0 {
-			f.jobsdone++
-		}
-		if f.jobind < len(f.jobs) {
-			msg.who.in <- f.jobs[f.jobind]
-			f.jobind++
-		} else if f.jobsdone == len(f.jobs) {
-			f.result <- f.k
-			return
-		}
-	}
-}
-
-func swapped(a []int, i, j int) []int {
-	b := make([]int, len(a))
-	copy(b, a)
-	b[i], b[j] = a[j], a[i]
-	return b
-}
-
-func main() {
-	flag.Parse()
-	runtime.GOMAXPROCS(*nCPU)
-	N := *n
-	base := make([]int, N)
-	for i := range base {
-		base[i] = i
-	}
-
-	njobs := 1
-	if N > 8 {
-		njobs += (N*(N-1))/2 - 28 // njobs = 1 + sum(8..N-1) = 1 + sum(1..N-1) - sum(1..7)
-	}
-	jobs := make([]Job, njobs)
-	jobsind := 0
-
-	firstN := N
-	if firstN > 8 {
-		firstN = 8
-	}
-	jobs[jobsind] = Job{base, firstN}
-	jobsind++
-	for i := N - 1; i >= 8; i-- {
-		for j := 0; j < i; j++ {
-			jobs[jobsind] = Job{swapped(base, i, j), i}
-			jobsind++
-		}
-	}
-
-	nworkers := *nCPU
-	if njobs < nworkers {
-		nworkers = njobs
-	}
-	workers := make([]*Kucher, nworkers)
-	foreman := NewFanner(jobs, workers)
-	go foreman.Run(N)
-	for i := range workers {
-		k := NewKucher(N)
-		workers[i] = k
-		go k.Run(foreman.in)
-		foreman.in <- Found{k, -1}
-	}
-	fmt.Printf("Pfannkuchen(%d) = %d\n", N, <-foreman.result)
-}
diff --git a/test/bench/shootout/fannkuch-parallel.txt b/test/bench/shootout/fannkuch-parallel.txt
deleted file mode 100644
index e66f779ea1..0000000000
--- a/test/bench/shootout/fannkuch-parallel.txt
+++ /dev/null
@@ -1,31 +0,0 @@
-1234567
-2134567
-2314567
-3214567
-3124567
-1324567
-2341567
-3241567
-3421567
-4321567
-4231567
-2431567
-3412567
-4312567
-4132567
-1432567
-1342567
-3142567
-4123567
-1423567
-1243567
-2143567
-2413567
-4213567
-2345167
-3245167
-3425167
-4325167
-4235167
-2435167
-Pfannkuchen(7) = 16
diff --git a/test/bench/shootout/fannkuch.c b/test/bench/shootout/fannkuch.c
deleted file mode 100644
index e576b5441f..0000000000
--- a/test/bench/shootout/fannkuch.c
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*
- * The Computer Language Shootout
- * http://shootout.alioth.debian.org/
- * Contributed by Heiner Marxen
- *
- * "fannkuch"	for C gcc
- *
- * $Id: fannkuch.1.gcc.code,v 1.15 2009-04-28 15:39:31 igouy-guest Exp $
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#define Int	int
-#define Aint	int
-
-    static long
-fannkuch( int n )
-{
-    Aint*	perm;
-    Aint*	perm1;
-    Aint*	count;
-    long	flips;
-    long	flipsMax;
-    Int		r;
-    Int		i;
-    Int		k;
-    Int		didpr;
-    const Int	n1	= n - 1;
-
-    if( n < 1 ) return 0;
-
-    perm  = calloc(n, sizeof(*perm ));
-    perm1 = calloc(n, sizeof(*perm1));
-    count = calloc(n, sizeof(*count));
-
-    for( i=0 ; i<n ; ++i ) perm1[i] = i;	/* initial (trivial) permu */
-
-    r = n; didpr = 0; flipsMax = 0;
-    for(;;) {
-	if( didpr < 30 ) {
-	    for( i=0 ; i<n ; ++i ) printf("%d", (int)(1+perm1[i]));
-	    printf("\n");
-	    ++didpr;
-	}
-	for( ; r!=1 ; --r ) {
-	    count[r-1] = r;
-	}
-
-#define XCH(x,y)	{ Aint t_mp; t_mp=(x); (x)=(y); (y)=t_mp; }
-
-	if( ! (perm1[0]==0 || perm1[n1]==n1) ) {
-	    flips = 0;
-	    for( i=1 ; i<n ; ++i ) {	/* perm = perm1 */
-		perm[i] = perm1[i];
-	    }
-	    k = perm1[0];		/* cache perm[0] in k */
-	    do {			/* k!=0 ==> k>0 */
-		Int	j;
-		for( i=1, j=k-1 ; i<j ; ++i, --j ) {
-		    XCH(perm[i], perm[j])
-		}
-		++flips;
-		/*
-		 * Now exchange k (caching perm[0]) and perm[k]... with care!
-		 * XCH(k, perm[k]) does NOT work!
-		 */
-		j=perm[k]; perm[k]=k ; k=j;
-	    }while( k );
-	    if( flipsMax < flips ) {
-		flipsMax = flips;
-	    }
-	}
-
-	for(;;) {
-	    if( r == n ) {
-		return flipsMax;
-	    }
-	    /* rotate down perm[0..r] by one */
-	    {
-		Int	perm0 = perm1[0];
-		i = 0;
-		while( i < r ) {
-		    k = i+1;
-		    perm1[i] = perm1[k];
-		    i = k;
-		}
-		perm1[r] = perm0;
-	    }
-	    if( (count[r] -= 1) > 0 ) {
-		break;
-	    }
-	    ++r;
-	}
-    }
-}
-
-    int
-main( int argc, char* argv[] )
-{
-    int		n = (argc>1) ? atoi(argv[1]) : 0;
-
-    printf("Pfannkuchen(%d) = %ld\n", n, fannkuch(n));
-    return 0;
-}
diff --git a/test/bench/shootout/fannkuch.go b/test/bench/shootout/fannkuch.go
deleted file mode 100644
index b554c77b10..0000000000
--- a/test/bench/shootout/fannkuch.go
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*
- * The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by The Go Authors.
- * Based on fannkuch.c by Heiner Marxen
- */
-
-package main
-
-import (
-	"flag"
-	"fmt"
-)
-
-var n = flag.Int("n", 7, "count")
-
-func fannkuch(n int) int {
-	if n < 1 {
-		return 0
-	}
-
-	n1 := n - 1
-	perm := make([]int, n)
-	perm1 := make([]int, n)
-	count := make([]int, n)
-
-	for i := 0; i < n; i++ {
-		perm1[i] = i // initial (trivial) permutation
-	}
-
-	r := n
-	didpr := 0
-	flipsMax := 0
-	for {
-		if didpr < 30 {
-			for i := 0; i < n; i++ {
-				fmt.Printf("%d", 1+perm1[i])
-			}
-			fmt.Printf("\n")
-			didpr++
-		}
-		for ; r != 1; r-- {
-			count[r-1] = r
-		}
-
-		if perm1[0] != 0 && perm1[n1] != n1 {
-			flips := 0
-			for i := 1; i < n; i++ { // perm = perm1
-				perm[i] = perm1[i]
-			}
-			k := perm1[0] // cache perm[0] in k
-			for {         // k!=0 ==> k>0
-				for i, j := 1, k-1; i < j; i, j = i+1, j-1 {
-					perm[i], perm[j] = perm[j], perm[i]
-				}
-				flips++
-				// Now exchange k (caching perm[0]) and perm[k]... with care!
-				j := perm[k]
-				perm[k] = k
-				k = j
-				if k == 0 {
-					break
-				}
-			}
-			if flipsMax < flips {
-				flipsMax = flips
-			}
-		}
-
-		for ; r < n; r++ {
-			// rotate down perm[0..r] by one
-			perm0 := perm1[0]
-			for i := 0; i < r; i++ {
-				perm1[i] = perm1[i+1]
-			}
-			perm1[r] = perm0
-			count[r]--
-			if count[r] > 0 {
-				break
-			}
-		}
-		if r == n {
-			return flipsMax
-		}
-	}
-	return 0
-}
-
-func main() {
-	flag.Parse()
-	fmt.Printf("Pfannkuchen(%d) = %d\n", *n, fannkuch(*n))
-}
diff --git a/test/bench/shootout/fannkuch.txt b/test/bench/shootout/fannkuch.txt
deleted file mode 100644
index e66f779ea1..0000000000
--- a/test/bench/shootout/fannkuch.txt
+++ /dev/null
@@ -1,31 +0,0 @@
-1234567
-2134567
-2314567
-3214567
-3124567
-1324567
-2341567
-3241567
-3421567
-4321567
-4231567
-2431567
-3412567
-4312567
-4132567
-1432567
-1342567
-3142567
-4123567
-1423567
-1243567
-2143567
-2413567
-4213567
-2345167
-3245167
-3425167
-4325167
-4235167
-2435167
-Pfannkuchen(7) = 16
diff --git a/test/bench/shootout/fasta-1000.txt b/test/bench/shootout/fasta-1000.txt
deleted file mode 100644
index f1caba0d62..0000000000
--- a/test/bench/shootout/fasta-1000.txt
+++ /dev/null
@@ -1,171 +0,0 @@
->ONE Homo sapiens alu
-GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGA
-TCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACT
-AAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAG
-GCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCG
-CCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGT
-GGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCA
-GGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAA
-TTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAG
-AATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCA
-GCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGT
-AATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACC
-AGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTG
-GTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACC
-CGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAG
-AGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTT
-TGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACA
-TGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCT
-GTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGG
-TTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGT
-CTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGG
-CGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCG
-TCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTA
-CTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCG
-AGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCG
-GGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACC
-TGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAA
-TACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGA
-GGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACT
-GCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTC
-ACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGT
-TCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC
-CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCG
-CTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTG
-GGCGACAGAGCGAGACTCCG
->TWO IUB ambiguity codes
-cttBtatcatatgctaKggNcataaaSatgtaaaDcDRtBggDtctttataattcBgtcg
-tactDtDagcctatttSVHtHttKtgtHMaSattgWaHKHttttagacatWatgtRgaaa
-NtactMcSMtYtcMgRtacttctWBacgaaatatagScDtttgaagacacatagtVgYgt
-cattHWtMMWcStgttaggKtSgaYaaccWStcgBttgcgaMttBYatcWtgacaYcaga
-gtaBDtRacttttcWatMttDBcatWtatcttactaBgaYtcttgttttttttYaaScYa
-HgtgttNtSatcMtcVaaaStccRcctDaataataStcYtRDSaMtDttgttSagtRRca
-tttHatSttMtWgtcgtatSSagactYaaattcaMtWatttaSgYttaRgKaRtccactt
-tattRggaMcDaWaWagttttgacatgttctacaaaRaatataataaMttcgDacgaSSt
-acaStYRctVaNMtMgtaggcKatcttttattaaaaagVWaHKYagtttttatttaacct
-tacgtVtcVaattVMBcttaMtttaStgacttagattWWacVtgWYagWVRctDattBYt
-gtttaagaagattattgacVatMaacattVctgtBSgaVtgWWggaKHaatKWcBScSWa
-accRVacacaaactaccScattRatatKVtactatatttHttaagtttSKtRtacaaagt
-RDttcaaaaWgcacatWaDgtDKacgaacaattacaRNWaatHtttStgttattaaMtgt
-tgDcgtMgcatBtgcttcgcgaDWgagctgcgaggggVtaaScNatttacttaatgacag
-cccccacatYScaMgtaggtYaNgttctgaMaacNaMRaacaaacaKctacatagYWctg
-ttWaaataaaataRattagHacacaagcgKatacBttRttaagtatttccgatctHSaat
-actcNttMaagtattMtgRtgaMgcataatHcMtaBSaRattagttgatHtMttaaKagg
-YtaaBataSaVatactWtataVWgKgttaaaacagtgcgRatatacatVtHRtVYataSa
-KtWaStVcNKHKttactatccctcatgWHatWaRcttactaggatctataDtDHBttata
-aaaHgtacVtagaYttYaKcctattcttcttaataNDaaggaaaDYgcggctaaWSctBa
-aNtgctggMBaKctaMVKagBaactaWaDaMaccYVtNtaHtVWtKgRtcaaNtYaNacg
-gtttNattgVtttctgtBaWgtaattcaagtcaVWtactNggattctttaYtaaagccgc
-tcttagHVggaYtgtNcDaVagctctctKgacgtatagYcctRYHDtgBattDaaDgccK
-tcHaaStttMcctagtattgcRgWBaVatHaaaataYtgtttagMDMRtaataaggatMt
-ttctWgtNtgtgaaaaMaatatRtttMtDgHHtgtcattttcWattRSHcVagaagtacg
-ggtaKVattKYagactNaatgtttgKMMgYNtcccgSKttctaStatatNVataYHgtNa
-BKRgNacaactgatttcctttaNcgatttctctataScaHtataRagtcRVttacDSDtt
-aRtSatacHgtSKacYagttMHtWataggatgactNtatSaNctataVtttRNKtgRacc
-tttYtatgttactttttcctttaaacatacaHactMacacggtWataMtBVacRaSaatc
-cgtaBVttccagccBcttaRKtgtgcctttttRtgtcagcRttKtaaacKtaaatctcac
-aattgcaNtSBaaccgggttattaaBcKatDagttactcttcattVtttHaaggctKKga
-tacatcBggScagtVcacattttgaHaDSgHatRMaHWggtatatRgccDttcgtatcga
-aacaHtaagttaRatgaVacttagattVKtaaYttaaatcaNatccRttRRaMScNaaaD
-gttVHWgtcHaaHgacVaWtgttScactaagSgttatcttagggDtaccagWattWtRtg
-ttHWHacgattBtgVcaYatcggttgagKcWtKKcaVtgaYgWctgYggVctgtHgaNcV
-taBtWaaYatcDRaaRtSctgaHaYRttagatMatgcatttNattaDttaattgttctaa
-ccctcccctagaWBtttHtBccttagaVaatMcBHagaVcWcagBVttcBtaYMccagat
-gaaaaHctctaacgttagNWRtcggattNatcRaNHttcagtKttttgWatWttcSaNgg
-gaWtactKKMaacatKatacNattgctWtatctaVgagctatgtRaHtYcWcttagccaa
-tYttWttaWSSttaHcaaaaagVacVgtaVaRMgattaVcDactttcHHggHRtgNcctt
-tYatcatKgctcctctatVcaaaaKaaaagtatatctgMtWtaaaacaStttMtcgactt
-taSatcgDataaactaaacaagtaaVctaggaSccaatMVtaaSKNVattttgHccatca
-cBVctgcaVatVttRtactgtVcaattHgtaaattaaattttYtatattaaRSgYtgBag
-aHSBDgtagcacRHtYcBgtcacttacactaYcgctWtattgSHtSatcataaatataHt
-cgtYaaMNgBaatttaRgaMaatatttBtttaaaHHKaatctgatWatYaacttMctctt
-ttVctagctDaaagtaVaKaKRtaacBgtatccaaccactHHaagaagaaggaNaaatBW
-attccgStaMSaMatBttgcatgRSacgttVVtaaDMtcSgVatWcaSatcttttVatag
-ttactttacgatcaccNtaDVgSRcgVcgtgaacgaNtaNatatagtHtMgtHcMtagaa
-attBgtataRaaaacaYKgtRccYtatgaagtaataKgtaaMttgaaRVatgcagaKStc
-tHNaaatctBBtcttaYaBWHgtVtgacagcaRcataWctcaBcYacYgatDgtDHccta
->THREE Homo sapiens frequency
-aacacttcaccaggtatcgtgaaggctcaagattacccagagaacctttgcaatataaga
-atatgtatgcagcattaccctaagtaattatattctttttctgactcaaagtgacaagcc
-ctagtgtatattaaatcggtatatttgggaaattcctcaaactatcctaatcaggtagcc
-atgaaagtgatcaaaaaagttcgtacttataccatacatgaattctggccaagtaaaaaa
-tagattgcgcaaaattcgtaccttaagtctctcgccaagatattaggatcctattactca
-tatcgtgtttttctttattgccgccatccccggagtatctcacccatccttctcttaaag
-gcctaatattacctatgcaaataaacatatattgttgaaaattgagaacctgatcgtgat
-tcttatgtgtaccatatgtatagtaatcacgcgactatatagtgctttagtatcgcccgt
-gggtgagtgaatattctgggctagcgtgagatagtttcttgtcctaatatttttcagatc
-gaatagcttctatttttgtgtttattgacatatgtcgaaactccttactcagtgaaagtc
-atgaccagatccacgaacaatcttcggaatcagtctcgttttacggcggaatcttgagtc
-taacttatatcccgtcgcttactttctaacaccccttatgtatttttaaaattacgttta
-ttcgaacgtacttggcggaagcgttattttttgaagtaagttacattgggcagactcttg
-acattttcgatacgactttctttcatccatcacaggactcgttcgtattgatatcagaag
-ctcgtgatgattagttgtcttctttaccaatactttgaggcctattctgcgaaatttttg
-ttgccctgcgaacttcacataccaaggaacacctcgcaacatgccttcatatccatcgtt
-cattgtaattcttacacaatgaatcctaagtaattacatccctgcgtaaaagatggtagg
-ggcactgaggatatattaccaagcatttagttatgagtaatcagcaatgtttcttgtatt
-aagttctctaaaatagttacatcgtaatgttatctcgggttccgcgaataaacgagatag
-attcattatatatggccctaagcaaaaacctcctcgtattctgttggtaattagaatcac
-acaatacgggttgagatattaattatttgtagtacgaagagatataaaaagatgaacaat
-tactcaagtcaagatgtatacgggatttataataaaaatcgggtagagatctgctttgca
-attcagacgtgccactaaatcgtaatatgtcgcgttacatcagaaagggtaactattatt
-aattaataaagggcttaatcactacatattagatcttatccgatagtcttatctattcgt
-tgtatttttaagcggttctaattcagtcattatatcagtgctccgagttctttattattg
-ttttaaggatgacaaaatgcctcttgttataacgctgggagaagcagactaagagtcgga
-gcagttggtagaatgaggctgcaaaagacggtctcgacgaatggacagactttactaaac
-caatgaaagacagaagtagagcaaagtctgaagtggtatcagcttaattatgacaaccct
-taatacttccctttcgccgaatactggcgtggaaaggttttaaaagtcgaagtagttaga
-ggcatctctcgctcataaataggtagactactcgcaatccaatgtgactatgtaatactg
-ggaacatcagtccgcgatgcagcgtgtttatcaaccgtccccactcgcctggggagacat
-gagaccacccccgtggggattattagtccgcagtaatcgactcttgacaatccttttcga
-ttatgtcatagcaatttacgacagttcagcgaagtgactactcggcgaaatggtattact
-aaagcattcgaacccacatgaatgtgattcttggcaatttctaatccactaaagcttttc
-cgttgaatctggttgtagatatttatataagttcactaattaagatcacggtagtatatt
-gatagtgatgtctttgcaagaggttggccgaggaatttacggattctctattgatacaat
-ttgtctggcttataactcttaaggctgaaccaggcgtttttagacgacttgatcagctgt
-tagaatggtttggactccctctttcatgtcagtaacatttcagccgttattgttacgata
-tgcttgaacaatattgatctaccacacacccatagtatattttataggtcatgctgttac
-ctacgagcatggtattccacttcccattcaatgagtattcaacatcactagcctcagaga
-tgatgacccacctctaataacgtcacgttgcggccatgtgaaacctgaacttgagtagac
-gatatcaagcgctttaaattgcatataacatttgagggtaaagctaagcggatgctttat
-ataatcaatactcaataataagatttgattgcattttagagttatgacacgacatagttc
-actaacgagttactattcccagatctagactgaagtactgatcgagacgatccttacgtc
-gatgatcgttagttatcgacttaggtcgggtctctagcggtattggtacttaaccggaca
-ctatactaataacccatgatcaaagcataacagaatacagacgataatttcgccaacata
-tatgtacagaccccaagcatgagaagctcattgaaagctatcattgaagtcccgctcaca
-atgtgtcttttccagacggtttaactggttcccgggagtcctggagtttcgacttacata
-aatggaaacaatgtattttgctaatttatctatagcgtcatttggaccaatacagaatat
-tatgttgcctagtaatccactataacccgcaagtgctgatagaaaatttttagacgattt
-ataaatgccccaagtatccctcccgtgaatcctccgttatactaattagtattcgttcat
-acgtataccgcgcatatatgaacatttggcgataaggcgcgtgaattgttacgtgacaga
-gatagcagtttcttgtgatatggttaacagacgtacatgaagggaaactttatatctata
-gtgatgcttccgtagaaataccgccactggtctgccaatgatgaagtatgtagctttagg
-tttgtactatgaggctttcgtttgtttgcagagtataacagttgcgagtgaaaaaccgac
-gaatttatactaatacgctttcactattggctacaaaatagggaagagtttcaatcatga
-gagggagtatatggatgctttgtagctaaaggtagaacgtatgtatatgctgccgttcat
-tcttgaaagatacataagcgataagttacgacaattataagcaacatccctaccttcgta
-acgatttcactgttactgcgcttgaaatacactatggggctattggcggagagaagcaga
-tcgcgccgagcatatacgagacctataatgttgatgatagagaaggcgtctgaattgata
-catcgaagtacactttctttcgtagtatctctcgtcctctttctatctccggacacaaga
-attaagttatatatatagagtcttaccaatcatgttgaatcctgattctcagagttcttt
-ggcgggccttgtgatgactgagaaacaatgcaatattgctccaaatttcctaagcaaatt
-ctcggttatgttatgttatcagcaaagcgttacgttatgttatttaaatctggaatgacg
-gagcgaagttcttatgtcggtgtgggaataattcttttgaagacagcactccttaaataa
-tatcgctccgtgtttgtatttatcgaatgggtctgtaaccttgcacaagcaaatcggtgg
-tgtatatatcggataacaattaatacgatgttcatagtgacagtatactgatcgagtcct
-ctaaagtcaattacctcacttaacaatctcattgatgttgtgtcattcccggtatcgccc
-gtagtatgtgctctgattgaccgagtgtgaaccaaggaacatctactaatgcctttgtta
-ggtaagatctctctgaattccttcgtgccaacttaaaacattatcaaaatttcttctact
-tggattaactacttttacgagcatggcaaattcccctgtggaagacggttcattattatc
-ggaaaccttatagaaattgcgtgttgactgaaattagatttttattgtaagagttgcatc
-tttgcgattcctctggtctagcttccaatgaacagtcctcccttctattcgacatcgggt
-ccttcgtacatgtctttgcgatgtaataattaggttcggagtgtggccttaatgggtgca
-actaggaatacaacgcaaatttgctgacatgatagcaaatcggtatgccggcaccaaaac
-gtgctccttgcttagcttgtgaatgagactcagtagttaaataaatccatatctgcaatc
-gattccacaggtattgtccactatctttgaactactctaagagatacaagcttagctgag
-accgaggtgtatatgactacgctgatatctgtaaggtaccaatgcaggcaaagtatgcga
-gaagctaataccggctgtttccagctttataagattaaaatttggctgtcctggcggcct
-cagaattgttctatcgtaatcagttggttcattaattagctaagtacgaggtacaactta
-tctgtcccagaacagctccacaagtttttttacagccgaaacccctgtgtgaatcttaat
-atccaagcgcgttatctgattagagtttacaactcagtattttatcagtacgttttgttt
-ccaacattacccggtatgacaaaatgacgccacgtgtcgaataatggtctgaccaatgta
-ggaagtgaaaagataaatat
diff --git a/test/bench/shootout/fasta.c b/test/bench/shootout/fasta.c
deleted file mode 100644
index 64c1c52058..0000000000
--- a/test/bench/shootout/fasta.c
+++ /dev/null
@@ -1,219 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*
- * http://shootout.alioth.debian.org/u32/program.php?test=fasta&lang=gcc&id=3
- */
-
-/*  The Computer Language Benchmarks Game
- *  http://shootout.alioth.debian.org/
- *
- *  contributed by Petr Prokhorenkov
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#ifndef fwrite_unlocked
-// not available on OS X 
-#define fwrite_unlocked fwrite
-#define fputc_unlocked fputc
-#define fputs_unlocked fputs
-#endif
-
-#define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))
-#define unlikely(x) __builtin_expect((x), 0)
-
-#define IM 139968
-#define IA 3877
-#define IC 29573
-
-#define LINE_LEN 60
-#define LOOKUP_SIZE 4096
-#define LOOKUP_SCALE ((float)(LOOKUP_SIZE - 1))
-
-typedef unsigned random_t;
-
-void
-random_init(random_t *random) {
-    *random = 42;
-}
-
-// Special version with result rescaled to LOOKUP_SCALE.
-static inline
-float
-random_next_lookup(random_t *random) {
-    *random = (*random*IA + IC)%IM;
-
-    return (*random)*(LOOKUP_SCALE/IM);
-}
-
-struct amino_acid {
-   char sym;
-   float prob;
-   float cprob_lookup;
-};
-
-void
-repeat(const char *alu, const char *title, int n) {
-    int len = strlen(alu);
-    char buffer[len + LINE_LEN];
-    int pos = 0;
-
-    memcpy(buffer, alu, len);
-    memcpy(buffer + len, alu, LINE_LEN);
-
-    fputs_unlocked(title, stdout);
-    while (n > 0) {
-        int bytes = n > LINE_LEN ? LINE_LEN : n;
-
-        fwrite_unlocked(buffer + pos, bytes, 1, stdout);
-        pos += bytes;
-        if (pos > len) {
-            pos -= len;
-        }
-        fputc_unlocked('\n', stdout);
-        n -= bytes;
-    }
-}
-
-/*
- * Lookup table contains mapping from real values to cumulative
- * probabilities. Careful selection of table size allows lookup
- * virtually in constant time.
- *
- * All cumulative probabilities are rescaled to LOOKUP_SCALE,
- * this allows to save one multiplication operation on each iteration
- * in randomize().
- */
-
-void *
-fill_lookup(struct amino_acid **lookup, struct amino_acid *amino_acid, int amino_acid_size) {
-    float p = 0;
-    int i, j;
-
-    for (i = 0; i < amino_acid_size; i++) {
-        p += amino_acid[i].prob;
-        amino_acid[i].cprob_lookup = p*LOOKUP_SCALE;
-    }
-
-    // Prevent rounding error.
-    amino_acid[amino_acid_size - 1].cprob_lookup = LOOKUP_SIZE - 1;
-
-    for (i = 0, j = 0; i < LOOKUP_SIZE; i++) {
-        while (amino_acid[j].cprob_lookup < i) {
-            j++;
-        }
-        lookup[i] = &amino_acid[j];
-    }
-
-    return 0;
-}
-
-void
-randomize(struct amino_acid *amino_acid, int amino_acid_size,
-        const char *title, int n, random_t *rand) {
-    struct amino_acid *lookup[LOOKUP_SIZE];
-    char line_buffer[LINE_LEN + 1];
-    int i, j;
-
-    line_buffer[LINE_LEN] = '\n';
-
-    fill_lookup(lookup, amino_acid, amino_acid_size);
-
-    fputs_unlocked(title, stdout);
-
-    for (i = 0, j = 0; i < n; i++, j++) {
-        if (j == LINE_LEN) {
-            fwrite_unlocked(line_buffer, LINE_LEN + 1, 1, stdout);
-            j = 0;
-        }
-
-        float r = random_next_lookup(rand);
-        struct amino_acid *u = lookup[(short)r];
-        while (unlikely(u->cprob_lookup < r)) {
-            ++u;
-        }
-        line_buffer[j] = u->sym;
-    }
-    line_buffer[j] = '\n';
-    fwrite_unlocked(line_buffer, j + 1, 1, stdout);
-}
-
-struct amino_acid amino_acid[] = {
-   { 'a', 0.27 },
-   { 'c', 0.12 },
-   { 'g', 0.12 },
-   { 't', 0.27 },
-
-   { 'B', 0.02 },
-   { 'D', 0.02 },
-   { 'H', 0.02 },
-   { 'K', 0.02 },
-   { 'M', 0.02 },
-   { 'N', 0.02 },
-   { 'R', 0.02 },
-   { 'S', 0.02 },
-   { 'V', 0.02 },
-   { 'W', 0.02 },
-   { 'Y', 0.02 },
-};
-
-struct amino_acid homo_sapiens[] = {
-   { 'a', 0.3029549426680 },
-   { 'c', 0.1979883004921 },
-   { 'g', 0.1975473066391 },
-   { 't', 0.3015094502008 },
-};
-
-static const char alu[] =
-   "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTG"
-   "GGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGA"
-   "GACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAA"
-   "AATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAAT"
-   "CCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAAC"
-   "CCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTG"
-   "CACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";
-
-int
-main(int argc, const char **argv) {
-    int n = argc > 1 ? atoi( argv[1] ) : 512;
-    random_t rand;
-
-    random_init(&rand);
-
-    repeat(alu, ">ONE Homo sapiens alu\n", n*2);
-    randomize(amino_acid, ARRAY_SIZE(amino_acid),
-            ">TWO IUB ambiguity codes\n", n*3, &rand);
-    randomize(homo_sapiens, ARRAY_SIZE(homo_sapiens),
-            ">THREE Homo sapiens frequency\n", n*5, &rand);
-
-    return 0;
-}
diff --git a/test/bench/shootout/fasta.go b/test/bench/shootout/fasta.go
deleted file mode 100644
index 17ff5dae55..0000000000
--- a/test/bench/shootout/fasta.go
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by The Go Authors.
- * Based on C program by by Petr Prokhorenkov.
- */
-
-package main
-
-import (
-	"flag"
-	"os"
-)
-
-var out = make(buffer, 0, 32768)
-
-var n = flag.Int("n", 1000, "length of result")
-
-const Line = 60
-
-func Repeat(alu []byte, n int) {
-	buf := append(alu, alu...)
-	off := 0
-	for n > 0 {
-		m := n
-		if m > Line {
-			m = Line
-		}
-		buf1 := out.NextWrite(m + 1)
-		copy(buf1, buf[off:])
-		buf1[m] = '\n'
-		if off += m; off >= len(alu) {
-			off -= len(alu)
-		}
-		n -= m
-	}
-}
-
-const (
-	IM = 139968
-	IA = 3877
-	IC = 29573
-
-	LookupSize          = 4096
-	LookupScale float64 = LookupSize - 1
-)
-
-var rand uint32 = 42
-
-type Acid struct {
-	sym   byte
-	prob  float64
-	cprob float64
-	next  *Acid
-}
-
-func computeLookup(acid []Acid) *[LookupSize]*Acid {
-	var lookup [LookupSize]*Acid
-	var p float64
-	for i := range acid {
-		p += acid[i].prob
-		acid[i].cprob = p * LookupScale
-		if i > 0 {
-			acid[i-1].next = &acid[i]
-		}
-	}
-	acid[len(acid)-1].cprob = 1.0 * LookupScale
-
-	j := 0
-	for i := range lookup {
-		for acid[j].cprob < float64(i) {
-			j++
-		}
-		lookup[i] = &acid[j]
-	}
-
-	return &lookup
-}
-
-func Random(acid []Acid, n int) {
-	lookup := computeLookup(acid)
-	for n > 0 {
-		m := n
-		if m > Line {
-			m = Line
-		}
-		buf := out.NextWrite(m + 1)
-		f := LookupScale / IM
-		myrand := rand
-		for i := 0; i < m; i++ {
-			myrand = (myrand*IA + IC) % IM
-			r := float64(int(myrand)) * f
-			a := lookup[int(r)]
-			for a.cprob < r {
-				a = a.next
-			}
-			buf[i] = a.sym
-		}
-		rand = myrand
-		buf[m] = '\n'
-		n -= m
-	}
-}
-
-func main() {
-	defer out.Flush()
-
-	flag.Parse()
-
-	iub := []Acid{
-		{prob: 0.27, sym: 'a'},
-		{prob: 0.12, sym: 'c'},
-		{prob: 0.12, sym: 'g'},
-		{prob: 0.27, sym: 't'},
-		{prob: 0.02, sym: 'B'},
-		{prob: 0.02, sym: 'D'},
-		{prob: 0.02, sym: 'H'},
-		{prob: 0.02, sym: 'K'},
-		{prob: 0.02, sym: 'M'},
-		{prob: 0.02, sym: 'N'},
-		{prob: 0.02, sym: 'R'},
-		{prob: 0.02, sym: 'S'},
-		{prob: 0.02, sym: 'V'},
-		{prob: 0.02, sym: 'W'},
-		{prob: 0.02, sym: 'Y'},
-	}
-
-	homosapiens := []Acid{
-		{prob: 0.3029549426680, sym: 'a'},
-		{prob: 0.1979883004921, sym: 'c'},
-		{prob: 0.1975473066391, sym: 'g'},
-		{prob: 0.3015094502008, sym: 't'},
-	}
-
-	alu := []byte(
-		"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG" +
-			"GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA" +
-			"CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT" +
-			"ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA" +
-			"GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG" +
-			"AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC" +
-			"AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA")
-
-	out.WriteString(">ONE Homo sapiens alu\n")
-	Repeat(alu, 2**n)
-	out.WriteString(">TWO IUB ambiguity codes\n")
-	Random(iub, 3**n)
-	out.WriteString(">THREE Homo sapiens frequency\n")
-	Random(homosapiens, 5**n)
-}
-
-type buffer []byte
-
-func (b *buffer) Flush() {
-	p := *b
-	if len(p) > 0 {
-		os.Stdout.Write(p)
-	}
-	*b = p[0:0]
-}
-
-func (b *buffer) WriteString(s string) {
-	p := b.NextWrite(len(s))
-	copy(p, s)
-}
-
-func (b *buffer) NextWrite(n int) []byte {
-	p := *b
-	if len(p)+n > cap(p) {
-		b.Flush()
-		p = *b
-	}
-	out := p[len(p) : len(p)+n]
-	*b = p[:len(p)+n]
-	return out
-}
diff --git a/test/bench/shootout/fasta.txt b/test/bench/shootout/fasta.txt
deleted file mode 100644
index f1caba0d62..0000000000
--- a/test/bench/shootout/fasta.txt
+++ /dev/null
@@ -1,171 +0,0 @@
->ONE Homo sapiens alu
-GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGA
-TCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACT
-AAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAG
-GCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCG
-CCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGT
-GGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCA
-GGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAA
-TTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAG
-AATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCA
-GCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGT
-AATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACC
-AGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTG
-GTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACC
-CGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAG
-AGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTT
-TGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACA
-TGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCT
-GTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGG
-TTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGT
-CTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGG
-CGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCG
-TCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTA
-CTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCG
-AGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCG
-GGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACC
-TGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAA
-TACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGA
-GGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACT
-GCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTC
-ACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGT
-TCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC
-CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCG
-CTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTG
-GGCGACAGAGCGAGACTCCG
->TWO IUB ambiguity codes
-cttBtatcatatgctaKggNcataaaSatgtaaaDcDRtBggDtctttataattcBgtcg
-tactDtDagcctatttSVHtHttKtgtHMaSattgWaHKHttttagacatWatgtRgaaa
-NtactMcSMtYtcMgRtacttctWBacgaaatatagScDtttgaagacacatagtVgYgt
-cattHWtMMWcStgttaggKtSgaYaaccWStcgBttgcgaMttBYatcWtgacaYcaga
-gtaBDtRacttttcWatMttDBcatWtatcttactaBgaYtcttgttttttttYaaScYa
-HgtgttNtSatcMtcVaaaStccRcctDaataataStcYtRDSaMtDttgttSagtRRca
-tttHatSttMtWgtcgtatSSagactYaaattcaMtWatttaSgYttaRgKaRtccactt
-tattRggaMcDaWaWagttttgacatgttctacaaaRaatataataaMttcgDacgaSSt
-acaStYRctVaNMtMgtaggcKatcttttattaaaaagVWaHKYagtttttatttaacct
-tacgtVtcVaattVMBcttaMtttaStgacttagattWWacVtgWYagWVRctDattBYt
-gtttaagaagattattgacVatMaacattVctgtBSgaVtgWWggaKHaatKWcBScSWa
-accRVacacaaactaccScattRatatKVtactatatttHttaagtttSKtRtacaaagt
-RDttcaaaaWgcacatWaDgtDKacgaacaattacaRNWaatHtttStgttattaaMtgt
-tgDcgtMgcatBtgcttcgcgaDWgagctgcgaggggVtaaScNatttacttaatgacag
-cccccacatYScaMgtaggtYaNgttctgaMaacNaMRaacaaacaKctacatagYWctg
-ttWaaataaaataRattagHacacaagcgKatacBttRttaagtatttccgatctHSaat
-actcNttMaagtattMtgRtgaMgcataatHcMtaBSaRattagttgatHtMttaaKagg
-YtaaBataSaVatactWtataVWgKgttaaaacagtgcgRatatacatVtHRtVYataSa
-KtWaStVcNKHKttactatccctcatgWHatWaRcttactaggatctataDtDHBttata
-aaaHgtacVtagaYttYaKcctattcttcttaataNDaaggaaaDYgcggctaaWSctBa
-aNtgctggMBaKctaMVKagBaactaWaDaMaccYVtNtaHtVWtKgRtcaaNtYaNacg
-gtttNattgVtttctgtBaWgtaattcaagtcaVWtactNggattctttaYtaaagccgc
-tcttagHVggaYtgtNcDaVagctctctKgacgtatagYcctRYHDtgBattDaaDgccK
-tcHaaStttMcctagtattgcRgWBaVatHaaaataYtgtttagMDMRtaataaggatMt
-ttctWgtNtgtgaaaaMaatatRtttMtDgHHtgtcattttcWattRSHcVagaagtacg
-ggtaKVattKYagactNaatgtttgKMMgYNtcccgSKttctaStatatNVataYHgtNa
-BKRgNacaactgatttcctttaNcgatttctctataScaHtataRagtcRVttacDSDtt
-aRtSatacHgtSKacYagttMHtWataggatgactNtatSaNctataVtttRNKtgRacc
-tttYtatgttactttttcctttaaacatacaHactMacacggtWataMtBVacRaSaatc
-cgtaBVttccagccBcttaRKtgtgcctttttRtgtcagcRttKtaaacKtaaatctcac
-aattgcaNtSBaaccgggttattaaBcKatDagttactcttcattVtttHaaggctKKga
-tacatcBggScagtVcacattttgaHaDSgHatRMaHWggtatatRgccDttcgtatcga
-aacaHtaagttaRatgaVacttagattVKtaaYttaaatcaNatccRttRRaMScNaaaD
-gttVHWgtcHaaHgacVaWtgttScactaagSgttatcttagggDtaccagWattWtRtg
-ttHWHacgattBtgVcaYatcggttgagKcWtKKcaVtgaYgWctgYggVctgtHgaNcV
-taBtWaaYatcDRaaRtSctgaHaYRttagatMatgcatttNattaDttaattgttctaa
-ccctcccctagaWBtttHtBccttagaVaatMcBHagaVcWcagBVttcBtaYMccagat
-gaaaaHctctaacgttagNWRtcggattNatcRaNHttcagtKttttgWatWttcSaNgg
-gaWtactKKMaacatKatacNattgctWtatctaVgagctatgtRaHtYcWcttagccaa
-tYttWttaWSSttaHcaaaaagVacVgtaVaRMgattaVcDactttcHHggHRtgNcctt
-tYatcatKgctcctctatVcaaaaKaaaagtatatctgMtWtaaaacaStttMtcgactt
-taSatcgDataaactaaacaagtaaVctaggaSccaatMVtaaSKNVattttgHccatca
-cBVctgcaVatVttRtactgtVcaattHgtaaattaaattttYtatattaaRSgYtgBag
-aHSBDgtagcacRHtYcBgtcacttacactaYcgctWtattgSHtSatcataaatataHt
-cgtYaaMNgBaatttaRgaMaatatttBtttaaaHHKaatctgatWatYaacttMctctt
-ttVctagctDaaagtaVaKaKRtaacBgtatccaaccactHHaagaagaaggaNaaatBW
-attccgStaMSaMatBttgcatgRSacgttVVtaaDMtcSgVatWcaSatcttttVatag
-ttactttacgatcaccNtaDVgSRcgVcgtgaacgaNtaNatatagtHtMgtHcMtagaa
-attBgtataRaaaacaYKgtRccYtatgaagtaataKgtaaMttgaaRVatgcagaKStc
-tHNaaatctBBtcttaYaBWHgtVtgacagcaRcataWctcaBcYacYgatDgtDHccta
->THREE Homo sapiens frequency
-aacacttcaccaggtatcgtgaaggctcaagattacccagagaacctttgcaatataaga
-atatgtatgcagcattaccctaagtaattatattctttttctgactcaaagtgacaagcc
-ctagtgtatattaaatcggtatatttgggaaattcctcaaactatcctaatcaggtagcc
-atgaaagtgatcaaaaaagttcgtacttataccatacatgaattctggccaagtaaaaaa
-tagattgcgcaaaattcgtaccttaagtctctcgccaagatattaggatcctattactca
-tatcgtgtttttctttattgccgccatccccggagtatctcacccatccttctcttaaag
-gcctaatattacctatgcaaataaacatatattgttgaaaattgagaacctgatcgtgat
-tcttatgtgtaccatatgtatagtaatcacgcgactatatagtgctttagtatcgcccgt
-gggtgagtgaatattctgggctagcgtgagatagtttcttgtcctaatatttttcagatc
-gaatagcttctatttttgtgtttattgacatatgtcgaaactccttactcagtgaaagtc
-atgaccagatccacgaacaatcttcggaatcagtctcgttttacggcggaatcttgagtc
-taacttatatcccgtcgcttactttctaacaccccttatgtatttttaaaattacgttta
-ttcgaacgtacttggcggaagcgttattttttgaagtaagttacattgggcagactcttg
-acattttcgatacgactttctttcatccatcacaggactcgttcgtattgatatcagaag
-ctcgtgatgattagttgtcttctttaccaatactttgaggcctattctgcgaaatttttg
-ttgccctgcgaacttcacataccaaggaacacctcgcaacatgccttcatatccatcgtt
-cattgtaattcttacacaatgaatcctaagtaattacatccctgcgtaaaagatggtagg
-ggcactgaggatatattaccaagcatttagttatgagtaatcagcaatgtttcttgtatt
-aagttctctaaaatagttacatcgtaatgttatctcgggttccgcgaataaacgagatag
-attcattatatatggccctaagcaaaaacctcctcgtattctgttggtaattagaatcac
-acaatacgggttgagatattaattatttgtagtacgaagagatataaaaagatgaacaat
-tactcaagtcaagatgtatacgggatttataataaaaatcgggtagagatctgctttgca
-attcagacgtgccactaaatcgtaatatgtcgcgttacatcagaaagggtaactattatt
-aattaataaagggcttaatcactacatattagatcttatccgatagtcttatctattcgt
-tgtatttttaagcggttctaattcagtcattatatcagtgctccgagttctttattattg
-ttttaaggatgacaaaatgcctcttgttataacgctgggagaagcagactaagagtcgga
-gcagttggtagaatgaggctgcaaaagacggtctcgacgaatggacagactttactaaac
-caatgaaagacagaagtagagcaaagtctgaagtggtatcagcttaattatgacaaccct
-taatacttccctttcgccgaatactggcgtggaaaggttttaaaagtcgaagtagttaga
-ggcatctctcgctcataaataggtagactactcgcaatccaatgtgactatgtaatactg
-ggaacatcagtccgcgatgcagcgtgtttatcaaccgtccccactcgcctggggagacat
-gagaccacccccgtggggattattagtccgcagtaatcgactcttgacaatccttttcga
-ttatgtcatagcaatttacgacagttcagcgaagtgactactcggcgaaatggtattact
-aaagcattcgaacccacatgaatgtgattcttggcaatttctaatccactaaagcttttc
-cgttgaatctggttgtagatatttatataagttcactaattaagatcacggtagtatatt
-gatagtgatgtctttgcaagaggttggccgaggaatttacggattctctattgatacaat
-ttgtctggcttataactcttaaggctgaaccaggcgtttttagacgacttgatcagctgt
-tagaatggtttggactccctctttcatgtcagtaacatttcagccgttattgttacgata
-tgcttgaacaatattgatctaccacacacccatagtatattttataggtcatgctgttac
-ctacgagcatggtattccacttcccattcaatgagtattcaacatcactagcctcagaga
-tgatgacccacctctaataacgtcacgttgcggccatgtgaaacctgaacttgagtagac
-gatatcaagcgctttaaattgcatataacatttgagggtaaagctaagcggatgctttat
-ataatcaatactcaataataagatttgattgcattttagagttatgacacgacatagttc
-actaacgagttactattcccagatctagactgaagtactgatcgagacgatccttacgtc
-gatgatcgttagttatcgacttaggtcgggtctctagcggtattggtacttaaccggaca
-ctatactaataacccatgatcaaagcataacagaatacagacgataatttcgccaacata
-tatgtacagaccccaagcatgagaagctcattgaaagctatcattgaagtcccgctcaca
-atgtgtcttttccagacggtttaactggttcccgggagtcctggagtttcgacttacata
-aatggaaacaatgtattttgctaatttatctatagcgtcatttggaccaatacagaatat
-tatgttgcctagtaatccactataacccgcaagtgctgatagaaaatttttagacgattt
-ataaatgccccaagtatccctcccgtgaatcctccgttatactaattagtattcgttcat
-acgtataccgcgcatatatgaacatttggcgataaggcgcgtgaattgttacgtgacaga
-gatagcagtttcttgtgatatggttaacagacgtacatgaagggaaactttatatctata
-gtgatgcttccgtagaaataccgccactggtctgccaatgatgaagtatgtagctttagg
-tttgtactatgaggctttcgtttgtttgcagagtataacagttgcgagtgaaaaaccgac
-gaatttatactaatacgctttcactattggctacaaaatagggaagagtttcaatcatga
-gagggagtatatggatgctttgtagctaaaggtagaacgtatgtatatgctgccgttcat
-tcttgaaagatacataagcgataagttacgacaattataagcaacatccctaccttcgta
-acgatttcactgttactgcgcttgaaatacactatggggctattggcggagagaagcaga
-tcgcgccgagcatatacgagacctataatgttgatgatagagaaggcgtctgaattgata
-catcgaagtacactttctttcgtagtatctctcgtcctctttctatctccggacacaaga
-attaagttatatatatagagtcttaccaatcatgttgaatcctgattctcagagttcttt
-ggcgggccttgtgatgactgagaaacaatgcaatattgctccaaatttcctaagcaaatt
-ctcggttatgttatgttatcagcaaagcgttacgttatgttatttaaatctggaatgacg
-gagcgaagttcttatgtcggtgtgggaataattcttttgaagacagcactccttaaataa
-tatcgctccgtgtttgtatttatcgaatgggtctgtaaccttgcacaagcaaatcggtgg
-tgtatatatcggataacaattaatacgatgttcatagtgacagtatactgatcgagtcct
-ctaaagtcaattacctcacttaacaatctcattgatgttgtgtcattcccggtatcgccc
-gtagtatgtgctctgattgaccgagtgtgaaccaaggaacatctactaatgcctttgtta
-ggtaagatctctctgaattccttcgtgccaacttaaaacattatcaaaatttcttctact
-tggattaactacttttacgagcatggcaaattcccctgtggaagacggttcattattatc
-ggaaaccttatagaaattgcgtgttgactgaaattagatttttattgtaagagttgcatc
-tttgcgattcctctggtctagcttccaatgaacagtcctcccttctattcgacatcgggt
-ccttcgtacatgtctttgcgatgtaataattaggttcggagtgtggccttaatgggtgca
-actaggaatacaacgcaaatttgctgacatgatagcaaatcggtatgccggcaccaaaac
-gtgctccttgcttagcttgtgaatgagactcagtagttaaataaatccatatctgcaatc
-gattccacaggtattgtccactatctttgaactactctaagagatacaagcttagctgag
-accgaggtgtatatgactacgctgatatctgtaaggtaccaatgcaggcaaagtatgcga
-gaagctaataccggctgtttccagctttataagattaaaatttggctgtcctggcggcct
-cagaattgttctatcgtaatcagttggttcattaattagctaagtacgaggtacaactta
-tctgtcccagaacagctccacaagtttttttacagccgaaacccctgtgtgaatcttaat
-atccaagcgcgttatctgattagagtttacaactcagtattttatcagtacgttttgttt
-ccaacattacccggtatgacaaaatgacgccacgtgtcgaataatggtctgaccaatgta
-ggaagtgaaaagataaatat
diff --git a/test/bench/shootout/k-nucleotide-parallel.go b/test/bench/shootout/k-nucleotide-parallel.go
deleted file mode 100644
index 96c80d8f0c..0000000000
--- a/test/bench/shootout/k-nucleotide-parallel.go
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by The Go Authors.
- */
-
-package main
-
-import (
-	"bufio"
-	"bytes"
-	"fmt"
-	"io/ioutil"
-	"os"
-	"runtime"
-	"sort"
-)
-
-func count(data string, n int) map[string]int {
-	counts := make(map[string]int)
-	top := len(data) - n
-	for i := 0; i <= top; i++ {
-		s := data[i : i+n]
-		counts[s]++
-	}
-	return counts
-}
-
-func countOne(data string, s string) int {
-	return count(data, len(s))[s]
-}
-
-type kNuc struct {
-	name  string
-	count int
-}
-
-type kNucArray []kNuc
-
-func (kn kNucArray) Len() int      { return len(kn) }
-func (kn kNucArray) Swap(i, j int) { kn[i], kn[j] = kn[j], kn[i] }
-func (kn kNucArray) Less(i, j int) bool {
-	if kn[i].count == kn[j].count {
-		return kn[i].name > kn[j].name // sort down
-	}
-	return kn[i].count > kn[j].count
-}
-
-func sortedArray(m map[string]int) kNucArray {
-	kn := make(kNucArray, len(m))
-	i := 0
-	for k, v := range m {
-		kn[i] = kNuc{k, v}
-		i++
-	}
-	sort.Sort(kn)
-	return kn
-}
-
-func printKnucs(a kNucArray) {
-	sum := 0
-	for _, kn := range a {
-		sum += kn.count
-	}
-	for _, kn := range a {
-		fmt.Printf("%s %.3f\n", kn.name, 100*float64(kn.count)/float64(sum))
-	}
-	fmt.Print("\n")
-}
-
-func main() {
-	runtime.GOMAXPROCS(4)
-	in := bufio.NewReader(os.Stdin)
-	three := []byte(">THREE ")
-	for {
-		line, err := in.ReadSlice('\n')
-		if err != nil {
-			fmt.Fprintln(os.Stderr, "ReadLine err:", err)
-			os.Exit(2)
-		}
-		if line[0] == '>' && bytes.Equal(line[0:len(three)], three) {
-			break
-		}
-	}
-	data, err := ioutil.ReadAll(in)
-	if err != nil {
-		fmt.Fprintln(os.Stderr, "ReadAll err:", err)
-		os.Exit(2)
-	}
-	// delete the newlines and convert to upper case
-	j := 0
-	for i := 0; i < len(data); i++ {
-		if data[i] != '\n' {
-			data[j] = data[i] &^ ' ' // upper case
-			j++
-		}
-	}
-	str := string(data[0:j])
-
-	var arr1, arr2 kNucArray
-	countsdone := make(chan bool)
-	go func() {
-		arr1 = sortedArray(count(str, 1))
-		countsdone <- true
-	}()
-	go func() {
-		arr2 = sortedArray(count(str, 2))
-		countsdone <- true
-	}()
-
-	interests := []string{"GGT", "GGTA", "GGTATT", "GGTATTTTAATT", "GGTATTTTAATTTATAGT"}
-	results := make([]chan string, len(interests))
-	for i, s := range interests {
-		ch := make(chan string)
-		results[i] = ch
-		go func(result chan string, ss string) {
-			result <- fmt.Sprintf("%d %s\n", countOne(str, ss), ss)
-		}(ch, s)
-	}
-	<-countsdone
-	<-countsdone
-	printKnucs(arr1)
-	printKnucs(arr2)
-	for _, rc := range results {
-		fmt.Print(<-rc)
-	}
-
-}
diff --git a/test/bench/shootout/k-nucleotide-parallel.txt b/test/bench/shootout/k-nucleotide-parallel.txt
deleted file mode 100644
index 84169b8ec3..0000000000
--- a/test/bench/shootout/k-nucleotide-parallel.txt
+++ /dev/null
@@ -1,27 +0,0 @@
-T 31.520
-A 29.600
-C 19.480
-G 19.400
-
-AT 9.922
-TT 9.602
-TA 9.402
-AA 8.402
-GA 6.321
-TC 6.301
-TG 6.201
-GT 6.041
-CT 5.961
-AG 5.841
-CA 5.461
-AC 5.441
-CC 4.041
-CG 4.021
-GC 3.701
-GG 3.341
-
-54 GGT
-24 GGTA
-4 GGTATT
-0 GGTATTTTAATT
-0 GGTATTTTAATTTATAGT
diff --git a/test/bench/shootout/k-nucleotide.c b/test/bench/shootout/k-nucleotide.c
deleted file mode 100644
index 9c30620209..0000000000
--- a/test/bench/shootout/k-nucleotide.c
+++ /dev/null
@@ -1,228 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include <stdio.h>
-#include <string.h>
-#include <ctype.h>
-#include <stdlib.h>
-#include <glib.h>
-
-typedef struct stat_s stat_t;
-struct stat_s
-{
-   const gchar *key;
-   long stat;
-};
-
-#define MAX_ELM (8192 / sizeof (stat_t))
-
-static int
-generate_frequencies (int fl, char *buffer, long buflen,
-		      GHashTable *ht, GTrashStack **ts, GPtrArray *roots, GStringChunk *sc)
-{
-   gchar *key;
-   long i;
-
-   if (fl > buflen) return 0;
-   if (fl == 0) return 0;
-
-   for (i = 0; i < buflen - fl + 1; ++i)
-     {
-	char nulled;
-	stat_t *stat;
-
-	nulled = buffer[i + fl];
-	buffer[i + fl] = '\0';
-
-	key = g_string_chunk_insert_const(sc, buffer + i);
-
-	stat = g_hash_table_lookup(ht, key);
-	if (!stat)
-	  {
-	     stat = g_trash_stack_pop(ts);
-	     if (!stat)
-	       {
-		  int j;
-
-		  stat = malloc(sizeof (stat_t) * MAX_ELM);
-		  g_ptr_array_add(roots, stat);
-
-		  for (j = 1; j < MAX_ELM; ++j)
-		    g_trash_stack_push(ts, stat + j);
-	       }
-	     stat->stat = 1;
-	     stat->key = key;
-
-	     g_hash_table_insert(ht, key, stat);
-	  }
-	else
-	  stat->stat++;
-
-	buffer[i + fl] = nulled;
-     }
-
-   return buflen - fl + 1;
-}
-
-static int
-cmp_func(gconstpointer a, gconstpointer b)
-{
-   const stat_t *left = a;
-   const stat_t *right = b;
-
-   return right->stat - left->stat;
-}
-
-static void
-sorted_list(gpointer key, gpointer value, gpointer user_data)
-{
-   stat_t *data = value;
-   GList **lst = user_data;
-
-   *lst = g_list_insert_sorted(*lst, data, cmp_func);
-}
-
-static void
-display_stat(gpointer data, gpointer user_data)
-{
-   long *total = user_data;
-   stat_t *st = data;
-
-   printf("%s %.3f\n", st->key, 100 * (float) st->stat / *total);
-}
-
-void
-write_frequencies (int fl, char *buffer, long buflen, GTrashStack **ts, GPtrArray *roots)
-{
-   GStringChunk *sc;
-   GHashTable *ht;
-   GList *lst;
-   long total;
-
-   ht = g_hash_table_new_full(g_str_hash, g_str_equal, NULL /* free key */, NULL /* free value */);
-   sc = g_string_chunk_new(buflen);
-   lst = NULL;
-
-   total = generate_frequencies (fl, buffer, buflen, ht, ts, roots, sc);
-
-   if (!total) goto on_error;
-
-   g_hash_table_foreach(ht, sorted_list, &lst);
-   g_list_foreach(lst, display_stat, &total);
-   g_list_free(lst);
-
- on_error:
-   g_hash_table_destroy(ht);
-   g_string_chunk_free(sc);
-}
-
-void
-write_count (char *searchFor, char *buffer, long buflen, GTrashStack **ts, GPtrArray *roots)
-{
-   GStringChunk *sc;
-   GHashTable *ht;
-   stat_t *result;
-   GList *lst;
-   long total;
-   long fl;
-
-   fl = strlen(searchFor);
-
-   ht = g_hash_table_new_full(g_str_hash, g_str_equal, NULL /* free key */, NULL /* free value */);
-   sc = g_string_chunk_new(buflen);
-   lst = NULL;
-   result = NULL;
-
-   total = generate_frequencies (fl, buffer, buflen, ht, ts, roots, sc);
-
-   if (!total) goto on_error;
-
-   result = g_hash_table_lookup(ht, searchFor);
-
- on_error:
-   printf("%ld\t%s\n", result ? result->stat : 0, searchFor);
-
-   g_hash_table_destroy(ht);
-   g_string_chunk_free(sc);
-}
-
-int
-main ()
-{
-   char buffer[4096];
-   GTrashStack *ts;
-   GPtrArray *roots;
-   GString *stuff;
-   gchar *s;
-   int len;
-
-   roots = g_ptr_array_new();
-   ts = NULL;
-
-   while (fgets(buffer, sizeof (buffer), stdin))
-     if (strncmp(buffer, ">THREE", 6) == 0)
-       break;
-
-   stuff = g_string_new(NULL);
-
-   while (fgets(buffer, sizeof (buffer), stdin))
-     {
-	size_t sz;
-
-	if (buffer[0] == '>')
-	  break;
-
-	sz = strlen(buffer);
-	if (buffer[sz - 1] == '\n')
-	  --sz;
-
-	stuff = g_string_append_len(stuff, buffer, sz);
-     }
-
-   stuff = g_string_ascii_up(stuff);
-   len = stuff->len;
-   s = g_string_free(stuff, FALSE);
-
-   write_frequencies(1, s, len, &ts, roots);
-   printf("\n");
-   write_frequencies(2, s, len, &ts, roots);
-   printf("\n");
-   write_count("GGT", s, len, &ts, roots);
-   write_count("GGTA", s, len, &ts, roots);
-   write_count("GGTATT", s, len, &ts, roots);
-   write_count("GGTATTTTAATT", s, len, &ts, roots);
-   write_count("GGTATTTTAATTTATAGT", s, len, &ts, roots);
-
-   free(s);
-
-   g_ptr_array_foreach(roots, (GFunc)free, NULL);
-   g_ptr_array_free(roots, TRUE);
-
-   return 0;
-}
diff --git a/test/bench/shootout/k-nucleotide.go b/test/bench/shootout/k-nucleotide.go
deleted file mode 100644
index fdc98ed472..0000000000
--- a/test/bench/shootout/k-nucleotide.go
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by The Go Authors.
- */
-
-package main
-
-import (
-	"bufio"
-	"bytes"
-	"fmt"
-	"io/ioutil"
-	"os"
-	"sort"
-)
-
-var in *bufio.Reader
-
-func count(data string, n int) map[string]int {
-	counts := make(map[string]int)
-	top := len(data) - n
-	for i := 0; i <= top; i++ {
-		s := data[i : i+n]
-		counts[s]++
-	}
-	return counts
-}
-
-func countOne(data string, s string) int {
-	return count(data, len(s))[s]
-}
-
-type kNuc struct {
-	name  string
-	count int
-}
-
-type kNucArray []kNuc
-
-func (kn kNucArray) Len() int      { return len(kn) }
-func (kn kNucArray) Swap(i, j int) { kn[i], kn[j] = kn[j], kn[i] }
-func (kn kNucArray) Less(i, j int) bool {
-	if kn[i].count == kn[j].count {
-		return kn[i].name > kn[j].name // sort down
-	}
-	return kn[i].count > kn[j].count
-}
-
-func sortedArray(m map[string]int) kNucArray {
-	kn := make(kNucArray, len(m))
-	i := 0
-	for k, v := range m {
-		kn[i].name = k
-		kn[i].count = v
-		i++
-	}
-	sort.Sort(kn)
-	return kn
-}
-
-func print(m map[string]int) {
-	a := sortedArray(m)
-	sum := 0
-	for _, kn := range a {
-		sum += kn.count
-	}
-	for _, kn := range a {
-		fmt.Printf("%s %.3f\n", kn.name, 100*float64(kn.count)/float64(sum))
-	}
-}
-
-func main() {
-	in = bufio.NewReader(os.Stdin)
-	three := []byte(">THREE ")
-	for {
-		line, err := in.ReadSlice('\n')
-		if err != nil {
-			fmt.Fprintln(os.Stderr, "ReadLine err:", err)
-			os.Exit(2)
-		}
-		if line[0] == '>' && bytes.Equal(line[0:len(three)], three) {
-			break
-		}
-	}
-	data, err := ioutil.ReadAll(in)
-	if err != nil {
-		fmt.Fprintln(os.Stderr, "ReadAll err:", err)
-		os.Exit(2)
-	}
-	// delete the newlines and convert to upper case
-	j := 0
-	for i := 0; i < len(data); i++ {
-		if data[i] != '\n' {
-			data[j] = data[i] &^ ' ' // upper case
-			j++
-		}
-	}
-	str := string(data[0:j])
-
-	print(count(str, 1))
-	fmt.Print("\n")
-
-	print(count(str, 2))
-	fmt.Print("\n")
-
-	interests := []string{"GGT", "GGTA", "GGTATT", "GGTATTTTAATT", "GGTATTTTAATTTATAGT"}
-	for _, s := range interests {
-		fmt.Printf("%d %s\n", countOne(str, s), s)
-	}
-}
diff --git a/test/bench/shootout/k-nucleotide.txt b/test/bench/shootout/k-nucleotide.txt
deleted file mode 100644
index 84169b8ec3..0000000000
--- a/test/bench/shootout/k-nucleotide.txt
+++ /dev/null
@@ -1,27 +0,0 @@
-T 31.520
-A 29.600
-C 19.480
-G 19.400
-
-AT 9.922
-TT 9.602
-TA 9.402
-AA 8.402
-GA 6.321
-TC 6.301
-TG 6.201
-GT 6.041
-CT 5.961
-AG 5.841
-CA 5.461
-AC 5.441
-CC 4.041
-CG 4.021
-GC 3.701
-GG 3.341
-
-54 GGT
-24 GGTA
-4 GGTATT
-0 GGTATTTTAATT
-0 GGTATTTTAATTTATAGT
diff --git a/test/bench/shootout/mandelbrot.c b/test/bench/shootout/mandelbrot.c
deleted file mode 100644
index c177c088ca..0000000000
--- a/test/bench/shootout/mandelbrot.c
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Shootout
-   http://shootout.alioth.debian.org/
-
-   contributed by Greg Buchholz
-
-   for the debian (AMD) machine...
-   compile flags:  -O3 -ffast-math -march=athlon-xp -funroll-loops
-
-   for the gp4 (Intel) machine...
-   compile flags:  -O3 -ffast-math -march=pentium4 -funroll-loops
-*/
-
-#include<stdio.h>
-
-int main (int argc, char **argv)
-{
-    int w, h, bit_num = 0;
-    char byte_acc = 0;
-    int i, iter = 50;
-    double x, y, limit = 2.0;
-    double Zr, Zi, Cr, Ci, Tr, Ti;
-
-    w = h = atoi(argv[1]);
-
-    printf("P4\n%d %d\n",w,h);
-
-    for(y=0;y<h;++y)
-    {
-        for(x=0;x<w;++x)
-        {
-            Zr = Zi = Tr = Ti = 0.0;
-            Cr = (2.0*x/w - 1.5); Ci=(2.0*y/h - 1.0);
-
-            for (i=0;i<iter && (Tr+Ti <= limit*limit);++i)
-            {
-                Zi = 2.0*Zr*Zi + Ci;
-                Zr = Tr - Ti + Cr;
-                Tr = Zr * Zr;
-                Ti = Zi * Zi;
-            }
-
-            byte_acc <<= 1;
-            if(Tr+Ti <= limit*limit) byte_acc |= 0x01;
-
-            ++bit_num;
-
-            if(bit_num == 8)
-            {
-                putc(byte_acc,stdout);
-                byte_acc = 0;
-                bit_num = 0;
-            }
-            else if(x == w-1)
-            {
-                byte_acc <<= (8-w%8);
-                putc(byte_acc,stdout);
-                byte_acc = 0;
-                bit_num = 0;
-            }
-        }
-    }
-}
diff --git a/test/bench/shootout/mandelbrot.go b/test/bench/shootout/mandelbrot.go
deleted file mode 100644
index df60343c24..0000000000
--- a/test/bench/shootout/mandelbrot.go
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by The Go Authors.
- * Based on mandelbrot.c contributed by Greg Buchholz
- */
-
-package main
-
-import (
-	"bufio"
-	"flag"
-	"fmt"
-	"os"
-)
-
-var n = flag.Int("n", 200, "size")
-
-func main() {
-	flag.Parse()
-	out := bufio.NewWriter(os.Stdout)
-	defer out.Flush()
-
-	w := float64(*n)
-	h := float64(*n)
-	bit_num := 0
-	byte_acc := byte(0)
-	const Iter = 50
-	const Zero float64 = 0
-	const Limit = 2.0
-
-	fmt.Fprintf(out, "P4\n%d %d\n", *n, *n)
-
-	for y := 0.0; y < h; y++ {
-		for x := 0.0; x < w; x++ {
-			Zr, Zi, Tr, Ti := Zero, Zero, Zero, Zero
-			Cr := (2*x/w - 1.5)
-			Ci := (2*y/h - 1.0)
-
-			for i := 0; i < Iter && (Tr+Ti <= Limit*Limit); i++ {
-				Zi = 2*Zr*Zi + Ci
-				Zr = Tr - Ti + Cr
-				Tr = Zr * Zr
-				Ti = Zi * Zi
-			}
-
-			byte_acc <<= 1
-			if Tr+Ti <= Limit*Limit {
-				byte_acc |= 0x01
-			}
-
-			bit_num++
-
-			if bit_num == 8 {
-				out.WriteByte(byte_acc)
-				byte_acc = 0
-				bit_num = 0
-			} else if x == w-1 {
-				byte_acc <<= uint(8 - uint(*n)%8)
-				out.WriteByte(byte_acc)
-				byte_acc = 0
-				bit_num = 0
-			}
-		}
-	}
-}
diff --git a/test/bench/shootout/mandelbrot.txt b/test/bench/shootout/mandelbrot.txt
deleted file mode 100644
index 2f7bbbc6b0..0000000000
Binary files a/test/bench/shootout/mandelbrot.txt and /dev/null differ
diff --git a/test/bench/shootout/meteor-contest.c b/test/bench/shootout/meteor-contest.c
deleted file mode 100644
index 19c43402c8..0000000000
--- a/test/bench/shootout/meteor-contest.c
+++ /dev/null
@@ -1,626 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by Christian Vosteen
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#define TRUE 1
-#define FALSE 0
-
-/* The board is a 50 cell hexagonal pattern.  For    . . . . .
- * maximum speed the board will be implemented as     . . . . .
- * 50 bits, which will fit into a 64 bit long long   . . . . .
- * int.                                               . . . . .
- *                                                   . . . . .
- * I will represent 0's as empty cells and 1's        . . . . .
- * as full cells.                                    . . . . .
- *                                                    . . . . .
- *                                                   . . . . .
- *                                                    . . . . .
- */
-
-unsigned long long board = 0xFFFC000000000000ULL;
-
-/* The puzzle pieces must be specified by the path followed
- * from one end to the other along 12 hexagonal directions.
- *
- *   Piece 0   Piece 1   Piece 2   Piece 3   Piece 4
- *
- *  O O O O    O   O O   O O O     O O O     O   O
- *         O    O O           O       O       O O
- *                           O         O         O
- *
- *   Piece 5   Piece 6   Piece 7   Piece 8   Piece 9
- *
- *    O O O     O O       O O     O O        O O O O
- *       O O       O O       O       O O O        O
- *                  O       O O
- *
- * I had to make it 12 directions because I wanted all of the
- * piece definitions to fit into the same size arrays.  It is
- * not possible to define piece 4 in terms of the 6 cardinal
- * directions in 4 moves.
- */
-
-#define E     0
-#define ESE   1
-#define SE    2
-#define S     3
-#define SW    4
-#define WSW   5
-#define W     6
-#define WNW   7
-#define NW    8
-#define N     9
-#define NE    10
-#define ENE   11
-#define PIVOT 12
-
-char piece_def[10][4] = {
-   {  E,  E,  E, SE},
-   { SE,  E, NE,  E},
-   {  E,  E, SE, SW},
-   {  E,  E, SW, SE},
-   { SE,  E, NE,  S},
-   {  E,  E, SW,  E},
-   {  E, SE, SE, NE},
-   {  E, SE, SE,  W},
-   {  E, SE,  E,  E},
-   {  E,  E,  E, SW}
-};
-
-
-/* To minimize the amount of work done in the recursive solve function below,
- * I'm going to allocate enough space for all legal rotations of each piece
- * at each position on the board. That's 10 pieces x 50 board positions x
- * 12 rotations.  However, not all 12 rotations will fit on every cell, so
- * I'll have to keep count of the actual number that do.
- * The pieces are going to be unsigned long long ints just like the board so
- * they can be bitwise-anded with the board to determine if they fit.
- * I'm also going to record the next possible open cell for each piece and
- * location to reduce the burden on the solve function.
- */
-unsigned long long pieces[10][50][12];
-int piece_counts[10][50];
-char next_cell[10][50][12];
-
-/* Returns the direction rotated 60 degrees clockwise */
-char rotate(char dir) {
-   return (dir + 2) % PIVOT;
-}
-
-/* Returns the direction flipped on the horizontal axis */
-char flip(char dir) {
-   return (PIVOT - dir) % PIVOT;
-}
-
-
-/* Returns the new cell index from the specified cell in the
- * specified direction.  The index is only valid if the
- * starting cell and direction have been checked by the
- * out_of_bounds function first.
- */
-char shift(char cell, char dir) {
-   switch(dir) {
-      case E:
-         return cell + 1;
-      case ESE:
-         if((cell / 5) % 2)
-            return cell + 7;
-         else
-            return cell + 6;
-      case SE:
-         if((cell / 5) % 2)
-            return cell + 6;
-         else
-            return cell + 5;
-      case S:
-         return cell + 10;
-      case SW:
-         if((cell / 5) % 2)
-            return cell + 5;
-         else
-            return cell + 4;
-      case WSW:
-         if((cell / 5) % 2)
-            return cell + 4;
-         else
-            return cell + 3;
-      case W:
-         return cell - 1;
-      case WNW:
-         if((cell / 5) % 2)
-            return cell - 6;
-         else
-            return cell - 7;
-      case NW:
-         if((cell / 5) % 2)
-            return cell - 5;
-         else
-            return cell - 6;
-      case N:
-         return cell - 10;
-      case NE:
-         if((cell / 5) % 2)
-            return cell - 4;
-         else
-            return cell - 5;
-      case ENE:
-         if((cell / 5) % 2)
-            return cell - 3;
-         else
-            return cell - 4;
-      default:
-         return cell;
-   }
-}
-
-/* Returns wether the specified cell and direction will land outside
- * of the board.  Used to determine if a piece is at a legal board
- * location or not.
- */
-char out_of_bounds(char cell, char dir) {
-   char i;
-   switch(dir) {
-      case E:
-         return cell % 5 == 4;
-      case ESE:
-         i = cell % 10;
-         return i == 4 || i == 8 || i == 9 || cell >= 45;
-      case SE:
-         return cell % 10 == 9 || cell >= 45;
-      case S:
-         return cell >= 40;
-      case SW:
-         return cell % 10 == 0 || cell >= 45;
-      case WSW:
-         i = cell % 10;
-         return i == 0 || i == 1 || i == 5 || cell >= 45;
-      case W:
-         return cell % 5 == 0;
-      case WNW:
-         i = cell % 10;
-         return i == 0 || i == 1 || i == 5 || cell < 5;
-      case NW:
-         return cell % 10 == 0 || cell < 5;
-      case N:
-         return cell < 10;
-      case NE:
-         return cell % 10 == 9 || cell < 5;
-      case ENE:
-         i = cell % 10;
-         return i == 4 || i == 8 || i == 9 || cell < 5;
-      default:
-         return FALSE;
-   }
-}
-
-/* Rotate a piece 60 degrees clockwise */
-void rotate_piece(int piece) {
-   int i;
-   for(i = 0; i < 4; i++)
-      piece_def[piece][i] = rotate(piece_def[piece][i]);
-}
-
-/* Flip a piece along the horizontal axis */
-void flip_piece(int piece) {
-   int i;
-   for(i = 0; i < 4; i++)
-      piece_def[piece][i] = flip(piece_def[piece][i]);
-}
-
-/* Convenience function to quickly calculate all of the indices for a piece */
-void calc_cell_indices(char *cell, int piece, char index) {
-   cell[0] = index;
-   cell[1] = shift(cell[0], piece_def[piece][0]);
-   cell[2] = shift(cell[1], piece_def[piece][1]);
-   cell[3] = shift(cell[2], piece_def[piece][2]);
-   cell[4] = shift(cell[3], piece_def[piece][3]);
-}
-
-/* Convenience function to quickly calculate if a piece fits on the board */
-int cells_fit_on_board(char *cell, int piece) {
-   return (!out_of_bounds(cell[0], piece_def[piece][0]) &&
-         !out_of_bounds(cell[1], piece_def[piece][1]) &&
-         !out_of_bounds(cell[2], piece_def[piece][2]) &&
-         !out_of_bounds(cell[3], piece_def[piece][3]));
-}
-
-/* Returns the lowest index of the cells of a piece.
- * I use the lowest index that a piece occupies as the index for looking up
- * the piece in the solve function.
- */
-char minimum_of_cells(char *cell) {
-   char minimum = cell[0];
-   minimum = cell[1] < minimum ? cell[1] : minimum;
-   minimum = cell[2] < minimum ? cell[2] : minimum;
-   minimum = cell[3] < minimum ? cell[3] : minimum;
-   minimum = cell[4] < minimum ? cell[4] : minimum;
-   return minimum;
-}
-
-/* Calculate the lowest possible open cell if the piece is placed on the board.
- * Used to later reduce the amount of time searching for open cells in the
- * solve function.
- */
-char first_empty_cell(char *cell, char minimum) {
-   char first_empty = minimum;
-   while(first_empty == cell[0] || first_empty == cell[1] ||
-         first_empty == cell[2] || first_empty == cell[3] ||
-         first_empty == cell[4])
-      first_empty++;
-   return first_empty;
-}
-
-/* Generate the unsigned long long int that will later be anded with the
- * board to determine if it fits.
- */
-unsigned long long bitmask_from_cells(char *cell) {
-   unsigned long long piece_mask = 0ULL;
-   int i;
-   for(i = 0; i < 5; i++)
-      piece_mask |= 1ULL << cell[i];
-   return piece_mask;
-}
-
-/* Record the piece and other important information in arrays that will
- * later be used by the solve function.
- */
-void record_piece(int piece, int minimum, char first_empty,
-      unsigned long long piece_mask) {
-   pieces[piece][minimum][piece_counts[piece][minimum]] = piece_mask;
-   next_cell[piece][minimum][piece_counts[piece][minimum]] = first_empty;
-   piece_counts[piece][minimum]++;
-}
-
-
-/* Fill the entire board going cell by cell.  If any cells are "trapped"
- * they will be left alone.
- */
-void fill_contiguous_space(char *board, int index) {
-   if(board[index] == 1)
-      return;
-   board[index] = 1;
-   if(!out_of_bounds(index, E))
-      fill_contiguous_space(board, shift(index, E));
-   if(!out_of_bounds(index, SE))
-      fill_contiguous_space(board, shift(index, SE));
-   if(!out_of_bounds(index, SW))
-      fill_contiguous_space(board, shift(index, SW));
-   if(!out_of_bounds(index, W))
-      fill_contiguous_space(board, shift(index, W));
-   if(!out_of_bounds(index, NW))
-      fill_contiguous_space(board, shift(index, NW));
-   if(!out_of_bounds(index, NE))
-      fill_contiguous_space(board, shift(index, NE));
-}
-
-
-/* To thin the number of pieces, I calculate if any of them trap any empty
- * cells at the edges.  There are only a handful of exceptions where the
- * the board can be solved with the trapped cells.  For example:  piece 8 can
- * trap 5 cells in the corner, but piece 3 can fit in those cells, or piece 0
- * can split the board in half where both halves are viable.
- */
-int has_island(char *cell, int piece) {
-   char temp_board[50];
-   char c;
-   int i;
-   for(i = 0; i < 50; i++)
-      temp_board[i] = 0;
-   for(i = 0; i < 5; i++)
-      temp_board[((int)cell[i])] = 1;
-   i = 49;
-   while(temp_board[i] == 1)
-      i--;
-   fill_contiguous_space(temp_board, i);
-   c = 0;
-   for(i = 0; i < 50; i++)
-      if(temp_board[i] == 0)
-         c++;
-   if(c == 0 || (c == 5 && piece == 8) || (c == 40 && piece == 8) ||
-         (c % 5 == 0 && piece == 0))
-      return FALSE;
-   else
-      return TRUE;
-}
-
-
-/* Calculate all six rotations of the specified piece at the specified index.
- * We calculate only half of piece 3's rotations.  This is because any solution
- * found has an identical solution rotated 180 degrees.  Thus we can reduce the
- * number of attempted pieces in the solve algorithm by not including the 180-
- * degree-rotated pieces of ONE of the pieces.  I chose piece 3 because it gave
- * me the best time ;)
- */
- void calc_six_rotations(char piece, char index) {
-   char rotation, cell[5];
-   char minimum, first_empty;
-   unsigned long long piece_mask;
-
-   for(rotation = 0; rotation < 6; rotation++) {
-      if(piece != 3 || rotation < 3) {
-         calc_cell_indices(cell, piece, index);
-         if(cells_fit_on_board(cell, piece) && !has_island(cell, piece)) {
-            minimum = minimum_of_cells(cell);
-            first_empty = first_empty_cell(cell, minimum);
-            piece_mask = bitmask_from_cells(cell);
-            record_piece(piece, minimum, first_empty, piece_mask);
-         }
-      }
-      rotate_piece(piece);
-   }
-}
-
-/* Calculate every legal rotation for each piece at each board location. */
-void calc_pieces(void) {
-   char piece, index;
-
-   for(piece = 0; piece < 10; piece++) {
-      for(index = 0; index < 50; index++) {
-         calc_six_rotations(piece, index);
-         flip_piece(piece);
-         calc_six_rotations(piece, index);
-      }
-   }
-}
-
-
-
-/* Calculate all 32 possible states for a 5-bit row and all rows that will
- * create islands that follow any of the 32 possible rows.  These pre-
- * calculated 5-bit rows will be used to find islands in a partially solved
- * board in the solve function.
- */
-#define ROW_MASK 0x1F
-#define TRIPLE_MASK 0x7FFF
-char all_rows[32] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
-      17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31};
-int bad_even_rows[32][32];
-int bad_odd_rows[32][32];
-int bad_even_triple[32768];
-int bad_odd_triple[32768];
-
-int rows_bad(char row1, char row2, int even) {
-   /* even is referring to row1 */
-   int i, in_zeroes, group_okay;
-   char block, row2_shift;
-   /* Test for blockages at same index and shifted index */
-   if(even)
-      row2_shift = ((row2 << 1) & ROW_MASK) | 0x01;
-   else
-      row2_shift = (row2 >> 1) | 0x10;
-   block = ((row1 ^ row2) & row2) & ((row1 ^ row2_shift) & row2_shift);
-   /* Test for groups of 0's */
-   in_zeroes = FALSE;
-   group_okay = FALSE;
-   for(i = 0; i < 5; i++) {
-      if(row1 & (1 << i)) {
-         if(in_zeroes) {
-            if(!group_okay)
-               return TRUE;
-            in_zeroes = FALSE;
-            group_okay = FALSE;
-         }
-      } else {
-         if(!in_zeroes)
-            in_zeroes = TRUE;
-         if(!(block & (1 << i)))
-            group_okay = TRUE;
-      }
-   }
-   if(in_zeroes)
-      return !group_okay;
-   else
-      return FALSE;
-}
-
-/* Check for cases where three rows checked sequentially cause a false
- * positive.  One scenario is when 5 cells may be surrounded where piece 5
- * or 7 can fit.  The other scenario is when piece 2 creates a hook shape.
- */
-int triple_is_okay(char row1, char row2, char row3, int even) {
-   if(even) {
-      /* There are four cases:
-       * row1: 00011  00001  11001  10101
-       * row2: 01011  00101  10001  10001
-       * row3: 011??  00110  ?????  ?????
-       */
-      return ((row1 == 0x03) && (row2 == 0x0B) && ((row3 & 0x1C) == 0x0C)) ||
-            ((row1 == 0x01) && (row2 == 0x05) && (row3 == 0x06)) ||
-            ((row1 == 0x19) && (row2 == 0x11)) ||
-            ((row1 == 0x15) && (row2 == 0x11));
-   } else {
-      /* There are two cases:
-       * row1: 10011  10101
-       * row2: 10001  10001
-       * row3: ?????  ?????
-       */
-      return ((row1 == 0x13) && (row2 == 0x11)) ||
-            ((row1 == 0x15) && (row2 == 0x11));
-   }
-}
-
-
-void calc_rows(void) {
-   int row1, row2, row3;
-   int result1, result2;
-   for(row1 = 0; row1 < 32; row1++) {
-      for(row2 = 0; row2 < 32; row2++) {
-         bad_even_rows[row1][row2] = rows_bad(row1, row2, TRUE);
-         bad_odd_rows[row1][row2] = rows_bad(row1, row2, FALSE);
-      }
-   }
-   for(row1 = 0; row1 < 32; row1++) {
-      for(row2 = 0; row2 < 32; row2++) {
-         for(row3 = 0; row3 < 32; row3++) {
-            result1 = bad_even_rows[row1][row2];
-            result2 = bad_odd_rows[row2][row3];
-            if(result1 == FALSE && result2 == TRUE
-                  && triple_is_okay(row1, row2, row3, TRUE))
-               bad_even_triple[row1+(row2*32)+(row3*1024)] = FALSE;
-            else
-               bad_even_triple[row1+(row2*32)+(row3*1024)] = result1 || result2;
-
-            result1 = bad_odd_rows[row1][row2];
-            result2 = bad_even_rows[row2][row3];
-            if(result1 == FALSE && result2 == TRUE
-                  && triple_is_okay(row1, row2, row3, FALSE))
-               bad_odd_triple[row1+(row2*32)+(row3*1024)] = FALSE;
-            else
-               bad_odd_triple[row1+(row2*32)+(row3*1024)] = result1 || result2;
-         }
-      }
-   }
-}
-
-
-
-/* Calculate islands while solving the board.
- */
-int boardHasIslands(char cell) {
-   /* Too low on board, don't bother checking */
-   if(cell >= 40)
-      return FALSE;
-   int current_triple = (board >> ((cell / 5) * 5)) & TRIPLE_MASK;
-   if((cell / 5) % 2)
-      return bad_odd_triple[current_triple];
-   else
-      return bad_even_triple[current_triple];
-}
-
-
-/* The recursive solve algorithm.  Try to place each permutation in the upper-
- * leftmost empty cell.  Mark off available pieces as it goes along.
- * Because the board is a bit mask, the piece number and bit mask must be saved
- * at each successful piece placement.  This data is used to create a 50 char
- * array if a solution is found.
- */
-short avail = 0x03FF;
-char sol_nums[10];
-unsigned long long sol_masks[10];
-signed char solutions[2100][50];
-int solution_count = 0;
-int max_solutions = 2100;
-
-void record_solution(void) {
-   int sol_no, index;
-   unsigned long long sol_mask;
-   for(sol_no = 0; sol_no < 10; sol_no++) {
-      sol_mask = sol_masks[sol_no];
-      for(index = 0; index < 50; index++) {
-         if(sol_mask & 1ULL) {
-            solutions[solution_count][index] = sol_nums[sol_no];
-            /* Board rotated 180 degrees is a solution too! */
-            solutions[solution_count+1][49-index] = sol_nums[sol_no];
-         }
-         sol_mask = sol_mask >> 1;
-      }
-   }
-   solution_count += 2;
-}
-
-void solve(int depth, int cell) {
-   int piece, rotation, max_rots;
-   unsigned long long *piece_mask;
-   short piece_no_mask;
-
-   if(solution_count >= max_solutions)
-      return;
-
-   while(board & (1ULL << cell))
-      cell++;
-
-   for(piece = 0; piece < 10; piece++) {
-      piece_no_mask = 1 << piece;
-      if(!(avail & piece_no_mask))
-         continue;
-      avail ^= piece_no_mask;
-      max_rots = piece_counts[piece][cell];
-      piece_mask = pieces[piece][cell];
-      for(rotation = 0; rotation < max_rots; rotation++) {
-         if(!(board & *(piece_mask + rotation))) {
-            sol_nums[depth] = piece;
-            sol_masks[depth] = *(piece_mask + rotation);
-            if(depth == 9) {
-               /* Solution found!!!!!11!!ONE! */
-               record_solution();
-               avail ^= piece_no_mask;
-               return;
-            }
-            board |= *(piece_mask + rotation);
-            if(!boardHasIslands(next_cell[piece][cell][rotation]))
-               solve(depth + 1, next_cell[piece][cell][rotation]);
-            board ^= *(piece_mask + rotation);
-         }
-      }
-      avail ^= piece_no_mask;
-   }
-}
-
-
-/* qsort comparator - used to find first and last solutions */
-int solution_sort(const void *elem1, const void *elem2) {
-   signed char *char1 = (signed char *) elem1;
-   signed char *char2 = (signed char *) elem2;
-   int i = 0;
-   while(i < 50 && char1[i] == char2[i])
-      i++;
-   return char1[i] - char2[i];
-}
-
-
-/* pretty print a board in the specified hexagonal format */
-void pretty(signed char *b) {
-   int i;
-   for(i = 0; i < 50; i += 10) {
-      printf("%c %c %c %c %c \n %c %c %c %c %c \n", b[i]+'0', b[i+1]+'0',
-            b[i+2]+'0', b[i+3]+'0', b[i+4]+'0', b[i+5]+'0', b[i+6]+'0',
-            b[i+7]+'0', b[i+8]+'0', b[i+9]+'0');
-   }
-   printf("\n");
-}
-
-int main(int argc, char **argv) {
-   if(argc > 1)
-      max_solutions = atoi(argv[1]);
-   calc_pieces();
-   calc_rows();
-   solve(0, 0);
-   printf("%d solutions found\n\n", solution_count);
-   qsort(solutions, solution_count, 50 * sizeof(signed char), solution_sort);
-   pretty(solutions[0]);
-   pretty(solutions[solution_count-1]);
-   return 0;
-}
diff --git a/test/bench/shootout/meteor-contest.go b/test/bench/shootout/meteor-contest.go
deleted file mode 100644
index 34a4e23f97..0000000000
--- a/test/bench/shootout/meteor-contest.go
+++ /dev/null
@@ -1,656 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by The Go Authors.
- * based on meteor-contest.c by Christian Vosteen
- */
-
-package main
-
-import (
-	"flag"
-	"fmt"
-)
-
-var max_solutions = flag.Int("n", 2100, "maximum number of solutions")
-
-func boolInt(b bool) int8 {
-	if b {
-		return 1
-	}
-	return 0
-}
-
-/* The board is a 50 cell hexagonal pattern.  For    . . . . .
- * maximum speed the board will be implemented as     . . . . .
- * 50 bits, which will fit into a 64 bit long long   . . . . .
- * int.                                               . . . . .
- *                                                   . . . . .
- * I will represent 0's as empty cells and 1's        . . . . .
- * as full cells.                                    . . . . .
- *                                                    . . . . .
- *                                                   . . . . .
- *                                                    . . . . .
- */
-
-var board uint64 = 0xFFFC000000000000
-
-/* The puzzle pieces must be specified by the path followed
- * from one end to the other along 12 hexagonal directions.
- *
- *   Piece 0   Piece 1   Piece 2   Piece 3   Piece 4
- *
- *  O O O O    O   O O   O O O     O O O     O   O
- *         O    O O           O       O       O O
- *                           O         O         O
- *
- *   Piece 5   Piece 6   Piece 7   Piece 8   Piece 9
- *
- *    O O O     O O       O O     O O        O O O O
- *       O O       O O       O       O O O        O
- *                  O       O O
- *
- * I had to make it 12 directions because I wanted all of the
- * piece definitions to fit into the same size arrays.  It is
- * not possible to define piece 4 in terms of the 6 cardinal
- * directions in 4 moves.
- */
-
-const (
-	E = iota
-	ESE
-	SE
-	S
-	SW
-	WSW
-	W
-	WNW
-	NW
-	N
-	NE
-	ENE
-	PIVOT
-)
-
-var piece_def = [10][4]int8{
-	[4]int8{E, E, E, SE},
-	[4]int8{SE, E, NE, E},
-	[4]int8{E, E, SE, SW},
-	[4]int8{E, E, SW, SE},
-	[4]int8{SE, E, NE, S},
-	[4]int8{E, E, SW, E},
-	[4]int8{E, SE, SE, NE},
-	[4]int8{E, SE, SE, W},
-	[4]int8{E, SE, E, E},
-	[4]int8{E, E, E, SW},
-}
-
-/* To minimize the amount of work done in the recursive solve function below,
- * I'm going to allocate enough space for all legal rotations of each piece
- * at each position on the board. That's 10 pieces x 50 board positions x
- * 12 rotations.  However, not all 12 rotations will fit on every cell, so
- * I'll have to keep count of the actual number that do.
- * The pieces are going to be unsigned long long ints just like the board so
- * they can be bitwise-anded with the board to determine if they fit.
- * I'm also going to record the next possible open cell for each piece and
- * location to reduce the burden on the solve function.
- */
-var (
-	pieces       [10][50][12]uint64
-	piece_counts [10][50]int
-	next_cell    [10][50][12]int8
-)
-
-/* Returns the direction rotated 60 degrees clockwise */
-func rotate(dir int8) int8 { return (dir + 2) % PIVOT }
-
-/* Returns the direction flipped on the horizontal axis */
-func flip(dir int8) int8 { return (PIVOT - dir) % PIVOT }
-
-/* Returns the new cell index from the specified cell in the
- * specified direction.  The index is only valid if the
- * starting cell and direction have been checked by the
- * out_of_bounds function first.
- */
-func shift(cell, dir int8) int8 {
-	switch dir {
-	case E:
-		return cell + 1
-	case ESE:
-		if ((cell / 5) % 2) != 0 {
-			return cell + 7
-		} else {
-			return cell + 6
-		}
-	case SE:
-		if ((cell / 5) % 2) != 0 {
-			return cell + 6
-		} else {
-			return cell + 5
-		}
-	case S:
-		return cell + 10
-	case SW:
-		if ((cell / 5) % 2) != 0 {
-			return cell + 5
-		} else {
-			return cell + 4
-		}
-	case WSW:
-		if ((cell / 5) % 2) != 0 {
-			return cell + 4
-		} else {
-			return cell + 3
-		}
-	case W:
-		return cell - 1
-	case WNW:
-		if ((cell / 5) % 2) != 0 {
-			return cell - 6
-		} else {
-			return cell - 7
-		}
-	case NW:
-		if ((cell / 5) % 2) != 0 {
-			return cell - 5
-		} else {
-			return cell - 6
-		}
-	case N:
-		return cell - 10
-	case NE:
-		if ((cell / 5) % 2) != 0 {
-			return cell - 4
-		} else {
-			return cell - 5
-		}
-	case ENE:
-		if ((cell / 5) % 2) != 0 {
-			return cell - 3
-		} else {
-			return cell - 4
-		}
-	}
-	return cell
-}
-
-/* Returns wether the specified cell and direction will land outside
- * of the board.  Used to determine if a piece is at a legal board
- * location or not.
- */
-func out_of_bounds(cell, dir int8) bool {
-	switch dir {
-	case E:
-		return cell%5 == 4
-	case ESE:
-		i := cell % 10
-		return i == 4 || i == 8 || i == 9 || cell >= 45
-	case SE:
-		return cell%10 == 9 || cell >= 45
-	case S:
-		return cell >= 40
-	case SW:
-		return cell%10 == 0 || cell >= 45
-	case WSW:
-		i := cell % 10
-		return i == 0 || i == 1 || i == 5 || cell >= 45
-	case W:
-		return cell%5 == 0
-	case WNW:
-		i := cell % 10
-		return i == 0 || i == 1 || i == 5 || cell < 5
-	case NW:
-		return cell%10 == 0 || cell < 5
-	case N:
-		return cell < 10
-	case NE:
-		return cell%10 == 9 || cell < 5
-	case ENE:
-		i := cell % 10
-		return i == 4 || i == 8 || i == 9 || cell < 5
-	}
-	return false
-}
-
-/* Rotate a piece 60 degrees clockwise */
-func rotate_piece(piece int) {
-	for i := 0; i < 4; i++ {
-		piece_def[piece][i] = rotate(piece_def[piece][i])
-	}
-}
-
-/* Flip a piece along the horizontal axis */
-func flip_piece(piece int) {
-	for i := 0; i < 4; i++ {
-		piece_def[piece][i] = flip(piece_def[piece][i])
-	}
-}
-
-/* Convenience function to quickly calculate all of the indices for a piece */
-func calc_cell_indices(cell []int8, piece int, index int8) {
-	cell[0] = index
-	for i := 1; i < 5; i++ {
-		cell[i] = shift(cell[i-1], piece_def[piece][i-1])
-	}
-}
-
-/* Convenience function to quickly calculate if a piece fits on the board */
-func cells_fit_on_board(cell []int8, piece int) bool {
-	return !out_of_bounds(cell[0], piece_def[piece][0]) &&
-		!out_of_bounds(cell[1], piece_def[piece][1]) &&
-		!out_of_bounds(cell[2], piece_def[piece][2]) &&
-		!out_of_bounds(cell[3], piece_def[piece][3])
-}
-
-/* Returns the lowest index of the cells of a piece.
- * I use the lowest index that a piece occupies as the index for looking up
- * the piece in the solve function.
- */
-func minimum_of_cells(cell []int8) int8 {
-	minimum := cell[0]
-	for i := 1; i < 5; i++ {
-		if cell[i] < minimum {
-			minimum = cell[i]
-		}
-	}
-	return minimum
-}
-
-/* Calculate the lowest possible open cell if the piece is placed on the board.
- * Used to later reduce the amount of time searching for open cells in the
- * solve function.
- */
-func first_empty_cell(cell []int8, minimum int8) int8 {
-	first_empty := minimum
-	for first_empty == cell[0] || first_empty == cell[1] ||
-		first_empty == cell[2] || first_empty == cell[3] ||
-		first_empty == cell[4] {
-		first_empty++
-	}
-	return first_empty
-}
-
-/* Generate the unsigned long long int that will later be anded with the
- * board to determine if it fits.
- */
-func bitmask_from_cells(cell []int8) uint64 {
-	var piece_mask uint64
-	for i := 0; i < 5; i++ {
-		piece_mask |= 1 << uint(cell[i])
-	}
-	return piece_mask
-}
-
-/* Record the piece and other important information in arrays that will
- * later be used by the solve function.
- */
-func record_piece(piece int, minimum int8, first_empty int8, piece_mask uint64) {
-	pieces[piece][minimum][piece_counts[piece][minimum]] = piece_mask
-	next_cell[piece][minimum][piece_counts[piece][minimum]] = first_empty
-	piece_counts[piece][minimum]++
-}
-
-/* Fill the entire board going cell by cell.  If any cells are "trapped"
- * they will be left alone.
- */
-func fill_contiguous_space(board []int8, index int8) {
-	if board[index] == 1 {
-		return
-	}
-	board[index] = 1
-	if !out_of_bounds(index, E) {
-		fill_contiguous_space(board, shift(index, E))
-	}
-	if !out_of_bounds(index, SE) {
-		fill_contiguous_space(board, shift(index, SE))
-	}
-	if !out_of_bounds(index, SW) {
-		fill_contiguous_space(board, shift(index, SW))
-	}
-	if !out_of_bounds(index, W) {
-		fill_contiguous_space(board, shift(index, W))
-	}
-	if !out_of_bounds(index, NW) {
-		fill_contiguous_space(board, shift(index, NW))
-	}
-	if !out_of_bounds(index, NE) {
-		fill_contiguous_space(board, shift(index, NE))
-	}
-}
-
-/* To thin the number of pieces, I calculate if any of them trap any empty
- * cells at the edges.  There are only a handful of exceptions where the
- * the board can be solved with the trapped cells.  For example:  piece 8 can
- * trap 5 cells in the corner, but piece 3 can fit in those cells, or piece 0
- * can split the board in half where both halves are viable.
- */
-func has_island(cell []int8, piece int) bool {
-	temp_board := make([]int8, 50)
-	var i int
-	for i = 0; i < 5; i++ {
-		temp_board[cell[i]] = 1
-	}
-	i = 49
-	for temp_board[i] == 1 {
-		i--
-	}
-	fill_contiguous_space(temp_board, int8(i))
-	c := 0
-	for i = 0; i < 50; i++ {
-		if temp_board[i] == 0 {
-			c++
-		}
-	}
-	if c == 0 || (c == 5 && piece == 8) || (c == 40 && piece == 8) ||
-		(c%5 == 0 && piece == 0) {
-		return false
-	}
-	return true
-}
-
-/* Calculate all six rotations of the specified piece at the specified index.
- * We calculate only half of piece 3's rotations.  This is because any solution
- * found has an identical solution rotated 180 degrees.  Thus we can reduce the
- * number of attempted pieces in the solve algorithm by not including the 180-
- * degree-rotated pieces of ONE of the pieces.  I chose piece 3 because it gave
- * me the best time ;)
- */
-func calc_six_rotations(piece, index int) {
-	cell := make([]int8, 5)
-	for rotation := 0; rotation < 6; rotation++ {
-		if piece != 3 || rotation < 3 {
-			calc_cell_indices(cell, piece, int8(index))
-			if cells_fit_on_board(cell, piece) && !has_island(cell, piece) {
-				minimum := minimum_of_cells(cell)
-				first_empty := first_empty_cell(cell, minimum)
-				piece_mask := bitmask_from_cells(cell)
-				record_piece(piece, minimum, first_empty, piece_mask)
-			}
-		}
-		rotate_piece(piece)
-	}
-}
-
-/* Calculate every legal rotation for each piece at each board location. */
-func calc_pieces() {
-	for piece := 0; piece < 10; piece++ {
-		for index := 0; index < 50; index++ {
-			calc_six_rotations(piece, index)
-			flip_piece(piece)
-			calc_six_rotations(piece, index)
-		}
-	}
-}
-
-/* Calculate all 32 possible states for a 5-bit row and all rows that will
- * create islands that follow any of the 32 possible rows.  These pre-
- * calculated 5-bit rows will be used to find islands in a partially solved
- * board in the solve function.
- */
-const (
-	ROW_MASK    = 0x1F
-	TRIPLE_MASK = 0x7FFF
-)
-
-var (
-	all_rows = [32]int8{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
-		17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
-	}
-	bad_even_rows   [32][32]int8
-	bad_odd_rows    [32][32]int8
-	bad_even_triple [32768]int8
-	bad_odd_triple  [32768]int8
-)
-
-func rows_bad(row1, row2 int8, even bool) int8 {
-	/* even is referring to row1 */
-	var row2_shift int8
-	/* Test for blockages at same index and shifted index */
-	if even {
-		row2_shift = ((row2 << 1) & ROW_MASK) | 0x01
-	} else {
-		row2_shift = (row2 >> 1) | 0x10
-	}
-	block := ((row1 ^ row2) & row2) & ((row1 ^ row2_shift) & row2_shift)
-	/* Test for groups of 0's */
-	in_zeroes := false
-	group_okay := false
-	for i := uint8(0); i < 5; i++ {
-		if row1&(1<<i) != 0 {
-			if in_zeroes {
-				if !group_okay {
-					return 1
-				}
-				in_zeroes = false
-				group_okay = false
-			}
-		} else {
-			if !in_zeroes {
-				in_zeroes = true
-			}
-			if (block & (1 << i)) == 0 {
-				group_okay = true
-			}
-		}
-	}
-	if in_zeroes {
-		return boolInt(!group_okay)
-	}
-	return 0
-}
-
-/* Check for cases where three rows checked sequentially cause a false
- * positive.  One scenario is when 5 cells may be surrounded where piece 5
- * or 7 can fit.  The other scenario is when piece 2 creates a hook shape.
- */
-func triple_is_okay(row1, row2, row3 int, even bool) bool {
-	if even {
-		/* There are four cases:
-		 * row1: 00011  00001  11001  10101
-		 * row2: 01011  00101  10001  10001
-		 * row3: 011??  00110  ?????  ?????
-		 */
-		return ((row1 == 0x03) && (row2 == 0x0B) && ((row3 & 0x1C) == 0x0C)) ||
-			((row1 == 0x01) && (row2 == 0x05) && (row3 == 0x06)) ||
-			((row1 == 0x19) && (row2 == 0x11)) ||
-			((row1 == 0x15) && (row2 == 0x11))
-	}
-	/* There are two cases:
-	 * row1: 10011  10101
-	 * row2: 10001  10001
-	 * row3: ?????  ?????
-	 */
-	return ((row1 == 0x13) && (row2 == 0x11)) ||
-		((row1 == 0x15) && (row2 == 0x11))
-}
-
-func calc_rows() {
-	for row1 := int8(0); row1 < 32; row1++ {
-		for row2 := int8(0); row2 < 32; row2++ {
-			bad_even_rows[row1][row2] = rows_bad(row1, row2, true)
-			bad_odd_rows[row1][row2] = rows_bad(row1, row2, false)
-		}
-	}
-	for row1 := 0; row1 < 32; row1++ {
-		for row2 := 0; row2 < 32; row2++ {
-			for row3 := 0; row3 < 32; row3++ {
-				result1 := bad_even_rows[row1][row2]
-				result2 := bad_odd_rows[row2][row3]
-				if result1 == 0 && result2 != 0 && triple_is_okay(row1, row2, row3, true) {
-					bad_even_triple[row1+(row2*32)+(row3*1024)] = 0
-				} else {
-					bad_even_triple[row1+(row2*32)+(row3*1024)] = boolInt(result1 != 0 || result2 != 0)
-				}
-
-				result1 = bad_odd_rows[row1][row2]
-				result2 = bad_even_rows[row2][row3]
-				if result1 == 0 && result2 != 0 && triple_is_okay(row1, row2, row3, false) {
-					bad_odd_triple[row1+(row2*32)+(row3*1024)] = 0
-				} else {
-					bad_odd_triple[row1+(row2*32)+(row3*1024)] = boolInt(result1 != 0 || result2 != 0)
-				}
-			}
-		}
-	}
-}
-
-/* Calculate islands while solving the board.
- */
-func boardHasIslands(cell int8) int8 {
-	/* Too low on board, don't bother checking */
-	if cell >= 40 {
-		return 0
-	}
-	current_triple := (board >> uint((cell/5)*5)) & TRIPLE_MASK
-	if (cell/5)%2 != 0 {
-		return bad_odd_triple[current_triple]
-	}
-	return bad_even_triple[current_triple]
-}
-
-/* The recursive solve algorithm.  Try to place each permutation in the upper-
- * leftmost empty cell.  Mark off available pieces as it goes along.
- * Because the board is a bit mask, the piece number and bit mask must be saved
- * at each successful piece placement.  This data is used to create a 50 char
- * array if a solution is found.
- */
-var (
-	avail          uint16 = 0x03FF
-	sol_nums       [10]int8
-	sol_masks      [10]uint64
-	solutions      [2100][50]int8
-	solution_count = 0
-)
-
-func record_solution() {
-	for sol_no := 0; sol_no < 10; sol_no++ {
-		sol_mask := sol_masks[sol_no]
-		for index := 0; index < 50; index++ {
-			if sol_mask&1 == 1 {
-				solutions[solution_count][index] = sol_nums[sol_no]
-				/* Board rotated 180 degrees is a solution too! */
-				solutions[solution_count+1][49-index] = sol_nums[sol_no]
-			}
-			sol_mask = sol_mask >> 1
-		}
-	}
-	solution_count += 2
-}
-
-func solve(depth, cell int8) {
-	if solution_count >= *max_solutions {
-		return
-	}
-
-	for board&(1<<uint(cell)) != 0 {
-		cell++
-	}
-
-	for piece := int8(0); piece < 10; piece++ {
-		var piece_no_mask uint16 = 1 << uint(piece)
-		if avail&piece_no_mask == 0 {
-			continue
-		}
-		avail ^= piece_no_mask
-		max_rots := piece_counts[piece][cell]
-		piece_mask := pieces[piece][cell]
-		for rotation := 0; rotation < max_rots; rotation++ {
-			if board&piece_mask[rotation] == 0 {
-				sol_nums[depth] = piece
-				sol_masks[depth] = piece_mask[rotation]
-				if depth == 9 {
-					/* Solution found!!!!!11!!ONE! */
-					record_solution()
-					avail ^= piece_no_mask
-					return
-				}
-				board |= piece_mask[rotation]
-				if boardHasIslands(next_cell[piece][cell][rotation]) == 0 {
-					solve(depth+1, next_cell[piece][cell][rotation])
-				}
-				board ^= piece_mask[rotation]
-			}
-		}
-		avail ^= piece_no_mask
-	}
-}
-
-/* pretty print a board in the specified hexagonal format */
-func pretty(b *[50]int8) {
-	for i := 0; i < 50; i += 10 {
-		fmt.Printf("%c %c %c %c %c \n %c %c %c %c %c \n", b[i]+'0', b[i+1]+'0',
-			b[i+2]+'0', b[i+3]+'0', b[i+4]+'0', b[i+5]+'0', b[i+6]+'0',
-			b[i+7]+'0', b[i+8]+'0', b[i+9]+'0')
-	}
-	fmt.Printf("\n")
-}
-
-/* Find smallest and largest solutions */
-func smallest_largest() (smallest, largest *[50]int8) {
-	smallest = &solutions[0]
-	largest = &solutions[0]
-	for i := 1; i < solution_count; i++ {
-		candidate := &solutions[i]
-		for j, s := range *smallest {
-			c := candidate[j]
-			if c == s {
-				continue
-			}
-			if c < s {
-				smallest = candidate
-			}
-			break
-		}
-		for j, s := range *largest {
-			c := candidate[j]
-			if c == s {
-				continue
-			}
-			if c > s {
-				largest = candidate
-			}
-			break
-		}
-	}
-	return
-}
-
-func main() {
-	flag.Parse()
-	calc_pieces()
-	calc_rows()
-	solve(0, 0)
-	fmt.Printf("%d solutions found\n\n", solution_count)
-	smallest, largest := smallest_largest()
-	pretty(smallest)
-	pretty(largest)
-}
diff --git a/test/bench/shootout/meteor-contest.txt b/test/bench/shootout/meteor-contest.txt
deleted file mode 100644
index 38d9783d64..0000000000
--- a/test/bench/shootout/meteor-contest.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-2098 solutions found
-
-0 0 0 0 1 
- 2 2 2 0 1 
-2 6 6 1 1 
- 2 6 1 5 5 
-8 6 5 5 5 
- 8 6 3 3 3 
-4 8 8 9 3 
- 4 4 8 9 3 
-4 7 4 7 9 
- 7 7 7 9 9 
-
-9 9 9 9 8 
- 9 6 6 8 5 
-6 6 8 8 5 
- 6 8 2 5 5 
-7 7 7 2 5 
- 7 4 7 2 0 
-1 4 2 2 0 
- 1 4 4 0 3 
-1 4 0 0 3 
- 1 1 3 3 3 
-
diff --git a/test/bench/shootout/nbody.c b/test/bench/shootout/nbody.c
deleted file mode 100644
index 3b95b05929..0000000000
--- a/test/bench/shootout/nbody.c
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*
- * The Great Computer Language Shootout
- * http://shootout.alioth.debian.org/
- *
- * contributed by Christoph Bauer
- *
- */
-
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-#define pi 3.141592653589793
-#define solar_mass (4 * pi * pi)
-#define days_per_year 365.24
-
-struct planet {
-  double x, y, z;
-  double vx, vy, vz;
-  double mass;
-};
-
-void advance(int nbodies, struct planet * bodies, double dt)
-{
-  int i, j;
-
-  for (i = 0; i < nbodies; i++) {
-    struct planet * b = &(bodies[i]);
-    for (j = i + 1; j < nbodies; j++) {
-      struct planet * b2 = &(bodies[j]);
-      double dx = b->x - b2->x;
-      double dy = b->y - b2->y;
-      double dz = b->z - b2->z;
-      double distance = sqrt(dx * dx + dy * dy + dz * dz);
-      double mag = dt / (distance * distance * distance);
-      b->vx -= dx * b2->mass * mag;
-      b->vy -= dy * b2->mass * mag;
-      b->vz -= dz * b2->mass * mag;
-      b2->vx += dx * b->mass * mag;
-      b2->vy += dy * b->mass * mag;
-      b2->vz += dz * b->mass * mag;
-    }
-  }
-  for (i = 0; i < nbodies; i++) {
-    struct planet * b = &(bodies[i]);
-    b->x += dt * b->vx;
-    b->y += dt * b->vy;
-    b->z += dt * b->vz;
-  }
-}
-
-double energy(int nbodies, struct planet * bodies)
-{
-  double e;
-  int i, j;
-
-  e = 0.0;
-  for (i = 0; i < nbodies; i++) {
-    struct planet * b = &(bodies[i]);
-    e += 0.5 * b->mass * (b->vx * b->vx + b->vy * b->vy + b->vz * b->vz);
-    for (j = i + 1; j < nbodies; j++) {
-      struct planet * b2 = &(bodies[j]);
-      double dx = b->x - b2->x;
-      double dy = b->y - b2->y;
-      double dz = b->z - b2->z;
-      double distance = sqrt(dx * dx + dy * dy + dz * dz);
-      e -= (b->mass * b2->mass) / distance;
-    }
-  }
-  return e;
-}
-
-void offset_momentum(int nbodies, struct planet * bodies)
-{
-  double px = 0.0, py = 0.0, pz = 0.0;
-  int i;
-  for (i = 0; i < nbodies; i++) {
-    px += bodies[i].vx * bodies[i].mass;
-    py += bodies[i].vy * bodies[i].mass;
-    pz += bodies[i].vz * bodies[i].mass;
-  }
-  bodies[0].vx = - px / solar_mass;
-  bodies[0].vy = - py / solar_mass;
-  bodies[0].vz = - pz / solar_mass;
-}
-
-#define NBODIES 5
-struct planet bodies[NBODIES] = {
-  {                               /* sun */
-    0, 0, 0, 0, 0, 0, solar_mass
-  },
-  {                               /* jupiter */
-    4.84143144246472090e+00,
-    -1.16032004402742839e+00,
-    -1.03622044471123109e-01,
-    1.66007664274403694e-03 * days_per_year,
-    7.69901118419740425e-03 * days_per_year,
-    -6.90460016972063023e-05 * days_per_year,
-    9.54791938424326609e-04 * solar_mass
-  },
-  {                               /* saturn */
-    8.34336671824457987e+00,
-    4.12479856412430479e+00,
-    -4.03523417114321381e-01,
-    -2.76742510726862411e-03 * days_per_year,
-    4.99852801234917238e-03 * days_per_year,
-    2.30417297573763929e-05 * days_per_year,
-    2.85885980666130812e-04 * solar_mass
-  },
-  {                               /* uranus */
-    1.28943695621391310e+01,
-    -1.51111514016986312e+01,
-    -2.23307578892655734e-01,
-    2.96460137564761618e-03 * days_per_year,
-    2.37847173959480950e-03 * days_per_year,
-    -2.96589568540237556e-05 * days_per_year,
-    4.36624404335156298e-05 * solar_mass
-  },
-  {                               /* neptune */
-    1.53796971148509165e+01,
-    -2.59193146099879641e+01,
-    1.79258772950371181e-01,
-    2.68067772490389322e-03 * days_per_year,
-    1.62824170038242295e-03 * days_per_year,
-    -9.51592254519715870e-05 * days_per_year,
-    5.15138902046611451e-05 * solar_mass
-  }
-};
-
-int main(int argc, char ** argv)
-{
-  int n = atoi(argv[1]);
-  int i;
-
-  offset_momentum(NBODIES, bodies);
-  printf ("%.9f\n", energy(NBODIES, bodies));
-  for (i = 1; i <= n; i++)
-    advance(NBODIES, bodies, 0.01);
-  printf ("%.9f\n", energy(NBODIES, bodies));
-  return 0;
-}
diff --git a/test/bench/shootout/nbody.go b/test/bench/shootout/nbody.go
deleted file mode 100644
index 988f3ba9cc..0000000000
--- a/test/bench/shootout/nbody.go
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by The Go Authors.
- * based on C program by Christoph Bauer
- */
-
-package main
-
-import (
-	"flag"
-	"fmt"
-	"math"
-)
-
-var n = flag.Int("n", 1000, "number of iterations")
-
-type Body struct {
-	x, y, z, vx, vy, vz, mass float64
-}
-
-const (
-	solarMass   = 4 * math.Pi * math.Pi
-	daysPerYear = 365.24
-)
-
-func (b *Body) offsetMomentum(px, py, pz float64) {
-	b.vx = -px / solarMass
-	b.vy = -py / solarMass
-	b.vz = -pz / solarMass
-}
-
-type System []*Body
-
-func NewSystem(body []Body) System {
-	n := make(System, len(body))
-	for i := 0; i < len(body); i++ {
-		n[i] = new(Body) // copy to avoid overwriting the inputs
-		*n[i] = body[i]
-	}
-	var px, py, pz float64
-	for _, body := range n {
-		px += body.vx * body.mass
-		py += body.vy * body.mass
-		pz += body.vz * body.mass
-	}
-	n[0].offsetMomentum(px, py, pz)
-	return n
-}
-
-func (sys System) energy() float64 {
-	var e float64
-	for i, body := range sys {
-		e += 0.5 * body.mass *
-			(body.vx*body.vx + body.vy*body.vy + body.vz*body.vz)
-		for j := i + 1; j < len(sys); j++ {
-			body2 := sys[j]
-			dx := body.x - body2.x
-			dy := body.y - body2.y
-			dz := body.z - body2.z
-			distance := math.Sqrt(dx*dx + dy*dy + dz*dz)
-			e -= (body.mass * body2.mass) / distance
-		}
-	}
-	return e
-}
-
-func (sys System) advance(dt float64) {
-	for i, body := range sys {
-		for j := i + 1; j < len(sys); j++ {
-			body2 := sys[j]
-			dx := body.x - body2.x
-			dy := body.y - body2.y
-			dz := body.z - body2.z
-
-			dSquared := dx*dx + dy*dy + dz*dz
-			distance := math.Sqrt(dSquared)
-			mag := dt / (dSquared * distance)
-
-			body.vx -= dx * body2.mass * mag
-			body.vy -= dy * body2.mass * mag
-			body.vz -= dz * body2.mass * mag
-
-			body2.vx += dx * body.mass * mag
-			body2.vy += dy * body.mass * mag
-			body2.vz += dz * body.mass * mag
-		}
-	}
-
-	for _, body := range sys {
-		body.x += dt * body.vx
-		body.y += dt * body.vy
-		body.z += dt * body.vz
-	}
-}
-
-var (
-	jupiter = Body{
-		x:    4.84143144246472090e+00,
-		y:    -1.16032004402742839e+00,
-		z:    -1.03622044471123109e-01,
-		vx:   1.66007664274403694e-03 * daysPerYear,
-		vy:   7.69901118419740425e-03 * daysPerYear,
-		vz:   -6.90460016972063023e-05 * daysPerYear,
-		mass: 9.54791938424326609e-04 * solarMass,
-	}
-	saturn = Body{
-		x:    8.34336671824457987e+00,
-		y:    4.12479856412430479e+00,
-		z:    -4.03523417114321381e-01,
-		vx:   -2.76742510726862411e-03 * daysPerYear,
-		vy:   4.99852801234917238e-03 * daysPerYear,
-		vz:   2.30417297573763929e-05 * daysPerYear,
-		mass: 2.85885980666130812e-04 * solarMass,
-	}
-	uranus = Body{
-		x:    1.28943695621391310e+01,
-		y:    -1.51111514016986312e+01,
-		z:    -2.23307578892655734e-01,
-		vx:   2.96460137564761618e-03 * daysPerYear,
-		vy:   2.37847173959480950e-03 * daysPerYear,
-		vz:   -2.96589568540237556e-05 * daysPerYear,
-		mass: 4.36624404335156298e-05 * solarMass,
-	}
-	neptune = Body{
-		x:    1.53796971148509165e+01,
-		y:    -2.59193146099879641e+01,
-		z:    1.79258772950371181e-01,
-		vx:   2.68067772490389322e-03 * daysPerYear,
-		vy:   1.62824170038242295e-03 * daysPerYear,
-		vz:   -9.51592254519715870e-05 * daysPerYear,
-		mass: 5.15138902046611451e-05 * solarMass,
-	}
-	sun = Body{
-		mass: solarMass,
-	}
-)
-
-func main() {
-	flag.Parse()
-
-	system := NewSystem([]Body{sun, jupiter, saturn, uranus, neptune})
-	fmt.Printf("%.9f\n", system.energy())
-	for i := 0; i < *n; i++ {
-		system.advance(0.01)
-	}
-	fmt.Printf("%.9f\n", system.energy())
-}
diff --git a/test/bench/shootout/nbody.txt b/test/bench/shootout/nbody.txt
deleted file mode 100644
index 1731557ce1..0000000000
--- a/test/bench/shootout/nbody.txt
+++ /dev/null
@@ -1,2 +0,0 @@
--0.169075164
--0.169087605
diff --git a/test/bench/shootout/pidigits.c b/test/bench/shootout/pidigits.c
deleted file mode 100644
index c064da0dd2..0000000000
--- a/test/bench/shootout/pidigits.c
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
-  http://shootout.alioth.debian.org/
-
-  contributed by Paolo Bonzini & Sean Bartlett
-  modified by Michael Mellor
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <gmp.h>
-
-static mpz_t numer, accum, denom, tmp1, tmp2;
-
-static int extract_digit()
-{
-  if (mpz_cmp(numer, accum) > 0)
-    return -1;
-
-  /* Compute (numer * 3 + accum) / denom */
-  mpz_mul_2exp(tmp1, numer, 1);
-  mpz_add(tmp1, tmp1, numer);
-  mpz_add(tmp1, tmp1, accum);
-  mpz_fdiv_qr(tmp1, tmp2, tmp1, denom);
-
-  /* Now, if (numer * 4 + accum) % denom... */
-  mpz_add(tmp2, tmp2, numer);
-
-  /* ... is normalized, then the two divisions have the same result.  */
-  if (mpz_cmp(tmp2, denom) >= 0)
-    return -1;
-
-  return mpz_get_ui(tmp1);
-}
-
-static void next_term(unsigned int k)
-{
-  unsigned int y2 = k*2 + 1;
-
-  mpz_mul_2exp(tmp1, numer, 1);
-  mpz_add(accum, accum, tmp1);
-  mpz_mul_ui(accum, accum, y2);
-  mpz_mul_ui(numer, numer, k);
-  mpz_mul_ui(denom, denom, y2);
-}
-
-static void eliminate_digit(unsigned int d)
-{
-  mpz_submul_ui(accum, denom, d);
-  mpz_mul_ui(accum, accum, 10);
-  mpz_mul_ui(numer, numer, 10);
-}
-
-static void pidigits(unsigned int n)
-{
-  int d;
-  unsigned int i = 0, k = 0, m;
-  mpz_init(tmp1);
-  mpz_init(tmp2);
-  mpz_init_set_ui(numer, 1);
-  mpz_init_set_ui(accum, 0);
-  mpz_init_set_ui(denom, 1);
-
-  for(;;)
-  {
-    do {
-      k++;
-      next_term(k);
-      d = extract_digit();
-    } while(d == -1);
-
-    putchar(d + '0');
-
-    i++;
-    m = i%10;
-    if(m == 0)
-      printf("\t:%d\n", i);
-    if(i >= n)
-      break;
-    eliminate_digit(d);
-  }
-
-  if(m) {
-    m = 10 - m;
-    while(m--)
-      putchar(' ');
-    printf("\t:%d\n", n);
-  }
-}
-
-int main(int argc, char **argv)
-{
-  pidigits(argc > 1 ? atoi(argv[1]) : 27);
-  return 0;
-}
diff --git a/test/bench/shootout/pidigits.go b/test/bench/shootout/pidigits.go
deleted file mode 100644
index a0f21a91db..0000000000
--- a/test/bench/shootout/pidigits.go
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by The Go Authors.
- * based on pidigits.c (by Paolo Bonzini & Sean Bartlett,
- *                      modified by Michael Mellor)
- */
-
-package main
-
-import (
-	"flag"
-	"fmt"
-	"math/big"
-)
-
-var n = flag.Int("n", 27, "number of digits")
-var silent = flag.Bool("s", false, "don't print result")
-
-var (
-	tmp1  = big.NewInt(0)
-	tmp2  = big.NewInt(0)
-	tmp3  = big.NewInt(0)
-	y2    = big.NewInt(0)
-	bigk  = big.NewInt(0)
-	numer = big.NewInt(1)
-	accum = big.NewInt(0)
-	denom = big.NewInt(1)
-	ten   = big.NewInt(10)
-)
-
-func extract_digit() int64 {
-	if numer.Cmp(accum) > 0 {
-		return -1
-	}
-
-	// Compute (numer * 3 + accum) / denom
-	tmp1.Lsh(numer, 1)
-	tmp1.Add(tmp1, numer)
-	tmp1.Add(tmp1, accum)
-	tmp1.DivMod(tmp1, denom, tmp2)
-
-	// Now, if (numer * 4 + accum) % denom...
-	tmp2.Add(tmp2, numer)
-
-	// ... is normalized, then the two divisions have the same result.
-	if tmp2.Cmp(denom) >= 0 {
-		return -1
-	}
-
-	return tmp1.Int64()
-}
-
-func next_term(k int64) {
-	y2.SetInt64(k*2 + 1)
-	bigk.SetInt64(k)
-
-	tmp1.Lsh(numer, 1)
-	accum.Add(accum, tmp1)
-	accum.Mul(accum, y2)
-	numer.Mul(numer, bigk)
-	denom.Mul(denom, y2)
-}
-
-func eliminate_digit(d int64) {
-	tmp3.SetInt64(d)
-	accum.Sub(accum, tmp3.Mul(denom, tmp3))
-	accum.Mul(accum, ten)
-	numer.Mul(numer, ten)
-}
-
-func printf(s string, arg ...interface{}) {
-	if !*silent {
-		fmt.Printf(s, arg...)
-	}
-}
-
-func main() {
-	flag.Parse()
-
-	var m int // 0 <= m < 10
-	for i, k := 0, int64(0); ; {
-		d := int64(-1)
-		for d < 0 {
-			k++
-			next_term(k)
-			d = extract_digit()
-		}
-
-		printf("%c", d+'0')
-
-		i++
-		m = i % 10
-		if m == 0 {
-			printf("\t:%d\n", i)
-		}
-		if i >= *n {
-			break
-		}
-		eliminate_digit(d)
-	}
-
-	if m > 0 {
-		printf("%s\t:%d\n", "          "[m:10], *n)
-	}
-}
diff --git a/test/bench/shootout/pidigits.txt b/test/bench/shootout/pidigits.txt
deleted file mode 100644
index ad946a9e85..0000000000
--- a/test/bench/shootout/pidigits.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-3141592653	:10
-5897932384	:20
-6264338   	:27
diff --git a/test/bench/shootout/regex-dna-parallel.go b/test/bench/shootout/regex-dna-parallel.go
deleted file mode 100644
index 9c6d42101d..0000000000
--- a/test/bench/shootout/regex-dna-parallel.go
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by The Go Authors.
- */
-
-package main
-
-import (
-	"fmt"
-	"io/ioutil"
-	"os"
-	"regexp"
-	"runtime"
-)
-
-var variants = []string{
-	"agggtaaa|tttaccct",
-	"[cgt]gggtaaa|tttaccc[acg]",
-	"a[act]ggtaaa|tttacc[agt]t",
-	"ag[act]gtaaa|tttac[agt]ct",
-	"agg[act]taaa|ttta[agt]cct",
-	"aggg[acg]aaa|ttt[cgt]ccct",
-	"agggt[cgt]aa|tt[acg]accct",
-	"agggta[cgt]a|t[acg]taccct",
-	"agggtaa[cgt]|[acg]ttaccct",
-}
-
-type Subst struct {
-	pat, repl string
-}
-
-var substs = []Subst{
-	Subst{"B", "(c|g|t)"},
-	Subst{"D", "(a|g|t)"},
-	Subst{"H", "(a|c|t)"},
-	Subst{"K", "(g|t)"},
-	Subst{"M", "(a|c)"},
-	Subst{"N", "(a|c|g|t)"},
-	Subst{"R", "(a|g)"},
-	Subst{"S", "(c|g)"},
-	Subst{"V", "(a|c|g)"},
-	Subst{"W", "(a|t)"},
-	Subst{"Y", "(c|t)"},
-}
-
-func countMatches(pat string, bytes []byte) int {
-	re := regexp.MustCompile(pat)
-	n := 0
-	for {
-		e := re.FindIndex(bytes)
-		if e == nil {
-			break
-		}
-		n++
-		bytes = bytes[e[1]:]
-	}
-	return n
-}
-
-func main() {
-	runtime.GOMAXPROCS(4)
-	bytes, err := ioutil.ReadAll(os.Stdin)
-	if err != nil {
-		fmt.Fprintf(os.Stderr, "can't read input: %s\n", err)
-		os.Exit(2)
-	}
-	ilen := len(bytes)
-	// Delete the comment lines and newlines
-	bytes = regexp.MustCompile("(>[^\n]+)?\n").ReplaceAll(bytes, []byte{})
-	clen := len(bytes)
-
-	mresults := make([]chan int, len(variants))
-	for i, s := range variants {
-		ch := make(chan int)
-		mresults[i] = ch
-		go func(ss string) {
-			ch <- countMatches(ss, bytes)
-		}(s)
-	}
-
-	lenresult := make(chan int)
-	bb := bytes
-	go func() {
-		for _, sub := range substs {
-			bb = regexp.MustCompile(sub.pat).ReplaceAll(bb, []byte(sub.repl))
-		}
-		lenresult <- len(bb)
-	}()
-
-	for i, s := range variants {
-		fmt.Printf("%s %d\n", s, <-mresults[i])
-	}
-	fmt.Printf("\n%d\n%d\n%d\n", ilen, clen, <-lenresult)
-}
diff --git a/test/bench/shootout/regex-dna-parallel.txt b/test/bench/shootout/regex-dna-parallel.txt
deleted file mode 100644
index e23e71fd6e..0000000000
--- a/test/bench/shootout/regex-dna-parallel.txt
+++ /dev/null
@@ -1,13 +0,0 @@
-agggtaaa|tttaccct 1
-[cgt]gggtaaa|tttaccc[acg] 0
-a[act]ggtaaa|tttacc[agt]t 0
-ag[act]gtaaa|tttac[agt]ct 0
-agg[act]taaa|ttta[agt]cct 1
-aggg[acg]aaa|ttt[cgt]ccct 0
-agggt[cgt]aa|tt[acg]accct 0
-agggta[cgt]a|t[acg]taccct 0
-agggtaa[cgt]|[acg]ttaccct 2
-
-10245
-10000
-13348
diff --git a/test/bench/shootout/regex-dna.c b/test/bench/shootout/regex-dna.c
deleted file mode 100644
index 134f8215c7..0000000000
--- a/test/bench/shootout/regex-dna.c
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*
-** The Computer Language Shootout
-** http://shootout.alioth.debian.org/
-** contributed by Mike Pall
-**
-** regex-dna benchmark using PCRE
-**
-** compile with:
-**   gcc -O3 -fomit-frame-pointer -o regexdna regexdna.c -lpcre
-*/
-
-#define __USE_STRING_INLINES
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <pcre.h>
-
-typedef struct fbuf {
-  char *buf;
-  size_t size, len;
-} fbuf_t;
-
-static void fb_init(fbuf_t *b)
-{
-  b->buf = NULL;
-  b->len = b->size = 0;
-}
-
-static char *fb_need(fbuf_t *b, size_t need)
-{
-  need += b->len;
-  if (need > b->size) {
-    if (b->size == 0) b->size = need;
-    else while (need > b->size) b->size += b->size;
-    if (!(b->buf = realloc(b->buf, b->size))) exit(1);
-  }
-  return b->buf+b->len;
-}
-
-#define FB_MINREAD	(3<<16)
-
-/* Read all of a stdio stream into dst buffer. */
-static size_t fb_readall(fbuf_t *dst, FILE *fp)
-{
-  char *dp;
-  int n;
-  for (dp = fb_need(dst, FB_MINREAD);
-       (n = fread(dp, 1, dst->size-dst->len, fp)) > 0;
-       dp = fb_need(dst, FB_MINREAD)) dst->len += n;
-  if (ferror(fp)) exit(1);
-  return dst->len;
-}
-
-/* Substitute pattern p with replacement r, copying from src to dst buffer. */
-static size_t fb_subst(fbuf_t *dst, fbuf_t *src, const char *p, const char *r)
-{
-  pcre *re;
-  pcre_extra *re_ex;
-  const char *re_e;
-  char *dp;
-  int re_eo, m[3], pos, rlen, clen;
-  if (!(re = pcre_compile(p, PCRE_CASELESS, &re_e, &re_eo, NULL))) exit(1);
-  re_ex = pcre_study(re, 0, &re_e);
-  for (dst->len = 0, rlen = strlen(r), pos = 0;
-       pcre_exec(re, re_ex, src->buf, src->len, pos, 0, m, 3) >= 0;
-       pos = m[1]) {
-    clen = m[0]-pos;
-    dp = fb_need(dst, clen+rlen);
-    dst->len += clen+rlen;
-    memcpy(dp, src->buf+pos, clen);
-    memcpy(dp+clen, r, rlen);
-  }
-  clen = src->len-pos;
-  dp = fb_need(dst, clen);
-  dst->len += clen;
-  memcpy(dp, src->buf+pos, clen);
-  return dst->len;
-}
-
-/* Count all matches with pattern p in src buffer. */
-static int fb_countmatches(fbuf_t *src, const char *p)
-{
-  pcre *re;
-  pcre_extra *re_ex;
-  const char *re_e;
-  int re_eo, m[3], pos, count;
-  if (!(re = pcre_compile(p, PCRE_CASELESS, &re_e, &re_eo, NULL))) exit(1);
-  re_ex = pcre_study(re, 0, &re_e);
-  for (count = 0, pos = 0;
-       pcre_exec(re, re_ex, src->buf, src->len, pos, 0, m, 3) >= 0;
-       pos = m[1]) count++;
-  return count;
-}
-
-static const char *variants[] = {
-  "agggtaaa|tttaccct",         "[cgt]gggtaaa|tttaccc[acg]",
-  "a[act]ggtaaa|tttacc[agt]t", "ag[act]gtaaa|tttac[agt]ct",
-  "agg[act]taaa|ttta[agt]cct", "aggg[acg]aaa|ttt[cgt]ccct",
-  "agggt[cgt]aa|tt[acg]accct", "agggta[cgt]a|t[acg]taccct",
-  "agggtaa[cgt]|[acg]ttaccct", NULL
-};
-
-static const char *subst[] = {
-  "B", "(c|g|t)", "D", "(a|g|t)",   "H", "(a|c|t)", "K", "(g|t)",
-  "M", "(a|c)",   "N", "(a|c|g|t)", "R", "(a|g)",   "S", "(c|g)",
-  "V", "(a|c|g)", "W", "(a|t)",     "Y", "(c|t)",   NULL
-};
-
-int main(int argc, char **argv)
-{
-  fbuf_t seq[2];
-  const char **pp;
-  size_t ilen, clen, slen;
-  int flip;
-  fb_init(&seq[0]);
-  fb_init(&seq[1]);
-  ilen = fb_readall(&seq[0], stdin);
-  clen = fb_subst(&seq[1], &seq[0], ">.*|\n", "");
-  for (pp = variants; *pp; pp++)
-    printf("%s %d\n", *pp, fb_countmatches(&seq[1], *pp));
-  for (slen = 0, flip = 1, pp = subst; *pp; pp += 2, flip = 1-flip)
-    slen = fb_subst(&seq[1-flip], &seq[flip], *pp, pp[1]);
-  printf("\n%zu\n%zu\n%zu\n", ilen, clen, slen);
-  return 0;
-}
diff --git a/test/bench/shootout/regex-dna.go b/test/bench/shootout/regex-dna.go
deleted file mode 100644
index 042d7f2836..0000000000
--- a/test/bench/shootout/regex-dna.go
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by The Go Authors.
- */
-
-package main
-
-import (
-	"fmt"
-	"io/ioutil"
-	"os"
-	"regexp"
-)
-
-var variants = []string{
-	"agggtaaa|tttaccct",
-	"[cgt]gggtaaa|tttaccc[acg]",
-	"a[act]ggtaaa|tttacc[agt]t",
-	"ag[act]gtaaa|tttac[agt]ct",
-	"agg[act]taaa|ttta[agt]cct",
-	"aggg[acg]aaa|ttt[cgt]ccct",
-	"agggt[cgt]aa|tt[acg]accct",
-	"agggta[cgt]a|t[acg]taccct",
-	"agggtaa[cgt]|[acg]ttaccct",
-}
-
-type Subst struct {
-	pat, repl string
-}
-
-var substs = []Subst{
-	Subst{"B", "(c|g|t)"},
-	Subst{"D", "(a|g|t)"},
-	Subst{"H", "(a|c|t)"},
-	Subst{"K", "(g|t)"},
-	Subst{"M", "(a|c)"},
-	Subst{"N", "(a|c|g|t)"},
-	Subst{"R", "(a|g)"},
-	Subst{"S", "(c|g)"},
-	Subst{"V", "(a|c|g)"},
-	Subst{"W", "(a|t)"},
-	Subst{"Y", "(c|t)"},
-}
-
-func countMatches(pat string, bytes []byte) int {
-	re := regexp.MustCompile(pat)
-	n := 0
-	for {
-		e := re.FindIndex(bytes)
-		if len(e) == 0 {
-			break
-		}
-		n++
-		bytes = bytes[e[1]:]
-	}
-	return n
-}
-
-func main() {
-	bytes, err := ioutil.ReadAll(os.Stdin)
-	if err != nil {
-		fmt.Fprintf(os.Stderr, "can't read input: %s\n", err)
-		os.Exit(2)
-	}
-	ilen := len(bytes)
-	// Delete the comment lines and newlines
-	bytes = regexp.MustCompile("(>[^\n]+)?\n").ReplaceAll(bytes, []byte{})
-	clen := len(bytes)
-	for _, s := range variants {
-		fmt.Printf("%s %d\n", s, countMatches(s, bytes))
-	}
-	for _, sub := range substs {
-		bytes = regexp.MustCompile(sub.pat).ReplaceAll(bytes, []byte(sub.repl))
-	}
-	fmt.Printf("\n%d\n%d\n%d\n", ilen, clen, len(bytes))
-}
diff --git a/test/bench/shootout/regex-dna.txt b/test/bench/shootout/regex-dna.txt
deleted file mode 100644
index e23e71fd6e..0000000000
--- a/test/bench/shootout/regex-dna.txt
+++ /dev/null
@@ -1,13 +0,0 @@
-agggtaaa|tttaccct 1
-[cgt]gggtaaa|tttaccc[acg] 0
-a[act]ggtaaa|tttacc[agt]t 0
-ag[act]gtaaa|tttac[agt]ct 0
-agg[act]taaa|ttta[agt]cct 1
-aggg[acg]aaa|ttt[cgt]ccct 0
-agggt[cgt]aa|tt[acg]accct 0
-agggta[cgt]a|t[acg]taccct 0
-agggtaa[cgt]|[acg]ttaccct 2
-
-10245
-10000
-13348
diff --git a/test/bench/shootout/reverse-complement.c b/test/bench/shootout/reverse-complement.c
deleted file mode 100644
index b34c84696e..0000000000
--- a/test/bench/shootout/reverse-complement.c
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*
- * The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org
- *
- * contributed by Bob W
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#define JBFSIZE 82      // line input buffer size
-#define QBFSIZE 5200     // output buffer initial size
-#define Z16     "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-#define V32     "\0TVGH\0\0CD\0\0M\0KN\0\0\0YSA\0BW\0R\0\0\0\0\0\0"
-#define VALL    Z16 Z16 Z16 Z16 V32 V32 Z16 Z16 Z16 Z16 Z16 Z16 Z16 Z16
-
-int errex(char *s, int n) {      // error message+value, return 1
-  fprintf(stderr,"\n*** Error: %s [%d]!\n", s, n);
-  return 1;
-}
-
-int main () {                    // ***** main *****
-  char *pj, *pq, *pr;            // buffer pointers: inp,out,/out
-  char *jjj = malloc(JBFSIZE);   // allocate input line buffer
-  char *qqq = malloc(QBFSIZE);   // output buffer (dyn. size)
-  char *pqstop = qqq+QBFSIZE;    // end-of-buffer pointer
-  char xtab[256] = VALL;         // char conversion table
-
-  if (!jjj || !qqq)
-    return errex("Buffer allocation", !jjj + !qqq);
-  pj = fgets(jjj,JBFSIZE,stdin);         // fetch 1st line
-  if (!pj)
-    return errex("No input data",0);
-  if (*jjj != '>')
-    return errex("1st char not '>'", 0);
-
-  while (pj) {                           // MAIN LOOP: process data
-    fputs(jjj, stdout);                  // output ID line
-
-    for (pq=qqq+1, pr=pqstop; ; pq++) {  // LOOP: fill output buffer
-      pj = fgets(jjj, JBFSIZE, stdin);   // get line from stdin
-      if (!pj || (*jjj=='>'))  break;    // EOF or new ID line
-      if (pr <= (pq+61)) {               // need to resize buffer
-        char *newstop = pqstop + 12777888;
-        char *newptr  = realloc(qqq, newstop-qqq);
-        if (!newptr)
-          return errex("Out of memory", 0);
-        if (newptr != qqq) {             // new base: adj. pointers
-          size_t x = newptr-qqq;         // offset for pointer update
-          pq+=x;  pr+=x;  qqq+=x;
-          newstop+=x;  pqstop+=x;
-        }
-        pr = __builtin_memmove(newstop-(pqstop-pr), pr, pqstop-pr);
-        pqstop = newstop;                // buffer resize complete
-      }
-      while (*pj) {                      // LOOP: conv. & revert line
-        char c = xtab[(unsigned char)(*pj++)];
-        if (c)                           // conversion valid
-          *(--pr) = c;
-      }
-    }
-
-    for (pq = qqq; pr<pqstop; ) {        // LOOP: format output
-      size_t x = (pqstop-pr)<60 ? pqstop-pr : 60;
-      __builtin_memmove(pq,pr,x);        // move line to free space
-      pr+=x;  pq+=x;  *(pq++) = 0xA;     // adjust pointers, add LF
-    }
-    fwrite(qqq, 1, pq-qqq, stdout);      // output converted data
-  }
-  return 0;
-}
diff --git a/test/bench/shootout/reverse-complement.go b/test/bench/shootout/reverse-complement.go
deleted file mode 100644
index baa30ffccc..0000000000
--- a/test/bench/shootout/reverse-complement.go
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by The Go Authors.
- */
-
-package main
-
-import (
-	"bufio"
-	"os"
-)
-
-const lineSize = 60
-
-var complement = [256]uint8{
-	'A': 'T', 'a': 'T',
-	'C': 'G', 'c': 'G',
-	'G': 'C', 'g': 'C',
-	'T': 'A', 't': 'A',
-	'U': 'A', 'u': 'A',
-	'M': 'K', 'm': 'K',
-	'R': 'Y', 'r': 'Y',
-	'W': 'W', 'w': 'W',
-	'S': 'S', 's': 'S',
-	'Y': 'R', 'y': 'R',
-	'K': 'M', 'k': 'M',
-	'V': 'B', 'v': 'B',
-	'H': 'D', 'h': 'D',
-	'D': 'H', 'd': 'H',
-	'B': 'V', 'b': 'V',
-	'N': 'N', 'n': 'N',
-}
-
-func main() {
-	in := bufio.NewReader(os.Stdin)
-	buf := make([]byte, 1024*1024)
-	line, err := in.ReadSlice('\n')
-	for err == nil {
-		os.Stdout.Write(line)
-
-		// Accumulate reversed complement in buf[w:]
-		nchar := 0
-		w := len(buf)
-		for {
-			line, err = in.ReadSlice('\n')
-			if err != nil || line[0] == '>' {
-				break
-			}
-			line = line[0 : len(line)-1]
-			nchar += len(line)
-			if len(line)+nchar/60+128 >= w {
-				nbuf := make([]byte, len(buf)*5)
-				copy(nbuf[len(nbuf)-len(buf):], buf)
-				w += len(nbuf) - len(buf)
-				buf = nbuf
-			}
-
-			// This loop is the bottleneck.
-			for _, c := range line {
-				w--
-				buf[w] = complement[c]
-			}
-		}
-
-		// Copy down to beginning of buffer, inserting newlines.
-		// The loop left room for the newlines and 128 bytes of padding.
-		i := 0
-		for j := w; j < len(buf); j += 60 {
-			n := copy(buf[i:i+60], buf[j:])
-			buf[i+n] = '\n'
-			i += n + 1
-		}
-		os.Stdout.Write(buf[0:i])
-	}
-}
diff --git a/test/bench/shootout/reverse-complement.txt b/test/bench/shootout/reverse-complement.txt
deleted file mode 100644
index 14d792ade8..0000000000
--- a/test/bench/shootout/reverse-complement.txt
+++ /dev/null
@@ -1,171 +0,0 @@
->ONE Homo sapiens alu
-CGGAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAAC
-CTCCGCCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACA
-GGCGCGCGCCACCACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCAT
-GTTGGCCAGGCTGGTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAA
-AGTGCTGGGATTACAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTC
-TGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCGCCTCCCGG
-GTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGCGCGCCACC
-ACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGGCCAGGCTG
-GTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTA
-CAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTCTGTCGCCCAGGCT
-GGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCGCCTCCCGGGTTCAAGCGATTC
-TCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGCGCGCCACCACGCCCGGCTAAT
-TTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGGCCAGGCTGGTCTCGAACTCCT
-GACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTACAGGCGTGAGCCA
-CCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGC
-GCGATCTCGGCTCACTGCAACCTCCGCCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCC
-TCCCGAGTAGCTGGGATTACAGGCGCGCGCCACCACGCCCGGCTAATTTTTGTATTTTTA
-GTAGAGACGGGGTTTCACCATGTTGGCCAGGCTGGTCTCGAACTCCTGACCTCAGGTGAT
-CCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTACAGGCGTGAGCCACCGCGCCCGGCCT
-TTTTGAGACGGAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTC
-ACTGCAACCTCCGCCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTG
-GGATTACAGGCGCGCGCCACCACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGT
-TTCACCATGTTGGCCAGGCTGGTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGG
-CCTCCCAAAGTGCTGGGATTACAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAG
-TCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCG
-CCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGC
-GCGCCACCACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGG
-CCAGGCTGGTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGC
-TGGGATTACAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTCTGTCG
-CCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCGCCTCCCGGGTTCA
-AGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGCGCGCCACCACGCC
-CGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGGCCAGGCTGGTCTC
-GAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTACAGGC
-GTGAGCCACCGCGCCCGGCC
->TWO IUB ambiguity codes
-TAGGDHACHATCRGTRGVTGAGWTATGYTGCTGTCABACDWVTRTAAGAVVAGATTTNDA
-GASMTCTGCATBYTTCAAKTTACMTATTACTTCATARGGYACMRTGTTTTYTATACVAAT
-TTCTAKGDACKADACTATATNTANTCGTTCACGBCGYSCBHTANGGTGATCGTAAAGTAA
-CTATBAAAAGATSTGWATBCSGAKHTTABBAACGTSYCATGCAAVATKTSKTASCGGAAT
-WVATTTNTCCTTCTTCTTDDAGTGGTTGGATACVGTTAYMTMTBTACTTTHAGCTAGBAA
-AAGAGKAAGTTRATWATCAGATTMDDTTTAAAVAAATATTKTCYTAAATTVCNKTTRACG
-ADTATATTTATGATSADSCAATAWAGCGRTAGTGTAAGTGACVGRADYGTGCTACHVSDT
-CTVCARCSYTTAATATARAAAATTTAATTTACDAATTGBACAGTAYAABATBTGCAGBVG
-TGATGGDCAAAATBNMSTTABKATTGGSTCCTAGBTTACTTGTTTAGTTTATHCGATSTA
-AAGTCGAKAAASTGTTTTAWAKCAGATATACTTTTMTTTTGBATAGAGGAGCMATGATRA
-AAGGNCAYDCCDDGAAAGTHGBTAATCKYTBTACBGTBCTTTTTGDTAASSWTAAWAARA
-TTGGCTAAGWGRADTYACATAGCTCBTAGATAWAGCAATNGTATMATGTTKMMAGTAWTC
-CCNTSGAAWATWCAAAAMACTGAADNTYGATNAATCCGAYWNCTAACGTTAGAGDTTTTC
-ATCTGGKRTAVGAABVCTGWGBTCTDVGKATTBTCTAAGGVADAAAVWTCTAGGGGAGGG
-TTAGAACAATTAAHTAATNAAATGCATKATCTAAYRTDTCAGSAYTTYHGATRTTWAVTA
-BGNTCDACAGBCCRCAGWCRTCABTGMMAWGMCTCAACCGATRTGBCAVAATCGTDWDAA
-CAYAWAATWCTGGTAHCCCTAAGATAACSCTTAGTGSAACAWTBGTCDTTDGACWDBAAC
-HTTTNGSKTYYAAYGGATNTGATTTAARTTAMBAATCTAAGTBTCATYTAACTTADTGTT
-TCGATACGAAHGGCYATATACCWDTKYATDCSHTDTCAAAATGTGBACTGSCCVGATGTA
-TCMMAGCCTTDAAABAATGAAGAGTAACTHATMGVTTAATAACCCGGTTVSANTGCAATT
-GTGAGATTTAMGTTTAMAAYGCTGACAYAAAAAGGCACAMYTAAGVGGCTGGAABVTACG
-GATTSTYGTBVAKTATWACCGTGTKAGTDTGTATGTTTAAAGGAAAAAGTAACATARAAA
-GGTYCAMNYAAABTATAGNTSATANAGTCATCCTATWADKAACTRGTMSACDGTATSAYT
-AAHSHGTAABYGACTYTATADTGSTATAGAGAAATCGNTAAAGGAAATCAGTTGTNCYMV
-TNACDRTATBNATATASTAGAAMSCGGGANRCKKMCAAACATTNAGTCTRMAATBMTACC
-CGTACTTCTBGDSYAATWGAAAATGACADDCHAKAAAYATATTKTTTTCACANACWAGAA
-AKATCCTTATTAYKHKCTAAACARTATTTTDATBTVWCYGCAATACTAGGKAAASTTDGA
-MGGCHTTHAATVCAHDRYAGGRCTATACGTCMAGAGAGCTBTHGNACARTCCBDCTAAGA
-GCGGCTTTARTAAAGAATCCNAGTAWBTGACTTGAATTACWTVACAGAAABCAATNAAAC
-CGTNTRANTTGAYCMAWBADTANABRGGTKTHTWTAGTTVCTMBKTAGMTVKCCAGCANT
-TVAGSWTTAGCCGCRHTTTCCTTHNTATTAAGAAGAATAGGMTRAARTCTABGTACDTTT
-TATAAVDHAHTATAGATCCTAGTAAGYTWATDWCATGAGGGATAGTAAMDMNGBASTWAM
-TSTATRBAYDABATGTATATYCGCACTGTTTTAACMCWBTATAWAGTATBTSTATVTTAR
-CCTMTTAAKADATCAACTAATYTSVTAKGDATTATGCKTCAYCAKAATACTTKAANGAGT
-ATTSDAGATCGGAAATACTTAAYAAVGTATMCGCTTGTGTDCTAATYTATTTTATTTWAA
-CAGWRCTATGTAGMTGTTTGTTYKTNGTTKTCAGAACNTRACCTACKTGSRATGTGGGGG
-CTGTCATTAAGTAAATNGSTTABCCCCTCGCAGCTCWHTCGCGAAGCAVATGCKACGHCA
-ACAKTTAATAACASAAADATTWNYTGTAATTGTTCGTMHACHTWATGTGCWTTTTGAAHY
-ACTTTGTAYAMSAAACTTAADAAATATAGTABMATATYAATGSGGTAGTTTGTGTBYGGT
-TWSGSVGWMATTDMTCCWWCABTCSVACAGBAATGTTKATBGTCAATAATCTTCTTAAAC
-ARVAATHAGYBWCTRWCABGTWWAATCTAAGTCASTAAAKTAAGVKBAATTBGABACGTA
-AGGTTAAATAAAAACTRMDTWBCTTTTTAATAAAAGATMGCCTACKAKNTBAGYRASTGT
-ASSTCGTHCGAAKTTATTATATTYTTTGTAGAACATGTCAAAACTWTWTHGKTCCYAATA
-AAGTGGAYTMCYTAARCSTAAATWAKTGAATTTRAGTCTSSATACGACWAKAASATDAAA
-TGYYACTSAACAAHAKTSHYARGASTATTATTHAGGYGGASTTTBGAKGATSANAACACD
-TRGSTTRAAAAAAAACAAGARTCVTAGTAAGATAWATGVHAAKATWGAAAAGTYAHVTAC
-TCTGRTGTCAWGATRVAAKTCGCAAVCGASWGGTTRTCSAMCCTAACASGWKKAWDAATG
-ACRCBACTATGTGTCTTCAAAHGSCTATATTTCGTVWAGAAGTAYCKGARAKSGKAGTAN
-TTTCYACATWATGTCTAAAADMDTWCAATSTKDACAMAADADBSAAATAGGCTHAHAGTA
-CGACVGAATTATAAAGAHCCVAYHGHTTTACATSTTTATGNCCMTAGCATATGATAVAAG
->THREE Homo sapiens frequency
-ATATTTATCTTTTCACTTCCTACATTGGTCAGACCATTATTCGACACGTGGCGTCATTTT
-GTCATACCGGGTAATGTTGGAAACAAAACGTACTGATAAAATACTGAGTTGTAAACTCTA
-ATCAGATAACGCGCTTGGATATTAAGATTCACACAGGGGTTTCGGCTGTAAAAAAACTTG
-TGGAGCTGTTCTGGGACAGATAAGTTGTACCTCGTACTTAGCTAATTAATGAACCAACTG
-ATTACGATAGAACAATTCTGAGGCCGCCAGGACAGCCAAATTTTAATCTTATAAAGCTGG
-AAACAGCCGGTATTAGCTTCTCGCATACTTTGCCTGCATTGGTACCTTACAGATATCAGC
-GTAGTCATATACACCTCGGTCTCAGCTAAGCTTGTATCTCTTAGAGTAGTTCAAAGATAG
-TGGACAATACCTGTGGAATCGATTGCAGATATGGATTTATTTAACTACTGAGTCTCATTC
-ACAAGCTAAGCAAGGAGCACGTTTTGGTGCCGGCATACCGATTTGCTATCATGTCAGCAA
-ATTTGCGTTGTATTCCTAGTTGCACCCATTAAGGCCACACTCCGAACCTAATTATTACAT
-CGCAAAGACATGTACGAAGGACCCGATGTCGAATAGAAGGGAGGACTGTTCATTGGAAGC
-TAGACCAGAGGAATCGCAAAGATGCAACTCTTACAATAAAAATCTAATTTCAGTCAACAC
-GCAATTTCTATAAGGTTTCCGATAATAATGAACCGTCTTCCACAGGGGAATTTGCCATGC
-TCGTAAAAGTAGTTAATCCAAGTAGAAGAAATTTTGATAATGTTTTAAGTTGGCACGAAG
-GAATTCAGAGAGATCTTACCTAACAAAGGCATTAGTAGATGTTCCTTGGTTCACACTCGG
-TCAATCAGAGCACATACTACGGGCGATACCGGGAATGACACAACATCAATGAGATTGTTA
-AGTGAGGTAATTGACTTTAGAGGACTCGATCAGTATACTGTCACTATGAACATCGTATTA
-ATTGTTATCCGATATATACACCACCGATTTGCTTGTGCAAGGTTACAGACCCATTCGATA
-AATACAAACACGGAGCGATATTATTTAAGGAGTGCTGTCTTCAAAAGAATTATTCCCACA
-CCGACATAAGAACTTCGCTCCGTCATTCCAGATTTAAATAACATAACGTAACGCTTTGCT
-GATAACATAACATAACCGAGAATTTGCTTAGGAAATTTGGAGCAATATTGCATTGTTTCT
-CAGTCATCACAAGGCCCGCCAAAGAACTCTGAGAATCAGGATTCAACATGATTGGTAAGA
-CTCTATATATATAACTTAATTCTTGTGTCCGGAGATAGAAAGAGGACGAGAGATACTACG
-AAAGAAAGTGTACTTCGATGTATCAATTCAGACGCCTTCTCTATCATCAACATTATAGGT
-CTCGTATATGCTCGGCGCGATCTGCTTCTCTCCGCCAATAGCCCCATAGTGTATTTCAAG
-CGCAGTAACAGTGAAATCGTTACGAAGGTAGGGATGTTGCTTATAATTGTCGTAACTTAT
-CGCTTATGTATCTTTCAAGAATGAACGGCAGCATATACATACGTTCTACCTTTAGCTACA
-AAGCATCCATATACTCCCTCTCATGATTGAAACTCTTCCCTATTTTGTAGCCAATAGTGA
-AAGCGTATTAGTATAAATTCGTCGGTTTTTCACTCGCAACTGTTATACTCTGCAAACAAA
-CGAAAGCCTCATAGTACAAACCTAAAGCTACATACTTCATCATTGGCAGACCAGTGGCGG
-TATTTCTACGGAAGCATCACTATAGATATAAAGTTTCCCTTCATGTACGTCTGTTAACCA
-TATCACAAGAAACTGCTATCTCTGTCACGTAACAATTCACGCGCCTTATCGCCAAATGTT
-CATATATGCGCGGTATACGTATGAACGAATACTAATTAGTATAACGGAGGATTCACGGGA
-GGGATACTTGGGGCATTTATAAATCGTCTAAAAATTTTCTATCAGCACTTGCGGGTTATA
-GTGGATTACTAGGCAACATAATATTCTGTATTGGTCCAAATGACGCTATAGATAAATTAG
-CAAAATACATTGTTTCCATTTATGTAAGTCGAAACTCCAGGACTCCCGGGAACCAGTTAA
-ACCGTCTGGAAAAGACACATTGTGAGCGGGACTTCAATGATAGCTTTCAATGAGCTTCTC
-ATGCTTGGGGTCTGTACATATATGTTGGCGAAATTATCGTCTGTATTCTGTTATGCTTTG
-ATCATGGGTTATTAGTATAGTGTCCGGTTAAGTACCAATACCGCTAGAGACCCGACCTAA
-GTCGATAACTAACGATCATCGACGTAAGGATCGTCTCGATCAGTACTTCAGTCTAGATCT
-GGGAATAGTAACTCGTTAGTGAACTATGTCGTGTCATAACTCTAAAATGCAATCAAATCT
-TATTATTGAGTATTGATTATATAAAGCATCCGCTTAGCTTTACCCTCAAATGTTATATGC
-AATTTAAAGCGCTTGATATCGTCTACTCAAGTTCAGGTTTCACATGGCCGCAACGTGACG
-TTATTAGAGGTGGGTCATCATCTCTGAGGCTAGTGATGTTGAATACTCATTGAATGGGAA
-GTGGAATACCATGCTCGTAGGTAACAGCATGACCTATAAAATATACTATGGGTGTGTGGT
-AGATCAATATTGTTCAAGCATATCGTAACAATAACGGCTGAAATGTTACTGACATGAAAG
-AGGGAGTCCAAACCATTCTAACAGCTGATCAAGTCGTCTAAAAACGCCTGGTTCAGCCTT
-AAGAGTTATAAGCCAGACAAATTGTATCAATAGAGAATCCGTAAATTCCTCGGCCAACCT
-CTTGCAAAGACATCACTATCAATATACTACCGTGATCTTAATTAGTGAACTTATATAAAT
-ATCTACAACCAGATTCAACGGAAAAGCTTTAGTGGATTAGAAATTGCCAAGAATCACATT
-CATGTGGGTTCGAATGCTTTAGTAATACCATTTCGCCGAGTAGTCACTTCGCTGAACTGT
-CGTAAATTGCTATGACATAATCGAAAAGGATTGTCAAGAGTCGATTACTGCGGACTAATA
-ATCCCCACGGGGGTGGTCTCATGTCTCCCCAGGCGAGTGGGGACGGTTGATAAACACGCT
-GCATCGCGGACTGATGTTCCCAGTATTACATAGTCACATTGGATTGCGAGTAGTCTACCT
-ATTTATGAGCGAGAGATGCCTCTAACTACTTCGACTTTTAAAACCTTTCCACGCCAGTAT
-TCGGCGAAAGGGAAGTATTAAGGGTTGTCATAATTAAGCTGATACCACTTCAGACTTTGC
-TCTACTTCTGTCTTTCATTGGTTTAGTAAAGTCTGTCCATTCGTCGAGACCGTCTTTTGC
-AGCCTCATTCTACCAACTGCTCCGACTCTTAGTCTGCTTCTCCCAGCGTTATAACAAGAG
-GCATTTTGTCATCCTTAAAACAATAATAAAGAACTCGGAGCACTGATATAATGACTGAAT
-TAGAACCGCTTAAAAATACAACGAATAGATAAGACTATCGGATAAGATCTAATATGTAGT
-GATTAAGCCCTTTATTAATTAATAATAGTTACCCTTTCTGATGTAACGCGACATATTACG
-ATTTAGTGGCACGTCTGAATTGCAAAGCAGATCTCTACCCGATTTTTATTATAAATCCCG
-TATACATCTTGACTTGAGTAATTGTTCATCTTTTTATATCTCTTCGTACTACAAATAATT
-AATATCTCAACCCGTATTGTGTGATTCTAATTACCAACAGAATACGAGGAGGTTTTTGCT
-TAGGGCCATATATAATGAATCTATCTCGTTTATTCGCGGAACCCGAGATAACATTACGAT
-GTAACTATTTTAGAGAACTTAATACAAGAAACATTGCTGATTACTCATAACTAAATGCTT
-GGTAATATATCCTCAGTGCCCCTACCATCTTTTACGCAGGGATGTAATTACTTAGGATTC
-ATTGTGTAAGAATTACAATGAACGATGGATATGAAGGCATGTTGCGAGGTGTTCCTTGGT
-ATGTGAAGTTCGCAGGGCAACAAAAATTTCGCAGAATAGGCCTCAAAGTATTGGTAAAGA
-AGACAACTAATCATCACGAGCTTCTGATATCAATACGAACGAGTCCTGTGATGGATGAAA
-GAAAGTCGTATCGAAAATGTCAAGAGTCTGCCCAATGTAACTTACTTCAAAAAATAACGC
-TTCCGCCAAGTACGTTCGAATAAACGTAATTTTAAAAATACATAAGGGGTGTTAGAAAGT
-AAGCGACGGGATATAAGTTAGACTCAAGATTCCGCCGTAAAACGAGACTGATTCCGAAGA
-TTGTTCGTGGATCTGGTCATGACTTTCACTGAGTAAGGAGTTTCGACATATGTCAATAAA
-CACAAAAATAGAAGCTATTCGATCTGAAAAATATTAGGACAAGAAACTATCTCACGCTAG
-CCCAGAATATTCACTCACCCACGGGCGATACTAAAGCACTATATAGTCGCGTGATTACTA
-TACATATGGTACACATAAGAATCACGATCAGGTTCTCAATTTTCAACAATATATGTTTAT
-TTGCATAGGTAATATTAGGCCTTTAAGAGAAGGATGGGTGAGATACTCCGGGGATGGCGG
-CAATAAAGAAAAACACGATATGAGTAATAGGATCCTAATATCTTGGCGAGAGACTTAAGG
-TACGAATTTTGCGCAATCTATTTTTTACTTGGCCAGAATTCATGTATGGTATAAGTACGA
-ACTTTTTTGATCACTTTCATGGCTACCTGATTAGGATAGTTTGAGGAATTTCCCAAATAT
-ACCGATTTAATATACACTAGGGCTTGTCACTTTGAGTCAGAAAAAGAATATAATTACTTA
-GGGTAATGCTGCATACATATTCTTATATTGCAAAGGTTCTCTGGGTAATCTTGAGCCTTC
-ACGATACCTGGTGAAGTGTT
diff --git a/test/bench/shootout/spectral-norm-parallel.go b/test/bench/shootout/spectral-norm-parallel.go
deleted file mode 100644
index 2706f39ec3..0000000000
--- a/test/bench/shootout/spectral-norm-parallel.go
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by The Go Authors.
- * Based on spectral-norm.c by Sebastien Loisel
- */
-
-package main
-
-import (
-	"flag"
-	"fmt"
-	"math"
-	"runtime"
-)
-
-var n = flag.Int("n", 2000, "count")
-var nCPU = flag.Int("ncpu", 4, "number of cpus")
-
-func evalA(i, j int) float64 { return 1 / float64(((i+j)*(i+j+1)/2 + i + 1)) }
-
-type Vec []float64
-
-func (v Vec) Times(i, n int, u Vec, c chan int) {
-	for ; i < n; i++ {
-		v[i] = 0
-		for j := 0; j < len(u); j++ {
-			v[i] += evalA(i, j) * u[j]
-		}
-	}
-	c <- 1
-}
-
-func (v Vec) TimesTransp(i, n int, u Vec, c chan int) {
-	for ; i < n; i++ {
-		v[i] = 0
-		for j := 0; j < len(u); j++ {
-			v[i] += evalA(j, i) * u[j]
-		}
-	}
-	c <- 1
-}
-
-func wait(c chan int) {
-	for i := 0; i < *nCPU; i++ {
-		<-c
-	}
-}
-
-func (v Vec) ATimesTransp(u Vec) {
-	x := make(Vec, len(u))
-	c := make(chan int, *nCPU)
-	for i := 0; i < *nCPU; i++ {
-		go x.Times(i*len(v) / *nCPU, (i+1)*len(v) / *nCPU, u, c)
-	}
-	wait(c)
-	for i := 0; i < *nCPU; i++ {
-		go v.TimesTransp(i*len(v) / *nCPU, (i+1)*len(v) / *nCPU, x, c)
-	}
-	wait(c)
-}
-
-func main() {
-	flag.Parse()
-	runtime.GOMAXPROCS(*nCPU)
-	N := *n
-	u := make(Vec, N)
-	for i := 0; i < N; i++ {
-		u[i] = 1
-	}
-	v := make(Vec, N)
-	for i := 0; i < 10; i++ {
-		v.ATimesTransp(u)
-		u.ATimesTransp(v)
-	}
-	var vBv, vv float64
-	for i := 0; i < N; i++ {
-		vBv += u[i] * v[i]
-		vv += v[i] * v[i]
-	}
-	fmt.Printf("%0.9f\n", math.Sqrt(vBv/vv))
-}
diff --git a/test/bench/shootout/spectral-norm.c b/test/bench/shootout/spectral-norm.c
deleted file mode 100644
index 832eb3d217..0000000000
--- a/test/bench/shootout/spectral-norm.c
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* -*- mode: c -*-
- *
- * The Great Computer Language Shootout
- * http://shootout.alioth.debian.org/
- *
- * Contributed by Sebastien Loisel
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-
-double eval_A(int i, int j) { return 1.0/((i+j)*(i+j+1)/2+i+1); }
-
-void eval_A_times_u(int N, const double u[], double Au[])
-{
-  int i,j;
-  for(i=0;i<N;i++)
-    {
-      Au[i]=0;
-      for(j=0;j<N;j++) Au[i]+=eval_A(i,j)*u[j];
-    }
-}
-
-void eval_At_times_u(int N, const double u[], double Au[])
-{
-  int i,j;
-  for(i=0;i<N;i++)
-    {
-      Au[i]=0;
-      for(j=0;j<N;j++) Au[i]+=eval_A(j,i)*u[j];
-    }
-}
-
-void eval_AtA_times_u(int N, const double u[], double AtAu[])
-{ double v[N]; eval_A_times_u(N,u,v); eval_At_times_u(N,v,AtAu); }
-
-int main(int argc, char *argv[])
-{
-  int i;
-  int N = ((argc == 2) ? atoi(argv[1]) : 2000);
-  double u[N],v[N],vBv,vv;
-  for(i=0;i<N;i++) u[i]=1;
-  for(i=0;i<10;i++)
-    {
-      eval_AtA_times_u(N,u,v);
-      eval_AtA_times_u(N,v,u);
-    }
-  vBv=vv=0;
-  for(i=0;i<N;i++) { vBv+=u[i]*v[i]; vv+=v[i]*v[i]; }
-  printf("%0.9f\n",sqrt(vBv/vv));
-  return 0;
-}
diff --git a/test/bench/shootout/spectral-norm.go b/test/bench/shootout/spectral-norm.go
deleted file mode 100644
index 6667f3e04a..0000000000
--- a/test/bench/shootout/spectral-norm.go
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by The Go Authors.
- * Based on spectral-norm.c by Sebastien Loisel
- */
-
-package main
-
-import (
-	"flag"
-	"fmt"
-	"math"
-)
-
-var n = flag.Int("n", 2000, "count")
-
-func evalA(i, j int) float64 { return 1 / float64(((i+j)*(i+j+1)/2 + i + 1)) }
-
-type Vec []float64
-
-func (v Vec) Times(u Vec) {
-	for i := 0; i < len(v); i++ {
-		v[i] = 0
-		for j := 0; j < len(u); j++ {
-			v[i] += evalA(i, j) * u[j]
-		}
-	}
-}
-
-func (v Vec) TimesTransp(u Vec) {
-	for i := 0; i < len(v); i++ {
-		v[i] = 0
-		for j := 0; j < len(u); j++ {
-			v[i] += evalA(j, i) * u[j]
-		}
-	}
-}
-
-func (v Vec) ATimesTransp(u Vec) {
-	x := make(Vec, len(u))
-	x.Times(u)
-	v.TimesTransp(x)
-}
-
-func main() {
-	flag.Parse()
-	N := *n
-	u := make(Vec, N)
-	for i := 0; i < N; i++ {
-		u[i] = 1
-	}
-	v := make(Vec, N)
-	for i := 0; i < 10; i++ {
-		v.ATimesTransp(u)
-		u.ATimesTransp(v)
-	}
-	var vBv, vv float64
-	for i := 0; i < N; i++ {
-		vBv += u[i] * v[i]
-		vv += v[i] * v[i]
-	}
-	fmt.Printf("%0.9f\n", math.Sqrt(vBv/vv))
-}
diff --git a/test/bench/shootout/spectral-norm.txt b/test/bench/shootout/spectral-norm.txt
deleted file mode 100644
index b9885983ee..0000000000
--- a/test/bench/shootout/spectral-norm.txt
+++ /dev/null
@@ -1 +0,0 @@
-1.274224152
diff --git a/test/bench/shootout/threadring.c b/test/bench/shootout/threadring.c
deleted file mode 100644
index 606db71dc9..0000000000
--- a/test/bench/shootout/threadring.c
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*
-* The Computer Language Benchmarks Game
-* http://shootout.alioth.debian.org/
-
-* contributed by Premysl Hruby
-*/
-
-#include <stdint.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <pthread.h>
-#include <string.h>
-#include <limits.h>
-
-// PTHREAD_STACK_MIN undeclared on mingw
-#ifndef PTHREAD_STACK_MIN
-#define PTHREAD_STACK_MIN 65535
-#endif
-
-#define THREADS (503)
-
-struct stack {
-   char x[PTHREAD_STACK_MIN];
-};
-
-
-/* staticaly initialize mutex[0] mutex */
-static pthread_mutex_t mutex[THREADS];
-static int data[THREADS];
-static struct stack stacks[THREADS];
-/* stacks must be defined staticaly, or my i386 box run of virtual memory for this
- * process while creating thread +- #400 */
-
-static void* thread(void *num)
-{
-   int l = (int)(uintptr_t)num;
-   int r = (l+1) % THREADS;
-   int token;
-
-   while(1) {
-      pthread_mutex_lock(mutex + l);
-      token = data[l];
-      if (token) {
-         data[r] = token - 1;
-         pthread_mutex_unlock(mutex + r);
-      }
-      else {
-         printf("%i\n", l+1);
-         exit(0);
-      }
-   }
-}
-
-
-
-int main(int argc, char **argv)
-{
-   int i;
-   pthread_t cthread;
-   pthread_attr_t stack_attr;
-
-   if (argc != 2)
-      exit(255);
-   data[0] = atoi(argv[1]);
-
-   pthread_attr_init(&stack_attr);
-
-   for (i = 0; i < THREADS; i++) {
-      pthread_mutex_init(mutex + i, NULL);
-      pthread_mutex_lock(mutex + i);
-
-#if defined(__MINGW32__) || defined(__MINGW64__)
-      pthread_attr_setstackaddr(&stack_attr, &stacks[i]);
-      pthread_attr_setstacksize(&stack_attr, sizeof(struct stack));
-#else
-      pthread_attr_setstack(&stack_attr, &stacks[i], sizeof(struct stack));
-#endif
-
-      pthread_create(&cthread, &stack_attr, thread, (void*)(uintptr_t)i);
-   }
-
-   pthread_mutex_unlock(mutex + 0);
-   pthread_join(cthread, NULL);
-}
diff --git a/test/bench/shootout/threadring.go b/test/bench/shootout/threadring.go
deleted file mode 100644
index e76dd0b452..0000000000
--- a/test/bench/shootout/threadring.go
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-    * Neither the name of "The Computer Language Benchmarks Game" nor the
-    name of "The Computer Language Shootout Benchmarks" nor the names of
-    its contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/* The Computer Language Benchmarks Game
- * http://shootout.alioth.debian.org/
- *
- * contributed by The Go Authors.
- */
-
-package main
-
-import (
-	"flag"
-	"fmt"
-	"os"
-)
-
-var n = flag.Int("n", 1000, "how many passes")
-
-const Nthread = 503
-
-func f(i int, in <-chan int, out chan<- int) {
-	for {
-		n := <-in
-		if n == 0 {
-			fmt.Printf("%d\n", i)
-			os.Exit(0)
-		}
-		out <- n - 1
-	}
-}
-
-func main() {
-	flag.Parse()
-
-	one := make(chan int) // will be input to thread 1
-	var in, out chan int = nil, one
-	for i := 1; i <= Nthread-1; i++ {
-		in, out = out, make(chan int)
-		go f(i, in, out)
-	}
-	go f(Nthread, out, one)
-	one <- *n
-	<-make(chan int) // hang until ring completes
-}
diff --git a/test/bench/shootout/threadring.txt b/test/bench/shootout/threadring.txt
deleted file mode 100644
index f9aaa4d565..0000000000
--- a/test/bench/shootout/threadring.txt
+++ /dev/null
@@ -1 +0,0 @@
-498
diff --git a/test/bench/shootout/timing.log b/test/bench/shootout/timing.log
deleted file mode 100644
index 4e7d17a11b..0000000000
--- a/test/bench/shootout/timing.log
+++ /dev/null
@@ -1,1254 +0,0 @@
-All tests on r45 or r70
-
-Aug 3 2009
-
-First version of fasta. Translation of fasta.c, fetched from
-	http://shootout.alioth.debian.org/u32q/benchmark.php?test=fasta&lang=gpp&id=4
-
-fasta -n 25000000
-	gcc -O2 fasta.c	5.98u 0.00s 6.01r
-	gccgo -O2 fasta.go	8.82u 0.02s 8.85r
-	6g fasta.go	13.50u 0.02s 13.53r
-	6g -B fata.go	12.99u 0.02s 13.02r
-
-Aug 4 2009
-[added timing.sh]
-
-# myrandom:
-#   hand-written optimization of integer division
-#   use int32->float conversion
-fasta -n 25000000
-	# probably I/O library inefficiencies
-	gcc -O2 fasta.c	5.99u 0.00s 6.00r 
-	gccgo -O2 fasta.go	8.82u 0.02s 8.85r
-	gc fasta	10.70u 0.00s 10.77r
-	gc_B fasta	10.09u 0.03s 10.12r
-
-reverse-complement < output-of-fasta-25000000
-	# we don't know - memory cache behavior?
-	gcc -O2 reverse-complement.c	2.04u 0.94s 10.54r
-	gccgo -O2 reverse-complement.go	6.54u 0.63s 7.17r
-	gc reverse-complement	6.55u 0.70s 7.26r
-	gc_B reverse-complement	6.32u 0.70s 7.10r
-
-nbody 50000000
-	# math.Sqrt needs to be in assembly; inlining is probably the other 50%
-	gcc -O2 nbody.c	21.61u 0.01s 24.80r
-	gccgo -O2 nbody.go	118.55u 0.02s 120.32r
-	gc nbody	100.84u 0.00s 100.85r
-	gc_B nbody	103.33u 0.00s 103.39r
-[
-hacked Sqrt in assembler
-	gc nbody	31.97u 0.00s 32.01r
-]
-
-binary-tree 15 # too slow to use 20
-	# memory allocation and garbage collection
-	gcc -O2 binary-tree.c -lm	0.86u 0.00s 0.87r
-	gccgo -O2 binary-tree.go	1.69u 0.46s 2.15r
-	gccgo -O2 binary-tree-freelist.go	8.48u 0.00s 8.48r
-	gc binary-tree	9.60u 0.01s 9.62r
-	gc binary-tree-freelist	0.48u 0.01s 0.50r
-
-August 5, 2009
-
-fannkuch 12
-	# bounds checking is half the difference
-	# rest might be registerization
-	gcc -O2 fannkuch.c	60.09u 0.01s 60.32r
-	gccgo -O2 fannkuch.go	64.89u 0.00s 64.92r
-	gc fannkuch	124.59u 0.00s 124.67r
-	gc_B fannkuch	91.14u 0.00s 91.16r
-
-regex-dna 100000
-	# regexp code is slow on trivial regexp
-	gcc -O2 regex-dna.c -lpcre	0.92u 0.00s 0.99r
-	gc regexp-dna	26.94u 0.18s 28.75r
-	gc_B regexp-dna	26.51u 0.09s 26.75r
-
-spectral-norm 5500
-	gcc -O2 spectral-norm.c -lm	11.54u 0.00s 11.55r
-	gccgo -O2 spectral-norm.go	12.20u 0.00s 12.23r
-	gc spectral-norm	50.23u 0.00s 50.36r
-	gc_B spectral-norm	49.69u 0.01s 49.83r
-	gc spectral-norm-parallel	24.47u 0.03s 11.05r  # has shift >>1 not div /2
-	[using >>1 instead of /2 : gc gives 24.33u 0.00s 24.33r]
-
-August 6, 2009
-
-k-nucleotide 5000000
-	# string maps are slower than glib string maps
-	gcc -O2 -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include k-nucleotide.c -lglib-2.0	k-nucleotide.c: 10.72u 0.01s 10.74r
-	gccgo -O2 k-nucleotide.go	21.64u 0.83s 22.78r
-	gc k-nucleotide	16.08u 0.06s 16.50r
-	gc_B k-nucleotide	17.32u 0.02s 17.37r
-
-mandelbrot 5500
-	# floating point code generator should use more registers
-	gcc -O2 mandelbrot.c	56.13u 0.02s 56.17r
-	gccgo -O2 mandelbrot.go	57.49u 0.01s 57.51r
-	gc mandelbrot	74.32u 0.00s 74.35r
-	gc_B mandelbrot	74.28u 0.01s 74.31r
-
-meteor 2100
-	# we don't know
-	gcc -O2 meteor-contest.c	0.10u 0.00s 0.10r
-	gccgo -O2 meteor-contest.go	0.12u 0.00s 0.14r
-	gc meteor-contest	0.24u 0.00s 0.26r
-	gc_B meteor-contest	0.23u 0.00s 0.24r
-
-pidigits 10000
-	# bignum is slower than gmp
-	gcc -O2 pidigits.c -lgmp	2.60u 0.00s 2.62r
-	gc pidigits	77.69u 0.14s 78.18r
-	gc_B pidigits	74.26u 0.18s 75.41r
-	gc_B pidigits	68.48u 0.20s 69.31r   # special case: no bounds checking in bignum
-
-August 7 2009
-
-# New gc does better division by powers of 2.  Significant improvements:
-
-spectral-norm 5500
-	# floating point code generator should use more registers; possibly inline evalA
-	gcc -O2 spectral-norm.c -lm	11.50u 0.00s 11.50r
-	gccgo -O2 spectral-norm.go	12.02u 0.00s 12.02r
-	gc spectral-norm	23.98u 0.00s 24.00r	# new time is 0.48 times old time, 52% faster
-	gc_B spectral-norm	23.71u 0.01s 23.72r	# ditto
-	gc spectral-norm-parallel	24.04u 0.00s 6.26r  # /2 put back.  note: 4x faster (on r70, idle)
-
-k-nucleotide 1000000
-	# string maps are slower than glib string maps
-	gcc -O2 -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include k-nucleotide.c -lglib-2.0	10.82u 0.04s 10.87r
-	gccgo -O2 k-nucleotide.go	22.73u 0.89s 23.63r
-	gc k-nucleotide	15.97u 0.03s 16.04r
-	gc_B k-nucleotide	15.86u 0.06s 15.93r	# 8.5% faster, but probably due to weird cache effeccts in previous version
-
-pidigits 10000
-	# bignum is slower than gmp
-	gcc -O2 pidigits.c -lgmp	2.58u 0.00s 2.58r
-	gc pidigits	71.24u 0.04s 71.28r	# 8.5% faster
-	gc_B pidigits	71.25u 0.03s 71.29r	# 4% faster
-
-threadring 50000000
-	gcc -O2 threadring.c -lpthread	35.51u 160.21s 199.50r
-	gccgo -O2 threadring.go	90.33u 459.95s 448.03r
-	gc threadring	33.11u 0.00s 33.14r
-	GOMAXPROCS=4 gc threadring	114.48u 226.65s 371.59r
-	# change wait code to do <-make(chan int) instead of time.Sleep
-	gc threadring	28.41u 0.01s 29.35r
-	GOMAXPROCS=4 gc threadring	112.59u 232.83s 384.72r
-	
-chameneos 6000000
-	gcc -O2 chameneosredux.c -lpthread	18.14u 276.52s 76.93r
-	gc chameneosredux	20.19u 0.01s 20.23r
-
-Aug 10 2009
-
-# new 6g with better fp registers, fast div and mod of integers
-# complete set of timings listed. significant changes marked ***
-
-fasta -n 25000000
-	# probably I/O library inefficiencies
-	gcc -O2 fasta.c	5.96u 0.00s 5.97r
-	gc fasta	10.59u 0.01s 10.61r
-	gc_B fasta	9.92u 0.02s 9.95r
-
-reverse-complement < output-of-fasta-25000000
-	# we don't know - memory cache behavior?
-	gcc -O2 reverse-complement.c	1.96u 1.56s 16.23r
-	gccgo -O2 reverse-complement.go	6.41u 0.62s 7.05r
-	gc reverse-complement	6.46u 0.70s 7.17r
-	gc_B reverse-complement	6.22u 0.72s 6.95r
-
-nbody 50000000
-	# math.Sqrt needs to be in assembly; inlining is probably the other 50%
-	gcc -O2 nbody.c	21.26u 0.01s 21.28r
-	gccgo -O2 nbody.go	116.68u 0.07s 116.80r
-	gc nbody	86.64u 0.01s 86.68r	# -14%
-	gc_B nbody	85.72u 0.02s 85.77r	# *** -17%
-
-binary-tree 15 # too slow to use 20
-	# memory allocation and garbage collection
-	gcc -O2 binary-tree.c -lm	0.87u 0.00s 0.87r
-	gccgo -O2 binary-tree.go	1.61u 0.47s 2.09r
-	gccgo -O2 binary-tree-freelist.go	0.00u 0.00s 0.01r
-	gc binary-tree	9.11u 0.01s 9.13r	# *** -5%
-	gc binary-tree-freelist	0.47u 0.01s 0.48r
-
-fannkuch 12
-	# bounds checking is half the difference
-	# rest might be registerization
-	gcc -O2 fannkuch.c	59.92u 0.00s 59.94r
-	gccgo -O2 fannkuch.go	65.54u 0.00s 65.58r
-	gc fannkuch	123.98u 0.01s 124.04r
-	gc_B fannkuch	90.75u 0.00s 90.78r
-
-regex-dna 100000
-	# regexp code is slow on trivial regexp
-	gcc -O2 regex-dna.c -lpcre	0.91u 0.00s 0.92r
-	gc regex-dna	27.25u 0.02s 27.28r
-	gc_B regex-dna	29.51u 0.03s 29.55r
-
-spectral-norm 5500
-	# possibly inline evalA
-	gcc -O2 spectral-norm.c -lm	11.57u 0.00s 11.57r
-	gccgo -O2 spectral-norm.go	12.07u 0.01s 12.08r
-	gc spectral-norm	23.99u 0.00s 24.00r
-	gc_B spectral-norm	23.73u 0.00s 23.75r
-
-k-nucleotide 1000000
-	# string maps are slower than glib string maps
-	gcc -O2 -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include k-nucleotide.c -lglib-2.0	10.63u 0.02s 10.69r
-	gccgo -O2 k-nucleotide.go	23.19u 0.91s 24.12r
-	gc k-nucleotide	16.73u 0.04s 16.78r	# *** +5% (but this one seems to vary by more than that)
-	gc_B k-nucleotide	16.46u 0.04s 16.51r	# *** +5%
-
-mandelbrot 16000
-	gcc -O2 mandelbrot.c	56.16u 0.00s 56.16r
-	gccgo -O2 mandelbrot.go	57.41u 0.01s 57.42r
-	gc mandelbrot	64.05u 0.02s 64.08r	# *** -14%
-	gc_B mandelbrot	64.10u 0.02s 64.14r	# *** -14%
-
-meteor 2100
-	# we don't know
-	gcc -O2 meteor-contest.c	0.10u 0.00s 0.10r
-	gccgo -O2 meteor-contest.go	0.12u 0.00s 0.12r
-	gc meteor-contest	0.18u 0.00s 0.20r	# *** -25%
-	gc_B meteor-contest	0.17u 0.00s 0.18r	# *** -24%
-
-pidigits 10000
-	# bignum is slower than gmp
-	gcc -O2 pidigits.c -lgmp	2.57u 0.00s 2.57r
-	gc pidigits	71.82u 0.04s 71.89r
-	gc_B pidigits	71.84u 0.08s 71.98r
-
-threadring 50000000
-	gcc -O2 threadring.c -lpthread	30.91u 164.33s 204.57r
-	gccgo -O2 threadring.go	87.12u 460.04s 447.61r
-	gc threadring	38.55u 0.00s 38.56r	# *** +16%
-
-chameneos 6000000
-	gcc -O2 chameneosredux.c -lpthread	17.93u 323.65s 88.47r
-	gc chameneosredux	21.72u 0.00s 21.73r
-
-August 10 2009
-
-# In-place versions for some bignum operations.
-pidigits 10000
-	gcc -O2 pidigits.c -lgmp	2.56u 0.00s 2.57r
-	gc pidigits	55.22u 0.04s 55.29r	# *** -23%
-	gc_B pidigits	55.49u 0.02s 55.60r	# *** -23%
-
-September 3 2009
-
-# New 6g inlines slices, has a few other tweaks.
-# Complete rerun. Significant changes marked.
-
-fasta -n 25000000
-	# probably I/O library inefficiencies
-	gcc -O2 fasta.c	5.96u 0.00s 5.96r
-	gc fasta	10.63u 0.02s 10.66r
-	gc_B fasta	9.92u 0.01s 9.94r
-
-reverse-complement < output-of-fasta-25000000
-	# we don't know - memory cache behavior?
-	gcc -O2 reverse-complement.c	1.92u 0.33s 2.93r
-	gccgo -O2 reverse-complement.go	6.76u 0.72s 7.58r	# +5%
-	gc reverse-complement	6.59u 0.70s 7.29r	# +2%
-	gc_B reverse-complement	5.57u 0.80s 6.37r	# -10%
-
-nbody 50000000
-	# math.Sqrt needs to be in assembly; inlining is probably the other 50%
-	# also loop alignment appears to be critical
-	gcc -O2 nbody.c	21.28u 0.00s 21.28r
-	gccgo -O2 nbody.go	119.21u 0.00s 119.22r	# +2%
-	gc nbody	109.72u 0.00s 109.78r	# + 28% *****
-	gc_B nbody	85.90u 0.00s 85.91r
-
-binary-tree 15 # too slow to use 20
-	# memory allocation and garbage collection
-	gcc -O2 binary-tree.c -lm	0.86u 0.00s 0.87r
-	gccgo -O2 binary-tree.go	1.88u 0.54s 2.42r	# +17%
-	gccgo -O2 binary-tree-freelist.go	0.01u 0.01s 0.02r
-	gc binary-tree	8.94u 0.01s 8.96r	# -2%
-	gc binary-tree-freelist	0.47u 0.01s 0.48r
-
-fannkuch 12
-	# bounds checking is half the difference
-	# rest might be registerization
-	gcc -O2 fannkuch.c	60.12u 0.00s 60.12r
-	gccgo -O2 fannkuch.go	92.62u 0.00s 92.66r		# +41% ***
-	gc fannkuch	123.90u 0.00s 123.92r
-	gc_B fannkuch	89.71u 0.00s 89.74r	# -1%
-
-regex-dna 100000
-	# regexp code is slow on trivial regexp
-	gcc -O2 regex-dna.c -lpcre	0.88u 0.00s 0.88r
-	gc regex-dna	25.77u 0.01s 25.79r		# -5%
-	gc_B regex-dna	26.05u 0.02s 26.09r	# -12% ***
-
-spectral-norm 5500
-	# possibly inline evalA
-	gcc -O2 spectral-norm.c -lm	11.51u 0.00s 11.51r
-	gccgo -O2 spectral-norm.go	11.95u 0.00s 11.96r
-	gc spectral-norm	24.23u 0.00s 24.23r
-	gc_B spectral-norm	23.83u 0.00s 23.84r
-
-k-nucleotide 1000000
-	# string maps are slower than glib string maps
-	gcc -O2 -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include k-nucleotide.c -lglib-2.0	10.68u 0.04s 10.72r
-	gccgo -O2 k-nucleotide.go	23.03u 0.88s 23.92r
-	gc k-nucleotide	15.79u 0.05s 15.85r	# -5% (but this one seems to vary by more than that)
-	gc_B k-nucleotide	17.88u 0.05s 17.95r # +8% (ditto)
-
-mandelbrot 16000
-	gcc -O2 mandelbrot.c	56.17u 0.02s 56.20r
-	gccgo -O2 mandelbrot.go	56.74u 0.02s 56.79r	 # -1%
-	gc mandelbrot	63.31u 0.01s 63.35r	# -1%
-	gc_B mandelbrot	63.29u 0.00s 63.31r	# -1%
-
-meteor 2100
-	# we don't know
-	gcc -O2 meteor-contest.c	0.10u 0.00s 0.10r
-	gccgo -O2 meteor-contest.go	0.11u 0.00s 0.12r
-	gc meteor-contest	0.18u 0.00s 0.19r
-	gc_B meteor-contest	0.17u 0.00s 0.18r
-
-pidigits 10000
-	# bignum is slower than gmp
-	gcc -O2 pidigits.c -lgmp	2.56u 0.00s 2.57r
-	gc pidigits	55.87u 0.03s 55.91r
-	gc_B pidigits	55.93u 0.03s 55.99r
-
-# these tests are compared using real time, since they run multiple processors
-# accuracy probably low
-threadring 50000000
-	gcc -O2 threadring.c -lpthread	26.31u 164.69s 199.92r	# -2%
-	gccgo -O2 threadring.go	87.90u 487.26s 472.81r	# +6%
-	gc threadring	28.89u 0.00s 28.90r	# -25% ***
-
-chameneos 6000000
-	gcc -O2 chameneosredux.c -lpthread	16.41u 296.91s 81.17r	# -8%
-	gc chameneosredux	19.97u 0.00s 19.97r	# -8%
-
-Sep 22, 2009
-
-# 6g inlines sliceslice in most cases.
-
-fasta -n 25000000
-	# probably I/O library inefficiencies
-	gc fasta	10.24u 0.00s 10.25r	# -4%
-	gc_B fasta	9.68u 0.01s 9.69r	# -3%
-
-reverse-complement < output-of-fasta-25000000
-	# we don't know - memory cache behavior?
-	gc reverse-complement	6.67u 0.69s 7.37r	# +1%
-	gc_B reverse-complement	6.00u 0.64s 6.65r	# +7%
-
-nbody -n 50000000
-	# math.Sqrt needs to be in assembly; inlining is probably the other 50%
-	# also loop alignment appears to be critical
-	gc nbody	86.27u 0.00s 86.29r	# -21%
-	gc_B nbody	104.52u 0.00s 104.54r	# +22%
-
-fannkuch 12
-	# bounds checking is half the difference
-	# rest might be registerization
-	gc fannkuch	128.36u 0.00s 128.37r	# +4%
-	gc_B fannkuch	89.32u 0.00s 89.34r
-
-regex-dna 100000
-	# regexp code is slow on trivial regexp
-	gc regex-dna	24.82u 0.01s 24.86r	# -4%
-	gc_B regex-dna	24.55u 0.01s 24.57r	# -6%
-
-spectral-norm 5500
-	# possibly inline evalA
-	gc spectral-norm	24.05u 0.00s 24.07r	# -1%
-	gc_B spectral-norm	23.60u 0.00s 23.65r	 # -1%
-
-k-nucleotide 1000000
-	# string maps are slower than glib string maps
-	gc k-nucleotide	17.84u 0.04s 17.89r	# +13% but mysterious variation continues
-	gc_B k-nucleotide	15.56u 0.08s 15.65r	# -13% (ditto)
-
-mandelbrot 16000
-	gc mandelbrot	64.08u 0.01s 64.11r	# +1%
-	gc_B mandelbrot	64.04u 0.00s 64.05r	# +1%
-
-pidigits 10000
-	# bignum is slower than gmp
-	gc pidigits	58.68u 0.02s 58.72r	# +5%
-	gc_B pidigits	58.86u 0.05s 58.99r	# +5%
-
-# these tests are compared using real time, since they run multiple processors
-# accuracy probably low
-threadring 50000000
-	gc threadring	32.70u 0.02s 32.77r	# +13%
-
-chameneos 6000000
-	gc chameneosredux	26.62u 0.00s 26.63r	# +13%
-
-Sep 24, 2009
-
-# Sqrt now in assembler for 6g.
-nbody -n 50000000
-	# remember, at least for 6g, alignment of loops may be important
-	gcc -O2 nbody.c	21.24u 0.00s 21.25r
-	gccgo -O2 nbody.go	121.03u 0.00s 121.04r
-	gc nbody	30.26u 0.00s 30.27r	# -65% ***
-	gc_B nbody	30.20u 0.02s 30.22r	# -72% *** 
-
-Nov 13 2009
-
-# fix bug in regexp; take performance hit.  good regexps will come in time.
-regex-dna 100000
-	gcc -O2 regex-dna.c -lpcre	0.92u 0.00s 0.94r
-	gc regex-dna	29.78u 0.03s 29.83r
-	gc_B regex-dna	32.63u 0.03s 32.74r
-
-Nov 24 2009
-
-# Roger Peppe's rewrite of the benchmark
-chameneos 6000000
-	gcc -O2 chameneosredux.c -lpthread	18.00u 303.29s 83.64r
-	gc chameneosredux	12.10u 0.00s 12.10r  # 2.22X faster
-
-Jan 6, 2010
-
-# Long-overdue update.  All numbers included in this complete run.
-# Some programs (e.g. reverse-complement) rewritten for speed.
-# Regular expressions much faster in common cases (although still far behind PCRE)
-# Bignum stuff improved
-# Better (but sometimes slower) locking in channels.
-
-fasta -n 25000000
-	gcc -O2 fasta.c	5.99u 0.01s 6.00r
-	gc fasta	9.11u 0.00s 9.12r	# -11%
-	gc_B fasta	8.60u 0.00s 8.62r	# +12% ??
-
-reverse-complement < output-of-fasta-25000000
-	gcc -O2 reverse-complement.c	2.00u 0.80s 9.54r
-#	gccgo -O2 reverse-complement.go	4.57u 0.35s 4.94r	# 33% faster
-	gc reverse-complement	2.01u 0.38s 2.40r	# 3.3X faster
-	gc_B reverse-complement	1.88u 0.36s 2.24r	# 3.2X faster
-GOGC=off
-	gc reverse-complement	2.01u 0.35s 2.37r
-	gc_B reverse-complement	1.86u 0.32s 2.19r
-
-nbody -n 50000000
-	gcc -O2 nbody.c	21.28u 0.00s 21.31r
-	gccgo -O2 nbody.go	80.02u 0.00s 80.05r	# 33% faster
-	gc nbody	30.13u 0.00s 30.13r
-	gc_B nbody	29.89u 0.01s 29.91r
-
-binary-tree 15 # too slow to use 20
-	gcc -O2 binary-tree.c -lm	0.86u 0.00s 0.87r
-	gccgo -O2 binary-tree.go	4.82u 0.41s 5.24r	# 2.5X slower
-	gc binary-tree	7.23u 0.01s 7.25r	# # -19%
-	gc binary-tree-freelist	0.43u 0.00s 0.44r	# -9%
-
-fannkuch 12
-	gcc -O2 fannkuch.c	60.17u 0.00s 60.17r
-	gccgo -O2 fannkuch.go	78.47u 0.01s 78.49r
-	gc fannkuch	128.86u 0.00s 128.96r
-	gc_B fannkuch	90.17u 0.00s 90.21r
-
-regex-dna 100000
-	gcc -O2 regex-dna.c -lpcre	0.90u 0.00s 0.92r
-	gc regex-dna	9.48u 0.01s 9.50r	# 3.1X faster
-	gc_B regex-dna	9.08u 0.00s 9.10r	# 3.6X faster
-
-spectral-norm 5500
-	gcc -O2 spectral-norm.c -lm	11.48u 0.00s 11.48r
-	gccgo -O2 spectral-norm.go	11.68u 0.00s 11.70r
-	gc spectral-norm	23.98u 0.00s 23.99r
-	gc_B spectral-norm	23.68u 0.00s 23.69r
-
-k-nucleotide 1000000
-	gcc -O2 k-nucleotide.c	10.85u 0.04s 10.90r
-	gccgo -O2 k-nucleotide.go	25.26u 0.87s 26.14r
-	gc k-nucleotide	15.28u 0.06s 15.37r	# restored; mysterious variation continues
-	gc_B k-nucleotide	15.97u 0.03s 16.00r
-
-mandelbrot 16000
-	gcc -O2 mandelbrot.c	56.12u 0.01s 56.15r
-	gccgo -O2 mandelbrot.go	56.86u 0.01s 56.89r
-	gc mandelbrot	66.05u 0.00s 66.07r	# -3%
-	gc_B mandelbrot	66.06u 0.00s 66.07r	# -3%
-
-meteor 2100
-	gcc -O2 meteor-contest.c	0.10u 0.00s 0.10r
-	gccgo -O2 meteor-contest.go	0.12u 0.00s 0.12r
-	gc meteor-contest	0.17u 0.00s 0.17r
-	gc_B meteor-contest	0.15u 0.00s 0.16r
-
-pidigits 10000
-	gcc -O2 pidigits.c -lgmp	2.57u 0.00s 2.59r
-	gc pidigits	38.27u 0.02s 38.30r	# 1.5X faster
-	gc_B pidigits	38.27u 0.02s 38.31r	# 1.5X faster
-
-threadring 50000000
-	gcc -O2 threadring.c	37.11u 170.59s 212.75r
-	gccgo -O2 threadring.go	89.67u 447.56s 442.55r	# -6.5%
-	gc threadring	36.08u 0.04s 36.15r	# +10%
-
-chameneos 6000000
-	gcc -O2 chameneosredux.c -lpthread	19.02u 331.08s 90.79r
-	gc chameneosredux	12.54u 0.00s 12.55r
-
-Oct 19, 2010
-
-# Another long-overdue update. Some of the code is new; parallel versions
-# of some are added.  A few significant improvements.
-
-fasta -n 25000000
-	gcc -O2 fasta.c	4.92u 0.00s 4.93r
-	gccgo -O2 fasta.go	3.31u 0.00s 3.34r  # new code
-	gc fasta	3.68u 0.00s 3.69r  # 2.5X faster with no code
-	gc_B fasta	3.68u 0.00s 3.69r  # 2.3X faster with no code
-
-reverse-complement < output-of-fasta-25000000
-	gcc -O2 reverse-complement.c	1.93u 0.81s 11.24r
-	gccgo -O2 reverse-complement.go	1.58u 0.43s 2.04r  # first run with new code?
-	gc reverse-complement	1.84u 0.34s 2.20r  # 10% faster
-	gc_B reverse-complement	1.85u 0.32s 2.18r
-
-nbody -n 50000000
-	gcc -O2 nbody.c	21.35u 0.00s 21.36r
-	gccgo -O2 nbody.go	21.62u 0.00s 21.66r  # 3.7X faster - why??
-	gc nbody	29.78u 0.00s 29.79r
-	gc_B nbody	29.72u 0.00s 29.72r
-
-binary-tree 15 # too slow to use 20
-	gcc -O2 binary-tree.c -lm	0.86u 0.00s 0.88r
-	gccgo -O2 binary-tree.go	4.05u 0.02s 4.08r  # 28% faster
-	gccgo -O2 binary-tree-freelist	0.34u 0.08s 0.34r
-	gc binary-tree	5.94u 0.00s 5.95r  # 20% faster
-	gc binary-tree-freelist	0.50u 0.01s 0.54r
-
-fannkuch 12
-	gcc -O2 fannkuch.c	60.45u 0.00s 60.45r
-	gccgo -O2 fannkuch.go	64.64u 0.00s 64.64r
-	gccgo -O2 fannkuch-parallel.go	115.63u 0.00s 31.58r
-	gc fannkuch	126.52u 0.04s 126.68r
-	gc fannkuch-parallel	238.82u 0.10s 65.93r  # GOMAXPROCS=4
-	gc_B fannkuch	88.99u 0.00s 89.02r
-
-regex-dna 100000
-	gcc -O2 regex-dna.c -lpcre	0.89u 0.00s 0.89r
-	gc regex-dna	8.99u 0.02s 9.03r
-	gc regex-dna-parallel	8.94u 0.02s 3.68r  # GOMAXPROCS=4
-	gc_B regex-dna	9.12u 0.00s 9.14r
-
-spectral-norm 5500
-	gcc -O2 spectral-norm.c -lm	11.55u 0.00s 11.57r
-	gccgo -O2 spectral-norm.go	11.73u 0.00s 11.75r
-	gc spectral-norm	23.74u 0.00s 23.79r
-	gc_B spectral-norm	24.49u 0.02s 24.54r
-
-k-nucleotide 1000000
-	gcc -O2 k-nucleotide.c	11.44u 0.06s 11.50r
-	gccgo -O2 k-nucleotide.go	8.65u 0.04s 8.71r
-	gccgo -O2 k-nucleotide-parallel.go	8.75u 0.03s 2.97r # set GOMAXPROCS=4
-	gc k-nucleotide	14.92u 0.05s 15.01r
-	gc k-nucleotide-parallel	16.96u 0.06s 6.53r  # set GOMAXPROCS=4
-	gc_B k-nucleotide	15.97u 0.03s 16.08r
-
-mandelbrot 16000
-	gcc -O2 mandelbrot.c	56.32u 0.00s 56.35r
-	gccgo -O2 mandelbrot.go	55.62u 0.02s 55.77r
-	gc mandelbrot	64.85u 0.01s 64.94r
-	gc_B mandelbrot	65.02u 0.01s 65.14r
-
-meteor 2100
-	gcc -O2 meteor-contest.c	0.10u 0.00s 0.10r
-	gccgo -O2 meteor-contest.go	0.10u 0.00s 0.11r
-	gc meteor-contest	0.17u 0.00s 0.18r
-	gc_B meteor-contest	0.16u 0.00s 0.16r
-
-pidigits 10000
-	gcc -O2 pidigits.c -lgmp	2.58u 0.00s 2.59r
-	gccgo -O2 pidigits.go	14.06u 0.01s 14.09r # first run?
-	gc pidigits	8.47u 0.05s 8.55r # 4.5X faster due to package big
-	gc_B pidigits	8.33u 0.01s 8.36r # 4.5X faster due to package big
-
-threadring 50000000
-	gcc -O2 threadring.c	28.18u 153.19s 186.47r
-	gccgo -O2 threadring.go	110.10u 516.48s 515.25r
-	gc threadring	40.39u 0.00s 40.40r
-
-chameneos 6000000
-	gcc -O2 chameneosredux.c -lpthread	18.20u 301.55s 83.10r
-	gccgo -O2 chameneosredux.go	52.22u 324.54s 201.21r
-	gc chameneosredux	13.52u 0.00s 13.54r
-
-Dec 14, 2010
-
-# Improved regex code (same algorithm) gets ~30%.
-
-regex-dna 100000
-	gcc -O2 regex-dna.c -lpcre	0.77u 0.01s 0.78r
-	gc regex-dna	6.80u 0.00s 6.81r
-	gc regex-dna-parallel	6.82u 0.01s 2.75r
-	gc_B regex-dna	6.69u 0.02s 6.70r
-
-Feb 15, 2011
-
-# Improved GC, still single-threaded but more efficient
-
-fasta -n 25000000
-	gcc -O2 fasta.c	3.40u 0.00s 3.40r
-	gccgo -O2 fasta.go	3.51u 0.00s 3.50r
-	gc fasta	3.66u 0.01s 3.66r
-	gc_B fasta	3.66u 0.00s 3.66r
-
-reverse-complement < output-of-fasta-25000000
-	gcc -O2 reverse-complement.c	1.86u 1.29s 4.93r
-	gccgo -O2 reverse-complement.go	2.18u 0.41s 2.60r
-	gc reverse-complement	1.67u 0.48s 2.15r
-	gc_B reverse-complement	1.71u 0.45s 2.15r
-
-nbody -n 50000000
-	gcc -O2 -lm nbody.c	21.64u 0.00s 21.64r
-	gccgo -O2 nbody.go	21.46u 0.00s 21.45r
-	gc nbody	29.07u 0.00s 29.06r
-	gc_B nbody	31.61u 0.00s 31.61r
-
-binary-tree 15 # too slow to use 20
-	gcc -O2 binary-tree.c -lm	0.88u 0.00s 0.87r
-	gccgo -O2 binary-tree.go	2.74u 0.07s 2.81r
-	gccgo -O2 binary-tree-freelist.go	0.01u 0.00s 0.00r
-	gc binary-tree	4.22u 0.02s 4.24r
-	gc binary-tree-freelist	0.54u 0.02s 0.55r
-
-fannkuch 12
-	gcc -O2 fannkuch.c	57.64u 0.00s 57.64r
-	gccgo -O2 fannkuch.go	65.79u 0.00s 65.82r
-	gccgo -O2 fannkuch-parallel.go	160.91u 0.02s 43.90r
-	gc fannkuch	126.36u 0.03s 126.53r
-	gc fannkuch-parallel	175.23u 0.04s 45.49r
-	gc_B fannkuch	89.23u 0.00s 89.24r
-
-regex-dna 100000
-	gcc -O2 regex-dna.c -lpcre	0.77u 0.01s 0.80r
-	gccgo -O2 regex-dna.go	12.38u 0.10s 12.52r
-	gccgo -O2 regex-dna-parallel.go	43.96u 4.64s 15.11r
-	gc regex-dna	7.03u 0.01s 7.05r
-	gc regex-dna-parallel	6.85u 0.05s 2.70r
-	gc_B regex-dna	6.87u 0.02s 6.89r
-
-spectral-norm 5500
-	gcc -O2 spectral-norm.c -lm	12.29u 0.00s 12.28r
-	gccgo -O2 spectral-norm.go	11.79u 0.00s 11.79r
-	gc spectral-norm	24.00u 0.02s 24.05r
-	gc_B spectral-norm	24.59u 0.01s 24.59r
-
-k-nucleotide 1000000
-	gcc -O2 k-nucleotide.c	9.75u 0.07s 9.82r
-	gccgo -O2 k-nucleotide.go	8.92u 0.06s 8.98r
-	gccgo -O2 k-nucleotide-parallel.go	8.40u 0.04s 2.76r
-	gc k-nucleotide	17.01u 0.03s 17.04r
-	gc k-nucleotide-parallel	16.51u 0.08s 6.21r
-	gc_B k-nucleotide	16.94u 0.08s 17.02r
-
-mandelbrot 16000
-	gcc -O2 mandelbrot.c	54.60u 0.00s 54.66r
-	gccgo -O2 mandelbrot.go	59.38u 0.00s 59.41r
-	gc mandelbrot	64.93u 0.04s 65.08r
-	gc_B mandelbrot	64.85u 0.03s 64.92r
-
-meteor 2098
-	gcc -O2 meteor-contest.c	0.10u 0.01s 0.10r
-	gccgo -O2 meteor-contest.go	0.11u 0.00s 0.11r
-	gc meteor-contest	0.18u 0.00s 0.17r
-	gc_B meteor-contest	0.17u 0.00s 0.16r
-
-pidigits 10000
-	gcc -O2 pidigits.c -lgmp	2.24u 0.00s 2.23r
-	gccgo -O2 pidigits.go	14.05u 0.00s 14.06r
-	gc pidigits	6.34u 0.05s 6.38r
-	gc_B pidigits	6.37u 0.02s 6.38r
-
-threadring 50000000
-	gcc -O2 threadring.c	30.50u 258.05s 325.72r
-	gccgo -O2 threadring.go	92.87u 748.39s 728.46r
-	gc threadring	38.03u 0.01s 38.04r
-
-# Apr 15, 2011
-# Move to new machine, Intel Xeon E5520@2.27GHz.
-# (Was Opteron(tm) Processor 8214 HE)
-
-fasta -n 25000000
-OLD:
-	gcc -O2 fasta.c	3.39u 0.04s 3.42r
-	gccgo -O2 fasta.go	3.52u 0.00s 3.52r
-	gc fasta	3.63u 0.04s 3.67r
-	gc_B fasta	3.66u 0.00s 3.66r
-NEW:
-	gcc -O2 fasta.c	1.45u 0.02s 1.47r
-	gccgo -O2 fasta.go	1.51u 0.01s 1.51r
-	gc fasta	2.04u 0.00s 2.04r
-	gc_B fasta	2.05u 0.00s 2.04r
-
-reverse-complement < output-of-fasta-25000000
-OLD:
-	gcc -O2 reverse-complement.c	1.87u 1.51s 7.02r
-	gccgo -O2 reverse-complement.go	1.56u 0.54s 3.37r
-	gc reverse-complement	1.73u 0.36s 2.08r
-	gc_B reverse-complement	1.75u 0.37s 2.12r
-NEW:
-	gcc -O2 reverse-complement.c	1.20u 0.47s 12.96r
-	gccgo -O2 reverse-complement.go	0.88u 0.14s 1.01r
-	gc reverse-complement	1.13u 0.17s 1.30r
-	gc_B reverse-complement	1.11u 0.09s 1.20r
-
-nbody -n 50000000
-OLD:
-	gcc -O2 -lm nbody.c	21.90u 0.00s 21.92r
-	gccgo -O2 nbody.go	23.12u 0.03s 23.19r
-	gc nbody	29.07u 0.00s 29.07r
-	gc_B nbody	31.84u 0.00s 31.85r
-NEW:
-	gcc -O2 -lm nbody.c	13.01u 0.00s 13.03r
-	gccgo -O2 nbody.go	13.35u 0.00s 13.37r
-	gc nbody	21.78u 0.00s 21.82r
-	gc_B nbody	21.72u 0.00s 21.76r
-
-binary-tree 15 # too slow to use 20
-OLD:
-	gcc -O2 binary-tree.c -lm	0.83u 0.02s 0.84r
-	gccgo -O2 binary-tree.go	2.61u 0.02s 2.62r
-	gccgo -O2 binary-tree-freelist.go	0.32u 0.01s 0.32r
-	gc binary-tree	3.93u 0.04s 3.97r
-	gc binary-tree-freelist	0.47u 0.03s 0.50r
-NEW:
-	gcc -O2 binary-tree.c -lm	0.60u 0.00s 0.59r
-	gccgo -O2 binary-tree.go	1.53u 0.00s 1.52r
-	gccgo -O2 binary-tree-freelist.go	0.01u 0.00s 0.00r
-	gc binary-tree	1.93u 0.02s 1.95r
-	gc binary-tree-freelist	0.32u 0.01s 0.32r
-
-fannkuch 12
-OLD:
-	gcc -O2 fannkuch.c	57.64u 0.00s 57.64r
-	gccgo -O2 fannkuch.go	65.56u 0.01s 65.65r
-	gccgo -O2 fannkuch-parallel.go	179.12u 0.00s 49.82r
-	gc fannkuch	126.39u 0.00s 126.39r
-	gc fannkuch-parallel	172.49u 0.02s 45.44r
-	gc_B fannkuch	89.30u 0.00s 89.28r
-NEW:
-	gcc -O2 fannkuch.c	45.17u 0.00s 45.26r
-	gccgo -O2 fannkuch.go	53.63u 0.00s 53.73r
-	gccgo -O2 fannkuch-parallel.go	216.72u 0.00s 58.42r
-	gc fannkuch	108.21u 0.00s 108.44r
-	gc fannkuch-parallel	227.20u 0.00s 57.27r
-	gc_B fannkuch	56.14u 0.00s 56.26r
-
-regex-dna 100000
-OLD:
-	gcc -O2 regex-dna.c -lpcre	0.77u 0.01s 0.78r
-	gccgo -O2 regex-dna.go	10.15u 0.02s 10.23r
-	gccgo -O2 regex-dna-parallel.go	33.81u 3.22s 11.62r
-	gc regex-dna	6.52u 0.04s 6.56r
-	gc regex-dna-parallel	6.84u 0.03s 2.70r
-	gc_B regex-dna	6.83u 0.01s 6.84r
-NEW:
-	gcc -O2 regex-dna.c -lpcre	0.47u 0.00s 0.47r
-	gccgo -O2 regex-dna.go	6.00u 0.00s 6.00r
-	gccgo -O2 regex-dna-parallel.go	44.54u 1.57s 6.51r
-	gc regex-dna	5.41u 0.01s 5.42r
-	gc regex-dna-parallel	5.62u 0.01s 2.20r
-	gc_B regex-dna	5.50u 0.00s 5.50r
-
-spectral-norm 5500
-OLD:
-	gcc -O2 spectral-norm.c -lm	12.29u 0.00s 12.28r
-	gccgo -O2 spectral-norm.go	11.56u 0.00s 11.55r
-	gc spectral-norm	23.98u 0.00s 24.00r
-	gc_B spectral-norm	24.62u 0.00s 24.65r
-NEW:
-	gcc -O2 spectral-norm.c -lm	15.79u 0.00s 15.82r
-	gccgo -O2 spectral-norm.go	15.32u 0.00s 15.35r
-	gc spectral-norm	19.62u 0.01s 19.67r
-	gc_B spectral-norm	19.62u 0.00s 19.66r
-
-k-nucleotide 1000000
-OLD:
-	gcc -O2 k-nucleotide.c	9.82u 0.06s 9.87r
-	gccgo -O2 k-nucleotide.go	8.30u 0.02s 8.32r
-	gccgo -O2 k-nucleotide-parallel.go	8.84u 0.05s 3.02r
-	gc k-nucleotide	15.38u 0.07s 15.44r
-	gc k-nucleotide-parallel	16.40u 0.03s 5.93r
-	gc_B k-nucleotide	15.19u 0.05s 15.23r
-NEW:
-	gcc -O2 -k-nucleotide.c	4.88u 0.03s 4.92r
-	gccgo -O2 k-nucleotide.go	5.94u 0.01s 5.96r
-	gccgo -O2 k-nucleotide-parallel.go	6.44u 0.03s 1.47r
-	gc k-nucleotide	9.61u 0.01s 9.63r
-	gc k-nucleotide-parallel	9.70u 0.00s 3.39r
-	gc_B k-nucleotide	9.19u 0.03s 9.23r
-
-mandelbrot 16000
-OLD:
-	gcc -O2 mandelbrot.c	54.54u 0.00s 54.56r
-	gccgo -O2 mandelbrot.go	59.63u 0.03s 59.67r
-	gc mandelbrot	64.82u 0.00s 64.83r
-	gc_B mandelbrot	64.84u 0.00s 64.91r
-NEW:
-	gcc -O2 mandelbrot.c	36.07u 0.01s 36.15r
-	gccgo -O2 mandelbrot.go	43.57u 0.00s 43.66r
-	gc mandelbrot	60.66u 0.00s 60.79r
-	gc_B mandelbrot	60.90u 0.00s 61.03r
-
-meteor 2098
-OLD:
-	gcc -O2 meteor-contest.c	0.11u 0.00s 0.10r
-	gccgo -O2 meteor-contest.go	0.10u 0.01s 0.10r
-	gc meteor-contest	0.18u 0.00s 0.17r
-	gc_B meteor-contest	0.17u 0.00s 0.16r
-NEW:
-	gcc -O2 meteor-contest.c	0.10u 0.00s 0.09r
-	gccgo -O2 meteor-contest.go	0.10u 0.00s 0.09r
-	gc meteor-contest	0.14u 0.00s 0.14r
-	gc_B meteor-contest	0.13u 0.00s 0.13r
-
-pidigits 10000
-OLD:
-	gcc -O2 pidigits.c -lgmp	2.22u 0.00s 2.21r
-	gccgo -O2 pidigits.go	13.39u 0.00s 13.40r
-	gc pidigits	6.42u 0.04s 6.45r
-	gc_B pidigits	6.45u 0.02s 6.47r
-NEW:
-	gcc -O2 pidigits.c -lgmp	2.27u 0.00s 2.29r
-	gccgo -O2 pidigits.go	9.21u 0.00s 9.22r
-	gc pidigits	3.60u 0.00s 3.60r
-	gc_B pidigits	3.56u 0.02s 3.58r
-
-threadring 50000000
-OLD:
-	gcc -O2 threadring.c -lpthread	34.51u 267.95s 336.12r
-	gccgo -O2 threadring.go	103.51u 588.57s 627.16r
-	gc threadring	54.68u 0.00s 54.73r
-NEW:
-	gcc -O2 threadring.c 32.00u 259.39s 369.74r
-	gccgo -O2 threadring.go	133.06u 546.02s 595.33r
-	gc threadring	16.75u 0.02s 16.80r
-
-chameneos 6000000
-OLD:
-	gcc -O2 chameneosredux.c -lpthread	12.65u 31.02s 13.33r
-	gccgo -O2 chameneosredux.go	47.04u 302.84s 252.29r
-	gc chameneosredux	14.14u 0.00s 14.14r
-NEW:
-	gcc -O2 chameneosredux.c -lpthread	8.05u 63.43s 11.16r
-	gccgo -O2 chameneosredux.go	82.95u 304.37s 207.64r
-	gc chameneosredux	9.42u 0.00s 9.43r
-
-# May 13, 2011
-# after gc update to inline append when possible - 35% faster
-
-regex-dna 100000
-	gc regex-dna	3.94u 0.00s 3.95r
-	gc regex-dna-parallel	4.15u 0.01s 1.63r
-	gc_B regex-dna	4.01u 0.01s 4.02r
-
-# Aug 4, 2011
-# After various updates to locking code and some runtime changes.
-# Slowdowns believed due to slower (but more correct) memmove.
-
-fannkuch 12
-	gccgo -O2 fannkuch.go	51.59u 0.00s 51.69r # -4%
-	gccgo -O2 fannkuch-parallel.go	253.17u 0.00s 64.67r # -11%
-	gc fannkuch	103.14u 0.00s 103.36r # -5%
-	gc fannkuch-parallel	189.63u 0.00s 49.37r # +9%
-	gc_B fannkuch	49.19u 0.00s 49.29r # -14%
-
-regex-dna 100000
-	gc regex-dna	3.78u 0.00s 3.78r # -43%
-	gc regex-dna-parallel	3.84u 0.02s 1.48r # -49%
-	gc_B regex-dna	3.62u 0.00s 3.63r # -52%
-
-k-nucleotide 1000000
-	gc k-nucleotide	12.23u 0.02s 12.27r # +27%
-	gc k-nucleotide-parallel	12.76u 0.02s 4.37r # +29%
-	gc_B k-nucleotide	12.18u 0.01s 12.21r # +33%
-
-threadring 50000000
-	gc threadring	17.49u 0.00s 17.53r # +4%
-
-chameneos 6000000
-	gc chameneosredux	7.61u 0.00s 7.63r # -24%
-
-Aug 9, 2011
-# After custom algorithms for 1- 2- 4- 8-byte scalars.
-
-fannkuch 12
-	gc fannkuch-parallel	157.17u 0.00s 41.08r # -17%
-
-k-nucleotide 1000000
-	gc k-nucleotide	8.72u 0.03s 8.76r # -39%
-	gc k-nucleotide-parallel	8.79u 0.01s 3.14r # -39%
-	gc_B k-nucleotide	8.65u 0.03s 8.69r # -39%
-
-pidigits 10000
-	gc pidigits	3.71u 0.02s 3.73r # +4%
-	gc_B pidigits	3.73u 0.00s 3.73r # +4%
-
-threadring 50000000
-	gc threadring	14.51u 0.00s 14.54r # -17%
-
-chameneos 6000000
-	gc chameneosredux	7.41u 0.00s 7.42r # -3%
-
-# A complete run at the Go 1 release.
-# Significant changes:
-# - gccgo is now enabled for all tests (goroutines are cheap enough)
-# - threadring and chameneos are 14% faster, probably due to runtime changes
-# - regex-dna 36% faster
-# - fannkuch-parallel (only) slowed down 40%
-# - gccgo on binary-tree-freelist is still optimized to nothing
-# Other changes are modest.
-
-fasta -n 25000000
-	gcc -O2 fasta.c	1.45u 0.02s 1.48r
-	gccgo -O2 fasta.go	1.46u 0.00s 1.47r
-	gc fasta	1.99u 0.01s 2.00r
-	gc_B fasta	1.99u 0.01s 2.01r
-
-reverse-complement < output-of-fasta-25000000
-	gcc -O2 reverse-complement.c	0.95u 0.48s 4.99r
-	gccgo -O2 reverse-complement.go	0.93u 0.16s 1.09r
-	gc reverse-complement	1.20u 0.19s 1.39r
-	gc_B reverse-complement	1.04u 0.16s 1.20r
-
-nbody -n 50000000
-	gcc -O2 -lm nbody.c	13.02u 0.00s 13.05r
-	gccgo -O2 nbody.go	14.46u 0.00s 14.49r
-	gc nbody	21.79u 0.00s 21.84r
-	gc_B nbody	21.74u 0.00s 21.79r
-
-binary-tree 15 # too slow to use 20
-	gcc -O2 binary-tree.c -lm	0.60u 0.01s 0.61r
-	gccgo -O2 binary-tree.go	1.30u 0.01s 1.32r
-	gccgo -O2 binary-tree-freelist.go	0.00u 0.00s 0.00r
-	gc binary-tree	1.84u 0.01s 1.86r
-	gc binary-tree-freelist	0.33u 0.00s 0.33r
-
-fannkuch 12
-	gcc -O2 fannkuch.c	45.24u 0.00s 45.34r
-	gccgo -O2 fannkuch.go	59.76u 0.01s 59.90r
-	gccgo -O2 fannkuch-parallel.go	218.20u 0.01s 61.60r
-	gc fannkuch	103.92u 0.00s 104.16r
-	gc fannkuch-parallel	221.61u 0.00s 60.49r
-	gc_B fannkuch	53.17u 0.00s 53.30r
-
-regex-dna 100000
-	gcc -O2 regex-dna.c -lpcre	0.47u 0.00s 0.48r
-	gccgo -O2 regex-dna.go	6.52u 0.00s 6.54r
-	gccgo -O2 regex-dna-parallel.go	14.40u 0.73s 4.35r
-	gc regex-dna	2.63u 0.02s 2.66r # -36%
-	gc regex-dna-parallel	2.87u 0.01s 1.11r
-	gc_B regex-dna	2.65u 0.00s 2.66r
-
-spectral-norm 5500
-	gcc -O2 spectral-norm.c -lm	15.78u 0.00s 15.82r
-	gccgo -O2 spectral-norm.go	15.79u 0.00s 15.83r
-	gc spectral-norm	19.76u 0.00s 19.80r
-	gc_B spectral-norm	19.73u 0.01s 19.78r
-
-k-nucleotide 1000000
-	gcc -O2  k-nucleotide.c	5.59u 0.03s 5.63r
-	gccgo -O2 k-nucleotide.go	4.09u 0.03s 4.13r
-	gccgo -O2 k-nucleotide-parallel.go	4.50u 0.06s 1.63r
-	gc k-nucleotide	9.23u 0.02s 9.27r
-	gc k-nucleotide-parallel	9.87u 0.03s 3.55r
-	gc_B k-nucleotide	9.20u 0.00s 9.22r
-
-mandelbrot 16000
-	gcc -O2 mandelbrot.c	36.09u 0.00s 36.18r
-	gccgo -O2 mandelbrot.go	41.69u 0.01s 41.80r
-	gc mandelbrot	60.91u 0.02s 61.07r
-	gc_B mandelbrot	60.90u 0.00s 61.04r
-
-meteor 2098
-	gcc -O2 meteor-contest.c	0.09u 0.00s 0.09r
-	gccgo -O2 meteor-contest.go	0.09u 0.00s 0.09r
-	gc meteor-contest	0.14u 0.00s 0.15r
-	gc_B meteor-contest	0.14u 0.00s 0.14r
-
-pidigits 10000
-	gcc -O2 pidigits.c -lgmp	2.27u 0.00s 2.27r
-	gccgo -O2 pidigits.go	8.65u 0.00s 8.67r
-	gc pidigits	3.70u 0.04s 3.75r
-	gc_B pidigits	3.72u 0.02s 3.75r
-
-threadring 50000000
-	gcc -O2 threadring.c	40.91u 369.85s 323.31r
-	gccgo -O2 threadring.go	26.97u 30.82s 57.93r
-	gc threadring	12.81u 0.01s 12.85r # -13%
-
-chameneos 6000000
-	gcc -O2 chameneosredux.c -lpthread	9.44u 72.90s 12.65r
-	gccgo -O2 chameneosredux.go	7.73u 7.53s 15.30r
-	gc chameneosredux	6.51u 0.00s 6.53r # - 14%
-
-# After http://codereview.appspot.com/6248049, moving panicindex
-# calls out of line (putting the likely code into a single path and shortening
-# loops). Significant changes since the last run (note: some are slower for
-# unrelated and as yet undiagnosed reasons):
-
-nbody -n 50000000
-	gc nbody	19.10u 0.01s 19.19r # -12%
-	gc_B nbody	19.19u 0.00s 19.23r # -12%
-
-binary-tree 15 # too slow to use 20
-	gc binary-tree	1.49u 0.01s 1.51r # -19%
-	
-fannkuch 12
-	gc fannkuch	60.79u 0.00s 60.92r # -41%
-	gc fannkuch-parallel	183.51u 0.01s 51.75r # -14%
-	gc_B fannkuch	51.68u 0.00s 51.79r # -3%
-
-k-nucleotide 1000000
-	gc k-nucleotide	9.74u 0.04s 9.80r # +6%
-	gc k-nucleotide-parallel	9.89u 0.05s 3.59r # +1%
-	gc_B k-nucleotide	9.39u 0.02s 9.43r # +2%
-
-mandelbrot (much slower, due to unrelated http://codereview.appspot.com/6209077)
-	gc mandelbrot	100.98u 0.00s 101.20r # +65%
-	gc_B mandelbrot	100.90u 0.01s 101.17r # +65%
-
-meteor 2098
-	gc meteor-contest	0.13u 0.00s 0.13r # -13%
-	gc_B meteor-contest	0.13u 0.00s 0.13r # -7%
-
-# May 30, 2012.
-# After http://codereview.appspot.com/6261051, restoring old code generated
-# for floating-point constants. Mandelbrot is back to its previous numbers.
-
-mandelbrot 16000
-	gcc -O2 mandelbrot.c	36.07u 0.00s 36.16r
-	gccgo -O2 mandelbrot.go	41.72u 0.01s 41.90r
-	gc mandelbrot	60.62u 0.00s 60.76r
-	gc_B mandelbrot	60.68u 0.00s 60.82r
-
-# May 30, 2012.
-# After http://codereview.appspot.com/6248068, better FP code
-# by avoiding MOVSD between registers.
-# Plus some other timing changes that have crept in from other speedups,
-# from garbage collection to Printf.
-
-fasta -n 25000000
-	gc fasta	1.76u 0.00s 1.76r # -12%
-	gc_B fasta	1.71u 0.00s 1.72r # -12%
-
-nbody -n 50000000
-	gc nbody	17.56u 0.00s 17.60r # -8%
-	gc_B nbody	17.30u 0.00s 17.34r # -10%
-
-fannkuch 12
-	gc fannkuch-parallel	155.92u 0.01s 44.05r # -15%
-
-k-nucleotide 1000000
-	gc k-nucleotide	9.22u 0.01s 9.26r # -5%
-	gc k-nucleotide-parallel	9.23u 0.03s 3.26r # -9%
-	gc_B k-nucleotide	9.22u 0.03s 9.28r # -2%
-
-mandelbrot 16000
-	gc mandelbrot	44.80u 0.00s 44.90r # -27%
-	gc_B mandelbrot	44.81u 0.00s 44.92r # -26%
-
-pidigits 10000
-	gc pidigits	3.51u 0.00s 3.52r # -6%
-	gc_B pidigits	3.51u 0.00s 3.52r # -6%
-
-# Aug 28, 2012
-# After some assembler work in package big.
-pidigits 10000
-	gc pidigits	2.85u 0.02s 2.88r # -22%
-	gc_B pidigits	2.88u 0.01s 2.90r # -21%
-
-# Sep 26, 2012
-# 64-bit ints, plus significantly better floating-point code.
-# Interesting details:
-# 	Generally something in the 0-10% slower range, some (binary tree) more
-#	Floating-point noticeably faster:
-#		nbody -25%
-#		mandelbrot -37% relative to Go 1.
-#	Other:
-#		regex-dna +47%
-fasta -n 25000000
-	gcc -O2 fasta.c	1.43u 0.03s 1.46r
-	gccgo -O2 fasta.go	1.47u 0.00s 1.47r
-	gc fasta	1.78u 0.01s 1.80r
-	gc_B fasta	1.76u 0.00s 1.76r
-
-reverse-complement < output-of-fasta-25000000
-	gcc -O2 reverse-complement.c	1.14u 0.39s 11.19r
-	gccgo -O2 reverse-complement.go	0.91u 0.17s 1.09r
-	gc reverse-complement	1.12u 0.18s 1.31r
-	gc_B reverse-complement	1.12u 0.15s 1.28r
-
-nbody -n 50000000
-	gcc -O2 nbody.c -lm	13.02u 0.00s 13.05r
-	gccgo -O2 nbody.go	13.90u 0.00s 13.93r
-	gc nbody	17.05u 0.00s 17.09r
-	gc_B nbody	16.30u 0.00s 16.34r
-
-binary-tree 15 # too slow to use 20
-	gcc -O2 binary-tree.c -lm	0.61u 0.00s 0.61r
-	gccgo -O2 binary-tree.go	1.24u 0.04s 1.29r
-	gccgo -O2 binary-tree-freelist.go	0.21u 0.01s 0.22r
-	gc binary-tree	1.93u 0.02s 1.96r
-	gc binary-tree-freelist	0.32u 0.00s 0.33r
-
-fannkuch 12
-	gcc -O2 fannkuch.c	45.19u 0.00s 45.29r
-	gccgo -O2 fannkuch.go	60.32u 0.00s 60.45r
-	gccgo -O2 fannkuch-parallel.go	185.59u 0.00s 59.49r
-	gc fannkuch	72.14u 0.00s 72.30r
-	gc fannkuch-parallel	172.54u 0.00s 43.59r
-	gc_B fannkuch	53.55u 0.00s 53.67r
-
-regex-dna 100000
-	gcc -O2 regex-dna.c -lpcre	0.47u 0.00s 0.47r
-	gccgo -O2 regex-dna.go	6.49u 0.05s 6.56r
-	gccgo -O2 regex-dna-parallel.go	14.60u 0.67s 4.42r
-	gc regex-dna	3.91u 0.00s 3.92r
-	gc regex-dna-parallel	4.01u 0.03s 1.56r
-	gc_B regex-dna	3.91u 0.00s 3.92r
-
-spectral-norm 5500
-	gcc -O2 spectral-norm.c -lm	15.85u 0.00s 15.89r
-	gccgo -O2 spectral-norm.go	15.86u 0.00s 15.89r
-	gc spectral-norm	19.72u 0.00s 19.76r
-	gc_B spectral-norm	19.68u 0.01s 19.74r
-
-k-nucleotide 1000000
-	gcc -O2 k-nucleotide.c -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include -lglib-2.0 	4.90u 0.01s 4.93r
-	gccgo -O2 k-nucleotide.go	4.78u 0.01s 4.80r
-	gccgo -O2 k-nucleotide-parallel.go	6.49u 0.02s 2.18r
-	gc k-nucleotide	9.05u 0.02s 9.09r
-	gc k-nucleotide-parallel	9.27u 0.01s 3.29r
-	gc_B k-nucleotide	8.95u 0.03s 9.00r
-
-mandelbrot 16000
-	gcc -O2 mandelbrot.c	36.11u 0.00s 36.19r
-	gccgo -O2 mandelbrot.go	43.67u 0.00s 43.77r
-	gc mandelbrot	38.57u 0.00s 38.66r
-	gc_B mandelbrot	38.59u 0.00s 38.68r
-
-meteor 2098
-	gcc -O2 meteor-contest.c	0.09u 0.00s 0.09r
-	gccgo -O2 meteor-contest.go	0.09u 0.00s 0.09r
-	gc meteor-contest	0.13u 0.00s 0.14r
-	gc_B meteor-contest	0.12u 0.00s 0.13r
-
-pidigits 10000
-	gcc -O2 pidigits.c -lgmp	2.26u 0.00s 2.27r
-	gccgo -O2 pidigits.go	9.05u 0.00s 9.07r
-	gc pidigits	2.88u 0.02s 2.90r
-	gc_B pidigits	2.89u 0.00s 2.90r
-
-threadring 50000000
-	gcc -O2 threadring.c -lpthread	37.30u 327.81s 289.28r
-	gccgo -O2 threadring.go	42.83u 26.15s 69.14r
-	gc threadring	13.00u 0.00s 13.03r
-
-chameneos 6000000
-	gcc -O2 chameneosredux.c -lpthread	8.80u 71.67s 12.19r
-	gccgo -O2 chameneosredux.go	11.28u 6.68s 18.00r
-	gc chameneosredux	6.94u 0.00s 6.96r
-
-# May 23, 2013
-# Go 1.1, which includes precise GC, new scheduler, faster maps.
-# 20%-ish speedups across many benchmarks.
-# gccgo showing significant improvement (even though it's not yet up to Go 1.1)
-#
-# Standouts:
-#	fannkuch, regex-dna, k-nucleotide, threadring, chameneos
-
-fasta -n 25000000
-	gcc -m64 -O2 fasta.c	1.54u 0.01s 1.55r
-	gccgo -O2 fasta.go	1.42u 0.00s 1.43r
-	gc fasta	1.50u 0.01s 1.52r # -16%
-	gc_B fasta	1.46u 0.00s 1.46r # -17%
-
-reverse-complement < output-of-fasta-25000000
-	gcc -m64 -O2 reverse-complement.c	0.87u 0.37s 4.36r
-	gccgo -O2 reverse-complement.go	0.77u 0.15s 0.93r # -15%
-	gc reverse-complement	0.99u 0.12s 1.12r # -15%
-	gc_B reverse-complement	0.85u 0.17s 1.02r # -21%
-
-nbody -n 50000000
-	gcc -m64 -O2 nbody.c -lm	13.50u 0.00s 13.53r
-	gccgo -O2 nbody.go	13.98u 0.01s 14.02r
-	gc nbody	16.63u 0.01s 16.67r
-	gc_B nbody	15.74u 0.00s 15.76r
-
-binary-tree 15 # too slow to use 20
-	gcc -m64 -O2 binary-tree.c -lm	0.61u 0.00s 0.61r
-	gccgo -O2 binary-tree.go	1.11u 0.01s 1.12r # -13%
-	gccgo -O2 binary-tree-freelist.go	0.22u 0.01s 0.23r
-	gc binary-tree	1.83u 0.02s 1.83r # -7%
-	gc binary-tree-freelist	0.32u 0.00s 0.32r
-
-fannkuch 12
-	gcc -m64 -O2 fannkuch.c	45.56u 0.00s 45.67r
-	gccgo -O2 fannkuch.go	57.71u 0.00s 57.85r # -4%
-	gccgo -O2 fannkuch-parallel.go	146.31u 0.00s 37.50r #-37%
-	gc fannkuch	70.06u 0.03s 70.17r # -3%
-	gc fannkuch-parallel	131.88u 0.06s 33.59r # -23%
-	gc_B fannkuch	45.55u 0.02s 45.63r # -15%
-
-regex-dna 100000
-	gcc -m64 -O2 regex-dna.c -lpcre	0.44u 0.01s 0.45r
-	gccgo -O2 regex-dna.go	5.59u 0.00s 5.61r # -14%
-	gccgo -O2 regex-dna-parallel.go	10.85u 0.30s 3.34r # -24%
-	gc regex-dna	2.23u 0.01s 2.25r # -43%
-	gc regex-dna-parallel	2.35u 0.00s 0.93r # -40%
-	gc_B regex-dna	2.24u 0.01s 2.25r # -43%
-
-spectral-norm 5500
-	gcc -m64 -O2 spectral-norm.c -lm	14.84u 0.00s 14.88r
-	gccgo -O2 spectral-norm.go	15.33u 0.00s 15.37r
-	gc spectral-norm	16.75u 0.02s 16.79r # -15%
-	gc_B spectral-norm	16.77u 0.01s 16.79r # -15%
-
-k-nucleotide 1000000
-	gcc -O2 k-nucleotide.c -I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include -lglib-2.0 	4.50u 0.00s 4.52r
-	gccgo -O2 k-nucleotide.go	3.72u 0.04s 3.77r # -21%
-	gccgo -O2 k-nucleotide-parallel.go	3.88u 0.03s 1.42r # -35%
-	gc k-nucleotide	6.32u 0.01s 6.33r # -31%
-	gc k-nucleotide-parallel	6.47u 0.05s 2.13r # -33%
-	gc_B k-nucleotide	6.45u 0.01s 6.47r # - 28%
-
-mandelbrot 16000
-	gcc -m64 -O2 mandelbrot.c	36.03u 0.00s 36.11r
-	gccgo -O2 mandelbrot.go	37.61u 0.00s 37.74r # -14%
-	gc mandelbrot	38.19u 0.05s 38.29r
-	gc_B mandelbrot	38.19u 0.03s 38.26r
-
-meteor 2098
-	gcc -m64 -O2 meteor-contest.c	0.08u 0.00s 0.08r
-	gccgo -O2 meteor-contest.go	0.09u 0.01s 0.10r
-	gc meteor-contest	0.12u 0.00s 0.12r # -15% although perhaps just noise
-	gc_B meteor-contest	0.11u 0.00s 0.12r # -8% although perhaps just noise
-
-pidigits 10000
-	gcc -m64 -O2 pidigits.c -lgmp	2.27u 0.00s 2.28r
-	gccgo -O2 pidigits.go	8.95u 0.02s 8.99r
-	gc pidigits	2.88u 0.14s 2.91r
-	gc_B pidigits	2.92u 0.10s 2.91r
-
-threadring 50000000
-	gcc -m64 -O2 threadring.c -lpthread	14.75u 167.88s 212.23r
-	gccgo -O2 threadring.go	36.72u 12.08s 48.91r # -29%
-	gc threadring	10.93u 0.01s 10.95r # -16%
-
-chameneos 6000000
-	gcc -m64 -O2 chameneosredux.c -lpthread	8.89u 56.62s 9.75r
-	gccgo -O2 chameneosredux.go	9.48u 2.48s 11.99r # -33%
-	gc chameneosredux	5.80u 0.00s 5.81r # -16%
-
diff --git a/test/bench/shootout/timing.sh b/test/bench/shootout/timing.sh
deleted file mode 100755
index 9abcf78d8c..0000000000
--- a/test/bench/shootout/timing.sh
+++ /dev/null
@@ -1,252 +0,0 @@
-#!/usr/bin/env bash
-# Copyright 2009 The Go Authors.  All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-set -e
-
-eval $(go tool dist env)
-GC="go tool compile"
-LD="go tool link"
-
-gccm=""
-case "$O" in
-8)
-	gccm=-m32;;
-6)
-	gccm=-m64;;
-esac
-
-EXE="out"
-havepcre=true
-haveglib=true
-havegmp=true
-case "$(uname)" in
-*MINGW* | *WIN32* | *CYGWIN*)
-	havepcre=false
-	haveglib=false
-	havegmp=false
-	if which pkg-config >/dev/null 2>&1; then
-		if pkg-config --cflags libpcre >/dev/null 2>&1
-		then
-			echo "havepcre"
-			havepcre=true
-		fi
-		if pkg-config --cflags glib-2.0 >/dev/null 2>&1
-		then
-			haveglib=true
-		fi
-		if pkg-config --cflags gmp >/dev/null 2>&1
-		then
-			havegmp=true
-		fi
-	fi
-	EXE=exe;;
-esac
-
-PATH=.:$PATH
-
-havegccgo=false
-if which gccgo >/dev/null 2>&1
-then
-	havegccgo=true
-fi
-
-mode=run
-case X"$1" in
-X-test)
-	mode=test
-	shift
-esac
-
-gc() {
-	$GC $1.go; $LD -o a.$EXE $1.o
-}
-
-gc_B() {
-	$GC -B $1.go; $LD -o a.$EXE $1.o
-}
-
-runonly() {
-	if [ $mode = run ]
-	then
-		"$@"
-	fi
-}
-
-run() {
-	if [ $mode = test ]
-	then
-		if echo $1 | grep -q '^gc '
-		then
-			$1	# compile the program
-			program=$(echo $1 | sed 's/gc //')
-			shift
-			echo $program
-			$1 <fasta-1000.txt > /tmp/$$
-			case $program in
-			chameneosredux)
-				# exact numbers may vary but non-numbers should match
-				grep -v '[0-9]' /tmp/$$ > /tmp/$$x
-				grep -v '[0-9]' chameneosredux.txt > /tmp/$$y
-				cmp /tmp/$$x /tmp/$$y
-				rm -f /tmp/$$ /tmp/$$x /tmp/$$y
-				;;
-			*)
-				cmp /tmp/$$ $program.txt
-				rm -f /tmp/$$
-			esac
-		fi
-		return
-	fi
-	if ! $havegccgo && echo $1 | grep -q '^gccgo '
-	then
-		return
-	fi
-	echo -n '	'$1'	'
-	$1
-	shift
-	
-	echo $((time -p $* >/dev/null) 2>&1) | awk '{print $4 "u " $6 "s " $2 "r"}'
-}
-
-fasta() {
-	runonly echo 'fasta -n 25000000'
-	run "gcc $gccm -O2 fasta.c" a.$EXE 25000000
-	run 'gccgo -O2 fasta.go' a.$EXE -n 25000000	#commented out until WriteString is in bufio
-	run 'gc fasta' a.$EXE -n 25000000
-	run 'gc_B fasta' a.$EXE -n 25000000
-}
-
-revcomp() {
-	runonly gcc -O2 fasta.c
-	runonly a.$EXE 25000000 > x
-	runonly echo 'reverse-complement < output-of-fasta-25000000'
-	run "gcc $gccm -O2 reverse-complement.c" a.$EXE < x
-	run 'gccgo -O2 reverse-complement.go' a.$EXE < x
-	run 'gc reverse-complement' a.$EXE < x
-	run 'gc_B reverse-complement' a.$EXE < x
-	rm x
-}
-
-nbody() {
-	runonly echo 'nbody -n 50000000'
-	run "gcc $gccm -O2 nbody.c -lm" a.$EXE 50000000
-	run 'gccgo -O2 nbody.go' a.$EXE -n 50000000
-	run 'gc nbody' a.$EXE -n 50000000
-	run 'gc_B nbody' a.$EXE -n 50000000
-}
-
-binarytree() {
-	runonly echo 'binary-tree 15 # too slow to use 20'
-	run "gcc $gccm -O2 binary-tree.c -lm" a.$EXE 15
-	run 'gccgo -O2 binary-tree.go' a.$EXE -n 15
-	run 'gccgo -O2 binary-tree-freelist.go' a.$EXE -n 15
-	run 'gc binary-tree' a.$EXE -n 15
-	run 'gc binary-tree-freelist' a.$EXE -n 15
-}
-
-fannkuch() {
-	runonly echo 'fannkuch 12'
-	run "gcc $gccm -O2 fannkuch.c" a.$EXE 12
-	run 'gccgo -O2 fannkuch.go' a.$EXE -n 12
-	run 'gccgo -O2 fannkuch-parallel.go' a.$EXE -n 12
-	run 'gc fannkuch' a.$EXE -n 12
-	run 'gc fannkuch-parallel' a.$EXE -n 12
-	run 'gc_B fannkuch' a.$EXE -n 12
-}
-
-regexdna() {
-	runonly gcc -O2 fasta.c
-	runonly a.$EXE 100000 > x
-	runonly echo 'regex-dna 100000'
-	if  $havepcre; then
-		run "gcc $gccm -O2 regex-dna.c $(pkg-config libpcre --cflags --libs)" a.$EXE <x
-	fi
-	run 'gccgo -O2 regex-dna.go' a.$EXE <x
-	run 'gccgo -O2 regex-dna-parallel.go' a.$EXE <x
-	run 'gc regex-dna' a.$EXE <x
-	run 'gc regex-dna-parallel' a.$EXE <x
-	run 'gc_B regex-dna' a.$EXE <x
-	rm x
-}
-
-spectralnorm() {
-	runonly echo 'spectral-norm 5500'
-	run "gcc $gccm -O2 spectral-norm.c -lm" a.$EXE 5500
-	run 'gccgo -O2 spectral-norm.go' a.$EXE -n 5500
-	run 'gc spectral-norm' a.$EXE -n 5500
-	run 'gc_B spectral-norm' a.$EXE -n 5500
-}
-
-knucleotide() {
-	runonly gcc -O2 fasta.c
-	runonly a.$EXE 1000000 > x  # should be using 25000000
-	runonly echo 'k-nucleotide 1000000'
-	if [ $mode = run ] && $haveglib; then
-		run "gcc -O2 k-nucleotide.c $(pkg-config glib-2.0 --cflags --libs)" a.$EXE <x
-	fi
-	run 'gccgo -O2 k-nucleotide.go' a.$EXE <x
-	run 'gccgo -O2 k-nucleotide-parallel.go' a.$EXE <x
-	run 'gc k-nucleotide' a.$EXE <x
-	run 'gc k-nucleotide-parallel' a.$EXE <x
-	run 'gc_B k-nucleotide' a.$EXE <x
-	rm x
-}
-
-mandelbrot() {
-	runonly echo 'mandelbrot 16000'
-	run "gcc $gccm -O2 mandelbrot.c" a.$EXE 16000
-	run 'gccgo -O2 mandelbrot.go' a.$EXE -n 16000
-	run 'gc mandelbrot' a.$EXE -n 16000
-	run 'gc_B mandelbrot' a.$EXE -n 16000
-}
-
-meteor() {
-	runonly echo 'meteor 2098'
-	run "gcc $gccm -O2 meteor-contest.c" a.$EXE 2098
-	run 'gccgo -O2 meteor-contest.go' a.$EXE -n 2098
-	run 'gc meteor-contest' a.$EXE -n 2098
-	run 'gc_B  meteor-contest' a.$EXE -n 2098
-}
-
-pidigits() {
-	runonly echo 'pidigits 10000'
-	if  $havegmp; then
-		run "gcc $gccm -O2 pidigits.c -lgmp" a.$EXE 10000
-	fi
-	run 'gccgo -O2 pidigits.go' a.$EXE -n 10000
-	run 'gc pidigits' a.$EXE -n 10000
-	run 'gc_B  pidigits' a.$EXE -n 10000
-}
-
-threadring() {
-	runonly echo 'threadring 50000000'
-	run "gcc $gccm -O2 threadring.c -lpthread" a.$EXE 50000000
-	run 'gccgo -O2 threadring.go' a.$EXE -n 50000000
-	run 'gc threadring' a.$EXE -n 50000000
-}
-
-chameneos() {
-	runonly echo 'chameneos 6000000'
-	run "gcc $gccm -O2 chameneosredux.c -lpthread" a.$EXE 6000000
-	run 'gccgo -O2 chameneosredux.go' a.$EXE 6000000
-	run 'gc chameneosredux' a.$EXE 6000000
-}
-
-case $# in
-0)
-	run="fasta revcomp nbody binarytree fannkuch regexdna spectralnorm knucleotide mandelbrot meteor pidigits threadring chameneos"
-	;;
-*)
-	run=$*
-esac
-
-for i in $run
-do
-	$i
-	runonly echo
-done
-
-rm *.o *.$EXE # Clean up
-
