commit 3f4f119b5e5a48c558c2b318b32f036e1062b108
Author: Matthew Dempsky <mdempsky@google.com>
Date:   Tue Mar 28 15:01:18 2017 -0700

    cmd/compile/internal/gc: npos(p, nod(o, l, r)) -> nodl(p, o, l, r)
    
    Prepared with gofmt -r.
    
    Passes toolstash-check.
    
    Change-Id: I8a4f7a8c365dfe464dfc5868a18c67d56af37749
    Reviewed-on: https://go-review.googlesource.com/38739
    Run-TryBot: Matthew Dempsky <mdempsky@google.com>
    Reviewed-by: Josh Bleecher Snyder <josharian@gmail.com>
    TryBot-Result: Gobot Gobot <gobot@golang.org>
---
 src/cmd/compile/internal/gc/bimport.go | 50 +++++++++++++++++-----------------
 1 file changed, 25 insertions(+), 25 deletions(-)

diff --git a/src/cmd/compile/internal/gc/bimport.go b/src/cmd/compile/internal/gc/bimport.go
index fd87ddd857..7b770ff241 100644
--- a/src/cmd/compile/internal/gc/bimport.go
+++ b/src/cmd/compile/internal/gc/bimport.go
@@ -927,7 +927,7 @@ func (p *importer) node() *Node {
 		return n
 
 	case OSTRUCTLIT:
-		n := npos(p.pos(), nod(OCOMPLIT, nil, typenod(p.typ())))
+		n := nodl(p.pos(), OCOMPLIT, nil, typenod(p.typ()))
 		n.List.Set(p.elemList()) // special handling of field names
 		return n
 
@@ -935,14 +935,14 @@ func (p *importer) node() *Node {
 	// 	unreachable - mapped to case OCOMPLIT below by exporter
 
 	case OCOMPLIT:
-		n := npos(p.pos(), nod(OCOMPLIT, nil, typenod(p.typ())))
+		n := nodl(p.pos(), OCOMPLIT, nil, typenod(p.typ()))
 		n.List.Set(p.exprList())
 		return n
 
 	case OKEY:
 		pos := p.pos()
 		left, right := p.exprsOrNil()
-		return npos(pos, nod(OKEY, left, right))
+		return nodl(pos, OKEY, left, right)
 
 	// case OSTRUCTKEY:
 	//	unreachable - handled in case OSTRUCTLIT by elemList
@@ -961,7 +961,7 @@ func (p *importer) node() *Node {
 	// 	unreachable - mapped to case ODOTTYPE below by exporter
 
 	case ODOTTYPE:
-		n := npos(p.pos(), nod(ODOTTYPE, p.expr(), nil))
+		n := nodl(p.pos(), ODOTTYPE, p.expr(), nil)
 		if p.bool() {
 			n.Right = p.expr()
 		} else {
@@ -973,10 +973,10 @@ func (p *importer) node() *Node {
 	// 	unreachable - mapped to cases below by exporter
 
 	case OINDEX:
-		return npos(p.pos(), nod(op, p.expr(), p.expr()))
+		return nodl(p.pos(), op, p.expr(), p.expr())
 
 	case OSLICE, OSLICE3:
-		n := npos(p.pos(), nod(op, p.expr(), nil))
+		n := nodl(p.pos(), op, p.expr(), nil)
 		low, high := p.exprsOrNil()
 		var max *Node
 		if n.Op.IsSlice3() {
@@ -989,7 +989,7 @@ func (p *importer) node() *Node {
 	// 	unreachable - mapped to OCONV case below by exporter
 
 	case OCONV:
-		n := npos(p.pos(), nod(OCALL, typenod(p.typ()), nil))
+		n := nodl(p.pos(), OCALL, typenod(p.typ()), nil)
 		n.List.Set(p.exprList())
 		return n
 
@@ -1005,7 +1005,7 @@ func (p *importer) node() *Node {
 	// 	unreachable - mapped to OCALL case below by exporter
 
 	case OCALL:
-		n := npos(p.pos(), nod(OCALL, p.expr(), nil))
+		n := nodl(p.pos(), OCALL, p.expr(), nil)
 		n.List.Set(p.exprList())
 		n.SetIsddd(p.bool())
 		return n
@@ -1018,19 +1018,19 @@ func (p *importer) node() *Node {
 
 	// unary expressions
 	case OPLUS, OMINUS, OADDR, OCOM, OIND, ONOT, ORECV:
-		return npos(p.pos(), nod(op, p.expr(), nil))
+		return nodl(p.pos(), op, p.expr(), nil)
 
 	// binary expressions
 	case OADD, OAND, OANDAND, OANDNOT, ODIV, OEQ, OGE, OGT, OLE, OLT,
 		OLSH, OMOD, OMUL, ONE, OOR, OOROR, ORSH, OSEND, OSUB, OXOR:
-		return npos(p.pos(), nod(op, p.expr(), p.expr()))
+		return nodl(p.pos(), op, p.expr(), p.expr())
 
 	case OADDSTR:
 		pos := p.pos()
 		list := p.exprList()
 		x := npos(pos, list[0])
 		for _, y := range list[1:] {
-			x = npos(pos, nod(OADD, x, y))
+			x = nodl(pos, OADD, x, y)
 		}
 		return x
 
@@ -1039,7 +1039,7 @@ func (p *importer) node() *Node {
 
 	case ODCLCONST:
 		// TODO(gri) these should not be exported in the first place
-		return npos(p.pos(), nod(OEMPTY, nil, nil))
+		return nodl(p.pos(), OEMPTY, nil, nil)
 
 	// --------------------------------------------------------------------
 	// statements
@@ -1061,10 +1061,10 @@ func (p *importer) node() *Node {
 	// 	unreachable - mapped to OAS case below by exporter
 
 	case OAS:
-		return npos(p.pos(), nod(OAS, p.expr(), p.expr()))
+		return nodl(p.pos(), OAS, p.expr(), p.expr())
 
 	case OASOP:
-		n := npos(p.pos(), nod(OASOP, nil, nil))
+		n := nodl(p.pos(), OASOP, nil, nil)
 		n.Etype = EType(p.int())
 		n.Left = p.expr()
 		if !p.bool() {
@@ -1079,13 +1079,13 @@ func (p *importer) node() *Node {
 	// 	unreachable - mapped to OAS2 case below by exporter
 
 	case OAS2:
-		n := npos(p.pos(), nod(OAS2, nil, nil))
+		n := nodl(p.pos(), OAS2, nil, nil)
 		n.List.Set(p.exprList())
 		n.Rlist.Set(p.exprList())
 		return n
 
 	case ORETURN:
-		n := npos(p.pos(), nod(ORETURN, nil, nil))
+		n := nodl(p.pos(), ORETURN, nil, nil)
 		n.List.Set(p.exprList())
 		return n
 
@@ -1093,11 +1093,11 @@ func (p *importer) node() *Node {
 	// 	unreachable - generated by compiler for trampolin routines (not exported)
 
 	case OPROC, ODEFER:
-		return npos(p.pos(), nod(op, p.expr(), nil))
+		return nodl(p.pos(), op, p.expr(), nil)
 
 	case OIF:
 		markdcl()
-		n := npos(p.pos(), nod(OIF, nil, nil))
+		n := nodl(p.pos(), OIF, nil, nil)
 		n.Ninit.Set(p.stmtList())
 		n.Left = p.expr()
 		n.Nbody.Set(p.stmtList())
@@ -1107,7 +1107,7 @@ func (p *importer) node() *Node {
 
 	case OFOR:
 		markdcl()
-		n := npos(p.pos(), nod(OFOR, nil, nil))
+		n := nodl(p.pos(), OFOR, nil, nil)
 		n.Ninit.Set(p.stmtList())
 		n.Left, n.Right = p.exprsOrNil()
 		n.Nbody.Set(p.stmtList())
@@ -1116,7 +1116,7 @@ func (p *importer) node() *Node {
 
 	case ORANGE:
 		markdcl()
-		n := npos(p.pos(), nod(ORANGE, nil, nil))
+		n := nodl(p.pos(), ORANGE, nil, nil)
 		n.List.Set(p.stmtList())
 		n.Right = p.expr()
 		n.Nbody.Set(p.stmtList())
@@ -1125,7 +1125,7 @@ func (p *importer) node() *Node {
 
 	case OSELECT, OSWITCH:
 		markdcl()
-		n := npos(p.pos(), nod(op, nil, nil))
+		n := nodl(p.pos(), op, nil, nil)
 		n.Ninit.Set(p.stmtList())
 		n.Left, _ = p.exprsOrNil()
 		n.List.Set(p.stmtList())
@@ -1137,7 +1137,7 @@ func (p *importer) node() *Node {
 
 	case OXCASE:
 		markdcl()
-		n := npos(p.pos(), nod(OXCASE, nil, nil))
+		n := nodl(p.pos(), OXCASE, nil, nil)
 		n.Xoffset = int64(block)
 		n.List.Set(p.exprList())
 		// TODO(gri) eventually we must declare variables for type switch
@@ -1150,7 +1150,7 @@ func (p *importer) node() *Node {
 	// 	unreachable - mapped to OXFALL case below by exporter
 
 	case OXFALL:
-		n := npos(p.pos(), nod(OXFALL, nil, nil))
+		n := nodl(p.pos(), OXFALL, nil, nil)
 		n.Xoffset = int64(block)
 		return n
 
@@ -1160,13 +1160,13 @@ func (p *importer) node() *Node {
 		if left != nil {
 			left = newname(left.Sym)
 		}
-		return npos(pos, nod(op, left, nil))
+		return nodl(pos, op, left, nil)
 
 	// case OEMPTY:
 	// 	unreachable - not emitted by exporter
 
 	case OGOTO, OLABEL:
-		n := npos(p.pos(), nod(op, newname(p.expr().Sym), nil))
+		n := nodl(p.pos(), op, newname(p.expr().Sym), nil)
 		n.Sym = dclstack // context, for goto restrictions
 		return n
 
