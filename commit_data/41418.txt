commit 9c2e7e8bed3368fd2b3903b47d686b5a900ebe04
Author: Michael Munday <mike.munday@ibm.com>
Date:   Mon Aug 12 20:19:58 2019 +0100

    cmd/compile: allow multiple SSA block control values
    
    Control values are used to choose which successor of a block is
    jumped to. Typically a control value takes the form of a 'flags'
    value that represents the result of a comparison. Some
    architectures however use a variable in a register as a control
    value.
    
    Up until now we have managed with a single control value per block.
    However some architectures (e.g. s390x and riscv64) have combined
    compare-and-branch instructions that take two variables in registers
    as parameters. To generate these instructions we need to support 2
    control values per block.
    
    This CL allows up to 2 control values to be used in a block in
    order to support the addition of compare-and-branch instructions.
    I have implemented s390x compare-and-branch instructions in a
    different CL.
    
    Passes toolstash-check -all.
    
    Results of compilebench:
    
    name                      old time/op       new time/op       delta
    Template                        208ms ± 1%        209ms ± 1%    ~     (p=0.289 n=20+20)
    Unicode                        83.7ms ± 1%       83.3ms ± 3%  -0.49%  (p=0.017 n=18+18)
    GoTypes                         748ms ± 1%        748ms ± 0%    ~     (p=0.460 n=20+18)
    Compiler                        3.47s ± 1%        3.48s ± 1%    ~     (p=0.070 n=19+18)
    SSA                             11.5s ± 1%        11.7s ± 1%  +1.64%  (p=0.000 n=19+18)
    Flate                           130ms ± 1%        130ms ± 1%    ~     (p=0.588 n=19+20)
    GoParser                        160ms ± 1%        161ms ± 1%    ~     (p=0.211 n=20+20)
    Reflect                         465ms ± 1%        467ms ± 1%  +0.42%  (p=0.007 n=20+20)
    Tar                             184ms ± 1%        185ms ± 2%    ~     (p=0.087 n=18+20)
    XML                             253ms ± 1%        253ms ± 1%    ~     (p=0.377 n=20+18)
    LinkCompiler                    769ms ± 2%        774ms ± 2%    ~     (p=0.070 n=19+19)
    ExternalLinkCompiler            3.59s ±11%        3.68s ± 6%    ~     (p=0.072 n=20+20)
    LinkWithoutDebugCompiler        446ms ± 5%        454ms ± 3%  +1.79%  (p=0.002 n=19+20)
    StdCmd                          26.0s ± 2%        26.0s ± 2%    ~     (p=0.799 n=20+20)
    
    name                      old user-time/op  new user-time/op  delta
    Template                        238ms ± 5%        240ms ± 5%    ~     (p=0.142 n=20+20)
    Unicode                         105ms ±11%        106ms ±10%    ~     (p=0.512 n=20+20)
    GoTypes                         876ms ± 2%        873ms ± 4%    ~     (p=0.647 n=20+19)
    Compiler                        4.17s ± 2%        4.19s ± 1%    ~     (p=0.093 n=20+18)
    SSA                             13.9s ± 1%        14.1s ± 1%  +1.45%  (p=0.000 n=18+18)
    Flate                           145ms ±13%        146ms ± 5%    ~     (p=0.851 n=20+18)
    GoParser                        185ms ± 5%        188ms ± 7%    ~     (p=0.174 n=20+20)
    Reflect                         534ms ± 3%        538ms ± 2%    ~     (p=0.105 n=20+18)
    Tar                             215ms ± 4%        211ms ± 9%    ~     (p=0.079 n=19+20)
    XML                             295ms ± 6%        295ms ± 5%    ~     (p=0.968 n=20+20)
    LinkCompiler                    832ms ± 4%        837ms ± 7%    ~     (p=0.707 n=17+20)
    ExternalLinkCompiler            1.58s ± 8%        1.60s ± 4%    ~     (p=0.296 n=20+19)
    LinkWithoutDebugCompiler        478ms ±12%        489ms ±10%    ~     (p=0.429 n=20+20)
    
    name                      old object-bytes  new object-bytes  delta
    Template                        559kB ± 0%        559kB ± 0%    ~     (all equal)
    Unicode                         216kB ± 0%        216kB ± 0%    ~     (all equal)
    GoTypes                        2.03MB ± 0%       2.03MB ± 0%    ~     (all equal)
    Compiler                       8.07MB ± 0%       8.07MB ± 0%  -0.06%  (p=0.000 n=20+20)
    SSA                            27.1MB ± 0%       27.3MB ± 0%  +0.89%  (p=0.000 n=20+20)
    Flate                           343kB ± 0%        343kB ± 0%    ~     (all equal)
    GoParser                        441kB ± 0%        441kB ± 0%    ~     (all equal)
    Reflect                        1.36MB ± 0%       1.36MB ± 0%    ~     (all equal)
    Tar                             487kB ± 0%        487kB ± 0%    ~     (all equal)
    XML                             632kB ± 0%        632kB ± 0%    ~     (all equal)
    
    name                      old export-bytes  new export-bytes  delta
    Template                       18.5kB ± 0%       18.5kB ± 0%    ~     (all equal)
    Unicode                        7.92kB ± 0%       7.92kB ± 0%    ~     (all equal)
    GoTypes                        35.0kB ± 0%       35.0kB ± 0%    ~     (all equal)
    Compiler                        109kB ± 0%        110kB ± 0%  +0.72%  (p=0.000 n=20+20)
    SSA                             137kB ± 0%        138kB ± 0%  +0.58%  (p=0.000 n=20+20)
    Flate                          4.89kB ± 0%       4.89kB ± 0%    ~     (all equal)
    GoParser                       8.49kB ± 0%       8.49kB ± 0%    ~     (all equal)
    Reflect                        11.4kB ± 0%       11.4kB ± 0%    ~     (all equal)
    Tar                            10.5kB ± 0%       10.5kB ± 0%    ~     (all equal)
    XML                            16.7kB ± 0%       16.7kB ± 0%    ~     (all equal)
    
    name                      old text-bytes    new text-bytes    delta
    HelloSize                       761kB ± 0%        761kB ± 0%    ~     (all equal)
    CmdGoSize                      10.8MB ± 0%       10.8MB ± 0%    ~     (all equal)
    
    name                      old data-bytes    new data-bytes    delta
    HelloSize                      10.7kB ± 0%       10.7kB ± 0%    ~     (all equal)
    CmdGoSize                       312kB ± 0%        312kB ± 0%    ~     (all equal)
    
    name                      old bss-bytes     new bss-bytes     delta
    HelloSize                       122kB ± 0%        122kB ± 0%    ~     (all equal)
    CmdGoSize                       146kB ± 0%        146kB ± 0%    ~     (all equal)
    
    name                      old exe-bytes     new exe-bytes     delta
    HelloSize                      1.13MB ± 0%       1.13MB ± 0%    ~     (all equal)
    CmdGoSize                      15.1MB ± 0%       15.1MB ± 0%    ~     (all equal)
    
    Change-Id: I3cc2f9829a109543d9a68be4a21775d2d3e9801f
    Reviewed-on: https://go-review.googlesource.com/c/go/+/196557
    Run-TryBot: Michael Munday <mike.munday@ibm.com>
    TryBot-Result: Gobot Gobot <gobot@golang.org>
    Reviewed-by: Daniel Martí <mvdan@mvdan.cc>
    Reviewed-by: Keith Randall <khr@golang.org>
---
 src/cmd/compile/internal/amd64/ssa.go          |    6 +-
 src/cmd/compile/internal/arm/ssa.go            |    2 +-
 src/cmd/compile/internal/arm64/ssa.go          |    8 +-
 src/cmd/compile/internal/gc/plive.go           |    2 +-
 src/cmd/compile/internal/mips/ssa.go           |    6 +-
 src/cmd/compile/internal/mips64/ssa.go         |    6 +-
 src/cmd/compile/internal/ppc64/ssa.go          |    2 +-
 src/cmd/compile/internal/s390x/ssa.go          |    6 +-
 src/cmd/compile/internal/ssa/README.md         |    8 +-
 src/cmd/compile/internal/ssa/block.go          |  104 +-
 src/cmd/compile/internal/ssa/branchelim.go     |   10 +-
 src/cmd/compile/internal/ssa/check.go          |   52 +-
 src/cmd/compile/internal/ssa/copyelim.go       |    6 +-
 src/cmd/compile/internal/ssa/cse.go            |    4 +-
 src/cmd/compile/internal/ssa/deadcode.go       |   14 +-
 src/cmd/compile/internal/ssa/deadstore.go      |   11 +-
 src/cmd/compile/internal/ssa/flagalloc.go      |   42 +-
 src/cmd/compile/internal/ssa/fuse.go           |    2 +-
 src/cmd/compile/internal/ssa/gen/386.rules     |  118 +-
 src/cmd/compile/internal/ssa/gen/386Ops.go     |   32 +-
 src/cmd/compile/internal/ssa/gen/AMD64.rules   |   20 +-
 src/cmd/compile/internal/ssa/gen/AMD64Ops.go   |   32 +-
 src/cmd/compile/internal/ssa/gen/ARM.rules     |  118 +-
 src/cmd/compile/internal/ssa/gen/ARM64.rules   |  136 +-
 src/cmd/compile/internal/ssa/gen/ARM64Ops.go   |   40 +-
 src/cmd/compile/internal/ssa/gen/ARMOps.go     |   20 +-
 src/cmd/compile/internal/ssa/gen/MIPS.rules    |   24 +-
 src/cmd/compile/internal/ssa/gen/MIPS64.rules  |   24 +-
 src/cmd/compile/internal/ssa/gen/MIPS64Ops.go  |   16 +-
 src/cmd/compile/internal/ssa/gen/MIPSOps.go    |   16 +-
 src/cmd/compile/internal/ssa/gen/PPC64.rules   |   36 +-
 src/cmd/compile/internal/ssa/gen/PPC64Ops.go   |   20 +-
 src/cmd/compile/internal/ssa/gen/S390X.rules   |   18 +-
 src/cmd/compile/internal/ssa/gen/S390XOps.go   |    2 +-
 src/cmd/compile/internal/ssa/gen/generic.rules |    4 +-
 src/cmd/compile/internal/ssa/gen/genericOps.go |   28 +-
 src/cmd/compile/internal/ssa/gen/main.go       |    3 +-
 src/cmd/compile/internal/ssa/gen/rulegen.go    |   95 +-
 src/cmd/compile/internal/ssa/html.go           |    4 +-
 src/cmd/compile/internal/ssa/loopbce.go        |    9 +-
 src/cmd/compile/internal/ssa/nilcheck.go       |    5 +-
 src/cmd/compile/internal/ssa/nilcheck_test.go  |    2 +-
 src/cmd/compile/internal/ssa/phiopt.go         |    8 +-
 src/cmd/compile/internal/ssa/prove.go          |   21 +-
 src/cmd/compile/internal/ssa/regalloc.go       |   47 +-
 src/cmd/compile/internal/ssa/rewrite.go        |    7 +-
 src/cmd/compile/internal/ssa/rewrite386.go     | 1048 ++++----
 src/cmd/compile/internal/ssa/rewriteAMD64.go   | 1644 +++++++------
 src/cmd/compile/internal/ssa/rewriteARM.go     | 3080 ++++++++++++++----------
 src/cmd/compile/internal/ssa/rewriteARM64.go   | 1954 ++++++++-------
 src/cmd/compile/internal/ssa/rewriteMIPS.go    |  338 +--
 src/cmd/compile/internal/ssa/rewriteMIPS64.go  |  322 +--
 src/cmd/compile/internal/ssa/rewritePPC64.go   |  888 ++++---
 src/cmd/compile/internal/ssa/rewriteS390X.go   |  118 +-
 src/cmd/compile/internal/ssa/rewritegeneric.go |   27 +-
 src/cmd/compile/internal/ssa/schedule.go       |   18 +-
 src/cmd/compile/internal/ssa/shortcircuit.go   |    4 +-
 src/cmd/compile/internal/ssa/sizeof_test.go    |    2 +-
 src/cmd/compile/internal/ssa/tighten.go        |    2 +-
 src/cmd/compile/internal/ssa/value.go          |    2 +-
 src/cmd/compile/internal/ssa/writebarrier.go   |    2 +-
 src/cmd/compile/internal/wasm/ssa.go           |    6 +-
 src/cmd/compile/internal/x86/ssa.go            |    6 +-
 63 files changed, 6052 insertions(+), 4605 deletions(-)

diff --git a/src/cmd/compile/internal/amd64/ssa.go b/src/cmd/compile/internal/amd64/ssa.go
index 9c91e05661..b52b996407 100644
--- a/src/cmd/compile/internal/amd64/ssa.go
+++ b/src/cmd/compile/internal/amd64/ssa.go
@@ -18,8 +18,8 @@ import (
 // markMoves marks any MOVXconst ops that need to avoid clobbering flags.
 func ssaMarkMoves(s *gc.SSAGenState, b *ssa.Block) {
 	flive := b.FlagsLiveAtEnd
-	if b.Control != nil && b.Control.Type.IsFlags() {
-		flive = true
+	for _, c := range b.ControlValues() {
+		flive = c.Type.IsFlags() || flive
 	}
 	for i := len(b.Values) - 1; i >= 0; i-- {
 		v := b.Values[i]
@@ -1245,6 +1245,6 @@ func ssaGenBlock(s *gc.SSAGenState, b, next *ssa.Block) {
 		}
 
 	default:
-		b.Fatalf("branch not implemented: %s. Control: %s", b.LongString(), b.Control.LongString())
+		b.Fatalf("branch not implemented: %s", b.LongString())
 	}
 }
diff --git a/src/cmd/compile/internal/arm/ssa.go b/src/cmd/compile/internal/arm/ssa.go
index ab0f417117..2c77912f21 100644
--- a/src/cmd/compile/internal/arm/ssa.go
+++ b/src/cmd/compile/internal/arm/ssa.go
@@ -955,6 +955,6 @@ func ssaGenBlock(s *gc.SSAGenState, b, next *ssa.Block) {
 		}
 
 	default:
-		b.Fatalf("branch not implemented: %s. Control: %s", b.LongString(), b.Control.LongString())
+		b.Fatalf("branch not implemented: %s", b.LongString())
 	}
 }
diff --git a/src/cmd/compile/internal/arm64/ssa.go b/src/cmd/compile/internal/arm64/ssa.go
index f13bd71f7a..252e875669 100644
--- a/src/cmd/compile/internal/arm64/ssa.go
+++ b/src/cmd/compile/internal/arm64/ssa.go
@@ -1057,9 +1057,9 @@ func ssaGenBlock(s *gc.SSAGenState, b, next *ssa.Block) {
 				s.Br(obj.AJMP, b.Succs[0].Block())
 			}
 		}
-		if !b.Control.Type.IsFlags() {
+		if !b.Controls[0].Type.IsFlags() {
 			p.From.Type = obj.TYPE_REG
-			p.From.Reg = b.Control.Reg()
+			p.From.Reg = b.Controls[0].Reg()
 		}
 	case ssa.BlockARM64TBZ, ssa.BlockARM64TBNZ:
 		jmp := blockJump[b.Kind]
@@ -1080,9 +1080,9 @@ func ssaGenBlock(s *gc.SSAGenState, b, next *ssa.Block) {
 		}
 		p.From.Offset = b.Aux.(int64)
 		p.From.Type = obj.TYPE_CONST
-		p.Reg = b.Control.Reg()
+		p.Reg = b.Controls[0].Reg()
 
 	default:
-		b.Fatalf("branch not implemented: %s. Control: %s", b.LongString(), b.Control.LongString())
+		b.Fatalf("branch not implemented: %s", b.LongString())
 	}
 }
diff --git a/src/cmd/compile/internal/gc/plive.go b/src/cmd/compile/internal/gc/plive.go
index 16a752c893..8809a644d5 100644
--- a/src/cmd/compile/internal/gc/plive.go
+++ b/src/cmd/compile/internal/gc/plive.go
@@ -670,7 +670,7 @@ func (lv *Liveness) markUnsafePoints() {
 		// single op that does the memory load from the flag
 		// address, so we look for that.
 		var load *ssa.Value
-		v := wbBlock.Control
+		v := wbBlock.Controls[0]
 		for {
 			if sym, ok := v.Aux.(*obj.LSym); ok && sym == writeBarrier {
 				load = v
diff --git a/src/cmd/compile/internal/mips/ssa.go b/src/cmd/compile/internal/mips/ssa.go
index 19b7c95bfd..bac8574b5c 100644
--- a/src/cmd/compile/internal/mips/ssa.go
+++ b/src/cmd/compile/internal/mips/ssa.go
@@ -855,11 +855,11 @@ func ssaGenBlock(s *gc.SSAGenState, b, next *ssa.Block) {
 				s.Br(obj.AJMP, b.Succs[0].Block())
 			}
 		}
-		if !b.Control.Type.IsFlags() {
+		if !b.Controls[0].Type.IsFlags() {
 			p.From.Type = obj.TYPE_REG
-			p.From.Reg = b.Control.Reg()
+			p.From.Reg = b.Controls[0].Reg()
 		}
 	default:
-		b.Fatalf("branch not implemented: %s. Control: %s", b.LongString(), b.Control.LongString())
+		b.Fatalf("branch not implemented: %s", b.LongString())
 	}
 }
diff --git a/src/cmd/compile/internal/mips64/ssa.go b/src/cmd/compile/internal/mips64/ssa.go
index 7eae35373d..a70db3576c 100644
--- a/src/cmd/compile/internal/mips64/ssa.go
+++ b/src/cmd/compile/internal/mips64/ssa.go
@@ -829,11 +829,11 @@ func ssaGenBlock(s *gc.SSAGenState, b, next *ssa.Block) {
 				s.Br(obj.AJMP, b.Succs[0].Block())
 			}
 		}
-		if !b.Control.Type.IsFlags() {
+		if !b.Controls[0].Type.IsFlags() {
 			p.From.Type = obj.TYPE_REG
-			p.From.Reg = b.Control.Reg()
+			p.From.Reg = b.Controls[0].Reg()
 		}
 	default:
-		b.Fatalf("branch not implemented: %s. Control: %s", b.LongString(), b.Control.LongString())
+		b.Fatalf("branch not implemented: %s", b.LongString())
 	}
 }
diff --git a/src/cmd/compile/internal/ppc64/ssa.go b/src/cmd/compile/internal/ppc64/ssa.go
index a12b256680..69847c38d2 100644
--- a/src/cmd/compile/internal/ppc64/ssa.go
+++ b/src/cmd/compile/internal/ppc64/ssa.go
@@ -1337,6 +1337,6 @@ func ssaGenBlock(s *gc.SSAGenState, b, next *ssa.Block) {
 			}
 		}
 	default:
-		b.Fatalf("branch not implemented: %s. Control: %s", b.LongString(), b.Control.LongString())
+		b.Fatalf("branch not implemented: %s", b.LongString())
 	}
 }
diff --git a/src/cmd/compile/internal/s390x/ssa.go b/src/cmd/compile/internal/s390x/ssa.go
index 74e63b9f42..52ba270116 100644
--- a/src/cmd/compile/internal/s390x/ssa.go
+++ b/src/cmd/compile/internal/s390x/ssa.go
@@ -17,8 +17,8 @@ import (
 // markMoves marks any MOVXconst ops that need to avoid clobbering flags.
 func ssaMarkMoves(s *gc.SSAGenState, b *ssa.Block) {
 	flive := b.FlagsLiveAtEnd
-	if b.Control != nil && b.Control.Type.IsFlags() {
-		flive = true
+	for _, c := range b.ControlValues() {
+		flive = c.Type.IsFlags() || flive
 	}
 	for i := len(b.Values) - 1; i >= 0; i-- {
 		v := b.Values[i]
@@ -864,6 +864,6 @@ func ssaGenBlock(s *gc.SSAGenState, b, next *ssa.Block) {
 			s.Br(s390x.ABR, succs[1])
 		}
 	default:
-		b.Fatalf("branch not implemented: %s. Control: %s", b.LongString(), b.Control.LongString())
+		b.Fatalf("branch not implemented: %s", b.LongString())
 	}
 }
diff --git a/src/cmd/compile/internal/ssa/README.md b/src/cmd/compile/internal/ssa/README.md
index d283118011..4483c2c85f 100644
--- a/src/cmd/compile/internal/ssa/README.md
+++ b/src/cmd/compile/internal/ssa/README.md
@@ -82,10 +82,10 @@ control value, which must return a memory state. This is necessary for functions
 to return some values, for example - the caller needs some memory state to
 depend on, to ensure that it receives those return values correctly.
 
-The last important block kind we will mention is the `if` block. Its control
-value must be a boolean value, and it has exactly two successor blocks. The
-control flow is handed to the first successor if the bool is true, and to the
-second otherwise.
+The last important block kind we will mention is the `if` block. It has a single
+control value that must be a boolean value, and it has exactly two successor
+blocks. The control flow is handed to the first successor if the bool is true,
+and to the second otherwise.
 
 Here is a sample if-else control flow represented with basic blocks:
 
diff --git a/src/cmd/compile/internal/ssa/block.go b/src/cmd/compile/internal/ssa/block.go
index 273e5f15d7..1ccea778c2 100644
--- a/src/cmd/compile/internal/ssa/block.go
+++ b/src/cmd/compile/internal/ssa/block.go
@@ -40,23 +40,28 @@ type Block struct {
 	// arguments by block id and have this field computed explicitly when needed?
 	Preds []Edge
 
-	// A value that determines how the block is exited. Its value depends on the kind
-	// of the block. For instance, a BlockIf has a boolean control value and BlockExit
-	// has a memory control value.
-	Control *Value
+	// A list of values that determine how the block is exited. The number
+	// and type of control values depends on the Kind of the block. For
+	// instance, a BlockIf has a single boolean control value and BlockExit
+	// has a single memory control value.
+	//
+	// The ControlValues() method may be used to get a slice with the non-nil
+	// control values that can be ranged over.
+	//
+	// Controls[1] must be nil if Controls[0] is nil.
+	Controls [2]*Value
 
 	// Auxiliary info for the block. Its value depends on the Kind.
 	Aux interface{}
 
 	// The unordered set of Values that define the operation of this block.
-	// The list must include the control value, if any. (TODO: need this last condition?)
 	// After the scheduling pass, this list is ordered.
 	Values []*Value
 
 	// The containing function
 	Func *Func
 
-	// Storage for Succs, Preds, and Values
+	// Storage for Succs, Preds and Values.
 	succstorage [2]Edge
 	predstorage [4]Edge
 	valstorage  [9]*Value
@@ -96,12 +101,12 @@ func (e Edge) Index() int {
 	return e.i
 }
 
-//     kind           control    successors
+//     kind          controls        successors
 //   ------------------------------------------
-//     Exit        return mem                []
-//    Plain               nil            [next]
-//       If   a boolean Value      [then, else]
-//    Defer               mem  [nopanic, panic]  (control opcode should be OpStaticCall to runtime.deferproc)
+//     Exit      [return mem]                []
+//    Plain                []            [next]
+//       If   [boolean Value]      [then, else]
+//    Defer             [mem]  [nopanic, panic]  (control opcode should be OpStaticCall to runtime.deferproc)
 type BlockKind int8
 
 // short form print
@@ -115,8 +120,8 @@ func (b *Block) LongString() string {
 	if b.Aux != nil {
 		s += fmt.Sprintf(" %s", b.Aux)
 	}
-	if b.Control != nil {
-		s += fmt.Sprintf(" %s", b.Control)
+	for _, c := range b.ControlValues() {
+		s += fmt.Sprintf(" %s", c)
 	}
 	if len(b.Succs) > 0 {
 		s += " ->"
@@ -133,13 +138,76 @@ func (b *Block) LongString() string {
 	return s
 }
 
+// NumControls returns the number of non-nil control values the
+// block has.
+func (b *Block) NumControls() int {
+	if b.Controls[0] == nil {
+		return 0
+	}
+	if b.Controls[1] == nil {
+		return 1
+	}
+	return 2
+}
+
+// ControlValues returns a slice containing the non-nil control
+// values of the block. The index of each control value will be
+// the same as it is in the Controls property and can be used
+// in ReplaceControl calls.
+func (b *Block) ControlValues() []*Value {
+	if b.Controls[0] == nil {
+		return b.Controls[:0]
+	}
+	if b.Controls[1] == nil {
+		return b.Controls[:1]
+	}
+	return b.Controls[:2]
+}
+
+// SetControl removes all existing control values and then adds
+// the control value provided. The number of control values after
+// a call to SetControl will always be 1.
 func (b *Block) SetControl(v *Value) {
-	if w := b.Control; w != nil {
-		w.Uses--
+	b.ResetControls()
+	b.Controls[0] = v
+	v.Uses++
+}
+
+// ResetControls sets the number of controls for the block to 0.
+func (b *Block) ResetControls() {
+	if b.Controls[0] != nil {
+		b.Controls[0].Uses--
+	}
+	if b.Controls[1] != nil {
+		b.Controls[1].Uses--
+	}
+	b.Controls = [2]*Value{} // reset both controls to nil
+}
+
+// AddControl appends a control value to the existing list of control values.
+func (b *Block) AddControl(v *Value) {
+	i := b.NumControls()
+	b.Controls[i] = v // panics if array is full
+	v.Uses++
+}
+
+// ReplaceControl exchanges the existing control value at the index provided
+// for the new value. The index must refer to a valid control value.
+func (b *Block) ReplaceControl(i int, v *Value) {
+	b.Controls[i].Uses--
+	b.Controls[i] = v
+	v.Uses++
+}
+
+// CopyControls replaces the controls for this block with those from the
+// provided block. The provided block is not modified.
+func (b *Block) CopyControls(from *Block) {
+	if b == from {
+		return
 	}
-	b.Control = v
-	if v != nil {
-		v.Uses++
+	b.ResetControls()
+	for _, c := range from.ControlValues() {
+		b.AddControl(c)
 	}
 }
 
diff --git a/src/cmd/compile/internal/ssa/branchelim.go b/src/cmd/compile/internal/ssa/branchelim.go
index fda0cbb9b3..c79b913d72 100644
--- a/src/cmd/compile/internal/ssa/branchelim.go
+++ b/src/cmd/compile/internal/ssa/branchelim.go
@@ -160,13 +160,13 @@ func elimIf(f *Func, loadAddr *sparseSet, dom *Block) bool {
 		if swap {
 			v.Args[0], v.Args[1] = v.Args[1], v.Args[0]
 		}
-		v.AddArg(dom.Control)
+		v.AddArg(dom.Controls[0])
 	}
 
 	// Put all of the instructions into 'dom'
 	// and update the CFG appropriately.
 	dom.Kind = post.Kind
-	dom.SetControl(post.Control)
+	dom.CopyControls(post)
 	dom.Aux = post.Aux
 	dom.Succs = append(dom.Succs[:0], post.Succs...)
 	for i := range dom.Succs {
@@ -201,7 +201,7 @@ func clobberBlock(b *Block) {
 	b.Preds = nil
 	b.Succs = nil
 	b.Aux = nil
-	b.SetControl(nil)
+	b.ResetControls()
 	b.Likely = BranchUnknown
 	b.Kind = BlockInvalid
 }
@@ -259,13 +259,13 @@ func elimIfElse(f *Func, loadAddr *sparseSet, b *Block) bool {
 		if swap {
 			v.Args[0], v.Args[1] = v.Args[1], v.Args[0]
 		}
-		v.AddArg(b.Control)
+		v.AddArg(b.Controls[0])
 	}
 
 	// Move the contents of all of these
 	// blocks into 'b' and update CFG edges accordingly
 	b.Kind = post.Kind
-	b.SetControl(post.Control)
+	b.CopyControls(post)
 	b.Aux = post.Aux
 	b.Succs = append(b.Succs[:0], post.Succs...)
 	for i := range b.Succs {
diff --git a/src/cmd/compile/internal/ssa/check.go b/src/cmd/compile/internal/ssa/check.go
index 6dbe2ac0b6..e97377bf5c 100644
--- a/src/cmd/compile/internal/ssa/check.go
+++ b/src/cmd/compile/internal/ssa/check.go
@@ -39,31 +39,31 @@ func checkFunc(f *Func) {
 			if len(b.Succs) != 0 {
 				f.Fatalf("exit block %s has successors", b)
 			}
-			if b.Control == nil {
+			if b.NumControls() != 1 {
 				f.Fatalf("exit block %s has no control value", b)
 			}
-			if !b.Control.Type.IsMemory() {
-				f.Fatalf("exit block %s has non-memory control value %s", b, b.Control.LongString())
+			if !b.Controls[0].Type.IsMemory() {
+				f.Fatalf("exit block %s has non-memory control value %s", b, b.Controls[0].LongString())
 			}
 		case BlockRet:
 			if len(b.Succs) != 0 {
 				f.Fatalf("ret block %s has successors", b)
 			}
-			if b.Control == nil {
+			if b.NumControls() != 1 {
 				f.Fatalf("ret block %s has nil control", b)
 			}
-			if !b.Control.Type.IsMemory() {
-				f.Fatalf("ret block %s has non-memory control value %s", b, b.Control.LongString())
+			if !b.Controls[0].Type.IsMemory() {
+				f.Fatalf("ret block %s has non-memory control value %s", b, b.Controls[0].LongString())
 			}
 		case BlockRetJmp:
 			if len(b.Succs) != 0 {
 				f.Fatalf("retjmp block %s len(Succs)==%d, want 0", b, len(b.Succs))
 			}
-			if b.Control == nil {
+			if b.NumControls() != 1 {
 				f.Fatalf("retjmp block %s has nil control", b)
 			}
-			if !b.Control.Type.IsMemory() {
-				f.Fatalf("retjmp block %s has non-memory control value %s", b, b.Control.LongString())
+			if !b.Controls[0].Type.IsMemory() {
+				f.Fatalf("retjmp block %s has non-memory control value %s", b, b.Controls[0].LongString())
 			}
 			if b.Aux == nil {
 				f.Fatalf("retjmp block %s has nil Aux field", b)
@@ -72,34 +72,34 @@ func checkFunc(f *Func) {
 			if len(b.Succs) != 1 {
 				f.Fatalf("plain block %s len(Succs)==%d, want 1", b, len(b.Succs))
 			}
-			if b.Control != nil {
-				f.Fatalf("plain block %s has non-nil control %s", b, b.Control.LongString())
+			if b.NumControls() != 0 {
+				f.Fatalf("plain block %s has non-nil control %s", b, b.Controls[0].LongString())
 			}
 		case BlockIf:
 			if len(b.Succs) != 2 {
 				f.Fatalf("if block %s len(Succs)==%d, want 2", b, len(b.Succs))
 			}
-			if b.Control == nil {
+			if b.NumControls() != 1 {
 				f.Fatalf("if block %s has no control value", b)
 			}
-			if !b.Control.Type.IsBoolean() {
-				f.Fatalf("if block %s has non-bool control value %s", b, b.Control.LongString())
+			if !b.Controls[0].Type.IsBoolean() {
+				f.Fatalf("if block %s has non-bool control value %s", b, b.Controls[0].LongString())
 			}
 		case BlockDefer:
 			if len(b.Succs) != 2 {
 				f.Fatalf("defer block %s len(Succs)==%d, want 2", b, len(b.Succs))
 			}
-			if b.Control == nil {
+			if b.NumControls() != 1 {
 				f.Fatalf("defer block %s has no control value", b)
 			}
-			if !b.Control.Type.IsMemory() {
-				f.Fatalf("defer block %s has non-memory control value %s", b, b.Control.LongString())
+			if !b.Controls[0].Type.IsMemory() {
+				f.Fatalf("defer block %s has non-memory control value %s", b, b.Controls[0].LongString())
 			}
 		case BlockFirst:
 			if len(b.Succs) != 2 {
 				f.Fatalf("plain/dead block %s len(Succs)==%d, want 2", b, len(b.Succs))
 			}
-			if b.Control != nil {
+			if b.NumControls() != 0 {
 				f.Fatalf("plain/dead block %s has a control value", b)
 			}
 		}
@@ -263,8 +263,10 @@ func checkFunc(f *Func) {
 				}
 			}
 		}
-		if b.Control != nil && !valueMark[b.Control.ID] {
-			f.Fatalf("control value for %s is missing: %v", b, b.Control)
+		for _, c := range b.ControlValues() {
+			if !valueMark[c.ID] {
+				f.Fatalf("control value for %s is missing: %v", b, c)
+			}
 		}
 	}
 	for b := f.freeBlocks; b != nil; b = b.succstorage[0].b {
@@ -296,8 +298,10 @@ func checkFunc(f *Func) {
 					}
 				}
 			}
-			if b.Control != nil && !domCheck(f, sdom, b.Control.Block, b) {
-				f.Fatalf("control value %s for %s doesn't dominate", b.Control, b)
+			for _, c := range b.ControlValues() {
+				if !domCheck(f, sdom, c.Block, b) {
+					f.Fatalf("control value %s for %s doesn't dominate", c, b)
+				}
 			}
 		}
 	}
@@ -329,8 +333,8 @@ func checkFunc(f *Func) {
 				uses[a.ID]++
 			}
 		}
-		if b.Control != nil {
-			uses[b.Control.ID]++
+		for _, c := range b.ControlValues() {
+			uses[c.ID]++
 		}
 	}
 	for _, b := range f.Blocks {
diff --git a/src/cmd/compile/internal/ssa/copyelim.go b/src/cmd/compile/internal/ssa/copyelim.go
index 44ccfe1bfe..5954d3bec8 100644
--- a/src/cmd/compile/internal/ssa/copyelim.go
+++ b/src/cmd/compile/internal/ssa/copyelim.go
@@ -17,8 +17,10 @@ func copyelim(f *Func) {
 
 	// Update block control values.
 	for _, b := range f.Blocks {
-		if v := b.Control; v != nil && v.Op == OpCopy {
-			b.SetControl(v.Args[0])
+		for i, v := range b.ControlValues() {
+			if v.Op == OpCopy {
+				b.ReplaceControl(i, v.Args[0])
+			}
 		}
 	}
 
diff --git a/src/cmd/compile/internal/ssa/cse.go b/src/cmd/compile/internal/ssa/cse.go
index 75595c3b3d..1fdcffcae8 100644
--- a/src/cmd/compile/internal/ssa/cse.go
+++ b/src/cmd/compile/internal/ssa/cse.go
@@ -248,14 +248,14 @@ func cse(f *Func) {
 				}
 			}
 		}
-		if v := b.Control; v != nil {
+		for i, v := range b.ControlValues() {
 			if x := rewrite[v.ID]; x != nil {
 				if v.Op == OpNilCheck {
 					// nilcheck pass will remove the nil checks and log
 					// them appropriately, so don't mess with them here.
 					continue
 				}
-				b.SetControl(x)
+				b.ReplaceControl(i, x)
 			}
 		}
 	}
diff --git a/src/cmd/compile/internal/ssa/deadcode.go b/src/cmd/compile/internal/ssa/deadcode.go
index 24d1d88165..b79ec7c2f6 100644
--- a/src/cmd/compile/internal/ssa/deadcode.go
+++ b/src/cmd/compile/internal/ssa/deadcode.go
@@ -110,11 +110,13 @@ func liveValues(f *Func, reachable []bool) (live []bool, liveOrderStmts []*Value
 		if !reachable[b.ID] {
 			continue
 		}
-		if v := b.Control; v != nil && !live[v.ID] {
-			live[v.ID] = true
-			q = append(q, v)
-			if v.Pos.IsStmt() != src.PosNotStmt {
-				liveOrderStmts = append(liveOrderStmts, v)
+		for _, v := range b.ControlValues() {
+			if !live[v.ID] {
+				live[v.ID] = true
+				q = append(q, v)
+				if v.Pos.IsStmt() != src.PosNotStmt {
+					liveOrderStmts = append(liveOrderStmts, v)
+				}
 			}
 		}
 		for _, v := range b.Values {
@@ -252,7 +254,7 @@ func deadcode(f *Func) {
 	for i, b := range f.Blocks {
 		if !reachable[b.ID] {
 			// TODO what if control is statement boundary? Too late here.
-			b.SetControl(nil)
+			b.ResetControls()
 		}
 		for _, v := range b.Values {
 			if !live[v.ID] {
diff --git a/src/cmd/compile/internal/ssa/deadstore.go b/src/cmd/compile/internal/ssa/deadstore.go
index ebcb571e66..6b9bcedadb 100644
--- a/src/cmd/compile/internal/ssa/deadstore.go
+++ b/src/cmd/compile/internal/ssa/deadstore.go
@@ -264,12 +264,11 @@ func elimDeadAutosGeneric(f *Func) {
 				changed = visit(v) || changed
 			}
 			// keep the auto if its address reaches a control value
-			if b.Control == nil {
-				continue
-			}
-			if n, ok := addr[b.Control]; ok && !used[n] {
-				used[n] = true
-				changed = true
+			for _, c := range b.ControlValues() {
+				if n, ok := addr[c]; ok && !used[n] {
+					used[n] = true
+					changed = true
+				}
 			}
 		}
 		if !changed {
diff --git a/src/cmd/compile/internal/ssa/flagalloc.go b/src/cmd/compile/internal/ssa/flagalloc.go
index 7a2ecc22dc..7e7ce11482 100644
--- a/src/cmd/compile/internal/ssa/flagalloc.go
+++ b/src/cmd/compile/internal/ssa/flagalloc.go
@@ -18,9 +18,17 @@ func flagalloc(f *Func) {
 			// Walk values backwards to figure out what flag
 			// value we want in the flag register at the start
 			// of the block.
-			flag := end[b.ID]
-			if b.Control != nil && b.Control.Type.IsFlags() {
-				flag = b.Control
+			var flag *Value
+			for _, c := range b.ControlValues() {
+				if c.Type.IsFlags() {
+					if flag != nil {
+						panic("cannot have multiple controls using flags")
+					}
+					flag = c
+				}
+			}
+			if flag == nil {
+				flag = end[b.ID]
 			}
 			for j := len(b.Values) - 1; j >= 0; j-- {
 				v := b.Values[j]
@@ -49,13 +57,15 @@ func flagalloc(f *Func) {
 	// we can leave in the flags register at the end of the block. (There
 	// is no place to put a flag regeneration instruction.)
 	for _, b := range f.Blocks {
-		v := b.Control
-		if v != nil && v.Type.IsFlags() && end[b.ID] != v {
-			end[b.ID] = nil
-		}
 		if b.Kind == BlockDefer {
 			// Defer blocks internally use/clobber the flags value.
 			end[b.ID] = nil
+			continue
+		}
+		for _, v := range b.ControlValues() {
+			if v.Type.IsFlags() && end[b.ID] != v {
+				end[b.ID] = nil
+			}
 		}
 	}
 
@@ -85,8 +95,10 @@ func flagalloc(f *Func) {
 				flag = v
 			}
 		}
-		if v := b.Control; v != nil && v != flag && v.Type.IsFlags() {
-			spill[v.ID] = true
+		for _, v := range b.ControlValues() {
+			if v != flag && v.Type.IsFlags() {
+				spill[v.ID] = true
+			}
 		}
 		if v := end[b.ID]; v != nil && v != flag {
 			spill[v.ID] = true
@@ -149,11 +161,13 @@ func flagalloc(f *Func) {
 				flag = v
 			}
 		}
-		if v := b.Control; v != nil && v != flag && v.Type.IsFlags() {
-			// Recalculate control value.
-			c := copyFlags(v, b)
-			b.SetControl(c)
-			flag = v
+		for i, v := range b.ControlValues() {
+			if v != flag && v.Type.IsFlags() {
+				// Recalculate control value.
+				c := copyFlags(v, b)
+				b.ReplaceControl(i, c)
+				flag = v
+			}
 		}
 		if v := end[b.ID]; v != nil && v != flag {
 			// Need to reissue flag generator for use by
diff --git a/src/cmd/compile/internal/ssa/fuse.go b/src/cmd/compile/internal/ssa/fuse.go
index 8d14b5d696..a530874b80 100644
--- a/src/cmd/compile/internal/ssa/fuse.go
+++ b/src/cmd/compile/internal/ssa/fuse.go
@@ -118,7 +118,7 @@ func fuseBlockIf(b *Block) bool {
 	}
 	b.Kind = BlockPlain
 	b.Likely = BranchUnknown
-	b.SetControl(nil)
+	b.ResetControls()
 
 	// Trash the empty blocks s0 and s1.
 	blocks := [...]*Block{s0, s1}
diff --git a/src/cmd/compile/internal/ssa/gen/386.rules b/src/cmd/compile/internal/ssa/gen/386.rules
index 1cdcf4c710..94573702a5 100644
--- a/src/cmd/compile/internal/ssa/gen/386.rules
+++ b/src/cmd/compile/internal/ssa/gen/386.rules
@@ -899,65 +899,65 @@
 (SBBLcarrymask (FlagGT_UGT)) -> (MOVLconst [0])
 
 // Absorb flag constants into branches.
-(EQ (FlagEQ) yes no) -> (First nil yes no)
-(EQ (FlagLT_ULT) yes no) -> (First nil no yes)
-(EQ (FlagLT_UGT) yes no) -> (First nil no yes)
-(EQ (FlagGT_ULT) yes no) -> (First nil no yes)
-(EQ (FlagGT_UGT) yes no) -> (First nil no yes)
-
-(NE (FlagEQ) yes no) -> (First nil no yes)
-(NE (FlagLT_ULT) yes no) -> (First nil yes no)
-(NE (FlagLT_UGT) yes no) -> (First nil yes no)
-(NE (FlagGT_ULT) yes no) -> (First nil yes no)
-(NE (FlagGT_UGT) yes no) -> (First nil yes no)
-
-(LT (FlagEQ) yes no) -> (First nil no yes)
-(LT (FlagLT_ULT) yes no) -> (First nil yes no)
-(LT (FlagLT_UGT) yes no) -> (First nil yes no)
-(LT (FlagGT_ULT) yes no) -> (First nil no yes)
-(LT (FlagGT_UGT) yes no) -> (First nil no yes)
-
-(LE (FlagEQ) yes no) -> (First nil yes no)
-(LE (FlagLT_ULT) yes no) -> (First nil yes no)
-(LE (FlagLT_UGT) yes no) -> (First nil yes no)
-(LE (FlagGT_ULT) yes no) -> (First nil no yes)
-(LE (FlagGT_UGT) yes no) -> (First nil no yes)
-
-(GT (FlagEQ) yes no) -> (First nil no yes)
-(GT (FlagLT_ULT) yes no) -> (First nil no yes)
-(GT (FlagLT_UGT) yes no) -> (First nil no yes)
-(GT (FlagGT_ULT) yes no) -> (First nil yes no)
-(GT (FlagGT_UGT) yes no) -> (First nil yes no)
-
-(GE (FlagEQ) yes no) -> (First nil yes no)
-(GE (FlagLT_ULT) yes no) -> (First nil no yes)
-(GE (FlagLT_UGT) yes no) -> (First nil no yes)
-(GE (FlagGT_ULT) yes no) -> (First nil yes no)
-(GE (FlagGT_UGT) yes no) -> (First nil yes no)
-
-(ULT (FlagEQ) yes no) -> (First nil no yes)
-(ULT (FlagLT_ULT) yes no) -> (First nil yes no)
-(ULT (FlagLT_UGT) yes no) -> (First nil no yes)
-(ULT (FlagGT_ULT) yes no) -> (First nil yes no)
-(ULT (FlagGT_UGT) yes no) -> (First nil no yes)
-
-(ULE (FlagEQ) yes no) -> (First nil yes no)
-(ULE (FlagLT_ULT) yes no) -> (First nil yes no)
-(ULE (FlagLT_UGT) yes no) -> (First nil no yes)
-(ULE (FlagGT_ULT) yes no) -> (First nil yes no)
-(ULE (FlagGT_UGT) yes no) -> (First nil no yes)
-
-(UGT (FlagEQ) yes no) -> (First nil no yes)
-(UGT (FlagLT_ULT) yes no) -> (First nil no yes)
-(UGT (FlagLT_UGT) yes no) -> (First nil yes no)
-(UGT (FlagGT_ULT) yes no) -> (First nil no yes)
-(UGT (FlagGT_UGT) yes no) -> (First nil yes no)
-
-(UGE (FlagEQ) yes no) -> (First nil yes no)
-(UGE (FlagLT_ULT) yes no) -> (First nil no yes)
-(UGE (FlagLT_UGT) yes no) -> (First nil yes no)
-(UGE (FlagGT_ULT) yes no) -> (First nil no yes)
-(UGE (FlagGT_UGT) yes no) -> (First nil yes no)
+(EQ (FlagEQ) yes no) -> (First yes no)
+(EQ (FlagLT_ULT) yes no) -> (First no yes)
+(EQ (FlagLT_UGT) yes no) -> (First no yes)
+(EQ (FlagGT_ULT) yes no) -> (First no yes)
+(EQ (FlagGT_UGT) yes no) -> (First no yes)
+
+(NE (FlagEQ) yes no) -> (First no yes)
+(NE (FlagLT_ULT) yes no) -> (First yes no)
+(NE (FlagLT_UGT) yes no) -> (First yes no)
+(NE (FlagGT_ULT) yes no) -> (First yes no)
+(NE (FlagGT_UGT) yes no) -> (First yes no)
+
+(LT (FlagEQ) yes no) -> (First no yes)
+(LT (FlagLT_ULT) yes no) -> (First yes no)
+(LT (FlagLT_UGT) yes no) -> (First yes no)
+(LT (FlagGT_ULT) yes no) -> (First no yes)
+(LT (FlagGT_UGT) yes no) -> (First no yes)
+
+(LE (FlagEQ) yes no) -> (First yes no)
+(LE (FlagLT_ULT) yes no) -> (First yes no)
+(LE (FlagLT_UGT) yes no) -> (First yes no)
+(LE (FlagGT_ULT) yes no) -> (First no yes)
+(LE (FlagGT_UGT) yes no) -> (First no yes)
+
+(GT (FlagEQ) yes no) -> (First no yes)
+(GT (FlagLT_ULT) yes no) -> (First no yes)
+(GT (FlagLT_UGT) yes no) -> (First no yes)
+(GT (FlagGT_ULT) yes no) -> (First yes no)
+(GT (FlagGT_UGT) yes no) -> (First yes no)
+
+(GE (FlagEQ) yes no) -> (First yes no)
+(GE (FlagLT_ULT) yes no) -> (First no yes)
+(GE (FlagLT_UGT) yes no) -> (First no yes)
+(GE (FlagGT_ULT) yes no) -> (First yes no)
+(GE (FlagGT_UGT) yes no) -> (First yes no)
+
+(ULT (FlagEQ) yes no) -> (First no yes)
+(ULT (FlagLT_ULT) yes no) -> (First yes no)
+(ULT (FlagLT_UGT) yes no) -> (First no yes)
+(ULT (FlagGT_ULT) yes no) -> (First yes no)
+(ULT (FlagGT_UGT) yes no) -> (First no yes)
+
+(ULE (FlagEQ) yes no) -> (First yes no)
+(ULE (FlagLT_ULT) yes no) -> (First yes no)
+(ULE (FlagLT_UGT) yes no) -> (First no yes)
+(ULE (FlagGT_ULT) yes no) -> (First yes no)
+(ULE (FlagGT_UGT) yes no) -> (First no yes)
+
+(UGT (FlagEQ) yes no) -> (First no yes)
+(UGT (FlagLT_ULT) yes no) -> (First no yes)
+(UGT (FlagLT_UGT) yes no) -> (First yes no)
+(UGT (FlagGT_ULT) yes no) -> (First no yes)
+(UGT (FlagGT_UGT) yes no) -> (First yes no)
+
+(UGE (FlagEQ) yes no) -> (First yes no)
+(UGE (FlagLT_ULT) yes no) -> (First no yes)
+(UGE (FlagLT_UGT) yes no) -> (First yes no)
+(UGE (FlagGT_ULT) yes no) -> (First no yes)
+(UGE (FlagGT_UGT) yes no) -> (First yes no)
 
 // Absorb flag constants into SETxx ops.
 (SETEQ (FlagEQ)) -> (MOVLconst [1])
diff --git a/src/cmd/compile/internal/ssa/gen/386Ops.go b/src/cmd/compile/internal/ssa/gen/386Ops.go
index 2851c4321c..4fb61adfeb 100644
--- a/src/cmd/compile/internal/ssa/gen/386Ops.go
+++ b/src/cmd/compile/internal/ssa/gen/386Ops.go
@@ -564,22 +564,22 @@ func init() {
 	}
 
 	var _386blocks = []blockData{
-		{name: "EQ"},
-		{name: "NE"},
-		{name: "LT"},
-		{name: "LE"},
-		{name: "GT"},
-		{name: "GE"},
-		{name: "OS"},
-		{name: "OC"},
-		{name: "ULT"},
-		{name: "ULE"},
-		{name: "UGT"},
-		{name: "UGE"},
-		{name: "EQF"},
-		{name: "NEF"},
-		{name: "ORD"}, // FP, ordered comparison (parity zero)
-		{name: "NAN"}, // FP, unordered comparison (parity one)
+		{name: "EQ", controls: 1},
+		{name: "NE", controls: 1},
+		{name: "LT", controls: 1},
+		{name: "LE", controls: 1},
+		{name: "GT", controls: 1},
+		{name: "GE", controls: 1},
+		{name: "OS", controls: 1},
+		{name: "OC", controls: 1},
+		{name: "ULT", controls: 1},
+		{name: "ULE", controls: 1},
+		{name: "UGT", controls: 1},
+		{name: "UGE", controls: 1},
+		{name: "EQF", controls: 1},
+		{name: "NEF", controls: 1},
+		{name: "ORD", controls: 1}, // FP, ordered comparison (parity zero)
+		{name: "NAN", controls: 1}, // FP, unordered comparison (parity one)
 	}
 
 	archs = append(archs, arch{
diff --git a/src/cmd/compile/internal/ssa/gen/AMD64.rules b/src/cmd/compile/internal/ssa/gen/AMD64.rules
index 58e2d3ad18..e4b97a8763 100644
--- a/src/cmd/compile/internal/ssa/gen/AMD64.rules
+++ b/src/cmd/compile/internal/ssa/gen/AMD64.rules
@@ -1346,16 +1346,16 @@
 (SBBLcarrymask (FlagGT_UGT)) -> (MOVLconst [0])
 
 // Absorb flag constants into branches.
-((EQ|LE|GE|ULE|UGE) (FlagEQ) yes no) -> (First nil yes no)
-((NE|LT|GT|ULT|UGT) (FlagEQ) yes no) -> (First nil no yes)
-((NE|LT|LE|ULT|ULE) (FlagLT_ULT) yes no) -> (First nil yes no)
-((EQ|GT|GE|UGT|UGE) (FlagLT_ULT) yes no) -> (First nil no yes)
-((NE|LT|LE|UGT|UGE) (FlagLT_UGT) yes no) -> (First nil yes no)
-((EQ|GT|GE|ULT|ULE) (FlagLT_UGT) yes no) -> (First nil no yes)
-((NE|GT|GE|ULT|ULE) (FlagGT_ULT) yes no) -> (First nil yes no)
-((EQ|LT|LE|UGT|UGE) (FlagGT_ULT) yes no) -> (First nil no yes)
-((NE|GT|GE|UGT|UGE) (FlagGT_UGT) yes no) -> (First nil yes no)
-((EQ|LT|LE|ULT|ULE) (FlagGT_UGT) yes no) -> (First nil no yes)
+((EQ|LE|GE|ULE|UGE) (FlagEQ) yes no) -> (First yes no)
+((NE|LT|GT|ULT|UGT) (FlagEQ) yes no) -> (First no yes)
+((NE|LT|LE|ULT|ULE) (FlagLT_ULT) yes no) -> (First yes no)
+((EQ|GT|GE|UGT|UGE) (FlagLT_ULT) yes no) -> (First no yes)
+((NE|LT|LE|UGT|UGE) (FlagLT_UGT) yes no) -> (First yes no)
+((EQ|GT|GE|ULT|ULE) (FlagLT_UGT) yes no) -> (First no yes)
+((NE|GT|GE|ULT|ULE) (FlagGT_ULT) yes no) -> (First yes no)
+((EQ|LT|LE|UGT|UGE) (FlagGT_ULT) yes no) -> (First no yes)
+((NE|GT|GE|UGT|UGE) (FlagGT_UGT) yes no) -> (First yes no)
+((EQ|LT|LE|ULT|ULE) (FlagGT_UGT) yes no) -> (First no yes)
 
 // Absorb flag constants into SETxx ops.
 ((SETEQ|SETLE|SETGE|SETBE|SETAE) (FlagEQ))     -> (MOVLconst [1])
diff --git a/src/cmd/compile/internal/ssa/gen/AMD64Ops.go b/src/cmd/compile/internal/ssa/gen/AMD64Ops.go
index 739733cf16..ed58db4d59 100644
--- a/src/cmd/compile/internal/ssa/gen/AMD64Ops.go
+++ b/src/cmd/compile/internal/ssa/gen/AMD64Ops.go
@@ -788,22 +788,22 @@ func init() {
 	}
 
 	var AMD64blocks = []blockData{
-		{name: "EQ"},
-		{name: "NE"},
-		{name: "LT"},
-		{name: "LE"},
-		{name: "GT"},
-		{name: "GE"},
-		{name: "OS"},
-		{name: "OC"},
-		{name: "ULT"},
-		{name: "ULE"},
-		{name: "UGT"},
-		{name: "UGE"},
-		{name: "EQF"},
-		{name: "NEF"},
-		{name: "ORD"}, // FP, ordered comparison (parity zero)
-		{name: "NAN"}, // FP, unordered comparison (parity one)
+		{name: "EQ", controls: 1},
+		{name: "NE", controls: 1},
+		{name: "LT", controls: 1},
+		{name: "LE", controls: 1},
+		{name: "GT", controls: 1},
+		{name: "GE", controls: 1},
+		{name: "OS", controls: 1},
+		{name: "OC", controls: 1},
+		{name: "ULT", controls: 1},
+		{name: "ULE", controls: 1},
+		{name: "UGT", controls: 1},
+		{name: "UGE", controls: 1},
+		{name: "EQF", controls: 1},
+		{name: "NEF", controls: 1},
+		{name: "ORD", controls: 1}, // FP, ordered comparison (parity zero)
+		{name: "NAN", controls: 1}, // FP, unordered comparison (parity one)
 	}
 
 	archs = append(archs, arch{
diff --git a/src/cmd/compile/internal/ssa/gen/ARM.rules b/src/cmd/compile/internal/ssa/gen/ARM.rules
index a3ee9046c5..0858b443da 100644
--- a/src/cmd/compile/internal/ssa/gen/ARM.rules
+++ b/src/cmd/compile/internal/ssa/gen/ARM.rules
@@ -647,65 +647,65 @@
 (CMPconst (SRLconst _ [c]) [n]) && 0 <= n && 0 < c && c <= 32 && (1<<uint32(32-c)) <= uint32(n) -> (FlagLT_ULT)
 
 // absorb flag constants into branches
-(EQ (FlagEQ) yes no) -> (First nil yes no)
-(EQ (FlagLT_ULT) yes no) -> (First nil no yes)
-(EQ (FlagLT_UGT) yes no) -> (First nil no yes)
-(EQ (FlagGT_ULT) yes no) -> (First nil no yes)
-(EQ (FlagGT_UGT) yes no) -> (First nil no yes)
-
-(NE (FlagEQ) yes no) -> (First nil no yes)
-(NE (FlagLT_ULT) yes no) -> (First nil yes no)
-(NE (FlagLT_UGT) yes no) -> (First nil yes no)
-(NE (FlagGT_ULT) yes no) -> (First nil yes no)
-(NE (FlagGT_UGT) yes no) -> (First nil yes no)
-
-(LT (FlagEQ) yes no) -> (First nil no yes)
-(LT (FlagLT_ULT) yes no) -> (First nil yes no)
-(LT (FlagLT_UGT) yes no) -> (First nil yes no)
-(LT (FlagGT_ULT) yes no) -> (First nil no yes)
-(LT (FlagGT_UGT) yes no) -> (First nil no yes)
-
-(LE (FlagEQ) yes no) -> (First nil yes no)
-(LE (FlagLT_ULT) yes no) -> (First nil yes no)
-(LE (FlagLT_UGT) yes no) -> (First nil yes no)
-(LE (FlagGT_ULT) yes no) -> (First nil no yes)
-(LE (FlagGT_UGT) yes no) -> (First nil no yes)
-
-(GT (FlagEQ) yes no) -> (First nil no yes)
-(GT (FlagLT_ULT) yes no) -> (First nil no yes)
-(GT (FlagLT_UGT) yes no) -> (First nil no yes)
-(GT (FlagGT_ULT) yes no) -> (First nil yes no)
-(GT (FlagGT_UGT) yes no) -> (First nil yes no)
-
-(GE (FlagEQ) yes no) -> (First nil yes no)
-(GE (FlagLT_ULT) yes no) -> (First nil no yes)
-(GE (FlagLT_UGT) yes no) -> (First nil no yes)
-(GE (FlagGT_ULT) yes no) -> (First nil yes no)
-(GE (FlagGT_UGT) yes no) -> (First nil yes no)
-
-(ULT (FlagEQ) yes no) -> (First nil no yes)
-(ULT (FlagLT_ULT) yes no) -> (First nil yes no)
-(ULT (FlagLT_UGT) yes no) -> (First nil no yes)
-(ULT (FlagGT_ULT) yes no) -> (First nil yes no)
-(ULT (FlagGT_UGT) yes no) -> (First nil no yes)
-
-(ULE (FlagEQ) yes no) -> (First nil yes no)
-(ULE (FlagLT_ULT) yes no) -> (First nil yes no)
-(ULE (FlagLT_UGT) yes no) -> (First nil no yes)
-(ULE (FlagGT_ULT) yes no) -> (First nil yes no)
-(ULE (FlagGT_UGT) yes no) -> (First nil no yes)
-
-(UGT (FlagEQ) yes no) -> (First nil no yes)
-(UGT (FlagLT_ULT) yes no) -> (First nil no yes)
-(UGT (FlagLT_UGT) yes no) -> (First nil yes no)
-(UGT (FlagGT_ULT) yes no) -> (First nil no yes)
-(UGT (FlagGT_UGT) yes no) -> (First nil yes no)
-
-(UGE (FlagEQ) yes no) -> (First nil yes no)
-(UGE (FlagLT_ULT) yes no) -> (First nil no yes)
-(UGE (FlagLT_UGT) yes no) -> (First nil yes no)
-(UGE (FlagGT_ULT) yes no) -> (First nil no yes)
-(UGE (FlagGT_UGT) yes no) -> (First nil yes no)
+(EQ (FlagEQ) yes no) -> (First yes no)
+(EQ (FlagLT_ULT) yes no) -> (First no yes)
+(EQ (FlagLT_UGT) yes no) -> (First no yes)
+(EQ (FlagGT_ULT) yes no) -> (First no yes)
+(EQ (FlagGT_UGT) yes no) -> (First no yes)
+
+(NE (FlagEQ) yes no) -> (First no yes)
+(NE (FlagLT_ULT) yes no) -> (First yes no)
+(NE (FlagLT_UGT) yes no) -> (First yes no)
+(NE (FlagGT_ULT) yes no) -> (First yes no)
+(NE (FlagGT_UGT) yes no) -> (First yes no)
+
+(LT (FlagEQ) yes no) -> (First no yes)
+(LT (FlagLT_ULT) yes no) -> (First yes no)
+(LT (FlagLT_UGT) yes no) -> (First yes no)
+(LT (FlagGT_ULT) yes no) -> (First no yes)
+(LT (FlagGT_UGT) yes no) -> (First no yes)
+
+(LE (FlagEQ) yes no) -> (First yes no)
+(LE (FlagLT_ULT) yes no) -> (First yes no)
+(LE (FlagLT_UGT) yes no) -> (First yes no)
+(LE (FlagGT_ULT) yes no) -> (First no yes)
+(LE (FlagGT_UGT) yes no) -> (First no yes)
+
+(GT (FlagEQ) yes no) -> (First no yes)
+(GT (FlagLT_ULT) yes no) -> (First no yes)
+(GT (FlagLT_UGT) yes no) -> (First no yes)
+(GT (FlagGT_ULT) yes no) -> (First yes no)
+(GT (FlagGT_UGT) yes no) -> (First yes no)
+
+(GE (FlagEQ) yes no) -> (First yes no)
+(GE (FlagLT_ULT) yes no) -> (First no yes)
+(GE (FlagLT_UGT) yes no) -> (First no yes)
+(GE (FlagGT_ULT) yes no) -> (First yes no)
+(GE (FlagGT_UGT) yes no) -> (First yes no)
+
+(ULT (FlagEQ) yes no) -> (First no yes)
+(ULT (FlagLT_ULT) yes no) -> (First yes no)
+(ULT (FlagLT_UGT) yes no) -> (First no yes)
+(ULT (FlagGT_ULT) yes no) -> (First yes no)
+(ULT (FlagGT_UGT) yes no) -> (First no yes)
+
+(ULE (FlagEQ) yes no) -> (First yes no)
+(ULE (FlagLT_ULT) yes no) -> (First yes no)
+(ULE (FlagLT_UGT) yes no) -> (First no yes)
+(ULE (FlagGT_ULT) yes no) -> (First yes no)
+(ULE (FlagGT_UGT) yes no) -> (First no yes)
+
+(UGT (FlagEQ) yes no) -> (First no yes)
+(UGT (FlagLT_ULT) yes no) -> (First no yes)
+(UGT (FlagLT_UGT) yes no) -> (First yes no)
+(UGT (FlagGT_ULT) yes no) -> (First no yes)
+(UGT (FlagGT_UGT) yes no) -> (First yes no)
+
+(UGE (FlagEQ) yes no) -> (First yes no)
+(UGE (FlagLT_ULT) yes no) -> (First no yes)
+(UGE (FlagLT_UGT) yes no) -> (First yes no)
+(UGE (FlagGT_ULT) yes no) -> (First no yes)
+(UGE (FlagGT_UGT) yes no) -> (First yes no)
 
 // absorb InvertFlags into branches
 (LT (InvertFlags cmp) yes no) -> (GT cmp yes no)
diff --git a/src/cmd/compile/internal/ssa/gen/ARM64.rules b/src/cmd/compile/internal/ssa/gen/ARM64.rules
index ddb504531c..7edd19e9cc 100644
--- a/src/cmd/compile/internal/ssa/gen/ARM64.rules
+++ b/src/cmd/compile/internal/ssa/gen/ARM64.rules
@@ -1481,74 +1481,74 @@
 (CMPWconst (MOVHUreg _) [c]) && 0xffff < int32(c) -> (FlagLT_ULT)
 
 // absorb flag constants into branches
-(EQ (FlagEQ) yes no) -> (First nil yes no)
-(EQ (FlagLT_ULT) yes no) -> (First nil no yes)
-(EQ (FlagLT_UGT) yes no) -> (First nil no yes)
-(EQ (FlagGT_ULT) yes no) -> (First nil no yes)
-(EQ (FlagGT_UGT) yes no) -> (First nil no yes)
-
-(NE (FlagEQ) yes no) -> (First nil no yes)
-(NE (FlagLT_ULT) yes no) -> (First nil yes no)
-(NE (FlagLT_UGT) yes no) -> (First nil yes no)
-(NE (FlagGT_ULT) yes no) -> (First nil yes no)
-(NE (FlagGT_UGT) yes no) -> (First nil yes no)
-
-(LT (FlagEQ) yes no) -> (First nil no yes)
-(LT (FlagLT_ULT) yes no) -> (First nil yes no)
-(LT (FlagLT_UGT) yes no) -> (First nil yes no)
-(LT (FlagGT_ULT) yes no) -> (First nil no yes)
-(LT (FlagGT_UGT) yes no) -> (First nil no yes)
-
-(LE (FlagEQ) yes no) -> (First nil yes no)
-(LE (FlagLT_ULT) yes no) -> (First nil yes no)
-(LE (FlagLT_UGT) yes no) -> (First nil yes no)
-(LE (FlagGT_ULT) yes no) -> (First nil no yes)
-(LE (FlagGT_UGT) yes no) -> (First nil no yes)
-
-(GT (FlagEQ) yes no) -> (First nil no yes)
-(GT (FlagLT_ULT) yes no) -> (First nil no yes)
-(GT (FlagLT_UGT) yes no) -> (First nil no yes)
-(GT (FlagGT_ULT) yes no) -> (First nil yes no)
-(GT (FlagGT_UGT) yes no) -> (First nil yes no)
-
-(GE (FlagEQ) yes no) -> (First nil yes no)
-(GE (FlagLT_ULT) yes no) -> (First nil no yes)
-(GE (FlagLT_UGT) yes no) -> (First nil no yes)
-(GE (FlagGT_ULT) yes no) -> (First nil yes no)
-(GE (FlagGT_UGT) yes no) -> (First nil yes no)
-
-(ULT (FlagEQ) yes no) -> (First nil no yes)
-(ULT (FlagLT_ULT) yes no) -> (First nil yes no)
-(ULT (FlagLT_UGT) yes no) -> (First nil no yes)
-(ULT (FlagGT_ULT) yes no) -> (First nil yes no)
-(ULT (FlagGT_UGT) yes no) -> (First nil no yes)
-
-(ULE (FlagEQ) yes no) -> (First nil yes no)
-(ULE (FlagLT_ULT) yes no) -> (First nil yes no)
-(ULE (FlagLT_UGT) yes no) -> (First nil no yes)
-(ULE (FlagGT_ULT) yes no) -> (First nil yes no)
-(ULE (FlagGT_UGT) yes no) -> (First nil no yes)
-
-(UGT (FlagEQ) yes no) -> (First nil no yes)
-(UGT (FlagLT_ULT) yes no) -> (First nil no yes)
-(UGT (FlagLT_UGT) yes no) -> (First nil yes no)
-(UGT (FlagGT_ULT) yes no) -> (First nil no yes)
-(UGT (FlagGT_UGT) yes no) -> (First nil yes no)
-
-(UGE (FlagEQ) yes no) -> (First nil yes no)
-(UGE (FlagLT_ULT) yes no) -> (First nil no yes)
-(UGE (FlagLT_UGT) yes no) -> (First nil yes no)
-(UGE (FlagGT_ULT) yes no) -> (First nil no yes)
-(UGE (FlagGT_UGT) yes no) -> (First nil yes no)
-
-(Z (MOVDconst [0]) yes no) -> (First nil yes no)
-(Z (MOVDconst [c]) yes no) && c != 0 -> (First nil no yes)
-(NZ (MOVDconst [0]) yes no) -> (First nil no yes)
-(NZ (MOVDconst [c]) yes no) && c != 0 -> (First nil yes no)
-(ZW (MOVDconst [c]) yes no) && int32(c) == 0 -> (First nil yes no)
-(ZW (MOVDconst [c]) yes no) && int32(c) != 0 -> (First nil no yes)
-(NZW (MOVDconst [c]) yes no) && int32(c) == 0 -> (First nil no yes)
-(NZW (MOVDconst [c]) yes no) && int32(c) != 0 -> (First nil yes no)
+(EQ (FlagEQ) yes no) -> (First yes no)
+(EQ (FlagLT_ULT) yes no) -> (First no yes)
+(EQ (FlagLT_UGT) yes no) -> (First no yes)
+(EQ (FlagGT_ULT) yes no) -> (First no yes)
+(EQ (FlagGT_UGT) yes no) -> (First no yes)
+
+(NE (FlagEQ) yes no) -> (First no yes)
+(NE (FlagLT_ULT) yes no) -> (First yes no)
+(NE (FlagLT_UGT) yes no) -> (First yes no)
+(NE (FlagGT_ULT) yes no) -> (First yes no)
+(NE (FlagGT_UGT) yes no) -> (First yes no)
+
+(LT (FlagEQ) yes no) -> (First no yes)
+(LT (FlagLT_ULT) yes no) -> (First yes no)
+(LT (FlagLT_UGT) yes no) -> (First yes no)
+(LT (FlagGT_ULT) yes no) -> (First no yes)
+(LT (FlagGT_UGT) yes no) -> (First no yes)
+
+(LE (FlagEQ) yes no) -> (First yes no)
+(LE (FlagLT_ULT) yes no) -> (First yes no)
+(LE (FlagLT_UGT) yes no) -> (First yes no)
+(LE (FlagGT_ULT) yes no) -> (First no yes)
+(LE (FlagGT_UGT) yes no) -> (First no yes)
+
+(GT (FlagEQ) yes no) -> (First no yes)
+(GT (FlagLT_ULT) yes no) -> (First no yes)
+(GT (FlagLT_UGT) yes no) -> (First no yes)
+(GT (FlagGT_ULT) yes no) -> (First yes no)
+(GT (FlagGT_UGT) yes no) -> (First yes no)
+
+(GE (FlagEQ) yes no) -> (First yes no)
+(GE (FlagLT_ULT) yes no) -> (First no yes)
+(GE (FlagLT_UGT) yes no) -> (First no yes)
+(GE (FlagGT_ULT) yes no) -> (First yes no)
+(GE (FlagGT_UGT) yes no) -> (First yes no)
+
+(ULT (FlagEQ) yes no) -> (First no yes)
+(ULT (FlagLT_ULT) yes no) -> (First yes no)
+(ULT (FlagLT_UGT) yes no) -> (First no yes)
+(ULT (FlagGT_ULT) yes no) -> (First yes no)
+(ULT (FlagGT_UGT) yes no) -> (First no yes)
+
+(ULE (FlagEQ) yes no) -> (First yes no)
+(ULE (FlagLT_ULT) yes no) -> (First yes no)
+(ULE (FlagLT_UGT) yes no) -> (First no yes)
+(ULE (FlagGT_ULT) yes no) -> (First yes no)
+(ULE (FlagGT_UGT) yes no) -> (First no yes)
+
+(UGT (FlagEQ) yes no) -> (First no yes)
+(UGT (FlagLT_ULT) yes no) -> (First no yes)
+(UGT (FlagLT_UGT) yes no) -> (First yes no)
+(UGT (FlagGT_ULT) yes no) -> (First no yes)
+(UGT (FlagGT_UGT) yes no) -> (First yes no)
+
+(UGE (FlagEQ) yes no) -> (First yes no)
+(UGE (FlagLT_ULT) yes no) -> (First no yes)
+(UGE (FlagLT_UGT) yes no) -> (First yes no)
+(UGE (FlagGT_ULT) yes no) -> (First no yes)
+(UGE (FlagGT_UGT) yes no) -> (First yes no)
+
+(Z (MOVDconst [0]) yes no) -> (First yes no)
+(Z (MOVDconst [c]) yes no) && c != 0 -> (First no yes)
+(NZ (MOVDconst [0]) yes no) -> (First no yes)
+(NZ (MOVDconst [c]) yes no) && c != 0 -> (First yes no)
+(ZW (MOVDconst [c]) yes no) && int32(c) == 0 -> (First yes no)
+(ZW (MOVDconst [c]) yes no) && int32(c) != 0 -> (First no yes)
+(NZW (MOVDconst [c]) yes no) && int32(c) == 0 -> (First no yes)
+(NZW (MOVDconst [c]) yes no) && int32(c) != 0 -> (First yes no)
 
 // absorb InvertFlags into branches
 (LT (InvertFlags cmp) yes no) -> (GT cmp yes no)
diff --git a/src/cmd/compile/internal/ssa/gen/ARM64Ops.go b/src/cmd/compile/internal/ssa/gen/ARM64Ops.go
index d4de904a24..e1f045fcf8 100644
--- a/src/cmd/compile/internal/ssa/gen/ARM64Ops.go
+++ b/src/cmd/compile/internal/ssa/gen/ARM64Ops.go
@@ -678,26 +678,26 @@ func init() {
 	}
 
 	blocks := []blockData{
-		{name: "EQ"},
-		{name: "NE"},
-		{name: "LT"},
-		{name: "LE"},
-		{name: "GT"},
-		{name: "GE"},
-		{name: "ULT"},
-		{name: "ULE"},
-		{name: "UGT"},
-		{name: "UGE"},
-		{name: "Z"},    // Control == 0 (take a register instead of flags)
-		{name: "NZ"},   // Control != 0
-		{name: "ZW"},   // Control == 0, 32-bit
-		{name: "NZW"},  // Control != 0, 32-bit
-		{name: "TBZ"},  // Control & (1 << Aux.(int64)) == 0
-		{name: "TBNZ"}, // Control & (1 << Aux.(int64)) != 0
-		{name: "FLT"},
-		{name: "FLE"},
-		{name: "FGT"},
-		{name: "FGE"},
+		{name: "EQ", controls: 1},
+		{name: "NE", controls: 1},
+		{name: "LT", controls: 1},
+		{name: "LE", controls: 1},
+		{name: "GT", controls: 1},
+		{name: "GE", controls: 1},
+		{name: "ULT", controls: 1},
+		{name: "ULE", controls: 1},
+		{name: "UGT", controls: 1},
+		{name: "UGE", controls: 1},
+		{name: "Z", controls: 1},    // Control == 0 (take a register instead of flags)
+		{name: "NZ", controls: 1},   // Control != 0
+		{name: "ZW", controls: 1},   // Control == 0, 32-bit
+		{name: "NZW", controls: 1},  // Control != 0, 32-bit
+		{name: "TBZ", controls: 1},  // Control & (1 << Aux.(int64)) == 0
+		{name: "TBNZ", controls: 1}, // Control & (1 << Aux.(int64)) != 0
+		{name: "FLT", controls: 1},
+		{name: "FLE", controls: 1},
+		{name: "FGT", controls: 1},
+		{name: "FGE", controls: 1},
 	}
 
 	archs = append(archs, arch{
diff --git a/src/cmd/compile/internal/ssa/gen/ARMOps.go b/src/cmd/compile/internal/ssa/gen/ARMOps.go
index eb0f671d0d..2983870486 100644
--- a/src/cmd/compile/internal/ssa/gen/ARMOps.go
+++ b/src/cmd/compile/internal/ssa/gen/ARMOps.go
@@ -568,16 +568,16 @@ func init() {
 	}
 
 	blocks := []blockData{
-		{name: "EQ"},
-		{name: "NE"},
-		{name: "LT"},
-		{name: "LE"},
-		{name: "GT"},
-		{name: "GE"},
-		{name: "ULT"},
-		{name: "ULE"},
-		{name: "UGT"},
-		{name: "UGE"},
+		{name: "EQ", controls: 1},
+		{name: "NE", controls: 1},
+		{name: "LT", controls: 1},
+		{name: "LE", controls: 1},
+		{name: "GT", controls: 1},
+		{name: "GE", controls: 1},
+		{name: "ULT", controls: 1},
+		{name: "ULE", controls: 1},
+		{name: "UGT", controls: 1},
+		{name: "UGE", controls: 1},
 	}
 
 	archs = append(archs, arch{
diff --git a/src/cmd/compile/internal/ssa/gen/MIPS.rules b/src/cmd/compile/internal/ssa/gen/MIPS.rules
index 2b3ae5d93e..2932f13ac7 100644
--- a/src/cmd/compile/internal/ssa/gen/MIPS.rules
+++ b/src/cmd/compile/internal/ssa/gen/MIPS.rules
@@ -687,18 +687,18 @@
 (SGTUconst [c] (SRLconst _ [d])) && uint32(d) <= 31 && 0xffffffff>>uint32(d) < uint32(c) -> (MOVWconst [1])
 
 // absorb constants into branches
-(EQ  (MOVWconst [0]) yes no) -> (First nil yes no)
-(EQ  (MOVWconst [c]) yes no) && c != 0 -> (First nil no yes)
-(NE  (MOVWconst [0]) yes no) -> (First nil no yes)
-(NE  (MOVWconst [c]) yes no) && c != 0 -> (First nil yes no)
-(LTZ (MOVWconst [c]) yes no) && int32(c) <  0 -> (First nil yes no)
-(LTZ (MOVWconst [c]) yes no) && int32(c) >= 0 -> (First nil no yes)
-(LEZ (MOVWconst [c]) yes no) && int32(c) <= 0 -> (First nil yes no)
-(LEZ (MOVWconst [c]) yes no) && int32(c) >  0 -> (First nil no yes)
-(GTZ (MOVWconst [c]) yes no) && int32(c) >  0 -> (First nil yes no)
-(GTZ (MOVWconst [c]) yes no) && int32(c) <= 0 -> (First nil no yes)
-(GEZ (MOVWconst [c]) yes no) && int32(c) >= 0 -> (First nil yes no)
-(GEZ (MOVWconst [c]) yes no) && int32(c) <  0 -> (First nil no yes)
+(EQ  (MOVWconst [0]) yes no) -> (First yes no)
+(EQ  (MOVWconst [c]) yes no) && c != 0 -> (First no yes)
+(NE  (MOVWconst [0]) yes no) -> (First no yes)
+(NE  (MOVWconst [c]) yes no) && c != 0 -> (First yes no)
+(LTZ (MOVWconst [c]) yes no) && int32(c) <  0 -> (First yes no)
+(LTZ (MOVWconst [c]) yes no) && int32(c) >= 0 -> (First no yes)
+(LEZ (MOVWconst [c]) yes no) && int32(c) <= 0 -> (First yes no)
+(LEZ (MOVWconst [c]) yes no) && int32(c) >  0 -> (First no yes)
+(GTZ (MOVWconst [c]) yes no) && int32(c) >  0 -> (First yes no)
+(GTZ (MOVWconst [c]) yes no) && int32(c) <= 0 -> (First no yes)
+(GEZ (MOVWconst [c]) yes no) && int32(c) >= 0 -> (First yes no)
+(GEZ (MOVWconst [c]) yes no) && int32(c) <  0 -> (First no yes)
 
 // conditional move
 (CMOVZ _ f (MOVWconst [0])) -> f
diff --git a/src/cmd/compile/internal/ssa/gen/MIPS64.rules b/src/cmd/compile/internal/ssa/gen/MIPS64.rules
index 69fe4b721e..a39241d160 100644
--- a/src/cmd/compile/internal/ssa/gen/MIPS64.rules
+++ b/src/cmd/compile/internal/ssa/gen/MIPS64.rules
@@ -694,15 +694,15 @@
 (SGTUconst [c] (SRLVconst _ [d])) && 0 < d && d <= 63 && 0xffffffffffffffff>>uint64(d) < uint64(c) -> (MOVVconst [1])
 
 // absorb constants into branches
-(EQ  (MOVVconst [0]) yes no) -> (First nil yes no)
-(EQ  (MOVVconst [c]) yes no) && c != 0 -> (First nil no yes)
-(NE  (MOVVconst [0]) yes no) -> (First nil no yes)
-(NE  (MOVVconst [c]) yes no) && c != 0 -> (First nil yes no)
-(LTZ (MOVVconst [c]) yes no) && c <  0 -> (First nil yes no)
-(LTZ (MOVVconst [c]) yes no) && c >= 0 -> (First nil no yes)
-(LEZ (MOVVconst [c]) yes no) && c <= 0 -> (First nil yes no)
-(LEZ (MOVVconst [c]) yes no) && c >  0 -> (First nil no yes)
-(GTZ (MOVVconst [c]) yes no) && c >  0 -> (First nil yes no)
-(GTZ (MOVVconst [c]) yes no) && c <= 0 -> (First nil no yes)
-(GEZ (MOVVconst [c]) yes no) && c >= 0 -> (First nil yes no)
-(GEZ (MOVVconst [c]) yes no) && c <  0 -> (First nil no yes)
+(EQ  (MOVVconst [0]) yes no) -> (First yes no)
+(EQ  (MOVVconst [c]) yes no) && c != 0 -> (First no yes)
+(NE  (MOVVconst [0]) yes no) -> (First no yes)
+(NE  (MOVVconst [c]) yes no) && c != 0 -> (First yes no)
+(LTZ (MOVVconst [c]) yes no) && c <  0 -> (First yes no)
+(LTZ (MOVVconst [c]) yes no) && c >= 0 -> (First no yes)
+(LEZ (MOVVconst [c]) yes no) && c <= 0 -> (First yes no)
+(LEZ (MOVVconst [c]) yes no) && c >  0 -> (First no yes)
+(GTZ (MOVVconst [c]) yes no) && c >  0 -> (First yes no)
+(GTZ (MOVVconst [c]) yes no) && c <= 0 -> (First no yes)
+(GEZ (MOVVconst [c]) yes no) && c >= 0 -> (First yes no)
+(GEZ (MOVVconst [c]) yes no) && c <  0 -> (First no yes)
diff --git a/src/cmd/compile/internal/ssa/gen/MIPS64Ops.go b/src/cmd/compile/internal/ssa/gen/MIPS64Ops.go
index e0a920f23d..184b119f89 100644
--- a/src/cmd/compile/internal/ssa/gen/MIPS64Ops.go
+++ b/src/cmd/compile/internal/ssa/gen/MIPS64Ops.go
@@ -453,14 +453,14 @@ func init() {
 	}
 
 	blocks := []blockData{
-		{name: "EQ"},
-		{name: "NE"},
-		{name: "LTZ"}, // < 0
-		{name: "LEZ"}, // <= 0
-		{name: "GTZ"}, // > 0
-		{name: "GEZ"}, // >= 0
-		{name: "FPT"}, // FP flag is true
-		{name: "FPF"}, // FP flag is false
+		{name: "EQ", controls: 1},
+		{name: "NE", controls: 1},
+		{name: "LTZ", controls: 1}, // < 0
+		{name: "LEZ", controls: 1}, // <= 0
+		{name: "GTZ", controls: 1}, // > 0
+		{name: "GEZ", controls: 1}, // >= 0
+		{name: "FPT", controls: 1}, // FP flag is true
+		{name: "FPF", controls: 1}, // FP flag is false
 	}
 
 	archs = append(archs, arch{
diff --git a/src/cmd/compile/internal/ssa/gen/MIPSOps.go b/src/cmd/compile/internal/ssa/gen/MIPSOps.go
index 729cc05102..0f7b985e06 100644
--- a/src/cmd/compile/internal/ssa/gen/MIPSOps.go
+++ b/src/cmd/compile/internal/ssa/gen/MIPSOps.go
@@ -409,14 +409,14 @@ func init() {
 	}
 
 	blocks := []blockData{
-		{name: "EQ"},
-		{name: "NE"},
-		{name: "LTZ"}, // < 0
-		{name: "LEZ"}, // <= 0
-		{name: "GTZ"}, // > 0
-		{name: "GEZ"}, // >= 0
-		{name: "FPT"}, // FP flag is true
-		{name: "FPF"}, // FP flag is false
+		{name: "EQ", controls: 1},
+		{name: "NE", controls: 1},
+		{name: "LTZ", controls: 1}, // < 0
+		{name: "LEZ", controls: 1}, // <= 0
+		{name: "GTZ", controls: 1}, // > 0
+		{name: "GEZ", controls: 1}, // >= 0
+		{name: "FPT", controls: 1}, // FP flag is true
+		{name: "FPF", controls: 1}, // FP flag is false
 	}
 
 	archs = append(archs, arch{
diff --git a/src/cmd/compile/internal/ssa/gen/PPC64.rules b/src/cmd/compile/internal/ssa/gen/PPC64.rules
index b247a0b99e..59cce4ed57 100644
--- a/src/cmd/compile/internal/ssa/gen/PPC64.rules
+++ b/src/cmd/compile/internal/ssa/gen/PPC64.rules
@@ -447,29 +447,29 @@
 (NE (CMPWconst [0] (ANDconst [c] x)) yes no) -> (NE (ANDCCconst [c] x) yes no)
 
 // absorb flag constants into branches
-(EQ (FlagEQ) yes no) -> (First nil yes no)
-(EQ (FlagLT) yes no) -> (First nil no yes)
-(EQ (FlagGT) yes no) -> (First nil no yes)
+(EQ (FlagEQ) yes no) -> (First yes no)
+(EQ (FlagLT) yes no) -> (First no yes)
+(EQ (FlagGT) yes no) -> (First no yes)
 
-(NE (FlagEQ) yes no) -> (First nil no yes)
-(NE (FlagLT) yes no) -> (First nil yes no)
-(NE (FlagGT) yes no) -> (First nil yes no)
+(NE (FlagEQ) yes no) -> (First no yes)
+(NE (FlagLT) yes no) -> (First yes no)
+(NE (FlagGT) yes no) -> (First yes no)
 
-(LT (FlagEQ) yes no) -> (First nil no yes)
-(LT (FlagLT) yes no) -> (First nil yes no)
-(LT (FlagGT) yes no) -> (First nil no yes)
+(LT (FlagEQ) yes no) -> (First no yes)
+(LT (FlagLT) yes no) -> (First yes no)
+(LT (FlagGT) yes no) -> (First no yes)
 
-(LE (FlagEQ) yes no) -> (First nil yes no)
-(LE (FlagLT) yes no) -> (First nil yes no)
-(LE (FlagGT) yes no) -> (First nil no yes)
+(LE (FlagEQ) yes no) -> (First yes no)
+(LE (FlagLT) yes no) -> (First yes no)
+(LE (FlagGT) yes no) -> (First no yes)
 
-(GT (FlagEQ) yes no) -> (First nil no yes)
-(GT (FlagLT) yes no) -> (First nil no yes)
-(GT (FlagGT) yes no) -> (First nil yes no)
+(GT (FlagEQ) yes no) -> (First no yes)
+(GT (FlagLT) yes no) -> (First no yes)
+(GT (FlagGT) yes no) -> (First yes no)
 
-(GE (FlagEQ) yes no) -> (First nil yes no)
-(GE (FlagLT) yes no) -> (First nil no yes)
-(GE (FlagGT) yes no) -> (First nil yes no)
+(GE (FlagEQ) yes no) -> (First yes no)
+(GE (FlagLT) yes no) -> (First no yes)
+(GE (FlagGT) yes no) -> (First yes no)
 
 // absorb InvertFlags into branches
 (LT (InvertFlags cmp) yes no) -> (GT cmp yes no)
diff --git a/src/cmd/compile/internal/ssa/gen/PPC64Ops.go b/src/cmd/compile/internal/ssa/gen/PPC64Ops.go
index 138fe23ca8..5505db5222 100644
--- a/src/cmd/compile/internal/ssa/gen/PPC64Ops.go
+++ b/src/cmd/compile/internal/ssa/gen/PPC64Ops.go
@@ -585,16 +585,16 @@ func init() {
 	}
 
 	blocks := []blockData{
-		{name: "EQ"},
-		{name: "NE"},
-		{name: "LT"},
-		{name: "LE"},
-		{name: "GT"},
-		{name: "GE"},
-		{name: "FLT"},
-		{name: "FLE"},
-		{name: "FGT"},
-		{name: "FGE"},
+		{name: "EQ", controls: 1},
+		{name: "NE", controls: 1},
+		{name: "LT", controls: 1},
+		{name: "LE", controls: 1},
+		{name: "GT", controls: 1},
+		{name: "GE", controls: 1},
+		{name: "FLT", controls: 1},
+		{name: "FLE", controls: 1},
+		{name: "FGT", controls: 1},
+		{name: "FGE", controls: 1},
 	}
 
 	archs = append(archs, arch{
diff --git a/src/cmd/compile/internal/ssa/gen/S390X.rules b/src/cmd/compile/internal/ssa/gen/S390X.rules
index e30312e454..83c3b358b5 100644
--- a/src/cmd/compile/internal/ssa/gen/S390X.rules
+++ b/src/cmd/compile/internal/ssa/gen/S390X.rules
@@ -976,15 +976,15 @@
 (CMP(W|W|WU|WU)const (MOV(W|WZ|W|WZ)reg x) [c]) -> (CMP(W|W|WU|WU)const x [c])
 
 // Absorb flag constants into branches.
-(BRC {c} (FlagEQ) yes no) && c.(s390x.CCMask) & s390x.Equal     != 0 -> (First nil yes no)
-(BRC {c} (FlagLT) yes no) && c.(s390x.CCMask) & s390x.Less      != 0 -> (First nil yes no)
-(BRC {c} (FlagGT) yes no) && c.(s390x.CCMask) & s390x.Greater   != 0 -> (First nil yes no)
-(BRC {c} (FlagOV) yes no) && c.(s390x.CCMask) & s390x.Unordered != 0 -> (First nil yes no)
-
-(BRC {c} (FlagEQ) yes no) && c.(s390x.CCMask) & s390x.Equal     == 0 -> (First nil no yes)
-(BRC {c} (FlagLT) yes no) && c.(s390x.CCMask) & s390x.Less      == 0 -> (First nil no yes)
-(BRC {c} (FlagGT) yes no) && c.(s390x.CCMask) & s390x.Greater   == 0 -> (First nil no yes)
-(BRC {c} (FlagOV) yes no) && c.(s390x.CCMask) & s390x.Unordered == 0 -> (First nil no yes)
+(BRC {c} (FlagEQ) yes no) && c.(s390x.CCMask) & s390x.Equal     != 0 -> (First yes no)
+(BRC {c} (FlagLT) yes no) && c.(s390x.CCMask) & s390x.Less      != 0 -> (First yes no)
+(BRC {c} (FlagGT) yes no) && c.(s390x.CCMask) & s390x.Greater   != 0 -> (First yes no)
+(BRC {c} (FlagOV) yes no) && c.(s390x.CCMask) & s390x.Unordered != 0 -> (First yes no)
+
+(BRC {c} (FlagEQ) yes no) && c.(s390x.CCMask) & s390x.Equal     == 0 -> (First no yes)
+(BRC {c} (FlagLT) yes no) && c.(s390x.CCMask) & s390x.Less      == 0 -> (First no yes)
+(BRC {c} (FlagGT) yes no) && c.(s390x.CCMask) & s390x.Greater   == 0 -> (First no yes)
+(BRC {c} (FlagOV) yes no) && c.(s390x.CCMask) & s390x.Unordered == 0 -> (First no yes)
 
 // Absorb flag constants into SETxx ops.
 (LOCGR {c} _ x (FlagEQ)) && c.(s390x.CCMask) & s390x.Equal     != 0 -> x
diff --git a/src/cmd/compile/internal/ssa/gen/S390XOps.go b/src/cmd/compile/internal/ssa/gen/S390XOps.go
index c8e4a22846..d34c250cf6 100644
--- a/src/cmd/compile/internal/ssa/gen/S390XOps.go
+++ b/src/cmd/compile/internal/ssa/gen/S390XOps.go
@@ -708,7 +708,7 @@ func init() {
 	}
 
 	var S390Xblocks = []blockData{
-		{name: "BRC"}, // aux is condition code mask (s390x.CCMask)
+		{name: "BRC", controls: 1}, // aux is condition code mask (s390x.CCMask)
 	}
 
 	archs = append(archs, arch{
diff --git a/src/cmd/compile/internal/ssa/gen/generic.rules b/src/cmd/compile/internal/ssa/gen/generic.rules
index 8696464a70..1503a5da6c 100644
--- a/src/cmd/compile/internal/ssa/gen/generic.rules
+++ b/src/cmd/compile/internal/ssa/gen/generic.rules
@@ -879,8 +879,8 @@
 (NilCheck (GetG mem) mem) -> mem
 
 (If (Not cond) yes no) -> (If cond no yes)
-(If (ConstBool [c]) yes no) && c == 1 -> (First nil yes no)
-(If (ConstBool [c]) yes no) && c == 0 -> (First nil no yes)
+(If (ConstBool [c]) yes no) && c == 1 -> (First yes no)
+(If (ConstBool [c]) yes no) && c == 0 -> (First no yes)
 
 // Get rid of Convert ops for pointer arithmetic on unsafe.Pointer.
 (Convert (Add(64|32) (Convert ptr mem) off) mem) -> (Add(64|32) ptr off)
diff --git a/src/cmd/compile/internal/ssa/gen/genericOps.go b/src/cmd/compile/internal/ssa/gen/genericOps.go
index 3ca773b595..df0dd8cabc 100644
--- a/src/cmd/compile/internal/ssa/gen/genericOps.go
+++ b/src/cmd/compile/internal/ssa/gen/genericOps.go
@@ -557,24 +557,22 @@ var genericOps = []opData{
 	{name: "Clobber", argLength: 0, typ: "Void", aux: "SymOff", symEffect: "None"}, // write an invalid pointer value to the given pointer slot of a stack variable
 }
 
-//     kind           control    successors       implicit exit
+//     kind          controls        successors   implicit exit
 //   ----------------------------------------------------------
-//     Exit        return mem                []             yes
-//      Ret        return mem                []             yes
-//   RetJmp        return mem                []             yes
-//    Plain               nil            [next]
-//       If   a boolean Value      [then, else]
-//     Call               mem            [next]             yes  (control opcode should be OpCall or OpStaticCall)
-//    Check              void            [next]             yes  (control opcode should be Op{Lowered}NilCheck)
-//    First               nil    [always,never]
+//     Exit      [return mem]                []             yes
+//      Ret      [return mem]                []             yes
+//   RetJmp      [return mem]                []             yes
+//    Plain                []            [next]
+//       If   [boolean Value]      [then, else]
+//    First                []   [always, never]
 
 var genericBlocks = []blockData{
-	{name: "Plain"},  // a single successor
-	{name: "If"},     // 2 successors, if control goto Succs[0] else goto Succs[1]
-	{name: "Defer"},  // 2 successors, Succs[0]=defer queued, Succs[1]=defer recovered. control is call op (of memory type)
-	{name: "Ret"},    // no successors, control value is memory result
-	{name: "RetJmp"}, // no successors, jumps to b.Aux.(*gc.Sym)
-	{name: "Exit"},   // no successors, control value generates a panic
+	{name: "Plain"},               // a single successor
+	{name: "If", controls: 1},     // if Controls[0] goto Succs[0] else goto Succs[1]
+	{name: "Defer", controls: 1},  // Succs[0]=defer queued, Succs[1]=defer recovered. Controls[0] is call op (of memory type)
+	{name: "Ret", controls: 1},    // no successors, Controls[0] value is memory result
+	{name: "RetJmp", controls: 1}, // no successors, Controls[0] value is memory result, jumps to b.Aux.(*gc.Sym)
+	{name: "Exit", controls: 1},   // no successors, Controls[0] value generates a panic
 
 	// transient block state used for dead code removal
 	{name: "First"}, // 2 successors, always takes the first one (second is dead)
diff --git a/src/cmd/compile/internal/ssa/gen/main.go b/src/cmd/compile/internal/ssa/gen/main.go
index decc583431..eef72284b9 100644
--- a/src/cmd/compile/internal/ssa/gen/main.go
+++ b/src/cmd/compile/internal/ssa/gen/main.go
@@ -68,7 +68,8 @@ type opData struct {
 }
 
 type blockData struct {
-	name string
+	name     string // the suffix for this block ("EQ", "LT", etc.)
+	controls int    // the number of control values this type of block requires
 }
 
 type regInfo struct {
diff --git a/src/cmd/compile/internal/ssa/gen/rulegen.go b/src/cmd/compile/internal/ssa/gen/rulegen.go
index 7c02778181..5c4c5ef1af 100644
--- a/src/cmd/compile/internal/ssa/gen/rulegen.go
+++ b/src/cmd/compile/internal/ssa/gen/rulegen.go
@@ -238,7 +238,6 @@ func genRulesSuffix(arch arch, suff string) {
 	fn = &Func{kind: "Block"}
 	fn.add(declf("config", "b.Func.Config"))
 	fn.add(declf("typ", "&b.Func.Config.Types"))
-	fn.add(declf("v", "b.Control"))
 
 	sw = &Switch{expr: exprf("b.Kind")}
 	ops = ops[:0]
@@ -247,9 +246,10 @@ func genRulesSuffix(arch arch, suff string) {
 	}
 	sort.Strings(ops)
 	for _, op := range ops {
-		swc := &Case{expr: exprf("%s", blockName(op, arch))}
+		name, data := getBlockInfo(op, arch)
+		swc := &Case{expr: exprf("%s", name)}
 		for _, rule := range blockrules[op] {
-			swc.add(genBlockRewrite(rule, arch))
+			swc.add(genBlockRewrite(rule, arch, data))
 		}
 		sw.add(swc)
 	}
@@ -593,11 +593,7 @@ func fprint(w io.Writer, n Node) {
 			fmt.Fprintf(w, "// cond: %s\n", n.cond)
 		}
 		fmt.Fprintf(w, "// result: %s\n", n.result)
-		if n.checkOp != "" {
-			fmt.Fprintf(w, "for v.Op == %s {\n", n.checkOp)
-		} else {
-			fmt.Fprintf(w, "for {\n")
-		}
+		fmt.Fprintf(w, "for %s {\n", n.check)
 		for _, n := range n.list {
 			fprint(w, n)
 		}
@@ -700,7 +696,7 @@ type (
 	RuleRewrite struct {
 		bodyBase
 		match, cond, result string // top comments
-		checkOp             string
+		check               string // top-level boolean expression
 
 		alloc int    // for unique var names
 		loc   string // file name & line number of the original rule
@@ -750,18 +746,39 @@ func breakf(format string, a ...interface{}) *CondBreak {
 	return &CondBreak{exprf(format, a...)}
 }
 
-func genBlockRewrite(rule Rule, arch arch) *RuleRewrite {
+func genBlockRewrite(rule Rule, arch arch, data blockData) *RuleRewrite {
 	rr := &RuleRewrite{loc: rule.loc}
 	rr.match, rr.cond, rr.result = rule.parse()
 	_, _, _, aux, s := extract(rr.match) // remove parens, then split
 
-	// check match of control value
-	pos := ""
-	if s[0] != "nil" {
-		if strings.Contains(s[0], "(") {
-			pos, rr.checkOp = genMatch0(rr, arch, s[0], "v")
+	// check match of control values
+	if len(s) < data.controls {
+		log.Fatalf("incorrect number of arguments in %s, got %v wanted at least %v", rule, len(s), data.controls)
+	}
+	controls := s[:data.controls]
+	pos := make([]string, data.controls)
+	for i, arg := range controls {
+		if strings.Contains(arg, "(") {
+			// TODO: allow custom names?
+			cname := fmt.Sprintf("b.Controls[%v]", i)
+			vname := fmt.Sprintf("v_%v", i)
+			rr.add(declf(vname, cname))
+			p, op := genMatch0(rr, arch, arg, vname)
+			if op != "" {
+				check := fmt.Sprintf("%s.Op == %s", cname, op)
+				if rr.check == "" {
+					rr.check = check
+				} else {
+					rr.check = rr.check + " && " + check
+				}
+			}
+			if p == "" {
+				p = vname + ".Pos"
+			}
+			pos[i] = p
 		} else {
-			rr.add(declf(s[0], "b.Control"))
+			rr.add(declf(arg, "b.Controls[%v]", i))
+			pos[i] = arg + ".Pos"
 		}
 	}
 	if aux != "" {
@@ -773,10 +790,14 @@ func genBlockRewrite(rule Rule, arch arch) *RuleRewrite {
 
 	// Rule matches. Generate result.
 	outop, _, _, aux, t := extract(rr.result) // remove parens, then split
-	newsuccs := t[1:]
+	_, outdata := getBlockInfo(outop, arch)
+	if len(t) < outdata.controls {
+		log.Fatalf("incorrect number of output arguments in %s, got %v wanted at least %v", rule, len(s), outdata.controls)
+	}
 
 	// Check if newsuccs is the same set as succs.
-	succs := s[1:]
+	succs := s[data.controls:]
+	newsuccs := t[outdata.controls:]
 	m := map[string]bool{}
 	for _, succ := range succs {
 		if m[succ] {
@@ -794,15 +815,23 @@ func genBlockRewrite(rule Rule, arch arch) *RuleRewrite {
 		log.Fatalf("unmatched successors %v in %s", m, rule)
 	}
 
-	rr.add(stmtf("b.Kind = %s", blockName(outop, arch)))
-	if t[0] == "nil" {
-		rr.add(stmtf("b.SetControl(nil)"))
-	} else {
-		if pos == "" {
-			pos = "v.Pos"
+	blockName, _ := getBlockInfo(outop, arch)
+	rr.add(stmtf("b.Kind = %s", blockName))
+	rr.add(stmtf("b.ResetControls()"))
+	for i, control := range t[:outdata.controls] {
+		// Select a source position for any new control values.
+		// TODO: does it always make sense to use the source position
+		// of the original control values or should we be using the
+		// block's source position in some cases?
+		newpos := "b.Pos" // default to block's source position
+		if i < len(pos) && pos[i] != "" {
+			// Use the previous control value's source position.
+			newpos = pos[i]
 		}
-		v := genResult0(rr, arch, t[0], false, false, pos)
-		rr.add(stmtf("b.SetControl(%s)", v))
+
+		// Generate a new control value (or copy an existing value).
+		v := genResult0(rr, arch, control, false, false, newpos)
+		rr.add(stmtf("b.AddControl(%s)", v))
 	}
 	if aux != "" {
 		rr.add(stmtf("b.Aux = %s", aux))
@@ -1164,13 +1193,19 @@ func parseValue(val string, arch arch, loc string) (op opData, oparch, typ, auxi
 	return
 }
 
-func blockName(name string, arch arch) string {
+func getBlockInfo(op string, arch arch) (name string, data blockData) {
 	for _, b := range genericBlocks {
-		if b.name == name {
-			return "Block" + name
+		if b.name == op {
+			return "Block" + op, b
+		}
+	}
+	for _, b := range arch.blocks {
+		if b.name == op {
+			return "Block" + arch.name + op, b
 		}
 	}
-	return "Block" + arch.name + name
+	log.Fatalf("could not find block data for %s", op)
+	panic("unreachable")
 }
 
 // typeName returns the string to use to generate a type.
diff --git a/src/cmd/compile/internal/ssa/html.go b/src/cmd/compile/internal/ssa/html.go
index a1b718096d..1e76a673ef 100644
--- a/src/cmd/compile/internal/ssa/html.go
+++ b/src/cmd/compile/internal/ssa/html.go
@@ -846,8 +846,8 @@ func (b *Block) LongHTML() string {
 	if b.Aux != nil {
 		s += html.EscapeString(fmt.Sprintf(" {%v}", b.Aux))
 	}
-	if b.Control != nil {
-		s += fmt.Sprintf(" %s", b.Control.HTML())
+	for _, c := range b.ControlValues() {
+		s += fmt.Sprintf(" %s", c.HTML())
 	}
 	if len(b.Succs) > 0 {
 		s += " &#8594;" // right arrow
diff --git a/src/cmd/compile/internal/ssa/loopbce.go b/src/cmd/compile/internal/ssa/loopbce.go
index bfa2597493..d53014943d 100644
--- a/src/cmd/compile/internal/ssa/loopbce.go
+++ b/src/cmd/compile/internal/ssa/loopbce.go
@@ -96,17 +96,18 @@ func findIndVar(f *Func) []indVar {
 		// Check thet the control if it either ind </<= max or max >/>= ind.
 		// TODO: Handle 32-bit comparisons.
 		// TODO: Handle unsigned comparisons?
-		switch b.Control.Op {
+		c := b.Controls[0]
+		switch c.Op {
 		case OpLeq64:
 			flags |= indVarMaxInc
 			fallthrough
 		case OpLess64:
-			ind, max = b.Control.Args[0], b.Control.Args[1]
+			ind, max = c.Args[0], c.Args[1]
 		case OpGeq64:
 			flags |= indVarMaxInc
 			fallthrough
 		case OpGreater64:
-			ind, max = b.Control.Args[1], b.Control.Args[0]
+			ind, max = c.Args[1], c.Args[0]
 		default:
 			continue
 		}
@@ -207,7 +208,7 @@ func findIndVar(f *Func) []indVar {
 			}
 			// Handle induction variables of these forms.
 			// KNN is known-not-negative.
-			// SIGNED ARITHMETIC ONLY. (see switch on b.Control.Op above)
+			// SIGNED ARITHMETIC ONLY. (see switch on c above)
 			// Possibilities for KNN are len and cap; perhaps we can infer others.
 			// for i := 0; i <= KNN-k    ; i += k
 			// for i := 0; i <  KNN-(k-1); i += k
diff --git a/src/cmd/compile/internal/ssa/nilcheck.go b/src/cmd/compile/internal/ssa/nilcheck.go
index 54c9c9d7de..009c68afa1 100644
--- a/src/cmd/compile/internal/ssa/nilcheck.go
+++ b/src/cmd/compile/internal/ssa/nilcheck.go
@@ -99,9 +99,8 @@ func nilcheckelim(f *Func) {
 			// First, see if we're dominated by an explicit nil check.
 			if len(b.Preds) == 1 {
 				p := b.Preds[0].b
-				if p.Kind == BlockIf && p.Control.Op == OpIsNonNil && p.Succs[0].b == b {
-					ptr := p.Control.Args[0]
-					if !nonNilValues[ptr.ID] {
+				if p.Kind == BlockIf && p.Controls[0].Op == OpIsNonNil && p.Succs[0].b == b {
+					if ptr := p.Controls[0].Args[0]; !nonNilValues[ptr.ID] {
 						nonNilValues[ptr.ID] = true
 						work = append(work, bp{op: ClearPtr, ptr: ptr})
 					}
diff --git a/src/cmd/compile/internal/ssa/nilcheck_test.go b/src/cmd/compile/internal/ssa/nilcheck_test.go
index b2f5cae088..e984069022 100644
--- a/src/cmd/compile/internal/ssa/nilcheck_test.go
+++ b/src/cmd/compile/internal/ssa/nilcheck_test.go
@@ -59,7 +59,7 @@ func ptrn(n int) string   { return "p" + strconv.Itoa(n) }
 func booln(n int) string  { return "c" + strconv.Itoa(n) }
 
 func isNilCheck(b *Block) bool {
-	return b.Kind == BlockIf && b.Control.Op == OpIsNonNil
+	return b.Kind == BlockIf && b.Controls[0].Op == OpIsNonNil
 }
 
 // TestNilcheckSimple verifies that a second repeated nilcheck is removed.
diff --git a/src/cmd/compile/internal/ssa/phiopt.go b/src/cmd/compile/internal/ssa/phiopt.go
index 60c8e58bd2..1840d6d54e 100644
--- a/src/cmd/compile/internal/ssa/phiopt.go
+++ b/src/cmd/compile/internal/ssa/phiopt.go
@@ -79,7 +79,7 @@ func phiopt(f *Func) {
 				if v.Args[reverse].AuxInt != v.Args[1-reverse].AuxInt {
 					ops := [2]Op{OpNot, OpCopy}
 					v.reset(ops[v.Args[reverse].AuxInt])
-					v.AddArg(b0.Control)
+					v.AddArg(b0.Controls[0])
 					if f.pass.debug > 0 {
 						f.Warnl(b.Pos, "converted OpPhi to %v", v.Op)
 					}
@@ -95,7 +95,7 @@ func phiopt(f *Func) {
 			if v.Args[reverse].Op == OpConstBool && v.Args[reverse].AuxInt == 1 {
 				if tmp := v.Args[1-reverse]; sdom.isAncestorEq(tmp.Block, b) {
 					v.reset(OpOrB)
-					v.SetArgs2(b0.Control, tmp)
+					v.SetArgs2(b0.Controls[0], tmp)
 					if f.pass.debug > 0 {
 						f.Warnl(b.Pos, "converted OpPhi to %v", v.Op)
 					}
@@ -111,7 +111,7 @@ func phiopt(f *Func) {
 			if v.Args[1-reverse].Op == OpConstBool && v.Args[1-reverse].AuxInt == 0 {
 				if tmp := v.Args[reverse]; sdom.isAncestorEq(tmp.Block, b) {
 					v.reset(OpAndB)
-					v.SetArgs2(b0.Control, tmp)
+					v.SetArgs2(b0.Controls[0], tmp)
 					if f.pass.debug > 0 {
 						f.Warnl(b.Pos, "converted OpPhi to %v", v.Op)
 					}
@@ -161,7 +161,7 @@ func phioptint(v *Value, b0 *Block, reverse int) {
 		v.Fatalf("bad int size %d", v.Type.Size())
 	}
 
-	a := b0.Control
+	a := b0.Controls[0]
 	if negate {
 		a = v.Block.NewValue1(v.Pos, OpNot, a.Type, a)
 	}
diff --git a/src/cmd/compile/internal/ssa/prove.go b/src/cmd/compile/internal/ssa/prove.go
index 014535c0a4..efa4453f75 100644
--- a/src/cmd/compile/internal/ssa/prove.go
+++ b/src/cmd/compile/internal/ssa/prove.go
@@ -979,7 +979,7 @@ func addIndVarRestrictions(ft *factsTable, b *Block, iv indVar) {
 // addBranchRestrictions updates the factsTables ft with the facts learned when
 // branching from Block b in direction br.
 func addBranchRestrictions(ft *factsTable, b *Block, br branch) {
-	c := b.Control
+	c := b.Controls[0]
 	switch br {
 	case negative:
 		addRestrictions(b, ft, boolean, nil, c, eq)
@@ -988,14 +988,14 @@ func addBranchRestrictions(ft *factsTable, b *Block, br branch) {
 	default:
 		panic("unknown branch")
 	}
-	if tr, has := domainRelationTable[b.Control.Op]; has {
+	if tr, has := domainRelationTable[c.Op]; has {
 		// When we branched from parent we learned a new set of
 		// restrictions. Update the factsTable accordingly.
 		d := tr.d
 		if d == signed && ft.isNonNegative(c.Args[0]) && ft.isNonNegative(c.Args[1]) {
 			d |= unsigned
 		}
-		switch b.Control.Op {
+		switch c.Op {
 		case OpIsInBounds, OpIsSliceInBounds:
 			// 0 <= a0 < a1 (or 0 <= a0 <= a1)
 			//
@@ -1096,6 +1096,7 @@ func addLocalInductiveFacts(ft *factsTable, b *Block) {
 			if pred.Kind != BlockIf {
 				continue
 			}
+			control := pred.Controls[0]
 
 			br := unknown
 			if pred.Succs[0].b == child {
@@ -1108,7 +1109,7 @@ func addLocalInductiveFacts(ft *factsTable, b *Block) {
 				br = negative
 			}
 
-			tr, has := domainRelationTable[pred.Control.Op]
+			tr, has := domainRelationTable[control.Op]
 			if !has {
 				continue
 			}
@@ -1121,10 +1122,10 @@ func addLocalInductiveFacts(ft *factsTable, b *Block) {
 
 			// Check for i2 < max or max > i2.
 			var max *Value
-			if r == lt && pred.Control.Args[0] == i2 {
-				max = pred.Control.Args[1]
-			} else if r == gt && pred.Control.Args[1] == i2 {
-				max = pred.Control.Args[0]
+			if r == lt && control.Args[0] == i2 {
+				max = control.Args[1]
+			} else if r == gt && control.Args[1] == i2 {
+				max = control.Args[0]
 			} else {
 				continue
 			}
@@ -1288,7 +1289,7 @@ func removeBranch(b *Block, branch branch) {
 		if branch == positive {
 			verb = "Disproved"
 		}
-		c := b.Control
+		c := b.Controls[0]
 		if b.Func.pass.debug > 1 {
 			b.Func.Warnl(b.Pos, "%s %s (%s)", verb, c.Op, c)
 		} else {
@@ -1296,7 +1297,7 @@ func removeBranch(b *Block, branch branch) {
 		}
 	}
 	b.Kind = BlockFirst
-	b.SetControl(nil)
+	b.ResetControls()
 	if branch == positive {
 		b.swapSuccessors()
 	}
diff --git a/src/cmd/compile/internal/ssa/regalloc.go b/src/cmd/compile/internal/ssa/regalloc.go
index 2590315ba1..6ffa1e3848 100644
--- a/src/cmd/compile/internal/ssa/regalloc.go
+++ b/src/cmd/compile/internal/ssa/regalloc.go
@@ -701,8 +701,10 @@ func (s *regAllocState) init(f *Func) {
 		for _, b := range f.Blocks {
 			// New block. Clear candidate set.
 			canLiveOnStack.clear()
-			if b.Control != nil && b.Control.Uses == 1 && !opcodeTable[b.Control.Op].generic {
-				canLiveOnStack.add(b.Control.ID)
+			for _, c := range b.ControlValues() {
+				if c.Uses == 1 && !opcodeTable[c.Op].generic {
+					canLiveOnStack.add(c.ID)
+				}
 			}
 			// Walking backwards.
 			for i := len(b.Values) - 1; i >= 0; i-- {
@@ -856,9 +858,11 @@ func (s *regAllocState) regalloc(f *Func) {
 			s.addUse(e.ID, int32(len(b.Values))+e.dist, e.pos) // pseudo-uses from beyond end of block
 			regValLiveSet.add(e.ID)
 		}
-		if v := b.Control; v != nil && s.values[v.ID].needReg {
-			s.addUse(v.ID, int32(len(b.Values)), b.Pos) // pseudo-use by control value
-			regValLiveSet.add(v.ID)
+		for _, v := range b.ControlValues() {
+			if s.values[v.ID].needReg {
+				s.addUse(v.ID, int32(len(b.Values)), b.Pos) // pseudo-use by control values
+				regValLiveSet.add(v.ID)
+			}
 		}
 		for i := len(b.Values) - 1; i >= 0; i-- {
 			v := b.Values[i]
@@ -1503,21 +1507,32 @@ func (s *regAllocState) regalloc(f *Func) {
 		issueSpill:
 		}
 
-		// Load control value into reg.
-		if v := b.Control; v != nil && s.values[v.ID].needReg {
+		// Copy the control values - we need this so we can reduce the
+		// uses property of these values later.
+		controls := append(make([]*Value, 0, 2), b.ControlValues()...)
+
+		// Load control values into registers.
+		for i, v := range b.ControlValues() {
+			if !s.values[v.ID].needReg {
+				continue
+			}
 			if s.f.pass.debug > regDebug {
 				fmt.Printf("  processing control %s\n", v.LongString())
 			}
 			// We assume that a control input can be passed in any
 			// type-compatible register. If this turns out not to be true,
 			// we'll need to introduce a regspec for a block's control value.
-			b.Control = s.allocValToReg(v, s.compatRegs(v.Type), false, b.Pos)
-			if b.Control != v {
-				v.Uses--
-				b.Control.Uses++
+			b.ReplaceControl(i, s.allocValToReg(v, s.compatRegs(v.Type), false, b.Pos))
+		}
+
+		// Reduce the uses of the control values once registers have been loaded.
+		// This loop is equivalent to the advanceUses method.
+		for _, v := range controls {
+			vi := &s.values[v.ID]
+			if !vi.needReg {
+				continue
 			}
 			// Remove this use from the uses list.
-			vi := &s.values[v.ID]
 			u := vi.uses
 			vi.uses = u.next
 			if u.next == nil {
@@ -2355,9 +2370,11 @@ func (s *regAllocState) computeLive() {
 				live.set(e.ID, e.dist+int32(len(b.Values)), e.pos)
 			}
 
-			// Mark control value as live
-			if b.Control != nil && s.values[b.Control.ID].needReg {
-				live.set(b.Control.ID, int32(len(b.Values)), b.Pos)
+			// Mark control values as live
+			for _, c := range b.ControlValues() {
+				if s.values[c.ID].needReg {
+					live.set(c.ID, int32(len(b.Values)), b.Pos)
+				}
 			}
 
 			// Propagate backwards to the start of the block
diff --git a/src/cmd/compile/internal/ssa/rewrite.go b/src/cmd/compile/internal/ssa/rewrite.go
index 22e17cb5da..59d7601567 100644
--- a/src/cmd/compile/internal/ssa/rewrite.go
+++ b/src/cmd/compile/internal/ssa/rewrite.go
@@ -25,9 +25,10 @@ func applyRewrite(f *Func, rb blockRewriter, rv valueRewriter) {
 	for {
 		change := false
 		for _, b := range f.Blocks {
-			if b.Control != nil && b.Control.Op == OpCopy {
-				for b.Control.Op == OpCopy {
-					b.SetControl(b.Control.Args[0])
+			for i, c := range b.ControlValues() {
+				for c.Op == OpCopy {
+					c = c.Args[0]
+					b.ReplaceControl(i, c)
 				}
 			}
 			if rb(b) {
diff --git a/src/cmd/compile/internal/ssa/rewrite386.go b/src/cmd/compile/internal/ssa/rewrite386.go
index 08139d6ae4..bde41059f8 100644
--- a/src/cmd/compile/internal/ssa/rewrite386.go
+++ b/src/cmd/compile/internal/ssa/rewrite386.go
@@ -21975,58 +21975,59 @@ func rewriteValue386_OpZeromask_0(v *Value) bool {
 	}
 }
 func rewriteBlock386(b *Block) bool {
-	v := b.Control
 	switch b.Kind {
 	case Block386EQ:
 		// match: (EQ (InvertFlags cmp) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == Op386InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386EQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (EQ (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (EQ (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (EQ (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -22034,304 +22035,341 @@ func rewriteBlock386(b *Block) bool {
 	case Block386GE:
 		// match: (GE (InvertFlags cmp) yes no)
 		// result: (LE cmp yes no)
-		for v.Op == Op386InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386LE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GE (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GE (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 	case Block386GT:
 		// match: (GT (InvertFlags cmp) yes no)
 		// result: (LT cmp yes no)
-		for v.Op == Op386InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386LT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GT (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GT (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GT (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 	case BlockIf:
 		// match: (If (SETL cmp) yes no)
 		// result: (LT cmp yes no)
-		for v.Op == Op386SETL {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386SETL {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386LT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETLE cmp) yes no)
 		// result: (LE cmp yes no)
-		for v.Op == Op386SETLE {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386SETLE {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386LE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETG cmp) yes no)
 		// result: (GT cmp yes no)
-		for v.Op == Op386SETG {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386SETG {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386GT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETGE cmp) yes no)
 		// result: (GE cmp yes no)
-		for v.Op == Op386SETGE {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386SETGE {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386GE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETEQ cmp) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == Op386SETEQ {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386SETEQ {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386EQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETNE cmp) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == Op386SETNE {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386SETNE {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386NE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETB cmp) yes no)
 		// result: (ULT cmp yes no)
-		for v.Op == Op386SETB {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386SETB {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386ULT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETBE cmp) yes no)
 		// result: (ULE cmp yes no)
-		for v.Op == Op386SETBE {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386SETBE {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386ULE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETA cmp) yes no)
 		// result: (UGT cmp yes no)
-		for v.Op == Op386SETA {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386SETA {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386UGT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETAE cmp) yes no)
 		// result: (UGE cmp yes no)
-		for v.Op == Op386SETAE {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386SETAE {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386UGE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETO cmp) yes no)
 		// result: (OS cmp yes no)
-		for v.Op == Op386SETO {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386SETO {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386OS
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETGF cmp) yes no)
 		// result: (UGT cmp yes no)
-		for v.Op == Op386SETGF {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386SETGF {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386UGT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETGEF cmp) yes no)
 		// result: (UGE cmp yes no)
-		for v.Op == Op386SETGEF {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386SETGEF {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386UGE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETEQF cmp) yes no)
 		// result: (EQF cmp yes no)
-		for v.Op == Op386SETEQF {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386SETEQF {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386EQF
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETNEF cmp) yes no)
 		// result: (NEF cmp yes no)
-		for v.Op == Op386SETNEF {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386SETNEF {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386NEF
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If cond yes no)
 		// result: (NE (TESTB cond cond) yes no)
 		for {
-			cond := b.Control
+			cond := b.Controls[0]
 			b.Kind = Block386NE
-			v0 := b.NewValue0(v.Pos, Op386TESTB, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(cond.Pos, Op386TESTB, types.TypeFlags)
 			v0.AddArg(cond)
 			v0.AddArg(cond)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 	case Block386LE:
 		// match: (LE (InvertFlags cmp) yes no)
 		// result: (GE cmp yes no)
-		for v.Op == Op386InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386GE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LE (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -22339,52 +22377,54 @@ func rewriteBlock386(b *Block) bool {
 	case Block386LT:
 		// match: (LT (InvertFlags cmp) yes no)
 		// result: (GT cmp yes no)
-		for v.Op == Op386InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386GT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LT (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LT (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -22392,747 +22432,815 @@ func rewriteBlock386(b *Block) bool {
 	case Block386NE:
 		// match: (NE (TESTB (SETL cmp) (SETL cmp)) yes no)
 		// result: (LT cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETL {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETL {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETL || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETL || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386LT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETL cmp) (SETL cmp)) yes no)
 		// result: (LT cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETL {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETL {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETL || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETL || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386LT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETLE cmp) (SETLE cmp)) yes no)
 		// result: (LE cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETLE {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETLE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETLE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETLE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386LE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETLE cmp) (SETLE cmp)) yes no)
 		// result: (LE cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETLE {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETLE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETLE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETLE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386LE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETG cmp) (SETG cmp)) yes no)
 		// result: (GT cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETG {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETG {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETG || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETG || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386GT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETG cmp) (SETG cmp)) yes no)
 		// result: (GT cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETG {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETG {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETG || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETG || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386GT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETGE cmp) (SETGE cmp)) yes no)
 		// result: (GE cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETGE {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETGE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETGE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETGE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386GE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETGE cmp) (SETGE cmp)) yes no)
 		// result: (GE cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETGE {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETGE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETGE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETGE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386GE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETEQ cmp) (SETEQ cmp)) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETEQ {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETEQ {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETEQ || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETEQ || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386EQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETEQ cmp) (SETEQ cmp)) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETEQ {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETEQ {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETEQ || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETEQ || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386EQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETNE cmp) (SETNE cmp)) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETNE {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETNE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETNE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETNE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386NE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETNE cmp) (SETNE cmp)) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETNE {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETNE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETNE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETNE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386NE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETB cmp) (SETB cmp)) yes no)
 		// result: (ULT cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETB {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETB {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETB || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETB || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386ULT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETB cmp) (SETB cmp)) yes no)
 		// result: (ULT cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETB {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETB {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETB || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETB || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386ULT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETBE cmp) (SETBE cmp)) yes no)
 		// result: (ULE cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETBE {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETBE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETBE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETBE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386ULE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETBE cmp) (SETBE cmp)) yes no)
 		// result: (ULE cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETBE {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETBE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETBE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETBE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386ULE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETA cmp) (SETA cmp)) yes no)
 		// result: (UGT cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETA {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETA {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETA || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETA || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386UGT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETA cmp) (SETA cmp)) yes no)
 		// result: (UGT cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETA {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETA {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETA || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETA || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386UGT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETAE cmp) (SETAE cmp)) yes no)
 		// result: (UGE cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETAE {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETAE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETAE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETAE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386UGE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETAE cmp) (SETAE cmp)) yes no)
 		// result: (UGE cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETAE {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETAE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETAE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETAE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386UGE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETO cmp) (SETO cmp)) yes no)
 		// result: (OS cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETO {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETO {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETO || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETO || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386OS
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETO cmp) (SETO cmp)) yes no)
 		// result: (OS cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETO {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETO {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETO || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETO || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386OS
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETGF cmp) (SETGF cmp)) yes no)
 		// result: (UGT cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETGF {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETGF {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETGF || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETGF || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386UGT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETGF cmp) (SETGF cmp)) yes no)
 		// result: (UGT cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETGF {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETGF {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETGF || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETGF || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386UGT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETGEF cmp) (SETGEF cmp)) yes no)
 		// result: (UGE cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETGEF {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETGEF {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETGEF || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETGEF || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386UGE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETGEF cmp) (SETGEF cmp)) yes no)
 		// result: (UGE cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETGEF {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETGEF {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETGEF || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETGEF || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386UGE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETEQF cmp) (SETEQF cmp)) yes no)
 		// result: (EQF cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETEQF {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETEQF {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETEQF || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETEQF || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386EQF
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETEQF cmp) (SETEQF cmp)) yes no)
 		// result: (EQF cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETEQF {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETEQF {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETEQF || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETEQF || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386EQF
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETNEF cmp) (SETNEF cmp)) yes no)
 		// result: (NEF cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETNEF {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETNEF {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETNEF || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETNEF || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386NEF
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETNEF cmp) (SETNEF cmp)) yes no)
 		// result: (NEF cmp yes no)
-		for v.Op == Op386TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != Op386SETNEF {
+		for b.Controls[0].Op == Op386TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != Op386SETNEF {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != Op386SETNEF || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != Op386SETNEF || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = Block386NEF
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (InvertFlags cmp) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == Op386InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386NE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (NE (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 	case Block386UGE:
 		// match: (UGE (InvertFlags cmp) yes no)
 		// result: (ULE cmp yes no)
-		for v.Op == Op386InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386ULE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (UGE (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (UGE (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGE (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (UGE (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGE (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 	case Block386UGT:
 		// match: (UGT (InvertFlags cmp) yes no)
 		// result: (ULT cmp yes no)
-		for v.Op == Op386InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386ULT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (UGT (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGT (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGT (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (UGT (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGT (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 	case Block386ULE:
 		// match: (ULE (InvertFlags cmp) yes no)
 		// result: (UGE cmp yes no)
-		for v.Op == Op386InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386UGE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (ULE (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULE (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULE (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (ULE (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULE (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -23140,52 +23248,54 @@ func rewriteBlock386(b *Block) bool {
 	case Block386ULT:
 		// match: (ULT (InvertFlags cmp) yes no)
 		// result: (UGT cmp yes no)
-		for v.Op == Op386InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == Op386InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = Block386UGT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (ULT (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (ULT (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULT (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (ULT (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == Op386FlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == Op386FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULT (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == Op386FlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == Op386FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
diff --git a/src/cmd/compile/internal/ssa/rewriteAMD64.go b/src/cmd/compile/internal/ssa/rewriteAMD64.go
index 055ab73b83..20443d2f48 100644
--- a/src/cmd/compile/internal/ssa/rewriteAMD64.go
+++ b/src/cmd/compile/internal/ssa/rewriteAMD64.go
@@ -58100,182 +58100,198 @@ func rewriteValueAMD64_OpZeroExt8to64_0(v *Value) bool {
 }
 func rewriteBlockAMD64(b *Block) bool {
 	config := b.Func.Config
-	v := b.Control
 	switch b.Kind {
 	case BlockAMD64EQ:
 		// match: (EQ (TESTL (SHLL (MOVLconst [1]) x) y))
 		// cond: !config.nacl
 		// result: (UGE (BTL x y))
-		for v.Op == OpAMD64TESTL {
-			y := v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SHLL {
+		for b.Controls[0].Op == OpAMD64TESTL {
+			v_0 := b.Controls[0]
+			y := v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SHLL {
 				break
 			}
-			x := v_0.Args[1]
-			v_0_0 := v_0.Args[0]
-			if v_0_0.Op != OpAMD64MOVLconst || v_0_0.AuxInt != 1 || !(!config.nacl) {
+			x := v_0_0.Args[1]
+			v_0_0_0 := v_0_0.Args[0]
+			if v_0_0_0.Op != OpAMD64MOVLconst || v_0_0_0.AuxInt != 1 || !(!config.nacl) {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTL, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTL y (SHLL (MOVLconst [1]) x)))
 		// cond: !config.nacl
 		// result: (UGE (BTL x y))
-		for v.Op == OpAMD64TESTL {
-			_ = v.Args[1]
-			y := v.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SHLL {
+		for b.Controls[0].Op == OpAMD64TESTL {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			y := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SHLL {
 				break
 			}
-			x := v_1.Args[1]
-			v_1_0 := v_1.Args[0]
-			if v_1_0.Op != OpAMD64MOVLconst || v_1_0.AuxInt != 1 || !(!config.nacl) {
+			x := v_0_1.Args[1]
+			v_0_1_0 := v_0_1.Args[0]
+			if v_0_1_0.Op != OpAMD64MOVLconst || v_0_1_0.AuxInt != 1 || !(!config.nacl) {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTL, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTQ (SHLQ (MOVQconst [1]) x) y))
 		// cond: !config.nacl
 		// result: (UGE (BTQ x y))
-		for v.Op == OpAMD64TESTQ {
-			y := v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SHLQ {
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			y := v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SHLQ {
 				break
 			}
-			x := v_0.Args[1]
-			v_0_0 := v_0.Args[0]
-			if v_0_0.Op != OpAMD64MOVQconst || v_0_0.AuxInt != 1 || !(!config.nacl) {
+			x := v_0_0.Args[1]
+			v_0_0_0 := v_0_0.Args[0]
+			if v_0_0_0.Op != OpAMD64MOVQconst || v_0_0_0.AuxInt != 1 || !(!config.nacl) {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQ, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQ, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTQ y (SHLQ (MOVQconst [1]) x)))
 		// cond: !config.nacl
 		// result: (UGE (BTQ x y))
-		for v.Op == OpAMD64TESTQ {
-			_ = v.Args[1]
-			y := v.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SHLQ {
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			y := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SHLQ {
 				break
 			}
-			x := v_1.Args[1]
-			v_1_0 := v_1.Args[0]
-			if v_1_0.Op != OpAMD64MOVQconst || v_1_0.AuxInt != 1 || !(!config.nacl) {
+			x := v_0_1.Args[1]
+			v_0_1_0 := v_0_1.Args[0]
+			if v_0_1_0.Op != OpAMD64MOVQconst || v_0_1_0.AuxInt != 1 || !(!config.nacl) {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQ, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQ, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTLconst [c] x))
 		// cond: isUint32PowerOfTwo(c) && !config.nacl
 		// result: (UGE (BTLconst [log2uint32(c)] x))
-		for v.Op == OpAMD64TESTLconst {
-			c := v.AuxInt
-			x := v.Args[0]
+		for b.Controls[0].Op == OpAMD64TESTLconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
+			x := v_0.Args[0]
 			if !(isUint32PowerOfTwo(c) && !config.nacl) {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTLconst, types.TypeFlags)
 			v0.AuxInt = log2uint32(c)
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTQconst [c] x))
 		// cond: isUint64PowerOfTwo(c) && !config.nacl
 		// result: (UGE (BTQconst [log2(c)] x))
-		for v.Op == OpAMD64TESTQconst {
-			c := v.AuxInt
-			x := v.Args[0]
+		for b.Controls[0].Op == OpAMD64TESTQconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
+			x := v_0.Args[0]
 			if !(isUint64PowerOfTwo(c) && !config.nacl) {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = log2(c)
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTQ (MOVQconst [c]) x))
 		// cond: isUint64PowerOfTwo(c) && !config.nacl
 		// result: (UGE (BTQconst [log2(c)] x))
-		for v.Op == OpAMD64TESTQ {
-			x := v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64MOVQconst {
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			x := v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64MOVQconst {
 				break
 			}
-			c := v_0.AuxInt
+			c := v_0_0.AuxInt
 			if !(isUint64PowerOfTwo(c) && !config.nacl) {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = log2(c)
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTQ x (MOVQconst [c])))
 		// cond: isUint64PowerOfTwo(c) && !config.nacl
 		// result: (UGE (BTQconst [log2(c)] x))
-		for v.Op == OpAMD64TESTQ {
-			_ = v.Args[1]
-			x := v.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64MOVQconst {
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64MOVQconst {
 				break
 			}
-			c := v_1.AuxInt
+			c := v_0_1.AuxInt
 			if !(isUint64PowerOfTwo(c) && !config.nacl) {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = log2(c)
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTQ z1:(SHLQconst [63] (SHRQconst [63] x)) z2))
 		// cond: z1==z2 && !config.nacl
 		// result: (UGE (BTQconst [63] x))
-		for v.Op == OpAMD64TESTQ {
-			z2 := v.Args[1]
-			z1 := v.Args[0]
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			z2 := v_0.Args[1]
+			z1 := v_0.Args[0]
 			if z1.Op != OpAMD64SHLQconst || z1.AuxInt != 63 {
 				break
 			}
@@ -58288,20 +58304,22 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = 63
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTQ z2 z1:(SHLQconst [63] (SHRQconst [63] x))))
 		// cond: z1==z2 && !config.nacl
 		// result: (UGE (BTQconst [63] x))
-		for v.Op == OpAMD64TESTQ {
-			_ = v.Args[1]
-			z2 := v.Args[0]
-			z1 := v.Args[1]
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			z2 := v_0.Args[0]
+			z1 := v_0.Args[1]
 			if z1.Op != OpAMD64SHLQconst || z1.AuxInt != 63 {
 				break
 			}
@@ -58314,19 +58332,21 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = 63
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTL z1:(SHLLconst [31] (SHRQconst [31] x)) z2))
 		// cond: z1==z2 && !config.nacl
 		// result: (UGE (BTQconst [31] x))
-		for v.Op == OpAMD64TESTL {
-			z2 := v.Args[1]
-			z1 := v.Args[0]
+		for b.Controls[0].Op == OpAMD64TESTL {
+			v_0 := b.Controls[0]
+			z2 := v_0.Args[1]
+			z1 := v_0.Args[0]
 			if z1.Op != OpAMD64SHLLconst || z1.AuxInt != 31 {
 				break
 			}
@@ -58339,20 +58359,22 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = 31
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTL z2 z1:(SHLLconst [31] (SHRQconst [31] x))))
 		// cond: z1==z2 && !config.nacl
 		// result: (UGE (BTQconst [31] x))
-		for v.Op == OpAMD64TESTL {
-			_ = v.Args[1]
-			z2 := v.Args[0]
-			z1 := v.Args[1]
+		for b.Controls[0].Op == OpAMD64TESTL {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			z2 := v_0.Args[0]
+			z1 := v_0.Args[1]
 			if z1.Op != OpAMD64SHLLconst || z1.AuxInt != 31 {
 				break
 			}
@@ -58365,19 +58387,21 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = 31
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTQ z1:(SHRQconst [63] (SHLQconst [63] x)) z2))
 		// cond: z1==z2 && !config.nacl
 		// result: (UGE (BTQconst [0] x))
-		for v.Op == OpAMD64TESTQ {
-			z2 := v.Args[1]
-			z1 := v.Args[0]
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			z2 := v_0.Args[1]
+			z1 := v_0.Args[0]
 			if z1.Op != OpAMD64SHRQconst || z1.AuxInt != 63 {
 				break
 			}
@@ -58390,20 +58414,22 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = 0
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTQ z2 z1:(SHRQconst [63] (SHLQconst [63] x))))
 		// cond: z1==z2 && !config.nacl
 		// result: (UGE (BTQconst [0] x))
-		for v.Op == OpAMD64TESTQ {
-			_ = v.Args[1]
-			z2 := v.Args[0]
-			z1 := v.Args[1]
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			z2 := v_0.Args[0]
+			z1 := v_0.Args[1]
 			if z1.Op != OpAMD64SHRQconst || z1.AuxInt != 63 {
 				break
 			}
@@ -58416,19 +58442,21 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = 0
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTL z1:(SHRLconst [31] (SHLLconst [31] x)) z2))
 		// cond: z1==z2 && !config.nacl
 		// result: (UGE (BTLconst [0] x))
-		for v.Op == OpAMD64TESTL {
-			z2 := v.Args[1]
-			z1 := v.Args[0]
+		for b.Controls[0].Op == OpAMD64TESTL {
+			v_0 := b.Controls[0]
+			z2 := v_0.Args[1]
+			z1 := v_0.Args[0]
 			if z1.Op != OpAMD64SHRLconst || z1.AuxInt != 31 {
 				break
 			}
@@ -58441,20 +58469,22 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTLconst, types.TypeFlags)
 			v0.AuxInt = 0
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTL z2 z1:(SHRLconst [31] (SHLLconst [31] x))))
 		// cond: z1==z2 && !config.nacl
 		// result: (UGE (BTLconst [0] x))
-		for v.Op == OpAMD64TESTL {
-			_ = v.Args[1]
-			z2 := v.Args[0]
-			z1 := v.Args[1]
+		for b.Controls[0].Op == OpAMD64TESTL {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			z2 := v_0.Args[0]
+			z1 := v_0.Args[1]
 			if z1.Op != OpAMD64SHRLconst || z1.AuxInt != 31 {
 				break
 			}
@@ -58467,19 +58497,21 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTLconst, types.TypeFlags)
 			v0.AuxInt = 0
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTQ z1:(SHRQconst [63] x) z2))
 		// cond: z1==z2 && !config.nacl
 		// result: (UGE (BTQconst [63] x))
-		for v.Op == OpAMD64TESTQ {
-			z2 := v.Args[1]
-			z1 := v.Args[0]
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			z2 := v_0.Args[1]
+			z1 := v_0.Args[0]
 			if z1.Op != OpAMD64SHRQconst || z1.AuxInt != 63 {
 				break
 			}
@@ -58488,20 +58520,22 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = 63
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTQ z2 z1:(SHRQconst [63] x)))
 		// cond: z1==z2 && !config.nacl
 		// result: (UGE (BTQconst [63] x))
-		for v.Op == OpAMD64TESTQ {
-			_ = v.Args[1]
-			z2 := v.Args[0]
-			z1 := v.Args[1]
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			z2 := v_0.Args[0]
+			z1 := v_0.Args[1]
 			if z1.Op != OpAMD64SHRQconst || z1.AuxInt != 63 {
 				break
 			}
@@ -58510,19 +58544,21 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = 63
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTL z1:(SHRLconst [31] x) z2))
 		// cond: z1==z2 && !config.nacl
 		// result: (UGE (BTLconst [31] x))
-		for v.Op == OpAMD64TESTL {
-			z2 := v.Args[1]
-			z1 := v.Args[0]
+		for b.Controls[0].Op == OpAMD64TESTL {
+			v_0 := b.Controls[0]
+			z2 := v_0.Args[1]
+			z1 := v_0.Args[0]
 			if z1.Op != OpAMD64SHRLconst || z1.AuxInt != 31 {
 				break
 			}
@@ -58531,20 +58567,22 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTLconst, types.TypeFlags)
 			v0.AuxInt = 31
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TESTL z2 z1:(SHRLconst [31] x)))
 		// cond: z1==z2 && !config.nacl
 		// result: (UGE (BTLconst [31] x))
-		for v.Op == OpAMD64TESTL {
-			_ = v.Args[1]
-			z2 := v.Args[0]
-			z1 := v.Args[1]
+		for b.Controls[0].Op == OpAMD64TESTL {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			z2 := v_0.Args[0]
+			z1 := v_0.Args[1]
 			if z1.Op != OpAMD64SHRLconst || z1.AuxInt != 31 {
 				break
 			}
@@ -58553,62 +58591,65 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTLconst, types.TypeFlags)
 			v0.AuxInt = 31
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (InvertFlags cmp) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == OpAMD64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64EQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (EQ (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (EQ (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (EQ (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -58616,304 +58657,341 @@ func rewriteBlockAMD64(b *Block) bool {
 	case BlockAMD64GE:
 		// match: (GE (InvertFlags cmp) yes no)
 		// result: (LE cmp yes no)
-		for v.Op == OpAMD64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64LE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GE (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GE (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 	case BlockAMD64GT:
 		// match: (GT (InvertFlags cmp) yes no)
 		// result: (LT cmp yes no)
-		for v.Op == OpAMD64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64LT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GT (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GT (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GT (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 	case BlockIf:
 		// match: (If (SETL cmp) yes no)
 		// result: (LT cmp yes no)
-		for v.Op == OpAMD64SETL {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64SETL {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64LT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETLE cmp) yes no)
 		// result: (LE cmp yes no)
-		for v.Op == OpAMD64SETLE {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64SETLE {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64LE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETG cmp) yes no)
 		// result: (GT cmp yes no)
-		for v.Op == OpAMD64SETG {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64SETG {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64GT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETGE cmp) yes no)
 		// result: (GE cmp yes no)
-		for v.Op == OpAMD64SETGE {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64SETGE {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64GE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETEQ cmp) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == OpAMD64SETEQ {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64SETEQ {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64EQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETNE cmp) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == OpAMD64SETNE {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64SETNE {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64NE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETB cmp) yes no)
 		// result: (ULT cmp yes no)
-		for v.Op == OpAMD64SETB {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64SETB {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64ULT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETBE cmp) yes no)
 		// result: (ULE cmp yes no)
-		for v.Op == OpAMD64SETBE {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64SETBE {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64ULE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETA cmp) yes no)
 		// result: (UGT cmp yes no)
-		for v.Op == OpAMD64SETA {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64SETA {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64UGT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETAE cmp) yes no)
 		// result: (UGE cmp yes no)
-		for v.Op == OpAMD64SETAE {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64SETAE {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64UGE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETO cmp) yes no)
 		// result: (OS cmp yes no)
-		for v.Op == OpAMD64SETO {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64SETO {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64OS
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETGF cmp) yes no)
 		// result: (UGT cmp yes no)
-		for v.Op == OpAMD64SETGF {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64SETGF {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64UGT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETGEF cmp) yes no)
 		// result: (UGE cmp yes no)
-		for v.Op == OpAMD64SETGEF {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64SETGEF {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64UGE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETEQF cmp) yes no)
 		// result: (EQF cmp yes no)
-		for v.Op == OpAMD64SETEQF {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64SETEQF {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64EQF
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (SETNEF cmp) yes no)
 		// result: (NEF cmp yes no)
-		for v.Op == OpAMD64SETNEF {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64SETNEF {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64NEF
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (If cond yes no)
 		// result: (NE (TESTB cond cond) yes no)
 		for {
-			cond := b.Control
+			cond := b.Controls[0]
 			b.Kind = BlockAMD64NE
-			v0 := b.NewValue0(v.Pos, OpAMD64TESTB, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(cond.Pos, OpAMD64TESTB, types.TypeFlags)
 			v0.AddArg(cond)
 			v0.AddArg(cond)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 	case BlockAMD64LE:
 		// match: (LE (InvertFlags cmp) yes no)
 		// result: (GE cmp yes no)
-		for v.Op == OpAMD64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64GE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LE (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -58921,52 +58999,54 @@ func rewriteBlockAMD64(b *Block) bool {
 	case BlockAMD64LT:
 		// match: (LT (InvertFlags cmp) yes no)
 		// result: (GT cmp yes no)
-		for v.Op == OpAMD64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64GT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LT (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LT (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -58974,573 +59054,634 @@ func rewriteBlockAMD64(b *Block) bool {
 	case BlockAMD64NE:
 		// match: (NE (TESTB (SETL cmp) (SETL cmp)) yes no)
 		// result: (LT cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETL {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETL {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETL || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETL || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64LT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETL cmp) (SETL cmp)) yes no)
 		// result: (LT cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETL {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETL {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETL || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETL || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64LT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETLE cmp) (SETLE cmp)) yes no)
 		// result: (LE cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETLE {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETLE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETLE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETLE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64LE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETLE cmp) (SETLE cmp)) yes no)
 		// result: (LE cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETLE {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETLE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETLE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETLE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64LE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETG cmp) (SETG cmp)) yes no)
 		// result: (GT cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETG {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETG {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETG || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETG || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64GT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETG cmp) (SETG cmp)) yes no)
 		// result: (GT cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETG {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETG {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETG || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETG || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64GT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETGE cmp) (SETGE cmp)) yes no)
 		// result: (GE cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETGE {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETGE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETGE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETGE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64GE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETGE cmp) (SETGE cmp)) yes no)
 		// result: (GE cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETGE {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETGE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETGE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETGE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64GE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETEQ cmp) (SETEQ cmp)) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETEQ {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETEQ {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETEQ || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETEQ || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64EQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETEQ cmp) (SETEQ cmp)) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETEQ {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETEQ {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETEQ || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETEQ || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64EQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETNE cmp) (SETNE cmp)) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETNE {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETNE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETNE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETNE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64NE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETNE cmp) (SETNE cmp)) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETNE {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETNE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETNE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETNE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64NE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETB cmp) (SETB cmp)) yes no)
 		// result: (ULT cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETB {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETB {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETB || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETB || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETB cmp) (SETB cmp)) yes no)
 		// result: (ULT cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETB {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETB {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETB || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETB || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETBE cmp) (SETBE cmp)) yes no)
 		// result: (ULE cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETBE {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETBE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETBE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETBE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64ULE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETBE cmp) (SETBE cmp)) yes no)
 		// result: (ULE cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETBE {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETBE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETBE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETBE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64ULE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETA cmp) (SETA cmp)) yes no)
 		// result: (UGT cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETA {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETA {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETA || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETA || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64UGT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETA cmp) (SETA cmp)) yes no)
 		// result: (UGT cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETA {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETA {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETA || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETA || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64UGT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETAE cmp) (SETAE cmp)) yes no)
 		// result: (UGE cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETAE {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETAE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETAE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETAE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETAE cmp) (SETAE cmp)) yes no)
 		// result: (UGE cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETAE {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETAE {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETAE || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETAE || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETO cmp) (SETO cmp)) yes no)
 		// result: (OS cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETO {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETO {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETO || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETO || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64OS
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETO cmp) (SETO cmp)) yes no)
 		// result: (OS cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETO {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETO {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETO || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETO || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64OS
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTL (SHLL (MOVLconst [1]) x) y))
 		// cond: !config.nacl
 		// result: (ULT (BTL x y))
-		for v.Op == OpAMD64TESTL {
-			y := v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SHLL {
+		for b.Controls[0].Op == OpAMD64TESTL {
+			v_0 := b.Controls[0]
+			y := v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SHLL {
 				break
 			}
-			x := v_0.Args[1]
-			v_0_0 := v_0.Args[0]
-			if v_0_0.Op != OpAMD64MOVLconst || v_0_0.AuxInt != 1 || !(!config.nacl) {
+			x := v_0_0.Args[1]
+			v_0_0_0 := v_0_0.Args[0]
+			if v_0_0_0.Op != OpAMD64MOVLconst || v_0_0_0.AuxInt != 1 || !(!config.nacl) {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTL, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTL y (SHLL (MOVLconst [1]) x)))
 		// cond: !config.nacl
 		// result: (ULT (BTL x y))
-		for v.Op == OpAMD64TESTL {
-			_ = v.Args[1]
-			y := v.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SHLL {
+		for b.Controls[0].Op == OpAMD64TESTL {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			y := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SHLL {
 				break
 			}
-			x := v_1.Args[1]
-			v_1_0 := v_1.Args[0]
-			if v_1_0.Op != OpAMD64MOVLconst || v_1_0.AuxInt != 1 || !(!config.nacl) {
+			x := v_0_1.Args[1]
+			v_0_1_0 := v_0_1.Args[0]
+			if v_0_1_0.Op != OpAMD64MOVLconst || v_0_1_0.AuxInt != 1 || !(!config.nacl) {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTL, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTQ (SHLQ (MOVQconst [1]) x) y))
 		// cond: !config.nacl
 		// result: (ULT (BTQ x y))
-		for v.Op == OpAMD64TESTQ {
-			y := v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SHLQ {
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			y := v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SHLQ {
 				break
 			}
-			x := v_0.Args[1]
-			v_0_0 := v_0.Args[0]
-			if v_0_0.Op != OpAMD64MOVQconst || v_0_0.AuxInt != 1 || !(!config.nacl) {
+			x := v_0_0.Args[1]
+			v_0_0_0 := v_0_0.Args[0]
+			if v_0_0_0.Op != OpAMD64MOVQconst || v_0_0_0.AuxInt != 1 || !(!config.nacl) {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQ, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQ, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTQ y (SHLQ (MOVQconst [1]) x)))
 		// cond: !config.nacl
 		// result: (ULT (BTQ x y))
-		for v.Op == OpAMD64TESTQ {
-			_ = v.Args[1]
-			y := v.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SHLQ {
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			y := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SHLQ {
 				break
 			}
-			x := v_1.Args[1]
-			v_1_0 := v_1.Args[0]
-			if v_1_0.Op != OpAMD64MOVQconst || v_1_0.AuxInt != 1 || !(!config.nacl) {
+			x := v_0_1.Args[1]
+			v_0_1_0 := v_0_1.Args[0]
+			if v_0_1_0.Op != OpAMD64MOVQconst || v_0_1_0.AuxInt != 1 || !(!config.nacl) {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQ, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQ, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTLconst [c] x))
 		// cond: isUint32PowerOfTwo(c) && !config.nacl
 		// result: (ULT (BTLconst [log2uint32(c)] x))
-		for v.Op == OpAMD64TESTLconst {
-			c := v.AuxInt
-			x := v.Args[0]
+		for b.Controls[0].Op == OpAMD64TESTLconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
+			x := v_0.Args[0]
 			if !(isUint32PowerOfTwo(c) && !config.nacl) {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTLconst, types.TypeFlags)
 			v0.AuxInt = log2uint32(c)
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTQconst [c] x))
 		// cond: isUint64PowerOfTwo(c) && !config.nacl
 		// result: (ULT (BTQconst [log2(c)] x))
-		for v.Op == OpAMD64TESTQconst {
-			c := v.AuxInt
-			x := v.Args[0]
+		for b.Controls[0].Op == OpAMD64TESTQconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
+			x := v_0.Args[0]
 			if !(isUint64PowerOfTwo(c) && !config.nacl) {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = log2(c)
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTQ (MOVQconst [c]) x))
 		// cond: isUint64PowerOfTwo(c) && !config.nacl
 		// result: (ULT (BTQconst [log2(c)] x))
-		for v.Op == OpAMD64TESTQ {
-			x := v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64MOVQconst {
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			x := v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64MOVQconst {
 				break
 			}
-			c := v_0.AuxInt
+			c := v_0_0.AuxInt
 			if !(isUint64PowerOfTwo(c) && !config.nacl) {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = log2(c)
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTQ x (MOVQconst [c])))
 		// cond: isUint64PowerOfTwo(c) && !config.nacl
 		// result: (ULT (BTQconst [log2(c)] x))
-		for v.Op == OpAMD64TESTQ {
-			_ = v.Args[1]
-			x := v.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64MOVQconst {
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64MOVQconst {
 				break
 			}
-			c := v_1.AuxInt
+			c := v_0_1.AuxInt
 			if !(isUint64PowerOfTwo(c) && !config.nacl) {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = log2(c)
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTQ z1:(SHLQconst [63] (SHRQconst [63] x)) z2))
 		// cond: z1==z2 && !config.nacl
 		// result: (ULT (BTQconst [63] x))
-		for v.Op == OpAMD64TESTQ {
-			z2 := v.Args[1]
-			z1 := v.Args[0]
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			z2 := v_0.Args[1]
+			z1 := v_0.Args[0]
 			if z1.Op != OpAMD64SHLQconst || z1.AuxInt != 63 {
 				break
 			}
@@ -59553,20 +59694,22 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = 63
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTQ z2 z1:(SHLQconst [63] (SHRQconst [63] x))))
 		// cond: z1==z2 && !config.nacl
 		// result: (ULT (BTQconst [63] x))
-		for v.Op == OpAMD64TESTQ {
-			_ = v.Args[1]
-			z2 := v.Args[0]
-			z1 := v.Args[1]
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			z2 := v_0.Args[0]
+			z1 := v_0.Args[1]
 			if z1.Op != OpAMD64SHLQconst || z1.AuxInt != 63 {
 				break
 			}
@@ -59579,19 +59722,21 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = 63
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTL z1:(SHLLconst [31] (SHRQconst [31] x)) z2))
 		// cond: z1==z2 && !config.nacl
 		// result: (ULT (BTQconst [31] x))
-		for v.Op == OpAMD64TESTL {
-			z2 := v.Args[1]
-			z1 := v.Args[0]
+		for b.Controls[0].Op == OpAMD64TESTL {
+			v_0 := b.Controls[0]
+			z2 := v_0.Args[1]
+			z1 := v_0.Args[0]
 			if z1.Op != OpAMD64SHLLconst || z1.AuxInt != 31 {
 				break
 			}
@@ -59604,20 +59749,22 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = 31
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTL z2 z1:(SHLLconst [31] (SHRQconst [31] x))))
 		// cond: z1==z2 && !config.nacl
 		// result: (ULT (BTQconst [31] x))
-		for v.Op == OpAMD64TESTL {
-			_ = v.Args[1]
-			z2 := v.Args[0]
-			z1 := v.Args[1]
+		for b.Controls[0].Op == OpAMD64TESTL {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			z2 := v_0.Args[0]
+			z1 := v_0.Args[1]
 			if z1.Op != OpAMD64SHLLconst || z1.AuxInt != 31 {
 				break
 			}
@@ -59630,19 +59777,21 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = 31
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTQ z1:(SHRQconst [63] (SHLQconst [63] x)) z2))
 		// cond: z1==z2 && !config.nacl
 		// result: (ULT (BTQconst [0] x))
-		for v.Op == OpAMD64TESTQ {
-			z2 := v.Args[1]
-			z1 := v.Args[0]
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			z2 := v_0.Args[1]
+			z1 := v_0.Args[0]
 			if z1.Op != OpAMD64SHRQconst || z1.AuxInt != 63 {
 				break
 			}
@@ -59655,20 +59804,22 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = 0
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTQ z2 z1:(SHRQconst [63] (SHLQconst [63] x))))
 		// cond: z1==z2 && !config.nacl
 		// result: (ULT (BTQconst [0] x))
-		for v.Op == OpAMD64TESTQ {
-			_ = v.Args[1]
-			z2 := v.Args[0]
-			z1 := v.Args[1]
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			z2 := v_0.Args[0]
+			z1 := v_0.Args[1]
 			if z1.Op != OpAMD64SHRQconst || z1.AuxInt != 63 {
 				break
 			}
@@ -59681,19 +59832,21 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = 0
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTL z1:(SHRLconst [31] (SHLLconst [31] x)) z2))
 		// cond: z1==z2 && !config.nacl
 		// result: (ULT (BTLconst [0] x))
-		for v.Op == OpAMD64TESTL {
-			z2 := v.Args[1]
-			z1 := v.Args[0]
+		for b.Controls[0].Op == OpAMD64TESTL {
+			v_0 := b.Controls[0]
+			z2 := v_0.Args[1]
+			z1 := v_0.Args[0]
 			if z1.Op != OpAMD64SHRLconst || z1.AuxInt != 31 {
 				break
 			}
@@ -59706,20 +59859,22 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTLconst, types.TypeFlags)
 			v0.AuxInt = 0
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTL z2 z1:(SHRLconst [31] (SHLLconst [31] x))))
 		// cond: z1==z2 && !config.nacl
 		// result: (ULT (BTLconst [0] x))
-		for v.Op == OpAMD64TESTL {
-			_ = v.Args[1]
-			z2 := v.Args[0]
-			z1 := v.Args[1]
+		for b.Controls[0].Op == OpAMD64TESTL {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			z2 := v_0.Args[0]
+			z1 := v_0.Args[1]
 			if z1.Op != OpAMD64SHRLconst || z1.AuxInt != 31 {
 				break
 			}
@@ -59732,19 +59887,21 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTLconst, types.TypeFlags)
 			v0.AuxInt = 0
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTQ z1:(SHRQconst [63] x) z2))
 		// cond: z1==z2 && !config.nacl
 		// result: (ULT (BTQconst [63] x))
-		for v.Op == OpAMD64TESTQ {
-			z2 := v.Args[1]
-			z1 := v.Args[0]
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			z2 := v_0.Args[1]
+			z1 := v_0.Args[0]
 			if z1.Op != OpAMD64SHRQconst || z1.AuxInt != 63 {
 				break
 			}
@@ -59753,20 +59910,22 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = 63
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTQ z2 z1:(SHRQconst [63] x)))
 		// cond: z1==z2 && !config.nacl
 		// result: (ULT (BTQconst [63] x))
-		for v.Op == OpAMD64TESTQ {
-			_ = v.Args[1]
-			z2 := v.Args[0]
-			z1 := v.Args[1]
+		for b.Controls[0].Op == OpAMD64TESTQ {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			z2 := v_0.Args[0]
+			z1 := v_0.Args[1]
 			if z1.Op != OpAMD64SHRQconst || z1.AuxInt != 63 {
 				break
 			}
@@ -59775,19 +59934,21 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTQconst, types.TypeFlags)
 			v0.AuxInt = 63
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTL z1:(SHRLconst [31] x) z2))
 		// cond: z1==z2 && !config.nacl
 		// result: (ULT (BTLconst [31] x))
-		for v.Op == OpAMD64TESTL {
-			z2 := v.Args[1]
-			z1 := v.Args[0]
+		for b.Controls[0].Op == OpAMD64TESTL {
+			v_0 := b.Controls[0]
+			z2 := v_0.Args[1]
+			z1 := v_0.Args[0]
 			if z1.Op != OpAMD64SHRLconst || z1.AuxInt != 31 {
 				break
 			}
@@ -59796,20 +59957,22 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTLconst, types.TypeFlags)
 			v0.AuxInt = 31
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTL z2 z1:(SHRLconst [31] x)))
 		// cond: z1==z2 && !config.nacl
 		// result: (ULT (BTLconst [31] x))
-		for v.Op == OpAMD64TESTL {
-			_ = v.Args[1]
-			z2 := v.Args[0]
-			z1 := v.Args[1]
+		for b.Controls[0].Op == OpAMD64TESTL {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			z2 := v_0.Args[0]
+			z1 := v_0.Args[1]
 			if z1.Op != OpAMD64SHRLconst || z1.AuxInt != 31 {
 				break
 			}
@@ -59818,360 +59981,385 @@ func rewriteBlockAMD64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockAMD64ULT
-			v0 := b.NewValue0(v.Pos, OpAMD64BTLconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpAMD64BTLconst, types.TypeFlags)
 			v0.AuxInt = 31
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETGF cmp) (SETGF cmp)) yes no)
 		// result: (UGT cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETGF {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETGF {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETGF || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETGF || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64UGT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETGF cmp) (SETGF cmp)) yes no)
 		// result: (UGT cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETGF {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETGF {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETGF || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETGF || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64UGT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETGEF cmp) (SETGEF cmp)) yes no)
 		// result: (UGE cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETGEF {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETGEF {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETGEF || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETGEF || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETGEF cmp) (SETGEF cmp)) yes no)
 		// result: (UGE cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETGEF {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETGEF {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETGEF || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETGEF || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64UGE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETEQF cmp) (SETEQF cmp)) yes no)
 		// result: (EQF cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETEQF {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETEQF {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETEQF || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETEQF || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64EQF
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETEQF cmp) (SETEQF cmp)) yes no)
 		// result: (EQF cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETEQF {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETEQF {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETEQF || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETEQF || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64EQF
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETNEF cmp) (SETNEF cmp)) yes no)
 		// result: (NEF cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETNEF {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETNEF {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETNEF || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETNEF || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64NEF
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TESTB (SETNEF cmp) (SETNEF cmp)) yes no)
 		// result: (NEF cmp yes no)
-		for v.Op == OpAMD64TESTB {
-			_ = v.Args[1]
-			v_0 := v.Args[0]
-			if v_0.Op != OpAMD64SETNEF {
+		for b.Controls[0].Op == OpAMD64TESTB {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpAMD64SETNEF {
 				break
 			}
-			cmp := v_0.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpAMD64SETNEF || cmp != v_1.Args[0] {
+			cmp := v_0_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpAMD64SETNEF || cmp != v_0_1.Args[0] {
 				break
 			}
 			b.Kind = BlockAMD64NEF
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (InvertFlags cmp) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == OpAMD64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64NE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (NE (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 	case BlockAMD64UGE:
 		// match: (UGE (InvertFlags cmp) yes no)
 		// result: (ULE cmp yes no)
-		for v.Op == OpAMD64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64ULE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (UGE (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (UGE (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGE (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (UGE (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGE (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 	case BlockAMD64UGT:
 		// match: (UGT (InvertFlags cmp) yes no)
 		// result: (ULT cmp yes no)
-		for v.Op == OpAMD64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64ULT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (UGT (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGT (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGT (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (UGT (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGT (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 	case BlockAMD64ULE:
 		// match: (ULE (InvertFlags cmp) yes no)
 		// result: (UGE cmp yes no)
-		for v.Op == OpAMD64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64UGE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (ULE (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULE (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULE (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (ULE (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULE (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -60179,52 +60367,54 @@ func rewriteBlockAMD64(b *Block) bool {
 	case BlockAMD64ULT:
 		// match: (ULT (InvertFlags cmp) yes no)
 		// result: (UGT cmp yes no)
-		for v.Op == OpAMD64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpAMD64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockAMD64UGT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (ULT (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (ULT (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULT (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (ULT (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpAMD64FlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpAMD64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULT (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpAMD64FlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpAMD64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
diff --git a/src/cmd/compile/internal/ssa/rewriteARM.go b/src/cmd/compile/internal/ssa/rewriteARM.go
index a192556059..b51799743b 100644
--- a/src/cmd/compile/internal/ssa/rewriteARM.go
+++ b/src/cmd/compile/internal/ssa/rewriteARM.go
@@ -20654,70 +20654,72 @@ func rewriteValueARM_OpZeromask_0(v *Value) bool {
 	}
 }
 func rewriteBlockARM(b *Block) bool {
-	v := b.Control
 	switch b.Kind {
 	case BlockARMEQ:
 		// match: (EQ (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (EQ (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (EQ (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (EQ (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (EQ (InvertFlags cmp) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == OpARMInvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARMInvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARMEQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(SUB x y)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (CMP x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUB {
 				break
 			}
@@ -20727,21 +20729,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMP, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(MULS x y a)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (CMP a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMMULS {
 				break
 			}
@@ -20752,24 +20756,26 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMP, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARMMUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARMMUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(SUBconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (CMPconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBconst {
 				break
 			}
@@ -20779,21 +20785,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(SUBshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (CMPshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftLL {
 				break
 			}
@@ -20804,22 +20812,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(SUBshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (CMPshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRL {
 				break
 			}
@@ -20830,22 +20840,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(SUBshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (CMPshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRA {
 				break
 			}
@@ -20856,22 +20868,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(SUBshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (CMPshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftLLreg {
 				break
 			}
@@ -20882,22 +20896,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(SUBshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (CMPshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRLreg {
 				break
 			}
@@ -20908,22 +20924,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(SUBshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (CMPshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRAreg {
 				break
 			}
@@ -20934,22 +20952,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(ADD x y)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (CMN x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADD {
 				break
 			}
@@ -20959,21 +20979,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMCMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMN, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(MULA x y a)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (CMN a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMMULA {
 				break
 			}
@@ -20984,24 +21006,26 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMCMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMN, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARMMUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARMMUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(ADDconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (CMNconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDconst {
 				break
 			}
@@ -21011,21 +21035,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMCMNconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(ADDshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (CMNshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftLL {
 				break
 			}
@@ -21036,22 +21062,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(ADDshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (CMNshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRL {
 				break
 			}
@@ -21062,22 +21090,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(ADDshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (CMNshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRA {
 				break
 			}
@@ -21088,22 +21118,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(ADDshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (CMNshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftLLreg {
 				break
 			}
@@ -21114,22 +21146,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(ADDshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (CMNshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRLreg {
 				break
 			}
@@ -21140,22 +21174,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(ADDshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (CMNshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRAreg {
 				break
 			}
@@ -21166,22 +21202,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(AND x y)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (TST x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMAND {
 				break
 			}
@@ -21191,21 +21229,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMTST, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTST, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(ANDconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (TSTconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDconst {
 				break
 			}
@@ -21215,21 +21255,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMTSTconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(ANDshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (TSTshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftLL {
 				break
 			}
@@ -21240,22 +21282,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(ANDshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (TSTshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRL {
 				break
 			}
@@ -21266,22 +21310,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(ANDshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (TSTshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRA {
 				break
 			}
@@ -21292,22 +21338,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(ANDshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (TSTshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftLLreg {
 				break
 			}
@@ -21318,22 +21366,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(ANDshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (TSTshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRLreg {
 				break
 			}
@@ -21344,22 +21394,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(ANDshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (TSTshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRAreg {
 				break
 			}
@@ -21370,22 +21422,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(XOR x y)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (TEQ x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXOR {
 				break
 			}
@@ -21395,21 +21449,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMTEQ, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQ, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(XORconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (TEQconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORconst {
 				break
 			}
@@ -21419,21 +21475,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMTEQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(XORshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (TEQshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftLL {
 				break
 			}
@@ -21444,22 +21502,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(XORshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (TEQshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRL {
 				break
 			}
@@ -21470,22 +21530,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(XORshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (TEQshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRA {
 				break
 			}
@@ -21496,22 +21558,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(XORshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (TEQshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftLLreg {
 				break
 			}
@@ -21522,22 +21586,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(XORshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (TEQshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRLreg {
 				break
 			}
@@ -21548,22 +21614,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] l:(XORshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (EQ (TEQshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRAreg {
 				break
 			}
@@ -21574,74 +21642,78 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMEQ
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 	case BlockARMGE:
 		// match: (GE (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GE (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GE (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (InvertFlags cmp) yes no)
 		// result: (LE cmp yes no)
-		for v.Op == OpARMInvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARMInvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARMLE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(SUB x y)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (CMP x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUB {
 				break
 			}
@@ -21651,21 +21723,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMP, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(MULS x y a)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (CMP a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMMULS {
 				break
 			}
@@ -21676,24 +21750,26 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMP, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARMMUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARMMUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(SUBconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (CMPconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBconst {
 				break
 			}
@@ -21703,21 +21779,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(SUBshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GE (CMPshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftLL {
 				break
 			}
@@ -21728,22 +21806,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(SUBshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GE (CMPshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRL {
 				break
 			}
@@ -21754,22 +21834,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(SUBshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GE (CMPshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRA {
 				break
 			}
@@ -21780,22 +21862,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(SUBshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (CMPshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftLLreg {
 				break
 			}
@@ -21806,22 +21890,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(SUBshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (CMPshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRLreg {
 				break
 			}
@@ -21832,22 +21918,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(SUBshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (CMPshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRAreg {
 				break
 			}
@@ -21858,22 +21946,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(ADD x y)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (CMN x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADD {
 				break
 			}
@@ -21883,21 +21973,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMCMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMN, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(MULA x y a)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (CMN a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMMULA {
 				break
 			}
@@ -21908,24 +22000,26 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMCMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMN, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARMMUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARMMUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(ADDconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (CMNconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDconst {
 				break
 			}
@@ -21935,21 +22029,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMCMNconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(ADDshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GE (CMNshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftLL {
 				break
 			}
@@ -21960,22 +22056,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(ADDshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GE (CMNshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRL {
 				break
 			}
@@ -21986,22 +22084,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(ADDshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GE (CMNshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRA {
 				break
 			}
@@ -22012,22 +22112,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(ADDshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (CMNshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftLLreg {
 				break
 			}
@@ -22038,22 +22140,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(ADDshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (CMNshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRLreg {
 				break
 			}
@@ -22064,22 +22168,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(ADDshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (CMNshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRAreg {
 				break
 			}
@@ -22090,22 +22196,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(AND x y)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (TST x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMAND {
 				break
 			}
@@ -22115,21 +22223,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMTST, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTST, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(ANDconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (TSTconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDconst {
 				break
 			}
@@ -22139,21 +22249,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMTSTconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(ANDshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GE (TSTshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftLL {
 				break
 			}
@@ -22164,22 +22276,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(ANDshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GE (TSTshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRL {
 				break
 			}
@@ -22190,22 +22304,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(ANDshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GE (TSTshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRA {
 				break
 			}
@@ -22216,22 +22332,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(ANDshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (TSTshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftLLreg {
 				break
 			}
@@ -22242,22 +22360,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(ANDshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (TSTshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRLreg {
 				break
 			}
@@ -22268,22 +22388,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(ANDshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (TSTshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRAreg {
 				break
 			}
@@ -22294,22 +22416,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(XOR x y)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (TEQ x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXOR {
 				break
 			}
@@ -22319,21 +22443,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMTEQ, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQ, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(XORconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (TEQconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORconst {
 				break
 			}
@@ -22343,21 +22469,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMTEQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(XORshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GE (TEQshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftLL {
 				break
 			}
@@ -22368,22 +22496,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(XORshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GE (TEQshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRL {
 				break
 			}
@@ -22394,22 +22524,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(XORshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GE (TEQshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRA {
 				break
 			}
@@ -22420,22 +22552,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(XORshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (TEQshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftLLreg {
 				break
 			}
@@ -22446,22 +22580,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(XORshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (TEQshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRLreg {
 				break
 			}
@@ -22472,22 +22608,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] l:(XORshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GE (TEQshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRAreg {
 				break
 			}
@@ -22498,75 +22636,79 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGE
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 	case BlockARMGT:
 		// match: (GT (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GT (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GT (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GT (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (InvertFlags cmp) yes no)
 		// result: (LT cmp yes no)
-		for v.Op == OpARMInvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARMInvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARMLT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(SUB x y)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (CMP x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUB {
 				break
 			}
@@ -22576,21 +22718,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMP, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(MULS x y a)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (CMP a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMMULS {
 				break
 			}
@@ -22601,24 +22745,26 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMP, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARMMUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARMMUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(SUBconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (CMPconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBconst {
 				break
 			}
@@ -22628,21 +22774,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(SUBshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GT (CMPshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftLL {
 				break
 			}
@@ -22653,22 +22801,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(SUBshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GT (CMPshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRL {
 				break
 			}
@@ -22679,22 +22829,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(SUBshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GT (CMPshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRA {
 				break
 			}
@@ -22705,22 +22857,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(SUBshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (CMPshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftLLreg {
 				break
 			}
@@ -22731,22 +22885,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(SUBshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (CMPshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRLreg {
 				break
 			}
@@ -22757,22 +22913,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(SUBshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (CMPshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRAreg {
 				break
 			}
@@ -22783,22 +22941,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(ADD x y)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (CMN x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADD {
 				break
 			}
@@ -22808,21 +22968,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMCMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMN, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(ADDconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (CMNconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDconst {
 				break
 			}
@@ -22832,21 +22994,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMCMNconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(ADDshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GT (CMNshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftLL {
 				break
 			}
@@ -22857,22 +23021,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(ADDshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GT (CMNshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRL {
 				break
 			}
@@ -22883,22 +23049,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(ADDshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GT (CMNshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRA {
 				break
 			}
@@ -22909,22 +23077,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(ADDshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (CMNshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftLLreg {
 				break
 			}
@@ -22935,22 +23105,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(ADDshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (CMNshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRLreg {
 				break
 			}
@@ -22961,22 +23133,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(ADDshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (CMNshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRAreg {
 				break
 			}
@@ -22987,22 +23161,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(AND x y)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (TST x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMAND {
 				break
 			}
@@ -23012,21 +23188,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMTST, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTST, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(MULA x y a)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (CMN a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMMULA {
 				break
 			}
@@ -23037,24 +23215,26 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMCMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMN, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARMMUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARMMUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(ANDconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (TSTconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDconst {
 				break
 			}
@@ -23064,21 +23244,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMTSTconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(ANDshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GT (TSTshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftLL {
 				break
 			}
@@ -23089,22 +23271,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(ANDshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GT (TSTshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRL {
 				break
 			}
@@ -23115,22 +23299,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(ANDshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GT (TSTshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRA {
 				break
 			}
@@ -23141,22 +23327,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(ANDshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (TSTshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftLLreg {
 				break
 			}
@@ -23167,22 +23355,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(ANDshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (TSTshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRLreg {
 				break
 			}
@@ -23193,22 +23383,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(ANDshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (TSTshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRAreg {
 				break
 			}
@@ -23219,22 +23411,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(XOR x y)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (TEQ x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXOR {
 				break
 			}
@@ -23244,21 +23438,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMTEQ, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQ, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(XORconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (TEQconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORconst {
 				break
 			}
@@ -23268,21 +23464,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMTEQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(XORshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GT (TEQshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftLL {
 				break
 			}
@@ -23293,22 +23491,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(XORshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GT (TEQshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRL {
 				break
 			}
@@ -23319,22 +23519,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(XORshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (GT (TEQshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRA {
 				break
 			}
@@ -23345,22 +23547,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(XORshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (TEQshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftLLreg {
 				break
 			}
@@ -23371,22 +23575,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(XORshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (TEQshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRLreg {
 				break
 			}
@@ -23397,22 +23603,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] l:(XORshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (GT (TEQshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRAreg {
 				break
 			}
@@ -23423,177 +23631,202 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMGT
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 	case BlockIf:
 		// match: (If (Equal cc) yes no)
 		// result: (EQ cc yes no)
-		for v.Op == OpARMEqual {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARMEqual {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARMEQ
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (NotEqual cc) yes no)
 		// result: (NE cc yes no)
-		for v.Op == OpARMNotEqual {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARMNotEqual {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARMNE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (LessThan cc) yes no)
 		// result: (LT cc yes no)
-		for v.Op == OpARMLessThan {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARMLessThan {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARMLT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (LessThanU cc) yes no)
 		// result: (ULT cc yes no)
-		for v.Op == OpARMLessThanU {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARMLessThanU {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARMULT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (LessEqual cc) yes no)
 		// result: (LE cc yes no)
-		for v.Op == OpARMLessEqual {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARMLessEqual {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARMLE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (LessEqualU cc) yes no)
 		// result: (ULE cc yes no)
-		for v.Op == OpARMLessEqualU {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARMLessEqualU {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARMULE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (GreaterThan cc) yes no)
 		// result: (GT cc yes no)
-		for v.Op == OpARMGreaterThan {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARMGreaterThan {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARMGT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (GreaterThanU cc) yes no)
 		// result: (UGT cc yes no)
-		for v.Op == OpARMGreaterThanU {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARMGreaterThanU {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARMUGT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (GreaterEqual cc) yes no)
 		// result: (GE cc yes no)
-		for v.Op == OpARMGreaterEqual {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARMGreaterEqual {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARMGE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (GreaterEqualU cc) yes no)
 		// result: (UGE cc yes no)
-		for v.Op == OpARMGreaterEqualU {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARMGreaterEqualU {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARMUGE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If cond yes no)
 		// result: (NE (CMPconst [0] cond) yes no)
 		for {
-			cond := b.Control
+			cond := b.Controls[0]
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(cond.Pos, OpARMCMPconst, types.TypeFlags)
 			v0.AuxInt = 0
 			v0.AddArg(cond)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 	case BlockARMLE:
 		// match: (LE (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LE (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LE (InvertFlags cmp) yes no)
 		// result: (GE cmp yes no)
-		for v.Op == OpARMInvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARMInvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARMGE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(SUB x y)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (CMP x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUB {
 				break
 			}
@@ -23603,21 +23836,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMP, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(MULS x y a)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (CMP a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMMULS {
 				break
 			}
@@ -23628,24 +23863,26 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMP, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARMMUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARMMUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(SUBconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (CMPconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBconst {
 				break
 			}
@@ -23655,21 +23892,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(SUBshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LE (CMPshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftLL {
 				break
 			}
@@ -23680,22 +23919,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(SUBshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LE (CMPshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRL {
 				break
 			}
@@ -23706,22 +23947,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(SUBshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LE (CMPshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRA {
 				break
 			}
@@ -23732,22 +23975,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(SUBshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (CMPshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftLLreg {
 				break
 			}
@@ -23758,22 +24003,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(SUBshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (CMPshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRLreg {
 				break
 			}
@@ -23784,22 +24031,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(SUBshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (CMPshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRAreg {
 				break
 			}
@@ -23810,22 +24059,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(ADD x y)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (CMN x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADD {
 				break
 			}
@@ -23835,21 +24086,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMCMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMN, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(MULA x y a)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (CMN a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMMULA {
 				break
 			}
@@ -23860,24 +24113,26 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMCMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMN, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARMMUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARMMUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(ADDconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (CMNconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDconst {
 				break
 			}
@@ -23887,21 +24142,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMCMNconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(ADDshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LE (CMNshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftLL {
 				break
 			}
@@ -23912,22 +24169,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(ADDshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LE (CMNshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRL {
 				break
 			}
@@ -23938,22 +24197,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(ADDshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LE (CMNshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRA {
 				break
 			}
@@ -23964,22 +24225,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(ADDshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (CMNshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftLLreg {
 				break
 			}
@@ -23990,22 +24253,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(ADDshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (CMNshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRLreg {
 				break
 			}
@@ -24016,22 +24281,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(ADDshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (CMNshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRAreg {
 				break
 			}
@@ -24042,22 +24309,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(AND x y)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (TST x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMAND {
 				break
 			}
@@ -24067,21 +24336,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMTST, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTST, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(ANDconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (TSTconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDconst {
 				break
 			}
@@ -24091,21 +24362,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMTSTconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(ANDshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LE (TSTshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftLL {
 				break
 			}
@@ -24116,22 +24389,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(ANDshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LE (TSTshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRL {
 				break
 			}
@@ -24142,22 +24417,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(ANDshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LE (TSTshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRA {
 				break
 			}
@@ -24168,22 +24445,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(ANDshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (TSTshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftLLreg {
 				break
 			}
@@ -24194,22 +24473,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(ANDshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (TSTshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRLreg {
 				break
 			}
@@ -24220,22 +24501,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(ANDshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (TSTshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRAreg {
 				break
 			}
@@ -24246,22 +24529,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(XOR x y)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (TEQ x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXOR {
 				break
 			}
@@ -24271,21 +24556,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMTEQ, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQ, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(XORconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (TEQconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORconst {
 				break
 			}
@@ -24295,21 +24582,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMTEQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(XORshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LE (TEQshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftLL {
 				break
 			}
@@ -24320,22 +24609,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(XORshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LE (TEQshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRL {
 				break
 			}
@@ -24346,22 +24637,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(XORshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LE (TEQshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRA {
 				break
 			}
@@ -24372,22 +24665,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(XORshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (TEQshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftLLreg {
 				break
 			}
@@ -24398,22 +24693,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(XORshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (TEQshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRLreg {
 				break
 			}
@@ -24424,22 +24721,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] l:(XORshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LE (TEQshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRAreg {
 				break
 			}
@@ -24450,75 +24749,79 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLE
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 	case BlockARMLT:
 		// match: (LT (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LT (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LT (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LT (InvertFlags cmp) yes no)
 		// result: (GT cmp yes no)
-		for v.Op == OpARMInvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARMInvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARMGT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(SUB x y)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (CMP x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUB {
 				break
 			}
@@ -24528,21 +24831,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMP, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(MULS x y a)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (CMP a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMMULS {
 				break
 			}
@@ -24553,24 +24858,26 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMP, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARMMUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARMMUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(SUBconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (CMPconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBconst {
 				break
 			}
@@ -24580,21 +24887,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(SUBshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LT (CMPshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftLL {
 				break
 			}
@@ -24605,22 +24914,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(SUBshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LT (CMPshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRL {
 				break
 			}
@@ -24631,22 +24942,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(SUBshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LT (CMPshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRA {
 				break
 			}
@@ -24657,22 +24970,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(SUBshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (CMPshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftLLreg {
 				break
 			}
@@ -24683,22 +24998,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(SUBshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (CMPshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRLreg {
 				break
 			}
@@ -24709,22 +25026,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(SUBshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (CMPshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRAreg {
 				break
 			}
@@ -24735,22 +25054,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(ADD x y)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (CMN x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADD {
 				break
 			}
@@ -24760,21 +25081,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMCMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMN, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(MULA x y a)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (CMN a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMMULA {
 				break
 			}
@@ -24785,24 +25108,26 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMCMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMN, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARMMUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARMMUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(ADDconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (CMNconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDconst {
 				break
 			}
@@ -24812,21 +25137,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMCMNconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(ADDshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LT (CMNshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftLL {
 				break
 			}
@@ -24837,22 +25164,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(ADDshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LT (CMNshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRL {
 				break
 			}
@@ -24863,22 +25192,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(ADDshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LT (CMNshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRA {
 				break
 			}
@@ -24889,22 +25220,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(ADDshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (CMNshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftLLreg {
 				break
 			}
@@ -24915,22 +25248,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(ADDshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (CMNshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRLreg {
 				break
 			}
@@ -24941,22 +25276,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(ADDshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (CMNshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRAreg {
 				break
 			}
@@ -24967,22 +25304,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(AND x y)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (TST x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMAND {
 				break
 			}
@@ -24992,21 +25331,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMTST, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTST, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(ANDconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (TSTconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDconst {
 				break
 			}
@@ -25016,21 +25357,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMTSTconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(ANDshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LT (TSTshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftLL {
 				break
 			}
@@ -25041,22 +25384,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(ANDshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LT (TSTshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRL {
 				break
 			}
@@ -25067,22 +25412,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(ANDshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LT (TSTshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRA {
 				break
 			}
@@ -25093,22 +25440,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(ANDshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (TSTshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftLLreg {
 				break
 			}
@@ -25119,22 +25468,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(ANDshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (TSTshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRLreg {
 				break
 			}
@@ -25145,22 +25496,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(ANDshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (TSTshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRAreg {
 				break
 			}
@@ -25171,22 +25524,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(XOR x y)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (TEQ x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXOR {
 				break
 			}
@@ -25196,21 +25551,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMTEQ, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQ, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(XORconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (TEQconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORconst {
 				break
 			}
@@ -25220,21 +25577,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMTEQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(XORshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LT (TEQshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftLL {
 				break
 			}
@@ -25245,22 +25604,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(XORshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LT (TEQshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRL {
 				break
 			}
@@ -25271,22 +25632,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(XORshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (LT (TEQshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRA {
 				break
 			}
@@ -25297,22 +25660,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(XORshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (TEQshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftLLreg {
 				break
 			}
@@ -25323,22 +25688,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(XORshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (TEQshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRLreg {
 				break
 			}
@@ -25349,22 +25716,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] l:(XORshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (LT (TEQshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRAreg {
 				break
 			}
@@ -25375,233 +25744,257 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMLT
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 	case BlockARMNE:
 		// match: (NE (CMPconst [0] (Equal cc)) yes no)
 		// result: (EQ cc yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpARMEqual {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpARMEqual {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockARMEQ
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] (NotEqual cc)) yes no)
 		// result: (NE cc yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpARMNotEqual {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpARMNotEqual {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockARMNE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] (LessThan cc)) yes no)
 		// result: (LT cc yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpARMLessThan {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpARMLessThan {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockARMLT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] (LessThanU cc)) yes no)
 		// result: (ULT cc yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpARMLessThanU {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpARMLessThanU {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockARMULT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] (LessEqual cc)) yes no)
 		// result: (LE cc yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpARMLessEqual {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpARMLessEqual {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockARMLE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] (LessEqualU cc)) yes no)
 		// result: (ULE cc yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpARMLessEqualU {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpARMLessEqualU {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockARMULE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] (GreaterThan cc)) yes no)
 		// result: (GT cc yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpARMGreaterThan {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpARMGreaterThan {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockARMGT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] (GreaterThanU cc)) yes no)
 		// result: (UGT cc yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpARMGreaterThanU {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpARMGreaterThanU {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockARMUGT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] (GreaterEqual cc)) yes no)
 		// result: (GE cc yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpARMGreaterEqual {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpARMGreaterEqual {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockARMGE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] (GreaterEqualU cc)) yes no)
 		// result: (UGE cc yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpARMGreaterEqualU {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpARMGreaterEqualU {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockARMUGE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (NE (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (InvertFlags cmp) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == OpARMInvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARMInvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARMNE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(SUB x y)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (CMP x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUB {
 				break
 			}
@@ -25611,21 +26004,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMP, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(MULS x y a)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (CMP a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMMULS {
 				break
 			}
@@ -25636,24 +26031,26 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMP, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARMMUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARMMUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(SUBconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (CMPconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBconst {
 				break
 			}
@@ -25663,21 +26060,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(SUBshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (NE (CMPshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftLL {
 				break
 			}
@@ -25688,22 +26087,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(SUBshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (NE (CMPshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRL {
 				break
 			}
@@ -25714,22 +26115,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(SUBshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (NE (CMPshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRA {
 				break
 			}
@@ -25740,22 +26143,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(SUBshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (CMPshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftLLreg {
 				break
 			}
@@ -25766,22 +26171,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(SUBshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (CMPshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRLreg {
 				break
 			}
@@ -25792,22 +26199,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(SUBshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (CMPshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMSUBshiftRAreg {
 				break
 			}
@@ -25818,22 +26227,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMPshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMPshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(ADD x y)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (CMN x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADD {
 				break
 			}
@@ -25843,21 +26254,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMN, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(MULA x y a)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (CMN a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMMULA {
 				break
 			}
@@ -25868,24 +26281,26 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMN, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARMMUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARMMUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(ADDconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (CMNconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDconst {
 				break
 			}
@@ -25895,21 +26310,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMNconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(ADDshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (NE (CMNshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftLL {
 				break
 			}
@@ -25920,22 +26337,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(ADDshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (NE (CMNshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRL {
 				break
 			}
@@ -25946,22 +26365,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(ADDshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (NE (CMNshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRA {
 				break
 			}
@@ -25972,22 +26393,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(ADDshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (CMNshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftLLreg {
 				break
 			}
@@ -25998,22 +26421,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(ADDshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (CMNshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRLreg {
 				break
 			}
@@ -26024,22 +26449,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(ADDshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (CMNshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMADDshiftRAreg {
 				break
 			}
@@ -26050,22 +26477,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMCMNshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMCMNshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(AND x y)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (TST x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMAND {
 				break
 			}
@@ -26075,21 +26504,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMTST, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTST, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(ANDconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (TSTconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDconst {
 				break
 			}
@@ -26099,21 +26530,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMTSTconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(ANDshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (NE (TSTshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftLL {
 				break
 			}
@@ -26124,22 +26557,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(ANDshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (NE (TSTshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRL {
 				break
 			}
@@ -26150,22 +26585,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(ANDshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (NE (TSTshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRA {
 				break
 			}
@@ -26176,22 +26613,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(ANDshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (TSTshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftLLreg {
 				break
 			}
@@ -26202,22 +26641,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(ANDshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (TSTshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRLreg {
 				break
 			}
@@ -26228,22 +26669,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(ANDshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (TSTshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMANDshiftRAreg {
 				break
 			}
@@ -26254,22 +26697,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMTSTshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTSTshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(XOR x y)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (TEQ x y) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXOR {
 				break
 			}
@@ -26279,21 +26724,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMTEQ, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQ, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(XORconst [c] x)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (TEQconst [c] x) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORconst {
 				break
 			}
@@ -26303,21 +26750,23 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMTEQconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(XORshiftLL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (NE (TEQshiftLL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftLL {
 				break
 			}
@@ -26328,22 +26777,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftLL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftLL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(XORshiftRL x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (NE (TEQshiftRL x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRL {
 				break
 			}
@@ -26354,22 +26805,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRL, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRL, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(XORshiftRA x y [c])) yes no)
 		// cond: l.Uses==1
 		// result: (NE (TEQshiftRA x y [c]) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRA {
 				break
 			}
@@ -26380,22 +26833,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRA, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRA, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(XORshiftLLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (TEQshiftLLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftLLreg {
 				break
 			}
@@ -26406,22 +26861,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftLLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftLLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(XORshiftRLreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (TEQshiftRLreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRLreg {
 				break
 			}
@@ -26432,22 +26889,24 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRLreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRLreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] l:(XORshiftRAreg x y z)) yes no)
 		// cond: l.Uses==1
 		// result: (NE (TEQshiftRAreg x y z) yes no)
-		for v.Op == OpARMCMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARMCMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			l := v.Args[0]
+			l := v_0.Args[0]
 			if l.Op != OpARMXORshiftRAreg {
 				break
 			}
@@ -26458,221 +26917,230 @@ func rewriteBlockARM(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARMNE
-			v0 := b.NewValue0(v.Pos, OpARMTEQshiftRAreg, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARMTEQshiftRAreg, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
 			v0.AddArg(z)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 	case BlockARMUGE:
 		// match: (UGE (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (UGE (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGE (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (UGE (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGE (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (UGE (InvertFlags cmp) yes no)
 		// result: (ULE cmp yes no)
-		for v.Op == OpARMInvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARMInvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARMULE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 	case BlockARMUGT:
 		// match: (UGT (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGT (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGT (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (UGT (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGT (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (UGT (InvertFlags cmp) yes no)
 		// result: (ULT cmp yes no)
-		for v.Op == OpARMInvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARMInvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARMULT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 	case BlockARMULE:
 		// match: (ULE (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULE (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULE (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (ULE (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULE (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (ULE (InvertFlags cmp) yes no)
 		// result: (UGE cmp yes no)
-		for v.Op == OpARMInvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARMInvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARMUGE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 	case BlockARMULT:
 		// match: (ULT (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (ULT (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULT (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (ULT (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARMFlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARMFlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULT (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARMFlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARMFlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (ULT (InvertFlags cmp) yes no)
 		// result: (UGT cmp yes no)
-		for v.Op == OpARMInvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARMInvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARMUGT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
diff --git a/src/cmd/compile/internal/ssa/rewriteARM64.go b/src/cmd/compile/internal/ssa/rewriteARM64.go
index f6f8301853..66db390e59 100644
--- a/src/cmd/compile/internal/ssa/rewriteARM64.go
+++ b/src/cmd/compile/internal/ssa/rewriteARM64.go
@@ -33280,17 +33280,17 @@ func rewriteValueARM64_OpZeroExt8to64_0(v *Value) bool {
 	}
 }
 func rewriteBlockARM64(b *Block) bool {
-	v := b.Control
 	switch b.Kind {
 	case BlockARM64EQ:
 		// match: (EQ (CMPWconst [0] x:(ANDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (EQ (TSTWconst [c] y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ANDconst {
 				break
 			}
@@ -33300,21 +33300,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64EQ
-			v0 := b.NewValue0(v.Pos, OpARM64TSTWconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TSTWconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] z:(AND x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (EQ (TST x y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64AND {
 				break
 			}
@@ -33324,21 +33326,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64EQ
-			v0 := b.NewValue0(v.Pos, OpARM64TST, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TST, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPWconst [0] z:(AND x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (EQ (TSTW x y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64AND {
 				break
 			}
@@ -33348,21 +33352,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64EQ
-			v0 := b.NewValue0(v.Pos, OpARM64TSTW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TSTW, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] x:(ANDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (EQ (TSTconst [c] y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ANDconst {
 				break
 			}
@@ -33372,21 +33378,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64EQ
-			v0 := b.NewValue0(v.Pos, OpARM64TSTconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TSTconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] x:(ADDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (EQ (CMNconst [c] y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ADDconst {
 				break
 			}
@@ -33396,21 +33404,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64EQ
-			v0 := b.NewValue0(v.Pos, OpARM64CMNconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPWconst [0] x:(ADDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (EQ (CMNWconst [c] y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ADDconst {
 				break
 			}
@@ -33420,21 +33430,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64EQ
-			v0 := b.NewValue0(v.Pos, OpARM64CMNWconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNWconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] z:(ADD x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (EQ (CMN x y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64ADD {
 				break
 			}
@@ -33444,21 +33456,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64EQ
-			v0 := b.NewValue0(v.Pos, OpARM64CMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMN, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPWconst [0] z:(ADD x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (EQ (CMNW x y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64ADD {
 				break
 			}
@@ -33468,20 +33482,22 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64EQ
-			v0 := b.NewValue0(v.Pos, OpARM64CMNW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNW, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMP x z:(NEG y)) yes no)
 		// cond: z.Uses == 1
 		// result: (EQ (CMN x y) yes no)
-		for v.Op == OpARM64CMP {
-			_ = v.Args[1]
-			x := v.Args[0]
-			z := v.Args[1]
+		for b.Controls[0].Op == OpARM64CMP {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			z := v_0.Args[1]
 			if z.Op != OpARM64NEG {
 				break
 			}
@@ -33490,20 +33506,22 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64EQ
-			v0 := b.NewValue0(v.Pos, OpARM64CMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMN, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPW x z:(NEG y)) yes no)
 		// cond: z.Uses == 1
 		// result: (EQ (CMNW x y) yes no)
-		for v.Op == OpARM64CMPW {
-			_ = v.Args[1]
-			x := v.Args[0]
-			z := v.Args[1]
+		for b.Controls[0].Op == OpARM64CMPW {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			z := v_0.Args[1]
 			if z.Op != OpARM64NEG {
 				break
 			}
@@ -33512,45 +33530,51 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64EQ
-			v0 := b.NewValue0(v.Pos, OpARM64CMNW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNW, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] x) yes no)
 		// result: (Z x yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			b.Kind = BlockARM64Z
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPWconst [0] x) yes no)
 		// result: (ZW x yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			b.Kind = BlockARM64ZW
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] z:(MADD a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (EQ (CMN a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MADD {
 				break
 			}
@@ -33561,24 +33585,26 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64EQ
-			v0 := b.NewValue0(v.Pos, OpARM64CMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMN, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] z:(MSUB a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (EQ (CMP a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MSUB {
 				break
 			}
@@ -33589,24 +33615,26 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64EQ
-			v0 := b.NewValue0(v.Pos, OpARM64CMP, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMP, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPWconst [0] z:(MADDW a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (EQ (CMNW a (MULW <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MADDW {
 				break
 			}
@@ -33617,24 +33645,26 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64EQ
-			v0 := b.NewValue0(v.Pos, OpARM64CMNW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNW, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MULW, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MULW, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPWconst [0] z:(MSUBW a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (EQ (CMPW a (MULW <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MSUBW {
 				break
 			}
@@ -33645,134 +33675,149 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64EQ
-			v0 := b.NewValue0(v.Pos, OpARM64CMPW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMPW, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MULW, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MULW, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (TSTconst [c] x) yes no)
 		// cond: oneBit(c)
 		// result: (TBZ {ntz(c)} x yes no)
-		for v.Op == OpARM64TSTconst {
-			c := v.AuxInt
-			x := v.Args[0]
+		for b.Controls[0].Op == OpARM64TSTconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
+			x := v_0.Args[0]
 			if !(oneBit(c)) {
 				break
 			}
 			b.Kind = BlockARM64TBZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = ntz(c)
 			return true
 		}
 		// match: (EQ (TSTWconst [c] x) yes no)
 		// cond: oneBit(int64(uint32(c)))
 		// result: (TBZ {ntz(int64(uint32(c)))} x yes no)
-		for v.Op == OpARM64TSTWconst {
-			c := v.AuxInt
-			x := v.Args[0]
+		for b.Controls[0].Op == OpARM64TSTWconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
+			x := v_0.Args[0]
 			if !(oneBit(int64(uint32(c)))) {
 				break
 			}
 			b.Kind = BlockARM64TBZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = ntz(int64(uint32(c)))
 			return true
 		}
 		// match: (EQ (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (EQ (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (EQ (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (EQ (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (EQ (InvertFlags cmp) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == OpARM64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARM64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARM64EQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 	case BlockARM64FGE:
 		// match: (FGE (InvertFlags cmp) yes no)
 		// result: (FLE cmp yes no)
-		for v.Op == OpARM64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARM64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARM64FLE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 	case BlockARM64FGT:
 		// match: (FGT (InvertFlags cmp) yes no)
 		// result: (FLT cmp yes no)
-		for v.Op == OpARM64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARM64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARM64FLT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 	case BlockARM64FLE:
 		// match: (FLE (InvertFlags cmp) yes no)
 		// result: (FGE cmp yes no)
-		for v.Op == OpARM64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARM64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARM64FGE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 	case BlockARM64FLT:
 		// match: (FLT (InvertFlags cmp) yes no)
 		// result: (FGT cmp yes no)
-		for v.Op == OpARM64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARM64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARM64FGT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
@@ -33780,11 +33825,12 @@ func rewriteBlockARM64(b *Block) bool {
 		// match: (GE (CMPWconst [0] x:(ANDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (GE (TSTWconst [c] y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ANDconst {
 				break
 			}
@@ -33794,21 +33840,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GE
-			v0 := b.NewValue0(v.Pos, OpARM64TSTWconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TSTWconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] z:(AND x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (GE (TST x y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64AND {
 				break
 			}
@@ -33818,21 +33866,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GE
-			v0 := b.NewValue0(v.Pos, OpARM64TST, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TST, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPWconst [0] z:(AND x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (GE (TSTW x y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64AND {
 				break
 			}
@@ -33842,21 +33892,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GE
-			v0 := b.NewValue0(v.Pos, OpARM64TSTW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TSTW, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] x:(ANDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (GE (TSTconst [c] y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ANDconst {
 				break
 			}
@@ -33866,21 +33918,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GE
-			v0 := b.NewValue0(v.Pos, OpARM64TSTconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TSTconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] x:(ADDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (GE (CMNconst [c] y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ADDconst {
 				break
 			}
@@ -33890,21 +33944,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GE
-			v0 := b.NewValue0(v.Pos, OpARM64CMNconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPWconst [0] x:(ADDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (GE (CMNWconst [c] y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ADDconst {
 				break
 			}
@@ -33914,21 +33970,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GE
-			v0 := b.NewValue0(v.Pos, OpARM64CMNWconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNWconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] z:(ADD x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (GE (CMN x y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64ADD {
 				break
 			}
@@ -33938,21 +33996,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GE
-			v0 := b.NewValue0(v.Pos, OpARM64CMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMN, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPWconst [0] z:(ADD x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (GE (CMNW x y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64ADD {
 				break
 			}
@@ -33962,20 +34022,22 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GE
-			v0 := b.NewValue0(v.Pos, OpARM64CMNW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNW, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMP x z:(NEG y)) yes no)
 		// cond: z.Uses == 1
 		// result: (GE (CMN x y) yes no)
-		for v.Op == OpARM64CMP {
-			_ = v.Args[1]
-			x := v.Args[0]
-			z := v.Args[1]
+		for b.Controls[0].Op == OpARM64CMP {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			z := v_0.Args[1]
 			if z.Op != OpARM64NEG {
 				break
 			}
@@ -33984,20 +34046,22 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GE
-			v0 := b.NewValue0(v.Pos, OpARM64CMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMN, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPW x z:(NEG y)) yes no)
 		// cond: z.Uses == 1
 		// result: (GE (CMNW x y) yes no)
-		for v.Op == OpARM64CMPW {
-			_ = v.Args[1]
-			x := v.Args[0]
-			z := v.Args[1]
+		for b.Controls[0].Op == OpARM64CMPW {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			z := v_0.Args[1]
 			if z.Op != OpARM64NEG {
 				break
 			}
@@ -34006,21 +34070,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GE
-			v0 := b.NewValue0(v.Pos, OpARM64CMNW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNW, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] z:(MADD a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (GE (CMN a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MADD {
 				break
 			}
@@ -34031,24 +34097,26 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GE
-			v0 := b.NewValue0(v.Pos, OpARM64CMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMN, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] z:(MSUB a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (GE (CMP a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MSUB {
 				break
 			}
@@ -34059,24 +34127,26 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GE
-			v0 := b.NewValue0(v.Pos, OpARM64CMP, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMP, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPWconst [0] z:(MADDW a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (GE (CMNW a (MULW <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MADDW {
 				break
 			}
@@ -34087,24 +34157,26 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GE
-			v0 := b.NewValue0(v.Pos, OpARM64CMNW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNW, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MULW, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MULW, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPWconst [0] z:(MSUBW a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (GE (CMPW a (MULW <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MSUBW {
 				break
 			}
@@ -34115,88 +34187,95 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GE
-			v0 := b.NewValue0(v.Pos, OpARM64CMPW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMPW, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MULW, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MULW, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPWconst [0] x) yes no)
 		// result: (TBZ {int64(31)} x yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			b.Kind = BlockARM64TBZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = int64(31)
 			return true
 		}
 		// match: (GE (CMPconst [0] x) yes no)
 		// result: (TBZ {int64(63)} x yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			b.Kind = BlockARM64TBZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = int64(63)
 			return true
 		}
 		// match: (GE (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GE (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GE (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (InvertFlags cmp) yes no)
 		// result: (LE cmp yes no)
-		for v.Op == OpARM64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARM64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARM64LE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
@@ -34204,11 +34283,12 @@ func rewriteBlockARM64(b *Block) bool {
 		// match: (GT (CMPWconst [0] x:(ANDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (GT (TSTWconst [c] y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ANDconst {
 				break
 			}
@@ -34218,21 +34298,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GT
-			v0 := b.NewValue0(v.Pos, OpARM64TSTWconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TSTWconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] z:(AND x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (GT (TST x y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64AND {
 				break
 			}
@@ -34242,21 +34324,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GT
-			v0 := b.NewValue0(v.Pos, OpARM64TST, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TST, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPWconst [0] z:(AND x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (GT (TSTW x y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64AND {
 				break
 			}
@@ -34266,21 +34350,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GT
-			v0 := b.NewValue0(v.Pos, OpARM64TSTW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TSTW, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] x:(ANDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (GT (TSTconst [c] y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ANDconst {
 				break
 			}
@@ -34290,21 +34376,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GT
-			v0 := b.NewValue0(v.Pos, OpARM64TSTconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TSTconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] x:(ADDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (GT (CMNconst [c] y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ADDconst {
 				break
 			}
@@ -34314,21 +34402,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GT
-			v0 := b.NewValue0(v.Pos, OpARM64CMNconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPWconst [0] x:(ADDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (GT (CMNWconst [c] y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ADDconst {
 				break
 			}
@@ -34338,21 +34428,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GT
-			v0 := b.NewValue0(v.Pos, OpARM64CMNWconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNWconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] z:(ADD x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (GT (CMN x y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64ADD {
 				break
 			}
@@ -34362,21 +34454,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GT
-			v0 := b.NewValue0(v.Pos, OpARM64CMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMN, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPWconst [0] z:(ADD x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (GT (CMNW x y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64ADD {
 				break
 			}
@@ -34386,20 +34480,22 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GT
-			v0 := b.NewValue0(v.Pos, OpARM64CMNW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNW, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMP x z:(NEG y)) yes no)
 		// cond: z.Uses == 1
 		// result: (GT (CMN x y) yes no)
-		for v.Op == OpARM64CMP {
-			_ = v.Args[1]
-			x := v.Args[0]
-			z := v.Args[1]
+		for b.Controls[0].Op == OpARM64CMP {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			z := v_0.Args[1]
 			if z.Op != OpARM64NEG {
 				break
 			}
@@ -34408,20 +34504,22 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GT
-			v0 := b.NewValue0(v.Pos, OpARM64CMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMN, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPW x z:(NEG y)) yes no)
 		// cond: z.Uses == 1
 		// result: (GT (CMNW x y) yes no)
-		for v.Op == OpARM64CMPW {
-			_ = v.Args[1]
-			x := v.Args[0]
-			z := v.Args[1]
+		for b.Controls[0].Op == OpARM64CMPW {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			z := v_0.Args[1]
 			if z.Op != OpARM64NEG {
 				break
 			}
@@ -34430,21 +34528,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GT
-			v0 := b.NewValue0(v.Pos, OpARM64CMNW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNW, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] z:(MADD a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (GT (CMN a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MADD {
 				break
 			}
@@ -34455,24 +34555,26 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GT
-			v0 := b.NewValue0(v.Pos, OpARM64CMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMN, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] z:(MSUB a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (GT (CMP a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MSUB {
 				break
 			}
@@ -34483,24 +34585,26 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GT
-			v0 := b.NewValue0(v.Pos, OpARM64CMP, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMP, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPWconst [0] z:(MADDW a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (GT (CMNW a (MULW <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MADDW {
 				break
 			}
@@ -34511,24 +34615,26 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GT
-			v0 := b.NewValue0(v.Pos, OpARM64CMNW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNW, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MULW, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MULW, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPWconst [0] z:(MSUBW a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (GT (CMPW a (MULW <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MSUBW {
 				break
 			}
@@ -34539,201 +34645,233 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64GT
-			v0 := b.NewValue0(v.Pos, OpARM64CMPW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMPW, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MULW, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MULW, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GT (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GT (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GT (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (InvertFlags cmp) yes no)
 		// result: (LT cmp yes no)
-		for v.Op == OpARM64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARM64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARM64LT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 	case BlockIf:
 		// match: (If (Equal cc) yes no)
 		// result: (EQ cc yes no)
-		for v.Op == OpARM64Equal {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64Equal {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64EQ
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (NotEqual cc) yes no)
 		// result: (NE cc yes no)
-		for v.Op == OpARM64NotEqual {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64NotEqual {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64NE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (LessThan cc) yes no)
 		// result: (LT cc yes no)
-		for v.Op == OpARM64LessThan {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64LessThan {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64LT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (LessThanU cc) yes no)
 		// result: (ULT cc yes no)
-		for v.Op == OpARM64LessThanU {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64LessThanU {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64ULT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (LessEqual cc) yes no)
 		// result: (LE cc yes no)
-		for v.Op == OpARM64LessEqual {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64LessEqual {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64LE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (LessEqualU cc) yes no)
 		// result: (ULE cc yes no)
-		for v.Op == OpARM64LessEqualU {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64LessEqualU {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64ULE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (GreaterThan cc) yes no)
 		// result: (GT cc yes no)
-		for v.Op == OpARM64GreaterThan {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64GreaterThan {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64GT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (GreaterThanU cc) yes no)
 		// result: (UGT cc yes no)
-		for v.Op == OpARM64GreaterThanU {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64GreaterThanU {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64UGT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (GreaterEqual cc) yes no)
 		// result: (GE cc yes no)
-		for v.Op == OpARM64GreaterEqual {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64GreaterEqual {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64GE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (GreaterEqualU cc) yes no)
 		// result: (UGE cc yes no)
-		for v.Op == OpARM64GreaterEqualU {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64GreaterEqualU {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64UGE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (LessThanF cc) yes no)
 		// result: (FLT cc yes no)
-		for v.Op == OpARM64LessThanF {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64LessThanF {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64FLT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (LessEqualF cc) yes no)
 		// result: (FLE cc yes no)
-		for v.Op == OpARM64LessEqualF {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64LessEqualF {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64FLE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (GreaterThanF cc) yes no)
 		// result: (FGT cc yes no)
-		for v.Op == OpARM64GreaterThanF {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64GreaterThanF {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64FGT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (GreaterEqualF cc) yes no)
 		// result: (FGE cc yes no)
-		for v.Op == OpARM64GreaterEqualF {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64GreaterEqualF {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64FGE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If cond yes no)
 		// result: (NZ cond yes no)
 		for {
-			cond := b.Control
+			cond := b.Controls[0]
 			b.Kind = BlockARM64NZ
-			b.SetControl(cond)
+			b.ResetControls()
+			b.AddControl(cond)
 			b.Aux = nil
 			return true
 		}
@@ -34741,11 +34879,12 @@ func rewriteBlockARM64(b *Block) bool {
 		// match: (LE (CMPWconst [0] x:(ANDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (LE (TSTWconst [c] y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ANDconst {
 				break
 			}
@@ -34755,21 +34894,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LE
-			v0 := b.NewValue0(v.Pos, OpARM64TSTWconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TSTWconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] z:(AND x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (LE (TST x y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64AND {
 				break
 			}
@@ -34779,21 +34920,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LE
-			v0 := b.NewValue0(v.Pos, OpARM64TST, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TST, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPWconst [0] z:(AND x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (LE (TSTW x y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64AND {
 				break
 			}
@@ -34803,21 +34946,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LE
-			v0 := b.NewValue0(v.Pos, OpARM64TSTW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TSTW, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] x:(ANDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (LE (TSTconst [c] y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ANDconst {
 				break
 			}
@@ -34827,21 +34972,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LE
-			v0 := b.NewValue0(v.Pos, OpARM64TSTconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TSTconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] x:(ADDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (LE (CMNconst [c] y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ADDconst {
 				break
 			}
@@ -34851,21 +34998,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LE
-			v0 := b.NewValue0(v.Pos, OpARM64CMNconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPWconst [0] x:(ADDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (LE (CMNWconst [c] y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ADDconst {
 				break
 			}
@@ -34875,21 +35024,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LE
-			v0 := b.NewValue0(v.Pos, OpARM64CMNWconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNWconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] z:(ADD x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (LE (CMN x y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64ADD {
 				break
 			}
@@ -34899,21 +35050,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LE
-			v0 := b.NewValue0(v.Pos, OpARM64CMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMN, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPWconst [0] z:(ADD x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (LE (CMNW x y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64ADD {
 				break
 			}
@@ -34923,20 +35076,22 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LE
-			v0 := b.NewValue0(v.Pos, OpARM64CMNW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNW, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMP x z:(NEG y)) yes no)
 		// cond: z.Uses == 1
 		// result: (LE (CMN x y) yes no)
-		for v.Op == OpARM64CMP {
-			_ = v.Args[1]
-			x := v.Args[0]
-			z := v.Args[1]
+		for b.Controls[0].Op == OpARM64CMP {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			z := v_0.Args[1]
 			if z.Op != OpARM64NEG {
 				break
 			}
@@ -34945,20 +35100,22 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LE
-			v0 := b.NewValue0(v.Pos, OpARM64CMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMN, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPW x z:(NEG y)) yes no)
 		// cond: z.Uses == 1
 		// result: (LE (CMNW x y) yes no)
-		for v.Op == OpARM64CMPW {
-			_ = v.Args[1]
-			x := v.Args[0]
-			z := v.Args[1]
+		for b.Controls[0].Op == OpARM64CMPW {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			z := v_0.Args[1]
 			if z.Op != OpARM64NEG {
 				break
 			}
@@ -34967,21 +35124,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LE
-			v0 := b.NewValue0(v.Pos, OpARM64CMNW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNW, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] z:(MADD a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (LE (CMN a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MADD {
 				break
 			}
@@ -34992,24 +35151,26 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LE
-			v0 := b.NewValue0(v.Pos, OpARM64CMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMN, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] z:(MSUB a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (LE (CMP a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MSUB {
 				break
 			}
@@ -35020,24 +35181,26 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LE
-			v0 := b.NewValue0(v.Pos, OpARM64CMP, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMP, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPWconst [0] z:(MADDW a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (LE (CMNW a (MULW <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MADDW {
 				break
 			}
@@ -35048,24 +35211,26 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LE
-			v0 := b.NewValue0(v.Pos, OpARM64CMNW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNW, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MULW, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MULW, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPWconst [0] z:(MSUBW a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (LE (CMPW a (MULW <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MSUBW {
 				break
 			}
@@ -35076,64 +35241,67 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LE
-			v0 := b.NewValue0(v.Pos, OpARM64CMPW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMPW, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MULW, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MULW, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LE (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LE (InvertFlags cmp) yes no)
 		// result: (GE cmp yes no)
-		for v.Op == OpARM64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARM64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARM64GE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
@@ -35141,11 +35309,12 @@ func rewriteBlockARM64(b *Block) bool {
 		// match: (LT (CMPWconst [0] x:(ANDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (LT (TSTWconst [c] y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ANDconst {
 				break
 			}
@@ -35155,21 +35324,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LT
-			v0 := b.NewValue0(v.Pos, OpARM64TSTWconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TSTWconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] z:(AND x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (LT (TST x y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64AND {
 				break
 			}
@@ -35179,21 +35350,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LT
-			v0 := b.NewValue0(v.Pos, OpARM64TST, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TST, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPWconst [0] z:(AND x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (LT (TSTW x y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64AND {
 				break
 			}
@@ -35203,21 +35376,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LT
-			v0 := b.NewValue0(v.Pos, OpARM64TSTW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TSTW, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] x:(ANDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (LT (TSTconst [c] y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ANDconst {
 				break
 			}
@@ -35227,21 +35402,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LT
-			v0 := b.NewValue0(v.Pos, OpARM64TSTconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TSTconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] x:(ADDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (LT (CMNconst [c] y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ADDconst {
 				break
 			}
@@ -35251,21 +35428,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LT
-			v0 := b.NewValue0(v.Pos, OpARM64CMNconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPWconst [0] x:(ADDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (LT (CMNWconst [c] y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ADDconst {
 				break
 			}
@@ -35275,21 +35454,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LT
-			v0 := b.NewValue0(v.Pos, OpARM64CMNWconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNWconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] z:(ADD x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (LT (CMN x y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64ADD {
 				break
 			}
@@ -35299,21 +35480,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LT
-			v0 := b.NewValue0(v.Pos, OpARM64CMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMN, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPWconst [0] z:(ADD x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (LT (CMNW x y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64ADD {
 				break
 			}
@@ -35323,20 +35506,22 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LT
-			v0 := b.NewValue0(v.Pos, OpARM64CMNW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNW, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMP x z:(NEG y)) yes no)
 		// cond: z.Uses == 1
 		// result: (LT (CMN x y) yes no)
-		for v.Op == OpARM64CMP {
-			_ = v.Args[1]
-			x := v.Args[0]
-			z := v.Args[1]
+		for b.Controls[0].Op == OpARM64CMP {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			z := v_0.Args[1]
 			if z.Op != OpARM64NEG {
 				break
 			}
@@ -35345,20 +35530,22 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LT
-			v0 := b.NewValue0(v.Pos, OpARM64CMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMN, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPW x z:(NEG y)) yes no)
 		// cond: z.Uses == 1
 		// result: (LT (CMNW x y) yes no)
-		for v.Op == OpARM64CMPW {
-			_ = v.Args[1]
-			x := v.Args[0]
-			z := v.Args[1]
+		for b.Controls[0].Op == OpARM64CMPW {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			z := v_0.Args[1]
 			if z.Op != OpARM64NEG {
 				break
 			}
@@ -35367,21 +35554,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LT
-			v0 := b.NewValue0(v.Pos, OpARM64CMNW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNW, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] z:(MADD a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (LT (CMN a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MADD {
 				break
 			}
@@ -35392,24 +35581,26 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LT
-			v0 := b.NewValue0(v.Pos, OpARM64CMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMN, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] z:(MSUB a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (LT (CMP a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MSUB {
 				break
 			}
@@ -35420,24 +35611,26 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LT
-			v0 := b.NewValue0(v.Pos, OpARM64CMP, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMP, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPWconst [0] z:(MADDW a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (LT (CMNW a (MULW <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MADDW {
 				break
 			}
@@ -35448,24 +35641,26 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LT
-			v0 := b.NewValue0(v.Pos, OpARM64CMNW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNW, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MULW, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MULW, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPWconst [0] z:(MSUBW a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (LT (CMPW a (MULW <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MSUBW {
 				break
 			}
@@ -35476,89 +35671,96 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64LT
-			v0 := b.NewValue0(v.Pos, OpARM64CMPW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMPW, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MULW, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MULW, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPWconst [0] x) yes no)
 		// result: (TBNZ {int64(31)} x yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			b.Kind = BlockARM64TBNZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = int64(31)
 			return true
 		}
 		// match: (LT (CMPconst [0] x) yes no)
 		// result: (TBNZ {int64(63)} x yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			b.Kind = BlockARM64TBNZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = int64(63)
 			return true
 		}
 		// match: (LT (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LT (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LT (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LT (InvertFlags cmp) yes no)
 		// result: (GT cmp yes no)
-		for v.Op == OpARM64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARM64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARM64GT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
@@ -35566,11 +35768,12 @@ func rewriteBlockARM64(b *Block) bool {
 		// match: (NE (CMPWconst [0] x:(ANDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (NE (TSTWconst [c] y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ANDconst {
 				break
 			}
@@ -35580,21 +35783,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64NE
-			v0 := b.NewValue0(v.Pos, OpARM64TSTWconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TSTWconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] z:(AND x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (NE (TST x y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64AND {
 				break
 			}
@@ -35604,21 +35809,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64NE
-			v0 := b.NewValue0(v.Pos, OpARM64TST, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TST, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPWconst [0] z:(AND x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (NE (TSTW x y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64AND {
 				break
 			}
@@ -35628,21 +35835,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64NE
-			v0 := b.NewValue0(v.Pos, OpARM64TSTW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TSTW, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] x:(ANDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (NE (TSTconst [c] y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ANDconst {
 				break
 			}
@@ -35652,21 +35861,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64NE
-			v0 := b.NewValue0(v.Pos, OpARM64TSTconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64TSTconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] x:(ADDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (NE (CMNconst [c] y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ADDconst {
 				break
 			}
@@ -35676,21 +35887,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64NE
-			v0 := b.NewValue0(v.Pos, OpARM64CMNconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPWconst [0] x:(ADDconst [c] y)) yes no)
 		// cond: x.Uses == 1
 		// result: (NE (CMNWconst [c] y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			if x.Op != OpARM64ADDconst {
 				break
 			}
@@ -35700,21 +35913,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64NE
-			v0 := b.NewValue0(v.Pos, OpARM64CMNWconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNWconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] z:(ADD x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (NE (CMN x y) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64ADD {
 				break
 			}
@@ -35724,21 +35939,23 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64NE
-			v0 := b.NewValue0(v.Pos, OpARM64CMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMN, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPWconst [0] z:(ADD x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (NE (CMNW x y) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64ADD {
 				break
 			}
@@ -35748,20 +35965,22 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64NE
-			v0 := b.NewValue0(v.Pos, OpARM64CMNW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNW, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMP x z:(NEG y)) yes no)
 		// cond: z.Uses == 1
 		// result: (NE (CMN x y) yes no)
-		for v.Op == OpARM64CMP {
-			_ = v.Args[1]
-			x := v.Args[0]
-			z := v.Args[1]
+		for b.Controls[0].Op == OpARM64CMP {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			z := v_0.Args[1]
 			if z.Op != OpARM64NEG {
 				break
 			}
@@ -35770,20 +35989,22 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64NE
-			v0 := b.NewValue0(v.Pos, OpARM64CMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMN, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPW x z:(NEG y)) yes no)
 		// cond: z.Uses == 1
 		// result: (NE (CMNW x y) yes no)
-		for v.Op == OpARM64CMPW {
-			_ = v.Args[1]
-			x := v.Args[0]
-			z := v.Args[1]
+		for b.Controls[0].Op == OpARM64CMPW {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			z := v_0.Args[1]
 			if z.Op != OpARM64NEG {
 				break
 			}
@@ -35792,45 +36013,51 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64NE
-			v0 := b.NewValue0(v.Pos, OpARM64CMNW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNW, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] x) yes no)
 		// result: (NZ x yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			b.Kind = BlockARM64NZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPWconst [0] x) yes no)
 		// result: (NZW x yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			b.Kind = BlockARM64NZW
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] z:(MADD a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (NE (CMN a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MADD {
 				break
 			}
@@ -35841,24 +36068,26 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64NE
-			v0 := b.NewValue0(v.Pos, OpARM64CMN, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMN, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] z:(MSUB a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (NE (CMP a (MUL <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MSUB {
 				break
 			}
@@ -35869,24 +36098,26 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64NE
-			v0 := b.NewValue0(v.Pos, OpARM64CMP, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMP, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MUL, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MUL, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPWconst [0] z:(MADDW a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (NE (CMNW a (MULW <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MADDW {
 				break
 			}
@@ -35897,24 +36128,26 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64NE
-			v0 := b.NewValue0(v.Pos, OpARM64CMNW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMNW, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MULW, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MULW, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPWconst [0] z:(MSUBW a x y)) yes no)
 		// cond: z.Uses==1
 		// result: (NE (CMPW a (MULW <x.Type> x y)) yes no)
-		for v.Op == OpARM64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpARM64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpARM64MSUBW {
 				break
 			}
@@ -35925,257 +36158,296 @@ func rewriteBlockARM64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockARM64NE
-			v0 := b.NewValue0(v.Pos, OpARM64CMPW, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpARM64CMPW, types.TypeFlags)
 			v0.AddArg(a)
-			v1 := b.NewValue0(v.Pos, OpARM64MULW, x.Type)
+			v1 := b.NewValue0(v_0.Pos, OpARM64MULW, x.Type)
 			v1.AddArg(x)
 			v1.AddArg(y)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (TSTconst [c] x) yes no)
 		// cond: oneBit(c)
 		// result: (TBNZ {ntz(c)} x yes no)
-		for v.Op == OpARM64TSTconst {
-			c := v.AuxInt
-			x := v.Args[0]
+		for b.Controls[0].Op == OpARM64TSTconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
+			x := v_0.Args[0]
 			if !(oneBit(c)) {
 				break
 			}
 			b.Kind = BlockARM64TBNZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = ntz(c)
 			return true
 		}
 		// match: (NE (TSTWconst [c] x) yes no)
 		// cond: oneBit(int64(uint32(c)))
 		// result: (TBNZ {ntz(int64(uint32(c)))} x yes no)
-		for v.Op == OpARM64TSTWconst {
-			c := v.AuxInt
-			x := v.Args[0]
+		for b.Controls[0].Op == OpARM64TSTWconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
+			x := v_0.Args[0]
 			if !(oneBit(int64(uint32(c)))) {
 				break
 			}
 			b.Kind = BlockARM64TBNZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = ntz(int64(uint32(c)))
 			return true
 		}
 		// match: (NE (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (NE (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (InvertFlags cmp) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == OpARM64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARM64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARM64NE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 	case BlockARM64NZ:
 		// match: (NZ (Equal cc) yes no)
 		// result: (EQ cc yes no)
-		for v.Op == OpARM64Equal {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64Equal {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64EQ
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NZ (NotEqual cc) yes no)
 		// result: (NE cc yes no)
-		for v.Op == OpARM64NotEqual {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64NotEqual {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64NE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NZ (LessThan cc) yes no)
 		// result: (LT cc yes no)
-		for v.Op == OpARM64LessThan {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64LessThan {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64LT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NZ (LessThanU cc) yes no)
 		// result: (ULT cc yes no)
-		for v.Op == OpARM64LessThanU {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64LessThanU {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64ULT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NZ (LessEqual cc) yes no)
 		// result: (LE cc yes no)
-		for v.Op == OpARM64LessEqual {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64LessEqual {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64LE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NZ (LessEqualU cc) yes no)
 		// result: (ULE cc yes no)
-		for v.Op == OpARM64LessEqualU {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64LessEqualU {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64ULE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NZ (GreaterThan cc) yes no)
 		// result: (GT cc yes no)
-		for v.Op == OpARM64GreaterThan {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64GreaterThan {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64GT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NZ (GreaterThanU cc) yes no)
 		// result: (UGT cc yes no)
-		for v.Op == OpARM64GreaterThanU {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64GreaterThanU {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64UGT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NZ (GreaterEqual cc) yes no)
 		// result: (GE cc yes no)
-		for v.Op == OpARM64GreaterEqual {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64GreaterEqual {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64GE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NZ (GreaterEqualU cc) yes no)
 		// result: (UGE cc yes no)
-		for v.Op == OpARM64GreaterEqualU {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64GreaterEqualU {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64UGE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NZ (LessThanF cc) yes no)
 		// result: (FLT cc yes no)
-		for v.Op == OpARM64LessThanF {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64LessThanF {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64FLT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NZ (LessEqualF cc) yes no)
 		// result: (FLE cc yes no)
-		for v.Op == OpARM64LessEqualF {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64LessEqualF {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64FLE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NZ (GreaterThanF cc) yes no)
 		// result: (FGT cc yes no)
-		for v.Op == OpARM64GreaterThanF {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64GreaterThanF {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64FGT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NZ (GreaterEqualF cc) yes no)
 		// result: (FGE cc yes no)
-		for v.Op == OpARM64GreaterEqualF {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpARM64GreaterEqualF {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockARM64FGE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NZ (ANDconst [c] x) yes no)
 		// cond: oneBit(c)
 		// result: (TBNZ {ntz(c)} x yes no)
-		for v.Op == OpARM64ANDconst {
-			c := v.AuxInt
-			x := v.Args[0]
+		for b.Controls[0].Op == OpARM64ANDconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
+			x := v_0.Args[0]
 			if !(oneBit(c)) {
 				break
 			}
 			b.Kind = BlockARM64TBNZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = ntz(c)
 			return true
 		}
 		// match: (NZ (MOVDconst [0]) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64MOVDconst {
-			if v.AuxInt != 0 {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64MOVDconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (NZ (MOVDconst [c]) yes no)
 		// cond: c != 0
-		// result: (First nil yes no)
-		for v.Op == OpARM64MOVDconst {
-			c := v.AuxInt
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64MOVDconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(c != 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
@@ -36183,251 +36455,263 @@ func rewriteBlockARM64(b *Block) bool {
 		// match: (NZW (ANDconst [c] x) yes no)
 		// cond: oneBit(int64(uint32(c)))
 		// result: (TBNZ {ntz(int64(uint32(c)))} x yes no)
-		for v.Op == OpARM64ANDconst {
-			c := v.AuxInt
-			x := v.Args[0]
+		for b.Controls[0].Op == OpARM64ANDconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
+			x := v_0.Args[0]
 			if !(oneBit(int64(uint32(c)))) {
 				break
 			}
 			b.Kind = BlockARM64TBNZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = ntz(int64(uint32(c)))
 			return true
 		}
 		// match: (NZW (MOVDconst [c]) yes no)
 		// cond: int32(c) == 0
-		// result: (First nil no yes)
-		for v.Op == OpARM64MOVDconst {
-			c := v.AuxInt
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64MOVDconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(int32(c) == 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (NZW (MOVDconst [c]) yes no)
 		// cond: int32(c) != 0
-		// result: (First nil yes no)
-		for v.Op == OpARM64MOVDconst {
-			c := v.AuxInt
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64MOVDconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(int32(c) != 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 	case BlockARM64UGE:
 		// match: (UGE (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (UGE (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGE (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (UGE (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGE (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (UGE (InvertFlags cmp) yes no)
 		// result: (ULE cmp yes no)
-		for v.Op == OpARM64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARM64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARM64ULE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 	case BlockARM64UGT:
 		// match: (UGT (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGT (FlagLT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagLT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGT (FlagLT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagLT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (UGT (FlagGT_ULT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagGT_ULT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (UGT (FlagGT_UGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagGT_UGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (UGT (InvertFlags cmp) yes no)
 		// result: (ULT cmp yes no)
-		for v.Op == OpARM64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARM64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARM64ULT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 	case BlockARM64ULE:
 		// match: (ULE (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULE (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULE (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (ULE (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULE (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (ULE (InvertFlags cmp) yes no)
 		// result: (UGE cmp yes no)
-		for v.Op == OpARM64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARM64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARM64UGE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 	case BlockARM64ULT:
 		// match: (ULT (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (ULT (FlagLT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagLT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagLT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULT (FlagLT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagLT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagLT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (ULT (FlagGT_ULT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64FlagGT_ULT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64FlagGT_ULT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ULT (FlagGT_UGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpARM64FlagGT_UGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64FlagGT_UGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (ULT (InvertFlags cmp) yes no)
 		// result: (UGT cmp yes no)
-		for v.Op == OpARM64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpARM64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockARM64UGT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
@@ -36435,38 +36719,42 @@ func rewriteBlockARM64(b *Block) bool {
 		// match: (Z (ANDconst [c] x) yes no)
 		// cond: oneBit(c)
 		// result: (TBZ {ntz(c)} x yes no)
-		for v.Op == OpARM64ANDconst {
-			c := v.AuxInt
-			x := v.Args[0]
+		for b.Controls[0].Op == OpARM64ANDconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
+			x := v_0.Args[0]
 			if !(oneBit(c)) {
 				break
 			}
 			b.Kind = BlockARM64TBZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = ntz(c)
 			return true
 		}
 		// match: (Z (MOVDconst [0]) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpARM64MOVDconst {
-			if v.AuxInt != 0 {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64MOVDconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (Z (MOVDconst [c]) yes no)
 		// cond: c != 0
-		// result: (First nil no yes)
-		for v.Op == OpARM64MOVDconst {
-			c := v.AuxInt
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64MOVDconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(c != 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -36475,40 +36763,44 @@ func rewriteBlockARM64(b *Block) bool {
 		// match: (ZW (ANDconst [c] x) yes no)
 		// cond: oneBit(int64(uint32(c)))
 		// result: (TBZ {ntz(int64(uint32(c)))} x yes no)
-		for v.Op == OpARM64ANDconst {
-			c := v.AuxInt
-			x := v.Args[0]
+		for b.Controls[0].Op == OpARM64ANDconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
+			x := v_0.Args[0]
 			if !(oneBit(int64(uint32(c)))) {
 				break
 			}
 			b.Kind = BlockARM64TBZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = ntz(int64(uint32(c)))
 			return true
 		}
 		// match: (ZW (MOVDconst [c]) yes no)
 		// cond: int32(c) == 0
-		// result: (First nil yes no)
-		for v.Op == OpARM64MOVDconst {
-			c := v.AuxInt
+		// result: (First yes no)
+		for b.Controls[0].Op == OpARM64MOVDconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(int32(c) == 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (ZW (MOVDconst [c]) yes no)
 		// cond: int32(c) != 0
-		// result: (First nil no yes)
-		for v.Op == OpARM64MOVDconst {
-			c := v.AuxInt
+		// result: (First no yes)
+		for b.Controls[0].Op == OpARM64MOVDconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(int32(c) != 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
diff --git a/src/cmd/compile/internal/ssa/rewriteMIPS.go b/src/cmd/compile/internal/ssa/rewriteMIPS.go
index 98bb5f3168..3ae2a72457 100644
--- a/src/cmd/compile/internal/ssa/rewriteMIPS.go
+++ b/src/cmd/compile/internal/ssa/rewriteMIPS.go
@@ -8995,182 +8995,207 @@ func rewriteValueMIPS_OpZeromask_0(v *Value) bool {
 	}
 }
 func rewriteBlockMIPS(b *Block) bool {
-	v := b.Control
 	switch b.Kind {
 	case BlockMIPSEQ:
 		// match: (EQ (FPFlagTrue cmp) yes no)
 		// result: (FPF cmp yes no)
-		for v.Op == OpMIPSFPFlagTrue {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpMIPSFPFlagTrue {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockMIPSFPF
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (FPFlagFalse cmp) yes no)
 		// result: (FPT cmp yes no)
-		for v.Op == OpMIPSFPFlagFalse {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpMIPSFPFlagFalse {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockMIPSFPT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (XORconst [1] cmp:(SGT _ _)) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == OpMIPSXORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPSXORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPSSGT {
 				break
 			}
 			_ = cmp.Args[1]
 			b.Kind = BlockMIPSNE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (XORconst [1] cmp:(SGTU _ _)) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == OpMIPSXORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPSXORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPSSGTU {
 				break
 			}
 			_ = cmp.Args[1]
 			b.Kind = BlockMIPSNE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (XORconst [1] cmp:(SGTconst _)) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == OpMIPSXORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPSXORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPSSGTconst {
 				break
 			}
 			b.Kind = BlockMIPSNE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (XORconst [1] cmp:(SGTUconst _)) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == OpMIPSXORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPSXORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPSSGTUconst {
 				break
 			}
 			b.Kind = BlockMIPSNE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (XORconst [1] cmp:(SGTzero _)) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == OpMIPSXORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPSXORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPSSGTzero {
 				break
 			}
 			b.Kind = BlockMIPSNE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (XORconst [1] cmp:(SGTUzero _)) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == OpMIPSXORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPSXORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPSSGTUzero {
 				break
 			}
 			b.Kind = BlockMIPSNE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (SGTUconst [1] x) yes no)
 		// result: (NE x yes no)
-		for v.Op == OpMIPSSGTUconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPSSGTUconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			b.Kind = BlockMIPSNE
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (SGTUzero x) yes no)
 		// result: (EQ x yes no)
-		for v.Op == OpMIPSSGTUzero {
-			x := v.Args[0]
+		for b.Controls[0].Op == OpMIPSSGTUzero {
+			v_0 := b.Controls[0]
+			x := v_0.Args[0]
 			b.Kind = BlockMIPSEQ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (SGTconst [0] x) yes no)
 		// result: (GEZ x yes no)
-		for v.Op == OpMIPSSGTconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpMIPSSGTconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			b.Kind = BlockMIPSGEZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (SGTzero x) yes no)
 		// result: (LEZ x yes no)
-		for v.Op == OpMIPSSGTzero {
-			x := v.Args[0]
+		for b.Controls[0].Op == OpMIPSSGTzero {
+			v_0 := b.Controls[0]
+			x := v_0.Args[0]
 			b.Kind = BlockMIPSLEZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (MOVWconst [0]) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpMIPSMOVWconst {
-			if v.AuxInt != 0 {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpMIPSMOVWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (MOVWconst [c]) yes no)
 		// cond: c != 0
-		// result: (First nil no yes)
-		for v.Op == OpMIPSMOVWconst {
-			c := v.AuxInt
+		// result: (First no yes)
+		for b.Controls[0].Op == OpMIPSMOVWconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(c != 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -9178,27 +9203,29 @@ func rewriteBlockMIPS(b *Block) bool {
 	case BlockMIPSGEZ:
 		// match: (GEZ (MOVWconst [c]) yes no)
 		// cond: int32(c) >= 0
-		// result: (First nil yes no)
-		for v.Op == OpMIPSMOVWconst {
-			c := v.AuxInt
+		// result: (First yes no)
+		for b.Controls[0].Op == OpMIPSMOVWconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(int32(c) >= 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GEZ (MOVWconst [c]) yes no)
 		// cond: int32(c) < 0
-		// result: (First nil no yes)
-		for v.Op == OpMIPSMOVWconst {
-			c := v.AuxInt
+		// result: (First no yes)
+		for b.Controls[0].Op == OpMIPSMOVWconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(int32(c) < 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -9206,27 +9233,29 @@ func rewriteBlockMIPS(b *Block) bool {
 	case BlockMIPSGTZ:
 		// match: (GTZ (MOVWconst [c]) yes no)
 		// cond: int32(c) > 0
-		// result: (First nil yes no)
-		for v.Op == OpMIPSMOVWconst {
-			c := v.AuxInt
+		// result: (First yes no)
+		for b.Controls[0].Op == OpMIPSMOVWconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(int32(c) > 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GTZ (MOVWconst [c]) yes no)
 		// cond: int32(c) <= 0
-		// result: (First nil no yes)
-		for v.Op == OpMIPSMOVWconst {
-			c := v.AuxInt
+		// result: (First no yes)
+		for b.Controls[0].Op == OpMIPSMOVWconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(int32(c) <= 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -9235,36 +9264,39 @@ func rewriteBlockMIPS(b *Block) bool {
 		// match: (If cond yes no)
 		// result: (NE cond yes no)
 		for {
-			cond := b.Control
+			cond := b.Controls[0]
 			b.Kind = BlockMIPSNE
-			b.SetControl(cond)
+			b.ResetControls()
+			b.AddControl(cond)
 			b.Aux = nil
 			return true
 		}
 	case BlockMIPSLEZ:
 		// match: (LEZ (MOVWconst [c]) yes no)
 		// cond: int32(c) <= 0
-		// result: (First nil yes no)
-		for v.Op == OpMIPSMOVWconst {
-			c := v.AuxInt
+		// result: (First yes no)
+		for b.Controls[0].Op == OpMIPSMOVWconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(int32(c) <= 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LEZ (MOVWconst [c]) yes no)
 		// cond: int32(c) > 0
-		// result: (First nil no yes)
-		for v.Op == OpMIPSMOVWconst {
-			c := v.AuxInt
+		// result: (First no yes)
+		for b.Controls[0].Op == OpMIPSMOVWconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(int32(c) > 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -9272,27 +9304,29 @@ func rewriteBlockMIPS(b *Block) bool {
 	case BlockMIPSLTZ:
 		// match: (LTZ (MOVWconst [c]) yes no)
 		// cond: int32(c) < 0
-		// result: (First nil yes no)
-		for v.Op == OpMIPSMOVWconst {
-			c := v.AuxInt
+		// result: (First yes no)
+		for b.Controls[0].Op == OpMIPSMOVWconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(int32(c) < 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LTZ (MOVWconst [c]) yes no)
 		// cond: int32(c) >= 0
-		// result: (First nil no yes)
-		for v.Op == OpMIPSMOVWconst {
-			c := v.AuxInt
+		// result: (First no yes)
+		for b.Controls[0].Op == OpMIPSMOVWconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(int32(c) >= 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -9300,178 +9334,204 @@ func rewriteBlockMIPS(b *Block) bool {
 	case BlockMIPSNE:
 		// match: (NE (FPFlagTrue cmp) yes no)
 		// result: (FPT cmp yes no)
-		for v.Op == OpMIPSFPFlagTrue {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpMIPSFPFlagTrue {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockMIPSFPT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FPFlagFalse cmp) yes no)
 		// result: (FPF cmp yes no)
-		for v.Op == OpMIPSFPFlagFalse {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpMIPSFPFlagFalse {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockMIPSFPF
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (XORconst [1] cmp:(SGT _ _)) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == OpMIPSXORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPSXORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPSSGT {
 				break
 			}
 			_ = cmp.Args[1]
 			b.Kind = BlockMIPSEQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (XORconst [1] cmp:(SGTU _ _)) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == OpMIPSXORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPSXORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPSSGTU {
 				break
 			}
 			_ = cmp.Args[1]
 			b.Kind = BlockMIPSEQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (XORconst [1] cmp:(SGTconst _)) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == OpMIPSXORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPSXORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPSSGTconst {
 				break
 			}
 			b.Kind = BlockMIPSEQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (XORconst [1] cmp:(SGTUconst _)) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == OpMIPSXORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPSXORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPSSGTUconst {
 				break
 			}
 			b.Kind = BlockMIPSEQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (XORconst [1] cmp:(SGTzero _)) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == OpMIPSXORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPSXORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPSSGTzero {
 				break
 			}
 			b.Kind = BlockMIPSEQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (XORconst [1] cmp:(SGTUzero _)) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == OpMIPSXORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPSXORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPSSGTUzero {
 				break
 			}
 			b.Kind = BlockMIPSEQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (SGTUconst [1] x) yes no)
 		// result: (EQ x yes no)
-		for v.Op == OpMIPSSGTUconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPSSGTUconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			b.Kind = BlockMIPSEQ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (SGTUzero x) yes no)
 		// result: (NE x yes no)
-		for v.Op == OpMIPSSGTUzero {
-			x := v.Args[0]
+		for b.Controls[0].Op == OpMIPSSGTUzero {
+			v_0 := b.Controls[0]
+			x := v_0.Args[0]
 			b.Kind = BlockMIPSNE
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (SGTconst [0] x) yes no)
 		// result: (LTZ x yes no)
-		for v.Op == OpMIPSSGTconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpMIPSSGTconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			b.Kind = BlockMIPSLTZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (SGTzero x) yes no)
 		// result: (GTZ x yes no)
-		for v.Op == OpMIPSSGTzero {
-			x := v.Args[0]
+		for b.Controls[0].Op == OpMIPSSGTzero {
+			v_0 := b.Controls[0]
+			x := v_0.Args[0]
 			b.Kind = BlockMIPSGTZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (MOVWconst [0]) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpMIPSMOVWconst {
-			if v.AuxInt != 0 {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpMIPSMOVWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (NE (MOVWconst [c]) yes no)
 		// cond: c != 0
-		// result: (First nil yes no)
-		for v.Op == OpMIPSMOVWconst {
-			c := v.AuxInt
+		// result: (First yes no)
+		for b.Controls[0].Op == OpMIPSMOVWconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(c != 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
diff --git a/src/cmd/compile/internal/ssa/rewriteMIPS64.go b/src/cmd/compile/internal/ssa/rewriteMIPS64.go
index 1be27697aa..226dc00952 100644
--- a/src/cmd/compile/internal/ssa/rewriteMIPS64.go
+++ b/src/cmd/compile/internal/ssa/rewriteMIPS64.go
@@ -9740,162 +9740,183 @@ func rewriteValueMIPS64_OpZeroExt8to64_0(v *Value) bool {
 	}
 }
 func rewriteBlockMIPS64(b *Block) bool {
-	v := b.Control
 	switch b.Kind {
 	case BlockMIPS64EQ:
 		// match: (EQ (FPFlagTrue cmp) yes no)
 		// result: (FPF cmp yes no)
-		for v.Op == OpMIPS64FPFlagTrue {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpMIPS64FPFlagTrue {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockMIPS64FPF
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (FPFlagFalse cmp) yes no)
 		// result: (FPT cmp yes no)
-		for v.Op == OpMIPS64FPFlagFalse {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpMIPS64FPFlagFalse {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockMIPS64FPT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (XORconst [1] cmp:(SGT _ _)) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == OpMIPS64XORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPS64XORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPS64SGT {
 				break
 			}
 			_ = cmp.Args[1]
 			b.Kind = BlockMIPS64NE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (XORconst [1] cmp:(SGTU _ _)) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == OpMIPS64XORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPS64XORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPS64SGTU {
 				break
 			}
 			_ = cmp.Args[1]
 			b.Kind = BlockMIPS64NE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (XORconst [1] cmp:(SGTconst _)) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == OpMIPS64XORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPS64XORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPS64SGTconst {
 				break
 			}
 			b.Kind = BlockMIPS64NE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (XORconst [1] cmp:(SGTUconst _)) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == OpMIPS64XORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPS64XORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPS64SGTUconst {
 				break
 			}
 			b.Kind = BlockMIPS64NE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (SGTUconst [1] x) yes no)
 		// result: (NE x yes no)
-		for v.Op == OpMIPS64SGTUconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPS64SGTUconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			b.Kind = BlockMIPS64NE
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (SGTU x (MOVVconst [0])) yes no)
 		// result: (EQ x yes no)
-		for v.Op == OpMIPS64SGTU {
-			_ = v.Args[1]
-			x := v.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpMIPS64MOVVconst || v_1.AuxInt != 0 {
+		for b.Controls[0].Op == OpMIPS64SGTU {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpMIPS64MOVVconst || v_0_1.AuxInt != 0 {
 				break
 			}
 			b.Kind = BlockMIPS64EQ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (SGTconst [0] x) yes no)
 		// result: (GEZ x yes no)
-		for v.Op == OpMIPS64SGTconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpMIPS64SGTconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			b.Kind = BlockMIPS64GEZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (SGT x (MOVVconst [0])) yes no)
 		// result: (LEZ x yes no)
-		for v.Op == OpMIPS64SGT {
-			_ = v.Args[1]
-			x := v.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpMIPS64MOVVconst || v_1.AuxInt != 0 {
+		for b.Controls[0].Op == OpMIPS64SGT {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpMIPS64MOVVconst || v_0_1.AuxInt != 0 {
 				break
 			}
 			b.Kind = BlockMIPS64LEZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (MOVVconst [0]) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpMIPS64MOVVconst {
-			if v.AuxInt != 0 {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpMIPS64MOVVconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (MOVVconst [c]) yes no)
 		// cond: c != 0
-		// result: (First nil no yes)
-		for v.Op == OpMIPS64MOVVconst {
-			c := v.AuxInt
+		// result: (First no yes)
+		for b.Controls[0].Op == OpMIPS64MOVVconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(c != 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -9903,27 +9924,29 @@ func rewriteBlockMIPS64(b *Block) bool {
 	case BlockMIPS64GEZ:
 		// match: (GEZ (MOVVconst [c]) yes no)
 		// cond: c >= 0
-		// result: (First nil yes no)
-		for v.Op == OpMIPS64MOVVconst {
-			c := v.AuxInt
+		// result: (First yes no)
+		for b.Controls[0].Op == OpMIPS64MOVVconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(c >= 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GEZ (MOVVconst [c]) yes no)
 		// cond: c < 0
-		// result: (First nil no yes)
-		for v.Op == OpMIPS64MOVVconst {
-			c := v.AuxInt
+		// result: (First no yes)
+		for b.Controls[0].Op == OpMIPS64MOVVconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(c < 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -9931,27 +9954,29 @@ func rewriteBlockMIPS64(b *Block) bool {
 	case BlockMIPS64GTZ:
 		// match: (GTZ (MOVVconst [c]) yes no)
 		// cond: c > 0
-		// result: (First nil yes no)
-		for v.Op == OpMIPS64MOVVconst {
-			c := v.AuxInt
+		// result: (First yes no)
+		for b.Controls[0].Op == OpMIPS64MOVVconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(c > 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GTZ (MOVVconst [c]) yes no)
 		// cond: c <= 0
-		// result: (First nil no yes)
-		for v.Op == OpMIPS64MOVVconst {
-			c := v.AuxInt
+		// result: (First no yes)
+		for b.Controls[0].Op == OpMIPS64MOVVconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(c <= 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -9960,36 +9985,39 @@ func rewriteBlockMIPS64(b *Block) bool {
 		// match: (If cond yes no)
 		// result: (NE cond yes no)
 		for {
-			cond := b.Control
+			cond := b.Controls[0]
 			b.Kind = BlockMIPS64NE
-			b.SetControl(cond)
+			b.ResetControls()
+			b.AddControl(cond)
 			b.Aux = nil
 			return true
 		}
 	case BlockMIPS64LEZ:
 		// match: (LEZ (MOVVconst [c]) yes no)
 		// cond: c <= 0
-		// result: (First nil yes no)
-		for v.Op == OpMIPS64MOVVconst {
-			c := v.AuxInt
+		// result: (First yes no)
+		for b.Controls[0].Op == OpMIPS64MOVVconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(c <= 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LEZ (MOVVconst [c]) yes no)
 		// cond: c > 0
-		// result: (First nil no yes)
-		for v.Op == OpMIPS64MOVVconst {
-			c := v.AuxInt
+		// result: (First no yes)
+		for b.Controls[0].Op == OpMIPS64MOVVconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(c > 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -9997,27 +10025,29 @@ func rewriteBlockMIPS64(b *Block) bool {
 	case BlockMIPS64LTZ:
 		// match: (LTZ (MOVVconst [c]) yes no)
 		// cond: c < 0
-		// result: (First nil yes no)
-		for v.Op == OpMIPS64MOVVconst {
-			c := v.AuxInt
+		// result: (First yes no)
+		for b.Controls[0].Op == OpMIPS64MOVVconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(c < 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LTZ (MOVVconst [c]) yes no)
 		// cond: c >= 0
-		// result: (First nil no yes)
-		for v.Op == OpMIPS64MOVVconst {
-			c := v.AuxInt
+		// result: (First no yes)
+		for b.Controls[0].Op == OpMIPS64MOVVconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(c >= 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -10025,158 +10055,180 @@ func rewriteBlockMIPS64(b *Block) bool {
 	case BlockMIPS64NE:
 		// match: (NE (FPFlagTrue cmp) yes no)
 		// result: (FPT cmp yes no)
-		for v.Op == OpMIPS64FPFlagTrue {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpMIPS64FPFlagTrue {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockMIPS64FPT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FPFlagFalse cmp) yes no)
 		// result: (FPF cmp yes no)
-		for v.Op == OpMIPS64FPFlagFalse {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpMIPS64FPFlagFalse {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockMIPS64FPF
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (XORconst [1] cmp:(SGT _ _)) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == OpMIPS64XORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPS64XORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPS64SGT {
 				break
 			}
 			_ = cmp.Args[1]
 			b.Kind = BlockMIPS64EQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (XORconst [1] cmp:(SGTU _ _)) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == OpMIPS64XORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPS64XORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPS64SGTU {
 				break
 			}
 			_ = cmp.Args[1]
 			b.Kind = BlockMIPS64EQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (XORconst [1] cmp:(SGTconst _)) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == OpMIPS64XORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPS64XORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPS64SGTconst {
 				break
 			}
 			b.Kind = BlockMIPS64EQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (XORconst [1] cmp:(SGTUconst _)) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == OpMIPS64XORconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPS64XORconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			cmp := v.Args[0]
+			cmp := v_0.Args[0]
 			if cmp.Op != OpMIPS64SGTUconst {
 				break
 			}
 			b.Kind = BlockMIPS64EQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (SGTUconst [1] x) yes no)
 		// result: (EQ x yes no)
-		for v.Op == OpMIPS64SGTUconst {
-			if v.AuxInt != 1 {
+		for b.Controls[0].Op == OpMIPS64SGTUconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 1 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			b.Kind = BlockMIPS64EQ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (SGTU x (MOVVconst [0])) yes no)
 		// result: (NE x yes no)
-		for v.Op == OpMIPS64SGTU {
-			_ = v.Args[1]
-			x := v.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpMIPS64MOVVconst || v_1.AuxInt != 0 {
+		for b.Controls[0].Op == OpMIPS64SGTU {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpMIPS64MOVVconst || v_0_1.AuxInt != 0 {
 				break
 			}
 			b.Kind = BlockMIPS64NE
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (SGTconst [0] x) yes no)
 		// result: (LTZ x yes no)
-		for v.Op == OpMIPS64SGTconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpMIPS64SGTconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			x := v.Args[0]
+			x := v_0.Args[0]
 			b.Kind = BlockMIPS64LTZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (SGT x (MOVVconst [0])) yes no)
 		// result: (GTZ x yes no)
-		for v.Op == OpMIPS64SGT {
-			_ = v.Args[1]
-			x := v.Args[0]
-			v_1 := v.Args[1]
-			if v_1.Op != OpMIPS64MOVVconst || v_1.AuxInt != 0 {
+		for b.Controls[0].Op == OpMIPS64SGT {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpMIPS64MOVVconst || v_0_1.AuxInt != 0 {
 				break
 			}
 			b.Kind = BlockMIPS64GTZ
-			b.SetControl(x)
+			b.ResetControls()
+			b.AddControl(x)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (MOVVconst [0]) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpMIPS64MOVVconst {
-			if v.AuxInt != 0 {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpMIPS64MOVVconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (NE (MOVVconst [c]) yes no)
 		// cond: c != 0
-		// result: (First nil yes no)
-		for v.Op == OpMIPS64MOVVconst {
-			c := v.AuxInt
+		// result: (First yes no)
+		for b.Controls[0].Op == OpMIPS64MOVVconst {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(c != 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
diff --git a/src/cmd/compile/internal/ssa/rewritePPC64.go b/src/cmd/compile/internal/ssa/rewritePPC64.go
index 4d2dfc1074..7743a2855e 100644
--- a/src/cmd/compile/internal/ssa/rewritePPC64.go
+++ b/src/cmd/compile/internal/ssa/rewritePPC64.go
@@ -26466,132 +26466,142 @@ func rewriteValuePPC64_OpZeroExt8to64_0(v *Value) bool {
 	}
 }
 func rewriteBlockPPC64(b *Block) bool {
-	v := b.Control
 	switch b.Kind {
 	case BlockPPC64EQ:
 		// match: (EQ (CMPconst [0] (ANDconst [c] x)) yes no)
 		// result: (EQ (ANDCCconst [c] x) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64ANDconst {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0.AuxInt
-			x := v_0.Args[0]
+			c := v_0_0.AuxInt
+			x := v_0_0.Args[0]
 			b.Kind = BlockPPC64EQ
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPWconst [0] (ANDconst [c] x)) yes no)
 		// result: (EQ (ANDCCconst [c] x) yes no)
-		for v.Op == OpPPC64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64ANDconst {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0.AuxInt
-			x := v_0.Args[0]
+			c := v_0_0.AuxInt
+			x := v_0_0.Args[0]
 			b.Kind = BlockPPC64EQ
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpPPC64FlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpPPC64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (FlagLT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpPPC64FlagLT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpPPC64FlagLT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (EQ (FlagGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpPPC64FlagGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpPPC64FlagGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (EQ (InvertFlags cmp) yes no)
 		// result: (EQ cmp yes no)
-		for v.Op == OpPPC64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpPPC64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockPPC64EQ
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] (ANDconst [c] x)) yes no)
 		// result: (EQ (ANDCCconst [c] x) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64ANDconst {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0.AuxInt
-			x := v_0.Args[0]
+			c := v_0_0.AuxInt
+			x := v_0_0.Args[0]
 			b.Kind = BlockPPC64EQ
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPWconst [0] (ANDconst [c] x)) yes no)
 		// result: (EQ (ANDCCconst [c] x) yes no)
-		for v.Op == OpPPC64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64ANDconst {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0.AuxInt
-			x := v_0.Args[0]
+			c := v_0_0.AuxInt
+			x := v_0_0.Args[0]
 			b.Kind = BlockPPC64EQ
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] z:(AND x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (EQ (ANDCC x y) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpPPC64AND {
 				break
 			}
@@ -26601,21 +26611,23 @@ func rewriteBlockPPC64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockPPC64EQ
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCC, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCC, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] z:(OR x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (EQ (ORCC x y) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpPPC64OR {
 				break
 			}
@@ -26625,21 +26637,23 @@ func rewriteBlockPPC64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockPPC64EQ
-			v0 := b.NewValue0(v.Pos, OpPPC64ORCC, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ORCC, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (EQ (CMPconst [0] z:(XOR x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (EQ (XORCC x y) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpPPC64XOR {
 				break
 			}
@@ -26649,96 +26663,104 @@ func rewriteBlockPPC64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockPPC64EQ
-			v0 := b.NewValue0(v.Pos, OpPPC64XORCC, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64XORCC, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 	case BlockPPC64GE:
 		// match: (GE (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpPPC64FlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpPPC64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (FlagLT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpPPC64FlagLT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpPPC64FlagLT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GE (FlagGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpPPC64FlagGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpPPC64FlagGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (InvertFlags cmp) yes no)
 		// result: (LE cmp yes no)
-		for v.Op == OpPPC64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpPPC64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockPPC64LE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] (ANDconst [c] x)) yes no)
 		// result: (GE (ANDCCconst [c] x) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64ANDconst {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0.AuxInt
-			x := v_0.Args[0]
+			c := v_0_0.AuxInt
+			x := v_0_0.Args[0]
 			b.Kind = BlockPPC64GE
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPWconst [0] (ANDconst [c] x)) yes no)
 		// result: (GE (ANDCCconst [c] x) yes no)
-		for v.Op == OpPPC64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64ANDconst {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0.AuxInt
-			x := v_0.Args[0]
+			c := v_0_0.AuxInt
+			x := v_0_0.Args[0]
 			b.Kind = BlockPPC64GE
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] z:(AND x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (GE (ANDCC x y) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpPPC64AND {
 				break
 			}
@@ -26748,21 +26770,23 @@ func rewriteBlockPPC64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockPPC64GE
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCC, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCC, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] z:(OR x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (GE (ORCC x y) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpPPC64OR {
 				break
 			}
@@ -26772,21 +26796,23 @@ func rewriteBlockPPC64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockPPC64GE
-			v0 := b.NewValue0(v.Pos, OpPPC64ORCC, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ORCC, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GE (CMPconst [0] z:(XOR x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (GE (XORCC x y) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpPPC64XOR {
 				break
 			}
@@ -26796,97 +26822,105 @@ func rewriteBlockPPC64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockPPC64GE
-			v0 := b.NewValue0(v.Pos, OpPPC64XORCC, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64XORCC, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 	case BlockPPC64GT:
 		// match: (GT (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpPPC64FlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpPPC64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GT (FlagLT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpPPC64FlagLT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpPPC64FlagLT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (GT (FlagGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpPPC64FlagGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpPPC64FlagGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (InvertFlags cmp) yes no)
 		// result: (LT cmp yes no)
-		for v.Op == OpPPC64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpPPC64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockPPC64LT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] (ANDconst [c] x)) yes no)
 		// result: (GT (ANDCCconst [c] x) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64ANDconst {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0.AuxInt
-			x := v_0.Args[0]
+			c := v_0_0.AuxInt
+			x := v_0_0.Args[0]
 			b.Kind = BlockPPC64GT
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPWconst [0] (ANDconst [c] x)) yes no)
 		// result: (GT (ANDCCconst [c] x) yes no)
-		for v.Op == OpPPC64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64ANDconst {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0.AuxInt
-			x := v_0.Args[0]
+			c := v_0_0.AuxInt
+			x := v_0_0.Args[0]
 			b.Kind = BlockPPC64GT
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] z:(AND x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (GT (ANDCC x y) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpPPC64AND {
 				break
 			}
@@ -26896,21 +26930,23 @@ func rewriteBlockPPC64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockPPC64GT
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCC, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCC, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] z:(OR x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (GT (ORCC x y) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpPPC64OR {
 				break
 			}
@@ -26920,21 +26956,23 @@ func rewriteBlockPPC64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockPPC64GT
-			v0 := b.NewValue0(v.Pos, OpPPC64ORCC, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ORCC, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (GT (CMPconst [0] z:(XOR x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (GT (XORCC x y) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpPPC64XOR {
 				break
 			}
@@ -26944,199 +26982,228 @@ func rewriteBlockPPC64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockPPC64GT
-			v0 := b.NewValue0(v.Pos, OpPPC64XORCC, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64XORCC, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 	case BlockIf:
 		// match: (If (Equal cc) yes no)
 		// result: (EQ cc yes no)
-		for v.Op == OpPPC64Equal {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpPPC64Equal {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockPPC64EQ
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (NotEqual cc) yes no)
 		// result: (NE cc yes no)
-		for v.Op == OpPPC64NotEqual {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpPPC64NotEqual {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockPPC64NE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (LessThan cc) yes no)
 		// result: (LT cc yes no)
-		for v.Op == OpPPC64LessThan {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpPPC64LessThan {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockPPC64LT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (LessEqual cc) yes no)
 		// result: (LE cc yes no)
-		for v.Op == OpPPC64LessEqual {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpPPC64LessEqual {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockPPC64LE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (GreaterThan cc) yes no)
 		// result: (GT cc yes no)
-		for v.Op == OpPPC64GreaterThan {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpPPC64GreaterThan {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockPPC64GT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (GreaterEqual cc) yes no)
 		// result: (GE cc yes no)
-		for v.Op == OpPPC64GreaterEqual {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpPPC64GreaterEqual {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockPPC64GE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (FLessThan cc) yes no)
 		// result: (FLT cc yes no)
-		for v.Op == OpPPC64FLessThan {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpPPC64FLessThan {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockPPC64FLT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (FLessEqual cc) yes no)
 		// result: (FLE cc yes no)
-		for v.Op == OpPPC64FLessEqual {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpPPC64FLessEqual {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockPPC64FLE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (FGreaterThan cc) yes no)
 		// result: (FGT cc yes no)
-		for v.Op == OpPPC64FGreaterThan {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpPPC64FGreaterThan {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockPPC64FGT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If (FGreaterEqual cc) yes no)
 		// result: (FGE cc yes no)
-		for v.Op == OpPPC64FGreaterEqual {
-			cc := v.Args[0]
+		for b.Controls[0].Op == OpPPC64FGreaterEqual {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
 			b.Kind = BlockPPC64FGE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (If cond yes no)
 		// result: (NE (CMPWconst [0] cond) yes no)
 		for {
-			cond := b.Control
+			cond := b.Controls[0]
 			b.Kind = BlockPPC64NE
-			v0 := b.NewValue0(v.Pos, OpPPC64CMPWconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(cond.Pos, OpPPC64CMPWconst, types.TypeFlags)
 			v0.AuxInt = 0
 			v0.AddArg(cond)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 	case BlockPPC64LE:
 		// match: (LE (FlagEQ) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpPPC64FlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpPPC64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (FlagLT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpPPC64FlagLT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpPPC64FlagLT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (FlagGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpPPC64FlagGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpPPC64FlagGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LE (InvertFlags cmp) yes no)
 		// result: (GE cmp yes no)
-		for v.Op == OpPPC64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpPPC64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockPPC64GE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] (ANDconst [c] x)) yes no)
 		// result: (LE (ANDCCconst [c] x) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64ANDconst {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0.AuxInt
-			x := v_0.Args[0]
+			c := v_0_0.AuxInt
+			x := v_0_0.Args[0]
 			b.Kind = BlockPPC64LE
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPWconst [0] (ANDconst [c] x)) yes no)
 		// result: (LE (ANDCCconst [c] x) yes no)
-		for v.Op == OpPPC64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64ANDconst {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0.AuxInt
-			x := v_0.Args[0]
+			c := v_0_0.AuxInt
+			x := v_0_0.Args[0]
 			b.Kind = BlockPPC64LE
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] z:(AND x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (LE (ANDCC x y) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpPPC64AND {
 				break
 			}
@@ -27146,21 +27213,23 @@ func rewriteBlockPPC64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockPPC64LE
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCC, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCC, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] z:(OR x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (LE (ORCC x y) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpPPC64OR {
 				break
 			}
@@ -27170,21 +27239,23 @@ func rewriteBlockPPC64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockPPC64LE
-			v0 := b.NewValue0(v.Pos, OpPPC64ORCC, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ORCC, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LE (CMPconst [0] z:(XOR x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (LE (XORCC x y) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpPPC64XOR {
 				break
 			}
@@ -27194,97 +27265,105 @@ func rewriteBlockPPC64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockPPC64LE
-			v0 := b.NewValue0(v.Pos, OpPPC64XORCC, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64XORCC, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 	case BlockPPC64LT:
 		// match: (LT (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpPPC64FlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpPPC64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LT (FlagLT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpPPC64FlagLT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpPPC64FlagLT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (FlagGT) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpPPC64FlagGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpPPC64FlagGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (LT (InvertFlags cmp) yes no)
 		// result: (GT cmp yes no)
-		for v.Op == OpPPC64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpPPC64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockPPC64GT
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] (ANDconst [c] x)) yes no)
 		// result: (LT (ANDCCconst [c] x) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64ANDconst {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0.AuxInt
-			x := v_0.Args[0]
+			c := v_0_0.AuxInt
+			x := v_0_0.Args[0]
 			b.Kind = BlockPPC64LT
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPWconst [0] (ANDconst [c] x)) yes no)
 		// result: (LT (ANDCCconst [c] x) yes no)
-		for v.Op == OpPPC64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64ANDconst {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0.AuxInt
-			x := v_0.Args[0]
+			c := v_0_0.AuxInt
+			x := v_0_0.Args[0]
 			b.Kind = BlockPPC64LT
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] z:(AND x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (LT (ANDCC x y) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpPPC64AND {
 				break
 			}
@@ -27294,21 +27373,23 @@ func rewriteBlockPPC64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockPPC64LT
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCC, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCC, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] z:(OR x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (LT (ORCC x y) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpPPC64OR {
 				break
 			}
@@ -27318,21 +27399,23 @@ func rewriteBlockPPC64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockPPC64LT
-			v0 := b.NewValue0(v.Pos, OpPPC64ORCC, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ORCC, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (LT (CMPconst [0] z:(XOR x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (LT (XORCC x y) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpPPC64XOR {
 				break
 			}
@@ -27342,296 +27425,328 @@ func rewriteBlockPPC64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockPPC64LT
-			v0 := b.NewValue0(v.Pos, OpPPC64XORCC, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64XORCC, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 	case BlockPPC64NE:
 		// match: (NE (CMPWconst [0] (Equal cc)) yes no)
 		// result: (EQ cc yes no)
-		for v.Op == OpPPC64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64Equal {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64Equal {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockPPC64EQ
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPWconst [0] (NotEqual cc)) yes no)
 		// result: (NE cc yes no)
-		for v.Op == OpPPC64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64NotEqual {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64NotEqual {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockPPC64NE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPWconst [0] (LessThan cc)) yes no)
 		// result: (LT cc yes no)
-		for v.Op == OpPPC64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64LessThan {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64LessThan {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockPPC64LT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPWconst [0] (LessEqual cc)) yes no)
 		// result: (LE cc yes no)
-		for v.Op == OpPPC64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64LessEqual {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64LessEqual {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockPPC64LE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPWconst [0] (GreaterThan cc)) yes no)
 		// result: (GT cc yes no)
-		for v.Op == OpPPC64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64GreaterThan {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64GreaterThan {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockPPC64GT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPWconst [0] (GreaterEqual cc)) yes no)
 		// result: (GE cc yes no)
-		for v.Op == OpPPC64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64GreaterEqual {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64GreaterEqual {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockPPC64GE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPWconst [0] (FLessThan cc)) yes no)
 		// result: (FLT cc yes no)
-		for v.Op == OpPPC64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64FLessThan {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64FLessThan {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockPPC64FLT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPWconst [0] (FLessEqual cc)) yes no)
 		// result: (FLE cc yes no)
-		for v.Op == OpPPC64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64FLessEqual {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64FLessEqual {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockPPC64FLE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPWconst [0] (FGreaterThan cc)) yes no)
 		// result: (FGT cc yes no)
-		for v.Op == OpPPC64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64FGreaterThan {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64FGreaterThan {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockPPC64FGT
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPWconst [0] (FGreaterEqual cc)) yes no)
 		// result: (FGE cc yes no)
-		for v.Op == OpPPC64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64FGreaterEqual {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64FGreaterEqual {
 				break
 			}
-			cc := v_0.Args[0]
+			cc := v_0_0.Args[0]
 			b.Kind = BlockPPC64FGE
-			b.SetControl(cc)
+			b.ResetControls()
+			b.AddControl(cc)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] (ANDconst [c] x)) yes no)
 		// result: (NE (ANDCCconst [c] x) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64ANDconst {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0.AuxInt
-			x := v_0.Args[0]
+			c := v_0_0.AuxInt
+			x := v_0_0.Args[0]
 			b.Kind = BlockPPC64NE
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPWconst [0] (ANDconst [c] x)) yes no)
 		// result: (NE (ANDCCconst [c] x) yes no)
-		for v.Op == OpPPC64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64ANDconst {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0.AuxInt
-			x := v_0.Args[0]
+			c := v_0_0.AuxInt
+			x := v_0_0.Args[0]
 			b.Kind = BlockPPC64NE
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FlagEQ) yes no)
-		// result: (First nil no yes)
-		for v.Op == OpPPC64FlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpPPC64FlagEQ {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (NE (FlagLT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpPPC64FlagLT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpPPC64FlagLT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (FlagGT) yes no)
-		// result: (First nil yes no)
-		for v.Op == OpPPC64FlagGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpPPC64FlagGT {
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (InvertFlags cmp) yes no)
 		// result: (NE cmp yes no)
-		for v.Op == OpPPC64InvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpPPC64InvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			b.Kind = BlockPPC64NE
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] (ANDconst [c] x)) yes no)
 		// result: (NE (ANDCCconst [c] x) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64ANDconst {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0.AuxInt
-			x := v_0.Args[0]
+			c := v_0_0.AuxInt
+			x := v_0_0.Args[0]
 			b.Kind = BlockPPC64NE
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPWconst [0] (ANDconst [c] x)) yes no)
 		// result: (NE (ANDCCconst [c] x) yes no)
-		for v.Op == OpPPC64CMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpPPC64ANDconst {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0.AuxInt
-			x := v_0.Args[0]
+			c := v_0_0.AuxInt
+			x := v_0_0.Args[0]
 			b.Kind = BlockPPC64NE
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
 			v0.AuxInt = c
 			v0.AddArg(x)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] z:(AND x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (NE (ANDCC x y) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpPPC64AND {
 				break
 			}
@@ -27641,21 +27756,23 @@ func rewriteBlockPPC64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockPPC64NE
-			v0 := b.NewValue0(v.Pos, OpPPC64ANDCC, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCC, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] z:(OR x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (NE (ORCC x y) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpPPC64OR {
 				break
 			}
@@ -27665,21 +27782,23 @@ func rewriteBlockPPC64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockPPC64NE
-			v0 := b.NewValue0(v.Pos, OpPPC64ORCC, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64ORCC, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
 		// match: (NE (CMPconst [0] z:(XOR x y)) yes no)
 		// cond: z.Uses == 1
 		// result: (NE (XORCC x y) yes no)
-		for v.Op == OpPPC64CMPconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpPPC64CMPconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			z := v.Args[0]
+			z := v_0.Args[0]
 			if z.Op != OpPPC64XOR {
 				break
 			}
@@ -27689,10 +27808,11 @@ func rewriteBlockPPC64(b *Block) bool {
 				break
 			}
 			b.Kind = BlockPPC64NE
-			v0 := b.NewValue0(v.Pos, OpPPC64XORCC, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(v_0.Pos, OpPPC64XORCC, types.TypeFlags)
 			v0.AddArg(x)
 			v0.AddArg(y)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = nil
 			return true
 		}
diff --git a/src/cmd/compile/internal/ssa/rewriteS390X.go b/src/cmd/compile/internal/ssa/rewriteS390X.go
index 84fe1473c0..9db0cc42e9 100644
--- a/src/cmd/compile/internal/ssa/rewriteS390X.go
+++ b/src/cmd/compile/internal/ssa/rewriteS390X.go
@@ -36449,37 +36449,38 @@ func rewriteValueS390X_OpZeroExt8to64_0(v *Value) bool {
 }
 func rewriteBlockS390X(b *Block) bool {
 	typ := &b.Func.Config.Types
-	v := b.Control
 	switch b.Kind {
 	case BlockS390XBRC:
 		// match: (BRC {c} (CMPWconst [0] (LOCGR {d} (MOVDconst [0]) (MOVDconst [x]) cmp)) yes no)
 		// cond: x != 0 && c.(s390x.CCMask) == s390x.Equal
 		// result: (BRC {d} cmp no yes)
-		for v.Op == OpS390XCMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpS390XCMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpS390XLOCGR {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpS390XLOCGR {
 				break
 			}
-			d := v_0.Aux
-			cmp := v_0.Args[2]
-			v_0_0 := v_0.Args[0]
-			if v_0_0.Op != OpS390XMOVDconst || v_0_0.AuxInt != 0 {
+			d := v_0_0.Aux
+			cmp := v_0_0.Args[2]
+			v_0_0_0 := v_0_0.Args[0]
+			if v_0_0_0.Op != OpS390XMOVDconst || v_0_0_0.AuxInt != 0 {
 				break
 			}
-			v_0_1 := v_0.Args[1]
-			if v_0_1.Op != OpS390XMOVDconst {
+			v_0_0_1 := v_0_0.Args[1]
+			if v_0_0_1.Op != OpS390XMOVDconst {
 				break
 			}
-			x := v_0_1.AuxInt
+			x := v_0_0_1.AuxInt
 			c := b.Aux
 			if !(x != 0 && c.(s390x.CCMask) == s390x.Equal) {
 				break
 			}
 			b.Kind = BlockS390XBRC
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = d
 			b.swapSuccessors()
 			return true
@@ -36487,148 +36488,152 @@ func rewriteBlockS390X(b *Block) bool {
 		// match: (BRC {c} (CMPWconst [0] (LOCGR {d} (MOVDconst [0]) (MOVDconst [x]) cmp)) yes no)
 		// cond: x != 0 && c.(s390x.CCMask) == s390x.NotEqual
 		// result: (BRC {d} cmp yes no)
-		for v.Op == OpS390XCMPWconst {
-			if v.AuxInt != 0 {
+		for b.Controls[0].Op == OpS390XCMPWconst {
+			v_0 := b.Controls[0]
+			if v_0.AuxInt != 0 {
 				break
 			}
-			v_0 := v.Args[0]
-			if v_0.Op != OpS390XLOCGR {
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpS390XLOCGR {
 				break
 			}
-			d := v_0.Aux
-			cmp := v_0.Args[2]
-			v_0_0 := v_0.Args[0]
-			if v_0_0.Op != OpS390XMOVDconst || v_0_0.AuxInt != 0 {
+			d := v_0_0.Aux
+			cmp := v_0_0.Args[2]
+			v_0_0_0 := v_0_0.Args[0]
+			if v_0_0_0.Op != OpS390XMOVDconst || v_0_0_0.AuxInt != 0 {
 				break
 			}
-			v_0_1 := v_0.Args[1]
-			if v_0_1.Op != OpS390XMOVDconst {
+			v_0_0_1 := v_0_0.Args[1]
+			if v_0_0_1.Op != OpS390XMOVDconst {
 				break
 			}
-			x := v_0_1.AuxInt
+			x := v_0_0_1.AuxInt
 			c := b.Aux
 			if !(x != 0 && c.(s390x.CCMask) == s390x.NotEqual) {
 				break
 			}
 			b.Kind = BlockS390XBRC
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = d
 			return true
 		}
 		// match: (BRC {c} (InvertFlags cmp) yes no)
 		// result: (BRC {c.(s390x.CCMask).ReverseComparison()} cmp yes no)
-		for v.Op == OpS390XInvertFlags {
-			cmp := v.Args[0]
+		for b.Controls[0].Op == OpS390XInvertFlags {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
 			c := b.Aux
 			b.Kind = BlockS390XBRC
-			b.SetControl(cmp)
+			b.ResetControls()
+			b.AddControl(cmp)
 			b.Aux = c.(s390x.CCMask).ReverseComparison()
 			return true
 		}
 		// match: (BRC {c} (FlagEQ) yes no)
 		// cond: c.(s390x.CCMask) & s390x.Equal != 0
-		// result: (First nil yes no)
-		for v.Op == OpS390XFlagEQ {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpS390XFlagEQ {
 			c := b.Aux
 			if !(c.(s390x.CCMask)&s390x.Equal != 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (BRC {c} (FlagLT) yes no)
 		// cond: c.(s390x.CCMask) & s390x.Less != 0
-		// result: (First nil yes no)
-		for v.Op == OpS390XFlagLT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpS390XFlagLT {
 			c := b.Aux
 			if !(c.(s390x.CCMask)&s390x.Less != 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (BRC {c} (FlagGT) yes no)
 		// cond: c.(s390x.CCMask) & s390x.Greater != 0
-		// result: (First nil yes no)
-		for v.Op == OpS390XFlagGT {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpS390XFlagGT {
 			c := b.Aux
 			if !(c.(s390x.CCMask)&s390x.Greater != 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (BRC {c} (FlagOV) yes no)
 		// cond: c.(s390x.CCMask) & s390x.Unordered != 0
-		// result: (First nil yes no)
-		for v.Op == OpS390XFlagOV {
+		// result: (First yes no)
+		for b.Controls[0].Op == OpS390XFlagOV {
 			c := b.Aux
 			if !(c.(s390x.CCMask)&s390x.Unordered != 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (BRC {c} (FlagEQ) yes no)
 		// cond: c.(s390x.CCMask) & s390x.Equal == 0
-		// result: (First nil no yes)
-		for v.Op == OpS390XFlagEQ {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpS390XFlagEQ {
 			c := b.Aux
 			if !(c.(s390x.CCMask)&s390x.Equal == 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (BRC {c} (FlagLT) yes no)
 		// cond: c.(s390x.CCMask) & s390x.Less == 0
-		// result: (First nil no yes)
-		for v.Op == OpS390XFlagLT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpS390XFlagLT {
 			c := b.Aux
 			if !(c.(s390x.CCMask)&s390x.Less == 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (BRC {c} (FlagGT) yes no)
 		// cond: c.(s390x.CCMask) & s390x.Greater == 0
-		// result: (First nil no yes)
-		for v.Op == OpS390XFlagGT {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpS390XFlagGT {
 			c := b.Aux
 			if !(c.(s390x.CCMask)&s390x.Greater == 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (BRC {c} (FlagOV) yes no)
 		// cond: c.(s390x.CCMask) & s390x.Unordered == 0
-		// result: (First nil no yes)
-		for v.Op == OpS390XFlagOV {
+		// result: (First no yes)
+		for b.Controls[0].Op == OpS390XFlagOV {
 			c := b.Aux
 			if !(c.(s390x.CCMask)&s390x.Unordered == 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
@@ -36637,14 +36642,15 @@ func rewriteBlockS390X(b *Block) bool {
 		// match: (If cond yes no)
 		// result: (BRC {s390x.NotEqual} (CMPWconst [0] (MOVBZreg <typ.Bool> cond)) yes no)
 		for {
-			cond := b.Control
+			cond := b.Controls[0]
 			b.Kind = BlockS390XBRC
-			v0 := b.NewValue0(v.Pos, OpS390XCMPWconst, types.TypeFlags)
+			b.ResetControls()
+			v0 := b.NewValue0(cond.Pos, OpS390XCMPWconst, types.TypeFlags)
 			v0.AuxInt = 0
-			v1 := b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.Bool)
+			v1 := b.NewValue0(cond.Pos, OpS390XMOVBZreg, typ.Bool)
 			v1.AddArg(cond)
 			v0.AddArg(v1)
-			b.SetControl(v0)
+			b.AddControl(v0)
 			b.Aux = s390x.NotEqual
 			return true
 		}
diff --git a/src/cmd/compile/internal/ssa/rewritegeneric.go b/src/cmd/compile/internal/ssa/rewritegeneric.go
index be1aefbfdc..091dff60be 100644
--- a/src/cmd/compile/internal/ssa/rewritegeneric.go
+++ b/src/cmd/compile/internal/ssa/rewritegeneric.go
@@ -47407,42 +47407,45 @@ func rewriteValuegeneric_OpZeroExt8to64_0(v *Value) bool {
 	return false
 }
 func rewriteBlockgeneric(b *Block) bool {
-	v := b.Control
 	switch b.Kind {
 	case BlockIf:
 		// match: (If (Not cond) yes no)
 		// result: (If cond no yes)
-		for v.Op == OpNot {
-			cond := v.Args[0]
+		for b.Controls[0].Op == OpNot {
+			v_0 := b.Controls[0]
+			cond := v_0.Args[0]
 			b.Kind = BlockIf
-			b.SetControl(cond)
+			b.ResetControls()
+			b.AddControl(cond)
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
 		}
 		// match: (If (ConstBool [c]) yes no)
 		// cond: c == 1
-		// result: (First nil yes no)
-		for v.Op == OpConstBool {
-			c := v.AuxInt
+		// result: (First yes no)
+		for b.Controls[0].Op == OpConstBool {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(c == 1) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			return true
 		}
 		// match: (If (ConstBool [c]) yes no)
 		// cond: c == 0
-		// result: (First nil no yes)
-		for v.Op == OpConstBool {
-			c := v.AuxInt
+		// result: (First no yes)
+		for b.Controls[0].Op == OpConstBool {
+			v_0 := b.Controls[0]
+			c := v_0.AuxInt
 			if !(c == 0) {
 				break
 			}
 			b.Kind = BlockFirst
-			b.SetControl(nil)
+			b.ResetControls()
 			b.Aux = nil
 			b.swapSuccessors()
 			return true
diff --git a/src/cmd/compile/internal/ssa/schedule.go b/src/cmd/compile/internal/ssa/schedule.go
index ca0e82953e..ff0ef25e90 100644
--- a/src/cmd/compile/internal/ssa/schedule.go
+++ b/src/cmd/compile/internal/ssa/schedule.go
@@ -195,27 +195,31 @@ func schedule(f *Func) {
 			}
 		}
 
-		if b.Control != nil && b.Control.Op != OpPhi && b.Control.Op != OpArg {
-			// Force the control value to be scheduled at the end,
-			// unless it is a phi value (which must be first).
+		for _, c := range b.ControlValues() {
+			// Force the control values to be scheduled at the end,
+			// unless they are phi values (which must be first).
 			// OpArg also goes first -- if it is stack it register allocates
 			// to a LoadReg, if it is register it is from the beginning anyway.
-			score[b.Control.ID] = ScoreControl
+			if c.Op == OpPhi || c.Op == OpArg {
+				continue
+			}
+			score[c.ID] = ScoreControl
 
-			// Schedule values dependent on the control value at the end.
+			// Schedule values dependent on the control values at the end.
 			// This reduces the number of register spills. We don't find
-			// all values that depend on the control, just values with a
+			// all values that depend on the controls, just values with a
 			// direct dependency. This is cheaper and in testing there
 			// was no difference in the number of spills.
 			for _, v := range b.Values {
 				if v.Op != OpPhi {
 					for _, a := range v.Args {
-						if a == b.Control {
+						if a == c {
 							score[v.ID] = ScoreControl
 						}
 					}
 				}
 			}
+
 		}
 
 		// To put things into a priority queue
diff --git a/src/cmd/compile/internal/ssa/shortcircuit.go b/src/cmd/compile/internal/ssa/shortcircuit.go
index 5bf0888043..bb2322e28a 100644
--- a/src/cmd/compile/internal/ssa/shortcircuit.go
+++ b/src/cmd/compile/internal/ssa/shortcircuit.go
@@ -32,7 +32,7 @@ func shortcircuit(f *Func) {
 				if p.Kind != BlockIf {
 					continue
 				}
-				if p.Control != a {
+				if p.Controls[0] != a {
 					continue
 				}
 				if e.i == 0 {
@@ -103,7 +103,7 @@ func shortcircuitBlock(b *Block) bool {
 	// Look for control values of the form Copy(Not(Copy(Phi(const, ...)))).
 	// Those must be the only values in the b, and they each must be used only by b.
 	// Track the negations so that we can swap successors as needed later.
-	v := b.Control
+	v := b.Controls[0]
 	nval := 1 // the control value
 	swap := false
 	for v.Uses == 1 && v.Block == b && (v.Op == OpCopy || v.Op == OpNot) {
diff --git a/src/cmd/compile/internal/ssa/sizeof_test.go b/src/cmd/compile/internal/ssa/sizeof_test.go
index 449788d32a..8ba6a88b66 100644
--- a/src/cmd/compile/internal/ssa/sizeof_test.go
+++ b/src/cmd/compile/internal/ssa/sizeof_test.go
@@ -23,7 +23,7 @@ func TestSizeof(t *testing.T) {
 		_64bit uintptr     // size on 64bit platforms
 	}{
 		{Value{}, 72, 112},
-		{Block{}, 152, 288},
+		{Block{}, 156, 296},
 		{LocalSlot{}, 32, 48},
 		{valState{}, 28, 40},
 	}
diff --git a/src/cmd/compile/internal/ssa/tighten.go b/src/cmd/compile/internal/ssa/tighten.go
index 580a06dfde..5dfc453649 100644
--- a/src/cmd/compile/internal/ssa/tighten.go
+++ b/src/cmd/compile/internal/ssa/tighten.go
@@ -87,7 +87,7 @@ func tighten(f *Func) {
 					}
 				}
 			}
-			if c := b.Control; c != nil {
+			for _, c := range b.ControlValues() {
 				if !canMove[c.ID] {
 					continue
 				}
diff --git a/src/cmd/compile/internal/ssa/value.go b/src/cmd/compile/internal/ssa/value.go
index a0905eab1e..d2038fcfa5 100644
--- a/src/cmd/compile/internal/ssa/value.go
+++ b/src/cmd/compile/internal/ssa/value.go
@@ -47,7 +47,7 @@ type Value struct {
 	// Source position
 	Pos src.XPos
 
-	// Use count. Each appearance in Value.Args and Block.Control counts once.
+	// Use count. Each appearance in Value.Args and Block.Controls counts once.
 	Uses int32
 
 	// wasm: Value stays on the WebAssembly stack. This value will not get a "register" (WebAssembly variable)
diff --git a/src/cmd/compile/internal/ssa/writebarrier.go b/src/cmd/compile/internal/ssa/writebarrier.go
index 5fc0ec19f7..4c51f9c788 100644
--- a/src/cmd/compile/internal/ssa/writebarrier.go
+++ b/src/cmd/compile/internal/ssa/writebarrier.go
@@ -182,7 +182,7 @@ func writebarrier(f *Func) {
 		b.Pos = pos
 
 		// set up control flow for end block
-		bEnd.SetControl(b.Control)
+		bEnd.CopyControls(b)
 		bEnd.Likely = b.Likely
 		for _, e := range b.Succs {
 			bEnd.Succs = append(bEnd.Succs, e)
diff --git a/src/cmd/compile/internal/wasm/ssa.go b/src/cmd/compile/internal/wasm/ssa.go
index 8584fca9be..75b306e168 100644
--- a/src/cmd/compile/internal/wasm/ssa.go
+++ b/src/cmd/compile/internal/wasm/ssa.go
@@ -78,20 +78,20 @@ func ssaGenBlock(s *gc.SSAGenState, b, next *ssa.Block) {
 		switch next {
 		case b.Succs[0].Block():
 			// if false, jump to b.Succs[1]
-			getValue32(s, b.Control)
+			getValue32(s, b.Controls[0])
 			s.Prog(wasm.AI32Eqz)
 			s.Prog(wasm.AIf)
 			s.Br(obj.AJMP, b.Succs[1].Block())
 			s.Prog(wasm.AEnd)
 		case b.Succs[1].Block():
 			// if true, jump to b.Succs[0]
-			getValue32(s, b.Control)
+			getValue32(s, b.Controls[0])
 			s.Prog(wasm.AIf)
 			s.Br(obj.AJMP, b.Succs[0].Block())
 			s.Prog(wasm.AEnd)
 		default:
 			// if true, jump to b.Succs[0], else jump to b.Succs[1]
-			getValue32(s, b.Control)
+			getValue32(s, b.Controls[0])
 			s.Prog(wasm.AIf)
 			s.Br(obj.AJMP, b.Succs[0].Block())
 			s.Prog(wasm.AEnd)
diff --git a/src/cmd/compile/internal/x86/ssa.go b/src/cmd/compile/internal/x86/ssa.go
index 66c7b753c6..603903ba48 100644
--- a/src/cmd/compile/internal/x86/ssa.go
+++ b/src/cmd/compile/internal/x86/ssa.go
@@ -18,8 +18,8 @@ import (
 // markMoves marks any MOVXconst ops that need to avoid clobbering flags.
 func ssaMarkMoves(s *gc.SSAGenState, b *ssa.Block) {
 	flive := b.FlagsLiveAtEnd
-	if b.Control != nil && b.Control.Type.IsFlags() {
-		flive = true
+	for _, c := range b.ControlValues() {
+		flive = c.Type.IsFlags() || flive
 	}
 	for i := len(b.Values) - 1; i >= 0; i-- {
 		v := b.Values[i]
@@ -952,6 +952,6 @@ func ssaGenBlock(s *gc.SSAGenState, b, next *ssa.Block) {
 			}
 		}
 	default:
-		b.Fatalf("branch not implemented: %s. Control: %s", b.LongString(), b.Control.LongString())
+		b.Fatalf("branch not implemented: %s", b.LongString())
 	}
 }
