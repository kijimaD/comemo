commit b003ee499a97f28a1328a8eaeb380596fad5788b
Author: Robert Griesemer <gri@golang.org>
Date:   Tue Dec 6 14:43:39 2022 -0800

    internal/types: consistently use double quotes around ERROR patterns
    
    Before matching the pattern, the double quotes are simply stripped
    (no Go string unquoting) for now. This is a first step towards use
    of proper Go strings as ERROR patterns.
    
    The changes were obtained through a couple of global regexp
    find/replace commands:
    
    /\* ERROR ([^"]+) \*/   =>   /* ERROR "$1" */
    // ERROR ([^"]+)$       =>   // ERROR "$1"
    
    followed up by manual fixes where multiple "/* ERROR"-style
    errors appeared on the same line (in that case, the first
    regexp matches the first and last ERROR).
    
    For #51006.
    
    Change-Id: Ib92c2d5e339075aeec1ea74c339b5fecf953d1a0
    Reviewed-on: https://go-review.googlesource.com/c/go/+/455718
    Auto-Submit: Robert Griesemer <gri@google.com>
    Reviewed-by: Robert Griesemer <gri@google.com>
    Run-TryBot: Robert Griesemer <gri@google.com>
    Reviewed-by: Robert Findley <rfindley@google.com>
    TryBot-Result: Gopher Robot <gobot@golang.org>
---
 src/cmd/compile/internal/types2/check_test.go      |   8 +-
 .../internal/types2/testdata/local/issue47996.go   |   2 +-
 src/go/types/check_test.go                         |  12 +-
 src/go/types/issues_test.go                        |   8 +-
 src/internal/types/testdata/check/blank.go         |   2 +-
 src/internal/types/testdata/check/builtins0.go     | 492 ++++++++++-----------
 src/internal/types/testdata/check/builtins1.go     |  68 +--
 src/internal/types/testdata/check/const0.go        |  18 +-
 src/internal/types/testdata/check/constdecl.go     |  16 +-
 src/internal/types/testdata/check/cycles0.go       |  66 +--
 src/internal/types/testdata/check/cycles2.go       |  10 +-
 src/internal/types/testdata/check/cycles3.go       |   2 +-
 src/internal/types/testdata/check/cycles4.go       |   2 +-
 src/internal/types/testdata/check/cycles5.go       |  30 +-
 src/internal/types/testdata/check/decls0.go        |   8 +-
 src/internal/types/testdata/check/decls1.go        |   4 +-
 src/internal/types/testdata/check/decls4.go        |  28 +-
 src/internal/types/testdata/check/errors.go        |  42 +-
 src/internal/types/testdata/check/expr0.go         |  10 +-
 src/internal/types/testdata/check/expr1.go         |  72 +--
 src/internal/types/testdata/check/expr2.go         | 106 ++---
 src/internal/types/testdata/check/expr3.go         |   6 +-
 src/internal/types/testdata/check/go1_16.go        |   2 +-
 src/internal/types/testdata/check/go1_19.go        |   2 +-
 src/internal/types/testdata/check/go1_8.go         |   2 +-
 src/internal/types/testdata/check/importC.go       |   6 +-
 .../testdata/check/importdecl0/importdecl0b.go     |   8 +-
 .../testdata/check/importdecl1/importdecl1b.go     |   2 +-
 src/internal/types/testdata/check/init0.go         |  40 +-
 src/internal/types/testdata/check/init1.go         |  14 +-
 src/internal/types/testdata/check/init2.go         |  52 +--
 src/internal/types/testdata/check/issues0.go       | 142 +++---
 src/internal/types/testdata/check/issues1.go       |  26 +-
 src/internal/types/testdata/check/main0.go         |   4 +-
 src/internal/types/testdata/check/map0.go          |   2 +-
 src/internal/types/testdata/check/methodsets.go    |   4 +-
 src/internal/types/testdata/check/shifts.go        |   4 +-
 src/internal/types/testdata/check/slices.go        |   2 +-
 src/internal/types/testdata/check/stmt0.go         | 110 ++---
 src/internal/types/testdata/check/typeinference.go |  24 +-
 src/internal/types/testdata/check/typeinst0.go     |  20 +-
 src/internal/types/testdata/check/typeinst1.go     |  40 +-
 src/internal/types/testdata/check/typeparams.go    | 140 +++---
 src/internal/types/testdata/check/unions.go        |   6 +-
 src/internal/types/testdata/check/vardecl.go       |  16 +-
 .../types/testdata/examples/constraints.go         |  30 +-
 src/internal/types/testdata/examples/functions.go  |  30 +-
 src/internal/types/testdata/examples/inference.go  |  14 +-
 src/internal/types/testdata/examples/methods.go    |  10 +-
 src/internal/types/testdata/examples/operations.go |   6 +-
 src/internal/types/testdata/examples/types.go      |  62 +--
 src/internal/types/testdata/examples/typesets.go   |   8 +-
 src/internal/types/testdata/fixedbugs/54942.go     |   4 +-
 .../types/testdata/fixedbugs/issue20583.go         |   8 +-
 .../types/testdata/fixedbugs/issue28251.go         |   6 +-
 .../types/testdata/fixedbugs/issue39634.go         |  58 +--
 .../types/testdata/fixedbugs/issue39664.go         |   2 +-
 .../types/testdata/fixedbugs/issue39693.go         |   2 +-
 .../types/testdata/fixedbugs/issue39699.go         |   6 +-
 .../types/testdata/fixedbugs/issue39723.go         |   2 +-
 .../types/testdata/fixedbugs/issue39725.go         |   4 +-
 .../types/testdata/fixedbugs/issue39754.go         |   4 +-
 .../types/testdata/fixedbugs/issue39768.go         |   6 +-
 .../types/testdata/fixedbugs/issue39938.go         |   6 +-
 .../types/testdata/fixedbugs/issue39948.go         |   2 +-
 .../types/testdata/fixedbugs/issue39976.go         |   2 +-
 .../types/testdata/fixedbugs/issue40056.go         |   4 +-
 .../types/testdata/fixedbugs/issue40057.go         |   2 +-
 .../types/testdata/fixedbugs/issue40350.go         |   2 +-
 .../types/testdata/fixedbugs/issue40684.go         |   4 +-
 .../types/testdata/fixedbugs/issue41124.go         |  44 +-
 .../types/testdata/fixedbugs/issue42695.go         |  12 +-
 .../types/testdata/fixedbugs/issue42758.go         |   4 +-
 .../types/testdata/fixedbugs/issue42881.go         |   6 +-
 .../types/testdata/fixedbugs/issue42987.go         |   2 +-
 .../types/testdata/fixedbugs/issue43087.go         |  10 +-
 .../types/testdata/fixedbugs/issue43109.go         |   2 +-
 .../types/testdata/fixedbugs/issue43110.go         |   8 +-
 .../types/testdata/fixedbugs/issue43124.go         |   4 +-
 .../types/testdata/fixedbugs/issue43125.go         |   4 +-
 .../types/testdata/fixedbugs/issue43190.go         |  18 +-
 .../types/testdata/fixedbugs/issue43527.go         |   4 +-
 .../types/testdata/fixedbugs/issue43671.go         |   8 +-
 .../types/testdata/fixedbugs/issue45114.go         |   2 +-
 .../types/testdata/fixedbugs/issue45550.go         |   2 +-
 .../types/testdata/fixedbugs/issue45635.go         |   2 +-
 .../types/testdata/fixedbugs/issue45639.go         |   4 +-
 .../types/testdata/fixedbugs/issue45920.go         |   4 +-
 .../types/testdata/fixedbugs/issue46090.go         |   2 +-
 .../types/testdata/fixedbugs/issue46403.go         |   2 +-
 .../types/testdata/fixedbugs/issue46461.go         |   6 +-
 .../types/testdata/fixedbugs/issue46583.go         |   8 +-
 .../types/testdata/fixedbugs/issue47031.go         |   2 +-
 .../types/testdata/fixedbugs/issue47115.go         |   8 +-
 .../types/testdata/fixedbugs/issue47127.go         |  32 +-
 .../types/testdata/fixedbugs/issue47411.go         |  10 +-
 .../types/testdata/fixedbugs/issue47747.go         |   4 +-
 .../types/testdata/fixedbugs/issue47796.go         |  14 +-
 .../types/testdata/fixedbugs/issue47818.go         |  38 +-
 .../types/testdata/fixedbugs/issue47968.go         |   8 +-
 .../types/testdata/fixedbugs/issue48008.go         |  24 +-
 .../types/testdata/fixedbugs/issue48018.go         |   2 +-
 .../types/testdata/fixedbugs/issue48048.go         |   4 +-
 .../types/testdata/fixedbugs/issue48082.go         |   2 +-
 .../types/testdata/fixedbugs/issue48083.go         |   2 +-
 .../types/testdata/fixedbugs/issue48136.go         |  14 +-
 .../types/testdata/fixedbugs/issue48312.go         |   6 +-
 .../types/testdata/fixedbugs/issue48472.go         |   4 +-
 .../types/testdata/fixedbugs/issue48529.go         |   2 +-
 .../types/testdata/fixedbugs/issue48582.go         |  10 +-
 .../types/testdata/fixedbugs/issue48619.go         |   4 +-
 .../types/testdata/fixedbugs/issue48656.go         |   2 +-
 .../types/testdata/fixedbugs/issue48703.go         |   2 +-
 .../types/testdata/fixedbugs/issue48712.go         |  22 +-
 .../types/testdata/fixedbugs/issue48819.go         |   2 +-
 .../types/testdata/fixedbugs/issue48951.go         |  14 +-
 .../types/testdata/fixedbugs/issue48962.go         |   2 +-
 .../types/testdata/fixedbugs/issue48974.go         |   2 +-
 .../types/testdata/fixedbugs/issue49003.go         |   2 +-
 .../types/testdata/fixedbugs/issue49005.go         |   8 +-
 .../types/testdata/fixedbugs/issue49043.go         |   4 +-
 .../types/testdata/fixedbugs/issue49112.go         |   4 +-
 .../types/testdata/fixedbugs/issue49179.go         |   8 +-
 .../types/testdata/fixedbugs/issue49242.go         |  10 +-
 .../types/testdata/fixedbugs/issue49247.go         |   4 +-
 .../types/testdata/fixedbugs/issue49276.go         |  10 +-
 .../types/testdata/fixedbugs/issue49296.go         |   8 +-
 .../types/testdata/fixedbugs/issue49439.go         |   8 +-
 .../types/testdata/fixedbugs/issue49482.go         |   2 +-
 .../types/testdata/fixedbugs/issue49541.go         |   4 +-
 .../types/testdata/fixedbugs/issue49579.go         |   2 +-
 .../types/testdata/fixedbugs/issue49602.go         |   6 +-
 .../types/testdata/fixedbugs/issue49735.go         |   6 +-
 .../types/testdata/fixedbugs/issue49739.go         |   6 +-
 .../types/testdata/fixedbugs/issue49864.go         |   2 +-
 .../types/testdata/fixedbugs/issue50321.go         |   2 +-
 .../types/testdata/fixedbugs/issue50372.go         |  10 +-
 .../types/testdata/fixedbugs/issue50417.go         |  30 +-
 .../types/testdata/fixedbugs/issue50516.go         |   4 +-
 .../types/testdata/fixedbugs/issue50646.go         |  12 +-
 .../types/testdata/fixedbugs/issue50779.go         |   2 +-
 .../types/testdata/fixedbugs/issue50782.go         |   4 +-
 .../types/testdata/fixedbugs/issue50816.go         |   4 +-
 .../types/testdata/fixedbugs/issue50912.go         |  10 +-
 .../types/testdata/fixedbugs/issue50918.go         |   4 +-
 .../types/testdata/fixedbugs/issue50929.go         |  18 +-
 .../types/testdata/fixedbugs/issue50965.go         |   4 +-
 .../types/testdata/fixedbugs/issue51025.go         |  10 +-
 .../types/testdata/fixedbugs/issue51145.go         |   8 +-
 .../types/testdata/fixedbugs/issue51229.go         |   8 +-
 .../types/testdata/fixedbugs/issue51232.go         |  10 +-
 .../types/testdata/fixedbugs/issue51233.go         |   8 +-
 .../types/testdata/fixedbugs/issue51257.go         |   8 +-
 .../types/testdata/fixedbugs/issue51335.go         |   4 +-
 .../types/testdata/fixedbugs/issue51339.go         |   6 +-
 .../types/testdata/fixedbugs/issue51360.go         |  10 +-
 .../types/testdata/fixedbugs/issue51376.go         |   4 +-
 .../types/testdata/fixedbugs/issue51472.go         |  12 +-
 .../types/testdata/fixedbugs/issue51509.go         |   2 +-
 .../types/testdata/fixedbugs/issue51525.go         |  12 +-
 .../types/testdata/fixedbugs/issue51533.go         |   4 +-
 .../types/testdata/fixedbugs/issue51578.go         |   4 +-
 .../types/testdata/fixedbugs/issue51593.go         |   2 +-
 .../types/testdata/fixedbugs/issue51607.go         |  20 +-
 .../types/testdata/fixedbugs/issue51610.go         |   2 +-
 .../types/testdata/fixedbugs/issue51658.go         |   8 +-
 .../types/testdata/fixedbugs/issue51877.go         |   8 +-
 .../types/testdata/fixedbugs/issue52401.go         |   4 +-
 .../types/testdata/fixedbugs/issue52698.go         |   2 +-
 .../types/testdata/fixedbugs/issue52915.go         |   4 +-
 .../types/testdata/fixedbugs/issue53358.go         |   6 +-
 .../types/testdata/fixedbugs/issue54280.go         |   2 +-
 .../types/testdata/fixedbugs/issue54405.go         |   4 +-
 .../types/testdata/fixedbugs/issue56351.go         |   2 +-
 .../types/testdata/fixedbugs/issue56665.go         |   6 +-
 .../types/testdata/fixedbugs/issue57500.go         |   2 +-
 src/internal/types/testdata/fixedbugs/issue6977.go |   8 +-
 src/internal/types/testdata/spec/assignability.go  |  70 +--
 src/internal/types/testdata/spec/comparable.go     |   4 +-
 src/internal/types/testdata/spec/comparable1.19.go |  12 +-
 src/internal/types/testdata/spec/comparisons.go    |  76 ++--
 src/internal/types/testdata/spec/conversions.go    |  48 +-
 src/internal/types/testdata/spec/oldcomparable.go  |  12 +-
 183 files changed, 1490 insertions(+), 1478 deletions(-)

diff --git a/src/cmd/compile/internal/types2/check_test.go b/src/cmd/compile/internal/types2/check_test.go
index 611466ba01..6825133048 100644
--- a/src/cmd/compile/internal/types2/check_test.go
+++ b/src/cmd/compile/internal/types2/check_test.go
@@ -196,8 +196,14 @@ func testFiles(t *testing.T, filenames []string, colDelta uint, manual bool) {
 		indices = indices[:0]
 		for i, want := range errList {
 			pattern := strings.TrimSpace(want.Msg[len(" ERROR "):])
+			// We expect all patterns to be quoted in double quotes
+			// and then we remove the quotes.
+			// TODO(gri) use correct strconv.Unquote eventually
 			if n := len(pattern); n >= 2 && pattern[0] == '"' && pattern[n-1] == '"' {
 				pattern = pattern[1 : n-1]
+			} else {
+				t.Errorf("%s:%d:%d: unquoted pattern: %s", filename, line, want.Pos.Col(), pattern)
+				continue
 			}
 			rx, err := regexp.Compile(pattern)
 			if err != nil {
@@ -303,7 +309,7 @@ func TestCheck(t *testing.T) {
 }
 func TestSpec(t *testing.T) { testDirFiles(t, "../../../../internal/types/testdata/spec", 0, false) }
 func TestExamples(t *testing.T) {
-	testDirFiles(t, "../../../../internal/types/testdata/examples", 45, false)
+	testDirFiles(t, "../../../../internal/types/testdata/examples", 50, false)
 } // TODO(gri) narrow column tolerance
 func TestFixedbugs(t *testing.T) {
 	testDirFiles(t, "../../../../internal/types/testdata/fixedbugs", 100, false)
diff --git a/src/cmd/compile/internal/types2/testdata/local/issue47996.go b/src/cmd/compile/internal/types2/testdata/local/issue47996.go
index 2c4b6610fe..6fb50a611b 100644
--- a/src/cmd/compile/internal/types2/testdata/local/issue47996.go
+++ b/src/cmd/compile/internal/types2/testdata/local/issue47996.go
@@ -5,4 +5,4 @@
 package p
 
 // don't crash
-func T /* ERROR missing */ [P] /* ERROR missing */ m /* ERROR unexpected */ () /* ERROR \) */ { /* ERROR { */ } /* ERROR } */
+func T /* ERROR "missing" */ [P] /* ERROR "missing" */ m /* ERROR "unexpected" */ () /* ERROR "\)" */ { /* ERROR "{" */ } /* ERROR "}" */
diff --git a/src/go/types/check_test.go b/src/go/types/check_test.go
index 4d27f3629a..ea742f2b90 100644
--- a/src/go/types/check_test.go
+++ b/src/go/types/check_test.go
@@ -208,8 +208,14 @@ func testFiles(t *testing.T, sizes Sizes, filenames []string, srcs [][]byte, man
 		indices = indices[:0]
 		for i, want := range errList {
 			pattern := strings.TrimSpace(want.text[len(" ERROR "):])
+			// We expect all patterns to be quoted in double quotes
+			// and then we remove the quotes.
+			// TODO(gri) use correct strconv.Unquote eventually
 			if n := len(pattern); n >= 2 && pattern[0] == '"' && pattern[n-1] == '"' {
 				pattern = pattern[1 : n-1]
+			} else {
+				t.Errorf("%s:%d:%d: unquoted pattern: %s", filename, line, want.col, pattern)
+				continue
 			}
 			rx, err := regexp.Compile(pattern)
 			if err != nil {
@@ -320,7 +326,7 @@ func TestManual(t *testing.T) {
 }
 
 func TestLongConstants(t *testing.T) {
-	format := "package longconst\n\nconst _ = %s /* ERROR constant overflow */ \nconst _ = %s // ERROR excessively long constant"
+	format := `package longconst; const _ = %s /* ERROR "constant overflow" */; const _ = %s // ERROR "excessively long constant"`
 	src := fmt.Sprintf(format, strings.Repeat("1", 9999), strings.Repeat("1", 10001))
 	testFiles(t, nil, []string{"longconst.go"}, [][]byte{[]byte(src)}, false, nil)
 }
@@ -329,14 +335,14 @@ func TestLongConstants(t *testing.T) {
 // be representable as int even if they already have a type that can
 // represent larger values.
 func TestIndexRepresentability(t *testing.T) {
-	const src = "package index\n\nvar s []byte\nvar _ = s[int64 /* ERROR \"int64\\(1\\) << 40 \\(.*\\) overflows int\" */ (1) << 40]"
+	const src = `package index; var s []byte; var _ = s[int64 /* ERROR "int64\(1\) << 40 \(.*\) overflows int" */ (1) << 40]`
 	testFiles(t, &StdSizes{4, 4}, []string{"index.go"}, [][]byte{[]byte(src)}, false, nil)
 }
 
 func TestIssue47243_TypedRHS(t *testing.T) {
 	// The RHS of the shift expression below overflows uint on 32bit platforms,
 	// but this is OK as it is explicitly typed.
-	const src = "package issue47243\n\nvar a uint64; var _ = a << uint64(4294967296)" // uint64(1<<32)
+	const src = `package issue47243; var a uint64; var _ = a << uint64(4294967296)` // uint64(1<<32)
 	testFiles(t, &StdSizes{4, 4}, []string{"p.go"}, [][]byte{[]byte(src)}, false, nil)
 }
 
diff --git a/src/go/types/issues_test.go b/src/go/types/issues_test.go
index b4845b1def..cbd6ca29e9 100644
--- a/src/go/types/issues_test.go
+++ b/src/go/types/issues_test.go
@@ -574,7 +574,7 @@ import (
 func _() {
 	// Packages should be fully qualified when there is ambiguity within the
 	// error string itself.
-	a.F(template /* ERROR cannot use.*html/template.* as .*text/template */ .Template{})
+	a.F(template /* ERROR "cannot use.*html/template.* as .*text/template" */ .Template{})
 }
 `
 		csrc = `
@@ -587,12 +587,12 @@ import (
 )
 
 // Issue #46905: make sure template is not the first package qualified.
-var _ fmt.Stringer = 1 // ERROR cannot use 1.*as fmt\.Stringer
+var _ fmt.Stringer = 1 // ERROR "cannot use 1.*as fmt\.Stringer"
 
 // Packages should be fully qualified when there is ambiguity in reachable
 // packages. In this case both a (and for that matter html/template) import
 // text/template.
-func _() { a.G(template /* ERROR cannot use .*html/template.*Template */ .Template{}) }
+func _() { a.G(template /* ERROR "cannot use .*html/template.*Template" */ .Template{}) }
 `
 
 		tsrc = `
@@ -603,7 +603,7 @@ import "text/template"
 type T int
 
 // Verify that the current package name also causes disambiguation.
-var _ T = template /* ERROR cannot use.*text/template.* as T value */.Template{}
+var _ T = template /* ERROR "cannot use.*text/template.* as T value" */.Template{}
 `
 	)
 
diff --git a/src/internal/types/testdata/check/blank.go b/src/internal/types/testdata/check/blank.go
index 6a2507f482..2bea11f53b 100644
--- a/src/internal/types/testdata/check/blank.go
+++ b/src/internal/types/testdata/check/blank.go
@@ -2,4 +2,4 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package _ /* ERROR invalid package name */
+package _ /* ERROR "invalid package name" */
diff --git a/src/internal/types/testdata/check/builtins0.go b/src/internal/types/testdata/check/builtins0.go
index b54d339069..08b6004d1e 100644
--- a/src/internal/types/testdata/check/builtins0.go
+++ b/src/internal/types/testdata/check/builtins0.go
@@ -14,38 +14,38 @@ func append1() {
 	var b byte
 	var x int
 	var s []byte
-	_ = append() // ERROR not enough arguments
-	_ = append("foo" /* ERROR must be a slice */ )
-	_ = append(nil /* ERROR must be a slice */ , s)
-	_ = append(x /* ERROR must be a slice */ , s)
+	_ = append() // ERROR "not enough arguments"
+	_ = append("foo" /* ERROR "must be a slice" */ )
+	_ = append(nil /* ERROR "must be a slice" */ , s)
+	_ = append(x /* ERROR "must be a slice" */ , s)
 	_ = append(s)
 	_ = append(s, nil...)
-	append /* ERROR not used */ (s)
+	append /* ERROR "not used" */ (s)
 
 	_ = append(s, b)
-	_ = append(s, x /* ERROR cannot use x */ )
-	_ = append(s, s /* ERROR cannot use s */ )
-	_ = append(s...) /* ERROR not enough arguments */
-	_ = append(s, b, s /* ERROR too many arguments */ ...)
+	_ = append(s, x /* ERROR "cannot use x" */ )
+	_ = append(s, s /* ERROR "cannot use s" */ )
+	_ = append(s...) /* ERROR "not enough arguments" */
+	_ = append(s, b, s /* ERROR "too many arguments" */ ...)
 	_ = append(s, 1, 2, 3)
-	_ = append(s, 1, 2, 3, x /* ERROR cannot use x */ , 5, 6, 6)
-	_ = append(s, 1, 2 /* ERROR too many arguments */, s...)
+	_ = append(s, 1, 2, 3, x /* ERROR "cannot use x" */ , 5, 6, 6)
+	_ = append(s, 1, 2 /* ERROR "too many arguments" */, s...)
 	_ = append([]interface{}(nil), 1, 2, "foo", x, 3.1425, false)
 
 	type S []byte
 	type T string
 	var t T
-	_ = append(s, "foo" /* ERROR cannot use .* in argument to append */ )
+	_ = append(s, "foo" /* ERROR "cannot use .* in argument to append" */ )
 	_ = append(s, "foo"...)
-	_ = append(S(s), "foo" /* ERROR cannot use .* in argument to append */ )
+	_ = append(S(s), "foo" /* ERROR "cannot use .* in argument to append" */ )
 	_ = append(S(s), "foo"...)
-	_ = append(s, t /* ERROR cannot use t */ )
+	_ = append(s, t /* ERROR "cannot use t" */ )
 	_ = append(s, t...)
 	_ = append(s, T("foo")...)
-	_ = append(S(s), t /* ERROR cannot use t */ )
+	_ = append(S(s), t /* ERROR "cannot use t" */ )
 	_ = append(S(s), t...)
 	_ = append(S(s), T("foo")...)
-	_ = append([]string{}, t /* ERROR cannot use t */ , "foo")
+	_ = append([]string{}, t /* ERROR "cannot use t" */ , "foo")
 	_ = append([]T{}, t, "foo")
 }
 
@@ -72,27 +72,27 @@ func append3() {
 	f3 := func() (s []int, x, y int) { return }
 	f5 := func() (s []interface{}, x int, y float32, z string, b bool) { return }
 	ff := func() (int, float32) { return 0, 0 }
-	_ = append(f0 /* ERROR used as value */ ())
+	_ = append(f0 /* ERROR "used as value" */ ())
 	_ = append(f1())
 	_ = append(f2())
 	_ = append(f3())
 	_ = append(f5())
-	_ = append(ff /* ERROR must be a slice */ ()) // TODO(gri) better error message
+	_ = append(ff /* ERROR "must be a slice" */ ()) // TODO(gri) better error message
 }
 
 func cap1() {
 	var a [10]bool
 	var p *[20]int
 	var c chan string
-	_ = cap() // ERROR not enough arguments
-	_ = cap(1, 2) // ERROR too many arguments
-	_ = cap(42 /* ERROR invalid */)
+	_ = cap() // ERROR "not enough arguments"
+	_ = cap(1, 2) // ERROR "too many arguments"
+	_ = cap(42 /* ERROR "invalid" */)
 	const _3 = cap(a)
 	assert(_3 == 10)
 	const _4 = cap(p)
 	assert(_4 == 20)
 	_ = cap(c)
-	cap /* ERROR not used */ (c)
+	cap /* ERROR "not used" */ (c)
 
 	// issue 4744
 	type T struct{ a [10]int }
@@ -100,17 +100,17 @@ func cap1() {
 
 	var s [][]byte
 	_ = cap(s)
-	_ = cap(s... /* ERROR invalid use of \.\.\. */ )
+	_ = cap(s... /* ERROR "invalid use of \.\.\." */ )
 }
 
 func cap2() {
 	f1a := func() (a [10]int) { return }
 	f1s := func() (s []int) { return }
 	f2 := func() (s []int, x int) { return }
-	_ = cap(f0 /* ERROR used as value */ ())
+	_ = cap(f0 /* ERROR "used as value" */ ())
 	_ = cap(f1a())
 	_ = cap(f1s())
-	_ = cap(f2()) // ERROR too many arguments
+	_ = cap(f2()) // ERROR "too many arguments"
 }
 
 // test cases for issue 7387
@@ -120,8 +120,8 @@ func cap3() {
 	const (
 		_ = cap([4]int{})
 		_ = cap([4]int{x})
-		_ = cap /* ERROR not constant */ ([4]int{f()})
-		_ = cap /* ERROR not constant */ ([4]int{cap([]int{})})
+		_ = cap /* ERROR "not constant" */ ([4]int{f()})
+		_ = cap /* ERROR "not constant" */ ([4]int{cap([]int{})})
 		_ = cap([4]int{cap([4]int{})})
 	)
 	var y float64
@@ -130,12 +130,12 @@ func cap3() {
 		_ = cap([4]float64{})
 		_ = cap([4]float64{y})
 		_ = cap([4]float64{real(2i)})
-		_ = cap /* ERROR not constant */ ([4]float64{real(z)})
+		_ = cap /* ERROR "not constant" */ ([4]float64{real(z)})
 	)
 	var ch chan [10]int
 	const (
-		_ = cap /* ERROR not constant */ (<-ch)
-		_ = cap /* ERROR not constant */ ([4]int{(<-ch)[0]})
+		_ = cap /* ERROR "not constant" */ (<-ch)
+		_ = cap /* ERROR "not constant" */ ([4]int{(<-ch)[0]})
 	)
 }
 
@@ -143,7 +143,7 @@ func clear1() {
 	var a [10]int
 	var m map[float64]string
 	var s []byte
-	clear(a /* ERROR cannot clear a */)
+	clear(a /* ERROR "cannot clear a" */)
 	clear(&a)
 	clear(m)
 	clear(s)
@@ -153,23 +153,23 @@ func clear1() {
 func close1() {
 	var c chan int
 	var r <-chan int
-	close() // ERROR not enough arguments
-	close(1, 2) // ERROR too many arguments
-	close(42 /* ERROR cannot close non-channel */)
-	close(r /* ERROR receive-only channel */)
+	close() // ERROR "not enough arguments"
+	close(1, 2) // ERROR "too many arguments"
+	close(42 /* ERROR "cannot close non-channel" */)
+	close(r /* ERROR "receive-only channel" */)
 	close(c)
-	_ = close /* ERROR used as value */ (c)
+	_ = close /* ERROR "used as value" */ (c)
 
 	var s []chan int
-	close(s... /* ERROR invalid use of \.\.\. */ )
+	close(s... /* ERROR "invalid use of \.\.\." */ )
 }
 
 func close2() {
 	f1 := func() (ch chan int) { return }
 	f2 := func() (ch chan int, x int) { return }
-	close(f0 /* ERROR used as value */ ())
+	close(f0 /* ERROR "used as value" */ ())
 	close(f1())
-	close(f2()) // ERROR too many arguments
+	close(f2()) // ERROR "too many arguments"
 }
 
 func complex1() {
@@ -178,16 +178,16 @@ func complex1() {
 	var f64 float64
 	var c64 complex64
 	var c128 complex128
-	_ = complex() // ERROR not enough arguments
-	_ = complex(1) // ERROR not enough arguments
-	_ = complex(true /* ERROR mismatched types */ , 0)
-	_ = complex(i32 /* ERROR expected floating-point */ , 0)
-	_ = complex("foo" /* ERROR mismatched types */ , 0)
-	_ = complex(c64 /* ERROR expected floating-point */ , 0)
-	_ = complex(0 /* ERROR mismatched types */ , true)
-	_ = complex(0 /* ERROR expected floating-point */ , i32)
-	_ = complex(0 /* ERROR mismatched types */ , "foo")
-	_ = complex(0 /* ERROR expected floating-point */ , c64)
+	_ = complex() // ERROR "not enough arguments"
+	_ = complex(1) // ERROR "not enough arguments"
+	_ = complex(true /* ERROR "mismatched types" */ , 0)
+	_ = complex(i32 /* ERROR "expected floating-point" */ , 0)
+	_ = complex("foo" /* ERROR "mismatched types" */ , 0)
+	_ = complex(c64 /* ERROR "expected floating-point" */ , 0)
+	_ = complex(0 /* ERROR "mismatched types" */ , true)
+	_ = complex(0 /* ERROR "expected floating-point" */ , i32)
+	_ = complex(0 /* ERROR "mismatched types" */ , "foo")
+	_ = complex(0 /* ERROR "expected floating-point" */ , c64)
 	_ = complex(f32, f32)
 	_ = complex(f32, 1)
 	_ = complex(f32, 1.0)
@@ -196,17 +196,17 @@ func complex1() {
 	_ = complex(f64, 1)
 	_ = complex(f64, 1.0)
 	_ = complex(f64, 'a')
-	_ = complex(f32 /* ERROR mismatched types */ , f64)
-	_ = complex(f64 /* ERROR mismatched types */ , f32)
+	_ = complex(f32 /* ERROR "mismatched types" */ , f64)
+	_ = complex(f64 /* ERROR "mismatched types" */ , f32)
 	_ = complex(1, 1)
 	_ = complex(1, 1.1)
 	_ = complex(1, 'a')
-	complex /* ERROR not used */ (1, 2)
+	complex /* ERROR "not used" */ (1, 2)
 
 	var _ complex64 = complex(f32, f32)
-	var _ complex64 = complex /* ERROR cannot use .* in variable declaration */ (f64, f64)
+	var _ complex64 = complex /* ERROR "cannot use .* in variable declaration" */ (f64, f64)
 
-	var _ complex128 = complex /* ERROR cannot use .* in variable declaration */ (f32, f32)
+	var _ complex128 = complex /* ERROR "cannot use .* in variable declaration" */ (f32, f32)
 	var _ complex128 = complex(f64, f64)
 
 	// untyped constants
@@ -218,14 +218,14 @@ func complex1() {
 	const _ = complex(0i, 0)
 	const _ int = 1.0 + complex(1, 0i)
 
-	const _ int = complex /* ERROR int */ (1.1, 0)
-	const _ float32 = complex /* ERROR float32 */ (1, 2)
+	const _ int = complex /* ERROR "int" */ (1.1, 0)
+	const _ float32 = complex /* ERROR "float32" */ (1, 2)
 
 	// untyped values
 	var s uint
-	_ = complex(1 /* ERROR integer */ <<s, 0)
-	const _ = complex /* ERROR not constant */ (1 /* ERROR integer */ <<s, 0)
-	var _ int = complex /* ERROR cannot use .* in variable declaration */ (1 /* ERROR integer */ <<s, 0)
+	_ = complex(1 /* ERROR "integer" */ <<s, 0)
+	const _ = complex /* ERROR "not constant" */ (1 /* ERROR "integer" */ <<s, 0)
+	var _ int = complex /* ERROR "cannot use .* in variable declaration" */ (1 /* ERROR "integer" */ <<s, 0)
 
 	// floating-point argument types must be identical
 	type F32 float32
@@ -233,33 +233,33 @@ func complex1() {
 	var x32 F32
 	var x64 F64
 	c64 = complex(x32, x32)
-	_ = complex(x32 /* ERROR mismatched types */ , f32)
-	_ = complex(f32 /* ERROR mismatched types */ , x32)
+	_ = complex(x32 /* ERROR "mismatched types" */ , f32)
+	_ = complex(f32 /* ERROR "mismatched types" */ , x32)
 	c128 = complex(x64, x64)
 	_ = c128
-	_ = complex(x64 /* ERROR mismatched types */ , f64)
-	_ = complex(f64 /* ERROR mismatched types */ , x64)
+	_ = complex(x64 /* ERROR "mismatched types" */ , f64)
+	_ = complex(f64 /* ERROR "mismatched types" */ , x64)
 
 	var t []float32
-	_ = complex(t... /* ERROR invalid use of \.\.\. */ )
+	_ = complex(t... /* ERROR "invalid use of \.\.\." */ )
 }
 
 func complex2() {
 	f1 := func() (x float32) { return }
 	f2 := func() (x, y float32) { return }
 	f3 := func() (x, y, z float32) { return }
-	_ = complex(f0 /* ERROR used as value */ ())
-	_ = complex(f1()) // ERROR not enough arguments
+	_ = complex(f0 /* ERROR "used as value" */ ())
+	_ = complex(f1()) // ERROR "not enough arguments"
 	_ = complex(f2())
-	_ = complex(f3()) // ERROR too many arguments
+	_ = complex(f3()) // ERROR "too many arguments"
 }
 
 func copy1() {
-	copy() // ERROR not enough arguments
-	copy("foo") // ERROR not enough arguments
-	copy([ /* ERROR copy expects slice arguments */ ...]int{}, []int{})
-	copy([ /* ERROR copy expects slice arguments */ ]int{}, [...]int{})
-	copy([ /* ERROR different element types */ ]int8{}, "foo")
+	copy() // ERROR "not enough arguments"
+	copy("foo") // ERROR "not enough arguments"
+	copy([ /* ERROR "copy expects slice arguments" */ ...]int{}, []int{})
+	copy([ /* ERROR "copy expects slice arguments" */ ]int{}, [...]int{})
+	copy([ /* ERROR "different element types" */ ]int8{}, "foo")
 
 	// spec examples
 	var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
@@ -272,44 +272,44 @@ func copy1() {
 
 	var t [][]int
 	copy(t, t)
-	copy(t /* ERROR copy expects slice arguments */ , nil)
-	copy(nil /* ERROR copy expects slice arguments */ , t)
-	copy(nil /* ERROR copy expects slice arguments */ , nil)
-	copy(t... /* ERROR invalid use of \.\.\. */ )
+	copy(t /* ERROR "copy expects slice arguments" */ , nil)
+	copy(nil /* ERROR "copy expects slice arguments" */ , t)
+	copy(nil /* ERROR "copy expects slice arguments" */ , nil)
+	copy(t... /* ERROR "invalid use of \.\.\." */ )
 }
 
 func copy2() {
 	f1 := func() (a []int) { return }
 	f2 := func() (a, b []int) { return }
 	f3 := func() (a, b, c []int) { return }
-	copy(f0 /* ERROR used as value */ ())
-	copy(f1()) // ERROR not enough arguments
+	copy(f0 /* ERROR "used as value" */ ())
+	copy(f1()) // ERROR "not enough arguments"
 	copy(f2())
-	copy(f3()) // ERROR too many arguments
+	copy(f3()) // ERROR "too many arguments"
 }
 
 func delete1() {
 	var m map[string]int
 	var s string
-	delete() // ERROR not enough arguments
-	delete(1) // ERROR not enough arguments
-	delete(1, 2, 3) // ERROR too many arguments
-	delete(m, 0 /* ERROR cannot use */)
+	delete() // ERROR "not enough arguments"
+	delete(1) // ERROR "not enough arguments"
+	delete(1, 2, 3) // ERROR "too many arguments"
+	delete(m, 0 /* ERROR "cannot use" */)
 	delete(m, s)
-	_ = delete /* ERROR used as value */ (m, s)
+	_ = delete /* ERROR "used as value" */ (m, s)
 
 	var t []map[string]string
-	delete(t... /* ERROR invalid use of \.\.\. */ )
+	delete(t... /* ERROR "invalid use of \.\.\." */ )
 }
 
 func delete2() {
 	f1 := func() (m map[string]int) { return }
 	f2 := func() (m map[string]int, k string) { return }
 	f3 := func() (m map[string]int, k string, x float32) { return }
-	delete(f0 /* ERROR used as value */ ())
-	delete(f1()) // ERROR not enough arguments
+	delete(f0 /* ERROR "used as value" */ ())
+	delete(f1()) // ERROR "not enough arguments"
 	delete(f2())
-	delete(f3()) // ERROR too many arguments
+	delete(f3()) // ERROR "too many arguments"
 }
 
 func imag1() {
@@ -317,11 +317,11 @@ func imag1() {
 	var f64 float64
 	var c64 complex64
 	var c128 complex128
-	_ = imag() // ERROR not enough arguments
-	_ = imag(1, 2) // ERROR too many arguments
+	_ = imag() // ERROR "not enough arguments"
+	_ = imag(1, 2) // ERROR "too many arguments"
 	_ = imag(10)
 	_ = imag(2.7182818)
-	_ = imag("foo" /* ERROR expected complex */)
+	_ = imag("foo" /* ERROR "expected complex" */)
 	_ = imag('a')
 	const _5 = imag(1 + 2i)
 	assert(_5 == 2)
@@ -331,9 +331,9 @@ func imag1() {
 	assert(_6 == 0)
 	f32 = imag(c64)
 	f64 = imag(c128)
-	f32 = imag /* ERROR cannot use .* in assignment */ (c128)
-	f64 = imag /* ERROR cannot use .* in assignment */ (c64)
-	imag /* ERROR not used */ (c64)
+	f32 = imag /* ERROR "cannot use .* in assignment" */ (c128)
+	f64 = imag /* ERROR "cannot use .* in assignment" */ (c64)
+	imag /* ERROR "not used" */ (c64)
 	_, _ = f32, f64
 
 	// complex type may not be predeclared
@@ -345,7 +345,7 @@ func imag1() {
 	f64 = imag(x128)
 
 	var a []complex64
-	_ = imag(a... /* ERROR invalid use of \.\.\. */ )
+	_ = imag(a... /* ERROR "invalid use of \.\.\." */ )
 
 	// if argument is untyped, result is untyped
 	const _ byte = imag(1.2 + 3i)
@@ -353,15 +353,15 @@ func imag1() {
 
 	// lhs constant shift operands are typed as complex128
 	var s uint
-	_ = imag(1 /* ERROR must be integer */ << s)
+	_ = imag(1 /* ERROR "must be integer" */ << s)
 }
 
 func imag2() {
 	f1 := func() (x complex128) { return }
 	f2 := func() (x, y complex128) { return }
-	_ = imag(f0 /* ERROR used as value */ ())
+	_ = imag(f0 /* ERROR "used as value" */ ())
 	_ = imag(f1())
-	_ = imag(f2()) // ERROR too many arguments
+	_ = imag(f2()) // ERROR "too many arguments"
 }
 
 func len1() {
@@ -369,9 +369,9 @@ func len1() {
 	var a [10]bool
 	var p *[20]int
 	var m map[string]complex128
-	_ = len() // ERROR not enough arguments
-	_ = len(1, 2) // ERROR too many arguments
-	_ = len(42 /* ERROR invalid */)
+	_ = len() // ERROR "not enough arguments"
+	_ = len(1, 2) // ERROR "too many arguments"
+	_ = len(42 /* ERROR "invalid" */)
 	const _3 = len(c)
 	assert(_3 == 6)
 	const _4 = len(a)
@@ -379,15 +379,15 @@ func len1() {
 	const _5 = len(p)
 	assert(_5 == 20)
 	_ = len(m)
-	len /* ERROR not used */ (c)
+	len /* ERROR "not used" */ (c)
 
 	// esoteric case
 	var t string
 	var hash map[interface{}][]*[10]int
-	const n = len /* ERROR not constant */ (hash[recover()][len(t)])
+	const n = len /* ERROR "not constant" */ (hash[recover()][len(t)])
 	assert(n == 10) // ok because n has unknown value and no error is reported
 	var ch <-chan int
-	const nn = len /* ERROR not constant */ (hash[<-ch][len(t)])
+	const nn = len /* ERROR "not constant" */ (hash[<-ch][len(t)])
 
 	// issue 4744
 	type T struct{ a [10]int }
@@ -395,15 +395,15 @@ func len1() {
 
 	var s [][]byte
 	_ = len(s)
-	_ = len(s... /* ERROR invalid use of \.\.\. */ )
+	_ = len(s... /* ERROR "invalid use of \.\.\." */ )
 }
 
 func len2() {
 	f1 := func() (x []int) { return }
 	f2 := func() (x, y []int) { return }
-	_ = len(f0 /* ERROR used as value */ ())
+	_ = len(f0 /* ERROR "used as value" */ ())
 	_ = len(f1())
-	_ = len(f2()) // ERROR too many arguments
+	_ = len(f2()) // ERROR "too many arguments"
 }
 
 // test cases for issue 7387
@@ -413,8 +413,8 @@ func len3() {
 	const (
 		_ = len([4]int{})
 		_ = len([4]int{x})
-		_ = len /* ERROR not constant */ ([4]int{f()})
-		_ = len /* ERROR not constant */ ([4]int{len([]int{})})
+		_ = len /* ERROR "not constant" */ ([4]int{f()})
+		_ = len /* ERROR "not constant" */ ([4]int{len([]int{})})
 		_ = len([4]int{len([4]int{})})
 	)
 	var y float64
@@ -423,12 +423,12 @@ func len3() {
 		_ = len([4]float64{})
 		_ = len([4]float64{y})
 		_ = len([4]float64{real(2i)})
-		_ = len /* ERROR not constant */ ([4]float64{real(z)})
+		_ = len /* ERROR "not constant" */ ([4]float64{real(z)})
 	)
 	var ch chan [10]int
 	const (
-		_ = len /* ERROR not constant */ (<-ch)
-		_ = len /* ERROR not constant */ ([4]int{(<-ch)[0]})
+		_ = len /* ERROR "not constant" */ (<-ch)
+		_ = len /* ERROR "not constant" */ ([4]int{(<-ch)[0]})
 	)
 }
 
@@ -437,108 +437,108 @@ func make1() {
 	var m float32
 	var s uint
 
-	_ = make() // ERROR not enough arguments
-	_ = make(1 /* ERROR not a type */)
-	_ = make(int /* ERROR cannot make */)
+	_ = make() // ERROR "not enough arguments"
+	_ = make(1 /* ERROR "not a type" */)
+	_ = make(int /* ERROR "cannot make" */)
 
 	// slices
-	_ = make/* ERROR arguments */ ([]int)
-	_ = make/* ERROR arguments */ ([]int, 2, 3, 4)
-	_ = make([]int, int /* ERROR not an expression */)
-	_ = make([]int, 10, float32 /* ERROR not an expression */)
-	_ = make([]int, "foo" /* ERROR cannot convert */)
-	_ = make([]int, 10, 2.3 /* ERROR truncated */)
+	_ = make/* ERROR "arguments" */ ([]int)
+	_ = make/* ERROR "arguments" */ ([]int, 2, 3, 4)
+	_ = make([]int, int /* ERROR "not an expression" */)
+	_ = make([]int, 10, float32 /* ERROR "not an expression" */)
+	_ = make([]int, "foo" /* ERROR "cannot convert" */)
+	_ = make([]int, 10, 2.3 /* ERROR "truncated" */)
 	_ = make([]int, 5, 10.0)
 	_ = make([]int, 0i)
 	_ = make([]int, 1.0)
 	_ = make([]int, 1.0<<s)
-	_ = make([]int, 1.1 /* ERROR int */ <<s)
-	_ = make([]int, - /* ERROR must not be negative */ 1, 10)
-	_ = make([]int, 0, - /* ERROR must not be negative */ 1)
-	_ = make([]int, - /* ERROR must not be negative */ 1, - /* ERROR must not be negative */ 1)
-	_ = make([]int, 1 /* ERROR overflows */ <<100, 1 /* ERROR overflows */ <<100)
-	_ = make([]int, 10 /* ERROR length and capacity swapped */ , 9)
-	_ = make([]int, 1 /* ERROR overflows */ <<100, 12345)
-	_ = make([]int, m /* ERROR must be integer */ )
-        _ = &make /* ERROR cannot take address */ ([]int, 0)
+	_ = make([]int, 1.1 /* ERROR "int" */ <<s)
+	_ = make([]int, - /* ERROR "must not be negative" */ 1, 10)
+	_ = make([]int, 0, - /* ERROR "must not be negative" */ 1)
+	_ = make([]int, - /* ERROR "must not be negative" */ 1, - /* ERROR "must not be negative" */ 1)
+	_ = make([]int, 1 /* ERROR "overflows" */ <<100, 1 /* ERROR "overflows" */ <<100)
+	_ = make([]int, 10 /* ERROR "length and capacity swapped" */ , 9)
+	_ = make([]int, 1 /* ERROR "overflows" */ <<100, 12345)
+	_ = make([]int, m /* ERROR "must be integer" */ )
+        _ = &make /* ERROR "cannot take address" */ ([]int, 0)
 
 	// maps
-	_ = make /* ERROR arguments */ (map[int]string, 10, 20)
-	_ = make(map[int]float32, int /* ERROR not an expression */)
-	_ = make(map[int]float32, "foo" /* ERROR cannot convert */)
+	_ = make /* ERROR "arguments" */ (map[int]string, 10, 20)
+	_ = make(map[int]float32, int /* ERROR "not an expression" */)
+	_ = make(map[int]float32, "foo" /* ERROR "cannot convert" */)
 	_ = make(map[int]float32, 10)
 	_ = make(map[int]float32, n)
 	_ = make(map[int]float32, int64(n))
 	_ = make(map[string]bool, 10.0)
 	_ = make(map[string]bool, 10.0<<s)
-        _ = &make /* ERROR cannot take address */ (map[string]bool)
+        _ = &make /* ERROR "cannot take address" */ (map[string]bool)
 
 	// channels
-	_ = make /* ERROR arguments */ (chan int, 10, 20)
-	_ = make(chan int, int /* ERROR not an expression */)
-	_ = make(chan<- int, "foo" /* ERROR cannot convert */)
-	_ = make(chan int, - /* ERROR must not be negative */ 10)
+	_ = make /* ERROR "arguments" */ (chan int, 10, 20)
+	_ = make(chan int, int /* ERROR "not an expression" */)
+	_ = make(chan<- int, "foo" /* ERROR "cannot convert" */)
+	_ = make(chan int, - /* ERROR "must not be negative" */ 10)
 	_ = make(<-chan float64, 10)
 	_ = make(chan chan int, n)
 	_ = make(chan string, int64(n))
 	_ = make(chan bool, 10.0)
 	_ = make(chan bool, 10.0<<s)
-        _ = &make /* ERROR cannot take address */ (chan bool)
+        _ = &make /* ERROR "cannot take address" */ (chan bool)
 
-	make /* ERROR not used */ ([]int, 10)
+	make /* ERROR "not used" */ ([]int, 10)
 
 	var t []int
 	_ = make([]int, t[0], t[1])
-	_ = make([]int, t... /* ERROR invalid use of \.\.\. */ )
+	_ = make([]int, t... /* ERROR "invalid use of \.\.\." */ )
 }
 
 func make2() {
 	f1 := func() (x []int) { return }
-	_ = make(f0 /* ERROR not a type */ ())
-	_ = make(f1 /* ERROR not a type */ ())
+	_ = make(f0 /* ERROR "not a type" */ ())
+	_ = make(f1 /* ERROR "not a type" */ ())
 }
 
 func new1() {
-	_ = new() // ERROR not enough arguments
-	_ = new(1, 2) // ERROR too many arguments
-	_ = new("foo" /* ERROR not a type */)
+	_ = new() // ERROR "not enough arguments"
+	_ = new(1, 2) // ERROR "too many arguments"
+	_ = new("foo" /* ERROR "not a type" */)
 	p := new(float64)
 	_ = new(struct{ x, y int })
 	q := new(*float64)
 	_ = *p == **q
-	new /* ERROR not used */ (int)
-        _ = &new /* ERROR cannot take address */ (int)
+	new /* ERROR "not used" */ (int)
+        _ = &new /* ERROR "cannot take address" */ (int)
 
-	_ = new(int... /* ERROR invalid use of \.\.\. */ )
+	_ = new(int... /* ERROR "invalid use of \.\.\." */ )
 }
 
 func new2() {
 	f1 := func() (x []int) { return }
-	_ = new(f0 /* ERROR not a type */ ())
-	_ = new(f1 /* ERROR not a type */ ())
+	_ = new(f0 /* ERROR "not a type" */ ())
+	_ = new(f1 /* ERROR "not a type" */ ())
 }
 
 func panic1() {
-	panic() // ERROR not enough arguments
-	panic(1, 2) // ERROR too many arguments
+	panic() // ERROR "not enough arguments"
+	panic(1, 2) // ERROR "too many arguments"
 	panic(0)
 	panic("foo")
 	panic(false)
 	panic(1<<10)
-	panic(1 << /* ERROR constant shift overflow */ 1000)
-	_ = panic /* ERROR used as value */ (0)
+	panic(1 << /* ERROR "constant shift overflow" */ 1000)
+	_ = panic /* ERROR "used as value" */ (0)
 
 	var s []byte
 	panic(s)
-	panic(s... /* ERROR invalid use of \.\.\. */ )
+	panic(s... /* ERROR "invalid use of \.\.\." */ )
 }
 
 func panic2() {
 	f1 := func() (x int) { return }
 	f2 := func() (x, y int) { return }
-	panic(f0 /* ERROR used as value */ ())
+	panic(f0 /* ERROR "used as value" */ ())
 	panic(f1())
-	panic(f2()) // ERROR too many arguments
+	panic(f2()) // ERROR "too many arguments"
 }
 
 func print1() {
@@ -549,19 +549,19 @@ func print1() {
 	print(2.718281828)
 	print(false)
 	print(1<<10)
-	print(1 << /* ERROR constant shift overflow */ 1000)
-	println(nil /* ERROR untyped nil */ )
+	print(1 << /* ERROR "constant shift overflow" */ 1000)
+	println(nil /* ERROR "untyped nil" */ )
 
 	var s []int
-	print(s... /* ERROR invalid use of \.\.\. */ )
-	_ = print /* ERROR used as value */ ()
+	print(s... /* ERROR "invalid use of \.\.\." */ )
+	_ = print /* ERROR "used as value" */ ()
 }
 
 func print2() {
 	f1 := func() (x int) { return }
 	f2 := func() (x, y int) { return }
 	f3 := func() (x int, y float32, z string) { return }
-	print(f0 /* ERROR used as value */ ())
+	print(f0 /* ERROR "used as value" */ ())
 	print(f1())
 	print(f2())
 	print(f3())
@@ -575,19 +575,19 @@ func println1() {
 	println(2.718281828)
 	println(false)
 	println(1<<10)
-	println(1 << /* ERROR constant shift overflow */ 1000)
-	println(nil /* ERROR untyped nil */ )
+	println(1 << /* ERROR "constant shift overflow" */ 1000)
+	println(nil /* ERROR "untyped nil" */ )
 
 	var s []int
-	println(s... /* ERROR invalid use of \.\.\. */ )
-	_ = println /* ERROR used as value */ ()
+	println(s... /* ERROR "invalid use of \.\.\." */ )
+	_ = println /* ERROR "used as value" */ ()
 }
 
 func println2() {
 	f1 := func() (x int) { return }
 	f2 := func() (x, y int) { return }
 	f3 := func() (x int, y float32, z string) { return }
-	println(f0 /* ERROR used as value */ ())
+	println(f0 /* ERROR "used as value" */ ())
 	println(f1())
 	println(f2())
 	println(f3())
@@ -598,11 +598,11 @@ func real1() {
 	var f64 float64
 	var c64 complex64
 	var c128 complex128
-	_ = real() // ERROR not enough arguments
-	_ = real(1, 2) // ERROR too many arguments
+	_ = real() // ERROR "not enough arguments"
+	_ = real(1, 2) // ERROR "too many arguments"
 	_ = real(10)
 	_ = real(2.7182818)
-	_ = real("foo" /* ERROR expected complex */)
+	_ = real("foo" /* ERROR "expected complex" */)
 	const _5 = real(1 + 2i)
 	assert(_5 == 1)
 	f32 = _5
@@ -611,9 +611,9 @@ func real1() {
 	assert(_6 == 0)
 	f32 = real(c64)
 	f64 = real(c128)
-	f32 = real /* ERROR cannot use .* in assignment */ (c128)
-	f64 = real /* ERROR cannot use .* in assignment */ (c64)
-	real /* ERROR not used */ (c64)
+	f32 = real /* ERROR "cannot use .* in assignment" */ (c128)
+	f64 = real /* ERROR "cannot use .* in assignment" */ (c64)
+	real /* ERROR "not used" */ (c64)
 
 	// complex type may not be predeclared
 	type C64 complex64
@@ -625,7 +625,7 @@ func real1() {
 	_, _ = f32, f64
 
 	var a []complex64
-	_ = real(a... /* ERROR invalid use of \.\.\. */ )
+	_ = real(a... /* ERROR "invalid use of \.\.\." */ )
 
 	// if argument is untyped, result is untyped
 	const _ byte = real(1 + 2.3i)
@@ -633,32 +633,32 @@ func real1() {
 
 	// lhs constant shift operands are typed as complex128
 	var s uint
-	_ = real(1 /* ERROR must be integer */ << s)
+	_ = real(1 /* ERROR "must be integer" */ << s)
 }
 
 func real2() {
 	f1 := func() (x complex128) { return }
 	f2 := func() (x, y complex128) { return }
-	_ = real(f0 /* ERROR used as value */ ())
+	_ = real(f0 /* ERROR "used as value" */ ())
 	_ = real(f1())
-	_ = real(f2()) // ERROR too many arguments
+	_ = real(f2()) // ERROR "too many arguments"
 }
 
 func recover1() {
 	_ = recover()
-	_ = recover(10) // ERROR too many arguments
+	_ = recover(10) // ERROR "too many arguments"
 	recover()
 
 	var s []int
-	recover(s... /* ERROR invalid use of \.\.\. */ )
+	recover(s... /* ERROR "invalid use of \.\.\." */ )
 }
 
 func recover2() {
 	f1 := func() (x int) { return }
 	f2 := func() (x, y int) { return }
-	_ = recover(f0 /* ERROR used as value */ ())
-	_ = recover(f1()) // ERROR too many arguments
-	_ = recover(f2()) // ERROR too many arguments
+	_ = recover(f0 /* ERROR "used as value" */ ())
+	_ = recover(f1()) // ERROR "too many arguments"
+	_ = recover(f2()) // ERROR "too many arguments"
 }
 
 // assuming types.DefaultPtrSize == 8
@@ -700,15 +700,15 @@ func (S2) m() {}
 
 func Alignof1() {
 	var x int
-	_ = unsafe.Alignof() // ERROR not enough arguments
-	_ = unsafe.Alignof(1, 2) // ERROR too many arguments
-	_ = unsafe.Alignof(int /* ERROR not an expression */)
+	_ = unsafe.Alignof() // ERROR "not enough arguments"
+	_ = unsafe.Alignof(1, 2) // ERROR "too many arguments"
+	_ = unsafe.Alignof(int /* ERROR "not an expression" */)
 	_ = unsafe.Alignof(42)
 	_ = unsafe.Alignof(new(struct{}))
 	_ = unsafe.Alignof(1<<10)
-	_ = unsafe.Alignof(1 << /* ERROR constant shift overflow */ 1000)
-	_ = unsafe.Alignof(nil /* ERROR untyped nil */ )
-	unsafe /* ERROR not used */ .Alignof(x)
+	_ = unsafe.Alignof(1 << /* ERROR "constant shift overflow" */ 1000)
+	_ = unsafe.Alignof(nil /* ERROR "untyped nil" */ )
+	unsafe /* ERROR "not used" */ .Alignof(x)
 
 	var y S0
 	assert(unsafe.Alignof(y.a) == 1)
@@ -719,28 +719,28 @@ func Alignof1() {
 
 	var s []byte
 	_ = unsafe.Alignof(s)
-	_ = unsafe.Alignof(s... /* ERROR invalid use of \.\.\. */ )
+	_ = unsafe.Alignof(s... /* ERROR "invalid use of \.\.\." */ )
 }
 
 func Alignof2() {
 	f1 := func() (x int32) { return }
 	f2 := func() (x, y int32) { return }
-	_ = unsafe.Alignof(f0 /* ERROR used as value */ ())
+	_ = unsafe.Alignof(f0 /* ERROR "used as value" */ ())
 	assert(unsafe.Alignof(f1()) == 4)
-	_ = unsafe.Alignof(f2()) // ERROR too many arguments
+	_ = unsafe.Alignof(f2()) // ERROR "too many arguments"
 }
 
 func Offsetof1() {
 	var x struct{ f int }
-	_ = unsafe.Offsetof() // ERROR not enough arguments
-	_ = unsafe.Offsetof(1, 2) // ERROR too many arguments
-	_ = unsafe.Offsetof(int /* ERROR not a selector expression */ )
-	_ = unsafe.Offsetof(x /* ERROR not a selector expression */ )
-	_ = unsafe.Offsetof(nil /* ERROR not a selector expression */ )
+	_ = unsafe.Offsetof() // ERROR "not enough arguments"
+	_ = unsafe.Offsetof(1, 2) // ERROR "too many arguments"
+	_ = unsafe.Offsetof(int /* ERROR "not a selector expression" */ )
+	_ = unsafe.Offsetof(x /* ERROR "not a selector expression" */ )
+	_ = unsafe.Offsetof(nil /* ERROR "not a selector expression" */ )
 	_ = unsafe.Offsetof(x.f)
 	_ = unsafe.Offsetof((x.f))
 	_ = unsafe.Offsetof((((((((x))).f)))))
-	unsafe /* ERROR not used */ .Offsetof(x.f)
+	unsafe /* ERROR "not used" */ .Offsetof(x.f)
 
 	var y0 S0
 	assert(unsafe.Offsetof(y0.a) == 0)
@@ -771,32 +771,32 @@ func Offsetof1() {
 
 	var y2 S2
 	assert(unsafe.Offsetof(y2.S1) == 0)
-	_ = unsafe.Offsetof(y2 /* ERROR embedded via a pointer */ .x)
-	_ = unsafe.Offsetof(y2 /* ERROR method value */ .m)
+	_ = unsafe.Offsetof(y2 /* ERROR "embedded via a pointer" */ .x)
+	_ = unsafe.Offsetof(y2 /* ERROR "method value" */ .m)
 
 	var s []byte
-	_ = unsafe.Offsetof(s... /* ERROR invalid use of \.\.\. */ )
+	_ = unsafe.Offsetof(s... /* ERROR "invalid use of \.\.\." */ )
 }
 
 func Offsetof2() {
 	f1 := func() (x int32) { return }
 	f2 := func() (x, y int32) { return }
-	_ = unsafe.Offsetof(f0 /* ERROR not a selector expression */ ())
-	_ = unsafe.Offsetof(f1 /* ERROR not a selector expression */ ())
-	_ = unsafe.Offsetof(f2 /* ERROR not a selector expression */ ())
+	_ = unsafe.Offsetof(f0 /* ERROR "not a selector expression" */ ())
+	_ = unsafe.Offsetof(f1 /* ERROR "not a selector expression" */ ())
+	_ = unsafe.Offsetof(f2 /* ERROR "not a selector expression" */ ())
 }
 
 func Sizeof1() {
 	var x int
-	_ = unsafe.Sizeof() // ERROR not enough arguments
-	_ = unsafe.Sizeof(1, 2) // ERROR too many arguments
-	_ = unsafe.Sizeof(int /* ERROR not an expression */)
+	_ = unsafe.Sizeof() // ERROR "not enough arguments"
+	_ = unsafe.Sizeof(1, 2) // ERROR "too many arguments"
+	_ = unsafe.Sizeof(int /* ERROR "not an expression" */)
 	_ = unsafe.Sizeof(42)
 	_ = unsafe.Sizeof(new(complex128))
 	_ = unsafe.Sizeof(1<<10)
-	_ = unsafe.Sizeof(1 << /* ERROR constant shift overflow */ 1000)
-	_ = unsafe.Sizeof(nil /* ERROR untyped nil */ )
-	unsafe /* ERROR not used */ .Sizeof(x)
+	_ = unsafe.Sizeof(1 << /* ERROR "constant shift overflow" */ 1000)
+	_ = unsafe.Sizeof(nil /* ERROR "untyped nil" */ )
+	unsafe /* ERROR "not used" */ .Sizeof(x)
 
 	// basic types have size guarantees
 	assert(unsafe.Sizeof(byte(0)) == 1)
@@ -849,28 +849,28 @@ func Sizeof1() {
 
 	var s []byte
 	_ = unsafe.Sizeof(s)
-	_ = unsafe.Sizeof(s... /* ERROR invalid use of \.\.\. */ )
+	_ = unsafe.Sizeof(s... /* ERROR "invalid use of \.\.\." */ )
 }
 
 func Sizeof2() {
 	f1 := func() (x int64) { return }
 	f2 := func() (x, y int64) { return }
-	_ = unsafe.Sizeof(f0 /* ERROR used as value */ ())
+	_ = unsafe.Sizeof(f0 /* ERROR "used as value" */ ())
 	assert(unsafe.Sizeof(f1()) == 8)
-	_ = unsafe.Sizeof(f2()) // ERROR too many arguments
+	_ = unsafe.Sizeof(f2()) // ERROR "too many arguments"
 }
 
 func Slice1() {
 	var x int
-	unsafe.Slice()        // ERROR not enough arguments
-	unsafe.Slice(1, 2, 3) // ERROR too many arguments
-	unsafe.Slice(1 /* ERROR is not a pointer */ , 2)
-	unsafe.Slice(nil /* ERROR nil is not a pointer */ , 0)
-	unsafe.Slice(&x, "foo" /* ERROR cannot convert .* to type int */ )
-	unsafe.Slice(&x, 1.2 /* ERROR truncated to int */ )
-	unsafe.Slice(&x, - /* ERROR must not be negative */ 1)
-	unsafe /* ERROR not used */ .Slice(&x, 0)
-	var _ []byte = unsafe /* ERROR value of type \[\]int */ .Slice(&x, 0)
+	unsafe.Slice()        // ERROR "not enough arguments"
+	unsafe.Slice(1, 2, 3) // ERROR "too many arguments"
+	unsafe.Slice(1 /* ERROR "is not a pointer" */ , 2)
+	unsafe.Slice(nil /* ERROR "nil is not a pointer" */ , 0)
+	unsafe.Slice(&x, "foo" /* ERROR "cannot convert .* to type int" */ )
+	unsafe.Slice(&x, 1.2 /* ERROR "truncated to int" */ )
+	unsafe.Slice(&x, - /* ERROR "must not be negative" */ 1)
+	unsafe /* ERROR "not used" */ .Slice(&x, 0)
+	var _ []byte = unsafe /* ERROR "value of type \[\]int" */ .Slice(&x, 0)
 
 	var _ []int = unsafe.Slice(&x, 0)
 	_ = unsafe.Slice(&x, 1.0)
@@ -879,8 +879,8 @@ func Slice1() {
 
 func SliceData1() {
 	var s []int
-	unsafe.SliceData(0 /* ERROR not a slice */)
-	unsafe /* ERROR not used */ .SliceData(s)
+	unsafe.SliceData(0 /* ERROR "not a slice" */)
+	unsafe /* ERROR "not used" */ .SliceData(s)
 
 	type S []int
 	_ = unsafe.SliceData(s)
@@ -889,14 +889,14 @@ func SliceData1() {
 
 func String1() {
 	var b byte
-	unsafe.String()        // ERROR not enough arguments
-	unsafe.String(1, 2, 3) // ERROR too many arguments
-	unsafe.String(1 /* ERROR cannot use 1 */ , 2)
-	unsafe.String(&b, "foo" /* ERROR cannot convert .* to type int */ )
-	unsafe.String(&b, 1.2 /* ERROR truncated to int */ )
-	unsafe.String(&b, - /* ERROR must not be negative */ 1)
-	unsafe /* ERROR not used */ .String(&b, 0)
-	var _ []byte = unsafe /* ERROR value of type string */ .String(&b, 0)
+	unsafe.String()        // ERROR "not enough arguments"
+	unsafe.String(1, 2, 3) // ERROR "too many arguments"
+	unsafe.String(1 /* ERROR "cannot use 1" */ , 2)
+	unsafe.String(&b, "foo" /* ERROR "cannot convert .* to type int" */ )
+	unsafe.String(&b, 1.2 /* ERROR "truncated to int" */ )
+	unsafe.String(&b, - /* ERROR "must not be negative" */ 1)
+	unsafe /* ERROR "not used" */ .String(&b, 0)
+	var _ []byte = unsafe /* ERROR "value of type string" */ .String(&b, 0)
 
 	var _ string = unsafe.String(&b, 0)
 	_ = unsafe.String(&b, 1.0)
@@ -906,9 +906,9 @@ func String1() {
 func StringData1() {
 	var s string
 	type S string
-	unsafe.StringData(0 /* ERROR cannot use 0 */)
-	unsafe.StringData(S /* ERROR cannot use S */ ("foo"))
-	unsafe /* ERROR not used */ .StringData(s)
+	unsafe.StringData(0 /* ERROR "cannot use 0" */)
+	unsafe.StringData(S /* ERROR "cannot use S" */ ("foo"))
+	unsafe /* ERROR "not used" */ .StringData(s)
 
 	_ = unsafe.StringData(s)
 	_ = unsafe.StringData("foo")
@@ -917,35 +917,35 @@ func StringData1() {
 // self-testing only
 func assert1() {
 	var x int
-	assert() /* ERROR not enough arguments */
-	assert(1, 2) /* ERROR too many arguments */
-	assert("foo" /* ERROR boolean constant */ )
-	assert(x /* ERROR boolean constant */)
+	assert() /* ERROR "not enough arguments" */
+	assert(1, 2) /* ERROR "too many arguments" */
+	assert("foo" /* ERROR "boolean constant" */ )
+	assert(x /* ERROR "boolean constant" */)
 	assert(true)
-	assert /* ERROR failed */ (false)
+	assert /* ERROR "failed" */ (false)
 	_ = assert(true)
 
 	var s []byte
-	assert(s... /* ERROR invalid use of \.\.\. */ )
+	assert(s... /* ERROR "invalid use of \.\.\." */ )
 }
 
 func assert2() {
 	f1 := func() (x bool) { return }
 	f2 := func() (x bool) { return }
-	assert(f0 /* ERROR used as value */ ())
-	assert(f1 /* ERROR boolean constant */ ())
-	assert(f2 /* ERROR boolean constant */ ())
+	assert(f0 /* ERROR "used as value" */ ())
+	assert(f1 /* ERROR "boolean constant" */ ())
+	assert(f2 /* ERROR "boolean constant" */ ())
 }
 
 // self-testing only
 func trace1() {
 	// Uncomment the code below to test trace - will produce console output
-	// _ = trace /* ERROR no value */ ()
+	// _ = trace /* ERROR "no value" */ ()
 	// _ = trace(1)
 	// _ = trace(true, 1.2, '\'', "foo", 42i, "foo" <= "bar")
 
 	var s []byte
-	trace(s... /* ERROR invalid use of \.\.\. */ )
+	trace(s... /* ERROR "invalid use of \.\.\." */ )
 }
 
 func trace2() {
diff --git a/src/internal/types/testdata/check/builtins1.go b/src/internal/types/testdata/check/builtins1.go
index 3348861582..cd622b678b 100644
--- a/src/internal/types/testdata/check/builtins1.go
+++ b/src/internal/types/testdata/check/builtins1.go
@@ -11,7 +11,7 @@ import "unsafe"
 // clear
 
 func _[T any](x T) {
-	clear(x /* ERROR cannot clear x */)
+	clear(x /* ERROR "cannot clear x" */)
 }
 
 func _[T ~map[int]string | ~[]byte | ~*[10]int](x T) {
@@ -19,7 +19,7 @@ func _[T ~map[int]string | ~[]byte | ~*[10]int](x T) {
 }
 
 func _[T ~map[int]string | ~[]byte | ~*[10]int | string](x T) {
-	clear(x /* ERROR cannot clear x */)
+	clear(x /* ERROR "cannot clear x" */)
 }
 
 // close
@@ -32,11 +32,11 @@ type C4 interface{ chan int | chan<- int }
 type C5[T any] interface{ ~chan T | chan<- T }
 
 func _[T any](ch T) {
-	close(ch /* ERROR cannot close non-channel */)
+	close(ch /* ERROR "cannot close non-channel" */)
 }
 
 func _[T C0](ch T) {
-	close(ch /* ERROR cannot close non-channel */)
+	close(ch /* ERROR "cannot close non-channel" */)
 }
 
 func _[T C1](ch T) {
@@ -44,7 +44,7 @@ func _[T C1](ch T) {
 }
 
 func _[T C2](ch T) {
-	close(ch /* ERROR cannot close receive-only channel */)
+	close(ch /* ERROR "cannot close receive-only channel" */)
 }
 
 func _[T C3](ch T) {
@@ -62,13 +62,13 @@ func _[T C5[X], X any](ch T) {
 // copy
 
 func _[T any](x, y T) {
-	copy(x /* ERROR copy expects slice arguments */ , y)
+	copy(x /* ERROR "copy expects slice arguments" */ , y)
 }
 
 func _[T ~[]byte](x, y T) {
 	copy(x, y)
 	copy(x, "foo")
-	copy("foo" /* ERROR expects slice arguments */ , y)
+	copy("foo" /* ERROR "expects slice arguments" */ , y)
 
 	var x2 []byte
 	copy(x2, y) // element types are identical
@@ -76,22 +76,22 @@ func _[T ~[]byte](x, y T) {
 
 	type myByte byte
 	var x3 []myByte
-	copy(x3 /* ERROR different element types */ , y)
-	copy(y /* ERROR different element types */ , x3)
+	copy(x3 /* ERROR "different element types" */ , y)
+	copy(y /* ERROR "different element types" */ , x3)
 }
 
 func _[T ~[]E, E any](x T, y []E) {
 	copy(x, y)
-	copy(x /* ERROR different element types */ , "foo")
+	copy(x /* ERROR "different element types" */ , "foo")
 }
 
 func _[T ~string](x []byte, y T) {
 	copy(x, y)
-	copy(y /* ERROR expects slice arguments */ , x)
+	copy(y /* ERROR "expects slice arguments" */ , x)
 }
 
 func _[T ~[]byte|~string](x T, y []byte) {
-	copy(x /* ERROR expects slice arguments */ , y)
+	copy(x /* ERROR "expects slice arguments" */ , y)
 	copy(y, x)
 }
 
@@ -111,11 +111,11 @@ type M3 interface{ map[string]int | map[rune]int }
 type M4[K comparable, V any] interface{ map[K]V | map[rune]V }
 
 func _[T any](m T) {
-	delete(m /* ERROR not a map */, "foo")
+	delete(m /* ERROR "not a map" */, "foo")
 }
 
 func _[T M0](m T) {
-	delete(m /* ERROR not a map */, "foo")
+	delete(m /* ERROR "not a map" */, "foo")
 }
 
 func _[T M1](m T) {
@@ -124,11 +124,11 @@ func _[T M1](m T) {
 
 func _[T M2](m T) {
 	delete(m, "foo")
-	delete(m, 0 /* ERROR cannot use .* as string */)
+	delete(m, 0 /* ERROR "cannot use .* as string" */)
 }
 
 func _[T M3](m T) {
-	delete(m /* ERROR must have identical key types */, "foo")
+	delete(m /* ERROR "must have identical key types" */, "foo")
 }
 
 func _[T M4[rune, V], V any](m T) {
@@ -136,7 +136,7 @@ func _[T M4[rune, V], V any](m T) {
 }
 
 func _[T M4[K, V], K comparable, V any](m T) {
-	delete(m /* ERROR must have identical key types */, "foo")
+	delete(m /* ERROR "must have identical key types" */, "foo")
 }
 
 // make
@@ -158,27 +158,27 @@ func _[
 	_ = make([]int, 10)
 	_ = make(S0, 10)
 	_ = make(S1, 10)
-	_ = make() /* ERROR not enough arguments */
-	_ = make /* ERROR expects 2 or 3 arguments */ (S1)
+	_ = make() /* ERROR "not enough arguments" */
+	_ = make /* ERROR "expects 2 or 3 arguments" */ (S1)
 	_ = make(S1, 10, 20)
-	_ = make /* ERROR expects 2 or 3 arguments */ (S1, 10, 20, 30)
-	_ = make(S2 /* ERROR cannot make S2: no core type */ , 10)
+	_ = make /* ERROR "expects 2 or 3 arguments" */ (S1, 10, 20, 30)
+	_ = make(S2 /* ERROR "cannot make S2: no core type" */ , 10)
 
 	type M0 map[string]int
 	_ = make(map[string]int)
 	_ = make(M0)
 	_ = make(M1)
 	_ = make(M1, 10)
-	_ = make/* ERROR expects 1 or 2 arguments */(M1, 10, 20)
-	_ = make(M2 /* ERROR cannot make M2: no core type */ )
+	_ = make/* ERROR "expects 1 or 2 arguments" */(M1, 10, 20)
+	_ = make(M2 /* ERROR "cannot make M2: no core type" */ )
 
 	type C0 chan int
 	_ = make(chan int)
 	_ = make(C0)
 	_ = make(C1)
 	_ = make(C1, 10)
-	_ = make/* ERROR expects 1 or 2 arguments */(C1, 10, 20)
-	_ = make(C2 /* ERROR cannot make C2: no core type */ )
+	_ = make/* ERROR "expects 1 or 2 arguments" */(C1, 10, 20)
+	_ = make(C2 /* ERROR "cannot make C2: no core type" */ )
 	_ = make(C3)
 }
 
@@ -200,8 +200,8 @@ func _[T comparable]() {
 
 	const bb = unsafe.Alignof(b)
 	assert(bb == 8)
-	const _ = unsafe /* ERROR not constant */ .Alignof(a)
-	const _ = unsafe /* ERROR not constant */ .Alignof(s)
+	const _ = unsafe /* ERROR "not constant" */ .Alignof(a)
+	const _ = unsafe /* ERROR "not constant" */ .Alignof(s)
 	const pp = unsafe.Alignof(p)
 	assert(pp == 8)
 	const ll = unsafe.Alignof(l)
@@ -214,7 +214,7 @@ func _[T comparable]() {
 	assert(cc == 8)
 	const mm = unsafe.Alignof(m)
 	assert(mm == 8)
-	const _ = unsafe /* ERROR not constant */ .Alignof(t)
+	const _ = unsafe /* ERROR "not constant" */ .Alignof(t)
 }
 
 // unsafe.Offsetof
@@ -235,8 +235,8 @@ func _[T comparable]() {
 
 	const bb = unsafe.Offsetof(b.f)
 	assert(bb == 8)
-	const _ = unsafe /* ERROR not constant */ .Alignof(a)
-	const _ = unsafe /* ERROR not constant */ .Alignof(s)
+	const _ = unsafe /* ERROR "not constant" */ .Alignof(a)
+	const _ = unsafe /* ERROR "not constant" */ .Alignof(s)
 	const pp = unsafe.Offsetof(p.f)
 	assert(pp == 8)
 	const ll = unsafe.Offsetof(l.f)
@@ -249,7 +249,7 @@ func _[T comparable]() {
 	assert(cc == 8)
 	const mm = unsafe.Offsetof(m.f)
 	assert(mm == 8)
-	const _ = unsafe /* ERROR not constant */ .Alignof(t)
+	const _ = unsafe /* ERROR "not constant" */ .Alignof(t)
 }
 
 // unsafe.Sizeof
@@ -270,8 +270,8 @@ func _[T comparable]() {
 
 	const bb = unsafe.Sizeof(b)
 	assert(bb == 8)
-	const _ = unsafe /* ERROR not constant */ .Alignof(a)
-	const _ = unsafe /* ERROR not constant */ .Alignof(s)
+	const _ = unsafe /* ERROR "not constant" */ .Alignof(a)
+	const _ = unsafe /* ERROR "not constant" */ .Alignof(s)
 	const pp = unsafe.Sizeof(p)
 	assert(pp == 8)
 	const ll = unsafe.Sizeof(l)
@@ -284,5 +284,5 @@ func _[T comparable]() {
 	assert(cc == 8)
 	const mm = unsafe.Sizeof(m)
 	assert(mm == 8)
-	const _ = unsafe /* ERROR not constant */ .Alignof(t)
+	const _ = unsafe /* ERROR "not constant" */ .Alignof(t)
 }
diff --git a/src/internal/types/testdata/check/const0.go b/src/internal/types/testdata/check/const0.go
index 402e6cf5a9..49c62d6c81 100644
--- a/src/internal/types/testdata/check/const0.go
+++ b/src/internal/types/testdata/check/const0.go
@@ -13,10 +13,10 @@ var x = 0
 const c0 = x /* ERROR "not constant" */
 
 // typed constants must have constant types
-const _ interface /* ERROR invalid constant type */ {} = 0
+const _ interface /* ERROR "invalid constant type" */ {} = 0
 
 func _ () {
-	const _ interface /* ERROR invalid constant type */ {} = 0
+	const _ interface /* ERROR "invalid constant type" */ {} = 0
 	for i := 0; i < 10; i++ {} // don't crash with non-nil iota here
 }
 
@@ -372,11 +372,11 @@ func _() {
 const prec = 512 // internal maximum precision for integers
 const maxInt = (1<<(prec/2) - 1) * (1<<(prec/2) + 1) // == 1<<prec - 1
 
-const _ = maxInt + /* ERROR constant addition overflow */ 1
-const _ = -maxInt - /* ERROR constant subtraction overflow */ 1
-const _ = maxInt ^ /* ERROR constant bitwise XOR overflow */ -1
-const _ = maxInt * /* ERROR constant multiplication overflow */ 2
-const _ = maxInt << /* ERROR constant shift overflow */ 2
-const _ = 1 << /* ERROR constant shift overflow */ prec
+const _ = maxInt + /* ERROR "constant addition overflow" */ 1
+const _ = -maxInt - /* ERROR "constant subtraction overflow" */ 1
+const _ = maxInt ^ /* ERROR "constant bitwise XOR overflow" */ -1
+const _ = maxInt * /* ERROR "constant multiplication overflow" */ 2
+const _ = maxInt << /* ERROR "constant shift overflow" */ 2
+const _ = 1 << /* ERROR "constant shift overflow" */ prec
 
-const _ = ^ /* ERROR constant bitwise complement overflow */ maxInt
+const _ = ^ /* ERROR "constant bitwise complement overflow" */ maxInt
diff --git a/src/internal/types/testdata/check/constdecl.go b/src/internal/types/testdata/check/constdecl.go
index faa9b9d5cb..e7b871bfdf 100644
--- a/src/internal/types/testdata/check/constdecl.go
+++ b/src/internal/types/testdata/check/constdecl.go
@@ -93,7 +93,7 @@ func _() {
 }
 
 // Test case for constants depending on function literals (see also #22992).
-const A /* ERROR initialization cycle */ = unsafe.Sizeof(func() { _ = A })
+const A /* ERROR "initialization cycle" */ = unsafe.Sizeof(func() { _ = A })
 
 func _() {
 	// The function literal below must not see a.
@@ -111,13 +111,13 @@ func _() {
 const (
 	_ byte = 255 + iota
 	/* some gap */
-	_ // ERROR overflows
+	_ // ERROR "overflows"
 	/* some gap */
-	/* some gap */ _ /* ERROR overflows */; _ /* ERROR overflows */
+	/* some gap */ _ /* ERROR "overflows" */; _ /* ERROR "overflows" */
 	/* some gap */
 	_ = 255 + iota
-	_ = byte /* ERROR overflows */ (255) + iota
-	_ /* ERROR overflows */
+	_ = byte /* ERROR "overflows" */ (255) + iota
+	_ /* ERROR "overflows" */
 )
 
 // Test cases from issue.
@@ -125,14 +125,14 @@ const (
 	ok = byte(iota + 253)
 	bad
 	barn
-	bard // ERROR cannot convert
+	bard // ERROR "cannot convert"
 )
 
 const (
 	c = len([1 - iota]int{})
 	d
-	e // ERROR invalid array length
-	f // ERROR invalid array length
+	e // ERROR "invalid array length"
+	f // ERROR "invalid array length"
 )
 
 // Test that identifiers in implicit (omitted) RHS
diff --git a/src/internal/types/testdata/check/cycles0.go b/src/internal/types/testdata/check/cycles0.go
index 7c00c7d625..8ad7877f94 100644
--- a/src/internal/types/testdata/check/cycles0.go
+++ b/src/internal/types/testdata/check/cycles0.go
@@ -8,10 +8,10 @@ import "unsafe"
 
 type (
 	T0 int
-	T1 /* ERROR invalid recursive type: T1 refers to itself */ T1
+	T1 /* ERROR "invalid recursive type: T1 refers to itself" */ T1
 	T2 *T2
 
-	T3 /* ERROR invalid recursive type */ T4
+	T3 /* ERROR "invalid recursive type" */ T4
 	T4 T5
 	T5 T3
 
@@ -20,10 +20,10 @@ type (
 	T8 T6
 
 	// arrays
-	A0 /* ERROR invalid recursive type */ [10]A0
+	A0 /* ERROR "invalid recursive type" */ [10]A0
 	A1 [10]*A1
 
-	A2 /* ERROR invalid recursive type */ [10]A3
+	A2 /* ERROR "invalid recursive type" */ [10]A3
 	A3 [10]A4
 	A4 A2
 
@@ -34,18 +34,18 @@ type (
 	L0 []L0
 
 	// structs
-	S0 /* ERROR invalid recursive type: S0 refers to itself */ struct{ _ S0 }
-	S1 /* ERROR invalid recursive type: S1 refers to itself */ struct{ S1 }
+	S0 /* ERROR "invalid recursive type: S0 refers to itself" */ struct{ _ S0 }
+	S1 /* ERROR "invalid recursive type: S1 refers to itself" */ struct{ S1 }
 	S2 struct{ _ *S2 }
 	S3 struct{ *S3 }
 
-	S4 /* ERROR invalid recursive type */ struct{ S5 }
+	S4 /* ERROR "invalid recursive type" */ struct{ S5 }
 	S5 struct{ S6 }
 	S6 S4
 
 	// pointers
 	P0 *P0
-	PP *struct{ PP.f /* ERROR PP.f is not a type */ }
+	PP *struct{ PP.f /* ERROR "PP.f is not a type" */ }
 
 	// functions
 	F0 func(F0)
@@ -53,9 +53,9 @@ type (
 	F2 func(F2) F2
 
 	// interfaces
-	I0 /* ERROR invalid recursive type: I0 refers to itself */ interface{ I0 }
+	I0 /* ERROR "invalid recursive type: I0 refers to itself" */ interface{ I0 }
 
-	I1 /* ERROR invalid recursive type */ interface{ I2 }
+	I1 /* ERROR "invalid recursive type" */ interface{ I2 }
 	I2 interface{ I3 }
 	I3 interface{ I1 }
 
@@ -66,7 +66,7 @@ type (
 	I6 interface{ I5 }
 
 	// maps
-	M0 map[M0 /* ERROR invalid map key */ ]M0
+	M0 map[M0 /* ERROR "invalid map key" */ ]M0
 
 	// channels
 	C0 chan C0
@@ -74,7 +74,7 @@ type (
 
 // test case for issue #34771
 type (
-	AA /* ERROR invalid recursive type */ B
+	AA /* ERROR "invalid recursive type" */ B
 	B C
 	C [10]D
 	D E
@@ -83,23 +83,23 @@ type (
 
 func _() {
 	type (
-		t1 /* ERROR invalid recursive type: t1 refers to itself */ t1
+		t1 /* ERROR "invalid recursive type: t1 refers to itself" */ t1
 		t2 *t2
 
-		t3 t4 /* ERROR undefined */
-		t4 t5 /* ERROR undefined */
+		t3 t4 /* ERROR "undefined" */
+		t4 t5 /* ERROR "undefined" */
 		t5 t3
 
 		// arrays
-		a0 /* ERROR invalid recursive type: a0 refers to itself */ [10]a0
+		a0 /* ERROR "invalid recursive type: a0 refers to itself" */ [10]a0
 		a1 [10]*a1
 
 		// slices
 		l0 []l0
 
 		// structs
-		s0 /* ERROR invalid recursive type: s0 refers to itself */ struct{ _ s0 }
-		s1 /* ERROR invalid recursive type: s1 refers to itself */ struct{ s1 }
+		s0 /* ERROR "invalid recursive type: s0 refers to itself" */ struct{ _ s0 }
+		s1 /* ERROR "invalid recursive type: s1 refers to itself" */ struct{ s1 }
 		s2 struct{ _ *s2 }
 		s3 struct{ *s3 }
 
@@ -112,10 +112,10 @@ func _() {
 		f2 func(f2) f2
 
 		// interfaces
-		i0 /* ERROR invalid recursive type: i0 refers to itself */ interface{ i0 }
+		i0 /* ERROR "invalid recursive type: i0 refers to itself" */ interface{ i0 }
 
 		// maps
-		m0 map[m0 /* ERROR invalid map key */ ]m0
+		m0 map[m0 /* ERROR "invalid map key" */ ]m0
 
 		// channels
 		c0 chan c0
@@ -124,10 +124,10 @@ func _() {
 
 // test cases for issue 6667
 
-type A [10]map[A /* ERROR invalid map key */ ]bool
+type A [10]map[A /* ERROR "invalid map key" */ ]bool
 
 type S struct {
-	m map[S /* ERROR invalid map key */ ]bool
+	m map[S /* ERROR "invalid map key" */ ]bool
 }
 
 // test cases for issue 7236
@@ -135,32 +135,32 @@ type S struct {
 
 type (
 	P1 *T9
-	T9 /* ERROR invalid recursive type: T9 refers to itself */ T9
+	T9 /* ERROR "invalid recursive type: T9 refers to itself" */ T9
 
-	T10 /* ERROR invalid recursive type: T10 refers to itself */ T10
+	T10 /* ERROR "invalid recursive type: T10 refers to itself" */ T10
 	P2 *T10
 )
 
 func (T11) m() {}
 
-type T11 /* ERROR invalid recursive type: T11 refers to itself */ struct{ T11 }
+type T11 /* ERROR "invalid recursive type: T11 refers to itself" */ struct{ T11 }
 
-type T12 /* ERROR invalid recursive type: T12 refers to itself */ struct{ T12 }
+type T12 /* ERROR "invalid recursive type: T12 refers to itself" */ struct{ T12 }
 
 func (*T12) m() {}
 
 type (
 	P3 *T13
-	T13 /* ERROR invalid recursive type */ T13
+	T13 /* ERROR "invalid recursive type" */ T13
 )
 
 // test cases for issue 18643
 // (type cycle detection when non-type expressions are involved)
 type (
-	T14 [len(T14 /* ERROR invalid recursive type */ {})]int
-	T15 [][len(T15 /* ERROR invalid recursive type */ {})]int
-	T16 map[[len(T16 /* ERROR invalid recursive type */ {1:2})]int]int
-	T17 map[int][len(T17 /* ERROR invalid recursive type */ {1:2})]int
+	T14 [len(T14 /* ERROR "invalid recursive type" */ {})]int
+	T15 [][len(T15 /* ERROR "invalid recursive type" */ {})]int
+	T16 map[[len(T16 /* ERROR "invalid recursive type" */ {1:2})]int]int
+	T17 map[int][len(T17 /* ERROR "invalid recursive type" */ {1:2})]int
 )
 
 // Test case for types depending on function literals (see also #22992).
@@ -169,7 +169,7 @@ type T22 = chan [unsafe.Sizeof(func(ch T20){ _ = <-ch })]byte
 
 func _() {
 	type T0 func(T0)
-	type T1 /* ERROR invalid recursive type */ = func(T1)
+	type T1 /* ERROR "invalid recursive type" */ = func(T1)
 	type T2 chan [unsafe.Sizeof(func(ch T2){ _ = <-ch })]byte
-	type T3 /* ERROR invalid recursive type */ = chan [unsafe.Sizeof(func(ch T3){ _ = <-ch })]byte
+	type T3 /* ERROR "invalid recursive type" */ = chan [unsafe.Sizeof(func(ch T3){ _ = <-ch })]byte
 }
diff --git a/src/internal/types/testdata/check/cycles2.go b/src/internal/types/testdata/check/cycles2.go
index 8480b2939f..a932d288b5 100644
--- a/src/internal/types/testdata/check/cycles2.go
+++ b/src/internal/types/testdata/check/cycles2.go
@@ -65,30 +65,30 @@ var _ = x == y
 // Test case for issue 6638.
 
 type T interface {
-	m() [T(nil).m /* ERROR undefined */ ()[0]]int
+	m() [T(nil).m /* ERROR "undefined" */ ()[0]]int
 }
 
 // Variations of this test case.
 
-type T1 /* ERROR invalid recursive type */ interface {
+type T1 /* ERROR "invalid recursive type" */ interface {
 	m() [x1.m()[0]]int
 }
 
 var x1 T1
 
-type T2 /* ERROR invalid recursive type */ interface {
+type T2 /* ERROR "invalid recursive type" */ interface {
 	m() [len(x2.m())]int
 }
 
 var x2 T2
 
-type T3 /* ERROR invalid recursive type */ interface {
+type T3 /* ERROR "invalid recursive type" */ interface {
 	m() [unsafe.Sizeof(x3.m)]int
 }
 
 var x3 T3
 
-type T4 /* ERROR invalid recursive type */ interface {
+type T4 /* ERROR "invalid recursive type" */ interface {
 	m() [unsafe.Sizeof(cast4(x4.m))]int // cast is invalid but we have a cycle, so all bets are off
 }
 
diff --git a/src/internal/types/testdata/check/cycles3.go b/src/internal/types/testdata/check/cycles3.go
index 4330551402..3ed999cc3d 100644
--- a/src/internal/types/testdata/check/cycles3.go
+++ b/src/internal/types/testdata/check/cycles3.go
@@ -48,7 +48,7 @@ type (
 )
 
 type (
-	U /* ERROR invalid recursive type */ interface {
+	U /* ERROR "invalid recursive type" */ interface {
 		V
 	}
 
diff --git a/src/internal/types/testdata/check/cycles4.go b/src/internal/types/testdata/check/cycles4.go
index 924aabf475..e82300125c 100644
--- a/src/internal/types/testdata/check/cycles4.go
+++ b/src/internal/types/testdata/check/cycles4.go
@@ -115,7 +115,7 @@ type Event interface {
 // to follow-on errors due to an incorrectly computed type set.
 
 type T8 interface {
-	m() [unsafe.Sizeof(T8.m /* ERROR undefined */ )]int
+	m() [unsafe.Sizeof(T8.m /* ERROR "undefined" */ )]int
 }
 
 var _ = T8.m // no error expected here
diff --git a/src/internal/types/testdata/check/cycles5.go b/src/internal/types/testdata/check/cycles5.go
index 5e0d1913d9..a863aa8e39 100644
--- a/src/internal/types/testdata/check/cycles5.go
+++ b/src/internal/types/testdata/check/cycles5.go
@@ -98,12 +98,12 @@ var _ = err.Error()
 
 type (
 	T1 interface { T2 }
-	T2 /* ERROR invalid recursive type */ T2
+	T2 /* ERROR "invalid recursive type" */ T2
 )
 
 type (
 	T3 interface { T4 }
-	T4 /* ERROR invalid recursive type */ T5
+	T4 /* ERROR "invalid recursive type" */ T5
 	T5 = T6
 	T6 = T7
 	T7 = T4
@@ -121,8 +121,8 @@ type I interface {
 
 // test cases for varias alias cycles
 
-type T10 /* ERROR invalid recursive type */ = *T10                 // issue #25141
-type T11 /* ERROR invalid recursive type */ = interface{ f(T11) }  // issue #23139
+type T10 /* ERROR "invalid recursive type" */ = *T10                 // issue #25141
+type T11 /* ERROR "invalid recursive type" */ = interface{ f(T11) }  // issue #23139
 
 // issue #18640
 type (
@@ -135,7 +135,7 @@ type (
 type (
 	a struct{ *b }
 	b = c
-	c struct{ *b /* ERROR invalid use of type alias */ }
+	c struct{ *b /* ERROR "invalid use of type alias" */ }
 )
 
 // issue #24939
@@ -145,7 +145,7 @@ type (
 	}
 
 	M interface {
-		F() P // ERROR invalid use of type alias
+		F() P // ERROR "invalid use of type alias"
 	}
 
 	P = interface {
@@ -154,23 +154,23 @@ type (
 )
 
 // issue #8699
-type T12 /* ERROR invalid recursive type */ [len(a12)]int
+type T12 /* ERROR "invalid recursive type" */ [len(a12)]int
 var a12 = makeArray()
 func makeArray() (res T12) { return }
 
 // issue #20770
-var r /* ERROR invalid cycle in declaration of r */ = newReader()
+var r /* ERROR "invalid cycle in declaration of r" */ = newReader()
 func newReader() r
 
 // variations of the theme of #8699 and #20770
-var arr /* ERROR cycle */ = f()
+var arr /* ERROR "cycle" */ = f()
 func f() [len(arr)]int
 
 // issue #25790
-func ff(ff /* ERROR not a type */ )
-func gg((gg /* ERROR not a type */ ))
+func ff(ff /* ERROR "not a type" */ )
+func gg((gg /* ERROR "not a type" */ ))
 
-type T13 /* ERROR invalid recursive type T13 */ [len(b13)]int
+type T13 /* ERROR "invalid recursive type T13" */ [len(b13)]int
 var b13 T13
 
 func g1() [unsafe.Sizeof(g1)]int
@@ -184,13 +184,13 @@ func init() {
 	assert(unsafe.Sizeof(x2) == 8)
 }
 
-func h() [h /* ERROR no value */ ()[0]]int { panic(0) }
+func h() [h /* ERROR "no value" */ ()[0]]int { panic(0) }
 
-var c14 /* ERROR cycle */ T14
+var c14 /* ERROR "cycle" */ T14
 type T14 [uintptr(unsafe.Sizeof(&c14))]byte
 
 // issue #34333
-type T15 /* ERROR invalid recursive type T15 */ struct {
+type T15 /* ERROR "invalid recursive type T15" */ struct {
 	f func() T16
 	b T16
 }
diff --git a/src/internal/types/testdata/check/decls0.go b/src/internal/types/testdata/check/decls0.go
index 868b318a70..72d423e95a 100644
--- a/src/internal/types/testdata/check/decls0.go
+++ b/src/internal/types/testdata/check/decls0.go
@@ -189,10 +189,10 @@ func f4() (x *f4 /* ERROR "not a type" */ ) { return }
 // TODO(#43215) this should be detected as a cycle error
 func f5([unsafe.Sizeof(f5)]int) {}
 
-func (S0) m1 (x S0.m1 /* ERROR S0.m1 is not a type */ ) {}
-func (S0) m2 (x *S0.m2 /* ERROR S0.m2 is not a type */ ) {}
-func (S0) m3 () (x S0.m3 /* ERROR S0.m3 is not a type */ ) { return }
-func (S0) m4 () (x *S0.m4 /* ERROR S0.m4 is not a type */ ) { return }
+func (S0) m1 (x S0.m1 /* ERROR "S0.m1 is not a type" */ ) {}
+func (S0) m2 (x *S0.m2 /* ERROR "S0.m2 is not a type" */ ) {}
+func (S0) m3 () (x S0.m3 /* ERROR "S0.m3 is not a type" */ ) { return }
+func (S0) m4 () (x *S0.m4 /* ERROR "S0.m4 is not a type" */ ) { return }
 
 // interfaces may not have any blank methods
 type BlankI interface {
diff --git a/src/internal/types/testdata/check/decls1.go b/src/internal/types/testdata/check/decls1.go
index b232fc8ba7..faeacbf3c8 100644
--- a/src/internal/types/testdata/check/decls1.go
+++ b/src/internal/types/testdata/check/decls1.go
@@ -96,8 +96,8 @@ var (
 	v11 = xx/yy*yy - xx
 	v12 = true && false
 	v13 = nil /* ERROR "use of untyped nil" */
-	v14 string = 257 // ERROR cannot use 257 .* as string value in variable declaration$
-	v15 int8 = 257 // ERROR cannot use 257 .* as int8 value in variable declaration .*overflows
+	v14 string = 257 // ERROR "cannot use 257 .* as string value in variable declaration$"
+	v15 int8 = 257 // ERROR "cannot use 257 .* as int8 value in variable declaration .*overflows"
 )
 
 // Multiple assignment expressions
diff --git a/src/internal/types/testdata/check/decls4.go b/src/internal/types/testdata/check/decls4.go
index c1294eec86..6ad20b6502 100644
--- a/src/internal/types/testdata/check/decls4.go
+++ b/src/internal/types/testdata/check/decls4.go
@@ -61,10 +61,10 @@ var (
 // alias receiver types
 func (Ai /* ERROR "cannot define new methods on non-local type int" */) m1() {}
 func (T0) m1() {}
-func (A0) m1 /* ERROR already declared */ () {}
+func (A0) m1 /* ERROR "already declared" */ () {}
 func (A0) m2 () {}
-func (A3 /* ERROR invalid receiver */ ) m1 () {}
-func (A10 /* ERROR invalid receiver */ ) m1() {}
+func (A3 /* ERROR "invalid receiver" */ ) m1 () {}
+func (A10 /* ERROR "invalid receiver" */ ) m1() {}
 
 // x0 has methods m1, m2 declared via receiver type names T0 and A0
 var _ interface{ m1(); m2() } = x0
@@ -95,12 +95,12 @@ type (
 	V3 = T
 )
 
-func (V0) m /* ERROR already declared */ () {}
+func (V0) m /* ERROR "already declared" */ () {}
 func (V1) n() {}
 
 // alias receiver types (invalid due to cycles)
 type (
-	W0 /* ERROR invalid recursive type */ = W1
+	W0 /* ERROR "invalid recursive type" */ = W1
 	W1 = (W2)
 	W2 = ((W0))
 )
@@ -115,19 +115,19 @@ type (
 	B2 = int
 )
 
-func (B0 /* ERROR cannot define new methods on non-local type int */ ) m() {}
-func (B1 /* ERROR cannot define new methods on non-local type int */ ) n() {}
+func (B0 /* ERROR "cannot define new methods on non-local type int" */ ) m() {}
+func (B1 /* ERROR "cannot define new methods on non-local type int" */ ) n() {}
 
 // cycles
 type (
-	C2 /* ERROR invalid recursive type */ = C2
-	C3 /* ERROR invalid recursive type */ = C4
+	C2 /* ERROR "invalid recursive type" */ = C2
+	C3 /* ERROR "invalid recursive type" */ = C4
 	C4 = C3
 	C5 struct {
 		f *C6
 	}
 	C6 = C5
-	C7 /* ERROR invalid recursive type */  struct {
+	C7 /* ERROR "invalid recursive type" */  struct {
 		f C8
 	}
 	C8 = C7
@@ -136,7 +136,7 @@ type (
 // embedded fields
 var (
 	s0 struct { T0 }
-	s1 struct { A0 } = s0 /* ERROR cannot use */ // embedded field names are different
+	s1 struct { A0 } = s0 /* ERROR "cannot use" */ // embedded field names are different
 )
 
 // embedding and lookup of fields and methods
@@ -190,10 +190,10 @@ type eD struct {
 }
 
 var (
-	_ = eD{}.xf /* ERROR ambiguous selector eD{}.xf */
-	_ = eD{}.xm /* ERROR ambiguous selector eD{}.xm */
+	_ = eD{}.xf /* ERROR "ambiguous selector eD{}.xf" */
+	_ = eD{}.xm /* ERROR "ambiguous selector eD{}.xm" */
 )
 
 var (
-	_ interface{ xm() } = eD /* ERROR missing method xm */ {}
+	_ interface{ xm() } = eD /* ERROR "missing method xm" */ {}
 )
\ No newline at end of file
diff --git a/src/internal/types/testdata/check/errors.go b/src/internal/types/testdata/check/errors.go
index b3ab8afcac..f9aa3fc71b 100644
--- a/src/internal/types/testdata/check/errors.go
+++ b/src/internal/types/testdata/check/errors.go
@@ -8,59 +8,59 @@ package errors
 // (matching messages are regular expressions, hence the \'s).
 func f(x int, m map[string]int) {
 	// no values
-	_ = f /* ERROR f\(0, m\) \(no value\) used as value */ (0, m)
+	_ = f /* ERROR "f\(0, m\) \(no value\) used as value" */ (0, m)
 
 	// built-ins
-	_ = println // ERROR println \(built-in\) must be called
+	_ = println // ERROR "println \(built-in\) must be called"
 
 	// types
-	_ = complex128 // ERROR complex128 \(type\) is not an expression
+	_ = complex128 // ERROR "complex128 \(type\) is not an expression"
 
 	// constants
 	const c1 = 991
 	const c2 float32 = 0.5
 	const c3 = "foo"
-	0 // ERROR 0 \(untyped int constant\) is not used
-	0.5 // ERROR 0.5 \(untyped float constant\) is not used
-	"foo" // ERROR "foo" \(untyped string constant\) is not used
-	c1 // ERROR c1 \(untyped int constant 991\) is not used
-	c2 // ERROR c2 \(constant 0.5 of type float32\) is not used
-	c1 /* ERROR c1 \+ c2 \(constant 991.5 of type float32\) is not used */ + c2
-	c3 // ERROR c3 \(untyped string constant "foo"\) is not used
+	0 // ERROR "0 \(untyped int constant\) is not used"
+	0.5 // ERROR "0.5 \(untyped float constant\) is not used"
+	"foo" // ERROR ""foo" \(untyped string constant\) is not used"
+	c1 // ERROR "c1 \(untyped int constant 991\) is not used"
+	c2 // ERROR "c2 \(constant 0.5 of type float32\) is not used"
+	c1 /* ERROR "c1 \+ c2 \(constant 991.5 of type float32\) is not used" */ + c2
+	c3 // ERROR "c3 \(untyped string constant "foo"\) is not used"
 
 	// variables
-	x // ERROR x \(variable of type int\) is not used
+	x // ERROR "x \(variable of type int\) is not used"
 
 	// values
-	nil // ERROR nil is not used
-	( /* ERROR \(\*int\)\(nil\) \(value of type \*int\) is not used */ *int)(nil)
-	x /* ERROR x != x \(untyped bool value\) is not used */ != x
-	x /* ERROR x \+ x \(value of type int\) is not used */ + x
+	nil // ERROR "nil is not used"
+	( /* ERROR "\(\*int\)\(nil\) \(value of type \*int\) is not used" */ *int)(nil)
+	x /* ERROR "x != x \(untyped bool value\) is not used" */ != x
+	x /* ERROR "x \+ x \(value of type int\) is not used" */ + x
 
 	// value, ok's
 	const s = "foo"
-	m /* ERROR m\[s\] \(map index expression of type int\) is not used */ [s]
+	m /* ERROR "m\[s\] \(map index expression of type int\) is not used" */ [s]
 }
 
 // Valid ERROR comments can have a variety of forms.
 func _() {
 	0 /* ERROR "0 .* is not used" */
-	0 /* ERROR 0 .* is not used */
+	0 /* ERROR "0 .* is not used" */
+	0 // ERROR "0 .* is not used"
 	0 // ERROR "0 .* is not used"
-	0 // ERROR 0 .* is not used
 }
 
 // Don't report spurious errors as a consequence of earlier errors.
 // Add more tests as needed.
 func _() {
-	if err := foo /* ERROR undefined */ (); err != nil /* no error here */ {}
+	if err := foo /* ERROR "undefined" */ (); err != nil /* "no error here" */ {}
 }
 
 // Use unqualified names for package-local objects.
 type T struct{}
-var _ int = T /* ERROR value of type T */ {} // use T in error message rather then errors.T
+var _ int = T /* ERROR "value of type T" */ {} // use T in error message rather then errors.T
 
 // Don't report errors containing "invalid type" (issue #24182).
-func _(x *missing /* ERROR undefined: missing */ ) {
+func _(x *missing /* ERROR "undefined: missing" */ ) {
 	x.m() // there shouldn't be an error here referring to *invalid type
 }
diff --git a/src/internal/types/testdata/check/expr0.go b/src/internal/types/testdata/check/expr0.go
index dd86eca535..059ad61d5c 100644
--- a/src/internal/types/testdata/check/expr0.go
+++ b/src/internal/types/testdata/check/expr0.go
@@ -175,13 +175,13 @@ var (
 func g() (a, b int) { return }
 
 func _() {
-	_ = -g /* ERROR multiple-value g */ ()
-	_ = <-g /* ERROR multiple-value g */ ()
+	_ = -g /* ERROR "multiple-value g" */ ()
+	_ = <-g /* ERROR "multiple-value g" */ ()
 }
 
 // ~ is accepted as unary operator only permitted in interface type elements
 var (
-	_ = ~ /* ERROR cannot use ~ outside of interface or type constraint */ 0
-	_ = ~ /* ERROR cannot use ~ outside of interface or type constraint */ "foo"
-	_ = ~ /* ERROR cannot use ~ outside of interface or type constraint */ i0
+	_ = ~ /* ERROR "cannot use ~ outside of interface or type constraint" */ 0
+	_ = ~ /* ERROR "cannot use ~ outside of interface or type constraint" */ "foo"
+	_ = ~ /* ERROR "cannot use ~ outside of interface or type constraint" */ i0
 )
diff --git a/src/internal/types/testdata/check/expr1.go b/src/internal/types/testdata/check/expr1.go
index 49e8baed02..8d54ec2f9e 100644
--- a/src/internal/types/testdata/check/expr1.go
+++ b/src/internal/types/testdata/check/expr1.go
@@ -16,10 +16,10 @@ func _(x, y bool, z mybool) {
 	x = x && true
 	x = x && false
 
-	z = z /* ERROR mismatched types */ || y
+	z = z /* ERROR "mismatched types" */ || y
 	z = z || true
 	z = z || false
-	z = z /* ERROR mismatched types */ && y
+	z = z /* ERROR "mismatched types" */ && y
 	z = z && true
 	z = z && false
 }
@@ -29,7 +29,7 @@ type myint int
 func _(x, y int, z myint) {
 	x = x + 1
 	x = x + 1.0
-	x = x + 1.1 // ERROR truncated to int
+	x = x + 1.1 // ERROR "truncated to int"
 	x = x + y
 	x = x - y
 	x = x * y
@@ -40,12 +40,12 @@ func _(x, y int, z myint) {
 
 	z = z + 1
 	z = z + 1.0
-	z = z + 1.1 // ERROR truncated to int
-	z = z /* ERROR mismatched types */ + y
-	z = z /* ERROR mismatched types */ - y
-	z = z /* ERROR mismatched types */ * y
-	z = z /* ERROR mismatched types */ / y
-	z = z /* ERROR mismatched types */ % y
+	z = z + 1.1 // ERROR "truncated to int"
+	z = z /* ERROR "mismatched types" */ + y
+	z = z /* ERROR "mismatched types" */ - y
+	z = z /* ERROR "mismatched types" */ * y
+	z = z /* ERROR "mismatched types" */ / y
+	z = z /* ERROR "mismatched types" */ % y
 	z = z << y
 	z = z >> y
 }
@@ -54,9 +54,9 @@ type myuint uint
 
 func _(x, y uint, z myuint) {
 	x = x + 1
-	x = x + - /* ERROR overflows uint */ 1
+	x = x + - /* ERROR "overflows uint" */ 1
 	x = x + 1.0
-	x = x + 1.1 // ERROR truncated to uint
+	x = x + 1.1 // ERROR "truncated to uint"
 	x = x + y
 	x = x - y
 	x = x * y
@@ -66,14 +66,14 @@ func _(x, y uint, z myuint) {
 	x = x >> y
 
 	z = z + 1
-	z = x + - /* ERROR overflows uint */ 1
+	z = x + - /* ERROR "overflows uint" */ 1
 	z = z + 1.0
-	z = z + 1.1 // ERROR truncated to uint
-	z = z /* ERROR mismatched types */ + y
-	z = z /* ERROR mismatched types */ - y
-	z = z /* ERROR mismatched types */ * y
-	z = z /* ERROR mismatched types */ / y
-	z = z /* ERROR mismatched types */ % y
+	z = z + 1.1 // ERROR "truncated to uint"
+	z = z /* ERROR "mismatched types" */ + y
+	z = z /* ERROR "mismatched types" */ - y
+	z = z /* ERROR "mismatched types" */ * y
+	z = z /* ERROR "mismatched types" */ / y
+	z = z /* ERROR "mismatched types" */ % y
 	z = z << y
 	z = z >> y
 }
@@ -89,39 +89,39 @@ func _(x, y float64, z myfloat64) {
 	x = x - y
 	x = x * y
 	x = x / y
-	x = x /* ERROR not defined */ % y
-	x = x /* ERROR operand x .* must be integer */ << y
-	x = x /* ERROR operand x .* must be integer */ >> y
+	x = x /* ERROR "not defined" */ % y
+	x = x /* ERROR "operand x .* must be integer" */ << y
+	x = x /* ERROR "operand x .* must be integer" */ >> y
 
 	z = z + 1
 	z = z + -1
 	z = z + 1.0
 	z = z + 1.1
-	z = z /* ERROR mismatched types */ + y
-	z = z /* ERROR mismatched types */ - y
-	z = z /* ERROR mismatched types */ * y
-	z = z /* ERROR mismatched types */ / y
-	z = z /* ERROR mismatched types */ % y
-	z = z /* ERROR operand z .* must be integer */ << y
-	z = z /* ERROR operand z .* must be integer */ >> y
+	z = z /* ERROR "mismatched types" */ + y
+	z = z /* ERROR "mismatched types" */ - y
+	z = z /* ERROR "mismatched types" */ * y
+	z = z /* ERROR "mismatched types" */ / y
+	z = z /* ERROR "mismatched types" */ % y
+	z = z /* ERROR "operand z .* must be integer" */ << y
+	z = z /* ERROR "operand z .* must be integer" */ >> y
 }
 
 type mystring string
 
 func _(x, y string, z mystring) {
 	x = x + "foo"
-	x = x /* ERROR not defined */ - "foo"
-	x = x /* ERROR mismatched types string and untyped int */ + 1
+	x = x /* ERROR "not defined" */ - "foo"
+	x = x /* ERROR "mismatched types string and untyped int" */ + 1
 	x = x + y
-	x = x /* ERROR not defined */ - y
-	x = x /* ERROR mismatched types string and untyped int */* 10
+	x = x /* ERROR "not defined" */ - y
+	x = x /* ERROR "mismatched types string and untyped int" */* 10
 }
 
 func f() (a, b int) { return }
 
 func _(x int) {
-	_ = f /* ERROR multiple-value f */ () + 1
-	_ = x + f /* ERROR multiple-value f */ ()
-	_ = f /* ERROR multiple-value f */ () + f
-	_ = f /* ERROR multiple-value f */ () + f /* ERROR multiple-value f */ ()
+	_ = f /* ERROR "multiple-value f" */ () + 1
+	_ = x + f /* ERROR "multiple-value f" */ ()
+	_ = f /* ERROR "multiple-value f" */ () + f
+	_ = f /* ERROR "multiple-value f" */ () + f /* ERROR "multiple-value f" */ ()
 }
diff --git a/src/internal/types/testdata/check/expr2.go b/src/internal/types/testdata/check/expr2.go
index 1929664128..b00cfc21f8 100644
--- a/src/internal/types/testdata/check/expr2.go
+++ b/src/internal/types/testdata/check/expr2.go
@@ -9,8 +9,8 @@ package expr2
 func _bool() {
 	const t = true == true
 	const f = true == false
-	_ = t /* ERROR operator .* not defined */ < f
-	_ = 0 == t /* ERROR mismatched types untyped int and untyped bool */
+	_ = t /* ERROR "operator .* not defined" */ < f
+	_ = 0 == t /* ERROR "mismatched types untyped int and untyped bool" */
 	var b bool
 	var x, y float32
 	b = x < y
@@ -20,7 +20,7 @@ func _bool() {
 
 // corner cases
 var (
-	v0 = nil == nil // ERROR operator == not defined on untyped nil
+	v0 = nil == nil // ERROR "operator == not defined on untyped nil"
 )
 
 func arrays() {
@@ -28,8 +28,8 @@ func arrays() {
 	var a, b [10]int
 	_ = a == b
 	_ = a != b
-	_ = a /* ERROR < not defined */ < b
-	_ = a == nil /* ERROR mismatched types */
+	_ = a /* ERROR "< not defined" */ < b
+	_ = a == nil /* ERROR "mismatched types" */
 
 	type C [10]int
 	var c C
@@ -37,10 +37,10 @@ func arrays() {
 
 	type D [10]int
 	var d D
-	_ = c == d /* ERROR mismatched types */
+	_ = c == d /* ERROR "mismatched types" */
 
 	var e [10]func() int
-	_ = e /* ERROR \[10\]func\(\) int cannot be compared */ == e
+	_ = e /* ERROR "\[10\]func\(\) int cannot be compared" */ == e
 }
 
 func structs() {
@@ -52,8 +52,8 @@ func structs() {
 	}
 	_ = s == t
 	_ = s != t
-	_ = s /* ERROR < not defined */ < t
-	_ = s == nil /* ERROR mismatched types */
+	_ = s /* ERROR "< not defined" */ < t
+	_ = s == nil /* ERROR "mismatched types" */
 
 	type S struct {
 		x int
@@ -68,23 +68,23 @@ func structs() {
 	var ss S
 	var tt T
 	_ = s == ss
-	_ = ss == tt /* ERROR mismatched types */
+	_ = ss == tt /* ERROR "mismatched types" */
 
 	var u struct {
 		x int
 		a [10]map[string]int
 	}
-	_ = u /* ERROR cannot be compared */ == u
+	_ = u /* ERROR "cannot be compared" */ == u
 }
 
 func pointers() {
 	// nil
-	_ = nil == nil // ERROR operator == not defined on untyped nil
-	_ = nil != nil // ERROR operator != not defined on untyped nil
-	_ = nil /* ERROR < not defined */ < nil
-	_ = nil /* ERROR <= not defined */ <= nil
-	_ = nil /* ERROR > not defined */ > nil
-	_ = nil /* ERROR >= not defined */ >= nil
+	_ = nil == nil // ERROR "operator == not defined on untyped nil"
+	_ = nil != nil // ERROR "operator != not defined on untyped nil"
+	_ = nil /* ERROR "< not defined" */ < nil
+	_ = nil /* ERROR "<= not defined" */ <= nil
+	_ = nil /* ERROR "> not defined" */ > nil
+	_ = nil /* ERROR ">= not defined" */ >= nil
 
 	// basics
 	var p, q *int
@@ -96,10 +96,10 @@ func pointers() {
 	_ = nil == q
 	_ = nil != q
 
-	_ = p /* ERROR < not defined */ < q
-	_ = p /* ERROR <= not defined */ <= q
-	_ = p /* ERROR > not defined */ > q
-	_ = p /* ERROR >= not defined */ >= q
+	_ = p /* ERROR "< not defined" */ < q
+	_ = p /* ERROR "<= not defined" */ <= q
+	_ = p /* ERROR "> not defined" */ > q
+	_ = p /* ERROR ">= not defined" */ >= q
 
 	// various element types
 	type (
@@ -115,11 +115,11 @@ func pointers() {
 		p2 P2
 	)
 	_ = ps1 == ps1
-	_ = ps1 == ps2 /* ERROR mismatched types */
-	_ = ps2 == ps1 /* ERROR mismatched types */
+	_ = ps1 == ps2 /* ERROR "mismatched types" */
+	_ = ps2 == ps1 /* ERROR "mismatched types" */
 
 	_ = p1 == p1
-	_ = p1 == p2 /* ERROR mismatched types */
+	_ = p1 == p2 /* ERROR "mismatched types" */
 
 	_ = p1 == ps1
 }
@@ -130,7 +130,7 @@ func channels() {
 	_ = c == d
 	_ = c != d
 	_ = c == nil
-	_ = c /* ERROR < not defined */ < d
+	_ = c /* ERROR "< not defined" */ < d
 
 	// various element types (named types)
 	type (
@@ -147,13 +147,13 @@ func channels() {
 		c2 C2
 	)
 	_ = c1 == c1
-	_ = c1 == c1r /* ERROR mismatched types */
-	_ = c1 == c1s /* ERROR mismatched types */
-	_ = c1r == c1s /* ERROR mismatched types */
+	_ = c1 == c1r /* ERROR "mismatched types" */
+	_ = c1 == c1s /* ERROR "mismatched types" */
+	_ = c1r == c1s /* ERROR "mismatched types" */
 	_ = c1 == c1a
 	_ = c1a == c1
-	_ = c1 == c2 /* ERROR mismatched types */
-	_ = c1a == c2 /* ERROR mismatched types */
+	_ = c1 == c2 /* ERROR "mismatched types" */
+	_ = c1a == c2 /* ERROR "mismatched types" */
 
 	// various element types (unnamed types)
 	var (
@@ -166,11 +166,11 @@ func channels() {
 	_ = d1 == d1
 	_ = d1 == d1r
 	_ = d1 == d1s
-	_ = d1r == d1s /* ERROR mismatched types */
+	_ = d1r == d1s /* ERROR "mismatched types" */
 	_ = d1 == d1a
 	_ = d1a == d1
-	_ = d1 == d2 /* ERROR mismatched types */
-	_ = d1a == d2 /* ERROR mismatched types */
+	_ = d1 == d2 /* ERROR "mismatched types" */
+	_ = d1a == d2 /* ERROR "mismatched types" */
 }
 
 // for interfaces test
@@ -188,39 +188,39 @@ func interfaces() {
 	_ = i == j
 	_ = i != j
 	_ = i == nil
-	_ = i /* ERROR < not defined */ < j
+	_ = i /* ERROR "< not defined" */ < j
 
 	// various interfaces
 	var ii interface { m() int; n() }
 	var k interface { m() float32 }
 	_ = i == ii
-	_ = i == k /* ERROR mismatched types */
+	_ = i == k /* ERROR "mismatched types" */
 
 	// interfaces vs values
 	var s1 S1
 	var s11 S11
 	var s2 S2
 
-	_ = i == 0 /* ERROR cannot convert */
-	_ = i == s1 /* ERROR mismatched types */
+	_ = i == 0 /* ERROR "cannot convert" */
+	_ = i == s1 /* ERROR "mismatched types" */
 	_ = i == &s1
 	_ = i == &s11
 
-	_ = i == s2 /* ERROR mismatched types */
-	_ = i == & /* ERROR mismatched types */ s2
+	_ = i == s2 /* ERROR "mismatched types" */
+	_ = i == & /* ERROR "mismatched types" */ s2
 
 	// issue #28164
 	// testcase from issue
-	_ = interface{}(nil) == [ /* ERROR slice can only be compared to nil */ ]int(nil)
+	_ = interface{}(nil) == [ /* ERROR "slice can only be compared to nil" */ ]int(nil)
 
 	// related cases
 	var e interface{}
 	var s []int
 	var x int
-	_ = e == s // ERROR slice can only be compared to nil
-	_ = s /* ERROR slice can only be compared to nil */ == e
-	_ = e /* ERROR operator < not defined on interface */ < x
-	_ = x < e // ERROR operator < not defined on interface
+	_ = e == s // ERROR "slice can only be compared to nil"
+	_ = s /* ERROR "slice can only be compared to nil" */ == e
+	_ = e /* ERROR "operator < not defined on interface" */ < x
+	_ = x < e // ERROR "operator < not defined on interface"
 }
 
 func slices() {
@@ -228,11 +228,11 @@ func slices() {
 	var s []int
 	_ = s == nil
 	_ = s != nil
-	_ = s /* ERROR < not defined */ < nil
+	_ = s /* ERROR "< not defined" */ < nil
 
 	// slices are not otherwise comparable
-	_ = s /* ERROR slice can only be compared to nil */ == s
-	_ = s /* ERROR < not defined */ < s
+	_ = s /* ERROR "slice can only be compared to nil" */ == s
+	_ = s /* ERROR "< not defined" */ < s
 }
 
 func maps() {
@@ -240,11 +240,11 @@ func maps() {
 	var m map[string]int
 	_ = m == nil
 	_ = m != nil
-	_ = m /* ERROR < not defined */ < nil
+	_ = m /* ERROR "< not defined" */ < nil
 
 	// maps are not otherwise comparable
-	_ = m /* ERROR map can only be compared to nil */ == m
-	_ = m /* ERROR < not defined */ < m
+	_ = m /* ERROR "map can only be compared to nil" */ == m
+	_ = m /* ERROR "< not defined" */ < m
 }
 
 func funcs() {
@@ -252,9 +252,9 @@ func funcs() {
 	var f func(int) float32
 	_ = f == nil
 	_ = f != nil
-	_ = f /* ERROR < not defined */ < nil
+	_ = f /* ERROR "< not defined" */ < nil
 
 	// funcs are not otherwise comparable
-	_ = f /* ERROR func can only be compared to nil */ == f
-	_ = f /* ERROR < not defined */ < f
+	_ = f /* ERROR "func can only be compared to nil" */ == f
+	_ = f /* ERROR "< not defined" */ < f
 }
diff --git a/src/internal/types/testdata/check/expr3.go b/src/internal/types/testdata/check/expr3.go
index 2da59841c6..8cf9482257 100644
--- a/src/internal/types/testdata/check/expr3.go
+++ b/src/internal/types/testdata/check/expr3.go
@@ -209,9 +209,9 @@ func struct_literals() {
 	_ = time.Time{}
 	_ = time.Time{sec /* ERROR "unknown field" */ : 0}
 	_ = time.Time{
-		0 /* ERROR implicit assignment to unexported field wall in struct literal */,
-		0 /* ERROR implicit assignment */ ,
-		nil /* ERROR implicit assignment */ ,
+		0 /* ERROR "implicit assignment to unexported field wall in struct literal" */,
+		0 /* ERROR "implicit assignment" */ ,
+		nil /* ERROR "implicit assignment" */ ,
 	}
 }
 
diff --git a/src/internal/types/testdata/check/go1_16.go b/src/internal/types/testdata/check/go1_16.go
index 81b529044c..9675b292b6 100644
--- a/src/internal/types/testdata/check/go1_16.go
+++ b/src/internal/types/testdata/check/go1_16.go
@@ -12,4 +12,4 @@ type Slice []byte
 type Array [8]byte
 
 var s Slice
-var p = (*Array)(s /* ERROR requires go1.17 or later */ )
+var p = (*Array)(s /* ERROR "requires go1.17 or later" */ )
diff --git a/src/internal/types/testdata/check/go1_19.go b/src/internal/types/testdata/check/go1_19.go
index f899d93733..b6cff4f465 100644
--- a/src/internal/types/testdata/check/go1_19.go
+++ b/src/internal/types/testdata/check/go1_19.go
@@ -12,4 +12,4 @@ type Slice []byte
 type Array [8]byte
 
 var s Slice
-var p = (Array)(s /* ERROR requires go1.20 or later */)
+var p = (Array)(s /* ERROR "requires go1.20 or later" */)
diff --git a/src/internal/types/testdata/check/go1_8.go b/src/internal/types/testdata/check/go1_8.go
index 99f2fd4eb2..6a7e639792 100644
--- a/src/internal/types/testdata/check/go1_8.go
+++ b/src/internal/types/testdata/check/go1_8.go
@@ -9,4 +9,4 @@
 package p
 
 // type alias declarations
-type any = /* ERROR type aliases requires go1.9 or later */ interface{}
+type any = /* ERROR "type aliases requires go1.9 or later" */ interface{}
diff --git a/src/internal/types/testdata/check/importC.go b/src/internal/types/testdata/check/importC.go
index 807802199f..a91feb653a 100644
--- a/src/internal/types/testdata/check/importC.go
+++ b/src/internal/types/testdata/check/importC.go
@@ -7,9 +7,9 @@
 package importC
 
 import "C"
-import _ /* ERROR cannot rename import "C" */ "C"
-import foo /* ERROR cannot rename import "C" */ "C"
-import . /* ERROR cannot rename import "C" */ "C"
+import _ /* ERROR "cannot rename import "C"" */ "C"
+import foo /* ERROR "cannot rename import "C"" */ "C"
+import . /* ERROR "cannot rename import "C"" */ "C"
 
 // Test cases extracted from issue #22090.
 
diff --git a/src/internal/types/testdata/check/importdecl0/importdecl0b.go b/src/internal/types/testdata/check/importdecl0/importdecl0b.go
index 904faff681..c5216a5dec 100644
--- a/src/internal/types/testdata/check/importdecl0/importdecl0b.go
+++ b/src/internal/types/testdata/check/importdecl0/importdecl0b.go
@@ -8,13 +8,13 @@ import "math"
 import m "math"
 
 import . "testing" // declares T in file scope
-import . /* ERROR .unsafe. imported and not used */ "unsafe"
+import . /* ERROR ".unsafe. imported and not used" */ "unsafe"
 import . "fmt"     // declares Println in file scope
 
 import (
-	"" /* ERROR invalid import path */
-	"a!b" /* ERROR invalid import path */
-	"abc\xffdef" /* ERROR invalid import path */
+	"" /* ERROR "invalid import path" */
+	"a!b" /* ERROR "invalid import path" */
+	"abc\xffdef" /* ERROR "invalid import path" */
 )
 
 // using "math" in this file doesn't affect its use in other files
diff --git a/src/internal/types/testdata/check/importdecl1/importdecl1b.go b/src/internal/types/testdata/check/importdecl1/importdecl1b.go
index ce8b983d28..fc39863764 100644
--- a/src/internal/types/testdata/check/importdecl1/importdecl1b.go
+++ b/src/internal/types/testdata/check/importdecl1/importdecl1b.go
@@ -4,7 +4,7 @@
 
 package importdecl1
 
-import . /* ERROR .unsafe. imported and not used */ "unsafe"
+import . /* ERROR ".unsafe. imported and not used" */ "unsafe"
 
 type B interface {
 	A
diff --git a/src/internal/types/testdata/check/init0.go b/src/internal/types/testdata/check/init0.go
index 5159a176d7..ee2175e2c7 100644
--- a/src/internal/types/testdata/check/init0.go
+++ b/src/internal/types/testdata/check/init0.go
@@ -8,50 +8,50 @@ package init0
 
 // initialization cycles (we don't know the types)
 const (
-	s0 /* ERROR initialization cycle: s0 refers to itself */ = s0
+	s0 /* ERROR "initialization cycle: s0 refers to itself" */ = s0
 
-	x0 /* ERROR initialization cycle for x0 */ = y0
+	x0 /* ERROR "initialization cycle for x0" */ = y0
 	y0 = x0
 
 	a0 = b0
-	b0 /* ERROR initialization cycle for b0 */ = c0
+	b0 /* ERROR "initialization cycle for b0" */ = c0
 	c0 = d0
 	d0 = b0
 )
 
 var (
-	s1 /* ERROR initialization cycle: s1 refers to itself */ = s1
+	s1 /* ERROR "initialization cycle: s1 refers to itself" */ = s1
 
-	x1 /* ERROR initialization cycle for x1 */ = y1
+	x1 /* ERROR "initialization cycle for x1" */ = y1
 	y1 = x1
 
 	a1 = b1
-	b1 /* ERROR initialization cycle for b1 */ = c1
+	b1 /* ERROR "initialization cycle for b1" */ = c1
 	c1 = d1
 	d1 = b1
 )
 
 // initialization cycles (we know the types)
 const (
-	s2 /* ERROR initialization cycle: s2 refers to itself */ int = s2
+	s2 /* ERROR "initialization cycle: s2 refers to itself" */ int = s2
 
-	x2 /* ERROR initialization cycle for x2 */ int = y2
+	x2 /* ERROR "initialization cycle for x2" */ int = y2
 	y2 = x2
 
 	a2 = b2
-	b2 /* ERROR initialization cycle for b2 */ int = c2
+	b2 /* ERROR "initialization cycle for b2" */ int = c2
 	c2 = d2
 	d2 = b2
 )
 
 var (
-	s3 /* ERROR initialization cycle: s3 refers to itself */ int = s3
+	s3 /* ERROR "initialization cycle: s3 refers to itself" */ int = s3
 
-	x3 /* ERROR initialization cycle for x3 */ int = y3
+	x3 /* ERROR "initialization cycle for x3" */ int = y3
 	y3 = x3
 
 	a3 = b3
-	b3 /* ERROR initialization cycle for b3 */ int = c3
+	b3 /* ERROR "initialization cycle for b3" */ int = c3
 	c3 = d3
 	d3 = b3
 )
@@ -61,25 +61,25 @@ var (
 type S1 struct {
 	f int
 }
-const cx3 S1 /* ERROR invalid constant type */ = S1{cx3.f}
-var vx3 /* ERROR initialization cycle: vx3 refers to itself */ S1 = S1{vx3.f}
+const cx3 S1 /* ERROR "invalid constant type" */ = S1{cx3.f}
+var vx3 /* ERROR "initialization cycle: vx3 refers to itself" */ S1 = S1{vx3.f}
 
 // cycles via functions
 
 var x4 = x5
-var x5 /* ERROR initialization cycle for x5 */ = f1()
+var x5 /* ERROR "initialization cycle for x5" */ = f1()
 func f1() int { return x5*10 }
 
-var x6, x7 /* ERROR initialization cycle */ = f2()
+var x6, x7 /* ERROR "initialization cycle" */ = f2()
 var x8 = x7
 func f2() (int, int) { return f3() + f3(), 0 }
 func f3() int { return x8 }
 
 // cycles via function literals
 
-var x9 /* ERROR initialization cycle: x9 refers to itself */ = func() int { return x9 }()
+var x9 /* ERROR "initialization cycle: x9 refers to itself" */ = func() int { return x9 }()
 
-var x10 /* ERROR initialization cycle for x10 */ = f4()
+var x10 /* ERROR "initialization cycle for x10" */ = f4()
 
 func f4() int {
 	_ = func() {
@@ -94,7 +94,7 @@ type T1 struct{}
 
 func (T1) m() bool { _ = x11; return false }
 
-var x11 /* ERROR initialization cycle for x11 */ = T1.m(T1{})
+var x11 /* ERROR "initialization cycle for x11" */ = T1.m(T1{})
 
 // cycles via method values
 
@@ -103,4 +103,4 @@ type T2 struct{}
 func (T2) m() bool { _ = x12; return false }
 
 var t1 T2
-var x12 /* ERROR initialization cycle for x12 */ = t1.m
+var x12 /* ERROR "initialization cycle for x12" */ = t1.m
diff --git a/src/internal/types/testdata/check/init1.go b/src/internal/types/testdata/check/init1.go
index 39ca31466b..c89032ad62 100644
--- a/src/internal/types/testdata/check/init1.go
+++ b/src/internal/types/testdata/check/init1.go
@@ -14,7 +14,7 @@ func (T0) m() int { return y0 }
 
 var x0 = T0{}
 
-var y0 /* ERROR initialization cycle */ = x0.m()
+var y0 /* ERROR "initialization cycle" */ = x0.m()
 
 type T1 struct{}
 
@@ -28,7 +28,7 @@ var y1 = x1.m() // no cycle reported, x1 is of interface type
 
 // issue 6703 (modified)
 
-var x2 /* ERROR initialization cycle */ = T2.m
+var x2 /* ERROR "initialization cycle" */ = T2.m
 
 var y2 = x2
 
@@ -39,7 +39,7 @@ func (T2) m() int {
 	return 0
 }
 
-var x3 /* ERROR initialization cycle */ = T3.m(T3{}) // <<<< added (T3{})
+var x3 /* ERROR "initialization cycle" */ = T3.m(T3{}) // <<<< added (T3{})
 
 var y3 = x3
 
@@ -50,7 +50,7 @@ func (T3) m() int {
 	return 0
 }
 
-var x4 /* ERROR initialization cycle */ = T4{}.m // <<<< added {}
+var x4 /* ERROR "initialization cycle" */ = T4{}.m // <<<< added {}
 
 var y4 = x4
 
@@ -61,7 +61,7 @@ func (T4) m() int {
 	return 0
 }
 
-var x5 /* ERROR initialization cycle */ = T5{}.m() // <<<< added ()
+var x5 /* ERROR "initialization cycle" */ = T5{}.m() // <<<< added ()
 
 var y5 = x5
 
@@ -76,7 +76,7 @@ func (T5) m() int {
 // simplified test case
 
 var x6 = f6
-var y6 /* ERROR initialization cycle */ = f6
+var y6 /* ERROR "initialization cycle" */ = f6
 func f6() { _ = y6 }
 
 // full test case
@@ -92,6 +92,6 @@ func matchList(s *S) E { return matcher(matchAnyFn)(s) }
 
 var foo = matcher(matchList)
 
-var matchAny /* ERROR initialization cycle */ = matcher(matchList)
+var matchAny /* ERROR "initialization cycle" */ = matcher(matchList)
 
 func matchAnyFn(s *S) (err E) { return matchAny(s) }
\ No newline at end of file
diff --git a/src/internal/types/testdata/check/init2.go b/src/internal/types/testdata/check/init2.go
index 614db6c949..24e9277122 100644
--- a/src/internal/types/testdata/check/init2.go
+++ b/src/internal/types/testdata/check/init2.go
@@ -9,131 +9,131 @@ package init2
 // cycles through functions
 
 func f1() int { _ = x1; return 0 }
-var x1 /* ERROR initialization cycle */ = f1
+var x1 /* ERROR "initialization cycle" */ = f1
 
 func f2() int { _ = x2; return 0 }
-var x2 /* ERROR initialization cycle */ = f2()
+var x2 /* ERROR "initialization cycle" */ = f2()
 
 // cycles through method expressions
 
 type T3 int
 func (T3) m() int { _ = x3; return 0 }
-var x3 /* ERROR initialization cycle */ = T3.m
+var x3 /* ERROR "initialization cycle" */ = T3.m
 
 type T4 int
 func (T4) m() int { _ = x4; return 0 }
-var x4 /* ERROR initialization cycle */ = T4.m(0)
+var x4 /* ERROR "initialization cycle" */ = T4.m(0)
 
 type T3p int
 func (*T3p) m() int { _ = x3p; return 0 }
-var x3p /* ERROR initialization cycle */ = (*T3p).m
+var x3p /* ERROR "initialization cycle" */ = (*T3p).m
 
 type T4p int
 func (*T4p) m() int { _ = x4p; return 0 }
-var x4p /* ERROR initialization cycle */ = (*T4p).m(nil)
+var x4p /* ERROR "initialization cycle" */ = (*T4p).m(nil)
 
 // cycles through method expressions of embedded methods
 
 type T5 struct { E5 }
 type E5 int
 func (E5) m() int { _ = x5; return 0 }
-var x5 /* ERROR initialization cycle */ = T5.m
+var x5 /* ERROR "initialization cycle" */ = T5.m
 
 type T6 struct { E6 }
 type E6 int
 func (E6) m() int { _ = x6; return 0 }
-var x6 /* ERROR initialization cycle */ = T6.m(T6{0})
+var x6 /* ERROR "initialization cycle" */ = T6.m(T6{0})
 
 type T5p struct { E5p }
 type E5p int
 func (*E5p) m() int { _ = x5p; return 0 }
-var x5p /* ERROR initialization cycle */ = (*T5p).m
+var x5p /* ERROR "initialization cycle" */ = (*T5p).m
 
 type T6p struct { E6p }
 type E6p int
 func (*E6p) m() int { _ = x6p; return 0 }
-var x6p /* ERROR initialization cycle */ = (*T6p).m(nil)
+var x6p /* ERROR "initialization cycle" */ = (*T6p).m(nil)
 
 // cycles through method values
 
 type T7 int
 func (T7) m() int { _ = x7; return 0 }
-var x7 /* ERROR initialization cycle */ = T7(0).m
+var x7 /* ERROR "initialization cycle" */ = T7(0).m
 
 type T8 int
 func (T8) m() int { _ = x8; return 0 }
-var x8 /* ERROR initialization cycle */ = T8(0).m()
+var x8 /* ERROR "initialization cycle" */ = T8(0).m()
 
 type T7p int
 func (*T7p) m() int { _ = x7p; return 0 }
-var x7p /* ERROR initialization cycle */ = new(T7p).m
+var x7p /* ERROR "initialization cycle" */ = new(T7p).m
 
 type T8p int
 func (*T8p) m() int { _ = x8p; return 0 }
-var x8p /* ERROR initialization cycle */ = new(T8p).m()
+var x8p /* ERROR "initialization cycle" */ = new(T8p).m()
 
 type T7v int
 func (T7v) m() int { _ = x7v; return 0 }
 var x7var T7v
-var x7v /* ERROR initialization cycle */ = x7var.m
+var x7v /* ERROR "initialization cycle" */ = x7var.m
 
 type T8v int
 func (T8v) m() int { _ = x8v; return 0 }
 var x8var T8v
-var x8v /* ERROR initialization cycle */ = x8var.m()
+var x8v /* ERROR "initialization cycle" */ = x8var.m()
 
 type T7pv int
 func (*T7pv) m() int { _ = x7pv; return 0 }
 var x7pvar *T7pv
-var x7pv /* ERROR initialization cycle */ = x7pvar.m
+var x7pv /* ERROR "initialization cycle" */ = x7pvar.m
 
 type T8pv int
 func (*T8pv) m() int { _ = x8pv; return 0 }
 var x8pvar *T8pv
-var x8pv /* ERROR initialization cycle */ = x8pvar.m()
+var x8pv /* ERROR "initialization cycle" */ = x8pvar.m()
 
 // cycles through method values of embedded methods
 
 type T9 struct { E9 }
 type E9 int
 func (E9) m() int { _ = x9; return 0 }
-var x9 /* ERROR initialization cycle */ = T9{0}.m
+var x9 /* ERROR "initialization cycle" */ = T9{0}.m
 
 type T10 struct { E10 }
 type E10 int
 func (E10) m() int { _ = x10; return 0 }
-var x10 /* ERROR initialization cycle */ = T10{0}.m()
+var x10 /* ERROR "initialization cycle" */ = T10{0}.m()
 
 type T9p struct { E9p }
 type E9p int
 func (*E9p) m() int { _ = x9p; return 0 }
-var x9p /* ERROR initialization cycle */ = new(T9p).m
+var x9p /* ERROR "initialization cycle" */ = new(T9p).m
 
 type T10p struct { E10p }
 type E10p int
 func (*E10p) m() int { _ = x10p; return 0 }
-var x10p /* ERROR initialization cycle */ = new(T10p).m()
+var x10p /* ERROR "initialization cycle" */ = new(T10p).m()
 
 type T9v struct { E9v }
 type E9v int
 func (E9v) m() int { _ = x9v; return 0 }
 var x9var T9v
-var x9v /* ERROR initialization cycle */ = x9var.m
+var x9v /* ERROR "initialization cycle" */ = x9var.m
 
 type T10v struct { E10v }
 type E10v int
 func (E10v) m() int { _ = x10v; return 0 }
 var x10var T10v
-var x10v /* ERROR initialization cycle */ = x10var.m()
+var x10v /* ERROR "initialization cycle" */ = x10var.m()
 
 type T9pv struct { E9pv }
 type E9pv int
 func (*E9pv) m() int { _ = x9pv; return 0 }
 var x9pvar *T9pv
-var x9pv /* ERROR initialization cycle */ = x9pvar.m
+var x9pv /* ERROR "initialization cycle" */ = x9pvar.m
 
 type T10pv struct { E10pv }
 type E10pv int
 func (*E10pv) m() int { _ = x10pv; return 0 }
 var x10pvar *T10pv
-var x10pv /* ERROR initialization cycle */ = x10pvar.m()
+var x10pv /* ERROR "initialization cycle" */ = x10pvar.m()
diff --git a/src/internal/types/testdata/check/issues0.go b/src/internal/types/testdata/check/issues0.go
index 4a66641369..c8c92ba1ef 100644
--- a/src/internal/types/testdata/check/issues0.go
+++ b/src/internal/types/testdata/check/issues0.go
@@ -25,25 +25,25 @@ func issue7035() {
 func issue8066() {
 	const (
 		_ = float32(340282356779733661637539395458142568447)
-		_ = float32(340282356779733661637539395458142568448 /* ERROR cannot convert */ )
+		_ = float32(340282356779733661637539395458142568448 /* ERROR "cannot convert" */ )
 	)
 }
 
 // Check that a missing identifier doesn't lead to a spurious error cascade.
 func issue8799a() {
-	x, ok := missing /* ERROR undefined */ ()
+	x, ok := missing /* ERROR "undefined" */ ()
 	_ = !ok
 	_ = x
 }
 
 func issue8799b(x int, ok bool) {
-	x, ok = missing /* ERROR undefined */ ()
+	x, ok = missing /* ERROR "undefined" */ ()
 	_ = !ok
 	_ = x
 }
 
 func issue9182() {
-	type Point C /* ERROR undefined */ .Point
+	type Point C /* ERROR "undefined" */ .Point
 	// no error for composite literal based on unknown type
 	_ = Point{x: 1, y: 2}
 }
@@ -59,54 +59,54 @@ func issue9473(a []int, b ...int) {
 	_ = append(f0())
 	_ = append(f0(), f0()...)
 	_ = append(f1())
-	_ = append(f2 /* ERROR cannot use .* in argument */ ())
-	_ = append(f2()... /* ERROR cannot use ... */ )
-	_ = append(f0(), f1 /* ERROR multiple-value f1 */ ())
-	_ = append(f0(), f2 /* ERROR multiple-value f2 */ ())
-	_ = append(f0(), f1 /* ERROR multiple-value f1 */ ()...)
-	_ = append(f0(), f2 /* ERROR multiple-value f2 */ ()...)
+	_ = append(f2 /* ERROR "cannot use .* in argument" */ ())
+	_ = append(f2()... /* ERROR "cannot use ..." */ )
+	_ = append(f0(), f1 /* ERROR "multiple-value f1" */ ())
+	_ = append(f0(), f2 /* ERROR "multiple-value f2" */ ())
+	_ = append(f0(), f1 /* ERROR "multiple-value f1" */ ()...)
+	_ = append(f0(), f2 /* ERROR "multiple-value f2" */ ()...)
 
 	// variadic user-defined function
 	append_(f0())
 	append_(f0(), f0()...)
 	append_(f1())
-	append_(f2 /* ERROR cannot use .* in argument */ ())
-	append_(f2()... /* ERROR cannot use ... */ )
-	append_(f0(), f1 /* ERROR multiple-value f1 */ ())
-	append_(f0(), f2 /* ERROR multiple-value f2 */ ())
-	append_(f0(), f1 /* ERROR multiple-value f1 */ ()...)
-	append_(f0(), f2 /* ERROR multiple-value f2 */ ()...)
+	append_(f2 /* ERROR "cannot use .* in argument" */ ())
+	append_(f2()... /* ERROR "cannot use ..." */ )
+	append_(f0(), f1 /* ERROR "multiple-value f1" */ ())
+	append_(f0(), f2 /* ERROR "multiple-value f2" */ ())
+	append_(f0(), f1 /* ERROR "multiple-value f1" */ ()...)
+	append_(f0(), f2 /* ERROR "multiple-value f2" */ ()...)
 }
 
 // Check that embedding a non-interface type in an interface results in a good error message.
 func issue10979() {
 	type _ interface {
-		int /* ERROR non-interface type int */
+		int /* ERROR "non-interface type int" */
 	}
 	type T struct{}
 	type _ interface {
-		T /* ERROR non-interface type T */
+		T /* ERROR "non-interface type T" */
 	}
 	type _ interface {
-		nosuchtype /* ERROR undefined: nosuchtype */
+		nosuchtype /* ERROR "undefined: nosuchtype" */
 	}
 	type _ interface {
-		fmt.Nosuchtype /* ERROR undefined: fmt\.Nosuchtype */
+		fmt.Nosuchtype /* ERROR "undefined: fmt\.Nosuchtype" */
 	}
 	type _ interface {
-		nosuchpkg /* ERROR undefined: nosuchpkg */ .Nosuchtype
+		nosuchpkg /* ERROR "undefined: nosuchpkg" */ .Nosuchtype
 	}
 	type I interface {
-		I.m /* ERROR I.m is not a type */
+		I.m /* ERROR "I.m is not a type" */
 		m()
 	}
 }
 
 // issue11347
 // These should not crash.
-var a1, b1 /* ERROR cycle */ , c1 /* ERROR cycle */ b1 = 0 > 0<<""[""[c1]]>c1
-var a2, b2 /* ERROR cycle */ = 0 /* ERROR assignment mismatch */ /* ERROR assignment mismatch */ > 0<<""[b2]
-var a3, b3 /* ERROR cycle */ = int /* ERROR assignment mismatch */ /* ERROR assignment mismatch */ (1<<""[b3])
+var a1, b1 /* ERROR "cycle" */ , c1 /* ERROR "cycle" */ b1 = 0 > 0<<""[""[c1]]>c1
+var a2, b2 /* ERROR "cycle" */ = 0 /* ERROR "assignment mismatch" */ /* ERROR "assignment mismatch" */ > 0<<""[b2]
+var a3, b3 /* ERROR "cycle" */ = int /* ERROR "assignment mismatch" */ /* ERROR "assignment mismatch" */ (1<<""[b3])
 
 // issue10260
 // Check that error messages explain reason for interface assignment failures.
@@ -133,42 +133,42 @@ func issue10260() {
 	)
 
 	var x I1
-	x = T1 /* ERROR cannot use T1{} .* as I1 value in assignment: T1 does not implement I1 \(method foo has pointer receiver\) */ {}
-	_ = x /* ERROR impossible type assertion: x\.\(T1\)\n\tT1 does not implement I1 \(method foo has pointer receiver\) */ .(T1)
+	x = T1 /* ERROR "cannot use T1{} .* as I1 value in assignment: T1 does not implement I1 \(method foo has pointer receiver\)" */ {}
+	_ = x /* ERROR "impossible type assertion: x\.\(T1\)\n\tT1 does not implement I1 \(method foo has pointer receiver\)" */ .(T1)
 
-	T1{}.foo /* ERROR cannot call pointer method foo on T1 */ ()
+	T1{}.foo /* ERROR "cannot call pointer method foo on T1" */ ()
 	x.Foo /* ERROR "x.Foo undefined \(type I1 has no field or method Foo, but does have foo\)" */ ()
 
-	_ = i2 /* ERROR impossible type assertion: i2\.\(\*T1\)\n\t\*T1 does not implement I2 \(wrong type for method foo\)\n\t\thave foo\(\)\n\t\twant foo\(int\) */ .(*T1)
+	_ = i2 /* ERROR "impossible type assertion: i2\.\(\*T1\)\n\t\*T1 does not implement I2 \(wrong type for method foo\)\n\t\thave foo\(\)\n\t\twant foo\(int\)" */ .(*T1)
 
-	i1 = i0 /* ERROR cannot use i0 .* as I1 value in assignment: I0 does not implement I1 \(missing method foo\) */
-	i1 = t0 /* ERROR .* t0 .* as I1 .*: \*T0 does not implement I1 \(missing method foo\) */
-	i1 = i2 /* ERROR .* i2 .* as I1 .*: I2 does not implement I1 \(wrong type for method foo\)\n\t\thave foo\(int\)\n\t\twant foo\(\) */
-	i1 = t2 /* ERROR .* t2 .* as I1 .*: \*T2 does not implement I1 \(wrong type for method foo\)\n\t\thave foo\(int\)\n\t\twant foo\(\) */
-	i2 = i1 /* ERROR .* i1 .* as I2 .*: I1 does not implement I2 \(wrong type for method foo\)\n\t\thave foo\(\)\n\t\twant foo\(int\) */
-	i2 = t1 /* ERROR .* t1 .* as I2 .*: \*T1 does not implement I2 \(wrong type for method foo\)\n\t\thave foo\(\)\n\t\twant foo\(int\) */
+	i1 = i0 /* ERROR "cannot use i0 .* as I1 value in assignment: I0 does not implement I1 \(missing method foo\)" */
+	i1 = t0 /* ERROR ".* t0 .* as I1 .*: \*T0 does not implement I1 \(missing method foo\)" */
+	i1 = i2 /* ERROR ".* i2 .* as I1 .*: I2 does not implement I1 \(wrong type for method foo\)\n\t\thave foo\(int\)\n\t\twant foo\(\)" */
+	i1 = t2 /* ERROR ".* t2 .* as I1 .*: \*T2 does not implement I1 \(wrong type for method foo\)\n\t\thave foo\(int\)\n\t\twant foo\(\)" */
+	i2 = i1 /* ERROR ".* i1 .* as I2 .*: I1 does not implement I2 \(wrong type for method foo\)\n\t\thave foo\(\)\n\t\twant foo\(int\)" */
+	i2 = t1 /* ERROR ".* t1 .* as I2 .*: \*T1 does not implement I2 \(wrong type for method foo\)\n\t\thave foo\(\)\n\t\twant foo\(int\)" */
 
-	_ = func() I1 { return i0 /* ERROR cannot use i0 .* as I1 value in return statement: I0 does not implement I1 \(missing method foo\) */ }
-	_ = func() I1 { return t0 /* ERROR .* t0 .* as I1 .*: \*T0 does not implement I1 \(missing method foo\) */ }
-	_ = func() I1 { return i2 /* ERROR .* i2 .* as I1 .*: I2 does not implement I1 \(wrong type for method foo\)\n\t\thave foo\(int\)\n\t\twant foo\(\) */ }
-	_ = func() I1 { return t2 /* ERROR .* t2 .* as I1 .*: \*T2 does not implement I1 \(wrong type for method foo\)\n\t\thave foo\(int\)\n\t\twant foo\(\) */ }
-	_ = func() I2 { return i1 /* ERROR .* i1 .* as I2 .*: I1 does not implement I2 \(wrong type for method foo\)\n\t\thave foo\(\)\n\t\twant foo\(int\) */ }
-	_ = func() I2 { return t1 /* ERROR .* t1 .* as I2 .*: \*T1 does not implement I2 \(wrong type for method foo\)\n\t\thave foo\(\)\n\t\twant foo\(int\) */ }
+	_ = func() I1 { return i0 /* ERROR "cannot use i0 .* as I1 value in return statement: I0 does not implement I1 \(missing method foo\)" */ }
+	_ = func() I1 { return t0 /* ERROR ".* t0 .* as I1 .*: \*T0 does not implement I1 \(missing method foo\)" */ }
+	_ = func() I1 { return i2 /* ERROR ".* i2 .* as I1 .*: I2 does not implement I1 \(wrong type for method foo\)\n\t\thave foo\(int\)\n\t\twant foo\(\)" */ }
+	_ = func() I1 { return t2 /* ERROR ".* t2 .* as I1 .*: \*T2 does not implement I1 \(wrong type for method foo\)\n\t\thave foo\(int\)\n\t\twant foo\(\)" */ }
+	_ = func() I2 { return i1 /* ERROR ".* i1 .* as I2 .*: I1 does not implement I2 \(wrong type for method foo\)\n\t\thave foo\(\)\n\t\twant foo\(int\)" */ }
+	_ = func() I2 { return t1 /* ERROR ".* t1 .* as I2 .*: \*T1 does not implement I2 \(wrong type for method foo\)\n\t\thave foo\(\)\n\t\twant foo\(int\)" */ }
 
 	// a few more - less exhaustive now
 
 	f := func(I1, I2){}
-	f(i0 /* ERROR missing method foo */ , i1 /* ERROR wrong type for method foo */ )
+	f(i0 /* ERROR "missing method foo" */ , i1 /* ERROR "wrong type for method foo" */ )
 
-	_ = [...]I1{i0 /* ERROR cannot use i0 .* as I1 value in array or slice literal: I0 does not implement I1 \(missing method foo\) */ }
-	_ = [...]I1{i2 /* ERROR cannot use i2 .* as I1 value in array or slice literal: I2 does not implement I1 \(wrong type for method foo\)\n\t\thave foo\(int\)\n\t\twant foo\(\) */ }
-	_ = []I1{i0 /* ERROR missing method foo */ }
-	_ = []I1{i2 /* ERROR wrong type for method foo */ }
-	_ = map[int]I1{0: i0 /* ERROR missing method foo */ }
-	_ = map[int]I1{0: i2 /* ERROR wrong type for method foo */ }
+	_ = [...]I1{i0 /* ERROR "cannot use i0 .* as I1 value in array or slice literal: I0 does not implement I1 \(missing method foo\)" */ }
+	_ = [...]I1{i2 /* ERROR "cannot use i2 .* as I1 value in array or slice literal: I2 does not implement I1 \(wrong type for method foo\)\n\t\thave foo\(int\)\n\t\twant foo\(\)" */ }
+	_ = []I1{i0 /* ERROR "missing method foo" */ }
+	_ = []I1{i2 /* ERROR "wrong type for method foo" */ }
+	_ = map[int]I1{0: i0 /* ERROR "missing method foo" */ }
+	_ = map[int]I1{0: i2 /* ERROR "wrong type for method foo" */ }
 
-	make(chan I1) <- i0 /* ERROR missing method foo */
-	make(chan I1) <- i2 /* ERROR wrong type for method foo */
+	make(chan I1) <- i0 /* ERROR "missing method foo" */
+	make(chan I1) <- i2 /* ERROR "wrong type for method foo" */
 }
 
 // Check that constants representable as integers are in integer form
@@ -199,7 +199,7 @@ func issue15755() {
 	_ = x == y
 
 	// related: we should see an error since the result of f1 is ([]int, int)
-	var u, v []int = f1 /* ERROR cannot use f1 */ ()
+	var u, v []int = f1 /* ERROR "cannot use f1" */ ()
 	_ = u
 	_ = v
 }
@@ -240,7 +240,7 @@ func issue24026() {
 	// b and c must not be visible inside function literal
 	a := 0
 	a, b, c := func() (int, int, int) {
-		return a, b /* ERROR undefined */ , c /* ERROR undefined */
+		return a, b /* ERROR "undefined" */ , c /* ERROR "undefined" */
 	}()
 	_, _ = b, c
 }
@@ -260,10 +260,10 @@ func issue24140(x interface{}) int {
 
 // Test that we don't crash when the 'if' condition is missing.
 func issue25438() {
-	if { /* ERROR missing condition */ }
-	if x := 0; /* ERROR missing condition */ { _ = x }
+	if { /* ERROR "missing condition" */ }
+	if x := 0; /* ERROR "missing condition" */ { _ = x }
 	if
-	{ /* ERROR missing condition */ }
+	{ /* ERROR "missing condition" */ }
 }
 
 // Test that we can embed alias type names in interfaces.
@@ -277,12 +277,12 @@ type E = interface {
 
 // Test case from issue.
 // cmd/compile reports a cycle as well.
-type issue25301b /* ERROR invalid recursive type */ = interface {
+type issue25301b /* ERROR "invalid recursive type" */ = interface {
 	m() interface{ issue25301b }
 }
 
 type issue25301c interface {
-	notE // ERROR non-interface type struct\{\}
+	notE // ERROR "non-interface type struct\{\}"
 }
 
 type notE = struct{}
@@ -313,28 +313,28 @@ type allocator struct {
 
 // Test that we don't crash when type-checking composite literals
 // containing errors in the type.
-var issue27346 = [][n /* ERROR undefined */ ]int{
+var issue27346 = [][n /* ERROR "undefined" */ ]int{
 	0: {},
 }
 
-var issue22467 = map[int][... /* ERROR invalid use of ... */ ]int{0: {}}
+var issue22467 = map[int][... /* ERROR "invalid use of ..." */ ]int{0: {}}
 
 // Test that invalid use of ... in parameter lists is recognized
 // (issue #28281).
 func issue28281a(int, int, ...int)
 func issue28281b(a, b int, c ...int)
-func issue28281c(a, b, c ... /* ERROR can only use ... with final parameter */ int)
-func issue28281d(... /* ERROR can only use ... with final parameter */ int, int)
-func issue28281e(a, b, c  ... /* ERROR can only use ... with final parameter */ int, d int)
-func issue28281f(... /* ERROR can only use ... with final parameter */ int, ... /* ERROR can only use ... with final parameter */ int, int)
-func (... /* ERROR can only use ... with final parameter */ TT) f()
-func issue28281g() (... /* ERROR can only use ... with final parameter */ TT)
+func issue28281c(a, b, c ... /* ERROR "can only use ... with final parameter" */ int)
+func issue28281d(... /* ERROR "can only use ... with final parameter" */ int, int)
+func issue28281e(a, b, c  ... /* ERROR "can only use ... with final parameter" */ int, d int)
+func issue28281f(... /* ERROR "can only use ... with final parameter" */ int, ... /* ERROR "can only use ... with final parameter" */ int, int)
+func (... /* ERROR "can only use ... with final parameter" */ TT) f()
+func issue28281g() (... /* ERROR "can only use ... with final parameter" */ TT)
 
 // Issue #26234: Make various field/method lookup errors easier to read by matching cmd/compile's output
 func issue26234a(f *syn.Prog) {
 	// The error message below should refer to the actual package name (syntax)
 	// not the local package name (syn).
-	f.foo /* ERROR f\.foo undefined \(type \*syntax\.Prog has no field or method foo\) */
+	f.foo /* ERROR "f\.foo undefined \(type \*syntax\.Prog has no field or method foo\)" */
 }
 
 type T struct {
@@ -347,23 +347,23 @@ type E1 struct{ f int }
 type E2 struct{ f int }
 
 func issue26234b(x T) {
-	_ = x.f /* ERROR ambiguous selector x.f */
+	_ = x.f /* ERROR "ambiguous selector x.f" */
 }
 
 func issue26234c() {
-	T.x /* ERROR T.x undefined \(type T has no method x\) */ ()
+	T.x /* ERROR "T.x undefined \(type T has no method x\)" */ ()
 }
 
 func issue35895() {
 	// T is defined in this package, don't qualify its name with the package name.
-	var _ T = 0 // ERROR cannot use 0 \(untyped int constant\) as T
+	var _ T = 0 // ERROR "cannot use 0 \(untyped int constant\) as T"
 
 	// There is only one package with name syntax imported, only use the (global) package name in error messages.
-	var _ *syn.Prog = 0 // ERROR cannot use 0 \(untyped int constant\) as \*syntax.Prog
+	var _ *syn.Prog = 0 // ERROR "cannot use 0 \(untyped int constant\) as \*syntax.Prog"
 
 	// Because both t1 and t2 have the same global package name (template),
 	// qualify packages with full path name in this case.
-	var _ t1.Template = t2 /* ERROR cannot use .* \(value of type .html/template.\.Template\) as .text/template.\.Template */ .Template{}
+	var _ t1.Template = t2 /* ERROR "cannot use .* \(value of type .html/template.\.Template\) as .text/template.\.Template" */ .Template{}
 }
 
 func issue42989(s uint) {
diff --git a/src/internal/types/testdata/check/issues1.go b/src/internal/types/testdata/check/issues1.go
index 2f3414de61..efde922cd2 100644
--- a/src/internal/types/testdata/check/issues1.go
+++ b/src/internal/types/testdata/check/issues1.go
@@ -18,11 +18,11 @@ func eql[T comparable](x, y T) bool {
 func _[X comparable, Y interface{comparable; m()}]() {
 	var x X
 	var y Y
-	eql(x, y /* ERROR does not match */ ) // interfaces of different types
+	eql(x, y /* ERROR "does not match" */ ) // interfaces of different types
 	eql(x, x)
 	eql(y, y)
-	eql(y, nil /* ERROR cannot use nil as Y value in argument to eql */ )
-	eql[io /* ERROR does not satisfy comparable */ .Reader](nil, nil)
+	eql(y, nil /* ERROR "cannot use nil as Y value in argument to eql" */ )
+	eql[io /* ERROR "does not satisfy comparable" */ .Reader](nil, nil)
 }
 
 // If we have a receiver of pointer to type parameter type (below: *T)
@@ -33,12 +33,12 @@ type C[T any] interface {
 
 // using type bound C
 func _[T C[T]](x *T) {
-	x.m /* ERROR x\.m undefined */ ()
+	x.m /* ERROR "x\.m undefined" */ ()
 }
 
 // using an interface literal as bound
 func _[T interface{ m() }](x *T) {
-	x.m /* ERROR x\.m undefined */ ()
+	x.m /* ERROR "x\.m undefined" */ ()
 }
 
 func f2[_ interface{ m1(); m2() }]() {}
@@ -48,7 +48,7 @@ func (T) m1()
 func (*T) m2()
 
 func _() {
-	f2[T /* ERROR m2 has pointer receiver */ ]()
+	f2[T /* ERROR "m2 has pointer receiver" */ ]()
 	f2[*T]()
 }
 
@@ -58,7 +58,7 @@ func _() {
 type T1[P interface{~uint}] struct{}
 
 func _[P any]() {
-    _ = T1[P /* ERROR P does not satisfy interface{~uint} */ ]{}
+    _ = T1[P /* ERROR "P does not satisfy interface{~uint}" */ ]{}
 }
 
 // This is the original (simplified) program causing the same issue.
@@ -74,8 +74,8 @@ func (u T2[U]) Add1() U {
     return u.s + 1
 }
 
-func NewT2[U any]() T2[U /* ERROR U does not satisfy Unsigned */ ] {
-    return T2[U /* ERROR U does not satisfy Unsigned */ ]{}
+func NewT2[U any]() T2[U /* ERROR "U does not satisfy Unsigned" */ ] {
+    return T2[U /* ERROR "U does not satisfy Unsigned" */ ]{}
 }
 
 func _() {
@@ -145,8 +145,8 @@ type List3[TElem any] struct {
 }
 
 // Infinite generic type declarations must lead to an error.
-type inf1[T any] struct{ _ inf1 /* ERROR invalid recursive type */ [T] }
-type inf2[T any] struct{ inf2 /* ERROR invalid recursive type */ [T] }
+type inf1[T any] struct{ _ inf1 /* ERROR "invalid recursive type" */ [T] }
+type inf2[T any] struct{ inf2 /* ERROR "invalid recursive type" */ [T] }
 
 // The implementation of conversions T(x) between integers and floating-point
 // numbers checks that both T and x have either integer or floating-point
@@ -201,7 +201,7 @@ func _[T interface{~int}](x T) {
 // (Example by mdempsky@.)
 func _[T interface { ~[10]int }](x T) {
 	_ = x[9] // ok
-	_ = x[20 /* ERROR out of bounds */ ]
+	_ = x[20 /* ERROR "out of bounds" */ ]
 }
 
 // Pointer indirection of a type parameter.
@@ -248,5 +248,5 @@ var _ = append[context.CancelFunc, []context.CancelFunc, context.CancelFunc](can
 func g[T any](T) T { panic(0) }
 
 var _ = g[int]
-var _ = g[nil /* ERROR is not a type */ ]
+var _ = g[nil /* ERROR "is not a type" */ ]
 var _ = g(0)
diff --git a/src/internal/types/testdata/check/main0.go b/src/internal/types/testdata/check/main0.go
index 132a5fec45..95a8ed1d6d 100644
--- a/src/internal/types/testdata/check/main0.go
+++ b/src/internal/types/testdata/check/main0.go
@@ -5,5 +5,5 @@
 package main
 
 func main()
-func main /* ERROR "no arguments and no return values" */ /* ERROR redeclared */ (int)
-func main /* ERROR "no arguments and no return values" */ /* ERROR redeclared */ () int
+func main /* ERROR "no arguments and no return values" */ /* ERROR "redeclared" */ (int)
+func main /* ERROR "no arguments and no return values" */ /* ERROR "redeclared" */ () int
diff --git a/src/internal/types/testdata/check/map0.go b/src/internal/types/testdata/check/map0.go
index 814d9539fd..21c989cc9d 100644
--- a/src/internal/types/testdata/check/map0.go
+++ b/src/internal/types/testdata/check/map0.go
@@ -6,7 +6,7 @@
 package orderedmap
 
 // TODO(gri) fix imports for tests
-import "chans" // ERROR could not import
+import "chans" // ERROR "could not import"
 
 // Map is an ordered map.
 type Map[K, V any] struct {
diff --git a/src/internal/types/testdata/check/methodsets.go b/src/internal/types/testdata/check/methodsets.go
index d145bc09f5..27f6d31f88 100644
--- a/src/internal/types/testdata/check/methodsets.go
+++ b/src/internal/types/testdata/check/methodsets.go
@@ -29,7 +29,7 @@ type T3 struct {
 func _() {
 	var (
 		_ func(T0) = T0.v0
-		_ = T0.p0 /* ERROR invalid method expression T0\.p0 \(needs pointer receiver \(\*T0\)\.p0\) */
+		_ = T0.p0 /* ERROR "invalid method expression T0\.p0 \(needs pointer receiver \(\*T0\)\.p0\)" */
 
 		_ func (*T0) = (*T0).v0
 		_ func (*T0) = (*T0).p0
@@ -40,7 +40,7 @@ func _() {
 		_ func(T2) = T2.p2
 
 		_ func(T3) = T3.v0
-		_ func(T3) = T3.p0 /* ERROR invalid method expression T3\.p0 \(needs pointer receiver \(\*T3\)\.p0\) */
+		_ func(T3) = T3.p0 /* ERROR "invalid method expression T3\.p0 \(needs pointer receiver \(\*T3\)\.p0\)" */
 		_ func(T3) = T3.v1
 		_ func(T3) = T3.p1
 		_ func(T3) = T3.v2
diff --git a/src/internal/types/testdata/check/shifts.go b/src/internal/types/testdata/check/shifts.go
index 5cd0182d52..a9a3e34725 100644
--- a/src/internal/types/testdata/check/shifts.go
+++ b/src/internal/types/testdata/check/shifts.go
@@ -206,7 +206,7 @@ func shifts6() {
 	// _ = int(1.0<<s)
 	// _ = int(complex(1, 0)<<s)
 	_ = int(float32/* ERROR "must be integer" */(1.0) <<s)
-	_ = int(1.1 /* ERROR must be integer */ <<s)
+	_ = int(1.1 /* ERROR "must be integer" */ <<s)
 	_ = int(( /* ERROR "must be integer" */ 1+1i)  <<s)
 
 	_ = complex(1 /* ERROR "must be integer" */ <<s, 0)
@@ -382,7 +382,7 @@ func issue21727() {
 	var a = make([]int, 1<<s + 1.2 /* ERROR "truncated to int" */ )
 	var _ = a[1<<s - 2.3 /* ERROR "truncated to int" */ ]
 	var _ int = 1<<s + 3.4 /* ERROR "truncated to int" */
-	var _ = string(1 /* ERROR shifted operand 1 .* must be integer */ << s)
+	var _ = string(1 /* ERROR "shifted operand 1 .* must be integer" */ << s)
 	var _ = string(1.0 /* ERROR "cannot convert" */ << s)
 }
 
diff --git a/src/internal/types/testdata/check/slices.go b/src/internal/types/testdata/check/slices.go
index 2bacd1c2aa..2c3351850f 100644
--- a/src/internal/types/testdata/check/slices.go
+++ b/src/internal/types/testdata/check/slices.go
@@ -56,7 +56,7 @@ func reducer(x float64, y int) float64 {
 }
 
 var reduced1 = Reduce[int, float64](input, 0, reducer)
-var reduced2 = Reduce(input, 1i /* ERROR overflows */, reducer) // using type inference
+var reduced2 = Reduce(input, 1i /* ERROR "overflows" */, reducer) // using type inference
 var reduced3 = Reduce(input, 1, reducer) // using type inference
 
 func filter(x int) bool {
diff --git a/src/internal/types/testdata/check/stmt0.go b/src/internal/types/testdata/check/stmt0.go
index 3e8cb6836b..b41ab73c78 100644
--- a/src/internal/types/testdata/check/stmt0.go
+++ b/src/internal/types/testdata/check/stmt0.go
@@ -90,7 +90,7 @@ func assignments1() {
 
 	// assignments to _
 	_ = nil /* ERROR "use of untyped nil" */
-	_ = 1  << /* ERROR constant shift overflow */ 1000
+	_ = 1  << /* ERROR "constant shift overflow" */ 1000
 	(_) = 0
 }
 
@@ -108,23 +108,23 @@ func assignments2() {
 	s, b = m["foo"]
 	_, d = m["bar"]
 	m["foo"] = nil
-	m["foo"] = nil /* ERROR assignment mismatch: 1 variable but 2 values */ , false
+	m["foo"] = nil /* ERROR "assignment mismatch: 1 variable but 2 values" */ , false
 	_ = append(m["foo"])
 	_ = append(m["foo"], true)
 
 	var c chan int
 	_, b = <-c
 	_, d = <-c
-	<- /* ERROR cannot assign */ c = 0
-	<-c = 0 /* ERROR assignment mismatch: 1 variable but 2 values */ , false
+	<- /* ERROR "cannot assign" */ c = 0
+	<-c = 0 /* ERROR "assignment mismatch: 1 variable but 2 values" */ , false
 
 	var x interface{}
 	_, b = x.(int)
-	x /* ERROR cannot assign */ .(int) = 0
-	x.(int) = 0 /* ERROR assignment mismatch: 1 variable but 2 values */ , false
+	x /* ERROR "cannot assign" */ .(int) = 0
+	x.(int) = 0 /* ERROR "assignment mismatch: 1 variable but 2 values" */ , false
 
-	assignments2 /* ERROR used as value */ () = nil
-	int /* ERROR not an expression */ = 0
+	assignments2 /* ERROR "used as value" */ () = nil
+	int /* ERROR "not an expression" */ = 0
 }
 
 func issue6487() {
@@ -143,13 +143,13 @@ func issue6487() {
 }
 
 func issue6766a() {
-	a, a /* ERROR a repeated on left side of := */ := 1, 2
+	a, a /* ERROR "a repeated on left side of :=" */ := 1, 2
 	_ = a
-	a, b, b /* ERROR b repeated on left side of := */ := 1, 2, 3
+	a, b, b /* ERROR "b repeated on left side of :=" */ := 1, 2, 3
 	_ = b
-	c, c /* ERROR c repeated on left side of := */, b := 1, 2, 3
+	c, c /* ERROR "c repeated on left side of :=" */, b := 1, 2, 3
 	_ = c
-	a, b := /* ERROR no new variables */ 1, 2
+	a, b := /* ERROR "no new variables" */ 1, 2
 }
 
 func shortVarDecls1() {
@@ -212,8 +212,8 @@ func selects() {
 	select {
 	case a, b := <-ch:
 		_, b = a, b
-	case x /* ERROR send or receive */ :
-	case a /* ERROR send or receive */ := ch:
+	case x /* ERROR "send or receive" */ :
+	case a /* ERROR "send or receive" */ := ch:
 	}
 
 	// test for issue 9570: ch2 in second case falsely resolved to
@@ -222,7 +222,7 @@ func selects() {
 	ch2 := make(chan int)
 	select {
 	case <-ch1:
-		var ch2 /* ERROR ch2 declared and not used */ chan bool
+		var ch2 /* ERROR "ch2 declared and not used" */ chan bool
 	case i := <-ch2:
 		print(i + 1)
 	}
@@ -231,7 +231,7 @@ func selects() {
 func gos() {
 	go 1; /* ERROR "must be function call" */
 	go int /* ERROR "go requires function call, not conversion" */ (0)
-	go ( /* ERROR expression in go must not be parenthesized */ gos())
+	go ( /* ERROR "expression in go must not be parenthesized" */ gos())
 	go gos()
 	var c chan int
 	go close(c)
@@ -241,7 +241,7 @@ func gos() {
 func defers() {
 	defer 1; /* ERROR "must be function call" */
 	defer int /* ERROR "defer requires function call, not conversion" */ (0)
-	defer ( /* ERROR expression in defer must not be parenthesized */ defers())
+	defer ( /* ERROR "expression in defer must not be parenthesized" */ defers())
 	defer defers()
 	var c chan int
 	defer close(c)
@@ -377,24 +377,24 @@ func continues() {
 
 func returns0() {
 	return
-	return 0 /* ERROR too many return values */
+	return 0 /* ERROR "too many return values" */
 }
 
 func returns1(x float64) (int, *float64) {
 	return 0, &x
-	return /* ERROR not enough return values */
+	return /* ERROR "not enough return values" */
 	return "foo" /* ERROR "cannot .* in return statement" */, x /* ERROR "cannot use .* in return statement" */
-	return 0, &x, 1 /* ERROR too many return values */
+	return 0, &x, 1 /* ERROR "too many return values" */
 }
 
 func returns2() (a, b int) {
 	return
-	return 1, "foo" /* ERROR cannot use .* in return statement */
-	return 1, 2, 3 /* ERROR too many return values */
+	return 1, "foo" /* ERROR "cannot use .* in return statement" */
+	return 1, 2, 3 /* ERROR "too many return values" */
 	{
 		type a int
 		return 1, 2
-		return /* ERROR a not in scope at return */
+		return /* ERROR "a not in scope at return" */
 	}
 }
 
@@ -448,36 +448,36 @@ func switches0() {
 
 	switch uint64(x) {
 	case 1<<64 - 1:
-	case 1 /* ERROR duplicate case */ <<64 - 1:
+	case 1 /* ERROR "duplicate case" */ <<64 - 1:
 	case 2, 3, 4:
-	case 5, 1 /* ERROR duplicate case */ <<64 - 1:
+	case 5, 1 /* ERROR "duplicate case" */ <<64 - 1:
 	}
 
 	var y32 float32
 	switch y32 {
 	case 1.1:
 	case 11/10: // integer division!
-	case 11. /* ERROR duplicate case */ /10:
+	case 11. /* ERROR "duplicate case" */ /10:
 	case 2, 3.0, 4.1:
-	case 5.2, 1.10 /* ERROR duplicate case */ :
+	case 5.2, 1.10 /* ERROR "duplicate case" */ :
 	}
 
 	var y64 float64
 	switch y64 {
 	case 1.1:
 	case 11/10: // integer division!
-	case 11. /* ERROR duplicate case */ /10:
+	case 11. /* ERROR "duplicate case" */ /10:
 	case 2, 3.0, 4.1:
-	case 5.2, 1.10 /* ERROR duplicate case */ :
+	case 5.2, 1.10 /* ERROR "duplicate case" */ :
 	}
 
 	var s string
 	switch s {
 	case "foo":
-	case "foo" /* ERROR duplicate case */ :
-	case "f" /* ERROR duplicate case */ + "oo":
+	case "foo" /* ERROR "duplicate case" */ :
+	case "f" /* ERROR "duplicate case" */ + "oo":
 	case "abc", "def", "ghi":
-	case "jkl", "foo" /* ERROR duplicate case */ :
+	case "jkl", "foo" /* ERROR "duplicate case" */ :
 	}
 
 	type T int
@@ -492,14 +492,14 @@ func switches0() {
 	case (*int)(nil): // do duplicate detection
 	case 1:
 	case byte(1):
-	case int /* ERROR duplicate case */ (1):
+	case int /* ERROR "duplicate case" */ (1):
 	case T(1):
 	case 1.0:
 	case F(1.0):
-	case F /* ERROR duplicate case */ (1.0):
+	case F /* ERROR "duplicate case" */ (1.0):
 	case "hello":
 	case S("hello"):
-	case S /* ERROR duplicate case */ ("hello"):
+	case S /* ERROR "duplicate case" */ ("hello"):
 	case 1==1, B(false):
 	case false, B(2==2):
 	}
@@ -777,20 +777,20 @@ func typeswitch3(x interface{}) {
 	switch x.(type) {
 	case int:
 	case float64:
-	case int /* ERROR duplicate case */ :
+	case int /* ERROR "duplicate case" */ :
 	}
 
 	switch x.(type) {
 	case nil:
 	case int:
-	case nil /* ERROR duplicate case */ , nil /* ERROR duplicate case */ :
+	case nil /* ERROR "duplicate case" */ , nil /* ERROR "duplicate case" */ :
 	}
 
 	type F func(int)
 	switch x.(type) {
 	case nil:
 	case int, func(int):
-	case float32, func /* ERROR duplicate case */ (x int):
+	case float32, func /* ERROR "duplicate case" */ (x int):
 	case F:
 	}
 }
@@ -800,7 +800,7 @@ func fors1() {
 	var i string
 	_ = i
 	for i := 0; i < 10; i++ {}
-	for i := 0; i < 10; j /* ERROR cannot declare */ := 0 {}
+	for i := 0; i < 10; j /* ERROR "cannot declare" */ := 0 {}
 }
 
 func rangeloops1() {
@@ -925,39 +925,39 @@ func rangeloops2() {
 	var a [10]int
 	var i I
 	_ = i
-	for i /* ERROR cannot use .* in assignment */ = range a {}
-	for i /* ERROR cannot use .* in assignment */ = range &a {}
-	for i /* ERROR cannot use .* in assignment */ = range a[:] {}
+	for i /* ERROR "cannot use .* in assignment" */ = range a {}
+	for i /* ERROR "cannot use .* in assignment" */ = range &a {}
+	for i /* ERROR "cannot use .* in assignment" */ = range a[:] {}
 
 	var s string
 	var r R
 	_ = r
-	for i /* ERROR cannot use .* in assignment */ = range s {}
-	for i /* ERROR cannot use .* in assignment */ = range "foo" {}
-	for _, r /* ERROR cannot use .* in assignment */ = range s {}
-	for _, r /* ERROR cannot use .* in assignment */ = range "foo" {}
+	for i /* ERROR "cannot use .* in assignment" */ = range s {}
+	for i /* ERROR "cannot use .* in assignment" */ = range "foo" {}
+	for _, r /* ERROR "cannot use .* in assignment" */ = range s {}
+	for _, r /* ERROR "cannot use .* in assignment" */ = range "foo" {}
 }
 
 func issue6766b() {
-	for _ := /* ERROR no new variables */ range "" {}
-	for a, a /* ERROR redeclared */ := range "" { _ = a }
+	for _ := /* ERROR "no new variables" */ range "" {}
+	for a, a /* ERROR "redeclared" */ := range "" { _ = a }
 	var a int
 	_ = a
-	for a, a /* ERROR redeclared */ := range []int{1, 2, 3} { _ = a }
+	for a, a /* ERROR "redeclared" */ := range []int{1, 2, 3} { _ = a }
 }
 
 // Test that despite errors in the range clause,
 // the loop body is still type-checked (and thus
 // errors reported).
 func issue10148() {
-	for y /* ERROR declared and not used */ := range "" {
-		_ = "" /* ERROR mismatched types untyped string and untyped int */ + 1
+	for y /* ERROR "declared and not used" */ := range "" {
+		_ = "" /* ERROR "mismatched types untyped string and untyped int" */ + 1
 	}
-	for range 1 /* ERROR cannot range over 1 */ {
-		_ = "" /* ERROR mismatched types untyped string and untyped int */ + 1
+	for range 1 /* ERROR "cannot range over 1" */ {
+		_ = "" /* ERROR "mismatched types untyped string and untyped int" */ + 1
 	}
-	for y := range 1 /* ERROR cannot range over 1 */ {
-		_ = "" /* ERROR mismatched types untyped string and untyped int */ + 1
+	for y := range 1 /* ERROR "cannot range over 1" */ {
+		_ = "" /* ERROR "mismatched types untyped string and untyped int" */ + 1
 	}
 }
 
diff --git a/src/internal/types/testdata/check/typeinference.go b/src/internal/types/testdata/check/typeinference.go
index 28f3e286b7..17447c4ed1 100644
--- a/src/internal/types/testdata/check/typeinference.go
+++ b/src/internal/types/testdata/check/typeinference.go
@@ -9,20 +9,20 @@ package typeInference
 // basic inference
 type Tb[P ~*Q, Q any] int
 func _() {
-	var x Tb /* ERROR got 1 arguments */ [*int]
+	var x Tb /* ERROR "got 1 arguments" */ [*int]
 	var y Tb[*int, int]
-	x = y /* ERROR cannot use y .* in assignment */
+	x = y /* ERROR "cannot use y .* in assignment" */
 	_ = x
 }
 
 // recursive inference
 type Tr[A any, B *C, C *D, D *A] int
 func _() {
-	var x Tr /* ERROR got 1 arguments */ [string]
+	var x Tr /* ERROR "got 1 arguments" */ [string]
 	var y Tr[string, ***string, **string, *string]
 	var z Tr[int, ***int, **int, *int]
-	x = y /* ERROR cannot use y .* in assignment */
-	x = z // ERROR cannot use z .* as Tr
+	x = y /* ERROR "cannot use y .* in assignment" */
+	x = z // ERROR "cannot use z .* as Tr"
 	_ = x
 }
 
@@ -33,17 +33,17 @@ type To2[A any, B [][]A] int
 type To3[A any, B [3]*A] int
 type To4[A any, B any, C struct{a A; b B}] int
 func _() {
-	var _ To0 /* ERROR got 1 arguments */ [int]
-	var _ To1 /* ERROR got 1 arguments */ [int]
-	var _ To2 /* ERROR got 1 arguments */ [int]
-	var _ To3 /* ERROR got 1 arguments */ [int]
-	var _ To4 /* ERROR got 2 arguments */ [int, string]
+	var _ To0 /* ERROR "got 1 arguments" */ [int]
+	var _ To1 /* ERROR "got 1 arguments" */ [int]
+	var _ To2 /* ERROR "got 1 arguments" */ [int]
+	var _ To3 /* ERROR "got 1 arguments" */ [int]
+	var _ To4 /* ERROR "got 2 arguments" */ [int, string]
 }
 
 // failed inference
 type Tf0[A, B any] int
 type Tf1[A any, B ~struct{a A; c C}, C any] int
 func _() {
-	var _ Tf0 /* ERROR got 1 arguments but 2 type parameters */ [int]
-	var _ Tf1 /* ERROR got 1 arguments but 3 type parameters */ [int]
+	var _ Tf0 /* ERROR "got 1 arguments but 2 type parameters" */ [int]
+	var _ Tf1 /* ERROR "got 1 arguments but 3 type parameters" */ [int]
 }
diff --git a/src/internal/types/testdata/check/typeinst0.go b/src/internal/types/testdata/check/typeinst0.go
index c21cb53d0c..0f62283f02 100644
--- a/src/internal/types/testdata/check/typeinst0.go
+++ b/src/internal/types/testdata/check/typeinst0.go
@@ -9,7 +9,7 @@ type myInt int
 // Parameterized type declarations
 
 // For now, a lone type parameter is not permitted as RHS in a type declaration (issue #45639).
-type T1[P any] P // ERROR cannot use a type parameter as RHS in type declaration
+type T1[P any] P // ERROR "cannot use a type parameter as RHS in type declaration"
 
 type T2[P any] struct {
         f P
@@ -20,11 +20,11 @@ type List[P any] []P
 
 // Alias type declarations cannot have type parameters.
 // Issue #46477 proposses to change that.
-type A1[P any] = /* ERROR cannot be alias */ struct{}
+type A1[P any] = /* ERROR "cannot be alias" */ struct{}
 
 // Pending clarification of #46477 we disallow aliases
 // of generic types.
-type A2 = List // ERROR cannot use generic type
+type A2 = List // ERROR "cannot use generic type"
 var _ A2[int]
 var _ A2
 
@@ -34,15 +34,15 @@ var _ A3
 // Parameterized type instantiations
 
 var x int
-type _ x /* ERROR not a type */ [int]
+type _ x /* ERROR "not a type" */ [int]
 
-type _ int /* ERROR not a generic type */ [] // ERROR expected type argument list
-type _ myInt /* ERROR not a generic type */ [] // ERROR expected type argument list
+type _ int /* ERROR "not a generic type" */ [] // ERROR "expected type argument list"
+type _ myInt /* ERROR "not a generic type" */ [] // ERROR "expected type argument list"
 
 // TODO(gri) better error messages
-type _ T1[] // ERROR expected type argument list
-type _ T1[x /* ERROR not a type */ ]
-type _ T1 /* ERROR got 2 arguments but 1 type parameters */ [int, float32]
+type _ T1[] // ERROR "expected type argument list"
+type _ T1[x /* ERROR "not a type" */ ]
+type _ T1 /* ERROR "got 2 arguments but 1 type parameters" */ [int, float32]
 
 var _ T2[int] = T2[int]{}
 
@@ -58,5 +58,5 @@ var _ T3[int] = T3[int](List[int]{1, 2, 3})
 
 // Self-recursive generic types are not permitted
 
-type self1[P any] self1 /* ERROR invalid recursive type */ [P]
+type self1[P any] self1 /* ERROR "invalid recursive type" */ [P]
 type self2[P any] *self2[P] // this is ok
diff --git a/src/internal/types/testdata/check/typeinst1.go b/src/internal/types/testdata/check/typeinst1.go
index e7bb247941..63de79a4a0 100644
--- a/src/internal/types/testdata/check/typeinst1.go
+++ b/src/internal/types/testdata/check/typeinst1.go
@@ -163,13 +163,13 @@ type _ interface {
 
 // Type sets may contain each type at most once.
 type _ interface {
-	~int|~ /* ERROR overlapping terms ~int */ int
-	~int|int /* ERROR overlapping terms int */
-	int|int /* ERROR overlapping terms int */
+	~int|~ /* ERROR "overlapping terms ~int" */ int
+	~int|int /* ERROR "overlapping terms int" */
+	int|int /* ERROR "overlapping terms int" */
 }
 
 type _ interface {
-	~struct{f int} | ~struct{g int} | ~ /* ERROR overlapping terms */ struct{f int}
+	~struct{f int} | ~struct{g int} | ~ /* ERROR "overlapping terms" */ struct{f int}
 }
 
 // Interface term lists can contain any type, incl. *Named types.
@@ -210,7 +210,7 @@ func f0[T I0]() {}
 var _ = f0[int]
 var _ = f0[bool]
 var _ = f0[string]
-var _ = f0[float64 /* ERROR does not satisfy I0 */ ]
+var _ = f0[float64 /* ERROR "does not satisfy I0" */ ]
 
 type I01 interface {
 	E0
@@ -219,9 +219,9 @@ type I01 interface {
 
 func f01[T I01]() {}
 var _ = f01[int]
-var _ = f01[bool /* ERROR does not satisfy I0 */ ]
+var _ = f01[bool /* ERROR "does not satisfy I0" */ ]
 var _ = f01[string]
-var _ = f01[float64 /* ERROR does not satisfy I0 */ ]
+var _ = f01[float64 /* ERROR "does not satisfy I0" */ ]
 
 type I012 interface {
 	E0
@@ -230,10 +230,10 @@ type I012 interface {
 }
 
 func f012[T I012]() {}
-var _ = f012[int /* ERROR cannot satisfy I012.*empty type set */ ]
-var _ = f012[bool /* ERROR cannot satisfy I012.*empty type set */ ]
-var _ = f012[string /* ERROR cannot satisfy I012.*empty type set */ ]
-var _ = f012[float64 /* ERROR cannot satisfy I012.*empty type set */ ]
+var _ = f012[int /* ERROR "cannot satisfy I012.*empty type set" */ ]
+var _ = f012[bool /* ERROR "cannot satisfy I012.*empty type set" */ ]
+var _ = f012[string /* ERROR "cannot satisfy I012.*empty type set" */ ]
+var _ = f012[float64 /* ERROR "cannot satisfy I012.*empty type set" */ ]
 
 type I12 interface {
 	E1
@@ -241,9 +241,9 @@ type I12 interface {
 }
 
 func f12[T I12]() {}
-var _ = f12[int /* ERROR does not satisfy I12 */ ]
-var _ = f12[bool /* ERROR does not satisfy I12 */ ]
-var _ = f12[string /* ERROR does not satisfy I12 */ ]
+var _ = f12[int /* ERROR "does not satisfy I12" */ ]
+var _ = f12[bool /* ERROR "does not satisfy I12" */ ]
+var _ = f12[string /* ERROR "does not satisfy I12" */ ]
 var _ = f12[float64]
 
 type I0_ interface {
@@ -253,13 +253,13 @@ type I0_ interface {
 
 func f0_[T I0_]() {}
 var _ = f0_[int]
-var _ = f0_[bool /* ERROR does not satisfy I0_ */ ]
-var _ = f0_[string /* ERROR does not satisfy I0_ */ ]
-var _ = f0_[float64 /* ERROR does not satisfy I0_ */ ]
+var _ = f0_[bool /* ERROR "does not satisfy I0_" */ ]
+var _ = f0_[string /* ERROR "does not satisfy I0_" */ ]
+var _ = f0_[float64 /* ERROR "does not satisfy I0_" */ ]
 
 // Using a function instance as a type is an error.
-var _ f0 // ERROR not a type
-var _ f0 /* ERROR not a type */ [int]
+var _ f0 // ERROR "not a type"
+var _ f0 /* ERROR "not a type" */ [int]
 
 // Empty type sets can only be satisfied by empty type sets.
 type none interface {
@@ -273,7 +273,7 @@ func gg[T any]() {}
 func hh[T ~int]() {}
 
 func _[T none]() {
-	_ = ff[int /* ERROR cannot satisfy none \(empty type set\) */ ]
+	_ = ff[int /* ERROR "cannot satisfy none \(empty type set\)" */ ]
 	_ = ff[T]  // pathological but ok because T's type set is empty, too
 	_ = gg[int]
 	_ = gg[T]
diff --git a/src/internal/types/testdata/check/typeparams.go b/src/internal/types/testdata/check/typeparams.go
index 0e440d8e6f..bf18895dc4 100644
--- a/src/internal/types/testdata/check/typeparams.go
+++ b/src/internal/types/testdata/check/typeparams.go
@@ -14,8 +14,8 @@ func _[_ any, _ interface{any}](any) {
 func identity[T any](x T) T { return x }
 
 func _[_ any](x int) int { panic(0) }
-func _[T any](T /* ERROR redeclared */ T)() {}
-func _[T, T /* ERROR redeclared */ any]() {}
+func _[T any](T /* ERROR "redeclared" */ T)() {}
+func _[T, T /* ERROR "redeclared" */ any]() {}
 
 // Constraints (incl. any) may be parenthesized.
 func _[_ (any)]() {}
@@ -31,15 +31,15 @@ func reverse[T any](list []T) []T {
         return rlist
 }
 
-var _ = reverse /* ERROR cannot use generic function reverse */
-var _ = reverse[int, float32 /* ERROR got 2 type arguments */ ] ([]int{1, 2, 3})
-var _ = reverse[int]([ /* ERROR cannot use */ ]float32{1, 2, 3})
+var _ = reverse /* ERROR "cannot use generic function reverse" */
+var _ = reverse[int, float32 /* ERROR "got 2 type arguments" */ ] ([]int{1, 2, 3})
+var _ = reverse[int]([ /* ERROR "cannot use" */ ]float32{1, 2, 3})
 var f = reverse[chan int]
-var _ = f(0 /* ERROR cannot use 0 .* as \[\]chan int */ )
+var _ = f(0 /* ERROR "cannot use 0 .* as \[\]chan int" */ )
 
 func swap[A, B any](a A, b B) (B, A) { return b, a }
 
-var _ = swap /* ERROR multiple-value */ [int, float32](1, 2)
+var _ = swap /* ERROR "multiple-value" */ [int, float32](1, 2)
 var f32, i = swap[int, float32](swap[float32, int](1, 2))
 var _ float32 = f32
 var _ int = i
@@ -58,10 +58,10 @@ func min[T interface{ ~int }](x, y T) T {
 }
 
 func _[T interface{~int | ~float32}](x, y T) bool { return x < y }
-func _[T any](x, y T) bool { return x /* ERROR type parameter T is not comparable */ < y }
-func _[T interface{~int | ~float32 | ~bool}](x, y T) bool { return x /* ERROR type parameter T is not comparable */ < y }
+func _[T any](x, y T) bool { return x /* ERROR "type parameter T is not comparable" */ < y }
+func _[T interface{~int | ~float32 | ~bool}](x, y T) bool { return x /* ERROR "type parameter T is not comparable" */ < y }
 
-func _[T C1[T]](x, y T) bool { return x /* ERROR type parameter T is not comparable */ < y }
+func _[T C1[T]](x, y T) bool { return x /* ERROR "type parameter T is not comparable" */ < y }
 func _[T C2[T]](x, y T) bool { return x < y }
 
 type C1[T any] interface{}
@@ -72,16 +72,16 @@ func new[T any]() *T {
         return &x
 }
 
-var _ = new /* ERROR cannot use generic function new */
+var _ = new /* ERROR "cannot use generic function new" */
 var _ *int = new[int]()
 
-func _[T any](map[T /* ERROR invalid map key type T \(missing comparable constraint\) */]int) {} // w/o constraint we don't know if T is comparable
+func _[T any](map[T /* ERROR "invalid map key type T \(missing comparable constraint\)" */]int) {} // w/o constraint we don't know if T is comparable
 
-func f1[T1 any](struct{T1 /* ERROR cannot be a .* type parameter */ }) int { panic(0) }
+func f1[T1 any](struct{T1 /* ERROR "cannot be a .* type parameter" */ }) int { panic(0) }
 var _ = f1[int](struct{T1}{})
 type T1 = int
 
-func f2[t1 any](struct{t1 /* ERROR cannot be a .* type parameter */ ; x float32}) int { panic(0) }
+func f2[t1 any](struct{t1 /* ERROR "cannot be a .* type parameter" */ ; x float32}) int { panic(0) }
 var _ = f2[t1](struct{t1; x float32}{})
 type t1 = int
 
@@ -96,29 +96,29 @@ func _[T any] (x T, i int) { _ = x /* ERROR "cannot index" */ [i] }
 func _[T interface{ ~int }] (x T, i int) { _ = x /* ERROR "cannot index" */ [i] }
 func _[T interface{ ~string }] (x T, i int) { _ = x[i] }
 func _[T interface{ ~[]int }] (x T, i int) { _ = x[i] }
-func _[T interface{ ~[10]int | ~*[20]int | ~map[int]int }] (x T, i int) { _ = x /* ERROR cannot index */ [i] } // map and non-map types
+func _[T interface{ ~[10]int | ~*[20]int | ~map[int]int }] (x T, i int) { _ = x /* ERROR "cannot index" */ [i] } // map and non-map types
 func _[T interface{ ~string | ~[]byte }] (x T, i int) { _ = x[i] }
 func _[T interface{ ~[]int | ~[1]rune }] (x T, i int) { _ = x /* ERROR "cannot index" */ [i] }
 func _[T interface{ ~string | ~[]rune }] (x T, i int) { _ = x /* ERROR "cannot index" */ [i] }
 
 // indexing with various combinations of map types in type sets (see issue #42616)
-func _[T interface{ ~[]E | ~map[int]E }, E any](x T, i int) { _ = x /* ERROR cannot index */ [i] } // map and non-map types
+func _[T interface{ ~[]E | ~map[int]E }, E any](x T, i int) { _ = x /* ERROR "cannot index" */ [i] } // map and non-map types
 func _[T interface{ ~[]E }, E any](x T, i int) { _ = &x[i] }
 func _[T interface{ ~map[int]E }, E any](x T, i int) { _, _ = x[i] } // comma-ok permitted
-func _[T interface{ ~map[int]E }, E any](x T, i int) { _ = &x /* ERROR cannot take address */ [i] }
-func _[T interface{ ~map[int]E | ~map[uint]E }, E any](x T, i int) { _ = x /* ERROR cannot index */ [i] } // different map element types
-func _[T interface{ ~[]E | ~map[string]E }, E any](x T, i int) { _ = x /* ERROR cannot index */ [i] } // map and non-map types
+func _[T interface{ ~map[int]E }, E any](x T, i int) { _ = &x /* ERROR "cannot take address" */ [i] }
+func _[T interface{ ~map[int]E | ~map[uint]E }, E any](x T, i int) { _ = x /* ERROR "cannot index" */ [i] } // different map element types
+func _[T interface{ ~[]E | ~map[string]E }, E any](x T, i int) { _ = x /* ERROR "cannot index" */ [i] } // map and non-map types
 
 // indexing with various combinations of array and other types in type sets
-func _[T interface{ [10]int }](x T, i int) { _ = x[i]; _ = x[9]; _ = x[10 /* ERROR out of bounds */ ] }
-func _[T interface{ [10]byte | string }](x T, i int) { _ = x[i]; _ = x[9]; _ = x[10 /* ERROR out of bounds */ ] }
-func _[T interface{ [10]int | *[20]int | []int }](x T, i int) { _ = x[i]; _ = x[9]; _ = x[10 /* ERROR out of bounds */ ] }
+func _[T interface{ [10]int }](x T, i int) { _ = x[i]; _ = x[9]; _ = x[10 /* ERROR "out of bounds" */ ] }
+func _[T interface{ [10]byte | string }](x T, i int) { _ = x[i]; _ = x[9]; _ = x[10 /* ERROR "out of bounds" */ ] }
+func _[T interface{ [10]int | *[20]int | []int }](x T, i int) { _ = x[i]; _ = x[9]; _ = x[10 /* ERROR "out of bounds" */ ] }
 
 // indexing with strings and non-variable arrays (assignment not permitted)
-func _[T string](x T) { _ = x[0]; x /* ERROR cannot assign */ [0] = 0 }
-func _[T []byte | string](x T) { x /* ERROR cannot assign */ [0] = 0 }
-func _[T [10]byte]() { f := func() (x T) { return }; f /* ERROR cannot assign */ ()[0] = 0 }
-func _[T [10]byte]() { f := func() (x *T) { return }; f /* ERROR cannot index */ ()[0] = 0 }
+func _[T string](x T) { _ = x[0]; x /* ERROR "cannot assign" */ [0] = 0 }
+func _[T []byte | string](x T) { x /* ERROR "cannot assign" */ [0] = 0 }
+func _[T [10]byte]() { f := func() (x T) { return }; f /* ERROR "cannot assign" */ ()[0] = 0 }
+func _[T [10]byte]() { f := func() (x *T) { return }; f /* ERROR "cannot index" */ ()[0] = 0 }
 func _[T [10]byte]() { f := func() (x *T) { return }; (*f())[0] = 0 }
 func _[T *[10]byte]() { f := func() (x T) { return }; f()[0] = 0 }
 
@@ -129,22 +129,22 @@ func _[T interface{ ~[10]E }, E any] (x T, i, j, k int) { var _ []E = x[i:j:k] }
 func _[T interface{ ~[]byte }] (x T, i, j, k int) { var _ T = x[i:j] }
 func _[T interface{ ~[]byte }] (x T, i, j, k int) { var _ T = x[i:j:k] }
 func _[T interface{ ~string }] (x T, i, j, k int) { var _ T = x[i:j] }
-func _[T interface{ ~string }] (x T, i, j, k int) { var _ T = x[i:j:k /* ERROR 3-index slice of string */ ] }
+func _[T interface{ ~string }] (x T, i, j, k int) { var _ T = x[i:j:k /* ERROR "3-index slice of string" */ ] }
 
 type myByte1 []byte
 type myByte2 []byte
 func _[T interface{ []byte | myByte1 | myByte2 }] (x T, i, j, k int) { var _ T = x[i:j:k] }
-func _[T interface{ []byte | myByte1 | []int }] (x T, i, j, k int) { var _ T = x /* ERROR no core type */ [i:j:k] }
+func _[T interface{ []byte | myByte1 | []int }] (x T, i, j, k int) { var _ T = x /* ERROR "no core type" */ [i:j:k] }
 
 func _[T interface{ []byte | myByte1 | myByte2 | string }] (x T, i, j, k int) { var _ T = x[i:j] }
-func _[T interface{ []byte | myByte1 | myByte2 | string }] (x T, i, j, k int) { var _ T = x[i:j:k /* ERROR 3-index slice of string */ ] }
-func _[T interface{ []byte | myByte1 | []int | string }] (x T, i, j, k int) { var _ T = x /* ERROR no core type */ [i:j] }
+func _[T interface{ []byte | myByte1 | myByte2 | string }] (x T, i, j, k int) { var _ T = x[i:j:k /* ERROR "3-index slice of string" */ ] }
+func _[T interface{ []byte | myByte1 | []int | string }] (x T, i, j, k int) { var _ T = x /* ERROR "no core type" */ [i:j] }
 
 // len/cap built-ins
 
-func _[T any](x T) { _ = len(x /* ERROR invalid argument */ ) }
-func _[T interface{ ~int }](x T) { _ = len(x /* ERROR invalid argument */ ) }
-func _[T interface{ ~string | ~[]byte | ~int }](x T) { _ = len(x /* ERROR invalid argument */ ) }
+func _[T any](x T) { _ = len(x /* ERROR "invalid argument" */ ) }
+func _[T interface{ ~int }](x T) { _ = len(x /* ERROR "invalid argument" */ ) }
+func _[T interface{ ~string | ~[]byte | ~int }](x T) { _ = len(x /* ERROR "invalid argument" */ ) }
 func _[T interface{ ~string }](x T) { _ = len(x) }
 func _[T interface{ ~[10]int }](x T) { _ = len(x) }
 func _[T interface{ ~[]byte }](x T) { _ = len(x) }
@@ -152,20 +152,20 @@ func _[T interface{ ~map[int]int }](x T) { _ = len(x) }
 func _[T interface{ ~chan int }](x T) { _ = len(x) }
 func _[T interface{ ~string | ~[]byte | ~chan int }](x T) { _ = len(x) }
 
-func _[T any](x T) { _ = cap(x /* ERROR invalid argument */ ) }
-func _[T interface{ ~int }](x T) { _ = cap(x /* ERROR invalid argument */ ) }
-func _[T interface{ ~string | ~[]byte | ~int }](x T) { _ = cap(x /* ERROR invalid argument */ ) }
-func _[T interface{ ~string }](x T) { _ = cap(x /* ERROR invalid argument */ ) }
+func _[T any](x T) { _ = cap(x /* ERROR "invalid argument" */ ) }
+func _[T interface{ ~int }](x T) { _ = cap(x /* ERROR "invalid argument" */ ) }
+func _[T interface{ ~string | ~[]byte | ~int }](x T) { _ = cap(x /* ERROR "invalid argument" */ ) }
+func _[T interface{ ~string }](x T) { _ = cap(x /* ERROR "invalid argument" */ ) }
 func _[T interface{ ~[10]int }](x T) { _ = cap(x) }
 func _[T interface{ ~[]byte }](x T) { _ = cap(x) }
-func _[T interface{ ~map[int]int }](x T) { _ = cap(x /* ERROR invalid argument */ ) }
+func _[T interface{ ~map[int]int }](x T) { _ = cap(x /* ERROR "invalid argument" */ ) }
 func _[T interface{ ~chan int }](x T) { _ = cap(x) }
 func _[T interface{ ~[]byte | ~chan int }](x T) { _ = cap(x) }
 
 // range iteration
 
 func _[T interface{}](x T) {
-        for range x /* ERROR cannot range */ {}
+        for range x /* ERROR "cannot range" */ {}
 }
 
 type myString string
@@ -206,18 +206,18 @@ func _[
         var c0 chan int
         for range c0 {}
         for _ = range c0 {}
-        for _, _ /* ERROR permits only one iteration variable */ = range c0 {}
+        for _, _ /* ERROR "permits only one iteration variable" */ = range c0 {}
 
         var c1 C1
         for range c1 {}
         for _ = range c1 {}
-        for _, _ /* ERROR permits only one iteration variable */ = range c1 {}
+        for _, _ /* ERROR "permits only one iteration variable" */ = range c1 {}
 
         var c2 C2
         for range c2 {}
 
         var c3 C3
-        for range c3 /* ERROR receive from send-only channel */ {}
+        for range c3 /* ERROR "receive from send-only channel" */ {}
 
         var s0 []int
         for range s0 {}
@@ -230,7 +230,7 @@ func _[
         for _, _ = range s1 {}
 
         var s2 S2
-        for range s2 /* ERROR cannot range over s2.*no core type */ {}
+        for range s2 /* ERROR "cannot range over s2.*no core type" */ {}
 
         var a0 []int
         for range a0 {}
@@ -243,7 +243,7 @@ func _[
         for _, _ = range a1 {}
 
         var a2 A2
-        for range a2 /* ERROR cannot range over a2.*no core type */ {}
+        for range a2 /* ERROR "cannot range over a2.*no core type" */ {}
 
         var p0 *[10]int
         for range p0 {}
@@ -256,7 +256,7 @@ func _[
         for _, _ = range p1 {}
 
         var p2 P2
-        for range p2 /* ERROR cannot range over p2.*no core type */ {}
+        for range p2 /* ERROR "cannot range over p2.*no core type" */ {}
 
         var m0 map[string]int
         for range m0 {}
@@ -269,22 +269,22 @@ func _[
         for _, _ = range m1 {}
 
         var m2 M2
-        for range m2 /* ERROR cannot range over m2.*no core type */ {}
+        for range m2 /* ERROR "cannot range over m2.*no core type" */ {}
 }
 
 // type inference checks
 
-var _ = new /* ERROR cannot infer T */ ()
+var _ = new /* ERROR "cannot infer T" */ ()
 
 func f4[A, B, C any](A, B) C { panic(0) }
 
-var _ = f4 /* ERROR cannot infer C */ (1, 2)
+var _ = f4 /* ERROR "cannot infer C" */ (1, 2)
 var _ = f4[int, float32, complex128](1, 2)
 
 func f5[A, B, C any](A, []*B, struct{f []C}) int { panic(0) }
 
 var _ = f5[int, float32, complex128](0, nil, struct{f []complex128}{})
-var _ = f5 /* ERROR cannot infer */ (0, nil, struct{f []complex128}{})
+var _ = f5 /* ERROR "cannot infer" */ (0, nil, struct{f []complex128}{})
 var _ = f5(0, []*float32{new[float32]()}, struct{f []complex128}{})
 
 func f6[A any](A, []A) int { panic(0) }
@@ -293,29 +293,29 @@ var _ = f6(0, nil)
 
 func f6nil[A any](A) int { panic(0) }
 
-var _ = f6nil /* ERROR cannot infer */ (nil)
+var _ = f6nil /* ERROR "cannot infer" */ (nil)
 
 // type inference with variadic functions
 
 func f7[T any](...T) T { panic(0) }
 
-var _ int = f7 /* ERROR cannot infer T */ ()
+var _ int = f7 /* ERROR "cannot infer T" */ ()
 var _ int = f7(1)
 var _ int = f7(1, 2)
 var _ int = f7([]int{}...)
-var _ int = f7 /* ERROR cannot use */ ([]float64{}...)
+var _ int = f7 /* ERROR "cannot use" */ ([]float64{}...)
 var _ float64 = f7([]float64{}...)
 var _ = f7[float64](1, 2.3)
 var _ = f7(float64(1), 2.3)
-var _ = f7(1, 2.3 /* ERROR does not match */ )
-var _ = f7(1.2, 3 /* ERROR does not match */ )
+var _ = f7(1, 2.3 /* ERROR "does not match" */ )
+var _ = f7(1.2, 3 /* ERROR "does not match" */ )
 
 func f8[A, B any](A, B, ...B) int { panic(0) }
 
-var _ = f8(1) /* ERROR not enough arguments */
+var _ = f8(1) /* ERROR "not enough arguments" */
 var _ = f8(1, 2.3)
 var _ = f8(1, 2.3, 3.4, 4.5)
-var _ = f8(1, 2.3, 3.4, 4 /* ERROR does not match */ )
+var _ = f8(1, 2.3, 3.4, 4 /* ERROR "does not match" */ )
 var _ = f8[int, float64](1, 2.3, 3.4, 4)
 
 var _ = f8[int, float64](0, 0, nil...) // test case for #18268
@@ -323,14 +323,14 @@ var _ = f8[int, float64](0, 0, nil...) // test case for #18268
 // init functions cannot have type parameters
 
 func init() {}
-func init[_ /* ERROR func init must have no type parameters */ any]() {}
-func init[P /* ERROR func init must have no type parameters */ any]() {}
+func init[_ /* ERROR "func init must have no type parameters" */ any]() {}
+func init[P /* ERROR "func init must have no type parameters" */ any]() {}
 
 type T struct {}
 
 func (T) m1() {}
-func (T) m2[ /* ERROR method must have no type parameters */ _ any]() {}
-func (T) m3[ /* ERROR method must have no type parameters */ P any]() {}
+func (T) m2[ /* ERROR "method must have no type parameters" */ _ any]() {}
+func (T) m3[ /* ERROR "method must have no type parameters" */ P any]() {}
 
 // type inference across parameterized types
 
@@ -454,17 +454,17 @@ func (_ R2[X, Y]) m2(X) Y
 //         }
 //
 //         // type assertions and type switches over generic types are strict
-//         _ = p /* ERROR cannot have dynamic type I4 */.(I4)
+//         _ = p /* ERROR "cannot have dynamic type I4" */.(I4)
 //         switch p.(type) {
-//         case I4 /* ERROR cannot have dynamic type I4 */ :
+//         case I4 /* ERROR "cannot have dynamic type I4" */ :
 //         }
 // }
 
 // type assertions and type switches over generic types lead to errors for now
 
 func _[T any](x T) {
-	_ = x /* ERROR cannot use type assertion */ .(int)
-	switch x /* ERROR cannot use type switch */ .(type) {
+	_ = x /* ERROR "cannot use type assertion" */ .(int)
+	switch x /* ERROR "cannot use type switch" */ .(type) {
 	}
 
 	// work-around
@@ -475,8 +475,8 @@ func _[T any](x T) {
 }
 
 func _[T interface{~int}](x T) {
-	_ = x /* ERROR cannot use type assertion */ .(int)
-	switch x /* ERROR cannot use type switch */ .(type) {
+	_ = x /* ERROR "cannot use type assertion" */ .(int)
+	switch x /* ERROR "cannot use type switch" */ .(type) {
 	}
 
 	// work-around
@@ -490,19 +490,19 @@ func _[T interface{~int}](x T) {
 type C[P any] interface{}
 
 func _[P C[P]] (x P) {
-	x.m /* ERROR x.m undefined */ ()
+	x.m /* ERROR "x.m undefined" */ ()
 }
 
 type I interface {}
 
 func _[P I] (x P) {
-	x.m /* ERROR type P has no field or method m */ ()
+	x.m /* ERROR "type P has no field or method m" */ ()
 }
 
 func _[P interface{}] (x P) {
-	x.m /* ERROR type P has no field or method m */ ()
+	x.m /* ERROR "type P has no field or method m" */ ()
 }
 
 func _[P any] (x P) {
-	x.m /* ERROR type P has no field or method m */ ()
+	x.m /* ERROR "type P has no field or method m" */ ()
 }
diff --git a/src/internal/types/testdata/check/unions.go b/src/internal/types/testdata/check/unions.go
index bcd7de6644..5a3a9edd35 100644
--- a/src/internal/types/testdata/check/unions.go
+++ b/src/internal/types/testdata/check/unions.go
@@ -54,13 +54,13 @@ type u101 interface {
 	t70|t71|t72|t73|t74|t75|t76|t77|t78|t79|
 	t80|t81|t82|t83|t84|t85|t86|t87|t88|t89|
 	t90|t91|t92|t93|t94|t95|t96|t97|t98|t99|
-        int // ERROR cannot handle more than 100 union terms
+        int // ERROR "cannot handle more than 100 union terms"
 }
 
 type u102 interface {
-        int /* ERROR cannot handle more than 100 union terms */ |string|u100a
+        int /* ERROR "cannot handle more than 100 union terms" */ |string|u100a
 }
 
 type u200 interface {
-        u100a /* ERROR cannot handle more than 100 union terms */ |u100b
+        u100a /* ERROR "cannot handle more than 100 union terms" */ |u100b
 }
diff --git a/src/internal/types/testdata/check/vardecl.go b/src/internal/types/testdata/check/vardecl.go
index 5b68adb323..a386fd822c 100644
--- a/src/internal/types/testdata/check/vardecl.go
+++ b/src/internal/types/testdata/check/vardecl.go
@@ -151,7 +151,7 @@ func (r T) _(a, b, c int) (u, v, w int) {
 // Unused variables in function literals must lead to only one error (issue #22524).
 func _() {
 	_ = func() {
-		var x /* ERROR declared and not used */ int
+		var x /* ERROR "declared and not used" */ int
 	}
 }
 
@@ -178,29 +178,29 @@ func _() {
 
 func _() {
 	var x int
-	return x /* ERROR too many return values */
-	return math /* ERROR too many return values */ .Sin(0)
+	return x /* ERROR "too many return values" */
+	return math /* ERROR "too many return values" */ .Sin(0)
 }
 
 func _() int {
 	var x, y int
-	return x, y /* ERROR too many return values */
+	return x, y /* ERROR "too many return values" */
 }
 
 // Short variable declarations must declare at least one new non-blank variable.
 func _() {
-	_ := /* ERROR no new variables */ 0
+	_ := /* ERROR "no new variables" */ 0
 	_, a := 0, 1
-	_, a := /* ERROR no new variables */ 0, 1
+	_, a := /* ERROR "no new variables" */ 0, 1
 	_, a, b := 0, 1, 2
-	_, _, _ := /* ERROR no new variables */ 0, 1, 2
+	_, _, _ := /* ERROR "no new variables" */ 0, 1, 2
 
 	_ = a
 	_ = b
 }
 
 // Test case for variables depending on function literals (see also #22992).
-var A /* ERROR initialization cycle */ = func() int { return A }()
+var A /* ERROR "initialization cycle" */ = func() int { return A }()
 
 func _() {
 	// The function literal below must not see a.
diff --git a/src/internal/types/testdata/examples/constraints.go b/src/internal/types/testdata/examples/constraints.go
index 5b144893ce..dcc3a81134 100644
--- a/src/internal/types/testdata/examples/constraints.go
+++ b/src/internal/types/testdata/examples/constraints.go
@@ -17,10 +17,10 @@ type (
 	union interface{int|~string}
 
 	// Union terms must describe disjoint (non-overlapping) type sets.
-	_ interface{int|int /* ERROR overlapping terms int */ }
-	_ interface{int|~ /* ERROR overlapping terms ~int */ int }
-	_ interface{~int|~ /* ERROR overlapping terms ~int */ int }
-	_ interface{~int|MyInt /* ERROR overlapping terms p.MyInt and ~int */ }
+	_ interface{int|int /* ERROR "overlapping terms int" */ }
+	_ interface{int|~ /* ERROR "overlapping terms ~int" */ int }
+	_ interface{~int|~ /* ERROR "overlapping terms ~int" */ int }
+	_ interface{~int|MyInt /* ERROR "overlapping terms p.MyInt and ~int" */ }
 	_ interface{int|any}
 	_ interface{int|~string|union}
 	_ interface{int|~string|interface{int}}
@@ -28,8 +28,8 @@ type (
 	_ interface{union|union} // ditto
 
 	// For now we do not permit interfaces with methods in unions.
-	_ interface{~ /* ERROR invalid use of ~ */ any}
-	_ interface{int|interface /* ERROR cannot use .* in union */ { m() }}
+	_ interface{~ /* ERROR "invalid use of ~" */ any}
+	_ interface{int|interface /* ERROR "cannot use .* in union" */ { m() }}
 )
 
 type (
@@ -37,17 +37,17 @@ type (
 	foo int
 	bar any
 	_ interface{foo}
-	_ interface{~ /* ERROR invalid use of ~ */ foo }
-	_ interface{~ /* ERROR invalid use of ~ */ bar }
+	_ interface{~ /* ERROR "invalid use of ~" */ foo }
+	_ interface{~ /* ERROR "invalid use of ~" */ bar }
 )
 
 // Stand-alone type parameters are not permitted as elements or terms in unions.
 type (
 	_[T interface{ *T } ] struct{}        // ok
 	_[T interface{ int | *T } ] struct{}  // ok
-	_[T interface{ T /* ERROR term cannot be a type parameter */ } ] struct{}
-	_[T interface{ ~T /* ERROR type in term ~T cannot be a type parameter */ } ] struct{}
-	_[T interface{ int|T /* ERROR term cannot be a type parameter */ }] struct{}
+	_[T interface{ T /* ERROR "term cannot be a type parameter" */ } ] struct{}
+	_[T interface{ ~T /* ERROR "type in term ~T cannot be a type parameter" */ } ] struct{}
+	_[T interface{ int|T /* ERROR "term cannot be a type parameter" */ }] struct{}
 )
 
 // Multiple embedded union elements are intersected. The order in which they
@@ -61,8 +61,8 @@ func _[T interface{ myInt1|myInt2; ~int }]() T { return T(0) }
 func _[T interface{ ~int; myInt1|myInt2 }]() T { return T(0) }
 
 // Here the intersections are empty - there's no type that's in the type set of T.
-func _[T interface{ myInt1|myInt2; int }]() T { return T(0 /* ERROR cannot convert */ ) }
-func _[T interface{ int; myInt1|myInt2 }]() T { return T(0 /* ERROR cannot convert */ ) }
+func _[T interface{ myInt1|myInt2; int }]() T { return T(0 /* ERROR "cannot convert" */ ) }
+func _[T interface{ int; myInt1|myInt2 }]() T { return T(0 /* ERROR "cannot convert" */ ) }
 
 // Union elements may be interfaces as long as they don't define
 // any methods or embed comparable.
@@ -75,6 +75,6 @@ type (
 	Number interface{ Integer|Unsigned|Floats|Complex }
 	Ordered interface{ Integer|Unsigned|Floats|~string }
 
-	_ interface{ Number | error /* ERROR cannot use error in union */ }
-	_ interface{ Ordered | comparable /* ERROR cannot use comparable in union */ }
+	_ interface{ Number | error /* ERROR "cannot use error in union" */ }
+	_ interface{ Ordered | comparable /* ERROR "cannot use comparable in union" */ }
 )
diff --git a/src/internal/types/testdata/examples/functions.go b/src/internal/types/testdata/examples/functions.go
index 47e1c35f3d..4f58bb5599 100644
--- a/src/internal/types/testdata/examples/functions.go
+++ b/src/internal/types/testdata/examples/functions.go
@@ -68,7 +68,7 @@ var _ float64 = foo(42, []float64{1.0}, &s)
 // for variadic functions.
 func variadic[A, B any](A, B, ...B) int { panic(0) }
 
-// var _ = variadic(1) // ERROR not enough arguments
+// var _ = variadic(1) // ERROR "not enough arguments"
 var _ = variadic(1, 2.3)
 var _ = variadic(1, 2.3, 3.4, 4.5)
 var _ = variadic[int, float64](1, 2.3, 3.4, 4)
@@ -128,15 +128,15 @@ func _() {
 	var send chan<-int
 
 	fboth(both)
-	fboth(recv /* ERROR cannot use */ )
-	fboth(send /* ERROR cannot use */ )
+	fboth(recv /* ERROR "cannot use" */ )
+	fboth(send /* ERROR "cannot use" */ )
 
 	frecv(both)
 	frecv(recv)
-	frecv(send /* ERROR cannot use */ )
+	frecv(send /* ERROR "cannot use" */ )
 
 	fsend(both)
-	fsend(recv /* ERROR cannot use */)
+	fsend(recv /* ERROR "cannot use" */)
 	fsend(send)
 }
 
@@ -150,15 +150,15 @@ func _() {
 	var send func(chan<- int)
 
 	ffboth(both)
-	ffboth(recv /* ERROR cannot use */ )
-	ffboth(send /* ERROR cannot use */ )
+	ffboth(recv /* ERROR "cannot use" */ )
+	ffboth(send /* ERROR "cannot use" */ )
 
-	ffrecv(both /* ERROR cannot use */ )
+	ffrecv(both /* ERROR "cannot use" */ )
 	ffrecv(recv)
-	ffrecv(send /* ERROR cannot use */ )
+	ffrecv(send /* ERROR "cannot use" */ )
 
-	ffsend(both /* ERROR cannot use */ )
-	ffsend(recv /* ERROR cannot use */ )
+	ffsend(both /* ERROR "cannot use" */ )
+	ffsend(recv /* ERROR "cannot use" */ )
 	ffsend(send)
 }
 
@@ -182,7 +182,7 @@ func _() {
 	type myString string
 	var s1 string
 	g3(nil, "1", myString("2"), "3")
-	g3(& /* ERROR does not match */ s1, "1", myString("2"), "3")
+	g3(& /* ERROR "does not match" */ s1, "1", myString("2"), "3")
 	_ = s1
 
 	type myStruct struct{x int}
@@ -208,12 +208,12 @@ func _() {
 // (that would indicate a slice type). Thus, generic functions cannot
 // have empty type parameter lists, either. This is a syntax error.
 
-func h[] /* ERROR empty type parameter list */ () {}
+func h[] /* ERROR "empty type parameter list" */ () {}
 
 func _() {
-	h /* ERROR cannot index */ [] /* ERROR operand */ ()
+	h /* ERROR "cannot index" */ [] /* ERROR "operand" */ ()
 }
 
 // Generic functions must have a function body.
 
-func _ /* ERROR generic function is missing function body */ [P any]()
+func _ /* ERROR "generic function is missing function body" */ [P any]()
diff --git a/src/internal/types/testdata/examples/inference.go b/src/internal/types/testdata/examples/inference.go
index 073df9ce3b..128ad9b3fe 100644
--- a/src/internal/types/testdata/examples/inference.go
+++ b/src/internal/types/testdata/examples/inference.go
@@ -24,13 +24,13 @@ func _() {
 	_ = min(x, 1)
 	_ = min(x, 1.0)
 	_ = min(1, 2)
-	_ = min(1, 2.3 /* ERROR default type float64 .* does not match */)
+	_ = min(1, 2.3 /* ERROR "default type float64 .* does not match" */)
 
 	var y float64
 	_ = min(1, y)
 	_ = min(1.2, y)
 	_ = min(1.2, 3.4)
-	_ = min(1.2, 3 /* ERROR default type int .* does not match */)
+	_ = min(1.2, 3 /* ERROR "default type int .* does not match" */)
 
 	var s string
 	_ = min(s, "foo")
@@ -51,7 +51,7 @@ func _() {
 
 	// Provided type arguments always take precedence over
 	// inferred types.
-	mixed[int, string](1.1 /* ERROR cannot use 1.1 */, "", false)
+	mixed[int, string](1.1 /* ERROR "cannot use 1.1" */, "", false)
 }
 
 func related1[Slice interface{ ~[]Elem }, Elem any](s Slice, e Elem) {}
@@ -69,13 +69,13 @@ func _() {
 
 	// A type argument inferred from another explicitly provided
 	// type argument overrides whatever value argument type is given.
-	related1[[]string](ss, 0 /* ERROR cannot use 0 */)
+	related1[[]string](ss, 0 /* ERROR "cannot use 0" */)
 
 	// A type argument may be inferred from a value argument
 	// and then help infer another type argument via constraint
 	// type inference.
 	related1(si, 0)
-	related1(si, "foo" /* ERROR cannot use "foo" */)
+	related1(si, "foo" /* ERROR "cannot use "foo"" */)
 }
 
 func related2[Elem any, Slice interface{ []Elem }](e Elem, s Slice) {}
@@ -97,7 +97,7 @@ func _() {
 	// last.
 	related2(1.2, []float64{})
 	related2(1.0, []int{})
-	related2 /* ERROR does not satisfy */ (float64(1.0), []int{}) // TODO(gri) fix error position
+	related2 /* ERROR "does not satisfy" */ (float64(1.0), []int{}) // TODO(gri) fix error position
 }
 
 type List[P any] []P
@@ -112,5 +112,5 @@ func _() {
 	// The 2nd type argument cannot be inferred from the first
 	// one because there's two possible choices: []Elem and
 	// List[Elem].
-	related3 /* ERROR cannot infer Slice */ [int]()
+	related3 /* ERROR "cannot infer Slice" */ [int]()
 }
diff --git a/src/internal/types/testdata/examples/methods.go b/src/internal/types/testdata/examples/methods.go
index a46f789d60..ffa1391d04 100644
--- a/src/internal/types/testdata/examples/methods.go
+++ b/src/internal/types/testdata/examples/methods.go
@@ -28,7 +28,7 @@ var _ int = x.m1()
 // It cannot possibly be some other type because the receiver type is not
 // instantiated with concrete types, it is standing for the parameterized
 // receiver type.
-func (t T1[[ /* ERROR must be an identifier */ ]int]) m2() {}
+func (t T1[[ /* ERROR "must be an identifier" */ ]int]) m2() {}
 
 // Note that using what looks like a predeclared identifier, say int,
 // as type parameter in this situation is deceptive and considered bad
@@ -39,7 +39,7 @@ func (t T1[[ /* ERROR must be an identifier */ ]int]) m2() {}
 // and usually should be avoided. There are some notable exceptions; e.g.,
 // sometimes it makes sense to use the identifier "copy" which happens to
 // also be the name of a predeclared built-in function.
-func (t T1[int]) m3() { var _ int = 42 /* ERROR cannot use 42 .* as int */ }
+func (t T1[int]) m3() { var _ int = 42 /* ERROR "cannot use 42 .* as int" */ }
 
 // The names of the type parameters used in a parameterized receiver
 // type don't have to match the type parameter names in the declaration
@@ -58,7 +58,7 @@ func (t T1[X]) m4() X { return t.a }
 // simply that such receiver type expressions perform two tasks simultaneously:
 // they declare the (local) type parameters and then use them to instantiate
 // the receiver type. Forgetting to provide a type parameter leads to an error.
-func (t T1 /* ERROR generic type .* without instantiation */ ) m5() {}
+func (t T1 /* ERROR "generic type .* without instantiation" */ ) m5() {}
 
 // However, sometimes we don't need the type parameter, and thus it is
 // inconvenient to have to choose a name. Since the receiver type expression
@@ -105,8 +105,8 @@ func (T1[A]) _() {}
 // 
 // type T3b[P interface{ ~unsafe.Pointer }] P
 // 
-// func (T3b /* ERROR invalid receiver */ [_]) m() {}
+// func (T3b /* ERROR "invalid receiver" */ [_]) m() {}
 // 
 // type T3c[P interface{ *int | *string }] P
 // 
-// func (T3c /* ERROR invalid receiver */ [_]) m() {}
+// func (T3c /* ERROR "invalid receiver" */ [_]) m() {}
diff --git a/src/internal/types/testdata/examples/operations.go b/src/internal/types/testdata/examples/operations.go
index 18e4d6080c..9fb95d0b2b 100644
--- a/src/internal/types/testdata/examples/operations.go
+++ b/src/internal/types/testdata/examples/operations.go
@@ -7,11 +7,11 @@ package p
 // indirection
 
 func _[P any](p P) {
-        _ = *p // ERROR cannot indirect p
+        _ = *p // ERROR "cannot indirect p"
 }
 
 func _[P interface{ int }](p P) {
-        _ = *p // ERROR cannot indirect p
+        _ = *p // ERROR "cannot indirect p"
 }
 
 func _[P interface{ *int }](p P) {
@@ -19,7 +19,7 @@ func _[P interface{ *int }](p P) {
 }
 
 func _[P interface{ *int | *string }](p P) {
-        _ = *p // ERROR must have identical base types
+        _ = *p // ERROR "must have identical base types"
 }
 
 type intPtr *int
diff --git a/src/internal/types/testdata/examples/types.go b/src/internal/types/testdata/examples/types.go
index 052d168fc6..43cb913da5 100644
--- a/src/internal/types/testdata/examples/types.go
+++ b/src/internal/types/testdata/examples/types.go
@@ -53,7 +53,7 @@ var x2 T2[int]
 func _() {
 	// This assignment is invalid because the types of x1, x2 are T1(...)
 	// and T2(...) respectively, which are two different defined types.
-	x1 = x2 // ERROR assignment
+	x1 = x2 // ERROR "assignment"
 
 	// This assignment is valid because the types of x1.f and x2.f are
 	// both struct { g int }; the type parameters act like type aliases
@@ -78,7 +78,7 @@ var x1a T1a
 var x2a T2a
 
 func _() {
-	x1a = x2a // ERROR assignment
+	x1a = x2a // ERROR "assignment"
 	x1a.f = x2a.f
 }
 
@@ -97,16 +97,16 @@ var xbool T[bool]
 // differently depending on the type arguments, and thus we can't possibly
 // consider such types identical. Consequently:
 func _() {
-	xint = xbool // ERROR assignment
+	xint = xbool // ERROR "assignment"
 }
 
 // Generic types cannot be used without instantiation.
-var _ T // ERROR cannot use generic type T
-var _ = T /* ERROR cannot use generic type T */ (0)
+var _ T // ERROR "cannot use generic type T"
+var _ = T /* ERROR "cannot use generic type T" */ (0)
 
 // In type context, generic (parameterized) types cannot be parenthesized before
 // being instantiated. See also NOTES entry from 12/4/2019.
-var _ (T /* ERROR cannot use generic type T */ )[ /* ERROR unexpected \[|expected ';' */ int]
+var _ (T /* ERROR "cannot use generic type T" */ )[ /* ERROR "unexpected \[|expected ';'" */ int]
 
 // All types may be parameterized, including interfaces.
 type I1[T any] interface{
@@ -114,7 +114,7 @@ type I1[T any] interface{
 }
 
 // There is no such thing as a variadic generic type.
-type _[T ... /* ERROR invalid use of ... */ any] struct{}
+type _[T ... /* ERROR "invalid use of ..." */ any] struct{}
 
 // Generic interfaces may be embedded as one would expect.
 type I2 interface {
@@ -146,14 +146,14 @@ func _() {
 }
 
 type _ struct {
-	( /* ERROR cannot parenthesize */ int8)
-	( /* ERROR cannot parenthesize */ *int16)
-	*( /* ERROR cannot parenthesize */ int32)
+	( /* ERROR "cannot parenthesize" */ int8)
+	( /* ERROR "cannot parenthesize" */ *int16)
+	*( /* ERROR "cannot parenthesize" */ int32)
 	List[int]
 
-	int8 /* ERROR int8 redeclared */
-	* /* ERROR int16 redeclared */ int16
-	List /* ERROR List redeclared */ [int]
+	int8 /* ERROR "int8 redeclared" */
+	* /* ERROR "int16 redeclared" */ int16
+	List /* ERROR "List redeclared" */ [int]
 }
 
 // Issue #45639: We don't allow this anymore. Keep this code
@@ -169,7 +169,7 @@ type _ struct {
 // 
 // 	// m is not defined on L (it is not "inherited" from
 // 	// its underlying type).
-// 	x.m /* ERROR x.m undefined */ ()
+// 	x.m /* ERROR "x.m undefined" */ ()
 // 
 // 	// But the properties of T, such that as that it supports
 // 	// the operations of the types given by its type bound,
@@ -189,8 +189,8 @@ type _ struct {
 // // It is not permitted to declare a local type whose underlying
 // // type is a type parameter not declared by that type declaration.
 // func _[T any]() {
-// 	type _ T         // ERROR cannot use function type parameter T as RHS in type declaration
-// 	type _ [_ any] T // ERROR cannot use function type parameter T as RHS in type declaration
+// 	type _ T         // ERROR "cannot use function type parameter T as RHS in type declaration"
+// 	type _ [_ any] T // ERROR "cannot use function type parameter T as RHS in type declaration"
 // }
 
 // As a special case, an explicit type argument may be omitted
@@ -220,11 +220,11 @@ type B2[_, _ any] any
 
 func _[T1 B0]() {}
 func _[T1 B1[T1]]() {}
-func _[T1 B2 /* ERROR cannot use generic type .* without instantiation */ ]() {}
+func _[T1 B2 /* ERROR "cannot use generic type .* without instantiation" */ ]() {}
 
 func _[T1, T2 B0]() {}
 func _[T1 B1[T1], T2 B1[T2]]() {}
-func _[T1, T2 B2 /* ERROR cannot use generic type .* without instantiation */ ]() {}
+func _[T1, T2 B2 /* ERROR "cannot use generic type .* without instantiation" */ ]() {}
 
 func _[T1 B0, T2 B1[T2]]() {} // here B1 applies to T2
 
@@ -248,30 +248,30 @@ type I interface {
 }
 
 var (
-	_ interface /* ERROR contains type constraints */ {~int}
-	_ I /* ERROR contains type constraints */
+	_ interface /* ERROR "contains type constraints" */ {~int}
+	_ I /* ERROR "contains type constraints" */
 )
 
-func _(I /* ERROR contains type constraints */ )
-func _(x, y, z I /* ERROR contains type constraints */ )
-func _() I /* ERROR contains type constraints */
+func _(I /* ERROR "contains type constraints" */ )
+func _(x, y, z I /* ERROR "contains type constraints" */ )
+func _() I /* ERROR "contains type constraints" */
 
 func _() {
-	var _ I /* ERROR contains type constraints */
+	var _ I /* ERROR "contains type constraints" */
 }
 
 type C interface {
 	comparable
 }
 
-var _ comparable /* ERROR comparable */
-var _ C /* ERROR comparable */
+var _ comparable /* ERROR "comparable" */
+var _ C /* ERROR "comparable" */
 
-func _(_ comparable /* ERROR comparable */ , _ C /* ERROR comparable */ )
+func _(_ comparable /* ERROR "comparable" */ , _ C /* ERROR "comparable" */ )
 
 func _() {
-	var _ comparable /* ERROR comparable */
-	var _ C /* ERROR comparable */
+	var _ comparable /* ERROR "comparable" */
+	var _ C /* ERROR "comparable" */
 }
 
 // Type parameters are never const types, i.e., it's
@@ -281,8 +281,8 @@ func _() {
 // first place.)
 func _[T interface{~int|~float64}]() {
 	// not valid
-	const _ = T /* ERROR not constant */ (0)
-	const _ T /* ERROR invalid constant type T */ = 1
+	const _ = T /* ERROR "not constant" */ (0)
+	const _ T /* ERROR "invalid constant type T" */ = 1
 
 	// valid
 	var _ = T(0)
diff --git a/src/internal/types/testdata/examples/typesets.go b/src/internal/types/testdata/examples/typesets.go
index a50beb9745..f6e95f561a 100644
--- a/src/internal/types/testdata/examples/typesets.go
+++ b/src/internal/types/testdata/examples/typesets.go
@@ -45,15 +45,15 @@ func _() *int {
 
 // A type parameter may not be embedded in an interface;
 // so it can also not be used as a constraint.
-func _[A any, B A /* ERROR cannot use a type parameter as constraint */]()    {}
-func _[A any, B, C A /* ERROR cannot use a type parameter as constraint */]() {}
+func _[A any, B A /* ERROR "cannot use a type parameter as constraint" */]()    {}
+func _[A any, B, C A /* ERROR "cannot use a type parameter as constraint" */]() {}
 
 // Error messages refer to the type constraint as it appears in the source.
 // (No implicit interface should be exposed.)
 func _[T string](x T) T {
-	return x /* ERROR constrained by string */ * x
+	return x /* ERROR "constrained by string" */ * x
 }
 
 func _[T int | string](x T) T {
-	return x /* ERROR constrained by int|string */ * x
+	return x /* ERROR "constrained by int|string" */ * x
 }
diff --git a/src/internal/types/testdata/fixedbugs/54942.go b/src/internal/types/testdata/fixedbugs/54942.go
index f2e733b6e3..74c8d3e47f 100644
--- a/src/internal/types/testdata/fixedbugs/54942.go
+++ b/src/internal/types/testdata/fixedbugs/54942.go
@@ -17,7 +17,7 @@ type T struct{}
 
 func (_ *T) m(a, b, c, d int) {}
 
-var _ I = new /* ERROR have m\(int, int, int, int\)\n\t\twant m\(int, int, \*int, int\) */ (T)
+var _ I = new /* ERROR "have m\(int, int, int, int\)\n\t\twant m\(int, int, \*int, int\)" */ (T)
 
 // (slightly modified) test case from issue
 
@@ -35,4 +35,4 @@ func (_ *myExecutor) Execute(ctx context.Context, stmt sql.Stmt, maxrows int, ar
 	return &Result{}, nil
 }
 
-var ex Executor = new /* ERROR have Execute\(context\.Context, sql\.Stmt, int, \[\]sql\.NamedArg, int\) \(\*Result, error\)\n\t\twant Execute\(context\.Context, sql\.Stmt, int, \[\]sql\.NamedArg, int\) \(Result, error\) */ (myExecutor)
+var ex Executor = new /* ERROR "have Execute\(context\.Context, sql\.Stmt, int, \[\]sql\.NamedArg, int\) \(\*Result, error\)\n\t\twant Execute\(context\.Context, sql\.Stmt, int, \[\]sql\.NamedArg, int\) \(Result, error\)" */ (myExecutor)
diff --git a/src/internal/types/testdata/fixedbugs/issue20583.go b/src/internal/types/testdata/fixedbugs/issue20583.go
index d26dbada4f..55cbd94175 100644
--- a/src/internal/types/testdata/fixedbugs/issue20583.go
+++ b/src/internal/types/testdata/fixedbugs/issue20583.go
@@ -5,10 +5,10 @@
 package issue20583
 
 const (
-	_ = 6e886451608 /* ERROR malformed constant */ /2
-	_ = 6e886451608i /* ERROR malformed constant */ /2
-	_ = 0 * 1e+1000000000 // ERROR malformed constant
+	_ = 6e886451608 /* ERROR "malformed constant" */ /2
+	_ = 6e886451608i /* ERROR "malformed constant" */ /2
+	_ = 0 * 1e+1000000000 // ERROR "malformed constant"
 
 	x = 1e100000000
-	_ = x*x*x*x*x*x* /* ERROR not representable */ x
+	_ = x*x*x*x*x*x* /* ERROR "not representable" */ x
 )
diff --git a/src/internal/types/testdata/fixedbugs/issue28251.go b/src/internal/types/testdata/fixedbugs/issue28251.go
index ef5e61df47..f2b17315e9 100644
--- a/src/internal/types/testdata/fixedbugs/issue28251.go
+++ b/src/internal/types/testdata/fixedbugs/issue28251.go
@@ -60,6 +60,6 @@ type (
         T11 = T
 )
 
-func (T9 /* ERROR invalid receiver type \*\*T */ ) m9() {}
-func _() { (T{}).m9 /* ERROR has no field or method m9 */ () }
-func _() { (&T{}).m9 /* ERROR has no field or method m9 */ () }
+func (T9 /* ERROR "invalid receiver type \*\*T" */ ) m9() {}
+func _() { (T{}).m9 /* ERROR "has no field or method m9" */ () }
+func _() { (&T{}).m9 /* ERROR "has no field or method m9" */ () }
diff --git a/src/internal/types/testdata/fixedbugs/issue39634.go b/src/internal/types/testdata/fixedbugs/issue39634.go
index 6ee15489c5..77418c2b8c 100644
--- a/src/internal/types/testdata/fixedbugs/issue39634.go
+++ b/src/internal/types/testdata/fixedbugs/issue39634.go
@@ -9,21 +9,21 @@
 package p
 
 // crash 1
-type nt1[_ any]interface{g /* ERROR undefined */ }
-type ph1[e nt1[e],g(d /* ERROR undefined */ )]s /* ERROR undefined */
-func(*ph1[e,e /* ERROR redeclared */ ])h(d /* ERROR undefined */ )
+type nt1[_ any]interface{g /* ERROR "undefined" */ }
+type ph1[e nt1[e],g(d /* ERROR "undefined" */ )]s /* ERROR "undefined" */
+func(*ph1[e,e /* ERROR "redeclared" */ ])h(d /* ERROR "undefined" */ )
 
 // crash 2
 // Disabled: empty []'s are now syntax errors. This example leads to too many follow-on errors.
-// type Numeric2 interface{t2 /* ERROR not a type */ }
-// func t2[T Numeric2](s[]T){0 /* ERROR not a type */ []{s /* ERROR cannot index */ [0][0]}}
+// type Numeric2 interface{t2 /* ERROR "not a type" */ }
+// func t2[T Numeric2](s[]T){0 /* ERROR "not a type */ []{s /* ERROR cannot index" */ [0][0]}}
 
 // crash 3
-type t3 *interface{ t3.p /* ERROR t3.p is not a type */ }
+type t3 *interface{ t3.p /* ERROR "t3.p is not a type" */ }
 
 // crash 4
-type Numeric4 interface{t4 /* ERROR not a type */ }
-func t4[T Numeric4](s[]T){if( /* ERROR non-boolean */ 0){*s /* ERROR cannot indirect */ [0]}}
+type Numeric4 interface{t4 /* ERROR "not a type" */ }
+func t4[T Numeric4](s[]T){if( /* ERROR "non-boolean" */ 0){*s /* ERROR "cannot indirect" */ [0]}}
 
 // crash 7
 type foo7 interface { bar() }
@@ -31,60 +31,60 @@ type x7[A any] struct{ foo7 }
 func main7() { var _ foo7 = x7[int]{} }
 
 // crash 8
-type foo8[A any] interface { ~A /* ERROR cannot be a type parameter */ }
+type foo8[A any] interface { ~A /* ERROR "cannot be a type parameter" */ }
 func bar8[A foo8[A]](a A) {}
 
 // crash 9
-type foo9[A any] interface { foo9 /* ERROR invalid recursive type */ [A] }
+type foo9[A any] interface { foo9 /* ERROR "invalid recursive type" */ [A] }
 func _() { var _ = new(foo9[int]) }
 
 // crash 12
-var u /* ERROR cycle */ , i [func /* ERROR used as value */ /* ERROR used as value */ (u, c /* ERROR undefined */ /* ERROR undefined */ ) {}(0, len /* ERROR must be called */ /* ERROR must be called */ )]c /* ERROR undefined */ /* ERROR undefined */
+var u /* ERROR "cycle" */ , i [func /* ERROR "used as value" */ /* ERROR "used as value" */ (u, c /* ERROR "undefined" */ /* ERROR "undefined" */ ) {}(0, len /* ERROR "must be called" */ /* ERROR "must be called" */ )]c /* ERROR "undefined" */ /* ERROR "undefined" */
 
 // crash 15
-func y15() { var a /* ERROR declared and not used */ interface{ p() } = G15[string]{} }
-type G15[X any] s /* ERROR undefined */
-func (G15 /* ERROR generic type .* without instantiation */ ) p()
+func y15() { var a /* ERROR "declared and not used" */ interface{ p() } = G15[string]{} }
+type G15[X any] s /* ERROR "undefined" */
+func (G15 /* ERROR "generic type .* without instantiation" */ ) p()
 
 // crash 16
-type Foo16[T any] r16 /* ERROR not a type */
+type Foo16[T any] r16 /* ERROR "not a type" */
 func r16[T any]() Foo16[Foo16[T]] { panic(0) }
 
 // crash 17
 type Y17 interface{ c() }
 type Z17 interface {
 	c() Y17
-	Y17 /* ERROR duplicate method */
+	Y17 /* ERROR "duplicate method" */
 }
 func F17[T Z17](T) {}
 
 // crash 18
-type o18[T any] []func(_ o18[[]_ /* ERROR cannot use _ */ ])
+type o18[T any] []func(_ o18[[]_ /* ERROR "cannot use _" */ ])
 
 // crash 19
-type Z19 [][[]Z19{}[0][0]]c19 /* ERROR undefined */
+type Z19 [][[]Z19{}[0][0]]c19 /* ERROR "undefined" */
 
 // crash 20
-type Z20 /* ERROR invalid recursive type */ interface{ Z20 }
-func F20[t Z20]() { F20(t /* ERROR invalid composite literal type */ {}) }
+type Z20 /* ERROR "invalid recursive type" */ interface{ Z20 }
+func F20[t Z20]() { F20(t /* ERROR "invalid composite literal type" */ {}) }
 
 // crash 21
-type Z21 /* ERROR invalid recursive type */ interface{ Z21 }
-func F21[T Z21]() { ( /* ERROR not used */ F21[Z21]) }
+type Z21 /* ERROR "invalid recursive type" */ interface{ Z21 }
+func F21[T Z21]() { ( /* ERROR "not used" */ F21[Z21]) }
 
 // crash 24
-type T24[P any] P // ERROR cannot use a type parameter as RHS in type declaration
-func (r T24[P]) m() { T24 /* ERROR without instantiation */ .m() }
+type T24[P any] P // ERROR "cannot use a type parameter as RHS in type declaration"
+func (r T24[P]) m() { T24 /* ERROR "without instantiation" */ .m() }
 
 // crash 25
 type T25[A any] int
 func (t T25[A]) m1() {}
-var x T25 /* ERROR without instantiation */ .m1
+var x T25 /* ERROR "without instantiation" */ .m1
 
 // crash 26
-type T26 = interface{ F26[ /* ERROR interface method must have no type parameters */ Z any]() }
-func F26[Z any]() T26 { return F26[] /* ERROR operand */ }
+type T26 = interface{ F26[ /* ERROR "interface method must have no type parameters" */ Z any]() }
+func F26[Z any]() T26 { return F26[] /* ERROR "operand" */ }
 
 // crash 27
-func e27[T any]() interface{ x27 /* ERROR not a type */ } { panic(0) }
-func x27() { e27 /* ERROR cannot infer T */ () }
+func e27[T any]() interface{ x27 /* ERROR "not a type" */ } { panic(0) }
+func x27() { e27 /* ERROR "cannot infer T" */ () }
diff --git a/src/internal/types/testdata/fixedbugs/issue39664.go b/src/internal/types/testdata/fixedbugs/issue39664.go
index 3b3ec56980..a8148c6e9e 100644
--- a/src/internal/types/testdata/fixedbugs/issue39664.go
+++ b/src/internal/types/testdata/fixedbugs/issue39664.go
@@ -6,7 +6,7 @@ package p
 
 type T[_ any] struct {}
 
-func (T /* ERROR instantiation */ ) m()
+func (T /* ERROR "instantiation" */ ) m()
 
 func _() {
 	var x interface { m() }
diff --git a/src/internal/types/testdata/fixedbugs/issue39693.go b/src/internal/types/testdata/fixedbugs/issue39693.go
index 496754d972..03f27895d8 100644
--- a/src/internal/types/testdata/fixedbugs/issue39693.go
+++ b/src/internal/types/testdata/fixedbugs/issue39693.go
@@ -11,7 +11,7 @@ type Number1 interface {
 }
 
 func Add1[T Number1](a, b T) T {
-	return a /* ERROR not defined */ + b
+	return a /* ERROR "not defined" */ + b
 }
 
 type Number2 interface {
diff --git a/src/internal/types/testdata/fixedbugs/issue39699.go b/src/internal/types/testdata/fixedbugs/issue39699.go
index 72f83997c2..73ba0c4cd6 100644
--- a/src/internal/types/testdata/fixedbugs/issue39699.go
+++ b/src/internal/types/testdata/fixedbugs/issue39699.go
@@ -23,7 +23,7 @@ type T3 interface {
 
 func _() {
 	_ = T0(0)
-	_ = T1 /* ERROR cannot use interface T1 in conversion */ (1)
-	_ = T2 /* ERROR cannot use interface T2 in conversion */ (2)
-	_ = T3 /* ERROR cannot use interface T3 in conversion */ (3)
+	_ = T1 /* ERROR "cannot use interface T1 in conversion" */ (1)
+	_ = T2 /* ERROR "cannot use interface T2 in conversion" */ (2)
+	_ = T3 /* ERROR "cannot use interface T3 in conversion" */ (3)
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue39723.go b/src/internal/types/testdata/fixedbugs/issue39723.go
index 00885238e6..19e5e80393 100644
--- a/src/internal/types/testdata/fixedbugs/issue39723.go
+++ b/src/internal/types/testdata/fixedbugs/issue39723.go
@@ -6,4 +6,4 @@ package p
 
 // A constraint must be an interface; it cannot
 // be a type parameter, for instance.
-func _[A interface{ ~int }, B A /* ERROR cannot use a type parameter as constraint */ ]() {}
+func _[A interface{ ~int }, B A /* ERROR "cannot use a type parameter as constraint" */ ]() {}
diff --git a/src/internal/types/testdata/fixedbugs/issue39725.go b/src/internal/types/testdata/fixedbugs/issue39725.go
index 62dc45a596..7efc11c79a 100644
--- a/src/internal/types/testdata/fixedbugs/issue39725.go
+++ b/src/internal/types/testdata/fixedbugs/issue39725.go
@@ -6,11 +6,11 @@ package p
 
 func f1[T1, T2 any](T1, T2, struct{a T1; b T2}) {}
 func _() {
-	f1(42, string("foo"), struct /* ERROR does not match inferred type struct\{a int; b string\} */ {a, b int}{})
+	f1(42, string("foo"), struct /* ERROR "does not match inferred type struct\{a int; b string\}" */ {a, b int}{})
 }
 
 // simplified test case from issue
 func f2[T any](_ []T, _ func(T)) {}
 func _() {
-	f2([]string{}, func /* ERROR does not match inferred type func\(string\) */ (f []byte) {})
+	f2([]string{}, func /* ERROR "does not match inferred type func\(string\)" */ (f []byte) {})
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue39754.go b/src/internal/types/testdata/fixedbugs/issue39754.go
index 97365e2ddd..3afb8d3dda 100644
--- a/src/internal/types/testdata/fixedbugs/issue39754.go
+++ b/src/internal/types/testdata/fixedbugs/issue39754.go
@@ -16,6 +16,6 @@ func f[V interface{}, A, B Box[V]]() {}
 
 func _() {
 	f[int, Optional[int], Optional[int]]()
-	_ = f[int, Optional[int], Optional /* ERROR does not satisfy Box */ [string]]
-	_ = f[int, Optional[int], Optional /* ERROR Optional.* does not satisfy Box.* */ [string]]
+	_ = f[int, Optional[int], Optional /* ERROR "does not satisfy Box" */ [string]]
+	_ = f[int, Optional[int], Optional /* ERROR "Optional.* does not satisfy Box.*" */ [string]]
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue39768.go b/src/internal/types/testdata/fixedbugs/issue39768.go
index 696d9d9bee..51a417759a 100644
--- a/src/internal/types/testdata/fixedbugs/issue39768.go
+++ b/src/internal/types/testdata/fixedbugs/issue39768.go
@@ -6,16 +6,16 @@ package p
 
 // For now, a lone type parameter is not permitted as RHS in a type declaration (issue #45639).
 // type T[P any] P
-// type A = T  // ERROR cannot use generic type
+// type A = T  // ERROR "cannot use generic type"
 // var x A[int]
 // var _ A
 //
 // type B = T[int]
 // var y B = x
-// var _ B /* ERROR not a generic type */ [int]
+// var _ B /* ERROR "not a generic type" */ [int]
 
 // test case from issue
 
 type Vector[T any] []T
-type VectorAlias = Vector // ERROR cannot use generic type
+type VectorAlias = Vector // ERROR "cannot use generic type"
 var v Vector[int]
diff --git a/src/internal/types/testdata/fixedbugs/issue39938.go b/src/internal/types/testdata/fixedbugs/issue39938.go
index 633698d611..bd5bdcae07 100644
--- a/src/internal/types/testdata/fixedbugs/issue39938.go
+++ b/src/internal/types/testdata/fixedbugs/issue39938.go
@@ -23,7 +23,7 @@ type T1 struct {
         _ E1[T1]
 }
 
-type T2 /* ERROR invalid recursive type */ struct {
+type T2 /* ERROR "invalid recursive type" */ struct {
         _ E2[T2]
 }
 
@@ -31,7 +31,7 @@ type T3 struct {
         _ E3[T3]
 }
 
-type T4 /* ERROR invalid recursive type */ [10]E5[T4]
+type T4 /* ERROR "invalid recursive type" */ [10]E5[T4]
 
 type T5 struct {
 	_ E0[E2[T5]]
@@ -49,6 +49,6 @@ type T8 struct {
 	_ E0[[]E2[E0[E2[E2[T8]]]]]
 }
 
-type T9 /* ERROR invalid recursive type */ [10]E2[E5[E2[T9]]]
+type T9 /* ERROR "invalid recursive type" */ [10]E2[E5[E2[T9]]]
 
 type T10 [10]E2[E5[E2[func(T10)]]]
diff --git a/src/internal/types/testdata/fixedbugs/issue39948.go b/src/internal/types/testdata/fixedbugs/issue39948.go
index c893cc049e..e4430cfc4a 100644
--- a/src/internal/types/testdata/fixedbugs/issue39948.go
+++ b/src/internal/types/testdata/fixedbugs/issue39948.go
@@ -5,5 +5,5 @@
 package p
 
 type T[P any] interface{
-	P // ERROR term cannot be a type parameter
+	P // ERROR "term cannot be a type parameter"
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue39976.go b/src/internal/types/testdata/fixedbugs/issue39976.go
index d703da90a2..e004e3e1ff 100644
--- a/src/internal/types/testdata/fixedbugs/issue39976.go
+++ b/src/internal/types/testdata/fixedbugs/issue39976.go
@@ -12,5 +12,5 @@ func NewCache[K, V any](p policy[K, V]) {}
 func _() {
 	var lru LRU[int, string]
 	NewCache[int, string](&lru)
-	NewCache(& /* ERROR does not match policy\[K, V\] \(cannot infer K and V\) */ lru)
+	NewCache(& /* ERROR "does not match policy\[K, V\] \(cannot infer K and V\)" */ lru)
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue40056.go b/src/internal/types/testdata/fixedbugs/issue40056.go
index 66130c0a55..ce882e7f22 100644
--- a/src/internal/types/testdata/fixedbugs/issue40056.go
+++ b/src/internal/types/testdata/fixedbugs/issue40056.go
@@ -5,11 +5,11 @@
 package p
 
 func _() {
-	NewS /* ERROR cannot infer T */ ().M()
+	NewS /* ERROR "cannot infer T" */ ().M()
 }
 
 type S struct {}
 
 func NewS[T any]() *S { panic(0) }
 
-func (_ *S /* ERROR S is not a generic type */ [T]) M()
+func (_ *S /* ERROR "S is not a generic type" */ [T]) M()
diff --git a/src/internal/types/testdata/fixedbugs/issue40057.go b/src/internal/types/testdata/fixedbugs/issue40057.go
index fdc8fb1c00..2996d398e7 100644
--- a/src/internal/types/testdata/fixedbugs/issue40057.go
+++ b/src/internal/types/testdata/fixedbugs/issue40057.go
@@ -7,7 +7,7 @@ package p
 func _() {
 	var x interface{}
 	switch t := x.(type) {
-	case S /* ERROR cannot use generic type */ :
+	case S /* ERROR "cannot use generic type" */ :
 		t.m()
 	}
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue40350.go b/src/internal/types/testdata/fixedbugs/issue40350.go
index 08eb426410..035086ad64 100644
--- a/src/internal/types/testdata/fixedbugs/issue40350.go
+++ b/src/internal/types/testdata/fixedbugs/issue40350.go
@@ -12,5 +12,5 @@ type number interface {
 func f[T number]() {}
 
 func _() {
-	_ = f[int /* ERROR int does not satisfy number \(number mentions int, but int is not in the type set of number\)*/]
+	_ = f[int /* ERROR "int does not satisfy number \(number mentions int, but int is not in the type set of number\)" */]
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue40684.go b/src/internal/types/testdata/fixedbugs/issue40684.go
index 63a058d039..4805184160 100644
--- a/src/internal/types/testdata/fixedbugs/issue40684.go
+++ b/src/internal/types/testdata/fixedbugs/issue40684.go
@@ -10,6 +10,6 @@ func f[_ any]() {}
 func g[_, _ any]() {}
 
 func _() {
-	_ = f[T /* ERROR without instantiation */ ]
-	_ = g[T /* ERROR without instantiation */ , T /* ERROR without instantiation */ ]
+	_ = f[T /* ERROR "without instantiation" */ ]
+	_ = g[T /* ERROR "without instantiation" */ , T /* ERROR "without instantiation" */ ]
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue41124.go b/src/internal/types/testdata/fixedbugs/issue41124.go
index 80d1ff4750..612f1d22f1 100644
--- a/src/internal/types/testdata/fixedbugs/issue41124.go
+++ b/src/internal/types/testdata/fixedbugs/issue41124.go
@@ -6,7 +6,7 @@ package p
 
 // Test case from issue.
 
-type Nat /* ERROR invalid recursive type */ interface {
+type Nat /* ERROR "invalid recursive type" */ interface {
 	Zero|Succ
 }
 
@@ -31,61 +31,61 @@ type I3 interface {
 }
 
 type _ struct {
-	f I1 // ERROR interface is .* comparable
+	f I1 // ERROR "interface is .* comparable"
 }
 
 type _ struct {
-	comparable // ERROR interface is .* comparable
+	comparable // ERROR "interface is .* comparable"
 }
 
 type _ struct{
-	I1 // ERROR interface is .* comparable
+	I1 // ERROR "interface is .* comparable"
 }
 
 type _ struct{
-	I2 // ERROR interface contains type constraints
+	I2 // ERROR "interface contains type constraints"
 }
 
 type _ struct{
-	I3 // ERROR interface contains type constraints
+	I3 // ERROR "interface contains type constraints"
 }
 
 // General composite types.
 
 type (
-	_ [10]I1 // ERROR interface is .* comparable
-	_ [10]I2 // ERROR interface contains type constraints
+	_ [10]I1 // ERROR "interface is .* comparable"
+	_ [10]I2 // ERROR "interface contains type constraints"
 
-	_ []I1 // ERROR interface is .* comparable
-	_ []I2 // ERROR interface contains type constraints
+	_ []I1 // ERROR "interface is .* comparable"
+	_ []I2 // ERROR "interface contains type constraints"
 
-	_ *I3 // ERROR interface contains type constraints
-	_ map[I1 /* ERROR interface is .* comparable */ ]I2 // ERROR interface contains type constraints
-	_ chan I3 // ERROR interface contains type constraints
-	_ func(I1 /* ERROR interface is .* comparable */ )
-	_ func() I2 // ERROR interface contains type constraints
+	_ *I3 // ERROR "interface contains type constraints"
+	_ map[I1 /* ERROR "interface is .* comparable" */ ]I2 // ERROR "interface contains type constraints"
+	_ chan I3 // ERROR "interface contains type constraints"
+	_ func(I1 /* ERROR "interface is .* comparable" */ )
+	_ func() I2 // ERROR "interface contains type constraints"
 )
 
 // Other cases.
 
-var _ = [...]I3 /* ERROR interface contains type constraints */ {}
+var _ = [...]I3 /* ERROR "interface contains type constraints" */ {}
 
 func _(x interface{}) {
-	_ = x.(I3 /* ERROR interface contains type constraints */ )
+	_ = x.(I3 /* ERROR "interface contains type constraints" */ )
 }
 
 type T1[_ any] struct{}
 type T3[_, _, _ any] struct{}
-var _ T1[I2 /* ERROR interface contains type constraints */ ]
-var _ T3[int, I2 /* ERROR interface contains type constraints */ , float32]
+var _ T1[I2 /* ERROR "interface contains type constraints" */ ]
+var _ T3[int, I2 /* ERROR "interface contains type constraints" */ , float32]
 
 func f1[_ any]() int { panic(0) }
-var _ = f1[I2 /* ERROR interface contains type constraints */ ]()
+var _ = f1[I2 /* ERROR "interface contains type constraints" */ ]()
 func f3[_, _, _ any]() int { panic(0) }
-var _ = f3[int, I2 /* ERROR interface contains type constraints */ , float32]()
+var _ = f3[int, I2 /* ERROR "interface contains type constraints" */ , float32]()
 
 func _(x interface{}) {
 	switch x.(type) {
-	case I2 /* ERROR interface contains type constraints */ :
+	case I2 /* ERROR "interface contains type constraints" */ :
 	}
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue42695.go b/src/internal/types/testdata/fixedbugs/issue42695.go
index d0d6200969..4551e9f03b 100644
--- a/src/internal/types/testdata/fixedbugs/issue42695.go
+++ b/src/internal/types/testdata/fixedbugs/issue42695.go
@@ -4,14 +4,14 @@
 
 package issue42695
 
-const _ = 6e5518446744 // ERROR malformed constant
-const _ uint8 = 6e5518446744 // ERROR malformed constant
+const _ = 6e5518446744 // ERROR "malformed constant"
+const _ uint8 = 6e5518446744 // ERROR "malformed constant"
 
-var _ = 6e5518446744 // ERROR malformed constant
-var _ uint8 = 6e5518446744 // ERROR malformed constant
+var _ = 6e5518446744 // ERROR "malformed constant"
+var _ uint8 = 6e5518446744 // ERROR "malformed constant"
 
 func f(x int) int {
-        return x + 6e5518446744 // ERROR malformed constant
+        return x + 6e5518446744 // ERROR "malformed constant"
 }
 
-var _ = f(6e5518446744 /* ERROR malformed constant */ )
+var _ = f(6e5518446744 /* ERROR "malformed constant" */ )
diff --git a/src/internal/types/testdata/fixedbugs/issue42758.go b/src/internal/types/testdata/fixedbugs/issue42758.go
index 6d75b106d4..4e1df340da 100644
--- a/src/internal/types/testdata/fixedbugs/issue42758.go
+++ b/src/internal/types/testdata/fixedbugs/issue42758.go
@@ -12,7 +12,7 @@ func _[T any](x interface{}){
 
 	switch x.(type) {
 	case T:
-	case T /* ERROR duplicate case */ :
+	case T /* ERROR "duplicate case" */ :
 	}
 }
 
@@ -27,7 +27,7 @@ func _[T constraint](x interface{}){
 	}
 }
 
-func _(x constraint /* ERROR contains type constraints */ ) {
+func _(x constraint /* ERROR "contains type constraints" */ ) {
 	switch x.(type) { // no need to report another error
 	}
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue42881.go b/src/internal/types/testdata/fixedbugs/issue42881.go
index 7122d1c787..9f18897dff 100644
--- a/src/internal/types/testdata/fixedbugs/issue42881.go
+++ b/src/internal/types/testdata/fixedbugs/issue42881.go
@@ -10,7 +10,7 @@ type (
 )
 
 var (
-	_ comparable // ERROR cannot use type comparable outside a type constraint: interface is \(or embeds\) comparable
-	_ T1         // ERROR cannot use type T1 outside a type constraint: interface is \(or embeds\) comparable
-	_ T2         // ERROR cannot use type T2 outside a type constraint: interface contains type constraints
+	_ comparable // ERROR "cannot use type comparable outside a type constraint: interface is \(or embeds\) comparable"
+	_ T1         // ERROR "cannot use type T1 outside a type constraint: interface is \(or embeds\) comparable"
+	_ T2         // ERROR "cannot use type T2 outside a type constraint: interface contains type constraints"
 )
diff --git a/src/internal/types/testdata/fixedbugs/issue42987.go b/src/internal/types/testdata/fixedbugs/issue42987.go
index f58c63f8a3..300508593c 100644
--- a/src/internal/types/testdata/fixedbugs/issue42987.go
+++ b/src/internal/types/testdata/fixedbugs/issue42987.go
@@ -5,4 +5,4 @@
 // Check that there is only one error (no follow-on errors).
 
 package p
-var _ = [ ... /* ERROR invalid use of \[...\] array */ ]byte("foo")
\ No newline at end of file
+var _ = [ ... /* ERROR "invalid use of \[...\] array" */ ]byte("foo")
\ No newline at end of file
diff --git a/src/internal/types/testdata/fixedbugs/issue43087.go b/src/internal/types/testdata/fixedbugs/issue43087.go
index 85d4450139..2f40a75ee8 100644
--- a/src/internal/types/testdata/fixedbugs/issue43087.go
+++ b/src/internal/types/testdata/fixedbugs/issue43087.go
@@ -5,7 +5,7 @@
 package p
 
 func _() {
-	a, b, b /* ERROR b repeated on left side of := */ := 1, 2, 3
+	a, b, b /* ERROR "b repeated on left side of :=" */ := 1, 2, 3
 	_ = a
 	_ = b
 }
@@ -17,27 +17,27 @@ func _() {
 
 func _() {
 	var b int
-	a, b, b /* ERROR b repeated on left side of := */ := 1, 2, 3
+	a, b, b /* ERROR "b repeated on left side of :=" */ := 1, 2, 3
 	_ = a
 	_ = b
 }
 
 func _() {
 	var a []int
-	a /* ERROR non-name .* on left side of := */ [0], b := 1, 2
+	a /* ERROR "non-name .* on left side of :=" */ [0], b := 1, 2
 	_ = a
 	_ = b
 }
 
 func _() {
 	var a int
-	a, a /* ERROR a repeated on left side of := */ := 1, 2
+	a, a /* ERROR "a repeated on left side of :=" */ := 1, 2
 	_ = a
 }
 
 func _() {
 	var a, b int
-	a, b := /* ERROR no new variables on left side of := */ 1, 2
+	a, b := /* ERROR "no new variables on left side of :=" */ 1, 2
 	_ = a
 	_ = b
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue43109.go b/src/internal/types/testdata/fixedbugs/issue43109.go
index f242f16ca6..3650f710f7 100644
--- a/src/internal/types/testdata/fixedbugs/issue43109.go
+++ b/src/internal/types/testdata/fixedbugs/issue43109.go
@@ -7,4 +7,4 @@
 
 package p
 
-import . "/foo" // ERROR could not import \/foo
+import . "/foo" // ERROR "could not import \/foo"
diff --git a/src/internal/types/testdata/fixedbugs/issue43110.go b/src/internal/types/testdata/fixedbugs/issue43110.go
index 8d5c983fd5..b0b2d9b28e 100644
--- a/src/internal/types/testdata/fixedbugs/issue43110.go
+++ b/src/internal/types/testdata/fixedbugs/issue43110.go
@@ -9,10 +9,10 @@ type P *struct{}
 func _() {
 	// want an error even if the switch is empty
 	var a struct{ _ func() }
-	switch a /* ERROR cannot switch on a */ {
+	switch a /* ERROR "cannot switch on a" */ {
 	}
 
-	switch a /* ERROR cannot switch on a */ {
+	switch a /* ERROR "cannot switch on a" */ {
 	case a: // no follow-on error here
 	}
 
@@ -30,10 +30,10 @@ func _() {
 	}
 
 	switch (func())(nil) {
-	case f /* ERROR invalid case f in switch on .* \(func can only be compared to nil\) */ :
+	case f /* ERROR "invalid case f in switch on .* \(func can only be compared to nil\)" */ :
 	}
 
-	switch nil /* ERROR use of untyped nil in switch expression */ {
+	switch nil /* ERROR "use of untyped nil in switch expression" */ {
 	}
 
 	// this is ok
diff --git a/src/internal/types/testdata/fixedbugs/issue43124.go b/src/internal/types/testdata/fixedbugs/issue43124.go
index f429f74a74..9ddb1a54c9 100644
--- a/src/internal/types/testdata/fixedbugs/issue43124.go
+++ b/src/internal/types/testdata/fixedbugs/issue43124.go
@@ -4,7 +4,7 @@
 
 package p
 
-var _ = int(0 /* ERROR invalid use of \.\.\. in conversion to int */ ...)
+var _ = int(0 /* ERROR "invalid use of \.\.\. in conversion to int" */ ...)
 
 // test case from issue
 
@@ -12,5 +12,5 @@ type M []string
 
 var (
 	x = []string{"a", "b"}
-	_ = M(x /* ERROR invalid use of \.\.\. in conversion to M */ ...)
+	_ = M(x /* ERROR "invalid use of \.\.\. in conversion to M" */ ...)
 )
diff --git a/src/internal/types/testdata/fixedbugs/issue43125.go b/src/internal/types/testdata/fixedbugs/issue43125.go
index 456888de6b..d0d6feb2a8 100644
--- a/src/internal/types/testdata/fixedbugs/issue43125.go
+++ b/src/internal/types/testdata/fixedbugs/issue43125.go
@@ -4,5 +4,5 @@
 
 package p
 
-var _ = new(- /* ERROR not a type */ 1)
-var _ = new(1 /* ERROR not a type */ + 1)
+var _ = new(- /* ERROR "not a type" */ 1)
+var _ = new(1 /* ERROR "not a type" */ + 1)
diff --git a/src/internal/types/testdata/fixedbugs/issue43190.go b/src/internal/types/testdata/fixedbugs/issue43190.go
index ace0487229..83efa12751 100644
--- a/src/internal/types/testdata/fixedbugs/issue43190.go
+++ b/src/internal/types/testdata/fixedbugs/issue43190.go
@@ -7,25 +7,25 @@
 
 package p
 
-import ; // ERROR missing import path
-import "" // ERROR invalid import path \(empty string\)
+import ; // ERROR "missing import path"
+import "" // ERROR "invalid import path \(empty string\)"
 import
-var /* ERROR missing import path */ _ int
-import .; // ERROR missing import path
-import 'x' // ERROR import path must be a string
+var /* ERROR "missing import path" */ _ int
+import .; // ERROR "missing import path"
+import 'x' // ERROR "import path must be a string"
 var _ int
-import /* ERROR imports must appear before other declarations */ _ "math"
+import /* ERROR "imports must appear before other declarations" */ _ "math"
 
 // Don't repeat previous error for each immediately following import ...
 import ()
-import (.) // ERROR missing import path
+import (.) // ERROR "missing import path"
 import (
 	"fmt"
 	.
-) // ERROR missing import path
+) // ERROR "missing import path"
 
 // ... but remind with error again if we start a new import section after
 // other declarations
 var _ = fmt.Println
-import /* ERROR imports must appear before other declarations */ _ "math"
+import /* ERROR "imports must appear before other declarations" */ _ "math"
 import _ "math"
diff --git a/src/internal/types/testdata/fixedbugs/issue43527.go b/src/internal/types/testdata/fixedbugs/issue43527.go
index b515100d3d..473ab96f56 100644
--- a/src/internal/types/testdata/fixedbugs/issue43527.go
+++ b/src/internal/types/testdata/fixedbugs/issue43527.go
@@ -8,8 +8,8 @@ const L = 10
 
 type (
 	_        [L]struct{}
-	_        [A /* ERROR undefined array length A or missing type constraint */ ]struct{}
-	_        [B /* ERROR invalid array length B */ ]struct{}
+	_        [A /* ERROR "undefined array length A or missing type constraint" */ ]struct{}
+	_        [B /* ERROR "invalid array length B" */ ]struct{}
 	_[A any] struct{}
 
 	B int
diff --git a/src/internal/types/testdata/fixedbugs/issue43671.go b/src/internal/types/testdata/fixedbugs/issue43671.go
index 6879aecb45..c72e1da63c 100644
--- a/src/internal/types/testdata/fixedbugs/issue43671.go
+++ b/src/internal/types/testdata/fixedbugs/issue43671.go
@@ -12,11 +12,11 @@ type C4 interface{ chan int | chan<- int }
 type C5[T any] interface{ ~chan T | <-chan T }
 
 func _[T any](ch T) {
-	<-ch // ERROR cannot receive from ch .* \(no core type\)
+	<-ch // ERROR "cannot receive from ch .* \(no core type\)"
 }
 
 func _[T C0](ch T) {
-	<-ch // ERROR cannot receive from non-channel ch
+	<-ch // ERROR "cannot receive from non-channel ch"
 }
 
 func _[T C1](ch T) {
@@ -28,11 +28,11 @@ func _[T C2](ch T) {
 }
 
 func _[T C3](ch T) {
-	<-ch // ERROR cannot receive from ch .* \(no core type\)
+	<-ch // ERROR "cannot receive from ch .* \(no core type\)"
 }
 
 func _[T C4](ch T) {
-	<-ch // ERROR cannot receive from send-only channel
+	<-ch // ERROR "cannot receive from send-only channel"
 }
 
 func _[T C5[X], X any](ch T, x X) {
diff --git a/src/internal/types/testdata/fixedbugs/issue45114.go b/src/internal/types/testdata/fixedbugs/issue45114.go
index 009366010e..d076e4f1e5 100644
--- a/src/internal/types/testdata/fixedbugs/issue45114.go
+++ b/src/internal/types/testdata/fixedbugs/issue45114.go
@@ -5,4 +5,4 @@
 package p
 
 var s uint
-var _ = string(1 /* ERROR shifted operand 1 .* must be integer */ << s)
+var _ = string(1 /* ERROR "shifted operand 1 .* must be integer" */ << s)
diff --git a/src/internal/types/testdata/fixedbugs/issue45550.go b/src/internal/types/testdata/fixedbugs/issue45550.go
index 498b1eb680..2ea4ffe307 100644
--- a/src/internal/types/testdata/fixedbugs/issue45550.go
+++ b/src/internal/types/testdata/fixedbugs/issue45550.go
@@ -4,7 +4,7 @@
 
 package p
 
-type Builder /* ERROR invalid recursive type */ [T interface{ struct{ Builder[T] } }] struct{}
+type Builder /* ERROR "invalid recursive type" */ [T interface{ struct{ Builder[T] } }] struct{}
 type myBuilder struct {
 	Builder[myBuilder]
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue45635.go b/src/internal/types/testdata/fixedbugs/issue45635.go
index af05ff019f..b83d4774fe 100644
--- a/src/internal/types/testdata/fixedbugs/issue45635.go
+++ b/src/internal/types/testdata/fixedbugs/issue45635.go
@@ -10,7 +10,7 @@ func main() {
 
 type N[T any] struct{}
 
-var _ N [] // ERROR expected type argument list
+var _ N [] // ERROR "expected type argument list"
 
 type I interface {
 	~[]int
diff --git a/src/internal/types/testdata/fixedbugs/issue45639.go b/src/internal/types/testdata/fixedbugs/issue45639.go
index 80148fe481..a224aedcb6 100644
--- a/src/internal/types/testdata/fixedbugs/issue45639.go
+++ b/src/internal/types/testdata/fixedbugs/issue45639.go
@@ -8,6 +8,6 @@ package P
 // // It is not permitted to declare a local type whose underlying
 // // type is a type parameters not declared by that type declaration.
 // func _[T any]() {
-// 	type _ T         // ERROR cannot use function type parameter T as RHS in type declaration
-// 	type _ [_ any] T // ERROR cannot use function type parameter T as RHS in type declaration
+// 	type _ T         // ERROR "cannot use function type parameter T as RHS in type declaration"
+// 	type _ [_ any] T // ERROR "cannot use function type parameter T as RHS in type declaration"
 // }
diff --git a/src/internal/types/testdata/fixedbugs/issue45920.go b/src/internal/types/testdata/fixedbugs/issue45920.go
index 0a281c5484..c769649b6e 100644
--- a/src/internal/types/testdata/fixedbugs/issue45920.go
+++ b/src/internal/types/testdata/fixedbugs/issue45920.go
@@ -8,10 +8,10 @@ func f1[T any, C chan T | <-chan T](ch C) {}
 
 func _(ch chan int)   { f1(ch) }
 func _(ch <-chan int) { f1(ch) }
-func _(ch chan<- int) { f1 /* ERROR chan<- int does not satisfy chan int \| <-chan int */ (ch) }
+func _(ch chan<- int) { f1 /* ERROR "chan<- int does not satisfy chan int \| <-chan int" */ (ch) }
 
 func f2[T any, C chan T | chan<- T](ch C) {}
 
 func _(ch chan int)   { f2(ch) }
-func _(ch <-chan int) { f2 /* ERROR <-chan int does not satisfy chan int \| chan<- int */ (ch) }
+func _(ch <-chan int) { f2 /* ERROR "<-chan int does not satisfy chan int \| chan<- int" */ (ch) }
 func _(ch chan<- int) { f2(ch) }
diff --git a/src/internal/types/testdata/fixedbugs/issue46090.go b/src/internal/types/testdata/fixedbugs/issue46090.go
index 07f0101acb..59670da7fa 100644
--- a/src/internal/types/testdata/fixedbugs/issue46090.go
+++ b/src/internal/types/testdata/fixedbugs/issue46090.go
@@ -8,4 +8,4 @@
 
 package p
 
-type _ comparable // ERROR predeclared comparable
+type _ comparable // ERROR "predeclared comparable"
diff --git a/src/internal/types/testdata/fixedbugs/issue46403.go b/src/internal/types/testdata/fixedbugs/issue46403.go
index 9d475222ad..fc60340a21 100644
--- a/src/internal/types/testdata/fixedbugs/issue46403.go
+++ b/src/internal/types/testdata/fixedbugs/issue46403.go
@@ -7,5 +7,5 @@ package issue46403
 func _() {
 	// a should be used, despite the parser error below.
 	var a []int
-	var _ = a[] // ERROR expected operand
+	var _ = a[] // ERROR "expected operand"
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue46461.go b/src/internal/types/testdata/fixedbugs/issue46461.go
index fce06f7ec7..ae70048d9b 100644
--- a/src/internal/types/testdata/fixedbugs/issue46461.go
+++ b/src/internal/types/testdata/fixedbugs/issue46461.go
@@ -5,16 +5,16 @@
 package p
 
 // test case 1
-type T /* ERROR invalid recursive type */ [U interface{ M() T[U] }] int
+type T /* ERROR "invalid recursive type" */ [U interface{ M() T[U] }] int
 
 type X int
 
 func (X) M() T[X] { return 0 }
 
 // test case 2
-type A /* ERROR invalid recursive type */ [T interface{ A[T] }] interface{}
+type A /* ERROR "invalid recursive type" */ [T interface{ A[T] }] interface{}
 
 // test case 3
-type A2 /* ERROR invalid recursive type */ [U interface{ A2[U] }] interface{ M() A2[U] }
+type A2 /* ERROR "invalid recursive type" */ [U interface{ A2[U] }] interface{ M() A2[U] }
 
 type I interface{ A2[I]; M() A2[I] }
diff --git a/src/internal/types/testdata/fixedbugs/issue46583.go b/src/internal/types/testdata/fixedbugs/issue46583.go
index da1f1ffbba..6033c5e36a 100644
--- a/src/internal/types/testdata/fixedbugs/issue46583.go
+++ b/src/internal/types/testdata/fixedbugs/issue46583.go
@@ -21,8 +21,8 @@ func (T4) m(x int) {}
 var f4 func(T4)
 
 func _() {
-	f1 = T1 /* ERROR func\(T1, int\) */ .m
-	f2 = T2 /* ERROR func\(t T2, x int\) */ .m
-	f3 = T3 /* ERROR func\(T3, int\) */ .m
-	f4 = T4 /* ERROR func\(_ T4, x int\) */ .m
+	f1 = T1 /* ERROR "func\(T1, int\)" */ .m
+	f2 = T2 /* ERROR "func\(t T2, x int\)" */ .m
+	f3 = T3 /* ERROR "func\(T3, int\)" */ .m
+	f4 = T4 /* ERROR "func\(_ T4, x int\)" */ .m
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue47031.go b/src/internal/types/testdata/fixedbugs/issue47031.go
index b184f9b5b7..e9b0bb36a6 100644
--- a/src/internal/types/testdata/fixedbugs/issue47031.go
+++ b/src/internal/types/testdata/fixedbugs/issue47031.go
@@ -7,7 +7,7 @@ package p
 type Mer interface { M() }
 
 func F[T Mer](p *T) {
-	p.M /* ERROR p\.M undefined */ ()
+	p.M /* ERROR "p\.M undefined" */ ()
 }
 
 type MyMer int
diff --git a/src/internal/types/testdata/fixedbugs/issue47115.go b/src/internal/types/testdata/fixedbugs/issue47115.go
index a0bfe38de8..f52f1d4a62 100644
--- a/src/internal/types/testdata/fixedbugs/issue47115.go
+++ b/src/internal/types/testdata/fixedbugs/issue47115.go
@@ -12,11 +12,11 @@ type C4 interface{ chan int | chan<- int }
 type C5[T any] interface{ ~chan T | chan<- T }
 
 func _[T any](ch T) {
-	ch <- /* ERROR cannot send to ch .* no core type */ 0
+	ch <- /* ERROR "cannot send to ch .* no core type" */ 0
 }
 
 func _[T C0](ch T) {
-	ch <- /* ERROR cannot send to non-channel */ 0
+	ch <- /* ERROR "cannot send to non-channel" */ 0
 }
 
 func _[T C1](ch T) {
@@ -24,11 +24,11 @@ func _[T C1](ch T) {
 }
 
 func _[T C2](ch T) {
-	ch  <-/* ERROR cannot send to receive-only channel */ 0
+	ch  <-/* ERROR "cannot send to receive-only channel" */ 0
 }
 
 func _[T C3](ch T) {
-	ch <- /* ERROR cannot send to ch .* no core type */ 0
+	ch <- /* ERROR "cannot send to ch .* no core type" */ 0
 }
 
 func _[T C4](ch T) {
diff --git a/src/internal/types/testdata/fixedbugs/issue47127.go b/src/internal/types/testdata/fixedbugs/issue47127.go
index bb4b487eb2..b6639387ea 100644
--- a/src/internal/types/testdata/fixedbugs/issue47127.go
+++ b/src/internal/types/testdata/fixedbugs/issue47127.go
@@ -8,30 +8,30 @@ package p
 
 type (
         _[P any] interface{ *P | []P | chan P | map[string]P }
-        _[P any] interface{ P /* ERROR term cannot be a type parameter */ }
-        _[P any] interface{ ~P /* ERROR type in term ~P cannot be a type parameter */ }
-        _[P any] interface{ int | P /* ERROR term cannot be a type parameter */ }
-        _[P any] interface{ int | ~P /* ERROR type in term ~P cannot be a type parameter */ }
+        _[P any] interface{ P /* ERROR "term cannot be a type parameter" */ }
+        _[P any] interface{ ~P /* ERROR "type in term ~P cannot be a type parameter" */ }
+        _[P any] interface{ int | P /* ERROR "term cannot be a type parameter" */ }
+        _[P any] interface{ int | ~P /* ERROR "type in term ~P cannot be a type parameter" */ }
 )
 
 func _[P any]() {
         type (
                 _[P any] interface{ *P | []P | chan P | map[string]P }
-                _[P any] interface{ P /* ERROR term cannot be a type parameter */ }
-                _[P any] interface{ ~P /* ERROR type in term ~P cannot be a type parameter */ }
-                _[P any] interface{ int | P /* ERROR term cannot be a type parameter */ }
-                _[P any] interface{ int | ~P /* ERROR type in term ~P cannot be a type parameter */ }
+                _[P any] interface{ P /* ERROR "term cannot be a type parameter" */ }
+                _[P any] interface{ ~P /* ERROR "type in term ~P cannot be a type parameter" */ }
+                _[P any] interface{ int | P /* ERROR "term cannot be a type parameter" */ }
+                _[P any] interface{ int | ~P /* ERROR "type in term ~P cannot be a type parameter" */ }
 
                 _ interface{ *P | []P | chan P | map[string]P }
-                _ interface{ P /* ERROR term cannot be a type parameter */ }
-                _ interface{ ~P /* ERROR type in term ~P cannot be a type parameter */ }
-                _ interface{ int | P /* ERROR term cannot be a type parameter */ }
-                _ interface{ int | ~P /* ERROR type in term ~P cannot be a type parameter */ }
+                _ interface{ P /* ERROR "term cannot be a type parameter" */ }
+                _ interface{ ~P /* ERROR "type in term ~P cannot be a type parameter" */ }
+                _ interface{ int | P /* ERROR "term cannot be a type parameter" */ }
+                _ interface{ int | ~P /* ERROR "type in term ~P cannot be a type parameter" */ }
         )
 }
 
 func _[P any, Q interface{ *P | []P | chan P | map[string]P }]() {}
-func _[P any, Q interface{ P /* ERROR term cannot be a type parameter */ }]() {}
-func _[P any, Q interface{ ~P /* ERROR type in term ~P cannot be a type parameter */ }]() {}
-func _[P any, Q interface{ int | P /* ERROR term cannot be a type parameter */ }]() {}
-func _[P any, Q interface{ int | ~P /* ERROR type in term ~P cannot be a type parameter */ }]() {}
+func _[P any, Q interface{ P /* ERROR "term cannot be a type parameter" */ }]() {}
+func _[P any, Q interface{ ~P /* ERROR "type in term ~P cannot be a type parameter" */ }]() {}
+func _[P any, Q interface{ int | P /* ERROR "term cannot be a type parameter" */ }]() {}
+func _[P any, Q interface{ int | ~P /* ERROR "type in term ~P cannot be a type parameter" */ }]() {}
diff --git a/src/internal/types/testdata/fixedbugs/issue47411.go b/src/internal/types/testdata/fixedbugs/issue47411.go
index 33b169a39e..097c4d0a57 100644
--- a/src/internal/types/testdata/fixedbugs/issue47411.go
+++ b/src/internal/types/testdata/fixedbugs/issue47411.go
@@ -15,12 +15,12 @@ func _[P comparable,
         _ = f[int]
         _ = f[P]
         _ = f[Q]
-        _ = f[func /* ERROR does not satisfy comparable */ ()]
-        _ = f[R /* ERROR R does not satisfy comparable */ ]
+        _ = f[func /* ERROR "does not satisfy comparable" */ ()]
+        _ = f[R /* ERROR "R does not satisfy comparable" */ ]
 
         _ = g[int]
-        _ = g[P /* ERROR P does not satisfy interface{interface{comparable; ~int \| ~string} */ ]
+        _ = g[P /* ERROR "P does not satisfy interface{interface{comparable; ~int \| ~string}" */ ]
         _ = g[Q]
-        _ = g[func /* ERROR func\(\) does not satisfy interface{interface{comparable; ~int \| ~string}} */ ()]
-        _ = g[R /* ERROR R does not satisfy interface{interface{comparable; ~int \| ~string} */ ]
+        _ = g[func /* ERROR "func\(\) does not satisfy interface{interface{comparable; ~int \| ~string}}" */ ()]
+        _ = g[R /* ERROR "R does not satisfy interface{interface{comparable; ~int \| ~string}" */ ]
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue47747.go b/src/internal/types/testdata/fixedbugs/issue47747.go
index 6f09fc2f57..f882b45c77 100644
--- a/src/internal/types/testdata/fixedbugs/issue47747.go
+++ b/src/internal/types/testdata/fixedbugs/issue47747.go
@@ -20,7 +20,7 @@ func _[P interface{ m() }](x P) {
         x.m()
         // (&x).m doesn't exist because &x is of type *P
         // and pointers to type parameters don't have methods
-        (&x).m /* ERROR type \*P is pointer to type parameter, not type parameter */ ()
+        (&x).m /* ERROR "type \*P is pointer to type parameter, not type parameter" */ ()
 }
 
 
@@ -29,7 +29,7 @@ type T2 interface{ m() }
 func _(x *T2) {
         // x.m doesn't exists because x is of type *T2
         // and pointers to interfaces don't have methods
-        x.m /* ERROR type \*T2 is pointer to interface, not interface */()
+        x.m /* ERROR "type \*T2 is pointer to interface, not interface" */()
 }
 
 // Test case 1 from issue
diff --git a/src/internal/types/testdata/fixedbugs/issue47796.go b/src/internal/types/testdata/fixedbugs/issue47796.go
index 4c59106e2e..7f719ff674 100644
--- a/src/internal/types/testdata/fixedbugs/issue47796.go
+++ b/src/internal/types/testdata/fixedbugs/issue47796.go
@@ -6,16 +6,16 @@ package p
 
 // parameterized types with self-recursive constraints
 type (
-	T1 /* ERROR invalid recursive type */ [P T1[P]]                            interface{}
-	T2 /* ERROR invalid recursive type */ [P, Q T2[P, Q]]                      interface{}
+	T1 /* ERROR "invalid recursive type" */ [P T1[P]]                            interface{}
+	T2 /* ERROR "invalid recursive type" */ [P, Q T2[P, Q]]                      interface{}
 	T3[P T2[P, Q], Q interface{ ~string }] interface{}
 
-	T4a /* ERROR invalid recursive type */ [P T4a[P]]                                                        interface{ ~int }
-	T4b /* ERROR invalid recursive type */ [P T4b[int]]                                                      interface{ ~int }
-	T4c /* ERROR invalid recursive type */ [P T4c[string]] interface{ ~int }
+	T4a /* ERROR "invalid recursive type" */ [P T4a[P]]                                                        interface{ ~int }
+	T4b /* ERROR "invalid recursive type" */ [P T4b[int]]                                                      interface{ ~int }
+	T4c /* ERROR "invalid recursive type" */ [P T4c[string]] interface{ ~int }
 
 	// mutually recursive constraints
-	T5 /* ERROR invalid recursive type */ [P T6[P]] interface{ int }
+	T5 /* ERROR "invalid recursive type" */ [P T6[P]] interface{ int }
 	T6[P T5[P]] interface{ int }
 )
 
@@ -28,6 +28,6 @@ var (
 
 // test case from issue
 
-type Eq /* ERROR invalid recursive type */ [a Eq[a]] interface {
+type Eq /* ERROR "invalid recursive type" */ [a Eq[a]] interface {
 	Equal(that a) bool
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue47818.go b/src/internal/types/testdata/fixedbugs/issue47818.go
index e9b0adbce9..2d172f6a7d 100644
--- a/src/internal/types/testdata/fixedbugs/issue47818.go
+++ b/src/internal/types/testdata/fixedbugs/issue47818.go
@@ -10,36 +10,36 @@
 
 package p
 
-type T[P /* ERROR type parameter requires go1\.18 or later */ any /* ERROR predeclared any requires go1\.18 or later */] struct{}
+type T[P /* ERROR "type parameter requires go1\.18 or later" */ any /* ERROR "predeclared any requires go1\.18 or later" */] struct{}
 
 // for init (and main, but we're not in package main) we should only get one error
-func init[P /* ERROR func init must have no type parameters */ any /* ERROR predeclared any requires go1\.18 or later */]() {
+func init[P /* ERROR "func init must have no type parameters" */ any /* ERROR "predeclared any requires go1\.18 or later" */]() {
 }
-func main[P /* ERROR type parameter requires go1\.18 or later */ any /* ERROR predeclared any requires go1\.18 or later */]() {
+func main[P /* ERROR "type parameter requires go1\.18 or later" */ any /* ERROR "predeclared any requires go1\.18 or later" */]() {
 }
 
-func f[P /* ERROR type parameter requires go1\.18 or later */ any /* ERROR predeclared any requires go1\.18 or later */](x P) {
-	var _ T[ /* ERROR type instantiation requires go1\.18 or later */ int]
-	var _ (T[ /* ERROR type instantiation requires go1\.18 or later */ int])
-	_ = T[ /* ERROR type instantiation requires go1\.18 or later */ int]{}
-	_ = T[ /* ERROR type instantiation requires go1\.18 or later */ int](struct{}{})
+func f[P /* ERROR "type parameter requires go1\.18 or later" */ any /* ERROR "predeclared any requires go1\.18 or later" */](x P) {
+	var _ T[ /* ERROR "type instantiation requires go1\.18 or later" */ int]
+	var _ (T[ /* ERROR "type instantiation requires go1\.18 or later" */ int])
+	_ = T[ /* ERROR "type instantiation requires go1\.18 or later" */ int]{}
+	_ = T[ /* ERROR "type instantiation requires go1\.18 or later" */ int](struct{}{})
 }
 
-func (T[ /* ERROR type instantiation requires go1\.18 or later */ P]) g(x int) {
-	f[ /* ERROR function instantiation requires go1\.18 or later */ int](0)     // explicit instantiation
-	(f[ /* ERROR function instantiation requires go1\.18 or later */ int])(0)   // parentheses (different code path)
-	f( /* ERROR implicit function instantiation requires go1\.18 or later */ x) // implicit instantiation
+func (T[ /* ERROR "type instantiation requires go1\.18 or later" */ P]) g(x int) {
+	f[ /* ERROR "function instantiation requires go1\.18 or later" */ int](0)     // explicit instantiation
+	(f[ /* ERROR "function instantiation requires go1\.18 or later" */ int])(0)   // parentheses (different code path)
+	f( /* ERROR "implicit function instantiation requires go1\.18 or later" */ x) // implicit instantiation
 }
 
 type C1 interface {
-	comparable // ERROR predeclared comparable requires go1\.18 or later
+	comparable // ERROR "predeclared comparable requires go1\.18 or later"
 }
 
 type C2 interface {
-	comparable // ERROR predeclared comparable requires go1\.18 or later
-	int        // ERROR embedding non-interface type int requires go1\.18 or later
-	~ /* ERROR embedding interface element ~int requires go1\.18 or later */ int
-	int /* ERROR embedding interface element int \| ~string requires go1\.18 or later */ | ~string
+	comparable // ERROR "predeclared comparable requires go1\.18 or later"
+	int        // ERROR "embedding non-interface type int requires go1\.18 or later"
+	~ /* ERROR "embedding interface element ~int requires go1\.18 or later" */ int
+	int /* ERROR "embedding interface element int \| ~string requires go1\.18 or later" */ | ~string
 }
 
 type _ interface {
@@ -49,12 +49,12 @@ type _ interface {
 }
 
 type (
-	_ comparable // ERROR predeclared comparable requires go1\.18 or later
+	_ comparable // ERROR "predeclared comparable requires go1\.18 or later"
 	// errors for these were reported with their declaration
 	_ C1
 	_ C2
 
-	_ = comparable // ERROR predeclared comparable requires go1\.18 or later
+	_ = comparable // ERROR "predeclared comparable requires go1\.18 or later"
 	// errors for these were reported with their declaration
 	_ = C1
 	_ = C2
diff --git a/src/internal/types/testdata/fixedbugs/issue47968.go b/src/internal/types/testdata/fixedbugs/issue47968.go
index 3dd303957c..35c7354e17 100644
--- a/src/internal/types/testdata/fixedbugs/issue47968.go
+++ b/src/internal/types/testdata/fixedbugs/issue47968.go
@@ -8,14 +8,14 @@ type T[P any] struct{}
 
 func (T[P]) m1()
 
-type A1 = T // ERROR cannot use generic type
+type A1 = T // ERROR "cannot use generic type"
 
 func (A1[P]) m2() {}
 
 type A2 = T[int]
 
-func (A2 /* ERROR cannot define new methods on instantiated type T\[int\] */) m3()   {}
-func (_ /* ERROR cannot define new methods on instantiated type T\[int\] */ A2) m4() {}
+func (A2 /* ERROR "cannot define new methods on instantiated type T\[int\]" */) m3()   {}
+func (_ /* ERROR "cannot define new methods on instantiated type T\[int\]" */ A2) m4() {}
 
 func (T[int]) m5()                                     {} // int is the type parameter name, not an instantiation
-func (T[* /* ERROR must be an identifier */ int]) m6() {} // syntax error
+func (T[* /* ERROR "must be an identifier" */ int]) m6() {} // syntax error
diff --git a/src/internal/types/testdata/fixedbugs/issue48008.go b/src/internal/types/testdata/fixedbugs/issue48008.go
index 6c14c78e4c..6615fa8c86 100644
--- a/src/internal/types/testdata/fixedbugs/issue48008.go
+++ b/src/internal/types/testdata/fixedbugs/issue48008.go
@@ -21,17 +21,17 @@ func _(x interface{}) {
 	case map[T[int]] string:
 	case chan T[int]:
 
-	case T /* ERROR cannot use generic type T\[P any\] without instantiation */ :
-	case []T /* ERROR cannot use generic type */ :
-	case [10]T /* ERROR cannot use generic type */ :
-	case struct{T /* ERROR cannot use generic type */ }:
-	case *T /* ERROR cannot use generic type */ :
-	case func(T /* ERROR cannot use generic type */ ):
-	case interface{m(T /* ERROR cannot use generic type */ )}:
-	case map[T /* ERROR cannot use generic type */ ] string:
-	case chan T /* ERROR cannot use generic type */ :
-
-	case T /* ERROR cannot use generic type */ , *T /* ERROR cannot use generic type */ :
+	case T /* ERROR "cannot use generic type T\[P any\] without instantiation" */ :
+	case []T /* ERROR "cannot use generic type" */ :
+	case [10]T /* ERROR "cannot use generic type" */ :
+	case struct{T /* ERROR "cannot use generic type" */ }:
+	case *T /* ERROR "cannot use generic type" */ :
+	case func(T /* ERROR "cannot use generic type" */ ):
+	case interface{m(T /* ERROR "cannot use generic type" */ )}:
+	case map[T /* ERROR "cannot use generic type" */ ] string:
+	case chan T /* ERROR "cannot use generic type" */ :
+
+	case T /* ERROR "cannot use generic type" */ , *T /* ERROR "cannot use generic type" */ :
 	}
 }
 
@@ -55,6 +55,6 @@ func _(x interface{}) {
 func _(x interface{}) {
 	var nil int
 	switch x.(type) {
-	case nil /* ERROR not a type */ : // not ok - this is the variable nil
+	case nil /* ERROR "not a type" */ : // not ok - this is the variable nil
 	}
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue48018.go b/src/internal/types/testdata/fixedbugs/issue48018.go
index e6ccc6b9be..3df908acb5 100644
--- a/src/internal/types/testdata/fixedbugs/issue48018.go
+++ b/src/internal/types/testdata/fixedbugs/issue48018.go
@@ -8,7 +8,7 @@ type Box[A any] struct {
 	value A
 }
 
-func Nest[A /* ERROR instantiation cycle */ any](b Box[A], n int) interface{} {
+func Nest[A /* ERROR "instantiation cycle" */ any](b Box[A], n int) interface{} {
 	if n == 0 {
 		return b
 	}
diff --git a/src/internal/types/testdata/fixedbugs/issue48048.go b/src/internal/types/testdata/fixedbugs/issue48048.go
index f401330621..98a03eabdf 100644
--- a/src/internal/types/testdata/fixedbugs/issue48048.go
+++ b/src/internal/types/testdata/fixedbugs/issue48048.go
@@ -11,5 +11,5 @@ func (T[_]) A() {}
 var _ = (T[int]).A
 var _ = (*T[int]).A
 
-var _ = (T /* ERROR cannot use generic type */).A
-var _ = (*T /* ERROR cannot use generic type */).A
+var _ = (T /* ERROR "cannot use generic type" */).A
+var _ = (*T /* ERROR "cannot use generic type" */).A
diff --git a/src/internal/types/testdata/fixedbugs/issue48082.go b/src/internal/types/testdata/fixedbugs/issue48082.go
index 5395154978..648c512ea2 100644
--- a/src/internal/types/testdata/fixedbugs/issue48082.go
+++ b/src/internal/types/testdata/fixedbugs/issue48082.go
@@ -4,4 +4,4 @@
 
 package issue48082
 
-import "init" /* ERROR init must be a func */ /* ERROR could not import init */
+import "init" /* ERROR "init must be a func" */ /* ERROR "could not import init" */
diff --git a/src/internal/types/testdata/fixedbugs/issue48083.go b/src/internal/types/testdata/fixedbugs/issue48083.go
index 3dae51415d..15e9b70d1d 100644
--- a/src/internal/types/testdata/fixedbugs/issue48083.go
+++ b/src/internal/types/testdata/fixedbugs/issue48083.go
@@ -6,4 +6,4 @@ package p
 
 type T[P any] struct{}
 
-type _ interface{ int | T /* ERROR cannot use generic type */ }
\ No newline at end of file
+type _ interface{ int | T /* ERROR "cannot use generic type" */ }
\ No newline at end of file
diff --git a/src/internal/types/testdata/fixedbugs/issue48136.go b/src/internal/types/testdata/fixedbugs/issue48136.go
index b87f84ae64..b76322e855 100644
--- a/src/internal/types/testdata/fixedbugs/issue48136.go
+++ b/src/internal/types/testdata/fixedbugs/issue48136.go
@@ -12,12 +12,12 @@ func f5[P interface{ func(P) }]() {}
 func f6[P interface { *Tree[P] }, Q any ]() {}
 
 func _() {
-        f1 /* ERROR cannot infer P */ ()
-        f2 /* ERROR cannot infer P */ ()
-        f3 /* ERROR cannot infer P */ ()
-        f4 /* ERROR cannot infer P */ ()
-        f5 /* ERROR cannot infer P */ ()
-        f6 /* ERROR cannot infer P */ ()
+        f1 /* ERROR "cannot infer P" */ ()
+        f2 /* ERROR "cannot infer P" */ ()
+        f3 /* ERROR "cannot infer P" */ ()
+        f4 /* ERROR "cannot infer P" */ ()
+        f5 /* ERROR "cannot infer P" */ ()
+        f6 /* ERROR "cannot infer P" */ ()
 }
 
 type Tree[P any] struct {
@@ -32,5 +32,5 @@ func foo[Src interface { func() Src }]() Src {
 }
 
 func _() {
-        foo /* ERROR cannot infer Src */ ()
+        foo /* ERROR "cannot infer Src" */ ()
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue48312.go b/src/internal/types/testdata/fixedbugs/issue48312.go
index 2fdb7cad94..bf52527f80 100644
--- a/src/internal/types/testdata/fixedbugs/issue48312.go
+++ b/src/internal/types/testdata/fixedbugs/issue48312.go
@@ -8,13 +8,13 @@ type T interface{ m() }
 type P *T
 
 func _(p *T) {
-	p.m /* ERROR type \*T is pointer to interface, not interface */ ()
+	p.m /* ERROR "type \*T is pointer to interface, not interface" */ ()
 }
 
 func _(p P) {
-	p.m /* ERROR type P is pointer to interface, not interface */ ()
+	p.m /* ERROR "type P is pointer to interface, not interface" */ ()
 }
 
 func _[P T](p *P) {
-	p.m /* ERROR type \*P is pointer to type parameter, not type parameter */ ()
+	p.m /* ERROR "type \*P is pointer to type parameter, not type parameter" */ ()
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue48472.go b/src/internal/types/testdata/fixedbugs/issue48472.go
index 2d908f4c8b..f43fa3b73e 100644
--- a/src/internal/types/testdata/fixedbugs/issue48472.go
+++ b/src/internal/types/testdata/fixedbugs/issue48472.go
@@ -7,10 +7,10 @@ package p
 func g() {
 	var s string
 	var i int
-	_ = s /* ERROR invalid operation: s \+ i \(mismatched types string and int\) */ + i
+	_ = s /* ERROR "invalid operation: s \+ i \(mismatched types string and int\)" */ + i
 }
 
 func f(i int) int {
-        i /* ERROR invalid operation: i \+= "1" \(mismatched types int and untyped string\) */ += "1"
+        i /* ERROR "invalid operation: i \+= "1" \(mismatched types int and untyped string\)" */ += "1"
         return i
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue48529.go b/src/internal/types/testdata/fixedbugs/issue48529.go
index d7a70b166f..bcc5e3536d 100644
--- a/src/internal/types/testdata/fixedbugs/issue48529.go
+++ b/src/internal/types/testdata/fixedbugs/issue48529.go
@@ -4,7 +4,7 @@
 
 package p
 
-type T /* ERROR invalid recursive type */ [U interface{ M() T[U, int] }] int
+type T /* ERROR "invalid recursive type" */ [U interface{ M() T[U, int] }] int
 
 type X int
 
diff --git a/src/internal/types/testdata/fixedbugs/issue48582.go b/src/internal/types/testdata/fixedbugs/issue48582.go
index 9e1d526abf..8ffcd5a8c2 100644
--- a/src/internal/types/testdata/fixedbugs/issue48582.go
+++ b/src/internal/types/testdata/fixedbugs/issue48582.go
@@ -4,11 +4,11 @@
 
 package p
 
-type N /* ERROR invalid recursive type */ interface {
+type N /* ERROR "invalid recursive type" */ interface {
 	int | N
 }
 
-type A /* ERROR invalid recursive type */ interface {
+type A /* ERROR "invalid recursive type" */ interface {
 	int | B
 }
 
@@ -16,8 +16,8 @@ type B interface {
 	int | A
 }
 
-type S /* ERROR invalid recursive type */ struct {
-	I // ERROR interface contains type constraints
+type S /* ERROR "invalid recursive type" */ struct {
+	I // ERROR "interface contains type constraints"
 }
 
 type I interface {
@@ -25,5 +25,5 @@ type I interface {
 }
 
 type P interface {
-	*P // ERROR interface contains type constraints
+	*P // ERROR "interface contains type constraints"
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue48619.go b/src/internal/types/testdata/fixedbugs/issue48619.go
index 72eea1ef59..fc5dce0ad5 100644
--- a/src/internal/types/testdata/fixedbugs/issue48619.go
+++ b/src/internal/types/testdata/fixedbugs/issue48619.go
@@ -7,8 +7,8 @@ package p
 func f[P any](a, _ P) {
 	var x int
 	// TODO(gri) these error messages, while correct, could be better
-	f(a, x /* ERROR type int of x does not match inferred type P for P */)
-	f(x, a /* ERROR type P of a does not match inferred type int for P */)
+	f(a, x /* ERROR "type int of x does not match inferred type P for P" */)
+	f(x, a /* ERROR "type P of a does not match inferred type int for P" */)
 }
 
 func g[P any](a, b P) {
diff --git a/src/internal/types/testdata/fixedbugs/issue48656.go b/src/internal/types/testdata/fixedbugs/issue48656.go
index 0f60f47120..f77e08a4c1 100644
--- a/src/internal/types/testdata/fixedbugs/issue48656.go
+++ b/src/internal/types/testdata/fixedbugs/issue48656.go
@@ -8,6 +8,6 @@ func f[P *Q, Q any](P, Q) {
 	_ = f[P]
 }
 
-func f2[P /* ERROR instantiation cycle */ *Q, Q any](P, Q) {
+func f2[P /* ERROR "instantiation cycle" */ *Q, Q any](P, Q) {
 	_ = f2[*P]
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue48703.go b/src/internal/types/testdata/fixedbugs/issue48703.go
index 8a32c1ecf2..89c667b2e9 100644
--- a/src/internal/types/testdata/fixedbugs/issue48703.go
+++ b/src/internal/types/testdata/fixedbugs/issue48703.go
@@ -14,7 +14,7 @@ func (_ List[P]) m() (_ List[List[P]]) { return }
 // Other types of recursion through methods.
 type R[P any] int
 
-func (*R[R /* ERROR must be an identifier */ [int]]) m0() {}
+func (*R[R /* ERROR "must be an identifier" */ [int]]) m0() {}
 func (R[P]) m1(R[R[P]])                                   {}
 func (R[P]) m2(R[*P])                                     {}
 func (R[P]) m3([unsafe.Sizeof(new(R[P]))]int)             {}
diff --git a/src/internal/types/testdata/fixedbugs/issue48712.go b/src/internal/types/testdata/fixedbugs/issue48712.go
index 63ce7bc510..76ad16cd8f 100644
--- a/src/internal/types/testdata/fixedbugs/issue48712.go
+++ b/src/internal/types/testdata/fixedbugs/issue48712.go
@@ -10,7 +10,7 @@ func _[P comparable](x, y P) {
 	_ = y == x
 	_ = y == y
 
-	_ = x /* ERROR type parameter P is not comparable with < */ < y
+	_ = x /* ERROR "type parameter P is not comparable with <" */ < y
 }
 
 func _[P comparable](x P, y any) {
@@ -19,23 +19,23 @@ func _[P comparable](x P, y any) {
 	_ = y == x
 	_ = y == y
 
-	_ = x /* ERROR type parameter P is not comparable with < */ < y
+	_ = x /* ERROR "type parameter P is not comparable with <" */ < y
 }
 
 func _[P any](x, y P) {
-	_ = x /* ERROR incomparable types in type set */ == x
-	_ = x /* ERROR incomparable types in type set */ == y
-	_ = y /* ERROR incomparable types in type set */ == x
-	_ = y /* ERROR incomparable types in type set */ == y
+	_ = x /* ERROR "incomparable types in type set" */ == x
+	_ = x /* ERROR "incomparable types in type set" */ == y
+	_ = y /* ERROR "incomparable types in type set" */ == x
+	_ = y /* ERROR "incomparable types in type set" */ == y
 
-	_ = x /* ERROR type parameter P is not comparable with < */ < y
+	_ = x /* ERROR "type parameter P is not comparable with <" */ < y
 }
 
 func _[P any](x P, y any) {
-	_ = x /* ERROR incomparable types in type set */ == x
-	_ = x /* ERROR incomparable types in type set */ == y
-	_ = y == x // ERROR incomparable types in type set
+	_ = x /* ERROR "incomparable types in type set" */ == x
+	_ = x /* ERROR "incomparable types in type set" */ == y
+	_ = y == x // ERROR "incomparable types in type set"
 	_ = y == y
 
-	_ = x /* ERROR type parameter P is not comparable with < */ < y
+	_ = x /* ERROR "type parameter P is not comparable with <" */ < y
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue48819.go b/src/internal/types/testdata/fixedbugs/issue48819.go
index 5d61803687..916faaffef 100644
--- a/src/internal/types/testdata/fixedbugs/issue48819.go
+++ b/src/internal/types/testdata/fixedbugs/issue48819.go
@@ -6,7 +6,7 @@ package p
 
 import "unsafe"
 
-type T /* ERROR invalid recursive type: T refers to itself */ struct {
+type T /* ERROR "invalid recursive type: T refers to itself" */ struct {
 	T
 }
 
diff --git a/src/internal/types/testdata/fixedbugs/issue48951.go b/src/internal/types/testdata/fixedbugs/issue48951.go
index c94b027799..8d6f8500e4 100644
--- a/src/internal/types/testdata/fixedbugs/issue48951.go
+++ b/src/internal/types/testdata/fixedbugs/issue48951.go
@@ -5,17 +5,17 @@
 package p
 
 type (
-        A1[P any] [10]A1 /* ERROR invalid recursive type */ [P]
-        A2[P any] [10]A2 /* ERROR invalid recursive type */ [*P]
+        A1[P any] [10]A1 /* ERROR "invalid recursive type" */ [P]
+        A2[P any] [10]A2 /* ERROR "invalid recursive type" */ [*P]
         A3[P any] [10]*A3[P]
 
         L1[P any] []L1[P]
 
-        S1[P any] struct{ f S1 /* ERROR invalid recursive type */ [P] }
-        S2[P any] struct{ f S2 /* ERROR invalid recursive type */ [*P] } // like example in issue
+        S1[P any] struct{ f S1 /* ERROR "invalid recursive type" */ [P] }
+        S2[P any] struct{ f S2 /* ERROR "invalid recursive type" */ [*P] } // like example in issue
         S3[P any] struct{ f *S3[P] }
 
-        I1[P any] interface{ I1 /* ERROR invalid recursive type */ [P] }
-        I2[P any] interface{ I2 /* ERROR invalid recursive type */ [*P] }
-        I3[P any] interface{ *I3 /* ERROR interface contains type constraints */ [P] }
+        I1[P any] interface{ I1 /* ERROR "invalid recursive type" */ [P] }
+        I2[P any] interface{ I2 /* ERROR "invalid recursive type" */ [*P] }
+        I3[P any] interface{ *I3 /* ERROR "interface contains type constraints" */ [P] }
 )
diff --git a/src/internal/types/testdata/fixedbugs/issue48962.go b/src/internal/types/testdata/fixedbugs/issue48962.go
index 05c681dcb9..4294cf0861 100644
--- a/src/internal/types/testdata/fixedbugs/issue48962.go
+++ b/src/internal/types/testdata/fixedbugs/issue48962.go
@@ -8,6 +8,6 @@ type T0[P any] struct {
 	f P
 }
 
-type T1 /* ERROR invalid recursive type */ struct {
+type T1 /* ERROR "invalid recursive type" */ struct {
 	_ T0[T1]
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue48974.go b/src/internal/types/testdata/fixedbugs/issue48974.go
index d8ff7c8cf4..08d8656a06 100644
--- a/src/internal/types/testdata/fixedbugs/issue48974.go
+++ b/src/internal/types/testdata/fixedbugs/issue48974.go
@@ -8,7 +8,7 @@ type Fooer interface {
 	Foo()
 }
 
-type Fooable[F /* ERROR instantiation cycle */ Fooer] struct {
+type Fooable[F /* ERROR "instantiation cycle" */ Fooer] struct {
 	ptr F
 }
 
diff --git a/src/internal/types/testdata/fixedbugs/issue49003.go b/src/internal/types/testdata/fixedbugs/issue49003.go
index ece1a27bb9..bf2e6c4d11 100644
--- a/src/internal/types/testdata/fixedbugs/issue49003.go
+++ b/src/internal/types/testdata/fixedbugs/issue49003.go
@@ -7,4 +7,4 @@ package p
 func f(s string) int {
 	for range s {
 	}
-} // ERROR missing return
+} // ERROR "missing return"
diff --git a/src/internal/types/testdata/fixedbugs/issue49005.go b/src/internal/types/testdata/fixedbugs/issue49005.go
index 5f551b9b8c..470312b797 100644
--- a/src/internal/types/testdata/fixedbugs/issue49005.go
+++ b/src/internal/types/testdata/fixedbugs/issue49005.go
@@ -8,11 +8,11 @@ type T1 interface{ M() }
 
 func F1() T1
 
-var _ = F1().(*X1 /* ERROR undefined: X1 */)
+var _ = F1().(*X1 /* ERROR "undefined: X1" */)
 
 func _() {
 	switch F1().(type) {
-	case *X1 /* ERROR undefined: X1 */ :
+	case *X1 /* ERROR "undefined: X1" */ :
 	}
 }
 
@@ -20,12 +20,12 @@ type T2 interface{ M() }
 
 func F2() T2
 
-var _ = F2 /* ERROR impossible type assertion: F2\(\)\.\(\*X2\)\n\t\*X2 does not implement T2 \(missing method M\) */ ().(*X2)
+var _ = F2 /* ERROR "impossible type assertion: F2\(\)\.\(\*X2\)\n\t\*X2 does not implement T2 \(missing method M\)" */ ().(*X2)
 
 type X2 struct{}
 
 func _() {
 	switch F2().(type) {
-	case * /* ERROR impossible type switch case: \*X2\n\tF2\(\) \(value of type T2\) cannot have dynamic type \*X2 \(missing method M\) */ X2:
+	case * /* ERROR "impossible type switch case: \*X2\n\tF2\(\) \(value of type T2\) cannot have dynamic type \*X2 \(missing method M\)" */ X2:
 	}
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue49043.go b/src/internal/types/testdata/fixedbugs/issue49043.go
index 3971cf89df..7594b3277c 100644
--- a/src/internal/types/testdata/fixedbugs/issue49043.go
+++ b/src/internal/types/testdata/fixedbugs/issue49043.go
@@ -6,13 +6,13 @@ package p
 
 // The example from the issue.
 type (
-	N[P any] M /* ERROR invalid recursive type */ [P]
+	N[P any] M /* ERROR "invalid recursive type" */ [P]
 	M[P any] N[P]
 )
 
 // A slightly more complicated case.
 type (
-	A[P any] B /* ERROR invalid recursive type */ [P]
+	A[P any] B /* ERROR "invalid recursive type" */ [P]
 	B[P any] C[P]
 	C[P any] A[P]
 )
diff --git a/src/internal/types/testdata/fixedbugs/issue49112.go b/src/internal/types/testdata/fixedbugs/issue49112.go
index dea2608219..4ce0442ac6 100644
--- a/src/internal/types/testdata/fixedbugs/issue49112.go
+++ b/src/internal/types/testdata/fixedbugs/issue49112.go
@@ -8,8 +8,8 @@ func f[P int](P) {}
 
 func _() {
         _ = f[int]
-        _ = f[[ /* ERROR \[\]int does not satisfy int */ ]int]
+        _ = f[[ /* ERROR "\[\]int does not satisfy int" */ ]int]
 
         f(0)
-        f/* ERROR \[\]int does not satisfy int */ ([]int{})
+        f/* ERROR "\[\]int does not satisfy int" */ ([]int{})
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue49179.go b/src/internal/types/testdata/fixedbugs/issue49179.go
index 2ddfa3312d..f6d38a96f2 100644
--- a/src/internal/types/testdata/fixedbugs/issue49179.go
+++ b/src/internal/types/testdata/fixedbugs/issue49179.go
@@ -13,11 +13,11 @@ type myFloat float64
 
 func _() {
 	_ = f1[int]
-	_ = f1[myInt /* ERROR possibly missing ~ for int in int \| string */]
+	_ = f1[myInt /* ERROR "possibly missing ~ for int in int \| string" */]
 	_ = f2[myInt]
-	_ = f2[myFloat /* ERROR possibly missing ~ for float64 in ~int \| string \| float64 */]
+	_ = f2[myFloat /* ERROR "possibly missing ~ for float64 in ~int \| string \| float64" */]
 	var x myInt
-	f3 /* ERROR myInt does not satisfy int \(possibly missing ~ for int in int\) */ (x)
+	f3 /* ERROR "myInt does not satisfy int \(possibly missing ~ for int in int\)" */ (x)
 }
 
 // test case from the issue
@@ -33,5 +33,5 @@ func Map[S SliceConstraint[E], E any](s S, f func(E) E) S {
 type MySlice []int
 
 func f(s MySlice) {
-	Map[MySlice /* ERROR MySlice does not satisfy SliceConstraint\[int\] \(possibly missing ~ for \[\]int in SliceConstraint\[int\]\) */, int](s, nil)
+	Map[MySlice /* ERROR "MySlice does not satisfy SliceConstraint\[int\] \(possibly missing ~ for \[\]int in SliceConstraint\[int\]\)" */, int](s, nil)
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue49242.go b/src/internal/types/testdata/fixedbugs/issue49242.go
index 524a0cbae3..ed54859c4d 100644
--- a/src/internal/types/testdata/fixedbugs/issue49242.go
+++ b/src/internal/types/testdata/fixedbugs/issue49242.go
@@ -5,23 +5,23 @@
 package p
 
 func _[P int](x P) int {
-	return x // ERROR cannot use x .* as int value in return statement
+	return x // ERROR "cannot use x .* as int value in return statement"
 }
 
 func _[P int]() int {
-	return P /* ERROR cannot use P\(1\) .* as int value in return statement */ (1)
+	return P /* ERROR "cannot use P\(1\) .* as int value in return statement" */ (1)
 }
 
 func _[P int](x int) P {
-        return x // ERROR cannot use x .* as P value in return statement
+        return x // ERROR "cannot use x .* as P value in return statement"
 }
 
 func _[P, Q any](x P) Q {
-        return x // ERROR cannot use x .* as Q value in return statement
+        return x // ERROR "cannot use x .* as Q value in return statement"
 }
 
 // test case from issue
 func F[G interface{ uint }]() int {
 	f := func(uint) int { return 0 }
-	return f(G /* ERROR cannot use G\(1\) .* as uint value in argument to f */ (1))
+	return f(G /* ERROR "cannot use G\(1\) .* as uint value in argument to f" */ (1))
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue49247.go b/src/internal/types/testdata/fixedbugs/issue49247.go
index 5be6001c7d..b1bd42c522 100644
--- a/src/internal/types/testdata/fixedbugs/issue49247.go
+++ b/src/internal/types/testdata/fixedbugs/issue49247.go
@@ -11,10 +11,10 @@ type integer interface {
 
 func Add1024[T integer](s []T) {
 	for i, v := range s {
-		s[i] = v + 1024 // ERROR cannot convert 1024 \(untyped int constant\) to type T
+		s[i] = v + 1024 // ERROR "cannot convert 1024 \(untyped int constant\) to type T"
 	}
 }
 
 func f[T interface{ int8 }]() {
-	println(T(1024 /* ERROR cannot convert 1024 \(untyped int value\) to type T */))
+	println(T(1024 /* ERROR "cannot convert 1024 \(untyped int value\) to type T" */))
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue49276.go b/src/internal/types/testdata/fixedbugs/issue49276.go
index ab5794a1c5..bdfb42f407 100644
--- a/src/internal/types/testdata/fixedbugs/issue49276.go
+++ b/src/internal/types/testdata/fixedbugs/issue49276.go
@@ -6,7 +6,7 @@ package p
 
 import "unsafe"
 
-type S /* ERROR invalid recursive type S */ struct {
+type S /* ERROR "invalid recursive type S" */ struct {
 	_ [unsafe.Sizeof(s)]byte
 }
 
@@ -15,7 +15,7 @@ var s S
 // Since f is a pointer, this case could be valid.
 // But it's pathological and not worth the expense.
 type T struct {
-	f *[unsafe.Sizeof(T /* ERROR invalid recursive type */ {})]int
+	f *[unsafe.Sizeof(T /* ERROR "invalid recursive type" */ {})]int
 }
 
 // a mutually recursive case using unsafe.Sizeof
@@ -25,7 +25,7 @@ type (
 	}
 
 	B1 struct {
-		_ [unsafe.Sizeof(A1 /* ERROR invalid recursive type */ {})]int
+		_ [unsafe.Sizeof(A1 /* ERROR "invalid recursive type" */ {})]int
 	}
 )
 
@@ -36,11 +36,11 @@ type (
 	}
 
 	B2 struct {
-		f [len(A2 /* ERROR invalid recursive type */ {}.f)]int
+		f [len(A2 /* ERROR "invalid recursive type" */ {}.f)]int
 	}
 )
 
 // test case from issue
 type a struct {
-	_ [42 - unsafe.Sizeof(a /* ERROR invalid recursive type */ {})]byte
+	_ [42 - unsafe.Sizeof(a /* ERROR "invalid recursive type" */ {})]byte
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue49296.go b/src/internal/types/testdata/fixedbugs/issue49296.go
index 98ad6f5409..ac742ab3a3 100644
--- a/src/internal/types/testdata/fixedbugs/issue49296.go
+++ b/src/internal/types/testdata/fixedbugs/issue49296.go
@@ -9,12 +9,12 @@ func _[
         T1 []int,
         T2 ~float64 | ~complex128 | chan int,
 ]() {
-        _ = T0(nil /* ERROR cannot convert nil to type T0 */ )
-        _ = T1(1 /* ERROR cannot convert 1 .* to type T1 */ )
-        _ = T2(2 /* ERROR cannot convert 2 .* to type T2 */ )
+        _ = T0(nil /* ERROR "cannot convert nil to type T0" */ )
+        _ = T1(1 /* ERROR "cannot convert 1 .* to type T1" */ )
+        _ = T2(2 /* ERROR "cannot convert 2 .* to type T2" */ )
 }
 
 // test case from issue
 func f[T interface{[]int}]() {
-	_ = T(1 /* ERROR cannot convert */ )
+	_ = T(1 /* ERROR "cannot convert" */ )
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue49439.go b/src/internal/types/testdata/fixedbugs/issue49439.go
index b8ad4955ab..3852f16094 100644
--- a/src/internal/types/testdata/fixedbugs/issue49439.go
+++ b/src/internal/types/testdata/fixedbugs/issue49439.go
@@ -6,12 +6,12 @@ package p
 
 import "unsafe"
 
-type T0 /* ERROR invalid recursive type */ [P T0[P]] struct{}
+type T0 /* ERROR "invalid recursive type" */ [P T0[P]] struct{}
 
-type T1 /* ERROR invalid recursive type */ [P T2[P]] struct{}
+type T1 /* ERROR "invalid recursive type" */ [P T2[P]] struct{}
 type T2[P T1[P]] struct{}
 
-type T3 /* ERROR invalid recursive type */ [P interface{ ~struct{ f T3[int] } }] struct{}
+type T3 /* ERROR "invalid recursive type" */ [P interface{ ~struct{ f T3[int] } }] struct{}
 
 // valid cycle in M
 type N[P M[P]] struct{}
@@ -23,4 +23,4 @@ type TC[P [unsafe.Sizeof(func() {
 })]byte] struct{}
 
 // test case from issue
-type X /* ERROR invalid recursive type */ [T any, PT X[T]] interface{}
+type X /* ERROR "invalid recursive type" */ [T any, PT X[T]] interface{}
diff --git a/src/internal/types/testdata/fixedbugs/issue49482.go b/src/internal/types/testdata/fixedbugs/issue49482.go
index 2b9e7482c8..b050be0fb8 100644
--- a/src/internal/types/testdata/fixedbugs/issue49482.go
+++ b/src/internal/types/testdata/fixedbugs/issue49482.go
@@ -13,7 +13,7 @@ const P = 2 // declare P to avoid noisy 'undefined' errors below.
 
 // The following parse as invalid array types due to parsing ambiguitiues.
 type _ [P *int /* ERROR "int \(type\) is not an expression" */ ]int
-type _ [P /* ERROR non-function P */ (*int)]int
+type _ [P /* ERROR "non-function P" */ (*int)]int
 
 // Adding a trailing comma or an enclosing interface resolves the ambiguity.
 type _[P *int,] int
diff --git a/src/internal/types/testdata/fixedbugs/issue49541.go b/src/internal/types/testdata/fixedbugs/issue49541.go
index c8499c1b61..d309abf058 100644
--- a/src/internal/types/testdata/fixedbugs/issue49541.go
+++ b/src/internal/types/testdata/fixedbugs/issue49541.go
@@ -13,7 +13,7 @@ func (S[A, B]) m() {}
 // TODO(gri): with type-type inference enabled we should only report one error
 // below. See issue #50588.
 
-func _[A any](s S /* ERROR got 1 arguments but 2 type parameters */ [A]) {
+func _[A any](s S /* ERROR "got 1 arguments but 2 type parameters" */ [A]) {
 	// we should see no follow-on errors below
 	s.f = 1
 	s.m()
@@ -22,7 +22,7 @@ func _[A any](s S /* ERROR got 1 arguments but 2 type parameters */ [A]) {
 // another test case from the issue
 
 func _() {
-	X(Interface[*F /* ERROR got 1 arguments but 2 type parameters */ [string]](Impl{}))
+	X(Interface[*F /* ERROR "got 1 arguments but 2 type parameters" */ [string]](Impl{}))
 }
 
 func X[Q Qer](fs Interface[Q]) {
diff --git a/src/internal/types/testdata/fixedbugs/issue49579.go b/src/internal/types/testdata/fixedbugs/issue49579.go
index ee2d94ab89..0d159763c0 100644
--- a/src/internal/types/testdata/fixedbugs/issue49579.go
+++ b/src/internal/types/testdata/fixedbugs/issue49579.go
@@ -9,7 +9,7 @@ type I[F any] interface {
 }
 
 func G[F any]() I[any] {
-	return g /* ERROR cannot use g\[F\]{} .* as I\[any\] value in return statement: g\[F\] does not implement I\[any\] \(method Q has pointer receiver\) */ [F]{}
+	return g /* ERROR "cannot use g\[F\]{} .* as I\[any\] value in return statement: g\[F\] does not implement I\[any\] \(method Q has pointer receiver\)" */ [F]{}
 }
 
 type g[F any] struct{}
diff --git a/src/internal/types/testdata/fixedbugs/issue49602.go b/src/internal/types/testdata/fixedbugs/issue49602.go
index 208501fafd..40fb2e3c1c 100644
--- a/src/internal/types/testdata/fixedbugs/issue49602.go
+++ b/src/internal/types/testdata/fixedbugs/issue49602.go
@@ -13,7 +13,7 @@ type C interface {
 }
 
 type _ interface {
-	int | M          // ERROR cannot use p\.M in union \(p\.M contains methods\)
-	int | comparable // ERROR cannot use comparable in union
-	int | C          // ERROR cannot use p\.C in union \(p\.C embeds comparable\)
+	int | M          // ERROR "cannot use p\.M in union \(p\.M contains methods\)"
+	int | comparable // ERROR "cannot use comparable in union"
+	int | C          // ERROR "cannot use p\.C in union \(p\.C embeds comparable\)"
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue49735.go b/src/internal/types/testdata/fixedbugs/issue49735.go
index 50870226e4..c1e31e9f8c 100644
--- a/src/internal/types/testdata/fixedbugs/issue49735.go
+++ b/src/internal/types/testdata/fixedbugs/issue49735.go
@@ -5,7 +5,7 @@
 package p
 
 func _[P1 any, P2 ~byte](s1 P1, s2 P2) {
-        _ = append(nil /* ERROR first argument to append must be a slice; have untyped nil */ , 0)
-        _ = append(s1 /* ERROR s1 .* has no core type */ , 0)
-        _ = append(s2 /* ERROR s2 .* has core type byte */ , 0)
+        _ = append(nil /* ERROR "first argument to append must be a slice; have untyped nil" */ , 0)
+        _ = append(s1 /* ERROR "s1 .* has no core type" */ , 0)
+        _ = append(s2 /* ERROR "s2 .* has core type byte" */ , 0)
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue49739.go b/src/internal/types/testdata/fixedbugs/issue49739.go
index 7feb5637dc..e280ed3d0d 100644
--- a/src/internal/types/testdata/fixedbugs/issue49739.go
+++ b/src/internal/types/testdata/fixedbugs/issue49739.go
@@ -9,7 +9,7 @@ package p
 
 type A int
 type C interface {
-	~ /* ERROR invalid use of ~ */ A
+	~ /* ERROR "invalid use of ~" */ A
 }
 
 func f[_ C]()              {}
@@ -17,7 +17,7 @@ func g[_ interface{ C }]() {}
 func h[_ C | int]()        {}
 
 func _() {
-	_ = f[int /* ERROR cannot satisfy C \(empty type set\) */]
-	_ = g[int /* ERROR cannot satisfy interface{C} \(empty type set\) */]
+	_ = f[int /* ERROR "cannot satisfy C \(empty type set\)" */]
+	_ = g[int /* ERROR "cannot satisfy interface{C} \(empty type set\)" */]
 	_ = h[int]
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue49864.go b/src/internal/types/testdata/fixedbugs/issue49864.go
index 0437e74a64..8ccd77cfea 100644
--- a/src/internal/types/testdata/fixedbugs/issue49864.go
+++ b/src/internal/types/testdata/fixedbugs/issue49864.go
@@ -5,5 +5,5 @@
 package p
 
 func _[P ~int, Q any](p P) {
-	_ = Q(p /* ERROR cannot convert */ )
+	_ = Q(p /* ERROR "cannot convert" */ )
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue50321.go b/src/internal/types/testdata/fixedbugs/issue50321.go
index 199e66eb6c..ab2a31b7eb 100644
--- a/src/internal/types/testdata/fixedbugs/issue50321.go
+++ b/src/internal/types/testdata/fixedbugs/issue50321.go
@@ -4,5 +4,5 @@
 
 package p
 
-func Ln[A A /* ERROR cannot use a type parameter as constraint */ ](p A) {
+func Ln[A A /* ERROR "cannot use a type parameter as constraint" */ ](p A) {
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue50372.go b/src/internal/types/testdata/fixedbugs/issue50372.go
index 4c9b65a72f..e596c0a348 100644
--- a/src/internal/types/testdata/fixedbugs/issue50372.go
+++ b/src/internal/types/testdata/fixedbugs/issue50372.go
@@ -11,8 +11,8 @@ func _(s []int) {
         for range s {}
         for i = range s {}
         for i, j = range s {}
-        for i, j, k /* ERROR range clause permits at most two iteration variables|at most 2 expressions */ = range s {}
-        for i, j, k, l /* ERROR range clause permits at most two iteration variables|at most 2 expressions */ = range s {}
+        for i, j, k /* ERROR "range clause permits at most two iteration variables|at most 2 expressions" */ = range s {}
+        for i, j, k, l /* ERROR "range clause permits at most two iteration variables|at most 2 expressions" */ = range s {}
 }
 
 func _(s chan int) {
@@ -21,7 +21,7 @@ func _(s chan int) {
 
         for range s {}
         for i = range s {}
-        for i, j /* ERROR range over .* permits only one iteration variable */ = range s {}
-        for i, j, k /* ERROR range over .* permits only one iteration variable|at most 2 expressions */ = range s {}
-        for i, j, k, l /* ERROR range over .* permits only one iteration variable|at most 2 expressions */ = range s {}
+        for i, j /* ERROR "range over .* permits only one iteration variable" */ = range s {}
+        for i, j, k /* ERROR "range over .* permits only one iteration variable|at most 2 expressions" */ = range s {}
+        for i, j, k, l /* ERROR "range over .* permits only one iteration variable|at most 2 expressions" */ = range s {}
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue50417.go b/src/internal/types/testdata/fixedbugs/issue50417.go
index 69ebf31b16..2a057f616f 100644
--- a/src/internal/types/testdata/fixedbugs/issue50417.go
+++ b/src/internal/types/testdata/fixedbugs/issue50417.go
@@ -13,29 +13,29 @@ type Sf struct {
 }
 
 func f0[P Sf](p P) {
-        _ = p.f // ERROR p\.f undefined
-        p.f /* ERROR p\.f undefined */ = 0
+        _ = p.f // ERROR "p\.f undefined"
+        p.f /* ERROR "p\.f undefined" */ = 0
 }
 
 func f0t[P ~struct{f int}](p P) {
-        _ = p.f // ERROR p\.f undefined
-        p.f /* ERROR p\.f undefined */ = 0
+        _ = p.f // ERROR "p\.f undefined"
+        p.f /* ERROR "p\.f undefined" */ = 0
 }
 
 var _ = f0[Sf]
 var _ = f0t[Sf]
 
-var _ = f0[Sm /* ERROR does not satisfy */ ]
-var _ = f0t[Sm /* ERROR does not satisfy */ ]
+var _ = f0[Sm /* ERROR "does not satisfy" */ ]
+var _ = f0t[Sm /* ERROR "does not satisfy" */ ]
 
 func f1[P interface{ Sf; m() }](p P) {
-        _ = p.f // ERROR p\.f undefined
-        p.f /* ERROR p\.f undefined */ = 0
+        _ = p.f // ERROR "p\.f undefined"
+        p.f /* ERROR "p\.f undefined" */ = 0
         p.m()
 }
 
-var _ = f1[Sf /* ERROR missing method m */ ]
-var _ = f1[Sm /* ERROR does not satisfy */ ]
+var _ = f1[Sf /* ERROR "missing method m" */ ]
+var _ = f1[Sm /* ERROR "does not satisfy" */ ]
 
 type Sm struct {}
 
@@ -48,8 +48,8 @@ type Sfm struct {
 func (Sfm) m() {}
 
 func f2[P interface{ Sfm; m() }](p P) {
-        _ = p.f // ERROR p\.f undefined
-        p.f /* ERROR p\.f undefined */ = 0
+        _ = p.f // ERROR "p\.f undefined"
+        p.f /* ERROR "p\.f undefined" */ = 0
         p.m()
 }
 
@@ -60,9 +60,9 @@ var _ = f2[Sfm]
 type PSfm *Sfm
 
 func f3[P interface{ PSfm }](p P) {
-        _ = p.f // ERROR p\.f undefined
-        p.f /* ERROR p\.f undefined */ = 0
-        p.m /* ERROR type P has no field or method m */ ()
+        _ = p.f // ERROR "p\.f undefined"
+        p.f /* ERROR "p\.f undefined" */ = 0
+        p.m /* ERROR "type P has no field or method m" */ ()
 }
 
 var _ = f3[PSfm]
diff --git a/src/internal/types/testdata/fixedbugs/issue50516.go b/src/internal/types/testdata/fixedbugs/issue50516.go
index f73015e2be..fcaefedc45 100644
--- a/src/internal/types/testdata/fixedbugs/issue50516.go
+++ b/src/internal/types/testdata/fixedbugs/issue50516.go
@@ -5,9 +5,9 @@
 package p
 
 func _[P struct{ f int }](x P) {
-	_ = x.g // ERROR type P has no field or method g
+	_ = x.g // ERROR "type P has no field or method g"
 }
 
 func _[P struct{ f int } | struct{ g int }](x P) {
-	_ = x.g // ERROR type P has no field or method g
+	_ = x.g // ERROR "type P has no field or method g"
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue50646.go b/src/internal/types/testdata/fixedbugs/issue50646.go
index ed7261c6b8..f783e7a0f7 100644
--- a/src/internal/types/testdata/fixedbugs/issue50646.go
+++ b/src/internal/types/testdata/fixedbugs/issue50646.go
@@ -13,16 +13,16 @@ type T interface{ m() }
 
 func _[P comparable, Q ~int, R any]() {
 	_ = f1[int]
-	_ = f1[T /* ERROR T does not satisfy comparable */ ]
-	_ = f1[any /* ERROR any does not satisfy comparable */ ]
+	_ = f1[T /* ERROR "T does not satisfy comparable" */ ]
+	_ = f1[any /* ERROR "any does not satisfy comparable" */ ]
 	_ = f1[P]
 	_ = f1[Q]
-	_ = f1[R /* ERROR R does not satisfy comparable */]
+	_ = f1[R /* ERROR "R does not satisfy comparable" */]
 
 	_ = f2[int]
-	_ = f2[T /* ERROR T does not satisfy comparable */ ]
-	_ = f2[any /* ERROR any does not satisfy comparable */ ]
+	_ = f2[T /* ERROR "T does not satisfy comparable" */ ]
+	_ = f2[any /* ERROR "any does not satisfy comparable" */ ]
 	_ = f2[P]
 	_ = f2[Q]
-	_ = f2[R /* ERROR R does not satisfy comparable */]
+	_ = f2[R /* ERROR "R does not satisfy comparable" */]
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue50779.go b/src/internal/types/testdata/fixedbugs/issue50779.go
index fe68c28bba..09ddf53ddf 100644
--- a/src/internal/types/testdata/fixedbugs/issue50779.go
+++ b/src/internal/types/testdata/fixedbugs/issue50779.go
@@ -15,7 +15,7 @@ type R[S any, P any] struct{}
 type SR = R[SS, ST]
 
 type SS interface {
-	NSR(any) *SR // ERROR invalid use of type alias SR in recursive type
+	NSR(any) *SR // ERROR "invalid use of type alias SR in recursive type"
 }
 
 type C interface {
diff --git a/src/internal/types/testdata/fixedbugs/issue50782.go b/src/internal/types/testdata/fixedbugs/issue50782.go
index 0e7b712a09..62e593610a 100644
--- a/src/internal/types/testdata/fixedbugs/issue50782.go
+++ b/src/internal/types/testdata/fixedbugs/issue50782.go
@@ -21,10 +21,10 @@ type numericAbs[T Numeric] interface {
 
 // AbsDifference computes the absolute value of the difference of
 // a and b, where the absolute value is determined by the Abs method.
-func absDifference[T numericAbs[T /* ERROR T does not satisfy Numeric */]](a, b T) T {
+func absDifference[T numericAbs[T /* ERROR "T does not satisfy Numeric" */]](a, b T) T {
 	// Field accesses are not permitted for now. Keep an error so
 	// we can find and fix this code once the situation changes.
-	return a.Value // ERROR a\.Value undefined
+	return a.Value // ERROR "a\.Value undefined"
 	// TODO: The error below should probably be positioned on the '-'.
 	// d := a /* ERROR "invalid operation: operator - not defined" */ .Value - b.Value
 	// return d.Abs()
diff --git a/src/internal/types/testdata/fixedbugs/issue50816.go b/src/internal/types/testdata/fixedbugs/issue50816.go
index e7e31d9192..c3d5261cb7 100644
--- a/src/internal/types/testdata/fixedbugs/issue50816.go
+++ b/src/internal/types/testdata/fixedbugs/issue50816.go
@@ -18,6 +18,6 @@ func (T2) foo() string { return "" }
 
 func _() {
 	var i I
-	_ = i /* ERROR impossible type assertion: i\.\(T1\)\n\tT1 does not implement I \(missing method Foo\)\n\t\thave foo\(\)\n\t\twant Foo\(\) */ .(T1)
-	_ = i /* ERROR impossible type assertion: i\.\(T2\)\n\tT2 does not implement I \(missing method Foo\)\n\t\thave foo\(\) string\n\t\twant Foo\(\) */ .(T2)
+	_ = i /* ERROR "impossible type assertion: i\.\(T1\)\n\tT1 does not implement I \(missing method Foo\)\n\t\thave foo\(\)\n\t\twant Foo\(\)" */ .(T1)
+	_ = i /* ERROR "impossible type assertion: i\.\(T2\)\n\tT2 does not implement I \(missing method Foo\)\n\t\thave foo\(\) string\n\t\twant Foo\(\)" */ .(T2)
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue50912.go b/src/internal/types/testdata/fixedbugs/issue50912.go
index f161925049..a99fa7bfea 100644
--- a/src/internal/types/testdata/fixedbugs/issue50912.go
+++ b/src/internal/types/testdata/fixedbugs/issue50912.go
@@ -5,15 +5,15 @@
 package p
 
 func Real[P ~complex128](x P) {
-	_ = real(x /* ERROR not supported */ )
+	_ = real(x /* ERROR "not supported" */ )
 }
 
 func Imag[P ~complex128](x P) {
-	_ = imag(x /* ERROR not supported */ )
+	_ = imag(x /* ERROR "not supported" */ )
 }
 
 func Complex[P ~float64](x P) {
-	_ = complex(x /* ERROR not supported */ , 0)
-	_ = complex(0 /* ERROR not supported */ , x)
-	_ = complex(x /* ERROR not supported */ , x)
+	_ = complex(x /* ERROR "not supported" */ , 0)
+	_ = complex(0 /* ERROR "not supported" */ , x)
+	_ = complex(x /* ERROR "not supported" */ , x)
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue50918.go b/src/internal/types/testdata/fixedbugs/issue50918.go
index 41604b8bad..b70cfde456 100644
--- a/src/internal/types/testdata/fixedbugs/issue50918.go
+++ b/src/internal/types/testdata/fixedbugs/issue50918.go
@@ -14,8 +14,8 @@ type thing2 struct {
 
 func _() {
 	var a1, b1 thing1
-	_ = a1 /* ERROR struct containing \[\]string cannot be compared */ == b1
+	_ = a1 /* ERROR "struct containing \[\]string cannot be compared" */ == b1
 
 	var a2, b2 thing2
-	_ = a2 /* ERROR struct containing \[\]thing1 cannot be compared */ == b2
+	_ = a2 /* ERROR "struct containing \[\]thing1 cannot be compared" */ == b2
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue50929.go b/src/internal/types/testdata/fixedbugs/issue50929.go
index 45e075191d..369d5e74ac 100644
--- a/src/internal/types/testdata/fixedbugs/issue50929.go
+++ b/src/internal/types/testdata/fixedbugs/issue50929.go
@@ -16,8 +16,8 @@ func G[A, B any](F[A, B]) {
 
 func _() {
 	// TODO(gri) only report one error below (issue #50932)
-	var x F /* ERROR got 1 arguments but 2 type parameters */ [int]
-	G(x /* ERROR does not match */)
+	var x F /* ERROR "got 1 arguments but 2 type parameters" */ [int]
+	G(x /* ERROR "does not match" */)
 }
 
 // test case from issue
@@ -46,23 +46,23 @@ func NSG[G any](c RSC[G]) {
 	fmt.Println(c)
 }
 
-func MMD[Rc RC /* ERROR got 1 arguments */ [RG], RG any, G any]() M /* ERROR got 2 arguments */ [Rc, RG] {
+func MMD[Rc RC /* ERROR "got 1 arguments" */ [RG], RG any, G any]() M /* ERROR "got 2 arguments" */ [Rc, RG] {
 
-	var nFn NFn /* ERROR got 2 arguments */ [Rc, RG]
+	var nFn NFn /* ERROR "got 2 arguments" */ [Rc, RG]
 
 	var empty Rc
 	switch any(empty).(type) {
-	case BC /* ERROR undefined: BC */ :
+	case BC /* ERROR "undefined: BC" */ :
 
 	case RSC[G]:
-		nFn = NSG /* ERROR cannot use NSG\[G\] */ [G]
+		nFn = NSG /* ERROR "cannot use NSG\[G\]" */ [G]
 	}
 
-	return M /* ERROR got 2 arguments */ [Rc, RG]{
+	return M /* ERROR "got 2 arguments" */ [Rc, RG]{
 		Fn: func(rc Rc) {
-			NC(nFn /* ERROR does not match */ )
+			NC(nFn /* ERROR "does not match" */ )
 		},
 	}
 
-	return M /* ERROR got 2 arguments */ [Rc, RG]{}
+	return M /* ERROR "got 2 arguments" */ [Rc, RG]{}
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue50965.go b/src/internal/types/testdata/fixedbugs/issue50965.go
index bf2dcc93d0..5361d21460 100644
--- a/src/internal/types/testdata/fixedbugs/issue50965.go
+++ b/src/internal/types/testdata/fixedbugs/issue50965.go
@@ -6,12 +6,12 @@ package p
 
 func _(x int, c string) {
 	switch x {
-	case c /* ERROR invalid case c in switch on x \(mismatched types string and int\) */ :
+	case c /* ERROR "invalid case c in switch on x \(mismatched types string and int\)" */ :
 	}
 }
 
 func _(x, c []int) {
 	switch x {
-	case c /* ERROR invalid case c in switch on x \(slice can only be compared to nil\) */ :
+	case c /* ERROR "invalid case c in switch on x \(slice can only be compared to nil\)" */ :
 	}
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue51025.go b/src/internal/types/testdata/fixedbugs/issue51025.go
index 207b06e84b..caaabd583e 100644
--- a/src/internal/types/testdata/fixedbugs/issue51025.go
+++ b/src/internal/types/testdata/fixedbugs/issue51025.go
@@ -4,19 +4,19 @@
 
 package p
 
-var _ interface{ m() } = struct /* ERROR m is a field, not a method */ {
+var _ interface{ m() } = struct /* ERROR "m is a field, not a method" */ {
 	m func()
 }{}
 
-var _ interface{ m() } = & /* ERROR m is a field, not a method */ struct {
+var _ interface{ m() } = & /* ERROR "m is a field, not a method" */ struct {
 	m func()
 }{}
 
-var _ interface{ M() } = struct /* ERROR missing method M */ {
+var _ interface{ M() } = struct /* ERROR "missing method M" */ {
 	m func()
 }{}
 
-var _ interface{ M() } = & /* ERROR missing method M */ struct {
+var _ interface{ M() } = & /* ERROR "missing method M" */ struct {
 	m func()
 }{}
 
@@ -33,6 +33,6 @@ func _() {
 	var i I
 
 	i = m
-	i = t // ERROR m is a field, not a method
+	i = t // ERROR "m is a field, not a method"
 	_ = i
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue51145.go b/src/internal/types/testdata/fixedbugs/issue51145.go
index b84391df19..1f970d9bb0 100644
--- a/src/internal/types/testdata/fixedbugs/issue51145.go
+++ b/src/internal/types/testdata/fixedbugs/issue51145.go
@@ -7,10 +7,10 @@ package p
 import "fmt"
 
 type (
-	_ [fmt /* ERROR invalid array length fmt */ ]int
-	_ [float64 /* ERROR invalid array length float64 */ ]int
-	_ [f /* ERROR invalid array length f */ ]int
-	_ [nil /* ERROR invalid array length nil */ ]int
+	_ [fmt /* ERROR "invalid array length fmt" */ ]int
+	_ [float64 /* ERROR "invalid array length float64" */ ]int
+	_ [f /* ERROR "invalid array length f" */ ]int
+	_ [nil /* ERROR "invalid array length nil" */ ]int
 )
 
 func f()
diff --git a/src/internal/types/testdata/fixedbugs/issue51229.go b/src/internal/types/testdata/fixedbugs/issue51229.go
index 808b6471f6..ae1ae03d97 100644
--- a/src/internal/types/testdata/fixedbugs/issue51229.go
+++ b/src/internal/types/testdata/fixedbugs/issue51229.go
@@ -105,11 +105,11 @@ func ch5[P chan int | chan<- int]()      { return } // core(P) == chan<- int   (
 
 func _() {
 	// P can be inferred as there's a single specific type and no tilde.
-	var _ chan int = ch1 /* ERROR cannot use ch1.*value of type chan<- int */ ()
+	var _ chan int = ch1 /* ERROR "cannot use ch1.*value of type chan<- int" */ ()
 	var _ chan<- int = ch1()
 
 	// P cannot be inferred as there's a tilde.
-	ch2 /* ERROR cannot infer P */ ()
+	ch2 /* ERROR "cannot infer P" */ ()
 	type myChan chan int
 	ch2[myChan]()
 
@@ -118,11 +118,11 @@ func _() {
 	ch3(e)
 
 	// P cannot be inferred as there's more than one specific type and a tilde.
-	ch4 /* ERROR cannot infer P */ (e)
+	ch4 /* ERROR "cannot infer P" */ (e)
 	_ = ch4[chan int]
 
 	// P cannot be inferred as there's more than one specific type.
-	ch5 /* ERROR cannot infer P */ ()
+	ch5 /* ERROR "cannot infer P" */ ()
 	ch5[chan<- int]()
 }
 
diff --git a/src/internal/types/testdata/fixedbugs/issue51232.go b/src/internal/types/testdata/fixedbugs/issue51232.go
index 3fa6a05732..637de9042f 100644
--- a/src/internal/types/testdata/fixedbugs/issue51232.go
+++ b/src/internal/types/testdata/fixedbugs/issue51232.go
@@ -11,20 +11,20 @@ type RC[RG any] interface {
 type Fn[RCT RC[RG], RG any] func(RCT)
 
 type F[RCT RC[RG], RG any] interface {
-	Fn() Fn /* ERROR got 1 arguments */ [RCT]
+	Fn() Fn /* ERROR "got 1 arguments" */ [RCT]
 }
 
 type concreteF[RCT RC[RG], RG any] struct {
-	makeFn func() Fn /* ERROR got 1 arguments */ [RCT]
+	makeFn func() Fn /* ERROR "got 1 arguments" */ [RCT]
 }
 
-func (c *concreteF[RCT, RG]) Fn() Fn /* ERROR got 1 arguments */ [RCT] {
+func (c *concreteF[RCT, RG]) Fn() Fn /* ERROR "got 1 arguments" */ [RCT] {
 	return c.makeFn()
 }
 
-func NewConcrete[RCT RC[RG], RG any](Rc RCT) F /* ERROR got 1 arguments */ [RCT] {
+func NewConcrete[RCT RC[RG], RG any](Rc RCT) F /* ERROR "got 1 arguments" */ [RCT] {
 	// TODO(rfindley): eliminate the duplicate error below.
-	return & /* ERROR cannot use .* as F\[RCT\] */ concreteF /* ERROR got 1 arguments */ [RCT]{
+	return & /* ERROR "cannot use .* as F\[RCT\]" */ concreteF /* ERROR "got 1 arguments" */ [RCT]{
 		makeFn: nil,
 	}
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue51233.go b/src/internal/types/testdata/fixedbugs/issue51233.go
index 9c15028c91..e2f97fc456 100644
--- a/src/internal/types/testdata/fixedbugs/issue51233.go
+++ b/src/internal/types/testdata/fixedbugs/issue51233.go
@@ -12,16 +12,16 @@ type RC[RG any] interface {
 
 type Fn[RCT RC[RG], RG any] func(RCT)
 
-type FFn[RCT RC[RG], RG any] func() Fn /* ERROR got 1 arguments */ [RCT]
+type FFn[RCT RC[RG], RG any] func() Fn /* ERROR "got 1 arguments" */ [RCT]
 
 type F[RCT RC[RG], RG any] interface {
-	Fn() Fn /* ERROR got 1 arguments */ [RCT]
+	Fn() Fn /* ERROR "got 1 arguments" */ [RCT]
 }
 
 type concreteF[RCT RC[RG], RG any] struct {
-	makeFn FFn /* ERROR got 1 arguments */ [RCT]
+	makeFn FFn /* ERROR "got 1 arguments" */ [RCT]
 }
 
-func (c *concreteF[RCT, RG]) Fn() Fn /* ERROR got 1 arguments */ [RCT] {
+func (c *concreteF[RCT, RG]) Fn() Fn /* ERROR "got 1 arguments" */ [RCT] {
 	return c.makeFn()
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue51257.go b/src/internal/types/testdata/fixedbugs/issue51257.go
index be4b81fee7..55abb75bf7 100644
--- a/src/internal/types/testdata/fixedbugs/issue51257.go
+++ b/src/internal/types/testdata/fixedbugs/issue51257.go
@@ -14,13 +14,13 @@ type S3 struct{ x [10]interface{ m() } }
 
 func _[P1 comparable, P2 S2]() {
 	_ = f[S1]
-	_ = f[S2 /* ERROR S2 does not satisfy comparable */ ]
-	_ = f[S3 /* ERROR S3 does not satisfy comparable */ ]
+	_ = f[S2 /* ERROR "S2 does not satisfy comparable" */ ]
+	_ = f[S3 /* ERROR "S3 does not satisfy comparable" */ ]
 
 	type L1 struct { x P1 }
 	type L2 struct { x P2 }
 	_ = f[L1]
-	_ = f[L2 /* ERROR L2 does not satisfy comparable */ ]
+	_ = f[L2 /* ERROR "L2 does not satisfy comparable" */ ]
 }
 
 
@@ -41,7 +41,7 @@ func NewSetFromSlice[T comparable](items []T) *Set[T] {
 type T struct{ x any }
 
 func main() {
-	NewSetFromSlice /* ERROR T does not satisfy comparable */ ([]T{
+	NewSetFromSlice /* ERROR "T does not satisfy comparable" */ ([]T{
 		{"foo"},
 		{5},
 	})
diff --git a/src/internal/types/testdata/fixedbugs/issue51335.go b/src/internal/types/testdata/fixedbugs/issue51335.go
index 35135cd1db..e2f82f09b7 100644
--- a/src/internal/types/testdata/fixedbugs/issue51335.go
+++ b/src/internal/types/testdata/fixedbugs/issue51335.go
@@ -8,9 +8,9 @@ type S1 struct{}
 type S2 struct{}
 
 func _[P *S1|*S2]() {
-	_= []P{{ /* ERROR invalid composite literal element type P \(no core type\) */ }}
+	_= []P{{ /* ERROR "invalid composite literal element type P \(no core type\)" */ }}
 }
 
 func _[P *S1|S1]() {
-	_= []P{{ /* ERROR invalid composite literal element type P \(no core type\) */ }}
+	_= []P{{ /* ERROR "invalid composite literal element type P \(no core type\)" */ }}
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue51339.go b/src/internal/types/testdata/fixedbugs/issue51339.go
index 38f86109e3..65c213462b 100644
--- a/src/internal/types/testdata/fixedbugs/issue51339.go
+++ b/src/internal/types/testdata/fixedbugs/issue51339.go
@@ -9,10 +9,10 @@ package p
 
 type T[P any, B *P] struct{}
 
-func (T /* ERROR cannot use generic type */ ) m0() {}
+func (T /* ERROR "cannot use generic type" */ ) m0() {}
 
 // TODO(rfindley): eliminate the duplicate errors here.
-func (/* ERROR got 1 type parameter, but receiver base type declares 2 */ T /* ERROR got 1 arguments but 2 type parameters */ [_]) m1() {}
+func (/* ERROR "got 1 type parameter, but receiver base type declares 2" */ T /* ERROR "got 1 arguments but 2 type parameters" */ [_]) m1() {}
 func (T[_, _]) m2() {}
 // TODO(gri) this error is unfortunate (issue #51343)
-func (T /* ERROR got 3 arguments but 2 type parameters */ [_, _, _]) m3() {}
+func (T /* ERROR "got 3 arguments but 2 type parameters" */ [_, _, _]) m3() {}
diff --git a/src/internal/types/testdata/fixedbugs/issue51360.go b/src/internal/types/testdata/fixedbugs/issue51360.go
index fe3de04dbf..1b9c45a934 100644
--- a/src/internal/types/testdata/fixedbugs/issue51360.go
+++ b/src/internal/types/testdata/fixedbugs/issue51360.go
@@ -5,9 +5,9 @@
 package p
 
 func _() {
-	len.Println /* ERROR cannot select on len */
-	len.Println /* ERROR cannot select on len */ ()
-	_ = len.Println /* ERROR cannot select on len */
-	_ = len /* ERROR cannot index len */ [0]
-	_ = *len /* ERROR cannot indirect len */
+	len.Println /* ERROR "cannot select on len" */
+	len.Println /* ERROR "cannot select on len" */ ()
+	_ = len.Println /* ERROR "cannot select on len" */
+	_ = len /* ERROR "cannot index len" */ [0]
+	_ = *len /* ERROR "cannot indirect len" */
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue51376.go b/src/internal/types/testdata/fixedbugs/issue51376.go
index 3801d6883c..b5402ded7f 100644
--- a/src/internal/types/testdata/fixedbugs/issue51376.go
+++ b/src/internal/types/testdata/fixedbugs/issue51376.go
@@ -12,7 +12,7 @@ func g[M map[K]V, K comparable, V any](M) {}
 func _[M1 ~map[K]V, M2 map[K]V, K comparable, V any]() {
         var m1 M1
         f(m1)
-        g /* ERROR M1 does not satisfy map\[K\]V */ (m1) // M1 has tilde
+        g /* ERROR "M1 does not satisfy map\[K\]V" */ (m1) // M1 has tilde
 
         var m2 M2
         f(m2)
@@ -20,5 +20,5 @@ func _[M1 ~map[K]V, M2 map[K]V, K comparable, V any]() {
 
         var m3 Map
         f(m3)
-        g /* ERROR Map does not satisfy map\[string\]int */ (m3) // M in g does not have tilde
+        g /* ERROR "Map does not satisfy map\[string\]int" */ (m3) // M in g does not have tilde
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue51472.go b/src/internal/types/testdata/fixedbugs/issue51472.go
index a0f9e9c025..081a3916f6 100644
--- a/src/internal/types/testdata/fixedbugs/issue51472.go
+++ b/src/internal/types/testdata/fixedbugs/issue51472.go
@@ -21,17 +21,17 @@ func _[T interface{comparable; ~int}](x T) {
 }
 
 func _[T interface{comparable; ~[]byte}](x T) {
-        _ = x /* ERROR empty type set */ == x
+        _ = x /* ERROR "empty type set" */ == x
 }
 
 // TODO(gri) The error message here should be better. See issue #51525.
 func _[T interface{comparable; ~int; ~string}](x T) {
-        _ = x /* ERROR empty type set */ == x
+        _ = x /* ERROR "empty type set" */ == x
 }
 
 // TODO(gri) The error message here should be better. See issue #51525.
 func _[T interface{~int; ~string}](x T) {
-        _ = x /* ERROR empty type set */ == x
+        _ = x /* ERROR "empty type set" */ == x
 }
 
 func _[T interface{comparable; interface{~int}; interface{int|float64}}](x T) {
@@ -39,7 +39,7 @@ func _[T interface{comparable; interface{~int}; interface{int|float64}}](x T) {
 }
 
 func _[T interface{interface{comparable; ~int}; interface{~float64; comparable; m()}}](x T) {
-        _ = x /* ERROR empty type set */ == x
+        _ = x /* ERROR "empty type set" */ == x
 }
 
 // test case from issue
@@ -49,6 +49,6 @@ func f[T interface{comparable; []byte|string}](x T) {
 }
 
 func _(s []byte) {
-	f /* ERROR \[\]byte does not satisfy interface{comparable; \[\]byte \| string} */ (s)
-        _ = f[[ /* ERROR does not satisfy */ ]byte]
+	f /* ERROR "\[\]byte does not satisfy interface{comparable; \[\]byte \| string}" */ (s)
+        _ = f[[ /* ERROR "does not satisfy" */ ]byte]
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue51509.go b/src/internal/types/testdata/fixedbugs/issue51509.go
index 64f5d7e5ba..4737a82505 100644
--- a/src/internal/types/testdata/fixedbugs/issue51509.go
+++ b/src/internal/types/testdata/fixedbugs/issue51509.go
@@ -4,4 +4,4 @@
 
 package p
 
-type T /* ERROR invalid recursive type */ T.x
+type T /* ERROR "invalid recursive type" */ T.x
diff --git a/src/internal/types/testdata/fixedbugs/issue51525.go b/src/internal/types/testdata/fixedbugs/issue51525.go
index 58569056f0..af569c8543 100644
--- a/src/internal/types/testdata/fixedbugs/issue51525.go
+++ b/src/internal/types/testdata/fixedbugs/issue51525.go
@@ -8,13 +8,13 @@ func _[T interface {
 	int
 	string
 }](x T) {
-	_ = x /* ERROR empty type set */ == x
-	_ = x /* ERROR empty type set */ + x
-	<-x /* ERROR empty type set */
-	x <- /* ERROR empty type set */ 0
-	close(x /* ERROR empty type set */)
+	_ = x /* ERROR "empty type set" */ == x
+	_ = x /* ERROR "empty type set" */ + x
+	<-x /* ERROR "empty type set" */
+	x <- /* ERROR "empty type set" */ 0
+	close(x /* ERROR "empty type set" */)
 }
 
 func _[T interface{ int | []byte }](x T) {
-	_ = x /* ERROR incomparable types in type set */ == x
+	_ = x /* ERROR "incomparable types in type set" */ == x
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue51533.go b/src/internal/types/testdata/fixedbugs/issue51533.go
index bf46f755f9..166e5fe64a 100644
--- a/src/internal/types/testdata/fixedbugs/issue51533.go
+++ b/src/internal/types/testdata/fixedbugs/issue51533.go
@@ -7,14 +7,14 @@ package p
 func _(x any) {
 	switch x {
 	case 0:
-		fallthrough // ERROR fallthrough statement out of place
+		fallthrough // ERROR "fallthrough statement out of place"
 		_ = x
 	default:
 	}
 
 	switch x.(type) {
 	case int:
-		fallthrough // ERROR cannot fallthrough in type switch
+		fallthrough // ERROR "cannot fallthrough in type switch"
 	default:
 	}
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue51578.go b/src/internal/types/testdata/fixedbugs/issue51578.go
index 5c204bae20..d2e8a28550 100644
--- a/src/internal/types/testdata/fixedbugs/issue51578.go
+++ b/src/internal/types/testdata/fixedbugs/issue51578.go
@@ -4,14 +4,14 @@
 
 package p
 
-var _ = (*interface /* ERROR interface contains type constraints */ {int})(nil)
+var _ = (*interface /* ERROR "interface contains type constraints" */ {int})(nil)
 
 // abbreviated test case from issue
 
 type TypeSet interface{ int | string }
 
 func _() {
-	f((*TypeSet /* ERROR interface contains type constraints */)(nil))
+	f((*TypeSet /* ERROR "interface contains type constraints" */)(nil))
 }
 
 func f(any) {}
\ No newline at end of file
diff --git a/src/internal/types/testdata/fixedbugs/issue51593.go b/src/internal/types/testdata/fixedbugs/issue51593.go
index e06c39fac0..f7b3a49988 100644
--- a/src/internal/types/testdata/fixedbugs/issue51593.go
+++ b/src/internal/types/testdata/fixedbugs/issue51593.go
@@ -9,5 +9,5 @@ func f[P interface{ m(R) }, R any]() {}
 type T = interface { m(int) }
 
 func _() {
-	_ = f /* ERROR cannot infer R */ [T] // don't crash in type inference
+	_ = f /* ERROR "cannot infer R" */ [T] // don't crash in type inference
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue51607.go b/src/internal/types/testdata/fixedbugs/issue51607.go
index d8df143627..298adade4b 100644
--- a/src/internal/types/testdata/fixedbugs/issue51607.go
+++ b/src/internal/types/testdata/fixedbugs/issue51607.go
@@ -16,13 +16,13 @@ type (
 type (
 	// overlap errors for non-interface terms
 	// (like the interface terms, but explicitly inlined)
-	_ interface{int | int /* ERROR overlapping terms int and int */ }
-	_ interface{int | ~ /* ERROR overlapping terms ~int and int */ int}
-	_ interface{~int | int /* ERROR overlapping terms int and ~int */ }
-	_ interface{~int | ~ /* ERROR overlapping terms ~int and ~int */ int}
+	_ interface{int | int /* ERROR "overlapping terms int and int" */ }
+	_ interface{int | ~ /* ERROR "overlapping terms ~int and int" */ int}
+	_ interface{~int | int /* ERROR "overlapping terms int and ~int" */ }
+	_ interface{~int | ~ /* ERROR "overlapping terms ~int and ~int" */ int}
 
-	_ interface{T1 | bool | string | T1 | bool /* ERROR overlapping terms bool and bool */ | string /* ERROR overlapping terms string and string */ }
-	_ interface{T1 | bool | string | T2 | ~ /* ERROR overlapping terms ~bool and bool */ bool | ~ /* ERROR overlapping terms ~string and string */ string}
+	_ interface{T1 | bool | string | T1 | bool /* ERROR "overlapping terms bool and bool" */ | string /* ERROR "overlapping terms string and string" */ }
+	_ interface{T1 | bool | string | T2 | ~ /* ERROR "overlapping terms ~bool and bool" */ bool | ~ /* ERROR "overlapping terms ~string and string" */ string}
 
 	// no errors for interface terms
 	_ interface{T1 | T1}
@@ -36,10 +36,10 @@ type (
 	_ interface{T4 | T4 | float64 }
 )
 
-func _[_ T1 | bool | string | T1 | bool /* ERROR overlapping terms */ ]() {}
-func _[_ T1 | bool | string | T2 | ~ /* ERROR overlapping terms */ bool ]() {}
-func _[_ T2 | ~bool | ~string | T1 | bool /* ERROR overlapping terms */ ]() {}
-func _[_ T2 | ~bool | ~string | T2 | ~ /* ERROR overlapping terms */ bool ]() {}
+func _[_ T1 | bool | string | T1 | bool /* ERROR "overlapping terms" */ ]() {}
+func _[_ T1 | bool | string | T2 | ~ /* ERROR "overlapping terms" */ bool ]() {}
+func _[_ T2 | ~bool | ~string | T1 | bool /* ERROR "overlapping terms" */ ]() {}
+func _[_ T2 | ~bool | ~string | T2 | ~ /* ERROR "overlapping terms" */ bool ]() {}
 
 func _[_ T3 | T3 | int]() {}
 func _[_ T3 | T4 | bool]() {}
diff --git a/src/internal/types/testdata/fixedbugs/issue51610.go b/src/internal/types/testdata/fixedbugs/issue51610.go
index d10c788503..ae35357909 100644
--- a/src/internal/types/testdata/fixedbugs/issue51610.go
+++ b/src/internal/types/testdata/fixedbugs/issue51610.go
@@ -5,5 +5,5 @@
 package p
 
 func _[P int | float64 | complex128]() {
-	_ = map[P]int{1: 1, 1.0 /* ERROR duplicate key 1 */ : 2, 1 /* ERROR duplicate key \(1 \+ 0i\) */ + 0i: 3}
+	_ = map[P]int{1: 1, 1.0 /* ERROR "duplicate key 1" */ : 2, 1 /* ERROR "duplicate key \(1 \+ 0i\)" */ + 0i: 3}
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue51658.go b/src/internal/types/testdata/fixedbugs/issue51658.go
index f32051caec..cbd504813e 100644
--- a/src/internal/types/testdata/fixedbugs/issue51658.go
+++ b/src/internal/types/testdata/fixedbugs/issue51658.go
@@ -8,9 +8,9 @@
 
 package p
 
-type F { // ERROR expected type|type declaration
+type F { // ERROR "expected type|type declaration"
 	float64
-} // ERROR expected declaration|non-declaration statement
+} // ERROR "expected declaration|non-declaration statement"
 
 func _[T F | int](x T) {
 	_ = x == 0 // don't crash when recording type of 0
@@ -18,9 +18,9 @@ func _[T F | int](x T) {
 
 // test case from issue
 
-type FloatType { // ERROR expected type|type declaration
+type FloatType { // ERROR "expected type|type declaration"
 	float32 | float64
-} // ERROR expected declaration|non-declaration statement
+} // ERROR "expected declaration|non-declaration statement"
 
 type IntegerType interface {
 	int8 | int16 | int32 | int64 | int |
diff --git a/src/internal/types/testdata/fixedbugs/issue51877.go b/src/internal/types/testdata/fixedbugs/issue51877.go
index c93242adce..4b0e5bcd1f 100644
--- a/src/internal/types/testdata/fixedbugs/issue51877.go
+++ b/src/internal/types/testdata/fixedbugs/issue51877.go
@@ -10,9 +10,9 @@ type S struct {
 }
 
 var (
-	_ = S{0}                    /* ERROR too few values in struct literal */
-	_ = struct{ f1, f2 int }{0} /* ERROR too few values in struct literal */
+	_ = S{0}                    /* ERROR "too few values in struct literal" */
+	_ = struct{ f1, f2 int }{0} /* ERROR "too few values in struct literal" */
 
-	_ = S{0, true, "foo" /* ERROR too many values in struct literal */}
-	_ = struct{ f1, f2 int }{0, 1, 2 /* ERROR too many values in struct literal */}
+	_ = S{0, true, "foo" /* ERROR "too many values in struct literal" */}
+	_ = struct{ f1, f2 int }{0, 1, 2 /* ERROR "too many values in struct literal" */}
 )
diff --git a/src/internal/types/testdata/fixedbugs/issue52401.go b/src/internal/types/testdata/fixedbugs/issue52401.go
index c7efd8c718..ccc32d3b1b 100644
--- a/src/internal/types/testdata/fixedbugs/issue52401.go
+++ b/src/internal/types/testdata/fixedbugs/issue52401.go
@@ -6,6 +6,6 @@ package p
 
 func _() {
 	const x = 0
-	x /* ERROR cannot assign to x */ += 1
-	x /* ERROR cannot assign to x */ ++
+	x /* ERROR "cannot assign to x" */ += 1
+	x /* ERROR "cannot assign to x" */ ++
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue52698.go b/src/internal/types/testdata/fixedbugs/issue52698.go
index ca794f8b16..20f24f09ff 100644
--- a/src/internal/types/testdata/fixedbugs/issue52698.go
+++ b/src/internal/types/testdata/fixedbugs/issue52698.go
@@ -9,7 +9,7 @@ type T[P any] struct {
 	_ P
 }
 
-type S /* ERROR invalid recursive type */ struct {
+type S /* ERROR "invalid recursive type" */ struct {
 	_ T[S]
 }
 
diff --git a/src/internal/types/testdata/fixedbugs/issue52915.go b/src/internal/types/testdata/fixedbugs/issue52915.go
index 6c43386efc..70dc664375 100644
--- a/src/internal/types/testdata/fixedbugs/issue52915.go
+++ b/src/internal/types/testdata/fixedbugs/issue52915.go
@@ -7,7 +7,7 @@ package p
 import "unsafe"
 
 type T[P any] struct {
-	T /* ERROR   invalid recursive type */ [P]
+	T /* ERROR "invalid recursive type" */ [P]
 }
 
 func _[P any]() {
@@ -20,4 +20,4 @@ func _[P any]() {
 
 // TODO(gri) This is a follow-on error due to T[int] being invalid.
 //           We should try to avoid it.
-const _ = unsafe /* ERROR not constant */ .Sizeof(T[int]{})
+const _ = unsafe /* ERROR "not constant" */ .Sizeof(T[int]{})
diff --git a/src/internal/types/testdata/fixedbugs/issue53358.go b/src/internal/types/testdata/fixedbugs/issue53358.go
index 774136f4f7..1b99535170 100644
--- a/src/internal/types/testdata/fixedbugs/issue53358.go
+++ b/src/internal/types/testdata/fixedbugs/issue53358.go
@@ -8,12 +8,12 @@ type A struct{}
 
 func (*A) m() int { return 0 }
 
-var _ = A.m /* ERROR invalid method expression A\.m \(needs pointer receiver \(\*A\)\.m\) */ ()
+var _ = A.m /* ERROR "invalid method expression A\.m \(needs pointer receiver \(\*A\)\.m\)" */ ()
 var _ = (*A).m(nil)
 
 type B struct{ A }
 
-var _ = B.m // ERROR invalid method expression B\.m \(needs pointer receiver \(\*B\)\.m\)
+var _ = B.m // ERROR "invalid method expression B\.m \(needs pointer receiver \(\*B\)\.m\)"
 var _ = (*B).m
 
-var _ = struct{ A }.m // ERROR invalid method expression struct{A}\.m \(needs pointer receiver \(\*struct{A}\)\.m\)
+var _ = struct{ A }.m // ERROR "invalid method expression struct{A}\.m \(needs pointer receiver \(\*struct{A}\)\.m\)"
diff --git a/src/internal/types/testdata/fixedbugs/issue54280.go b/src/internal/types/testdata/fixedbugs/issue54280.go
index e83e1a140a..9465894aed 100644
--- a/src/internal/types/testdata/fixedbugs/issue54280.go
+++ b/src/internal/types/testdata/fixedbugs/issue54280.go
@@ -4,4 +4,4 @@
 
 package p
 
-const C = 912_345_678_901_234_567_890_123_456_789_012_345_678_901_234_567_890_912_345_678_901_234_567_890_123_456_789_012_345_678_901_234_567_890_912_345_678_901_234_567_890_123_456_789_012_345_678_901_234_567_890_912 // ERROR constant overflow
+const C = 912_345_678_901_234_567_890_123_456_789_012_345_678_901_234_567_890_912_345_678_901_234_567_890_123_456_789_012_345_678_901_234_567_890_912_345_678_901_234_567_890_123_456_789_012_345_678_901_234_567_890_912 // ERROR "constant overflow"
diff --git a/src/internal/types/testdata/fixedbugs/issue54405.go b/src/internal/types/testdata/fixedbugs/issue54405.go
index 611d83058d..688fee1f9e 100644
--- a/src/internal/types/testdata/fixedbugs/issue54405.go
+++ b/src/internal/types/testdata/fixedbugs/issue54405.go
@@ -8,9 +8,9 @@
 package p
 
 var x struct {
-	f *NotAType /* ERROR undefined */
+	f *NotAType /* ERROR "undefined" */
 }
 var _ = x.f == nil // no error expected here
 
-var y *NotAType  /* ERROR undefined */
+var y *NotAType  /* ERROR "undefined" */
 var _ = y == nil // no error expected here
diff --git a/src/internal/types/testdata/fixedbugs/issue56351.go b/src/internal/types/testdata/fixedbugs/issue56351.go
index d7d04b0043..b1e27e11b6 100644
--- a/src/internal/types/testdata/fixedbugs/issue56351.go
+++ b/src/internal/types/testdata/fixedbugs/issue56351.go
@@ -7,5 +7,5 @@
 package p
 
 func _(s []int) {
-	clear /* ERROR clear requires go1\.21 or later */ (s)
+	clear /* ERROR "clear requires go1\.21 or later" */ (s)
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue56665.go b/src/internal/types/testdata/fixedbugs/issue56665.go
index 11786b93fd..1f787d0bbc 100644
--- a/src/internal/types/testdata/fixedbugs/issue56665.go
+++ b/src/internal/types/testdata/fixedbugs/issue56665.go
@@ -10,7 +10,7 @@ type A[T any] interface {
 }
 
 type B[T any] interface {
-	B /* ERROR invalid recursive type */ [*T]
+	B /* ERROR "invalid recursive type" */ [*T]
 }
 
 type C[T any, U B[U]] interface {
@@ -19,12 +19,12 @@ type C[T any, U B[U]] interface {
 
 // Simplified reproducer:
 type X[T any] interface {
-	X /* ERROR invalid recursive type */ [*T]
+	X /* ERROR "invalid recursive type" */ [*T]
 }
 
 var _ X[int]
 
 // A related example that doesn't go through interfaces.
-type A2[P any] [10]A2 /* ERROR invalid recursive type */ [*P]
+type A2[P any] [10]A2 /* ERROR "invalid recursive type" */ [*P]
 
 var _ A2[int]
diff --git a/src/internal/types/testdata/fixedbugs/issue57500.go b/src/internal/types/testdata/fixedbugs/issue57500.go
index abdcb5ea35..0bb1d25d82 100644
--- a/src/internal/types/testdata/fixedbugs/issue57500.go
+++ b/src/internal/types/testdata/fixedbugs/issue57500.go
@@ -12,5 +12,5 @@ type C interface {
 func f[T C]() {}
 
 func _() {
-	_ = f[[ /* ERROR \[2\]any does not satisfy C \(C mentions \[2\]any, but \[2\]any is not in the type set of C\) */ 2]any]
+	_ = f[[ /* ERROR "\[2\]any does not satisfy C \(C mentions \[2\]any, but \[2\]any is not in the type set of C\)" */ 2]any]
 }
diff --git a/src/internal/types/testdata/fixedbugs/issue6977.go b/src/internal/types/testdata/fixedbugs/issue6977.go
index 8f4e9ba2b2..c455d3a849 100644
--- a/src/internal/types/testdata/fixedbugs/issue6977.go
+++ b/src/internal/types/testdata/fixedbugs/issue6977.go
@@ -32,10 +32,10 @@ type U3 interface { M; m() }
 type U4 interface { M; M; M }
 type U5 interface { U1; U2; U3; U4 }
 
-type U6 interface { m(); m /* ERROR duplicate method */ () }
-type U7 interface { M32 /* ERROR duplicate method */ ; m() }
-type U8 interface { m(); M32 /* ERROR duplicate method */ }
-type U9 interface { M32; M64 /* ERROR duplicate method */ }
+type U6 interface { m(); m /* ERROR "duplicate method" */ () }
+type U7 interface { M32 /* ERROR "duplicate method" */ ; m() }
+type U8 interface { m(); M32 /* ERROR "duplicate method" */ }
+type U9 interface { M32; M64 /* ERROR "duplicate method" */ }
 
 // Verify that repeated embedding of the same interface(s)
 // eliminates duplicate methods early (rather than at the
diff --git a/src/internal/types/testdata/spec/assignability.go b/src/internal/types/testdata/spec/assignability.go
index 0ab8eb3e93..c287f64f4b 100644
--- a/src/internal/types/testdata/spec/assignability.go
+++ b/src/internal/types/testdata/spec/assignability.go
@@ -37,7 +37,7 @@ func _[TP any](X TP) {
 // and at least one of V or T is not a named type."
 // (here a named type is a type with a name)
 func _[TP1, TP2 Interface](X1 TP1, X2 TP2) {
-	b = B // ERROR cannot use B .* as int value
+	b = B // ERROR "cannot use B .* as int value"
 	a = A
 	l = L
 	s = S
@@ -48,7 +48,7 @@ func _[TP1, TP2 Interface](X1 TP1, X2 TP2) {
 	c = C
 	d = D
 
-	B = b // ERROR cannot use b .* as Basic value
+	B = b // ERROR "cannot use b .* as Basic value"
 	A = a
 	L = l
 	S = s
@@ -58,16 +58,16 @@ func _[TP1, TP2 Interface](X1 TP1, X2 TP2) {
 	M = m
 	C = c
 	D = d
-	X1 = i  // ERROR cannot use i .* as TP1 value
-	X1 = X2 // ERROR cannot use X2 .* as TP1 value
+	X1 = i  // ERROR "cannot use i .* as TP1 value"
+	X1 = X2 // ERROR "cannot use X2 .* as TP1 value"
 }
 
 // "T is an interface type and x implements T and T is not a type parameter"
 func _[TP Interface](X TP) {
-	i = d // ERROR missing method m
+	i = d // ERROR "missing method m"
 	i = D
 	i = X
-	X = i // ERROR cannot use i .* as TP value
+	X = i // ERROR "cannot use i .* as TP value"
 }
 
 // "x is a bidirectional channel value, T is a channel type, x's type V and T have identical element types, and at least one of V or T is not a named type"
@@ -102,24 +102,24 @@ func _[
 		_ RecvChan = c
 		_ Chan     = c
 
-		_ SendChan = C // ERROR cannot use C .* as SendChan value
-		_ RecvChan = C // ERROR cannot use C .* as RecvChan value
+		_ SendChan = C // ERROR "cannot use C .* as SendChan value"
+		_ RecvChan = C // ERROR "cannot use C .* as RecvChan value"
 		_ Chan     = C
-		_ Chan     = make /* ERROR cannot use make\(chan Basic\) .* as Chan value */ (chan Basic)
+		_ Chan     = make /* ERROR "cannot use make\(chan Basic\) .* as Chan value" */ (chan Basic)
 	)
 
 	var (
-		_ _CC = C // ERROR cannot use C .* as _CC value
-		_ _SC = C // ERROR cannot use C .* as _SC value
-		_ _RC = C // ERROR cannot use C .* as _RC value
+		_ _CC = C // ERROR "cannot use C .* as _CC value"
+		_ _SC = C // ERROR "cannot use C .* as _SC value"
+		_ _RC = C // ERROR "cannot use C .* as _RC value"
 
-		_ CC = _CC /* ERROR cannot use _CC\(nil\) .* as CC value */ (nil)
-		_ SC = _CC /* ERROR cannot use _CC\(nil\) .* as SC value */ (nil)
-		_ RC = _CC /* ERROR cannot use _CC\(nil\) .* as RC value */ (nil)
+		_ CC = _CC /* ERROR "cannot use _CC\(nil\) .* as CC value" */ (nil)
+		_ SC = _CC /* ERROR "cannot use _CC\(nil\) .* as SC value" */ (nil)
+		_ RC = _CC /* ERROR "cannot use _CC\(nil\) .* as RC value" */ (nil)
 
-		_ CC = C // ERROR cannot use C .* as CC value
-		_ SC = C // ERROR cannot use C .* as SC value
-		_ RC = C // ERROR cannot use C .* as RC value
+		_ CC = C // ERROR "cannot use C .* as CC value"
+		_ SC = C // ERROR "cannot use C .* as SC value"
+		_ RC = C // ERROR "cannot use C .* as RC value"
 	)
 }
 
@@ -130,11 +130,11 @@ func _[
 	TP2 ~chan int | ~chan byte,
 ]() {
 	var (
-		_ TP0 = c // ERROR cannot use c .* as TP0 value
-		_ TP0 = C // ERROR cannot use C .* as TP0 value
+		_ TP0 = c // ERROR "cannot use c .* as TP0 value"
+		_ TP0 = C // ERROR "cannot use C .* as TP0 value"
 		_ TP1 = c
-		_ TP1 = C // ERROR cannot use C .* as TP1 value
-		_ TP2 = c // ERROR .* cannot assign chan int to chan byte
+		_ TP1 = C // ERROR "cannot use C .* as TP1 value"
+		_ TP2 = c // ERROR ".* cannot assign chan int to chan byte"
 	)
 }
 
@@ -147,34 +147,34 @@ func _[
 	i = X0
 	I = X0
 	c = X1
-	C = X1 // ERROR cannot use X1 .* as Chan value
-	c = X2 // ERROR .* cannot assign chan byte \(in TP2\) to chan int
+	C = X1 // ERROR "cannot use X1 .* as Chan value"
+	c = X2 // ERROR ".* cannot assign chan byte \(in TP2\) to chan int"
 }
 
 // "x is the predeclared identifier nil and T is a pointer, function, slice, map, channel, or interface type"
 func _[TP Interface](X TP) {
-	b = nil // ERROR cannot use nil
-	a = nil // ERROR cannot use nil
+	b = nil // ERROR "cannot use nil"
+	a = nil // ERROR "cannot use nil"
 	l = nil
-	s = nil // ERROR cannot use nil
+	s = nil // ERROR "cannot use nil"
 	p = nil
 	f = nil
 	i = nil
 	m = nil
 	c = nil
-	d = nil // ERROR cannot use nil
+	d = nil // ERROR "cannot use nil"
 
-	B = nil // ERROR cannot use nil
-	A = nil // ERROR cannot use nil
+	B = nil // ERROR "cannot use nil"
+	A = nil // ERROR "cannot use nil"
 	L = nil
-	S = nil // ERROR cannot use nil
+	S = nil // ERROR "cannot use nil"
 	P = nil
 	F = nil
 	I = nil
 	M = nil
 	C = nil
-	D = nil // ERROR cannot use nil
-	X = nil // ERROR cannot use nil
+	D = nil // ERROR "cannot use nil"
+	X = nil // ERROR "cannot use nil"
 }
 
 // "x is an untyped constant representable by a value of type T"
@@ -206,8 +206,8 @@ func _[
 
 	i8_16 = -1 << 7
 	i8_16 = 1<<7 - 1
-	i8_16 = - /* ERROR cannot use .* as Int8_16 */ 1 << 15
-	i8_16 = 1 /* ERROR cannot use .* as Int8_16 */ <<15 - 1
+	i8_16 = - /* ERROR "cannot use .* as Int8_16" */ 1 << 15
+	i8_16 = 1 /* ERROR "cannot use .* as Int8_16" */ <<15 - 1
 }
 
 // proto-types for tests
diff --git a/src/internal/types/testdata/spec/comparable.go b/src/internal/types/testdata/spec/comparable.go
index f407c356d3..211fa119a8 100644
--- a/src/internal/types/testdata/spec/comparable.go
+++ b/src/internal/types/testdata/spec/comparable.go
@@ -15,12 +15,12 @@ func _[P comparable, Q ~int, R any]() {
 	_ = f1[any /* any does satisfy comparable */]
 	_ = f1[P]
 	_ = f1[Q]
-	_ = f1[R /* ERROR R does not satisfy comparable */]
+	_ = f1[R /* ERROR "R does not satisfy comparable" */]
 
 	_ = f2[int]
 	_ = f2[T /* T does satisfy comparable */]
 	_ = f2[any /* any does satisfy comparable */]
 	_ = f2[P]
 	_ = f2[Q]
-	_ = f2[R /* ERROR R does not satisfy comparable */]
+	_ = f2[R /* ERROR "R does not satisfy comparable" */]
 }
diff --git a/src/internal/types/testdata/spec/comparable1.19.go b/src/internal/types/testdata/spec/comparable1.19.go
index dc1c5fa029..75b9fd3103 100644
--- a/src/internal/types/testdata/spec/comparable1.19.go
+++ b/src/internal/types/testdata/spec/comparable1.19.go
@@ -13,16 +13,16 @@ type T interface{ m() }
 
 func _[P comparable, Q ~int, R any]() {
 	_ = f1[int]
-	_ = f1[T /* ERROR T to satisfy comparable requires go1\.20 or later */]
-	_ = f1[any /* ERROR any to satisfy comparable requires go1\.20 or later */]
+	_ = f1[T /* ERROR "T to satisfy comparable requires go1\.20 or later" */]
+	_ = f1[any /* ERROR "any to satisfy comparable requires go1\.20 or later" */]
 	_ = f1[P]
 	_ = f1[Q]
-	_ = f1[R /* ERROR R does not satisfy comparable */]
+	_ = f1[R /* ERROR "R does not satisfy comparable" */]
 
 	_ = f2[int]
-	_ = f2[T /* ERROR T to satisfy comparable requires go1\.20 or later */]
-	_ = f2[any /* ERROR any to satisfy comparable requires go1\.20 or later */]
+	_ = f2[T /* ERROR "T to satisfy comparable requires go1\.20 or later" */]
+	_ = f2[any /* ERROR "any to satisfy comparable requires go1\.20 or later" */]
 	_ = f2[P]
 	_ = f2[Q]
-	_ = f2[R /* ERROR R does not satisfy comparable */]
+	_ = f2[R /* ERROR "R does not satisfy comparable" */]
 }
diff --git a/src/internal/types/testdata/spec/comparisons.go b/src/internal/types/testdata/spec/comparisons.go
index 886e78c0a7..36d8d7114c 100644
--- a/src/internal/types/testdata/spec/comparisons.go
+++ b/src/internal/types/testdata/spec/comparisons.go
@@ -29,37 +29,37 @@ var (
 )
 
 func _() {
-	_ = nil == nil // ERROR operator == not defined on untyped nil
+	_ = nil == nil // ERROR "operator == not defined on untyped nil"
 	_ = b == b
-	_ = a /* ERROR \[10\]func\(\) cannot be compared */ == a
-	_ = l /* ERROR slice can only be compared to nil */ == l
-	_ = s /* ERROR struct containing \[\]byte cannot be compared */ == s
+	_ = a /* ERROR "\[10\]func\(\) cannot be compared" */ == a
+	_ = l /* ERROR "slice can only be compared to nil" */ == l
+	_ = s /* ERROR "struct containing \[\]byte cannot be compared" */ == s
 	_ = p == p
-	_ = f /* ERROR func can only be compared to nil */ == f
+	_ = f /* ERROR "func can only be compared to nil" */ == f
 	_ = i == i
-	_ = m /* ERROR map can only be compared to nil */ == m
+	_ = m /* ERROR "map can only be compared to nil" */ == m
 	_ = c == c
 
-	_ = b == nil /* ERROR mismatched types */
-	_ = a == nil /* ERROR mismatched types */
+	_ = b == nil /* ERROR "mismatched types" */
+	_ = a == nil /* ERROR "mismatched types" */
 	_ = l == nil
-	_ = s == nil /* ERROR mismatched types */
+	_ = s == nil /* ERROR "mismatched types" */
 	_ = p == nil
 	_ = f == nil
 	_ = i == nil
 	_ = m == nil
 	_ = c == nil
 
-	_ = nil /* ERROR operator < not defined on untyped nil */ < nil
+	_ = nil /* ERROR "operator < not defined on untyped nil" */ < nil
 	_ = b < b
-	_ = a /* ERROR operator < not defined on array */ < a
-	_ = l /* ERROR operator < not defined on slice */ < l
-	_ = s /* ERROR operator < not defined on struct */ < s
-	_ = p /* ERROR operator < not defined on pointer */ < p
-	_ = f /* ERROR operator < not defined on func */ < f
-	_ = i /* ERROR operator < not defined on interface */ < i
-	_ = m /* ERROR operator < not defined on map */ < m
-	_ = c /* ERROR operator < not defined on chan */ < c
+	_ = a /* ERROR "operator < not defined on array" */ < a
+	_ = l /* ERROR "operator < not defined on slice" */ < l
+	_ = s /* ERROR "operator < not defined on struct" */ < s
+	_ = p /* ERROR "operator < not defined on pointer" */ < p
+	_ = f /* ERROR "operator < not defined on func" */ < f
+	_ = i /* ERROR "operator < not defined on interface" */ < i
+	_ = m /* ERROR "operator < not defined on map" */ < m
+	_ = c /* ERROR "operator < not defined on chan" */ < c
 }
 
 func _[
@@ -86,35 +86,35 @@ func _[
 	c C,
 ) {
 	_ = b == b
-	_ = a /* ERROR incomparable types in type set */ == a
-	_ = l /* ERROR incomparable types in type set */ == l
-	_ = s /* ERROR incomparable types in type set */ == s
+	_ = a /* ERROR "incomparable types in type set" */ == a
+	_ = l /* ERROR "incomparable types in type set" */ == l
+	_ = s /* ERROR "incomparable types in type set" */ == s
 	_ = p == p
-	_ = f /* ERROR incomparable types in type set */ == f
-	_ = i /* ERROR incomparable types in type set */ == i
+	_ = f /* ERROR "incomparable types in type set" */ == f
+	_ = i /* ERROR "incomparable types in type set" */ == i
 	_ = j == j
-	_ = m /* ERROR incomparable types in type set */ == m
+	_ = m /* ERROR "incomparable types in type set" */ == m
 	_ = c == c
 
-	_ = b == nil /* ERROR mismatched types */
-	_ = a == nil /* ERROR mismatched types */
+	_ = b == nil /* ERROR "mismatched types" */
+	_ = a == nil /* ERROR "mismatched types" */
 	_ = l == nil
-	_ = s == nil /* ERROR mismatched types */
+	_ = s == nil /* ERROR "mismatched types" */
 	_ = p == nil
 	_ = f == nil
-	_ = i == nil /* ERROR mismatched types */
-	_ = j == nil /* ERROR mismatched types */
+	_ = i == nil /* ERROR "mismatched types" */
+	_ = j == nil /* ERROR "mismatched types" */
 	_ = m == nil
 	_ = c == nil
 
 	_ = b < b
-	_ = a /* ERROR type parameter A is not comparable with < */ < a
-	_ = l /* ERROR type parameter L is not comparable with < */ < l
-	_ = s /* ERROR type parameter S is not comparable with < */ < s
-	_ = p /* ERROR type parameter P is not comparable with < */ < p
-	_ = f /* ERROR type parameter F is not comparable with < */ < f
-	_ = i /* ERROR type parameter I is not comparable with < */ < i
-	_ = j /* ERROR type parameter J is not comparable with < */ < j
-	_ = m /* ERROR type parameter M is not comparable with < */ < m
-	_ = c /* ERROR type parameter C is not comparable with < */ < c
+	_ = a /* ERROR "type parameter A is not comparable with <" */ < a
+	_ = l /* ERROR "type parameter L is not comparable with <" */ < l
+	_ = s /* ERROR "type parameter S is not comparable with <" */ < s
+	_ = p /* ERROR "type parameter P is not comparable with <" */ < p
+	_ = f /* ERROR "type parameter F is not comparable with <" */ < f
+	_ = i /* ERROR "type parameter I is not comparable with <" */ < i
+	_ = j /* ERROR "type parameter J is not comparable with <" */ < j
+	_ = m /* ERROR "type parameter M is not comparable with <" */ < m
+	_ = c /* ERROR "type parameter C is not comparable with <" */ < c
 }
diff --git a/src/internal/types/testdata/spec/conversions.go b/src/internal/types/testdata/spec/conversions.go
index fc014fc2b0..332373845a 100644
--- a/src/internal/types/testdata/spec/conversions.go
+++ b/src/internal/types/testdata/spec/conversions.go
@@ -9,22 +9,22 @@ import "unsafe"
 // constant conversions
 
 func _[T ~byte]() T { return 255 }
-func _[T ~byte]() T { return 256 /* ERROR cannot use 256 .* as T value */ }
+func _[T ~byte]() T { return 256 /* ERROR "cannot use 256 .* as T value" */ }
 
 func _[T ~byte]() {
-	const _ = T /* ERROR T\(0\) .* is not constant */ (0)
+	const _ = T /* ERROR "T\(0\) .* is not constant" */ (0)
 	var _ T = 255
-	var _ T = 256 // ERROR cannot use 256 .* as T value
+	var _ T = 256 // ERROR "cannot use 256 .* as T value"
 }
 
 func _[T ~string]() T                { return T('a') }
 func _[T ~int | ~string]() T         { return T('a') }
-func _[T ~byte | ~int | ~string]() T { return T(256 /* ERROR cannot convert 256 .* to type T */) }
+func _[T ~byte | ~int | ~string]() T { return T(256 /* ERROR "cannot convert 256 .* to type T" */) }
 
 // implicit conversions never convert to string
 func _[T ~string]() {
-	var _ string = 0 // ERROR cannot use .* as string value
-	var _ T = 0      // ERROR cannot use .* as T value
+	var _ string = 0 // ERROR "cannot use .* as string value"
+	var _ T = 0      // ERROR "cannot use .* as T value"
 }
 
 // failing const conversions of constants to type parameters report a cause
@@ -34,10 +34,10 @@ func _[
 	T3 ~int | ~float64 | ~bool,
 	T4 ~int | ~string,
 ]() {
-	_ = T1(0 /* ERROR cannot convert 0 .* to type T1: T1 does not contain specific types */)
-	_ = T2(1 /* ERROR cannot convert 1 .* to type T2: T2 does not contain specific types */)
-	_ = T3(2 /* ERROR cannot convert 2 .* to type T3: cannot convert 2 .* to type bool \(in T3\) */)
-	_ = T4(3.14 /* ERROR cannot convert 3.14 .* to type T4: cannot convert 3.14 .* to type int \(in T4\) */)
+	_ = T1(0 /* ERROR "cannot convert 0 .* to type T1: T1 does not contain specific types" */)
+	_ = T2(1 /* ERROR "cannot convert 1 .* to type T2: T2 does not contain specific types" */)
+	_ = T3(2 /* ERROR "cannot convert 2 .* to type T3: cannot convert 2 .* to type bool \(in T3\)" */)
+	_ = T4(3.14 /* ERROR "cannot convert 3.14 .* to type T4: cannot convert 3.14 .* to type int \(in T4\)" */)
 }
 
 // "x is assignable to T"
@@ -66,7 +66,7 @@ func _[X Foo, T Bar](x X) T       { return T(x) }
 func _[X Foo | Bar, T Bar](x X) T { return T(x) }
 func _[X Foo, T Foo | Bar](x X) T { return T(x) }
 func _[X Foo, T Far](x X) T {
-	return T(x /* ERROR cannot convert x \(variable of type X constrained by Foo\) to type T: cannot convert Foo \(in X\) to type Far \(in T\) */)
+	return T(x /* ERROR "cannot convert x \(variable of type X constrained by Foo\) to type T: cannot convert Foo \(in X\) to type Far \(in T\)" */)
 }
 
 // "x's type and T are unnamed pointer types and their pointer base types
@@ -76,7 +76,7 @@ func _[X ~*Foo, T ~*Bar](x X) T         { return T(x) }
 func _[X ~*Foo | ~*Bar, T ~*Bar](x X) T { return T(x) }
 func _[X ~*Foo, T ~*Foo | ~*Bar](x X) T { return T(x) }
 func _[X ~*Foo, T ~*Far](x X) T {
-	return T(x /* ERROR cannot convert x \(variable of type X constrained by ~\*Foo\) to type T: cannot convert \*Foo \(in X\) to type \*Far \(in T\) */)
+	return T(x /* ERROR "cannot convert x \(variable of type X constrained by ~\*Foo\) to type T: cannot convert \*Foo \(in X\) to type \*Far \(in T\)" */)
 }
 
 // Verify that the defined types in constraints are considered for the rule above.
@@ -88,10 +88,10 @@ type (
 	T0 *C
 )
 
-func _(x X0) T0           { return T0(x /* ERROR cannot convert */) } // non-generic reference
-func _[X X0, T T0](x X) T { return T(x /* ERROR cannot convert */) }
-func _[T T0](x X0) T      { return T(x /* ERROR cannot convert */) }
-func _[X X0](x X) T0      { return T0(x /* ERROR cannot convert */) }
+func _(x X0) T0           { return T0(x /* ERROR "cannot convert" */) } // non-generic reference
+func _[X X0, T T0](x X) T { return T(x /* ERROR "cannot convert" */) }
+func _[T T0](x X0) T      { return T(x /* ERROR "cannot convert" */) }
+func _[X X0](x X) T0      { return T0(x /* ERROR "cannot convert" */) }
 
 // "x's type and T are both integer or floating point types"
 
@@ -109,14 +109,14 @@ func _[X Float, T Float](x X) T    { return T(x) }
 
 func _[X, T Integer | Unsigned | Float](x X) T { return T(x) }
 func _[X, T Integer | ~string](x X) T {
-	return T(x /* ERROR cannot convert x \(variable of type X constrained by Integer \| ~string\) to type T: cannot convert string \(in X\) to type int \(in T\) */)
+	return T(x /* ERROR "cannot convert x \(variable of type X constrained by Integer \| ~string\) to type T: cannot convert string \(in X\) to type int \(in T\)" */)
 }
 
 // "x's type and T are both complex types"
 
 func _[X, T Complex](x X) T { return T(x) }
 func _[X, T Float | Complex](x X) T {
-	return T(x /* ERROR cannot convert x \(variable of type X constrained by Float \| Complex\) to type T: cannot convert float32 \(in X\) to type complex64 \(in T\) */)
+	return T(x /* ERROR "cannot convert x \(variable of type X constrained by Float \| Complex\) to type T: cannot convert float32 \(in X\) to type complex64 \(in T\)" */)
 }
 
 // "x is an integer or a slice of bytes or runes and T is a string type"
@@ -129,7 +129,7 @@ func _[T ~string](x myInt) T    { return T(x) }
 func _[X Integer](x X) string   { return string(x) }
 func _[X Integer](x X) myString { return myString(x) }
 func _[X Integer](x X) *string {
-	return (*string)(x /* ERROR cannot convert x \(variable of type X constrained by Integer\) to type \*string: cannot convert int \(in X\) to type \*string */)
+	return (*string)(x /* ERROR "cannot convert x \(variable of type X constrained by Integer\) to type \*string: cannot convert int \(in X\) to type \*string" */)
 }
 
 func _[T ~string](x []byte) T                           { return T(x) }
@@ -138,7 +138,7 @@ func _[X ~[]byte, T ~string](x X) T                     { return T(x) }
 func _[X ~[]rune, T ~string](x X) T                     { return T(x) }
 func _[X Integer | ~[]byte | ~[]rune, T ~string](x X) T { return T(x) }
 func _[X Integer | ~[]byte | ~[]rune, T ~*string](x X) T {
-	return T(x /* ERROR cannot convert x \(variable of type X constrained by Integer \| ~\[\]byte \| ~\[\]rune\) to type T: cannot convert int \(in X\) to type \*string \(in T\) */)
+	return T(x /* ERROR "cannot convert x \(variable of type X constrained by Integer \| ~\[\]byte \| ~\[\]rune\) to type T: cannot convert int \(in X\) to type \*string \(in T\)" */)
 }
 
 // "x is a string and T is a slice of bytes or runes"
@@ -146,14 +146,14 @@ func _[X Integer | ~[]byte | ~[]rune, T ~*string](x X) T {
 func _[T ~[]byte](x string) T { return T(x) }
 func _[T ~[]rune](x string) T { return T(x) }
 func _[T ~[]rune](x *string) T {
-	return T(x /* ERROR cannot convert x \(variable of type \*string\) to type T: cannot convert \*string to type \[\]rune \(in T\) */)
+	return T(x /* ERROR "cannot convert x \(variable of type \*string\) to type T: cannot convert \*string to type \[\]rune \(in T\)" */)
 }
 
 func _[X ~string, T ~[]byte](x X) T           { return T(x) }
 func _[X ~string, T ~[]rune](x X) T           { return T(x) }
 func _[X ~string, T ~[]byte | ~[]rune](x X) T { return T(x) }
 func _[X ~*string, T ~[]byte | ~[]rune](x X) T {
-	return T(x /* ERROR cannot convert x \(variable of type X constrained by ~\*string\) to type T: cannot convert \*string \(in X\) to type \[\]byte \(in T\) */)
+	return T(x /* ERROR "cannot convert x \(variable of type X constrained by ~\*string\) to type T: cannot convert \*string \(in X\) to type \[\]byte \(in T\)" */)
 }
 
 // package unsafe:
@@ -164,7 +164,7 @@ type myUintptr uintptr
 func _[X ~uintptr](x X) unsafe.Pointer  { return unsafe.Pointer(x) }
 func _[T unsafe.Pointer](x myUintptr) T { return T(x) }
 func _[T unsafe.Pointer](x int64) T {
-	return T(x /* ERROR cannot convert x \(variable of type int64\) to type T: cannot convert int64 to type unsafe\.Pointer \(in T\) */)
+	return T(x /* ERROR "cannot convert x \(variable of type int64\) to type T: cannot convert int64 to type unsafe\.Pointer \(in T\)" */)
 }
 
 // "and vice versa"
@@ -173,7 +173,7 @@ func _[T ~uintptr](x unsafe.Pointer) T  { return T(x) }
 func _[X unsafe.Pointer](x X) uintptr   { return uintptr(x) }
 func _[X unsafe.Pointer](x X) myUintptr { return myUintptr(x) }
 func _[X unsafe.Pointer](x X) int64 {
-	return int64(x /* ERROR cannot convert x \(variable of type X constrained by unsafe\.Pointer\) to type int64: cannot convert unsafe\.Pointer \(in X\) to type int64 */)
+	return int64(x /* ERROR "cannot convert x \(variable of type X constrained by unsafe\.Pointer\) to type int64: cannot convert unsafe\.Pointer \(in X\) to type int64" */)
 }
 
 // "x is a slice, T is an array or pointer-to-array type,
diff --git a/src/internal/types/testdata/spec/oldcomparable.go b/src/internal/types/testdata/spec/oldcomparable.go
index 081d972ab0..2d0e275fbe 100644
--- a/src/internal/types/testdata/spec/oldcomparable.go
+++ b/src/internal/types/testdata/spec/oldcomparable.go
@@ -13,16 +13,16 @@ type T interface{ m() }
 
 func _[P comparable, Q ~int, R any]() {
 	_ = f1[int]
-	_ = f1[T /* ERROR T does not satisfy comparable */]
-	_ = f1[any /* ERROR any does not satisfy comparable */]
+	_ = f1[T /* ERROR "T does not satisfy comparable" */]
+	_ = f1[any /* ERROR "any does not satisfy comparable" */]
 	_ = f1[P]
 	_ = f1[Q]
-	_ = f1[R /* ERROR R does not satisfy comparable */]
+	_ = f1[R /* ERROR "R does not satisfy comparable" */]
 
 	_ = f2[int]
-	_ = f2[T /* ERROR T does not satisfy comparable */]
-	_ = f2[any /* ERROR any does not satisfy comparable */]
+	_ = f2[T /* ERROR "T does not satisfy comparable" */]
+	_ = f2[any /* ERROR "any does not satisfy comparable" */]
 	_ = f2[P]
 	_ = f2[Q]
-	_ = f2[R /* ERROR R does not satisfy comparable */]
+	_ = f2[R /* ERROR "R does not satisfy comparable" */]
 }
