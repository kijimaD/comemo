commit 4a5d6916ede1a5547f78140c7594a9519bda90e7
Author: Lynn Boger <laboger@linux.vnet.ibm.com>
Date:   Tue Apr 21 17:21:10 2020 -0400

    cmd/compile: update PPC64.rules to use typed aux values
    
    Passes toolstash-check.
    
    Change-Id: I874f8b834ef2f94daa971ecef2dbe4e14daf4213
    Reviewed-on: https://go-review.googlesource.com/c/go/+/229305
    Run-TryBot: Lynn Boger <laboger@linux.vnet.ibm.com>
    TryBot-Result: Gobot Gobot <gobot@golang.org>
    Reviewed-by: Keith Randall <khr@golang.org>
---
 src/cmd/compile/internal/ssa/gen/PPC64.rules | 1614 ++++++------
 src/cmd/compile/internal/ssa/rewritePPC64.go | 3512 +++++++++++++-------------
 2 files changed, 2612 insertions(+), 2514 deletions(-)

diff --git a/src/cmd/compile/internal/ssa/gen/PPC64.rules b/src/cmd/compile/internal/ssa/gen/PPC64.rules
index 78fd8fb47b..47c6c90fc6 100644
--- a/src/cmd/compile/internal/ssa/gen/PPC64.rules
+++ b/src/cmd/compile/internal/ssa/gen/PPC64.rules
@@ -3,568 +3,568 @@
 // license that can be found in the LICENSE file.
 
 // Lowering arithmetic
-(Add(Ptr|64|32|16|8) ...) -> (ADD ...)
-(Add64F ...) -> (FADD ...)
-(Add32F ...) -> (FADDS ...)
-
-(Sub(Ptr|64|32|16|8) ...) -> (SUB ...)
-(Sub32F ...) -> (FSUBS ...)
-(Sub64F ...) -> (FSUB ...)
-
-(Mod16 x y) -> (Mod32 (SignExt16to32 x) (SignExt16to32 y))
-(Mod16u x y) -> (Mod32u (ZeroExt16to32 x) (ZeroExt16to32 y))
-(Mod8 x y) -> (Mod32 (SignExt8to32 x) (SignExt8to32 y))
-(Mod8u x y) -> (Mod32u (ZeroExt8to32 x) (ZeroExt8to32 y))
-(Mod64 x y) -> (SUB x (MULLD y (DIVD x y)))
-(Mod64u x y) -> (SUB x (MULLD y (DIVDU x y)))
-(Mod32 x y) -> (SUB x (MULLW y (DIVW x y)))
-(Mod32u x y) -> (SUB x (MULLW y (DIVWU x y)))
-
-// (x + y) / 2 with x>=y -> (x - y) / 2 + y
-(Avg64u <t> x y) -> (ADD (SRDconst <t> (SUB <t> x y) [1]) y)
-
-(Add64carry ...) -> (LoweredAdd64Carry ...)
-(Mul64 ...) -> (MULLD ...)
-(Mul(32|16|8) ...) -> (MULLW ...)
-(Mul64uhilo ...) -> (LoweredMuluhilo ...)
-
-(Div64 ...) -> (DIVD ...)
-(Div64u ...) -> (DIVDU ...)
-(Div32 ...) -> (DIVW ...)
-(Div32u ...) -> (DIVWU ...)
-(Div16  x y) -> (DIVW  (SignExt16to32 x) (SignExt16to32 y))
-(Div16u x y) -> (DIVWU (ZeroExt16to32 x) (ZeroExt16to32 y))
-(Div8   x y) -> (DIVW  (SignExt8to32 x) (SignExt8to32 y))
-(Div8u  x y) -> (DIVWU (ZeroExt8to32 x) (ZeroExt8to32 y))
-
-(Hmul(64|64u|32|32u) ...) -> (MULH(D|DU|W|WU) ...)
-
-(Mul32F ...) -> (FMULS ...)
-(Mul64F ...) -> (FMUL ...)
-
-(Div32F ...) -> (FDIVS ...)
-(Div64F ...) -> (FDIV ...)
-
-// Lowering float <-> int
-(Cvt32to32F x) -> (FCFIDS (MTVSRD (SignExt32to64 x)))
-(Cvt32to64F x) -> (FCFID (MTVSRD (SignExt32to64 x)))
-(Cvt64to32F x) -> (FCFIDS (MTVSRD x))
-(Cvt64to64F x) -> (FCFID (MTVSRD x))
-
-(Cvt32Fto32 x) -> (MFVSRD (FCTIWZ x))
-(Cvt32Fto64 x) -> (MFVSRD (FCTIDZ x))
-(Cvt64Fto32 x) -> (MFVSRD (FCTIWZ x))
-(Cvt64Fto64 x) -> (MFVSRD (FCTIDZ x))
-
-(Cvt32Fto64F ...) -> (Copy ...) // Note v will have the wrong type for patterns dependent on Float32/Float64
-(Cvt64Fto32F ...) -> (FRSP ...)
-
-(CvtBoolToUint8 ...) -> (Copy ...)
-
-(Round(32|64)F ...) -> (LoweredRound(32|64)F ...)
-
-(Sqrt ...) -> (FSQRT ...)
-(Floor ...) -> (FFLOOR ...)
-(Ceil ...) -> (FCEIL ...)
-(Trunc ...) -> (FTRUNC ...)
-(Round ...) -> (FROUND ...)
-(Copysign x y) -> (FCPSGN y x)
-(Abs ...) -> (FABS ...)
-(FMA ...) -> (FMADD ...)
+(Add(Ptr|64|32|16|8) ...) => (ADD ...)
+(Add64F ...) => (FADD ...)
+(Add32F ...) => (FADDS ...)
+
+(Sub(Ptr|64|32|16|8) ...) => (SUB ...)
+(Sub32F ...) => (FSUBS ...)
+(Sub64F ...) => (FSUB ...)
+
+(Mod16 x y) => (Mod32 (SignExt16to32 x) (SignExt16to32 y))
+(Mod16u x y) => (Mod32u (ZeroExt16to32 x) (ZeroExt16to32 y))
+(Mod8 x y) => (Mod32 (SignExt8to32 x) (SignExt8to32 y))
+(Mod8u x y) => (Mod32u (ZeroExt8to32 x) (ZeroExt8to32 y))
+(Mod64 x y) => (SUB x (MULLD y (DIVD x y)))
+(Mod64u x y) => (SUB x (MULLD y (DIVDU x y)))
+(Mod32 x y) => (SUB x (MULLW y (DIVW x y)))
+(Mod32u x y) => (SUB x (MULLW y (DIVWU x y)))
+
+// (x + y) / 2 with x>=y => (x - y) / 2 + y
+(Avg64u <t> x y) => (ADD (SRDconst <t> (SUB <t> x y) [1]) y)
+
+(Add64carry ...) => (LoweredAdd64Carry ...)
+(Mul64 ...) => (MULLD ...)
+(Mul(32|16|8) ...) => (MULLW ...)
+(Mul64uhilo ...) => (LoweredMuluhilo ...)
+
+(Div64 [false] x y) => (DIVD x y)
+(Div64u ...) => (DIVDU ...)
+(Div32 [false] x y) => (DIVW x y)
+(Div32u ...) => (DIVWU ...)
+(Div16 [false]  x y) => (DIVW  (SignExt16to32 x) (SignExt16to32 y))
+(Div16u x y) => (DIVWU (ZeroExt16to32 x) (ZeroExt16to32 y))
+(Div8 x y) => (DIVW  (SignExt8to32 x) (SignExt8to32 y))
+(Div8u x y) => (DIVWU (ZeroExt8to32 x) (ZeroExt8to32 y))
+
+(Hmul(64|64u|32|32u) ...) => (MULH(D|DU|W|WU) ...)
+
+(Mul32F ...) => (FMULS ...)
+(Mul64F ...) => (FMUL ...)
+
+(Div32F ...) => (FDIVS ...)
+(Div64F ...) => (FDIV ...)
+
+// Lowering float <=> int
+(Cvt32to32F x) => (FCFIDS (MTVSRD (SignExt32to64 x)))
+(Cvt32to64F x) => (FCFID (MTVSRD (SignExt32to64 x)))
+(Cvt64to32F x) => (FCFIDS (MTVSRD x))
+(Cvt64to64F x) => (FCFID (MTVSRD x))
+
+(Cvt32Fto32 x) => (MFVSRD (FCTIWZ x))
+(Cvt32Fto64 x) => (MFVSRD (FCTIDZ x))
+(Cvt64Fto32 x) => (MFVSRD (FCTIWZ x))
+(Cvt64Fto64 x) => (MFVSRD (FCTIDZ x))
+
+(Cvt32Fto64F ...) => (Copy ...) // Note v will have the wrong type for patterns dependent on Float32/Float64
+(Cvt64Fto32F ...) => (FRSP ...)
+
+(CvtBoolToUint8 ...) => (Copy ...)
+
+(Round(32|64)F ...) => (LoweredRound(32|64)F ...)
+
+(Sqrt ...) => (FSQRT ...)
+(Floor ...) => (FFLOOR ...)
+(Ceil ...) => (FCEIL ...)
+(Trunc ...) => (FTRUNC ...)
+(Round ...) => (FROUND ...)
+(Copysign x y) => (FCPSGN y x)
+(Abs ...) => (FABS ...)
+(FMA ...) => (FMADD ...)
 
 // Lowering constants
-(Const(64|32|16|8) ...) -> (MOVDconst ...)
-(Const(32|64)F ...) -> (FMOV(S|D)const ...)
-(ConstNil) -> (MOVDconst [0])
-(ConstBool ...) -> (MOVDconst ...)
+(Const(64|32|16|8) [val]) => (MOVDconst [int64(val)])
+(Const(32|64)F ...) => (FMOV(S|D)const ...)
+(ConstNil) => (MOVDconst [0])
+(ConstBool [b]) => (MOVDconst [b2i(b)])
 
 // Constant folding
-(FABS (FMOVDconst [x])) -> (FMOVDconst [auxFrom64F(math.Abs(auxTo64F(x)))])
-(FSQRT (FMOVDconst [x])) && auxTo64F(x) >= 0 -> (FMOVDconst [auxFrom64F(math.Sqrt(auxTo64F(x)))])
-(FFLOOR (FMOVDconst [x])) -> (FMOVDconst [auxFrom64F(math.Floor(auxTo64F(x)))])
-(FCEIL (FMOVDconst [x])) -> (FMOVDconst [auxFrom64F(math.Ceil(auxTo64F(x)))])
-(FTRUNC (FMOVDconst [x])) -> (FMOVDconst [auxFrom64F(math.Trunc(auxTo64F(x)))])
+(FABS (FMOVDconst [x])) => (FMOVDconst [math.Abs(x)])
+(FSQRT (FMOVDconst [x])) && x >= 0 => (FMOVDconst [math.Sqrt(x)])
+(FFLOOR (FMOVDconst [x])) => (FMOVDconst [math.Floor(x)])
+(FCEIL (FMOVDconst [x])) => (FMOVDconst [math.Ceil(x)])
+(FTRUNC (FMOVDconst [x])) => (FMOVDconst [math.Trunc(x)])
 
 // Rotates
-(RotateLeft8 <t> x (MOVDconst [c])) -> (Or8 (Lsh8x64 <t> x (MOVDconst [c&7])) (Rsh8Ux64 <t> x (MOVDconst [-c&7])))
-(RotateLeft16 <t> x (MOVDconst [c])) -> (Or16 (Lsh16x64 <t> x (MOVDconst [c&15])) (Rsh16Ux64 <t> x (MOVDconst [-c&15])))
-(RotateLeft32 x (MOVDconst [c])) -> (ROTLWconst [c&31] x)
-(RotateLeft64 x (MOVDconst [c])) -> (ROTLconst [c&63] x)
+(RotateLeft8 <t> x (MOVDconst [c])) => (Or8 (Lsh8x64 <t> x (MOVDconst [c&7])) (Rsh8Ux64 <t> x (MOVDconst [-c&7])))
+(RotateLeft16 <t> x (MOVDconst [c])) => (Or16 (Lsh16x64 <t> x (MOVDconst [c&15])) (Rsh16Ux64 <t> x (MOVDconst [-c&15])))
+(RotateLeft32 x (MOVDconst [c])) => (ROTLWconst [c&31] x)
+(RotateLeft64 x (MOVDconst [c])) => (ROTLconst [c&63] x)
 
 // Rotate generation with const shift
-(ADD (SLDconst x [c]) (SRDconst x [d])) && d == 64-c -> (ROTLconst [c] x)
-( OR (SLDconst x [c]) (SRDconst x [d])) && d == 64-c -> (ROTLconst [c] x)
-(XOR (SLDconst x [c]) (SRDconst x [d])) && d == 64-c -> (ROTLconst [c] x)
+(ADD (SLDconst x [c]) (SRDconst x [d])) && d == 64-c => (ROTLconst [c] x)
+( OR (SLDconst x [c]) (SRDconst x [d])) && d == 64-c => (ROTLconst [c] x)
+(XOR (SLDconst x [c]) (SRDconst x [d])) && d == 64-c => (ROTLconst [c] x)
 
-(ADD (SLWconst x [c]) (SRWconst x [d])) && d == 32-c -> (ROTLWconst [c] x)
-( OR (SLWconst x [c]) (SRWconst x [d])) && d == 32-c -> (ROTLWconst [c] x)
-(XOR (SLWconst x [c]) (SRWconst x [d])) && d == 32-c -> (ROTLWconst [c] x)
+(ADD (SLWconst x [c]) (SRWconst x [d])) && d == 32-c => (ROTLWconst [c] x)
+( OR (SLWconst x [c]) (SRWconst x [d])) && d == 32-c => (ROTLWconst [c] x)
+(XOR (SLWconst x [c]) (SRWconst x [d])) && d == 32-c => (ROTLWconst [c] x)
 
 // Rotate generation with non-const shift
 // these match patterns from math/bits/RotateLeft[32|64], but there could be others
-(ADD (SLD x (ANDconst <typ.Int64> [63] y)) (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))) -> (ROTL x y)
-( OR (SLD x (ANDconst <typ.Int64> [63] y)) (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))) -> (ROTL x y)
-(XOR (SLD x (ANDconst <typ.Int64> [63] y)) (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))) -> (ROTL x y)
+(ADD (SLD x (ANDconst <typ.Int64> [63] y)) (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))) => (ROTL x y)
+( OR (SLD x (ANDconst <typ.Int64> [63] y)) (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))) => (ROTL x y)
+(XOR (SLD x (ANDconst <typ.Int64> [63] y)) (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))) => (ROTL x y)
 
-(ADD (SLW x (ANDconst <typ.Int32> [31] y)) (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))) -> (ROTLW x y)
-( OR (SLW x (ANDconst <typ.Int32> [31] y)) (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))) -> (ROTLW x y)
-(XOR (SLW x (ANDconst <typ.Int32> [31] y)) (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))) -> (ROTLW x y)
+(ADD (SLW x (ANDconst <typ.Int32> [31] y)) (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))) => (ROTLW x y)
+( OR (SLW x (ANDconst <typ.Int32> [31] y)) (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))) => (ROTLW x y)
+(XOR (SLW x (ANDconst <typ.Int32> [31] y)) (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))) => (ROTLW x y)
 
 // Lowering rotates
-(RotateLeft32 x y) -> (ROTLW x y)
-(RotateLeft64 x y) -> (ROTL x y)
+(RotateLeft32 x y) => (ROTLW x y)
+(RotateLeft64 x y) => (ROTL x y)
 
 // Constant rotate generation
-(ROTLW  x (MOVDconst [c])) -> (ROTLWconst  x [c&31])
-(ROTL   x (MOVDconst [c])) -> (ROTLconst   x [c&63])
+(ROTLW  x (MOVDconst [c])) => (ROTLWconst  x [c&31])
+(ROTL   x (MOVDconst [c])) => (ROTLconst   x [c&63])
 
 
 // large constant shifts
-(Lsh64x64  _ (MOVDconst [c])) && uint64(c) >= 64 -> (MOVDconst [0])
-(Rsh64Ux64 _ (MOVDconst [c])) && uint64(c) >= 64 -> (MOVDconst [0])
-(Lsh32x64  _ (MOVDconst [c])) && uint64(c) >= 32 -> (MOVDconst [0])
-(Rsh32Ux64 _ (MOVDconst [c])) && uint64(c) >= 32 -> (MOVDconst [0])
-(Lsh16x64  _ (MOVDconst [c])) && uint64(c) >= 16 -> (MOVDconst [0])
-(Rsh16Ux64 _ (MOVDconst [c])) && uint64(c) >= 16 -> (MOVDconst [0])
-(Lsh8x64   _ (MOVDconst [c])) && uint64(c) >= 8  -> (MOVDconst [0])
-(Rsh8Ux64  _ (MOVDconst [c])) && uint64(c) >= 8  -> (MOVDconst [0])
+(Lsh64x64  _ (MOVDconst [c])) && uint64(c) >= 64 => (MOVDconst [0])
+(Rsh64Ux64 _ (MOVDconst [c])) && uint64(c) >= 64 => (MOVDconst [0])
+(Lsh32x64  _ (MOVDconst [c])) && uint64(c) >= 32 => (MOVDconst [0])
+(Rsh32Ux64 _ (MOVDconst [c])) && uint64(c) >= 32 => (MOVDconst [0])
+(Lsh16x64  _ (MOVDconst [c])) && uint64(c) >= 16 => (MOVDconst [0])
+(Rsh16Ux64 _ (MOVDconst [c])) && uint64(c) >= 16 => (MOVDconst [0])
+(Lsh8x64   _ (MOVDconst [c])) && uint64(c) >= 8  => (MOVDconst [0])
+(Rsh8Ux64  _ (MOVDconst [c])) && uint64(c) >= 8  => (MOVDconst [0])
 
 // large constant signed right shift, we leave the sign bit
-(Rsh64x64 x (MOVDconst [c])) && uint64(c) >= 64 -> (SRADconst x [63])
-(Rsh32x64 x (MOVDconst [c])) && uint64(c) >= 32 -> (SRAWconst x [63])
-(Rsh16x64 x (MOVDconst [c])) && uint64(c) >= 16 -> (SRAWconst (SignExt16to32 x) [63])
-(Rsh8x64  x (MOVDconst [c])) && uint64(c) >= 8  -> (SRAWconst (SignExt8to32  x) [63])
+(Rsh64x64 x (MOVDconst [c])) && uint64(c) >= 64 => (SRADconst x [63])
+(Rsh32x64 x (MOVDconst [c])) && uint64(c) >= 32 => (SRAWconst x [63])
+(Rsh16x64 x (MOVDconst [c])) && uint64(c) >= 16 => (SRAWconst (SignExt16to32 x) [63])
+(Rsh8x64  x (MOVDconst [c])) && uint64(c) >= 8  => (SRAWconst (SignExt8to32  x) [63])
 
 // constant shifts
-(Lsh64x64  x (MOVDconst [c])) && uint64(c) < 64 -> (SLDconst x [c])
-(Rsh64x64  x (MOVDconst [c])) && uint64(c) < 64 -> (SRADconst x [c])
-(Rsh64Ux64 x (MOVDconst [c])) && uint64(c) < 64 -> (SRDconst x [c])
-(Lsh32x64  x (MOVDconst [c])) && uint64(c) < 32 -> (SLWconst x [c])
-(Rsh32x64  x (MOVDconst [c])) && uint64(c) < 32 -> (SRAWconst x [c])
-(Rsh32Ux64 x (MOVDconst [c])) && uint64(c) < 32 -> (SRWconst x [c])
-(Lsh16x64  x (MOVDconst [c])) && uint64(c) < 16 -> (SLWconst x [c])
-(Rsh16x64  x (MOVDconst [c])) && uint64(c) < 16 -> (SRAWconst (SignExt16to32 x) [c])
-(Rsh16Ux64 x (MOVDconst [c])) && uint64(c) < 16 -> (SRWconst (ZeroExt16to32 x) [c])
-(Lsh8x64   x (MOVDconst [c])) && uint64(c) < 8  -> (SLWconst x [c])
-(Rsh8x64   x (MOVDconst [c])) && uint64(c) < 8  -> (SRAWconst (SignExt8to32  x) [c])
-(Rsh8Ux64  x (MOVDconst [c])) && uint64(c) < 8  -> (SRWconst (ZeroExt8to32  x) [c])
-
-(Lsh64x32  x (MOVDconst [c])) && uint32(c) < 64 -> (SLDconst x [c])
-(Rsh64x32  x (MOVDconst [c])) && uint32(c) < 64 -> (SRADconst x [c])
-(Rsh64Ux32 x (MOVDconst [c])) && uint32(c) < 64 -> (SRDconst x [c])
-(Lsh32x32  x (MOVDconst [c])) && uint32(c) < 32 -> (SLWconst x [c])
-(Rsh32x32  x (MOVDconst [c])) && uint32(c) < 32 -> (SRAWconst x [c])
-(Rsh32Ux32 x (MOVDconst [c])) && uint32(c) < 32 -> (SRWconst x [c])
-(Lsh16x32  x (MOVDconst [c])) && uint32(c) < 16 -> (SLWconst x [c])
-(Rsh16x32  x (MOVDconst [c])) && uint32(c) < 16 -> (SRAWconst (SignExt16to32 x) [c])
-(Rsh16Ux32 x (MOVDconst [c])) && uint32(c) < 16 -> (SRWconst (ZeroExt16to32 x) [c])
-(Lsh8x32   x (MOVDconst [c])) && uint32(c) < 8  -> (SLWconst x [c])
-(Rsh8x32   x (MOVDconst [c])) && uint32(c) < 8  -> (SRAWconst (SignExt8to32  x) [c])
-(Rsh8Ux32  x (MOVDconst [c])) && uint32(c) < 8  -> (SRWconst (ZeroExt8to32  x) [c])
+(Lsh64x64  x (MOVDconst [c])) && uint64(c) < 64 => (SLDconst x [c])
+(Rsh64x64  x (MOVDconst [c])) && uint64(c) < 64 => (SRADconst x [c])
+(Rsh64Ux64 x (MOVDconst [c])) && uint64(c) < 64 => (SRDconst x [c])
+(Lsh32x64  x (MOVDconst [c])) && uint64(c) < 32 => (SLWconst x [c])
+(Rsh32x64  x (MOVDconst [c])) && uint64(c) < 32 => (SRAWconst x [c])
+(Rsh32Ux64 x (MOVDconst [c])) && uint64(c) < 32 => (SRWconst x [c])
+(Lsh16x64  x (MOVDconst [c])) && uint64(c) < 16 => (SLWconst x [c])
+(Rsh16x64  x (MOVDconst [c])) && uint64(c) < 16 => (SRAWconst (SignExt16to32 x) [c])
+(Rsh16Ux64 x (MOVDconst [c])) && uint64(c) < 16 => (SRWconst (ZeroExt16to32 x) [c])
+(Lsh8x64   x (MOVDconst [c])) && uint64(c) < 8  => (SLWconst x [c])
+(Rsh8x64   x (MOVDconst [c])) && uint64(c) < 8  => (SRAWconst (SignExt8to32  x) [c])
+(Rsh8Ux64  x (MOVDconst [c])) && uint64(c) < 8  => (SRWconst (ZeroExt8to32  x) [c])
+
+(Lsh64x32  x (MOVDconst [c])) && uint32(c) < 64 => (SLDconst x [c])
+(Rsh64x32  x (MOVDconst [c])) && uint32(c) < 64 => (SRADconst x [c])
+(Rsh64Ux32 x (MOVDconst [c])) && uint32(c) < 64 => (SRDconst x [c])
+(Lsh32x32  x (MOVDconst [c])) && uint32(c) < 32 => (SLWconst x [c])
+(Rsh32x32  x (MOVDconst [c])) && uint32(c) < 32 => (SRAWconst x [c])
+(Rsh32Ux32 x (MOVDconst [c])) && uint32(c) < 32 => (SRWconst x [c])
+(Lsh16x32  x (MOVDconst [c])) && uint32(c) < 16 => (SLWconst x [c])
+(Rsh16x32  x (MOVDconst [c])) && uint32(c) < 16 => (SRAWconst (SignExt16to32 x) [c])
+(Rsh16Ux32 x (MOVDconst [c])) && uint32(c) < 16 => (SRWconst (ZeroExt16to32 x) [c])
+(Lsh8x32   x (MOVDconst [c])) && uint32(c) < 8  => (SLWconst x [c])
+(Rsh8x32   x (MOVDconst [c])) && uint32(c) < 8  => (SRAWconst (SignExt8to32  x) [c])
+(Rsh8Ux32  x (MOVDconst [c])) && uint32(c) < 8  => (SRWconst (ZeroExt8to32  x) [c])
 
 // Lower bounded shifts first. No need to check shift value.
-(Lsh64x(64|32|16|8)  x y) && shiftIsBounded(v) -> (SLD x y)
-(Lsh32x(64|32|16|8)  x y) && shiftIsBounded(v) -> (SLW x y)
-(Lsh16x(64|32|16|8)  x y) && shiftIsBounded(v) -> (SLW x y)
-(Lsh8x(64|32|16|8)   x y) && shiftIsBounded(v) -> (SLW x y)
-(Rsh64Ux(64|32|16|8) x y) && shiftIsBounded(v) -> (SRD x y)
-(Rsh32Ux(64|32|16|8) x y) && shiftIsBounded(v) -> (SRW x y)
-(Rsh16Ux(64|32|16|8) x y) && shiftIsBounded(v) -> (SRW (MOVHZreg x) y)
-(Rsh8Ux(64|32|16|8)  x y) && shiftIsBounded(v) -> (SRW (MOVBZreg x) y)
-(Rsh64x(64|32|16|8)  x y) && shiftIsBounded(v) -> (SRAD x y)
-(Rsh32x(64|32|16|8)  x y) && shiftIsBounded(v) -> (SRAW x y)
-(Rsh16x(64|32|16|8)  x y) && shiftIsBounded(v) -> (SRAW (MOVHreg x) y)
-(Rsh8x(64|32|16|8)   x y) && shiftIsBounded(v) -> (SRAW (MOVBreg x) y)
+(Lsh64x(64|32|16|8)  x y) && shiftIsBounded(v) => (SLD x y)
+(Lsh32x(64|32|16|8)  x y) && shiftIsBounded(v) => (SLW x y)
+(Lsh16x(64|32|16|8)  x y) && shiftIsBounded(v) => (SLW x y)
+(Lsh8x(64|32|16|8)   x y) && shiftIsBounded(v) => (SLW x y)
+(Rsh64Ux(64|32|16|8) x y) && shiftIsBounded(v) => (SRD x y)
+(Rsh32Ux(64|32|16|8) x y) && shiftIsBounded(v) => (SRW x y)
+(Rsh16Ux(64|32|16|8) x y) && shiftIsBounded(v) => (SRW (MOVHZreg x) y)
+(Rsh8Ux(64|32|16|8)  x y) && shiftIsBounded(v) => (SRW (MOVBZreg x) y)
+(Rsh64x(64|32|16|8)  x y) && shiftIsBounded(v) => (SRAD x y)
+(Rsh32x(64|32|16|8)  x y) && shiftIsBounded(v) => (SRAW x y)
+(Rsh16x(64|32|16|8)  x y) && shiftIsBounded(v) => (SRAW (MOVHreg x) y)
+(Rsh8x(64|32|16|8)   x y) && shiftIsBounded(v) => (SRAW (MOVBreg x) y)
 
 // non-constant rotates
 // These are subexpressions found in statements that can become rotates
 // In these cases the shift count is known to be < 64 so the more complicated expressions
 // with Mask & Carry is not needed
-(Lsh64x64 x (AND y (MOVDconst [63]))) -> (SLD x (ANDconst <typ.Int64> [63] y))
-(Lsh64x64 x (ANDconst <typ.Int64> [63] y)) -> (SLD x (ANDconst <typ.Int64> [63] y))
-(Rsh64Ux64 x (AND y (MOVDconst [63]))) -> (SRD x (ANDconst <typ.Int64> [63] y))
-(Rsh64Ux64 x (ANDconst <typ.UInt> [63] y)) -> (SRD x (ANDconst <typ.UInt> [63] y))
-(Rsh64Ux64 x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y))) -> (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
-(Rsh64Ux64 x (SUB <typ.UInt> (MOVDconst [64]) (AND <typ.UInt> y (MOVDconst [63])))) -> (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
-(Rsh64x64 x (AND y (MOVDconst [63]))) -> (SRAD x (ANDconst <typ.Int64> [63] y))
-(Rsh64x64 x (ANDconst <typ.UInt> [63] y)) -> (SRAD x (ANDconst <typ.UInt> [63] y))
-(Rsh64x64 x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y))) -> (SRAD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
-(Rsh64x64 x (SUB <typ.UInt> (MOVDconst [64]) (AND <typ.UInt> y (MOVDconst [63])))) -> (SRAD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
-
-(Lsh64x64 x y)  -> (SLD  x (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [64]))))
-(Rsh64x64 x y) -> (SRAD x (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [64]))))
-(Rsh64Ux64 x y) -> (SRD x (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [64]))))
-
-(Lsh32x64 x (AND y (MOVDconst [31]))) -> (SLW x (ANDconst <typ.Int32> [31] y))
-(Lsh32x64 x (ANDconst <typ.Int32> [31] y)) -> (SLW x (ANDconst <typ.Int32> [31] y))
-
-(Rsh32Ux64 x (AND y (MOVDconst [31]))) -> (SRW x (ANDconst <typ.Int32> [31] y))
-(Rsh32Ux64 x (ANDconst <typ.UInt> [31] y)) -> (SRW x (ANDconst <typ.UInt> [31] y))
-(Rsh32Ux64 x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y))) -> (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
-(Rsh32Ux64 x (SUB <typ.UInt> (MOVDconst [32]) (AND <typ.UInt> y (MOVDconst [31])))) -> (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
-
-(Rsh32x64 x (AND y (MOVDconst [31]))) -> (SRAW x (ANDconst <typ.Int32> [31] y))
-(Rsh32x64 x (ANDconst <typ.UInt> [31] y)) -> (SRAW x (ANDconst <typ.UInt> [31] y))
-(Rsh32x64 x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y))) -> (SRAW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
-(Rsh32x64 x (SUB <typ.UInt> (MOVDconst [32]) (AND <typ.UInt> y (MOVDconst [31])))) -> (SRAW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
-
-(Rsh32x64 x y)  -> (SRAW x (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [32]))))
-(Rsh32Ux64 x y) -> (SRW  x (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [32]))))
-(Lsh32x64 x y)  -> (SLW  x (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [32]))))
-
-(Rsh16x64 x y)  -> (SRAW (SignExt16to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [16]))))
-(Rsh16Ux64 x y) -> (SRW  (ZeroExt16to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [16]))))
-(Lsh16x64 x y)  -> (SLW  x                 (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [16]))))
-
-(Rsh8x64 x y)  -> (SRAW (SignExt8to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [8]))))
-(Rsh8Ux64 x y) -> (SRW  (ZeroExt8to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [8]))))
-(Lsh8x64 x y)  -> (SLW  x                (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [8]))))
-
-(Rsh64x32 x y)  -> (SRAD x (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [64]))))
-(Rsh64Ux32 x y) -> (SRD x  (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [64]))))
-(Lsh64x32 x y)  -> (SLD x  (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [64]))))
-(Rsh32x32 x y)  -> (SRAW x (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [32]))))
-(Rsh32Ux32 x y) -> (SRW x  (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [32]))))
-(Lsh32x32 x y)  -> (SLW x  (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [32]))))
-
-(Rsh16x32 x y)  -> (SRAW (SignExt16to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [16]))))
-(Rsh16Ux32 x y) -> (SRW  (ZeroExt16to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [16]))))
-(Lsh16x32 x y)  -> (SLW  x                 (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [16]))))
-
-(Rsh8x32 x y)  -> (SRAW (SignExt8to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [8]))))
-(Rsh8Ux32 x y) -> (SRW  (ZeroExt8to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [8]))))
-(Lsh8x32 x y)  -> (SLW  x                (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [8]))))
-
-
-(Rsh64x16 x y)  -> (SRAD x (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [64]))))
-(Rsh64Ux16 x y) -> (SRD x  (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [64]))))
-(Lsh64x16 x y)  -> (SLD x  (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [64]))))
-
-(Rsh32x16 x y)  -> (SRAW x (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [32]))))
-(Rsh32Ux16 x y) -> (SRW x  (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [32]))))
-(Lsh32x16 x y)  -> (SLW x  (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [32]))))
-
-(Rsh16x16 x y)  -> (SRAW (SignExt16to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [16]))))
-(Rsh16Ux16 x y) -> (SRW  (ZeroExt16to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [16]))))
-(Lsh16x16 x y)  -> (SLW  x                 (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [16]))))
-
-(Rsh8x16 x y)  -> (SRAW (SignExt8to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [8]))))
-(Rsh8Ux16 x y) -> (SRW  (ZeroExt8to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [8]))))
-(Lsh8x16 x y)  -> (SLW  x                (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [8]))))
-
-
-(Rsh64x8 x y)  -> (SRAD x (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [64]))))
-(Rsh64Ux8 x y) -> (SRD x  (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [64]))))
-(Lsh64x8 x y)  -> (SLD x  (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [64]))))
-
-(Rsh32x8 x y)  -> (SRAW x (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [32]))))
-(Rsh32Ux8 x y) -> (SRW x  (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [32]))))
-(Lsh32x8 x y)  -> (SLW x  (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [32]))))
-
-(Rsh16x8 x y)  -> (SRAW (SignExt16to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [16]))))
-(Rsh16Ux8 x y) -> (SRW  (ZeroExt16to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [16]))))
-(Lsh16x8 x y)  -> (SLW  x                 (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [16]))))
-
-(Rsh8x8 x y)  -> (SRAW (SignExt8to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [8]))))
-(Rsh8Ux8 x y) -> (SRW  (ZeroExt8to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [8]))))
-(Lsh8x8 x y)  -> (SLW  x                (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [8]))))
+(Lsh64x64 x (AND y (MOVDconst [63]))) => (SLD x (ANDconst <typ.Int64> [63] y))
+(Lsh64x64 x (ANDconst <typ.Int64> [63] y)) => (SLD x (ANDconst <typ.Int64> [63] y))
+(Rsh64Ux64 x (AND y (MOVDconst [63]))) => (SRD x (ANDconst <typ.Int64> [63] y))
+(Rsh64Ux64 x (ANDconst <typ.UInt> [63] y)) => (SRD x (ANDconst <typ.UInt> [63] y))
+(Rsh64Ux64 x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y))) => (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
+(Rsh64Ux64 x (SUB <typ.UInt> (MOVDconst [64]) (AND <typ.UInt> y (MOVDconst [63])))) => (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
+(Rsh64x64 x (AND y (MOVDconst [63]))) => (SRAD x (ANDconst <typ.Int64> [63] y))
+(Rsh64x64 x (ANDconst <typ.UInt> [63] y)) => (SRAD x (ANDconst <typ.UInt> [63] y))
+(Rsh64x64 x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y))) => (SRAD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
+(Rsh64x64 x (SUB <typ.UInt> (MOVDconst [64]) (AND <typ.UInt> y (MOVDconst [63])))) => (SRAD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
+
+(Lsh64x64 x y)  => (SLD  x (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [64]))))
+(Rsh64x64 x y) => (SRAD x (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [64]))))
+(Rsh64Ux64 x y) => (SRD x (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [64]))))
+
+(Lsh32x64 x (AND y (MOVDconst [31]))) => (SLW x (ANDconst <typ.Int32> [31] y))
+(Lsh32x64 x (ANDconst <typ.Int32> [31] y)) => (SLW x (ANDconst <typ.Int32> [31] y))
+
+(Rsh32Ux64 x (AND y (MOVDconst [31]))) => (SRW x (ANDconst <typ.Int32> [31] y))
+(Rsh32Ux64 x (ANDconst <typ.UInt> [31] y)) => (SRW x (ANDconst <typ.UInt> [31] y))
+(Rsh32Ux64 x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y))) => (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
+(Rsh32Ux64 x (SUB <typ.UInt> (MOVDconst [32]) (AND <typ.UInt> y (MOVDconst [31])))) => (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
+
+(Rsh32x64 x (AND y (MOVDconst [31]))) => (SRAW x (ANDconst <typ.Int32> [31] y))
+(Rsh32x64 x (ANDconst <typ.UInt> [31] y)) => (SRAW x (ANDconst <typ.UInt> [31] y))
+(Rsh32x64 x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y))) => (SRAW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
+(Rsh32x64 x (SUB <typ.UInt> (MOVDconst [32]) (AND <typ.UInt> y (MOVDconst [31])))) => (SRAW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
+
+(Rsh32x64 x y)  => (SRAW x (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [32]))))
+(Rsh32Ux64 x y) => (SRW  x (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [32]))))
+(Lsh32x64 x y)  => (SLW  x (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [32]))))
+
+(Rsh16x64 x y)  => (SRAW (SignExt16to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [16]))))
+(Rsh16Ux64 x y) => (SRW  (ZeroExt16to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [16]))))
+(Lsh16x64 x y)  => (SLW  x                 (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [16]))))
+
+(Rsh8x64 x y)  => (SRAW (SignExt8to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [8]))))
+(Rsh8Ux64 x y) => (SRW  (ZeroExt8to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [8]))))
+(Lsh8x64 x y)  => (SLW  x                (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [8]))))
+
+(Rsh64x32 x y)  => (SRAD x (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [64]))))
+(Rsh64Ux32 x y) => (SRD x  (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [64]))))
+(Lsh64x32 x y)  => (SLD x  (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [64]))))
+(Rsh32x32 x y)  => (SRAW x (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [32]))))
+(Rsh32Ux32 x y) => (SRW x  (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [32]))))
+(Lsh32x32 x y)  => (SLW x  (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [32]))))
+
+(Rsh16x32 x y)  => (SRAW (SignExt16to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [16]))))
+(Rsh16Ux32 x y) => (SRW  (ZeroExt16to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [16]))))
+(Lsh16x32 x y)  => (SLW  x                 (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [16]))))
+
+(Rsh8x32 x y)  => (SRAW (SignExt8to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [8]))))
+(Rsh8Ux32 x y) => (SRW  (ZeroExt8to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [8]))))
+(Lsh8x32 x y)  => (SLW  x                (ISEL [0] y (MOVDconst [-1]) (CMPU y (MOVDconst [8]))))
+
+
+(Rsh64x16 x y)  => (SRAD x (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [64]))))
+(Rsh64Ux16 x y) => (SRD x  (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [64]))))
+(Lsh64x16 x y)  => (SLD x  (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [64]))))
+
+(Rsh32x16 x y)  => (SRAW x (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [32]))))
+(Rsh32Ux16 x y) => (SRW x  (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [32]))))
+(Lsh32x16 x y)  => (SLW x  (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [32]))))
+
+(Rsh16x16 x y)  => (SRAW (SignExt16to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [16]))))
+(Rsh16Ux16 x y) => (SRW  (ZeroExt16to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [16]))))
+(Lsh16x16 x y)  => (SLW  x                 (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [16]))))
+
+(Rsh8x16 x y)  => (SRAW (SignExt8to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [8]))))
+(Rsh8Ux16 x y) => (SRW  (ZeroExt8to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [8]))))
+(Lsh8x16 x y)  => (SLW  x                (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt16to64 y) (MOVDconst [8]))))
+
+
+(Rsh64x8 x y)  => (SRAD x (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [64]))))
+(Rsh64Ux8 x y) => (SRD x  (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [64]))))
+(Lsh64x8 x y)  => (SLD x  (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [64]))))
+
+(Rsh32x8 x y)  => (SRAW x (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [32]))))
+(Rsh32Ux8 x y) => (SRW x  (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [32]))))
+(Lsh32x8 x y)  => (SLW x  (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [32]))))
+
+(Rsh16x8 x y)  => (SRAW (SignExt16to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [16]))))
+(Rsh16Ux8 x y) => (SRW  (ZeroExt16to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [16]))))
+(Lsh16x8 x y)  => (SLW  x                 (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [16]))))
+
+(Rsh8x8 x y)  => (SRAW (SignExt8to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [8]))))
+(Rsh8Ux8 x y) => (SRW  (ZeroExt8to32 x) (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [8]))))
+(Lsh8x8 x y)  => (SLW  x                (ISEL [0] y (MOVDconst [-1]) (CMPU (ZeroExt8to64 y) (MOVDconst [8]))))
 
 // Cleaning up shift ops when input is masked
-(MaskIfNotCarry (ADDconstForCarry [c] (ANDconst [d] _))) && c < 0 && d > 0 && c + d < 0 -> (MOVDconst [-1])
-(ISEL [0] (ANDconst [d] y) (MOVDconst [-1]) (CMPU (ANDconst [d] y) (MOVDconst [c]))) && c >= d -> (ANDconst [d] y)
-(ISEL [0] (ANDconst [d] y) (MOVDconst [-1]) (CMPUconst [c] (ANDconst [d] y))) && c >= d -> (ANDconst [d] y)
-(ORN x (MOVDconst [-1])) -> x
+(MaskIfNotCarry (ADDconstForCarry [c] (ANDconst [d] _))) && c < 0 && d > 0 && int64(c) + d < 0 => (MOVDconst [-1])
+(ISEL [0] (ANDconst [d] y) (MOVDconst [-1]) (CMPU (ANDconst [d] y) (MOVDconst [c]))) && c >= d => (ANDconst [d] y)
+(ISEL [0] (ANDconst [d] y) (MOVDconst [-1]) (CMPUconst [c] (ANDconst [d] y))) && c >= d => (ANDconst [d] y)
+(ORN x (MOVDconst [-1])) => x
 
-(ADDconstForCarry [c] (MOVDconst [d])) && int64(int16(c)) < 0 && (int64(int16(c)) <  0 || int64(int16(c)) + d >= 0) -> (FlagCarryClear)
-(ADDconstForCarry [c] (MOVDconst [d])) && int64(int16(c)) < 0 &&  int64(int16(c)) >= 0 && int64(int16(c)) + d <  0  -> (FlagCarrySet)
+(ADDconstForCarry [c] (MOVDconst [d])) && c < 0 && (int64(c) <  0 || int64(c) + d >= 0) => (FlagCarryClear)
+(ADDconstForCarry [c] (MOVDconst [d])) && c < 0 &&  int64(c) >= 0 && int64(c) + d <  0  => (FlagCarrySet)
 
-(MaskIfNotCarry (FlagCarrySet)) -> (MOVDconst [0])
-(MaskIfNotCarry (FlagCarryClear)) -> (MOVDconst [-1])
+(MaskIfNotCarry (FlagCarrySet)) => (MOVDconst [0])
+(MaskIfNotCarry (FlagCarryClear)) => (MOVDconst [-1])
 
-(S(RAD|RAW|RD|RW|LD|LW) x (MOVDconst [c])) -> (S(RAD|RAW|RD|RW|LD|LW)const [c] x)
+(S(RAD|RAW|RD|RW|LD|LW) x (MOVDconst [c])) => (S(RAD|RAW|RD|RW|LD|LW)const [c] x)
 
-(Addr ...) -> (MOVDaddr ...)
-(LocalAddr {sym} base _) -> (MOVDaddr {sym} base)
-(OffPtr [off] ptr) -> (ADD (MOVDconst <typ.Int64> [off]) ptr)
+(Addr {sym} base) => (MOVDaddr {sym} [0] base)
+(LocalAddr {sym} base _) => (MOVDaddr {sym} base)
+(OffPtr [off] ptr) => (ADD (MOVDconst <typ.Int64> [off]) ptr)
 
 // TODO: optimize these cases?
-(Ctz32NonZero ...) -> (Ctz32 ...)
-(Ctz64NonZero ...) -> (Ctz64 ...)
+(Ctz32NonZero ...) => (Ctz32 ...)
+(Ctz64NonZero ...) => (Ctz64 ...)
 
-(Ctz64 x) && objabi.GOPPC64<=8 -> (POPCNTD (ANDN <typ.Int64> (ADDconst <typ.Int64> [-1] x) x))
-(Ctz64 x) -> (CNTTZD x)
-(Ctz32 x) && objabi.GOPPC64<=8 -> (POPCNTW (MOVWZreg (ANDN <typ.Int> (ADDconst <typ.Int> [-1] x) x)))
-(Ctz32 x) -> (CNTTZW (MOVWZreg x))
-(Ctz16 x) -> (POPCNTW (MOVHZreg (ANDN <typ.Int16> (ADDconst <typ.Int16> [-1] x) x)))
-(Ctz8 x)  -> (POPCNTB (MOVBZreg (ANDN <typ.UInt8> (ADDconst <typ.UInt8> [-1] x) x)))
+(Ctz64 x) && objabi.GOPPC64<=8 => (POPCNTD (ANDN <typ.Int64> (ADDconst <typ.Int64> [-1] x) x))
+(Ctz64 x) => (CNTTZD x)
+(Ctz32 x) && objabi.GOPPC64<=8 => (POPCNTW (MOVWZreg (ANDN <typ.Int> (ADDconst <typ.Int> [-1] x) x)))
+(Ctz32 x) => (CNTTZW (MOVWZreg x))
+(Ctz16 x) => (POPCNTW (MOVHZreg (ANDN <typ.Int16> (ADDconst <typ.Int16> [-1] x) x)))
+(Ctz8 x)  => (POPCNTB (MOVBZreg (ANDN <typ.UInt8> (ADDconst <typ.UInt8> [-1] x) x)))
 
-(BitLen64 x) -> (SUB (MOVDconst [64]) (CNTLZD <typ.Int> x))
-(BitLen32 x) -> (SUB (MOVDconst [32]) (CNTLZW <typ.Int> x))
+(BitLen64 x) => (SUB (MOVDconst [64]) (CNTLZD <typ.Int> x))
+(BitLen32 x) => (SUB (MOVDconst [32]) (CNTLZW <typ.Int> x))
 
-(PopCount64 ...) -> (POPCNTD ...)
-(PopCount32 x) -> (POPCNTW (MOVWZreg x))
-(PopCount16 x) -> (POPCNTW (MOVHZreg x))
-(PopCount8 x) -> (POPCNTB (MOVBZreg x))
+(PopCount64 ...) => (POPCNTD ...)
+(PopCount32 x) => (POPCNTW (MOVWZreg x))
+(PopCount16 x) => (POPCNTW (MOVHZreg x))
+(PopCount8 x) => (POPCNTB (MOVBZreg x))
 
-(And(64|32|16|8) ...) -> (AND ...)
-(Or(64|32|16|8) ...) -> (OR ...)
-(Xor(64|32|16|8) ...) -> (XOR ...)
+(And(64|32|16|8) ...) => (AND ...)
+(Or(64|32|16|8) ...) => (OR ...)
+(Xor(64|32|16|8) ...) => (XOR ...)
 
-(Neg(64|32|16|8) ...) -> (NEG ...)
-(Neg64F ...) -> (FNEG ...)
-(Neg32F ...) -> (FNEG ...)
+(Neg(64|32|16|8) ...) => (NEG ...)
+(Neg64F ...) => (FNEG ...)
+(Neg32F ...) => (FNEG ...)
 
-(Com(64|32|16|8) x) -> (NOR x x)
+(Com(64|32|16|8) x) => (NOR x x)
 
 // Lowering boolean ops
-(AndB ...) -> (AND ...)
-(OrB ...) -> (OR ...)
-(Not x) -> (XORconst [1] x)
+(AndB ...) => (AND ...)
+(OrB ...) => (OR ...)
+(Not x) => (XORconst [1] x)
 
 // Use ANDN for AND x NOT y
-(AND x (NOR y y)) -> (ANDN x y)
+(AND x (NOR y y)) => (ANDN x y)
 
 // Lowering comparisons
-(EqB x y)  -> (ANDconst [1] (EQV x y))
+(EqB x y)  => (ANDconst [1] (EQV x y))
 // Sign extension dependence on operand sign sets up for sign/zero-extension elision later
-(Eq8 x y) && isSigned(x.Type) && isSigned(y.Type) -> (Equal (CMPW (SignExt8to32 x) (SignExt8to32 y)))
-(Eq16 x y) && isSigned(x.Type) && isSigned(y.Type) -> (Equal (CMPW (SignExt16to32 x) (SignExt16to32 y)))
-(Eq8 x y) -> (Equal (CMPW (ZeroExt8to32 x) (ZeroExt8to32 y)))
-(Eq16 x y) -> (Equal (CMPW (ZeroExt16to32 x) (ZeroExt16to32 y)))
-(Eq32 x y) -> (Equal (CMPW x y))
-(Eq64 x y) -> (Equal (CMP x y))
-(Eq32F x y) -> (Equal (FCMPU x y))
-(Eq64F x y) -> (Equal (FCMPU x y))
-(EqPtr x y) -> (Equal (CMP x y))
-
-(NeqB ...) -> (XOR ...)
+(Eq8 x y) && isSigned(x.Type) && isSigned(y.Type) => (Equal (CMPW (SignExt8to32 x) (SignExt8to32 y)))
+(Eq16 x y) && isSigned(x.Type) && isSigned(y.Type) => (Equal (CMPW (SignExt16to32 x) (SignExt16to32 y)))
+(Eq8 x y) => (Equal (CMPW (ZeroExt8to32 x) (ZeroExt8to32 y)))
+(Eq16 x y) => (Equal (CMPW (ZeroExt16to32 x) (ZeroExt16to32 y)))
+(Eq32 x y) => (Equal (CMPW x y))
+(Eq64 x y) => (Equal (CMP x y))
+(Eq32F x y) => (Equal (FCMPU x y))
+(Eq64F x y) => (Equal (FCMPU x y))
+(EqPtr x y) => (Equal (CMP x y))
+
+(NeqB ...) => (XOR ...)
 // Like Eq8 and Eq16, prefer sign extension likely to enable later elision.
-(Neq8 x y) && isSigned(x.Type) && isSigned(y.Type) -> (NotEqual (CMPW (SignExt8to32 x) (SignExt8to32 y)))
-(Neq16 x y) && isSigned(x.Type) && isSigned(y.Type) -> (NotEqual (CMPW (SignExt16to32 x) (SignExt16to32 y)))
-(Neq8 x y)  -> (NotEqual (CMPW (ZeroExt8to32 x) (ZeroExt8to32 y)))
-(Neq16 x y) -> (NotEqual (CMPW (ZeroExt16to32 x) (ZeroExt16to32 y)))
-(Neq32 x y) -> (NotEqual (CMPW x y))
-(Neq64 x y) -> (NotEqual (CMP x y))
-(Neq32F x y) -> (NotEqual (FCMPU x y))
-(Neq64F x y) -> (NotEqual (FCMPU x y))
-(NeqPtr x y) -> (NotEqual (CMP x y))
-
-(Less8 x y)  -> (LessThan (CMPW (SignExt8to32 x) (SignExt8to32 y)))
-(Less16 x y) -> (LessThan (CMPW (SignExt16to32 x) (SignExt16to32 y)))
-(Less32 x y) -> (LessThan (CMPW x y))
-(Less64 x y) -> (LessThan (CMP x y))
-(Less32F x y) -> (FLessThan (FCMPU x y))
-(Less64F x y) -> (FLessThan (FCMPU x y))
-
-(Less8U x y)  -> (LessThan (CMPWU (ZeroExt8to32 x) (ZeroExt8to32 y)))
-(Less16U x y) -> (LessThan (CMPWU (ZeroExt16to32 x) (ZeroExt16to32 y)))
-(Less32U x y) -> (LessThan (CMPWU x y))
-(Less64U x y) -> (LessThan (CMPU x y))
-
-(Leq8 x y)  -> (LessEqual (CMPW (SignExt8to32 x) (SignExt8to32 y)))
-(Leq16 x y) -> (LessEqual (CMPW (SignExt16to32 x) (SignExt16to32 y)))
-(Leq32 x y) -> (LessEqual (CMPW x y))
-(Leq64 x y) -> (LessEqual (CMP x y))
-(Leq32F x y) -> (FLessEqual (FCMPU x y))
-(Leq64F x y) -> (FLessEqual (FCMPU x y))
-
-(Leq8U x y)  -> (LessEqual (CMPWU (ZeroExt8to32 x) (ZeroExt8to32 y)))
-(Leq16U x y) -> (LessEqual (CMPWU (ZeroExt16to32 x) (ZeroExt16to32 y)))
-(Leq32U x y) -> (LessEqual (CMPWU x y))
-(Leq64U x y) -> (LessEqual (CMPU x y))
+(Neq8 x y) && isSigned(x.Type) && isSigned(y.Type) => (NotEqual (CMPW (SignExt8to32 x) (SignExt8to32 y)))
+(Neq16 x y) && isSigned(x.Type) && isSigned(y.Type) => (NotEqual (CMPW (SignExt16to32 x) (SignExt16to32 y)))
+(Neq8 x y)  => (NotEqual (CMPW (ZeroExt8to32 x) (ZeroExt8to32 y)))
+(Neq16 x y) => (NotEqual (CMPW (ZeroExt16to32 x) (ZeroExt16to32 y)))
+(Neq32 x y) => (NotEqual (CMPW x y))
+(Neq64 x y) => (NotEqual (CMP x y))
+(Neq32F x y) => (NotEqual (FCMPU x y))
+(Neq64F x y) => (NotEqual (FCMPU x y))
+(NeqPtr x y) => (NotEqual (CMP x y))
+
+(Less8 x y)  => (LessThan (CMPW (SignExt8to32 x) (SignExt8to32 y)))
+(Less16 x y) => (LessThan (CMPW (SignExt16to32 x) (SignExt16to32 y)))
+(Less32 x y) => (LessThan (CMPW x y))
+(Less64 x y) => (LessThan (CMP x y))
+(Less32F x y) => (FLessThan (FCMPU x y))
+(Less64F x y) => (FLessThan (FCMPU x y))
+
+(Less8U x y)  => (LessThan (CMPWU (ZeroExt8to32 x) (ZeroExt8to32 y)))
+(Less16U x y) => (LessThan (CMPWU (ZeroExt16to32 x) (ZeroExt16to32 y)))
+(Less32U x y) => (LessThan (CMPWU x y))
+(Less64U x y) => (LessThan (CMPU x y))
+
+(Leq8 x y)  => (LessEqual (CMPW (SignExt8to32 x) (SignExt8to32 y)))
+(Leq16 x y) => (LessEqual (CMPW (SignExt16to32 x) (SignExt16to32 y)))
+(Leq32 x y) => (LessEqual (CMPW x y))
+(Leq64 x y) => (LessEqual (CMP x y))
+(Leq32F x y) => (FLessEqual (FCMPU x y))
+(Leq64F x y) => (FLessEqual (FCMPU x y))
+
+(Leq8U x y)  => (LessEqual (CMPWU (ZeroExt8to32 x) (ZeroExt8to32 y)))
+(Leq16U x y) => (LessEqual (CMPWU (ZeroExt16to32 x) (ZeroExt16to32 y)))
+(Leq32U x y) => (LessEqual (CMPWU x y))
+(Leq64U x y) => (LessEqual (CMPU x y))
 
 // Absorb pseudo-ops into blocks.
-(If (Equal cc) yes no) -> (EQ cc yes no)
-(If (NotEqual cc) yes no) -> (NE cc yes no)
-(If (LessThan cc) yes no) -> (LT cc yes no)
-(If (LessEqual cc) yes no) -> (LE cc yes no)
-(If (GreaterThan cc) yes no) -> (GT cc yes no)
-(If (GreaterEqual cc) yes no) -> (GE cc yes no)
-(If (FLessThan cc) yes no) -> (FLT cc yes no)
-(If (FLessEqual cc) yes no) -> (FLE cc yes no)
-(If (FGreaterThan cc) yes no) -> (FGT cc yes no)
-(If (FGreaterEqual cc) yes no) -> (FGE cc yes no)
-
-(If cond yes no) -> (NE (CMPWconst [0] cond) yes no)
+(If (Equal cc) yes no) => (EQ cc yes no)
+(If (NotEqual cc) yes no) => (NE cc yes no)
+(If (LessThan cc) yes no) => (LT cc yes no)
+(If (LessEqual cc) yes no) => (LE cc yes no)
+(If (GreaterThan cc) yes no) => (GT cc yes no)
+(If (GreaterEqual cc) yes no) => (GE cc yes no)
+(If (FLessThan cc) yes no) => (FLT cc yes no)
+(If (FLessEqual cc) yes no) => (FLE cc yes no)
+(If (FGreaterThan cc) yes no) => (FGT cc yes no)
+(If (FGreaterEqual cc) yes no) => (FGE cc yes no)
+
+(If cond yes no) => (NE (CMPWconst [0] cond) yes no)
 
 // Absorb boolean tests into block
-(NE (CMPWconst [0] (Equal cc)) yes no) -> (EQ cc yes no)
-(NE (CMPWconst [0] (NotEqual cc)) yes no) -> (NE cc yes no)
-(NE (CMPWconst [0] (LessThan cc)) yes no) -> (LT cc yes no)
-(NE (CMPWconst [0] (LessEqual cc)) yes no) -> (LE cc yes no)
-(NE (CMPWconst [0] (GreaterThan cc)) yes no) -> (GT cc yes no)
-(NE (CMPWconst [0] (GreaterEqual cc)) yes no) -> (GE cc yes no)
-(NE (CMPWconst [0] (FLessThan cc)) yes no) -> (FLT cc yes no)
-(NE (CMPWconst [0] (FLessEqual cc)) yes no) -> (FLE cc yes no)
-(NE (CMPWconst [0] (FGreaterThan cc)) yes no) -> (FGT cc yes no)
-(NE (CMPWconst [0] (FGreaterEqual cc)) yes no) -> (FGE cc yes no)
+(NE (CMPWconst [0] (Equal cc)) yes no) => (EQ cc yes no)
+(NE (CMPWconst [0] (NotEqual cc)) yes no) => (NE cc yes no)
+(NE (CMPWconst [0] (LessThan cc)) yes no) => (LT cc yes no)
+(NE (CMPWconst [0] (LessEqual cc)) yes no) => (LE cc yes no)
+(NE (CMPWconst [0] (GreaterThan cc)) yes no) => (GT cc yes no)
+(NE (CMPWconst [0] (GreaterEqual cc)) yes no) => (GE cc yes no)
+(NE (CMPWconst [0] (FLessThan cc)) yes no) => (FLT cc yes no)
+(NE (CMPWconst [0] (FLessEqual cc)) yes no) => (FLE cc yes no)
+(NE (CMPWconst [0] (FGreaterThan cc)) yes no) => (FGT cc yes no)
+(NE (CMPWconst [0] (FGreaterEqual cc)) yes no) => (FGE cc yes no)
 
 // Elide compares of bit tests // TODO need to make both CC and result of ANDCC available.
-(EQ (CMPconst [0] (ANDconst [c] x)) yes no) -> (EQ (ANDCCconst [c] x) yes no)
-(NE (CMPconst [0] (ANDconst [c] x)) yes no) -> (NE (ANDCCconst [c] x) yes no)
-(EQ (CMPWconst [0] (ANDconst [c] x)) yes no) -> (EQ (ANDCCconst [c] x) yes no)
-(NE (CMPWconst [0] (ANDconst [c] x)) yes no) -> (NE (ANDCCconst [c] x) yes no)
+(EQ (CMPconst [0] (ANDconst [c] x)) yes no) => (EQ (ANDCCconst [c] x) yes no)
+(NE (CMPconst [0] (ANDconst [c] x)) yes no) => (NE (ANDCCconst [c] x) yes no)
+(EQ (CMPWconst [0] (ANDconst [c] x)) yes no) => (EQ (ANDCCconst [c] x) yes no)
+(NE (CMPWconst [0] (ANDconst [c] x)) yes no) => (NE (ANDCCconst [c] x) yes no)
 
 // absorb flag constants into branches
-(EQ (FlagEQ) yes no) -> (First yes no)
-(EQ (FlagLT) yes no) -> (First no yes)
-(EQ (FlagGT) yes no) -> (First no yes)
+(EQ (FlagEQ) yes no) => (First yes no)
+(EQ (FlagLT) yes no) => (First no yes)
+(EQ (FlagGT) yes no) => (First no yes)
 
-(NE (FlagEQ) yes no) -> (First no yes)
-(NE (FlagLT) yes no) -> (First yes no)
-(NE (FlagGT) yes no) -> (First yes no)
+(NE (FlagEQ) yes no) => (First no yes)
+(NE (FlagLT) yes no) => (First yes no)
+(NE (FlagGT) yes no) => (First yes no)
 
-(LT (FlagEQ) yes no) -> (First no yes)
-(LT (FlagLT) yes no) -> (First yes no)
-(LT (FlagGT) yes no) -> (First no yes)
+(LT (FlagEQ) yes no) => (First no yes)
+(LT (FlagLT) yes no) => (First yes no)
+(LT (FlagGT) yes no) => (First no yes)
 
-(LE (FlagEQ) yes no) -> (First yes no)
-(LE (FlagLT) yes no) -> (First yes no)
-(LE (FlagGT) yes no) -> (First no yes)
+(LE (FlagEQ) yes no) => (First yes no)
+(LE (FlagLT) yes no) => (First yes no)
+(LE (FlagGT) yes no) => (First no yes)
 
-(GT (FlagEQ) yes no) -> (First no yes)
-(GT (FlagLT) yes no) -> (First no yes)
-(GT (FlagGT) yes no) -> (First yes no)
+(GT (FlagEQ) yes no) => (First no yes)
+(GT (FlagLT) yes no) => (First no yes)
+(GT (FlagGT) yes no) => (First yes no)
 
-(GE (FlagEQ) yes no) -> (First yes no)
-(GE (FlagLT) yes no) -> (First no yes)
-(GE (FlagGT) yes no) -> (First yes no)
+(GE (FlagEQ) yes no) => (First yes no)
+(GE (FlagLT) yes no) => (First no yes)
+(GE (FlagGT) yes no) => (First yes no)
 
 // absorb InvertFlags into branches
-(LT (InvertFlags cmp) yes no) -> (GT cmp yes no)
-(GT (InvertFlags cmp) yes no) -> (LT cmp yes no)
-(LE (InvertFlags cmp) yes no) -> (GE cmp yes no)
-(GE (InvertFlags cmp) yes no) -> (LE cmp yes no)
-(EQ (InvertFlags cmp) yes no) -> (EQ cmp yes no)
-(NE (InvertFlags cmp) yes no) -> (NE cmp yes no)
+(LT (InvertFlags cmp) yes no) => (GT cmp yes no)
+(GT (InvertFlags cmp) yes no) => (LT cmp yes no)
+(LE (InvertFlags cmp) yes no) => (GE cmp yes no)
+(GE (InvertFlags cmp) yes no) => (LE cmp yes no)
+(EQ (InvertFlags cmp) yes no) => (EQ cmp yes no)
+(NE (InvertFlags cmp) yes no) => (NE cmp yes no)
 
 // constant comparisons
-(CMPWconst (MOVDconst [x]) [y]) && int32(x)==int32(y) -> (FlagEQ)
-(CMPWconst (MOVDconst [x]) [y]) && int32(x)<int32(y)  -> (FlagLT)
-(CMPWconst (MOVDconst [x]) [y]) && int32(x)>int32(y)  -> (FlagGT)
+(CMPWconst (MOVDconst [x]) [y]) && int32(x)==int32(y) => (FlagEQ)
+(CMPWconst (MOVDconst [x]) [y]) && int32(x)<int32(y)  => (FlagLT)
+(CMPWconst (MOVDconst [x]) [y]) && int32(x)>int32(y)  => (FlagGT)
 
-(CMPconst (MOVDconst [x]) [y]) && x==y -> (FlagEQ)
-(CMPconst (MOVDconst [x]) [y]) && x<y  -> (FlagLT)
-(CMPconst (MOVDconst [x]) [y]) && x>y  -> (FlagGT)
+(CMPconst (MOVDconst [x]) [y]) && x==y => (FlagEQ)
+(CMPconst (MOVDconst [x]) [y]) && x<y  => (FlagLT)
+(CMPconst (MOVDconst [x]) [y]) && x>y  => (FlagGT)
 
-(CMPWUconst (MOVDconst [x]) [y]) && int32(x)==int32(y)  -> (FlagEQ)
-(CMPWUconst (MOVDconst [x]) [y]) && uint32(x)<uint32(y) -> (FlagLT)
-(CMPWUconst (MOVDconst [x]) [y]) && uint32(x)>uint32(y) -> (FlagGT)
+(CMPWUconst (MOVDconst [x]) [y]) && int32(x)==int32(y)  => (FlagEQ)
+(CMPWUconst (MOVDconst [x]) [y]) && uint32(x)<uint32(y) => (FlagLT)
+(CMPWUconst (MOVDconst [x]) [y]) && uint32(x)>uint32(y) => (FlagGT)
 
-(CMPUconst (MOVDconst [x]) [y]) && x==y  -> (FlagEQ)
-(CMPUconst (MOVDconst [x]) [y]) && uint64(x)<uint64(y) -> (FlagLT)
-(CMPUconst (MOVDconst [x]) [y]) && uint64(x)>uint64(y) -> (FlagGT)
+(CMPUconst (MOVDconst [x]) [y]) && x==y  => (FlagEQ)
+(CMPUconst (MOVDconst [x]) [y]) && uint64(x)<uint64(y) => (FlagLT)
+(CMPUconst (MOVDconst [x]) [y]) && uint64(x)>uint64(y) => (FlagGT)
 
 // other known comparisons
-//(CMPconst (MOVBUreg _) [c]) && 0xff < c -> (FlagLT)
-//(CMPconst (MOVHUreg _) [c]) && 0xffff < c -> (FlagLT)
-//(CMPconst (ANDconst _ [m]) [n]) && 0 <= int32(m) && int32(m) < int32(n) -> (FlagLT)
-//(CMPconst (SRLconst _ [c]) [n]) && 0 <= n && 0 < c && c <= 32 && (1<<uint32(32-c)) <= uint32(n) -> (FlagLT)
+//(CMPconst (MOVBUreg _) [c]) && 0xff < c => (FlagLT)
+//(CMPconst (MOVHUreg _) [c]) && 0xffff < c => (FlagLT)
+//(CMPconst (ANDconst _ [m]) [n]) && 0 <= int32(m) && int32(m) < int32(n) => (FlagLT)
+//(CMPconst (SRLconst _ [c]) [n]) && 0 <= n && 0 < c && c <= 32 && (1<<uint32(32-c)) <= uint32(n) => (FlagLT)
 
 // absorb flag constants into boolean values
-(Equal (FlagEQ)) -> (MOVDconst [1])
-(Equal (FlagLT)) -> (MOVDconst [0])
-(Equal (FlagGT)) -> (MOVDconst [0])
+(Equal (FlagEQ)) => (MOVDconst [1])
+(Equal (FlagLT)) => (MOVDconst [0])
+(Equal (FlagGT)) => (MOVDconst [0])
 
-(NotEqual (FlagEQ)) -> (MOVDconst [0])
-(NotEqual (FlagLT)) -> (MOVDconst [1])
-(NotEqual (FlagGT)) -> (MOVDconst [1])
+(NotEqual (FlagEQ)) => (MOVDconst [0])
+(NotEqual (FlagLT)) => (MOVDconst [1])
+(NotEqual (FlagGT)) => (MOVDconst [1])
 
-(LessThan (FlagEQ)) -> (MOVDconst [0])
-(LessThan (FlagLT)) -> (MOVDconst [1])
-(LessThan (FlagGT)) -> (MOVDconst [0])
+(LessThan (FlagEQ)) => (MOVDconst [0])
+(LessThan (FlagLT)) => (MOVDconst [1])
+(LessThan (FlagGT)) => (MOVDconst [0])
 
-(LessEqual (FlagEQ)) -> (MOVDconst [1])
-(LessEqual (FlagLT)) -> (MOVDconst [1])
-(LessEqual (FlagGT)) -> (MOVDconst [0])
+(LessEqual (FlagEQ)) => (MOVDconst [1])
+(LessEqual (FlagLT)) => (MOVDconst [1])
+(LessEqual (FlagGT)) => (MOVDconst [0])
 
-(GreaterThan (FlagEQ)) -> (MOVDconst [0])
-(GreaterThan (FlagLT)) -> (MOVDconst [0])
-(GreaterThan (FlagGT)) -> (MOVDconst [1])
+(GreaterThan (FlagEQ)) => (MOVDconst [0])
+(GreaterThan (FlagLT)) => (MOVDconst [0])
+(GreaterThan (FlagGT)) => (MOVDconst [1])
 
-(GreaterEqual (FlagEQ)) -> (MOVDconst [1])
-(GreaterEqual (FlagLT)) -> (MOVDconst [0])
-(GreaterEqual (FlagGT)) -> (MOVDconst [1])
+(GreaterEqual (FlagEQ)) => (MOVDconst [1])
+(GreaterEqual (FlagLT)) => (MOVDconst [0])
+(GreaterEqual (FlagGT)) => (MOVDconst [1])
 
 // absorb InvertFlags into boolean values
-(Equal (InvertFlags x)) -> (Equal x)
-(NotEqual (InvertFlags x)) -> (NotEqual x)
-(LessThan (InvertFlags x)) -> (GreaterThan x)
-(GreaterThan (InvertFlags x)) -> (LessThan x)
-(LessEqual (InvertFlags x)) -> (GreaterEqual x)
-(GreaterEqual (InvertFlags x)) -> (LessEqual x)
+(Equal (InvertFlags x)) => (Equal x)
+(NotEqual (InvertFlags x)) => (NotEqual x)
+(LessThan (InvertFlags x)) => (GreaterThan x)
+(GreaterThan (InvertFlags x)) => (LessThan x)
+(LessEqual (InvertFlags x)) => (GreaterEqual x)
+(GreaterEqual (InvertFlags x)) => (LessEqual x)
 
 // Elide compares of bit tests // TODO need to make both CC and result of ANDCC available.
-((EQ|NE|LT|LE|GT|GE) (CMPconst [0] (ANDconst [c] x)) yes no) -> ((EQ|NE|LT|LE|GT|GE) (ANDCCconst [c] x) yes no)
-((EQ|NE|LT|LE|GT|GE) (CMPWconst [0] (ANDconst [c] x)) yes no) -> ((EQ|NE|LT|LE|GT|GE) (ANDCCconst [c] x) yes no)
-((EQ|NE|LT|LE|GT|GE) (CMPconst [0] z:(AND x y)) yes no) && z.Uses == 1 -> ((EQ|NE|LT|LE|GT|GE) (ANDCC x y) yes no)
-((EQ|NE|LT|LE|GT|GE) (CMPconst [0] z:(OR x y)) yes no) && z.Uses == 1 -> ((EQ|NE|LT|LE|GT|GE) (ORCC x y) yes no)
-((EQ|NE|LT|LE|GT|GE) (CMPconst [0] z:(XOR x y)) yes no) && z.Uses == 1 -> ((EQ|NE|LT|LE|GT|GE) (XORCC x y) yes no)
+((EQ|NE|LT|LE|GT|GE) (CMPconst [0] (ANDconst [c] x)) yes no) => ((EQ|NE|LT|LE|GT|GE) (ANDCCconst [c] x) yes no)
+((EQ|NE|LT|LE|GT|GE) (CMPWconst [0] (ANDconst [c] x)) yes no) => ((EQ|NE|LT|LE|GT|GE) (ANDCCconst [c] x) yes no)
+((EQ|NE|LT|LE|GT|GE) (CMPconst [0] z:(AND x y)) yes no) && z.Uses == 1 => ((EQ|NE|LT|LE|GT|GE) (ANDCC x y) yes no)
+((EQ|NE|LT|LE|GT|GE) (CMPconst [0] z:(OR x y)) yes no) && z.Uses == 1 => ((EQ|NE|LT|LE|GT|GE) (ORCC x y) yes no)
+((EQ|NE|LT|LE|GT|GE) (CMPconst [0] z:(XOR x y)) yes no) && z.Uses == 1 => ((EQ|NE|LT|LE|GT|GE) (XORCC x y) yes no)
 
-(CondSelect x y bool) && flagArg(bool) != nil -> (ISEL [2] x y bool)
-(CondSelect x y bool) && flagArg(bool) == nil -> (ISEL [2] x y (CMPWconst [0] bool))
+(CondSelect x y bool) && flagArg(bool) != nil => (ISEL [2] x y bool)
+(CondSelect x y bool) && flagArg(bool) == nil => (ISEL [2] x y (CMPWconst [0] bool))
 
 // Lowering loads
-(Load <t> ptr mem) && (is64BitInt(t) || isPtr(t)) -> (MOVDload ptr mem)
-(Load <t> ptr mem) && is32BitInt(t) && isSigned(t) -> (MOVWload ptr mem)
-(Load <t> ptr mem) && is32BitInt(t) && !isSigned(t) -> (MOVWZload ptr mem)
-(Load <t> ptr mem) && is16BitInt(t) && isSigned(t) -> (MOVHload ptr mem)
-(Load <t> ptr mem) && is16BitInt(t) && !isSigned(t) -> (MOVHZload ptr mem)
-(Load <t> ptr mem) && t.IsBoolean() -> (MOVBZload ptr mem)
-(Load <t> ptr mem) && is8BitInt(t) && isSigned(t) -> (MOVBreg (MOVBZload ptr mem)) // PPC has no signed-byte load.
-(Load <t> ptr mem) && is8BitInt(t) && !isSigned(t) -> (MOVBZload ptr mem)
-
-(Load <t> ptr mem) && is32BitFloat(t) -> (FMOVSload ptr mem)
-(Load <t> ptr mem) && is64BitFloat(t) -> (FMOVDload ptr mem)
-
-(Store {t} ptr val mem) && t.(*types.Type).Size() == 8 && is64BitFloat(val.Type) -> (FMOVDstore ptr val mem)
-(Store {t} ptr val mem) && t.(*types.Type).Size() == 8 && is32BitFloat(val.Type) -> (FMOVDstore ptr val mem) // glitch from (Cvt32Fto64F x) -> x -- type is wrong
-(Store {t} ptr val mem) && t.(*types.Type).Size() == 4 && is32BitFloat(val.Type) -> (FMOVSstore ptr val mem)
-(Store {t} ptr val mem) && t.(*types.Type).Size() == 8 && (is64BitInt(val.Type) || isPtr(val.Type)) -> (MOVDstore ptr val mem)
-(Store {t} ptr val mem) && t.(*types.Type).Size() == 4 && is32BitInt(val.Type) -> (MOVWstore ptr val mem)
-(Store {t} ptr val mem) && t.(*types.Type).Size() == 2 -> (MOVHstore ptr val mem)
-(Store {t} ptr val mem) && t.(*types.Type).Size() == 1 -> (MOVBstore ptr val mem)
+(Load <t> ptr mem) && (is64BitInt(t) || isPtr(t)) => (MOVDload ptr mem)
+(Load <t> ptr mem) && is32BitInt(t) && isSigned(t) => (MOVWload ptr mem)
+(Load <t> ptr mem) && is32BitInt(t) && !isSigned(t) => (MOVWZload ptr mem)
+(Load <t> ptr mem) && is16BitInt(t) && isSigned(t) => (MOVHload ptr mem)
+(Load <t> ptr mem) && is16BitInt(t) && !isSigned(t) => (MOVHZload ptr mem)
+(Load <t> ptr mem) && t.IsBoolean() => (MOVBZload ptr mem)
+(Load <t> ptr mem) && is8BitInt(t) && isSigned(t) => (MOVBreg (MOVBZload ptr mem)) // PPC has no signed-byte load.
+(Load <t> ptr mem) && is8BitInt(t) && !isSigned(t) => (MOVBZload ptr mem)
+
+(Load <t> ptr mem) && is32BitFloat(t) => (FMOVSload ptr mem)
+(Load <t> ptr mem) && is64BitFloat(t) => (FMOVDload ptr mem)
+
+(Store {t} ptr val mem) && t.Size() == 8 && is64BitFloat(val.Type) => (FMOVDstore ptr val mem)
+(Store {t} ptr val mem) && t.Size() == 8 && is32BitFloat(val.Type) => (FMOVDstore ptr val mem) // glitch from (Cvt32Fto64F x) => x -- type is wrong
+(Store {t} ptr val mem) && t.Size() == 4 && is32BitFloat(val.Type) => (FMOVSstore ptr val mem)
+(Store {t} ptr val mem) && t.Size() == 8 && (is64BitInt(val.Type) || isPtr(val.Type)) => (MOVDstore ptr val mem)
+(Store {t} ptr val mem) && t.Size() == 4 && is32BitInt(val.Type) => (MOVWstore ptr val mem)
+(Store {t} ptr val mem) && t.Size() == 2 => (MOVHstore ptr val mem)
+(Store {t} ptr val mem) && t.Size() == 1 => (MOVBstore ptr val mem)
 
 // Using Zero instead of LoweredZero allows the
 // target address to be folded where possible.
-(Zero [0] _ mem) -> mem
-(Zero [1] destptr mem) -> (MOVBstorezero destptr mem)
-(Zero [2] destptr mem) ->
+(Zero [0] _ mem) => mem
+(Zero [1] destptr mem) => (MOVBstorezero destptr mem)
+(Zero [2] destptr mem) =>
 	(MOVHstorezero destptr mem)
-(Zero [3] destptr mem) ->
+(Zero [3] destptr mem) =>
 	(MOVBstorezero [2] destptr
 		(MOVHstorezero destptr mem))
-(Zero [4] destptr mem) ->
+(Zero [4] destptr mem) =>
 	(MOVWstorezero destptr mem)
-(Zero [5] destptr mem) ->
+(Zero [5] destptr mem) =>
 	(MOVBstorezero [4] destptr
         	(MOVWstorezero destptr mem))
-(Zero [6] destptr mem) ->
+(Zero [6] destptr mem) =>
 	(MOVHstorezero [4] destptr
 		(MOVWstorezero destptr mem))
-(Zero [7] destptr mem) ->
+(Zero [7] destptr mem) =>
 	(MOVBstorezero [6] destptr
 		(MOVHstorezero [4] destptr
 			(MOVWstorezero destptr mem)))
 
 // MOVD for store with DS must have offsets that are multiple of 4
-(Zero [8] {t} destptr mem) && t.(*types.Type).Alignment()%4 == 0 ->
+(Zero [8] {t} destptr mem) && t.Alignment()%4 == 0 =>
         (MOVDstorezero destptr mem)
-(Zero [8] destptr mem) ->
+(Zero [8] destptr mem) =>
         (MOVWstorezero [4] destptr
                 (MOVWstorezero [0] destptr mem))
 // Handle these cases only if aligned properly, otherwise use general case below
-(Zero [12] {t} destptr mem) && t.(*types.Type).Alignment()%4 == 0 ->
+(Zero [12] {t} destptr mem) && t.Alignment()%4 == 0 =>
         (MOVWstorezero [8] destptr
                 (MOVDstorezero [0] destptr mem))
-(Zero [16] {t} destptr mem) && t.(*types.Type).Alignment()%4 == 0 ->
+(Zero [16] {t} destptr mem) && t.Alignment()%4 == 0 =>
        (MOVDstorezero [8] destptr
                 (MOVDstorezero [0] destptr mem))
-(Zero [24] {t} destptr mem) && t.(*types.Type).Alignment()%4 == 0 ->
+(Zero [24] {t} destptr mem) && t.Alignment()%4 == 0 =>
        (MOVDstorezero [16] destptr
                (MOVDstorezero [8] destptr
                        (MOVDstorezero [0] destptr mem)))
-(Zero [32] {t} destptr mem) && t.(*types.Type).Alignment()%4 == 0 ->
+(Zero [32] {t} destptr mem) && t.Alignment()%4 == 0 =>
        (MOVDstorezero [24] destptr
                (MOVDstorezero [16] destptr
                        (MOVDstorezero [8] destptr
@@ -573,228 +573,228 @@
 // Handle cases not handled above
 // Lowered Short cases do not generate loops, and as a result don't clobber
 // the address registers or flags.
-(Zero [s] ptr mem) && objabi.GOPPC64 <= 8 && s < 64 -> (LoweredZeroShort [s] ptr mem)
-(Zero [s] ptr mem) && objabi.GOPPC64 <= 8 -> (LoweredZero [s] ptr mem)
-(Zero [s] ptr mem) && s < 128 && objabi.GOPPC64 >= 9 -> (LoweredQuadZeroShort [s] ptr mem)
-(Zero [s] ptr mem) && objabi.GOPPC64 >= 9 -> (LoweredQuadZero [s] ptr mem)
+(Zero [s] ptr mem) && objabi.GOPPC64 <= 8 && s < 64 => (LoweredZeroShort [s] ptr mem)
+(Zero [s] ptr mem) && objabi.GOPPC64 <= 8 => (LoweredZero [s] ptr mem)
+(Zero [s] ptr mem) && s < 128 && objabi.GOPPC64 >= 9 => (LoweredQuadZeroShort [s] ptr mem)
+(Zero [s] ptr mem) && objabi.GOPPC64 >= 9 => (LoweredQuadZero [s] ptr mem)
 
 // moves
 // Only the MOVD and MOVW instructions require 4 byte
 // alignment in the offset field.  The other MOVx instructions
 // allow any alignment.
-(Move [0] _ _ mem) -> mem
-(Move [1] dst src mem) -> (MOVBstore dst (MOVBZload src mem) mem)
-(Move [2] dst src mem) ->
+(Move [0] _ _ mem) => mem
+(Move [1] dst src mem) => (MOVBstore dst (MOVBZload src mem) mem)
+(Move [2] dst src mem) =>
         (MOVHstore dst (MOVHZload src mem) mem)
-(Move [4] dst src mem) ->
+(Move [4] dst src mem) =>
 	(MOVWstore dst (MOVWZload src mem) mem)
 // MOVD for load and store must have offsets that are multiple of 4
-(Move [8] {t} dst src mem) && t.(*types.Type).Alignment()%4 == 0 ->
+(Move [8] {t} dst src mem) && t.Alignment()%4 == 0 =>
 	(MOVDstore dst (MOVDload src mem) mem)
-(Move [8] dst src mem) ->
+(Move [8] dst src mem) =>
 	(MOVWstore [4] dst (MOVWZload [4] src mem)
 		(MOVWstore dst (MOVWZload src mem) mem))
-(Move [3] dst src mem) ->
+(Move [3] dst src mem) =>
         (MOVBstore [2] dst (MOVBZload [2] src mem)
                 (MOVHstore dst (MOVHload src mem) mem))
-(Move [5] dst src mem) ->
+(Move [5] dst src mem) =>
         (MOVBstore [4] dst (MOVBZload [4] src mem)
                 (MOVWstore dst (MOVWZload src mem) mem))
-(Move [6] dst src mem) ->
+(Move [6] dst src mem) =>
         (MOVHstore [4] dst (MOVHZload [4] src mem)
                 (MOVWstore dst (MOVWZload src mem) mem))
-(Move [7] dst src mem) ->
+(Move [7] dst src mem) =>
         (MOVBstore [6] dst (MOVBZload [6] src mem)
                 (MOVHstore [4] dst (MOVHZload [4] src mem)
                         (MOVWstore dst (MOVWZload src mem) mem)))
 
 // Large move uses a loop. Since the address is computed and the
 // offset is zero, any alignment can be used.
-(Move [s] dst src mem) && s > 8 && objabi.GOPPC64 <= 8 && logLargeCopy(v, s) ->
+(Move [s] dst src mem) && s > 8 && objabi.GOPPC64 <= 8 && logLargeCopy(v, s) =>
         (LoweredMove [s] dst src mem)
-(Move [s] dst src mem) && s > 8 && s <= 64 && objabi.GOPPC64 >= 9 ->
+(Move [s] dst src mem) && s > 8 && s <= 64 && objabi.GOPPC64 >= 9 =>
         (LoweredQuadMoveShort [s] dst src mem)
-(Move [s] dst src mem) && s > 8 && objabi.GOPPC64 >= 9 && logLargeCopy(v, s) ->
+(Move [s] dst src mem) && s > 8 && objabi.GOPPC64 >= 9 && logLargeCopy(v, s) =>
         (LoweredQuadMove [s] dst src mem)
 
 // Calls
 // Lowering calls
-(StaticCall ...) -> (CALLstatic ...)
-(ClosureCall ...) -> (CALLclosure ...)
-(InterCall ...) -> (CALLinter ...)
+(StaticCall ...) => (CALLstatic ...)
+(ClosureCall ...) => (CALLclosure ...)
+(InterCall ...) => (CALLinter ...)
 
 // Miscellaneous
-(GetClosurePtr ...) -> (LoweredGetClosurePtr ...)
-(GetCallerSP ...) -> (LoweredGetCallerSP ...)
-(GetCallerPC ...) -> (LoweredGetCallerPC ...)
-(IsNonNil ptr) -> (NotEqual (CMPconst [0] ptr))
-(IsInBounds idx len) -> (LessThan (CMPU idx len))
-(IsSliceInBounds idx len) -> (LessEqual (CMPU idx len))
-(NilCheck ...) -> (LoweredNilCheck ...)
+(GetClosurePtr ...) => (LoweredGetClosurePtr ...)
+(GetCallerSP ...) => (LoweredGetCallerSP ...)
+(GetCallerPC ...) => (LoweredGetCallerPC ...)
+(IsNonNil ptr) => (NotEqual (CMPconst [0] ptr))
+(IsInBounds idx len) => (LessThan (CMPU idx len))
+(IsSliceInBounds idx len) => (LessEqual (CMPU idx len))
+(NilCheck ...) => (LoweredNilCheck ...)
 
 // Write barrier.
-(WB ...) -> (LoweredWB ...)
+(WB ...) => (LoweredWB ...)
 
-(PanicBounds [kind] x y mem) && boundsABI(kind) == 0 -> (LoweredPanicBoundsA [kind] x y mem)
-(PanicBounds [kind] x y mem) && boundsABI(kind) == 1 -> (LoweredPanicBoundsB [kind] x y mem)
-(PanicBounds [kind] x y mem) && boundsABI(kind) == 2 -> (LoweredPanicBoundsC [kind] x y mem)
+(PanicBounds [kind] x y mem) && boundsABI(kind) == 0 => (LoweredPanicBoundsA [kind] x y mem)
+(PanicBounds [kind] x y mem) && boundsABI(kind) == 1 => (LoweredPanicBoundsB [kind] x y mem)
+(PanicBounds [kind] x y mem) && boundsABI(kind) == 2 => (LoweredPanicBoundsC [kind] x y mem)
 
 // Optimizations
 // Note that PPC "logical" immediates come in 0:15 and 16:31 unsigned immediate forms,
 // so ORconst, XORconst easily expand into a pair.
 
 // Include very-large constants in the const-const case.
-(AND (MOVDconst [c]) (MOVDconst [d])) -> (MOVDconst [c&d])
-(OR (MOVDconst [c]) (MOVDconst [d])) -> (MOVDconst [c|d])
-(XOR (MOVDconst [c]) (MOVDconst [d])) -> (MOVDconst [c^d])
-(ORN (MOVDconst [c]) (MOVDconst [d])) -> (MOVDconst [c|^d])
-(ANDN (MOVDconst [c]) (MOVDconst [d])) -> (MOVDconst [c&^d])
-(NOR (MOVDconst [c]) (MOVDconst [d])) -> (MOVDconst [^(c|d)])
+(AND (MOVDconst [c]) (MOVDconst [d])) => (MOVDconst [c&d])
+(OR (MOVDconst [c]) (MOVDconst [d])) => (MOVDconst [c|d])
+(XOR (MOVDconst [c]) (MOVDconst [d])) => (MOVDconst [c^d])
+(ORN (MOVDconst [c]) (MOVDconst [d])) => (MOVDconst [c|^d])
+(ANDN (MOVDconst [c]) (MOVDconst [d])) => (MOVDconst [c&^d])
+(NOR (MOVDconst [c]) (MOVDconst [d])) => (MOVDconst [^(c|d)])
 
 // Discover consts
-(AND x (MOVDconst [c])) && isU16Bit(c) -> (ANDconst [c] x)
-(XOR x (MOVDconst [c])) && isU32Bit(c) -> (XORconst [c] x)
-(OR x (MOVDconst [c])) && isU32Bit(c) -> (ORconst [c] x)
+(AND x (MOVDconst [c])) && isU16Bit(c) => (ANDconst [c] x)
+(XOR x (MOVDconst [c])) && isU32Bit(c) => (XORconst [c] x)
+(OR x (MOVDconst [c])) && isU32Bit(c) => (ORconst [c] x)
 
 // Simplify consts
-(ANDconst [c] (ANDconst [d] x)) -> (ANDconst [c&d] x)
-(ORconst [c] (ORconst [d] x)) -> (ORconst [c|d] x)
-(XORconst [c] (XORconst [d] x)) -> (XORconst [c^d] x)
-(ANDconst [-1] x) -> x
-(ANDconst [0] _) -> (MOVDconst [0])
-(XORconst [0] x) -> x
-(ORconst [-1] _) -> (MOVDconst [-1])
-(ORconst [0] x) -> x
-
-// zero-extend of small and -> small and
-(MOVBZreg y:(ANDconst [c] _)) && uint64(c) <= 0xFF -> y
-(MOVHZreg y:(ANDconst [c] _)) && uint64(c) <= 0xFFFF -> y
-(MOVWZreg y:(ANDconst [c] _)) && uint64(c) <= 0xFFFFFFFF -> y
-(MOVWZreg y:(AND (MOVDconst [c]) _)) && uint64(c) <= 0xFFFFFFFF -> y
-
-// sign extend of small-positive and -> small-positive-and
-(MOVBreg y:(ANDconst [c] _)) && uint64(c) <= 0x7F -> y
-(MOVHreg y:(ANDconst [c] _)) && uint64(c) <= 0x7FFF -> y
-(MOVWreg y:(ANDconst [c] _)) && uint64(c) <= 0xFFFF -> y // 0xFFFF is largest immediate constant, when regarded as 32-bit is > 0
-(MOVWreg y:(AND (MOVDconst [c]) _)) && uint64(c) <= 0x7FFFFFFF -> y
-
-// small and of zero-extend -> either zero-extend or small and
-(ANDconst [c] y:(MOVBZreg _)) && c&0xFF == 0xFF -> y
-(ANDconst [0xFF] y:(MOVBreg _)) -> y
-(ANDconst [c] y:(MOVHZreg _))  && c&0xFFFF == 0xFFFF -> y
-(ANDconst [0xFFFF] y:(MOVHreg _)) -> y
-
-(AND (MOVDconst [c]) y:(MOVWZreg _))  && c&0xFFFFFFFF == 0xFFFFFFFF -> y
-(AND (MOVDconst [0xFFFFFFFF]) y:(MOVWreg x)) -> (MOVWZreg x)
+(ANDconst [c] (ANDconst [d] x)) => (ANDconst [c&d] x)
+(ORconst [c] (ORconst [d] x)) => (ORconst [c|d] x)
+(XORconst [c] (XORconst [d] x)) => (XORconst [c^d] x)
+(ANDconst [-1] x) => x
+(ANDconst [0] _) => (MOVDconst [0])
+(XORconst [0] x) => x
+(ORconst [-1] _) => (MOVDconst [-1])
+(ORconst [0] x) => x
+
+// zero-extend of small and => small and
+(MOVBZreg y:(ANDconst [c] _)) && uint64(c) <= 0xFF => y
+(MOVHZreg y:(ANDconst [c] _)) && uint64(c) <= 0xFFFF => y
+(MOVWZreg y:(ANDconst [c] _)) && uint64(c) <= 0xFFFFFFFF => y
+(MOVWZreg y:(AND (MOVDconst [c]) _)) && uint64(c) <= 0xFFFFFFFF => y
+
+// sign extend of small-positive and => small-positive-and
+(MOVBreg y:(ANDconst [c] _)) && uint64(c) <= 0x7F => y
+(MOVHreg y:(ANDconst [c] _)) && uint64(c) <= 0x7FFF => y
+(MOVWreg y:(ANDconst [c] _)) && uint64(c) <= 0xFFFF => y // 0xFFFF is largest immediate constant, when regarded as 32-bit is > 0
+(MOVWreg y:(AND (MOVDconst [c]) _)) && uint64(c) <= 0x7FFFFFFF => y
+
+// small and of zero-extend => either zero-extend or small and
+(ANDconst [c] y:(MOVBZreg _)) && c&0xFF == 0xFF => y
+(ANDconst [0xFF] y:(MOVBreg _)) => y
+(ANDconst [c] y:(MOVHZreg _))  && c&0xFFFF == 0xFFFF => y
+(ANDconst [0xFFFF] y:(MOVHreg _)) => y
+
+(AND (MOVDconst [c]) y:(MOVWZreg _))  && c&0xFFFFFFFF == 0xFFFFFFFF => y
+(AND (MOVDconst [0xFFFFFFFF]) y:(MOVWreg x)) => (MOVWZreg x)
 // normal case
-(ANDconst [c] (MOV(B|BZ)reg x)) -> (ANDconst [c&0xFF] x)
-(ANDconst [c] (MOV(H|HZ)reg x)) -> (ANDconst [c&0xFFFF] x)
-(ANDconst [c] (MOV(W|WZ)reg x)) -> (ANDconst [c&0xFFFFFFFF] x)
+(ANDconst [c] (MOV(B|BZ)reg x)) => (ANDconst [c&0xFF] x)
+(ANDconst [c] (MOV(H|HZ)reg x)) => (ANDconst [c&0xFFFF] x)
+(ANDconst [c] (MOV(W|WZ)reg x)) => (ANDconst [c&0xFFFFFFFF] x)
 
 // Eliminate unnecessary sign/zero extend following right shift
-(MOV(B|H|W)Zreg (SRWconst [c] (MOVBZreg x))) -> (SRWconst [c] (MOVBZreg x))
-(MOV(H|W)Zreg (SRWconst [c] (MOVHZreg x))) -> (SRWconst [c] (MOVHZreg x))
-(MOVWZreg (SRWconst [c] (MOVWZreg x))) -> (SRWconst [c] (MOVWZreg x))
-(MOV(B|H|W)reg (SRAWconst [c] (MOVBreg x))) -> (SRAWconst [c] (MOVBreg x))
-(MOV(H|W)reg (SRAWconst [c] (MOVHreg x))) -> (SRAWconst [c] (MOVHreg x))
-(MOVWreg (SRAWconst [c] (MOVWreg x))) -> (SRAWconst [c] (MOVWreg x))
-
-(MOVWZreg (SRWconst [c] x)) && sizeof(x.Type) <= 32 -> (SRWconst [c] x)
-(MOVHZreg (SRWconst [c] x)) && sizeof(x.Type) <= 16 -> (SRWconst [c] x)
-(MOVBZreg (SRWconst [c] x)) && sizeof(x.Type) == 8 -> (SRWconst [c] x)
-(MOVWreg (SRAWconst [c] x)) && sizeof(x.Type) <= 32 -> (SRAWconst [c] x)
-(MOVHreg (SRAWconst [c] x)) && sizeof(x.Type) <= 16 -> (SRAWconst [c] x)
-(MOVBreg (SRAWconst [c] x)) && sizeof(x.Type) == 8 -> (SRAWconst [c] x)
+(MOV(B|H|W)Zreg (SRWconst [c] (MOVBZreg x))) => (SRWconst [c] (MOVBZreg x))
+(MOV(H|W)Zreg (SRWconst [c] (MOVHZreg x))) => (SRWconst [c] (MOVHZreg x))
+(MOVWZreg (SRWconst [c] (MOVWZreg x))) => (SRWconst [c] (MOVWZreg x))
+(MOV(B|H|W)reg (SRAWconst [c] (MOVBreg x))) => (SRAWconst [c] (MOVBreg x))
+(MOV(H|W)reg (SRAWconst [c] (MOVHreg x))) => (SRAWconst [c] (MOVHreg x))
+(MOVWreg (SRAWconst [c] (MOVWreg x))) => (SRAWconst [c] (MOVWreg x))
+
+(MOVWZreg (SRWconst [c] x)) && sizeof(x.Type) <= 32 => (SRWconst [c] x)
+(MOVHZreg (SRWconst [c] x)) && sizeof(x.Type) <= 16 => (SRWconst [c] x)
+(MOVBZreg (SRWconst [c] x)) && sizeof(x.Type) == 8 => (SRWconst [c] x)
+(MOVWreg (SRAWconst [c] x)) && sizeof(x.Type) <= 32 => (SRAWconst [c] x)
+(MOVHreg (SRAWconst [c] x)) && sizeof(x.Type) <= 16 => (SRAWconst [c] x)
+(MOVBreg (SRAWconst [c] x)) && sizeof(x.Type) == 8 => (SRAWconst [c] x)
 
 // initial right shift will handle sign/zero extend
-(MOVBZreg (SRDconst [c] x)) && c>=56 -> (SRDconst [c] x)
-(MOVBreg (SRDconst [c] x)) && c>56 -> (SRDconst [c] x)
-(MOVBreg (SRDconst [c] x)) && c==56 -> (SRADconst [c] x)
-(MOVBreg (SRADconst [c] x)) && c>=56 -> (SRADconst [c] x)
-(MOVBZreg (SRWconst [c] x)) && c>=24 -> (SRWconst [c] x)
-(MOVBreg (SRWconst [c] x)) && c>24 -> (SRWconst [c] x)
-(MOVBreg (SRWconst [c] x)) && c==24 -> (SRAWconst [c] x)
-(MOVBreg (SRAWconst [c] x)) && c>=24 -> (SRAWconst [c] x)
-
-(MOVHZreg (SRDconst [c] x)) && c>=48 -> (SRDconst [c] x)
-(MOVHreg (SRDconst [c] x)) && c>48 -> (SRDconst [c] x)
-(MOVHreg (SRDconst [c] x)) && c==48 -> (SRADconst [c] x)
-(MOVHreg (SRADconst [c] x)) && c>=48 -> (SRADconst [c] x)
-(MOVHZreg (SRWconst [c] x)) && c>=16 -> (SRWconst [c] x)
-(MOVHreg (SRWconst [c] x)) && c>16 -> (SRWconst [c] x)
-(MOVHreg (SRAWconst [c] x)) && c>=16 -> (SRAWconst [c] x)
-(MOVHreg (SRWconst [c] x)) && c==16 -> (SRAWconst [c] x)
-
-(MOVWZreg (SRDconst [c] x)) && c>=32 -> (SRDconst [c] x)
-(MOVWreg (SRDconst [c] x)) && c>32 -> (SRDconst [c] x)
-(MOVWreg (SRADconst [c] x)) && c>=32 -> (SRADconst [c] x)
-(MOVWreg (SRDconst [c] x)) && c==32 -> (SRADconst [c] x)
+(MOVBZreg (SRDconst [c] x)) && c>=56 => (SRDconst [c] x)
+(MOVBreg (SRDconst [c] x)) && c>56 => (SRDconst [c] x)
+(MOVBreg (SRDconst [c] x)) && c==56 => (SRADconst [c] x)
+(MOVBreg (SRADconst [c] x)) && c>=56 => (SRADconst [c] x)
+(MOVBZreg (SRWconst [c] x)) && c>=24 => (SRWconst [c] x)
+(MOVBreg (SRWconst [c] x)) && c>24 => (SRWconst [c] x)
+(MOVBreg (SRWconst [c] x)) && c==24 => (SRAWconst [c] x)
+(MOVBreg (SRAWconst [c] x)) && c>=24 => (SRAWconst [c] x)
+
+(MOVHZreg (SRDconst [c] x)) && c>=48 => (SRDconst [c] x)
+(MOVHreg (SRDconst [c] x)) && c>48 => (SRDconst [c] x)
+(MOVHreg (SRDconst [c] x)) && c==48 => (SRADconst [c] x)
+(MOVHreg (SRADconst [c] x)) && c>=48 => (SRADconst [c] x)
+(MOVHZreg (SRWconst [c] x)) && c>=16 => (SRWconst [c] x)
+(MOVHreg (SRWconst [c] x)) && c>16 => (SRWconst [c] x)
+(MOVHreg (SRAWconst [c] x)) && c>=16 => (SRAWconst [c] x)
+(MOVHreg (SRWconst [c] x)) && c==16 => (SRAWconst [c] x)
+
+(MOVWZreg (SRDconst [c] x)) && c>=32 => (SRDconst [c] x)
+(MOVWreg (SRDconst [c] x)) && c>32 => (SRDconst [c] x)
+(MOVWreg (SRADconst [c] x)) && c>=32 => (SRADconst [c] x)
+(MOVWreg (SRDconst [c] x)) && c==32 => (SRADconst [c] x)
 
 // Various redundant zero/sign extension combinations.
-(MOVBZreg y:(MOVBZreg _)) -> y  // repeat
-(MOVBreg y:(MOVBreg _)) -> y // repeat
-(MOVBreg (MOVBZreg x)) -> (MOVBreg x)
-(MOVBZreg (MOVBreg x)) -> (MOVBZreg x)
+(MOVBZreg y:(MOVBZreg _)) => y  // repeat
+(MOVBreg y:(MOVBreg _)) => y // repeat
+(MOVBreg (MOVBZreg x)) => (MOVBreg x)
+(MOVBZreg (MOVBreg x)) => (MOVBZreg x)
 
 // H - there are more combinations than these
 
-(MOVHZreg y:(MOVHZreg _)) -> y // repeat
-(MOVHZreg y:(MOVBZreg _)) -> y // wide of narrow
-(MOVHZreg y:(MOVHBRload _ _)) -> y
+(MOVHZreg y:(MOVHZreg _)) => y // repeat
+(MOVHZreg y:(MOVBZreg _)) => y // wide of narrow
+(MOVHZreg y:(MOVHBRload _ _)) => y
 
-(MOVHreg y:(MOVHreg _)) -> y // repeat
-(MOVHreg y:(MOVBreg _)) -> y // wide of narrow
+(MOVHreg y:(MOVHreg _)) => y // repeat
+(MOVHreg y:(MOVBreg _)) => y // wide of narrow
 
-(MOVHreg y:(MOVHZreg x)) -> (MOVHreg x)
-(MOVHZreg y:(MOVHreg x)) -> (MOVHZreg x)
+(MOVHreg y:(MOVHZreg x)) => (MOVHreg x)
+(MOVHZreg y:(MOVHreg x)) => (MOVHZreg x)
 
 // W - there are more combinations than these
 
-(MOVWZreg y:(MOVWZreg _)) -> y // repeat
-(MOVWZreg y:(MOVHZreg _)) -> y // wide of narrow
-(MOVWZreg y:(MOVBZreg _)) -> y // wide of narrow
-(MOVWZreg y:(MOVHBRload _ _)) -> y
-(MOVWZreg y:(MOVWBRload _ _)) -> y
+(MOVWZreg y:(MOVWZreg _)) => y // repeat
+(MOVWZreg y:(MOVHZreg _)) => y // wide of narrow
+(MOVWZreg y:(MOVBZreg _)) => y // wide of narrow
+(MOVWZreg y:(MOVHBRload _ _)) => y
+(MOVWZreg y:(MOVWBRload _ _)) => y
 
-(MOVWreg y:(MOVWreg _)) -> y // repeat
-(MOVWreg y:(MOVHreg _)) -> y // wide of narrow
-(MOVWreg y:(MOVBreg _)) -> y // wide of narrow
+(MOVWreg y:(MOVWreg _)) => y // repeat
+(MOVWreg y:(MOVHreg _)) => y // wide of narrow
+(MOVWreg y:(MOVBreg _)) => y // wide of narrow
 
-(MOVWreg y:(MOVWZreg x)) -> (MOVWreg x)
-(MOVWZreg y:(MOVWreg x)) -> (MOVWZreg x)
+(MOVWreg y:(MOVWZreg x)) => (MOVWreg x)
+(MOVWZreg y:(MOVWreg x)) => (MOVWZreg x)
 
 // Arithmetic constant ops
 
-(ADD x (MOVDconst [c])) && is32Bit(c) -> (ADDconst [c] x)
-(ADDconst [c] (ADDconst [d] x)) && is32Bit(c+d) -> (ADDconst [c+d] x)
-(ADDconst [0] x) -> x
-(SUB x (MOVDconst [c])) && is32Bit(-c) -> (ADDconst [-c] x)
+(ADD x (MOVDconst [c])) && is32Bit(c) => (ADDconst [c] x)
+(ADDconst [c] (ADDconst [d] x)) && is32Bit(c+d) => (ADDconst [c+d] x)
+(ADDconst [0] x) => x
+(SUB x (MOVDconst [c])) && is32Bit(-c) => (ADDconst [-c] x)
 // TODO deal with subtract-from-const
 
-(ADDconst [c] (MOVDaddr [d] {sym} x)) -> (MOVDaddr [c+d] {sym} x)
+(ADDconst [c] (MOVDaddr [d] {sym} x)) && is32Bit(c+int64(d)) => (MOVDaddr [int32(c+int64(d))] {sym} x)
 
-// Use register moves instead of stores and loads to move int<->float values
+// Use register moves instead of stores and loads to move int<=>float values
 // Common with math Float64bits, Float64frombits
-(MOVDload [off] {sym} ptr (FMOVDstore [off] {sym} ptr x _)) -> (MFVSRD x)
-(FMOVDload [off] {sym} ptr (MOVDstore [off] {sym} ptr x _)) -> (MTVSRD x)
+(MOVDload [off] {sym} ptr (FMOVDstore [off] {sym} ptr x _)) => (MFVSRD x)
+(FMOVDload [off] {sym} ptr (MOVDstore [off] {sym} ptr x _)) => (MTVSRD x)
 
-(FMOVDstore [off] {sym} ptr (MTVSRD x) mem) -> (MOVDstore [off] {sym} ptr x mem)
-(MOVDstore [off] {sym} ptr (MFVSRD x) mem) -> (FMOVDstore [off] {sym} ptr x mem)
+(FMOVDstore [off] {sym} ptr (MTVSRD x) mem) => (MOVDstore [off] {sym} ptr x mem)
+(MOVDstore [off] {sym} ptr (MFVSRD x) mem) => (FMOVDstore [off] {sym} ptr x mem)
 
-(MTVSRD (MOVDconst [c])) -> (FMOVDconst [c])
-(MFVSRD (FMOVDconst [c])) -> (MOVDconst [c])
+(MTVSRD (MOVDconst [c])) => (FMOVDconst [math.Float64frombits(uint64(c))])
+(MFVSRD (FMOVDconst [c])) => (MOVDconst [int64(math.Float64bits(c))])
 
-(MTVSRD x:(MOVDload [off] {sym} ptr mem)) && x.Uses == 1 && clobber(x) -> @x.Block (FMOVDload [off] {sym} ptr mem)
-(MFVSRD x:(FMOVDload [off] {sym} ptr mem)) && x.Uses == 1 && clobber(x) -> @x.Block (MOVDload [off] {sym} ptr mem)
+(MTVSRD x:(MOVDload [off] {sym} ptr mem)) && x.Uses == 1 && clobber(x) => @x.Block (FMOVDload [off] {sym} ptr mem)
+(MFVSRD x:(FMOVDload [off] {sym} ptr mem)) && x.Uses == 1 && clobber(x) => @x.Block (MOVDload [off] {sym} ptr mem)
 
 // Fold offsets for stores.
-(MOVDstore [off1] {sym} (ADDconst [off2] x) val mem) && is16Bit(off1+off2) && (off1+off2)%4 == 0 -> (MOVDstore [off1+off2] {sym} x val mem)
-(MOVWstore [off1] {sym} (ADDconst [off2] x) val mem) && is16Bit(off1+off2) -> (MOVWstore [off1+off2] {sym} x val mem)
-(MOVHstore [off1] {sym} (ADDconst [off2] x) val mem) && is16Bit(off1+off2) -> (MOVHstore [off1+off2] {sym} x val mem)
-(MOVBstore [off1] {sym} (ADDconst [off2] x) val mem) && is16Bit(off1+off2) -> (MOVBstore [off1+off2] {sym} x val mem)
+(MOVDstore [off1] {sym} (ADDconst [off2] x) val mem) && is16Bit(int64(off1)+off2) && (int64(off1)+off2)%4 == 0 => (MOVDstore [off1+int32(off2)] {sym} x val mem)
+(MOVWstore [off1] {sym} (ADDconst [off2] x) val mem) && is16Bit(int64(off1)+off2) => (MOVWstore [off1+int32(off2)] {sym} x val mem)
+(MOVHstore [off1] {sym} (ADDconst [off2] x) val mem) && is16Bit(int64(off1)+off2) => (MOVHstore [off1+int32(off2)] {sym} x val mem)
+(MOVBstore [off1] {sym} (ADDconst [off2] x) val mem) && is16Bit(int64(off1)+off2) => (MOVBstore [off1+int32(off2)] {sym} x val mem)
 
-(FMOVSstore [off1] {sym} (ADDconst [off2] ptr) val mem) && is16Bit(off1+off2) -> (FMOVSstore [off1+off2] {sym} ptr val mem)
-(FMOVDstore [off1] {sym} (ADDconst [off2] ptr) val mem) && is16Bit(off1+off2) -> (FMOVDstore [off1+off2] {sym} ptr val mem)
+(FMOVSstore [off1] {sym} (ADDconst [off2] ptr) val mem) && is16Bit(int64(off1)+off2) => (FMOVSstore [off1+int32(off2)] {sym} ptr val mem)
+(FMOVDstore [off1] {sym} (ADDconst [off2] ptr) val mem) && is16Bit(int64(off1)+off2) => (FMOVDstore [off1+int32(off2)] {sym} ptr val mem)
 
 // Fold address into load/store.
 // The assembler needs to generate several instructions and use
@@ -802,94 +802,94 @@
 // the temp register. So don't fold address of global, unless there
 // is only one use.
 (MOVBstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem) && canMergeSym(sym1,sym2)
-	&& (ptr.Op != OpSB || p.Uses == 1) ->
-        (MOVBstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
+	&& (ptr.Op != OpSB || p.Uses == 1) =>
+        (MOVBstore [off1+off2] {mergeSymTyped(sym1,sym2)} ptr val mem)
 (MOVHstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem) && canMergeSym(sym1,sym2)
-	&& (ptr.Op != OpSB || p.Uses == 1) ->
-        (MOVHstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
+	&& (ptr.Op != OpSB || p.Uses == 1) =>
+        (MOVHstore [off1+off2] {mergeSymTyped(sym1,sym2)} ptr val mem)
 (MOVWstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem) && canMergeSym(sym1,sym2)
-	&& (ptr.Op != OpSB || p.Uses == 1) ->
-        (MOVWstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
+	&& (ptr.Op != OpSB || p.Uses == 1) =>
+        (MOVWstore [off1+off2] {mergeSymTyped(sym1,sym2)} ptr val mem)
 (MOVDstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem) && canMergeSym(sym1,sym2)
-	&& (ptr.Op != OpSB || p.Uses == 1) && (off1+off2)%4 == 0 ->
-        (MOVDstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
+	&& (ptr.Op != OpSB || p.Uses == 1) && (off1+off2)%4 == 0 =>
+        (MOVDstore [off1+off2] {mergeSymTyped(sym1,sym2)} ptr val mem)
 
 (FMOVSstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem) && canMergeSym(sym1,sym2)
-	&& (ptr.Op != OpSB || p.Uses == 1) ->
-        (FMOVSstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
+	&& (ptr.Op != OpSB || p.Uses == 1) =>
+        (FMOVSstore [off1+off2] {mergeSymTyped(sym1,sym2)} ptr val mem)
 (FMOVDstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem) && canMergeSym(sym1,sym2)
-	&& (ptr.Op != OpSB || p.Uses == 1) ->
-        (FMOVDstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
+	&& (ptr.Op != OpSB || p.Uses == 1) =>
+        (FMOVDstore [off1+off2] {mergeSymTyped(sym1,sym2)} ptr val mem)
 
 (MOVBZload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2)
-	&& (ptr.Op != OpSB || p.Uses == 1) ->
-        (MOVBZload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
+	&& (ptr.Op != OpSB || p.Uses == 1) =>
+        (MOVBZload [off1+off2] {mergeSymTyped(sym1,sym2)} ptr mem)
 (MOVHload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2)
-	&& (ptr.Op != OpSB || p.Uses == 1) ->
-        (MOVHload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
+	&& (ptr.Op != OpSB || p.Uses == 1) =>
+        (MOVHload [off1+off2] {mergeSymTyped(sym1,sym2)} ptr mem)
 (MOVHZload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2)
-	&& (ptr.Op != OpSB || p.Uses == 1) ->
-        (MOVHZload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
+	&& (ptr.Op != OpSB || p.Uses == 1) =>
+        (MOVHZload [off1+off2] {mergeSymTyped(sym1,sym2)} ptr mem)
 (MOVWload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2)
-	&& (ptr.Op != OpSB || p.Uses == 1) && (off1+off2)%4 == 0 ->
-        (MOVWload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
+	&& (ptr.Op != OpSB || p.Uses == 1) && (off1+off2)%4 == 0 =>
+        (MOVWload [off1+off2] {mergeSymTyped(sym1,sym2)} ptr mem)
 (MOVWZload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2)
-	&& (ptr.Op != OpSB || p.Uses == 1) ->
-        (MOVWZload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
+	&& (ptr.Op != OpSB || p.Uses == 1) =>
+        (MOVWZload [off1+off2] {mergeSymTyped(sym1,sym2)} ptr mem)
 (MOVDload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2)
-	&& (ptr.Op != OpSB || p.Uses == 1) && (off1+off2)%4 == 0 ->
-        (MOVDload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
+	&& (ptr.Op != OpSB || p.Uses == 1) && (off1+off2)%4 == 0 =>
+        (MOVDload [off1+off2] {mergeSymTyped(sym1,sym2)} ptr mem)
 (FMOVSload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2)
-	&& (ptr.Op != OpSB || p.Uses == 1) ->
-        (FMOVSload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
+	&& (ptr.Op != OpSB || p.Uses == 1) =>
+        (FMOVSload [off1+off2] {mergeSymTyped(sym1,sym2)} ptr mem)
 (FMOVDload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2)
-	&& (ptr.Op != OpSB || p.Uses == 1) ->
-        (FMOVDload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
+	&& (ptr.Op != OpSB || p.Uses == 1) =>
+        (FMOVDload [off1+off2] {mergeSymTyped(sym1,sym2)} ptr mem)
 
 // Fold offsets for loads.
-(FMOVSload [off1] {sym} (ADDconst [off2] ptr) mem) && is16Bit(off1+off2) -> (FMOVSload [off1+off2] {sym} ptr mem)
-(FMOVDload [off1] {sym} (ADDconst [off2] ptr) mem) && is16Bit(off1+off2) -> (FMOVDload [off1+off2] {sym} ptr mem)
+(FMOVSload [off1] {sym} (ADDconst [off2] ptr) mem) && is16Bit(int64(off1)+off2) => (FMOVSload [off1+int32(off2)] {sym} ptr mem)
+(FMOVDload [off1] {sym} (ADDconst [off2] ptr) mem) && is16Bit(int64(off1)+off2) => (FMOVDload [off1+int32(off2)] {sym} ptr mem)
 
-(MOVDload [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(off1+off2) && (off1+off2)%4 == 0 -> (MOVDload [off1+off2] {sym} x mem)
-(MOVWload [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(off1+off2) && (off1+off2)%4 == 0 -> (MOVWload [off1+off2] {sym} x mem)
-(MOVWZload [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(off1+off2) -> (MOVWZload [off1+off2] {sym} x mem)
-(MOVHload [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(off1+off2) -> (MOVHload [off1+off2] {sym} x mem)
-(MOVHZload [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(off1+off2) -> (MOVHZload [off1+off2] {sym} x mem)
-(MOVBZload [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(off1+off2) -> (MOVBZload [off1+off2] {sym} x mem)
+(MOVDload [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(int64(off1)+off2) && (int64(off1)+off2)%4 == 0 => (MOVDload [off1+int32(off2)] {sym} x mem)
+(MOVWload [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(int64(off1)+off2) && (int64(off1)+off2)%4 == 0 => (MOVWload [off1+int32(off2)] {sym} x mem)
+(MOVWZload [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(int64(off1)+off2) => (MOVWZload [off1+int32(off2)] {sym} x mem)
+(MOVHload [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(int64(off1)+off2) => (MOVHload [off1+int32(off2)] {sym} x mem)
+(MOVHZload [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(int64(off1)+off2) => (MOVHZload [off1+int32(off2)] {sym} x mem)
+(MOVBZload [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(int64(off1)+off2) => (MOVBZload [off1+int32(off2)] {sym} x mem)
 
 // Determine load + addressing that can be done as a register indexed load
-(MOV(D|W|WZ|H|HZ|BZ)load [0] {sym} p:(ADD ptr idx) mem) && sym == nil && p.Uses == 1 -> (MOV(D|W|WZ|H|HZ|BZ)loadidx ptr idx mem)
+(MOV(D|W|WZ|H|HZ|BZ)load [0] {sym} p:(ADD ptr idx) mem) && sym == nil && p.Uses == 1 => (MOV(D|W|WZ|H|HZ|BZ)loadidx ptr idx mem)
 
 // Determine indexed loads with constant values that can be done without index
-(MOV(D|W)loadidx ptr (MOVDconst [c]) mem) && is16Bit(c) && c%4 == 0 -> (MOV(D|W)load [c] ptr mem)
-(MOV(WZ|H|HZ|BZ)loadidx ptr (MOVDconst [c]) mem) && is16Bit(c) -> (MOV(WZ|H|HZ|BZ)load [c] ptr mem)
-(MOV(D|W)loadidx (MOVDconst [c]) ptr mem) && is16Bit(c) && c%4 == 0 -> (MOV(D|W)load [c] ptr mem)
-(MOV(WZ|H|HZ|BZ)loadidx (MOVDconst [c]) ptr mem) && is16Bit(c) -> (MOV(WZ|H|HZ|BZ)load [c] ptr mem)
+(MOV(D|W)loadidx ptr (MOVDconst [c]) mem) && is16Bit(c) && c%4 == 0 => (MOV(D|W)load [int32(c)] ptr mem)
+(MOV(WZ|H|HZ|BZ)loadidx ptr (MOVDconst [c]) mem) && is16Bit(c) => (MOV(WZ|H|HZ|BZ)load [int32(c)] ptr mem)
+(MOV(D|W)loadidx (MOVDconst [c]) ptr mem) && is16Bit(c) && c%4 == 0 => (MOV(D|W)load [int32(c)] ptr mem)
+(MOV(WZ|H|HZ|BZ)loadidx (MOVDconst [c]) ptr mem) && is16Bit(c) => (MOV(WZ|H|HZ|BZ)load [int32(c)] ptr mem)
 
-// Store of zero -> storezero
-(MOVDstore [off] {sym} ptr (MOVDconst [0]) mem) -> (MOVDstorezero [off] {sym} ptr mem)
-(MOVWstore [off] {sym} ptr (MOVDconst [0]) mem) -> (MOVWstorezero [off] {sym} ptr mem)
-(MOVHstore [off] {sym} ptr (MOVDconst [0]) mem) -> (MOVHstorezero [off] {sym} ptr mem)
-(MOVBstore [off] {sym} ptr (MOVDconst [0]) mem) -> (MOVBstorezero [off] {sym} ptr mem)
+// Store of zero => storezero
+(MOVDstore [off] {sym} ptr (MOVDconst [0]) mem) => (MOVDstorezero [off] {sym} ptr mem)
+(MOVWstore [off] {sym} ptr (MOVDconst [0]) mem) => (MOVWstorezero [off] {sym} ptr mem)
+(MOVHstore [off] {sym} ptr (MOVDconst [0]) mem) => (MOVHstorezero [off] {sym} ptr mem)
+(MOVBstore [off] {sym} ptr (MOVDconst [0]) mem) => (MOVBstorezero [off] {sym} ptr mem)
 
 // Fold offsets for storezero
-(MOVDstorezero [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(off1+off2) && (off1+off2)%4 == 0 ->
-    (MOVDstorezero [off1+off2] {sym} x mem)
-(MOVWstorezero [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(off1+off2) ->
-    (MOVWstorezero [off1+off2] {sym} x mem)
-(MOVHstorezero [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(off1+off2) ->
-    (MOVHstorezero [off1+off2] {sym} x mem)
-(MOVBstorezero [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(off1+off2) ->
-    (MOVBstorezero [off1+off2] {sym} x mem)
+(MOVDstorezero [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(int64(off1)+off2) && (int64(off1)+off2)%4 == 0 =>
+    (MOVDstorezero [off1+int32(off2)] {sym} x mem)
+(MOVWstorezero [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(int64(off1)+off2) =>
+    (MOVWstorezero [off1+int32(off2)] {sym} x mem)
+(MOVHstorezero [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(int64(off1)+off2) =>
+    (MOVHstorezero [off1+int32(off2)] {sym} x mem)
+(MOVBstorezero [off1] {sym} (ADDconst [off2] x) mem) && is16Bit(int64(off1)+off2) =>
+    (MOVBstorezero [off1+int32(off2)] {sym} x mem)
 
 // Stores with addressing that can be done as indexed stores
-(MOV(D|W|H|B)store [0] {sym} p:(ADD ptr idx) val mem) && sym == nil && p.Uses == 1 -> (MOV(D|W|H|B)storeidx ptr idx val mem)
+(MOV(D|W|H|B)store [0] {sym} p:(ADD ptr idx) val mem) && sym == nil && p.Uses == 1 => (MOV(D|W|H|B)storeidx ptr idx val mem)
 
 // Stores with constant index values can be done without indexed instructions
-(MOVDstoreidx ptr (MOVDconst [c]) val mem) && is16Bit(c) && c%4 == 0 -> (MOVDstore [c] ptr val mem)
-(MOV(W|H|B)storeidx ptr (MOVDconst [c]) val mem) && is16Bit(c) -> (MOV(W|H|B)store [c] ptr val mem)
-(MOVDstoreidx (MOVDconst [c]) ptr val mem) && is16Bit(c) && c%4 == 0 -> (MOVDstore [c] ptr val mem)
-(MOV(W|H|B)storeidx (MOVDconst [c]) ptr val mem) && is16Bit(c) -> (MOV(W|H|B)store [c] ptr val mem)
+(MOVDstoreidx ptr (MOVDconst [c]) val mem) && is16Bit(c) && c%4 == 0 => (MOVDstore [int32(c)] ptr val mem)
+(MOV(W|H|B)storeidx ptr (MOVDconst [c]) val mem) && is16Bit(c) => (MOV(W|H|B)store [int32(c)] ptr val mem)
+(MOVDstoreidx (MOVDconst [c]) ptr val mem) && is16Bit(c) && c%4 == 0 => (MOVDstore [int32(c)] ptr val mem)
+(MOV(W|H|B)storeidx (MOVDconst [c]) ptr val mem) && is16Bit(c) => (MOV(W|H|B)store [int32(c)] ptr val mem)
 
 // Fold symbols into storezero
 (MOVDstorezero [off1] {sym1} p:(MOVDaddr [off2] {sym2} x) mem) && canMergeSym(sym1,sym2)
@@ -906,169 +906,169 @@
     (MOVBstorezero [off1+off2] {mergeSym(sym1,sym2)} x mem)
 
 // atomic intrinsics
-(AtomicLoad(8|32|64|Ptr)  ptr mem) -> (LoweredAtomicLoad(8|32|64|Ptr) [1] ptr mem)
-(AtomicLoadAcq32        ptr mem) -> (LoweredAtomicLoad32 [0] ptr mem)
+(AtomicLoad(8|32|64|Ptr)  ptr mem) => (LoweredAtomicLoad(8|32|64|Ptr) [1] ptr mem)
+(AtomicLoadAcq32        ptr mem) => (LoweredAtomicLoad32 [0] ptr mem)
 
-(AtomicStore(8|32|64)    ptr val mem) -> (LoweredAtomicStore(8|32|64) [1] ptr val mem)
-(AtomicStoreRel32        ptr val mem) -> (LoweredAtomicStore32 [0] ptr val mem)
-//(AtomicStorePtrNoWB ptr val mem) -> (STLR  ptr val mem)
+(AtomicStore(8|32|64)    ptr val mem) => (LoweredAtomicStore(8|32|64) [1] ptr val mem)
+(AtomicStoreRel32        ptr val mem) => (LoweredAtomicStore32 [0] ptr val mem)
+//(AtomicStorePtrNoWB ptr val mem) => (STLR  ptr val mem)
 
-(AtomicExchange(32|64) ...) -> (LoweredAtomicExchange(32|64) ...)
+(AtomicExchange(32|64) ...) => (LoweredAtomicExchange(32|64) ...)
 
-(AtomicAdd(32|64) ...) -> (LoweredAtomicAdd(32|64) ...)
+(AtomicAdd(32|64) ...) => (LoweredAtomicAdd(32|64) ...)
 
-(AtomicCompareAndSwap(32|64) ptr old new_ mem) -> (LoweredAtomicCas(32|64) [1] ptr old new_ mem)
-(AtomicCompareAndSwapRel32   ptr old new_ mem) -> (LoweredAtomicCas32 [0] ptr old new_ mem)
+(AtomicCompareAndSwap(32|64) ptr old new_ mem) => (LoweredAtomicCas(32|64) [1] ptr old new_ mem)
+(AtomicCompareAndSwapRel32   ptr old new_ mem) => (LoweredAtomicCas32 [0] ptr old new_ mem)
 
-(AtomicAnd8 ...) -> (LoweredAtomicAnd8 ...)
-(AtomicOr8  ...) -> (LoweredAtomicOr8  ...)
+(AtomicAnd8 ...) => (LoweredAtomicAnd8 ...)
+(AtomicOr8  ...) => (LoweredAtomicOr8  ...)
 
 // Lowering extension
 // Note: we always extend to 64 bits even though some ops don't need that many result bits.
-(SignExt8to(16|32|64) ...) -> (MOVBreg ...)
-(SignExt16to(32|64) ...) -> (MOVHreg ...)
-(SignExt32to64 ...) -> (MOVWreg ...)
+(SignExt8to(16|32|64) ...) => (MOVBreg ...)
+(SignExt16to(32|64) ...) => (MOVHreg ...)
+(SignExt32to64 ...) => (MOVWreg ...)
 
-(ZeroExt8to(16|32|64) ...) -> (MOVBZreg ...)
-(ZeroExt16to(32|64) ...) -> (MOVHZreg ...)
-(ZeroExt32to64 ...) -> (MOVWZreg ...)
+(ZeroExt8to(16|32|64) ...) => (MOVBZreg ...)
+(ZeroExt16to(32|64) ...) => (MOVHZreg ...)
+(ZeroExt32to64 ...) => (MOVWZreg ...)
 
-(Trunc(16|32|64)to8 <t> x) && isSigned(t) -> (MOVBreg x)
-(Trunc(16|32|64)to8  x) -> (MOVBZreg x)
-(Trunc(32|64)to16 <t> x) && isSigned(t) -> (MOVHreg x)
-(Trunc(32|64)to16 x) -> (MOVHZreg x)
-(Trunc64to32 <t> x) && isSigned(t) -> (MOVWreg x)
-(Trunc64to32 x) -> (MOVWZreg x)
+(Trunc(16|32|64)to8 <t> x) && isSigned(t) => (MOVBreg x)
+(Trunc(16|32|64)to8  x) => (MOVBZreg x)
+(Trunc(32|64)to16 <t> x) && isSigned(t) => (MOVHreg x)
+(Trunc(32|64)to16 x) => (MOVHZreg x)
+(Trunc64to32 <t> x) && isSigned(t) => (MOVWreg x)
+(Trunc64to32 x) => (MOVWZreg x)
 
-(Slicemask <t> x) -> (SRADconst (NEG <t> x) [63])
+(Slicemask <t> x) => (SRADconst (NEG <t> x) [63])
 
 // Note that MOV??reg returns a 64-bit int, x is not necessarily that wide
 // This may interact with other patterns in the future. (Compare with arm64)
-(MOV(B|H|W)Zreg x:(MOVBZload _ _)) -> x
-(MOV(B|H|W)Zreg x:(MOVBZloadidx _ _ _)) -> x
-(MOV(H|W)Zreg x:(MOVHZload _ _)) -> x
-(MOV(H|W)Zreg x:(MOVHZloadidx _ _ _)) -> x
-(MOV(H|W)reg x:(MOVHload _ _)) -> x
-(MOV(H|W)reg x:(MOVHloadidx _ _ _)) -> x
-(MOVWZreg x:(MOVWZload _ _)) -> x
-(MOVWZreg x:(MOVWZloadidx _ _ _)) -> x
-(MOVWreg x:(MOVWload _ _)) -> x
-(MOVWreg x:(MOVWloadidx _ _ _)) -> x
+(MOV(B|H|W)Zreg x:(MOVBZload _ _)) => x
+(MOV(B|H|W)Zreg x:(MOVBZloadidx _ _ _)) => x
+(MOV(H|W)Zreg x:(MOVHZload _ _)) => x
+(MOV(H|W)Zreg x:(MOVHZloadidx _ _ _)) => x
+(MOV(H|W)reg x:(MOVHload _ _)) => x
+(MOV(H|W)reg x:(MOVHloadidx _ _ _)) => x
+(MOVWZreg x:(MOVWZload _ _)) => x
+(MOVWZreg x:(MOVWZloadidx _ _ _)) => x
+(MOVWreg x:(MOVWload _ _)) => x
+(MOVWreg x:(MOVWloadidx _ _ _)) => x
 
 // don't extend if argument is already extended
-(MOVBreg x:(Arg <t>)) && is8BitInt(t) && isSigned(t) -> x
-(MOVBZreg x:(Arg <t>)) && is8BitInt(t) && !isSigned(t) -> x
-(MOVHreg x:(Arg <t>)) && (is8BitInt(t) || is16BitInt(t)) && isSigned(t) -> x
-(MOVHZreg x:(Arg <t>)) && (is8BitInt(t) || is16BitInt(t)) && !isSigned(t) -> x
-(MOVWreg x:(Arg <t>)) && (is8BitInt(t) || is16BitInt(t) || is32BitInt(t)) && isSigned(t) -> x
-(MOVWZreg x:(Arg <t>)) && (is8BitInt(t) || is16BitInt(t) || is32BitInt(t)) && !isSigned(t) -> x
+(MOVBreg x:(Arg <t>)) && is8BitInt(t) && isSigned(t) => x
+(MOVBZreg x:(Arg <t>)) && is8BitInt(t) && !isSigned(t) => x
+(MOVHreg x:(Arg <t>)) && (is8BitInt(t) || is16BitInt(t)) && isSigned(t) => x
+(MOVHZreg x:(Arg <t>)) && (is8BitInt(t) || is16BitInt(t)) && !isSigned(t) => x
+(MOVWreg x:(Arg <t>)) && (is8BitInt(t) || is16BitInt(t) || is32BitInt(t)) && isSigned(t) => x
+(MOVWZreg x:(Arg <t>)) && (is8BitInt(t) || is16BitInt(t) || is32BitInt(t)) && !isSigned(t) => x
 
-(MOVBZreg (MOVDconst [c]))  -> (MOVDconst [int64(uint8(c))])
-(MOVBreg (MOVDconst [c]))  -> (MOVDconst [int64(int8(c))])
-(MOVHZreg (MOVDconst [c]))  -> (MOVDconst [int64(uint16(c))])
-(MOVHreg (MOVDconst [c]))  -> (MOVDconst [int64(int16(c))])
-(MOVWreg (MOVDconst [c])) -> (MOVDconst [int64(int32(c))])
-(MOVWZreg (MOVDconst [c])) -> (MOVDconst [int64(uint32(c))])
+(MOVBZreg (MOVDconst [c]))  => (MOVDconst [int64(uint8(c))])
+(MOVBreg (MOVDconst [c]))  => (MOVDconst [int64(int8(c))])
+(MOVHZreg (MOVDconst [c]))  => (MOVDconst [int64(uint16(c))])
+(MOVHreg (MOVDconst [c]))  => (MOVDconst [int64(int16(c))])
+(MOVWreg (MOVDconst [c])) => (MOVDconst [int64(int32(c))])
+(MOVWZreg (MOVDconst [c])) => (MOVDconst [int64(uint32(c))])
 
 
 // Lose widening ops fed to stores
-(MOVBstore [off] {sym} ptr (MOV(B|BZ|H|HZ|W|WZ)reg x) mem) -> (MOVBstore [off] {sym} ptr x mem)
-(MOVHstore [off] {sym} ptr (MOV(H|HZ|W|WZ)reg x) mem) -> (MOVHstore [off] {sym} ptr x mem)
-(MOVWstore [off] {sym} ptr (MOV(W|WZ)reg x) mem) -> (MOVWstore [off] {sym} ptr x mem)
-(MOVBstore [off] {sym} ptr (SRWconst (MOV(H|HZ)reg x) [c]) mem) && c <= 8 -> (MOVBstore [off] {sym} ptr (SRWconst <typ.UInt32> x [c]) mem)
-(MOVBstore [off] {sym} ptr (SRWconst (MOV(W|WZ)reg x) [c]) mem) && c <= 24 -> (MOVBstore [off] {sym} ptr (SRWconst <typ.UInt32> x [c]) mem)
-(MOVBstoreidx ptr idx (MOV(B|BZ|H|HZ|W|WZ)reg x) mem) -> (MOVBstoreidx ptr idx x mem)
-(MOVHstoreidx ptr idx (MOV(H|HZ|W|WZ)reg x) mem) -> (MOVHstoreidx ptr idx x mem)
-(MOVWstoreidx ptr idx (MOV(W|WZ)reg x) mem) -> (MOVWstoreidx ptr idx x mem)
-(MOVBstoreidx ptr idx (SRWconst (MOV(H|HZ)reg x) [c]) mem) && c <= 8 -> (MOVBstoreidx ptr idx (SRWconst <typ.UInt32> x [c]) mem)
-(MOVBstoreidx ptr idx (SRWconst (MOV(W|WZ)reg x) [c]) mem) && c <= 24 -> (MOVBstoreidx ptr idx (SRWconst <typ.UInt32> x [c]) mem)
-(MOVHBRstore {sym} ptr (MOV(H|HZ|W|WZ)reg x) mem) -> (MOVHBRstore {sym} ptr x mem)
-(MOVWBRstore {sym} ptr (MOV(W|WZ)reg x) mem) -> (MOVWBRstore {sym} ptr x mem)
+(MOVBstore [off] {sym} ptr (MOV(B|BZ|H|HZ|W|WZ)reg x) mem) => (MOVBstore [off] {sym} ptr x mem)
+(MOVHstore [off] {sym} ptr (MOV(H|HZ|W|WZ)reg x) mem) => (MOVHstore [off] {sym} ptr x mem)
+(MOVWstore [off] {sym} ptr (MOV(W|WZ)reg x) mem) => (MOVWstore [off] {sym} ptr x mem)
+(MOVBstore [off] {sym} ptr (SRWconst (MOV(H|HZ)reg x) [c]) mem) && c <= 8 => (MOVBstore [off] {sym} ptr (SRWconst <typ.UInt32> x [c]) mem)
+(MOVBstore [off] {sym} ptr (SRWconst (MOV(W|WZ)reg x) [c]) mem) && c <= 24 => (MOVBstore [off] {sym} ptr (SRWconst <typ.UInt32> x [c]) mem)
+(MOVBstoreidx ptr idx (MOV(B|BZ|H|HZ|W|WZ)reg x) mem) => (MOVBstoreidx ptr idx x mem)
+(MOVHstoreidx ptr idx (MOV(H|HZ|W|WZ)reg x) mem) => (MOVHstoreidx ptr idx x mem)
+(MOVWstoreidx ptr idx (MOV(W|WZ)reg x) mem) => (MOVWstoreidx ptr idx x mem)
+(MOVBstoreidx ptr idx (SRWconst (MOV(H|HZ)reg x) [c]) mem) && c <= 8 => (MOVBstoreidx ptr idx (SRWconst <typ.UInt32> x [c]) mem)
+(MOVBstoreidx ptr idx (SRWconst (MOV(W|WZ)reg x) [c]) mem) && c <= 24 => (MOVBstoreidx ptr idx (SRWconst <typ.UInt32> x [c]) mem)
+(MOVHBRstore {sym} ptr (MOV(H|HZ|W|WZ)reg x) mem) => (MOVHBRstore {sym} ptr x mem)
+(MOVWBRstore {sym} ptr (MOV(W|WZ)reg x) mem) => (MOVWBRstore {sym} ptr x mem)
 
 // Lose W-widening ops fed to compare-W
-(CMPW x (MOVWreg y)) -> (CMPW x y)
-(CMPW (MOVWreg x) y) -> (CMPW x y)
-(CMPWU x (MOVWZreg y)) -> (CMPWU x y)
-(CMPWU (MOVWZreg x) y) -> (CMPWU x y)
+(CMPW x (MOVWreg y)) => (CMPW x y)
+(CMPW (MOVWreg x) y) => (CMPW x y)
+(CMPWU x (MOVWZreg y)) => (CMPWU x y)
+(CMPWU (MOVWZreg x) y) => (CMPWU x y)
 
-(CMP x (MOVDconst [c])) && is16Bit(c) -> (CMPconst x [c])
-(CMP (MOVDconst [c]) y) && is16Bit(c) -> (InvertFlags (CMPconst y [c]))
-(CMPW x (MOVDconst [c])) && is16Bit(c) -> (CMPWconst x [c])
-(CMPW (MOVDconst [c]) y) && is16Bit(c) -> (InvertFlags (CMPWconst y [c]))
+(CMP x (MOVDconst [c])) && is16Bit(c) => (CMPconst x [c])
+(CMP (MOVDconst [c]) y) && is16Bit(c) => (InvertFlags (CMPconst y [c]))
+(CMPW x (MOVDconst [c])) && is16Bit(c) => (CMPWconst x [int32(c)])
+(CMPW (MOVDconst [c]) y) && is16Bit(c) => (InvertFlags (CMPWconst y [int32(c)]))
 
-(CMPU x (MOVDconst [c])) && isU16Bit(c) -> (CMPUconst x [c])
-(CMPU (MOVDconst [c]) y) && isU16Bit(c) -> (InvertFlags (CMPUconst y [c]))
-(CMPWU x (MOVDconst [c])) && isU16Bit(c) -> (CMPWUconst x [c])
-(CMPWU (MOVDconst [c]) y) && isU16Bit(c) -> (InvertFlags (CMPWUconst y [c]))
+(CMPU x (MOVDconst [c])) && isU16Bit(c) => (CMPUconst x [c])
+(CMPU (MOVDconst [c]) y) && isU16Bit(c) => (InvertFlags (CMPUconst y [c]))
+(CMPWU x (MOVDconst [c])) && isU16Bit(c) => (CMPWUconst x [int32(c)])
+(CMPWU (MOVDconst [c]) y) && isU16Bit(c) => (InvertFlags (CMPWUconst y [int32(c)]))
 
 // Canonicalize the order of arguments to comparisons - helps with CSE.
-((CMP|CMPW|CMPU|CMPWU) x y) && x.ID > y.ID -> (InvertFlags ((CMP|CMPW|CMPU|CMPWU) y x))
+((CMP|CMPW|CMPU|CMPWU) x y) && x.ID > y.ID => (InvertFlags ((CMP|CMPW|CMPU|CMPWU) y x))
 
 // ISEL auxInt values 0=LT 1=GT 2=EQ   arg2 ? arg0 : arg1
 // ISEL auxInt values 4=GE 5=LE 6=NE   arg2 ? arg1 : arg0
 // ISELB special case where arg0, arg1 values are 0, 1
 
-(Equal cmp) -> (ISELB [2] (MOVDconst [1]) cmp)
-(NotEqual cmp) -> (ISELB [6] (MOVDconst [1]) cmp)
-(LessThan cmp) -> (ISELB [0] (MOVDconst [1]) cmp)
-(FLessThan cmp) -> (ISELB [0] (MOVDconst [1]) cmp)
-(FLessEqual cmp) -> (ISEL [2] (MOVDconst [1]) (ISELB [0] (MOVDconst [1]) cmp) cmp)
-(GreaterEqual cmp) -> (ISELB [4] (MOVDconst [1]) cmp)
-(GreaterThan cmp) -> (ISELB [1] (MOVDconst [1]) cmp)
-(FGreaterThan cmp) -> (ISELB [1] (MOVDconst [1]) cmp)
-(FGreaterEqual cmp) -> (ISEL [2] (MOVDconst [1]) (ISELB [1] (MOVDconst [1]) cmp) cmp)
-(LessEqual cmp) -> (ISELB [5] (MOVDconst [1]) cmp)
-
-(ISELB [0] _ (FlagLT)) -> (MOVDconst [1])
-(ISELB [0] _ (Flag(GT|EQ))) -> (MOVDconst [0])
-(ISELB [1] _ (FlagGT)) -> (MOVDconst [1])
-(ISELB [1] _ (Flag(LT|EQ))) -> (MOVDconst [0])
-(ISELB [2] _ (FlagEQ)) -> (MOVDconst [1])
-(ISELB [2] _ (Flag(LT|GT))) -> (MOVDconst [0])
-(ISELB [4] _ (FlagLT)) -> (MOVDconst [0])
-(ISELB [4] _ (Flag(GT|EQ))) -> (MOVDconst [1])
-(ISELB [5] _ (FlagGT)) -> (MOVDconst [0])
-(ISELB [5] _ (Flag(LT|EQ))) -> (MOVDconst [1])
-(ISELB [6] _ (FlagEQ)) -> (MOVDconst [0])
-(ISELB [6] _ (Flag(LT|GT))) -> (MOVDconst [1])
-
-(ISEL [2] x _ (FlagEQ)) -> x
-(ISEL [2] _ y (Flag(LT|GT))) -> y
-
-(ISEL [6] _ y (FlagEQ)) -> y
-(ISEL [6] x _ (Flag(LT|GT))) -> x
-
-(ISEL [0] _ y (Flag(EQ|GT))) -> y
-(ISEL [0] x _ (FlagLT)) -> x
-
-(ISEL [5] _ x (Flag(EQ|LT))) -> x
-(ISEL [5] y _ (FlagGT)) -> y
-
-(ISEL [1] _ y (Flag(EQ|LT))) -> y
-(ISEL [1] x _ (FlagGT)) -> x
-
-(ISEL [4] x _ (Flag(EQ|GT))) -> x
-(ISEL [4] _ y (FlagLT)) -> y
-
-(ISELB [n] (MOVDconst [1]) (InvertFlags bool)) && n%4 == 0 -> (ISELB [n+1] (MOVDconst [1]) bool)
-(ISELB [n] (MOVDconst [1]) (InvertFlags bool)) && n%4 == 1 -> (ISELB [n-1] (MOVDconst [1]) bool)
-(ISELB [n] (MOVDconst [1]) (InvertFlags bool)) && n%4 == 2 -> (ISELB [n] (MOVDconst [1]) bool)
-(ISEL [n] x y (InvertFlags bool)) && n%4 == 0 -> (ISEL [n+1] x y bool)
-(ISEL [n] x y (InvertFlags bool)) && n%4 == 1 -> (ISEL [n-1] x y bool)
-(ISEL [n] x y (InvertFlags bool)) && n%4 == 2 -> (ISEL [n] x y bool)
+(Equal cmp) => (ISELB [2] (MOVDconst [1]) cmp)
+(NotEqual cmp) => (ISELB [6] (MOVDconst [1]) cmp)
+(LessThan cmp) => (ISELB [0] (MOVDconst [1]) cmp)
+(FLessThan cmp) => (ISELB [0] (MOVDconst [1]) cmp)
+(FLessEqual cmp) => (ISEL [2] (MOVDconst [1]) (ISELB [0] (MOVDconst [1]) cmp) cmp)
+(GreaterEqual cmp) => (ISELB [4] (MOVDconst [1]) cmp)
+(GreaterThan cmp) => (ISELB [1] (MOVDconst [1]) cmp)
+(FGreaterThan cmp) => (ISELB [1] (MOVDconst [1]) cmp)
+(FGreaterEqual cmp) => (ISEL [2] (MOVDconst [1]) (ISELB [1] (MOVDconst [1]) cmp) cmp)
+(LessEqual cmp) => (ISELB [5] (MOVDconst [1]) cmp)
+
+(ISELB [0] _ (FlagLT)) => (MOVDconst [1])
+(ISELB [0] _ (Flag(GT|EQ))) => (MOVDconst [0])
+(ISELB [1] _ (FlagGT)) => (MOVDconst [1])
+(ISELB [1] _ (Flag(LT|EQ))) => (MOVDconst [0])
+(ISELB [2] _ (FlagEQ)) => (MOVDconst [1])
+(ISELB [2] _ (Flag(LT|GT))) => (MOVDconst [0])
+(ISELB [4] _ (FlagLT)) => (MOVDconst [0])
+(ISELB [4] _ (Flag(GT|EQ))) => (MOVDconst [1])
+(ISELB [5] _ (FlagGT)) => (MOVDconst [0])
+(ISELB [5] _ (Flag(LT|EQ))) => (MOVDconst [1])
+(ISELB [6] _ (FlagEQ)) => (MOVDconst [0])
+(ISELB [6] _ (Flag(LT|GT))) => (MOVDconst [1])
+
+(ISEL [2] x _ (FlagEQ)) => x
+(ISEL [2] _ y (Flag(LT|GT))) => y
+
+(ISEL [6] _ y (FlagEQ)) => y
+(ISEL [6] x _ (Flag(LT|GT))) => x
+
+(ISEL [0] _ y (Flag(EQ|GT))) => y
+(ISEL [0] x _ (FlagLT)) => x
+
+(ISEL [5] _ x (Flag(EQ|LT))) => x
+(ISEL [5] y _ (FlagGT)) => y
+
+(ISEL [1] _ y (Flag(EQ|LT))) => y
+(ISEL [1] x _ (FlagGT)) => x
+
+(ISEL [4] x _ (Flag(EQ|GT))) => x
+(ISEL [4] _ y (FlagLT)) => y
+
+(ISELB [n] (MOVDconst [1]) (InvertFlags bool)) && n%4 == 0 => (ISELB [n+1] (MOVDconst [1]) bool)
+(ISELB [n] (MOVDconst [1]) (InvertFlags bool)) && n%4 == 1 => (ISELB [n-1] (MOVDconst [1]) bool)
+(ISELB [n] (MOVDconst [1]) (InvertFlags bool)) && n%4 == 2 => (ISELB [n] (MOVDconst [1]) bool)
+(ISEL [n] x y (InvertFlags bool)) && n%4 == 0 => (ISEL [n+1] x y bool)
+(ISEL [n] x y (InvertFlags bool)) && n%4 == 1 => (ISEL [n-1] x y bool)
+(ISEL [n] x y (InvertFlags bool)) && n%4 == 2 => (ISEL [n] x y bool)
 
 // A particular pattern seen in cgo code:
-(AND (MOVDconst [c]) x:(MOVBZload _ _)) -> (ANDconst [c&0xFF] x)
+(AND (MOVDconst [c]) x:(MOVBZload _ _)) => (ANDconst [c&0xFF] x)
 
 // floating point negative abs
-(FNEG (FABS x)) -> (FNABS x)
-(FNEG (FNABS x)) -> (FABS x)
+(FNEG (FABS x)) => (FNABS x)
+(FNEG (FNABS x)) => (FABS x)
 
 // floating-point fused multiply-add/sub
-(FADD (FMUL x y) z) -> (FMADD x y z)
-(FSUB (FMUL x y) z) -> (FMSUB x y z)
-(FADDS (FMULS x y) z) -> (FMADDS x y z)
-(FSUBS (FMULS x y) z) -> (FMSUBS x y z)
+(FADD (FMUL x y) z) => (FMADD x y z)
+(FSUB (FMUL x y) z) => (FMSUB x y z)
+(FADDS (FMULS x y) z) => (FMADDS x y z)
+(FSUBS (FMULS x y) z) => (FMSUBS x y z)
 
 
 // The following statements are found in encoding/binary functions UintXX (load) and PutUintXX (store)
@@ -1079,7 +1079,7 @@
 // To implement for big endian machines, most rules would have to be duplicated but the
 // resulting rule would be reversed, i. e., MOVHZload on little endian would be MOVHBRload on big endian
 // and vice versa.
-// b[0] | b[1]<<8 -> load 16-bit Little endian
+// b[0] | b[1]<<8 => load 16-bit Little endian
 (OR <t> x0:(MOVBZload [i0] {s} p mem)
 	o1:(SL(W|D)const x1:(MOVBZload [i1] {s} p mem) [8]))
 	&& !config.BigEndian
@@ -1088,9 +1088,9 @@
 	&& o1.Uses == 1
 	&& mergePoint(b, x0, x1) != nil
 	&& clobber(x0, x1, o1)
-	 -> @mergePoint(b,x0,x1) (MOVHZload <t> {s} [i0] p mem)
+	 => @mergePoint(b,x0,x1) (MOVHZload <t> {s} [i0] p mem)
 
-// b[0]<<8 | b[1] -> load 16-bit Big endian on Little endian arch.
+// b[0]<<8 | b[1] => load 16-bit Big endian on Little endian arch.
 // Use byte-reverse indexed load for 2 bytes.
 (OR <t> x0:(MOVBZload [i1] {s} p mem)
 	o1:(SL(W|D)const x1:(MOVBZload [i0] {s} p mem) [8]))
@@ -1100,9 +1100,9 @@
 	&& o1.Uses == 1
 	&& mergePoint(b, x0, x1) != nil
 	&& clobber(x0, x1, o1)
-	  -> @mergePoint(b,x0,x1) (MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	  => @mergePoint(b,x0,x1) (MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 
-// b[0]<<n+8 | b[1]<<n -> load 16-bit Big endian (where n%8== 0)
+// b[0]<<n+8 | b[1]<<n => load 16-bit Big endian (where n%8== 0)
 // Use byte-reverse indexed load for 2 bytes,
 // then shift left to the correct position. Used to match subrules
 // from longer rules.
@@ -1116,9 +1116,9 @@
 	&& s0.Uses == 1 && s1.Uses == 1
 	&& mergePoint(b, x0, x1) != nil
 	&& clobber(x0, x1, s0, s1)
-	  -> @mergePoint(b,x0,x1) (SLDconst <t> (MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [n1])
+	  => @mergePoint(b,x0,x1) (SLDconst <t> (MOVHBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [n1])
 
-// b[0] | b[1]<<8 | b[2]<<16 | b[3]<<24 -> load 32-bit Little endian
+// b[0] | b[1]<<8 | b[2]<<16 | b[3]<<24 => load 32-bit Little endian
 // Use byte-reverse indexed load for 4 bytes.
 (OR <t> s1:(SL(W|D)const x2:(MOVBZload [i3] {s} p mem) [24])
 	o0:(OR <t> s0:(SL(W|D)const x1:(MOVBZload [i2] {s} p mem) [16])
@@ -1131,9 +1131,9 @@
 	&& s0.Uses == 1 && s1.Uses == 1
 	&& mergePoint(b, x0, x1, x2) != nil
 	&& clobber(x0, x1, x2, s0, s1, o0)
-	 -> @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
+	 => @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
 
-// b[0]<<24 | b[1]<<16 | b[2]<<8 | b[3] -> load 32-bit Big endian order on Little endian arch
+// b[0]<<24 | b[1]<<16 | b[2]<<8 | b[3] => load 32-bit Big endian order on Little endian arch
 // Use byte-reverse indexed load for 4 bytes with computed address.
 // Could be used to match subrules of a longer rule.
 (OR <t> s1:(SL(W|D)const x2:(MOVBZload [i0] {s} p mem) [24])
@@ -1147,9 +1147,9 @@
 	&& s0.Uses == 1 && s1.Uses == 1
 	&& mergePoint(b, x0, x1, x2) != nil
 	&& clobber(x0, x1, x2, s0, s1, o0)
-	  -> @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	  => @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 
-// b[3] | b[2]<<8 | b[1]<<16 | b[0]<<24 -> load 32-bit Big endian order on Little endian arch
+// b[3] | b[2]<<8 | b[1]<<16 | b[0]<<24 => load 32-bit Big endian order on Little endian arch
 // Use byte-reverse indexed load for 4 bytes with computed address.
 // Could be used to match subrules of a longer rule.
 (OR <t> x0:(MOVBZload [i3] {s} p mem)
@@ -1163,9 +1163,9 @@
 	&& s0.Uses == 1 && s1.Uses == 1
 	&& mergePoint(b, x0, x1, x2) != nil
 	&& clobber(x0, x1, x2, s0, s1, o0)
-	  -> @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	  => @mergePoint(b,x0,x1,x2) (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 
-// b[0]<<56 | b[1]<<48 | b[2]<<40 | b[3]<<32 -> load 32-bit Big endian order on Little endian arch
+// b[0]<<56 | b[1]<<48 | b[2]<<40 | b[3]<<32 => load 32-bit Big endian order on Little endian arch
 // Use byte-reverse indexed load to for 4 bytes with computed address.
 // Used to match longer rules.
 (OR <t> s2:(SLDconst x2:(MOVBZload [i3] {s} p mem) [32])
@@ -1179,9 +1179,9 @@
 	&& s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1
 	&& mergePoint(b, x0, x1, x2) != nil
 	&& clobber(x0, x1, x2, s0, s1, s2, o0)
-	  -> @mergePoint(b,x0,x1,x2) (SLDconst <t> (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])
+	  => @mergePoint(b,x0,x1,x2) (SLDconst <t> (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])
 
-// b[3]<<32 | b[2]<<40 | b[1]<<48 | b[0]<<56 -> load 32-bit Big endian order on Little endian arch
+// b[3]<<32 | b[2]<<40 | b[1]<<48 | b[0]<<56 => load 32-bit Big endian order on Little endian arch
 // Use byte-reverse indexed load for 4 bytes with constant address.
 // Used to match longer rules.
 (OR <t> s2:(SLDconst x2:(MOVBZload [i0] {s} p mem) [56])
@@ -1195,9 +1195,9 @@
         && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1
         && mergePoint(b, x0, x1, x2) != nil
         && clobber(x0, x1, x2, s0, s1, s2, o0)
-          -> @mergePoint(b,x0,x1,x2) (SLDconst <t> (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])
+          => @mergePoint(b,x0,x1,x2) (SLDconst <t> (MOVWBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem) [32])
 
-// b[0] | b[1]<<8 | b[2]<<16 | b[3]<<24 | b[4] <<32 | b[5]<<40 | b[6]<<48 | b[7]<<56 -> load 64-bit Little endian
+// b[0] | b[1]<<8 | b[2]<<16 | b[3]<<24 | b[4] <<32 | b[5]<<40 | b[6]<<48 | b[7]<<56 => load 64-bit Little endian
 // Rules with commutative ops and many operands will result in extremely large functions in rewritePPC64,
 // so matching shorter previously defined subrules is important.
 // Offset must be multiple of 4 for MOVD
@@ -1217,7 +1217,7 @@
 	&& s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1
 	&& mergePoint(b, x0, x4, x5, x6, x7) != nil
 	&& clobber(x0, x4, x5, x6, x7, s3, s4, s5, s6, o3, o4, o5)
-	  -> @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
+	  => @mergePoint(b,x0,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
 // b[7] | b[6]<<8 | b[5]<<16 | b[4]<<24 | b[3]<<32 | b[2]<<40 | b[1]<<48 | b[0]<<56 load 64-bit Big endian ordered bytes on Little endian arch
 // Use byte-reverse indexed load of 8 bytes.
@@ -1238,9 +1238,9 @@
 	&& s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1
 	&& mergePoint(b, x0, x1, x2, x3, x4) != nil
 	&& clobber(x0, x1, x2, x3, x4, o0, o1, o2, s0, s1, s2, s3)
-	  -> @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	  => @mergePoint(b,x0,x1,x2,x3,x4) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 
-// b[0]<<56 | b[1]<<48 | b[2]<<40 | b[3]<<32 | b[4]<<24 | b[5]<<16 | b[6]<<8 | b[7] -> load 64-bit Big endian ordered bytes on Little endian arch
+// b[0]<<56 | b[1]<<48 | b[2]<<40 | b[3]<<32 | b[4]<<24 | b[5]<<16 | b[6]<<8 | b[7] => load 64-bit Big endian ordered bytes on Little endian arch
 // Use byte-reverse indexed load of 8 bytes.
 // Rules with commutative ops and many operands can result in extremely large functions in rewritePPC64,
 // so matching shorter previously defined subrules is important.
@@ -1259,7 +1259,7 @@
 	&& s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1
 	&& mergePoint(b, x3, x4, x5, x6, x7) != nil
 	&& clobber(x3, x4, x5, x6, x7, o3, o4, o5, s0, s4, s5, s6)
-	-> @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
+	=> @mergePoint(b,x3,x4,x5,x6,x7) (MOVDBRload <t> (MOVDaddr <typ.Uintptr> [i0] {s} p) mem)
 
 // 2 byte store Little endian as in:
 //      b[0] = byte(v >> 16)
@@ -1271,7 +1271,7 @@
         && x0.Uses == 1
         && i1 == i0+1
         && clobber(x0)
-          -> (MOVHstore [i0] {s} p (SRWconst <typ.UInt16> w [16]) mem)
+          => (MOVHstore [i0] {s} p (SRWconst <typ.UInt16> w [16]) mem)
 
 // 2 byte store Little endian as in:
 //      b[0] = byte(v)
@@ -1282,7 +1282,7 @@
 	&& x0.Uses == 1
 	&& i1 == i0+1
 	&& clobber(x0)
-	  -> (MOVHstore [i0] {s} p w mem)
+	  => (MOVHstore [i0] {s} p w mem)
 
 // 4 byte store Little endian as in:
 //     b[0:1] = uint16(v)
@@ -1293,7 +1293,7 @@
 	&& x0.Uses == 1
 	&& i1 == i0+2
 	&& clobber(x0)
-	  -> (MOVWstore [i0] {s} p w mem)
+	  => (MOVWstore [i0] {s} p w mem)
 
 // 4 byte store Big endian as in:
 //     b[0] = byte(v >> 24)
@@ -1309,7 +1309,7 @@
 	&& x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1
 	&& i1 == i0+1 && i2 == i0+2 && i3 == i0+3
 	&& clobber(x0, x1, x2)
-	  -> (MOVWBRstore (MOVDaddr <typ.Uintptr> [i0] {s} p) w mem)
+	  => (MOVWBRstore (MOVDaddr <typ.Uintptr> [i0] {s} p) w mem)
 
 // The 2 byte store appears after the 4 byte store so that the
 // match for the 2 byte store is not done first.
@@ -1325,7 +1325,7 @@
 	&& x0.Uses == 1
 	&& i1 == i0+1
 	&& clobber(x0)
-	  -> (MOVHBRstore (MOVDaddr <typ.Uintptr> [i0] {s} p) w mem)
+	  => (MOVHBRstore (MOVDaddr <typ.Uintptr> [i0] {s} p) w mem)
 
 // 8 byte store Little endian as in:
 //	b[0] = byte(v)
@@ -1348,7 +1348,7 @@
 	&& x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1
 	&& i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7
 	&& clobber(x0, x1, x2, x3)
-	  -> (MOVDstore [i0] {s} p w mem)
+	  => (MOVDstore [i0] {s} p w mem)
 
 // 8 byte store Big endian as in:
 //      b[0] = byte(v >> 56)
@@ -1372,4 +1372,4 @@
         && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1
         && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7
         && clobber(x0, x1, x2, x3, x4, x5, x6)
-          -> (MOVDBRstore (MOVDaddr <typ.Uintptr> [i0] {s} p) w mem)
+          => (MOVDBRstore (MOVDaddr <typ.Uintptr> [i0] {s} p) w mem)
diff --git a/src/cmd/compile/internal/ssa/rewritePPC64.go b/src/cmd/compile/internal/ssa/rewritePPC64.go
index d950d3f133..1a61b409a0 100644
--- a/src/cmd/compile/internal/ssa/rewritePPC64.go
+++ b/src/cmd/compile/internal/ssa/rewritePPC64.go
@@ -37,8 +37,7 @@ func rewriteValuePPC64(v *Value) bool {
 		v.Op = OpPPC64ADD
 		return true
 	case OpAddr:
-		v.Op = OpPPC64MOVDaddr
-		return true
+		return rewriteValuePPC64_OpAddr(v)
 	case OpAnd16:
 		v.Op = OpPPC64AND
 		return true
@@ -119,26 +118,21 @@ func rewriteValuePPC64(v *Value) bool {
 	case OpCondSelect:
 		return rewriteValuePPC64_OpCondSelect(v)
 	case OpConst16:
-		v.Op = OpPPC64MOVDconst
-		return true
+		return rewriteValuePPC64_OpConst16(v)
 	case OpConst32:
-		v.Op = OpPPC64MOVDconst
-		return true
+		return rewriteValuePPC64_OpConst32(v)
 	case OpConst32F:
 		v.Op = OpPPC64FMOVSconst
 		return true
 	case OpConst64:
-		v.Op = OpPPC64MOVDconst
-		return true
+		return rewriteValuePPC64_OpConst64(v)
 	case OpConst64F:
 		v.Op = OpPPC64FMOVDconst
 		return true
 	case OpConst8:
-		v.Op = OpPPC64MOVDconst
-		return true
+		return rewriteValuePPC64_OpConst8(v)
 	case OpConstBool:
-		v.Op = OpPPC64MOVDconst
-		return true
+		return rewriteValuePPC64_OpConstBool(v)
 	case OpConstNil:
 		return rewriteValuePPC64_OpConstNil(v)
 	case OpCopysign:
@@ -187,8 +181,7 @@ func rewriteValuePPC64(v *Value) bool {
 	case OpDiv16u:
 		return rewriteValuePPC64_OpDiv16u(v)
 	case OpDiv32:
-		v.Op = OpPPC64DIVW
-		return true
+		return rewriteValuePPC64_OpDiv32(v)
 	case OpDiv32F:
 		v.Op = OpPPC64FDIVS
 		return true
@@ -196,8 +189,7 @@ func rewriteValuePPC64(v *Value) bool {
 		v.Op = OpPPC64DIVWU
 		return true
 	case OpDiv64:
-		v.Op = OpPPC64DIVD
-		return true
+		return rewriteValuePPC64_OpDiv64(v)
 	case OpDiv64F:
 		v.Op = OpPPC64FDIV
 		return true
@@ -806,6 +798,20 @@ func rewriteValuePPC64(v *Value) bool {
 	}
 	return false
 }
+func rewriteValuePPC64_OpAddr(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (Addr {sym} base)
+	// result: (MOVDaddr {sym} [0] base)
+	for {
+		sym := auxToSym(v.Aux)
+		base := v_0
+		v.reset(OpPPC64MOVDaddr)
+		v.AuxInt = int32ToAuxInt(0)
+		v.Aux = symToAux(sym)
+		v.AddArg(base)
+		return true
+	}
+}
 func rewriteValuePPC64_OpAtomicCompareAndSwap32(v *Value) bool {
 	v_3 := v.Args[3]
 	v_2 := v.Args[2]
@@ -819,7 +825,7 @@ func rewriteValuePPC64_OpAtomicCompareAndSwap32(v *Value) bool {
 		new_ := v_2
 		mem := v_3
 		v.reset(OpPPC64LoweredAtomicCas32)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		v.AddArg4(ptr, old, new_, mem)
 		return true
 	}
@@ -837,7 +843,7 @@ func rewriteValuePPC64_OpAtomicCompareAndSwap64(v *Value) bool {
 		new_ := v_2
 		mem := v_3
 		v.reset(OpPPC64LoweredAtomicCas64)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		v.AddArg4(ptr, old, new_, mem)
 		return true
 	}
@@ -855,7 +861,7 @@ func rewriteValuePPC64_OpAtomicCompareAndSwapRel32(v *Value) bool {
 		new_ := v_2
 		mem := v_3
 		v.reset(OpPPC64LoweredAtomicCas32)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		v.AddArg4(ptr, old, new_, mem)
 		return true
 	}
@@ -869,7 +875,7 @@ func rewriteValuePPC64_OpAtomicLoad32(v *Value) bool {
 		ptr := v_0
 		mem := v_1
 		v.reset(OpPPC64LoweredAtomicLoad32)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -883,7 +889,7 @@ func rewriteValuePPC64_OpAtomicLoad64(v *Value) bool {
 		ptr := v_0
 		mem := v_1
 		v.reset(OpPPC64LoweredAtomicLoad64)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -897,7 +903,7 @@ func rewriteValuePPC64_OpAtomicLoad8(v *Value) bool {
 		ptr := v_0
 		mem := v_1
 		v.reset(OpPPC64LoweredAtomicLoad8)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -911,7 +917,7 @@ func rewriteValuePPC64_OpAtomicLoadAcq32(v *Value) bool {
 		ptr := v_0
 		mem := v_1
 		v.reset(OpPPC64LoweredAtomicLoad32)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -925,7 +931,7 @@ func rewriteValuePPC64_OpAtomicLoadPtr(v *Value) bool {
 		ptr := v_0
 		mem := v_1
 		v.reset(OpPPC64LoweredAtomicLoadPtr)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -941,7 +947,7 @@ func rewriteValuePPC64_OpAtomicStore32(v *Value) bool {
 		val := v_1
 		mem := v_2
 		v.reset(OpPPC64LoweredAtomicStore32)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
@@ -957,7 +963,7 @@ func rewriteValuePPC64_OpAtomicStore64(v *Value) bool {
 		val := v_1
 		mem := v_2
 		v.reset(OpPPC64LoweredAtomicStore64)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
@@ -973,7 +979,7 @@ func rewriteValuePPC64_OpAtomicStore8(v *Value) bool {
 		val := v_1
 		mem := v_2
 		v.reset(OpPPC64LoweredAtomicStore8)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
@@ -989,7 +995,7 @@ func rewriteValuePPC64_OpAtomicStoreRel32(v *Value) bool {
 		val := v_1
 		mem := v_2
 		v.reset(OpPPC64LoweredAtomicStore32)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
@@ -1006,7 +1012,7 @@ func rewriteValuePPC64_OpAvg64u(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64ADD)
 		v0 := b.NewValue0(v.Pos, OpPPC64SRDconst, t)
-		v0.AuxInt = 1
+		v0.AuxInt = int64ToAuxInt(1)
 		v1 := b.NewValue0(v.Pos, OpPPC64SUB, t)
 		v1.AddArg2(x, y)
 		v0.AddArg(v1)
@@ -1024,7 +1030,7 @@ func rewriteValuePPC64_OpBitLen32(v *Value) bool {
 		x := v_0
 		v.reset(OpPPC64SUB)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v0.AuxInt = 32
+		v0.AuxInt = int64ToAuxInt(32)
 		v1 := b.NewValue0(v.Pos, OpPPC64CNTLZW, typ.Int)
 		v1.AddArg(x)
 		v.AddArg2(v0, v1)
@@ -1041,7 +1047,7 @@ func rewriteValuePPC64_OpBitLen64(v *Value) bool {
 		x := v_0
 		v.reset(OpPPC64SUB)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v0.AuxInt = 64
+		v0.AuxInt = int64ToAuxInt(64)
 		v1 := b.NewValue0(v.Pos, OpPPC64CNTLZD, typ.Int)
 		v1.AddArg(x)
 		v.AddArg2(v0, v1)
@@ -1108,7 +1114,7 @@ func rewriteValuePPC64_OpCondSelect(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64ISEL)
-		v.AuxInt = 2
+		v.AuxInt = int32ToAuxInt(2)
 		v.AddArg3(x, y, bool)
 		return true
 	}
@@ -1123,21 +1129,71 @@ func rewriteValuePPC64_OpCondSelect(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64ISEL)
-		v.AuxInt = 2
+		v.AuxInt = int32ToAuxInt(2)
 		v0 := b.NewValue0(v.Pos, OpPPC64CMPWconst, types.TypeFlags)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v0.AddArg(bool)
 		v.AddArg3(x, y, v0)
 		return true
 	}
 	return false
 }
+func rewriteValuePPC64_OpConst16(v *Value) bool {
+	// match: (Const16 [val])
+	// result: (MOVDconst [int64(val)])
+	for {
+		val := auxIntToInt16(v.AuxInt)
+		v.reset(OpPPC64MOVDconst)
+		v.AuxInt = int64ToAuxInt(int64(val))
+		return true
+	}
+}
+func rewriteValuePPC64_OpConst32(v *Value) bool {
+	// match: (Const32 [val])
+	// result: (MOVDconst [int64(val)])
+	for {
+		val := auxIntToInt32(v.AuxInt)
+		v.reset(OpPPC64MOVDconst)
+		v.AuxInt = int64ToAuxInt(int64(val))
+		return true
+	}
+}
+func rewriteValuePPC64_OpConst64(v *Value) bool {
+	// match: (Const64 [val])
+	// result: (MOVDconst [int64(val)])
+	for {
+		val := auxIntToInt64(v.AuxInt)
+		v.reset(OpPPC64MOVDconst)
+		v.AuxInt = int64ToAuxInt(int64(val))
+		return true
+	}
+}
+func rewriteValuePPC64_OpConst8(v *Value) bool {
+	// match: (Const8 [val])
+	// result: (MOVDconst [int64(val)])
+	for {
+		val := auxIntToInt8(v.AuxInt)
+		v.reset(OpPPC64MOVDconst)
+		v.AuxInt = int64ToAuxInt(int64(val))
+		return true
+	}
+}
+func rewriteValuePPC64_OpConstBool(v *Value) bool {
+	// match: (ConstBool [b])
+	// result: (MOVDconst [b2i(b)])
+	for {
+		b := auxIntToBool(v.AuxInt)
+		v.reset(OpPPC64MOVDconst)
+		v.AuxInt = int64ToAuxInt(b2i(b))
+		return true
+	}
+}
 func rewriteValuePPC64_OpConstNil(v *Value) bool {
 	// match: (ConstNil)
 	// result: (MOVDconst [0])
 	for {
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 }
@@ -1166,7 +1222,7 @@ func rewriteValuePPC64_OpCtz16(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVHZreg, typ.Int64)
 		v1 := b.NewValue0(v.Pos, OpPPC64ANDN, typ.Int16)
 		v2 := b.NewValue0(v.Pos, OpPPC64ADDconst, typ.Int16)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v2.AddArg(x)
 		v1.AddArg2(v2, x)
 		v0.AddArg(v1)
@@ -1190,7 +1246,7 @@ func rewriteValuePPC64_OpCtz32(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVWZreg, typ.Int64)
 		v1 := b.NewValue0(v.Pos, OpPPC64ANDN, typ.Int)
 		v2 := b.NewValue0(v.Pos, OpPPC64ADDconst, typ.Int)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v2.AddArg(x)
 		v1.AddArg2(v2, x)
 		v0.AddArg(v1)
@@ -1223,7 +1279,7 @@ func rewriteValuePPC64_OpCtz64(v *Value) bool {
 		v.reset(OpPPC64POPCNTD)
 		v0 := b.NewValue0(v.Pos, OpPPC64ANDN, typ.Int64)
 		v1 := b.NewValue0(v.Pos, OpPPC64ADDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v1.AddArg(x)
 		v0.AddArg2(v1, x)
 		v.AddArg(v0)
@@ -1250,7 +1306,7 @@ func rewriteValuePPC64_OpCtz8(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVBZreg, typ.Int64)
 		v1 := b.NewValue0(v.Pos, OpPPC64ANDN, typ.UInt8)
 		v2 := b.NewValue0(v.Pos, OpPPC64ADDconst, typ.UInt8)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v2.AddArg(x)
 		v1.AddArg2(v2, x)
 		v0.AddArg(v1)
@@ -1387,9 +1443,12 @@ func rewriteValuePPC64_OpDiv16(v *Value) bool {
 	v_0 := v.Args[0]
 	b := v.Block
 	typ := &b.Func.Config.Types
-	// match: (Div16 x y)
+	// match: (Div16 [false] x y)
 	// result: (DIVW (SignExt16to32 x) (SignExt16to32 y))
 	for {
+		if auxIntToBool(v.AuxInt) != false {
+			break
+		}
 		x := v_0
 		y := v_1
 		v.reset(OpPPC64DIVW)
@@ -1400,6 +1459,7 @@ func rewriteValuePPC64_OpDiv16(v *Value) bool {
 		v.AddArg2(v0, v1)
 		return true
 	}
+	return false
 }
 func rewriteValuePPC64_OpDiv16u(v *Value) bool {
 	v_1 := v.Args[1]
@@ -1420,6 +1480,40 @@ func rewriteValuePPC64_OpDiv16u(v *Value) bool {
 		return true
 	}
 }
+func rewriteValuePPC64_OpDiv32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (Div32 [false] x y)
+	// result: (DIVW x y)
+	for {
+		if auxIntToBool(v.AuxInt) != false {
+			break
+		}
+		x := v_0
+		y := v_1
+		v.reset(OpPPC64DIVW)
+		v.AddArg2(x, y)
+		return true
+	}
+	return false
+}
+func rewriteValuePPC64_OpDiv64(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (Div64 [false] x y)
+	// result: (DIVD x y)
+	for {
+		if auxIntToBool(v.AuxInt) != false {
+			break
+		}
+		x := v_0
+		y := v_1
+		v.reset(OpPPC64DIVD)
+		v.AddArg2(x, y)
+		return true
+	}
+	return false
+}
 func rewriteValuePPC64_OpDiv8(v *Value) bool {
 	v_1 := v.Args[1]
 	v_0 := v.Args[0]
@@ -1619,7 +1713,7 @@ func rewriteValuePPC64_OpEqB(v *Value) bool {
 		x := v_0
 		y := v_1
 		v.reset(OpPPC64ANDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		v0 := b.NewValue0(v.Pos, OpPPC64EQV, typ.Int64)
 		v0.AddArg2(x, y)
 		v.AddArg(v0)
@@ -1667,7 +1761,7 @@ func rewriteValuePPC64_OpIsNonNil(v *Value) bool {
 		ptr := v_0
 		v.reset(OpPPC64NotEqual)
 		v0 := b.NewValue0(v.Pos, OpPPC64CMPconst, types.TypeFlags)
-		v0.AuxInt = 0
+		v0.AuxInt = int64ToAuxInt(0)
 		v0.AddArg(ptr)
 		v.AddArg(v0)
 		return true
@@ -2203,10 +2297,10 @@ func rewriteValuePPC64_OpLocalAddr(v *Value) bool {
 	// match: (LocalAddr {sym} base _)
 	// result: (MOVDaddr {sym} base)
 	for {
-		sym := v.Aux
+		sym := auxToSym(v.Aux)
 		base := v_0
 		v.reset(OpPPC64MOVDaddr)
-		v.Aux = sym
+		v.Aux = symToAux(sym)
 		v.AddArg(base)
 		return true
 	}
@@ -2236,14 +2330,14 @@ func rewriteValuePPC64_OpLsh16x16(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SLW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
 		v3.AddArg(y)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 16
+		v4.AuxInt = int64ToAuxInt(16)
 		v2.AddArg2(v3, v4)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -2263,12 +2357,12 @@ func rewriteValuePPC64_OpLsh16x32(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint32(c) < 16) {
 			break
 		}
 		v.reset(OpPPC64SLWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -2292,12 +2386,12 @@ func rewriteValuePPC64_OpLsh16x32(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SLW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v3.AuxInt = 16
+		v3.AuxInt = int64ToAuxInt(16)
 		v2.AddArg2(y, v3)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -2316,12 +2410,12 @@ func rewriteValuePPC64_OpLsh16x64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) >= 16) {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (Lsh16x64 x (MOVDconst [c]))
@@ -2332,12 +2426,12 @@ func rewriteValuePPC64_OpLsh16x64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) < 16) {
 			break
 		}
 		v.reset(OpPPC64SLWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -2361,12 +2455,12 @@ func rewriteValuePPC64_OpLsh16x64(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SLW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v3.AuxInt = 16
+		v3.AuxInt = int64ToAuxInt(16)
 		v2.AddArg2(y, v3)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -2398,14 +2492,14 @@ func rewriteValuePPC64_OpLsh16x8(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SLW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
 		v3.AddArg(y)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 16
+		v4.AuxInt = int64ToAuxInt(16)
 		v2.AddArg2(v3, v4)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -2437,14 +2531,14 @@ func rewriteValuePPC64_OpLsh32x16(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SLW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
 		v3.AddArg(y)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 32
+		v4.AuxInt = int64ToAuxInt(32)
 		v2.AddArg2(v3, v4)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -2464,12 +2558,12 @@ func rewriteValuePPC64_OpLsh32x32(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint32(c) < 32) {
 			break
 		}
 		v.reset(OpPPC64SLWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -2493,12 +2587,12 @@ func rewriteValuePPC64_OpLsh32x32(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SLW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v3.AuxInt = 32
+		v3.AuxInt = int64ToAuxInt(32)
 		v2.AddArg2(y, v3)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -2517,12 +2611,12 @@ func rewriteValuePPC64_OpLsh32x64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) >= 32) {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (Lsh32x64 x (MOVDconst [c]))
@@ -2533,12 +2627,12 @@ func rewriteValuePPC64_OpLsh32x64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) < 32) {
 			break
 		}
 		v.reset(OpPPC64SLWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -2567,12 +2661,12 @@ func rewriteValuePPC64_OpLsh32x64(v *Value) bool {
 		v_1_1 := v_1.Args[1]
 		for _i0 := 0; _i0 <= 1; _i0, v_1_0, v_1_1 = _i0+1, v_1_1, v_1_0 {
 			y := v_1_0
-			if v_1_1.Op != OpPPC64MOVDconst || v_1_1.AuxInt != 31 {
+			if v_1_1.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_1.AuxInt) != 31 {
 				continue
 			}
 			v.reset(OpPPC64SLW)
 			v0 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int32)
-			v0.AuxInt = 31
+			v0.AuxInt = int64ToAuxInt(31)
 			v0.AddArg(y)
 			v.AddArg2(x, v0)
 			return true
@@ -2583,13 +2677,13 @@ func rewriteValuePPC64_OpLsh32x64(v *Value) bool {
 	// result: (SLW x (ANDconst <typ.Int32> [31] y))
 	for {
 		x := v_0
-		if v_1.Op != OpPPC64ANDconst || v_1.Type != typ.Int32 || v_1.AuxInt != 31 {
+		if v_1.Op != OpPPC64ANDconst || v_1.Type != typ.Int32 || auxIntToInt64(v_1.AuxInt) != 31 {
 			break
 		}
 		y := v_1.Args[0]
 		v.reset(OpPPC64SLW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int32)
-		v0.AuxInt = 31
+		v0.AuxInt = int64ToAuxInt(31)
 		v0.AddArg(y)
 		v.AddArg2(x, v0)
 		return true
@@ -2601,12 +2695,12 @@ func rewriteValuePPC64_OpLsh32x64(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SLW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v3.AuxInt = 32
+		v3.AuxInt = int64ToAuxInt(32)
 		v2.AddArg2(y, v3)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -2638,14 +2732,14 @@ func rewriteValuePPC64_OpLsh32x8(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SLW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
 		v3.AddArg(y)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 32
+		v4.AuxInt = int64ToAuxInt(32)
 		v2.AddArg2(v3, v4)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -2677,14 +2771,14 @@ func rewriteValuePPC64_OpLsh64x16(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SLD)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
 		v3.AddArg(y)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 64
+		v4.AuxInt = int64ToAuxInt(64)
 		v2.AddArg2(v3, v4)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -2704,12 +2798,12 @@ func rewriteValuePPC64_OpLsh64x32(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint32(c) < 64) {
 			break
 		}
 		v.reset(OpPPC64SLDconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -2733,12 +2827,12 @@ func rewriteValuePPC64_OpLsh64x32(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SLD)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v3.AuxInt = 64
+		v3.AuxInt = int64ToAuxInt(64)
 		v2.AddArg2(y, v3)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -2757,12 +2851,12 @@ func rewriteValuePPC64_OpLsh64x64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) >= 64) {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (Lsh64x64 x (MOVDconst [c]))
@@ -2773,12 +2867,12 @@ func rewriteValuePPC64_OpLsh64x64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) < 64) {
 			break
 		}
 		v.reset(OpPPC64SLDconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -2807,12 +2901,12 @@ func rewriteValuePPC64_OpLsh64x64(v *Value) bool {
 		v_1_1 := v_1.Args[1]
 		for _i0 := 0; _i0 <= 1; _i0, v_1_0, v_1_1 = _i0+1, v_1_1, v_1_0 {
 			y := v_1_0
-			if v_1_1.Op != OpPPC64MOVDconst || v_1_1.AuxInt != 63 {
+			if v_1_1.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_1.AuxInt) != 63 {
 				continue
 			}
 			v.reset(OpPPC64SLD)
 			v0 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int64)
-			v0.AuxInt = 63
+			v0.AuxInt = int64ToAuxInt(63)
 			v0.AddArg(y)
 			v.AddArg2(x, v0)
 			return true
@@ -2823,13 +2917,13 @@ func rewriteValuePPC64_OpLsh64x64(v *Value) bool {
 	// result: (SLD x (ANDconst <typ.Int64> [63] y))
 	for {
 		x := v_0
-		if v_1.Op != OpPPC64ANDconst || v_1.Type != typ.Int64 || v_1.AuxInt != 63 {
+		if v_1.Op != OpPPC64ANDconst || v_1.Type != typ.Int64 || auxIntToInt64(v_1.AuxInt) != 63 {
 			break
 		}
 		y := v_1.Args[0]
 		v.reset(OpPPC64SLD)
 		v0 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int64)
-		v0.AuxInt = 63
+		v0.AuxInt = int64ToAuxInt(63)
 		v0.AddArg(y)
 		v.AddArg2(x, v0)
 		return true
@@ -2841,12 +2935,12 @@ func rewriteValuePPC64_OpLsh64x64(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SLD)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v3.AuxInt = 64
+		v3.AuxInt = int64ToAuxInt(64)
 		v2.AddArg2(y, v3)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -2878,14 +2972,14 @@ func rewriteValuePPC64_OpLsh64x8(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SLD)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
 		v3.AddArg(y)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 64
+		v4.AuxInt = int64ToAuxInt(64)
 		v2.AddArg2(v3, v4)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -2917,14 +3011,14 @@ func rewriteValuePPC64_OpLsh8x16(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SLW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
 		v3.AddArg(y)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 8
+		v4.AuxInt = int64ToAuxInt(8)
 		v2.AddArg2(v3, v4)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -2944,12 +3038,12 @@ func rewriteValuePPC64_OpLsh8x32(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint32(c) < 8) {
 			break
 		}
 		v.reset(OpPPC64SLWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -2973,12 +3067,12 @@ func rewriteValuePPC64_OpLsh8x32(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SLW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v3.AuxInt = 8
+		v3.AuxInt = int64ToAuxInt(8)
 		v2.AddArg2(y, v3)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -2997,12 +3091,12 @@ func rewriteValuePPC64_OpLsh8x64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) >= 8) {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (Lsh8x64 x (MOVDconst [c]))
@@ -3013,12 +3107,12 @@ func rewriteValuePPC64_OpLsh8x64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) < 8) {
 			break
 		}
 		v.reset(OpPPC64SLWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -3042,12 +3136,12 @@ func rewriteValuePPC64_OpLsh8x64(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SLW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v3.AuxInt = 8
+		v3.AuxInt = int64ToAuxInt(8)
 		v2.AddArg2(y, v3)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -3079,14 +3173,14 @@ func rewriteValuePPC64_OpLsh8x8(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SLW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
 		v3.AddArg(y)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 8
+		v4.AuxInt = int64ToAuxInt(8)
 		v2.AddArg2(v3, v4)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -3254,7 +3348,7 @@ func rewriteValuePPC64_OpMove(v *Value) bool {
 	// match: (Move [0] _ _ mem)
 	// result: mem
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt64(v.AuxInt) != 0 {
 			break
 		}
 		mem := v_2
@@ -3264,7 +3358,7 @@ func rewriteValuePPC64_OpMove(v *Value) bool {
 	// match: (Move [1] dst src mem)
 	// result: (MOVBstore dst (MOVBZload src mem) mem)
 	for {
-		if v.AuxInt != 1 {
+		if auxIntToInt64(v.AuxInt) != 1 {
 			break
 		}
 		dst := v_0
@@ -3279,7 +3373,7 @@ func rewriteValuePPC64_OpMove(v *Value) bool {
 	// match: (Move [2] dst src mem)
 	// result: (MOVHstore dst (MOVHZload src mem) mem)
 	for {
-		if v.AuxInt != 2 {
+		if auxIntToInt64(v.AuxInt) != 2 {
 			break
 		}
 		dst := v_0
@@ -3294,7 +3388,7 @@ func rewriteValuePPC64_OpMove(v *Value) bool {
 	// match: (Move [4] dst src mem)
 	// result: (MOVWstore dst (MOVWZload src mem) mem)
 	for {
-		if v.AuxInt != 4 {
+		if auxIntToInt64(v.AuxInt) != 4 {
 			break
 		}
 		dst := v_0
@@ -3307,17 +3401,17 @@ func rewriteValuePPC64_OpMove(v *Value) bool {
 		return true
 	}
 	// match: (Move [8] {t} dst src mem)
-	// cond: t.(*types.Type).Alignment()%4 == 0
+	// cond: t.Alignment()%4 == 0
 	// result: (MOVDstore dst (MOVDload src mem) mem)
 	for {
-		if v.AuxInt != 8 {
+		if auxIntToInt64(v.AuxInt) != 8 {
 			break
 		}
-		t := v.Aux
+		t := auxToType(v.Aux)
 		dst := v_0
 		src := v_1
 		mem := v_2
-		if !(t.(*types.Type).Alignment()%4 == 0) {
+		if !(t.Alignment()%4 == 0) {
 			break
 		}
 		v.reset(OpPPC64MOVDstore)
@@ -3329,16 +3423,16 @@ func rewriteValuePPC64_OpMove(v *Value) bool {
 	// match: (Move [8] dst src mem)
 	// result: (MOVWstore [4] dst (MOVWZload [4] src mem) (MOVWstore dst (MOVWZload src mem) mem))
 	for {
-		if v.AuxInt != 8 {
+		if auxIntToInt64(v.AuxInt) != 8 {
 			break
 		}
 		dst := v_0
 		src := v_1
 		mem := v_2
 		v.reset(OpPPC64MOVWstore)
-		v.AuxInt = 4
+		v.AuxInt = int32ToAuxInt(4)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVWZload, typ.UInt32)
-		v0.AuxInt = 4
+		v0.AuxInt = int32ToAuxInt(4)
 		v0.AddArg2(src, mem)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVWstore, types.TypeMem)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVWZload, typ.UInt32)
@@ -3350,16 +3444,16 @@ func rewriteValuePPC64_OpMove(v *Value) bool {
 	// match: (Move [3] dst src mem)
 	// result: (MOVBstore [2] dst (MOVBZload [2] src mem) (MOVHstore dst (MOVHload src mem) mem))
 	for {
-		if v.AuxInt != 3 {
+		if auxIntToInt64(v.AuxInt) != 3 {
 			break
 		}
 		dst := v_0
 		src := v_1
 		mem := v_2
 		v.reset(OpPPC64MOVBstore)
-		v.AuxInt = 2
+		v.AuxInt = int32ToAuxInt(2)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVBZload, typ.UInt8)
-		v0.AuxInt = 2
+		v0.AuxInt = int32ToAuxInt(2)
 		v0.AddArg2(src, mem)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVHstore, types.TypeMem)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVHload, typ.Int16)
@@ -3371,16 +3465,16 @@ func rewriteValuePPC64_OpMove(v *Value) bool {
 	// match: (Move [5] dst src mem)
 	// result: (MOVBstore [4] dst (MOVBZload [4] src mem) (MOVWstore dst (MOVWZload src mem) mem))
 	for {
-		if v.AuxInt != 5 {
+		if auxIntToInt64(v.AuxInt) != 5 {
 			break
 		}
 		dst := v_0
 		src := v_1
 		mem := v_2
 		v.reset(OpPPC64MOVBstore)
-		v.AuxInt = 4
+		v.AuxInt = int32ToAuxInt(4)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVBZload, typ.UInt8)
-		v0.AuxInt = 4
+		v0.AuxInt = int32ToAuxInt(4)
 		v0.AddArg2(src, mem)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVWstore, types.TypeMem)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVWZload, typ.UInt32)
@@ -3392,16 +3486,16 @@ func rewriteValuePPC64_OpMove(v *Value) bool {
 	// match: (Move [6] dst src mem)
 	// result: (MOVHstore [4] dst (MOVHZload [4] src mem) (MOVWstore dst (MOVWZload src mem) mem))
 	for {
-		if v.AuxInt != 6 {
+		if auxIntToInt64(v.AuxInt) != 6 {
 			break
 		}
 		dst := v_0
 		src := v_1
 		mem := v_2
 		v.reset(OpPPC64MOVHstore)
-		v.AuxInt = 4
+		v.AuxInt = int32ToAuxInt(4)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVHZload, typ.UInt16)
-		v0.AuxInt = 4
+		v0.AuxInt = int32ToAuxInt(4)
 		v0.AddArg2(src, mem)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVWstore, types.TypeMem)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVWZload, typ.UInt32)
@@ -3413,21 +3507,21 @@ func rewriteValuePPC64_OpMove(v *Value) bool {
 	// match: (Move [7] dst src mem)
 	// result: (MOVBstore [6] dst (MOVBZload [6] src mem) (MOVHstore [4] dst (MOVHZload [4] src mem) (MOVWstore dst (MOVWZload src mem) mem)))
 	for {
-		if v.AuxInt != 7 {
+		if auxIntToInt64(v.AuxInt) != 7 {
 			break
 		}
 		dst := v_0
 		src := v_1
 		mem := v_2
 		v.reset(OpPPC64MOVBstore)
-		v.AuxInt = 6
+		v.AuxInt = int32ToAuxInt(6)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVBZload, typ.UInt8)
-		v0.AuxInt = 6
+		v0.AuxInt = int32ToAuxInt(6)
 		v0.AddArg2(src, mem)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVHstore, types.TypeMem)
-		v1.AuxInt = 4
+		v1.AuxInt = int32ToAuxInt(4)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVHZload, typ.UInt16)
-		v2.AuxInt = 4
+		v2.AuxInt = int32ToAuxInt(4)
 		v2.AddArg2(src, mem)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVWstore, types.TypeMem)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVWZload, typ.UInt32)
@@ -3441,7 +3535,7 @@ func rewriteValuePPC64_OpMove(v *Value) bool {
 	// cond: s > 8 && objabi.GOPPC64 <= 8 && logLargeCopy(v, s)
 	// result: (LoweredMove [s] dst src mem)
 	for {
-		s := v.AuxInt
+		s := auxIntToInt64(v.AuxInt)
 		dst := v_0
 		src := v_1
 		mem := v_2
@@ -3449,7 +3543,7 @@ func rewriteValuePPC64_OpMove(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64LoweredMove)
-		v.AuxInt = s
+		v.AuxInt = int64ToAuxInt(s)
 		v.AddArg3(dst, src, mem)
 		return true
 	}
@@ -3457,7 +3551,7 @@ func rewriteValuePPC64_OpMove(v *Value) bool {
 	// cond: s > 8 && s <= 64 && objabi.GOPPC64 >= 9
 	// result: (LoweredQuadMoveShort [s] dst src mem)
 	for {
-		s := v.AuxInt
+		s := auxIntToInt64(v.AuxInt)
 		dst := v_0
 		src := v_1
 		mem := v_2
@@ -3465,7 +3559,7 @@ func rewriteValuePPC64_OpMove(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64LoweredQuadMoveShort)
-		v.AuxInt = s
+		v.AuxInt = int64ToAuxInt(s)
 		v.AddArg3(dst, src, mem)
 		return true
 	}
@@ -3473,7 +3567,7 @@ func rewriteValuePPC64_OpMove(v *Value) bool {
 	// cond: s > 8 && objabi.GOPPC64 >= 9 && logLargeCopy(v, s)
 	// result: (LoweredQuadMove [s] dst src mem)
 	for {
-		s := v.AuxInt
+		s := auxIntToInt64(v.AuxInt)
 		dst := v_0
 		src := v_1
 		mem := v_2
@@ -3481,7 +3575,7 @@ func rewriteValuePPC64_OpMove(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64LoweredQuadMove)
-		v.AuxInt = s
+		v.AuxInt = int64ToAuxInt(s)
 		v.AddArg3(dst, src, mem)
 		return true
 	}
@@ -3660,7 +3754,7 @@ func rewriteValuePPC64_OpNot(v *Value) bool {
 	for {
 		x := v_0
 		v.reset(OpPPC64XORconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		v.AddArg(x)
 		return true
 	}
@@ -3672,11 +3766,11 @@ func rewriteValuePPC64_OpOffPtr(v *Value) bool {
 	// match: (OffPtr [off] ptr)
 	// result: (ADD (MOVDconst <typ.Int64> [off]) ptr)
 	for {
-		off := v.AuxInt
+		off := auxIntToInt64(v.AuxInt)
 		ptr := v_0
 		v.reset(OpPPC64ADD)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v0.AuxInt = off
+		v0.AuxInt = int64ToAuxInt(off)
 		v.AddArg2(v0, ptr)
 		return true
 	}
@@ -3694,17 +3788,17 @@ func rewriteValuePPC64_OpPPC64ADD(v *Value) bool {
 			if v_0.Op != OpPPC64SLDconst {
 				continue
 			}
-			c := v_0.AuxInt
+			c := auxIntToInt64(v_0.AuxInt)
 			x := v_0.Args[0]
 			if v_1.Op != OpPPC64SRDconst {
 				continue
 			}
-			d := v_1.AuxInt
+			d := auxIntToInt64(v_1.AuxInt)
 			if x != v_1.Args[0] || !(d == 64-c) {
 				continue
 			}
 			v.reset(OpPPC64ROTLconst)
-			v.AuxInt = c
+			v.AuxInt = int64ToAuxInt(c)
 			v.AddArg(x)
 			return true
 		}
@@ -3718,17 +3812,17 @@ func rewriteValuePPC64_OpPPC64ADD(v *Value) bool {
 			if v_0.Op != OpPPC64SLWconst {
 				continue
 			}
-			c := v_0.AuxInt
+			c := auxIntToInt64(v_0.AuxInt)
 			x := v_0.Args[0]
 			if v_1.Op != OpPPC64SRWconst {
 				continue
 			}
-			d := v_1.AuxInt
+			d := auxIntToInt64(v_1.AuxInt)
 			if x != v_1.Args[0] || !(d == 32-c) {
 				continue
 			}
 			v.reset(OpPPC64ROTLWconst)
-			v.AuxInt = c
+			v.AuxInt = int64ToAuxInt(c)
 			v.AddArg(x)
 			return true
 		}
@@ -3744,7 +3838,7 @@ func rewriteValuePPC64_OpPPC64ADD(v *Value) bool {
 			_ = v_0.Args[1]
 			x := v_0.Args[0]
 			v_0_1 := v_0.Args[1]
-			if v_0_1.Op != OpPPC64ANDconst || v_0_1.Type != typ.Int64 || v_0_1.AuxInt != 63 {
+			if v_0_1.Op != OpPPC64ANDconst || v_0_1.Type != typ.Int64 || auxIntToInt64(v_0_1.AuxInt) != 63 {
 				continue
 			}
 			y := v_0_1.Args[0]
@@ -3761,11 +3855,11 @@ func rewriteValuePPC64_OpPPC64ADD(v *Value) bool {
 			}
 			_ = v_1_1.Args[1]
 			v_1_1_0 := v_1_1.Args[0]
-			if v_1_1_0.Op != OpPPC64MOVDconst || v_1_1_0.AuxInt != 64 {
+			if v_1_1_0.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_1_0.AuxInt) != 64 {
 				continue
 			}
 			v_1_1_1 := v_1_1.Args[1]
-			if v_1_1_1.Op != OpPPC64ANDconst || v_1_1_1.Type != typ.UInt || v_1_1_1.AuxInt != 63 || y != v_1_1_1.Args[0] {
+			if v_1_1_1.Op != OpPPC64ANDconst || v_1_1_1.Type != typ.UInt || auxIntToInt64(v_1_1_1.AuxInt) != 63 || y != v_1_1_1.Args[0] {
 				continue
 			}
 			v.reset(OpPPC64ROTL)
@@ -3784,7 +3878,7 @@ func rewriteValuePPC64_OpPPC64ADD(v *Value) bool {
 			_ = v_0.Args[1]
 			x := v_0.Args[0]
 			v_0_1 := v_0.Args[1]
-			if v_0_1.Op != OpPPC64ANDconst || v_0_1.Type != typ.Int32 || v_0_1.AuxInt != 31 {
+			if v_0_1.Op != OpPPC64ANDconst || v_0_1.Type != typ.Int32 || auxIntToInt64(v_0_1.AuxInt) != 31 {
 				continue
 			}
 			y := v_0_1.Args[0]
@@ -3801,11 +3895,11 @@ func rewriteValuePPC64_OpPPC64ADD(v *Value) bool {
 			}
 			_ = v_1_1.Args[1]
 			v_1_1_0 := v_1_1.Args[0]
-			if v_1_1_0.Op != OpPPC64MOVDconst || v_1_1_0.AuxInt != 32 {
+			if v_1_1_0.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_1_0.AuxInt) != 32 {
 				continue
 			}
 			v_1_1_1 := v_1_1.Args[1]
-			if v_1_1_1.Op != OpPPC64ANDconst || v_1_1_1.Type != typ.UInt || v_1_1_1.AuxInt != 31 || y != v_1_1_1.Args[0] {
+			if v_1_1_1.Op != OpPPC64ANDconst || v_1_1_1.Type != typ.UInt || auxIntToInt64(v_1_1_1.AuxInt) != 31 || y != v_1_1_1.Args[0] {
 				continue
 			}
 			v.reset(OpPPC64ROTLW)
@@ -3823,12 +3917,12 @@ func rewriteValuePPC64_OpPPC64ADD(v *Value) bool {
 			if v_1.Op != OpPPC64MOVDconst {
 				continue
 			}
-			c := v_1.AuxInt
+			c := auxIntToInt64(v_1.AuxInt)
 			if !(is32Bit(c)) {
 				continue
 			}
 			v.reset(OpPPC64ADDconst)
-			v.AuxInt = c
+			v.AuxInt = int64ToAuxInt(c)
 			v.AddArg(x)
 			return true
 		}
@@ -3842,24 +3936,24 @@ func rewriteValuePPC64_OpPPC64ADDconst(v *Value) bool {
 	// cond: is32Bit(c+d)
 	// result: (ADDconst [c+d] x)
 	for {
-		c := v.AuxInt
+		c := auxIntToInt64(v.AuxInt)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		d := v_0.AuxInt
+		d := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(is32Bit(c + d)) {
 			break
 		}
 		v.reset(OpPPC64ADDconst)
-		v.AuxInt = c + d
+		v.AuxInt = int64ToAuxInt(c + d)
 		v.AddArg(x)
 		return true
 	}
 	// match: (ADDconst [0] x)
 	// result: x
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt64(v.AuxInt) != 0 {
 			break
 		}
 		x := v_0
@@ -3867,18 +3961,22 @@ func rewriteValuePPC64_OpPPC64ADDconst(v *Value) bool {
 		return true
 	}
 	// match: (ADDconst [c] (MOVDaddr [d] {sym} x))
-	// result: (MOVDaddr [c+d] {sym} x)
+	// cond: is32Bit(c+int64(d))
+	// result: (MOVDaddr [int32(c+int64(d))] {sym} x)
 	for {
-		c := v.AuxInt
+		c := auxIntToInt64(v.AuxInt)
 		if v_0.Op != OpPPC64MOVDaddr {
 			break
 		}
-		d := v_0.AuxInt
-		sym := v_0.Aux
+		d := auxIntToInt32(v_0.AuxInt)
+		sym := auxToSym(v_0.Aux)
 		x := v_0.Args[0]
+		if !(is32Bit(c + int64(d))) {
+			break
+		}
 		v.reset(OpPPC64MOVDaddr)
-		v.AuxInt = c + d
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(int32(c + int64(d)))
+		v.Aux = symToAux(sym)
 		v.AddArg(x)
 		return true
 	}
@@ -3887,30 +3985,30 @@ func rewriteValuePPC64_OpPPC64ADDconst(v *Value) bool {
 func rewriteValuePPC64_OpPPC64ADDconstForCarry(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (ADDconstForCarry [c] (MOVDconst [d]))
-	// cond: int64(int16(c)) < 0 && (int64(int16(c)) < 0 || int64(int16(c)) + d >= 0)
+	// cond: c < 0 && (int64(c) < 0 || int64(c) + d >= 0)
 	// result: (FlagCarryClear)
 	for {
-		c := v.AuxInt
+		c := auxIntToInt16(v.AuxInt)
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		d := v_0.AuxInt
-		if !(int64(int16(c)) < 0 && (int64(int16(c)) < 0 || int64(int16(c))+d >= 0)) {
+		d := auxIntToInt64(v_0.AuxInt)
+		if !(c < 0 && (int64(c) < 0 || int64(c)+d >= 0)) {
 			break
 		}
 		v.reset(OpPPC64FlagCarryClear)
 		return true
 	}
 	// match: (ADDconstForCarry [c] (MOVDconst [d]))
-	// cond: int64(int16(c)) < 0 && int64(int16(c)) >= 0 && int64(int16(c)) + d < 0
+	// cond: c < 0 && int64(c) >= 0 && int64(c) + d < 0
 	// result: (FlagCarrySet)
 	for {
-		c := v.AuxInt
+		c := auxIntToInt16(v.AuxInt)
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		d := v_0.AuxInt
-		if !(int64(int16(c)) < 0 && int64(int16(c)) >= 0 && int64(int16(c))+d < 0) {
+		d := auxIntToInt64(v_0.AuxInt)
+		if !(c < 0 && int64(c) >= 0 && int64(c)+d < 0) {
 			break
 		}
 		v.reset(OpPPC64FlagCarrySet)
@@ -3946,13 +4044,13 @@ func rewriteValuePPC64_OpPPC64AND(v *Value) bool {
 			if v_0.Op != OpPPC64MOVDconst {
 				continue
 			}
-			c := v_0.AuxInt
+			c := auxIntToInt64(v_0.AuxInt)
 			if v_1.Op != OpPPC64MOVDconst {
 				continue
 			}
-			d := v_1.AuxInt
+			d := auxIntToInt64(v_1.AuxInt)
 			v.reset(OpPPC64MOVDconst)
-			v.AuxInt = c & d
+			v.AuxInt = int64ToAuxInt(c & d)
 			return true
 		}
 		break
@@ -3966,12 +4064,12 @@ func rewriteValuePPC64_OpPPC64AND(v *Value) bool {
 			if v_1.Op != OpPPC64MOVDconst {
 				continue
 			}
-			c := v_1.AuxInt
+			c := auxIntToInt64(v_1.AuxInt)
 			if !(isU16Bit(c)) {
 				continue
 			}
 			v.reset(OpPPC64ANDconst)
-			v.AuxInt = c
+			v.AuxInt = int64ToAuxInt(c)
 			v.AddArg(x)
 			return true
 		}
@@ -3985,7 +4083,7 @@ func rewriteValuePPC64_OpPPC64AND(v *Value) bool {
 			if v_0.Op != OpPPC64MOVDconst {
 				continue
 			}
-			c := v_0.AuxInt
+			c := auxIntToInt64(v_0.AuxInt)
 			y := v_1
 			if y.Op != OpPPC64MOVWZreg || !(c&0xFFFFFFFF == 0xFFFFFFFF) {
 				continue
@@ -3999,7 +4097,7 @@ func rewriteValuePPC64_OpPPC64AND(v *Value) bool {
 	// result: (MOVWZreg x)
 	for {
 		for _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {
-			if v_0.Op != OpPPC64MOVDconst || v_0.AuxInt != 0xFFFFFFFF {
+			if v_0.Op != OpPPC64MOVDconst || auxIntToInt64(v_0.AuxInt) != 0xFFFFFFFF {
 				continue
 			}
 			y := v_1
@@ -4020,13 +4118,13 @@ func rewriteValuePPC64_OpPPC64AND(v *Value) bool {
 			if v_0.Op != OpPPC64MOVDconst {
 				continue
 			}
-			c := v_0.AuxInt
+			c := auxIntToInt64(v_0.AuxInt)
 			x := v_1
 			if x.Op != OpPPC64MOVBZload {
 				continue
 			}
 			v.reset(OpPPC64ANDconst)
-			v.AuxInt = c & 0xFF
+			v.AuxInt = int64ToAuxInt(c & 0xFF)
 			v.AddArg(x)
 			return true
 		}
@@ -4043,13 +4141,13 @@ func rewriteValuePPC64_OpPPC64ANDN(v *Value) bool {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		d := v_1.AuxInt
+		d := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = c &^ d
+		v.AuxInt = int64ToAuxInt(c &^ d)
 		return true
 	}
 	return false
@@ -4059,21 +4157,21 @@ func rewriteValuePPC64_OpPPC64ANDconst(v *Value) bool {
 	// match: (ANDconst [c] (ANDconst [d] x))
 	// result: (ANDconst [c&d] x)
 	for {
-		c := v.AuxInt
+		c := auxIntToInt64(v.AuxInt)
 		if v_0.Op != OpPPC64ANDconst {
 			break
 		}
-		d := v_0.AuxInt
+		d := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		v.reset(OpPPC64ANDconst)
-		v.AuxInt = c & d
+		v.AuxInt = int64ToAuxInt(c & d)
 		v.AddArg(x)
 		return true
 	}
 	// match: (ANDconst [-1] x)
 	// result: x
 	for {
-		if v.AuxInt != -1 {
+		if auxIntToInt64(v.AuxInt) != -1 {
 			break
 		}
 		x := v_0
@@ -4083,18 +4181,18 @@ func rewriteValuePPC64_OpPPC64ANDconst(v *Value) bool {
 	// match: (ANDconst [0] _)
 	// result: (MOVDconst [0])
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt64(v.AuxInt) != 0 {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (ANDconst [c] y:(MOVBZreg _))
 	// cond: c&0xFF == 0xFF
 	// result: y
 	for {
-		c := v.AuxInt
+		c := auxIntToInt64(v.AuxInt)
 		y := v_0
 		if y.Op != OpPPC64MOVBZreg || !(c&0xFF == 0xFF) {
 			break
@@ -4105,7 +4203,7 @@ func rewriteValuePPC64_OpPPC64ANDconst(v *Value) bool {
 	// match: (ANDconst [0xFF] y:(MOVBreg _))
 	// result: y
 	for {
-		if v.AuxInt != 0xFF {
+		if auxIntToInt64(v.AuxInt) != 0xFF {
 			break
 		}
 		y := v_0
@@ -4119,7 +4217,7 @@ func rewriteValuePPC64_OpPPC64ANDconst(v *Value) bool {
 	// cond: c&0xFFFF == 0xFFFF
 	// result: y
 	for {
-		c := v.AuxInt
+		c := auxIntToInt64(v.AuxInt)
 		y := v_0
 		if y.Op != OpPPC64MOVHZreg || !(c&0xFFFF == 0xFFFF) {
 			break
@@ -4130,7 +4228,7 @@ func rewriteValuePPC64_OpPPC64ANDconst(v *Value) bool {
 	// match: (ANDconst [0xFFFF] y:(MOVHreg _))
 	// result: y
 	for {
-		if v.AuxInt != 0xFFFF {
+		if auxIntToInt64(v.AuxInt) != 0xFFFF {
 			break
 		}
 		y := v_0
@@ -4143,78 +4241,78 @@ func rewriteValuePPC64_OpPPC64ANDconst(v *Value) bool {
 	// match: (ANDconst [c] (MOVBreg x))
 	// result: (ANDconst [c&0xFF] x)
 	for {
-		c := v.AuxInt
+		c := auxIntToInt64(v.AuxInt)
 		if v_0.Op != OpPPC64MOVBreg {
 			break
 		}
 		x := v_0.Args[0]
 		v.reset(OpPPC64ANDconst)
-		v.AuxInt = c & 0xFF
+		v.AuxInt = int64ToAuxInt(c & 0xFF)
 		v.AddArg(x)
 		return true
 	}
 	// match: (ANDconst [c] (MOVBZreg x))
 	// result: (ANDconst [c&0xFF] x)
 	for {
-		c := v.AuxInt
+		c := auxIntToInt64(v.AuxInt)
 		if v_0.Op != OpPPC64MOVBZreg {
 			break
 		}
 		x := v_0.Args[0]
 		v.reset(OpPPC64ANDconst)
-		v.AuxInt = c & 0xFF
+		v.AuxInt = int64ToAuxInt(c & 0xFF)
 		v.AddArg(x)
 		return true
 	}
 	// match: (ANDconst [c] (MOVHreg x))
 	// result: (ANDconst [c&0xFFFF] x)
 	for {
-		c := v.AuxInt
+		c := auxIntToInt64(v.AuxInt)
 		if v_0.Op != OpPPC64MOVHreg {
 			break
 		}
 		x := v_0.Args[0]
 		v.reset(OpPPC64ANDconst)
-		v.AuxInt = c & 0xFFFF
+		v.AuxInt = int64ToAuxInt(c & 0xFFFF)
 		v.AddArg(x)
 		return true
 	}
 	// match: (ANDconst [c] (MOVHZreg x))
 	// result: (ANDconst [c&0xFFFF] x)
 	for {
-		c := v.AuxInt
+		c := auxIntToInt64(v.AuxInt)
 		if v_0.Op != OpPPC64MOVHZreg {
 			break
 		}
 		x := v_0.Args[0]
 		v.reset(OpPPC64ANDconst)
-		v.AuxInt = c & 0xFFFF
+		v.AuxInt = int64ToAuxInt(c & 0xFFFF)
 		v.AddArg(x)
 		return true
 	}
 	// match: (ANDconst [c] (MOVWreg x))
 	// result: (ANDconst [c&0xFFFFFFFF] x)
 	for {
-		c := v.AuxInt
+		c := auxIntToInt64(v.AuxInt)
 		if v_0.Op != OpPPC64MOVWreg {
 			break
 		}
 		x := v_0.Args[0]
 		v.reset(OpPPC64ANDconst)
-		v.AuxInt = c & 0xFFFFFFFF
+		v.AuxInt = int64ToAuxInt(c & 0xFFFFFFFF)
 		v.AddArg(x)
 		return true
 	}
 	// match: (ANDconst [c] (MOVWZreg x))
 	// result: (ANDconst [c&0xFFFFFFFF] x)
 	for {
-		c := v.AuxInt
+		c := auxIntToInt64(v.AuxInt)
 		if v_0.Op != OpPPC64MOVWZreg {
 			break
 		}
 		x := v_0.Args[0]
 		v.reset(OpPPC64ANDconst)
-		v.AuxInt = c & 0xFFFFFFFF
+		v.AuxInt = int64ToAuxInt(c & 0xFFFFFFFF)
 		v.AddArg(x)
 		return true
 	}
@@ -4232,12 +4330,12 @@ func rewriteValuePPC64_OpPPC64CMP(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(is16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64CMPconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -4248,14 +4346,14 @@ func rewriteValuePPC64_OpPPC64CMP(v *Value) bool {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		y := v_1
 		if !(is16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64InvertFlags)
 		v0 := b.NewValue0(v.Pos, OpPPC64CMPconst, types.TypeFlags)
-		v0.AuxInt = c
+		v0.AuxInt = int64ToAuxInt(c)
 		v0.AddArg(y)
 		v.AddArg(v0)
 		return true
@@ -4289,12 +4387,12 @@ func rewriteValuePPC64_OpPPC64CMPU(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(isU16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64CMPUconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -4305,14 +4403,14 @@ func rewriteValuePPC64_OpPPC64CMPU(v *Value) bool {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		y := v_1
 		if !(isU16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64InvertFlags)
 		v0 := b.NewValue0(v.Pos, OpPPC64CMPUconst, types.TypeFlags)
-		v0.AuxInt = c
+		v0.AuxInt = int64ToAuxInt(c)
 		v0.AddArg(y)
 		v.AddArg(v0)
 		return true
@@ -4340,11 +4438,11 @@ func rewriteValuePPC64_OpPPC64CMPUconst(v *Value) bool {
 	// cond: x==y
 	// result: (FlagEQ)
 	for {
-		y := v.AuxInt
+		y := auxIntToInt64(v.AuxInt)
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		x := v_0.AuxInt
+		x := auxIntToInt64(v_0.AuxInt)
 		if !(x == y) {
 			break
 		}
@@ -4355,11 +4453,11 @@ func rewriteValuePPC64_OpPPC64CMPUconst(v *Value) bool {
 	// cond: uint64(x)<uint64(y)
 	// result: (FlagLT)
 	for {
-		y := v.AuxInt
+		y := auxIntToInt64(v.AuxInt)
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		x := v_0.AuxInt
+		x := auxIntToInt64(v_0.AuxInt)
 		if !(uint64(x) < uint64(y)) {
 			break
 		}
@@ -4370,11 +4468,11 @@ func rewriteValuePPC64_OpPPC64CMPUconst(v *Value) bool {
 	// cond: uint64(x)>uint64(y)
 	// result: (FlagGT)
 	for {
-		y := v.AuxInt
+		y := auxIntToInt64(v.AuxInt)
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		x := v_0.AuxInt
+		x := auxIntToInt64(v_0.AuxInt)
 		if !(uint64(x) > uint64(y)) {
 			break
 		}
@@ -4413,36 +4511,36 @@ func rewriteValuePPC64_OpPPC64CMPW(v *Value) bool {
 	}
 	// match: (CMPW x (MOVDconst [c]))
 	// cond: is16Bit(c)
-	// result: (CMPWconst x [c])
+	// result: (CMPWconst x [int32(c)])
 	for {
 		x := v_0
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(is16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64CMPWconst)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg(x)
 		return true
 	}
 	// match: (CMPW (MOVDconst [c]) y)
 	// cond: is16Bit(c)
-	// result: (InvertFlags (CMPWconst y [c]))
+	// result: (InvertFlags (CMPWconst y [int32(c)]))
 	for {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		y := v_1
 		if !(is16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64InvertFlags)
 		v0 := b.NewValue0(v.Pos, OpPPC64CMPWconst, types.TypeFlags)
-		v0.AuxInt = c
+		v0.AuxInt = int32ToAuxInt(int32(c))
 		v0.AddArg(y)
 		v.AddArg(v0)
 		return true
@@ -4494,36 +4592,36 @@ func rewriteValuePPC64_OpPPC64CMPWU(v *Value) bool {
 	}
 	// match: (CMPWU x (MOVDconst [c]))
 	// cond: isU16Bit(c)
-	// result: (CMPWUconst x [c])
+	// result: (CMPWUconst x [int32(c)])
 	for {
 		x := v_0
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(isU16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64CMPWUconst)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg(x)
 		return true
 	}
 	// match: (CMPWU (MOVDconst [c]) y)
 	// cond: isU16Bit(c)
-	// result: (InvertFlags (CMPWUconst y [c]))
+	// result: (InvertFlags (CMPWUconst y [int32(c)]))
 	for {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		y := v_1
 		if !(isU16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64InvertFlags)
 		v0 := b.NewValue0(v.Pos, OpPPC64CMPWUconst, types.TypeFlags)
-		v0.AuxInt = c
+		v0.AuxInt = int32ToAuxInt(int32(c))
 		v0.AddArg(y)
 		v.AddArg(v0)
 		return true
@@ -4551,11 +4649,11 @@ func rewriteValuePPC64_OpPPC64CMPWUconst(v *Value) bool {
 	// cond: int32(x)==int32(y)
 	// result: (FlagEQ)
 	for {
-		y := v.AuxInt
+		y := auxIntToInt32(v.AuxInt)
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		x := v_0.AuxInt
+		x := auxIntToInt64(v_0.AuxInt)
 		if !(int32(x) == int32(y)) {
 			break
 		}
@@ -4566,11 +4664,11 @@ func rewriteValuePPC64_OpPPC64CMPWUconst(v *Value) bool {
 	// cond: uint32(x)<uint32(y)
 	// result: (FlagLT)
 	for {
-		y := v.AuxInt
+		y := auxIntToInt32(v.AuxInt)
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		x := v_0.AuxInt
+		x := auxIntToInt64(v_0.AuxInt)
 		if !(uint32(x) < uint32(y)) {
 			break
 		}
@@ -4581,11 +4679,11 @@ func rewriteValuePPC64_OpPPC64CMPWUconst(v *Value) bool {
 	// cond: uint32(x)>uint32(y)
 	// result: (FlagGT)
 	for {
-		y := v.AuxInt
+		y := auxIntToInt32(v.AuxInt)
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		x := v_0.AuxInt
+		x := auxIntToInt64(v_0.AuxInt)
 		if !(uint32(x) > uint32(y)) {
 			break
 		}
@@ -4600,11 +4698,11 @@ func rewriteValuePPC64_OpPPC64CMPWconst(v *Value) bool {
 	// cond: int32(x)==int32(y)
 	// result: (FlagEQ)
 	for {
-		y := v.AuxInt
+		y := auxIntToInt32(v.AuxInt)
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		x := v_0.AuxInt
+		x := auxIntToInt64(v_0.AuxInt)
 		if !(int32(x) == int32(y)) {
 			break
 		}
@@ -4615,11 +4713,11 @@ func rewriteValuePPC64_OpPPC64CMPWconst(v *Value) bool {
 	// cond: int32(x)<int32(y)
 	// result: (FlagLT)
 	for {
-		y := v.AuxInt
+		y := auxIntToInt32(v.AuxInt)
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		x := v_0.AuxInt
+		x := auxIntToInt64(v_0.AuxInt)
 		if !(int32(x) < int32(y)) {
 			break
 		}
@@ -4630,11 +4728,11 @@ func rewriteValuePPC64_OpPPC64CMPWconst(v *Value) bool {
 	// cond: int32(x)>int32(y)
 	// result: (FlagGT)
 	for {
-		y := v.AuxInt
+		y := auxIntToInt32(v.AuxInt)
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		x := v_0.AuxInt
+		x := auxIntToInt64(v_0.AuxInt)
 		if !(int32(x) > int32(y)) {
 			break
 		}
@@ -4649,11 +4747,11 @@ func rewriteValuePPC64_OpPPC64CMPconst(v *Value) bool {
 	// cond: x==y
 	// result: (FlagEQ)
 	for {
-		y := v.AuxInt
+		y := auxIntToInt64(v.AuxInt)
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		x := v_0.AuxInt
+		x := auxIntToInt64(v_0.AuxInt)
 		if !(x == y) {
 			break
 		}
@@ -4664,11 +4762,11 @@ func rewriteValuePPC64_OpPPC64CMPconst(v *Value) bool {
 	// cond: x<y
 	// result: (FlagLT)
 	for {
-		y := v.AuxInt
+		y := auxIntToInt64(v.AuxInt)
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		x := v_0.AuxInt
+		x := auxIntToInt64(v_0.AuxInt)
 		if !(x < y) {
 			break
 		}
@@ -4679,11 +4777,11 @@ func rewriteValuePPC64_OpPPC64CMPconst(v *Value) bool {
 	// cond: x>y
 	// result: (FlagGT)
 	for {
-		y := v.AuxInt
+		y := auxIntToInt64(v.AuxInt)
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		x := v_0.AuxInt
+		x := auxIntToInt64(v_0.AuxInt)
 		if !(x > y) {
 			break
 		}
@@ -4703,7 +4801,7 @@ func rewriteValuePPC64_OpPPC64Equal(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		return true
 	}
 	// match: (Equal (FlagLT))
@@ -4713,7 +4811,7 @@ func rewriteValuePPC64_OpPPC64Equal(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (Equal (FlagGT))
@@ -4723,7 +4821,7 @@ func rewriteValuePPC64_OpPPC64Equal(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (Equal (InvertFlags x))
@@ -4742,9 +4840,9 @@ func rewriteValuePPC64_OpPPC64Equal(v *Value) bool {
 	for {
 		cmp := v_0
 		v.reset(OpPPC64ISELB)
-		v.AuxInt = 2
+		v.AuxInt = int32ToAuxInt(2)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v0.AuxInt = 1
+		v0.AuxInt = int64ToAuxInt(1)
 		v.AddArg2(v0, cmp)
 		return true
 	}
@@ -4752,14 +4850,14 @@ func rewriteValuePPC64_OpPPC64Equal(v *Value) bool {
 func rewriteValuePPC64_OpPPC64FABS(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (FABS (FMOVDconst [x]))
-	// result: (FMOVDconst [auxFrom64F(math.Abs(auxTo64F(x)))])
+	// result: (FMOVDconst [math.Abs(x)])
 	for {
 		if v_0.Op != OpPPC64FMOVDconst {
 			break
 		}
-		x := v_0.AuxInt
+		x := auxIntToFloat64(v_0.AuxInt)
 		v.reset(OpPPC64FMOVDconst)
-		v.AuxInt = auxFrom64F(math.Abs(auxTo64F(x)))
+		v.AuxInt = float64ToAuxInt(math.Abs(x))
 		return true
 	}
 	return false
@@ -4809,14 +4907,14 @@ func rewriteValuePPC64_OpPPC64FADDS(v *Value) bool {
 func rewriteValuePPC64_OpPPC64FCEIL(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (FCEIL (FMOVDconst [x]))
-	// result: (FMOVDconst [auxFrom64F(math.Ceil(auxTo64F(x)))])
+	// result: (FMOVDconst [math.Ceil(x)])
 	for {
 		if v_0.Op != OpPPC64FMOVDconst {
 			break
 		}
-		x := v_0.AuxInt
+		x := auxIntToFloat64(v_0.AuxInt)
 		v.reset(OpPPC64FMOVDconst)
-		v.AuxInt = auxFrom64F(math.Ceil(auxTo64F(x)))
+		v.AuxInt = float64ToAuxInt(math.Ceil(x))
 		return true
 	}
 	return false
@@ -4824,14 +4922,14 @@ func rewriteValuePPC64_OpPPC64FCEIL(v *Value) bool {
 func rewriteValuePPC64_OpPPC64FFLOOR(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (FFLOOR (FMOVDconst [x]))
-	// result: (FMOVDconst [auxFrom64F(math.Floor(auxTo64F(x)))])
+	// result: (FMOVDconst [math.Floor(x)])
 	for {
 		if v_0.Op != OpPPC64FMOVDconst {
 			break
 		}
-		x := v_0.AuxInt
+		x := auxIntToFloat64(v_0.AuxInt)
 		v.reset(OpPPC64FMOVDconst)
-		v.AuxInt = auxFrom64F(math.Floor(auxTo64F(x)))
+		v.AuxInt = float64ToAuxInt(math.Floor(x))
 		return true
 	}
 	return false
@@ -4845,13 +4943,13 @@ func rewriteValuePPC64_OpPPC64FGreaterEqual(v *Value) bool {
 	for {
 		cmp := v_0
 		v.reset(OpPPC64ISEL)
-		v.AuxInt = 2
+		v.AuxInt = int32ToAuxInt(2)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v0.AuxInt = 1
+		v0.AuxInt = int64ToAuxInt(1)
 		v1 := b.NewValue0(v.Pos, OpPPC64ISELB, typ.Int32)
-		v1.AuxInt = 1
+		v1.AuxInt = int32ToAuxInt(1)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v2.AuxInt = 1
+		v2.AuxInt = int64ToAuxInt(1)
 		v1.AddArg2(v2, cmp)
 		v.AddArg3(v0, v1, cmp)
 		return true
@@ -4866,9 +4964,9 @@ func rewriteValuePPC64_OpPPC64FGreaterThan(v *Value) bool {
 	for {
 		cmp := v_0
 		v.reset(OpPPC64ISELB)
-		v.AuxInt = 1
+		v.AuxInt = int32ToAuxInt(1)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v0.AuxInt = 1
+		v0.AuxInt = int64ToAuxInt(1)
 		v.AddArg2(v0, cmp)
 		return true
 	}
@@ -4882,13 +4980,13 @@ func rewriteValuePPC64_OpPPC64FLessEqual(v *Value) bool {
 	for {
 		cmp := v_0
 		v.reset(OpPPC64ISEL)
-		v.AuxInt = 2
+		v.AuxInt = int32ToAuxInt(2)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v0.AuxInt = 1
+		v0.AuxInt = int64ToAuxInt(1)
 		v1 := b.NewValue0(v.Pos, OpPPC64ISELB, typ.Int32)
-		v1.AuxInt = 0
+		v1.AuxInt = int32ToAuxInt(0)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v2.AuxInt = 1
+		v2.AuxInt = int64ToAuxInt(1)
 		v1.AddArg2(v2, cmp)
 		v.AddArg3(v0, v1, cmp)
 		return true
@@ -4903,9 +5001,9 @@ func rewriteValuePPC64_OpPPC64FLessThan(v *Value) bool {
 	for {
 		cmp := v_0
 		v.reset(OpPPC64ISELB)
-		v.AuxInt = 0
+		v.AuxInt = int32ToAuxInt(0)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v0.AuxInt = 1
+		v0.AuxInt = int64ToAuxInt(1)
 		v.AddArg2(v0, cmp)
 		return true
 	}
@@ -4916,10 +5014,10 @@ func rewriteValuePPC64_OpPPC64FMOVDload(v *Value) bool {
 	// match: (FMOVDload [off] {sym} ptr (MOVDstore [off] {sym} ptr x _))
 	// result: (MTVSRD x)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
-		if v_1.Op != OpPPC64MOVDstore || v_1.AuxInt != off || v_1.Aux != sym {
+		if v_1.Op != OpPPC64MOVDstore || auxIntToInt32(v_1.AuxInt) != off || auxToSym(v_1.Aux) != sym {
 			break
 		}
 		x := v_1.Args[1]
@@ -4932,45 +5030,45 @@ func rewriteValuePPC64_OpPPC64FMOVDload(v *Value) bool {
 	}
 	// match: (FMOVDload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
 	// cond: canMergeSym(sym1,sym2) && (ptr.Op != OpSB || p.Uses == 1)
-	// result: (FMOVDload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
+	// result: (FMOVDload [off1+off2] {mergeSymTyped(sym1,sym2)} ptr mem)
 	for {
-		off1 := v.AuxInt
-		sym1 := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64MOVDaddr {
 			break
 		}
-		off2 := p.AuxInt
-		sym2 := p.Aux
+		off2 := auxIntToInt32(p.AuxInt)
+		sym2 := auxToSym(p.Aux)
 		ptr := p.Args[0]
 		mem := v_1
 		if !(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1)) {
 			break
 		}
 		v.reset(OpPPC64FMOVDload)
-		v.AuxInt = off1 + off2
-		v.Aux = mergeSym(sym1, sym2)
+		v.AuxInt = int32ToAuxInt(off1 + off2)
+		v.Aux = symToAux(mergeSymTyped(sym1, sym2))
 		v.AddArg2(ptr, mem)
 		return true
 	}
 	// match: (FMOVDload [off1] {sym} (ADDconst [off2] ptr) mem)
-	// cond: is16Bit(off1+off2)
-	// result: (FMOVDload [off1+off2] {sym} ptr mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (FMOVDload [off1+int32(off2)] {sym} ptr mem)
 	for {
-		off1 := v.AuxInt
-		sym := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		off2 := v_0.AuxInt
+		off2 := auxIntToInt64(v_0.AuxInt)
 		ptr := v_0.Args[0]
 		mem := v_1
-		if !(is16Bit(off1 + off2)) {
+		if !(is16Bit(int64(off1) + off2)) {
 			break
 		}
 		v.reset(OpPPC64FMOVDload)
-		v.AuxInt = off1 + off2
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -4983,8 +5081,8 @@ func rewriteValuePPC64_OpPPC64FMOVDstore(v *Value) bool {
 	// match: (FMOVDstore [off] {sym} ptr (MTVSRD x) mem)
 	// result: (MOVDstore [off] {sym} ptr x mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MTVSRD {
 			break
@@ -4992,45 +5090,45 @@ func rewriteValuePPC64_OpPPC64FMOVDstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVDstore)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
 	// match: (FMOVDstore [off1] {sym} (ADDconst [off2] ptr) val mem)
-	// cond: is16Bit(off1+off2)
-	// result: (FMOVDstore [off1+off2] {sym} ptr val mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (FMOVDstore [off1+int32(off2)] {sym} ptr val mem)
 	for {
-		off1 := v.AuxInt
-		sym := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		off2 := v_0.AuxInt
+		off2 := auxIntToInt64(v_0.AuxInt)
 		ptr := v_0.Args[0]
 		val := v_1
 		mem := v_2
-		if !(is16Bit(off1 + off2)) {
+		if !(is16Bit(int64(off1) + off2)) {
 			break
 		}
 		v.reset(OpPPC64FMOVDstore)
-		v.AuxInt = off1 + off2
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
 	// match: (FMOVDstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem)
 	// cond: canMergeSym(sym1,sym2) && (ptr.Op != OpSB || p.Uses == 1)
-	// result: (FMOVDstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
+	// result: (FMOVDstore [off1+off2] {mergeSymTyped(sym1,sym2)} ptr val mem)
 	for {
-		off1 := v.AuxInt
-		sym1 := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64MOVDaddr {
 			break
 		}
-		off2 := p.AuxInt
-		sym2 := p.Aux
+		off2 := auxIntToInt32(p.AuxInt)
+		sym2 := auxToSym(p.Aux)
 		ptr := p.Args[0]
 		val := v_1
 		mem := v_2
@@ -5038,8 +5136,8 @@ func rewriteValuePPC64_OpPPC64FMOVDstore(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64FMOVDstore)
-		v.AuxInt = off1 + off2
-		v.Aux = mergeSym(sym1, sym2)
+		v.AuxInt = int32ToAuxInt(off1 + off2)
+		v.Aux = symToAux(mergeSymTyped(sym1, sym2))
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
@@ -5050,45 +5148,45 @@ func rewriteValuePPC64_OpPPC64FMOVSload(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (FMOVSload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
 	// cond: canMergeSym(sym1,sym2) && (ptr.Op != OpSB || p.Uses == 1)
-	// result: (FMOVSload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
+	// result: (FMOVSload [off1+off2] {mergeSymTyped(sym1,sym2)} ptr mem)
 	for {
-		off1 := v.AuxInt
-		sym1 := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64MOVDaddr {
 			break
 		}
-		off2 := p.AuxInt
-		sym2 := p.Aux
+		off2 := auxIntToInt32(p.AuxInt)
+		sym2 := auxToSym(p.Aux)
 		ptr := p.Args[0]
 		mem := v_1
 		if !(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1)) {
 			break
 		}
 		v.reset(OpPPC64FMOVSload)
-		v.AuxInt = off1 + off2
-		v.Aux = mergeSym(sym1, sym2)
+		v.AuxInt = int32ToAuxInt(off1 + off2)
+		v.Aux = symToAux(mergeSymTyped(sym1, sym2))
 		v.AddArg2(ptr, mem)
 		return true
 	}
 	// match: (FMOVSload [off1] {sym} (ADDconst [off2] ptr) mem)
-	// cond: is16Bit(off1+off2)
-	// result: (FMOVSload [off1+off2] {sym} ptr mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (FMOVSload [off1+int32(off2)] {sym} ptr mem)
 	for {
-		off1 := v.AuxInt
-		sym := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		off2 := v_0.AuxInt
+		off2 := auxIntToInt64(v_0.AuxInt)
 		ptr := v_0.Args[0]
 		mem := v_1
-		if !(is16Bit(off1 + off2)) {
+		if !(is16Bit(int64(off1) + off2)) {
 			break
 		}
 		v.reset(OpPPC64FMOVSload)
-		v.AuxInt = off1 + off2
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -5099,39 +5197,39 @@ func rewriteValuePPC64_OpPPC64FMOVSstore(v *Value) bool {
 	v_1 := v.Args[1]
 	v_0 := v.Args[0]
 	// match: (FMOVSstore [off1] {sym} (ADDconst [off2] ptr) val mem)
-	// cond: is16Bit(off1+off2)
-	// result: (FMOVSstore [off1+off2] {sym} ptr val mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (FMOVSstore [off1+int32(off2)] {sym} ptr val mem)
 	for {
-		off1 := v.AuxInt
-		sym := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		off2 := v_0.AuxInt
+		off2 := auxIntToInt64(v_0.AuxInt)
 		ptr := v_0.Args[0]
 		val := v_1
 		mem := v_2
-		if !(is16Bit(off1 + off2)) {
+		if !(is16Bit(int64(off1) + off2)) {
 			break
 		}
 		v.reset(OpPPC64FMOVSstore)
-		v.AuxInt = off1 + off2
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
 	// match: (FMOVSstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem)
 	// cond: canMergeSym(sym1,sym2) && (ptr.Op != OpSB || p.Uses == 1)
-	// result: (FMOVSstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
+	// result: (FMOVSstore [off1+off2] {mergeSymTyped(sym1,sym2)} ptr val mem)
 	for {
-		off1 := v.AuxInt
-		sym1 := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64MOVDaddr {
 			break
 		}
-		off2 := p.AuxInt
-		sym2 := p.Aux
+		off2 := auxIntToInt32(p.AuxInt)
+		sym2 := auxToSym(p.Aux)
 		ptr := p.Args[0]
 		val := v_1
 		mem := v_2
@@ -5139,8 +5237,8 @@ func rewriteValuePPC64_OpPPC64FMOVSstore(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64FMOVSstore)
-		v.AuxInt = off1 + off2
-		v.Aux = mergeSym(sym1, sym2)
+		v.AuxInt = int32ToAuxInt(off1 + off2)
+		v.Aux = symToAux(mergeSymTyped(sym1, sym2))
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
@@ -5175,18 +5273,18 @@ func rewriteValuePPC64_OpPPC64FNEG(v *Value) bool {
 func rewriteValuePPC64_OpPPC64FSQRT(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (FSQRT (FMOVDconst [x]))
-	// cond: auxTo64F(x) >= 0
-	// result: (FMOVDconst [auxFrom64F(math.Sqrt(auxTo64F(x)))])
+	// cond: x >= 0
+	// result: (FMOVDconst [math.Sqrt(x)])
 	for {
 		if v_0.Op != OpPPC64FMOVDconst {
 			break
 		}
-		x := v_0.AuxInt
-		if !(auxTo64F(x) >= 0) {
+		x := auxIntToFloat64(v_0.AuxInt)
+		if !(x >= 0) {
 			break
 		}
 		v.reset(OpPPC64FMOVDconst)
-		v.AuxInt = auxFrom64F(math.Sqrt(auxTo64F(x)))
+		v.AuxInt = float64ToAuxInt(math.Sqrt(x))
 		return true
 	}
 	return false
@@ -5230,14 +5328,14 @@ func rewriteValuePPC64_OpPPC64FSUBS(v *Value) bool {
 func rewriteValuePPC64_OpPPC64FTRUNC(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (FTRUNC (FMOVDconst [x]))
-	// result: (FMOVDconst [auxFrom64F(math.Trunc(auxTo64F(x)))])
+	// result: (FMOVDconst [math.Trunc(x)])
 	for {
 		if v_0.Op != OpPPC64FMOVDconst {
 			break
 		}
-		x := v_0.AuxInt
+		x := auxIntToFloat64(v_0.AuxInt)
 		v.reset(OpPPC64FMOVDconst)
-		v.AuxInt = auxFrom64F(math.Trunc(auxTo64F(x)))
+		v.AuxInt = float64ToAuxInt(math.Trunc(x))
 		return true
 	}
 	return false
@@ -5253,7 +5351,7 @@ func rewriteValuePPC64_OpPPC64GreaterEqual(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		return true
 	}
 	// match: (GreaterEqual (FlagLT))
@@ -5263,7 +5361,7 @@ func rewriteValuePPC64_OpPPC64GreaterEqual(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (GreaterEqual (FlagGT))
@@ -5273,7 +5371,7 @@ func rewriteValuePPC64_OpPPC64GreaterEqual(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		return true
 	}
 	// match: (GreaterEqual (InvertFlags x))
@@ -5292,9 +5390,9 @@ func rewriteValuePPC64_OpPPC64GreaterEqual(v *Value) bool {
 	for {
 		cmp := v_0
 		v.reset(OpPPC64ISELB)
-		v.AuxInt = 4
+		v.AuxInt = int32ToAuxInt(4)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v0.AuxInt = 1
+		v0.AuxInt = int64ToAuxInt(1)
 		v.AddArg2(v0, cmp)
 		return true
 	}
@@ -5310,7 +5408,7 @@ func rewriteValuePPC64_OpPPC64GreaterThan(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (GreaterThan (FlagLT))
@@ -5320,7 +5418,7 @@ func rewriteValuePPC64_OpPPC64GreaterThan(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (GreaterThan (FlagGT))
@@ -5330,7 +5428,7 @@ func rewriteValuePPC64_OpPPC64GreaterThan(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		return true
 	}
 	// match: (GreaterThan (InvertFlags x))
@@ -5349,9 +5447,9 @@ func rewriteValuePPC64_OpPPC64GreaterThan(v *Value) bool {
 	for {
 		cmp := v_0
 		v.reset(OpPPC64ISELB)
-		v.AuxInt = 1
+		v.AuxInt = int32ToAuxInt(1)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v0.AuxInt = 1
+		v0.AuxInt = int64ToAuxInt(1)
 		v.AddArg2(v0, cmp)
 		return true
 	}
@@ -5364,29 +5462,29 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// cond: c >= d
 	// result: (ANDconst [d] y)
 	for {
-		if v.AuxInt != 0 || v_0.Op != OpPPC64ANDconst {
+		if auxIntToInt32(v.AuxInt) != 0 || v_0.Op != OpPPC64ANDconst {
 			break
 		}
-		d := v_0.AuxInt
+		d := auxIntToInt64(v_0.AuxInt)
 		y := v_0.Args[0]
-		if v_1.Op != OpPPC64MOVDconst || v_1.AuxInt != -1 || v_2.Op != OpPPC64CMPU {
+		if v_1.Op != OpPPC64MOVDconst || auxIntToInt64(v_1.AuxInt) != -1 || v_2.Op != OpPPC64CMPU {
 			break
 		}
 		_ = v_2.Args[1]
 		v_2_0 := v_2.Args[0]
-		if v_2_0.Op != OpPPC64ANDconst || v_2_0.AuxInt != d || y != v_2_0.Args[0] {
+		if v_2_0.Op != OpPPC64ANDconst || auxIntToInt64(v_2_0.AuxInt) != d || y != v_2_0.Args[0] {
 			break
 		}
 		v_2_1 := v_2.Args[1]
 		if v_2_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_2_1.AuxInt
+		c := auxIntToInt64(v_2_1.AuxInt)
 		if !(c >= d) {
 			break
 		}
 		v.reset(OpPPC64ANDconst)
-		v.AuxInt = d
+		v.AuxInt = int64ToAuxInt(d)
 		v.AddArg(y)
 		return true
 	}
@@ -5394,28 +5492,28 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// cond: c >= d
 	// result: (ANDconst [d] y)
 	for {
-		if v.AuxInt != 0 || v_0.Op != OpPPC64ANDconst {
+		if auxIntToInt32(v.AuxInt) != 0 || v_0.Op != OpPPC64ANDconst {
 			break
 		}
-		d := v_0.AuxInt
+		d := auxIntToInt64(v_0.AuxInt)
 		y := v_0.Args[0]
-		if v_1.Op != OpPPC64MOVDconst || v_1.AuxInt != -1 || v_2.Op != OpPPC64CMPUconst {
+		if v_1.Op != OpPPC64MOVDconst || auxIntToInt64(v_1.AuxInt) != -1 || v_2.Op != OpPPC64CMPUconst {
 			break
 		}
-		c := v_2.AuxInt
+		c := auxIntToInt64(v_2.AuxInt)
 		v_2_0 := v_2.Args[0]
-		if v_2_0.Op != OpPPC64ANDconst || v_2_0.AuxInt != d || y != v_2_0.Args[0] || !(c >= d) {
+		if v_2_0.Op != OpPPC64ANDconst || auxIntToInt64(v_2_0.AuxInt) != d || y != v_2_0.Args[0] || !(c >= d) {
 			break
 		}
 		v.reset(OpPPC64ANDconst)
-		v.AuxInt = d
+		v.AuxInt = int64ToAuxInt(d)
 		v.AddArg(y)
 		return true
 	}
 	// match: (ISEL [2] x _ (FlagEQ))
 	// result: x
 	for {
-		if v.AuxInt != 2 {
+		if auxIntToInt32(v.AuxInt) != 2 {
 			break
 		}
 		x := v_0
@@ -5428,7 +5526,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// match: (ISEL [2] _ y (FlagLT))
 	// result: y
 	for {
-		if v.AuxInt != 2 {
+		if auxIntToInt32(v.AuxInt) != 2 {
 			break
 		}
 		y := v_1
@@ -5441,7 +5539,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// match: (ISEL [2] _ y (FlagGT))
 	// result: y
 	for {
-		if v.AuxInt != 2 {
+		if auxIntToInt32(v.AuxInt) != 2 {
 			break
 		}
 		y := v_1
@@ -5454,7 +5552,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// match: (ISEL [6] _ y (FlagEQ))
 	// result: y
 	for {
-		if v.AuxInt != 6 {
+		if auxIntToInt32(v.AuxInt) != 6 {
 			break
 		}
 		y := v_1
@@ -5467,7 +5565,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// match: (ISEL [6] x _ (FlagLT))
 	// result: x
 	for {
-		if v.AuxInt != 6 {
+		if auxIntToInt32(v.AuxInt) != 6 {
 			break
 		}
 		x := v_0
@@ -5480,7 +5578,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// match: (ISEL [6] x _ (FlagGT))
 	// result: x
 	for {
-		if v.AuxInt != 6 {
+		if auxIntToInt32(v.AuxInt) != 6 {
 			break
 		}
 		x := v_0
@@ -5493,7 +5591,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// match: (ISEL [0] _ y (FlagEQ))
 	// result: y
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt32(v.AuxInt) != 0 {
 			break
 		}
 		y := v_1
@@ -5506,7 +5604,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// match: (ISEL [0] _ y (FlagGT))
 	// result: y
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt32(v.AuxInt) != 0 {
 			break
 		}
 		y := v_1
@@ -5519,7 +5617,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// match: (ISEL [0] x _ (FlagLT))
 	// result: x
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt32(v.AuxInt) != 0 {
 			break
 		}
 		x := v_0
@@ -5532,7 +5630,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// match: (ISEL [5] _ x (FlagEQ))
 	// result: x
 	for {
-		if v.AuxInt != 5 {
+		if auxIntToInt32(v.AuxInt) != 5 {
 			break
 		}
 		x := v_1
@@ -5545,7 +5643,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// match: (ISEL [5] _ x (FlagLT))
 	// result: x
 	for {
-		if v.AuxInt != 5 {
+		if auxIntToInt32(v.AuxInt) != 5 {
 			break
 		}
 		x := v_1
@@ -5558,7 +5656,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// match: (ISEL [5] y _ (FlagGT))
 	// result: y
 	for {
-		if v.AuxInt != 5 {
+		if auxIntToInt32(v.AuxInt) != 5 {
 			break
 		}
 		y := v_0
@@ -5571,7 +5669,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// match: (ISEL [1] _ y (FlagEQ))
 	// result: y
 	for {
-		if v.AuxInt != 1 {
+		if auxIntToInt32(v.AuxInt) != 1 {
 			break
 		}
 		y := v_1
@@ -5584,7 +5682,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// match: (ISEL [1] _ y (FlagLT))
 	// result: y
 	for {
-		if v.AuxInt != 1 {
+		if auxIntToInt32(v.AuxInt) != 1 {
 			break
 		}
 		y := v_1
@@ -5597,7 +5695,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// match: (ISEL [1] x _ (FlagGT))
 	// result: x
 	for {
-		if v.AuxInt != 1 {
+		if auxIntToInt32(v.AuxInt) != 1 {
 			break
 		}
 		x := v_0
@@ -5610,7 +5708,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// match: (ISEL [4] x _ (FlagEQ))
 	// result: x
 	for {
-		if v.AuxInt != 4 {
+		if auxIntToInt32(v.AuxInt) != 4 {
 			break
 		}
 		x := v_0
@@ -5623,7 +5721,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// match: (ISEL [4] x _ (FlagGT))
 	// result: x
 	for {
-		if v.AuxInt != 4 {
+		if auxIntToInt32(v.AuxInt) != 4 {
 			break
 		}
 		x := v_0
@@ -5636,7 +5734,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// match: (ISEL [4] _ y (FlagLT))
 	// result: y
 	for {
-		if v.AuxInt != 4 {
+		if auxIntToInt32(v.AuxInt) != 4 {
 			break
 		}
 		y := v_1
@@ -5650,7 +5748,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// cond: n%4 == 0
 	// result: (ISEL [n+1] x y bool)
 	for {
-		n := v.AuxInt
+		n := auxIntToInt32(v.AuxInt)
 		x := v_0
 		y := v_1
 		if v_2.Op != OpPPC64InvertFlags {
@@ -5661,7 +5759,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64ISEL)
-		v.AuxInt = n + 1
+		v.AuxInt = int32ToAuxInt(n + 1)
 		v.AddArg3(x, y, bool)
 		return true
 	}
@@ -5669,7 +5767,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// cond: n%4 == 1
 	// result: (ISEL [n-1] x y bool)
 	for {
-		n := v.AuxInt
+		n := auxIntToInt32(v.AuxInt)
 		x := v_0
 		y := v_1
 		if v_2.Op != OpPPC64InvertFlags {
@@ -5680,7 +5778,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64ISEL)
-		v.AuxInt = n - 1
+		v.AuxInt = int32ToAuxInt(n - 1)
 		v.AddArg3(x, y, bool)
 		return true
 	}
@@ -5688,7 +5786,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 	// cond: n%4 == 2
 	// result: (ISEL [n] x y bool)
 	for {
-		n := v.AuxInt
+		n := auxIntToInt32(v.AuxInt)
 		x := v_0
 		y := v_1
 		if v_2.Op != OpPPC64InvertFlags {
@@ -5699,7 +5797,7 @@ func rewriteValuePPC64_OpPPC64ISEL(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64ISEL)
-		v.AuxInt = n
+		v.AuxInt = int32ToAuxInt(n)
 		v.AddArg3(x, y, bool)
 		return true
 	}
@@ -5713,189 +5811,189 @@ func rewriteValuePPC64_OpPPC64ISELB(v *Value) bool {
 	// match: (ISELB [0] _ (FlagLT))
 	// result: (MOVDconst [1])
 	for {
-		if v.AuxInt != 0 || v_1.Op != OpPPC64FlagLT {
+		if auxIntToInt32(v.AuxInt) != 0 || v_1.Op != OpPPC64FlagLT {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		return true
 	}
 	// match: (ISELB [0] _ (FlagGT))
 	// result: (MOVDconst [0])
 	for {
-		if v.AuxInt != 0 || v_1.Op != OpPPC64FlagGT {
+		if auxIntToInt32(v.AuxInt) != 0 || v_1.Op != OpPPC64FlagGT {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (ISELB [0] _ (FlagEQ))
 	// result: (MOVDconst [0])
 	for {
-		if v.AuxInt != 0 || v_1.Op != OpPPC64FlagEQ {
+		if auxIntToInt32(v.AuxInt) != 0 || v_1.Op != OpPPC64FlagEQ {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (ISELB [1] _ (FlagGT))
 	// result: (MOVDconst [1])
 	for {
-		if v.AuxInt != 1 || v_1.Op != OpPPC64FlagGT {
+		if auxIntToInt32(v.AuxInt) != 1 || v_1.Op != OpPPC64FlagGT {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		return true
 	}
 	// match: (ISELB [1] _ (FlagLT))
 	// result: (MOVDconst [0])
 	for {
-		if v.AuxInt != 1 || v_1.Op != OpPPC64FlagLT {
+		if auxIntToInt32(v.AuxInt) != 1 || v_1.Op != OpPPC64FlagLT {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (ISELB [1] _ (FlagEQ))
 	// result: (MOVDconst [0])
 	for {
-		if v.AuxInt != 1 || v_1.Op != OpPPC64FlagEQ {
+		if auxIntToInt32(v.AuxInt) != 1 || v_1.Op != OpPPC64FlagEQ {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (ISELB [2] _ (FlagEQ))
 	// result: (MOVDconst [1])
 	for {
-		if v.AuxInt != 2 || v_1.Op != OpPPC64FlagEQ {
+		if auxIntToInt32(v.AuxInt) != 2 || v_1.Op != OpPPC64FlagEQ {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		return true
 	}
 	// match: (ISELB [2] _ (FlagLT))
 	// result: (MOVDconst [0])
 	for {
-		if v.AuxInt != 2 || v_1.Op != OpPPC64FlagLT {
+		if auxIntToInt32(v.AuxInt) != 2 || v_1.Op != OpPPC64FlagLT {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (ISELB [2] _ (FlagGT))
 	// result: (MOVDconst [0])
 	for {
-		if v.AuxInt != 2 || v_1.Op != OpPPC64FlagGT {
+		if auxIntToInt32(v.AuxInt) != 2 || v_1.Op != OpPPC64FlagGT {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (ISELB [4] _ (FlagLT))
 	// result: (MOVDconst [0])
 	for {
-		if v.AuxInt != 4 || v_1.Op != OpPPC64FlagLT {
+		if auxIntToInt32(v.AuxInt) != 4 || v_1.Op != OpPPC64FlagLT {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (ISELB [4] _ (FlagGT))
 	// result: (MOVDconst [1])
 	for {
-		if v.AuxInt != 4 || v_1.Op != OpPPC64FlagGT {
+		if auxIntToInt32(v.AuxInt) != 4 || v_1.Op != OpPPC64FlagGT {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		return true
 	}
 	// match: (ISELB [4] _ (FlagEQ))
 	// result: (MOVDconst [1])
 	for {
-		if v.AuxInt != 4 || v_1.Op != OpPPC64FlagEQ {
+		if auxIntToInt32(v.AuxInt) != 4 || v_1.Op != OpPPC64FlagEQ {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		return true
 	}
 	// match: (ISELB [5] _ (FlagGT))
 	// result: (MOVDconst [0])
 	for {
-		if v.AuxInt != 5 || v_1.Op != OpPPC64FlagGT {
+		if auxIntToInt32(v.AuxInt) != 5 || v_1.Op != OpPPC64FlagGT {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (ISELB [5] _ (FlagLT))
 	// result: (MOVDconst [1])
 	for {
-		if v.AuxInt != 5 || v_1.Op != OpPPC64FlagLT {
+		if auxIntToInt32(v.AuxInt) != 5 || v_1.Op != OpPPC64FlagLT {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		return true
 	}
 	// match: (ISELB [5] _ (FlagEQ))
 	// result: (MOVDconst [1])
 	for {
-		if v.AuxInt != 5 || v_1.Op != OpPPC64FlagEQ {
+		if auxIntToInt32(v.AuxInt) != 5 || v_1.Op != OpPPC64FlagEQ {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		return true
 	}
 	// match: (ISELB [6] _ (FlagEQ))
 	// result: (MOVDconst [0])
 	for {
-		if v.AuxInt != 6 || v_1.Op != OpPPC64FlagEQ {
+		if auxIntToInt32(v.AuxInt) != 6 || v_1.Op != OpPPC64FlagEQ {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (ISELB [6] _ (FlagLT))
 	// result: (MOVDconst [1])
 	for {
-		if v.AuxInt != 6 || v_1.Op != OpPPC64FlagLT {
+		if auxIntToInt32(v.AuxInt) != 6 || v_1.Op != OpPPC64FlagLT {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		return true
 	}
 	// match: (ISELB [6] _ (FlagGT))
 	// result: (MOVDconst [1])
 	for {
-		if v.AuxInt != 6 || v_1.Op != OpPPC64FlagGT {
+		if auxIntToInt32(v.AuxInt) != 6 || v_1.Op != OpPPC64FlagGT {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		return true
 	}
 	// match: (ISELB [n] (MOVDconst [1]) (InvertFlags bool))
 	// cond: n%4 == 0
 	// result: (ISELB [n+1] (MOVDconst [1]) bool)
 	for {
-		n := v.AuxInt
-		if v_0.Op != OpPPC64MOVDconst || v_0.AuxInt != 1 || v_1.Op != OpPPC64InvertFlags {
+		n := auxIntToInt32(v.AuxInt)
+		if v_0.Op != OpPPC64MOVDconst || auxIntToInt64(v_0.AuxInt) != 1 || v_1.Op != OpPPC64InvertFlags {
 			break
 		}
 		bool := v_1.Args[0]
@@ -5903,9 +6001,9 @@ func rewriteValuePPC64_OpPPC64ISELB(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64ISELB)
-		v.AuxInt = n + 1
+		v.AuxInt = int32ToAuxInt(n + 1)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v0.AuxInt = 1
+		v0.AuxInt = int64ToAuxInt(1)
 		v.AddArg2(v0, bool)
 		return true
 	}
@@ -5913,8 +6011,8 @@ func rewriteValuePPC64_OpPPC64ISELB(v *Value) bool {
 	// cond: n%4 == 1
 	// result: (ISELB [n-1] (MOVDconst [1]) bool)
 	for {
-		n := v.AuxInt
-		if v_0.Op != OpPPC64MOVDconst || v_0.AuxInt != 1 || v_1.Op != OpPPC64InvertFlags {
+		n := auxIntToInt32(v.AuxInt)
+		if v_0.Op != OpPPC64MOVDconst || auxIntToInt64(v_0.AuxInt) != 1 || v_1.Op != OpPPC64InvertFlags {
 			break
 		}
 		bool := v_1.Args[0]
@@ -5922,9 +6020,9 @@ func rewriteValuePPC64_OpPPC64ISELB(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64ISELB)
-		v.AuxInt = n - 1
+		v.AuxInt = int32ToAuxInt(n - 1)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v0.AuxInt = 1
+		v0.AuxInt = int64ToAuxInt(1)
 		v.AddArg2(v0, bool)
 		return true
 	}
@@ -5932,8 +6030,8 @@ func rewriteValuePPC64_OpPPC64ISELB(v *Value) bool {
 	// cond: n%4 == 2
 	// result: (ISELB [n] (MOVDconst [1]) bool)
 	for {
-		n := v.AuxInt
-		if v_0.Op != OpPPC64MOVDconst || v_0.AuxInt != 1 || v_1.Op != OpPPC64InvertFlags {
+		n := auxIntToInt32(v.AuxInt)
+		if v_0.Op != OpPPC64MOVDconst || auxIntToInt64(v_0.AuxInt) != 1 || v_1.Op != OpPPC64InvertFlags {
 			break
 		}
 		bool := v_1.Args[0]
@@ -5941,9 +6039,9 @@ func rewriteValuePPC64_OpPPC64ISELB(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64ISELB)
-		v.AuxInt = n
+		v.AuxInt = int32ToAuxInt(n)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v0.AuxInt = 1
+		v0.AuxInt = int64ToAuxInt(1)
 		v.AddArg2(v0, bool)
 		return true
 	}
@@ -5960,7 +6058,7 @@ func rewriteValuePPC64_OpPPC64LessEqual(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		return true
 	}
 	// match: (LessEqual (FlagLT))
@@ -5970,7 +6068,7 @@ func rewriteValuePPC64_OpPPC64LessEqual(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		return true
 	}
 	// match: (LessEqual (FlagGT))
@@ -5980,7 +6078,7 @@ func rewriteValuePPC64_OpPPC64LessEqual(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (LessEqual (InvertFlags x))
@@ -5999,9 +6097,9 @@ func rewriteValuePPC64_OpPPC64LessEqual(v *Value) bool {
 	for {
 		cmp := v_0
 		v.reset(OpPPC64ISELB)
-		v.AuxInt = 5
+		v.AuxInt = int32ToAuxInt(5)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v0.AuxInt = 1
+		v0.AuxInt = int64ToAuxInt(1)
 		v.AddArg2(v0, cmp)
 		return true
 	}
@@ -6017,7 +6115,7 @@ func rewriteValuePPC64_OpPPC64LessThan(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (LessThan (FlagLT))
@@ -6027,7 +6125,7 @@ func rewriteValuePPC64_OpPPC64LessThan(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		return true
 	}
 	// match: (LessThan (FlagGT))
@@ -6037,7 +6135,7 @@ func rewriteValuePPC64_OpPPC64LessThan(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (LessThan (InvertFlags x))
@@ -6056,9 +6154,9 @@ func rewriteValuePPC64_OpPPC64LessThan(v *Value) bool {
 	for {
 		cmp := v_0
 		v.reset(OpPPC64ISELB)
-		v.AuxInt = 0
+		v.AuxInt = int32ToAuxInt(0)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v0.AuxInt = 1
+		v0.AuxInt = int64ToAuxInt(1)
 		v.AddArg2(v0, cmp)
 		return true
 	}
@@ -6068,14 +6166,14 @@ func rewriteValuePPC64_OpPPC64MFVSRD(v *Value) bool {
 	b := v.Block
 	typ := &b.Func.Config.Types
 	// match: (MFVSRD (FMOVDconst [c]))
-	// result: (MOVDconst [c])
+	// result: (MOVDconst [int64(math.Float64bits(c))])
 	for {
 		if v_0.Op != OpPPC64FMOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToFloat64(v_0.AuxInt)
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(int64(math.Float64bits(c)))
 		return true
 	}
 	// match: (MFVSRD x:(FMOVDload [off] {sym} ptr mem))
@@ -6086,8 +6184,8 @@ func rewriteValuePPC64_OpPPC64MFVSRD(v *Value) bool {
 		if x.Op != OpPPC64FMOVDload {
 			break
 		}
-		off := x.AuxInt
-		sym := x.Aux
+		off := auxIntToInt32(x.AuxInt)
+		sym := auxToSym(x.Aux)
 		mem := x.Args[1]
 		ptr := x.Args[0]
 		if !(x.Uses == 1 && clobber(x)) {
@@ -6096,8 +6194,8 @@ func rewriteValuePPC64_OpPPC64MFVSRD(v *Value) bool {
 		b = x.Block
 		v0 := b.NewValue0(x.Pos, OpPPC64MOVDload, typ.Int64)
 		v.copyOf(v0)
-		v0.AuxInt = off
-		v0.Aux = sym
+		v0.AuxInt = int32ToAuxInt(off)
+		v0.Aux = symToAux(sym)
 		v0.AddArg2(ptr, mem)
 		return true
 	}
@@ -6108,45 +6206,45 @@ func rewriteValuePPC64_OpPPC64MOVBZload(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (MOVBZload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
 	// cond: canMergeSym(sym1,sym2) && (ptr.Op != OpSB || p.Uses == 1)
-	// result: (MOVBZload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
+	// result: (MOVBZload [off1+off2] {mergeSymTyped(sym1,sym2)} ptr mem)
 	for {
-		off1 := v.AuxInt
-		sym1 := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64MOVDaddr {
 			break
 		}
-		off2 := p.AuxInt
-		sym2 := p.Aux
+		off2 := auxIntToInt32(p.AuxInt)
+		sym2 := auxToSym(p.Aux)
 		ptr := p.Args[0]
 		mem := v_1
 		if !(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1)) {
 			break
 		}
 		v.reset(OpPPC64MOVBZload)
-		v.AuxInt = off1 + off2
-		v.Aux = mergeSym(sym1, sym2)
+		v.AuxInt = int32ToAuxInt(off1 + off2)
+		v.Aux = symToAux(mergeSymTyped(sym1, sym2))
 		v.AddArg2(ptr, mem)
 		return true
 	}
 	// match: (MOVBZload [off1] {sym} (ADDconst [off2] x) mem)
-	// cond: is16Bit(off1+off2)
-	// result: (MOVBZload [off1+off2] {sym} x mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVBZload [off1+int32(off2)] {sym} x mem)
 	for {
-		off1 := v.AuxInt
-		sym := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		off2 := v_0.AuxInt
+		off2 := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		mem := v_1
-		if !(is16Bit(off1 + off2)) {
+		if !(is16Bit(int64(off1) + off2)) {
 			break
 		}
 		v.reset(OpPPC64MOVBZload)
-		v.AuxInt = off1 + off2
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
 		v.AddArg2(x, mem)
 		return true
 	}
@@ -6154,10 +6252,10 @@ func rewriteValuePPC64_OpPPC64MOVBZload(v *Value) bool {
 	// cond: sym == nil && p.Uses == 1
 	// result: (MOVBZloadidx ptr idx mem)
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt32(v.AuxInt) != 0 {
 			break
 		}
-		sym := v.Aux
+		sym := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64ADD {
 			break
@@ -6180,37 +6278,37 @@ func rewriteValuePPC64_OpPPC64MOVBZloadidx(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (MOVBZloadidx ptr (MOVDconst [c]) mem)
 	// cond: is16Bit(c)
-	// result: (MOVBZload [c] ptr mem)
+	// result: (MOVBZload [int32(c)] ptr mem)
 	for {
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		mem := v_2
 		if !(is16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64MOVBZload)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg2(ptr, mem)
 		return true
 	}
 	// match: (MOVBZloadidx (MOVDconst [c]) ptr mem)
 	// cond: is16Bit(c)
-	// result: (MOVBZload [c] ptr mem)
+	// result: (MOVBZload [int32(c)] ptr mem)
 	for {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		ptr := v_1
 		mem := v_2
 		if !(is16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64MOVBZload)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -6228,7 +6326,7 @@ func rewriteValuePPC64_OpPPC64MOVBZreg(v *Value) bool {
 		if y.Op != OpPPC64ANDconst {
 			break
 		}
-		c := y.AuxInt
+		c := auxIntToInt64(y.AuxInt)
 		if !(uint64(c) <= 0xFF) {
 			break
 		}
@@ -6241,14 +6339,14 @@ func rewriteValuePPC64_OpPPC64MOVBZreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v_0_0 := v_0.Args[0]
 		if v_0_0.Op != OpPPC64MOVBZreg {
 			break
 		}
 		x := v_0_0.Args[0]
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVBZreg, typ.Int64)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -6261,13 +6359,13 @@ func rewriteValuePPC64_OpPPC64MOVBZreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(sizeof(x.Type) == 8) {
 			break
 		}
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -6278,13 +6376,13 @@ func rewriteValuePPC64_OpPPC64MOVBZreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c >= 56) {
 			break
 		}
 		v.reset(OpPPC64SRDconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -6295,13 +6393,13 @@ func rewriteValuePPC64_OpPPC64MOVBZreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c >= 24) {
 			break
 		}
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -6367,9 +6465,9 @@ func rewriteValuePPC64_OpPPC64MOVBZreg(v *Value) bool {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = int64(uint8(c))
+		v.AuxInt = int64ToAuxInt(int64(uint8(c)))
 		return true
 	}
 	return false
@@ -6386,7 +6484,7 @@ func rewriteValuePPC64_OpPPC64MOVBreg(v *Value) bool {
 		if y.Op != OpPPC64ANDconst {
 			break
 		}
-		c := y.AuxInt
+		c := auxIntToInt64(y.AuxInt)
 		if !(uint64(c) <= 0x7F) {
 			break
 		}
@@ -6399,14 +6497,14 @@ func rewriteValuePPC64_OpPPC64MOVBreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRAWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v_0_0 := v_0.Args[0]
 		if v_0_0.Op != OpPPC64MOVBreg {
 			break
 		}
 		x := v_0_0.Args[0]
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVBreg, typ.Int64)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -6419,13 +6517,13 @@ func rewriteValuePPC64_OpPPC64MOVBreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRAWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(sizeof(x.Type) == 8) {
 			break
 		}
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -6436,13 +6534,13 @@ func rewriteValuePPC64_OpPPC64MOVBreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c > 56) {
 			break
 		}
 		v.reset(OpPPC64SRDconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -6453,13 +6551,13 @@ func rewriteValuePPC64_OpPPC64MOVBreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c == 56) {
 			break
 		}
 		v.reset(OpPPC64SRADconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -6470,13 +6568,13 @@ func rewriteValuePPC64_OpPPC64MOVBreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRADconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c >= 56) {
 			break
 		}
 		v.reset(OpPPC64SRADconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -6487,13 +6585,13 @@ func rewriteValuePPC64_OpPPC64MOVBreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c > 24) {
 			break
 		}
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -6504,13 +6602,13 @@ func rewriteValuePPC64_OpPPC64MOVBreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c == 24) {
 			break
 		}
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -6521,13 +6619,13 @@ func rewriteValuePPC64_OpPPC64MOVBreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRAWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c >= 24) {
 			break
 		}
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -6573,9 +6671,9 @@ func rewriteValuePPC64_OpPPC64MOVBreg(v *Value) bool {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = int64(int8(c))
+		v.AuxInt = int64ToAuxInt(int64(int8(c)))
 		return true
 	}
 	return false
@@ -6588,39 +6686,39 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 	config := b.Func.Config
 	typ := &b.Func.Config.Types
 	// match: (MOVBstore [off1] {sym} (ADDconst [off2] x) val mem)
-	// cond: is16Bit(off1+off2)
-	// result: (MOVBstore [off1+off2] {sym} x val mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVBstore [off1+int32(off2)] {sym} x val mem)
 	for {
-		off1 := v.AuxInt
-		sym := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		off2 := v_0.AuxInt
+		off2 := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		val := v_1
 		mem := v_2
-		if !(is16Bit(off1 + off2)) {
+		if !(is16Bit(int64(off1) + off2)) {
 			break
 		}
 		v.reset(OpPPC64MOVBstore)
-		v.AuxInt = off1 + off2
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
 		v.AddArg3(x, val, mem)
 		return true
 	}
 	// match: (MOVBstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem)
 	// cond: canMergeSym(sym1,sym2) && (ptr.Op != OpSB || p.Uses == 1)
-	// result: (MOVBstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
+	// result: (MOVBstore [off1+off2] {mergeSymTyped(sym1,sym2)} ptr val mem)
 	for {
-		off1 := v.AuxInt
-		sym1 := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64MOVDaddr {
 			break
 		}
-		off2 := p.AuxInt
-		sym2 := p.Aux
+		off2 := auxIntToInt32(p.AuxInt)
+		sym2 := auxToSym(p.Aux)
 		ptr := p.Args[0]
 		val := v_1
 		mem := v_2
@@ -6628,24 +6726,24 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVBstore)
-		v.AuxInt = off1 + off2
-		v.Aux = mergeSym(sym1, sym2)
+		v.AuxInt = int32ToAuxInt(off1 + off2)
+		v.Aux = symToAux(mergeSymTyped(sym1, sym2))
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
 	// match: (MOVBstore [off] {sym} ptr (MOVDconst [0]) mem)
 	// result: (MOVBstorezero [off] {sym} ptr mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
-		if v_1.Op != OpPPC64MOVDconst || v_1.AuxInt != 0 {
+		if v_1.Op != OpPPC64MOVDconst || auxIntToInt64(v_1.AuxInt) != 0 {
 			break
 		}
 		mem := v_2
 		v.reset(OpPPC64MOVBstorezero)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -6653,10 +6751,10 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 	// cond: sym == nil && p.Uses == 1
 	// result: (MOVBstoreidx ptr idx val mem)
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt32(v.AuxInt) != 0 {
 			break
 		}
-		sym := v.Aux
+		sym := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64ADD {
 			break
@@ -6675,8 +6773,8 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 	// match: (MOVBstore [off] {sym} ptr (MOVBreg x) mem)
 	// result: (MOVBstore [off] {sym} ptr x mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVBreg {
 			break
@@ -6684,16 +6782,16 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVBstore)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
 	// match: (MOVBstore [off] {sym} ptr (MOVBZreg x) mem)
 	// result: (MOVBstore [off] {sym} ptr x mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVBZreg {
 			break
@@ -6701,16 +6799,16 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVBstore)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
 	// match: (MOVBstore [off] {sym} ptr (MOVHreg x) mem)
 	// result: (MOVBstore [off] {sym} ptr x mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVHreg {
 			break
@@ -6718,16 +6816,16 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVBstore)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
 	// match: (MOVBstore [off] {sym} ptr (MOVHZreg x) mem)
 	// result: (MOVBstore [off] {sym} ptr x mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVHZreg {
 			break
@@ -6735,16 +6833,16 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVBstore)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
 	// match: (MOVBstore [off] {sym} ptr (MOVWreg x) mem)
 	// result: (MOVBstore [off] {sym} ptr x mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVWreg {
 			break
@@ -6752,16 +6850,16 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVBstore)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
 	// match: (MOVBstore [off] {sym} ptr (MOVWZreg x) mem)
 	// result: (MOVBstore [off] {sym} ptr x mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVWZreg {
 			break
@@ -6769,8 +6867,8 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVBstore)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
@@ -6778,13 +6876,13 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 	// cond: c <= 8
 	// result: (MOVBstore [off] {sym} ptr (SRWconst <typ.UInt32> x [c]) mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		v_1_0 := v_1.Args[0]
 		if v_1_0.Op != OpPPC64MOVHreg {
 			break
@@ -6795,10 +6893,10 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVBstore)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v0 := b.NewValue0(v.Pos, OpPPC64SRWconst, typ.UInt32)
-		v0.AuxInt = c
+		v0.AuxInt = int64ToAuxInt(c)
 		v0.AddArg(x)
 		v.AddArg3(ptr, v0, mem)
 		return true
@@ -6807,13 +6905,13 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 	// cond: c <= 8
 	// result: (MOVBstore [off] {sym} ptr (SRWconst <typ.UInt32> x [c]) mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		v_1_0 := v_1.Args[0]
 		if v_1_0.Op != OpPPC64MOVHZreg {
 			break
@@ -6824,10 +6922,10 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVBstore)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v0 := b.NewValue0(v.Pos, OpPPC64SRWconst, typ.UInt32)
-		v0.AuxInt = c
+		v0.AuxInt = int64ToAuxInt(c)
 		v0.AddArg(x)
 		v.AddArg3(ptr, v0, mem)
 		return true
@@ -6836,13 +6934,13 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 	// cond: c <= 24
 	// result: (MOVBstore [off] {sym} ptr (SRWconst <typ.UInt32> x [c]) mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		v_1_0 := v_1.Args[0]
 		if v_1_0.Op != OpPPC64MOVWreg {
 			break
@@ -6853,10 +6951,10 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVBstore)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v0 := b.NewValue0(v.Pos, OpPPC64SRWconst, typ.UInt32)
-		v0.AuxInt = c
+		v0.AuxInt = int64ToAuxInt(c)
 		v0.AddArg(x)
 		v.AddArg3(ptr, v0, mem)
 		return true
@@ -6865,13 +6963,13 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 	// cond: c <= 24
 	// result: (MOVBstore [off] {sym} ptr (SRWconst <typ.UInt32> x [c]) mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		v_1_0 := v_1.Args[0]
 		if v_1_0.Op != OpPPC64MOVWZreg {
 			break
@@ -6882,10 +6980,10 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVBstore)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v0 := b.NewValue0(v.Pos, OpPPC64SRWconst, typ.UInt32)
-		v0.AuxInt = c
+		v0.AuxInt = int64ToAuxInt(c)
 		v0.AddArg(x)
 		v.AddArg3(ptr, v0, mem)
 		return true
@@ -6894,10 +6992,10 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 	// cond: !config.BigEndian && x0.Uses == 1 && i1 == i0+1 && clobber(x0)
 	// result: (MOVHstore [i0] {s} p (SRWconst <typ.UInt16> w [16]) mem)
 	for {
-		i1 := v.AuxInt
-		s := v.Aux
+		i1 := auxIntToInt32(v.AuxInt)
+		s := auxToSym(v.Aux)
 		p := v_0
-		if v_1.Op != OpPPC64SRWconst || v_1.AuxInt != 24 {
+		if v_1.Op != OpPPC64SRWconst || auxIntToInt64(v_1.AuxInt) != 24 {
 			break
 		}
 		w := v_1.Args[0]
@@ -6905,8 +7003,8 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 		if x0.Op != OpPPC64MOVBstore {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		i0 := auxIntToInt32(x0.AuxInt)
+		if auxToSym(x0.Aux) != s {
 			break
 		}
 		mem := x0.Args[2]
@@ -6914,14 +7012,14 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		x0_1 := x0.Args[1]
-		if x0_1.Op != OpPPC64SRWconst || x0_1.AuxInt != 16 || w != x0_1.Args[0] || !(!config.BigEndian && x0.Uses == 1 && i1 == i0+1 && clobber(x0)) {
+		if x0_1.Op != OpPPC64SRWconst || auxIntToInt64(x0_1.AuxInt) != 16 || w != x0_1.Args[0] || !(!config.BigEndian && x0.Uses == 1 && i1 == i0+1 && clobber(x0)) {
 			break
 		}
 		v.reset(OpPPC64MOVHstore)
-		v.AuxInt = i0
-		v.Aux = s
+		v.AuxInt = int32ToAuxInt(i0)
+		v.Aux = symToAux(s)
 		v0 := b.NewValue0(x0.Pos, OpPPC64SRWconst, typ.UInt16)
-		v0.AuxInt = 16
+		v0.AuxInt = int64ToAuxInt(16)
 		v0.AddArg(w)
 		v.AddArg3(p, v0, mem)
 		return true
@@ -6930,10 +7028,10 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 	// cond: !config.BigEndian && x0.Uses == 1 && i1 == i0+1 && clobber(x0)
 	// result: (MOVHstore [i0] {s} p (SRWconst <typ.UInt16> w [16]) mem)
 	for {
-		i1 := v.AuxInt
-		s := v.Aux
+		i1 := auxIntToInt32(v.AuxInt)
+		s := auxToSym(v.Aux)
 		p := v_0
-		if v_1.Op != OpPPC64SRDconst || v_1.AuxInt != 24 {
+		if v_1.Op != OpPPC64SRDconst || auxIntToInt64(v_1.AuxInt) != 24 {
 			break
 		}
 		w := v_1.Args[0]
@@ -6941,8 +7039,8 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 		if x0.Op != OpPPC64MOVBstore {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		i0 := auxIntToInt32(x0.AuxInt)
+		if auxToSym(x0.Aux) != s {
 			break
 		}
 		mem := x0.Args[2]
@@ -6950,14 +7048,14 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		x0_1 := x0.Args[1]
-		if x0_1.Op != OpPPC64SRDconst || x0_1.AuxInt != 16 || w != x0_1.Args[0] || !(!config.BigEndian && x0.Uses == 1 && i1 == i0+1 && clobber(x0)) {
+		if x0_1.Op != OpPPC64SRDconst || auxIntToInt64(x0_1.AuxInt) != 16 || w != x0_1.Args[0] || !(!config.BigEndian && x0.Uses == 1 && i1 == i0+1 && clobber(x0)) {
 			break
 		}
 		v.reset(OpPPC64MOVHstore)
-		v.AuxInt = i0
-		v.Aux = s
+		v.AuxInt = int32ToAuxInt(i0)
+		v.Aux = symToAux(s)
 		v0 := b.NewValue0(x0.Pos, OpPPC64SRWconst, typ.UInt16)
-		v0.AuxInt = 16
+		v0.AuxInt = int64ToAuxInt(16)
 		v0.AddArg(w)
 		v.AddArg3(p, v0, mem)
 		return true
@@ -6966,10 +7064,10 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 	// cond: !config.BigEndian && x0.Uses == 1 && i1 == i0+1 && clobber(x0)
 	// result: (MOVHstore [i0] {s} p w mem)
 	for {
-		i1 := v.AuxInt
-		s := v.Aux
+		i1 := auxIntToInt32(v.AuxInt)
+		s := auxToSym(v.Aux)
 		p := v_0
-		if v_1.Op != OpPPC64SRWconst || v_1.AuxInt != 8 {
+		if v_1.Op != OpPPC64SRWconst || auxIntToInt64(v_1.AuxInt) != 8 {
 			break
 		}
 		w := v_1.Args[0]
@@ -6977,8 +7075,8 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 		if x0.Op != OpPPC64MOVBstore {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		i0 := auxIntToInt32(x0.AuxInt)
+		if auxToSym(x0.Aux) != s {
 			break
 		}
 		mem := x0.Args[2]
@@ -6986,8 +7084,8 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVHstore)
-		v.AuxInt = i0
-		v.Aux = s
+		v.AuxInt = int32ToAuxInt(i0)
+		v.Aux = symToAux(s)
 		v.AddArg3(p, w, mem)
 		return true
 	}
@@ -6995,10 +7093,10 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 	// cond: !config.BigEndian && x0.Uses == 1 && i1 == i0+1 && clobber(x0)
 	// result: (MOVHstore [i0] {s} p w mem)
 	for {
-		i1 := v.AuxInt
-		s := v.Aux
+		i1 := auxIntToInt32(v.AuxInt)
+		s := auxToSym(v.Aux)
 		p := v_0
-		if v_1.Op != OpPPC64SRDconst || v_1.AuxInt != 8 {
+		if v_1.Op != OpPPC64SRDconst || auxIntToInt64(v_1.AuxInt) != 8 {
 			break
 		}
 		w := v_1.Args[0]
@@ -7006,8 +7104,8 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 		if x0.Op != OpPPC64MOVBstore {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		i0 := auxIntToInt32(x0.AuxInt)
+		if auxToSym(x0.Aux) != s {
 			break
 		}
 		mem := x0.Args[2]
@@ -7015,8 +7113,8 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVHstore)
-		v.AuxInt = i0
-		v.Aux = s
+		v.AuxInt = int32ToAuxInt(i0)
+		v.Aux = symToAux(s)
 		v.AddArg3(p, w, mem)
 		return true
 	}
@@ -7024,16 +7122,16 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 	// cond: !config.BigEndian && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && clobber(x0, x1, x2)
 	// result: (MOVWBRstore (MOVDaddr <typ.Uintptr> [i0] {s} p) w mem)
 	for {
-		i3 := v.AuxInt
-		s := v.Aux
+		i3 := auxIntToInt32(v.AuxInt)
+		s := auxToSym(v.Aux)
 		p := v_0
 		w := v_1
 		x0 := v_2
 		if x0.Op != OpPPC64MOVBstore {
 			break
 		}
-		i2 := x0.AuxInt
-		if x0.Aux != s {
+		i2 := auxIntToInt32(x0.AuxInt)
+		if auxToSym(x0.Aux) != s {
 			break
 		}
 		_ = x0.Args[2]
@@ -7041,15 +7139,15 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		x0_1 := x0.Args[1]
-		if x0_1.Op != OpPPC64SRWconst || x0_1.AuxInt != 8 || w != x0_1.Args[0] {
+		if x0_1.Op != OpPPC64SRWconst || auxIntToInt64(x0_1.AuxInt) != 8 || w != x0_1.Args[0] {
 			break
 		}
 		x1 := x0.Args[2]
 		if x1.Op != OpPPC64MOVBstore {
 			break
 		}
-		i1 := x1.AuxInt
-		if x1.Aux != s {
+		i1 := auxIntToInt32(x1.AuxInt)
+		if auxToSym(x1.Aux) != s {
 			break
 		}
 		_ = x1.Args[2]
@@ -7057,15 +7155,15 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		x1_1 := x1.Args[1]
-		if x1_1.Op != OpPPC64SRWconst || x1_1.AuxInt != 16 || w != x1_1.Args[0] {
+		if x1_1.Op != OpPPC64SRWconst || auxIntToInt64(x1_1.AuxInt) != 16 || w != x1_1.Args[0] {
 			break
 		}
 		x2 := x1.Args[2]
 		if x2.Op != OpPPC64MOVBstore {
 			break
 		}
-		i0 := x2.AuxInt
-		if x2.Aux != s {
+		i0 := auxIntToInt32(x2.AuxInt)
+		if auxToSym(x2.Aux) != s {
 			break
 		}
 		mem := x2.Args[2]
@@ -7073,13 +7171,13 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		x2_1 := x2.Args[1]
-		if x2_1.Op != OpPPC64SRWconst || x2_1.AuxInt != 24 || w != x2_1.Args[0] || !(!config.BigEndian && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && clobber(x0, x1, x2)) {
+		if x2_1.Op != OpPPC64SRWconst || auxIntToInt64(x2_1.AuxInt) != 24 || w != x2_1.Args[0] || !(!config.BigEndian && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && clobber(x0, x1, x2)) {
 			break
 		}
 		v.reset(OpPPC64MOVWBRstore)
 		v0 := b.NewValue0(x2.Pos, OpPPC64MOVDaddr, typ.Uintptr)
-		v0.AuxInt = i0
-		v0.Aux = s
+		v0.AuxInt = int32ToAuxInt(i0)
+		v0.Aux = symToAux(s)
 		v0.AddArg(p)
 		v.AddArg3(v0, w, mem)
 		return true
@@ -7088,16 +7186,16 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 	// cond: !config.BigEndian && x0.Uses == 1 && i1 == i0+1 && clobber(x0)
 	// result: (MOVHBRstore (MOVDaddr <typ.Uintptr> [i0] {s} p) w mem)
 	for {
-		i1 := v.AuxInt
-		s := v.Aux
+		i1 := auxIntToInt32(v.AuxInt)
+		s := auxToSym(v.Aux)
 		p := v_0
 		w := v_1
 		x0 := v_2
 		if x0.Op != OpPPC64MOVBstore {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		i0 := auxIntToInt32(x0.AuxInt)
+		if auxToSym(x0.Aux) != s {
 			break
 		}
 		mem := x0.Args[2]
@@ -7105,13 +7203,13 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		x0_1 := x0.Args[1]
-		if x0_1.Op != OpPPC64SRWconst || x0_1.AuxInt != 8 || w != x0_1.Args[0] || !(!config.BigEndian && x0.Uses == 1 && i1 == i0+1 && clobber(x0)) {
+		if x0_1.Op != OpPPC64SRWconst || auxIntToInt64(x0_1.AuxInt) != 8 || w != x0_1.Args[0] || !(!config.BigEndian && x0.Uses == 1 && i1 == i0+1 && clobber(x0)) {
 			break
 		}
 		v.reset(OpPPC64MOVHBRstore)
 		v0 := b.NewValue0(x0.Pos, OpPPC64MOVDaddr, typ.Uintptr)
-		v0.AuxInt = i0
-		v0.Aux = s
+		v0.AuxInt = int32ToAuxInt(i0)
+		v0.Aux = symToAux(s)
 		v0.AddArg(p)
 		v.AddArg3(v0, w, mem)
 		return true
@@ -7120,10 +7218,10 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 	// cond: !config.BigEndian && i0%4 == 0 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && clobber(x0, x1, x2, x3)
 	// result: (MOVDstore [i0] {s} p w mem)
 	for {
-		i7 := v.AuxInt
-		s := v.Aux
+		i7 := auxIntToInt32(v.AuxInt)
+		s := auxToSym(v.Aux)
 		p := v_0
-		if v_1.Op != OpPPC64SRDconst || v_1.AuxInt != 56 {
+		if v_1.Op != OpPPC64SRDconst || auxIntToInt64(v_1.AuxInt) != 56 {
 			break
 		}
 		w := v_1.Args[0]
@@ -7131,8 +7229,8 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 		if x0.Op != OpPPC64MOVBstore {
 			break
 		}
-		i6 := x0.AuxInt
-		if x0.Aux != s {
+		i6 := auxIntToInt32(x0.AuxInt)
+		if auxToSym(x0.Aux) != s {
 			break
 		}
 		_ = x0.Args[2]
@@ -7140,15 +7238,15 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		x0_1 := x0.Args[1]
-		if x0_1.Op != OpPPC64SRDconst || x0_1.AuxInt != 48 || w != x0_1.Args[0] {
+		if x0_1.Op != OpPPC64SRDconst || auxIntToInt64(x0_1.AuxInt) != 48 || w != x0_1.Args[0] {
 			break
 		}
 		x1 := x0.Args[2]
 		if x1.Op != OpPPC64MOVBstore {
 			break
 		}
-		i5 := x1.AuxInt
-		if x1.Aux != s {
+		i5 := auxIntToInt32(x1.AuxInt)
+		if auxToSym(x1.Aux) != s {
 			break
 		}
 		_ = x1.Args[2]
@@ -7156,15 +7254,15 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		x1_1 := x1.Args[1]
-		if x1_1.Op != OpPPC64SRDconst || x1_1.AuxInt != 40 || w != x1_1.Args[0] {
+		if x1_1.Op != OpPPC64SRDconst || auxIntToInt64(x1_1.AuxInt) != 40 || w != x1_1.Args[0] {
 			break
 		}
 		x2 := x1.Args[2]
 		if x2.Op != OpPPC64MOVBstore {
 			break
 		}
-		i4 := x2.AuxInt
-		if x2.Aux != s {
+		i4 := auxIntToInt32(x2.AuxInt)
+		if auxToSym(x2.Aux) != s {
 			break
 		}
 		_ = x2.Args[2]
@@ -7172,15 +7270,15 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		x2_1 := x2.Args[1]
-		if x2_1.Op != OpPPC64SRDconst || x2_1.AuxInt != 32 || w != x2_1.Args[0] {
+		if x2_1.Op != OpPPC64SRDconst || auxIntToInt64(x2_1.AuxInt) != 32 || w != x2_1.Args[0] {
 			break
 		}
 		x3 := x2.Args[2]
 		if x3.Op != OpPPC64MOVWstore {
 			break
 		}
-		i0 := x3.AuxInt
-		if x3.Aux != s {
+		i0 := auxIntToInt32(x3.AuxInt)
+		if auxToSym(x3.Aux) != s {
 			break
 		}
 		mem := x3.Args[2]
@@ -7188,8 +7286,8 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDstore)
-		v.AuxInt = i0
-		v.Aux = s
+		v.AuxInt = int32ToAuxInt(i0)
+		v.Aux = symToAux(s)
 		v.AddArg3(p, w, mem)
 		return true
 	}
@@ -7197,16 +7295,16 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 	// cond: !config.BigEndian && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && clobber(x0, x1, x2, x3, x4, x5, x6)
 	// result: (MOVDBRstore (MOVDaddr <typ.Uintptr> [i0] {s} p) w mem)
 	for {
-		i7 := v.AuxInt
-		s := v.Aux
+		i7 := auxIntToInt32(v.AuxInt)
+		s := auxToSym(v.Aux)
 		p := v_0
 		w := v_1
 		x0 := v_2
 		if x0.Op != OpPPC64MOVBstore {
 			break
 		}
-		i6 := x0.AuxInt
-		if x0.Aux != s {
+		i6 := auxIntToInt32(x0.AuxInt)
+		if auxToSym(x0.Aux) != s {
 			break
 		}
 		_ = x0.Args[2]
@@ -7214,15 +7312,15 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		x0_1 := x0.Args[1]
-		if x0_1.Op != OpPPC64SRDconst || x0_1.AuxInt != 8 || w != x0_1.Args[0] {
+		if x0_1.Op != OpPPC64SRDconst || auxIntToInt64(x0_1.AuxInt) != 8 || w != x0_1.Args[0] {
 			break
 		}
 		x1 := x0.Args[2]
 		if x1.Op != OpPPC64MOVBstore {
 			break
 		}
-		i5 := x1.AuxInt
-		if x1.Aux != s {
+		i5 := auxIntToInt32(x1.AuxInt)
+		if auxToSym(x1.Aux) != s {
 			break
 		}
 		_ = x1.Args[2]
@@ -7230,15 +7328,15 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		x1_1 := x1.Args[1]
-		if x1_1.Op != OpPPC64SRDconst || x1_1.AuxInt != 16 || w != x1_1.Args[0] {
+		if x1_1.Op != OpPPC64SRDconst || auxIntToInt64(x1_1.AuxInt) != 16 || w != x1_1.Args[0] {
 			break
 		}
 		x2 := x1.Args[2]
 		if x2.Op != OpPPC64MOVBstore {
 			break
 		}
-		i4 := x2.AuxInt
-		if x2.Aux != s {
+		i4 := auxIntToInt32(x2.AuxInt)
+		if auxToSym(x2.Aux) != s {
 			break
 		}
 		_ = x2.Args[2]
@@ -7246,15 +7344,15 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		x2_1 := x2.Args[1]
-		if x2_1.Op != OpPPC64SRDconst || x2_1.AuxInt != 24 || w != x2_1.Args[0] {
+		if x2_1.Op != OpPPC64SRDconst || auxIntToInt64(x2_1.AuxInt) != 24 || w != x2_1.Args[0] {
 			break
 		}
 		x3 := x2.Args[2]
 		if x3.Op != OpPPC64MOVBstore {
 			break
 		}
-		i3 := x3.AuxInt
-		if x3.Aux != s {
+		i3 := auxIntToInt32(x3.AuxInt)
+		if auxToSym(x3.Aux) != s {
 			break
 		}
 		_ = x3.Args[2]
@@ -7262,15 +7360,15 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		x3_1 := x3.Args[1]
-		if x3_1.Op != OpPPC64SRDconst || x3_1.AuxInt != 32 || w != x3_1.Args[0] {
+		if x3_1.Op != OpPPC64SRDconst || auxIntToInt64(x3_1.AuxInt) != 32 || w != x3_1.Args[0] {
 			break
 		}
 		x4 := x3.Args[2]
 		if x4.Op != OpPPC64MOVBstore {
 			break
 		}
-		i2 := x4.AuxInt
-		if x4.Aux != s {
+		i2 := auxIntToInt32(x4.AuxInt)
+		if auxToSym(x4.Aux) != s {
 			break
 		}
 		_ = x4.Args[2]
@@ -7278,15 +7376,15 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		x4_1 := x4.Args[1]
-		if x4_1.Op != OpPPC64SRDconst || x4_1.AuxInt != 40 || w != x4_1.Args[0] {
+		if x4_1.Op != OpPPC64SRDconst || auxIntToInt64(x4_1.AuxInt) != 40 || w != x4_1.Args[0] {
 			break
 		}
 		x5 := x4.Args[2]
 		if x5.Op != OpPPC64MOVBstore {
 			break
 		}
-		i1 := x5.AuxInt
-		if x5.Aux != s {
+		i1 := auxIntToInt32(x5.AuxInt)
+		if auxToSym(x5.Aux) != s {
 			break
 		}
 		_ = x5.Args[2]
@@ -7294,15 +7392,15 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		x5_1 := x5.Args[1]
-		if x5_1.Op != OpPPC64SRDconst || x5_1.AuxInt != 48 || w != x5_1.Args[0] {
+		if x5_1.Op != OpPPC64SRDconst || auxIntToInt64(x5_1.AuxInt) != 48 || w != x5_1.Args[0] {
 			break
 		}
 		x6 := x5.Args[2]
 		if x6.Op != OpPPC64MOVBstore {
 			break
 		}
-		i0 := x6.AuxInt
-		if x6.Aux != s {
+		i0 := auxIntToInt32(x6.AuxInt)
+		if auxToSym(x6.Aux) != s {
 			break
 		}
 		mem := x6.Args[2]
@@ -7310,13 +7408,13 @@ func rewriteValuePPC64_OpPPC64MOVBstore(v *Value) bool {
 			break
 		}
 		x6_1 := x6.Args[1]
-		if x6_1.Op != OpPPC64SRDconst || x6_1.AuxInt != 56 || w != x6_1.Args[0] || !(!config.BigEndian && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && clobber(x0, x1, x2, x3, x4, x5, x6)) {
+		if x6_1.Op != OpPPC64SRDconst || auxIntToInt64(x6_1.AuxInt) != 56 || w != x6_1.Args[0] || !(!config.BigEndian && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && clobber(x0, x1, x2, x3, x4, x5, x6)) {
 			break
 		}
 		v.reset(OpPPC64MOVDBRstore)
 		v0 := b.NewValue0(x6.Pos, OpPPC64MOVDaddr, typ.Uintptr)
-		v0.AuxInt = i0
-		v0.Aux = s
+		v0.AuxInt = int32ToAuxInt(i0)
+		v0.Aux = symToAux(s)
 		v0.AddArg(p)
 		v.AddArg3(v0, w, mem)
 		return true
@@ -7332,31 +7430,31 @@ func rewriteValuePPC64_OpPPC64MOVBstoreidx(v *Value) bool {
 	typ := &b.Func.Config.Types
 	// match: (MOVBstoreidx ptr (MOVDconst [c]) val mem)
 	// cond: is16Bit(c)
-	// result: (MOVBstore [c] ptr val mem)
+	// result: (MOVBstore [int32(c)] ptr val mem)
 	for {
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		val := v_2
 		mem := v_3
 		if !(is16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64MOVBstore)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
 	// match: (MOVBstoreidx (MOVDconst [c]) ptr val mem)
 	// cond: is16Bit(c)
-	// result: (MOVBstore [c] ptr val mem)
+	// result: (MOVBstore [int32(c)] ptr val mem)
 	for {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		ptr := v_1
 		val := v_2
 		mem := v_3
@@ -7364,7 +7462,7 @@ func rewriteValuePPC64_OpPPC64MOVBstoreidx(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVBstore)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
@@ -7461,7 +7559,7 @@ func rewriteValuePPC64_OpPPC64MOVBstoreidx(v *Value) bool {
 		if v_2.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_2.AuxInt
+		c := auxIntToInt64(v_2.AuxInt)
 		v_2_0 := v_2.Args[0]
 		if v_2_0.Op != OpPPC64MOVHreg {
 			break
@@ -7473,7 +7571,7 @@ func rewriteValuePPC64_OpPPC64MOVBstoreidx(v *Value) bool {
 		}
 		v.reset(OpPPC64MOVBstoreidx)
 		v0 := b.NewValue0(v.Pos, OpPPC64SRWconst, typ.UInt32)
-		v0.AuxInt = c
+		v0.AuxInt = int64ToAuxInt(c)
 		v0.AddArg(x)
 		v.AddArg4(ptr, idx, v0, mem)
 		return true
@@ -7487,7 +7585,7 @@ func rewriteValuePPC64_OpPPC64MOVBstoreidx(v *Value) bool {
 		if v_2.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_2.AuxInt
+		c := auxIntToInt64(v_2.AuxInt)
 		v_2_0 := v_2.Args[0]
 		if v_2_0.Op != OpPPC64MOVHZreg {
 			break
@@ -7499,7 +7597,7 @@ func rewriteValuePPC64_OpPPC64MOVBstoreidx(v *Value) bool {
 		}
 		v.reset(OpPPC64MOVBstoreidx)
 		v0 := b.NewValue0(v.Pos, OpPPC64SRWconst, typ.UInt32)
-		v0.AuxInt = c
+		v0.AuxInt = int64ToAuxInt(c)
 		v0.AddArg(x)
 		v.AddArg4(ptr, idx, v0, mem)
 		return true
@@ -7513,7 +7611,7 @@ func rewriteValuePPC64_OpPPC64MOVBstoreidx(v *Value) bool {
 		if v_2.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_2.AuxInt
+		c := auxIntToInt64(v_2.AuxInt)
 		v_2_0 := v_2.Args[0]
 		if v_2_0.Op != OpPPC64MOVWreg {
 			break
@@ -7525,7 +7623,7 @@ func rewriteValuePPC64_OpPPC64MOVBstoreidx(v *Value) bool {
 		}
 		v.reset(OpPPC64MOVBstoreidx)
 		v0 := b.NewValue0(v.Pos, OpPPC64SRWconst, typ.UInt32)
-		v0.AuxInt = c
+		v0.AuxInt = int64ToAuxInt(c)
 		v0.AddArg(x)
 		v.AddArg4(ptr, idx, v0, mem)
 		return true
@@ -7539,7 +7637,7 @@ func rewriteValuePPC64_OpPPC64MOVBstoreidx(v *Value) bool {
 		if v_2.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_2.AuxInt
+		c := auxIntToInt64(v_2.AuxInt)
 		v_2_0 := v_2.Args[0]
 		if v_2_0.Op != OpPPC64MOVWZreg {
 			break
@@ -7551,7 +7649,7 @@ func rewriteValuePPC64_OpPPC64MOVBstoreidx(v *Value) bool {
 		}
 		v.reset(OpPPC64MOVBstoreidx)
 		v0 := b.NewValue0(v.Pos, OpPPC64SRWconst, typ.UInt32)
-		v0.AuxInt = c
+		v0.AuxInt = int64ToAuxInt(c)
 		v0.AddArg(x)
 		v.AddArg4(ptr, idx, v0, mem)
 		return true
@@ -7562,23 +7660,23 @@ func rewriteValuePPC64_OpPPC64MOVBstorezero(v *Value) bool {
 	v_1 := v.Args[1]
 	v_0 := v.Args[0]
 	// match: (MOVBstorezero [off1] {sym} (ADDconst [off2] x) mem)
-	// cond: is16Bit(off1+off2)
-	// result: (MOVBstorezero [off1+off2] {sym} x mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVBstorezero [off1+int32(off2)] {sym} x mem)
 	for {
-		off1 := v.AuxInt
-		sym := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		off2 := v_0.AuxInt
+		off2 := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		mem := v_1
-		if !(is16Bit(off1 + off2)) {
+		if !(is16Bit(int64(off1) + off2)) {
 			break
 		}
 		v.reset(OpPPC64MOVBstorezero)
-		v.AuxInt = off1 + off2
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
 		v.AddArg2(x, mem)
 		return true
 	}
@@ -7613,10 +7711,10 @@ func rewriteValuePPC64_OpPPC64MOVDload(v *Value) bool {
 	// match: (MOVDload [off] {sym} ptr (FMOVDstore [off] {sym} ptr x _))
 	// result: (MFVSRD x)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
-		if v_1.Op != OpPPC64FMOVDstore || v_1.AuxInt != off || v_1.Aux != sym {
+		if v_1.Op != OpPPC64FMOVDstore || auxIntToInt32(v_1.AuxInt) != off || auxToSym(v_1.Aux) != sym {
 			break
 		}
 		x := v_1.Args[1]
@@ -7629,45 +7727,45 @@ func rewriteValuePPC64_OpPPC64MOVDload(v *Value) bool {
 	}
 	// match: (MOVDload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
 	// cond: canMergeSym(sym1,sym2) && (ptr.Op != OpSB || p.Uses == 1) && (off1+off2)%4 == 0
-	// result: (MOVDload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
+	// result: (MOVDload [off1+off2] {mergeSymTyped(sym1,sym2)} ptr mem)
 	for {
-		off1 := v.AuxInt
-		sym1 := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64MOVDaddr {
 			break
 		}
-		off2 := p.AuxInt
-		sym2 := p.Aux
+		off2 := auxIntToInt32(p.AuxInt)
+		sym2 := auxToSym(p.Aux)
 		ptr := p.Args[0]
 		mem := v_1
 		if !(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1) && (off1+off2)%4 == 0) {
 			break
 		}
 		v.reset(OpPPC64MOVDload)
-		v.AuxInt = off1 + off2
-		v.Aux = mergeSym(sym1, sym2)
+		v.AuxInt = int32ToAuxInt(off1 + off2)
+		v.Aux = symToAux(mergeSymTyped(sym1, sym2))
 		v.AddArg2(ptr, mem)
 		return true
 	}
 	// match: (MOVDload [off1] {sym} (ADDconst [off2] x) mem)
-	// cond: is16Bit(off1+off2) && (off1+off2)%4 == 0
-	// result: (MOVDload [off1+off2] {sym} x mem)
+	// cond: is16Bit(int64(off1)+off2) && (int64(off1)+off2)%4 == 0
+	// result: (MOVDload [off1+int32(off2)] {sym} x mem)
 	for {
-		off1 := v.AuxInt
-		sym := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		off2 := v_0.AuxInt
+		off2 := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		mem := v_1
-		if !(is16Bit(off1+off2) && (off1+off2)%4 == 0) {
+		if !(is16Bit(int64(off1)+off2) && (int64(off1)+off2)%4 == 0) {
 			break
 		}
 		v.reset(OpPPC64MOVDload)
-		v.AuxInt = off1 + off2
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
 		v.AddArg2(x, mem)
 		return true
 	}
@@ -7675,10 +7773,10 @@ func rewriteValuePPC64_OpPPC64MOVDload(v *Value) bool {
 	// cond: sym == nil && p.Uses == 1
 	// result: (MOVDloadidx ptr idx mem)
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt32(v.AuxInt) != 0 {
 			break
 		}
-		sym := v.Aux
+		sym := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64ADD {
 			break
@@ -7701,37 +7799,37 @@ func rewriteValuePPC64_OpPPC64MOVDloadidx(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (MOVDloadidx ptr (MOVDconst [c]) mem)
 	// cond: is16Bit(c) && c%4 == 0
-	// result: (MOVDload [c] ptr mem)
+	// result: (MOVDload [int32(c)] ptr mem)
 	for {
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		mem := v_2
 		if !(is16Bit(c) && c%4 == 0) {
 			break
 		}
 		v.reset(OpPPC64MOVDload)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg2(ptr, mem)
 		return true
 	}
 	// match: (MOVDloadidx (MOVDconst [c]) ptr mem)
 	// cond: is16Bit(c) && c%4 == 0
-	// result: (MOVDload [c] ptr mem)
+	// result: (MOVDload [int32(c)] ptr mem)
 	for {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		ptr := v_1
 		mem := v_2
 		if !(is16Bit(c) && c%4 == 0) {
 			break
 		}
 		v.reset(OpPPC64MOVDload)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -7744,8 +7842,8 @@ func rewriteValuePPC64_OpPPC64MOVDstore(v *Value) bool {
 	// match: (MOVDstore [off] {sym} ptr (MFVSRD x) mem)
 	// result: (FMOVDstore [off] {sym} ptr x mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MFVSRD {
 			break
@@ -7753,45 +7851,45 @@ func rewriteValuePPC64_OpPPC64MOVDstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64FMOVDstore)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
 	// match: (MOVDstore [off1] {sym} (ADDconst [off2] x) val mem)
-	// cond: is16Bit(off1+off2) && (off1+off2)%4 == 0
-	// result: (MOVDstore [off1+off2] {sym} x val mem)
+	// cond: is16Bit(int64(off1)+off2) && (int64(off1)+off2)%4 == 0
+	// result: (MOVDstore [off1+int32(off2)] {sym} x val mem)
 	for {
-		off1 := v.AuxInt
-		sym := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		off2 := v_0.AuxInt
+		off2 := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		val := v_1
 		mem := v_2
-		if !(is16Bit(off1+off2) && (off1+off2)%4 == 0) {
+		if !(is16Bit(int64(off1)+off2) && (int64(off1)+off2)%4 == 0) {
 			break
 		}
 		v.reset(OpPPC64MOVDstore)
-		v.AuxInt = off1 + off2
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
 		v.AddArg3(x, val, mem)
 		return true
 	}
 	// match: (MOVDstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem)
 	// cond: canMergeSym(sym1,sym2) && (ptr.Op != OpSB || p.Uses == 1) && (off1+off2)%4 == 0
-	// result: (MOVDstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
+	// result: (MOVDstore [off1+off2] {mergeSymTyped(sym1,sym2)} ptr val mem)
 	for {
-		off1 := v.AuxInt
-		sym1 := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64MOVDaddr {
 			break
 		}
-		off2 := p.AuxInt
-		sym2 := p.Aux
+		off2 := auxIntToInt32(p.AuxInt)
+		sym2 := auxToSym(p.Aux)
 		ptr := p.Args[0]
 		val := v_1
 		mem := v_2
@@ -7799,24 +7897,24 @@ func rewriteValuePPC64_OpPPC64MOVDstore(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDstore)
-		v.AuxInt = off1 + off2
-		v.Aux = mergeSym(sym1, sym2)
+		v.AuxInt = int32ToAuxInt(off1 + off2)
+		v.Aux = symToAux(mergeSymTyped(sym1, sym2))
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
 	// match: (MOVDstore [off] {sym} ptr (MOVDconst [0]) mem)
 	// result: (MOVDstorezero [off] {sym} ptr mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
-		if v_1.Op != OpPPC64MOVDconst || v_1.AuxInt != 0 {
+		if v_1.Op != OpPPC64MOVDconst || auxIntToInt64(v_1.AuxInt) != 0 {
 			break
 		}
 		mem := v_2
 		v.reset(OpPPC64MOVDstorezero)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -7824,10 +7922,10 @@ func rewriteValuePPC64_OpPPC64MOVDstore(v *Value) bool {
 	// cond: sym == nil && p.Uses == 1
 	// result: (MOVDstoreidx ptr idx val mem)
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt32(v.AuxInt) != 0 {
 			break
 		}
-		sym := v.Aux
+		sym := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64ADD {
 			break
@@ -7852,31 +7950,31 @@ func rewriteValuePPC64_OpPPC64MOVDstoreidx(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (MOVDstoreidx ptr (MOVDconst [c]) val mem)
 	// cond: is16Bit(c) && c%4 == 0
-	// result: (MOVDstore [c] ptr val mem)
+	// result: (MOVDstore [int32(c)] ptr val mem)
 	for {
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		val := v_2
 		mem := v_3
 		if !(is16Bit(c) && c%4 == 0) {
 			break
 		}
 		v.reset(OpPPC64MOVDstore)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
 	// match: (MOVDstoreidx (MOVDconst [c]) ptr val mem)
 	// cond: is16Bit(c) && c%4 == 0
-	// result: (MOVDstore [c] ptr val mem)
+	// result: (MOVDstore [int32(c)] ptr val mem)
 	for {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		ptr := v_1
 		val := v_2
 		mem := v_3
@@ -7884,7 +7982,7 @@ func rewriteValuePPC64_OpPPC64MOVDstoreidx(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDstore)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
@@ -7894,23 +7992,23 @@ func rewriteValuePPC64_OpPPC64MOVDstorezero(v *Value) bool {
 	v_1 := v.Args[1]
 	v_0 := v.Args[0]
 	// match: (MOVDstorezero [off1] {sym} (ADDconst [off2] x) mem)
-	// cond: is16Bit(off1+off2) && (off1+off2)%4 == 0
-	// result: (MOVDstorezero [off1+off2] {sym} x mem)
+	// cond: is16Bit(int64(off1)+off2) && (int64(off1)+off2)%4 == 0
+	// result: (MOVDstorezero [off1+int32(off2)] {sym} x mem)
 	for {
-		off1 := v.AuxInt
-		sym := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		off2 := v_0.AuxInt
+		off2 := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		mem := v_1
-		if !(is16Bit(off1+off2) && (off1+off2)%4 == 0) {
+		if !(is16Bit(int64(off1)+off2) && (int64(off1)+off2)%4 == 0) {
 			break
 		}
 		v.reset(OpPPC64MOVDstorezero)
-		v.AuxInt = off1 + off2
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
 		v.AddArg2(x, mem)
 		return true
 	}
@@ -7946,7 +8044,7 @@ func rewriteValuePPC64_OpPPC64MOVHBRstore(v *Value) bool {
 	// match: (MOVHBRstore {sym} ptr (MOVHreg x) mem)
 	// result: (MOVHBRstore {sym} ptr x mem)
 	for {
-		sym := v.Aux
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVHreg {
 			break
@@ -7954,14 +8052,14 @@ func rewriteValuePPC64_OpPPC64MOVHBRstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVHBRstore)
-		v.Aux = sym
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
 	// match: (MOVHBRstore {sym} ptr (MOVHZreg x) mem)
 	// result: (MOVHBRstore {sym} ptr x mem)
 	for {
-		sym := v.Aux
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVHZreg {
 			break
@@ -7969,14 +8067,14 @@ func rewriteValuePPC64_OpPPC64MOVHBRstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVHBRstore)
-		v.Aux = sym
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
 	// match: (MOVHBRstore {sym} ptr (MOVWreg x) mem)
 	// result: (MOVHBRstore {sym} ptr x mem)
 	for {
-		sym := v.Aux
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVWreg {
 			break
@@ -7984,14 +8082,14 @@ func rewriteValuePPC64_OpPPC64MOVHBRstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVHBRstore)
-		v.Aux = sym
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
 	// match: (MOVHBRstore {sym} ptr (MOVWZreg x) mem)
 	// result: (MOVHBRstore {sym} ptr x mem)
 	for {
-		sym := v.Aux
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVWZreg {
 			break
@@ -7999,7 +8097,7 @@ func rewriteValuePPC64_OpPPC64MOVHBRstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVHBRstore)
-		v.Aux = sym
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
@@ -8010,45 +8108,45 @@ func rewriteValuePPC64_OpPPC64MOVHZload(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (MOVHZload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
 	// cond: canMergeSym(sym1,sym2) && (ptr.Op != OpSB || p.Uses == 1)
-	// result: (MOVHZload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
+	// result: (MOVHZload [off1+off2] {mergeSymTyped(sym1,sym2)} ptr mem)
 	for {
-		off1 := v.AuxInt
-		sym1 := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64MOVDaddr {
 			break
 		}
-		off2 := p.AuxInt
-		sym2 := p.Aux
+		off2 := auxIntToInt32(p.AuxInt)
+		sym2 := auxToSym(p.Aux)
 		ptr := p.Args[0]
 		mem := v_1
 		if !(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1)) {
 			break
 		}
 		v.reset(OpPPC64MOVHZload)
-		v.AuxInt = off1 + off2
-		v.Aux = mergeSym(sym1, sym2)
+		v.AuxInt = int32ToAuxInt(off1 + off2)
+		v.Aux = symToAux(mergeSymTyped(sym1, sym2))
 		v.AddArg2(ptr, mem)
 		return true
 	}
 	// match: (MOVHZload [off1] {sym} (ADDconst [off2] x) mem)
-	// cond: is16Bit(off1+off2)
-	// result: (MOVHZload [off1+off2] {sym} x mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVHZload [off1+int32(off2)] {sym} x mem)
 	for {
-		off1 := v.AuxInt
-		sym := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		off2 := v_0.AuxInt
+		off2 := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		mem := v_1
-		if !(is16Bit(off1 + off2)) {
+		if !(is16Bit(int64(off1) + off2)) {
 			break
 		}
 		v.reset(OpPPC64MOVHZload)
-		v.AuxInt = off1 + off2
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
 		v.AddArg2(x, mem)
 		return true
 	}
@@ -8056,10 +8154,10 @@ func rewriteValuePPC64_OpPPC64MOVHZload(v *Value) bool {
 	// cond: sym == nil && p.Uses == 1
 	// result: (MOVHZloadidx ptr idx mem)
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt32(v.AuxInt) != 0 {
 			break
 		}
-		sym := v.Aux
+		sym := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64ADD {
 			break
@@ -8082,37 +8180,37 @@ func rewriteValuePPC64_OpPPC64MOVHZloadidx(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (MOVHZloadidx ptr (MOVDconst [c]) mem)
 	// cond: is16Bit(c)
-	// result: (MOVHZload [c] ptr mem)
+	// result: (MOVHZload [int32(c)] ptr mem)
 	for {
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		mem := v_2
 		if !(is16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64MOVHZload)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg2(ptr, mem)
 		return true
 	}
 	// match: (MOVHZloadidx (MOVDconst [c]) ptr mem)
 	// cond: is16Bit(c)
-	// result: (MOVHZload [c] ptr mem)
+	// result: (MOVHZload [int32(c)] ptr mem)
 	for {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		ptr := v_1
 		mem := v_2
 		if !(is16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64MOVHZload)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -8130,7 +8228,7 @@ func rewriteValuePPC64_OpPPC64MOVHZreg(v *Value) bool {
 		if y.Op != OpPPC64ANDconst {
 			break
 		}
-		c := y.AuxInt
+		c := auxIntToInt64(y.AuxInt)
 		if !(uint64(c) <= 0xFFFF) {
 			break
 		}
@@ -8143,14 +8241,14 @@ func rewriteValuePPC64_OpPPC64MOVHZreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v_0_0 := v_0.Args[0]
 		if v_0_0.Op != OpPPC64MOVBZreg {
 			break
 		}
 		x := v_0_0.Args[0]
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVBZreg, typ.Int64)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -8162,14 +8260,14 @@ func rewriteValuePPC64_OpPPC64MOVHZreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v_0_0 := v_0.Args[0]
 		if v_0_0.Op != OpPPC64MOVHZreg {
 			break
 		}
 		x := v_0_0.Args[0]
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVHZreg, typ.Int64)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -8182,13 +8280,13 @@ func rewriteValuePPC64_OpPPC64MOVHZreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(sizeof(x.Type) <= 16) {
 			break
 		}
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -8199,13 +8297,13 @@ func rewriteValuePPC64_OpPPC64MOVHZreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c >= 48) {
 			break
 		}
 		v.reset(OpPPC64SRDconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -8216,13 +8314,13 @@ func rewriteValuePPC64_OpPPC64MOVHZreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c >= 16) {
 			break
 		}
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -8329,9 +8427,9 @@ func rewriteValuePPC64_OpPPC64MOVHZreg(v *Value) bool {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = int64(uint16(c))
+		v.AuxInt = int64ToAuxInt(int64(uint16(c)))
 		return true
 	}
 	return false
@@ -8341,45 +8439,45 @@ func rewriteValuePPC64_OpPPC64MOVHload(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (MOVHload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
 	// cond: canMergeSym(sym1,sym2) && (ptr.Op != OpSB || p.Uses == 1)
-	// result: (MOVHload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
+	// result: (MOVHload [off1+off2] {mergeSymTyped(sym1,sym2)} ptr mem)
 	for {
-		off1 := v.AuxInt
-		sym1 := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64MOVDaddr {
 			break
 		}
-		off2 := p.AuxInt
-		sym2 := p.Aux
+		off2 := auxIntToInt32(p.AuxInt)
+		sym2 := auxToSym(p.Aux)
 		ptr := p.Args[0]
 		mem := v_1
 		if !(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1)) {
 			break
 		}
 		v.reset(OpPPC64MOVHload)
-		v.AuxInt = off1 + off2
-		v.Aux = mergeSym(sym1, sym2)
+		v.AuxInt = int32ToAuxInt(off1 + off2)
+		v.Aux = symToAux(mergeSymTyped(sym1, sym2))
 		v.AddArg2(ptr, mem)
 		return true
 	}
 	// match: (MOVHload [off1] {sym} (ADDconst [off2] x) mem)
-	// cond: is16Bit(off1+off2)
-	// result: (MOVHload [off1+off2] {sym} x mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVHload [off1+int32(off2)] {sym} x mem)
 	for {
-		off1 := v.AuxInt
-		sym := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		off2 := v_0.AuxInt
+		off2 := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		mem := v_1
-		if !(is16Bit(off1 + off2)) {
+		if !(is16Bit(int64(off1) + off2)) {
 			break
 		}
 		v.reset(OpPPC64MOVHload)
-		v.AuxInt = off1 + off2
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
 		v.AddArg2(x, mem)
 		return true
 	}
@@ -8387,10 +8485,10 @@ func rewriteValuePPC64_OpPPC64MOVHload(v *Value) bool {
 	// cond: sym == nil && p.Uses == 1
 	// result: (MOVHloadidx ptr idx mem)
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt32(v.AuxInt) != 0 {
 			break
 		}
-		sym := v.Aux
+		sym := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64ADD {
 			break
@@ -8413,37 +8511,37 @@ func rewriteValuePPC64_OpPPC64MOVHloadidx(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (MOVHloadidx ptr (MOVDconst [c]) mem)
 	// cond: is16Bit(c)
-	// result: (MOVHload [c] ptr mem)
+	// result: (MOVHload [int32(c)] ptr mem)
 	for {
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		mem := v_2
 		if !(is16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64MOVHload)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg2(ptr, mem)
 		return true
 	}
 	// match: (MOVHloadidx (MOVDconst [c]) ptr mem)
 	// cond: is16Bit(c)
-	// result: (MOVHload [c] ptr mem)
+	// result: (MOVHload [int32(c)] ptr mem)
 	for {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		ptr := v_1
 		mem := v_2
 		if !(is16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64MOVHload)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -8461,7 +8559,7 @@ func rewriteValuePPC64_OpPPC64MOVHreg(v *Value) bool {
 		if y.Op != OpPPC64ANDconst {
 			break
 		}
-		c := y.AuxInt
+		c := auxIntToInt64(y.AuxInt)
 		if !(uint64(c) <= 0x7FFF) {
 			break
 		}
@@ -8474,14 +8572,14 @@ func rewriteValuePPC64_OpPPC64MOVHreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRAWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v_0_0 := v_0.Args[0]
 		if v_0_0.Op != OpPPC64MOVBreg {
 			break
 		}
 		x := v_0_0.Args[0]
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVBreg, typ.Int64)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -8493,14 +8591,14 @@ func rewriteValuePPC64_OpPPC64MOVHreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRAWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v_0_0 := v_0.Args[0]
 		if v_0_0.Op != OpPPC64MOVHreg {
 			break
 		}
 		x := v_0_0.Args[0]
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVHreg, typ.Int64)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -8513,13 +8611,13 @@ func rewriteValuePPC64_OpPPC64MOVHreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRAWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(sizeof(x.Type) <= 16) {
 			break
 		}
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -8530,13 +8628,13 @@ func rewriteValuePPC64_OpPPC64MOVHreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c > 48) {
 			break
 		}
 		v.reset(OpPPC64SRDconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -8547,13 +8645,13 @@ func rewriteValuePPC64_OpPPC64MOVHreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c == 48) {
 			break
 		}
 		v.reset(OpPPC64SRADconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -8564,13 +8662,13 @@ func rewriteValuePPC64_OpPPC64MOVHreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRADconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c >= 48) {
 			break
 		}
 		v.reset(OpPPC64SRADconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -8581,13 +8679,13 @@ func rewriteValuePPC64_OpPPC64MOVHreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c > 16) {
 			break
 		}
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -8598,13 +8696,13 @@ func rewriteValuePPC64_OpPPC64MOVHreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRAWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c >= 16) {
 			break
 		}
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -8615,13 +8713,13 @@ func rewriteValuePPC64_OpPPC64MOVHreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c == 16) {
 			break
 		}
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -8698,9 +8796,9 @@ func rewriteValuePPC64_OpPPC64MOVHreg(v *Value) bool {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = int64(int16(c))
+		v.AuxInt = int64ToAuxInt(int64(int16(c)))
 		return true
 	}
 	return false
@@ -8712,39 +8810,39 @@ func rewriteValuePPC64_OpPPC64MOVHstore(v *Value) bool {
 	b := v.Block
 	config := b.Func.Config
 	// match: (MOVHstore [off1] {sym} (ADDconst [off2] x) val mem)
-	// cond: is16Bit(off1+off2)
-	// result: (MOVHstore [off1+off2] {sym} x val mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVHstore [off1+int32(off2)] {sym} x val mem)
 	for {
-		off1 := v.AuxInt
-		sym := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		off2 := v_0.AuxInt
+		off2 := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		val := v_1
 		mem := v_2
-		if !(is16Bit(off1 + off2)) {
+		if !(is16Bit(int64(off1) + off2)) {
 			break
 		}
 		v.reset(OpPPC64MOVHstore)
-		v.AuxInt = off1 + off2
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
 		v.AddArg3(x, val, mem)
 		return true
 	}
 	// match: (MOVHstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem)
 	// cond: canMergeSym(sym1,sym2) && (ptr.Op != OpSB || p.Uses == 1)
-	// result: (MOVHstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
+	// result: (MOVHstore [off1+off2] {mergeSymTyped(sym1,sym2)} ptr val mem)
 	for {
-		off1 := v.AuxInt
-		sym1 := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64MOVDaddr {
 			break
 		}
-		off2 := p.AuxInt
-		sym2 := p.Aux
+		off2 := auxIntToInt32(p.AuxInt)
+		sym2 := auxToSym(p.Aux)
 		ptr := p.Args[0]
 		val := v_1
 		mem := v_2
@@ -8752,24 +8850,24 @@ func rewriteValuePPC64_OpPPC64MOVHstore(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVHstore)
-		v.AuxInt = off1 + off2
-		v.Aux = mergeSym(sym1, sym2)
+		v.AuxInt = int32ToAuxInt(off1 + off2)
+		v.Aux = symToAux(mergeSymTyped(sym1, sym2))
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
 	// match: (MOVHstore [off] {sym} ptr (MOVDconst [0]) mem)
 	// result: (MOVHstorezero [off] {sym} ptr mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
-		if v_1.Op != OpPPC64MOVDconst || v_1.AuxInt != 0 {
+		if v_1.Op != OpPPC64MOVDconst || auxIntToInt64(v_1.AuxInt) != 0 {
 			break
 		}
 		mem := v_2
 		v.reset(OpPPC64MOVHstorezero)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -8777,10 +8875,10 @@ func rewriteValuePPC64_OpPPC64MOVHstore(v *Value) bool {
 	// cond: sym == nil && p.Uses == 1
 	// result: (MOVHstoreidx ptr idx val mem)
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt32(v.AuxInt) != 0 {
 			break
 		}
-		sym := v.Aux
+		sym := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64ADD {
 			break
@@ -8799,8 +8897,8 @@ func rewriteValuePPC64_OpPPC64MOVHstore(v *Value) bool {
 	// match: (MOVHstore [off] {sym} ptr (MOVHreg x) mem)
 	// result: (MOVHstore [off] {sym} ptr x mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVHreg {
 			break
@@ -8808,16 +8906,16 @@ func rewriteValuePPC64_OpPPC64MOVHstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVHstore)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
 	// match: (MOVHstore [off] {sym} ptr (MOVHZreg x) mem)
 	// result: (MOVHstore [off] {sym} ptr x mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVHZreg {
 			break
@@ -8825,16 +8923,16 @@ func rewriteValuePPC64_OpPPC64MOVHstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVHstore)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
 	// match: (MOVHstore [off] {sym} ptr (MOVWreg x) mem)
 	// result: (MOVHstore [off] {sym} ptr x mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVWreg {
 			break
@@ -8842,16 +8940,16 @@ func rewriteValuePPC64_OpPPC64MOVHstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVHstore)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
 	// match: (MOVHstore [off] {sym} ptr (MOVWZreg x) mem)
 	// result: (MOVHstore [off] {sym} ptr x mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVWZreg {
 			break
@@ -8859,8 +8957,8 @@ func rewriteValuePPC64_OpPPC64MOVHstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVHstore)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
@@ -8868,10 +8966,10 @@ func rewriteValuePPC64_OpPPC64MOVHstore(v *Value) bool {
 	// cond: !config.BigEndian && x0.Uses == 1 && i1 == i0+2 && clobber(x0)
 	// result: (MOVWstore [i0] {s} p w mem)
 	for {
-		i1 := v.AuxInt
-		s := v.Aux
+		i1 := auxIntToInt32(v.AuxInt)
+		s := auxToSym(v.Aux)
 		p := v_0
-		if v_1.Op != OpPPC64SRWconst || v_1.AuxInt != 16 {
+		if v_1.Op != OpPPC64SRWconst || auxIntToInt64(v_1.AuxInt) != 16 {
 			break
 		}
 		w := v_1.Args[0]
@@ -8879,8 +8977,8 @@ func rewriteValuePPC64_OpPPC64MOVHstore(v *Value) bool {
 		if x0.Op != OpPPC64MOVHstore {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		i0 := auxIntToInt32(x0.AuxInt)
+		if auxToSym(x0.Aux) != s {
 			break
 		}
 		mem := x0.Args[2]
@@ -8888,8 +8986,8 @@ func rewriteValuePPC64_OpPPC64MOVHstore(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVWstore)
-		v.AuxInt = i0
-		v.Aux = s
+		v.AuxInt = int32ToAuxInt(i0)
+		v.Aux = symToAux(s)
 		v.AddArg3(p, w, mem)
 		return true
 	}
@@ -8897,10 +8995,10 @@ func rewriteValuePPC64_OpPPC64MOVHstore(v *Value) bool {
 	// cond: !config.BigEndian && x0.Uses == 1 && i1 == i0+2 && clobber(x0)
 	// result: (MOVWstore [i0] {s} p w mem)
 	for {
-		i1 := v.AuxInt
-		s := v.Aux
+		i1 := auxIntToInt32(v.AuxInt)
+		s := auxToSym(v.Aux)
 		p := v_0
-		if v_1.Op != OpPPC64SRDconst || v_1.AuxInt != 16 {
+		if v_1.Op != OpPPC64SRDconst || auxIntToInt64(v_1.AuxInt) != 16 {
 			break
 		}
 		w := v_1.Args[0]
@@ -8908,8 +9006,8 @@ func rewriteValuePPC64_OpPPC64MOVHstore(v *Value) bool {
 		if x0.Op != OpPPC64MOVHstore {
 			break
 		}
-		i0 := x0.AuxInt
-		if x0.Aux != s {
+		i0 := auxIntToInt32(x0.AuxInt)
+		if auxToSym(x0.Aux) != s {
 			break
 		}
 		mem := x0.Args[2]
@@ -8917,8 +9015,8 @@ func rewriteValuePPC64_OpPPC64MOVHstore(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVWstore)
-		v.AuxInt = i0
-		v.Aux = s
+		v.AuxInt = int32ToAuxInt(i0)
+		v.Aux = symToAux(s)
 		v.AddArg3(p, w, mem)
 		return true
 	}
@@ -8931,31 +9029,31 @@ func rewriteValuePPC64_OpPPC64MOVHstoreidx(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (MOVHstoreidx ptr (MOVDconst [c]) val mem)
 	// cond: is16Bit(c)
-	// result: (MOVHstore [c] ptr val mem)
+	// result: (MOVHstore [int32(c)] ptr val mem)
 	for {
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		val := v_2
 		mem := v_3
 		if !(is16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64MOVHstore)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
 	// match: (MOVHstoreidx (MOVDconst [c]) ptr val mem)
 	// cond: is16Bit(c)
-	// result: (MOVHstore [c] ptr val mem)
+	// result: (MOVHstore [int32(c)] ptr val mem)
 	for {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		ptr := v_1
 		val := v_2
 		mem := v_3
@@ -8963,7 +9061,7 @@ func rewriteValuePPC64_OpPPC64MOVHstoreidx(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVHstore)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
@@ -9029,23 +9127,23 @@ func rewriteValuePPC64_OpPPC64MOVHstorezero(v *Value) bool {
 	v_1 := v.Args[1]
 	v_0 := v.Args[0]
 	// match: (MOVHstorezero [off1] {sym} (ADDconst [off2] x) mem)
-	// cond: is16Bit(off1+off2)
-	// result: (MOVHstorezero [off1+off2] {sym} x mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVHstorezero [off1+int32(off2)] {sym} x mem)
 	for {
-		off1 := v.AuxInt
-		sym := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		off2 := v_0.AuxInt
+		off2 := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		mem := v_1
-		if !(is16Bit(off1 + off2)) {
+		if !(is16Bit(int64(off1) + off2)) {
 			break
 		}
 		v.reset(OpPPC64MOVHstorezero)
-		v.AuxInt = off1 + off2
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
 		v.AddArg2(x, mem)
 		return true
 	}
@@ -9081,7 +9179,7 @@ func rewriteValuePPC64_OpPPC64MOVWBRstore(v *Value) bool {
 	// match: (MOVWBRstore {sym} ptr (MOVWreg x) mem)
 	// result: (MOVWBRstore {sym} ptr x mem)
 	for {
-		sym := v.Aux
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVWreg {
 			break
@@ -9089,14 +9187,14 @@ func rewriteValuePPC64_OpPPC64MOVWBRstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVWBRstore)
-		v.Aux = sym
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
 	// match: (MOVWBRstore {sym} ptr (MOVWZreg x) mem)
 	// result: (MOVWBRstore {sym} ptr x mem)
 	for {
-		sym := v.Aux
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVWZreg {
 			break
@@ -9104,7 +9202,7 @@ func rewriteValuePPC64_OpPPC64MOVWBRstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVWBRstore)
-		v.Aux = sym
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
@@ -9115,45 +9213,45 @@ func rewriteValuePPC64_OpPPC64MOVWZload(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (MOVWZload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
 	// cond: canMergeSym(sym1,sym2) && (ptr.Op != OpSB || p.Uses == 1)
-	// result: (MOVWZload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
+	// result: (MOVWZload [off1+off2] {mergeSymTyped(sym1,sym2)} ptr mem)
 	for {
-		off1 := v.AuxInt
-		sym1 := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64MOVDaddr {
 			break
 		}
-		off2 := p.AuxInt
-		sym2 := p.Aux
+		off2 := auxIntToInt32(p.AuxInt)
+		sym2 := auxToSym(p.Aux)
 		ptr := p.Args[0]
 		mem := v_1
 		if !(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1)) {
 			break
 		}
 		v.reset(OpPPC64MOVWZload)
-		v.AuxInt = off1 + off2
-		v.Aux = mergeSym(sym1, sym2)
+		v.AuxInt = int32ToAuxInt(off1 + off2)
+		v.Aux = symToAux(mergeSymTyped(sym1, sym2))
 		v.AddArg2(ptr, mem)
 		return true
 	}
 	// match: (MOVWZload [off1] {sym} (ADDconst [off2] x) mem)
-	// cond: is16Bit(off1+off2)
-	// result: (MOVWZload [off1+off2] {sym} x mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVWZload [off1+int32(off2)] {sym} x mem)
 	for {
-		off1 := v.AuxInt
-		sym := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		off2 := v_0.AuxInt
+		off2 := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		mem := v_1
-		if !(is16Bit(off1 + off2)) {
+		if !(is16Bit(int64(off1) + off2)) {
 			break
 		}
 		v.reset(OpPPC64MOVWZload)
-		v.AuxInt = off1 + off2
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
 		v.AddArg2(x, mem)
 		return true
 	}
@@ -9161,10 +9259,10 @@ func rewriteValuePPC64_OpPPC64MOVWZload(v *Value) bool {
 	// cond: sym == nil && p.Uses == 1
 	// result: (MOVWZloadidx ptr idx mem)
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt32(v.AuxInt) != 0 {
 			break
 		}
-		sym := v.Aux
+		sym := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64ADD {
 			break
@@ -9187,37 +9285,37 @@ func rewriteValuePPC64_OpPPC64MOVWZloadidx(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (MOVWZloadidx ptr (MOVDconst [c]) mem)
 	// cond: is16Bit(c)
-	// result: (MOVWZload [c] ptr mem)
+	// result: (MOVWZload [int32(c)] ptr mem)
 	for {
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		mem := v_2
 		if !(is16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64MOVWZload)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg2(ptr, mem)
 		return true
 	}
 	// match: (MOVWZloadidx (MOVDconst [c]) ptr mem)
 	// cond: is16Bit(c)
-	// result: (MOVWZload [c] ptr mem)
+	// result: (MOVWZload [int32(c)] ptr mem)
 	for {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		ptr := v_1
 		mem := v_2
 		if !(is16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64MOVWZload)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -9235,7 +9333,7 @@ func rewriteValuePPC64_OpPPC64MOVWZreg(v *Value) bool {
 		if y.Op != OpPPC64ANDconst {
 			break
 		}
-		c := y.AuxInt
+		c := auxIntToInt64(y.AuxInt)
 		if !(uint64(c) <= 0xFFFFFFFF) {
 			break
 		}
@@ -9256,7 +9354,7 @@ func rewriteValuePPC64_OpPPC64MOVWZreg(v *Value) bool {
 			if y_0.Op != OpPPC64MOVDconst {
 				continue
 			}
-			c := y_0.AuxInt
+			c := auxIntToInt64(y_0.AuxInt)
 			if !(uint64(c) <= 0xFFFFFFFF) {
 				continue
 			}
@@ -9271,14 +9369,14 @@ func rewriteValuePPC64_OpPPC64MOVWZreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v_0_0 := v_0.Args[0]
 		if v_0_0.Op != OpPPC64MOVBZreg {
 			break
 		}
 		x := v_0_0.Args[0]
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVBZreg, typ.Int64)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -9290,14 +9388,14 @@ func rewriteValuePPC64_OpPPC64MOVWZreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v_0_0 := v_0.Args[0]
 		if v_0_0.Op != OpPPC64MOVHZreg {
 			break
 		}
 		x := v_0_0.Args[0]
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVHZreg, typ.Int64)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -9309,14 +9407,14 @@ func rewriteValuePPC64_OpPPC64MOVWZreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v_0_0 := v_0.Args[0]
 		if v_0_0.Op != OpPPC64MOVWZreg {
 			break
 		}
 		x := v_0_0.Args[0]
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVWZreg, typ.Int64)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -9329,13 +9427,13 @@ func rewriteValuePPC64_OpPPC64MOVWZreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(sizeof(x.Type) <= 32) {
 			break
 		}
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -9346,13 +9444,13 @@ func rewriteValuePPC64_OpPPC64MOVWZreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c >= 32) {
 			break
 		}
 		v.reset(OpPPC64SRDconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -9499,9 +9597,9 @@ func rewriteValuePPC64_OpPPC64MOVWZreg(v *Value) bool {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = int64(uint32(c))
+		v.AuxInt = int64ToAuxInt(int64(uint32(c)))
 		return true
 	}
 	return false
@@ -9511,45 +9609,45 @@ func rewriteValuePPC64_OpPPC64MOVWload(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (MOVWload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
 	// cond: canMergeSym(sym1,sym2) && (ptr.Op != OpSB || p.Uses == 1) && (off1+off2)%4 == 0
-	// result: (MOVWload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
+	// result: (MOVWload [off1+off2] {mergeSymTyped(sym1,sym2)} ptr mem)
 	for {
-		off1 := v.AuxInt
-		sym1 := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64MOVDaddr {
 			break
 		}
-		off2 := p.AuxInt
-		sym2 := p.Aux
+		off2 := auxIntToInt32(p.AuxInt)
+		sym2 := auxToSym(p.Aux)
 		ptr := p.Args[0]
 		mem := v_1
 		if !(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1) && (off1+off2)%4 == 0) {
 			break
 		}
 		v.reset(OpPPC64MOVWload)
-		v.AuxInt = off1 + off2
-		v.Aux = mergeSym(sym1, sym2)
+		v.AuxInt = int32ToAuxInt(off1 + off2)
+		v.Aux = symToAux(mergeSymTyped(sym1, sym2))
 		v.AddArg2(ptr, mem)
 		return true
 	}
 	// match: (MOVWload [off1] {sym} (ADDconst [off2] x) mem)
-	// cond: is16Bit(off1+off2) && (off1+off2)%4 == 0
-	// result: (MOVWload [off1+off2] {sym} x mem)
+	// cond: is16Bit(int64(off1)+off2) && (int64(off1)+off2)%4 == 0
+	// result: (MOVWload [off1+int32(off2)] {sym} x mem)
 	for {
-		off1 := v.AuxInt
-		sym := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		off2 := v_0.AuxInt
+		off2 := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		mem := v_1
-		if !(is16Bit(off1+off2) && (off1+off2)%4 == 0) {
+		if !(is16Bit(int64(off1)+off2) && (int64(off1)+off2)%4 == 0) {
 			break
 		}
 		v.reset(OpPPC64MOVWload)
-		v.AuxInt = off1 + off2
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
 		v.AddArg2(x, mem)
 		return true
 	}
@@ -9557,10 +9655,10 @@ func rewriteValuePPC64_OpPPC64MOVWload(v *Value) bool {
 	// cond: sym == nil && p.Uses == 1
 	// result: (MOVWloadidx ptr idx mem)
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt32(v.AuxInt) != 0 {
 			break
 		}
-		sym := v.Aux
+		sym := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64ADD {
 			break
@@ -9583,37 +9681,37 @@ func rewriteValuePPC64_OpPPC64MOVWloadidx(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (MOVWloadidx ptr (MOVDconst [c]) mem)
 	// cond: is16Bit(c) && c%4 == 0
-	// result: (MOVWload [c] ptr mem)
+	// result: (MOVWload [int32(c)] ptr mem)
 	for {
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		mem := v_2
 		if !(is16Bit(c) && c%4 == 0) {
 			break
 		}
 		v.reset(OpPPC64MOVWload)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg2(ptr, mem)
 		return true
 	}
 	// match: (MOVWloadidx (MOVDconst [c]) ptr mem)
 	// cond: is16Bit(c) && c%4 == 0
-	// result: (MOVWload [c] ptr mem)
+	// result: (MOVWload [int32(c)] ptr mem)
 	for {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		ptr := v_1
 		mem := v_2
 		if !(is16Bit(c) && c%4 == 0) {
 			break
 		}
 		v.reset(OpPPC64MOVWload)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -9631,7 +9729,7 @@ func rewriteValuePPC64_OpPPC64MOVWreg(v *Value) bool {
 		if y.Op != OpPPC64ANDconst {
 			break
 		}
-		c := y.AuxInt
+		c := auxIntToInt64(y.AuxInt)
 		if !(uint64(c) <= 0xFFFF) {
 			break
 		}
@@ -9652,7 +9750,7 @@ func rewriteValuePPC64_OpPPC64MOVWreg(v *Value) bool {
 			if y_0.Op != OpPPC64MOVDconst {
 				continue
 			}
-			c := y_0.AuxInt
+			c := auxIntToInt64(y_0.AuxInt)
 			if !(uint64(c) <= 0x7FFFFFFF) {
 				continue
 			}
@@ -9667,14 +9765,14 @@ func rewriteValuePPC64_OpPPC64MOVWreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRAWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v_0_0 := v_0.Args[0]
 		if v_0_0.Op != OpPPC64MOVBreg {
 			break
 		}
 		x := v_0_0.Args[0]
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVBreg, typ.Int64)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -9686,14 +9784,14 @@ func rewriteValuePPC64_OpPPC64MOVWreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRAWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v_0_0 := v_0.Args[0]
 		if v_0_0.Op != OpPPC64MOVHreg {
 			break
 		}
 		x := v_0_0.Args[0]
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVHreg, typ.Int64)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -9705,14 +9803,14 @@ func rewriteValuePPC64_OpPPC64MOVWreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRAWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v_0_0 := v_0.Args[0]
 		if v_0_0.Op != OpPPC64MOVWreg {
 			break
 		}
 		x := v_0_0.Args[0]
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVWreg, typ.Int64)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -9725,13 +9823,13 @@ func rewriteValuePPC64_OpPPC64MOVWreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRAWconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(sizeof(x.Type) <= 32) {
 			break
 		}
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -9742,13 +9840,13 @@ func rewriteValuePPC64_OpPPC64MOVWreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c > 32) {
 			break
 		}
 		v.reset(OpPPC64SRDconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -9759,13 +9857,13 @@ func rewriteValuePPC64_OpPPC64MOVWreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRADconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c >= 32) {
 			break
 		}
 		v.reset(OpPPC64SRADconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -9776,13 +9874,13 @@ func rewriteValuePPC64_OpPPC64MOVWreg(v *Value) bool {
 		if v_0.Op != OpPPC64SRDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		if !(c == 32) {
 			break
 		}
 		v.reset(OpPPC64SRADconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -9889,9 +9987,9 @@ func rewriteValuePPC64_OpPPC64MOVWreg(v *Value) bool {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = int64(int32(c))
+		v.AuxInt = int64ToAuxInt(int64(int32(c)))
 		return true
 	}
 	return false
@@ -9901,39 +9999,39 @@ func rewriteValuePPC64_OpPPC64MOVWstore(v *Value) bool {
 	v_1 := v.Args[1]
 	v_0 := v.Args[0]
 	// match: (MOVWstore [off1] {sym} (ADDconst [off2] x) val mem)
-	// cond: is16Bit(off1+off2)
-	// result: (MOVWstore [off1+off2] {sym} x val mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVWstore [off1+int32(off2)] {sym} x val mem)
 	for {
-		off1 := v.AuxInt
-		sym := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		off2 := v_0.AuxInt
+		off2 := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		val := v_1
 		mem := v_2
-		if !(is16Bit(off1 + off2)) {
+		if !(is16Bit(int64(off1) + off2)) {
 			break
 		}
 		v.reset(OpPPC64MOVWstore)
-		v.AuxInt = off1 + off2
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
 		v.AddArg3(x, val, mem)
 		return true
 	}
 	// match: (MOVWstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem)
 	// cond: canMergeSym(sym1,sym2) && (ptr.Op != OpSB || p.Uses == 1)
-	// result: (MOVWstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
+	// result: (MOVWstore [off1+off2] {mergeSymTyped(sym1,sym2)} ptr val mem)
 	for {
-		off1 := v.AuxInt
-		sym1 := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64MOVDaddr {
 			break
 		}
-		off2 := p.AuxInt
-		sym2 := p.Aux
+		off2 := auxIntToInt32(p.AuxInt)
+		sym2 := auxToSym(p.Aux)
 		ptr := p.Args[0]
 		val := v_1
 		mem := v_2
@@ -9941,24 +10039,24 @@ func rewriteValuePPC64_OpPPC64MOVWstore(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVWstore)
-		v.AuxInt = off1 + off2
-		v.Aux = mergeSym(sym1, sym2)
+		v.AuxInt = int32ToAuxInt(off1 + off2)
+		v.Aux = symToAux(mergeSymTyped(sym1, sym2))
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
 	// match: (MOVWstore [off] {sym} ptr (MOVDconst [0]) mem)
 	// result: (MOVWstorezero [off] {sym} ptr mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
-		if v_1.Op != OpPPC64MOVDconst || v_1.AuxInt != 0 {
+		if v_1.Op != OpPPC64MOVDconst || auxIntToInt64(v_1.AuxInt) != 0 {
 			break
 		}
 		mem := v_2
 		v.reset(OpPPC64MOVWstorezero)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -9966,10 +10064,10 @@ func rewriteValuePPC64_OpPPC64MOVWstore(v *Value) bool {
 	// cond: sym == nil && p.Uses == 1
 	// result: (MOVWstoreidx ptr idx val mem)
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt32(v.AuxInt) != 0 {
 			break
 		}
-		sym := v.Aux
+		sym := auxToSym(v.Aux)
 		p := v_0
 		if p.Op != OpPPC64ADD {
 			break
@@ -9988,8 +10086,8 @@ func rewriteValuePPC64_OpPPC64MOVWstore(v *Value) bool {
 	// match: (MOVWstore [off] {sym} ptr (MOVWreg x) mem)
 	// result: (MOVWstore [off] {sym} ptr x mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVWreg {
 			break
@@ -9997,16 +10095,16 @@ func rewriteValuePPC64_OpPPC64MOVWstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVWstore)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
 	// match: (MOVWstore [off] {sym} ptr (MOVWZreg x) mem)
 	// result: (MOVWstore [off] {sym} ptr x mem)
 	for {
-		off := v.AuxInt
-		sym := v.Aux
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVWZreg {
 			break
@@ -10014,8 +10112,8 @@ func rewriteValuePPC64_OpPPC64MOVWstore(v *Value) bool {
 		x := v_1.Args[0]
 		mem := v_2
 		v.reset(OpPPC64MOVWstore)
-		v.AuxInt = off
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
 		v.AddArg3(ptr, x, mem)
 		return true
 	}
@@ -10028,31 +10126,31 @@ func rewriteValuePPC64_OpPPC64MOVWstoreidx(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (MOVWstoreidx ptr (MOVDconst [c]) val mem)
 	// cond: is16Bit(c)
-	// result: (MOVWstore [c] ptr val mem)
+	// result: (MOVWstore [int32(c)] ptr val mem)
 	for {
 		ptr := v_0
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		val := v_2
 		mem := v_3
 		if !(is16Bit(c)) {
 			break
 		}
 		v.reset(OpPPC64MOVWstore)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
 	// match: (MOVWstoreidx (MOVDconst [c]) ptr val mem)
 	// cond: is16Bit(c)
-	// result: (MOVWstore [c] ptr val mem)
+	// result: (MOVWstore [int32(c)] ptr val mem)
 	for {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		ptr := v_1
 		val := v_2
 		mem := v_3
@@ -10060,7 +10158,7 @@ func rewriteValuePPC64_OpPPC64MOVWstoreidx(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVWstore)
-		v.AuxInt = c
+		v.AuxInt = int32ToAuxInt(int32(c))
 		v.AddArg3(ptr, val, mem)
 		return true
 	}
@@ -10098,23 +10196,23 @@ func rewriteValuePPC64_OpPPC64MOVWstorezero(v *Value) bool {
 	v_1 := v.Args[1]
 	v_0 := v.Args[0]
 	// match: (MOVWstorezero [off1] {sym} (ADDconst [off2] x) mem)
-	// cond: is16Bit(off1+off2)
-	// result: (MOVWstorezero [off1+off2] {sym} x mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVWstorezero [off1+int32(off2)] {sym} x mem)
 	for {
-		off1 := v.AuxInt
-		sym := v.Aux
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
 		if v_0.Op != OpPPC64ADDconst {
 			break
 		}
-		off2 := v_0.AuxInt
+		off2 := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		mem := v_1
-		if !(is16Bit(off1 + off2)) {
+		if !(is16Bit(int64(off1) + off2)) {
 			break
 		}
 		v.reset(OpPPC64MOVWstorezero)
-		v.AuxInt = off1 + off2
-		v.Aux = sym
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
 		v.AddArg2(x, mem)
 		return true
 	}
@@ -10148,14 +10246,14 @@ func rewriteValuePPC64_OpPPC64MTVSRD(v *Value) bool {
 	b := v.Block
 	typ := &b.Func.Config.Types
 	// match: (MTVSRD (MOVDconst [c]))
-	// result: (FMOVDconst [c])
+	// result: (FMOVDconst [math.Float64frombits(uint64(c))])
 	for {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		v.reset(OpPPC64FMOVDconst)
-		v.AuxInt = c
+		v.AuxInt = float64ToAuxInt(math.Float64frombits(uint64(c)))
 		return true
 	}
 	// match: (MTVSRD x:(MOVDload [off] {sym} ptr mem))
@@ -10166,8 +10264,8 @@ func rewriteValuePPC64_OpPPC64MTVSRD(v *Value) bool {
 		if x.Op != OpPPC64MOVDload {
 			break
 		}
-		off := x.AuxInt
-		sym := x.Aux
+		off := auxIntToInt32(x.AuxInt)
+		sym := auxToSym(x.Aux)
 		mem := x.Args[1]
 		ptr := x.Args[0]
 		if !(x.Uses == 1 && clobber(x)) {
@@ -10176,8 +10274,8 @@ func rewriteValuePPC64_OpPPC64MTVSRD(v *Value) bool {
 		b = x.Block
 		v0 := b.NewValue0(x.Pos, OpPPC64FMOVDload, typ.Float64)
 		v.copyOf(v0)
-		v0.AuxInt = off
-		v0.Aux = sym
+		v0.AuxInt = int32ToAuxInt(off)
+		v0.Aux = symToAux(sym)
 		v0.AddArg2(ptr, mem)
 		return true
 	}
@@ -10186,23 +10284,23 @@ func rewriteValuePPC64_OpPPC64MTVSRD(v *Value) bool {
 func rewriteValuePPC64_OpPPC64MaskIfNotCarry(v *Value) bool {
 	v_0 := v.Args[0]
 	// match: (MaskIfNotCarry (ADDconstForCarry [c] (ANDconst [d] _)))
-	// cond: c < 0 && d > 0 && c + d < 0
+	// cond: c < 0 && d > 0 && int64(c) + d < 0
 	// result: (MOVDconst [-1])
 	for {
 		if v_0.Op != OpPPC64ADDconstForCarry {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt16(v_0.AuxInt)
 		v_0_0 := v_0.Args[0]
 		if v_0_0.Op != OpPPC64ANDconst {
 			break
 		}
-		d := v_0_0.AuxInt
-		if !(c < 0 && d > 0 && c+d < 0) {
+		d := auxIntToInt64(v_0_0.AuxInt)
+		if !(c < 0 && d > 0 && int64(c)+d < 0) {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = -1
+		v.AuxInt = int64ToAuxInt(-1)
 		return true
 	}
 	// match: (MaskIfNotCarry (FlagCarrySet))
@@ -10212,7 +10310,7 @@ func rewriteValuePPC64_OpPPC64MaskIfNotCarry(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (MaskIfNotCarry (FlagCarryClear))
@@ -10222,7 +10320,7 @@ func rewriteValuePPC64_OpPPC64MaskIfNotCarry(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = -1
+		v.AuxInt = int64ToAuxInt(-1)
 		return true
 	}
 	return false
@@ -10237,13 +10335,13 @@ func rewriteValuePPC64_OpPPC64NOR(v *Value) bool {
 			if v_0.Op != OpPPC64MOVDconst {
 				continue
 			}
-			c := v_0.AuxInt
+			c := auxIntToInt64(v_0.AuxInt)
 			if v_1.Op != OpPPC64MOVDconst {
 				continue
 			}
-			d := v_1.AuxInt
+			d := auxIntToInt64(v_1.AuxInt)
 			v.reset(OpPPC64MOVDconst)
-			v.AuxInt = ^(c | d)
+			v.AuxInt = int64ToAuxInt(^(c | d))
 			return true
 		}
 		break
@@ -10261,7 +10359,7 @@ func rewriteValuePPC64_OpPPC64NotEqual(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (NotEqual (FlagLT))
@@ -10271,7 +10369,7 @@ func rewriteValuePPC64_OpPPC64NotEqual(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		return true
 	}
 	// match: (NotEqual (FlagGT))
@@ -10281,7 +10379,7 @@ func rewriteValuePPC64_OpPPC64NotEqual(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 1
+		v.AuxInt = int64ToAuxInt(1)
 		return true
 	}
 	// match: (NotEqual (InvertFlags x))
@@ -10300,9 +10398,9 @@ func rewriteValuePPC64_OpPPC64NotEqual(v *Value) bool {
 	for {
 		cmp := v_0
 		v.reset(OpPPC64ISELB)
-		v.AuxInt = 6
+		v.AuxInt = int32ToAuxInt(6)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v0.AuxInt = 1
+		v0.AuxInt = int64ToAuxInt(1)
 		v.AddArg2(v0, cmp)
 		return true
 	}
@@ -10321,17 +10419,17 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			if v_0.Op != OpPPC64SLDconst {
 				continue
 			}
-			c := v_0.AuxInt
+			c := auxIntToInt64(v_0.AuxInt)
 			x := v_0.Args[0]
 			if v_1.Op != OpPPC64SRDconst {
 				continue
 			}
-			d := v_1.AuxInt
+			d := auxIntToInt64(v_1.AuxInt)
 			if x != v_1.Args[0] || !(d == 64-c) {
 				continue
 			}
 			v.reset(OpPPC64ROTLconst)
-			v.AuxInt = c
+			v.AuxInt = int64ToAuxInt(c)
 			v.AddArg(x)
 			return true
 		}
@@ -10345,17 +10443,17 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			if v_0.Op != OpPPC64SLWconst {
 				continue
 			}
-			c := v_0.AuxInt
+			c := auxIntToInt64(v_0.AuxInt)
 			x := v_0.Args[0]
 			if v_1.Op != OpPPC64SRWconst {
 				continue
 			}
-			d := v_1.AuxInt
+			d := auxIntToInt64(v_1.AuxInt)
 			if x != v_1.Args[0] || !(d == 32-c) {
 				continue
 			}
 			v.reset(OpPPC64ROTLWconst)
-			v.AuxInt = c
+			v.AuxInt = int64ToAuxInt(c)
 			v.AddArg(x)
 			return true
 		}
@@ -10371,7 +10469,7 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			_ = v_0.Args[1]
 			x := v_0.Args[0]
 			v_0_1 := v_0.Args[1]
-			if v_0_1.Op != OpPPC64ANDconst || v_0_1.Type != typ.Int64 || v_0_1.AuxInt != 63 {
+			if v_0_1.Op != OpPPC64ANDconst || v_0_1.Type != typ.Int64 || auxIntToInt64(v_0_1.AuxInt) != 63 {
 				continue
 			}
 			y := v_0_1.Args[0]
@@ -10388,11 +10486,11 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			}
 			_ = v_1_1.Args[1]
 			v_1_1_0 := v_1_1.Args[0]
-			if v_1_1_0.Op != OpPPC64MOVDconst || v_1_1_0.AuxInt != 64 {
+			if v_1_1_0.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_1_0.AuxInt) != 64 {
 				continue
 			}
 			v_1_1_1 := v_1_1.Args[1]
-			if v_1_1_1.Op != OpPPC64ANDconst || v_1_1_1.Type != typ.UInt || v_1_1_1.AuxInt != 63 || y != v_1_1_1.Args[0] {
+			if v_1_1_1.Op != OpPPC64ANDconst || v_1_1_1.Type != typ.UInt || auxIntToInt64(v_1_1_1.AuxInt) != 63 || y != v_1_1_1.Args[0] {
 				continue
 			}
 			v.reset(OpPPC64ROTL)
@@ -10411,7 +10509,7 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			_ = v_0.Args[1]
 			x := v_0.Args[0]
 			v_0_1 := v_0.Args[1]
-			if v_0_1.Op != OpPPC64ANDconst || v_0_1.Type != typ.Int32 || v_0_1.AuxInt != 31 {
+			if v_0_1.Op != OpPPC64ANDconst || v_0_1.Type != typ.Int32 || auxIntToInt64(v_0_1.AuxInt) != 31 {
 				continue
 			}
 			y := v_0_1.Args[0]
@@ -10428,11 +10526,11 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			}
 			_ = v_1_1.Args[1]
 			v_1_1_0 := v_1_1.Args[0]
-			if v_1_1_0.Op != OpPPC64MOVDconst || v_1_1_0.AuxInt != 32 {
+			if v_1_1_0.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_1_0.AuxInt) != 32 {
 				continue
 			}
 			v_1_1_1 := v_1_1.Args[1]
-			if v_1_1_1.Op != OpPPC64ANDconst || v_1_1_1.Type != typ.UInt || v_1_1_1.AuxInt != 31 || y != v_1_1_1.Args[0] {
+			if v_1_1_1.Op != OpPPC64ANDconst || v_1_1_1.Type != typ.UInt || auxIntToInt64(v_1_1_1.AuxInt) != 31 || y != v_1_1_1.Args[0] {
 				continue
 			}
 			v.reset(OpPPC64ROTLW)
@@ -10448,13 +10546,13 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			if v_0.Op != OpPPC64MOVDconst {
 				continue
 			}
-			c := v_0.AuxInt
+			c := auxIntToInt64(v_0.AuxInt)
 			if v_1.Op != OpPPC64MOVDconst {
 				continue
 			}
-			d := v_1.AuxInt
+			d := auxIntToInt64(v_1.AuxInt)
 			v.reset(OpPPC64MOVDconst)
-			v.AuxInt = c | d
+			v.AuxInt = int64ToAuxInt(c | d)
 			return true
 		}
 		break
@@ -10468,12 +10566,12 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			if v_1.Op != OpPPC64MOVDconst {
 				continue
 			}
-			c := v_1.AuxInt
+			c := auxIntToInt64(v_1.AuxInt)
 			if !(isU32Bit(c)) {
 				continue
 			}
 			v.reset(OpPPC64ORconst)
-			v.AuxInt = c
+			v.AuxInt = int64ToAuxInt(c)
 			v.AddArg(x)
 			return true
 		}
@@ -10489,20 +10587,20 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			if x0.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i0 := x0.AuxInt
-			s := x0.Aux
+			i0 := auxIntToInt32(x0.AuxInt)
+			s := auxToSym(x0.Aux)
 			mem := x0.Args[1]
 			p := x0.Args[0]
 			o1 := v_1
-			if o1.Op != OpPPC64SLWconst || o1.AuxInt != 8 {
+			if o1.Op != OpPPC64SLWconst || auxIntToInt64(o1.AuxInt) != 8 {
 				continue
 			}
 			x1 := o1.Args[0]
 			if x1.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i1 := x1.AuxInt
-			if x1.Aux != s {
+			i1 := auxIntToInt32(x1.AuxInt)
+			if auxToSym(x1.Aux) != s {
 				continue
 			}
 			_ = x1.Args[1]
@@ -10512,8 +10610,8 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			b = mergePoint(b, x0, x1)
 			v0 := b.NewValue0(x1.Pos, OpPPC64MOVHZload, t)
 			v.copyOf(v0)
-			v0.AuxInt = i0
-			v0.Aux = s
+			v0.AuxInt = int32ToAuxInt(i0)
+			v0.Aux = symToAux(s)
 			v0.AddArg2(p, mem)
 			return true
 		}
@@ -10529,20 +10627,20 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			if x0.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i0 := x0.AuxInt
-			s := x0.Aux
+			i0 := auxIntToInt32(x0.AuxInt)
+			s := auxToSym(x0.Aux)
 			mem := x0.Args[1]
 			p := x0.Args[0]
 			o1 := v_1
-			if o1.Op != OpPPC64SLDconst || o1.AuxInt != 8 {
+			if o1.Op != OpPPC64SLDconst || auxIntToInt64(o1.AuxInt) != 8 {
 				continue
 			}
 			x1 := o1.Args[0]
 			if x1.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i1 := x1.AuxInt
-			if x1.Aux != s {
+			i1 := auxIntToInt32(x1.AuxInt)
+			if auxToSym(x1.Aux) != s {
 				continue
 			}
 			_ = x1.Args[1]
@@ -10552,8 +10650,8 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			b = mergePoint(b, x0, x1)
 			v0 := b.NewValue0(x1.Pos, OpPPC64MOVHZload, t)
 			v.copyOf(v0)
-			v0.AuxInt = i0
-			v0.Aux = s
+			v0.AuxInt = int32ToAuxInt(i0)
+			v0.Aux = symToAux(s)
 			v0.AddArg2(p, mem)
 			return true
 		}
@@ -10569,20 +10667,20 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			if x0.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i1 := x0.AuxInt
-			s := x0.Aux
+			i1 := auxIntToInt32(x0.AuxInt)
+			s := auxToSym(x0.Aux)
 			mem := x0.Args[1]
 			p := x0.Args[0]
 			o1 := v_1
-			if o1.Op != OpPPC64SLWconst || o1.AuxInt != 8 {
+			if o1.Op != OpPPC64SLWconst || auxIntToInt64(o1.AuxInt) != 8 {
 				continue
 			}
 			x1 := o1.Args[0]
 			if x1.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i0 := x1.AuxInt
-			if x1.Aux != s {
+			i0 := auxIntToInt32(x1.AuxInt)
+			if auxToSym(x1.Aux) != s {
 				continue
 			}
 			_ = x1.Args[1]
@@ -10593,8 +10691,8 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			v0 := b.NewValue0(x1.Pos, OpPPC64MOVHBRload, t)
 			v.copyOf(v0)
 			v1 := b.NewValue0(x1.Pos, OpPPC64MOVDaddr, typ.Uintptr)
-			v1.AuxInt = i0
-			v1.Aux = s
+			v1.AuxInt = int32ToAuxInt(i0)
+			v1.Aux = symToAux(s)
 			v1.AddArg(p)
 			v0.AddArg2(v1, mem)
 			return true
@@ -10611,20 +10709,20 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			if x0.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i1 := x0.AuxInt
-			s := x0.Aux
+			i1 := auxIntToInt32(x0.AuxInt)
+			s := auxToSym(x0.Aux)
 			mem := x0.Args[1]
 			p := x0.Args[0]
 			o1 := v_1
-			if o1.Op != OpPPC64SLDconst || o1.AuxInt != 8 {
+			if o1.Op != OpPPC64SLDconst || auxIntToInt64(o1.AuxInt) != 8 {
 				continue
 			}
 			x1 := o1.Args[0]
 			if x1.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i0 := x1.AuxInt
-			if x1.Aux != s {
+			i0 := auxIntToInt32(x1.AuxInt)
+			if auxToSym(x1.Aux) != s {
 				continue
 			}
 			_ = x1.Args[1]
@@ -10635,8 +10733,8 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			v0 := b.NewValue0(x1.Pos, OpPPC64MOVHBRload, t)
 			v.copyOf(v0)
 			v1 := b.NewValue0(x1.Pos, OpPPC64MOVDaddr, typ.Uintptr)
-			v1.AuxInt = i0
-			v1.Aux = s
+			v1.AuxInt = int32ToAuxInt(i0)
+			v1.Aux = symToAux(s)
 			v1.AddArg(p)
 			v0.AddArg2(v1, mem)
 			return true
@@ -10653,26 +10751,26 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			if s0.Op != OpPPC64SLWconst {
 				continue
 			}
-			n1 := s0.AuxInt
+			n1 := auxIntToInt64(s0.AuxInt)
 			x0 := s0.Args[0]
 			if x0.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i1 := x0.AuxInt
-			s := x0.Aux
+			i1 := auxIntToInt32(x0.AuxInt)
+			s := auxToSym(x0.Aux)
 			mem := x0.Args[1]
 			p := x0.Args[0]
 			s1 := v_1
 			if s1.Op != OpPPC64SLWconst {
 				continue
 			}
-			n2 := s1.AuxInt
+			n2 := auxIntToInt64(s1.AuxInt)
 			x1 := s1.Args[0]
 			if x1.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i0 := x1.AuxInt
-			if x1.Aux != s {
+			i0 := auxIntToInt32(x1.AuxInt)
+			if auxToSym(x1.Aux) != s {
 				continue
 			}
 			_ = x1.Args[1]
@@ -10682,11 +10780,11 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			b = mergePoint(b, x0, x1)
 			v0 := b.NewValue0(x1.Pos, OpPPC64SLDconst, t)
 			v.copyOf(v0)
-			v0.AuxInt = n1
+			v0.AuxInt = int64ToAuxInt(n1)
 			v1 := b.NewValue0(x1.Pos, OpPPC64MOVHBRload, t)
 			v2 := b.NewValue0(x1.Pos, OpPPC64MOVDaddr, typ.Uintptr)
-			v2.AuxInt = i0
-			v2.Aux = s
+			v2.AuxInt = int32ToAuxInt(i0)
+			v2.Aux = symToAux(s)
 			v2.AddArg(p)
 			v1.AddArg2(v2, mem)
 			v0.AddArg(v1)
@@ -10704,26 +10802,26 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			if s0.Op != OpPPC64SLDconst {
 				continue
 			}
-			n1 := s0.AuxInt
+			n1 := auxIntToInt64(s0.AuxInt)
 			x0 := s0.Args[0]
 			if x0.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i1 := x0.AuxInt
-			s := x0.Aux
+			i1 := auxIntToInt32(x0.AuxInt)
+			s := auxToSym(x0.Aux)
 			mem := x0.Args[1]
 			p := x0.Args[0]
 			s1 := v_1
 			if s1.Op != OpPPC64SLDconst {
 				continue
 			}
-			n2 := s1.AuxInt
+			n2 := auxIntToInt64(s1.AuxInt)
 			x1 := s1.Args[0]
 			if x1.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i0 := x1.AuxInt
-			if x1.Aux != s {
+			i0 := auxIntToInt32(x1.AuxInt)
+			if auxToSym(x1.Aux) != s {
 				continue
 			}
 			_ = x1.Args[1]
@@ -10733,11 +10831,11 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			b = mergePoint(b, x0, x1)
 			v0 := b.NewValue0(x1.Pos, OpPPC64SLDconst, t)
 			v.copyOf(v0)
-			v0.AuxInt = n1
+			v0.AuxInt = int64ToAuxInt(n1)
 			v1 := b.NewValue0(x1.Pos, OpPPC64MOVHBRload, t)
 			v2 := b.NewValue0(x1.Pos, OpPPC64MOVDaddr, typ.Uintptr)
-			v2.AuxInt = i0
-			v2.Aux = s
+			v2.AuxInt = int32ToAuxInt(i0)
+			v2.Aux = symToAux(s)
 			v2.AddArg(p)
 			v1.AddArg2(v2, mem)
 			v0.AddArg(v1)
@@ -10752,15 +10850,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 		t := v.Type
 		for _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {
 			s1 := v_0
-			if s1.Op != OpPPC64SLWconst || s1.AuxInt != 24 {
+			if s1.Op != OpPPC64SLWconst || auxIntToInt64(s1.AuxInt) != 24 {
 				continue
 			}
 			x2 := s1.Args[0]
 			if x2.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i3 := x2.AuxInt
-			s := x2.Aux
+			i3 := auxIntToInt32(x2.AuxInt)
+			s := auxToSym(x2.Aux)
 			mem := x2.Args[1]
 			p := x2.Args[0]
 			o0 := v_1
@@ -10772,15 +10870,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			o0_1 := o0.Args[1]
 			for _i1 := 0; _i1 <= 1; _i1, o0_0, o0_1 = _i1+1, o0_1, o0_0 {
 				s0 := o0_0
-				if s0.Op != OpPPC64SLWconst || s0.AuxInt != 16 {
+				if s0.Op != OpPPC64SLWconst || auxIntToInt64(s0.AuxInt) != 16 {
 					continue
 				}
 				x1 := s0.Args[0]
 				if x1.Op != OpPPC64MOVBZload {
 					continue
 				}
-				i2 := x1.AuxInt
-				if x1.Aux != s {
+				i2 := auxIntToInt32(x1.AuxInt)
+				if auxToSym(x1.Aux) != s {
 					continue
 				}
 				_ = x1.Args[1]
@@ -10791,8 +10889,8 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 				if x0.Op != OpPPC64MOVHZload {
 					continue
 				}
-				i0 := x0.AuxInt
-				if x0.Aux != s {
+				i0 := auxIntToInt32(x0.AuxInt)
+				if auxToSym(x0.Aux) != s {
 					continue
 				}
 				_ = x0.Args[1]
@@ -10802,8 +10900,8 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 				b = mergePoint(b, x0, x1, x2)
 				v0 := b.NewValue0(x0.Pos, OpPPC64MOVWZload, t)
 				v.copyOf(v0)
-				v0.AuxInt = i0
-				v0.Aux = s
+				v0.AuxInt = int32ToAuxInt(i0)
+				v0.Aux = symToAux(s)
 				v0.AddArg2(p, mem)
 				return true
 			}
@@ -10817,15 +10915,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 		t := v.Type
 		for _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {
 			s1 := v_0
-			if s1.Op != OpPPC64SLDconst || s1.AuxInt != 24 {
+			if s1.Op != OpPPC64SLDconst || auxIntToInt64(s1.AuxInt) != 24 {
 				continue
 			}
 			x2 := s1.Args[0]
 			if x2.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i3 := x2.AuxInt
-			s := x2.Aux
+			i3 := auxIntToInt32(x2.AuxInt)
+			s := auxToSym(x2.Aux)
 			mem := x2.Args[1]
 			p := x2.Args[0]
 			o0 := v_1
@@ -10837,15 +10935,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			o0_1 := o0.Args[1]
 			for _i1 := 0; _i1 <= 1; _i1, o0_0, o0_1 = _i1+1, o0_1, o0_0 {
 				s0 := o0_0
-				if s0.Op != OpPPC64SLDconst || s0.AuxInt != 16 {
+				if s0.Op != OpPPC64SLDconst || auxIntToInt64(s0.AuxInt) != 16 {
 					continue
 				}
 				x1 := s0.Args[0]
 				if x1.Op != OpPPC64MOVBZload {
 					continue
 				}
-				i2 := x1.AuxInt
-				if x1.Aux != s {
+				i2 := auxIntToInt32(x1.AuxInt)
+				if auxToSym(x1.Aux) != s {
 					continue
 				}
 				_ = x1.Args[1]
@@ -10856,8 +10954,8 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 				if x0.Op != OpPPC64MOVHZload {
 					continue
 				}
-				i0 := x0.AuxInt
-				if x0.Aux != s {
+				i0 := auxIntToInt32(x0.AuxInt)
+				if auxToSym(x0.Aux) != s {
 					continue
 				}
 				_ = x0.Args[1]
@@ -10867,8 +10965,8 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 				b = mergePoint(b, x0, x1, x2)
 				v0 := b.NewValue0(x0.Pos, OpPPC64MOVWZload, t)
 				v.copyOf(v0)
-				v0.AuxInt = i0
-				v0.Aux = s
+				v0.AuxInt = int32ToAuxInt(i0)
+				v0.Aux = symToAux(s)
 				v0.AddArg2(p, mem)
 				return true
 			}
@@ -10882,15 +10980,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 		t := v.Type
 		for _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {
 			s1 := v_0
-			if s1.Op != OpPPC64SLWconst || s1.AuxInt != 24 {
+			if s1.Op != OpPPC64SLWconst || auxIntToInt64(s1.AuxInt) != 24 {
 				continue
 			}
 			x2 := s1.Args[0]
 			if x2.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i0 := x2.AuxInt
-			s := x2.Aux
+			i0 := auxIntToInt32(x2.AuxInt)
+			s := auxToSym(x2.Aux)
 			mem := x2.Args[1]
 			p := x2.Args[0]
 			o0 := v_1
@@ -10902,15 +11000,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			o0_1 := o0.Args[1]
 			for _i1 := 0; _i1 <= 1; _i1, o0_0, o0_1 = _i1+1, o0_1, o0_0 {
 				s0 := o0_0
-				if s0.Op != OpPPC64SLWconst || s0.AuxInt != 16 {
+				if s0.Op != OpPPC64SLWconst || auxIntToInt64(s0.AuxInt) != 16 {
 					continue
 				}
 				x1 := s0.Args[0]
 				if x1.Op != OpPPC64MOVBZload {
 					continue
 				}
-				i1 := x1.AuxInt
-				if x1.Aux != s {
+				i1 := auxIntToInt32(x1.AuxInt)
+				if auxToSym(x1.Aux) != s {
 					continue
 				}
 				_ = x1.Args[1]
@@ -10926,16 +11024,16 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 				if x0_0.Op != OpPPC64MOVDaddr || x0_0.Type != typ.Uintptr {
 					continue
 				}
-				i2 := x0_0.AuxInt
-				if x0_0.Aux != s || p != x0_0.Args[0] || mem != x0.Args[1] || !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0, x1, x2, s0, s1, o0)) {
+				i2 := auxIntToInt32(x0_0.AuxInt)
+				if auxToSym(x0_0.Aux) != s || p != x0_0.Args[0] || mem != x0.Args[1] || !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0, x1, x2, s0, s1, o0)) {
 					continue
 				}
 				b = mergePoint(b, x0, x1, x2)
 				v0 := b.NewValue0(x0.Pos, OpPPC64MOVWBRload, t)
 				v.copyOf(v0)
 				v1 := b.NewValue0(x0.Pos, OpPPC64MOVDaddr, typ.Uintptr)
-				v1.AuxInt = i0
-				v1.Aux = s
+				v1.AuxInt = int32ToAuxInt(i0)
+				v1.Aux = symToAux(s)
 				v1.AddArg(p)
 				v0.AddArg2(v1, mem)
 				return true
@@ -10950,15 +11048,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 		t := v.Type
 		for _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {
 			s1 := v_0
-			if s1.Op != OpPPC64SLDconst || s1.AuxInt != 24 {
+			if s1.Op != OpPPC64SLDconst || auxIntToInt64(s1.AuxInt) != 24 {
 				continue
 			}
 			x2 := s1.Args[0]
 			if x2.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i0 := x2.AuxInt
-			s := x2.Aux
+			i0 := auxIntToInt32(x2.AuxInt)
+			s := auxToSym(x2.Aux)
 			mem := x2.Args[1]
 			p := x2.Args[0]
 			o0 := v_1
@@ -10970,15 +11068,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			o0_1 := o0.Args[1]
 			for _i1 := 0; _i1 <= 1; _i1, o0_0, o0_1 = _i1+1, o0_1, o0_0 {
 				s0 := o0_0
-				if s0.Op != OpPPC64SLDconst || s0.AuxInt != 16 {
+				if s0.Op != OpPPC64SLDconst || auxIntToInt64(s0.AuxInt) != 16 {
 					continue
 				}
 				x1 := s0.Args[0]
 				if x1.Op != OpPPC64MOVBZload {
 					continue
 				}
-				i1 := x1.AuxInt
-				if x1.Aux != s {
+				i1 := auxIntToInt32(x1.AuxInt)
+				if auxToSym(x1.Aux) != s {
 					continue
 				}
 				_ = x1.Args[1]
@@ -10994,16 +11092,16 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 				if x0_0.Op != OpPPC64MOVDaddr || x0_0.Type != typ.Uintptr {
 					continue
 				}
-				i2 := x0_0.AuxInt
-				if x0_0.Aux != s || p != x0_0.Args[0] || mem != x0.Args[1] || !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0, x1, x2, s0, s1, o0)) {
+				i2 := auxIntToInt32(x0_0.AuxInt)
+				if auxToSym(x0_0.Aux) != s || p != x0_0.Args[0] || mem != x0.Args[1] || !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0, x1, x2, s0, s1, o0)) {
 					continue
 				}
 				b = mergePoint(b, x0, x1, x2)
 				v0 := b.NewValue0(x0.Pos, OpPPC64MOVWBRload, t)
 				v.copyOf(v0)
 				v1 := b.NewValue0(x0.Pos, OpPPC64MOVDaddr, typ.Uintptr)
-				v1.AuxInt = i0
-				v1.Aux = s
+				v1.AuxInt = int32ToAuxInt(i0)
+				v1.Aux = symToAux(s)
 				v1.AddArg(p)
 				v0.AddArg2(v1, mem)
 				return true
@@ -11021,8 +11119,8 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			if x0.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i3 := x0.AuxInt
-			s := x0.Aux
+			i3 := auxIntToInt32(x0.AuxInt)
+			s := auxToSym(x0.Aux)
 			mem := x0.Args[1]
 			p := x0.Args[0]
 			o0 := v_1
@@ -11034,15 +11132,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			o0_1 := o0.Args[1]
 			for _i1 := 0; _i1 <= 1; _i1, o0_0, o0_1 = _i1+1, o0_1, o0_0 {
 				s0 := o0_0
-				if s0.Op != OpPPC64SLWconst || s0.AuxInt != 8 {
+				if s0.Op != OpPPC64SLWconst || auxIntToInt64(s0.AuxInt) != 8 {
 					continue
 				}
 				x1 := s0.Args[0]
 				if x1.Op != OpPPC64MOVBZload {
 					continue
 				}
-				i2 := x1.AuxInt
-				if x1.Aux != s {
+				i2 := auxIntToInt32(x1.AuxInt)
+				if auxToSym(x1.Aux) != s {
 					continue
 				}
 				_ = x1.Args[1]
@@ -11050,7 +11148,7 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 					continue
 				}
 				s1 := o0_1
-				if s1.Op != OpPPC64SLWconst || s1.AuxInt != 16 {
+				if s1.Op != OpPPC64SLWconst || auxIntToInt64(s1.AuxInt) != 16 {
 					continue
 				}
 				x2 := s1.Args[0]
@@ -11062,16 +11160,16 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 				if x2_0.Op != OpPPC64MOVDaddr || x2_0.Type != typ.Uintptr {
 					continue
 				}
-				i0 := x2_0.AuxInt
-				if x2_0.Aux != s || p != x2_0.Args[0] || mem != x2.Args[1] || !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0, x1, x2, s0, s1, o0)) {
+				i0 := auxIntToInt32(x2_0.AuxInt)
+				if auxToSym(x2_0.Aux) != s || p != x2_0.Args[0] || mem != x2.Args[1] || !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0, x1, x2, s0, s1, o0)) {
 					continue
 				}
 				b = mergePoint(b, x0, x1, x2)
 				v0 := b.NewValue0(x2.Pos, OpPPC64MOVWBRload, t)
 				v.copyOf(v0)
 				v1 := b.NewValue0(x2.Pos, OpPPC64MOVDaddr, typ.Uintptr)
-				v1.AuxInt = i0
-				v1.Aux = s
+				v1.AuxInt = int32ToAuxInt(i0)
+				v1.Aux = symToAux(s)
 				v1.AddArg(p)
 				v0.AddArg2(v1, mem)
 				return true
@@ -11089,8 +11187,8 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			if x0.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i3 := x0.AuxInt
-			s := x0.Aux
+			i3 := auxIntToInt32(x0.AuxInt)
+			s := auxToSym(x0.Aux)
 			mem := x0.Args[1]
 			p := x0.Args[0]
 			o0 := v_1
@@ -11102,15 +11200,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			o0_1 := o0.Args[1]
 			for _i1 := 0; _i1 <= 1; _i1, o0_0, o0_1 = _i1+1, o0_1, o0_0 {
 				s0 := o0_0
-				if s0.Op != OpPPC64SLDconst || s0.AuxInt != 8 {
+				if s0.Op != OpPPC64SLDconst || auxIntToInt64(s0.AuxInt) != 8 {
 					continue
 				}
 				x1 := s0.Args[0]
 				if x1.Op != OpPPC64MOVBZload {
 					continue
 				}
-				i2 := x1.AuxInt
-				if x1.Aux != s {
+				i2 := auxIntToInt32(x1.AuxInt)
+				if auxToSym(x1.Aux) != s {
 					continue
 				}
 				_ = x1.Args[1]
@@ -11118,7 +11216,7 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 					continue
 				}
 				s1 := o0_1
-				if s1.Op != OpPPC64SLDconst || s1.AuxInt != 16 {
+				if s1.Op != OpPPC64SLDconst || auxIntToInt64(s1.AuxInt) != 16 {
 					continue
 				}
 				x2 := s1.Args[0]
@@ -11130,16 +11228,16 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 				if x2_0.Op != OpPPC64MOVDaddr || x2_0.Type != typ.Uintptr {
 					continue
 				}
-				i0 := x2_0.AuxInt
-				if x2_0.Aux != s || p != x2_0.Args[0] || mem != x2.Args[1] || !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0, x1, x2, s0, s1, o0)) {
+				i0 := auxIntToInt32(x2_0.AuxInt)
+				if auxToSym(x2_0.Aux) != s || p != x2_0.Args[0] || mem != x2.Args[1] || !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0, x1, x2, s0, s1, o0)) {
 					continue
 				}
 				b = mergePoint(b, x0, x1, x2)
 				v0 := b.NewValue0(x2.Pos, OpPPC64MOVWBRload, t)
 				v.copyOf(v0)
 				v1 := b.NewValue0(x2.Pos, OpPPC64MOVDaddr, typ.Uintptr)
-				v1.AuxInt = i0
-				v1.Aux = s
+				v1.AuxInt = int32ToAuxInt(i0)
+				v1.Aux = symToAux(s)
 				v1.AddArg(p)
 				v0.AddArg2(v1, mem)
 				return true
@@ -11154,15 +11252,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 		t := v.Type
 		for _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {
 			s2 := v_0
-			if s2.Op != OpPPC64SLDconst || s2.AuxInt != 32 {
+			if s2.Op != OpPPC64SLDconst || auxIntToInt64(s2.AuxInt) != 32 {
 				continue
 			}
 			x2 := s2.Args[0]
 			if x2.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i3 := x2.AuxInt
-			s := x2.Aux
+			i3 := auxIntToInt32(x2.AuxInt)
+			s := auxToSym(x2.Aux)
 			mem := x2.Args[1]
 			p := x2.Args[0]
 			o0 := v_1
@@ -11174,15 +11272,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			o0_1 := o0.Args[1]
 			for _i1 := 0; _i1 <= 1; _i1, o0_0, o0_1 = _i1+1, o0_1, o0_0 {
 				s1 := o0_0
-				if s1.Op != OpPPC64SLDconst || s1.AuxInt != 40 {
+				if s1.Op != OpPPC64SLDconst || auxIntToInt64(s1.AuxInt) != 40 {
 					continue
 				}
 				x1 := s1.Args[0]
 				if x1.Op != OpPPC64MOVBZload {
 					continue
 				}
-				i2 := x1.AuxInt
-				if x1.Aux != s {
+				i2 := auxIntToInt32(x1.AuxInt)
+				if auxToSym(x1.Aux) != s {
 					continue
 				}
 				_ = x1.Args[1]
@@ -11190,7 +11288,7 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 					continue
 				}
 				s0 := o0_1
-				if s0.Op != OpPPC64SLDconst || s0.AuxInt != 48 {
+				if s0.Op != OpPPC64SLDconst || auxIntToInt64(s0.AuxInt) != 48 {
 					continue
 				}
 				x0 := s0.Args[0]
@@ -11202,18 +11300,18 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 				if x0_0.Op != OpPPC64MOVDaddr || x0_0.Type != typ.Uintptr {
 					continue
 				}
-				i0 := x0_0.AuxInt
-				if x0_0.Aux != s || p != x0_0.Args[0] || mem != x0.Args[1] || !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0, x1, x2, s0, s1, s2, o0)) {
+				i0 := auxIntToInt32(x0_0.AuxInt)
+				if auxToSym(x0_0.Aux) != s || p != x0_0.Args[0] || mem != x0.Args[1] || !(!config.BigEndian && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0, x1, x2, s0, s1, s2, o0)) {
 					continue
 				}
 				b = mergePoint(b, x0, x1, x2)
 				v0 := b.NewValue0(x0.Pos, OpPPC64SLDconst, t)
 				v.copyOf(v0)
-				v0.AuxInt = 32
+				v0.AuxInt = int64ToAuxInt(32)
 				v1 := b.NewValue0(x0.Pos, OpPPC64MOVWBRload, t)
 				v2 := b.NewValue0(x0.Pos, OpPPC64MOVDaddr, typ.Uintptr)
-				v2.AuxInt = i0
-				v2.Aux = s
+				v2.AuxInt = int32ToAuxInt(i0)
+				v2.Aux = symToAux(s)
 				v2.AddArg(p)
 				v1.AddArg2(v2, mem)
 				v0.AddArg(v1)
@@ -11229,15 +11327,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 		t := v.Type
 		for _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {
 			s2 := v_0
-			if s2.Op != OpPPC64SLDconst || s2.AuxInt != 56 {
+			if s2.Op != OpPPC64SLDconst || auxIntToInt64(s2.AuxInt) != 56 {
 				continue
 			}
 			x2 := s2.Args[0]
 			if x2.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i0 := x2.AuxInt
-			s := x2.Aux
+			i0 := auxIntToInt32(x2.AuxInt)
+			s := auxToSym(x2.Aux)
 			mem := x2.Args[1]
 			p := x2.Args[0]
 			o0 := v_1
@@ -11249,15 +11347,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			o0_1 := o0.Args[1]
 			for _i1 := 0; _i1 <= 1; _i1, o0_0, o0_1 = _i1+1, o0_1, o0_0 {
 				s1 := o0_0
-				if s1.Op != OpPPC64SLDconst || s1.AuxInt != 48 {
+				if s1.Op != OpPPC64SLDconst || auxIntToInt64(s1.AuxInt) != 48 {
 					continue
 				}
 				x1 := s1.Args[0]
 				if x1.Op != OpPPC64MOVBZload {
 					continue
 				}
-				i1 := x1.AuxInt
-				if x1.Aux != s {
+				i1 := auxIntToInt32(x1.AuxInt)
+				if auxToSym(x1.Aux) != s {
 					continue
 				}
 				_ = x1.Args[1]
@@ -11265,7 +11363,7 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 					continue
 				}
 				s0 := o0_1
-				if s0.Op != OpPPC64SLDconst || s0.AuxInt != 32 {
+				if s0.Op != OpPPC64SLDconst || auxIntToInt64(s0.AuxInt) != 32 {
 					continue
 				}
 				x0 := s0.Args[0]
@@ -11277,18 +11375,18 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 				if x0_0.Op != OpPPC64MOVDaddr || x0_0.Type != typ.Uintptr {
 					continue
 				}
-				i2 := x0_0.AuxInt
-				if x0_0.Aux != s || p != x0_0.Args[0] || mem != x0.Args[1] || !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0, x1, x2, s0, s1, s2, o0)) {
+				i2 := auxIntToInt32(x0_0.AuxInt)
+				if auxToSym(x0_0.Aux) != s || p != x0_0.Args[0] || mem != x0.Args[1] || !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && o0.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0, x1, x2, s0, s1, s2, o0)) {
 					continue
 				}
 				b = mergePoint(b, x0, x1, x2)
 				v0 := b.NewValue0(x0.Pos, OpPPC64SLDconst, t)
 				v.copyOf(v0)
-				v0.AuxInt = 32
+				v0.AuxInt = int64ToAuxInt(32)
 				v1 := b.NewValue0(x0.Pos, OpPPC64MOVWBRload, t)
 				v2 := b.NewValue0(x0.Pos, OpPPC64MOVDaddr, typ.Uintptr)
-				v2.AuxInt = i0
-				v2.Aux = s
+				v2.AuxInt = int32ToAuxInt(i0)
+				v2.Aux = symToAux(s)
 				v2.AddArg(p)
 				v1.AddArg2(v2, mem)
 				v0.AddArg(v1)
@@ -11304,15 +11402,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 		t := v.Type
 		for _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {
 			s6 := v_0
-			if s6.Op != OpPPC64SLDconst || s6.AuxInt != 56 {
+			if s6.Op != OpPPC64SLDconst || auxIntToInt64(s6.AuxInt) != 56 {
 				continue
 			}
 			x7 := s6.Args[0]
 			if x7.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i7 := x7.AuxInt
-			s := x7.Aux
+			i7 := auxIntToInt32(x7.AuxInt)
+			s := auxToSym(x7.Aux)
 			mem := x7.Args[1]
 			p := x7.Args[0]
 			o5 := v_1
@@ -11324,15 +11422,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			o5_1 := o5.Args[1]
 			for _i1 := 0; _i1 <= 1; _i1, o5_0, o5_1 = _i1+1, o5_1, o5_0 {
 				s5 := o5_0
-				if s5.Op != OpPPC64SLDconst || s5.AuxInt != 48 {
+				if s5.Op != OpPPC64SLDconst || auxIntToInt64(s5.AuxInt) != 48 {
 					continue
 				}
 				x6 := s5.Args[0]
 				if x6.Op != OpPPC64MOVBZload {
 					continue
 				}
-				i6 := x6.AuxInt
-				if x6.Aux != s {
+				i6 := auxIntToInt32(x6.AuxInt)
+				if auxToSym(x6.Aux) != s {
 					continue
 				}
 				_ = x6.Args[1]
@@ -11348,15 +11446,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 				o4_1 := o4.Args[1]
 				for _i2 := 0; _i2 <= 1; _i2, o4_0, o4_1 = _i2+1, o4_1, o4_0 {
 					s4 := o4_0
-					if s4.Op != OpPPC64SLDconst || s4.AuxInt != 40 {
+					if s4.Op != OpPPC64SLDconst || auxIntToInt64(s4.AuxInt) != 40 {
 						continue
 					}
 					x5 := s4.Args[0]
 					if x5.Op != OpPPC64MOVBZload {
 						continue
 					}
-					i5 := x5.AuxInt
-					if x5.Aux != s {
+					i5 := auxIntToInt32(x5.AuxInt)
+					if auxToSym(x5.Aux) != s {
 						continue
 					}
 					_ = x5.Args[1]
@@ -11372,15 +11470,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 					o3_1 := o3.Args[1]
 					for _i3 := 0; _i3 <= 1; _i3, o3_0, o3_1 = _i3+1, o3_1, o3_0 {
 						s3 := o3_0
-						if s3.Op != OpPPC64SLDconst || s3.AuxInt != 32 {
+						if s3.Op != OpPPC64SLDconst || auxIntToInt64(s3.AuxInt) != 32 {
 							continue
 						}
 						x4 := s3.Args[0]
 						if x4.Op != OpPPC64MOVBZload {
 							continue
 						}
-						i4 := x4.AuxInt
-						if x4.Aux != s {
+						i4 := auxIntToInt32(x4.AuxInt)
+						if auxToSym(x4.Aux) != s {
 							continue
 						}
 						_ = x4.Args[1]
@@ -11391,8 +11489,8 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 						if x0.Op != OpPPC64MOVWZload {
 							continue
 						}
-						i0 := x0.AuxInt
-						if x0.Aux != s {
+						i0 := auxIntToInt32(x0.AuxInt)
+						if auxToSym(x0.Aux) != s {
 							continue
 						}
 						_ = x0.Args[1]
@@ -11402,8 +11500,8 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 						b = mergePoint(b, x0, x4, x5, x6, x7)
 						v0 := b.NewValue0(x0.Pos, OpPPC64MOVDload, t)
 						v.copyOf(v0)
-						v0.AuxInt = i0
-						v0.Aux = s
+						v0.AuxInt = int32ToAuxInt(i0)
+						v0.Aux = symToAux(s)
 						v0.AddArg2(p, mem)
 						return true
 					}
@@ -11419,15 +11517,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 		t := v.Type
 		for _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {
 			s0 := v_0
-			if s0.Op != OpPPC64SLDconst || s0.AuxInt != 56 {
+			if s0.Op != OpPPC64SLDconst || auxIntToInt64(s0.AuxInt) != 56 {
 				continue
 			}
 			x0 := s0.Args[0]
 			if x0.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i0 := x0.AuxInt
-			s := x0.Aux
+			i0 := auxIntToInt32(x0.AuxInt)
+			s := auxToSym(x0.Aux)
 			mem := x0.Args[1]
 			p := x0.Args[0]
 			o0 := v_1
@@ -11439,15 +11537,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			o0_1 := o0.Args[1]
 			for _i1 := 0; _i1 <= 1; _i1, o0_0, o0_1 = _i1+1, o0_1, o0_0 {
 				s1 := o0_0
-				if s1.Op != OpPPC64SLDconst || s1.AuxInt != 48 {
+				if s1.Op != OpPPC64SLDconst || auxIntToInt64(s1.AuxInt) != 48 {
 					continue
 				}
 				x1 := s1.Args[0]
 				if x1.Op != OpPPC64MOVBZload {
 					continue
 				}
-				i1 := x1.AuxInt
-				if x1.Aux != s {
+				i1 := auxIntToInt32(x1.AuxInt)
+				if auxToSym(x1.Aux) != s {
 					continue
 				}
 				_ = x1.Args[1]
@@ -11463,15 +11561,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 				o1_1 := o1.Args[1]
 				for _i2 := 0; _i2 <= 1; _i2, o1_0, o1_1 = _i2+1, o1_1, o1_0 {
 					s2 := o1_0
-					if s2.Op != OpPPC64SLDconst || s2.AuxInt != 40 {
+					if s2.Op != OpPPC64SLDconst || auxIntToInt64(s2.AuxInt) != 40 {
 						continue
 					}
 					x2 := s2.Args[0]
 					if x2.Op != OpPPC64MOVBZload {
 						continue
 					}
-					i2 := x2.AuxInt
-					if x2.Aux != s {
+					i2 := auxIntToInt32(x2.AuxInt)
+					if auxToSym(x2.Aux) != s {
 						continue
 					}
 					_ = x2.Args[1]
@@ -11487,15 +11585,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 					o2_1 := o2.Args[1]
 					for _i3 := 0; _i3 <= 1; _i3, o2_0, o2_1 = _i3+1, o2_1, o2_0 {
 						s3 := o2_0
-						if s3.Op != OpPPC64SLDconst || s3.AuxInt != 32 {
+						if s3.Op != OpPPC64SLDconst || auxIntToInt64(s3.AuxInt) != 32 {
 							continue
 						}
 						x3 := s3.Args[0]
 						if x3.Op != OpPPC64MOVBZload {
 							continue
 						}
-						i3 := x3.AuxInt
-						if x3.Aux != s {
+						i3 := auxIntToInt32(x3.AuxInt)
+						if auxToSym(x3.Aux) != s {
 							continue
 						}
 						_ = x3.Args[1]
@@ -11511,7 +11609,7 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 						if x4_0.Op != OpPPC64MOVDaddr || x4_0.Type != typ.Uintptr {
 							continue
 						}
-						i4 := x4_0.AuxInt
+						i4 := auxIntToInt32(x4_0.AuxInt)
 						if p != x4_0.Args[0] || mem != x4.Args[1] || !(!config.BigEndian && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && mergePoint(b, x0, x1, x2, x3, x4) != nil && clobber(x0, x1, x2, x3, x4, o0, o1, o2, s0, s1, s2, s3)) {
 							continue
 						}
@@ -11519,8 +11617,8 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 						v0 := b.NewValue0(x4.Pos, OpPPC64MOVDBRload, t)
 						v.copyOf(v0)
 						v1 := b.NewValue0(x4.Pos, OpPPC64MOVDaddr, typ.Uintptr)
-						v1.AuxInt = i0
-						v1.Aux = s
+						v1.AuxInt = int32ToAuxInt(i0)
+						v1.Aux = symToAux(s)
 						v1.AddArg(p)
 						v0.AddArg2(v1, mem)
 						return true
@@ -11540,8 +11638,8 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			if x7.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i7 := x7.AuxInt
-			s := x7.Aux
+			i7 := auxIntToInt32(x7.AuxInt)
+			s := auxToSym(x7.Aux)
 			mem := x7.Args[1]
 			p := x7.Args[0]
 			o5 := v_1
@@ -11553,15 +11651,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			o5_1 := o5.Args[1]
 			for _i1 := 0; _i1 <= 1; _i1, o5_0, o5_1 = _i1+1, o5_1, o5_0 {
 				s6 := o5_0
-				if s6.Op != OpPPC64SLDconst || s6.AuxInt != 8 {
+				if s6.Op != OpPPC64SLDconst || auxIntToInt64(s6.AuxInt) != 8 {
 					continue
 				}
 				x6 := s6.Args[0]
 				if x6.Op != OpPPC64MOVBZload {
 					continue
 				}
-				i6 := x6.AuxInt
-				if x6.Aux != s {
+				i6 := auxIntToInt32(x6.AuxInt)
+				if auxToSym(x6.Aux) != s {
 					continue
 				}
 				_ = x6.Args[1]
@@ -11577,15 +11675,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 				o4_1 := o4.Args[1]
 				for _i2 := 0; _i2 <= 1; _i2, o4_0, o4_1 = _i2+1, o4_1, o4_0 {
 					s5 := o4_0
-					if s5.Op != OpPPC64SLDconst || s5.AuxInt != 16 {
+					if s5.Op != OpPPC64SLDconst || auxIntToInt64(s5.AuxInt) != 16 {
 						continue
 					}
 					x5 := s5.Args[0]
 					if x5.Op != OpPPC64MOVBZload {
 						continue
 					}
-					i5 := x5.AuxInt
-					if x5.Aux != s {
+					i5 := auxIntToInt32(x5.AuxInt)
+					if auxToSym(x5.Aux) != s {
 						continue
 					}
 					_ = x5.Args[1]
@@ -11601,15 +11699,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 					o3_1 := o3.Args[1]
 					for _i3 := 0; _i3 <= 1; _i3, o3_0, o3_1 = _i3+1, o3_1, o3_0 {
 						s4 := o3_0
-						if s4.Op != OpPPC64SLDconst || s4.AuxInt != 24 {
+						if s4.Op != OpPPC64SLDconst || auxIntToInt64(s4.AuxInt) != 24 {
 							continue
 						}
 						x4 := s4.Args[0]
 						if x4.Op != OpPPC64MOVBZload {
 							continue
 						}
-						i4 := x4.AuxInt
-						if x4.Aux != s {
+						i4 := auxIntToInt32(x4.AuxInt)
+						if auxToSym(x4.Aux) != s {
 							continue
 						}
 						_ = x4.Args[1]
@@ -11617,7 +11715,7 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 							continue
 						}
 						s0 := o3_1
-						if s0.Op != OpPPC64SLWconst || s0.AuxInt != 32 {
+						if s0.Op != OpPPC64SLWconst || auxIntToInt64(s0.AuxInt) != 32 {
 							continue
 						}
 						x3 := s0.Args[0]
@@ -11629,16 +11727,16 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 						if x3_0.Op != OpPPC64MOVDaddr || x3_0.Type != typ.Uintptr {
 							continue
 						}
-						i0 := x3_0.AuxInt
-						if x3_0.Aux != s || p != x3_0.Args[0] || mem != x3.Args[1] || !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3, x4, x5, x6, x7, o3, o4, o5, s0, s4, s5, s6)) {
+						i0 := auxIntToInt32(x3_0.AuxInt)
+						if auxToSym(x3_0.Aux) != s || p != x3_0.Args[0] || mem != x3.Args[1] || !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3, x4, x5, x6, x7, o3, o4, o5, s0, s4, s5, s6)) {
 							continue
 						}
 						b = mergePoint(b, x3, x4, x5, x6, x7)
 						v0 := b.NewValue0(x3.Pos, OpPPC64MOVDBRload, t)
 						v.copyOf(v0)
 						v1 := b.NewValue0(x3.Pos, OpPPC64MOVDaddr, typ.Uintptr)
-						v1.AuxInt = i0
-						v1.Aux = s
+						v1.AuxInt = int32ToAuxInt(i0)
+						v1.Aux = symToAux(s)
 						v1.AddArg(p)
 						v0.AddArg2(v1, mem)
 						return true
@@ -11658,8 +11756,8 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			if x7.Op != OpPPC64MOVBZload {
 				continue
 			}
-			i7 := x7.AuxInt
-			s := x7.Aux
+			i7 := auxIntToInt32(x7.AuxInt)
+			s := auxToSym(x7.Aux)
 			mem := x7.Args[1]
 			p := x7.Args[0]
 			o5 := v_1
@@ -11671,15 +11769,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 			o5_1 := o5.Args[1]
 			for _i1 := 0; _i1 <= 1; _i1, o5_0, o5_1 = _i1+1, o5_1, o5_0 {
 				s6 := o5_0
-				if s6.Op != OpPPC64SLDconst || s6.AuxInt != 8 {
+				if s6.Op != OpPPC64SLDconst || auxIntToInt64(s6.AuxInt) != 8 {
 					continue
 				}
 				x6 := s6.Args[0]
 				if x6.Op != OpPPC64MOVBZload {
 					continue
 				}
-				i6 := x6.AuxInt
-				if x6.Aux != s {
+				i6 := auxIntToInt32(x6.AuxInt)
+				if auxToSym(x6.Aux) != s {
 					continue
 				}
 				_ = x6.Args[1]
@@ -11695,15 +11793,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 				o4_1 := o4.Args[1]
 				for _i2 := 0; _i2 <= 1; _i2, o4_0, o4_1 = _i2+1, o4_1, o4_0 {
 					s5 := o4_0
-					if s5.Op != OpPPC64SLDconst || s5.AuxInt != 16 {
+					if s5.Op != OpPPC64SLDconst || auxIntToInt64(s5.AuxInt) != 16 {
 						continue
 					}
 					x5 := s5.Args[0]
 					if x5.Op != OpPPC64MOVBZload {
 						continue
 					}
-					i5 := x5.AuxInt
-					if x5.Aux != s {
+					i5 := auxIntToInt32(x5.AuxInt)
+					if auxToSym(x5.Aux) != s {
 						continue
 					}
 					_ = x5.Args[1]
@@ -11719,15 +11817,15 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 					o3_1 := o3.Args[1]
 					for _i3 := 0; _i3 <= 1; _i3, o3_0, o3_1 = _i3+1, o3_1, o3_0 {
 						s4 := o3_0
-						if s4.Op != OpPPC64SLDconst || s4.AuxInt != 24 {
+						if s4.Op != OpPPC64SLDconst || auxIntToInt64(s4.AuxInt) != 24 {
 							continue
 						}
 						x4 := s4.Args[0]
 						if x4.Op != OpPPC64MOVBZload {
 							continue
 						}
-						i4 := x4.AuxInt
-						if x4.Aux != s {
+						i4 := auxIntToInt32(x4.AuxInt)
+						if auxToSym(x4.Aux) != s {
 							continue
 						}
 						_ = x4.Args[1]
@@ -11735,7 +11833,7 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 							continue
 						}
 						s0 := o3_1
-						if s0.Op != OpPPC64SLDconst || s0.AuxInt != 32 {
+						if s0.Op != OpPPC64SLDconst || auxIntToInt64(s0.AuxInt) != 32 {
 							continue
 						}
 						x3 := s0.Args[0]
@@ -11747,16 +11845,16 @@ func rewriteValuePPC64_OpPPC64OR(v *Value) bool {
 						if x3_0.Op != OpPPC64MOVDaddr || x3_0.Type != typ.Uintptr {
 							continue
 						}
-						i0 := x3_0.AuxInt
-						if x3_0.Aux != s || p != x3_0.Args[0] || mem != x3.Args[1] || !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3, x4, x5, x6, x7, o3, o4, o5, s0, s4, s5, s6)) {
+						i0 := auxIntToInt32(x3_0.AuxInt)
+						if auxToSym(x3_0.Aux) != s || p != x3_0.Args[0] || mem != x3.Args[1] || !(!config.BigEndian && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1 && x7.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1 && s0.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1 && mergePoint(b, x3, x4, x5, x6, x7) != nil && clobber(x3, x4, x5, x6, x7, o3, o4, o5, s0, s4, s5, s6)) {
 							continue
 						}
 						b = mergePoint(b, x3, x4, x5, x6, x7)
 						v0 := b.NewValue0(x3.Pos, OpPPC64MOVDBRload, t)
 						v.copyOf(v0)
 						v1 := b.NewValue0(x3.Pos, OpPPC64MOVDaddr, typ.Uintptr)
-						v1.AuxInt = i0
-						v1.Aux = s
+						v1.AuxInt = int32ToAuxInt(i0)
+						v1.Aux = symToAux(s)
 						v1.AddArg(p)
 						v0.AddArg2(v1, mem)
 						return true
@@ -11775,7 +11873,7 @@ func rewriteValuePPC64_OpPPC64ORN(v *Value) bool {
 	// result: x
 	for {
 		x := v_0
-		if v_1.Op != OpPPC64MOVDconst || v_1.AuxInt != -1 {
+		if v_1.Op != OpPPC64MOVDconst || auxIntToInt64(v_1.AuxInt) != -1 {
 			break
 		}
 		v.copyOf(x)
@@ -11787,13 +11885,13 @@ func rewriteValuePPC64_OpPPC64ORN(v *Value) bool {
 		if v_0.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_0.AuxInt
+		c := auxIntToInt64(v_0.AuxInt)
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		d := v_1.AuxInt
+		d := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = c | ^d
+		v.AuxInt = int64ToAuxInt(c | ^d)
 		return true
 	}
 	return false
@@ -11803,31 +11901,31 @@ func rewriteValuePPC64_OpPPC64ORconst(v *Value) bool {
 	// match: (ORconst [c] (ORconst [d] x))
 	// result: (ORconst [c|d] x)
 	for {
-		c := v.AuxInt
+		c := auxIntToInt64(v.AuxInt)
 		if v_0.Op != OpPPC64ORconst {
 			break
 		}
-		d := v_0.AuxInt
+		d := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		v.reset(OpPPC64ORconst)
-		v.AuxInt = c | d
+		v.AuxInt = int64ToAuxInt(c | d)
 		v.AddArg(x)
 		return true
 	}
 	// match: (ORconst [-1] _)
 	// result: (MOVDconst [-1])
 	for {
-		if v.AuxInt != -1 {
+		if auxIntToInt64(v.AuxInt) != -1 {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = -1
+		v.AuxInt = int64ToAuxInt(-1)
 		return true
 	}
 	// match: (ORconst [0] x)
 	// result: x
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt64(v.AuxInt) != 0 {
 			break
 		}
 		x := v_0
@@ -11846,9 +11944,9 @@ func rewriteValuePPC64_OpPPC64ROTL(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpPPC64ROTLconst)
-		v.AuxInt = c & 63
+		v.AuxInt = int64ToAuxInt(c & 63)
 		v.AddArg(x)
 		return true
 	}
@@ -11864,9 +11962,9 @@ func rewriteValuePPC64_OpPPC64ROTLW(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpPPC64ROTLWconst)
-		v.AuxInt = c & 31
+		v.AuxInt = int64ToAuxInt(c & 31)
 		v.AddArg(x)
 		return true
 	}
@@ -11882,9 +11980,9 @@ func rewriteValuePPC64_OpPPC64SLD(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpPPC64SLDconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -11900,9 +11998,9 @@ func rewriteValuePPC64_OpPPC64SLW(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpPPC64SLWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -11918,9 +12016,9 @@ func rewriteValuePPC64_OpPPC64SRAD(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpPPC64SRADconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -11936,9 +12034,9 @@ func rewriteValuePPC64_OpPPC64SRAW(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -11954,9 +12052,9 @@ func rewriteValuePPC64_OpPPC64SRD(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpPPC64SRDconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -11972,9 +12070,9 @@ func rewriteValuePPC64_OpPPC64SRW(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -11991,12 +12089,12 @@ func rewriteValuePPC64_OpPPC64SUB(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(is32Bit(-c)) {
 			break
 		}
 		v.reset(OpPPC64ADDconst)
-		v.AuxInt = -c
+		v.AuxInt = int64ToAuxInt(-c)
 		v.AddArg(x)
 		return true
 	}
@@ -12015,17 +12113,17 @@ func rewriteValuePPC64_OpPPC64XOR(v *Value) bool {
 			if v_0.Op != OpPPC64SLDconst {
 				continue
 			}
-			c := v_0.AuxInt
+			c := auxIntToInt64(v_0.AuxInt)
 			x := v_0.Args[0]
 			if v_1.Op != OpPPC64SRDconst {
 				continue
 			}
-			d := v_1.AuxInt
+			d := auxIntToInt64(v_1.AuxInt)
 			if x != v_1.Args[0] || !(d == 64-c) {
 				continue
 			}
 			v.reset(OpPPC64ROTLconst)
-			v.AuxInt = c
+			v.AuxInt = int64ToAuxInt(c)
 			v.AddArg(x)
 			return true
 		}
@@ -12039,17 +12137,17 @@ func rewriteValuePPC64_OpPPC64XOR(v *Value) bool {
 			if v_0.Op != OpPPC64SLWconst {
 				continue
 			}
-			c := v_0.AuxInt
+			c := auxIntToInt64(v_0.AuxInt)
 			x := v_0.Args[0]
 			if v_1.Op != OpPPC64SRWconst {
 				continue
 			}
-			d := v_1.AuxInt
+			d := auxIntToInt64(v_1.AuxInt)
 			if x != v_1.Args[0] || !(d == 32-c) {
 				continue
 			}
 			v.reset(OpPPC64ROTLWconst)
-			v.AuxInt = c
+			v.AuxInt = int64ToAuxInt(c)
 			v.AddArg(x)
 			return true
 		}
@@ -12065,7 +12163,7 @@ func rewriteValuePPC64_OpPPC64XOR(v *Value) bool {
 			_ = v_0.Args[1]
 			x := v_0.Args[0]
 			v_0_1 := v_0.Args[1]
-			if v_0_1.Op != OpPPC64ANDconst || v_0_1.Type != typ.Int64 || v_0_1.AuxInt != 63 {
+			if v_0_1.Op != OpPPC64ANDconst || v_0_1.Type != typ.Int64 || auxIntToInt64(v_0_1.AuxInt) != 63 {
 				continue
 			}
 			y := v_0_1.Args[0]
@@ -12082,11 +12180,11 @@ func rewriteValuePPC64_OpPPC64XOR(v *Value) bool {
 			}
 			_ = v_1_1.Args[1]
 			v_1_1_0 := v_1_1.Args[0]
-			if v_1_1_0.Op != OpPPC64MOVDconst || v_1_1_0.AuxInt != 64 {
+			if v_1_1_0.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_1_0.AuxInt) != 64 {
 				continue
 			}
 			v_1_1_1 := v_1_1.Args[1]
-			if v_1_1_1.Op != OpPPC64ANDconst || v_1_1_1.Type != typ.UInt || v_1_1_1.AuxInt != 63 || y != v_1_1_1.Args[0] {
+			if v_1_1_1.Op != OpPPC64ANDconst || v_1_1_1.Type != typ.UInt || auxIntToInt64(v_1_1_1.AuxInt) != 63 || y != v_1_1_1.Args[0] {
 				continue
 			}
 			v.reset(OpPPC64ROTL)
@@ -12105,7 +12203,7 @@ func rewriteValuePPC64_OpPPC64XOR(v *Value) bool {
 			_ = v_0.Args[1]
 			x := v_0.Args[0]
 			v_0_1 := v_0.Args[1]
-			if v_0_1.Op != OpPPC64ANDconst || v_0_1.Type != typ.Int32 || v_0_1.AuxInt != 31 {
+			if v_0_1.Op != OpPPC64ANDconst || v_0_1.Type != typ.Int32 || auxIntToInt64(v_0_1.AuxInt) != 31 {
 				continue
 			}
 			y := v_0_1.Args[0]
@@ -12122,11 +12220,11 @@ func rewriteValuePPC64_OpPPC64XOR(v *Value) bool {
 			}
 			_ = v_1_1.Args[1]
 			v_1_1_0 := v_1_1.Args[0]
-			if v_1_1_0.Op != OpPPC64MOVDconst || v_1_1_0.AuxInt != 32 {
+			if v_1_1_0.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_1_0.AuxInt) != 32 {
 				continue
 			}
 			v_1_1_1 := v_1_1.Args[1]
-			if v_1_1_1.Op != OpPPC64ANDconst || v_1_1_1.Type != typ.UInt || v_1_1_1.AuxInt != 31 || y != v_1_1_1.Args[0] {
+			if v_1_1_1.Op != OpPPC64ANDconst || v_1_1_1.Type != typ.UInt || auxIntToInt64(v_1_1_1.AuxInt) != 31 || y != v_1_1_1.Args[0] {
 				continue
 			}
 			v.reset(OpPPC64ROTLW)
@@ -12142,13 +12240,13 @@ func rewriteValuePPC64_OpPPC64XOR(v *Value) bool {
 			if v_0.Op != OpPPC64MOVDconst {
 				continue
 			}
-			c := v_0.AuxInt
+			c := auxIntToInt64(v_0.AuxInt)
 			if v_1.Op != OpPPC64MOVDconst {
 				continue
 			}
-			d := v_1.AuxInt
+			d := auxIntToInt64(v_1.AuxInt)
 			v.reset(OpPPC64MOVDconst)
-			v.AuxInt = c ^ d
+			v.AuxInt = int64ToAuxInt(c ^ d)
 			return true
 		}
 		break
@@ -12162,12 +12260,12 @@ func rewriteValuePPC64_OpPPC64XOR(v *Value) bool {
 			if v_1.Op != OpPPC64MOVDconst {
 				continue
 			}
-			c := v_1.AuxInt
+			c := auxIntToInt64(v_1.AuxInt)
 			if !(isU32Bit(c)) {
 				continue
 			}
 			v.reset(OpPPC64XORconst)
-			v.AuxInt = c
+			v.AuxInt = int64ToAuxInt(c)
 			v.AddArg(x)
 			return true
 		}
@@ -12180,21 +12278,21 @@ func rewriteValuePPC64_OpPPC64XORconst(v *Value) bool {
 	// match: (XORconst [c] (XORconst [d] x))
 	// result: (XORconst [c^d] x)
 	for {
-		c := v.AuxInt
+		c := auxIntToInt64(v.AuxInt)
 		if v_0.Op != OpPPC64XORconst {
 			break
 		}
-		d := v_0.AuxInt
+		d := auxIntToInt64(v_0.AuxInt)
 		x := v_0.Args[0]
 		v.reset(OpPPC64XORconst)
-		v.AuxInt = c ^ d
+		v.AuxInt = int64ToAuxInt(c ^ d)
 		v.AddArg(x)
 		return true
 	}
 	// match: (XORconst [0] x)
 	// result: x
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt64(v.AuxInt) != 0 {
 			break
 		}
 		x := v_0
@@ -12211,7 +12309,7 @@ func rewriteValuePPC64_OpPanicBounds(v *Value) bool {
 	// cond: boundsABI(kind) == 0
 	// result: (LoweredPanicBoundsA [kind] x y mem)
 	for {
-		kind := v.AuxInt
+		kind := auxIntToInt64(v.AuxInt)
 		x := v_0
 		y := v_1
 		mem := v_2
@@ -12219,7 +12317,7 @@ func rewriteValuePPC64_OpPanicBounds(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64LoweredPanicBoundsA)
-		v.AuxInt = kind
+		v.AuxInt = int64ToAuxInt(kind)
 		v.AddArg3(x, y, mem)
 		return true
 	}
@@ -12227,7 +12325,7 @@ func rewriteValuePPC64_OpPanicBounds(v *Value) bool {
 	// cond: boundsABI(kind) == 1
 	// result: (LoweredPanicBoundsB [kind] x y mem)
 	for {
-		kind := v.AuxInt
+		kind := auxIntToInt64(v.AuxInt)
 		x := v_0
 		y := v_1
 		mem := v_2
@@ -12235,7 +12333,7 @@ func rewriteValuePPC64_OpPanicBounds(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64LoweredPanicBoundsB)
-		v.AuxInt = kind
+		v.AuxInt = int64ToAuxInt(kind)
 		v.AddArg3(x, y, mem)
 		return true
 	}
@@ -12243,7 +12341,7 @@ func rewriteValuePPC64_OpPanicBounds(v *Value) bool {
 	// cond: boundsABI(kind) == 2
 	// result: (LoweredPanicBoundsC [kind] x y mem)
 	for {
-		kind := v.AuxInt
+		kind := auxIntToInt64(v.AuxInt)
 		x := v_0
 		y := v_1
 		mem := v_2
@@ -12251,7 +12349,7 @@ func rewriteValuePPC64_OpPanicBounds(v *Value) bool {
 			break
 		}
 		v.reset(OpPPC64LoweredPanicBoundsC)
-		v.AuxInt = kind
+		v.AuxInt = int64ToAuxInt(kind)
 		v.AddArg3(x, y, mem)
 		return true
 	}
@@ -12315,15 +12413,15 @@ func rewriteValuePPC64_OpRotateLeft16(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpOr16)
 		v0 := b.NewValue0(v.Pos, OpLsh16x64, t)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = c & 15
+		v1.AuxInt = int64ToAuxInt(c & 15)
 		v0.AddArg2(x, v1)
 		v2 := b.NewValue0(v.Pos, OpRsh16Ux64, t)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v3.AuxInt = -c & 15
+		v3.AuxInt = int64ToAuxInt(-c & 15)
 		v2.AddArg2(x, v3)
 		v.AddArg2(v0, v2)
 		return true
@@ -12340,9 +12438,9 @@ func rewriteValuePPC64_OpRotateLeft32(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpPPC64ROTLWconst)
-		v.AuxInt = c & 31
+		v.AuxInt = int64ToAuxInt(c & 31)
 		v.AddArg(x)
 		return true
 	}
@@ -12366,9 +12464,9 @@ func rewriteValuePPC64_OpRotateLeft64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpPPC64ROTLconst)
-		v.AuxInt = c & 63
+		v.AuxInt = int64ToAuxInt(c & 63)
 		v.AddArg(x)
 		return true
 	}
@@ -12395,15 +12493,15 @@ func rewriteValuePPC64_OpRotateLeft8(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		v.reset(OpOr8)
 		v0 := b.NewValue0(v.Pos, OpLsh8x64, t)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = c & 7
+		v1.AuxInt = int64ToAuxInt(c & 7)
 		v0.AddArg2(x, v1)
 		v2 := b.NewValue0(v.Pos, OpRsh8Ux64, t)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v3.AuxInt = -c & 7
+		v3.AuxInt = int64ToAuxInt(-c & 7)
 		v2.AddArg2(x, v3)
 		v.AddArg2(v0, v2)
 		return true
@@ -12439,14 +12537,14 @@ func rewriteValuePPC64_OpRsh16Ux16(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32)
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v1.AuxInt = 0
+		v1.AuxInt = int32ToAuxInt(0)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v3 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v4 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
 		v4.AddArg(y)
 		v5 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v5.AuxInt = 16
+		v5.AuxInt = int64ToAuxInt(16)
 		v3.AddArg2(v4, v5)
 		v1.AddArg3(y, v2, v3)
 		v.AddArg2(v0, v1)
@@ -12466,12 +12564,12 @@ func rewriteValuePPC64_OpRsh16Ux32(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint32(c) < 16) {
 			break
 		}
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -12501,12 +12599,12 @@ func rewriteValuePPC64_OpRsh16Ux32(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32)
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v1.AuxInt = 0
+		v1.AuxInt = int32ToAuxInt(0)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v3 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 16
+		v4.AuxInt = int64ToAuxInt(16)
 		v3.AddArg2(y, v4)
 		v1.AddArg3(y, v2, v3)
 		v.AddArg2(v0, v1)
@@ -12525,12 +12623,12 @@ func rewriteValuePPC64_OpRsh16Ux64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) >= 16) {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (Rsh16Ux64 x (MOVDconst [c]))
@@ -12541,12 +12639,12 @@ func rewriteValuePPC64_OpRsh16Ux64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) < 16) {
 			break
 		}
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -12576,12 +12674,12 @@ func rewriteValuePPC64_OpRsh16Ux64(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32)
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v1.AuxInt = 0
+		v1.AuxInt = int32ToAuxInt(0)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v3 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 16
+		v4.AuxInt = int64ToAuxInt(16)
 		v3.AddArg2(y, v4)
 		v1.AddArg3(y, v2, v3)
 		v.AddArg2(v0, v1)
@@ -12617,14 +12715,14 @@ func rewriteValuePPC64_OpRsh16Ux8(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32)
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v1.AuxInt = 0
+		v1.AuxInt = int32ToAuxInt(0)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v3 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v4 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
 		v4.AddArg(y)
 		v5 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v5.AuxInt = 16
+		v5.AuxInt = int64ToAuxInt(16)
 		v3.AddArg2(v4, v5)
 		v1.AddArg3(y, v2, v3)
 		v.AddArg2(v0, v1)
@@ -12660,14 +12758,14 @@ func rewriteValuePPC64_OpRsh16x16(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32)
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v1.AuxInt = 0
+		v1.AuxInt = int32ToAuxInt(0)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v3 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v4 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
 		v4.AddArg(y)
 		v5 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v5.AuxInt = 16
+		v5.AuxInt = int64ToAuxInt(16)
 		v3.AddArg2(v4, v5)
 		v1.AddArg3(y, v2, v3)
 		v.AddArg2(v0, v1)
@@ -12687,12 +12785,12 @@ func rewriteValuePPC64_OpRsh16x32(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint32(c) < 16) {
 			break
 		}
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -12722,12 +12820,12 @@ func rewriteValuePPC64_OpRsh16x32(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32)
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v1.AuxInt = 0
+		v1.AuxInt = int32ToAuxInt(0)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v3 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 16
+		v4.AuxInt = int64ToAuxInt(16)
 		v3.AddArg2(y, v4)
 		v1.AddArg3(y, v2, v3)
 		v.AddArg2(v0, v1)
@@ -12747,12 +12845,12 @@ func rewriteValuePPC64_OpRsh16x64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) >= 16) {
 			break
 		}
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = 63
+		v.AuxInt = int64ToAuxInt(63)
 		v0 := b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -12766,12 +12864,12 @@ func rewriteValuePPC64_OpRsh16x64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) < 16) {
 			break
 		}
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -12801,12 +12899,12 @@ func rewriteValuePPC64_OpRsh16x64(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32)
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v1.AuxInt = 0
+		v1.AuxInt = int32ToAuxInt(0)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v3 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 16
+		v4.AuxInt = int64ToAuxInt(16)
 		v3.AddArg2(y, v4)
 		v1.AddArg3(y, v2, v3)
 		v.AddArg2(v0, v1)
@@ -12842,14 +12940,14 @@ func rewriteValuePPC64_OpRsh16x8(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32)
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v1.AuxInt = 0
+		v1.AuxInt = int32ToAuxInt(0)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v3 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v4 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
 		v4.AddArg(y)
 		v5 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v5.AuxInt = 16
+		v5.AuxInt = int64ToAuxInt(16)
 		v3.AddArg2(v4, v5)
 		v1.AddArg3(y, v2, v3)
 		v.AddArg2(v0, v1)
@@ -12881,14 +12979,14 @@ func rewriteValuePPC64_OpRsh32Ux16(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SRW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
 		v3.AddArg(y)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 32
+		v4.AuxInt = int64ToAuxInt(32)
 		v2.AddArg2(v3, v4)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -12908,12 +13006,12 @@ func rewriteValuePPC64_OpRsh32Ux32(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint32(c) < 32) {
 			break
 		}
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -12937,12 +13035,12 @@ func rewriteValuePPC64_OpRsh32Ux32(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SRW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v3.AuxInt = 32
+		v3.AuxInt = int64ToAuxInt(32)
 		v2.AddArg2(y, v3)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -12961,12 +13059,12 @@ func rewriteValuePPC64_OpRsh32Ux64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) >= 32) {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (Rsh32Ux64 x (MOVDconst [c]))
@@ -12977,12 +13075,12 @@ func rewriteValuePPC64_OpRsh32Ux64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) < 32) {
 			break
 		}
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -13011,12 +13109,12 @@ func rewriteValuePPC64_OpRsh32Ux64(v *Value) bool {
 		v_1_1 := v_1.Args[1]
 		for _i0 := 0; _i0 <= 1; _i0, v_1_0, v_1_1 = _i0+1, v_1_1, v_1_0 {
 			y := v_1_0
-			if v_1_1.Op != OpPPC64MOVDconst || v_1_1.AuxInt != 31 {
+			if v_1_1.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_1.AuxInt) != 31 {
 				continue
 			}
 			v.reset(OpPPC64SRW)
 			v0 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int32)
-			v0.AuxInt = 31
+			v0.AuxInt = int64ToAuxInt(31)
 			v0.AddArg(y)
 			v.AddArg2(x, v0)
 			return true
@@ -13027,13 +13125,13 @@ func rewriteValuePPC64_OpRsh32Ux64(v *Value) bool {
 	// result: (SRW x (ANDconst <typ.UInt> [31] y))
 	for {
 		x := v_0
-		if v_1.Op != OpPPC64ANDconst || v_1.Type != typ.UInt || v_1.AuxInt != 31 {
+		if v_1.Op != OpPPC64ANDconst || v_1.Type != typ.UInt || auxIntToInt64(v_1.AuxInt) != 31 {
 			break
 		}
 		y := v_1.Args[0]
 		v.reset(OpPPC64SRW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt)
-		v0.AuxInt = 31
+		v0.AuxInt = int64ToAuxInt(31)
 		v0.AddArg(y)
 		v.AddArg2(x, v0)
 		return true
@@ -13047,20 +13145,20 @@ func rewriteValuePPC64_OpRsh32Ux64(v *Value) bool {
 		}
 		_ = v_1.Args[1]
 		v_1_0 := v_1.Args[0]
-		if v_1_0.Op != OpPPC64MOVDconst || v_1_0.AuxInt != 32 {
+		if v_1_0.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_0.AuxInt) != 32 {
 			break
 		}
 		v_1_1 := v_1.Args[1]
-		if v_1_1.Op != OpPPC64ANDconst || v_1_1.Type != typ.UInt || v_1_1.AuxInt != 31 {
+		if v_1_1.Op != OpPPC64ANDconst || v_1_1.Type != typ.UInt || auxIntToInt64(v_1_1.AuxInt) != 31 {
 			break
 		}
 		y := v_1_1.Args[0]
 		v.reset(OpPPC64SRW)
 		v0 := b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = 32
+		v1.AuxInt = int64ToAuxInt(32)
 		v2 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt)
-		v2.AuxInt = 31
+		v2.AuxInt = int64ToAuxInt(31)
 		v2.AddArg(y)
 		v0.AddArg2(v1, v2)
 		v.AddArg2(x, v0)
@@ -13075,7 +13173,7 @@ func rewriteValuePPC64_OpRsh32Ux64(v *Value) bool {
 		}
 		_ = v_1.Args[1]
 		v_1_0 := v_1.Args[0]
-		if v_1_0.Op != OpPPC64MOVDconst || v_1_0.AuxInt != 32 {
+		if v_1_0.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_0.AuxInt) != 32 {
 			break
 		}
 		v_1_1 := v_1.Args[1]
@@ -13087,15 +13185,15 @@ func rewriteValuePPC64_OpRsh32Ux64(v *Value) bool {
 		v_1_1_1 := v_1_1.Args[1]
 		for _i0 := 0; _i0 <= 1; _i0, v_1_1_0, v_1_1_1 = _i0+1, v_1_1_1, v_1_1_0 {
 			y := v_1_1_0
-			if v_1_1_1.Op != OpPPC64MOVDconst || v_1_1_1.AuxInt != 31 {
+			if v_1_1_1.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_1_1.AuxInt) != 31 {
 				continue
 			}
 			v.reset(OpPPC64SRW)
 			v0 := b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt)
 			v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-			v1.AuxInt = 32
+			v1.AuxInt = int64ToAuxInt(32)
 			v2 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt)
-			v2.AuxInt = 31
+			v2.AuxInt = int64ToAuxInt(31)
 			v2.AddArg(y)
 			v0.AddArg2(v1, v2)
 			v.AddArg2(x, v0)
@@ -13110,12 +13208,12 @@ func rewriteValuePPC64_OpRsh32Ux64(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SRW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v3.AuxInt = 32
+		v3.AuxInt = int64ToAuxInt(32)
 		v2.AddArg2(y, v3)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -13147,14 +13245,14 @@ func rewriteValuePPC64_OpRsh32Ux8(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SRW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
 		v3.AddArg(y)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 32
+		v4.AuxInt = int64ToAuxInt(32)
 		v2.AddArg2(v3, v4)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -13186,14 +13284,14 @@ func rewriteValuePPC64_OpRsh32x16(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SRAW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
 		v3.AddArg(y)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 32
+		v4.AuxInt = int64ToAuxInt(32)
 		v2.AddArg2(v3, v4)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -13213,12 +13311,12 @@ func rewriteValuePPC64_OpRsh32x32(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint32(c) < 32) {
 			break
 		}
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -13242,12 +13340,12 @@ func rewriteValuePPC64_OpRsh32x32(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SRAW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v3.AuxInt = 32
+		v3.AuxInt = int64ToAuxInt(32)
 		v2.AddArg2(y, v3)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -13267,12 +13365,12 @@ func rewriteValuePPC64_OpRsh32x64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) >= 32) {
 			break
 		}
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = 63
+		v.AuxInt = int64ToAuxInt(63)
 		v.AddArg(x)
 		return true
 	}
@@ -13284,12 +13382,12 @@ func rewriteValuePPC64_OpRsh32x64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) < 32) {
 			break
 		}
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -13318,12 +13416,12 @@ func rewriteValuePPC64_OpRsh32x64(v *Value) bool {
 		v_1_1 := v_1.Args[1]
 		for _i0 := 0; _i0 <= 1; _i0, v_1_0, v_1_1 = _i0+1, v_1_1, v_1_0 {
 			y := v_1_0
-			if v_1_1.Op != OpPPC64MOVDconst || v_1_1.AuxInt != 31 {
+			if v_1_1.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_1.AuxInt) != 31 {
 				continue
 			}
 			v.reset(OpPPC64SRAW)
 			v0 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int32)
-			v0.AuxInt = 31
+			v0.AuxInt = int64ToAuxInt(31)
 			v0.AddArg(y)
 			v.AddArg2(x, v0)
 			return true
@@ -13334,13 +13432,13 @@ func rewriteValuePPC64_OpRsh32x64(v *Value) bool {
 	// result: (SRAW x (ANDconst <typ.UInt> [31] y))
 	for {
 		x := v_0
-		if v_1.Op != OpPPC64ANDconst || v_1.Type != typ.UInt || v_1.AuxInt != 31 {
+		if v_1.Op != OpPPC64ANDconst || v_1.Type != typ.UInt || auxIntToInt64(v_1.AuxInt) != 31 {
 			break
 		}
 		y := v_1.Args[0]
 		v.reset(OpPPC64SRAW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt)
-		v0.AuxInt = 31
+		v0.AuxInt = int64ToAuxInt(31)
 		v0.AddArg(y)
 		v.AddArg2(x, v0)
 		return true
@@ -13354,20 +13452,20 @@ func rewriteValuePPC64_OpRsh32x64(v *Value) bool {
 		}
 		_ = v_1.Args[1]
 		v_1_0 := v_1.Args[0]
-		if v_1_0.Op != OpPPC64MOVDconst || v_1_0.AuxInt != 32 {
+		if v_1_0.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_0.AuxInt) != 32 {
 			break
 		}
 		v_1_1 := v_1.Args[1]
-		if v_1_1.Op != OpPPC64ANDconst || v_1_1.Type != typ.UInt || v_1_1.AuxInt != 31 {
+		if v_1_1.Op != OpPPC64ANDconst || v_1_1.Type != typ.UInt || auxIntToInt64(v_1_1.AuxInt) != 31 {
 			break
 		}
 		y := v_1_1.Args[0]
 		v.reset(OpPPC64SRAW)
 		v0 := b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = 32
+		v1.AuxInt = int64ToAuxInt(32)
 		v2 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt)
-		v2.AuxInt = 31
+		v2.AuxInt = int64ToAuxInt(31)
 		v2.AddArg(y)
 		v0.AddArg2(v1, v2)
 		v.AddArg2(x, v0)
@@ -13382,7 +13480,7 @@ func rewriteValuePPC64_OpRsh32x64(v *Value) bool {
 		}
 		_ = v_1.Args[1]
 		v_1_0 := v_1.Args[0]
-		if v_1_0.Op != OpPPC64MOVDconst || v_1_0.AuxInt != 32 {
+		if v_1_0.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_0.AuxInt) != 32 {
 			break
 		}
 		v_1_1 := v_1.Args[1]
@@ -13394,15 +13492,15 @@ func rewriteValuePPC64_OpRsh32x64(v *Value) bool {
 		v_1_1_1 := v_1_1.Args[1]
 		for _i0 := 0; _i0 <= 1; _i0, v_1_1_0, v_1_1_1 = _i0+1, v_1_1_1, v_1_1_0 {
 			y := v_1_1_0
-			if v_1_1_1.Op != OpPPC64MOVDconst || v_1_1_1.AuxInt != 31 {
+			if v_1_1_1.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_1_1.AuxInt) != 31 {
 				continue
 			}
 			v.reset(OpPPC64SRAW)
 			v0 := b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt)
 			v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-			v1.AuxInt = 32
+			v1.AuxInt = int64ToAuxInt(32)
 			v2 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt)
-			v2.AuxInt = 31
+			v2.AuxInt = int64ToAuxInt(31)
 			v2.AddArg(y)
 			v0.AddArg2(v1, v2)
 			v.AddArg2(x, v0)
@@ -13417,12 +13515,12 @@ func rewriteValuePPC64_OpRsh32x64(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SRAW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v3.AuxInt = 32
+		v3.AuxInt = int64ToAuxInt(32)
 		v2.AddArg2(y, v3)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -13454,14 +13552,14 @@ func rewriteValuePPC64_OpRsh32x8(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SRAW)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
 		v3.AddArg(y)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 32
+		v4.AuxInt = int64ToAuxInt(32)
 		v2.AddArg2(v3, v4)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -13493,14 +13591,14 @@ func rewriteValuePPC64_OpRsh64Ux16(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SRD)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
 		v3.AddArg(y)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 64
+		v4.AuxInt = int64ToAuxInt(64)
 		v2.AddArg2(v3, v4)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -13520,12 +13618,12 @@ func rewriteValuePPC64_OpRsh64Ux32(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint32(c) < 64) {
 			break
 		}
 		v.reset(OpPPC64SRDconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -13549,12 +13647,12 @@ func rewriteValuePPC64_OpRsh64Ux32(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SRD)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v3.AuxInt = 64
+		v3.AuxInt = int64ToAuxInt(64)
 		v2.AddArg2(y, v3)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -13573,12 +13671,12 @@ func rewriteValuePPC64_OpRsh64Ux64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) >= 64) {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (Rsh64Ux64 x (MOVDconst [c]))
@@ -13589,12 +13687,12 @@ func rewriteValuePPC64_OpRsh64Ux64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) < 64) {
 			break
 		}
 		v.reset(OpPPC64SRDconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -13623,12 +13721,12 @@ func rewriteValuePPC64_OpRsh64Ux64(v *Value) bool {
 		v_1_1 := v_1.Args[1]
 		for _i0 := 0; _i0 <= 1; _i0, v_1_0, v_1_1 = _i0+1, v_1_1, v_1_0 {
 			y := v_1_0
-			if v_1_1.Op != OpPPC64MOVDconst || v_1_1.AuxInt != 63 {
+			if v_1_1.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_1.AuxInt) != 63 {
 				continue
 			}
 			v.reset(OpPPC64SRD)
 			v0 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int64)
-			v0.AuxInt = 63
+			v0.AuxInt = int64ToAuxInt(63)
 			v0.AddArg(y)
 			v.AddArg2(x, v0)
 			return true
@@ -13639,13 +13737,13 @@ func rewriteValuePPC64_OpRsh64Ux64(v *Value) bool {
 	// result: (SRD x (ANDconst <typ.UInt> [63] y))
 	for {
 		x := v_0
-		if v_1.Op != OpPPC64ANDconst || v_1.Type != typ.UInt || v_1.AuxInt != 63 {
+		if v_1.Op != OpPPC64ANDconst || v_1.Type != typ.UInt || auxIntToInt64(v_1.AuxInt) != 63 {
 			break
 		}
 		y := v_1.Args[0]
 		v.reset(OpPPC64SRD)
 		v0 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt)
-		v0.AuxInt = 63
+		v0.AuxInt = int64ToAuxInt(63)
 		v0.AddArg(y)
 		v.AddArg2(x, v0)
 		return true
@@ -13659,20 +13757,20 @@ func rewriteValuePPC64_OpRsh64Ux64(v *Value) bool {
 		}
 		_ = v_1.Args[1]
 		v_1_0 := v_1.Args[0]
-		if v_1_0.Op != OpPPC64MOVDconst || v_1_0.AuxInt != 64 {
+		if v_1_0.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_0.AuxInt) != 64 {
 			break
 		}
 		v_1_1 := v_1.Args[1]
-		if v_1_1.Op != OpPPC64ANDconst || v_1_1.Type != typ.UInt || v_1_1.AuxInt != 63 {
+		if v_1_1.Op != OpPPC64ANDconst || v_1_1.Type != typ.UInt || auxIntToInt64(v_1_1.AuxInt) != 63 {
 			break
 		}
 		y := v_1_1.Args[0]
 		v.reset(OpPPC64SRD)
 		v0 := b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = 64
+		v1.AuxInt = int64ToAuxInt(64)
 		v2 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt)
-		v2.AuxInt = 63
+		v2.AuxInt = int64ToAuxInt(63)
 		v2.AddArg(y)
 		v0.AddArg2(v1, v2)
 		v.AddArg2(x, v0)
@@ -13687,7 +13785,7 @@ func rewriteValuePPC64_OpRsh64Ux64(v *Value) bool {
 		}
 		_ = v_1.Args[1]
 		v_1_0 := v_1.Args[0]
-		if v_1_0.Op != OpPPC64MOVDconst || v_1_0.AuxInt != 64 {
+		if v_1_0.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_0.AuxInt) != 64 {
 			break
 		}
 		v_1_1 := v_1.Args[1]
@@ -13699,15 +13797,15 @@ func rewriteValuePPC64_OpRsh64Ux64(v *Value) bool {
 		v_1_1_1 := v_1_1.Args[1]
 		for _i0 := 0; _i0 <= 1; _i0, v_1_1_0, v_1_1_1 = _i0+1, v_1_1_1, v_1_1_0 {
 			y := v_1_1_0
-			if v_1_1_1.Op != OpPPC64MOVDconst || v_1_1_1.AuxInt != 63 {
+			if v_1_1_1.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_1_1.AuxInt) != 63 {
 				continue
 			}
 			v.reset(OpPPC64SRD)
 			v0 := b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt)
 			v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-			v1.AuxInt = 64
+			v1.AuxInt = int64ToAuxInt(64)
 			v2 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt)
-			v2.AuxInt = 63
+			v2.AuxInt = int64ToAuxInt(63)
 			v2.AddArg(y)
 			v0.AddArg2(v1, v2)
 			v.AddArg2(x, v0)
@@ -13722,12 +13820,12 @@ func rewriteValuePPC64_OpRsh64Ux64(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SRD)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v3.AuxInt = 64
+		v3.AuxInt = int64ToAuxInt(64)
 		v2.AddArg2(y, v3)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -13759,14 +13857,14 @@ func rewriteValuePPC64_OpRsh64Ux8(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SRD)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
 		v3.AddArg(y)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 64
+		v4.AuxInt = int64ToAuxInt(64)
 		v2.AddArg2(v3, v4)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -13798,14 +13896,14 @@ func rewriteValuePPC64_OpRsh64x16(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SRAD)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
 		v3.AddArg(y)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 64
+		v4.AuxInt = int64ToAuxInt(64)
 		v2.AddArg2(v3, v4)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -13825,12 +13923,12 @@ func rewriteValuePPC64_OpRsh64x32(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint32(c) < 64) {
 			break
 		}
 		v.reset(OpPPC64SRADconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -13854,12 +13952,12 @@ func rewriteValuePPC64_OpRsh64x32(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SRAD)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v3.AuxInt = 64
+		v3.AuxInt = int64ToAuxInt(64)
 		v2.AddArg2(y, v3)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -13879,12 +13977,12 @@ func rewriteValuePPC64_OpRsh64x64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) >= 64) {
 			break
 		}
 		v.reset(OpPPC64SRADconst)
-		v.AuxInt = 63
+		v.AuxInt = int64ToAuxInt(63)
 		v.AddArg(x)
 		return true
 	}
@@ -13896,12 +13994,12 @@ func rewriteValuePPC64_OpRsh64x64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) < 64) {
 			break
 		}
 		v.reset(OpPPC64SRADconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v.AddArg(x)
 		return true
 	}
@@ -13930,12 +14028,12 @@ func rewriteValuePPC64_OpRsh64x64(v *Value) bool {
 		v_1_1 := v_1.Args[1]
 		for _i0 := 0; _i0 <= 1; _i0, v_1_0, v_1_1 = _i0+1, v_1_1, v_1_0 {
 			y := v_1_0
-			if v_1_1.Op != OpPPC64MOVDconst || v_1_1.AuxInt != 63 {
+			if v_1_1.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_1.AuxInt) != 63 {
 				continue
 			}
 			v.reset(OpPPC64SRAD)
 			v0 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int64)
-			v0.AuxInt = 63
+			v0.AuxInt = int64ToAuxInt(63)
 			v0.AddArg(y)
 			v.AddArg2(x, v0)
 			return true
@@ -13946,13 +14044,13 @@ func rewriteValuePPC64_OpRsh64x64(v *Value) bool {
 	// result: (SRAD x (ANDconst <typ.UInt> [63] y))
 	for {
 		x := v_0
-		if v_1.Op != OpPPC64ANDconst || v_1.Type != typ.UInt || v_1.AuxInt != 63 {
+		if v_1.Op != OpPPC64ANDconst || v_1.Type != typ.UInt || auxIntToInt64(v_1.AuxInt) != 63 {
 			break
 		}
 		y := v_1.Args[0]
 		v.reset(OpPPC64SRAD)
 		v0 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt)
-		v0.AuxInt = 63
+		v0.AuxInt = int64ToAuxInt(63)
 		v0.AddArg(y)
 		v.AddArg2(x, v0)
 		return true
@@ -13966,20 +14064,20 @@ func rewriteValuePPC64_OpRsh64x64(v *Value) bool {
 		}
 		_ = v_1.Args[1]
 		v_1_0 := v_1.Args[0]
-		if v_1_0.Op != OpPPC64MOVDconst || v_1_0.AuxInt != 64 {
+		if v_1_0.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_0.AuxInt) != 64 {
 			break
 		}
 		v_1_1 := v_1.Args[1]
-		if v_1_1.Op != OpPPC64ANDconst || v_1_1.Type != typ.UInt || v_1_1.AuxInt != 63 {
+		if v_1_1.Op != OpPPC64ANDconst || v_1_1.Type != typ.UInt || auxIntToInt64(v_1_1.AuxInt) != 63 {
 			break
 		}
 		y := v_1_1.Args[0]
 		v.reset(OpPPC64SRAD)
 		v0 := b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = 64
+		v1.AuxInt = int64ToAuxInt(64)
 		v2 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt)
-		v2.AuxInt = 63
+		v2.AuxInt = int64ToAuxInt(63)
 		v2.AddArg(y)
 		v0.AddArg2(v1, v2)
 		v.AddArg2(x, v0)
@@ -13994,7 +14092,7 @@ func rewriteValuePPC64_OpRsh64x64(v *Value) bool {
 		}
 		_ = v_1.Args[1]
 		v_1_0 := v_1.Args[0]
-		if v_1_0.Op != OpPPC64MOVDconst || v_1_0.AuxInt != 64 {
+		if v_1_0.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_0.AuxInt) != 64 {
 			break
 		}
 		v_1_1 := v_1.Args[1]
@@ -14006,15 +14104,15 @@ func rewriteValuePPC64_OpRsh64x64(v *Value) bool {
 		v_1_1_1 := v_1_1.Args[1]
 		for _i0 := 0; _i0 <= 1; _i0, v_1_1_0, v_1_1_1 = _i0+1, v_1_1_1, v_1_1_0 {
 			y := v_1_1_0
-			if v_1_1_1.Op != OpPPC64MOVDconst || v_1_1_1.AuxInt != 63 {
+			if v_1_1_1.Op != OpPPC64MOVDconst || auxIntToInt64(v_1_1_1.AuxInt) != 63 {
 				continue
 			}
 			v.reset(OpPPC64SRAD)
 			v0 := b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt)
 			v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-			v1.AuxInt = 64
+			v1.AuxInt = int64ToAuxInt(64)
 			v2 := b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt)
-			v2.AuxInt = 63
+			v2.AuxInt = int64ToAuxInt(63)
 			v2.AddArg(y)
 			v0.AddArg2(v1, v2)
 			v.AddArg2(x, v0)
@@ -14029,12 +14127,12 @@ func rewriteValuePPC64_OpRsh64x64(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SRAD)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v3.AuxInt = 64
+		v3.AuxInt = int64ToAuxInt(64)
 		v2.AddArg2(y, v3)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -14066,14 +14164,14 @@ func rewriteValuePPC64_OpRsh64x8(v *Value) bool {
 		y := v_1
 		v.reset(OpPPC64SRAD)
 		v0 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v1.AuxInt = -1
+		v1.AuxInt = int64ToAuxInt(-1)
 		v2 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v3 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
 		v3.AddArg(y)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 64
+		v4.AuxInt = int64ToAuxInt(64)
 		v2.AddArg2(v3, v4)
 		v0.AddArg3(y, v1, v2)
 		v.AddArg2(x, v0)
@@ -14109,14 +14207,14 @@ func rewriteValuePPC64_OpRsh8Ux16(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32)
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v1.AuxInt = 0
+		v1.AuxInt = int32ToAuxInt(0)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v3 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v4 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
 		v4.AddArg(y)
 		v5 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v5.AuxInt = 8
+		v5.AuxInt = int64ToAuxInt(8)
 		v3.AddArg2(v4, v5)
 		v1.AddArg3(y, v2, v3)
 		v.AddArg2(v0, v1)
@@ -14136,12 +14234,12 @@ func rewriteValuePPC64_OpRsh8Ux32(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint32(c) < 8) {
 			break
 		}
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -14171,12 +14269,12 @@ func rewriteValuePPC64_OpRsh8Ux32(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32)
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v1.AuxInt = 0
+		v1.AuxInt = int32ToAuxInt(0)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v3 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 8
+		v4.AuxInt = int64ToAuxInt(8)
 		v3.AddArg2(y, v4)
 		v1.AddArg3(y, v2, v3)
 		v.AddArg2(v0, v1)
@@ -14195,12 +14293,12 @@ func rewriteValuePPC64_OpRsh8Ux64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) >= 8) {
 			break
 		}
 		v.reset(OpPPC64MOVDconst)
-		v.AuxInt = 0
+		v.AuxInt = int64ToAuxInt(0)
 		return true
 	}
 	// match: (Rsh8Ux64 x (MOVDconst [c]))
@@ -14211,12 +14309,12 @@ func rewriteValuePPC64_OpRsh8Ux64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) < 8) {
 			break
 		}
 		v.reset(OpPPC64SRWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -14246,12 +14344,12 @@ func rewriteValuePPC64_OpRsh8Ux64(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32)
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v1.AuxInt = 0
+		v1.AuxInt = int32ToAuxInt(0)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v3 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 8
+		v4.AuxInt = int64ToAuxInt(8)
 		v3.AddArg2(y, v4)
 		v1.AddArg3(y, v2, v3)
 		v.AddArg2(v0, v1)
@@ -14287,14 +14385,14 @@ func rewriteValuePPC64_OpRsh8Ux8(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32)
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v1.AuxInt = 0
+		v1.AuxInt = int32ToAuxInt(0)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v3 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v4 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
 		v4.AddArg(y)
 		v5 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v5.AuxInt = 8
+		v5.AuxInt = int64ToAuxInt(8)
 		v3.AddArg2(v4, v5)
 		v1.AddArg3(y, v2, v3)
 		v.AddArg2(v0, v1)
@@ -14330,14 +14428,14 @@ func rewriteValuePPC64_OpRsh8x16(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32)
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v1.AuxInt = 0
+		v1.AuxInt = int32ToAuxInt(0)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v3 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v4 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
 		v4.AddArg(y)
 		v5 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v5.AuxInt = 8
+		v5.AuxInt = int64ToAuxInt(8)
 		v3.AddArg2(v4, v5)
 		v1.AddArg3(y, v2, v3)
 		v.AddArg2(v0, v1)
@@ -14357,12 +14455,12 @@ func rewriteValuePPC64_OpRsh8x32(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint32(c) < 8) {
 			break
 		}
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -14392,12 +14490,12 @@ func rewriteValuePPC64_OpRsh8x32(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32)
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v1.AuxInt = 0
+		v1.AuxInt = int32ToAuxInt(0)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v3 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 8
+		v4.AuxInt = int64ToAuxInt(8)
 		v3.AddArg2(y, v4)
 		v1.AddArg3(y, v2, v3)
 		v.AddArg2(v0, v1)
@@ -14417,12 +14515,12 @@ func rewriteValuePPC64_OpRsh8x64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) >= 8) {
 			break
 		}
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = 63
+		v.AuxInt = int64ToAuxInt(63)
 		v0 := b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -14436,12 +14534,12 @@ func rewriteValuePPC64_OpRsh8x64(v *Value) bool {
 		if v_1.Op != OpPPC64MOVDconst {
 			break
 		}
-		c := v_1.AuxInt
+		c := auxIntToInt64(v_1.AuxInt)
 		if !(uint64(c) < 8) {
 			break
 		}
 		v.reset(OpPPC64SRAWconst)
-		v.AuxInt = c
+		v.AuxInt = int64ToAuxInt(c)
 		v0 := b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -14471,12 +14569,12 @@ func rewriteValuePPC64_OpRsh8x64(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32)
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v1.AuxInt = 0
+		v1.AuxInt = int32ToAuxInt(0)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v3 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v4 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v4.AuxInt = 8
+		v4.AuxInt = int64ToAuxInt(8)
 		v3.AddArg2(y, v4)
 		v1.AddArg3(y, v2, v3)
 		v.AddArg2(v0, v1)
@@ -14512,14 +14610,14 @@ func rewriteValuePPC64_OpRsh8x8(v *Value) bool {
 		v0 := b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32)
 		v0.AddArg(x)
 		v1 := b.NewValue0(v.Pos, OpPPC64ISEL, typ.Int32)
-		v1.AuxInt = 0
+		v1.AuxInt = int32ToAuxInt(0)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v2.AuxInt = -1
+		v2.AuxInt = int64ToAuxInt(-1)
 		v3 := b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags)
 		v4 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
 		v4.AddArg(y)
 		v5 := b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64)
-		v5.AuxInt = 8
+		v5.AuxInt = int64ToAuxInt(8)
 		v3.AddArg2(v4, v5)
 		v1.AddArg3(y, v2, v3)
 		v.AddArg2(v0, v1)
@@ -14535,7 +14633,7 @@ func rewriteValuePPC64_OpSlicemask(v *Value) bool {
 		t := v.Type
 		x := v_0
 		v.reset(OpPPC64SRADconst)
-		v.AuxInt = 63
+		v.AuxInt = int64ToAuxInt(63)
 		v0 := b.NewValue0(v.Pos, OpPPC64NEG, t)
 		v0.AddArg(x)
 		v.AddArg(v0)
@@ -14547,14 +14645,14 @@ func rewriteValuePPC64_OpStore(v *Value) bool {
 	v_1 := v.Args[1]
 	v_0 := v.Args[0]
 	// match: (Store {t} ptr val mem)
-	// cond: t.(*types.Type).Size() == 8 && is64BitFloat(val.Type)
+	// cond: t.Size() == 8 && is64BitFloat(val.Type)
 	// result: (FMOVDstore ptr val mem)
 	for {
-		t := v.Aux
+		t := auxToType(v.Aux)
 		ptr := v_0
 		val := v_1
 		mem := v_2
-		if !(t.(*types.Type).Size() == 8 && is64BitFloat(val.Type)) {
+		if !(t.Size() == 8 && is64BitFloat(val.Type)) {
 			break
 		}
 		v.reset(OpPPC64FMOVDstore)
@@ -14562,14 +14660,14 @@ func rewriteValuePPC64_OpStore(v *Value) bool {
 		return true
 	}
 	// match: (Store {t} ptr val mem)
-	// cond: t.(*types.Type).Size() == 8 && is32BitFloat(val.Type)
+	// cond: t.Size() == 8 && is32BitFloat(val.Type)
 	// result: (FMOVDstore ptr val mem)
 	for {
-		t := v.Aux
+		t := auxToType(v.Aux)
 		ptr := v_0
 		val := v_1
 		mem := v_2
-		if !(t.(*types.Type).Size() == 8 && is32BitFloat(val.Type)) {
+		if !(t.Size() == 8 && is32BitFloat(val.Type)) {
 			break
 		}
 		v.reset(OpPPC64FMOVDstore)
@@ -14577,14 +14675,14 @@ func rewriteValuePPC64_OpStore(v *Value) bool {
 		return true
 	}
 	// match: (Store {t} ptr val mem)
-	// cond: t.(*types.Type).Size() == 4 && is32BitFloat(val.Type)
+	// cond: t.Size() == 4 && is32BitFloat(val.Type)
 	// result: (FMOVSstore ptr val mem)
 	for {
-		t := v.Aux
+		t := auxToType(v.Aux)
 		ptr := v_0
 		val := v_1
 		mem := v_2
-		if !(t.(*types.Type).Size() == 4 && is32BitFloat(val.Type)) {
+		if !(t.Size() == 4 && is32BitFloat(val.Type)) {
 			break
 		}
 		v.reset(OpPPC64FMOVSstore)
@@ -14592,14 +14690,14 @@ func rewriteValuePPC64_OpStore(v *Value) bool {
 		return true
 	}
 	// match: (Store {t} ptr val mem)
-	// cond: t.(*types.Type).Size() == 8 && (is64BitInt(val.Type) || isPtr(val.Type))
+	// cond: t.Size() == 8 && (is64BitInt(val.Type) || isPtr(val.Type))
 	// result: (MOVDstore ptr val mem)
 	for {
-		t := v.Aux
+		t := auxToType(v.Aux)
 		ptr := v_0
 		val := v_1
 		mem := v_2
-		if !(t.(*types.Type).Size() == 8 && (is64BitInt(val.Type) || isPtr(val.Type))) {
+		if !(t.Size() == 8 && (is64BitInt(val.Type) || isPtr(val.Type))) {
 			break
 		}
 		v.reset(OpPPC64MOVDstore)
@@ -14607,14 +14705,14 @@ func rewriteValuePPC64_OpStore(v *Value) bool {
 		return true
 	}
 	// match: (Store {t} ptr val mem)
-	// cond: t.(*types.Type).Size() == 4 && is32BitInt(val.Type)
+	// cond: t.Size() == 4 && is32BitInt(val.Type)
 	// result: (MOVWstore ptr val mem)
 	for {
-		t := v.Aux
+		t := auxToType(v.Aux)
 		ptr := v_0
 		val := v_1
 		mem := v_2
-		if !(t.(*types.Type).Size() == 4 && is32BitInt(val.Type)) {
+		if !(t.Size() == 4 && is32BitInt(val.Type)) {
 			break
 		}
 		v.reset(OpPPC64MOVWstore)
@@ -14622,14 +14720,14 @@ func rewriteValuePPC64_OpStore(v *Value) bool {
 		return true
 	}
 	// match: (Store {t} ptr val mem)
-	// cond: t.(*types.Type).Size() == 2
+	// cond: t.Size() == 2
 	// result: (MOVHstore ptr val mem)
 	for {
-		t := v.Aux
+		t := auxToType(v.Aux)
 		ptr := v_0
 		val := v_1
 		mem := v_2
-		if !(t.(*types.Type).Size() == 2) {
+		if !(t.Size() == 2) {
 			break
 		}
 		v.reset(OpPPC64MOVHstore)
@@ -14637,14 +14735,14 @@ func rewriteValuePPC64_OpStore(v *Value) bool {
 		return true
 	}
 	// match: (Store {t} ptr val mem)
-	// cond: t.(*types.Type).Size() == 1
+	// cond: t.Size() == 1
 	// result: (MOVBstore ptr val mem)
 	for {
-		t := v.Aux
+		t := auxToType(v.Aux)
 		ptr := v_0
 		val := v_1
 		mem := v_2
-		if !(t.(*types.Type).Size() == 1) {
+		if !(t.Size() == 1) {
 			break
 		}
 		v.reset(OpPPC64MOVBstore)
@@ -14804,7 +14902,7 @@ func rewriteValuePPC64_OpZero(v *Value) bool {
 	// match: (Zero [0] _ mem)
 	// result: mem
 	for {
-		if v.AuxInt != 0 {
+		if auxIntToInt64(v.AuxInt) != 0 {
 			break
 		}
 		mem := v_1
@@ -14814,7 +14912,7 @@ func rewriteValuePPC64_OpZero(v *Value) bool {
 	// match: (Zero [1] destptr mem)
 	// result: (MOVBstorezero destptr mem)
 	for {
-		if v.AuxInt != 1 {
+		if auxIntToInt64(v.AuxInt) != 1 {
 			break
 		}
 		destptr := v_0
@@ -14826,7 +14924,7 @@ func rewriteValuePPC64_OpZero(v *Value) bool {
 	// match: (Zero [2] destptr mem)
 	// result: (MOVHstorezero destptr mem)
 	for {
-		if v.AuxInt != 2 {
+		if auxIntToInt64(v.AuxInt) != 2 {
 			break
 		}
 		destptr := v_0
@@ -14838,13 +14936,13 @@ func rewriteValuePPC64_OpZero(v *Value) bool {
 	// match: (Zero [3] destptr mem)
 	// result: (MOVBstorezero [2] destptr (MOVHstorezero destptr mem))
 	for {
-		if v.AuxInt != 3 {
+		if auxIntToInt64(v.AuxInt) != 3 {
 			break
 		}
 		destptr := v_0
 		mem := v_1
 		v.reset(OpPPC64MOVBstorezero)
-		v.AuxInt = 2
+		v.AuxInt = int32ToAuxInt(2)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVHstorezero, types.TypeMem)
 		v0.AddArg2(destptr, mem)
 		v.AddArg2(destptr, v0)
@@ -14853,7 +14951,7 @@ func rewriteValuePPC64_OpZero(v *Value) bool {
 	// match: (Zero [4] destptr mem)
 	// result: (MOVWstorezero destptr mem)
 	for {
-		if v.AuxInt != 4 {
+		if auxIntToInt64(v.AuxInt) != 4 {
 			break
 		}
 		destptr := v_0
@@ -14865,13 +14963,13 @@ func rewriteValuePPC64_OpZero(v *Value) bool {
 	// match: (Zero [5] destptr mem)
 	// result: (MOVBstorezero [4] destptr (MOVWstorezero destptr mem))
 	for {
-		if v.AuxInt != 5 {
+		if auxIntToInt64(v.AuxInt) != 5 {
 			break
 		}
 		destptr := v_0
 		mem := v_1
 		v.reset(OpPPC64MOVBstorezero)
-		v.AuxInt = 4
+		v.AuxInt = int32ToAuxInt(4)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVWstorezero, types.TypeMem)
 		v0.AddArg2(destptr, mem)
 		v.AddArg2(destptr, v0)
@@ -14880,13 +14978,13 @@ func rewriteValuePPC64_OpZero(v *Value) bool {
 	// match: (Zero [6] destptr mem)
 	// result: (MOVHstorezero [4] destptr (MOVWstorezero destptr mem))
 	for {
-		if v.AuxInt != 6 {
+		if auxIntToInt64(v.AuxInt) != 6 {
 			break
 		}
 		destptr := v_0
 		mem := v_1
 		v.reset(OpPPC64MOVHstorezero)
-		v.AuxInt = 4
+		v.AuxInt = int32ToAuxInt(4)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVWstorezero, types.TypeMem)
 		v0.AddArg2(destptr, mem)
 		v.AddArg2(destptr, v0)
@@ -14895,15 +14993,15 @@ func rewriteValuePPC64_OpZero(v *Value) bool {
 	// match: (Zero [7] destptr mem)
 	// result: (MOVBstorezero [6] destptr (MOVHstorezero [4] destptr (MOVWstorezero destptr mem)))
 	for {
-		if v.AuxInt != 7 {
+		if auxIntToInt64(v.AuxInt) != 7 {
 			break
 		}
 		destptr := v_0
 		mem := v_1
 		v.reset(OpPPC64MOVBstorezero)
-		v.AuxInt = 6
+		v.AuxInt = int32ToAuxInt(6)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVHstorezero, types.TypeMem)
-		v0.AuxInt = 4
+		v0.AuxInt = int32ToAuxInt(4)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVWstorezero, types.TypeMem)
 		v1.AddArg2(destptr, mem)
 		v0.AddArg2(destptr, v1)
@@ -14911,16 +15009,16 @@ func rewriteValuePPC64_OpZero(v *Value) bool {
 		return true
 	}
 	// match: (Zero [8] {t} destptr mem)
-	// cond: t.(*types.Type).Alignment()%4 == 0
+	// cond: t.Alignment()%4 == 0
 	// result: (MOVDstorezero destptr mem)
 	for {
-		if v.AuxInt != 8 {
+		if auxIntToInt64(v.AuxInt) != 8 {
 			break
 		}
-		t := v.Aux
+		t := auxToType(v.Aux)
 		destptr := v_0
 		mem := v_1
-		if !(t.(*types.Type).Alignment()%4 == 0) {
+		if !(t.Alignment()%4 == 0) {
 			break
 		}
 		v.reset(OpPPC64MOVDstorezero)
@@ -14930,106 +15028,106 @@ func rewriteValuePPC64_OpZero(v *Value) bool {
 	// match: (Zero [8] destptr mem)
 	// result: (MOVWstorezero [4] destptr (MOVWstorezero [0] destptr mem))
 	for {
-		if v.AuxInt != 8 {
+		if auxIntToInt64(v.AuxInt) != 8 {
 			break
 		}
 		destptr := v_0
 		mem := v_1
 		v.reset(OpPPC64MOVWstorezero)
-		v.AuxInt = 4
+		v.AuxInt = int32ToAuxInt(4)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVWstorezero, types.TypeMem)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v0.AddArg2(destptr, mem)
 		v.AddArg2(destptr, v0)
 		return true
 	}
 	// match: (Zero [12] {t} destptr mem)
-	// cond: t.(*types.Type).Alignment()%4 == 0
+	// cond: t.Alignment()%4 == 0
 	// result: (MOVWstorezero [8] destptr (MOVDstorezero [0] destptr mem))
 	for {
-		if v.AuxInt != 12 {
+		if auxIntToInt64(v.AuxInt) != 12 {
 			break
 		}
-		t := v.Aux
+		t := auxToType(v.Aux)
 		destptr := v_0
 		mem := v_1
-		if !(t.(*types.Type).Alignment()%4 == 0) {
+		if !(t.Alignment()%4 == 0) {
 			break
 		}
 		v.reset(OpPPC64MOVWstorezero)
-		v.AuxInt = 8
+		v.AuxInt = int32ToAuxInt(8)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDstorezero, types.TypeMem)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v0.AddArg2(destptr, mem)
 		v.AddArg2(destptr, v0)
 		return true
 	}
 	// match: (Zero [16] {t} destptr mem)
-	// cond: t.(*types.Type).Alignment()%4 == 0
+	// cond: t.Alignment()%4 == 0
 	// result: (MOVDstorezero [8] destptr (MOVDstorezero [0] destptr mem))
 	for {
-		if v.AuxInt != 16 {
+		if auxIntToInt64(v.AuxInt) != 16 {
 			break
 		}
-		t := v.Aux
+		t := auxToType(v.Aux)
 		destptr := v_0
 		mem := v_1
-		if !(t.(*types.Type).Alignment()%4 == 0) {
+		if !(t.Alignment()%4 == 0) {
 			break
 		}
 		v.reset(OpPPC64MOVDstorezero)
-		v.AuxInt = 8
+		v.AuxInt = int32ToAuxInt(8)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDstorezero, types.TypeMem)
-		v0.AuxInt = 0
+		v0.AuxInt = int32ToAuxInt(0)
 		v0.AddArg2(destptr, mem)
 		v.AddArg2(destptr, v0)
 		return true
 	}
 	// match: (Zero [24] {t} destptr mem)
-	// cond: t.(*types.Type).Alignment()%4 == 0
+	// cond: t.Alignment()%4 == 0
 	// result: (MOVDstorezero [16] destptr (MOVDstorezero [8] destptr (MOVDstorezero [0] destptr mem)))
 	for {
-		if v.AuxInt != 24 {
+		if auxIntToInt64(v.AuxInt) != 24 {
 			break
 		}
-		t := v.Aux
+		t := auxToType(v.Aux)
 		destptr := v_0
 		mem := v_1
-		if !(t.(*types.Type).Alignment()%4 == 0) {
+		if !(t.Alignment()%4 == 0) {
 			break
 		}
 		v.reset(OpPPC64MOVDstorezero)
-		v.AuxInt = 16
+		v.AuxInt = int32ToAuxInt(16)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDstorezero, types.TypeMem)
-		v0.AuxInt = 8
+		v0.AuxInt = int32ToAuxInt(8)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDstorezero, types.TypeMem)
-		v1.AuxInt = 0
+		v1.AuxInt = int32ToAuxInt(0)
 		v1.AddArg2(destptr, mem)
 		v0.AddArg2(destptr, v1)
 		v.AddArg2(destptr, v0)
 		return true
 	}
 	// match: (Zero [32] {t} destptr mem)
-	// cond: t.(*types.Type).Alignment()%4 == 0
+	// cond: t.Alignment()%4 == 0
 	// result: (MOVDstorezero [24] destptr (MOVDstorezero [16] destptr (MOVDstorezero [8] destptr (MOVDstorezero [0] destptr mem))))
 	for {
-		if v.AuxInt != 32 {
+		if auxIntToInt64(v.AuxInt) != 32 {
 			break
 		}
-		t := v.Aux
+		t := auxToType(v.Aux)
 		destptr := v_0
 		mem := v_1
-		if !(t.(*types.Type).Alignment()%4 == 0) {
+		if !(t.Alignment()%4 == 0) {
 			break
 		}
 		v.reset(OpPPC64MOVDstorezero)
-		v.AuxInt = 24
+		v.AuxInt = int32ToAuxInt(24)
 		v0 := b.NewValue0(v.Pos, OpPPC64MOVDstorezero, types.TypeMem)
-		v0.AuxInt = 16
+		v0.AuxInt = int32ToAuxInt(16)
 		v1 := b.NewValue0(v.Pos, OpPPC64MOVDstorezero, types.TypeMem)
-		v1.AuxInt = 8
+		v1.AuxInt = int32ToAuxInt(8)
 		v2 := b.NewValue0(v.Pos, OpPPC64MOVDstorezero, types.TypeMem)
-		v2.AuxInt = 0
+		v2.AuxInt = int32ToAuxInt(0)
 		v2.AddArg2(destptr, mem)
 		v1.AddArg2(destptr, v2)
 		v0.AddArg2(destptr, v1)
@@ -15040,14 +15138,14 @@ func rewriteValuePPC64_OpZero(v *Value) bool {
 	// cond: objabi.GOPPC64 <= 8 && s < 64
 	// result: (LoweredZeroShort [s] ptr mem)
 	for {
-		s := v.AuxInt
+		s := auxIntToInt64(v.AuxInt)
 		ptr := v_0
 		mem := v_1
 		if !(objabi.GOPPC64 <= 8 && s < 64) {
 			break
 		}
 		v.reset(OpPPC64LoweredZeroShort)
-		v.AuxInt = s
+		v.AuxInt = int64ToAuxInt(s)
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -15055,14 +15153,14 @@ func rewriteValuePPC64_OpZero(v *Value) bool {
 	// cond: objabi.GOPPC64 <= 8
 	// result: (LoweredZero [s] ptr mem)
 	for {
-		s := v.AuxInt
+		s := auxIntToInt64(v.AuxInt)
 		ptr := v_0
 		mem := v_1
 		if !(objabi.GOPPC64 <= 8) {
 			break
 		}
 		v.reset(OpPPC64LoweredZero)
-		v.AuxInt = s
+		v.AuxInt = int64ToAuxInt(s)
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -15070,14 +15168,14 @@ func rewriteValuePPC64_OpZero(v *Value) bool {
 	// cond: s < 128 && objabi.GOPPC64 >= 9
 	// result: (LoweredQuadZeroShort [s] ptr mem)
 	for {
-		s := v.AuxInt
+		s := auxIntToInt64(v.AuxInt)
 		ptr := v_0
 		mem := v_1
 		if !(s < 128 && objabi.GOPPC64 >= 9) {
 			break
 		}
 		v.reset(OpPPC64LoweredQuadZeroShort)
-		v.AuxInt = s
+		v.AuxInt = int64ToAuxInt(s)
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -15085,14 +15183,14 @@ func rewriteValuePPC64_OpZero(v *Value) bool {
 	// cond: objabi.GOPPC64 >= 9
 	// result: (LoweredQuadZero [s] ptr mem)
 	for {
-		s := v.AuxInt
+		s := auxIntToInt64(v.AuxInt)
 		ptr := v_0
 		mem := v_1
 		if !(objabi.GOPPC64 >= 9) {
 			break
 		}
 		v.reset(OpPPC64LoweredQuadZero)
-		v.AuxInt = s
+		v.AuxInt = int64ToAuxInt(s)
 		v.AddArg2(ptr, mem)
 		return true
 	}
@@ -15105,17 +15203,17 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (EQ (ANDCCconst [c] x) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
 			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0_0.AuxInt
+			c := auxIntToInt64(v_0_0.AuxInt)
 			x := v_0_0.Args[0]
 			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
-			v0.AuxInt = c
+			v0.AuxInt = int64ToAuxInt(c)
 			v0.AddArg(x)
 			b.resetWithControl(BlockPPC64EQ, v0)
 			return true
@@ -15124,17 +15222,17 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (EQ (ANDCCconst [c] x) yes no)
 		for b.Controls[0].Op == OpPPC64CMPWconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt32(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
 			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0_0.AuxInt
+			c := auxIntToInt64(v_0_0.AuxInt)
 			x := v_0_0.Args[0]
 			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
-			v0.AuxInt = c
+			v0.AuxInt = int64ToAuxInt(c)
 			v0.AddArg(x)
 			b.resetWithControl(BlockPPC64EQ, v0)
 			return true
@@ -15171,17 +15269,17 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (EQ (ANDCCconst [c] x) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
 			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0_0.AuxInt
+			c := auxIntToInt64(v_0_0.AuxInt)
 			x := v_0_0.Args[0]
 			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
-			v0.AuxInt = c
+			v0.AuxInt = int64ToAuxInt(c)
 			v0.AddArg(x)
 			b.resetWithControl(BlockPPC64EQ, v0)
 			return true
@@ -15190,17 +15288,17 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (EQ (ANDCCconst [c] x) yes no)
 		for b.Controls[0].Op == OpPPC64CMPWconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt32(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
 			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0_0.AuxInt
+			c := auxIntToInt64(v_0_0.AuxInt)
 			x := v_0_0.Args[0]
 			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
-			v0.AuxInt = c
+			v0.AuxInt = int64ToAuxInt(c)
 			v0.AddArg(x)
 			b.resetWithControl(BlockPPC64EQ, v0)
 			return true
@@ -15210,7 +15308,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (EQ (ANDCC x y) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			z := v_0.Args[0]
@@ -15238,7 +15336,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (EQ (ORCC x y) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			z := v_0.Args[0]
@@ -15266,7 +15364,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (EQ (XORCC x y) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			z := v_0.Args[0]
@@ -15321,17 +15419,17 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (GE (ANDCCconst [c] x) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
 			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0_0.AuxInt
+			c := auxIntToInt64(v_0_0.AuxInt)
 			x := v_0_0.Args[0]
 			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
-			v0.AuxInt = c
+			v0.AuxInt = int64ToAuxInt(c)
 			v0.AddArg(x)
 			b.resetWithControl(BlockPPC64GE, v0)
 			return true
@@ -15340,17 +15438,17 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (GE (ANDCCconst [c] x) yes no)
 		for b.Controls[0].Op == OpPPC64CMPWconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt32(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
 			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0_0.AuxInt
+			c := auxIntToInt64(v_0_0.AuxInt)
 			x := v_0_0.Args[0]
 			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
-			v0.AuxInt = c
+			v0.AuxInt = int64ToAuxInt(c)
 			v0.AddArg(x)
 			b.resetWithControl(BlockPPC64GE, v0)
 			return true
@@ -15360,7 +15458,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (GE (ANDCC x y) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			z := v_0.Args[0]
@@ -15388,7 +15486,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (GE (ORCC x y) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			z := v_0.Args[0]
@@ -15416,7 +15514,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (GE (XORCC x y) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			z := v_0.Args[0]
@@ -15472,17 +15570,17 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (GT (ANDCCconst [c] x) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
 			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0_0.AuxInt
+			c := auxIntToInt64(v_0_0.AuxInt)
 			x := v_0_0.Args[0]
 			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
-			v0.AuxInt = c
+			v0.AuxInt = int64ToAuxInt(c)
 			v0.AddArg(x)
 			b.resetWithControl(BlockPPC64GT, v0)
 			return true
@@ -15491,17 +15589,17 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (GT (ANDCCconst [c] x) yes no)
 		for b.Controls[0].Op == OpPPC64CMPWconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt32(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
 			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0_0.AuxInt
+			c := auxIntToInt64(v_0_0.AuxInt)
 			x := v_0_0.Args[0]
 			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
-			v0.AuxInt = c
+			v0.AuxInt = int64ToAuxInt(c)
 			v0.AddArg(x)
 			b.resetWithControl(BlockPPC64GT, v0)
 			return true
@@ -15511,7 +15609,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (GT (ANDCC x y) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			z := v_0.Args[0]
@@ -15539,7 +15637,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (GT (ORCC x y) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			z := v_0.Args[0]
@@ -15567,7 +15665,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (GT (XORCC x y) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			z := v_0.Args[0]
@@ -15676,7 +15774,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		for {
 			cond := b.Controls[0]
 			v0 := b.NewValue0(cond.Pos, OpPPC64CMPWconst, types.TypeFlags)
-			v0.AuxInt = 0
+			v0.AuxInt = int32ToAuxInt(0)
 			v0.AddArg(cond)
 			b.resetWithControl(BlockPPC64NE, v0)
 			return true
@@ -15713,17 +15811,17 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (LE (ANDCCconst [c] x) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
 			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0_0.AuxInt
+			c := auxIntToInt64(v_0_0.AuxInt)
 			x := v_0_0.Args[0]
 			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
-			v0.AuxInt = c
+			v0.AuxInt = int64ToAuxInt(c)
 			v0.AddArg(x)
 			b.resetWithControl(BlockPPC64LE, v0)
 			return true
@@ -15732,17 +15830,17 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (LE (ANDCCconst [c] x) yes no)
 		for b.Controls[0].Op == OpPPC64CMPWconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt32(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
 			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0_0.AuxInt
+			c := auxIntToInt64(v_0_0.AuxInt)
 			x := v_0_0.Args[0]
 			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
-			v0.AuxInt = c
+			v0.AuxInt = int64ToAuxInt(c)
 			v0.AddArg(x)
 			b.resetWithControl(BlockPPC64LE, v0)
 			return true
@@ -15752,7 +15850,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (LE (ANDCC x y) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			z := v_0.Args[0]
@@ -15780,7 +15878,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (LE (ORCC x y) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			z := v_0.Args[0]
@@ -15808,7 +15906,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (LE (XORCC x y) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			z := v_0.Args[0]
@@ -15864,17 +15962,17 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (LT (ANDCCconst [c] x) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
 			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0_0.AuxInt
+			c := auxIntToInt64(v_0_0.AuxInt)
 			x := v_0_0.Args[0]
 			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
-			v0.AuxInt = c
+			v0.AuxInt = int64ToAuxInt(c)
 			v0.AddArg(x)
 			b.resetWithControl(BlockPPC64LT, v0)
 			return true
@@ -15883,17 +15981,17 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (LT (ANDCCconst [c] x) yes no)
 		for b.Controls[0].Op == OpPPC64CMPWconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt32(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
 			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0_0.AuxInt
+			c := auxIntToInt64(v_0_0.AuxInt)
 			x := v_0_0.Args[0]
 			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
-			v0.AuxInt = c
+			v0.AuxInt = int64ToAuxInt(c)
 			v0.AddArg(x)
 			b.resetWithControl(BlockPPC64LT, v0)
 			return true
@@ -15903,7 +16001,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (LT (ANDCC x y) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			z := v_0.Args[0]
@@ -15931,7 +16029,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (LT (ORCC x y) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			z := v_0.Args[0]
@@ -15959,7 +16057,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (LT (XORCC x y) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			z := v_0.Args[0]
@@ -15987,7 +16085,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (EQ cc yes no)
 		for b.Controls[0].Op == OpPPC64CMPWconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt32(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
@@ -16002,7 +16100,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (NE cc yes no)
 		for b.Controls[0].Op == OpPPC64CMPWconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt32(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
@@ -16017,7 +16115,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (LT cc yes no)
 		for b.Controls[0].Op == OpPPC64CMPWconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt32(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
@@ -16032,7 +16130,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (LE cc yes no)
 		for b.Controls[0].Op == OpPPC64CMPWconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt32(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
@@ -16047,7 +16145,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (GT cc yes no)
 		for b.Controls[0].Op == OpPPC64CMPWconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt32(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
@@ -16062,7 +16160,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (GE cc yes no)
 		for b.Controls[0].Op == OpPPC64CMPWconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt32(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
@@ -16077,7 +16175,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (FLT cc yes no)
 		for b.Controls[0].Op == OpPPC64CMPWconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt32(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
@@ -16092,7 +16190,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (FLE cc yes no)
 		for b.Controls[0].Op == OpPPC64CMPWconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt32(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
@@ -16107,7 +16205,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (FGT cc yes no)
 		for b.Controls[0].Op == OpPPC64CMPWconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt32(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
@@ -16122,7 +16220,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (FGE cc yes no)
 		for b.Controls[0].Op == OpPPC64CMPWconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt32(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
@@ -16137,17 +16235,17 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (NE (ANDCCconst [c] x) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
 			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0_0.AuxInt
+			c := auxIntToInt64(v_0_0.AuxInt)
 			x := v_0_0.Args[0]
 			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
-			v0.AuxInt = c
+			v0.AuxInt = int64ToAuxInt(c)
 			v0.AddArg(x)
 			b.resetWithControl(BlockPPC64NE, v0)
 			return true
@@ -16156,17 +16254,17 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (NE (ANDCCconst [c] x) yes no)
 		for b.Controls[0].Op == OpPPC64CMPWconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt32(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
 			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0_0.AuxInt
+			c := auxIntToInt64(v_0_0.AuxInt)
 			x := v_0_0.Args[0]
 			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
-			v0.AuxInt = c
+			v0.AuxInt = int64ToAuxInt(c)
 			v0.AddArg(x)
 			b.resetWithControl(BlockPPC64NE, v0)
 			return true
@@ -16202,17 +16300,17 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (NE (ANDCCconst [c] x) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
 			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0_0.AuxInt
+			c := auxIntToInt64(v_0_0.AuxInt)
 			x := v_0_0.Args[0]
 			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
-			v0.AuxInt = c
+			v0.AuxInt = int64ToAuxInt(c)
 			v0.AddArg(x)
 			b.resetWithControl(BlockPPC64NE, v0)
 			return true
@@ -16221,17 +16319,17 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (NE (ANDCCconst [c] x) yes no)
 		for b.Controls[0].Op == OpPPC64CMPWconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt32(v_0.AuxInt) != 0 {
 				break
 			}
 			v_0_0 := v_0.Args[0]
 			if v_0_0.Op != OpPPC64ANDconst {
 				break
 			}
-			c := v_0_0.AuxInt
+			c := auxIntToInt64(v_0_0.AuxInt)
 			x := v_0_0.Args[0]
 			v0 := b.NewValue0(v_0.Pos, OpPPC64ANDCCconst, types.TypeFlags)
-			v0.AuxInt = c
+			v0.AuxInt = int64ToAuxInt(c)
 			v0.AddArg(x)
 			b.resetWithControl(BlockPPC64NE, v0)
 			return true
@@ -16241,7 +16339,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (NE (ANDCC x y) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			z := v_0.Args[0]
@@ -16269,7 +16367,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (NE (ORCC x y) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			z := v_0.Args[0]
@@ -16297,7 +16395,7 @@ func rewriteBlockPPC64(b *Block) bool {
 		// result: (NE (XORCC x y) yes no)
 		for b.Controls[0].Op == OpPPC64CMPconst {
 			v_0 := b.Controls[0]
-			if v_0.AuxInt != 0 {
+			if auxIntToInt64(v_0.AuxInt) != 0 {
 				break
 			}
 			z := v_0.Args[0]
