commit 6201a963f1ea19e1473dc13f4d5f397a9eac543a
Author: Russ Cox <rsc@golang.org>
Date:   Fri Sep 26 14:11:26 2008 -0700

    move src/syscall to src/lib/syscall.
    enforce rule: all kernel data structures and constants
            go in syscall module.
    move things that should be in syscall out of net.
    make net a single package.
    
    R=r
    OCL=15985
    CL=15994
---
 src/clean.bash                                     |   2 +-
 src/lib/clean.bash                                 |   2 +-
 src/lib/make.bash                                  |   2 +-
 src/lib/net/Makefile                               |  65 +--
 src/lib/net/cvt.s                                  |  38 --
 src/lib/net/fd_darwin.go                           |  79 ++++
 src/lib/net/fd_linux.go                            |  79 ++++
 src/lib/net/ip.go                                  |   2 +-
 src/lib/net/net.go                                 | 171 +++----
 src/lib/net/net_darwin.go                          |  70 +++
 src/lib/net/net_linux.go                           |  70 +++
 src/lib/syscall/Makefile                           |  58 +++
 .../syscall/asm_amd64_darwin.s}                    |  15 +-
 .../syscall/asm_amd64_linux.s}                     |  21 -
 src/lib/syscall/cast_amd64.s                       |  70 +++
 src/{ => lib}/syscall/errstr_darwin.go             |   0
 src/{ => lib}/syscall/errstr_linux.go              |   0
 src/lib/syscall/file_darwin.go                     |  88 ++++
 src/lib/syscall/file_linux.go                      |  84 ++++
 src/lib/syscall/mkdarwin                           |  34 ++
 src/lib/syscall/mklinux                            |  28 ++
 src/lib/syscall/socket_darwin.go                   | 109 +++++
 src/lib/syscall/socket_linux.go                    |  99 +++++
 src/{ => lib}/syscall/syscall.go                   |   3 +
 src/lib/syscall/syscall_amd64_darwin.go            | 489 +++++++++++++++++++++
 src/lib/syscall/syscall_amd64_linux.go             | 297 +++++++++++++
 src/{ => lib}/syscall/time_amd64_darwin.go         |   3 +-
 src/{ => lib}/syscall/time_amd64_linux.go          |  13 +-
 src/lib/syscall/types_amd64_darwin.go              | 191 ++++++++
 src/lib/syscall/types_amd64_linux.go               | 149 +++++++
 src/make.bash                                      |   2 +-
 src/syscall/Makefile                               |  54 ---
 src/syscall/file_amd64_darwin.go                   | 149 -------
 src/syscall/file_amd64_linux.go                    | 151 -------
 34 files changed, 2140 insertions(+), 547 deletions(-)

diff --git a/src/clean.bash b/src/clean.bash
index 36b0c99fb5..b381c1137f 100755
--- a/src/clean.bash
+++ b/src/clean.bash
@@ -3,7 +3,7 @@
 # Use of this source code is governed by a BSD-style
 # license that can be found in the LICENSE file.
 
-for i in lib9 libbio libmach_amd64 libregexp syscall cmd runtime lib
+for i in lib9 libbio libmach_amd64 libregexp cmd runtime lib
 do
 	cd $i
 	case $i in
diff --git a/src/lib/clean.bash b/src/lib/clean.bash
index 3ae43f4a20..93bb64a15a 100755
--- a/src/lib/clean.bash
+++ b/src/lib/clean.bash
@@ -6,7 +6,7 @@
 
 rm -f $GOROOT/pkg/*
 
-for i in os math net time
+for i in syscall os math net time
 do
 	cd $i
 	make nuke
diff --git a/src/lib/make.bash b/src/lib/make.bash
index 24f8c0e62d..c2037e0dc6 100755
--- a/src/lib/make.bash
+++ b/src/lib/make.bash
@@ -6,7 +6,7 @@
 
 set -e
 
-for i in os math
+for i in syscall os math
 do
 	echo; echo; echo %%%% making lib/$i %%%%; echo
 	cd $i
diff --git a/src/lib/net/Makefile b/src/lib/net/Makefile
index 4788e84e12..553a95d49d 100644
--- a/src/lib/net/Makefile
+++ b/src/lib/net/Makefile
@@ -2,46 +2,57 @@
 # Use of this source code is governed by a BSD-style
 # license that can be found in the LICENSE file.
 
+# DO NOT EDIT.  Automatically generated by gobuild.
+# gobuild -m net net.go fd_darwin.go ip.go cast_amd64.s net_darwin.go
 O=6
 GC=$(O)g
+CC=$(O)c -w
 AS=$(O)a
+AR=$(O)ar
 
-NET=$(GOROOT)/pkg/net.a
-SOCKET=$(GOROOT)/pkg/socket.a
-IP=$(GOROOT)/pkg/ip.$O
+PKG=$(GOROOT)/pkg/net.a
 
-NETO=\
-	net.$O\
+install: $(PKG)
 
-SOCKETO=\
-	cvt.$O\
-	socket_$(GOOS).$O\
+nuke: clean
+	rm -f $(PKG)
 
-$(NET): $(NETO)
-	$(O)ar grc $(NET) $(NETO)
+clean:
+	rm -f *.$O *.a
 
-$(NETO): $(IP) $(SOCKET)
+%.$O: %.go
+	$(GC) $*.go
 
-$(SOCKETO): $(IP)
+%.$O: %.c
+	$(CC) $*.c
 
-$(SOCKET): $(SOCKETO)
-	$(O)ar grc $(SOCKET) $(SOCKETO)
-	rm $(SOCKETO)
+%.$O: %.s
+	$(AS) $*.s
 
-$(GOROOT)/pkg/%.$O: %.$O
-	cp $*.$O $(GOROOT)/pkg/$*.$O
-	rm $*.$O
 
-install: nuke $(IP) $(SOCKET) $(NET)
+O1=\
+	ip.$O\
+	cast_$(GOARCH).$O\
 
-nuke:
-	rm -f *.$O *.a $(IP) $(NET)
+O2=\
+	fd_$(GOOS).$O\
+	net_$(GOOS).$O\
 
-clean:
-	rm -f *.$O *.a
+O3=\
+	net.$O\
 
-%.$O:	%.go
-	$(GC) $<
+$(PKG): a1 a2 a3
+a1:	$(O1)
+	$(AR) grc $(PKG) $(O1)
+	rm -f $(O1)
+a2:	$(O2)
+	$(AR) grc $(PKG) $(O2)
+	rm -f $(O2)
+a3:	$(O3)
+	$(AR) grc $(PKG) $(O3)
+	rm -f $(O3)
+
+$(O1): nuke
+$(O2): a1
+$(O3): a2
 
-%.$O:	%.s
-	$(AS) $<
diff --git a/src/lib/net/cvt.s b/src/lib/net/cvt.s
deleted file mode 100644
index 920f52351e..0000000000
--- a/src/lib/net/cvt.s
+++ /dev/null
@@ -1,38 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Type-unsafe casts.
-
-TEXT socket·SockaddrPtr(SB),7,$0
-	MOVQ	8(SP), AX
-	MOVQ	AX, 16(SP)
-	RET
-TEXT socket·Int32Ptr(SB),7,$0
-	MOVQ	8(SP), AX
-	MOVQ	AX, 16(SP)
-	RET
-TEXT socket·LingerPtr(SB),7,$0
-	MOVQ	8(SP), AX
-	MOVQ	AX, 16(SP)
-	RET
-TEXT	socket·TimevalPtr(SB),7,$0
-	MOVQ	8(SP), AX
-	MOVQ	AX, 16(SP)
-	RET
-TEXT socket·SockaddrInet4ToSockaddr(SB),7,$0
-	MOVQ	8(SP), AX
-	MOVQ	AX, 16(SP)
-	RET
-TEXT socket·SockaddrToSockaddrInet4(SB),7,$0
-	MOVQ	8(SP), AX
-	MOVQ	AX, 16(SP)
-	RET
-TEXT socket·SockaddrInet6ToSockaddr(SB),7,$0
-	MOVQ	8(SP), AX
-	MOVQ	AX, 16(SP)
-	RET
-TEXT socket·SockaddrToSockaddrInet6(SB),7,$0
-	MOVQ	8(SP), AX
-	MOVQ	AX, 16(SP)
-	RET
diff --git a/src/lib/net/fd_darwin.go b/src/lib/net/fd_darwin.go
new file mode 100644
index 0000000000..28b24d9ba3
--- /dev/null
+++ b/src/lib/net/fd_darwin.go
@@ -0,0 +1,79 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Network file descriptors.
+
+package net
+
+import (
+	"os";
+	"syscall";
+	"net"
+)
+
+/* BUG 6g has trouble with this.
+
+export type FD os.FD;
+
+export func NewFD(fd int64) (nfd *FD, err *os.Error) {
+	ofd := os.NewFD(fd)
+	return ofd, nil
+}
+
+func (fd *FD) Close() *os.Error {
+	var ofd *os.FD = fd
+	return ofd.Close()
+}
+
+func (fd *FD) Read(p *[]byte) (n int, err *os.Error) {
+	var ofd *os.FD = fd;
+	n, err = ofd.Read(p)
+	return n, err
+}
+
+func (fd *FD) Write(p *[]byte) (n int, err *os.Error) {
+	var ofd *os.FD = fd;
+	n, err = ofd.Write(p)
+	return n, err
+}
+
+*/
+
+// TODO: Replace with kqueue/kevent.
+
+export type FD struct {
+	fd int64;
+	osfd *os.FD;
+}
+
+export func NewFD(fd int64) (nfd *FD, err *os.Error) {
+	nfd = new(FD);
+	nfd.osfd = os.NewFD(fd);
+	nfd.fd = fd
+	return nfd, nil
+}
+
+func (fd *FD) Close() *os.Error {
+	return fd.osfd.Close()
+}
+
+func (fd *FD) Read(p *[]byte) (n int, err *os.Error) {
+	n, err = fd.osfd.Read(p)
+	return n, err
+}
+
+func (fd *FD) Write(p *[]byte) (n int, err *os.Error) {
+	n, err = fd.osfd.Write(p)
+	return n, err
+}
+
+func (fd *FD) Accept(sa *syscall.Sockaddr) (nfd *FD, err *os.Error) {
+	s, e := syscall.accept(fd.fd, sa);
+	if e != 0 {
+		return nil, os.ErrnoToError(e)
+	}
+	nfd, err = NewFD(s)
+	return nfd, err
+}
+
diff --git a/src/lib/net/fd_linux.go b/src/lib/net/fd_linux.go
new file mode 100644
index 0000000000..dc7ba2db14
--- /dev/null
+++ b/src/lib/net/fd_linux.go
@@ -0,0 +1,79 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Network file descriptors.
+
+package net
+
+import (
+	"os";
+	"syscall";
+	"net"
+)
+
+/* BUG 6g has trouble with this.
+
+export type FD os.FD;
+
+export func NewFD(fd int64) (nfd *FD, err *os.Error) {
+	ofd := os.NewFD(fd)
+	return ofd, nil
+}
+
+func (fd *FD) Close() *os.Error {
+	var ofd *os.FD = fd
+	return ofd.Close()
+}
+
+func (fd *FD) Read(p *[]byte) (n int, err *os.Error) {
+	var ofd *os.FD = fd;
+	n, err = ofd.Read(p)
+	return n, err
+}
+
+func (fd *FD) Write(p *[]byte) (n int, err *os.Error) {
+	var ofd *os.FD = fd;
+	n, err = ofd.Write(p)
+	return n, err
+}
+
+*/
+
+// TODO: Replace with epoll.
+
+export type FD struct {
+	fd int64;
+	osfd *os.FD;
+}
+
+export func NewFD(fd int64) (nfd *FD, err *os.Error) {
+	nfd = new(FD);
+	nfd.osfd = os.NewFD(fd);
+	nfd.fd = fd
+	return nfd, nil
+}
+
+func (fd *FD) Close() *os.Error {
+	return fd.osfd.Close()
+}
+
+func (fd *FD) Read(p *[]byte) (n int, err *os.Error) {
+	n, err = fd.osfd.Read(p)
+	return n, err
+}
+
+func (fd *FD) Write(p *[]byte) (n int, err *os.Error) {
+	n, err = fd.osfd.Write(p)
+	return n, err
+}
+
+func (fd *FD) Accept(sa *syscall.Sockaddr) (nfd *FD, err *os.Error) {
+	s, e := syscall.accept(fd.fd, sa);
+	if e != 0 {
+		return nil, os.ErrnoToError(e)
+	}
+	nfd, err = NewFD(s)
+	return nfd, err
+}
+
diff --git a/src/lib/net/ip.go b/src/lib/net/ip.go
index a96ae6709b..8c53d6f189 100644
--- a/src/lib/net/ip.go
+++ b/src/lib/net/ip.go
@@ -10,7 +10,7 @@
 // This library accepts either size of byte array but always
 // returns 16-byte addresses.
 
-package ip
+package net
 
 export const (
 	IPv4len = 4;
diff --git a/src/lib/net/net.go b/src/lib/net/net.go
index 55fc98a8d0..5ffa83c517 100644
--- a/src/lib/net/net.go
+++ b/src/lib/net/net.go
@@ -6,8 +6,7 @@ package net
 
 import (
 	"os";
-	"ip";
-	"socket";
+	"net";
 	"strings";
 	"syscall"
 )
@@ -64,7 +63,7 @@ func JoinHostPort(host, port string) string {
 	return host + ":" + port
 }
 
-func dtoi(s string) (n int, ok bool) {
+func xdtoi(s string) (n int, ok bool) {
 	if s == "" || s[0] < '0' || s[0] > '9' {
 		return 0, false
 	}
@@ -81,7 +80,7 @@ func dtoi(s string) (n int, ok bool) {
 // Convert "host:port" into IP address and port.
 // For now, host and port must be numeric literals.
 // Eventually, we'll have name resolution.
-func HostPortToIP(net string, hostport string) (ipaddr *[]byte, iport int, err *os.Error) {
+func HostPortToIP(net string, hostport string) (ip *[]byte, iport int, err *os.Error) {
 	var host, port string;
 	host, port, err = SplitHostPort(hostport);
 	if err != nil {
@@ -90,14 +89,14 @@ func HostPortToIP(net string, hostport string) (ipaddr *[]byte, iport int, err *
 
 	// TODO: Resolve host.
 
-	addr := ip.ParseIP(host);
+	addr := ParseIP(host);
 	if addr == nil {
 		return nil, 0, UnknownHost
 	}
 
 	// TODO: Resolve port.
 
-	p, ok := dtoi(port);
+	p, ok := xdtoi(port);
 	if !ok || p < 0 || p > 0xFFFF {
 		return nil, 0, UnknownPort
 	}
@@ -106,14 +105,14 @@ func HostPortToIP(net string, hostport string) (ipaddr *[]byte, iport int, err *
 }
 
 // Convert socket address into "host:port".
-func SockaddrToHostPort(sa *socket.Sockaddr) (hostport string, err *os.Error) {
+func SockaddrToHostPort(sa *syscall.Sockaddr) (hostport string, err *os.Error) {
 	switch sa.family {
-	case socket.AF_INET, socket.AF_INET6:
-		addr, port, e := socket.SockaddrToIP(sa)
+	case syscall.AF_INET, syscall.AF_INET6:
+		addr, port, e := SockaddrToIP(sa)
 		if e != nil {
 			return "", e
 		}
-		host := ip.IPToString(addr);
+		host := IPToString(addr);
 		return JoinHostPort(host, strings.itoa(port)), nil
 	default:
 		return "", UnknownSocketFamily
@@ -130,45 +129,48 @@ func boolint(b bool) int {
 }
 
 // Generic Socket creation.
-func Socket(f, p, t int64, la, ra *socket.Sockaddr) (fd int64, err *os.Error) {
-	s, e := socket.socket(f, p, t);
-	if e != nil {
-		return -1, e
+func Socket(f, p, t int64, la, ra *syscall.Sockaddr) (fd *FD, err *os.Error) {
+	s, e := syscall.socket(f, p, t);
+	if e != 0 {
+		return nil, os.ErrnoToError(e)
 	}
 
 	// Allow reuse of recently-used addresses.
-	socket.setsockopt_int(s, socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+	syscall.setsockopt_int(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)
 
 	var r int64
 	if la != nil {
-		r, e = socket.bind(s, la)
-		if e != nil {
+		r, e = syscall.bind(s, la)
+		if e != 0 {
 			syscall.close(s)
-			return -1, e
+			return nil, os.ErrnoToError(e)
 		}
 	}
 
 	if ra != nil {
-		r, e = socket.connect(s, ra)
-		if e != nil {
+		r, e = syscall.connect(s, ra)
+		if e != 0 {
 			syscall.close(s)
-			return -1, e
+			return nil, os.ErrnoToError(e)
 		}
 	}
 
-	return s, nil
+	fd, err = NewFD(s)
+	if err != nil {
+		syscall.close(s)
+		return nil, err
+	}
+
+	return fd, nil
 }
 
 
 // Generic implementation of Conn interface; not exported.
-
 type ConnBase struct {
-	fd *os.FD;
+	fd *FD;
 	raddr string;
 }
 
-// Eventually, these will use epoll or some such.
-
 func (c *ConnBase) FD() int64 {
 	if c == nil || c.fd == nil {
 		return -1
@@ -212,20 +214,29 @@ func (c *ConnBase) Close() *os.Error {
 	return c.fd.Close()
 }
 
+
+func setsockopt_int(fd, level, opt int64, value int) *os.Error {
+	return os.ErrnoToError(syscall.setsockopt_int(fd, level, opt, value));
+}
+
+func setsockopt_tv(fd, level, opt int64, nsec int64) *os.Error {
+	return os.ErrnoToError(syscall.setsockopt_tv(fd, level, opt, nsec));
+}
+
 func (c *ConnBase) SetReadBuffer(bytes int) *os.Error {
-	return socket.setsockopt_int(c.FD(), socket.SOL_SOCKET, socket.SO_RCVBUF, bytes);
+	return setsockopt_int(c.FD(), syscall.SOL_SOCKET, syscall.SO_RCVBUF, bytes);
 }
 
 func (c *ConnBase) SetWriteBuffer(bytes int) *os.Error {
-	return socket.setsockopt_int(c.FD(), socket.SOL_SOCKET, socket.SO_SNDBUF, bytes);
+	return setsockopt_int(c.FD(), syscall.SOL_SOCKET, syscall.SO_SNDBUF, bytes);
 }
 
 func (c *ConnBase) SetReadTimeout(nsec int64) *os.Error {
-	return socket.setsockopt_tv(c.FD(), socket.SOL_SOCKET, socket.SO_RCVTIMEO, nsec);
+	return setsockopt_tv(c.FD(), syscall.SOL_SOCKET, syscall.SO_RCVTIMEO, nsec);
 }
 
 func (c *ConnBase) SetWriteTimeout(nsec int64) *os.Error {
-	return socket.setsockopt_tv(c.FD(), socket.SOL_SOCKET, socket.SO_SNDTIMEO, nsec);
+	return setsockopt_tv(c.FD(), syscall.SOL_SOCKET, syscall.SO_SNDTIMEO, nsec);
 }
 
 func (c *ConnBase) SetTimeout(nsec int64) *os.Error {
@@ -236,7 +247,7 @@ func (c *ConnBase) SetTimeout(nsec int64) *os.Error {
 }
 
 func (c *ConnBase) SetReuseAddr(reuse bool) *os.Error {
-	return socket.setsockopt_int(c.FD(), socket.SOL_SOCKET, socket.SO_REUSEADDR, boolint(reuse));
+	return setsockopt_int(c.FD(), syscall.SOL_SOCKET, syscall.SO_REUSEADDR, boolint(reuse));
 }
 
 func (c *ConnBase) BindToDevice(dev string) *os.Error {
@@ -245,15 +256,16 @@ func (c *ConnBase) BindToDevice(dev string) *os.Error {
 }
 
 func (c *ConnBase) SetDontRoute(dontroute bool) *os.Error {
-	return socket.setsockopt_int(c.FD(), socket.SOL_SOCKET, socket.SO_DONTROUTE, boolint(dontroute));
+	return setsockopt_int(c.FD(), syscall.SOL_SOCKET, syscall.SO_DONTROUTE, boolint(dontroute));
 }
 
 func (c *ConnBase) SetKeepAlive(keepalive bool) *os.Error {
-	return socket.setsockopt_int(c.FD(), socket.SOL_SOCKET, socket.SO_KEEPALIVE, boolint(keepalive));
+	return setsockopt_int(c.FD(), syscall.SOL_SOCKET, syscall.SO_KEEPALIVE, boolint(keepalive));
 }
 
 func (c *ConnBase) SetLinger(sec int) *os.Error {
-	return socket.setsockopt_linger(c.FD(), socket.SOL_SOCKET, socket.SO_LINGER, sec);
+	e := syscall.setsockopt_linger(c.FD(), syscall.SOL_SOCKET, syscall.SO_LINGER, sec)
+	return os.ErrnoToError(e);
 }
 
 
@@ -267,7 +279,7 @@ func (c *ConnBase) SetLinger(sec int) *os.Error {
 // PreferIPv4 here should fall back to the IPv4 socket interface when possible.
 const PreferIPv4 = false
 
-func InternetSocket(net, laddr, raddr string, proto int64) (fd int64, err *os.Error) {
+func InternetSocket(netw, laddr, raddr string, proto int64) (fd *FD, err *os.Error) {
 	// Parse addresses (unless they are empty).
 	var lip, rip *[]byte
 	var lport, rport int
@@ -280,22 +292,22 @@ rport = 0;
 lerr = nil;
 rerr = nil
 	if laddr != "" {
-		lip, lport, lerr = HostPortToIP(net, laddr)
+		lip, lport, lerr = HostPortToIP(netw, laddr)
 		if lerr != nil {
-			return -1, lerr
+			return nil, lerr
 		}
 	}
 	if raddr != "" {
-		rip, rport, rerr = HostPortToIP(net, raddr)
+		rip, rport, rerr = HostPortToIP(netw, raddr)
 		if rerr != nil {
-			return -1, rerr
+			return nil, rerr
 		}
 	}
 
 	// Figure out IP version.
 	// If network has a suffix like "tcp4", obey it.
 	vers := 0;
-	switch net[len(net)-1] {
+	switch netw[len(netw)-1] {
 	case '4':
 		vers = 4
 	case '6':
@@ -304,38 +316,38 @@ rerr = nil
 		// Otherwise, guess.
 		// If the addresses are IPv4 and we prefer IPv4, use 4; else 6.
 		if PreferIPv4
-		&& (lip == nil || ip.ToIPv4(lip) != nil)
-		&& (rip == nil || ip.ToIPv4(rip) != nil) {
+		&& (lip == nil || ToIPv4(lip) != nil)
+		&& (rip == nil || ToIPv4(rip) != nil) {
 			vers = 4
 		} else {
 			vers = 6
 		}
 	}
 
-	var cvt *(addr *[]byte, port int) (sa *socket.Sockaddr, err *os.Error)
+	var cvt *(addr *[]byte, port int) (sa *syscall.Sockaddr, err *os.Error)
 	var family int64
 	if vers == 4 {
-		cvt = &socket.IPv4ToSockaddr;
-		family = socket.AF_INET
+		cvt = &IPv4ToSockaddr;
+		family = syscall.AF_INET
 	} else {
-		cvt = &socket.IPv6ToSockaddr;
-		family = socket.AF_INET6
+		cvt = &IPv6ToSockaddr;
+		family = syscall.AF_INET6
 	}
 
-	var la, ra *socket.Sockaddr;
+	var la, ra *syscall.Sockaddr;
 // BUG
 la = nil;
 ra = nil
 	if lip != nil {
 		la, lerr = cvt(lip, lport);
 		if lerr != nil {
-			return -1, lerr
+			return nil, lerr
 		}
 	}
 	if rip != nil {
 		ra, rerr = cvt(rip, rport);
 		if rerr != nil {
-			return -1, rerr
+			return nil, rerr
 		}
 	}
 
@@ -355,7 +367,7 @@ func (c *ConnTCP) SetNoDelay(nodelay bool) *os.Error {
 	if c == nil {
 		return os.EINVAL
 	}
-	return socket.setsockopt_int(c.base.fd.fd, socket.IPPROTO_TCP, socket.TCP_NODELAY, boolint(nodelay))
+	return setsockopt_int((&c.base).FD(), syscall.IPPROTO_TCP, syscall.TCP_NODELAY, boolint(nodelay))
 }
 
 // Wrappers
@@ -409,19 +421,19 @@ func (c *ConnTCP) SetKeepAlive(keepalive bool) *os.Error {
 	return (&c.base).SetKeepAlive(keepalive)
 }
 
-func NewConnTCP(fd int64, raddr string) *ConnTCP {
+func NewConnTCP(fd *FD, raddr string) *ConnTCP {
 	c := new(ConnTCP);
-	c.base.fd = os.NewFD(fd);
+	c.base.fd = fd;
 	c.base.raddr = raddr;
 	c.SetNoDelay(true);
 	return c
 }
 
-export func DialTCP(net, laddr, raddr string) (c *ConnTCP, err *os.Error) {
+export func DialTCP(netw, laddr, raddr string) (c *ConnTCP, err *os.Error) {
 	if raddr == "" {
 		return nil, MissingAddress
 	}
-	fd, e := InternetSocket(net, laddr, raddr, socket.SOCK_STREAM)
+	fd, e := InternetSocket(netw, laddr, raddr, syscall.SOCK_STREAM)
 	if e != nil {
 		return nil, e
 	}
@@ -484,26 +496,26 @@ var noconn NoConn
 // Eventually, we plan to allow names in addition to IP addresses,
 // but that requires writing a DNS library.
 
-export func Dial(net, laddr, raddr string) (c Conn, err *os.Error) {
-	switch net {
+export func Dial(netw, laddr, raddr string) (c Conn, err *os.Error) {
+	switch netw {
 	case "tcp", "tcp4", "tcp6":
-		c, err := DialTCP(net, laddr, raddr)
+		c, err := DialTCP(netw, laddr, raddr)
 		if err != nil {
 			return &noconn, err
 		}
 		return c, nil
 /*
 	case "udp", "udp4", "upd6":
-		c, err := DialUDP(net, laddr, raddr)
+		c, err := DialUDP(netw, laddr, raddr)
 		return c, err
 	case "ether":
-		c, err := DialEther(net, laddr, raddr)
+		c, err := DialEther(netw, laddr, raddr)
 		return c, err
 	case "ipv4":
-		c, err := DialIPv4(net, laddr, raddr)
+		c, err := DialIPv4(netw, laddr, raddr)
 		return c, err
 	case "ipv6":
-		c, err := DialIPv6(net, laddr, raddr)
+		c, err := DialIPv6(netw, laddr, raddr)
 		return c, err
 */
 	}
@@ -525,22 +537,22 @@ func (l *NoListener) Close() *os.Error { return os.EINVAL }
 var nolistener NoListener
 
 export type ListenerTCP struct {
-	fd *os.FD;
+	fd *FD;
 	laddr string
 }
 
-export func ListenTCP(net, laddr string) (l *ListenerTCP, err *os.Error) {
-	fd, e := InternetSocket(net, laddr, "", socket.SOCK_STREAM)
+export func ListenTCP(netw, laddr string) (l *ListenerTCP, err *os.Error) {
+	fd, e := InternetSocket(netw, laddr, "", syscall.SOCK_STREAM)
 	if e != nil {
 		return nil, e
 	}
-	r, e1 := socket.listen(fd, socket.ListenBacklog())
-	if e1 != nil {
-		syscall.close(fd)
-		return nil, e1
+	r, e1 := syscall.listen(fd.fd, ListenBacklog())
+	if e1 != 0 {
+		syscall.close(fd.fd)
+		return nil, os.ErrnoToError(e1)
 	}
 	l = new(ListenerTCP);
-	l.fd = os.NewFD(fd);
+	l.fd = fd
 	return l, nil
 }
 
@@ -548,15 +560,15 @@ func (l *ListenerTCP) AcceptTCP() (c *ConnTCP, raddr string, err *os.Error) {
 	if l == nil || l.fd == nil || l.fd.fd < 0 {
 		return nil, "", os.EINVAL
 	}
-	var sa socket.Sockaddr;
-	fd, e := socket.accept(l.fd.fd, &sa)
+	var sa syscall.Sockaddr;
+	fd, e := l.fd.Accept(&sa)
 	if e != nil {
 		return nil, "", e
 	}
-	raddr, e = SockaddrToHostPort(&sa)
-	if e != nil {
-		syscall.close(fd)
-		return nil, "", e
+	raddr, err = SockaddrToHostPort(&sa)
+	if err != nil {
+		fd.Close()
+		return nil, "", err
 	}
 	return NewConnTCP(fd, raddr), raddr, nil
 }
@@ -576,10 +588,10 @@ func (l *ListenerTCP) Close() *os.Error {
 	return l.fd.Close()
 }
 
-export func Listen(net, laddr string) (l Listener, err *os.Error) {
-	switch net {
+export func Listen(netw, laddr string) (l Listener, err *os.Error) {
+	switch netw {
 	case "tcp", "tcp4", "tcp6":
-		l, err := ListenTCP(net, laddr)
+		l, err := ListenTCP(netw, laddr)
 		if err != nil {
 			return &nolistener, err
 		}
@@ -590,3 +602,4 @@ export func Listen(net, laddr string) (l Listener, err *os.Error) {
 	}
 	return nil, UnknownNetwork
 }
+
diff --git a/src/lib/net/net_darwin.go b/src/lib/net/net_darwin.go
new file mode 100644
index 0000000000..3accbe13bb
--- /dev/null
+++ b/src/lib/net/net_darwin.go
@@ -0,0 +1,70 @@
+// Copyright 2009 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package net
+
+import (
+	"os";
+	"syscall";
+	"net"
+)
+
+export func IPv4ToSockaddr(p *[]byte, port int) (sa1 *syscall.Sockaddr, err *os.Error) {
+	p = ToIPv4(p)
+	if p == nil || port < 0 || port > 0xFFFF {
+		return nil, os.EINVAL
+	}
+	sa := new(syscall.SockaddrInet4);
+	sa.len = syscall.SizeofSockaddrInet4;
+	sa.family = syscall.AF_INET;
+	sa.port[0] = byte(port>>8);
+	sa.port[1] = byte(port);
+	for i := 0; i < IPv4len; i++ {
+		sa.addr[i] = p[i]
+	}
+	return syscall.SockaddrInet4ToSockaddr(sa), nil
+}
+
+export func IPv6ToSockaddr(p *[]byte, port int) (sa1 *syscall.Sockaddr, err *os.Error) {
+	p = ToIPv6(p)
+	if p == nil || port < 0 || port > 0xFFFF {
+		return nil, os.EINVAL
+	}
+	sa := new(syscall.SockaddrInet6);
+	sa.len = syscall.SizeofSockaddrInet6;
+	sa.family = syscall.AF_INET6;
+	sa.port[0] = byte(port>>8);
+	sa.port[1] = byte(port);
+	for i := 0; i < IPv6len; i++ {
+		sa.addr[i] = p[i]
+	}
+	return syscall.SockaddrInet6ToSockaddr(sa), nil
+}
+
+export func SockaddrToIP(sa1 *syscall.Sockaddr) (p *[]byte, port int, err *os.Error) {
+	switch sa1.family {
+	case syscall.AF_INET:
+		sa := syscall.SockaddrToSockaddrInet4(sa1);
+		a := ToIPv6(&sa.addr)
+		if a == nil {
+			return nil, 0, os.EINVAL
+		}
+		return a, int(sa.port[0])<<8 + int(sa.port[1]), nil
+	case syscall.AF_INET6:
+		sa := syscall.SockaddrToSockaddrInet6(sa1);
+		a := ToIPv6(&sa.addr)
+		if a == nil {
+			return nil, 0, os.EINVAL
+		}
+		return a, int(sa.port[0])<<8 + int(sa.port[1]), nil
+	default:
+		return nil, 0, os.EINVAL
+	}
+	return nil, 0, nil	// not reached
+}
+
+export func ListenBacklog() int64 {
+	return syscall.SOMAXCONN
+}
+
diff --git a/src/lib/net/net_linux.go b/src/lib/net/net_linux.go
new file mode 100644
index 0000000000..bc0b8f6d3a
--- /dev/null
+++ b/src/lib/net/net_linux.go
@@ -0,0 +1,70 @@
+// Copyright 2009 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package net
+
+import (
+	"os";
+	"syscall";
+	"net"
+)
+
+export func IPv4ToSockaddr(p *[]byte, port int) (sa1 *syscall.Sockaddr, err *os.Error) {
+	p = ToIPv4(p)
+	if p == nil || port < 0 || port > 0xFFFF {
+		return nil, os.EINVAL
+	}
+	sa := new(syscall.SockaddrInet4);
+	sa.family = syscall.AF_INET;
+	sa.port[0] = byte(port>>8);
+	sa.port[1] = byte(port);
+	for i := 0; i < IPv4len; i++ {
+		sa.addr[i] = p[i]
+	}
+	return syscall.SockaddrInet4ToSockaddr(sa), nil
+}
+
+export func IPv6ToSockaddr(p *[]byte, port int) (sa1 *syscall.Sockaddr, err *os.Error) {
+	p = ToIPv6(p)
+	if p == nil || port < 0 || port > 0xFFFF {
+		return nil, os.EINVAL
+	}
+	sa := new(syscall.SockaddrInet6);
+	sa.family = syscall.AF_INET6;
+	sa.port[0] = byte(port>>8);
+	sa.port[1] = byte(port);
+	for i := 0; i < IPv6len; i++ {
+		sa.addr[i] = p[i]
+	}
+	return syscall.SockaddrInet6ToSockaddr(sa), nil
+}
+
+export func SockaddrToIP(sa1 *syscall.Sockaddr) (p *[]byte, port int, err *os.Error) {
+	switch sa1.family {
+	case syscall.AF_INET:
+		sa := syscall.SockaddrToSockaddrInet4(sa1);
+		a := ToIPv6(&sa.addr)
+		if a == nil {
+			return nil, 0, os.EINVAL
+		}
+		return a, int(sa.port[0])<<8 + int(sa.port[1]), nil
+	case syscall.AF_INET6:
+		sa := syscall.SockaddrToSockaddrInet6(sa1);
+		a := ToIPv6(&sa.addr)
+		if a == nil {
+			return nil, 0, os.EINVAL
+		}
+		return a, int(sa.port[0])<<8 + int(sa.port[1]), nil
+	default:
+		return nil, 0, os.EINVAL
+	}
+	return nil, 0, nil	// not reached
+}
+
+export func ListenBacklog() int64 {
+	// TODO: Read the limit from /proc/sys/net/core/somaxconn,
+	// to take advantage of kernels that have raised the limit.
+	return syscall.SOMAXCONN
+}
+
diff --git a/src/lib/syscall/Makefile b/src/lib/syscall/Makefile
new file mode 100644
index 0000000000..8564854f1d
--- /dev/null
+++ b/src/lib/syscall/Makefile
@@ -0,0 +1,58 @@
+# Copyright 2009 The Go Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style
+# license that can be found in the LICENSE file.
+
+# DO NOT EDIT.  Automatically generated by gobuild.
+# gobuild -m syscall errstr_darwin.go file_darwin.go socket_darwin.go\
+#    syscall_amd64_darwin.go time_amd64_darwin.go types_amd64_darwin.go\
+#    asm_amd64_darwin.s cast_amd64.s syscall.go
+O=6
+GC=$(O)g
+CC=$(O)c -w
+AS=$(O)a
+AR=$(O)ar
+
+PKG=$(GOROOT)/pkg/syscall.a
+
+install: $(PKG)
+
+nuke: clean
+	rm -f $(PKG)
+
+clean:
+	rm -f *.$O *.a
+
+%.$O: %.go
+	$(GC) $*.go
+
+%.$O: %.c
+	$(CC) $*.c
+
+%.$O: %.s
+	$(AS) $*.s
+
+
+O1=\
+	errstr_$(GOOS).$O\
+	syscall_$(GOARCH)_$(GOOS).$O\
+	types_$(GOARCH)_$(GOOS).$O\
+	asm_$(GOARCH)_$(GOOS).$O\
+	cast_$(GOARCH).$O\
+	syscall.$O\
+
+O2=\
+	file_$(GOOS).$O\
+	socket_$(GOOS).$O\
+	time_$(GOARCH)_$(GOOS).$O\
+
+$(PKG): a1 a2
+a1:	$(O1)
+	$(AR) grc $(PKG) $(O1)
+	rm -f $(O1)
+a2:	$(O2)
+	$(AR) grc $(PKG) $(O2)
+	rm -f $(O2)
+
+$(O1): nuke
+$(O2): a1
+
diff --git a/src/syscall/syscall_amd64_darwin.s b/src/lib/syscall/asm_amd64_darwin.s
similarity index 80%
rename from src/syscall/syscall_amd64_darwin.s
rename to src/lib/syscall/asm_amd64_darwin.s
index 8677451d40..64b74db43e 100644
--- a/src/syscall/syscall_amd64_darwin.s
+++ b/src/lib/syscall/asm_amd64_darwin.s
@@ -10,7 +10,7 @@
 // func Syscall6(trap int64, a1, a2, a3, a4, a5, a6 int64) (r1, r2, err int64);
 // Trap # in AX, args in DI SI DX, return in AX DX
 
-TEXT	syscall·Syscall(SB),7,$-8
+TEXT	syscall·Syscall(SB),7,$0
 	MOVQ	16(SP), DI
 	MOVQ	24(SP), SI
 	MOVQ	32(SP), DX
@@ -27,7 +27,7 @@ TEXT	syscall·Syscall(SB),7,$-8
 	MOVQ	$0, 56(SP)	// errno
 	RET
 
-TEXT	syscall·Syscall6(SB),7,$-8
+TEXT	syscall·Syscall6(SB),7,$0
 	MOVQ	16(SP), DI
 	MOVQ	24(SP), SI
 	MOVQ	32(SP), DX
@@ -46,14 +46,3 @@ TEXT	syscall·Syscall6(SB),7,$-8
 	MOVQ	DX, 72(SP)	// r2
 	MOVQ	$0, 80(SP)	// errno
 	RET
-
-// conversion operators - really just casts
-TEXT	syscall·BytePtr(SB),7,$-8
-	MOVQ	8(SP), AX
-	MOVQ	AX, 16(SP)
-	RET
-
-TEXT	syscall·StatPtr(SB),7,$-8
-	MOVQ	8(SP), AX
-	MOVQ	AX, 16(SP)
-	RET
diff --git a/src/syscall/syscall_amd64_linux.s b/src/lib/syscall/asm_amd64_linux.s
similarity index 77%
rename from src/syscall/syscall_amd64_linux.s
rename to src/lib/syscall/asm_amd64_linux.s
index 4fea6d55b9..48630337ab 100644
--- a/src/syscall/syscall_amd64_linux.s
+++ b/src/lib/syscall/asm_amd64_linux.s
@@ -48,24 +48,3 @@ TEXT syscall·Syscall6(SB),7,$-8
 	MOVQ	DX, 72(SP)	// r2
 	MOVQ	$0, 80(SP)	// errno
 	RET
-
-// conversion operators - really just casts
-TEXT	syscall·BytePtr(SB),7,$-8
-	MOVQ	8(SP), AX
-	MOVQ	AX, 16(SP)
-	RET
-
-TEXT	syscall·Int32Ptr(SB),7,$-8
-	MOVQ	8(SP), AX
-	MOVQ	AX, 16(SP)
-	RET
-
-TEXT	syscall·Int64Ptr(SB),7,$-8
-	MOVQ	8(SP), AX
-	MOVQ	AX, 16(SP)
-	RET
-
-TEXT	syscall·StatPtr(SB),7,$-8
-	MOVQ	8(SP), AX
-	MOVQ	AX, 16(SP)
-	RET
diff --git a/src/lib/syscall/cast_amd64.s b/src/lib/syscall/cast_amd64.s
new file mode 100644
index 0000000000..d0447d6e53
--- /dev/null
+++ b/src/lib/syscall/cast_amd64.s
@@ -0,0 +1,70 @@
+// Copyright 2009 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// conversion operators - really just casts
+TEXT	syscall·BytePtr(SB),7,$-8
+	MOVQ	8(SP), AX
+	MOVQ	AX, 16(SP)
+	RET
+
+TEXT	syscall·Int32Ptr(SB),7,$-8
+	MOVQ	8(SP), AX
+	MOVQ	AX, 16(SP)
+	RET
+
+TEXT	syscall·Int64Ptr(SB),7,$-8
+	MOVQ	8(SP), AX
+	MOVQ	AX, 16(SP)
+	RET
+
+TEXT	syscall·KeventPtr(SB),7,$-8
+	MOVQ	8(SP), AX
+	MOVQ	AX, 16(SP)
+	RET
+
+TEXT	syscall·LingerPtr(SB),7,$-8
+	MOVQ	8(SP), AX
+	MOVQ	AX, 16(SP)
+	RET
+
+TEXT	syscall·SockaddrPtr(SB),7,$-8
+	MOVQ	8(SP), AX
+	MOVQ	AX, 16(SP)
+	RET
+
+TEXT	syscall·StatPtr(SB),7,$-8
+	MOVQ	8(SP), AX
+	MOVQ	AX, 16(SP)
+	RET
+
+TEXT	syscall·TimespecPtr(SB),7,$-8
+	MOVQ	8(SP), AX
+	MOVQ	AX, 16(SP)
+	RET
+
+TEXT	syscall·TimevalPtr(SB),7,$-8
+	MOVQ	8(SP), AX
+	MOVQ	AX, 16(SP)
+	RET
+
+TEXT	syscall·SockaddrToSockaddrInet4(SB),7,$-8
+	MOVQ	8(SP), AX
+	MOVQ	AX, 16(SP)
+	RET
+
+TEXT	syscall·SockaddrToSockaddrInet6(SB),7,$-8
+	MOVQ	8(SP), AX
+	MOVQ	AX, 16(SP)
+	RET
+
+TEXT	syscall·SockaddrInet4ToSockaddr(SB),7,$-8
+	MOVQ	8(SP), AX
+	MOVQ	AX, 16(SP)
+	RET
+
+TEXT	syscall·SockaddrInet6ToSockaddr(SB),7,$-8
+	MOVQ	8(SP), AX
+	MOVQ	AX, 16(SP)
+	RET
+
diff --git a/src/syscall/errstr_darwin.go b/src/lib/syscall/errstr_darwin.go
similarity index 100%
rename from src/syscall/errstr_darwin.go
rename to src/lib/syscall/errstr_darwin.go
diff --git a/src/syscall/errstr_linux.go b/src/lib/syscall/errstr_linux.go
similarity index 100%
rename from src/syscall/errstr_linux.go
rename to src/lib/syscall/errstr_linux.go
diff --git a/src/lib/syscall/file_darwin.go b/src/lib/syscall/file_darwin.go
new file mode 100644
index 0000000000..c481b0d1ed
--- /dev/null
+++ b/src/lib/syscall/file_darwin.go
@@ -0,0 +1,88 @@
+// Copyright 2009 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package syscall
+
+// File operations for Darwin
+
+import syscall "syscall"
+
+const NameBufsize = 512
+
+export func open(name string, mode int64, perm int64) (ret int64, errno int64) {
+	var namebuf [NameBufsize]byte;
+	if !StringToBytes(&namebuf, name) {
+		return -1, ENAMETOOLONG
+	}
+	r1, r2, err := Syscall(SYS_OPEN, BytePtr(&namebuf[0]), mode, perm);
+	return r1, err;
+}
+
+export func creat(name string, perm int64) (ret int64, errno int64) {
+	var namebuf [NameBufsize]byte;
+	if !StringToBytes(&namebuf, name) {
+		return -1, ENAMETOOLONG
+	}
+	r1, r2, err := Syscall(SYS_OPEN, BytePtr(&namebuf[0]), O_CREAT|O_WRONLY|O_TRUNC, perm);
+	return r1, err;
+}
+
+export func close(fd int64) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_CLOSE, fd, 0, 0);
+	return r1, err;
+}
+
+export func read(fd int64, buf *byte, nbytes int64) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_READ, fd, BytePtr(buf), nbytes);
+	return r1, err;
+}
+
+export func write(fd int64, buf *byte, nbytes int64) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_WRITE, fd, BytePtr(buf), nbytes);
+	return r1, err;
+}
+
+export func pipe(fds *[2]int64) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_PIPE, 0, 0, 0);
+	if r1 < 0 {
+		return r1, err;
+	}
+	fds[0] = r1;
+	fds[1] = r2;
+	return 0, 0;
+}
+
+export func stat(name string, buf *Stat) (ret int64, errno int64) {
+	var namebuf [NameBufsize]byte;
+	if !StringToBytes(&namebuf, name) {
+		return -1, ENAMETOOLONG
+	}
+	r1, r2, err := Syscall(SYS_STAT, BytePtr(&namebuf[0]), StatPtr(buf), 0);
+	return r1, err;
+}
+
+export func lstat(name *byte, buf *Stat) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_LSTAT, BytePtr(name), StatPtr(buf), 0);
+	return r1, err;
+}
+
+export func fstat(fd int64, buf *Stat) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_FSTAT, fd, StatPtr(buf), 0);
+	return r1, err;
+}
+
+export func unlink(name string) (ret int64, errno int64) {
+	var namebuf [NameBufsize]byte;
+	if !StringToBytes(&namebuf, name) {
+		return -1, ENAMETOOLONG
+	}
+	r1, r2, err := Syscall(SYS_UNLINK, BytePtr(&namebuf[0]), 0, 0);
+	return r1, err;
+}
+
+export func fcntl(fd, cmd, arg int64) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_FCNTL, fd, cmd, arg)
+	return r1, err
+}
+
diff --git a/src/lib/syscall/file_linux.go b/src/lib/syscall/file_linux.go
new file mode 100644
index 0000000000..fdf690fbb2
--- /dev/null
+++ b/src/lib/syscall/file_linux.go
@@ -0,0 +1,84 @@
+// Copyright 2009 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package syscall
+
+// File operations for Linux
+
+import syscall "syscall"
+
+const NameBufsize = 512
+
+export func open(name string, mode int64, perm int64) (ret int64, errno int64) {
+	var namebuf [NameBufsize]byte;
+	if !StringToBytes(&namebuf, name) {
+		return -1, ENAMETOOLONG
+	}
+	r1, r2, err := Syscall(SYS_OPEN, BytePtr(&namebuf[0]), mode, perm);
+	return r1, err;
+}
+
+export func creat(name string, perm int64) (ret int64, errno int64) {
+	var namebuf [NameBufsize]byte;
+	if !StringToBytes(&namebuf, name) {
+		return -1, ENAMETOOLONG
+	}
+	r1, r2, err := Syscall(SYS_OPEN, BytePtr(&namebuf[0]),  O_CREAT|O_WRONLY|O_TRUNC, perm);
+	return r1, err;
+}
+
+export func close(fd int64) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_CLOSE, fd, 0, 0);
+	return r1, err;
+}
+
+export func read(fd int64, buf *byte, nbytes int64) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_READ, fd, BytePtr(buf), nbytes);
+	return r1, err;
+}
+
+export func write(fd int64, buf *byte, nbytes int64) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_WRITE, fd, BytePtr(buf), nbytes);
+	return r1, err;
+}
+
+export func pipe(fds *[2]int64) (ret int64, errno int64) {
+	var t [2] int32;
+	r1, r2, err := Syscall(SYS_PIPE, Int32Ptr(&t[0]), 0, 0);
+	if r1 < 0 {
+		return r1, err;
+	}
+	fds[0] = int64(t[0]);
+	fds[1] = int64(t[1]);
+	return 0, 0;
+}
+
+export func stat(name string, buf *Stat) (ret int64, errno int64) {
+	var namebuf [NameBufsize]byte;
+	if !StringToBytes(&namebuf, name) {
+		return -1, ENAMETOOLONG
+	}
+	r1, r2, err := Syscall(SYS_STAT, BytePtr(&namebuf[0]), StatPtr(buf), 0);
+	return r1, err;
+}
+
+export func lstat(name *byte, buf *Stat) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_LSTAT, BytePtr(name), StatPtr(buf), 0);
+	return r1, err;
+}
+
+export func fstat(fd int64, buf *Stat) (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_FSTAT, fd, StatPtr(buf), 0);
+	return r1, err;
+}
+
+export func unlink(name string) (ret int64, errno int64) {
+	var namebuf [NameBufsize]byte;
+	if !StringToBytes(&namebuf, name) {
+		return -1, ENAMETOOLONG
+	}
+	const SYSUNLINK = 87;
+	r1, r2, err := Syscall(SYS_UNLINK, BytePtr(&namebuf[0]), 0, 0);
+	return r1, err;
+}
diff --git a/src/lib/syscall/mkdarwin b/src/lib/syscall/mkdarwin
new file mode 100755
index 0000000000..ca521bae1b
--- /dev/null
+++ b/src/lib/syscall/mkdarwin
@@ -0,0 +1,34 @@
+# Copyright 2009 The Go Authors.  All rights reserved.
+# Use of this source code is governed by a BSD-style
+# license that can be found in the LICENSE file.
+
+my $command = "mkdarwin " . join(' ', @ARGV);
+
+print <<EOF;
+// Generated by mkdarwin; DO NOT EDIT.
+// $command
+
+package syscall
+
+export const (
+EOF
+
+while(<>){
+	if(/^([0-9]+)\s+ALL\s+({ \S+\s+(\w+).*})/){
+		my $num = $1;
+		my $proto = $2;
+		my $name = "SYS_$3";
+		$name =~ y/a-z/A-Z/;
+
+		# There are multiple entries for nosys(), so comment them out.
+		if($name eq "SYS_NOSYS"){
+			$name = "// $name";
+		}
+
+		print "	$name = $num;  // $proto\n";
+	}
+}
+
+print <<EOF;
+)
+EOF
diff --git a/src/lib/syscall/mklinux b/src/lib/syscall/mklinux
new file mode 100755
index 0000000000..f1b02fa2fd
--- /dev/null
+++ b/src/lib/syscall/mklinux
@@ -0,0 +1,28 @@
+#!/usr/bin/perl
+# Copyright 2009 The Go Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style
+# license that can be found in the LICENSE file.
+
+my $command = "mklinux ". join(' ', @ARGV);
+
+print <<EOF;
+// Generated by mklinux; DO NOT EDIT.
+// $command
+
+package syscall
+
+export const(
+EOF
+
+while(<>){
+	if(/^#define __NR_(\w+)\s+([0-9]+)/){
+		my $name = "SYS_$1";
+		my $num = $2;
+		$name =~ y/a-z/A-Z/;
+		print "	$name = $num;\n";
+	}
+}
+
+print <<EOF;
+)
+EOF
diff --git a/src/lib/syscall/socket_darwin.go b/src/lib/syscall/socket_darwin.go
new file mode 100644
index 0000000000..c8104da0b1
--- /dev/null
+++ b/src/lib/syscall/socket_darwin.go
@@ -0,0 +1,109 @@
+// Copyright 2009 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Low-level socket interface.
+// Only for implementing net package.
+// DO NOT USE DIRECTLY.
+
+package syscall
+import "syscall"
+
+export func SockaddrToSockaddrInet4(s *Sockaddr) *SockaddrInet4;
+export func SockaddrToSockaddrInet6(s *Sockaddr) *SockaddrInet6;
+export func SockaddrInet4ToSockaddr(s *SockaddrInet4) *Sockaddr;
+export func SockaddrInet6ToSockaddr(s *SockaddrInet6) *Sockaddr;
+
+export func socket(domain, proto, typ int64) (ret int64, err int64) {
+	r1, r2, e := Syscall(SYS_SOCKET, domain, proto, typ);
+	return r1, e
+}
+
+export func connect(fd int64, sa *Sockaddr) (ret int64, err int64) {
+	r1, r2, e := Syscall(SYS_CONNECT, fd, SockaddrPtr(sa), int64(sa.len));
+	return r1, e
+}
+
+export func bind(fd int64, sa *Sockaddr) (ret int64, err int64) {
+	r1, r2, e := Syscall(SYS_BIND, fd, SockaddrPtr(sa), int64(sa.len));
+	return r1, e
+}
+
+export func listen(fd, n int64) (ret int64, err int64) {
+	r1, r2, e := Syscall(SYS_LISTEN, fd, n, 0);
+	return r1, e
+}
+
+export func accept(fd int64, sa *Sockaddr) (ret int64, err int64) {
+	n := SizeofSockaddr;
+	r1, r2, e := Syscall(SYS_ACCEPT, fd, SockaddrPtr(sa), Int32Ptr(&n));
+	return r1, e
+}
+
+export func setsockopt(fd, level, opt, valueptr, length int64) (ret int64, err int64) {
+	if fd < 0 {
+		return -1, EINVAL
+	}
+	r1, r2, e := Syscall6(SYS_SETSOCKOPT, fd, level, opt, valueptr, length, 0);
+	return r1, e
+}
+
+export func setsockopt_int(fd, level, opt int64, value int) int64 {
+	n := int32(opt);
+	r1, e := setsockopt(fd, level, opt, Int32Ptr(&n), 4)
+	return e
+}
+
+export func setsockopt_tv(fd, level, opt, nsec int64) int64 {
+	var tv Timeval;
+	nsec += 999;
+	tv.sec = int64(nsec/1000000000);
+	tv.usec = uint32(nsec%1000000000);
+	r1, e := setsockopt(fd, level, opt, TimevalPtr(&tv), 4)
+	return e
+}
+
+export func setsockopt_linger(fd, level, opt int64, sec int) int64 {
+	var l Linger;
+	if sec != 0 {
+		l.yes = 1;
+		l.sec = sec
+	} else {
+		l.yes = 0;
+		l.sec = 0
+	}
+	r1, err := setsockopt(fd, level, opt, LingerPtr(&l), 8)
+	return err
+}
+
+/*
+export func getsockopt(fd, level, opt, valueptr, lenptr int64) (ret int64, errno int64) {
+	r1, r2, err := Syscall6(SYS_GETSOCKOPT, fd, level, opt, valueptr, lenptr, 0);
+	return r1, err;
+}
+*/
+
+export func kqueue() (ret int64, errno int64) {
+	r1, r2, err := Syscall(SYS_KQUEUE, 0, 0, 0);
+	return r1, err
+}
+
+export func kevent(kq int64, changes, events *[]Kevent, timeout *Timespec) (ret int64, errno int64) {
+	var nchange, changeptr, nevent, eventptr int64;
+	nchange = 0;
+	changeptr = 0;
+	nevent = 0;
+	eventptr = 0;
+	if changes != nil && len(changes) > 0 {
+		changeptr = KeventPtr(&changes[0]);
+		nchange = int64(len(changes))
+	}
+	if events != nil && len(events) > 0 {
+		eventptr = KeventPtr(&events[0]);
+		nevent = int64(len(events))
+	}
+	r1, r2, err := Syscall6(SYS_KEVENT, kq, changeptr, nchange,
+		eventptr, nevent, TimespecPtr(timeout));
+	return r1, err
+}
+
diff --git a/src/lib/syscall/socket_linux.go b/src/lib/syscall/socket_linux.go
new file mode 100644
index 0000000000..b690e81a2c
--- /dev/null
+++ b/src/lib/syscall/socket_linux.go
@@ -0,0 +1,99 @@
+// Copyright 2009 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Low-level socket interface.
+// Only for implementing net package.
+// DO NOT USE DIRECTLY.
+
+package syscall
+import "syscall"
+
+export func SockaddrToSockaddrInet4(s *Sockaddr) *SockaddrInet4;
+export func SockaddrToSockaddrInet6(s *Sockaddr) *SockaddrInet6;
+export func SockaddrInet4ToSockaddr(s *SockaddrInet4) *Sockaddr;
+export func SockaddrInet6ToSockaddr(s *SockaddrInet6) *Sockaddr;
+
+func Len(s *Sockaddr) int64 {
+	switch s.family {
+	case AF_UNIX:
+		return SizeofSockaddrUnix
+	case AF_INET:
+		return SizeofSockaddrInet4
+	case AF_INET6:
+		return SizeofSockaddrInet6
+	}
+	return 0
+}
+
+export func socket(domain, proto, typ int64) (ret int64, err int64) {
+	r1, r2, e := Syscall(SYS_SOCKET, domain, proto, typ);
+	return r1, e
+}
+
+export func connect(fd int64, sa *Sockaddr) (ret int64, err int64) {
+	r1, r2, e := Syscall(SYS_CONNECT, fd, SockaddrPtr(sa), Len(sa));
+	return r1, e
+}
+
+export func bind(fd int64, sa *Sockaddr) (ret int64, err int64) {
+	r1, r2, e := Syscall(SYS_BIND, fd, SockaddrPtr(sa), Len(sa));
+	return r1, e
+}
+
+export func listen(fd, n int64) (ret int64, err int64) {
+	r1, r2, e := Syscall(SYS_LISTEN, fd, n, 0);
+	return r1, e
+}
+
+export func accept(fd int64, sa *Sockaddr) (ret int64, err int64) {
+	n := SizeofSockaddr;
+	r1, r2, e := Syscall(SYS_ACCEPT, fd, SockaddrPtr(sa), Int32Ptr(&n));
+	return r1, e
+}
+
+export func setsockopt(fd, level, opt, valueptr, length int64) (ret int64, err int64) {
+	if fd < 0 {
+		return -1, EINVAL
+	}
+	r1, r2, e := Syscall6(SYS_SETSOCKOPT, fd, level, opt, valueptr, length, 0);
+	return r1, e
+}
+
+export func setsockopt_int(fd, level, opt int64, value int) int64 {
+	n := int32(opt);
+	r1, e := setsockopt(fd, level, opt, Int32Ptr(&n), 4)
+	return e
+}
+
+export func setsockopt_tv(fd, level, opt, nsec int64) int64 {
+	var tv Timeval;
+	nsec += 999;
+	tv.sec = int64(nsec/1000000000);
+	tv.usec = uint64(nsec%1000000000);
+	r1, e := setsockopt(fd, level, opt, TimevalPtr(&tv), 4)
+	return e
+}
+
+export func setsockopt_linger(fd, level, opt int64, sec int) int64 {
+	var l Linger;
+	if sec != 0 {
+		l.yes = 1;
+		l.sec = sec
+	} else {
+		l.yes = 0;
+		l.sec = 0
+	}
+	r1, err := setsockopt(fd, level, opt, LingerPtr(&l), 8)
+	return err
+}
+
+/*
+export func getsockopt(fd, level, opt, valueptr, lenptr int64) (ret int64, errno int64) {
+	r1, r2, err := Syscall6(GETSOCKOPT, fd, level, opt, valueptr, lenptr, 0);
+	return r1, err;
+}
+*/
+
+// TODO: epoll
+
diff --git a/src/syscall/syscall.go b/src/lib/syscall/syscall.go
similarity index 90%
rename from src/syscall/syscall.go
rename to src/lib/syscall/syscall.go
index 9ec14de27a..6420684ce0 100644
--- a/src/syscall/syscall.go
+++ b/src/lib/syscall/syscall.go
@@ -10,7 +10,10 @@ package syscall
 
 export func Syscall(trap int64, a1, a2, a3 int64) (r1, r2, err int64);
 export func Syscall6(trap int64, a1, a2, a3, a4, a5, a6 int64) (r1, r2, err int64);
+
 export func BytePtr(b *byte) int64;
+export func Int32Ptr(p *int32) int64;
+export func Int64Ptr(p *int64) int64;
 
 /*
  * Used to convert file names to byte arrays for passing to kernel,
diff --git a/src/lib/syscall/syscall_amd64_darwin.go b/src/lib/syscall/syscall_amd64_darwin.go
new file mode 100644
index 0000000000..76d1c46a64
--- /dev/null
+++ b/src/lib/syscall/syscall_amd64_darwin.go
@@ -0,0 +1,489 @@
+// Copyright 2009 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Generated by mkdarwin; DO NOT EDIT.
+// mkdarwin /home/rsc/pub/xnu-1228/bsd/kern/syscalls.master
+
+package syscall
+
+export const (
+	// SYS_NOSYS = 0;  // { int nosys(void); }   { indirect syscall }
+	SYS_EXIT = 1;  // { void exit(int rval); }
+	SYS_FORK = 2;  // { int fork(void); }
+	SYS_READ = 3;  // { user_ssize_t read(int fd, user_addr_t cbuf, user_size_t nbyte); }
+	SYS_WRITE = 4;  // { user_ssize_t write(int fd, user_addr_t cbuf, user_size_t nbyte); }
+	SYS_OPEN = 5;  // { int open(user_addr_t path, int flags, int mode); }
+	SYS_CLOSE = 6;  // { int close(int fd); }
+	SYS_WAIT4 = 7;  // { int wait4(int pid, user_addr_t status, int options, user_addr_t rusage); }
+	// SYS_NOSYS = 8;  // { int nosys(void); }   { old creat }
+	SYS_LINK = 9;  // { int link(user_addr_t path, user_addr_t link); }
+	SYS_UNLINK = 10;  // { int unlink(user_addr_t path); }
+	// SYS_NOSYS = 11;  // { int nosys(void); }   { old execv }
+	SYS_CHDIR = 12;  // { int chdir(user_addr_t path); }
+	SYS_FCHDIR = 13;  // { int fchdir(int fd); }
+	SYS_MKNOD = 14;  // { int mknod(user_addr_t path, int mode, int dev); }
+	SYS_CHMOD = 15;  // { int chmod(user_addr_t path, int mode); }
+	SYS_CHOWN = 16;  // { int chown(user_addr_t path, int uid, int gid); }
+	SYS_OGETFSSTAT = 18;  // { int ogetfsstat(user_addr_t buf, int bufsize, int flags); }
+	SYS_GETFSSTAT = 18;  // { int getfsstat(user_addr_t buf, int bufsize, int flags); }
+	// SYS_NOSYS = 19;  // { int nosys(void); }   { old lseek }
+	SYS_GETPID = 20;  // { int getpid(void); }
+	// SYS_NOSYS = 21;  // { int nosys(void); }   { old mount }
+	// SYS_NOSYS = 22;  // { int nosys(void); }   { old umount }
+	SYS_SETUID = 23;  // { int setuid(uid_t uid); }
+	SYS_GETUID = 24;  // { int getuid(void); }
+	SYS_GETEUID = 25;  // { int geteuid(void); }
+	SYS_PTRACE = 26;  // { int ptrace(int req, pid_t pid, caddr_t addr, int data); }
+	SYS_RECVMSG = 27;  // { int recvmsg(int s, struct msghdr *msg, int flags); }
+	SYS_SENDMSG = 28;  // { int sendmsg(int s, caddr_t msg, int flags); }
+	SYS_RECVFROM = 29;  // { int recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, int *fromlenaddr); }
+	SYS_ACCEPT = 30;  // { int accept(int s, caddr_t name, socklen_t	*anamelen); }
+	SYS_GETPEERNAME = 31;  // { int getpeername(int fdes, caddr_t asa, socklen_t *alen); }
+	SYS_GETSOCKNAME = 32;  // { int getsockname(int fdes, caddr_t asa, socklen_t *alen); }
+	// SYS_NOSYS = 27;  // { int nosys(void); }
+	// SYS_NOSYS = 28;  // { int nosys(void); }
+	// SYS_NOSYS = 29;  // { int nosys(void); }
+	// SYS_NOSYS = 30;  // { int nosys(void); }
+	// SYS_NOSYS = 31;  // { int nosys(void); }
+	// SYS_NOSYS = 32;  // { int nosys(void); }
+	SYS_ACCESS = 33;  // { int access(user_addr_t path, int flags); }
+	SYS_CHFLAGS = 34;  // { int chflags(char *path, int flags); }
+	SYS_FCHFLAGS = 35;  // { int fchflags(int fd, int flags); }
+	SYS_SYNC = 36;  // { int sync(void); }
+	SYS_KILL = 37;  // { int kill(int pid, int signum, int posix); }
+	// SYS_NOSYS = 38;  // { int nosys(void); }   { old stat  }
+	SYS_GETPPID = 39;  // { int getppid(void); }
+	// SYS_NOSYS = 40;  // { int nosys(void); }   { old lstat }
+	SYS_DUP = 41;  // { int dup(u_int fd); }
+	SYS_PIPE = 42;  // { int pipe(void); }
+	SYS_GETEGID = 43;  // { int getegid(void); }
+	SYS_PROFIL = 44;  // { int profil(short *bufbase, size_t bufsize, u_long pcoffset, u_int pcscale); }
+	// SYS_NOSYS = 45;  // { int nosys(void); } { old ktrace }
+	SYS_SIGACTION = 46;  // { int sigaction(int signum, struct __sigaction *nsa, struct sigaction *osa); }
+	SYS_GETGID = 47;  // { int getgid(void); }
+	SYS_SIGPROCMASK = 48;  // { int sigprocmask(int how, user_addr_t mask, user_addr_t omask); }
+	SYS_GETLOGIN = 49;  // { int getlogin(char *namebuf, u_int namelen); }
+	SYS_SETLOGIN = 50;  // { int setlogin(char *namebuf); }
+	SYS_ACCT = 51;  // { int acct(char *path); }
+	SYS_SIGPENDING = 52;  // { int sigpending(struct sigvec *osv); }
+	SYS_SIGALTSTACK = 53;  // { int sigaltstack(struct sigaltstack *nss, struct sigaltstack *oss); }
+	SYS_IOCTL = 54;  // { int ioctl(int fd, u_long com, caddr_t data); }
+	SYS_REBOOT = 55;  // { int reboot(int opt, char *command); }
+	SYS_REVOKE = 56;  // { int revoke(char *path); }
+	SYS_SYMLINK = 57;  // { int symlink(char *path, char *link); }
+	SYS_READLINK = 58;  // { int readlink(char *path, char *buf, int count); }
+	SYS_EXECVE = 59;  // { int execve(char *fname, char **argp, char **envp); }
+	SYS_UMASK = 60;  // { int umask(int newmask); }
+	SYS_CHROOT = 61;  // { int chroot(user_addr_t path); }
+	// SYS_NOSYS = 62;  // { int nosys(void); }   { old fstat }
+	// SYS_NOSYS = 63;  // { int nosys(void); }   { used internally, reserved }
+	// SYS_NOSYS = 64;  // { int nosys(void); }   { old getpagesize }
+	SYS_MSYNC = 65;  // { int msync(caddr_t addr, size_t len, int flags); }
+	SYS_VFORK = 66;  // { int vfork(void); }
+	// SYS_NOSYS = 67;  // { int nosys(void); }   { old vread }
+	// SYS_NOSYS = 68;  // { int nosys(void); }   { old vwrite }
+	SYS_SBRK = 69;  // { int sbrk(int incr) NO_SYSCALL_STUB; }
+	SYS_SSTK = 70;  // { int sstk(int incr) NO_SYSCALL_STUB; }
+	// SYS_NOSYS = 71;  // { int nosys(void); }   { old mmap }
+	SYS_OVADVISE = 72;  // { int ovadvise(void) NO_SYSCALL_STUB; }   { old vadvise }
+	SYS_MUNMAP = 73;  // { int munmap(caddr_t addr, size_t len); }
+	SYS_MPROTECT = 74;  // { int mprotect(caddr_t addr, size_t len, int prot); }
+	SYS_MADVISE = 75;  // { int madvise(caddr_t addr, size_t len, int behav); }
+	// SYS_NOSYS = 76;  // { int nosys(void); }   { old vhangup }
+	// SYS_NOSYS = 77;  // { int nosys(void); }   { old vlimit }
+	SYS_MINCORE = 78;  // { int mincore(user_addr_t addr, user_size_t len, user_addr_t vec); }
+	SYS_GETGROUPS = 79;  // { int getgroups(u_int gidsetsize, gid_t *gidset); }
+	SYS_SETGROUPS = 80;  // { int setgroups(u_int gidsetsize, gid_t *gidset); }
+	SYS_GETPGRP = 81;  // { int getpgrp(void); }
+	SYS_SETPGID = 82;  // { int setpgid(int pid, int pgid); }
+	SYS_SETITIMER = 83;  // { int setitimer(u_int which, struct itimerval *itv, struct itimerval *oitv); }
+	// SYS_NOSYS = 84;  // { int nosys(void); }   { old wait }
+	SYS_SWAPON = 85;  // { int swapon(void); }
+	SYS_GETITIMER = 86;  // { int getitimer(u_int which, struct itimerval *itv); }
+	// SYS_NOSYS = 87;  // { int nosys(void); }   { old gethostname }
+	// SYS_NOSYS = 88;  // { int nosys(void); }   { old sethostname }
+	SYS_GETDTABLESIZE = 89;  // { int getdtablesize(void); }
+	SYS_DUP2 = 90;  // { int dup2(u_int from, u_int to); }
+	// SYS_NOSYS = 91;  // { int nosys(void); }   { old getdopt }
+	SYS_FCNTL = 92;  // { int fcntl(int fd, int cmd, long arg); }
+	SYS_SELECT = 93;  // { int select(int nd, u_int32_t *in, u_int32_t *ou, u_int32_t *ex, struct timeval *tv); }
+	// SYS_NOSYS = 94;  // { int nosys(void); }   { old setdopt }
+	SYS_FSYNC = 95;  // { int fsync(int fd); }
+	SYS_SETPRIORITY = 96;  // { int setpriority(int which, id_t who, int prio); }
+	SYS_SOCKET = 97;  // { int socket(int domain, int type, int protocol); }
+	SYS_CONNECT = 98;  // { int connect(int s, caddr_t name, socklen_t namelen); }
+	// SYS_NOSYS = 97;  // { int nosys(void); }
+	// SYS_NOSYS = 98;  // { int nosys(void); }
+	// SYS_NOSYS = 99;  // { int nosys(void); }   { old accept }
+	SYS_GETPRIORITY = 100;  // { int getpriority(int which, id_t who); }
+	// SYS_NOSYS = 101;  // { int nosys(void); }   { old send }
+	// SYS_NOSYS = 102;  // { int nosys(void); }   { old recv }
+	// SYS_NOSYS = 103;  // { int nosys(void); }   { old sigreturn }
+	SYS_BIND = 104;  // { int bind(int s, caddr_t name, socklen_t namelen); }
+	SYS_SETSOCKOPT = 105;  // { int setsockopt(int s, int level, int name, caddr_t val, socklen_t valsize); }
+	SYS_LISTEN = 106;  // { int listen(int s, int backlog); }
+	// SYS_NOSYS = 104;  // { int nosys(void); }
+	// SYS_NOSYS = 105;  // { int nosys(void); }
+	// SYS_NOSYS = 106;  // { int nosys(void); }
+	// SYS_NOSYS = 107;  // { int nosys(void); }   { old vtimes }
+	// SYS_NOSYS = 108;  // { int nosys(void); }   { old sigvec }
+	// SYS_NOSYS = 109;  // { int nosys(void); }   { old sigblock }
+	// SYS_NOSYS = 110;  // { int nosys(void); }   { old sigsetmask }
+	SYS_SIGSUSPEND = 111;  // { int sigsuspend(sigset_t mask); }
+	// SYS_NOSYS = 112;  // { int nosys(void); }   { old sigstack }
+	// SYS_NOSYS = 113;  // { int nosys(void); }   { old recvmsg }
+	// SYS_NOSYS = 114;  // { int nosys(void); }   { old sendmsg }
+	// SYS_NOSYS = 113;  // { int nosys(void); }
+	// SYS_NOSYS = 114;  // { int nosys(void); }
+	// SYS_NOSYS = 115;  // { int nosys(void); }   { old vtrace }
+	SYS_GETTIMEOFDAY = 116;  // { int gettimeofday(struct timeval *tp, struct timezone *tzp); }
+	SYS_GETRUSAGE = 117;  // { int getrusage(int who, struct rusage *rusage); }
+	SYS_GETSOCKOPT = 118;  // { int getsockopt(int s, int level, int name, caddr_t val, socklen_t *avalsize); }
+	// SYS_NOSYS = 118;  // { int nosys(void); }
+	// SYS_NOSYS = 119;  // { int nosys(void); }   { old resuba }
+	SYS_READV = 120;  // { user_ssize_t readv(int fd, struct iovec *iovp, u_int iovcnt); }
+	SYS_WRITEV = 121;  // { user_ssize_t writev(int fd, struct iovec *iovp, u_int iovcnt); }
+	SYS_SETTIMEOFDAY = 122;  // { int settimeofday(struct timeval *tv, struct timezone *tzp); }
+	SYS_FCHOWN = 123;  // { int fchown(int fd, int uid, int gid); }
+	SYS_FCHMOD = 124;  // { int fchmod(int fd, int mode); }
+	// SYS_NOSYS = 125;  // { int nosys(void); }   { old recvfrom }
+	SYS_SETREUID = 126;  // { int setreuid(uid_t ruid, uid_t euid); }
+	SYS_SETREGID = 127;  // { int setregid(gid_t rgid, gid_t egid); }
+	SYS_RENAME = 128;  // { int rename(char *from, char *to); }
+	// SYS_NOSYS = 129;  // { int nosys(void); }   { old truncate }
+	// SYS_NOSYS = 130;  // { int nosys(void); }   { old ftruncate }
+	SYS_FLOCK = 131;  // { int flock(int fd, int how); }
+	SYS_MKFIFO = 132;  // { int mkfifo(user_addr_t path, int mode); }
+	SYS_SENDTO = 133;  // { int sendto(int s, caddr_t buf, size_t len, int flags, caddr_t to, socklen_t tolen); }
+	SYS_SHUTDOWN = 134;  // { int shutdown(int s, int how); }
+	SYS_SOCKETPAIR = 135;  // { int socketpair(int domain, int type, int protocol, int *rsv); }
+	// SYS_NOSYS = 133;  // { int nosys(void); }
+	// SYS_NOSYS = 134;  // { int nosys(void); }
+	// SYS_NOSYS = 135;  // { int nosys(void); }
+	SYS_MKDIR = 136;  // { int mkdir(user_addr_t path, int mode); }
+	SYS_RMDIR = 137;  // { int rmdir(char *path); }
+	SYS_UTIMES = 138;  // { int utimes(char *path, struct timeval *tptr); }
+	SYS_FUTIMES = 139;  // { int futimes(int fd, struct timeval *tptr); }
+	SYS_ADJTIME = 140;  // { int adjtime(struct timeval *delta, struct timeval *olddelta); }
+	// SYS_NOSYS = 141;  // { int nosys(void); }   { old getpeername }
+	SYS_GETHOSTUUID = 142;  // { int gethostuuid(unsigned char *uuid_buf, const struct timespec *timeoutp); }
+	// SYS_NOSYS = 143;  // { int nosys(void); }   { old sethostid 	}
+	// SYS_NOSYS = 144;  // { int nosys(void); }   { old getrlimit }
+	// SYS_NOSYS = 145;  // { int nosys(void); }   { old setrlimit }
+	// SYS_NOSYS = 146;  // { int nosys(void); }   { old killpg }
+	SYS_SETSID = 147;  // { int setsid(void); }
+	// SYS_NOSYS = 148;  // { int nosys(void); }   { old setquota }
+	// SYS_NOSYS = 149;  // { int nosys(void); }   { old qquota }
+	// SYS_NOSYS = 150;  // { int nosys(void); }   { old getsockname }
+	SYS_GETPGID = 151;  // { int getpgid(pid_t pid); }
+	SYS_SETPRIVEXEC = 152;  // { int setprivexec(int flag); }
+	SYS_PREAD = 153;  // { user_ssize_t pread(int fd, user_addr_t buf, user_size_t nbyte, off_t offset); }
+	SYS_PWRITE = 154;  // { user_ssize_t pwrite(int fd, user_addr_t buf, user_size_t nbyte, off_t offset); }
+	SYS_NFSSVC = 155;  // { int nfssvc(int flag, caddr_t argp); }
+	// SYS_NOSYS = 155;  // { int nosys(void); }
+	// SYS_NOSYS = 156;  // { int nosys(void); }   { old getdirentries }
+	SYS_STATFS = 157;  // { int statfs(char *path, struct statfs *buf); }
+	SYS_FSTATFS = 158;  // { int fstatfs(int fd, struct statfs *buf); }
+	SYS_UNMOUNT = 159;  // { int unmount(user_addr_t path, int flags); }
+	// SYS_NOSYS = 160;  // { int nosys(void); }   { old async_daemon }
+	SYS_GETFH = 161;  // { int getfh(char *fname, fhandle_t *fhp); }
+	// SYS_NOSYS = 161;  // { int nosys(void); }
+	// SYS_NOSYS = 162;  // { int nosys(void); }   { old getdomainname }
+	// SYS_NOSYS = 163;  // { int nosys(void); }   { old setdomainname }
+	// SYS_NOSYS = 164;  // { int nosys(void); }
+	SYS_QUOTACTL = 165;  // { int quotactl(const char *path, int cmd, int uid, caddr_t arg); }
+	// SYS_NOSYS = 166;  // { int nosys(void); }   { old exportfs }
+	SYS_MOUNT = 167;  // { int mount(char *type, char *path, int flags, caddr_t data); }
+	// SYS_NOSYS = 168;  // { int nosys(void); }   { old ustat }
+	SYS_CSOPS = 169;  // { int csops(pid_t pid, uint32_t ops, user_addr_t useraddr, user_size_t usersize); }
+	// SYS_NOSYS = 171;  // { int nosys(void); }   { old wait3 }
+	// SYS_NOSYS = 172;  // { int nosys(void); }   { old rpause	}
+	SYS_WAITID = 173;  // { int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); }
+	// SYS_NOSYS = 174;  // { int nosys(void); }   { old getdents }
+	// SYS_NOSYS = 175;  // { int nosys(void); }   { old gc_control }
+	SYS_ADD_PROFIL = 176;  // { int add_profil(short *bufbase, size_t bufsize, u_long pcoffset, u_int pcscale); }
+	// SYS_NOSYS = 177;  // { int nosys(void); }
+	// SYS_NOSYS = 178;  // { int nosys(void); }
+	// SYS_NOSYS = 179;  // { int nosys(void); }
+	SYS_KDEBUG_TRACE = 180;  // { int kdebug_trace(int code, int arg1, int arg2, int arg3, int arg4, int arg5) NO_SYSCALL_STUB; }
+	SYS_SETGID = 181;  // { int setgid(gid_t gid); }
+	SYS_SETEGID = 182;  // { int setegid(gid_t egid); }
+	SYS_SETEUID = 183;  // { int seteuid(uid_t euid); }
+	SYS_SIGRETURN = 184;  // { int sigreturn(struct ucontext *uctx, int infostyle); }
+	// SYS_NOSYS = 186;  // { int nosys(void); }
+	// SYS_NOSYS = 187;  // { int nosys(void); }
+	SYS_STAT = 188;  // { int stat(user_addr_t path, user_addr_t ub); }
+	SYS_FSTAT = 189;  // { int fstat(int fd, user_addr_t ub); }
+	SYS_LSTAT = 190;  // { int lstat(user_addr_t path, user_addr_t ub); }
+	SYS_PATHCONF = 191;  // { int pathconf(char *path, int name); }
+	SYS_FPATHCONF = 192;  // { int fpathconf(int fd, int name); }
+	// SYS_NOSYS = 193;  // { int nosys(void); }
+	SYS_GETRLIMIT = 194;  // { int getrlimit(u_int which, struct rlimit *rlp); }
+	SYS_SETRLIMIT = 195;  // { int setrlimit(u_int which, struct rlimit *rlp); }
+	SYS_GETDIRENTRIES = 196;  // { int getdirentries(int fd, char *buf, u_int count, long *basep); }
+	SYS_MMAP = 197;  // { user_addr_t mmap(caddr_t addr, size_t len, int prot, int flags, int fd, off_t pos); }
+	// SYS_NOSYS = 198;  // { int nosys(void); } 	{ __syscall }
+	SYS_LSEEK = 199;  // { off_t lseek(int fd, off_t offset, int whence); }
+	SYS_TRUNCATE = 200;  // { int truncate(char *path, off_t length); }
+	SYS_FTRUNCATE = 201;  // { int ftruncate(int fd, off_t length); }
+	SYS___SYSCTL = 202;  // { int __sysctl(int *name, u_int namelen, void *old, size_t *oldlenp, void *new, size_t newlen); }
+	SYS_MLOCK = 203;  // { int mlock(caddr_t addr, size_t len); }
+	SYS_MUNLOCK = 204;  // { int munlock(caddr_t addr, size_t len); }
+	SYS_UNDELETE = 205;  // { int undelete(user_addr_t path); }
+	SYS_ATSOCKET = 206;  // { int ATsocket(int proto); }
+	// SYS_NOSYS = 213;  // { int nosys(void); } 	{ Reserved for AppleTalk }
+	// SYS_NOSYS = 206;  // { int nosys(void); }
+	// SYS_NOSYS = 207;  // { int nosys(void); }
+	// SYS_NOSYS = 208;  // { int nosys(void); }
+	// SYS_NOSYS = 209;  // { int nosys(void); }
+	// SYS_NOSYS = 210;  // { int nosys(void); }
+	// SYS_NOSYS = 211;  // { int nosys(void); }
+	// SYS_NOSYS = 212;  // { int nosys(void); }
+	// SYS_NOSYS = 213;  // { int nosys(void); } 	{ Reserved for AppleTalk }
+	SYS_KQUEUE_FROM_PORTSET_NP = 214;  // { int kqueue_from_portset_np(int portset); }
+	SYS_KQUEUE_PORTSET_NP = 215;  // { int kqueue_portset_np(int fd); }
+	SYS_GETATTRLIST = 220;  // { int getattrlist(const char *path, struct attrlist *alist, void *attributeBuffer, size_t bufferSize, u_long options); }
+	SYS_SETATTRLIST = 221;  // { int setattrlist(const char *path, struct attrlist *alist, void *attributeBuffer, size_t bufferSize, u_long options); }
+	SYS_GETDIRENTRIESATTR = 222;  // { int getdirentriesattr(int fd, struct attrlist *alist, void *buffer, size_t buffersize, u_long *count, u_long *basep, u_long *newstate, u_long options); }
+	SYS_EXCHANGEDATA = 223;  // { int exchangedata(const char *path1, const char *path2, u_long options); }
+	// SYS_NOSYS = 224;  // { int nosys(void); } { was checkuseraccess }
+	SYS_SEARCHFS = 225;  // { int searchfs(const char *path, struct fssearchblock *searchblock, u_long *nummatches, u_long scriptcode, u_long options, struct searchstate *state); }
+	SYS_DELETE = 226;  // { int delete(user_addr_t path) NO_SYSCALL_STUB; }       { private delete (Carbon semantics) }
+	SYS_COPYFILE = 227;  // { int copyfile(char *from, char *to, int mode, int flags) NO_SYSCALL_STUB; }
+	// SYS_NOSYS = 228;  // { int nosys(void); }
+	// SYS_NOSYS = 229;  // { int nosys(void); }
+	SYS_POLL = 230;  // { int poll(struct pollfd *fds, u_int nfds, int timeout); }
+	SYS_WATCHEVENT = 231;  // { int watchevent(struct eventreq *u_req, int u_eventmask); }
+	SYS_WAITEVENT = 232;  // { int waitevent(struct eventreq *u_req, struct timeval *tv); }
+	SYS_MODWATCH = 233;  // { int modwatch(struct eventreq *u_req, int u_eventmask); }
+	SYS_GETXATTR = 234;  // { user_ssize_t getxattr(user_addr_t path, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
+	SYS_FGETXATTR = 235;  // { user_ssize_t fgetxattr(int fd, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
+	SYS_SETXATTR = 236;  // { int setxattr(user_addr_t path, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
+	SYS_FSETXATTR = 237;  // { int fsetxattr(int fd, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
+	SYS_REMOVEXATTR = 238;  // { int removexattr(user_addr_t path, user_addr_t attrname, int options); }
+	SYS_FREMOVEXATTR = 239;  // { int fremovexattr(int fd, user_addr_t attrname, int options); }
+	SYS_LISTXATTR = 240;  // { user_ssize_t listxattr(user_addr_t path, user_addr_t namebuf, size_t bufsize, int options); }
+	SYS_FLISTXATTR = 241;  // { user_ssize_t flistxattr(int fd, user_addr_t namebuf, size_t bufsize, int options); }
+	SYS_FSCTL = 242;  // { int fsctl(const char *path, u_long cmd, caddr_t data, u_long options); }
+	SYS_INITGROUPS = 243;  // { int initgroups(u_int gidsetsize, gid_t *gidset, int gmuid); }
+	SYS_POSIX_SPAWN = 244;  // { int posix_spawn(pid_t *pid, const char *path, const struct _posix_spawn_args_desc *adesc, char **argv, char **envp); }
+	// SYS_NOSYS = 245;  // { int nosys(void); }
+	// SYS_NOSYS = 246;  // { int nosys(void); }
+	SYS_NFSCLNT = 247;  // { int nfsclnt(int flag, caddr_t argp); }
+	// SYS_NOSYS = 247;  // { int nosys(void); }
+	SYS_FHOPEN = 248;  // { int fhopen(const struct fhandle *u_fhp, int flags); }
+	// SYS_NOSYS = 248;  // { int nosys(void); }
+	// SYS_NOSYS = 249;  // { int nosys(void); }
+	SYS_MINHERIT = 250;  // { int minherit(void *addr, size_t len, int inherit); }
+	SYS_SEMSYS = 251;  // { int semsys(u_int which, int a2, int a3, int a4, int a5); }
+	// SYS_NOSYS = 251;  // { int nosys(void); }
+	SYS_MSGSYS = 252;  // { int msgsys(u_int which, int a2, int a3, int a4, int a5); }
+	// SYS_NOSYS = 252;  // { int nosys(void); }
+	SYS_SHMSYS = 253;  // { int shmsys(u_int which, int a2, int a3, int a4); }
+	// SYS_NOSYS = 253;  // { int nosys(void); }
+	SYS_SEMCTL = 254;  // { int semctl(int semid, int semnum, int cmd, semun_t arg); }
+	SYS_SEMGET = 255;  // { int semget(key_t key, int	nsems, int semflg); }
+	SYS_SEMOP = 256;  // { int semop(int semid, struct sembuf *sops, int nsops); }
+	// SYS_NOSYS = 257;  // { int nosys(void); }
+	// SYS_NOSYS = 254;  // { int nosys(void); }
+	// SYS_NOSYS = 255;  // { int nosys(void); }
+	// SYS_NOSYS = 256;  // { int nosys(void); }
+	// SYS_NOSYS = 257;  // { int nosys(void); }
+	SYS_MSGCTL = 258;  // { int msgctl(int msqid, int cmd, struct	msqid_ds *buf); }
+	SYS_MSGGET = 259;  // { int msgget(key_t key, int msgflg); }
+	SYS_MSGSND = 260;  // { int msgsnd(int msqid, void *msgp, size_t msgsz, int msgflg); }
+	SYS_MSGRCV = 261;  // { user_ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); }
+	// SYS_NOSYS = 258;  // { int nosys(void); }
+	// SYS_NOSYS = 259;  // { int nosys(void); }
+	// SYS_NOSYS = 260;  // { int nosys(void); }
+	// SYS_NOSYS = 261;  // { int nosys(void); }
+	SYS_SHMAT = 262;  // { user_addr_t shmat(int shmid, void *shmaddr, int shmflg); }
+	SYS_SHMCTL = 263;  // { int shmctl(int shmid, int cmd, struct shmid_ds *buf); }
+	SYS_SHMDT = 264;  // { int shmdt(void *shmaddr); }
+	SYS_SHMGET = 265;  // { int shmget(key_t key, size_t size, int shmflg); }
+	// SYS_NOSYS = 262;  // { int nosys(void); }
+	// SYS_NOSYS = 263;  // { int nosys(void); }
+	// SYS_NOSYS = 264;  // { int nosys(void); }
+	// SYS_NOSYS = 265;  // { int nosys(void); }
+	SYS_SHM_OPEN = 266;  // { int shm_open(const char *name, int oflag, int mode); }
+	SYS_SHM_UNLINK = 267;  // { int shm_unlink(const char *name); }
+	SYS_SEM_OPEN = 268;  // { user_addr_t sem_open(const char *name, int oflag, int mode, int value); }
+	SYS_SEM_CLOSE = 269;  // { int sem_close(sem_t *sem); }
+	SYS_SEM_UNLINK = 270;  // { int sem_unlink(const char *name); }
+	SYS_SEM_WAIT = 271;  // { int sem_wait(sem_t *sem); }
+	SYS_SEM_TRYWAIT = 272;  // { int sem_trywait(sem_t *sem); }
+	SYS_SEM_POST = 273;  // { int sem_post(sem_t *sem); }
+	SYS_SEM_GETVALUE = 274;  // { int sem_getvalue(sem_t *sem, int *sval); }
+	SYS_SEM_INIT = 275;  // { int sem_init(sem_t *sem, int phsared, u_int value); }
+	SYS_SEM_DESTROY = 276;  // { int sem_destroy(sem_t *sem); }
+	SYS_OPEN_EXTENDED = 277;  // { int open_extended(user_addr_t path, int flags, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_UMASK_EXTENDED = 278;  // { int umask_extended(int newmask, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_STAT_EXTENDED = 279;  // { int stat_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_LSTAT_EXTENDED = 280;  // { int lstat_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_FSTAT_EXTENDED = 281;  // { int fstat_extended(int fd, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_CHMOD_EXTENDED = 282;  // { int chmod_extended(user_addr_t path, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_FCHMOD_EXTENDED = 283;  // { int fchmod_extended(int fd, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_ACCESS_EXTENDED = 284;  // { int access_extended(user_addr_t entries, size_t size, user_addr_t results, uid_t uid) NO_SYSCALL_STUB; }
+	SYS_SETTID = 285;  // { int settid(uid_t uid, gid_t gid) NO_SYSCALL_STUB; }
+	SYS_GETTID = 286;  // { int gettid(uid_t *uidp, gid_t *gidp) NO_SYSCALL_STUB; }
+	SYS_SETSGROUPS = 287;  // { int setsgroups(int setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
+	SYS_GETSGROUPS = 288;  // { int getsgroups(user_addr_t setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
+	SYS_SETWGROUPS = 289;  // { int setwgroups(int setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
+	SYS_GETWGROUPS = 290;  // { int getwgroups(user_addr_t setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
+	SYS_MKFIFO_EXTENDED = 291;  // { int mkfifo_extended(user_addr_t path, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_MKDIR_EXTENDED = 292;  // { int mkdir_extended(user_addr_t path, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_IDENTITYSVC = 293;  // { int identitysvc(int opcode, user_addr_t message) NO_SYSCALL_STUB; }
+	SYS_SHARED_REGION_CHECK_NP = 294;  // { int shared_region_check_np(uint64_t *start_address) NO_SYSCALL_STUB; }
+	SYS_SHARED_REGION_MAP_NP = 295;  // { int shared_region_map_np(int fd, uint32_t count, const struct shared_file_mapping_np *mappings) NO_SYSCALL_STUB; }
+	// SYS_NOSYS = 296;  // { int nosys(void); } { old load_shared_file }
+	// SYS_NOSYS = 297;  // { int nosys(void); } { old reset_shared_file }
+	// SYS_NOSYS = 298;  // { int nosys(void); } { old new_system_shared_regions }
+	SYS_ENOSYS = 299;  // { int enosys(void); } { old shared_region_map_file_np }
+	SYS_ENOSYS = 300;  // { int enosys(void); } { old shared_region_make_private_np }
+	SYS___PTHREAD_MUTEX_DESTROY = 301;  // { int __pthread_mutex_destroy(int mutexid); }
+	SYS___PTHREAD_MUTEX_INIT = 302;  // { int __pthread_mutex_init(user_addr_t  mutex, user_addr_t attr); }
+	SYS___PTHREAD_MUTEX_LOCK = 303;  // { int __pthread_mutex_lock(int mutexid); }
+	SYS___PTHREAD_MUTEX_TRYLOCK = 304;  // { int __pthread_mutex_trylock(int mutexid); }
+	SYS___PTHREAD_MUTEX_UNLOCK = 305;  // { int __pthread_mutex_unlock(int mutexid); }
+	SYS___PTHREAD_COND_INIT = 306;  // { int __pthread_cond_init(user_addr_t cond, user_addr_t attr); }
+	SYS___PTHREAD_COND_DESTROY = 307;  // { int __pthread_cond_destroy(int condid); }
+	SYS___PTHREAD_COND_BROADCAST = 308;  // { int __pthread_cond_broadcast(int condid); }
+	SYS___PTHREAD_COND_SIGNAL = 309;  // { int __pthread_cond_signal(int condid); }
+	SYS_GETSID = 310;  // { int getsid(pid_t pid); }
+	SYS_SETTID_WITH_PID = 311;  // { int settid_with_pid(pid_t pid, int assume) NO_SYSCALL_STUB; }
+	SYS___PTHREAD_COND_TIMEDWAIT = 312;  // { int __pthread_cond_timedwait(int condid, int mutexid, user_addr_t abstime); }
+	SYS_AIO_FSYNC = 313;  // { int aio_fsync(int op, user_addr_t aiocbp); }
+	SYS_AIO_RETURN = 314;  // { user_ssize_t aio_return(user_addr_t aiocbp); }
+	SYS_AIO_SUSPEND = 315;  // { int aio_suspend(user_addr_t aiocblist, int nent, user_addr_t timeoutp); }
+	SYS_AIO_CANCEL = 316;  // { int aio_cancel(int fd, user_addr_t aiocbp); }
+	SYS_AIO_ERROR = 317;  // { int aio_error(user_addr_t aiocbp); }
+	SYS_AIO_READ = 318;  // { int aio_read(user_addr_t aiocbp); }
+	SYS_AIO_WRITE = 319;  // { int aio_write(user_addr_t aiocbp); }
+	SYS_LIO_LISTIO = 320;  // { int lio_listio(int mode, user_addr_t aiocblist, int nent, user_addr_t sigp); }
+	SYS___PTHREAD_COND_WAIT = 321;  // { int __pthread_cond_wait(int condid, int mutexid); }
+	SYS_IOPOLICYSYS = 322;  // { int iopolicysys(int cmd, void *arg) NO_SYSCALL_STUB; }
+	// SYS_NOSYS = 323;  // { int nosys(void); }
+	SYS_MLOCKALL = 324;  // { int mlockall(int how); }
+	SYS_MUNLOCKALL = 325;  // { int munlockall(int how); }
+	// SYS_NOSYS = 326;  // { int nosys(void); }
+	SYS_ISSETUGID = 327;  // { int issetugid(void); }
+	SYS___PTHREAD_KILL = 328;  // { int __pthread_kill(int thread_port, int sig); }
+	SYS___PTHREAD_SIGMASK = 329;  // { int __pthread_sigmask(int how, user_addr_t set, user_addr_t oset); }
+	SYS___SIGWAIT = 330;  // { int __sigwait(user_addr_t set, user_addr_t sig); }
+	SYS___DISABLE_THREADSIGNAL = 331;  // { int __disable_threadsignal(int value); }
+	SYS___PTHREAD_MARKCANCEL = 332;  // { int __pthread_markcancel(int thread_port); }
+	SYS___PTHREAD_CANCELED = 333;  // { int __pthread_canceled(int  action); }
+	SYS___SEMWAIT_SIGNAL = 334;  // { int __semwait_signal(int cond_sem, int mutex_sem, int timeout, int relative, time_t tv_sec, int32_t tv_nsec); }
+	// SYS_NOSYS = 335;  // { int nosys(void); }   { old utrace }
+	SYS_PROC_INFO = 336;  // { int proc_info(int32_t callnum,int32_t pid,uint32_t flavor, uint64_t arg,user_addr_t buffer,int32_t buffersize) NO_SYSCALL_STUB; }
+	SYS_SENDFILE = 337;  // { int sendfile(int fd, int s, off_t offset, off_t *nbytes, struct sf_hdtr *hdtr, int flags); }
+	// SYS_NOSYS = 337;  // { int nosys(void); }
+	SYS_STAT64 = 338;  // { int stat64(user_addr_t path, user_addr_t ub); }
+	SYS_FSTAT64 = 339;  // { int fstat64(int fd, user_addr_t ub); }
+	SYS_LSTAT64 = 340;  // { int lstat64(user_addr_t path, user_addr_t ub); }
+	SYS_STAT64_EXTENDED = 341;  // { int stat64_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_LSTAT64_EXTENDED = 342;  // { int lstat64_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_FSTAT64_EXTENDED = 343;  // { int fstat64_extended(int fd, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_GETDIRENTRIES64 = 344;  // { user_ssize_t getdirentries64(int fd, void *buf, user_size_t bufsize, off_t *position) NO_SYSCALL_STUB; }
+	SYS_STATFS64 = 345;  // { int statfs64(char *path, struct statfs64 *buf); }
+	SYS_FSTATFS64 = 346;  // { int fstatfs64(int fd, struct statfs64 *buf); }
+	SYS_GETFSSTAT64 = 347;  // { int getfsstat64(user_addr_t buf, int bufsize, int flags); }
+	SYS___PTHREAD_CHDIR = 348;  // { int __pthread_chdir(user_addr_t path); }
+	SYS___PTHREAD_FCHDIR = 349;  // { int __pthread_fchdir(int fd); }
+	SYS_AUDIT = 350;  // { int audit(void *record, int length); }
+	SYS_AUDITON = 351;  // { int auditon(int cmd, void *data, int length); }
+	// SYS_NOSYS = 352;  // { int nosys(void); }
+	SYS_GETAUID = 353;  // { int getauid(au_id_t *auid); }
+	SYS_SETAUID = 354;  // { int setauid(au_id_t *auid); }
+	SYS_GETAUDIT = 355;  // { int getaudit(struct auditinfo *auditinfo); }
+	SYS_SETAUDIT = 356;  // { int setaudit(struct auditinfo *auditinfo); }
+	SYS_GETAUDIT_ADDR = 357;  // { int getaudit_addr(struct auditinfo_addr *auditinfo_addr, int length); }
+	SYS_SETAUDIT_ADDR = 358;  // { int setaudit_addr(struct auditinfo_addr *auditinfo_addr, int length); }
+	SYS_AUDITCTL = 359;  // { int auditctl(char *path); }
+	// SYS_NOSYS = 350;  // { int nosys(void); }
+	// SYS_NOSYS = 351;  // { int nosys(void); }
+	// SYS_NOSYS = 352;  // { int nosys(void); }
+	// SYS_NOSYS = 353;  // { int nosys(void); }
+	// SYS_NOSYS = 354;  // { int nosys(void); }
+	// SYS_NOSYS = 355;  // { int nosys(void); }
+	// SYS_NOSYS = 356;  // { int nosys(void); }
+	// SYS_NOSYS = 357;  // { int nosys(void); }
+	// SYS_NOSYS = 358;  // { int nosys(void); }
+	// SYS_NOSYS = 359;  // { int nosys(void); }
+	SYS_BSDTHREAD_CREATE = 360;  // { user_addr_t bsdthread_create(user_addr_t func, user_addr_t func_arg, user_addr_t stack, user_addr_t pthread, uint32_t flags) NO_SYSCALL_STUB; }
+	SYS_BSDTHREAD_TERMINATE = 361;  // { int bsdthread_terminate(user_addr_t stackaddr, size_t freesize, uint32_t port, uint32_t sem) NO_SYSCALL_STUB; }
+	SYS_KQUEUE = 362;  // { int kqueue(void); }
+	SYS_KEVENT = 363;  // { int kevent(int fd, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout); }
+	SYS_LCHOWN = 364;  // { int lchown(user_addr_t path, uid_t owner, gid_t group); }
+	SYS_STACK_SNAPSHOT = 365;  // { int stack_snapshot(pid_t pid, user_addr_t tracebuf, uint32_t tracebuf_size, uint32_t options) NO_SYSCALL_STUB; }
+	SYS_BSDTHREAD_REGISTER = 366;  // { int bsdthread_register(user_addr_t threadstart, user_addr_t wqthread, int pthsize) NO_SYSCALL_STUB; }
+	SYS_WORKQ_OPEN = 367;  // { int workq_open(void) NO_SYSCALL_STUB; }
+	SYS_WORKQ_OPS = 368;  // { int workq_ops(int options, user_addr_t item, int prio) NO_SYSCALL_STUB; }
+	// SYS_NOSYS = 369;  // { int nosys(void); }
+	// SYS_NOSYS = 370;  // { int nosys(void); }
+	// SYS_NOSYS = 371;  // { int nosys(void); }
+	// SYS_NOSYS = 372;  // { int nosys(void); }
+	// SYS_NOSYS = 373;  // { int nosys(void); }
+	// SYS_NOSYS = 374;  // { int nosys(void); }
+	// SYS_NOSYS = 375;  // { int nosys(void); }
+	// SYS_NOSYS = 376;  // { int nosys(void); }
+	// SYS_NOSYS = 377;  // { int nosys(void); }
+	// SYS_NOSYS = 378;  // { int nosys(void); }
+	// SYS_NOSYS = 379;  // { int nosys(void); }
+	SYS___MAC_EXECVE = 380;  // { int __mac_execve(char *fname, char **argp, char **envp, struct mac *mac_p); }
+	SYS___MAC_SYSCALL = 381;  // { int __mac_syscall(char *policy, int call, user_addr_t arg); }
+	SYS___MAC_GET_FILE = 382;  // { int __mac_get_file(char *path_p, struct mac *mac_p); }
+	SYS___MAC_SET_FILE = 383;  // { int __mac_set_file(char *path_p, struct mac *mac_p); }
+	SYS___MAC_GET_LINK = 384;  // { int __mac_get_link(char *path_p, struct mac *mac_p); }
+	SYS___MAC_SET_LINK = 385;  // { int __mac_set_link(char *path_p, struct mac *mac_p); }
+	SYS___MAC_GET_PROC = 386;  // { int __mac_get_proc(struct mac *mac_p); }
+	SYS___MAC_SET_PROC = 387;  // { int __mac_set_proc(struct mac *mac_p); }
+	SYS___MAC_GET_FD = 388;  // { int __mac_get_fd(int fd, struct mac *mac_p); }
+	SYS___MAC_SET_FD = 389;  // { int __mac_set_fd(int fd, struct mac *mac_p); }
+	SYS___MAC_GET_PID = 390;  // { int __mac_get_pid(pid_t pid, struct mac *mac_p); }
+	SYS___MAC_GET_LCID = 391;  // { int __mac_get_lcid(pid_t lcid, struct mac *mac_p); }
+	SYS___MAC_GET_LCTX = 392;  // { int __mac_get_lctx(struct mac *mac_p); }
+	SYS___MAC_SET_LCTX = 393;  // { int __mac_set_lctx(struct mac *mac_p); }
+	SYS_SETLCID = 394;  // { int setlcid(pid_t pid, pid_t lcid) NO_SYSCALL_STUB; }
+	SYS_GETLCID = 395;  // { int getlcid(pid_t pid) NO_SYSCALL_STUB; }
+	SYS_READ_NOCANCEL = 396;  // { user_ssize_t read_nocancel(int fd, user_addr_t cbuf, user_size_t nbyte) NO_SYSCALL_STUB; }
+	SYS_WRITE_NOCANCEL = 397;  // { user_ssize_t write_nocancel(int fd, user_addr_t cbuf, user_size_t nbyte) NO_SYSCALL_STUB; }
+	SYS_OPEN_NOCANCEL = 398;  // { int open_nocancel(user_addr_t path, int flags, int mode) NO_SYSCALL_STUB; }
+	SYS_CLOSE_NOCANCEL = 399;  // { int close_nocancel(int fd) NO_SYSCALL_STUB; }
+	SYS_WAIT4_NOCANCEL = 400;  // { int wait4_nocancel(int pid, user_addr_t status, int options, user_addr_t rusage) NO_SYSCALL_STUB; }
+	SYS_RECVMSG_NOCANCEL = 401;  // { int recvmsg_nocancel(int s, struct msghdr *msg, int flags) NO_SYSCALL_STUB; }
+	SYS_SENDMSG_NOCANCEL = 402;  // { int sendmsg_nocancel(int s, caddr_t msg, int flags) NO_SYSCALL_STUB; }
+	SYS_RECVFROM_NOCANCEL = 403;  // { int recvfrom_nocancel(int s, void *buf, size_t len, int flags, struct sockaddr *from, int *fromlenaddr) NO_SYSCALL_STUB; }
+	SYS_ACCEPT_NOCANCEL = 404;  // { int accept_nocancel(int s, caddr_t name, socklen_t	*anamelen) NO_SYSCALL_STUB; }
+	// SYS_NOSYS = 401;  // { int nosys(void); }
+	// SYS_NOSYS = 402;  // { int nosys(void); }
+	// SYS_NOSYS = 403;  // { int nosys(void); }
+	// SYS_NOSYS = 404;  // { int nosys(void); }
+	SYS_MSYNC_NOCANCEL = 405;  // { int msync_nocancel(caddr_t addr, size_t len, int flags) NO_SYSCALL_STUB; }
+	SYS_FCNTL_NOCANCEL = 406;  // { int fcntl_nocancel(int fd, int cmd, long arg) NO_SYSCALL_STUB; }
+	SYS_SELECT_NOCANCEL = 407;  // { int select_nocancel(int nd, u_int32_t *in, u_int32_t *ou, u_int32_t *ex, struct timeval *tv) NO_SYSCALL_STUB; }
+	SYS_FSYNC_NOCANCEL = 408;  // { int fsync_nocancel(int fd) NO_SYSCALL_STUB; }
+	SYS_CONNECT_NOCANCEL = 409;  // { int connect_nocancel(int s, caddr_t name, socklen_t namelen) NO_SYSCALL_STUB; }
+	// SYS_NOSYS = 409;  // { int nosys(void); }
+	SYS_SIGSUSPEND_NOCANCEL = 410;  // { int sigsuspend_nocancel(sigset_t mask) NO_SYSCALL_STUB; }
+	SYS_READV_NOCANCEL = 411;  // { user_ssize_t readv_nocancel(int fd, struct iovec *iovp, u_int iovcnt) NO_SYSCALL_STUB; }
+	SYS_WRITEV_NOCANCEL = 412;  // { user_ssize_t writev_nocancel(int fd, struct iovec *iovp, u_int iovcnt) NO_SYSCALL_STUB; }
+	SYS_SENDTO_NOCANCEL = 413;  // { int sendto_nocancel(int s, caddr_t buf, size_t len, int flags, caddr_t to, socklen_t tolen) NO_SYSCALL_STUB; }
+	// SYS_NOSYS = 413;  // { int nosys(void); }
+	SYS_PREAD_NOCANCEL = 414;  // { user_ssize_t pread_nocancel(int fd, user_addr_t buf, user_size_t nbyte, off_t offset) NO_SYSCALL_STUB; }
+	SYS_PWRITE_NOCANCEL = 415;  // { user_ssize_t pwrite_nocancel(int fd, user_addr_t buf, user_size_t nbyte, off_t offset) NO_SYSCALL_STUB; }
+	SYS_WAITID_NOCANCEL = 416;  // { int waitid_nocancel(idtype_t idtype, id_t id, siginfo_t *infop, int options) NO_SYSCALL_STUB; }
+	SYS_POLL_NOCANCEL = 417;  // { int poll_nocancel(struct pollfd *fds, u_int nfds, int timeout) NO_SYSCALL_STUB; }
+	SYS_MSGSND_NOCANCEL = 418;  // { int msgsnd_nocancel(int msqid, void *msgp, size_t msgsz, int msgflg) NO_SYSCALL_STUB; }
+	SYS_MSGRCV_NOCANCEL = 419;  // { user_ssize_t msgrcv_nocancel(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg) NO_SYSCALL_STUB; }
+	// SYS_NOSYS = 418;  // { int nosys(void); }
+	// SYS_NOSYS = 419;  // { int nosys(void); }
+	SYS_SEM_WAIT_NOCANCEL = 420;  // { int sem_wait_nocancel(sem_t *sem) NO_SYSCALL_STUB; }
+	SYS_AIO_SUSPEND_NOCANCEL = 421;  // { int aio_suspend_nocancel(user_addr_t aiocblist, int nent, user_addr_t timeoutp) NO_SYSCALL_STUB; }
+	SYS___SIGWAIT_NOCANCEL = 422;  // { int __sigwait_nocancel(user_addr_t set, user_addr_t sig) NO_SYSCALL_STUB; }
+	SYS___SEMWAIT_SIGNAL_NOCANCEL = 423;  // { int __semwait_signal_nocancel(int cond_sem, int mutex_sem, int timeout, int relative, time_t tv_sec, int32_t tv_nsec) NO_SYSCALL_STUB; }
+	SYS___MAC_MOUNT = 424;  // { int __mac_mount(char *type, char *path, int flags, caddr_t data, struct mac *mac_p); }
+	SYS___MAC_GET_MOUNT = 425;  // { int __mac_get_mount(char *path, struct mac *mac_p); }
+	SYS___MAC_GETFSSTAT = 426;  // { int __mac_getfsstat(user_addr_t buf, int bufsize, user_addr_t mac, int macsize, int flags); }
+)
diff --git a/src/lib/syscall/syscall_amd64_linux.go b/src/lib/syscall/syscall_amd64_linux.go
new file mode 100644
index 0000000000..1e1f498dd4
--- /dev/null
+++ b/src/lib/syscall/syscall_amd64_linux.go
@@ -0,0 +1,297 @@
+// Copyright 2009 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Generated by mklinux; DO NOT EDIT.
+// mklinux /usr/include/asm/unistd_64.h
+
+package syscall
+
+export const(
+	SYS_READ = 0;
+	SYS_WRITE = 1;
+	SYS_OPEN = 2;
+	SYS_CLOSE = 3;
+	SYS_STAT = 4;
+	SYS_FSTAT = 5;
+	SYS_LSTAT = 6;
+	SYS_POLL = 7;
+	SYS_LSEEK = 8;
+	SYS_MMAP = 9;
+	SYS_MPROTECT = 10;
+	SYS_MUNMAP = 11;
+	SYS_BRK = 12;
+	SYS_RT_SIGACTION = 13;
+	SYS_RT_SIGPROCMASK = 14;
+	SYS_RT_SIGRETURN = 15;
+	SYS_IOCTL = 16;
+	SYS_PREAD64 = 17;
+	SYS_PWRITE64 = 18;
+	SYS_READV = 19;
+	SYS_WRITEV = 20;
+	SYS_ACCESS = 21;
+	SYS_PIPE = 22;
+	SYS_SELECT = 23;
+	SYS_SCHED_YIELD = 24;
+	SYS_MREMAP = 25;
+	SYS_MSYNC = 26;
+	SYS_MINCORE = 27;
+	SYS_MADVISE = 28;
+	SYS_SHMGET = 29;
+	SYS_SHMAT = 30;
+	SYS_SHMCTL = 31;
+	SYS_DUP = 32;
+	SYS_DUP2 = 33;
+	SYS_PAUSE = 34;
+	SYS_NANOSLEEP = 35;
+	SYS_GETITIMER = 36;
+	SYS_ALARM = 37;
+	SYS_SETITIMER = 38;
+	SYS_GETPID = 39;
+	SYS_SENDFILE = 40;
+	SYS_SOCKET = 41;
+	SYS_CONNECT = 42;
+	SYS_ACCEPT = 43;
+	SYS_SENDTO = 44;
+	SYS_RECVFROM = 45;
+	SYS_SENDMSG = 46;
+	SYS_RECVMSG = 47;
+	SYS_SHUTDOWN = 48;
+	SYS_BIND = 49;
+	SYS_LISTEN = 50;
+	SYS_GETSOCKNAME = 51;
+	SYS_GETPEERNAME = 52;
+	SYS_SOCKETPAIR = 53;
+	SYS_SETSOCKOPT = 54;
+	SYS_GETSOCKOPT = 55;
+	SYS_CLONE = 56;
+	SYS_FORK = 57;
+	SYS_VFORK = 58;
+	SYS_EXECVE = 59;
+	SYS_EXIT = 60;
+	SYS_WAIT4 = 61;
+	SYS_KILL = 62;
+	SYS_UNAME = 63;
+	SYS_SEMGET = 64;
+	SYS_SEMOP = 65;
+	SYS_SEMCTL = 66;
+	SYS_SHMDT = 67;
+	SYS_MSGGET = 68;
+	SYS_MSGSND = 69;
+	SYS_MSGRCV = 70;
+	SYS_MSGCTL = 71;
+	SYS_FCNTL = 72;
+	SYS_FLOCK = 73;
+	SYS_FSYNC = 74;
+	SYS_FDATASYNC = 75;
+	SYS_TRUNCATE = 76;
+	SYS_FTRUNCATE = 77;
+	SYS_GETDENTS = 78;
+	SYS_GETCWD = 79;
+	SYS_CHDIR = 80;
+	SYS_FCHDIR = 81;
+	SYS_RENAME = 82;
+	SYS_MKDIR = 83;
+	SYS_RMDIR = 84;
+	SYS_CREAT = 85;
+	SYS_LINK = 86;
+	SYS_UNLINK = 87;
+	SYS_SYMLINK = 88;
+	SYS_READLINK = 89;
+	SYS_CHMOD = 90;
+	SYS_FCHMOD = 91;
+	SYS_CHOWN = 92;
+	SYS_FCHOWN = 93;
+	SYS_LCHOWN = 94;
+	SYS_UMASK = 95;
+	SYS_GETTIMEOFDAY = 96;
+	SYS_GETRLIMIT = 97;
+	SYS_GETRUSAGE = 98;
+	SYS_SYSINFO = 99;
+	SYS_TIMES = 100;
+	SYS_PTRACE = 101;
+	SYS_GETUID = 102;
+	SYS_SYSLOG = 103;
+	SYS_GETGID = 104;
+	SYS_SETUID = 105;
+	SYS_SETGID = 106;
+	SYS_GETEUID = 107;
+	SYS_GETEGID = 108;
+	SYS_SETPGID = 109;
+	SYS_GETPPID = 110;
+	SYS_GETPGRP = 111;
+	SYS_SETSID = 112;
+	SYS_SETREUID = 113;
+	SYS_SETREGID = 114;
+	SYS_GETGROUPS = 115;
+	SYS_SETGROUPS = 116;
+	SYS_SETRESUID = 117;
+	SYS_GETRESUID = 118;
+	SYS_SETRESGID = 119;
+	SYS_GETRESGID = 120;
+	SYS_GETPGID = 121;
+	SYS_SETFSUID = 122;
+	SYS_SETFSGID = 123;
+	SYS_GETSID = 124;
+	SYS_CAPGET = 125;
+	SYS_CAPSET = 126;
+	SYS_RT_SIGPENDING = 127;
+	SYS_RT_SIGTIMEDWAIT = 128;
+	SYS_RT_SIGQUEUEINFO = 129;
+	SYS_RT_SIGSUSPEND = 130;
+	SYS_SIGALTSTACK = 131;
+	SYS_UTIME = 132;
+	SYS_MKNOD = 133;
+	SYS_USELIB = 134;
+	SYS_PERSONALITY = 135;
+	SYS_USTAT = 136;
+	SYS_STATFS = 137;
+	SYS_FSTATFS = 138;
+	SYS_SYSFS = 139;
+	SYS_GETPRIORITY = 140;
+	SYS_SETPRIORITY = 141;
+	SYS_SCHED_SETPARAM = 142;
+	SYS_SCHED_GETPARAM = 143;
+	SYS_SCHED_SETSCHEDULER = 144;
+	SYS_SCHED_GETSCHEDULER = 145;
+	SYS_SCHED_GET_PRIORITY_MAX = 146;
+	SYS_SCHED_GET_PRIORITY_MIN = 147;
+	SYS_SCHED_RR_GET_INTERVAL = 148;
+	SYS_MLOCK = 149;
+	SYS_MUNLOCK = 150;
+	SYS_MLOCKALL = 151;
+	SYS_MUNLOCKALL = 152;
+	SYS_VHANGUP = 153;
+	SYS_MODIFY_LDT = 154;
+	SYS_PIVOT_ROOT = 155;
+	SYS__SYSCTL = 156;
+	SYS_PRCTL = 157;
+	SYS_ARCH_PRCTL = 158;
+	SYS_ADJTIMEX = 159;
+	SYS_SETRLIMIT = 160;
+	SYS_CHROOT = 161;
+	SYS_SYNC = 162;
+	SYS_ACCT = 163;
+	SYS_SETTIMEOFDAY = 164;
+	SYS_MOUNT = 165;
+	SYS_UMOUNT2 = 166;
+	SYS_SWAPON = 167;
+	SYS_SWAPOFF = 168;
+	SYS_REBOOT = 169;
+	SYS_SETHOSTNAME = 170;
+	SYS_SETDOMAINNAME = 171;
+	SYS_IOPL = 172;
+	SYS_IOPERM = 173;
+	SYS_CREATE_MODULE = 174;
+	SYS_INIT_MODULE = 175;
+	SYS_DELETE_MODULE = 176;
+	SYS_GET_KERNEL_SYMS = 177;
+	SYS_QUERY_MODULE = 178;
+	SYS_QUOTACTL = 179;
+	SYS_NFSSERVCTL = 180;
+	SYS_GETPMSG = 181;
+	SYS_PUTPMSG = 182;
+	SYS_AFS_SYSCALL = 183;
+	SYS_TUXCALL = 184;
+	SYS_SECURITY = 185;
+	SYS_GETTID = 186;
+	SYS_READAHEAD = 187;
+	SYS_SETXATTR = 188;
+	SYS_LSETXATTR = 189;
+	SYS_FSETXATTR = 190;
+	SYS_GETXATTR = 191;
+	SYS_LGETXATTR = 192;
+	SYS_FGETXATTR = 193;
+	SYS_LISTXATTR = 194;
+	SYS_LLISTXATTR = 195;
+	SYS_FLISTXATTR = 196;
+	SYS_REMOVEXATTR = 197;
+	SYS_LREMOVEXATTR = 198;
+	SYS_FREMOVEXATTR = 199;
+	SYS_TKILL = 200;
+	SYS_TIME = 201;
+	SYS_FUTEX = 202;
+	SYS_SCHED_SETAFFINITY = 203;
+	SYS_SCHED_GETAFFINITY = 204;
+	SYS_SET_THREAD_AREA = 205;
+	SYS_IO_SETUP = 206;
+	SYS_IO_DESTROY = 207;
+	SYS_IO_GETEVENTS = 208;
+	SYS_IO_SUBMIT = 209;
+	SYS_IO_CANCEL = 210;
+	SYS_GET_THREAD_AREA = 211;
+	SYS_LOOKUP_DCOOKIE = 212;
+	SYS_EPOLL_CREATE = 213;
+	SYS_EPOLL_CTL_OLD = 214;
+	SYS_EPOLL_WAIT_OLD = 215;
+	SYS_REMAP_FILE_PAGES = 216;
+	SYS_GETDENTS64 = 217;
+	SYS_SET_TID_ADDRESS = 218;
+	SYS_RESTART_SYSCALL = 219;
+	SYS_SEMTIMEDOP = 220;
+	SYS_FADVISE64 = 221;
+	SYS_TIMER_CREATE = 222;
+	SYS_TIMER_SETTIME = 223;
+	SYS_TIMER_GETTIME = 224;
+	SYS_TIMER_GETOVERRUN = 225;
+	SYS_TIMER_DELETE = 226;
+	SYS_CLOCK_SETTIME = 227;
+	SYS_CLOCK_GETTIME = 228;
+	SYS_CLOCK_GETRES = 229;
+	SYS_CLOCK_NANOSLEEP = 230;
+	SYS_EXIT_GROUP = 231;
+	SYS_EPOLL_WAIT = 232;
+	SYS_EPOLL_CTL = 233;
+	SYS_TGKILL = 234;
+	SYS_UTIMES = 235;
+	SYS_VSERVER = 236;
+	SYS_MBIND = 237;
+	SYS_SET_MEMPOLICY = 238;
+	SYS_GET_MEMPOLICY = 239;
+	SYS_MQ_OPEN = 240;
+	SYS_MQ_UNLINK = 241;
+	SYS_MQ_TIMEDSEND = 242;
+	SYS_MQ_TIMEDRECEIVE = 243;
+	SYS_MQ_NOTIFY = 244;
+	SYS_MQ_GETSETATTR = 245;
+	SYS_KEXEC_LOAD = 246;
+	SYS_WAITID = 247;
+	SYS_ADD_KEY = 248;
+	SYS_REQUEST_KEY = 249;
+	SYS_KEYCTL = 250;
+	SYS_IOPRIO_SET = 251;
+	SYS_IOPRIO_GET = 252;
+	SYS_INOTIFY_INIT = 253;
+	SYS_INOTIFY_ADD_WATCH = 254;
+	SYS_INOTIFY_RM_WATCH = 255;
+	SYS_MIGRATE_PAGES = 256;
+	SYS_OPENAT = 257;
+	SYS_MKDIRAT = 258;
+	SYS_MKNODAT = 259;
+	SYS_FCHOWNAT = 260;
+	SYS_FUTIMESAT = 261;
+	SYS_NEWFSTATAT = 262;
+	SYS_UNLINKAT = 263;
+	SYS_RENAMEAT = 264;
+	SYS_LINKAT = 265;
+	SYS_SYMLINKAT = 266;
+	SYS_READLINKAT = 267;
+	SYS_FCHMODAT = 268;
+	SYS_FACCESSAT = 269;
+	SYS_PSELECT6 = 270;
+	SYS_PPOLL = 271;
+	SYS_UNSHARE = 272;
+	SYS_SET_ROBUST_LIST = 273;
+	SYS_GET_ROBUST_LIST = 274;
+	SYS_SPLICE = 275;
+	SYS_TEE = 276;
+	SYS_SYNC_FILE_RANGE = 277;
+	SYS_VMSPLICE = 278;
+	SYS_MOVE_PAGES = 279;
+	SYS_UTIMENSAT = 280;
+	SYS_EPOLL_PWAIT = 281;
+	SYS_SIGNALFD = 282;
+	SYS_TIMERFD = 283;
+	SYS_EVENTFD = 284;
+	SYS_FALLOCATE = 285;
+)
diff --git a/src/syscall/time_amd64_darwin.go b/src/lib/syscall/time_amd64_darwin.go
similarity index 84%
rename from src/syscall/time_amd64_darwin.go
rename to src/lib/syscall/time_amd64_darwin.go
index 4bcbe249f6..011933b4f3 100644
--- a/src/syscall/time_amd64_darwin.go
+++ b/src/lib/syscall/time_amd64_darwin.go
@@ -7,11 +7,10 @@ package syscall
 import syscall "syscall"
 
 export func gettimeofday() (sec, nsec, errno int64) {
-	const GETTIMEOFDAY = 116;
 	// The "1" in the call is the timeval pointer, which must be
 	// non-zero but is otherwise unused.  The results
 	// are returned in r1, r2.
-	r1, r2, err := syscall.Syscall(GETTIMEOFDAY, 1, 0, 0);
+	r1, r2, err := Syscall(SYS_GETTIMEOFDAY, 1, 0, 0);
 	if err != 0 {
 		return 0, 0, err
 	}
diff --git a/src/syscall/time_amd64_linux.go b/src/lib/syscall/time_amd64_linux.go
similarity index 53%
rename from src/syscall/time_amd64_linux.go
rename to src/lib/syscall/time_amd64_linux.go
index 71bd5658be..43b050119e 100644
--- a/src/syscall/time_amd64_linux.go
+++ b/src/lib/syscall/time_amd64_linux.go
@@ -6,14 +6,11 @@ package syscall
 
 import syscall "syscall"
 
-func	Int64Ptr(s *int64) int64;
-
 export func gettimeofday() (sec, nsec, errno int64) {
-	const GETTIMEOFDAY = 96
-	var tv [2]int64;	// struct timeval
-	r1, r2, err := syscall.Syscall(GETTIMEOFDAY, Int64Ptr(&tv[0]), 0, 0);
-	if err != 0 {
-		return 0, 0, err
+	var tv Timeval;
+	r1, r2, e := Syscall(SYS_GETTIMEOFDAY, TimevalPtr(&tv), 0, 0);
+	if e != 0 {
+		return 0, 0, e
 	}
-	return tv[0], tv[1]*1000, 0
+	return int64(tv.sec), int64(tv.usec*1000), 0
 }
diff --git a/src/lib/syscall/types_amd64_darwin.go b/src/lib/syscall/types_amd64_darwin.go
new file mode 100644
index 0000000000..bb715ccb16
--- /dev/null
+++ b/src/lib/syscall/types_amd64_darwin.go
@@ -0,0 +1,191 @@
+// Copyright 2009 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Types and defined constants.
+// Should be automatically generated, but is not.
+
+package syscall
+
+
+// Time
+
+export type Timespec struct {
+	sec	int64;
+	nsec	uint64;
+}
+export func TimespecPtr(t *Timespec) int64;
+
+export type Timeval struct {
+	sec	int64;
+	usec	uint32;
+}
+export func TimevalPtr(t *Timeval) int64;
+
+
+// Files
+
+export const (
+	O_RDONLY = 0x0;
+	O_WRONLY = 0x1;
+	O_RDWR = 0x2;
+	O_APPEND = 0x8;
+	O_ASYNC = 0x40;
+	O_CREAT = 0x200;
+	O_NOCTTY = 0x20000;
+	O_NONBLOCK = 0x4;
+	O_NDELAY = O_NONBLOCK;
+	O_SYNC = 0x80;
+	O_TRUNC = 0x400;
+
+	F_GETFL = 3;
+	F_SETFL = 4;
+)
+
+export type Stat struct {
+	dev	uint32;
+	mode	uint16;
+	nlink	uint16;
+	ino	uint64;
+	uid	uint32;
+	gid	uint32;
+	rdev	uint32;
+	pad1	uint32;
+	atime Timespec;
+	mtime Timespec;
+	ctime Timespec;
+	birthtime Timespec;
+	size uint64;
+	blocks uint64;
+	blksize uint32;
+	flags uint32;
+	gen uint32;
+	lspare uint32;
+	qspare [2]uint64;
+}
+export func StatPtr(s *Stat) int64;
+
+
+// Sockets
+
+export const (
+	AF_UNIX = 1;
+	AF_INET = 2;
+	AF_DATAKIT = 9;
+	AF_INET6 = 30;
+
+	SOCK_STREAM = 1;
+	SOCK_DGRAM = 2;
+	SOCK_RAW = 3;
+	SOCK_RDM = 4;
+	SOCK_SEQPACKET = 5;
+
+	SOL_SOCKET = 0xffff;
+
+	SO_REUSEADDR = 0x0004;
+	SO_KEEPALIVE = 0x0008;
+	SO_DONTROUTE = 0x0010;
+	SO_BROADCAST = 0x0020;
+	SO_USELOOPBACK = 0x0040;
+	SO_LINGER = 0x1080;
+	SO_REUSEPORT = 0x0200;
+	SO_SNDBUF = 0x1001;
+	SO_RCVBUF = 0x1002;
+	SO_SNDTIMEO = 0x1005;
+	SO_RCVTIMEO = 0x1006;
+	SO_NOSIGPIPE = 0x1022;
+
+	IPPROTO_TCP = 6;
+	IPPROTO_UDP = 17;
+
+	TCP_NODELAY = 0x01;
+
+	SOMAXCONN = 128;
+)
+
+export type SockaddrUnix struct {
+	len	byte;
+	family	byte;
+	path	[104]byte
+}
+export const SizeofSockaddrUnix = 106
+
+export type SockaddrInet4 struct {
+	len	byte;
+	family	byte;
+	port	[2]byte;
+	addr	[4]byte;
+	zero	[8]byte
+}
+export const SizeofSockaddrInet4 = 16
+
+export type SockaddrInet6 struct {
+	len	byte;
+	family	byte;
+	port	[2]byte;
+	flowinfo	[4]byte;
+	addr	[16]byte;
+	scopeid	[4]byte;
+}
+export const SizeofSockaddrInet6 = 28
+
+export type Sockaddr struct {
+	len	byte;
+	family	byte;
+	opaque	[126]byte
+}
+export const SizeofSockaddr = 128
+export func SockaddrPtr(s *Sockaddr) int64;
+
+export type Linger struct {
+	yes int32;
+	sec int32;
+}
+export func LingerPtr(l *Linger) int64;
+
+
+// Events (kqueue, kevent)
+
+export const (
+	// filters
+	EVFILT_READ = -1;
+	EVFILT_WRITE = -2;
+	EVFILT_AIO = -3;
+	EVFILT_VNODE = -4;
+	EVFILT_PROC = -5;
+	EVFILT_SIGNAL = -6;
+	EVFILT_TIMER = -7;
+	EVFILT_MACHPORT = -8;
+	EVFILT_FS = -9;
+
+	EVFILT_SYSCOUNT = 9;
+
+	// actions
+	EV_ADD = 0x0001;
+	EV_DELETE = 0x0002;
+	EV_DISABLE = 0x0008;
+	EV_RECEIPT = 0x0040;
+
+	// flags
+	EV_ONESHOT = 0x0010;
+	EV_CLEAR = 0x0020;
+	EV_RECEIPT = 0x40;
+	EV_SYSFLAGS = 0xF000;
+	EV_FLAG0 = 0x1000;
+	EV_FLAG1 = 0x2000;
+
+	// returned values
+	EV_EOF = 0x8000;
+	EV_ERROR = 0x4000
+)
+
+export type Kevent struct {
+	ident int64;
+	filter int16;
+	flags uint16;
+	fflags uint32;
+	data int64;
+	udata int64;
+}
+export func KeventPtr(e *Kevent) int64;
+
diff --git a/src/lib/syscall/types_amd64_linux.go b/src/lib/syscall/types_amd64_linux.go
new file mode 100644
index 0000000000..7de141923d
--- /dev/null
+++ b/src/lib/syscall/types_amd64_linux.go
@@ -0,0 +1,149 @@
+// Copyright 2009 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Types and defined constants.
+// Should be automatically generated, but is not.
+
+package syscall
+
+
+// Time
+
+export type Timespec struct {
+	sec	int64;
+	nsec	uint64;
+}
+export func TimespecPtr(t *Timespec) int64;
+
+export type Timeval struct {
+	sec	int64;
+	usec	uint64;
+}
+export func TimevalPtr(t *Timeval) int64;
+
+
+// Files
+
+export const (
+	O_RDONLY = 0x0;
+	O_WRONLY = 0x1;
+	O_RDWR = 0x2;
+	O_APPEND = 0x400;
+	O_ASYNC = 0x2000;
+	O_CREAT = 0x40;
+	O_NOCTTY = 0x100;
+	O_NONBLOCK = 0x800;
+	O_NDELAY = O_NONBLOCK;
+	O_SYNC = 0x1000;
+	O_TRUNC = 0x200;
+)
+
+export type Stat struct {
+	dev	uint64;
+	ino	uint64;
+	nlink	uint64;
+	mode	uint32;
+	uid	uint32;
+	gid	uint32;
+	_pad0	uint32;
+	rdev	uint64;
+	size	int64;
+	blksize	int64;
+	blocks	int64;
+	atime	Timespec;
+	mtime	Timespec;
+	ctime	Timespec;
+	_unused	[3]int64
+}
+export func StatPtr(s *Stat) int64;
+
+
+// Sockets
+
+export const (
+	AF_UNIX = 1;
+	AF_INET = 2;
+	AF_INET6 = 10;
+
+	SOCK_STREAM = 1;
+	SOCK_DGRAM = 2;
+	SOCK_RAW = 3;
+	SOCK_RDM = 4;
+	SOCK_SEQPACKET = 5;
+
+	SOL_SOCKET = 1;
+
+	SO_DEBUG = 1;
+	SO_REUSEADDR = 2;
+	SO_TYPE = 3;
+	SO_ERROR = 4;
+	SO_DONTROUTE = 5;
+	SO_BROADCAST = 6;
+	SO_SNDBUF = 7;
+	SO_RCVBUF = 8;
+	SO_SNDBUFFORCE = 32;
+	SO_RCVBUFFORCE = 33;
+	SO_KEEPALIVE = 9;
+	SO_OOBINLINE = 10;
+	SO_NO_CHECK = 11;
+	SO_PRIORITY = 12;
+	SO_LINGER = 13;
+	SO_BSDCOMPAT = 14;
+	SO_PASSCRED = 16;
+	SO_PEERCRED = 17;
+	SO_RCVLOWAT = 18;
+	SO_SNDLOWAT = 19;
+	SO_RCVTIMEO = 20;
+	SO_SNDTIMEO = 21;
+	SO_BINDTODEVICE = 25;
+
+	IPPROTO_TCP = 6;
+	IPPROTO_UDP = 17;
+
+	TCP_NODELAY = 0x01;
+
+	SOMAXCONN = 128;
+)
+
+export type SockaddrUnix struct {
+	family	uint16;
+	path	[108]byte
+}
+export const SizeofSockaddrUnix = 110
+
+export type SockaddrInet4 struct {
+	family	uint16;
+	port	[2]byte;
+	addr	[4]byte;
+	zero	[8]byte
+}
+export const SizeofSockaddrInet4 = 16
+
+export type SockaddrInet6 struct {
+	family	uint16;
+	port	[2]byte;
+	flowinfo	[4]byte;
+	addr	[16]byte;
+	scopeid	[4]byte;
+}
+export const SizeofSockaddrInet6 = 28
+
+export type Sockaddr struct {
+	family	uint16;
+	opaque	[126]byte
+}
+export const SizeofSockaddr = 128
+export func SockaddrPtr(s *Sockaddr) int64;
+
+export type Linger struct {
+	yes int32;
+	sec int32;
+}
+export func LingerPtr(l *Linger) int64;
+
+
+// Events (epoll)
+
+// TODO
+
diff --git a/src/make.bash b/src/make.bash
index 037457fb8d..3ff193145e 100755
--- a/src/make.bash
+++ b/src/make.bash
@@ -8,7 +8,7 @@ export MAKEFLAGS=-j4
 
 bash clean.bash
 
-for i in lib9 libbio libmach_amd64 libregexp cmd runtime syscall lib
+for i in lib9 libbio libmach_amd64 libregexp cmd runtime lib
 do
 	echo; echo; echo %%%% making $i %%%%; echo
 	cd $i
diff --git a/src/syscall/Makefile b/src/syscall/Makefile
deleted file mode 100644
index a34c96adf3..0000000000
--- a/src/syscall/Makefile
+++ /dev/null
@@ -1,54 +0,0 @@
-# Copyright 2009 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-CFLAGS=
-O=6
-CC=$(O)c
-AS=$(O)a
-GC=$(O)g
-
-PKG=$(GOROOT)/pkg/syscall.a
-
-O1=\
-	syscall.$O \
-	errstr_$(GOOS).$O \
-
-O2=\
-	file_$(GOARCH)_$(GOOS).$O \
-	time_$(GOARCH)_$(GOOS).$O \
-	syscall_$(GOARCH)_$(GOOS).$O \
-
-
-install: nuke $(PKG)
-
-$(PKG): a1 a2
-
-a1: 	$(O1)
-	$(O)ar grc $(PKG) $(O1)
-	rm *.6
-
-a2: 	$(O2)
-	$(O)ar grc $(PKG) $(O2)
-	rm *.6
-
-$(O1): nuke
-$(O2): a1
-
-nuke:
-	rm -f *.$(O) *.a $(PKG)
-
-clean:
-	rm -f *.$(O) *.a
-
-%.$O:	%.c
-	$(CC) $<
-
-sys_file.$O:	sys_file.c sys_types.h $(OS_H)
-	$(CC) -D$(GOARCH)_$(GOOS) $<
-
-%.$O:	%.s
-	$(AS) $<
-
-%.$O:	%.go
-	$(GC) $<
diff --git a/src/syscall/file_amd64_darwin.go b/src/syscall/file_amd64_darwin.go
deleted file mode 100644
index fcf6db0a79..0000000000
--- a/src/syscall/file_amd64_darwin.go
+++ /dev/null
@@ -1,149 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package syscall
-
-// File operations for Darwin
-
-import syscall "syscall"
-
-//export Stat
-//export stat, fstat, lstat
-//export open, creat, close, read, write, pipe
-//export unlink
-
-func	StatPtr(s *Stat) int64;
-
-type dev_t uint32;
-type ino_t uint64;
-type mode_t uint16;
-type nlink_t uint16;
-type uid_t uint32;
-type gid_t uint32;
-type off_t int64;
-type blksize_t int64;
-type blkcnt_t int64;
-type time_t int64;
-
-type Timespec struct {
-	tv_sec	time_t;
-	tv_nsec	int64;
-}
-
-export type Stat struct {
-	st_dev	dev_t;     /* ID of device containing file */
-	st_mode	mode_t;    /* protection */
-	st_nlink	nlink_t;   /* number of hard links */
-	st_ino	ino_t;     /* inode number */
-	st_uid	uid_t;     /* user ID of owner */
-	st_gid	gid_t;     /* group ID of owner */
-	st_rdev	dev_t;    /* device ID (if special file) */
-	st_atime	Timespec;   /* time of last access */
-	st_mtime	Timespec;   /* time of last modification */
-	st_ctime	Timespec;   /* time of last status change */
-	st_birthtimespec	Timespec;   /* birth time */
-	st_size	off_t;    /* total size, in bytes */
-	st_blocks	blkcnt_t;  /* number of blocks allocated */
-	st_blksize	blksize_t; /* blocksize for filesystem I/O */
-	st_flags	uint32;
-	st_gen		uint32;
- 	st_qspare[2]	int64;
-}
-
-export const (
-	O_RDONLY = 0x0;
-	O_WRONLY = 0x1;
-	O_RDWR = 0x2;
-	O_APPEND = 0x8;
-	O_ASYNC = 0x40;
-	O_CREAT = 0x200;
-	O_NOCTTY = 0x20000;
-	O_NONBLOCK = 0x4;
-	O_NDELAY = O_NONBLOCK;
-	O_SYNC = 0x80;
-	O_TRUNC = 0x400;
-)
-
-const NameBufsize = 512
-
-export func open(name string, mode int64, perm int64) (ret int64, errno int64) {
-	var namebuf [NameBufsize]byte;
-	if !StringToBytes(&namebuf, name) {
-		return -1, syscall.ENAMETOOLONG
-	}
-	const SYSOPEN = 5;
-	r1, r2, err := syscall.Syscall(SYSOPEN, BytePtr(&namebuf[0]), mode, perm);
-	return r1, err;
-}
-
-export func creat(name string, perm int64) (ret int64, errno int64) {
-	var namebuf [NameBufsize]byte;
-	if !StringToBytes(&namebuf, name) {
-		return -1, syscall.ENAMETOOLONG
-	}
-	const SYSOPEN = 5;
-	r1, r2, err := syscall.Syscall(SYSOPEN, BytePtr(&namebuf[0]), O_CREAT|O_WRONLY|O_TRUNC, perm);
-	return r1, err;
-}
-
-export func close(fd int64) (ret int64, errno int64) {
-	const SYSCLOSE = 6;
-	r1, r2, err := syscall.Syscall(SYSCLOSE, fd, 0, 0);
-	return r1, err;
-}
-
-export func read(fd int64, buf *byte, nbytes int64) (ret int64, errno int64) {
-	const SYSREAD = 3;
-	r1, r2, err := syscall.Syscall(SYSREAD, fd, BytePtr(buf), nbytes);
-	return r1, err;
-}
-
-export func write(fd int64, buf *byte, nbytes int64) (ret int64, errno int64) {
-	const SYSWRITE = 4;
-	r1, r2, err := syscall.Syscall(SYSWRITE, fd, BytePtr(buf), nbytes);
-	return r1, err;
-}
-
-export func pipe(fds *[2]int64) (ret int64, errno int64) {
-	const SYSPIPE = 42;
-	r1, r2, err := syscall.Syscall(SYSPIPE, 0, 0, 0);
-	if r1 < 0 {
-		return r1, err;
-	}
-	fds[0] = r1;
-	fds[1] = r2;
-	return 0, 0;
-}
-
-export func stat(name string, buf *Stat) (ret int64, errno int64) {
-	var namebuf [NameBufsize]byte;
-	if !StringToBytes(&namebuf, name) {
-		return -1, syscall.ENAMETOOLONG
-	}
-	const SYSSTAT = 338;
-	r1, r2, err := syscall.Syscall(SYSSTAT, BytePtr(&namebuf[0]), StatPtr(buf), 0);
-	return r1, err;
-}
-
-export func lstat(name *byte, buf *Stat) (ret int64, errno int64) {
-	const SYSLSTAT = 340;
-	r1, r2, err := syscall.Syscall(SYSLSTAT, BytePtr(name), StatPtr(buf), 0);
-	return r1, err;
-}
-
-export func fstat(fd int64, buf *Stat) (ret int64, errno int64) {
-	const SYSFSTAT = 339;
-	r1, r2, err := syscall.Syscall(SYSFSTAT, fd, StatPtr(buf), 0);
-	return r1, err;
-}
-
-export func unlink(name string) (ret int64, errno int64) {
-	var namebuf [NameBufsize]byte;
-	if !StringToBytes(&namebuf, name) {
-		return -1, syscall.ENAMETOOLONG
-	}
-	const SYSUNLINK = 10;
-	r1, r2, err := syscall.Syscall(SYSUNLINK, BytePtr(&namebuf[0]), 0, 0);
-	return r1, err;
-}
diff --git a/src/syscall/file_amd64_linux.go b/src/syscall/file_amd64_linux.go
deleted file mode 100644
index 5b5d903591..0000000000
--- a/src/syscall/file_amd64_linux.go
+++ /dev/null
@@ -1,151 +0,0 @@
-// Copyright 2009 The Go Authors.  All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package syscall
-
-// File operations for Linux
-
-import syscall "syscall"
-
-//export Stat
-//export stat, fstat, lstat
-//export open, creat, close, read, write, pipe
-//export unlink
-
-func	StatPtr(s *Stat) int64;
-func	Int32Ptr(s *int32) int64;
-
-type dev_t uint64;
-type ino_t uint64;
-type mode_t uint32;
-type nlink_t uint64;
-type uid_t uint32;
-type gid_t uint32;
-type off_t int64;
-type blksize_t int64;
-type blkcnt_t int64;
-type time_t int64;
-
-type Timespec struct {
-	tv_sec	time_t;
-	tv_nsec	int64;
-}
-
-export type Stat struct {
-	st_dev	dev_t;     /* ID of device containing file */
-	st_ino	ino_t;     /* inode number */
-	st_nlink	nlink_t;   /* number of hard links */
-	st_mode	mode_t;    /* protection */
-	st_uid	uid_t;     /* user ID of owner */
-	st_gid	gid_t;     /* group ID of owner */
-	pad0	int32;
-	st_rdev	dev_t;    /* device ID (if special file) */
-	st_size	off_t;    /* total size, in bytes */
-	st_blksize	blksize_t; /* blocksize for filesystem I/O */
-	st_blocks	blkcnt_t;  /* number of blocks allocated */
-	st_atime	Timespec;   /* time of last access */
-	st_mtime	Timespec;   /* time of last modification */
-	st_ctime	Timespec;   /* time of last status change */
-	st_unused4	int64;
-	st_unused5	int64;
-	st_unused6	int64;
-}
-
-export const (
-	O_RDONLY = 0x0;
-	O_WRONLY = 0x1;
-	O_RDWR = 0x2;
-	O_APPEND = 0x400;
-	O_ASYNC = 0x2000;
-	O_CREAT = 0x40;
-	O_NOCTTY = 0x100;
-	O_NONBLOCK = 0x800;
-	O_NDELAY = O_NONBLOCK;
-	O_SYNC = 0x1000;
-	O_TRUNC = 0x200;
-)
-
-const NameBufsize = 512
-
-export func open(name string, mode int64, perm int64) (ret int64, errno int64) {
-	var namebuf [NameBufsize]byte;
-	if !StringToBytes(&namebuf, name) {
-		return -1, syscall.ENAMETOOLONG
-	}
-	const SYSOPEN = 2;
-	r1, r2, err := syscall.Syscall(SYSOPEN, BytePtr(&namebuf[0]), mode, perm);
-	return r1, err;
-}
-
-export func creat(name string, perm int64) (ret int64, errno int64) {
-	var namebuf [NameBufsize]byte;
-	if !StringToBytes(&namebuf, name) {
-		return -1, syscall.ENAMETOOLONG
-	}
-	const SYSOPEN = 2;
-	r1, r2, err := syscall.Syscall(SYSOPEN, BytePtr(&namebuf[0]),  O_CREAT|O_WRONLY|O_TRUNC, perm);
-	return r1, err;
-}
-
-export func close(fd int64) (ret int64, errno int64) {
-	const SYSCLOSE = 3;
-	r1, r2, err := syscall.Syscall(SYSCLOSE, fd, 0, 0);
-	return r1, err;
-}
-
-export func read(fd int64, buf *byte, nbytes int64) (ret int64, errno int64) {
-	const SYSREAD = 0;
-	r1, r2, err := syscall.Syscall(SYSREAD, fd, BytePtr(buf), nbytes);
-	return r1, err;
-}
-
-export func write(fd int64, buf *byte, nbytes int64) (ret int64, errno int64) {
-	const SYSWRITE = 1;
-	r1, r2, err := syscall.Syscall(SYSWRITE, fd, BytePtr(buf), nbytes);
-	return r1, err;
-}
-
-export func pipe(fds *[2]int64) (ret int64, errno int64) {
-	const SYSPIPE = 22;
-	var t [2] int32;
-	r1, r2, err := syscall.Syscall(SYSPIPE, Int32Ptr(&t[0]), 0, 0);
-	if r1 < 0 {
-		return r1, err;
-	}
-	fds[0] = int64(t[0]);
-	fds[1] = int64(t[1]);
-	return 0, 0;
-}
-
-export func stat(name string, buf *Stat) (ret int64, errno int64) {
-	var namebuf [NameBufsize]byte;
-	if !StringToBytes(&namebuf, name) {
-		return -1, syscall.ENAMETOOLONG
-	}
-	const SYSSTAT = 4;
-	r1, r2, err := syscall.Syscall(SYSSTAT, BytePtr(&namebuf[0]), StatPtr(buf), 0);
-	return r1, err;
-}
-
-export func lstat(name *byte, buf *Stat) (ret int64, errno int64) {
-	const SYSLSTAT = 6;
-	r1, r2, err := syscall.Syscall(SYSLSTAT, BytePtr(name), StatPtr(buf), 0);
-	return r1, err;
-}
-
-export func fstat(fd int64, buf *Stat) (ret int64, errno int64) {
-	const SYSFSTAT = 5;
-	r1, r2, err := syscall.Syscall(SYSFSTAT, fd, StatPtr(buf), 0);
-	return r1, err;
-}
-
-export func unlink(name string) (ret int64, errno int64) {
-	var namebuf [NameBufsize]byte;
-	if !StringToBytes(&namebuf, name) {
-		return -1, syscall.ENAMETOOLONG
-	}
-	const SYSUNLINK = 87;
-	r1, r2, err := syscall.Syscall(SYSUNLINK, BytePtr(&namebuf[0]), 0, 0);
-	return r1, err;
-}
