commit eee2697c38b73b731604d5584abd97bf674857ed
Author: Cuong Manh Le <cuong.manhle.vn@gmail.com>
Date:   Fri Feb 17 11:57:30 2023 +0700

    cmd/compile: use ONAME node directly from generated hash func
    
    This reverts CL 468879
    
    CL 469017 marked type eq/hash functions as non-inlineable, so this
    change won't cause ICE anymore.
    
    Updates #58572
    
    Change-Id: I3e6ec9ba2217102693acd1848a0eba0886dc9fda
    Reviewed-on: https://go-review.googlesource.com/c/go/+/469018
    Auto-Submit: Cuong Manh Le <cuong.manhle.vn@gmail.com>
    Reviewed-by: Bryan Mills <bcmills@google.com>
    Run-TryBot: Cuong Manh Le <cuong.manhle.vn@gmail.com>
    Reviewed-by: Matthew Dempsky <mdempsky@google.com>
    TryBot-Result: Gopher Robot <gobot@golang.org>
---
 src/cmd/compile/internal/reflectdata/alg.go | 31 ++++++++++-------------------
 1 file changed, 11 insertions(+), 20 deletions(-)

diff --git a/src/cmd/compile/internal/reflectdata/alg.go b/src/cmd/compile/internal/reflectdata/alg.go
index 9201a1999f..e793d4920d 100644
--- a/src/cmd/compile/internal/reflectdata/alg.go
+++ b/src/cmd/compile/internal/reflectdata/alg.go
@@ -134,6 +134,11 @@ func genhash(t *types.Type) *obj.LSym {
 }
 
 func hashFunc(t *types.Type) *ir.Func {
+	sym := TypeSymPrefix(".hash", t)
+	if sym.Def != nil {
+		return sym.Def.(*ir.Name).Func
+	}
+
 	base.Pos = base.AutogeneratedPos // less confusing than end of input
 	typecheck.DeclContext = ir.PEXTERN
 
@@ -144,8 +149,8 @@ func hashFunc(t *types.Type) *ir.Func {
 	}
 	results := []*ir.Field{ir.NewField(base.Pos, nil, types.Types[types.TUINTPTR])}
 
-	sym := TypeSymPrefix(".hash", t)
 	fn := typecheck.DeclFunc(sym, nil, args, results)
+	sym.Def = fn.Nname
 	np := ir.AsNode(fn.Type().Params().Field(0).Nname)
 	nh := ir.AsNode(fn.Type().Params().Field(1).Nname)
 
@@ -231,9 +236,9 @@ func hashFunc(t *types.Type) *ir.Func {
 	fn.SetDupok(true)
 	typecheck.Func(fn)
 
-	ir.CurFunc = fn
-	typecheck.Stmts(fn.Body)
-	ir.CurFunc = nil
+	ir.WithFunc(fn, func() {
+		typecheck.Stmts(fn.Body)
+	})
 
 	fn.SetNilCheckDisabled(true)
 	typecheck.Target.Decls = append(typecheck.Target.Decls, fn)
@@ -249,8 +254,6 @@ func runtimeHashFor(name string, t *types.Type) *ir.Name {
 
 // hashfor returns the function to compute the hash of a value of type t.
 func hashfor(t *types.Type) *ir.Name {
-	var sym *types.Sym
-
 	switch a, _ := types.AlgType(t); a {
 	case types.AMEM:
 		base.Fatalf("hashfor with AMEM type")
@@ -268,22 +271,10 @@ func hashfor(t *types.Type) *ir.Name {
 		return runtimeHashFor("c64hash", t)
 	case types.ACPLX128:
 		return runtimeHashFor("c128hash", t)
-	default:
-		// Note: the caller of hashfor ensured that this symbol
-		// exists and has a body by calling genhash for t.
-		sym = TypeSymPrefix(".hash", t)
 	}
 
-	// TODO(austin): This creates an ir.Name with a nil Func.
-	n := typecheck.NewName(sym)
-	ir.MarkFunc(n)
-	n.SetType(types.NewSignature(nil, []*types.Field{
-		types.NewField(base.Pos, nil, types.NewPtr(t)),
-		types.NewField(base.Pos, nil, types.Types[types.TUINTPTR]),
-	}, []*types.Field{
-		types.NewField(base.Pos, nil, types.Types[types.TUINTPTR]),
-	}))
-	return n
+	fn := hashFunc(t)
+	return fn.Nname
 }
 
 // sysClosure returns a closure which will call the
