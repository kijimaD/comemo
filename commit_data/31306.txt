commit 249aca5deebcc22cc5169814207416a40f14cd86
Author: Hajime Hoshi <hajimehoshi@gmail.com>
Date:   Sat Feb 11 02:09:57 2017 +0900

    cmd/compile/internal/gc: unexport or remove global functions
    
    Change-Id: Ib2109ab773fbf2a35188300cf91a54735f75fc7c
    Reviewed-on: https://go-review.googlesource.com/36736
    Reviewed-by: Matthew Dempsky <mdempsky@google.com>
---
 src/cmd/compile/internal/gc/alg.go       |  4 ++--
 src/cmd/compile/internal/gc/lex.go       |  2 +-
 src/cmd/compile/internal/gc/noder.go     |  8 ++++----
 src/cmd/compile/internal/gc/sinit.go     |  2 +-
 src/cmd/compile/internal/gc/subr.go      | 27 ++-------------------------
 src/cmd/compile/internal/gc/typecheck.go |  6 +++---
 src/cmd/compile/internal/gc/walk.go      | 32 ++++++++++++++++----------------
 7 files changed, 29 insertions(+), 52 deletions(-)

diff --git a/src/cmd/compile/internal/gc/alg.go b/src/cmd/compile/internal/gc/alg.go
index f8cfd3ce5c..86af982f2f 100644
--- a/src/cmd/compile/internal/gc/alg.go
+++ b/src/cmd/compile/internal/gc/alg.go
@@ -186,7 +186,7 @@ func genhash(sym *Sym, t *Type) {
 		fmt.Printf("genhash %v %v\n", sym, t)
 	}
 
-	lineno = MakePos(nil, 1, 0) // less confusing than end of input
+	lineno = makePos(nil, 1, 0) // less confusing than end of input
 	dclcontext = PEXTERN
 	markdcl()
 
@@ -364,7 +364,7 @@ func geneq(sym *Sym, t *Type) {
 		fmt.Printf("geneq %v %v\n", sym, t)
 	}
 
-	lineno = MakePos(nil, 1, 0) // less confusing than end of input
+	lineno = makePos(nil, 1, 0) // less confusing than end of input
 	dclcontext = PEXTERN
 	markdcl()
 
diff --git a/src/cmd/compile/internal/gc/lex.go b/src/cmd/compile/internal/gc/lex.go
index bcb2445bc4..7bd534d71d 100644
--- a/src/cmd/compile/internal/gc/lex.go
+++ b/src/cmd/compile/internal/gc/lex.go
@@ -16,7 +16,7 @@ import (
 // TODO(gri) rename and eventually remove
 var lineno src.XPos
 
-func MakePos(base *src.PosBase, line, col uint) src.XPos {
+func makePos(base *src.PosBase, line, col uint) src.XPos {
 	return Ctxt.PosTable.XPos(src.MakePos(base, line, col))
 }
 
diff --git a/src/cmd/compile/internal/gc/noder.go b/src/cmd/compile/internal/gc/noder.go
index ebb4810f00..ff5f025f44 100644
--- a/src/cmd/compile/internal/gc/noder.go
+++ b/src/cmd/compile/internal/gc/noder.go
@@ -111,7 +111,7 @@ func (p *noder) node() {
 	// for fninit and set lineno to NoPos here.
 	// TODO(gri) fix this once we switched permanently to the new
 	// position information.
-	lineno = MakePos(p.file.Pos().Base(), uint(p.file.Lines), 0)
+	lineno = makePos(p.file.Pos().Base(), uint(p.file.Lines), 0)
 
 	clearImports()
 }
@@ -322,7 +322,7 @@ func (p *noder) funcDecl(fun *syntax.FuncDecl) *Node {
 		yyerror("can only use //go:noescape with external func implementations")
 	}
 	f.Func.Pragma = pragma
-	lineno = MakePos(fun.Pos().Base(), fun.EndLine, 0)
+	lineno = makePos(fun.Pos().Base(), fun.EndLine, 0)
 	f.Func.Endlineno = lineno
 
 	funcbody(f)
@@ -448,14 +448,14 @@ func (p *noder) expr(expr syntax.Expr) *Node {
 			l[i] = p.wrapname(expr.ElemList[i], e)
 		}
 		n.List.Set(l)
-		lineno = MakePos(expr.Pos().Base(), expr.EndLine, 0)
+		lineno = makePos(expr.Pos().Base(), expr.EndLine, 0)
 		return n
 	case *syntax.KeyValueExpr:
 		return p.nod(expr, OKEY, p.expr(expr.Key), p.wrapname(expr.Value, p.expr(expr.Value)))
 	case *syntax.FuncLit:
 		closurehdr(p.typeExpr(expr.Type))
 		body := p.stmts(expr.Body)
-		lineno = MakePos(expr.Pos().Base(), expr.EndLine, 0)
+		lineno = makePos(expr.Pos().Base(), expr.EndLine, 0)
 		return p.setlineno(expr, closurebody(body))
 	case *syntax.ParenExpr:
 		return p.nod(expr, OPAREN, p.expr(expr.X), nil)
diff --git a/src/cmd/compile/internal/gc/sinit.go b/src/cmd/compile/internal/gc/sinit.go
index 19b2222861..009d13565f 100644
--- a/src/cmd/compile/internal/gc/sinit.go
+++ b/src/cmd/compile/internal/gc/sinit.go
@@ -1402,7 +1402,7 @@ func genAsInitNoCheck(n *Node) bool {
 
 		nam.Xoffset += int64(array_nel) - int64(array_array)
 		var nod1 Node
-		Nodconst(&nod1, Types[TINT], nr.Type.NumElem())
+		nodconst(&nod1, Types[TINT], nr.Type.NumElem())
 		gdata(&nam, &nod1, Widthint)
 
 		nam.Xoffset += int64(array_cap) - int64(array_nel)
diff --git a/src/cmd/compile/internal/gc/subr.go b/src/cmd/compile/internal/gc/subr.go
index b4b758e07c..58414e602c 100644
--- a/src/cmd/compile/internal/gc/subr.go
+++ b/src/cmd/compile/internal/gc/subr.go
@@ -440,7 +440,7 @@ func nodfltconst(v *Mpflt) *Node {
 	return c
 }
 
-func Nodconst(n *Node, t *Type, v int64) {
+func nodconst(n *Node, t *Type, v int64) {
 	*n = Node{}
 	n.Op = OLITERAL
 	n.Addable = true
@@ -1706,7 +1706,7 @@ func genwrapper(rcvr *Type, method *Field, newnam *Sym, iface int) {
 		fmt.Printf("genwrapper rcvrtype=%v method=%v newnam=%v\n", rcvr, method, newnam)
 	}
 
-	lineno = MakePos(src.NewFileBase("<autogenerated>", "<autogenerated>"), 1, 0)
+	lineno = makePos(src.NewFileBase("<autogenerated>", "<autogenerated>"), 1, 0)
 
 	dclcontext = PEXTERN
 	markdcl()
@@ -1956,29 +1956,6 @@ func implements(t, iface *Type, m, samename **Field, ptr *int) bool {
 	return true
 }
 
-// even simpler simtype; get rid of ptr, bool.
-// assuming that the front end has rejected
-// all the invalid conversions (like ptr -> bool)
-func Simsimtype(t *Type) EType {
-	if t == nil {
-		return 0
-	}
-
-	et := simtype[t.Etype]
-	switch et {
-	case TPTR32:
-		et = TUINT32
-
-	case TPTR64:
-		et = TUINT64
-
-	case TBOOL:
-		et = TUINT8
-	}
-
-	return et
-}
-
 func listtreecopy(l []*Node, pos src.XPos) []*Node {
 	var out []*Node
 	for _, n := range l {
diff --git a/src/cmd/compile/internal/gc/typecheck.go b/src/cmd/compile/internal/gc/typecheck.go
index ee4eb0353e..ec6f1832fe 100644
--- a/src/cmd/compile/internal/gc/typecheck.go
+++ b/src/cmd/compile/internal/gc/typecheck.go
@@ -1321,7 +1321,7 @@ OpSwitch:
 
 		// any side effects disappear; ignore init
 		var r Node
-		Nodconst(&r, Types[TUINTPTR], evalunsafe(n))
+		nodconst(&r, Types[TUINTPTR], evalunsafe(n))
 		r.Orig = n
 		n = &r
 
@@ -1376,7 +1376,7 @@ OpSwitch:
 		case TSTRING:
 			if Isconst(l, CTSTR) {
 				var r Node
-				Nodconst(&r, Types[TINT], int64(len(l.Val().U.(string))))
+				nodconst(&r, Types[TINT], int64(len(l.Val().U.(string))))
 				r.Orig = n
 				n = &r
 			}
@@ -1386,7 +1386,7 @@ OpSwitch:
 				break
 			}
 			var r Node
-			Nodconst(&r, Types[TINT], t.NumElem())
+			nodconst(&r, Types[TINT], t.NumElem())
 			r.Orig = n
 			n = &r
 		}
diff --git a/src/cmd/compile/internal/gc/walk.go b/src/cmd/compile/internal/gc/walk.go
index 772e86bfab..a3315c066a 100644
--- a/src/cmd/compile/internal/gc/walk.go
+++ b/src/cmd/compile/internal/gc/walk.go
@@ -529,7 +529,7 @@ opswitch:
 		}
 		if t.IsArray() {
 			safeexpr(n.Left, init)
-			Nodconst(n, n.Type, t.NumElem())
+			nodconst(n, n.Type, t.NumElem())
 			n.Typecheck = 1
 		}
 
@@ -3445,7 +3445,7 @@ func walkdiv(n *Node, init *Nodes) *Node {
 		case TUINT8, TUINT16, TUINT32:
 			var nc Node
 
-			Nodconst(&nc, nl.Type, int64(m.Um))
+			nodconst(&nc, nl.Type, int64(m.Um))
 			n1 := nod(OHMUL, nl, &nc)
 			n1 = typecheck(n1, Erv)
 			if m.Ua != 0 {
@@ -3475,13 +3475,13 @@ func walkdiv(n *Node, init *Nodes) *Node {
 				// shift by m.s
 				var nc Node
 
-				Nodconst(&nc, Types[TUINT], int64(m.S))
+				nodconst(&nc, Types[TUINT], int64(m.S))
 				n = conv(nod(ORSH, n2, &nc), nl.Type)
 			} else {
 				// n = n1 >> m.s
 				var nc Node
 
-				Nodconst(&nc, Types[TUINT], int64(m.S))
+				nodconst(&nc, Types[TUINT], int64(m.S))
 				n = nod(ORSH, n1, &nc)
 			}
 
@@ -3489,7 +3489,7 @@ func walkdiv(n *Node, init *Nodes) *Node {
 		case TINT8, TINT16, TINT32:
 			var nc Node
 
-			Nodconst(&nc, nl.Type, m.Sm)
+			nodconst(&nc, nl.Type, m.Sm)
 			n1 := nod(OHMUL, nl, &nc)
 			n1 = typecheck(n1, Erv)
 			if m.Sm < 0 {
@@ -3500,13 +3500,13 @@ func walkdiv(n *Node, init *Nodes) *Node {
 			// shift by m.s
 			var ns Node
 
-			Nodconst(&ns, Types[TUINT], int64(m.S))
+			nodconst(&ns, Types[TUINT], int64(m.S))
 			n2 := conv(nod(ORSH, n1, &ns), nl.Type)
 
 			// add 1 iff n1 is negative.
 			var nneg Node
 
-			Nodconst(&nneg, Types[TUINT], int64(w)-1)
+			nodconst(&nneg, Types[TUINT], int64(w)-1)
 			n3 := nod(ORSH, nl, &nneg) // n4 = -1 iff n1 is negative.
 			n = nod(OSUB, n2, n3)
 
@@ -3523,7 +3523,7 @@ func walkdiv(n *Node, init *Nodes) *Node {
 	case 0:
 		if n.Op == OMOD {
 			// nl % 1 is zero.
-			Nodconst(n, n.Type, 0)
+			nodconst(n, n.Type, 0)
 		} else if s != 0 {
 			// divide by -1
 			n.Op = OMINUS
@@ -3542,7 +3542,7 @@ func walkdiv(n *Node, init *Nodes) *Node {
 				// nl & (2^pow-1) is (nl+1)%2^pow - 1.
 				var nc Node
 
-				Nodconst(&nc, Types[simtype[TUINT]], int64(w)-1)
+				nodconst(&nc, Types[simtype[TUINT]], int64(w)-1)
 				n1 := nod(ORSH, nl, &nc) // n1 = -1 iff nl < 0.
 				if pow == 1 {
 					n1 = typecheck(n1, Erv)
@@ -3552,14 +3552,14 @@ func walkdiv(n *Node, init *Nodes) *Node {
 					n2 := nod(OSUB, nl, n1)
 
 					var nc Node
-					Nodconst(&nc, nl.Type, 1)
+					nodconst(&nc, nl.Type, 1)
 					n3 := nod(OAND, n2, &nc)
 					n = nod(OADD, n3, n1)
 				} else {
 					// n = (nl+ε)&(nr-1) - ε where ε=2^pow-1 iff nl<0.
 					var nc Node
 
-					Nodconst(&nc, nl.Type, (1<<uint(pow))-1)
+					nodconst(&nc, nl.Type, (1<<uint(pow))-1)
 					n2 := nod(OAND, n1, &nc) // n2 = 2^pow-1 iff nl<0.
 					n2 = typecheck(n2, Erv)
 					n2 = cheapexpr(n2, init)
@@ -3576,7 +3576,7 @@ func walkdiv(n *Node, init *Nodes) *Node {
 				// if nl < 0, we want to add 2^n-1 first.
 				var nc Node
 
-				Nodconst(&nc, Types[simtype[TUINT]], int64(w)-1)
+				nodconst(&nc, Types[simtype[TUINT]], int64(w)-1)
 				n1 := nod(ORSH, nl, &nc) // n1 = -1 iff nl < 0.
 				if pow == 1 {
 					// nl+1 is nl-(-1)
@@ -3585,7 +3585,7 @@ func walkdiv(n *Node, init *Nodes) *Node {
 					// Do a logical right right on -1 to keep pow bits.
 					var nc Node
 
-					Nodconst(&nc, Types[simtype[TUINT]], int64(w)-int64(pow))
+					nodconst(&nc, Types[simtype[TUINT]], int64(w)-int64(pow))
 					n2 := nod(ORSH, conv(n1, nl.Type.toUnsigned()), &nc)
 					n.Left = nod(OADD, nl, conv(n2, nl.Type))
 				}
@@ -3594,7 +3594,7 @@ func walkdiv(n *Node, init *Nodes) *Node {
 				n.Op = ORSH
 
 				var n2 Node
-				Nodconst(&n2, Types[simtype[TUINT]], int64(pow))
+				nodconst(&n2, Types[simtype[TUINT]], int64(pow))
 				n.Right = &n2
 				n.Typecheck = 0
 			}
@@ -3610,12 +3610,12 @@ func walkdiv(n *Node, init *Nodes) *Node {
 			// n = nl & (nr-1)
 			n.Op = OAND
 
-			Nodconst(&nc, nl.Type, nr.Int64()-1)
+			nodconst(&nc, nl.Type, nr.Int64()-1)
 		} else {
 			// n = nl >> pow
 			n.Op = ORSH
 
-			Nodconst(&nc, Types[simtype[TUINT]], int64(pow))
+			nodconst(&nc, Types[simtype[TUINT]], int64(pow))
 		}
 
 		n.Typecheck = 0
