commit 704bc9d5c95858fd43151f19e7e4de6c99142f1c
Author: Rob Pike <r@golang.org>
Date:   Fri Feb 6 17:54:26 2009 -0800

    portable stat for os
    add name to os.FD
    clean up some interfaces
    
    R=rsc
    DELTA=318  (231 added, 44 deleted, 43 changed)
    OCL=24624
    CL=24627
---
 src/lib/io/io.go                | 30 +++++++---------
 src/lib/net/fd.go               | 10 +++---
 src/lib/os/Makefile             | 22 ++++++++----
 src/lib/os/os_file.go           | 66 +++++++++++++++++++++++++---------
 src/lib/os/os_test.go           | 79 +++++++++++++++++++++++++++++++++++++++++
 src/lib/os/os_types.go          | 26 ++++++++++++++
 src/lib/os/stat_amd64_darwin.go | 34 ++++++++++++++++++
 src/lib/os/stat_amd64_linux.go  | 34 ++++++++++++++++++
 src/lib/syscall/file_linux.go   | 40 +++++++--------------
 src/lib/syscall/syscall.go      | 11 +++---
 src/lib/utf8_test.go            | 11 +++---
 11 files changed, 277 insertions(+), 86 deletions(-)

diff --git a/src/lib/io/io.go b/src/lib/io/io.go
index 54f18fb959..1004ac901b 100644
--- a/src/lib/io/io.go
+++ b/src/lib/io/io.go
@@ -34,14 +34,19 @@ type Close interface {
 	Close() *os.Error;
 }
 
-func WriteString(w Write, s string) (n int, err *os.Error) {
-	b := make([]byte, len(s)+1);
-	if !syscall.StringToBytes(b, s) {
-		return -1, os.EINVAL
+// Convert a string to an array of bytes for easy marshaling.
+// Could fill with syscall.StringToBytes but it adds an unnecessary \000
+// so the length would be wrong.
+func StringBytes(s string) []byte {
+	b := make([]byte, len(s));
+	for i := 0; i < len(s); i++ {
+		b[i] = s[i];
 	}
-	// BUG return w.Write(b[0:len(s)])
-	r, e := w.Write(b[0:len(s)]);
-	return r, e
+	return b;
+}
+
+func WriteString(w Write, s string) (n int, err *os.Error) {
+	return w.Write(StringBytes(s))
 }
 
 // Read until buffer is full, EOF, or error
@@ -147,14 +152,3 @@ func Copy(src Read, dst Write) (written int64, err *os.Error) {
 	}
 	return written, err
 }
-
-// Convert a string to an array of bytes for easy marshaling.
-// Could fill with syscall.StringToBytes but it adds an unnecessary \000
-// so the length would be wrong.
-func StringBytes(s string) []byte {
-	b := make([]byte, len(s));
-	for i := 0; i < len(s); i++ {
-		b[i] = s[i];
-	}
-	return b;
-}
diff --git a/src/lib/net/fd.go b/src/lib/net/fd.go
index 83394ddd33..45269c81a0 100644
--- a/src/lib/net/fd.go
+++ b/src/lib/net/fd.go
@@ -84,19 +84,19 @@ func _NewPollServer() (s *_PollServer, err *os.Error) {
 	if s.pr, s.pw, err = os.Pipe(); err != nil {
 		return nil, err
 	}
-	if err = _SetNonblock(s.pr.Fd); err != nil {
+	if err = _SetNonblock(s.pr.Fd()); err != nil {
 	Error:
 		s.pr.Close();
 		s.pw.Close();
 		return nil, err
 	}
-	if err = _SetNonblock(s.pw.Fd); err != nil {
+	if err = _SetNonblock(s.pw.Fd()); err != nil {
 		goto Error
 	}
 	if s.poll, err = NewPollster(); err != nil {
 		goto Error
 	}
-	if err = s.poll.AddFD(s.pr.Fd, 'r', true); err != nil {
+	if err = s.poll.AddFD(s.pr.Fd(), 'r', true); err != nil {
 		s.poll.Close();
 		goto Error
 	}
@@ -142,7 +142,7 @@ func (s *_PollServer) Run() {
 			print("_PollServer WaitFD: ", err.String(), "\n");
 			return
 		}
-		if fd == s.pr.Fd {
+		if fd == s.pr.Fd() {
 			// Drain our wakeup pipe.
 			for nn, e := s.pr.Read(scratch); nn > 0; {
 				nn, e = s.pr.Read(scratch)
@@ -216,7 +216,7 @@ func NewFD(fd int64) (f *FD, err *os.Error) {
 	}
 	f = new(FD);
 	f.fd = fd;
-	f.osfd = os.NewFD(fd);
+	f.osfd = os.NewFD(fd, "socket");
 	f.cr = make(chan *FD, 1);
 	f.cw = make(chan *FD, 1);
 	return f, nil
diff --git a/src/lib/os/Makefile b/src/lib/os/Makefile
index 954d1cc363..c8c8e8839f 100644
--- a/src/lib/os/Makefile
+++ b/src/lib/os/Makefile
@@ -3,7 +3,8 @@
 # license that can be found in the LICENSE file.
 
 # DO NOT EDIT.  Automatically generated by gobuild.
-# gobuild -m >Makefile
+# gobuild -m os_env.go os_error.go os_file.go os_test.go os_time.go\
+#    os_types.go stat_amd64_linux.go >Makefile
 O=6
 GC=$(O)g
 CC=$(O)c -w
@@ -33,27 +34,36 @@ coverage: packages
 
 O1=\
 	os_error.$O\
+	os_types.$O\
 
 O2=\
-	os_file.$O\
-	os_time.$O\
 	os_env.$O\
+	os_time.$O\
+	stat_$(GOARCH)_$(GOOS).$O\
 
-os.a: a1 a2
+O3=\
+	os_file.$O\
+
+os.a: a1 a2 a3
 
 a1:	$(O1)
-	$(AR) grc os.a os_error.$O
+	$(AR) grc os.a os_error.$O os_types.$O
 	rm -f $(O1)
 
 a2:	$(O2)
-	$(AR) grc os.a os_file.$O os_time.$O os_env.$O
+	$(AR) grc os.a os_env.$O os_time.$O stat_$(GOARCH)_$(GOOS).$O
 	rm -f $(O2)
 
+a3:	$(O3)
+	$(AR) grc os.a os_file.$O
+	rm -f $(O3)
+
 newpkg: clean
 	$(AR) grc os.a
 
 $(O1): newpkg
 $(O2): a1
+$(O3): a2
 
 nuke: clean
 	rm -f $(GOROOT)/pkg/os.a
diff --git a/src/lib/os/os_file.go b/src/lib/os/os_file.go
index 6c516ff76f..25b14d03f2 100644
--- a/src/lib/os/os_file.go
+++ b/src/lib/os/os_file.go
@@ -9,20 +9,29 @@ import os "os"
 
 // FDs are wrappers for file descriptors
 type FD struct {
-	Fd int64
+	fd int64;
+	name	string;
 }
 
-func NewFD(fd int64) *FD {
+func (fd *FD) Fd() int64 {
+	return fd.fd
+}
+
+func (fd *FD) Name() string {
+	return fd.name
+}
+
+func NewFD(fd int64, name string) *FD {
 	if fd < 0 {
 		return nil
 	}
-	return &FD{fd}
+	return &FD{fd, name}
 }
 
 var (
-	Stdin = NewFD(0);
-	Stdout = NewFD(1);
-	Stderr = NewFD(2);
+	Stdin = NewFD(0, "/dev/stdin");
+	Stdout = NewFD(1, "/dev/stdout");
+	Stderr = NewFD(2, "/dev/stderr");
 )
 
 const (
@@ -41,15 +50,15 @@ const (
 
 func Open(name string, mode int, flags int) (fd *FD, err *Error) {
 	r, e := syscall.Open(name, int64(mode), int64(flags));
-	return NewFD(r), ErrnoToError(e)
+	return NewFD(r, name), ErrnoToError(e)
 }
 
 func (fd *FD) Close() *Error {
 	if fd == nil {
 		return EINVAL
 	}
-	r, e := syscall.Close(fd.Fd);
-	fd.Fd = -1;  // so it can't be closed again
+	r, e := syscall.Close(fd.fd);
+	fd.fd = -1;  // so it can't be closed again
 	return ErrnoToError(e)
 }
 
@@ -59,7 +68,7 @@ func (fd *FD) Read(b []byte) (ret int, err *Error) {
 	}
 	var r, e int64;
 	if len(b) > 0 {  // because we access b[0]
-		r, e = syscall.Read(fd.Fd, &b[0], int64(len(b)));
+		r, e = syscall.Read(fd.fd, &b[0], int64(len(b)));
 		if r < 0 {
 			r = 0
 		}
@@ -73,7 +82,7 @@ func (fd *FD) Write(b []byte) (ret int, err *Error) {
 	}
 	var r, e int64;
 	if len(b) > 0 {  // because we access b[0]
-		r, e = syscall.Write(fd.Fd, &b[0], int64(len(b)));
+		r, e = syscall.Write(fd.fd, &b[0], int64(len(b)));
 		if r < 0 {
 			r = 0
 		}
@@ -85,11 +94,7 @@ func (fd *FD) WriteString(s string) (ret int, err *Error) {
 	if fd == nil {
 		return 0, EINVAL
 	}
-	b := make([]byte, len(s)+1);
-	if !syscall.StringToBytes(b, s) {
-		return 0, EINVAL
-	}
-	r, e := syscall.Write(fd.Fd, &b[0], int64(len(s)));
+	r, e := syscall.Write(fd.fd, syscall.StringBytePtr(s), int64(len(s)));
 	if r < 0 {
 		r = 0
 	}
@@ -102,10 +107,37 @@ func Pipe() (fd1 *FD, fd2 *FD, err *Error) {
 	if e != 0 {
 		return nil, nil, ErrnoToError(e)
 	}
-	return NewFD(p[0]), NewFD(p[1]), nil
+	return NewFD(p[0], "|0"), NewFD(p[1], "|1"), nil
 }
 
 func Mkdir(name string, perm int) *Error {
 	r, e := syscall.Mkdir(name, int64(perm));
 	return ErrnoToError(e)
 }
+
+func Stat(name string) (dir *Dir, err *Error) {
+	stat := new(syscall.Stat_t);
+	r, e := syscall.Stat(name, stat);
+	if e != 0 {
+		return nil, ErrnoToError(e)
+	}
+	return dirFromStat(name, new(Dir), stat), nil
+}
+
+func Fstat(fd *FD) (dir *Dir, err *Error) {
+	stat := new(syscall.Stat_t);
+	r, e := syscall.Fstat(fd.fd, stat);
+	if e != 0 {
+		return nil, ErrnoToError(e)
+	}
+	return dirFromStat(fd.name, new(Dir), stat), nil
+}
+
+func Lstat(name string) (dir *Dir, err *Error) {
+	stat := new(syscall.Stat_t);
+	r, e := syscall.Lstat(name, stat);
+	if e != 0 {
+		return nil, ErrnoToError(e)
+	}
+	return dirFromStat(name, new(Dir), stat), nil
+}
diff --git a/src/lib/os/os_test.go b/src/lib/os/os_test.go
new file mode 100644
index 0000000000..beaa227538
--- /dev/null
+++ b/src/lib/os/os_test.go
@@ -0,0 +1,79 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package os
+
+import (
+	"fmt";
+	"os";
+	"testing";
+)
+
+func size(file string, t *testing.T) uint64 {
+	fd, err := Open(file, O_RDONLY, 0);
+	defer fd.Close();
+	if err != nil {
+		t.Fatal("open failed:", err);
+	}
+	var buf [100]byte;
+	len := 0;
+	for {
+		n, e := fd.Read(buf);
+		if n < 0 || e != nil {
+			t.Fatal("read failed:", err);
+		}
+		if n == 0 {
+			break
+		}
+		len += n;
+	}
+	return uint64(len)
+}
+
+func TestStat(t *testing.T) {
+	dir, err := Stat("/etc/passwd");
+	if err != nil {
+		t.Fatal("stat failed:", err);
+	}
+	if dir.Name != "passwd" {
+		t.Error("name should be passwd; is", dir.Name);
+	}
+	filesize := size("/etc/passwd", t);
+	if dir.Size != filesize {
+		t.Error("size should be ", filesize, "; is", dir.Size);
+	}
+}
+
+func TestFstat(t *testing.T) {
+	fd, err1 := Open("/etc/passwd", O_RDONLY, 0);
+	defer fd.Close();
+	if err1 != nil {
+		t.Fatal("open failed:", err1);
+	}
+	dir, err2 := Fstat(fd);
+	if err2 != nil {
+		t.Fatal("fstat failed:", err2);
+	}
+	if dir.Name != "passwd" {
+		t.Error("name should be passwd; is", dir.Name);
+	}
+	filesize := size("/etc/passwd", t);
+	if dir.Size != filesize {
+		t.Error("size should be ", filesize, "; is", dir.Size);
+	}
+}
+
+func TestLstat(t *testing.T) {
+	dir, err := Lstat("/etc/passwd");
+	if err != nil {
+		t.Fatal("lstat failed:", err);
+	}
+	if dir.Name != "passwd" {
+		t.Error("name should be passwd; is", dir.Name);
+	}
+	filesize := size("/etc/passwd", t);
+	if dir.Size != filesize {
+		t.Error("size should be ", filesize, "; is", dir.Size);
+	}
+}
diff --git a/src/lib/os/os_types.go b/src/lib/os/os_types.go
new file mode 100644
index 0000000000..2e8ce3b9bf
--- /dev/null
+++ b/src/lib/os/os_types.go
@@ -0,0 +1,26 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package os
+
+// An operating-system independent representation of Unix data structures.
+// OS-specific routines in this directory convert the OS-local versions to these.
+
+// Result of stat64(2) etc.
+type Dir struct {
+	Dev	uint64;
+	Ino	uint64;
+	Nlink	uint64;
+	Mode	uint32;
+	Uid	uint32;
+	Gid	uint32;
+	Rdev	uint64;
+	Size	uint64;
+	Blksize	uint64;
+	Blocks	uint64;
+	Atime_ns	uint64;	// nanoseconds since 1970
+	Mtime_ns	uint64;	// nanoseconds since 1970
+	Ctime_ns	uint64;	// nanoseconds since 1970
+	Name	string;
+}
diff --git a/src/lib/os/stat_amd64_darwin.go b/src/lib/os/stat_amd64_darwin.go
new file mode 100644
index 0000000000..0c811680a8
--- /dev/null
+++ b/src/lib/os/stat_amd64_darwin.go
@@ -0,0 +1,34 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// AMD64, Darwin
+
+package os
+
+import syscall "syscall"
+import os "os"
+
+func dirFromStat(name string, dir *Dir, stat *syscall.Stat_t) *Dir {
+	dir.Dev = uint64(stat.Dev);
+	dir.Ino = stat.Ino;
+	dir.Nlink = uint64(stat.Nlink);
+	dir.Mode = uint32(stat.Mode);
+	dir.Uid = stat.Uid;
+	dir.Gid = stat.Gid;
+	dir.Rdev = uint64(stat.Rdev);
+	dir.Size = stat.Size;
+	dir.Blksize = uint64(stat.Blksize);
+	dir.Blocks = stat.Blocks;
+	dir.Atime_ns = uint64(stat.Atime.Sec) * 1e9 + stat.Atime.Nsec;
+	dir.Mtime_ns = uint64(stat.Mtime.Sec) * 1e9 + stat.Mtime.Nsec;
+	dir.Ctime_ns = uint64(stat.Ctime.Sec) * 1e9 + stat.Atime.Nsec;
+	for i := len(name) - 1; i >= 0; i-- {
+		if name[i] == '/' {
+			name = name[i+1:len(name)];
+			break;
+		}
+	}
+	dir.Name = name;
+	return dir;
+}
diff --git a/src/lib/os/stat_amd64_linux.go b/src/lib/os/stat_amd64_linux.go
new file mode 100644
index 0000000000..b39f8c2ad0
--- /dev/null
+++ b/src/lib/os/stat_amd64_linux.go
@@ -0,0 +1,34 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// AMD64, Linux
+
+package os
+
+import syscall "syscall"
+import os "os"
+
+func dirFromStat(name string, dir *Dir, stat *syscall.Stat_t) *Dir {
+	dir.Dev = stat.Dev;
+	dir.Ino = stat.Ino;
+	dir.Nlink = stat.Nlink;
+	dir.Mode = stat.Mode;
+	dir.Uid = stat.Uid;
+	dir.Gid = stat.Gid;
+	dir.Rdev = stat.Rdev;
+	dir.Size = uint64(stat.Size);
+	dir.Blksize = uint64(stat.Blksize);
+	dir.Blocks = uint64(stat.Blocks);
+	dir.Atime_ns = uint64(stat.Atime.Sec) * 1e9 + stat.Atime.Nsec;
+	dir.Mtime_ns = uint64(stat.Mtime.Sec) * 1e9 + stat.Mtime.Nsec;
+	dir.Ctime_ns = uint64(stat.Ctime.Sec) * 1e9 + stat.Atime.Nsec;
+	for i := len(name) - 1; i >= 0; i-- {
+		if name[i] == '/' {
+			name = name[i+1:len(name)];
+			break;
+		}
+	}
+	dir.Name = name;
+	return dir;
+}
diff --git a/src/lib/syscall/file_linux.go b/src/lib/syscall/file_linux.go
index ef30faac99..52c1e90402 100644
--- a/src/lib/syscall/file_linux.go
+++ b/src/lib/syscall/file_linux.go
@@ -14,20 +14,14 @@ import (
 const nameBufsize = 512
 
 func Open(name string, mode int64, perm int64) (ret int64, errno int64) {
-	var namebuf [nameBufsize]byte;
-	if !StringToBytes(namebuf, name) {
-		return -1, ENAMETOOLONG
-	}
-	r1, r2, err := Syscall(SYS_OPEN, int64(uintptr(unsafe.Pointer(&namebuf[0]))), mode, perm);
+	namebuf := StringBytePtr(name);
+	r1, r2, err := Syscall(SYS_OPEN, int64(uintptr(unsafe.Pointer(namebuf))), mode, perm);
 	return r1, err;
 }
 
 func Creat(name string, perm int64) (ret int64, errno int64) {
-	var namebuf [nameBufsize]byte;
-	if !StringToBytes(namebuf, name) {
-		return -1, ENAMETOOLONG
-	}
-	r1, r2, err := Syscall(SYS_OPEN, int64(uintptr(unsafe.Pointer(&namebuf[0]))),  O_CREAT|O_WRONLY|O_TRUNC, perm);
+	namebuf := StringBytePtr(name);
+	r1, r2, err := Syscall(SYS_OPEN, int64(uintptr(unsafe.Pointer(namebuf))),  O_CREAT|O_WRONLY|O_TRUNC, perm);
 	return r1, err;
 }
 
@@ -58,16 +52,14 @@ func Pipe(fds *[2]int64) (ret int64, errno int64) {
 }
 
 func Stat(name string, buf *Stat_t) (ret int64, errno int64) {
-	var namebuf [nameBufsize]byte;
-	if !StringToBytes(namebuf, name) {
-		return -1, ENAMETOOLONG
-	}
-	r1, r2, err := Syscall(SYS_STAT, int64(uintptr(unsafe.Pointer(&namebuf[0]))), int64(uintptr(unsafe.Pointer(buf))), 0);
+	namebuf := StringBytePtr(name);
+	r1, r2, err := Syscall(SYS_STAT, int64(uintptr(unsafe.Pointer(namebuf))), int64(uintptr(unsafe.Pointer(buf))), 0);
 	return r1, err;
 }
 
-func Lstat(name *byte, buf *Stat_t) (ret int64, errno int64) {
-	r1, r2, err := Syscall(SYS_LSTAT, int64(uintptr(unsafe.Pointer(name))), int64(uintptr(unsafe.Pointer(buf))), 0);
+func Lstat(name string, buf *Stat_t) (ret int64, errno int64) {
+	namebuf := StringBytePtr(name);
+	r1, r2, err := Syscall(SYS_LSTAT, int64(uintptr(unsafe.Pointer(namebuf))), int64(uintptr(unsafe.Pointer(buf))), 0);
 	return r1, err;
 }
 
@@ -77,11 +69,8 @@ func Fstat(fd int64, buf *Stat_t) (ret int64, errno int64) {
 }
 
 func Unlink(name string) (ret int64, errno int64) {
-	var namebuf [nameBufsize]byte;
-	if !StringToBytes(namebuf, name) {
-		return -1, ENAMETOOLONG
-	}
-	r1, r2, err := Syscall(SYS_UNLINK, int64(uintptr(unsafe.Pointer(&namebuf[0]))), 0, 0);
+	namebuf := StringBytePtr(name);
+	r1, r2, err := Syscall(SYS_UNLINK, int64(uintptr(unsafe.Pointer(namebuf))), 0, 0);
 	return r1, err;
 }
 
@@ -91,11 +80,8 @@ func Fcntl(fd, cmd, arg int64) (ret int64, errno int64) {
 }
 
 func Mkdir(name string, perm int64) (ret int64, errno int64) {
-	var namebuf [nameBufsize]byte;
-	if !StringToBytes(namebuf, name) {
-		return -1, ENAMETOOLONG
-	}
-	r1, r2, err := Syscall(SYS_MKDIR, int64(uintptr(unsafe.Pointer(&namebuf[0]))), perm, 0);
+	namebuf := StringBytePtr(name);
+	r1, r2, err := Syscall(SYS_MKDIR, int64(uintptr(unsafe.Pointer(namebuf))), perm, 0);
 	return r1, err;
 }
 
diff --git a/src/lib/syscall/syscall.go b/src/lib/syscall/syscall.go
index 780f0f2620..d8db5ce5d9 100644
--- a/src/lib/syscall/syscall.go
+++ b/src/lib/syscall/syscall.go
@@ -16,13 +16,10 @@ func RawSyscall(trap int64, a1, a2, a3 int64) (r1, r2, err int64);
  * Used to convert file names to byte arrays for passing to kernel,
  * but useful elsewhere too.
  */
-func StringToBytes(b []byte, s string) bool {
-	if len(s) >= len(b) {
-		return false
-	}
+func StringBytePtr(s string) *byte {
+	a := make([]byte, len(s)+1);
 	for i := 0; i < len(s); i++ {
-		b[i] = s[i]
+		a[i] = s[i];
 	}
-	b[len(s)] = '\000';	// not necessary - memory is zeroed - but be explicit
-	return true
+	return &a[0];
 }
diff --git a/src/lib/utf8_test.go b/src/lib/utf8_test.go
index 2cb15889ef..7999afd2ee 100644
--- a/src/lib/utf8_test.go
+++ b/src/lib/utf8_test.go
@@ -6,6 +6,7 @@ package utf8
 
 import (
 	"fmt";
+	"io";
 	"syscall";
 	"testing";
 	"utf8";
@@ -44,13 +45,11 @@ var utf8map = []Utf8Map {
 	Utf8Map{ 0x10ffff, "\xf4\x8f\xbf\xbf" },
 }
 
-// like io.StringBytes but leaves one extra byte at end
+// io.StringBytes with one extra byte at end
 func bytes(s string) []byte {
-	b := make([]byte, len(s)+1);
-	if !syscall.StringToBytes(b, s) {
-		panic("StringTobytes failed");
-	}
-	return b[0:len(s)];
+	s += "\x00";
+	b := io.StringBytes(s);
+	return b[0:len(s)-1];
 }
 
 func TestFullRune(t *testing.T) {
