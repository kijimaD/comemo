commit 9aad9fef76f49240a33f253e2db4e2de5c2f192f
Author: Russ Cox <rsc@golang.org>
Date:   Sun Aug 3 17:25:15 2008 -0700

    make 6a, 6c, 6g, 6l, libmach_amd64 build on 64-bit gcc.
    these guys really really want long to be 32-bits,
    so ,s/long/int32/ (and then manual fixup).
    still passes all tests.
    
    (i started out looking for just those longs that
    needed to be int32 instead, and it was just too hard
    to track them down one by one.)
    
    the longs were rare enough that i don't think
    it will cause integration problems.
    
    R=ken
    OCL=13787
    CL=13789
---
 include/bootexec.h             | 146 ++++++++++++++++++++---------------------
 include/mach_amd64.h           |  62 ++++++++---------
 include/u.h                    |  10 +++
 include/ureg_x86.h             |  40 +++++------
 src/cmd/6a/a.h                 |  17 +++--
 src/cmd/6a/lex.c               |   2 +-
 src/cmd/6c/cgen.c              |  26 ++++----
 src/cmd/6c/div.c               |  14 ++--
 src/cmd/6c/gc.h                |  84 ++++++++++++------------
 src/cmd/6c/mul.c               |  20 +++---
 src/cmd/6c/pgen.c              |   6 +-
 src/cmd/6c/pswt.c              |  12 ++--
 src/cmd/6c/reg.c               |  72 ++++++++++----------
 src/cmd/6c/swt.c               |  32 ++++-----
 src/cmd/6c/txt.c               |  22 +++----
 src/cmd/6g/align.c             |  16 ++---
 src/cmd/6g/cgen.c              |   6 +-
 src/cmd/6g/gen.c               |  14 ++--
 src/cmd/6g/gg.h                |  22 +++----
 src/cmd/6g/gsubr.c             |   8 +--
 src/cmd/6g/list.c              |   2 +-
 src/cmd/6g/obj.c               |   6 +-
 src/cmd/6l/6.out.h             |   4 +-
 src/cmd/6l/asm.c               |  32 ++++-----
 src/cmd/6l/l.h                 |  66 +++++++++----------
 src/cmd/6l/obj.c               |  26 ++++----
 src/cmd/6l/pass.c              |  30 ++++-----
 src/cmd/6l/span.c              |  24 +++----
 src/cmd/cc/acid.c              |   2 +-
 src/cmd/cc/bits.c              |   2 +-
 src/cmd/cc/cc.h                | 132 ++++++++++++++++++-------------------
 src/cmd/cc/cc.y                |   6 +-
 src/cmd/cc/com.c               |   2 +-
 src/cmd/cc/dcl.c               |  34 +++++-----
 src/cmd/cc/lex.c               |  30 ++++-----
 src/cmd/cc/lexbody             |  14 ++--
 src/cmd/cc/macbody             |   8 +--
 src/cmd/cc/pgen.c              |   4 +-
 src/cmd/cc/pickle.c            |   2 +-
 src/cmd/cc/pswt.c              |  12 ++--
 src/cmd/cc/sub.c               |  72 ++++++++++----------
 src/cmd/gc/const.c             |   4 +-
 src/cmd/gc/dcl.c               |   2 +-
 src/cmd/gc/export.c            |   2 +-
 src/cmd/gc/go.h                |  62 ++++++++---------
 src/cmd/gc/lex.c               |  18 ++---
 src/cmd/gc/mpatof.c            |   8 +--
 src/cmd/gc/subr.c              |  38 +++++------
 src/cmd/gc/walk.c              |   8 +--
 src/libmach_amd64/6obj.c       |   2 +-
 src/libmach_amd64/8.c          |   2 +-
 src/libmach_amd64/8db.c        |  40 +++++------
 src/libmach_amd64/access.c     |   6 +-
 src/libmach_amd64/elf.h        |  42 ++++++------
 src/libmach_amd64/executable.c |  58 ++++++++--------
 src/libmach_amd64/machdata.c   |  22 +++----
 src/libmach_amd64/macho.h      |  48 +++++++-------
 src/libmach_amd64/obj.c        |   4 +-
 src/libmach_amd64/swap.c       |  12 ++--
 src/libmach_amd64/sym.c        |  58 ++++++++--------
 60 files changed, 793 insertions(+), 784 deletions(-)

diff --git a/include/bootexec.h b/include/bootexec.h
index 7442733860..49721ea33b 100644
--- a/include/bootexec.h
+++ b/include/bootexec.h
@@ -29,14 +29,14 @@
 struct coffsect
 {
 	char	name[8];
-	ulong	phys;
-	ulong	virt;
-	ulong	size;
-	ulong	fptr;
-	ulong	fptrreloc;
-	ulong	fptrlineno;
-	ulong	nrelocnlineno;
-	ulong	flags;
+	uint32	phys;
+	uint32	virt;
+	uint32	size;
+	uint32	fptr;
+	uint32	fptrreloc;
+	uint32	fptrlineno;
+	uint32	nrelocnlineno;
+	uint32	flags;
 };
 
 /*
@@ -46,26 +46,26 @@ struct mipsexec
 {
 	short	mmagic;		/* (0x160) mips magic number */
 	short	nscns;		/* (unused) number of sections */
-	long	timdat;		/* (unused) time & date stamp */
-	long	symptr;		/* offset to symbol table */
-	long	nsyms;		/* size of symbol table */
+	int32	timdat;		/* (unused) time & date stamp */
+	int32	symptr;		/* offset to symbol table */
+	int32	nsyms;		/* size of symbol table */
 	short	opthdr;		/* (0x38) sizeof(optional hdr) */
 	short	pcszs;		/* flags */
 	short	amagic;		/* see above */
 	short	vstamp;		/* version stamp */
-	long	tsize;		/* text size in bytes */
-	long	dsize;		/* initialized data */
-	long	bsize;		/* uninitialized data */
-	long	mentry;		/* entry pt.				*/
-	long	text_start;	/* base of text used for this file	*/
-	long	data_start;	/* base of data used for this file	*/
-	long	bss_start;	/* base of bss used for this file	*/
-	long	gprmask;	/* general purpose register mask	*/
+	int32	tsize;		/* text size in bytes */
+	int32	dsize;		/* initialized data */
+	int32	bsize;		/* uninitialized data */
+	int32	mentry;		/* entry pt.				*/
+	int32	text_start;	/* base of text used for this file	*/
+	int32	data_start;	/* base of data used for this file	*/
+	int32	bss_start;	/* base of bss used for this file	*/
+	int32	gprmask;	/* general purpose register mask	*/
 union{
-	long	cprmask[4];	/* co-processor register masks		*/
-	long	pcsize;
+	int32	cprmask[4];	/* co-processor register masks		*/
+	int32	pcsize;
 };
-	long	gp_value;	/* the gp value used for this object    */
+	int32	gp_value;	/* the gp value used for this object    */
 };
 
 struct mips4kexec
@@ -80,64 +80,64 @@ struct sparcexec
 {
 	short	sjunk;		/* dynamic bit and version number */
 	short	smagic;		/* 0407 */
-	ulong	stext;
-	ulong	sdata;
-	ulong	sbss;
-	ulong	ssyms;
-	ulong	sentry;
-	ulong	strsize;
-	ulong	sdrsize;
+	uint32	stext;
+	uint32	sdata;
+	uint32	sbss;
+	uint32	ssyms;
+	uint32	sentry;
+	uint32	strsize;
+	uint32	sdrsize;
 };
 
 struct nextexec
 {
 /* UNUSED
 	struct	nexthdr{
-		ulong	nmagic;
-		ulong	ncputype;
-		ulong	ncpusubtype;
-		ulong	nfiletype;
-		ulong	ncmds;
-		ulong	nsizeofcmds;
-		ulong	nflags;
+		uint32	nmagic;
+		uint32	ncputype;
+		uint32	ncpusubtype;
+		uint32	nfiletype;
+		uint32	ncmds;
+		uint32	nsizeofcmds;
+		uint32	nflags;
 	};
 
 	struct nextcmd{
-		ulong	cmd;
-		ulong	cmdsize;
+		uint32	cmd;
+		uint32	cmdsize;
 		uchar	segname[16];
-		ulong	vmaddr;
-		ulong	vmsize;
-		ulong	fileoff;
-		ulong	filesize;
-		ulong	maxprot;
-		ulong	initprot;
-		ulong	nsects;
-		ulong	flags;
+		uint32	vmaddr;
+		uint32	vmsize;
+		uint32	fileoff;
+		uint32	filesize;
+		uint32	maxprot;
+		uint32	initprot;
+		uint32	nsects;
+		uint32	flags;
 	}textc;
 	struct nextsect{
 		char	sectname[16];
 		char	segname[16];
-		ulong	addr;
-		ulong	size;
-		ulong	offset;
-		ulong	align;
-		ulong	reloff;
-		ulong	nreloc;
-		ulong	flags;
-		ulong	reserved1;
-		ulong	reserved2;
+		uint32	addr;
+		uint32	size;
+		uint32	offset;
+		uint32	align;
+		uint32	reloff;
+		uint32	nreloc;
+		uint32	flags;
+		uint32	reserved1;
+		uint32	reserved2;
 	}texts;
 	struct nextcmd	datac;
 	struct nextsect	datas;
 	struct nextsect	bsss;
 	struct nextsym{
-		ulong	cmd;
-		ulong	cmdsize;
-		ulong	symoff;
-		ulong	nsyms;
-		ulong	spoff;
-		ulong	pcoff;
+		uint32	cmd;
+		uint32	cmdsize;
+		uint32	symoff;
+		uint32	nsyms;
+		uint32	spoff;
+		uint32	pcoff;
 	}symc;
 */
 };
@@ -146,20 +146,20 @@ struct i386exec
 {
 /* UNUSED
 	struct	i386coff{
-		ulong	isectmagic;
-		ulong	itime;
-		ulong	isyms;
-		ulong	insyms;
-		ulong	iflags;
+		uint32	isectmagic;
+		uint32	itime;
+		uint32	isyms;
+		uint32	insyms;
+		uint32	iflags;
 	};
 	struct	i386hdr{
-		ulong	imagic;
-		ulong	itextsize;
-		ulong	idatasize;
-		ulong	ibsssize;
-		ulong	ientry;
-		ulong	itextstart;
-		ulong	idatastart;
+		uint32	imagic;
+		uint32	itextsize;
+		uint32	idatasize;
+		uint32	ibsssize;
+		uint32	ientry;
+		uint32	itextstart;
+		uint32	idatastart;
 	};
 	struct coffsect	itexts;
 	struct coffsect idatas;
diff --git a/include/mach_amd64.h b/include/mach_amd64.h
index eb046d8cf7..4a3bf20e69 100644
--- a/include/mach_amd64.h
+++ b/include/mach_amd64.h
@@ -42,14 +42,14 @@
 typedef	struct	Exec	Exec;
 struct	Exec
 {
-	long	magic;		/* magic number */
-	long	text;	 	/* size of text segment */
-	long	data;	 	/* size of initialized data */
-	long	bss;	  	/* size of uninitialized data */
-	long	syms;	 	/* size of symbol table */
-	long	entry;	 	/* entry point */
-	long	spsz;		/* size of pc/sp offset table */
-	long	pcsz;		/* size of pc/line number table */
+	int32	magic;		/* magic number */
+	int32	text;	 	/* size of text segment */
+	int32	data;	 	/* size of initialized data */
+	int32	bss;	  	/* size of uninitialized data */
+	int32	syms;	 	/* size of symbol table */
+	int32	entry;	 	/* entry point */
+	int32	spsz;		/* size of pc/sp offset table */
+	int32	pcsz;		/* size of pc/line number table */
 };
 
 #define HDR_MAGIC	0x00008000		/* header expansion */
@@ -263,8 +263,8 @@ struct Mach{
 	char	*name;
 	int	mtype;			/* machine type code */
 	Reglist *reglist;		/* register set */
-	long	regsize;		/* sizeof registers in bytes */
-	long	fpregsize;		/* sizeof fp registers in bytes */
+	int32	regsize;		/* sizeof registers in bytes */
+	int32	fpregsize;		/* sizeof fp registers in bytes */
 	char	*pc;			/* pc name */
 	char	*sp;			/* sp name */
 	char	*link;			/* link register name */
@@ -291,12 +291,12 @@ struct	Machdata {		/* Machine-dependent debugger support */
 	short	bpsize;				/* size of break point instr. */
 
 	ushort	(*swab)(ushort);		/* ushort to local byte order */
-	ulong	(*swal)(ulong);			/* ulong to local byte order */
+	uint32	(*swal)(uint32);			/* uint32 to local byte order */
 	uvlong	(*swav)(uvlong);		/* uvlong to local byte order */
 	int	(*ctrace)(Map*, uvlong, uvlong, uvlong, Tracer); /* C traceback */
 	uvlong	(*findframe)(Map*, uvlong, uvlong, uvlong, uvlong);/* frame finder */
 	char*	(*excep)(Map*, Rgetter);	/* last exception */
-	ulong	(*bpfix)(uvlong);		/* breakpoint fixup */
+	uint32	(*bpfix)(uvlong);		/* breakpoint fixup */
 	int	(*sftos)(char*, int, void*);	/* single precision float */
 	int	(*dftos)(char*, int, void*);	/* double precision float */
 	int	(*foll)(Map*, uvlong, Rgetter, uvlong*);/* follow set */
@@ -315,7 +315,7 @@ typedef struct Fhdr
 	uchar	hdrsz;		/* header size */
 	uchar	_magic;		/* _MAGIC() magic */
 	uchar	spare;
-	long	magic;		/* magic number */
+	int32	magic;		/* magic number */
 	uvlong	txtaddr;	/* text address */
 	vlong	txtoff;		/* start of text in file */
 	uvlong	dataddr;	/* start of data segment */
@@ -324,12 +324,12 @@ typedef struct Fhdr
 	uvlong	entry;		/* entry point */
 	vlong	sppcoff;	/* offset of sp-pc table in file */
 	vlong	lnpcoff;	/* offset of line number-pc table in file */
-	long	txtsz;		/* text size */
-	long	datsz;		/* size of data seg */
-	long	bsssz;		/* size of bss */
-	long	symsz;		/* size of symbol table */
-	long	sppcsz;		/* size of sp-pc table */
-	long	lnpcsz;		/* size of line number-pc table */
+	int32	txtsz;		/* text size */
+	int32	datsz;		/* size of data seg */
+	int32	bsssz;		/* size of bss */
+	int32	symsz;		/* size of symbol table */
+	int32	sppcsz;		/* size of sp-pc table */
+	int32	lnpcsz;		/* size of line number-pc table */
 } Fhdr;
 
 extern	int	asstype;	/* dissembler type - machdata.c */
@@ -340,14 +340,14 @@ int		beieee80ftos(char*, int, void*);
 int		beieeesftos(char*, int, void*);
 int		beieeedftos(char*, int, void*);
 ushort		beswab(ushort);
-ulong		beswal(ulong);
+uint32		beswal(uint32);
 uvlong		beswav(uvlong);
 uvlong		ciscframe(Map*, uvlong, uvlong, uvlong, uvlong);
 int		cisctrace(Map*, uvlong, uvlong, uvlong, Tracer);
 int		crackhdr(int fd, Fhdr*);
-uvlong		file2pc(char*, long);
+uvlong		file2pc(char*, int32);
 int		fileelem(Sym**, uchar *, char*, int);
-long		fileline(char*, int, uvlong);
+int32		fileline(char*, int, uvlong);
 int		filesym(int, char*, int);
 int		findlocal(Symbol*, char*, Symbol*);
 int		findseg(Map*, char*);
@@ -356,23 +356,23 @@ int		fnbound(uvlong, uvlong*);
 int		fpformat(Map*, Reglist*, char*, int, int);
 int		get1(Map*, uvlong, uchar*, int);
 int		get2(Map*, uvlong, ushort*);
-int		get4(Map*, uvlong, ulong*);
+int		get4(Map*, uvlong, uint32*);
 int		get8(Map*, uvlong, uvlong*);
 int		geta(Map*, uvlong, uvlong*);
 int		getauto(Symbol*, int, int, Symbol*);
 Sym*		getsym(int);
 int		globalsym(Symbol *, int);
-char*		_hexify(char*, ulong, int);
-int		ieeesftos(char*, int, ulong);
-int		ieeedftos(char*, int, ulong, ulong);
+char*		_hexify(char*, uint32, int);
+int		ieeesftos(char*, int, uint32);
+int		ieeedftos(char*, int, uint32, uint32);
 int		isar(Biobuf*);
 int		leieee80ftos(char*, int, void*);
 int		leieeesftos(char*, int, void*);
 int		leieeedftos(char*, int, void*);
 ushort		leswab(ushort);
-ulong		leswal(ulong);
+uint32		leswal(uint32);
 uvlong		leswav(uvlong);
-uvlong		line2addr(long, uvlong, uvlong);
+uvlong		line2addr(int32, uvlong, uvlong);
 Map*		loadmap(Map*, int, Fhdr*);
 int		localaddr(Map*, char*, char*, uvlong*, Rgetter);
 int		localsym(Symbol*, int);
@@ -384,10 +384,10 @@ Map*		newmap(Map*, int);
 void		objtraverse(void(*)(Sym*, void*), void*);
 int		objtype(Biobuf*, char**);
 uvlong		pc2sp(uvlong);
-long		pc2line(uvlong);
+int32		pc2line(uvlong);
 int		put1(Map*, uvlong, uchar*, int);
 int		put2(Map*, uvlong, ushort);
-int		put4(Map*, uvlong, ulong);
+int		put4(Map*, uvlong, uint32);
 int		put8(Map*, uvlong, uvlong);
 int		puta(Map*, uvlong, uvlong);
 int		readar(Biobuf*, int, vlong, int);
@@ -395,7 +395,7 @@ int		readobj(Biobuf*, int);
 uvlong		riscframe(Map*, uvlong, uvlong, uvlong, uvlong);
 int		risctrace(Map*, uvlong, uvlong, uvlong, Tracer);
 int		setmap(Map*, int, uvlong, uvlong, vlong, char*);
-Sym*		symbase(long*);
+Sym*		symbase(int32*);
 int		syminit(int, Fhdr*);
 int		symoff(char*, int, uvlong, int);
 void		textseg(uvlong, Fhdr*);
diff --git a/include/u.h b/include/u.h
index 9b7bccb1a2..1b196286eb 100644
--- a/include/u.h
+++ b/include/u.h
@@ -173,6 +173,16 @@ typedef intptr_t intptr;
 typedef uint32_t u32int;
 typedef int32_t s32int;
 
+typedef s8int int8;
+typedef u8int uint8;
+typedef s16int int16;
+typedef u16int uint16;
+typedef s32int int32;
+typedef u32int uint32;
+typedef s64int int64;
+typedef u64int uint64;
+
+
 #undef _NEEDUCHAR
 #undef _NEEDUSHORT
 #undef _NEEDUINT
diff --git a/include/ureg_x86.h b/include/ureg_x86.h
index 84d32fccb9..c20fe4e4c4 100644
--- a/include/ureg_x86.h
+++ b/include/ureg_x86.h
@@ -28,26 +28,26 @@
 
 struct Ureg
 {
-	ulong	di;		/* general registers */
-	ulong	si;		/* ... */
-	ulong	bp;		/* ... */
-	ulong	nsp;
-	ulong	bx;		/* ... */
-	ulong	dx;		/* ... */
-	ulong	cx;		/* ... */
-	ulong	ax;		/* ... */
-	ulong	gs;		/* data segments */
-	ulong	fs;		/* ... */
-	ulong	es;		/* ... */
-	ulong	ds;		/* ... */
-	ulong	trap;		/* trap type */
-	ulong	ecode;		/* error code (or zero) */
-	ulong	pc;		/* pc */
-	ulong	cs;		/* old context */
-	ulong	flags;		/* old flags */
+	uint32	di;		/* general registers */
+	uint32	si;		/* ... */
+	uint32	bp;		/* ... */
+	uint32	nsp;
+	uint32	bx;		/* ... */
+	uint32	dx;		/* ... */
+	uint32	cx;		/* ... */
+	uint32	ax;		/* ... */
+	uint32	gs;		/* data segments */
+	uint32	fs;		/* ... */
+	uint32	es;		/* ... */
+	uint32	ds;		/* ... */
+	uint32	trap;		/* trap type */
+	uint32	ecode;		/* error code (or zero) */
+	uint32	pc;		/* pc */
+	uint32	cs;		/* old context */
+	uint32	flags;		/* old flags */
 	union {
-		ulong	usp;
-		ulong	sp;
+		uint32	usp;
+		uint32	sp;
 	};
-	ulong	ss;		/* old stack segment */
+	uint32	ss;		/* old stack segment */
 };
diff --git a/src/cmd/6a/a.h b/src/cmd/6a/a.h
index 47adbc81f3..10ac389ddc 100644
--- a/src/cmd/6a/a.h
+++ b/src/cmd/6a/a.h
@@ -32,7 +32,6 @@
 #include <libc.h>
 #include <bio.h>
 #include "../6l/6.out.h"
-#include "compat.h"
 
 
 #ifndef	EXTERN
@@ -119,7 +118,7 @@ struct	Hist
 {
 	Hist*	link;
 	char*	name;
-	long	line;
+	int32	line;
 	vlong	offset;
 };
 #define	H	((Hist*)0)
@@ -145,24 +144,24 @@ EXTERN	char*	include[NINCLUDE];
 EXTERN	Io*	iofree;
 EXTERN	Io*	ionext;
 EXTERN	Io*	iostack;
-EXTERN	long	lineno;
+EXTERN	int32	lineno;
 EXTERN	int	nerrors;
-EXTERN	long	nhunk;
+EXTERN	int32	nhunk;
 EXTERN	int	ninclude;
 EXTERN	Gen	nullgen;
 EXTERN	char*	outfile;
 EXTERN	int	pass;
 EXTERN	char*	pathname;
-EXTERN	long	pc;
+EXTERN	int32	pc;
 EXTERN	int	peekc;
 EXTERN	int	sym;
 EXTERN	char	symb[NSYMB];
 EXTERN	int	thechar;
 EXTERN	char*	thestring;
-EXTERN	long	thunk;
+EXTERN	int32	thunk;
 EXTERN	Biobuf	obuf;
 
-void*	allocn(void*, long, long);
+void*	allocn(void*, int32, int32);
 void	errorexit(void);
 void	pushio(void);
 void	newio(void);
@@ -170,7 +169,7 @@ void	newfile(char*, int);
 Sym*	slookup(char*);
 Sym*	lookup(void);
 void	syminit(Sym*);
-long	yylex(void);
+int32	yylex(void);
 int	getc(void);
 int	getnsc(void);
 void	unget(int);
@@ -197,7 +196,7 @@ void	maclin(void);
 void	macif(int);
 void	macend(void);
 void	dodefine(char*);
-void	prfile(long);
+void	prfile(int32);
 void	linehist(char*, int);
 void	gethunk(void);
 void	yyerror(char*, ...);
diff --git a/src/cmd/6a/lex.c b/src/cmd/6a/lex.c
index 6bd20783be..22539fc7ea 100644
--- a/src/cmd/6a/lex.c
+++ b/src/cmd/6a/lex.c
@@ -1102,7 +1102,7 @@ zname(char *n, int t, int s)
 void
 zaddr(Gen *a, int s)
 {
-	long l;
+	int32 l;
 	int i, t;
 	char *n;
 	Ieee e;
diff --git a/src/cmd/6c/cgen.c b/src/cmd/6c/cgen.c
index 3027325f7f..b9ff040702 100644
--- a/src/cmd/6c/cgen.c
+++ b/src/cmd/6c/cgen.c
@@ -40,7 +40,7 @@ cgen(Node *n, Node *nn)
 	Prog *p1;
 	Node nod, nod1, nod2, nod3, nod4;
 	int o, hardleft;
-	long v, curs;
+	int32 v, curs;
 	vlong c;
 
 	if(debug['g']) {
@@ -1048,7 +1048,7 @@ cgen(Node *n, Node *nn)
 			diag(n, "DOT and no offset");
 			break;
 		}
-		nod.xoffset += (long)r->vconst;
+		nod.xoffset += (int32)r->vconst;
 		nod.type = n->type;
 		cgen(&nod, nn);
 		break;
@@ -1150,7 +1150,7 @@ void
 reglcgen(Node *t, Node *n, Node *nn)
 {
 	Node *r;
-	long v;
+	int32 v;
 
 	regialloc(t, n, nn);
 	if(n->op == OIND) {
@@ -1234,7 +1234,7 @@ boolgen(Node *n, int true, Node *nn)
 	int o;
 	Prog *p1, *p2;
 	Node *l, *r, nod, nod1;
-	long curs;
+	int32 curs;
 
 	if(debug['g']) {
 		prtree(nn, "boolgen lhs");
@@ -1418,7 +1418,7 @@ boolgen(Node *n, int true, Node *nn)
 }
 
 void
-sugen(Node *n, Node *nn, long w)
+sugen(Node *n, Node *nn, int32 w)
 {
 	Prog *p1;
 	Node nod0, nod1, nod2, nod3, nod4, *l, *r;
@@ -1460,7 +1460,7 @@ sugen(Node *n, Node *nn, long w)
 			diag(n, "DOT and no offset");
 			break;
 		}
-		nod1.xoffset += (long)r->vconst;
+		nod1.xoffset += (int32)r->vconst;
 		nod1.type = n->type;
 		sugen(&nod1, nn, w);
 		break;
@@ -1846,7 +1846,7 @@ layout(Node *f, Node *t, int c, int cv, Node *cn)
 int
 immconst(Node *n)
 {
-	long v;
+	int32 v;
 
 	if(n->op != OCONST || !typechlpv[n->type->etype])
 		return 0;
@@ -1916,22 +1916,22 @@ vaddr(Node *n, int a)
 	return 0;
 }
 
-long
+int32
 hi64v(Node *n)
 {
 	if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
-		return (long)(n->vconst) & ~0L;
+		return (int32)(n->vconst) & ~0L;
 	else
-		return (long)((uvlong)n->vconst>>32) & ~0L;
+		return (int32)((uvlong)n->vconst>>32) & ~0L;
 }
 
-long
+int32
 lo64v(Node *n)
 {
 	if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
-		return (long)((uvlong)n->vconst>>32) & ~0L;
+		return (int32)((uvlong)n->vconst>>32) & ~0L;
 	else
-		return (long)(n->vconst) & ~0L;
+		return (int32)(n->vconst) & ~0L;
 }
 
 Node *
diff --git a/src/cmd/6c/div.c b/src/cmd/6c/div.c
index 4b63ddc1e8..d67ef8df78 100644
--- a/src/cmd/6c/div.c
+++ b/src/cmd/6c/div.c
@@ -41,7 +41,7 @@
 #define	T32	TN(32)
 
 int
-multiplier(ulong d, int p, uvlong *mp)
+multiplier(uint32 d, int p, uvlong *mp)
 {
 	int l;
 	uvlong mlo, mhi, tlo, thi;
@@ -67,7 +67,7 @@ multiplier(ulong d, int p, uvlong *mp)
 }
 
 int
-sdiv(ulong d, ulong *mp, int *sp)
+sdiv(uint32 d, uint32 *mp, int *sp)
 {
 	int s;
 	uvlong m;
@@ -82,7 +82,7 @@ sdiv(ulong d, ulong *mp, int *sp)
 }
 
 int
-udiv(ulong d, ulong *mp, int *sp, int *pp)
+udiv(uint32 d, uint32 *mp, int *sp, int *pp)
 {
 	int p, s;
 	uvlong m;
@@ -113,7 +113,7 @@ void
 sdivgen(Node *l, Node *r, Node *ax, Node *dx)
 {
 	int a, s;
-	ulong m;
+	uint32 m;
 	vlong c;
 
 	c = r->vconst;
@@ -137,7 +137,7 @@ void
 udivgen(Node *l, Node *r, Node *ax, Node *dx)
 {
 	int a, s, t;
-	ulong m;
+	uint32 m;
 	Node nod;
 
 	a = udiv(r->vconst, &m, &s, &t);
@@ -184,7 +184,7 @@ sext(Node *d, Node *s, Node *l)
 }
 
 void
-sdiv2(long c, int v, Node *l, Node *n)
+sdiv2(int32 c, int v, Node *l, Node *n)
 {
 	Node nod;
 
@@ -206,7 +206,7 @@ sdiv2(long c, int v, Node *l, Node *n)
 }
 
 void
-smod2(long c, int v, Node *l, Node *n)
+smod2(int32 c, int v, Node *l, Node *n)
 {
 	Node nod;
 
diff --git a/src/cmd/6c/gc.h b/src/cmd/6c/gc.h
index dee9966cab..8e442c0add 100644
--- a/src/cmd/6c/gc.h
+++ b/src/cmd/6c/gc.h
@@ -83,7 +83,7 @@ struct	Prog
 	Adr	from;
 	Adr	to;
 	Prog*	link;
-	long	lineno;
+	int32	lineno;
 	short	as;
 };
 #define	P	((Prog*)0)
@@ -92,7 +92,7 @@ struct	Case
 {
 	Case*	link;
 	vlong	val;
-	long	label;
+	int32	label;
 	char	def;
 	char	isv;
 };
@@ -101,7 +101,7 @@ struct	Case
 struct	C1
 {
 	vlong	val;
-	long	label;
+	int32	label;
 };
 
 struct	Var
@@ -114,8 +114,8 @@ struct	Var
 
 struct	Reg
 {
-	long	pc;
-	long	rpo;		/* reverse post ordering */
+	int32	pc;
+	int32	rpo;		/* reverse post ordering */
 
 	Bits	set;
 	Bits	use1;
@@ -128,11 +128,11 @@ struct	Reg
 	Bits	regdiff;
 	Bits	act;
 
-	long	regu;
-	long	loop;		/* could be shorter */
+	int32	regu;
+	int32	loop;		/* could be shorter */
 
 	Reg*	log5;
-	long	active;
+	int32	active;
 
 	Reg*	p1;
 	Reg*	p2;
@@ -161,26 +161,26 @@ struct	Rgn
 	short	regno;
 };
 
-EXTERN	long	breakpc;
-EXTERN	long	nbreak;
+EXTERN	int32	breakpc;
+EXTERN	int32	nbreak;
 EXTERN	Case*	cases;
 EXTERN	Node	constnode;
 EXTERN	Node	fconstnode;
 EXTERN	Node	vconstnode;
-EXTERN	long	continpc;
-EXTERN	long	curarg;
-EXTERN	long	cursafe;
+EXTERN	int32	continpc;
+EXTERN	int32	curarg;
+EXTERN	int32	cursafe;
 EXTERN	Prog*	firstp;
 EXTERN	Prog*	lastp;
-EXTERN	long	maxargsafe;
+EXTERN	int32	maxargsafe;
 EXTERN	int	mnstring;
 EXTERN	Node*	nodrat;
 EXTERN	Node*	nodret;
 EXTERN	Node*	nodsafe;
-EXTERN	long	nrathole;
-EXTERN	long	nstring;
+EXTERN	int32	nrathole;
+EXTERN	int32	nstring;
 EXTERN	Prog*	p;
-EXTERN	long	pc;
+EXTERN	int32	pc;
 EXTERN	Node	lregnode;
 EXTERN	Node	qregnode;
 EXTERN	char	string[NSNAME];
@@ -188,8 +188,8 @@ EXTERN	Sym*	symrathole;
 EXTERN	Node	znode;
 EXTERN	Prog	zprog;
 EXTERN	int	reg[D_NONE];
-EXTERN	long	exregoffset;
-EXTERN	long	exfregoffset;
+EXTERN	int32	exregoffset;
+EXTERN	int32	exfregoffset;
 EXTERN	uchar	typechlpv[NTYPE];
 
 #define	BLOAD(r)	band(bnot(r->refbehind), r->refahead)
@@ -214,8 +214,8 @@ EXTERN	Bits	params;
 EXTERN	Bits	consts;
 EXTERN	Bits	addrs;
 
-EXTERN	long	regbits;
-EXTERN	long	exregbits;
+EXTERN	int32	regbits;
+EXTERN	int32	exregbits;
 
 EXTERN	int	change;
 EXTERN	int	suppress;
@@ -225,9 +225,9 @@ EXTERN	Reg*	lastr;
 EXTERN	Reg	zreg;
 EXTERN	Reg*	freer;
 EXTERN	Var	var[NVAR];
-EXTERN	long*	idom;
+EXTERN	int32*	idom;
 EXTERN	Reg**	rpo2r;
-EXTERN	long	maxnr;
+EXTERN	int32	maxnr;
 
 extern	char*	anames[];
 
@@ -251,7 +251,7 @@ void	reglcgen(Node*, Node*, Node*);
 void	lcgen(Node*, Node*);
 void	bcgen(Node*, int);
 void	boolgen(Node*, int, Node*);
-void	sugen(Node*, Node*, long);
+void	sugen(Node*, Node*, int32);
 int	needreg(Node*, int);
 int	hardconst(Node*);
 int	immconst(Node*);
@@ -272,7 +272,7 @@ void	gclean(void);
 void	nextpc(void);
 void	gargs(Node*, Node*, Node*);
 void	garg1(Node*, Node*, Node*, int, Node**);
-Node*	nodconst(long);
+Node*	nodconst(int32);
 Node*	nodfconst(double);
 Node*	nodgconst(vlong, Type*);
 int	nodreg(Node*, Node*, int);
@@ -293,7 +293,7 @@ void	gins(int a, Node*, Node*);
 void	gopcode(int, Type*, Node*, Node*);
 int	samaddr(Node*, Node*);
 void	gbranch(int);
-void	patch(Prog*, long);
+void	patch(Prog*, int32);
 int	sconst(Node*);
 void	gpseudo(int, Sym*, Node*);
 
@@ -302,14 +302,14 @@ void	gpseudo(int, Sym*, Node*);
  */
 int	swcmp(const void*, const void*);
 void	doswit(Node*);
-void	swit1(C1*, int, long, Node*);
+void	swit1(C1*, int, int32, Node*);
 void	cas(void);
 void	bitload(Node*, Node*, Node*, Node*, Node*);
 void	bitstore(Node*, Node*, Node*, Node*, Node*);
-long	outstring(char*, long);
+int32	outstring(char*, int32);
 void	nullwarn(Node*, Node*);
-void	sextern(Sym*, Node*, long, long);
-void	gextern(Sym*, Node*, long, long);
+void	sextern(Sym*, Node*, int32, int32);
+void	gextern(Sym*, Node*, int32, int32);
 void	outcode(void);
 void	ieeedtod(Ieee*, double);
 
@@ -334,12 +334,12 @@ void	regopt(Prog*);
 void	addmove(Reg*, int, int, int);
 Bits	mkvar(Reg*, Adr*);
 void	prop(Reg*, Bits, Bits);
-void	loopit(Reg*, long);
+void	loopit(Reg*, int32);
 void	synch(Reg*, Bits);
-ulong	allreg(ulong, Rgn*);
+uint32	allreg(uint32, Rgn*);
 void	paint1(Reg*, int);
-ulong	paint2(Reg*, int);
-void	paint3(Reg*, int, long, int);
+uint32	paint2(Reg*, int);
+void	paint3(Reg*, int, int32, int);
 void	addreg(Adr*, int);
 
 /*
@@ -361,10 +361,10 @@ int	copyau(Adr*, Adr*);
 int	copysub(Adr*, Adr*, Adr*, int);
 int	copysub1(Prog*, Adr*, Adr*, int);
 
-long	RtoB(int);
-long	FtoB(int);
-int	BtoR(long);
-int	BtoF(long);
+int32	RtoB(int);
+int32	FtoB(int);
+int	BtoR(int32);
+int	BtoF(int32);
 
 #define	D_HI	D_NONE
 #define	D_LO	D_NONE
@@ -383,8 +383,8 @@ int	cond(int);
 int	com64(Node*);
 void	com64init(void);
 void	bool64(Node*);
-long	lo64v(Node*);
-long	hi64v(Node*);
+int32	lo64v(Node*);
+int32	hi64v(Node*);
 Node*	lo64(Node*);
 Node*	hi64(Node*);
 
@@ -393,8 +393,8 @@ Node*	hi64(Node*);
  */
 void	sdivgen(Node*, Node*, Node*, Node*);
 void	udivgen(Node*, Node*, Node*, Node*);
-void	sdiv2(long, int, Node*, Node*);
-void	smod2(long, int, Node*, Node*);
+void	sdiv2(int32, int, Node*, Node*);
+void	smod2(int32, int, Node*, Node*);
 void	mulgen(Type*, Node*, Node*);
 void	genmuladd(Node*, Node*, int, Node*);
 void	shiftit(Type*, Node*, Node*);
diff --git a/src/cmd/6c/mul.c b/src/cmd/6c/mul.c
index 7fd2012f11..eefeacaeda 100644
--- a/src/cmd/6c/mul.c
+++ b/src/cmd/6c/mul.c
@@ -40,7 +40,7 @@ struct	Malg
 
 struct	Mparam
 {
-	ulong	value;
+	uint32	value;
 	char	alg;
 	char	neg;
 	char	shift;
@@ -64,10 +64,10 @@ static	Malg	malgs[]	=
  * return position of lowest 1
  */
 int
-lowbit(ulong v)
+lowbit(uint32 v)
 {
 	int s, i;
-	ulong m;
+	uint32 m;
 
 	s = 0;
 	m = 0xFFFFFFFFUL;
@@ -97,13 +97,13 @@ genmuladd(Node *d, Node *s, int m, Node *a)
 }
 
 void
-mulparam(ulong m, Mparam *mp)
+mulparam(uint32 m, Mparam *mp)
 {
 	int c, i, j, n, o, q, s;
 	int bc, bi, bn, bo, bq, bs, bt;
 	char *p;
-	long u;
-	ulong t;
+	int32 u;
+	uint32 t;
 
 	bc = bq = 10;
 	bi = bn = bo = bs = bt = 0;
@@ -122,7 +122,7 @@ mulparam(ulong m, Mparam *mp)
 				u = -u;
 			}
 			n = lowbit(u);
-			t = (ulong)u >> n;
+			t = (uint32)u >> n;
 			switch(i) {
 			case 0:
 				if(t == 1) {
@@ -321,9 +321,9 @@ m2(int a)
 void
 shiftit(Type *t, Node *s, Node *d)
 {
-	long c;
+	int32 c;
 
-	c = (long)s->vconst & 31;
+	c = (int32)s->vconst & 31;
 	switch(c) {
 	case 0:
 		break;
@@ -336,7 +336,7 @@ shiftit(Type *t, Node *s, Node *d)
 }
 
 static int
-mulgen1(ulong v, Node *n)
+mulgen1(uint32 v, Node *n)
 {
 	int i, o;
 	Mparam *p;
diff --git a/src/cmd/6c/pgen.c b/src/cmd/6c/pgen.c
index 22ecd5f9c8..367347e116 100644
--- a/src/cmd/6c/pgen.c
+++ b/src/cmd/6c/pgen.c
@@ -34,7 +34,7 @@ vlong
 argsize(void)
 {
 	Type *t;
-	long s;
+	int32 s;
 
 //print("t=%T\n", thisfn);
 	s = 0;
@@ -125,7 +125,7 @@ void
 supgen(Node *n)
 {
 	int owarn;
-	long spc;
+	int32 spc;
 	Prog *sp;
 
 	if(n == Z)
@@ -149,7 +149,7 @@ gen(Node *n)
 	Node *l, nod;
 	Prog *sp, *spc, *spb;
 	Case *cn;
-	long sbc, scc;
+	int32 sbc, scc;
 	int snbreak, sncontin;
 	int f, o, oldreach;
 
diff --git a/src/cmd/6c/pswt.c b/src/cmd/6c/pswt.c
index f4149f17b3..02d4e64a05 100644
--- a/src/cmd/6c/pswt.c
+++ b/src/cmd/6c/pswt.c
@@ -47,7 +47,7 @@ doswit(Node *n)
 {
 	Case *c;
 	C1 *q, *iq;
-	long def, nc, i, isv;
+	int32 def, nc, i, isv;
 
 	def = 0;
 	nc = 0;
@@ -74,7 +74,7 @@ doswit(Node *n)
 		if(isv)
 			q->val = c->val;
 		else
-			q->val = (long)c->val;	/* cast ensures correct value for 32-bit switch on 64-bit architecture */
+			q->val = (int32)c->val;	/* cast ensures correct value for 32-bit switch on 64-bit architecture */
 		q++;
 	}
 	qsort(iq, nc, sizeof(C1), swcmp);
@@ -101,12 +101,12 @@ cas(void)
 	cases = c;
 }
 
-long
-outlstring(ushort *s, long n)
+int32
+outlstring(ushort *s, int32 n)
 {
 	char buf[2];
 	int c;
-	long r;
+	int32 r;
 
 	if(suppress)
 		return nstring;
@@ -164,5 +164,5 @@ ieeedtod(Ieee *ieee, double native)
 	fr = modf(fr*f, &ho);
 	ieee->l = ho;
 	ieee->l <<= 16;
-	ieee->l |= (long)(fr*f);
+	ieee->l |= (int32)(fr*f);
 }
diff --git a/src/cmd/6c/reg.c b/src/cmd/6c/reg.c
index a03d1ca47b..431501202e 100644
--- a/src/cmd/6c/reg.c
+++ b/src/cmd/6c/reg.c
@@ -66,13 +66,13 @@ regopt(Prog *p)
 	Reg *r, *r1, *r2;
 	Prog *p1;
 	int i, z;
-	long initpc, val, npc;
-	ulong vreg;
+	int32 initpc, val, npc;
+	uint32 vreg;
 	Bits bit;
 	struct
 	{
-		long	m;
-		long	c;
+		int32	m;
+		int32	c;
 		Reg*	p;
 	} log5[6], *lp;
 
@@ -721,10 +721,10 @@ addmove(Reg *r, int bn, int rn, int f)
 		print("%P\t.a%P\n", p, p1);
 }
 
-ulong
+uint32
 doregbits(int r)
 {
-	ulong b;
+	uint32 b;
 
 	b = 0;
 	if(r >= D_INDIR)
@@ -748,7 +748,7 @@ mkvar(Reg *r, Adr *a)
 {
 	Var *v;
 	int i, t, n, et, z;
-	long o;
+	int32 o;
 	Bits bit;
 	Sym *s;
 
@@ -894,8 +894,8 @@ prop(Reg *r, Bits ref, Bits cal)
  *	such a node is a loop head.
  *	recursively, all preds with a greater rpo number are in the loop
  */
-long
-postorder(Reg *r, Reg **rpo2r, long n)
+int32
+postorder(Reg *r, Reg **rpo2r, int32 n)
 {
 	Reg *r1;
 
@@ -911,10 +911,10 @@ postorder(Reg *r, Reg **rpo2r, long n)
 	return n;
 }
 
-long
-rpolca(long *idom, long rpo1, long rpo2)
+int32
+rpolca(int32 *idom, int32 rpo1, int32 rpo2)
 {
-	long t;
+	int32 t;
 
 	if(rpo1 == -1)
 		return rpo2;
@@ -935,7 +935,7 @@ rpolca(long *idom, long rpo1, long rpo2)
 }
 
 int
-doms(long *idom, long r, long s)
+doms(int32 *idom, int32 r, int32 s)
 {
 	while(s > r)
 		s = idom[s];
@@ -943,9 +943,9 @@ doms(long *idom, long r, long s)
 }
 
 int
-loophead(long *idom, Reg *r)
+loophead(int32 *idom, Reg *r)
 {
-	long src;
+	int32 src;
 
 	src = r->rpo;
 	if(r->p1 != R && doms(idom, src, r->p1->rpo))
@@ -957,7 +957,7 @@ loophead(long *idom, Reg *r)
 }
 
 void
-loopmark(Reg **rpo2r, long head, Reg *r)
+loopmark(Reg **rpo2r, int32 head, Reg *r)
 {
 	if(r->rpo < head || r->active == head)
 		return;
@@ -970,14 +970,14 @@ loopmark(Reg **rpo2r, long head, Reg *r)
 }
 
 void
-loopit(Reg *r, long nr)
+loopit(Reg *r, int32 nr)
 {
 	Reg *r1;
-	long i, d, me;
+	int32 i, d, me;
 
 	if(nr > maxnr) {
 		rpo2r = alloc(nr * sizeof(Reg*));
-		idom = alloc(nr * sizeof(long));
+		idom = alloc(nr * sizeof(int32));
 		maxnr = nr;
 	}
 
@@ -1040,8 +1040,8 @@ synch(Reg *r, Bits dif)
 	}
 }
 
-ulong
-allreg(ulong b, Rgn *r)
+uint32
+allreg(uint32 b, Rgn *r)
 {
 	Var *v;
 	int i;
@@ -1091,7 +1091,7 @@ paint1(Reg *r, int bn)
 	Reg *r1;
 	Prog *p;
 	int z;
-	ulong bb;
+	uint32 bb;
 
 	z = bn/32;
 	bb = 1L<<(bn%32);
@@ -1162,10 +1162,10 @@ paint1(Reg *r, int bn)
 	}
 }
 
-ulong
-regset(Reg *r, ulong bb)
+uint32
+regset(Reg *r, uint32 bb)
 {
-	ulong b, set;
+	uint32 b, set;
 	Adr v;
 	int c;
 
@@ -1183,10 +1183,10 @@ regset(Reg *r, ulong bb)
 	return set;
 }
 
-ulong
-reguse(Reg *r, ulong bb)
+uint32
+reguse(Reg *r, uint32 bb)
 {
-	ulong b, set;
+	uint32 b, set;
 	Adr v;
 	int c;
 
@@ -1202,12 +1202,12 @@ reguse(Reg *r, ulong bb)
 	return set;
 }
 
-ulong
+uint32
 paint2(Reg *r, int bn)
 {
 	Reg *r1;
 	int z;
-	ulong bb, vreg, x;
+	uint32 bb, vreg, x;
 
 	z = bn/32;
 	bb = 1L << (bn%32);
@@ -1263,12 +1263,12 @@ paint2(Reg *r, int bn)
 }
 
 void
-paint3(Reg *r, int bn, long rb, int rn)
+paint3(Reg *r, int bn, int32 rb, int rn)
 {
 	Reg *r1;
 	Prog *p;
 	int z;
-	ulong bb;
+	uint32 bb;
 
 	z = bn/32;
 	bb = 1L << (bn%32);
@@ -1342,7 +1342,7 @@ addreg(Adr *a, int rn)
 	a->type = rn;
 }
 
-long
+int32
 RtoB(int r)
 {
 
@@ -1352,7 +1352,7 @@ RtoB(int r)
 }
 
 int
-BtoR(long b)
+BtoR(int32 b)
 {
 
 	b &= 0xffffL;
@@ -1367,7 +1367,7 @@ BtoR(long b)
  *	17	X6
  *	18	X7
  */
-long
+int32
 FtoB(int f)
 {
 	if(f < FREGMIN || f > FREGEXT)
@@ -1376,7 +1376,7 @@ FtoB(int f)
 }
 
 int
-BtoF(long b)
+BtoF(int32 b)
 {
 
 	b &= 0x70000L;
diff --git a/src/cmd/6c/swt.c b/src/cmd/6c/swt.c
index 90bd545cc0..b3f31b04d4 100644
--- a/src/cmd/6c/swt.c
+++ b/src/cmd/6c/swt.c
@@ -31,7 +31,7 @@
 #include "gc.h"
 
 void
-swit1(C1 *q, int nc, long def, Node *n)
+swit1(C1 *q, int nc, int32 def, Node *n)
 {
 	C1 *r;
 	int i;
@@ -70,7 +70,7 @@ void
 bitload(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
 {
 	int sh;
-	long v;
+	int32 v;
 	Node *l;
 
 	/*
@@ -108,7 +108,7 @@ bitload(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
 void
 bitstore(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
 {
-	long v;
+	int32 v;
 	Node nod;
 	int sh;
 
@@ -132,10 +132,10 @@ bitstore(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
 	regfree(n3);
 }
 
-long
-outstring(char *s, long n)
+int32
+outstring(char *s, int32 n)
 {
-	long r;
+	int32 r;
 
 	if(suppress)
 		return nstring;
@@ -158,9 +158,9 @@ outstring(char *s, long n)
 }
 
 void
-sextern(Sym *s, Node *a, long o, long w)
+sextern(Sym *s, Node *a, int32 o, int32 w)
 {
-	long e, lw;
+	int32 e, lw;
 
 	for(e=0; e<w; e+=NSNAME) {
 		lw = NSNAME;
@@ -175,7 +175,7 @@ sextern(Sym *s, Node *a, long o, long w)
 }
 
 void
-gextern(Sym *s, Node *a, long o, long w)
+gextern(Sym *s, Node *a, int32 o, int32 w)
 {
 	if(0 && a->op == OCONST && typev[a->type->etype]) {
 		gpseudo(ADATA, s, lo64(a));
@@ -382,7 +382,7 @@ void
 zname(Biobuf *b, Sym *s, int t)
 {
 	char *n;
-	ulong sig;
+	uint32 sig;
 
 	if(debug['T'] && t == D_EXTERN && s->sig != SIGDONE && s->type != types[TENUM] && s != symrathole){
 		sig = sign(s);
@@ -411,7 +411,7 @@ zname(Biobuf *b, Sym *s, int t)
 void
 zaddr(Biobuf *b, Adr *a, int s)
 {
-	long l;
+	int32 l;
 	int i, t;
 	char *n;
 	Ieee e;
@@ -488,10 +488,10 @@ zaddr(Biobuf *b, Adr *a, int s)
 		Bputc(b, a->type);
 }
 
-long
-align(long i, Type *t, int op)
+int32
+align(int32 i, Type *t, int op)
 {
-	long o;
+	int32 o;
 	Type *v;
 	int w;
 
@@ -556,8 +556,8 @@ align(long i, Type *t, int op)
 	return o;
 }
 
-long
-maxround(long max, long v)
+int32
+maxround(int32 max, int32 v)
 {
 	v += SZ_VLONG-1;
 	if(v > max)
diff --git a/src/cmd/6c/txt.c b/src/cmd/6c/txt.c
index eb560f5f87..c7e52102f3 100644
--- a/src/cmd/6c/txt.c
+++ b/src/cmd/6c/txt.c
@@ -186,7 +186,7 @@ nextpc(void)
 void
 gargs(Node *n, Node *tn1, Node *tn2)
 {
-	long regs;
+	int32 regs;
 	Node fnxargs[20], *fnxp;
 
 	regs = cursafe;
@@ -276,13 +276,13 @@ Node*
 nodgconst(vlong v, Type *t)
 {
 	if(!typev[t->etype])
-		return nodconst((long)v);
+		return nodconst((int32)v);
 	vconstnode.vconst = v;
 	return &vconstnode;
 }
 
 Node*
-nodconst(long v)
+nodconst(int32 v)
 {
 	constnode.vconst = v;
 	return &constnode;
@@ -475,7 +475,7 @@ regind(Node *n, Node *nn)
 void
 naddr(Node *n, Adr *a)
 {
-	long v;
+	int32 v;
 
 	a->type = D_NONE;
 	if(n == Z)
@@ -1031,7 +1031,7 @@ gmove(Node *f, Node *t)
 		return;
 
 /*
- * ulong to float
+ * uvlong to float
  */
 	case CASE(	TUVLONG,	TDOUBLE):
 	case CASE(	TUVLONG,	TFLOAT):
@@ -1143,7 +1143,7 @@ void
 doindex(Node *n)
 {
 	Node nod, nod1;
-	long v;
+	int32 v;
 
 if(debug['Y'])
 prtree(n, "index");
@@ -1447,7 +1447,7 @@ gbranch(int o)
 }
 
 void
-patch(Prog *op, long pc)
+patch(Prog *op, int32 pc)
 {
 
 	op->to.offset = pc;
@@ -1473,7 +1473,7 @@ gpseudo(int a, Sym *s, Node *n)
 int
 sconst(Node *n)
 {
-	long v;
+	int32 v;
 
 	if(n->op == OCONST && !typefd[n->type->etype]) {
 		v = n->vconst;
@@ -1483,10 +1483,10 @@ sconst(Node *n)
 	return 0;
 }
 
-long
+int32
 exreg(Type *t)
 {
-	long o;
+	int32 o;
 
 	if(typechlpv[t->etype]) {
 		if(exregoffset <= REGEXT-4)
@@ -1521,7 +1521,7 @@ schar	ewidth[NTYPE] =
 	-1,		/*[TUNION]*/
 	SZ_INT,		/*[TENUM]*/
 };
-long	ncast[NTYPE] =
+int32	ncast[NTYPE] =
 {
 	0,				/*[TXXX]*/
 	BCHAR|BUCHAR,			/*[TCHAR]*/
diff --git a/src/cmd/6g/align.c b/src/cmd/6g/align.c
index 5d8a2fe09c..2ba6b04e74 100644
--- a/src/cmd/6g/align.c
+++ b/src/cmd/6g/align.c
@@ -24,7 +24,7 @@ static	int	wmax	= 8;	// max rounding
 
 /*
  * additionally, go declares several platform-specific type aliases:
- * ushort, short, uint, int, ulong, long, float, and double.  The bit
+ * ushort, short, uint, int, uint32, int32, float, and double.  The bit
  */
 static char*
 typedefs[] =
@@ -47,8 +47,8 @@ typedefs[] =
 
 };
 
-ulong
-rnd(ulong o, ulong r)
+uint32
+rnd(uint32 o, uint32 r)
 {
 	if(r > wmax)
 		r = wmax;
@@ -62,7 +62,7 @@ void
 offmod(Type *t)
 {
 	Type *f;
-	long o;
+	int32 o;
 
 	o = 0;
 	for(f=t->type; f!=T; f=f->down) {
@@ -75,11 +75,11 @@ offmod(Type *t)
 	}
 }
 
-ulong
-widstruct(Type *t, ulong o, int flag)
+uint32
+widstruct(Type *t, uint32 o, int flag)
 {
 	Type *f;
-	long w;
+	int32 w;
 
 	for(f=t->type; f!=T; f=f->down) {
 		if(f->etype != TFIELD)
@@ -100,7 +100,7 @@ widstruct(Type *t, ulong o, int flag)
 void
 dowidth(Type *t)
 {
-	ulong w;
+	uint32 w;
 
 	w = 0;
 	if(t == T)
diff --git a/src/cmd/6g/cgen.c b/src/cmd/6g/cgen.c
index 3661986c4f..412d3fa09b 100644
--- a/src/cmd/6g/cgen.c
+++ b/src/cmd/6g/cgen.c
@@ -244,7 +244,7 @@ agen(Node *n, Node *res)
 {
 	Node *nl, *nr;
 	Node n1, n2, n3, tmp;
-	ulong w;
+	uint32 w;
 	Type *t;
 
 	if(debug['g']) {
@@ -576,10 +576,10 @@ ret:
 }
 
 void
-sgen(Node *n, Node *ns, ulong w)
+sgen(Node *n, Node *ns, uint32 w)
 {
 	Node nodl, nodr;
-	long c;
+	int32 c;
 
 	if(debug['g']) {
 		dump("\nsgen-res", ns);
diff --git a/src/cmd/6g/gen.c b/src/cmd/6g/gen.c
index 3da034e249..c0d2b9df6c 100644
--- a/src/cmd/6g/gen.c
+++ b/src/cmd/6g/gen.c
@@ -22,7 +22,7 @@ compile(Node *fn)
 	Plist *pl;
 	Node nod1;
 	Prog *ptxt;
-	long lno;
+	int32 lno;
 
 if(newproc == N) {
 	newproc = nod(ONAME, N, N);
@@ -90,7 +90,7 @@ allocparams(void)
 	Iter list;
 	Type *t;
 	Node *n;
-	ulong w;
+	uint32 w;
 
 	/*
 	 * allocate (set xoffset) the stack
@@ -120,7 +120,7 @@ allocparams(void)
 void
 gen(Node *n)
 {
-	long lno;
+	int32 lno;
 	Prog *scontin, *sbreak;
 	Prog *p1, *p2, *p3;
 	Sym *s;
@@ -305,7 +305,7 @@ agen_inter(Node *n, Node *res)
 	Node nodo, nodr, nodt;
 	Sym *s;
 	char *e;
-	long o,lno;
+	int32 o,lno;
 
 	lno = setlineno(n);
 
@@ -420,7 +420,7 @@ swgen(Node *n)
 	Node n1, tmp;
 	Case *s0, *se, *s;
 	Prog *p1, *dflt;
-	long lno;
+	int32 lno;
 	int any;
 	Iter save1, save2;
 
@@ -791,7 +791,7 @@ cgen_asop(Node *n)
 {
 	Node n1, n2, n3, n4;
 	Node *nl, *nr;
-	long lno;
+	int32 lno;
 
 	nl = n->left;
 	nr = n->right;
@@ -837,7 +837,7 @@ cgen_as(Node *nl, Node *nr, int op)
 {
 	Node nc, n1;
 	Type *tl;
-	ulong w, c;
+	uint32 w, c;
 
 	if(nl == N)
 		return;
diff --git a/src/cmd/6g/gg.h b/src/cmd/6g/gg.h
index 9b35228528..bf6a66b90e 100644
--- a/src/cmd/6g/gg.h
+++ b/src/cmd/6g/gg.h
@@ -34,8 +34,8 @@ struct	Addr
 struct	Prog
 {
 	short	as;		// opcode
-	ulong	loc;		// pc offset in this func
-	ulong	lineno;		// source line that generated this
+	uint32	loc;		// pc offset in this func
+	uint32	lineno;		// source line that generated this
 	Addr	from;		// src address
 	Addr	to;		// dst address
 	Prog*	link;		// next instruction in this func
@@ -57,8 +57,8 @@ struct Sig
 {
 	char*	name;
 	Sym*	sym;
-	ulong	hash;
-	long	offset;
+	uint32	hash;
+	int32	offset;
 	Sig*	link;
 };
 
@@ -87,14 +87,14 @@ EXTERN	Plist*	plast;
 EXTERN	Pool*	poolist;
 EXTERN	Pool*	poolast;
 EXTERN	Biobuf*	bout;
-EXTERN	long	dynloc;
+EXTERN	int32	dynloc;
 EXTERN	uchar	reg[D_NONE];
 EXTERN	ushort	txt[NTYPE*NTYPE];
-EXTERN	long	maxround;
-EXTERN	long	widthptr;
+EXTERN	int32	maxround;
+EXTERN	int32	widthptr;
 EXTERN	Sym*	symstringo;	// string objects
-EXTERN	long	stringo;	// size of string objects
-EXTERN	long	pcloc;		// instruction counter
+EXTERN	int32	stringo;	// size of string objects
+EXTERN	int32	pcloc;		// instruction counter
 EXTERN	String	emptystring;
 extern	char*	anames[];
 EXTERN	Hist*	hist;
@@ -134,7 +134,7 @@ void	agen(Node*, Node*);
 void	igen(Node*, Node*, Node*);
 vlong	fieldoffset(Type*, Node*);
 void	bgen(Node*, int, Prog*);
-void	sgen(Node*, Node*, ulong);
+void	sgen(Node*, Node*, uint32);
 void	gmove(Node*, Node*);
 Prog*	gins(int, Node*, Node*);
 int	samaddr(Node*, Node*);
@@ -205,4 +205,4 @@ void	outhist(Biobuf*);
  * align
  */
 void	dowidth(Type*);
-ulong	rnd(ulong, ulong);
+uint32	rnd(uint32, uint32);
diff --git a/src/cmd/6g/gsubr.c b/src/cmd/6g/gsubr.c
index c56a3381ef..7a08556393 100644
--- a/src/cmd/6g/gsubr.c
+++ b/src/cmd/6g/gsubr.c
@@ -759,7 +759,7 @@ gmove(Node *f, Node *t)
 		return;
 
 /*
- * ulong to float
+ * uvlong to float
  */
 	case CASE(TUINT64, TFLOAT64):
 	case CASE(TUINT64, TFLOAT32):
@@ -972,7 +972,7 @@ Prog*
 gins(int as, Node *f, Node *t)
 {
 //	Node nod;
-//	long v;
+//	int32 v;
 	Prog *p;
 
 //	if(f != N && f->op == OINDEX) {
@@ -1660,7 +1660,7 @@ void
 tempname(Node *n, Type *t)
 {
 	Sym *s;
-	ulong w;
+	uint32 w;
 
 	if(t == T) {
 		yyerror("tempname called with nil type");
@@ -1785,7 +1785,7 @@ void
 setmaxarg(Type *t)
 {
 	Type *to;
-	long w;
+	int32 w;
 
 	to = *getoutarg(t);
 	w = to->width;
diff --git a/src/cmd/6g/list.c b/src/cmd/6g/list.c
index 53ef173d48..f5b2d554d7 100644
--- a/src/cmd/6g/list.c
+++ b/src/cmd/6g/list.c
@@ -76,7 +76,7 @@ Dconv(Fmt *fp)
 	char str[40], s[20];
 	Addr *a;
 	int i;
-	ulong d1, d2;
+	uint32 d1, d2;
 
 	a = va_arg(fp->args, Addr*);
 	i = a->type;
diff --git a/src/cmd/6g/obj.c b/src/cmd/6g/obj.c
index b3ae0c3bf0..a915f11326 100644
--- a/src/cmd/6g/obj.c
+++ b/src/cmd/6g/obj.c
@@ -193,7 +193,7 @@ zname(Biobuf *b, Sym *s, int t)
 void
 zaddr(Biobuf *b, Addr *a, int s)
 {
-	long l;
+	int32 l;
 	int i, t;
 	char *n;
 	Ieee e;
@@ -359,7 +359,7 @@ ieeedtod(Ieee *ieee, double native)
 	fr = modf(fr*f, &ho);
 	ieee->l = ho;
 	ieee->l <<= 16;
-	ieee->l |= (long)(fr*f);
+	ieee->l |= (int32)(fr*f);
 }
 
 void
@@ -409,7 +409,7 @@ dumpstrings(void)
 	Pool *l;
 	Prog *p;
 	Addr ac, ao;
-	long wi;
+	int32 wi;
 
 	if(poolist == nil)
 		return;
diff --git a/src/cmd/6l/6.out.h b/src/cmd/6l/6.out.h
index 8cce77f0b4..89e56f6805 100644
--- a/src/cmd/6l/6.out.h
+++ b/src/cmd/6l/6.out.h
@@ -852,8 +852,8 @@ enum
 typedef	struct	ieee	Ieee;
 struct	ieee
 {
-	long	l;	/* contains ls-man	0xffffffff */
-	long	h;	/* contains sign	0x80000000
+	int32	l;	/* contains ls-man	0xffffffff */
+	int32	h;	/* contains sign	0x80000000
 				    exp		0x7ff00000
 				    ms-man	0x000fffff */
 };
diff --git a/src/cmd/6l/asm.c b/src/cmd/6l/asm.c
index 3ae914afe4..53e39ac40a 100644
--- a/src/cmd/6l/asm.c
+++ b/src/cmd/6l/asm.c
@@ -32,7 +32,7 @@
 
 #define	Dbufslop	100
 
-#define PADDR(a)	((ulong)(a) & ~0x80000000)
+#define PADDR(a)	((uint32)(a) & ~0x80000000)
 
 vlong
 entryvalue(void)
@@ -73,7 +73,7 @@ wput(ushort w)
 }
 
 void
-lput(long l)
+lput(int32 l)
 {
 	cput(l>>24);
 	cput(l>>16);
@@ -89,7 +89,7 @@ llput(vlong v)
 }
 
 void
-lputl(long l)
+lputl(int32 l)
 {
 	cput(l);
 	cput(l>>8);
@@ -120,7 +120,7 @@ void
 asmb(void)
 {
 	Prog *p;
-	long v, magic;
+	int32 v, magic;
 	int a;
 	uchar *op1;
 	vlong vl, va, fo, w;
@@ -595,11 +595,11 @@ outa(int n, uchar *cast, uchar *map, vlong l)
 }
 
 void
-datblk(long s, long n)
+datblk(int32 s, int32 n)
 {
 	Prog *p;
 	uchar *cast;
-	long l, fl, j;
+	int32 l, fl, j;
 	vlong o;
 	int i, c;
 
@@ -747,7 +747,7 @@ vputl(vlong v)
 
 void
 machseg(char *name, vlong vaddr, vlong vsize, vlong foff, vlong fsize,
-	ulong prot1, ulong prot2, ulong nsect, ulong flag)
+	uint32 prot1, uint32 prot2, uint32 nsect, uint32 flag)
 {
 	lputl(25);	/* segment 64 */
 	lputl(72 + 80*nsect);
@@ -763,7 +763,7 @@ machseg(char *name, vlong vaddr, vlong vsize, vlong foff, vlong fsize,
 }
 
 void
-machsymseg(ulong foffset, ulong fsize)
+machsymseg(uint32 foffset, uint32 fsize)
 {
 	lputl(3);	/* obsolete gdb debug info */
 	lputl(16);	/* size of symseg command */
@@ -772,8 +772,8 @@ machsymseg(ulong foffset, ulong fsize)
 }
 
 void
-machsect(char *name, char *seg, vlong addr, vlong size, ulong off,
-	ulong align, ulong reloc, ulong nreloc, ulong flag)
+machsect(char *name, char *seg, vlong addr, vlong size, uint32 off,
+	uint32 align, uint32 reloc, uint32 nreloc, uint32 flag)
 {
 	strnput(name, 16);
 	strnput(seg, 16);
@@ -807,10 +807,10 @@ machstack(vlong e)
 		lputl(0);
 }
 
-ulong
+uint32
 machheadr(void)
 {
-	ulong a;
+	uint32 a;
 
 	a = 8;		/* a.out header */
 	a += 18;	/* page zero seg */
@@ -828,10 +828,10 @@ machheadr(void)
 	return a*4;
 }
 
-ulong
+uint32
 linuxheadr(void)
 {
-	ulong a;
+	uint32 a;
 
 	a = 64;		/* a.out header */
 
@@ -870,8 +870,8 @@ linuxphdr(int type, int flags, vlong foff,
 }
 
 void
-linuxshdr(char *name, ulong type, vlong flags, vlong addr, vlong off,
-	vlong size, ulong link, ulong info, vlong align, vlong entsize)
+linuxshdr(char *name, uint32 type, vlong flags, vlong addr, vlong off,
+	vlong size, uint32 link, uint32 info, vlong align, vlong entsize)
 {
 	lputl(stroffset);
 	lputl(type);
diff --git a/src/cmd/6l/l.h b/src/cmd/6l/l.h
index 8966ed260e..1cc92f5032 100644
--- a/src/cmd/6l/l.h
+++ b/src/cmd/6l/l.h
@@ -88,7 +88,7 @@ struct	Prog
 	Prog*	link;
 	Prog*	pcond;	/* work on this */
 	vlong	pc;
-	long	line;
+	int32	line;
 	uchar	mark;	/* work on these */
 	uchar	back;
 
@@ -100,7 +100,7 @@ struct	Auto
 {
 	Sym*	asym;
 	Auto*	link;
-	long	aoffset;
+	int32	aoffset;
 	short	type;
 };
 struct	Sym
@@ -113,7 +113,7 @@ struct	Sym
 	uchar	subtype;
 	ushort	file;
 	vlong	value;
-	long	sig;
+	int32	sig;
 	Sym*	link;
 };
 struct	Optab
@@ -274,14 +274,14 @@ EXTERN union
 #pragma	varargck	type	"R"	int
 #pragma	varargck	type	"S"	char*
 
-EXTERN	long	HEADR;
-EXTERN	long	HEADTYPE;
+EXTERN	int32	HEADR;
+EXTERN	int32	HEADTYPE;
 EXTERN	vlong	INITDAT;
-EXTERN	long	INITRND;
+EXTERN	int32	INITRND;
 EXTERN	vlong	INITTEXT;
 EXTERN	char*	INITENTRY;		/* entry point */
 EXTERN	Biobuf	bso;
-EXTERN	long	bsssize;
+EXTERN	int32	bsssize;
 EXTERN	int	cbc;
 EXTERN	char*	cbp;
 EXTERN	char*	pcstr;
@@ -319,19 +319,19 @@ EXTERN	uchar	and[30];
 EXTERN	int	reg[D_NONE];
 EXTERN	int	regrex[D_NONE+1];
 EXTERN	Prog*	lastp;
-EXTERN	long	lcsize;
+EXTERN	int32	lcsize;
 EXTERN	int	nerrors;
-EXTERN	long	nhunk;
-EXTERN	long	nsymbol;
+EXTERN	int32	nhunk;
+EXTERN	int32	nsymbol;
 EXTERN	char*	noname;
 EXTERN	char*	outfile;
 EXTERN	vlong	pc;
-EXTERN	long	spsize;
+EXTERN	int32	spsize;
 EXTERN	Sym*	symlist;
-EXTERN	long	symsize;
+EXTERN	int32	symsize;
 EXTERN	Prog*	textp;
 EXTERN	vlong	textsize;
-EXTERN	long	thunk;
+EXTERN	int32	thunk;
 EXTERN	int	version;
 EXTERN	Prog	zprg;
 EXTERN	int	dtype;
@@ -344,7 +344,7 @@ EXTERN	int	imports, nimports;
 EXTERN	int	exports, nexports;
 EXTERN	char*	EXPTAB;
 EXTERN	Prog	undefp;
-EXTERN	ulong	stroffset;
+EXTERN	uint32	stroffset;
 EXTERN	vlong	textstksiz;
 EXTERN	vlong	textarg;
 
@@ -359,7 +359,7 @@ int	Dconv(Fmt*);
 int	Pconv(Fmt*);
 int	Rconv(Fmt*);
 int	Sconv(Fmt*);
-void	addhist(long, int);
+void	addhist(int32, int);
 Prog*	appendp(Prog*);
 void	asmb(void);
 void	asmdyn(void);
@@ -372,38 +372,38 @@ Prog*	brchain(Prog*);
 Prog*	brloop(Prog*);
 void	buildop(void);
 void	cflush(void);
-void	ckoff(Sym*, long);
+void	ckoff(Sym*, int32);
 Prog*	copyp(Prog*);
 double	cputime(void);
-void	datblk(long, long);
+void	datblk(int32, int32);
 void	diag(char*, ...);
 void	dodata(void);
 void	doinit(void);
 void	doprof1(void);
 void	doprof2(void);
 void	dostkoff(void);
-void	dynreloc(Sym*, ulong, int);
+void	dynreloc(Sym*, uint32, int);
 vlong	entryvalue(void);
 void	errorexit(void);
 void	export(void);
-int	find1(long, int);
-int	find2(long, int);
+int	find1(int32, int);
+int	find2(int32, int);
 void	follow(void);
 void	addstachmark(void);
 void	gethunk(void);
 void	histtoauto(void);
 double	ieeedtod(Ieee*);
-long	ieeedtof(Ieee*);
+int32	ieeedtof(Ieee*);
 void	import(void);
-void	ldobj(int, long, char*);
+void	ldobj(int, int32, char*);
 void	loadlib(void);
 void	listinit(void);
 Sym*	lookup(char*, int);
-void	lput(long);
-void	lputl(long);
+void	lput(int32);
+void	lputl(int32);
 void	main(int, char*[]);
 void	mkfwd(void);
-void*	mysbrk(ulong);
+void*	mysbrk(uint32);
 void	nuxiinit(void);
 void	objfile(char*);
 int	opsize(Prog*);
@@ -412,7 +412,7 @@ Prog*	prg(void);
 void	parsetextconst(vlong);
 void	readundefs(char*, int);
 int	relinv(int);
-long	reuse(Prog*, Sym*);
+int32	reuse(Prog*, Sym*);
 vlong	rnd(vlong, vlong);
 void	span(void);
 void	undef(void);
@@ -424,18 +424,18 @@ void	xfol(Prog*);
 int	zaddr(uchar*, Adr*, Sym*[]);
 void	zerosig(char*);
 
-void	machseg(char*, vlong, vlong, vlong, vlong, ulong, ulong, ulong, ulong);
-void	machsymseg(ulong, ulong);
-void	machsect(char*, char*, vlong, vlong, ulong, ulong, ulong, ulong, ulong);
+void	machseg(char*, vlong, vlong, vlong, vlong, uint32, uint32, uint32, uint32);
+void	machsymseg(uint32, uint32);
+void	machsect(char*, char*, vlong, vlong, uint32, uint32, uint32, uint32, uint32);
 void	machstack(vlong);
-ulong	machheadr(void);
+uint32	machheadr(void);
 
-ulong	linuxheadr(void);
+uint32	linuxheadr(void);
 void	linuxphdr(int type, int flags, vlong foff,
 	vlong vaddr, vlong paddr,
 	vlong filesize, vlong memsize, vlong align);
-void	linuxshdr(char *name, ulong type, vlong flags, vlong addr, vlong off,
-	vlong size, ulong link, ulong info, vlong align, vlong entsize);
+void	linuxshdr(char *name, uint32 type, vlong flags, vlong addr, vlong off,
+	vlong size, uint32 link, uint32 info, vlong align, vlong entsize);
 int	linuxstrtable(void);
 
 
diff --git a/src/cmd/6l/obj.c b/src/cmd/6l/obj.c
index 41976b6053..47c0280de5 100644
--- a/src/cmd/6l/obj.c
+++ b/src/cmd/6l/obj.c
@@ -421,7 +421,7 @@ void
 loadlib(void)
 {
 	int i;
-	long h;
+	int32 h;
 	Sym *s;
 
 loop:
@@ -453,7 +453,7 @@ errorexit(void)
 void
 objfile(char *file)
 {
-	long off, esym, cnt, l;
+	int32 off, esym, cnt, l;
 	int f, work;
 	Sym *s;
 	char magbuf[SARMAG];
@@ -561,7 +561,7 @@ int
 zaddr(uchar *p, Adr *a, Sym *h[])
 {
 	int c, t, i;
-	long l;
+	int32 l;
 	Sym *s;
 	Auto *u;
 
@@ -579,7 +579,7 @@ zaddr(uchar *p, Adr *a, Sym *h[])
 	if(t & T_OFFSET) {
 		/*
 		 * Hack until Charles fixes the compiler.
-		a->offset = (long)(p[c] | (p[c+1]<<8) | (p[c+2]<<16) | (p[c+3]<<24));
+		a->offset = (int32)(p[c] | (p[c+1]<<8) | (p[c+2]<<16) | (p[c+3]<<24));
 		 */
 		l = p[c] | (p[c+1]<<8) | (p[c+2]<<16) | (p[c+3]<<24);
 		a->offset = l;
@@ -707,7 +707,7 @@ addlib(char *obj)
 }
 
 void
-addhist(long line, int type)
+addhist(int32 line, int type)
 {
 	Auto *u;
 	Sym *s;
@@ -808,14 +808,14 @@ readsome(int f, uchar *buf, uchar *good, uchar *stop, int max)
 }
 
 void
-ldobj(int f, long c, char *pn)
+ldobj(int f, int32 c, char *pn)
 {
 	vlong ipc;
 	Prog *p, *t;
 	uchar *bloc, *bsize, *stop;
 	int v, o, r, skip, mode;
 	Sym *h[NSYM], *s, *di;
-	ulong sig;
+	uint32 sig;
 	static int files;
 	static char **filen;
 	char **nfilen;
@@ -1230,7 +1230,7 @@ lookup(char *symb, int v)
 {
 	Sym *s;
 	char *p;
-	long h;
+	int32 h;
 	int l, c;
 
 	h = v;
@@ -1298,7 +1298,7 @@ void
 doprof1(void)
 {
 	Sym *s;
-	long n;
+	int32 n;
 	Prog *p, *q;
 
 	if(debug['v'])
@@ -1487,7 +1487,7 @@ nuxiinit(void)
 }
 
 int
-find1(long l, int c)
+find1(int32 l, int c)
 {
 	char *p;
 	int i;
@@ -1500,7 +1500,7 @@ find1(long l, int c)
 }
 
 int
-find2(long l, int c)
+find2(int32 l, int c)
 {
 	short *p;
 	int i;
@@ -1515,11 +1515,11 @@ find2(long l, int c)
 	return 0;
 }
 
-long
+int32
 ieeedtof(Ieee *e)
 {
 	int exp;
-	long v;
+	int32 v;
 
 	if(e->h == 0)
 		return 0;
diff --git a/src/cmd/6l/pass.c b/src/cmd/6l/pass.c
index 808cef1dc0..e071f6e1a9 100644
--- a/src/cmd/6l/pass.c
+++ b/src/cmd/6l/pass.c
@@ -36,7 +36,7 @@ dodata(void)
 	int i;
 	Sym *s;
 	Prog *p;
-	long t, u;
+	int32 t, u;
 
 	if(debug['v'])
 		Bprint(&bso, "%5.2f dodata\n", cputime());
@@ -297,7 +297,7 @@ void
 markstk(Prog *l)
 {
 	Prog *p0, *p, *q, *r;
-	long i, n, line;
+	int32 i, n, line;
 	Sym *s;
 
 	version++;
@@ -438,10 +438,10 @@ doinit(void)
 void
 patch(void)
 {
-	long c;
+	int32 c;
 	Prog *p, *q;
 	Sym *s;
-	long vexit;
+	int32 vexit;
 
 	if(debug['v'])
 		Bprint(&bso, "%5.2f mkfwd\n", cputime());
@@ -517,7 +517,7 @@ mkfwd(void)
 {
 	Prog *p;
 	int i;
-	long dwn[LOG], cnt[LOG];
+	int32 dwn[LOG], cnt[LOG];
 	Prog *lst[LOG];
 
 	for(i=0; i<LOG; i++) {
@@ -566,7 +566,7 @@ void
 dostkoff(void)
 {
 	Prog *p, *q;
-	long autoffset, deltasp;
+	int32 autoffset, deltasp;
 	int a, f, curframe, curbecome, maxbecome, pcsize;
 	Prog *pmorestack;
 	Sym *symmorestack;
@@ -882,7 +882,7 @@ import(void)
 }
 
 void
-ckoff(Sym *s, long v)
+ckoff(Sym *s, int32 v)
 {
 	if(v < 0 || v >= 1<<Roffset)
 		diag("relocation offset %ld for %s out of range", v, s->name);
@@ -954,13 +954,13 @@ export(void)
 		/* Bprint(&bso, "EXPORT: %s sig=%lux t=%d\n", s->name, s->sig, s->type); */
 
 		/* signature */
-		p = newdata(et, off, sizeof(long), D_EXTERN);
-		off += sizeof(long);
+		p = newdata(et, off, sizeof(int32), D_EXTERN);
+		off += sizeof(int32);
 		p->to.offset = s->sig;
 
 		/* address */
-		p = newdata(et, off, sizeof(long), D_EXTERN);
-		off += sizeof(long);
+		p = newdata(et, off, sizeof(int32), D_EXTERN);
+		off += sizeof(int32);
 		p->to.type = D_ADDR;
 		p->to.index = D_EXTERN;
 		p->to.sym = s;
@@ -982,8 +982,8 @@ export(void)
 		}
 
 		/* name */
-		p = newdata(et, off, sizeof(long), D_EXTERN);
-		off += sizeof(long);
+		p = newdata(et, off, sizeof(int32), D_EXTERN);
+		off += sizeof(int32);
 		p->to.type = D_ADDR;
 		p->to.index = D_STATIC;
 		p->to.sym = str;
@@ -997,8 +997,8 @@ export(void)
 	}
 
 	for(i = 0; i < 3; i++){
-		newdata(et, off, sizeof(long), D_EXTERN);
-		off += sizeof(long);
+		newdata(et, off, sizeof(int32), D_EXTERN);
+		off += sizeof(int32);
 	}
 	et->value = off;
 	if(sv == 0)
diff --git a/src/cmd/6l/span.c b/src/cmd/6l/span.c
index 4b225da8ca..acb8f071d4 100644
--- a/src/cmd/6l/span.c
+++ b/src/cmd/6l/span.c
@@ -37,7 +37,7 @@ void
 span(void)
 {
 	Prog *p, *q;
-	long v;
+	int32 v;
 	vlong c, idat;
 	int m, n, again;
 
@@ -267,7 +267,7 @@ asmlc(void)
 {
 	vlong oldpc;
 	Prog *p;
-	long oldlc, v, s;
+	int32 oldlc, v, s;
 
 	oldpc = INITTEXT;
 	oldlc = 0;
@@ -346,7 +346,7 @@ int
 oclass(Adr *a)
 {
 	vlong v;
-	long l;
+	int32 l;
 
 	if(a->type >= D_INDIR || a->index != D_NONE) {
 		if(a->index != D_NONE && a->scale == 0) {
@@ -623,7 +623,7 @@ bad:
 }
 
 static void
-put4(long v)
+put4(int32 v)
 {
 	if(dlm && curp != P && reloca != nil){
 		dynreloc(reloca->sym, curp->pc + andptr - &and[0], 1);
@@ -692,7 +692,7 @@ vaddr(Adr *a)
 static void
 asmandsz(Adr *a, int r, int rex, int m64)
 {
-	long v;
+	int32 v;
 	int t;
 	Adr aa;
 
@@ -1638,7 +1638,7 @@ struct Reloc
 	int n;
 	int t;
 	uchar *m;
-	ulong *a;
+	uint32 *a;
 };
 
 Reloc rels;
@@ -1648,26 +1648,26 @@ grow(Reloc *r)
 {
 	int t;
 	uchar *m, *nm;
-	ulong *a, *na;
+	uint32 *a, *na;
 
 	t = r->t;
 	r->t += 64;
 	m = r->m;
 	a = r->a;
 	r->m = nm = malloc(r->t*sizeof(uchar));
-	r->a = na = malloc(r->t*sizeof(ulong));
+	r->a = na = malloc(r->t*sizeof(uint32));
 	memmove(nm, m, t*sizeof(uchar));
-	memmove(na, a, t*sizeof(ulong));
+	memmove(na, a, t*sizeof(uint32));
 	free(m);
 	free(a);
 }
 
 void
-dynreloc(Sym *s, ulong v, int abs)
+dynreloc(Sym *s, uint32 v, int abs)
 {
 	int i, k, n;
 	uchar *m;
-	ulong *a;
+	uint32 *a;
 	Reloc *r;
 
 	if(s->type == SUNDEF)
@@ -1712,7 +1712,7 @@ asmdyn()
 {
 	int i, n, t, c;
 	Sym *s;
-	ulong la, ra, *a;
+	uint32 la, ra, *a;
 	vlong off;
 	uchar *m;
 	Reloc *r;
diff --git a/src/cmd/cc/acid.c b/src/cmd/cc/acid.c
index 62be5e82b7..7a674822ff 100644
--- a/src/cmd/cc/acid.c
+++ b/src/cmd/cc/acid.c
@@ -124,7 +124,7 @@ acidinit(void)
 }
 
 void
-acidmember(Type *t, long off, int flag)
+acidmember(Type *t, int32 off, int flag)
 {
 	Sym *s, *s1;
 	Type *l;
diff --git a/src/cmd/cc/bits.c b/src/cmd/cc/bits.c
index 31e788c8a9..aef4449e82 100644
--- a/src/cmd/cc/bits.c
+++ b/src/cmd/cc/bits.c
@@ -91,7 +91,7 @@ int
 bnum(Bits a)
 {
 	int i;
-	long b;
+	int32 b;
 
 	for(i=0; i<BITS; i++)
 		if(b = a.b[i])
diff --git a/src/cmd/cc/cc.h b/src/cmd/cc/cc.h
index db1cf94ee2..b453755947 100644
--- a/src/cmd/cc/cc.h
+++ b/src/cmd/cc/cc.h
@@ -65,10 +65,10 @@ typedef	struct	Bits	Bits;
 #define	MASK(n)		(SIGN(n)|(SIGN(n)-1))
 
 #define	BITS	5
-#define	NVAR	(BITS*sizeof(ulong)*8)
+#define	NVAR	(BITS*sizeof(uint32)*8)
 struct	Bits
 {
-	ulong	b[BITS];
+	uint32	b[BITS];
 };
 
 struct	Node
@@ -76,9 +76,9 @@ struct	Node
 	Node*	left;
 	Node*	right;
 	void*	label;
-	long	pc;
+	int32	pc;
 	int	reg;
-	long	xoffset;
+	int32	xoffset;
 	double	fconst;		/* fp constant */
 	vlong	vconst;		/* non fp const */
 	char*	cstring;	/* character string */
@@ -86,7 +86,7 @@ struct	Node
 
 	Sym*	sym;
 	Type*	type;
-	long	lineno;
+	int32	lineno;
 	uchar	op;
 	uchar	oldop;
 	uchar	xcast;
@@ -106,8 +106,8 @@ struct	Sym
 	Type*	suetag;
 	Type*	tenum;
 	char*	macro;
-	long	varlineno;
-	long	offset;
+	int32	varlineno;
+	int32	offset;
 	vlong	vconst;
 	double	fconst;
 	Node*	label;
@@ -135,8 +135,8 @@ struct	Decl
 	Decl*	link;
 	Sym*	sym;
 	Type*	type;
-	long	varlineno;
-	long	offset;
+	int32	varlineno;
+	int32	offset;
 	short	val;
 	ushort	block;
 	uchar	class;
@@ -151,9 +151,9 @@ struct	Type
 	Funct*	funct;
 	Type*	link;
 	Type*	down;
-	long	width;
-	long	offset;
-	long	lineno;
+	int32	width;
+	int32	offset;
+	int32	lineno;
 	uchar	shift;
 	uchar	nbits;
 	uchar	etype;
@@ -166,7 +166,7 @@ struct	Type
 struct	Init			/* general purpose initialization */
 {
 	int	code;
-	ulong	value;
+	uint32	value;
 	char*	s;
 };
 
@@ -190,8 +190,8 @@ struct	Hist
 {
 	Hist*	link;
 	char*	name;
-	long	line;
-	long	offset;
+	int32	line;
+	int32	offset;
 };
 #define	H	((Hist*)0)
 EXTERN Hist*	hist;
@@ -445,12 +445,12 @@ EXTERN struct
 } en;
 
 EXTERN	int	autobn;
-EXTERN	long	autoffset;
+EXTERN	int32	autoffset;
 EXTERN	int	blockno;
 EXTERN	Decl*	dclstack;
 EXTERN	char	debug[256];
 EXTERN	Hist*	ehist;
-EXTERN	long	firstbit;
+EXTERN	int32	firstbit;
 EXTERN	Sym*	firstarg;
 EXTERN	Type*	firstargtype;
 EXTERN	Decl*	firstdcl;
@@ -461,16 +461,16 @@ EXTERN	char*	include[20];
 EXTERN	Io*	iofree;
 EXTERN	Io*	ionext;
 EXTERN	Io*	iostack;
-EXTERN	long	lastbit;
+EXTERN	int32	lastbit;
 EXTERN	char	lastclass;
 EXTERN	Type*	lastdcl;
-EXTERN	long	lastfield;
+EXTERN	int32	lastfield;
 EXTERN	Type*	lasttype;
-EXTERN	long	lineno;
-EXTERN	long	nearln;
+EXTERN	int32	lineno;
+EXTERN	int32	nearln;
 EXTERN	int	nerrors;
 EXTERN	int	newflag;
-EXTERN	long	nhunk;
+EXTERN	int32	nhunk;
 EXTERN	int	ninclude;
 EXTERN	Node*	nodproto;
 EXTERN	Node*	nodcast;
@@ -479,7 +479,7 @@ EXTERN	Biobuf	diagbuf;
 EXTERN	char*	outfile;
 EXTERN	char*	pathname;
 EXTERN	int	peekc;
-EXTERN	long	stkoff;
+EXTERN	int32	stkoff;
 EXTERN	Type*	strf;
 EXTERN	Type*	strl;
 EXTERN	char	symb[NSYMB];
@@ -490,7 +490,7 @@ EXTERN	Type*	tufield;
 EXTERN	int	thechar;
 EXTERN	char*	thestring;
 EXTERN	Type*	thisfn;
-EXTERN	long	thunk;
+EXTERN	int32	thunk;
 EXTERN	Type*	types[NTYPE];
 EXTERN	Type*	fntypes[NTYPE];
 EXTERN	Node*	initlist;
@@ -508,10 +508,10 @@ extern	char	*onames[], *tnames[], *gnames[];
 extern	char	*cnames[], *qnames[], *bnames[];
 extern	uchar	tab[NTYPE][NTYPE];
 extern	uchar	comrel[], invrel[], logrel[];
-extern	long	ncast[], tadd[], tand[];
-extern	long	targ[], tasadd[], tasign[], tcast[];
-extern	long	tdot[], tfunct[], tindir[], tmul[];
-extern	long	tnot[], trel[], tsub[];
+extern	int32	ncast[], tadd[], tand[];
+extern	int32	targ[], tasadd[], tasign[], tcast[];
+extern	int32	tdot[], tfunct[], tindir[], tmul[];
+extern	int32	tnot[], trel[], tsub[];
 
 extern	uchar	typeaf[];
 extern	uchar	typefd[];
@@ -533,10 +533,10 @@ extern	uchar	typechlpfd[];
 EXTERN	uchar*	typeword;
 EXTERN	uchar*	typecmplx;
 
-extern	ulong	thash1;
-extern	ulong	thash2;
-extern	ulong	thash3;
-extern	ulong	thash[];
+extern	uint32	thash1;
+extern	uint32	thash2;
+extern	uint32	thash3;
+extern	uint32	thash[];
 
 /*
  *	compat.c/unix.c/windows.c
@@ -551,7 +551,7 @@ int	myexec(char*, char*[]);
 int	mydup(int, int);
 int	myfork(void);
 int	mypipe(int*);
-void*	mysbrk(ulong);
+void*	mysbrk(uint32);
 
 /*
  *	parser
@@ -562,25 +562,25 @@ int	mpatov(char*, vlong*);
 /*
  *	lex.c
  */
-void*	allocn(void*, long, long);
-void*	alloc(long);
+void*	allocn(void*, int32, int32);
+void*	alloc(int32);
 void	cinit(void);
 int	compile(char*, char**, int);
 void	errorexit(void);
 int	filbuf(void);
 int	getc(void);
-long	getr(void);
+int32	getr(void);
 int	getnsc(void);
 Sym*	lookup(void);
 void	main(int, char*[]);
 void	newfile(char*, int);
 void	newio(void);
 void	pushio(void);
-long	escchar(long, int, int);
+int32	escchar(int32, int, int);
 Sym*	slookup(char*);
 void	syminit(Sym*);
 void	unget(int);
-long	yylex(void);
+int32	yylex(void);
 int	Lconv(Fmt*);
 int	Tconv(Fmt*);
 int	FNconv(Fmt*);
@@ -595,7 +595,7 @@ void	setinclude(char*);
 void	dodefine(char*);
 void	domacro(void);
 Sym*	getsym(void);
-long	getnsn(void);
+int32	getnsn(void);
 void	linehist(char*, int);
 void	macdef(void);
 void	macprag(void);
@@ -609,9 +609,9 @@ void	macund(void);
 /*
  * dcl.c
  */
-Node*	doinit(Sym*, Type*, long, Node*);
+Node*	doinit(Sym*, Type*, int32, Node*);
 Type*	tcopy(Type*);
-Node*	init1(Sym*, Type*, long, int);
+Node*	init1(Sym*, Type*, int32, int);
 Node*	newlist(Node*, Node*);
 void	adecl(int, Type*, Sym*);
 int	anyproto(Node*);
@@ -632,16 +632,16 @@ void	pdecl(int, Type*, Sym*);
 Decl*	push(void);
 Decl*	push1(Sym*);
 Node*	revertdcl(void);
-long	xround(long, int);
+int32	xround(int32, int);
 int	rsametype(Type*, Type*, int, int);
 int	sametype(Type*, Type*);
-ulong	sign(Sym*);
-ulong	signature(Type*);
+uint32	sign(Sym*);
+uint32	signature(Type*);
 void	suallign(Type*);
 void	tmerge(Type*, Sym*);
 void	walkparam(Node*, int);
 void	xdecl(int, Type*, Sym*);
-Node*	contig(Sym*, Node*, long);
+Node*	contig(Sym*, Node*, int32);
 
 /*
  * com.c
@@ -678,12 +678,12 @@ void	dclfunct(Type*, Sym*);
  */
 void	arith(Node*, int);
 int	deadheads(Node*);
-Type*	dotsearch(Sym*, Type*, Node*, long*);
-long	dotoffset(Type*, Type*, Node*);
+Type*	dotsearch(Sym*, Type*, Node*, int32*);
+int32	dotoffset(Type*, Type*, Node*);
 void	gethunk(void);
 Node*	invert(Node*);
-int	bitno(long);
-void	makedot(Node*, Type*, long);
+int	bitno(int32);
+void	makedot(Node*, Type*, int32);
 int	mixedasop(Type*, Type*);
 Node*	new(int, Node*, Node*);
 Node*	new1(int, Node*, Node*);
@@ -693,12 +693,12 @@ void	prtree(Node*, char*);
 void	prtree1(Node*, int, int);
 void	relcon(Node*, Node*);
 int	relindex(int);
-int	simpleg(long);
-Type*	garbt(Type*, long);
-int	simplec(long);
-Type*	simplet(long);
-int	stcompat(Node*, Type*, Type*, long[]);
-int	tcompat(Node*, Type*, Type*, long[]);
+int	simpleg(int32);
+Type*	garbt(Type*, int32);
+int	simplec(int32);
+Type*	simplet(int32);
+int	stcompat(Node*, Type*, Type*, int32[]);
+int	tcompat(Node*, Type*, Type*, int32[]);
 void	tinit(void);
 Type*	typ(int, Type*);
 Type*	copytyp(Type*);
@@ -708,9 +708,9 @@ int	side(Node*);
 int	vconst(Node*);
 int	xlog2(uvlong);
 int	vlog(Node*);
-int	topbit(ulong);
+int	topbit(uint32);
 void	simplifyshift(Node*);
-long	typebitor(long, long);
+int32	typebitor(int32, int32);
 void	diag(Node*, char*, ...);
 void	warn(Node*, char*, ...);
 void	yyerror(char*, ...);
@@ -755,15 +755,15 @@ void	pragincomplete(void);
  */
 void	codgen(Node*, Node*);
 void	gclean(void);
-void	gextern(Sym*, Node*, long, long);
+void	gextern(Sym*, Node*, int32, int32);
 void	ginit(void);
-long	outstring(char*, long);
-long	outlstring(ushort*, long);
-void	sextern(Sym*, Node*, long, long);
+int32	outstring(char*, int32);
+int32	outlstring(ushort*, int32);
+void	sextern(Sym*, Node*, int32, int32);
 void	xcom(Node*);
-long	exreg(Type*);
-long	align(long, Type*, int);
-long	maxround(long, long);
+int32	exreg(Type*);
+int32	align(int32, Type*, int);
+int32	maxround(int32, int32);
 
 extern	schar	ewidth[];
 
@@ -788,8 +788,8 @@ int	machcap(Node*);
 #pragma	varargck	argpos	yyerror	1
 
 #pragma	varargck	type	"F"	Node*
-#pragma	varargck	type	"L"	long
-#pragma	varargck	type	"Q"	long
+#pragma	varargck	type	"L"	int32
+#pragma	varargck	type	"Q"	int32
 #pragma	varargck	type	"O"	int
 #pragma	varargck	type	"T"	Type*
 #pragma	varargck	type	"|"	int
diff --git a/src/cmd/cc/cc.y b/src/cmd/cc/cc.y
index 1abcddd439..50d2ecdd87 100644
--- a/src/cmd/cc/cc.y
+++ b/src/cmd/cc/cc.y
@@ -48,9 +48,9 @@
 	struct
 	{
 		char*	s;
-		long	l;
+		int32	l;
 	} sval;
-	long	lval;
+	int32	lval;
 	double	dval;
 	vlong	vval;
 }
@@ -198,7 +198,7 @@ adlist:
 	}
 	'=' init
 	{
-		long w;
+		int32 w;
 
 		w = $1->sym->type->width;
 		$$ = doinit($1->sym, $1->type, 0L, $4);
diff --git a/src/cmd/cc/com.c b/src/cmd/cc/com.c
index b0b1620ce1..5ee38e8823 100644
--- a/src/cmd/cc/com.c
+++ b/src/cmd/cc/com.c
@@ -839,7 +839,7 @@ int
 tcomd(Node *n)
 {
 	Type *t;
-	long o;
+	int32 o;
 
 	o = 0;
 	t = dotsearch(n->sym, n->left->type->link, n, &o);
diff --git a/src/cmd/cc/dcl.c b/src/cmd/cc/dcl.c
index f44c340077..c07c5c80d0 100644
--- a/src/cmd/cc/dcl.c
+++ b/src/cmd/cc/dcl.c
@@ -35,7 +35,7 @@ dodecl(void (*f)(int,Type*,Sym*), int c, Type *t, Node *n)
 {
 	Sym *s;
 	Node *n1;
-	long v;
+	int32 v;
 
 	nearln = lineno;
 	lastfield = 0;
@@ -183,7 +183,7 @@ tcopy(Type *t)
 }
 
 Node*
-doinit(Sym *s, Type *t, long o, Node *a)
+doinit(Sym *s, Type *t, int32 o, Node *a)
 {
 	Node *n;
 
@@ -312,11 +312,11 @@ isstruct(Node *a, Type *t)
 }
 
 Node*
-init1(Sym *s, Type *t, long o, int exflag)
+init1(Sym *s, Type *t, int32 o, int exflag)
 {
 	Node *a, *l, *r, nod;
 	Type *t1;
-	long e, w, so, mw;
+	int32 e, w, so, mw;
 
 	a = peekinit();
 	if(a == Z)
@@ -552,7 +552,7 @@ void
 suallign(Type *t)
 {
 	Type *l;
-	long o, w;
+	int32 o, w;
 
 	o = 0;
 	switch(t->etype) {
@@ -616,8 +616,8 @@ suallign(Type *t)
 	}
 }
 
-long
-xround(long v, int w)
+int32
+xround(int32 v, int w)
 {
 	int r;
 
@@ -1057,12 +1057,12 @@ sigind(Type *t, Typetab *tt)
 	return -1;
 }
 
-static ulong
+static uint32
 signat(Type *t, Typetab *tt)
 {
 	int i;
 	Type *t1;
-	long s;
+	int32 s;
 
 	s = 0;
 	for(; t; t=t->link) {
@@ -1095,10 +1095,10 @@ signat(Type *t, Typetab *tt)
 	return s;
 }
 
-ulong
+uint32
 signature(Type *t)
 {
-	ulong s;
+	uint32 s;
 	Typetab tt;
 
 	tt.n = 0;
@@ -1108,10 +1108,10 @@ signature(Type *t)
 	return s;
 }
 
-ulong
+uint32
 sign(Sym *s)
 {
-	ulong v;
+	uint32 v;
 	Type *t;
 
 	if(s->sig == SIGINTERN)
@@ -1313,7 +1313,7 @@ pdecl(int c, Type *t, Sym *s)
 void
 xdecl(int c, Type *t, Sym *s)
 {
-	long o;
+	int32 o;
 
 	o = 0;
 	switch(c) {
@@ -1538,7 +1538,7 @@ doenum(Sym *s, Node *n)
 }
 
 void
-symadjust(Sym *s, Node *n, long del)
+symadjust(Sym *s, Node *n, int32 del)
 {
 
 	switch(n->op) {
@@ -1564,10 +1564,10 @@ symadjust(Sym *s, Node *n, long del)
 }
 
 Node*
-contig(Sym *s, Node *n, long v)
+contig(Sym *s, Node *n, int32 v)
 {
 	Node *p, *r, *q, *m;
-	long w;
+	int32 w;
 	Type *zt;
 
 	if(debug['i']) {
diff --git a/src/cmd/cc/lex.c b/src/cmd/cc/lex.c
index a1de21cd82..cf5a844e87 100644
--- a/src/cmd/cc/lex.c
+++ b/src/cmd/cc/lex.c
@@ -394,7 +394,7 @@ Sym*
 lookup(void)
 {
 	Sym *s;
-	ulong h;
+	uint32 h;
 	char *p;
 	int c, n;
 
@@ -404,7 +404,7 @@ lookup(void)
 		h += *p++;
 	}
 	n = (p - symb) + 1;
-	if((long)h < 0)
+	if((int32)h < 0)
 		h = ~h;
 	h %= NHASH;
 	c = symb[0];
@@ -453,11 +453,11 @@ enum
 	Numflt		= 1<<4,
 };
 
-long
+int32
 yylex(void)
 {
 	vlong vv;
-	long c, c1, t;
+	int32 c, c1, t;
 	char *cp;
 	Rune rune;
 	Sym *s;
@@ -1019,7 +1019,7 @@ getc(void)
 	return c;
 }
 
-long
+int32
 getr(void)
 {
 	int c, i;
@@ -1079,10 +1079,10 @@ unget(int c)
 		lineno--;
 }
 
-long
-escchar(long e, int longflg, int escflg)
+int32
+escchar(int32 e, int longflg, int escflg)
 {
-	long c, l;
+	int32 c, l;
 	int i;
 
 loop:
@@ -1335,14 +1335,14 @@ Lconv(Fmt *fp)
 	struct
 	{
 		Hist*	incl;	/* start of this include file */
-		long	idel;	/* delta line number to apply to include */
+		int32	idel;	/* delta line number to apply to include */
 		Hist*	line;	/* start of this #line directive */
-		long	ldel;	/* delta line number to apply to #line */
+		int32	ldel;	/* delta line number to apply to #line */
 	} a[HISTSZ];
-	long l, d;
+	int32 l, d;
 	int i, n;
 
-	l = va_arg(fp->args, long);
+	l = va_arg(fp->args, int32);
 	n = 0;
 	for(h = hist; h != H; h = h->link) {
 		if(l < h->line)
@@ -1402,7 +1402,7 @@ Tconv(Fmt *fp)
 	char str[STRINGSZ+20], s[STRINGSZ+20];
 	Type *t, *t1;
 	int et;
-	long n;
+	int32 n;
 
 	str[0] = 0;
 	for(t = va_arg(fp->args, Type*); t != T; t = t->link) {
@@ -1472,11 +1472,11 @@ int
 Qconv(Fmt *fp)
 {
 	char str[STRINGSZ+20], *s;
-	long b;
+	int32 b;
 	int i;
 
 	str[0] = 0;
-	for(b = va_arg(fp->args, long); b;) {
+	for(b = va_arg(fp->args, int32); b;) {
 		i = bitno(b);
 		if(str[0])
 			strcat(str, " ");
diff --git a/src/cmd/cc/lexbody b/src/cmd/cc/lexbody
index 3a38e2ae99..869bf377cc 100644
--- a/src/cmd/cc/lexbody
+++ b/src/cmd/cc/lexbody
@@ -76,7 +76,7 @@ gethunk(void)
 }
 
 void*
-alloc(long n)
+alloc(int32 n)
 {
 	void *p;
 
@@ -93,7 +93,7 @@ alloc(long n)
 }
 
 void*
-allocn(void *p, long on, long n)
+allocn(void *p, int32 on, int32 n)
 {
 	void *q;
 
@@ -204,7 +204,7 @@ Sym*
 lookup(void)
 {
 	Sym *s;
-	long h;
+	int32 h;
 	char *p;
 	int c, l;
 
@@ -242,7 +242,7 @@ ISALPHA(int c)
 	return 0;
 }
 
-long
+int32
 yylex(void)
 {
 	int c, c1;
@@ -665,11 +665,11 @@ yyerror(char *a, ...)
 }
 
 void
-prfile(long l)
+prfile(int32 l)
 {
 	int i, n;
 	Hist a[HISTSZ], *h;
-	long d;
+	int32 d;
 
 	n = 0;
 	for(h = hist; h != H; h = h->link) {
@@ -729,5 +729,5 @@ ieeedtod(Ieee *ieee, double native)
 	fr = modf(fr*f, &ho);
 	ieee->l = ho;
 	ieee->l <<= 16;
-	ieee->l |= (long)(fr*f);
+	ieee->l |= (int32)(fr*f);
 }
diff --git a/src/cmd/cc/macbody b/src/cmd/cc/macbody
index 9d309c10d4..6077915e64 100644
--- a/src/cmd/cc/macbody
+++ b/src/cmd/cc/macbody
@@ -30,10 +30,10 @@
 
 #define VARMAC 0x80
 
-long
+int32
 getnsn(void)
 {
-	long n;
+	int32 n;
 	int c;
 
 	c = getnsc();
@@ -138,7 +138,7 @@ dodefine(char *cp)
 {
 	Sym *s;
 	char *p;
-	long l;
+	int32 l;
 
 	strcpy(symb, cp);
 	p = strchr(symb, '=');
@@ -604,7 +604,7 @@ maclin(void)
 {
 	char *cp;
 	int c;
-	long n;
+	int32 n;
 
 	n = getnsn();
 	c = getc();
diff --git a/src/cmd/cc/pgen.c b/src/cmd/cc/pgen.c
index ae0b1b40cd..336eefe322 100644
--- a/src/cmd/cc/pgen.c
+++ b/src/cmd/cc/pgen.c
@@ -95,7 +95,7 @@ void
 supgen(Node *n)
 {
 	int owarn;
-	long spc;
+	int32 spc;
 	Prog *sp;
 
 	if(n == Z)
@@ -119,7 +119,7 @@ gen(Node *n)
 	Node *l, nod;
 	Prog *sp, *spc, *spb;
 	Case *cn;
-	long sbc, scc;
+	int32 sbc, scc;
 	int snbreak, sncontin;
 	int f, o, oldreach;
 
diff --git a/src/cmd/cc/pickle.c b/src/cmd/cc/pickle.c
index 3626e4ad79..fb7ec585b5 100644
--- a/src/cmd/cc/pickle.c
+++ b/src/cmd/cc/pickle.c
@@ -125,7 +125,7 @@ pickleinit(void)
 }
 
 void
-picklemember(Type *t, long off)
+picklemember(Type *t, int32 off)
 {
 	Sym *s, *s1;
 	static int picklecharinit = 0;
diff --git a/src/cmd/cc/pswt.c b/src/cmd/cc/pswt.c
index f4149f17b3..02d4e64a05 100644
--- a/src/cmd/cc/pswt.c
+++ b/src/cmd/cc/pswt.c
@@ -47,7 +47,7 @@ doswit(Node *n)
 {
 	Case *c;
 	C1 *q, *iq;
-	long def, nc, i, isv;
+	int32 def, nc, i, isv;
 
 	def = 0;
 	nc = 0;
@@ -74,7 +74,7 @@ doswit(Node *n)
 		if(isv)
 			q->val = c->val;
 		else
-			q->val = (long)c->val;	/* cast ensures correct value for 32-bit switch on 64-bit architecture */
+			q->val = (int32)c->val;	/* cast ensures correct value for 32-bit switch on 64-bit architecture */
 		q++;
 	}
 	qsort(iq, nc, sizeof(C1), swcmp);
@@ -101,12 +101,12 @@ cas(void)
 	cases = c;
 }
 
-long
-outlstring(ushort *s, long n)
+int32
+outlstring(ushort *s, int32 n)
 {
 	char buf[2];
 	int c;
-	long r;
+	int32 r;
 
 	if(suppress)
 		return nstring;
@@ -164,5 +164,5 @@ ieeedtod(Ieee *ieee, double native)
 	fr = modf(fr*f, &ho);
 	ieee->l = ho;
 	ieee->l <<= 16;
-	ieee->l |= (long)(fr*f);
+	ieee->l |= (int32)(fr*f);
 }
diff --git a/src/cmd/cc/sub.c b/src/cmd/cc/sub.c
index fcf915cb8c..171c75232f 100644
--- a/src/cmd/cc/sub.c
+++ b/src/cmd/cc/sub.c
@@ -174,7 +174,7 @@ copytyp(Type *t)
 }
 
 Type*
-garbt(Type *t, long b)
+garbt(Type *t, int32 b)
 {
 	Type *t1;
 
@@ -187,7 +187,7 @@ garbt(Type *t, long b)
 }
 
 int
-simpleg(long b)
+simpleg(int32 b)
 {
 
 	b &= BGARB;
@@ -203,7 +203,7 @@ simpleg(long b)
 }
 
 int
-simplec(long b)
+simplec(int32 b)
 {
 
 	b &= BCLASS;
@@ -230,7 +230,7 @@ simplec(long b)
 }
 
 Type*
-simplet(long b)
+simplet(int32 b)
 {
 
 	b &= ~BCLASS & ~BGARB;
@@ -299,10 +299,10 @@ simplet(long b)
 }
 
 int
-stcompat(Node *n, Type *t1, Type *t2, long ttab[])
+stcompat(Node *n, Type *t1, Type *t2, int32 ttab[])
 {
 	int i;
-	ulong b;
+	uint32 b;
 
 	i = 0;
 	if(t2 != T)
@@ -326,7 +326,7 @@ stcompat(Node *n, Type *t1, Type *t2, long ttab[])
 }
 
 int
-tcompat(Node *n, Type *t1, Type *t2, long ttab[])
+tcompat(Node *n, Type *t1, Type *t2, int32 ttab[])
 {
 
 	if(stcompat(n, t1, t2, ttab)) {
@@ -342,7 +342,7 @@ tcompat(Node *n, Type *t1, Type *t2, long ttab[])
 }
 
 void
-makedot(Node *n, Type *t, long o)
+makedot(Node *n, Type *t, int32 o)
 {
 	Node *n1, *n2;
 
@@ -389,7 +389,7 @@ makedot(Node *n, Type *t, long o)
 }
 
 Type*
-dotsearch(Sym *s, Type *t, Node *n, long *off)
+dotsearch(Sym *s, Type *t, Node *n, int32 *off)
 {
 	Type *t1, *xt, *rt;
 
@@ -441,12 +441,12 @@ ambig:
 	return xt;
 }
 
-long
+int32
 dotoffset(Type *st, Type *lt, Node *n)
 {
 	Type *t;
 	Sym *g;
-	long o, o1;
+	int32 o, o1;
 
 	o = -1;
 	/*
@@ -574,7 +574,7 @@ typeext(Type *st, Node *l)
 {
 	Type *lt;
 	Node *n1, *n2;
-	long o;
+	int32 o;
 
 	lt = l->type;
 	if(lt == T)
@@ -689,7 +689,7 @@ arith(Node *n, int f)
 	Type *t1, *t2;
 	int i, j, k;
 	Node *n1;
-	long w;
+	int32 w;
 
 	t1 = n->left->type;
 	if(n->right == Z)
@@ -799,7 +799,7 @@ bad:
 void
 simplifyshift(Node *n)
 {
-	ulong c3;
+	uint32 c3;
 	int o, s1, s2, c1, c2;
 
 	if(!typechlp[n->type->etype])
@@ -1078,7 +1078,7 @@ bad:
 }
 
 int
-topbit(ulong v)
+topbit(uint32 v)
 {
 	int i;
 
@@ -1160,7 +1160,7 @@ invert(Node *n)
 }
 
 int
-bitno(long b)
+bitno(int32 b)
 {
 	int i;
 
@@ -1171,10 +1171,10 @@ bitno(long b)
 	return 0;
 }
 
-long
-typebitor(long a, long b)
+int32
+typebitor(int32 a, int32 b)
 {
-	long c;
+	int32 c;
 
 	c = a | b;
 	if(a & b)
@@ -1277,10 +1277,10 @@ fatal(Node *n, char *fmt, ...)
 	errorexit();
 }
 
-ulong	thash1	= 0x2edab8c9;
-ulong	thash2	= 0x1dc74fb8;
-ulong	thash3	= 0x1f241331;
-ulong	thash[NALLTYPES];
+uint32	thash1	= 0x2edab8c9;
+uint32	thash2	= 0x1dc74fb8;
+uint32	thash3	= 0x1f241331;
+uint32	thash[NALLTYPES];
 Init	thashinit[] =
 {
 	TXXX,		0x17527bbd,	0,
@@ -1618,7 +1618,7 @@ int	typesuinit[] =
 	TSTRUCT, TUNION, -1,
 };
 
-long	tasign[NTYPE];
+int32	tasign[NTYPE];
 Init	tasigninit[] =
 {
 	TCHAR,		BNUMBER,	0,
@@ -1639,7 +1639,7 @@ Init	tasigninit[] =
 	-1,		0,		0,
 };
 
-long	tasadd[NTYPE];
+int32	tasadd[NTYPE];
 Init	tasaddinit[] =
 {
 	TCHAR,		BNUMBER,	0,
@@ -1658,7 +1658,7 @@ Init	tasaddinit[] =
 	-1,		0,		0,
 };
 
-long	tcast[NTYPE];
+int32	tcast[NTYPE];
 Init	tcastinit[] =
 {
 	TCHAR,		BNUMBER|BIND|BVOID,	0,
@@ -1680,7 +1680,7 @@ Init	tcastinit[] =
 	-1,		0,			0,
 };
 
-long	tadd[NTYPE];
+int32	tadd[NTYPE];
 Init	taddinit[] =
 {
 	TCHAR,		BNUMBER|BIND,	0,
@@ -1699,7 +1699,7 @@ Init	taddinit[] =
 	-1,		0,		0,
 };
 
-long	tsub[NTYPE];
+int32	tsub[NTYPE];
 Init	tsubinit[] =
 {
 	TCHAR,		BNUMBER,	0,
@@ -1718,7 +1718,7 @@ Init	tsubinit[] =
 	-1,		0,		0,
 };
 
-long	tmul[NTYPE];
+int32	tmul[NTYPE];
 Init	tmulinit[] =
 {
 	TCHAR,		BNUMBER,	0,
@@ -1736,7 +1736,7 @@ Init	tmulinit[] =
 	-1,		0,		0,
 };
 
-long	tand[NTYPE];
+int32	tand[NTYPE];
 Init	tandinit[] =
 {
 	TCHAR,		BINTEGER,	0,
@@ -1752,7 +1752,7 @@ Init	tandinit[] =
 	-1,		0,		0,
 };
 
-long	trel[NTYPE];
+int32	trel[NTYPE];
 Init	trelinit[] =
 {
 	TCHAR,		BNUMBER,	0,
@@ -1771,27 +1771,27 @@ Init	trelinit[] =
 	-1,		0,		0,
 };
 
-long	tfunct[1] =
+int32	tfunct[1] =
 {
 	BFUNC,
 };
 
-long	tindir[1] =
+int32	tindir[1] =
 {
 	BIND,
 };
 
-long	tdot[1] =
+int32	tdot[1] =
 {
 	BSTRUCT|BUNION,
 };
 
-long	tnot[1] =
+int32	tnot[1] =
 {
 	BNUMBER|BIND,
 };
 
-long	targ[1] =
+int32	targ[1] =
 {
 	BNUMBER|BIND|BSTRUCT|BUNION,
 };
diff --git a/src/cmd/gc/const.c b/src/cmd/gc/const.c
index 36d7b4936a..2ee03c98a5 100644
--- a/src/cmd/gc/const.c
+++ b/src/cmd/gc/const.c
@@ -107,7 +107,7 @@ void
 evconst(Node *n)
 {
 	Node *nl, *nr;
-	long len;
+	int32 len;
 	String *str;
 	int wl, wr;
 
@@ -378,7 +378,7 @@ defaultlit(Node *n)
 int
 cmpslit(Node *l, Node *r)
 {
-	long l1, l2, i, m;
+	int32 l1, l2, i, m;
 	char *s1, *s2;
 
 	l1 = l->val.sval->len;
diff --git a/src/cmd/gc/dcl.c b/src/cmd/gc/dcl.c
index f1631fe605..4b86e8e3c2 100644
--- a/src/cmd/gc/dcl.c
+++ b/src/cmd/gc/dcl.c
@@ -919,7 +919,7 @@ fninit(Node *n)
 	Node *done, *any;
 	Node *a, *fn, *r;
 	Iter iter;
-	ulong h;
+	uint32 h;
 	Sym *s;
 
 	r = N;
diff --git a/src/cmd/gc/export.c b/src/cmd/gc/export.c
index 2a898f6607..839dc76597 100644
--- a/src/cmd/gc/export.c
+++ b/src/cmd/gc/export.c
@@ -273,7 +273,7 @@ void
 dumpexport(void)
 {
 	Dcl *d;
-	long lno;
+	int32 lno;
 
 	lno = lineno;
 
diff --git a/src/cmd/gc/go.h b/src/cmd/gc/go.h
index 9e37c79465..ed61378a21 100644
--- a/src/cmd/gc/go.h
+++ b/src/cmd/gc/go.h
@@ -52,7 +52,7 @@ enum
 typedef	struct	String	String;
 struct	String
 {
-	long	len;
+	int32	len;
 	char	s[3];	// variable
 };
 
@@ -83,7 +83,7 @@ struct	Type
 	uchar	outnamed;
 
 	Sym*	sym;
-	long	vargen;		// unique name for OTYPE/ONAME
+	int32	vargen;		// unique name for OTYPE/ONAME
 
 	// most nodes
 	Type*	type;
@@ -100,7 +100,7 @@ struct	Type
 	vlong	argwid;
 
 	// TARRAY
-	long	bound;
+	int32	bound;
 };
 #define	T	((Type*)0)
 
@@ -142,8 +142,8 @@ struct	Node
 	Sym*	fsym;		// import
 	Sym*	psym;		// import
 	Sym*	sym;		// various
-	long	vargen;		// unique name for OTYPE/ONAME
-	long	lineno;
+	int32	vargen;		// unique name for OTYPE/ONAME
+	int32	lineno;
 	vlong	xoffset;
 };
 #define	N	((Node*)0)
@@ -167,8 +167,8 @@ struct	Sym
 	Type*	forwtype;	// TPTR iff forward declared
 	void*	label;		// pointer to Prog* of label
 	vlong	offset;		// stack location if automatic
-	long	lexical;
-	long	vargen;		// unique variable number
+	int32	lexical;
+	int32	vargen;		// unique variable number
 	Sym*	link;
 };
 #define	S	((Sym*)0)
@@ -180,7 +180,7 @@ struct	Dcl
 	Sym*	dsym;		// for printing only
 	Node*	dnode;		// oname
 	Type*	dtype;		// otype
-	long	lineno;
+	int32	lineno;
 
 	Dcl*	forw;
 	Dcl*	back;		// sentinel has pointer to last
@@ -202,8 +202,8 @@ struct	Hist
 {
 	Hist*	link;
 	char*	name;
-	long	line;
-	long	offset;
+	int32	line;
+	int32	offset;
 };
 #define	H	((Hist*)0)
 
@@ -341,14 +341,14 @@ struct	Io
 {
 	char*	infile;
 	Biobuf*	bin;
-	long	ilineno;
+	int32	ilineno;
 	int	peekc;
 	char*	cp;	// used for content when bin==nil
 };
 
 EXTERN	Io	curio;
 EXTERN	Io	pushedio;
-EXTERN	long	lineno;
+EXTERN	int32	lineno;
 EXTERN	char*	pathname;
 EXTERN	Hist*	hist;
 EXTERN	Hist*	ehist;
@@ -394,12 +394,12 @@ EXTERN	int	inimportsys;
 
 EXTERN	Node*	booltrue;
 EXTERN	Node*	boolfalse;
-EXTERN	ulong	iota;
+EXTERN	uint32	iota;
 EXTERN	Node*	lastconst;
-EXTERN	long	vargen;
-EXTERN	long	exportgen;
-EXTERN	long	maxarg;
-EXTERN	long	stksize;
+EXTERN	int32	vargen;
+EXTERN	int32	exportgen;
+EXTERN	int32	maxarg;
+EXTERN	int32	stksize;
 EXTERN	ushort	blockgen;		// max block number
 EXTERN	ushort	block;			// current block number
 
@@ -410,8 +410,8 @@ EXTERN	char*	context;
 EXTERN	int	thechar;
 EXTERN	char*	thestring;
 EXTERN	char*	hunk;
-EXTERN	long	nhunk;
-EXTERN	long	thunk;
+EXTERN	int32	nhunk;
+EXTERN	int32	thunk;
 
 /*
  *	y.tab.c
@@ -426,10 +426,10 @@ void	setfilename(char*);
 void	importfile(Val*);
 void	cannedimports(void);
 void	unimportfile();
-long	yylex(void);
+int32	yylex(void);
 void	lexinit(void);
 char*	lexname(int);
-long	getr(void);
+int32	getr(void);
 int	getnsc(void);
 int	escchar(int, int*, vlong*);
 int	getc(void);
@@ -446,17 +446,17 @@ int	mpatov(char*, vlong*);
  *	subr.c
  */
 void	myexit(int);
-void*	mal(long);
-void*	remal(void*, long, long);
+void*	mal(int32);
+void*	remal(void*, int32, int32);
 void	errorexit(void);
-ulong	stringhash(char*);
+uint32	stringhash(char*);
 Sym*	lookup(char*);
 Sym*	pkglookup(char*, char*);
 void	yyerror(char*, ...);
 void	warn(char*, ...);
 void	fatal(char*, ...);
-void	linehist(char*, long);
-long	setlineno(Node*);
+void	linehist(char*, int32);
+int32	setlineno(Node*);
 Node*	nod(int, Node*, Node*);
 Node*	list(Node*, Node*);
 Type*	typ(int);
@@ -473,11 +473,11 @@ int	isbytearray(Type*);
 int	eqtype(Type*, Type*, int);
 void	argtype(Node*, Type*);
 int	eqargs(Type*, Type*);
-ulong	typehash(Type*, int);
+uint32	typehash(Type*, int);
 void	frame(int);
-Node*	literal(long);
+Node*	literal(int32);
 Node*	dobad(void);
-Node*	nodintconst(long);
+Node*	nodintconst(int32);
 void	ullmancalc(Node*);
 void	badtype(int, Type*, Type*);
 Type*	ptrto(Type*);
@@ -583,7 +583,7 @@ Node*	ascompatet(int, Node**, Type**, int);
 Node*	ascompatte(int, Type**, Node**, int);
 int	ascompat(Type*, Type*);
 Node*	prcompat(Node*);
-Node*	nodpanic(long);
+Node*	nodpanic(int32);
 Node*	newcompat(Node*);
 Node*	stringop(Node*, int);
 Type*	fixmap(Type*);
@@ -616,6 +616,6 @@ void	proglist(void);
 int	optopop(int);
 void	dumpobj(void);
 void	dowidth(Type*);
-void	argspace(long);
+void	argspace(int32);
 Node*	nodarg(Type*, int);
 void	nodconst(Node*, Type*, vlong);
diff --git a/src/cmd/gc/lex.c b/src/cmd/gc/lex.c
index a70186892c..567e441620 100644
--- a/src/cmd/gc/lex.c
+++ b/src/cmd/gc/lex.c
@@ -198,7 +198,7 @@ importfile(Val *f)
 {
 	Biobuf *imp;
 	char *file;
-	long c;
+	int32 c;
 	char *p;
 	int len;
 
@@ -283,7 +283,7 @@ cannedimports(void)
 	inimportsys = 1;
 }
 
-long
+int32
 yylex(void)
 {
 	int c, c1;
@@ -335,8 +335,8 @@ l0:
 	case '"':
 		/* "..." */
 		strcpy(namebuf, "\"<string>\"");
-		cp = mal(sizeof(long));
-		c1 = 4;
+		cp = mal(sizeof(int32));
+		c1 = sizeof(int32);
 
 	caseq:
 		for(;;) {
@@ -359,8 +359,8 @@ l0:
 	case '`':
 		/* `...` */
 		strcpy(namebuf, "`<string>`");
-		cp = mal(sizeof(long));
-		c1 = 4;
+		cp = mal(sizeof(int32));
+		c1 = sizeof(int32);
 
 	casebq:
 		for(;;) {
@@ -385,7 +385,7 @@ l0:
 			break;
 		}
 
-		*(long*)cp = c1-4;	// length
+		*(int32*)cp = c1-sizeof(int32);	// length
 		do {
 			cp = remal(cp, c1, 1);
 			cp[c1++] = 0;
@@ -781,7 +781,7 @@ ungetc(int c)
 		lineno--;
 }
 
-long
+int32
 getr(void)
 {
 	int c, i;
@@ -1212,7 +1212,7 @@ void
 mkpackage(char* pkg)
 {
 	Sym *s;
-	long h;
+	int32 h;
 	char *p;
 
 	if(bout != nil) {
diff --git a/src/cmd/gc/mpatof.c b/src/cmd/gc/mpatof.c
index 07bcf4a27a..3ddc6130f5 100644
--- a/src/cmd/gc/mpatof.c
+++ b/src/cmd/gc/mpatof.c
@@ -10,7 +10,7 @@ int	mpatov(char *s, vlong *v);
 
 enum
 {
-	Mpscale	= 29,		/* safely smaller than bits in a long */
+	Mpscale	= 29,		/* safely smaller than bits in a int32 */
 	Mpprec	= 36,		/* Mpscale*Mpprec sb > largest fp exp */
 	Mpbase	= 1L<<Mpscale,
 };
@@ -18,7 +18,7 @@ enum
 typedef
 struct
 {
-	long	a[Mpprec];
+	int32	a[Mpprec];
 	char	ovf;
 } Mp;
 
@@ -169,7 +169,7 @@ static int
 mptof(Mp *a, double *d)
 {
 	double f, g;
-	long x, *a1;
+	int32 x, *a1;
 	int i;
 
 	if(a->ovf)
@@ -200,7 +200,7 @@ static void
 mpadd(Mp *a, Mp *b)
 {
 	int i, c;
-	long x, *a1, *b1;
+	int32 x, *a1, *b1;
 
 	if(b->ovf)
 		a->ovf = 1;
diff --git a/src/cmd/gc/subr.c b/src/cmd/gc/subr.c
index db76f831ab..f34b2cc5bf 100644
--- a/src/cmd/gc/subr.c
+++ b/src/cmd/gc/subr.c
@@ -61,7 +61,7 @@ fatal(char *fmt, ...)
 }
 
 void
-linehist(char *file, long off)
+linehist(char *file, int32 off)
 {
 	Hist *h;
 	char *cp;
@@ -96,10 +96,10 @@ linehist(char *file, long off)
 	ehist = h;
 }
 
-long
+int32
 setlineno(Node *n)
 {
-	long lno;
+	int32 lno;
 
 	lno = lineno;
 	if(n != N && n->op != ONAME) {
@@ -113,10 +113,10 @@ setlineno(Node *n)
 	return lno;
 }
 
-ulong
+uint32
 stringhash(char *p)
 {
-	long h;
+	int32 h;
 	int c;
 
 	h = 0;
@@ -139,7 +139,7 @@ Sym*
 lookup(char *p)
 {
 	Sym *s;
-	ulong h;
+	uint32 h;
 	int c;
 
 	h = stringhash(p) % NHASH;
@@ -171,7 +171,7 @@ Sym*
 pkglookup(char *p, char *k)
 {
 	Sym *s;
-	ulong h;
+	uint32 h;
 	int c;
 
 	h = stringhash(p) % NHASH;
@@ -204,7 +204,7 @@ void
 gethunk(void)
 {
 	char *h;
-	long nh;
+	int32 nh;
 
 	nh = NHUNK;
 	if(thunk >= 10L*NHUNK)
@@ -220,11 +220,11 @@ gethunk(void)
 }
 
 void*
-mal(long n)
+mal(int32 n)
 {
 	void *p;
 
-	while((ulong)hunk & MAXALIGN) {
+	while((uintptr)hunk & MAXALIGN) {
 		hunk++;
 		nhunk--;
 	}
@@ -239,7 +239,7 @@ mal(long n)
 }
 
 void*
-remal(void *p, long on, long n)
+remal(void *p, int32 on, int32 n)
 {
 	void *q;
 
@@ -307,7 +307,7 @@ dobad(void)
 }
 
 Node*
-nodintconst(long v)
+nodintconst(int32 v)
 {
 	Node *c;
 
@@ -702,15 +702,15 @@ Lconv(Fmt *fp)
 	struct
 	{
 		Hist*	incl;	/* start of this include file */
-		long	idel;	/* delta line number to apply to include */
+		int32	idel;	/* delta line number to apply to include */
 		Hist*	line;	/* start of this #line directive */
-		long	ldel;	/* delta line number to apply to #line */
+		int32	ldel;	/* delta line number to apply to #line */
 	} a[HISTSZ];
-	long lno, d;
+	int32 lno, d;
 	int i, n;
 	Hist *h;
 
-	lno = va_arg(fp->args, long);
+	lno = va_arg(fp->args, int32);
 
 	n = 0;
 	for(h=hist; h!=H; h=h->link) {
@@ -1463,10 +1463,10 @@ eqargs(Type *t1, Type *t2)
 	return 1;
 }
 
-ulong
+uint32
 typehash(Type *at, int d)
 {
-	ulong h;
+	uint32 h;
 	Type *t;
 
 	if(at == T)
@@ -1524,7 +1524,7 @@ ptrto(Type *t)
 }
 
 Node*
-literal(long v)
+literal(int32 v)
 {
 	Node *n;
 
diff --git a/src/cmd/gc/walk.c b/src/cmd/gc/walk.c
index 8a494f72e9..329d10ceda 100644
--- a/src/cmd/gc/walk.c
+++ b/src/cmd/gc/walk.c
@@ -44,7 +44,7 @@ walktype(Node *n, int top)
 	Type *t;
 	Sym *s;
 	int et, cl, cr;
-	long lno;
+	int32 lno;
 
 	lno = setlineno(n);
 
@@ -1042,7 +1042,7 @@ walkselect(Node *sel)
 	Node *n, *oc, *on, *r;
 	Node *var, *bod, *res;
 	int count;
-	long lno;
+	int32 lno;
 
 	lno = setlineno(sel);
 
@@ -1459,7 +1459,7 @@ loop:
 }
 
 Node*
-nodpanic(long lineno)
+nodpanic(int32 lineno)
 {
 	Node *n, *on;
 
@@ -1513,7 +1513,7 @@ Node*
 stringop(Node *n, int top)
 {
 	Node *r, *c, *on;
-	long l;
+	int32 l;
 
 	switch(n->op) {
 	default:
diff --git a/src/libmach_amd64/6obj.c b/src/libmach_amd64/6obj.c
index 62c218e022..27bd6915bb 100644
--- a/src/libmach_amd64/6obj.c
+++ b/src/libmach_amd64/6obj.c
@@ -116,7 +116,7 @@ addr(Biobuf *bp)
 {
 	Addr a;
 	int t;
-	long l;
+	int32 l;
 	vlong off;
 
 	off = 0;
diff --git a/src/libmach_amd64/8.c b/src/libmach_amd64/8.c
index b6c87be123..301678fa0b 100644
--- a/src/libmach_amd64/8.c
+++ b/src/libmach_amd64/8.c
@@ -34,7 +34,7 @@
 #include <ureg_x86.h>
 #include <mach_amd64.h>
 
-#define	REGOFF(x)	(ulong)(&((struct Ureg *) 0)->x)
+#define	REGOFF(x)	(uintptr)(&((struct Ureg *) 0)->x)
 
 #define PC		REGOFF(pc)
 #define SP		REGOFF(sp)
diff --git a/src/libmach_amd64/8db.c b/src/libmach_amd64/8db.c
index 0ded151144..e4c62489fa 100644
--- a/src/libmach_amd64/8db.c
+++ b/src/libmach_amd64/8db.c
@@ -84,7 +84,7 @@ Machdata i386mach =
 	1,			/* break point size */
 
 	leswab,			/* convert short to local byte order */
-	leswal,			/* convert long to local byte order */
+	leswal,			/* convert int32 to local byte order */
 	leswav,			/* convert vlong to local byte order */
 	i386trace,		/* C traceback */
 	i386frame,		/* frame finder */
@@ -101,7 +101,7 @@ Machdata i386mach =
 static char*
 i386excep(Map *map, Rgetter rget)
 {
-	ulong c;
+	uint32 c;
 	uvlong pc;
 	static char buf[16];
 
@@ -210,9 +210,9 @@ struct	Instr
 	char	rip;		/* RIP-relative in amd64 mode */
 	uchar	opre;		/* f2/f3 could introduce media */
 	short	seg;		/* segment of far address */
-	ulong	disp;		/* displacement */
-	ulong 	imm;		/* immediate */
-	ulong 	imm2;		/* second immediate operand */
+	uint32	disp;		/* displacement */
+	uint32 	imm;		/* immediate */
+	uint32 	imm2;		/* second immediate operand */
 	uvlong	imm64;		/* big immediate */
 	char	*curr;		/* fill level in output buffer */
 	char	*end;		/* end of output buffer */
@@ -286,9 +286,9 @@ enum {
 	Iwdq,			/* Operand-sized immediate, possibly 64 bits */
 	Awd,			/* Address offset */
 	Iwds,			/* Operand-sized immediate (sign extended) */
-	RM,			/* Word or long R/M field with register (/r) */
+	RM,			/* Word or int32 R/M field with register (/r) */
 	RMB,			/* Byte R/M field with register (/r) */
-	RMOP,			/* Word or long R/M field with op code (/digit) */
+	RMOP,			/* Word or int32 R/M field with op code (/digit) */
 	RMOPB,			/* Byte R/M field with op code (/digit) */
 	RMR,			/* R/M register only (mod = 11) */
 	RMM,			/* R/M memory only (mod = 0/1/2) */
@@ -1294,10 +1294,10 @@ igets(Map *map, Instr *ip, ushort *sp)
  *  get 4 bytes of the instruction
  */
 static int
-igetl(Map *map, Instr *ip, ulong *lp)
+igetl(Map *map, Instr *ip, uint32 *lp)
 {
 	ushort s;
-	long	l;
+	int32	l;
 
 	if (igets(map, ip, &s) < 0)
 		return -1;
@@ -1315,7 +1315,7 @@ igetl(Map *map, Instr *ip, ulong *lp)
 static int
 igetq(Map *map, Instr *ip, vlong *qp)
 {
-	ulong	l;
+	uint32	l;
 	uvlong q;
 
 	if (igetl(map, ip, &l) < 0)
@@ -1483,7 +1483,7 @@ badop:
 				ip->imm = c|0xffffff00;
 			else
 				ip->imm = c&0xff;
-			ip->imm64 = (long)ip->imm;
+			ip->imm64 = (int32)ip->imm;
 			ip->jumptype = Jbs;
 			break;
 		case Ibs:	/* 8-bit immediate (sign extended) */
@@ -1496,7 +1496,7 @@ badop:
 					ip->imm = c|0xff00;
 			else
 				ip->imm = c&0xff;
-			ip->imm64 = (long)ip->imm;
+			ip->imm64 = (int32)ip->imm;
 			break;
 		case Iw:	/* 16-bit immediate -> imm */
 			if (igets(map, ip, &s) < 0)
@@ -1530,7 +1530,7 @@ badop:
 					return 0;
 				ip->imm64 = ip->imm;
 				if (ip->rex & REXW) {
-					ulong l;
+					uint32 l;
 					if (igetl(map, ip, &l) < 0)
 						return 0;
 					ip->imm64 |= (uvlong)l << 32;
@@ -1781,7 +1781,7 @@ static void
 plocal(Instr *ip)
 {
 	int ret;
-	long offset;
+	int32 offset;
 	Symbol s;
 	char *reg;
 
@@ -1826,10 +1826,10 @@ isjmp(Instr *ip)
  * are changed on sources.
  */
 static int
-issymref(Instr *ip, Symbol *s, long w, long val)
+issymref(Instr *ip, Symbol *s, int32 w, int32 val)
 {
 	Symbol next, tmp;
-	long isstring, size;
+	int32 isstring, size;
 
 	if (isjmp(ip))
 		return 1;
@@ -1869,7 +1869,7 @@ static void
 immediate(Instr *ip, vlong val)
 {
 	Symbol s;
-	long w;
+	int32 w;
 
 	if (findsym(val, CANY, &s)) {		/* TO DO */
 		w = val - s.value;
@@ -2036,9 +2036,9 @@ prinstr(Instr *ip, char *fmt)
 			break;
 		case 'p':
 			/*
-			 * signed immediate in the ulong ip->imm.
+			 * signed immediate in the uint32 ip->imm.
 			 */
-			v = (long)ip->imm;
+			v = (int32)ip->imm;
 			immediate(ip, v+ip->addr+ip->n);
 			break;
 		case 'r':
@@ -2154,7 +2154,7 @@ i386foll(Map *map, uvlong pc, Rgetter rget, uvlong *foll)
 		return 1;
 	case Iwds:		/* pc relative JUMP or CALL*/
 	case Jbs:		/* pc relative JUMP or CALL */
-		v = (long)i.imm;
+		v = (int32)i.imm;
 		foll[0] = pc+v+i.n;
 		n = 1;
 		break;
diff --git a/src/libmach_amd64/access.c b/src/libmach_amd64/access.c
index fe75f7131d..68cb927549 100644
--- a/src/libmach_amd64/access.c
+++ b/src/libmach_amd64/access.c
@@ -45,7 +45,7 @@ static	struct	segment*	reloc(Map*, uvlong, vlong*);
 int
 geta(Map *map, uvlong addr, uvlong *x)
 {
-	ulong l;
+	uint32 l;
 	uvlong vl;
 
 	if (mach->szaddr == 8){
@@ -81,7 +81,7 @@ get8(Map *map, uvlong addr, uvlong *x)
 }
 
 int
-get4(Map *map, uvlong addr, ulong *x)
+get4(Map *map, uvlong addr, uint32 *x)
 {
 	if (!map) {
 		werrstr("get4: invalid map");
@@ -158,7 +158,7 @@ put8(Map *map, uvlong addr, uvlong v)
 }
 
 int
-put4(Map *map, uvlong addr, ulong v)
+put4(Map *map, uvlong addr, uint32 v)
 {
 	if (!map) {
 		werrstr("put4: invalid map");
diff --git a/src/libmach_amd64/elf.h b/src/libmach_amd64/elf.h
index 1079b723e8..8dbc983f0a 100644
--- a/src/libmach_amd64/elf.h
+++ b/src/libmach_amd64/elf.h
@@ -35,9 +35,9 @@ typedef struct {
 	ushort	type;		/* file type */
 	ushort	machine;	/* target machine */
 	int	version;	/* file version */
-	ulong	elfentry;	/* start address */
-	ulong	phoff;		/* phdr file offset */
-	ulong	shoff;		/* shdr file offset */
+	uint32	elfentry;	/* start address */
+	uint32	phoff;		/* phdr file offset */
+	uint32	shoff;		/* shdr file offset */
 	int	flags;		/* file flags */
 	ushort	ehsize;		/* sizeof ehdr */
 	ushort	phentsize;	/* sizeof phdr */
@@ -66,11 +66,11 @@ typedef struct {
 
 typedef struct {
 	int	type;		/* entry type */
-	ulong	offset;		/* file offset */
-	ulong	vaddr;		/* virtual address */
-	ulong	paddr;		/* physical address */
+	uint32	offset;		/* file offset */
+	uint32	vaddr;		/* virtual address */
+	uint32	paddr;		/* physical address */
 	int	filesz;		/* file size */
-	ulong	memsz;		/* memory size */
+	uint32	memsz;		/* memory size */
 	int	flags;		/* entry flags */
 	int	align;		/* memory/file alignment */
 } Phdr32;
@@ -87,27 +87,27 @@ typedef struct {
 } Phdr64;
 
 typedef struct {
-	ulong	name;		/* section name */
-	ulong	type;		/* SHT_... */
-	ulong	flags;		/* SHF_... */
-	ulong	addr;		/* virtual address */
-	ulong	offset;		/* file offset */
-	ulong	size;		/* section size */
-	ulong	link;		/* misc info */
-	ulong	info;		/* misc info */
-	ulong	addralign;	/* memory alignment */
-	ulong	entsize;	/* entry size if table */
+	uint32	name;		/* section name */
+	uint32	type;		/* SHT_... */
+	uint32	flags;		/* SHF_... */
+	uint32	addr;		/* virtual address */
+	uint32	offset;		/* file offset */
+	uint32	size;		/* section size */
+	uint32	link;		/* misc info */
+	uint32	info;		/* misc info */
+	uint32	addralign;	/* memory alignment */
+	uint32	entsize;	/* entry size if table */
 } Shdr32;
 
 typedef struct {
-	ulong	name;		/* section name */
-	ulong	type;		/* SHT_... */
+	uint32	name;		/* section name */
+	uint32	type;		/* SHT_... */
 	uvlong	flags;		/* SHF_... */
 	uvlong	addr;		/* virtual address */
 	uvlong	offset;		/* file offset */
 	uvlong	size;		/* section size */
-	ulong	link;		/* misc info */
-	ulong	info;		/* misc info */
+	uint32	link;		/* misc info */
+	uint32	info;		/* misc info */
 	uvlong	addralign;	/* memory alignment */
 	uvlong	entsize;	/* entry size if table */
 } Shdr64;
diff --git a/src/libmach_amd64/executable.c b/src/libmach_amd64/executable.c
index 4f0356ebce..6c05102ab0 100644
--- a/src/libmach_amd64/executable.c
+++ b/src/libmach_amd64/executable.c
@@ -36,7 +36,7 @@
 
 /*
  *	All a.out header types.  The dummy entry allows canonical
- *	processing of the union as a sequence of longs
+ *	processing of the union as a sequence of int32s
  */
 
 typedef struct {
@@ -53,7 +53,7 @@ typedef struct {
 		struct nextexec next;	/* bootexec.h */
 		Machhdr machhdr;	/* macho.h */
 	} e;
-	long dummy;			/* padding to ensure extra long */
+	int32 dummy;			/* padding to ensure extra int32 */
 } ExecHdr;
 
 static	int	nextboot(int, Fhdr*, ExecHdr*);
@@ -66,25 +66,25 @@ static	int	adotout(int, Fhdr*, ExecHdr*);
 static	int	elfdotout(int, Fhdr*, ExecHdr*);
 static	int	machdotout(int, Fhdr*, ExecHdr*);
 static	int	armdotout(int, Fhdr*, ExecHdr*);
-static	void	setsym(Fhdr*, long, long, long, vlong);
-static	void	setdata(Fhdr*, uvlong, long, vlong, long);
-static	void	settext(Fhdr*, uvlong, uvlong, long, vlong);
-static	void	hswal(void*, int, ulong(*)(ulong));
-static	uvlong	_round(uvlong, ulong);
+static	void	setsym(Fhdr*, int32, int32, int32, vlong);
+static	void	setdata(Fhdr*, uvlong, int32, vlong, int32);
+static	void	settext(Fhdr*, uvlong, uvlong, int32, vlong);
+static	void	hswal(void*, int, uint32(*)(uint32));
+static	uvlong	_round(uvlong, uint32);
 
 /*
  *	definition of per-executable file type structures
  */
 
 typedef struct Exectable{
-	long	magic;			/* big-endian magic number of file */
+	int32	magic;			/* big-endian magic number of file */
 	char	*name;			/* executable identifier */
 	char	*dlmname;		/* dynamically loadable module identifier */
 	uchar	type;			/* Internal code */
 	uchar	_magic;			/* _MAGIC() magic */
 	Mach	*mach;			/* Per-machine data */
-	long	hsize;			/* header size */
-	ulong	(*swal)(ulong);		/* beswal or leswal */
+	int32	hsize;			/* header size */
+	uint32	(*swal)(uint32);		/* beswal or leswal */
 	int	(*hparse)(int, Fhdr*, ExecHdr*);
 } ExecTable;
 
@@ -336,7 +336,7 @@ crackhdr(int fd, Fhdr *fp)
 	ExecTable *mp;
 	ExecHdr d;
 	int nb, ret;
-	ulong magic;
+	uint32 magic;
 
 	fp->type = FNONE;
 	nb = read(fd, (char *)&d.e, sizeof(d.e));
@@ -383,7 +383,7 @@ crackhdr(int fd, Fhdr *fp)
 
 		mach = mp->mach;
 		if(mp->swal != nil)
-			hswal(&d, sizeof(d.e)/sizeof(ulong), mp->swal);
+			hswal(&d, sizeof(d.e)/sizeof(uint32), mp->swal);
 		ret = mp->hparse(fd, fp, &d);
 		seek(fd, mp->hsize, 0);		/* seek to end of header */
 		break;
@@ -397,9 +397,9 @@ crackhdr(int fd, Fhdr *fp)
  * Convert header to canonical form
  */
 static void
-hswal(void *v, int n, ulong (*swap)(ulong))
+hswal(void *v, int n, uint32 (*swap)(uint32))
 {
-	ulong *ulp;
+	uint32 *ulp;
 
 	for(ulp = v; n--; ulp++)
 		*ulp = (*swap)(*ulp);
@@ -411,7 +411,7 @@ hswal(void *v, int n, ulong (*swap)(ulong))
 static int
 adotout(int fd, Fhdr *fp, ExecHdr *hp)
 {
-	long pgsize;
+	int32 pgsize;
 
 	USED(fd);
 	pgsize = mach->pgsize;
@@ -491,10 +491,10 @@ common(int fd, Fhdr *fp, ExecHdr *hp)
 static int
 commonllp64(int unused, Fhdr *fp, ExecHdr *hp)
 {
-	long pgsize;
+	int32 pgsize;
 	uvlong entry;
 
-	hswal(&hp->e, sizeof(Exec)/sizeof(long), beswal);
+	hswal(&hp->e, sizeof(Exec)/sizeof(int32), beswal);
 	if(!(hp->e.exechdr.magic & HDR_MAGIC))
 		return 0;
 
@@ -634,7 +634,7 @@ elf64dotout(int fd, Fhdr *fp, ExecHdr *hp)
 {
 
 	uvlong (*swav)(uvlong);
-	ulong (*swal)(ulong);
+	uint32 (*swal)(uint32);
 	ushort (*swab)(ushort);
 	Ehdr64 *ep;
 	Phdr64 *ph;
@@ -721,7 +721,7 @@ elf64dotout(int fd, Fhdr *fp, ExecHdr *hp)
 		free(ph);
 		return 0;
 	}
-	hswal(ph, phsz/sizeof(ulong), swal);
+	hswal(ph, phsz/sizeof(uint32), swal);
 
 	shsz = sizeof(Shdr64)*ep->shnum;
 	sh = malloc(shsz);
@@ -731,7 +731,7 @@ elf64dotout(int fd, Fhdr *fp, ExecHdr *hp)
 			free(sh);
 			sh = 0;
 		} else
-			hswal(ph, phsz/sizeof(ulong), swal);
+			hswal(ph, phsz/sizeof(uint32), swal);
 	}
 
 	/* find text, data and symbols and install them */
@@ -757,7 +757,7 @@ elf64dotout(int fd, Fhdr *fp, ExecHdr *hp)
 		 * ph[1] : symsz, lcsz, 0, 0, symoff
 		 */
 		if(ep->machine == SPARC64 && ep->phnum == 2) {
-			ulong txtaddr, txtsz, dataddr, bsssz;
+			uint32 txtaddr, txtsz, dataddr, bsssz;
 
 			txtaddr = ph[0].vaddr | 0x80000000;
 			txtsz = ph[0].filesz - ph[0].paddr;
@@ -822,7 +822,7 @@ static int
 elfdotout(int fd, Fhdr *fp, ExecHdr *hp)
 {
 
-	ulong (*swal)(ulong);
+	uint32 (*swal)(uint32);
 	ushort (*swab)(ushort);
 	Ehdr32 *ep;
 	Phdr32 *ph;
@@ -905,7 +905,7 @@ elfdotout(int fd, Fhdr *fp, ExecHdr *hp)
 		free(ph);
 		return 0;
 	}
-	hswal(ph, phsz/sizeof(ulong), swal);
+	hswal(ph, phsz/sizeof(uint32), swal);
 
 	/* find text, data and symbols and install them */
 	it = id = is = -1;
@@ -930,7 +930,7 @@ elfdotout(int fd, Fhdr *fp, ExecHdr *hp)
 		 * ph[1] : symsz, lcsz, 0, 0, symoff
 		 */
 		if(ep->machine == SPARC64 && ep->phnum == 2) {
-			ulong txtaddr, txtsz, dataddr, bsssz;
+			uint32 txtaddr, txtsz, dataddr, bsssz;
 
 			txtaddr = ph[0].vaddr | 0x80000000;
 			txtsz = ph[0].filesz - ph[0].paddr;
@@ -960,7 +960,7 @@ static int
 machdotout(int fd, Fhdr *fp, ExecHdr *hp)
 {
 	uvlong (*swav)(uvlong);
-	ulong (*swal)(ulong);
+	uint32 (*swal)(uint32);
 	ushort (*swab)(ushort);
 	Machhdr *mp;
 	MachCmd **cmd;
@@ -1117,7 +1117,7 @@ armdotout(int fd, Fhdr *fp, ExecHdr *hp)
 }
 
 static void
-settext(Fhdr *fp, uvlong e, uvlong a, long s, vlong off)
+settext(Fhdr *fp, uvlong e, uvlong a, int32 s, vlong off)
 {
 	fp->txtaddr = a;
 	fp->entry = e;
@@ -1126,7 +1126,7 @@ settext(Fhdr *fp, uvlong e, uvlong a, long s, vlong off)
 }
 
 static void
-setdata(Fhdr *fp, uvlong a, long s, vlong off, long bss)
+setdata(Fhdr *fp, uvlong a, int32 s, vlong off, int32 bss)
 {
 	fp->dataddr = a;
 	fp->datsz = s;
@@ -1135,7 +1135,7 @@ setdata(Fhdr *fp, uvlong a, long s, vlong off, long bss)
 }
 
 static void
-setsym(Fhdr *fp, long symsz, long sppcsz, long lnpcsz, vlong symoff)
+setsym(Fhdr *fp, int32 symsz, int32 sppcsz, int32 lnpcsz, vlong symoff)
 {
 	fp->symsz = symsz;
 	fp->symoff = symoff;
@@ -1147,7 +1147,7 @@ setsym(Fhdr *fp, long symsz, long sppcsz, long lnpcsz, vlong symoff)
 
 
 static uvlong
-_round(uvlong a, ulong b)
+_round(uvlong a, uint32 b)
 {
 	uvlong w;
 
diff --git a/src/libmach_amd64/machdata.c b/src/libmach_amd64/machdata.c
index 8a25d1d924..dfbce3acd6 100644
--- a/src/libmach_amd64/machdata.c
+++ b/src/libmach_amd64/machdata.c
@@ -98,7 +98,7 @@ symoff(char *buf, int n, uvlong v, int space)
 {
 	Symbol s;
 	int r;
-	long delta;
+	int32 delta;
 
 	r = delta = 0;		/* to shut compiler up */
 	if (v) {
@@ -132,7 +132,7 @@ int
 fpformat(Map *map, Reglist *rp, char *buf, int n, int modif)
 {
 	char reg[12];
-	ulong r;
+	uint32 r;
 
 	switch(rp->rformat)
 	{
@@ -180,9 +180,9 @@ fpformat(Map *map, Reglist *rp, char *buf, int n, int modif)
 }
 
 char *
-_hexify(char *buf, ulong p, int zeros)
+_hexify(char *buf, uint32 p, int zeros)
 {
-	ulong d;
+	uint32 d;
 
 	d = p/16;
 	if(d)
@@ -200,7 +200,7 @@ _hexify(char *buf, ulong p, int zeros)
  * double format.  Naive but workable, probably.
  */
 int
-ieeedftos(char *buf, int n, ulong h, ulong l)
+ieeedftos(char *buf, int n, uint32 h, uint32 l)
 {
 	double fr;
 	int exp;
@@ -238,7 +238,7 @@ ieeedftos(char *buf, int n, ulong h, ulong l)
 }
 
 int
-ieeesftos(char *buf, int n, ulong h)
+ieeesftos(char *buf, int n, uint32 h)
 {
 	double fr;
 	int exp;
@@ -273,25 +273,25 @@ ieeesftos(char *buf, int n, ulong h)
 int
 beieeesftos(char *buf, int n, void *s)
 {
-	return ieeesftos(buf, n, beswal(*(ulong*)s));
+	return ieeesftos(buf, n, beswal(*(uint32*)s));
 }
 
 int
 beieeedftos(char *buf, int n, void *s)
 {
-	return ieeedftos(buf, n, beswal(*(ulong*)s), beswal(((ulong*)(s))[1]));
+	return ieeedftos(buf, n, beswal(*(uint32*)s), beswal(((uint32*)(s))[1]));
 }
 
 int
 leieeesftos(char *buf, int n, void *s)
 {
-	return ieeesftos(buf, n, leswal(*(ulong*)s));
+	return ieeesftos(buf, n, leswal(*(uint32*)s));
 }
 
 int
 leieeedftos(char *buf, int n, void *s)
 {
-	return ieeedftos(buf, n, leswal(((ulong*)(s))[1]), leswal(*(ulong*)s));
+	return ieeedftos(buf, n, leswal(((uint32*)(s))[1]), leswal(*(uint32*)s));
 }
 
 /* packed in 12 bytes, with s[2]==s[3]==0; mantissa starts at s[4]*/
@@ -300,7 +300,7 @@ beieee80ftos(char *buf, int n, void *s)
 {
 	uchar *reg = (uchar*)s;
 	int i;
-	ulong x;
+	uint32 x;
 	uchar ieee[8+8];	/* room for slop */
 	uchar *p, *q;
 
diff --git a/src/libmach_amd64/macho.h b/src/libmach_amd64/macho.h
index 26ce48b363..d391fc959f 100644
--- a/src/libmach_amd64/macho.h
+++ b/src/libmach_amd64/macho.h
@@ -7,19 +7,19 @@
  */
 
 typedef struct {
-	ulong	magic;		/* mach magic number identifier */
-	ulong	cputype;	/* cpu specifier */
-	ulong	cpusubtype;	/* machine specifier */
-	ulong	filetype;	/* type of file */
-	ulong	ncmds;		/* number of load commands */
-	ulong	sizeofcmds;	/* the size of all the load commands */
-	ulong	flags;		/* flags */
-	ulong	reserved;	/* reserved */
+	uint32	magic;		/* mach magic number identifier */
+	uint32	cputype;	/* cpu specifier */
+	uint32	cpusubtype;	/* machine specifier */
+	uint32	filetype;	/* type of file */
+	uint32	ncmds;		/* number of load commands */
+	uint32	sizeofcmds;	/* the size of all the load commands */
+	uint32	flags;		/* flags */
+	uint32	reserved;	/* reserved */
 } Machhdr;
 
 typedef struct {
-	ulong	type;	/* type of load command */
-	ulong	size;	/* total size in bytes */
+	uint32	type;	/* type of load command */
+	uint32	size;	/* total size in bytes */
 } MachCmd;
 
 typedef struct  {
@@ -29,16 +29,16 @@ typedef struct  {
 	uvlong	vmsize;		/* memory size of this segment */
 	uvlong	fileoff;	/* file offset of this segment */
 	uvlong	filesize;	/* amount to map from the file */
-	ulong	maxprot;	/* maximum VM protection */
-	ulong	initprot;	/* initial VM protection */
-	ulong	nsects;		/* number of sections in segment */
-	ulong	flags;		/* flags */
+	uint32	maxprot;	/* maximum VM protection */
+	uint32	initprot;	/* initial VM protection */
+	uint32	nsects;		/* number of sections in segment */
+	uint32	flags;		/* flags */
 } MachSeg64; /* for 64-bit architectures */
 
 typedef struct  {
 	MachCmd	cmd;
-	ulong	fileoff;	/* file offset of this segment */
-	ulong	filesize;	/* amount to map from the file */
+	uint32	fileoff;	/* file offset of this segment */
+	uint32	filesize;	/* amount to map from the file */
 } MachSymSeg;
 
 typedef struct  {
@@ -46,14 +46,14 @@ typedef struct  {
 	char		segname[16];	/* segment this section goes in */
 	uvlong	addr;		/* memory address of this section */
 	uvlong	size;		/* size in bytes of this section */
-	ulong	offset;		/* file offset of this section */
-	ulong	align;		/* section alignment (power of 2) */
-	ulong	reloff;		/* file offset of relocation entries */
-	ulong	nreloc;		/* number of relocation entries */
-	ulong	flags;		/* flags (section type and attributes)*/
-	ulong	reserved1;	/* reserved (for offset or index) */
-	ulong	reserved2;	/* reserved (for count or sizeof) */
-	ulong	reserved3;	/* reserved */
+	uint32	offset;		/* file offset of this section */
+	uint32	align;		/* section alignment (power of 2) */
+	uint32	reloff;		/* file offset of relocation entries */
+	uint32	nreloc;		/* number of relocation entries */
+	uint32	flags;		/* flags (section type and attributes)*/
+	uint32	reserved1;	/* reserved (for offset or index) */
+	uint32	reserved2;	/* reserved (for count or sizeof) */
+	uint32	reserved3;	/* reserved */
 } MachSect64; /* for 64-bit architectures */
 
 enum {
diff --git a/src/libmach_amd64/obj.c b/src/libmach_amd64/obj.c
index c4bb1b905d..7a6e204510 100644
--- a/src/libmach_amd64/obj.c
+++ b/src/libmach_amd64/obj.c
@@ -240,7 +240,7 @@ processprog(Prog *p, int doautos)
 static void
 objlookup(int id, char *name, int type, uint sig)
 {
-	long h;
+	int32 h;
 	char *cp;
 	Sym *s;
 	Symtab *sp;
@@ -351,7 +351,7 @@ nextar(Biobuf *bp, int offset, char *buf)
 {
 	struct ar_hdr a;
 	int i, r;
-	long arsize;
+	int32 arsize;
 
 	if (offset&01)
 		offset++;
diff --git a/src/libmach_amd64/swap.c b/src/libmach_amd64/swap.c
index 77cdac8a03..bc296a3d7a 100644
--- a/src/libmach_amd64/swap.c
+++ b/src/libmach_amd64/swap.c
@@ -41,10 +41,10 @@ beswab(ushort s)
 }
 
 /*
- * big-endian long
+ * big-endian int32
  */
-ulong
-beswal(ulong l)
+uint32
+beswal(uint32 l)
 {
 	uchar *p;
 
@@ -80,10 +80,10 @@ leswab(ushort s)
 }
 
 /*
- * little-endian long
+ * little-endian int32
  */
-ulong
-leswal(ulong l)
+uint32
+leswal(uint32 l)
 {
 	uchar *p;
 
diff --git a/src/libmach_amd64/sym.c b/src/libmach_amd64/sym.c
index e43111546e..b5e0ac6d87 100644
--- a/src/libmach_amd64/sym.c
+++ b/src/libmach_amd64/sym.c
@@ -46,8 +46,8 @@ struct txtsym {				/* Text Symbol table */
 
 struct hist {				/* Stack of include files & #line directives */
 	char	*name;			/* Assumes names Null terminated in file */
-	long	line;			/* line # where it was included */
-	long	offset;			/* line # of #line directive */
+	int32	line;			/* line # where it was included */
+	int32	offset;			/* line # of #line directive */
 };
 
 struct file {				/* Per input file header to history stack */
@@ -69,11 +69,11 @@ static	Sym	**fnames;		/* file names path component table */
 static	Sym	**globals;		/* globals by addr table */
 static	Hist	*hist;			/* base of history stack */
 static	int	isbuilt;		/* internal table init flag */
-static	long	nauto;			/* number of automatics */
-static	long	nfiles;			/* number of files */
-static	long	nglob;			/* number of globals */
-static	long	nhist;			/* number of history stack entries */
-static	long	nsym;			/* number of symbols */
+static	int32	nauto;			/* number of automatics */
+static	int32	nfiles;			/* number of files */
+static	int32	nglob;			/* number of globals */
+static	int32	nhist;			/* number of history stack entries */
+static	int32	nsym;			/* number of symbols */
 static	int	ntxt;			/* number of text symbols */
 static	uchar	*pcline;		/* start of pc-line state table */
 static	uchar 	*pclineend;		/* end of pc-line table */
@@ -86,15 +86,15 @@ static	uvlong	txtend;			/* end of text segment */
 static	uvlong	firstinstr;		/* as found from symtab; needed for amd64 */
 
 static void	cleansyms(void);
-static long	decodename(Biobuf*, Sym*);
+static int32	decodename(Biobuf*, Sym*);
 static short	*encfname(char*);
-static int 	fline(char*, int, long, Hist*, Hist**);
+static int 	fline(char*, int, int32, Hist*, Hist**);
 static void	fillsym(Sym*, Symbol*);
 static int	findglobal(char*, Symbol*);
 static int	findlocvar(Symbol*, char *, Symbol*);
 static int	findtext(char*, Symbol*);
 static int	hcomp(Hist*, short*);
-static int	hline(File*, short*, long*);
+static int	hline(File*, short*, int32*);
 static void	printhist(char*, Hist*, int);
 static int	buildtbls(void);
 static int	symcomp(const void*, const void*);
@@ -109,7 +109,7 @@ int
 syminit(int fd, Fhdr *fp)
 {
 	Sym *p;
-	long i, l, size;
+	int32 i, l, size;
 	vlong vl;
 	Biobuf b;
 	int svalsz;
@@ -228,12 +228,12 @@ symerrmsg(int n, char *table)
 	return -1;
 }
 
-static long
+static int32
 decodename(Biobuf *bp, Sym *p)
 {
 	char *cp;
 	int c1, c2;
-	long n;
+	int32 n;
 	vlong o;
 
 	if((p->type & 0x80) == 0) {		/* old-style, fixed length names */
@@ -352,7 +352,7 @@ textseg(uvlong base, Fhdr *fp)
  *		(special hack for high access rate operations)
  */
 Sym *
-symbase(long *n)
+symbase(int32 *n)
 {
 	*n = nsym;
 	return symbols;
@@ -375,7 +375,7 @@ getsym(int index)
 static int
 buildtbls(void)
 {
-	long i;
+	int32 i;
 	int j, nh, ng, nt;
 	File *f;
 	Txtsym *tp;
@@ -607,7 +607,7 @@ findtext(char *name, Symbol *s)
 static int
 findglobal(char *name, Symbol *s)
 {
-	long i;
+	int32 i;
 
 	for(i = 0; i < nglob; i++) {
 		if(cdotstrcmp(globals[i]->name, name) == 0) {
@@ -881,10 +881,10 @@ globalsym(Symbol *s, int index)
  *	find the pc given a file name and line offset into it.
  */
 uvlong
-file2pc(char *file, long line)
+file2pc(char *file, int32 line)
 {
 	File *fp;
-	long i;
+	int32 i;
 	uvlong pc, start, end;
 	short *name;
 
@@ -980,11 +980,11 @@ encfname(char *file)
  *	the size of intervening files in the stack.
  */
 static int
-hline(File *fp, short *name, long *line)
+hline(File *fp, short *name, int32 *line)
 {
 	Hist *hp;
 	int offset, depth;
-	long ln;
+	int32 ln;
 
 	for(hp = fp->hist; hp->name; hp++)		/* find name in stack */
 		if(hp->name[1] || hp->name[2]) {
@@ -1053,10 +1053,10 @@ hcomp(Hist *hp, short *sp)
 /*
  *	Convert a pc to a "file:line {file:line}" string.
  */
-long
+int32
 fileline(char *str, int n, uvlong dot)
 {
-	long line, top, bot, mid;
+	int32 line, top, bot, mid;
 	File *f;
 
 	*str = 0;
@@ -1087,11 +1087,11 @@ fileline(char *str, int n, uvlong dot)
  *	file with included files inserted in line.
  */
 static int
-fline(char *str, int n, long line, Hist *base, Hist **ret)
+fline(char *str, int n, int32 line, Hist *base, Hist **ret)
 {
 	Hist *start;			/* start of current level */
 	Hist *h;			/* current entry */
-	long delta;			/* sum of size of files this level */
+	int32 delta;			/* sum of size of files this level */
 	int k;
 
 	start = base;
@@ -1287,12 +1287,12 @@ pc2sp(uvlong pc)
 /*
  *	find the source file line number for a given value of the pc
  */
-long
+int32
 pc2line(uvlong pc)
 {
 	uchar *c, u;
 	uvlong currpc;
-	long currline;
+	int32 currline;
 
 	if(pcline == 0)
 		return -1;
@@ -1331,12 +1331,12 @@ pc2line(uvlong pc)
  *	a file and the first text address in the following file, respectively.
  */
 uvlong
-line2addr(long line, uvlong basepc, uvlong endpc)
+line2addr(int32 line, uvlong basepc, uvlong endpc)
 {
 	uchar *c,  u;
 	uvlong currpc, pc;
-	long currline;
-	long delta, d;
+	int32 currline;
+	int32 delta, d;
 	int found;
 
 	if(pcline == 0 || line == 0)
