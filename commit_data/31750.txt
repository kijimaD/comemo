commit 84b9329bd9085a47325818005b6162af265ddfa4
Author: Josh Bleecher Snyder <josharian@gmail.com>
Date:   Sun Nov 6 11:08:08 2016 -0800

    cmd/compile: add Type.LongString and Type.ShortString
    
    Reduces duplication and centralizes documentation.
    Moves all uses of FmtUnsigned and tconv inside fmt.go.
    
    Passes toolstash -cmp.
    
    Change-Id: If6d906e7e839de05f36423523a3a1d596e29807d
    Reviewed-on: https://go-review.googlesource.com/38141
    Run-TryBot: Josh Bleecher Snyder <josharian@gmail.com>
    TryBot-Result: Gobot Gobot <gobot@golang.org>
    Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org>
    Reviewed-by: Robert Griesemer <gri@golang.org>
---
 src/cmd/compile/internal/gc/fmt.go     | 20 ++++++++++++++++++++
 src/cmd/compile/internal/gc/reflect.go | 12 ++++++------
 src/cmd/compile/internal/gc/subr.go    |  9 ++-------
 src/cmd/compile/internal/gc/swt.go     |  4 +---
 4 files changed, 29 insertions(+), 16 deletions(-)

diff --git a/src/cmd/compile/internal/gc/fmt.go b/src/cmd/compile/internal/gc/fmt.go
index 3c6c47fe8e..73d5c086d4 100644
--- a/src/cmd/compile/internal/gc/fmt.go
+++ b/src/cmd/compile/internal/gc/fmt.go
@@ -1604,6 +1604,26 @@ func (t *Type) String() string {
 	return t.tconv(0)
 }
 
+// ShortString generates a short description of t.
+// It is used in autogenerated method names, reflection,
+// and itab names.
+func (t *Type) ShortString() string {
+	if fmtmode != FErr {
+		Fatalf("ShortString fmtmode %v", fmtmode)
+	}
+	return t.tconv(FmtLeft)
+}
+
+// LongString generates a complete description of t.
+// It is useful for reflection,
+// or when a unique fingerprint or hash of a type is required.
+func (t *Type) LongString() string {
+	if fmtmode != FErr {
+		Fatalf("LongString fmtmode %v", fmtmode)
+	}
+	return t.tconv(FmtLeft | FmtUnsigned)
+}
+
 func fldconv(f *Field, flag FmtFlag) string {
 	if f == nil {
 		return "<T>"
diff --git a/src/cmd/compile/internal/gc/reflect.go b/src/cmd/compile/internal/gc/reflect.go
index d2c5aafd8b..a09a075b4c 100644
--- a/src/cmd/compile/internal/gc/reflect.go
+++ b/src/cmd/compile/internal/gc/reflect.go
@@ -875,7 +875,7 @@ func dcommontype(s *Sym, ot int, t *Type) int {
 	}
 
 	exported := false
-	p := t.tconv(FmtLeft | FmtUnsigned)
+	p := t.LongString()
 	// If we're writing out type T,
 	// we are very likely to write out type *T as well.
 	// Use the string "*T"[1:] for "T", so that the two
@@ -940,7 +940,7 @@ func dcommontype(s *Sym, ot int, t *Type) int {
 }
 
 func typesym(t *Type) *Sym {
-	name := t.tconv(FmtLeft)
+	name := t.ShortString()
 
 	// Use a separate symbol name for Noalg types for #17752.
 	if a, bad := algtype1(t); a == ANOEQ && bad.Noalg() {
@@ -953,11 +953,11 @@ func typesym(t *Type) *Sym {
 // tracksym returns the symbol for tracking use of field/method f, assumed
 // to be a member of struct/interface type t.
 func tracksym(t *Type, f *Field) *Sym {
-	return Pkglookup(t.tconv(FmtLeft)+"."+f.Sym.Name, trackpkg)
+	return Pkglookup(t.ShortString()+"."+f.Sym.Name, trackpkg)
 }
 
 func typesymprefix(prefix string, t *Type) *Sym {
-	p := prefix + "." + t.tconv(FmtLeft)
+	p := prefix + "." + t.ShortString()
 	s := Pkglookup(p, typepkg)
 
 	//print("algsym: %s -> %+S\n", p, s);
@@ -996,7 +996,7 @@ func itabname(t, itype *Type) *Node {
 	if t == nil || (t.IsPtr() && t.Elem() == nil) || t.IsUntyped() || !itype.IsInterface() || itype.IsEmptyInterface() {
 		Fatalf("itabname(%v, %v)", t, itype)
 	}
-	s := Pkglookup(t.tconv(FmtLeft)+","+itype.tconv(FmtLeft), itabpkg)
+	s := Pkglookup(t.ShortString()+","+itype.ShortString(), itabpkg)
 	if s.Def == nil {
 		n := newname(s)
 		n.Type = Types[TUINT8]
@@ -1420,7 +1420,7 @@ func dumptypestructs() {
 		// method functions. None are allocated on heap, so we can use obj.NOPTR.
 		ggloblsym(i.sym, int32(o), int16(obj.DUPOK|obj.NOPTR))
 
-		ilink := Pkglookup(i.t.tconv(FmtLeft)+","+i.itype.tconv(FmtLeft), itablinkpkg)
+		ilink := Pkglookup(i.t.ShortString()+","+i.itype.ShortString(), itablinkpkg)
 		dsymptr(ilink, 0, i.sym, 0)
 		ggloblsym(ilink, int32(Widthptr), int16(obj.DUPOK|obj.RODATA))
 	}
diff --git a/src/cmd/compile/internal/gc/subr.go b/src/cmd/compile/internal/gc/subr.go
index 880f1350d3..f8a7f26420 100644
--- a/src/cmd/compile/internal/gc/subr.go
+++ b/src/cmd/compile/internal/gc/subr.go
@@ -1086,14 +1086,9 @@ func syslook(name string) *Node {
 	return s.Def
 }
 
-// typehash computes a hash value for type t to use in type switch
-// statements.
+// typehash computes a hash value for type t to use in type switch statements.
 func typehash(t *Type) uint32 {
-	// t.tconv(FmtLeft | FmtUnsigned) already contains all the necessary logic
-	// to generate a representation that completely describes the type, so using
-	// it here avoids duplicating that code.
-	// See the comments in exprSwitch.checkDupCases.
-	p := t.tconv(FmtLeft | FmtUnsigned)
+	p := t.LongString()
 
 	// Using MD5 is overkill, but reduces accidental collisions.
 	h := md5.Sum([]byte(p))
diff --git a/src/cmd/compile/internal/gc/swt.go b/src/cmd/compile/internal/gc/swt.go
index d91b2e7a12..679c144545 100644
--- a/src/cmd/compile/internal/gc/swt.go
+++ b/src/cmd/compile/internal/gc/swt.go
@@ -659,9 +659,7 @@ func (s *exprSwitch) checkDupCases(cc []caseClause) {
 		}
 		n := c.node.Left
 		tv := typeVal{
-			// n.Type.tconv(FmtLeft | FmtUnsigned) here serves to completely describe the type.
-			// See the comments in func typehash.
-			typ: n.Type.tconv(FmtLeft | FmtUnsigned),
+			typ: n.Type.LongString(),
 			val: n.Val().Interface(),
 		}
 		prev, dup := seen[tv]
