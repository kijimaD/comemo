commit e71fc0c1fe3787e6398c50377097ee34b2e63981
Author: Alex Brainman <alex.brainman@gmail.com>
Date:   Thu Jul 7 10:40:45 2011 +1000

    syscall: rearrange windows code so 386 and amd64 can share files
    
    R=golang-dev, r
    CC=golang-dev, vcc.163
    https://golang.org/cl/4641093
---
 src/pkg/os/Makefile                       |    2 +-
 src/pkg/syscall/Makefile                  |    2 +
 src/pkg/syscall/asm_windows_386.s         |    2 +-
 src/pkg/syscall/asm_windows_amd64.s       |    7 +
 src/pkg/syscall/mkall.sh                  |   11 +-
 src/pkg/syscall/syscall_windows.go        |    2 +
 src/pkg/syscall/syscall_windows_386.go    |    2 -
 src/pkg/syscall/syscall_windows_amd64.go  |    5 +
 src/pkg/syscall/zerrors_windows.go        |  283 ++++++
 src/pkg/syscall/zerrors_windows_386.go    |  284 +------
 src/pkg/syscall/zerrors_windows_amd64.go  |    5 +
 src/pkg/syscall/zsyscall_windows_386.go   |    2 +-
 src/pkg/syscall/zsyscall_windows_amd64.go | 1323 +++++++++++++++++++++++++++++
 src/pkg/syscall/zsysnum_windows_amd64.go  |    3 +
 src/pkg/syscall/ztypes_windows.go         |  656 ++++++++++++++
 src/pkg/syscall/ztypes_windows_386.go     |  659 +-------------
 src/pkg/syscall/ztypes_windows_amd64.go   |    5 +
 17 files changed, 2311 insertions(+), 942 deletions(-)

diff --git a/src/pkg/os/Makefile b/src/pkg/os/Makefile
index 060cc970d1..354e1e8db5 100644
--- a/src/pkg/os/Makefile
+++ b/src/pkg/os/Makefile
@@ -84,5 +84,5 @@ include ../../Make.pkg
 signal_unix.go: ../syscall/zerrors_$(GOOS)_$(GOARCH).go
 	./mkunixsignals.sh $< > $@ || rm -f $@
 
-signal_windows.go: ../syscall/ztypes_$(GOOS)_$(GOARCH).go
+signal_windows.go: ../syscall/ztypes_$(GOOS).go
 	./mkunixsignals.sh $< > $@ || rm -f $@
diff --git a/src/pkg/syscall/Makefile b/src/pkg/syscall/Makefile
index d7bd58373b..212b6f85d8 100644
--- a/src/pkg/syscall/Makefile
+++ b/src/pkg/syscall/Makefile
@@ -41,6 +41,8 @@ GOFILES_linux=\
 
 GOFILES_windows=\
 	exec_windows.go\
+	zerrors_windows.go\
+	ztypes_windows.go\
 
 GOFILES_plan9=\
 	exec_plan9.go\
diff --git a/src/pkg/syscall/asm_windows_386.s b/src/pkg/syscall/asm_windows_386.s
index 3d9f6fc943..a7b95643dd 100644
--- a/src/pkg/syscall/asm_windows_386.s
+++ b/src/pkg/syscall/asm_windows_386.s
@@ -3,5 +3,5 @@
 // license that can be found in the LICENSE file.
 
 //
-// System calls for 386, Windows are implemented in ../runtime/windows/syscall.cgo
+// System calls for 386, Windows are implemented in ../runtime/windows/syscall.goc
 //
diff --git a/src/pkg/syscall/asm_windows_amd64.s b/src/pkg/syscall/asm_windows_amd64.s
new file mode 100644
index 0000000000..8b38710c79
--- /dev/null
+++ b/src/pkg/syscall/asm_windows_amd64.s
@@ -0,0 +1,7 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//
+// System calls for amd64, Windows are implemented in ../runtime/windows/syscall.goc
+//
diff --git a/src/pkg/syscall/mkall.sh b/src/pkg/syscall/mkall.sh
index f031a38ed0..7d0c1ac2ab 100755
--- a/src/pkg/syscall/mkall.sh
+++ b/src/pkg/syscall/mkall.sh
@@ -78,6 +78,7 @@ GOOSARCH="${GOOS}_${GOARCH}"
 # defaults
 mksyscall="./mksyscall.pl"
 mkerrors="./mkerrors.sh"
+zerrors="zerrors_$GOOSARCH.go"
 run="sh"
 
 case "$1" in
@@ -150,6 +151,14 @@ windows_386)
 	mksysnum=
 	mktypes=
 	mkerrors="./mkerrors_windows.sh -f -m32"
+	zerrors="zerrors_windows.go"
+	;;
+windows_amd64)
+	mksyscall="./mksyscall_windows.pl"
+	mksysnum=
+	mktypes=
+	mkerrors="./mkerrors_windows.sh -f -m32"
+	zerrors="zerrors_windows.go"
 	;;
 plan9_386)
 	mkerrors=
@@ -164,7 +173,7 @@ plan9_386)
 esac
 
 (
-	if [ -n "$mkerrors" ]; then echo "$mkerrors |gofmt >zerrors_$GOOSARCH.go"; fi
+	if [ -n "$mkerrors" ]; then echo "$mkerrors |gofmt >$zerrors"; fi
 	syscall_goos="syscall_$GOOS.go"
 	case "$GOOS" in
 	darwin | freebsd)
diff --git a/src/pkg/syscall/syscall_windows.go b/src/pkg/syscall/syscall_windows.go
index 54dda0238e..5b8143aac9 100644
--- a/src/pkg/syscall/syscall_windows.go
+++ b/src/pkg/syscall/syscall_windows.go
@@ -100,6 +100,8 @@ func getSysProcAddr(m uintptr, pname string) uintptr {
 	return p
 }
 
+func Getpagesize() int { return 4096 }
+
 // Converts a Go function to a function pointer conforming
 // to the stdcall calling convention.  This is useful when
 // interoperating with Windows code requiring callbacks.
diff --git a/src/pkg/syscall/syscall_windows_386.go b/src/pkg/syscall/syscall_windows_386.go
index 1ce025b31a..61d2d8cb65 100644
--- a/src/pkg/syscall/syscall_windows_386.go
+++ b/src/pkg/syscall/syscall_windows_386.go
@@ -3,5 +3,3 @@
 // license that can be found in the LICENSE file.
 
 package syscall
-
-func Getpagesize() int { return 4096 }
diff --git a/src/pkg/syscall/syscall_windows_amd64.go b/src/pkg/syscall/syscall_windows_amd64.go
new file mode 100644
index 0000000000..61d2d8cb65
--- /dev/null
+++ b/src/pkg/syscall/syscall_windows_amd64.go
@@ -0,0 +1,5 @@
+// Copyright 2009 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package syscall
diff --git a/src/pkg/syscall/zerrors_windows.go b/src/pkg/syscall/zerrors_windows.go
new file mode 100644
index 0000000000..ae4506fac0
--- /dev/null
+++ b/src/pkg/syscall/zerrors_windows.go
@@ -0,0 +1,283 @@
+// mkerrors_windows.sh -f -m32
+// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
+
+package syscall
+
+// Go names for Windows errors.
+const (
+	ENOENT  = ERROR_FILE_NOT_FOUND
+	ENOTDIR = ERROR_DIRECTORY
+)
+
+// Windows reserves errors >= 1<<29 for application use.
+const APPLICATION_ERROR = 1 << 29
+
+// Invented values to support what package os and others expects.
+const (
+	E2BIG = APPLICATION_ERROR + iota
+	EACCES
+	EADDRINUSE
+	EADDRNOTAVAIL
+	EADV
+	EAFNOSUPPORT
+	EAGAIN
+	EALREADY
+	EBADE
+	EBADF
+	EBADFD
+	EBADMSG
+	EBADR
+	EBADRQC
+	EBADSLT
+	EBFONT
+	EBUSY
+	ECANCELED
+	ECHILD
+	ECHRNG
+	ECOMM
+	ECONNABORTED
+	ECONNREFUSED
+	ECONNRESET
+	EDEADLK
+	EDEADLOCK
+	EDESTADDRREQ
+	EDOM
+	EDOTDOT
+	EDQUOT
+	EEXIST
+	EFAULT
+	EFBIG
+	EHOSTDOWN
+	EHOSTUNREACH
+	EIDRM
+	EILSEQ
+	EINPROGRESS
+	EINTR
+	EINVAL
+	EIO
+	EISCONN
+	EISDIR
+	EISNAM
+	EKEYEXPIRED
+	EKEYREJECTED
+	EKEYREVOKED
+	EL2HLT
+	EL2NSYNC
+	EL3HLT
+	EL3RST
+	ELIBACC
+	ELIBBAD
+	ELIBEXEC
+	ELIBMAX
+	ELIBSCN
+	ELNRNG
+	ELOOP
+	EMEDIUMTYPE
+	EMFILE
+	EMLINK
+	EMSGSIZE
+	EMULTIHOP
+	ENAMETOOLONG
+	ENAVAIL
+	ENETDOWN
+	ENETRESET
+	ENETUNREACH
+	ENFILE
+	ENOANO
+	ENOBUFS
+	ENOCSI
+	ENODATA
+	ENODEV
+	ENOEXEC
+	ENOKEY
+	ENOLCK
+	ENOLINK
+	ENOMEDIUM
+	ENOMEM
+	ENOMSG
+	ENONET
+	ENOPKG
+	ENOPROTOOPT
+	ENOSPC
+	ENOSR
+	ENOSTR
+	ENOSYS
+	ENOTBLK
+	ENOTCONN
+	ENOTEMPTY
+	ENOTNAM
+	ENOTRECOVERABLE
+	ENOTSOCK
+	ENOTSUP
+	ENOTTY
+	ENOTUNIQ
+	ENXIO
+	EOPNOTSUPP
+	EOVERFLOW
+	EOWNERDEAD
+	EPERM
+	EPFNOSUPPORT
+	EPIPE
+	EPROTO
+	EPROTONOSUPPORT
+	EPROTOTYPE
+	ERANGE
+	EREMCHG
+	EREMOTE
+	EREMOTEIO
+	ERESTART
+	EROFS
+	ESHUTDOWN
+	ESOCKTNOSUPPORT
+	ESPIPE
+	ESRCH
+	ESRMNT
+	ESTALE
+	ESTRPIPE
+	ETIME
+	ETIMEDOUT
+	ETOOMANYREFS
+	ETXTBSY
+	EUCLEAN
+	EUNATCH
+	EUSERS
+	EWOULDBLOCK
+	EXDEV
+	EXFULL
+	EWINDOWS
+)
+
+// Error strings for invented errors
+var errors = [...]string{
+	E2BIG - APPLICATION_ERROR:           "argument list too long",
+	EACCES - APPLICATION_ERROR:          "permission denied",
+	EADDRINUSE - APPLICATION_ERROR:      "address already in use",
+	EADDRNOTAVAIL - APPLICATION_ERROR:   "cannot assign requested address",
+	EADV - APPLICATION_ERROR:            "advertise error",
+	EAFNOSUPPORT - APPLICATION_ERROR:    "address family not supported by protocol",
+	EAGAIN - APPLICATION_ERROR:          "resource temporarily unavailable",
+	EALREADY - APPLICATION_ERROR:        "operation already in progress",
+	EBADE - APPLICATION_ERROR:           "invalid exchange",
+	EBADF - APPLICATION_ERROR:           "bad file descriptor",
+	EBADFD - APPLICATION_ERROR:          "file descriptor in bad state",
+	EBADMSG - APPLICATION_ERROR:         "bad message",
+	EBADR - APPLICATION_ERROR:           "invalid request descriptor",
+	EBADRQC - APPLICATION_ERROR:         "invalid request code",
+	EBADSLT - APPLICATION_ERROR:         "invalid slot",
+	EBFONT - APPLICATION_ERROR:          "bad font file format",
+	EBUSY - APPLICATION_ERROR:           "device or resource busy",
+	ECANCELED - APPLICATION_ERROR:       "operation canceled",
+	ECHILD - APPLICATION_ERROR:          "no child processes",
+	ECHRNG - APPLICATION_ERROR:          "channel number out of range",
+	ECOMM - APPLICATION_ERROR:           "communication error on send",
+	ECONNABORTED - APPLICATION_ERROR:    "software caused connection abort",
+	ECONNREFUSED - APPLICATION_ERROR:    "connection refused",
+	ECONNRESET - APPLICATION_ERROR:      "connection reset by peer",
+	EDEADLK - APPLICATION_ERROR:         "resource deadlock avoided",
+	EDEADLOCK - APPLICATION_ERROR:       "resource deadlock avoided",
+	EDESTADDRREQ - APPLICATION_ERROR:    "destination address required",
+	EDOM - APPLICATION_ERROR:            "numerical argument out of domain",
+	EDOTDOT - APPLICATION_ERROR:         "RFS specific error",
+	EDQUOT - APPLICATION_ERROR:          "disk quota exceeded",
+	EEXIST - APPLICATION_ERROR:          "file exists",
+	EFAULT - APPLICATION_ERROR:          "bad address",
+	EFBIG - APPLICATION_ERROR:           "file too large",
+	EHOSTDOWN - APPLICATION_ERROR:       "host is down",
+	EHOSTUNREACH - APPLICATION_ERROR:    "no route to host",
+	EIDRM - APPLICATION_ERROR:           "identifier removed",
+	EILSEQ - APPLICATION_ERROR:          "invalid or incomplete multibyte or wide character",
+	EINPROGRESS - APPLICATION_ERROR:     "operation now in progress",
+	EINTR - APPLICATION_ERROR:           "interrupted system call",
+	EINVAL - APPLICATION_ERROR:          "invalid argument",
+	EIO - APPLICATION_ERROR:             "input/output error",
+	EISCONN - APPLICATION_ERROR:         "transport endpoint is already connected",
+	EISDIR - APPLICATION_ERROR:          "is a directory",
+	EISNAM - APPLICATION_ERROR:          "is a named type file",
+	EKEYEXPIRED - APPLICATION_ERROR:     "key has expired",
+	EKEYREJECTED - APPLICATION_ERROR:    "key was rejected by service",
+	EKEYREVOKED - APPLICATION_ERROR:     "key has been revoked",
+	EL2HLT - APPLICATION_ERROR:          "level 2 halted",
+	EL2NSYNC - APPLICATION_ERROR:        "level 2 not synchronized",
+	EL3HLT - APPLICATION_ERROR:          "level 3 halted",
+	EL3RST - APPLICATION_ERROR:          "level 3 reset",
+	ELIBACC - APPLICATION_ERROR:         "can not access a needed shared library",
+	ELIBBAD - APPLICATION_ERROR:         "accessing a corrupted shared library",
+	ELIBEXEC - APPLICATION_ERROR:        "cannot exec a shared library directly",
+	ELIBMAX - APPLICATION_ERROR:         "attempting to link in too many shared libraries",
+	ELIBSCN - APPLICATION_ERROR:         ".lib section in a.out corrupted",
+	ELNRNG - APPLICATION_ERROR:          "link number out of range",
+	ELOOP - APPLICATION_ERROR:           "too many levels of symbolic links",
+	EMEDIUMTYPE - APPLICATION_ERROR:     "wrong medium type",
+	EMFILE - APPLICATION_ERROR:          "too many open files",
+	EMLINK - APPLICATION_ERROR:          "too many links",
+	EMSGSIZE - APPLICATION_ERROR:        "message too long",
+	EMULTIHOP - APPLICATION_ERROR:       "multihop attempted",
+	ENAMETOOLONG - APPLICATION_ERROR:    "file name too long",
+	ENAVAIL - APPLICATION_ERROR:         "no XENIX semaphores available",
+	ENETDOWN - APPLICATION_ERROR:        "network is down",
+	ENETRESET - APPLICATION_ERROR:       "network dropped connection on reset",
+	ENETUNREACH - APPLICATION_ERROR:     "network is unreachable",
+	ENFILE - APPLICATION_ERROR:          "too many open files in system",
+	ENOANO - APPLICATION_ERROR:          "no anode",
+	ENOBUFS - APPLICATION_ERROR:         "no buffer space available",
+	ENOCSI - APPLICATION_ERROR:          "no CSI structure available",
+	ENODATA - APPLICATION_ERROR:         "no data available",
+	ENODEV - APPLICATION_ERROR:          "no such device",
+	ENOEXEC - APPLICATION_ERROR:         "exec format error",
+	ENOKEY - APPLICATION_ERROR:          "required key not available",
+	ENOLCK - APPLICATION_ERROR:          "no locks available",
+	ENOLINK - APPLICATION_ERROR:         "link has been severed",
+	ENOMEDIUM - APPLICATION_ERROR:       "no medium found",
+	ENOMEM - APPLICATION_ERROR:          "cannot allocate memory",
+	ENOMSG - APPLICATION_ERROR:          "no message of desired type",
+	ENONET - APPLICATION_ERROR:          "machine is not on the network",
+	ENOPKG - APPLICATION_ERROR:          "package not installed",
+	ENOPROTOOPT - APPLICATION_ERROR:     "protocol not available",
+	ENOSPC - APPLICATION_ERROR:          "no space left on device",
+	ENOSR - APPLICATION_ERROR:           "out of streams resources",
+	ENOSTR - APPLICATION_ERROR:          "device not a stream",
+	ENOSYS - APPLICATION_ERROR:          "function not implemented",
+	ENOTBLK - APPLICATION_ERROR:         "block device required",
+	ENOTCONN - APPLICATION_ERROR:        "transport endpoint is not connected",
+	ENOTEMPTY - APPLICATION_ERROR:       "directory not empty",
+	ENOTNAM - APPLICATION_ERROR:         "not a XENIX named type file",
+	ENOTRECOVERABLE - APPLICATION_ERROR: "state not recoverable",
+	ENOTSOCK - APPLICATION_ERROR:        "socket operation on non-socket",
+	ENOTSUP - APPLICATION_ERROR:         "operation not supported",
+	ENOTTY - APPLICATION_ERROR:          "inappropriate ioctl for device",
+	ENOTUNIQ - APPLICATION_ERROR:        "name not unique on network",
+	ENXIO - APPLICATION_ERROR:           "no such device or address",
+	EOPNOTSUPP - APPLICATION_ERROR:      "operation not supported",
+	EOVERFLOW - APPLICATION_ERROR:       "value too large for defined data type",
+	EOWNERDEAD - APPLICATION_ERROR:      "owner died",
+	EPERM - APPLICATION_ERROR:           "operation not permitted",
+	EPFNOSUPPORT - APPLICATION_ERROR:    "protocol family not supported",
+	EPIPE - APPLICATION_ERROR:           "broken pipe",
+	EPROTO - APPLICATION_ERROR:          "protocol error",
+	EPROTONOSUPPORT - APPLICATION_ERROR: "protocol not supported",
+	EPROTOTYPE - APPLICATION_ERROR:      "protocol wrong type for socket",
+	ERANGE - APPLICATION_ERROR:          "numerical result out of range",
+	EREMCHG - APPLICATION_ERROR:         "remote address changed",
+	EREMOTE - APPLICATION_ERROR:         "object is remote",
+	EREMOTEIO - APPLICATION_ERROR:       "remote I/O error",
+	ERESTART - APPLICATION_ERROR:        "interrupted system call should be restarted",
+	EROFS - APPLICATION_ERROR:           "read-only file system",
+	ESHUTDOWN - APPLICATION_ERROR:       "cannot send after transport endpoint shutdown",
+	ESOCKTNOSUPPORT - APPLICATION_ERROR: "socket type not supported",
+	ESPIPE - APPLICATION_ERROR:          "illegal seek",
+	ESRCH - APPLICATION_ERROR:           "no such process",
+	ESRMNT - APPLICATION_ERROR:          "srmount error",
+	ESTALE - APPLICATION_ERROR:          "stale NFS file handle",
+	ESTRPIPE - APPLICATION_ERROR:        "streams pipe error",
+	ETIME - APPLICATION_ERROR:           "timer expired",
+	ETIMEDOUT - APPLICATION_ERROR:       "connection timed out",
+	ETOOMANYREFS - APPLICATION_ERROR:    "too many references: cannot splice",
+	ETXTBSY - APPLICATION_ERROR:         "text file busy",
+	EUCLEAN - APPLICATION_ERROR:         "structure needs cleaning",
+	EUNATCH - APPLICATION_ERROR:         "protocol driver not attached",
+	EUSERS - APPLICATION_ERROR:          "too many users",
+	EWOULDBLOCK - APPLICATION_ERROR:     "resource temporarily unavailable",
+	EXDEV - APPLICATION_ERROR:           "invalid cross-device link",
+	EXFULL - APPLICATION_ERROR:          "exchange full",
+	EWINDOWS - APPLICATION_ERROR:        "not supported by windows",
+}
diff --git a/src/pkg/syscall/zerrors_windows_386.go b/src/pkg/syscall/zerrors_windows_386.go
index ae4506fac0..d1008bd03c 100644
--- a/src/pkg/syscall/zerrors_windows_386.go
+++ b/src/pkg/syscall/zerrors_windows_386.go
@@ -1,283 +1,5 @@
-// mkerrors_windows.sh -f -m32
-// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
+// Copyright 2011 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
 
 package syscall
-
-// Go names for Windows errors.
-const (
-	ENOENT  = ERROR_FILE_NOT_FOUND
-	ENOTDIR = ERROR_DIRECTORY
-)
-
-// Windows reserves errors >= 1<<29 for application use.
-const APPLICATION_ERROR = 1 << 29
-
-// Invented values to support what package os and others expects.
-const (
-	E2BIG = APPLICATION_ERROR + iota
-	EACCES
-	EADDRINUSE
-	EADDRNOTAVAIL
-	EADV
-	EAFNOSUPPORT
-	EAGAIN
-	EALREADY
-	EBADE
-	EBADF
-	EBADFD
-	EBADMSG
-	EBADR
-	EBADRQC
-	EBADSLT
-	EBFONT
-	EBUSY
-	ECANCELED
-	ECHILD
-	ECHRNG
-	ECOMM
-	ECONNABORTED
-	ECONNREFUSED
-	ECONNRESET
-	EDEADLK
-	EDEADLOCK
-	EDESTADDRREQ
-	EDOM
-	EDOTDOT
-	EDQUOT
-	EEXIST
-	EFAULT
-	EFBIG
-	EHOSTDOWN
-	EHOSTUNREACH
-	EIDRM
-	EILSEQ
-	EINPROGRESS
-	EINTR
-	EINVAL
-	EIO
-	EISCONN
-	EISDIR
-	EISNAM
-	EKEYEXPIRED
-	EKEYREJECTED
-	EKEYREVOKED
-	EL2HLT
-	EL2NSYNC
-	EL3HLT
-	EL3RST
-	ELIBACC
-	ELIBBAD
-	ELIBEXEC
-	ELIBMAX
-	ELIBSCN
-	ELNRNG
-	ELOOP
-	EMEDIUMTYPE
-	EMFILE
-	EMLINK
-	EMSGSIZE
-	EMULTIHOP
-	ENAMETOOLONG
-	ENAVAIL
-	ENETDOWN
-	ENETRESET
-	ENETUNREACH
-	ENFILE
-	ENOANO
-	ENOBUFS
-	ENOCSI
-	ENODATA
-	ENODEV
-	ENOEXEC
-	ENOKEY
-	ENOLCK
-	ENOLINK
-	ENOMEDIUM
-	ENOMEM
-	ENOMSG
-	ENONET
-	ENOPKG
-	ENOPROTOOPT
-	ENOSPC
-	ENOSR
-	ENOSTR
-	ENOSYS
-	ENOTBLK
-	ENOTCONN
-	ENOTEMPTY
-	ENOTNAM
-	ENOTRECOVERABLE
-	ENOTSOCK
-	ENOTSUP
-	ENOTTY
-	ENOTUNIQ
-	ENXIO
-	EOPNOTSUPP
-	EOVERFLOW
-	EOWNERDEAD
-	EPERM
-	EPFNOSUPPORT
-	EPIPE
-	EPROTO
-	EPROTONOSUPPORT
-	EPROTOTYPE
-	ERANGE
-	EREMCHG
-	EREMOTE
-	EREMOTEIO
-	ERESTART
-	EROFS
-	ESHUTDOWN
-	ESOCKTNOSUPPORT
-	ESPIPE
-	ESRCH
-	ESRMNT
-	ESTALE
-	ESTRPIPE
-	ETIME
-	ETIMEDOUT
-	ETOOMANYREFS
-	ETXTBSY
-	EUCLEAN
-	EUNATCH
-	EUSERS
-	EWOULDBLOCK
-	EXDEV
-	EXFULL
-	EWINDOWS
-)
-
-// Error strings for invented errors
-var errors = [...]string{
-	E2BIG - APPLICATION_ERROR:           "argument list too long",
-	EACCES - APPLICATION_ERROR:          "permission denied",
-	EADDRINUSE - APPLICATION_ERROR:      "address already in use",
-	EADDRNOTAVAIL - APPLICATION_ERROR:   "cannot assign requested address",
-	EADV - APPLICATION_ERROR:            "advertise error",
-	EAFNOSUPPORT - APPLICATION_ERROR:    "address family not supported by protocol",
-	EAGAIN - APPLICATION_ERROR:          "resource temporarily unavailable",
-	EALREADY - APPLICATION_ERROR:        "operation already in progress",
-	EBADE - APPLICATION_ERROR:           "invalid exchange",
-	EBADF - APPLICATION_ERROR:           "bad file descriptor",
-	EBADFD - APPLICATION_ERROR:          "file descriptor in bad state",
-	EBADMSG - APPLICATION_ERROR:         "bad message",
-	EBADR - APPLICATION_ERROR:           "invalid request descriptor",
-	EBADRQC - APPLICATION_ERROR:         "invalid request code",
-	EBADSLT - APPLICATION_ERROR:         "invalid slot",
-	EBFONT - APPLICATION_ERROR:          "bad font file format",
-	EBUSY - APPLICATION_ERROR:           "device or resource busy",
-	ECANCELED - APPLICATION_ERROR:       "operation canceled",
-	ECHILD - APPLICATION_ERROR:          "no child processes",
-	ECHRNG - APPLICATION_ERROR:          "channel number out of range",
-	ECOMM - APPLICATION_ERROR:           "communication error on send",
-	ECONNABORTED - APPLICATION_ERROR:    "software caused connection abort",
-	ECONNREFUSED - APPLICATION_ERROR:    "connection refused",
-	ECONNRESET - APPLICATION_ERROR:      "connection reset by peer",
-	EDEADLK - APPLICATION_ERROR:         "resource deadlock avoided",
-	EDEADLOCK - APPLICATION_ERROR:       "resource deadlock avoided",
-	EDESTADDRREQ - APPLICATION_ERROR:    "destination address required",
-	EDOM - APPLICATION_ERROR:            "numerical argument out of domain",
-	EDOTDOT - APPLICATION_ERROR:         "RFS specific error",
-	EDQUOT - APPLICATION_ERROR:          "disk quota exceeded",
-	EEXIST - APPLICATION_ERROR:          "file exists",
-	EFAULT - APPLICATION_ERROR:          "bad address",
-	EFBIG - APPLICATION_ERROR:           "file too large",
-	EHOSTDOWN - APPLICATION_ERROR:       "host is down",
-	EHOSTUNREACH - APPLICATION_ERROR:    "no route to host",
-	EIDRM - APPLICATION_ERROR:           "identifier removed",
-	EILSEQ - APPLICATION_ERROR:          "invalid or incomplete multibyte or wide character",
-	EINPROGRESS - APPLICATION_ERROR:     "operation now in progress",
-	EINTR - APPLICATION_ERROR:           "interrupted system call",
-	EINVAL - APPLICATION_ERROR:          "invalid argument",
-	EIO - APPLICATION_ERROR:             "input/output error",
-	EISCONN - APPLICATION_ERROR:         "transport endpoint is already connected",
-	EISDIR - APPLICATION_ERROR:          "is a directory",
-	EISNAM - APPLICATION_ERROR:          "is a named type file",
-	EKEYEXPIRED - APPLICATION_ERROR:     "key has expired",
-	EKEYREJECTED - APPLICATION_ERROR:    "key was rejected by service",
-	EKEYREVOKED - APPLICATION_ERROR:     "key has been revoked",
-	EL2HLT - APPLICATION_ERROR:          "level 2 halted",
-	EL2NSYNC - APPLICATION_ERROR:        "level 2 not synchronized",
-	EL3HLT - APPLICATION_ERROR:          "level 3 halted",
-	EL3RST - APPLICATION_ERROR:          "level 3 reset",
-	ELIBACC - APPLICATION_ERROR:         "can not access a needed shared library",
-	ELIBBAD - APPLICATION_ERROR:         "accessing a corrupted shared library",
-	ELIBEXEC - APPLICATION_ERROR:        "cannot exec a shared library directly",
-	ELIBMAX - APPLICATION_ERROR:         "attempting to link in too many shared libraries",
-	ELIBSCN - APPLICATION_ERROR:         ".lib section in a.out corrupted",
-	ELNRNG - APPLICATION_ERROR:          "link number out of range",
-	ELOOP - APPLICATION_ERROR:           "too many levels of symbolic links",
-	EMEDIUMTYPE - APPLICATION_ERROR:     "wrong medium type",
-	EMFILE - APPLICATION_ERROR:          "too many open files",
-	EMLINK - APPLICATION_ERROR:          "too many links",
-	EMSGSIZE - APPLICATION_ERROR:        "message too long",
-	EMULTIHOP - APPLICATION_ERROR:       "multihop attempted",
-	ENAMETOOLONG - APPLICATION_ERROR:    "file name too long",
-	ENAVAIL - APPLICATION_ERROR:         "no XENIX semaphores available",
-	ENETDOWN - APPLICATION_ERROR:        "network is down",
-	ENETRESET - APPLICATION_ERROR:       "network dropped connection on reset",
-	ENETUNREACH - APPLICATION_ERROR:     "network is unreachable",
-	ENFILE - APPLICATION_ERROR:          "too many open files in system",
-	ENOANO - APPLICATION_ERROR:          "no anode",
-	ENOBUFS - APPLICATION_ERROR:         "no buffer space available",
-	ENOCSI - APPLICATION_ERROR:          "no CSI structure available",
-	ENODATA - APPLICATION_ERROR:         "no data available",
-	ENODEV - APPLICATION_ERROR:          "no such device",
-	ENOEXEC - APPLICATION_ERROR:         "exec format error",
-	ENOKEY - APPLICATION_ERROR:          "required key not available",
-	ENOLCK - APPLICATION_ERROR:          "no locks available",
-	ENOLINK - APPLICATION_ERROR:         "link has been severed",
-	ENOMEDIUM - APPLICATION_ERROR:       "no medium found",
-	ENOMEM - APPLICATION_ERROR:          "cannot allocate memory",
-	ENOMSG - APPLICATION_ERROR:          "no message of desired type",
-	ENONET - APPLICATION_ERROR:          "machine is not on the network",
-	ENOPKG - APPLICATION_ERROR:          "package not installed",
-	ENOPROTOOPT - APPLICATION_ERROR:     "protocol not available",
-	ENOSPC - APPLICATION_ERROR:          "no space left on device",
-	ENOSR - APPLICATION_ERROR:           "out of streams resources",
-	ENOSTR - APPLICATION_ERROR:          "device not a stream",
-	ENOSYS - APPLICATION_ERROR:          "function not implemented",
-	ENOTBLK - APPLICATION_ERROR:         "block device required",
-	ENOTCONN - APPLICATION_ERROR:        "transport endpoint is not connected",
-	ENOTEMPTY - APPLICATION_ERROR:       "directory not empty",
-	ENOTNAM - APPLICATION_ERROR:         "not a XENIX named type file",
-	ENOTRECOVERABLE - APPLICATION_ERROR: "state not recoverable",
-	ENOTSOCK - APPLICATION_ERROR:        "socket operation on non-socket",
-	ENOTSUP - APPLICATION_ERROR:         "operation not supported",
-	ENOTTY - APPLICATION_ERROR:          "inappropriate ioctl for device",
-	ENOTUNIQ - APPLICATION_ERROR:        "name not unique on network",
-	ENXIO - APPLICATION_ERROR:           "no such device or address",
-	EOPNOTSUPP - APPLICATION_ERROR:      "operation not supported",
-	EOVERFLOW - APPLICATION_ERROR:       "value too large for defined data type",
-	EOWNERDEAD - APPLICATION_ERROR:      "owner died",
-	EPERM - APPLICATION_ERROR:           "operation not permitted",
-	EPFNOSUPPORT - APPLICATION_ERROR:    "protocol family not supported",
-	EPIPE - APPLICATION_ERROR:           "broken pipe",
-	EPROTO - APPLICATION_ERROR:          "protocol error",
-	EPROTONOSUPPORT - APPLICATION_ERROR: "protocol not supported",
-	EPROTOTYPE - APPLICATION_ERROR:      "protocol wrong type for socket",
-	ERANGE - APPLICATION_ERROR:          "numerical result out of range",
-	EREMCHG - APPLICATION_ERROR:         "remote address changed",
-	EREMOTE - APPLICATION_ERROR:         "object is remote",
-	EREMOTEIO - APPLICATION_ERROR:       "remote I/O error",
-	ERESTART - APPLICATION_ERROR:        "interrupted system call should be restarted",
-	EROFS - APPLICATION_ERROR:           "read-only file system",
-	ESHUTDOWN - APPLICATION_ERROR:       "cannot send after transport endpoint shutdown",
-	ESOCKTNOSUPPORT - APPLICATION_ERROR: "socket type not supported",
-	ESPIPE - APPLICATION_ERROR:          "illegal seek",
-	ESRCH - APPLICATION_ERROR:           "no such process",
-	ESRMNT - APPLICATION_ERROR:          "srmount error",
-	ESTALE - APPLICATION_ERROR:          "stale NFS file handle",
-	ESTRPIPE - APPLICATION_ERROR:        "streams pipe error",
-	ETIME - APPLICATION_ERROR:           "timer expired",
-	ETIMEDOUT - APPLICATION_ERROR:       "connection timed out",
-	ETOOMANYREFS - APPLICATION_ERROR:    "too many references: cannot splice",
-	ETXTBSY - APPLICATION_ERROR:         "text file busy",
-	EUCLEAN - APPLICATION_ERROR:         "structure needs cleaning",
-	EUNATCH - APPLICATION_ERROR:         "protocol driver not attached",
-	EUSERS - APPLICATION_ERROR:          "too many users",
-	EWOULDBLOCK - APPLICATION_ERROR:     "resource temporarily unavailable",
-	EXDEV - APPLICATION_ERROR:           "invalid cross-device link",
-	EXFULL - APPLICATION_ERROR:          "exchange full",
-	EWINDOWS - APPLICATION_ERROR:        "not supported by windows",
-}
diff --git a/src/pkg/syscall/zerrors_windows_amd64.go b/src/pkg/syscall/zerrors_windows_amd64.go
new file mode 100644
index 0000000000..d1008bd03c
--- /dev/null
+++ b/src/pkg/syscall/zerrors_windows_amd64.go
@@ -0,0 +1,5 @@
+// Copyright 2011 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package syscall
diff --git a/src/pkg/syscall/zsyscall_windows_386.go b/src/pkg/syscall/zsyscall_windows_386.go
index 8bf8db81a8..350ad232ad 100644
--- a/src/pkg/syscall/zsyscall_windows_386.go
+++ b/src/pkg/syscall/zsyscall_windows_386.go
@@ -1,4 +1,4 @@
-// mksyscall_windows.pl 
+// mksyscall_windows.pl -l32 syscall_windows.go syscall_windows_386.go
 // MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
 
 package syscall
diff --git a/src/pkg/syscall/zsyscall_windows_amd64.go b/src/pkg/syscall/zsyscall_windows_amd64.go
new file mode 100644
index 0000000000..e7d09fbc2d
--- /dev/null
+++ b/src/pkg/syscall/zsyscall_windows_amd64.go
@@ -0,0 +1,1323 @@
+// mksyscall_windows.pl syscall_windows.go syscall_windows_amd64.go
+// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
+
+package syscall
+
+import "unsafe"
+
+var (
+	modkernel32 = loadDll("kernel32.dll")
+	modadvapi32 = loadDll("advapi32.dll")
+	modshell32  = loadDll("shell32.dll")
+	modwsock32  = loadDll("wsock32.dll")
+	modws2_32   = loadDll("ws2_32.dll")
+	moddnsapi   = loadDll("dnsapi.dll")
+	modiphlpapi = loadDll("iphlpapi.dll")
+
+	procGetLastError               = getSysProcAddr(modkernel32, "GetLastError")
+	procLoadLibraryW               = getSysProcAddr(modkernel32, "LoadLibraryW")
+	procFreeLibrary                = getSysProcAddr(modkernel32, "FreeLibrary")
+	procGetProcAddress             = getSysProcAddr(modkernel32, "GetProcAddress")
+	procGetVersion                 = getSysProcAddr(modkernel32, "GetVersion")
+	procFormatMessageW             = getSysProcAddr(modkernel32, "FormatMessageW")
+	procExitProcess                = getSysProcAddr(modkernel32, "ExitProcess")
+	procCreateFileW                = getSysProcAddr(modkernel32, "CreateFileW")
+	procReadFile                   = getSysProcAddr(modkernel32, "ReadFile")
+	procWriteFile                  = getSysProcAddr(modkernel32, "WriteFile")
+	procSetFilePointer             = getSysProcAddr(modkernel32, "SetFilePointer")
+	procCloseHandle                = getSysProcAddr(modkernel32, "CloseHandle")
+	procGetStdHandle               = getSysProcAddr(modkernel32, "GetStdHandle")
+	procFindFirstFileW             = getSysProcAddr(modkernel32, "FindFirstFileW")
+	procFindNextFileW              = getSysProcAddr(modkernel32, "FindNextFileW")
+	procFindClose                  = getSysProcAddr(modkernel32, "FindClose")
+	procGetFileInformationByHandle = getSysProcAddr(modkernel32, "GetFileInformationByHandle")
+	procGetCurrentDirectoryW       = getSysProcAddr(modkernel32, "GetCurrentDirectoryW")
+	procSetCurrentDirectoryW       = getSysProcAddr(modkernel32, "SetCurrentDirectoryW")
+	procCreateDirectoryW           = getSysProcAddr(modkernel32, "CreateDirectoryW")
+	procRemoveDirectoryW           = getSysProcAddr(modkernel32, "RemoveDirectoryW")
+	procDeleteFileW                = getSysProcAddr(modkernel32, "DeleteFileW")
+	procMoveFileW                  = getSysProcAddr(modkernel32, "MoveFileW")
+	procGetComputerNameW           = getSysProcAddr(modkernel32, "GetComputerNameW")
+	procSetEndOfFile               = getSysProcAddr(modkernel32, "SetEndOfFile")
+	procGetSystemTimeAsFileTime    = getSysProcAddr(modkernel32, "GetSystemTimeAsFileTime")
+	procSleep                      = getSysProcAddr(modkernel32, "Sleep")
+	procGetTimeZoneInformation     = getSysProcAddr(modkernel32, "GetTimeZoneInformation")
+	procCreateIoCompletionPort     = getSysProcAddr(modkernel32, "CreateIoCompletionPort")
+	procGetQueuedCompletionStatus  = getSysProcAddr(modkernel32, "GetQueuedCompletionStatus")
+	procCancelIo                   = getSysProcAddr(modkernel32, "CancelIo")
+	procCreateProcessW             = getSysProcAddr(modkernel32, "CreateProcessW")
+	procOpenProcess                = getSysProcAddr(modkernel32, "OpenProcess")
+	procTerminateProcess           = getSysProcAddr(modkernel32, "TerminateProcess")
+	procGetExitCodeProcess         = getSysProcAddr(modkernel32, "GetExitCodeProcess")
+	procGetStartupInfoW            = getSysProcAddr(modkernel32, "GetStartupInfoW")
+	procGetCurrentProcess          = getSysProcAddr(modkernel32, "GetCurrentProcess")
+	procDuplicateHandle            = getSysProcAddr(modkernel32, "DuplicateHandle")
+	procWaitForSingleObject        = getSysProcAddr(modkernel32, "WaitForSingleObject")
+	procGetTempPathW               = getSysProcAddr(modkernel32, "GetTempPathW")
+	procCreatePipe                 = getSysProcAddr(modkernel32, "CreatePipe")
+	procGetFileType                = getSysProcAddr(modkernel32, "GetFileType")
+	procCryptAcquireContextW       = getSysProcAddr(modadvapi32, "CryptAcquireContextW")
+	procCryptReleaseContext        = getSysProcAddr(modadvapi32, "CryptReleaseContext")
+	procCryptGenRandom             = getSysProcAddr(modadvapi32, "CryptGenRandom")
+	procGetEnvironmentStringsW     = getSysProcAddr(modkernel32, "GetEnvironmentStringsW")
+	procFreeEnvironmentStringsW    = getSysProcAddr(modkernel32, "FreeEnvironmentStringsW")
+	procGetEnvironmentVariableW    = getSysProcAddr(modkernel32, "GetEnvironmentVariableW")
+	procSetEnvironmentVariableW    = getSysProcAddr(modkernel32, "SetEnvironmentVariableW")
+	procSetFileTime                = getSysProcAddr(modkernel32, "SetFileTime")
+	procGetFileAttributesW         = getSysProcAddr(modkernel32, "GetFileAttributesW")
+	procSetFileAttributesW         = getSysProcAddr(modkernel32, "SetFileAttributesW")
+	procGetCommandLineW            = getSysProcAddr(modkernel32, "GetCommandLineW")
+	procCommandLineToArgvW         = getSysProcAddr(modshell32, "CommandLineToArgvW")
+	procLocalFree                  = getSysProcAddr(modkernel32, "LocalFree")
+	procSetHandleInformation       = getSysProcAddr(modkernel32, "SetHandleInformation")
+	procFlushFileBuffers           = getSysProcAddr(modkernel32, "FlushFileBuffers")
+	procGetFullPathNameW           = getSysProcAddr(modkernel32, "GetFullPathNameW")
+	procCreateFileMappingW         = getSysProcAddr(modkernel32, "CreateFileMappingW")
+	procMapViewOfFile              = getSysProcAddr(modkernel32, "MapViewOfFile")
+	procUnmapViewOfFile            = getSysProcAddr(modkernel32, "UnmapViewOfFile")
+	procFlushViewOfFile            = getSysProcAddr(modkernel32, "FlushViewOfFile")
+	procVirtualLock                = getSysProcAddr(modkernel32, "VirtualLock")
+	procVirtualUnlock              = getSysProcAddr(modkernel32, "VirtualUnlock")
+	procTransmitFile               = getSysProcAddr(modwsock32, "TransmitFile")
+	procWSAStartup                 = getSysProcAddr(modwsock32, "WSAStartup")
+	procWSACleanup                 = getSysProcAddr(modwsock32, "WSACleanup")
+	procWSAIoctl                   = getSysProcAddr(modws2_32, "WSAIoctl")
+	procsocket                     = getSysProcAddr(modwsock32, "socket")
+	procsetsockopt                 = getSysProcAddr(modwsock32, "setsockopt")
+	procbind                       = getSysProcAddr(modwsock32, "bind")
+	procconnect                    = getSysProcAddr(modwsock32, "connect")
+	procgetsockname                = getSysProcAddr(modwsock32, "getsockname")
+	procgetpeername                = getSysProcAddr(modwsock32, "getpeername")
+	proclisten                     = getSysProcAddr(modwsock32, "listen")
+	procshutdown                   = getSysProcAddr(modwsock32, "shutdown")
+	procclosesocket                = getSysProcAddr(modwsock32, "closesocket")
+	procAcceptEx                   = getSysProcAddr(modwsock32, "AcceptEx")
+	procGetAcceptExSockaddrs       = getSysProcAddr(modwsock32, "GetAcceptExSockaddrs")
+	procWSARecv                    = getSysProcAddr(modws2_32, "WSARecv")
+	procWSASend                    = getSysProcAddr(modws2_32, "WSASend")
+	procWSARecvFrom                = getSysProcAddr(modws2_32, "WSARecvFrom")
+	procWSASendTo                  = getSysProcAddr(modws2_32, "WSASendTo")
+	procgethostbyname              = getSysProcAddr(modws2_32, "gethostbyname")
+	procgetservbyname              = getSysProcAddr(modws2_32, "getservbyname")
+	procntohs                      = getSysProcAddr(modws2_32, "ntohs")
+	procDnsQuery_W                 = getSysProcAddr(moddnsapi, "DnsQuery_W")
+	procDnsRecordListFree          = getSysProcAddr(moddnsapi, "DnsRecordListFree")
+	procGetIfEntry                 = getSysProcAddr(modiphlpapi, "GetIfEntry")
+	procGetAdaptersInfo            = getSysProcAddr(modiphlpapi, "GetAdaptersInfo")
+)
+
+func GetLastError() (lasterrno int) {
+	r0, _, _ := Syscall(procGetLastError, 0, 0, 0, 0)
+	lasterrno = int(r0)
+	return
+}
+
+func LoadLibrary(libname string) (handle Handle, errno int) {
+	r0, _, e1 := Syscall(procLoadLibraryW, 1, uintptr(unsafe.Pointer(StringToUTF16Ptr(libname))), 0, 0)
+	handle = Handle(r0)
+	if handle == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func FreeLibrary(handle Handle) (errno int) {
+	r1, _, e1 := Syscall(procFreeLibrary, 1, uintptr(handle), 0, 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetProcAddress(module Handle, procname string) (proc Handle, errno int) {
+	r0, _, e1 := Syscall(procGetProcAddress, 2, uintptr(module), uintptr(unsafe.Pointer(StringBytePtr(procname))), 0)
+	proc = Handle(r0)
+	if proc == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetVersion() (ver uint32, errno int) {
+	r0, _, e1 := Syscall(procGetVersion, 0, 0, 0, 0)
+	ver = uint32(r0)
+	if ver == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func FormatMessage(flags uint32, msgsrc uint32, msgid uint32, langid uint32, buf []uint16, args *byte) (n uint32, errno int) {
+	var _p0 *uint16
+	if len(buf) > 0 {
+		_p0 = &buf[0]
+	}
+	r0, _, e1 := Syscall9(procFormatMessageW, 7, uintptr(flags), uintptr(msgsrc), uintptr(msgid), uintptr(langid), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(args)), 0, 0)
+	n = uint32(r0)
+	if n == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func ExitProcess(exitcode uint32) {
+	Syscall(procExitProcess, 1, uintptr(exitcode), 0, 0)
+	return
+}
+
+func CreateFile(name *uint16, access uint32, mode uint32, sa *SecurityAttributes, createmode uint32, attrs uint32, templatefile int32) (handle Handle, errno int) {
+	r0, _, e1 := Syscall9(procCreateFileW, 7, uintptr(unsafe.Pointer(name)), uintptr(access), uintptr(mode), uintptr(unsafe.Pointer(sa)), uintptr(createmode), uintptr(attrs), uintptr(templatefile), 0, 0)
+	handle = Handle(r0)
+	if handle == InvalidHandle {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func ReadFile(handle Handle, buf []byte, done *uint32, overlapped *Overlapped) (errno int) {
+	var _p0 *byte
+	if len(buf) > 0 {
+		_p0 = &buf[0]
+	}
+	r1, _, e1 := Syscall6(procReadFile, 5, uintptr(handle), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(done)), uintptr(unsafe.Pointer(overlapped)), 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func WriteFile(handle Handle, buf []byte, done *uint32, overlapped *Overlapped) (errno int) {
+	var _p0 *byte
+	if len(buf) > 0 {
+		_p0 = &buf[0]
+	}
+	r1, _, e1 := Syscall6(procWriteFile, 5, uintptr(handle), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(done)), uintptr(unsafe.Pointer(overlapped)), 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func SetFilePointer(handle Handle, lowoffset int32, highoffsetptr *int32, whence uint32) (newlowoffset uint32, errno int) {
+	r0, _, e1 := Syscall6(procSetFilePointer, 4, uintptr(handle), uintptr(lowoffset), uintptr(unsafe.Pointer(highoffsetptr)), uintptr(whence), 0, 0)
+	newlowoffset = uint32(r0)
+	if newlowoffset == 0xffffffff {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func CloseHandle(handle Handle) (errno int) {
+	r1, _, e1 := Syscall(procCloseHandle, 1, uintptr(handle), 0, 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetStdHandle(stdhandle int) (handle Handle, errno int) {
+	r0, _, e1 := Syscall(procGetStdHandle, 1, uintptr(stdhandle), 0, 0)
+	handle = Handle(r0)
+	if handle == InvalidHandle {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func FindFirstFile(name *uint16, data *Win32finddata) (handle Handle, errno int) {
+	r0, _, e1 := Syscall(procFindFirstFileW, 2, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(data)), 0)
+	handle = Handle(r0)
+	if handle == InvalidHandle {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func FindNextFile(handle Handle, data *Win32finddata) (errno int) {
+	r1, _, e1 := Syscall(procFindNextFileW, 2, uintptr(handle), uintptr(unsafe.Pointer(data)), 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func FindClose(handle Handle) (errno int) {
+	r1, _, e1 := Syscall(procFindClose, 1, uintptr(handle), 0, 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetFileInformationByHandle(handle Handle, data *ByHandleFileInformation) (errno int) {
+	r1, _, e1 := Syscall(procGetFileInformationByHandle, 2, uintptr(handle), uintptr(unsafe.Pointer(data)), 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetCurrentDirectory(buflen uint32, buf *uint16) (n uint32, errno int) {
+	r0, _, e1 := Syscall(procGetCurrentDirectoryW, 2, uintptr(buflen), uintptr(unsafe.Pointer(buf)), 0)
+	n = uint32(r0)
+	if n == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func SetCurrentDirectory(path *uint16) (errno int) {
+	r1, _, e1 := Syscall(procSetCurrentDirectoryW, 1, uintptr(unsafe.Pointer(path)), 0, 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func CreateDirectory(path *uint16, sa *SecurityAttributes) (errno int) {
+	r1, _, e1 := Syscall(procCreateDirectoryW, 2, uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(sa)), 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func RemoveDirectory(path *uint16) (errno int) {
+	r1, _, e1 := Syscall(procRemoveDirectoryW, 1, uintptr(unsafe.Pointer(path)), 0, 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func DeleteFile(path *uint16) (errno int) {
+	r1, _, e1 := Syscall(procDeleteFileW, 1, uintptr(unsafe.Pointer(path)), 0, 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func MoveFile(from *uint16, to *uint16) (errno int) {
+	r1, _, e1 := Syscall(procMoveFileW, 2, uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(to)), 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetComputerName(buf *uint16, n *uint32) (errno int) {
+	r1, _, e1 := Syscall(procGetComputerNameW, 2, uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(n)), 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func SetEndOfFile(handle Handle) (errno int) {
+	r1, _, e1 := Syscall(procSetEndOfFile, 1, uintptr(handle), 0, 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetSystemTimeAsFileTime(time *Filetime) {
+	Syscall(procGetSystemTimeAsFileTime, 1, uintptr(unsafe.Pointer(time)), 0, 0)
+	return
+}
+
+func sleep(msec uint32) {
+	Syscall(procSleep, 1, uintptr(msec), 0, 0)
+	return
+}
+
+func GetTimeZoneInformation(tzi *Timezoneinformation) (rc uint32, errno int) {
+	r0, _, e1 := Syscall(procGetTimeZoneInformation, 1, uintptr(unsafe.Pointer(tzi)), 0, 0)
+	rc = uint32(r0)
+	if rc == 0xffffffff {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func CreateIoCompletionPort(filehandle Handle, cphandle Handle, key uint32, threadcnt uint32) (handle Handle, errno int) {
+	r0, _, e1 := Syscall6(procCreateIoCompletionPort, 4, uintptr(filehandle), uintptr(cphandle), uintptr(key), uintptr(threadcnt), 0, 0)
+	handle = Handle(r0)
+	if handle == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetQueuedCompletionStatus(cphandle Handle, qty *uint32, key *uint32, overlapped **Overlapped, timeout uint32) (errno int) {
+	r1, _, e1 := Syscall6(procGetQueuedCompletionStatus, 5, uintptr(cphandle), uintptr(unsafe.Pointer(qty)), uintptr(unsafe.Pointer(key)), uintptr(unsafe.Pointer(overlapped)), uintptr(timeout), 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func CancelIo(s Handle) (errno int) {
+	r1, _, e1 := Syscall(procCancelIo, 1, uintptr(s), 0, 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func CreateProcess(appName *uint16, commandLine *uint16, procSecurity *SecurityAttributes, threadSecurity *SecurityAttributes, inheritHandles bool, creationFlags uint32, env *uint16, currentDir *uint16, startupInfo *StartupInfo, outProcInfo *ProcessInformation) (errno int) {
+	var _p0 uint32
+	if inheritHandles {
+		_p0 = 1
+	} else {
+		_p0 = 0
+	}
+	r1, _, e1 := Syscall12(procCreateProcessW, 10, uintptr(unsafe.Pointer(appName)), uintptr(unsafe.Pointer(commandLine)), uintptr(unsafe.Pointer(procSecurity)), uintptr(unsafe.Pointer(threadSecurity)), uintptr(_p0), uintptr(creationFlags), uintptr(unsafe.Pointer(env)), uintptr(unsafe.Pointer(currentDir)), uintptr(unsafe.Pointer(startupInfo)), uintptr(unsafe.Pointer(outProcInfo)), 0, 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func OpenProcess(da uint32, inheritHandle bool, pid uint32) (handle Handle, errno int) {
+	var _p0 uint32
+	if inheritHandle {
+		_p0 = 1
+	} else {
+		_p0 = 0
+	}
+	r0, _, e1 := Syscall(procOpenProcess, 3, uintptr(da), uintptr(_p0), uintptr(pid))
+	handle = Handle(r0)
+	if handle == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func TerminateProcess(handle Handle, exitcode uint32) (errno int) {
+	r1, _, e1 := Syscall(procTerminateProcess, 2, uintptr(handle), uintptr(exitcode), 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetExitCodeProcess(handle Handle, exitcode *uint32) (errno int) {
+	r1, _, e1 := Syscall(procGetExitCodeProcess, 2, uintptr(handle), uintptr(unsafe.Pointer(exitcode)), 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetStartupInfo(startupInfo *StartupInfo) (errno int) {
+	r1, _, e1 := Syscall(procGetStartupInfoW, 1, uintptr(unsafe.Pointer(startupInfo)), 0, 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetCurrentProcess() (pseudoHandle Handle, errno int) {
+	r0, _, e1 := Syscall(procGetCurrentProcess, 0, 0, 0, 0)
+	pseudoHandle = Handle(r0)
+	if pseudoHandle == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func DuplicateHandle(hSourceProcessHandle Handle, hSourceHandle Handle, hTargetProcessHandle Handle, lpTargetHandle *Handle, dwDesiredAccess uint32, bInheritHandle bool, dwOptions uint32) (errno int) {
+	var _p0 uint32
+	if bInheritHandle {
+		_p0 = 1
+	} else {
+		_p0 = 0
+	}
+	r1, _, e1 := Syscall9(procDuplicateHandle, 7, uintptr(hSourceProcessHandle), uintptr(hSourceHandle), uintptr(hTargetProcessHandle), uintptr(unsafe.Pointer(lpTargetHandle)), uintptr(dwDesiredAccess), uintptr(_p0), uintptr(dwOptions), 0, 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func WaitForSingleObject(handle Handle, waitMilliseconds uint32) (event uint32, errno int) {
+	r0, _, e1 := Syscall(procWaitForSingleObject, 2, uintptr(handle), uintptr(waitMilliseconds), 0)
+	event = uint32(r0)
+	if event == 0xffffffff {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetTempPath(buflen uint32, buf *uint16) (n uint32, errno int) {
+	r0, _, e1 := Syscall(procGetTempPathW, 2, uintptr(buflen), uintptr(unsafe.Pointer(buf)), 0)
+	n = uint32(r0)
+	if n == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func CreatePipe(readhandle *Handle, writehandle *Handle, sa *SecurityAttributes, size uint32) (errno int) {
+	r1, _, e1 := Syscall6(procCreatePipe, 4, uintptr(unsafe.Pointer(readhandle)), uintptr(unsafe.Pointer(writehandle)), uintptr(unsafe.Pointer(sa)), uintptr(size), 0, 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetFileType(filehandle Handle) (n uint32, errno int) {
+	r0, _, e1 := Syscall(procGetFileType, 1, uintptr(filehandle), 0, 0)
+	n = uint32(r0)
+	if n == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func CryptAcquireContext(provhandle *Handle, container *uint16, provider *uint16, provtype uint32, flags uint32) (errno int) {
+	r1, _, e1 := Syscall6(procCryptAcquireContextW, 5, uintptr(unsafe.Pointer(provhandle)), uintptr(unsafe.Pointer(container)), uintptr(unsafe.Pointer(provider)), uintptr(provtype), uintptr(flags), 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func CryptReleaseContext(provhandle Handle, flags uint32) (errno int) {
+	r1, _, e1 := Syscall(procCryptReleaseContext, 2, uintptr(provhandle), uintptr(flags), 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func CryptGenRandom(provhandle Handle, buflen uint32, buf *byte) (errno int) {
+	r1, _, e1 := Syscall(procCryptGenRandom, 3, uintptr(provhandle), uintptr(buflen), uintptr(unsafe.Pointer(buf)))
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetEnvironmentStrings() (envs *uint16, errno int) {
+	r0, _, e1 := Syscall(procGetEnvironmentStringsW, 0, 0, 0, 0)
+	envs = (*uint16)(unsafe.Pointer(r0))
+	if envs == nil {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func FreeEnvironmentStrings(envs *uint16) (errno int) {
+	r1, _, e1 := Syscall(procFreeEnvironmentStringsW, 1, uintptr(unsafe.Pointer(envs)), 0, 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetEnvironmentVariable(name *uint16, buffer *uint16, size uint32) (n uint32, errno int) {
+	r0, _, e1 := Syscall(procGetEnvironmentVariableW, 3, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(buffer)), uintptr(size))
+	n = uint32(r0)
+	if n == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func SetEnvironmentVariable(name *uint16, value *uint16) (errno int) {
+	r1, _, e1 := Syscall(procSetEnvironmentVariableW, 2, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(value)), 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func SetFileTime(handle Handle, ctime *Filetime, atime *Filetime, wtime *Filetime) (errno int) {
+	r1, _, e1 := Syscall6(procSetFileTime, 4, uintptr(handle), uintptr(unsafe.Pointer(ctime)), uintptr(unsafe.Pointer(atime)), uintptr(unsafe.Pointer(wtime)), 0, 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetFileAttributes(name *uint16) (attrs uint32, errno int) {
+	r0, _, e1 := Syscall(procGetFileAttributesW, 1, uintptr(unsafe.Pointer(name)), 0, 0)
+	attrs = uint32(r0)
+	if attrs == INVALID_FILE_ATTRIBUTES {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func SetFileAttributes(name *uint16, attrs uint32) (errno int) {
+	r1, _, e1 := Syscall(procSetFileAttributesW, 2, uintptr(unsafe.Pointer(name)), uintptr(attrs), 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetCommandLine() (cmd *uint16) {
+	r0, _, _ := Syscall(procGetCommandLineW, 0, 0, 0, 0)
+	cmd = (*uint16)(unsafe.Pointer(r0))
+	return
+}
+
+func CommandLineToArgv(cmd *uint16, argc *int32) (argv *[8192]*[8192]uint16, errno int) {
+	r0, _, e1 := Syscall(procCommandLineToArgvW, 2, uintptr(unsafe.Pointer(cmd)), uintptr(unsafe.Pointer(argc)), 0)
+	argv = (*[8192]*[8192]uint16)(unsafe.Pointer(r0))
+	if argv == nil {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func LocalFree(hmem Handle) (handle Handle, errno int) {
+	r0, _, e1 := Syscall(procLocalFree, 1, uintptr(hmem), 0, 0)
+	handle = Handle(r0)
+	if handle != 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func SetHandleInformation(handle Handle, mask uint32, flags uint32) (errno int) {
+	r1, _, e1 := Syscall(procSetHandleInformation, 3, uintptr(handle), uintptr(mask), uintptr(flags))
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func FlushFileBuffers(handle Handle) (errno int) {
+	r1, _, e1 := Syscall(procFlushFileBuffers, 1, uintptr(handle), 0, 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetFullPathName(path *uint16, buflen uint32, buf *uint16, fname **uint16) (n uint32, errno int) {
+	r0, _, e1 := Syscall6(procGetFullPathNameW, 4, uintptr(unsafe.Pointer(path)), uintptr(buflen), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(fname)), 0, 0)
+	n = uint32(r0)
+	if n == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func CreateFileMapping(fhandle Handle, sa *SecurityAttributes, prot uint32, maxSizeHigh uint32, maxSizeLow uint32, name *uint16) (handle Handle, errno int) {
+	r0, _, e1 := Syscall6(procCreateFileMappingW, 6, uintptr(fhandle), uintptr(unsafe.Pointer(sa)), uintptr(prot), uintptr(maxSizeHigh), uintptr(maxSizeLow), uintptr(unsafe.Pointer(name)))
+	handle = Handle(r0)
+	if handle == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func MapViewOfFile(handle Handle, access uint32, offsetHigh uint32, offsetLow uint32, length uintptr) (addr uintptr, errno int) {
+	r0, _, e1 := Syscall6(procMapViewOfFile, 5, uintptr(handle), uintptr(access), uintptr(offsetHigh), uintptr(offsetLow), uintptr(length), 0)
+	addr = uintptr(r0)
+	if addr == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func UnmapViewOfFile(addr uintptr) (errno int) {
+	r1, _, e1 := Syscall(procUnmapViewOfFile, 1, uintptr(addr), 0, 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func FlushViewOfFile(addr uintptr, length uintptr) (errno int) {
+	r1, _, e1 := Syscall(procFlushViewOfFile, 2, uintptr(addr), uintptr(length), 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func VirtualLock(addr uintptr, length uintptr) (errno int) {
+	r1, _, e1 := Syscall(procVirtualLock, 2, uintptr(addr), uintptr(length), 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func VirtualUnlock(addr uintptr, length uintptr) (errno int) {
+	r1, _, e1 := Syscall(procVirtualUnlock, 2, uintptr(addr), uintptr(length), 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func TransmitFile(s Handle, handle Handle, bytesToWrite uint32, bytsPerSend uint32, overlapped *Overlapped, transmitFileBuf *TransmitFileBuffers, flags uint32) (errno int) {
+	r1, _, e1 := Syscall9(procTransmitFile, 7, uintptr(s), uintptr(handle), uintptr(bytesToWrite), uintptr(bytsPerSend), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(transmitFileBuf)), uintptr(flags), 0, 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func WSAStartup(verreq uint32, data *WSAData) (sockerrno int) {
+	r0, _, _ := Syscall(procWSAStartup, 2, uintptr(verreq), uintptr(unsafe.Pointer(data)), 0)
+	sockerrno = int(r0)
+	return
+}
+
+func WSACleanup() (errno int) {
+	r1, _, e1 := Syscall(procWSACleanup, 0, 0, 0, 0)
+	if int(r1) == -1 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func WSAIoctl(s Handle, iocc uint32, inbuf *byte, cbif uint32, outbuf *byte, cbob uint32, cbbr *uint32, overlapped *Overlapped, completionRoutine uintptr) (errno int) {
+	r1, _, e1 := Syscall9(procWSAIoctl, 9, uintptr(s), uintptr(iocc), uintptr(unsafe.Pointer(inbuf)), uintptr(cbif), uintptr(unsafe.Pointer(outbuf)), uintptr(cbob), uintptr(unsafe.Pointer(cbbr)), uintptr(unsafe.Pointer(overlapped)), uintptr(completionRoutine))
+	if int(r1) == -1 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func socket(af int32, typ int32, protocol int32) (handle Handle, errno int) {
+	r0, _, e1 := Syscall(procsocket, 3, uintptr(af), uintptr(typ), uintptr(protocol))
+	handle = Handle(r0)
+	if handle == InvalidHandle {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func setsockopt(s Handle, level int32, optname int32, optval *byte, optlen int32) (errno int) {
+	r1, _, e1 := Syscall6(procsetsockopt, 5, uintptr(s), uintptr(level), uintptr(optname), uintptr(unsafe.Pointer(optval)), uintptr(optlen), 0)
+	if int(r1) == -1 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func bind(s Handle, name uintptr, namelen int32) (errno int) {
+	r1, _, e1 := Syscall(procbind, 3, uintptr(s), uintptr(name), uintptr(namelen))
+	if int(r1) == -1 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func connect(s Handle, name uintptr, namelen int32) (errno int) {
+	r1, _, e1 := Syscall(procconnect, 3, uintptr(s), uintptr(name), uintptr(namelen))
+	if int(r1) == -1 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func getsockname(s Handle, rsa *RawSockaddrAny, addrlen *int32) (errno int) {
+	r1, _, e1 := Syscall(procgetsockname, 3, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	if int(r1) == -1 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func getpeername(s Handle, rsa *RawSockaddrAny, addrlen *int32) (errno int) {
+	r1, _, e1 := Syscall(procgetpeername, 3, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	if int(r1) == -1 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func listen(s Handle, backlog int32) (errno int) {
+	r1, _, e1 := Syscall(proclisten, 2, uintptr(s), uintptr(backlog), 0)
+	if int(r1) == -1 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func shutdown(s Handle, how int32) (errno int) {
+	r1, _, e1 := Syscall(procshutdown, 2, uintptr(s), uintptr(how), 0)
+	if int(r1) == -1 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func Closesocket(s Handle) (errno int) {
+	r1, _, e1 := Syscall(procclosesocket, 1, uintptr(s), 0, 0)
+	if int(r1) == -1 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func AcceptEx(ls Handle, as Handle, buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, recvd *uint32, overlapped *Overlapped) (errno int) {
+	r1, _, e1 := Syscall9(procAcceptEx, 8, uintptr(ls), uintptr(as), uintptr(unsafe.Pointer(buf)), uintptr(rxdatalen), uintptr(laddrlen), uintptr(raddrlen), uintptr(unsafe.Pointer(recvd)), uintptr(unsafe.Pointer(overlapped)), 0)
+	if int(r1) == 0 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetAcceptExSockaddrs(buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, lrsa **RawSockaddrAny, lrsalen *int32, rrsa **RawSockaddrAny, rrsalen *int32) {
+	Syscall9(procGetAcceptExSockaddrs, 8, uintptr(unsafe.Pointer(buf)), uintptr(rxdatalen), uintptr(laddrlen), uintptr(raddrlen), uintptr(unsafe.Pointer(lrsa)), uintptr(unsafe.Pointer(lrsalen)), uintptr(unsafe.Pointer(rrsa)), uintptr(unsafe.Pointer(rrsalen)), 0)
+	return
+}
+
+func WSARecv(s Handle, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, overlapped *Overlapped, croutine *byte) (errno int) {
+	r1, _, e1 := Syscall9(procWSARecv, 7, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(recvd)), uintptr(unsafe.Pointer(flags)), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)), 0, 0)
+	if int(r1) == -1 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func WSASend(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, overlapped *Overlapped, croutine *byte) (errno int) {
+	r1, _, e1 := Syscall9(procWSASend, 7, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(sent)), uintptr(flags), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)), 0, 0)
+	if int(r1) == -1 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func WSARecvFrom(s Handle, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, from *RawSockaddrAny, fromlen *int32, overlapped *Overlapped, croutine *byte) (errno int) {
+	r1, _, e1 := Syscall9(procWSARecvFrom, 9, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(recvd)), uintptr(unsafe.Pointer(flags)), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)))
+	if int(r1) == -1 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func WSASendTo(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, to *RawSockaddrAny, tolen int32, overlapped *Overlapped, croutine *byte) (errno int) {
+	r1, _, e1 := Syscall9(procWSASendTo, 9, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(sent)), uintptr(flags), uintptr(unsafe.Pointer(to)), uintptr(tolen), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)))
+	if int(r1) == -1 {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetHostByName(name string) (h *Hostent, errno int) {
+	r0, _, e1 := Syscall(procgethostbyname, 1, uintptr(unsafe.Pointer(StringBytePtr(name))), 0, 0)
+	h = (*Hostent)(unsafe.Pointer(r0))
+	if h == nil {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func GetServByName(name string, proto string) (s *Servent, errno int) {
+	r0, _, e1 := Syscall(procgetservbyname, 2, uintptr(unsafe.Pointer(StringBytePtr(name))), uintptr(unsafe.Pointer(StringBytePtr(proto))), 0)
+	s = (*Servent)(unsafe.Pointer(r0))
+	if s == nil {
+		if e1 != 0 {
+			errno = int(e1)
+		} else {
+			errno = EINVAL
+		}
+	} else {
+		errno = 0
+	}
+	return
+}
+
+func Ntohs(netshort uint16) (u uint16) {
+	r0, _, _ := Syscall(procntohs, 1, uintptr(netshort), 0, 0)
+	u = uint16(r0)
+	return
+}
+
+func DnsQuery(name string, qtype uint16, options uint32, extra *byte, qrs **DNSRecord, pr *byte) (status uint32) {
+	r0, _, _ := Syscall6(procDnsQuery_W, 6, uintptr(unsafe.Pointer(StringToUTF16Ptr(name))), uintptr(qtype), uintptr(options), uintptr(unsafe.Pointer(extra)), uintptr(unsafe.Pointer(qrs)), uintptr(unsafe.Pointer(pr)))
+	status = uint32(r0)
+	return
+}
+
+func DnsRecordListFree(rl *DNSRecord, freetype uint32) {
+	Syscall(procDnsRecordListFree, 2, uintptr(unsafe.Pointer(rl)), uintptr(freetype), 0)
+	return
+}
+
+func GetIfEntry(pIfRow *MibIfRow) (errcode int) {
+	r0, _, _ := Syscall(procGetIfEntry, 1, uintptr(unsafe.Pointer(pIfRow)), 0, 0)
+	errcode = int(r0)
+	return
+}
+
+func GetAdaptersInfo(ai *IpAdapterInfo, ol *uint32) (errcode int) {
+	r0, _, _ := Syscall(procGetAdaptersInfo, 2, uintptr(unsafe.Pointer(ai)), uintptr(unsafe.Pointer(ol)), 0)
+	errcode = int(r0)
+	return
+}
diff --git a/src/pkg/syscall/zsysnum_windows_amd64.go b/src/pkg/syscall/zsysnum_windows_amd64.go
new file mode 100644
index 0000000000..36bf065d1f
--- /dev/null
+++ b/src/pkg/syscall/zsysnum_windows_amd64.go
@@ -0,0 +1,3 @@
+// nothing to see here
+
+package syscall
diff --git a/src/pkg/syscall/ztypes_windows.go b/src/pkg/syscall/ztypes_windows.go
new file mode 100644
index 0000000000..1a264a405f
--- /dev/null
+++ b/src/pkg/syscall/ztypes_windows.go
@@ -0,0 +1,656 @@
+package syscall
+
+// TODO(brainman): autogenerate types in ztypes_windows_386.go
+
+//import "unsafe"
+
+// Constants
+const (
+	sizeofPtr      = 0x4
+	sizeofShort    = 0x2
+	sizeofInt      = 0x4
+	sizeofLong     = 0x4
+	sizeofLongLong = 0x8
+	PathMax        = 0x1000
+	SizeofLinger   = 0x8
+	SizeofMsghdr   = 0x1c
+	SizeofCmsghdr  = 0xc
+)
+
+const (
+	// Windows errors.
+	ERROR_FILE_NOT_FOUND      = 2
+	ERROR_PATH_NOT_FOUND      = 3
+	ERROR_NO_MORE_FILES       = 18
+	ERROR_BROKEN_PIPE         = 109
+	ERROR_BUFFER_OVERFLOW     = 111
+	ERROR_INSUFFICIENT_BUFFER = 122
+	ERROR_MOD_NOT_FOUND       = 126
+	ERROR_PROC_NOT_FOUND      = 127
+	ERROR_ENVVAR_NOT_FOUND    = 203
+	ERROR_DIRECTORY           = 267
+	ERROR_OPERATION_ABORTED   = 995
+	ERROR_IO_PENDING          = 997
+)
+
+const (
+	// Invented values to support what package os expects.
+	O_RDONLY   = 0x00000
+	O_WRONLY   = 0x00001
+	O_RDWR     = 0x00002
+	O_CREAT    = 0x00040
+	O_EXCL     = 0x00080
+	O_NOCTTY   = 0x00100
+	O_TRUNC    = 0x00200
+	O_NONBLOCK = 0x00800
+	O_APPEND   = 0x00400
+	O_SYNC     = 0x01000
+	O_ASYNC    = 0x02000
+	O_CLOEXEC  = 0x80000
+)
+
+const (
+	// More invented values for signals
+	SIGHUP  = 0x1
+	SIGINT  = 0x2
+	SIGQUIT = 0x3
+	SIGILL  = 0x4
+	SIGTRAP = 0x5
+	SIGABRT = 0x6
+	SIGBUS  = 0x7
+	SIGFPE  = 0x8
+	SIGKILL = 0x9
+	SIGSEGV = 0xb
+	SIGPIPE = 0xd
+	SIGALRM = 0xe
+	SIGTERM = 0xf
+)
+
+const (
+	GENERIC_READ    = 0x80000000
+	GENERIC_WRITE   = 0x40000000
+	GENERIC_EXECUTE = 0x20000000
+	GENERIC_ALL     = 0x10000000
+
+	FILE_APPEND_DATA      = 0x00000004
+	FILE_WRITE_ATTRIBUTES = 0x00000100
+
+	FILE_SHARE_READ          = 0x00000001
+	FILE_SHARE_WRITE         = 0x00000002
+	FILE_SHARE_DELETE        = 0x00000004
+	FILE_ATTRIBUTE_READONLY  = 0x00000001
+	FILE_ATTRIBUTE_HIDDEN    = 0x00000002
+	FILE_ATTRIBUTE_SYSTEM    = 0x00000004
+	FILE_ATTRIBUTE_DIRECTORY = 0x00000010
+	FILE_ATTRIBUTE_ARCHIVE   = 0x00000020
+	FILE_ATTRIBUTE_NORMAL    = 0x00000080
+
+	INVALID_FILE_ATTRIBUTES = 0xffffffff
+
+	CREATE_NEW        = 1
+	CREATE_ALWAYS     = 2
+	OPEN_EXISTING     = 3
+	OPEN_ALWAYS       = 4
+	TRUNCATE_EXISTING = 5
+
+	HANDLE_FLAG_INHERIT    = 0x00000001
+	STARTF_USESTDHANDLES   = 0x00000100
+	STARTF_USESHOWWINDOW   = 0x00000001
+	DUPLICATE_CLOSE_SOURCE = 0x00000001
+	DUPLICATE_SAME_ACCESS  = 0x00000002
+
+	STD_INPUT_HANDLE  = -10
+	STD_OUTPUT_HANDLE = -11
+	STD_ERROR_HANDLE  = -12
+
+	FILE_BEGIN   = 0
+	FILE_CURRENT = 1
+	FILE_END     = 2
+
+	FORMAT_MESSAGE_ALLOCATE_BUFFER = 256
+	FORMAT_MESSAGE_IGNORE_INSERTS  = 512
+	FORMAT_MESSAGE_FROM_STRING     = 1024
+	FORMAT_MESSAGE_FROM_HMODULE    = 2048
+	FORMAT_MESSAGE_FROM_SYSTEM     = 4096
+	FORMAT_MESSAGE_ARGUMENT_ARRAY  = 8192
+	FORMAT_MESSAGE_MAX_WIDTH_MASK  = 255
+
+	MAX_PATH      = 260
+	MAX_LONG_PATH = 32768
+
+	MAX_COMPUTERNAME_LENGTH = 15
+
+	TIME_ZONE_ID_UNKNOWN  = 0
+	TIME_ZONE_ID_STANDARD = 1
+
+	TIME_ZONE_ID_DAYLIGHT = 2
+	IGNORE                = 0
+	INFINITE              = 0xffffffff
+
+	WAIT_TIMEOUT   = 258
+	WAIT_ABANDONED = 0x00000080
+	WAIT_OBJECT_0  = 0x00000000
+	WAIT_FAILED    = 0xFFFFFFFF
+
+	CREATE_UNICODE_ENVIRONMENT = 0x00000400
+
+	STANDARD_RIGHTS_READ      = 0x00020000
+	PROCESS_QUERY_INFORMATION = 0x00000400
+	SYNCHRONIZE               = 0x00100000
+
+	PAGE_READONLY          = 0x02
+	PAGE_READWRITE         = 0x04
+	PAGE_WRITECOPY         = 0x08
+	PAGE_EXECUTE_READ      = 0x20
+	PAGE_EXECUTE_READWRITE = 0x40
+	PAGE_EXECUTE_WRITECOPY = 0x80
+
+	FILE_MAP_COPY    = 0x01
+	FILE_MAP_WRITE   = 0x02
+	FILE_MAP_READ    = 0x04
+	FILE_MAP_EXECUTE = 0x20
+)
+
+const (
+	// wincrypt.h
+	PROV_RSA_FULL                    = 1
+	PROV_RSA_SIG                     = 2
+	PROV_DSS                         = 3
+	PROV_FORTEZZA                    = 4
+	PROV_MS_EXCHANGE                 = 5
+	PROV_SSL                         = 6
+	PROV_RSA_SCHANNEL                = 12
+	PROV_DSS_DH                      = 13
+	PROV_EC_ECDSA_SIG                = 14
+	PROV_EC_ECNRA_SIG                = 15
+	PROV_EC_ECDSA_FULL               = 16
+	PROV_EC_ECNRA_FULL               = 17
+	PROV_DH_SCHANNEL                 = 18
+	PROV_SPYRUS_LYNKS                = 20
+	PROV_RNG                         = 21
+	PROV_INTEL_SEC                   = 22
+	PROV_REPLACE_OWF                 = 23
+	PROV_RSA_AES                     = 24
+	CRYPT_VERIFYCONTEXT              = 0xF0000000
+	CRYPT_NEWKEYSET                  = 0x00000008
+	CRYPT_DELETEKEYSET               = 0x00000010
+	CRYPT_MACHINE_KEYSET             = 0x00000020
+	CRYPT_SILENT                     = 0x00000040
+	CRYPT_DEFAULT_CONTAINER_OPTIONAL = 0x00000080
+)
+
+// Types
+
+type _C_short int16
+
+type _C_int int32
+
+type _C_long int32
+
+type _C_long_long int64
+
+// Invented values to support what package os expects.
+type Timeval struct {
+	Sec  int32
+	Usec int32
+}
+
+func (tv *Timeval) Nanoseconds() int64 {
+	return (int64(tv.Sec)*1e6 + int64(tv.Usec)) * 1e3
+}
+
+func NsecToTimeval(nsec int64) (tv Timeval) {
+	tv.Sec = int32(nsec / 1e9)
+	tv.Usec = int32(nsec % 1e9 / 1e3)
+	return
+}
+
+type SecurityAttributes struct {
+	Length             uint32
+	SecurityDescriptor uintptr
+	InheritHandle      uint32
+}
+
+type Overlapped struct {
+	Internal     uint32
+	InternalHigh uint32
+	Offset       uint32
+	OffsetHigh   uint32
+	HEvent       Handle
+}
+
+type Filetime struct {
+	LowDateTime  uint32
+	HighDateTime uint32
+}
+
+func (ft *Filetime) Nanoseconds() int64 {
+	// 100-nanosecond intervals since January 1, 1601
+	nsec := int64(ft.HighDateTime)<<32 + int64(ft.LowDateTime)
+	// change starting time to the Epoch (00:00:00 UTC, January 1, 1970)
+	nsec -= 116444736000000000
+	// convert into nanoseconds
+	nsec *= 100
+	return nsec
+}
+
+func NsecToFiletime(nsec int64) (ft Filetime) {
+	// convert into 100-nanosecond
+	nsec /= 100
+	// change starting time to January 1, 1601
+	nsec += 116444736000000000
+	// split into high / low
+	ft.LowDateTime = uint32(nsec & 0xffffffff)
+	ft.HighDateTime = uint32(nsec >> 32 & 0xffffffff)
+	return ft
+}
+
+type Win32finddata struct {
+	FileAttributes    uint32
+	CreationTime      Filetime
+	LastAccessTime    Filetime
+	LastWriteTime     Filetime
+	FileSizeHigh      uint32
+	FileSizeLow       uint32
+	Reserved0         uint32
+	Reserved1         uint32
+	FileName          [MAX_PATH - 1]uint16
+	AlternateFileName [13]uint16
+}
+
+type ByHandleFileInformation struct {
+	FileAttributes     uint32
+	CreationTime       Filetime
+	LastAccessTime     Filetime
+	LastWriteTime      Filetime
+	VolumeSerialNumber uint32
+	FileSizeHigh       uint32
+	FileSizeLow        uint32
+	NumberOfLinks      uint32
+	FileIndexHigh      uint32
+	FileIndexLow       uint32
+}
+
+// ShowWindow constants
+const (
+	// winuser.h
+	SW_HIDE            = 0
+	SW_NORMAL          = 1
+	SW_SHOWNORMAL      = 1
+	SW_SHOWMINIMIZED   = 2
+	SW_SHOWMAXIMIZED   = 3
+	SW_MAXIMIZE        = 3
+	SW_SHOWNOACTIVATE  = 4
+	SW_SHOW            = 5
+	SW_MINIMIZE        = 6
+	SW_SHOWMINNOACTIVE = 7
+	SW_SHOWNA          = 8
+	SW_RESTORE         = 9
+	SW_SHOWDEFAULT     = 10
+	SW_FORCEMINIMIZE   = 11
+)
+
+type StartupInfo struct {
+	Cb            uint32
+	_             *uint16
+	Desktop       *uint16
+	Title         *uint16
+	X             uint32
+	Y             uint32
+	XSize         uint32
+	YSize         uint32
+	XCountChars   uint32
+	YCountChars   uint32
+	FillAttribute uint32
+	Flags         uint32
+	ShowWindow    uint16
+	_             uint16
+	_             *byte
+	StdInput      Handle
+	StdOutput     Handle
+	StdErr        Handle
+}
+
+type ProcessInformation struct {
+	Process   Handle
+	Thread    Handle
+	ProcessId uint32
+	ThreadId  uint32
+}
+
+// Invented values to support what package os expects.
+type Stat_t struct {
+	Windata Win32finddata
+	Mode    uint32
+}
+
+type Systemtime struct {
+	Year         uint16
+	Month        uint16
+	DayOfWeek    uint16
+	Day          uint16
+	Hour         uint16
+	Minute       uint16
+	Second       uint16
+	Milliseconds uint16
+}
+
+type Timezoneinformation struct {
+	Bias         int32
+	StandardName [32]uint16
+	StandardDate Systemtime
+	StandardBias int32
+	DaylightName [32]uint16
+	DaylightDate Systemtime
+	DaylightBias int32
+}
+
+// Socket related.
+
+const (
+	AF_UNSPEC  = 0
+	AF_UNIX    = 1
+	AF_INET    = 2
+	AF_INET6   = 23
+	AF_NETBIOS = 17
+
+	SOCK_STREAM    = 1
+	SOCK_DGRAM     = 2
+	SOCK_RAW       = 3
+	SOCK_SEQPACKET = 5
+
+	IPPROTO_IP  = 0
+	IPPROTO_TCP = 6
+	IPPROTO_UDP = 17
+
+	SOL_SOCKET               = 0xffff
+	SO_REUSEADDR             = 4
+	SO_KEEPALIVE             = 8
+	SO_DONTROUTE             = 16
+	SO_BROADCAST             = 32
+	SO_LINGER                = 128
+	SO_RCVBUF                = 0x1002
+	SO_SNDBUF                = 0x1001
+	SO_UPDATE_ACCEPT_CONTEXT = 0x700b
+
+	IPPROTO_IPV6 = 0x29
+	IPV6_V6ONLY  = 0x1b
+
+	SOMAXCONN = 5
+
+	TCP_NODELAY = 1
+
+	SHUT_RD   = 0
+	SHUT_WR   = 1
+	SHUT_RDWR = 2
+
+	WSADESCRIPTION_LEN = 256
+	WSASYS_STATUS_LEN  = 128
+)
+
+type WSAData struct {
+	Version      uint16
+	HighVersion  uint16
+	Description  [WSADESCRIPTION_LEN + 1]byte
+	SystemStatus [WSASYS_STATUS_LEN + 1]byte
+	MaxSockets   uint16
+	MaxUdpDg     uint16
+	VendorInfo   *byte
+}
+
+type WSABuf struct {
+	Len uint32
+	Buf *byte
+}
+
+// TODO(brainman): fix all needed for os
+
+const (
+	PROT_READ  = 0x1
+	PROT_WRITE = 0x2
+	MAP_SHARED = 0x1
+	SYS_FORK   = 0
+	SYS_PTRACE = 0
+	SYS_CHDIR  = 0
+	SYS_DUP2   = 0
+	SYS_FCNTL  = 0
+	SYS_EXECVE = 0
+	F_GETFD    = 0x1
+	F_SETFD    = 0x2
+	F_GETFL    = 0x3
+	F_SETFL    = 0x4
+	FD_CLOEXEC = 0
+	S_IFMT     = 0x1f000
+	S_IFIFO    = 0x1000
+	S_IFCHR    = 0x2000
+	S_IFDIR    = 0x4000
+	S_IFBLK    = 0x6000
+	S_IFREG    = 0x8000
+	S_IFLNK    = 0xa000
+	S_IFSOCK   = 0xc000
+	S_ISUID    = 0x800
+	S_ISGID    = 0x400
+	S_ISVTX    = 0x200
+	S_IRUSR    = 0x100
+	S_IWRITE   = 0x80
+	S_IWUSR    = 0x80
+	S_IXUSR    = 0x40
+)
+
+const (
+	FILE_TYPE_CHAR    = 0x0002
+	FILE_TYPE_DISK    = 0x0001
+	FILE_TYPE_PIPE    = 0x0003
+	FILE_TYPE_REMOTE  = 0x8000
+	FILE_TYPE_UNKNOWN = 0x0000
+)
+
+type Hostent struct {
+	Name     *byte
+	Aliases  **byte
+	AddrType uint16
+	Length   uint16
+	AddrList **byte
+}
+
+type Servent struct {
+	Name    *byte
+	Aliases **byte
+	Port    uint16
+	Proto   *byte
+}
+
+const (
+	DNS_TYPE_A       = 0x0001
+	DNS_TYPE_NS      = 0x0002
+	DNS_TYPE_MD      = 0x0003
+	DNS_TYPE_MF      = 0x0004
+	DNS_TYPE_CNAME   = 0x0005
+	DNS_TYPE_SOA     = 0x0006
+	DNS_TYPE_MB      = 0x0007
+	DNS_TYPE_MG      = 0x0008
+	DNS_TYPE_MR      = 0x0009
+	DNS_TYPE_NULL    = 0x000a
+	DNS_TYPE_WKS     = 0x000b
+	DNS_TYPE_PTR     = 0x000c
+	DNS_TYPE_HINFO   = 0x000d
+	DNS_TYPE_MINFO   = 0x000e
+	DNS_TYPE_MX      = 0x000f
+	DNS_TYPE_TEXT    = 0x0010
+	DNS_TYPE_RP      = 0x0011
+	DNS_TYPE_AFSDB   = 0x0012
+	DNS_TYPE_X25     = 0x0013
+	DNS_TYPE_ISDN    = 0x0014
+	DNS_TYPE_RT      = 0x0015
+	DNS_TYPE_NSAP    = 0x0016
+	DNS_TYPE_NSAPPTR = 0x0017
+	DNS_TYPE_SIG     = 0x0018
+	DNS_TYPE_KEY     = 0x0019
+	DNS_TYPE_PX      = 0x001a
+	DNS_TYPE_GPOS    = 0x001b
+	DNS_TYPE_AAAA    = 0x001c
+	DNS_TYPE_LOC     = 0x001d
+	DNS_TYPE_NXT     = 0x001e
+	DNS_TYPE_EID     = 0x001f
+	DNS_TYPE_NIMLOC  = 0x0020
+	DNS_TYPE_SRV     = 0x0021
+	DNS_TYPE_ATMA    = 0x0022
+	DNS_TYPE_NAPTR   = 0x0023
+	DNS_TYPE_KX      = 0x0024
+	DNS_TYPE_CERT    = 0x0025
+	DNS_TYPE_A6      = 0x0026
+	DNS_TYPE_DNAME   = 0x0027
+	DNS_TYPE_SINK    = 0x0028
+	DNS_TYPE_OPT     = 0x0029
+	DNS_TYPE_DS      = 0x002B
+	DNS_TYPE_RRSIG   = 0x002E
+	DNS_TYPE_NSEC    = 0x002F
+	DNS_TYPE_DNSKEY  = 0x0030
+	DNS_TYPE_DHCID   = 0x0031
+	DNS_TYPE_UINFO   = 0x0064
+	DNS_TYPE_UID     = 0x0065
+	DNS_TYPE_GID     = 0x0066
+	DNS_TYPE_UNSPEC  = 0x0067
+	DNS_TYPE_ADDRS   = 0x00f8
+	DNS_TYPE_TKEY    = 0x00f9
+	DNS_TYPE_TSIG    = 0x00fa
+	DNS_TYPE_IXFR    = 0x00fb
+	DNS_TYPE_AXFR    = 0x00fc
+	DNS_TYPE_MAILB   = 0x00fd
+	DNS_TYPE_MAILA   = 0x00fe
+	DNS_TYPE_ALL     = 0x00ff
+	DNS_TYPE_ANY     = 0x00ff
+	DNS_TYPE_WINS    = 0xff01
+	DNS_TYPE_WINSR   = 0xff02
+	DNS_TYPE_NBSTAT  = 0xff01
+)
+
+type DNSSRVData struct {
+	Target   *uint16
+	Priority uint16
+	Weight   uint16
+	Port     uint16
+	Pad      uint16
+}
+
+type DNSPTRData struct {
+	Host *uint16
+}
+
+type DNSRecord struct {
+	Next     *DNSRecord
+	Name     *uint16
+	Type     uint16
+	Length   uint16
+	Dw       uint32
+	Ttl      uint32
+	Reserved uint32
+	Data     [40]byte
+}
+
+const (
+	TF_DISCONNECT         = 1
+	TF_REUSE_SOCKET       = 2
+	TF_WRITE_BEHIND       = 4
+	TF_USE_DEFAULT_WORKER = 0
+	TF_USE_SYSTEM_THREAD  = 16
+	TF_USE_KERNEL_APC     = 32
+)
+
+type TransmitFileBuffers struct {
+	Head       uintptr
+	HeadLength uint32
+	Tail       uintptr
+	TailLength uint32
+}
+
+const (
+	IFF_UP           = 1
+	IFF_BROADCAST    = 2
+	IFF_LOOPBACK     = 4
+	IFF_POINTTOPOINT = 8
+	IFF_MULTICAST    = 16
+)
+
+const SIO_GET_INTERFACE_LIST = 0x4004747F
+
+// TODO(mattn): SockaddrGen is union of sockaddr/sockaddr_in/sockaddr_in6_old.
+// will be fixed to change variable type as suitable.
+
+type SockaddrGen [24]byte
+
+type InterfaceInfo struct {
+	Flags            uint32
+	Address          SockaddrGen
+	BroadcastAddress SockaddrGen
+	Netmask          SockaddrGen
+}
+
+type IpAddressString struct {
+	String [16]byte
+}
+
+type IpMaskString IpAddressString
+
+type IpAddrString struct {
+	Next      *IpAddrString
+	IpAddress IpAddressString
+	IpMask    IpMaskString
+	Context   uint32
+}
+
+const MAX_ADAPTER_NAME_LENGTH = 256
+const MAX_ADAPTER_DESCRIPTION_LENGTH = 128
+const MAX_ADAPTER_ADDRESS_LENGTH = 8
+
+type IpAdapterInfo struct {
+	Next                *IpAdapterInfo
+	ComboIndex          uint32
+	AdapterName         [MAX_ADAPTER_NAME_LENGTH + 4]byte
+	Description         [MAX_ADAPTER_DESCRIPTION_LENGTH + 4]byte
+	AddressLength       uint32
+	Address             [MAX_ADAPTER_ADDRESS_LENGTH]byte
+	Index               uint32
+	Type                uint32
+	DhcpEnabled         uint32
+	CurrentIpAddress    *IpAddrString
+	IpAddressList       IpAddrString
+	GatewayList         IpAddrString
+	DhcpServer          IpAddrString
+	HaveWins            bool
+	PrimaryWinsServer   IpAddrString
+	SecondaryWinsServer IpAddrString
+	LeaseObtained       int64
+	LeaseExpires        int64
+}
+
+const MAXLEN_PHYSADDR = 8
+const MAX_INTERFACE_NAME_LEN = 256
+const MAXLEN_IFDESCR = 256
+
+type MibIfRow struct {
+	Name            [MAX_INTERFACE_NAME_LEN]uint16
+	Index           uint32
+	Type            uint32
+	Mtu             uint32
+	Speed           uint32
+	PhysAddrLen     uint32
+	PhysAddr        [MAXLEN_PHYSADDR]byte
+	AdminStatus     uint32
+	OperStatus      uint32
+	LastChange      uint32
+	InOctets        uint32
+	InUcastPkts     uint32
+	InNUcastPkts    uint32
+	InDiscards      uint32
+	InErrors        uint32
+	InUnknownProtos uint32
+	OutOctets       uint32
+	OutUcastPkts    uint32
+	OutNUcastPkts   uint32
+	OutDiscards     uint32
+	OutErrors       uint32
+	OutQLen         uint32
+	DescrLen        uint32
+	Descr           [MAXLEN_IFDESCR]byte
+}
diff --git a/src/pkg/syscall/ztypes_windows_386.go b/src/pkg/syscall/ztypes_windows_386.go
index 1a264a405f..d1008bd03c 100644
--- a/src/pkg/syscall/ztypes_windows_386.go
+++ b/src/pkg/syscall/ztypes_windows_386.go
@@ -1,656 +1,5 @@
-package syscall
-
-// TODO(brainman): autogenerate types in ztypes_windows_386.go
-
-//import "unsafe"
-
-// Constants
-const (
-	sizeofPtr      = 0x4
-	sizeofShort    = 0x2
-	sizeofInt      = 0x4
-	sizeofLong     = 0x4
-	sizeofLongLong = 0x8
-	PathMax        = 0x1000
-	SizeofLinger   = 0x8
-	SizeofMsghdr   = 0x1c
-	SizeofCmsghdr  = 0xc
-)
-
-const (
-	// Windows errors.
-	ERROR_FILE_NOT_FOUND      = 2
-	ERROR_PATH_NOT_FOUND      = 3
-	ERROR_NO_MORE_FILES       = 18
-	ERROR_BROKEN_PIPE         = 109
-	ERROR_BUFFER_OVERFLOW     = 111
-	ERROR_INSUFFICIENT_BUFFER = 122
-	ERROR_MOD_NOT_FOUND       = 126
-	ERROR_PROC_NOT_FOUND      = 127
-	ERROR_ENVVAR_NOT_FOUND    = 203
-	ERROR_DIRECTORY           = 267
-	ERROR_OPERATION_ABORTED   = 995
-	ERROR_IO_PENDING          = 997
-)
-
-const (
-	// Invented values to support what package os expects.
-	O_RDONLY   = 0x00000
-	O_WRONLY   = 0x00001
-	O_RDWR     = 0x00002
-	O_CREAT    = 0x00040
-	O_EXCL     = 0x00080
-	O_NOCTTY   = 0x00100
-	O_TRUNC    = 0x00200
-	O_NONBLOCK = 0x00800
-	O_APPEND   = 0x00400
-	O_SYNC     = 0x01000
-	O_ASYNC    = 0x02000
-	O_CLOEXEC  = 0x80000
-)
-
-const (
-	// More invented values for signals
-	SIGHUP  = 0x1
-	SIGINT  = 0x2
-	SIGQUIT = 0x3
-	SIGILL  = 0x4
-	SIGTRAP = 0x5
-	SIGABRT = 0x6
-	SIGBUS  = 0x7
-	SIGFPE  = 0x8
-	SIGKILL = 0x9
-	SIGSEGV = 0xb
-	SIGPIPE = 0xd
-	SIGALRM = 0xe
-	SIGTERM = 0xf
-)
-
-const (
-	GENERIC_READ    = 0x80000000
-	GENERIC_WRITE   = 0x40000000
-	GENERIC_EXECUTE = 0x20000000
-	GENERIC_ALL     = 0x10000000
-
-	FILE_APPEND_DATA      = 0x00000004
-	FILE_WRITE_ATTRIBUTES = 0x00000100
-
-	FILE_SHARE_READ          = 0x00000001
-	FILE_SHARE_WRITE         = 0x00000002
-	FILE_SHARE_DELETE        = 0x00000004
-	FILE_ATTRIBUTE_READONLY  = 0x00000001
-	FILE_ATTRIBUTE_HIDDEN    = 0x00000002
-	FILE_ATTRIBUTE_SYSTEM    = 0x00000004
-	FILE_ATTRIBUTE_DIRECTORY = 0x00000010
-	FILE_ATTRIBUTE_ARCHIVE   = 0x00000020
-	FILE_ATTRIBUTE_NORMAL    = 0x00000080
-
-	INVALID_FILE_ATTRIBUTES = 0xffffffff
-
-	CREATE_NEW        = 1
-	CREATE_ALWAYS     = 2
-	OPEN_EXISTING     = 3
-	OPEN_ALWAYS       = 4
-	TRUNCATE_EXISTING = 5
-
-	HANDLE_FLAG_INHERIT    = 0x00000001
-	STARTF_USESTDHANDLES   = 0x00000100
-	STARTF_USESHOWWINDOW   = 0x00000001
-	DUPLICATE_CLOSE_SOURCE = 0x00000001
-	DUPLICATE_SAME_ACCESS  = 0x00000002
-
-	STD_INPUT_HANDLE  = -10
-	STD_OUTPUT_HANDLE = -11
-	STD_ERROR_HANDLE  = -12
-
-	FILE_BEGIN   = 0
-	FILE_CURRENT = 1
-	FILE_END     = 2
-
-	FORMAT_MESSAGE_ALLOCATE_BUFFER = 256
-	FORMAT_MESSAGE_IGNORE_INSERTS  = 512
-	FORMAT_MESSAGE_FROM_STRING     = 1024
-	FORMAT_MESSAGE_FROM_HMODULE    = 2048
-	FORMAT_MESSAGE_FROM_SYSTEM     = 4096
-	FORMAT_MESSAGE_ARGUMENT_ARRAY  = 8192
-	FORMAT_MESSAGE_MAX_WIDTH_MASK  = 255
-
-	MAX_PATH      = 260
-	MAX_LONG_PATH = 32768
-
-	MAX_COMPUTERNAME_LENGTH = 15
-
-	TIME_ZONE_ID_UNKNOWN  = 0
-	TIME_ZONE_ID_STANDARD = 1
-
-	TIME_ZONE_ID_DAYLIGHT = 2
-	IGNORE                = 0
-	INFINITE              = 0xffffffff
-
-	WAIT_TIMEOUT   = 258
-	WAIT_ABANDONED = 0x00000080
-	WAIT_OBJECT_0  = 0x00000000
-	WAIT_FAILED    = 0xFFFFFFFF
-
-	CREATE_UNICODE_ENVIRONMENT = 0x00000400
-
-	STANDARD_RIGHTS_READ      = 0x00020000
-	PROCESS_QUERY_INFORMATION = 0x00000400
-	SYNCHRONIZE               = 0x00100000
-
-	PAGE_READONLY          = 0x02
-	PAGE_READWRITE         = 0x04
-	PAGE_WRITECOPY         = 0x08
-	PAGE_EXECUTE_READ      = 0x20
-	PAGE_EXECUTE_READWRITE = 0x40
-	PAGE_EXECUTE_WRITECOPY = 0x80
-
-	FILE_MAP_COPY    = 0x01
-	FILE_MAP_WRITE   = 0x02
-	FILE_MAP_READ    = 0x04
-	FILE_MAP_EXECUTE = 0x20
-)
-
-const (
-	// wincrypt.h
-	PROV_RSA_FULL                    = 1
-	PROV_RSA_SIG                     = 2
-	PROV_DSS                         = 3
-	PROV_FORTEZZA                    = 4
-	PROV_MS_EXCHANGE                 = 5
-	PROV_SSL                         = 6
-	PROV_RSA_SCHANNEL                = 12
-	PROV_DSS_DH                      = 13
-	PROV_EC_ECDSA_SIG                = 14
-	PROV_EC_ECNRA_SIG                = 15
-	PROV_EC_ECDSA_FULL               = 16
-	PROV_EC_ECNRA_FULL               = 17
-	PROV_DH_SCHANNEL                 = 18
-	PROV_SPYRUS_LYNKS                = 20
-	PROV_RNG                         = 21
-	PROV_INTEL_SEC                   = 22
-	PROV_REPLACE_OWF                 = 23
-	PROV_RSA_AES                     = 24
-	CRYPT_VERIFYCONTEXT              = 0xF0000000
-	CRYPT_NEWKEYSET                  = 0x00000008
-	CRYPT_DELETEKEYSET               = 0x00000010
-	CRYPT_MACHINE_KEYSET             = 0x00000020
-	CRYPT_SILENT                     = 0x00000040
-	CRYPT_DEFAULT_CONTAINER_OPTIONAL = 0x00000080
-)
-
-// Types
-
-type _C_short int16
-
-type _C_int int32
-
-type _C_long int32
-
-type _C_long_long int64
-
-// Invented values to support what package os expects.
-type Timeval struct {
-	Sec  int32
-	Usec int32
-}
-
-func (tv *Timeval) Nanoseconds() int64 {
-	return (int64(tv.Sec)*1e6 + int64(tv.Usec)) * 1e3
-}
-
-func NsecToTimeval(nsec int64) (tv Timeval) {
-	tv.Sec = int32(nsec / 1e9)
-	tv.Usec = int32(nsec % 1e9 / 1e3)
-	return
-}
-
-type SecurityAttributes struct {
-	Length             uint32
-	SecurityDescriptor uintptr
-	InheritHandle      uint32
-}
-
-type Overlapped struct {
-	Internal     uint32
-	InternalHigh uint32
-	Offset       uint32
-	OffsetHigh   uint32
-	HEvent       Handle
-}
-
-type Filetime struct {
-	LowDateTime  uint32
-	HighDateTime uint32
-}
-
-func (ft *Filetime) Nanoseconds() int64 {
-	// 100-nanosecond intervals since January 1, 1601
-	nsec := int64(ft.HighDateTime)<<32 + int64(ft.LowDateTime)
-	// change starting time to the Epoch (00:00:00 UTC, January 1, 1970)
-	nsec -= 116444736000000000
-	// convert into nanoseconds
-	nsec *= 100
-	return nsec
-}
-
-func NsecToFiletime(nsec int64) (ft Filetime) {
-	// convert into 100-nanosecond
-	nsec /= 100
-	// change starting time to January 1, 1601
-	nsec += 116444736000000000
-	// split into high / low
-	ft.LowDateTime = uint32(nsec & 0xffffffff)
-	ft.HighDateTime = uint32(nsec >> 32 & 0xffffffff)
-	return ft
-}
-
-type Win32finddata struct {
-	FileAttributes    uint32
-	CreationTime      Filetime
-	LastAccessTime    Filetime
-	LastWriteTime     Filetime
-	FileSizeHigh      uint32
-	FileSizeLow       uint32
-	Reserved0         uint32
-	Reserved1         uint32
-	FileName          [MAX_PATH - 1]uint16
-	AlternateFileName [13]uint16
-}
-
-type ByHandleFileInformation struct {
-	FileAttributes     uint32
-	CreationTime       Filetime
-	LastAccessTime     Filetime
-	LastWriteTime      Filetime
-	VolumeSerialNumber uint32
-	FileSizeHigh       uint32
-	FileSizeLow        uint32
-	NumberOfLinks      uint32
-	FileIndexHigh      uint32
-	FileIndexLow       uint32
-}
+// Copyright 2011 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
 
-// ShowWindow constants
-const (
-	// winuser.h
-	SW_HIDE            = 0
-	SW_NORMAL          = 1
-	SW_SHOWNORMAL      = 1
-	SW_SHOWMINIMIZED   = 2
-	SW_SHOWMAXIMIZED   = 3
-	SW_MAXIMIZE        = 3
-	SW_SHOWNOACTIVATE  = 4
-	SW_SHOW            = 5
-	SW_MINIMIZE        = 6
-	SW_SHOWMINNOACTIVE = 7
-	SW_SHOWNA          = 8
-	SW_RESTORE         = 9
-	SW_SHOWDEFAULT     = 10
-	SW_FORCEMINIMIZE   = 11
-)
-
-type StartupInfo struct {
-	Cb            uint32
-	_             *uint16
-	Desktop       *uint16
-	Title         *uint16
-	X             uint32
-	Y             uint32
-	XSize         uint32
-	YSize         uint32
-	XCountChars   uint32
-	YCountChars   uint32
-	FillAttribute uint32
-	Flags         uint32
-	ShowWindow    uint16
-	_             uint16
-	_             *byte
-	StdInput      Handle
-	StdOutput     Handle
-	StdErr        Handle
-}
-
-type ProcessInformation struct {
-	Process   Handle
-	Thread    Handle
-	ProcessId uint32
-	ThreadId  uint32
-}
-
-// Invented values to support what package os expects.
-type Stat_t struct {
-	Windata Win32finddata
-	Mode    uint32
-}
-
-type Systemtime struct {
-	Year         uint16
-	Month        uint16
-	DayOfWeek    uint16
-	Day          uint16
-	Hour         uint16
-	Minute       uint16
-	Second       uint16
-	Milliseconds uint16
-}
-
-type Timezoneinformation struct {
-	Bias         int32
-	StandardName [32]uint16
-	StandardDate Systemtime
-	StandardBias int32
-	DaylightName [32]uint16
-	DaylightDate Systemtime
-	DaylightBias int32
-}
-
-// Socket related.
-
-const (
-	AF_UNSPEC  = 0
-	AF_UNIX    = 1
-	AF_INET    = 2
-	AF_INET6   = 23
-	AF_NETBIOS = 17
-
-	SOCK_STREAM    = 1
-	SOCK_DGRAM     = 2
-	SOCK_RAW       = 3
-	SOCK_SEQPACKET = 5
-
-	IPPROTO_IP  = 0
-	IPPROTO_TCP = 6
-	IPPROTO_UDP = 17
-
-	SOL_SOCKET               = 0xffff
-	SO_REUSEADDR             = 4
-	SO_KEEPALIVE             = 8
-	SO_DONTROUTE             = 16
-	SO_BROADCAST             = 32
-	SO_LINGER                = 128
-	SO_RCVBUF                = 0x1002
-	SO_SNDBUF                = 0x1001
-	SO_UPDATE_ACCEPT_CONTEXT = 0x700b
-
-	IPPROTO_IPV6 = 0x29
-	IPV6_V6ONLY  = 0x1b
-
-	SOMAXCONN = 5
-
-	TCP_NODELAY = 1
-
-	SHUT_RD   = 0
-	SHUT_WR   = 1
-	SHUT_RDWR = 2
-
-	WSADESCRIPTION_LEN = 256
-	WSASYS_STATUS_LEN  = 128
-)
-
-type WSAData struct {
-	Version      uint16
-	HighVersion  uint16
-	Description  [WSADESCRIPTION_LEN + 1]byte
-	SystemStatus [WSASYS_STATUS_LEN + 1]byte
-	MaxSockets   uint16
-	MaxUdpDg     uint16
-	VendorInfo   *byte
-}
-
-type WSABuf struct {
-	Len uint32
-	Buf *byte
-}
-
-// TODO(brainman): fix all needed for os
-
-const (
-	PROT_READ  = 0x1
-	PROT_WRITE = 0x2
-	MAP_SHARED = 0x1
-	SYS_FORK   = 0
-	SYS_PTRACE = 0
-	SYS_CHDIR  = 0
-	SYS_DUP2   = 0
-	SYS_FCNTL  = 0
-	SYS_EXECVE = 0
-	F_GETFD    = 0x1
-	F_SETFD    = 0x2
-	F_GETFL    = 0x3
-	F_SETFL    = 0x4
-	FD_CLOEXEC = 0
-	S_IFMT     = 0x1f000
-	S_IFIFO    = 0x1000
-	S_IFCHR    = 0x2000
-	S_IFDIR    = 0x4000
-	S_IFBLK    = 0x6000
-	S_IFREG    = 0x8000
-	S_IFLNK    = 0xa000
-	S_IFSOCK   = 0xc000
-	S_ISUID    = 0x800
-	S_ISGID    = 0x400
-	S_ISVTX    = 0x200
-	S_IRUSR    = 0x100
-	S_IWRITE   = 0x80
-	S_IWUSR    = 0x80
-	S_IXUSR    = 0x40
-)
-
-const (
-	FILE_TYPE_CHAR    = 0x0002
-	FILE_TYPE_DISK    = 0x0001
-	FILE_TYPE_PIPE    = 0x0003
-	FILE_TYPE_REMOTE  = 0x8000
-	FILE_TYPE_UNKNOWN = 0x0000
-)
-
-type Hostent struct {
-	Name     *byte
-	Aliases  **byte
-	AddrType uint16
-	Length   uint16
-	AddrList **byte
-}
-
-type Servent struct {
-	Name    *byte
-	Aliases **byte
-	Port    uint16
-	Proto   *byte
-}
-
-const (
-	DNS_TYPE_A       = 0x0001
-	DNS_TYPE_NS      = 0x0002
-	DNS_TYPE_MD      = 0x0003
-	DNS_TYPE_MF      = 0x0004
-	DNS_TYPE_CNAME   = 0x0005
-	DNS_TYPE_SOA     = 0x0006
-	DNS_TYPE_MB      = 0x0007
-	DNS_TYPE_MG      = 0x0008
-	DNS_TYPE_MR      = 0x0009
-	DNS_TYPE_NULL    = 0x000a
-	DNS_TYPE_WKS     = 0x000b
-	DNS_TYPE_PTR     = 0x000c
-	DNS_TYPE_HINFO   = 0x000d
-	DNS_TYPE_MINFO   = 0x000e
-	DNS_TYPE_MX      = 0x000f
-	DNS_TYPE_TEXT    = 0x0010
-	DNS_TYPE_RP      = 0x0011
-	DNS_TYPE_AFSDB   = 0x0012
-	DNS_TYPE_X25     = 0x0013
-	DNS_TYPE_ISDN    = 0x0014
-	DNS_TYPE_RT      = 0x0015
-	DNS_TYPE_NSAP    = 0x0016
-	DNS_TYPE_NSAPPTR = 0x0017
-	DNS_TYPE_SIG     = 0x0018
-	DNS_TYPE_KEY     = 0x0019
-	DNS_TYPE_PX      = 0x001a
-	DNS_TYPE_GPOS    = 0x001b
-	DNS_TYPE_AAAA    = 0x001c
-	DNS_TYPE_LOC     = 0x001d
-	DNS_TYPE_NXT     = 0x001e
-	DNS_TYPE_EID     = 0x001f
-	DNS_TYPE_NIMLOC  = 0x0020
-	DNS_TYPE_SRV     = 0x0021
-	DNS_TYPE_ATMA    = 0x0022
-	DNS_TYPE_NAPTR   = 0x0023
-	DNS_TYPE_KX      = 0x0024
-	DNS_TYPE_CERT    = 0x0025
-	DNS_TYPE_A6      = 0x0026
-	DNS_TYPE_DNAME   = 0x0027
-	DNS_TYPE_SINK    = 0x0028
-	DNS_TYPE_OPT     = 0x0029
-	DNS_TYPE_DS      = 0x002B
-	DNS_TYPE_RRSIG   = 0x002E
-	DNS_TYPE_NSEC    = 0x002F
-	DNS_TYPE_DNSKEY  = 0x0030
-	DNS_TYPE_DHCID   = 0x0031
-	DNS_TYPE_UINFO   = 0x0064
-	DNS_TYPE_UID     = 0x0065
-	DNS_TYPE_GID     = 0x0066
-	DNS_TYPE_UNSPEC  = 0x0067
-	DNS_TYPE_ADDRS   = 0x00f8
-	DNS_TYPE_TKEY    = 0x00f9
-	DNS_TYPE_TSIG    = 0x00fa
-	DNS_TYPE_IXFR    = 0x00fb
-	DNS_TYPE_AXFR    = 0x00fc
-	DNS_TYPE_MAILB   = 0x00fd
-	DNS_TYPE_MAILA   = 0x00fe
-	DNS_TYPE_ALL     = 0x00ff
-	DNS_TYPE_ANY     = 0x00ff
-	DNS_TYPE_WINS    = 0xff01
-	DNS_TYPE_WINSR   = 0xff02
-	DNS_TYPE_NBSTAT  = 0xff01
-)
-
-type DNSSRVData struct {
-	Target   *uint16
-	Priority uint16
-	Weight   uint16
-	Port     uint16
-	Pad      uint16
-}
-
-type DNSPTRData struct {
-	Host *uint16
-}
-
-type DNSRecord struct {
-	Next     *DNSRecord
-	Name     *uint16
-	Type     uint16
-	Length   uint16
-	Dw       uint32
-	Ttl      uint32
-	Reserved uint32
-	Data     [40]byte
-}
-
-const (
-	TF_DISCONNECT         = 1
-	TF_REUSE_SOCKET       = 2
-	TF_WRITE_BEHIND       = 4
-	TF_USE_DEFAULT_WORKER = 0
-	TF_USE_SYSTEM_THREAD  = 16
-	TF_USE_KERNEL_APC     = 32
-)
-
-type TransmitFileBuffers struct {
-	Head       uintptr
-	HeadLength uint32
-	Tail       uintptr
-	TailLength uint32
-}
-
-const (
-	IFF_UP           = 1
-	IFF_BROADCAST    = 2
-	IFF_LOOPBACK     = 4
-	IFF_POINTTOPOINT = 8
-	IFF_MULTICAST    = 16
-)
-
-const SIO_GET_INTERFACE_LIST = 0x4004747F
-
-// TODO(mattn): SockaddrGen is union of sockaddr/sockaddr_in/sockaddr_in6_old.
-// will be fixed to change variable type as suitable.
-
-type SockaddrGen [24]byte
-
-type InterfaceInfo struct {
-	Flags            uint32
-	Address          SockaddrGen
-	BroadcastAddress SockaddrGen
-	Netmask          SockaddrGen
-}
-
-type IpAddressString struct {
-	String [16]byte
-}
-
-type IpMaskString IpAddressString
-
-type IpAddrString struct {
-	Next      *IpAddrString
-	IpAddress IpAddressString
-	IpMask    IpMaskString
-	Context   uint32
-}
-
-const MAX_ADAPTER_NAME_LENGTH = 256
-const MAX_ADAPTER_DESCRIPTION_LENGTH = 128
-const MAX_ADAPTER_ADDRESS_LENGTH = 8
-
-type IpAdapterInfo struct {
-	Next                *IpAdapterInfo
-	ComboIndex          uint32
-	AdapterName         [MAX_ADAPTER_NAME_LENGTH + 4]byte
-	Description         [MAX_ADAPTER_DESCRIPTION_LENGTH + 4]byte
-	AddressLength       uint32
-	Address             [MAX_ADAPTER_ADDRESS_LENGTH]byte
-	Index               uint32
-	Type                uint32
-	DhcpEnabled         uint32
-	CurrentIpAddress    *IpAddrString
-	IpAddressList       IpAddrString
-	GatewayList         IpAddrString
-	DhcpServer          IpAddrString
-	HaveWins            bool
-	PrimaryWinsServer   IpAddrString
-	SecondaryWinsServer IpAddrString
-	LeaseObtained       int64
-	LeaseExpires        int64
-}
-
-const MAXLEN_PHYSADDR = 8
-const MAX_INTERFACE_NAME_LEN = 256
-const MAXLEN_IFDESCR = 256
-
-type MibIfRow struct {
-	Name            [MAX_INTERFACE_NAME_LEN]uint16
-	Index           uint32
-	Type            uint32
-	Mtu             uint32
-	Speed           uint32
-	PhysAddrLen     uint32
-	PhysAddr        [MAXLEN_PHYSADDR]byte
-	AdminStatus     uint32
-	OperStatus      uint32
-	LastChange      uint32
-	InOctets        uint32
-	InUcastPkts     uint32
-	InNUcastPkts    uint32
-	InDiscards      uint32
-	InErrors        uint32
-	InUnknownProtos uint32
-	OutOctets       uint32
-	OutUcastPkts    uint32
-	OutNUcastPkts   uint32
-	OutDiscards     uint32
-	OutErrors       uint32
-	OutQLen         uint32
-	DescrLen        uint32
-	Descr           [MAXLEN_IFDESCR]byte
-}
+package syscall
diff --git a/src/pkg/syscall/ztypes_windows_amd64.go b/src/pkg/syscall/ztypes_windows_amd64.go
new file mode 100644
index 0000000000..d1008bd03c
--- /dev/null
+++ b/src/pkg/syscall/ztypes_windows_amd64.go
@@ -0,0 +1,5 @@
+// Copyright 2011 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package syscall
