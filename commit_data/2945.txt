commit 3b864e41957d11314baf236eeda1e27c6a91bcf8
Author: Russ Cox <rsc@golang.org>
Date:   Wed Aug 12 13:18:37 2009 -0700

    convert low-level (used by testing) packages to
    whole-package compilation.  new Makefiles,
    tests now in separate package
    
            bytes
            flag
            fmt
            io
            math
            once
            os
            reflect
            strconv
            sync
            time
            utf8
    
    delete import "xxx" in package xxx.
    
    inside package xxx, xxx is not declared
    anymore so s/xxx.//g
    
    delete file and package level forward declarations.
    
    note the new internal_test.go and sync
    and strconv to provide public access to
    internals during testing.  the installed version
    of the package omits that file and thus does
    not open the internals to all clients.
    
    R=r
    OCL=33065
    CL=33097
---
 src/pkg/bytes/Makefile                            |  60 +-----------
 src/pkg/bytes/buffer.go                           |   1 -
 src/pkg/bytes/buffer_test.go                      |   4 +-
 src/pkg/bytes/bytes_test.go                       |   6 +-
 src/pkg/flag/Makefile                             |  57 +----------
 src/pkg/flag/flag.go                              |   2 +-
 src/pkg/flag/flag_test.go                         |  48 ++++-----
 src/pkg/fmt/Makefile                              |  66 +------------
 src/pkg/fmt/fmt_test.go                           |   4 +-
 src/pkg/fmt/print.go                              |   4 -
 src/pkg/io/Makefile                               |  69 ++-----------
 src/pkg/io/pipe.go                                |   1 -
 src/pkg/io/pipe_test.go                           |  13 ++-
 src/pkg/io/utils.go                               |   1 -
 src/pkg/io/utils_test.go                          |   4 +-
 src/pkg/math/Makefile                             | 114 +++++-----------------
 src/pkg/math/all_test.go                          |   4 +-
 src/pkg/math/asin.go                              |   1 -
 src/pkg/math/atan.go                              |   1 -
 src/pkg/math/atan2.go                             |   1 -
 src/pkg/math/exp.go                               |   1 -
 src/pkg/math/floor.go                             |   1 -
 src/pkg/math/fmod.go                              |   1 -
 src/pkg/math/log.go                               |   9 +-
 src/pkg/math/pow.go                               |   1 -
 src/pkg/math/sin.go                               |   1 -
 src/pkg/math/sinh.go                              |   1 -
 src/pkg/math/sqrt.go                              |   1 -
 src/pkg/math/tan.go                               |   1 -
 src/pkg/math/tanh.go                              |   1 -
 src/pkg/once/Makefile                             |  57 +----------
 src/pkg/once/once_test.go                         |   4 +-
 src/pkg/os/Makefile                               | 103 +++----------------
 src/pkg/os/dir_darwin_386.go                      |   7 +-
 src/pkg/os/dir_darwin_amd64.go                    |   2 -
 src/pkg/os/dir_linux_386.go                       |   2 -
 src/pkg/os/dir_linux_amd64.go                     |   2 -
 src/pkg/os/env.go                                 |   1 -
 src/pkg/os/exec.go                                |   1 -
 src/pkg/os/file.go                                |   8 --
 src/pkg/os/getwd.go                               |   1 -
 src/pkg/os/os_test.go                             |   4 +-
 src/pkg/os/path.go                                |   1 -
 src/pkg/os/path_test.go                           |   4 +-
 src/pkg/os/proc.go                                |   1 -
 src/pkg/os/stat_darwin_386.go                     |   3 +-
 src/pkg/os/stat_darwin_amd64.go                   |   3 +-
 src/pkg/os/stat_linux_386.go                      |   5 +-
 src/pkg/os/stat_linux_amd64.go                    |   3 +-
 src/pkg/os/sys_darwin.go                          |   5 +-
 src/pkg/os/sys_linux.go                           |   1 -
 src/pkg/os/time.go                                |   5 +-
 src/pkg/reflect/Makefile                          |  77 ++-------------
 src/pkg/reflect/all_test.go                       |  56 +++++------
 src/pkg/reflect/deepequal.go                      |   1 -
 src/pkg/reflect/{tostring.go => tostring_test.go} |   9 +-
 src/pkg/reflect/type.go                           |   7 --
 src/pkg/reflect/value.go                          |  14 +--
 src/pkg/strconv/Makefile                          |  82 ++--------------
 src/pkg/strconv/atof.go                           |   1 -
 src/pkg/strconv/atof_test.go                      |  30 +++---
 src/pkg/strconv/atoi.go                           |  12 +--
 src/pkg/strconv/atoi_test.go                      |  34 +++----
 src/pkg/strconv/decimal.go                        |  10 --
 src/pkg/strconv/decimal_test.go                   |  19 ++--
 src/pkg/strconv/fp_test.go                        |   3 +-
 src/pkg/strconv/ftoa.go                           |  12 +--
 src/pkg/strconv/ftoa_test.go                      |  14 +--
 src/pkg/strconv/internal_test.go                  |  18 ++++
 src/pkg/strconv/itoa_test.go                      |  52 +++++-----
 src/pkg/strconv/quote_test.go                     |   4 +-
 src/pkg/sync/Makefile                             |  57 +----------
 src/pkg/sync/internal_test.go                     |  15 +++
 src/pkg/sync/mutex_test.go                        |   8 +-
 src/pkg/time/Makefile                             |  77 ++-------------
 src/pkg/time/tick.go                              |   1 -
 src/pkg/time/tick_test.go                         |   4 +-
 src/pkg/time/time.go                              |   1 -
 src/pkg/time/time_test.go                         |   4 +-
 src/pkg/utf8/Makefile                             |  57 +----------
 src/pkg/utf8/utf8_test.go                         |  34 +++----
 81 files changed, 332 insertions(+), 1083 deletions(-)

diff --git a/src/pkg/bytes/Makefile b/src/pkg/bytes/Makefile
index 96071221c6..6d7d113e69 100644
--- a/src/pkg/bytes/Makefile
+++ b/src/pkg/bytes/Makefile
@@ -2,61 +2,11 @@
 # Use of this source code is governed by a BSD-style
 # license that can be found in the LICENSE file.
 
-
-# DO NOT EDIT.  Automatically generated by gobuild.
-# gobuild -m >Makefile
-
-D=
-
 include $(GOROOT)/src/Make.$(GOARCH)
-AR=gopack
-
-default: packages
-
-clean:
-	rm -rf *.[$(OS)] *.a [$(OS)].out _obj
-
-test: packages
-	gotest
-
-coverage: packages
-	gotest
-	6cov -g $$(pwd) | grep -v '_test\.go:'
-
-%.$O: %.go
-	$(GC) -I_obj $*.go
-
-%.$O: %.c
-	$(CC) $*.c
-
-%.$O: %.s
-	$(AS) $*.s
-
-O1=\
-	buffer.$O\
-	bytes.$O\
-
-
-phases: a1
-_obj$D/bytes.a: phases
-
-a1: $(O1)
-	$(AR) grc _obj$D/bytes.a buffer.$O bytes.$O
-	rm -f $(O1)
-
-
-newpkg: clean
-	mkdir -p _obj$D
-	$(AR) grc _obj$D/bytes.a
-
-$(O1): newpkg
-$(O2): a1
-
-nuke: clean
-	rm -f $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/bytes.a
 
-packages: _obj$D/bytes.a
+TARG=bytes
+GOFILES=\
+	buffer.go\
+	bytes.go\
 
-install: packages
-	test -d $(GOROOT)/pkg && mkdir -p $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D
-	cp _obj$D/bytes.a $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/bytes.a
+include $(GOROOT)/src/Make.pkg
diff --git a/src/pkg/bytes/buffer.go b/src/pkg/bytes/buffer.go
index 58e06e9e4d..6c857069b0 100644
--- a/src/pkg/bytes/buffer.go
+++ b/src/pkg/bytes/buffer.go
@@ -7,7 +7,6 @@ package bytes
 // Simple byte buffer for marshaling data.
 
 import (
-	"bytes";
 	"os";
 )
 
diff --git a/src/pkg/bytes/buffer_test.go b/src/pkg/bytes/buffer_test.go
index 76078882c2..4d3fca8727 100644
--- a/src/pkg/bytes/buffer_test.go
+++ b/src/pkg/bytes/buffer_test.go
@@ -2,10 +2,10 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package bytes
+package bytes_test
 
 import (
-	"bytes";
+	. "bytes";
 	"rand";
 	"testing";
 )
diff --git a/src/pkg/bytes/bytes_test.go b/src/pkg/bytes/bytes_test.go
index a3e44262cc..e37767d9a2 100644
--- a/src/pkg/bytes/bytes_test.go
+++ b/src/pkg/bytes/bytes_test.go
@@ -2,10 +2,10 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package bytes
+package bytes_test
 
 import (
-	"bytes";
+	. "bytes";
 	"strings";
 	"testing";
 )
@@ -85,7 +85,7 @@ var explodetests = []ExplodeTest {
 }
 func TestExplode(t *testing.T) {
 	for _, tt := range(explodetests) {
-		a := explode(strings.Bytes(tt.s), tt.n);
+		a := Split(strings.Bytes(tt.s), nil, tt.n);
 		result := arrayOfString(a);
 		if !eq(result, tt.a) {
 			t.Errorf(`Explode("%s", %d) = %v; want %v`, tt.s, tt.n, result, tt.a);
diff --git a/src/pkg/flag/Makefile b/src/pkg/flag/Makefile
index 466e19564c..faa95185ca 100644
--- a/src/pkg/flag/Makefile
+++ b/src/pkg/flag/Makefile
@@ -2,59 +2,10 @@
 # Use of this source code is governed by a BSD-style
 # license that can be found in the LICENSE file.
 
-# DO NOT EDIT.  Automatically generated by gobuild.
-# gobuild -m >Makefile
-
-D=
-
 include $(GOROOT)/src/Make.$(GOARCH)
-AR=gopack
-
-default: packages
-
-clean:
-	rm -rf *.[$(OS)] *.a [$(OS)].out _obj
-
-test: packages
-	gotest
-
-coverage: packages
-	gotest
-	6cov -g `pwd` | grep -v '_test\.go:'
-
-%.$O: %.go
-	$(GC) -I_obj $*.go
-
-%.$O: %.c
-	$(CC) $*.c
-
-%.$O: %.s
-	$(AS) $*.s
-
-O1=\
-	flag.$O\
-
-
-phases: a1
-_obj$D/flag.a: phases
-
-a1: $(O1)
-	$(AR) grc _obj$D/flag.a flag.$O
-	rm -f $(O1)
-
-
-newpkg: clean
-	mkdir -p _obj$D
-	$(AR) grc _obj$D/flag.a
-
-$(O1): newpkg
-$(O2): a1
-
-nuke: clean
-	rm -f $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/flag.a
 
-packages: _obj$D/flag.a
+TARG=flag
+GOFILES=\
+	flag.go\
 
-install: packages
-	test -d $(GOROOT)/pkg && mkdir -p $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D
-	cp _obj$D/flag.a $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/flag.a
+include $(GOROOT)/src/Make.pkg
diff --git a/src/pkg/flag/flag.go b/src/pkg/flag/flag.go
index 7e4f6dc173..9927886435 100644
--- a/src/pkg/flag/flag.go
+++ b/src/pkg/flag/flag.go
@@ -8,7 +8,7 @@
 	Usage:
 
 	1) Define flags using flag.String(), Bool(), Int(), etc. Example:
-		import flag "flag"
+		import "flag"
 		var ip *int = flag.Int("flagname", 1234, "help message for flagname")
 	If you like, you can bind the flag to a variable using the Var() functions.
 		var flagvar int
diff --git a/src/pkg/flag/flag_test.go b/src/pkg/flag/flag_test.go
index 0d83fcf81e..259d507ed7 100644
--- a/src/pkg/flag/flag_test.go
+++ b/src/pkg/flag/flag_test.go
@@ -2,21 +2,21 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package flag
+package flag_test
 
 import (
-	"flag";
+	. "flag";
 	"fmt";
 	"testing";
 )
 
 var (
-	test_bool = flag.Bool("test_bool", false, "bool value");
-	test_int = flag.Int("test_int", 0, "int value");
-	test_int64 = flag.Int64("test_int64", 0, "int64 value");
-	test_uint = flag.Uint("test_uint", 0, "uint value");
-	test_uint64 = flag.Uint64("test_uint64", 0, "uint64 value");
-	test_string = flag.String("test_string", "0", "string value");
+	test_bool = Bool("test_bool", false, "bool value");
+	test_int = Int("test_int", 0, "int value");
+	test_int64 = Int64("test_int64", 0, "int64 value");
+	test_uint = Uint("test_uint", 0, "uint value");
+	test_uint64 = Uint64("test_uint64", 0, "uint64 value");
+	test_string = String("test_string", "0", "string value");
 )
 
 func boolString(s string) string {
@@ -27,9 +27,9 @@ func boolString(s string) string {
 }
 
 func TestEverything(t *testing.T) {
-	m := make(map[string] *flag.Flag);
+	m := make(map[string] *Flag);
 	desired := "0";
-	visitor := func(f *flag.Flag) {
+	visitor := func(f *Flag) {
 		if len(f.Name) > 5 && f.Name[0:5] == "test_" {
 			m[f.Name] = f;
 			ok := false;
@@ -40,36 +40,36 @@ func TestEverything(t *testing.T) {
 				ok = true;
 			}
 			if !ok {
-				t.Error("flag.Visit: bad value", f.Value.String(), "for", f.Name);
+				t.Error("Visit: bad value", f.Value.String(), "for", f.Name);
 			}
 		}
 	};
-	flag.VisitAll(visitor);
+	VisitAll(visitor);
 	if len(m) != 6 {
-		t.Error("flag.VisitAll misses some flags");
+		t.Error("VisitAll misses some flags");
 		for k, v := range m {
 			t.Log(k, *v)
 		}
 	}
-	m = make(map[string] *flag.Flag);
-	flag.Visit(visitor);
+	m = make(map[string] *Flag);
+	Visit(visitor);
 	if len(m) != 0 {
-		t.Errorf("flag.Visit sees unset flags");
+		t.Errorf("Visit sees unset flags");
 		for k, v := range m {
 			t.Log(k, *v)
 		}
 	}
 	// Now set all flags
-	flag.Set("test_bool", "true");
-	flag.Set("test_int", "1");
-	flag.Set("test_int64", "1");
-	flag.Set("test_uint", "1");
-	flag.Set("test_uint64", "1");
-	flag.Set("test_string", "1");
+	Set("test_bool", "true");
+	Set("test_int", "1");
+	Set("test_int64", "1");
+	Set("test_uint", "1");
+	Set("test_uint64", "1");
+	Set("test_string", "1");
 	desired = "1";
-	flag.Visit(visitor);
+	Visit(visitor);
 	if len(m) != 6 {
-		t.Error("flag.Visit fails after set");
+		t.Error("Visit fails after set");
 		for k, v := range m {
 			t.Log(k, *v)
 		}
diff --git a/src/pkg/fmt/Makefile b/src/pkg/fmt/Makefile
index 5d0281a0c3..9273093e89 100644
--- a/src/pkg/fmt/Makefile
+++ b/src/pkg/fmt/Makefile
@@ -2,67 +2,11 @@
 # Use of this source code is governed by a BSD-style
 # license that can be found in the LICENSE file.
 
-# DO NOT EDIT.  Automatically generated by gobuild.
-# gobuild -m >Makefile
-
-D=
-
 include $(GOROOT)/src/Make.$(GOARCH)
-AR=gopack
-
-default: packages
-
-clean:
-	rm -rf *.[$(OS)] *.a [$(OS)].out _obj
-
-test: packages
-	gotest
-
-coverage: packages
-	gotest
-	6cov -g `pwd` | grep -v '_test\.go:'
-
-%.$O: %.go
-	$(GC) -I_obj $*.go
-
-%.$O: %.c
-	$(CC) $*.c
-
-%.$O: %.s
-	$(AS) $*.s
-
-O1=\
-	format.$O\
-
-O2=\
-	print.$O\
-
-
-phases: a1 a2
-_obj$D/fmt.a: phases
-
-a1: $(O1)
-	$(AR) grc _obj$D/fmt.a format.$O
-	rm -f $(O1)
-
-a2: $(O2)
-	$(AR) grc _obj$D/fmt.a print.$O
-	rm -f $(O2)
-
-
-newpkg: clean
-	mkdir -p _obj$D
-	$(AR) grc _obj$D/fmt.a
-
-$(O1): newpkg
-$(O2): a1
-$(O3): a2
-
-nuke: clean
-	rm -f $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/fmt.a
 
-packages: _obj$D/fmt.a
+TARG=fmt
+GOFILES=\
+	format.go\
+	print.go\
 
-install: packages
-	test -d $(GOROOT)/pkg && mkdir -p $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D
-	cp _obj$D/fmt.a $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/fmt.a
+include $(GOROOT)/src/Make.pkg
diff --git a/src/pkg/fmt/fmt_test.go b/src/pkg/fmt/fmt_test.go
index 9d772e1bef..76234e552b 100644
--- a/src/pkg/fmt/fmt_test.go
+++ b/src/pkg/fmt/fmt_test.go
@@ -2,10 +2,10 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package fmt
+package fmt_test
 
 import (
-	"fmt";
+	. "fmt";
 	"io";
 	"math";
 	"strings";
diff --git a/src/pkg/fmt/print.go b/src/pkg/fmt/print.go
index 86a09879e5..bb1030e726 100644
--- a/src/pkg/fmt/print.go
+++ b/src/pkg/fmt/print.go
@@ -74,7 +74,6 @@ package fmt
 
 
 import (
-	"fmt";
 	"io";
 	"os";
 	"reflect";
@@ -198,9 +197,6 @@ func (p *pp) Write(b []byte) (ret int, err os.Error) {
 	return len(b), nil;
 }
 
-func (p *pp) doprintf(format string, v *reflect.StructValue);
-func (p *pp) doprint(v *reflect.StructValue, addspace, addnewline bool);
-
 // These routines end in 'f' and take a format string.
 
 // Fprintf formats according to a format specifier and writes to w.
diff --git a/src/pkg/io/Makefile b/src/pkg/io/Makefile
index eb3a966ad0..bf124f4549 100644
--- a/src/pkg/io/Makefile
+++ b/src/pkg/io/Makefile
@@ -2,69 +2,12 @@
 # Use of this source code is governed by a BSD-style
 # license that can be found in the LICENSE file.
 
-
-# DO NOT EDIT.  Automatically generated by gobuild.
-# gobuild -m >Makefile
-
-D=
-
 include $(GOROOT)/src/Make.$(GOARCH)
-AR=gopack
-
-default: packages
-
-clean:
-	rm -rf *.[$(OS)] *.a [$(OS)].out _obj
-
-test: packages
-	gotest
-
-coverage: packages
-	gotest
-	6cov -g $$(pwd) | grep -v '_test\.go:'
-
-%.$O: %.go
-	$(GC) -I_obj $*.go
-
-%.$O: %.c
-	$(CC) $*.c
-
-%.$O: %.s
-	$(AS) $*.s
-
-O1=\
-	io.$O\
-	pipe.$O\
-
-O2=\
-	utils.$O\
-
-
-phases: a1 a2
-_obj$D/io.a: phases
-
-a1: $(O1)
-	$(AR) grc _obj$D/io.a io.$O pipe.$O
-	rm -f $(O1)
-
-a2: $(O2)
-	$(AR) grc _obj$D/io.a utils.$O
-	rm -f $(O2)
-
-
-newpkg: clean
-	mkdir -p _obj$D
-	$(AR) grc _obj$D/io.a
-
-$(O1): newpkg
-$(O2): a1
-$(O3): a2
-
-nuke: clean
-	rm -f $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/io.a
 
-packages: _obj$D/io.a
+TARG=io
+GOFILES=\
+	io.go\
+	pipe.go\
+	utils.go\
 
-install: packages
-	test -d $(GOROOT)/pkg && mkdir -p $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D
-	cp _obj$D/io.a $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/io.a
+include $(GOROOT)/src/Make.pkg
diff --git a/src/pkg/io/pipe.go b/src/pkg/io/pipe.go
index 729094fde3..151f3ca68e 100644
--- a/src/pkg/io/pipe.go
+++ b/src/pkg/io/pipe.go
@@ -8,7 +8,6 @@
 package io
 
 import (
-	"io";
 	"os";
 	"sync";
 )
diff --git a/src/pkg/io/pipe_test.go b/src/pkg/io/pipe_test.go
index 6b36cc6fcb..f936376973 100644
--- a/src/pkg/io/pipe_test.go
+++ b/src/pkg/io/pipe_test.go
@@ -2,11 +2,11 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package io
+package io_test
 
 import (
 	"fmt";
-	"io";
+	. "io";
 	"os";
 	"strings";
 	"testing";
@@ -84,6 +84,11 @@ func TestPipe2(t *testing.T) {
 	}
 }
 
+type pipeReturn struct {
+	n int;
+	err os.Error;
+}
+
 // Test a large write that requires multiple reads to satisfy.
 func writer(w WriteCloser, buf []byte, c chan pipeReturn) {
 	n, err := w.Write(buf);
@@ -156,10 +161,10 @@ func (p pipeTest) String() string {
 var pipeTests = []pipeTest {
 	pipeTest{ true, nil, false },
 	pipeTest{ true, nil, true },
-	pipeTest{ true, io.ErrShortWrite, true },
+	pipeTest{ true, ErrShortWrite, true },
 	pipeTest{ false, nil, false },
 	pipeTest{ false, nil, true },
-	pipeTest{ false, io.ErrShortWrite, true },
+	pipeTest{ false, ErrShortWrite, true },
 }
 
 func delayClose(t *testing.T, cl closer, ch chan int, tt pipeTest) {
diff --git a/src/pkg/io/utils.go b/src/pkg/io/utils.go
index 23acfb4ef1..45dd5f9a4c 100644
--- a/src/pkg/io/utils.go
+++ b/src/pkg/io/utils.go
@@ -8,7 +8,6 @@ package io
 
 import (
 	"bytes";
-	"io";
 	"os";
 )
 
diff --git a/src/pkg/io/utils_test.go b/src/pkg/io/utils_test.go
index 4538337436..a16a40b574 100644
--- a/src/pkg/io/utils_test.go
+++ b/src/pkg/io/utils_test.go
@@ -2,10 +2,10 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package io
+package io_test
 
 import (
-	"io";
+	. "io";
 	"os";
 	"strings";
 	"testing";
diff --git a/src/pkg/math/Makefile b/src/pkg/math/Makefile
index 058049072f..f062a7468b 100644
--- a/src/pkg/math/Makefile
+++ b/src/pkg/math/Makefile
@@ -2,97 +2,27 @@
 # Use of this source code is governed by a BSD-style
 # license that can be found in the LICENSE file.
 
-# DO NOT EDIT.  Automatically generated by gobuild.
-# gobuild -m >Makefile
-
-D=
-
 include $(GOROOT)/src/Make.$(GOARCH)
-AR=gopack
-
-default: packages
-
-clean:
-	rm -rf *.[$(OS)] *.a [$(OS)].out _obj
-
-test: packages
-	gotest
-
-coverage: packages
-	gotest
-	6cov -g `pwd` | grep -v '_test\.go:'
-
-%.$O: %.go
-	$(GC) -I_obj $*.go
-
-%.$O: %.c
-	$(CC) $*.c
-
-%.$O: %.s
-	$(AS) $*.s
-
-O1=\
-	const.$O\
-	fabs.$O\
-	hypot.$O\
-	pow10.$O\
-	runtime.$O\
-
-O2=\
-	atan.$O\
-	exp.$O\
-	floor.$O\
-	fmod.$O\
-	log.$O\
-	sin.$O\
-	sqrt.$O\
-	tan.$O\
-
-O3=\
-	asin.$O\
-	atan2.$O\
-	pow.$O\
-	sinh.$O\
-
-O4=\
-	tanh.$O\
-
-
-phases: a1 a2 a3 a4
-_obj$D/math.a: phases
-
-a1: $(O1)
-	$(AR) grc _obj$D/math.a const.$O fabs.$O hypot.$O pow10.$O runtime.$O
-	rm -f $(O1)
-
-a2: $(O2)
-	$(AR) grc _obj$D/math.a atan.$O exp.$O floor.$O fmod.$O log.$O sin.$O sqrt.$O tan.$O
-	rm -f $(O2)
-
-a3: $(O3)
-	$(AR) grc _obj$D/math.a asin.$O atan2.$O pow.$O sinh.$O
-	rm -f $(O3)
-
-a4: $(O4)
-	$(AR) grc _obj$D/math.a tanh.$O
-	rm -f $(O4)
-
-
-newpkg: clean
-	mkdir -p _obj$D
-	$(AR) grc _obj$D/math.a
-
-$(O1): newpkg
-$(O2): a1
-$(O3): a2
-$(O4): a3
-$(O5): a4
-
-nuke: clean
-	rm -f $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/math.a
-
-packages: _obj$D/math.a
 
-install: packages
-	test -d $(GOROOT)/pkg && mkdir -p $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D
-	cp _obj$D/math.a $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/math.a
+TARG=math
+GOFILES=\
+	asin.go\
+	atan.go\
+	atan2.go\
+	const.go\
+	exp.go\
+	fabs.go\
+	floor.go\
+	fmod.go\
+	hypot.go\
+	log.go\
+	pow.go\
+	pow10.go\
+	runtime.go\
+	sin.go\
+	sinh.go\
+	sqrt.go\
+	tan.go\
+	tanh.go\
+
+include $(GOROOT)/src/Make.pkg
diff --git a/src/pkg/math/all_test.go b/src/pkg/math/all_test.go
index 8973d456ec..9a7075899e 100644
--- a/src/pkg/math/all_test.go
+++ b/src/pkg/math/all_test.go
@@ -2,10 +2,10 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package math
+package math_test
 
 import (
-	"math";
+	. "math";
 	"testing";
 )
 
diff --git a/src/pkg/math/asin.go b/src/pkg/math/asin.go
index 23c9a1069b..38fc365b35 100644
--- a/src/pkg/math/asin.go
+++ b/src/pkg/math/asin.go
@@ -4,7 +4,6 @@
 
 package math
 
-import "math"
 
 /*
  * asin(arg) and acos(arg) return the arcsin, arccos,
diff --git a/src/pkg/math/atan.go b/src/pkg/math/atan.go
index 4b18f76aaf..bc13b3bfae 100644
--- a/src/pkg/math/atan.go
+++ b/src/pkg/math/atan.go
@@ -4,7 +4,6 @@
 
 package math
 
-import "math"
 
 /*
  *	floating-point arctangent
diff --git a/src/pkg/math/atan2.go b/src/pkg/math/atan2.go
index 72f2117b37..efd5cb9268 100644
--- a/src/pkg/math/atan2.go
+++ b/src/pkg/math/atan2.go
@@ -4,7 +4,6 @@
 
 package math
 
-import "math"
 
 // Atan returns the arc tangent of y/x, using
 // the signs of the two to determine the quadrant
diff --git a/src/pkg/math/exp.go b/src/pkg/math/exp.go
index a32c7e1d50..22014daace 100644
--- a/src/pkg/math/exp.go
+++ b/src/pkg/math/exp.go
@@ -4,7 +4,6 @@
 
 package math
 
-import "math"
 
 // The original C code, the long comment, and the constants
 // below are from FreeBSD's /usr/src/lib/msun/src/e_exp.c
diff --git a/src/pkg/math/floor.go b/src/pkg/math/floor.go
index 48a1003f04..1580221ab6 100644
--- a/src/pkg/math/floor.go
+++ b/src/pkg/math/floor.go
@@ -4,7 +4,6 @@
 
 package math
 
-import "math"
 
 // Floor returns the greatest integer value less than or equal to x.
 func Floor(x float64) float64 {
diff --git a/src/pkg/math/fmod.go b/src/pkg/math/fmod.go
index 617f5408bb..681c921bb9 100644
--- a/src/pkg/math/fmod.go
+++ b/src/pkg/math/fmod.go
@@ -4,7 +4,6 @@
 
 package math
 
-import "math"
 
 /*
  *	floating-point mod func without infinity or NaN checking
diff --git a/src/pkg/math/log.go b/src/pkg/math/log.go
index 603a935acd..4f9a376062 100644
--- a/src/pkg/math/log.go
+++ b/src/pkg/math/log.go
@@ -4,7 +4,6 @@
 
 package math
 
-import "math"
 
 // The original C code, the long comment, and the constants
 // below are from FreeBSD's /usr/src/lib/msun/src/e_log.c
@@ -33,19 +32,17 @@ import "math"
 //		 = 2s + 2/3 s**3 + 2/5 s**5 + .....,
 //	     	 = 2s + s*R
 //      We use a special Reme algorithm on [0,0.1716] to generate
-// 	a polynomial of degree 14 to approximate R The maximum error
+//	a polynomial of degree 14 to approximate R.  The maximum error
 //	of this polynomial approximation is bounded by 2**-58.45. In
 //	other words,
 //		        2      4      6      8      10      12      14
 //	    R(z) ~ L1*s +L2*s +L3*s +L4*s +L5*s  +L6*s  +L7*s
-//  	(the values of L1 to L7 are listed in the program)
-//	and
+//	(the values of L1 to L7 are listed in the program) and
 //	    |      2          14          |     -58.45
 //	    | L1*s +...+L7*s    -  R(z) | <= 2
 //	    |                             |
 //	Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2.
-//	In order to guarantee error in log below 1ulp, we compute log
-//	by
+//	In order to guarantee error in log below 1ulp, we compute log by
 //		log(1+f) = f - s*(f - R)	(if f is not too large)
 //		log(1+f) = f - (hfsq - s*(hfsq+R)).	(better accuracy)
 //
diff --git a/src/pkg/math/pow.go b/src/pkg/math/pow.go
index 920d210b56..93f4fa8e9d 100644
--- a/src/pkg/math/pow.go
+++ b/src/pkg/math/pow.go
@@ -4,7 +4,6 @@
 
 package math
 
-import "math"
 
 // Pow returns x**y, the base-x exponential of y.
 func Pow(x, y float64) float64 {
diff --git a/src/pkg/math/sin.go b/src/pkg/math/sin.go
index 0c26a767b7..8f0959ab08 100644
--- a/src/pkg/math/sin.go
+++ b/src/pkg/math/sin.go
@@ -4,7 +4,6 @@
 
 package math
 
-import "math"
 
 func sinus(x float64, quad int) float64 {
 	// Coefficients are #3370 from Hart & Cheney (18.80D).
diff --git a/src/pkg/math/sinh.go b/src/pkg/math/sinh.go
index ef70989fb9..1e55f0ba58 100644
--- a/src/pkg/math/sinh.go
+++ b/src/pkg/math/sinh.go
@@ -4,7 +4,6 @@
 
 package math
 
-import "math"
 
 /*
  *	Sinh(x) returns the hyperbolic sine of x
diff --git a/src/pkg/math/sqrt.go b/src/pkg/math/sqrt.go
index 79384f6481..09bdf6b4c7 100644
--- a/src/pkg/math/sqrt.go
+++ b/src/pkg/math/sqrt.go
@@ -4,7 +4,6 @@
 
 package math
 
-import "math"
 
 /*
  *	sqrt returns the square root of its floating
diff --git a/src/pkg/math/tan.go b/src/pkg/math/tan.go
index ee6dfbe40a..a8e6b15c91 100644
--- a/src/pkg/math/tan.go
+++ b/src/pkg/math/tan.go
@@ -4,7 +4,6 @@
 
 package math
 
-import "math"
 
 /*
  *	floating point tangent
diff --git a/src/pkg/math/tanh.go b/src/pkg/math/tanh.go
index 18d38ae8fe..20dc5b79d0 100644
--- a/src/pkg/math/tanh.go
+++ b/src/pkg/math/tanh.go
@@ -4,7 +4,6 @@
 
 package math
 
-import "math"
 
 /*
  *	tanh(x) computes the hyperbolic tangent of its floating
diff --git a/src/pkg/once/Makefile b/src/pkg/once/Makefile
index 6350402c2e..f83250b543 100644
--- a/src/pkg/once/Makefile
+++ b/src/pkg/once/Makefile
@@ -2,59 +2,10 @@
 # Use of this source code is governed by a BSD-style
 # license that can be found in the LICENSE file.
 
-# DO NOT EDIT.  Automatically generated by gobuild.
-# gobuild -m >Makefile
-
-D=
-
 include $(GOROOT)/src/Make.$(GOARCH)
-AR=gopack
-
-default: packages
-
-clean:
-	rm -rf *.[$(OS)] *.a [$(OS)].out _obj
-
-test: packages
-	gotest
-
-coverage: packages
-	gotest
-	6cov -g `pwd` | grep -v '_test\.go:'
-
-%.$O: %.go
-	$(GC) -I_obj $*.go
-
-%.$O: %.c
-	$(CC) $*.c
-
-%.$O: %.s
-	$(AS) $*.s
-
-O1=\
-	once.$O\
-
-
-phases: a1
-_obj$D/once.a: phases
-
-a1: $(O1)
-	$(AR) grc _obj$D/once.a once.$O
-	rm -f $(O1)
-
-
-newpkg: clean
-	mkdir -p _obj$D
-	$(AR) grc _obj$D/once.a
-
-$(O1): newpkg
-$(O2): a1
-
-nuke: clean
-	rm -f $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/once.a
 
-packages: _obj$D/once.a
+TARG=once
+GOFILES=\
+	once.go\
 
-install: packages
-	test -d $(GOROOT)/pkg && mkdir -p $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D
-	cp _obj$D/once.a $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/once.a
+include $(GOROOT)/src/Make.pkg
diff --git a/src/pkg/once/once_test.go b/src/pkg/once/once_test.go
index 9506ff3d79..749805aead 100644
--- a/src/pkg/once/once_test.go
+++ b/src/pkg/once/once_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package once
+package once_test
 
 import (
 	"once";
@@ -14,7 +14,7 @@ func call() {
 	ncall++
 }
 
-func TestOnce(t *testing.T) {
+func TestDo(t *testing.T) {
 	ncall = 0;
 	once.Do(call);
 	if ncall != 1 {
diff --git a/src/pkg/os/Makefile b/src/pkg/os/Makefile
index bb2559e868..323be5edb7 100644
--- a/src/pkg/os/Makefile
+++ b/src/pkg/os/Makefile
@@ -2,92 +2,21 @@
 # Use of this source code is governed by a BSD-style
 # license that can be found in the LICENSE file.
 
-
-# DO NOT EDIT.  Automatically generated by gobuild.
-# gobuild -m dir_${GOOS}_${GOARCH}.go env.go error.go file.go path.go stat_${GOOS}_${GOARCH}.go time.go types.go exec.go proc.go getwd.go sys_${GOOS}.go >Makefile
-
-D=
-
 include $(GOROOT)/src/Make.$(GOARCH)
-AR=gopack
-
-default: packages
-
-clean:
-	rm -rf *.[$(OS)] *.a [$(OS)].out _obj
-
-test: packages
-	gotest
-
-coverage: packages
-	gotest
-	6cov -g $$(pwd) | grep -v '_test\.go:'
-
-%.$O: %.go
-	$(GC) -I_obj $*.go
-
-%.$O: %.c
-	$(CC) $*.c
-
-%.$O: %.s
-	$(AS) $*.s
-
-O1=\
-	error.$O\
-	types.$O\
-
-O2=\
-	proc.$O\
-	stat_$(GOOS)_$(GOARCH).$O\
-	time.$O\
-
-O3=\
-	env.$O\
-	file.$O\
-
-O4=\
-	dir_$(GOOS)_$(GOARCH).$O\
-	exec.$O\
-	getwd.$O\
-	path.$O\
-	sys_$(GOOS).$O\
-
-
-phases: a1 a2 a3 a4
-_obj$D/os.a: phases
-
-a1: $(O1)
-	$(AR) grc _obj$D/os.a error.$O types.$O
-	rm -f $(O1)
-
-a2: $(O2)
-	$(AR) grc _obj$D/os.a proc.$O stat_$(GOOS)_$(GOARCH).$O time.$O
-	rm -f $(O2)
-
-a3: $(O3)
-	$(AR) grc _obj$D/os.a env.$O file.$O
-	rm -f $(O3)
-
-a4: $(O4)
-	$(AR) grc _obj$D/os.a dir_$(GOOS)_$(GOARCH).$O exec.$O getwd.$O path.$O sys_$(GOOS).$O
-	rm -f $(O4)
-
-
-newpkg: clean
-	mkdir -p _obj$D
-	$(AR) grc _obj$D/os.a
-
-$(O1): newpkg
-$(O2): a1
-$(O3): a2
-$(O4): a3
-$(O5): a4
-
-nuke: clean
-	rm -f $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/os.a
-
-packages: _obj$D/os.a
 
-install: packages
-	test -d $(GOROOT)/pkg && mkdir -p $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D
-	cp _obj$D/os.a $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/os.a
+TARG=os
+GOFILES=\
+	dir_$(GOOS)_$(GOARCH).go\
+	env.go\
+	error.go\
+	exec.go\
+	file.go\
+	getwd.go\
+	path.go\
+	proc.go\
+	stat_$(GOOS)_$(GOARCH).go\
+	sys_$(GOOS).go\
+	time.go\
+	types.go\
+
+include $(GOROOT)/src/Make.pkg
diff --git a/src/pkg/os/dir_darwin_386.go b/src/pkg/os/dir_darwin_386.go
index 8ae6ba70fb..0131ab1b06 100644
--- a/src/pkg/os/dir_darwin_386.go
+++ b/src/pkg/os/dir_darwin_386.go
@@ -5,7 +5,6 @@
 package os
 
 import (
-	"os";
 	"syscall";
 	"unsafe";
 )
@@ -14,7 +13,11 @@ const (
 	blockSize = 4096	// TODO(r): use statfs
 )
 
-// Negative count means read until EOF.
+// Readdirnames reads the contents of the directory associated with file and
+// returns an array of up to count names, in directory order.  Subsequent
+// calls on the same file will yield further names.
+// A negative count means to read until EOF.
+// Readdirnames returns the array and an Error, if any.
 func (file *File) Readdirnames(count int) (names []string, err Error) {
 	// If this file has no dirinfo, create one.
 	if file.dirinfo == nil {
diff --git a/src/pkg/os/dir_darwin_amd64.go b/src/pkg/os/dir_darwin_amd64.go
index 8ae6ba70fb..7701b7d0db 100644
--- a/src/pkg/os/dir_darwin_amd64.go
+++ b/src/pkg/os/dir_darwin_amd64.go
@@ -5,7 +5,6 @@
 package os
 
 import (
-	"os";
 	"syscall";
 	"unsafe";
 )
@@ -14,7 +13,6 @@ const (
 	blockSize = 4096	// TODO(r): use statfs
 )
 
-// Negative count means read until EOF.
 func (file *File) Readdirnames(count int) (names []string, err Error) {
 	// If this file has no dirinfo, create one.
 	if file.dirinfo == nil {
diff --git a/src/pkg/os/dir_linux_386.go b/src/pkg/os/dir_linux_386.go
index 9b9a1763e8..0e70f0ba07 100644
--- a/src/pkg/os/dir_linux_386.go
+++ b/src/pkg/os/dir_linux_386.go
@@ -9,7 +9,6 @@
 package os
 
 import (
-	"os";
 	"syscall";
 	"unsafe";
 )
@@ -27,7 +26,6 @@ func clen(n []byte) int {
 	return len(n)
 }
 
-// Negative count means read until EOF.
 func (file *File) Readdirnames(count int) (names []string, err Error) {
 	// If this file has no dirinfo, create one.
 	if file.dirinfo == nil {
diff --git a/src/pkg/os/dir_linux_amd64.go b/src/pkg/os/dir_linux_amd64.go
index c0a7ee8b7d..8bd29b27c9 100644
--- a/src/pkg/os/dir_linux_amd64.go
+++ b/src/pkg/os/dir_linux_amd64.go
@@ -5,7 +5,6 @@
 package os
 
 import (
-	"os";
 	"syscall";
 	"unsafe";
 )
@@ -23,7 +22,6 @@ func clen(n []byte) int {
 	return len(n)
 }
 
-// Negative count means read until EOF.
 func (file *File) Readdirnames(count int) (names []string, err Error) {
 	// If this file has no dirinfo, create one.
 	if file.dirinfo == nil {
diff --git a/src/pkg/os/env.go b/src/pkg/os/env.go
index 5515dae2f5..b867cb5648 100644
--- a/src/pkg/os/env.go
+++ b/src/pkg/os/env.go
@@ -8,7 +8,6 @@ package os
 
 import (
 	"once";
-	"os";
 )
 
 // ENOENV is the Error indicating that an environment variable does not exist.
diff --git a/src/pkg/os/exec.go b/src/pkg/os/exec.go
index d9f7d2a570..3a305243ca 100644
--- a/src/pkg/os/exec.go
+++ b/src/pkg/os/exec.go
@@ -5,7 +5,6 @@
 package os
 
 import (
-	"os";
 	"syscall";
 )
 
diff --git a/src/pkg/os/file.go b/src/pkg/os/file.go
index b2b456429c..958a8230c6 100644
--- a/src/pkg/os/file.go
+++ b/src/pkg/os/file.go
@@ -7,7 +7,6 @@
 package os
 
 import (
-	"os";
 	"syscall";
 )
 
@@ -257,13 +256,6 @@ func Lstat(name string) (dir *Dir, err Error) {
 	return dirFromStat(name, new(Dir), &stat, &stat), nil
 }
 
-// Readdirnames reads the contents of the directory associated with file and
-// returns an array of up to count names, in directory order.  Subsequent
-// calls on the same file will yield further names.
-// A negative count means to read until EOF.
-// Readdirnames returns the array and an Error, if any.
-func (file *File) Readdirnames(count int) (names []string, err Error)
-
 // Readdir reads the contents of the directory associated with file and
 // returns an array of up to count Dir structures, as would be returned
 // by Stat, in directory order.  Subsequent calls on the same file will yield further Dirs.
diff --git a/src/pkg/os/getwd.go b/src/pkg/os/getwd.go
index 5b1b4e2e28..5aeeaa0c3a 100644
--- a/src/pkg/os/getwd.go
+++ b/src/pkg/os/getwd.go
@@ -5,7 +5,6 @@
 package os
 
 import (
-	"os";
 	"syscall"
 )
 
diff --git a/src/pkg/os/os_test.go b/src/pkg/os/os_test.go
index a10a6af72e..84c4d15a01 100644
--- a/src/pkg/os/os_test.go
+++ b/src/pkg/os/os_test.go
@@ -2,13 +2,13 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package os
+package os_test
 
 import (
 	"bytes";
 	"fmt";
 	"io";
-	"os";
+	. "os";
 	"strings";
 	"testing";
 )
diff --git a/src/pkg/os/path.go b/src/pkg/os/path.go
index 8499ec9600..a1718b5a3d 100644
--- a/src/pkg/os/path.go
+++ b/src/pkg/os/path.go
@@ -4,7 +4,6 @@
 
 package os
 
-import "os"
 
 // MkdirAll creates a directory named path,
 // along with any necessary parents, and returns nil,
diff --git a/src/pkg/os/path_test.go b/src/pkg/os/path_test.go
index 357d6882f3..2790d98931 100644
--- a/src/pkg/os/path_test.go
+++ b/src/pkg/os/path_test.go
@@ -2,10 +2,10 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package os
+package os_test
 
 import (
-	"os";
+	. "os";
 	"testing";
 )
 
diff --git a/src/pkg/os/proc.go b/src/pkg/os/proc.go
index 38380c1e3a..39d5515bac 100644
--- a/src/pkg/os/proc.go
+++ b/src/pkg/os/proc.go
@@ -8,7 +8,6 @@ package os
 
 import (
 	"syscall";
-	"os";
 	"unsafe";
 )
 
diff --git a/src/pkg/os/stat_darwin_386.go b/src/pkg/os/stat_darwin_386.go
index a6d7b78d15..cc6e549666 100644
--- a/src/pkg/os/stat_darwin_386.go
+++ b/src/pkg/os/stat_darwin_386.go
@@ -6,8 +6,7 @@
 
 package os
 
-import syscall "syscall"
-import os "os"
+import "syscall"
 
 func isSymlink(stat *syscall.Stat_t) bool {
 	return stat.Mode & syscall.S_IFMT == syscall.S_IFLNK
diff --git a/src/pkg/os/stat_darwin_amd64.go b/src/pkg/os/stat_darwin_amd64.go
index 1771ca160b..c6f031a244 100644
--- a/src/pkg/os/stat_darwin_amd64.go
+++ b/src/pkg/os/stat_darwin_amd64.go
@@ -6,8 +6,7 @@
 
 package os
 
-import syscall "syscall"
-import os "os"
+import "syscall"
 
 func isSymlink(stat *syscall.Stat_t) bool {
 	return stat.Mode & syscall.S_IFMT == syscall.S_IFLNK
diff --git a/src/pkg/os/stat_linux_386.go b/src/pkg/os/stat_linux_386.go
index 13ee942c97..d08fabcc60 100644
--- a/src/pkg/os/stat_linux_386.go
+++ b/src/pkg/os/stat_linux_386.go
@@ -10,10 +10,7 @@
 
 package os
 
-import (
-	"os";
-	"syscall";
-)
+import "syscall"
 
 func isSymlink(stat *syscall.Stat_t) bool {
 	return stat.Mode & syscall.S_IFMT == syscall.S_IFLNK
diff --git a/src/pkg/os/stat_linux_amd64.go b/src/pkg/os/stat_linux_amd64.go
index 9b30181784..f4c300b2c8 100644
--- a/src/pkg/os/stat_linux_amd64.go
+++ b/src/pkg/os/stat_linux_amd64.go
@@ -6,8 +6,7 @@
 
 package os
 
-import syscall "syscall"
-import os "os"
+import "syscall"
 
 func isSymlink(stat *syscall.Stat_t) bool {
 	return stat.Mode & syscall.S_IFMT == syscall.S_IFLNK
diff --git a/src/pkg/os/sys_darwin.go b/src/pkg/os/sys_darwin.go
index 731709dfcc..fb57f1733b 100644
--- a/src/pkg/os/sys_darwin.go
+++ b/src/pkg/os/sys_darwin.go
@@ -6,10 +6,7 @@
 
 package os
 
-import (
-	"os";
-	"syscall";
-)
+import "syscall"
 
 func Hostname() (name string, err Error) {
 	var errno int;
diff --git a/src/pkg/os/sys_linux.go b/src/pkg/os/sys_linux.go
index 6ff4e014fb..12a99dff32 100644
--- a/src/pkg/os/sys_linux.go
+++ b/src/pkg/os/sys_linux.go
@@ -6,7 +6,6 @@
 
 package os
 
-import "os"
 
 // Hostname returns the host name reported by the kernel.
 func Hostname() (name string, err Error) {
diff --git a/src/pkg/os/time.go b/src/pkg/os/time.go
index e1022066fd..d0ba6e1fa5 100644
--- a/src/pkg/os/time.go
+++ b/src/pkg/os/time.go
@@ -4,10 +4,7 @@
 
 package os
 
-import (
-	"os";
-	"syscall"
-)
+import "syscall"
 
 
 // Time returns the current time, in whole seconds and
diff --git a/src/pkg/reflect/Makefile b/src/pkg/reflect/Makefile
index 32c3509032..9e9ea3ad6e 100644
--- a/src/pkg/reflect/Makefile
+++ b/src/pkg/reflect/Makefile
@@ -2,77 +2,12 @@
 # Use of this source code is governed by a BSD-style
 # license that can be found in the LICENSE file.
 
-
-# DO NOT EDIT.  Automatically generated by gobuild.
-# gobuild -m >Makefile
-
-D=
-
 include $(GOROOT)/src/Make.$(GOARCH)
-AR=gopack
-
-default: packages
-
-clean:
-	rm -rf *.[$(OS)] *.a [$(OS)].out _obj
-
-test: packages
-	gotest
-
-coverage: packages
-	gotest
-	6cov -g $$(pwd) | grep -v '_test\.go:'
-
-%.$O: %.go
-	$(GC) -I_obj $*.go
-
-%.$O: %.c
-	$(CC) $*.c
-
-%.$O: %.s
-	$(AS) $*.s
-
-O1=\
-	type.$O\
-
-O2=\
-	value.$O\
-
-O3=\
-	deepequal.$O\
-	tostring.$O\
-
-
-phases: a1 a2 a3
-_obj$D/reflect.a: phases
-
-a1: $(O1)
-	$(AR) grc _obj$D/reflect.a type.$O
-	rm -f $(O1)
-
-a2: $(O2)
-	$(AR) grc _obj$D/reflect.a value.$O
-	rm -f $(O2)
-
-a3: $(O3)
-	$(AR) grc _obj$D/reflect.a deepequal.$O tostring.$O
-	rm -f $(O3)
-
-
-newpkg: clean
-	mkdir -p _obj$D
-	$(AR) grc _obj$D/reflect.a
-
-$(O1): newpkg
-$(O2): a1
-$(O3): a2
-$(O4): a3
-
-nuke: clean
-	rm -f $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/reflect.a
 
-packages: _obj$D/reflect.a
+TARG=reflect
+GOFILES=\
+	deepequal.go\
+	type.go\
+	value.go\
 
-install: packages
-	test -d $(GOROOT)/pkg && mkdir -p $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D
-	cp _obj$D/reflect.a $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/reflect.a
+include $(GOROOT)/src/Make.pkg
diff --git a/src/pkg/reflect/all_test.go b/src/pkg/reflect/all_test.go
index 297c95e396..6aa54e01ce 100644
--- a/src/pkg/reflect/all_test.go
+++ b/src/pkg/reflect/all_test.go
@@ -2,12 +2,12 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package reflect
+package reflect_test
 
 import (
 	"io";
 	"os";
-	"reflect";
+	. "reflect";
 	"testing";
 	"unsafe";
 )
@@ -50,14 +50,14 @@ var typeTests = []pair {
 	pair { struct { x float64 }{}, "float64" },
 	pair { struct { x int8 }{}, "int8" },
 	pair { struct { x (**int8) }{}, "**int8" },
-	pair { struct { x (**reflect.integer) }{}, "**reflect.integer" },
+	pair { struct { x (**integer) }{}, "**reflect_test.integer" },
 	pair { struct { x ([32]int32) }{}, "[32]int32" },
 	pair { struct { x ([]int8) }{}, "[]int8" },
 	pair { struct { x (map[string]int32) }{}, "map[string] int32" },
 	pair { struct { x (chan<-string) }{}, "chan<- string" },
 	pair { struct { x struct {c chan *int32; d float32} }{}, "struct { c chan *int32; d float32 }" },
 	pair { struct { x (func(a int8, b int32)) }{}, "func(int8, int32)" },
-	pair { struct { x struct {c func(chan *reflect.integer, *int8)} }{}, "struct { c func(chan *reflect.integer, *int8) }" },
+	pair { struct { x struct {c func(chan *integer, *int8)} }{}, "struct { c func(chan *reflect_test.integer, *int8) }" },
 	pair { struct { x struct {a int8; b int32} }{}, "struct { a int8; b int32 }" },
 	pair { struct { x struct {a int8; b int8; c int32} }{}, "struct { a int8; b int8; c int32 }" },
 	pair { struct { x struct {a int8; b int8; c int8; d int32} }{}, "struct { a int8; b int8; c int8; d int32 }" },
@@ -85,12 +85,12 @@ var valueTests = []pair {
 	pair { (*int8)(nil), "*int8(0)" },
 	pair { (**int8)(nil), "**int8(0)" },
 	pair { ([5]int32){}, "[5]int32{0, 0, 0, 0, 0}" },
-	pair { (**reflect.integer)(nil), "**reflect.integer(0)" },
+	pair { (**integer)(nil), "**reflect_test.integer(0)" },
 	pair { (map[string]int32)(nil), "map[string] int32{<can't iterate on maps>}" },
 	pair { (chan<-string)(nil), "chan<- string" },
 	pair { (struct {c chan *int32; d float32}){}, "struct { c chan *int32; d float32 }{chan *int32, 0}" },
 	pair { (func(a int8, b int32))(nil), "func(int8, int32)(0)" },
-	pair { (struct {c func(chan *reflect.integer, *int8)}){}, "struct { c func(chan *reflect.integer, *int8) }{func(chan *reflect.integer, *int8)(0)}" },
+	pair { (struct {c func(chan *integer, *int8)}){}, "struct { c func(chan *reflect_test.integer, *int8) }{func(chan *reflect_test.integer, *int8)(0)}" },
 	pair { (struct {a int8; b int32}){}, "struct { a int8; b int32 }{0, 0}" },
 	pair { (struct {a int8; b int8; c int32}){}, "struct { a int8; b int8; c int32 }{0, 0, 0}" },
 }
@@ -112,35 +112,35 @@ func TestValue(t *testing.T) {
 	for i, tt := range valueTests {
 		v := NewValue(tt.i);
 		switch v := v.(type) {
-		case *reflect.IntValue:
+		case *IntValue:
 			v.Set(132);
-		case *reflect.Int8Value:
+		case *Int8Value:
 			v.Set(8);
-		case *reflect.Int16Value:
+		case *Int16Value:
 			v.Set(16);
-		case *reflect.Int32Value:
+		case *Int32Value:
 			v.Set(32);
-		case *reflect.Int64Value:
+		case *Int64Value:
 			v.Set(64);
-		case *reflect.UintValue:
+		case *UintValue:
 			v.Set(132);
-		case *reflect.Uint8Value:
+		case *Uint8Value:
 			v.Set(8);
-		case *reflect.Uint16Value:
+		case *Uint16Value:
 			v.Set(16);
-		case *reflect.Uint32Value:
+		case *Uint32Value:
 			v.Set(32);
-		case *reflect.Uint64Value:
+		case *Uint64Value:
 			v.Set(64);
-		case *reflect.FloatValue:
+		case *FloatValue:
 			v.Set(3200.0);
-		case *reflect.Float32Value:
+		case *Float32Value:
 			v.Set(32.1);
-		case *reflect.Float64Value:
+		case *Float64Value:
 			v.Set(64.2);
-		case *reflect.StringValue:
+		case *StringValue:
 			v.Set("stringy cheese");
-		case *reflect.BoolValue:
+		case *BoolValue:
 			v.Set(true);
 		}
 		s := valueToString(v);
@@ -157,8 +157,8 @@ var valueToStringTests = []pair {
 	pair { 123.4, "123.4" },
 	pair { byte(123), "123" },
 	pair { "abc", "abc" },
-	pair { T{123, 456.75, "hello", &_i}, "reflect.T{123, 456.75, hello, *int(&7)}" },
-	pair { new(chan *T), "*chan *reflect.T(&chan *reflect.T)" },
+	pair { T{123, 456.75, "hello", &_i}, "reflect_test.T{123, 456.75, hello, *int(&7)}" },
+	pair { new(chan *T), "*chan *reflect_test.T(&chan *reflect_test.T)" },
 	pair { [10]int{1,2,3,4,5,6,7,8,9,10}, "[10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}" },
 	pair { &[10]int{1,2,3,4,5,6,7,8,9,10}, "*[10]int(&[10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})" },
 	pair { []int{1,2,3,4,5,6,7,8,9,10}, "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}" },
@@ -771,7 +771,7 @@ func (p Point) Dist(scale int) int {
 func TestMethod(t *testing.T) {
 	// Non-curried method of type.
 	p := Point{3, 4};
-	i := reflect.Typeof(p).Method(0).Func.Call([]Value{NewValue(p), NewValue(10)})[0].(*IntValue).Get();
+	i := Typeof(p).Method(0).Func.Call([]Value{NewValue(p), NewValue(10)})[0].(*IntValue).Get();
 	if i != 250 {
 		t.Errorf("Type Method returned %d; want 250", i);
 	}
@@ -812,7 +812,7 @@ func TestInterfaceSet(t *testing.T) {
 	if q := s.P.(*Point); q != p {
 		t.Errorf("i: have %p want %p", q, p);
 	}
-	
+
 	i := pv.Method(0).Call([]Value{NewValue(10)})[0].(*IntValue).Get();
 	if i != 250 {
 		t.Errorf("Interface Method returned %d; want 250", i);
@@ -907,7 +907,7 @@ func TestFieldByIndex(t *testing.T) {
 		}
 
 		if test.value != 0 {
-			v := reflect.NewValue(test.s).(*reflect.StructValue).FieldByIndex(test.index);
+			v := NewValue(test.s).(*StructValue).FieldByIndex(test.index);
 			if v != nil {
 				if x, ok := v.Interface().(int); ok {
 					if x != test.value {
@@ -945,9 +945,9 @@ func TestFieldByName(t *testing.T) {
 		} else if len(test.index) > 0 {
 			t.Errorf("%s.%s not found", s.Name(), test.name);
 		}
-		
+
 		if test.value != 0 {
-			v := reflect.NewValue(test.s).(*reflect.StructValue).FieldByName(test.name);
+			v := NewValue(test.s).(*StructValue).FieldByName(test.name);
 			if v != nil {
 				if x, ok := v.Interface().(int); ok {
 					if x != test.value {
diff --git a/src/pkg/reflect/deepequal.go b/src/pkg/reflect/deepequal.go
index e93513e8d9..86da3c6ee9 100644
--- a/src/pkg/reflect/deepequal.go
+++ b/src/pkg/reflect/deepequal.go
@@ -6,7 +6,6 @@
 
 package reflect
 
-import "reflect"
 
 // During deepValueEqual, must keep track of checks that are
 // in progress.  The comparison algorithm assumes that all
diff --git a/src/pkg/reflect/tostring.go b/src/pkg/reflect/tostring_test.go
similarity index 94%
rename from src/pkg/reflect/tostring.go
rename to src/pkg/reflect/tostring_test.go
index b9ada7b50e..e2f7dbf75f 100644
--- a/src/pkg/reflect/tostring.go
+++ b/src/pkg/reflect/tostring_test.go
@@ -2,15 +2,14 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// Reflection library.
 // Formatting of reflection types and values for debugging.
 // Not defined as methods so they do not need to be linked into most binaries;
 // the functions are not used by the library itself, only in tests.
 
-package reflect
+package reflect_test
 
 import (
-	"reflect";
+	. "reflect";
 	"strconv";
 )
 
@@ -113,7 +112,7 @@ func valueToString(val Value) string {
 		v := val;
 		return typ.String() + "(" + strconv.Itoa64(int64(v.Get())) + ")";
 	default:
-		panicln("reflect.valueToString: can't print type ", typ.String());
+		panicln("valueToString: can't print type ", typ.String());
 	}
-	return "reflect.valueToString: can't happen";
+	return "valueToString: can't happen";
 }
diff --git a/src/pkg/reflect/type.go b/src/pkg/reflect/type.go
index 9820864f03..4bd2fc1214 100644
--- a/src/pkg/reflect/type.go
+++ b/src/pkg/reflect/type.go
@@ -226,11 +226,6 @@ type StructType struct {
  * The compiler does not know about the data structures and methods below.
  */
 
-type Type interface
-type addr unsafe.Pointer
-type FuncValue struct
-func newFuncValue(typ Type, addr addr, canSet bool) *FuncValue
-
 // Method represents a single method.
 type Method struct {
 	PkgPath string;		// empty for uppercase Name
@@ -281,8 +276,6 @@ type Type interface {
 	uncommon() *uncommonType;
 }
 
-func toType(i interface{}) Type
-
 func (t *uncommonType) uncommon() *uncommonType {
 	return t;
 }
diff --git a/src/pkg/reflect/value.go b/src/pkg/reflect/value.go
index f1ea106557..e2df30b799 100644
--- a/src/pkg/reflect/value.go
+++ b/src/pkg/reflect/value.go
@@ -5,14 +5,13 @@
 package reflect
 
 import (
-	"reflect";
 	"runtime";
 	"unsafe";
 )
 
 const ptrSize = uintptr(unsafe.Sizeof((*byte)(nil)))
-
 const cannotSet = "cannot set value obtained via unexported struct field"
+type addr unsafe.Pointer
 
 // TODO: This will have to go away when
 // the new gc goes in.
@@ -72,8 +71,6 @@ type Value interface {
 	getAddr()	addr;
 }
 
-func MakeZero(typ Type) Value
-
 type value struct {
 	typ Type;
 	addr addr;
@@ -92,11 +89,6 @@ func (v *value) getAddr() addr {
 	return v.addr;
 }
 
-func (v *value) Method(i int) *FuncValue
-
-type InterfaceValue struct
-type StructValue struct
-
 func (v *value) Interface() interface{} {
 	if typ, ok := v.typ.(*InterfaceType); ok {
 		// There are two different representations of interface values,
@@ -117,9 +109,6 @@ func (v *value) CanSet() bool {
 	return v.canSet;
 }
 
-func newValue(typ Type, addr addr, canSet bool) Value
-func NewValue(i interface{}) Value
-
 /*
  * basic types
  */
@@ -420,7 +409,6 @@ type UnsafePointerValue struct {
 // Get returns the underlying uintptr value.
 // Get returns uintptr, not unsafe.Pointer, so that
 // programs that do not import "unsafe" cannot
-// obtain a value of unsafe.Pointer type from "reflect".
 func (v *UnsafePointerValue) Get() uintptr {
 	return uintptr(*(*unsafe.Pointer)(v.addr));
 }
diff --git a/src/pkg/strconv/Makefile b/src/pkg/strconv/Makefile
index f295218441..af5c5e1108 100644
--- a/src/pkg/strconv/Makefile
+++ b/src/pkg/strconv/Makefile
@@ -2,79 +2,15 @@
 # Use of this source code is governed by a BSD-style
 # license that can be found in the LICENSE file.
 
-
-# DO NOT EDIT.  Automatically generated by gobuild.
-# gobuild -m >Makefile
-
-D=
-
 include $(GOROOT)/src/Make.$(GOARCH)
-AR=gopack
-
-default: packages
-
-clean:
-	rm -rf *.[$(OS)] *.a [$(OS)].out _obj
-
-test: packages
-	gotest
-
-coverage: packages
-	gotest
-	6cov -g $$(pwd) | grep -v '_test\.go:'
-
-%.$O: %.go
-	$(GC) -I_obj $*.go
-
-%.$O: %.c
-	$(CC) $*.c
-
-%.$O: %.s
-	$(AS) $*.s
-
-O1=\
-	decimal.$O\
-	itoa.$O\
-	quote.$O\
-
-O2=\
-	atoi.$O\
-	ftoa.$O\
-
-O3=\
-	atof.$O\
-
-
-phases: a1 a2 a3
-_obj$D/strconv.a: phases
-
-a1: $(O1)
-	$(AR) grc _obj$D/strconv.a decimal.$O itoa.$O quote.$O
-	rm -f $(O1)
-
-a2: $(O2)
-	$(AR) grc _obj$D/strconv.a atoi.$O ftoa.$O
-	rm -f $(O2)
-
-a3: $(O3)
-	$(AR) grc _obj$D/strconv.a atof.$O
-	rm -f $(O3)
-
-
-newpkg: clean
-	mkdir -p _obj$D
-	$(AR) grc _obj$D/strconv.a
-
-$(O1): newpkg
-$(O2): a1
-$(O3): a2
-$(O4): a3
-
-nuke: clean
-	rm -f $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/strconv.a
 
-packages: _obj$D/strconv.a
+TARG=strconv
+GOFILES=\
+	atof.go\
+	atoi.go\
+	decimal.go\
+	ftoa.go\
+	itoa.go\
+	quote.go\
 
-install: packages
-	test -d $(GOROOT)/pkg && mkdir -p $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D
-	cp _obj$D/strconv.a $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/strconv.a
+include $(GOROOT)/src/Make.pkg
diff --git a/src/pkg/strconv/atof.go b/src/pkg/strconv/atof.go
index 6d6ec562ce..1379558094 100644
--- a/src/pkg/strconv/atof.go
+++ b/src/pkg/strconv/atof.go
@@ -15,7 +15,6 @@ package strconv
 import (
 	"math";
 	"os";
-	"strconv";
 )
 
 var optimize = true	// can change for testing
diff --git a/src/pkg/strconv/atof_test.go b/src/pkg/strconv/atof_test.go
index ecccab79b0..e78244ea0a 100644
--- a/src/pkg/strconv/atof_test.go
+++ b/src/pkg/strconv/atof_test.go
@@ -2,13 +2,14 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package strconv
+package strconv_test
+
 import (
 	"fmt";
 	"os";
 	"reflect";
-	"strconv";
-	"testing"
+	. "strconv";
+	"testing";
 )
 
 type atofTest struct {
@@ -104,36 +105,35 @@ func init() {
 }
 
 func testAtof(t *testing.T, opt bool) {
-	oldopt := strconv.optimize;
-	strconv.optimize = opt;
+	oldopt := SetOptimize(opt);
 	for i := 0; i < len(atoftests); i++ {
 		test := &atoftests[i];
-		out, err := strconv.Atof64(test.in);
-		outs := strconv.Ftoa64(out, 'g', -1);
+		out, err := Atof64(test.in);
+		outs := Ftoa64(out, 'g', -1);
 		if outs != test.out || !reflect.DeepEqual(err, test.err) {
-			t.Errorf("strconv.Atof64(%v) = %v, %v want %v, %v\n",
+			t.Errorf("Atof64(%v) = %v, %v want %v, %v\n",
 				test.in, out, err, test.out, test.err);
 		}
 
 		if float64(float32(out)) == out {
-			out32, err := strconv.Atof32(test.in);
-			outs := strconv.Ftoa32(out32, 'g', -1);
+			out32, err := Atof32(test.in);
+			outs := Ftoa32(out32, 'g', -1);
 			if outs != test.out || !reflect.DeepEqual(err, test.err) {
-				t.Errorf("strconv.Atof32(%v) = %v, %v want %v, %v  # %v\n",
+				t.Errorf("Atof32(%v) = %v, %v want %v, %v  # %v\n",
 					test.in, out32, err, test.out, test.err, out);
 			}
 		}
 
 		if FloatSize == 64 || float64(float32(out)) == out {
-			outf, err := strconv.Atof(test.in);
-			outs := strconv.Ftoa(outf, 'g', -1);
+			outf, err := Atof(test.in);
+			outs := Ftoa(outf, 'g', -1);
 			if outs != test.out || !reflect.DeepEqual(err, test.err) {
-				t.Errorf("strconv.Ftoa(%v) = %v, %v want %v, %v  # %v\n",
+				t.Errorf("Ftoa(%v) = %v, %v want %v, %v  # %v\n",
 					test.in, outf, err, test.out, test.err, out);
 			}
 		}
 	}
-	strconv.optimize = oldopt;
+	SetOptimize(oldopt);
 }
 
 func TestAtof(t *testing.T) {
diff --git a/src/pkg/strconv/atoi.go b/src/pkg/strconv/atoi.go
index cc9688bb05..d86d0f88b1 100644
--- a/src/pkg/strconv/atoi.go
+++ b/src/pkg/strconv/atoi.go
@@ -3,10 +3,8 @@
 // license that can be found in the LICENSE file.
 
 package strconv
-import (
-	"os";
-	"strconv"
-)
+
+import "os"
 
 type NumError struct {
 	Num string;
@@ -25,7 +23,7 @@ func computeIntsize() uint {
 	}
 	return siz
 }
-var intsize = computeIntsize();
+var IntSize = computeIntsize();
 
 // Return the first number n such that n*base >= 1<<64.
 func cutoff64(base int) uint64 {
@@ -189,9 +187,9 @@ func Atoi(s string) (i int, err os.Error) {
 	i = int(i1);
 	if int64(i) != i1 {
 		if i1 < 0 {
-			return -1<<(intsize-1), &NumError{s, os.ERANGE}
+			return -1<<(IntSize-1), &NumError{s, os.ERANGE}
 		}
-		return 1<<(intsize-1) - 1, &NumError{s, os.ERANGE}
+		return 1<<(IntSize-1) - 1, &NumError{s, os.ERANGE}
 	}
 	return i, nil
 }
diff --git a/src/pkg/strconv/atoi_test.go b/src/pkg/strconv/atoi_test.go
index 54630ae62b..ab46e50f40 100644
--- a/src/pkg/strconv/atoi_test.go
+++ b/src/pkg/strconv/atoi_test.go
@@ -2,14 +2,14 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package strconv
+package strconv_test
 
 import (
 	"fmt";
 	"os";
 	"reflect";
-	"strconv";
-	"testing"
+	. "strconv";
+	"testing";
 )
 
 type atoui64Test struct {
@@ -151,9 +151,9 @@ func init() {
 func TestAtoui64(t *testing.T) {
 	for i := range atoui64tests {
 		test := &atoui64tests[i];
-		out, err := strconv.Atoui64(test.in);
+		out, err := Atoui64(test.in);
 		if test.out != out || !reflect.DeepEqual(test.err, err) {
-			t.Errorf("strconv.Atoui64(%q) = %v, %v want %v, %v\n",
+			t.Errorf("Atoui64(%q) = %v, %v want %v, %v\n",
 				test.in, out, err, test.out, test.err);
 		}
 	}
@@ -162,31 +162,31 @@ func TestAtoui64(t *testing.T) {
 func TestAtoi64(t *testing.T) {
 	for i := range atoi64tests {
 		test := &atoi64tests[i];
-		out, err := strconv.Atoi64(test.in);
+		out, err := Atoi64(test.in);
 		if test.out != out || !reflect.DeepEqual(test.err, err) {
-			t.Errorf("strconv.Atoi64(%q) = %v, %v want %v, %v\n",
+			t.Errorf("Atoi64(%q) = %v, %v want %v, %v\n",
 				test.in, out, err, test.out, test.err);
 		}
 	}
 }
 
 func TestAtoui(t *testing.T) {
-	switch intsize {
+	switch IntSize {
 	case 32:
 		for i := range atoui32tests {
 			test := &atoui32tests[i];
-			out, err := strconv.Atoui(test.in);
+			out, err := Atoui(test.in);
 			if test.out != uint32(out) || !reflect.DeepEqual(test.err, err) {
-				t.Errorf("strconv.Atoui(%q) = %v, %v want %v, %v\n",
+				t.Errorf("Atoui(%q) = %v, %v want %v, %v\n",
 					test.in, out, err, test.out, test.err);
 			}
 		}
 	case 64:
 		for i := range atoui64tests {
 			test := &atoui64tests[i];
-			out, err := strconv.Atoui(test.in);
+			out, err := Atoui(test.in);
 			if test.out != uint64(out) || !reflect.DeepEqual(test.err, err) {
-				t.Errorf("strconv.Atoui(%q) = %v, %v want %v, %v\n",
+				t.Errorf("Atoui(%q) = %v, %v want %v, %v\n",
 					test.in, out, err, test.out, test.err);
 			}
 		}
@@ -194,22 +194,22 @@ func TestAtoui(t *testing.T) {
 }
 
 func TestAtoi(t *testing.T) {
-	switch intsize {
+	switch IntSize {
 	case 32:
 		for i := range atoi32tests {
 			test := &atoi32tests[i];
-			out, err := strconv.Atoi(test.in);
+			out, err := Atoi(test.in);
 			if test.out != int32(out) || !reflect.DeepEqual(test.err, err) {
-				t.Errorf("strconv.Atoi(%q) = %v, %v want %v, %v\n",
+				t.Errorf("Atoi(%q) = %v, %v want %v, %v\n",
 					test.in, out, err, test.out, test.err);
 			}
 		}
 	case 64:
 		for i := range atoi64tests {
 			test := &atoi64tests[i];
-			out, err := strconv.Atoi(test.in);
+			out, err := Atoi(test.in);
 			if test.out != int64(out) || !reflect.DeepEqual(test.err, err) {
-				t.Errorf("strconv.Atoi(%q) = %v, %v want %v, %v\n",
+				t.Errorf("Atoi(%q) = %v, %v want %v, %v\n",
 					test.in, out, err, test.out, test.err);
 			}
 		}
diff --git a/src/pkg/strconv/decimal.go b/src/pkg/strconv/decimal.go
index bf559b1936..6772c09615 100644
--- a/src/pkg/strconv/decimal.go
+++ b/src/pkg/strconv/decimal.go
@@ -20,16 +20,6 @@ type decimal struct {
 	nd int;	// number of digits used
 	dp int;	// decimal point
 };
-func (a *decimal) String() string;
-func (a *decimal) Assign(v uint64);
-func (a *decimal) Shift(k int) *decimal;
-func (a *decimal) Round(nd int) *decimal;
-func (a *decimal) RoundUp(nd int) *decimal;
-func (a *decimal) RoundDown(nd int) *decimal;
-func (a *decimal) RoundedInteger() uint64;
-
-
-func digitZero(dst []byte) int;
 
 func (a *decimal) String() string {
 	n := 10 + a.nd;
diff --git a/src/pkg/strconv/decimal_test.go b/src/pkg/strconv/decimal_test.go
index bc82861bdd..1498deaec8 100644
--- a/src/pkg/strconv/decimal_test.go
+++ b/src/pkg/strconv/decimal_test.go
@@ -2,11 +2,11 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package strconv
+package strconv_test
 
 import (
 	"fmt";
-	"strconv";
+	. "strconv";
 	"testing";
 )
 
@@ -33,7 +33,7 @@ func TestDecimalShift(t *testing.T) {
 	ok := true;
 	for i := 0; i < len(shifttests); i++ {
 		test := &shifttests[i];
-		s := strconv.newDecimal(test.i).Shift(test.shift).String();
+		s := NewDecimal(test.i).Shift(test.shift).String();
 		if s != test.out {
 			t.Errorf("Decimal %v << %v = %v, want %v\n",
 				test.i, test.shift, s, test.out);
@@ -69,17 +69,17 @@ var roundtests = []roundTest {
 func TestDecimalRound(t *testing.T) {
 	for i := 0; i < len(roundtests); i++ {
 		test := &roundtests[i];
-		s := strconv.newDecimal(test.i).RoundDown(test.nd).String();
+		s := NewDecimal(test.i).RoundDown(test.nd).String();
 		if s != test.down {
 			t.Errorf("Decimal %v RoundDown %d = %v, want %v\n",
 				test.i, test.nd, s, test.down);
 		}
-		s = strconv.newDecimal(test.i).Round(test.nd).String();
+		s = NewDecimal(test.i).Round(test.nd).String();
 		if s != test.round {
 			t.Errorf("Decimal %v Round %d = %v, want %v\n",
 				test.i, test.nd, s, test.down);
 		}
-		s = strconv.newDecimal(test.i).RoundUp(test.nd).String();
+		s = NewDecimal(test.i).RoundUp(test.nd).String();
 		if s != test.up {
 			t.Errorf("Decimal %v RoundUp %d = %v, want %v\n",
 				test.i, test.nd, s, test.up);
@@ -109,11 +109,10 @@ var roundinttests = []roundIntTest {
 func TestDecimalRoundedInteger(t *testing.T) {
 	for i := 0; i < len(roundinttests); i++ {
 		test := roundinttests[i];
-		// TODO: should be able to use int := here.
-		int1 := strconv.newDecimal(test.i).Shift(test.shift).RoundedInteger();
-		if int1 != test.int {
+		int := NewDecimal(test.i).Shift(test.shift).RoundedInteger();
+		if int != test.int {
 			t.Errorf("Decimal %v >> %v RoundedInteger = %v, want %v\n",
-				test.i, test.shift, int1, test.int);
+				test.i, test.shift, int, test.int);
 		}
 	}
 }
diff --git a/src/pkg/strconv/fp_test.go b/src/pkg/strconv/fp_test.go
index 20e158cec9..0890b0fad2 100644
--- a/src/pkg/strconv/fp_test.go
+++ b/src/pkg/strconv/fp_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package strconv
+package strconv_test
 import (
 	"bufio";
 	"fmt";
@@ -144,6 +144,5 @@ func TestFp(t *testing.T) {
 			t.Error("testfp.txt:", lineno, ": ", a[0], " ", a[1], " ", a[2], " (", v, ") ",
 				"want ", a[3], " got ", s);
 		}
-//else print("testfp.txt:", lineno, ": worked! ", s, "\n");
 	}
 }
diff --git a/src/pkg/strconv/ftoa.go b/src/pkg/strconv/ftoa.go
index b171151758..b5835c7c85 100644
--- a/src/pkg/strconv/ftoa.go
+++ b/src/pkg/strconv/ftoa.go
@@ -10,10 +10,7 @@
 
 package strconv
 
-import (
-	"math";
-	"strconv";
-)
+import "math"
 
 // TODO: move elsewhere?
 type floatInfo struct {
@@ -24,13 +21,6 @@ type floatInfo struct {
 var float32info = floatInfo{ 23, 8, -127 }
 var float64info = floatInfo{ 52, 11, -1023 }
 
-func fmtB(neg bool, mant uint64, exp int, flt *floatInfo) string
-func fmtE(neg bool, d *decimal, prec int) string
-func fmtF(neg bool, d *decimal, prec int) string
-func genericFtoa(bits uint64, fmt byte, prec int, flt *floatInfo) string
-func max(a, b int) int
-func roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo)
-
 func floatsize() int {
 	// Figure out whether float is float32 or float64.
 	// 1e-35 is representable in both, but 1e-70
diff --git a/src/pkg/strconv/ftoa_test.go b/src/pkg/strconv/ftoa_test.go
index 0f0baa5145..44402439ca 100644
--- a/src/pkg/strconv/ftoa_test.go
+++ b/src/pkg/strconv/ftoa_test.go
@@ -2,12 +2,12 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package strconv
+package strconv_test
 
 import (
 	"math";
-	"strconv";
-	"testing"
+	. "strconv";
+	"testing";
 )
 
 type ftoaTest struct {
@@ -100,17 +100,17 @@ var ftoatests = []ftoaTest {
 }
 
 func TestFtoa(t *testing.T) {
-	if strconv.FloatSize != 32 {
-		panic("floatsize: ", strconv.FloatSize);
+	if FloatSize != 32 {
+		panic("floatsize: ", FloatSize);
 	}
 	for i := 0; i < len(ftoatests); i++ {
 		test := &ftoatests[i];
-		s := strconv.Ftoa64(test.f, test.fmt, test.prec);
+		s := Ftoa64(test.f, test.fmt, test.prec);
 		if s != test.s {
 			t.Error("test", test.f, string(test.fmt), test.prec, "want", test.s, "got", s);
 		}
 		if float64(float32(test.f)) == test.f && test.fmt != 'b' {
-			s := strconv.Ftoa32(float32(test.f), test.fmt, test.prec);
+			s := Ftoa32(float32(test.f), test.fmt, test.prec);
 			if s != test.s {
 				t.Error("test32", test.f, string(test.fmt), test.prec, "want", test.s, "got", s);
 			}
diff --git a/src/pkg/strconv/internal_test.go b/src/pkg/strconv/internal_test.go
new file mode 100644
index 0000000000..8ec75db35c
--- /dev/null
+++ b/src/pkg/strconv/internal_test.go
@@ -0,0 +1,18 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// export access to strconv internals for tests
+
+package strconv
+
+func NewDecimal(i uint64) *decimal {
+	return newDecimal(i);
+}
+
+func SetOptimize(b bool) bool {
+	old := optimize;
+	optimize = b;
+	return old;
+}
+
diff --git a/src/pkg/strconv/itoa_test.go b/src/pkg/strconv/itoa_test.go
index 998c306239..793ece60ec 100644
--- a/src/pkg/strconv/itoa_test.go
+++ b/src/pkg/strconv/itoa_test.go
@@ -2,12 +2,12 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package strconv
+package strconv_test
 
 import (
 	"fmt";
 	"os";
-	"strconv";
+	. "strconv";
 	"testing";
 )
 
@@ -61,62 +61,62 @@ var itob64tests = []itob64Test {
 
 func TestItoa(t *testing.T) {
 	for i, test := range itob64tests {
-		s := strconv.Itob64(test.in, test.base);
+		s := Itob64(test.in, test.base);
 		if s != test.out {
-			t.Errorf("strconv.Itob64(%v, %v) = %v want %v\n",
+			t.Errorf("Itob64(%v, %v) = %v want %v\n",
 				test.in, test.base, s, test.out);
 		}
 
 		if test.in >= 0 {
-			s := strconv.Uitob64(uint64(test.in), test.base);
+			s := Uitob64(uint64(test.in), test.base);
 			if s != test.out {
-				t.Errorf("strconv.Uitob64(%v, %v) = %v want %v\n",
+				t.Errorf("Uitob64(%v, %v) = %v want %v\n",
 					test.in, test.base, s, test.out);
 			}
 		}
 
 		if int64(int(test.in)) == test.in {
-			s := strconv.Itob(int(test.in), test.base);
+			s := Itob(int(test.in), test.base);
 			if s != test.out {
-				t.Errorf("strconv.Itob(%v, %v) = %v want %v\n",
+				t.Errorf("Itob(%v, %v) = %v want %v\n",
 					test.in, test.base, s, test.out);
 			}
 
 			if test.in >= 0  {
-				s := strconv.Uitob(uint(test.in), test.base);
+				s := Uitob(uint(test.in), test.base);
 				if s != test.out {
-					t.Errorf("strconv.Uitob(%v, %v) = %v want %v\n",
+					t.Errorf("Uitob(%v, %v) = %v want %v\n",
 						test.in, test.base, s, test.out);
 				}
 			}
 		}
 
 		if test.base == 10 {
-			s := strconv.Itoa64(test.in);
+			s := Itoa64(test.in);
 			if s != test.out {
-				t.Errorf("strconv.Itoa64(%v) = %v want %v\n",
+				t.Errorf("Itoa64(%v) = %v want %v\n",
 					test.in, s, test.out);
 			}
 
 			if test.in >= 0 {
-				s := strconv.Uitob64(uint64(test.in), test.base);
+				s := Uitob64(uint64(test.in), test.base);
 				if s != test.out {
-					t.Errorf("strconv.Uitob64(%v, %v) = %v want %v\n",
+					t.Errorf("Uitob64(%v, %v) = %v want %v\n",
 						test.in, test.base, s, test.out);
 				}
 			}
 
 			if int64(int(test.in)) == test.in {
-				s := strconv.Itoa(int(test.in));
+				s := Itoa(int(test.in));
 				if s != test.out {
-					t.Errorf("strconv.Itoa(%v) = %v want %v\n",
+					t.Errorf("Itoa(%v) = %v want %v\n",
 						test.in, s, test.out);
 				}
 
 				if test.in >= 0 {
-					s := strconv.Uitoa(uint(test.in));
+					s := Uitoa(uint(test.in));
 					if s != test.out {
-						t.Errorf("strconv.Uitoa(%v) = %v want %v\n",
+						t.Errorf("Uitoa(%v) = %v want %v\n",
 							test.in, s, test.out);
 					}
 				}
@@ -141,31 +141,31 @@ var uitob64tests = []uitob64Test {
 
 func TestUitoa(t *testing.T) {
 	for i, test := range uitob64tests {
-		s := strconv.Uitob64(test.in, test.base);
+		s := Uitob64(test.in, test.base);
 		if s != test.out {
-			t.Errorf("strconv.Uitob64(%v, %v) = %v want %v\n",
+			t.Errorf("Uitob64(%v, %v) = %v want %v\n",
 				test.in, test.base, s, test.out);
 		}
 
 		if uint64(uint(test.in)) == test.in {
-			s := strconv.Uitob(uint(test.in), test.base);
+			s := Uitob(uint(test.in), test.base);
 			if s != test.out {
-				t.Errorf("strconv.Uitob(%v, %v) = %v want %v\n",
+				t.Errorf("Uitob(%v, %v) = %v want %v\n",
 					test.in, test.base, s, test.out);
 			}
 		}
 
 		if test.base == 10 {
-			s := strconv.Uitoa64(test.in);
+			s := Uitoa64(test.in);
 			if s != test.out {
-				t.Errorf("strconv.Uitoa64(%v) = %v want %v\n",
+				t.Errorf("Uitoa64(%v) = %v want %v\n",
 					test.in, s, test.out);
 			}
 
 			if uint64(uint(test.in)) == test.in {
-				s := strconv.Uitoa(uint(test.in));
+				s := Uitoa(uint(test.in));
 				if s != test.out {
-					t.Errorf("strconv.Uitoa(%v) = %v want %v\n",
+					t.Errorf("Uitoa(%v) = %v want %v\n",
 						test.in, s, test.out);
 				}
 			}
diff --git a/src/pkg/strconv/quote_test.go b/src/pkg/strconv/quote_test.go
index 0b35b20cc7..a3d7ab939f 100644
--- a/src/pkg/strconv/quote_test.go
+++ b/src/pkg/strconv/quote_test.go
@@ -2,11 +2,11 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package strconv
+package strconv_test
 
 import (
 	"os";
-	"strconv";
+	. "strconv";
 	"testing";
 )
 
diff --git a/src/pkg/sync/Makefile b/src/pkg/sync/Makefile
index 566853d576..0c18f8bcbc 100644
--- a/src/pkg/sync/Makefile
+++ b/src/pkg/sync/Makefile
@@ -2,60 +2,13 @@
 # Use of this source code is governed by a BSD-style
 # license that can be found in the LICENSE file.
 
-# DO NOT EDIT.  Automatically generated by gobuild.
-# gobuild -m asm_${GOARCH}.s mutex.go >Makefile
-
-D=
-
 include $(GOROOT)/src/Make.$(GOARCH)
-AR=gopack
-
-default: packages
-
-clean:
-	rm -rf *.[$(OS)] *.a [$(OS)].out _obj
-
-test: packages
-	gotest
-
-coverage: packages
-	gotest
-	6cov -g `pwd` | grep -v '_test\.go:'
-
-%.$O: %.go
-	$(GC) -I_obj $*.go
-
-%.$O: %.c
-	$(CC) $*.c
 
-%.$O: %.s
-	$(AS) $*.s
+TARG=sync
+GOFILES=\
+	mutex.go\
 
-O1=\
+OFILES=\
 	asm_$(GOARCH).$O\
-	mutex.$O\
-
-
-phases: a1
-_obj$D/sync.a: phases
-
-a1: $(O1)
-	$(AR) grc _obj$D/sync.a asm_$(GOARCH).$O mutex.$O
-	rm -f $(O1)
-
-
-newpkg: clean
-	mkdir -p _obj$D
-	$(AR) grc _obj$D/sync.a
-
-$(O1): newpkg
-$(O2): a1
-
-nuke: clean
-	rm -f $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/sync.a
-
-packages: _obj$D/sync.a
 
-install: packages
-	test -d $(GOROOT)/pkg && mkdir -p $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D
-	cp _obj$D/sync.a $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/sync.a
+include $(GOROOT)/src/Make.pkg
diff --git a/src/pkg/sync/internal_test.go b/src/pkg/sync/internal_test.go
new file mode 100644
index 0000000000..e6027cfbe9
--- /dev/null
+++ b/src/pkg/sync/internal_test.go
@@ -0,0 +1,15 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// expose internals for testing
+
+package sync
+
+func Semacquire(s *int32) {
+	semacquire(s)
+}
+
+func Semrelease(s *int32) {
+	semrelease(s)
+}
diff --git a/src/pkg/sync/mutex_test.go b/src/pkg/sync/mutex_test.go
index 819dbb9de5..e1f6a17bd9 100644
--- a/src/pkg/sync/mutex_test.go
+++ b/src/pkg/sync/mutex_test.go
@@ -4,17 +4,17 @@
 
 // GOMAXPROCS=10 gotest
 
-package sync
+package sync_test
 
 import (
-	"sync";
+	. "sync";
 	"testing"
 )
 
 func HammerSemaphore(s *int32, cdone chan bool) {
 	for i := 0; i < 1000; i++ {
-		semacquire(s);
-		semrelease(s);
+		Semacquire(s);
+		Semrelease(s);
 	}
 	cdone <- true;
 }
diff --git a/src/pkg/time/Makefile b/src/pkg/time/Makefile
index 8d3c3b65f6..fef9753c87 100644
--- a/src/pkg/time/Makefile
+++ b/src/pkg/time/Makefile
@@ -2,76 +2,13 @@
 # Use of this source code is governed by a BSD-style
 # license that can be found in the LICENSE file.
 
-# DO NOT EDIT.  Automatically generated by gobuild.
-# gobuild -m >Makefile
-
-D=
-
 include $(GOROOT)/src/Make.$(GOARCH)
-AR=gopack
-
-default: packages
-
-clean:
-	rm -rf *.[$(OS)] *.a [$(OS)].out _obj
-
-test: packages
-	gotest
-
-coverage: packages
-	gotest
-	6cov -g `pwd` | grep -v '_test\.go:'
-
-%.$O: %.go
-	$(GC) -I_obj $*.go
-
-%.$O: %.c
-	$(CC) $*.c
-
-%.$O: %.s
-	$(AS) $*.s
-
-O1=\
-	sleep.$O\
-	zoneinfo.$O\
-
-O2=\
-	time.$O\
-
-O3=\
-	tick.$O\
-
-
-phases: a1 a2 a3
-_obj$D/time.a: phases
-
-a1: $(O1)
-	$(AR) grc _obj$D/time.a sleep.$O zoneinfo.$O
-	rm -f $(O1)
-
-a2: $(O2)
-	$(AR) grc _obj$D/time.a time.$O
-	rm -f $(O2)
-
-a3: $(O3)
-	$(AR) grc _obj$D/time.a tick.$O
-	rm -f $(O3)
-
-
-newpkg: clean
-	mkdir -p _obj$D
-	$(AR) grc _obj$D/time.a
-
-$(O1): newpkg
-$(O2): a1
-$(O3): a2
-$(O4): a3
-
-nuke: clean
-	rm -f $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/time.a
 
-packages: _obj$D/time.a
+TARG=time
+GOFILES=\
+	sleep.go\
+	tick.go\
+	time.go\
+	zoneinfo.go\
 
-install: packages
-	test -d $(GOROOT)/pkg && mkdir -p $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D
-	cp _obj$D/time.a $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/time.a
+include $(GOROOT)/src/Make.pkg
diff --git a/src/pkg/time/tick.go b/src/pkg/time/tick.go
index 26de901250..81c3852203 100644
--- a/src/pkg/time/tick.go
+++ b/src/pkg/time/tick.go
@@ -6,7 +6,6 @@ package time
 
 import (
 	"syscall";
-	"time";
 	"unsafe";
 )
 
diff --git a/src/pkg/time/tick_test.go b/src/pkg/time/tick_test.go
index 0667be679b..c7cad1217e 100644
--- a/src/pkg/time/tick_test.go
+++ b/src/pkg/time/tick_test.go
@@ -2,11 +2,11 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package time
+package time_test
 
 import (
 	"testing";
-	"time";
+	. "time";
 )
 
 func TestTick(t *testing.T) {
diff --git a/src/pkg/time/time.go b/src/pkg/time/time.go
index d47dbe6a11..1e4990b10f 100644
--- a/src/pkg/time/time.go
+++ b/src/pkg/time/time.go
@@ -8,7 +8,6 @@ package time
 
 import (
 	"os";
-	"time"
 )
 
 // Seconds reports the number of seconds since the Unix epoch,
diff --git a/src/pkg/time/time_test.go b/src/pkg/time/time_test.go
index 2457d8561a..2c80a716dc 100644
--- a/src/pkg/time/time_test.go
+++ b/src/pkg/time/time_test.go
@@ -2,12 +2,12 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package time
+package time_test
 
 import (
 	"os";
 	"testing";
-	"time";
+	. "time";
 )
 
 func init() {
diff --git a/src/pkg/utf8/Makefile b/src/pkg/utf8/Makefile
index b5ad083b2d..b33adaa8a1 100644
--- a/src/pkg/utf8/Makefile
+++ b/src/pkg/utf8/Makefile
@@ -2,59 +2,10 @@
 # Use of this source code is governed by a BSD-style
 # license that can be found in the LICENSE file.
 
-# DO NOT EDIT.  Automatically generated by gobuild.
-# gobuild -m >Makefile
-
-D=
-
 include $(GOROOT)/src/Make.$(GOARCH)
-AR=gopack
-
-default: packages
-
-clean:
-	rm -rf *.[$(OS)] *.a [$(OS)].out _obj
-
-test: packages
-	gotest
-
-coverage: packages
-	gotest
-	6cov -g `pwd` | grep -v '_test\.go:'
-
-%.$O: %.go
-	$(GC) -I_obj $*.go
-
-%.$O: %.c
-	$(CC) $*.c
-
-%.$O: %.s
-	$(AS) $*.s
-
-O1=\
-	utf8.$O\
-
-
-phases: a1
-_obj$D/utf8.a: phases
-
-a1: $(O1)
-	$(AR) grc _obj$D/utf8.a utf8.$O
-	rm -f $(O1)
-
-
-newpkg: clean
-	mkdir -p _obj$D
-	$(AR) grc _obj$D/utf8.a
-
-$(O1): newpkg
-$(O2): a1
-
-nuke: clean
-	rm -f $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/utf8.a
 
-packages: _obj$D/utf8.a
+TARG=utf8
+GOFILES=\
+	utf8.go\
 
-install: packages
-	test -d $(GOROOT)/pkg && mkdir -p $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D
-	cp _obj$D/utf8.a $(GOROOT)/pkg/$(GOOS)_$(GOARCH)$D/utf8.a
+include $(GOROOT)/src/Make.pkg
diff --git a/src/pkg/utf8/utf8_test.go b/src/pkg/utf8/utf8_test.go
index 1597a94c72..9c689ca2db 100644
--- a/src/pkg/utf8/utf8_test.go
+++ b/src/pkg/utf8/utf8_test.go
@@ -2,14 +2,14 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-package utf8
+package utf8_test
 
 import (
 	"bytes";
 	"fmt";
 	"strings";
 	"testing";
-	"utf8";
+	. "utf8";
 )
 
 type Utf8Map struct {
@@ -56,19 +56,19 @@ func TestFullRune(t *testing.T) {
 	for i := 0; i < len(utf8map); i++ {
 		m := utf8map[i];
 		b := makeBytes(m.str);
-		if !utf8.FullRune(b) {
+		if !FullRune(b) {
 			t.Errorf("FullRune(%q) (rune %04x) = false, want true", b, m.rune);
 		}
 		s := m.str;
-		if !utf8.FullRuneInString(s) {
+		if !FullRuneInString(s) {
 			t.Errorf("FullRuneInString(%q) (rune %04x) = false, want true", s, m.rune);
 		}
 		b1 := b[0:len(b)-1];
-		if utf8.FullRune(b1) {
+		if FullRune(b1) {
 			t.Errorf("FullRune(%q) = true, want false", b1);
 		}
 		s1 := string(b1);
-		if utf8.FullRuneInString(s1) {
+		if FullRuneInString(s1) {
 			t.Errorf("FullRune(%q) = true, want false", s1);
 		}
 	}
@@ -79,7 +79,7 @@ func TestEncodeRune(t *testing.T) {
 		m := utf8map[i];
 		b := makeBytes(m.str);
 		var buf [10]byte;
-		n := utf8.EncodeRune(m.rune, &buf);
+		n := EncodeRune(m.rune, &buf);
 		b1 := buf[0:n];
 		if !bytes.Equal(b, b1) {
 			t.Errorf("EncodeRune(0x%04x) = %q want %q", m.rune, b1, b);
@@ -91,23 +91,23 @@ func TestDecodeRune(t *testing.T) {
 	for i := 0; i < len(utf8map); i++ {
 		m := utf8map[i];
 		b := makeBytes(m.str);
-		rune, size := utf8.DecodeRune(b);
+		rune, size := DecodeRune(b);
 		if rune != m.rune || size != len(b) {
 			t.Errorf("DecodeRune(%q) = 0x%04x, %d want 0x%04x, %d", b, rune, size, m.rune, len(b));
 		}
 		s := m.str;
-		rune, size = utf8.DecodeRuneInString(s);
+		rune, size = DecodeRuneInString(s);
 		if rune != m.rune || size != len(b) {
 			t.Errorf("DecodeRune(%q) = 0x%04x, %d want 0x%04x, %d", s, rune, size, m.rune, len(b));
 		}
 
 		// there's an extra byte that bytes left behind - make sure trailing byte works
-		rune, size = utf8.DecodeRune(b[0:cap(b)]);
+		rune, size = DecodeRune(b[0:cap(b)]);
 		if rune != m.rune || size != len(b) {
 			t.Errorf("DecodeRune(%q) = 0x%04x, %d want 0x%04x, %d", b, rune, size, m.rune, len(b));
 		}
 		s = m.str+"\x00";
-		rune, size = utf8.DecodeRuneInString(s);
+		rune, size = DecodeRuneInString(s);
 		if rune != m.rune || size != len(b) {
 			t.Errorf("DecodeRuneInString(%q) = 0x%04x, %d want 0x%04x, %d", s, rune, size, m.rune, len(b));
 		}
@@ -117,12 +117,12 @@ func TestDecodeRune(t *testing.T) {
 		if wantsize >= len(b) {
 			wantsize = 0;
 		}
-		rune, size = utf8.DecodeRune(b[0:len(b)-1]);
+		rune, size = DecodeRune(b[0:len(b)-1]);
 		if rune != RuneError || size != wantsize {
 			t.Errorf("DecodeRune(%q) = 0x%04x, %d want 0x%04x, %d", b[0:len(b)-1], rune, size, RuneError, wantsize);
 		}
 		s = m.str[0:len(m.str)-1];
-		rune, size = utf8.DecodeRuneInString(s);
+		rune, size = DecodeRuneInString(s);
 		if rune != RuneError || size != wantsize {
 			t.Errorf("DecodeRuneInString(%q) = 0x%04x, %d want 0x%04x, %d", s, rune, size, RuneError, wantsize);
 		}
@@ -133,12 +133,12 @@ func TestDecodeRune(t *testing.T) {
 		} else {
 			b[len(b)-1] = 0x7F;
 		}
-		rune, size = utf8.DecodeRune(b);
+		rune, size = DecodeRune(b);
 		if rune != RuneError || size != 1 {
 			t.Errorf("DecodeRune(%q) = 0x%04x, %d want 0x%04x, %d", b, rune, size, RuneError, 1);
 		}
 		s = string(b);
-		rune, size = utf8.DecodeRune(b);
+		rune, size = DecodeRune(b);
 		if rune != RuneError || size != 1 {
 			t.Errorf("DecodeRuneInString(%q) = 0x%04x, %d want 0x%04x, %d", s, rune, size, RuneError, 1);
 		}
@@ -158,10 +158,10 @@ var runecounttests = []RuneCountTest {
 func TestRuneCount(t *testing.T) {
 	for i := 0; i < len(runecounttests); i++ {
 		tt := runecounttests[i];
-		if out := utf8.RuneCountInString(tt.in); out != tt.out {
+		if out := RuneCountInString(tt.in); out != tt.out {
 			t.Errorf("RuneCountInString(%q) = %d, want %d", tt.in, out, tt.out);
 		}
-		if out := utf8.RuneCount(makeBytes(tt.in)); out != tt.out {
+		if out := RuneCount(makeBytes(tt.in)); out != tt.out {
 			t.Errorf("RuneCount(%q) = %d, want %d", tt.in, out, tt.out);
 		}
 	}
