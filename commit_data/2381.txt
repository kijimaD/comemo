commit 4be7067f42af0fd716c9fb5495ceaa2ff0c4f46d
Author: Russ Cox <rsc@golang.org>
Date:   Thu Jun 4 13:33:48 2009 -0700

    machine-generated files for CL 29882
    
    R=r
    DELTA=1652  (1652 added, 0 deleted, 0 changed)
    OCL=29883
    CL=29887
---
 src/lib/syscall/zerrors_linux_386.go  | 316 +++++++++++++++
 src/lib/syscall/zsyscall_linux_386.go | 720 ++++++++++++++++++++++++++++++++++
 src/lib/syscall/zsysnum_linux_386.go  | 319 +++++++++++++++
 src/lib/syscall/ztypes_linux_386.go   | 297 ++++++++++++++
 4 files changed, 1652 insertions(+)

diff --git a/src/lib/syscall/zerrors_linux_386.go b/src/lib/syscall/zerrors_linux_386.go
new file mode 100644
index 0000000000..f1e7e011da
--- /dev/null
+++ b/src/lib/syscall/zerrors_linux_386.go
@@ -0,0 +1,316 @@
+// mkerrors
+// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
+
+// godefs -gsyscall _errors.c
+
+// MACHINE GENERATED - DO NOT EDIT.
+
+package syscall
+
+// Constants
+const (
+	EMULTIHOP = 0x48;
+	EUNATCH = 0x31;
+	EAFNOSUPPORT = 0x61;
+	EREMCHG = 0x4e;
+	EACCES = 0xd;
+	EL3RST = 0x2f;
+	EDESTADDRREQ = 0x59;
+	EILSEQ = 0x54;
+	ESPIPE = 0x1d;
+	EMLINK = 0x1f;
+	EOWNERDEAD = 0x82;
+	ENOTTY = 0x19;
+	EBADE = 0x34;
+	EBADF = 0x9;
+	EBADR = 0x35;
+	EADV = 0x44;
+	ERANGE = 0x22;
+	ECANCELED = 0x7d;
+	ETXTBSY = 0x1a;
+	ENOMEM = 0xc;
+	EINPROGRESS = 0x73;
+	ENOTBLK = 0xf;
+	EPROTOTYPE = 0x5b;
+	ERESTART = 0x55;
+	EISNAM = 0x78;
+	ENOMSG = 0x2a;
+	EALREADY = 0x72;
+	ETIMEDOUT = 0x6e;
+	ENODATA = 0x3d;
+	EINTR = 0x4;
+	ENOLINK = 0x43;
+	EPERM = 0x1;
+	ELOOP = 0x28;
+	ENETDOWN = 0x64;
+	ESTALE = 0x74;
+	ENOTSOCK = 0x58;
+	ENOSR = 0x3f;
+	ECHILD = 0xa;
+	ELNRNG = 0x30;
+	EPIPE = 0x20;
+	EBADMSG = 0x4a;
+	EBFONT = 0x3b;
+	EREMOTE = 0x42;
+	ETOOMANYREFS = 0x6d;
+	EPFNOSUPPORT = 0x60;
+	ENONET = 0x40;
+	EXFULL = 0x36;
+	EBADSLT = 0x39;
+	ENOTNAM = 0x76;
+	ELIBEXEC = 0x53;
+	ENOCSI = 0x32;
+	ENOTEMPTY = 0x27;
+	EADDRINUSE = 0x62;
+	ENETRESET = 0x66;
+	EISDIR = 0x15;
+	EIDRM = 0x2b;
+	ECOMM = 0x46;
+	EBADFD = 0x4d;
+	EL2HLT = 0x33;
+	ENOKEY = 0x7e;
+	EINVAL = 0x16;
+	ESHUTDOWN = 0x6c;
+	EKEYREJECTED = 0x81;
+	ELIBSCN = 0x51;
+	ENAVAIL = 0x77;
+	ENOSTR = 0x3c;
+	EOVERFLOW = 0x4b;
+	EUCLEAN = 0x75;
+	ENOMEDIUM = 0x7b;
+	EBUSY = 0x10;
+	EPROTO = 0x47;
+	ENODEV = 0x13;
+	EKEYEXPIRED = 0x7f;
+	EROFS = 0x1e;
+	ELIBACC = 0x4f;
+	E2BIG = 0x7;
+	EDEADLK = 0x23;
+	ECONNRESET = 0x68;
+	ENXIO = 0x6;
+	EBADRQC = 0x38;
+	ENAMETOOLONG = 0x24;
+	ESOCKTNOSUPPORT = 0x5e;
+	EDOTDOT = 0x49;
+	EADDRNOTAVAIL = 0x63;
+	ETIME = 0x3e;
+	EPROTONOSUPPORT = 0x5d;
+	ENOTRECOVERABLE = 0x83;
+	EIO = 0x5;
+	ENETUNREACH = 0x65;
+	EXDEV = 0x12;
+	EDQUOT = 0x7a;
+	EREMOTEIO = 0x79;
+	ENOSPC = 0x1c;
+	ENOEXEC = 0x8;
+	EMSGSIZE = 0x5a;
+	EDOM = 0x21;
+	EFBIG = 0x1b;
+	ESRCH = 0x3;
+	ECHRNG = 0x2c;
+	EHOSTDOWN = 0x70;
+	ENOLCK = 0x25;
+	ENFILE = 0x17;
+	ENOSYS = 0x26;
+	ENOTCONN = 0x6b;
+	ENOTSUP = 0x5f;
+	ESRMNT = 0x45;
+	EDEADLOCK = 0x23;
+	ECONNABORTED = 0x67;
+	ENOANO = 0x37;
+	EISCONN = 0x6a;
+	EUSERS = 0x57;
+	ENOPROTOOPT = 0x5c;
+	EMFILE = 0x18;
+	ENOBUFS = 0x69;
+	EL3HLT = 0x2e;
+	EFAULT = 0xe;
+	EWOULDBLOCK = 0xb;
+	ELIBBAD = 0x50;
+	ESTRPIPE = 0x56;
+	ECONNREFUSED = 0x6f;
+	EAGAIN = 0xb;
+	ELIBMAX = 0x52;
+	EEXIST = 0x11;
+	EL2NSYNC = 0x2d;
+	ENOENT = 0x2;
+	ENOPKG = 0x41;
+	EKEYREVOKED = 0x80;
+	EHOSTUNREACH = 0x71;
+	ENOTUNIQ = 0x4c;
+	EOPNOTSUPP = 0x5f;
+	ENOTDIR = 0x14;
+	EMEDIUMTYPE = 0x7c;
+	SIGBUS = 0x7;
+	SIGTTIN = 0x15;
+	SIGPROF = 0x1b;
+	SIGFPE = 0x8;
+	SIGHUP = 0x1;
+	SIGTTOU = 0x16;
+	SIGSTKFLT = 0x10;
+	SIGUSR1 = 0xa;
+	SIGURG = 0x17;
+	SIGQUIT = 0x3;
+	SIGCLD = 0x11;
+	SIGIO = 0x1d;
+	SIGABRT = 0x6;
+	SIGUSR2 = 0xc;
+	SIGTRAP = 0x5;
+	SIGVTALRM = 0x1a;
+	SIGPOLL = 0x1d;
+	SIGSEGV = 0xb;
+	SIGCONT = 0x12;
+	SIGPIPE = 0xd;
+	SIGWINCH = 0x1c;
+	SIGXFSZ = 0x19;
+	SIGCHLD = 0x11;
+	SIGSYS = 0x1f;
+	SIGSTOP = 0x13;
+	SIGALRM = 0xe;
+	SIGTSTP = 0x14;
+	SIGKILL = 0x9;
+	SIGXCPU = 0x18;
+	SIGUNUSED = 0x1f;
+	SIGPWR = 0x1e;
+	SIGILL = 0x4;
+	SIGINT = 0x2;
+	SIGIOT = 0x6;
+	SIGTERM = 0xf;
+)
+
+// Types
+
+
+// Error table
+var errors = [...]string {
+	72: "multihop attempted",
+	49: "protocol driver not attached",
+	97: "address family not supported by protocol",
+	78: "remote address changed",
+	13: "permission denied",
+	47: "level 3 reset",
+	89: "destination address required",
+	84: "invalid or incomplete multibyte or wide character",
+	29: "illegal seek",
+	31: "too many links",
+	130: "owner died",
+	25: "inappropriate ioctl for device",
+	52: "invalid exchange",
+	9: "bad file descriptor",
+	53: "invalid request descriptor",
+	68: "advertise error",
+	34: "numerical result out of range",
+	125: "operation canceled",
+	26: "text file busy",
+	12: "cannot allocate memory",
+	115: "operation now in progress",
+	15: "block device required",
+	91: "protocol wrong type for socket",
+	85: "interrupted system call should be restarted",
+	120: "is a named type file",
+	42: "no message of desired type",
+	114: "operation already in progress",
+	110: "connection timed out",
+	61: "no data available",
+	4: "interrupted system call",
+	67: "link has been severed",
+	1: "operation not permitted",
+	40: "too many levels of symbolic links",
+	100: "network is down",
+	116: "stale NFS file handle",
+	88: "socket operation on non-socket",
+	63: "out of streams resources",
+	10: "no child processes",
+	48: "link number out of range",
+	32: "broken pipe",
+	74: "bad message",
+	59: "bad font file format",
+	66: "object is remote",
+	109: "too many references: cannot splice",
+	96: "protocol family not supported",
+	64: "machine is not on the network",
+	54: "exchange full",
+	57: "invalid slot",
+	118: "not a XENIX named type file",
+	83: "cannot exec a shared library directly",
+	50: "no CSI structure available",
+	39: "directory not empty",
+	98: "address already in use",
+	102: "network dropped connection on reset",
+	21: "is a directory",
+	43: "identifier removed",
+	70: "communication error on send",
+	77: "file descriptor in bad state",
+	51: "level 2 halted",
+	126: "required key not available",
+	22: "invalid argument",
+	108: "cannot send after transport endpoint shutdown",
+	129: "key was rejected by service",
+	81: ".lib section in a.out corrupted",
+	119: "no XENIX semaphores available",
+	60: "device not a stream",
+	75: "value too large for defined data type",
+	117: "structure needs cleaning",
+	123: "no medium found",
+	16: "device or resource busy",
+	71: "protocol error",
+	19: "no such device",
+	127: "key has expired",
+	30: "read-only file system",
+	79: "can not access a needed shared library",
+	7: "argument list too long",
+	35: "resource deadlock avoided",
+	104: "connection reset by peer",
+	6: "no such device or address",
+	56: "invalid request code",
+	36: "file name too long",
+	94: "socket type not supported",
+	73: "RFS specific error",
+	99: "cannot assign requested address",
+	62: "timer expired",
+	93: "protocol not supported",
+	131: "state not recoverable",
+	5: "input/output error",
+	101: "network is unreachable",
+	18: "invalid cross-device link",
+	122: "disk quota exceeded",
+	121: "remote I/O error",
+	28: "no space left on device",
+	8: "exec format error",
+	90: "message too long",
+	33: "numerical argument out of domain",
+	27: "file too large",
+	3: "no such process",
+	44: "channel number out of range",
+	112: "host is down",
+	37: "no locks available",
+	23: "too many open files in system",
+	38: "function not implemented",
+	107: "transport endpoint is not connected",
+	95: "operation not supported",
+	69: "srmount error",
+	103: "software caused connection abort",
+	55: "no anode",
+	106: "transport endpoint is already connected",
+	87: "too many users",
+	92: "protocol not available",
+	24: "too many open files",
+	105: "no buffer space available",
+	46: "level 3 halted",
+	14: "bad address",
+	11: "resource temporarily unavailable",
+	80: "accessing a corrupted shared library",
+	86: "streams pipe error",
+	111: "connection refused",
+	82: "attempting to link in too many shared libraries",
+	17: "file exists",
+	45: "level 2 not synchronized",
+	2: "no such file or directory",
+	65: "package not installed",
+	128: "key has been revoked",
+	113: "no route to host",
+	76: "name not unique on network",
+	20: "not a directory",
+	124: "wrong medium type",
+}
+
diff --git a/src/lib/syscall/zsyscall_linux_386.go b/src/lib/syscall/zsyscall_linux_386.go
new file mode 100644
index 0000000000..ef323b0885
--- /dev/null
+++ b/src/lib/syscall/zsyscall_linux_386.go
@@ -0,0 +1,720 @@
+// mksyscall syscall_linux.go syscall_linux_386.go
+// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
+
+package syscall
+
+import (
+	"syscall";
+	"unsafe";
+)
+
+func pipe(p *[2]_C_int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func utimes(path string, times *[2]Timeval) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(times)), 0);
+	errno = int(e1);
+	return;
+}
+
+func futimesat(dirfd int, path string, times *[2]Timeval) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(times)));
+	errno = int(e1);
+	return;
+}
+
+func Getcwd(buf []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(buf) > 0 { _p0 = &buf[0]; }
+	r0, r1, e1 := Syscall(SYS_GETCWD, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func getgroups(n int, list *_Gid_t) (nn int, errno int) {
+	r0, r1, e1 := Syscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0);
+	nn = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func setgroups(n int, list *_Gid_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0);
+	errno = int(e1);
+	return;
+}
+
+func wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, errno int) {
+	r0, r1, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0);
+	wpid = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Access(path string, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Acct(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Adjtimex(buf *Timex) (state int, errno int) {
+	r0, r1, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0);
+	state = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Chdir(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Chmod(path string, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Chown(path string, uid int, gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
+	errno = int(e1);
+	return;
+}
+
+func Chroot(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Close(fd int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Creat(path string, mode int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_CREAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Dup(oldfd int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0);
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Dup2(oldfd int, newfd int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0);
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func EpollCreate(size int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0);
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func EpollCtl(epfd int, op int, fd int, event *EpollEvent) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func EpollWait(epfd int, events []EpollEvent, msec int) (n int, errno int) {
+	var _p0 *EpollEvent;
+	if len(events) > 0 { _p0 = &events[0]; }
+	r0, r1, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(unsafe.Pointer(_p0)), uintptr(len(events)), uintptr(msec), 0, 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Exit(code int) () {
+	r0, r1, e1 := Syscall(SYS_EXIT_GROUP, uintptr(code), 0, 0);
+	return;
+}
+
+func Faccessat(dirfd int, path string, mode int, flags int) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(flags), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Fallocate(fd int, mode int, off int64, len int64) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(off >> 32), uintptr(len), uintptr(len >> 32));
+	errno = int(e1);
+	return;
+}
+
+func Fchdir(fd int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Fchmod(fd int, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Fchmodat(dirfd int, path string, mode int, flags int) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(flags), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Fchown(fd int, uid int, gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid));
+	errno = int(e1);
+	return;
+}
+
+func Fchownat(dirfd int, path string, uid int, gid int, flags int) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid), uintptr(flags), 0);
+	errno = int(e1);
+	return;
+}
+
+func fcntl(fd int, cmd int, arg int) (val int, errno int) {
+	r0, r1, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg));
+	val = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Fdatasync(fd int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Fstat(fd int, stat *Stat_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Fstatfs(fd int, buf *Statfs_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Fsync(fd int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Ftruncate(fd int, length int64) (errno int) {
+	r0, r1, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length >> 32));
+	errno = int(e1);
+	return;
+}
+
+func Getdents(fd int, buf []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(buf) > 0 { _p0 = &buf[0]; }
+	r0, r1, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Getegid() (egid int) {
+	r0, r1, e1 := Syscall(SYS_GETEGID, 0, 0, 0);
+	egid = int(r0);
+	return;
+}
+
+func Geteuid() (euid int) {
+	r0, r1, e1 := Syscall(SYS_GETEUID, 0, 0, 0);
+	euid = int(r0);
+	return;
+}
+
+func Getgid() (gid int) {
+	r0, r1, e1 := Syscall(SYS_GETGID, 0, 0, 0);
+	gid = int(r0);
+	return;
+}
+
+func Getpgid(pid int) (pgid int, errno int) {
+	r0, r1, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0);
+	pgid = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Getpgrp() (pid int) {
+	r0, r1, e1 := Syscall(SYS_GETPGRP, 0, 0, 0);
+	pid = int(r0);
+	return;
+}
+
+func Getpid() (pid int) {
+	r0, r1, e1 := Syscall(SYS_GETPID, 0, 0, 0);
+	pid = int(r0);
+	return;
+}
+
+func Getppid() (ppid int) {
+	r0, r1, e1 := Syscall(SYS_GETPPID, 0, 0, 0);
+	ppid = int(r0);
+	return;
+}
+
+func Getrlimit(resource int, rlim *Rlimit) (errno int) {
+	r0, r1, e1 := Syscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Getrusage(who int, rusage *Rusage) (errno int) {
+	r0, r1, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Gettid() (tid int) {
+	r0, r1, e1 := Syscall(SYS_GETTID, 0, 0, 0);
+	tid = int(r0);
+	return;
+}
+
+func Gettimeofday(tv *Timeval) (errno int) {
+	r0, r1, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Getuid() (uid int) {
+	r0, r1, e1 := Syscall(SYS_GETUID, 0, 0, 0);
+	uid = int(r0);
+	return;
+}
+
+func Ioperm(from int, num int, on int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on));
+	errno = int(e1);
+	return;
+}
+
+func Iopl(level int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Kill(pid int, sig int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(sig), 0);
+	errno = int(e1);
+	return;
+}
+
+func Klogctl(typ int, buf []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(buf) > 0 { _p0 = &buf[0]; }
+	r0, r1, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Lchown(path string, uid int, gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
+	errno = int(e1);
+	return;
+}
+
+func Link(oldpath string, newpath string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Lstat(path string, stat *Stat_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Mkdir(path string, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
+	errno = int(e1);
+	return;
+}
+
+func Mkdirat(dirfd int, path string, mode int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode));
+	errno = int(e1);
+	return;
+}
+
+func Mknod(path string, mode int, dev int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev));
+	errno = int(e1);
+	return;
+}
+
+func Mknodat(dirfd int, path string, mode int, dev int) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Nanosleep(time *Timespec, leftover *Timespec) (errno int) {
+	r0, r1, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Open(path string, mode int, perm int) (fd int, errno int) {
+	r0, r1, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm));
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Openat(dirfd int, path string, flags int, mode int) (fd int, errno int) {
+	r0, r1, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), uintptr(mode), 0, 0);
+	fd = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Pause() (errno int) {
+	r0, r1, e1 := Syscall(SYS_PAUSE, 0, 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func PivotRoot(newroot string, putold string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(StringBytePtr(newroot))), uintptr(unsafe.Pointer(StringBytePtr(putold))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Pread(fd int, p []byte, offset int64) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset >> 32), 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset >> 32), 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Read(fd int, p []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Readlink(path string, buf []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(buf) > 0 { _p0 = &buf[0]; }
+	r0, r1, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Rename(oldpath string, newpath string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(newdirfd), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Rmdir(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Seek(fd int, offset int64, whence int) (off int64, errno int) {
+	r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(offset >> 32), uintptr(whence), 0, 0);
+	off = int64(r0);
+	errno = int(e1);
+	return;
+}
+
+func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, errno int) {
+	r0, r1, e1 := Syscall6(SYS_SELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0);
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func Setdomainname(p []byte) (errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setfsgid(gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setfsuid(uid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setgid(gid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETGID, uintptr(gid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Sethostname(p []byte) (errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall(SYS_SETHOSTNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setpgid(pid int, pgid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setregid(rgid int, egid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setresgid(rgid int, egid int, sgid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid));
+	errno = int(e1);
+	return;
+}
+
+func Setresuid(ruid int, euid int, suid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid));
+	errno = int(e1);
+	return;
+}
+
+func Setreuid(ruid int, euid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setrlimit(resource int, rlim *Rlimit) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Setsid() (pid int) {
+	r0, r1, e1 := Syscall(SYS_SETSID, 0, 0, 0);
+	pid = int(r0);
+	return;
+}
+
+func Settimeofday(tv *Timeval) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Setuid(uid int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, errno int) {
+	r0, r1, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags));
+	n = int64(r0);
+	errno = int(e1);
+	return;
+}
+
+func Stat(path string, stat *Stat_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Statfs(path string, buf *Statfs_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(buf)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Symlink(oldpath string, newpath string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Sync() () {
+	r0, r1, e1 := Syscall(SYS_SYNC, 0, 0, 0);
+	return;
+}
+
+func SyncFileRange(fd int, off int64, n int64, flags int) (errno int) {
+	r0, r1, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(off >> 32), uintptr(n), uintptr(n >> 32), uintptr(flags));
+	errno = int(e1);
+	return;
+}
+
+func Sysinfo(info *Sysinfo_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Tee(rfd int, wfd int, len int, flags int) (n int64, errno int) {
+	r0, r1, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0);
+	n = int64(r0);
+	errno = int(e1);
+	return;
+}
+
+func Tgkill(tgid int, tid int, sig int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig));
+	errno = int(e1);
+	return;
+}
+
+func Time(t *Time_t) (tt Time_t, errno int) {
+	r0, r1, e1 := Syscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0);
+	tt = Time_t(r0);
+	errno = int(e1);
+	return;
+}
+
+func Times(tms *Tms) (ticks uintptr, errno int) {
+	r0, r1, e1 := Syscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0);
+	ticks = uintptr(r0);
+	errno = int(e1);
+	return;
+}
+
+func Truncate(path string, length int64) (errno int) {
+	r0, r1, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), uintptr(length >> 32));
+	errno = int(e1);
+	return;
+}
+
+func Umask(mask int) (oldmask int) {
+	r0, r1, e1 := Syscall(SYS_UMASK, uintptr(mask), 0, 0);
+	oldmask = int(r0);
+	return;
+}
+
+func Uname(buf *Utsname) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Unlink(path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Unlinkat(dirfd int, path string) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), 0);
+	errno = int(e1);
+	return;
+}
+
+func Unshare(flags int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func Ustat(dev int, ubuf *Ustat_t) (errno int) {
+	r0, r1, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Utime(path string, buf *Utimbuf) (errno int) {
+	r0, r1, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(buf)), 0);
+	errno = int(e1);
+	return;
+}
+
+func Write(fd int, p []byte) (n int, errno int) {
+	var _p0 *byte;
+	if len(p) > 0 { _p0 = &p[0]; }
+	r0, r1, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func exitThread(code int) (errno int) {
+	r0, r1, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0);
+	errno = int(e1);
+	return;
+}
+
+func read(fd int, p *byte, np int) (n int, errno int) {
+	r0, r1, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+func write(fd int, p *byte, np int) (n int, errno int) {
+	r0, r1, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np));
+	n = int(r0);
+	errno = int(e1);
+	return;
+}
+
+
+
diff --git a/src/lib/syscall/zsysnum_linux_386.go b/src/lib/syscall/zsysnum_linux_386.go
new file mode 100644
index 0000000000..46c1112f8c
--- /dev/null
+++ b/src/lib/syscall/zsysnum_linux_386.go
@@ -0,0 +1,319 @@
+// Generated by mklinux; DO NOT EDIT.
+// mklinux /usr/include/asm/unistd_32.h
+
+package syscall
+
+const(
+	SYS_RESTART_SYSCALL = 0;
+	SYS_EXIT = 1;
+	SYS_FORK = 2;
+	SYS_READ = 3;
+	SYS_WRITE = 4;
+	SYS_OPEN = 5;
+	SYS_CLOSE = 6;
+	SYS_WAITPID = 7;
+	SYS_CREAT = 8;
+	SYS_LINK = 9;
+	SYS_UNLINK = 10;
+	SYS_EXECVE = 11;
+	SYS_CHDIR = 12;
+	SYS_TIME = 13;
+	SYS_MKNOD = 14;
+	SYS_CHMOD = 15;
+	SYS_LCHOWN = 16;
+	SYS_BREAK = 17;
+	SYS_OLDSTAT = 18;
+	SYS_LSEEK = 19;
+	SYS_GETPID = 20;
+	SYS_MOUNT = 21;
+	SYS_UMOUNT = 22;
+	SYS_SETUID = 23;
+	SYS_GETUID = 24;
+	SYS_STIME = 25;
+	SYS_PTRACE = 26;
+	SYS_ALARM = 27;
+	SYS_OLDFSTAT = 28;
+	SYS_PAUSE = 29;
+	SYS_UTIME = 30;
+	SYS_STTY = 31;
+	SYS_GTTY = 32;
+	SYS_ACCESS = 33;
+	SYS_NICE = 34;
+	SYS_FTIME = 35;
+	SYS_SYNC = 36;
+	SYS_KILL = 37;
+	SYS_RENAME = 38;
+	SYS_MKDIR = 39;
+	SYS_RMDIR = 40;
+	SYS_DUP = 41;
+	SYS_PIPE = 42;
+	SYS_TIMES = 43;
+	SYS_PROF = 44;
+	SYS_BRK = 45;
+	SYS_SETGID = 46;
+	SYS_GETGID = 47;
+	SYS_SIGNAL = 48;
+	SYS_GETEUID = 49;
+	SYS_GETEGID = 50;
+	SYS_ACCT = 51;
+	SYS_UMOUNT2 = 52;
+	SYS_LOCK = 53;
+	SYS_IOCTL = 54;
+	SYS_FCNTL = 55;
+	SYS_MPX = 56;
+	SYS_SETPGID = 57;
+	SYS_ULIMIT = 58;
+	SYS_OLDOLDUNAME = 59;
+	SYS_UMASK = 60;
+	SYS_CHROOT = 61;
+	SYS_USTAT = 62;
+	SYS_DUP2 = 63;
+	SYS_GETPPID = 64;
+	SYS_GETPGRP = 65;
+	SYS_SETSID = 66;
+	SYS_SIGACTION = 67;
+	SYS_SGETMASK = 68;
+	SYS_SSETMASK = 69;
+	SYS_SETREUID = 70;
+	SYS_SETREGID = 71;
+	SYS_SIGSUSPEND = 72;
+	SYS_SIGPENDING = 73;
+	SYS_SETHOSTNAME = 74;
+	SYS_SETRLIMIT = 75;
+	SYS_GETRLIMIT = 76;
+	SYS_GETRUSAGE = 77;
+	SYS_GETTIMEOFDAY = 78;
+	SYS_SETTIMEOFDAY = 79;
+	SYS_GETGROUPS = 80;
+	SYS_SETGROUPS = 81;
+	SYS_SELECT = 82;
+	SYS_SYMLINK = 83;
+	SYS_OLDLSTAT = 84;
+	SYS_READLINK = 85;
+	SYS_USELIB = 86;
+	SYS_SWAPON = 87;
+	SYS_REBOOT = 88;
+	SYS_READDIR = 89;
+	SYS_MMAP = 90;
+	SYS_MUNMAP = 91;
+	SYS_TRUNCATE = 92;
+	SYS_FTRUNCATE = 93;
+	SYS_FCHMOD = 94;
+	SYS_FCHOWN = 95;
+	SYS_GETPRIORITY = 96;
+	SYS_SETPRIORITY = 97;
+	SYS_PROFIL = 98;
+	SYS_STATFS = 99;
+	SYS_FSTATFS = 100;
+	SYS_IOPERM = 101;
+	SYS_SOCKETCALL = 102;
+	SYS_SYSLOG = 103;
+	SYS_SETITIMER = 104;
+	SYS_GETITIMER = 105;
+	SYS_STAT = 106;
+	SYS_LSTAT = 107;
+	SYS_FSTAT = 108;
+	SYS_OLDUNAME = 109;
+	SYS_IOPL = 110;
+	SYS_VHANGUP = 111;
+	SYS_IDLE = 112;
+	SYS_VM86OLD = 113;
+	SYS_WAIT4 = 114;
+	SYS_SWAPOFF = 115;
+	SYS_SYSINFO = 116;
+	SYS_IPC = 117;
+	SYS_FSYNC = 118;
+	SYS_SIGRETURN = 119;
+	SYS_CLONE = 120;
+	SYS_SETDOMAINNAME = 121;
+	SYS_UNAME = 122;
+	SYS_MODIFY_LDT = 123;
+	SYS_ADJTIMEX = 124;
+	SYS_MPROTECT = 125;
+	SYS_SIGPROCMASK = 126;
+	SYS_CREATE_MODULE = 127;
+	SYS_INIT_MODULE = 128;
+	SYS_DELETE_MODULE = 129;
+	SYS_GET_KERNEL_SYMS = 130;
+	SYS_QUOTACTL = 131;
+	SYS_GETPGID = 132;
+	SYS_FCHDIR = 133;
+	SYS_BDFLUSH = 134;
+	SYS_SYSFS = 135;
+	SYS_PERSONALITY = 136;
+	SYS_AFS_SYSCALL = 137;
+	SYS_SETFSUID = 138;
+	SYS_SETFSGID = 139;
+	SYS__LLSEEK = 140;
+	SYS_GETDENTS = 141;
+	SYS__NEWSELECT = 142;
+	SYS_FLOCK = 143;
+	SYS_MSYNC = 144;
+	SYS_READV = 145;
+	SYS_WRITEV = 146;
+	SYS_GETSID = 147;
+	SYS_FDATASYNC = 148;
+	SYS__SYSCTL = 149;
+	SYS_MLOCK = 150;
+	SYS_MUNLOCK = 151;
+	SYS_MLOCKALL = 152;
+	SYS_MUNLOCKALL = 153;
+	SYS_SCHED_SETPARAM = 154;
+	SYS_SCHED_GETPARAM = 155;
+	SYS_SCHED_SETSCHEDULER = 156;
+	SYS_SCHED_GETSCHEDULER = 157;
+	SYS_SCHED_YIELD = 158;
+	SYS_SCHED_GET_PRIORITY_MAX = 159;
+	SYS_SCHED_GET_PRIORITY_MIN = 160;
+	SYS_SCHED_RR_GET_INTERVAL = 161;
+	SYS_NANOSLEEP = 162;
+	SYS_MREMAP = 163;
+	SYS_SETRESUID = 164;
+	SYS_GETRESUID = 165;
+	SYS_VM86 = 166;
+	SYS_QUERY_MODULE = 167;
+	SYS_POLL = 168;
+	SYS_NFSSERVCTL = 169;
+	SYS_SETRESGID = 170;
+	SYS_GETRESGID = 171;
+	SYS_PRCTL = 172;
+	SYS_RT_SIGRETURN = 173;
+	SYS_RT_SIGACTION = 174;
+	SYS_RT_SIGPROCMASK = 175;
+	SYS_RT_SIGPENDING = 176;
+	SYS_RT_SIGTIMEDWAIT = 177;
+	SYS_RT_SIGQUEUEINFO = 178;
+	SYS_RT_SIGSUSPEND = 179;
+	SYS_PREAD64 = 180;
+	SYS_PWRITE64 = 181;
+	SYS_CHOWN = 182;
+	SYS_GETCWD = 183;
+	SYS_CAPGET = 184;
+	SYS_CAPSET = 185;
+	SYS_SIGALTSTACK = 186;
+	SYS_SENDFILE = 187;
+	SYS_GETPMSG = 188;
+	SYS_PUTPMSG = 189;
+	SYS_VFORK = 190;
+	SYS_UGETRLIMIT = 191;
+	SYS_MMAP2 = 192;
+	SYS_TRUNCATE64 = 193;
+	SYS_FTRUNCATE64 = 194;
+	SYS_STAT64 = 195;
+	SYS_LSTAT64 = 196;
+	SYS_FSTAT64 = 197;
+	SYS_LCHOWN32 = 198;
+	SYS_GETUID32 = 199;
+	SYS_GETGID32 = 200;
+	SYS_GETEUID32 = 201;
+	SYS_GETEGID32 = 202;
+	SYS_SETREUID32 = 203;
+	SYS_SETREGID32 = 204;
+	SYS_GETGROUPS32 = 205;
+	SYS_SETGROUPS32 = 206;
+	SYS_FCHOWN32 = 207;
+	SYS_SETRESUID32 = 208;
+	SYS_GETRESUID32 = 209;
+	SYS_SETRESGID32 = 210;
+	SYS_GETRESGID32 = 211;
+	SYS_CHOWN32 = 212;
+	SYS_SETUID32 = 213;
+	SYS_SETGID32 = 214;
+	SYS_SETFSUID32 = 215;
+	SYS_SETFSGID32 = 216;
+	SYS_PIVOT_ROOT = 217;
+	SYS_MINCORE = 218;
+	SYS_MADVISE = 219;
+	SYS_MADVISE1 = 219;
+	SYS_GETDENTS64 = 220;
+	SYS_FCNTL64 = 221;
+	SYS_GETTID = 224;
+	SYS_READAHEAD = 225;
+	SYS_SETXATTR = 226;
+	SYS_LSETXATTR = 227;
+	SYS_FSETXATTR = 228;
+	SYS_GETXATTR = 229;
+	SYS_LGETXATTR = 230;
+	SYS_FGETXATTR = 231;
+	SYS_LISTXATTR = 232;
+	SYS_LLISTXATTR = 233;
+	SYS_FLISTXATTR = 234;
+	SYS_REMOVEXATTR = 235;
+	SYS_LREMOVEXATTR = 236;
+	SYS_FREMOVEXATTR = 237;
+	SYS_TKILL = 238;
+	SYS_SENDFILE64 = 239;
+	SYS_FUTEX = 240;
+	SYS_SCHED_SETAFFINITY = 241;
+	SYS_SCHED_GETAFFINITY = 242;
+	SYS_SET_THREAD_AREA = 243;
+	SYS_GET_THREAD_AREA = 244;
+	SYS_IO_SETUP = 245;
+	SYS_IO_DESTROY = 246;
+	SYS_IO_GETEVENTS = 247;
+	SYS_IO_SUBMIT = 248;
+	SYS_IO_CANCEL = 249;
+	SYS_FADVISE64 = 250;
+	SYS_EXIT_GROUP = 252;
+	SYS_LOOKUP_DCOOKIE = 253;
+	SYS_EPOLL_CREATE = 254;
+	SYS_EPOLL_CTL = 255;
+	SYS_EPOLL_WAIT = 256;
+	SYS_REMAP_FILE_PAGES = 257;
+	SYS_SET_TID_ADDRESS = 258;
+	SYS_TIMER_CREATE = 259;
+	SYS_STATFS64 = 268;
+	SYS_FSTATFS64 = 269;
+	SYS_TGKILL = 270;
+	SYS_UTIMES = 271;
+	SYS_FADVISE64_64 = 272;
+	SYS_VSERVER = 273;
+	SYS_MBIND = 274;
+	SYS_GET_MEMPOLICY = 275;
+	SYS_SET_MEMPOLICY = 276;
+	SYS_MQ_OPEN = 277;
+	SYS_KEXEC_LOAD = 283;
+	SYS_WAITID = 284;
+	SYS_ADD_KEY = 286;
+	SYS_REQUEST_KEY = 287;
+	SYS_KEYCTL = 288;
+	SYS_IOPRIO_SET = 289;
+	SYS_IOPRIO_GET = 290;
+	SYS_INOTIFY_INIT = 291;
+	SYS_INOTIFY_ADD_WATCH = 292;
+	SYS_INOTIFY_RM_WATCH = 293;
+	SYS_MIGRATE_PAGES = 294;
+	SYS_OPENAT = 295;
+	SYS_MKDIRAT = 296;
+	SYS_MKNODAT = 297;
+	SYS_FCHOWNAT = 298;
+	SYS_FUTIMESAT = 299;
+	SYS_FSTATAT64 = 300;
+	SYS_UNLINKAT = 301;
+	SYS_RENAMEAT = 302;
+	SYS_LINKAT = 303;
+	SYS_SYMLINKAT = 304;
+	SYS_READLINKAT = 305;
+	SYS_FCHMODAT = 306;
+	SYS_FACCESSAT = 307;
+	SYS_PSELECT6 = 308;
+	SYS_PPOLL = 309;
+	SYS_UNSHARE = 310;
+	SYS_SET_ROBUST_LIST = 311;
+	SYS_GET_ROBUST_LIST = 312;
+	SYS_SPLICE = 313;
+	SYS_SYNC_FILE_RANGE = 314;
+	SYS_TEE = 315;
+	SYS_VMSPLICE = 316;
+	SYS_MOVE_PAGES = 317;
+	SYS_GETCPU = 318;
+	SYS_EPOLL_PWAIT = 319;
+	SYS_UTIMENSAT = 320;
+	SYS_SIGNALFD = 321;
+	SYS_TIMERFD = 322;
+	SYS_EVENTFD = 323;
+	SYS_FALLOCATE = 324;
+)
+
+func _darwin_system_call_conflict() {
+}
diff --git a/src/lib/syscall/ztypes_linux_386.go b/src/lib/syscall/ztypes_linux_386.go
new file mode 100644
index 0000000000..c3a0837621
--- /dev/null
+++ b/src/lib/syscall/ztypes_linux_386.go
@@ -0,0 +1,297 @@
+// godefs -gsyscall -f-m32 types_linux.c types_linux_386.c
+
+// MACHINE GENERATED - DO NOT EDIT.
+
+package syscall
+
+// Constants
+const (
+	sizeofPtr = 0x4;
+	sizeofShort = 0x2;
+	sizeofInt = 0x4;
+	sizeofLong = 0x4;
+	sizeofLongLong = 0x8;
+	PathMax = 0x1000;
+	O_RDONLY = 0;
+	O_WRONLY = 0x1;
+	O_RDWR = 0x2;
+	O_APPEND = 0x400;
+	O_ASYNC = 0x2000;
+	O_CREAT = 0x40;
+	O_NOCTTY = 0x100;
+	O_NONBLOCK = 0x800;
+	O_SYNC = 0x1000;
+	O_TRUNC = 0x200;
+	O_CLOEXEC = 0;
+	F_GETFD = 0x1;
+	F_SETFD = 0x2;
+	F_GETFL = 0x3;
+	F_SETFL = 0x4;
+	FD_CLOEXEC = 0x1;
+	NAME_MAX = 0xff;
+	S_IFMT = 0xf000;
+	S_IFIFO = 0x1000;
+	S_IFCHR = 0x2000;
+	S_IFDIR = 0x4000;
+	S_IFBLK = 0x6000;
+	S_IFREG = 0x8000;
+	S_IFLNK = 0xa000;
+	S_IFSOCK = 0xc000;
+	S_ISUID = 0x800;
+	S_ISGID = 0x400;
+	S_ISVTX = 0x200;
+	S_IRUSR = 0x100;
+	S_IWUSR = 0x80;
+	S_IXUSR = 0x40;
+	WNOHANG = 0x1;
+	WUNTRACED = 0x2;
+	WEXITED = 0x4;
+	WSTOPPED = 0x2;
+	WCONTINUED = 0x8;
+	WNOWAIT = 0x1000000;
+	AF_UNIX = 0x1;
+	AF_INET = 0x2;
+	AF_INET6 = 0xa;
+	SOCK_STREAM = 0x1;
+	SOCK_DGRAM = 0x2;
+	SOCK_RAW = 0x3;
+	SOCK_SEQPACKET = 0x5;
+	SOL_SOCKET = 0x1;
+	SO_REUSEADDR = 0x2;
+	SO_KEEPALIVE = 0x9;
+	SO_DONTROUTE = 0x5;
+	SO_BROADCAST = 0x6;
+	SO_LINGER = 0xd;
+	SO_SNDBUF = 0x7;
+	SO_RCVBUF = 0x8;
+	SO_SNDTIMEO = 0x15;
+	SO_RCVTIMEO = 0x14;
+	IPPROTO_TCP = 0x6;
+	IPPROTO_UDP = 0x11;
+	TCP_NODELAY = 0x1;
+	SOMAXCONN = 0x80;
+	SizeofSockaddrInet4 = 0x10;
+	SizeofSockaddrInet6 = 0x1c;
+	SizeofSockaddrAny = 0x1c;
+	SizeofSockaddrUnix = 0x6e;
+	EPOLLIN = 0x1;
+	EPOLLRDHUP = 0x2000;
+	EPOLLOUT = 0x4;
+	EPOLLONESHOT = 0x40000000;
+	EPOLL_CTL_MOD = 0x3;
+	EPOLL_CTL_ADD = 0x1;
+	EPOLL_CTL_DEL = 0x2;
+)
+
+// Types
+
+type Timespec struct {
+	Sec int32;
+	Nsec int32;
+}
+
+type Timeval struct {
+	Sec int32;
+	Usec int32;
+}
+
+type Timex struct {
+	Modes uint32;
+	Offset int32;
+	Freq int32;
+	Maxerror int32;
+	Esterror int32;
+	Status int32;
+	Constant int32;
+	Precision int32;
+	Tolerance int32;
+	Time Timeval;
+	Tick int32;
+	Ppsfreq int32;
+	Jitter int32;
+	Shift int32;
+	Stabil int32;
+	Jitcnt int32;
+	Calcnt int32;
+	Errcnt int32;
+	Stbcnt int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+	 int32;
+}
+
+type Time_t int32
+
+type Tms struct {
+	Utime int32;
+	Stime int32;
+	Cutime int32;
+	Cstime int32;
+}
+
+type Utimbuf struct {
+	Actime int32;
+	Modtime int32;
+}
+
+type Rusage struct {
+	Utime Timeval;
+	Stime Timeval;
+	Maxrss int32;
+	Ixrss int32;
+	Idrss int32;
+	Isrss int32;
+	Minflt int32;
+	Majflt int32;
+	Nswap int32;
+	Inblock int32;
+	Oublock int32;
+	Msgsnd int32;
+	Msgrcv int32;
+	Nsignals int32;
+	Nvcsw int32;
+	Nivcsw int32;
+}
+
+type Rlimit struct {
+	Cur uint32;
+	Max uint32;
+}
+
+type _C_int int32
+
+type _Gid_t uint32
+
+type Stat_t struct {
+	Dev uint64;
+	__pad1 uint16;
+	Pad0 [2]byte;
+	Ino uint32;
+	Mode uint32;
+	Nlink uint32;
+	Uid uint32;
+	Gid uint32;
+	Rdev uint64;
+	__pad2 uint16;
+	Pad1 [2]byte;
+	Size int32;
+	Blksize int32;
+	Blocks int32;
+	Atim Timespec;
+	Mtim Timespec;
+	Ctim Timespec;
+	__unused4 uint32;
+	__unused5 uint32;
+}
+
+type Statfs_t struct {
+	Type int32;
+	Bsize int32;
+	Blocks uint32;
+	Bfree uint32;
+	Bavail uint32;
+	Files uint32;
+	Ffree uint32;
+	Fsid [8]byte /* __fsid_t */;
+	Namelen int32;
+	Frsize int32;
+	Spare [5]int32;
+}
+
+type Dirent struct {
+	Ino uint32;
+	Off int32;
+	Reclen uint16;
+	Type uint8;
+	Name [256]int8;
+	Pad0 [1]byte;
+}
+
+type RawSockaddrInet4 struct {
+	Family uint16;
+	Port uint16;
+	Addr [4]byte /* in_addr */;
+	Zero [8]uint8;
+}
+
+type RawSockaddrInet6 struct {
+	Family uint16;
+	Port uint16;
+	Flowinfo uint32;
+	Addr [16]byte /* in6_addr */;
+	Scope_id uint32;
+}
+
+type RawSockaddrUnix struct {
+	Family uint16;
+	Path [108]int8;
+}
+
+type RawSockaddr struct {
+	Family uint16;
+	Data [14]int8;
+}
+
+type RawSockaddrAny struct {
+	Addr RawSockaddr;
+	Pad [12]int8;
+}
+
+type _Socklen uint32
+
+type Linger struct {
+	Onoff int32;
+	Linger int32;
+}
+
+type FdSet struct {
+	__fds_bits [32]int32;
+}
+
+type Sysinfo_t struct {
+	Uptime int32;
+	Loads [3]uint32;
+	Totalram uint32;
+	Freeram uint32;
+	Sharedram uint32;
+	Bufferram uint32;
+	Totalswap uint32;
+	Freeswap uint32;
+	Procs uint16;
+	Pad uint16;
+	Totalhigh uint32;
+	Freehigh uint32;
+	Unit uint32;
+	_f [8]int8;
+}
+
+type Utsname struct {
+	Sysname [65]int8;
+	Nodename [65]int8;
+	Release [65]int8;
+	Version [65]int8;
+	Machine [65]int8;
+	__domainname [65]int8;
+}
+
+type Ustat_t struct {
+	Tfree int32;
+	Tinode uint32;
+	Fname [6]int8;
+	Fpack [6]int8;
+}
+
+type EpollEvent struct {
+	Events uint32;
+	Fd int32;
+	Pad int32;
+}
