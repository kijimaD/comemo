commit 9ac4449cb2bf8fa1fc414a9cbc67c5a46af8ea51
Author: Russ Cox <rsc@golang.org>
Date:   Fri Nov 20 11:45:05 2009 -0800

    gofmt -r 'α[β:len(α)] -> α[β:]' -w src/cmd src/pkg
    
    R=r, gri
    CC=golang-dev
    https://golang.org/cl/156115
---
 src/cmd/cgo/gcc.go                       |  4 ++--
 src/cmd/cgo/util.go                      |  2 +-
 src/cmd/ebnflint/ebnflint.go             |  4 ++--
 src/cmd/godoc/godoc.go                   | 10 +++++-----
 src/cmd/godoc/main.go                    |  2 +-
 src/cmd/goyacc/goyacc.go                 | 10 +++++-----
 src/pkg/archive/tar/common.go            |  2 +-
 src/pkg/archive/tar/reader.go            |  2 +-
 src/pkg/archive/tar/writer_test.go       |  4 ++--
 src/pkg/asn1/asn1.go                     |  8 ++++----
 src/pkg/asn1/common.go                   |  4 ++--
 src/pkg/big/int.go                       |  6 +++---
 src/pkg/big/nat.go                       |  4 ++--
 src/pkg/bignum/integer.go                |  2 +-
 src/pkg/bignum/rational.go               |  6 +++---
 src/pkg/bufio/bufio.go                   | 10 +++++-----
 src/pkg/bytes/buffer.go                  |  6 +++---
 src/pkg/bytes/buffer_test.go             |  4 ++--
 src/pkg/bytes/bytes.go                   |  8 ++++----
 src/pkg/compress/flate/deflate.go        |  2 +-
 src/pkg/compress/flate/huffman_code.go   |  2 +-
 src/pkg/crypto/block/eax.go              |  2 +-
 src/pkg/crypto/block/ecb.go              |  6 +++---
 src/pkg/crypto/block/xor.go              |  8 ++++----
 src/pkg/crypto/md5/md5.go                |  4 ++--
 src/pkg/crypto/md5/md5block.go           |  2 +-
 src/pkg/crypto/rsa/pkcs1v15.go           |  4 ++--
 src/pkg/crypto/rsa/rsa.go                | 12 ++++++------
 src/pkg/crypto/sha1/sha1.go              |  4 ++--
 src/pkg/crypto/sha1/sha1block.go         |  2 +-
 src/pkg/crypto/tls/handshake_messages.go | 26 +++++++++++++-------------
 src/pkg/crypto/tls/handshake_server.go   |  4 ++--
 src/pkg/crypto/tls/prf.go                | 16 ++++++++--------
 src/pkg/crypto/tls/record_process.go     |  6 +++---
 src/pkg/crypto/tls/record_read.go        |  2 +-
 src/pkg/crypto/tls/tls.go                |  2 +-
 src/pkg/debug/dwarf/buf.go               |  8 ++++----
 src/pkg/debug/dwarf/entry.go             |  4 ++--
 src/pkg/debug/elf/file.go                |  2 +-
 src/pkg/debug/gosym/pclntab.go           |  4 ++--
 src/pkg/debug/gosym/pclntab_test.go      |  4 ++--
 src/pkg/debug/gosym/symtab.go            | 16 ++++++++--------
 src/pkg/debug/macho/file.go              |  2 +-
 src/pkg/encoding/ascii85/ascii85.go      | 14 +++++++-------
 src/pkg/encoding/base64/base64.go        | 12 ++++++------
 src/pkg/encoding/binary/binary.go        | 16 ++++++++--------
 src/pkg/encoding/git85/git.go            | 10 +++++-----
 src/pkg/encoding/pem/pem.go              |  8 ++++----
 src/pkg/exp/4s/4s.go                     |  2 +-
 src/pkg/exp/datafmt/datafmt.go           |  4 ++--
 src/pkg/exp/datafmt/parser.go            |  4 ++--
 src/pkg/exp/eval/expr.go                 |  4 ++--
 src/pkg/exp/eval/stmt.go                 |  4 ++--
 src/pkg/exp/nacl/av/event.go             |  2 +-
 src/pkg/exp/nacl/srpc/client.go          |  4 ++--
 src/pkg/exp/nacl/srpc/msg.go             | 10 +++++-----
 src/pkg/exp/ogle/cmd.go                  |  4 ++--
 src/pkg/exp/ogle/process.go              |  6 +++---
 src/pkg/exp/ogle/rruntime.go             |  2 +-
 src/pkg/flag/flag.go                     |  6 +++---
 src/pkg/fmt/fmt_test.go                  |  2 +-
 src/pkg/fmt/print.go                     |  4 ++--
 src/pkg/go/doc/comment.go                |  8 ++++----
 src/pkg/go/doc/doc.go                    |  4 ++--
 src/pkg/go/printer/printer.go            |  8 ++++----
 src/pkg/go/scanner/scanner.go            |  4 ++--
 src/pkg/http/fs.go                       |  6 +++---
 src/pkg/http/request.go                  |  2 +-
 src/pkg/http/url.go                      | 10 +++++-----
 src/pkg/image/png/reader.go              |  4 ++--
 src/pkg/image/png/writer.go              | 12 ++++++------
 src/pkg/io/io.go                         |  2 +-
 src/pkg/io/pipe.go                       |  2 +-
 src/pkg/json/generic.go                  |  2 +-
 src/pkg/json/parse.go                    |  6 +++---
 src/pkg/log/log.go                       |  4 ++--
 src/pkg/math/atan.go                     |  2 +-
 src/pkg/math/sin.go                      |  2 +-
 src/pkg/net/fd.go                        |  2 +-
 src/pkg/net/fd_darwin.go                 |  2 +-
 src/pkg/net/fd_freebsd.go                |  2 +-
 src/pkg/net/ip.go                        |  6 +++---
 src/pkg/net/ipsock.go                    |  2 +-
 src/pkg/net/parse.go                     |  4 ++--
 src/pkg/net/port.go                      |  2 +-
 src/pkg/net/server_test.go               |  4 ++--
 src/pkg/os/env.go                        |  2 +-
 src/pkg/os/exec.go                       |  2 +-
 src/pkg/os/file.go                       |  4 ++--
 src/pkg/os/stat_darwin.go                |  2 +-
 src/pkg/os/stat_freebsd.go               |  2 +-
 src/pkg/os/stat_linux.go                 |  2 +-
 src/pkg/os/stat_nacl.go                  |  2 +-
 src/pkg/patch/git.go                     |  2 +-
 src/pkg/patch/patch.go                   | 16 ++++++++--------
 src/pkg/patch/textdiff.go                |  6 +++---
 src/pkg/path/path.go                     |  4 ++--
 src/pkg/rand/rand_test.go                | 12 ++++++------
 src/pkg/regexp/regexp.go                 | 14 +++++++-------
 src/pkg/strconv/atoi.go                  |  6 +++---
 src/pkg/strconv/atoi_test.go             |  6 +++---
 src/pkg/strconv/ftoa.go                  |  2 +-
 src/pkg/strconv/itoa.go                  |  2 +-
 src/pkg/strconv/quote.go                 | 14 +++++++-------
 src/pkg/strings/reader.go                |  4 ++--
 src/pkg/strings/strings.go               |  6 +++---
 src/pkg/syscall/errstr.go                |  2 +-
 src/pkg/syscall/syscall_linux.go         | 12 ++++++------
 src/pkg/tabwriter/tabwriter.go           |  2 +-
 src/pkg/template/format.go               |  2 +-
 src/pkg/template/template.go             |  4 ++--
 src/pkg/testing/iotest/reader.go         |  2 +-
 src/pkg/testing/regexp.go                |  2 +-
 src/pkg/time/zoneinfo.go                 |  6 +++---
 src/pkg/unicode/maketables.go            |  2 +-
 src/pkg/utf8/utf8.go                     |  2 +-
 src/pkg/xml/read.go                      |  2 +-
 src/pkg/xml/xml.go                       |  6 +++---
 118 files changed, 308 insertions(+), 308 deletions(-)

diff --git a/src/cmd/cgo/gcc.go b/src/cmd/cgo/gcc.go
index 255946d9c5..7614f5a3b1 100644
--- a/src/cmd/cgo/gcc.go
+++ b/src/cmd/cgo/gcc.go
@@ -65,7 +65,7 @@ func (p *Prog) loadDebugInfo() {
 		if len(line) < 9 || line[0:9] != "cgo-test:" {
 			continue
 		}
-		line = line[9:len(line)];
+		line = line[9:];
 		colon := strings.Index(line, ":");
 		if colon < 0 {
 			continue
@@ -148,7 +148,7 @@ func (p *Prog) loadDebugInfo() {
 		if !ok || t == nil {
 			fatal("internal error: %s has non-pointer type", name)
 		}
-		i, err := strconv.Atoi(name[7:len(name)]);
+		i, err := strconv.Atoi(name[7:]);
 		if err != nil {
 			fatal("malformed __cgo__ name: %s", name)
 		}
diff --git a/src/cmd/cgo/util.go b/src/cmd/cgo/util.go
index 9e9d9aef1e..53b3ef6a30 100644
--- a/src/cmd/cgo/util.go
+++ b/src/cmd/cgo/util.go
@@ -19,7 +19,7 @@ func (r ByteReaderAt) ReadAt(p []byte, off int64) (n int, err os.Error) {
 	if off >= int64(len(r)) || off < 0 {
 		return 0, os.EOF
 	}
-	return copy(p, r[off:len(r)]), nil;
+	return copy(p, r[off:]), nil;
 }
 
 // run runs the command argv, feeding in stdin on standard input.
diff --git a/src/cmd/ebnflint/ebnflint.go b/src/cmd/ebnflint/ebnflint.go
index 394e473a84..bd0ea34b5c 100644
--- a/src/cmd/ebnflint/ebnflint.go
+++ b/src/cmd/ebnflint/ebnflint.go
@@ -54,7 +54,7 @@ func extractEBNF(src []byte) []byte {
 		}
 
 		// j = end of EBNF text (or end of source)
-		j := bytes.Index(src[i:len(src)], close);	// close marker
+		j := bytes.Index(src[i:], close);	// close marker
 		if j < 0 {
 			j = len(src) - i
 		}
@@ -64,7 +64,7 @@ func extractEBNF(src []byte) []byte {
 		buf.Write(src[i:j]);
 
 		// advance
-		src = src[j:len(src)];
+		src = src[j:];
 	}
 
 	return buf.Bytes();
diff --git a/src/cmd/godoc/godoc.go b/src/cmd/godoc/godoc.go
index c6f26a8394..7cf5a85197 100644
--- a/src/cmd/godoc/godoc.go
+++ b/src/cmd/godoc/godoc.go
@@ -367,11 +367,11 @@ func (root *Directory) listing(skipRoot bool) *DirList {
 		// crashes and check)
 		path := d.Path;
 		if strings.HasPrefix(d.Path, root.Path) {
-			path = d.Path[len(root.Path):len(d.Path)]
+			path = d.Path[len(root.Path):]
 		}
 		// remove trailing '/' if any - path must be relative
 		if len(path) > 0 && path[0] == '/' {
-			path = path[1:len(path)]
+			path = path[1:]
 		}
 		p.Path = path;
 		p.Name = d.Name;
@@ -451,7 +451,7 @@ func parse(path string, mode uint) (*ast.File, *parseErrors) {
 				errs[i].line = r.Pos.Line;
 				errs[i].msg = r.Msg;
 			}
-			errs[len(errors)].src = src[offs:len(src)];
+			errs[len(errors)].src = src[offs:];
 		} else {
 			// single error of unspecified type
 			errs = make([]parseError, 2);
@@ -589,7 +589,7 @@ func textFmt(w io.Writer, x interface{}, format string) {
 
 func removePrefix(s, prefix string) string {
 	if strings.HasPrefix(s, prefix) {
-		return s[len(prefix):len(s)]
+		return s[len(prefix):]
 	}
 	return s;
 }
@@ -1049,7 +1049,7 @@ func (h *httpHandler) ServeHTTP(c *http.Conn, r *http.Request) {
 	}
 
 	path := r.URL.Path;
-	path = path[len(h.pattern):len(path)];
+	path = path[len(h.pattern):];
 	info := h.getPageInfo(path);
 
 	var buf bytes.Buffer;
diff --git a/src/cmd/godoc/main.go b/src/cmd/godoc/main.go
index a59bd80289..f303b987f8 100644
--- a/src/cmd/godoc/main.go
+++ b/src/cmd/godoc/main.go
@@ -230,7 +230,7 @@ func main() {
 
 	if info.PDoc != nil && flag.NArg() > 1 {
 		args := flag.Args();
-		info.PDoc.Filter(args[1:len(args)]);
+		info.PDoc.Filter(args[1:]);
 	}
 
 	if err := packageText.Execute(info, os.Stdout); err != nil {
diff --git a/src/cmd/goyacc/goyacc.go b/src/cmd/goyacc/goyacc.go
index 95e34d6667..0d8d8857eb 100644
--- a/src/cmd/goyacc/goyacc.go
+++ b/src/cmd/goyacc/goyacc.go
@@ -772,7 +772,7 @@ func defin(nt int, s string) int {
 			}
 		} else if s[2] == 'u' && len(s) == 2+1+4 {	// \unnnn sequence
 			val = 0;
-			s = s[3:len(s)];
+			s = s[3:];
 			for s != "" {
 				c := int(s[0]);
 				switch {
@@ -786,7 +786,7 @@ func defin(nt int, s string) int {
 					error("illegal \\unnnn construction")
 				}
 				val = val*16 + c;
-				s = s[1:len(s)];
+				s = s[1:];
 			}
 			if val == 0 {
 				error("'\\u0000' is illegal")
@@ -1438,7 +1438,7 @@ func symnam(i int) string {
 		s = tokset[i].name
 	}
 	if s[0] == ' ' {
-		s = s[1:len(s)]
+		s = s[1:]
 	}
 	return s;
 }
@@ -1476,7 +1476,7 @@ func cpres() {
 		c := i + NTBASE;
 		for j := 0; j < nprod; j++ {
 			if prdptr[j][0] == c {
-				curres[n] = prdptr[j][1:len(prdptr[j])];
+				curres[n] = prdptr[j][1:];
 				n++;
 			}
 		}
@@ -1755,7 +1755,7 @@ func stagen() {
 			}
 
 			if first != 0 {
-				indgo[i] = apack(temp1[1:len(temp1)], nnonter-1) - 1
+				indgo[i] = apack(temp1[1:], nnonter-1) - 1
 			}
 
 			more++;
diff --git a/src/pkg/archive/tar/common.go b/src/pkg/archive/tar/common.go
index adf8e3cd3c..792a3050b7 100644
--- a/src/pkg/archive/tar/common.go
+++ b/src/pkg/archive/tar/common.go
@@ -70,6 +70,6 @@ type slicer []byte
 
 func (sp *slicer) next(n int) (b []byte) {
 	s := *sp;
-	b, *sp = s[0:n], s[n:len(s)];
+	b, *sp = s[0:n], s[n:];
 	return;
 }
diff --git a/src/pkg/archive/tar/reader.go b/src/pkg/archive/tar/reader.go
index 74057401f8..cc2d89909f 100644
--- a/src/pkg/archive/tar/reader.go
+++ b/src/pkg/archive/tar/reader.go
@@ -71,7 +71,7 @@ func cString(b []byte) string {
 func (tr *Reader) octal(b []byte) int64 {
 	// Removing leading spaces.
 	for len(b) > 0 && b[0] == ' ' {
-		b = b[1:len(b)]
+		b = b[1:]
 	}
 	// Removing trailing NULs and spaces.
 	for len(b) > 0 && (b[len(b)-1] == ' ' || b[len(b)-1] == '\x00') {
diff --git a/src/pkg/archive/tar/writer_test.go b/src/pkg/archive/tar/writer_test.go
index 6e2b78a578..4a6c486f8d 100644
--- a/src/pkg/archive/tar/writer_test.go
+++ b/src/pkg/archive/tar/writer_test.go
@@ -112,8 +112,8 @@ func bytediff(a []byte, b []byte) string {
 		if sa != sb {
 			s += fmt.Sprintf("-%v\n+%v\n", sa, sb)
 		}
-		a = a[na:len(a)];
-		b = b[nb:len(b)];
+		a = a[na:];
+		b = b[nb:];
 	}
 	return s;
 }
diff --git a/src/pkg/asn1/asn1.go b/src/pkg/asn1/asn1.go
index a345a3b551..4a1ef7f5e9 100644
--- a/src/pkg/asn1/asn1.go
+++ b/src/pkg/asn1/asn1.go
@@ -141,7 +141,7 @@ func parseBitString(bytes []byte) (ret BitString, err os.Error) {
 		return;
 	}
 	ret.BitLength = (len(bytes)-1)*8 - paddingBits;
-	ret.Bytes = bytes[1:len(bytes)];
+	ret.Bytes = bytes[1:];
 	return;
 }
 
@@ -254,7 +254,7 @@ func parseUTCTime(bytes []byte) (ret *time.Time, err os.Error) {
 	if !ok1 || !ok2 || !ok3 || !ok4 || !ok5 {
 		goto Error
 	}
-	bytes = bytes[10:len(bytes)];
+	bytes = bytes[10:];
 	switch bytes[0] {
 	case '0', '1', '2', '3', '4', '5', '6':
 		if len(bytes) < 3 {
@@ -264,7 +264,7 @@ func parseUTCTime(bytes []byte) (ret *time.Time, err os.Error) {
 		if !ok1 {
 			goto Error
 		}
-		bytes = bytes[2:len(bytes)];
+		bytes = bytes[2:];
 	}
 	if len(bytes) == 0 {
 		goto Error
@@ -790,5 +790,5 @@ func Unmarshal(val interface{}, b []byte) (rest []byte, err os.Error) {
 	if err != nil {
 		return nil, err
 	}
-	return b[offset:len(b)], nil;
+	return b[offset:], nil;
 }
diff --git a/src/pkg/asn1/common.go b/src/pkg/asn1/common.go
index 3021493fc1..bdc4c8abd6 100644
--- a/src/pkg/asn1/common.go
+++ b/src/pkg/asn1/common.go
@@ -92,13 +92,13 @@ func parseFieldParameters(str string) (ret fieldParameters) {
 		case part == "printable":
 			ret.stringType = tagPrintableString
 		case strings.HasPrefix(part, "default:"):
-			i, err := strconv.Atoi64(part[8:len(part)]);
+			i, err := strconv.Atoi64(part[8:]);
 			if err == nil {
 				ret.defaultValue = new(int64);
 				*ret.defaultValue = i;
 			}
 		case strings.HasPrefix(part, "tag:"):
-			i, err := strconv.Atoi(part[4:len(part)]);
+			i, err := strconv.Atoi(part[4:]);
 			if err == nil {
 				ret.tag = new(int);
 				*ret.tag = i;
diff --git a/src/pkg/big/int.go b/src/pkg/big/int.go
index a22f2322bf..22c0eddff0 100644
--- a/src/pkg/big/int.go
+++ b/src/pkg/big/int.go
@@ -185,7 +185,7 @@ func (z *Int) SetString(s string, base int) (*Int, bool) {
 
 	if s[0] == '-' {
 		z.neg = true;
-		s = s[1:len(s)];
+		s = s[1:];
 	} else {
 		z.neg = false
 	}
@@ -260,7 +260,7 @@ func (z *Int) Bytes() []byte {
 		i++
 	}
 
-	return b[i:len(b)];
+	return b[i:];
 }
 
 
@@ -364,7 +364,7 @@ func (z *Int) Rsh(x *Int, n int) *Int {
 	removedWords := n / _W;
 	z.abs = makeN(z.abs, len(x.abs)-removedWords, false);
 	z.neg = x.neg;
-	shiftRight(z.abs, x.abs[removedWords:len(x.abs)], n%_W);
+	shiftRight(z.abs, x.abs[removedWords:], n%_W);
 	z.abs = normN(z.abs);
 	return z;
 }
diff --git a/src/pkg/big/nat.go b/src/pkg/big/nat.go
index 7fad9f8298..0b7c184283 100644
--- a/src/pkg/big/nat.go
+++ b/src/pkg/big/nat.go
@@ -467,7 +467,7 @@ func stringN(x []Word, base int) string {
 		s[i] = "0123456789abcdef"[r];
 	}
 
-	return string(s[i:len(s)]);
+	return string(s[i:]);
 }
 
 
@@ -585,7 +585,7 @@ func powersOfTwoDecompose(n []Word) (q []Word, k Word) {
 	x := trailingZeroBits(n[zeroWords]);
 
 	q = makeN(nil, len(n)-zeroWords, false);
-	shiftRight(q, n[zeroWords:len(n)], x);
+	shiftRight(q, n[zeroWords:], x);
 
 	k = Word(_W*zeroWords + x);
 	return;
diff --git a/src/pkg/bignum/integer.go b/src/pkg/bignum/integer.go
index 10cc3344f7..3d382473e1 100644
--- a/src/pkg/bignum/integer.go
+++ b/src/pkg/bignum/integer.go
@@ -514,7 +514,7 @@ func IntFromString(s string, base uint) (*Integer, uint, int) {
 		i0 = 1
 	}
 
-	mant, base, slen := NatFromString(s[i0:len(s)], base);
+	mant, base, slen := NatFromString(s[i0:], base);
 
 	return MakeInt(i0 > 0 && s[0] == '-', mant), base, i0 + slen;
 }
diff --git a/src/pkg/bignum/rational.go b/src/pkg/bignum/rational.go
index 267ed3c30f..9e9c3a8e08 100644
--- a/src/pkg/bignum/rational.go
+++ b/src/pkg/bignum/rational.go
@@ -173,10 +173,10 @@ func RatFromString(s string, base uint) (*Rational, uint, int) {
 		ch := s[alen];
 		if ch == '/' {
 			alen++;
-			b, base, blen = NatFromString(s[alen:len(s)], base);
+			b, base, blen = NatFromString(s[alen:], base);
 		} else if ch == '.' {
 			alen++;
-			b, base, blen = NatFromString(s[alen:len(s)], abase);
+			b, base, blen = NatFromString(s[alen:], abase);
 			assert(base == abase);
 			f := Nat(uint64(base)).Pow(uint(blen));
 			a = MakeInt(a.sign, a.mant.Mul(f).Add(b));
@@ -190,7 +190,7 @@ func RatFromString(s string, base uint) (*Rational, uint, int) {
 		ch := s[rlen];
 		if ch == 'e' || ch == 'E' {
 			rlen++;
-			e, _, elen := IntFromString(s[rlen:len(s)], 10);
+			e, _, elen := IntFromString(s[rlen:], 10);
 			rlen += elen;
 			m := Nat(10).Pow(uint(e.mant.Value()));
 			if e.sign {
diff --git a/src/pkg/bufio/bufio.go b/src/pkg/bufio/bufio.go
index f7b2f98b50..788e9b52bb 100644
--- a/src/pkg/bufio/bufio.go
+++ b/src/pkg/bufio/bufio.go
@@ -98,7 +98,7 @@ func (b *Reader) fill() {
 	b.r = 0;
 
 	// Read new data.
-	n, e := b.rd.Read(b.buf[b.w:len(b.buf)]);
+	n, e := b.rd.Read(b.buf[b.w:]);
 	b.w += n;
 	if e != nil {
 		b.err = e
@@ -125,7 +125,7 @@ func (b *Reader) Read(p []byte) (nn int, err os.Error) {
 				if n > 0 {
 					b.lastbyte = int(p[n-1])
 				}
-				p = p[n:len(p)];
+				p = p[n:];
 				nn += n;
 				continue;
 			}
@@ -136,7 +136,7 @@ func (b *Reader) Read(p []byte) (nn int, err os.Error) {
 			n = b.w - b.r
 		}
 		copySlice(p[0:n], b.buf[b.r:b.r+n]);
-		p = p[n:len(p)];
+		p = p[n:];
 		b.r += n;
 		b.lastbyte = int(b.buf[b.r-1]);
 		nn += n;
@@ -413,7 +413,7 @@ func (b *Writer) Write(p []byte) (nn int, err os.Error) {
 			// Write directly from p to avoid copy.
 			n, b.err = b.wr.Write(p);
 			nn += n;
-			p = p[n:len(p)];
+			p = p[n:];
 			if b.err != nil {
 				break
 			}
@@ -425,7 +425,7 @@ func (b *Writer) Write(p []byte) (nn int, err os.Error) {
 		copySlice(b.buf[b.n:b.n+n], p[0:n]);
 		b.n += n;
 		nn += n;
-		p = p[n:len(p)];
+		p = p[n:];
 	}
 	return nn, b.err;
 }
diff --git a/src/pkg/bytes/buffer.go b/src/pkg/bytes/buffer.go
index 0bbc06c323..ab6f837aa1 100644
--- a/src/pkg/bytes/buffer.go
+++ b/src/pkg/bytes/buffer.go
@@ -24,7 +24,7 @@ func copyBytes(dst []byte, doff int, src []byte) {
 		dst[doff] = src[0];
 		return;
 	}
-	copy(dst[doff:len(dst)], src);
+	copy(dst[doff:], src);
 }
 
 // A Buffer is a variable-sized buffer of bytes
@@ -38,7 +38,7 @@ type Buffer struct {
 
 // Bytes returns the contents of the unread portion of the buffer;
 // len(b.Bytes()) == b.Len().
-func (b *Buffer) Bytes() []byte	{ return b.buf[b.off:len(b.buf)] }
+func (b *Buffer) Bytes() []byte	{ return b.buf[b.off:] }
 
 // String returns the contents of the unread portion of the buffer
 // as a string.  If the Buffer is a nil pointer, it returns "<nil>".
@@ -47,7 +47,7 @@ func (b *Buffer) String() string {
 		// Special case, useful in debugging.
 		return "<nil>"
 	}
-	return string(b.buf[b.off:len(b.buf)]);
+	return string(b.buf[b.off:]);
 }
 
 // Len returns the number of bytes of the unread portion of the buffer;
diff --git a/src/pkg/bytes/buffer_test.go b/src/pkg/bytes/buffer_test.go
index e11eb5b1cc..d4862459d5 100644
--- a/src/pkg/bytes/buffer_test.go
+++ b/src/pkg/bytes/buffer_test.go
@@ -111,7 +111,7 @@ func empty(t *testing.T, testname string, buf *Buffer, s string, fub []byte) {
 		if err != nil {
 			t.Errorf(testname+" (empty 2): err should always be nil, found err == %s\n", err)
 		}
-		s = s[n:len(s)];
+		s = s[n:];
 		check(t, testname+" (empty 3)", buf, s);
 	}
 
@@ -228,7 +228,7 @@ func TestMixedReadsAndWrites(t *testing.T) {
 		rlen := rand.Intn(len(data));
 		fub := make([]byte, rlen);
 		n, _ := buf.Read(fub);
-		s = s[n:len(s)];
+		s = s[n:];
 	}
 	empty(t, "TestMixedReadsAndWrites (2)", &buf, s, make([]byte, buf.Len()));
 }
diff --git a/src/pkg/bytes/bytes.go b/src/pkg/bytes/bytes.go
index 171fa3d1bc..8548b15490 100644
--- a/src/pkg/bytes/bytes.go
+++ b/src/pkg/bytes/bytes.go
@@ -61,7 +61,7 @@ func explode(s []byte, n int) [][]byte {
 		}
 		_, size = utf8.DecodeRune(s);
 		a[na] = s[0:size];
-		s = s[size:len(s)];
+		s = s[size:];
 		na++;
 	}
 	return a[0:na];
@@ -144,7 +144,7 @@ func genSplit(s, sep []byte, sepSave, n int) [][]byte {
 			i += len(sep) - 1;
 		}
 	}
-	a[na] = s[start:len(s)];
+	a[na] = s[start:];
 	return a[0 : na+1];
 }
 
@@ -201,7 +201,7 @@ func HasPrefix(s, prefix []byte) bool {
 
 // HasSuffix tests whether the byte array s ends with suffix.
 func HasSuffix(s, suffix []byte) bool {
-	return len(s) >= len(suffix) && Equal(s[len(s)-len(suffix):len(s)], suffix)
+	return len(s) >= len(suffix) && Equal(s[len(s)-len(suffix):], suffix)
 }
 
 // Map returns a copy of the byte array s with all its characters modified
@@ -217,7 +217,7 @@ func Map(mapping func(rune int) int, s []byte) []byte {
 		wid := 1;
 		rune := int(s[i]);
 		if rune >= utf8.RuneSelf {
-			rune, wid = utf8.DecodeRune(s[i:len(s)])
+			rune, wid = utf8.DecodeRune(s[i:])
 		}
 		rune = mapping(rune);
 		if nbytes+utf8.RuneLen(rune) > maxbytes {
diff --git a/src/pkg/compress/flate/deflate.go b/src/pkg/compress/flate/deflate.go
index 257bc99406..d07e465254 100644
--- a/src/pkg/compress/flate/deflate.go
+++ b/src/pkg/compress/flate/deflate.go
@@ -144,7 +144,7 @@ func (d *deflater) fillWindow(index int) (int, os.Error) {
 	}
 	var count int;
 	var err os.Error;
-	count, err = io.ReadAtLeast(d.r, d.window[d.windowEnd:len(d.window)], 1);
+	count, err = io.ReadAtLeast(d.r, d.window[d.windowEnd:], 1);
 	d.windowEnd += count;
 	if err == os.EOF {
 		return index, nil
diff --git a/src/pkg/compress/flate/huffman_code.go b/src/pkg/compress/flate/huffman_code.go
index 484f7d6abb..f212d059de 100644
--- a/src/pkg/compress/flate/huffman_code.go
+++ b/src/pkg/compress/flate/huffman_code.go
@@ -301,7 +301,7 @@ func (h *huffmanEncoder) assignEncodingAndSize(bitCount []int32, list []literalN
 		// are encoded using "bits" bits, and get the values
 		// code, code + 1, ....  The code values are
 		// assigned in literal order (not frequency order).
-		chunk := list[len(list)-int(bits) : len(list)];
+		chunk := list[len(list)-int(bits):];
 		sortByLiteral(chunk);
 		for _, node := range chunk {
 			h.codeBits[node.literal] = uint8(n);
diff --git a/src/pkg/crypto/block/eax.go b/src/pkg/crypto/block/eax.go
index b739f4ef14..07919e4ae7 100644
--- a/src/pkg/crypto/block/eax.go
+++ b/src/pkg/crypto/block/eax.go
@@ -161,7 +161,7 @@ func (cr *cmacReader) Read(p []byte) (n int, err os.Error) {
 	tagBytes := len(tag);
 	if len(p) > 4*tagBytes {
 		// If p is big, try to read directly into p to avoid a copy.
-		n, err = cr.r.Read(p[tagBytes:len(p)]);
+		n, err = cr.r.Read(p[tagBytes:]);
 		if n == 0 {
 			goto out
 		}
diff --git a/src/pkg/crypto/block/ecb.go b/src/pkg/crypto/block/ecb.go
index 851bdfd706..c7491eb9cb 100644
--- a/src/pkg/crypto/block/ecb.go
+++ b/src/pkg/crypto/block/ecb.go
@@ -66,7 +66,7 @@ func (x *ecbDecrypter) readPlain(p []byte) int {
 		p[i] = x.plain[i]
 	}
 	if n < len(x.plain) {
-		x.plain = x.plain[n:len(x.plain)]
+		x.plain = x.plain[n:]
 	} else {
 		x.plain = nil
 	}
@@ -172,7 +172,7 @@ func (x *ecbEncrypter) flushCrypt() os.Error {
 	}
 	n, err := x.w.Write(x.crypt);
 	if n < len(x.crypt) {
-		x.crypt = x.crypt[n:len(x.crypt)];
+		x.crypt = x.crypt[n:];
 		if err == nil {
 			err = io.ErrShortWrite
 		}
@@ -246,7 +246,7 @@ func (x *ecbEncrypter) Write(p []byte) (n int, err os.Error) {
 			break
 		}
 		n += m;
-		p = p[m:len(p)];
+		p = p[m:];
 
 		// Encrypt, adjusting crypt and plain.
 		x.encrypt();
diff --git a/src/pkg/crypto/block/xor.go b/src/pkg/crypto/block/xor.go
index f231919753..ffb76c5c4a 100644
--- a/src/pkg/crypto/block/xor.go
+++ b/src/pkg/crypto/block/xor.go
@@ -46,7 +46,7 @@ func (x *xorReader) Read(p []byte) (n int, err os.Error) {
 		p[i] ^= buf[bp];
 		bp++;
 	}
-	x.buf = buf[bp:len(buf)];
+	x.buf = buf[bp:];
 	return n, err;
 }
 
@@ -96,7 +96,7 @@ func (x *xorWriter) Write(p []byte) (n int, err os.Error) {
 				x.work[i] = buf[bp] ^ p[i];
 				bp++;
 			}
-			x.buf = buf[bp:len(buf)];
+			x.buf = buf[bp:];
 			chunk = x.work[0:m];
 		}
 
@@ -112,13 +112,13 @@ func (x *xorWriter) Write(p []byte) (n int, err os.Error) {
 			for i := nn; i < m; i++ {
 				chunk[i] ^= p[i]
 			}
-			x.extra = chunk[nn:len(chunk)];
+			x.extra = chunk[nn:];
 		}
 		n += nn;
 		if err != nil {
 			return
 		}
-		p = p[m:len(p)];
+		p = p[m:];
 	}
 	return;
 }
diff --git a/src/pkg/crypto/md5/md5.go b/src/pkg/crypto/md5/md5.go
index e0699aeec0..3752886915 100644
--- a/src/pkg/crypto/md5/md5.go
+++ b/src/pkg/crypto/md5/md5.go
@@ -63,10 +63,10 @@ func (d *digest) Write(p []byte) (nn int, err os.Error) {
 			_Block(d, &d.x);
 			d.nx = 0;
 		}
-		p = p[n:len(p)];
+		p = p[n:];
 	}
 	n := _Block(d, p);
-	p = p[n:len(p)];
+	p = p[n:];
 	if len(p) > 0 {
 		for i := 0; i < len(p); i++ {
 			d.x[i] = p[i]
diff --git a/src/pkg/crypto/md5/md5block.go b/src/pkg/crypto/md5/md5block.go
index 22136942c1..4421acf8ec 100644
--- a/src/pkg/crypto/md5/md5block.go
+++ b/src/pkg/crypto/md5/md5block.go
@@ -164,7 +164,7 @@ func _Block(dig *digest, p []byte) int {
 		c += cc;
 		d += dd;
 
-		p = p[_Chunk:len(p)];
+		p = p[_Chunk:];
 		n += _Chunk;
 	}
 
diff --git a/src/pkg/crypto/rsa/pkcs1v15.go b/src/pkg/crypto/rsa/pkcs1v15.go
index 90a045ff5c..9dbc20f296 100644
--- a/src/pkg/crypto/rsa/pkcs1v15.go
+++ b/src/pkg/crypto/rsa/pkcs1v15.go
@@ -27,7 +27,7 @@ func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, er
 	// EM = 0x02 || PS || 0x00 || M
 	em := make([]byte, k-1);
 	em[0] = 2;
-	ps, mm := em[1:len(em)-len(msg)-1], em[len(em)-len(msg):len(em)];
+	ps, mm := em[1:len(em)-len(msg)-1], em[len(em)-len(msg):];
 	err = nonZeroRandomBytes(ps, rand);
 	if err != nil {
 		return
@@ -113,7 +113,7 @@ func decryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (valid
 	}
 
 	valid = firstByteIsZero & secondByteIsTwo & (^lookingForIndex & 1);
-	msg = em[index+1 : len(em)];
+	msg = em[index+1:];
 	return;
 }
 
diff --git a/src/pkg/crypto/rsa/rsa.go b/src/pkg/crypto/rsa/rsa.go
index 12465973cc..0576bb6a76 100644
--- a/src/pkg/crypto/rsa/rsa.go
+++ b/src/pkg/crypto/rsa/rsa.go
@@ -260,11 +260,11 @@ func EncryptOAEP(hash hash.Hash, rand io.Reader, pub *PublicKey, msg []byte, lab
 
 	em := make([]byte, k);
 	seed := em[1 : 1+hash.Size()];
-	db := em[1+hash.Size() : len(em)];
+	db := em[1+hash.Size():];
 
 	copy(db[0:hash.Size()], lHash);
 	db[len(db)-len(msg)-1] = 1;
-	copy(db[len(db)-len(msg):len(db)], msg);
+	copy(db[len(db)-len(msg):], msg);
 
 	_, err = io.ReadFull(rand, seed);
 	if err != nil {
@@ -397,7 +397,7 @@ func DecryptOAEP(hash hash.Hash, rand io.Reader, priv *PrivateKey, ciphertext []
 	firstByteIsZero := subtle.ConstantTimeByteEq(em[0], 0);
 
 	seed := em[1 : hash.Size()+1];
-	db := em[hash.Size()+1 : len(em)];
+	db := em[hash.Size()+1:];
 
 	mgf1XOR(seed, hash, db);
 	mgf1XOR(db, hash, seed);
@@ -417,7 +417,7 @@ func DecryptOAEP(hash hash.Hash, rand io.Reader, priv *PrivateKey, ciphertext []
 	//   invalid: 1 iff we saw a non-zero byte before the 0x01.
 	var lookingForIndex, index, invalid int;
 	lookingForIndex = 1;
-	rest := db[hash.Size():len(db)];
+	rest := db[hash.Size():];
 
 	for i := 0; i < len(rest); i++ {
 		equals0 := subtle.ConstantTimeByteEq(rest[i], 0);
@@ -432,7 +432,7 @@ func DecryptOAEP(hash hash.Hash, rand io.Reader, priv *PrivateKey, ciphertext []
 		return;
 	}
 
-	msg = rest[index+1 : len(rest)];
+	msg = rest[index+1:];
 	return;
 }
 
@@ -444,6 +444,6 @@ func leftPad(input []byte, size int) (out []byte) {
 		n = size
 	}
 	out = make([]byte, size);
-	copy(out[len(out)-n:len(out)], input);
+	copy(out[len(out)-n:], input);
 	return;
 }
diff --git a/src/pkg/crypto/sha1/sha1.go b/src/pkg/crypto/sha1/sha1.go
index 6569f5aef1..ad648d15dc 100644
--- a/src/pkg/crypto/sha1/sha1.go
+++ b/src/pkg/crypto/sha1/sha1.go
@@ -65,10 +65,10 @@ func (d *digest) Write(p []byte) (nn int, err os.Error) {
 			_Block(d, &d.x);
 			d.nx = 0;
 		}
-		p = p[n:len(p)];
+		p = p[n:];
 	}
 	n := _Block(d, p);
-	p = p[n:len(p)];
+	p = p[n:];
 	if len(p) > 0 {
 		for i := 0; i < len(p); i++ {
 			d.x[i] = p[i]
diff --git a/src/pkg/crypto/sha1/sha1block.go b/src/pkg/crypto/sha1/sha1block.go
index 2983bc7058..ff11520c0d 100644
--- a/src/pkg/crypto/sha1/sha1block.go
+++ b/src/pkg/crypto/sha1/sha1block.go
@@ -72,7 +72,7 @@ func _Block(dig *digest, p []byte) int {
 		h3 += d;
 		h4 += e;
 
-		p = p[_Chunk:len(p)];
+		p = p[_Chunk:];
 		n += _Chunk;
 	}
 
diff --git a/src/pkg/crypto/tls/handshake_messages.go b/src/pkg/crypto/tls/handshake_messages.go
index 7ad5276637..87e2e779e3 100644
--- a/src/pkg/crypto/tls/handshake_messages.go
+++ b/src/pkg/crypto/tls/handshake_messages.go
@@ -29,16 +29,16 @@ func (m *clientHelloMsg) marshal() []byte {
 	copy(x[6:38], m.random);
 	x[38] = uint8(len(m.sessionId));
 	copy(x[39:39+len(m.sessionId)], m.sessionId);
-	y := x[39+len(m.sessionId) : len(x)];
+	y := x[39+len(m.sessionId):];
 	y[0] = uint8(len(m.cipherSuites) >> 7);
 	y[1] = uint8(len(m.cipherSuites) << 1);
 	for i, suite := range m.cipherSuites {
 		y[2+i*2] = uint8(suite >> 8);
 		y[3+i*2] = uint8(suite);
 	}
-	z := y[2+len(m.cipherSuites)*2 : len(y)];
+	z := y[2+len(m.cipherSuites)*2:];
 	z[0] = uint8(len(m.compressionMethods));
-	copy(z[1:len(z)], m.compressionMethods);
+	copy(z[1:], m.compressionMethods);
 	m.raw = x;
 
 	return x;
@@ -57,7 +57,7 @@ func (m *clientHelloMsg) unmarshal(data []byte) bool {
 		return false
 	}
 	m.sessionId = data[39 : 39+sessionIdLen];
-	data = data[39+sessionIdLen : len(data)];
+	data = data[39+sessionIdLen:];
 	if len(data) < 2 {
 		return false
 	}
@@ -72,7 +72,7 @@ func (m *clientHelloMsg) unmarshal(data []byte) bool {
 	for i := 0; i < numCipherSuites; i++ {
 		m.cipherSuites[i] = uint16(data[2+2*i])<<8 | uint16(data[3+2*i])
 	}
-	data = data[2+cipherSuiteLen : len(data)];
+	data = data[2+cipherSuiteLen:];
 	if len(data) < 2 {
 		return false
 	}
@@ -111,7 +111,7 @@ func (m *serverHelloMsg) marshal() []byte {
 	copy(x[6:38], m.random);
 	x[38] = uint8(len(m.sessionId));
 	copy(x[39:39+len(m.sessionId)], m.sessionId);
-	z := x[39+len(m.sessionId) : len(x)];
+	z := x[39+len(m.sessionId):];
 	z[0] = uint8(m.cipherSuite >> 8);
 	z[1] = uint8(m.cipherSuite);
 	z[2] = uint8(m.compressionMethod);
@@ -147,13 +147,13 @@ func (m *certificateMsg) marshal() (x []byte) {
 	x[5] = uint8(certificateOctets >> 8);
 	x[6] = uint8(certificateOctets);
 
-	y := x[7:len(x)];
+	y := x[7:];
 	for _, slice := range m.certificates {
 		y[0] = uint8(len(slice) >> 16);
 		y[1] = uint8(len(slice) >> 8);
 		y[2] = uint8(len(slice));
-		copy(y[3:len(y)], slice);
-		y = y[3+len(slice) : len(y)];
+		copy(y[3:], slice);
+		y = y[3+len(slice):];
 	}
 
 	m.raw = x;
@@ -185,7 +185,7 @@ func (m *clientKeyExchangeMsg) marshal() []byte {
 	x[3] = uint8(length);
 	x[4] = uint8(len(m.ciphertext) >> 8);
 	x[5] = uint8(len(m.ciphertext));
-	copy(x[6:len(x)], m.ciphertext);
+	copy(x[6:], m.ciphertext);
 
 	m.raw = x;
 	return x;
@@ -200,7 +200,7 @@ func (m *clientKeyExchangeMsg) unmarshal(data []byte) bool {
 	if len(data) != 6+cipherTextLen {
 		return false
 	}
-	m.ciphertext = data[6:len(data)];
+	m.ciphertext = data[6:];
 	return true;
 }
 
@@ -217,7 +217,7 @@ func (m *finishedMsg) marshal() (x []byte) {
 	x = make([]byte, 16);
 	x[0] = typeFinished;
 	x[3] = 12;
-	copy(x[4:len(x)], m.verifyData);
+	copy(x[4:], m.verifyData);
 	m.raw = x;
 	return;
 }
@@ -227,6 +227,6 @@ func (m *finishedMsg) unmarshal(data []byte) bool {
 	if len(data) != 4+12 {
 		return false
 	}
-	m.verifyData = data[4:len(data)];
+	m.verifyData = data[4:];
 	return true;
 }
diff --git a/src/pkg/crypto/tls/handshake_server.go b/src/pkg/crypto/tls/handshake_server.go
index 86f11e66c0..0e04c42af2 100644
--- a/src/pkg/crypto/tls/handshake_server.go
+++ b/src/pkg/crypto/tls/handshake_server.go
@@ -102,7 +102,7 @@ func (h *serverHandshake) loop(writeChan chan<- interface{}, controlChan chan<-
 	hello.random[1] = byte(currentTime >> 16);
 	hello.random[2] = byte(currentTime >> 8);
 	hello.random[3] = byte(currentTime);
-	_, err := io.ReadFull(config.Rand, hello.random[4:len(hello.random)]);
+	_, err := io.ReadFull(config.Rand, hello.random[4:]);
 	if err != nil {
 		h.error(alertInternalError);
 		return;
@@ -135,7 +135,7 @@ func (h *serverHandshake) loop(writeChan chan<- interface{}, controlChan chan<-
 	finishedHash.Write(ckx.marshal());
 
 	preMasterSecret := make([]byte, 48);
-	_, err = io.ReadFull(config.Rand, preMasterSecret[2:len(preMasterSecret)]);
+	_, err = io.ReadFull(config.Rand, preMasterSecret[2:]);
 	if err != nil {
 		h.error(alertInternalError);
 		return;
diff --git a/src/pkg/crypto/tls/prf.go b/src/pkg/crypto/tls/prf.go
index 4009c94972..b89b59c296 100644
--- a/src/pkg/crypto/tls/prf.go
+++ b/src/pkg/crypto/tls/prf.go
@@ -16,7 +16,7 @@ import (
 // Split a premaster secret in two as specified in RFC 4346, section 5.
 func splitPreMasterSecret(secret []byte) (s1, s2 []byte) {
 	s1 = secret[0 : (len(secret)+1)/2];
-	s2 = secret[len(secret)/2 : len(secret)];
+	s2 = secret[len(secret)/2:];
 	return;
 }
 
@@ -52,7 +52,7 @@ func pRF11(result, secret, label, seed []byte) {
 
 	labelAndSeed := make([]byte, len(label)+len(seed));
 	copy(labelAndSeed, label);
-	copy(labelAndSeed[len(label):len(labelAndSeed)], seed);
+	copy(labelAndSeed[len(label):], seed);
 
 	s1, s2 := splitPreMasterSecret(secret);
 	pHash(result, s1, labelAndSeed, hashMD5);
@@ -81,20 +81,20 @@ var serverFinishedLabel = strings.Bytes("server finished")
 func keysFromPreMasterSecret11(preMasterSecret, clientRandom, serverRandom []byte, macLen, keyLen int) (masterSecret, clientMAC, serverMAC, clientKey, serverKey []byte) {
 	var seed [tlsRandomLength * 2]byte;
 	copy(seed[0:len(clientRandom)], clientRandom);
-	copy(seed[len(clientRandom):len(seed)], serverRandom);
+	copy(seed[len(clientRandom):], serverRandom);
 	masterSecret = make([]byte, masterSecretLength);
-	pRF11(masterSecret, preMasterSecret, masterSecretLabel, seed[0:len(seed)]);
+	pRF11(masterSecret, preMasterSecret, masterSecretLabel, seed[0:]);
 
 	copy(seed[0:len(clientRandom)], serverRandom);
-	copy(seed[len(serverRandom):len(seed)], clientRandom);
+	copy(seed[len(serverRandom):], clientRandom);
 
 	n := 2*macLen + 2*keyLen;
 	keyMaterial := make([]byte, n);
-	pRF11(keyMaterial, masterSecret, keyExpansionLabel, seed[0:len(seed)]);
+	pRF11(keyMaterial, masterSecret, keyExpansionLabel, seed[0:]);
 	clientMAC = keyMaterial[0:macLen];
 	serverMAC = keyMaterial[macLen : macLen*2];
 	clientKey = keyMaterial[macLen*2 : macLen*2+keyLen];
-	serverKey = keyMaterial[macLen*2+keyLen : len(keyMaterial)];
+	serverKey = keyMaterial[macLen*2+keyLen:];
 	return;
 }
 
@@ -124,7 +124,7 @@ func (h finishedHash) Write(msg []byte) (n int, err os.Error) {
 func finishedSum(md5, sha1, label, masterSecret []byte) []byte {
 	seed := make([]byte, len(md5)+len(sha1));
 	copy(seed, md5);
-	copy(seed[len(md5):len(seed)], sha1);
+	copy(seed[len(md5):], sha1);
 	out := make([]byte, finishedVerifyLength);
 	pRF11(out, masterSecret, label, seed);
 	return out;
diff --git a/src/pkg/crypto/tls/record_process.go b/src/pkg/crypto/tls/record_process.go
index 86b908a033..b7edd9fd16 100644
--- a/src/pkg/crypto/tls/record_process.go
+++ b/src/pkg/crypto/tls/record_process.go
@@ -180,7 +180,7 @@ func (p *recordProcessor) processRecord(r *record) {
 	p.mac.Write(r.payload[0 : len(r.payload)-p.mac.Size()]);
 	macBytes := p.mac.Sum();
 
-	if subtle.ConstantTimeCompare(macBytes, r.payload[len(r.payload)-p.mac.Size():len(r.payload)]) != 1 {
+	if subtle.ConstantTimeCompare(macBytes, r.payload[len(r.payload)-p.mac.Size():]) != 1 {
 		p.error(alertBadRecordMAC);
 		return;
 	}
@@ -228,7 +228,7 @@ func (p *recordProcessor) processHandshakeRecord(data []byte) {
 		}
 		newBuf := make([]byte, len(p.handshakeBuf)+len(data));
 		copy(newBuf, p.handshakeBuf);
-		copy(newBuf[len(p.handshakeBuf):len(newBuf)], data);
+		copy(newBuf[len(p.handshakeBuf):], data);
 		p.handshakeBuf = newBuf;
 	}
 
@@ -241,7 +241,7 @@ func (p *recordProcessor) processHandshakeRecord(data []byte) {
 		}
 
 		bytes := p.handshakeBuf[0 : handshakeLen+4];
-		p.handshakeBuf = p.handshakeBuf[handshakeLen+4 : len(p.handshakeBuf)];
+		p.handshakeBuf = p.handshakeBuf[handshakeLen+4:];
 		if bytes[0] == typeFinished {
 			// Special case because Finished is synchronous: the
 			// handshake handler has to tell us if it's ok to start
diff --git a/src/pkg/crypto/tls/record_read.go b/src/pkg/crypto/tls/record_read.go
index 877cfc797d..518a1361be 100644
--- a/src/pkg/crypto/tls/record_read.go
+++ b/src/pkg/crypto/tls/record_read.go
@@ -21,7 +21,7 @@ func recordReader(c chan<- *record, source io.Reader) {
 
 	for {
 		var header [5]byte;
-		n, _ := buf.Read(header[0:len(header)]);
+		n, _ := buf.Read(header[0:]);
 		if n != 5 {
 			return
 		}
diff --git a/src/pkg/crypto/tls/tls.go b/src/pkg/crypto/tls/tls.go
index 8f6ad111cb..a162487de2 100644
--- a/src/pkg/crypto/tls/tls.go
+++ b/src/pkg/crypto/tls/tls.go
@@ -59,7 +59,7 @@ func (tls *Conn) Read(p []byte) (int, os.Error) {
 	}
 
 	n := copy(p, tls.readBuf);
-	tls.readBuf = tls.readBuf[n:len(tls.readBuf)];
+	tls.readBuf = tls.readBuf[n:];
 	return n, nil;
 }
 
diff --git a/src/pkg/debug/dwarf/buf.go b/src/pkg/debug/dwarf/buf.go
index 10a7e5cb8e..2ece903a0d 100644
--- a/src/pkg/debug/dwarf/buf.go
+++ b/src/pkg/debug/dwarf/buf.go
@@ -33,7 +33,7 @@ func (b *buf) uint8() uint8 {
 		return 0;
 	}
 	val := b.data[0];
-	b.data = b.data[1:len(b.data)];
+	b.data = b.data[1:];
 	b.off++;
 	return val;
 }
@@ -44,7 +44,7 @@ func (b *buf) bytes(n int) []byte {
 		return nil;
 	}
 	data := b.data[0:n];
-	b.data = b.data[n:len(b.data)];
+	b.data = b.data[n:];
 	b.off += Offset(n);
 	return data;
 }
@@ -55,7 +55,7 @@ func (b *buf) string() string {
 	for i := 0; i < len(b.data); i++ {
 		if b.data[i] == 0 {
 			s := string(b.data[0:i]);
-			b.data = b.data[i+1 : len(b.data)];
+			b.data = b.data[i+1:];
 			b.off += Offset(i + 1);
 			return s;
 		}
@@ -97,7 +97,7 @@ func (b *buf) varint() (c uint64, bits uint) {
 		bits += 7;
 		if byte&0x80 == 0 {
 			b.off += Offset(i + 1);
-			b.data = b.data[i+1 : len(b.data)];
+			b.data = b.data[i+1:];
 			return c, bits;
 		}
 	}
diff --git a/src/pkg/debug/dwarf/entry.go b/src/pkg/debug/dwarf/entry.go
index 2aec1c17e8..a4f013c393 100644
--- a/src/pkg/debug/dwarf/entry.go
+++ b/src/pkg/debug/dwarf/entry.go
@@ -38,7 +38,7 @@ func (d *Data) parseAbbrev(off uint32) (abbrevTable, os.Error) {
 	if off > uint32(len(data)) {
 		data = nil
 	} else {
-		data = data[off:len(data)]
+		data = data[off:]
 	}
 	b := makeBuf(d, "abbrev", 0, data, 0);
 
@@ -269,7 +269,7 @@ func (r *Reader) Seek(off Offset) {
 		u = &d.unit[i];
 		if u.off <= off && off < u.off+Offset(len(u.data)) {
 			r.unit = i;
-			r.b = makeBuf(r.d, "info", off, u.data[off-u.off:len(u.data)], u.addrsize);
+			r.b = makeBuf(r.d, "info", off, u.data[off-u.off:], u.addrsize);
 			return;
 		}
 	}
diff --git a/src/pkg/debug/elf/file.go b/src/pkg/debug/elf/file.go
index c9e015ae2e..e610bc2eb9 100644
--- a/src/pkg/debug/elf/file.go
+++ b/src/pkg/debug/elf/file.go
@@ -343,7 +343,7 @@ func (f *File) getSymbols64() ([]Symbol, os.Error) {
 
 	// The first entry is all zeros.
 	var skip [Sym64Size]byte;
-	symtab.Read(skip[0:len(skip)]);
+	symtab.Read(skip[0:]);
 
 	symbols := make([]Symbol, symtab.Len()/Sym64Size);
 
diff --git a/src/pkg/debug/gosym/pclntab.go b/src/pkg/debug/gosym/pclntab.go
index 2fd93aa8e4..6c6a18868b 100644
--- a/src/pkg/debug/gosym/pclntab.go
+++ b/src/pkg/debug/gosym/pclntab.go
@@ -31,7 +31,7 @@ func (t *LineTable) parse(targetPC uint64, targetLine int) (b []byte, pc uint64,
 	b, pc, line = t.Data, t.PC, t.Line;
 	for pc <= targetPC && line != targetLine && len(b) > 0 {
 		code := b[0];
-		b = b[1:len(b)];
+		b = b[1:];
 		switch {
 		case code == 0:
 			if len(b) < 4 {
@@ -39,7 +39,7 @@ func (t *LineTable) parse(targetPC uint64, targetLine int) (b []byte, pc uint64,
 				break;
 			}
 			val := binary.BigEndian.Uint32(b);
-			b = b[4:len(b)];
+			b = b[4:];
 			line += int(val);
 		case code <= 64:
 			line += int(code)
diff --git a/src/pkg/debug/gosym/pclntab_test.go b/src/pkg/debug/gosym/pclntab_test.go
index c30b37e135..66609d9cf7 100644
--- a/src/pkg/debug/gosym/pclntab_test.go
+++ b/src/pkg/debug/gosym/pclntab_test.go
@@ -121,7 +121,7 @@ func TestLineAline(t *testing.T) {
 			}
 
 			// cgo files are full of 'Z' symbols, which we don't handle
-			if len(path) > 4 && path[len(path)-4:len(path)] == ".cgo" {
+			if len(path) > 4 && path[len(path)-4:] == ".cgo" {
 				continue
 			}
 
@@ -167,7 +167,7 @@ func TestPCLine(t *testing.T) {
 		wantLine += int(textdat[off]);
 		if fn == nil {
 			t.Errorf("failed to get line of PC %#x", pc)
-		} else if len(file) < 12 || file[len(file)-12:len(file)] != "pclinetest.s" || line != wantLine || fn != sym {
+		} else if len(file) < 12 || file[len(file)-12:] != "pclinetest.s" || line != wantLine || fn != sym {
 			t.Errorf("expected %s:%d (%s) at PC %#x, got %s:%d (%s)", "pclinetest.s", wantLine, sym.Name, pc, file, line, fn.Name)
 		}
 	}
diff --git a/src/pkg/debug/gosym/symtab.go b/src/pkg/debug/gosym/symtab.go
index 3c2502e0a5..39e397ecef 100644
--- a/src/pkg/debug/gosym/symtab.go
+++ b/src/pkg/debug/gosym/symtab.go
@@ -60,7 +60,7 @@ func (s *Sym) ReceiverName() string {
 // BaseName returns the symbol name without the package or receiver name.
 func (s *Sym) BaseName() string {
 	if i := strings.LastIndex(s.Name, "."); i != -1 {
-		return s.Name[i+1 : len(s.Name)]
+		return s.Name[i+1:]
 	}
 	return s.Name;
 }
@@ -116,7 +116,7 @@ func walksymtab(data []byte, fn func(sym) os.Error) os.Error {
 		}
 		typ &^= 0x80;
 		s.typ = typ;
-		p = p[5:len(p)];
+		p = p[5:];
 		var i int;
 		var nnul int;
 		for i = 0; i < len(p); i++ {
@@ -127,7 +127,7 @@ func walksymtab(data []byte, fn func(sym) os.Error) os.Error {
 		}
 		switch typ {
 		case 'z', 'Z':
-			p = p[i+nnul : len(p)];
+			p = p[i+nnul:];
 			for i = 0; i+2 <= len(p); i += 2 {
 				if p[i] == 0 && p[i+1] == 0 {
 					nnul = 2;
@@ -141,7 +141,7 @@ func walksymtab(data []byte, fn func(sym) os.Error) os.Error {
 		s.name = p[0:i];
 		i += nnul;
 		s.gotype = binary.BigEndian.Uint32(p[i : i+4]);
-		p = p[i+4 : len(p)];
+		p = p[i+4:];
 		fn(s);
 	}
 	return nil;
@@ -229,7 +229,7 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
 		case 'Z', 'z':	// path symbol
 			// Finish the current object
 			if obj != nil {
-				obj.Funcs = t.Funcs[lastf:len(t.Funcs)]
+				obj.Funcs = t.Funcs[lastf:]
 			}
 			lastf = len(t.Funcs);
 
@@ -318,7 +318,7 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, os.Error) {
 		}
 	}
 	if obj != nil {
-		obj.Funcs = t.Funcs[lastf:len(t.Funcs)]
+		obj.Funcs = t.Funcs[lastf:]
 	}
 	return &t, nil;
 }
@@ -336,7 +336,7 @@ func (t *Table) PCToFunc(pc uint64) *Func {
 		case fn.Entry <= pc && pc < fn.End:
 			return fn
 		default:
-			funcs = funcs[m+1 : len(funcs)]
+			funcs = funcs[m+1:]
 		}
 	}
 	return nil;
@@ -482,7 +482,7 @@ func (o *Obj) alineFromLine(path string, line int) (int, os.Error) {
 		var incstart int;
 		line += int(s.Value);
 	pathloop:
-		for _, s := range o.Paths[i:len(o.Paths)] {
+		for _, s := range o.Paths[i:] {
 			val := int(s.Value);
 			switch {
 			case depth == 1 && val >= line:
diff --git a/src/pkg/debug/macho/file.go b/src/pkg/debug/macho/file.go
index 2338710745..233490c835 100644
--- a/src/pkg/debug/macho/file.go
+++ b/src/pkg/debug/macho/file.go
@@ -208,7 +208,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {
 			return nil, &FormatError{offset, "invalid command block size", nil}
 		}
 		var cmddat []byte;
-		cmddat, dat = dat[0:siz], dat[siz:len(dat)];
+		cmddat, dat = dat[0:siz], dat[siz:];
 		offset += int64(siz);
 		var s *Segment;
 		switch cmd {
diff --git a/src/pkg/encoding/ascii85/ascii85.go b/src/pkg/encoding/ascii85/ascii85.go
index ba70f3dea2..85f688b2f6 100644
--- a/src/pkg/encoding/ascii85/ascii85.go
+++ b/src/pkg/encoding/ascii85/ascii85.go
@@ -57,7 +57,7 @@ func Encode(dst, src []byte) int {
 		// Special case: zero (!!!!!) shortens to z.
 		if v == 0 && len(src) >= 4 {
 			dst[0] = 'z';
-			dst = dst[1:len(dst)];
+			dst = dst[1:];
 			n++;
 			continue;
 		}
@@ -74,9 +74,9 @@ func Encode(dst, src []byte) int {
 			m -= 4 - len(src);
 			src = nil;
 		} else {
-			src = src[4:len(src)]
+			src = src[4:]
 		}
-		dst = dst[m:len(dst)];
+		dst = dst[m:];
 		n += m;
 	}
 	return n;
@@ -113,7 +113,7 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 			e.nbuf++;
 		}
 		n += i;
-		p = p[i:len(p)];
+		p = p[i:];
 		if e.nbuf < 4 {
 			return
 		}
@@ -138,7 +138,7 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 			}
 		}
 		n += nn;
-		p = p[nn:len(p)];
+		p = p[nn:];
 	}
 
 	// Trailing fringe.
@@ -268,7 +268,7 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 		// Copy leftover output from last decode.
 		if len(d.out) > 0 {
 			n = copy(p, d.out);
-			d.out = d.out[n:len(d.out)];
+			d.out = d.out[n:];
 			return;
 		}
 
@@ -293,7 +293,7 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 		}
 
 		// Read more data.
-		nn, d.readErr = d.r.Read(d.buf[d.nbuf:len(d.buf)]);
+		nn, d.readErr = d.r.Read(d.buf[d.nbuf:]);
 		d.nbuf += nn;
 	}
 	panic("unreachable");
diff --git a/src/pkg/encoding/base64/base64.go b/src/pkg/encoding/base64/base64.go
index b149a67153..ddb0e71177 100644
--- a/src/pkg/encoding/base64/base64.go
+++ b/src/pkg/encoding/base64/base64.go
@@ -101,8 +101,8 @@ func (enc *Encoding) Encode(dst, src []byte) {
 			break;
 		}
 
-		src = src[3:len(src)];
-		dst = dst[4:len(dst)];
+		src = src[3:];
+		dst = dst[4:];
 	}
 }
 
@@ -128,7 +128,7 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 			e.nbuf++;
 		}
 		n += i;
-		p = p[i:len(p)];
+		p = p[i:];
 		if e.nbuf < 3 {
 			return
 		}
@@ -153,7 +153,7 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 			}
 		}
 		n += nn;
-		p = p[nn:len(p)];
+		p = p[nn:];
 	}
 
 	// Trailing fringe.
@@ -279,7 +279,7 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 	// Use leftover decoded output from last read.
 	if len(d.out) > 0 {
 		n = copy(p, d.out);
-		d.out = d.out[n:len(d.out)];
+		d.out = d.out[n:];
 		return n, nil;
 	}
 
@@ -304,7 +304,7 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 		nw, d.end, d.err = d.enc.decode(&d.outbuf, d.buf[0:nr]);
 		d.out = d.outbuf[0:nw];
 		n = copy(p, d.out);
-		d.out = d.out[n:len(d.out)];
+		d.out = d.out[n:];
 	} else {
 		n, d.end, d.err = d.enc.decode(p, d.buf[0:nr])
 	}
diff --git a/src/pkg/encoding/binary/binary.go b/src/pkg/encoding/binary/binary.go
index 92c89cea97..f3cc8584a8 100644
--- a/src/pkg/encoding/binary/binary.go
+++ b/src/pkg/encoding/binary/binary.go
@@ -210,46 +210,46 @@ type encoder struct {
 
 func (d *decoder) uint8() uint8 {
 	x := d.buf[0];
-	d.buf = d.buf[1:len(d.buf)];
+	d.buf = d.buf[1:];
 	return x;
 }
 
 func (e *encoder) uint8(x uint8) {
 	e.buf[0] = x;
-	e.buf = e.buf[1:len(e.buf)];
+	e.buf = e.buf[1:];
 }
 
 func (d *decoder) uint16() uint16 {
 	x := d.order.Uint16(d.buf[0:2]);
-	d.buf = d.buf[2:len(d.buf)];
+	d.buf = d.buf[2:];
 	return x;
 }
 
 func (e *encoder) uint16(x uint16) {
 	e.order.PutUint16(e.buf[0:2], x);
-	e.buf = e.buf[2:len(e.buf)];
+	e.buf = e.buf[2:];
 }
 
 func (d *decoder) uint32() uint32 {
 	x := d.order.Uint32(d.buf[0:4]);
-	d.buf = d.buf[4:len(d.buf)];
+	d.buf = d.buf[4:];
 	return x;
 }
 
 func (e *encoder) uint32(x uint32) {
 	e.order.PutUint32(e.buf[0:4], x);
-	e.buf = e.buf[4:len(e.buf)];
+	e.buf = e.buf[4:];
 }
 
 func (d *decoder) uint64() uint64 {
 	x := d.order.Uint64(d.buf[0:8]);
-	d.buf = d.buf[8:len(d.buf)];
+	d.buf = d.buf[8:];
 	return x;
 }
 
 func (e *encoder) uint64(x uint64) {
 	e.order.PutUint64(e.buf[0:8], x);
-	e.buf = e.buf[8:len(e.buf)];
+	e.buf = e.buf[8:];
 }
 
 func (d *decoder) int8() int8	{ return int8(d.uint8()) }
diff --git a/src/pkg/encoding/git85/git.go b/src/pkg/encoding/git85/git.go
index cbc78fc3c4..71130a883b 100644
--- a/src/pkg/encoding/git85/git.go
+++ b/src/pkg/encoding/git85/git.go
@@ -74,7 +74,7 @@ func Encode(dst, src []byte) int {
 		}
 		dst[ndst] = '\n';
 		ndst++;
-		src = src[n:len(src)];
+		src = src[n:];
 	}
 	return ndst;
 }
@@ -173,7 +173,7 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 			e.nbuf++;
 		}
 		n += i;
-		p = p[i:len(p)];
+		p = p[i:];
 		if e.nbuf < 52 {
 			return
 		}
@@ -197,7 +197,7 @@ func (e *encoder) Write(p []byte) (n int, err os.Error) {
 			}
 		}
 		n += nn;
-		p = p[nn:len(p)];
+		p = p[nn:];
 	}
 
 	// Trailing fringe.
@@ -242,7 +242,7 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 		// Copy leftover output from last decode.
 		if len(d.out) > 0 {
 			n = copy(p, d.out);
-			d.out = d.out[n:len(d.out)];
+			d.out = d.out[n:];
 			return;
 		}
 
@@ -257,7 +257,7 @@ func (d *decoder) Read(p []byte) (n int, err os.Error) {
 
 		// Read and decode more input.
 		var nn int;
-		nn, d.readErr = d.r.Read(d.buf[d.nbuf:len(d.buf)]);
+		nn, d.readErr = d.r.Read(d.buf[d.nbuf:]);
 		d.nbuf += nn;
 
 		// Send complete lines to Decode.
diff --git a/src/pkg/encoding/pem/pem.go b/src/pkg/encoding/pem/pem.go
index 409f07fb0b..7828d87c1c 100644
--- a/src/pkg/encoding/pem/pem.go
+++ b/src/pkg/encoding/pem/pem.go
@@ -43,7 +43,7 @@ func getLine(data []byte) (line, rest []byte) {
 			i--
 		}
 	}
-	return data[0:i], data[j:len(data)];
+	return data[0:i], data[j:];
 }
 
 // removeWhitespace returns a copy of its input with all spaces, tab and
@@ -75,7 +75,7 @@ func Decode(data []byte) (p *Block, rest []byte) {
 	// pemStart begins with a newline. However, at the very beginning of
 	// the byte array, we'll accept the start string without it.
 	rest = data;
-	if bytes.HasPrefix(data, pemStart[1:len(pemStart)]) {
+	if bytes.HasPrefix(data, pemStart[1:]) {
 		rest = rest[len(pemStart)-1 : len(data)]
 	} else if i := bytes.Index(data, pemStart); i >= 0 {
 		rest = rest[i+len(pemStart) : len(data)]
@@ -108,7 +108,7 @@ func Decode(data []byte) (p *Block, rest []byte) {
 		}
 
 		// TODO(agl): need to cope with values that spread across lines.
-		key, val := line[0:i], line[i+1:len(line)];
+		key, val := line[0:i], line[i+1:];
 		key = bytes.TrimSpace(key);
 		val = bytes.TrimSpace(val);
 		p.Headers[string(key)] = string(val);
@@ -128,7 +128,7 @@ func Decode(data []byte) (p *Block, rest []byte) {
 	}
 	p.Bytes = p.Bytes[0:n];
 
-	_, rest = getLine(rest[i+len(pemEnd) : len(rest)]);
+	_, rest = getLine(rest[i+len(pemEnd):]);
 
 	return;
 
diff --git a/src/pkg/exp/4s/4s.go b/src/pkg/exp/4s/4s.go
index 2d22843fc7..f230572016 100644
--- a/src/pkg/exp/4s/4s.go
+++ b/src/pkg/exp/4s/4s.go
@@ -55,7 +55,7 @@ func audioServer() {
 		b := <-sndc;
 		for len(b)*2 >= n {
 			var a []uint16;
-			a, b = b[0:n/2], b[n/2:len(b)];
+			a, b = b[0:n/2], b[n/2:];
 			n, err = av.AudioStream(a);
 			if err != nil {
 				log.Exit(err)
diff --git a/src/pkg/exp/datafmt/datafmt.go b/src/pkg/exp/datafmt/datafmt.go
index 67b6183ad4..4ed9695abe 100644
--- a/src/pkg/exp/datafmt/datafmt.go
+++ b/src/pkg/exp/datafmt/datafmt.go
@@ -367,7 +367,7 @@ func (s *State) Write(data []byte) (int, os.Error) {
 			s.linePos.Line++;
 		}
 	}
-	n3, _ := s.output.Write(data[i0:len(data)]);
+	n3, _ := s.output.Write(data[i0:]);
 	return n + n3, nil;
 }
 
@@ -501,7 +501,7 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {
 				// segment contains a %-format at the beginning
 				if lit[1] == '%' {
 					// "%%" is printed as a single "%"
-					s.Write(lit[1:len(lit)])
+					s.Write(lit[1:])
 				} else {
 					// use s instead of s.output to get indentation right
 					fmt.Fprintf(s, string(lit), value.Interface())
diff --git a/src/pkg/exp/datafmt/parser.go b/src/pkg/exp/datafmt/parser.go
index fe17ba22af..648ffd6619 100644
--- a/src/pkg/exp/datafmt/parser.go
+++ b/src/pkg/exp/datafmt/parser.go
@@ -159,7 +159,7 @@ func (p *parser) parseLiteral() literal {
 	}
 	// the final segment may start with any character
 	// (it is empty iff the string is empty)
-	list.Push(s[i0:len(s)]);
+	list.Push(s[i0:]);
 
 	// convert list into a literal
 	lit := make(literal, list.Len());
@@ -343,7 +343,7 @@ func (p *parser) parseFormat() {
 func remap(p *parser, name string) string {
 	i := strings.Index(name, ".");
 	if i >= 0 {
-		packageName, suffix := name[0:i], name[i:len(name)];
+		packageName, suffix := name[0:i], name[i:];
 		// lookup package
 		if importPath, found := p.packs[packageName]; found {
 			name = importPath + suffix
diff --git a/src/pkg/exp/eval/expr.go b/src/pkg/exp/eval/expr.go
index 85f72b8106..1f1bf06343 100644
--- a/src/pkg/exp/eval/expr.go
+++ b/src/pkg/exp/eval/expr.go
@@ -763,7 +763,7 @@ func (a *exprInfo) compileCharLit(lit string) *expr {
 		a.silentErrors++;
 		return nil;
 	}
-	v, _, tail, err := strconv.UnquoteChar(lit[1:len(lit)], '\'');
+	v, _, tail, err := strconv.UnquoteChar(lit[1:], '\'');
 	if err != nil || tail != "'" {
 		// Caught by parser
 		a.silentErrors++;
@@ -835,7 +835,7 @@ func (a *exprInfo) compileSelectorExpr(v *expr, name string) *expr {
 		default:
 			log.Crashf("Marked field at depth %d, but already found one at depth %d", depth, bestDepth)
 		}
-		amberr += "\n\t" + pathName[1:len(pathName)];
+		amberr += "\n\t" + pathName[1:];
 	};
 
 	visited := make(map[Type]bool);
diff --git a/src/pkg/exp/eval/stmt.go b/src/pkg/exp/eval/stmt.go
index 815a149f62..60c6b9ee68 100644
--- a/src/pkg/exp/eval/stmt.go
+++ b/src/pkg/exp/eval/stmt.go
@@ -185,7 +185,7 @@ func (f *flowBuf) gotosObeyScopes(a *compiler) {
 		b := src.block;
 		for len(numVars) > 0 && b != tgt.block {
 			b = b.outer;
-			numVars = numVars[1:len(numVars)];
+			numVars = numVars[1:];
 		}
 		if b != tgt.block {
 			// We jumped into a deeper block
@@ -1099,7 +1099,7 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {
 				// non-empty statement in a case or
 				// default clause in an expression
 				// "switch" statement.
-				for _, s2 := range clause.Body[j+1 : len(clause.Body)] {
+				for _, s2 := range clause.Body[j+1:] {
 					// XXX(Spec) 6g also considers
 					// empty blocks to be empty
 					// statements.
diff --git a/src/pkg/exp/nacl/av/event.go b/src/pkg/exp/nacl/av/event.go
index 3b9a0e4d9d..5d38ac7cec 100644
--- a/src/pkg/exp/nacl/av/event.go
+++ b/src/pkg/exp/nacl/av/event.go
@@ -384,7 +384,7 @@ func (r *reader) Read(p []byte) (n int, err os.Error) {
 		return 0, os.EOF
 	}
 	n = bytes.Copy(p, b);
-	*r = b[n:len(b)];
+	*r = b[n:];
 	return;
 }
 
diff --git a/src/pkg/exp/nacl/srpc/client.go b/src/pkg/exp/nacl/srpc/client.go
index f0daa0d43c..d19b48888d 100644
--- a/src/pkg/exp/nacl/srpc/client.go
+++ b/src/pkg/exp/nacl/srpc/client.go
@@ -72,7 +72,7 @@ func NewClient(fd int) (c *Client, err os.Error) {
 		if i < 0 {
 			continue
 		}
-		c.service[string(line[0:i])] = srv{uint32(n), string(line[i+1 : len(line)])};
+		c.service[string(line[0:i])] = srv{uint32(n), string(line[i+1:])};
 	}
 
 	c.out = make(chan *msg);
@@ -159,7 +159,7 @@ func (r *RPC) Start(name string, arg []interface{}) {
 	for srv.fmt[i] != ':' {
 		i++
 	}
-	fmt := srv.fmt[i+1 : len(srv.fmt)];
+	fmt := srv.fmt[i+1:];
 
 	// Now the return prototypes.
 	m.Ret = make([]interface{}, len(fmt)-i);
diff --git a/src/pkg/exp/nacl/srpc/msg.go b/src/pkg/exp/nacl/srpc/msg.go
index 4370295927..857055a400 100644
--- a/src/pkg/exp/nacl/srpc/msg.go
+++ b/src/pkg/exp/nacl/srpc/msg.go
@@ -168,7 +168,7 @@ func (m *msg) uint8() uint8 {
 		return 0;
 	}
 	x := m.rdata[0];
-	m.rdata = m.rdata[1:len(m.rdata)];
+	m.rdata = m.rdata[1:];
 	return x;
 }
 
@@ -182,7 +182,7 @@ func (m *msg) uint32() uint32 {
 	}
 	b := m.rdata[0:4];
 	x := uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24;
-	m.rdata = m.rdata[4:len(m.rdata)];
+	m.rdata = m.rdata[4:];
 	return x;
 }
 
@@ -197,7 +197,7 @@ func (m *msg) uint64() uint64 {
 	b := m.rdata[0:8];
 	x := uint64(uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24);
 	x |= uint64(uint32(b[4])|uint32(b[5])<<8|uint32(b[6])<<16|uint32(b[7])<<24) << 32;
-	m.rdata = m.rdata[8:len(m.rdata)];
+	m.rdata = m.rdata[8:];
 	return x;
 }
 
@@ -210,7 +210,7 @@ func (m *msg) bytes(n int) []byte {
 		return nil;
 	}
 	x := m.rdata[0:n];
-	m.rdata = m.rdata[n:len(m.rdata)];
+	m.rdata = m.rdata[n:];
 	return x;
 }
 
@@ -357,7 +357,7 @@ func (m *msg) unpackValues(v []interface{}) {
 				return;
 			}
 			v[i] = int(m.rdesc[0]);
-			m.rdesc = m.rdesc[1:len(m.rdesc)];
+			m.rdesc = m.rdesc[1:];
 		case 'i':	// int
 			v[i] = int32(m.uint32())
 		case 'I':	// int array
diff --git a/src/pkg/exp/ogle/cmd.go b/src/pkg/exp/ogle/cmd.go
index 5ea2752e9b..6f0615f921 100644
--- a/src/pkg/exp/ogle/cmd.go
+++ b/src/pkg/exp/ogle/cmd.go
@@ -102,7 +102,7 @@ func getCmd(line []byte) (*cmd, []byte) {
 	slit := string(lit);
 	for i := range cmds {
 		if cmds[i].cmd == slit {
-			return &cmds[i], line[pos.Offset+len(lit) : len(line)]
+			return &cmds[i], line[pos.Offset+len(lit):]
 		}
 	}
 	return nil, nil;
@@ -140,7 +140,7 @@ func cmdLoad(args []byte) os.Error {
 	var fname string;
 	var tproc proc.Process;
 	if len(path) >= 4 && path[0:4] == "pid:" {
-		pid, err := strconv.Atoi(path[4:len(path)]);
+		pid, err := strconv.Atoi(path[4:]);
 		if err != nil {
 			return err
 		}
diff --git a/src/pkg/exp/ogle/process.go b/src/pkg/exp/ogle/process.go
index 6806d69732..efe3c4da4a 100644
--- a/src/pkg/exp/ogle/process.go
+++ b/src/pkg/exp/ogle/process.go
@@ -233,7 +233,7 @@ func (p *Process) bootstrap() {
 		if n[0] != 'P' || n[1] < 'A' || n[1] > 'Z' {
 			continue
 		}
-		sym := p.syms.LookupSym("type.*runtime." + n[1:len(n)]);
+		sym := p.syms.LookupSym("type.*runtime." + n[1:]);
 		if sym == nil {
 			continue
 		}
@@ -409,7 +409,7 @@ func (p *Process) postEvent(ev Event) {
 func (p *Process) processEvents() (EventAction, os.Error) {
 	var ev Event;
 	for len(p.posted) > 0 {
-		ev, p.posted = p.posted[0], p.posted[1:len(p.posted)];
+		ev, p.posted = p.posted[0], p.posted[1:];
 		action, err := p.processEvent(ev);
 		if action == EAStop {
 			return action, err
@@ -417,7 +417,7 @@ func (p *Process) processEvents() (EventAction, os.Error) {
 	}
 
 	for len(p.pending) > 0 {
-		ev, p.pending = p.pending[0], p.pending[1:len(p.pending)];
+		ev, p.pending = p.pending[0], p.pending[1:];
 		action, err := p.processEvent(ev);
 		if action == EAStop {
 			return action, err
diff --git a/src/pkg/exp/ogle/rruntime.go b/src/pkg/exp/ogle/rruntime.go
index 9b08a6a2f8..1a78814765 100644
--- a/src/pkg/exp/ogle/rruntime.go
+++ b/src/pkg/exp/ogle/rruntime.go
@@ -254,7 +254,7 @@ func fillRuntimeIndexes(runtime *runtimeValues, out *runtimeIndexes) {
 			}
 			name := f.Name;
 			if name[0] >= 'a' && name[0] <= 'z' {
-				name = string(name[0]+'A'-'a') + name[1:len(name)]
+				name = string(name[0]+'A'-'a') + name[1:]
 			}
 			indexes[name] = j;
 		}
diff --git a/src/pkg/flag/flag.go b/src/pkg/flag/flag.go
index 0471d126c0..86a3b3dc10 100644
--- a/src/pkg/flag/flag.go
+++ b/src/pkg/flag/flag.go
@@ -303,7 +303,7 @@ func Arg(i int) string {
 func NArg() int	{ return len(os.Args) - flags.first_arg }
 
 // Args returns the non-flag command-line arguments.
-func Args() []string	{ return os.Args[flags.first_arg:len(os.Args)] }
+func Args() []string	{ return os.Args[flags.first_arg:] }
 
 func add(name string, value FlagValue, usage string) {
 	// Remember the default value as a string; it won't change.
@@ -448,7 +448,7 @@ func (f *allFlags) parseOne(index int) (ok bool, next int) {
 			return false, index + 1
 		}
 	}
-	name := s[num_minuses:len(s)];
+	name := s[num_minuses:];
 	if len(name) == 0 || name[0] == '-' || name[0] == '=' {
 		fmt.Fprintln(os.Stderr, "bad flag syntax:", s);
 		Usage();
@@ -460,7 +460,7 @@ func (f *allFlags) parseOne(index int) (ok bool, next int) {
 	value := "";
 	for i := 1; i < len(name); i++ {	// equals cannot be first
 		if name[i] == '=' {
-			value = name[i+1 : len(name)];
+			value = name[i+1:];
 			has_value = true;
 			name = name[0:i];
 			break;
diff --git a/src/pkg/fmt/fmt_test.go b/src/pkg/fmt/fmt_test.go
index 3d9d9bf6fd..e2e59576f1 100644
--- a/src/pkg/fmt/fmt_test.go
+++ b/src/pkg/fmt/fmt_test.go
@@ -236,7 +236,7 @@ func TestSprintf(t *testing.T) {
 					break
 				}
 			}
-			s = s[0:i] + "PTR" + s[j:len(s)];
+			s = s[0:i] + "PTR" + s[j:];
 		}
 		if s != tt.out {
 			if _, ok := tt.val.(string); ok {
diff --git a/src/pkg/fmt/print.go b/src/pkg/fmt/print.go
index 15def46a61..cecdda0c32 100644
--- a/src/pkg/fmt/print.go
+++ b/src/pkg/fmt/print.go
@@ -603,7 +603,7 @@ func (p *pp) doprintf(format string, v *reflect.StructValue) {
 	end := len(format) - 1;
 	fieldnum := 0;	// we process one field per non-trivial format
 	for i := 0; i <= end; {
-		c, w := utf8.DecodeRuneInString(format[i:len(format)]);
+		c, w := utf8.DecodeRuneInString(format[i:]);
 		if c != '%' || i == end {
 			p.add(c);
 			i += w;
@@ -634,7 +634,7 @@ func (p *pp) doprintf(format string, v *reflect.StructValue) {
 		if i < end && format[i] == '.' {
 			p.fmt.prec, p.fmt.prec_present, i = parsenum(format, i+1, end)
 		}
-		c, w = utf8.DecodeRuneInString(format[i:len(format)]);
+		c, w = utf8.DecodeRuneInString(format[i:]);
 		i += w;
 		// percent is special - absorbs no operand
 		if c == '%' {
diff --git a/src/pkg/go/doc/comment.go b/src/pkg/go/doc/comment.go
index cf1452ac92..79f837927a 100644
--- a/src/pkg/go/doc/comment.go
+++ b/src/pkg/go/doc/comment.go
@@ -37,7 +37,7 @@ func CommentText(comment *ast.CommentGroup) string {
 			c = c[2:n];
 			// Remove leading space after //, if there is one.
 			if len(c) > 0 && c[0] == ' ' {
-				c = c[1:len(c)]
+				c = c[1:]
 			}
 		}
 
@@ -115,7 +115,7 @@ func split(text []byte) [][]byte {
 		}
 	}
 	if last < len(text) {
-		out[n] = text[last:len(text)]
+		out[n] = text[last:]
 	}
 
 	return out;
@@ -144,7 +144,7 @@ func commentEscape(w io.Writer, s []byte) {
 			i++;	// loop will add one more
 		}
 	}
-	template.HTMLEscape(w, s[last:len(s)]);
+	template.HTMLEscape(w, s[last:]);
 }
 
 
@@ -194,7 +194,7 @@ func unindent(block [][]byte) {
 	// remove
 	for i, line := range block {
 		if !isBlank(line) {
-			block[i] = line[n:len(line)]
+			block[i] = line[n:]
 		}
 	}
 }
diff --git a/src/pkg/go/doc/doc.go b/src/pkg/go/doc/doc.go
index 4ef12641b8..c713ffc459 100644
--- a/src/pkg/go/doc/doc.go
+++ b/src/pkg/go/doc/doc.go
@@ -277,10 +277,10 @@ func (doc *docReader) addFile(src *ast.File) {
 		cstr := string(text);
 		if m := bug_markers.ExecuteString(cstr); len(m) > 0 {
 			// found a BUG comment; maybe empty
-			if bstr := cstr[m[1]:len(cstr)]; bug_content.MatchString(bstr) {
+			if bstr := cstr[m[1]:]; bug_content.MatchString(bstr) {
 				// non-empty BUG comment; collect comment without BUG prefix
 				list := copyCommentList(c.List);
-				list[0].Text = text[m[1]:len(text)];
+				list[0].Text = text[m[1]:];
 				doc.bugs.Push(&ast.CommentGroup{list, nil});
 			}
 		}
diff --git a/src/pkg/go/printer/printer.go b/src/pkg/go/printer/printer.go
index a0b64c56cf..6c4c7ece6c 100644
--- a/src/pkg/go/printer/printer.go
+++ b/src/pkg/go/printer/printer.go
@@ -194,7 +194,7 @@ func (p *printer) write(data []byte) {
 	}
 
 	// write remaining segment
-	p.write0(data[i0:len(data)]);
+	p.write0(data[i0:]);
 
 	// update p.pos
 	d := len(data) - i0;
@@ -400,7 +400,7 @@ func split(text []byte) [][]byte {
 			n++;
 		}
 	}
-	lines[n] = text[i:len(text)];
+	lines[n] = text[i:];
 
 	return lines;
 }
@@ -475,7 +475,7 @@ func stripCommonPrefix(lines [][]byte) {
 		// for the opening /*, assume up to 3 blanks or a tab. This
 		// whitespace may be found as suffix in the common prefix.
 		first := lines[0];
-		if isBlank(first[2:len(first)]) {
+		if isBlank(first[2:]) {
 			// no comment text on the first line:
 			// reduce prefix by up to 3 blanks or a tab
 			// if present - this keeps comment text indented
@@ -536,7 +536,7 @@ func stripCommonPrefix(lines [][]byte) {
 	// Remove the common prefix from all but the first and empty lines.
 	for i, line := range lines {
 		if i > 0 && len(line) != 0 {
-			lines[i] = line[len(prefix):len(line)]
+			lines[i] = line[len(prefix):]
 		}
 	}
 }
diff --git a/src/pkg/go/scanner/scanner.go b/src/pkg/go/scanner/scanner.go
index 8391c693e7..177fe0f19a 100644
--- a/src/pkg/go/scanner/scanner.go
+++ b/src/pkg/go/scanner/scanner.go
@@ -52,7 +52,7 @@ func (S *Scanner) next() {
 			S.pos.Column = 0;
 		case r >= 0x80:
 			// not ASCII
-			r, w = utf8.DecodeRune(S.src[S.offset:len(S.src)])
+			r, w = utf8.DecodeRune(S.src[S.offset:])
 		}
 		S.offset += w;
 		S.ch = r;
@@ -157,7 +157,7 @@ func (S *Scanner) scanComment(pos token.Position) {
 						// get filename and line number, if any
 						i := bytes.Index(text, []byte{':'});
 						if i >= 0 {
-							if line, err := strconv.Atoi(string(text[i+1 : len(text)])); err == nil && line > 0 {
+							if line, err := strconv.Atoi(string(text[i+1:])); err == nil && line > 0 {
 								// valid //line filename:line comment;
 								// update scanner position
 								S.pos.Filename = string(text[len(prefix):i]);
diff --git a/src/pkg/http/fs.go b/src/pkg/http/fs.go
index 9ba5dd5c87..55b6f267ed 100644
--- a/src/pkg/http/fs.go
+++ b/src/pkg/http/fs.go
@@ -47,7 +47,7 @@ func isText(b []byte) bool {
 				return false
 			}
 		}
-		b = b[size:len(b)];
+		b = b[size:];
 	}
 	return true;
 }
@@ -77,7 +77,7 @@ func serveFileInternal(c *Conn, r *Request, name string, redirect bool) {
 
 	// redirect to strip off any index.html
 	n := len(name) - len(indexPage);
-	if n >= 0 && name[n:len(name)] == indexPage {
+	if n >= 0 && name[n:] == indexPage {
 		Redirect(c, name[0:n+1], StatusMovedPermanently);
 		return;
 	}
@@ -176,6 +176,6 @@ func (f *fileHandler) ServeHTTP(c *Conn, r *Request) {
 		NotFound(c, r);
 		return;
 	}
-	path = path[len(f.prefix):len(path)];
+	path = path[len(f.prefix):];
 	serveFileInternal(c, r, f.root+"/"+path, true);
 }
diff --git a/src/pkg/http/request.go b/src/pkg/http/request.go
index ee8d9af0ee..0d296a6b1d 100644
--- a/src/pkg/http/request.go
+++ b/src/pkg/http/request.go
@@ -265,7 +265,7 @@ func readKeyValue(b *bufio.Reader) (key, value string, err os.Error) {
 			break
 		}
 	}
-	value = string(line[i:len(line)]);
+	value = string(line[i:]);
 
 	// Look for extension lines, which must begin with space.
 	for {
diff --git a/src/pkg/http/url.go b/src/pkg/http/url.go
index 95d9bed738..ddf0ba986d 100644
--- a/src/pkg/http/url.go
+++ b/src/pkg/http/url.go
@@ -80,7 +80,7 @@ func URLUnescape(s string) (string, os.Error) {
 		case '%':
 			n++;
 			if i+2 >= len(s) || !ishex(s[i+1]) || !ishex(s[i+2]) {
-				s = s[i:len(s)];
+				s = s[i:];
 				if len(s) > 3 {
 					s = s[0:3]
 				}
@@ -196,7 +196,7 @@ func getscheme(rawurl string) (scheme, path string, err os.Error) {
 			if i == 0 {
 				return "", "", os.ErrorString("missing protocol scheme")
 			}
-			return rawurl[0:i], rawurl[i+1 : len(rawurl)], nil;
+			return rawurl[0:i], rawurl[i+1:], nil;
 		default:
 			// we have encountered an invalid character,
 			// so there is no valid scheme
@@ -213,9 +213,9 @@ func split(s string, c byte, cutc bool) (string, string) {
 	for i := 0; i < len(s); i++ {
 		if s[i] == c {
 			if cutc {
-				return s[0:i], s[i+1 : len(s)]
+				return s[0:i], s[i+1:]
 			}
-			return s[0:i], s[i:len(s)];
+			return s[0:i], s[i:];
 		}
 	}
 	return s, "";
@@ -254,7 +254,7 @@ func ParseURL(rawurl string) (url *URL, err os.Error) {
 
 	// Maybe path is //authority/path
 	if len(path) > 2 && path[0:2] == "//" {
-		url.Authority, path = split(path[2:len(path)], '/', false)
+		url.Authority, path = split(path[2:], '/', false)
 	}
 
 	// If there's no @, split's default is wrong.  Check explicitly.
diff --git a/src/pkg/image/png/reader.go b/src/pkg/image/png/reader.go
index ac35df8102..96528af0d4 100644
--- a/src/pkg/image/png/reader.go
+++ b/src/pkg/image/png/reader.go
@@ -216,8 +216,8 @@ func (d *decoder) idatReader(idat io.Reader) os.Error {
 		}
 
 		// Apply the filter.
-		cdat := cr[1:len(cr)];
-		pdat := pr[1:len(pr)];
+		cdat := cr[1:];
+		pdat := pr[1:];
 		switch cr[0] {
 		case ftNone:
 			// No-op.
diff --git a/src/pkg/image/png/writer.go b/src/pkg/image/png/writer.go
index 08d09f135a..9ec2544d03 100644
--- a/src/pkg/image/png/writer.go
+++ b/src/pkg/image/png/writer.go
@@ -137,12 +137,12 @@ func filter(cr [][]byte, pr []byte, bpp int) int {
 	// This is the same heuristic that libpng uses, although the filters are attempted in order of
 	// estimated most likely to be minimal (ftUp, ftPaeth, ftNone, ftSub, ftAverage), rather than
 	// in their enumeration order (ftNone, ftSub, ftUp, ftAverage, ftPaeth).
-	cdat0 := cr[0][1:len(cr[0])];
-	cdat1 := cr[1][1:len(cr[1])];
-	cdat2 := cr[2][1:len(cr[2])];
-	cdat3 := cr[3][1:len(cr[3])];
-	cdat4 := cr[4][1:len(cr[4])];
-	pdat := pr[1:len(pr)];
+	cdat0 := cr[0][1:];
+	cdat1 := cr[1][1:];
+	cdat2 := cr[2][1:];
+	cdat3 := cr[3][1:];
+	cdat4 := cr[4][1:];
+	pdat := pr[1:];
 	n := len(cdat0);
 
 	// The up filter.
diff --git a/src/pkg/io/io.go b/src/pkg/io/io.go
index 90f6566ac2..b2a051596a 100644
--- a/src/pkg/io/io.go
+++ b/src/pkg/io/io.go
@@ -154,7 +154,7 @@ func WriteString(w Writer, s string) (n int, err os.Error) {
 func ReadAtLeast(r Reader, buf []byte, min int) (n int, err os.Error) {
 	n = 0;
 	for n < min {
-		nn, e := r.Read(buf[n:len(buf)]);
+		nn, e := r.Read(buf[n:]);
 		if nn > 0 {
 			n += nn
 		}
diff --git a/src/pkg/io/pipe.go b/src/pkg/io/pipe.go
index 2caf21854f..a12d937dd6 100644
--- a/src/pkg/io/pipe.go
+++ b/src/pkg/io/pipe.go
@@ -54,7 +54,7 @@ func (p *pipe) Read(data []byte) (n int, err os.Error) {
 		data[i] = p.wpend[i]
 	}
 	p.wtot += n;
-	p.wpend = p.wpend[n:len(p.wpend)];
+	p.wpend = p.wpend[n:];
 
 	// If write block is done, finish the write.
 	if len(p.wpend) == 0 {
diff --git a/src/pkg/json/generic.go b/src/pkg/json/generic.go
index fb97edc19f..eed8f9daa2 100644
--- a/src/pkg/json/generic.go
+++ b/src/pkg/json/generic.go
@@ -172,7 +172,7 @@ func Walk(j Json, path string) Json {
 		var elem string;
 		if i := strings.Index(path, "/"); i >= 0 {
 			elem = path[0:i];
-			path = path[i+1 : len(path)];
+			path = path[i+1:];
 		} else {
 			elem = path;
 			path = "";
diff --git a/src/pkg/json/parse.go b/src/pkg/json/parse.go
index d96abd9616..008637593a 100644
--- a/src/pkg/json/parse.go
+++ b/src/pkg/json/parse.go
@@ -101,7 +101,7 @@ func Unquote(s string) (t string, ok bool) {
 					return
 				}
 				r += 4;
-				w += utf8.EncodeRune(rune, b[w:len(b)]);
+				w += utf8.EncodeRune(rune, b[w:]);
 			}
 		// Control characters are invalid, but we've seen raw \n.
 		case s[r] < ' ' && s[r] != '\n':
@@ -119,9 +119,9 @@ func Unquote(s string) (t string, ok bool) {
 			w++;
 		// Coerce to well-formed UTF-8.
 		default:
-			rune, size := utf8.DecodeRuneInString(s[r:len(s)]);
+			rune, size := utf8.DecodeRuneInString(s[r:]);
 			r += size;
-			w += utf8.EncodeRune(rune, b[w:len(b)]);
+			w += utf8.EncodeRune(rune, b[w:]);
 		}
 	}
 	return string(b[0:w]), true;
diff --git a/src/pkg/log/log.go b/src/pkg/log/log.go
index 6f07e67bcd..a49fbc0415 100644
--- a/src/pkg/log/log.go
+++ b/src/pkg/log/log.go
@@ -78,7 +78,7 @@ func itoa(i int, wid int) string {
 		b[bp] = byte(u%10) + '0';
 	}
 
-	return string(b[bp:len(b)]);
+	return string(b[bp:]);
 }
 
 func (l *Logger) formatHeader(ns int64, calldepth int) string {
@@ -105,7 +105,7 @@ func (l *Logger) formatHeader(ns int64, calldepth int) string {
 					short = file;
 					for i := len(file) - 1; i > 0; i-- {
 						if file[i] == '/' {
-							short = file[i+1 : len(file)];
+							short = file[i+1:];
 							break;
 						}
 					}
diff --git a/src/pkg/math/atan.go b/src/pkg/math/atan.go
index 1582031a3b..4f0ad9bf05 100644
--- a/src/pkg/math/atan.go
+++ b/src/pkg/math/atan.go
@@ -32,7 +32,7 @@ func xatan(arg float64) float64 {
 		Q0	= .89678597403663861962481162e3;
 	)
 	sq := arg * arg;
-	value := ((((P4*sq+P3)*sq+P2)*sq + P1) * sq + P0);
+	value := ((((P4*sq+P3)*sq+P2)*sq+P1)*sq + P0);
 	value = value / (((((sq+Q4)*sq+Q3)*sq+Q2)*sq+Q1)*sq + Q0);
 	return value * arg;
 }
diff --git a/src/pkg/math/sin.go b/src/pkg/math/sin.go
index adff067c24..70b7218c96 100644
--- a/src/pkg/math/sin.go
+++ b/src/pkg/math/sin.go
@@ -45,7 +45,7 @@ func sinus(x float64, quad int) float64 {
 
 	yy := y * y;
 	temp1 := ((((P4*yy+P3)*yy+P2)*yy+P1)*yy + P0) * y;
-	temp2 := ((((yy+Q3)*yy+Q2)*yy + Q1) * yy + Q0);
+	temp2 := ((((yy+Q3)*yy+Q2)*yy+Q1)*yy + Q0);
 	return temp1 / temp2;
 }
 
diff --git a/src/pkg/net/fd.go b/src/pkg/net/fd.go
index 4c782dfec8..f134b0f78a 100644
--- a/src/pkg/net/fd.go
+++ b/src/pkg/net/fd.go
@@ -428,7 +428,7 @@ func (fd *netFD) Write(p []byte) (n int, err os.Error) {
 	err = nil;
 	nn := 0;
 	for nn < len(p) {
-		n, err = fd.file.Write(p[nn:len(p)]);
+		n, err = fd.file.Write(p[nn:]);
 		if n > 0 {
 			nn += n
 		}
diff --git a/src/pkg/net/fd_darwin.go b/src/pkg/net/fd_darwin.go
index bf60ca77d2..74818581a4 100644
--- a/src/pkg/net/fd_darwin.go
+++ b/src/pkg/net/fd_darwin.go
@@ -97,7 +97,7 @@ func (p *pollster) WaitFD(nsec int64) (fd int, mode int, err os.Error) {
 		p.events = p.eventbuf[0:nn];
 	}
 	ev := &p.events[0];
-	p.events = p.events[1:len(p.events)];
+	p.events = p.events[1:];
 	fd = int(ev.Ident);
 	if ev.Filter == syscall.EVFILT_READ {
 		mode = 'r'
diff --git a/src/pkg/net/fd_freebsd.go b/src/pkg/net/fd_freebsd.go
index b9c016b745..12a64014a8 100644
--- a/src/pkg/net/fd_freebsd.go
+++ b/src/pkg/net/fd_freebsd.go
@@ -93,7 +93,7 @@ func (p *pollster) WaitFD(nsec int64) (fd int, mode int, err os.Error) {
 		p.events = p.eventbuf[0:nn];
 	}
 	ev := &p.events[0];
-	p.events = p.events[1:len(p.events)];
+	p.events = p.events[1:];
 	fd = int(ev.Ident);
 	if ev.Filter == syscall.EVFILT_READ {
 		mode = 'r'
diff --git a/src/pkg/net/ip.go b/src/pkg/net/ip.go
index 822cd78a05..db15528906 100644
--- a/src/pkg/net/ip.go
+++ b/src/pkg/net/ip.go
@@ -153,7 +153,7 @@ func itod(i uint) string {
 		b[bp] = byte(i%10) + '0';
 	}
 
-	return string(b[bp:len(b)]);
+	return string(b[bp:]);
 }
 
 // Convert i to hexadecimal string.
@@ -170,7 +170,7 @@ func itox(i uint) string {
 		b[bp] = "0123456789abcdef"[byte(i%16)];
 	}
 
-	return string(b[bp:len(b)]);
+	return string(b[bp:]);
 }
 
 // String returns the string form of the IP address ip.
@@ -342,7 +342,7 @@ L:	for j < IPv6len {
 				// Not enough room.
 				return nil
 			}
-			p4 := parseIPv4(s[i:len(s)]);
+			p4 := parseIPv4(s[i:]);
 			if p4 == nil {
 				return nil
 			}
diff --git a/src/pkg/net/ipsock.go b/src/pkg/net/ipsock.go
index f717f0663f..f61d22ac95 100644
--- a/src/pkg/net/ipsock.go
+++ b/src/pkg/net/ipsock.go
@@ -157,7 +157,7 @@ func splitHostPort(hostport string) (host, port string, err os.Error) {
 		return;
 	}
 
-	host, port = hostport[0:i], hostport[i+1:len(hostport)];
+	host, port = hostport[0:i], hostport[i+1:];
 
 	// Can put brackets around host ...
 	if len(host) > 0 && host[0] == '[' && host[len(host)-1] == ']' {
diff --git a/src/pkg/net/parse.go b/src/pkg/net/parse.go
index cfec46f456..c93f8335cd 100644
--- a/src/pkg/net/parse.go
+++ b/src/pkg/net/parse.go
@@ -96,7 +96,7 @@ func splitAtBytes(s string, t string) []string {
 		}
 	}
 	if last < len(s) {
-		a[n] = string(s[last:len(s)]);
+		a[n] = string(s[last:]);
 		n++;
 	}
 	return a[0:n];
@@ -169,7 +169,7 @@ func itoa(i int) string {
 		n--;
 		buf[n] = '-';
 	}
-	return string(buf[n:len(buf)]);
+	return string(buf[n:]);
 }
 
 // Number of occurrences of b in s.
diff --git a/src/pkg/net/port.go b/src/pkg/net/port.go
index 134f9b317b..b496f53081 100644
--- a/src/pkg/net/port.go
+++ b/src/pkg/net/port.go
@@ -32,7 +32,7 @@ func readServices() {
 		if !ok || port <= 0 || j >= len(portnet) || portnet[j] != '/' {
 			continue
 		}
-		netw := portnet[j+1 : len(portnet)];	// "tcp"
+		netw := portnet[j+1:];	// "tcp"
 		m, ok1 := services[netw];
 		if !ok1 {
 			m = make(map[string]int);
diff --git a/src/pkg/net/server_test.go b/src/pkg/net/server_test.go
index 647f29789f..d5c2f182cb 100644
--- a/src/pkg/net/server_test.go
+++ b/src/pkg/net/server_test.go
@@ -80,7 +80,7 @@ func doTest(t *testing.T, network, listenaddr, dialaddr string) {
 	go runServe(t, network, listenaddr, listening, done);
 	addr := <-listening;	// wait for server to start
 	if network == "tcp" {
-		dialaddr += addr[strings.LastIndex(addr, ":"):len(addr)]
+		dialaddr += addr[strings.LastIndex(addr, ":"):]
 	}
 	connect(t, network, dialaddr);
 	<-done;	// make sure server stopped
@@ -143,7 +143,7 @@ func doTestPacket(t *testing.T, network, listenaddr, dialaddr string) {
 	go runPacket(t, network, listenaddr, listening, done);
 	addr := <-listening;	// wait for server to start
 	if network == "udp" {
-		dialaddr += addr[strings.LastIndex(addr, ":"):len(addr)]
+		dialaddr += addr[strings.LastIndex(addr, ":"):]
 	}
 	connect(t, network, dialaddr);
 	<-done;	// tell server to stop
diff --git a/src/pkg/os/env.go b/src/pkg/os/env.go
index 071db0d1d4..c1713586dd 100644
--- a/src/pkg/os/env.go
+++ b/src/pkg/os/env.go
@@ -21,7 +21,7 @@ func copyenv() {
 	for _, s := range Envs {
 		for j := 0; j < len(s); j++ {
 			if s[j] == '=' {
-				env[s[0:j]] = s[j+1 : len(s)];
+				env[s[0:j]] = s[j+1:];
 				break;
 			}
 		}
diff --git a/src/pkg/os/exec.go b/src/pkg/os/exec.go
index 3797d80db8..6525f254e2 100644
--- a/src/pkg/os/exec.go
+++ b/src/pkg/os/exec.go
@@ -119,7 +119,7 @@ func itod(i int) string {
 		b[bp] = '-';
 	}
 
-	return string(b[bp:len(b)]);
+	return string(b[bp:]);
 }
 
 func (w Waitmsg) String() string {
diff --git a/src/pkg/os/file.go b/src/pkg/os/file.go
index bc7f02ef98..dc722055a5 100644
--- a/src/pkg/os/file.go
+++ b/src/pkg/os/file.go
@@ -146,7 +146,7 @@ func (file *File) ReadAt(b []byte, off int64) (n int, err Error) {
 			err = &PathError{"read", file.name, Errno(e)};
 			break;
 		}
-		b = b[m:len(b)];
+		b = b[m:];
 		off += int64(m);
 	}
 	return;
@@ -191,7 +191,7 @@ func (file *File) WriteAt(b []byte, off int64) (n int, err Error) {
 			err = &PathError{"write", file.name, Errno(e)};
 			break;
 		}
-		b = b[m:len(b)];
+		b = b[m:];
 		off += int64(m);
 	}
 	return;
diff --git a/src/pkg/os/stat_darwin.go b/src/pkg/os/stat_darwin.go
index 1bdd371136..857c9068d3 100644
--- a/src/pkg/os/stat_darwin.go
+++ b/src/pkg/os/stat_darwin.go
@@ -26,7 +26,7 @@ func dirFromStat(name string, dir *Dir, lstat, stat *syscall.Stat_t) *Dir {
 	dir.Ctime_ns = uint64(syscall.TimespecToNsec(stat.Ctimespec));
 	for i := len(name) - 1; i >= 0; i-- {
 		if name[i] == '/' {
-			name = name[i+1 : len(name)];
+			name = name[i+1:];
 			break;
 		}
 	}
diff --git a/src/pkg/os/stat_freebsd.go b/src/pkg/os/stat_freebsd.go
index d2630d72d6..c28f976894 100644
--- a/src/pkg/os/stat_freebsd.go
+++ b/src/pkg/os/stat_freebsd.go
@@ -26,7 +26,7 @@ func dirFromStat(name string, dir *Dir, lstat, stat *syscall.Stat_t) *Dir {
 	dir.Ctime_ns = uint64(syscall.TimespecToNsec(stat.Ctimespec));
 	for i := len(name) - 1; i >= 0; i-- {
 		if name[i] == '/' {
-			name = name[i+1 : len(name)];
+			name = name[i+1:];
 			break;
 		}
 	}
diff --git a/src/pkg/os/stat_linux.go b/src/pkg/os/stat_linux.go
index e19725b22e..a947b58028 100644
--- a/src/pkg/os/stat_linux.go
+++ b/src/pkg/os/stat_linux.go
@@ -26,7 +26,7 @@ func dirFromStat(name string, dir *Dir, lstat, stat *syscall.Stat_t) *Dir {
 	dir.Ctime_ns = uint64(syscall.TimespecToNsec(stat.Ctim));
 	for i := len(name) - 1; i >= 0; i-- {
 		if name[i] == '/' {
-			name = name[i+1 : len(name)];
+			name = name[i+1:];
 			break;
 		}
 	}
diff --git a/src/pkg/os/stat_nacl.go b/src/pkg/os/stat_nacl.go
index 9a66c671e2..8cad9c944c 100644
--- a/src/pkg/os/stat_nacl.go
+++ b/src/pkg/os/stat_nacl.go
@@ -26,7 +26,7 @@ func dirFromStat(name string, dir *Dir, lstat, stat *syscall.Stat_t) *Dir {
 	dir.Ctime_ns = uint64(stat.Ctime) * 1e9;
 	for i := len(name) - 1; i >= 0; i-- {
 		if name[i] == '/' {
-			name = name[i+1 : len(name)];
+			name = name[i+1:];
 			break;
 		}
 	}
diff --git a/src/pkg/patch/git.go b/src/pkg/patch/git.go
index 63bf2cd74f..7fae216c4e 100644
--- a/src/pkg/patch/git.go
+++ b/src/pkg/patch/git.go
@@ -63,7 +63,7 @@ func getHex(s []byte) (data []byte, rest []byte) {
 	for i := range data {
 		data[i] = unhex(s[2*i])<<4 | unhex(s[2*i+1])
 	}
-	rest = s[n:len(s)];
+	rest = s[n:];
 	return;
 }
 
diff --git a/src/pkg/patch/patch.go b/src/pkg/patch/patch.go
index 81a2dfcfc4..d04b78865c 100644
--- a/src/pkg/patch/patch.go
+++ b/src/pkg/patch/patch.go
@@ -100,13 +100,13 @@ func Parse(text []byte) (*Set, os.Error) {
 		// begins the section.  After that is the file name.
 		s, raw, _ := getLine(raw, 1);
 		if hasPrefix(s, "Index: ") {
-			p.Dst = string(bytes.TrimSpace(s[7:len(s)]));
+			p.Dst = string(bytes.TrimSpace(s[7:]));
 			goto HaveName;
 		} else if hasPrefix(s, "diff ") {
 			str := string(bytes.TrimSpace(s));
 			i := strings.LastIndex(str, " b/");
 			if i >= 0 {
-				p.Dst = str[i+3 : len(str)];
+				p.Dst = str[i+3:];
 				goto HaveName;
 			}
 		}
@@ -240,7 +240,7 @@ func getLine(data []byte, n int) (first []byte, rest []byte, ok bool) {
 			ok = false;
 			break;
 		}
-		rest = rest[nl+1 : len(rest)];
+		rest = rest[nl+1:];
 	}
 	first = data[0 : len(data)-len(rest)];
 	return;
@@ -260,7 +260,7 @@ func sections(text []byte, prefix string) ([]byte, [][]byte) {
 		if nl < 0 {
 			break
 		}
-		b = b[nl+1 : len(b)];
+		b = b[nl+1:];
 	}
 
 	sect := make([][]byte, n+1);
@@ -276,9 +276,9 @@ func sections(text []byte, prefix string) ([]byte, [][]byte) {
 			sect[n] = text;
 			break;
 		}
-		b = b[nl+1 : len(b)];
+		b = b[nl+1:];
 	}
-	return sect[0], sect[1:len(sect)];
+	return sect[0], sect[1:];
 }
 
 // if s begins with the prefix t, skip returns
@@ -287,7 +287,7 @@ func skip(s []byte, t string) (ss []byte, ok bool) {
 	if len(s) < len(t) || string(s[0:len(t)]) != t {
 		return nil, false
 	}
-	return s[len(t):len(s)], true;
+	return s[len(t):], true;
 }
 
 // if s begins with the prefix t and then is a sequence
@@ -305,7 +305,7 @@ func atoi(s []byte, t string, base int) (n int, ss []byte, ok bool) {
 	if i == 0 {
 		return
 	}
-	return n, s[i:len(s)], true;
+	return n, s[i:], true;
 }
 
 // hasPrefix returns true if s begins with t.
diff --git a/src/pkg/patch/textdiff.go b/src/pkg/patch/textdiff.go
index 2bfa8815d2..8771f22d7d 100644
--- a/src/pkg/patch/textdiff.go
+++ b/src/pkg/patch/textdiff.go
@@ -64,7 +64,7 @@ func ParseTextDiff(raw []byte) (TextDiff, os.Error) {
 		var dropOldNL, dropNewNL bool;
 		var nold, nnew int;
 		var lastch byte;
-		chunk = chunk[1:len(chunk)];
+		chunk = chunk[1:];
 		for _, l := range chunk {
 			if nold == oldCount && nnew == newCount && (len(l) == 0 || l[0] != '\\') {
 				if len(bytes.TrimSpace(l)) != 0 {
@@ -122,7 +122,7 @@ func ParseTextDiff(raw []byte) (TextDiff, os.Error) {
 			if nold == oldCount && nnew == newCount {
 				break
 			}
-			ch, l := l[0], l[1:len(l)];
+			ch, l := l[0], l[1:];
 			if ch == '\\' {
 				continue
 			}
@@ -162,7 +162,7 @@ func (d TextDiff) Apply(data []byte) ([]byte, os.Error) {
 			return nil, ErrPatchFailure
 		}
 		buf.Write(prefix);
-		data = data[len(c.Old):len(data)];
+		data = data[len(c.Old):];
 		buf.Write(c.New);
 		line = c.Line + bytes.Count(c.Old, newline);
 	}
diff --git a/src/pkg/path/path.go b/src/pkg/path/path.go
index 52ec334a94..e5b9e989d2 100644
--- a/src/pkg/path/path.go
+++ b/src/pkg/path/path.go
@@ -109,7 +109,7 @@ func Clean(path string) string {
 func Split(path string) (dir, file string) {
 	for i := len(path) - 1; i >= 0; i-- {
 		if path[i] == '/' {
-			return path[0 : i+1], path[i+1 : len(path)]
+			return path[0 : i+1], path[i+1:]
 		}
 	}
 	return "", path;
@@ -131,7 +131,7 @@ func Join(dir, file string) string {
 func Ext(path string) string {
 	for i := len(path) - 1; i >= 0 && path[i] != '/'; i-- {
 		if path[i] == '.' {
-			return path[i:len(path)]
+			return path[i:]
 		}
 	}
 	return "";
diff --git a/src/pkg/rand/rand_test.go b/src/pkg/rand/rand_test.go
index 5741aca8a2..ae417a9be7 100644
--- a/src/pkg/rand/rand_test.go
+++ b/src/pkg/rand/rand_test.go
@@ -289,26 +289,26 @@ func compareFloat32Slices(s1, s2 []float32) int {
 
 func TestNormTables(t *testing.T) {
 	testKn, testWn, testFn := initNorm();
-	if i := compareUint32Slices(kn[0:len(kn)], testKn); i >= 0 {
+	if i := compareUint32Slices(kn[0:], testKn); i >= 0 {
 		t.Errorf("kn disagrees at index %v; %v != %v\n", i, kn[i], testKn[i])
 	}
-	if i := compareFloat32Slices(wn[0:len(wn)], testWn); i >= 0 {
+	if i := compareFloat32Slices(wn[0:], testWn); i >= 0 {
 		t.Errorf("wn disagrees at index %v; %v != %v\n", i, wn[i], testWn[i])
 	}
-	if i := compareFloat32Slices(fn[0:len(fn)], testFn); i >= 0 {
+	if i := compareFloat32Slices(fn[0:], testFn); i >= 0 {
 		t.Errorf("fn disagrees at index %v; %v != %v\n", i, fn[i], testFn[i])
 	}
 }
 
 func TestExpTables(t *testing.T) {
 	testKe, testWe, testFe := initExp();
-	if i := compareUint32Slices(ke[0:len(ke)], testKe); i >= 0 {
+	if i := compareUint32Slices(ke[0:], testKe); i >= 0 {
 		t.Errorf("ke disagrees at index %v; %v != %v\n", i, ke[i], testKe[i])
 	}
-	if i := compareFloat32Slices(we[0:len(we)], testWe); i >= 0 {
+	if i := compareFloat32Slices(we[0:], testWe); i >= 0 {
 		t.Errorf("we disagrees at index %v; %v != %v\n", i, we[i], testWe[i])
 	}
-	if i := compareFloat32Slices(fe[0:len(fe)], testFe); i >= 0 {
+	if i := compareFloat32Slices(fe[0:], testFe); i >= 0 {
 		t.Errorf("fe disagrees at index %v; %v != %v\n", i, fe[i], testFe[i])
 	}
 }
diff --git a/src/pkg/regexp/regexp.go b/src/pkg/regexp/regexp.go
index 30043fcb9a..8f17954d79 100644
--- a/src/pkg/regexp/regexp.go
+++ b/src/pkg/regexp/regexp.go
@@ -265,7 +265,7 @@ func (p *parser) nextc() int {
 	if p.pos >= len(p.re.expr) {
 		p.ch = endOfFile
 	} else {
-		c, w := utf8.DecodeRuneInString(p.re.expr[p.pos:len(p.re.expr)]);
+		c, w := utf8.DecodeRuneInString(p.re.expr[p.pos:]);
 		p.ch = c;
 		p.pos += w;
 	}
@@ -804,9 +804,9 @@ func (re *Regexp) doExecute(str string, bytestr []byte, pos int) []int {
 	if re.prefix != "" {
 		var advance int;
 		if bytestr == nil {
-			advance = strings.Index(str[pos:len(str)], re.prefix)
+			advance = strings.Index(str[pos:], re.prefix)
 		} else {
-			advance = bytes.Index(bytestr[pos:len(bytestr)], re.prefixBytes)
+			advance = bytes.Index(bytestr[pos:], re.prefixBytes)
 		}
 		if advance == -1 {
 			return []int{}
@@ -1014,7 +1014,7 @@ func (re *Regexp) ReplaceAllString(src, repl string) string {
 		lastMatchEnd = a[1];
 
 		// Advance past this match; always advance at least one character.
-		_, width := utf8.DecodeRuneInString(src[searchPos:len(src)]);
+		_, width := utf8.DecodeRuneInString(src[searchPos:]);
 		if searchPos+width > a[1] {
 			searchPos += width
 		} else if searchPos+1 > a[1] {
@@ -1027,7 +1027,7 @@ func (re *Regexp) ReplaceAllString(src, repl string) string {
 	}
 
 	// Copy the unmatched characters after the last match.
-	io.WriteString(buf, src[lastMatchEnd:len(src)]);
+	io.WriteString(buf, src[lastMatchEnd:]);
 
 	return buf.String();
 }
@@ -1058,7 +1058,7 @@ func (re *Regexp) ReplaceAll(src, repl []byte) []byte {
 		lastMatchEnd = a[1];
 
 		// Advance past this match; always advance at least one character.
-		_, width := utf8.DecodeRune(src[searchPos:len(src)]);
+		_, width := utf8.DecodeRune(src[searchPos:]);
 		if searchPos+width > a[1] {
 			searchPos += width
 		} else if searchPos+1 > a[1] {
@@ -1071,7 +1071,7 @@ func (re *Regexp) ReplaceAll(src, repl []byte) []byte {
 	}
 
 	// Copy the unmatched characters after the last match.
-	buf.Write(src[lastMatchEnd:len(src)]);
+	buf.Write(src[lastMatchEnd:]);
 
 	return buf.Bytes();
 }
diff --git a/src/pkg/strconv/atoi.go b/src/pkg/strconv/atoi.go
index a9d03dac17..bcfaf2ce58 100644
--- a/src/pkg/strconv/atoi.go
+++ b/src/pkg/strconv/atoi.go
@@ -56,7 +56,7 @@ func Btoui64(s string, b int) (n uint64, err os.Error) {
 		switch {
 		case s[0] == '0' && len(s) > 1 && (s[1] == 'x' || s[1] == 'X'):
 			b = 16;
-			s = s[2:len(s)];
+			s = s[2:];
 			if len(s) < 1 {
 				err = os.EINVAL;
 				goto Error;
@@ -140,10 +140,10 @@ func Btoi64(s string, base int) (i int64, err os.Error) {
 	s0 := s;
 	neg := false;
 	if s[0] == '+' {
-		s = s[1:len(s)]
+		s = s[1:]
 	} else if s[0] == '-' {
 		neg = true;
-		s = s[1:len(s)];
+		s = s[1:];
 	}
 
 	// Convert unsigned and check range.
diff --git a/src/pkg/strconv/atoi_test.go b/src/pkg/strconv/atoi_test.go
index 58554d3043..37027aa6fd 100644
--- a/src/pkg/strconv/atoi_test.go
+++ b/src/pkg/strconv/atoi_test.go
@@ -70,7 +70,7 @@ var atoi64tests = []atoi64Test{
 	atoi64Test{"98765432100", 98765432100, nil},
 	atoi64Test{"-98765432100", -98765432100, nil},
 	atoi64Test{"9223372036854775807", 1<<63 - 1, nil},
-	atoi64Test{"-9223372036854775807", -(1 << 63 - 1), nil},
+	atoi64Test{"-9223372036854775807", -(1<<63 - 1), nil},
 	atoi64Test{"9223372036854775808", 1<<63 - 1, os.ERANGE},
 	atoi64Test{"-9223372036854775808", -1 << 63, nil},
 	atoi64Test{"9223372036854775809", 1<<63 - 1, os.ERANGE},
@@ -94,7 +94,7 @@ var btoi64tests = []atoi64Test{
 	atoi64Test{"98765432100", 98765432100, nil},
 	atoi64Test{"-98765432100", -98765432100, nil},
 	atoi64Test{"9223372036854775807", 1<<63 - 1, nil},
-	atoi64Test{"-9223372036854775807", -(1 << 63 - 1), nil},
+	atoi64Test{"-9223372036854775807", -(1<<63 - 1), nil},
 	atoi64Test{"9223372036854775808", 1<<63 - 1, os.ERANGE},
 	atoi64Test{"-9223372036854775808", -1 << 63, nil},
 	atoi64Test{"9223372036854775809", 1<<63 - 1, os.ERANGE},
@@ -140,7 +140,7 @@ var atoi32tests = []atoi32Test{
 	atoi32Test{"987654321", 987654321, nil},
 	atoi32Test{"-987654321", -987654321, nil},
 	atoi32Test{"2147483647", 1<<31 - 1, nil},
-	atoi32Test{"-2147483647", -(1 << 31 - 1), nil},
+	atoi32Test{"-2147483647", -(1<<31 - 1), nil},
 	atoi32Test{"2147483648", 1<<31 - 1, os.ERANGE},
 	atoi32Test{"-2147483648", -1 << 31, nil},
 	atoi32Test{"2147483649", 1<<31 - 1, os.ERANGE},
diff --git a/src/pkg/strconv/ftoa.go b/src/pkg/strconv/ftoa.go
index a285b64027..7300cd8615 100644
--- a/src/pkg/strconv/ftoa.go
+++ b/src/pkg/strconv/ftoa.go
@@ -397,7 +397,7 @@ func fmtB(neg bool, mant uint64, exp int, flt *floatInfo) string {
 		w--;
 		buf[w] = '-';
 	}
-	return string(buf[w:len(buf)]);
+	return string(buf[w:]);
 }
 
 func max(a, b int) int {
diff --git a/src/pkg/strconv/itoa.go b/src/pkg/strconv/itoa.go
index 65d60d79c6..bb4810453c 100644
--- a/src/pkg/strconv/itoa.go
+++ b/src/pkg/strconv/itoa.go
@@ -20,7 +20,7 @@ func Uitob64(u uint64, base uint) string {
 		u /= b;
 	}
 
-	return string(buf[j:len(buf)]);
+	return string(buf[j:]);
 }
 
 // Itob64 returns the string representation of i in the given base.
diff --git a/src/pkg/strconv/quote.go b/src/pkg/strconv/quote.go
index 2e4ab1c3cb..5b5911db0f 100644
--- a/src/pkg/strconv/quote.go
+++ b/src/pkg/strconv/quote.go
@@ -21,7 +21,7 @@ const lowerhex = "0123456789abcdef"
 func Quote(s string) string {
 	var buf bytes.Buffer;
 	buf.WriteByte('"');
-	for ; len(s) > 0; s = s[1:len(s)] {
+	for ; len(s) > 0; s = s[1:] {
 		switch c := s[0]; {
 		case c == '"':
 			buf.WriteString(`\"`)
@@ -49,7 +49,7 @@ func Quote(s string) string {
 			if r == utf8.RuneError && size == 1 {
 				goto EscX
 			}
-			s = s[size-1 : len(s)];	// next iteration will slice off 1 more
+			s = s[size-1:];	// next iteration will slice off 1 more
 			if r < 0x10000 {
 				buf.WriteString(`\u`);
 				for j := uint(0); j < 4; j++ {
@@ -118,9 +118,9 @@ func UnquoteChar(s string, quote byte) (value int, multibyte bool, tail string,
 		return;
 	case c >= utf8.RuneSelf:
 		r, size := utf8.DecodeRuneInString(s);
-		return r, true, s[size:len(s)], nil;
+		return r, true, s[size:], nil;
 	case c != '\\':
-		return int(s[0]), false, s[1:len(s)], nil
+		return int(s[0]), false, s[1:], nil
 	}
 
 	// hard case: c is backslash
@@ -129,7 +129,7 @@ func UnquoteChar(s string, quote byte) (value int, multibyte bool, tail string,
 		return;
 	}
 	c := s[1];
-	s = s[2:len(s)];
+	s = s[2:];
 
 	switch c {
 	case 'a':
@@ -169,7 +169,7 @@ func UnquoteChar(s string, quote byte) (value int, multibyte bool, tail string,
 			}
 			v = v<<4 | x;
 		}
-		s = s[n:len(s)];
+		s = s[n:];
 		if c == 'x' {
 			// single-byte string, possibly not UTF-8
 			value = v;
@@ -194,7 +194,7 @@ func UnquoteChar(s string, quote byte) (value int, multibyte bool, tail string,
 			}
 			v = (v << 3) | x;
 		}
-		s = s[2:len(s)];
+		s = s[2:];
 		if v > 255 {
 			err = os.EINVAL;
 			return;
diff --git a/src/pkg/strings/reader.go b/src/pkg/strings/reader.go
index 880bafacdd..80c745bb8b 100644
--- a/src/pkg/strings/reader.go
+++ b/src/pkg/strings/reader.go
@@ -19,7 +19,7 @@ func (r *Reader) Read(b []byte) (n int, err os.Error) {
 		b[n] = s[n];
 		n++;
 	}
-	*r = s[n:len(s)];
+	*r = s[n:];
 	return;
 }
 
@@ -29,7 +29,7 @@ func (r *Reader) ReadByte() (b byte, err os.Error) {
 		return 0, os.EOF
 	}
 	b = s[0];
-	*r = s[1:len(s)];
+	*r = s[1:];
 	return;
 }
 
diff --git a/src/pkg/strings/strings.go b/src/pkg/strings/strings.go
index fb3070a1a5..1578b3db69 100644
--- a/src/pkg/strings/strings.go
+++ b/src/pkg/strings/strings.go
@@ -26,7 +26,7 @@ func explode(s string, n int) []string {
 			break;
 		}
 		rune, size = utf8.DecodeRuneInString(s);
-		s = s[size:len(s)];
+		s = s[size:];
 		a[na] = string(rune);
 		na++;
 	}
@@ -118,7 +118,7 @@ func genSplit(s, sep string, sepSave, n int) []string {
 			i += len(sep) - 1;
 		}
 	}
-	a[na] = s[start:len(s)];
+	a[na] = s[start:];
 	return a[0 : na+1];
 }
 
@@ -174,7 +174,7 @@ func HasPrefix(s, prefix string) bool {
 
 // HasSuffix tests whether the string s ends with suffix.
 func HasSuffix(s, suffix string) bool {
-	return len(s) >= len(suffix) && s[len(s)-len(suffix):len(s)] == suffix
+	return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
 }
 
 // Map returns a copy of the string s with all its characters modified
diff --git a/src/pkg/syscall/errstr.go b/src/pkg/syscall/errstr.go
index 136aea9980..87c354d050 100644
--- a/src/pkg/syscall/errstr.go
+++ b/src/pkg/syscall/errstr.go
@@ -17,7 +17,7 @@ func str(val int) string {	// do it here rather than with fmt to avoid dependenc
 		val /= 10;
 	}
 	buf[i] = byte(val + '0');
-	return string(buf[i:len(buf)]);
+	return string(buf[i:]);
 }
 
 func Errstr(errno int) string {
diff --git a/src/pkg/syscall/syscall_linux.go b/src/pkg/syscall/syscall_linux.go
index 930d99be65..f94dc7df75 100644
--- a/src/pkg/syscall/syscall_linux.go
+++ b/src/pkg/syscall/syscall_linux.go
@@ -416,8 +416,8 @@ func ptracePeek(req int, pid int, addr uintptr, out []byte) (count int, errno in
 		if errno != 0 {
 			return 0, errno
 		}
-		n += bytesCopy(out, buf[addr%sizeofPtr:len(buf)]);
-		out = out[n:len(out)];
+		n += bytesCopy(out, buf[addr%sizeofPtr:]);
+		out = out[n:];
 	}
 
 	// Remainder.
@@ -430,7 +430,7 @@ func ptracePeek(req int, pid int, addr uintptr, out []byte) (count int, errno in
 		}
 		copied := bytesCopy(out, &buf);
 		n += copied;
-		out = out[copied:len(out)];
+		out = out[copied:];
 	}
 
 	return n, 0;
@@ -456,13 +456,13 @@ func ptracePoke(pokeReq int, peekReq int, pid int, addr uintptr, data []byte) (c
 		if errno != 0 {
 			return 0, errno
 		}
-		n += bytesCopy(buf[addr%sizeofPtr:len(buf)], data);
+		n += bytesCopy(buf[addr%sizeofPtr:], data);
 		word := *((*uintptr)(unsafe.Pointer(&buf[0])));
 		errno = ptrace(pokeReq, pid, addr-addr%sizeofPtr, word);
 		if errno != 0 {
 			return 0, errno
 		}
-		data = data[n:len(data)];
+		data = data[n:];
 	}
 
 	// Interior.
@@ -473,7 +473,7 @@ func ptracePoke(pokeReq int, peekReq int, pid int, addr uintptr, data []byte) (c
 			return n, errno
 		}
 		n += sizeofPtr;
-		data = data[sizeofPtr:len(data)];
+		data = data[sizeofPtr:];
 	}
 
 	// Trailing edge.
diff --git a/src/pkg/tabwriter/tabwriter.go b/src/pkg/tabwriter/tabwriter.go
index c469ae41db..7099d3fd47 100644
--- a/src/pkg/tabwriter/tabwriter.go
+++ b/src/pkg/tabwriter/tabwriter.go
@@ -542,7 +542,7 @@ func (b *Writer) Write(buf []byte) (n int, err os.Error) {
 	}
 
 	// append leftover text
-	b.append(buf[n:len(buf)]);
+	b.append(buf[n:]);
 	n = len(buf);
 	return;
 }
diff --git a/src/pkg/template/format.go b/src/pkg/template/format.go
index 21c11c659e..e79469e6f1 100644
--- a/src/pkg/template/format.go
+++ b/src/pkg/template/format.go
@@ -53,7 +53,7 @@ func HTMLEscape(w io.Writer, s []byte) {
 		w.Write(esc);
 		last = i + 1;
 	}
-	w.Write(s[last:len(s)]);
+	w.Write(s[last:]);
 }
 
 // HTMLFormatter formats arbitrary values for HTML
diff --git a/src/pkg/template/template.go b/src/pkg/template/template.go
index 6964d67f43..3cd9b542c5 100644
--- a/src/pkg/template/template.go
+++ b/src/pkg/template/template.go
@@ -199,7 +199,7 @@ func white(c uint8) bool	{ return c == ' ' || c == '\t' || c == '\r' || c == '\n
 
 // Safely, does s[n:n+len(t)] == t?
 func equal(s []byte, n int, t []byte) bool {
-	b := s[n:len(s)];
+	b := s[n:];
 	if len(t) > len(b) {	// not enough space left for a match.
 		return false
 	}
@@ -387,7 +387,7 @@ func (t *Template) newVariable(name_formatter string) (v *variableElement) {
 	bar := strings.Index(name_formatter, "|");
 	if bar >= 0 {
 		name = name_formatter[0:bar];
-		formatter = name_formatter[bar+1 : len(name_formatter)];
+		formatter = name_formatter[bar+1:];
 	}
 	// Probably ok, so let's build it.
 	v = &variableElement{t.linenum, name, formatter};
diff --git a/src/pkg/testing/iotest/reader.go b/src/pkg/testing/iotest/reader.go
index ce2da08b03..0a1a3f6b3c 100644
--- a/src/pkg/testing/iotest/reader.go
+++ b/src/pkg/testing/iotest/reader.go
@@ -63,7 +63,7 @@ func (r *dataErrReader) Read(p []byte) (n int, err os.Error) {
 			break
 		}
 		n = copy(p, r.unread);
-		r.unread = r.unread[n:len(r.unread)];
+		r.unread = r.unread[n:];
 	}
 	return;
 }
diff --git a/src/pkg/testing/regexp.go b/src/pkg/testing/regexp.go
index 0df9bb4717..0675a4e54b 100644
--- a/src/pkg/testing/regexp.go
+++ b/src/pkg/testing/regexp.go
@@ -282,7 +282,7 @@ func (p *parser) nextc() int {
 	if p.pos >= len(p.re.expr) {
 		p.ch = endOfFile
 	} else {
-		c, w := utf8.DecodeRuneInString(p.re.expr[p.pos:len(p.re.expr)]);
+		c, w := utf8.DecodeRuneInString(p.re.expr[p.pos:]);
 		p.ch = c;
 		p.pos += w;
 	}
diff --git a/src/pkg/time/zoneinfo.go b/src/pkg/time/zoneinfo.go
index 4316bbd8b9..40f8f0feb6 100644
--- a/src/pkg/time/zoneinfo.go
+++ b/src/pkg/time/zoneinfo.go
@@ -34,7 +34,7 @@ func (d *data) read(n int) []byte {
 		return nil;
 	}
 	p := d.p[0:n];
-	d.p = d.p[n:len(d.p)];
+	d.p = d.p[n:];
 	return p;
 }
 
@@ -168,7 +168,7 @@ func parseinfo(bytes []byte) (zt []zonetime, ok bool) {
 		if b, ok = zonedata.byte(); !ok || int(b) >= len(abbrev) {
 			return nil, false
 		}
-		z[i].name = byteString(abbrev[b:len(abbrev)]);
+		z[i].name = byteString(abbrev[b:]);
 	}
 
 	// Now the transition time info.
@@ -234,7 +234,7 @@ func lookupTimezone(sec int64) (zone string, offset int) {
 		if sec < int64(tz[m].time) {
 			tz = tz[0:m]
 		} else {
-			tz = tz[m:len(tz)]
+			tz = tz[m:]
 		}
 	}
 	z := tz[0].zone;
diff --git a/src/pkg/unicode/maketables.go b/src/pkg/unicode/maketables.go
index 066415f8ff..e376172b87 100644
--- a/src/pkg/unicode/maketables.go
+++ b/src/pkg/unicode/maketables.go
@@ -487,7 +487,7 @@ func parseScript(line string, scripts map[string][]Script) {
 	}
 	hi := lo;
 	if len(matches[2]) > 2 {	// ignore leading ..
-		hi, err = strconv.Btoui64(matches[2][2:len(matches[2])], 16);
+		hi, err = strconv.Btoui64(matches[2][2:], 16);
 		if err != nil {
 			die.Log("%.5s...:", err)
 		}
diff --git a/src/pkg/utf8/utf8.go b/src/pkg/utf8/utf8.go
index f665050089..969d10ab44 100644
--- a/src/pkg/utf8/utf8.go
+++ b/src/pkg/utf8/utf8.go
@@ -265,7 +265,7 @@ func RuneCount(p []byte) int {
 		if p[i] < RuneSelf {
 			i++
 		} else {
-			_, size := DecodeRune(p[i:len(p)]);
+			_, size := DecodeRune(p[i:]);
 			i += size;
 		}
 	}
diff --git a/src/pkg/xml/read.go b/src/pkg/xml/read.go
index d5f6842584..5685787230 100644
--- a/src/pkg/xml/read.go
+++ b/src/pkg/xml/read.go
@@ -231,7 +231,7 @@ func (p *Parser) unmarshal(val reflect.Value, start *StartElement) os.Error {
 				ns := "";
 				i := strings.LastIndex(tag, " ");
 				if i >= 0 {
-					ns, tag = tag[0:i], tag[i+1:len(tag)]
+					ns, tag = tag[0:i], tag[i+1:]
 				}
 				if tag != start.Name.Local {
 					return UnmarshalError("expected element type <" + tag + "> but have <" + start.Name.Local + ">")
diff --git a/src/pkg/xml/xml.go b/src/pkg/xml/xml.go
index c3b91fd5fa..6e7b3d30bf 100644
--- a/src/pkg/xml/xml.go
+++ b/src/pkg/xml/xml.go
@@ -749,9 +749,9 @@ Input:
 				var n uint64;
 				var err os.Error;
 				if i >= 3 && s[1] == 'x' {
-					n, err = strconv.Btoui64(s[2:len(s)], 16)
+					n, err = strconv.Btoui64(s[2:], 16)
 				} else {
-					n, err = strconv.Btoui64(s[1:len(s)], 10)
+					n, err = strconv.Btoui64(s[1:], 10)
 				}
 				if err == nil && n <= unicode.MaxRune {
 					text = string(n);
@@ -813,7 +813,7 @@ func (p *Parser) nsname() (name Name, ok bool) {
 		name.Local = s
 	} else {
 		name.Space = s[0:i];
-		name.Local = s[i+1 : len(s)];
+		name.Local = s[i+1:];
 	}
 	return name, true;
 }
