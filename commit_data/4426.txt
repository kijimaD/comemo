commit d65a5cce89596e0256280ab8318548d3fa5bb09b
Author: Robert Griesemer <gri@golang.org>
Date:   Tue Dec 15 15:40:16 2009 -0800

    1) Change default gofmt default settings for
       parsing and printing to new syntax.
    
       Use -oldparser to parse the old syntax,
       use -oldprinter to print the old syntax.
    
    2) Change default gofmt formatting settings
       to use tabs for indentation only and to use
       spaces for alignment. This will make the code
       alignment insensitive to an editor's tabwidth.
    
       Use -spaces=false to use tabs for alignment.
    
    3) Manually changed src/exp/parser/parser_test.go
       so that it doesn't try to parse the parser's
       source files using the old syntax (they have
       new syntax now).
    
    4) gofmt -w src misc test/bench
    
    4th set of files.
    
    R=rsc
    CC=golang-dev
    https://golang.org/cl/180049
---
 src/pkg/once/once.go                      |   28 +-
 src/pkg/once/once_test.go                 |   14 +-
 src/pkg/os/dir_darwin.go                  |   56 +-
 src/pkg/os/dir_freebsd.go                 |   56 +-
 src/pkg/os/dir_linux.go                   |   50 +-
 src/pkg/os/dir_nacl.go                    |   50 +-
 src/pkg/os/env.go                         |   40 +-
 src/pkg/os/error.go                       |   98 +--
 src/pkg/os/exec.go                        |   72 +-
 src/pkg/os/file.go                        |  224 +++----
 src/pkg/os/getwd.go                       |   44 +-
 src/pkg/os/os_test.go                     |  366 +++++-----
 src/pkg/os/path.go                        |   42 +-
 src/pkg/os/path_test.go                   |   56 +-
 src/pkg/os/proc.go                        |   18 +-
 src/pkg/os/stat_darwin.go                 |   34 +-
 src/pkg/os/stat_freebsd.go                |   34 +-
 src/pkg/os/stat_linux.go                  |   34 +-
 src/pkg/os/stat_nacl.go                   |   34 +-
 src/pkg/os/sys_darwin.go                  |    6 +-
 src/pkg/os/sys_freebsd.go                 |    6 +-
 src/pkg/os/sys_linux.go                   |   10 +-
 src/pkg/os/sys_nacl.go                    |    2 +-
 src/pkg/os/time.go                        |    4 +-
 src/pkg/os/types.go                       |   48 +-
 src/pkg/patch/apply.go                    |   32 +-
 src/pkg/patch/git.go                      |   78 +--
 src/pkg/patch/patch.go                    |  192 +++---
 src/pkg/patch/patch_test.go               |   26 +-
 src/pkg/patch/textdiff.go                 |  100 +--
 src/pkg/path/path.go                      |   70 +-
 src/pkg/path/path_test.go                 |   74 +-
 src/pkg/rand/exp.go                       |   12 +-
 src/pkg/rand/normal.go                    |   20 +-
 src/pkg/rand/rand.go                      |   96 +--
 src/pkg/rand/rand_test.go                 |  202 +++---
 src/pkg/rand/rng.go                       |   68 +-
 src/pkg/reflect/all_test.go               |  634 +++++++++---------
 src/pkg/reflect/deepequal.go              |   58 +-
 src/pkg/reflect/tostring_test.go          |   64 +-
 src/pkg/reflect/type.go                   |  322 ++++-----
 src/pkg/reflect/value.go                  |  616 ++++++++---------
 src/pkg/regexp/all_test.go                |  206 +++---
 src/pkg/regexp/regexp.go                  |  892 ++++++++++++-------------
 src/pkg/rpc/client.go                     |  164 ++---
 src/pkg/rpc/debug.go                      |   54 +-
 src/pkg/rpc/server.go                     |  274 ++++----
 src/pkg/rpc/server_test.go                |  136 ++--
 src/pkg/runtime/type.go                   |  168 ++---
 src/pkg/sort/sort.go                      |  126 ++--
 src/pkg/sort/sort_test.go                 |  188 +++---
 src/pkg/strconv/atof.go                   |  204 +++---
 src/pkg/strconv/atof_test.go              |   38 +-
 src/pkg/strconv/atoi.go                   |  106 +--
 src/pkg/strconv/atoi_test.go              |   76 +--
 src/pkg/strconv/decimal.go                |  266 ++++----
 src/pkg/strconv/decimal_test.go           |   40 +-
 src/pkg/strconv/fp_test.go                |  116 ++--
 src/pkg/strconv/ftoa.go                   |  208 +++---
 src/pkg/strconv/ftoa_test.go              |   26 +-
 src/pkg/strconv/internal_test.go          |    8 +-
 src/pkg/strconv/itoa.go                   |   28 +-
 src/pkg/strconv/itoa_test.go              |   40 +-
 src/pkg/strconv/quote.go                  |  134 ++--
 src/pkg/strconv/quote_test.go             |   26 +-
 src/pkg/strings/reader.go                 |   20 +-
 src/pkg/strings/strings.go                |  164 ++---
 src/pkg/strings/strings_test.go           |  160 ++---
 src/pkg/sync/mutex.go                     |   14 +-
 src/pkg/sync/mutex_test.go                |   76 +--
 src/pkg/sync/rwmutex.go                   |   18 +-
 src/pkg/sync/rwmutex_test.go              |   88 +--
 src/pkg/syscall/errstr.go                 |   18 +-
 src/pkg/syscall/exec.go                   |  118 ++--
 src/pkg/syscall/syscall.go                |    6 +-
 src/pkg/syscall/syscall_darwin.go         |  236 +++----
 src/pkg/syscall/syscall_darwin_386.go     |   34 +-
 src/pkg/syscall/syscall_darwin_amd64.go   |   34 +-
 src/pkg/syscall/syscall_freebsd.go        |  236 +++----
 src/pkg/syscall/syscall_freebsd_386.go    |   26 +-
 src/pkg/syscall/syscall_freebsd_amd64.go  |   26 +-
 src/pkg/syscall/syscall_linux.go          |  278 ++++----
 src/pkg/syscall/syscall_linux_386.go      |  118 ++--
 src/pkg/syscall/syscall_linux_amd64.go    |   24 +-
 src/pkg/syscall/syscall_linux_arm.go      |   22 +-
 src/pkg/syscall/syscall_nacl.go           |  180 ++---
 src/pkg/syscall/syscall_nacl_386.go       |   14 +-
 src/pkg/syscall/zerrors_darwin_386.go     | 1038 ++++++++++++++--------------
 src/pkg/syscall/zerrors_darwin_amd64.go   | 1038 ++++++++++++++--------------
 src/pkg/syscall/zerrors_freebsd_386.go    | 1040 ++++++++++++++---------------
 src/pkg/syscall/zerrors_freebsd_amd64.go  | 1040 ++++++++++++++---------------
 src/pkg/syscall/zerrors_linux_386.go      | 1020 ++++++++++++++--------------
 src/pkg/syscall/zerrors_linux_amd64.go    | 1020 ++++++++++++++--------------
 src/pkg/syscall/zerrors_linux_arm.go      |  342 +++++-----
 src/pkg/syscall/zerrors_nacl_386.go       |  240 +++----
 src/pkg/syscall/zsyscall_darwin_386.go    |  684 +++++++++----------
 src/pkg/syscall/zsyscall_darwin_amd64.go  |  684 +++++++++----------
 src/pkg/syscall/zsyscall_freebsd_386.go   |  668 +++++++++---------
 src/pkg/syscall/zsyscall_freebsd_amd64.go |  668 +++++++++---------
 src/pkg/syscall/zsyscall_linux_386.go     |  720 ++++++++++----------
 src/pkg/syscall/zsyscall_linux_amd64.go   |  816 +++++++++++-----------
 src/pkg/syscall/zsyscall_linux_arm.go     |  798 +++++++++++-----------
 src/pkg/syscall/zsyscall_nacl_386.go      |  224 +++----
 src/pkg/syscall/zsysnum_darwin_386.go     |  646 +++++++++---------
 src/pkg/syscall/zsysnum_darwin_amd64.go   |  646 +++++++++---------
 src/pkg/syscall/zsysnum_freebsd_386.go    |  624 ++++++++---------
 src/pkg/syscall/zsysnum_freebsd_amd64.go  |  624 ++++++++---------
 src/pkg/syscall/zsysnum_linux_386.go      |  620 ++++++++---------
 src/pkg/syscall/zsysnum_linux_amd64.go    |  574 ++++++++--------
 src/pkg/syscall/zsysnum_linux_arm.go      |  656 +++++++++---------
 src/pkg/syscall/zsysnum_nacl_386.go       |  108 +--
 src/pkg/syscall/ztypes_darwin_386.go      |  274 ++++----
 src/pkg/syscall/ztypes_darwin_amd64.go    |  284 ++++----
 src/pkg/syscall/ztypes_freebsd_386.go     |  288 ++++----
 src/pkg/syscall/ztypes_freebsd_amd64.go   |  294 ++++----
 src/pkg/syscall/ztypes_linux_386.go       |  374 +++++------
 src/pkg/syscall/ztypes_linux_amd64.go     |  394 +++++------
 src/pkg/syscall/ztypes_linux_arm.go       |  554 +++++++--------
 src/pkg/syscall/ztypes_nacl_386.go        |  136 ++--
 119 files changed, 14330 insertions(+), 14330 deletions(-)

diff --git a/src/pkg/once/once.go b/src/pkg/once/once.go
index 3270f9aec4..b53cd97bd8 100644
--- a/src/pkg/once/once.go
+++ b/src/pkg/once/once.go
@@ -9,8 +9,8 @@ package once
 import "sync"
 
 type job struct {
-	done		bool;
-	sync.Mutex;	// should probably be sync.Notification or some such
+	done       bool
+	sync.Mutex // should probably be sync.Notification or some such
 }
 
 var jobs = make(map[func()]*job)
@@ -37,23 +37,23 @@ var joblock sync.Mutex
 // because the func() expression in the first creates a new
 // func each time f runs, and each of those funcs is run once.
 func Do(f func()) {
-	joblock.Lock();
-	j, present := jobs[f];
+	joblock.Lock()
+	j, present := jobs[f]
 	if !present {
 		// run it
-		j = new(job);
-		j.Lock();
-		jobs[f] = j;
-		joblock.Unlock();
-		f();
-		j.done = true;
-		j.Unlock();
+		j = new(job)
+		j.Lock()
+		jobs[f] = j
+		joblock.Unlock()
+		f()
+		j.done = true
+		j.Unlock()
 	} else {
 		// wait for it
-		joblock.Unlock();
+		joblock.Unlock()
 		if j.done != true {
-			j.Lock();
-			j.Unlock();
+			j.Lock()
+			j.Unlock()
 		}
 	}
 }
diff --git a/src/pkg/once/once_test.go b/src/pkg/once/once_test.go
index e31bcc278f..e7aaec3120 100644
--- a/src/pkg/once/once_test.go
+++ b/src/pkg/once/once_test.go
@@ -5,25 +5,25 @@
 package once_test
 
 import (
-	"once";
-	"testing";
+	"once"
+	"testing"
 )
 
 var ncall int
 
-func call()	{ ncall++ }
+func call() { ncall++ }
 
 func TestDo(t *testing.T) {
-	ncall = 0;
-	once.Do(call);
+	ncall = 0
+	once.Do(call)
 	if ncall != 1 {
 		t.Fatalf("once.Do(call) didn't call(): ncall=%d", ncall)
 	}
-	once.Do(call);
+	once.Do(call)
 	if ncall != 1 {
 		t.Fatalf("second once.Do(call) did call(): ncall=%d", ncall)
 	}
-	once.Do(call);
+	once.Do(call)
 	if ncall != 1 {
 		t.Fatalf("third once.Do(call) did call(): ncall=%d", ncall)
 	}
diff --git a/src/pkg/os/dir_darwin.go b/src/pkg/os/dir_darwin.go
index 9b9d02ea8a..7917daec6b 100644
--- a/src/pkg/os/dir_darwin.go
+++ b/src/pkg/os/dir_darwin.go
@@ -5,12 +5,12 @@
 package os
 
 import (
-	"syscall";
-	"unsafe";
+	"syscall"
+	"unsafe"
 )
 
 const (
-	blockSize = 4096;	// TODO(r): use statfs
+	blockSize = 4096 // TODO(r): use statfs
 )
 
 // Readdirnames reads the contents of the directory associated with file and
@@ -21,59 +21,59 @@ const (
 func (file *File) Readdirnames(count int) (names []string, err Error) {
 	// If this file has no dirinfo, create one.
 	if file.dirinfo == nil {
-		file.dirinfo = new(dirInfo);
+		file.dirinfo = new(dirInfo)
 		// The buffer must be at least a block long.
 		// TODO(r): use fstatfs to find fs block size.
-		file.dirinfo.buf = make([]byte, blockSize);
+		file.dirinfo.buf = make([]byte, blockSize)
 	}
-	d := file.dirinfo;
-	size := count;
+	d := file.dirinfo
+	size := count
 	if size < 0 {
 		size = 100
 	}
-	names = make([]string, 0, size);	// Empty with room to grow.
+	names = make([]string, 0, size) // Empty with room to grow.
 	for count != 0 {
 		// Refill the buffer if necessary
 		if d.bufp >= d.nbuf {
-			var errno int;
-			d.bufp = 0;
+			var errno int
+			d.bufp = 0
 			// Final argument is (basep *uintptr) and the syscall doesn't take nil.
-			d.nbuf, errno = syscall.Getdirentries(file.fd, d.buf, new(uintptr));
+			d.nbuf, errno = syscall.Getdirentries(file.fd, d.buf, new(uintptr))
 			if errno != 0 {
-				d.nbuf = 0;
-				return names, NewSyscallError("getdirentries", errno);
+				d.nbuf = 0
+				return names, NewSyscallError("getdirentries", errno)
 			}
 			if d.nbuf <= 0 {
-				break	// EOF
+				break // EOF
 			}
 		}
 		// Drain the buffer
 		for count != 0 && d.bufp < d.nbuf {
-			dirent := (*syscall.Dirent)(unsafe.Pointer(&d.buf[d.bufp]));
+			dirent := (*syscall.Dirent)(unsafe.Pointer(&d.buf[d.bufp]))
 			if dirent.Reclen == 0 {
-				d.bufp = d.nbuf;
-				break;
+				d.bufp = d.nbuf
+				break
 			}
-			d.bufp += int(dirent.Reclen);
-			if dirent.Ino == 0 {	// File absent in directory.
+			d.bufp += int(dirent.Reclen)
+			if dirent.Ino == 0 { // File absent in directory.
 				continue
 			}
-			bytes := (*[len(dirent.Name)]byte)(unsafe.Pointer(&dirent.Name[0]));
-			var name = string(bytes[0:dirent.Namlen]);
-			if name == "." || name == ".." {	// Useless names
+			bytes := (*[len(dirent.Name)]byte)(unsafe.Pointer(&dirent.Name[0]))
+			var name = string(bytes[0:dirent.Namlen])
+			if name == "." || name == ".." { // Useless names
 				continue
 			}
-			count--;
+			count--
 			if len(names) == cap(names) {
-				nnames := make([]string, len(names), 2*len(names));
+				nnames := make([]string, len(names), 2*len(names))
 				for i := 0; i < len(names); i++ {
 					nnames[i] = names[i]
 				}
-				names = nnames;
+				names = nnames
 			}
-			names = names[0 : len(names)+1];
-			names[len(names)-1] = name;
+			names = names[0 : len(names)+1]
+			names[len(names)-1] = name
 		}
 	}
-	return names, nil;
+	return names, nil
 }
diff --git a/src/pkg/os/dir_freebsd.go b/src/pkg/os/dir_freebsd.go
index 34f4b9f13f..7a0290ac6a 100644
--- a/src/pkg/os/dir_freebsd.go
+++ b/src/pkg/os/dir_freebsd.go
@@ -5,70 +5,70 @@
 package os
 
 import (
-	"syscall";
-	"unsafe";
+	"syscall"
+	"unsafe"
 )
 
 const (
-	blockSize = 4096;	// TODO(r): use statfs
+	blockSize = 4096 // TODO(r): use statfs
 )
 
 func (file *File) Readdirnames(count int) (names []string, err Error) {
 	// If this file has no dirinfo, create one.
 	if file.dirinfo == nil {
-		file.dirinfo = new(dirInfo);
+		file.dirinfo = new(dirInfo)
 		// The buffer must be at least a block long.
 		// TODO(r): use fstatfs to find fs block size.
-		file.dirinfo.buf = make([]byte, blockSize);
+		file.dirinfo.buf = make([]byte, blockSize)
 	}
-	d := file.dirinfo;
-	size := count;
+	d := file.dirinfo
+	size := count
 	if size < 0 {
 		size = 100
 	}
-	names = make([]string, 0, size);	// Empty with room to grow.
+	names = make([]string, 0, size) // Empty with room to grow.
 	for count != 0 {
 		// Refill the buffer if necessary
 		if d.bufp >= d.nbuf {
-			var errno int;
-			d.bufp = 0;
+			var errno int
+			d.bufp = 0
 			// Final argument is (basep *uintptr) and the syscall doesn't take nil.
-			d.nbuf, errno = syscall.Getdirentries(file.fd, d.buf, new(uintptr));
+			d.nbuf, errno = syscall.Getdirentries(file.fd, d.buf, new(uintptr))
 			if errno != 0 {
-				d.nbuf = 0;
-				return names, NewSyscallError("getdirentries", errno);
+				d.nbuf = 0
+				return names, NewSyscallError("getdirentries", errno)
 			}
 			if d.nbuf <= 0 {
-				break	// EOF
+				break // EOF
 			}
 		}
 		// Drain the buffer
 		for count != 0 && d.bufp < d.nbuf {
-			dirent := (*syscall.Dirent)(unsafe.Pointer(&d.buf[d.bufp]));
+			dirent := (*syscall.Dirent)(unsafe.Pointer(&d.buf[d.bufp]))
 			if dirent.Reclen == 0 {
-				d.bufp = d.nbuf;
-				break;
+				d.bufp = d.nbuf
+				break
 			}
-			d.bufp += int(dirent.Reclen);
-			if dirent.Fileno == 0 {	// File absent in directory.
+			d.bufp += int(dirent.Reclen)
+			if dirent.Fileno == 0 { // File absent in directory.
 				continue
 			}
-			bytes := (*[len(dirent.Name)]byte)(unsafe.Pointer(&dirent.Name[0]));
-			var name = string(bytes[0:dirent.Namlen]);
-			if name == "." || name == ".." {	// Useless names
+			bytes := (*[len(dirent.Name)]byte)(unsafe.Pointer(&dirent.Name[0]))
+			var name = string(bytes[0:dirent.Namlen])
+			if name == "." || name == ".." { // Useless names
 				continue
 			}
-			count--;
+			count--
 			if len(names) == cap(names) {
-				nnames := make([]string, len(names), 2*len(names));
+				nnames := make([]string, len(names), 2*len(names))
 				for i := 0; i < len(names); i++ {
 					nnames[i] = names[i]
 				}
-				names = nnames;
+				names = nnames
 			}
-			names = names[0 : len(names)+1];
-			names[len(names)-1] = name;
+			names = names[0 : len(names)+1]
+			names[len(names)-1] = name
 		}
 	}
-	return names, nil;
+	return names, nil
 }
diff --git a/src/pkg/os/dir_linux.go b/src/pkg/os/dir_linux.go
index 0e73fefd65..e693794f02 100644
--- a/src/pkg/os/dir_linux.go
+++ b/src/pkg/os/dir_linux.go
@@ -5,12 +5,12 @@
 package os
 
 import (
-	"syscall";
-	"unsafe";
+	"syscall"
+	"unsafe"
 )
 
 const (
-	blockSize = 4096;	// TODO(r): use statfs
+	blockSize = 4096 // TODO(r): use statfs
 )
 
 func clen(n []byte) int {
@@ -19,59 +19,59 @@ func clen(n []byte) int {
 			return i
 		}
 	}
-	return len(n);
+	return len(n)
 }
 
 func (file *File) Readdirnames(count int) (names []string, err Error) {
 	// If this file has no dirinfo, create one.
 	if file.dirinfo == nil {
-		file.dirinfo = new(dirInfo);
+		file.dirinfo = new(dirInfo)
 		// The buffer must be at least a block long.
 		// TODO(r): use fstatfs to find fs block size.
-		file.dirinfo.buf = make([]byte, blockSize);
+		file.dirinfo.buf = make([]byte, blockSize)
 	}
-	d := file.dirinfo;
-	size := count;
+	d := file.dirinfo
+	size := count
 	if size < 0 {
 		size = 100
 	}
-	names = make([]string, 0, size);	// Empty with room to grow.
+	names = make([]string, 0, size) // Empty with room to grow.
 	for count != 0 {
 		// Refill the buffer if necessary
 		if d.bufp >= d.nbuf {
-			var errno int;
-			d.nbuf, errno = syscall.Getdents(file.fd, d.buf);
+			var errno int
+			d.nbuf, errno = syscall.Getdents(file.fd, d.buf)
 			if errno != 0 {
 				return names, NewSyscallError("getdents", errno)
 			}
 			if d.nbuf <= 0 {
-				break	// EOF
+				break // EOF
 			}
-			d.bufp = 0;
+			d.bufp = 0
 		}
 		// Drain the buffer
 		for count != 0 && d.bufp < d.nbuf {
-			dirent := (*syscall.Dirent)(unsafe.Pointer(&d.buf[d.bufp]));
-			d.bufp += int(dirent.Reclen);
-			if dirent.Ino == 0 {	// File absent in directory.
+			dirent := (*syscall.Dirent)(unsafe.Pointer(&d.buf[d.bufp]))
+			d.bufp += int(dirent.Reclen)
+			if dirent.Ino == 0 { // File absent in directory.
 				continue
 			}
-			bytes := (*[len(dirent.Name)]byte)(unsafe.Pointer(&dirent.Name[0]));
-			var name = string(bytes[0:clen(bytes)]);
-			if name == "." || name == ".." {	// Useless names
+			bytes := (*[len(dirent.Name)]byte)(unsafe.Pointer(&dirent.Name[0]))
+			var name = string(bytes[0:clen(bytes)])
+			if name == "." || name == ".." { // Useless names
 				continue
 			}
-			count--;
+			count--
 			if len(names) == cap(names) {
-				nnames := make([]string, len(names), 2*len(names));
+				nnames := make([]string, len(names), 2*len(names))
 				for i := 0; i < len(names); i++ {
 					nnames[i] = names[i]
 				}
-				names = nnames;
+				names = nnames
 			}
-			names = names[0 : len(names)+1];
-			names[len(names)-1] = name;
+			names = names[0 : len(names)+1]
+			names[len(names)-1] = name
 		}
 	}
-	return names, nil;
+	return names, nil
 }
diff --git a/src/pkg/os/dir_nacl.go b/src/pkg/os/dir_nacl.go
index 0e73fefd65..e693794f02 100644
--- a/src/pkg/os/dir_nacl.go
+++ b/src/pkg/os/dir_nacl.go
@@ -5,12 +5,12 @@
 package os
 
 import (
-	"syscall";
-	"unsafe";
+	"syscall"
+	"unsafe"
 )
 
 const (
-	blockSize = 4096;	// TODO(r): use statfs
+	blockSize = 4096 // TODO(r): use statfs
 )
 
 func clen(n []byte) int {
@@ -19,59 +19,59 @@ func clen(n []byte) int {
 			return i
 		}
 	}
-	return len(n);
+	return len(n)
 }
 
 func (file *File) Readdirnames(count int) (names []string, err Error) {
 	// If this file has no dirinfo, create one.
 	if file.dirinfo == nil {
-		file.dirinfo = new(dirInfo);
+		file.dirinfo = new(dirInfo)
 		// The buffer must be at least a block long.
 		// TODO(r): use fstatfs to find fs block size.
-		file.dirinfo.buf = make([]byte, blockSize);
+		file.dirinfo.buf = make([]byte, blockSize)
 	}
-	d := file.dirinfo;
-	size := count;
+	d := file.dirinfo
+	size := count
 	if size < 0 {
 		size = 100
 	}
-	names = make([]string, 0, size);	// Empty with room to grow.
+	names = make([]string, 0, size) // Empty with room to grow.
 	for count != 0 {
 		// Refill the buffer if necessary
 		if d.bufp >= d.nbuf {
-			var errno int;
-			d.nbuf, errno = syscall.Getdents(file.fd, d.buf);
+			var errno int
+			d.nbuf, errno = syscall.Getdents(file.fd, d.buf)
 			if errno != 0 {
 				return names, NewSyscallError("getdents", errno)
 			}
 			if d.nbuf <= 0 {
-				break	// EOF
+				break // EOF
 			}
-			d.bufp = 0;
+			d.bufp = 0
 		}
 		// Drain the buffer
 		for count != 0 && d.bufp < d.nbuf {
-			dirent := (*syscall.Dirent)(unsafe.Pointer(&d.buf[d.bufp]));
-			d.bufp += int(dirent.Reclen);
-			if dirent.Ino == 0 {	// File absent in directory.
+			dirent := (*syscall.Dirent)(unsafe.Pointer(&d.buf[d.bufp]))
+			d.bufp += int(dirent.Reclen)
+			if dirent.Ino == 0 { // File absent in directory.
 				continue
 			}
-			bytes := (*[len(dirent.Name)]byte)(unsafe.Pointer(&dirent.Name[0]));
-			var name = string(bytes[0:clen(bytes)]);
-			if name == "." || name == ".." {	// Useless names
+			bytes := (*[len(dirent.Name)]byte)(unsafe.Pointer(&dirent.Name[0]))
+			var name = string(bytes[0:clen(bytes)])
+			if name == "." || name == ".." { // Useless names
 				continue
 			}
-			count--;
+			count--
 			if len(names) == cap(names) {
-				nnames := make([]string, len(names), 2*len(names));
+				nnames := make([]string, len(names), 2*len(names))
 				for i := 0; i < len(names); i++ {
 					nnames[i] = names[i]
 				}
-				names = nnames;
+				names = nnames
 			}
-			names = names[0 : len(names)+1];
-			names[len(names)-1] = name;
+			names = names[0 : len(names)+1]
+			names[len(names)-1] = name
 		}
 	}
-	return names, nil;
+	return names, nil
 }
diff --git a/src/pkg/os/env.go b/src/pkg/os/env.go
index c1713586dd..bdd2ac293c 100644
--- a/src/pkg/os/env.go
+++ b/src/pkg/os/env.go
@@ -7,7 +7,7 @@
 package os
 
 import (
-	"once";
+	"once"
 )
 
 // ENOENV is the Error indicating that an environment variable does not exist.
@@ -17,12 +17,12 @@ var env map[string]string
 
 
 func copyenv() {
-	env = make(map[string]string);
+	env = make(map[string]string)
 	for _, s := range Envs {
 		for j := 0; j < len(s); j++ {
 			if s[j] == '=' {
-				env[s[0:j]] = s[j+1:];
-				break;
+				env[s[0:j]] = s[j+1:]
+				break
 			}
 		}
 	}
@@ -31,56 +31,56 @@ func copyenv() {
 // Getenverror retrieves the value of the environment variable named by the key.
 // It returns the value and an error, if any.
 func Getenverror(key string) (value string, err Error) {
-	once.Do(copyenv);
+	once.Do(copyenv)
 
 	if len(key) == 0 {
 		return "", EINVAL
 	}
-	v, ok := env[key];
+	v, ok := env[key]
 	if !ok {
 		return "", ENOENV
 	}
-	return v, nil;
+	return v, nil
 }
 
 // Getenv retrieves the value of the environment variable named by the key.
 // It returns the value, which will be empty if the variable is not present.
 func Getenv(key string) string {
-	v, _ := Getenverror(key);
-	return v;
+	v, _ := Getenverror(key)
+	return v
 }
 
 // Setenv sets the value of the environment variable named by the key.
 // It returns an Error, if any.
 func Setenv(key, value string) Error {
-	once.Do(copyenv);
+	once.Do(copyenv)
 
 	if len(key) == 0 {
 		return EINVAL
 	}
-	env[key] = value;
-	return nil;
+	env[key] = value
+	return nil
 }
 
 // Clearenv deletes all environment variables.
 func Clearenv() {
-	once.Do(copyenv);	// prevent copyenv in Getenv/Setenv
-	env = make(map[string]string);
+	once.Do(copyenv) // prevent copyenv in Getenv/Setenv
+	env = make(map[string]string)
 }
 
 // Environ returns an array of strings representing the environment,
 // in the form "key=value".
 func Environ() []string {
-	once.Do(copyenv);
-	a := make([]string, len(env));
-	i := 0;
+	once.Do(copyenv)
+	a := make([]string, len(env))
+	i := 0
 	for k, v := range env {
 		// check i < len(a) for safety,
 		// in case env is changing underfoot.
 		if i < len(a) {
-			a[i] = k + "=" + v;
-			i++;
+			a[i] = k + "=" + v
+			i++
 		}
 	}
-	return a[0:i];
+	return a[0:i]
 }
diff --git a/src/pkg/os/error.go b/src/pkg/os/error.go
index 34f88de8d1..8c53f645ae 100644
--- a/src/pkg/os/error.go
+++ b/src/pkg/os/error.go
@@ -8,85 +8,85 @@ import syscall "syscall"
 
 // An Error can represent any printable error condition.
 type Error interface {
-	String() string;
+	String() string
 }
 
 // A helper type that can be embedded or wrapped to simplify satisfying
 // Error.
 type ErrorString string
 
-func (e ErrorString) String() string	{ return string(e) }
+func (e ErrorString) String() string { return string(e) }
 
 // Note: If the name of the function NewError changes,
 // pkg/go/doc/doc.go should be adjusted since it hardwires
 // this name in a heuristic.
 
 // NewError converts s to an ErrorString, which satisfies the Error interface.
-func NewError(s string) Error	{ return ErrorString(s) }
+func NewError(s string) Error { return ErrorString(s) }
 
 // Errno is the Unix error number.  Names such as EINVAL are simple
 // wrappers to convert the error number into an Error.
 type Errno int64
 
-func (e Errno) String() string	{ return syscall.Errstr(int(e)) }
+func (e Errno) String() string { return syscall.Errstr(int(e)) }
 
 // Commonly known Unix errors.
 var (
-	EPERM		Error	= Errno(syscall.EPERM);
-	ENOENT		Error	= Errno(syscall.ENOENT);
-	ESRCH		Error	= Errno(syscall.ESRCH);
-	EINTR		Error	= Errno(syscall.EINTR);
-	EIO		Error	= Errno(syscall.EIO);
-	ENXIO		Error	= Errno(syscall.ENXIO);
-	E2BIG		Error	= Errno(syscall.E2BIG);
-	ENOEXEC		Error	= Errno(syscall.ENOEXEC);
-	EBADF		Error	= Errno(syscall.EBADF);
-	ECHILD		Error	= Errno(syscall.ECHILD);
-	EDEADLK		Error	= Errno(syscall.EDEADLK);
-	ENOMEM		Error	= Errno(syscall.ENOMEM);
-	EACCES		Error	= Errno(syscall.EACCES);
-	EFAULT		Error	= Errno(syscall.EFAULT);
-	EBUSY		Error	= Errno(syscall.EBUSY);
-	EEXIST		Error	= Errno(syscall.EEXIST);
-	EXDEV		Error	= Errno(syscall.EXDEV);
-	ENODEV		Error	= Errno(syscall.ENODEV);
-	ENOTDIR		Error	= Errno(syscall.ENOTDIR);
-	EISDIR		Error	= Errno(syscall.EISDIR);
-	EINVAL		Error	= Errno(syscall.EINVAL);
-	ENFILE		Error	= Errno(syscall.ENFILE);
-	EMFILE		Error	= Errno(syscall.EMFILE);
-	ENOTTY		Error	= Errno(syscall.ENOTTY);
-	EFBIG		Error	= Errno(syscall.EFBIG);
-	ENOSPC		Error	= Errno(syscall.ENOSPC);
-	ESPIPE		Error	= Errno(syscall.ESPIPE);
-	EROFS		Error	= Errno(syscall.EROFS);
-	EMLINK		Error	= Errno(syscall.EMLINK);
-	EPIPE		Error	= Errno(syscall.EPIPE);
-	EAGAIN		Error	= Errno(syscall.EAGAIN);
-	EDOM		Error	= Errno(syscall.EDOM);
-	ERANGE		Error	= Errno(syscall.ERANGE);
-	EADDRINUSE	Error	= Errno(syscall.EADDRINUSE);
-	ECONNREFUSED	Error	= Errno(syscall.ECONNREFUSED);
-	ENAMETOOLONG	Error	= Errno(syscall.ENAMETOOLONG);
-	EAFNOSUPPORT	Error	= Errno(syscall.EAFNOSUPPORT);
+	EPERM        Error = Errno(syscall.EPERM)
+	ENOENT       Error = Errno(syscall.ENOENT)
+	ESRCH        Error = Errno(syscall.ESRCH)
+	EINTR        Error = Errno(syscall.EINTR)
+	EIO          Error = Errno(syscall.EIO)
+	ENXIO        Error = Errno(syscall.ENXIO)
+	E2BIG        Error = Errno(syscall.E2BIG)
+	ENOEXEC      Error = Errno(syscall.ENOEXEC)
+	EBADF        Error = Errno(syscall.EBADF)
+	ECHILD       Error = Errno(syscall.ECHILD)
+	EDEADLK      Error = Errno(syscall.EDEADLK)
+	ENOMEM       Error = Errno(syscall.ENOMEM)
+	EACCES       Error = Errno(syscall.EACCES)
+	EFAULT       Error = Errno(syscall.EFAULT)
+	EBUSY        Error = Errno(syscall.EBUSY)
+	EEXIST       Error = Errno(syscall.EEXIST)
+	EXDEV        Error = Errno(syscall.EXDEV)
+	ENODEV       Error = Errno(syscall.ENODEV)
+	ENOTDIR      Error = Errno(syscall.ENOTDIR)
+	EISDIR       Error = Errno(syscall.EISDIR)
+	EINVAL       Error = Errno(syscall.EINVAL)
+	ENFILE       Error = Errno(syscall.ENFILE)
+	EMFILE       Error = Errno(syscall.EMFILE)
+	ENOTTY       Error = Errno(syscall.ENOTTY)
+	EFBIG        Error = Errno(syscall.EFBIG)
+	ENOSPC       Error = Errno(syscall.ENOSPC)
+	ESPIPE       Error = Errno(syscall.ESPIPE)
+	EROFS        Error = Errno(syscall.EROFS)
+	EMLINK       Error = Errno(syscall.EMLINK)
+	EPIPE        Error = Errno(syscall.EPIPE)
+	EAGAIN       Error = Errno(syscall.EAGAIN)
+	EDOM         Error = Errno(syscall.EDOM)
+	ERANGE       Error = Errno(syscall.ERANGE)
+	EADDRINUSE   Error = Errno(syscall.EADDRINUSE)
+	ECONNREFUSED Error = Errno(syscall.ECONNREFUSED)
+	ENAMETOOLONG Error = Errno(syscall.ENAMETOOLONG)
+	EAFNOSUPPORT Error = Errno(syscall.EAFNOSUPPORT)
 )
 
 // PathError records an error and the operation and file path that caused it.
 type PathError struct {
-	Op	string;
-	Path	string;
-	Error	Error;
+	Op    string
+	Path  string
+	Error Error
 }
 
-func (e *PathError) String() string	{ return e.Op + " " + e.Path + ": " + e.Error.String() }
+func (e *PathError) String() string { return e.Op + " " + e.Path + ": " + e.Error.String() }
 
 // SyscallError records an error from a specific system call.
 type SyscallError struct {
-	Syscall	string;
-	Errno	Errno;
+	Syscall string
+	Errno   Errno
 }
 
-func (e *SyscallError) String() string	{ return e.Syscall + ": " + e.Errno.String() }
+func (e *SyscallError) String() string { return e.Syscall + ": " + e.Errno.String() }
 
 // Note: If the name of the function NewSyscallError changes,
 // pkg/go/doc/doc.go should be adjusted since it hardwires
@@ -99,5 +99,5 @@ func NewSyscallError(syscall string, errno int) Error {
 	if errno == 0 {
 		return nil
 	}
-	return &SyscallError{syscall, Errno(errno)};
+	return &SyscallError{syscall, Errno(errno)}
 }
diff --git a/src/pkg/os/exec.go b/src/pkg/os/exec.go
index 6525f254e2..d55acbaa70 100644
--- a/src/pkg/os/exec.go
+++ b/src/pkg/os/exec.go
@@ -5,7 +5,7 @@
 package os
 
 import (
-	"syscall";
+	"syscall"
 )
 
 // ForkExec forks the current process and invokes Exec with the file, arguments,
@@ -17,7 +17,7 @@ import (
 // If dir is not empty, the child chdirs into the directory before execing the program.
 func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []*File) (pid int, err Error) {
 	// Create array of integer (system) fds.
-	intfd := make([]int, len(fd));
+	intfd := make([]int, len(fd))
 	for i, f := range fd {
 		if f == nil {
 			intfd[i] = -1
@@ -26,11 +26,11 @@ func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []*File
 		}
 	}
 
-	p, e := syscall.ForkExec(argv0, argv, envv, dir, intfd);
+	p, e := syscall.ForkExec(argv0, argv, envv, dir, intfd)
 	if e != 0 {
 		return 0, &PathError{"fork/exec", argv0, Errno(e)}
 	}
-	return p, nil;
+	return p, nil
 }
 
 // Exec replaces the current process with an execution of the program
@@ -41,11 +41,11 @@ func Exec(argv0 string, argv []string, envv []string) Error {
 	if envv == nil {
 		envv = Environ()
 	}
-	e := syscall.Exec(argv0, argv, envv);
+	e := syscall.Exec(argv0, argv, envv)
 	if e != 0 {
 		return &PathError{"exec", argv0, Errno(e)}
 	}
-	return nil;
+	return nil
 }
 
 // TODO(rsc): Should os implement its own syscall.WaitStatus
@@ -57,17 +57,17 @@ func Exec(argv0 string, argv []string, envv []string) Error {
 
 // Waitmsg stores the information about an exited process as reported by Wait.
 type Waitmsg struct {
-	Pid			int;			// The process's id.
-	syscall.WaitStatus;				// System-dependent status info.
-	Rusage			*syscall.Rusage;	// System-dependent resource usage info.
+	Pid                int             // The process's id.
+	syscall.WaitStatus                 // System-dependent status info.
+	Rusage             *syscall.Rusage // System-dependent resource usage info.
 }
 
 // Options for Wait.
 const (
-	WNOHANG		= syscall.WNOHANG;	// Don't wait if no process has exited.
-	WSTOPPED	= syscall.WSTOPPED;	// If set, status of stopped subprocesses is also reported.
-	WUNTRACED	= WSTOPPED;
-	WRUSAGE		= 1 << 20;	// Record resource usage.
+	WNOHANG   = syscall.WNOHANG  // Don't wait if no process has exited.
+	WSTOPPED  = syscall.WSTOPPED // If set, status of stopped subprocesses is also reported.
+	WUNTRACED = WSTOPPED
+	WRUSAGE   = 1 << 20 // Record resource usage.
 )
 
 // WRUSAGE must not be too high a bit, to avoid clashing with Linux's
@@ -78,21 +78,21 @@ const (
 // Waitmsg describing its status and an Error, if any. The options
 // (WNOHANG etc.) affect the behavior of the Wait call.
 func Wait(pid int, options int) (w *Waitmsg, err Error) {
-	var status syscall.WaitStatus;
-	var rusage *syscall.Rusage;
+	var status syscall.WaitStatus
+	var rusage *syscall.Rusage
 	if options&WRUSAGE != 0 {
-		rusage = new(syscall.Rusage);
-		options ^= WRUSAGE;
+		rusage = new(syscall.Rusage)
+		options ^= WRUSAGE
 	}
-	pid1, e := syscall.Wait4(pid, &status, options, rusage);
+	pid1, e := syscall.Wait4(pid, &status, options, rusage)
 	if e != 0 {
 		return nil, NewSyscallError("wait", e)
 	}
-	w = new(Waitmsg);
-	w.Pid = pid1;
-	w.WaitStatus = status;
-	w.Rusage = rusage;
-	return w, nil;
+	w = new(Waitmsg)
+	w.Pid = pid1
+	w.WaitStatus = status
+	w.Rusage = rusage
+	return w, nil
 }
 
 // Convert i to decimal string.
@@ -101,37 +101,37 @@ func itod(i int) string {
 		return "0"
 	}
 
-	u := uint64(i);
+	u := uint64(i)
 	if i < 0 {
 		u = -u
 	}
 
 	// Assemble decimal in reverse order.
-	var b [32]byte;
-	bp := len(b);
+	var b [32]byte
+	bp := len(b)
 	for ; u > 0; u /= 10 {
-		bp--;
-		b[bp] = byte(u%10) + '0';
+		bp--
+		b[bp] = byte(u%10) + '0'
 	}
 
 	if i < 0 {
-		bp--;
-		b[bp] = '-';
+		bp--
+		b[bp] = '-'
 	}
 
-	return string(b[bp:]);
+	return string(b[bp:])
 }
 
 func (w Waitmsg) String() string {
 	// TODO(austin) Use signal names when possible?
-	res := "";
+	res := ""
 	switch {
 	case w.Exited():
 		res = "exit status " + itod(w.ExitStatus())
 	case w.Signaled():
 		res = "signal " + itod(w.Signal())
 	case w.Stopped():
-		res = "stop signal " + itod(w.StopSignal());
+		res = "stop signal " + itod(w.StopSignal())
 		if w.StopSignal() == syscall.SIGTRAP && w.TrapCause() != 0 {
 			res += " (trap " + itod(w.TrapCause()) + ")"
 		}
@@ -141,11 +141,11 @@ func (w Waitmsg) String() string {
 	if w.CoreDump() {
 		res += " (core dumped)"
 	}
-	return res;
+	return res
 }
 
 // Getpid returns the process id of the caller.
-func Getpid() int	{ return syscall.Getpid() }
+func Getpid() int { return syscall.Getpid() }
 
 // Getppid returns the process id of the caller's parent.
-func Getppid() int	{ return syscall.Getppid() }
+func Getppid() int { return syscall.Getppid() }
diff --git a/src/pkg/os/file.go b/src/pkg/os/file.go
index 459b78cc22..87a2925e97 100644
--- a/src/pkg/os/file.go
+++ b/src/pkg/os/file.go
@@ -7,80 +7,80 @@
 package os
 
 import (
-	"syscall";
+	"syscall"
 )
 
 // Auxiliary information if the File describes a directory
 type dirInfo struct {
-	buf	[]byte;	// buffer for directory I/O
-	nbuf	int;	// length of buf; return value from Getdirentries
-	bufp	int;	// location of next record in buf.
+	buf  []byte // buffer for directory I/O
+	nbuf int    // length of buf; return value from Getdirentries
+	bufp int    // location of next record in buf.
 }
 
 // File represents an open file descriptor.
 type File struct {
-	fd	int;
-	name	string;
-	dirinfo	*dirInfo;	// nil unless directory being read
-	nepipe	int;		// number of consecutive EPIPE in Write
+	fd      int
+	name    string
+	dirinfo *dirInfo // nil unless directory being read
+	nepipe  int      // number of consecutive EPIPE in Write
 }
 
 // Fd returns the integer Unix file descriptor referencing the open file.
-func (file *File) Fd() int	{ return file.fd }
+func (file *File) Fd() int { return file.fd }
 
 // Name returns the name of the file as presented to Open.
-func (file *File) Name() string	{ return file.name }
+func (file *File) Name() string { return file.name }
 
 // NewFile returns a new File with the given file descriptor and name.
 func NewFile(fd int, name string) *File {
 	if fd < 0 {
 		return nil
 	}
-	return &File{fd, name, nil, 0};
+	return &File{fd, name, nil, 0}
 }
 
 // Stdin, Stdout, and Stderr are open Files pointing to the standard input,
 // standard output, and standard error file descriptors.
 var (
-	Stdin	= NewFile(0, "/dev/stdin");
-	Stdout	= NewFile(1, "/dev/stdout");
-	Stderr	= NewFile(2, "/dev/stderr");
+	Stdin  = NewFile(0, "/dev/stdin")
+	Stdout = NewFile(1, "/dev/stdout")
+	Stderr = NewFile(2, "/dev/stderr")
 )
 
 // Flags to Open wrapping those of the underlying system. Not all flags
 // may be implemented on a given system.
 const (
-	O_RDONLY	= syscall.O_RDONLY;	// open the file read-only.
-	O_WRONLY	= syscall.O_WRONLY;	// open the file write-only.
-	O_RDWR		= syscall.O_RDWR;	// open the file read-write.
-	O_APPEND	= syscall.O_APPEND;	// open the file append-only.
-	O_ASYNC		= syscall.O_ASYNC;	// generate a signal when I/O is available.
-	O_CREAT		= syscall.O_CREAT;	// create a new file if none exists.
-	O_EXCL		= syscall.O_EXCL;	// used with O_CREAT, file must not exist
-	O_NOCTTY	= syscall.O_NOCTTY;	// do not make file the controlling tty.
-	O_NONBLOCK	= syscall.O_NONBLOCK;	// open in non-blocking mode.
-	O_NDELAY	= O_NONBLOCK;		// synonym for O_NONBLOCK
-	O_SYNC		= syscall.O_SYNC;	// open for synchronous I/O.
-	O_TRUNC		= syscall.O_TRUNC;	// if possible, truncate file when opened.
-	O_CREATE	= O_CREAT;		// create a new file if none exists.
+	O_RDONLY   = syscall.O_RDONLY   // open the file read-only.
+	O_WRONLY   = syscall.O_WRONLY   // open the file write-only.
+	O_RDWR     = syscall.O_RDWR     // open the file read-write.
+	O_APPEND   = syscall.O_APPEND   // open the file append-only.
+	O_ASYNC    = syscall.O_ASYNC    // generate a signal when I/O is available.
+	O_CREAT    = syscall.O_CREAT    // create a new file if none exists.
+	O_EXCL     = syscall.O_EXCL     // used with O_CREAT, file must not exist
+	O_NOCTTY   = syscall.O_NOCTTY   // do not make file the controlling tty.
+	O_NONBLOCK = syscall.O_NONBLOCK // open in non-blocking mode.
+	O_NDELAY   = O_NONBLOCK         // synonym for O_NONBLOCK
+	O_SYNC     = syscall.O_SYNC     // open for synchronous I/O.
+	O_TRUNC    = syscall.O_TRUNC    // if possible, truncate file when opened.
+	O_CREATE   = O_CREAT            // create a new file if none exists.
 )
 
 // Open opens the named file with specified flag (O_RDONLY etc.) and perm, (0666 etc.)
 // if applicable.  If successful, methods on the returned File can be used for I/O.
 // It returns the File and an Error, if any.
 func Open(name string, flag int, perm int) (file *File, err Error) {
-	r, e := syscall.Open(name, flag|syscall.O_CLOEXEC, perm);
+	r, e := syscall.Open(name, flag|syscall.O_CLOEXEC, perm)
 	if e != 0 {
 		return nil, &PathError{"open", name, Errno(e)}
 	}
 
 	// There's a race here with fork/exec, which we are
 	// content to live with.  See ../syscall/exec.go
-	if syscall.O_CLOEXEC == 0 {	// O_CLOEXEC not supported
+	if syscall.O_CLOEXEC == 0 { // O_CLOEXEC not supported
 		syscall.CloseOnExec(r)
 	}
 
-	return NewFile(r, name), nil;
+	return NewFile(r, name), nil
 }
 
 // Close closes the File, rendering it unusable for I/O.
@@ -89,17 +89,17 @@ func (file *File) Close() Error {
 	if file == nil {
 		return EINVAL
 	}
-	var err Error;
+	var err Error
 	if e := syscall.Close(file.fd); e != 0 {
 		err = &PathError{"close", file.name, Errno(e)}
 	}
-	file.fd = -1;	// so it can't be closed again
-	return err;
+	file.fd = -1 // so it can't be closed again
+	return err
 }
 
 type eofError int
 
-func (eofError) String() string	{ return "EOF" }
+func (eofError) String() string { return "EOF" }
 
 // EOF is the Error returned by Read when no more input is available.
 // Functions should return EOF only to signal a graceful end of input.
@@ -115,7 +115,7 @@ func (file *File) Read(b []byte) (n int, err Error) {
 	if file == nil {
 		return 0, EINVAL
 	}
-	n, e := syscall.Read(file.fd, b);
+	n, e := syscall.Read(file.fd, b)
 	if n < 0 {
 		n = 0
 	}
@@ -125,7 +125,7 @@ func (file *File) Read(b []byte) (n int, err Error) {
 	if e != 0 {
 		err = &PathError{"read", file.name, Errno(e)}
 	}
-	return n, err;
+	return n, err
 }
 
 // ReadAt reads len(b) bytes from the File starting at byte offset off.
@@ -137,19 +137,19 @@ func (file *File) ReadAt(b []byte, off int64) (n int, err Error) {
 		return 0, EINVAL
 	}
 	for len(b) > 0 {
-		m, e := syscall.Pread(file.fd, b, off);
+		m, e := syscall.Pread(file.fd, b, off)
 		if m == 0 && e == 0 {
 			return n, EOF
 		}
 		if e != 0 {
-			err = &PathError{"read", file.name, Errno(e)};
-			break;
+			err = &PathError{"read", file.name, Errno(e)}
+			break
 		}
-		n += m;
-		b = b[m:];
-		off += int64(m);
+		n += m
+		b = b[m:]
+		off += int64(m)
 	}
-	return;
+	return
 }
 
 // Write writes len(b) bytes to the File.
@@ -159,12 +159,12 @@ func (file *File) Write(b []byte) (n int, err Error) {
 	if file == nil {
 		return 0, EINVAL
 	}
-	n, e := syscall.Write(file.fd, b);
+	n, e := syscall.Write(file.fd, b)
 	if n < 0 {
 		n = 0
 	}
 	if e == syscall.EPIPE {
-		file.nepipe++;
+		file.nepipe++
 		if file.nepipe >= 10 {
 			Exit(syscall.EPIPE)
 		}
@@ -174,7 +174,7 @@ func (file *File) Write(b []byte) (n int, err Error) {
 	if e != 0 {
 		err = &PathError{"write", file.name, Errno(e)}
 	}
-	return n, err;
+	return n, err
 }
 
 // WriteAt writes len(b) bytes to the File starting at byte offset off.
@@ -185,16 +185,16 @@ func (file *File) WriteAt(b []byte, off int64) (n int, err Error) {
 		return 0, EINVAL
 	}
 	for len(b) > 0 {
-		m, e := syscall.Pwrite(file.fd, b, off);
+		m, e := syscall.Pwrite(file.fd, b, off)
 		if e != 0 {
-			err = &PathError{"write", file.name, Errno(e)};
-			break;
+			err = &PathError{"write", file.name, Errno(e)}
+			break
 		}
-		n += m;
-		b = b[m:];
-		off += int64(m);
+		n += m
+		b = b[m:]
+		off += int64(m)
 	}
-	return;
+	return
 }
 
 // Seek sets the offset for the next Read or Write on file to offset, interpreted
@@ -202,14 +202,14 @@ func (file *File) WriteAt(b []byte, off int64) (n int, err Error) {
 // relative to the current offset, and 2 means relative to the end.
 // It returns the new offset and an Error, if any.
 func (file *File) Seek(offset int64, whence int) (ret int64, err Error) {
-	r, e := syscall.Seek(file.fd, offset, whence);
+	r, e := syscall.Seek(file.fd, offset, whence)
 	if e == 0 && file.dirinfo != nil && r != 0 {
 		e = syscall.EISDIR
 	}
 	if e != 0 {
 		return 0, &PathError{"seek", file.name, Errno(e)}
 	}
-	return r, nil;
+	return r, nil
 }
 
 // WriteString is like Write, but writes the contents of string s rather than
@@ -218,38 +218,38 @@ func (file *File) WriteString(s string) (ret int, err Error) {
 	if file == nil {
 		return 0, EINVAL
 	}
-	b := syscall.StringByteSlice(s);
-	b = b[0 : len(b)-1];
-	return file.Write(b);
+	b := syscall.StringByteSlice(s)
+	b = b[0 : len(b)-1]
+	return file.Write(b)
 }
 
 // Pipe returns a connected pair of Files; reads from r return bytes written to w.
 // It returns the files and an Error, if any.
 func Pipe() (r *File, w *File, err Error) {
-	var p [2]int;
+	var p [2]int
 
 	// See ../syscall/exec.go for description of lock.
-	syscall.ForkLock.RLock();
-	e := syscall.Pipe(&p);
+	syscall.ForkLock.RLock()
+	e := syscall.Pipe(&p)
 	if e != 0 {
-		syscall.ForkLock.RUnlock();
-		return nil, nil, NewSyscallError("pipe", e);
+		syscall.ForkLock.RUnlock()
+		return nil, nil, NewSyscallError("pipe", e)
 	}
-	syscall.CloseOnExec(p[0]);
-	syscall.CloseOnExec(p[1]);
-	syscall.ForkLock.RUnlock();
+	syscall.CloseOnExec(p[0])
+	syscall.CloseOnExec(p[1])
+	syscall.ForkLock.RUnlock()
 
-	return NewFile(p[0], "|0"), NewFile(p[1], "|1"), nil;
+	return NewFile(p[0], "|0"), NewFile(p[1], "|1"), nil
 }
 
 // Mkdir creates a new directory with the specified name and permission bits.
 // It returns an error, if any.
 func Mkdir(name string, perm int) Error {
-	e := syscall.Mkdir(name, perm);
+	e := syscall.Mkdir(name, perm)
 	if e != 0 {
 		return &PathError{"mkdir", name, Errno(e)}
 	}
-	return nil;
+	return nil
 }
 
 // Stat returns a Dir structure describing the named file and an error, if any.
@@ -258,42 +258,42 @@ func Mkdir(name string, perm int) Error {
 // If name names an invalid symbolic link, the returned Dir describes
 // the link itself and has dir.FollowedSymlink set to false.
 func Stat(name string) (dir *Dir, err Error) {
-	var lstat, stat syscall.Stat_t;
-	e := syscall.Lstat(name, &lstat);
+	var lstat, stat syscall.Stat_t
+	e := syscall.Lstat(name, &lstat)
 	if e != 0 {
 		return nil, &PathError{"stat", name, Errno(e)}
 	}
-	statp := &lstat;
+	statp := &lstat
 	if lstat.Mode&syscall.S_IFMT == syscall.S_IFLNK {
-		e := syscall.Stat(name, &stat);
+		e := syscall.Stat(name, &stat)
 		if e == 0 {
 			statp = &stat
 		}
 	}
-	return dirFromStat(name, new(Dir), &lstat, statp), nil;
+	return dirFromStat(name, new(Dir), &lstat, statp), nil
 }
 
 // Stat returns the Dir structure describing file.
 // It returns the Dir and an error, if any.
 func (file *File) Stat() (dir *Dir, err Error) {
-	var stat syscall.Stat_t;
-	e := syscall.Fstat(file.fd, &stat);
+	var stat syscall.Stat_t
+	e := syscall.Fstat(file.fd, &stat)
 	if e != 0 {
 		return nil, &PathError{"stat", file.name, Errno(e)}
 	}
-	return dirFromStat(file.name, new(Dir), &stat, &stat), nil;
+	return dirFromStat(file.name, new(Dir), &stat, &stat), nil
 }
 
 // Lstat returns the Dir structure describing the named file and an error, if any.
 // If the file is a symbolic link, the returned Dir describes the
 // symbolic link.  Lstat makes no attempt to follow the link.
 func Lstat(name string) (dir *Dir, err Error) {
-	var stat syscall.Stat_t;
-	e := syscall.Lstat(name, &stat);
+	var stat syscall.Stat_t
+	e := syscall.Lstat(name, &stat)
 	if e != 0 {
 		return nil, &PathError{"lstat", name, Errno(e)}
 	}
-	return dirFromStat(name, new(Dir), &stat, &stat), nil;
+	return dirFromStat(name, new(Dir), &stat, &stat), nil
 }
 
 // Readdir reads the contents of the directory associated with file and
@@ -302,25 +302,25 @@ func Lstat(name string) (dir *Dir, err Error) {
 // A negative count means to read until EOF.
 // Readdir returns the array and an Error, if any.
 func (file *File) Readdir(count int) (dirs []Dir, err Error) {
-	dirname := file.name;
+	dirname := file.name
 	if dirname == "" {
 		dirname = "."
 	}
-	dirname += "/";
-	names, err1 := file.Readdirnames(count);
+	dirname += "/"
+	names, err1 := file.Readdirnames(count)
 	if err1 != nil {
 		return nil, err1
 	}
-	dirs = make([]Dir, len(names));
+	dirs = make([]Dir, len(names))
 	for i, filename := range names {
-		dirp, err := Lstat(dirname + filename);
+		dirp, err := Lstat(dirname + filename)
 		if dirp == nil || err != nil {
-			dirs[i].Name = filename	// rest is already zeroed out
+			dirs[i].Name = filename // rest is already zeroed out
 		} else {
 			dirs[i] = *dirp
 		}
 	}
-	return;
+	return
 }
 
 // Chdir changes the current working directory to the named directory.
@@ -328,7 +328,7 @@ func Chdir(dir string) Error {
 	if e := syscall.Chdir(dir); e != 0 {
 		return &PathError{"chdir", dir, Errno(e)}
 	}
-	return nil;
+	return nil
 }
 
 // Chdir changes the current working directory to the file,
@@ -337,7 +337,7 @@ func (f *File) Chdir() Error {
 	if e := syscall.Fchdir(f.fd); e != 0 {
 		return &PathError{"chdir", f.name, Errno(e)}
 	}
-	return nil;
+	return nil
 }
 
 // Remove removes the named file or directory.
@@ -346,11 +346,11 @@ func Remove(name string) Error {
 	// whether name is a file or directory.
 	// Try both: it is cheaper on average than
 	// doing a Stat plus the right one.
-	e := syscall.Unlink(name);
+	e := syscall.Unlink(name)
 	if e == 0 {
 		return nil
 	}
-	e1 := syscall.Rmdir(name);
+	e1 := syscall.Rmdir(name)
 	if e1 == 0 {
 		return nil
 	}
@@ -367,16 +367,16 @@ func Remove(name string) Error {
 	if e1 != syscall.ENOTDIR {
 		e = e1
 	}
-	return &PathError{"remove", name, Errno(e)};
+	return &PathError{"remove", name, Errno(e)}
 }
 
 // LinkError records an error during a link or symlink or rename
 // system call and the paths that caused it.
 type LinkError struct {
-	Op	string;
-	Old	string;
-	New	string;
-	Error	Error;
+	Op    string
+	Old   string
+	New   string
+	Error Error
 }
 
 func (e *LinkError) String() string {
@@ -385,28 +385,28 @@ func (e *LinkError) String() string {
 
 // Link creates a hard link.
 func Link(oldname, newname string) Error {
-	e := syscall.Link(oldname, newname);
+	e := syscall.Link(oldname, newname)
 	if e != 0 {
 		return &LinkError{"link", oldname, newname, Errno(e)}
 	}
-	return nil;
+	return nil
 }
 
 // Symlink creates a symbolic link.
 func Symlink(oldname, newname string) Error {
-	e := syscall.Symlink(oldname, newname);
+	e := syscall.Symlink(oldname, newname)
 	if e != 0 {
 		return &LinkError{"symlink", oldname, newname, Errno(e)}
 	}
-	return nil;
+	return nil
 }
 
 // Readlink reads the contents of a symbolic link: the destination of
 // the link.  It returns the contents and an Error, if any.
 func Readlink(name string) (string, Error) {
 	for len := 128; ; len *= 2 {
-		b := make([]byte, len);
-		n, e := syscall.Readlink(name, b);
+		b := make([]byte, len)
+		n, e := syscall.Readlink(name, b)
 		if e != 0 {
 			return "", &PathError{"readlink", name, Errno(e)}
 		}
@@ -415,16 +415,16 @@ func Readlink(name string) (string, Error) {
 		}
 	}
 	// Silence 6g.
-	return "", nil;
+	return "", nil
 }
 
 // Rename renames a file.
 func Rename(oldname, newname string) Error {
-	e := syscall.Rename(oldname, newname);
+	e := syscall.Rename(oldname, newname)
 	if e != 0 {
 		return &LinkError{"rename", oldname, newname, Errno(e)}
 	}
-	return nil;
+	return nil
 }
 
 // Chmod changes the mode of the named file to mode.
@@ -433,7 +433,7 @@ func Chmod(name string, mode int) Error {
 	if e := syscall.Chmod(name, mode); e != 0 {
 		return &PathError{"chmod", name, Errno(e)}
 	}
-	return nil;
+	return nil
 }
 
 // Chmod changes the mode of the file to mode.
@@ -441,7 +441,7 @@ func (f *File) Chmod(mode int) Error {
 	if e := syscall.Fchmod(f.fd, mode); e != 0 {
 		return &PathError{"chmod", f.name, Errno(e)}
 	}
-	return nil;
+	return nil
 }
 
 // Chown changes the numeric uid and gid of the named file.
@@ -450,7 +450,7 @@ func Chown(name string, uid, gid int) Error {
 	if e := syscall.Chown(name, uid, gid); e != 0 {
 		return &PathError{"chown", name, Errno(e)}
 	}
-	return nil;
+	return nil
 }
 
 // Lchown changes the numeric uid and gid of the named file.
@@ -459,7 +459,7 @@ func Lchown(name string, uid, gid int) Error {
 	if e := syscall.Lchown(name, uid, gid); e != 0 {
 		return &PathError{"lchown", name, Errno(e)}
 	}
-	return nil;
+	return nil
 }
 
 // Chown changes the numeric uid and gid of the named file.
@@ -467,7 +467,7 @@ func (f *File) Chown(uid, gid int) Error {
 	if e := syscall.Fchown(f.fd, uid, gid); e != 0 {
 		return &PathError{"chown", f.name, Errno(e)}
 	}
-	return nil;
+	return nil
 }
 
 // Truncate changes the size of the named file.
@@ -476,7 +476,7 @@ func Truncate(name string, size int64) Error {
 	if e := syscall.Truncate(name, size); e != 0 {
 		return &PathError{"truncate", name, Errno(e)}
 	}
-	return nil;
+	return nil
 }
 
 // Truncate changes the size of the file.
@@ -485,5 +485,5 @@ func (f *File) Truncate(size int64) Error {
 	if e := syscall.Ftruncate(f.fd, size); e != 0 {
 		return &PathError{"truncate", f.name, Errno(e)}
 	}
-	return nil;
+	return nil
 }
diff --git a/src/pkg/os/getwd.go b/src/pkg/os/getwd.go
index 57f69d12eb..49aaea865f 100644
--- a/src/pkg/os/getwd.go
+++ b/src/pkg/os/getwd.go
@@ -5,7 +5,7 @@
 package os
 
 import (
-	"syscall";
+	"syscall"
 )
 
 // Getwd returns a rooted path name corresponding to the
@@ -15,21 +15,21 @@ import (
 func Getwd() (string, Error) {
 	// If the operating system provides a Getwd call, use it.
 	if syscall.ImplementsGetwd {
-		s, e := syscall.Getwd();
-		return s, NewSyscallError("getwd", e);
+		s, e := syscall.Getwd()
+		return s, NewSyscallError("getwd", e)
 	}
 
 	// Otherwise, we're trying to find our way back to ".".
-	dot, err := Stat(".");
+	dot, err := Stat(".")
 	if err != nil {
 		return "", err
 	}
 
 	// Clumsy but widespread kludge:
 	// if $PWD is set and matches ".", use it.
-	pwd := Getenv("PWD");
+	pwd := Getenv("PWD")
 	if len(pwd) > 0 && pwd[0] == '/' {
-		d, err := Stat(pwd);
+		d, err := Stat(pwd)
 		if err == nil && d.Dev == dot.Dev && d.Ino == dot.Ino {
 			return pwd, nil
 		}
@@ -37,7 +37,7 @@ func Getwd() (string, Error) {
 
 	// Root is a special case because it has no parent
 	// and ends in a slash.
-	root, err := Stat("/");
+	root, err := Stat("/")
 	if err != nil {
 		// Can't stat root - no hope.
 		return "", err
@@ -49,44 +49,44 @@ func Getwd() (string, Error) {
 	// General algorithm: find name in parent
 	// and then find name of parent.  Each iteration
 	// adds /name to the beginning of pwd.
-	pwd = "";
+	pwd = ""
 	for parent := ".."; ; parent = "../" + parent {
-		if len(parent) >= 1024 {	// Sanity check
+		if len(parent) >= 1024 { // Sanity check
 			return "", ENAMETOOLONG
 		}
-		fd, err := Open(parent, O_RDONLY, 0);
+		fd, err := Open(parent, O_RDONLY, 0)
 		if err != nil {
 			return "", err
 		}
 
 		for {
-			names, err := fd.Readdirnames(100);
+			names, err := fd.Readdirnames(100)
 			if err != nil {
-				fd.Close();
-				return "", err;
+				fd.Close()
+				return "", err
 			}
 			for _, name := range names {
-				d, _ := Lstat(parent + "/" + name);
+				d, _ := Lstat(parent + "/" + name)
 				if d.Dev == dot.Dev && d.Ino == dot.Ino {
-					pwd = "/" + name + pwd;
-					goto Found;
+					pwd = "/" + name + pwd
+					goto Found
 				}
 			}
 		}
-		fd.Close();
-		return "", ENOENT;
+		fd.Close()
+		return "", ENOENT
 
 	Found:
-		pd, err := fd.Stat();
+		pd, err := fd.Stat()
 		if err != nil {
 			return "", err
 		}
-		fd.Close();
+		fd.Close()
 		if pd.Dev == root.Dev && pd.Ino == root.Ino {
 			break
 		}
 		// Set up for next round.
-		dot = pd;
+		dot = pd
 	}
-	return pwd, nil;
+	return pwd, nil
 }
diff --git a/src/pkg/os/os_test.go b/src/pkg/os/os_test.go
index 7ff2bddb3c..4523cad79d 100644
--- a/src/pkg/os/os_test.go
+++ b/src/pkg/os/os_test.go
@@ -5,13 +5,13 @@
 package os_test
 
 import (
-	"bytes";
-	"fmt";
-	"io";
-	"io/ioutil";
-	. "os";
-	"strings";
-	"testing";
+	"bytes"
+	"fmt"
+	"io"
+	"io/ioutil"
+	. "os"
+	"strings"
+	"testing"
 )
 
 var dot = []string{
@@ -34,16 +34,16 @@ var etc = []string{
 }
 
 func size(name string, t *testing.T) uint64 {
-	file, err := Open(name, O_RDONLY, 0);
-	defer file.Close();
+	file, err := Open(name, O_RDONLY, 0)
+	defer file.Close()
 	if err != nil {
 		t.Fatal("open failed:", err)
 	}
-	var buf [100]byte;
-	len := 0;
+	var buf [100]byte
+	len := 0
 	for {
-		n, e := file.Read(&buf);
-		len += n;
+		n, e := file.Read(&buf)
+		len += n
 		if e == EOF {
 			break
 		}
@@ -51,68 +51,68 @@ func size(name string, t *testing.T) uint64 {
 			t.Fatal("read failed:", err)
 		}
 	}
-	return uint64(len);
+	return uint64(len)
 }
 
 func TestStat(t *testing.T) {
-	dir, err := Stat("/etc/passwd");
+	dir, err := Stat("/etc/passwd")
 	if err != nil {
 		t.Fatal("stat failed:", err)
 	}
 	if dir.Name != "passwd" {
 		t.Error("name should be passwd; is", dir.Name)
 	}
-	filesize := size("/etc/passwd", t);
+	filesize := size("/etc/passwd", t)
 	if dir.Size != filesize {
 		t.Error("size should be", filesize, "; is", dir.Size)
 	}
 }
 
 func TestFstat(t *testing.T) {
-	file, err1 := Open("/etc/passwd", O_RDONLY, 0);
-	defer file.Close();
+	file, err1 := Open("/etc/passwd", O_RDONLY, 0)
+	defer file.Close()
 	if err1 != nil {
 		t.Fatal("open failed:", err1)
 	}
-	dir, err2 := file.Stat();
+	dir, err2 := file.Stat()
 	if err2 != nil {
 		t.Fatal("fstat failed:", err2)
 	}
 	if dir.Name != "passwd" {
 		t.Error("name should be passwd; is", dir.Name)
 	}
-	filesize := size("/etc/passwd", t);
+	filesize := size("/etc/passwd", t)
 	if dir.Size != filesize {
 		t.Error("size should be", filesize, "; is", dir.Size)
 	}
 }
 
 func TestLstat(t *testing.T) {
-	dir, err := Lstat("/etc/passwd");
+	dir, err := Lstat("/etc/passwd")
 	if err != nil {
 		t.Fatal("lstat failed:", err)
 	}
 	if dir.Name != "passwd" {
 		t.Error("name should be passwd; is", dir.Name)
 	}
-	filesize := size("/etc/passwd", t);
+	filesize := size("/etc/passwd", t)
 	if dir.Size != filesize {
 		t.Error("size should be", filesize, "; is", dir.Size)
 	}
 }
 
 func testReaddirnames(dir string, contents []string, t *testing.T) {
-	file, err := Open(dir, O_RDONLY, 0);
-	defer file.Close();
+	file, err := Open(dir, O_RDONLY, 0)
+	defer file.Close()
 	if err != nil {
 		t.Fatalf("open %q failed: %v", dir, err)
 	}
-	s, err2 := file.Readdirnames(-1);
+	s, err2 := file.Readdirnames(-1)
 	if err2 != nil {
 		t.Fatalf("readdirnames %q failed: %v", err2)
 	}
 	for _, m := range contents {
-		found := false;
+		found := false
 		for _, n := range s {
 			if n == "." || n == ".." {
 				t.Errorf("got %s in directory", n)
@@ -121,7 +121,7 @@ func testReaddirnames(dir string, contents []string, t *testing.T) {
 				if found {
 					t.Error("present twice:", m)
 				}
-				found = true;
+				found = true
 			}
 		}
 		if !found {
@@ -131,23 +131,23 @@ func testReaddirnames(dir string, contents []string, t *testing.T) {
 }
 
 func testReaddir(dir string, contents []string, t *testing.T) {
-	file, err := Open(dir, O_RDONLY, 0);
-	defer file.Close();
+	file, err := Open(dir, O_RDONLY, 0)
+	defer file.Close()
 	if err != nil {
 		t.Fatalf("open %q failed: %v", dir, err)
 	}
-	s, err2 := file.Readdir(-1);
+	s, err2 := file.Readdir(-1)
 	if err2 != nil {
 		t.Fatalf("readdir %q failed: %v", dir, err2)
 	}
 	for _, m := range contents {
-		found := false;
+		found := false
 		for _, n := range s {
 			if m == n.Name {
 				if found {
 					t.Error("present twice:", m)
 				}
-				found = true;
+				found = true
 			}
 		}
 		if !found {
@@ -157,51 +157,51 @@ func testReaddir(dir string, contents []string, t *testing.T) {
 }
 
 func TestReaddirnames(t *testing.T) {
-	testReaddirnames(".", dot, t);
-	testReaddirnames("/etc", etc, t);
+	testReaddirnames(".", dot, t)
+	testReaddirnames("/etc", etc, t)
 }
 
 func TestReaddir(t *testing.T) {
-	testReaddir(".", dot, t);
-	testReaddir("/etc", etc, t);
+	testReaddir(".", dot, t)
+	testReaddir("/etc", etc, t)
 }
 
 // Read the directory one entry at a time.
 func smallReaddirnames(file *File, length int, t *testing.T) []string {
-	names := make([]string, length);
-	count := 0;
+	names := make([]string, length)
+	count := 0
 	for {
-		d, err := file.Readdirnames(1);
+		d, err := file.Readdirnames(1)
 		if err != nil {
 			t.Fatalf("readdir %q failed: %v", file.Name(), err)
 		}
 		if len(d) == 0 {
 			break
 		}
-		names[count] = d[0];
-		count++;
+		names[count] = d[0]
+		count++
 	}
-	return names[0:count];
+	return names[0:count]
 }
 
 // Check that reading a directory one entry at a time gives the same result
 // as reading it all at once.
 func TestReaddirnamesOneAtATime(t *testing.T) {
-	dir := "/usr/bin";	// big directory that doesn't change often.
-	file, err := Open(dir, O_RDONLY, 0);
-	defer file.Close();
+	dir := "/usr/bin" // big directory that doesn't change often.
+	file, err := Open(dir, O_RDONLY, 0)
+	defer file.Close()
 	if err != nil {
 		t.Fatalf("open %q failed: %v", dir, err)
 	}
-	all, err1 := file.Readdirnames(-1);
+	all, err1 := file.Readdirnames(-1)
 	if err1 != nil {
 		t.Fatalf("readdirnames %q failed: %v", dir, err1)
 	}
-	file1, err2 := Open(dir, O_RDONLY, 0);
+	file1, err2 := Open(dir, O_RDONLY, 0)
 	if err2 != nil {
 		t.Fatalf("open %q failed: %v", dir, err2)
 	}
-	small := smallReaddirnames(file1, len(all)+100, t);	// +100 in case we screw up
+	small := smallReaddirnames(file1, len(all)+100, t) // +100 in case we screw up
 	for i, n := range all {
 		if small[i] != n {
 			t.Errorf("small read %q %q mismatch: %v", small[i], n)
@@ -210,26 +210,26 @@ func TestReaddirnamesOneAtATime(t *testing.T) {
 }
 
 func TestHardLink(t *testing.T) {
-	from, to := "hardlinktestfrom", "hardlinktestto";
-	Remove(from);	// Just in case.
-	file, err := Open(to, O_CREAT|O_WRONLY, 0666);
+	from, to := "hardlinktestfrom", "hardlinktestto"
+	Remove(from) // Just in case.
+	file, err := Open(to, O_CREAT|O_WRONLY, 0666)
 	if err != nil {
 		t.Fatalf("open %q failed: %v", to, err)
 	}
-	defer Remove(to);
+	defer Remove(to)
 	if err = file.Close(); err != nil {
 		t.Errorf("close %q failed: %v", to, err)
 	}
-	err = Link(to, from);
+	err = Link(to, from)
 	if err != nil {
 		t.Fatalf("link %q, %q failed: %v", to, from, err)
 	}
-	defer Remove(from);
-	tostat, err := Stat(to);
+	defer Remove(from)
+	tostat, err := Stat(to)
 	if err != nil {
 		t.Fatalf("stat %q failed: %v", to, err)
 	}
-	fromstat, err := Stat(from);
+	fromstat, err := Stat(from)
 	if err != nil {
 		t.Fatalf("stat %q failed: %v", from, err)
 	}
@@ -239,74 +239,74 @@ func TestHardLink(t *testing.T) {
 }
 
 func TestSymLink(t *testing.T) {
-	from, to := "symlinktestfrom", "symlinktestto";
-	Remove(from);	// Just in case.
-	file, err := Open(to, O_CREAT|O_WRONLY, 0666);
+	from, to := "symlinktestfrom", "symlinktestto"
+	Remove(from) // Just in case.
+	file, err := Open(to, O_CREAT|O_WRONLY, 0666)
 	if err != nil {
 		t.Fatalf("open %q failed: %v", to, err)
 	}
-	defer Remove(to);
+	defer Remove(to)
 	if err = file.Close(); err != nil {
 		t.Errorf("close %q failed: %v", to, err)
 	}
-	err = Symlink(to, from);
+	err = Symlink(to, from)
 	if err != nil {
 		t.Fatalf("symlink %q, %q failed: %v", to, from, err)
 	}
-	defer Remove(from);
-	tostat, err := Stat(to);
+	defer Remove(from)
+	tostat, err := Stat(to)
 	if err != nil {
 		t.Fatalf("stat %q failed: %v", to, err)
 	}
 	if tostat.FollowedSymlink {
 		t.Fatalf("stat %q claims to have followed a symlink", to)
 	}
-	fromstat, err := Stat(from);
+	fromstat, err := Stat(from)
 	if err != nil {
 		t.Fatalf("stat %q failed: %v", from, err)
 	}
 	if tostat.Dev != fromstat.Dev || tostat.Ino != fromstat.Ino {
 		t.Errorf("symlink %q, %q did not create symlink", to, from)
 	}
-	fromstat, err = Lstat(from);
+	fromstat, err = Lstat(from)
 	if err != nil {
 		t.Fatalf("lstat %q failed: %v", from, err)
 	}
 	if !fromstat.IsSymlink() {
 		t.Fatalf("symlink %q, %q did not create symlink", to, from)
 	}
-	fromstat, err = Stat(from);
+	fromstat, err = Stat(from)
 	if err != nil {
 		t.Fatalf("stat %q failed: %v", from, err)
 	}
 	if !fromstat.FollowedSymlink {
 		t.Fatalf("stat %q did not follow symlink")
 	}
-	s, err := Readlink(from);
+	s, err := Readlink(from)
 	if err != nil {
 		t.Fatalf("readlink %q failed: %v", from, err)
 	}
 	if s != to {
 		t.Fatalf("after symlink %q != %q", s, to)
 	}
-	file, err = Open(from, O_RDONLY, 0);
+	file, err = Open(from, O_RDONLY, 0)
 	if err != nil {
 		t.Fatalf("open %q failed: %v", from, err)
 	}
-	file.Close();
+	file.Close()
 }
 
 func TestLongSymlink(t *testing.T) {
-	s := "0123456789abcdef";
+	s := "0123456789abcdef"
 	// Long, but not too long: a common limit is 255.
-	s = s + s + s + s + s + s + s + s + s + s + s + s + s + s + s;
-	from := "longsymlinktestfrom";
-	err := Symlink(s, from);
+	s = s + s + s + s + s + s + s + s + s + s + s + s + s + s + s
+	from := "longsymlinktestfrom"
+	err := Symlink(s, from)
 	if err != nil {
 		t.Fatalf("symlink %q, %q failed: %v", s, from, err)
 	}
-	defer Remove(from);
-	r, err := Readlink(from);
+	defer Remove(from)
+	r, err := Readlink(from)
 	if err != nil {
 		t.Fatalf("readlink %q failed: %v", from, err)
 	}
@@ -316,49 +316,49 @@ func TestLongSymlink(t *testing.T) {
 }
 
 func TestRename(t *testing.T) {
-	from, to := "renamefrom", "renameto";
-	Remove(to);	// Just in case.
-	file, err := Open(from, O_CREAT|O_WRONLY, 0666);
+	from, to := "renamefrom", "renameto"
+	Remove(to) // Just in case.
+	file, err := Open(from, O_CREAT|O_WRONLY, 0666)
 	if err != nil {
 		t.Fatalf("open %q failed: %v", to, err)
 	}
 	if err = file.Close(); err != nil {
 		t.Errorf("close %q failed: %v", to, err)
 	}
-	err = Rename(from, to);
+	err = Rename(from, to)
 	if err != nil {
 		t.Fatalf("rename %q, %q failed: %v", to, from, err)
 	}
-	defer Remove(to);
-	_, err = Stat(to);
+	defer Remove(to)
+	_, err = Stat(to)
 	if err != nil {
 		t.Errorf("stat %q failed: %v", to, err)
 	}
 }
 
 func TestForkExec(t *testing.T) {
-	r, w, err := Pipe();
+	r, w, err := Pipe()
 	if err != nil {
 		t.Fatalf("Pipe: %v", err)
 	}
-	pid, err := ForkExec("/bin/pwd", []string{"pwd"}, nil, "/", []*File{nil, w, Stderr});
+	pid, err := ForkExec("/bin/pwd", []string{"pwd"}, nil, "/", []*File{nil, w, Stderr})
 	if err != nil {
 		t.Fatalf("ForkExec: %v", err)
 	}
-	w.Close();
+	w.Close()
 
-	var b bytes.Buffer;
-	io.Copy(&b, r);
-	output := b.String();
-	expect := "/\n";
+	var b bytes.Buffer
+	io.Copy(&b, r)
+	output := b.String()
+	expect := "/\n"
 	if output != expect {
 		t.Errorf("exec /bin/pwd returned %q wanted %q", output, expect)
 	}
-	Wait(pid, 0);
+	Wait(pid, 0)
 }
 
 func checkMode(t *testing.T, path string, mode uint32) {
-	dir, err := Stat(path);
+	dir, err := Stat(path)
 	if err != nil {
 		t.Fatalf("Stat %q (looking for mode %#o): %s", path, mode, err)
 	}
@@ -368,9 +368,9 @@ func checkMode(t *testing.T, path string, mode uint32) {
 }
 
 func TestChmod(t *testing.T) {
-	MkdirAll("_obj", 0777);
-	const Path = "_obj/_TestChmod_";
-	fd, err := Open(Path, O_WRONLY|O_CREAT, 0666);
+	MkdirAll("_obj", 0777)
+	const Path = "_obj/_TestChmod_"
+	fd, err := Open(Path, O_WRONLY|O_CREAT, 0666)
 	if err != nil {
 		t.Fatalf("create %s: %s", Path, err)
 	}
@@ -378,19 +378,19 @@ func TestChmod(t *testing.T) {
 	if err = Chmod(Path, 0456); err != nil {
 		t.Fatalf("chmod %s 0456: %s", Path, err)
 	}
-	checkMode(t, Path, 0456);
+	checkMode(t, Path, 0456)
 
 	if err = fd.Chmod(0123); err != nil {
 		t.Fatalf("fchmod %s 0123: %s", Path, err)
 	}
-	checkMode(t, Path, 0123);
+	checkMode(t, Path, 0123)
 
-	fd.Close();
-	Remove(Path);
+	fd.Close()
+	Remove(Path)
 }
 
 func checkUidGid(t *testing.T, path string, uid, gid int) {
-	dir, err := Stat(path);
+	dir, err := Stat(path)
 	if err != nil {
 		t.Fatalf("Stat %q (looking for uid/gid %d/%d): %s", path, uid, gid, err)
 	}
@@ -408,49 +408,49 @@ func TestChown(t *testing.T) {
 	// on the file.  If _obj is on NFS, the Getgroups groups are
 	// basically useless.
 
-	const Path = "/tmp/_TestChown_";
-	fd, err := Open(Path, O_WRONLY|O_CREAT, 0666);
+	const Path = "/tmp/_TestChown_"
+	fd, err := Open(Path, O_WRONLY|O_CREAT, 0666)
 	if err != nil {
 		t.Fatalf("create %s: %s", Path, err)
 	}
-	dir, err := fd.Stat();
+	dir, err := fd.Stat()
 	if err != nil {
 		t.Fatalf("fstat %s: %s", Path, err)
 	}
-	defer fd.Close();
-	defer Remove(Path);
+	defer fd.Close()
+	defer Remove(Path)
 
 	// Can't change uid unless root, but can try
 	// changing the group id.  First try our current group.
-	gid := Getgid();
-	t.Log("gid:", gid);
+	gid := Getgid()
+	t.Log("gid:", gid)
 	if err = Chown(Path, -1, gid); err != nil {
 		t.Fatalf("chown %s -1 %d: %s", Path, gid, err)
 	}
-	checkUidGid(t, Path, int(dir.Uid), gid);
+	checkUidGid(t, Path, int(dir.Uid), gid)
 
 	// Then try all the auxiliary groups.
-	groups, err := Getgroups();
+	groups, err := Getgroups()
 	if err != nil {
 		t.Fatalf("getgroups: %s", err)
 	}
-	t.Log("groups: ", groups);
+	t.Log("groups: ", groups)
 	for _, g := range groups {
 		if err = Chown(Path, -1, g); err != nil {
 			t.Fatalf("chown %s -1 %d: %s", Path, g, err)
 		}
-		checkUidGid(t, Path, int(dir.Uid), g);
+		checkUidGid(t, Path, int(dir.Uid), g)
 
 		// change back to gid to test fd.Chown
 		if err = fd.Chown(-1, gid); err != nil {
 			t.Fatalf("fchown %s -1 %d: %s", Path, gid, err)
 		}
-		checkUidGid(t, Path, int(dir.Uid), gid);
+		checkUidGid(t, Path, int(dir.Uid), gid)
 	}
 }
 
 func checkSize(t *testing.T, path string, size uint64) {
-	dir, err := Stat(path);
+	dir, err := Stat(path)
 	if err != nil {
 		t.Fatalf("Stat %q (looking for size %d): %s", path, size, err)
 	}
@@ -460,73 +460,73 @@ func checkSize(t *testing.T, path string, size uint64) {
 }
 
 func TestTruncate(t *testing.T) {
-	MkdirAll("_obj", 0777);
-	const Path = "_obj/_TestTruncate_";
-	fd, err := Open(Path, O_WRONLY|O_CREAT, 0666);
+	MkdirAll("_obj", 0777)
+	const Path = "_obj/_TestTruncate_"
+	fd, err := Open(Path, O_WRONLY|O_CREAT, 0666)
 	if err != nil {
 		t.Fatalf("create %s: %s", Path, err)
 	}
 
-	checkSize(t, Path, 0);
-	fd.Write(strings.Bytes("hello, world\n"));
-	checkSize(t, Path, 13);
-	fd.Truncate(10);
-	checkSize(t, Path, 10);
-	fd.Truncate(1024);
-	checkSize(t, Path, 1024);
-	fd.Truncate(0);
-	checkSize(t, Path, 0);
-	fd.Write(strings.Bytes("surprise!"));
-	checkSize(t, Path, 13+9);	// wrote at offset past where hello, world was.
-	fd.Close();
-	Remove(Path);
+	checkSize(t, Path, 0)
+	fd.Write(strings.Bytes("hello, world\n"))
+	checkSize(t, Path, 13)
+	fd.Truncate(10)
+	checkSize(t, Path, 10)
+	fd.Truncate(1024)
+	checkSize(t, Path, 1024)
+	fd.Truncate(0)
+	checkSize(t, Path, 0)
+	fd.Write(strings.Bytes("surprise!"))
+	checkSize(t, Path, 13+9) // wrote at offset past where hello, world was.
+	fd.Close()
+	Remove(Path)
 }
 
 func TestChdirAndGetwd(t *testing.T) {
-	fd, err := Open(".", O_RDONLY, 0);
+	fd, err := Open(".", O_RDONLY, 0)
 	if err != nil {
 		t.Fatalf("Open .: %s", err)
 	}
 	// These are chosen carefully not to be symlinks on a Mac
 	// (unlike, say, /var, /etc, and /tmp).
-	dirs := []string{"/bin", "/", "/usr/bin"};
+	dirs := []string{"/bin", "/", "/usr/bin"}
 	for mode := 0; mode < 2; mode++ {
 		for _, d := range dirs {
 			if mode == 0 {
 				err = Chdir(d)
 			} else {
-				fd1, err := Open(d, O_RDONLY, 0);
+				fd1, err := Open(d, O_RDONLY, 0)
 				if err != nil {
-					t.Errorf("Open %s: %s", d, err);
-					continue;
+					t.Errorf("Open %s: %s", d, err)
+					continue
 				}
-				err = fd1.Chdir();
-				fd1.Close();
+				err = fd1.Chdir()
+				fd1.Close()
 			}
-			pwd, err1 := Getwd();
-			err2 := fd.Chdir();
+			pwd, err1 := Getwd()
+			err2 := fd.Chdir()
 			if err2 != nil {
 				// We changed the current directory and cannot go back.
 				// Don't let the tests continue; they'll scribble
 				// all over some other directory.
-				fmt.Fprintf(Stderr, "fchdir back to dot failed: %s\n", err2);
-				Exit(1);
+				fmt.Fprintf(Stderr, "fchdir back to dot failed: %s\n", err2)
+				Exit(1)
 			}
 			if err != nil {
-				fd.Close();
-				t.Fatalf("Chdir %s: %s", d, err);
+				fd.Close()
+				t.Fatalf("Chdir %s: %s", d, err)
 			}
 			if err1 != nil {
-				fd.Close();
-				t.Fatalf("Getwd in %s: %s", d, err1);
+				fd.Close()
+				t.Fatalf("Getwd in %s: %s", d, err1)
 			}
 			if pwd != d {
-				fd.Close();
-				t.Fatalf("Getwd returned %q want %q", pwd, d);
+				fd.Close()
+				t.Fatalf("Getwd returned %q want %q", pwd, d)
 			}
 		}
 	}
-	fd.Close();
+	fd.Close()
 }
 
 func TestTime(t *testing.T) {
@@ -536,25 +536,25 @@ func TestTime(t *testing.T) {
 	// filling in the structure passed to the system call.
 	// Too bad the compiler doesn't know that
 	// 365.24*86400 is an integer.
-	sec, nsec, err := Time();
+	sec, nsec, err := Time()
 	if sec < (2009-1970)*36524*864 {
 		t.Errorf("Time() = %d, %d, %s; not plausible", sec, nsec, err)
 	}
 }
 
 func TestSeek(t *testing.T) {
-	f, err := Open("_obj/seektest", O_CREAT|O_RDWR|O_TRUNC, 0666);
+	f, err := Open("_obj/seektest", O_CREAT|O_RDWR|O_TRUNC, 0666)
 	if err != nil {
 		t.Fatalf("open _obj/seektest: %s", err)
 	}
 
-	const data = "hello, world\n";
-	io.WriteString(f, data);
+	const data = "hello, world\n"
+	io.WriteString(f, data)
 
 	type test struct {
-		in	int64;
-		whence	int;
-		out	int64;
+		in     int64
+		whence int
+		out    int64
 	}
 	var tests = []test{
 		test{0, 1, int64(len(data))},
@@ -565,25 +565,25 @@ func TestSeek(t *testing.T) {
 		test{-1, 2, int64(len(data)) - 1},
 		test{1 << 33, 0, 1 << 33},
 		test{1 << 33, 2, 1<<33 + int64(len(data))},
-	};
+	}
 	for i, tt := range tests {
-		off, err := f.Seek(tt.in, tt.whence);
+		off, err := f.Seek(tt.in, tt.whence)
 		if off != tt.out || err != nil {
 			if e, ok := err.(*PathError); ok && e.Error == EINVAL && tt.out > 1<<32 {
 				// Reiserfs rejects the big seeks.
 				// http://code.google.com/p/go/issues/detail?id=91
 				break
 			}
-			t.Errorf("#%d: Seek(%v, %v) = %v, %v want %v, nil", i, tt.in, tt.whence, off, err, tt.out);
+			t.Errorf("#%d: Seek(%v, %v) = %v, %v want %v, nil", i, tt.in, tt.whence, off, err, tt.out)
 		}
 	}
-	f.Close();
+	f.Close()
 }
 
 type openErrorTest struct {
-	path	string;
-	mode	int;
-	error	string;
+	path  string
+	mode  int
+	error string
 }
 
 var openErrorTests = []openErrorTest{
@@ -606,11 +606,11 @@ var openErrorTests = []openErrorTest{
 
 func TestOpenError(t *testing.T) {
 	for _, tt := range openErrorTests {
-		f, err := Open(tt.path, tt.mode, 0);
+		f, err := Open(tt.path, tt.mode, 0)
 		if err == nil {
-			t.Errorf("Open(%q, %d) succeeded", tt.path, tt.mode);
-			f.Close();
-			continue;
+			t.Errorf("Open(%q, %d) succeeded", tt.path, tt.mode)
+			f.Close()
+			continue
 		}
 		if s := err.String(); s != tt.error {
 			t.Errorf("Open(%q, %d) = _, %q; want %q", tt.path, tt.mode, s, tt.error)
@@ -620,20 +620,20 @@ func TestOpenError(t *testing.T) {
 
 func run(t *testing.T, cmd []string) string {
 	// Run /bin/hostname and collect output.
-	r, w, err := Pipe();
+	r, w, err := Pipe()
 	if err != nil {
 		t.Fatal(err)
 	}
-	pid, err := ForkExec("/bin/hostname", []string{"hostname"}, nil, "/", []*File{nil, w, Stderr});
+	pid, err := ForkExec("/bin/hostname", []string{"hostname"}, nil, "/", []*File{nil, w, Stderr})
 	if err != nil {
 		t.Fatal(err)
 	}
-	w.Close();
+	w.Close()
 
-	var b bytes.Buffer;
-	io.Copy(&b, r);
-	Wait(pid, 0);
-	output := b.String();
+	var b bytes.Buffer
+	io.Copy(&b, r)
+	Wait(pid, 0)
+	output := b.String()
 	if n := len(output); n > 0 && output[n-1] == '\n' {
 		output = output[0 : n-1]
 	}
@@ -641,32 +641,32 @@ func run(t *testing.T, cmd []string) string {
 		t.Fatalf("%v produced no output", cmd)
 	}
 
-	return output;
+	return output
 }
 
 
 func TestHostname(t *testing.T) {
 	// Check internal Hostname() against the output of /bin/hostname.
-	hostname, err := Hostname();
+	hostname, err := Hostname()
 	if err != nil {
 		t.Fatalf("%v", err)
 	}
-	want := run(t, []string{"/bin/hostname"});
+	want := run(t, []string{"/bin/hostname"})
 	if hostname != want {
 		t.Errorf("Hostname() = %q, want %q", hostname, want)
 	}
 }
 
 func TestReadAt(t *testing.T) {
-	f, err := Open("_obj/readtest", O_CREAT|O_RDWR|O_TRUNC, 0666);
+	f, err := Open("_obj/readtest", O_CREAT|O_RDWR|O_TRUNC, 0666)
 	if err != nil {
 		t.Fatalf("open _obj/readtest: %s", err)
 	}
-	const data = "hello, world\n";
-	io.WriteString(f, data);
+	const data = "hello, world\n"
+	io.WriteString(f, data)
 
-	b := make([]byte, 5);
-	n, err := f.ReadAt(b, 7);
+	b := make([]byte, 5)
+	n, err := f.ReadAt(b, 7)
 	if err != nil || n != len(b) {
 		t.Fatalf("ReadAt 7: %d, %r", n, err)
 	}
@@ -676,19 +676,19 @@ func TestReadAt(t *testing.T) {
 }
 
 func TestWriteAt(t *testing.T) {
-	f, err := Open("_obj/writetest", O_CREAT|O_RDWR|O_TRUNC, 0666);
+	f, err := Open("_obj/writetest", O_CREAT|O_RDWR|O_TRUNC, 0666)
 	if err != nil {
 		t.Fatalf("open _obj/writetest: %s", err)
 	}
-	const data = "hello, world\n";
-	io.WriteString(f, data);
+	const data = "hello, world\n"
+	io.WriteString(f, data)
 
-	n, err := f.WriteAt(strings.Bytes("WORLD"), 7);
+	n, err := f.WriteAt(strings.Bytes("WORLD"), 7)
 	if err != nil || n != 5 {
 		t.Fatalf("WriteAt 7: %d, %v", n, err)
 	}
 
-	b, err := ioutil.ReadFile("_obj/writetest");
+	b, err := ioutil.ReadFile("_obj/writetest")
 	if err != nil {
 		t.Fatalf("ReadFile _obj/writetest: %v", err)
 	}
diff --git a/src/pkg/os/path.go b/src/pkg/os/path.go
index cdaee92d72..36f497a1a5 100644
--- a/src/pkg/os/path.go
+++ b/src/pkg/os/path.go
@@ -14,45 +14,45 @@ package os
 // and returns nil.
 func MkdirAll(path string, perm int) Error {
 	// If path exists, stop with success or error.
-	dir, err := Lstat(path);
+	dir, err := Lstat(path)
 	if err == nil {
 		if dir.IsDirectory() {
 			return nil
 		}
-		return &PathError{"mkdir", path, ENOTDIR};
+		return &PathError{"mkdir", path, ENOTDIR}
 	}
 
 	// Doesn't already exist; make sure parent does.
-	i := len(path);
-	for i > 0 && path[i-1] == '/' {	// Skip trailing slashes.
+	i := len(path)
+	for i > 0 && path[i-1] == '/' { // Skip trailing slashes.
 		i--
 	}
 
-	j := i;
-	for j > 0 && path[j-1] != '/' {	// Scan backward over element.
+	j := i
+	for j > 0 && path[j-1] != '/' { // Scan backward over element.
 		j--
 	}
 
 	if j > 0 {
 		// Create parent
-		err = MkdirAll(path[0:j-1], perm);
+		err = MkdirAll(path[0:j-1], perm)
 		if err != nil {
 			return err
 		}
 	}
 
 	// Now parent exists, try to create.
-	err = Mkdir(path, perm);
+	err = Mkdir(path, perm)
 	if err != nil {
 		// Handle arguments like "foo/." by
 		// double-checking that directory doesn't exist.
-		dir, err1 := Lstat(path);
+		dir, err1 := Lstat(path)
 		if err1 == nil && dir.IsDirectory() {
 			return nil
 		}
-		return err;
+		return err
 	}
-	return nil;
+	return nil
 }
 
 // RemoveAll removes path and any children it contains.
@@ -61,18 +61,18 @@ func MkdirAll(path string, perm int) Error {
 // returns nil (no error).
 func RemoveAll(path string) Error {
 	// Simple case: if Remove works, we're done.
-	err := Remove(path);
+	err := Remove(path)
 	if err == nil {
 		return nil
 	}
 
 	// Otherwise, is this a directory we need to recurse into?
-	dir, serr := Lstat(path);
+	dir, serr := Lstat(path)
 	if serr != nil {
 		if serr, ok := serr.(*PathError); ok && serr.Error == ENOENT {
 			return nil
 		}
-		return serr;
+		return serr
 	}
 	if !dir.IsDirectory() {
 		// Not a directory; return the error from Remove.
@@ -80,18 +80,18 @@ func RemoveAll(path string) Error {
 	}
 
 	// Directory.
-	fd, err := Open(path, O_RDONLY, 0);
+	fd, err := Open(path, O_RDONLY, 0)
 	if err != nil {
 		return err
 	}
-	defer fd.Close();
+	defer fd.Close()
 
 	// Remove contents & return first error.
-	err = nil;
+	err = nil
 	for {
-		names, err1 := fd.Readdirnames(100);
+		names, err1 := fd.Readdirnames(100)
 		for _, name := range names {
-			err1 := RemoveAll(path + "/" + name);
+			err1 := RemoveAll(path + "/" + name)
 			if err == nil {
 				err = err1
 			}
@@ -106,9 +106,9 @@ func RemoveAll(path string) Error {
 	}
 
 	// Remove directory.
-	err1 := Remove(path);
+	err1 := Remove(path)
 	if err == nil {
 		err = err1
 	}
-	return err;
+	return err
 }
diff --git a/src/pkg/os/path_test.go b/src/pkg/os/path_test.go
index 9b01bd5b64..fcd4bac54f 100644
--- a/src/pkg/os/path_test.go
+++ b/src/pkg/os/path_test.go
@@ -5,38 +5,38 @@
 package os_test
 
 import (
-	. "os";
-	"testing";
+	. "os"
+	"testing"
 )
 
 func TestMkdirAll(t *testing.T) {
 	// Create new dir, in _obj so it will get
 	// cleaned up by make if not by us.
-	path := "_obj/_TestMkdirAll_/dir/./dir2";
-	err := MkdirAll(path, 0777);
+	path := "_obj/_TestMkdirAll_/dir/./dir2"
+	err := MkdirAll(path, 0777)
 	if err != nil {
 		t.Fatalf("MkdirAll %q: %s", path, err)
 	}
 
 	// Already exists, should succeed.
-	err = MkdirAll(path, 0777);
+	err = MkdirAll(path, 0777)
 	if err != nil {
 		t.Fatalf("MkdirAll %q (second time): %s", path, err)
 	}
 
 	// Make file.
-	fpath := path + "/file";
-	_, err = Open(fpath, O_WRONLY|O_CREAT, 0666);
+	fpath := path + "/file"
+	_, err = Open(fpath, O_WRONLY|O_CREAT, 0666)
 	if err != nil {
 		t.Fatalf("create %q: %s", fpath, err)
 	}
 
 	// Can't make directory named after file.
-	err = MkdirAll(fpath, 0777);
+	err = MkdirAll(fpath, 0777)
 	if err == nil {
 		t.Fatalf("MkdirAll %q: no error")
 	}
-	perr, ok := err.(*PathError);
+	perr, ok := err.(*PathError)
 	if !ok {
 		t.Fatalf("MkdirAll %q returned %T, not *PathError", fpath, err)
 	}
@@ -45,12 +45,12 @@ func TestMkdirAll(t *testing.T) {
 	}
 
 	// Can't make subdirectory of file.
-	ffpath := fpath + "/subdir";
-	err = MkdirAll(ffpath, 0777);
+	ffpath := fpath + "/subdir"
+	err = MkdirAll(ffpath, 0777)
 	if err == nil {
 		t.Fatalf("MkdirAll %q: no error")
 	}
-	perr, ok = err.(*PathError);
+	perr, ok = err.(*PathError)
 	if !ok {
 		t.Fatalf("MkdirAll %q returned %T, not *PathError", ffpath, err)
 	}
@@ -58,24 +58,24 @@ func TestMkdirAll(t *testing.T) {
 		t.Fatalf("MkdirAll %q returned wrong error path: %q not %q", ffpath, perr.Path, fpath)
 	}
 
-	RemoveAll("_obj/_TestMkdirAll_");
+	RemoveAll("_obj/_TestMkdirAll_")
 }
 
 func TestRemoveAll(t *testing.T) {
 	// Work directory.
-	path := "_obj/_TestRemoveAll_";
-	fpath := path + "/file";
-	dpath := path + "/dir";
+	path := "_obj/_TestRemoveAll_"
+	fpath := path + "/file"
+	dpath := path + "/dir"
 
 	// Make directory with 1 file and remove.
 	if err := MkdirAll(path, 0777); err != nil {
 		t.Fatalf("MkdirAll %q: %s", path, err)
 	}
-	fd, err := Open(fpath, O_WRONLY|O_CREAT, 0666);
+	fd, err := Open(fpath, O_WRONLY|O_CREAT, 0666)
 	if err != nil {
 		t.Fatalf("create %q: %s", fpath, err)
 	}
-	fd.Close();
+	fd.Close()
 	if err = RemoveAll(path); err != nil {
 		t.Fatalf("RemoveAll %q (first): %s", path, err)
 	}
@@ -87,16 +87,16 @@ func TestRemoveAll(t *testing.T) {
 	if err = MkdirAll(dpath, 0777); err != nil {
 		t.Fatalf("MkdirAll %q: %s", dpath, err)
 	}
-	fd, err = Open(fpath, O_WRONLY|O_CREAT, 0666);
+	fd, err = Open(fpath, O_WRONLY|O_CREAT, 0666)
 	if err != nil {
 		t.Fatalf("create %q: %s", fpath, err)
 	}
-	fd.Close();
-	fd, err = Open(dpath+"/file", O_WRONLY|O_CREAT, 0666);
+	fd.Close()
+	fd, err = Open(dpath+"/file", O_WRONLY|O_CREAT, 0666)
 	if err != nil {
 		t.Fatalf("create %q: %s", fpath, err)
 	}
-	fd.Close();
+	fd.Close()
 	if err = RemoveAll(path); err != nil {
 		t.Fatalf("RemoveAll %q (second): %s", path, err)
 	}
@@ -104,30 +104,30 @@ func TestRemoveAll(t *testing.T) {
 		t.Fatalf("Lstat %q succeeded after RemoveAll (second)", path)
 	}
 
-	if Getuid() != 0 {	// Test fails as root
+	if Getuid() != 0 { // Test fails as root
 		// Make directory with file and subdirectory and trigger error.
 		if err = MkdirAll(dpath, 0777); err != nil {
 			t.Fatalf("MkdirAll %q: %s", dpath, err)
 		}
 
 		for _, s := range []string{fpath, dpath + "/file1", path + "/zzz"} {
-			fd, err = Open(s, O_WRONLY|O_CREAT, 0666);
+			fd, err = Open(s, O_WRONLY|O_CREAT, 0666)
 			if err != nil {
 				t.Fatalf("create %q: %s", s, err)
 			}
-			fd.Close();
+			fd.Close()
 		}
 		if err = Chmod(dpath, 0); err != nil {
 			t.Fatalf("Chmod %q 0: %s", dpath, err)
 		}
 		if err = RemoveAll(path); err == nil {
-			_, err := Lstat(path);
+			_, err := Lstat(path)
 			if err == nil {
 				t.Errorf("Can lstat %q after supposed RemoveAll", path)
 			}
-			t.Fatalf("RemoveAll %q succeeded with chmod 0 subdirectory", path, err);
+			t.Fatalf("RemoveAll %q succeeded with chmod 0 subdirectory", path, err)
 		}
-		perr, ok := err.(*PathError);
+		perr, ok := err.(*PathError)
 		if !ok {
 			t.Fatalf("RemoveAll %q returned %T not *PathError", path, err)
 		}
diff --git a/src/pkg/os/proc.go b/src/pkg/os/proc.go
index e780cfc9ad..dfddab6cb8 100644
--- a/src/pkg/os/proc.go
+++ b/src/pkg/os/proc.go
@@ -8,28 +8,28 @@ package os
 
 import "syscall"
 
-var Args []string	// provided by runtime
-var Envs []string	// provided by runtime
+var Args []string // provided by runtime
+var Envs []string // provided by runtime
 
 
 // Getuid returns the numeric user id of the caller.
-func Getuid() int	{ return syscall.Getuid() }
+func Getuid() int { return syscall.Getuid() }
 
 // Geteuid returns the numeric effective user id of the caller.
-func Geteuid() int	{ return syscall.Geteuid() }
+func Geteuid() int { return syscall.Geteuid() }
 
 // Getgid returns the numeric group id of the caller.
-func Getgid() int	{ return syscall.Getgid() }
+func Getgid() int { return syscall.Getgid() }
 
 // Getegid returns the numeric effective group id of the caller.
-func Getegid() int	{ return syscall.Getegid() }
+func Getegid() int { return syscall.Getegid() }
 
 // Getgroups returns a list of the numeric ids of groups that the caller belongs to.
 func Getgroups() ([]int, Error) {
-	gids, errno := syscall.Getgroups();
-	return gids, NewSyscallError("getgroups", errno);
+	gids, errno := syscall.Getgroups()
+	return gids, NewSyscallError("getgroups", errno)
 }
 
 // Exit causes the current program to exit with the given status code.
 // Conventionally, code zero indicates success, non-zero an error.
-func Exit(code int)	{ syscall.Exit(code) }
+func Exit(code int) { syscall.Exit(code) }
diff --git a/src/pkg/os/stat_darwin.go b/src/pkg/os/stat_darwin.go
index 857c9068d3..003a453516 100644
--- a/src/pkg/os/stat_darwin.go
+++ b/src/pkg/os/stat_darwin.go
@@ -11,28 +11,28 @@ func isSymlink(stat *syscall.Stat_t) bool {
 }
 
 func dirFromStat(name string, dir *Dir, lstat, stat *syscall.Stat_t) *Dir {
-	dir.Dev = uint64(stat.Dev);
-	dir.Ino = stat.Ino;
-	dir.Nlink = uint64(stat.Nlink);
-	dir.Mode = uint32(stat.Mode);
-	dir.Uid = stat.Uid;
-	dir.Gid = stat.Gid;
-	dir.Rdev = uint64(stat.Rdev);
-	dir.Size = uint64(stat.Size);
-	dir.Blksize = uint64(stat.Blksize);
-	dir.Blocks = uint64(stat.Blocks);
-	dir.Atime_ns = uint64(syscall.TimespecToNsec(stat.Atimespec));
-	dir.Mtime_ns = uint64(syscall.TimespecToNsec(stat.Mtimespec));
-	dir.Ctime_ns = uint64(syscall.TimespecToNsec(stat.Ctimespec));
+	dir.Dev = uint64(stat.Dev)
+	dir.Ino = stat.Ino
+	dir.Nlink = uint64(stat.Nlink)
+	dir.Mode = uint32(stat.Mode)
+	dir.Uid = stat.Uid
+	dir.Gid = stat.Gid
+	dir.Rdev = uint64(stat.Rdev)
+	dir.Size = uint64(stat.Size)
+	dir.Blksize = uint64(stat.Blksize)
+	dir.Blocks = uint64(stat.Blocks)
+	dir.Atime_ns = uint64(syscall.TimespecToNsec(stat.Atimespec))
+	dir.Mtime_ns = uint64(syscall.TimespecToNsec(stat.Mtimespec))
+	dir.Ctime_ns = uint64(syscall.TimespecToNsec(stat.Ctimespec))
 	for i := len(name) - 1; i >= 0; i-- {
 		if name[i] == '/' {
-			name = name[i+1:];
-			break;
+			name = name[i+1:]
+			break
 		}
 	}
-	dir.Name = name;
+	dir.Name = name
 	if isSymlink(lstat) && !isSymlink(stat) {
 		dir.FollowedSymlink = true
 	}
-	return dir;
+	return dir
 }
diff --git a/src/pkg/os/stat_freebsd.go b/src/pkg/os/stat_freebsd.go
index c28f976894..84a6c7859d 100644
--- a/src/pkg/os/stat_freebsd.go
+++ b/src/pkg/os/stat_freebsd.go
@@ -11,28 +11,28 @@ func isSymlink(stat *syscall.Stat_t) bool {
 }
 
 func dirFromStat(name string, dir *Dir, lstat, stat *syscall.Stat_t) *Dir {
-	dir.Dev = uint64(stat.Dev);
-	dir.Ino = uint64(stat.Ino);
-	dir.Nlink = uint64(stat.Nlink);
-	dir.Mode = uint32(stat.Mode);
-	dir.Uid = stat.Uid;
-	dir.Gid = stat.Gid;
-	dir.Rdev = uint64(stat.Rdev);
-	dir.Size = uint64(stat.Size);
-	dir.Blksize = uint64(stat.Blksize);
-	dir.Blocks = uint64(stat.Blocks);
-	dir.Atime_ns = uint64(syscall.TimespecToNsec(stat.Atimespec));
-	dir.Mtime_ns = uint64(syscall.TimespecToNsec(stat.Mtimespec));
-	dir.Ctime_ns = uint64(syscall.TimespecToNsec(stat.Ctimespec));
+	dir.Dev = uint64(stat.Dev)
+	dir.Ino = uint64(stat.Ino)
+	dir.Nlink = uint64(stat.Nlink)
+	dir.Mode = uint32(stat.Mode)
+	dir.Uid = stat.Uid
+	dir.Gid = stat.Gid
+	dir.Rdev = uint64(stat.Rdev)
+	dir.Size = uint64(stat.Size)
+	dir.Blksize = uint64(stat.Blksize)
+	dir.Blocks = uint64(stat.Blocks)
+	dir.Atime_ns = uint64(syscall.TimespecToNsec(stat.Atimespec))
+	dir.Mtime_ns = uint64(syscall.TimespecToNsec(stat.Mtimespec))
+	dir.Ctime_ns = uint64(syscall.TimespecToNsec(stat.Ctimespec))
 	for i := len(name) - 1; i >= 0; i-- {
 		if name[i] == '/' {
-			name = name[i+1:];
-			break;
+			name = name[i+1:]
+			break
 		}
 	}
-	dir.Name = name;
+	dir.Name = name
 	if isSymlink(lstat) && !isSymlink(stat) {
 		dir.FollowedSymlink = true
 	}
-	return dir;
+	return dir
 }
diff --git a/src/pkg/os/stat_linux.go b/src/pkg/os/stat_linux.go
index a947b58028..362fae48be 100644
--- a/src/pkg/os/stat_linux.go
+++ b/src/pkg/os/stat_linux.go
@@ -11,28 +11,28 @@ func isSymlink(stat *syscall.Stat_t) bool {
 }
 
 func dirFromStat(name string, dir *Dir, lstat, stat *syscall.Stat_t) *Dir {
-	dir.Dev = stat.Dev;
-	dir.Ino = uint64(stat.Ino);
-	dir.Nlink = uint64(stat.Nlink);
-	dir.Mode = stat.Mode;
-	dir.Uid = stat.Uid;
-	dir.Gid = stat.Gid;
-	dir.Rdev = stat.Rdev;
-	dir.Size = uint64(stat.Size);
-	dir.Blksize = uint64(stat.Blksize);
-	dir.Blocks = uint64(stat.Blocks);
-	dir.Atime_ns = uint64(syscall.TimespecToNsec(stat.Atim));
-	dir.Mtime_ns = uint64(syscall.TimespecToNsec(stat.Mtim));
-	dir.Ctime_ns = uint64(syscall.TimespecToNsec(stat.Ctim));
+	dir.Dev = stat.Dev
+	dir.Ino = uint64(stat.Ino)
+	dir.Nlink = uint64(stat.Nlink)
+	dir.Mode = stat.Mode
+	dir.Uid = stat.Uid
+	dir.Gid = stat.Gid
+	dir.Rdev = stat.Rdev
+	dir.Size = uint64(stat.Size)
+	dir.Blksize = uint64(stat.Blksize)
+	dir.Blocks = uint64(stat.Blocks)
+	dir.Atime_ns = uint64(syscall.TimespecToNsec(stat.Atim))
+	dir.Mtime_ns = uint64(syscall.TimespecToNsec(stat.Mtim))
+	dir.Ctime_ns = uint64(syscall.TimespecToNsec(stat.Ctim))
 	for i := len(name) - 1; i >= 0; i-- {
 		if name[i] == '/' {
-			name = name[i+1:];
-			break;
+			name = name[i+1:]
+			break
 		}
 	}
-	dir.Name = name;
+	dir.Name = name
 	if isSymlink(lstat) && !isSymlink(stat) {
 		dir.FollowedSymlink = true
 	}
-	return dir;
+	return dir
 }
diff --git a/src/pkg/os/stat_nacl.go b/src/pkg/os/stat_nacl.go
index 8cad9c944c..65f49c8860 100644
--- a/src/pkg/os/stat_nacl.go
+++ b/src/pkg/os/stat_nacl.go
@@ -11,28 +11,28 @@ func isSymlink(stat *syscall.Stat_t) bool {
 }
 
 func dirFromStat(name string, dir *Dir, lstat, stat *syscall.Stat_t) *Dir {
-	dir.Dev = uint64(stat.Dev);
-	dir.Ino = uint64(stat.Ino);
-	dir.Nlink = uint64(stat.Nlink);
-	dir.Mode = stat.Mode;
-	dir.Uid = stat.Uid;
-	dir.Gid = stat.Gid;
-	dir.Rdev = uint64(stat.Rdev);
-	dir.Size = uint64(stat.Size);
-	dir.Blksize = uint64(stat.Blksize);
-	dir.Blocks = uint64(stat.Blocks);
-	dir.Atime_ns = uint64(stat.Atime) * 1e9;
-	dir.Mtime_ns = uint64(stat.Mtime) * 1e9;
-	dir.Ctime_ns = uint64(stat.Ctime) * 1e9;
+	dir.Dev = uint64(stat.Dev)
+	dir.Ino = uint64(stat.Ino)
+	dir.Nlink = uint64(stat.Nlink)
+	dir.Mode = stat.Mode
+	dir.Uid = stat.Uid
+	dir.Gid = stat.Gid
+	dir.Rdev = uint64(stat.Rdev)
+	dir.Size = uint64(stat.Size)
+	dir.Blksize = uint64(stat.Blksize)
+	dir.Blocks = uint64(stat.Blocks)
+	dir.Atime_ns = uint64(stat.Atime) * 1e9
+	dir.Mtime_ns = uint64(stat.Mtime) * 1e9
+	dir.Ctime_ns = uint64(stat.Ctime) * 1e9
 	for i := len(name) - 1; i >= 0; i-- {
 		if name[i] == '/' {
-			name = name[i+1:];
-			break;
+			name = name[i+1:]
+			break
 		}
 	}
-	dir.Name = name;
+	dir.Name = name
 	if isSymlink(lstat) && !isSymlink(stat) {
 		dir.FollowedSymlink = true
 	}
-	return dir;
+	return dir
 }
diff --git a/src/pkg/os/sys_darwin.go b/src/pkg/os/sys_darwin.go
index c92845578b..2e3ab21279 100644
--- a/src/pkg/os/sys_darwin.go
+++ b/src/pkg/os/sys_darwin.go
@@ -9,10 +9,10 @@ package os
 import "syscall"
 
 func Hostname() (name string, err Error) {
-	var errno int;
-	name, errno = syscall.Sysctl("kern.hostname");
+	var errno int
+	name, errno = syscall.Sysctl("kern.hostname")
 	if errno != 0 {
 		return "", NewSyscallError("sysctl kern.hostname", errno)
 	}
-	return name, nil;
+	return name, nil
 }
diff --git a/src/pkg/os/sys_freebsd.go b/src/pkg/os/sys_freebsd.go
index cc8daeca3e..c567f5c358 100644
--- a/src/pkg/os/sys_freebsd.go
+++ b/src/pkg/os/sys_freebsd.go
@@ -7,10 +7,10 @@ package os
 import "syscall"
 
 func Hostname() (name string, err Error) {
-	var errno int;
-	name, errno = syscall.Sysctl("kern.hostname");
+	var errno int
+	name, errno = syscall.Sysctl("kern.hostname")
 	if errno != 0 {
 		return "", NewSyscallError("sysctl kern.hostname", errno)
 	}
-	return name, nil;
+	return name, nil
 }
diff --git a/src/pkg/os/sys_linux.go b/src/pkg/os/sys_linux.go
index 896be164de..0622b67122 100644
--- a/src/pkg/os/sys_linux.go
+++ b/src/pkg/os/sys_linux.go
@@ -9,14 +9,14 @@ package os
 
 // Hostname returns the host name reported by the kernel.
 func Hostname() (name string, err Error) {
-	f, err := Open("/proc/sys/kernel/hostname", O_RDONLY, 0);
+	f, err := Open("/proc/sys/kernel/hostname", O_RDONLY, 0)
 	if err != nil {
 		return "", err
 	}
-	defer f.Close();
+	defer f.Close()
 
-	var buf [512]byte;	// Enough for a DNS name.
-	n, err := f.Read(&buf);
+	var buf [512]byte // Enough for a DNS name.
+	n, err := f.Read(&buf)
 	if err != nil {
 		return "", err
 	}
@@ -24,5 +24,5 @@ func Hostname() (name string, err Error) {
 	if n > 0 && buf[n-1] == '\n' {
 		n--
 	}
-	return string(buf[0:n]), nil;
+	return string(buf[0:n]), nil
 }
diff --git a/src/pkg/os/sys_nacl.go b/src/pkg/os/sys_nacl.go
index 51694a0467..dfcccb3e82 100644
--- a/src/pkg/os/sys_nacl.go
+++ b/src/pkg/os/sys_nacl.go
@@ -4,4 +4,4 @@
 
 package os
 
-func Hostname() (name string, err Error)	{ return "nacl", nil }
+func Hostname() (name string, err Error) { return "nacl", nil }
diff --git a/src/pkg/os/time.go b/src/pkg/os/time.go
index 2510b8586a..380345f1b1 100644
--- a/src/pkg/os/time.go
+++ b/src/pkg/os/time.go
@@ -12,9 +12,9 @@ import "syscall"
 // time is thus 1e9*sec+nsec, in nanoseconds.  The zero of
 // time is the Unix epoch.
 func Time() (sec int64, nsec int64, err Error) {
-	var tv syscall.Timeval;
+	var tv syscall.Timeval
 	if errno := syscall.Gettimeofday(&tv); errno != 0 {
 		return 0, 0, NewSyscallError("gettimeofday", errno)
 	}
-	return int64(tv.Sec), int64(tv.Usec) * 1000, err;
+	return int64(tv.Sec), int64(tv.Usec) * 1000, err
 }
diff --git a/src/pkg/os/types.go b/src/pkg/os/types.go
index ec3b4e11b4..673b7f788f 100644
--- a/src/pkg/os/types.go
+++ b/src/pkg/os/types.go
@@ -10,47 +10,47 @@ import "syscall"
 // OS-specific routines in this directory convert the OS-local versions to these.
 
 // Getpagesize returns the underlying system's memory page size.
-func Getpagesize() int	{ return syscall.Getpagesize() }
+func Getpagesize() int { return syscall.Getpagesize() }
 
 // A Dir describes a file and is returned by Stat, Fstat, and Lstat
 type Dir struct {
-	Dev		uint64;	// device number of file system holding file.
-	Ino		uint64;	// inode number.
-	Nlink		uint64;	// number of hard links.
-	Mode		uint32;	// permission and mode bits.
-	Uid		uint32;	// user id of owner.
-	Gid		uint32;	// group id of owner.
-	Rdev		uint64;	// device type for special file.
-	Size		uint64;	// length in bytes.
-	Blksize		uint64;	// size of blocks, in bytes.
-	Blocks		uint64;	// number of blocks allocated for file.
-	Atime_ns	uint64;	// access time; nanoseconds since epoch.
-	Mtime_ns	uint64;	// modified time; nanoseconds since epoch.
-	Ctime_ns	uint64;	// status change time; nanoseconds since epoch.
-	Name		string;	// name of file as presented to Open.
-	FollowedSymlink	bool;	// followed a symlink to get this information
+	Dev             uint64 // device number of file system holding file.
+	Ino             uint64 // inode number.
+	Nlink           uint64 // number of hard links.
+	Mode            uint32 // permission and mode bits.
+	Uid             uint32 // user id of owner.
+	Gid             uint32 // group id of owner.
+	Rdev            uint64 // device type for special file.
+	Size            uint64 // length in bytes.
+	Blksize         uint64 // size of blocks, in bytes.
+	Blocks          uint64 // number of blocks allocated for file.
+	Atime_ns        uint64 // access time; nanoseconds since epoch.
+	Mtime_ns        uint64 // modified time; nanoseconds since epoch.
+	Ctime_ns        uint64 // status change time; nanoseconds since epoch.
+	Name            string // name of file as presented to Open.
+	FollowedSymlink bool   // followed a symlink to get this information
 }
 
 // IsFifo reports whether the Dir describes a FIFO file.
-func (dir *Dir) IsFifo() bool	{ return (dir.Mode & syscall.S_IFMT) == syscall.S_IFIFO }
+func (dir *Dir) IsFifo() bool { return (dir.Mode & syscall.S_IFMT) == syscall.S_IFIFO }
 
 // IsChar reports whether the Dir describes a character special file.
-func (dir *Dir) IsChar() bool	{ return (dir.Mode & syscall.S_IFMT) == syscall.S_IFCHR }
+func (dir *Dir) IsChar() bool { return (dir.Mode & syscall.S_IFMT) == syscall.S_IFCHR }
 
 // IsDirectory reports whether the Dir describes a directory.
-func (dir *Dir) IsDirectory() bool	{ return (dir.Mode & syscall.S_IFMT) == syscall.S_IFDIR }
+func (dir *Dir) IsDirectory() bool { return (dir.Mode & syscall.S_IFMT) == syscall.S_IFDIR }
 
 // IsBlock reports whether the Dir describes a block special file.
-func (dir *Dir) IsBlock() bool	{ return (dir.Mode & syscall.S_IFMT) == syscall.S_IFBLK }
+func (dir *Dir) IsBlock() bool { return (dir.Mode & syscall.S_IFMT) == syscall.S_IFBLK }
 
 // IsRegular reports whether the Dir describes a regular file.
-func (dir *Dir) IsRegular() bool	{ return (dir.Mode & syscall.S_IFMT) == syscall.S_IFREG }
+func (dir *Dir) IsRegular() bool { return (dir.Mode & syscall.S_IFMT) == syscall.S_IFREG }
 
 // IsSymlink reports whether the Dir describes a symbolic link.
-func (dir *Dir) IsSymlink() bool	{ return (dir.Mode & syscall.S_IFMT) == syscall.S_IFLNK }
+func (dir *Dir) IsSymlink() bool { return (dir.Mode & syscall.S_IFMT) == syscall.S_IFLNK }
 
 // IsSocket reports whether the Dir describes a socket.
-func (dir *Dir) IsSocket() bool	{ return (dir.Mode & syscall.S_IFMT) == syscall.S_IFSOCK }
+func (dir *Dir) IsSocket() bool { return (dir.Mode & syscall.S_IFMT) == syscall.S_IFSOCK }
 
 // Permission returns the file permission bits.
-func (dir *Dir) Permission() int	{ return int(dir.Mode & 0777) }
+func (dir *Dir) Permission() int { return int(dir.Mode & 0777) }
diff --git a/src/pkg/patch/apply.go b/src/pkg/patch/apply.go
index fc82f93cc8..0dd9080bf3 100644
--- a/src/pkg/patch/apply.go
+++ b/src/pkg/patch/apply.go
@@ -8,11 +8,11 @@ import "os"
 
 // An Op is a single operation to execute to apply a patch.
 type Op struct {
-	Verb	Verb;	// action
-	Src	string;	// source file
-	Dst	string;	// destination file
-	Mode	int;	// mode for destination (if non-zero)
-	Data	[]byte;	// data for destination (if non-nil)
+	Verb Verb   // action
+	Src  string // source file
+	Dst  string // destination file
+	Mode int    // mode for destination (if non-zero)
+	Data []byte // data for destination (if non-nil)
 }
 
 // Apply applies the patch set to the files named in the patch set,
@@ -24,31 +24,31 @@ type Op struct {
 // Typically this function will be io.ReadFile.
 //
 func (set *Set) Apply(readFile func(string) ([]byte, os.Error)) ([]Op, os.Error) {
-	op := make([]Op, len(set.File));
+	op := make([]Op, len(set.File))
 
 	for i, f := range set.File {
-		o := &op[i];
-		o.Verb = f.Verb;
-		o.Src = f.Src;
-		o.Dst = f.Dst;
-		o.Mode = f.NewMode;
+		o := &op[i]
+		o.Verb = f.Verb
+		o.Src = f.Src
+		o.Dst = f.Dst
+		o.Mode = f.NewMode
 		if f.Diff != NoDiff || o.Verb != Edit {
 			// Clients assume o.Data == nil means no data diff.
 			// Start with a non-nil data.
-			var old []byte = make([]byte, 0);	// not nil
-			var err os.Error;
+			var old []byte = make([]byte, 0) // not nil
+			var err os.Error
 			if f.Src != "" {
-				old, err = readFile(f.Src);
+				old, err = readFile(f.Src)
 				if err != nil {
 					return nil, &os.PathError{string(f.Verb), f.Src, err}
 				}
 			}
-			o.Data, err = f.Diff.Apply(old);
+			o.Data, err = f.Diff.Apply(old)
 			if err != nil {
 				return nil, &os.PathError{string(f.Verb), f.Src, err}
 			}
 		}
 	}
 
-	return op, nil;
+	return op, nil
 }
diff --git a/src/pkg/patch/git.go b/src/pkg/patch/git.go
index 7fae216c4e..f366a3e058 100644
--- a/src/pkg/patch/git.go
+++ b/src/pkg/patch/git.go
@@ -5,13 +5,13 @@
 package patch
 
 import (
-	"bytes";
-	"compress/zlib";
-	"crypto/sha1";
-	"encoding/git85";
-	"fmt";
-	"io";
-	"os";
+	"bytes"
+	"compress/zlib"
+	"crypto/sha1"
+	"encoding/git85"
+	"fmt"
+	"io"
+	"os"
 )
 
 func gitSHA1(data []byte) []byte {
@@ -19,18 +19,18 @@ func gitSHA1(data []byte) []byte {
 		// special case: 0 length is all zeros sum
 		return make([]byte, 20)
 	}
-	h := sha1.New();
-	fmt.Fprintf(h, "blob %d\x00", len(data));
-	h.Write(data);
-	return h.Sum();
+	h := sha1.New()
+	fmt.Fprintf(h, "blob %d\x00", len(data))
+	h.Write(data)
+	return h.Sum()
 }
 
 // BUG(rsc): The Git binary delta format is not implemented, only Git binary literals.
 
 // GitBinaryLiteral represents a Git binary literal diff.
 type GitBinaryLiteral struct {
-	OldSHA1	[]byte;	// if non-empty, the SHA1 hash of the original
-	New	[]byte;	// the new contents
+	OldSHA1 []byte // if non-empty, the SHA1 hash of the original
+	New     []byte // the new contents
 }
 
 // Apply implements the Diff interface's Apply method.
@@ -38,7 +38,7 @@ func (d *GitBinaryLiteral) Apply(old []byte) ([]byte, os.Error) {
 	if sum := gitSHA1(old); !bytes.HasPrefix(sum, d.OldSHA1) {
 		return nil, ErrPatchFailure
 	}
-	return d.New, nil;
+	return d.New, nil
 }
 
 func unhex(c byte) uint8 {
@@ -50,60 +50,60 @@ func unhex(c byte) uint8 {
 	case 'A' <= c && c <= 'F':
 		return c - 'A' + 10
 	}
-	return 255;
+	return 255
 }
 
 func getHex(s []byte) (data []byte, rest []byte) {
-	n := 0;
+	n := 0
 	for n < len(s) && unhex(s[n]) != 255 {
 		n++
 	}
-	n &^= 1;	// Only take an even number of hex digits.
-	data = make([]byte, n/2);
+	n &^= 1 // Only take an even number of hex digits.
+	data = make([]byte, n/2)
 	for i := range data {
 		data[i] = unhex(s[2*i])<<4 | unhex(s[2*i+1])
 	}
-	rest = s[n:];
-	return;
+	rest = s[n:]
+	return
 }
 
 // ParseGitBinary parses raw as a Git binary patch.
 func ParseGitBinary(raw []byte) (Diff, os.Error) {
-	var oldSHA1, newSHA1 []byte;
-	var sawBinary bool;
+	var oldSHA1, newSHA1 []byte
+	var sawBinary bool
 
 	for {
-		var first []byte;
-		first, raw, _ = getLine(raw, 1);
-		first = bytes.TrimSpace(first);
+		var first []byte
+		first, raw, _ = getLine(raw, 1)
+		first = bytes.TrimSpace(first)
 		if s, ok := skip(first, "index "); ok {
-			oldSHA1, s = getHex(s);
+			oldSHA1, s = getHex(s)
 			if s, ok = skip(s, ".."); !ok {
 				continue
 			}
-			newSHA1, s = getHex(s);
-			continue;
+			newSHA1, s = getHex(s)
+			continue
 		}
 		if _, ok := skip(first, "GIT binary patch"); ok {
-			sawBinary = true;
-			continue;
+			sawBinary = true
+			continue
 		}
 		if n, _, ok := atoi(first, "literal ", 10); ok && sawBinary {
-			data := make([]byte, n);
-			d := git85.NewDecoder(bytes.NewBuffer(raw));
-			z, err := zlib.NewInflater(d);
+			data := make([]byte, n)
+			d := git85.NewDecoder(bytes.NewBuffer(raw))
+			z, err := zlib.NewInflater(d)
 			if err != nil {
 				return nil, err
 			}
-			defer z.Close();
+			defer z.Close()
 			if _, err = io.ReadFull(z, data); err != nil {
 				if err == os.EOF {
 					err = io.ErrUnexpectedEOF
 				}
-				return nil, err;
+				return nil, err
 			}
-			var buf [1]byte;
-			m, err := z.Read(&buf);
+			var buf [1]byte
+			m, err := z.Read(&buf)
 			if m != 0 || err != os.EOF {
 				return nil, os.NewError("Git binary literal longer than expected")
 			}
@@ -111,11 +111,11 @@ func ParseGitBinary(raw []byte) (Diff, os.Error) {
 			if sum := gitSHA1(data); !bytes.HasPrefix(sum, newSHA1) {
 				return nil, os.NewError("Git binary literal SHA1 mismatch")
 			}
-			return &GitBinaryLiteral{oldSHA1, data}, nil;
+			return &GitBinaryLiteral{oldSHA1, data}, nil
 		}
 		if !sawBinary {
 			return nil, os.NewError("unexpected Git patch header: " + string(first))
 		}
 	}
-	panic("unreachable");
+	panic("unreachable")
 }
diff --git a/src/pkg/patch/patch.go b/src/pkg/patch/patch.go
index d04b78865c..04ecd9d242 100644
--- a/src/pkg/patch/patch.go
+++ b/src/pkg/patch/patch.go
@@ -8,37 +8,37 @@
 package patch
 
 import (
-	"bytes";
-	"os";
-	"path";
-	"strings";
+	"bytes"
+	"os"
+	"path"
+	"strings"
 )
 
 // A Set represents a set of patches to be applied as a single atomic unit.
 // Patch sets are often preceded by a descriptive header.
 type Set struct {
-	Header	string;	// free-form text
-	File	[]*File;
+	Header string // free-form text
+	File   []*File
 }
 
 // A File represents a collection of changes to be made to a single file.
 type File struct {
-	Verb			Verb;
-	Src			string;	// source for Verb == Copy, Verb == Rename
-	Dst			string;
-	OldMode, NewMode	int;	// 0 indicates not used
-	Diff;				// changes to data; == NoDiff if operation does not edit file
+	Verb             Verb
+	Src              string // source for Verb == Copy, Verb == Rename
+	Dst              string
+	OldMode, NewMode int // 0 indicates not used
+	Diff                 // changes to data; == NoDiff if operation does not edit file
 }
 
 // A Verb is an action performed on a file.
 type Verb string
 
 const (
-	Add	Verb	= "add";
-	Copy	Verb	= "copy";
-	Delete	Verb	= "delete";
-	Edit	Verb	= "edit";
-	Rename	Verb	= "rename";
+	Add    Verb = "add"
+	Copy   Verb = "copy"
+	Delete Verb = "delete"
+	Edit   Verb = "edit"
+	Rename Verb = "rename"
 )
 
 // A Diff is any object that describes changes to transform
@@ -47,7 +47,7 @@ type Diff interface {
 	// Apply applies the changes listed in the diff
 	// to the string s, returning the new version of the string.
 	// Note that the string s need not be a text string.
-	Apply(old []byte) (new []byte, err os.Error);
+	Apply(old []byte) (new []byte, err os.Error)
 }
 
 // NoDiff is a no-op Diff implementation: it passes the
@@ -63,7 +63,7 @@ func (noDiffType) Apply(old []byte) ([]byte, os.Error) {
 // A SyntaxError represents a syntax error encountered while parsing a patch.
 type SyntaxError string
 
-func (e SyntaxError) String() string	{ return string(e) }
+func (e SyntaxError) String() string { return string(e) }
 
 var newline = []byte{'\n'}
 
@@ -82,37 +82,37 @@ func Parse(text []byte) (*Set, os.Error) {
 	//	diff [--git] a/file/path b/file/path.
 	//
 	// First look for Index: lines.  If none, fall back on diff lines.
-	text, files := sections(text, "Index: ");
+	text, files := sections(text, "Index: ")
 	if len(files) == 0 {
 		text, files = sections(text, "diff ")
 	}
 
-	set := &Set{string(text), make([]*File, len(files))};
+	set := &Set{string(text), make([]*File, len(files))}
 
 	// Parse file header and then
 	// parse files into patch chunks.
 	// Each chunk begins with @@.
 	for i, raw := range files {
-		p := new(File);
-		set.File[i] = p;
+		p := new(File)
+		set.File[i] = p
 
 		// First line of hdr is the Index: that
 		// begins the section.  After that is the file name.
-		s, raw, _ := getLine(raw, 1);
+		s, raw, _ := getLine(raw, 1)
 		if hasPrefix(s, "Index: ") {
-			p.Dst = string(bytes.TrimSpace(s[7:]));
-			goto HaveName;
+			p.Dst = string(bytes.TrimSpace(s[7:]))
+			goto HaveName
 		} else if hasPrefix(s, "diff ") {
-			str := string(bytes.TrimSpace(s));
-			i := strings.LastIndex(str, " b/");
+			str := string(bytes.TrimSpace(s))
+			i := strings.LastIndex(str, " b/")
 			if i >= 0 {
-				p.Dst = str[i+3:];
-				goto HaveName;
+				p.Dst = str[i+3:]
+				goto HaveName
 			}
 		}
-		return nil, SyntaxError("unexpected patch header line: " + string(s));
+		return nil, SyntaxError("unexpected patch header line: " + string(s))
 	HaveName:
-		p.Dst = path.Clean(p.Dst);
+		p.Dst = path.Clean(p.Dst)
 		if strings.HasPrefix(p.Dst, "../") || strings.HasPrefix(p.Dst, "/") {
 			return nil, SyntaxError("invalid path: " + p.Dst)
 		}
@@ -126,55 +126,55 @@ func Parse(text []byte) (*Set, os.Error) {
 		//	rename to %s
 		//	copy from %s		- file copied from other file
 		//	copy to %s
-		p.Verb = Edit;
+		p.Verb = Edit
 		for len(raw) > 0 {
-			oldraw := raw;
-			var l []byte;
-			l, raw, _ = getLine(raw, 1);
-			l = bytes.TrimSpace(l);
+			oldraw := raw
+			var l []byte
+			l, raw, _ = getLine(raw, 1)
+			l = bytes.TrimSpace(l)
 			if m, s, ok := atoi(l, "new file mode ", 8); ok && len(s) == 0 {
-				p.NewMode = m;
-				p.Verb = Add;
-				continue;
+				p.NewMode = m
+				p.Verb = Add
+				continue
 			}
 			if m, s, ok := atoi(l, "deleted file mode ", 8); ok && len(s) == 0 {
-				p.OldMode = m;
-				p.Verb = Delete;
-				p.Src = p.Dst;
-				p.Dst = "";
-				continue;
+				p.OldMode = m
+				p.Verb = Delete
+				p.Src = p.Dst
+				p.Dst = ""
+				continue
 			}
 			if m, s, ok := atoi(l, "old file mode ", 8); ok && len(s) == 0 {
 				// usually implies p.Verb = "rename" or "copy"
 				// but we'll get that from the rename or copy line.
-				p.OldMode = m;
-				continue;
+				p.OldMode = m
+				continue
 			}
 			if m, s, ok := atoi(l, "old mode ", 8); ok && len(s) == 0 {
-				p.OldMode = m;
-				continue;
+				p.OldMode = m
+				continue
 			}
 			if m, s, ok := atoi(l, "new mode ", 8); ok && len(s) == 0 {
-				p.NewMode = m;
-				continue;
+				p.NewMode = m
+				continue
 			}
 			if s, ok := skip(l, "rename from "); ok && len(s) > 0 {
-				p.Src = string(s);
-				p.Verb = Rename;
-				continue;
+				p.Src = string(s)
+				p.Verb = Rename
+				continue
 			}
 			if s, ok := skip(l, "rename to "); ok && len(s) > 0 {
-				p.Verb = Rename;
-				continue;
+				p.Verb = Rename
+				continue
 			}
 			if s, ok := skip(l, "copy from "); ok && len(s) > 0 {
-				p.Src = string(s);
-				p.Verb = Copy;
-				continue;
+				p.Src = string(s)
+				p.Verb = Copy
+				continue
 			}
 			if s, ok := skip(l, "copy to "); ok && len(s) > 0 {
-				p.Verb = Copy;
-				continue;
+				p.Verb = Copy
+				continue
 			}
 			if s, ok := skip(l, "Binary file "); ok && len(s) > 0 {
 				// Hg prints
@@ -200,22 +200,22 @@ func Parse(text []byte) (*Set, os.Error) {
 				continue
 			}
 			if hasPrefix(l, "@@ -") {
-				diff, err := ParseTextDiff(oldraw);
+				diff, err := ParseTextDiff(oldraw)
 				if err != nil {
 					return nil, err
 				}
-				p.Diff = diff;
-				break;
+				p.Diff = diff
+				break
 			}
 			if hasPrefix(l, "index ") || hasPrefix(l, "GIT binary patch") {
-				diff, err := ParseGitBinary(oldraw);
+				diff, err := ParseGitBinary(oldraw)
 				if err != nil {
 					return nil, err
 				}
-				p.Diff = diff;
-				break;
+				p.Diff = diff
+				break
 			}
-			return nil, SyntaxError("unexpected patch header line: " + string(l));
+			return nil, SyntaxError("unexpected patch header line: " + string(l))
 		}
 		if p.Diff == nil {
 			p.Diff = NoDiff
@@ -225,25 +225,25 @@ func Parse(text []byte) (*Set, os.Error) {
 		}
 	}
 
-	return set, nil;
+	return set, nil
 }
 
 // getLine returns the first n lines of data and the remainder.
 // If data has no newline, getLine returns data, nil, false
 func getLine(data []byte, n int) (first []byte, rest []byte, ok bool) {
-	rest = data;
-	ok = true;
+	rest = data
+	ok = true
 	for ; n > 0; n-- {
-		nl := bytes.Index(rest, newline);
+		nl := bytes.Index(rest, newline)
 		if nl < 0 {
-			rest = nil;
-			ok = false;
-			break;
+			rest = nil
+			ok = false
+			break
 		}
-		rest = rest[nl+1:];
+		rest = rest[nl+1:]
 	}
-	first = data[0 : len(data)-len(rest)];
-	return;
+	first = data[0 : len(data)-len(rest)]
+	return
 }
 
 // sections returns a collection of file sections,
@@ -251,34 +251,34 @@ func getLine(data []byte, n int) (first []byte, rest []byte, ok bool) {
 // text before the first instance of such a line is
 // returned separately.
 func sections(text []byte, prefix string) ([]byte, [][]byte) {
-	n := 0;
+	n := 0
 	for b := text; ; {
 		if hasPrefix(b, prefix) {
 			n++
 		}
-		nl := bytes.Index(b, newline);
+		nl := bytes.Index(b, newline)
 		if nl < 0 {
 			break
 		}
-		b = b[nl+1:];
+		b = b[nl+1:]
 	}
 
-	sect := make([][]byte, n+1);
-	n = 0;
+	sect := make([][]byte, n+1)
+	n = 0
 	for b := text; ; {
 		if hasPrefix(b, prefix) {
-			sect[n] = text[0 : len(text)-len(b)];
-			n++;
-			text = b;
+			sect[n] = text[0 : len(text)-len(b)]
+			n++
+			text = b
 		}
-		nl := bytes.Index(b, newline);
+		nl := bytes.Index(b, newline)
 		if nl < 0 {
-			sect[n] = text;
-			break;
+			sect[n] = text
+			break
 		}
-		b = b[nl+1:];
+		b = b[nl+1:]
 	}
-	return sect[0], sect[1:];
+	return sect[0], sect[1:]
 }
 
 // if s begins with the prefix t, skip returns
@@ -287,7 +287,7 @@ func skip(s []byte, t string) (ss []byte, ok bool) {
 	if len(s) < len(t) || string(s[0:len(t)]) != t {
 		return nil, false
 	}
-	return s[len(t):], true;
+	return s[len(t):], true
 }
 
 // if s begins with the prefix t and then is a sequence
@@ -298,22 +298,22 @@ func atoi(s []byte, t string, base int) (n int, ss []byte, ok bool) {
 	if s, ok = skip(s, t); !ok {
 		return
 	}
-	var i int;
+	var i int
 	for i = 0; i < len(s) && '0' <= s[i] && s[i] <= byte('0'+base-1); i++ {
 		n = n*base + int(s[i]-'0')
 	}
 	if i == 0 {
 		return
 	}
-	return n, s[i:], true;
+	return n, s[i:], true
 }
 
 // hasPrefix returns true if s begins with t.
 func hasPrefix(s []byte, t string) bool {
-	_, ok := skip(s, t);
-	return ok;
+	_, ok := skip(s, t)
+	return ok
 }
 
 // splitLines returns the result of splitting s into lines.
 // The \n on each line is preserved.
-func splitLines(s []byte) [][]byte	{ return bytes.SplitAfter(s, newline, 0) }
+func splitLines(s []byte) [][]byte { return bytes.SplitAfter(s, newline, 0) }
diff --git a/src/pkg/patch/patch_test.go b/src/pkg/patch/patch_test.go
index 046ffa8828..5b3d48315f 100644
--- a/src/pkg/patch/patch_test.go
+++ b/src/pkg/patch/patch_test.go
@@ -7,31 +7,31 @@ package patch
 // TODO(rsc): test Apply
 
 import (
-	"strings";
-	"testing";
+	"strings"
+	"testing"
 )
 
 type Test struct {
-	in	string;
-	out	string;
-	diff	string;
+	in   string
+	out  string
+	diff string
 }
 
 func TestFileApply(t *testing.T) {
 	for i, test := range tests {
-		set, err := Parse(strings.Bytes(test.diff));
+		set, err := Parse(strings.Bytes(test.diff))
 		if err != nil {
-			t.Errorf("#%d: Parse: %s", i, err);
-			continue;
+			t.Errorf("#%d: Parse: %s", i, err)
+			continue
 		}
 		if len(set.File) != 1 {
-			t.Errorf("#%d: Parse returned %d patches, want 1", i, len(set.File));
-			continue;
+			t.Errorf("#%d: Parse returned %d patches, want 1", i, len(set.File))
+			continue
 		}
-		new, err := set.File[0].Apply(strings.Bytes(test.in));
+		new, err := set.File[0].Apply(strings.Bytes(test.in))
 		if err != nil {
-			t.Errorf("#%d: Apply: %s", i, err);
-			continue;
+			t.Errorf("#%d: Apply: %s", i, err)
+			continue
 		}
 		if s := string(new); s != test.out {
 			t.Errorf("#%d:\n--- have\n%s--- want\n%s", i, s, test.out)
diff --git a/src/pkg/patch/textdiff.go b/src/pkg/patch/textdiff.go
index 8771f22d7d..c7e693fc66 100644
--- a/src/pkg/patch/textdiff.go
+++ b/src/pkg/patch/textdiff.go
@@ -1,8 +1,8 @@
 package patch
 
 import (
-	"bytes";
-	"os";
+	"bytes"
+	"os"
 )
 
 type TextDiff []TextChunk
@@ -11,25 +11,25 @@ type TextDiff []TextChunk
 // the text beginning at Line, which should be exactly Old,
 // is to be replaced with New.
 type TextChunk struct {
-	Line	int;
-	Old	[]byte;
-	New	[]byte;
+	Line int
+	Old  []byte
+	New  []byte
 }
 
 func ParseTextDiff(raw []byte) (TextDiff, os.Error) {
 	// Copy raw so it is safe to keep references to slices.
-	_, chunks := sections(raw, "@@ -");
-	delta := 0;
-	diff := make(TextDiff, len(chunks));
+	_, chunks := sections(raw, "@@ -")
+	delta := 0
+	diff := make(TextDiff, len(chunks))
 	for i, raw := range chunks {
-		c := &diff[i];
+		c := &diff[i]
 
 		// Parse start line: @@ -oldLine,oldCount +newLine,newCount @@ junk
-		chunk := splitLines(raw);
-		chunkHeader := chunk[0];
-		var ok bool;
-		var oldLine, oldCount, newLine, newCount int;
-		s := chunkHeader;
+		chunk := splitLines(raw)
+		chunkHeader := chunk[0]
+		var ok bool
+		var oldLine, oldCount, newLine, newCount int
+		s := chunkHeader
 		if oldLine, s, ok = atoi(s, "@@ -", 10); !ok {
 		ErrChunkHdr:
 			return nil, SyntaxError("unexpected chunk header line: " + string(chunkHeader))
@@ -61,16 +61,16 @@ func ParseTextDiff(raw []byte) (TextDiff, os.Error) {
 		}
 
 		// Count lines in text
-		var dropOldNL, dropNewNL bool;
-		var nold, nnew int;
-		var lastch byte;
-		chunk = chunk[1:];
+		var dropOldNL, dropNewNL bool
+		var nold, nnew int
+		var lastch byte
+		chunk = chunk[1:]
 		for _, l := range chunk {
 			if nold == oldCount && nnew == newCount && (len(l) == 0 || l[0] != '\\') {
 				if len(bytes.TrimSpace(l)) != 0 {
 					return nil, SyntaxError("too many chunk lines")
 				}
-				continue;
+				continue
 			}
 			if len(l) == 0 {
 				return nil, SyntaxError("empty chunk line")
@@ -81,8 +81,8 @@ func ParseTextDiff(raw []byte) (TextDiff, os.Error) {
 			case '-':
 				nold++
 			case ' ':
-				nnew++;
-				nold++;
+				nnew++
+				nold++
 			case '\\':
 				if _, ok := skip(l, "\\ No newline at end of file"); ok {
 					switch lastch {
@@ -91,18 +91,18 @@ func ParseTextDiff(raw []byte) (TextDiff, os.Error) {
 					case '+':
 						dropNewNL = true
 					case ' ':
-						dropOldNL = true;
-						dropNewNL = true;
+						dropOldNL = true
+						dropNewNL = true
 					default:
 						return nil, SyntaxError("message `\\ No newline at end of file' out of context")
 					}
-					break;
+					break
 				}
-				fallthrough;
+				fallthrough
 			default:
 				return nil, SyntaxError("unexpected chunk line: " + string(l))
 			}
-			lastch = l[0];
+			lastch = l[0]
 		}
 
 		// Does it match the header?
@@ -112,31 +112,31 @@ func ParseTextDiff(raw []byte) (TextDiff, os.Error) {
 		if oldLine+delta != newLine {
 			return nil, SyntaxError("chunk delta is out of sync with previous chunks")
 		}
-		delta += nnew - nold;
-		c.Line = oldLine;
+		delta += nnew - nold
+		c.Line = oldLine
 
-		var old, new bytes.Buffer;
-		nold = 0;
-		nnew = 0;
+		var old, new bytes.Buffer
+		nold = 0
+		nnew = 0
 		for _, l := range chunk {
 			if nold == oldCount && nnew == newCount {
 				break
 			}
-			ch, l := l[0], l[1:];
+			ch, l := l[0], l[1:]
 			if ch == '\\' {
 				continue
 			}
 			if ch != '+' {
-				old.Write(l);
-				nold++;
+				old.Write(l)
+				nold++
 			}
 			if ch != '-' {
-				new.Write(l);
-				nnew++;
+				new.Write(l)
+				nnew++
 			}
 		}
-		c.Old = old.Bytes();
-		c.New = new.Bytes();
+		c.Old = old.Bytes()
+		c.New = new.Bytes()
 		if dropOldNL {
 			c.Old = c.Old[0 : len(c.Old)-1]
 		}
@@ -144,7 +144,7 @@ func ParseTextDiff(raw []byte) (TextDiff, os.Error) {
 			c.New = c.New[0 : len(c.New)-1]
 		}
 	}
-	return diff, nil;
+	return diff, nil
 }
 
 var ErrPatchFailure = os.NewError("patch did not apply cleanly")
@@ -152,20 +152,20 @@ var ErrPatchFailure = os.NewError("patch did not apply cleanly")
 // Apply applies the changes listed in the diff
 // to the data, returning the new version.
 func (d TextDiff) Apply(data []byte) ([]byte, os.Error) {
-	var buf bytes.Buffer;
-	line := 1;
+	var buf bytes.Buffer
+	line := 1
 	for _, c := range d {
-		var ok bool;
-		var prefix []byte;
-		prefix, data, ok = getLine(data, c.Line-line);
+		var ok bool
+		var prefix []byte
+		prefix, data, ok = getLine(data, c.Line-line)
 		if !ok || !bytes.HasPrefix(data, c.Old) {
 			return nil, ErrPatchFailure
 		}
-		buf.Write(prefix);
-		data = data[len(c.Old):];
-		buf.Write(c.New);
-		line = c.Line + bytes.Count(c.Old, newline);
+		buf.Write(prefix)
+		data = data[len(c.Old):]
+		buf.Write(c.New)
+		line = c.Line + bytes.Count(c.Old, newline)
 	}
-	buf.Write(data);
-	return buf.Bytes(), nil;
+	buf.Write(data)
+	return buf.Bytes(), nil
 }
diff --git a/src/pkg/path/path.go b/src/pkg/path/path.go
index 59deb5ce91..e03f2ecf60 100644
--- a/src/pkg/path/path.go
+++ b/src/pkg/path/path.go
@@ -7,9 +7,9 @@
 package path
 
 import (
-	"io/ioutil";
-	"os";
-	"strings";
+	"io/ioutil"
+	"os"
+	"strings"
 )
 
 // Clean returns the shortest path name equivalent to path
@@ -34,16 +34,16 @@ func Clean(path string) string {
 		return "."
 	}
 
-	rooted := path[0] == '/';
-	n := len(path);
+	rooted := path[0] == '/'
+	n := len(path)
 
 	// Invariants:
 	//	reading from path; r is index of next byte to process.
 	//	writing to buf; w is index of next byte to write.
 	//	dotdot is index in buf where .. must stop, either because
 	//		it is the leading slash or it is a leading ../../.. prefix.
-	buf := strings.Bytes(path);
-	r, w, dotdot := 0, 0, 0;
+	buf := strings.Bytes(path)
+	r, w, dotdot := 0, 0, 0
 	if rooted {
 		r, w, dotdot = 1, 1, 1
 	}
@@ -58,48 +58,48 @@ func Clean(path string) string {
 			r++
 		case path[r] == '.' && path[r+1] == '.' && (r+2 == n || path[r+2] == '/'):
 			// .. element: remove to last /
-			r += 2;
+			r += 2
 			switch {
 			case w > dotdot:
 				// can backtrack
-				w--;
+				w--
 				for w > dotdot && buf[w] != '/' {
 					w--
 				}
 			case !rooted:
 				// cannot backtrack, but not rooted, so append .. element.
 				if w > 0 {
-					buf[w] = '/';
-					w++;
+					buf[w] = '/'
+					w++
 				}
-				buf[w] = '.';
-				w++;
-				buf[w] = '.';
-				w++;
-				dotdot = w;
+				buf[w] = '.'
+				w++
+				buf[w] = '.'
+				w++
+				dotdot = w
 			}
 		default:
 			// real path element.
 			// add slash if needed
 			if rooted && w != 1 || !rooted && w != 0 {
-				buf[w] = '/';
-				w++;
+				buf[w] = '/'
+				w++
 			}
 			// copy element
 			for ; r < n && path[r] != '/'; r++ {
-				buf[w] = path[r];
-				w++;
+				buf[w] = path[r]
+				w++
 			}
 		}
 	}
 
 	// Turn empty string into "."
 	if w == 0 {
-		buf[w] = '.';
-		w++;
+		buf[w] = '.'
+		w++
 	}
 
-	return string(buf[0:w]);
+	return string(buf[0:w])
 }
 
 // Split splits path immediately following the final slash,
@@ -112,7 +112,7 @@ func Split(path string) (dir, file string) {
 			return path[0 : i+1], path[i+1:]
 		}
 	}
-	return "", path;
+	return "", path
 }
 
 // Join joins dir and file into a single path, adding a separating
@@ -121,7 +121,7 @@ func Join(dir, file string) string {
 	if dir == "" {
 		return file
 	}
-	return Clean(dir + "/" + file);
+	return Clean(dir + "/" + file)
 }
 
 // Ext returns the file name extension used by path.
@@ -134,28 +134,28 @@ func Ext(path string) string {
 			return path[i:]
 		}
 	}
-	return "";
+	return ""
 }
 
 // Visitor methods are invoked for corresponding file tree entries
 // visited by Walk. The parameter path is the full path of d relative
 // to root.
 type Visitor interface {
-	VisitDir(path string, d *os.Dir) bool;
-	VisitFile(path string, d *os.Dir);
+	VisitDir(path string, d *os.Dir) bool
+	VisitFile(path string, d *os.Dir)
 }
 
 func walk(path string, d *os.Dir, v Visitor, errors chan<- os.Error) {
 	if !d.IsDirectory() {
-		v.VisitFile(path, d);
-		return;
+		v.VisitFile(path, d)
+		return
 	}
 
 	if !v.VisitDir(path, d) {
-		return	// skip directory entries
+		return // skip directory entries
 	}
 
-	list, err := ioutil.ReadDir(path);
+	list, err := ioutil.ReadDir(path)
 	if err != nil {
 		if errors != nil {
 			errors <- err
@@ -175,12 +175,12 @@ func walk(path string, d *os.Dir, v Visitor, errors chan<- os.Error) {
 // If errors != nil, Walk sends each directory read error
 // to the channel.  Otherwise Walk discards the error.
 func Walk(root string, v Visitor, errors chan<- os.Error) {
-	d, err := os.Lstat(root);
+	d, err := os.Lstat(root)
 	if err != nil {
 		if errors != nil {
 			errors <- err
 		}
-		return;	// can't progress
+		return // can't progress
 	}
-	walk(root, d, v, errors);
+	walk(root, d, v, errors)
 }
diff --git a/src/pkg/path/path_test.go b/src/pkg/path/path_test.go
index 74520fa315..296712e522 100644
--- a/src/pkg/path/path_test.go
+++ b/src/pkg/path/path_test.go
@@ -5,12 +5,12 @@
 package path
 
 import (
-	"os";
-	"testing";
+	"os"
+	"testing"
 )
 
 type CleanTest struct {
-	path, clean string;
+	path, clean string
 }
 
 var cleantests = []CleanTest{
@@ -72,7 +72,7 @@ func TestClean(t *testing.T) {
 }
 
 type SplitTest struct {
-	path, dir, file string;
+	path, dir, file string
 }
 
 var splittests = []SplitTest{
@@ -92,7 +92,7 @@ func TestSplit(t *testing.T) {
 }
 
 type JoinTest struct {
-	dir, file, path string;
+	dir, file, path string
 }
 
 var jointests = []JoinTest{
@@ -114,7 +114,7 @@ func TestJoin(t *testing.T) {
 }
 
 type ExtTest struct {
-	path, ext string;
+	path, ext string
 }
 
 var exttests = []ExtTest{
@@ -134,9 +134,9 @@ func TestExt(t *testing.T) {
 }
 
 type Node struct {
-	name	string;
-	entries	[]*Node;	// nil if the entry is a file
-	mark	int;
+	name    string
+	entries []*Node // nil if the entry is a file
+	mark    int
 }
 
 var tree = &Node{
@@ -166,7 +166,7 @@ var tree = &Node{
 }
 
 func walkTree(n *Node, path string, f func(path string, n *Node)) {
-	f(path, n);
+	f(path, n)
 	for _, e := range n.entries {
 		walkTree(e, Join(path, e.name), f)
 	}
@@ -175,25 +175,25 @@ func walkTree(n *Node, path string, f func(path string, n *Node)) {
 func makeTree(t *testing.T) {
 	walkTree(tree, tree.name, func(path string, n *Node) {
 		if n.entries == nil {
-			fd, err := os.Open(path, os.O_CREAT, 0660);
+			fd, err := os.Open(path, os.O_CREAT, 0660)
 			if err != nil {
 				t.Errorf("makeTree: %v", err)
 			}
-			fd.Close();
+			fd.Close()
 		} else {
 			os.Mkdir(path, 0770)
 		}
 	})
 }
 
-func markTree(n *Node)	{ walkTree(n, "", func(path string, n *Node) { n.mark++ }) }
+func markTree(n *Node) { walkTree(n, "", func(path string, n *Node) { n.mark++ }) }
 
 func checkMarks(t *testing.T) {
 	walkTree(tree, tree.name, func(path string, n *Node) {
 		if n.mark != 1 {
 			t.Errorf("node %s mark = %d; expected 1", path, n.mark)
 		}
-		n.mark = 0;
+		n.mark = 0
 	})
 }
 
@@ -209,8 +209,8 @@ func mark(name string) {
 type TestVisitor struct{}
 
 func (v *TestVisitor) VisitDir(path string, d *os.Dir) bool {
-	mark(d.Name);
-	return true;
+	mark(d.Name)
+	return true
 }
 
 func (v *TestVisitor) VisitFile(path string, d *os.Dir) {
@@ -218,52 +218,52 @@ func (v *TestVisitor) VisitFile(path string, d *os.Dir) {
 }
 
 func TestWalk(t *testing.T) {
-	makeTree(t);
+	makeTree(t)
 
 	// 1) ignore error handling, expect none
-	v := &TestVisitor{};
-	Walk(tree.name, v, nil);
-	checkMarks(t);
+	v := &TestVisitor{}
+	Walk(tree.name, v, nil)
+	checkMarks(t)
 
 	// 2) handle errors, expect none
-	errors := make(chan os.Error, 64);
-	Walk(tree.name, v, errors);
+	errors := make(chan os.Error, 64)
+	Walk(tree.name, v, errors)
 	if err, ok := <-errors; ok {
 		t.Errorf("no error expected, found: s", err)
 	}
-	checkMarks(t);
+	checkMarks(t)
 
 	if os.Getuid() != 0 {
 		// introduce 2 errors: chmod top-level directories to 0
-		os.Chmod(Join(tree.name, tree.entries[1].name), 0);
-		os.Chmod(Join(tree.name, tree.entries[3].name), 0);
+		os.Chmod(Join(tree.name, tree.entries[1].name), 0)
+		os.Chmod(Join(tree.name, tree.entries[3].name), 0)
 		// mark respective subtrees manually
-		markTree(tree.entries[1]);
-		markTree(tree.entries[3]);
+		markTree(tree.entries[1])
+		markTree(tree.entries[3])
 		// correct double-marking of directory itself
-		tree.entries[1].mark--;
-		tree.entries[3].mark--;
+		tree.entries[1].mark--
+		tree.entries[3].mark--
 
 		// 3) handle errors, expect two
-		errors = make(chan os.Error, 64);
-		os.Chmod(Join(tree.name, tree.entries[1].name), 0);
-		Walk(tree.name, v, errors);
+		errors = make(chan os.Error, 64)
+		os.Chmod(Join(tree.name, tree.entries[1].name), 0)
+		Walk(tree.name, v, errors)
 		for i := 1; i <= 2; i++ {
 			if _, ok := <-errors; !ok {
-				t.Errorf("%d. error expected, none found", i);
-				break;
+				t.Errorf("%d. error expected, none found", i)
+				break
 			}
 		}
 		if err, ok := <-errors; ok {
 			t.Errorf("only two errors expected, found 3rd: %v", err)
 		}
 		// the inaccessible subtrees were marked manually
-		checkMarks(t);
+		checkMarks(t)
 	}
 
 	// cleanup
-	os.Chmod(Join(tree.name, tree.entries[1].name), 0770);
-	os.Chmod(Join(tree.name, tree.entries[3].name), 0770);
+	os.Chmod(Join(tree.name, tree.entries[1].name), 0770)
+	os.Chmod(Join(tree.name, tree.entries[3].name), 0770)
 	if err := os.RemoveAll(tree.name); err != nil {
 		t.Errorf("removeTree: %v", err)
 	}
diff --git a/src/pkg/rand/exp.go b/src/pkg/rand/exp.go
index aaa3cc7b04..85da495219 100644
--- a/src/pkg/rand/exp.go
+++ b/src/pkg/rand/exp.go
@@ -5,7 +5,7 @@
 package rand
 
 import (
-	"math";
+	"math"
 )
 
 /*
@@ -17,7 +17,7 @@ import (
  */
 
 const (
-	re = 7.69711747013104972;
+	re = 7.69711747013104972
 )
 
 // ExpFloat64 returns an exponentially distributed float64 in the range
@@ -30,9 +30,9 @@ const (
 //
 func (r *Rand) ExpFloat64() float64 {
 	for {
-		j := r.Uint32();
-		i := j & 0xFF;
-		x := float64(j) * float64(we[i]);
+		j := r.Uint32()
+		i := j & 0xFF
+		x := float64(j) * float64(we[i])
 		if j < ke[i] {
 			return x
 		}
@@ -43,7 +43,7 @@ func (r *Rand) ExpFloat64() float64 {
 			return x
 		}
 	}
-	panic("unreachable");
+	panic("unreachable")
 }
 
 var ke = [256]uint32{
diff --git a/src/pkg/rand/normal.go b/src/pkg/rand/normal.go
index 25769c7bf3..9ab46db9f5 100644
--- a/src/pkg/rand/normal.go
+++ b/src/pkg/rand/normal.go
@@ -5,7 +5,7 @@
 package rand
 
 import (
-	"math";
+	"math"
 )
 
 /*
@@ -17,14 +17,14 @@ import (
  */
 
 const (
-	rn = 3.442619855899;
+	rn = 3.442619855899
 )
 
 func absInt32(i int32) uint32 {
 	if i < 0 {
 		return uint32(-i)
 	}
-	return uint32(i);
+	return uint32(i)
 }
 
 // NormFloat64 returns a normally distributed float64 in the range
@@ -37,9 +37,9 @@ func absInt32(i int32) uint32 {
 //
 func (r *Rand) NormFloat64() float64 {
 	for {
-		j := int32(r.Uint32());	// Possibly negative
-		i := j & 0x7F;
-		x := float64(j) * float64(wn[i]);
+		j := int32(r.Uint32()) // Possibly negative
+		i := j & 0x7F
+		x := float64(j) * float64(wn[i])
 		if absInt32(j) < kn[i] {
 			// This case should be hit better than 99% of the time.
 			return x
@@ -48,8 +48,8 @@ func (r *Rand) NormFloat64() float64 {
 		if i == 0 {
 			// This extra work is only required for the base strip.
 			for {
-				x = -math.Log(r.Float64()) * (1.0 / rn);
-				y := -math.Log(r.Float64());
+				x = -math.Log(r.Float64()) * (1.0 / rn)
+				y := -math.Log(r.Float64())
 				if y+y >= x*x {
 					break
 				}
@@ -57,13 +57,13 @@ func (r *Rand) NormFloat64() float64 {
 			if j > 0 {
 				return rn + x
 			}
-			return -rn - x;
+			return -rn - x
 		}
 		if fn[i]+float32(r.Float64())*(fn[i-1]-fn[i]) < float32(math.Exp(-.5*x*x)) {
 			return x
 		}
 	}
-	panic("unreachable");
+	panic("unreachable")
 }
 
 var kn = [128]uint32{
diff --git a/src/pkg/rand/rand.go b/src/pkg/rand/rand.go
index 0063e40594..0d7eaa79a1 100644
--- a/src/pkg/rand/rand.go
+++ b/src/pkg/rand/rand.go
@@ -10,42 +10,42 @@ import "sync"
 // A Source represents a source of uniformly-distributed
 // pseudo-random int64 values in the range [0, 1<<63).
 type Source interface {
-	Int63() int64;
-	Seed(seed int64);
+	Int63() int64
+	Seed(seed int64)
 }
 
 // NewSource returns a new pseudo-random Source seeded with the given value.
 func NewSource(seed int64) Source {
-	var rng rngSource;
-	rng.Seed(seed);
-	return &rng;
+	var rng rngSource
+	rng.Seed(seed)
+	return &rng
 }
 
 // A Rand is a source of random numbers.
 type Rand struct {
-	src Source;
+	src Source
 }
 
 // New returns a new Rand that uses random values from src
 // to generate other random values.
-func New(src Source) *Rand	{ return &Rand{src} }
+func New(src Source) *Rand { return &Rand{src} }
 
 // Seed uses the provided seed value to initialize the generator to a deterministic state.
-func (r *Rand) Seed(seed int64)	{ r.src.Seed(seed) }
+func (r *Rand) Seed(seed int64) { r.src.Seed(seed) }
 
 // Int63 returns a non-negative pseudo-random 63-bit integer as an int64.
-func (r *Rand) Int63() int64	{ return r.src.Int63() }
+func (r *Rand) Int63() int64 { return r.src.Int63() }
 
 // Uint32 returns a pseudo-random 32-bit value as a uint32.
-func (r *Rand) Uint32() uint32	{ return uint32(r.Int63() >> 31) }
+func (r *Rand) Uint32() uint32 { return uint32(r.Int63() >> 31) }
 
 // Int31 returns a non-negative pseudo-random 31-bit integer as an int32.
-func (r *Rand) Int31() int32	{ return int32(r.Int63() >> 32) }
+func (r *Rand) Int31() int32 { return int32(r.Int63() >> 32) }
 
 // Int returns a non-negative pseudo-random int.
 func (r *Rand) Int() int {
-	u := uint(r.Int63());
-	return int(u << 1 >> 1);	// clear sign bit if int == int32
+	u := uint(r.Int63())
+	return int(u << 1 >> 1) // clear sign bit if int == int32
 }
 
 // Int63n returns, as an int64, a non-negative pseudo-random number in [0,n).
@@ -53,40 +53,40 @@ func (r *Rand) Int63n(n int64) int64 {
 	if n <= 0 {
 		return 0
 	}
-	max := int64((1 << 63) - 1 - (1<<63)%uint64(n));
-	v := r.Int63();
+	max := int64((1 << 63) - 1 - (1<<63)%uint64(n))
+	v := r.Int63()
 	for v > max {
 		v = r.Int63()
 	}
-	return v % n;
+	return v % n
 }
 
 // Int31n returns, as an int32, a non-negative pseudo-random number in [0,n).
-func (r *Rand) Int31n(n int32) int32	{ return int32(r.Int63n(int64(n))) }
+func (r *Rand) Int31n(n int32) int32 { return int32(r.Int63n(int64(n))) }
 
 // Intn returns, as an int, a non-negative pseudo-random number in [0,n).
-func (r *Rand) Intn(n int) int	{ return int(r.Int63n(int64(n))) }
+func (r *Rand) Intn(n int) int { return int(r.Int63n(int64(n))) }
 
 // Float64 returns, as a float64, a pseudo-random number in [0.0,1.0).
-func (r *Rand) Float64() float64	{ return float64(r.Int63()) / (1 << 63) }
+func (r *Rand) Float64() float64 { return float64(r.Int63()) / (1 << 63) }
 
 // Float32 returns, as a float32, a pseudo-random number in [0.0,1.0).
-func (r *Rand) Float32() float32	{ return float32(r.Float64()) }
+func (r *Rand) Float32() float32 { return float32(r.Float64()) }
 
 // Float returns, as a float, a pseudo-random number in [0.0,1.0).
-func (r *Rand) Float() float	{ return float(r.Float64()) }
+func (r *Rand) Float() float { return float(r.Float64()) }
 
 // Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n).
 func (r *Rand) Perm(n int) []int {
-	m := make([]int, n);
+	m := make([]int, n)
 	for i := 0; i < n; i++ {
 		m[i] = i
 	}
 	for i := 0; i < n; i++ {
-		j := r.Intn(i + 1);
-		m[i], m[j] = m[j], m[i];
+		j := r.Intn(i + 1)
+		m[i], m[j] = m[j], m[i]
 	}
-	return m;
+	return m
 }
 
 /*
@@ -96,40 +96,40 @@ func (r *Rand) Perm(n int) []int {
 var globalRand = New(&lockedSource{src: NewSource(1)})
 
 // Seed uses the provided seed value to initialize the generator to a deterministic state.
-func Seed(seed int64)	{ globalRand.Seed(seed) }
+func Seed(seed int64) { globalRand.Seed(seed) }
 
 // Int63 returns a non-negative pseudo-random 63-bit integer as an int64.
-func Int63() int64	{ return globalRand.Int63() }
+func Int63() int64 { return globalRand.Int63() }
 
 // Uint32 returns a pseudo-random 32-bit value as a uint32.
-func Uint32() uint32	{ return globalRand.Uint32() }
+func Uint32() uint32 { return globalRand.Uint32() }
 
 // Int31 returns a non-negative pseudo-random 31-bit integer as an int32.
-func Int31() int32	{ return globalRand.Int31() }
+func Int31() int32 { return globalRand.Int31() }
 
 // Int returns a non-negative pseudo-random int.
-func Int() int	{ return globalRand.Int() }
+func Int() int { return globalRand.Int() }
 
 // Int63n returns, as an int64, a non-negative pseudo-random number in [0,n).
-func Int63n(n int64) int64	{ return globalRand.Int63n(n) }
+func Int63n(n int64) int64 { return globalRand.Int63n(n) }
 
 // Int31n returns, as an int32, a non-negative pseudo-random number in [0,n).
-func Int31n(n int32) int32	{ return globalRand.Int31n(n) }
+func Int31n(n int32) int32 { return globalRand.Int31n(n) }
 
 // Intn returns, as an int, a non-negative pseudo-random number in [0,n).
-func Intn(n int) int	{ return globalRand.Intn(n) }
+func Intn(n int) int { return globalRand.Intn(n) }
 
 // Float64 returns, as a float64, a pseudo-random number in [0.0,1.0).
-func Float64() float64	{ return globalRand.Float64() }
+func Float64() float64 { return globalRand.Float64() }
 
 // Float32 returns, as a float32, a pseudo-random number in [0.0,1.0).
-func Float32() float32	{ return globalRand.Float32() }
+func Float32() float32 { return globalRand.Float32() }
 
 // Float returns, as a float, a pseudo-random number in [0.0,1.0).
-func Float() float	{ return globalRand.Float() }
+func Float() float { return globalRand.Float() }
 
 // Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n).
-func Perm(n int) []int	{ return globalRand.Perm(n) }
+func Perm(n int) []int { return globalRand.Perm(n) }
 
 // NormFloat64 returns a normally distributed float64 in the range
 // [-math.MaxFloat64, +math.MaxFloat64] with
@@ -139,7 +139,7 @@ func Perm(n int) []int	{ return globalRand.Perm(n) }
 //
 //  sample = NormFloat64() * desiredStdDev + desiredMean
 //
-func NormFloat64() float64	{ return globalRand.NormFloat64() }
+func NormFloat64() float64 { return globalRand.NormFloat64() }
 
 // ExpFloat64 returns an exponentially distributed float64 in the range
 // (0, +math.MaxFloat64] with an exponential distribution whose rate parameter
@@ -149,22 +149,22 @@ func NormFloat64() float64	{ return globalRand.NormFloat64() }
 //
 //  sample = ExpFloat64() / desiredRateParameter
 //
-func ExpFloat64() float64	{ return globalRand.ExpFloat64() }
+func ExpFloat64() float64 { return globalRand.ExpFloat64() }
 
 type lockedSource struct {
-	lk	sync.Mutex;
-	src	Source;
+	lk  sync.Mutex
+	src Source
 }
 
 func (r *lockedSource) Int63() (n int64) {
-	r.lk.Lock();
-	n = r.src.Int63();
-	r.lk.Unlock();
-	return;
+	r.lk.Lock()
+	n = r.src.Int63()
+	r.lk.Unlock()
+	return
 }
 
 func (r *lockedSource) Seed(seed int64) {
-	r.lk.Lock();
-	r.src.Seed(seed);
-	r.lk.Unlock();
+	r.lk.Lock()
+	r.src.Seed(seed)
+	r.lk.Unlock()
 }
diff --git a/src/pkg/rand/rand_test.go b/src/pkg/rand/rand_test.go
index e0d1da4bb7..b90c69db7f 100644
--- a/src/pkg/rand/rand_test.go
+++ b/src/pkg/rand/rand_test.go
@@ -5,36 +5,36 @@
 package rand
 
 import (
-	"math";
-	"fmt";
-	"os";
-	"testing";
+	"math"
+	"fmt"
+	"os"
+	"testing"
 )
 
 const (
-	numTestSamples = 10000;
+	numTestSamples = 10000
 )
 
 type statsResults struct {
-	mean		float64;
-	stddev		float64;
-	closeEnough	float64;
-	maxError	float64;
+	mean        float64
+	stddev      float64
+	closeEnough float64
+	maxError    float64
 }
 
 func max(a, b float64) float64 {
 	if a > b {
 		return a
 	}
-	return b;
+	return b
 }
 
 func nearEqual(a, b, closeEnough, maxError float64) bool {
-	absDiff := math.Fabs(a - b);
-	if absDiff < closeEnough {	// Necessary when one value is zero and one value is close to zero.
+	absDiff := math.Fabs(a - b)
+	if absDiff < closeEnough { // Necessary when one value is zero and one value is close to zero.
 		return true
 	}
-	return absDiff/max(math.Fabs(a), math.Fabs(b)) < maxError;
+	return absDiff/max(math.Fabs(a), math.Fabs(b)) < maxError
 }
 
 var testSeeds = []int64{1, 1754801282, 1698661970, 1550503961}
@@ -43,52 +43,52 @@ var testSeeds = []int64{1, 1754801282, 1698661970, 1550503961}
 // two statsResults are similar.
 func (this *statsResults) checkSimilarDistribution(expected *statsResults) os.Error {
 	if !nearEqual(this.mean, expected.mean, expected.closeEnough, expected.maxError) {
-		s := fmt.Sprintf("mean %v != %v (allowed error %v, %v)", this.mean, expected.mean, expected.closeEnough, expected.maxError);
-		fmt.Println(s);
-		return os.ErrorString(s);
+		s := fmt.Sprintf("mean %v != %v (allowed error %v, %v)", this.mean, expected.mean, expected.closeEnough, expected.maxError)
+		fmt.Println(s)
+		return os.ErrorString(s)
 	}
 	if !nearEqual(this.stddev, expected.stddev, 0, expected.maxError) {
-		s := fmt.Sprintf("stddev %v != %v (allowed error %v, %v)", this.stddev, expected.stddev, expected.closeEnough, expected.maxError);
-		fmt.Println(s);
-		return os.ErrorString(s);
+		s := fmt.Sprintf("stddev %v != %v (allowed error %v, %v)", this.stddev, expected.stddev, expected.closeEnough, expected.maxError)
+		fmt.Println(s)
+		return os.ErrorString(s)
 	}
-	return nil;
+	return nil
 }
 
 func getStatsResults(samples []float64) *statsResults {
-	res := new(statsResults);
-	var sum float64;
+	res := new(statsResults)
+	var sum float64
 	for i := range samples {
 		sum += samples[i]
 	}
-	res.mean = sum / float64(len(samples));
-	var devsum float64;
+	res.mean = sum / float64(len(samples))
+	var devsum float64
 	for i := range samples {
 		devsum += math.Pow(samples[i]-res.mean, 2)
 	}
-	res.stddev = math.Sqrt(devsum / float64(len(samples)));
-	return res;
+	res.stddev = math.Sqrt(devsum / float64(len(samples)))
+	return res
 }
 
 func checkSampleDistribution(t *testing.T, samples []float64, expected *statsResults) {
-	actual := getStatsResults(samples);
-	err := actual.checkSimilarDistribution(expected);
+	actual := getStatsResults(samples)
+	err := actual.checkSimilarDistribution(expected)
 	if err != nil {
 		t.Errorf(err.String())
 	}
 }
 
 func checkSampleSliceDistributions(t *testing.T, samples []float64, nslices int, expected *statsResults) {
-	chunk := len(samples) / nslices;
+	chunk := len(samples) / nslices
 	for i := 0; i < nslices; i++ {
-		low := i * chunk;
-		var high int;
+		low := i * chunk
+		var high int
 		if i == nslices-1 {
 			high = len(samples) - 1
 		} else {
 			high = (i + 1) * chunk
 		}
-		checkSampleDistribution(t, samples[low:high], expected);
+		checkSampleDistribution(t, samples[low:high], expected)
 	}
 }
 
@@ -97,29 +97,29 @@ func checkSampleSliceDistributions(t *testing.T, samples []float64, nslices int,
 //
 
 func generateNormalSamples(nsamples int, mean, stddev float64, seed int64) []float64 {
-	r := New(NewSource(seed));
-	samples := make([]float64, nsamples);
+	r := New(NewSource(seed))
+	samples := make([]float64, nsamples)
 	for i := range samples {
 		samples[i] = r.NormFloat64()*stddev + mean
 	}
-	return samples;
+	return samples
 }
 
 func testNormalDistribution(t *testing.T, nsamples int, mean, stddev float64, seed int64) {
 	//fmt.Printf("testing nsamples=%v mean=%v stddev=%v seed=%v\n", nsamples, mean, stddev, seed);
 
-	samples := generateNormalSamples(nsamples, mean, stddev, seed);
-	errorScale := max(1.0, stddev);	// Error scales with stddev
-	expected := &statsResults{mean, stddev, 0.10 * errorScale, 0.08 * errorScale};
+	samples := generateNormalSamples(nsamples, mean, stddev, seed)
+	errorScale := max(1.0, stddev) // Error scales with stddev
+	expected := &statsResults{mean, stddev, 0.10 * errorScale, 0.08 * errorScale}
 
 	// Make sure that the entire set matches the expected distribution.
-	checkSampleDistribution(t, samples, expected);
+	checkSampleDistribution(t, samples, expected)
 
 	// Make sure that each half of the set matches the expected distribution.
-	checkSampleSliceDistributions(t, samples, 2, expected);
+	checkSampleSliceDistributions(t, samples, 2, expected)
 
 	// Make sure that each 7th of the set matches the expected distribution.
-	checkSampleSliceDistributions(t, samples, 7, expected);
+	checkSampleSliceDistributions(t, samples, 7, expected)
 }
 
 // Actual tests
@@ -145,32 +145,32 @@ func TestNonStandardNormalValues(t *testing.T) {
 //
 
 func generateExponentialSamples(nsamples int, rate float64, seed int64) []float64 {
-	r := New(NewSource(seed));
-	samples := make([]float64, nsamples);
+	r := New(NewSource(seed))
+	samples := make([]float64, nsamples)
 	for i := range samples {
 		samples[i] = r.ExpFloat64() / rate
 	}
-	return samples;
+	return samples
 }
 
 func testExponentialDistribution(t *testing.T, nsamples int, rate float64, seed int64) {
 	//fmt.Printf("testing nsamples=%v rate=%v seed=%v\n", nsamples, rate, seed);
 
-	mean := 1 / rate;
-	stddev := mean;
+	mean := 1 / rate
+	stddev := mean
 
-	samples := generateExponentialSamples(nsamples, rate, seed);
-	errorScale := max(1.0, 1/rate);	// Error scales with the inverse of the rate
-	expected := &statsResults{mean, stddev, 0.10 * errorScale, 0.20 * errorScale};
+	samples := generateExponentialSamples(nsamples, rate, seed)
+	errorScale := max(1.0, 1/rate) // Error scales with the inverse of the rate
+	expected := &statsResults{mean, stddev, 0.10 * errorScale, 0.20 * errorScale}
 
 	// Make sure that the entire set matches the expected distribution.
-	checkSampleDistribution(t, samples, expected);
+	checkSampleDistribution(t, samples, expected)
 
 	// Make sure that each half of the set matches the expected distribution.
-	checkSampleSliceDistributions(t, samples, 2, expected);
+	checkSampleSliceDistributions(t, samples, 2, expected)
 
 	// Make sure that each 7th of the set matches the expected distribution.
-	checkSampleSliceDistributions(t, samples, 7, expected);
+	checkSampleSliceDistributions(t, samples, 7, expected)
 }
 
 // Actual tests
@@ -194,61 +194,61 @@ func TestNonStandardExponentialValues(t *testing.T) {
 //
 
 func initNorm() (testKn []uint32, testWn, testFn []float32) {
-	const m1 = 1 << 31;
+	const m1 = 1 << 31
 	var (
-		dn	float64	= rn;
-		tn		= dn;
-		vn	float64	= 9.91256303526217e-3;
+		dn float64 = rn
+		tn         = dn
+		vn float64 = 9.91256303526217e-3
 	)
 
-	testKn = make([]uint32, 128);
-	testWn = make([]float32, 128);
-	testFn = make([]float32, 128);
-
-	q := vn / math.Exp(-0.5*dn*dn);
-	testKn[0] = uint32((dn / q) * m1);
-	testKn[1] = 0;
-	testWn[0] = float32(q / m1);
-	testWn[127] = float32(dn / m1);
-	testFn[0] = 1.0;
-	testFn[127] = float32(math.Exp(-0.5 * dn * dn));
+	testKn = make([]uint32, 128)
+	testWn = make([]float32, 128)
+	testFn = make([]float32, 128)
+
+	q := vn / math.Exp(-0.5*dn*dn)
+	testKn[0] = uint32((dn / q) * m1)
+	testKn[1] = 0
+	testWn[0] = float32(q / m1)
+	testWn[127] = float32(dn / m1)
+	testFn[0] = 1.0
+	testFn[127] = float32(math.Exp(-0.5 * dn * dn))
 	for i := 126; i >= 1; i-- {
-		dn = math.Sqrt(-2.0 * math.Log(vn/dn+math.Exp(-0.5*dn*dn)));
-		testKn[i+1] = uint32((dn / tn) * m1);
-		tn = dn;
-		testFn[i] = float32(math.Exp(-0.5 * dn * dn));
-		testWn[i] = float32(dn / m1);
+		dn = math.Sqrt(-2.0 * math.Log(vn/dn+math.Exp(-0.5*dn*dn)))
+		testKn[i+1] = uint32((dn / tn) * m1)
+		tn = dn
+		testFn[i] = float32(math.Exp(-0.5 * dn * dn))
+		testWn[i] = float32(dn / m1)
 	}
-	return;
+	return
 }
 
 func initExp() (testKe []uint32, testWe, testFe []float32) {
-	const m2 = 1 << 32;
+	const m2 = 1 << 32
 	var (
-		de	float64	= re;
-		te		= de;
-		ve	float64	= 3.9496598225815571993e-3;
+		de float64 = re
+		te         = de
+		ve float64 = 3.9496598225815571993e-3
 	)
 
-	testKe = make([]uint32, 256);
-	testWe = make([]float32, 256);
-	testFe = make([]float32, 256);
-
-	q := ve / math.Exp(-de);
-	testKe[0] = uint32((de / q) * m2);
-	testKe[1] = 0;
-	testWe[0] = float32(q / m2);
-	testWe[255] = float32(de / m2);
-	testFe[0] = 1.0;
-	testFe[255] = float32(math.Exp(-de));
+	testKe = make([]uint32, 256)
+	testWe = make([]float32, 256)
+	testFe = make([]float32, 256)
+
+	q := ve / math.Exp(-de)
+	testKe[0] = uint32((de / q) * m2)
+	testKe[1] = 0
+	testWe[0] = float32(q / m2)
+	testWe[255] = float32(de / m2)
+	testFe[0] = 1.0
+	testFe[255] = float32(math.Exp(-de))
 	for i := 254; i >= 1; i-- {
-		de = -math.Log(ve/de + math.Exp(-de));
-		testKe[i+1] = uint32((de / te) * m2);
-		te = de;
-		testFe[i] = float32(math.Exp(-de));
-		testWe[i] = float32(de / m2);
+		de = -math.Log(ve/de + math.Exp(-de))
+		testKe[i+1] = uint32((de / te) * m2)
+		te = de
+		testFe[i] = float32(math.Exp(-de))
+		testWe[i] = float32(de / m2)
 	}
-	return;
+	return
 }
 
 // compareUint32Slices returns the first index where the two slices
@@ -259,14 +259,14 @@ func compareUint32Slices(s1, s2 []uint32) int {
 		if len(s1) > len(s2) {
 			return len(s2) + 1
 		}
-		return len(s1) + 1;
+		return len(s1) + 1
 	}
 	for i := range s1 {
 		if s1[i] != s2[i] {
 			return i
 		}
 	}
-	return -1;
+	return -1
 }
 
 // compareFloat32Slices returns the first index where the two slices
@@ -277,18 +277,18 @@ func compareFloat32Slices(s1, s2 []float32) int {
 		if len(s1) > len(s2) {
 			return len(s2) + 1
 		}
-		return len(s1) + 1;
+		return len(s1) + 1
 	}
 	for i := range s1 {
 		if !nearEqual(float64(s1[i]), float64(s2[i]), 0, 1e-7) {
 			return i
 		}
 	}
-	return -1;
+	return -1
 }
 
 func TestNormTables(t *testing.T) {
-	testKn, testWn, testFn := initNorm();
+	testKn, testWn, testFn := initNorm()
 	if i := compareUint32Slices(kn[0:], testKn); i >= 0 {
 		t.Errorf("kn disagrees at index %v; %v != %v\n", i, kn[i], testKn[i])
 	}
@@ -301,7 +301,7 @@ func TestNormTables(t *testing.T) {
 }
 
 func TestExpTables(t *testing.T) {
-	testKe, testWe, testFe := initExp();
+	testKe, testWe, testFe := initExp()
 	if i := compareUint32Slices(ke[0:], testKe); i >= 0 {
 		t.Errorf("ke disagrees at index %v; %v != %v\n", i, ke[i], testKe[i])
 	}
@@ -322,7 +322,7 @@ func BenchmarkInt63Threadsafe(b *testing.B) {
 }
 
 func BenchmarkInt63Unthreadsafe(b *testing.B) {
-	r := New(NewSource(1));
+	r := New(NewSource(1))
 	for n := b.N; n > 0; n-- {
 		r.Int63()
 	}
diff --git a/src/pkg/rand/rng.go b/src/pkg/rand/rng.go
index a8f7a18b1f..947c49f0f2 100644
--- a/src/pkg/rand/rng.go
+++ b/src/pkg/rand/rng.go
@@ -12,14 +12,14 @@ package rand
  */
 
 const (
-	_LEN	= 607;
-	_TAP	= 273;
-	_MAX	= 1 << 63;
-	_MASK	= _MAX - 1;
-	_A	= 48271;
-	_M	= (1 << 31) - 1;
-	_Q	= 44488;
-	_R	= 3399;
+	_LEN  = 607
+	_TAP  = 273
+	_MAX  = 1 << 63
+	_MASK = _MAX - 1
+	_A    = 48271
+	_M    = (1 << 31) - 1
+	_Q    = 44488
+	_R    = 3399
 )
 
 var (
@@ -179,32 +179,32 @@ var (
 		4922828954023452664, 2879211533496425641, 5896236396443472108, 8465043815351752425,
 		7329020396871624740, 8915471717014488588, 2944902635677463047, 7052079073493465134,
 		8382142935188824023, 9103922860780351547, 4152330101494654406,
-	};
+	}
 )
 
 type rngSource struct {
-	tap	int;		// index into vec
-	feed	int;		// index into vec
-	vec	[_LEN]int64;	// current feedback register
+	tap  int         // index into vec
+	feed int         // index into vec
+	vec  [_LEN]int64 // current feedback register
 }
 
 // seed rng x[n+1] = 48271 * x[n] mod (2**31 - 1)
 func seedrand(x int32) int32 {
-	hi := x / _Q;
-	lo := x % _Q;
-	x = _A*lo - _R*hi;
+	hi := x / _Q
+	lo := x % _Q
+	x = _A*lo - _R*hi
 	if x < 0 {
 		x += _M
 	}
-	return x;
+	return x
 }
 
 // Seed uses the provided seed value to initialize the generator to a deterministic state.
 func (rng *rngSource) Seed(seed int64) {
-	rng.tap = 0;
-	rng.feed = _LEN - _TAP;
+	rng.tap = 0
+	rng.feed = _LEN - _TAP
 
-	seed = seed % _M;
+	seed = seed % _M
 	if seed < 0 {
 		seed += _M
 	}
@@ -212,35 +212,35 @@ func (rng *rngSource) Seed(seed int64) {
 		seed = 89482311
 	}
 
-	x := int32(seed);
+	x := int32(seed)
 	for i := -20; i < _LEN; i++ {
-		x = seedrand(x);
+		x = seedrand(x)
 		if i >= 0 {
-			var u int64;
-			u = int64(x) << 40;
-			x = seedrand(x);
-			u ^= int64(x) << 20;
-			x = seedrand(x);
-			u ^= int64(x);
-			u ^= rng_cooked[i];
-			rng.vec[i] = u & _MASK;
+			var u int64
+			u = int64(x) << 40
+			x = seedrand(x)
+			u ^= int64(x) << 20
+			x = seedrand(x)
+			u ^= int64(x)
+			u ^= rng_cooked[i]
+			rng.vec[i] = u & _MASK
 		}
 	}
 }
 
 // Int63 returns a non-negative pseudo-random 63-bit integer as an int64.
 func (rng *rngSource) Int63() int64 {
-	rng.tap--;
+	rng.tap--
 	if rng.tap < 0 {
 		rng.tap += _LEN
 	}
 
-	rng.feed--;
+	rng.feed--
 	if rng.feed < 0 {
 		rng.feed += _LEN
 	}
 
-	x := (rng.vec[rng.feed] + rng.vec[rng.tap]) & _MASK;
-	rng.vec[rng.feed] = x;
-	return x;
+	x := (rng.vec[rng.feed] + rng.vec[rng.tap]) & _MASK
+	rng.vec[rng.feed] = x
+	return x
 }
diff --git a/src/pkg/reflect/all_test.go b/src/pkg/reflect/all_test.go
index b94db00d95..974cca8c36 100644
--- a/src/pkg/reflect/all_test.go
+++ b/src/pkg/reflect/all_test.go
@@ -5,27 +5,27 @@
 package reflect_test
 
 import (
-	"io";
-	"os";
-	. "reflect";
-	"testing";
-	"unsafe";
+	"io"
+	"os"
+	. "reflect"
+	"testing"
+	"unsafe"
 )
 
 type integer int
 type T struct {
-	a	int;
-	b	float64;
-	c	string;
-	d	*int;
+	a int
+	b float64
+	c string
+	d *int
 }
 
 type pair struct {
-	i	interface{};
-	s	string;
+	i interface{}
+	s string
 }
 
-func isDigit(c uint8) bool	{ return '0' <= c && c <= '9' }
+func isDigit(c uint8) bool { return '0' <= c && c <= '9' }
 
 func assert(t *testing.T, s, want string) {
 	if s != want {
@@ -33,7 +33,7 @@ func assert(t *testing.T, s, want string) {
 	}
 }
 
-func typestring(i interface{}) string	{ return Typeof(i).String() }
+func typestring(i interface{}) string { return Typeof(i).String() }
 
 var typeTests = []pair{
 	pair{struct{ x int }{}, "int"},
@@ -58,96 +58,96 @@ var typeTests = []pair{
 	pair{struct{ x (chan<- string) }{}, "chan<- string"},
 	pair{struct {
 		x struct {
-			c	chan *int32;
-			d	float32;
-		};
+			c chan *int32
+			d float32
+		}
 	}{},
 		"struct { c chan *int32; d float32 }",
 	},
 	pair{struct{ x (func(a int8, b int32)) }{}, "func(int8, int32)"},
 	pair{struct {
 		x struct {
-			c func(chan *integer, *int8);
-		};
+			c func(chan *integer, *int8)
+		}
 	}{},
 		"struct { c func(chan *reflect_test.integer, *int8) }",
 	},
 	pair{struct {
 		x struct {
-			a	int8;
-			b	int32;
-		};
+			a int8
+			b int32
+		}
 	}{},
 		"struct { a int8; b int32 }",
 	},
 	pair{struct {
 		x struct {
-			a	int8;
-			b	int8;
-			c	int32;
-		};
+			a int8
+			b int8
+			c int32
+		}
 	}{},
 		"struct { a int8; b int8; c int32 }",
 	},
 	pair{struct {
 		x struct {
-			a	int8;
-			b	int8;
-			c	int8;
-			d	int32;
-		};
+			a int8
+			b int8
+			c int8
+			d int32
+		}
 	}{},
 		"struct { a int8; b int8; c int8; d int32 }",
 	},
 	pair{struct {
 		x struct {
-			a	int8;
-			b	int8;
-			c	int8;
-			d	int8;
-			e	int32;
-		};
+			a int8
+			b int8
+			c int8
+			d int8
+			e int32
+		}
 	}{},
 		"struct { a int8; b int8; c int8; d int8; e int32 }",
 	},
 	pair{struct {
 		x struct {
-			a	int8;
-			b	int8;
-			c	int8;
-			d	int8;
-			e	int8;
-			f	int32;
-		};
+			a int8
+			b int8
+			c int8
+			d int8
+			e int8
+			f int32
+		}
 	}{},
 		"struct { a int8; b int8; c int8; d int8; e int8; f int32 }",
 	},
 	pair{struct {
 		x struct {
-			a int8 "hi there";
-		};
+			a int8 "hi there"
+		}
 	}{},
 		`struct { a int8 "hi there" }`,
 	},
 	pair{struct {
 		x struct {
-			a int8 "hi \x00there\t\n\"\\";
-		};
+			a int8 "hi \x00there\t\n\"\\"
+		}
 	}{},
 		`struct { a int8 "hi \x00there\t\n\"\\" }`,
 	},
 	pair{struct {
 		x struct {
-			f func(args ...);
-		};
+			f func(args ...)
+		}
 	}{},
 		"struct { f func(...) }",
 	},
 	pair{struct {
 		x (interface {
-			a(func(func(int) int) (func(func(int)) int));
-			b();
-		});
+			a(func(func(int) int) (func(func(int)) int))
+			b()
+		})
 	}{},
 		"interface { a (func(func(int) (int)) (func(func(int)) (int))); b () }",
 	},
@@ -173,34 +173,34 @@ var valueTests = []pair{
 	pair{(map[string]int32)(nil), "map[string] int32{<can't iterate on maps>}"},
 	pair{(chan<- string)(nil), "chan<- string"},
 	pair{(struct {
-		c	chan *int32;
-		d	float32;
+		c chan *int32
+		d float32
 	}){},
 		"struct { c chan *int32; d float32 }{chan *int32, 0}",
 	},
 	pair{(func(a int8, b int32))(nil), "func(int8, int32)(0)"},
 	pair{(struct {
-		c func(chan *integer, *int8);
+		c func(chan *integer, *int8)
 	}){},
 		"struct { c func(chan *reflect_test.integer, *int8) }{func(chan *reflect_test.integer, *int8)(0)}",
 	},
 	pair{(struct {
-		a	int8;
-		b	int32;
+		a int8
+		b int32
 	}){},
 		"struct { a int8; b int32 }{0, 0}",
 	},
 	pair{(struct {
-		a	int8;
-		b	int8;
-		c	int32;
+		a int8
+		b int8
+		c int32
 	}){},
 		"struct { a int8; b int8; c int32 }{0, 0, 0}",
 	},
 }
 
 func testType(t *testing.T, i int, typ Type, want string) {
-	s := typ.String();
+	s := typ.String()
 	if s != want {
 		t.Errorf("#%d: have %#q, want %#q", i, s, want)
 	}
@@ -214,7 +214,7 @@ func TestTypes(t *testing.T) {
 
 func TestSet(t *testing.T) {
 	for i, tt := range valueTests {
-		v := NewValue(tt.i);
+		v := NewValue(tt.i)
 		switch v := v.(type) {
 		case *IntValue:
 			v.Set(132)
@@ -247,7 +247,7 @@ func TestSet(t *testing.T) {
 		case *BoolValue:
 			v.Set(true)
 		}
-		s := valueToString(v);
+		s := valueToString(v)
 		if s != tt.s {
 			t.Errorf("#%d: have %#q, want %#q", i, s, tt.s)
 		}
@@ -256,7 +256,7 @@ func TestSet(t *testing.T) {
 
 func TestSetValue(t *testing.T) {
 	for i, tt := range valueTests {
-		v := NewValue(tt.i);
+		v := NewValue(tt.i)
 		switch v := v.(type) {
 		case *IntValue:
 			v.SetValue(NewValue(int(132)))
@@ -289,7 +289,7 @@ func TestSetValue(t *testing.T) {
 		case *BoolValue:
 			v.SetValue(NewValue(true))
 		}
-		s := valueToString(v);
+		s := valueToString(v)
 		if s != tt.s {
 			t.Errorf("#%d: have %#q, want %#q", i, s, tt.s)
 		}
@@ -313,7 +313,7 @@ var valueToStringTests = []pair{
 
 func TestValueToString(t *testing.T) {
 	for i, test := range valueToStringTests {
-		s := valueToString(NewValue(test.i));
+		s := valueToString(NewValue(test.i))
 		if s != test.s {
 			t.Errorf("#%d: have %#q, want %#q", i, s, test.s)
 		}
@@ -321,136 +321,136 @@ func TestValueToString(t *testing.T) {
 }
 
 func TestArrayElemSet(t *testing.T) {
-	v := NewValue([10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10});
-	v.(*ArrayValue).Elem(4).(*IntValue).Set(123);
-	s := valueToString(v);
-	const want = "[10]int{1, 2, 3, 4, 123, 6, 7, 8, 9, 10}";
+	v := NewValue([10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
+	v.(*ArrayValue).Elem(4).(*IntValue).Set(123)
+	s := valueToString(v)
+	const want = "[10]int{1, 2, 3, 4, 123, 6, 7, 8, 9, 10}"
 	if s != want {
 		t.Errorf("[10]int: have %#q want %#q", s, want)
 	}
 
-	v = NewValue([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10});
-	v.(*SliceValue).Elem(4).(*IntValue).Set(123);
-	s = valueToString(v);
-	const want1 = "[]int{1, 2, 3, 4, 123, 6, 7, 8, 9, 10}";
+	v = NewValue([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
+	v.(*SliceValue).Elem(4).(*IntValue).Set(123)
+	s = valueToString(v)
+	const want1 = "[]int{1, 2, 3, 4, 123, 6, 7, 8, 9, 10}"
 	if s != want1 {
 		t.Errorf("[]int: have %#q want %#q", s, want1)
 	}
 }
 
 func TestPtrPointTo(t *testing.T) {
-	var ip *int32;
-	var i int32 = 1234;
-	vip := NewValue(&ip);
-	vi := NewValue(i);
-	vip.(*PtrValue).Elem().(*PtrValue).PointTo(vi);
+	var ip *int32
+	var i int32 = 1234
+	vip := NewValue(&ip)
+	vi := NewValue(i)
+	vip.(*PtrValue).Elem().(*PtrValue).PointTo(vi)
 	if *ip != 1234 {
 		t.Errorf("got %d, want 1234", *ip)
 	}
 }
 
 func TestAll(t *testing.T) {
-	testType(t, 1, Typeof((int8)(0)), "int8");
-	testType(t, 2, Typeof((*int8)(nil)).(*PtrType).Elem(), "int8");
+	testType(t, 1, Typeof((int8)(0)), "int8")
+	testType(t, 2, Typeof((*int8)(nil)).(*PtrType).Elem(), "int8")
 
 	typ := Typeof((*struct {
-		c	chan *int32;
-		d	float32;
-	})(nil));
-	testType(t, 3, typ, "*struct { c chan *int32; d float32 }");
-	etyp := typ.(*PtrType).Elem();
-	testType(t, 4, etyp, "struct { c chan *int32; d float32 }");
-	styp := etyp.(*StructType);
-	f := styp.Field(0);
-	testType(t, 5, f.Type, "chan *int32");
-
-	f, present := styp.FieldByName("d");
+		c chan *int32
+		d float32
+	})(nil))
+	testType(t, 3, typ, "*struct { c chan *int32; d float32 }")
+	etyp := typ.(*PtrType).Elem()
+	testType(t, 4, etyp, "struct { c chan *int32; d float32 }")
+	styp := etyp.(*StructType)
+	f := styp.Field(0)
+	testType(t, 5, f.Type, "chan *int32")
+
+	f, present := styp.FieldByName("d")
 	if !present {
 		t.Errorf("FieldByName says present field is absent")
 	}
-	testType(t, 6, f.Type, "float32");
+	testType(t, 6, f.Type, "float32")
 
-	f, present = styp.FieldByName("absent");
+	f, present = styp.FieldByName("absent")
 	if present {
 		t.Errorf("FieldByName says absent field is present")
 	}
 
-	typ = Typeof([32]int32{});
-	testType(t, 7, typ, "[32]int32");
-	testType(t, 8, typ.(*ArrayType).Elem(), "int32");
+	typ = Typeof([32]int32{})
+	testType(t, 7, typ, "[32]int32")
+	testType(t, 8, typ.(*ArrayType).Elem(), "int32")
 
-	typ = Typeof((map[string]*int32)(nil));
-	testType(t, 9, typ, "map[string] *int32");
-	mtyp := typ.(*MapType);
-	testType(t, 10, mtyp.Key(), "string");
-	testType(t, 11, mtyp.Elem(), "*int32");
+	typ = Typeof((map[string]*int32)(nil))
+	testType(t, 9, typ, "map[string] *int32")
+	mtyp := typ.(*MapType)
+	testType(t, 10, mtyp.Key(), "string")
+	testType(t, 11, mtyp.Elem(), "*int32")
 
-	typ = Typeof((chan<- string)(nil));
-	testType(t, 12, typ, "chan<- string");
-	testType(t, 13, typ.(*ChanType).Elem(), "string");
+	typ = Typeof((chan<- string)(nil))
+	testType(t, 12, typ, "chan<- string")
+	testType(t, 13, typ.(*ChanType).Elem(), "string")
 
 	// make sure tag strings are not part of element type
 	typ = Typeof(struct {
-		d []uint32 "TAG";
-	}{}).(*StructType).Field(0).Type;
-	testType(t, 14, typ, "[]uint32");
+		d []uint32 "TAG"
+	}{}).(*StructType).Field(0).Type
+	testType(t, 14, typ, "[]uint32")
 }
 
 func TestInterfaceGet(t *testing.T) {
 	var inter struct {
-		e interface{};
-	}
-	inter.e = 123.456;
-	v1 := NewValue(&inter);
-	v2 := v1.(*PtrValue).Elem().(*StructValue).Field(0);
-	assert(t, v2.Type().String(), "interface { }");
-	i2 := v2.(*InterfaceValue).Interface();
-	v3 := NewValue(i2);
-	assert(t, v3.Type().String(), "float");
+		e interface{}
+	}
+	inter.e = 123.456
+	v1 := NewValue(&inter)
+	v2 := v1.(*PtrValue).Elem().(*StructValue).Field(0)
+	assert(t, v2.Type().String(), "interface { }")
+	i2 := v2.(*InterfaceValue).Interface()
+	v3 := NewValue(i2)
+	assert(t, v3.Type().String(), "float")
 }
 
 func TestInterfaceValue(t *testing.T) {
 	var inter struct {
-		e interface{};
+		e interface{}
 	}
-	inter.e = 123.456;
-	v1 := NewValue(&inter);
-	v2 := v1.(*PtrValue).Elem().(*StructValue).Field(0);
-	assert(t, v2.Type().String(), "interface { }");
-	v3 := v2.(*InterfaceValue).Elem();
-	assert(t, v3.Type().String(), "float");
+	inter.e = 123.456
+	v1 := NewValue(&inter)
+	v2 := v1.(*PtrValue).Elem().(*StructValue).Field(0)
+	assert(t, v2.Type().String(), "interface { }")
+	v3 := v2.(*InterfaceValue).Elem()
+	assert(t, v3.Type().String(), "float")
 
-	i3 := v2.Interface();
+	i3 := v2.Interface()
 	if _, ok := i3.(float); !ok {
 		t.Error("v2.Interface() did not return float, got ", Typeof(i3))
 	}
 }
 
 func TestFunctionValue(t *testing.T) {
-	v := NewValue(func() {});
+	v := NewValue(func() {})
 	if v.Interface() != v.Interface() {
 		t.Fatalf("TestFunction != itself")
 	}
-	assert(t, v.Type().String(), "func()");
+	assert(t, v.Type().String(), "func()")
 }
 
 func TestCopyArray(t *testing.T) {
-	a := []int{1, 2, 3, 4, 10, 9, 8, 7};
-	b := []int{11, 22, 33, 44, 1010, 99, 88, 77, 66, 55, 44};
-	c := []int{11, 22, 33, 44, 1010, 99, 88, 77, 66, 55, 44};
-	va := NewValue(&a);
-	vb := NewValue(&b);
+	a := []int{1, 2, 3, 4, 10, 9, 8, 7}
+	b := []int{11, 22, 33, 44, 1010, 99, 88, 77, 66, 55, 44}
+	c := []int{11, 22, 33, 44, 1010, 99, 88, 77, 66, 55, 44}
+	va := NewValue(&a)
+	vb := NewValue(&b)
 	for i := 0; i < len(b); i++ {
 		if b[i] != c[i] {
 			t.Fatalf("b != c before test")
 		}
 	}
-	aa := va.(*PtrValue).Elem().(*SliceValue);
-	ab := vb.(*PtrValue).Elem().(*SliceValue);
+	aa := va.(*PtrValue).Elem().(*SliceValue)
+	ab := vb.(*PtrValue).Elem().(*SliceValue)
 	for tocopy := 1; tocopy <= 7; tocopy++ {
-		aa.SetLen(tocopy);
-		ArrayCopy(ab, aa);
-		aa.SetLen(8);
+		aa.SetLen(tocopy)
+		ArrayCopy(ab, aa)
+		aa.SetLen(8)
 		for i := 0; i < tocopy; i++ {
 			if a[i] != b[i] {
 				t.Errorf("(i) tocopy=%d a[%d]=%d, b[%d]=%d",
@@ -474,39 +474,39 @@ func TestCopyArray(t *testing.T) {
 }
 
 func TestBigUnnamedStruct(t *testing.T) {
-	b := struct{ a, b, c, d int64 }{1, 2, 3, 4};
-	v := NewValue(b);
+	b := struct{ a, b, c, d int64 }{1, 2, 3, 4}
+	v := NewValue(b)
 	b1 := v.Interface().(struct {
-		a, b, c, d int64;
-	});
+		a, b, c, d int64
+	})
 	if b1.a != b.a || b1.b != b.b || b1.c != b.c || b1.d != b.d {
 		t.Errorf("NewValue(%v).Interface().(*Big) = %v", b, b1)
 	}
 }
 
 type big struct {
-	a, b, c, d, e int64;
+	a, b, c, d, e int64
 }
 
 func TestBigStruct(t *testing.T) {
-	b := big{1, 2, 3, 4, 5};
-	v := NewValue(b);
-	b1 := v.Interface().(big);
+	b := big{1, 2, 3, 4, 5}
+	v := NewValue(b)
+	b1 := v.Interface().(big)
 	if b1.a != b.a || b1.b != b.b || b1.c != b.c || b1.d != b.d || b1.e != b.e {
 		t.Errorf("NewValue(%v).Interface().(big) = %v", b, b1)
 	}
 }
 
 type Basic struct {
-	x	int;
-	y	float32;
+	x int
+	y float32
 }
 
 type NotBasic Basic
 
 type DeepEqualTest struct {
-	a, b	interface{};
-	eq	bool;
+	a, b interface{}
+	eq   bool
 }
 
 var deepEqualTests = []DeepEqualTest{
@@ -559,11 +559,11 @@ func TestDeepEqual(t *testing.T) {
 
 func TestTypeof(t *testing.T) {
 	for _, test := range deepEqualTests {
-		v := NewValue(test.a);
+		v := NewValue(test.a)
 		if v == nil {
 			continue
 		}
-		typ := Typeof(test.a);
+		typ := Typeof(test.a)
 		if typ != v.Type() {
 			t.Errorf("Typeof(%v) = %v, but NewValue(%v).Type() = %v", test.a, typ, test.a, v.Type())
 		}
@@ -571,43 +571,43 @@ func TestTypeof(t *testing.T) {
 }
 
 type Recursive struct {
-	x	int;
-	r	*Recursive;
+	x int
+	r *Recursive
 }
 
 func TestDeepEqualRecursiveStruct(t *testing.T) {
-	a, b := new(Recursive), new(Recursive);
-	*a = Recursive{12, a};
-	*b = Recursive{12, b};
+	a, b := new(Recursive), new(Recursive)
+	*a = Recursive{12, a}
+	*b = Recursive{12, b}
 	if !DeepEqual(a, b) {
 		t.Error("DeepEqual(recursive same) = false, want true")
 	}
 }
 
 type Complex struct {
-	a	int;
-	b	[3]*Complex;
-	c	*string;
-	d	map[float]float;
+	a int
+	b [3]*Complex
+	c *string
+	d map[float]float
 }
 
 func TestDeepEqualComplexStruct(t *testing.T) {
-	m := make(map[float]float);
-	stra, strb := "hello", "hello";
-	a, b := new(Complex), new(Complex);
-	*a = Complex{5, [3]*Complex{a, b, a}, &stra, m};
-	*b = Complex{5, [3]*Complex{b, a, a}, &strb, m};
+	m := make(map[float]float)
+	stra, strb := "hello", "hello"
+	a, b := new(Complex), new(Complex)
+	*a = Complex{5, [3]*Complex{a, b, a}, &stra, m}
+	*b = Complex{5, [3]*Complex{b, a, a}, &strb, m}
 	if !DeepEqual(a, b) {
 		t.Error("DeepEqual(complex same) = false, want true")
 	}
 }
 
 func TestDeepEqualComplexStructInequality(t *testing.T) {
-	m := make(map[float]float);
-	stra, strb := "hello", "helloo";	// Difference is here
-	a, b := new(Complex), new(Complex);
-	*a = Complex{5, [3]*Complex{a, b, a}, &stra, m};
-	*b = Complex{5, [3]*Complex{b, a, a}, &strb, m};
+	m := make(map[float]float)
+	stra, strb := "hello", "helloo" // Difference is here
+	a, b := new(Complex), new(Complex)
+	*a = Complex{5, [3]*Complex{a, b, a}, &stra, m}
+	*b = Complex{5, [3]*Complex{b, a, a}, &strb, m}
 	if DeepEqual(a, b) {
 		t.Error("DeepEqual(complex different) = true, want false")
 	}
@@ -615,8 +615,8 @@ func TestDeepEqualComplexStructInequality(t *testing.T) {
 
 
 func check2ndField(x interface{}, offs uintptr, t *testing.T) {
-	s := NewValue(x).(*StructValue);
-	f := s.Type().(*StructType).Field(1);
+	s := NewValue(x).(*StructValue)
+	f := s.Type().(*StructType).Field(1)
 	if f.Offset != offs {
 		t.Error("mismatched offsets in structure alignment:", f.Offset, offs)
 	}
@@ -626,40 +626,40 @@ func check2ndField(x interface{}, offs uintptr, t *testing.T) {
 // from the compiler itself.
 func TestAlignment(t *testing.T) {
 	type T1inner struct {
-		a int;
+		a int
 	}
 	type T1 struct {
-		T1inner;
-		f	int;
+		T1inner
+		f int
 	}
 	type T2inner struct {
-		a, b int;
+		a, b int
 	}
 	type T2 struct {
-		T2inner;
-		f	int;
+		T2inner
+		f int
 	}
 
-	x := T1{T1inner{2}, 17};
-	check2ndField(x, uintptr(unsafe.Pointer(&x.f))-uintptr(unsafe.Pointer(&x)), t);
+	x := T1{T1inner{2}, 17}
+	check2ndField(x, uintptr(unsafe.Pointer(&x.f))-uintptr(unsafe.Pointer(&x)), t)
 
-	x1 := T2{T2inner{2, 3}, 17};
-	check2ndField(x1, uintptr(unsafe.Pointer(&x1.f))-uintptr(unsafe.Pointer(&x1)), t);
+	x1 := T2{T2inner{2, 3}, 17}
+	check2ndField(x1, uintptr(unsafe.Pointer(&x1.f))-uintptr(unsafe.Pointer(&x1)), t)
 }
 
 type IsNiller interface {
-	IsNil() bool;
+	IsNil() bool
 }
 
 func Nil(a interface{}, t *testing.T) {
-	n := NewValue(a).(*StructValue).Field(0).(IsNiller);
+	n := NewValue(a).(*StructValue).Field(0).(IsNiller)
 	if !n.IsNil() {
 		t.Errorf("%v should be nil", a)
 	}
 }
 
 func NotNil(a interface{}, t *testing.T) {
-	n := NewValue(a).(*StructValue).Field(0).(IsNiller);
+	n := NewValue(a).(*StructValue).Field(0).(IsNiller)
 	if n.IsNil() {
 		t.Errorf("value of type %v should not be nil", NewValue(a).Type().String())
 	}
@@ -667,10 +667,10 @@ func NotNil(a interface{}, t *testing.T) {
 
 func TestIsNil(t *testing.T) {
 	// These do not implement IsNil
-	doNotNil := []interface{}{int(0), float32(0), struct{ a int }{}};
+	doNotNil := []interface{}{int(0), float32(0), struct{ a int }{}}
 	for _, ts := range doNotNil {
-		ty := Typeof(ts);
-		v := MakeZero(ty);
+		ty := Typeof(ts)
+		v := MakeZero(ty)
 		if _, ok := v.(IsNiller); ok {
 			t.Errorf("%s is nilable; should not be", ts)
 		}
@@ -685,10 +685,10 @@ func TestIsNil(t *testing.T) {
 		struct{ x func() bool }{},
 		struct{ x chan int }{},
 		struct{ x []string }{},
-	};
+	}
 	for _, ts := range doNil {
-		ty := Typeof(ts).(*StructType).Field(0).Type;
-		v := MakeZero(ty);
+		ty := Typeof(ts).(*StructType).Field(0).Type
+		v := MakeZero(ty)
 		if _, ok := v.(IsNiller); !ok {
 			t.Errorf("%s %T is not nilable; should be", ts, v)
 		}
@@ -696,55 +696,55 @@ func TestIsNil(t *testing.T) {
 
 	// Check the implementations
 	var pi struct {
-		x *int;
+		x *int
 	}
-	Nil(pi, t);
-	pi.x = new(int);
-	NotNil(pi, t);
+	Nil(pi, t)
+	pi.x = new(int)
+	NotNil(pi, t)
 
 	var si struct {
-		x []int;
+		x []int
 	}
-	Nil(si, t);
-	si.x = make([]int, 10);
-	NotNil(si, t);
+	Nil(si, t)
+	si.x = make([]int, 10)
+	NotNil(si, t)
 
 	var ci struct {
-		x chan int;
+		x chan int
 	}
-	Nil(ci, t);
-	ci.x = make(chan int);
-	NotNil(ci, t);
+	Nil(ci, t)
+	ci.x = make(chan int)
+	NotNil(ci, t)
 
 	var mi struct {
-		x map[int]int;
+		x map[int]int
 	}
-	Nil(mi, t);
-	mi.x = make(map[int]int);
-	NotNil(mi, t);
+	Nil(mi, t)
+	mi.x = make(map[int]int)
+	NotNil(mi, t)
 
 	var ii struct {
-		x interface{};
+		x interface{}
 	}
-	Nil(ii, t);
-	ii.x = 2;
-	NotNil(ii, t);
+	Nil(ii, t)
+	ii.x = 2
+	NotNil(ii, t)
 
 	var fi struct {
-		x func(t *testing.T);
+		x func(t *testing.T)
 	}
-	Nil(fi, t);
-	fi.x = TestIsNil;
-	NotNil(fi, t);
+	Nil(fi, t)
+	fi.x = TestIsNil
+	NotNil(fi, t)
 }
 
 func TestInterfaceExtraction(t *testing.T) {
 	var s struct {
-		w io.Writer;
+		w io.Writer
 	}
 
-	s.w = os.Stdout;
-	v := Indirect(NewValue(&s)).(*StructValue).Field(0).Interface();
+	s.w = os.Stdout
+	v := Indirect(NewValue(&s)).(*StructValue).Field(0).Interface()
 	if v != s.w.(interface{}) {
 		t.Error("Interface() on interface: ", v, s.w)
 	}
@@ -755,45 +755,45 @@ func TestInterfaceEditing(t *testing.T) {
 	// so the interface conversion allocates
 	// memory to hold a string and puts that
 	// pointer in the interface.
-	var i interface{} = "hello";
+	var i interface{} = "hello"
 
 	// if i pass the interface value by value
 	// to NewValue, i should get a fresh copy
 	// of the value.
-	v := NewValue(i);
+	v := NewValue(i)
 
 	// and setting that copy to "bye" should
 	// not change the value stored in i.
-	v.(*StringValue).Set("bye");
+	v.(*StringValue).Set("bye")
 	if i.(string) != "hello" {
 		t.Errorf(`Set("bye") changed i to %s`, i.(string))
 	}
 
 	// the same should be true of smaller items.
-	i = 123;
-	v = NewValue(i);
-	v.(*IntValue).Set(234);
+	i = 123
+	v = NewValue(i)
+	v.(*IntValue).Set(234)
 	if i.(int) != 123 {
 		t.Errorf("Set(234) changed i to %d", i.(int))
 	}
 }
 
 func TestNilPtrValueSub(t *testing.T) {
-	var pi *int;
+	var pi *int
 	if pv := NewValue(pi).(*PtrValue); pv.Elem() != nil {
 		t.Error("NewValue((*int)(nil)).(*PtrValue).Elem() != nil")
 	}
 }
 
 func TestMap(t *testing.T) {
-	m := map[string]int{"a": 1, "b": 2};
-	mv := NewValue(m).(*MapValue);
+	m := map[string]int{"a": 1, "b": 2}
+	mv := NewValue(m).(*MapValue)
 	if n := mv.Len(); n != len(m) {
 		t.Errorf("Len = %d, want %d", n, len(m))
 	}
-	keys := mv.Keys();
-	i := 0;
-	newmap := MakeMap(mv.Type().(*MapType));
+	keys := mv.Keys()
+	i := 0
+	newmap := MakeMap(mv.Type().(*MapType))
 	for k, v := range m {
 		// Check that returned Keys match keys in range.
 		// These aren't required to be in the same order,
@@ -804,36 +804,36 @@ func TestMap(t *testing.T) {
 		} else if kv := keys[i].(*StringValue); kv.Get() != k {
 			t.Errorf("Keys[%d] = %q, want %q", i, kv.Get(), k)
 		}
-		i++;
+		i++
 
 		// Check that value lookup is correct.
-		vv := mv.Elem(NewValue(k));
+		vv := mv.Elem(NewValue(k))
 		if vi := vv.(*IntValue).Get(); vi != v {
 			t.Errorf("Key %q: have value %d, want %d", vi, v)
 		}
 
 		// Copy into new map.
-		newmap.SetElem(NewValue(k), NewValue(v));
+		newmap.SetElem(NewValue(k), NewValue(v))
 	}
-	vv := mv.Elem(NewValue("not-present"));
+	vv := mv.Elem(NewValue("not-present"))
 	if vv != nil {
 		t.Errorf("Invalid key: got non-nil value %s", valueToString(vv))
 	}
 
-	newm := newmap.Interface().(map[string]int);
+	newm := newmap.Interface().(map[string]int)
 	if len(newm) != len(m) {
 		t.Errorf("length after copy: newm=%d, m=%d", newm, m)
 	}
 
 	for k, v := range newm {
-		mv, ok := m[k];
+		mv, ok := m[k]
 		if mv != v {
 			t.Errorf("newm[%q] = %d, but m[%q] = %d, %v", k, v, k, mv, ok)
 		}
 	}
 
-	newmap.SetElem(NewValue("a"), nil);
-	v, ok := newm["a"];
+	newmap.SetElem(NewValue("a"), nil)
+	v, ok := newm["a"]
 	if ok {
 		t.Errorf("newm[\"a\"] = %d after delete", v)
 	}
@@ -841,40 +841,40 @@ func TestMap(t *testing.T) {
 
 func TestChan(t *testing.T) {
 	for loop := 0; loop < 2; loop++ {
-		var c chan int;
-		var cv *ChanValue;
+		var c chan int
+		var cv *ChanValue
 
 		// check both ways to allocate channels
 		switch loop {
 		case 1:
-			c = make(chan int, 1);
-			cv = NewValue(c).(*ChanValue);
+			c = make(chan int, 1)
+			cv = NewValue(c).(*ChanValue)
 		case 0:
-			cv = MakeChan(Typeof(c).(*ChanType), 1);
-			c = cv.Interface().(chan int);
+			cv = MakeChan(Typeof(c).(*ChanType), 1)
+			c = cv.Interface().(chan int)
 		}
 
 		// Send
-		cv.Send(NewValue(2));
+		cv.Send(NewValue(2))
 		if i := <-c; i != 2 {
 			t.Errorf("reflect Send 2, native recv %d", i)
 		}
 
 		// Recv
-		c <- 3;
+		c <- 3
 		if i := cv.Recv().(*IntValue).Get(); i != 3 {
 			t.Errorf("native send 3, reflect Recv %d", i)
 		}
 
 		// TryRecv fail
-		val := cv.TryRecv();
+		val := cv.TryRecv()
 		if val != nil {
 			t.Errorf("TryRecv on empty chan: %s", valueToString(val))
 		}
 
 		// TryRecv success
-		c <- 4;
-		val = cv.TryRecv();
+		c <- 4
+		val = cv.TryRecv()
 		if val == nil {
 			t.Errorf("TryRecv on ready chan got nil")
 		} else if i := val.(*IntValue).Get(); i != 4 {
@@ -882,15 +882,15 @@ func TestChan(t *testing.T) {
 		}
 
 		// TrySend fail
-		c <- 100;
-		ok := cv.TrySend(NewValue(5));
-		i := <-c;
+		c <- 100
+		ok := cv.TrySend(NewValue(5))
+		i := <-c
 		if ok {
 			t.Errorf("TrySend on full chan succeeded: value %d", i)
 		}
 
 		// TrySend success
-		ok = cv.TrySend(NewValue(6));
+		ok = cv.TrySend(NewValue(6))
 		if !ok {
 			t.Errorf("TrySend on empty chan failed")
 		} else {
@@ -900,8 +900,8 @@ func TestChan(t *testing.T) {
 		}
 
 		// Close
-		c <- 123;
-		cv.Close();
+		c <- 123
+		cv.Close()
 		if cv.Closed() {
 			t.Errorf("closed too soon - 1")
 		}
@@ -920,9 +920,9 @@ func TestChan(t *testing.T) {
 	}
 
 	// check creation of unbuffered channel
-	var c chan int;
-	cv := MakeChan(Typeof(c).(*ChanType), 0);
-	c = cv.Interface().(chan int);
+	var c chan int
+	cv := MakeChan(Typeof(c).(*ChanType), 0)
+	c = cv.Interface().(chan int)
 	if cv.TrySend(NewValue(7)) {
 		t.Errorf("TrySend on sync chan succeeded")
 	}
@@ -931,8 +931,8 @@ func TestChan(t *testing.T) {
 	}
 
 	// len/cap
-	cv = MakeChan(Typeof(c).(*ChanType), 10);
-	c = cv.Interface().(chan int);
+	cv = MakeChan(Typeof(c).(*ChanType), 10)
+	c = cv.Interface().(chan int)
 	for i := 0; i < 3; i++ {
 		c <- i
 	}
@@ -949,35 +949,35 @@ func dummy(b byte, c int, d byte) (i byte, j int, k byte) {
 }
 
 func TestFunc(t *testing.T) {
-	ret := NewValue(dummy).(*FuncValue).Call([]Value{NewValue(byte(10)), NewValue(20), NewValue(byte(30))});
+	ret := NewValue(dummy).(*FuncValue).Call([]Value{NewValue(byte(10)), NewValue(20), NewValue(byte(30))})
 	if len(ret) != 3 {
 		t.Fatalf("Call returned %d values, want 3", len(ret))
 	}
 
-	i := ret[0].(*Uint8Value).Get();
-	j := ret[1].(*IntValue).Get();
-	k := ret[2].(*Uint8Value).Get();
+	i := ret[0].(*Uint8Value).Get()
+	j := ret[1].(*IntValue).Get()
+	k := ret[2].(*Uint8Value).Get()
 	if i != 10 || j != 20 || k != 30 {
 		t.Errorf("Call returned %d, %d, %d; want 10, 20, 30", i, j, k)
 	}
 }
 
 type Point struct {
-	x, y int;
+	x, y int
 }
 
-func (p Point) Dist(scale int) int	{ return p.x*p.x*scale + p.y*p.y*scale }
+func (p Point) Dist(scale int) int { return p.x*p.x*scale + p.y*p.y*scale }
 
 func TestMethod(t *testing.T) {
 	// Non-curried method of type.
-	p := Point{3, 4};
-	i := Typeof(p).Method(0).Func.Call([]Value{NewValue(p), NewValue(10)})[0].(*IntValue).Get();
+	p := Point{3, 4}
+	i := Typeof(p).Method(0).Func.Call([]Value{NewValue(p), NewValue(10)})[0].(*IntValue).Get()
 	if i != 250 {
 		t.Errorf("Type Method returned %d; want 250", i)
 	}
 
 	// Curried method of value.
-	i = NewValue(p).Method(0).Call([]Value{NewValue(10)})[0].(*IntValue).Get();
+	i = NewValue(p).Method(0).Call([]Value{NewValue(10)})[0].(*IntValue).Get()
 	if i != 250 {
 		t.Errorf("Value Method returned %d; want 250", i)
 	}
@@ -988,53 +988,53 @@ func TestMethod(t *testing.T) {
 	// access the underlying Point, not the interface.
 	var s = struct {
 		x interface {
-			Dist(int) int;
-		};
-	}{p};
-	pv := NewValue(s).(*StructValue).Field(0);
-	i = pv.Method(0).Call([]Value{NewValue(10)})[0].(*IntValue).Get();
+			Dist(int) int
+		}
+	}{p}
+	pv := NewValue(s).(*StructValue).Field(0)
+	i = pv.Method(0).Call([]Value{NewValue(10)})[0].(*IntValue).Get()
 	if i != 250 {
 		t.Errorf("Interface Method returned %d; want 250", i)
 	}
 }
 
 func TestInterfaceSet(t *testing.T) {
-	p := &Point{3, 4};
+	p := &Point{3, 4}
 
 	var s struct {
-		I	interface{};
-		P	interface {
-			Dist(int) int;
-		};
+		I interface{}
+		P interface {
+			Dist(int) int
+		}
 	}
-	sv := NewValue(&s).(*PtrValue).Elem().(*StructValue);
-	sv.Field(0).(*InterfaceValue).Set(NewValue(p));
+	sv := NewValue(&s).(*PtrValue).Elem().(*StructValue)
+	sv.Field(0).(*InterfaceValue).Set(NewValue(p))
 	if q := s.I.(*Point); q != p {
 		t.Errorf("i: have %p want %p", q, p)
 	}
 
-	pv := sv.Field(1).(*InterfaceValue);
-	pv.Set(NewValue(p));
+	pv := sv.Field(1).(*InterfaceValue)
+	pv.Set(NewValue(p))
 	if q := s.P.(*Point); q != p {
 		t.Errorf("i: have %p want %p", q, p)
 	}
 
-	i := pv.Method(0).Call([]Value{NewValue(10)})[0].(*IntValue).Get();
+	i := pv.Method(0).Call([]Value{NewValue(10)})[0].(*IntValue).Get()
 	if i != 250 {
 		t.Errorf("Interface Method returned %d; want 250", i)
 	}
 }
 
 type T1 struct {
-	a	string;
-	int;
+	a string
+	int
 }
 
 func TestAnonymousFields(t *testing.T) {
-	var field StructField;
-	var ok bool;
-	var t1 T1;
-	type1 := Typeof(t1).(*StructType);
+	var field StructField
+	var ok bool
+	var t1 T1
+	type1 := Typeof(t1).(*StructType)
 	if field, ok = type1.FieldByName("int"); !ok {
 		t.Error("no field 'int'")
 	}
@@ -1044,53 +1044,53 @@ func TestAnonymousFields(t *testing.T) {
 }
 
 type FTest struct {
-	s	interface{};
-	name	string;
-	index	[]int;
-	value	int;
+	s     interface{}
+	name  string
+	index []int
+	value int
 }
 
 type D1 struct {
-	d int;
+	d int
 }
 type D2 struct {
-	d int;
+	d int
 }
 
 type S0 struct {
-	a, b, c	int;
-	D1;
-	D2;
+	a, b, c int
+	D1
+	D2
 }
 
 type S1 struct {
-	b	int;
-	S0;
+	b int
+	S0
 }
 
 type S2 struct {
-	a	int;
-	*S1;
+	a int
+	*S1
 }
 
 type S1x struct {
-	S1;
+	S1
 }
 
 type S1y struct {
-	S1;
+	S1
 }
 
 type S3 struct {
-	S1x;
-	S2;
-	d, e	int;
-	*S1y;
+	S1x
+	S2
+	d, e int
+	*S1y
 }
 
 type S4 struct {
-	*S4;
-	a	int;
+	*S4
+	a int
 }
 
 var fieldTests = []FTest{
@@ -1118,8 +1118,8 @@ var fieldTests = []FTest{
 
 func TestFieldByIndex(t *testing.T) {
 	for _, test := range fieldTests {
-		s := Typeof(test.s).(*StructType);
-		f := s.FieldByIndex(test.index);
+		s := Typeof(test.s).(*StructType)
+		f := s.FieldByIndex(test.index)
 		if f.Name != "" {
 			if test.index != nil {
 				if f.Name != test.name {
@@ -1133,7 +1133,7 @@ func TestFieldByIndex(t *testing.T) {
 		}
 
 		if test.value != 0 {
-			v := NewValue(test.s).(*StructValue).FieldByIndex(test.index);
+			v := NewValue(test.s).(*StructValue).FieldByIndex(test.index)
 			if v != nil {
 				if x, ok := v.Interface().(int); ok {
 					if x != test.value {
@@ -1151,8 +1151,8 @@ func TestFieldByIndex(t *testing.T) {
 
 func TestFieldByName(t *testing.T) {
 	for _, test := range fieldTests {
-		s := Typeof(test.s).(*StructType);
-		f, found := s.FieldByName(test.name);
+		s := Typeof(test.s).(*StructType)
+		f, found := s.FieldByName(test.name)
 		if found {
 			if test.index != nil {
 				// Verify field depth and index.
@@ -1173,7 +1173,7 @@ func TestFieldByName(t *testing.T) {
 		}
 
 		if test.value != 0 {
-			v := NewValue(test.s).(*StructValue).FieldByName(test.name);
+			v := NewValue(test.s).(*StructValue).FieldByName(test.name)
 			if v != nil {
 				if x, ok := v.Interface().(int); ok {
 					if x != test.value {
diff --git a/src/pkg/reflect/deepequal.go b/src/pkg/reflect/deepequal.go
index f3e13f85c1..575946c1e1 100644
--- a/src/pkg/reflect/deepequal.go
+++ b/src/pkg/reflect/deepequal.go
@@ -12,10 +12,10 @@ package reflect
 // checks in progress are true when it reencounters them.
 // Visited are stored in a map indexed by 17 * a1 + a2;
 type visit struct {
-	a1	uintptr;
-	a2	uintptr;
-	typ	Type;
-	next	*visit;
+	a1   uintptr
+	a2   uintptr
+	typ  Type
+	next *visit
 }
 
 // Tests for deep equality using reflected types. The map argument tracks
@@ -31,8 +31,8 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) bool {
 
 	// if depth > 10 { panic("deepValueEqual") }	// for debugging
 
-	addr1 := v1.Addr();
-	addr2 := v2.Addr();
+	addr1 := v1.Addr()
+	addr2 := v2.Addr()
 	if addr1 > addr2 {
 		// Canonicalize order to reduce number of entries in visited.
 		addr1, addr2 = addr2, addr1
@@ -44,9 +44,9 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) bool {
 	}
 
 	// ... or already seen
-	h := 17*addr1 + addr2;
-	seen, _ := visited[h];
-	typ := v1.Type();
+	h := 17*addr1 + addr2
+	seen, _ := visited[h]
+	typ := v1.Type()
 	for p := seen; p != nil; p = p.next {
 		if p.a1 == addr1 && p.a2 == addr2 && p.typ == typ {
 			return true
@@ -54,12 +54,12 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) bool {
 	}
 
 	// Remember for later.
-	visited[h] = &visit{addr1, addr2, typ, seen};
+	visited[h] = &visit{addr1, addr2, typ, seen}
 
 	switch v := v1.(type) {
 	case *ArrayValue:
-		arr1 := v;
-		arr2 := v2.(*ArrayValue);
+		arr1 := v
+		arr2 := v2.(*ArrayValue)
 		if arr1.Len() != arr2.Len() {
 			return false
 		}
@@ -68,10 +68,10 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) bool {
 				return false
 			}
 		}
-		return true;
+		return true
 	case *SliceValue:
-		arr1 := v;
-		arr2 := v2.(*SliceValue);
+		arr1 := v
+		arr2 := v2.(*SliceValue)
 		if arr1.Len() != arr2.Len() {
 			return false
 		}
@@ -80,28 +80,28 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) bool {
 				return false
 			}
 		}
-		return true;
+		return true
 	case *InterfaceValue:
-		i1 := v.Interface();
-		i2 := v2.Interface();
+		i1 := v.Interface()
+		i2 := v2.Interface()
 		if i1 == nil || i2 == nil {
 			return i1 == i2
 		}
-		return deepValueEqual(NewValue(i1), NewValue(i2), visited, depth+1);
+		return deepValueEqual(NewValue(i1), NewValue(i2), visited, depth+1)
 	case *PtrValue:
 		return deepValueEqual(v.Elem(), v2.(*PtrValue).Elem(), visited, depth+1)
 	case *StructValue:
-		struct1 := v;
-		struct2 := v2.(*StructValue);
+		struct1 := v
+		struct2 := v2.(*StructValue)
 		for i, n := 0, v.NumField(); i < n; i++ {
 			if !deepValueEqual(struct1.Field(i), struct2.Field(i), visited, depth+1) {
 				return false
 			}
 		}
-		return true;
+		return true
 	case *MapValue:
-		map1 := v;
-		map2 := v2.(*MapValue);
+		map1 := v
+		map2 := v2.(*MapValue)
 		if map1.Len() != map2.Len() {
 			return false
 		}
@@ -110,13 +110,13 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) bool {
 				return false
 			}
 		}
-		return true;
+		return true
 	default:
 		// Normal equality suffices
 		return v1.Interface() == v2.Interface()
 	}
 
-	panic("Not reached");
+	panic("Not reached")
 }
 
 // DeepEqual tests for deep equality. It uses normal == equality where possible
@@ -126,10 +126,10 @@ func DeepEqual(a1, a2 interface{}) bool {
 	if a1 == nil || a2 == nil {
 		return a1 == a2
 	}
-	v1 := NewValue(a1);
-	v2 := NewValue(a2);
+	v1 := NewValue(a1)
+	v2 := NewValue(a2)
 	if v1.Type() != v2.Type() {
 		return false
 	}
-	return deepValueEqual(v1, v2, make(map[uintptr]*visit), 0);
+	return deepValueEqual(v1, v2, make(map[uintptr]*visit), 0)
 }
diff --git a/src/pkg/reflect/tostring_test.go b/src/pkg/reflect/tostring_test.go
index 4a9e75793b..190385afac 100644
--- a/src/pkg/reflect/tostring_test.go
+++ b/src/pkg/reflect/tostring_test.go
@@ -9,18 +9,18 @@
 package reflect_test
 
 import (
-	. "reflect";
-	"strconv";
+	. "reflect"
+	"strconv"
 )
 
 // valueToString returns a textual representation of the reflection value val.
 // For debugging only.
 func valueToString(val Value) string {
-	var str string;
+	var str string
 	if val == nil {
 		return "<nil>"
 	}
-	typ := val.Type();
+	typ := val.Type()
 	switch val := val.(type) {
 	case *IntValue:
 		return strconv.Uitoa64(uint64(val.Get()))
@@ -61,57 +61,57 @@ func valueToString(val Value) string {
 			return "false"
 		}
 	case *PtrValue:
-		v := val;
-		str = typ.String() + "(";
+		v := val
+		str = typ.String() + "("
 		if v.IsNil() {
 			str += "0"
 		} else {
 			str += "&" + valueToString(v.Elem())
 		}
-		str += ")";
-		return str;
+		str += ")"
+		return str
 	case ArrayOrSliceValue:
-		v := val;
-		str += typ.String();
-		str += "{";
+		v := val
+		str += typ.String()
+		str += "{"
 		for i := 0; i < v.Len(); i++ {
 			if i > 0 {
 				str += ", "
 			}
-			str += valueToString(v.Elem(i));
+			str += valueToString(v.Elem(i))
 		}
-		str += "}";
-		return str;
+		str += "}"
+		return str
 	case *MapValue:
-		t := typ.(*MapType);
-		str = t.String();
-		str += "{";
-		str += "<can't iterate on maps>";
-		str += "}";
-		return str;
+		t := typ.(*MapType)
+		str = t.String()
+		str += "{"
+		str += "<can't iterate on maps>"
+		str += "}"
+		return str
 	case *ChanValue:
-		str = typ.String();
-		return str;
+		str = typ.String()
+		return str
 	case *StructValue:
-		t := typ.(*StructType);
-		v := val;
-		str += t.String();
-		str += "{";
+		t := typ.(*StructType)
+		v := val
+		str += t.String()
+		str += "{"
 		for i, n := 0, v.NumField(); i < n; i++ {
 			if i > 0 {
 				str += ", "
 			}
-			str += valueToString(v.Field(i));
+			str += valueToString(v.Field(i))
 		}
-		str += "}";
-		return str;
+		str += "}"
+		return str
 	case *InterfaceValue:
 		return typ.String() + "(" + valueToString(val.Elem()) + ")"
 	case *FuncValue:
-		v := val;
-		return typ.String() + "(" + strconv.Itoa64(int64(v.Get())) + ")";
+		v := val
+		return typ.String() + "(" + strconv.Itoa64(int64(v.Get())) + ")"
 	default:
 		panicln("valueToString: can't print type ", typ.String())
 	}
-	return "valueToString: can't happen";
+	return "valueToString: can't happen"
 }
diff --git a/src/pkg/reflect/type.go b/src/pkg/reflect/type.go
index a6988d312c..2c059924bf 100644
--- a/src/pkg/reflect/type.go
+++ b/src/pkg/reflect/type.go
@@ -16,9 +16,9 @@
 package reflect
 
 import (
-	"runtime";
-	"strconv";
-	"unsafe";
+	"runtime"
+	"strconv"
+	"unsafe"
 )
 
 /*
@@ -35,198 +35,198 @@ import (
  */
 
 type commonType struct {
-	size		uintptr;
-	hash		uint32;
-	alg		uint8;
-	align		uint8;
-	fieldAlign	uint8;
-	string		*string;
-	*uncommonType;
+	size       uintptr
+	hash       uint32
+	alg        uint8
+	align      uint8
+	fieldAlign uint8
+	string     *string
+	*uncommonType
 }
 
 type method struct {
-	hash	uint32;
-	name	*string;
-	pkgPath	*string;
-	typ	*runtime.Type;
-	ifn	unsafe.Pointer;
-	tfn	unsafe.Pointer;
+	hash    uint32
+	name    *string
+	pkgPath *string
+	typ     *runtime.Type
+	ifn     unsafe.Pointer
+	tfn     unsafe.Pointer
 }
 
 type uncommonType struct {
-	name	*string;
-	pkgPath	*string;
-	methods	[]method;
+	name    *string
+	pkgPath *string
+	methods []method
 }
 
 // BoolType represents a boolean type.
 type BoolType struct {
-	commonType;
+	commonType
 }
 
 // Float32Type represents a float32 type.
 type Float32Type struct {
-	commonType;
+	commonType
 }
 
 // Float64Type represents a float64 type.
 type Float64Type struct {
-	commonType;
+	commonType
 }
 
 // FloatType represents a float type.
 type FloatType struct {
-	commonType;
+	commonType
 }
 
 // Int16Type represents an int16 type.
 type Int16Type struct {
-	commonType;
+	commonType
 }
 
 // Int32Type represents an int32 type.
 type Int32Type struct {
-	commonType;
+	commonType
 }
 
 // Int64Type represents an int64 type.
 type Int64Type struct {
-	commonType;
+	commonType
 }
 
 // Int8Type represents an int8 type.
 type Int8Type struct {
-	commonType;
+	commonType
 }
 
 // IntType represents an int type.
 type IntType struct {
-	commonType;
+	commonType
 }
 
 // Uint16Type represents a uint16 type.
 type Uint16Type struct {
-	commonType;
+	commonType
 }
 
 // Uint32Type represents a uint32 type.
 type Uint32Type struct {
-	commonType;
+	commonType
 }
 
 // Uint64Type represents a uint64 type.
 type Uint64Type struct {
-	commonType;
+	commonType
 }
 
 // Uint8Type represents a uint8 type.
 type Uint8Type struct {
-	commonType;
+	commonType
 }
 
 // UintType represents a uint type.
 type UintType struct {
-	commonType;
+	commonType
 }
 
 // StringType represents a string type.
 type StringType struct {
-	commonType;
+	commonType
 }
 
 // UintptrType represents a uintptr type.
 type UintptrType struct {
-	commonType;
+	commonType
 }
 
 // DotDotDotType represents the ... that can
 // be used as the type of the final function parameter.
 type DotDotDotType struct {
-	commonType;
+	commonType
 }
 
 // UnsafePointerType represents an unsafe.Pointer type.
 type UnsafePointerType struct {
-	commonType;
+	commonType
 }
 
 // ArrayType represents a fixed array type.
 type ArrayType struct {
-	commonType;
-	elem	*runtime.Type;
-	len	uintptr;
+	commonType
+	elem *runtime.Type
+	len  uintptr
 }
 
 // ChanDir represents a channel type's direction.
 type ChanDir int
 
 const (
-	RecvDir	ChanDir	= 1 << iota;
-	SendDir;
-	BothDir	= RecvDir | SendDir;
+	RecvDir ChanDir = 1 << iota
+	SendDir
+	BothDir = RecvDir | SendDir
 )
 
 // ChanType represents a channel type.
 type ChanType struct {
-	commonType;
-	elem	*runtime.Type;
-	dir	uintptr;
+	commonType
+	elem *runtime.Type
+	dir  uintptr
 }
 
 // FuncType represents a function type.
 type FuncType struct {
-	commonType;
-	in	[]*runtime.Type;
-	out	[]*runtime.Type;
+	commonType
+	in  []*runtime.Type
+	out []*runtime.Type
 }
 
 // Method on interface type
 type imethod struct {
-	hash	uint32;
-	perm	uint32;
-	name	*string;
-	pkgPath	*string;
-	typ	*runtime.Type;
+	hash    uint32
+	perm    uint32
+	name    *string
+	pkgPath *string
+	typ     *runtime.Type
 }
 
 // InterfaceType represents an interface type.
 type InterfaceType struct {
-	commonType;
-	methods	[]imethod;
+	commonType
+	methods []imethod
 }
 
 // MapType represents a map type.
 type MapType struct {
-	commonType;
-	key	*runtime.Type;
-	elem	*runtime.Type;
+	commonType
+	key  *runtime.Type
+	elem *runtime.Type
 }
 
 // PtrType represents a pointer type.
 type PtrType struct {
-	commonType;
-	elem	*runtime.Type;
+	commonType
+	elem *runtime.Type
 }
 
 // SliceType represents a slice type.
 type SliceType struct {
-	commonType;
-	elem	*runtime.Type;
+	commonType
+	elem *runtime.Type
 }
 
 // Struct field
 type structField struct {
-	name	*string;
-	pkgPath	*string;
-	typ	*runtime.Type;
-	tag	*string;
-	offset	uintptr;
+	name    *string
+	pkgPath *string
+	typ     *runtime.Type
+	tag     *string
+	offset  uintptr
 }
 
 // StructType represents a struct type.
 type StructType struct {
-	commonType;
-	fields	[]structField;
+	commonType
+	fields []structField
 }
 
 
@@ -237,10 +237,10 @@ type StructType struct {
 
 // Method represents a single method.
 type Method struct {
-	PkgPath	string;	// empty for uppercase Name
-	Name	string;
-	Type	*FuncType;
-	Func	*FuncValue;
+	PkgPath string // empty for uppercase Name
+	Name    string
+	Type    *FuncType
+	Func    *FuncValue
 }
 
 // Type is the runtime representation of a Go type.
@@ -253,37 +253,37 @@ type Type interface {
 	// PkgPath returns the type's package path.
 	// The package path is a full package import path like "container/vector".
 	// PkgPath returns an empty string for unnamed types.
-	PkgPath() string;
+	PkgPath() string
 
 	// Name returns the type's name within its package.
 	// Name returns an empty string for unnamed types.
-	Name() string;
+	Name() string
 
 	// String returns a string representation of the type.
 	// The string representation may use shortened package names
 	// (e.g., vector instead of "container/vector") and is not
 	// guaranteed to be unique among types.  To test for equality,
 	// compare the Types directly.
-	String() string;
+	String() string
 
 	// Size returns the number of bytes needed to store
 	// a value of the given type; it is analogous to unsafe.Sizeof.
-	Size() uintptr;
+	Size() uintptr
 
 	// Align returns the alignment of a value of this type
 	// when allocated in memory.
-	Align() int;
+	Align() int
 
 	// FieldAlign returns the alignment of a value of this type
 	// when used as a field in a struct.
-	FieldAlign() int;
+	FieldAlign() int
 
 	// For non-interface types, Method returns the i'th method with receiver T.
 	// For interface types, Method returns the i'th method in the interface.
 	// NumMethod returns the number of such methods.
-	Method(int) Method;
-	NumMethod() int;
-	uncommon() *uncommonType;
+	Method(int) Method
+	NumMethod() int
+	uncommon() *uncommonType
 }
 
 func (t *uncommonType) uncommon() *uncommonType {
@@ -294,70 +294,70 @@ func (t *uncommonType) PkgPath() string {
 	if t == nil || t.pkgPath == nil {
 		return ""
 	}
-	return *t.pkgPath;
+	return *t.pkgPath
 }
 
 func (t *uncommonType) Name() string {
 	if t == nil || t.name == nil {
 		return ""
 	}
-	return *t.name;
+	return *t.name
 }
 
-func (t *commonType) String() string	{ return *t.string }
+func (t *commonType) String() string { return *t.string }
 
-func (t *commonType) Size() uintptr	{ return t.size }
+func (t *commonType) Size() uintptr { return t.size }
 
-func (t *commonType) Align() int	{ return int(t.align) }
+func (t *commonType) Align() int { return int(t.align) }
 
-func (t *commonType) FieldAlign() int	{ return int(t.fieldAlign) }
+func (t *commonType) FieldAlign() int { return int(t.fieldAlign) }
 
 func (t *uncommonType) Method(i int) (m Method) {
 	if t == nil || i < 0 || i >= len(t.methods) {
 		return
 	}
-	p := &t.methods[i];
+	p := &t.methods[i]
 	if p.name != nil {
 		m.Name = *p.name
 	}
 	if p.pkgPath != nil {
 		m.PkgPath = *p.pkgPath
 	}
-	m.Type = toType(*p.typ).(*FuncType);
-	fn := p.tfn;
-	m.Func = newFuncValue(m.Type, addr(&fn), true);
-	return;
+	m.Type = toType(*p.typ).(*FuncType)
+	fn := p.tfn
+	m.Func = newFuncValue(m.Type, addr(&fn), true)
+	return
 }
 
 func (t *uncommonType) NumMethod() int {
 	if t == nil {
 		return 0
 	}
-	return len(t.methods);
+	return len(t.methods)
 }
 
 // TODO(rsc): 6g supplies these, but they are not
 // as efficient as they could be: they have commonType
 // as the receiver instead of *commonType.
-func (t *commonType) NumMethod() int	{ return t.uncommonType.NumMethod() }
+func (t *commonType) NumMethod() int { return t.uncommonType.NumMethod() }
 
-func (t *commonType) Method(i int) (m Method)	{ return t.uncommonType.Method(i) }
+func (t *commonType) Method(i int) (m Method) { return t.uncommonType.Method(i) }
 
-func (t *commonType) PkgPath() string	{ return t.uncommonType.PkgPath() }
+func (t *commonType) PkgPath() string { return t.uncommonType.PkgPath() }
 
-func (t *commonType) Name() string	{ return t.uncommonType.Name() }
+func (t *commonType) Name() string { return t.uncommonType.Name() }
 
 // Len returns the number of elements in the array.
-func (t *ArrayType) Len() int	{ return int(t.len) }
+func (t *ArrayType) Len() int { return int(t.len) }
 
 // Elem returns the type of the array's elements.
-func (t *ArrayType) Elem() Type	{ return toType(*t.elem) }
+func (t *ArrayType) Elem() Type { return toType(*t.elem) }
 
 // Dir returns the channel direction.
-func (t *ChanType) Dir() ChanDir	{ return ChanDir(t.dir) }
+func (t *ChanType) Dir() ChanDir { return ChanDir(t.dir) }
 
 // Elem returns the channel's element type.
-func (t *ChanType) Elem() Type	{ return toType(*t.elem) }
+func (t *ChanType) Elem() Type { return toType(*t.elem) }
 
 func (d ChanDir) String() string {
 	switch d {
@@ -368,7 +368,7 @@ func (d ChanDir) String() string {
 	case BothDir:
 		return "chan"
 	}
-	return "ChanDir" + strconv.Itoa(int(d));
+	return "ChanDir" + strconv.Itoa(int(d))
 }
 
 // In returns the type of the i'th function input parameter.
@@ -376,60 +376,60 @@ func (t *FuncType) In(i int) Type {
 	if i < 0 || i >= len(t.in) {
 		return nil
 	}
-	return toType(*t.in[i]);
+	return toType(*t.in[i])
 }
 
 // NumIn returns the number of input parameters.
-func (t *FuncType) NumIn() int	{ return len(t.in) }
+func (t *FuncType) NumIn() int { return len(t.in) }
 
 // Out returns the type of the i'th function output parameter.
 func (t *FuncType) Out(i int) Type {
 	if i < 0 || i >= len(t.out) {
 		return nil
 	}
-	return toType(*t.out[i]);
+	return toType(*t.out[i])
 }
 
 // NumOut returns the number of function output parameters.
-func (t *FuncType) NumOut() int	{ return len(t.out) }
+func (t *FuncType) NumOut() int { return len(t.out) }
 
 // Method returns the i'th interface method.
 func (t *InterfaceType) Method(i int) (m Method) {
 	if i < 0 || i >= len(t.methods) {
 		return
 	}
-	p := &t.methods[i];
-	m.Name = *p.name;
+	p := &t.methods[i]
+	m.Name = *p.name
 	if p.pkgPath != nil {
 		m.PkgPath = *p.pkgPath
 	}
-	m.Type = toType(*p.typ).(*FuncType);
-	return;
+	m.Type = toType(*p.typ).(*FuncType)
+	return
 }
 
 // NumMethod returns the number of interface methods.
-func (t *InterfaceType) NumMethod() int	{ return len(t.methods) }
+func (t *InterfaceType) NumMethod() int { return len(t.methods) }
 
 // Key returns the map key type.
-func (t *MapType) Key() Type	{ return toType(*t.key) }
+func (t *MapType) Key() Type { return toType(*t.key) }
 
 // Elem returns the map element type.
-func (t *MapType) Elem() Type	{ return toType(*t.elem) }
+func (t *MapType) Elem() Type { return toType(*t.elem) }
 
 // Elem returns the pointer element type.
-func (t *PtrType) Elem() Type	{ return toType(*t.elem) }
+func (t *PtrType) Elem() Type { return toType(*t.elem) }
 
 // Elem returns the type of the slice's elements.
-func (t *SliceType) Elem() Type	{ return toType(*t.elem) }
+func (t *SliceType) Elem() Type { return toType(*t.elem) }
 
 type StructField struct {
-	PkgPath		string;	// empty for uppercase Name
-	Name		string;
-	Type		Type;
-	Tag		string;
-	Offset		uintptr;
-	Index		[]int;
-	Anonymous	bool;
+	PkgPath   string // empty for uppercase Name
+	Name      string
+	Type      Type
+	Tag       string
+	Offset    uintptr
+	Index     []int
+	Anonymous bool
 }
 
 // Field returns the i'th struct field.
@@ -437,17 +437,17 @@ func (t *StructType) Field(i int) (f StructField) {
 	if i < 0 || i >= len(t.fields) {
 		return
 	}
-	p := t.fields[i];
-	f.Type = toType(*p.typ);
+	p := t.fields[i]
+	f.Type = toType(*p.typ)
 	if p.name != nil {
 		f.Name = *p.name
 	} else {
-		t := f.Type;
+		t := f.Type
 		if pt, ok := t.(*PtrType); ok {
 			t = pt.Elem()
 		}
-		f.Name = t.Name();
-		f.Anonymous = true;
+		f.Name = t.Name()
+		f.Anonymous = true
 	}
 	if p.pkgPath != nil {
 		f.PkgPath = *p.pkgPath
@@ -455,9 +455,9 @@ func (t *StructType) Field(i int) (f StructField) {
 	if p.tag != nil {
 		f.Tag = *p.tag
 	}
-	f.Offset = p.offset;
-	f.Index = []int{i};
-	return;
+	f.Offset = p.offset
+	f.Index = []int{i}
+	return
 }
 
 // TODO(gri): Should there be an error/bool indicator if the index
@@ -467,45 +467,45 @@ func (t *StructType) Field(i int) (f StructField) {
 func (t *StructType) FieldByIndex(index []int) (f StructField) {
 	for i, x := range index {
 		if i > 0 {
-			ft := f.Type;
+			ft := f.Type
 			if pt, ok := ft.(*PtrType); ok {
 				ft = pt.Elem()
 			}
 			if st, ok := ft.(*StructType); ok {
 				t = st
 			} else {
-				var f0 StructField;
-				f = f0;
-				return;
+				var f0 StructField
+				f = f0
+				return
 			}
 		}
-		f = t.Field(x);
+		f = t.Field(x)
 	}
-	return;
+	return
 }
 
-const inf = 1 << 30	// infinity - no struct has that many nesting levels
+const inf = 1 << 30 // infinity - no struct has that many nesting levels
 
 func (t *StructType) fieldByName(name string, mark map[*StructType]bool, depth int) (ff StructField, fd int) {
-	fd = inf;	// field depth
+	fd = inf // field depth
 
 	if _, marked := mark[t]; marked {
 		// Struct already seen.
 		return
 	}
-	mark[t] = true;
+	mark[t] = true
 
-	var fi int;	// field index
-	n := 0;		// number of matching fields at depth fd
-L:	for i, _ := range t.fields {
-		f := t.Field(i);
-		d := inf;
+	var fi int // field index
+	n := 0     // number of matching fields at depth fd
+L: for i, _ := range t.fields {
+		f := t.Field(i)
+		d := inf
 		switch {
 		case f.Name == name:
 			// Matching top-level field.
 			d = depth
 		case f.Anonymous:
-			ft := f.Type;
+			ft := f.Type
 			if pt, ok := ft.(*PtrType); ok {
 				ft = pt.Elem()
 			}
@@ -524,12 +524,12 @@ L:	for i, _ := range t.fields {
 		switch {
 		case d < fd:
 			// Found field at shallower depth.
-			ff, fi, fd = f, i, d;
-			n = 1;
+			ff, fi, fd = f, i, d
+			n = 1
 		case d == fd:
 			// More than one matching field at the same depth (or d, fd == inf).
 			// Same as no field found at this depth.
-			n++;
+			n++
 			if d == depth {
 				// Impossible to find a field at lower depth.
 				break L
@@ -542,28 +542,28 @@ L:	for i, _ := range t.fields {
 		if len(ff.Index) <= depth {
 			ff.Index = make([]int, depth+1)
 		}
-		ff.Index[depth] = fi;
+		ff.Index[depth] = fi
 	} else {
 		// None or more than one matching field found.
 		fd = inf
 	}
 
-	mark[t] = false, false;
-	return;
+	mark[t] = false, false
+	return
 }
 
 // FieldByName returns the struct field with the given name
 // and a boolean to indicate if the field was found.
 func (t *StructType) FieldByName(name string) (f StructField, present bool) {
 	if ff, fd := t.fieldByName(name, make(map[*StructType]bool), 0); fd < inf {
-		ff.Index = ff.Index[0 : fd+1];
-		f, present = ff, true;
+		ff.Index = ff.Index[0 : fd+1]
+		f, present = ff, true
 	}
-	return;
+	return
 }
 
 // NumField returns the number of struct fields.
-func (t *StructType) NumField() int	{ return len(t.fields) }
+func (t *StructType) NumField() int { return len(t.fields) }
 
 // Convert runtime type to reflect type.
 // Same memory layouts, different method sets.
@@ -624,15 +624,15 @@ func toType(i interface{}) Type {
 	case *runtime.StructType:
 		return (*StructType)(unsafe.Pointer(v))
 	}
-	panicln("toType", i);
+	panicln("toType", i)
 }
 
 // ArrayOrSliceType is the common interface implemented
 // by both ArrayType and SliceType.
 type ArrayOrSliceType interface {
-	Type;
-	Elem() Type;
+	Type
+	Elem() Type
 }
 
 // Typeof returns the reflection Type of the value in the interface{}.
-func Typeof(i interface{}) Type	{ return toType(unsafe.Typeof(i)) }
+func Typeof(i interface{}) Type { return toType(unsafe.Typeof(i)) }
diff --git a/src/pkg/reflect/value.go b/src/pkg/reflect/value.go
index 34393f953d..bbc66de5e7 100644
--- a/src/pkg/reflect/value.go
+++ b/src/pkg/reflect/value.go
@@ -5,8 +5,8 @@
 package reflect
 
 import (
-	"runtime";
-	"unsafe";
+	"runtime"
+	"unsafe"
 )
 
 const ptrSize = uintptr(unsafe.Sizeof((*byte)(nil)))
@@ -17,15 +17,15 @@ type addr unsafe.Pointer
 // TODO: This will have to go away when
 // the new gc goes in.
 func memmove(adst, asrc addr, n uintptr) {
-	dst := uintptr(adst);
-	src := uintptr(asrc);
+	dst := uintptr(adst)
+	src := uintptr(asrc)
 	switch {
 	case src < dst && src+n > dst:
 		// byte copy backward
 		// careful: i is unsigned
 		for i := n; i > 0; {
-			i--;
-			*(*byte)(addr(dst + i)) = *(*byte)(addr(src + i));
+			i--
+			*(*byte)(addr(dst + i)) = *(*byte)(addr(src + i))
 		}
 	case (n|src|dst)&(ptrSize-1) != 0:
 		// byte copy forward
@@ -45,46 +45,46 @@ func memmove(adst, asrc addr, n uintptr) {
 // have additional type-specific methods.
 type Value interface {
 	// Type returns the value's type.
-	Type() Type;
+	Type() Type
 
 	// Interface returns the value as an interface{}.
-	Interface() interface{};
+	Interface() interface{}
 
 	// CanSet returns whether the value can be changed.
 	// Values obtained by the use of non-exported struct fields
 	// can be used in Get but not Set.
 	// If CanSet() returns false, calling the type-specific Set
 	// will cause a crash.
-	CanSet() bool;
+	CanSet() bool
 
 	// SetValue assigns v to the value; v must have the same type as the value.
-	SetValue(v Value);
+	SetValue(v Value)
 
 	// Addr returns a pointer to the underlying data.
 	// It is for advanced clients that also
 	// import the "unsafe" package.
-	Addr() uintptr;
+	Addr() uintptr
 
 	// Method returns a FuncValue corresponding to the value's i'th method.
 	// The arguments to a Call on the returned FuncValue
 	// should not include a receiver; the FuncValue will use
 	// the value as the receiver.
-	Method(i int) *FuncValue;
+	Method(i int) *FuncValue
 
-	getAddr() addr;
+	getAddr() addr
 }
 
 type value struct {
-	typ	Type;
-	addr	addr;
-	canSet	bool;
+	typ    Type
+	addr   addr
+	canSet bool
 }
 
-func (v *value) Type() Type	{ return v.typ }
+func (v *value) Type() Type { return v.typ }
 
-func (v *value) Addr() uintptr	{ return uintptr(v.addr) }
+func (v *value) Addr() uintptr { return uintptr(v.addr) }
 
-func (v *value) getAddr() addr	{ return v.addr }
+func (v *value) getAddr() addr { return v.addr }
 
 func (v *value) Interface() interface{} {
 	if typ, ok := v.typ.(*InterfaceType); ok {
@@ -98,13 +98,13 @@ func (v *value) Interface() interface{} {
 		}
 		// Extract from v.addr as interface value with methods.
 		return *(*interface {
-			m();
-		})(v.addr);
+			m()
+		})(v.addr)
 	}
-	return unsafe.Unreflect(v.typ, unsafe.Pointer(v.addr));
+	return unsafe.Unreflect(v.typ, unsafe.Pointer(v.addr))
 }
 
-func (v *value) CanSet() bool	{ return v.canSet }
+func (v *value) CanSet() bool { return v.canSet }
 
 /*
  * basic types
@@ -112,325 +112,325 @@ func (v *value) CanSet() bool	{ return v.canSet }
 
 // BoolValue represents a bool value.
 type BoolValue struct {
-	value;
+	value
 }
 
 // Get returns the underlying bool value.
-func (v *BoolValue) Get() bool	{ return *(*bool)(v.addr) }
+func (v *BoolValue) Get() bool { return *(*bool)(v.addr) }
 
 // Set sets v to the value x.
 func (v *BoolValue) Set(x bool) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	*(*bool)(v.addr) = x;
+	*(*bool)(v.addr) = x
 }
 
 // Set sets v to the value x.
-func (v *BoolValue) SetValue(x Value)	{ v.Set(x.(*BoolValue).Get()) }
+func (v *BoolValue) SetValue(x Value) { v.Set(x.(*BoolValue).Get()) }
 
 // FloatValue represents a float value.
 type FloatValue struct {
-	value;
+	value
 }
 
 // Get returns the underlying float value.
-func (v *FloatValue) Get() float	{ return *(*float)(v.addr) }
+func (v *FloatValue) Get() float { return *(*float)(v.addr) }
 
 // Set sets v to the value x.
 func (v *FloatValue) Set(x float) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	*(*float)(v.addr) = x;
+	*(*float)(v.addr) = x
 }
 
 // Set sets v to the value x.
-func (v *FloatValue) SetValue(x Value)	{ v.Set(x.(*FloatValue).Get()) }
+func (v *FloatValue) SetValue(x Value) { v.Set(x.(*FloatValue).Get()) }
 
 // Float32Value represents a float32 value.
 type Float32Value struct {
-	value;
+	value
 }
 
 // Get returns the underlying float32 value.
-func (v *Float32Value) Get() float32	{ return *(*float32)(v.addr) }
+func (v *Float32Value) Get() float32 { return *(*float32)(v.addr) }
 
 // Set sets v to the value x.
 func (v *Float32Value) Set(x float32) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	*(*float32)(v.addr) = x;
+	*(*float32)(v.addr) = x
 }
 
 // Set sets v to the value x.
-func (v *Float32Value) SetValue(x Value)	{ v.Set(x.(*Float32Value).Get()) }
+func (v *Float32Value) SetValue(x Value) { v.Set(x.(*Float32Value).Get()) }
 
 // Float64Value represents a float64 value.
 type Float64Value struct {
-	value;
+	value
 }
 
 // Get returns the underlying float64 value.
-func (v *Float64Value) Get() float64	{ return *(*float64)(v.addr) }
+func (v *Float64Value) Get() float64 { return *(*float64)(v.addr) }
 
 // Set sets v to the value x.
 func (v *Float64Value) Set(x float64) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	*(*float64)(v.addr) = x;
+	*(*float64)(v.addr) = x
 }
 
 // Set sets v to the value x.
-func (v *Float64Value) SetValue(x Value)	{ v.Set(x.(*Float64Value).Get()) }
+func (v *Float64Value) SetValue(x Value) { v.Set(x.(*Float64Value).Get()) }
 
 // IntValue represents an int value.
 type IntValue struct {
-	value;
+	value
 }
 
 // Get returns the underlying int value.
-func (v *IntValue) Get() int	{ return *(*int)(v.addr) }
+func (v *IntValue) Get() int { return *(*int)(v.addr) }
 
 // Set sets v to the value x.
 func (v *IntValue) Set(x int) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	*(*int)(v.addr) = x;
+	*(*int)(v.addr) = x
 }
 
 // Set sets v to the value x.
-func (v *IntValue) SetValue(x Value)	{ v.Set(x.(*IntValue).Get()) }
+func (v *IntValue) SetValue(x Value) { v.Set(x.(*IntValue).Get()) }
 
 // Int8Value represents an int8 value.
 type Int8Value struct {
-	value;
+	value
 }
 
 // Get returns the underlying int8 value.
-func (v *Int8Value) Get() int8	{ return *(*int8)(v.addr) }
+func (v *Int8Value) Get() int8 { return *(*int8)(v.addr) }
 
 // Set sets v to the value x.
 func (v *Int8Value) Set(x int8) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	*(*int8)(v.addr) = x;
+	*(*int8)(v.addr) = x
 }
 
 // Set sets v to the value x.
-func (v *Int8Value) SetValue(x Value)	{ v.Set(x.(*Int8Value).Get()) }
+func (v *Int8Value) SetValue(x Value) { v.Set(x.(*Int8Value).Get()) }
 
 // Int16Value represents an int16 value.
 type Int16Value struct {
-	value;
+	value
 }
 
 // Get returns the underlying int16 value.
-func (v *Int16Value) Get() int16	{ return *(*int16)(v.addr) }
+func (v *Int16Value) Get() int16 { return *(*int16)(v.addr) }
 
 // Set sets v to the value x.
 func (v *Int16Value) Set(x int16) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	*(*int16)(v.addr) = x;
+	*(*int16)(v.addr) = x
 }
 
 // Set sets v to the value x.
-func (v *Int16Value) SetValue(x Value)	{ v.Set(x.(*Int16Value).Get()) }
+func (v *Int16Value) SetValue(x Value) { v.Set(x.(*Int16Value).Get()) }
 
 // Int32Value represents an int32 value.
 type Int32Value struct {
-	value;
+	value
 }
 
 // Get returns the underlying int32 value.
-func (v *Int32Value) Get() int32	{ return *(*int32)(v.addr) }
+func (v *Int32Value) Get() int32 { return *(*int32)(v.addr) }
 
 // Set sets v to the value x.
 func (v *Int32Value) Set(x int32) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	*(*int32)(v.addr) = x;
+	*(*int32)(v.addr) = x
 }
 
 // Set sets v to the value x.
-func (v *Int32Value) SetValue(x Value)	{ v.Set(x.(*Int32Value).Get()) }
+func (v *Int32Value) SetValue(x Value) { v.Set(x.(*Int32Value).Get()) }
 
 // Int64Value represents an int64 value.
 type Int64Value struct {
-	value;
+	value
 }
 
 // Get returns the underlying int64 value.
-func (v *Int64Value) Get() int64	{ return *(*int64)(v.addr) }
+func (v *Int64Value) Get() int64 { return *(*int64)(v.addr) }
 
 // Set sets v to the value x.
 func (v *Int64Value) Set(x int64) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	*(*int64)(v.addr) = x;
+	*(*int64)(v.addr) = x
 }
 
 // Set sets v to the value x.
-func (v *Int64Value) SetValue(x Value)	{ v.Set(x.(*Int64Value).Get()) }
+func (v *Int64Value) SetValue(x Value) { v.Set(x.(*Int64Value).Get()) }
 
 // StringValue represents a string value.
 type StringValue struct {
-	value;
+	value
 }
 
 // Get returns the underlying string value.
-func (v *StringValue) Get() string	{ return *(*string)(v.addr) }
+func (v *StringValue) Get() string { return *(*string)(v.addr) }
 
 // Set sets v to the value x.
 func (v *StringValue) Set(x string) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	*(*string)(v.addr) = x;
+	*(*string)(v.addr) = x
 }
 
 // Set sets v to the value x.
-func (v *StringValue) SetValue(x Value)	{ v.Set(x.(*StringValue).Get()) }
+func (v *StringValue) SetValue(x Value) { v.Set(x.(*StringValue).Get()) }
 
 // UintValue represents a uint value.
 type UintValue struct {
-	value;
+	value
 }
 
 // Get returns the underlying uint value.
-func (v *UintValue) Get() uint	{ return *(*uint)(v.addr) }
+func (v *UintValue) Get() uint { return *(*uint)(v.addr) }
 
 // Set sets v to the value x.
 func (v *UintValue) Set(x uint) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	*(*uint)(v.addr) = x;
+	*(*uint)(v.addr) = x
 }
 
 // Set sets v to the value x.
-func (v *UintValue) SetValue(x Value)	{ v.Set(x.(*UintValue).Get()) }
+func (v *UintValue) SetValue(x Value) { v.Set(x.(*UintValue).Get()) }
 
 // Uint8Value represents a uint8 value.
 type Uint8Value struct {
-	value;
+	value
 }
 
 // Get returns the underlying uint8 value.
-func (v *Uint8Value) Get() uint8	{ return *(*uint8)(v.addr) }
+func (v *Uint8Value) Get() uint8 { return *(*uint8)(v.addr) }
 
 // Set sets v to the value x.
 func (v *Uint8Value) Set(x uint8) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	*(*uint8)(v.addr) = x;
+	*(*uint8)(v.addr) = x
 }
 
 // Set sets v to the value x.
-func (v *Uint8Value) SetValue(x Value)	{ v.Set(x.(*Uint8Value).Get()) }
+func (v *Uint8Value) SetValue(x Value) { v.Set(x.(*Uint8Value).Get()) }
 
 // Uint16Value represents a uint16 value.
 type Uint16Value struct {
-	value;
+	value
 }
 
 // Get returns the underlying uint16 value.
-func (v *Uint16Value) Get() uint16	{ return *(*uint16)(v.addr) }
+func (v *Uint16Value) Get() uint16 { return *(*uint16)(v.addr) }
 
 // Set sets v to the value x.
 func (v *Uint16Value) Set(x uint16) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	*(*uint16)(v.addr) = x;
+	*(*uint16)(v.addr) = x
 }
 
 // Set sets v to the value x.
-func (v *Uint16Value) SetValue(x Value)	{ v.Set(x.(*Uint16Value).Get()) }
+func (v *Uint16Value) SetValue(x Value) { v.Set(x.(*Uint16Value).Get()) }
 
 // Uint32Value represents a uint32 value.
 type Uint32Value struct {
-	value;
+	value
 }
 
 // Get returns the underlying uint32 value.
-func (v *Uint32Value) Get() uint32	{ return *(*uint32)(v.addr) }
+func (v *Uint32Value) Get() uint32 { return *(*uint32)(v.addr) }
 
 // Set sets v to the value x.
 func (v *Uint32Value) Set(x uint32) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	*(*uint32)(v.addr) = x;
+	*(*uint32)(v.addr) = x
 }
 
 // Set sets v to the value x.
-func (v *Uint32Value) SetValue(x Value)	{ v.Set(x.(*Uint32Value).Get()) }
+func (v *Uint32Value) SetValue(x Value) { v.Set(x.(*Uint32Value).Get()) }
 
 // Uint64Value represents a uint64 value.
 type Uint64Value struct {
-	value;
+	value
 }
 
 // Get returns the underlying uint64 value.
-func (v *Uint64Value) Get() uint64	{ return *(*uint64)(v.addr) }
+func (v *Uint64Value) Get() uint64 { return *(*uint64)(v.addr) }
 
 // Set sets v to the value x.
 func (v *Uint64Value) Set(x uint64) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	*(*uint64)(v.addr) = x;
+	*(*uint64)(v.addr) = x
 }
 
 // Set sets v to the value x.
-func (v *Uint64Value) SetValue(x Value)	{ v.Set(x.(*Uint64Value).Get()) }
+func (v *Uint64Value) SetValue(x Value) { v.Set(x.(*Uint64Value).Get()) }
 
 // UintptrValue represents a uintptr value.
 type UintptrValue struct {
-	value;
+	value
 }
 
 // Get returns the underlying uintptr value.
-func (v *UintptrValue) Get() uintptr	{ return *(*uintptr)(v.addr) }
+func (v *UintptrValue) Get() uintptr { return *(*uintptr)(v.addr) }
 
 // Set sets v to the value x.
 func (v *UintptrValue) Set(x uintptr) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	*(*uintptr)(v.addr) = x;
+	*(*uintptr)(v.addr) = x
 }
 
 // Set sets v to the value x.
-func (v *UintptrValue) SetValue(x Value)	{ v.Set(x.(*UintptrValue).Get()) }
+func (v *UintptrValue) SetValue(x Value) { v.Set(x.(*UintptrValue).Get()) }
 
 // UnsafePointerValue represents an unsafe.Pointer value.
 type UnsafePointerValue struct {
-	value;
+	value
 }
 
 // Get returns the underlying uintptr value.
 // Get returns uintptr, not unsafe.Pointer, so that
 // programs that do not import "unsafe" cannot
 // obtain a value of unsafe.Pointer type from "reflect".
-func (v *UnsafePointerValue) Get() uintptr	{ return uintptr(*(*unsafe.Pointer)(v.addr)) }
+func (v *UnsafePointerValue) Get() uintptr { return uintptr(*(*unsafe.Pointer)(v.addr)) }
 
 // Set sets v to the value x.
 func (v *UnsafePointerValue) Set(x unsafe.Pointer) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	*(*unsafe.Pointer)(v.addr) = x;
+	*(*unsafe.Pointer)(v.addr) = x
 }
 
 // Set sets v to the value x.
@@ -451,11 +451,11 @@ func typesMustMatch(t1, t2 Type) {
 // ArrayOrSliceValue is the common interface
 // implemented by both ArrayValue and SliceValue.
 type ArrayOrSliceValue interface {
-	Value;
-	Len() int;
-	Cap() int;
-	Elem(i int) Value;
-	addr() addr;
+	Value
+	Len() int
+	Cap() int
+	Elem(i int) Value
+	addr() addr
 }
 
 // ArrayCopy copies the contents of src into dst until either
@@ -465,30 +465,30 @@ type ArrayOrSliceValue interface {
 func ArrayCopy(dst, src ArrayOrSliceValue) int {
 	// TODO: This will have to move into the runtime
 	// once the real gc goes in.
-	de := dst.Type().(ArrayOrSliceType).Elem();
-	se := src.Type().(ArrayOrSliceType).Elem();
-	typesMustMatch(de, se);
-	n := dst.Len();
+	de := dst.Type().(ArrayOrSliceType).Elem()
+	se := src.Type().(ArrayOrSliceType).Elem()
+	typesMustMatch(de, se)
+	n := dst.Len()
 	if xn := src.Len(); n > xn {
 		n = xn
 	}
-	memmove(dst.addr(), src.addr(), uintptr(n)*de.Size());
-	return n;
+	memmove(dst.addr(), src.addr(), uintptr(n)*de.Size())
+	return n
 }
 
 // An ArrayValue represents an array.
 type ArrayValue struct {
-	value;
+	value
 }
 
 // Len returns the length of the array.
-func (v *ArrayValue) Len() int	{ return v.typ.(*ArrayType).Len() }
+func (v *ArrayValue) Len() int { return v.typ.(*ArrayType).Len() }
 
 // Cap returns the capacity of the array (equal to Len()).
-func (v *ArrayValue) Cap() int	{ return v.typ.(*ArrayType).Len() }
+func (v *ArrayValue) Cap() int { return v.typ.(*ArrayType).Len() }
 
 // addr returns the base address of the data in the array.
-func (v *ArrayValue) addr() addr	{ return v.value.addr }
+func (v *ArrayValue) addr() addr { return v.value.addr }
 
 // Set assigns x to v.
 // The new value x must have the same type as v.
@@ -496,22 +496,22 @@ func (v *ArrayValue) Set(x *ArrayValue) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	typesMustMatch(v.typ, x.typ);
-	ArrayCopy(v, x);
+	typesMustMatch(v.typ, x.typ)
+	ArrayCopy(v, x)
 }
 
 // Set sets v to the value x.
-func (v *ArrayValue) SetValue(x Value)	{ v.Set(x.(*ArrayValue)) }
+func (v *ArrayValue) SetValue(x Value) { v.Set(x.(*ArrayValue)) }
 
 // Elem returns the i'th element of v.
 func (v *ArrayValue) Elem(i int) Value {
-	typ := v.typ.(*ArrayType).Elem();
-	n := v.Len();
+	typ := v.typ.(*ArrayType).Elem()
+	n := v.Len()
 	if i < 0 || i >= n {
 		panic("index", i, "in array len", n)
 	}
-	p := addr(uintptr(v.addr()) + uintptr(i)*typ.Size());
-	return newValue(typ, p, v.canSet);
+	p := addr(uintptr(v.addr()) + uintptr(i)*typ.Size())
+	return newValue(typ, p, v.canSet)
 }
 
 /*
@@ -520,38 +520,38 @@ func (v *ArrayValue) Elem(i int) Value {
 
 // runtime representation of slice
 type SliceHeader struct {
-	Data	uintptr;
-	Len	int;
-	Cap	int;
+	Data uintptr
+	Len  int
+	Cap  int
 }
 
 // A SliceValue represents a slice.
 type SliceValue struct {
-	value;
+	value
 }
 
-func (v *SliceValue) slice() *SliceHeader	{ return (*SliceHeader)(v.value.addr) }
+func (v *SliceValue) slice() *SliceHeader { return (*SliceHeader)(v.value.addr) }
 
 // IsNil returns whether v is a nil slice.
-func (v *SliceValue) IsNil() bool	{ return v.slice().Data == 0 }
+func (v *SliceValue) IsNil() bool { return v.slice().Data == 0 }
 
 // Len returns the length of the slice.
-func (v *SliceValue) Len() int	{ return int(v.slice().Len) }
+func (v *SliceValue) Len() int { return int(v.slice().Len) }
 
 // Cap returns the capacity of the slice.
-func (v *SliceValue) Cap() int	{ return int(v.slice().Cap) }
+func (v *SliceValue) Cap() int { return int(v.slice().Cap) }
 
 // addr returns the base address of the data in the slice.
-func (v *SliceValue) addr() addr	{ return addr(v.slice().Data) }
+func (v *SliceValue) addr() addr { return addr(v.slice().Data) }
 
 // SetLen changes the length of v.
 // The new length n must be between 0 and the capacity, inclusive.
 func (v *SliceValue) SetLen(n int) {
-	s := v.slice();
+	s := v.slice()
 	if n < 0 || n > int(s.Cap) {
 		panicln("SetLen", n, "with capacity", s.Cap)
 	}
-	s.Len = n;
+	s.Len = n
 }
 
 // Set assigns x to v.
@@ -560,36 +560,36 @@ func (v *SliceValue) Set(x *SliceValue) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	typesMustMatch(v.typ, x.typ);
-	*v.slice() = *x.slice();
+	typesMustMatch(v.typ, x.typ)
+	*v.slice() = *x.slice()
 }
 
 // Set sets v to the value x.
-func (v *SliceValue) SetValue(x Value)	{ v.Set(x.(*SliceValue)) }
+func (v *SliceValue) SetValue(x Value) { v.Set(x.(*SliceValue)) }
 
 // Slice returns a sub-slice of the slice v.
 func (v *SliceValue) Slice(beg, end int) *SliceValue {
-	cap := v.Cap();
+	cap := v.Cap()
 	if beg < 0 || end < beg || end > cap {
 		panic("slice bounds [", beg, ":", end, "] with capacity ", cap)
 	}
-	typ := v.typ.(*SliceType);
-	s := new(SliceHeader);
-	s.Data = uintptr(v.addr()) + uintptr(beg)*typ.Elem().Size();
-	s.Len = end - beg;
-	s.Cap = cap - beg;
-	return newValue(typ, addr(s), v.canSet).(*SliceValue);
+	typ := v.typ.(*SliceType)
+	s := new(SliceHeader)
+	s.Data = uintptr(v.addr()) + uintptr(beg)*typ.Elem().Size()
+	s.Len = end - beg
+	s.Cap = cap - beg
+	return newValue(typ, addr(s), v.canSet).(*SliceValue)
 }
 
 // Elem returns the i'th element of v.
 func (v *SliceValue) Elem(i int) Value {
-	typ := v.typ.(*SliceType).Elem();
-	n := v.Len();
+	typ := v.typ.(*SliceType).Elem()
+	n := v.Len()
 	if i < 0 || i >= n {
 		panicln("index", i, "in array of length", n)
 	}
-	p := addr(uintptr(v.addr()) + uintptr(i)*typ.Size());
-	return newValue(typ, p, v.canSet);
+	p := addr(uintptr(v.addr()) + uintptr(i)*typ.Size())
+	return newValue(typ, p, v.canSet)
 }
 
 // MakeSlice creates a new zero-initialized slice value
@@ -599,8 +599,8 @@ func MakeSlice(typ *SliceType, len, cap int) *SliceValue {
 		Data: uintptr(unsafe.NewArray(typ.Elem(), cap)),
 		Len: len,
 		Cap: cap,
-	};
-	return newValue(typ, addr(s), true).(*SliceValue);
+	}
+	return newValue(typ, addr(s), true).(*SliceValue)
 }
 
 /*
@@ -609,11 +609,11 @@ func MakeSlice(typ *SliceType, len, cap int) *SliceValue {
 
 // A ChanValue represents a chan.
 type ChanValue struct {
-	value;
+	value
 }
 
 // IsNil returns whether v is a nil channel.
-func (v *ChanValue) IsNil() bool	{ return *(*uintptr)(v.addr) == 0 }
+func (v *ChanValue) IsNil() bool { return *(*uintptr)(v.addr) == 0 }
 
 // Set assigns x to v.
 // The new value x must have the same type as v.
@@ -621,16 +621,16 @@ func (v *ChanValue) Set(x *ChanValue) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	typesMustMatch(v.typ, x.typ);
-	*(*uintptr)(v.addr) = *(*uintptr)(x.addr);
+	typesMustMatch(v.typ, x.typ)
+	*(*uintptr)(v.addr) = *(*uintptr)(x.addr)
 }
 
 // Set sets v to the value x.
-func (v *ChanValue) SetValue(x Value)	{ v.Set(x.(*ChanValue)) }
+func (v *ChanValue) SetValue(x Value) { v.Set(x.(*ChanValue)) }
 
 // Get returns the uintptr value of v.
 // It is mainly useful for printing.
-func (v *ChanValue) Get() uintptr	{ return *(*uintptr)(v.addr) }
+func (v *ChanValue) Get() uintptr { return *(*uintptr)(v.addr) }
 
 // implemented in ../pkg/runtime/reflect.cgo
 func makechan(typ *runtime.ChanType, size uint32) (ch *byte)
@@ -643,72 +643,72 @@ func chancap(ch *byte) int32
 
 // Closed returns the result of closed(c) on the underlying channel.
 func (v *ChanValue) Closed() bool {
-	ch := *(**byte)(v.addr);
-	return chanclosed(ch);
+	ch := *(**byte)(v.addr)
+	return chanclosed(ch)
 }
 
 // Close closes the channel.
 func (v *ChanValue) Close() {
-	ch := *(**byte)(v.addr);
-	chanclose(ch);
+	ch := *(**byte)(v.addr)
+	chanclose(ch)
 }
 
 func (v *ChanValue) Len() int {
-	ch := *(**byte)(v.addr);
-	return int(chanlen(ch));
+	ch := *(**byte)(v.addr)
+	return int(chanlen(ch))
 }
 
 func (v *ChanValue) Cap() int {
-	ch := *(**byte)(v.addr);
-	return int(chancap(ch));
+	ch := *(**byte)(v.addr)
+	return int(chancap(ch))
 }
 
 // internal send; non-blocking if b != nil
 func (v *ChanValue) send(x Value, b *bool) {
-	t := v.Type().(*ChanType);
+	t := v.Type().(*ChanType)
 	if t.Dir()&SendDir == 0 {
 		panic("send on recv-only channel")
 	}
-	typesMustMatch(t.Elem(), x.Type());
-	ch := *(**byte)(v.addr);
-	chansend(ch, (*byte)(x.getAddr()), b);
+	typesMustMatch(t.Elem(), x.Type())
+	ch := *(**byte)(v.addr)
+	chansend(ch, (*byte)(x.getAddr()), b)
 }
 
 // internal recv; non-blocking if b != nil
 func (v *ChanValue) recv(b *bool) Value {
-	t := v.Type().(*ChanType);
+	t := v.Type().(*ChanType)
 	if t.Dir()&RecvDir == 0 {
 		panic("recv on send-only channel")
 	}
-	ch := *(**byte)(v.addr);
-	x := MakeZero(t.Elem());
-	chanrecv(ch, (*byte)(x.getAddr()), b);
-	return x;
+	ch := *(**byte)(v.addr)
+	x := MakeZero(t.Elem())
+	chanrecv(ch, (*byte)(x.getAddr()), b)
+	return x
 }
 
 // Send sends x on the channel v.
-func (v *ChanValue) Send(x Value)	{ v.send(x, nil) }
+func (v *ChanValue) Send(x Value) { v.send(x, nil) }
 
 // Recv receives and returns a value from the channel v.
-func (v *ChanValue) Recv() Value	{ return v.recv(nil) }
+func (v *ChanValue) Recv() Value { return v.recv(nil) }
 
 // TrySend attempts to sends x on the channel v but will not block.
 // It returns true if the value was sent, false otherwise.
 func (v *ChanValue) TrySend(x Value) bool {
-	var ok bool;
-	v.send(x, &ok);
-	return ok;
+	var ok bool
+	v.send(x, &ok)
+	return ok
 }
 
 // TryRecv attempts to receive a value from the channel v but will not block.
 // It returns the value if one is received, nil otherwise.
 func (v *ChanValue) TryRecv() Value {
-	var ok bool;
-	x := v.recv(&ok);
+	var ok bool
+	x := v.recv(&ok)
 	if !ok {
 		return nil
 	}
-	return x;
+	return x
 }
 
 // MakeChan creates a new channel with the specified type and buffer size.
@@ -719,9 +719,9 @@ func MakeChan(typ *ChanType, buffer int) *ChanValue {
 	if typ.Dir() != BothDir {
 		panic("MakeChan: unidirectional channel type")
 	}
-	v := MakeZero(typ).(*ChanValue);
-	*(**byte)(v.addr) = makechan((*runtime.ChanType)(unsafe.Pointer(typ)), uint32(buffer));
-	return v;
+	v := MakeZero(typ).(*ChanValue)
+	*(**byte)(v.addr) = makechan((*runtime.ChanType)(unsafe.Pointer(typ)), uint32(buffer))
+	return v
 }
 
 /*
@@ -730,17 +730,17 @@ func MakeChan(typ *ChanType, buffer int) *ChanValue {
 
 // A FuncValue represents a function value.
 type FuncValue struct {
-	value;
-	first		*value;
-	isInterface	bool;
+	value
+	first       *value
+	isInterface bool
 }
 
 // IsNil returns whether v is a nil function.
-func (v *FuncValue) IsNil() bool	{ return *(*uintptr)(v.addr) == 0 }
+func (v *FuncValue) IsNil() bool { return *(*uintptr)(v.addr) == 0 }
 
 // Get returns the uintptr value of v.
 // It is mainly useful for printing.
-func (v *FuncValue) Get() uintptr	{ return *(*uintptr)(v.addr) }
+func (v *FuncValue) Get() uintptr { return *(*uintptr)(v.addr) }
 
 // Set assigns x to v.
 // The new value x must have the same type as v.
@@ -748,71 +748,71 @@ func (v *FuncValue) Set(x *FuncValue) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	typesMustMatch(v.typ, x.typ);
-	*(*uintptr)(v.addr) = *(*uintptr)(x.addr);
+	typesMustMatch(v.typ, x.typ)
+	*(*uintptr)(v.addr) = *(*uintptr)(x.addr)
 }
 
 // Set sets v to the value x.
-func (v *FuncValue) SetValue(x Value)	{ v.Set(x.(*FuncValue)) }
+func (v *FuncValue) SetValue(x Value) { v.Set(x.(*FuncValue)) }
 
 // Method returns a FuncValue corresponding to v's i'th method.
 // The arguments to a Call on the returned FuncValue
 // should not include a receiver; the FuncValue will use v
 // as the receiver.
 func (v *value) Method(i int) *FuncValue {
-	t := v.Type().uncommon();
+	t := v.Type().uncommon()
 	if t == nil || i < 0 || i >= len(t.methods) {
 		return nil
 	}
-	p := &t.methods[i];
-	fn := p.tfn;
-	fv := &FuncValue{value: value{toType(*p.typ), addr(&fn), true}, first: v, isInterface: false};
-	return fv;
+	p := &t.methods[i]
+	fn := p.tfn
+	fv := &FuncValue{value: value{toType(*p.typ), addr(&fn), true}, first: v, isInterface: false}
+	return fv
 }
 
 // implemented in ../pkg/runtime/*/asm.s
 func call(fn, arg *byte, n uint32)
 
 type tiny struct {
-	b byte;
+	b byte
 }
 
 // Call calls the function v with input parameters in.
 // It returns the function's output parameters as Values.
 func (fv *FuncValue) Call(in []Value) []Value {
-	var structAlign = Typeof((*tiny)(nil)).(*PtrType).Elem().Size();
+	var structAlign = Typeof((*tiny)(nil)).(*PtrType).Elem().Size()
 
-	t := fv.Type().(*FuncType);
-	nin := len(in);
+	t := fv.Type().(*FuncType)
+	nin := len(in)
 	if fv.first != nil && !fv.isInterface {
 		nin++
 	}
 	if nin != t.NumIn() {
 		panic("FuncValue: wrong argument count")
 	}
-	nout := t.NumOut();
+	nout := t.NumOut()
 
 	// Compute arg size & allocate.
 	// This computation is 6g/8g-dependent
 	// and probably wrong for gccgo, but so
 	// is most of this function.
-	size := uintptr(0);
+	size := uintptr(0)
 	if fv.isInterface {
 		// extra word for interface value
 		size += ptrSize
 	}
 	for i := 0; i < nin; i++ {
-		tv := t.In(i);
-		a := uintptr(tv.Align());
-		size = (size + a - 1) &^ (a - 1);
-		size += tv.Size();
+		tv := t.In(i)
+		a := uintptr(tv.Align())
+		size = (size + a - 1) &^ (a - 1)
+		size += tv.Size()
 	}
-	size = (size + structAlign - 1) &^ (structAlign - 1);
+	size = (size + structAlign - 1) &^ (structAlign - 1)
 	for i := 0; i < nout; i++ {
-		tv := t.Out(i);
-		a := uintptr(tv.Align());
-		size = (size + a - 1) &^ (a - 1);
-		size += tv.Size();
+		tv := t.Out(i)
+		a := uintptr(tv.Align())
+		size = (size + a - 1) &^ (a - 1)
+		size += tv.Size()
 	}
 
 	// size must be > 0 in order for &args[0] to be valid.
@@ -821,8 +821,8 @@ func (fv *FuncValue) Call(in []Value) []Value {
 	if size < 8 {
 		size = 8
 	}
-	args := make([]byte, size);
-	ptr := uintptr(unsafe.Pointer(&args[0]));
+	args := make([]byte, size)
+	ptr := uintptr(unsafe.Pointer(&args[0]))
 
 	// Copy into args.
 	//
@@ -830,54 +830,54 @@ func (fv *FuncValue) Call(in []Value) []Value {
 	// This one may be fine.  The values are holding up the
 	// references for us, so maybe this can be treated
 	// like any stack-to-stack copy.
-	off := uintptr(0);
-	delta := 0;
+	off := uintptr(0)
+	delta := 0
 	if v := fv.first; v != nil {
 		// Hard-wired first argument.
 		if fv.isInterface {
 			// v is a single uninterpreted word
-			memmove(addr(ptr), v.getAddr(), ptrSize);
-			off = ptrSize;
+			memmove(addr(ptr), v.getAddr(), ptrSize)
+			off = ptrSize
 		} else {
 			// v is a real value
-			tv := v.Type();
-			typesMustMatch(t.In(0), tv);
-			n := tv.Size();
-			memmove(addr(ptr), v.getAddr(), n);
-			off = n;
-			delta = 1;
+			tv := v.Type()
+			typesMustMatch(t.In(0), tv)
+			n := tv.Size()
+			memmove(addr(ptr), v.getAddr(), n)
+			off = n
+			delta = 1
 		}
 	}
 	for i, v := range in {
-		tv := v.Type();
-		typesMustMatch(t.In(i+delta), tv);
-		a := uintptr(tv.Align());
-		off = (off + a - 1) &^ (a - 1);
-		n := tv.Size();
-		memmove(addr(ptr+off), v.getAddr(), n);
-		off += n;
+		tv := v.Type()
+		typesMustMatch(t.In(i+delta), tv)
+		a := uintptr(tv.Align())
+		off = (off + a - 1) &^ (a - 1)
+		n := tv.Size()
+		memmove(addr(ptr+off), v.getAddr(), n)
+		off += n
 	}
-	off = (off + structAlign - 1) &^ (structAlign - 1);
+	off = (off + structAlign - 1) &^ (structAlign - 1)
 
 	// Call
-	call(*(**byte)(fv.addr), (*byte)(addr(ptr)), uint32(size));
+	call(*(**byte)(fv.addr), (*byte)(addr(ptr)), uint32(size))
 
 	// Copy return values out of args.
 	//
 	// TODO(rsc): revisit like above.
-	ret := make([]Value, nout);
+	ret := make([]Value, nout)
 	for i := 0; i < nout; i++ {
-		tv := t.Out(i);
-		a := uintptr(tv.Align());
-		off = (off + a - 1) &^ (a - 1);
-		v := MakeZero(tv);
-		n := tv.Size();
-		memmove(v.getAddr(), addr(ptr+off), n);
-		ret[i] = v;
-		off += n;
+		tv := t.Out(i)
+		a := uintptr(tv.Align())
+		off = (off + a - 1) &^ (a - 1)
+		v := MakeZero(tv)
+		n := tv.Size()
+		memmove(v.getAddr(), addr(ptr+off), n)
+		ret[i] = v
+		off += n
 	}
 
-	return ret;
+	return ret
 }
 
 /*
@@ -886,16 +886,16 @@ func (fv *FuncValue) Call(in []Value) []Value {
 
 // An InterfaceValue represents an interface value.
 type InterfaceValue struct {
-	value;
+	value
 }
 
 // No Get because v.Interface() is available.
 
 // IsNil returns whether v is a nil interface value.
-func (v *InterfaceValue) IsNil() bool	{ return v.Interface() == nil }
+func (v *InterfaceValue) IsNil() bool { return v.Interface() == nil }
 
 // Elem returns the concrete value stored in the interface value v.
-func (v *InterfaceValue) Elem() Value	{ return NewValue(v.Interface()) }
+func (v *InterfaceValue) Elem() Value { return NewValue(v.Interface()) }
 
 // ../runtime/reflect.cgo
 func setiface(typ *InterfaceType, x *interface{}, addr addr)
@@ -911,38 +911,38 @@ func (v *InterfaceValue) Set(x Value) {
 	}
 	// Two different representations; see comment in Get.
 	// Empty interface is easy.
-	t := v.typ.(*InterfaceType);
+	t := v.typ.(*InterfaceType)
 	if t.NumMethod() == 0 {
-		*(*interface{})(v.addr) = i;
-		return;
+		*(*interface{})(v.addr) = i
+		return
 	}
 
 	// Non-empty interface requires a runtime check.
-	setiface(t, &i, v.addr);
+	setiface(t, &i, v.addr)
 }
 
 // Set sets v to the value x.
-func (v *InterfaceValue) SetValue(x Value)	{ v.Set(x) }
+func (v *InterfaceValue) SetValue(x Value) { v.Set(x) }
 
 // Method returns a FuncValue corresponding to v's i'th method.
 // The arguments to a Call on the returned FuncValue
 // should not include a receiver; the FuncValue will use v
 // as the receiver.
 func (v *InterfaceValue) Method(i int) *FuncValue {
-	t := v.Type().(*InterfaceType);
+	t := v.Type().(*InterfaceType)
 	if t == nil || i < 0 || i >= len(t.methods) {
 		return nil
 	}
-	p := &t.methods[i];
+	p := &t.methods[i]
 
 	// Interface is two words: itable, data.
-	tab := *(**runtime.Itable)(v.addr);
-	data := &value{Typeof((*byte)(nil)), addr(uintptr(v.addr) + ptrSize), true};
+	tab := *(**runtime.Itable)(v.addr)
+	data := &value{Typeof((*byte)(nil)), addr(uintptr(v.addr) + ptrSize), true}
 
 	// Function pointer is at p.perm in the table.
-	fn := tab.Fn[p.perm];
-	fv := &FuncValue{value: value{toType(*p.typ), addr(&fn), true}, first: data, isInterface: true};
-	return fv;
+	fn := tab.Fn[p.perm]
+	fv := &FuncValue{value: value{toType(*p.typ), addr(&fn), true}, first: data, isInterface: true}
+	return fv
 }
 
 /*
@@ -951,11 +951,11 @@ func (v *InterfaceValue) Method(i int) *FuncValue {
 
 // A MapValue represents a map value.
 type MapValue struct {
-	value;
+	value
 }
 
 // IsNil returns whether v is a nil map value.
-func (v *MapValue) IsNil() bool	{ return *(*uintptr)(v.addr) == 0 }
+func (v *MapValue) IsNil() bool { return *(*uintptr)(v.addr) == 0 }
 
 // Set assigns x to v.
 // The new value x must have the same type as v.
@@ -963,12 +963,12 @@ func (v *MapValue) Set(x *MapValue) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	typesMustMatch(v.typ, x.typ);
-	*(*uintptr)(v.addr) = *(*uintptr)(x.addr);
+	typesMustMatch(v.typ, x.typ)
+	*(*uintptr)(v.addr) = *(*uintptr)(x.addr)
 }
 
 // Set sets v to the value x.
-func (v *MapValue) SetValue(x Value)	{ v.Set(x.(*MapValue)) }
+func (v *MapValue) SetValue(x Value) { v.Set(x.(*MapValue)) }
 
 // implemented in ../pkg/runtime/reflect.cgo
 func mapaccess(m, key, val *byte) bool
@@ -982,70 +982,70 @@ func makemap(t *runtime.MapType) *byte
 // Elem returns the value associated with key in the map v.
 // It returns nil if key is not found in the map.
 func (v *MapValue) Elem(key Value) Value {
-	t := v.Type().(*MapType);
-	typesMustMatch(t.Key(), key.Type());
-	m := *(**byte)(v.addr);
+	t := v.Type().(*MapType)
+	typesMustMatch(t.Key(), key.Type())
+	m := *(**byte)(v.addr)
 	if m == nil {
 		return nil
 	}
-	newval := MakeZero(t.Elem());
+	newval := MakeZero(t.Elem())
 	if !mapaccess(m, (*byte)(key.getAddr()), (*byte)(newval.getAddr())) {
 		return nil
 	}
-	return newval;
+	return newval
 }
 
 // SetElem sets the value associated with key in the map v to val.
 // If val is nil, Put deletes the key from map.
 func (v *MapValue) SetElem(key, val Value) {
-	t := v.Type().(*MapType);
-	typesMustMatch(t.Key(), key.Type());
-	var vaddr *byte;
+	t := v.Type().(*MapType)
+	typesMustMatch(t.Key(), key.Type())
+	var vaddr *byte
 	if val != nil {
-		typesMustMatch(t.Elem(), val.Type());
-		vaddr = (*byte)(val.getAddr());
+		typesMustMatch(t.Elem(), val.Type())
+		vaddr = (*byte)(val.getAddr())
 	}
-	m := *(**byte)(v.addr);
-	mapassign(m, (*byte)(key.getAddr()), vaddr);
+	m := *(**byte)(v.addr)
+	mapassign(m, (*byte)(key.getAddr()), vaddr)
 }
 
 // Len returns the number of keys in the map v.
 func (v *MapValue) Len() int {
-	m := *(**byte)(v.addr);
+	m := *(**byte)(v.addr)
 	if m == nil {
 		return 0
 	}
-	return int(maplen(m));
+	return int(maplen(m))
 }
 
 // Keys returns a slice containing all the keys present in the map,
 // in unspecified order.
 func (v *MapValue) Keys() []Value {
-	tk := v.Type().(*MapType).Key();
-	m := *(**byte)(v.addr);
-	mlen := int32(0);
+	tk := v.Type().(*MapType).Key()
+	m := *(**byte)(v.addr)
+	mlen := int32(0)
 	if m != nil {
 		mlen = maplen(m)
 	}
-	it := mapiterinit(m);
-	a := make([]Value, mlen);
-	var i int;
+	it := mapiterinit(m)
+	a := make([]Value, mlen)
+	var i int
 	for i = 0; i < len(a); i++ {
-		k := MakeZero(tk);
+		k := MakeZero(tk)
 		if !mapiterkey(it, (*byte)(k.getAddr())) {
 			break
 		}
-		a[i] = k;
-		mapiternext(it);
+		a[i] = k
+		mapiternext(it)
 	}
-	return a[0:i];
+	return a[0:i]
 }
 
 // MakeMap creates a new map of the specified type.
 func MakeMap(typ *MapType) *MapValue {
-	v := MakeZero(typ).(*MapValue);
-	*(**byte)(v.addr) = makemap((*runtime.MapType)(unsafe.Pointer(typ)));
-	return v;
+	v := MakeZero(typ).(*MapValue)
+	*(**byte)(v.addr) = makemap((*runtime.MapType)(unsafe.Pointer(typ)))
+	return v
 }
 
 /*
@@ -1054,15 +1054,15 @@ func MakeMap(typ *MapType) *MapValue {
 
 // A PtrValue represents a pointer.
 type PtrValue struct {
-	value;
+	value
 }
 
 // IsNil returns whether v is a nil pointer.
-func (v *PtrValue) IsNil() bool	{ return *(*uintptr)(v.addr) == 0 }
+func (v *PtrValue) IsNil() bool { return *(*uintptr)(v.addr) == 0 }
 
 // Get returns the uintptr value of v.
 // It is mainly useful for printing.
-func (v *PtrValue) Get() uintptr	{ return *(*uintptr)(v.addr) }
+func (v *PtrValue) Get() uintptr { return *(*uintptr)(v.addr) }
 
 // Set assigns x to v.
 // The new value x must have the same type as v.
@@ -1070,24 +1070,24 @@ func (v *PtrValue) Set(x *PtrValue) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	typesMustMatch(v.typ, x.typ);
+	typesMustMatch(v.typ, x.typ)
 	// TODO: This will have to move into the runtime
 	// once the new gc goes in
-	*(*uintptr)(v.addr) = *(*uintptr)(x.addr);
+	*(*uintptr)(v.addr) = *(*uintptr)(x.addr)
 }
 
 // Set sets v to the value x.
-func (v *PtrValue) SetValue(x Value)	{ v.Set(x.(*PtrValue)) }
+func (v *PtrValue) SetValue(x Value) { v.Set(x.(*PtrValue)) }
 
 // PointTo changes v to point to x.
 func (v *PtrValue) PointTo(x Value) {
 	if !x.CanSet() {
 		panic("cannot set x; cannot point to x")
 	}
-	typesMustMatch(v.typ.(*PtrType).Elem(), x.Type());
+	typesMustMatch(v.typ.(*PtrType).Elem(), x.Type())
 	// TODO: This will have to move into the runtime
 	// once the new gc goes in.
-	*(*uintptr)(v.addr) = x.Addr();
+	*(*uintptr)(v.addr) = x.Addr()
 }
 
 // Elem returns the value that v points to.
@@ -1096,7 +1096,7 @@ func (v *PtrValue) Elem() Value {
 	if v.IsNil() {
 		return nil
 	}
-	return newValue(v.typ.(*PtrType).Elem(), *(*addr)(v.addr), v.canSet);
+	return newValue(v.typ.(*PtrType).Elem(), *(*addr)(v.addr), v.canSet)
 }
 
 // Indirect returns the value that v points to.
@@ -1106,7 +1106,7 @@ func Indirect(v Value) Value {
 	if pv, ok := v.(*PtrValue); ok {
 		return pv.Elem()
 	}
-	return v;
+	return v
 }
 
 /*
@@ -1115,7 +1115,7 @@ func Indirect(v Value) Value {
 
 // A StructValue represents a struct value.
 type StructValue struct {
-	value;
+	value
 }
 
 // Set assigns x to v.
@@ -1126,26 +1126,26 @@ func (v *StructValue) Set(x *StructValue) {
 	if !v.canSet {
 		panic(cannotSet)
 	}
-	typesMustMatch(v.typ, x.typ);
-	memmove(v.addr, x.addr, v.typ.Size());
+	typesMustMatch(v.typ, x.typ)
+	memmove(v.addr, x.addr, v.typ.Size())
 }
 
 // Set sets v to the value x.
-func (v *StructValue) SetValue(x Value)	{ v.Set(x.(*StructValue)) }
+func (v *StructValue) SetValue(x Value) { v.Set(x.(*StructValue)) }
 
 // Field returns the i'th field of the struct.
 func (v *StructValue) Field(i int) Value {
-	t := v.typ.(*StructType);
+	t := v.typ.(*StructType)
 	if i < 0 || i >= t.NumField() {
 		return nil
 	}
-	f := t.Field(i);
-	return newValue(f.Type, addr(uintptr(v.addr)+f.Offset), v.canSet && f.PkgPath == "");
+	f := t.Field(i)
+	return newValue(f.Type, addr(uintptr(v.addr)+f.Offset), v.canSet && f.PkgPath == "")
 }
 
 // FieldByIndex returns the nested field corresponding to index.
 func (t *StructValue) FieldByIndex(index []int) (v Value) {
-	v = t;
+	v = t
 	for i, x := range index {
 		if i > 0 {
 			if p, ok := v.(*PtrValue); ok {
@@ -1154,13 +1154,13 @@ func (t *StructValue) FieldByIndex(index []int) (v Value) {
 			if s, ok := v.(*StructValue); ok {
 				t = s
 			} else {
-				v = nil;
-				return;
+				v = nil
+				return
 			}
 		}
-		v = t.Field(x);
+		v = t.Field(x)
 	}
-	return;
+	return
 }
 
 // FieldByName returns the struct field with the given name.
@@ -1169,11 +1169,11 @@ func (t *StructValue) FieldByName(name string) Value {
 	if f, ok := t.Type().(*StructType).FieldByName(name); ok {
 		return t.FieldByIndex(f.Index)
 	}
-	return nil;
+	return nil
 }
 
 // NumField returns the number of fields in the struct.
-func (v *StructValue) NumField() int	{ return v.typ.(*StructType).NumField() }
+func (v *StructValue) NumField() int { return v.typ.(*StructType).NumField() }
 
 /*
  * constructors
@@ -1185,8 +1185,8 @@ func NewValue(i interface{}) Value {
 	if i == nil {
 		return nil
 	}
-	t, a := unsafe.Reflect(i);
-	return newValue(toType(t), addr(a), true);
+	t, a := unsafe.Reflect(i)
+	return newValue(toType(t), addr(a), true)
 }
 
 
@@ -1203,7 +1203,7 @@ func newValue(typ Type, addr addr, canSet bool) Value {
 
 	// All values have same memory layout;
 	// build once and convert.
-	v := &struct{ value }{value{typ, addr, canSet}};
+	v := &struct{ value }{value{typ, addr, canSet}}
 	switch typ.(type) {
 	case *ArrayType:
 		// TODO(rsc): Something must prevent
@@ -1261,7 +1261,7 @@ func newValue(typ Type, addr addr, canSet bool) Value {
 	case *UnsafePointerType:
 		return (*UnsafePointerValue)(v)
 	}
-	panicln("newValue", typ.String());
+	panicln("newValue", typ.String())
 }
 
 // MakeZero returns a zero Value for the specified Type.
@@ -1269,5 +1269,5 @@ func MakeZero(typ Type) Value {
 	if typ == nil {
 		return nil
 	}
-	return newValue(typ, addr(unsafe.New(typ)), true);
+	return newValue(typ, addr(unsafe.New(typ)), true)
 }
diff --git a/src/pkg/regexp/all_test.go b/src/pkg/regexp/all_test.go
index 6c586ba984..0c274139b6 100644
--- a/src/pkg/regexp/all_test.go
+++ b/src/pkg/regexp/all_test.go
@@ -5,9 +5,9 @@
 package regexp
 
 import (
-	"os";
-	"strings";
-	"testing";
+	"os"
+	"strings"
+	"testing"
 )
 
 var good_re = []string{
@@ -32,8 +32,8 @@ var good_re = []string{
 
 // TODO: nice to do this with a map
 type stringError struct {
-	re	string;
-	err	os.Error;
+	re  string
+	err os.Error
 }
 
 var bad_re = []stringError{
@@ -54,9 +54,9 @@ var bad_re = []stringError{
 type vec []int
 
 type tester struct {
-	re	string;
-	text	string;
-	match	vec;
+	re    string
+	text  string
+	match vec
 }
 
 var matches = []tester{
@@ -100,27 +100,27 @@ var matches = []tester{
 }
 
 func compileTest(t *testing.T, expr string, error os.Error) *Regexp {
-	re, err := Compile(expr);
+	re, err := Compile(expr)
 	if err != error {
 		t.Error("compiling `", expr, "`; unexpected error: ", err.String())
 	}
-	return re;
+	return re
 }
 
 func printVec(t *testing.T, m []int) {
-	l := len(m);
+	l := len(m)
 	if l == 0 {
 		t.Log("\t<no match>")
 	} else {
 		if m[len(m)-1] == -1 {
 			m = m[0 : len(m)-2]
 		}
-		t.Log("\t", m);
+		t.Log("\t", m)
 	}
 }
 
 func equal(m1, m2 []int) bool {
-	l := len(m1);
+	l := len(m1)
 	if l != len(m2) {
 		return false
 	}
@@ -129,11 +129,11 @@ func equal(m1, m2 []int) bool {
 			return false
 		}
 	}
-	return true;
+	return true
 }
 
 func equalStrings(m1, m2 []string) bool {
-	l := len(m1);
+	l := len(m1)
 	if l != len(m2) {
 		return false
 	}
@@ -142,28 +142,28 @@ func equalStrings(m1, m2 []string) bool {
 			return false
 		}
 	}
-	return true;
+	return true
 }
 
 func executeTest(t *testing.T, expr string, str string, match []int) {
-	re := compileTest(t, expr, nil);
+	re := compileTest(t, expr, nil)
 	if re == nil {
 		return
 	}
-	m := re.ExecuteString(str);
+	m := re.ExecuteString(str)
 	if !equal(m, match) {
-		t.Errorf("ExecuteString failure on %#q matching %q:", expr, str);
-		printVec(t, m);
-		t.Log("should be:");
-		printVec(t, match);
+		t.Errorf("ExecuteString failure on %#q matching %q:", expr, str)
+		printVec(t, m)
+		t.Log("should be:")
+		printVec(t, match)
 	}
 	// now try bytes
-	m = re.Execute(strings.Bytes(str));
+	m = re.Execute(strings.Bytes(str))
 	if !equal(m, match) {
-		t.Errorf("Execute failure on %#q matching %q:", expr, str);
-		printVec(t, m);
-		t.Log("should be:");
-		printVec(t, match);
+		t.Errorf("Execute failure on %#q matching %q:", expr, str)
+		printVec(t, m)
+		t.Log("should be:")
+		printVec(t, match)
 	}
 }
 
@@ -181,22 +181,22 @@ func TestBadCompile(t *testing.T) {
 
 func TestExecute(t *testing.T) {
 	for i := 0; i < len(matches); i++ {
-		test := &matches[i];
-		executeTest(t, test.re, test.text, test.match);
+		test := &matches[i]
+		executeTest(t, test.re, test.text, test.match)
 	}
 }
 
 func matchTest(t *testing.T, expr string, str string, match []int) {
-	re := compileTest(t, expr, nil);
+	re := compileTest(t, expr, nil)
 	if re == nil {
 		return
 	}
-	m := re.MatchString(str);
+	m := re.MatchString(str)
 	if m != (len(match) > 0) {
 		t.Errorf("MatchString failure on %#q matching %q: %t should be %t", expr, str, m, len(match) > 0)
 	}
 	// now try bytes
-	m = re.Match(strings.Bytes(str));
+	m = re.Match(strings.Bytes(str))
 	if m != (len(match) > 0) {
 		t.Errorf("Match failure on %#q matching %q: %t should be %t", expr, str, m, len(match) > 0)
 	}
@@ -204,20 +204,20 @@ func matchTest(t *testing.T, expr string, str string, match []int) {
 
 func TestMatch(t *testing.T) {
 	for i := 0; i < len(matches); i++ {
-		test := &matches[i];
-		matchTest(t, test.re, test.text, test.match);
+		test := &matches[i]
+		matchTest(t, test.re, test.text, test.match)
 	}
 }
 
 func TestMatchStrings(t *testing.T) {
 	for i := 0; i < len(matches); i++ {
-		test := &matches[i];
-		matchTest(t, test.re, test.text, test.match);
+		test := &matches[i]
+		matchTest(t, test.re, test.text, test.match)
 	}
 }
 
 func matchFunctionTest(t *testing.T, expr string, str string, match []int) {
-	m, err := MatchString(expr, str);
+	m, err := MatchString(expr, str)
 	if err == nil {
 		return
 	}
@@ -228,13 +228,13 @@ func matchFunctionTest(t *testing.T, expr string, str string, match []int) {
 
 func TestMatchFunction(t *testing.T) {
 	for i := 0; i < len(matches); i++ {
-		test := &matches[i];
-		matchFunctionTest(t, test.re, test.text, test.match);
+		test := &matches[i]
+		matchFunctionTest(t, test.re, test.text, test.match)
 	}
 }
 
 type ReplaceTest struct {
-	pattern, replacement, input, output string;
+	pattern, replacement, input, output string
 }
 
 var replaceTests = []ReplaceTest{
@@ -301,18 +301,18 @@ var replaceTests = []ReplaceTest{
 
 func TestReplaceAll(t *testing.T) {
 	for _, tc := range replaceTests {
-		re, err := Compile(tc.pattern);
+		re, err := Compile(tc.pattern)
 		if err != nil {
-			t.Errorf("Unexpected error compiling %q: %v", tc.pattern, err);
-			continue;
+			t.Errorf("Unexpected error compiling %q: %v", tc.pattern, err)
+			continue
 		}
-		actual := re.ReplaceAllString(tc.input, tc.replacement);
+		actual := re.ReplaceAllString(tc.input, tc.replacement)
 		if actual != tc.output {
 			t.Errorf("%q.Replace(%q,%q) = %q; want %q",
 				tc.pattern, tc.input, tc.replacement, actual, tc.output)
 		}
 		// now try bytes
-		actual = string(re.ReplaceAll(strings.Bytes(tc.input), strings.Bytes(tc.replacement)));
+		actual = string(re.ReplaceAll(strings.Bytes(tc.input), strings.Bytes(tc.replacement)))
 		if actual != tc.output {
 			t.Errorf("%q.Replace(%q,%q) = %q; want %q",
 				tc.pattern, tc.input, tc.replacement, actual, tc.output)
@@ -321,7 +321,7 @@ func TestReplaceAll(t *testing.T) {
 }
 
 type QuoteMetaTest struct {
-	pattern, output string;
+	pattern, output string
 }
 
 var quoteMetaTests = []QuoteMetaTest{
@@ -333,25 +333,25 @@ var quoteMetaTests = []QuoteMetaTest{
 func TestQuoteMeta(t *testing.T) {
 	for _, tc := range quoteMetaTests {
 		// Verify that QuoteMeta returns the expected string.
-		quoted := QuoteMeta(tc.pattern);
+		quoted := QuoteMeta(tc.pattern)
 		if quoted != tc.output {
 			t.Errorf("QuoteMeta(`%s`) = `%s`; want `%s`",
-				tc.pattern, quoted, tc.output);
-			continue;
+				tc.pattern, quoted, tc.output)
+			continue
 		}
 
 		// Verify that the quoted string is in fact treated as expected
 		// by Compile -- i.e. that it matches the original, unquoted string.
 		if tc.pattern != "" {
-			re, err := Compile(quoted);
+			re, err := Compile(quoted)
 			if err != nil {
-				t.Errorf("Unexpected error compiling QuoteMeta(`%s`): %v", tc.pattern, err);
-				continue;
+				t.Errorf("Unexpected error compiling QuoteMeta(`%s`): %v", tc.pattern, err)
+				continue
 			}
-			src := "abc" + tc.pattern + "def";
-			repl := "xyz";
-			replaced := re.ReplaceAllString(src, repl);
-			expected := "abcxyzdef";
+			src := "abc" + tc.pattern + "def"
+			repl := "xyz"
+			replaced := re.ReplaceAllString(src, repl)
+			expected := "abcxyzdef"
 			if replaced != expected {
 				t.Errorf("QuoteMeta(`%s`).Replace(`%s`,`%s`) = `%s`; want `%s`",
 					tc.pattern, src, repl, replaced, expected)
@@ -361,11 +361,11 @@ func TestQuoteMeta(t *testing.T) {
 }
 
 type matchCase struct {
-	matchfunc	string;
-	input		string;
-	n		int;
-	regexp		string;
-	expected	[]string;
+	matchfunc string
+	input     string
+	n         int
+	regexp    string
+	expected  []string
 }
 
 var matchCases = []matchCase{
@@ -392,90 +392,90 @@ func printStringSlice(t *testing.T, s []string) {
 }
 
 func TestAllMatches(t *testing.T) {
-	ch := make(chan matchCase);
+	ch := make(chan matchCase)
 	go func() {
 		for _, c := range matchCases {
-			ch <- c;
+			ch <- c
 			stringCase := matchCase{
 				"string" + c.matchfunc,
 				c.input,
 				c.n,
 				c.regexp,
 				c.expected,
-			};
-			ch <- stringCase;
+			}
+			ch <- stringCase
 		}
-		close(ch);
-	}();
+		close(ch)
+	}()
 
 	for c := range ch {
-		var result []string;
-		re, _ := Compile(c.regexp);
+		var result []string
+		re, _ := Compile(c.regexp)
 
 		switch c.matchfunc {
 		case "matchit":
-			result = make([]string, len(c.input)+1);
-			i := 0;
-			b := strings.Bytes(c.input);
+			result = make([]string, len(c.input)+1)
+			i := 0
+			b := strings.Bytes(c.input)
 			for match := range re.AllMatchesIter(b, c.n) {
-				result[i] = string(match);
-				i++;
+				result[i] = string(match)
+				i++
 			}
-			result = result[0:i];
+			result = result[0:i]
 		case "stringmatchit":
-			result = make([]string, len(c.input)+1);
-			i := 0;
+			result = make([]string, len(c.input)+1)
+			i := 0
 			for match := range re.AllMatchesStringIter(c.input, c.n) {
-				result[i] = match;
-				i++;
+				result[i] = match
+				i++
 			}
-			result = result[0:i];
+			result = result[0:i]
 		case "match":
-			result = make([]string, len(c.input)+1);
-			b := strings.Bytes(c.input);
-			i := 0;
+			result = make([]string, len(c.input)+1)
+			b := strings.Bytes(c.input)
+			i := 0
 			for _, match := range re.AllMatches(b, c.n) {
-				result[i] = string(match);
-				i++;
+				result[i] = string(match)
+				i++
 			}
-			result = result[0:i];
+			result = result[0:i]
 		case "stringmatch":
 			result = re.AllMatchesString(c.input, c.n)
 		}
 
 		if !equalStrings(result, c.expected) {
 			t.Errorf("testing '%s'.%s('%s', %d), expected: ",
-				c.regexp, c.matchfunc, c.input, c.n);
-			printStringSlice(t, c.expected);
-			t.Log("got: ");
-			printStringSlice(t, result);
-			t.Log("\n");
+				c.regexp, c.matchfunc, c.input, c.n)
+			printStringSlice(t, c.expected)
+			t.Log("got: ")
+			printStringSlice(t, result)
+			t.Log("\n")
 		}
 	}
 }
 
 func BenchmarkLiteral(b *testing.B) {
-	x := strings.Repeat("x", 50);
-	b.StopTimer();
-	re, _ := Compile(x);
-	b.StartTimer();
+	x := strings.Repeat("x", 50)
+	b.StopTimer()
+	re, _ := Compile(x)
+	b.StartTimer()
 	for i := 0; i < b.N; i++ {
 		if !re.MatchString(x) {
-			println("no match!");
-			break;
+			println("no match!")
+			break
 		}
 	}
 }
 
 func BenchmarkNotLiteral(b *testing.B) {
-	x := strings.Repeat("x", 49);
-	b.StopTimer();
-	re, _ := Compile("^" + x);
-	b.StartTimer();
+	x := strings.Repeat("x", 49)
+	b.StopTimer()
+	re, _ := Compile("^" + x)
+	b.StartTimer()
 	for i := 0; i < b.N; i++ {
 		if !re.MatchString(x) {
-			println("no match!");
-			break;
+			println("no match!")
+			break
 		}
 	}
 }
diff --git a/src/pkg/regexp/regexp.go b/src/pkg/regexp/regexp.go
index 6135fb61b3..fd6fbefee8 100644
--- a/src/pkg/regexp/regexp.go
+++ b/src/pkg/regexp/regexp.go
@@ -23,144 +23,144 @@
 package regexp
 
 import (
-	"bytes";
-	"container/vector";
-	"io";
-	"os";
-	"strings";
-	"utf8";
+	"bytes"
+	"container/vector"
+	"io"
+	"os"
+	"strings"
+	"utf8"
 )
 
 var debug = false
 
 // Error codes returned by failures to parse an expression.
 var (
-	ErrInternal		= os.NewError("internal error");
-	ErrUnmatchedLpar	= os.NewError("unmatched '('");
-	ErrUnmatchedRpar	= os.NewError("unmatched ')'");
-	ErrUnmatchedLbkt	= os.NewError("unmatched '['");
-	ErrUnmatchedRbkt	= os.NewError("unmatched ']'");
-	ErrBadRange		= os.NewError("bad range in character class");
-	ErrExtraneousBackslash	= os.NewError("extraneous backslash");
-	ErrBadClosure		= os.NewError("repeated closure (**, ++, etc.)");
-	ErrBareClosure		= os.NewError("closure applies to nothing");
-	ErrBadBackslash		= os.NewError("illegal backslash escape");
+	ErrInternal            = os.NewError("internal error")
+	ErrUnmatchedLpar       = os.NewError("unmatched '('")
+	ErrUnmatchedRpar       = os.NewError("unmatched ')'")
+	ErrUnmatchedLbkt       = os.NewError("unmatched '['")
+	ErrUnmatchedRbkt       = os.NewError("unmatched ']'")
+	ErrBadRange            = os.NewError("bad range in character class")
+	ErrExtraneousBackslash = os.NewError("extraneous backslash")
+	ErrBadClosure          = os.NewError("repeated closure (**, ++, etc.)")
+	ErrBareClosure         = os.NewError("closure applies to nothing")
+	ErrBadBackslash        = os.NewError("illegal backslash escape")
 )
 
 // An instruction executed by the NFA
 type instr interface {
-	kind() int;	// the type of this instruction: _CHAR, _ANY, etc.
-	next() instr;	// the instruction to execute after this one
-	setNext(i instr);
-	index() int;
-	setIndex(i int);
-	print();
+	kind() int   // the type of this instruction: _CHAR, _ANY, etc.
+	next() instr // the instruction to execute after this one
+	setNext(i instr)
+	index() int
+	setIndex(i int)
+	print()
 }
 
 // Fields and methods common to all instructions
 type common struct {
-	_next	instr;
-	_index	int;
+	_next  instr
+	_index int
 }
 
-func (c *common) next() instr		{ return c._next }
-func (c *common) setNext(i instr)	{ c._next = i }
-func (c *common) index() int		{ return c._index }
-func (c *common) setIndex(i int)	{ c._index = i }
+func (c *common) next() instr     { return c._next }
+func (c *common) setNext(i instr) { c._next = i }
+func (c *common) index() int      { return c._index }
+func (c *common) setIndex(i int)  { c._index = i }
 
 // Regexp is the representation of a compiled regular expression.
 // The public interface is entirely through methods.
 type Regexp struct {
-	expr		string;	// the original expression
-	prefix		string;	// initial plain text string
-	prefixBytes	[]byte;	// initial plain text bytes
-	inst		*vector.Vector;
-	start		instr;
-	nbra		int;	// number of brackets in expression, for subexpressions
+	expr        string // the original expression
+	prefix      string // initial plain text string
+	prefixBytes []byte // initial plain text bytes
+	inst        *vector.Vector
+	start       instr
+	nbra        int // number of brackets in expression, for subexpressions
 }
 
 const (
-	_START		= iota;	// beginning of program
-	_END;		// end of program: success
-	_BOT;		// '^' beginning of text
-	_EOT;		// '$' end of text
-	_CHAR;		// 'a' regular character
-	_CHARCLASS;	// [a-z] character class
-	_ANY;		// '.' any character including newline
-	_NOTNL;		// [^\n] special case: any character but newline
-	_BRA;		// '(' parenthesized expression
-	_EBRA;		// ')'; end of '(' parenthesized expression
-	_ALT;		// '|' alternation
-	_NOP;		// do nothing; makes it easy to link without patching
+	_START     = iota // beginning of program
+	_END       // end of program: success
+	_BOT       // '^' beginning of text
+	_EOT       // '$' end of text
+	_CHAR      // 'a' regular character
+	_CHARCLASS // [a-z] character class
+	_ANY       // '.' any character including newline
+	_NOTNL     // [^\n] special case: any character but newline
+	_BRA       // '(' parenthesized expression
+	_EBRA      // ')'; end of '(' parenthesized expression
+	_ALT       // '|' alternation
+	_NOP       // do nothing; makes it easy to link without patching
 )
 
 // --- START start of program
 type _Start struct {
-	common;
+	common
 }
 
-func (start *_Start) kind() int	{ return _START }
-func (start *_Start) print()	{ print("start") }
+func (start *_Start) kind() int { return _START }
+func (start *_Start) print()    { print("start") }
 
 // --- END end of program
 type _End struct {
-	common;
+	common
 }
 
-func (end *_End) kind() int	{ return _END }
-func (end *_End) print()	{ print("end") }
+func (end *_End) kind() int { return _END }
+func (end *_End) print()    { print("end") }
 
 // --- BOT beginning of text
 type _Bot struct {
-	common;
+	common
 }
 
-func (bot *_Bot) kind() int	{ return _BOT }
-func (bot *_Bot) print()	{ print("bot") }
+func (bot *_Bot) kind() int { return _BOT }
+func (bot *_Bot) print()    { print("bot") }
 
 // --- EOT end of text
 type _Eot struct {
-	common;
+	common
 }
 
-func (eot *_Eot) kind() int	{ return _EOT }
-func (eot *_Eot) print()	{ print("eot") }
+func (eot *_Eot) kind() int { return _EOT }
+func (eot *_Eot) print()    { print("eot") }
 
 // --- CHAR a regular character
 type _Char struct {
-	common;
-	char	int;
+	common
+	char int
 }
 
-func (char *_Char) kind() int	{ return _CHAR }
-func (char *_Char) print()	{ print("char ", string(char.char)) }
+func (char *_Char) kind() int { return _CHAR }
+func (char *_Char) print()    { print("char ", string(char.char)) }
 
 func newChar(char int) *_Char {
-	c := new(_Char);
-	c.char = char;
-	return c;
+	c := new(_Char)
+	c.char = char
+	return c
 }
 
 // --- CHARCLASS [a-z]
 
 type _CharClass struct {
-	common;
-	char	int;
-	negate	bool;	// is character class negated? ([^a-z])
+	common
+	char   int
+	negate bool // is character class negated? ([^a-z])
 	// vector of int, stored pairwise: [a-z] is (a,z); x is (x,x):
-	ranges	*vector.IntVector;
+	ranges *vector.IntVector
 }
 
-func (cclass *_CharClass) kind() int	{ return _CHARCLASS }
+func (cclass *_CharClass) kind() int { return _CHARCLASS }
 
 func (cclass *_CharClass) print() {
-	print("charclass");
+	print("charclass")
 	if cclass.negate {
 		print(" (negated)")
 	}
 	for i := 0; i < cclass.ranges.Len(); i += 2 {
-		l := cclass.ranges.At(i);
-		r := cclass.ranges.At(i + 1);
+		l := cclass.ranges.At(i)
+		r := cclass.ranges.At(i + 1)
 		if l == r {
 			print(" [", string(l), "]")
 		} else {
@@ -171,112 +171,112 @@ func (cclass *_CharClass) print() {
 
 func (cclass *_CharClass) addRange(a, b int) {
 	// range is a through b inclusive
-	cclass.ranges.Push(a);
-	cclass.ranges.Push(b);
+	cclass.ranges.Push(a)
+	cclass.ranges.Push(b)
 }
 
 func (cclass *_CharClass) matches(c int) bool {
 	for i := 0; i < cclass.ranges.Len(); i = i + 2 {
-		min := cclass.ranges.At(i);
-		max := cclass.ranges.At(i + 1);
+		min := cclass.ranges.At(i)
+		max := cclass.ranges.At(i + 1)
 		if min <= c && c <= max {
 			return !cclass.negate
 		}
 	}
-	return cclass.negate;
+	return cclass.negate
 }
 
 func newCharClass() *_CharClass {
-	c := new(_CharClass);
-	c.ranges = new(vector.IntVector);
-	return c;
+	c := new(_CharClass)
+	c.ranges = new(vector.IntVector)
+	return c
 }
 
 // --- ANY any character
 type _Any struct {
-	common;
+	common
 }
 
-func (any *_Any) kind() int	{ return _ANY }
-func (any *_Any) print()	{ print("any") }
+func (any *_Any) kind() int { return _ANY }
+func (any *_Any) print()    { print("any") }
 
 // --- NOTNL any character but newline
 type _NotNl struct {
-	common;
+	common
 }
 
-func (notnl *_NotNl) kind() int	{ return _NOTNL }
-func (notnl *_NotNl) print()	{ print("notnl") }
+func (notnl *_NotNl) kind() int { return _NOTNL }
+func (notnl *_NotNl) print()    { print("notnl") }
 
 // --- BRA parenthesized expression
 type _Bra struct {
-	common;
-	n	int;	// subexpression number
+	common
+	n int // subexpression number
 }
 
-func (bra *_Bra) kind() int	{ return _BRA }
-func (bra *_Bra) print()	{ print("bra", bra.n) }
+func (bra *_Bra) kind() int { return _BRA }
+func (bra *_Bra) print()    { print("bra", bra.n) }
 
 // --- EBRA end of parenthesized expression
 type _Ebra struct {
-	common;
-	n	int;	// subexpression number
+	common
+	n int // subexpression number
 }
 
-func (ebra *_Ebra) kind() int	{ return _EBRA }
-func (ebra *_Ebra) print()	{ print("ebra ", ebra.n) }
+func (ebra *_Ebra) kind() int { return _EBRA }
+func (ebra *_Ebra) print()    { print("ebra ", ebra.n) }
 
 // --- ALT alternation
 type _Alt struct {
-	common;
-	left	instr;	// other branch
+	common
+	left instr // other branch
 }
 
-func (alt *_Alt) kind() int	{ return _ALT }
-func (alt *_Alt) print()	{ print("alt(", alt.left.index(), ")") }
+func (alt *_Alt) kind() int { return _ALT }
+func (alt *_Alt) print()    { print("alt(", alt.left.index(), ")") }
 
 // --- NOP no operation
 type _Nop struct {
-	common;
+	common
 }
 
-func (nop *_Nop) kind() int	{ return _NOP }
-func (nop *_Nop) print()	{ print("nop") }
+func (nop *_Nop) kind() int { return _NOP }
+func (nop *_Nop) print()    { print("nop") }
 
 func (re *Regexp) add(i instr) instr {
-	i.setIndex(re.inst.Len());
-	re.inst.Push(i);
-	return i;
+	i.setIndex(re.inst.Len())
+	re.inst.Push(i)
+	return i
 }
 
 type parser struct {
-	re	*Regexp;
-	error	os.Error;
-	nlpar	int;	// number of unclosed lpars
-	pos	int;
-	ch	int;
+	re    *Regexp
+	error os.Error
+	nlpar int // number of unclosed lpars
+	pos   int
+	ch    int
 }
 
 const endOfFile = -1
 
-func (p *parser) c() int	{ return p.ch }
+func (p *parser) c() int { return p.ch }
 
 func (p *parser) nextc() int {
 	if p.pos >= len(p.re.expr) {
 		p.ch = endOfFile
 	} else {
-		c, w := utf8.DecodeRuneInString(p.re.expr[p.pos:]);
-		p.ch = c;
-		p.pos += w;
+		c, w := utf8.DecodeRuneInString(p.re.expr[p.pos:])
+		p.ch = c
+		p.pos += w
 	}
-	return p.ch;
+	return p.ch
 }
 
 func newParser(re *Regexp) *parser {
-	p := new(parser);
-	p.re = re;
-	p.nextc();	// load p.ch
-	return p;
+	p := new(parser)
+	p.re = re
+	p.nextc() // load p.ch
+	return p
 }
 
 func special(c int) bool {
@@ -285,7 +285,7 @@ func special(c int) bool {
 			return true
 		}
 	}
-	return false;
+	return false
 }
 
 func specialcclass(c int) bool {
@@ -294,76 +294,76 @@ func specialcclass(c int) bool {
 			return true
 		}
 	}
-	return false;
+	return false
 }
 
 func (p *parser) charClass() instr {
-	cc := newCharClass();
+	cc := newCharClass()
 	if p.c() == '^' {
-		cc.negate = true;
-		p.nextc();
+		cc.negate = true
+		p.nextc()
 	}
-	left := -1;
+	left := -1
 	for {
 		switch c := p.c(); c {
 		case ']', endOfFile:
 			if left >= 0 {
-				p.error = ErrBadRange;
-				return nil;
+				p.error = ErrBadRange
+				return nil
 			}
 			// Is it [^\n]?
 			if cc.negate && cc.ranges.Len() == 2 &&
 				cc.ranges.At(0) == '\n' && cc.ranges.At(1) == '\n' {
-				nl := new(_NotNl);
-				p.re.add(nl);
-				return nl;
+				nl := new(_NotNl)
+				p.re.add(nl)
+				return nl
 			}
 			// Special common case: "[a]" -> "a"
 			if !cc.negate && cc.ranges.Len() == 2 && cc.ranges.At(0) == cc.ranges.At(1) {
-				c := newChar(cc.ranges.At(0));
-				p.re.add(c);
-				return c;
+				c := newChar(cc.ranges.At(0))
+				p.re.add(c)
+				return c
 			}
-			p.re.add(cc);
-			return cc;
-		case '-':	// do this before backslash processing
-			p.error = ErrBadRange;
-			return nil;
+			p.re.add(cc)
+			return cc
+		case '-': // do this before backslash processing
+			p.error = ErrBadRange
+			return nil
 		case '\\':
-			c = p.nextc();
+			c = p.nextc()
 			switch {
 			case c == endOfFile:
-				p.error = ErrExtraneousBackslash;
-				return nil;
+				p.error = ErrExtraneousBackslash
+				return nil
 			case c == 'n':
 				c = '\n'
 			case specialcclass(c):
 				// c is as delivered
 			default:
-				p.error = ErrBadBackslash;
-				return nil;
+				p.error = ErrBadBackslash
+				return nil
 			}
-			fallthrough;
+			fallthrough
 		default:
-			p.nextc();
+			p.nextc()
 			switch {
-			case left < 0:	// first of pair
-				if p.c() == '-' {	// range
-					p.nextc();
-					left = c;
-				} else {	// single char
+			case left < 0: // first of pair
+				if p.c() == '-' { // range
+					p.nextc()
+					left = c
+				} else { // single char
 					cc.addRange(c, c)
 				}
-			case left <= c:	// second of pair
-				cc.addRange(left, c);
-				left = -1;
+			case left <= c: // second of pair
+				cc.addRange(left, c)
+				left = -1
 			default:
-				p.error = ErrBadRange;
-				return nil;
+				p.error = ErrBadRange
+				return nil
 			}
 		}
 	}
-	return nil;
+	return nil
 }
 
 func (p *parser) term() (start, end instr) {
@@ -378,126 +378,126 @@ func (p *parser) term() (start, end instr) {
 	case '|', endOfFile:
 		return nil, nil
 	case '*', '+':
-		p.error = ErrBareClosure;
-		return;
+		p.error = ErrBareClosure
+		return
 	case ')':
 		if p.nlpar == 0 {
-			p.error = ErrUnmatchedRpar;
-			return;
+			p.error = ErrUnmatchedRpar
+			return
 		}
-		return nil, nil;
+		return nil, nil
 	case ']':
-		p.error = ErrUnmatchedRbkt;
-		return;
+		p.error = ErrUnmatchedRbkt
+		return
 	case '^':
-		p.nextc();
-		start = p.re.add(new(_Bot));
-		return start, start;
+		p.nextc()
+		start = p.re.add(new(_Bot))
+		return start, start
 	case '$':
-		p.nextc();
-		start = p.re.add(new(_Eot));
-		return start, start;
+		p.nextc()
+		start = p.re.add(new(_Eot))
+		return start, start
 	case '.':
-		p.nextc();
-		start = p.re.add(new(_Any));
-		return start, start;
+		p.nextc()
+		start = p.re.add(new(_Any))
+		return start, start
 	case '[':
-		p.nextc();
-		start = p.charClass();
+		p.nextc()
+		start = p.charClass()
 		if p.error != nil {
 			return
 		}
 		if p.c() != ']' {
-			p.error = ErrUnmatchedLbkt;
-			return;
+			p.error = ErrUnmatchedLbkt
+			return
 		}
-		p.nextc();
-		return start, start;
+		p.nextc()
+		return start, start
 	case '(':
-		p.nextc();
-		p.nlpar++;
-		p.re.nbra++;	// increment first so first subexpr is \1
-		nbra := p.re.nbra;
-		start, end = p.regexp();
+		p.nextc()
+		p.nlpar++
+		p.re.nbra++ // increment first so first subexpr is \1
+		nbra := p.re.nbra
+		start, end = p.regexp()
 		if p.c() != ')' {
-			p.error = ErrUnmatchedLpar;
-			return;
+			p.error = ErrUnmatchedLpar
+			return
 		}
-		p.nlpar--;
-		p.nextc();
-		bra := new(_Bra);
-		p.re.add(bra);
-		ebra := new(_Ebra);
-		p.re.add(ebra);
-		bra.n = nbra;
-		ebra.n = nbra;
+		p.nlpar--
+		p.nextc()
+		bra := new(_Bra)
+		p.re.add(bra)
+		ebra := new(_Ebra)
+		p.re.add(ebra)
+		bra.n = nbra
+		ebra.n = nbra
 		if start == nil {
 			if end == nil {
-				p.error = ErrInternal;
-				return;
+				p.error = ErrInternal
+				return
 			}
-			start = ebra;
+			start = ebra
 		} else {
 			end.setNext(ebra)
 		}
-		bra.setNext(start);
-		return bra, ebra;
+		bra.setNext(start)
+		return bra, ebra
 	case '\\':
-		c = p.nextc();
+		c = p.nextc()
 		switch {
 		case c == endOfFile:
-			p.error = ErrExtraneousBackslash;
-			return;
+			p.error = ErrExtraneousBackslash
+			return
 		case c == 'n':
 			c = '\n'
 		case special(c):
 			// c is as delivered
 		default:
-			p.error = ErrBadBackslash;
-			return;
+			p.error = ErrBadBackslash
+			return
 		}
-		fallthrough;
+		fallthrough
 	default:
-		p.nextc();
-		start = newChar(c);
-		p.re.add(start);
-		return start, start;
+		p.nextc()
+		start = newChar(c)
+		p.re.add(start)
+		return start, start
 	}
-	panic("unreachable");
+	panic("unreachable")
 }
 
 func (p *parser) closure() (start, end instr) {
-	start, end = p.term();
+	start, end = p.term()
 	if start == nil || p.error != nil {
 		return
 	}
 	switch p.c() {
 	case '*':
 		// (start,end)*:
-		alt := new(_Alt);
-		p.re.add(alt);
-		end.setNext(alt);	// after end, do alt
-		alt.left = start;	// alternate brach: return to start
-		start = alt;		// alt becomes new (start, end)
-		end = alt;
+		alt := new(_Alt)
+		p.re.add(alt)
+		end.setNext(alt) // after end, do alt
+		alt.left = start // alternate brach: return to start
+		start = alt      // alt becomes new (start, end)
+		end = alt
 	case '+':
 		// (start,end)+:
-		alt := new(_Alt);
-		p.re.add(alt);
-		end.setNext(alt);	// after end, do alt
-		alt.left = start;	// alternate brach: return to start
-		end = alt;		// start is unchanged; end is alt
+		alt := new(_Alt)
+		p.re.add(alt)
+		end.setNext(alt) // after end, do alt
+		alt.left = start // alternate brach: return to start
+		end = alt        // start is unchanged; end is alt
 	case '?':
 		// (start,end)?:
-		alt := new(_Alt);
-		p.re.add(alt);
-		nop := new(_Nop);
-		p.re.add(nop);
-		alt.left = start;	// alternate branch is start
-		alt.setNext(nop);	// follow on to nop
-		end.setNext(nop);	// after end, go to nop
-		start = alt;		// start is now alt
-		end = nop;		// end is nop pointed to by both branches
+		alt := new(_Alt)
+		p.re.add(alt)
+		nop := new(_Nop)
+		p.re.add(nop)
+		alt.left = start // alternate branch is start
+		alt.setNext(nop) // follow on to nop
+		end.setNext(nop) // after end, go to nop
+		start = alt      // start is now alt
+		end = nop        // end is nop pointed to by both branches
 	default:
 		return
 	}
@@ -505,34 +505,34 @@ func (p *parser) closure() (start, end instr) {
 	case '*', '+', '?':
 		p.error = ErrBadClosure
 	}
-	return;
+	return
 }
 
 func (p *parser) concatenation() (start, end instr) {
 	for {
-		nstart, nend := p.closure();
+		nstart, nend := p.closure()
 		if p.error != nil {
 			return
 		}
 		switch {
-		case nstart == nil:	// end of this concatenation
-			if start == nil {	// this is the empty string
-				nop := p.re.add(new(_Nop));
-				return nop, nop;
+		case nstart == nil: // end of this concatenation
+			if start == nil { // this is the empty string
+				nop := p.re.add(new(_Nop))
+				return nop, nop
 			}
-			return;
-		case start == nil:	// this is first element of concatenation
+			return
+		case start == nil: // this is first element of concatenation
 			start, end = nstart, nend
 		default:
-			end.setNext(nstart);
-			end = nend;
+			end.setNext(nstart)
+			end = nend
 		}
 	}
-	panic("unreachable");
+	panic("unreachable")
 }
 
 func (p *parser) regexp() (start, end instr) {
-	start, end = p.concatenation();
+	start, end = p.concatenation()
 	if p.error != nil {
 		return
 	}
@@ -541,101 +541,101 @@ func (p *parser) regexp() (start, end instr) {
 		default:
 			return
 		case '|':
-			p.nextc();
-			nstart, nend := p.concatenation();
+			p.nextc()
+			nstart, nend := p.concatenation()
 			if p.error != nil {
 				return
 			}
-			alt := new(_Alt);
-			p.re.add(alt);
-			alt.left = start;
-			alt.setNext(nstart);
-			nop := new(_Nop);
-			p.re.add(nop);
-			end.setNext(nop);
-			nend.setNext(nop);
-			start, end = alt, nop;
+			alt := new(_Alt)
+			p.re.add(alt)
+			alt.left = start
+			alt.setNext(nstart)
+			nop := new(_Nop)
+			p.re.add(nop)
+			end.setNext(nop)
+			nend.setNext(nop)
+			start, end = alt, nop
 		}
 	}
-	panic("unreachable");
+	panic("unreachable")
 }
 
 func unNop(i instr) instr {
 	for i.kind() == _NOP {
 		i = i.next()
 	}
-	return i;
+	return i
 }
 
 func (re *Regexp) eliminateNops() {
 	for i := 0; i < re.inst.Len(); i++ {
-		inst := re.inst.At(i).(instr);
+		inst := re.inst.At(i).(instr)
 		if inst.kind() == _END {
 			continue
 		}
-		inst.setNext(unNop(inst.next()));
+		inst.setNext(unNop(inst.next()))
 		if inst.kind() == _ALT {
-			alt := inst.(*_Alt);
-			alt.left = unNop(alt.left);
+			alt := inst.(*_Alt)
+			alt.left = unNop(alt.left)
 		}
 	}
 }
 
 func (re *Regexp) dump() {
-	print("prefix <", re.prefix, ">\n");
+	print("prefix <", re.prefix, ">\n")
 	for i := 0; i < re.inst.Len(); i++ {
-		inst := re.inst.At(i).(instr);
-		print(inst.index(), ": ");
-		inst.print();
+		inst := re.inst.At(i).(instr)
+		print(inst.index(), ": ")
+		inst.print()
 		if inst.kind() != _END {
 			print(" -> ", inst.next().index())
 		}
-		print("\n");
+		print("\n")
 	}
 }
 
 func (re *Regexp) doParse() os.Error {
-	p := newParser(re);
-	start := new(_Start);
-	re.add(start);
-	s, e := p.regexp();
+	p := newParser(re)
+	start := new(_Start)
+	re.add(start)
+	s, e := p.regexp()
 	if p.error != nil {
 		return p.error
 	}
-	start.setNext(s);
-	re.start = start;
-	e.setNext(re.add(new(_End)));
+	start.setNext(s)
+	re.start = start
+	e.setNext(re.add(new(_End)))
 
 	if debug {
-		re.dump();
-		println();
+		re.dump()
+		println()
 	}
 
-	re.eliminateNops();
+	re.eliminateNops()
 	if debug {
-		re.dump();
-		println();
+		re.dump()
+		println()
 	}
 	if p.error == nil {
-		re.setPrefix();
+		re.setPrefix()
 		if debug {
-			re.dump();
-			println();
+			re.dump()
+			println()
 		}
 	}
-	return p.error;
+	return p.error
 }
 
 // Extract regular text from the beginning of the pattern.
 // That text can be used by doExecute to speed up matching.
 func (re *Regexp) setPrefix() {
-	var b []byte;
-	var utf = make([]byte, utf8.UTFMax);
+	var b []byte
+	var utf = make([]byte, utf8.UTFMax)
 	// First instruction is start; skip that.
-	i := re.inst.At(0).(instr).next().index();
+	i := re.inst.At(0).(instr).next().index()
 Loop:
 	for i < re.inst.Len() {
-		inst := re.inst.At(i).(instr);
+		inst := re.inst.At(i).(instr)
 		// stop if this is not a char
 		if inst.kind() != _CHAR {
 			break
@@ -646,96 +646,96 @@ Loop:
 		case _BOT, _EOT, _ALT:
 			break Loop
 		}
-		n := utf8.EncodeRune(inst.(*_Char).char, utf);
-		b = bytes.Add(b, utf[0:n]);
-		i = inst.next().index();
+		n := utf8.EncodeRune(inst.(*_Char).char, utf)
+		b = bytes.Add(b, utf[0:n])
+		i = inst.next().index()
 	}
 	// point start instruction to first non-CHAR
-	re.inst.At(0).(instr).setNext(re.inst.At(i).(instr));
-	re.prefixBytes = b;
-	re.prefix = string(b);
+	re.inst.At(0).(instr).setNext(re.inst.At(i).(instr))
+	re.prefixBytes = b
+	re.prefix = string(b)
 }
 
 // Compile parses a regular expression and returns, if successful, a Regexp
 // object that can be used to match against text.
 func Compile(str string) (regexp *Regexp, error os.Error) {
-	regexp = new(Regexp);
-	regexp.expr = str;
-	regexp.inst = new(vector.Vector);
-	error = regexp.doParse();
-	return;
+	regexp = new(Regexp)
+	regexp.expr = str
+	regexp.inst = new(vector.Vector)
+	error = regexp.doParse()
+	return
 }
 
 // MustCompile is like Compile but panics if the expression cannot be parsed.
 // It simplifies safe initialization of global variables holding compiled regular
 // expressions.
 func MustCompile(str string) *Regexp {
-	regexp, error := Compile(str);
+	regexp, error := Compile(str)
 	if error != nil {
 		panicln(`regexp: compiling "`, str, `": `, error.String())
 	}
-	return regexp;
+	return regexp
 }
 
 // The match arena allows us to reduce the garbage generated by tossing
 // match vectors away as we execute.  Matches are ref counted and returned
 // to a free list when no longer active.  Increases a simple benchmark by 22X.
 type matchArena struct {
-	head	*matchVec;
-	len	int;	// length of match vector
+	head *matchVec
+	len  int // length of match vector
 }
 
 type matchVec struct {
-	m	[]int;	// pairs of bracketing submatches. 0th is start,end
-	ref	int;
-	next	*matchVec;
+	m    []int // pairs of bracketing submatches. 0th is start,end
+	ref  int
+	next *matchVec
 }
 
 func (a *matchArena) new() *matchVec {
 	if a.head == nil {
-		const N = 10;
-		block := make([]matchVec, N);
+		const N = 10
+		block := make([]matchVec, N)
 		for i := 0; i < N; i++ {
-			b := &block[i];
-			b.next = a.head;
-			a.head = b;
+			b := &block[i]
+			b.next = a.head
+			a.head = b
 		}
 	}
-	m := a.head;
-	a.head = m.next;
-	m.ref = 0;
+	m := a.head
+	a.head = m.next
+	m.ref = 0
 	if m.m == nil {
 		m.m = make([]int, a.len)
 	}
-	return m;
+	return m
 }
 
 func (a *matchArena) free(m *matchVec) {
-	m.ref--;
+	m.ref--
 	if m.ref == 0 {
-		m.next = a.head;
-		a.head = m;
+		m.next = a.head
+		a.head = m
 	}
 }
 
 func (a *matchArena) copy(m *matchVec) *matchVec {
-	m1 := a.new();
-	copy(m1.m, m.m);
-	return m1;
+	m1 := a.new()
+	copy(m1.m, m.m)
+	return m1
 }
 
 func (a *matchArena) noMatch() *matchVec {
-	m := a.new();
+	m := a.new()
 	for i := range m.m {
-		m.m[i] = -1	// no match seen; catches cases like "a(b)?c" on "ac"
+		m.m[i] = -1 // no match seen; catches cases like "a(b)?c" on "ac"
 	}
-	m.ref = 1;
-	return m;
+	m.ref = 1
+	return m
 }
 
 type state struct {
-	inst	instr;	// next instruction to execute
-	match	*matchVec;
+	inst  instr // next instruction to execute
+	match *matchVec
 }
 
 // Append new state to to-do list.  Leftmost-longest wins so avoid
@@ -747,25 +747,25 @@ func (a *matchArena) addState(s []state, inst instr, match *matchVec, pos, end i
 		if pos == 0 {
 			s = a.addState(s, inst.next(), match, pos, end)
 		}
-		return s;
+		return s
 	case _EOT:
 		if pos == end {
 			s = a.addState(s, inst.next(), match, pos, end)
 		}
-		return s;
+		return s
 	case _BRA:
-		n := inst.(*_Bra).n;
-		match.m[2*n] = pos;
-		s = a.addState(s, inst.next(), match, pos, end);
-		return s;
+		n := inst.(*_Bra).n
+		match.m[2*n] = pos
+		s = a.addState(s, inst.next(), match, pos, end)
+		return s
 	case _EBRA:
-		n := inst.(*_Ebra).n;
-		match.m[2*n+1] = pos;
-		s = a.addState(s, inst.next(), match, pos, end);
-		return s;
+		n := inst.(*_Ebra).n
+		match.m[2*n+1] = pos
+		s = a.addState(s, inst.next(), match, pos, end)
+		return s
 	}
-	index := inst.index();
-	l := len(s);
+	index := inst.index()
+	l := len(s)
 	// States are inserted in order so it's sufficient to see if we have the same
 	// instruction; no need to see if existing match is earlier (it is).
 	for i := 0; i < l; i++ {
@@ -774,38 +774,38 @@ func (a *matchArena) addState(s []state, inst instr, match *matchVec, pos, end i
 		}
 	}
 	if l == cap(s) {
-		s1 := make([]state, 2*l)[0:l];
-		copy(s1, s);
-		s = s1;
+		s1 := make([]state, 2*l)[0:l]
+		copy(s1, s)
+		s = s1
 	}
-	s = s[0 : l+1];
-	s[l].inst = inst;
-	s[l].match = match;
-	match.ref++;
+	s = s[0 : l+1]
+	s[l].inst = inst
+	s[l].match = match
+	match.ref++
 	if inst.kind() == _ALT {
-		s = a.addState(s, inst.(*_Alt).left, a.copy(match), pos, end);
+		s = a.addState(s, inst.(*_Alt).left, a.copy(match), pos, end)
 		// give other branch a copy of this match vector
-		s = a.addState(s, inst.next(), a.copy(match), pos, end);
+		s = a.addState(s, inst.next(), a.copy(match), pos, end)
 	}
-	return s;
+	return s
 }
 
 // Accepts either string or bytes - the logic is identical either way.
 // If bytes == nil, scan str.
 func (re *Regexp) doExecute(str string, bytestr []byte, pos int) []int {
-	var s [2][]state;
-	s[0] = make([]state, 10)[0:0];
-	s[1] = make([]state, 10)[0:0];
-	in, out := 0, 1;
-	var final state;
-	found := false;
-	end := len(str);
+	var s [2][]state
+	s[0] = make([]state, 10)[0:0]
+	s[1] = make([]state, 10)[0:0]
+	in, out := 0, 1
+	var final state
+	found := false
+	end := len(str)
 	if bytestr != nil {
 		end = len(bytestr)
 	}
 	// fast check for initial plain substring
 	if re.prefix != "" {
-		var advance int;
+		var advance int
 		if bytestr == nil {
 			advance = strings.Index(str[pos:], re.prefix)
 		} else {
@@ -814,30 +814,30 @@ func (re *Regexp) doExecute(str string, bytestr []byte, pos int) []int {
 		if advance == -1 {
 			return []int{}
 		}
-		pos += advance + len(re.prefix);
+		pos += advance + len(re.prefix)
 	}
-	arena := &matchArena{nil, 2 * (re.nbra + 1)};
+	arena := &matchArena{nil, 2 * (re.nbra + 1)}
 	for pos <= end {
 		if !found {
 			// prime the pump if we haven't seen a match yet
-			match := arena.noMatch();
-			match.m[0] = pos;
-			s[out] = arena.addState(s[out], re.start.next(), match, pos, end);
-			arena.free(match);	// if addState saved it, ref was incremented
+			match := arena.noMatch()
+			match.m[0] = pos
+			s[out] = arena.addState(s[out], re.start.next(), match, pos, end)
+			arena.free(match) // if addState saved it, ref was incremented
 		}
-		in, out = out, in;	// old out state is new in state
+		in, out = out, in // old out state is new in state
 		// clear out old state
-		old := s[out];
+		old := s[out]
 		for _, state := range old {
 			arena.free(state.match)
 		}
-		s[out] = old[0:0];	// truncate state vector
+		s[out] = old[0:0] // truncate state vector
 		if found && len(s[in]) == 0 {
 			// machine has completed
 			break
 		}
-		charwidth := 1;
-		c := endOfFile;
+		charwidth := 1
+		c := endOfFile
 		if pos < end {
 			if bytestr == nil {
 				c, charwidth = utf8.DecodeRuneInString(str[pos:end])
@@ -845,7 +845,7 @@ func (re *Regexp) doExecute(str string, bytestr []byte, pos int) []int {
 				c, charwidth = utf8.DecodeRune(bytestr[pos:end])
 			}
 		}
-		pos += charwidth;
+		pos += charwidth
 		for _, st := range s[in] {
 			switch st.inst.kind() {
 			case _BOT:
@@ -871,20 +871,20 @@ func (re *Regexp) doExecute(str string, bytestr []byte, pos int) []int {
 			case _ALT:
 			case _END:
 				// choose leftmost longest
-				if !found ||	// first
-					st.match.m[0] < final.match.m[0] ||	// leftmost
-					(st.match.m[0] == final.match.m[0] && pos-charwidth > final.match.m[1]) {	// longest
+				if !found || // first
+					st.match.m[0] < final.match.m[0] || // leftmost
+					(st.match.m[0] == final.match.m[0] && pos-charwidth > final.match.m[1]) { // longest
 					if final.match != nil {
 						arena.free(final.match)
 					}
-					final = st;
-					final.match.ref++;
-					final.match.m[1] = pos - charwidth;
+					final = st
+					final.match.ref++
+					final.match.m[1] = pos - charwidth
 				}
-				found = true;
+				found = true
 			default:
-				st.inst.print();
-				panic("unknown instruction in execute");
+				st.inst.print()
+				panic("unknown instruction in execute")
 			}
 		}
 	}
@@ -895,7 +895,7 @@ func (re *Regexp) doExecute(str string, bytestr []byte, pos int) []int {
 	if re.prefix != "" && len(final.match.m) > 0 {
 		final.match.m[0] -= len(re.prefix)
 	}
-	return final.match.m;
+	return final.match.m
 }
 
 
@@ -918,17 +918,17 @@ func (re *Regexp) ExecuteString(s string) (a []int) {
 //    b[a[2*i]:a[2*i+1]] for i > 0 is the subslice matched by the ith parenthesized subexpression.
 // A negative value means the subexpression did not match any element of the slice.
 // An empty array means "no match".
-func (re *Regexp) Execute(b []byte) (a []int)	{ return re.doExecute("", b, 0) }
+func (re *Regexp) Execute(b []byte) (a []int) { return re.doExecute("", b, 0) }
 
 
 // MatchString returns whether the Regexp matches the string s.
 // The return value is a boolean: true for match, false for no match.
-func (re *Regexp) MatchString(s string) bool	{ return len(re.doExecute(s, nil, 0)) > 0 }
+func (re *Regexp) MatchString(s string) bool { return len(re.doExecute(s, nil, 0)) > 0 }
 
 
 // Match returns whether the Regexp matches the byte slice b.
 // The return value is a boolean: true for match, false for no match.
-func (re *Regexp) Match(b []byte) bool	{ return len(re.doExecute("", b, 0)) > 0 }
+func (re *Regexp) Match(b []byte) bool { return len(re.doExecute("", b, 0)) > 0 }
 
 
 // MatchStrings matches the Regexp against the string s.
@@ -937,17 +937,17 @@ func (re *Regexp) Match(b []byte) bool	{ return len(re.doExecute("", b, 0)) > 0
 //    a[i] for i > 0 is the substring matched by the ith parenthesized subexpression.
 // An empty array means ``no match''.
 func (re *Regexp) MatchStrings(s string) (a []string) {
-	r := re.doExecute(s, nil, 0);
+	r := re.doExecute(s, nil, 0)
 	if r == nil {
 		return nil
 	}
-	a = make([]string, len(r)/2);
+	a = make([]string, len(r)/2)
 	for i := 0; i < len(r); i += 2 {
-		if r[i] != -1 {	// -1 means no match for this subexpression
+		if r[i] != -1 { // -1 means no match for this subexpression
 			a[i/2] = s[r[i]:r[i+1]]
 		}
 	}
-	return;
+	return
 }
 
 // MatchSlices matches the Regexp against the byte slice b.
@@ -956,56 +956,56 @@ func (re *Regexp) MatchStrings(s string) (a []string) {
 //    a[i] for i > 0 is the subslice matched by the ith parenthesized subexpression.
 // An empty array means ``no match''.
 func (re *Regexp) MatchSlices(b []byte) (a [][]byte) {
-	r := re.doExecute("", b, 0);
+	r := re.doExecute("", b, 0)
 	if r == nil {
 		return nil
 	}
-	a = make([][]byte, len(r)/2);
+	a = make([][]byte, len(r)/2)
 	for i := 0; i < len(r); i += 2 {
-		if r[i] != -1 {	// -1 means no match for this subexpression
+		if r[i] != -1 { // -1 means no match for this subexpression
 			a[i/2] = b[r[i]:r[i+1]]
 		}
 	}
-	return;
+	return
 }
 
 // MatchString checks whether a textual regular expression
 // matches a string.  More complicated queries need
 // to use Compile and the full Regexp interface.
 func MatchString(pattern string, s string) (matched bool, error os.Error) {
-	re, err := Compile(pattern);
+	re, err := Compile(pattern)
 	if err != nil {
 		return false, err
 	}
-	return re.MatchString(s), nil;
+	return re.MatchString(s), nil
 }
 
 // Match checks whether a textual regular expression
 // matches a byte slice.  More complicated queries need
 // to use Compile and the full Regexp interface.
 func Match(pattern string, b []byte) (matched bool, error os.Error) {
-	re, err := Compile(pattern);
+	re, err := Compile(pattern)
 	if err != nil {
 		return false, err
 	}
-	return re.Match(b), nil;
+	return re.Match(b), nil
 }
 
 // ReplaceAllString returns a copy of src in which all matches for the Regexp
 // have been replaced by repl.  No support is provided for expressions
 // (e.g. \1 or $1) in the replacement string.
 func (re *Regexp) ReplaceAllString(src, repl string) string {
-	lastMatchEnd := 0;	// end position of the most recent match
-	searchPos := 0;		// position where we next look for a match
-	buf := new(bytes.Buffer);
+	lastMatchEnd := 0 // end position of the most recent match
+	searchPos := 0    // position where we next look for a match
+	buf := new(bytes.Buffer)
 	for searchPos <= len(src) {
-		a := re.doExecute(src, nil, searchPos);
+		a := re.doExecute(src, nil, searchPos)
 		if len(a) == 0 {
-			break	// no more matches
+			break // no more matches
 		}
 
 		// Copy the unmatched characters before this match.
-		io.WriteString(buf, src[lastMatchEnd:a[0]]);
+		io.WriteString(buf, src[lastMatchEnd:a[0]])
 
 		// Now insert a copy of the replacement string, but not for a
 		// match of the empty string immediately after another match.
@@ -1014,10 +1014,10 @@ func (re *Regexp) ReplaceAllString(src, repl string) string {
 		if a[1] > lastMatchEnd || a[0] == 0 {
 			io.WriteString(buf, repl)
 		}
-		lastMatchEnd = a[1];
+		lastMatchEnd = a[1]
 
 		// Advance past this match; always advance at least one character.
-		_, width := utf8.DecodeRuneInString(src[searchPos:]);
+		_, width := utf8.DecodeRuneInString(src[searchPos:])
 		if searchPos+width > a[1] {
 			searchPos += width
 		} else if searchPos+1 > a[1] {
@@ -1030,26 +1030,26 @@ func (re *Regexp) ReplaceAllString(src, repl string) string {
 	}
 
 	// Copy the unmatched characters after the last match.
-	io.WriteString(buf, src[lastMatchEnd:]);
+	io.WriteString(buf, src[lastMatchEnd:])
 
-	return buf.String();
+	return buf.String()
 }
 
 // ReplaceAll returns a copy of src in which all matches for the Regexp
 // have been replaced by repl.  No support is provided for expressions
 // (e.g. \1 or $1) in the replacement text.
 func (re *Regexp) ReplaceAll(src, repl []byte) []byte {
-	lastMatchEnd := 0;	// end position of the most recent match
-	searchPos := 0;		// position where we next look for a match
-	buf := new(bytes.Buffer);
+	lastMatchEnd := 0 // end position of the most recent match
+	searchPos := 0    // position where we next look for a match
+	buf := new(bytes.Buffer)
 	for searchPos <= len(src) {
-		a := re.doExecute("", src, searchPos);
+		a := re.doExecute("", src, searchPos)
 		if len(a) == 0 {
-			break	// no more matches
+			break // no more matches
 		}
 
 		// Copy the unmatched characters before this match.
-		buf.Write(src[lastMatchEnd:a[0]]);
+		buf.Write(src[lastMatchEnd:a[0]])
 
 		// Now insert a copy of the replacement string, but not for a
 		// match of the empty string immediately after another match.
@@ -1058,10 +1058,10 @@ func (re *Regexp) ReplaceAll(src, repl []byte) []byte {
 		if a[1] > lastMatchEnd || a[0] == 0 {
 			buf.Write(repl)
 		}
-		lastMatchEnd = a[1];
+		lastMatchEnd = a[1]
 
 		// Advance past this match; always advance at least one character.
-		_, width := utf8.DecodeRune(src[searchPos:]);
+		_, width := utf8.DecodeRune(src[searchPos:])
 		if searchPos+width > a[1] {
 			searchPos += width
 		} else if searchPos+1 > a[1] {
@@ -1074,33 +1074,33 @@ func (re *Regexp) ReplaceAll(src, repl []byte) []byte {
 	}
 
 	// Copy the unmatched characters after the last match.
-	buf.Write(src[lastMatchEnd:]);
+	buf.Write(src[lastMatchEnd:])
 
-	return buf.Bytes();
+	return buf.Bytes()
 }
 
 // QuoteMeta returns a string that quotes all regular expression metacharacters
 // inside the argument text; the returned string is a regular expression matching
 // the literal text.  For example, QuoteMeta(`[foo]`) returns `\[foo\]`.
 func QuoteMeta(s string) string {
-	b := make([]byte, 2*len(s));
+	b := make([]byte, 2*len(s))
 
 	// A byte loop is correct because all metacharacters are ASCII.
-	j := 0;
+	j := 0
 	for i := 0; i < len(s); i++ {
 		if special(int(s[i])) {
-			b[j] = '\\';
-			j++;
+			b[j] = '\\'
+			j++
 		}
-		b[j] = s[i];
-		j++;
+		b[j] = s[i]
+		j++
 	}
-	return string(b[0:j]);
+	return string(b[0:j])
 }
 
 // Find matches in slice b if b is non-nil, otherwise find matches in string s.
 func (re *Regexp) allMatches(s string, b []byte, n int, deliver func(int, int)) {
-	var end int;
+	var end int
 	if b == nil {
 		end = len(s)
 	} else {
@@ -1108,12 +1108,12 @@ func (re *Regexp) allMatches(s string, b []byte, n int, deliver func(int, int))
 	}
 
 	for pos, i, prevMatchEnd := 0, 0, -1; i < n && pos <= end; {
-		matches := re.doExecute(s, b, pos);
+		matches := re.doExecute(s, b, pos)
 		if len(matches) == 0 {
 			break
 		}
 
-		accept := true;
+		accept := true
 		if matches[1] == pos {
 			// We've found an empty match.
 			if matches[0] == prevMatchEnd {
@@ -1121,7 +1121,7 @@ func (re *Regexp) allMatches(s string, b []byte, n int, deliver func(int, int))
 				// after a previous match, so ignore it.
 				accept = false
 			}
-			var width int;
+			var width int
 			if b == nil {
 				_, width = utf8.DecodeRuneInString(s[pos:end])
 			} else {
@@ -1135,11 +1135,11 @@ func (re *Regexp) allMatches(s string, b []byte, n int, deliver func(int, int))
 		} else {
 			pos = matches[1]
 		}
-		prevMatchEnd = matches[1];
+		prevMatchEnd = matches[1]
 
 		if accept {
-			deliver(matches[0], matches[1]);
-			i++;
+			deliver(matches[0], matches[1])
+			i++
 		}
 	}
 }
@@ -1153,13 +1153,13 @@ func (re *Regexp) AllMatches(b []byte, n int) [][]byte {
 	if n <= 0 {
 		n = len(b) + 1
 	}
-	result := make([][]byte, n);
-	i := 0;
+	result := make([][]byte, n)
+	i := 0
 	re.allMatches("", b, n, func(start, end int) {
-		result[i] = b[start:end];
-		i++;
-	});
-	return result[0:i];
+		result[i] = b[start:end]
+		i++
+	})
+	return result[0:i]
 }
 
 // AllMatchesString slices the string s into substrings that are successive
@@ -1171,13 +1171,13 @@ func (re *Regexp) AllMatchesString(s string, n int) []string {
 	if n <= 0 {
 		n = len(s) + 1
 	}
-	result := make([]string, n);
-	i := 0;
+	result := make([]string, n)
+	i := 0
 	re.allMatches(s, nil, n, func(start, end int) {
-		result[i] = s[start:end];
-		i++;
-	});
-	return result[0:i];
+		result[i] = s[start:end]
+		i++
+	})
+	return result[0:i]
 }
 
 // AllMatchesIter slices the byte slice b into substrings that are successive
@@ -1189,12 +1189,12 @@ func (re *Regexp) AllMatchesIter(b []byte, n int) <-chan []byte {
 	if n <= 0 {
 		n = len(b) + 1
 	}
-	c := make(chan []byte, 10);
+	c := make(chan []byte, 10)
 	go func() {
-		re.allMatches("", b, n, func(start, end int) { c <- b[start:end] });
-		close(c);
-	}();
-	return c;
+		re.allMatches("", b, n, func(start, end int) { c <- b[start:end] })
+		close(c)
+	}()
+	return c
 }
 
 // AllMatchesStringIter slices the string s into substrings that are successive
@@ -1206,10 +1206,10 @@ func (re *Regexp) AllMatchesStringIter(s string, n int) <-chan string {
 	if n <= 0 {
 		n = len(s) + 1
 	}
-	c := make(chan string, 10);
+	c := make(chan string, 10)
 	go func() {
-		re.allMatches(s, nil, n, func(start, end int) { c <- s[start:end] });
-		close(c);
-	}();
-	return c;
+		re.allMatches(s, nil, n, func(start, end int) { c <- s[start:end] })
+		close(c)
+	}()
+	return c
 }
diff --git a/src/pkg/rpc/client.go b/src/pkg/rpc/client.go
index 827dbe1b41..673283be3d 100644
--- a/src/pkg/rpc/client.go
+++ b/src/pkg/rpc/client.go
@@ -5,84 +5,84 @@
 package rpc
 
 import (
-	"bufio";
-	"gob";
-	"http";
-	"io";
-	"log";
-	"net";
-	"os";
-	"sync";
+	"bufio"
+	"gob"
+	"http"
+	"io"
+	"log"
+	"net"
+	"os"
+	"sync"
 )
 
 // Call represents an active RPC.
 type Call struct {
-	ServiceMethod	string;		// The name of the service and method to call.
-	Args		interface{};	// The argument to the function (*struct).
-	Reply		interface{};	// The reply from the function (*struct).
-	Error		os.Error;	// After completion, the error status.
-	Done		chan *Call;	// Strobes when call is complete; value is the error status.
-	seq		uint64;
+	ServiceMethod string      // The name of the service and method to call.
+	Args          interface{} // The argument to the function (*struct).
+	Reply         interface{} // The reply from the function (*struct).
+	Error         os.Error    // After completion, the error status.
+	Done          chan *Call  // Strobes when call is complete; value is the error status.
+	seq           uint64
 }
 
 // Client represents an RPC Client.
 // There may be multiple outstanding Calls associated
 // with a single Client.
 type Client struct {
-	mutex		sync.Mutex;	// protects pending, seq
-	shutdown	os.Error;	// non-nil if the client is shut down
-	sending		sync.Mutex;
-	seq		uint64;
-	conn		io.ReadWriteCloser;
-	enc		*gob.Encoder;
-	dec		*gob.Decoder;
-	pending		map[uint64]*Call;
+	mutex    sync.Mutex // protects pending, seq
+	shutdown os.Error   // non-nil if the client is shut down
+	sending  sync.Mutex
+	seq      uint64
+	conn     io.ReadWriteCloser
+	enc      *gob.Encoder
+	dec      *gob.Decoder
+	pending  map[uint64]*Call
 }
 
 func (client *Client) send(c *Call) {
 	// Register this call.
-	client.mutex.Lock();
+	client.mutex.Lock()
 	if client.shutdown != nil {
-		c.Error = client.shutdown;
-		client.mutex.Unlock();
-		_ = c.Done <- c;	// do not block
-		return;
+		c.Error = client.shutdown
+		client.mutex.Unlock()
+		_ = c.Done <- c // do not block
+		return
 	}
-	c.seq = client.seq;
-	client.seq++;
-	client.pending[c.seq] = c;
-	client.mutex.Unlock();
+	c.seq = client.seq
+	client.seq++
+	client.pending[c.seq] = c
+	client.mutex.Unlock()
 
 	// Encode and send the request.
-	request := new(Request);
-	client.sending.Lock();
-	request.Seq = c.seq;
-	request.ServiceMethod = c.ServiceMethod;
-	client.enc.Encode(request);
-	err := client.enc.Encode(c.Args);
+	request := new(Request)
+	client.sending.Lock()
+	request.Seq = c.seq
+	request.ServiceMethod = c.ServiceMethod
+	client.enc.Encode(request)
+	err := client.enc.Encode(c.Args)
 	if err != nil {
 		panicln("rpc: client encode error:", err.String())
 	}
-	client.sending.Unlock();
+	client.sending.Unlock()
 }
 
 func (client *Client) input() {
-	var err os.Error;
+	var err os.Error
 	for err == nil {
-		response := new(Response);
-		err = client.dec.Decode(response);
+		response := new(Response)
+		err = client.dec.Decode(response)
 		if err != nil {
 			if err == os.EOF {
 				err = io.ErrUnexpectedEOF
 			}
-			break;
+			break
 		}
-		seq := response.Seq;
-		client.mutex.Lock();
-		c := client.pending[seq];
-		client.pending[seq] = c, false;
-		client.mutex.Unlock();
-		err = client.dec.Decode(c.Reply);
+		seq := response.Seq
+		client.mutex.Lock()
+		c := client.pending[seq]
+		client.pending[seq] = c, false
+		client.mutex.Unlock()
+		err = client.dec.Decode(c.Reply)
 		// Empty strings should turn into nil os.Errors
 		if response.Error != "" {
 			c.Error = os.ErrorString(response.Error)
@@ -91,59 +91,59 @@ func (client *Client) input() {
 		}
 		// We don't want to block here.  It is the caller's responsibility to make
 		// sure the channel has enough buffer space. See comment in Go().
-		_ = c.Done <- c;	// do not block
+		_ = c.Done <- c // do not block
 	}
 	// Terminate pending calls.
-	client.mutex.Lock();
-	client.shutdown = err;
+	client.mutex.Lock()
+	client.shutdown = err
 	for _, call := range client.pending {
-		call.Error = err;
-		_ = call.Done <- call;	// do not block
+		call.Error = err
+		_ = call.Done <- call // do not block
 	}
-	client.mutex.Unlock();
-	log.Stderr("rpc: client protocol error:", err);
+	client.mutex.Unlock()
+	log.Stderr("rpc: client protocol error:", err)
 }
 
 // NewClient returns a new Client to handle requests to the
 // set of services at the other end of the connection.
 func NewClient(conn io.ReadWriteCloser) *Client {
-	client := new(Client);
-	client.conn = conn;
-	client.enc = gob.NewEncoder(conn);
-	client.dec = gob.NewDecoder(conn);
-	client.pending = make(map[uint64]*Call);
-	go client.input();
-	return client;
+	client := new(Client)
+	client.conn = conn
+	client.enc = gob.NewEncoder(conn)
+	client.dec = gob.NewDecoder(conn)
+	client.pending = make(map[uint64]*Call)
+	go client.input()
+	return client
 }
 
 // DialHTTP connects to an HTTP RPC server at the specified network address.
 func DialHTTP(network, address string) (*Client, os.Error) {
-	conn, err := net.Dial(network, "", address);
+	conn, err := net.Dial(network, "", address)
 	if err != nil {
 		return nil, err
 	}
-	io.WriteString(conn, "CONNECT "+rpcPath+" HTTP/1.0\n\n");
+	io.WriteString(conn, "CONNECT "+rpcPath+" HTTP/1.0\n\n")
 
 	// Require successful HTTP response
 	// before switching to RPC protocol.
-	resp, err := http.ReadResponse(bufio.NewReader(conn));
+	resp, err := http.ReadResponse(bufio.NewReader(conn))
 	if err == nil && resp.Status == connected {
 		return NewClient(conn), nil
 	}
 	if err == nil {
 		err = os.ErrorString("unexpected HTTP response: " + resp.Status)
 	}
-	conn.Close();
-	return nil, &net.OpError{"dial-http", network + " " + address, nil, err};
+	conn.Close()
+	return nil, &net.OpError{"dial-http", network + " " + address, nil, err}
 }
 
 // Dial connects to an RPC server at the specified network address.
 func Dial(network, address string) (*Client, os.Error) {
-	conn, err := net.Dial(network, "", address);
+	conn, err := net.Dial(network, "", address)
 	if err != nil {
 		return nil, err
 	}
-	return NewClient(conn), nil;
+	return NewClient(conn), nil
 }
 
 // Go invokes the function asynchronously.  It returns the Call structure representing
@@ -151,12 +151,12 @@ func Dial(network, address string) (*Client, os.Error) {
 // the same Call object.  If done is nil, Go will allocate a new channel.
 // If non-nil, done must be buffered or Go will deliberately crash.
 func (client *Client) Go(serviceMethod string, args interface{}, reply interface{}, done chan *Call) *Call {
-	c := new(Call);
-	c.ServiceMethod = serviceMethod;
-	c.Args = args;
-	c.Reply = reply;
+	c := new(Call)
+	c.ServiceMethod = serviceMethod
+	c.Args = args
+	c.Reply = reply
 	if done == nil {
-		done = make(chan *Call, 10)	// buffered.
+		done = make(chan *Call, 10) // buffered.
 	} else {
 		// If caller passes done != nil, it must arrange that
 		// done has enough buffer for the number of simultaneous
@@ -166,14 +166,14 @@ func (client *Client) Go(serviceMethod string, args interface{}, reply interface
 			log.Crash("rpc: done channel is unbuffered")
 		}
 	}
-	c.Done = done;
+	c.Done = done
 	if client.shutdown != nil {
-		c.Error = client.shutdown;
-		_ = c.Done <- c;	// do not block
-		return c;
+		c.Error = client.shutdown
+		_ = c.Done <- c // do not block
+		return c
 	}
-	client.send(c);
-	return c;
+	client.send(c)
+	return c
 }
 
 // Call invokes the named function, waits for it to complete, and returns its error status.
@@ -181,6 +181,6 @@ func (client *Client) Call(serviceMethod string, args interface{}, reply interfa
 	if client.shutdown != nil {
 		return client.shutdown
 	}
-	call := <-client.Go(serviceMethod, args, reply, nil).Done;
-	return call.Error;
+	call := <-client.Go(serviceMethod, args, reply, nil).Done
+	return call.Error
 }
diff --git a/src/pkg/rpc/debug.go b/src/pkg/rpc/debug.go
index 7ba74a5e0e..638584f497 100644
--- a/src/pkg/rpc/debug.go
+++ b/src/pkg/rpc/debug.go
@@ -10,10 +10,10 @@ package rpc
 */
 
 import (
-	"fmt";
-	"http";
-	"sort";
-	"template";
+	"fmt"
+	"http"
+	"sort"
+	"template"
 )
 
 const debugText = `<html>
@@ -39,47 +39,47 @@ const debugText = `<html>
 var debug = template.MustParse(debugText, nil)
 
 type debugMethod struct {
-	m	*methodType;
-	name	string;
+	m    *methodType
+	name string
 }
 
 type methodArray []debugMethod
 
 type debugService struct {
-	s	*service;
-	name	string;
-	meth	methodArray;
+	s    *service
+	name string
+	meth methodArray
 }
 
 type serviceArray []debugService
 
-func (s serviceArray) Len() int			{ return len(s) }
-func (s serviceArray) Less(i, j int) bool	{ return s[i].name < s[j].name }
-func (s serviceArray) Swap(i, j int)		{ s[i], s[j] = s[j], s[i] }
+func (s serviceArray) Len() int           { return len(s) }
+func (s serviceArray) Less(i, j int) bool { return s[i].name < s[j].name }
+func (s serviceArray) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
 
-func (m methodArray) Len() int			{ return len(m) }
-func (m methodArray) Less(i, j int) bool	{ return m[i].name < m[j].name }
-func (m methodArray) Swap(i, j int)		{ m[i], m[j] = m[j], m[i] }
+func (m methodArray) Len() int           { return len(m) }
+func (m methodArray) Less(i, j int) bool { return m[i].name < m[j].name }
+func (m methodArray) Swap(i, j int)      { m[i], m[j] = m[j], m[i] }
 
 // Runs at /debug/rpc
 func debugHTTP(c *http.Conn, req *http.Request) {
 	// Build a sorted version of the data.
-	var services = make(serviceArray, len(server.serviceMap));
-	i := 0;
-	server.Lock();
+	var services = make(serviceArray, len(server.serviceMap))
+	i := 0
+	server.Lock()
 	for sname, service := range server.serviceMap {
-		services[i] = debugService{service, sname, make(methodArray, len(service.method))};
-		j := 0;
+		services[i] = debugService{service, sname, make(methodArray, len(service.method))}
+		j := 0
 		for mname, method := range service.method {
-			services[i].meth[j] = debugMethod{method, mname};
-			j++;
+			services[i].meth[j] = debugMethod{method, mname}
+			j++
 		}
-		sort.Sort(services[i].meth);
-		i++;
+		sort.Sort(services[i].meth)
+		i++
 	}
-	server.Unlock();
-	sort.Sort(services);
-	err := debug.Execute(services, c);
+	server.Unlock()
+	sort.Sort(services)
+	err := debug.Execute(services, c)
 	if err != nil {
 		fmt.Fprintln(c, "rpc: error executing template:", err.String())
 	}
diff --git a/src/pkg/rpc/server.go b/src/pkg/rpc/server.go
index 3e01a9d419..2fdae0b467 100644
--- a/src/pkg/rpc/server.go
+++ b/src/pkg/rpc/server.go
@@ -108,17 +108,17 @@
 package rpc
 
 import (
-	"gob";
-	"http";
-	"log";
-	"io";
-	"net";
-	"os";
-	"reflect";
-	"strings";
-	"sync";
-	"unicode";
-	"utf8";
+	"gob"
+	"http"
+	"log"
+	"io"
+	"net"
+	"os"
+	"reflect"
+	"strings"
+	"sync"
+	"unicode"
+	"utf8"
 )
 
 // Precompute the reflect type for os.Error.  Can't use os.Error directly
@@ -127,40 +127,40 @@ var unusedError *os.Error
 var typeOfOsError = reflect.Typeof(unusedError).(*reflect.PtrType).Elem()
 
 type methodType struct {
-	sync.Mutex;	// protects counters
-	method		reflect.Method;
-	argType		*reflect.PtrType;
-	replyType	*reflect.PtrType;
-	numCalls	uint;
+	sync.Mutex // protects counters
+	method     reflect.Method
+	argType    *reflect.PtrType
+	replyType  *reflect.PtrType
+	numCalls   uint
 }
 
 type service struct {
-	name	string;			// name of service
-	rcvr	reflect.Value;		// receiver of methods for the service
-	typ	reflect.Type;		// type of the receiver
-	method	map[string]*methodType;	// registered methods
+	name   string                 // name of service
+	rcvr   reflect.Value          // receiver of methods for the service
+	typ    reflect.Type           // type of the receiver
+	method map[string]*methodType // registered methods
 }
 
 // Request is a header written before every RPC call.  It is used internally
 // but documented here as an aid to debugging, such as when analyzing
 // network traffic.
 type Request struct {
-	ServiceMethod	string;	// format: "Service.Method"
-	Seq		uint64;	// sequence number chosen by client
+	ServiceMethod string // format: "Service.Method"
+	Seq           uint64 // sequence number chosen by client
 }
 
 // Response is a header written before every RPC return.  It is used internally
 // but documented here as an aid to debugging, such as when analyzing
 // network traffic.
 type Response struct {
-	ServiceMethod	string;	// echoes that of the Request
-	Seq		uint64;	// echoes that of the request
-	Error		string;	// error, if any.
+	ServiceMethod string // echoes that of the Request
+	Seq           uint64 // echoes that of the request
+	Error         string // error, if any.
 }
 
 type serverType struct {
-	sync.Mutex;	// protects the serviceMap
-	serviceMap	map[string]*service;
+	sync.Mutex // protects the serviceMap
+	serviceMap map[string]*service
 }
 
 // This variable is a global whose "public" methods are really private methods
@@ -170,198 +170,198 @@ var server = &serverType{serviceMap: make(map[string]*service)}
 
 // Is this a publicly visible - upper case - name?
 func isPublic(name string) bool {
-	rune, _ := utf8.DecodeRuneInString(name);
-	return unicode.IsUpper(rune);
+	rune, _ := utf8.DecodeRuneInString(name)
+	return unicode.IsUpper(rune)
 }
 
 func (server *serverType) register(rcvr interface{}) os.Error {
-	server.Lock();
-	defer server.Unlock();
+	server.Lock()
+	defer server.Unlock()
 	if server.serviceMap == nil {
 		server.serviceMap = make(map[string]*service)
 	}
-	s := new(service);
-	s.typ = reflect.Typeof(rcvr);
-	s.rcvr = reflect.NewValue(rcvr);
-	sname := reflect.Indirect(s.rcvr).Type().Name();
+	s := new(service)
+	s.typ = reflect.Typeof(rcvr)
+	s.rcvr = reflect.NewValue(rcvr)
+	sname := reflect.Indirect(s.rcvr).Type().Name()
 	if sname == "" {
 		log.Exit("rpc: no service name for type", s.typ.String())
 	}
 	if !isPublic(sname) {
-		s := "rpc Register: type " + sname + " is not public";
-		log.Stderr(s);
-		return os.ErrorString(s);
+		s := "rpc Register: type " + sname + " is not public"
+		log.Stderr(s)
+		return os.ErrorString(s)
 	}
 	if _, present := server.serviceMap[sname]; present {
 		return os.ErrorString("rpc: service already defined: " + sname)
 	}
-	s.name = sname;
-	s.method = make(map[string]*methodType);
+	s.name = sname
+	s.method = make(map[string]*methodType)
 
 	// Install the methods
 	for m := 0; m < s.typ.NumMethod(); m++ {
-		method := s.typ.Method(m);
-		mtype := method.Type;
-		mname := method.Name;
+		method := s.typ.Method(m)
+		mtype := method.Type
+		mname := method.Name
 		if !isPublic(mname) {
 			continue
 		}
 		// Method needs three ins: receiver, *args, *reply.
 		// The args and reply must be structs until gobs are more general.
 		if mtype.NumIn() != 3 {
-			log.Stderr("method", mname, "has wrong number of ins:", mtype.NumIn());
-			continue;
+			log.Stderr("method", mname, "has wrong number of ins:", mtype.NumIn())
+			continue
 		}
-		argType, ok := mtype.In(1).(*reflect.PtrType);
+		argType, ok := mtype.In(1).(*reflect.PtrType)
 		if !ok {
-			log.Stderr(mname, "arg type not a pointer:", mtype.In(1));
-			continue;
+			log.Stderr(mname, "arg type not a pointer:", mtype.In(1))
+			continue
 		}
 		if _, ok := argType.Elem().(*reflect.StructType); !ok {
-			log.Stderr(mname, "arg type not a pointer to a struct:", argType);
-			continue;
+			log.Stderr(mname, "arg type not a pointer to a struct:", argType)
+			continue
 		}
-		replyType, ok := mtype.In(2).(*reflect.PtrType);
+		replyType, ok := mtype.In(2).(*reflect.PtrType)
 		if !ok {
-			log.Stderr(mname, "reply type not a pointer:", mtype.In(2));
-			continue;
+			log.Stderr(mname, "reply type not a pointer:", mtype.In(2))
+			continue
 		}
 		if _, ok := replyType.Elem().(*reflect.StructType); !ok {
-			log.Stderr(mname, "reply type not a pointer to a struct:", replyType);
-			continue;
+			log.Stderr(mname, "reply type not a pointer to a struct:", replyType)
+			continue
 		}
 		if !isPublic(argType.Elem().Name()) {
-			log.Stderr(mname, "argument type not public:", argType);
-			continue;
+			log.Stderr(mname, "argument type not public:", argType)
+			continue
 		}
 		if !isPublic(replyType.Elem().Name()) {
-			log.Stderr(mname, "reply type not public:", replyType);
-			continue;
+			log.Stderr(mname, "reply type not public:", replyType)
+			continue
 		}
 		// Method needs one out: os.Error.
 		if mtype.NumOut() != 1 {
-			log.Stderr("method", mname, "has wrong number of outs:", mtype.NumOut());
-			continue;
+			log.Stderr("method", mname, "has wrong number of outs:", mtype.NumOut())
+			continue
 		}
 		if returnType := mtype.Out(0); returnType != typeOfOsError {
-			log.Stderr("method", mname, "returns", returnType.String(), "not os.Error");
-			continue;
+			log.Stderr("method", mname, "returns", returnType.String(), "not os.Error")
+			continue
 		}
-		s.method[mname] = &methodType{method: method, argType: argType, replyType: replyType};
+		s.method[mname] = &methodType{method: method, argType: argType, replyType: replyType}
 	}
 
 	if len(s.method) == 0 {
-		s := "rpc Register: type " + sname + " has no public methods of suitable type";
-		log.Stderr(s);
-		return os.ErrorString(s);
+		s := "rpc Register: type " + sname + " has no public methods of suitable type"
+		log.Stderr(s)
+		return os.ErrorString(s)
 	}
-	server.serviceMap[s.name] = s;
-	return nil;
+	server.serviceMap[s.name] = s
+	return nil
 }
 
 // A value sent as a placeholder for the response when the server receives an invalid request.
 type InvalidRequest struct {
-	marker int;
+	marker int
 }
 
 var invalidRequest = InvalidRequest{1}
 
 func _new(t *reflect.PtrType) *reflect.PtrValue {
-	v := reflect.MakeZero(t).(*reflect.PtrValue);
-	v.PointTo(reflect.MakeZero(t.Elem()));
-	return v;
+	v := reflect.MakeZero(t).(*reflect.PtrValue)
+	v.PointTo(reflect.MakeZero(t.Elem()))
+	return v
 }
 
 func sendResponse(sending *sync.Mutex, req *Request, reply interface{}, enc *gob.Encoder, errmsg string) {
-	resp := new(Response);
+	resp := new(Response)
 	// Encode the response header
-	resp.ServiceMethod = req.ServiceMethod;
+	resp.ServiceMethod = req.ServiceMethod
 	if errmsg != "" {
 		resp.Error = errmsg
 	}
-	resp.Seq = req.Seq;
-	sending.Lock();
-	enc.Encode(resp);
+	resp.Seq = req.Seq
+	sending.Lock()
+	enc.Encode(resp)
 	// Encode the reply value.
-	enc.Encode(reply);
-	sending.Unlock();
+	enc.Encode(reply)
+	sending.Unlock()
 }
 
 func (s *service) call(sending *sync.Mutex, mtype *methodType, req *Request, argv, replyv reflect.Value, enc *gob.Encoder) {
-	mtype.Lock();
-	mtype.numCalls++;
-	mtype.Unlock();
-	function := mtype.method.Func;
+	mtype.Lock()
+	mtype.numCalls++
+	mtype.Unlock()
+	function := mtype.method.Func
 	// Invoke the method, providing a new value for the reply.
-	returnValues := function.Call([]reflect.Value{s.rcvr, argv, replyv});
+	returnValues := function.Call([]reflect.Value{s.rcvr, argv, replyv})
 	// The return value for the method is an os.Error.
-	errInter := returnValues[0].Interface();
-	errmsg := "";
+	errInter := returnValues[0].Interface()
+	errmsg := ""
 	if errInter != nil {
 		errmsg = errInter.(os.Error).String()
 	}
-	sendResponse(sending, req, replyv.Interface(), enc, errmsg);
+	sendResponse(sending, req, replyv.Interface(), enc, errmsg)
 }
 
 func (server *serverType) input(conn io.ReadWriteCloser) {
-	dec := gob.NewDecoder(conn);
-	enc := gob.NewEncoder(conn);
-	sending := new(sync.Mutex);
+	dec := gob.NewDecoder(conn)
+	enc := gob.NewEncoder(conn)
+	sending := new(sync.Mutex)
 	for {
 		// Grab the request header.
-		req := new(Request);
-		err := dec.Decode(req);
+		req := new(Request)
+		err := dec.Decode(req)
 		if err != nil {
 			if err == os.EOF || err == io.ErrUnexpectedEOF {
-				log.Stderr("rpc: ", err);
-				break;
+				log.Stderr("rpc: ", err)
+				break
 			}
-			s := "rpc: server cannot decode request: " + err.String();
-			sendResponse(sending, req, invalidRequest, enc, s);
-			continue;
+			s := "rpc: server cannot decode request: " + err.String()
+			sendResponse(sending, req, invalidRequest, enc, s)
+			continue
 		}
-		serviceMethod := strings.Split(req.ServiceMethod, ".", 0);
+		serviceMethod := strings.Split(req.ServiceMethod, ".", 0)
 		if len(serviceMethod) != 2 {
-			s := "rpc: service/method request ill:formed: " + req.ServiceMethod;
-			sendResponse(sending, req, invalidRequest, enc, s);
-			continue;
+			s := "rpc: service/method request ill:formed: " + req.ServiceMethod
+			sendResponse(sending, req, invalidRequest, enc, s)
+			continue
 		}
 		// Look up the request.
-		server.Lock();
-		service, ok := server.serviceMap[serviceMethod[0]];
-		server.Unlock();
+		server.Lock()
+		service, ok := server.serviceMap[serviceMethod[0]]
+		server.Unlock()
 		if !ok {
-			s := "rpc: can't find service " + req.ServiceMethod;
-			sendResponse(sending, req, invalidRequest, enc, s);
-			continue;
+			s := "rpc: can't find service " + req.ServiceMethod
+			sendResponse(sending, req, invalidRequest, enc, s)
+			continue
 		}
-		mtype, ok := service.method[serviceMethod[1]];
+		mtype, ok := service.method[serviceMethod[1]]
 		if !ok {
-			s := "rpc: can't find method " + req.ServiceMethod;
-			sendResponse(sending, req, invalidRequest, enc, s);
-			continue;
+			s := "rpc: can't find method " + req.ServiceMethod
+			sendResponse(sending, req, invalidRequest, enc, s)
+			continue
 		}
 		// Decode the argument value.
-		argv := _new(mtype.argType);
-		replyv := _new(mtype.replyType);
-		err = dec.Decode(argv.Interface());
+		argv := _new(mtype.argType)
+		replyv := _new(mtype.replyType)
+		err = dec.Decode(argv.Interface())
 		if err != nil {
-			log.Stderr("rpc: tearing down", serviceMethod[0], "connection:", err);
-			sendResponse(sending, req, replyv.Interface(), enc, err.String());
-			continue;
+			log.Stderr("rpc: tearing down", serviceMethod[0], "connection:", err)
+			sendResponse(sending, req, replyv.Interface(), enc, err.String())
+			continue
 		}
-		go service.call(sending, mtype, req, argv, replyv, enc);
+		go service.call(sending, mtype, req, argv, replyv, enc)
 	}
-	conn.Close();
+	conn.Close()
 }
 
 func (server *serverType) accept(lis net.Listener) {
 	for {
-		conn, err := lis.Accept();
+		conn, err := lis.Accept()
 		if err != nil {
-			log.Exit("rpc.Serve: accept:", err.String())	// TODO(r): exit?
+			log.Exit("rpc.Serve: accept:", err.String()) // TODO(r): exit?
 		}
-		go server.input(conn);
+		go server.input(conn)
 	}
 }
 
@@ -372,17 +372,17 @@ func (server *serverType) accept(lis net.Listener) {
 //	- one return value of type os.Error
 // It returns an error if the receiver is not public or has no
 // suitable methods.
-func Register(rcvr interface{}) os.Error	{ return server.register(rcvr) }
+func Register(rcvr interface{}) os.Error { return server.register(rcvr) }
 
 // ServeConn runs the server on a single connection.  When the connection
 // completes, service terminates.  ServeConn blocks; the caller typically
 // invokes it in a go statement.
-func ServeConn(conn io.ReadWriteCloser)	{ go server.input(conn) }
+func ServeConn(conn io.ReadWriteCloser) { go server.input(conn) }
 
 // Accept accepts connections on the listener and serves requests
 // for each incoming connection.  Accept blocks; the caller typically
 // invokes it in a go statement.
-func Accept(lis net.Listener)	{ server.accept(lis) }
+func Accept(lis net.Listener) { server.accept(lis) }
 
 // Can connect to RPC service using HTTP CONNECT to rpcPath.
 var rpcPath string = "/_goRPC_"
@@ -391,23 +391,23 @@ var connected = "200 Connected to Go RPC"
 
 func serveHTTP(c *http.Conn, req *http.Request) {
 	if req.Method != "CONNECT" {
-		c.SetHeader("Content-Type", "text/plain; charset=utf-8");
-		c.WriteHeader(http.StatusMethodNotAllowed);
-		io.WriteString(c, "405 must CONNECT to "+rpcPath+"\n");
-		return;
+		c.SetHeader("Content-Type", "text/plain; charset=utf-8")
+		c.WriteHeader(http.StatusMethodNotAllowed)
+		io.WriteString(c, "405 must CONNECT to "+rpcPath+"\n")
+		return
 	}
-	conn, _, err := c.Hijack();
+	conn, _, err := c.Hijack()
 	if err != nil {
-		log.Stderr("rpc hijacking ", c.RemoteAddr, ": ", err.String());
-		return;
+		log.Stderr("rpc hijacking ", c.RemoteAddr, ": ", err.String())
+		return
 	}
-	io.WriteString(conn, "HTTP/1.0 "+connected+"\n\n");
-	server.input(conn);
+	io.WriteString(conn, "HTTP/1.0 "+connected+"\n\n")
+	server.input(conn)
 }
 
 // HandleHTTP registers an HTTP handler for RPC messages.
 // It is still necessary to invoke http.Serve(), typically in a go statement.
 func HandleHTTP() {
-	http.Handle(rpcPath, http.HandlerFunc(serveHTTP));
-	http.Handle(debugPath, http.HandlerFunc(debugHTTP));
+	http.Handle(rpcPath, http.HandlerFunc(serveHTTP))
+	http.Handle(debugPath, http.HandlerFunc(debugHTTP))
 }
diff --git a/src/pkg/rpc/server_test.go b/src/pkg/rpc/server_test.go
index 8ee5ed7232..98c0eadd32 100644
--- a/src/pkg/rpc/server_test.go
+++ b/src/pkg/rpc/server_test.go
@@ -5,13 +5,13 @@
 package rpc
 
 import (
-	"http";
-	"log";
-	"net";
-	"once";
-	"os";
-	"strings";
-	"testing";
+	"http"
+	"log"
+	"net"
+	"once"
+	"os"
+	"strings"
+	"testing"
 )
 
 var serverAddr string
@@ -21,31 +21,31 @@ const second = 1e9
 
 
 type Args struct {
-	A, B int;
+	A, B int
 }
 
 type Reply struct {
-	C int;
+	C int
 }
 
 type Arith int
 
 func (t *Arith) Add(args *Args, reply *Reply) os.Error {
-	reply.C = args.A + args.B;
-	return nil;
+	reply.C = args.A + args.B
+	return nil
 }
 
 func (t *Arith) Mul(args *Args, reply *Reply) os.Error {
-	reply.C = args.A * args.B;
-	return nil;
+	reply.C = args.A * args.B
+	return nil
 }
 
 func (t *Arith) Div(args *Args, reply *Reply) os.Error {
 	if args.B == 0 {
 		return os.ErrorString("divide by zero")
 	}
-	reply.C = args.A / args.B;
-	return nil;
+	reply.C = args.A / args.B
+	return nil
 }
 
 func (t *Arith) Error(args *Args, reply *Reply) os.Error {
@@ -53,39 +53,39 @@ func (t *Arith) Error(args *Args, reply *Reply) os.Error {
 }
 
 func startServer() {
-	Register(new(Arith));
+	Register(new(Arith))
 
-	l, e := net.Listen("tcp", ":0");	// any available address
+	l, e := net.Listen("tcp", ":0") // any available address
 	if e != nil {
 		log.Exitf("net.Listen tcp :0: %v", e)
 	}
-	serverAddr = l.Addr().String();
-	log.Stderr("Test RPC server listening on ", serverAddr);
-	go Accept(l);
+	serverAddr = l.Addr().String()
+	log.Stderr("Test RPC server listening on ", serverAddr)
+	go Accept(l)
 
-	HandleHTTP();
-	l, e = net.Listen("tcp", ":0");	// any available address
+	HandleHTTP()
+	l, e = net.Listen("tcp", ":0") // any available address
 	if e != nil {
-		log.Stderrf("net.Listen tcp :0: %v", e);
-		os.Exit(1);
+		log.Stderrf("net.Listen tcp :0: %v", e)
+		os.Exit(1)
 	}
-	httpServerAddr = l.Addr().String();
-	log.Stderr("Test HTTP RPC server listening on ", httpServerAddr);
-	go http.Serve(l, nil);
+	httpServerAddr = l.Addr().String()
+	log.Stderr("Test HTTP RPC server listening on ", httpServerAddr)
+	go http.Serve(l, nil)
 }
 
 func TestRPC(t *testing.T) {
-	once.Do(startServer);
+	once.Do(startServer)
 
-	client, err := Dial("tcp", serverAddr);
+	client, err := Dial("tcp", serverAddr)
 	if err != nil {
 		t.Fatal("dialing", err)
 	}
 
 	// Synchronous calls
-	args := &Args{7, 8};
-	reply := new(Reply);
-	err = client.Call("Arith.Add", args, reply);
+	args := &Args{7, 8}
+	reply := new(Reply)
+	err = client.Call("Arith.Add", args, reply)
 	if err != nil {
 		t.Errorf("Add: expected no error but got string %q", err.String())
 	}
@@ -93,9 +93,9 @@ func TestRPC(t *testing.T) {
 		t.Errorf("Add: expected %d got %d", reply.C, args.A+args.B)
 	}
 
-	args = &Args{7, 8};
-	reply = new(Reply);
-	err = client.Call("Arith.Mul", args, reply);
+	args = &Args{7, 8}
+	reply = new(Reply)
+	err = client.Call("Arith.Mul", args, reply)
 	if err != nil {
 		t.Errorf("Mul: expected no error but got string %q", err.String())
 	}
@@ -104,13 +104,13 @@ func TestRPC(t *testing.T) {
 	}
 
 	// Out of order.
-	args = &Args{7, 8};
-	mulReply := new(Reply);
-	mulCall := client.Go("Arith.Mul", args, mulReply, nil);
-	addReply := new(Reply);
-	addCall := client.Go("Arith.Add", args, addReply, nil);
+	args = &Args{7, 8}
+	mulReply := new(Reply)
+	mulCall := client.Go("Arith.Mul", args, mulReply, nil)
+	addReply := new(Reply)
+	addCall := client.Go("Arith.Add", args, addReply, nil)
 
-	addCall = <-addCall.Done;
+	addCall = <-addCall.Done
 	if addCall.Error != nil {
 		t.Errorf("Add: expected no error but got string %q", addCall.Error.String())
 	}
@@ -118,7 +118,7 @@ func TestRPC(t *testing.T) {
 		t.Errorf("Add: expected %d got %d", addReply.C, args.A+args.B)
 	}
 
-	mulCall = <-mulCall.Done;
+	mulCall = <-mulCall.Done
 	if mulCall.Error != nil {
 		t.Errorf("Mul: expected no error but got string %q", mulCall.Error.String())
 	}
@@ -127,9 +127,9 @@ func TestRPC(t *testing.T) {
 	}
 
 	// Error test
-	args = &Args{7, 0};
-	reply = new(Reply);
-	err = client.Call("Arith.Div", args, reply);
+	args = &Args{7, 0}
+	reply = new(Reply)
+	err = client.Call("Arith.Div", args, reply)
 	// expect an error: zero divide
 	if err == nil {
 		t.Error("Div: expected error")
@@ -139,17 +139,17 @@ func TestRPC(t *testing.T) {
 }
 
 func TestHTTPRPC(t *testing.T) {
-	once.Do(startServer);
+	once.Do(startServer)
 
-	client, err := DialHTTP("tcp", httpServerAddr);
+	client, err := DialHTTP("tcp", httpServerAddr)
 	if err != nil {
 		t.Fatal("dialing", err)
 	}
 
 	// Synchronous calls
-	args := &Args{7, 8};
-	reply := new(Reply);
-	err = client.Call("Arith.Add", args, reply);
+	args := &Args{7, 8}
+	reply := new(Reply)
+	err = client.Call("Arith.Add", args, reply)
 	if err != nil {
 		t.Errorf("Add: expected no error but got string %q", err.String())
 	}
@@ -159,18 +159,18 @@ func TestHTTPRPC(t *testing.T) {
 }
 
 func TestCheckUnknownService(t *testing.T) {
-	once.Do(startServer);
+	once.Do(startServer)
 
-	conn, err := net.Dial("tcp", "", serverAddr);
+	conn, err := net.Dial("tcp", "", serverAddr)
 	if err != nil {
 		t.Fatal("dialing:", err)
 	}
 
-	client := NewClient(conn);
+	client := NewClient(conn)
 
-	args := &Args{7, 8};
-	reply := new(Reply);
-	err = client.Call("Unknown.Add", args, reply);
+	args := &Args{7, 8}
+	reply := new(Reply)
+	err = client.Call("Unknown.Add", args, reply)
 	if err == nil {
 		t.Error("expected error calling unknown service")
 	} else if strings.Index(err.String(), "service") < 0 {
@@ -179,18 +179,18 @@ func TestCheckUnknownService(t *testing.T) {
 }
 
 func TestCheckUnknownMethod(t *testing.T) {
-	once.Do(startServer);
+	once.Do(startServer)
 
-	conn, err := net.Dial("tcp", "", serverAddr);
+	conn, err := net.Dial("tcp", "", serverAddr)
 	if err != nil {
 		t.Fatal("dialing:", err)
 	}
 
-	client := NewClient(conn);
+	client := NewClient(conn)
 
-	args := &Args{7, 8};
-	reply := new(Reply);
-	err = client.Call("Arith.Unknown", args, reply);
+	args := &Args{7, 8}
+	reply := new(Reply)
+	err = client.Call("Arith.Unknown", args, reply)
 	if err == nil {
 		t.Error("expected error calling unknown service")
 	} else if strings.Index(err.String(), "method") < 0 {
@@ -199,17 +199,17 @@ func TestCheckUnknownMethod(t *testing.T) {
 }
 
 func TestCheckBadType(t *testing.T) {
-	once.Do(startServer);
+	once.Do(startServer)
 
-	conn, err := net.Dial("tcp", "", serverAddr);
+	conn, err := net.Dial("tcp", "", serverAddr)
 	if err != nil {
 		t.Fatal("dialing:", err)
 	}
 
-	client := NewClient(conn);
+	client := NewClient(conn)
 
-	reply := new(Reply);
-	err = client.Call("Arith.Add", reply, reply);	// args, reply would be the correct thing to use
+	reply := new(Reply)
+	err = client.Call("Arith.Add", reply, reply) // args, reply would be the correct thing to use
 	if err == nil {
 		t.Error("expected error calling Arith.Add with wrong arg type")
 	} else if strings.Index(err.String(), "type") < 0 {
@@ -246,7 +246,7 @@ func (t *Bad) ReplyNotPublic(args *Args, reply *local) os.Error {
 
 // Check that registration handles lots of bad methods and a type with no suitable methods.
 func TestRegistrationError(t *testing.T) {
-	err := Register(new(Bad));
+	err := Register(new(Bad))
 	if err == nil {
 		t.Errorf("expected error registering bad type")
 	}
diff --git a/src/pkg/runtime/type.go b/src/pkg/runtime/type.go
index e91544483f..d983b6f0c6 100644
--- a/src/pkg/runtime/type.go
+++ b/src/pkg/runtime/type.go
@@ -26,56 +26,56 @@ type Type interface{}
 // All types begin with a few common fields needed for
 // the interface runtime.
 type commonType struct {
-	size		uintptr;	// size in bytes
-	hash		uint32;		// hash of type; avoids computation in hash tables
-	alg		uint8;		// algorithm for copy+hash+cmp (../runtime/runtime.h:/AMEM)
-	align		uint8;		// alignment of variable with this type
-	fieldAlign	uint8;		// alignment of struct field with this type
-	kind		uint8;		// enumeration for C
-	string		*string;	// string form; unnecessary  but undeniably useful
-	*uncommonType;			// (relatively) uncommon fields
+	size          uintptr // size in bytes
+	hash          uint32  // hash of type; avoids computation in hash tables
+	alg           uint8   // algorithm for copy+hash+cmp (../runtime/runtime.h:/AMEM)
+	align         uint8   // alignment of variable with this type
+	fieldAlign    uint8   // alignment of struct field with this type
+	kind          uint8   // enumeration for C
+	string        *string // string form; unnecessary  but undeniably useful
+	*uncommonType         // (relatively) uncommon fields
 }
 
 // Values for commonType.kind.
 const (
-	kindBool	= 1 + iota;
-	kindInt;
-	kindInt8;
-	kindInt16;
-	kindInt32;
-	kindInt64;
-	kindUint;
-	kindUint8;
-	kindUint16;
-	kindUint32;
-	kindUint64;
-	kindUintptr;
-	kindFloat;
-	kindFloat32;
-	kindFloat64;
-	kindArray;
-	kindChan;
-	kindDotDotDot;
-	kindFunc;
-	kindInterface;
-	kindMap;
-	kindPtr;
-	kindSlice;
-	kindString;
-	kindStruct;
-	kindUnsafePointer;
-
-	kindNoPointers	= 1 << 7;	// OR'ed into kind
+	kindBool = 1 + iota
+	kindInt
+	kindInt8
+	kindInt16
+	kindInt32
+	kindInt64
+	kindUint
+	kindUint8
+	kindUint16
+	kindUint32
+	kindUint64
+	kindUintptr
+	kindFloat
+	kindFloat32
+	kindFloat64
+	kindArray
+	kindChan
+	kindDotDotDot
+	kindFunc
+	kindInterface
+	kindMap
+	kindPtr
+	kindSlice
+	kindString
+	kindStruct
+	kindUnsafePointer
+
+	kindNoPointers = 1 << 7 // OR'ed into kind
 )
 
 // Method on non-interface type
 type method struct {
-	hash	uint32;		// hash of name + pkg + typ
-	name	*string;	// name of method
-	pkgPath	*string;	// nil for exported Names; otherwise import path
-	typ	*Type;		// .(*FuncType) underneath
-	ifn	unsafe.Pointer;	// fn used in interface call (one-word receiver)
-	tfn	unsafe.Pointer;	// fn used for normal method call
+	hash    uint32         // hash of name + pkg + typ
+	name    *string        // name of method
+	pkgPath *string        // nil for exported Names; otherwise import path
+	typ     *Type          // .(*FuncType) underneath
+	ifn     unsafe.Pointer // fn used in interface call (one-word receiver)
+	tfn     unsafe.Pointer // fn used for normal method call
 }
 
 // uncommonType is present only for types with names or methods
@@ -83,9 +83,9 @@ type method struct {
 // Using a pointer to this struct reduces the overall size required
 // to describe an unnamed type with no methods.
 type uncommonType struct {
-	name	*string;	// name of type
-	pkgPath	*string;	// import path; nil for built-in types like int, string
-	methods	[]method;	// methods associated with type
+	name    *string  // name of type
+	pkgPath *string  // import path; nil for built-in types like int, string
+	methods []method // methods associated with type
 }
 
 // BoolType represents a boolean type.
@@ -145,91 +145,91 @@ type UnsafePointerType commonType
 
 // ArrayType represents a fixed array type.
 type ArrayType struct {
-	commonType;
-	elem	*Type;	// array element type
-	len	uintptr;
+	commonType
+	elem *Type // array element type
+	len  uintptr
 }
 
 // SliceType represents a slice type.
 type SliceType struct {
-	commonType;
-	elem	*Type;	// slice element type
+	commonType
+	elem *Type // slice element type
 }
 
 // ChanDir represents a channel type's direction.
 type ChanDir int
 
 const (
-	RecvDir		ChanDir	= 1 << iota;	// <-chan
-	SendDir;		// chan<-
-	BothDir			= RecvDir | SendDir;	// chan
+	RecvDir ChanDir = 1 << iota // <-chan
+	SendDir         // chan<-
+	BothDir         = RecvDir | SendDir // chan
 )
 
 // ChanType represents a channel type.
 type ChanType struct {
-	commonType;
-	elem	*Type;		// channel element type
-	dir	uintptr;	// channel direction (ChanDir)
+	commonType
+	elem *Type   // channel element type
+	dir  uintptr // channel direction (ChanDir)
 }
 
 // FuncType represents a function type.
 type FuncType struct {
-	commonType;
-	in	[]*Type;	// input parameter types
-	out	[]*Type;	// output parameter types
+	commonType
+	in  []*Type // input parameter types
+	out []*Type // output parameter types
 }
 
 // Method on interface type
 type imethod struct {
-	hash	uint32;		// hash of name + pkg + typ; same hash as method
-	perm	uint32;		// index of function pointer in interface map
-	name	*string;	// name of method
-	pkgPath	*string;	// nil for exported Names; otherwise import path
-	typ	*Type;		// .(*FuncType) underneath
+	hash    uint32  // hash of name + pkg + typ; same hash as method
+	perm    uint32  // index of function pointer in interface map
+	name    *string // name of method
+	pkgPath *string // nil for exported Names; otherwise import path
+	typ     *Type   // .(*FuncType) underneath
 }
 
 // InterfaceType represents an interface type.
 type InterfaceType struct {
-	commonType;
-	methods	[]imethod;	// sorted by hash
+	commonType
+	methods []imethod // sorted by hash
 }
 
 // MapType represents a map type.
 type MapType struct {
-	commonType;
-	key	*Type;	// map key type
-	elem	*Type;	// map element (value) type
+	commonType
+	key  *Type // map key type
+	elem *Type // map element (value) type
 }
 
 // PtrType represents a pointer type.
 type PtrType struct {
-	commonType;
-	elem	*Type;	// pointer element (pointed at) type
+	commonType
+	elem *Type // pointer element (pointed at) type
 }
 
 // Struct field
 type structField struct {
-	name	*string;	// nil for embedded fields
-	pkgPath	*string;	// nil for exported Names; otherwise import path
-	typ	*Type;		// type of field
-	tag	*string;	// nil if no tag
-	offset	uintptr;	// byte offset of field within struct
+	name    *string // nil for embedded fields
+	pkgPath *string // nil for exported Names; otherwise import path
+	typ     *Type   // type of field
+	tag     *string // nil if no tag
+	offset  uintptr // byte offset of field within struct
 }
 
 // StructType represents a struct type.
 type StructType struct {
-	commonType;
-	fields	[]structField;	// sorted by offset
+	commonType
+	fields []structField // sorted by offset
 }
 
 /*
  * Must match iface.c:/Itab and compilers.
  */
 type Itable struct {
-	Itype	*Type;	// (*tab.inter).(*InterfaceType) is the interface type
-	Type	*Type;
-	link	*Itable;
-	bad	int32;
-	unused	int32;
-	Fn	[100000]uintptr;	// bigger than we'll ever see
+	Itype  *Type // (*tab.inter).(*InterfaceType) is the interface type
+	Type   *Type
+	link   *Itable
+	bad    int32
+	unused int32
+	Fn     [100000]uintptr // bigger than we'll ever see
 }
diff --git a/src/pkg/sort/sort.go b/src/pkg/sort/sort.go
index c9b80356b6..b2b4b98f7d 100644
--- a/src/pkg/sort/sort.go
+++ b/src/pkg/sort/sort.go
@@ -11,19 +11,19 @@ package sort
 // elements of the collection be enumerated by an integer index.
 type Interface interface {
 	// Len is the number of elements in the collection.
-	Len() int;
+	Len() int
 	// Less returns whether the element with index i is should sort
 	// before the element with index j.
-	Less(i, j int) bool;
+	Less(i, j int) bool
 	// Swap swaps the elements with indexes i and j.
-	Swap(i, j int);
+	Swap(i, j int)
 }
 
 func min(a, b int) int {
 	if a < b {
 		return a
 	}
-	return b;
+	return b
 }
 
 // Insertion sort
@@ -40,9 +40,9 @@ func insertionSort(data Interface, a, b int) {
 
 // Move the median of the three values data[a], data[b], data[c] into data[a].
 func medianOfThree(data Interface, a, b, c int) {
-	m0 := b;
-	m1 := a;
-	m2 := c;
+	m0 := b
+	m1 := a
+	m2 := c
 	// bubble sort on 3 elements
 	if data.Less(m1, m0) {
 		data.Swap(m1, m0)
@@ -63,15 +63,15 @@ func swapRange(data Interface, a, b, n int) {
 }
 
 func doPivot(data Interface, lo, hi int) (midlo, midhi int) {
-	m := (lo + hi) / 2;
+	m := (lo + hi) / 2
 	if hi-lo > 40 {
 		// Tukey's ``Ninther,'' median of three medians of three.
-		s := (hi - lo) / 8;
-		medianOfThree(data, lo, lo+s, lo+2*s);
-		medianOfThree(data, m, m-s, m+s);
-		medianOfThree(data, hi-1, hi-1-s, hi-1-2*s);
+		s := (hi - lo) / 8
+		medianOfThree(data, lo, lo+s, lo+2*s)
+		medianOfThree(data, m, m-s, m+s)
+		medianOfThree(data, hi-1, hi-1-s, hi-1-2*s)
 	}
-	medianOfThree(data, lo, m, hi-1);
+	medianOfThree(data, lo, m, hi-1)
 
 	// Invariants are:
 	//	data[lo] = pivot (set up by ChoosePivot)
@@ -83,65 +83,65 @@ func doPivot(data Interface, lo, hi int) (midlo, midhi int) {
 	//
 	// Once b meets c, can swap the "= pivot" sections
 	// into the middle of the array.
-	pivot := lo;
-	a, b, c, d := lo+1, lo+1, hi, hi;
+	pivot := lo
+	a, b, c, d := lo+1, lo+1, hi, hi
 	for b < c {
-		if data.Less(b, pivot) {	// data[b] < pivot
-			b++;
-			continue;
+		if data.Less(b, pivot) { // data[b] < pivot
+			b++
+			continue
 		}
-		if !data.Less(pivot, b) {	// data[b] = pivot
-			data.Swap(a, b);
-			a++;
-			b++;
-			continue;
+		if !data.Less(pivot, b) { // data[b] = pivot
+			data.Swap(a, b)
+			a++
+			b++
+			continue
 		}
-		if data.Less(pivot, c-1) {	// data[c-1] > pivot
-			c--;
-			continue;
+		if data.Less(pivot, c-1) { // data[c-1] > pivot
+			c--
+			continue
 		}
-		if !data.Less(c-1, pivot) {	// data[c-1] = pivot
-			data.Swap(c-1, d-1);
-			c--;
-			d--;
-			continue;
+		if !data.Less(c-1, pivot) { // data[c-1] = pivot
+			data.Swap(c-1, d-1)
+			c--
+			d--
+			continue
 		}
 		// data[b] > pivot; data[c-1] < pivot
-		data.Swap(b, c-1);
-		b++;
-		c--;
+		data.Swap(b, c-1)
+		b++
+		c--
 	}
 
-	n := min(b-a, a-lo);
-	swapRange(data, lo, b-n, n);
+	n := min(b-a, a-lo)
+	swapRange(data, lo, b-n, n)
 
-	n = min(hi-d, d-c);
-	swapRange(data, c, hi-n, n);
+	n = min(hi-d, d-c)
+	swapRange(data, c, hi-n, n)
 
-	return lo + b - a, hi - (d - c);
+	return lo + b - a, hi - (d - c)
 }
 
 func quickSort(data Interface, a, b int) {
 	if b-a > 7 {
-		mlo, mhi := doPivot(data, a, b);
-		quickSort(data, a, mlo);
-		quickSort(data, mhi, b);
+		mlo, mhi := doPivot(data, a, b)
+		quickSort(data, a, mlo)
+		quickSort(data, mhi, b)
 	} else if b-a > 1 {
 		insertionSort(data, a, b)
 	}
 }
 
-func Sort(data Interface)	{ quickSort(data, 0, data.Len()) }
+func Sort(data Interface) { quickSort(data, 0, data.Len()) }
 
 
 func IsSorted(data Interface) bool {
-	n := data.Len();
+	n := data.Len()
 	for i := n - 1; i > 0; i-- {
 		if data.Less(i, i-1) {
 			return false
 		}
 	}
-	return true;
+	return true
 }
 
 
@@ -150,49 +150,49 @@ func IsSorted(data Interface) bool {
 // IntArray attaches the methods of Interface to []int, sorting in increasing order.
 type IntArray []int
 
-func (p IntArray) Len() int		{ return len(p) }
-func (p IntArray) Less(i, j int) bool	{ return p[i] < p[j] }
-func (p IntArray) Swap(i, j int)	{ p[i], p[j] = p[j], p[i] }
+func (p IntArray) Len() int           { return len(p) }
+func (p IntArray) Less(i, j int) bool { return p[i] < p[j] }
+func (p IntArray) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
 
 // Sort is a convenience method.
-func (p IntArray) Sort()	{ Sort(p) }
+func (p IntArray) Sort() { Sort(p) }
 
 
 // FloatArray attaches the methods of Interface to []float, sorting in increasing order.
 type FloatArray []float
 
-func (p FloatArray) Len() int		{ return len(p) }
-func (p FloatArray) Less(i, j int) bool	{ return p[i] < p[j] }
-func (p FloatArray) Swap(i, j int)	{ p[i], p[j] = p[j], p[i] }
+func (p FloatArray) Len() int           { return len(p) }
+func (p FloatArray) Less(i, j int) bool { return p[i] < p[j] }
+func (p FloatArray) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
 
 // Sort is a convenience method.
-func (p FloatArray) Sort()	{ Sort(p) }
+func (p FloatArray) Sort() { Sort(p) }
 
 
 // StringArray attaches the methods of Interface to []string, sorting in increasing order.
 type StringArray []string
 
-func (p StringArray) Len() int			{ return len(p) }
-func (p StringArray) Less(i, j int) bool	{ return p[i] < p[j] }
-func (p StringArray) Swap(i, j int)		{ p[i], p[j] = p[j], p[i] }
+func (p StringArray) Len() int           { return len(p) }
+func (p StringArray) Less(i, j int) bool { return p[i] < p[j] }
+func (p StringArray) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
 
 // Sort is a convenience method.
-func (p StringArray) Sort()	{ Sort(p) }
+func (p StringArray) Sort() { Sort(p) }
 
 
 // Convenience wrappers for common cases
 
 // SortInts sorts an array of ints in increasing order.
-func SortInts(a []int)	{ Sort(IntArray(a)) }
+func SortInts(a []int) { Sort(IntArray(a)) }
 // SortFloats sorts an array of floats in increasing order.
-func SortFloats(a []float)	{ Sort(FloatArray(a)) }
+func SortFloats(a []float) { Sort(FloatArray(a)) }
 // SortStrings sorts an array of strings in increasing order.
-func SortStrings(a []string)	{ Sort(StringArray(a)) }
+func SortStrings(a []string) { Sort(StringArray(a)) }
 
 
 // IntsAreSorted tests whether an array of ints is sorted in increasing order.
-func IntsAreSorted(a []int) bool	{ return IsSorted(IntArray(a)) }
+func IntsAreSorted(a []int) bool { return IsSorted(IntArray(a)) }
 // FloatsAreSorted tests whether an array of floats is sorted in increasing order.
-func FloatsAreSorted(a []float) bool	{ return IsSorted(FloatArray(a)) }
+func FloatsAreSorted(a []float) bool { return IsSorted(FloatArray(a)) }
 // StringsAreSorted tests whether an array of strings is sorted in increasing order.
-func StringsAreSorted(a []string) bool	{ return IsSorted(StringArray(a)) }
+func StringsAreSorted(a []string) bool { return IsSorted(StringArray(a)) }
diff --git a/src/pkg/sort/sort_test.go b/src/pkg/sort/sort_test.go
index 8d1807b6d2..4c5ed61ef3 100644
--- a/src/pkg/sort/sort_test.go
+++ b/src/pkg/sort/sort_test.go
@@ -5,10 +5,10 @@
 package sort
 
 import (
-	"fmt";
-	"rand";
-	"strconv";
-	"testing";
+	"fmt"
+	"rand"
+	"strconv"
+	"testing"
 )
 
 
@@ -17,173 +17,173 @@ var floats = [...]float{74.3, 59.0, 238.2, -784.0, 2.3, 9845.768, -959.7485, 905
 var strings = [...]string{"", "Hello", "foo", "bar", "foo", "f00", "%*&^*&^&", "***"}
 
 func TestSortIntArray(t *testing.T) {
-	data := ints;
-	a := IntArray(&data);
-	Sort(a);
+	data := ints
+	a := IntArray(&data)
+	Sort(a)
 	if !IsSorted(a) {
-		t.Errorf("sorted %v", ints);
-		t.Errorf("   got %v", data);
+		t.Errorf("sorted %v", ints)
+		t.Errorf("   got %v", data)
 	}
 }
 
 func TestSortFloatArray(t *testing.T) {
-	data := floats;
-	a := FloatArray(&data);
-	Sort(a);
+	data := floats
+	a := FloatArray(&data)
+	Sort(a)
 	if !IsSorted(a) {
-		t.Errorf("sorted %v", floats);
-		t.Errorf("   got %v", data);
+		t.Errorf("sorted %v", floats)
+		t.Errorf("   got %v", data)
 	}
 }
 
 func TestSortStringArray(t *testing.T) {
-	data := strings;
-	a := StringArray(&data);
-	Sort(a);
+	data := strings
+	a := StringArray(&data)
+	Sort(a)
 	if !IsSorted(a) {
-		t.Errorf("sorted %v", strings);
-		t.Errorf("   got %v", data);
+		t.Errorf("sorted %v", strings)
+		t.Errorf("   got %v", data)
 	}
 }
 
 func TestSortInts(t *testing.T) {
-	data := ints;
-	SortInts(&data);
+	data := ints
+	SortInts(&data)
 	if !IntsAreSorted(&data) {
-		t.Errorf("sorted %v", ints);
-		t.Errorf("   got %v", data);
+		t.Errorf("sorted %v", ints)
+		t.Errorf("   got %v", data)
 	}
 }
 
 func TestSortFloats(t *testing.T) {
-	data := floats;
-	SortFloats(&data);
+	data := floats
+	SortFloats(&data)
 	if !FloatsAreSorted(&data) {
-		t.Errorf("sorted %v", floats);
-		t.Errorf("   got %v", data);
+		t.Errorf("sorted %v", floats)
+		t.Errorf("   got %v", data)
 	}
 }
 
 func TestSortStrings(t *testing.T) {
-	data := strings;
-	SortStrings(&data);
+	data := strings
+	SortStrings(&data)
 	if !StringsAreSorted(&data) {
-		t.Errorf("sorted %v", strings);
-		t.Errorf("   got %v", data);
+		t.Errorf("sorted %v", strings)
+		t.Errorf("   got %v", data)
 	}
 }
 
 func TestSortLarge_Random(t *testing.T) {
-	data := make([]int, 1000000);
+	data := make([]int, 1000000)
 	for i := 0; i < len(data); i++ {
 		data[i] = rand.Intn(100)
 	}
 	if IntsAreSorted(data) {
 		t.Fatalf("terrible rand.rand")
 	}
-	SortInts(data);
+	SortInts(data)
 	if !IntsAreSorted(data) {
 		t.Errorf("sort didn't sort - 1M ints")
 	}
 }
 
 func BenchmarkSortString1K(b *testing.B) {
-	b.StopTimer();
+	b.StopTimer()
 	for i := 0; i < b.N; i++ {
-		data := make([]string, 1<<10);
+		data := make([]string, 1<<10)
 		for i := 0; i < len(data); i++ {
 			data[i] = strconv.Itoa(i ^ 0x2cc)
 		}
-		b.StartTimer();
-		SortStrings(data);
-		b.StopTimer();
+		b.StartTimer()
+		SortStrings(data)
+		b.StopTimer()
 	}
 }
 
 func BenchmarkSortInt1K(b *testing.B) {
-	b.StopTimer();
+	b.StopTimer()
 	for i := 0; i < b.N; i++ {
-		data := make([]int, 1<<10);
+		data := make([]int, 1<<10)
 		for i := 0; i < len(data); i++ {
 			data[i] = i ^ 0x2cc
 		}
-		b.StartTimer();
-		SortInts(data);
-		b.StopTimer();
+		b.StartTimer()
+		SortInts(data)
+		b.StopTimer()
 	}
 }
 
 func BenchmarkSortInt64K(b *testing.B) {
-	b.StopTimer();
+	b.StopTimer()
 	for i := 0; i < b.N; i++ {
-		data := make([]int, 1<<16);
+		data := make([]int, 1<<16)
 		for i := 0; i < len(data); i++ {
 			data[i] = i ^ 0xcccc
 		}
-		b.StartTimer();
-		SortInts(data);
-		b.StopTimer();
+		b.StartTimer()
+		SortInts(data)
+		b.StopTimer()
 	}
 }
 
 const (
-	_Sawtooth	= iota;
-	_Rand;
-	_Stagger;
-	_Plateau;
-	_Shuffle;
-	_NDist;
+	_Sawtooth = iota
+	_Rand
+	_Stagger
+	_Plateau
+	_Shuffle
+	_NDist
 )
 
 const (
-	_Copy	= iota;
-	_Reverse;
-	_ReverseFirstHalf;
-	_ReverseSecondHalf;
-	_Sorted;
-	_Dither;
-	_NMode;
+	_Copy = iota
+	_Reverse
+	_ReverseFirstHalf
+	_ReverseSecondHalf
+	_Sorted
+	_Dither
+	_NMode
 )
 
 type testingData struct {
-	desc	string;
-	t	*testing.T;
-	data	[]int;
-	maxswap	int;	// number of swaps allowed
-	nswap	int;
+	desc    string
+	t       *testing.T
+	data    []int
+	maxswap int // number of swaps allowed
+	nswap   int
 }
 
-func (d *testingData) Len() int			{ return len(d.data) }
-func (d *testingData) Less(i, j int) bool	{ return d.data[i] < d.data[j] }
+func (d *testingData) Len() int           { return len(d.data) }
+func (d *testingData) Less(i, j int) bool { return d.data[i] < d.data[j] }
 func (d *testingData) Swap(i, j int) {
 	if d.nswap >= d.maxswap {
-		d.t.Errorf("%s: used %d swaps sorting array of %d", d.desc, d.nswap, len(d.data));
-		d.t.FailNow();
+		d.t.Errorf("%s: used %d swaps sorting array of %d", d.desc, d.nswap, len(d.data))
+		d.t.FailNow()
 	}
-	d.nswap++;
-	d.data[i], d.data[j] = d.data[j], d.data[i];
+	d.nswap++
+	d.data[i], d.data[j] = d.data[j], d.data[i]
 }
 
 func lg(n int) int {
-	i := 0;
+	i := 0
 	for 1<<uint(i) < n {
 		i++
 	}
-	return i;
+	return i
 }
 
 func TestBentleyMcIlroy(t *testing.T) {
-	sizes := []int{100, 1023, 1024, 1025};
-	dists := []string{"sawtooth", "rand", "stagger", "plateau", "shuffle"};
-	modes := []string{"copy", "reverse", "reverse1", "reverse2", "sort", "dither"};
-	var tmp1, tmp2 [1025]int;
+	sizes := []int{100, 1023, 1024, 1025}
+	dists := []string{"sawtooth", "rand", "stagger", "plateau", "shuffle"}
+	modes := []string{"copy", "reverse", "reverse1", "reverse2", "sort", "dither"}
+	var tmp1, tmp2 [1025]int
 	for ni := 0; ni < len(sizes); ni++ {
-		n := sizes[ni];
+		n := sizes[ni]
 		for m := 1; m < 2*n; m *= 2 {
 			for dist := 0; dist < _NDist; dist++ {
-				j := 0;
-				k := 1;
-				data := tmp1[0:n];
+				j := 0
+				k := 1
+				data := tmp1[0:n]
 				for i := 0; i < n; i++ {
 					switch dist {
 					case _Sawtooth:
@@ -196,16 +196,16 @@ func TestBentleyMcIlroy(t *testing.T) {
 						data[i] = min(i, m)
 					case _Shuffle:
 						if rand.Intn(m) != 0 {
-							j += 2;
-							data[i] = j;
+							j += 2
+							data[i] = j
 						} else {
-							k += 2;
-							data[i] = k;
+							k += 2
+							data[i] = k
 						}
 					}
 				}
 
-				mdata := tmp2[0:n];
+				mdata := tmp2[0:n]
 				for mode := 0; mode < _NMode; mode++ {
 					switch mode {
 					case _Copy:
@@ -236,16 +236,16 @@ func TestBentleyMcIlroy(t *testing.T) {
 						}
 						// SortInts is known to be correct
 						// because mode Sort runs after mode _Copy.
-						SortInts(mdata);
+						SortInts(mdata)
 					case _Dither:
 						for i := 0; i < n; i++ {
 							mdata[i] = data[i] + i%5
 						}
 					}
 
-					desc := fmt.Sprintf("n=%d m=%d dist=%s mode=%s", n, m, dists[dist], modes[mode]);
-					d := &testingData{desc, t, mdata[0:n], n * lg(n) * 12 / 10, 0};
-					Sort(d);
+					desc := fmt.Sprintf("n=%d m=%d dist=%s mode=%s", n, m, dists[dist], modes[mode])
+					d := &testingData{desc, t, mdata[0:n], n * lg(n) * 12 / 10, 0}
+					Sort(d)
 
 					// If we were testing C qsort, we'd have to make a copy
 					// of the array and sort it ourselves and then compare
@@ -256,9 +256,9 @@ func TestBentleyMcIlroy(t *testing.T) {
 					// mutating method Sort can call is TestingData.swap,
 					// it suffices here just to check that the final array is sorted.
 					if !IntsAreSorted(mdata) {
-						t.Errorf("%s: ints not sorted", desc);
-						t.Errorf("\t%v", mdata);
-						t.FailNow();
+						t.Errorf("%s: ints not sorted", desc)
+						t.Errorf("\t%v", mdata)
+						t.FailNow()
 					}
 				}
 			}
diff --git a/src/pkg/strconv/atof.go b/src/pkg/strconv/atof.go
index 30ac128541..bf0c5aaba3 100644
--- a/src/pkg/strconv/atof.go
+++ b/src/pkg/strconv/atof.go
@@ -13,15 +13,15 @@
 package strconv
 
 import (
-	"math";
-	"os";
+	"math"
+	"os"
 )
 
-var optimize = true	// can change for testing
+var optimize = true // can change for testing
 
 // TODO(rsc): Better truncation handling.
 func stringToDecimal(s string) (neg bool, d *decimal, trunc bool, ok bool) {
-	i := 0;
+	i := 0
 
 	// optional sign
 	if i >= len(s) {
@@ -31,35 +31,35 @@ func stringToDecimal(s string) (neg bool, d *decimal, trunc bool, ok bool) {
 	case s[i] == '+':
 		i++
 	case s[i] == '-':
-		neg = true;
-		i++;
+		neg = true
+		i++
 	}
 
 	// digits
-	b := new(decimal);
-	sawdot := false;
-	sawdigits := false;
+	b := new(decimal)
+	sawdot := false
+	sawdigits := false
 	for ; i < len(s); i++ {
 		switch {
 		case s[i] == '.':
 			if sawdot {
 				return
 			}
-			sawdot = true;
-			b.dp = b.nd;
-			continue;
+			sawdot = true
+			b.dp = b.nd
+			continue
 
 		case '0' <= s[i] && s[i] <= '9':
-			sawdigits = true;
-			if s[i] == '0' && b.nd == 0 {	// ignore leading zeros
-				b.dp--;
-				continue;
+			sawdigits = true
+			if s[i] == '0' && b.nd == 0 { // ignore leading zeros
+				b.dp--
+				continue
 			}
-			b.d[b.nd] = s[i];
-			b.nd++;
-			continue;
+			b.d[b.nd] = s[i]
+			b.nd++
+			continue
 		}
-		break;
+		break
 	}
 	if !sawdigits {
 		return
@@ -74,50 +74,50 @@ func stringToDecimal(s string) (neg bool, d *decimal, trunc bool, ok bool) {
 	// a lot (say, 100000).  it doesn't matter if it's
 	// not the exact number.
 	if i < len(s) && s[i] == 'e' {
-		i++;
+		i++
 		if i >= len(s) {
 			return
 		}
-		esign := 1;
+		esign := 1
 		if s[i] == '+' {
 			i++
 		} else if s[i] == '-' {
-			i++;
-			esign = -1;
+			i++
+			esign = -1
 		}
 		if i >= len(s) || s[i] < '0' || s[i] > '9' {
 			return
 		}
-		e := 0;
+		e := 0
 		for ; i < len(s) && '0' <= s[i] && s[i] <= '9'; i++ {
 			if e < 10000 {
 				e = e*10 + int(s[i]) - '0'
 			}
 		}
-		b.dp += e * esign;
+		b.dp += e * esign
 	}
 
 	if i != len(s) {
 		return
 	}
 
-	d = b;
-	ok = true;
-	return;
+	d = b
+	ok = true
+	return
 }
 
 // decimal power of ten to binary power of two.
 var powtab = []int{1, 3, 6, 9, 13, 16, 19, 23, 26}
 
 func decimalToFloatBits(neg bool, d *decimal, trunc bool, flt *floatInfo) (b uint64, overflow bool) {
-	var exp int;
-	var mant uint64;
+	var exp int
+	var mant uint64
 
 	// Zero is always a special case.
 	if d.nd == 0 {
-		mant = 0;
-		exp = flt.bias;
-		goto out;
+		mant = 0
+		exp = flt.bias
+		goto out
 	}
 
 	// Obvious overflow/underflow.
@@ -128,44 +128,44 @@ func decimalToFloatBits(neg bool, d *decimal, trunc bool, flt *floatInfo) (b uin
 	}
 	if d.dp < -330 {
 		// zero
-		mant = 0;
-		exp = flt.bias;
-		goto out;
+		mant = 0
+		exp = flt.bias
+		goto out
 	}
 
 	// Scale by powers of two until in range [0.5, 1.0)
-	exp = 0;
+	exp = 0
 	for d.dp > 0 {
-		var n int;
+		var n int
 		if d.dp >= len(powtab) {
 			n = 27
 		} else {
 			n = powtab[d.dp]
 		}
-		d.Shift(-n);
-		exp += n;
+		d.Shift(-n)
+		exp += n
 	}
 	for d.dp < 0 || d.dp == 0 && d.d[0] < '5' {
-		var n int;
+		var n int
 		if -d.dp >= len(powtab) {
 			n = 27
 		} else {
 			n = powtab[-d.dp]
 		}
-		d.Shift(n);
-		exp -= n;
+		d.Shift(n)
+		exp -= n
 	}
 
 	// Our range is [0.5,1) but floating point range is [1,2).
-	exp--;
+	exp--
 
 	// Minimum representable exponent is flt.bias+1.
 	// If the exponent is smaller, move it up and
 	// adjust d accordingly.
 	if exp < flt.bias+1 {
-		n := flt.bias + 1 - exp;
-		d.Shift(-n);
-		exp += n;
+		n := flt.bias + 1 - exp
+		d.Shift(-n)
+		exp += n
 	}
 
 	if exp-flt.bias >= 1<<flt.expbits-1 {
@@ -173,12 +173,12 @@ func decimalToFloatBits(neg bool, d *decimal, trunc bool, flt *floatInfo) (b uin
 	}
 
 	// Extract 1+flt.mantbits bits.
-	mant = d.Shift(int(1 + flt.mantbits)).RoundedInteger();
+	mant = d.Shift(int(1 + flt.mantbits)).RoundedInteger()
 
 	// Rounding might have added a bit; shift down.
 	if mant == 2<<flt.mantbits {
-		mant >>= 1;
-		exp++;
+		mant >>= 1
+		exp++
 		if exp-flt.bias >= 1<<flt.expbits-1 {
 			goto overflow
 		}
@@ -188,46 +188,46 @@ func decimalToFloatBits(neg bool, d *decimal, trunc bool, flt *floatInfo) (b uin
 	if mant&(1<<flt.mantbits) == 0 {
 		exp = flt.bias
 	}
-	goto out;
+	goto out
 
 overflow:
 	// ±Inf
-	mant = 0;
-	exp = 1<<flt.expbits - 1 + flt.bias;
-	overflow = true;
+	mant = 0
+	exp = 1<<flt.expbits - 1 + flt.bias
+	overflow = true
 
 out:
 	// Assemble bits.
-	bits := mant & (uint64(1)<<flt.mantbits - 1);
-	bits |= uint64((exp-flt.bias)&(1<<flt.expbits-1)) << flt.mantbits;
+	bits := mant & (uint64(1)<<flt.mantbits - 1)
+	bits |= uint64((exp-flt.bias)&(1<<flt.expbits-1)) << flt.mantbits
 	if neg {
 		bits |= 1 << flt.mantbits << flt.expbits
 	}
-	return bits, overflow;
+	return bits, overflow
 }
 
 // Compute exact floating-point integer from d's digits.
 // Caller is responsible for avoiding overflow.
 func decimalAtof64Int(neg bool, d *decimal) float64 {
-	f := float64(0);
+	f := float64(0)
 	for i := 0; i < d.nd; i++ {
 		f = f*10 + float64(d.d[i]-'0')
 	}
 	if neg {
-		f *= -1	// BUG work around 6g f = -f.
+		f *= -1 // BUG work around 6g f = -f.
 	}
-	return f;
+	return f
 }
 
 func decimalAtof32Int(neg bool, d *decimal) float32 {
-	f := float32(0);
+	f := float32(0)
 	for i := 0; i < d.nd; i++ {
 		f = f*10 + float32(d.d[i]-'0')
 	}
 	if neg {
-		f *= -1	// BUG work around 6g f = -f.
+		f *= -1 // BUG work around 6g f = -f.
 	}
-	return f;
+	return f
 }
 
 // Exact powers of 10.
@@ -252,26 +252,26 @@ func decimalAtof64(neg bool, d *decimal, trunc bool) (f float64, ok bool) {
 		return
 	}
 	switch {
-	case d.dp == d.nd:	// int
-		f := decimalAtof64Int(neg, d);
-		return f, true;
+	case d.dp == d.nd: // int
+		f := decimalAtof64Int(neg, d)
+		return f, true
 
-	case d.dp > d.nd && d.dp <= 15+22:	// int * 10^k
-		f := decimalAtof64Int(neg, d);
-		k := d.dp - d.nd;
+	case d.dp > d.nd && d.dp <= 15+22: // int * 10^k
+		f := decimalAtof64Int(neg, d)
+		k := d.dp - d.nd
 		// If exponent is big but number of digits is not,
 		// can move a few zeros into the integer part.
 		if k > 22 {
-			f *= float64pow10[k-22];
-			k = 22;
+			f *= float64pow10[k-22]
+			k = 22
 		}
-		return f * float64pow10[k], true;
+		return f * float64pow10[k], true
 
-	case d.dp < d.nd && d.nd-d.dp <= 22:	// int / 10^k
-		f := decimalAtof64Int(neg, d);
-		return f / float64pow10[d.nd-d.dp], true;
+	case d.dp < d.nd && d.nd-d.dp <= 22: // int / 10^k
+		f := decimalAtof64Int(neg, d)
+		return f / float64pow10[d.nd-d.dp], true
 	}
-	return;
+	return
 }
 
 // If possible to convert decimal d to 32-bit float f exactly,
@@ -283,26 +283,26 @@ func decimalAtof32(neg bool, d *decimal, trunc bool) (f float32, ok bool) {
 		return
 	}
 	switch {
-	case d.dp == d.nd:	// int
-		f := decimalAtof32Int(neg, d);
-		return f, true;
+	case d.dp == d.nd: // int
+		f := decimalAtof32Int(neg, d)
+		return f, true
 
-	case d.dp > d.nd && d.dp <= 7+10:	// int * 10^k
-		f := decimalAtof32Int(neg, d);
-		k := d.dp - d.nd;
+	case d.dp > d.nd && d.dp <= 7+10: // int * 10^k
+		f := decimalAtof32Int(neg, d)
+		k := d.dp - d.nd
 		// If exponent is big but number of digits is not,
 		// can move a few zeros into the integer part.
 		if k > 10 {
-			f *= float32pow10[k-10];
-			k = 10;
+			f *= float32pow10[k-10]
+			k = 10
 		}
-		return f * float32pow10[k], true;
+		return f * float32pow10[k], true
 
-	case d.dp < d.nd && d.nd-d.dp <= 10:	// int / 10^k
-		f := decimalAtof32Int(neg, d);
-		return f / float32pow10[d.nd-d.dp], true;
+	case d.dp < d.nd && d.nd-d.dp <= 10: // int / 10^k
+		f := decimalAtof32Int(neg, d)
+		return f / float32pow10[d.nd-d.dp], true
 	}
-	return;
+	return
 }
 
 // Atof32 converts the string s to a 32-bit floating-point number.
@@ -320,7 +320,7 @@ func decimalAtof32(neg bool, d *decimal, trunc bool) (f float32, ok bool) {
 // away from the largest floating point number of the given size,
 // Atof32 returns f = ±Inf, err.Error = os.ERANGE.
 func Atof32(s string) (f float32, err os.Error) {
-	neg, d, trunc, ok := stringToDecimal(s);
+	neg, d, trunc, ok := stringToDecimal(s)
 	if !ok {
 		return 0, &NumError{s, os.EINVAL}
 	}
@@ -329,19 +329,19 @@ func Atof32(s string) (f float32, err os.Error) {
 			return f, nil
 		}
 	}
-	b, ovf := decimalToFloatBits(neg, d, trunc, &float32info);
-	f = math.Float32frombits(uint32(b));
+	b, ovf := decimalToFloatBits(neg, d, trunc, &float32info)
+	f = math.Float32frombits(uint32(b))
 	if ovf {
 		err = &NumError{s, os.ERANGE}
 	}
-	return f, err;
+	return f, err
 }
 
 // Atof64 converts the string s to a 64-bit floating-point number.
 // Except for the type of its result, its definition is the same as that
 // of Atof32.
 func Atof64(s string) (f float64, err os.Error) {
-	neg, d, trunc, ok := stringToDecimal(s);
+	neg, d, trunc, ok := stringToDecimal(s)
 	if !ok {
 		return 0, &NumError{s, os.EINVAL}
 	}
@@ -350,20 +350,20 @@ func Atof64(s string) (f float64, err os.Error) {
 			return f, nil
 		}
 	}
-	b, ovf := decimalToFloatBits(neg, d, trunc, &float64info);
-	f = math.Float64frombits(b);
+	b, ovf := decimalToFloatBits(neg, d, trunc, &float64info)
+	f = math.Float64frombits(b)
 	if ovf {
 		err = &NumError{s, os.ERANGE}
 	}
-	return f, err;
+	return f, err
 }
 
 // Atof is like Atof32 or Atof64, depending on the size of float.
 func Atof(s string) (f float, err os.Error) {
 	if FloatSize == 32 {
-		f1, err1 := Atof32(s);
-		return float(f1), err1;
+		f1, err1 := Atof32(s)
+		return float(f1), err1
 	}
-	f1, err1 := Atof64(s);
-	return float(f1), err1;
+	f1, err1 := Atof64(s)
+	return float(f1), err1
 }
diff --git a/src/pkg/strconv/atof_test.go b/src/pkg/strconv/atof_test.go
index a10381d077..c0fe1bda75 100644
--- a/src/pkg/strconv/atof_test.go
+++ b/src/pkg/strconv/atof_test.go
@@ -5,16 +5,16 @@
 package strconv_test
 
 import (
-	"os";
-	"reflect";
-	. "strconv";
-	"testing";
+	"os"
+	"reflect"
+	. "strconv"
+	"testing"
 )
 
 type atofTest struct {
-	in	string;
-	out	string;
-	err	os.Error;
+	in  string
+	out string
+	err os.Error
 }
 
 var atoftests = []atofTest{
@@ -96,7 +96,7 @@ func init() {
 	// The atof routines return NumErrors wrapping
 	// the error and the string.  Convert the table above.
 	for i := range atoftests {
-		test := &atoftests[i];
+		test := &atoftests[i]
 		if test.err != nil {
 			test.err = &NumError{test.in, test.err}
 		}
@@ -104,19 +104,19 @@ func init() {
 }
 
 func testAtof(t *testing.T, opt bool) {
-	oldopt := SetOptimize(opt);
+	oldopt := SetOptimize(opt)
 	for i := 0; i < len(atoftests); i++ {
-		test := &atoftests[i];
-		out, err := Atof64(test.in);
-		outs := Ftoa64(out, 'g', -1);
+		test := &atoftests[i]
+		out, err := Atof64(test.in)
+		outs := Ftoa64(out, 'g', -1)
 		if outs != test.out || !reflect.DeepEqual(err, test.err) {
 			t.Errorf("Atof64(%v) = %v, %v want %v, %v\n",
 				test.in, out, err, test.out, test.err)
 		}
 
 		if float64(float32(out)) == out {
-			out32, err := Atof32(test.in);
-			outs := Ftoa32(out32, 'g', -1);
+			out32, err := Atof32(test.in)
+			outs := Ftoa32(out32, 'g', -1)
 			if outs != test.out || !reflect.DeepEqual(err, test.err) {
 				t.Errorf("Atof32(%v) = %v, %v want %v, %v  # %v\n",
 					test.in, out32, err, test.out, test.err, out)
@@ -124,20 +124,20 @@ func testAtof(t *testing.T, opt bool) {
 		}
 
 		if FloatSize == 64 || float64(float32(out)) == out {
-			outf, err := Atof(test.in);
-			outs := Ftoa(outf, 'g', -1);
+			outf, err := Atof(test.in)
+			outs := Ftoa(outf, 'g', -1)
 			if outs != test.out || !reflect.DeepEqual(err, test.err) {
 				t.Errorf("Ftoa(%v) = %v, %v want %v, %v  # %v\n",
 					test.in, outf, err, test.out, test.err, out)
 			}
 		}
 	}
-	SetOptimize(oldopt);
+	SetOptimize(oldopt)
 }
 
-func TestAtof(t *testing.T)	{ testAtof(t, true) }
+func TestAtof(t *testing.T) { testAtof(t, true) }
 
-func TestAtofSlow(t *testing.T)	{ testAtof(t, false) }
+func TestAtofSlow(t *testing.T) { testAtof(t, false) }
 
 func BenchmarkAtofDecimal(b *testing.B) {
 	for i := 0; i < b.N; i++ {
diff --git a/src/pkg/strconv/atoi.go b/src/pkg/strconv/atoi.go
index bcfaf2ce58..60492b653b 100644
--- a/src/pkg/strconv/atoi.go
+++ b/src/pkg/strconv/atoi.go
@@ -7,19 +7,19 @@ package strconv
 import "os"
 
 type NumError struct {
-	Num	string;
-	Error	os.Error;
+	Num   string
+	Error os.Error
 }
 
-func (e *NumError) String() string	{ return "parsing " + e.Num + ": " + e.Error.String() }
+func (e *NumError) String() string { return "parsing " + e.Num + ": " + e.Error.String() }
 
 
 func computeIntsize() uint {
-	siz := uint(8);
+	siz := uint(8)
 	for 1<<siz != 0 {
 		siz *= 2
 	}
-	return siz;
+	return siz
 }
 
 var IntSize = computeIntsize()
@@ -29,7 +29,7 @@ func cutoff64(base int) uint64 {
 	if base < 2 {
 		return 0
 	}
-	return (1<<64-1)/uint64(base) + 1;
+	return (1<<64-1)/uint64(base) + 1
 }
 
 // Btoui64 interprets a string s in an arbitrary base b (2 to 36)
@@ -42,11 +42,11 @@ func cutoff64(base int) uint64 {
 // digits, err.Error = os.EINVAL; if the value corresponding
 // to s cannot be represented by a uint64, err.Error = os.ERANGE.
 func Btoui64(s string, b int) (n uint64, err os.Error) {
-	s0 := s;
+	s0 := s
 	switch {
 	case len(s) < 1:
-		err = os.EINVAL;
-		goto Error;
+		err = os.EINVAL
+		goto Error
 
 	case 2 <= b && b <= 36:
 		// valid base; nothing to do
@@ -55,11 +55,11 @@ func Btoui64(s string, b int) (n uint64, err os.Error) {
 		// Look for octal, hex prefix.
 		switch {
 		case s[0] == '0' && len(s) > 1 && (s[1] == 'x' || s[1] == 'X'):
-			b = 16;
-			s = s[2:];
+			b = 16
+			s = s[2:]
 			if len(s) < 1 {
-				err = os.EINVAL;
-				goto Error;
+				err = os.EINVAL
+				goto Error
 			}
 		case s[0] == '0':
 			b = 8
@@ -68,15 +68,15 @@ func Btoui64(s string, b int) (n uint64, err os.Error) {
 		}
 
 	default:
-		err = os.ErrorString("invalid base " + Itoa(b));
-		goto Error;
+		err = os.ErrorString("invalid base " + Itoa(b))
+		goto Error
 	}
 
-	n = 0;
-	cutoff := cutoff64(b);
+	n = 0
+	cutoff := cutoff64(b)
 
 	for i := 0; i < len(s); i++ {
-		var v byte;
+		var v byte
 		switch {
 		case '0' <= s[i] && s[i] <= '9':
 			v = s[i] - '0'
@@ -85,38 +85,38 @@ func Btoui64(s string, b int) (n uint64, err os.Error) {
 		case 'A' <= s[i] && s[i] <= 'Z':
 			v = s[i] - 'A' + 10
 		default:
-			n = 0;
-			err = os.EINVAL;
-			goto Error;
+			n = 0
+			err = os.EINVAL
+			goto Error
 		}
 		if int(v) >= b {
-			n = 0;
-			err = os.EINVAL;
-			goto Error;
+			n = 0
+			err = os.EINVAL
+			goto Error
 		}
 
 		if n >= cutoff {
 			// n*b overflows
-			n = 1<<64 - 1;
-			err = os.ERANGE;
-			goto Error;
+			n = 1<<64 - 1
+			err = os.ERANGE
+			goto Error
 		}
-		n *= uint64(b);
+		n *= uint64(b)
 
-		n1 := n + uint64(v);
+		n1 := n + uint64(v)
 		if n1 < n {
 			// n+v overflows
-			n = 1<<64 - 1;
-			err = os.ERANGE;
-			goto Error;
+			n = 1<<64 - 1
+			err = os.ERANGE
+			goto Error
 		}
-		n = n1;
+		n = n1
 	}
 
-	return n, nil;
+	return n, nil
 
 Error:
-	return n, &NumError{s0, err};
+	return n, &NumError{s0, err}
 }
 
 // Atoui64 interprets a string s as a decimal number and
@@ -137,21 +137,21 @@ func Btoi64(s string, base int) (i int64, err os.Error) {
 	}
 
 	// Pick off leading sign.
-	s0 := s;
-	neg := false;
+	s0 := s
+	neg := false
 	if s[0] == '+' {
 		s = s[1:]
 	} else if s[0] == '-' {
-		neg = true;
-		s = s[1:];
+		neg = true
+		s = s[1:]
 	}
 
 	// Convert unsigned and check range.
-	var un uint64;
-	un, err = Btoui64(s, base);
+	var un uint64
+	un, err = Btoui64(s, base)
 	if err != nil && err.(*NumError).Error != os.ERANGE {
-		err.(*NumError).Num = s0;
-		return 0, err;
+		err.(*NumError).Num = s0
+		return 0, err
 	}
 	if !neg && un >= 1<<63 {
 		return 1<<63 - 1, &NumError{s0, os.ERANGE}
@@ -159,43 +159,43 @@ func Btoi64(s string, base int) (i int64, err os.Error) {
 	if neg && un > 1<<63 {
 		return -1 << 63, &NumError{s0, os.ERANGE}
 	}
-	n := int64(un);
+	n := int64(un)
 	if neg {
 		n = -n
 	}
-	return n, nil;
+	return n, nil
 }
 
 // Atoi64 is like Atoui64 but allows signed numbers and
 // returns its result in an int64.
-func Atoi64(s string) (i int64, err os.Error)	{ return Btoi64(s, 10) }
+func Atoi64(s string) (i int64, err os.Error) { return Btoi64(s, 10) }
 
 
 // Atoui is like Atoui64 but returns its result as a uint.
 func Atoui(s string) (i uint, err os.Error) {
-	i1, e1 := Atoui64(s);
+	i1, e1 := Atoui64(s)
 	if e1 != nil && e1.(*NumError).Error != os.ERANGE {
 		return 0, e1
 	}
-	i = uint(i1);
+	i = uint(i1)
 	if uint64(i) != i1 {
 		return ^uint(0), &NumError{s, os.ERANGE}
 	}
-	return i, nil;
+	return i, nil
 }
 
 // Atoi is like Atoi64 but returns its result as an int.
 func Atoi(s string) (i int, err os.Error) {
-	i1, e1 := Atoi64(s);
+	i1, e1 := Atoi64(s)
 	if e1 != nil && e1.(*NumError).Error != os.ERANGE {
 		return 0, e1
 	}
-	i = int(i1);
+	i = int(i1)
 	if int64(i) != i1 {
 		if i1 < 0 {
 			return -1 << (IntSize - 1), &NumError{s, os.ERANGE}
 		}
-		return 1<<(IntSize-1) - 1, &NumError{s, os.ERANGE};
+		return 1<<(IntSize-1) - 1, &NumError{s, os.ERANGE}
 	}
-	return i, nil;
+	return i, nil
 }
diff --git a/src/pkg/strconv/atoi_test.go b/src/pkg/strconv/atoi_test.go
index 7420cdcae7..7df9303424 100644
--- a/src/pkg/strconv/atoi_test.go
+++ b/src/pkg/strconv/atoi_test.go
@@ -5,16 +5,16 @@
 package strconv_test
 
 import (
-	"os";
-	"reflect";
-	. "strconv";
-	"testing";
+	"os"
+	"reflect"
+	. "strconv"
+	"testing"
 )
 
 type atoui64Test struct {
-	in	string;
-	out	uint64;
-	err	os.Error;
+	in  string
+	out uint64
+	err os.Error
 }
 
 var atoui64tests = []atoui64Test{
@@ -52,9 +52,9 @@ var btoui64tests = []atoui64Test{
 }
 
 type atoi64Test struct {
-	in	string;
-	out	int64;
-	err	os.Error;
+	in  string
+	out int64
+	err os.Error
 }
 
 var atoi64tests = []atoi64Test{
@@ -102,9 +102,9 @@ var btoi64tests = []atoi64Test{
 }
 
 type atoui32Test struct {
-	in	string;
-	out	uint32;
-	err	os.Error;
+	in  string
+	out uint32
+	err os.Error
 }
 
 var atoui32tests = []atoui32Test{
@@ -120,9 +120,9 @@ var atoui32tests = []atoui32Test{
 }
 
 type atoi32Test struct {
-	in	string;
-	out	int32;
-	err	os.Error;
+	in  string
+	out int32
+	err os.Error
 }
 
 var atoi32tests = []atoi32Test{
@@ -151,37 +151,37 @@ func init() {
 	// The atoi routines return NumErrors wrapping
 	// the error and the string.  Convert the tables above.
 	for i := range atoui64tests {
-		test := &atoui64tests[i];
+		test := &atoui64tests[i]
 		if test.err != nil {
 			test.err = &NumError{test.in, test.err}
 		}
 	}
 	for i := range btoui64tests {
-		test := &btoui64tests[i];
+		test := &btoui64tests[i]
 		if test.err != nil {
 			test.err = &NumError{test.in, test.err}
 		}
 	}
 	for i := range atoi64tests {
-		test := &atoi64tests[i];
+		test := &atoi64tests[i]
 		if test.err != nil {
 			test.err = &NumError{test.in, test.err}
 		}
 	}
 	for i := range btoi64tests {
-		test := &btoi64tests[i];
+		test := &btoi64tests[i]
 		if test.err != nil {
 			test.err = &NumError{test.in, test.err}
 		}
 	}
 	for i := range atoui32tests {
-		test := &atoui32tests[i];
+		test := &atoui32tests[i]
 		if test.err != nil {
 			test.err = &NumError{test.in, test.err}
 		}
 	}
 	for i := range atoi32tests {
-		test := &atoi32tests[i];
+		test := &atoi32tests[i]
 		if test.err != nil {
 			test.err = &NumError{test.in, test.err}
 		}
@@ -190,8 +190,8 @@ func init() {
 
 func TestAtoui64(t *testing.T) {
 	for i := range atoui64tests {
-		test := &atoui64tests[i];
-		out, err := Atoui64(test.in);
+		test := &atoui64tests[i]
+		out, err := Atoui64(test.in)
 		if test.out != out || !reflect.DeepEqual(test.err, err) {
 			t.Errorf("Atoui64(%q) = %v, %v want %v, %v\n",
 				test.in, out, err, test.out, test.err)
@@ -201,8 +201,8 @@ func TestAtoui64(t *testing.T) {
 
 func TestBtoui64(t *testing.T) {
 	for i := range btoui64tests {
-		test := &btoui64tests[i];
-		out, err := Btoui64(test.in, 0);
+		test := &btoui64tests[i]
+		out, err := Btoui64(test.in, 0)
 		if test.out != out || !reflect.DeepEqual(test.err, err) {
 			t.Errorf("Btoui64(%q) = %v, %v want %v, %v\n",
 				test.in, out, err, test.out, test.err)
@@ -212,8 +212,8 @@ func TestBtoui64(t *testing.T) {
 
 func TestAtoi64(t *testing.T) {
 	for i := range atoi64tests {
-		test := &atoi64tests[i];
-		out, err := Atoi64(test.in);
+		test := &atoi64tests[i]
+		out, err := Atoi64(test.in)
 		if test.out != out || !reflect.DeepEqual(test.err, err) {
 			t.Errorf("Atoi64(%q) = %v, %v want %v, %v\n",
 				test.in, out, err, test.out, test.err)
@@ -223,8 +223,8 @@ func TestAtoi64(t *testing.T) {
 
 func TestBtoi64(t *testing.T) {
 	for i := range btoi64tests {
-		test := &btoi64tests[i];
-		out, err := Btoi64(test.in, 0);
+		test := &btoi64tests[i]
+		out, err := Btoi64(test.in, 0)
 		if test.out != out || !reflect.DeepEqual(test.err, err) {
 			t.Errorf("Btoi64(%q) = %v, %v want %v, %v\n",
 				test.in, out, err, test.out, test.err)
@@ -236,8 +236,8 @@ func TestAtoui(t *testing.T) {
 	switch IntSize {
 	case 32:
 		for i := range atoui32tests {
-			test := &atoui32tests[i];
-			out, err := Atoui(test.in);
+			test := &atoui32tests[i]
+			out, err := Atoui(test.in)
 			if test.out != uint32(out) || !reflect.DeepEqual(test.err, err) {
 				t.Errorf("Atoui(%q) = %v, %v want %v, %v\n",
 					test.in, out, err, test.out, test.err)
@@ -245,8 +245,8 @@ func TestAtoui(t *testing.T) {
 		}
 	case 64:
 		for i := range atoui64tests {
-			test := &atoui64tests[i];
-			out, err := Atoui(test.in);
+			test := &atoui64tests[i]
+			out, err := Atoui(test.in)
 			if test.out != uint64(out) || !reflect.DeepEqual(test.err, err) {
 				t.Errorf("Atoui(%q) = %v, %v want %v, %v\n",
 					test.in, out, err, test.out, test.err)
@@ -259,8 +259,8 @@ func TestAtoi(t *testing.T) {
 	switch IntSize {
 	case 32:
 		for i := range atoi32tests {
-			test := &atoi32tests[i];
-			out, err := Atoi(test.in);
+			test := &atoi32tests[i]
+			out, err := Atoi(test.in)
 			if test.out != int32(out) || !reflect.DeepEqual(test.err, err) {
 				t.Errorf("Atoi(%q) = %v, %v want %v, %v\n",
 					test.in, out, err, test.out, test.err)
@@ -268,8 +268,8 @@ func TestAtoi(t *testing.T) {
 		}
 	case 64:
 		for i := range atoi64tests {
-			test := &atoi64tests[i];
-			out, err := Atoi(test.in);
+			test := &atoi64tests[i]
+			out, err := Atoi(test.in)
 			if test.out != int64(out) || !reflect.DeepEqual(test.err, err) {
 				t.Errorf("Atoi(%q) = %v, %v want %v, %v\n",
 					test.in, out, err, test.out, test.err)
diff --git a/src/pkg/strconv/decimal.go b/src/pkg/strconv/decimal.go
index 04caedb6d2..02c6618cb8 100644
--- a/src/pkg/strconv/decimal.go
+++ b/src/pkg/strconv/decimal.go
@@ -14,13 +14,13 @@ package strconv
 type decimal struct {
 	// TODO(rsc): Can make d[] a bit smaller and add
 	// truncated bool;
-	d	[2000]byte;	// digits
-	nd	int;		// number of digits used
-	dp	int;		// decimal point
+	d  [2000]byte // digits
+	nd int        // number of digits used
+	dp int        // decimal point
 }
 
 func (a *decimal) String() string {
-	n := 10 + a.nd;
+	n := 10 + a.nd
 	if a.dp > 0 {
 		n += a.dp
 	}
@@ -28,48 +28,48 @@ func (a *decimal) String() string {
 		n += -a.dp
 	}
 
-	buf := make([]byte, n);
-	w := 0;
+	buf := make([]byte, n)
+	w := 0
 	switch {
 	case a.nd == 0:
 		return "0"
 
 	case a.dp <= 0:
 		// zeros fill space between decimal point and digits
-		buf[w] = '0';
-		w++;
-		buf[w] = '.';
-		w++;
-		w += digitZero(buf[w : w+-a.dp]);
-		w += copy(buf[w:w+a.nd], a.d[0:a.nd]);
+		buf[w] = '0'
+		w++
+		buf[w] = '.'
+		w++
+		w += digitZero(buf[w : w+-a.dp])
+		w += copy(buf[w:w+a.nd], a.d[0:a.nd])
 
 	case a.dp < a.nd:
 		// decimal point in middle of digits
-		w += copy(buf[w:w+a.dp], a.d[0:a.dp]);
-		buf[w] = '.';
-		w++;
-		w += copy(buf[w:w+a.nd-a.dp], a.d[a.dp:a.nd]);
+		w += copy(buf[w:w+a.dp], a.d[0:a.dp])
+		buf[w] = '.'
+		w++
+		w += copy(buf[w:w+a.nd-a.dp], a.d[a.dp:a.nd])
 
 	default:
 		// zeros fill space between digits and decimal point
-		w += copy(buf[w:w+a.nd], a.d[0:a.nd]);
-		w += digitZero(buf[w : w+a.dp-a.nd]);
+		w += copy(buf[w:w+a.nd], a.d[0:a.nd])
+		w += digitZero(buf[w : w+a.dp-a.nd])
 	}
-	return string(buf[0:w]);
+	return string(buf[0:w])
 }
 
 func copy(dst []byte, src []byte) int {
 	for i := 0; i < len(dst); i++ {
 		dst[i] = src[i]
 	}
-	return len(dst);
+	return len(dst)
 }
 
 func digitZero(dst []byte) int {
 	for i := 0; i < len(dst); i++ {
 		dst[i] = '0'
 	}
-	return len(dst);
+	return len(dst)
 }
 
 // trim trailing zeros from number.
@@ -86,32 +86,32 @@ func trim(a *decimal) {
 
 // Assign v to a.
 func (a *decimal) Assign(v uint64) {
-	var buf [50]byte;
+	var buf [50]byte
 
 	// Write reversed decimal in buf.
-	n := 0;
+	n := 0
 	for v > 0 {
-		v1 := v / 10;
-		v -= 10 * v1;
-		buf[n] = byte(v + '0');
-		n++;
-		v = v1;
+		v1 := v / 10
+		v -= 10 * v1
+		buf[n] = byte(v + '0')
+		n++
+		v = v1
 	}
 
 	// Reverse again to produce forward decimal in a.d.
-	a.nd = 0;
+	a.nd = 0
 	for n--; n >= 0; n-- {
-		a.d[a.nd] = buf[n];
-		a.nd++;
+		a.d[a.nd] = buf[n]
+		a.nd++
 	}
-	a.dp = a.nd;
-	trim(a);
+	a.dp = a.nd
+	trim(a)
 }
 
 func newDecimal(i uint64) *decimal {
-	a := new(decimal);
-	a.Assign(i);
-	return a;
+	a := new(decimal)
+	a.Assign(i)
+	return a
 }
 
 // Maximum shift that we can do in one pass without overflow.
@@ -120,50 +120,50 @@ const maxShift = 27
 
 // Binary shift right (* 2) by k bits.  k <= maxShift to avoid overflow.
 func rightShift(a *decimal, k uint) {
-	r := 0;	// read pointer
-	w := 0;	// write pointer
+	r := 0 // read pointer
+	w := 0 // write pointer
 
 	// Pick up enough leading digits to cover first shift.
-	n := 0;
+	n := 0
 	for ; n>>k == 0; r++ {
 		if r >= a.nd {
 			if n == 0 {
 				// a == 0; shouldn't get here, but handle anyway.
-				a.nd = 0;
-				return;
+				a.nd = 0
+				return
 			}
 			for n>>k == 0 {
-				n = n * 10;
-				r++;
+				n = n * 10
+				r++
 			}
-			break;
+			break
 		}
-		c := int(a.d[r]);
-		n = n*10 + c - '0';
+		c := int(a.d[r])
+		n = n*10 + c - '0'
 	}
-	a.dp -= r - 1;
+	a.dp -= r - 1
 
 	// Pick up a digit, put down a digit.
 	for ; r < a.nd; r++ {
-		c := int(a.d[r]);
-		dig := n >> k;
-		n -= dig << k;
-		a.d[w] = byte(dig + '0');
-		w++;
-		n = n*10 + c - '0';
+		c := int(a.d[r])
+		dig := n >> k
+		n -= dig << k
+		a.d[w] = byte(dig + '0')
+		w++
+		n = n*10 + c - '0'
 	}
 
 	// Put down extra digits.
 	for n > 0 {
-		dig := n >> k;
-		n -= dig << k;
-		a.d[w] = byte(dig + '0');
-		w++;
-		n = n * 10;
+		dig := n >> k
+		n -= dig << k
+		a.d[w] = byte(dig + '0')
+		w++
+		n = n * 10
 	}
 
-	a.nd = w;
-	trim(a);
+	a.nd = w
+	trim(a)
 }
 
 // Cheat sheet for left shift: table indexed by shift count giving
@@ -177,8 +177,8 @@ func rightShift(a *decimal, k uint) {
 // Credit for this trick goes to Ken.
 
 type leftCheat struct {
-	delta	int;	// number of new digits
-	cutoff	string;	//   minus one digit if original < a.
+	delta  int    // number of new digits
+	cutoff string //   minus one digit if original < a.
 }
 
 var leftcheats = []leftCheat{
@@ -195,33 +195,33 @@ var leftcheats = []leftCheat{
 		}'
 	*/
 	leftCheat{0, ""},
-	leftCheat{1, "5"},	// * 2
-	leftCheat{1, "25"},	// * 4
-	leftCheat{1, "125"},	// * 8
-	leftCheat{2, "625"},	// * 16
-	leftCheat{2, "3125"},	// * 32
-	leftCheat{2, "15625"},	// * 64
-	leftCheat{3, "78125"},	// * 128
-	leftCheat{3, "390625"},	// * 256
-	leftCheat{3, "1953125"},	// * 512
-	leftCheat{4, "9765625"},	// * 1024
-	leftCheat{4, "48828125"},	// * 2048
-	leftCheat{4, "244140625"},	// * 4096
-	leftCheat{4, "1220703125"},	// * 8192
-	leftCheat{5, "6103515625"},	// * 16384
-	leftCheat{5, "30517578125"},	// * 32768
-	leftCheat{5, "152587890625"},	// * 65536
-	leftCheat{6, "762939453125"},	// * 131072
-	leftCheat{6, "3814697265625"},	// * 262144
-	leftCheat{6, "19073486328125"},	// * 524288
-	leftCheat{7, "95367431640625"},	// * 1048576
-	leftCheat{7, "476837158203125"},	// * 2097152
-	leftCheat{7, "2384185791015625"},	// * 4194304
-	leftCheat{7, "11920928955078125"},	// * 8388608
-	leftCheat{8, "59604644775390625"},	// * 16777216
-	leftCheat{8, "298023223876953125"},	// * 33554432
-	leftCheat{8, "1490116119384765625"},	// * 67108864
-	leftCheat{9, "7450580596923828125"},	// * 134217728
+	leftCheat{1, "5"}, // * 2
+	leftCheat{1, "25"}, // * 4
+	leftCheat{1, "125"}, // * 8
+	leftCheat{2, "625"}, // * 16
+	leftCheat{2, "3125"}, // * 32
+	leftCheat{2, "15625"}, // * 64
+	leftCheat{3, "78125"}, // * 128
+	leftCheat{3, "390625"}, // * 256
+	leftCheat{3, "1953125"}, // * 512
+	leftCheat{4, "9765625"}, // * 1024
+	leftCheat{4, "48828125"}, // * 2048
+	leftCheat{4, "244140625"}, // * 4096
+	leftCheat{4, "1220703125"}, // * 8192
+	leftCheat{5, "6103515625"}, // * 16384
+	leftCheat{5, "30517578125"}, // * 32768
+	leftCheat{5, "152587890625"}, // * 65536
+	leftCheat{6, "762939453125"}, // * 131072
+	leftCheat{6, "3814697265625"}, // * 262144
+	leftCheat{6, "19073486328125"}, // * 524288
+	leftCheat{7, "95367431640625"}, // * 1048576
+	leftCheat{7, "476837158203125"}, // * 2097152
+	leftCheat{7, "2384185791015625"}, // * 4194304
+	leftCheat{7, "11920928955078125"}, // * 8388608
+	leftCheat{8, "59604644775390625"}, // * 16777216
+	leftCheat{8, "298023223876953125"}, // * 33554432
+	leftCheat{8, "1490116119384765625"}, // * 67108864
+	leftCheat{9, "7450580596923828125"}, // * 134217728
 }
 
 // Is the leading prefix of b lexicographically less than s?
@@ -234,42 +234,42 @@ func prefixIsLessThan(b []byte, s string) bool {
 			return b[i] < s[i]
 		}
 	}
-	return false;
+	return false
 }
 
 // Binary shift left (/ 2) by k bits.  k <= maxShift to avoid overflow.
 func leftShift(a *decimal, k uint) {
-	delta := leftcheats[k].delta;
+	delta := leftcheats[k].delta
 	if prefixIsLessThan(a.d[0:a.nd], leftcheats[k].cutoff) {
 		delta--
 	}
 
-	r := a.nd;		// read index
-	w := a.nd + delta;	// write index
-	n := 0;
+	r := a.nd         // read index
+	w := a.nd + delta // write index
+	n := 0
 
 	// Pick up a digit, put down a digit.
 	for r--; r >= 0; r-- {
-		n += (int(a.d[r]) - '0') << k;
-		quo := n / 10;
-		rem := n - 10*quo;
-		w--;
-		a.d[w] = byte(rem + '0');
-		n = quo;
+		n += (int(a.d[r]) - '0') << k
+		quo := n / 10
+		rem := n - 10*quo
+		w--
+		a.d[w] = byte(rem + '0')
+		n = quo
 	}
 
 	// Put down extra digits.
 	for n > 0 {
-		quo := n / 10;
-		rem := n - 10*quo;
-		w--;
-		a.d[w] = byte(rem + '0');
-		n = quo;
+		quo := n / 10
+		rem := n - 10*quo
+		w--
+		a.d[w] = byte(rem + '0')
+		n = quo
 	}
 
-	a.nd += delta;
-	a.dp += delta;
-	trim(a);
+	a.nd += delta
+	a.dp += delta
+	trim(a)
 }
 
 // Binary shift left (k > 0) or right (k < 0).
@@ -280,18 +280,18 @@ func (a *decimal) Shift(k int) *decimal {
 		// nothing to do: a == 0
 	case k > 0:
 		for k > maxShift {
-			leftShift(a, maxShift);
-			k -= maxShift;
+			leftShift(a, maxShift)
+			k -= maxShift
 		}
-		leftShift(a, uint(k));
+		leftShift(a, uint(k))
 	case k < 0:
 		for k < -maxShift {
-			rightShift(a, maxShift);
-			k += maxShift;
+			rightShift(a, maxShift)
+			k += maxShift
 		}
-		rightShift(a, uint(-k));
+		rightShift(a, uint(-k))
 	}
-	return a;
+	return a
 }
 
 // If we chop a at nd digits, should we round up?
@@ -299,11 +299,11 @@ func shouldRoundUp(a *decimal, nd int) bool {
 	if nd <= 0 || nd >= a.nd {
 		return false
 	}
-	if a.d[nd] == '5' && nd+1 == a.nd {	// exactly halfway - round to even
+	if a.d[nd] == '5' && nd+1 == a.nd { // exactly halfway - round to even
 		return (a.d[nd-1]-'0')%2 != 0
 	}
 	// not halfway - digit tells all
-	return a.d[nd] >= '5';
+	return a.d[nd] >= '5'
 }
 
 // Round a to nd digits (or fewer).
@@ -315,7 +315,7 @@ func (a *decimal) Round(nd int) *decimal {
 	if shouldRoundUp(a, nd) {
 		return a.RoundUp(nd)
 	}
-	return a.RoundDown(nd);
+	return a.RoundDown(nd)
 }
 
 // Round a down to nd digits (or fewer).
@@ -324,9 +324,9 @@ func (a *decimal) RoundDown(nd int) *decimal {
 	if nd <= 0 || nd >= a.nd {
 		return a
 	}
-	a.nd = nd;
-	trim(a);
-	return a;
+	a.nd = nd
+	trim(a)
+	return a
 }
 
 // Round a up to nd digits (or fewer).
@@ -338,20 +338,20 @@ func (a *decimal) RoundUp(nd int) *decimal {
 
 	// round up
 	for i := nd - 1; i >= 0; i-- {
-		c := a.d[i];
-		if c < '9' {	// can stop after this digit
-			a.d[i]++;
-			a.nd = i + 1;
-			return a;
+		c := a.d[i]
+		if c < '9' { // can stop after this digit
+			a.d[i]++
+			a.nd = i + 1
+			return a
 		}
 	}
 
 	// Number is all 9s.
 	// Change to single 1 with adjusted decimal point.
-	a.d[0] = '1';
-	a.nd = 1;
-	a.dp++;
-	return a;
+	a.d[0] = '1'
+	a.nd = 1
+	a.dp++
+	return a
 }
 
 // Extract integer part, rounded appropriately.
@@ -360,8 +360,8 @@ func (a *decimal) RoundedInteger() uint64 {
 	if a.dp > 20 {
 		return 0xFFFFFFFFFFFFFFFF
 	}
-	var i int;
-	n := uint64(0);
+	var i int
+	n := uint64(0)
 	for i = 0; i < a.dp && i < a.nd; i++ {
 		n = n*10 + uint64(a.d[i]-'0')
 	}
@@ -371,5 +371,5 @@ func (a *decimal) RoundedInteger() uint64 {
 	if shouldRoundUp(a, a.dp) {
 		n++
 	}
-	return n;
+	return n
 }
diff --git a/src/pkg/strconv/decimal_test.go b/src/pkg/strconv/decimal_test.go
index 9e67aa4c34..5f73450cde 100644
--- a/src/pkg/strconv/decimal_test.go
+++ b/src/pkg/strconv/decimal_test.go
@@ -5,14 +5,14 @@
 package strconv_test
 
 import (
-	. "strconv";
-	"testing";
+	. "strconv"
+	"testing"
 )
 
 type shiftTest struct {
-	i	uint64;
-	shift	int;
-	out	string;
+	i     uint64
+	shift int
+	out   string
 }
 
 var shifttests = []shiftTest{
@@ -31,8 +31,8 @@ var shifttests = []shiftTest{
 
 func TestDecimalShift(t *testing.T) {
 	for i := 0; i < len(shifttests); i++ {
-		test := &shifttests[i];
-		s := NewDecimal(test.i).Shift(test.shift).String();
+		test := &shifttests[i]
+		s := NewDecimal(test.i).Shift(test.shift).String()
 		if s != test.out {
 			t.Errorf("Decimal %v << %v = %v, want %v\n",
 				test.i, test.shift, s, test.out)
@@ -41,10 +41,10 @@ func TestDecimalShift(t *testing.T) {
 }
 
 type roundTest struct {
-	i		uint64;
-	nd		int;
-	down, round, up	string;
-	int		uint64;
+	i               uint64
+	nd              int
+	down, round, up string
+	int             uint64
 }
 
 var roundtests = []roundTest{
@@ -67,18 +67,18 @@ var roundtests = []roundTest{
 
 func TestDecimalRound(t *testing.T) {
 	for i := 0; i < len(roundtests); i++ {
-		test := &roundtests[i];
-		s := NewDecimal(test.i).RoundDown(test.nd).String();
+		test := &roundtests[i]
+		s := NewDecimal(test.i).RoundDown(test.nd).String()
 		if s != test.down {
 			t.Errorf("Decimal %v RoundDown %d = %v, want %v\n",
 				test.i, test.nd, s, test.down)
 		}
-		s = NewDecimal(test.i).Round(test.nd).String();
+		s = NewDecimal(test.i).Round(test.nd).String()
 		if s != test.round {
 			t.Errorf("Decimal %v Round %d = %v, want %v\n",
 				test.i, test.nd, s, test.down)
 		}
-		s = NewDecimal(test.i).RoundUp(test.nd).String();
+		s = NewDecimal(test.i).RoundUp(test.nd).String()
 		if s != test.up {
 			t.Errorf("Decimal %v RoundUp %d = %v, want %v\n",
 				test.i, test.nd, s, test.up)
@@ -87,9 +87,9 @@ func TestDecimalRound(t *testing.T) {
 }
 
 type roundIntTest struct {
-	i	uint64;
-	shift	int;
-	int	uint64;
+	i     uint64
+	shift int
+	int   uint64
 }
 
 var roundinttests = []roundIntTest{
@@ -107,8 +107,8 @@ var roundinttests = []roundIntTest{
 
 func TestDecimalRoundedInteger(t *testing.T) {
 	for i := 0; i < len(roundinttests); i++ {
-		test := roundinttests[i];
-		int := NewDecimal(test.i).Shift(test.shift).RoundedInteger();
+		test := roundinttests[i]
+		int := NewDecimal(test.i).Shift(test.shift).RoundedInteger()
 		if int != test.int {
 			t.Errorf("Decimal %v >> %v RoundedInteger = %v, want %v\n",
 				test.i, test.shift, int, test.int)
diff --git a/src/pkg/strconv/fp_test.go b/src/pkg/strconv/fp_test.go
index 8fee9f84ce..2f0172a72d 100644
--- a/src/pkg/strconv/fp_test.go
+++ b/src/pkg/strconv/fp_test.go
@@ -5,12 +5,12 @@
 package strconv_test
 
 import (
-	"bufio";
-	"fmt";
-	"os";
-	"strconv";
-	"strings";
-	"testing";
+	"bufio"
+	"fmt"
+	"os"
+	"strconv"
+	"strings"
+	"testing"
 )
 
 func pow2(i int) float64 {
@@ -22,124 +22,124 @@ func pow2(i int) float64 {
 	case i == 1:
 		return 2
 	}
-	return pow2(i/2) * pow2(i-i/2);
+	return pow2(i/2) * pow2(i-i/2)
 }
 
 // Wrapper around strconv.Atof64.  Handles dddddp+ddd (binary exponent)
 // itself, passes the rest on to strconv.Atof64.
 func myatof64(s string) (f float64, ok bool) {
-	a := strings.Split(s, "p", 2);
+	a := strings.Split(s, "p", 2)
 	if len(a) == 2 {
-		n, err := strconv.Atoi64(a[0]);
+		n, err := strconv.Atoi64(a[0])
 		if err != nil {
 			return 0, false
 		}
-		e, err1 := strconv.Atoi(a[1]);
+		e, err1 := strconv.Atoi(a[1])
 		if err1 != nil {
-			println("bad e", a[1]);
-			return 0, false;
+			println("bad e", a[1])
+			return 0, false
 		}
-		v := float64(n);
+		v := float64(n)
 		// We expect that v*pow2(e) fits in a float64,
 		// but pow2(e) by itself may not.  Be careful.
 		if e <= -1000 {
-			v *= pow2(-1000);
-			e += 1000;
+			v *= pow2(-1000)
+			e += 1000
 			for e < 0 {
-				v /= 2;
-				e++;
+				v /= 2
+				e++
 			}
-			return v, true;
+			return v, true
 		}
 		if e >= 1000 {
-			v *= pow2(1000);
-			e -= 1000;
+			v *= pow2(1000)
+			e -= 1000
 			for e > 0 {
-				v *= 2;
-				e--;
+				v *= 2
+				e--
 			}
-			return v, true;
+			return v, true
 		}
-		return v * pow2(e), true;
+		return v * pow2(e), true
 	}
-	f1, err := strconv.Atof64(s);
+	f1, err := strconv.Atof64(s)
 	if err != nil {
 		return 0, false
 	}
-	return f1, true;
+	return f1, true
 }
 
 // Wrapper around strconv.Atof32.  Handles dddddp+ddd (binary exponent)
 // itself, passes the rest on to strconv.Atof32.
 func myatof32(s string) (f float32, ok bool) {
-	a := strings.Split(s, "p", 2);
+	a := strings.Split(s, "p", 2)
 	if len(a) == 2 {
-		n, err := strconv.Atoi(a[0]);
+		n, err := strconv.Atoi(a[0])
 		if err != nil {
-			println("bad n", a[0]);
-			return 0, false;
+			println("bad n", a[0])
+			return 0, false
 		}
-		e, err1 := strconv.Atoi(a[1]);
+		e, err1 := strconv.Atoi(a[1])
 		if err1 != nil {
-			println("bad p", a[1]);
-			return 0, false;
+			println("bad p", a[1])
+			return 0, false
 		}
-		return float32(float64(n) * pow2(e)), true;
+		return float32(float64(n) * pow2(e)), true
 	}
-	f1, err1 := strconv.Atof32(s);
+	f1, err1 := strconv.Atof32(s)
 	if err1 != nil {
 		return 0, false
 	}
-	return f1, true;
+	return f1, true
 }
 
 func TestFp(t *testing.T) {
-	f, err := os.Open("testfp.txt", os.O_RDONLY, 0);
+	f, err := os.Open("testfp.txt", os.O_RDONLY, 0)
 	if err != nil {
 		panicln("testfp: open testfp.txt:", err.String())
 	}
-	defer f.Close();
+	defer f.Close()
 
-	b := bufio.NewReader(f);
+	b := bufio.NewReader(f)
 
-	lineno := 0;
+	lineno := 0
 	for {
-		line, err2 := b.ReadString('\n');
+		line, err2 := b.ReadString('\n')
 		if err2 == os.EOF {
 			break
 		}
 		if err2 != nil {
 			panicln("testfp: read testfp.txt:", err2.String())
 		}
-		line = line[0 : len(line)-1];
-		lineno++;
+		line = line[0 : len(line)-1]
+		lineno++
 		if len(line) == 0 || line[0] == '#' {
 			continue
 		}
-		a := strings.Split(line, " ", 0);
+		a := strings.Split(line, " ", 0)
 		if len(a) != 4 {
-			t.Error("testfp.txt:", lineno, ": wrong field count\n");
-			continue;
+			t.Error("testfp.txt:", lineno, ": wrong field count\n")
+			continue
 		}
-		var s string;
-		var v float64;
+		var s string
+		var v float64
 		switch a[0] {
 		case "float64":
-			var ok bool;
-			v, ok = myatof64(a[2]);
+			var ok bool
+			v, ok = myatof64(a[2])
 			if !ok {
-				t.Error("testfp.txt:", lineno, ": cannot atof64 ", a[2]);
-				continue;
+				t.Error("testfp.txt:", lineno, ": cannot atof64 ", a[2])
+				continue
 			}
-			s = fmt.Sprintf(a[1], v);
+			s = fmt.Sprintf(a[1], v)
 		case "float32":
-			v1, ok := myatof32(a[2]);
+			v1, ok := myatof32(a[2])
 			if !ok {
-				t.Error("testfp.txt:", lineno, ": cannot atof32 ", a[2]);
-				continue;
+				t.Error("testfp.txt:", lineno, ": cannot atof32 ", a[2])
+				continue
 			}
-			s = fmt.Sprintf(a[1], v1);
-			v = float64(v1);
+			s = fmt.Sprintf(a[1], v1)
+			v = float64(v1)
 		}
 		if s != a[3] {
 			t.Error("testfp.txt:", lineno, ": ", a[0], " ", a[1], " ", a[2], " (", v, ") ",
diff --git a/src/pkg/strconv/ftoa.go b/src/pkg/strconv/ftoa.go
index 7300cd8615..86e35b3995 100644
--- a/src/pkg/strconv/ftoa.go
+++ b/src/pkg/strconv/ftoa.go
@@ -14,9 +14,9 @@ import "math"
 
 // TODO: move elsewhere?
 type floatInfo struct {
-	mantbits	uint;
-	expbits		uint;
-	bias		int;
+	mantbits uint
+	expbits  uint
+	bias     int
 }
 
 var float32info = floatInfo{23, 8, -127}
@@ -26,11 +26,11 @@ func floatsize() int {
 	// Figure out whether float is float32 or float64.
 	// 1e-35 is representable in both, but 1e-70
 	// is too small for a float32.
-	var f float = 1e-35;
+	var f float = 1e-35
 	if f*f == 0 {
 		return 32
 	}
-	return 64;
+	return 64
 }
 
 // Floatsize gives the size of the float type, either 32 or 64.
@@ -69,13 +69,13 @@ func Ftoa(f float, fmt byte, prec int) string {
 	if FloatSize == 32 {
 		return Ftoa32(float32(f), fmt, prec)
 	}
-	return Ftoa64(float64(f), fmt, prec);
+	return Ftoa64(float64(f), fmt, prec)
 }
 
 func genericFtoa(bits uint64, fmt byte, prec int, flt *floatInfo) string {
-	neg := bits>>flt.expbits>>flt.mantbits != 0;
-	exp := int(bits>>flt.mantbits) & (1<<flt.expbits - 1);
-	mant := bits & (uint64(1)<<flt.mantbits - 1);
+	neg := bits>>flt.expbits>>flt.mantbits != 0
+	exp := int(bits>>flt.mantbits) & (1<<flt.expbits - 1)
+	mant := bits & (uint64(1)<<flt.mantbits - 1)
 
 	switch exp {
 	case 1<<flt.expbits - 1:
@@ -86,7 +86,7 @@ func genericFtoa(bits uint64, fmt byte, prec int, flt *floatInfo) string {
 		if neg {
 			return "-Inf"
 		}
-		return "+Inf";
+		return "+Inf"
 
 	case 0:
 		// denormalized
@@ -96,7 +96,7 @@ func genericFtoa(bits uint64, fmt byte, prec int, flt *floatInfo) string {
 		// add implicit top bit
 		mant |= uint64(1) << flt.mantbits
 	}
-	exp += flt.bias;
+	exp += flt.bias
 
 	// Pick off easy binary format.
 	if fmt == 'b' {
@@ -107,14 +107,14 @@ func genericFtoa(bits uint64, fmt byte, prec int, flt *floatInfo) string {
 	// The shift is exp - flt.mantbits because mant is a 1-bit integer
 	// followed by a flt.mantbits fraction, and we are treating it as
 	// a 1+flt.mantbits-bit integer.
-	d := newDecimal(mant).Shift(exp - int(flt.mantbits));
+	d := newDecimal(mant).Shift(exp - int(flt.mantbits))
 
 	// Round appropriately.
 	// Negative precision means "only as much as needed to be exact."
-	shortest := false;
+	shortest := false
 	if prec < 0 {
-		shortest = true;
-		roundShortest(d, mant, exp, flt);
+		shortest = true
+		roundShortest(d, mant, exp, flt)
 		switch fmt {
 		case 'e', 'E':
 			prec = d.nd - 1
@@ -133,7 +133,7 @@ func genericFtoa(bits uint64, fmt byte, prec int, flt *floatInfo) string {
 			if prec == 0 {
 				prec = 1
 			}
-			d.Round(prec);
+			d.Round(prec)
 		}
 	}
 
@@ -150,18 +150,18 @@ func genericFtoa(bits uint64, fmt byte, prec int, flt *floatInfo) string {
 		// %e is used if the exponent from the conversion
 		// is less than -4 or greater than or equal to the precision.
 		// if precision was the shortest possible, use precision 6 for this decision.
-		eprec := prec;
+		eprec := prec
 		if shortest {
 			eprec = 6
 		}
-		exp := d.dp - 1;
+		exp := d.dp - 1
 		if exp < -4 || exp >= eprec {
 			return fmtE(neg, d, prec-1, fmt+'e'-'g')
 		}
-		return fmtF(neg, d, max(prec-d.dp, 0));
+		return fmtF(neg, d, max(prec-d.dp, 0))
 	}
 
-	return "%" + string(fmt);
+	return "%" + string(fmt)
 }
 
 // Round d (= mant * 2^exp) to the shortest number of digits
@@ -170,8 +170,8 @@ func genericFtoa(bits uint64, fmt byte, prec int, flt *floatInfo) string {
 func roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo) {
 	// If mantissa is zero, the number is zero; stop now.
 	if mant == 0 {
-		d.nd = 0;
-		return;
+		d.nd = 0
+		return
 	}
 
 	// TODO(rsc): Unless exp == minexp, if the number of digits in d
@@ -186,7 +186,7 @@ func roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo) {
 	// d = mant << (exp - mantbits)
 	// Next highest floating point number is mant+1 << exp-mantbits.
 	// Our upper bound is halfway inbetween, mant*2+1 << exp-mantbits-1.
-	upper := newDecimal(mant*2 + 1).Shift(exp - int(flt.mantbits) - 1);
+	upper := newDecimal(mant*2 + 1).Shift(exp - int(flt.mantbits) - 1)
 
 	// d = mant << (exp - mantbits)
 	// Next lowest floating point number is mant-1 << exp-mantbits,
@@ -194,33 +194,33 @@ func roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo) {
 	// in which case the next lowest is mant*2-1 << exp-mantbits-1.
 	// Either way, call it mantlo << explo-mantbits.
 	// Our lower bound is halfway inbetween, mantlo*2+1 << explo-mantbits-1.
-	minexp := flt.bias + 1;	// minimum possible exponent
-	var mantlo uint64;
-	var explo int;
+	minexp := flt.bias + 1 // minimum possible exponent
+	var mantlo uint64
+	var explo int
 	if mant > 1<<flt.mantbits || exp == minexp {
-		mantlo = mant - 1;
-		explo = exp;
+		mantlo = mant - 1
+		explo = exp
 	} else {
-		mantlo = mant*2 - 1;
-		explo = exp - 1;
+		mantlo = mant*2 - 1
+		explo = exp - 1
 	}
-	lower := newDecimal(mantlo*2 + 1).Shift(explo - int(flt.mantbits) - 1);
+	lower := newDecimal(mantlo*2 + 1).Shift(explo - int(flt.mantbits) - 1)
 
 	// The upper and lower bounds are possible outputs only if
 	// the original mantissa is even, so that IEEE round-to-even
 	// would round to the original mantissa and not the neighbors.
-	inclusive := mant%2 == 0;
+	inclusive := mant%2 == 0
 
 	// Now we can figure out the minimum number of digits required.
 	// Walk along until d has distinguished itself from upper and lower.
 	for i := 0; i < d.nd; i++ {
-		var l, m, u byte;	// lower, middle, upper digits
+		var l, m, u byte // lower, middle, upper digits
 		if i < lower.nd {
 			l = lower.d[i]
 		} else {
 			l = '0'
 		}
-		m = d.d[i];
+		m = d.d[i]
 		if i < upper.nd {
 			u = upper.d[i]
 		} else {
@@ -229,37 +229,37 @@ func roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo) {
 
 		// Okay to round down (truncate) if lower has a different digit
 		// or if lower is inclusive and is exactly the result of rounding down.
-		okdown := l != m || (inclusive && l == m && i+1 == lower.nd);
+		okdown := l != m || (inclusive && l == m && i+1 == lower.nd)
 
 		// Okay to round up if upper has a different digit and
 		// either upper is inclusive or upper is bigger than the result of rounding up.
-		okup := m != u && (inclusive || i+1 < upper.nd);
+		okup := m != u && (inclusive || i+1 < upper.nd)
 
 		// If it's okay to do either, then round to the nearest one.
 		// If it's okay to do only one, do it.
 		switch {
 		case okdown && okup:
-			d.Round(i + 1);
-			return;
+			d.Round(i + 1)
+			return
 		case okdown:
-			d.RoundDown(i + 1);
-			return;
+			d.RoundDown(i + 1)
+			return
 		case okup:
-			d.RoundUp(i + 1);
-			return;
+			d.RoundUp(i + 1)
+			return
 		}
 	}
 }
 
 // %e: -d.ddddde±dd
 func fmtE(neg bool, d *decimal, prec int, fmt byte) string {
-	buf := make([]byte, 3+max(prec, 0)+30);	// "-0." + prec digits + exp
-	w := 0;					// write index
+	buf := make([]byte, 3+max(prec, 0)+30) // "-0." + prec digits + exp
+	w := 0                                 // write index
 
 	// sign
 	if neg {
-		buf[w] = '-';
-		w++;
+		buf[w] = '-'
+		w++
 	}
 
 	// first digit
@@ -268,141 +268,141 @@ func fmtE(neg bool, d *decimal, prec int, fmt byte) string {
 	} else {
 		buf[w] = d.d[0]
 	}
-	w++;
+	w++
 
 	// .moredigits
 	if prec > 0 {
-		buf[w] = '.';
-		w++;
+		buf[w] = '.'
+		w++
 		for i := 0; i < prec; i++ {
 			if 1+i < d.nd {
 				buf[w] = d.d[1+i]
 			} else {
 				buf[w] = '0'
 			}
-			w++;
+			w++
 		}
 	}
 
 	// e±
-	buf[w] = fmt;
-	w++;
-	exp := d.dp - 1;
-	if d.nd == 0 {	// special case: 0 has exponent 0
+	buf[w] = fmt
+	w++
+	exp := d.dp - 1
+	if d.nd == 0 { // special case: 0 has exponent 0
 		exp = 0
 	}
 	if exp < 0 {
-		buf[w] = '-';
-		exp = -exp;
+		buf[w] = '-'
+		exp = -exp
 	} else {
 		buf[w] = '+'
 	}
-	w++;
+	w++
 
 	// dddd
 	// count digits
-	n := 0;
+	n := 0
 	for e := exp; e > 0; e /= 10 {
 		n++
 	}
 	// leading zeros
 	for i := n; i < 2; i++ {
-		buf[w] = '0';
-		w++;
+		buf[w] = '0'
+		w++
 	}
 	// digits
-	w += n;
-	n = 0;
+	w += n
+	n = 0
 	for e := exp; e > 0; e /= 10 {
-		n++;
-		buf[w-n] = byte(e%10 + '0');
+		n++
+		buf[w-n] = byte(e%10 + '0')
 	}
 
-	return string(buf[0:w]);
+	return string(buf[0:w])
 }
 
 // %f: -ddddddd.ddddd
 func fmtF(neg bool, d *decimal, prec int) string {
-	buf := make([]byte, 1+max(d.dp, 1)+1+max(prec, 0));
-	w := 0;
+	buf := make([]byte, 1+max(d.dp, 1)+1+max(prec, 0))
+	w := 0
 
 	// sign
 	if neg {
-		buf[w] = '-';
-		w++;
+		buf[w] = '-'
+		w++
 	}
 
 	// integer, padded with zeros as needed.
 	if d.dp > 0 {
-		var i int;
+		var i int
 		for i = 0; i < d.dp && i < d.nd; i++ {
-			buf[w] = d.d[i];
-			w++;
+			buf[w] = d.d[i]
+			w++
 		}
 		for ; i < d.dp; i++ {
-			buf[w] = '0';
-			w++;
+			buf[w] = '0'
+			w++
 		}
 	} else {
-		buf[w] = '0';
-		w++;
+		buf[w] = '0'
+		w++
 	}
 
 	// fraction
 	if prec > 0 {
-		buf[w] = '.';
-		w++;
+		buf[w] = '.'
+		w++
 		for i := 0; i < prec; i++ {
 			if d.dp+i < 0 || d.dp+i >= d.nd {
 				buf[w] = '0'
 			} else {
 				buf[w] = d.d[d.dp+i]
 			}
-			w++;
+			w++
 		}
 	}
 
-	return string(buf[0:w]);
+	return string(buf[0:w])
 }
 
 // %b: -ddddddddp+ddd
 func fmtB(neg bool, mant uint64, exp int, flt *floatInfo) string {
-	var buf [50]byte;
-	w := len(buf);
-	exp -= int(flt.mantbits);
-	esign := byte('+');
+	var buf [50]byte
+	w := len(buf)
+	exp -= int(flt.mantbits)
+	esign := byte('+')
 	if exp < 0 {
-		esign = '-';
-		exp = -exp;
+		esign = '-'
+		exp = -exp
 	}
-	n := 0;
+	n := 0
 	for exp > 0 || n < 1 {
-		n++;
-		w--;
-		buf[w] = byte(exp%10 + '0');
-		exp /= 10;
+		n++
+		w--
+		buf[w] = byte(exp%10 + '0')
+		exp /= 10
 	}
-	w--;
-	buf[w] = esign;
-	w--;
-	buf[w] = 'p';
-	n = 0;
+	w--
+	buf[w] = esign
+	w--
+	buf[w] = 'p'
+	n = 0
 	for mant > 0 || n < 1 {
-		n++;
-		w--;
-		buf[w] = byte(mant%10 + '0');
-		mant /= 10;
+		n++
+		w--
+		buf[w] = byte(mant%10 + '0')
+		mant /= 10
 	}
 	if neg {
-		w--;
-		buf[w] = '-';
+		w--
+		buf[w] = '-'
 	}
-	return string(buf[w:]);
+	return string(buf[w:])
 }
 
 func max(a, b int) int {
 	if a > b {
 		return a
 	}
-	return b;
+	return b
 }
diff --git a/src/pkg/strconv/ftoa_test.go b/src/pkg/strconv/ftoa_test.go
index 99d8ec5149..70497bf82a 100644
--- a/src/pkg/strconv/ftoa_test.go
+++ b/src/pkg/strconv/ftoa_test.go
@@ -5,23 +5,23 @@
 package strconv_test
 
 import (
-	"math";
-	. "strconv";
-	"testing";
+	"math"
+	. "strconv"
+	"testing"
 )
 
 type ftoaTest struct {
-	f	float64;
-	fmt	byte;
-	prec	int;
-	s	string;
+	f    float64
+	fmt  byte
+	prec int
+	s    string
 }
 
-func fdiv(a, b float64) float64	{ return a / b }	// keep compiler in the dark
+func fdiv(a, b float64) float64 { return a / b } // keep compiler in the dark
 
 const (
-	below1e23	= 99999999999999974834176;
-	above1e23	= 100000000000000008388608;
+	below1e23 = 99999999999999974834176
+	above1e23 = 100000000000000008388608
 )
 
 var ftoatests = []ftoaTest{
@@ -104,13 +104,13 @@ func TestFtoa(t *testing.T) {
 		panic("floatsize: ", FloatSize)
 	}
 	for i := 0; i < len(ftoatests); i++ {
-		test := &ftoatests[i];
-		s := Ftoa64(test.f, test.fmt, test.prec);
+		test := &ftoatests[i]
+		s := Ftoa64(test.f, test.fmt, test.prec)
 		if s != test.s {
 			t.Error("test", test.f, string(test.fmt), test.prec, "want", test.s, "got", s)
 		}
 		if float64(float32(test.f)) == test.f && test.fmt != 'b' {
-			s := Ftoa32(float32(test.f), test.fmt, test.prec);
+			s := Ftoa32(float32(test.f), test.fmt, test.prec)
 			if s != test.s {
 				t.Error("test32", test.f, string(test.fmt), test.prec, "want", test.s, "got", s)
 			}
diff --git a/src/pkg/strconv/internal_test.go b/src/pkg/strconv/internal_test.go
index 1a3bab2a03..9a7f4f0867 100644
--- a/src/pkg/strconv/internal_test.go
+++ b/src/pkg/strconv/internal_test.go
@@ -6,10 +6,10 @@
 
 package strconv
 
-func NewDecimal(i uint64) *decimal	{ return newDecimal(i) }
+func NewDecimal(i uint64) *decimal { return newDecimal(i) }
 
 func SetOptimize(b bool) bool {
-	old := optimize;
-	optimize = b;
-	return old;
+	old := optimize
+	optimize = b
+	return old
 }
diff --git a/src/pkg/strconv/itoa.go b/src/pkg/strconv/itoa.go
index bb4810453c..a633560537 100644
--- a/src/pkg/strconv/itoa.go
+++ b/src/pkg/strconv/itoa.go
@@ -11,16 +11,16 @@ func Uitob64(u uint64, base uint) string {
 	}
 
 	// Assemble decimal in reverse order.
-	var buf [32]byte;
-	j := len(buf);
-	b := uint64(base);
+	var buf [32]byte
+	j := len(buf)
+	b := uint64(base)
 	for u > 0 {
-		j--;
-		buf[j] = "0123456789abcdefghijklmnopqrstuvwxyz"[u%b];
-		u /= b;
+		j--
+		buf[j] = "0123456789abcdefghijklmnopqrstuvwxyz"[u%b]
+		u /= b
 	}
 
-	return string(buf[j:]);
+	return string(buf[j:])
 }
 
 // Itob64 returns the string representation of i in the given base.
@@ -32,23 +32,23 @@ func Itob64(i int64, base uint) string {
 	if i < 0 {
 		return "-" + Uitob64(-uint64(i), base)
 	}
-	return Uitob64(uint64(i), base);
+	return Uitob64(uint64(i), base)
 }
 
 // Itoa64 returns the decimal string representation of i.
-func Itoa64(i int64) string	{ return Itob64(i, 10) }
+func Itoa64(i int64) string { return Itob64(i, 10) }
 
 // Uitoa64 returns the decimal string representation of i.
-func Uitoa64(i uint64) string	{ return Uitob64(i, 10) }
+func Uitoa64(i uint64) string { return Uitob64(i, 10) }
 
 // Uitob returns the string representation of i in the given base.
-func Uitob(i uint, base uint) string	{ return Uitob64(uint64(i), base) }
+func Uitob(i uint, base uint) string { return Uitob64(uint64(i), base) }
 
 // Itob returns the string representation of i in the given base.
-func Itob(i int, base uint) string	{ return Itob64(int64(i), base) }
+func Itob(i int, base uint) string { return Itob64(int64(i), base) }
 
 // Itoa returns the decimal string representation of i.
-func Itoa(i int) string	{ return Itob64(int64(i), 10) }
+func Itoa(i int) string { return Itob64(int64(i), 10) }
 
 // Uitoa returns the decimal string representation of i.
-func Uitoa(i uint) string	{ return Uitob64(uint64(i), 10) }
+func Uitoa(i uint) string { return Uitob64(uint64(i), 10) }
diff --git a/src/pkg/strconv/itoa_test.go b/src/pkg/strconv/itoa_test.go
index 63e2cf9462..e0624b547c 100644
--- a/src/pkg/strconv/itoa_test.go
+++ b/src/pkg/strconv/itoa_test.go
@@ -5,14 +5,14 @@
 package strconv_test
 
 import (
-	. "strconv";
-	"testing";
+	. "strconv"
+	"testing"
 )
 
 type itob64Test struct {
-	in	int64;
-	base	uint;
-	out	string;
+	in   int64
+	base uint
+	out  string
 }
 
 var itob64tests = []itob64Test{
@@ -59,14 +59,14 @@ var itob64tests = []itob64Test{
 
 func TestItoa(t *testing.T) {
 	for _, test := range itob64tests {
-		s := Itob64(test.in, test.base);
+		s := Itob64(test.in, test.base)
 		if s != test.out {
 			t.Errorf("Itob64(%v, %v) = %v want %v\n",
 				test.in, test.base, s, test.out)
 		}
 
 		if test.in >= 0 {
-			s := Uitob64(uint64(test.in), test.base);
+			s := Uitob64(uint64(test.in), test.base)
 			if s != test.out {
 				t.Errorf("Uitob64(%v, %v) = %v want %v\n",
 					test.in, test.base, s, test.out)
@@ -74,14 +74,14 @@ func TestItoa(t *testing.T) {
 		}
 
 		if int64(int(test.in)) == test.in {
-			s := Itob(int(test.in), test.base);
+			s := Itob(int(test.in), test.base)
 			if s != test.out {
 				t.Errorf("Itob(%v, %v) = %v want %v\n",
 					test.in, test.base, s, test.out)
 			}
 
 			if test.in >= 0 {
-				s := Uitob(uint(test.in), test.base);
+				s := Uitob(uint(test.in), test.base)
 				if s != test.out {
 					t.Errorf("Uitob(%v, %v) = %v want %v\n",
 						test.in, test.base, s, test.out)
@@ -90,14 +90,14 @@ func TestItoa(t *testing.T) {
 		}
 
 		if test.base == 10 {
-			s := Itoa64(test.in);
+			s := Itoa64(test.in)
 			if s != test.out {
 				t.Errorf("Itoa64(%v) = %v want %v\n",
 					test.in, s, test.out)
 			}
 
 			if test.in >= 0 {
-				s := Uitob64(uint64(test.in), test.base);
+				s := Uitob64(uint64(test.in), test.base)
 				if s != test.out {
 					t.Errorf("Uitob64(%v, %v) = %v want %v\n",
 						test.in, test.base, s, test.out)
@@ -105,14 +105,14 @@ func TestItoa(t *testing.T) {
 			}
 
 			if int64(int(test.in)) == test.in {
-				s := Itoa(int(test.in));
+				s := Itoa(int(test.in))
 				if s != test.out {
 					t.Errorf("Itoa(%v) = %v want %v\n",
 						test.in, s, test.out)
 				}
 
 				if test.in >= 0 {
-					s := Uitoa(uint(test.in));
+					s := Uitoa(uint(test.in))
 					if s != test.out {
 						t.Errorf("Uitoa(%v) = %v want %v\n",
 							test.in, s, test.out)
@@ -124,9 +124,9 @@ func TestItoa(t *testing.T) {
 }
 
 type uitob64Test struct {
-	in	uint64;
-	base	uint;
-	out	string;
+	in   uint64
+	base uint
+	out  string
 }
 
 var uitob64tests = []uitob64Test{
@@ -139,14 +139,14 @@ var uitob64tests = []uitob64Test{
 
 func TestUitoa(t *testing.T) {
 	for _, test := range uitob64tests {
-		s := Uitob64(test.in, test.base);
+		s := Uitob64(test.in, test.base)
 		if s != test.out {
 			t.Errorf("Uitob64(%v, %v) = %v want %v\n",
 				test.in, test.base, s, test.out)
 		}
 
 		if uint64(uint(test.in)) == test.in {
-			s := Uitob(uint(test.in), test.base);
+			s := Uitob(uint(test.in), test.base)
 			if s != test.out {
 				t.Errorf("Uitob(%v, %v) = %v want %v\n",
 					test.in, test.base, s, test.out)
@@ -154,14 +154,14 @@ func TestUitoa(t *testing.T) {
 		}
 
 		if test.base == 10 {
-			s := Uitoa64(test.in);
+			s := Uitoa64(test.in)
 			if s != test.out {
 				t.Errorf("Uitoa64(%v) = %v want %v\n",
 					test.in, s, test.out)
 			}
 
 			if uint64(uint(test.in)) == test.in {
-				s := Uitoa(uint(test.in));
+				s := Uitoa(uint(test.in))
 				if s != test.out {
 					t.Errorf("Uitoa(%v) = %v want %v\n",
 						test.in, s, test.out)
diff --git a/src/pkg/strconv/quote.go b/src/pkg/strconv/quote.go
index 5b5911db0f..ccd1062645 100644
--- a/src/pkg/strconv/quote.go
+++ b/src/pkg/strconv/quote.go
@@ -5,11 +5,11 @@
 package strconv
 
 import (
-	"bytes";
-	"os";
-	"strings";
-	"unicode";
-	"utf8";
+	"bytes"
+	"os"
+	"strings"
+	"unicode"
+	"utf8"
 )
 
 const lowerhex = "0123456789abcdef"
@@ -19,8 +19,8 @@ const lowerhex = "0123456789abcdef"
 // sequences (\t, \n, \xFF, \u0100) for control characters
 // and non-ASCII characters.
 func Quote(s string) string {
-	var buf bytes.Buffer;
-	buf.WriteByte('"');
+	var buf bytes.Buffer
+	buf.WriteByte('"')
 	for ; len(s) > 0; s = s[1:] {
 		switch c := s[0]; {
 		case c == '"':
@@ -45,18 +45,18 @@ func Quote(s string) string {
 			buf.WriteString(`\v`)
 
 		case c >= utf8.RuneSelf && utf8.FullRuneInString(s):
-			r, size := utf8.DecodeRuneInString(s);
+			r, size := utf8.DecodeRuneInString(s)
 			if r == utf8.RuneError && size == 1 {
 				goto EscX
 			}
-			s = s[size-1:];	// next iteration will slice off 1 more
+			s = s[size-1:] // next iteration will slice off 1 more
 			if r < 0x10000 {
-				buf.WriteString(`\u`);
+				buf.WriteString(`\u`)
 				for j := uint(0); j < 4; j++ {
 					buf.WriteByte(lowerhex[(r>>(12-4*j))&0xF])
 				}
 			} else {
-				buf.WriteString(`\U`);
+				buf.WriteString(`\U`)
 				for j := uint(0); j < 8; j++ {
 					buf.WriteByte(lowerhex[(r>>(28-4*j))&0xF])
 				}
@@ -64,13 +64,13 @@ func Quote(s string) string {
 
 		default:
 		EscX:
-			buf.WriteString(`\x`);
-			buf.WriteByte(lowerhex[c>>4]);
-			buf.WriteByte(lowerhex[c&0xF]);
+			buf.WriteString(`\x`)
+			buf.WriteByte(lowerhex[c>>4])
+			buf.WriteByte(lowerhex[c&0xF])
 		}
 	}
-	buf.WriteByte('"');
-	return buf.String();
+	buf.WriteByte('"')
+	return buf.String()
 }
 
 // CanBackquote returns whether the string s would be
@@ -81,11 +81,11 @@ func CanBackquote(s string) bool {
 			return false
 		}
 	}
-	return true;
+	return true
 }
 
 func unhex(b byte) (v int, ok bool) {
-	c := int(b);
+	c := int(b)
 	switch {
 	case '0' <= c && c <= '9':
 		return c - '0', true
@@ -94,7 +94,7 @@ func unhex(b byte) (v int, ok bool) {
 	case 'A' <= c && c <= 'F':
 		return c - 'A' + 10, true
 	}
-	return;
+	return
 }
 
 // UnquoteChar decodes the first character or byte in the escaped string
@@ -114,22 +114,22 @@ func UnquoteChar(s string, quote byte) (value int, multibyte bool, tail string,
 	// easy cases
 	switch c := s[0]; {
 	case c == quote && (quote == '\'' || quote == '"'):
-		err = os.EINVAL;
-		return;
+		err = os.EINVAL
+		return
 	case c >= utf8.RuneSelf:
-		r, size := utf8.DecodeRuneInString(s);
-		return r, true, s[size:], nil;
+		r, size := utf8.DecodeRuneInString(s)
+		return r, true, s[size:], nil
 	case c != '\\':
 		return int(s[0]), false, s[1:], nil
 	}
 
 	// hard case: c is backslash
 	if len(s) <= 1 {
-		err = os.EINVAL;
-		return;
+		err = os.EINVAL
+		return
 	}
-	c := s[1];
-	s = s[2:];
+	c := s[1]
+	s = s[2:]
 
 	switch c {
 	case 'a':
@@ -147,7 +147,7 @@ func UnquoteChar(s string, quote byte) (value int, multibyte bool, tail string,
 	case 'v':
 		value = '\v'
 	case 'x', 'u', 'U':
-		n := 0;
+		n := 0
 		switch c {
 		case 'x':
 			n = 2
@@ -156,64 +156,64 @@ func UnquoteChar(s string, quote byte) (value int, multibyte bool, tail string,
 		case 'U':
 			n = 8
 		}
-		v := 0;
+		v := 0
 		if len(s) < n {
-			err = os.EINVAL;
-			return;
+			err = os.EINVAL
+			return
 		}
 		for j := 0; j < n; j++ {
-			x, ok := unhex(s[j]);
+			x, ok := unhex(s[j])
 			if !ok {
-				err = os.EINVAL;
-				return;
+				err = os.EINVAL
+				return
 			}
-			v = v<<4 | x;
+			v = v<<4 | x
 		}
-		s = s[n:];
+		s = s[n:]
 		if c == 'x' {
 			// single-byte string, possibly not UTF-8
-			value = v;
-			break;
+			value = v
+			break
 		}
 		if v > unicode.MaxRune {
-			err = os.EINVAL;
-			return;
+			err = os.EINVAL
+			return
 		}
-		value = v;
-		multibyte = true;
+		value = v
+		multibyte = true
 	case '0', '1', '2', '3', '4', '5', '6', '7':
-		v := int(c) - '0';
+		v := int(c) - '0'
 		if len(s) < 2 {
-			err = os.EINVAL;
-			return;
+			err = os.EINVAL
+			return
 		}
-		for j := 0; j < 2; j++ {	// one digit already; two more
-			x := int(s[j]) - '0';
+		for j := 0; j < 2; j++ { // one digit already; two more
+			x := int(s[j]) - '0'
 			if x < 0 || x > 7 {
 				return
 			}
-			v = (v << 3) | x;
+			v = (v << 3) | x
 		}
-		s = s[2:];
+		s = s[2:]
 		if v > 255 {
-			err = os.EINVAL;
-			return;
+			err = os.EINVAL
+			return
 		}
-		value = v;
+		value = v
 	case '\\':
 		value = '\\'
 	case '\'', '"':
 		if c != quote {
-			err = os.EINVAL;
-			return;
+			err = os.EINVAL
+			return
 		}
-		value = int(c);
+		value = int(c)
 	default:
-		err = os.EINVAL;
-		return;
+		err = os.EINVAL
+		return
 	}
-	tail = s;
-	return;
+	tail = s
+	return
 }
 
 // Unquote interprets s as a single-quoted, double-quoted,
@@ -222,33 +222,33 @@ func UnquoteChar(s string, quote byte) (value int, multibyte bool, tail string,
 // character literal; Unquote returns the corresponding
 // one-character string.)
 func Unquote(s string) (t string, err os.Error) {
-	n := len(s);
+	n := len(s)
 	if n < 2 {
 		return "", os.EINVAL
 	}
-	quote := s[0];
+	quote := s[0]
 	if quote != s[n-1] {
 		return "", os.EINVAL
 	}
-	s = s[1 : n-1];
+	s = s[1 : n-1]
 
 	if quote == '`' {
 		if strings.Index(s, "`") >= 0 {
 			return "", os.EINVAL
 		}
-		return s, nil;
+		return s, nil
 	}
 	if quote != '"' && quote != '\'' {
 		return "", err
 	}
 
-	var buf bytes.Buffer;
+	var buf bytes.Buffer
 	for len(s) > 0 {
-		c, multibyte, ss, err := UnquoteChar(s, quote);
+		c, multibyte, ss, err := UnquoteChar(s, quote)
 		if err != nil {
 			return "", err
 		}
-		s = ss;
+		s = ss
 		if c < utf8.RuneSelf || !multibyte {
 			buf.WriteByte(byte(c))
 		} else {
@@ -259,5 +259,5 @@ func Unquote(s string) (t string, err os.Error) {
 			return "", os.EINVAL
 		}
 	}
-	return buf.String(), nil;
+	return buf.String(), nil
 }
diff --git a/src/pkg/strconv/quote_test.go b/src/pkg/strconv/quote_test.go
index 3c42d39711..31784879ae 100644
--- a/src/pkg/strconv/quote_test.go
+++ b/src/pkg/strconv/quote_test.go
@@ -5,14 +5,14 @@
 package strconv_test
 
 import (
-	"os";
-	. "strconv";
-	"testing";
+	"os"
+	. "strconv"
+	"testing"
 )
 
 type quoteTest struct {
-	in	string;
-	out	string;
+	in  string
+	out string
 }
 
 var quotetests = []quoteTest{
@@ -26,7 +26,7 @@ var quotetests = []quoteTest{
 
 func TestQuote(t *testing.T) {
 	for i := 0; i < len(quotetests); i++ {
-		tt := quotetests[i];
+		tt := quotetests[i]
 		if out := Quote(tt.in); out != tt.out {
 			t.Errorf("Quote(%s) = %s, want %s", tt.in, out, tt.out)
 		}
@@ -34,8 +34,8 @@ func TestQuote(t *testing.T) {
 }
 
 type canBackquoteTest struct {
-	in	string;
-	out	bool;
+	in  string
+	out bool
 }
 
 var canbackquotetests = []canBackquoteTest{
@@ -49,7 +49,7 @@ var canbackquotetests = []canBackquoteTest{
 	canBackquoteTest{string(6), false},
 	canBackquoteTest{string(7), false},
 	canBackquoteTest{string(8), false},
-	canBackquoteTest{string(9), true},	// \t
+	canBackquoteTest{string(9), true}, // \t
 	canBackquoteTest{string(10), false},
 	canBackquoteTest{string(11), false},
 	canBackquoteTest{string(12), false},
@@ -81,7 +81,7 @@ var canbackquotetests = []canBackquoteTest{
 
 func TestCanBackquote(t *testing.T) {
 	for i := 0; i < len(canbackquotetests); i++ {
-		tt := canbackquotetests[i];
+		tt := canbackquotetests[i]
 		if out := CanBackquote(tt.in); out != tt.out {
 			t.Errorf("CanBackquote(%q) = %v, want %v", tt.in, out, tt.out)
 		}
@@ -147,7 +147,7 @@ var misquoted = []string{
 
 func TestUnquote(t *testing.T) {
 	for i := 0; i < len(unquotetests); i++ {
-		tt := unquotetests[i];
+		tt := unquotetests[i]
 		if out, err := Unquote(tt.in); err != nil && out != tt.out {
 			t.Errorf("Unquote(%#q) = %q, %v want %q, nil", tt.in, out, err, tt.out)
 		}
@@ -155,14 +155,14 @@ func TestUnquote(t *testing.T) {
 
 	// run the quote tests too, backward
 	for i := 0; i < len(quotetests); i++ {
-		tt := quotetests[i];
+		tt := quotetests[i]
 		if in, err := Unquote(tt.out); in != tt.in {
 			t.Errorf("Unquote(%#q) = %q, %v, want %q, nil", tt.out, in, err, tt.in)
 		}
 	}
 
 	for i := 0; i < len(misquoted); i++ {
-		s := misquoted[i];
+		s := misquoted[i]
 		if out, err := Unquote(s); out != "" || err != os.EINVAL {
 			t.Errorf("Unquote(%#q) = %q, %v want %q, %v", s, out, err, "", os.EINVAL)
 		}
diff --git a/src/pkg/strings/reader.go b/src/pkg/strings/reader.go
index 80c745bb8b..7cefbd24bb 100644
--- a/src/pkg/strings/reader.go
+++ b/src/pkg/strings/reader.go
@@ -11,28 +11,28 @@ import "os"
 type Reader string
 
 func (r *Reader) Read(b []byte) (n int, err os.Error) {
-	s := *r;
+	s := *r
 	if len(s) == 0 {
 		return 0, os.EOF
 	}
 	for n < len(s) && n < len(b) {
-		b[n] = s[n];
-		n++;
+		b[n] = s[n]
+		n++
 	}
-	*r = s[n:];
-	return;
+	*r = s[n:]
+	return
 }
 
 func (r *Reader) ReadByte() (b byte, err os.Error) {
-	s := *r;
+	s := *r
 	if len(s) == 0 {
 		return 0, os.EOF
 	}
-	b = s[0];
-	*r = s[1:];
-	return;
+	b = s[0]
+	*r = s[1:]
+	return
 }
 
 // NewReader returns a new Reader reading from s.
 // It is similar to bytes.NewBufferString but more efficient and read-only.
-func NewReader(s string) *Reader	{ return (*Reader)(&s) }
+func NewReader(s string) *Reader { return (*Reader)(&s) }
diff --git a/src/pkg/strings/strings.go b/src/pkg/strings/strings.go
index 4e375b4d5b..ae34a5f3c3 100644
--- a/src/pkg/strings/strings.go
+++ b/src/pkg/strings/strings.go
@@ -6,8 +6,8 @@
 package strings
 
 import (
-	"unicode";
-	"utf8";
+	"unicode"
+	"utf8"
 )
 
 // explode splits s into an array of UTF-8 sequences, one per Unicode character (still strings) up to a maximum of n (n <= 0 means no limit).
@@ -16,21 +16,21 @@ func explode(s string, n int) []string {
 	if n <= 0 {
 		n = len(s)
 	}
-	a := make([]string, n);
-	var size, rune int;
-	na := 0;
+	a := make([]string, n)
+	var size, rune int
+	na := 0
 	for len(s) > 0 {
 		if na+1 >= n {
-			a[na] = s;
-			na++;
-			break;
+			a[na] = s
+			na++
+			break
 		}
-		rune, size = utf8.DecodeRuneInString(s);
-		s = s[size:];
-		a[na] = string(rune);
-		na++;
+		rune, size = utf8.DecodeRuneInString(s)
+		s = s[size:]
+		a[na] = string(rune)
+		na++
 	}
-	return a[0:na];
+	return a[0:na]
 }
 
 // Count counts the number of non-overlapping instances of sep in s.
@@ -38,24 +38,24 @@ func Count(s, sep string) int {
 	if sep == "" {
 		return utf8.RuneCountInString(s) + 1
 	}
-	c := sep[0];
-	n := 0;
+	c := sep[0]
+	n := 0
 	for i := 0; i+len(sep) <= len(s); i++ {
 		if s[i] == c && (len(sep) == 1 || s[i:i+len(sep)] == sep) {
-			n++;
-			i += len(sep) - 1;
+			n++
+			i += len(sep) - 1
 		}
 	}
-	return n;
+	return n
 }
 
 // Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.
 func Index(s, sep string) int {
-	n := len(sep);
+	n := len(sep)
 	if n == 0 {
 		return 0
 	}
-	c := sep[0];
+	c := sep[0]
 	if n == 1 {
 		// special case worth making fast
 		for i := 0; i < len(s); i++ {
@@ -63,23 +63,23 @@ func Index(s, sep string) int {
 				return i
 			}
 		}
-		return -1;
+		return -1
 	}
 	for i := 0; i+n <= len(s); i++ {
 		if s[i] == c && (n == 1 || s[i:i+n] == sep) {
 			return i
 		}
 	}
-	return -1;
+	return -1
 }
 
 // LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.
 func LastIndex(s, sep string) int {
-	n := len(sep);
+	n := len(sep)
 	if n == 0 {
 		return len(s)
 	}
-	c := sep[0];
+	c := sep[0]
 	if n == 1 {
 		// special case worth making fast
 		for i := len(s) - 1; i >= 0; i-- {
@@ -87,14 +87,14 @@ func LastIndex(s, sep string) int {
 				return i
 			}
 		}
-		return -1;
+		return -1
 	}
 	for i := len(s) - n; i >= 0; i-- {
 		if s[i] == c && (n == 1 || s[i:i+n] == sep) {
 			return i
 		}
 	}
-	return -1;
+	return -1
 }
 
 // Generic split: splits after each instance of sep,
@@ -106,26 +106,26 @@ func genSplit(s, sep string, sepSave, n int) []string {
 	if n <= 0 {
 		n = Count(s, sep) + 1
 	}
-	c := sep[0];
-	start := 0;
-	a := make([]string, n);
-	na := 0;
+	c := sep[0]
+	start := 0
+	a := make([]string, n)
+	na := 0
 	for i := 0; i+len(sep) <= len(s) && na+1 < n; i++ {
 		if s[i] == c && (len(sep) == 1 || s[i:i+len(sep)] == sep) {
-			a[na] = s[start : i+sepSave];
-			na++;
-			start = i + len(sep);
-			i += len(sep) - 1;
+			a[na] = s[start : i+sepSave]
+			na++
+			start = i + len(sep)
+			i += len(sep) - 1
 		}
 	}
-	a[na] = s[start:];
-	return a[0 : na+1];
+	a[na] = s[start:]
+	return a[0 : na+1]
 }
 
 // Split splits the string s around each instance of sep, returning an array of substrings of s.
 // If sep is empty, Split splits s after each UTF-8 sequence.
 // If n > 0, Split splits s into at most n substrings; the last substring will be the unsplit remainder.
-func Split(s, sep string, n int) []string	{ return genSplit(s, sep, 0, n) }
+func Split(s, sep string, n int) []string { return genSplit(s, sep, 0, n) }
 
 // SplitAfter splits the string s after each instance of sep, returning an array of substrings of s.
 // If sep is empty, SplitAfter splits s after each UTF-8 sequence.
@@ -143,28 +143,28 @@ func Join(a []string, sep string) string {
 	if len(a) == 1 {
 		return a[0]
 	}
-	n := len(sep) * (len(a) - 1);
+	n := len(sep) * (len(a) - 1)
 	for i := 0; i < len(a); i++ {
 		n += len(a[i])
 	}
 
-	b := make([]byte, n);
-	bp := 0;
+	b := make([]byte, n)
+	bp := 0
 	for i := 0; i < len(a); i++ {
-		s := a[i];
+		s := a[i]
 		for j := 0; j < len(s); j++ {
-			b[bp] = s[j];
-			bp++;
+			b[bp] = s[j]
+			bp++
 		}
 		if i+1 < len(a) {
-			s = sep;
+			s = sep
 			for j := 0; j < len(s); j++ {
-				b[bp] = s[j];
-				bp++;
+				b[bp] = s[j]
+				bp++
 			}
 		}
 	}
-	return string(b);
+	return string(b)
 }
 
 // HasPrefix tests whether the string s begins with prefix.
@@ -184,105 +184,105 @@ func Map(mapping func(rune int) int, s string) string {
 	// In the worst case, the string can grow when mapped, making
 	// things unpleasant.  But it's so rare we barge in assuming it's
 	// fine.  It could also shrink but that falls out naturally.
-	maxbytes := len(s);	// length of b
-	nbytes := 0;		// number of bytes encoded in b
-	b := make([]byte, maxbytes);
+	maxbytes := len(s) // length of b
+	nbytes := 0        // number of bytes encoded in b
+	b := make([]byte, maxbytes)
 	for _, c := range s {
-		rune := mapping(c);
+		rune := mapping(c)
 		if rune >= 0 {
-			wid := 1;
+			wid := 1
 			if rune >= utf8.RuneSelf {
 				wid = utf8.RuneLen(rune)
 			}
 			if nbytes+wid > maxbytes {
 				// Grow the buffer.
-				maxbytes = maxbytes*2 + utf8.UTFMax;
-				nb := make([]byte, maxbytes);
+				maxbytes = maxbytes*2 + utf8.UTFMax
+				nb := make([]byte, maxbytes)
 				for i, c := range b[0:nbytes] {
 					nb[i] = c
 				}
-				b = nb;
+				b = nb
 			}
-			nbytes += utf8.EncodeRune(rune, b[nbytes:maxbytes]);
+			nbytes += utf8.EncodeRune(rune, b[nbytes:maxbytes])
 		}
 	}
-	return string(b[0:nbytes]);
+	return string(b[0:nbytes])
 }
 
 // Repeat returns a new string consisting of count copies of the string s.
 func Repeat(s string, count int) string {
-	b := make([]byte, len(s)*count);
-	bp := 0;
+	b := make([]byte, len(s)*count)
+	bp := 0
 	for i := 0; i < count; i++ {
 		for j := 0; j < len(s); j++ {
-			b[bp] = s[j];
-			bp++;
+			b[bp] = s[j]
+			bp++
 		}
 	}
-	return string(b);
+	return string(b)
 }
 
 
 // ToUpper returns a copy of the string s with all Unicode letters mapped to their upper case.
-func ToUpper(s string) string	{ return Map(unicode.ToUpper, s) }
+func ToUpper(s string) string { return Map(unicode.ToUpper, s) }
 
 // ToLower returns a copy of the string s with all Unicode letters mapped to their lower case.
-func ToLower(s string) string	{ return Map(unicode.ToLower, s) }
+func ToLower(s string) string { return Map(unicode.ToLower, s) }
 
 // ToTitle returns a copy of the string s with all Unicode letters mapped to their title case.
-func ToTitle(s string) string	{ return Map(unicode.ToTitle, s) }
+func ToTitle(s string) string { return Map(unicode.ToTitle, s) }
 
 // Trim returns a slice of the string s, with all leading and trailing white space
 // removed, as defined by Unicode.
 func TrimSpace(s string) string {
-	start, end := 0, len(s);
+	start, end := 0, len(s)
 	for start < end {
-		wid := 1;
-		rune := int(s[start]);
+		wid := 1
+		rune := int(s[start])
 		if rune >= utf8.RuneSelf {
 			rune, wid = utf8.DecodeRuneInString(s[start:end])
 		}
 		if !unicode.IsSpace(rune) {
 			break
 		}
-		start += wid;
+		start += wid
 	}
 	for start < end {
-		wid := 1;
-		rune := int(s[end-1]);
+		wid := 1
+		rune := int(s[end-1])
 		if rune >= utf8.RuneSelf {
 			// Back up carefully looking for beginning of rune. Mustn't pass start.
 			for wid = 2; start <= end-wid && !utf8.RuneStart(s[end-wid]); wid++ {
 			}
-			if start > end-wid {	// invalid UTF-8 sequence; stop processing
+			if start > end-wid { // invalid UTF-8 sequence; stop processing
 				return s[start:end]
 			}
-			rune, wid = utf8.DecodeRuneInString(s[end-wid : end]);
+			rune, wid = utf8.DecodeRuneInString(s[end-wid : end])
 		}
 		if !unicode.IsSpace(rune) {
 			break
 		}
-		end -= wid;
+		end -= wid
 	}
-	return s[start:end];
+	return s[start:end]
 }
 
 // Bytes returns a new slice containing the bytes in s.
 func Bytes(s string) []byte {
-	b := make([]byte, len(s));
+	b := make([]byte, len(s))
 	for i := 0; i < len(s); i++ {
 		b[i] = s[i]
 	}
-	return b;
+	return b
 }
 
 // Runes returns a slice of runes (Unicode code points) equivalent to the string s.
 func Runes(s string) []int {
-	t := make([]int, utf8.RuneCountInString(s));
-	i := 0;
+	t := make([]int, utf8.RuneCountInString(s))
+	i := 0
 	for _, r := range s {
-		t[i] = r;
-		i++;
+		t[i] = r
+		i++
 	}
-	return t;
+	return t
 }
diff --git a/src/pkg/strings/strings_test.go b/src/pkg/strings/strings_test.go
index e3e7f38aed..eb0f8d1fb5 100644
--- a/src/pkg/strings/strings_test.go
+++ b/src/pkg/strings/strings_test.go
@@ -5,10 +5,10 @@
 package strings_test
 
 import (
-	. "strings";
-	"testing";
-	"unicode";
-	"utf8";
+	. "strings"
+	"testing"
+	"unicode"
+	"utf8"
 )
 
 func eq(a, b []string) bool {
@@ -20,7 +20,7 @@ func eq(a, b []string) bool {
 			return false
 		}
 	}
-	return true;
+	return true
 }
 
 var abcd = "abcd"
@@ -29,9 +29,9 @@ var commas = "1,2,3,4"
 var dots = "1....2....3....4"
 
 type IndexTest struct {
-	s	string;
-	sep	string;
-	out	int;
+	s   string
+	sep string
+	out int
 }
 
 var indexTests = []IndexTest{
@@ -76,22 +76,22 @@ var lastIndexTests = []IndexTest{
 // in failure reports.
 func runIndexTests(t *testing.T, f func(s, sep string) int, funcName string, testCases []IndexTest) {
 	for _, test := range testCases {
-		actual := f(test.s, test.sep);
+		actual := f(test.s, test.sep)
 		if actual != test.out {
 			t.Errorf("%s(%q,%q) = %v; want %v", funcName, test.s, test.sep, actual, test.out)
 		}
 	}
 }
 
-func TestIndex(t *testing.T)	{ runIndexTests(t, Index, "Index", indexTests) }
+func TestIndex(t *testing.T) { runIndexTests(t, Index, "Index", indexTests) }
 
-func TestLastIndex(t *testing.T)	{ runIndexTests(t, LastIndex, "LastIndex", lastIndexTests) }
+func TestLastIndex(t *testing.T) { runIndexTests(t, LastIndex, "LastIndex", lastIndexTests) }
 
 
 type ExplodeTest struct {
-	s	string;
-	n	int;
-	a	[]string;
+	s string
+	n int
+	a []string
 }
 
 var explodetests = []ExplodeTest{
@@ -102,12 +102,12 @@ var explodetests = []ExplodeTest{
 
 func TestExplode(t *testing.T) {
 	for _, tt := range explodetests {
-		a := Split(tt.s, "", tt.n);
+		a := Split(tt.s, "", tt.n)
 		if !eq(a, tt.a) {
-			t.Errorf("explode(%q, %d) = %v; want %v", tt.s, tt.n, a, tt.a);
-			continue;
+			t.Errorf("explode(%q, %d) = %v; want %v", tt.s, tt.n, a, tt.a)
+			continue
 		}
-		s := Join(a, "");
+		s := Join(a, "")
 		if s != tt.s {
 			t.Errorf(`Join(explode(%q, %d), "") = %q`, tt.s, tt.n, s)
 		}
@@ -115,10 +115,10 @@ func TestExplode(t *testing.T) {
 }
 
 type SplitTest struct {
-	s	string;
-	sep	string;
-	n	int;
-	a	[]string;
+	s   string
+	sep string
+	n   int
+	a   []string
 }
 
 var splittests = []SplitTest{
@@ -138,12 +138,12 @@ var splittests = []SplitTest{
 
 func TestSplit(t *testing.T) {
 	for _, tt := range splittests {
-		a := Split(tt.s, tt.sep, tt.n);
+		a := Split(tt.s, tt.sep, tt.n)
 		if !eq(a, tt.a) {
-			t.Errorf("Split(%q, %q, %d) = %v; want %v", tt.s, tt.sep, tt.n, a, tt.a);
-			continue;
+			t.Errorf("Split(%q, %q, %d) = %v; want %v", tt.s, tt.sep, tt.n, a, tt.a)
+			continue
 		}
-		s := Join(a, tt.sep);
+		s := Join(a, tt.sep)
 		if s != tt.s {
 			t.Errorf("Join(Split(%q, %q, %d), %q) = %q", tt.s, tt.sep, tt.n, tt.sep, s)
 		}
@@ -168,12 +168,12 @@ var splitaftertests = []SplitTest{
 
 func TestSplitAfter(t *testing.T) {
 	for _, tt := range splitaftertests {
-		a := SplitAfter(tt.s, tt.sep, tt.n);
+		a := SplitAfter(tt.s, tt.sep, tt.n)
 		if !eq(a, tt.a) {
-			t.Errorf(`Split(%q, %q, %d) = %v; want %v`, tt.s, tt.sep, tt.n, a, tt.a);
-			continue;
+			t.Errorf(`Split(%q, %q, %d) = %v; want %v`, tt.s, tt.sep, tt.n, a, tt.a)
+			continue
 		}
-		s := Join(a, "");
+		s := Join(a, "")
 		if s != tt.s {
 			t.Errorf(`Join(Split(%q, %q, %d), %q) = %q`, tt.s, tt.sep, tt.n, tt.sep, s)
 		}
@@ -182,14 +182,14 @@ func TestSplitAfter(t *testing.T) {
 
 // Test case for any function which accepts and returns a single string.
 type StringTest struct {
-	in, out string;
+	in, out string
 }
 
 // Execute f on each test case.  funcName should be the name of f; it's used
 // in failure reports.
 func runStringTests(t *testing.T, f func(string) string, funcName string, testCases []StringTest) {
 	for _, tc := range testCases {
-		actual := f(tc.in);
+		actual := f(tc.in)
 		if actual != tc.out {
 			t.Errorf("%s(%q) = %q; want %q", funcName, tc.in, actual, tc.out)
 		}
@@ -201,7 +201,7 @@ var upperTests = []StringTest{
 	StringTest{"abc", "ABC"},
 	StringTest{"AbC123", "ABC123"},
 	StringTest{"azAZ09_", "AZAZ09_"},
-	StringTest{"\u0250\u0250\u0250\u0250\u0250", "\u2C6F\u2C6F\u2C6F\u2C6F\u2C6F"},	// grows one byte per char
+	StringTest{"\u0250\u0250\u0250\u0250\u0250", "\u2C6F\u2C6F\u2C6F\u2C6F\u2C6F"}, // grows one byte per char
 }
 
 var lowerTests = []StringTest{
@@ -209,7 +209,7 @@ var lowerTests = []StringTest{
 	StringTest{"abc", "abc"},
 	StringTest{"AbC123", "abc123"},
 	StringTest{"azAZ09_", "azaz09_"},
-	StringTest{"\u2C6D\u2C6D\u2C6D\u2C6D\u2C6D", "\u0251\u0251\u0251\u0251\u0251"},	// shrinks one byte per char
+	StringTest{"\u2C6D\u2C6D\u2C6D\u2C6D\u2C6D", "\u0251\u0251\u0251\u0251\u0251"}, // shrinks one byte per char
 }
 
 const space = "\t\v\r\f\n\u0085\u00a0\u2000\u3000"
@@ -223,59 +223,59 @@ var trimSpaceTests = []StringTest{
 	StringTest{" \t\r\n x\t\t\r\r\n\n ", "x"},
 	StringTest{" \u2000\t\r\n x\t\t\r\r\ny\n \u3000", "x\t\t\r\r\ny"},
 	StringTest{"1 \t\r\n2", "1 \t\r\n2"},
-	StringTest{" x\x80", "x\x80"},	// invalid UTF-8 on end
-	StringTest{" x\xc0", "x\xc0"},	// invalid UTF-8 on end
+	StringTest{" x\x80", "x\x80"}, // invalid UTF-8 on end
+	StringTest{" x\xc0", "x\xc0"}, // invalid UTF-8 on end
 }
 
 func tenRunes(rune int) string {
-	r := make([]int, 10);
+	r := make([]int, 10)
 	for i := range r {
 		r[i] = rune
 	}
-	return string(r);
+	return string(r)
 }
 
 // User-defined self-inverse mapping function
 func rot13(rune int) int {
-	step := 13;
+	step := 13
 	if rune >= 'a' && rune <= 'z' {
 		return ((rune - 'a' + step) % 26) + 'a'
 	}
 	if rune >= 'A' && rune <= 'Z' {
 		return ((rune - 'A' + step) % 26) + 'A'
 	}
-	return rune;
+	return rune
 }
 
 func TestMap(t *testing.T) {
 	// Run a couple of awful growth/shrinkage tests
-	a := tenRunes('a');
+	a := tenRunes('a')
 	// 1.  Grow.  This triggers two reallocations in Map.
-	maxRune := func(rune int) int { return unicode.MaxRune };
-	m := Map(maxRune, a);
-	expect := tenRunes(unicode.MaxRune);
+	maxRune := func(rune int) int { return unicode.MaxRune }
+	m := Map(maxRune, a)
+	expect := tenRunes(unicode.MaxRune)
 	if m != expect {
 		t.Errorf("growing: expected %q got %q", expect, m)
 	}
 
 	// 2. Shrink
-	minRune := func(rune int) int { return 'a' };
-	m = Map(minRune, tenRunes(unicode.MaxRune));
-	expect = a;
+	minRune := func(rune int) int { return 'a' }
+	m = Map(minRune, tenRunes(unicode.MaxRune))
+	expect = a
 	if m != expect {
 		t.Errorf("shrinking: expected %q got %q", expect, m)
 	}
 
 	// 3. Rot13
-	m = Map(rot13, "a to zed");
-	expect = "n gb mrq";
+	m = Map(rot13, "a to zed")
+	expect = "n gb mrq"
 	if m != expect {
 		t.Errorf("rot13: expected %q got %q", expect, m)
 	}
 
 	// 4. Rot13^2
-	m = Map(rot13, Map(rot13, "a to zed"));
-	expect = "a to zed";
+	m = Map(rot13, Map(rot13, "a to zed"))
+	expect = "a to zed"
 	if m != expect {
 		t.Errorf("rot13: expected %q got %q", expect, m)
 	}
@@ -285,50 +285,50 @@ func TestMap(t *testing.T) {
 		if unicode.Is(unicode.Latin, rune) {
 			return rune
 		}
-		return -1;
-	};
-	m = Map(dropNotLatin, "Hello, 세계");
-	expect = "Hello";
+		return -1
+	}
+	m = Map(dropNotLatin, "Hello, 세계")
+	expect = "Hello"
 	if m != expect {
 		t.Errorf("drop: expected %q got %q", expect, m)
 	}
 }
 
-func TestToUpper(t *testing.T)	{ runStringTests(t, ToUpper, "ToUpper", upperTests) }
+func TestToUpper(t *testing.T) { runStringTests(t, ToUpper, "ToUpper", upperTests) }
 
-func TestToLower(t *testing.T)	{ runStringTests(t, ToLower, "ToLower", lowerTests) }
+func TestToLower(t *testing.T) { runStringTests(t, ToLower, "ToLower", lowerTests) }
 
-func TestTrimSpace(t *testing.T)	{ runStringTests(t, TrimSpace, "TrimSpace", trimSpaceTests) }
+func TestTrimSpace(t *testing.T) { runStringTests(t, TrimSpace, "TrimSpace", trimSpaceTests) }
 
 func equal(m string, s1, s2 string, t *testing.T) bool {
 	if s1 == s2 {
 		return true
 	}
-	e1 := Split(s1, "", 0);
-	e2 := Split(s2, "", 0);
+	e1 := Split(s1, "", 0)
+	e2 := Split(s2, "", 0)
 	for i, c1 := range e1 {
 		if i > len(e2) {
 			break
 		}
-		r1, _ := utf8.DecodeRuneInString(c1);
-		r2, _ := utf8.DecodeRuneInString(e2[i]);
+		r1, _ := utf8.DecodeRuneInString(c1)
+		r2, _ := utf8.DecodeRuneInString(e2[i])
 		if r1 != r2 {
 			t.Errorf("%s diff at %d: U+%04X U+%04X", m, i, r1, r2)
 		}
 	}
-	return false;
+	return false
 }
 
 func TestCaseConsistency(t *testing.T) {
 	// Make a string of all the runes.
-	a := make([]int, unicode.MaxRune+1);
+	a := make([]int, unicode.MaxRune+1)
 	for i := range a {
 		a[i] = i
 	}
-	s := string(a);
+	s := string(a)
 	// convert the cases.
-	upper := ToUpper(s);
-	lower := ToLower(s);
+	upper := ToUpper(s)
+	lower := ToLower(s)
 
 	// Consistency checks
 	if n := utf8.RuneCountInString(upper); n != unicode.MaxRune+1 {
@@ -360,8 +360,8 @@ func TestCaseConsistency(t *testing.T) {
 }
 
 type RepeatTest struct {
-	in, out	string;
-	count	int;
+	in, out string
+	count   int
 }
 
 var RepeatTests = []RepeatTest{
@@ -376,10 +376,10 @@ var RepeatTests = []RepeatTest{
 
 func TestRepeat(t *testing.T) {
 	for _, tt := range RepeatTests {
-		a := Repeat(tt.in, tt.count);
+		a := Repeat(tt.in, tt.count)
 		if !equal("Repeat(s)", a, tt.out, t) {
-			t.Errorf("Repeat(%v, %d) = %v; want %v", tt.in, tt.count, a, tt.out);
-			continue;
+			t.Errorf("Repeat(%v, %d) = %v; want %v", tt.in, tt.count, a, tt.out)
+			continue
 		}
 	}
 }
@@ -393,13 +393,13 @@ func runesEqual(a, b []int) bool {
 			return false
 		}
 	}
-	return true;
+	return true
 }
 
 type RunesTest struct {
-	in	string;
-	out	[]int;
-	lossy	bool;
+	in    string
+	out   []int
+	lossy bool
 }
 
 var RunesTests = []RunesTest{
@@ -414,14 +414,14 @@ var RunesTests = []RunesTest{
 
 func TestRunes(t *testing.T) {
 	for _, tt := range RunesTests {
-		a := Runes(tt.in);
+		a := Runes(tt.in)
 		if !runesEqual(a, tt.out) {
-			t.Errorf("Runes(%q) = %v; want %v", tt.in, a, tt.out);
-			continue;
+			t.Errorf("Runes(%q) = %v; want %v", tt.in, a, tt.out)
+			continue
 		}
 		if !tt.lossy {
 			// can only test reassembly if we didn't lose information
-			s := string(a);
+			s := string(a)
 			if s != tt.in {
 				t.Errorf("string(Runes(%q)) = %x; want %x", tt.in, s, tt.in)
 			}
diff --git a/src/pkg/sync/mutex.go b/src/pkg/sync/mutex.go
index 9ba628824b..b170370bc1 100644
--- a/src/pkg/sync/mutex.go
+++ b/src/pkg/sync/mutex.go
@@ -16,8 +16,8 @@ func cas(val *uint32, old, new uint32) bool
 // Mutexes can be created as part of other structures;
 // the zero value for a Mutex is an unlocked mutex.
 type Mutex struct {
-	key	uint32;
-	sema	uint32;
+	key  uint32
+	sema uint32
 }
 
 // Add delta to *val, and return the new *val in a thread-safe way. If multiple
@@ -25,13 +25,13 @@ type Mutex struct {
 // serialized, and all the deltas will be added in an undefined order.
 func xadd(val *uint32, delta int32) (new uint32) {
 	for {
-		v := *val;
-		nv := v + uint32(delta);
+		v := *val
+		nv := v + uint32(delta)
 		if cas(val, v, nv) {
 			return nv
 		}
 	}
-	panic("unreached");
+	panic("unreached")
 }
 
 // Lock locks m.
@@ -42,7 +42,7 @@ func (m *Mutex) Lock() {
 		// changed from 0 to 1; we hold lock
 		return
 	}
-	runtime.Semacquire(&m.sema);
+	runtime.Semacquire(&m.sema)
 }
 
 // Unlock unlocks m.
@@ -56,5 +56,5 @@ func (m *Mutex) Unlock() {
 		// changed from 1 to 0; no contention
 		return
 	}
-	runtime.Semrelease(&m.sema);
+	runtime.Semrelease(&m.sema)
 }
diff --git a/src/pkg/sync/mutex_test.go b/src/pkg/sync/mutex_test.go
index 05fef786af..d0e048ed7a 100644
--- a/src/pkg/sync/mutex_test.go
+++ b/src/pkg/sync/mutex_test.go
@@ -7,23 +7,23 @@
 package sync_test
 
 import (
-	"runtime";
-	. "sync";
-	"testing";
+	"runtime"
+	. "sync"
+	"testing"
 )
 
 func HammerSemaphore(s *uint32, loops int, cdone chan bool) {
 	for i := 0; i < loops; i++ {
-		runtime.Semacquire(s);
-		runtime.Semrelease(s);
+		runtime.Semacquire(s)
+		runtime.Semrelease(s)
 	}
-	cdone <- true;
+	cdone <- true
 }
 
 func TestSemaphore(t *testing.T) {
-	s := new(uint32);
-	*s = 1;
-	c := make(chan bool);
+	s := new(uint32)
+	*s = 1
+	c := make(chan bool)
 	for i := 0; i < 10; i++ {
 		go HammerSemaphore(s, 1000, c)
 	}
@@ -33,37 +33,37 @@ func TestSemaphore(t *testing.T) {
 }
 
 func BenchmarkUncontendedSemaphore(b *testing.B) {
-	s := new(uint32);
-	*s = 1;
-	HammerSemaphore(s, b.N, make(chan bool, 2));
+	s := new(uint32)
+	*s = 1
+	HammerSemaphore(s, b.N, make(chan bool, 2))
 }
 
 func BenchmarkContendedSemaphore(b *testing.B) {
-	b.StopTimer();
-	s := new(uint32);
-	*s = 1;
-	c := make(chan bool);
-	runtime.GOMAXPROCS(2);
-	b.StartTimer();
+	b.StopTimer()
+	s := new(uint32)
+	*s = 1
+	c := make(chan bool)
+	runtime.GOMAXPROCS(2)
+	b.StartTimer()
 
-	go HammerSemaphore(s, b.N/2, c);
-	go HammerSemaphore(s, b.N/2, c);
-	<-c;
-	<-c;
+	go HammerSemaphore(s, b.N/2, c)
+	go HammerSemaphore(s, b.N/2, c)
+	<-c
+	<-c
 }
 
 
 func HammerMutex(m *Mutex, loops int, cdone chan bool) {
 	for i := 0; i < loops; i++ {
-		m.Lock();
-		m.Unlock();
+		m.Lock()
+		m.Unlock()
 	}
-	cdone <- true;
+	cdone <- true
 }
 
 func TestMutex(t *testing.T) {
-	m := new(Mutex);
-	c := make(chan bool);
+	m := new(Mutex)
+	c := make(chan bool)
 	for i := 0; i < 10; i++ {
 		go HammerMutex(m, 1000, c)
 	}
@@ -73,19 +73,19 @@ func TestMutex(t *testing.T) {
 }
 
 func BenchmarkUncontendedMutex(b *testing.B) {
-	m := new(Mutex);
-	HammerMutex(m, b.N, make(chan bool, 2));
+	m := new(Mutex)
+	HammerMutex(m, b.N, make(chan bool, 2))
 }
 
 func BenchmarkContendedMutex(b *testing.B) {
-	b.StopTimer();
-	m := new(Mutex);
-	c := make(chan bool);
-	runtime.GOMAXPROCS(2);
-	b.StartTimer();
+	b.StopTimer()
+	m := new(Mutex)
+	c := make(chan bool)
+	runtime.GOMAXPROCS(2)
+	b.StartTimer()
 
-	go HammerMutex(m, b.N/2, c);
-	go HammerMutex(m, b.N/2, c);
-	<-c;
-	<-c;
+	go HammerMutex(m, b.N/2, c)
+	go HammerMutex(m, b.N/2, c)
+	<-c
+	<-c
 }
diff --git a/src/pkg/sync/rwmutex.go b/src/pkg/sync/rwmutex.go
index b5e2b55c0d..0058cf2525 100644
--- a/src/pkg/sync/rwmutex.go
+++ b/src/pkg/sync/rwmutex.go
@@ -14,9 +14,9 @@ package sync
 // Writers take priority over Readers: no new RLocks
 // are granted while a blocked Lock call is waiting.
 type RWMutex struct {
-	w		Mutex;	// held if there are pending readers or writers
-	r		Mutex;	// held if the w is being rd
-	readerCount	uint32;	// number of pending readers
+	w           Mutex  // held if there are pending readers or writers
+	r           Mutex  // held if the w is being rd
+	readerCount uint32 // number of pending readers
 }
 
 // RLock locks rw for reading.
@@ -32,13 +32,13 @@ func (rw *RWMutex) RLock() {
 	//   C: rw.RLock()  // granted
 	//   B: rw.RUnlock()
 	//   ... (new readers come and go indefinitely, W is starving)
-	rw.r.Lock();
+	rw.r.Lock()
 	if xadd(&rw.readerCount, 1) == 1 {
 		// The first reader locks rw.w, so writers will be blocked
 		// while the readers have the RLock.
 		rw.w.Lock()
 	}
-	rw.r.Unlock();
+	rw.r.Unlock()
 }
 
 // RUnlock undoes a single RLock call;
@@ -59,9 +59,9 @@ func (rw *RWMutex) RUnlock() {
 // a blocked Lock call excludes new readers from acquiring
 // the lock.
 func (rw *RWMutex) Lock() {
-	rw.r.Lock();
-	rw.w.Lock();
-	rw.r.Unlock();
+	rw.r.Lock()
+	rw.w.Lock()
+	rw.r.Unlock()
 }
 
 // Unlock unlocks rw for writing.
@@ -72,4 +72,4 @@ func (rw *RWMutex) Lock() {
 // a locked RWMutex is not associated with a particular goroutine.
 // It is allowed for one goroutine to RLock (Lock) an RWMutex and then
 // arrange for another goroutine to RUnlock (Unlock) it.
-func (rw *RWMutex) Unlock()	{ rw.w.Unlock() }
+func (rw *RWMutex) Unlock() { rw.w.Unlock() }
diff --git a/src/pkg/sync/rwmutex_test.go b/src/pkg/sync/rwmutex_test.go
index ad35608004..111bca1e38 100644
--- a/src/pkg/sync/rwmutex_test.go
+++ b/src/pkg/sync/rwmutex_test.go
@@ -7,26 +7,26 @@
 package sync_test
 
 import (
-	"fmt";
-	"runtime";
-	. "sync";
-	"testing";
+	"fmt"
+	"runtime"
+	. "sync"
+	"testing"
 )
 
 func parallelReader(m *RWMutex, clocked, cunlock, cdone chan bool) {
-	m.RLock();
-	clocked <- true;
-	<-cunlock;
-	m.RUnlock();
-	cdone <- true;
+	m.RLock()
+	clocked <- true
+	<-cunlock
+	m.RUnlock()
+	cdone <- true
 }
 
 func doTestParallelReaders(numReaders, gomaxprocs int) {
-	runtime.GOMAXPROCS(gomaxprocs);
-	var m RWMutex;
-	clocked := make(chan bool);
-	cunlock := make(chan bool);
-	cdone := make(chan bool);
+	runtime.GOMAXPROCS(gomaxprocs)
+	var m RWMutex
+	clocked := make(chan bool)
+	cunlock := make(chan bool)
+	cdone := make(chan bool)
 	for i := 0; i < numReaders; i++ {
 		go parallelReader(&m, clocked, cunlock, cdone)
 	}
@@ -44,53 +44,53 @@ func doTestParallelReaders(numReaders, gomaxprocs int) {
 }
 
 func TestParallelReaders(t *testing.T) {
-	doTestParallelReaders(1, 4);
-	doTestParallelReaders(3, 4);
-	doTestParallelReaders(4, 2);
+	doTestParallelReaders(1, 4)
+	doTestParallelReaders(3, 4)
+	doTestParallelReaders(4, 2)
 }
 
 func reader(rwm *RWMutex, num_iterations int, activity *uint32, cdone chan bool) {
 	for i := 0; i < num_iterations; i++ {
-		rwm.RLock();
-		n := Xadd(activity, 1);
+		rwm.RLock()
+		n := Xadd(activity, 1)
 		if n < 1 || n >= 10000 {
 			panic(fmt.Sprintf("wlock(%d)\n", n))
 		}
 		for i := 0; i < 100; i++ {
 		}
-		Xadd(activity, -1);
-		rwm.RUnlock();
+		Xadd(activity, -1)
+		rwm.RUnlock()
 	}
-	cdone <- true;
+	cdone <- true
 }
 
 func writer(rwm *RWMutex, num_iterations int, activity *uint32, cdone chan bool) {
 	for i := 0; i < num_iterations; i++ {
-		rwm.Lock();
-		n := Xadd(activity, 10000);
+		rwm.Lock()
+		n := Xadd(activity, 10000)
 		if n != 10000 {
 			panic(fmt.Sprintf("wlock(%d)\n", n))
 		}
 		for i := 0; i < 100; i++ {
 		}
-		Xadd(activity, -10000);
-		rwm.Unlock();
+		Xadd(activity, -10000)
+		rwm.Unlock()
 	}
-	cdone <- true;
+	cdone <- true
 }
 
 func HammerRWMutex(gomaxprocs, numReaders, num_iterations int) {
-	runtime.GOMAXPROCS(gomaxprocs);
+	runtime.GOMAXPROCS(gomaxprocs)
 	// Number of active readers + 10000 * number of active writers.
-	var activity uint32;
-	var rwm RWMutex;
-	cdone := make(chan bool);
-	go writer(&rwm, num_iterations, &activity, cdone);
-	var i int;
+	var activity uint32
+	var rwm RWMutex
+	cdone := make(chan bool)
+	go writer(&rwm, num_iterations, &activity, cdone)
+	var i int
 	for i = 0; i < numReaders/2; i++ {
 		go reader(&rwm, num_iterations, &activity, cdone)
 	}
-	go writer(&rwm, num_iterations, &activity, cdone);
+	go writer(&rwm, num_iterations, &activity, cdone)
 	for ; i < numReaders; i++ {
 		go reader(&rwm, num_iterations, &activity, cdone)
 	}
@@ -101,14 +101,14 @@ func HammerRWMutex(gomaxprocs, numReaders, num_iterations int) {
 }
 
 func TestRWMutex(t *testing.T) {
-	HammerRWMutex(1, 1, 1000);
-	HammerRWMutex(1, 3, 1000);
-	HammerRWMutex(1, 10, 1000);
-	HammerRWMutex(4, 1, 1000);
-	HammerRWMutex(4, 3, 1000);
-	HammerRWMutex(4, 10, 1000);
-	HammerRWMutex(10, 1, 1000);
-	HammerRWMutex(10, 3, 1000);
-	HammerRWMutex(10, 10, 1000);
-	HammerRWMutex(10, 5, 10000);
+	HammerRWMutex(1, 1, 1000)
+	HammerRWMutex(1, 3, 1000)
+	HammerRWMutex(1, 10, 1000)
+	HammerRWMutex(4, 1, 1000)
+	HammerRWMutex(4, 3, 1000)
+	HammerRWMutex(4, 10, 1000)
+	HammerRWMutex(10, 1, 1000)
+	HammerRWMutex(10, 3, 1000)
+	HammerRWMutex(10, 10, 1000)
+	HammerRWMutex(10, 5, 10000)
 }
diff --git a/src/pkg/syscall/errstr.go b/src/pkg/syscall/errstr.go
index 87c354d050..94a799a801 100644
--- a/src/pkg/syscall/errstr.go
+++ b/src/pkg/syscall/errstr.go
@@ -5,24 +5,24 @@
 package syscall
 
 
-func str(val int) string {	// do it here rather than with fmt to avoid dependency
+func str(val int) string { // do it here rather than with fmt to avoid dependency
 	if val < 0 {
 		return "-" + str(-val)
 	}
-	var buf [32]byte;	// big enough for int64
-	i := len(buf) - 1;
+	var buf [32]byte // big enough for int64
+	i := len(buf) - 1
 	for val >= 10 {
-		buf[i] = byte(val%10 + '0');
-		i--;
-		val /= 10;
+		buf[i] = byte(val%10 + '0')
+		i--
+		val /= 10
 	}
-	buf[i] = byte(val + '0');
-	return string(buf[i:]);
+	buf[i] = byte(val + '0')
+	return string(buf[i:])
 }
 
 func Errstr(errno int) string {
 	if errno < 0 || errno >= int(len(errors)) {
 		return "error " + str(errno)
 	}
-	return errors[errno];
+	return errors[errno]
 }
diff --git a/src/pkg/syscall/exec.go b/src/pkg/syscall/exec.go
index a3be959bd5..3418ff0888 100644
--- a/src/pkg/syscall/exec.go
+++ b/src/pkg/syscall/exec.go
@@ -7,8 +7,8 @@
 package syscall
 
 import (
-	"sync";
-	"unsafe";
+	"sync"
+	"unsafe"
 )
 
 // Lock synchronizing creation of new file descriptors with fork.
@@ -63,18 +63,18 @@ var ForkLock sync.RWMutex
 // Convert array of string to array
 // of NUL-terminated byte pointer.
 func StringArrayPtr(ss []string) []*byte {
-	bb := make([]*byte, len(ss)+1);
+	bb := make([]*byte, len(ss)+1)
 	for i := 0; i < len(ss); i++ {
 		bb[i] = StringBytePtr(ss[i])
 	}
-	bb[len(ss)] = nil;
-	return bb;
+	bb[len(ss)] = nil
+	return bb
 }
 
-func CloseOnExec(fd int)	{ fcntl(fd, F_SETFD, FD_CLOEXEC) }
+func CloseOnExec(fd int) { fcntl(fd, F_SETFD, FD_CLOEXEC) }
 
 func SetNonblock(fd int, nonblocking bool) (errno int) {
-	flag, err := fcntl(fd, F_GETFL, 0);
+	flag, err := fcntl(fd, F_GETFL, 0)
 	if err != 0 {
 		return err
 	}
@@ -83,8 +83,8 @@ func SetNonblock(fd int, nonblocking bool) (errno int) {
 	} else {
 		flag &= ^O_NONBLOCK
 	}
-	_, err = fcntl(fd, F_SETFL, flag);
-	return err;
+	_, err = fcntl(fd, F_SETFL, flag)
+	return err
 }
 
 
@@ -99,15 +99,15 @@ func SetNonblock(fd int, nonblocking bool) (errno int) {
 func forkAndExecInChild(argv0 *byte, argv []*byte, envv []*byte, traceme bool, dir *byte, fd []int, pipe int) (pid int, err int) {
 	// Declare all variables at top in case any
 	// declarations require heap allocation (e.g., err1).
-	var r1, r2, err1 uintptr;
-	var nextfd int;
-	var i int;
+	var r1, r2, err1 uintptr
+	var nextfd int
+	var i int
 
-	darwin := OS == "darwin";
+	darwin := OS == "darwin"
 
 	// About to call fork.
 	// No more allocation or calls of non-assembly functions.
-	r1, r2, err1 = RawSyscall(SYS_FORK, 0, 0, 0);
+	r1, r2, err1 = RawSyscall(SYS_FORK, 0, 0, 0)
 	if err1 != 0 {
 		return 0, int(err1)
 	}
@@ -129,7 +129,7 @@ func forkAndExecInChild(argv0 *byte, argv []*byte, envv []*byte, traceme bool, d
 
 	// Enable tracing if requested.
 	if traceme {
-		_, _, err1 = RawSyscall(SYS_PTRACE, uintptr(PTRACE_TRACEME), 0, 0);
+		_, _, err1 = RawSyscall(SYS_PTRACE, uintptr(PTRACE_TRACEME), 0, 0)
 		if err1 != 0 {
 			goto childerror
 		}
@@ -137,7 +137,7 @@ func forkAndExecInChild(argv0 *byte, argv []*byte, envv []*byte, traceme bool, d
 
 	// Chdir
 	if dir != nil {
-		_, _, err1 = RawSyscall(SYS_CHDIR, uintptr(unsafe.Pointer(dir)), 0, 0);
+		_, _, err1 = RawSyscall(SYS_CHDIR, uintptr(unsafe.Pointer(dir)), 0, 0)
 		if err1 != 0 {
 			goto childerror
 		}
@@ -145,26 +145,26 @@ func forkAndExecInChild(argv0 *byte, argv []*byte, envv []*byte, traceme bool, d
 
 	// Pass 1: look for fd[i] < i and move those up above len(fd)
 	// so that pass 2 won't stomp on an fd it needs later.
-	nextfd = int(len(fd));
+	nextfd = int(len(fd))
 	if pipe < nextfd {
-		_, _, err1 = RawSyscall(SYS_DUP2, uintptr(pipe), uintptr(nextfd), 0);
+		_, _, err1 = RawSyscall(SYS_DUP2, uintptr(pipe), uintptr(nextfd), 0)
 		if err1 != 0 {
 			goto childerror
 		}
-		RawSyscall(SYS_FCNTL, uintptr(nextfd), F_SETFD, FD_CLOEXEC);
-		pipe = nextfd;
-		nextfd++;
+		RawSyscall(SYS_FCNTL, uintptr(nextfd), F_SETFD, FD_CLOEXEC)
+		pipe = nextfd
+		nextfd++
 	}
 	for i = 0; i < len(fd); i++ {
 		if fd[i] >= 0 && fd[i] < int(i) {
-			_, _, err1 = RawSyscall(SYS_DUP2, uintptr(fd[i]), uintptr(nextfd), 0);
+			_, _, err1 = RawSyscall(SYS_DUP2, uintptr(fd[i]), uintptr(nextfd), 0)
 			if err1 != 0 {
 				goto childerror
 			}
-			RawSyscall(SYS_FCNTL, uintptr(nextfd), F_SETFD, FD_CLOEXEC);
-			fd[i] = nextfd;
-			nextfd++;
-			if nextfd == pipe {	// don't stomp on pipe
+			RawSyscall(SYS_FCNTL, uintptr(nextfd), F_SETFD, FD_CLOEXEC)
+			fd[i] = nextfd
+			nextfd++
+			if nextfd == pipe { // don't stomp on pipe
 				nextfd++
 			}
 		}
@@ -173,21 +173,21 @@ func forkAndExecInChild(argv0 *byte, argv []*byte, envv []*byte, traceme bool, d
 	// Pass 2: dup fd[i] down onto i.
 	for i = 0; i < len(fd); i++ {
 		if fd[i] == -1 {
-			RawSyscall(SYS_CLOSE, uintptr(i), 0, 0);
-			continue;
+			RawSyscall(SYS_CLOSE, uintptr(i), 0, 0)
+			continue
 		}
 		if fd[i] == int(i) {
 			// dup2(i, i) won't clear close-on-exec flag on Linux,
 			// probably not elsewhere either.
-			_, _, err1 = RawSyscall(SYS_FCNTL, uintptr(fd[i]), F_SETFD, 0);
+			_, _, err1 = RawSyscall(SYS_FCNTL, uintptr(fd[i]), F_SETFD, 0)
 			if err1 != 0 {
 				goto childerror
 			}
-			continue;
+			continue
 		}
 		// The new fd is created NOT close-on-exec,
 		// which is exactly what we want.
-		_, _, err1 = RawSyscall(SYS_DUP2, uintptr(fd[i]), uintptr(i), 0);
+		_, _, err1 = RawSyscall(SYS_DUP2, uintptr(fd[i]), uintptr(i), 0)
 		if err1 != 0 {
 			goto childerror
 		}
@@ -205,11 +205,11 @@ func forkAndExecInChild(argv0 *byte, argv []*byte, envv []*byte, traceme bool, d
 	_, _, err1 = RawSyscall(SYS_EXECVE,
 		uintptr(unsafe.Pointer(argv0)),
 		uintptr(unsafe.Pointer(&argv[0])),
-		uintptr(unsafe.Pointer(&envv[0])));
+		uintptr(unsafe.Pointer(&envv[0])))
 
 childerror:
 	// send error code on pipe
-	RawSyscall(SYS_WRITE, uintptr(pipe), uintptr(unsafe.Pointer(&err1)), uintptr(unsafe.Sizeof(err1)));
+	RawSyscall(SYS_WRITE, uintptr(pipe), uintptr(unsafe.Pointer(&err1)), uintptr(unsafe.Sizeof(err1)))
 	for {
 		RawSyscall(SYS_EXIT, 253, 0, 0)
 	}
@@ -217,23 +217,23 @@ childerror:
 	// Calling panic is not actually safe,
 	// but the for loop above won't break
 	// and this shuts up the compiler.
-	panic("unreached");
+	panic("unreached")
 }
 
 func forkExec(argv0 string, argv []string, envv []string, traceme bool, dir string, fd []int) (pid int, err int) {
-	var p [2]int;
-	var n int;
-	var err1 uintptr;
-	var wstatus WaitStatus;
+	var p [2]int
+	var n int
+	var err1 uintptr
+	var wstatus WaitStatus
 
-	p[0] = -1;
-	p[1] = -1;
+	p[0] = -1
+	p[1] = -1
 
 	// Convert args to C form.
-	argv0p := StringBytePtr(argv0);
-	argvp := StringArrayPtr(argv);
-	envvp := StringArrayPtr(envv);
-	var dirp *byte;
+	argv0p := StringBytePtr(argv0)
+	argvp := StringArrayPtr(argv)
+	envvp := StringArrayPtr(envv)
+	var dirp *byte
 	if len(dir) > 0 {
 		dirp = StringBytePtr(dir)
 	}
@@ -241,7 +241,7 @@ func forkExec(argv0 string, argv []string, envv []string, traceme bool, dir stri
 	// Acquire the fork lock so that no other threads
 	// create new fds that are not yet close-on-exec
 	// before we fork.
-	ForkLock.Lock();
+	ForkLock.Lock()
 
 	// Allocate child status pipe close on exec.
 	if err = Pipe(&p); err != 0 {
@@ -255,22 +255,22 @@ func forkExec(argv0 string, argv []string, envv []string, traceme bool, dir stri
 	}
 
 	// Kick off child.
-	pid, err = forkAndExecInChild(argv0p, argvp, envvp, traceme, dirp, fd, p[1]);
+	pid, err = forkAndExecInChild(argv0p, argvp, envvp, traceme, dirp, fd, p[1])
 	if err != 0 {
 	error:
 		if p[0] >= 0 {
-			Close(p[0]);
-			Close(p[1]);
+			Close(p[0])
+			Close(p[1])
 		}
-		ForkLock.Unlock();
-		return 0, err;
+		ForkLock.Unlock()
+		return 0, err
 	}
-	ForkLock.Unlock();
+	ForkLock.Unlock()
 
 	// Read child error status from pipe.
-	Close(p[1]);
-	n, err = read(p[0], (*byte)(unsafe.Pointer(&err1)), unsafe.Sizeof(err1));
-	Close(p[0]);
+	Close(p[1])
+	n, err = read(p[0], (*byte)(unsafe.Pointer(&err1)), unsafe.Sizeof(err1))
+	Close(p[0])
 	if err != 0 || n != 0 {
 		if n == unsafe.Sizeof(err1) {
 			err = int(err1)
@@ -281,15 +281,15 @@ func forkExec(argv0 string, argv []string, envv []string, traceme bool, dir stri
 
 		// Child failed; wait for it to exit, to make sure
 		// the zombies don't accumulate.
-		_, err1 := Wait4(pid, &wstatus, 0, nil);
+		_, err1 := Wait4(pid, &wstatus, 0, nil)
 		for err1 == EINTR {
 			_, err1 = Wait4(pid, &wstatus, 0, nil)
 		}
-		return 0, err;
+		return 0, err
 	}
 
 	// Read got EOF, so pipe closed on exec, so exec succeeded.
-	return pid, 0;
+	return pid, 0
 }
 
 // Combination of fork and exec, careful to be thread safe.
@@ -307,6 +307,6 @@ func Exec(argv0 string, argv []string, envv []string) (err int) {
 	_, _, err1 := RawSyscall(SYS_EXECVE,
 		uintptr(unsafe.Pointer(StringBytePtr(argv0))),
 		uintptr(unsafe.Pointer(&StringArrayPtr(argv)[0])),
-		uintptr(unsafe.Pointer(&StringArrayPtr(envv)[0])));
-	return int(err1);
+		uintptr(unsafe.Pointer(&StringArrayPtr(envv)[0])))
+	return int(err1)
 }
diff --git a/src/pkg/syscall/syscall.go b/src/pkg/syscall/syscall.go
index 06f3635d68..372149bf2c 100644
--- a/src/pkg/syscall/syscall.go
+++ b/src/pkg/syscall/syscall.go
@@ -18,13 +18,13 @@ func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr)
 // StringByteSlice returns a NUL-terminated slice of bytes
 // containing the text of s.
 func StringByteSlice(s string) []byte {
-	a := make([]byte, len(s)+1);
+	a := make([]byte, len(s)+1)
 	for i := 0; i < len(s); i++ {
 		a[i] = s[i]
 	}
-	return a;
+	return a
 }
 
 // StringBytePtr returns a pointer to a NUL-terminated array of bytes
 // containing the text of s.
-func StringBytePtr(s string) *byte	{ return &StringByteSlice(s)[0] }
+func StringBytePtr(s string) *byte { return &StringByteSlice(s)[0] }
diff --git a/src/pkg/syscall/syscall_darwin.go b/src/pkg/syscall/syscall_darwin.go
index bb28bc1e97..20f9fa24e4 100644
--- a/src/pkg/syscall/syscall_darwin.go
+++ b/src/pkg/syscall/syscall_darwin.go
@@ -23,7 +23,7 @@ const OS = "darwin"
 // even linking this function into the binary.  See ../os/getwd.go.
 const ImplementsGetwd = false
 
-func Getwd() (string, int)	{ return "", ENOTSUP }
+func Getwd() (string, int) { return "", ENOTSUP }
 
 
 /*
@@ -34,7 +34,7 @@ func Getwd() (string, int)	{ return "", ENOTSUP }
 //sys	setgroups(ngid int, gid *_Gid_t) (errno int)
 
 func Getgroups() (gids []int, errno int) {
-	n, err := getgroups(0, nil);
+	n, err := getgroups(0, nil)
 	if err != 0 {
 		return nil, errno
 	}
@@ -47,16 +47,16 @@ func Getgroups() (gids []int, errno int) {
 		return nil, EINVAL
 	}
 
-	a := make([]_Gid_t, n);
-	n, err = getgroups(n, &a[0]);
+	a := make([]_Gid_t, n)
+	n, err = getgroups(n, &a[0])
 	if err != 0 {
 		return nil, errno
 	}
-	gids = make([]int, n);
+	gids = make([]int, n)
 	for i, v := range a[0:n] {
 		gids[i] = int(v)
 	}
-	return;
+	return
 }
 
 func Setgroups(gids []int) (errno int) {
@@ -64,11 +64,11 @@ func Setgroups(gids []int) (errno int) {
 		return setgroups(0, nil)
 	}
 
-	a := make([]_Gid_t, len(gids));
+	a := make([]_Gid_t, len(gids))
 	for i, v := range gids {
 		a[i] = _Gid_t(v)
 	}
-	return setgroups(len(a), &a[0]);
+	return setgroups(len(a), &a[0])
 }
 
 // Wait status is 7 bits at bottom, either 0 (exited),
@@ -80,44 +80,44 @@ func Setgroups(gids []int) (errno int) {
 type WaitStatus uint32
 
 const (
-	mask	= 0x7F;
-	core	= 0x80;
-	shift	= 8;
+	mask  = 0x7F
+	core  = 0x80
+	shift = 8
 
-	exited	= 0;
-	stopped	= 0x7F;
+	exited  = 0
+	stopped = 0x7F
 )
 
-func (w WaitStatus) Exited() bool	{ return w&mask == exited }
+func (w WaitStatus) Exited() bool { return w&mask == exited }
 
 func (w WaitStatus) ExitStatus() int {
 	if w&mask != exited {
 		return -1
 	}
-	return int(w >> shift);
+	return int(w >> shift)
 }
 
-func (w WaitStatus) Signaled() bool	{ return w&mask != stopped && w&mask != 0 }
+func (w WaitStatus) Signaled() bool { return w&mask != stopped && w&mask != 0 }
 
 func (w WaitStatus) Signal() int {
-	sig := int(w & mask);
+	sig := int(w & mask)
 	if sig == stopped || sig == 0 {
 		return -1
 	}
-	return sig;
+	return sig
 }
 
-func (w WaitStatus) CoreDump() bool	{ return w.Signaled() && w&core != 0 }
+func (w WaitStatus) CoreDump() bool { return w.Signaled() && w&core != 0 }
 
-func (w WaitStatus) Stopped() bool	{ return w&mask == stopped && w>>shift != SIGSTOP }
+func (w WaitStatus) Stopped() bool { return w&mask == stopped && w>>shift != SIGSTOP }
 
-func (w WaitStatus) Continued() bool	{ return w&mask == stopped && w>>shift == SIGSTOP }
+func (w WaitStatus) Continued() bool { return w&mask == stopped && w>>shift == SIGSTOP }
 
 func (w WaitStatus) StopSignal() int {
 	if !w.Stopped() {
 		return -1
 	}
-	return int(w>>shift) & 0xFF;
+	return int(w>>shift) & 0xFF
 }
 
 func (w WaitStatus) TrapCause() int {
@@ -128,12 +128,12 @@ func (w WaitStatus) TrapCause() int {
 //sys	wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, errno int)
 
 func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, errno int) {
-	var status _C_int;
-	wpid, errno = wait4(pid, &status, options, rusage);
+	var status _C_int
+	wpid, errno = wait4(pid, &status, options, rusage)
 	if wstatus != nil {
 		*wstatus = WaitStatus(status)
 	}
-	return;
+	return
 }
 
 //sys	pipe() (r int, w int, errno int)
@@ -142,13 +142,13 @@ func Pipe(p []int) (errno int) {
 	if len(p) != 2 {
 		return EINVAL
 	}
-	p[0], p[1], errno = pipe();
-	return;
+	p[0], p[1], errno = pipe()
+	return
 }
 
 func Sleep(ns int64) (errno int) {
-	tv := NsecToTimeval(ns);
-	return Select(0, nil, nil, nil, &tv);
+	tv := NsecToTimeval(ns)
+	return Select(0, nil, nil, nil, &tv)
 }
 
 //sys	accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, errno int)
@@ -165,173 +165,173 @@ func Sleep(ns int64) (errno int) {
 var SocketDisableIPv6 bool
 
 type Sockaddr interface {
-	sockaddr() (ptr uintptr, len _Socklen, errno int);	// lowercase; only we can define Sockaddrs
+	sockaddr() (ptr uintptr, len _Socklen, errno int) // lowercase; only we can define Sockaddrs
 }
 
 type SockaddrInet4 struct {
-	Port	int;
-	Addr	[4]byte;
-	raw	RawSockaddrInet4;
+	Port int
+	Addr [4]byte
+	raw  RawSockaddrInet4
 }
 
 func (sa *SockaddrInet4) sockaddr() (uintptr, _Socklen, int) {
 	if sa.Port < 0 || sa.Port > 0xFFFF {
 		return 0, 0, EINVAL
 	}
-	sa.raw.Len = SizeofSockaddrInet4;
-	sa.raw.Family = AF_INET;
-	p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port));
-	p[0] = byte(sa.Port >> 8);
-	p[1] = byte(sa.Port);
+	sa.raw.Len = SizeofSockaddrInet4
+	sa.raw.Family = AF_INET
+	p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port))
+	p[0] = byte(sa.Port >> 8)
+	p[1] = byte(sa.Port)
 	for i := 0; i < len(sa.Addr); i++ {
 		sa.raw.Addr[i] = sa.Addr[i]
 	}
-	return uintptr(unsafe.Pointer(&sa.raw)), _Socklen(sa.raw.Len), 0;
+	return uintptr(unsafe.Pointer(&sa.raw)), _Socklen(sa.raw.Len), 0
 }
 
 type SockaddrInet6 struct {
-	Port	int;
-	Addr	[16]byte;
-	raw	RawSockaddrInet6;
+	Port int
+	Addr [16]byte
+	raw  RawSockaddrInet6
 }
 
 func (sa *SockaddrInet6) sockaddr() (uintptr, _Socklen, int) {
 	if sa.Port < 0 || sa.Port > 0xFFFF {
 		return 0, 0, EINVAL
 	}
-	sa.raw.Len = SizeofSockaddrInet6;
-	sa.raw.Family = AF_INET6;
-	p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port));
-	p[0] = byte(sa.Port >> 8);
-	p[1] = byte(sa.Port);
+	sa.raw.Len = SizeofSockaddrInet6
+	sa.raw.Family = AF_INET6
+	p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port))
+	p[0] = byte(sa.Port >> 8)
+	p[1] = byte(sa.Port)
 	for i := 0; i < len(sa.Addr); i++ {
 		sa.raw.Addr[i] = sa.Addr[i]
 	}
-	return uintptr(unsafe.Pointer(&sa.raw)), _Socklen(sa.raw.Len), 0;
+	return uintptr(unsafe.Pointer(&sa.raw)), _Socklen(sa.raw.Len), 0
 }
 
 type SockaddrUnix struct {
-	Name	string;
-	raw	RawSockaddrUnix;
+	Name string
+	raw  RawSockaddrUnix
 }
 
 func (sa *SockaddrUnix) sockaddr() (uintptr, _Socklen, int) {
-	name := sa.Name;
-	n := len(name);
+	name := sa.Name
+	n := len(name)
 	if n >= len(sa.raw.Path) || n == 0 {
 		return 0, 0, EINVAL
 	}
-	sa.raw.Len = byte(3 + n);	// 2 for Family, Len; 1 for NUL
-	sa.raw.Family = AF_UNIX;
+	sa.raw.Len = byte(3 + n) // 2 for Family, Len; 1 for NUL
+	sa.raw.Family = AF_UNIX
 	for i := 0; i < n; i++ {
 		sa.raw.Path[i] = int8(name[i])
 	}
-	return uintptr(unsafe.Pointer(&sa.raw)), _Socklen(sa.raw.Len), 0;
+	return uintptr(unsafe.Pointer(&sa.raw)), _Socklen(sa.raw.Len), 0
 }
 
 func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, int) {
 	switch rsa.Addr.Family {
 	case AF_UNIX:
-		pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa));
+		pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))
 		if pp.Len < 3 || pp.Len > SizeofSockaddrUnix {
 			return nil, EINVAL
 		}
-		sa := new(SockaddrUnix);
-		n := int(pp.Len) - 3;	// subtract leading Family, Len, terminating NUL
+		sa := new(SockaddrUnix)
+		n := int(pp.Len) - 3 // subtract leading Family, Len, terminating NUL
 		for i := 0; i < n; i++ {
 			if pp.Path[i] == 0 {
 				// found early NUL; assume Len is overestimating
-				n = i;
-				break;
+				n = i
+				break
 			}
 		}
-		bytes := (*[len(pp.Path)]byte)(unsafe.Pointer(&pp.Path[0]));
-		sa.Name = string(bytes[0:n]);
-		return sa, 0;
+		bytes := (*[len(pp.Path)]byte)(unsafe.Pointer(&pp.Path[0]))
+		sa.Name = string(bytes[0:n])
+		return sa, 0
 
 	case AF_INET:
-		pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa));
-		sa := new(SockaddrInet4);
-		p := (*[2]byte)(unsafe.Pointer(&pp.Port));
-		sa.Port = int(p[0])<<8 + int(p[1]);
+		pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))
+		sa := new(SockaddrInet4)
+		p := (*[2]byte)(unsafe.Pointer(&pp.Port))
+		sa.Port = int(p[0])<<8 + int(p[1])
 		for i := 0; i < len(sa.Addr); i++ {
 			sa.Addr[i] = pp.Addr[i]
 		}
-		return sa, 0;
+		return sa, 0
 
 	case AF_INET6:
-		pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa));
-		sa := new(SockaddrInet6);
-		p := (*[2]byte)(unsafe.Pointer(&pp.Port));
-		sa.Port = int(p[0])<<8 + int(p[1]);
+		pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))
+		sa := new(SockaddrInet6)
+		p := (*[2]byte)(unsafe.Pointer(&pp.Port))
+		sa.Port = int(p[0])<<8 + int(p[1])
 		for i := 0; i < len(sa.Addr); i++ {
 			sa.Addr[i] = pp.Addr[i]
 		}
-		return sa, 0;
+		return sa, 0
 	}
-	return nil, EAFNOSUPPORT;
+	return nil, EAFNOSUPPORT
 }
 
 func Accept(fd int) (nfd int, sa Sockaddr, errno int) {
-	var rsa RawSockaddrAny;
-	var len _Socklen = SizeofSockaddrAny;
-	nfd, errno = accept(fd, &rsa, &len);
+	var rsa RawSockaddrAny
+	var len _Socklen = SizeofSockaddrAny
+	nfd, errno = accept(fd, &rsa, &len)
 	if errno != 0 {
 		return
 	}
-	sa, errno = anyToSockaddr(&rsa);
+	sa, errno = anyToSockaddr(&rsa)
 	if errno != 0 {
-		Close(nfd);
-		nfd = 0;
+		Close(nfd)
+		nfd = 0
 	}
-	return;
+	return
 }
 
 func Getsockname(fd int) (sa Sockaddr, errno int) {
-	var rsa RawSockaddrAny;
-	var len _Socklen = SizeofSockaddrAny;
+	var rsa RawSockaddrAny
+	var len _Socklen = SizeofSockaddrAny
 	if errno = getsockname(fd, &rsa, &len); errno != 0 {
 		return
 	}
-	return anyToSockaddr(&rsa);
+	return anyToSockaddr(&rsa)
 }
 
 func Getpeername(fd int) (sa Sockaddr, errno int) {
-	var rsa RawSockaddrAny;
-	var len _Socklen = SizeofSockaddrAny;
+	var rsa RawSockaddrAny
+	var len _Socklen = SizeofSockaddrAny
 	if errno = getpeername(fd, &rsa, &len); errno != 0 {
 		return
 	}
-	return anyToSockaddr(&rsa);
+	return anyToSockaddr(&rsa)
 }
 
 func Bind(fd int, sa Sockaddr) (errno int) {
-	ptr, n, err := sa.sockaddr();
+	ptr, n, err := sa.sockaddr()
 	if err != 0 {
 		return err
 	}
-	return bind(fd, ptr, n);
+	return bind(fd, ptr, n)
 }
 
 func Connect(fd int, sa Sockaddr) (errno int) {
-	ptr, n, err := sa.sockaddr();
+	ptr, n, err := sa.sockaddr()
 	if err != 0 {
 		return err
 	}
-	return connect(fd, ptr, n);
+	return connect(fd, ptr, n)
 }
 
 func Socket(domain, typ, proto int) (fd, errno int) {
 	if domain == AF_INET6 && SocketDisableIPv6 {
 		return -1, EAFNOSUPPORT
 	}
-	fd, errno = socket(domain, typ, proto);
-	return;
+	fd, errno = socket(domain, typ, proto)
+	return
 }
 
 func SetsockoptInt(fd, level, opt int, value int) (errno int) {
-	var n = int32(value);
-	return setsockopt(fd, level, opt, uintptr(unsafe.Pointer(&n)), 4);
+	var n = int32(value)
+	return setsockopt(fd, level, opt, uintptr(unsafe.Pointer(&n)), 4)
 }
 
 func SetsockoptTimeval(fd, level, opt int, tv *Timeval) (errno int) {
@@ -346,44 +346,44 @@ func SetsockoptLinger(fd, level, opt int, l *Linger) (errno int) {
 //sys recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, errno int)
 
 func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, errno int) {
-	var rsa RawSockaddrAny;
-	var len _Socklen = SizeofSockaddrAny;
+	var rsa RawSockaddrAny
+	var len _Socklen = SizeofSockaddrAny
 	if n, errno = recvfrom(fd, p, flags, &rsa, &len); errno != 0 {
 		return
 	}
-	from, errno = anyToSockaddr(&rsa);
-	return;
+	from, errno = anyToSockaddr(&rsa)
+	return
 }
 
 //sys sendto(s int, buf []byte, flags int, to uintptr, addrlen _Socklen) (errno int)
 
 func Sendto(fd int, p []byte, flags int, to Sockaddr) (errno int) {
-	ptr, n, err := to.sockaddr();
+	ptr, n, err := to.sockaddr()
 	if err != 0 {
 		return err
 	}
-	return sendto(fd, p, flags, ptr, n);
+	return sendto(fd, p, flags, ptr, n)
 }
 
 //sys	kevent(kq int, change uintptr, nchange int, event uintptr, nevent int, timeout *Timespec) (n int, errno int)
 
 func Kevent(kq int, changes, events []Kevent_t, timeout *Timespec) (n int, errno int) {
-	var change, event uintptr;
+	var change, event uintptr
 	if len(changes) > 0 {
 		change = uintptr(unsafe.Pointer(&changes[0]))
 	}
 	if len(events) > 0 {
 		event = uintptr(unsafe.Pointer(&events[0]))
 	}
-	return kevent(kq, change, len(changes), event, len(events), timeout);
+	return kevent(kq, change, len(changes), event, len(events), timeout)
 }
 
 //sys	sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (errno int) = SYS___SYSCTL
 
 // Translate "kern.hostname" to []_C_int{0,1,2,3}.
 func nametomib(name string) (mib []_C_int, errno int) {
-	const CTL_MAXNAME = 12;
-	const siz = uintptr(unsafe.Sizeof(mib[0]));
+	const CTL_MAXNAME = 12
+	const siz = uintptr(unsafe.Sizeof(mib[0]))
 
 	// NOTE(rsc): It seems strange to set the buffer to have
 	// size CTL_MAXNAME+2 but use only CTL_MAXNAME
@@ -392,29 +392,29 @@ func nametomib(name string) (mib []_C_int, errno int) {
 	// I am scared that if we don't include the +2 here, the kernel
 	// will silently write 2 words farther than we specify
 	// and we'll get memory corruption.
-	var buf [CTL_MAXNAME + 2]_C_int;
-	n := uintptr(CTL_MAXNAME) * siz;
+	var buf [CTL_MAXNAME + 2]_C_int
+	n := uintptr(CTL_MAXNAME) * siz
 
-	p := (*byte)(unsafe.Pointer(&buf[0]));
-	bytes := StringByteSlice(name);
+	p := (*byte)(unsafe.Pointer(&buf[0]))
+	bytes := StringByteSlice(name)
 
 	// Magic sysctl: "setting" 0.3 to a string name
 	// lets you read back the array of integers form.
 	if errno = sysctl([]_C_int{0, 3}, p, &n, &bytes[0], uintptr(len(name))); errno != 0 {
 		return nil, errno
 	}
-	return buf[0 : n/siz], 0;
+	return buf[0 : n/siz], 0
 }
 
 func Sysctl(name string) (value string, errno int) {
 	// Translate name to mib number.
-	mib, errno := nametomib(name);
+	mib, errno := nametomib(name)
 	if errno != 0 {
 		return "", errno
 	}
 
 	// Find size.
-	n := uintptr(0);
+	n := uintptr(0)
 	if errno = sysctl(mib, nil, &n, nil, 0); errno != 0 {
 		return "", errno
 	}
@@ -423,7 +423,7 @@ func Sysctl(name string) (value string, errno int) {
 	}
 
 	// Read into buffer of that size.
-	buf := make([]byte, n);
+	buf := make([]byte, n)
 	if errno = sysctl(mib, &buf[0], &n, nil, 0); errno != 0 {
 		return "", errno
 	}
@@ -432,26 +432,26 @@ func Sysctl(name string) (value string, errno int) {
 	if n > 0 && buf[n-1] == '\x00' {
 		n--
 	}
-	return string(buf[0:n]), 0;
+	return string(buf[0:n]), 0
 }
 
 func SysctlUint32(name string) (value uint32, errno int) {
 	// Translate name to mib number.
-	mib, errno := nametomib(name);
+	mib, errno := nametomib(name)
 	if errno != 0 {
 		return 0, errno
 	}
 
 	// Read into buffer of that size.
-	n := uintptr(4);
-	buf := make([]byte, 4);
+	n := uintptr(4)
+	buf := make([]byte, 4)
 	if errno = sysctl(mib, &buf[0], &n, nil, 0); errno != 0 {
 		return 0, errno
 	}
 	if n != 4 {
 		return 0, EIO
 	}
-	return *(*uint32)(unsafe.Pointer(&buf[0])), 0;
+	return *(*uint32)(unsafe.Pointer(&buf[0])), 0
 }
 
 // TODO: wrap
diff --git a/src/pkg/syscall/syscall_darwin_386.go b/src/pkg/syscall/syscall_darwin_386.go
index a5296fbd76..3fd72efe3f 100644
--- a/src/pkg/syscall/syscall_darwin_386.go
+++ b/src/pkg/syscall/syscall_darwin_386.go
@@ -4,23 +4,23 @@
 
 package syscall
 
-func Getpagesize() int	{ return 4096 }
+func Getpagesize() int { return 4096 }
 
-func TimespecToNsec(ts Timespec) int64	{ return int64(ts.Sec)*1e9 + int64(ts.Nsec) }
+func TimespecToNsec(ts Timespec) int64 { return int64(ts.Sec)*1e9 + int64(ts.Nsec) }
 
 func NsecToTimespec(nsec int64) (ts Timespec) {
-	ts.Sec = int32(nsec / 1e9);
-	ts.Nsec = int32(nsec % 1e9);
-	return;
+	ts.Sec = int32(nsec / 1e9)
+	ts.Nsec = int32(nsec % 1e9)
+	return
 }
 
-func TimevalToNsec(tv Timeval) int64	{ return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }
+func TimevalToNsec(tv Timeval) int64 { return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }
 
 func NsecToTimeval(nsec int64) (tv Timeval) {
-	nsec += 999;	// round up to microsecond
-	tv.Usec = int32(nsec % 1e9 / 1e3);
-	tv.Sec = int32(nsec / 1e9);
-	return;
+	nsec += 999 // round up to microsecond
+	tv.Usec = int32(nsec % 1e9 / 1e3)
+	tv.Sec = int32(nsec / 1e9)
+	return
 }
 
 //sys	gettimeofday(tp *Timeval) (sec int32, usec int32, errno int)
@@ -28,14 +28,14 @@ func Gettimeofday(tv *Timeval) (errno int) {
 	// The tv passed to gettimeofday must be non-nil
 	// but is otherwise unused.  The answers come back
 	// in the two registers.
-	sec, usec, err := gettimeofday(tv);
-	tv.Sec = int32(sec);
-	tv.Usec = int32(usec);
-	return err;
+	sec, usec, err := gettimeofday(tv)
+	tv.Sec = int32(sec)
+	tv.Usec = int32(usec)
+	return err
 }
 
 func SetKevent(k *Kevent_t, fd, mode, flags int) {
-	k.Ident = uint32(fd);
-	k.Filter = int16(mode);
-	k.Flags = uint16(flags);
+	k.Ident = uint32(fd)
+	k.Filter = int16(mode)
+	k.Flags = uint16(flags)
 }
diff --git a/src/pkg/syscall/syscall_darwin_amd64.go b/src/pkg/syscall/syscall_darwin_amd64.go
index 941124fb75..df8d375888 100644
--- a/src/pkg/syscall/syscall_darwin_amd64.go
+++ b/src/pkg/syscall/syscall_darwin_amd64.go
@@ -4,23 +4,23 @@
 
 package syscall
 
-func Getpagesize() int	{ return 4096 }
+func Getpagesize() int { return 4096 }
 
-func TimespecToNsec(ts Timespec) int64	{ return int64(ts.Sec)*1e9 + int64(ts.Nsec) }
+func TimespecToNsec(ts Timespec) int64 { return int64(ts.Sec)*1e9 + int64(ts.Nsec) }
 
 func NsecToTimespec(nsec int64) (ts Timespec) {
-	ts.Sec = nsec / 1e9;
-	ts.Nsec = nsec % 1e9;
-	return;
+	ts.Sec = nsec / 1e9
+	ts.Nsec = nsec % 1e9
+	return
 }
 
-func TimevalToNsec(tv Timeval) int64	{ return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }
+func TimevalToNsec(tv Timeval) int64 { return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }
 
 func NsecToTimeval(nsec int64) (tv Timeval) {
-	nsec += 999;	// round up to microsecond
-	tv.Usec = int32(nsec % 1e9 / 1e3);
-	tv.Sec = int64(nsec / 1e9);
-	return;
+	nsec += 999 // round up to microsecond
+	tv.Usec = int32(nsec % 1e9 / 1e3)
+	tv.Sec = int64(nsec / 1e9)
+	return
 }
 
 //sys	gettimeofday(tp *Timeval) (sec int64, usec int32, errno int)
@@ -28,14 +28,14 @@ func Gettimeofday(tv *Timeval) (errno int) {
 	// The tv passed to gettimeofday must be non-nil
 	// but is otherwise unused.  The answers come back
 	// in the two registers.
-	sec, usec, err := gettimeofday(tv);
-	tv.Sec = sec;
-	tv.Usec = usec;
-	return err;
+	sec, usec, err := gettimeofday(tv)
+	tv.Sec = sec
+	tv.Usec = usec
+	return err
 }
 
 func SetKevent(k *Kevent_t, fd, mode, flags int) {
-	k.Ident = uint64(fd);
-	k.Filter = int16(mode);
-	k.Flags = uint16(flags);
+	k.Ident = uint64(fd)
+	k.Filter = int16(mode)
+	k.Flags = uint16(flags)
 }
diff --git a/src/pkg/syscall/syscall_freebsd.go b/src/pkg/syscall/syscall_freebsd.go
index e0ad92fada..9b4ecd320f 100644
--- a/src/pkg/syscall/syscall_freebsd.go
+++ b/src/pkg/syscall/syscall_freebsd.go
@@ -23,7 +23,7 @@ const OS = "freebsd"
 // even linking this function into the binary.  See ../os/getwd.go.
 const ImplementsGetwd = false
 
-func Getwd() (string, int)	{ return "", ENOTSUP }
+func Getwd() (string, int) { return "", ENOTSUP }
 
 
 /*
@@ -34,7 +34,7 @@ func Getwd() (string, int)	{ return "", ENOTSUP }
 //sys	setgroups(ngid int, gid *_Gid_t) (errno int)
 
 func Getgroups() (gids []int, errno int) {
-	n, err := getgroups(0, nil);
+	n, err := getgroups(0, nil)
 	if err != 0 {
 		return nil, errno
 	}
@@ -47,16 +47,16 @@ func Getgroups() (gids []int, errno int) {
 		return nil, EINVAL
 	}
 
-	a := make([]_Gid_t, n);
-	n, err = getgroups(n, &a[0]);
+	a := make([]_Gid_t, n)
+	n, err = getgroups(n, &a[0])
 	if err != 0 {
 		return nil, errno
 	}
-	gids = make([]int, n);
+	gids = make([]int, n)
 	for i, v := range a[0:n] {
 		gids[i] = int(v)
 	}
-	return;
+	return
 }
 
 func Setgroups(gids []int) (errno int) {
@@ -64,11 +64,11 @@ func Setgroups(gids []int) (errno int) {
 		return setgroups(0, nil)
 	}
 
-	a := make([]_Gid_t, len(gids));
+	a := make([]_Gid_t, len(gids))
 	for i, v := range gids {
 		a[i] = _Gid_t(v)
 	}
-	return setgroups(len(a), &a[0]);
+	return setgroups(len(a), &a[0])
 }
 
 // Wait status is 7 bits at bottom, either 0 (exited),
@@ -80,44 +80,44 @@ func Setgroups(gids []int) (errno int) {
 type WaitStatus uint32
 
 const (
-	mask	= 0x7F;
-	core	= 0x80;
-	shift	= 8;
+	mask  = 0x7F
+	core  = 0x80
+	shift = 8
 
-	exited	= 0;
-	stopped	= 0x7F;
+	exited  = 0
+	stopped = 0x7F
 )
 
-func (w WaitStatus) Exited() bool	{ return w&mask == exited }
+func (w WaitStatus) Exited() bool { return w&mask == exited }
 
 func (w WaitStatus) ExitStatus() int {
 	if w&mask != exited {
 		return -1
 	}
-	return int(w >> shift);
+	return int(w >> shift)
 }
 
-func (w WaitStatus) Signaled() bool	{ return w&mask != stopped && w&mask != 0 }
+func (w WaitStatus) Signaled() bool { return w&mask != stopped && w&mask != 0 }
 
 func (w WaitStatus) Signal() int {
-	sig := int(w & mask);
+	sig := int(w & mask)
 	if sig == stopped || sig == 0 {
 		return -1
 	}
-	return sig;
+	return sig
 }
 
-func (w WaitStatus) CoreDump() bool	{ return w.Signaled() && w&core != 0 }
+func (w WaitStatus) CoreDump() bool { return w.Signaled() && w&core != 0 }
 
-func (w WaitStatus) Stopped() bool	{ return w&mask == stopped && w>>shift != SIGSTOP }
+func (w WaitStatus) Stopped() bool { return w&mask == stopped && w>>shift != SIGSTOP }
 
-func (w WaitStatus) Continued() bool	{ return w&mask == stopped && w>>shift == SIGSTOP }
+func (w WaitStatus) Continued() bool { return w&mask == stopped && w>>shift == SIGSTOP }
 
 func (w WaitStatus) StopSignal() int {
 	if !w.Stopped() {
 		return -1
 	}
-	return int(w>>shift) & 0xFF;
+	return int(w>>shift) & 0xFF
 }
 
 func (w WaitStatus) TrapCause() int {
@@ -128,12 +128,12 @@ func (w WaitStatus) TrapCause() int {
 //sys	wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, errno int)
 
 func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, errno int) {
-	var status _C_int;
-	wpid, errno = wait4(pid, &status, options, rusage);
+	var status _C_int
+	wpid, errno = wait4(pid, &status, options, rusage)
 	if wstatus != nil {
 		*wstatus = WaitStatus(status)
 	}
-	return;
+	return
 }
 
 //sys	pipe() (r int, w int, errno int)
@@ -142,13 +142,13 @@ func Pipe(p []int) (errno int) {
 	if len(p) != 2 {
 		return EINVAL
 	}
-	p[0], p[1], errno = pipe();
-	return;
+	p[0], p[1], errno = pipe()
+	return
 }
 
 func Sleep(ns int64) (errno int) {
-	tv := NsecToTimeval(ns);
-	return Select(0, nil, nil, nil, &tv);
+	tv := NsecToTimeval(ns)
+	return Select(0, nil, nil, nil, &tv)
 }
 
 //sys	accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, errno int)
@@ -165,173 +165,173 @@ func Sleep(ns int64) (errno int) {
 var SocketDisableIPv6 bool
 
 type Sockaddr interface {
-	sockaddr() (ptr uintptr, len _Socklen, errno int);	// lowercase; only we can define Sockaddrs
+	sockaddr() (ptr uintptr, len _Socklen, errno int) // lowercase; only we can define Sockaddrs
 }
 
 type SockaddrInet4 struct {
-	Port	int;
-	Addr	[4]byte;
-	raw	RawSockaddrInet4;
+	Port int
+	Addr [4]byte
+	raw  RawSockaddrInet4
 }
 
 func (sa *SockaddrInet4) sockaddr() (uintptr, _Socklen, int) {
 	if sa.Port < 0 || sa.Port > 0xFFFF {
 		return 0, 0, EINVAL
 	}
-	sa.raw.Len = SizeofSockaddrInet4;
-	sa.raw.Family = AF_INET;
-	p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port));
-	p[0] = byte(sa.Port >> 8);
-	p[1] = byte(sa.Port);
+	sa.raw.Len = SizeofSockaddrInet4
+	sa.raw.Family = AF_INET
+	p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port))
+	p[0] = byte(sa.Port >> 8)
+	p[1] = byte(sa.Port)
 	for i := 0; i < len(sa.Addr); i++ {
 		sa.raw.Addr[i] = sa.Addr[i]
 	}
-	return uintptr(unsafe.Pointer(&sa.raw)), _Socklen(sa.raw.Len), 0;
+	return uintptr(unsafe.Pointer(&sa.raw)), _Socklen(sa.raw.Len), 0
 }
 
 type SockaddrInet6 struct {
-	Port	int;
-	Addr	[16]byte;
-	raw	RawSockaddrInet6;
+	Port int
+	Addr [16]byte
+	raw  RawSockaddrInet6
 }
 
 func (sa *SockaddrInet6) sockaddr() (uintptr, _Socklen, int) {
 	if sa.Port < 0 || sa.Port > 0xFFFF {
 		return 0, 0, EINVAL
 	}
-	sa.raw.Len = SizeofSockaddrInet6;
-	sa.raw.Family = AF_INET6;
-	p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port));
-	p[0] = byte(sa.Port >> 8);
-	p[1] = byte(sa.Port);
+	sa.raw.Len = SizeofSockaddrInet6
+	sa.raw.Family = AF_INET6
+	p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port))
+	p[0] = byte(sa.Port >> 8)
+	p[1] = byte(sa.Port)
 	for i := 0; i < len(sa.Addr); i++ {
 		sa.raw.Addr[i] = sa.Addr[i]
 	}
-	return uintptr(unsafe.Pointer(&sa.raw)), _Socklen(sa.raw.Len), 0;
+	return uintptr(unsafe.Pointer(&sa.raw)), _Socklen(sa.raw.Len), 0
 }
 
 type SockaddrUnix struct {
-	Name	string;
-	raw	RawSockaddrUnix;
+	Name string
+	raw  RawSockaddrUnix
 }
 
 func (sa *SockaddrUnix) sockaddr() (uintptr, _Socklen, int) {
-	name := sa.Name;
-	n := len(name);
+	name := sa.Name
+	n := len(name)
 	if n >= len(sa.raw.Path) || n == 0 {
 		return 0, 0, EINVAL
 	}
-	sa.raw.Len = byte(3 + n);	// 2 for Family, Len; 1 for NUL
-	sa.raw.Family = AF_UNIX;
+	sa.raw.Len = byte(3 + n) // 2 for Family, Len; 1 for NUL
+	sa.raw.Family = AF_UNIX
 	for i := 0; i < n; i++ {
 		sa.raw.Path[i] = int8(name[i])
 	}
-	return uintptr(unsafe.Pointer(&sa.raw)), _Socklen(sa.raw.Len), 0;
+	return uintptr(unsafe.Pointer(&sa.raw)), _Socklen(sa.raw.Len), 0
 }
 
 func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, int) {
 	switch rsa.Addr.Family {
 	case AF_UNIX:
-		pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa));
+		pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))
 		if pp.Len < 3 || pp.Len > SizeofSockaddrUnix {
 			return nil, EINVAL
 		}
-		sa := new(SockaddrUnix);
-		n := int(pp.Len) - 3;	// subtract leading Family, Len, terminating NUL
+		sa := new(SockaddrUnix)
+		n := int(pp.Len) - 3 // subtract leading Family, Len, terminating NUL
 		for i := 0; i < n; i++ {
 			if pp.Path[i] == 0 {
 				// found early NUL; assume Len is overestimating
-				n = i;
-				break;
+				n = i
+				break
 			}
 		}
-		bytes := (*[len(pp.Path)]byte)(unsafe.Pointer(&pp.Path[0]));
-		sa.Name = string(bytes[0:n]);
-		return sa, 0;
+		bytes := (*[len(pp.Path)]byte)(unsafe.Pointer(&pp.Path[0]))
+		sa.Name = string(bytes[0:n])
+		return sa, 0
 
 	case AF_INET:
-		pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa));
-		sa := new(SockaddrInet4);
-		p := (*[2]byte)(unsafe.Pointer(&pp.Port));
-		sa.Port = int(p[0])<<8 + int(p[1]);
+		pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))
+		sa := new(SockaddrInet4)
+		p := (*[2]byte)(unsafe.Pointer(&pp.Port))
+		sa.Port = int(p[0])<<8 + int(p[1])
 		for i := 0; i < len(sa.Addr); i++ {
 			sa.Addr[i] = pp.Addr[i]
 		}
-		return sa, 0;
+		return sa, 0
 
 	case AF_INET6:
-		pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa));
-		sa := new(SockaddrInet6);
-		p := (*[2]byte)(unsafe.Pointer(&pp.Port));
-		sa.Port = int(p[0])<<8 + int(p[1]);
+		pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))
+		sa := new(SockaddrInet6)
+		p := (*[2]byte)(unsafe.Pointer(&pp.Port))
+		sa.Port = int(p[0])<<8 + int(p[1])
 		for i := 0; i < len(sa.Addr); i++ {
 			sa.Addr[i] = pp.Addr[i]
 		}
-		return sa, 0;
+		return sa, 0
 	}
-	return nil, EAFNOSUPPORT;
+	return nil, EAFNOSUPPORT
 }
 
 func Accept(fd int) (nfd int, sa Sockaddr, errno int) {
-	var rsa RawSockaddrAny;
-	var len _Socklen = SizeofSockaddrAny;
-	nfd, errno = accept(fd, &rsa, &len);
+	var rsa RawSockaddrAny
+	var len _Socklen = SizeofSockaddrAny
+	nfd, errno = accept(fd, &rsa, &len)
 	if errno != 0 {
 		return
 	}
-	sa, errno = anyToSockaddr(&rsa);
+	sa, errno = anyToSockaddr(&rsa)
 	if errno != 0 {
-		Close(nfd);
-		nfd = 0;
+		Close(nfd)
+		nfd = 0
 	}
-	return;
+	return
 }
 
 func Getsockname(fd int) (sa Sockaddr, errno int) {
-	var rsa RawSockaddrAny;
-	var len _Socklen = SizeofSockaddrAny;
+	var rsa RawSockaddrAny
+	var len _Socklen = SizeofSockaddrAny
 	if errno = getsockname(fd, &rsa, &len); errno != 0 {
 		return
 	}
-	return anyToSockaddr(&rsa);
+	return anyToSockaddr(&rsa)
 }
 
 func Getpeername(fd int) (sa Sockaddr, errno int) {
-	var rsa RawSockaddrAny;
-	var len _Socklen = SizeofSockaddrAny;
+	var rsa RawSockaddrAny
+	var len _Socklen = SizeofSockaddrAny
 	if errno = getpeername(fd, &rsa, &len); errno != 0 {
 		return
 	}
-	return anyToSockaddr(&rsa);
+	return anyToSockaddr(&rsa)
 }
 
 func Bind(fd int, sa Sockaddr) (errno int) {
-	ptr, n, err := sa.sockaddr();
+	ptr, n, err := sa.sockaddr()
 	if err != 0 {
 		return err
 	}
-	return bind(fd, ptr, n);
+	return bind(fd, ptr, n)
 }
 
 func Connect(fd int, sa Sockaddr) (errno int) {
-	ptr, n, err := sa.sockaddr();
+	ptr, n, err := sa.sockaddr()
 	if err != 0 {
 		return err
 	}
-	return connect(fd, ptr, n);
+	return connect(fd, ptr, n)
 }
 
 func Socket(domain, typ, proto int) (fd, errno int) {
 	if domain == AF_INET6 && SocketDisableIPv6 {
 		return -1, EAFNOSUPPORT
 	}
-	fd, errno = socket(domain, typ, proto);
-	return;
+	fd, errno = socket(domain, typ, proto)
+	return
 }
 
 func SetsockoptInt(fd, level, opt int, value int) (errno int) {
-	var n = int32(value);
-	return setsockopt(fd, level, opt, uintptr(unsafe.Pointer(&n)), 4);
+	var n = int32(value)
+	return setsockopt(fd, level, opt, uintptr(unsafe.Pointer(&n)), 4)
 }
 
 func SetsockoptTimeval(fd, level, opt int, tv *Timeval) (errno int) {
@@ -346,44 +346,44 @@ func SetsockoptLinger(fd, level, opt int, l *Linger) (errno int) {
 //sys recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, errno int)
 
 func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, errno int) {
-	var rsa RawSockaddrAny;
-	var len _Socklen = SizeofSockaddrAny;
+	var rsa RawSockaddrAny
+	var len _Socklen = SizeofSockaddrAny
 	if n, errno = recvfrom(fd, p, flags, &rsa, &len); errno != 0 {
 		return
 	}
-	from, errno = anyToSockaddr(&rsa);
-	return;
+	from, errno = anyToSockaddr(&rsa)
+	return
 }
 
 //sys sendto(s int, buf []byte, flags int, to uintptr, addrlen _Socklen) (errno int)
 
 func Sendto(fd int, p []byte, flags int, to Sockaddr) (errno int) {
-	ptr, n, err := to.sockaddr();
+	ptr, n, err := to.sockaddr()
 	if err != 0 {
 		return err
 	}
-	return sendto(fd, p, flags, ptr, n);
+	return sendto(fd, p, flags, ptr, n)
 }
 
 //sys	kevent(kq int, change uintptr, nchange int, event uintptr, nevent int, timeout *Timespec) (n int, errno int)
 
 func Kevent(kq int, changes, events []Kevent_t, timeout *Timespec) (n int, errno int) {
-	var change, event uintptr;
+	var change, event uintptr
 	if len(changes) > 0 {
 		change = uintptr(unsafe.Pointer(&changes[0]))
 	}
 	if len(events) > 0 {
 		event = uintptr(unsafe.Pointer(&events[0]))
 	}
-	return kevent(kq, change, len(changes), event, len(events), timeout);
+	return kevent(kq, change, len(changes), event, len(events), timeout)
 }
 
 //sys	sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (errno int) = SYS___SYSCTL
 
 // Translate "kern.hostname" to []_C_int{0,1,2,3}.
 func nametomib(name string) (mib []_C_int, errno int) {
-	const CTL_MAXNAME = 12;
-	const siz = uintptr(unsafe.Sizeof(mib[0]));
+	const CTL_MAXNAME = 12
+	const siz = uintptr(unsafe.Sizeof(mib[0]))
 
 	// NOTE(rsc): It seems strange to set the buffer to have
 	// size CTL_MAXNAME+2 but use only CTL_MAXNAME
@@ -392,29 +392,29 @@ func nametomib(name string) (mib []_C_int, errno int) {
 	// I am scared that if we don't include the +2 here, the kernel
 	// will silently write 2 words farther than we specify
 	// and we'll get memory corruption.
-	var buf [CTL_MAXNAME + 2]_C_int;
-	n := uintptr(CTL_MAXNAME) * siz;
+	var buf [CTL_MAXNAME + 2]_C_int
+	n := uintptr(CTL_MAXNAME) * siz
 
-	p := (*byte)(unsafe.Pointer(&buf[0]));
-	bytes := StringByteSlice(name);
+	p := (*byte)(unsafe.Pointer(&buf[0]))
+	bytes := StringByteSlice(name)
 
 	// Magic sysctl: "setting" 0.3 to a string name
 	// lets you read back the array of integers form.
 	if errno = sysctl([]_C_int{0, 3}, p, &n, &bytes[0], uintptr(len(name))); errno != 0 {
 		return nil, errno
 	}
-	return buf[0 : n/siz], 0;
+	return buf[0 : n/siz], 0
 }
 
 func Sysctl(name string) (value string, errno int) {
 	// Translate name to mib number.
-	mib, errno := nametomib(name);
+	mib, errno := nametomib(name)
 	if errno != 0 {
 		return "", errno
 	}
 
 	// Find size.
-	n := uintptr(0);
+	n := uintptr(0)
 	if errno = sysctl(mib, nil, &n, nil, 0); errno != 0 {
 		return "", errno
 	}
@@ -423,7 +423,7 @@ func Sysctl(name string) (value string, errno int) {
 	}
 
 	// Read into buffer of that size.
-	buf := make([]byte, n);
+	buf := make([]byte, n)
 	if errno = sysctl(mib, &buf[0], &n, nil, 0); errno != 0 {
 		return "", errno
 	}
@@ -432,26 +432,26 @@ func Sysctl(name string) (value string, errno int) {
 	if n > 0 && buf[n-1] == '\x00' {
 		n--
 	}
-	return string(buf[0:n]), 0;
+	return string(buf[0:n]), 0
 }
 
 func SysctlUint32(name string) (value uint32, errno int) {
 	// Translate name to mib number.
-	mib, errno := nametomib(name);
+	mib, errno := nametomib(name)
 	if errno != 0 {
 		return 0, errno
 	}
 
 	// Read into buffer of that size.
-	n := uintptr(4);
-	buf := make([]byte, 4);
+	n := uintptr(4)
+	buf := make([]byte, 4)
 	if errno = sysctl(mib, &buf[0], &n, nil, 0); errno != 0 {
 		return 0, errno
 	}
 	if n != 4 {
 		return 0, EIO
 	}
-	return *(*uint32)(unsafe.Pointer(&buf[0])), 0;
+	return *(*uint32)(unsafe.Pointer(&buf[0])), 0
 }
 
 // TODO: wrap
diff --git a/src/pkg/syscall/syscall_freebsd_386.go b/src/pkg/syscall/syscall_freebsd_386.go
index a85950508e..0aa577ee66 100644
--- a/src/pkg/syscall/syscall_freebsd_386.go
+++ b/src/pkg/syscall/syscall_freebsd_386.go
@@ -4,27 +4,27 @@
 
 package syscall
 
-func Getpagesize() int	{ return 4096 }
+func Getpagesize() int { return 4096 }
 
-func TimespecToNsec(ts Timespec) int64	{ return int64(ts.Sec)*1e9 + int64(ts.Nsec) }
+func TimespecToNsec(ts Timespec) int64 { return int64(ts.Sec)*1e9 + int64(ts.Nsec) }
 
 func NsecToTimespec(nsec int64) (ts Timespec) {
-	ts.Sec = int32(nsec / 1e9);
-	ts.Nsec = int32(nsec % 1e9);
-	return;
+	ts.Sec = int32(nsec / 1e9)
+	ts.Nsec = int32(nsec % 1e9)
+	return
 }
 
-func TimevalToNsec(tv Timeval) int64	{ return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }
+func TimevalToNsec(tv Timeval) int64 { return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }
 
 func NsecToTimeval(nsec int64) (tv Timeval) {
-	nsec += 999;	// round up to microsecond
-	tv.Usec = int32(nsec % 1e9 / 1e3);
-	tv.Sec = int32(nsec / 1e9);
-	return;
+	nsec += 999 // round up to microsecond
+	tv.Usec = int32(nsec % 1e9 / 1e3)
+	tv.Sec = int32(nsec / 1e9)
+	return
 }
 
 func SetKevent(k *Kevent_t, fd, mode, flags int) {
-	k.Ident = uint32(fd);
-	k.Filter = int16(mode);
-	k.Flags = uint16(flags);
+	k.Ident = uint32(fd)
+	k.Filter = int16(mode)
+	k.Flags = uint16(flags)
 }
diff --git a/src/pkg/syscall/syscall_freebsd_amd64.go b/src/pkg/syscall/syscall_freebsd_amd64.go
index 70a4df8f8e..ef5aff6ef5 100644
--- a/src/pkg/syscall/syscall_freebsd_amd64.go
+++ b/src/pkg/syscall/syscall_freebsd_amd64.go
@@ -4,27 +4,27 @@
 
 package syscall
 
-func Getpagesize() int	{ return 4096 }
+func Getpagesize() int { return 4096 }
 
-func TimespecToNsec(ts Timespec) int64	{ return int64(ts.Sec)*1e9 + int64(ts.Nsec) }
+func TimespecToNsec(ts Timespec) int64 { return int64(ts.Sec)*1e9 + int64(ts.Nsec) }
 
 func NsecToTimespec(nsec int64) (ts Timespec) {
-	ts.Sec = nsec / 1e9;
-	ts.Nsec = nsec % 1e9;
-	return;
+	ts.Sec = nsec / 1e9
+	ts.Nsec = nsec % 1e9
+	return
 }
 
-func TimevalToNsec(tv Timeval) int64	{ return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }
+func TimevalToNsec(tv Timeval) int64 { return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }
 
 func NsecToTimeval(nsec int64) (tv Timeval) {
-	nsec += 999;	// round up to microsecond
-	tv.Usec = nsec % 1e9 / 1e3;
-	tv.Sec = int64(nsec / 1e9);
-	return;
+	nsec += 999 // round up to microsecond
+	tv.Usec = nsec % 1e9 / 1e3
+	tv.Sec = int64(nsec / 1e9)
+	return
 }
 
 func SetKevent(k *Kevent_t, fd, mode, flags int) {
-	k.Ident = uint64(fd);
-	k.Filter = int16(mode);
-	k.Flags = uint16(flags);
+	k.Ident = uint64(fd)
+	k.Filter = int16(mode)
+	k.Flags = uint16(flags)
 }
diff --git a/src/pkg/syscall/syscall_linux.go b/src/pkg/syscall/syscall_linux.go
index 0c2d1aa79a..53ddf1c0e4 100644
--- a/src/pkg/syscall/syscall_linux.go
+++ b/src/pkg/syscall/syscall_linux.go
@@ -24,11 +24,11 @@ func Pipe(p []int) (errno int) {
 	if len(p) != 2 {
 		return EINVAL
 	}
-	var pp [2]_C_int;
-	errno = pipe(&pp);
-	p[0] = int(pp[0]);
-	p[1] = int(pp[1]);
-	return;
+	var pp [2]_C_int
+	errno = pipe(&pp)
+	p[0] = int(pp[0])
+	p[1] = int(pp[1])
+	return
 }
 
 //sys	utimes(path string, times *[2]Timeval) (errno int)
@@ -36,7 +36,7 @@ func Utimes(path string, tv []Timeval) (errno int) {
 	if len(tv) != 2 {
 		return EINVAL
 	}
-	return utimes(path, (*[2]Timeval)(unsafe.Pointer(&tv[0])));
+	return utimes(path, (*[2]Timeval)(unsafe.Pointer(&tv[0])))
 }
 
 //sys	futimesat(dirfd int, path string, times *[2]Timeval) (errno int)
@@ -44,15 +44,15 @@ func Futimesat(dirfd int, path string, tv []Timeval) (errno int) {
 	if len(tv) != 2 {
 		return EINVAL
 	}
-	return futimesat(dirfd, path, (*[2]Timeval)(unsafe.Pointer(&tv[0])));
+	return futimesat(dirfd, path, (*[2]Timeval)(unsafe.Pointer(&tv[0])))
 }
 
 const ImplementsGetwd = true
 
 //sys	Getcwd(buf []byte) (n int, errno int)
 func Getwd() (wd string, errno int) {
-	var buf [PathMax]byte;
-	n, err := Getcwd(&buf);
+	var buf [PathMax]byte
+	n, err := Getcwd(&buf)
 	if err != 0 {
 		return "", err
 	}
@@ -60,11 +60,11 @@ func Getwd() (wd string, errno int) {
 	if n < 1 || n > len(buf) || buf[n-1] != 0 {
 		return "", EINVAL
 	}
-	return string(buf[0 : n-1]), 0;
+	return string(buf[0 : n-1]), 0
 }
 
 func Getgroups() (gids []int, errno int) {
-	n, err := getgroups(0, nil);
+	n, err := getgroups(0, nil)
 	if err != 0 {
 		return nil, errno
 	}
@@ -77,16 +77,16 @@ func Getgroups() (gids []int, errno int) {
 		return nil, EINVAL
 	}
 
-	a := make([]_Gid_t, n);
-	n, err = getgroups(n, &a[0]);
+	a := make([]_Gid_t, n)
+	n, err = getgroups(n, &a[0])
 	if err != 0 {
 		return nil, errno
 	}
-	gids = make([]int, n);
+	gids = make([]int, n)
 	for i, v := range a[0:n] {
 		gids[i] = int(v)
 	}
-	return;
+	return
 }
 
 func Setgroups(gids []int) (errno int) {
@@ -94,11 +94,11 @@ func Setgroups(gids []int) (errno int) {
 		return setgroups(0, nil)
 	}
 
-	a := make([]_Gid_t, len(gids));
+	a := make([]_Gid_t, len(gids))
 	for i, v := range gids {
 		a[i] = _Gid_t(v)
 	}
-	return setgroups(len(a), &a[0]);
+	return setgroups(len(a), &a[0])
 }
 
 type WaitStatus uint32
@@ -113,65 +113,65 @@ type WaitStatus uint32
 // from stopped via the core dump bit.
 
 const (
-	mask	= 0x7F;
-	core	= 0x80;
-	exited	= 0x00;
-	stopped	= 0x7F;
-	shift	= 8;
+	mask    = 0x7F
+	core    = 0x80
+	exited  = 0x00
+	stopped = 0x7F
+	shift   = 8
 )
 
-func (w WaitStatus) Exited() bool	{ return w&mask == exited }
+func (w WaitStatus) Exited() bool { return w&mask == exited }
 
-func (w WaitStatus) Signaled() bool	{ return w&mask != stopped && w&mask != exited }
+func (w WaitStatus) Signaled() bool { return w&mask != stopped && w&mask != exited }
 
-func (w WaitStatus) Stopped() bool	{ return w&0xFF == stopped }
+func (w WaitStatus) Stopped() bool { return w&0xFF == stopped }
 
-func (w WaitStatus) Continued() bool	{ return w == 0xFFFF }
+func (w WaitStatus) Continued() bool { return w == 0xFFFF }
 
-func (w WaitStatus) CoreDump() bool	{ return w.Signaled() && w&core != 0 }
+func (w WaitStatus) CoreDump() bool { return w.Signaled() && w&core != 0 }
 
 func (w WaitStatus) ExitStatus() int {
 	if !w.Exited() {
 		return -1
 	}
-	return int(w>>shift) & 0xFF;
+	return int(w>>shift) & 0xFF
 }
 
 func (w WaitStatus) Signal() int {
 	if !w.Signaled() {
 		return -1
 	}
-	return int(w & mask);
+	return int(w & mask)
 }
 
 func (w WaitStatus) StopSignal() int {
 	if !w.Stopped() {
 		return -1
 	}
-	return int(w>>shift) & 0xFF;
+	return int(w>>shift) & 0xFF
 }
 
 func (w WaitStatus) TrapCause() int {
 	if w.StopSignal() != SIGTRAP {
 		return -1
 	}
-	return int(w>>shift) >> 8;
+	return int(w>>shift) >> 8
 }
 
 //sys	wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, errno int)
 func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, errno int) {
-	var status _C_int;
-	wpid, errno = wait4(pid, &status, options, rusage);
+	var status _C_int
+	wpid, errno = wait4(pid, &status, options, rusage)
 	if wstatus != nil {
 		*wstatus = WaitStatus(status)
 	}
-	return;
+	return
 }
 
 func Sleep(nsec int64) (errno int) {
-	tv := NsecToTimeval(nsec);
-	_, err := Select(0, nil, nil, nil, &tv);
-	return err;
+	tv := NsecToTimeval(nsec)
+	_, err := Select(0, nil, nil, nil, &tv)
+	return err
 }
 
 // For testing: clients can set this flag to force
@@ -179,61 +179,61 @@ func Sleep(nsec int64) (errno int) {
 var SocketDisableIPv6 bool
 
 type Sockaddr interface {
-	sockaddr() (ptr uintptr, len _Socklen, errno int);	// lowercase; only we can define Sockaddrs
+	sockaddr() (ptr uintptr, len _Socklen, errno int) // lowercase; only we can define Sockaddrs
 }
 
 type SockaddrInet4 struct {
-	Port	int;
-	Addr	[4]byte;
-	raw	RawSockaddrInet4;
+	Port int
+	Addr [4]byte
+	raw  RawSockaddrInet4
 }
 
 func (sa *SockaddrInet4) sockaddr() (uintptr, _Socklen, int) {
 	if sa.Port < 0 || sa.Port > 0xFFFF {
 		return 0, 0, EINVAL
 	}
-	sa.raw.Family = AF_INET;
-	p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port));
-	p[0] = byte(sa.Port >> 8);
-	p[1] = byte(sa.Port);
+	sa.raw.Family = AF_INET
+	p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port))
+	p[0] = byte(sa.Port >> 8)
+	p[1] = byte(sa.Port)
 	for i := 0; i < len(sa.Addr); i++ {
 		sa.raw.Addr[i] = sa.Addr[i]
 	}
-	return uintptr(unsafe.Pointer(&sa.raw)), SizeofSockaddrInet4, 0;
+	return uintptr(unsafe.Pointer(&sa.raw)), SizeofSockaddrInet4, 0
 }
 
 type SockaddrInet6 struct {
-	Port	int;
-	Addr	[16]byte;
-	raw	RawSockaddrInet6;
+	Port int
+	Addr [16]byte
+	raw  RawSockaddrInet6
 }
 
 func (sa *SockaddrInet6) sockaddr() (uintptr, _Socklen, int) {
 	if sa.Port < 0 || sa.Port > 0xFFFF {
 		return 0, 0, EINVAL
 	}
-	sa.raw.Family = AF_INET6;
-	p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port));
-	p[0] = byte(sa.Port >> 8);
-	p[1] = byte(sa.Port);
+	sa.raw.Family = AF_INET6
+	p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port))
+	p[0] = byte(sa.Port >> 8)
+	p[1] = byte(sa.Port)
 	for i := 0; i < len(sa.Addr); i++ {
 		sa.raw.Addr[i] = sa.Addr[i]
 	}
-	return uintptr(unsafe.Pointer(&sa.raw)), SizeofSockaddrInet6, 0;
+	return uintptr(unsafe.Pointer(&sa.raw)), SizeofSockaddrInet6, 0
 }
 
 type SockaddrUnix struct {
-	Name	string;
-	raw	RawSockaddrUnix;
+	Name string
+	raw  RawSockaddrUnix
 }
 
 func (sa *SockaddrUnix) sockaddr() (uintptr, _Socklen, int) {
-	name := sa.Name;
-	n := len(name);
+	name := sa.Name
+	n := len(name)
 	if n >= len(sa.raw.Path) || n == 0 {
 		return 0, 0, EINVAL
 	}
-	sa.raw.Family = AF_UNIX;
+	sa.raw.Family = AF_UNIX
 	for i := 0; i < n; i++ {
 		sa.raw.Path[i] = int8(name[i])
 	}
@@ -242,14 +242,14 @@ func (sa *SockaddrUnix) sockaddr() (uintptr, _Socklen, int) {
 	}
 
 	// length is family, name, NUL.
-	return uintptr(unsafe.Pointer(&sa.raw)), 1 + _Socklen(n) + 1, 0;
+	return uintptr(unsafe.Pointer(&sa.raw)), 1 + _Socklen(n) + 1, 0
 }
 
 func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, int) {
 	switch rsa.Addr.Family {
 	case AF_UNIX:
-		pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa));
-		sa := new(SockaddrUnix);
+		pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))
+		sa := new(SockaddrUnix)
 		if pp.Path[0] == 0 {
 			// "Abstract" Unix domain socket.
 			// Rewrite leading NUL as @ for textual display.
@@ -264,97 +264,97 @@ func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, int) {
 		// abstract Unix domain sockets--they are supposed
 		// to be uninterpreted fixed-size binary blobs--but
 		// everyone uses this convention.
-		n := 0;
+		n := 0
 		for n < len(pp.Path) && pp.Path[n] != 0 {
 			n++
 		}
-		bytes := (*[len(pp.Path)]byte)(unsafe.Pointer(&pp.Path[0]));
-		sa.Name = string(bytes[0:n]);
-		return sa, 0;
+		bytes := (*[len(pp.Path)]byte)(unsafe.Pointer(&pp.Path[0]))
+		sa.Name = string(bytes[0:n])
+		return sa, 0
 
 	case AF_INET:
-		pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa));
-		sa := new(SockaddrInet4);
-		p := (*[2]byte)(unsafe.Pointer(&pp.Port));
-		sa.Port = int(p[0])<<8 + int(p[1]);
+		pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))
+		sa := new(SockaddrInet4)
+		p := (*[2]byte)(unsafe.Pointer(&pp.Port))
+		sa.Port = int(p[0])<<8 + int(p[1])
 		for i := 0; i < len(sa.Addr); i++ {
 			sa.Addr[i] = pp.Addr[i]
 		}
-		return sa, 0;
+		return sa, 0
 
 	case AF_INET6:
-		pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa));
-		sa := new(SockaddrInet6);
-		p := (*[2]byte)(unsafe.Pointer(&pp.Port));
-		sa.Port = int(p[0])<<8 + int(p[1]);
+		pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))
+		sa := new(SockaddrInet6)
+		p := (*[2]byte)(unsafe.Pointer(&pp.Port))
+		sa.Port = int(p[0])<<8 + int(p[1])
 		for i := 0; i < len(sa.Addr); i++ {
 			sa.Addr[i] = pp.Addr[i]
 		}
-		return sa, 0;
+		return sa, 0
 	}
-	return nil, EAFNOSUPPORT;
+	return nil, EAFNOSUPPORT
 }
 
 func Accept(fd int) (nfd int, sa Sockaddr, errno int) {
-	var rsa RawSockaddrAny;
-	var len _Socklen = SizeofSockaddrAny;
-	nfd, errno = accept(fd, &rsa, &len);
+	var rsa RawSockaddrAny
+	var len _Socklen = SizeofSockaddrAny
+	nfd, errno = accept(fd, &rsa, &len)
 	if errno != 0 {
 		return
 	}
-	sa, errno = anyToSockaddr(&rsa);
+	sa, errno = anyToSockaddr(&rsa)
 	if errno != 0 {
-		Close(nfd);
-		nfd = 0;
+		Close(nfd)
+		nfd = 0
 	}
-	return;
+	return
 }
 
 func Getsockname(fd int) (sa Sockaddr, errno int) {
-	var rsa RawSockaddrAny;
-	var len _Socklen = SizeofSockaddrAny;
+	var rsa RawSockaddrAny
+	var len _Socklen = SizeofSockaddrAny
 	if errno = getsockname(fd, &rsa, &len); errno != 0 {
 		return
 	}
-	return anyToSockaddr(&rsa);
+	return anyToSockaddr(&rsa)
 }
 
 func Getpeername(fd int) (sa Sockaddr, errno int) {
-	var rsa RawSockaddrAny;
-	var len _Socklen = SizeofSockaddrAny;
+	var rsa RawSockaddrAny
+	var len _Socklen = SizeofSockaddrAny
 	if errno = getpeername(fd, &rsa, &len); errno != 0 {
 		return
 	}
-	return anyToSockaddr(&rsa);
+	return anyToSockaddr(&rsa)
 }
 
 func Bind(fd int, sa Sockaddr) (errno int) {
-	ptr, n, err := sa.sockaddr();
+	ptr, n, err := sa.sockaddr()
 	if err != 0 {
 		return err
 	}
-	return bind(fd, ptr, n);
+	return bind(fd, ptr, n)
 }
 
 func Connect(fd int, sa Sockaddr) (errno int) {
-	ptr, n, err := sa.sockaddr();
+	ptr, n, err := sa.sockaddr()
 	if err != 0 {
 		return err
 	}
-	return connect(fd, ptr, n);
+	return connect(fd, ptr, n)
 }
 
 func Socket(domain, typ, proto int) (fd, errno int) {
 	if domain == AF_INET6 && SocketDisableIPv6 {
 		return -1, EAFNOSUPPORT
 	}
-	fd, errno = socket(domain, typ, proto);
-	return;
+	fd, errno = socket(domain, typ, proto)
+	return
 }
 
 func SetsockoptInt(fd, level, opt int, value int) (errno int) {
-	var n = int32(value);
-	return setsockopt(fd, level, opt, uintptr(unsafe.Pointer(&n)), 4);
+	var n = int32(value)
+	return setsockopt(fd, level, opt, uintptr(unsafe.Pointer(&n)), 4)
 }
 
 func SetsockoptTimeval(fd, level, opt int, tv *Timeval) (errno int) {
@@ -366,21 +366,21 @@ func SetsockoptLinger(fd, level, opt int, l *Linger) (errno int) {
 }
 
 func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, errno int) {
-	var rsa RawSockaddrAny;
-	var len _Socklen = SizeofSockaddrAny;
+	var rsa RawSockaddrAny
+	var len _Socklen = SizeofSockaddrAny
 	if n, errno = recvfrom(fd, p, flags, &rsa, &len); errno != 0 {
 		return
 	}
-	from, errno = anyToSockaddr(&rsa);
-	return;
+	from, errno = anyToSockaddr(&rsa)
+	return
 }
 
 func Sendto(fd int, p []byte, flags int, to Sockaddr) (errno int) {
-	ptr, n, err := to.sockaddr();
+	ptr, n, err := to.sockaddr()
 	if err != 0 {
 		return err
 	}
-	return sendto(fd, p, flags, ptr, n);
+	return sendto(fd, p, flags, ptr, n)
 }
 
 //sys	ptrace(request int, pid int, addr uintptr, data uintptr) (errno int)
@@ -392,37 +392,37 @@ func ptracePeek(req int, pid int, addr uintptr, out []byte) (count int, errno in
 	// The ptrace syscall differs from glibc's ptrace.
 	// Peeks returns the word in *data, not as the return value.
 
-	var buf [sizeofPtr]byte;
+	var buf [sizeofPtr]byte
 
 	// Leading edge.  PEEKTEXT/PEEKDATA don't require aligned
 	// access (PEEKUSER warns that it might), but if we don't
 	// align our reads, we might straddle an unmapped page
 	// boundary and not get the bytes leading up to the page
 	// boundary.
-	n := 0;
+	n := 0
 	if addr%sizeofPtr != 0 {
-		errno = ptrace(req, pid, addr-addr%sizeofPtr, uintptr(unsafe.Pointer(&buf[0])));
+		errno = ptrace(req, pid, addr-addr%sizeofPtr, uintptr(unsafe.Pointer(&buf[0])))
 		if errno != 0 {
 			return 0, errno
 		}
-		n += copy(out, buf[addr%sizeofPtr:]);
-		out = out[n:];
+		n += copy(out, buf[addr%sizeofPtr:])
+		out = out[n:]
 	}
 
 	// Remainder.
 	for len(out) > 0 {
 		// We use an internal buffer to gaurantee alignment.
 		// It's not documented if this is necessary, but we're paranoid.
-		errno = ptrace(req, pid, addr+uintptr(n), uintptr(unsafe.Pointer(&buf[0])));
+		errno = ptrace(req, pid, addr+uintptr(n), uintptr(unsafe.Pointer(&buf[0])))
 		if errno != 0 {
 			return n, errno
 		}
-		copied := copy(out, &buf);
-		n += copied;
-		out = out[copied:];
+		copied := copy(out, &buf)
+		n += copied
+		out = out[copied:]
 	}
 
-	return n, 0;
+	return n, 0
 }
 
 func PtracePeekText(pid int, addr uintptr, out []byte) (count int, errno int) {
@@ -438,50 +438,50 @@ func ptracePoke(pokeReq int, peekReq int, pid int, addr uintptr, data []byte) (c
 	// with the possibility of straddling an invalid page.
 
 	// Leading edge.
-	n := 0;
+	n := 0
 	if addr%sizeofPtr != 0 {
-		var buf [sizeofPtr]byte;
-		errno = ptrace(peekReq, pid, addr-addr%sizeofPtr, uintptr(unsafe.Pointer(&buf[0])));
+		var buf [sizeofPtr]byte
+		errno = ptrace(peekReq, pid, addr-addr%sizeofPtr, uintptr(unsafe.Pointer(&buf[0])))
 		if errno != 0 {
 			return 0, errno
 		}
-		n += copy(buf[addr%sizeofPtr:], data);
-		word := *((*uintptr)(unsafe.Pointer(&buf[0])));
-		errno = ptrace(pokeReq, pid, addr-addr%sizeofPtr, word);
+		n += copy(buf[addr%sizeofPtr:], data)
+		word := *((*uintptr)(unsafe.Pointer(&buf[0])))
+		errno = ptrace(pokeReq, pid, addr-addr%sizeofPtr, word)
 		if errno != 0 {
 			return 0, errno
 		}
-		data = data[n:];
+		data = data[n:]
 	}
 
 	// Interior.
 	for len(data) > sizeofPtr {
-		word := *((*uintptr)(unsafe.Pointer(&data[0])));
-		errno = ptrace(pokeReq, pid, addr+uintptr(n), word);
+		word := *((*uintptr)(unsafe.Pointer(&data[0])))
+		errno = ptrace(pokeReq, pid, addr+uintptr(n), word)
 		if errno != 0 {
 			return n, errno
 		}
-		n += sizeofPtr;
-		data = data[sizeofPtr:];
+		n += sizeofPtr
+		data = data[sizeofPtr:]
 	}
 
 	// Trailing edge.
 	if len(data) > 0 {
-		var buf [sizeofPtr]byte;
-		errno = ptrace(peekReq, pid, addr+uintptr(n), uintptr(unsafe.Pointer(&buf[0])));
+		var buf [sizeofPtr]byte
+		errno = ptrace(peekReq, pid, addr+uintptr(n), uintptr(unsafe.Pointer(&buf[0])))
 		if errno != 0 {
 			return n, errno
 		}
-		copy(&buf, data);
-		word := *((*uintptr)(unsafe.Pointer(&buf[0])));
-		errno = ptrace(pokeReq, pid, addr+uintptr(n), word);
+		copy(&buf, data)
+		word := *((*uintptr)(unsafe.Pointer(&buf[0])))
+		errno = ptrace(pokeReq, pid, addr+uintptr(n), word)
 		if errno != 0 {
 			return n, errno
 		}
-		n += len(data);
+		n += len(data)
 	}
 
-	return n, 0;
+	return n, 0
 }
 
 func PtracePokeText(pid int, addr uintptr, data []byte) (count int, errno int) {
@@ -505,21 +505,21 @@ func PtraceSetOptions(pid int, options int) (errno int) {
 }
 
 func PtraceGetEventMsg(pid int) (msg uint, errno int) {
-	var data _C_long;
-	errno = ptrace(PTRACE_GETEVENTMSG, pid, 0, uintptr(unsafe.Pointer(&data)));
-	msg = uint(data);
-	return;
+	var data _C_long
+	errno = ptrace(PTRACE_GETEVENTMSG, pid, 0, uintptr(unsafe.Pointer(&data)))
+	msg = uint(data)
+	return
 }
 
 func PtraceCont(pid int, signal int) (errno int) {
 	return ptrace(PTRACE_CONT, pid, 0, uintptr(signal))
 }
 
-func PtraceSingleStep(pid int) (errno int)	{ return ptrace(PTRACE_SINGLESTEP, pid, 0, 0) }
+func PtraceSingleStep(pid int) (errno int) { return ptrace(PTRACE_SINGLESTEP, pid, 0, 0) }
 
-func PtraceAttach(pid int) (errno int)	{ return ptrace(PTRACE_ATTACH, pid, 0, 0) }
+func PtraceAttach(pid int) (errno int) { return ptrace(PTRACE_ATTACH, pid, 0, 0) }
 
-func PtraceDetach(pid int) (errno int)	{ return ptrace(PTRACE_DETACH, pid, 0, 0) }
+func PtraceDetach(pid int) (errno int) { return ptrace(PTRACE_DETACH, pid, 0, 0) }
 
 // Sendto
 // Recvfrom
diff --git a/src/pkg/syscall/syscall_linux_386.go b/src/pkg/syscall/syscall_linux_386.go
index 8f212f32b2..4dfaddc43e 100644
--- a/src/pkg/syscall/syscall_linux_386.go
+++ b/src/pkg/syscall/syscall_linux_386.go
@@ -6,23 +6,23 @@ package syscall
 
 import "unsafe"
 
-func Getpagesize() int	{ return 4096 }
+func Getpagesize() int { return 4096 }
 
-func TimespecToNsec(ts Timespec) int64	{ return int64(ts.Sec)*1e9 + int64(ts.Nsec) }
+func TimespecToNsec(ts Timespec) int64 { return int64(ts.Sec)*1e9 + int64(ts.Nsec) }
 
 func NsecToTimespec(nsec int64) (ts Timespec) {
-	ts.Sec = int32(nsec / 1e9);
-	ts.Nsec = int32(nsec % 1e9);
-	return;
+	ts.Sec = int32(nsec / 1e9)
+	ts.Nsec = int32(nsec % 1e9)
+	return
 }
 
-func TimevalToNsec(tv Timeval) int64	{ return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }
+func TimevalToNsec(tv Timeval) int64 { return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }
 
 func NsecToTimeval(nsec int64) (tv Timeval) {
-	nsec += 999;	// round up to microsecond
-	tv.Sec = int32(nsec / 1e9);
-	tv.Usec = int32(nsec % 1e9 / 1e3);
-	return;
+	nsec += 999 // round up to microsecond
+	tv.Sec = int32(nsec / 1e9)
+	tv.Usec = int32(nsec % 1e9 / 1e3)
+	return
 }
 
 // 64-bit file system and 32-bit uid calls
@@ -64,102 +64,102 @@ func Seek(fd int, offset int64, whence int) (newoffset int64, errno int)
 
 const (
 	// see linux/net.h
-	_SOCKET		= 1;
-	_BIND		= 2;
-	_CONNECT	= 3;
-	_LISTEN		= 4;
-	_ACCEPT		= 5;
-	_GETSOCKNAME	= 6;
-	_GETPEERNAME	= 7;
-	_SOCKETPAIR	= 8;
-	_SEND		= 9;
-	_RECV		= 10;
-	_SENDTO		= 11;
-	_RECVFROM	= 12;
-	_SHUTDOWN	= 13;
-	_SETSOCKOPT	= 14;
-	_GETSOCKOPT	= 15;
-	_SENDMSG	= 16;
-	_RECVMSG	= 17;
+	_SOCKET      = 1
+	_BIND        = 2
+	_CONNECT     = 3
+	_LISTEN      = 4
+	_ACCEPT      = 5
+	_GETSOCKNAME = 6
+	_GETPEERNAME = 7
+	_SOCKETPAIR  = 8
+	_SEND        = 9
+	_RECV        = 10
+	_SENDTO      = 11
+	_RECVFROM    = 12
+	_SHUTDOWN    = 13
+	_SETSOCKOPT  = 14
+	_GETSOCKOPT  = 15
+	_SENDMSG     = 16
+	_RECVMSG     = 17
 )
 
 func socketcall(call int, a0, a1, a2, a3, a4, a5 uintptr) (n int, errno int)
 
 func accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, errno int) {
-	fd, errno = socketcall(_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0);
-	return;
+	fd, errno = socketcall(_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0)
+	return
 }
 
 func getsockname(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
-	_, errno = socketcall(_GETSOCKNAME, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0);
-	return;
+	_, errno = socketcall(_GETSOCKNAME, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0)
+	return
 }
 
 func getpeername(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
-	_, errno = socketcall(_GETPEERNAME, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0);
-	return;
+	_, errno = socketcall(_GETPEERNAME, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0)
+	return
 }
 
 func bind(s int, addr uintptr, addrlen _Socklen) (errno int) {
-	_, errno = socketcall(_BIND, uintptr(s), uintptr(addr), uintptr(addrlen), 0, 0, 0);
-	return;
+	_, errno = socketcall(_BIND, uintptr(s), uintptr(addr), uintptr(addrlen), 0, 0, 0)
+	return
 }
 
 func connect(s int, addr uintptr, addrlen _Socklen) (errno int) {
-	_, errno = socketcall(_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen), 0, 0, 0);
-	return;
+	_, errno = socketcall(_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen), 0, 0, 0)
+	return
 }
 
 func socket(domain int, typ int, proto int) (fd int, errno int) {
-	fd, errno = socketcall(_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto), 0, 0, 0);
-	return;
+	fd, errno = socketcall(_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto), 0, 0, 0)
+	return
 }
 
 func setsockopt(s int, level int, name int, val uintptr, vallen int) (errno int) {
-	_, errno = socketcall(_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0);
-	return;
+	_, errno = socketcall(_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)
+	return
 }
 
 func recvfrom(s int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, errno int) {
-	var base uintptr;
+	var base uintptr
 	if len(p) > 0 {
 		base = uintptr(unsafe.Pointer(&p[0]))
 	}
-	n, errno = socketcall(_RECVFROM, uintptr(s), base, uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)));
-	return;
+	n, errno = socketcall(_RECVFROM, uintptr(s), base, uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
+	return
 }
 
 func sendto(s int, p []byte, flags int, to uintptr, addrlen _Socklen) (errno int) {
-	var base uintptr;
+	var base uintptr
 	if len(p) > 0 {
 		base = uintptr(unsafe.Pointer(&p[0]))
 	}
-	_, errno = socketcall(_SENDTO, uintptr(s), base, uintptr(len(p)), uintptr(flags), to, uintptr(addrlen));
-	return;
+	_, errno = socketcall(_SENDTO, uintptr(s), base, uintptr(len(p)), uintptr(flags), to, uintptr(addrlen))
+	return
 }
 
 func Listen(s int, n int) (errno int) {
-	_, errno = socketcall(_LISTEN, uintptr(s), uintptr(n), 0, 0, 0, 0);
-	return;
+	_, errno = socketcall(_LISTEN, uintptr(s), uintptr(n), 0, 0, 0, 0)
+	return
 }
 
 func Shutdown(s, how int) (errno int) {
-	_, errno = socketcall(_SHUTDOWN, uintptr(s), uintptr(how), 0, 0, 0, 0);
-	return;
+	_, errno = socketcall(_SHUTDOWN, uintptr(s), uintptr(how), 0, 0, 0, 0)
+	return
 }
 
 func Fstatfs(fd int, buf *Statfs_t) (errno int) {
-	_, _, e1 := Syscall(SYS_FSTATFS64, uintptr(fd), uintptr(unsafe.Sizeof(*buf)), uintptr(unsafe.Pointer(buf)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSTATFS64, uintptr(fd), uintptr(unsafe.Sizeof(*buf)), uintptr(unsafe.Pointer(buf)))
+	errno = int(e1)
+	return
 }
 
 func Statfs(path string, buf *Statfs_t) (errno int) {
-	_, _, e1 := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Sizeof(*buf)), uintptr(unsafe.Pointer(buf)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Sizeof(*buf)), uintptr(unsafe.Pointer(buf)))
+	errno = int(e1)
+	return
 }
 
-func (r *PtraceRegs) PC() uint64	{ return uint64(uint32(r.Eip)) }
+func (r *PtraceRegs) PC() uint64 { return uint64(uint32(r.Eip)) }
 
-func (r *PtraceRegs) SetPC(pc uint64)	{ r.Eip = int32(pc) }
+func (r *PtraceRegs) SetPC(pc uint64) { r.Eip = int32(pc) }
diff --git a/src/pkg/syscall/syscall_linux_amd64.go b/src/pkg/syscall/syscall_linux_amd64.go
index e3a3daed66..8e5471af72 100644
--- a/src/pkg/syscall/syscall_linux_amd64.go
+++ b/src/pkg/syscall/syscall_linux_amd64.go
@@ -42,25 +42,25 @@ package syscall
 //sys	recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, errno int)
 //sys	sendto(s int, buf []byte, flags int, to uintptr, addrlen _Socklen) (errno int)
 
-func Getpagesize() int	{ return 4096 }
+func Getpagesize() int { return 4096 }
 
-func TimespecToNsec(ts Timespec) int64	{ return int64(ts.Sec)*1e9 + int64(ts.Nsec) }
+func TimespecToNsec(ts Timespec) int64 { return int64(ts.Sec)*1e9 + int64(ts.Nsec) }
 
 func NsecToTimespec(nsec int64) (ts Timespec) {
-	ts.Sec = nsec / 1e9;
-	ts.Nsec = nsec % 1e9;
-	return;
+	ts.Sec = nsec / 1e9
+	ts.Nsec = nsec % 1e9
+	return
 }
 
-func TimevalToNsec(tv Timeval) int64	{ return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }
+func TimevalToNsec(tv Timeval) int64 { return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }
 
 func NsecToTimeval(nsec int64) (tv Timeval) {
-	nsec += 999;	// round up to microsecond
-	tv.Sec = nsec / 1e9;
-	tv.Usec = nsec % 1e9 / 1e3;
-	return;
+	nsec += 999 // round up to microsecond
+	tv.Sec = nsec / 1e9
+	tv.Usec = nsec % 1e9 / 1e3
+	return
 }
 
-func (r *PtraceRegs) PC() uint64	{ return r.Rip }
+func (r *PtraceRegs) PC() uint64 { return r.Rip }
 
-func (r *PtraceRegs) SetPC(pc uint64)	{ r.Rip = pc }
+func (r *PtraceRegs) SetPC(pc uint64) { r.Rip = pc }
diff --git a/src/pkg/syscall/syscall_linux_arm.go b/src/pkg/syscall/syscall_linux_arm.go
index 86731bf41e..390f8a8533 100644
--- a/src/pkg/syscall/syscall_linux_arm.go
+++ b/src/pkg/syscall/syscall_linux_arm.go
@@ -4,21 +4,21 @@
 
 package syscall
 
-func Getpagesize() int	{ return 4096 }
+func Getpagesize() int { return 4096 }
 
-func TimespecToNsec(ts Timespec) int64	{ return int64(ts.Sec)*1e9 + int64(ts.Nsec) }
+func TimespecToNsec(ts Timespec) int64 { return int64(ts.Sec)*1e9 + int64(ts.Nsec) }
 
 func NsecToTimespec(nsec int64) (ts Timespec) {
-	ts.Sec = int32(nsec / 1e9);
-	ts.Nsec = int32(nsec % 1e9);
-	return;
+	ts.Sec = int32(nsec / 1e9)
+	ts.Nsec = int32(nsec % 1e9)
+	return
 }
 
 func NsecToTimeval(nsec int64) (tv Timeval) {
-	nsec += 999;	// round up to microsecond
-	tv.Sec = int32(nsec / 1e9);
-	tv.Usec = int32(nsec % 1e9 / 1e3);
-	return;
+	nsec += 999 // round up to microsecond
+	tv.Sec = int32(nsec / 1e9)
+	tv.Usec = int32(nsec % 1e9 / 1e3)
+	return
 }
 
 //sys	accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, errno int)
@@ -58,6 +58,6 @@ func NsecToTimeval(nsec int64) (tv Timeval) {
 //sys	Statfs(path string, buf *Statfs_t) (errno int)
 
 // TODO(kaib): add support for tracing
-func (r *PtraceRegs) PC() uint64	{ return 0 }
+func (r *PtraceRegs) PC() uint64 { return 0 }
 
-func (r *PtraceRegs) SetPC(pc uint64)	{}
+func (r *PtraceRegs) SetPC(pc uint64) {}
diff --git a/src/pkg/syscall/syscall_nacl.go b/src/pkg/syscall/syscall_nacl.go
index a3f6740c9a..6a5d9c2d69 100644
--- a/src/pkg/syscall/syscall_nacl.go
+++ b/src/pkg/syscall/syscall_nacl.go
@@ -54,8 +54,8 @@ func Seek(fd int, offset int64, whence int) (newoffset int64, errno int) {
 	if int64(int32(offset)) != offset {
 		return 0, ERANGE
 	}
-	o, _, e := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence));
-	return int64(o), int(e);
+	o, _, e := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))
+	return int64(o), int(e)
 }
 
 // Sleep by waiting on a condition variable that will never be signaled.
@@ -63,34 +63,34 @@ func Seek(fd int, offset int64, whence int) (newoffset int64, errno int) {
 var tcv, tmu int
 
 func init() {
-	tmu, _ = MutexCreate();
-	tcv, _ = CondCreate();
+	tmu, _ = MutexCreate()
+	tcv, _ = CondCreate()
 }
 
 func Sleep(ns int64) (errno int) {
-	ts := NsecToTimespec(ns);
-	var tv Timeval;
+	ts := NsecToTimespec(ns)
+	var tv Timeval
 	if errno = Gettimeofday(&tv); errno != 0 {
 		return
 	}
-	ts.Sec += tv.Sec;
-	ts.Nsec += tv.Usec * 1000;
+	ts.Sec += tv.Sec
+	ts.Nsec += tv.Usec * 1000
 	switch {
 	case ts.Nsec >= 1e9:
-		ts.Nsec -= 1e9;
-		ts.Sec++;
+		ts.Nsec -= 1e9
+		ts.Sec++
 	case ts.Nsec <= -1e9:
-		ts.Nsec += 1e9;
-		ts.Sec--;
+		ts.Nsec += 1e9
+		ts.Sec--
 	}
 	if errno = MutexLock(tmu); errno != 0 {
 		return
 	}
-	errno = CondTimedWaitAbs(tcv, tmu, &ts);
+	errno = CondTimedWaitAbs(tcv, tmu, &ts)
 	if e := MutexUnlock(tmu); e != 0 && errno == 0 {
 		errno = e
 	}
-	return;
+	return
 }
 
 // Implemented in NaCl but not here; maybe later:
@@ -111,10 +111,10 @@ func Sleep(ns int64) (errno int) {
 // Not implemented in NaCl but needed to compile other packages.
 
 const (
-	SIGTRAP = 5;
+	SIGTRAP = 5
 )
 
-func Pipe(p []int) (errno int)	{ return ENACL }
+func Pipe(p []int) (errno int) { return ENACL }
 
 func fcntl(fd, cmd, arg int) (val int, errno int) {
 	return 0, ENACL
@@ -128,25 +128,25 @@ func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
 	return 0, ENACL
 }
 
-func Mkdir(path string, mode int) (errno int)	{ return ENACL }
+func Mkdir(path string, mode int) (errno int) { return ENACL }
 
 func Lstat(path string, stat *Stat_t) (errno int) {
 	return ENACL
 }
 
-func Chdir(path string) (errno int)	{ return ENACL }
+func Chdir(path string) (errno int) { return ENACL }
 
-func Fchdir(fd int) (errno int)	{ return ENACL }
+func Fchdir(fd int) (errno int) { return ENACL }
 
-func Unlink(path string) (errno int)	{ return ENACL }
+func Unlink(path string) (errno int) { return ENACL }
 
-func Rmdir(path string) (errno int)	{ return ENACL }
+func Rmdir(path string) (errno int) { return ENACL }
 
 func Link(oldpath, newpath string) (errno int) {
 	return ENACL
 }
 
-func Symlink(path, link string) (errno int)	{ return ENACL }
+func Symlink(path, link string) (errno int) { return ENACL }
 
 func Readlink(path string, buf []byte) (n int, errno int) {
 	return 0, ENACL
@@ -156,7 +156,7 @@ func Rename(oldpath, newpath string) (errno int) {
 	return ENACL
 }
 
-func Fchmod(fd int, mode int) (errno int)	{ return ENACL }
+func Fchmod(fd int, mode int) (errno int) { return ENACL }
 
 func Chown(path string, uid int, gid int) (errno int) {
 	return ENACL
@@ -184,65 +184,65 @@ func Ftruncate(fd int, length int64) (errno int) {
 
 const ImplementsGetwd = true
 
-func Getwd() (wd string, errno int)	{ return "", ENACL }
+func Getwd() (wd string, errno int) { return "", ENACL }
 
-func Getuid() (uid int)	{ return -1 }
+func Getuid() (uid int) { return -1 }
 
-func Geteuid() (euid int)	{ return -1 }
+func Geteuid() (euid int) { return -1 }
 
-func Getgid() (gid int)	{ return -1 }
+func Getgid() (gid int) { return -1 }
 
-func Getegid() (egid int)	{ return -1 }
+func Getegid() (egid int) { return -1 }
 
-func Getppid() (ppid int)	{ return -1 }
+func Getppid() (ppid int) { return -1 }
 
-func Getgroups() (gids []int, errno int)	{ return nil, ENACL }
+func Getgroups() (gids []int, errno int) { return nil, ENACL }
 
 type Sockaddr interface {
-	sockaddr();
+	sockaddr()
 }
 
 type SockaddrInet4 struct {
-	Port	int;
-	Addr	[4]byte;
+	Port int
+	Addr [4]byte
 }
 
-func (*SockaddrInet4) sockaddr()	{}
+func (*SockaddrInet4) sockaddr() {}
 
 type SockaddrInet6 struct {
-	Port	int;
-	Addr	[16]byte;
+	Port int
+	Addr [16]byte
 }
 
-func (*SockaddrInet6) sockaddr()	{}
+func (*SockaddrInet6) sockaddr() {}
 
 type SockaddrUnix struct {
-	Name string;
+	Name string
 }
 
-func (*SockaddrUnix) sockaddr()	{}
+func (*SockaddrUnix) sockaddr() {}
 
 const (
-	AF_INET	= 1 + iota;
-	AF_INET6;
-	AF_UNIX;
-	IPPROTO_TCP;
-	SOCK_DGRAM;
-	SOCK_STREAM;
-	SOL_SOCKET;
-	SOMAXCONN;
-	SO_DONTROUTE;
-	SO_KEEPALIVE;
-	SO_LINGER;
-	SO_RCVBUF;
-	SO_REUSEADDR;
-	SO_SNDBUF;
-	TCP_NODELAY;
-	WNOHANG;
-	WSTOPPED;
-	PTRACE_TRACEME;
-	SO_BROADCAST	= 0;
-	SHUT_RDWR	= 0;
+	AF_INET = 1 + iota
+	AF_INET6
+	AF_UNIX
+	IPPROTO_TCP
+	SOCK_DGRAM
+	SOCK_STREAM
+	SOL_SOCKET
+	SOMAXCONN
+	SO_DONTROUTE
+	SO_KEEPALIVE
+	SO_LINGER
+	SO_RCVBUF
+	SO_REUSEADDR
+	SO_SNDBUF
+	TCP_NODELAY
+	WNOHANG
+	WSTOPPED
+	PTRACE_TRACEME
+	SO_BROADCAST = 0
+	SHUT_RDWR    = 0
 )
 
 func Accept(fd int) (nfd int, sa Sockaddr, errno int) {
@@ -257,9 +257,9 @@ func Getpeername(fd int) (sa Sockaddr, errno int) {
 	return nil, ENACL
 }
 
-func Bind(fd int, sa Sockaddr) (errno int)	{ return ENACL }
+func Bind(fd int, sa Sockaddr) (errno int) { return ENACL }
 
-func Connect(fd int, sa Sockaddr) (errno int)	{ return ENACL }
+func Connect(fd int, sa Sockaddr) (errno int) { return ENACL }
 
 func Socket(domain, typ, proto int) (fd, errno int) {
 	return 0, ENACL
@@ -269,7 +269,7 @@ func SetsockoptInt(fd, level, opt int, value int) (errno int) {
 	return ENACL
 }
 
-func Shutdown(fd, how int) (errno int)	{ return ENACL }
+func Shutdown(fd, how int) (errno int) { return ENACL }
 
 func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, errno int) {
 	return 0, nil, ENACL
@@ -284,33 +284,33 @@ func SetsockoptTimeval(fd, level, opt int, tv *Timeval) (errno int) {
 }
 
 type Linger struct {
-	Onoff	int32;
-	Linger	int32;
+	Onoff  int32
+	Linger int32
 }
 
 func SetsockoptLinger(fd, level, opt int, l *Linger) (errno int) {
 	return ENACL
 }
 
-func Listen(s int, n int) (errno int)	{ return ENACL }
+func Listen(s int, n int) (errno int) { return ENACL }
 
 type Rusage struct {
-	Utime		Timeval;
-	Stime		Timeval;
-	Maxrss		int32;
-	Ixrss		int32;
-	Idrss		int32;
-	Isrss		int32;
-	Minflt		int32;
-	Majflt		int32;
-	Nswap		int32;
-	Inblock		int32;
-	Oublock		int32;
-	Msgsnd		int32;
-	Msgrcv		int32;
-	Nsignals	int32;
-	Nvcsw		int32;
-	Nivcsw		int32;
+	Utime    Timeval
+	Stime    Timeval
+	Maxrss   int32
+	Ixrss    int32
+	Idrss    int32
+	Isrss    int32
+	Minflt   int32
+	Majflt   int32
+	Nswap    int32
+	Inblock  int32
+	Oublock  int32
+	Msgsnd   int32
+	Msgrcv   int32
+	Nsignals int32
+	Nvcsw    int32
+	Nivcsw   int32
 }
 
 func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, errno int) {
@@ -319,20 +319,20 @@ func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int,
 
 type WaitStatus uint32
 
-func (WaitStatus) Exited() bool	{ return false }
+func (WaitStatus) Exited() bool { return false }
 
-func (WaitStatus) ExitStatus() int	{ return -1 }
+func (WaitStatus) ExitStatus() int { return -1 }
 
-func (WaitStatus) Signal() int	{ return -1 }
+func (WaitStatus) Signal() int { return -1 }
 
-func (WaitStatus) CoreDump() bool	{ return false }
+func (WaitStatus) CoreDump() bool { return false }
 
-func (WaitStatus) Stopped() bool	{ return false }
+func (WaitStatus) Stopped() bool { return false }
 
-func (WaitStatus) Continued() bool	{ return false }
+func (WaitStatus) Continued() bool { return false }
 
-func (WaitStatus) StopSignal() int	{ return -1 }
+func (WaitStatus) StopSignal() int { return -1 }
 
-func (WaitStatus) Signaled() bool	{ return false }
+func (WaitStatus) Signaled() bool { return false }
 
-func (WaitStatus) TrapCause() int	{ return -1 }
+func (WaitStatus) TrapCause() int { return -1 }
diff --git a/src/pkg/syscall/syscall_nacl_386.go b/src/pkg/syscall/syscall_nacl_386.go
index 22626cbd3b..86ed66f886 100644
--- a/src/pkg/syscall/syscall_nacl_386.go
+++ b/src/pkg/syscall/syscall_nacl_386.go
@@ -4,16 +4,16 @@
 
 package syscall
 
-func Getpagesize() int	{ return 4096 }
+func Getpagesize() int { return 4096 }
 
 func NsecToTimeval(nsec int64) (tv Timeval) {
-	tv.Sec = int32(nsec / 1e9);
-	tv.Usec = int32(nsec % 1e9 / 1e3);
-	return;
+	tv.Sec = int32(nsec / 1e9)
+	tv.Usec = int32(nsec % 1e9 / 1e3)
+	return
 }
 
 func NsecToTimespec(nsec int64) (ts Timespec) {
-	ts.Sec = int32(nsec / 1e9);
-	ts.Nsec = int32(nsec % 1e9);
-	return;
+	ts.Sec = int32(nsec / 1e9)
+	ts.Nsec = int32(nsec % 1e9)
+	return
 }
diff --git a/src/pkg/syscall/zerrors_darwin_386.go b/src/pkg/syscall/zerrors_darwin_386.go
index 84a07e3c25..76660a8445 100644
--- a/src/pkg/syscall/zerrors_darwin_386.go
+++ b/src/pkg/syscall/zerrors_darwin_386.go
@@ -9,525 +9,525 @@ package syscall
 
 // Constants
 const (
-	AF_APPLETALK			= 0x10;
-	AF_CCITT			= 0xa;
-	AF_CHAOS			= 0x5;
-	AF_CNT				= 0x15;
-	AF_COIP				= 0x14;
-	AF_DATAKIT			= 0x9;
-	AF_DECnet			= 0xc;
-	AF_DLI				= 0xd;
-	AF_E164				= 0x1c;
-	AF_ECMA				= 0x8;
-	AF_HYLINK			= 0xf;
-	AF_IEEE80211			= 0x25;
-	AF_IMPLINK			= 0x3;
-	AF_INET				= 0x2;
-	AF_INET6			= 0x1e;
-	AF_IPX				= 0x17;
-	AF_ISDN				= 0x1c;
-	AF_ISO				= 0x7;
-	AF_LAT				= 0xe;
-	AF_LINK				= 0x12;
-	AF_LOCAL			= 0x1;
-	AF_MAX				= 0x26;
-	AF_NATM				= 0x1f;
-	AF_NDRV				= 0x1b;
-	AF_NETBIOS			= 0x21;
-	AF_NS				= 0x6;
-	AF_OSI				= 0x7;
-	AF_PPP				= 0x22;
-	AF_PUP				= 0x4;
-	AF_RESERVED_36			= 0x24;
-	AF_ROUTE			= 0x11;
-	AF_SIP				= 0x18;
-	AF_SNA				= 0xb;
-	AF_SYSTEM			= 0x20;
-	AF_UNIX				= 0x1;
-	AF_UNSPEC			= 0;
-	E2BIG				= 0x7;
-	EACCES				= 0xd;
-	EADDRINUSE			= 0x30;
-	EADDRNOTAVAIL			= 0x31;
-	EAFNOSUPPORT			= 0x2f;
-	EAGAIN				= 0x23;
-	EALREADY			= 0x25;
-	EAUTH				= 0x50;
-	EBADARCH			= 0x56;
-	EBADEXEC			= 0x55;
-	EBADF				= 0x9;
-	EBADMACHO			= 0x58;
-	EBADMSG				= 0x5e;
-	EBADRPC				= 0x48;
-	EBUSY				= 0x10;
-	ECANCELED			= 0x59;
-	ECHILD				= 0xa;
-	ECONNABORTED			= 0x35;
-	ECONNREFUSED			= 0x3d;
-	ECONNRESET			= 0x36;
-	EDEADLK				= 0xb;
-	EDESTADDRREQ			= 0x27;
-	EDEVERR				= 0x53;
-	EDOM				= 0x21;
-	EDQUOT				= 0x45;
-	EEXIST				= 0x11;
-	EFAULT				= 0xe;
-	EFBIG				= 0x1b;
-	EFTYPE				= 0x4f;
-	EHOSTDOWN			= 0x40;
-	EHOSTUNREACH			= 0x41;
-	EIDRM				= 0x5a;
-	EILSEQ				= 0x5c;
-	EINPROGRESS			= 0x24;
-	EINTR				= 0x4;
-	EINVAL				= 0x16;
-	EIO				= 0x5;
-	EISCONN				= 0x38;
-	EISDIR				= 0x15;
-	ELAST				= 0x67;
-	ELOOP				= 0x3e;
-	EMFILE				= 0x18;
-	EMLINK				= 0x1f;
-	EMSGSIZE			= 0x28;
-	EMULTIHOP			= 0x5f;
-	ENAMETOOLONG			= 0x3f;
-	ENEEDAUTH			= 0x51;
-	ENETDOWN			= 0x32;
-	ENETRESET			= 0x34;
-	ENETUNREACH			= 0x33;
-	ENFILE				= 0x17;
-	ENOATTR				= 0x5d;
-	ENOBUFS				= 0x37;
-	ENODATA				= 0x60;
-	ENODEV				= 0x13;
-	ENOENT				= 0x2;
-	ENOEXEC				= 0x8;
-	ENOLCK				= 0x4d;
-	ENOLINK				= 0x61;
-	ENOMEM				= 0xc;
-	ENOMSG				= 0x5b;
-	ENOPOLICY			= 0x67;
-	ENOPROTOOPT			= 0x2a;
-	ENOSPC				= 0x1c;
-	ENOSR				= 0x62;
-	ENOSTR				= 0x63;
-	ENOSYS				= 0x4e;
-	ENOTBLK				= 0xf;
-	ENOTCONN			= 0x39;
-	ENOTDIR				= 0x14;
-	ENOTEMPTY			= 0x42;
-	ENOTSOCK			= 0x26;
-	ENOTSUP				= 0x2d;
-	ENOTTY				= 0x19;
-	ENXIO				= 0x6;
-	EOPNOTSUPP			= 0x66;
-	EOVERFLOW			= 0x54;
-	EPERM				= 0x1;
-	EPFNOSUPPORT			= 0x2e;
-	EPIPE				= 0x20;
-	EPROCLIM			= 0x43;
-	EPROCUNAVAIL			= 0x4c;
-	EPROGMISMATCH			= 0x4b;
-	EPROGUNAVAIL			= 0x4a;
-	EPROTO				= 0x64;
-	EPROTONOSUPPORT			= 0x2b;
-	EPROTOTYPE			= 0x29;
-	EPWROFF				= 0x52;
-	ERANGE				= 0x22;
-	EREMOTE				= 0x47;
-	EROFS				= 0x1e;
-	ERPCMISMATCH			= 0x49;
-	ESHLIBVERS			= 0x57;
-	ESHUTDOWN			= 0x3a;
-	ESOCKTNOSUPPORT			= 0x2c;
-	ESPIPE				= 0x1d;
-	ESRCH				= 0x3;
-	ESTALE				= 0x46;
-	ETIME				= 0x65;
-	ETIMEDOUT			= 0x3c;
-	ETOOMANYREFS			= 0x3b;
-	ETXTBSY				= 0x1a;
-	EUSERS				= 0x44;
-	EVFILT_AIO			= -0x3;
-	EVFILT_FS			= -0x9;
-	EVFILT_MACHPORT			= -0x8;
-	EVFILT_PROC			= -0x5;
-	EVFILT_READ			= -0x1;
-	EVFILT_SESSION			= -0xb;
-	EVFILT_SIGNAL			= -0x6;
-	EVFILT_SYSCOUNT			= 0xb;
-	EVFILT_THREADMARKER		= 0xb;
-	EVFILT_TIMER			= -0x7;
-	EVFILT_USER			= -0xa;
-	EVFILT_VNODE			= -0x4;
-	EVFILT_WRITE			= -0x2;
-	EV_ADD				= 0x1;
-	EV_CLEAR			= 0x20;
-	EV_DELETE			= 0x2;
-	EV_DISABLE			= 0x8;
-	EV_DISPATCH			= 0x80;
-	EV_ENABLE			= 0x4;
-	EV_EOF				= 0x8000;
-	EV_ERROR			= 0x4000;
-	EV_FLAG0			= 0x1000;
-	EV_FLAG1			= 0x2000;
-	EV_ONESHOT			= 0x10;
-	EV_OOBAND			= 0x2000;
-	EV_POLL				= 0x1000;
-	EV_RECEIPT			= 0x40;
-	EV_SYSFLAGS			= 0xf000;
-	EV_TRIGGER			= 0x100;
-	EWOULDBLOCK			= 0x23;
-	EXDEV				= 0x12;
-	FD_CLOEXEC			= 0x1;
-	FD_SETSIZE			= 0x400;
-	F_ADDFILESIGS			= 0x3d;
-	F_ADDSIGS			= 0x3b;
-	F_ALLOCATEALL			= 0x4;
-	F_ALLOCATECONTIG		= 0x2;
-	F_CHKCLEAN			= 0x29;
-	F_DUPFD				= 0;
-	F_FREEZE_FS			= 0x35;
-	F_FULLFSYNC			= 0x33;
-	F_GETFD				= 0x1;
-	F_GETFL				= 0x3;
-	F_GETLK				= 0x7;
-	F_GETOWN			= 0x5;
-	F_GETPATH			= 0x32;
-	F_GLOBAL_NOCACHE		= 0x37;
-	F_LOG2PHYS			= 0x31;
-	F_MARKDEPENDENCY		= 0x3c;
-	F_NOCACHE			= 0x30;
-	F_PATHPKG_CHECK			= 0x34;
-	F_PEOFPOSMODE			= 0x3;
-	F_PREALLOCATE			= 0x2a;
-	F_RDADVISE			= 0x2c;
-	F_RDAHEAD			= 0x2d;
-	F_RDLCK				= 0x1;
-	F_READBOOTSTRAP			= 0x2e;
-	F_SETFD				= 0x2;
-	F_SETFL				= 0x4;
-	F_SETLK				= 0x8;
-	F_SETLKW			= 0x9;
-	F_SETOWN			= 0x6;
-	F_SETSIZE			= 0x2b;
-	F_THAW_FS			= 0x36;
-	F_UNLCK				= 0x2;
-	F_VOLPOSMODE			= 0x4;
-	F_WRITEBOOTSTRAP		= 0x2f;
-	F_WRLCK				= 0x3;
-	IPPROTO_3PC			= 0x22;
-	IPPROTO_ADFS			= 0x44;
-	IPPROTO_AH			= 0x33;
-	IPPROTO_AHIP			= 0x3d;
-	IPPROTO_APES			= 0x63;
-	IPPROTO_ARGUS			= 0xd;
-	IPPROTO_AX25			= 0x5d;
-	IPPROTO_BHA			= 0x31;
-	IPPROTO_BLT			= 0x1e;
-	IPPROTO_BRSATMON		= 0x4c;
-	IPPROTO_CFTP			= 0x3e;
-	IPPROTO_CHAOS			= 0x10;
-	IPPROTO_CMTP			= 0x26;
-	IPPROTO_CPHB			= 0x49;
-	IPPROTO_CPNX			= 0x48;
-	IPPROTO_DDP			= 0x25;
-	IPPROTO_DGP			= 0x56;
-	IPPROTO_DIVERT			= 0xfe;
-	IPPROTO_DONE			= 0x101;
-	IPPROTO_DSTOPTS			= 0x3c;
-	IPPROTO_EGP			= 0x8;
-	IPPROTO_EMCON			= 0xe;
-	IPPROTO_ENCAP			= 0x62;
-	IPPROTO_EON			= 0x50;
-	IPPROTO_ESP			= 0x32;
-	IPPROTO_ETHERIP			= 0x61;
-	IPPROTO_FRAGMENT		= 0x2c;
-	IPPROTO_GGP			= 0x3;
-	IPPROTO_GMTP			= 0x64;
-	IPPROTO_GRE			= 0x2f;
-	IPPROTO_HELLO			= 0x3f;
-	IPPROTO_HMP			= 0x14;
-	IPPROTO_HOPOPTS			= 0;
-	IPPROTO_ICMP			= 0x1;
-	IPPROTO_ICMPV6			= 0x3a;
-	IPPROTO_IDP			= 0x16;
-	IPPROTO_IDPR			= 0x23;
-	IPPROTO_IDRP			= 0x2d;
-	IPPROTO_IGMP			= 0x2;
-	IPPROTO_IGP			= 0x55;
-	IPPROTO_IGRP			= 0x58;
-	IPPROTO_IL			= 0x28;
-	IPPROTO_INLSP			= 0x34;
-	IPPROTO_INP			= 0x20;
-	IPPROTO_IP			= 0;
-	IPPROTO_IPCOMP			= 0x6c;
-	IPPROTO_IPCV			= 0x47;
-	IPPROTO_IPEIP			= 0x5e;
-	IPPROTO_IPIP			= 0x4;
-	IPPROTO_IPPC			= 0x43;
-	IPPROTO_IPV4			= 0x4;
-	IPPROTO_IPV6			= 0x29;
-	IPPROTO_IRTP			= 0x1c;
-	IPPROTO_KRYPTOLAN		= 0x41;
-	IPPROTO_LARP			= 0x5b;
-	IPPROTO_LEAF1			= 0x19;
-	IPPROTO_LEAF2			= 0x1a;
-	IPPROTO_MAX			= 0x100;
-	IPPROTO_MAXID			= 0x34;
-	IPPROTO_MEAS			= 0x13;
-	IPPROTO_MHRP			= 0x30;
-	IPPROTO_MICP			= 0x5f;
-	IPPROTO_MTP			= 0x5c;
-	IPPROTO_MUX			= 0x12;
-	IPPROTO_ND			= 0x4d;
-	IPPROTO_NHRP			= 0x36;
-	IPPROTO_NONE			= 0x3b;
-	IPPROTO_NSP			= 0x1f;
-	IPPROTO_NVPII			= 0xb;
-	IPPROTO_OSPFIGP			= 0x59;
-	IPPROTO_PGM			= 0x71;
-	IPPROTO_PIGP			= 0x9;
-	IPPROTO_PIM			= 0x67;
-	IPPROTO_PRM			= 0x15;
-	IPPROTO_PUP			= 0xc;
-	IPPROTO_PVP			= 0x4b;
-	IPPROTO_RAW			= 0xff;
-	IPPROTO_RCCMON			= 0xa;
-	IPPROTO_RDP			= 0x1b;
-	IPPROTO_ROUTING			= 0x2b;
-	IPPROTO_RSVP			= 0x2e;
-	IPPROTO_RVD			= 0x42;
-	IPPROTO_SATEXPAK		= 0x40;
-	IPPROTO_SATMON			= 0x45;
-	IPPROTO_SCCSP			= 0x60;
-	IPPROTO_SDRP			= 0x2a;
-	IPPROTO_SEP			= 0x21;
-	IPPROTO_SRPC			= 0x5a;
-	IPPROTO_ST			= 0x7;
-	IPPROTO_SVMTP			= 0x52;
-	IPPROTO_SWIPE			= 0x35;
-	IPPROTO_TCF			= 0x57;
-	IPPROTO_TCP			= 0x6;
-	IPPROTO_TP			= 0x1d;
-	IPPROTO_TPXX			= 0x27;
-	IPPROTO_TRUNK1			= 0x17;
-	IPPROTO_TRUNK2			= 0x18;
-	IPPROTO_TTP			= 0x54;
-	IPPROTO_UDP			= 0x11;
-	IPPROTO_VINES			= 0x53;
-	IPPROTO_VISA			= 0x46;
-	IPPROTO_VMTP			= 0x51;
-	IPPROTO_WBEXPAK			= 0x4f;
-	IPPROTO_WBMON			= 0x4e;
-	IPPROTO_WSN			= 0x4a;
-	IPPROTO_XNET			= 0xf;
-	IPPROTO_XTP			= 0x24;
-	IP_ADD_MEMBERSHIP		= 0xc;
-	IP_BOUND_IF			= 0x19;
-	IP_DEFAULT_MULTICAST_LOOP	= 0x1;
-	IP_DEFAULT_MULTICAST_TTL	= 0x1;
-	IP_DROP_MEMBERSHIP		= 0xd;
-	IP_DUMMYNET_CONFIGURE		= 0x3c;
-	IP_DUMMYNET_DEL			= 0x3d;
-	IP_DUMMYNET_FLUSH		= 0x3e;
-	IP_DUMMYNET_GET			= 0x40;
-	IP_FAITH			= 0x16;
-	IP_FW_ADD			= 0x28;
-	IP_FW_DEL			= 0x29;
-	IP_FW_FLUSH			= 0x2a;
-	IP_FW_GET			= 0x2c;
-	IP_FW_RESETLOG			= 0x2d;
-	IP_FW_ZERO			= 0x2b;
-	IP_HDRINCL			= 0x2;
-	IP_IPSEC_POLICY			= 0x15;
-	IP_MAX_MEMBERSHIPS		= 0x14;
-	IP_MULTICAST_IF			= 0x9;
-	IP_MULTICAST_LOOP		= 0xb;
-	IP_MULTICAST_TTL		= 0xa;
-	IP_MULTICAST_VIF		= 0xe;
-	IP_NAT__XXX			= 0x37;
-	IP_OLD_FW_ADD			= 0x32;
-	IP_OLD_FW_DEL			= 0x33;
-	IP_OLD_FW_FLUSH			= 0x34;
-	IP_OLD_FW_GET			= 0x36;
-	IP_OLD_FW_RESETLOG		= 0x38;
-	IP_OLD_FW_ZERO			= 0x35;
-	IP_OPTIONS			= 0x1;
-	IP_PORTRANGE			= 0x13;
-	IP_PORTRANGE_DEFAULT		= 0;
-	IP_PORTRANGE_HIGH		= 0x1;
-	IP_PORTRANGE_LOW		= 0x2;
-	IP_RECVDSTADDR			= 0x7;
-	IP_RECVIF			= 0x14;
-	IP_RECVOPTS			= 0x5;
-	IP_RECVRETOPTS			= 0x6;
-	IP_RECVTTL			= 0x18;
-	IP_RETOPTS			= 0x8;
-	IP_RSVP_OFF			= 0x10;
-	IP_RSVP_ON			= 0xf;
-	IP_RSVP_VIF_OFF			= 0x12;
-	IP_RSVP_VIF_ON			= 0x11;
-	IP_STRIPHDR			= 0x17;
-	IP_TOS				= 0x3;
-	IP_TRAFFIC_MGT_BACKGROUND	= 0x41;
-	IP_TTL				= 0x4;
-	O_ACCMODE			= 0x3;
-	O_ALERT				= 0x20000000;
-	O_APPEND			= 0x8;
-	O_ASYNC				= 0x40;
-	O_CREAT				= 0x200;
-	O_DIRECTORY			= 0x100000;
-	O_DSYNC				= 0x400000;
-	O_EVTONLY			= 0x8000;
-	O_EXCL				= 0x800;
-	O_EXLOCK			= 0x20;
-	O_FSYNC				= 0x80;
-	O_NDELAY			= 0x4;
-	O_NOCTTY			= 0x20000;
-	O_NOFOLLOW			= 0x100;
-	O_NONBLOCK			= 0x4;
-	O_POPUP				= 0x80000000;
-	O_RDONLY			= 0;
-	O_RDWR				= 0x2;
-	O_SHLOCK			= 0x10;
-	O_SYMLINK			= 0x200000;
-	O_SYNC				= 0x80;
-	O_TRUNC				= 0x400;
-	O_WRONLY			= 0x1;
-	SHUT_RD				= 0;
-	SHUT_RDWR			= 0x2;
-	SHUT_WR				= 0x1;
-	SIGABRT				= 0x6;
-	SIGALRM				= 0xe;
-	SIGBUS				= 0xa;
-	SIGCHLD				= 0x14;
-	SIGCONT				= 0x13;
-	SIGEMT				= 0x7;
-	SIGFPE				= 0x8;
-	SIGHUP				= 0x1;
-	SIGILL				= 0x4;
-	SIGINFO				= 0x1d;
-	SIGINT				= 0x2;
-	SIGIO				= 0x17;
-	SIGIOT				= 0x6;
-	SIGKILL				= 0x9;
-	SIGPIPE				= 0xd;
-	SIGPROF				= 0x1b;
-	SIGQUIT				= 0x3;
-	SIGSEGV				= 0xb;
-	SIGSTOP				= 0x11;
-	SIGSYS				= 0xc;
-	SIGTERM				= 0xf;
-	SIGTRAP				= 0x5;
-	SIGTSTP				= 0x12;
-	SIGTTIN				= 0x15;
-	SIGTTOU				= 0x16;
-	SIGURG				= 0x10;
-	SIGUSR1				= 0x1e;
-	SIGUSR2				= 0x1f;
-	SIGVTALRM			= 0x1a;
-	SIGWINCH			= 0x1c;
-	SIGXCPU				= 0x18;
-	SIGXFSZ				= 0x19;
-	SOCK_DGRAM			= 0x2;
-	SOCK_MAXADDRLEN			= 0xff;
-	SOCK_RAW			= 0x3;
-	SOCK_RDM			= 0x4;
-	SOCK_SEQPACKET			= 0x5;
-	SOCK_STREAM			= 0x1;
-	SOL_SOCKET			= 0xffff;
-	SOMAXCONN			= 0x80;
-	SO_ACCEPTCONN			= 0x2;
-	SO_BROADCAST			= 0x20;
-	SO_DEBUG			= 0x1;
-	SO_DONTROUTE			= 0x10;
-	SO_DONTTRUNC			= 0x2000;
-	SO_ERROR			= 0x1007;
-	SO_KEEPALIVE			= 0x8;
-	SO_LABEL			= 0x1010;
-	SO_LINGER			= 0x80;
-	SO_LINGER_SEC			= 0x1080;
-	SO_NKE				= 0x1021;
-	SO_NOADDRERR			= 0x1023;
-	SO_NOSIGPIPE			= 0x1022;
-	SO_NOTIFYCONFLICT		= 0x1026;
-	SO_NP_EXTENSIONS		= 0x1083;
-	SO_NREAD			= 0x1020;
-	SO_NWRITE			= 0x1024;
-	SO_OOBINLINE			= 0x100;
-	SO_PEERLABEL			= 0x1011;
-	SO_RANDOMPORT			= 0x1082;
-	SO_RCVBUF			= 0x1002;
-	SO_RCVLOWAT			= 0x1004;
-	SO_RCVTIMEO			= 0x1006;
-	SO_RESTRICTIONS			= 0x1081;
-	SO_RESTRICT_DENYIN		= 0x1;
-	SO_RESTRICT_DENYOUT		= 0x2;
-	SO_RESTRICT_DENYSET		= 0x80000000;
-	SO_REUSEADDR			= 0x4;
-	SO_REUSEPORT			= 0x200;
-	SO_REUSESHAREUID		= 0x1025;
-	SO_SNDBUF			= 0x1001;
-	SO_SNDLOWAT			= 0x1003;
-	SO_SNDTIMEO			= 0x1005;
-	SO_TIMESTAMP			= 0x400;
-	SO_TYPE				= 0x1008;
-	SO_UPCALLCLOSEWAIT		= 0x1027;
-	SO_USELOOPBACK			= 0x40;
-	SO_WANTMORE			= 0x4000;
-	SO_WANTOOBFLAG			= 0x8000;
-	S_IEXEC				= 0x40;
-	S_IFBLK				= 0x6000;
-	S_IFCHR				= 0x2000;
-	S_IFDIR				= 0x4000;
-	S_IFIFO				= 0x1000;
-	S_IFLNK				= 0xa000;
-	S_IFMT				= 0xf000;
-	S_IFREG				= 0x8000;
-	S_IFSOCK			= 0xc000;
-	S_IFWHT				= 0xe000;
-	S_IREAD				= 0x100;
-	S_IRGRP				= 0x20;
-	S_IROTH				= 0x4;
-	S_IRUSR				= 0x100;
-	S_IRWXG				= 0x38;
-	S_IRWXO				= 0x7;
-	S_IRWXU				= 0x1c0;
-	S_ISGID				= 0x400;
-	S_ISTXT				= 0x200;
-	S_ISUID				= 0x800;
-	S_ISVTX				= 0x200;
-	S_IWGRP				= 0x10;
-	S_IWOTH				= 0x2;
-	S_IWRITE			= 0x80;
-	S_IWUSR				= 0x80;
-	S_IXGRP				= 0x8;
-	S_IXOTH				= 0x1;
-	S_IXUSR				= 0x40;
-	TCP_CONNECTIONTIMEOUT		= 0x20;
-	TCP_KEEPALIVE			= 0x10;
-	TCP_MAXBURST			= 0x4;
-	TCP_MAXHLEN			= 0x3c;
-	TCP_MAXOLEN			= 0x28;
-	TCP_MAXSEG			= 0x2;
-	TCP_MAXWIN			= 0xffff;
-	TCP_MAX_SACK			= 0x3;
-	TCP_MAX_WINSHIFT		= 0xe;
-	TCP_MINMSS			= 0xd8;
-	TCP_MINMSSOVERLOAD		= 0x3e8;
-	TCP_MSS				= 0x200;
-	TCP_NODELAY			= 0x1;
-	TCP_NOOPT			= 0x8;
-	TCP_NOPUSH			= 0x4;
-	WCONTINUED			= 0x10;
-	WCOREFLAG			= 0x80;
-	WEXITED				= 0x4;
-	WNOHANG				= 0x1;
-	WNOWAIT				= 0x20;
-	WORDSIZE			= 0x40;
-	WSTOPPED			= 0x7f;
-	WUNTRACED			= 0x2;
+	AF_APPLETALK              = 0x10
+	AF_CCITT                  = 0xa
+	AF_CHAOS                  = 0x5
+	AF_CNT                    = 0x15
+	AF_COIP                   = 0x14
+	AF_DATAKIT                = 0x9
+	AF_DECnet                 = 0xc
+	AF_DLI                    = 0xd
+	AF_E164                   = 0x1c
+	AF_ECMA                   = 0x8
+	AF_HYLINK                 = 0xf
+	AF_IEEE80211              = 0x25
+	AF_IMPLINK                = 0x3
+	AF_INET                   = 0x2
+	AF_INET6                  = 0x1e
+	AF_IPX                    = 0x17
+	AF_ISDN                   = 0x1c
+	AF_ISO                    = 0x7
+	AF_LAT                    = 0xe
+	AF_LINK                   = 0x12
+	AF_LOCAL                  = 0x1
+	AF_MAX                    = 0x26
+	AF_NATM                   = 0x1f
+	AF_NDRV                   = 0x1b
+	AF_NETBIOS                = 0x21
+	AF_NS                     = 0x6
+	AF_OSI                    = 0x7
+	AF_PPP                    = 0x22
+	AF_PUP                    = 0x4
+	AF_RESERVED_36            = 0x24
+	AF_ROUTE                  = 0x11
+	AF_SIP                    = 0x18
+	AF_SNA                    = 0xb
+	AF_SYSTEM                 = 0x20
+	AF_UNIX                   = 0x1
+	AF_UNSPEC                 = 0
+	E2BIG                     = 0x7
+	EACCES                    = 0xd
+	EADDRINUSE                = 0x30
+	EADDRNOTAVAIL             = 0x31
+	EAFNOSUPPORT              = 0x2f
+	EAGAIN                    = 0x23
+	EALREADY                  = 0x25
+	EAUTH                     = 0x50
+	EBADARCH                  = 0x56
+	EBADEXEC                  = 0x55
+	EBADF                     = 0x9
+	EBADMACHO                 = 0x58
+	EBADMSG                   = 0x5e
+	EBADRPC                   = 0x48
+	EBUSY                     = 0x10
+	ECANCELED                 = 0x59
+	ECHILD                    = 0xa
+	ECONNABORTED              = 0x35
+	ECONNREFUSED              = 0x3d
+	ECONNRESET                = 0x36
+	EDEADLK                   = 0xb
+	EDESTADDRREQ              = 0x27
+	EDEVERR                   = 0x53
+	EDOM                      = 0x21
+	EDQUOT                    = 0x45
+	EEXIST                    = 0x11
+	EFAULT                    = 0xe
+	EFBIG                     = 0x1b
+	EFTYPE                    = 0x4f
+	EHOSTDOWN                 = 0x40
+	EHOSTUNREACH              = 0x41
+	EIDRM                     = 0x5a
+	EILSEQ                    = 0x5c
+	EINPROGRESS               = 0x24
+	EINTR                     = 0x4
+	EINVAL                    = 0x16
+	EIO                       = 0x5
+	EISCONN                   = 0x38
+	EISDIR                    = 0x15
+	ELAST                     = 0x67
+	ELOOP                     = 0x3e
+	EMFILE                    = 0x18
+	EMLINK                    = 0x1f
+	EMSGSIZE                  = 0x28
+	EMULTIHOP                 = 0x5f
+	ENAMETOOLONG              = 0x3f
+	ENEEDAUTH                 = 0x51
+	ENETDOWN                  = 0x32
+	ENETRESET                 = 0x34
+	ENETUNREACH               = 0x33
+	ENFILE                    = 0x17
+	ENOATTR                   = 0x5d
+	ENOBUFS                   = 0x37
+	ENODATA                   = 0x60
+	ENODEV                    = 0x13
+	ENOENT                    = 0x2
+	ENOEXEC                   = 0x8
+	ENOLCK                    = 0x4d
+	ENOLINK                   = 0x61
+	ENOMEM                    = 0xc
+	ENOMSG                    = 0x5b
+	ENOPOLICY                 = 0x67
+	ENOPROTOOPT               = 0x2a
+	ENOSPC                    = 0x1c
+	ENOSR                     = 0x62
+	ENOSTR                    = 0x63
+	ENOSYS                    = 0x4e
+	ENOTBLK                   = 0xf
+	ENOTCONN                  = 0x39
+	ENOTDIR                   = 0x14
+	ENOTEMPTY                 = 0x42
+	ENOTSOCK                  = 0x26
+	ENOTSUP                   = 0x2d
+	ENOTTY                    = 0x19
+	ENXIO                     = 0x6
+	EOPNOTSUPP                = 0x66
+	EOVERFLOW                 = 0x54
+	EPERM                     = 0x1
+	EPFNOSUPPORT              = 0x2e
+	EPIPE                     = 0x20
+	EPROCLIM                  = 0x43
+	EPROCUNAVAIL              = 0x4c
+	EPROGMISMATCH             = 0x4b
+	EPROGUNAVAIL              = 0x4a
+	EPROTO                    = 0x64
+	EPROTONOSUPPORT           = 0x2b
+	EPROTOTYPE                = 0x29
+	EPWROFF                   = 0x52
+	ERANGE                    = 0x22
+	EREMOTE                   = 0x47
+	EROFS                     = 0x1e
+	ERPCMISMATCH              = 0x49
+	ESHLIBVERS                = 0x57
+	ESHUTDOWN                 = 0x3a
+	ESOCKTNOSUPPORT           = 0x2c
+	ESPIPE                    = 0x1d
+	ESRCH                     = 0x3
+	ESTALE                    = 0x46
+	ETIME                     = 0x65
+	ETIMEDOUT                 = 0x3c
+	ETOOMANYREFS              = 0x3b
+	ETXTBSY                   = 0x1a
+	EUSERS                    = 0x44
+	EVFILT_AIO                = -0x3
+	EVFILT_FS                 = -0x9
+	EVFILT_MACHPORT           = -0x8
+	EVFILT_PROC               = -0x5
+	EVFILT_READ               = -0x1
+	EVFILT_SESSION            = -0xb
+	EVFILT_SIGNAL             = -0x6
+	EVFILT_SYSCOUNT           = 0xb
+	EVFILT_THREADMARKER       = 0xb
+	EVFILT_TIMER              = -0x7
+	EVFILT_USER               = -0xa
+	EVFILT_VNODE              = -0x4
+	EVFILT_WRITE              = -0x2
+	EV_ADD                    = 0x1
+	EV_CLEAR                  = 0x20
+	EV_DELETE                 = 0x2
+	EV_DISABLE                = 0x8
+	EV_DISPATCH               = 0x80
+	EV_ENABLE                 = 0x4
+	EV_EOF                    = 0x8000
+	EV_ERROR                  = 0x4000
+	EV_FLAG0                  = 0x1000
+	EV_FLAG1                  = 0x2000
+	EV_ONESHOT                = 0x10
+	EV_OOBAND                 = 0x2000
+	EV_POLL                   = 0x1000
+	EV_RECEIPT                = 0x40
+	EV_SYSFLAGS               = 0xf000
+	EV_TRIGGER                = 0x100
+	EWOULDBLOCK               = 0x23
+	EXDEV                     = 0x12
+	FD_CLOEXEC                = 0x1
+	FD_SETSIZE                = 0x400
+	F_ADDFILESIGS             = 0x3d
+	F_ADDSIGS                 = 0x3b
+	F_ALLOCATEALL             = 0x4
+	F_ALLOCATECONTIG          = 0x2
+	F_CHKCLEAN                = 0x29
+	F_DUPFD                   = 0
+	F_FREEZE_FS               = 0x35
+	F_FULLFSYNC               = 0x33
+	F_GETFD                   = 0x1
+	F_GETFL                   = 0x3
+	F_GETLK                   = 0x7
+	F_GETOWN                  = 0x5
+	F_GETPATH                 = 0x32
+	F_GLOBAL_NOCACHE          = 0x37
+	F_LOG2PHYS                = 0x31
+	F_MARKDEPENDENCY          = 0x3c
+	F_NOCACHE                 = 0x30
+	F_PATHPKG_CHECK           = 0x34
+	F_PEOFPOSMODE             = 0x3
+	F_PREALLOCATE             = 0x2a
+	F_RDADVISE                = 0x2c
+	F_RDAHEAD                 = 0x2d
+	F_RDLCK                   = 0x1
+	F_READBOOTSTRAP           = 0x2e
+	F_SETFD                   = 0x2
+	F_SETFL                   = 0x4
+	F_SETLK                   = 0x8
+	F_SETLKW                  = 0x9
+	F_SETOWN                  = 0x6
+	F_SETSIZE                 = 0x2b
+	F_THAW_FS                 = 0x36
+	F_UNLCK                   = 0x2
+	F_VOLPOSMODE              = 0x4
+	F_WRITEBOOTSTRAP          = 0x2f
+	F_WRLCK                   = 0x3
+	IPPROTO_3PC               = 0x22
+	IPPROTO_ADFS              = 0x44
+	IPPROTO_AH                = 0x33
+	IPPROTO_AHIP              = 0x3d
+	IPPROTO_APES              = 0x63
+	IPPROTO_ARGUS             = 0xd
+	IPPROTO_AX25              = 0x5d
+	IPPROTO_BHA               = 0x31
+	IPPROTO_BLT               = 0x1e
+	IPPROTO_BRSATMON          = 0x4c
+	IPPROTO_CFTP              = 0x3e
+	IPPROTO_CHAOS             = 0x10
+	IPPROTO_CMTP              = 0x26
+	IPPROTO_CPHB              = 0x49
+	IPPROTO_CPNX              = 0x48
+	IPPROTO_DDP               = 0x25
+	IPPROTO_DGP               = 0x56
+	IPPROTO_DIVERT            = 0xfe
+	IPPROTO_DONE              = 0x101
+	IPPROTO_DSTOPTS           = 0x3c
+	IPPROTO_EGP               = 0x8
+	IPPROTO_EMCON             = 0xe
+	IPPROTO_ENCAP             = 0x62
+	IPPROTO_EON               = 0x50
+	IPPROTO_ESP               = 0x32
+	IPPROTO_ETHERIP           = 0x61
+	IPPROTO_FRAGMENT          = 0x2c
+	IPPROTO_GGP               = 0x3
+	IPPROTO_GMTP              = 0x64
+	IPPROTO_GRE               = 0x2f
+	IPPROTO_HELLO             = 0x3f
+	IPPROTO_HMP               = 0x14
+	IPPROTO_HOPOPTS           = 0
+	IPPROTO_ICMP              = 0x1
+	IPPROTO_ICMPV6            = 0x3a
+	IPPROTO_IDP               = 0x16
+	IPPROTO_IDPR              = 0x23
+	IPPROTO_IDRP              = 0x2d
+	IPPROTO_IGMP              = 0x2
+	IPPROTO_IGP               = 0x55
+	IPPROTO_IGRP              = 0x58
+	IPPROTO_IL                = 0x28
+	IPPROTO_INLSP             = 0x34
+	IPPROTO_INP               = 0x20
+	IPPROTO_IP                = 0
+	IPPROTO_IPCOMP            = 0x6c
+	IPPROTO_IPCV              = 0x47
+	IPPROTO_IPEIP             = 0x5e
+	IPPROTO_IPIP              = 0x4
+	IPPROTO_IPPC              = 0x43
+	IPPROTO_IPV4              = 0x4
+	IPPROTO_IPV6              = 0x29
+	IPPROTO_IRTP              = 0x1c
+	IPPROTO_KRYPTOLAN         = 0x41
+	IPPROTO_LARP              = 0x5b
+	IPPROTO_LEAF1             = 0x19
+	IPPROTO_LEAF2             = 0x1a
+	IPPROTO_MAX               = 0x100
+	IPPROTO_MAXID             = 0x34
+	IPPROTO_MEAS              = 0x13
+	IPPROTO_MHRP              = 0x30
+	IPPROTO_MICP              = 0x5f
+	IPPROTO_MTP               = 0x5c
+	IPPROTO_MUX               = 0x12
+	IPPROTO_ND                = 0x4d
+	IPPROTO_NHRP              = 0x36
+	IPPROTO_NONE              = 0x3b
+	IPPROTO_NSP               = 0x1f
+	IPPROTO_NVPII             = 0xb
+	IPPROTO_OSPFIGP           = 0x59
+	IPPROTO_PGM               = 0x71
+	IPPROTO_PIGP              = 0x9
+	IPPROTO_PIM               = 0x67
+	IPPROTO_PRM               = 0x15
+	IPPROTO_PUP               = 0xc
+	IPPROTO_PVP               = 0x4b
+	IPPROTO_RAW               = 0xff
+	IPPROTO_RCCMON            = 0xa
+	IPPROTO_RDP               = 0x1b
+	IPPROTO_ROUTING           = 0x2b
+	IPPROTO_RSVP              = 0x2e
+	IPPROTO_RVD               = 0x42
+	IPPROTO_SATEXPAK          = 0x40
+	IPPROTO_SATMON            = 0x45
+	IPPROTO_SCCSP             = 0x60
+	IPPROTO_SDRP              = 0x2a
+	IPPROTO_SEP               = 0x21
+	IPPROTO_SRPC              = 0x5a
+	IPPROTO_ST                = 0x7
+	IPPROTO_SVMTP             = 0x52
+	IPPROTO_SWIPE             = 0x35
+	IPPROTO_TCF               = 0x57
+	IPPROTO_TCP               = 0x6
+	IPPROTO_TP                = 0x1d
+	IPPROTO_TPXX              = 0x27
+	IPPROTO_TRUNK1            = 0x17
+	IPPROTO_TRUNK2            = 0x18
+	IPPROTO_TTP               = 0x54
+	IPPROTO_UDP               = 0x11
+	IPPROTO_VINES             = 0x53
+	IPPROTO_VISA              = 0x46
+	IPPROTO_VMTP              = 0x51
+	IPPROTO_WBEXPAK           = 0x4f
+	IPPROTO_WBMON             = 0x4e
+	IPPROTO_WSN               = 0x4a
+	IPPROTO_XNET              = 0xf
+	IPPROTO_XTP               = 0x24
+	IP_ADD_MEMBERSHIP         = 0xc
+	IP_BOUND_IF               = 0x19
+	IP_DEFAULT_MULTICAST_LOOP = 0x1
+	IP_DEFAULT_MULTICAST_TTL  = 0x1
+	IP_DROP_MEMBERSHIP        = 0xd
+	IP_DUMMYNET_CONFIGURE     = 0x3c
+	IP_DUMMYNET_DEL           = 0x3d
+	IP_DUMMYNET_FLUSH         = 0x3e
+	IP_DUMMYNET_GET           = 0x40
+	IP_FAITH                  = 0x16
+	IP_FW_ADD                 = 0x28
+	IP_FW_DEL                 = 0x29
+	IP_FW_FLUSH               = 0x2a
+	IP_FW_GET                 = 0x2c
+	IP_FW_RESETLOG            = 0x2d
+	IP_FW_ZERO                = 0x2b
+	IP_HDRINCL                = 0x2
+	IP_IPSEC_POLICY           = 0x15
+	IP_MAX_MEMBERSHIPS        = 0x14
+	IP_MULTICAST_IF           = 0x9
+	IP_MULTICAST_LOOP         = 0xb
+	IP_MULTICAST_TTL          = 0xa
+	IP_MULTICAST_VIF          = 0xe
+	IP_NAT__XXX               = 0x37
+	IP_OLD_FW_ADD             = 0x32
+	IP_OLD_FW_DEL             = 0x33
+	IP_OLD_FW_FLUSH           = 0x34
+	IP_OLD_FW_GET             = 0x36
+	IP_OLD_FW_RESETLOG        = 0x38
+	IP_OLD_FW_ZERO            = 0x35
+	IP_OPTIONS                = 0x1
+	IP_PORTRANGE              = 0x13
+	IP_PORTRANGE_DEFAULT      = 0
+	IP_PORTRANGE_HIGH         = 0x1
+	IP_PORTRANGE_LOW          = 0x2
+	IP_RECVDSTADDR            = 0x7
+	IP_RECVIF                 = 0x14
+	IP_RECVOPTS               = 0x5
+	IP_RECVRETOPTS            = 0x6
+	IP_RECVTTL                = 0x18
+	IP_RETOPTS                = 0x8
+	IP_RSVP_OFF               = 0x10
+	IP_RSVP_ON                = 0xf
+	IP_RSVP_VIF_OFF           = 0x12
+	IP_RSVP_VIF_ON            = 0x11
+	IP_STRIPHDR               = 0x17
+	IP_TOS                    = 0x3
+	IP_TRAFFIC_MGT_BACKGROUND = 0x41
+	IP_TTL                    = 0x4
+	O_ACCMODE                 = 0x3
+	O_ALERT                   = 0x20000000
+	O_APPEND                  = 0x8
+	O_ASYNC                   = 0x40
+	O_CREAT                   = 0x200
+	O_DIRECTORY               = 0x100000
+	O_DSYNC                   = 0x400000
+	O_EVTONLY                 = 0x8000
+	O_EXCL                    = 0x800
+	O_EXLOCK                  = 0x20
+	O_FSYNC                   = 0x80
+	O_NDELAY                  = 0x4
+	O_NOCTTY                  = 0x20000
+	O_NOFOLLOW                = 0x100
+	O_NONBLOCK                = 0x4
+	O_POPUP                   = 0x80000000
+	O_RDONLY                  = 0
+	O_RDWR                    = 0x2
+	O_SHLOCK                  = 0x10
+	O_SYMLINK                 = 0x200000
+	O_SYNC                    = 0x80
+	O_TRUNC                   = 0x400
+	O_WRONLY                  = 0x1
+	SHUT_RD                   = 0
+	SHUT_RDWR                 = 0x2
+	SHUT_WR                   = 0x1
+	SIGABRT                   = 0x6
+	SIGALRM                   = 0xe
+	SIGBUS                    = 0xa
+	SIGCHLD                   = 0x14
+	SIGCONT                   = 0x13
+	SIGEMT                    = 0x7
+	SIGFPE                    = 0x8
+	SIGHUP                    = 0x1
+	SIGILL                    = 0x4
+	SIGINFO                   = 0x1d
+	SIGINT                    = 0x2
+	SIGIO                     = 0x17
+	SIGIOT                    = 0x6
+	SIGKILL                   = 0x9
+	SIGPIPE                   = 0xd
+	SIGPROF                   = 0x1b
+	SIGQUIT                   = 0x3
+	SIGSEGV                   = 0xb
+	SIGSTOP                   = 0x11
+	SIGSYS                    = 0xc
+	SIGTERM                   = 0xf
+	SIGTRAP                   = 0x5
+	SIGTSTP                   = 0x12
+	SIGTTIN                   = 0x15
+	SIGTTOU                   = 0x16
+	SIGURG                    = 0x10
+	SIGUSR1                   = 0x1e
+	SIGUSR2                   = 0x1f
+	SIGVTALRM                 = 0x1a
+	SIGWINCH                  = 0x1c
+	SIGXCPU                   = 0x18
+	SIGXFSZ                   = 0x19
+	SOCK_DGRAM                = 0x2
+	SOCK_MAXADDRLEN           = 0xff
+	SOCK_RAW                  = 0x3
+	SOCK_RDM                  = 0x4
+	SOCK_SEQPACKET            = 0x5
+	SOCK_STREAM               = 0x1
+	SOL_SOCKET                = 0xffff
+	SOMAXCONN                 = 0x80
+	SO_ACCEPTCONN             = 0x2
+	SO_BROADCAST              = 0x20
+	SO_DEBUG                  = 0x1
+	SO_DONTROUTE              = 0x10
+	SO_DONTTRUNC              = 0x2000
+	SO_ERROR                  = 0x1007
+	SO_KEEPALIVE              = 0x8
+	SO_LABEL                  = 0x1010
+	SO_LINGER                 = 0x80
+	SO_LINGER_SEC             = 0x1080
+	SO_NKE                    = 0x1021
+	SO_NOADDRERR              = 0x1023
+	SO_NOSIGPIPE              = 0x1022
+	SO_NOTIFYCONFLICT         = 0x1026
+	SO_NP_EXTENSIONS          = 0x1083
+	SO_NREAD                  = 0x1020
+	SO_NWRITE                 = 0x1024
+	SO_OOBINLINE              = 0x100
+	SO_PEERLABEL              = 0x1011
+	SO_RANDOMPORT             = 0x1082
+	SO_RCVBUF                 = 0x1002
+	SO_RCVLOWAT               = 0x1004
+	SO_RCVTIMEO               = 0x1006
+	SO_RESTRICTIONS           = 0x1081
+	SO_RESTRICT_DENYIN        = 0x1
+	SO_RESTRICT_DENYOUT       = 0x2
+	SO_RESTRICT_DENYSET       = 0x80000000
+	SO_REUSEADDR              = 0x4
+	SO_REUSEPORT              = 0x200
+	SO_REUSESHAREUID          = 0x1025
+	SO_SNDBUF                 = 0x1001
+	SO_SNDLOWAT               = 0x1003
+	SO_SNDTIMEO               = 0x1005
+	SO_TIMESTAMP              = 0x400
+	SO_TYPE                   = 0x1008
+	SO_UPCALLCLOSEWAIT        = 0x1027
+	SO_USELOOPBACK            = 0x40
+	SO_WANTMORE               = 0x4000
+	SO_WANTOOBFLAG            = 0x8000
+	S_IEXEC                   = 0x40
+	S_IFBLK                   = 0x6000
+	S_IFCHR                   = 0x2000
+	S_IFDIR                   = 0x4000
+	S_IFIFO                   = 0x1000
+	S_IFLNK                   = 0xa000
+	S_IFMT                    = 0xf000
+	S_IFREG                   = 0x8000
+	S_IFSOCK                  = 0xc000
+	S_IFWHT                   = 0xe000
+	S_IREAD                   = 0x100
+	S_IRGRP                   = 0x20
+	S_IROTH                   = 0x4
+	S_IRUSR                   = 0x100
+	S_IRWXG                   = 0x38
+	S_IRWXO                   = 0x7
+	S_IRWXU                   = 0x1c0
+	S_ISGID                   = 0x400
+	S_ISTXT                   = 0x200
+	S_ISUID                   = 0x800
+	S_ISVTX                   = 0x200
+	S_IWGRP                   = 0x10
+	S_IWOTH                   = 0x2
+	S_IWRITE                  = 0x80
+	S_IWUSR                   = 0x80
+	S_IXGRP                   = 0x8
+	S_IXOTH                   = 0x1
+	S_IXUSR                   = 0x40
+	TCP_CONNECTIONTIMEOUT     = 0x20
+	TCP_KEEPALIVE             = 0x10
+	TCP_MAXBURST              = 0x4
+	TCP_MAXHLEN               = 0x3c
+	TCP_MAXOLEN               = 0x28
+	TCP_MAXSEG                = 0x2
+	TCP_MAXWIN                = 0xffff
+	TCP_MAX_SACK              = 0x3
+	TCP_MAX_WINSHIFT          = 0xe
+	TCP_MINMSS                = 0xd8
+	TCP_MINMSSOVERLOAD        = 0x3e8
+	TCP_MSS                   = 0x200
+	TCP_NODELAY               = 0x1
+	TCP_NOOPT                 = 0x8
+	TCP_NOPUSH                = 0x4
+	WCONTINUED                = 0x10
+	WCOREFLAG                 = 0x80
+	WEXITED                   = 0x4
+	WNOHANG                   = 0x1
+	WNOWAIT                   = 0x20
+	WORDSIZE                  = 0x40
+	WSTOPPED                  = 0x7f
+	WUNTRACED                 = 0x2
 )
 
 // Types
diff --git a/src/pkg/syscall/zerrors_darwin_amd64.go b/src/pkg/syscall/zerrors_darwin_amd64.go
index 84a07e3c25..76660a8445 100644
--- a/src/pkg/syscall/zerrors_darwin_amd64.go
+++ b/src/pkg/syscall/zerrors_darwin_amd64.go
@@ -9,525 +9,525 @@ package syscall
 
 // Constants
 const (
-	AF_APPLETALK			= 0x10;
-	AF_CCITT			= 0xa;
-	AF_CHAOS			= 0x5;
-	AF_CNT				= 0x15;
-	AF_COIP				= 0x14;
-	AF_DATAKIT			= 0x9;
-	AF_DECnet			= 0xc;
-	AF_DLI				= 0xd;
-	AF_E164				= 0x1c;
-	AF_ECMA				= 0x8;
-	AF_HYLINK			= 0xf;
-	AF_IEEE80211			= 0x25;
-	AF_IMPLINK			= 0x3;
-	AF_INET				= 0x2;
-	AF_INET6			= 0x1e;
-	AF_IPX				= 0x17;
-	AF_ISDN				= 0x1c;
-	AF_ISO				= 0x7;
-	AF_LAT				= 0xe;
-	AF_LINK				= 0x12;
-	AF_LOCAL			= 0x1;
-	AF_MAX				= 0x26;
-	AF_NATM				= 0x1f;
-	AF_NDRV				= 0x1b;
-	AF_NETBIOS			= 0x21;
-	AF_NS				= 0x6;
-	AF_OSI				= 0x7;
-	AF_PPP				= 0x22;
-	AF_PUP				= 0x4;
-	AF_RESERVED_36			= 0x24;
-	AF_ROUTE			= 0x11;
-	AF_SIP				= 0x18;
-	AF_SNA				= 0xb;
-	AF_SYSTEM			= 0x20;
-	AF_UNIX				= 0x1;
-	AF_UNSPEC			= 0;
-	E2BIG				= 0x7;
-	EACCES				= 0xd;
-	EADDRINUSE			= 0x30;
-	EADDRNOTAVAIL			= 0x31;
-	EAFNOSUPPORT			= 0x2f;
-	EAGAIN				= 0x23;
-	EALREADY			= 0x25;
-	EAUTH				= 0x50;
-	EBADARCH			= 0x56;
-	EBADEXEC			= 0x55;
-	EBADF				= 0x9;
-	EBADMACHO			= 0x58;
-	EBADMSG				= 0x5e;
-	EBADRPC				= 0x48;
-	EBUSY				= 0x10;
-	ECANCELED			= 0x59;
-	ECHILD				= 0xa;
-	ECONNABORTED			= 0x35;
-	ECONNREFUSED			= 0x3d;
-	ECONNRESET			= 0x36;
-	EDEADLK				= 0xb;
-	EDESTADDRREQ			= 0x27;
-	EDEVERR				= 0x53;
-	EDOM				= 0x21;
-	EDQUOT				= 0x45;
-	EEXIST				= 0x11;
-	EFAULT				= 0xe;
-	EFBIG				= 0x1b;
-	EFTYPE				= 0x4f;
-	EHOSTDOWN			= 0x40;
-	EHOSTUNREACH			= 0x41;
-	EIDRM				= 0x5a;
-	EILSEQ				= 0x5c;
-	EINPROGRESS			= 0x24;
-	EINTR				= 0x4;
-	EINVAL				= 0x16;
-	EIO				= 0x5;
-	EISCONN				= 0x38;
-	EISDIR				= 0x15;
-	ELAST				= 0x67;
-	ELOOP				= 0x3e;
-	EMFILE				= 0x18;
-	EMLINK				= 0x1f;
-	EMSGSIZE			= 0x28;
-	EMULTIHOP			= 0x5f;
-	ENAMETOOLONG			= 0x3f;
-	ENEEDAUTH			= 0x51;
-	ENETDOWN			= 0x32;
-	ENETRESET			= 0x34;
-	ENETUNREACH			= 0x33;
-	ENFILE				= 0x17;
-	ENOATTR				= 0x5d;
-	ENOBUFS				= 0x37;
-	ENODATA				= 0x60;
-	ENODEV				= 0x13;
-	ENOENT				= 0x2;
-	ENOEXEC				= 0x8;
-	ENOLCK				= 0x4d;
-	ENOLINK				= 0x61;
-	ENOMEM				= 0xc;
-	ENOMSG				= 0x5b;
-	ENOPOLICY			= 0x67;
-	ENOPROTOOPT			= 0x2a;
-	ENOSPC				= 0x1c;
-	ENOSR				= 0x62;
-	ENOSTR				= 0x63;
-	ENOSYS				= 0x4e;
-	ENOTBLK				= 0xf;
-	ENOTCONN			= 0x39;
-	ENOTDIR				= 0x14;
-	ENOTEMPTY			= 0x42;
-	ENOTSOCK			= 0x26;
-	ENOTSUP				= 0x2d;
-	ENOTTY				= 0x19;
-	ENXIO				= 0x6;
-	EOPNOTSUPP			= 0x66;
-	EOVERFLOW			= 0x54;
-	EPERM				= 0x1;
-	EPFNOSUPPORT			= 0x2e;
-	EPIPE				= 0x20;
-	EPROCLIM			= 0x43;
-	EPROCUNAVAIL			= 0x4c;
-	EPROGMISMATCH			= 0x4b;
-	EPROGUNAVAIL			= 0x4a;
-	EPROTO				= 0x64;
-	EPROTONOSUPPORT			= 0x2b;
-	EPROTOTYPE			= 0x29;
-	EPWROFF				= 0x52;
-	ERANGE				= 0x22;
-	EREMOTE				= 0x47;
-	EROFS				= 0x1e;
-	ERPCMISMATCH			= 0x49;
-	ESHLIBVERS			= 0x57;
-	ESHUTDOWN			= 0x3a;
-	ESOCKTNOSUPPORT			= 0x2c;
-	ESPIPE				= 0x1d;
-	ESRCH				= 0x3;
-	ESTALE				= 0x46;
-	ETIME				= 0x65;
-	ETIMEDOUT			= 0x3c;
-	ETOOMANYREFS			= 0x3b;
-	ETXTBSY				= 0x1a;
-	EUSERS				= 0x44;
-	EVFILT_AIO			= -0x3;
-	EVFILT_FS			= -0x9;
-	EVFILT_MACHPORT			= -0x8;
-	EVFILT_PROC			= -0x5;
-	EVFILT_READ			= -0x1;
-	EVFILT_SESSION			= -0xb;
-	EVFILT_SIGNAL			= -0x6;
-	EVFILT_SYSCOUNT			= 0xb;
-	EVFILT_THREADMARKER		= 0xb;
-	EVFILT_TIMER			= -0x7;
-	EVFILT_USER			= -0xa;
-	EVFILT_VNODE			= -0x4;
-	EVFILT_WRITE			= -0x2;
-	EV_ADD				= 0x1;
-	EV_CLEAR			= 0x20;
-	EV_DELETE			= 0x2;
-	EV_DISABLE			= 0x8;
-	EV_DISPATCH			= 0x80;
-	EV_ENABLE			= 0x4;
-	EV_EOF				= 0x8000;
-	EV_ERROR			= 0x4000;
-	EV_FLAG0			= 0x1000;
-	EV_FLAG1			= 0x2000;
-	EV_ONESHOT			= 0x10;
-	EV_OOBAND			= 0x2000;
-	EV_POLL				= 0x1000;
-	EV_RECEIPT			= 0x40;
-	EV_SYSFLAGS			= 0xf000;
-	EV_TRIGGER			= 0x100;
-	EWOULDBLOCK			= 0x23;
-	EXDEV				= 0x12;
-	FD_CLOEXEC			= 0x1;
-	FD_SETSIZE			= 0x400;
-	F_ADDFILESIGS			= 0x3d;
-	F_ADDSIGS			= 0x3b;
-	F_ALLOCATEALL			= 0x4;
-	F_ALLOCATECONTIG		= 0x2;
-	F_CHKCLEAN			= 0x29;
-	F_DUPFD				= 0;
-	F_FREEZE_FS			= 0x35;
-	F_FULLFSYNC			= 0x33;
-	F_GETFD				= 0x1;
-	F_GETFL				= 0x3;
-	F_GETLK				= 0x7;
-	F_GETOWN			= 0x5;
-	F_GETPATH			= 0x32;
-	F_GLOBAL_NOCACHE		= 0x37;
-	F_LOG2PHYS			= 0x31;
-	F_MARKDEPENDENCY		= 0x3c;
-	F_NOCACHE			= 0x30;
-	F_PATHPKG_CHECK			= 0x34;
-	F_PEOFPOSMODE			= 0x3;
-	F_PREALLOCATE			= 0x2a;
-	F_RDADVISE			= 0x2c;
-	F_RDAHEAD			= 0x2d;
-	F_RDLCK				= 0x1;
-	F_READBOOTSTRAP			= 0x2e;
-	F_SETFD				= 0x2;
-	F_SETFL				= 0x4;
-	F_SETLK				= 0x8;
-	F_SETLKW			= 0x9;
-	F_SETOWN			= 0x6;
-	F_SETSIZE			= 0x2b;
-	F_THAW_FS			= 0x36;
-	F_UNLCK				= 0x2;
-	F_VOLPOSMODE			= 0x4;
-	F_WRITEBOOTSTRAP		= 0x2f;
-	F_WRLCK				= 0x3;
-	IPPROTO_3PC			= 0x22;
-	IPPROTO_ADFS			= 0x44;
-	IPPROTO_AH			= 0x33;
-	IPPROTO_AHIP			= 0x3d;
-	IPPROTO_APES			= 0x63;
-	IPPROTO_ARGUS			= 0xd;
-	IPPROTO_AX25			= 0x5d;
-	IPPROTO_BHA			= 0x31;
-	IPPROTO_BLT			= 0x1e;
-	IPPROTO_BRSATMON		= 0x4c;
-	IPPROTO_CFTP			= 0x3e;
-	IPPROTO_CHAOS			= 0x10;
-	IPPROTO_CMTP			= 0x26;
-	IPPROTO_CPHB			= 0x49;
-	IPPROTO_CPNX			= 0x48;
-	IPPROTO_DDP			= 0x25;
-	IPPROTO_DGP			= 0x56;
-	IPPROTO_DIVERT			= 0xfe;
-	IPPROTO_DONE			= 0x101;
-	IPPROTO_DSTOPTS			= 0x3c;
-	IPPROTO_EGP			= 0x8;
-	IPPROTO_EMCON			= 0xe;
-	IPPROTO_ENCAP			= 0x62;
-	IPPROTO_EON			= 0x50;
-	IPPROTO_ESP			= 0x32;
-	IPPROTO_ETHERIP			= 0x61;
-	IPPROTO_FRAGMENT		= 0x2c;
-	IPPROTO_GGP			= 0x3;
-	IPPROTO_GMTP			= 0x64;
-	IPPROTO_GRE			= 0x2f;
-	IPPROTO_HELLO			= 0x3f;
-	IPPROTO_HMP			= 0x14;
-	IPPROTO_HOPOPTS			= 0;
-	IPPROTO_ICMP			= 0x1;
-	IPPROTO_ICMPV6			= 0x3a;
-	IPPROTO_IDP			= 0x16;
-	IPPROTO_IDPR			= 0x23;
-	IPPROTO_IDRP			= 0x2d;
-	IPPROTO_IGMP			= 0x2;
-	IPPROTO_IGP			= 0x55;
-	IPPROTO_IGRP			= 0x58;
-	IPPROTO_IL			= 0x28;
-	IPPROTO_INLSP			= 0x34;
-	IPPROTO_INP			= 0x20;
-	IPPROTO_IP			= 0;
-	IPPROTO_IPCOMP			= 0x6c;
-	IPPROTO_IPCV			= 0x47;
-	IPPROTO_IPEIP			= 0x5e;
-	IPPROTO_IPIP			= 0x4;
-	IPPROTO_IPPC			= 0x43;
-	IPPROTO_IPV4			= 0x4;
-	IPPROTO_IPV6			= 0x29;
-	IPPROTO_IRTP			= 0x1c;
-	IPPROTO_KRYPTOLAN		= 0x41;
-	IPPROTO_LARP			= 0x5b;
-	IPPROTO_LEAF1			= 0x19;
-	IPPROTO_LEAF2			= 0x1a;
-	IPPROTO_MAX			= 0x100;
-	IPPROTO_MAXID			= 0x34;
-	IPPROTO_MEAS			= 0x13;
-	IPPROTO_MHRP			= 0x30;
-	IPPROTO_MICP			= 0x5f;
-	IPPROTO_MTP			= 0x5c;
-	IPPROTO_MUX			= 0x12;
-	IPPROTO_ND			= 0x4d;
-	IPPROTO_NHRP			= 0x36;
-	IPPROTO_NONE			= 0x3b;
-	IPPROTO_NSP			= 0x1f;
-	IPPROTO_NVPII			= 0xb;
-	IPPROTO_OSPFIGP			= 0x59;
-	IPPROTO_PGM			= 0x71;
-	IPPROTO_PIGP			= 0x9;
-	IPPROTO_PIM			= 0x67;
-	IPPROTO_PRM			= 0x15;
-	IPPROTO_PUP			= 0xc;
-	IPPROTO_PVP			= 0x4b;
-	IPPROTO_RAW			= 0xff;
-	IPPROTO_RCCMON			= 0xa;
-	IPPROTO_RDP			= 0x1b;
-	IPPROTO_ROUTING			= 0x2b;
-	IPPROTO_RSVP			= 0x2e;
-	IPPROTO_RVD			= 0x42;
-	IPPROTO_SATEXPAK		= 0x40;
-	IPPROTO_SATMON			= 0x45;
-	IPPROTO_SCCSP			= 0x60;
-	IPPROTO_SDRP			= 0x2a;
-	IPPROTO_SEP			= 0x21;
-	IPPROTO_SRPC			= 0x5a;
-	IPPROTO_ST			= 0x7;
-	IPPROTO_SVMTP			= 0x52;
-	IPPROTO_SWIPE			= 0x35;
-	IPPROTO_TCF			= 0x57;
-	IPPROTO_TCP			= 0x6;
-	IPPROTO_TP			= 0x1d;
-	IPPROTO_TPXX			= 0x27;
-	IPPROTO_TRUNK1			= 0x17;
-	IPPROTO_TRUNK2			= 0x18;
-	IPPROTO_TTP			= 0x54;
-	IPPROTO_UDP			= 0x11;
-	IPPROTO_VINES			= 0x53;
-	IPPROTO_VISA			= 0x46;
-	IPPROTO_VMTP			= 0x51;
-	IPPROTO_WBEXPAK			= 0x4f;
-	IPPROTO_WBMON			= 0x4e;
-	IPPROTO_WSN			= 0x4a;
-	IPPROTO_XNET			= 0xf;
-	IPPROTO_XTP			= 0x24;
-	IP_ADD_MEMBERSHIP		= 0xc;
-	IP_BOUND_IF			= 0x19;
-	IP_DEFAULT_MULTICAST_LOOP	= 0x1;
-	IP_DEFAULT_MULTICAST_TTL	= 0x1;
-	IP_DROP_MEMBERSHIP		= 0xd;
-	IP_DUMMYNET_CONFIGURE		= 0x3c;
-	IP_DUMMYNET_DEL			= 0x3d;
-	IP_DUMMYNET_FLUSH		= 0x3e;
-	IP_DUMMYNET_GET			= 0x40;
-	IP_FAITH			= 0x16;
-	IP_FW_ADD			= 0x28;
-	IP_FW_DEL			= 0x29;
-	IP_FW_FLUSH			= 0x2a;
-	IP_FW_GET			= 0x2c;
-	IP_FW_RESETLOG			= 0x2d;
-	IP_FW_ZERO			= 0x2b;
-	IP_HDRINCL			= 0x2;
-	IP_IPSEC_POLICY			= 0x15;
-	IP_MAX_MEMBERSHIPS		= 0x14;
-	IP_MULTICAST_IF			= 0x9;
-	IP_MULTICAST_LOOP		= 0xb;
-	IP_MULTICAST_TTL		= 0xa;
-	IP_MULTICAST_VIF		= 0xe;
-	IP_NAT__XXX			= 0x37;
-	IP_OLD_FW_ADD			= 0x32;
-	IP_OLD_FW_DEL			= 0x33;
-	IP_OLD_FW_FLUSH			= 0x34;
-	IP_OLD_FW_GET			= 0x36;
-	IP_OLD_FW_RESETLOG		= 0x38;
-	IP_OLD_FW_ZERO			= 0x35;
-	IP_OPTIONS			= 0x1;
-	IP_PORTRANGE			= 0x13;
-	IP_PORTRANGE_DEFAULT		= 0;
-	IP_PORTRANGE_HIGH		= 0x1;
-	IP_PORTRANGE_LOW		= 0x2;
-	IP_RECVDSTADDR			= 0x7;
-	IP_RECVIF			= 0x14;
-	IP_RECVOPTS			= 0x5;
-	IP_RECVRETOPTS			= 0x6;
-	IP_RECVTTL			= 0x18;
-	IP_RETOPTS			= 0x8;
-	IP_RSVP_OFF			= 0x10;
-	IP_RSVP_ON			= 0xf;
-	IP_RSVP_VIF_OFF			= 0x12;
-	IP_RSVP_VIF_ON			= 0x11;
-	IP_STRIPHDR			= 0x17;
-	IP_TOS				= 0x3;
-	IP_TRAFFIC_MGT_BACKGROUND	= 0x41;
-	IP_TTL				= 0x4;
-	O_ACCMODE			= 0x3;
-	O_ALERT				= 0x20000000;
-	O_APPEND			= 0x8;
-	O_ASYNC				= 0x40;
-	O_CREAT				= 0x200;
-	O_DIRECTORY			= 0x100000;
-	O_DSYNC				= 0x400000;
-	O_EVTONLY			= 0x8000;
-	O_EXCL				= 0x800;
-	O_EXLOCK			= 0x20;
-	O_FSYNC				= 0x80;
-	O_NDELAY			= 0x4;
-	O_NOCTTY			= 0x20000;
-	O_NOFOLLOW			= 0x100;
-	O_NONBLOCK			= 0x4;
-	O_POPUP				= 0x80000000;
-	O_RDONLY			= 0;
-	O_RDWR				= 0x2;
-	O_SHLOCK			= 0x10;
-	O_SYMLINK			= 0x200000;
-	O_SYNC				= 0x80;
-	O_TRUNC				= 0x400;
-	O_WRONLY			= 0x1;
-	SHUT_RD				= 0;
-	SHUT_RDWR			= 0x2;
-	SHUT_WR				= 0x1;
-	SIGABRT				= 0x6;
-	SIGALRM				= 0xe;
-	SIGBUS				= 0xa;
-	SIGCHLD				= 0x14;
-	SIGCONT				= 0x13;
-	SIGEMT				= 0x7;
-	SIGFPE				= 0x8;
-	SIGHUP				= 0x1;
-	SIGILL				= 0x4;
-	SIGINFO				= 0x1d;
-	SIGINT				= 0x2;
-	SIGIO				= 0x17;
-	SIGIOT				= 0x6;
-	SIGKILL				= 0x9;
-	SIGPIPE				= 0xd;
-	SIGPROF				= 0x1b;
-	SIGQUIT				= 0x3;
-	SIGSEGV				= 0xb;
-	SIGSTOP				= 0x11;
-	SIGSYS				= 0xc;
-	SIGTERM				= 0xf;
-	SIGTRAP				= 0x5;
-	SIGTSTP				= 0x12;
-	SIGTTIN				= 0x15;
-	SIGTTOU				= 0x16;
-	SIGURG				= 0x10;
-	SIGUSR1				= 0x1e;
-	SIGUSR2				= 0x1f;
-	SIGVTALRM			= 0x1a;
-	SIGWINCH			= 0x1c;
-	SIGXCPU				= 0x18;
-	SIGXFSZ				= 0x19;
-	SOCK_DGRAM			= 0x2;
-	SOCK_MAXADDRLEN			= 0xff;
-	SOCK_RAW			= 0x3;
-	SOCK_RDM			= 0x4;
-	SOCK_SEQPACKET			= 0x5;
-	SOCK_STREAM			= 0x1;
-	SOL_SOCKET			= 0xffff;
-	SOMAXCONN			= 0x80;
-	SO_ACCEPTCONN			= 0x2;
-	SO_BROADCAST			= 0x20;
-	SO_DEBUG			= 0x1;
-	SO_DONTROUTE			= 0x10;
-	SO_DONTTRUNC			= 0x2000;
-	SO_ERROR			= 0x1007;
-	SO_KEEPALIVE			= 0x8;
-	SO_LABEL			= 0x1010;
-	SO_LINGER			= 0x80;
-	SO_LINGER_SEC			= 0x1080;
-	SO_NKE				= 0x1021;
-	SO_NOADDRERR			= 0x1023;
-	SO_NOSIGPIPE			= 0x1022;
-	SO_NOTIFYCONFLICT		= 0x1026;
-	SO_NP_EXTENSIONS		= 0x1083;
-	SO_NREAD			= 0x1020;
-	SO_NWRITE			= 0x1024;
-	SO_OOBINLINE			= 0x100;
-	SO_PEERLABEL			= 0x1011;
-	SO_RANDOMPORT			= 0x1082;
-	SO_RCVBUF			= 0x1002;
-	SO_RCVLOWAT			= 0x1004;
-	SO_RCVTIMEO			= 0x1006;
-	SO_RESTRICTIONS			= 0x1081;
-	SO_RESTRICT_DENYIN		= 0x1;
-	SO_RESTRICT_DENYOUT		= 0x2;
-	SO_RESTRICT_DENYSET		= 0x80000000;
-	SO_REUSEADDR			= 0x4;
-	SO_REUSEPORT			= 0x200;
-	SO_REUSESHAREUID		= 0x1025;
-	SO_SNDBUF			= 0x1001;
-	SO_SNDLOWAT			= 0x1003;
-	SO_SNDTIMEO			= 0x1005;
-	SO_TIMESTAMP			= 0x400;
-	SO_TYPE				= 0x1008;
-	SO_UPCALLCLOSEWAIT		= 0x1027;
-	SO_USELOOPBACK			= 0x40;
-	SO_WANTMORE			= 0x4000;
-	SO_WANTOOBFLAG			= 0x8000;
-	S_IEXEC				= 0x40;
-	S_IFBLK				= 0x6000;
-	S_IFCHR				= 0x2000;
-	S_IFDIR				= 0x4000;
-	S_IFIFO				= 0x1000;
-	S_IFLNK				= 0xa000;
-	S_IFMT				= 0xf000;
-	S_IFREG				= 0x8000;
-	S_IFSOCK			= 0xc000;
-	S_IFWHT				= 0xe000;
-	S_IREAD				= 0x100;
-	S_IRGRP				= 0x20;
-	S_IROTH				= 0x4;
-	S_IRUSR				= 0x100;
-	S_IRWXG				= 0x38;
-	S_IRWXO				= 0x7;
-	S_IRWXU				= 0x1c0;
-	S_ISGID				= 0x400;
-	S_ISTXT				= 0x200;
-	S_ISUID				= 0x800;
-	S_ISVTX				= 0x200;
-	S_IWGRP				= 0x10;
-	S_IWOTH				= 0x2;
-	S_IWRITE			= 0x80;
-	S_IWUSR				= 0x80;
-	S_IXGRP				= 0x8;
-	S_IXOTH				= 0x1;
-	S_IXUSR				= 0x40;
-	TCP_CONNECTIONTIMEOUT		= 0x20;
-	TCP_KEEPALIVE			= 0x10;
-	TCP_MAXBURST			= 0x4;
-	TCP_MAXHLEN			= 0x3c;
-	TCP_MAXOLEN			= 0x28;
-	TCP_MAXSEG			= 0x2;
-	TCP_MAXWIN			= 0xffff;
-	TCP_MAX_SACK			= 0x3;
-	TCP_MAX_WINSHIFT		= 0xe;
-	TCP_MINMSS			= 0xd8;
-	TCP_MINMSSOVERLOAD		= 0x3e8;
-	TCP_MSS				= 0x200;
-	TCP_NODELAY			= 0x1;
-	TCP_NOOPT			= 0x8;
-	TCP_NOPUSH			= 0x4;
-	WCONTINUED			= 0x10;
-	WCOREFLAG			= 0x80;
-	WEXITED				= 0x4;
-	WNOHANG				= 0x1;
-	WNOWAIT				= 0x20;
-	WORDSIZE			= 0x40;
-	WSTOPPED			= 0x7f;
-	WUNTRACED			= 0x2;
+	AF_APPLETALK              = 0x10
+	AF_CCITT                  = 0xa
+	AF_CHAOS                  = 0x5
+	AF_CNT                    = 0x15
+	AF_COIP                   = 0x14
+	AF_DATAKIT                = 0x9
+	AF_DECnet                 = 0xc
+	AF_DLI                    = 0xd
+	AF_E164                   = 0x1c
+	AF_ECMA                   = 0x8
+	AF_HYLINK                 = 0xf
+	AF_IEEE80211              = 0x25
+	AF_IMPLINK                = 0x3
+	AF_INET                   = 0x2
+	AF_INET6                  = 0x1e
+	AF_IPX                    = 0x17
+	AF_ISDN                   = 0x1c
+	AF_ISO                    = 0x7
+	AF_LAT                    = 0xe
+	AF_LINK                   = 0x12
+	AF_LOCAL                  = 0x1
+	AF_MAX                    = 0x26
+	AF_NATM                   = 0x1f
+	AF_NDRV                   = 0x1b
+	AF_NETBIOS                = 0x21
+	AF_NS                     = 0x6
+	AF_OSI                    = 0x7
+	AF_PPP                    = 0x22
+	AF_PUP                    = 0x4
+	AF_RESERVED_36            = 0x24
+	AF_ROUTE                  = 0x11
+	AF_SIP                    = 0x18
+	AF_SNA                    = 0xb
+	AF_SYSTEM                 = 0x20
+	AF_UNIX                   = 0x1
+	AF_UNSPEC                 = 0
+	E2BIG                     = 0x7
+	EACCES                    = 0xd
+	EADDRINUSE                = 0x30
+	EADDRNOTAVAIL             = 0x31
+	EAFNOSUPPORT              = 0x2f
+	EAGAIN                    = 0x23
+	EALREADY                  = 0x25
+	EAUTH                     = 0x50
+	EBADARCH                  = 0x56
+	EBADEXEC                  = 0x55
+	EBADF                     = 0x9
+	EBADMACHO                 = 0x58
+	EBADMSG                   = 0x5e
+	EBADRPC                   = 0x48
+	EBUSY                     = 0x10
+	ECANCELED                 = 0x59
+	ECHILD                    = 0xa
+	ECONNABORTED              = 0x35
+	ECONNREFUSED              = 0x3d
+	ECONNRESET                = 0x36
+	EDEADLK                   = 0xb
+	EDESTADDRREQ              = 0x27
+	EDEVERR                   = 0x53
+	EDOM                      = 0x21
+	EDQUOT                    = 0x45
+	EEXIST                    = 0x11
+	EFAULT                    = 0xe
+	EFBIG                     = 0x1b
+	EFTYPE                    = 0x4f
+	EHOSTDOWN                 = 0x40
+	EHOSTUNREACH              = 0x41
+	EIDRM                     = 0x5a
+	EILSEQ                    = 0x5c
+	EINPROGRESS               = 0x24
+	EINTR                     = 0x4
+	EINVAL                    = 0x16
+	EIO                       = 0x5
+	EISCONN                   = 0x38
+	EISDIR                    = 0x15
+	ELAST                     = 0x67
+	ELOOP                     = 0x3e
+	EMFILE                    = 0x18
+	EMLINK                    = 0x1f
+	EMSGSIZE                  = 0x28
+	EMULTIHOP                 = 0x5f
+	ENAMETOOLONG              = 0x3f
+	ENEEDAUTH                 = 0x51
+	ENETDOWN                  = 0x32
+	ENETRESET                 = 0x34
+	ENETUNREACH               = 0x33
+	ENFILE                    = 0x17
+	ENOATTR                   = 0x5d
+	ENOBUFS                   = 0x37
+	ENODATA                   = 0x60
+	ENODEV                    = 0x13
+	ENOENT                    = 0x2
+	ENOEXEC                   = 0x8
+	ENOLCK                    = 0x4d
+	ENOLINK                   = 0x61
+	ENOMEM                    = 0xc
+	ENOMSG                    = 0x5b
+	ENOPOLICY                 = 0x67
+	ENOPROTOOPT               = 0x2a
+	ENOSPC                    = 0x1c
+	ENOSR                     = 0x62
+	ENOSTR                    = 0x63
+	ENOSYS                    = 0x4e
+	ENOTBLK                   = 0xf
+	ENOTCONN                  = 0x39
+	ENOTDIR                   = 0x14
+	ENOTEMPTY                 = 0x42
+	ENOTSOCK                  = 0x26
+	ENOTSUP                   = 0x2d
+	ENOTTY                    = 0x19
+	ENXIO                     = 0x6
+	EOPNOTSUPP                = 0x66
+	EOVERFLOW                 = 0x54
+	EPERM                     = 0x1
+	EPFNOSUPPORT              = 0x2e
+	EPIPE                     = 0x20
+	EPROCLIM                  = 0x43
+	EPROCUNAVAIL              = 0x4c
+	EPROGMISMATCH             = 0x4b
+	EPROGUNAVAIL              = 0x4a
+	EPROTO                    = 0x64
+	EPROTONOSUPPORT           = 0x2b
+	EPROTOTYPE                = 0x29
+	EPWROFF                   = 0x52
+	ERANGE                    = 0x22
+	EREMOTE                   = 0x47
+	EROFS                     = 0x1e
+	ERPCMISMATCH              = 0x49
+	ESHLIBVERS                = 0x57
+	ESHUTDOWN                 = 0x3a
+	ESOCKTNOSUPPORT           = 0x2c
+	ESPIPE                    = 0x1d
+	ESRCH                     = 0x3
+	ESTALE                    = 0x46
+	ETIME                     = 0x65
+	ETIMEDOUT                 = 0x3c
+	ETOOMANYREFS              = 0x3b
+	ETXTBSY                   = 0x1a
+	EUSERS                    = 0x44
+	EVFILT_AIO                = -0x3
+	EVFILT_FS                 = -0x9
+	EVFILT_MACHPORT           = -0x8
+	EVFILT_PROC               = -0x5
+	EVFILT_READ               = -0x1
+	EVFILT_SESSION            = -0xb
+	EVFILT_SIGNAL             = -0x6
+	EVFILT_SYSCOUNT           = 0xb
+	EVFILT_THREADMARKER       = 0xb
+	EVFILT_TIMER              = -0x7
+	EVFILT_USER               = -0xa
+	EVFILT_VNODE              = -0x4
+	EVFILT_WRITE              = -0x2
+	EV_ADD                    = 0x1
+	EV_CLEAR                  = 0x20
+	EV_DELETE                 = 0x2
+	EV_DISABLE                = 0x8
+	EV_DISPATCH               = 0x80
+	EV_ENABLE                 = 0x4
+	EV_EOF                    = 0x8000
+	EV_ERROR                  = 0x4000
+	EV_FLAG0                  = 0x1000
+	EV_FLAG1                  = 0x2000
+	EV_ONESHOT                = 0x10
+	EV_OOBAND                 = 0x2000
+	EV_POLL                   = 0x1000
+	EV_RECEIPT                = 0x40
+	EV_SYSFLAGS               = 0xf000
+	EV_TRIGGER                = 0x100
+	EWOULDBLOCK               = 0x23
+	EXDEV                     = 0x12
+	FD_CLOEXEC                = 0x1
+	FD_SETSIZE                = 0x400
+	F_ADDFILESIGS             = 0x3d
+	F_ADDSIGS                 = 0x3b
+	F_ALLOCATEALL             = 0x4
+	F_ALLOCATECONTIG          = 0x2
+	F_CHKCLEAN                = 0x29
+	F_DUPFD                   = 0
+	F_FREEZE_FS               = 0x35
+	F_FULLFSYNC               = 0x33
+	F_GETFD                   = 0x1
+	F_GETFL                   = 0x3
+	F_GETLK                   = 0x7
+	F_GETOWN                  = 0x5
+	F_GETPATH                 = 0x32
+	F_GLOBAL_NOCACHE          = 0x37
+	F_LOG2PHYS                = 0x31
+	F_MARKDEPENDENCY          = 0x3c
+	F_NOCACHE                 = 0x30
+	F_PATHPKG_CHECK           = 0x34
+	F_PEOFPOSMODE             = 0x3
+	F_PREALLOCATE             = 0x2a
+	F_RDADVISE                = 0x2c
+	F_RDAHEAD                 = 0x2d
+	F_RDLCK                   = 0x1
+	F_READBOOTSTRAP           = 0x2e
+	F_SETFD                   = 0x2
+	F_SETFL                   = 0x4
+	F_SETLK                   = 0x8
+	F_SETLKW                  = 0x9
+	F_SETOWN                  = 0x6
+	F_SETSIZE                 = 0x2b
+	F_THAW_FS                 = 0x36
+	F_UNLCK                   = 0x2
+	F_VOLPOSMODE              = 0x4
+	F_WRITEBOOTSTRAP          = 0x2f
+	F_WRLCK                   = 0x3
+	IPPROTO_3PC               = 0x22
+	IPPROTO_ADFS              = 0x44
+	IPPROTO_AH                = 0x33
+	IPPROTO_AHIP              = 0x3d
+	IPPROTO_APES              = 0x63
+	IPPROTO_ARGUS             = 0xd
+	IPPROTO_AX25              = 0x5d
+	IPPROTO_BHA               = 0x31
+	IPPROTO_BLT               = 0x1e
+	IPPROTO_BRSATMON          = 0x4c
+	IPPROTO_CFTP              = 0x3e
+	IPPROTO_CHAOS             = 0x10
+	IPPROTO_CMTP              = 0x26
+	IPPROTO_CPHB              = 0x49
+	IPPROTO_CPNX              = 0x48
+	IPPROTO_DDP               = 0x25
+	IPPROTO_DGP               = 0x56
+	IPPROTO_DIVERT            = 0xfe
+	IPPROTO_DONE              = 0x101
+	IPPROTO_DSTOPTS           = 0x3c
+	IPPROTO_EGP               = 0x8
+	IPPROTO_EMCON             = 0xe
+	IPPROTO_ENCAP             = 0x62
+	IPPROTO_EON               = 0x50
+	IPPROTO_ESP               = 0x32
+	IPPROTO_ETHERIP           = 0x61
+	IPPROTO_FRAGMENT          = 0x2c
+	IPPROTO_GGP               = 0x3
+	IPPROTO_GMTP              = 0x64
+	IPPROTO_GRE               = 0x2f
+	IPPROTO_HELLO             = 0x3f
+	IPPROTO_HMP               = 0x14
+	IPPROTO_HOPOPTS           = 0
+	IPPROTO_ICMP              = 0x1
+	IPPROTO_ICMPV6            = 0x3a
+	IPPROTO_IDP               = 0x16
+	IPPROTO_IDPR              = 0x23
+	IPPROTO_IDRP              = 0x2d
+	IPPROTO_IGMP              = 0x2
+	IPPROTO_IGP               = 0x55
+	IPPROTO_IGRP              = 0x58
+	IPPROTO_IL                = 0x28
+	IPPROTO_INLSP             = 0x34
+	IPPROTO_INP               = 0x20
+	IPPROTO_IP                = 0
+	IPPROTO_IPCOMP            = 0x6c
+	IPPROTO_IPCV              = 0x47
+	IPPROTO_IPEIP             = 0x5e
+	IPPROTO_IPIP              = 0x4
+	IPPROTO_IPPC              = 0x43
+	IPPROTO_IPV4              = 0x4
+	IPPROTO_IPV6              = 0x29
+	IPPROTO_IRTP              = 0x1c
+	IPPROTO_KRYPTOLAN         = 0x41
+	IPPROTO_LARP              = 0x5b
+	IPPROTO_LEAF1             = 0x19
+	IPPROTO_LEAF2             = 0x1a
+	IPPROTO_MAX               = 0x100
+	IPPROTO_MAXID             = 0x34
+	IPPROTO_MEAS              = 0x13
+	IPPROTO_MHRP              = 0x30
+	IPPROTO_MICP              = 0x5f
+	IPPROTO_MTP               = 0x5c
+	IPPROTO_MUX               = 0x12
+	IPPROTO_ND                = 0x4d
+	IPPROTO_NHRP              = 0x36
+	IPPROTO_NONE              = 0x3b
+	IPPROTO_NSP               = 0x1f
+	IPPROTO_NVPII             = 0xb
+	IPPROTO_OSPFIGP           = 0x59
+	IPPROTO_PGM               = 0x71
+	IPPROTO_PIGP              = 0x9
+	IPPROTO_PIM               = 0x67
+	IPPROTO_PRM               = 0x15
+	IPPROTO_PUP               = 0xc
+	IPPROTO_PVP               = 0x4b
+	IPPROTO_RAW               = 0xff
+	IPPROTO_RCCMON            = 0xa
+	IPPROTO_RDP               = 0x1b
+	IPPROTO_ROUTING           = 0x2b
+	IPPROTO_RSVP              = 0x2e
+	IPPROTO_RVD               = 0x42
+	IPPROTO_SATEXPAK          = 0x40
+	IPPROTO_SATMON            = 0x45
+	IPPROTO_SCCSP             = 0x60
+	IPPROTO_SDRP              = 0x2a
+	IPPROTO_SEP               = 0x21
+	IPPROTO_SRPC              = 0x5a
+	IPPROTO_ST                = 0x7
+	IPPROTO_SVMTP             = 0x52
+	IPPROTO_SWIPE             = 0x35
+	IPPROTO_TCF               = 0x57
+	IPPROTO_TCP               = 0x6
+	IPPROTO_TP                = 0x1d
+	IPPROTO_TPXX              = 0x27
+	IPPROTO_TRUNK1            = 0x17
+	IPPROTO_TRUNK2            = 0x18
+	IPPROTO_TTP               = 0x54
+	IPPROTO_UDP               = 0x11
+	IPPROTO_VINES             = 0x53
+	IPPROTO_VISA              = 0x46
+	IPPROTO_VMTP              = 0x51
+	IPPROTO_WBEXPAK           = 0x4f
+	IPPROTO_WBMON             = 0x4e
+	IPPROTO_WSN               = 0x4a
+	IPPROTO_XNET              = 0xf
+	IPPROTO_XTP               = 0x24
+	IP_ADD_MEMBERSHIP         = 0xc
+	IP_BOUND_IF               = 0x19
+	IP_DEFAULT_MULTICAST_LOOP = 0x1
+	IP_DEFAULT_MULTICAST_TTL  = 0x1
+	IP_DROP_MEMBERSHIP        = 0xd
+	IP_DUMMYNET_CONFIGURE     = 0x3c
+	IP_DUMMYNET_DEL           = 0x3d
+	IP_DUMMYNET_FLUSH         = 0x3e
+	IP_DUMMYNET_GET           = 0x40
+	IP_FAITH                  = 0x16
+	IP_FW_ADD                 = 0x28
+	IP_FW_DEL                 = 0x29
+	IP_FW_FLUSH               = 0x2a
+	IP_FW_GET                 = 0x2c
+	IP_FW_RESETLOG            = 0x2d
+	IP_FW_ZERO                = 0x2b
+	IP_HDRINCL                = 0x2
+	IP_IPSEC_POLICY           = 0x15
+	IP_MAX_MEMBERSHIPS        = 0x14
+	IP_MULTICAST_IF           = 0x9
+	IP_MULTICAST_LOOP         = 0xb
+	IP_MULTICAST_TTL          = 0xa
+	IP_MULTICAST_VIF          = 0xe
+	IP_NAT__XXX               = 0x37
+	IP_OLD_FW_ADD             = 0x32
+	IP_OLD_FW_DEL             = 0x33
+	IP_OLD_FW_FLUSH           = 0x34
+	IP_OLD_FW_GET             = 0x36
+	IP_OLD_FW_RESETLOG        = 0x38
+	IP_OLD_FW_ZERO            = 0x35
+	IP_OPTIONS                = 0x1
+	IP_PORTRANGE              = 0x13
+	IP_PORTRANGE_DEFAULT      = 0
+	IP_PORTRANGE_HIGH         = 0x1
+	IP_PORTRANGE_LOW          = 0x2
+	IP_RECVDSTADDR            = 0x7
+	IP_RECVIF                 = 0x14
+	IP_RECVOPTS               = 0x5
+	IP_RECVRETOPTS            = 0x6
+	IP_RECVTTL                = 0x18
+	IP_RETOPTS                = 0x8
+	IP_RSVP_OFF               = 0x10
+	IP_RSVP_ON                = 0xf
+	IP_RSVP_VIF_OFF           = 0x12
+	IP_RSVP_VIF_ON            = 0x11
+	IP_STRIPHDR               = 0x17
+	IP_TOS                    = 0x3
+	IP_TRAFFIC_MGT_BACKGROUND = 0x41
+	IP_TTL                    = 0x4
+	O_ACCMODE                 = 0x3
+	O_ALERT                   = 0x20000000
+	O_APPEND                  = 0x8
+	O_ASYNC                   = 0x40
+	O_CREAT                   = 0x200
+	O_DIRECTORY               = 0x100000
+	O_DSYNC                   = 0x400000
+	O_EVTONLY                 = 0x8000
+	O_EXCL                    = 0x800
+	O_EXLOCK                  = 0x20
+	O_FSYNC                   = 0x80
+	O_NDELAY                  = 0x4
+	O_NOCTTY                  = 0x20000
+	O_NOFOLLOW                = 0x100
+	O_NONBLOCK                = 0x4
+	O_POPUP                   = 0x80000000
+	O_RDONLY                  = 0
+	O_RDWR                    = 0x2
+	O_SHLOCK                  = 0x10
+	O_SYMLINK                 = 0x200000
+	O_SYNC                    = 0x80
+	O_TRUNC                   = 0x400
+	O_WRONLY                  = 0x1
+	SHUT_RD                   = 0
+	SHUT_RDWR                 = 0x2
+	SHUT_WR                   = 0x1
+	SIGABRT                   = 0x6
+	SIGALRM                   = 0xe
+	SIGBUS                    = 0xa
+	SIGCHLD                   = 0x14
+	SIGCONT                   = 0x13
+	SIGEMT                    = 0x7
+	SIGFPE                    = 0x8
+	SIGHUP                    = 0x1
+	SIGILL                    = 0x4
+	SIGINFO                   = 0x1d
+	SIGINT                    = 0x2
+	SIGIO                     = 0x17
+	SIGIOT                    = 0x6
+	SIGKILL                   = 0x9
+	SIGPIPE                   = 0xd
+	SIGPROF                   = 0x1b
+	SIGQUIT                   = 0x3
+	SIGSEGV                   = 0xb
+	SIGSTOP                   = 0x11
+	SIGSYS                    = 0xc
+	SIGTERM                   = 0xf
+	SIGTRAP                   = 0x5
+	SIGTSTP                   = 0x12
+	SIGTTIN                   = 0x15
+	SIGTTOU                   = 0x16
+	SIGURG                    = 0x10
+	SIGUSR1                   = 0x1e
+	SIGUSR2                   = 0x1f
+	SIGVTALRM                 = 0x1a
+	SIGWINCH                  = 0x1c
+	SIGXCPU                   = 0x18
+	SIGXFSZ                   = 0x19
+	SOCK_DGRAM                = 0x2
+	SOCK_MAXADDRLEN           = 0xff
+	SOCK_RAW                  = 0x3
+	SOCK_RDM                  = 0x4
+	SOCK_SEQPACKET            = 0x5
+	SOCK_STREAM               = 0x1
+	SOL_SOCKET                = 0xffff
+	SOMAXCONN                 = 0x80
+	SO_ACCEPTCONN             = 0x2
+	SO_BROADCAST              = 0x20
+	SO_DEBUG                  = 0x1
+	SO_DONTROUTE              = 0x10
+	SO_DONTTRUNC              = 0x2000
+	SO_ERROR                  = 0x1007
+	SO_KEEPALIVE              = 0x8
+	SO_LABEL                  = 0x1010
+	SO_LINGER                 = 0x80
+	SO_LINGER_SEC             = 0x1080
+	SO_NKE                    = 0x1021
+	SO_NOADDRERR              = 0x1023
+	SO_NOSIGPIPE              = 0x1022
+	SO_NOTIFYCONFLICT         = 0x1026
+	SO_NP_EXTENSIONS          = 0x1083
+	SO_NREAD                  = 0x1020
+	SO_NWRITE                 = 0x1024
+	SO_OOBINLINE              = 0x100
+	SO_PEERLABEL              = 0x1011
+	SO_RANDOMPORT             = 0x1082
+	SO_RCVBUF                 = 0x1002
+	SO_RCVLOWAT               = 0x1004
+	SO_RCVTIMEO               = 0x1006
+	SO_RESTRICTIONS           = 0x1081
+	SO_RESTRICT_DENYIN        = 0x1
+	SO_RESTRICT_DENYOUT       = 0x2
+	SO_RESTRICT_DENYSET       = 0x80000000
+	SO_REUSEADDR              = 0x4
+	SO_REUSEPORT              = 0x200
+	SO_REUSESHAREUID          = 0x1025
+	SO_SNDBUF                 = 0x1001
+	SO_SNDLOWAT               = 0x1003
+	SO_SNDTIMEO               = 0x1005
+	SO_TIMESTAMP              = 0x400
+	SO_TYPE                   = 0x1008
+	SO_UPCALLCLOSEWAIT        = 0x1027
+	SO_USELOOPBACK            = 0x40
+	SO_WANTMORE               = 0x4000
+	SO_WANTOOBFLAG            = 0x8000
+	S_IEXEC                   = 0x40
+	S_IFBLK                   = 0x6000
+	S_IFCHR                   = 0x2000
+	S_IFDIR                   = 0x4000
+	S_IFIFO                   = 0x1000
+	S_IFLNK                   = 0xa000
+	S_IFMT                    = 0xf000
+	S_IFREG                   = 0x8000
+	S_IFSOCK                  = 0xc000
+	S_IFWHT                   = 0xe000
+	S_IREAD                   = 0x100
+	S_IRGRP                   = 0x20
+	S_IROTH                   = 0x4
+	S_IRUSR                   = 0x100
+	S_IRWXG                   = 0x38
+	S_IRWXO                   = 0x7
+	S_IRWXU                   = 0x1c0
+	S_ISGID                   = 0x400
+	S_ISTXT                   = 0x200
+	S_ISUID                   = 0x800
+	S_ISVTX                   = 0x200
+	S_IWGRP                   = 0x10
+	S_IWOTH                   = 0x2
+	S_IWRITE                  = 0x80
+	S_IWUSR                   = 0x80
+	S_IXGRP                   = 0x8
+	S_IXOTH                   = 0x1
+	S_IXUSR                   = 0x40
+	TCP_CONNECTIONTIMEOUT     = 0x20
+	TCP_KEEPALIVE             = 0x10
+	TCP_MAXBURST              = 0x4
+	TCP_MAXHLEN               = 0x3c
+	TCP_MAXOLEN               = 0x28
+	TCP_MAXSEG                = 0x2
+	TCP_MAXWIN                = 0xffff
+	TCP_MAX_SACK              = 0x3
+	TCP_MAX_WINSHIFT          = 0xe
+	TCP_MINMSS                = 0xd8
+	TCP_MINMSSOVERLOAD        = 0x3e8
+	TCP_MSS                   = 0x200
+	TCP_NODELAY               = 0x1
+	TCP_NOOPT                 = 0x8
+	TCP_NOPUSH                = 0x4
+	WCONTINUED                = 0x10
+	WCOREFLAG                 = 0x80
+	WEXITED                   = 0x4
+	WNOHANG                   = 0x1
+	WNOWAIT                   = 0x20
+	WORDSIZE                  = 0x40
+	WSTOPPED                  = 0x7f
+	WUNTRACED                 = 0x2
 )
 
 // Types
diff --git a/src/pkg/syscall/zerrors_freebsd_386.go b/src/pkg/syscall/zerrors_freebsd_386.go
index b198adb95b..4c1b828e54 100644
--- a/src/pkg/syscall/zerrors_freebsd_386.go
+++ b/src/pkg/syscall/zerrors_freebsd_386.go
@@ -9,526 +9,526 @@ package syscall
 
 // Constants
 const (
-	AF_APPLETALK			= 0x10;
-	AF_ARP				= 0x23;
-	AF_ATM				= 0x1e;
-	AF_BLUETOOTH			= 0x24;
-	AF_CCITT			= 0xa;
-	AF_CHAOS			= 0x5;
-	AF_CNT				= 0x15;
-	AF_COIP				= 0x14;
-	AF_DATAKIT			= 0x9;
-	AF_DECnet			= 0xc;
-	AF_DLI				= 0xd;
-	AF_E164				= 0x1a;
-	AF_ECMA				= 0x8;
-	AF_HYLINK			= 0xf;
-	AF_IEEE80211			= 0x25;
-	AF_IMPLINK			= 0x3;
-	AF_INET				= 0x2;
-	AF_INET6			= 0x1c;
-	AF_IPX				= 0x17;
-	AF_ISDN				= 0x1a;
-	AF_ISO				= 0x7;
-	AF_LAT				= 0xe;
-	AF_LINK				= 0x12;
-	AF_LOCAL			= 0x1;
-	AF_MAX				= 0x26;
-	AF_NATM				= 0x1d;
-	AF_NETBIOS			= 0x6;
-	AF_NETGRAPH			= 0x20;
-	AF_OSI				= 0x7;
-	AF_PUP				= 0x4;
-	AF_ROUTE			= 0x11;
-	AF_SCLUSTER			= 0x22;
-	AF_SIP				= 0x18;
-	AF_SLOW				= 0x21;
-	AF_SNA				= 0xb;
-	AF_UNIX				= 0x1;
-	AF_UNSPEC			= 0;
-	AF_VENDOR00			= 0x27;
-	AF_VENDOR01			= 0x29;
-	AF_VENDOR02			= 0x2b;
-	AF_VENDOR03			= 0x2d;
-	AF_VENDOR04			= 0x2f;
-	AF_VENDOR05			= 0x31;
-	AF_VENDOR06			= 0x33;
-	AF_VENDOR07			= 0x35;
-	AF_VENDOR08			= 0x37;
-	AF_VENDOR09			= 0x39;
-	AF_VENDOR10			= 0x3b;
-	AF_VENDOR11			= 0x3d;
-	AF_VENDOR12			= 0x3f;
-	AF_VENDOR13			= 0x41;
-	AF_VENDOR14			= 0x43;
-	AF_VENDOR15			= 0x45;
-	AF_VENDOR16			= 0x47;
-	AF_VENDOR17			= 0x49;
-	AF_VENDOR18			= 0x4b;
-	AF_VENDOR19			= 0x4d;
-	AF_VENDOR20			= 0x4f;
-	AF_VENDOR21			= 0x51;
-	AF_VENDOR22			= 0x53;
-	AF_VENDOR23			= 0x55;
-	AF_VENDOR24			= 0x57;
-	AF_VENDOR25			= 0x59;
-	AF_VENDOR26			= 0x5b;
-	AF_VENDOR27			= 0x5d;
-	AF_VENDOR28			= 0x5f;
-	AF_VENDOR29			= 0x61;
-	AF_VENDOR30			= 0x63;
-	AF_VENDOR31			= 0x65;
-	AF_VENDOR32			= 0x67;
-	AF_VENDOR33			= 0x69;
-	AF_VENDOR34			= 0x6b;
-	AF_VENDOR35			= 0x6d;
-	AF_VENDOR36			= 0x6f;
-	AF_VENDOR37			= 0x71;
-	AF_VENDOR38			= 0x73;
-	AF_VENDOR39			= 0x75;
-	AF_VENDOR40			= 0x77;
-	AF_VENDOR41			= 0x79;
-	AF_VENDOR42			= 0x7b;
-	AF_VENDOR43			= 0x7d;
-	AF_VENDOR44			= 0x7f;
-	AF_VENDOR45			= 0x81;
-	AF_VENDOR46			= 0x83;
-	AF_VENDOR47			= 0x85;
-	E2BIG				= 0x7;
-	EACCES				= 0xd;
-	EADDRINUSE			= 0x30;
-	EADDRNOTAVAIL			= 0x31;
-	EAFNOSUPPORT			= 0x2f;
-	EAGAIN				= 0x23;
-	EALREADY			= 0x25;
-	EAUTH				= 0x50;
-	EBADF				= 0x9;
-	EBADMSG				= 0x59;
-	EBADRPC				= 0x48;
-	EBUSY				= 0x10;
-	ECANCELED			= 0x55;
-	ECHILD				= 0xa;
-	ECONNABORTED			= 0x35;
-	ECONNREFUSED			= 0x3d;
-	ECONNRESET			= 0x36;
-	EDEADLK				= 0xb;
-	EDESTADDRREQ			= 0x27;
-	EDOM				= 0x21;
-	EDOOFUS				= 0x58;
-	EDQUOT				= 0x45;
-	EEXIST				= 0x11;
-	EFAULT				= 0xe;
-	EFBIG				= 0x1b;
-	EFTYPE				= 0x4f;
-	EHOSTDOWN			= 0x40;
-	EHOSTUNREACH			= 0x41;
-	EIDRM				= 0x52;
-	EILSEQ				= 0x56;
-	EINPROGRESS			= 0x24;
-	EINTR				= 0x4;
-	EINVAL				= 0x16;
-	EIO				= 0x5;
-	EISCONN				= 0x38;
-	EISDIR				= 0x15;
-	ELAST				= 0x5c;
-	ELOOP				= 0x3e;
-	EMFILE				= 0x18;
-	EMLINK				= 0x1f;
-	EMSGSIZE			= 0x28;
-	EMULTIHOP			= 0x5a;
-	ENAMETOOLONG			= 0x3f;
-	ENEEDAUTH			= 0x51;
-	ENETDOWN			= 0x32;
-	ENETRESET			= 0x34;
-	ENETUNREACH			= 0x33;
-	ENFILE				= 0x17;
-	ENOATTR				= 0x57;
-	ENOBUFS				= 0x37;
-	ENODEV				= 0x13;
-	ENOENT				= 0x2;
-	ENOEXEC				= 0x8;
-	ENOLCK				= 0x4d;
-	ENOLINK				= 0x5b;
-	ENOMEM				= 0xc;
-	ENOMSG				= 0x53;
-	ENOPROTOOPT			= 0x2a;
-	ENOSPC				= 0x1c;
-	ENOSYS				= 0x4e;
-	ENOTBLK				= 0xf;
-	ENOTCONN			= 0x39;
-	ENOTDIR				= 0x14;
-	ENOTEMPTY			= 0x42;
-	ENOTSOCK			= 0x26;
-	ENOTSUP				= 0x2d;
-	ENOTTY				= 0x19;
-	ENXIO				= 0x6;
-	EOPNOTSUPP			= 0x2d;
-	EOVERFLOW			= 0x54;
-	EPERM				= 0x1;
-	EPFNOSUPPORT			= 0x2e;
-	EPIPE				= 0x20;
-	EPROCLIM			= 0x43;
-	EPROCUNAVAIL			= 0x4c;
-	EPROGMISMATCH			= 0x4b;
-	EPROGUNAVAIL			= 0x4a;
-	EPROTO				= 0x5c;
-	EPROTONOSUPPORT			= 0x2b;
-	EPROTOTYPE			= 0x29;
-	ERANGE				= 0x22;
-	EREMOTE				= 0x47;
-	EROFS				= 0x1e;
-	ERPCMISMATCH			= 0x49;
-	ESHUTDOWN			= 0x3a;
-	ESOCKTNOSUPPORT			= 0x2c;
-	ESPIPE				= 0x1d;
-	ESRCH				= 0x3;
-	ESTALE				= 0x46;
-	ETIMEDOUT			= 0x3c;
-	ETOOMANYREFS			= 0x3b;
-	ETXTBSY				= 0x1a;
-	EUSERS				= 0x44;
-	EVFILT_AIO			= -0x3;
-	EVFILT_FS			= -0x9;
-	EVFILT_LIO			= -0xa;
-	EVFILT_NETDEV			= -0x8;
-	EVFILT_PROC			= -0x5;
-	EVFILT_READ			= -0x1;
-	EVFILT_SIGNAL			= -0x6;
-	EVFILT_SYSCOUNT			= 0xa;
-	EVFILT_TIMER			= -0x7;
-	EVFILT_VNODE			= -0x4;
-	EVFILT_WRITE			= -0x2;
-	EV_ADD				= 0x1;
-	EV_CLEAR			= 0x20;
-	EV_DELETE			= 0x2;
-	EV_DISABLE			= 0x8;
-	EV_ENABLE			= 0x4;
-	EV_EOF				= 0x8000;
-	EV_ERROR			= 0x4000;
-	EV_FLAG1			= 0x2000;
-	EV_ONESHOT			= 0x10;
-	EV_SYSFLAGS			= 0xf000;
-	EWOULDBLOCK			= 0x23;
-	EXDEV				= 0x12;
-	FD_CLOEXEC			= 0x1;
-	FD_SETSIZE			= 0x400;
-	F_CANCEL			= 0x5;
-	F_DUP2FD			= 0xa;
-	F_DUPFD				= 0;
-	F_GETFD				= 0x1;
-	F_GETFL				= 0x3;
-	F_GETLK				= 0xb;
-	F_GETOWN			= 0x5;
-	F_OGETLK			= 0x7;
-	F_OSETLK			= 0x8;
-	F_OSETLKW			= 0x9;
-	F_RDLCK				= 0x1;
-	F_SETFD				= 0x2;
-	F_SETFL				= 0x4;
-	F_SETLK				= 0xc;
-	F_SETLKW			= 0xd;
-	F_SETLK_REMOTE			= 0xe;
-	F_SETOWN			= 0x6;
-	F_UNLCK				= 0x2;
-	F_UNLCKSYS			= 0x4;
-	F_WRLCK				= 0x3;
-	IPPROTO_3PC			= 0x22;
-	IPPROTO_ADFS			= 0x44;
-	IPPROTO_AH			= 0x33;
-	IPPROTO_AHIP			= 0x3d;
-	IPPROTO_APES			= 0x63;
-	IPPROTO_ARGUS			= 0xd;
-	IPPROTO_AX25			= 0x5d;
-	IPPROTO_BHA			= 0x31;
-	IPPROTO_BLT			= 0x1e;
-	IPPROTO_BRSATMON		= 0x4c;
-	IPPROTO_CARP			= 0x70;
-	IPPROTO_CFTP			= 0x3e;
-	IPPROTO_CHAOS			= 0x10;
-	IPPROTO_CMTP			= 0x26;
-	IPPROTO_CPHB			= 0x49;
-	IPPROTO_CPNX			= 0x48;
-	IPPROTO_DDP			= 0x25;
-	IPPROTO_DGP			= 0x56;
-	IPPROTO_DIVERT			= 0x102;
-	IPPROTO_DONE			= 0x101;
-	IPPROTO_DSTOPTS			= 0x3c;
-	IPPROTO_EGP			= 0x8;
-	IPPROTO_EMCON			= 0xe;
-	IPPROTO_ENCAP			= 0x62;
-	IPPROTO_EON			= 0x50;
-	IPPROTO_ESP			= 0x32;
-	IPPROTO_ETHERIP			= 0x61;
-	IPPROTO_FRAGMENT		= 0x2c;
-	IPPROTO_GGP			= 0x3;
-	IPPROTO_GMTP			= 0x64;
-	IPPROTO_GRE			= 0x2f;
-	IPPROTO_HELLO			= 0x3f;
-	IPPROTO_HMP			= 0x14;
-	IPPROTO_HOPOPTS			= 0;
-	IPPROTO_ICMP			= 0x1;
-	IPPROTO_ICMPV6			= 0x3a;
-	IPPROTO_IDP			= 0x16;
-	IPPROTO_IDPR			= 0x23;
-	IPPROTO_IDRP			= 0x2d;
-	IPPROTO_IGMP			= 0x2;
-	IPPROTO_IGP			= 0x55;
-	IPPROTO_IGRP			= 0x58;
-	IPPROTO_IL			= 0x28;
-	IPPROTO_INLSP			= 0x34;
-	IPPROTO_INP			= 0x20;
-	IPPROTO_IP			= 0;
-	IPPROTO_IPCOMP			= 0x6c;
-	IPPROTO_IPCV			= 0x47;
-	IPPROTO_IPEIP			= 0x5e;
-	IPPROTO_IPIP			= 0x4;
-	IPPROTO_IPPC			= 0x43;
-	IPPROTO_IPV4			= 0x4;
-	IPPROTO_IPV6			= 0x29;
-	IPPROTO_IRTP			= 0x1c;
-	IPPROTO_KRYPTOLAN		= 0x41;
-	IPPROTO_LARP			= 0x5b;
-	IPPROTO_LEAF1			= 0x19;
-	IPPROTO_LEAF2			= 0x1a;
-	IPPROTO_MAX			= 0x100;
-	IPPROTO_MAXID			= 0x34;
-	IPPROTO_MEAS			= 0x13;
-	IPPROTO_MHRP			= 0x30;
-	IPPROTO_MICP			= 0x5f;
-	IPPROTO_MOBILE			= 0x37;
-	IPPROTO_MTP			= 0x5c;
-	IPPROTO_MUX			= 0x12;
-	IPPROTO_ND			= 0x4d;
-	IPPROTO_NHRP			= 0x36;
-	IPPROTO_NONE			= 0x3b;
-	IPPROTO_NSP			= 0x1f;
-	IPPROTO_NVPII			= 0xb;
-	IPPROTO_OLD_DIVERT		= 0xfe;
-	IPPROTO_OSPFIGP			= 0x59;
-	IPPROTO_PFSYNC			= 0xf0;
-	IPPROTO_PGM			= 0x71;
-	IPPROTO_PIGP			= 0x9;
-	IPPROTO_PIM			= 0x67;
-	IPPROTO_PRM			= 0x15;
-	IPPROTO_PUP			= 0xc;
-	IPPROTO_PVP			= 0x4b;
-	IPPROTO_RAW			= 0xff;
-	IPPROTO_RCCMON			= 0xa;
-	IPPROTO_RDP			= 0x1b;
-	IPPROTO_ROUTING			= 0x2b;
-	IPPROTO_RSVP			= 0x2e;
-	IPPROTO_RVD			= 0x42;
-	IPPROTO_SATEXPAK		= 0x40;
-	IPPROTO_SATMON			= 0x45;
-	IPPROTO_SCCSP			= 0x60;
-	IPPROTO_SCTP			= 0x84;
-	IPPROTO_SDRP			= 0x2a;
-	IPPROTO_SEP			= 0x21;
-	IPPROTO_SKIP			= 0x39;
-	IPPROTO_SPACER			= 0x7fff;
-	IPPROTO_SRPC			= 0x5a;
-	IPPROTO_ST			= 0x7;
-	IPPROTO_SVMTP			= 0x52;
-	IPPROTO_SWIPE			= 0x35;
-	IPPROTO_TCF			= 0x57;
-	IPPROTO_TCP			= 0x6;
-	IPPROTO_TLSP			= 0x38;
-	IPPROTO_TP			= 0x1d;
-	IPPROTO_TPXX			= 0x27;
-	IPPROTO_TRUNK1			= 0x17;
-	IPPROTO_TRUNK2			= 0x18;
-	IPPROTO_TTP			= 0x54;
-	IPPROTO_UDP			= 0x11;
-	IPPROTO_VINES			= 0x53;
-	IPPROTO_VISA			= 0x46;
-	IPPROTO_VMTP			= 0x51;
-	IPPROTO_WBEXPAK			= 0x4f;
-	IPPROTO_WBMON			= 0x4e;
-	IPPROTO_WSN			= 0x4a;
-	IPPROTO_XNET			= 0xf;
-	IPPROTO_XTP			= 0x24;
-	IP_ADD_MEMBERSHIP		= 0xc;
-	IP_ADD_SOURCE_MEMBERSHIP	= 0x46;
-	IP_BINDANY			= 0x18;
-	IP_BLOCK_SOURCE			= 0x48;
-	IP_DEFAULT_MULTICAST_LOOP	= 0x1;
-	IP_DEFAULT_MULTICAST_TTL	= 0x1;
-	IP_DONTFRAG			= 0x43;
-	IP_DROP_MEMBERSHIP		= 0xd;
-	IP_DROP_SOURCE_MEMBERSHIP	= 0x47;
-	IP_DUMMYNET_CONFIGURE		= 0x3c;
-	IP_DUMMYNET_DEL			= 0x3d;
-	IP_DUMMYNET_FLUSH		= 0x3e;
-	IP_DUMMYNET_GET			= 0x40;
-	IP_FAITH			= 0x16;
-	IP_FW_ADD			= 0x32;
-	IP_FW_DEL			= 0x33;
-	IP_FW_FLUSH			= 0x34;
-	IP_FW_GET			= 0x36;
-	IP_FW_NAT_CFG			= 0x38;
-	IP_FW_NAT_DEL			= 0x39;
-	IP_FW_NAT_GET_CONFIG		= 0x3a;
-	IP_FW_NAT_GET_LOG		= 0x3b;
-	IP_FW_RESETLOG			= 0x37;
-	IP_FW_TABLE_ADD			= 0x28;
-	IP_FW_TABLE_DEL			= 0x29;
-	IP_FW_TABLE_FLUSH		= 0x2a;
-	IP_FW_TABLE_GETSIZE		= 0x2b;
-	IP_FW_TABLE_LIST		= 0x2c;
-	IP_FW_ZERO			= 0x35;
-	IP_HDRINCL			= 0x2;
-	IP_IPSEC_POLICY			= 0x15;
-	IP_MAX_GROUP_SRC_FILTER		= 0x200;
-	IP_MAX_MEMBERSHIPS		= 0xfff;
-	IP_MAX_SOCK_MUTE_FILTER		= 0x80;
-	IP_MAX_SOCK_SRC_FILTER		= 0x80;
-	IP_MAX_SOURCE_FILTER		= 0x400;
-	IP_MINTTL			= 0x42;
-	IP_MIN_MEMBERSHIPS		= 0x1f;
-	IP_MSFILTER			= 0x4a;
-	IP_MULTICAST_IF			= 0x9;
-	IP_MULTICAST_LOOP		= 0xb;
-	IP_MULTICAST_TTL		= 0xa;
-	IP_MULTICAST_VIF		= 0xe;
-	IP_ONESBCAST			= 0x17;
-	IP_OPTIONS			= 0x1;
-	IP_PORTRANGE			= 0x13;
-	IP_PORTRANGE_DEFAULT		= 0;
-	IP_PORTRANGE_HIGH		= 0x1;
-	IP_PORTRANGE_LOW		= 0x2;
-	IP_RECVDSTADDR			= 0x7;
-	IP_RECVIF			= 0x14;
-	IP_RECVOPTS			= 0x5;
-	IP_RECVRETOPTS			= 0x6;
-	IP_RECVTTL			= 0x41;
-	IP_RETOPTS			= 0x8;
-	IP_RSVP_OFF			= 0x10;
-	IP_RSVP_ON			= 0xf;
-	IP_RSVP_VIF_OFF			= 0x12;
-	IP_RSVP_VIF_ON			= 0x11;
-	IP_SENDSRCADDR			= 0x7;
-	IP_TOS				= 0x3;
-	IP_TTL				= 0x4;
-	IP_UNBLOCK_SOURCE		= 0x49;
-	O_ACCMODE			= 0x3;
-	O_APPEND			= 0x8;
-	O_ASYNC				= 0x40;
-	O_CREAT				= 0x200;
-	O_DIRECT			= 0x10000;
-	O_DIRECTORY			= 0x20000;
-	O_EXCL				= 0x800;
-	O_EXEC				= 0x40000;
-	O_EXLOCK			= 0x20;
-	O_FSYNC				= 0x80;
-	O_NDELAY			= 0x4;
-	O_NOCTTY			= 0x8000;
-	O_NOFOLLOW			= 0x100;
-	O_NONBLOCK			= 0x4;
-	O_RDONLY			= 0;
-	O_RDWR				= 0x2;
-	O_SHLOCK			= 0x10;
-	O_SYNC				= 0x80;
-	O_TRUNC				= 0x400;
-	O_TTY_INIT			= 0x80000;
-	O_WRONLY			= 0x1;
-	SHUT_RD				= 0;
-	SHUT_RDWR			= 0x2;
-	SHUT_WR				= 0x1;
-	SIGABRT				= 0x6;
-	SIGALRM				= 0xe;
-	SIGBUS				= 0xa;
-	SIGCHLD				= 0x14;
-	SIGCONT				= 0x13;
-	SIGEMT				= 0x7;
-	SIGFPE				= 0x8;
-	SIGHUP				= 0x1;
-	SIGILL				= 0x4;
-	SIGINFO				= 0x1d;
-	SIGINT				= 0x2;
-	SIGIO				= 0x17;
-	SIGIOT				= 0x6;
-	SIGKILL				= 0x9;
-	SIGLWP				= 0x20;
-	SIGPIPE				= 0xd;
-	SIGPROF				= 0x1b;
-	SIGQUIT				= 0x3;
-	SIGSEGV				= 0xb;
-	SIGSTOP				= 0x11;
-	SIGSYS				= 0xc;
-	SIGTERM				= 0xf;
-	SIGTHR				= 0x20;
-	SIGTRAP				= 0x5;
-	SIGTSTP				= 0x12;
-	SIGTTIN				= 0x15;
-	SIGTTOU				= 0x16;
-	SIGURG				= 0x10;
-	SIGUSR1				= 0x1e;
-	SIGUSR2				= 0x1f;
-	SIGVTALRM			= 0x1a;
-	SIGWINCH			= 0x1c;
-	SIGXCPU				= 0x18;
-	SIGXFSZ				= 0x19;
-	SOCK_DGRAM			= 0x2;
-	SOCK_MAXADDRLEN			= 0xff;
-	SOCK_RAW			= 0x3;
-	SOCK_RDM			= 0x4;
-	SOCK_SEQPACKET			= 0x5;
-	SOCK_STREAM			= 0x1;
-	SOL_SOCKET			= 0xffff;
-	SOMAXCONN			= 0x80;
-	SO_ACCEPTCONN			= 0x2;
-	SO_ACCEPTFILTER			= 0x1000;
-	SO_BINTIME			= 0x2000;
-	SO_BROADCAST			= 0x20;
-	SO_DEBUG			= 0x1;
-	SO_DONTROUTE			= 0x10;
-	SO_ERROR			= 0x1007;
-	SO_KEEPALIVE			= 0x8;
-	SO_LABEL			= 0x1009;
-	SO_LINGER			= 0x80;
-	SO_LISTENINCQLEN		= 0x1013;
-	SO_LISTENQLEN			= 0x1012;
-	SO_LISTENQLIMIT			= 0x1011;
-	SO_NOSIGPIPE			= 0x800;
-	SO_NO_DDP			= 0x8000;
-	SO_NO_OFFLOAD			= 0x4000;
-	SO_OOBINLINE			= 0x100;
-	SO_PEERLABEL			= 0x1010;
-	SO_RCVBUF			= 0x1002;
-	SO_RCVLOWAT			= 0x1004;
-	SO_RCVTIMEO			= 0x1006;
-	SO_REUSEADDR			= 0x4;
-	SO_REUSEPORT			= 0x200;
-	SO_SETFIB			= 0x1014;
-	SO_SNDBUF			= 0x1001;
-	SO_SNDLOWAT			= 0x1003;
-	SO_SNDTIMEO			= 0x1005;
-	SO_TIMESTAMP			= 0x400;
-	SO_TYPE				= 0x1008;
-	SO_USELOOPBACK			= 0x40;
-	TCP_CA_NAME_MAX			= 0x10;
-	TCP_CONGESTION			= 0x40;
-	TCP_INFO			= 0x20;
-	TCP_MAXBURST			= 0x4;
-	TCP_MAXHLEN			= 0x3c;
-	TCP_MAXOLEN			= 0x28;
-	TCP_MAXSEG			= 0x2;
-	TCP_MAXWIN			= 0xffff;
-	TCP_MAX_SACK			= 0x4;
-	TCP_MAX_WINSHIFT		= 0xe;
-	TCP_MD5SIG			= 0x10;
-	TCP_MINMSS			= 0xd8;
-	TCP_MSS				= 0x200;
-	TCP_NODELAY			= 0x1;
-	TCP_NOOPT			= 0x8;
-	TCP_NOPUSH			= 0x4;
-	WCONTINUED			= 0x4;
-	WCOREFLAG			= 0x80;
-	WLINUXCLONE			= 0x80000000;
-	WNOHANG				= 0x1;
-	WNOWAIT				= 0x8;
-	WSTOPPED			= 0x2;
-	WUNTRACED			= 0x2;
+	AF_APPLETALK              = 0x10
+	AF_ARP                    = 0x23
+	AF_ATM                    = 0x1e
+	AF_BLUETOOTH              = 0x24
+	AF_CCITT                  = 0xa
+	AF_CHAOS                  = 0x5
+	AF_CNT                    = 0x15
+	AF_COIP                   = 0x14
+	AF_DATAKIT                = 0x9
+	AF_DECnet                 = 0xc
+	AF_DLI                    = 0xd
+	AF_E164                   = 0x1a
+	AF_ECMA                   = 0x8
+	AF_HYLINK                 = 0xf
+	AF_IEEE80211              = 0x25
+	AF_IMPLINK                = 0x3
+	AF_INET                   = 0x2
+	AF_INET6                  = 0x1c
+	AF_IPX                    = 0x17
+	AF_ISDN                   = 0x1a
+	AF_ISO                    = 0x7
+	AF_LAT                    = 0xe
+	AF_LINK                   = 0x12
+	AF_LOCAL                  = 0x1
+	AF_MAX                    = 0x26
+	AF_NATM                   = 0x1d
+	AF_NETBIOS                = 0x6
+	AF_NETGRAPH               = 0x20
+	AF_OSI                    = 0x7
+	AF_PUP                    = 0x4
+	AF_ROUTE                  = 0x11
+	AF_SCLUSTER               = 0x22
+	AF_SIP                    = 0x18
+	AF_SLOW                   = 0x21
+	AF_SNA                    = 0xb
+	AF_UNIX                   = 0x1
+	AF_UNSPEC                 = 0
+	AF_VENDOR00               = 0x27
+	AF_VENDOR01               = 0x29
+	AF_VENDOR02               = 0x2b
+	AF_VENDOR03               = 0x2d
+	AF_VENDOR04               = 0x2f
+	AF_VENDOR05               = 0x31
+	AF_VENDOR06               = 0x33
+	AF_VENDOR07               = 0x35
+	AF_VENDOR08               = 0x37
+	AF_VENDOR09               = 0x39
+	AF_VENDOR10               = 0x3b
+	AF_VENDOR11               = 0x3d
+	AF_VENDOR12               = 0x3f
+	AF_VENDOR13               = 0x41
+	AF_VENDOR14               = 0x43
+	AF_VENDOR15               = 0x45
+	AF_VENDOR16               = 0x47
+	AF_VENDOR17               = 0x49
+	AF_VENDOR18               = 0x4b
+	AF_VENDOR19               = 0x4d
+	AF_VENDOR20               = 0x4f
+	AF_VENDOR21               = 0x51
+	AF_VENDOR22               = 0x53
+	AF_VENDOR23               = 0x55
+	AF_VENDOR24               = 0x57
+	AF_VENDOR25               = 0x59
+	AF_VENDOR26               = 0x5b
+	AF_VENDOR27               = 0x5d
+	AF_VENDOR28               = 0x5f
+	AF_VENDOR29               = 0x61
+	AF_VENDOR30               = 0x63
+	AF_VENDOR31               = 0x65
+	AF_VENDOR32               = 0x67
+	AF_VENDOR33               = 0x69
+	AF_VENDOR34               = 0x6b
+	AF_VENDOR35               = 0x6d
+	AF_VENDOR36               = 0x6f
+	AF_VENDOR37               = 0x71
+	AF_VENDOR38               = 0x73
+	AF_VENDOR39               = 0x75
+	AF_VENDOR40               = 0x77
+	AF_VENDOR41               = 0x79
+	AF_VENDOR42               = 0x7b
+	AF_VENDOR43               = 0x7d
+	AF_VENDOR44               = 0x7f
+	AF_VENDOR45               = 0x81
+	AF_VENDOR46               = 0x83
+	AF_VENDOR47               = 0x85
+	E2BIG                     = 0x7
+	EACCES                    = 0xd
+	EADDRINUSE                = 0x30
+	EADDRNOTAVAIL             = 0x31
+	EAFNOSUPPORT              = 0x2f
+	EAGAIN                    = 0x23
+	EALREADY                  = 0x25
+	EAUTH                     = 0x50
+	EBADF                     = 0x9
+	EBADMSG                   = 0x59
+	EBADRPC                   = 0x48
+	EBUSY                     = 0x10
+	ECANCELED                 = 0x55
+	ECHILD                    = 0xa
+	ECONNABORTED              = 0x35
+	ECONNREFUSED              = 0x3d
+	ECONNRESET                = 0x36
+	EDEADLK                   = 0xb
+	EDESTADDRREQ              = 0x27
+	EDOM                      = 0x21
+	EDOOFUS                   = 0x58
+	EDQUOT                    = 0x45
+	EEXIST                    = 0x11
+	EFAULT                    = 0xe
+	EFBIG                     = 0x1b
+	EFTYPE                    = 0x4f
+	EHOSTDOWN                 = 0x40
+	EHOSTUNREACH              = 0x41
+	EIDRM                     = 0x52
+	EILSEQ                    = 0x56
+	EINPROGRESS               = 0x24
+	EINTR                     = 0x4
+	EINVAL                    = 0x16
+	EIO                       = 0x5
+	EISCONN                   = 0x38
+	EISDIR                    = 0x15
+	ELAST                     = 0x5c
+	ELOOP                     = 0x3e
+	EMFILE                    = 0x18
+	EMLINK                    = 0x1f
+	EMSGSIZE                  = 0x28
+	EMULTIHOP                 = 0x5a
+	ENAMETOOLONG              = 0x3f
+	ENEEDAUTH                 = 0x51
+	ENETDOWN                  = 0x32
+	ENETRESET                 = 0x34
+	ENETUNREACH               = 0x33
+	ENFILE                    = 0x17
+	ENOATTR                   = 0x57
+	ENOBUFS                   = 0x37
+	ENODEV                    = 0x13
+	ENOENT                    = 0x2
+	ENOEXEC                   = 0x8
+	ENOLCK                    = 0x4d
+	ENOLINK                   = 0x5b
+	ENOMEM                    = 0xc
+	ENOMSG                    = 0x53
+	ENOPROTOOPT               = 0x2a
+	ENOSPC                    = 0x1c
+	ENOSYS                    = 0x4e
+	ENOTBLK                   = 0xf
+	ENOTCONN                  = 0x39
+	ENOTDIR                   = 0x14
+	ENOTEMPTY                 = 0x42
+	ENOTSOCK                  = 0x26
+	ENOTSUP                   = 0x2d
+	ENOTTY                    = 0x19
+	ENXIO                     = 0x6
+	EOPNOTSUPP                = 0x2d
+	EOVERFLOW                 = 0x54
+	EPERM                     = 0x1
+	EPFNOSUPPORT              = 0x2e
+	EPIPE                     = 0x20
+	EPROCLIM                  = 0x43
+	EPROCUNAVAIL              = 0x4c
+	EPROGMISMATCH             = 0x4b
+	EPROGUNAVAIL              = 0x4a
+	EPROTO                    = 0x5c
+	EPROTONOSUPPORT           = 0x2b
+	EPROTOTYPE                = 0x29
+	ERANGE                    = 0x22
+	EREMOTE                   = 0x47
+	EROFS                     = 0x1e
+	ERPCMISMATCH              = 0x49
+	ESHUTDOWN                 = 0x3a
+	ESOCKTNOSUPPORT           = 0x2c
+	ESPIPE                    = 0x1d
+	ESRCH                     = 0x3
+	ESTALE                    = 0x46
+	ETIMEDOUT                 = 0x3c
+	ETOOMANYREFS              = 0x3b
+	ETXTBSY                   = 0x1a
+	EUSERS                    = 0x44
+	EVFILT_AIO                = -0x3
+	EVFILT_FS                 = -0x9
+	EVFILT_LIO                = -0xa
+	EVFILT_NETDEV             = -0x8
+	EVFILT_PROC               = -0x5
+	EVFILT_READ               = -0x1
+	EVFILT_SIGNAL             = -0x6
+	EVFILT_SYSCOUNT           = 0xa
+	EVFILT_TIMER              = -0x7
+	EVFILT_VNODE              = -0x4
+	EVFILT_WRITE              = -0x2
+	EV_ADD                    = 0x1
+	EV_CLEAR                  = 0x20
+	EV_DELETE                 = 0x2
+	EV_DISABLE                = 0x8
+	EV_ENABLE                 = 0x4
+	EV_EOF                    = 0x8000
+	EV_ERROR                  = 0x4000
+	EV_FLAG1                  = 0x2000
+	EV_ONESHOT                = 0x10
+	EV_SYSFLAGS               = 0xf000
+	EWOULDBLOCK               = 0x23
+	EXDEV                     = 0x12
+	FD_CLOEXEC                = 0x1
+	FD_SETSIZE                = 0x400
+	F_CANCEL                  = 0x5
+	F_DUP2FD                  = 0xa
+	F_DUPFD                   = 0
+	F_GETFD                   = 0x1
+	F_GETFL                   = 0x3
+	F_GETLK                   = 0xb
+	F_GETOWN                  = 0x5
+	F_OGETLK                  = 0x7
+	F_OSETLK                  = 0x8
+	F_OSETLKW                 = 0x9
+	F_RDLCK                   = 0x1
+	F_SETFD                   = 0x2
+	F_SETFL                   = 0x4
+	F_SETLK                   = 0xc
+	F_SETLKW                  = 0xd
+	F_SETLK_REMOTE            = 0xe
+	F_SETOWN                  = 0x6
+	F_UNLCK                   = 0x2
+	F_UNLCKSYS                = 0x4
+	F_WRLCK                   = 0x3
+	IPPROTO_3PC               = 0x22
+	IPPROTO_ADFS              = 0x44
+	IPPROTO_AH                = 0x33
+	IPPROTO_AHIP              = 0x3d
+	IPPROTO_APES              = 0x63
+	IPPROTO_ARGUS             = 0xd
+	IPPROTO_AX25              = 0x5d
+	IPPROTO_BHA               = 0x31
+	IPPROTO_BLT               = 0x1e
+	IPPROTO_BRSATMON          = 0x4c
+	IPPROTO_CARP              = 0x70
+	IPPROTO_CFTP              = 0x3e
+	IPPROTO_CHAOS             = 0x10
+	IPPROTO_CMTP              = 0x26
+	IPPROTO_CPHB              = 0x49
+	IPPROTO_CPNX              = 0x48
+	IPPROTO_DDP               = 0x25
+	IPPROTO_DGP               = 0x56
+	IPPROTO_DIVERT            = 0x102
+	IPPROTO_DONE              = 0x101
+	IPPROTO_DSTOPTS           = 0x3c
+	IPPROTO_EGP               = 0x8
+	IPPROTO_EMCON             = 0xe
+	IPPROTO_ENCAP             = 0x62
+	IPPROTO_EON               = 0x50
+	IPPROTO_ESP               = 0x32
+	IPPROTO_ETHERIP           = 0x61
+	IPPROTO_FRAGMENT          = 0x2c
+	IPPROTO_GGP               = 0x3
+	IPPROTO_GMTP              = 0x64
+	IPPROTO_GRE               = 0x2f
+	IPPROTO_HELLO             = 0x3f
+	IPPROTO_HMP               = 0x14
+	IPPROTO_HOPOPTS           = 0
+	IPPROTO_ICMP              = 0x1
+	IPPROTO_ICMPV6            = 0x3a
+	IPPROTO_IDP               = 0x16
+	IPPROTO_IDPR              = 0x23
+	IPPROTO_IDRP              = 0x2d
+	IPPROTO_IGMP              = 0x2
+	IPPROTO_IGP               = 0x55
+	IPPROTO_IGRP              = 0x58
+	IPPROTO_IL                = 0x28
+	IPPROTO_INLSP             = 0x34
+	IPPROTO_INP               = 0x20
+	IPPROTO_IP                = 0
+	IPPROTO_IPCOMP            = 0x6c
+	IPPROTO_IPCV              = 0x47
+	IPPROTO_IPEIP             = 0x5e
+	IPPROTO_IPIP              = 0x4
+	IPPROTO_IPPC              = 0x43
+	IPPROTO_IPV4              = 0x4
+	IPPROTO_IPV6              = 0x29
+	IPPROTO_IRTP              = 0x1c
+	IPPROTO_KRYPTOLAN         = 0x41
+	IPPROTO_LARP              = 0x5b
+	IPPROTO_LEAF1             = 0x19
+	IPPROTO_LEAF2             = 0x1a
+	IPPROTO_MAX               = 0x100
+	IPPROTO_MAXID             = 0x34
+	IPPROTO_MEAS              = 0x13
+	IPPROTO_MHRP              = 0x30
+	IPPROTO_MICP              = 0x5f
+	IPPROTO_MOBILE            = 0x37
+	IPPROTO_MTP               = 0x5c
+	IPPROTO_MUX               = 0x12
+	IPPROTO_ND                = 0x4d
+	IPPROTO_NHRP              = 0x36
+	IPPROTO_NONE              = 0x3b
+	IPPROTO_NSP               = 0x1f
+	IPPROTO_NVPII             = 0xb
+	IPPROTO_OLD_DIVERT        = 0xfe
+	IPPROTO_OSPFIGP           = 0x59
+	IPPROTO_PFSYNC            = 0xf0
+	IPPROTO_PGM               = 0x71
+	IPPROTO_PIGP              = 0x9
+	IPPROTO_PIM               = 0x67
+	IPPROTO_PRM               = 0x15
+	IPPROTO_PUP               = 0xc
+	IPPROTO_PVP               = 0x4b
+	IPPROTO_RAW               = 0xff
+	IPPROTO_RCCMON            = 0xa
+	IPPROTO_RDP               = 0x1b
+	IPPROTO_ROUTING           = 0x2b
+	IPPROTO_RSVP              = 0x2e
+	IPPROTO_RVD               = 0x42
+	IPPROTO_SATEXPAK          = 0x40
+	IPPROTO_SATMON            = 0x45
+	IPPROTO_SCCSP             = 0x60
+	IPPROTO_SCTP              = 0x84
+	IPPROTO_SDRP              = 0x2a
+	IPPROTO_SEP               = 0x21
+	IPPROTO_SKIP              = 0x39
+	IPPROTO_SPACER            = 0x7fff
+	IPPROTO_SRPC              = 0x5a
+	IPPROTO_ST                = 0x7
+	IPPROTO_SVMTP             = 0x52
+	IPPROTO_SWIPE             = 0x35
+	IPPROTO_TCF               = 0x57
+	IPPROTO_TCP               = 0x6
+	IPPROTO_TLSP              = 0x38
+	IPPROTO_TP                = 0x1d
+	IPPROTO_TPXX              = 0x27
+	IPPROTO_TRUNK1            = 0x17
+	IPPROTO_TRUNK2            = 0x18
+	IPPROTO_TTP               = 0x54
+	IPPROTO_UDP               = 0x11
+	IPPROTO_VINES             = 0x53
+	IPPROTO_VISA              = 0x46
+	IPPROTO_VMTP              = 0x51
+	IPPROTO_WBEXPAK           = 0x4f
+	IPPROTO_WBMON             = 0x4e
+	IPPROTO_WSN               = 0x4a
+	IPPROTO_XNET              = 0xf
+	IPPROTO_XTP               = 0x24
+	IP_ADD_MEMBERSHIP         = 0xc
+	IP_ADD_SOURCE_MEMBERSHIP  = 0x46
+	IP_BINDANY                = 0x18
+	IP_BLOCK_SOURCE           = 0x48
+	IP_DEFAULT_MULTICAST_LOOP = 0x1
+	IP_DEFAULT_MULTICAST_TTL  = 0x1
+	IP_DONTFRAG               = 0x43
+	IP_DROP_MEMBERSHIP        = 0xd
+	IP_DROP_SOURCE_MEMBERSHIP = 0x47
+	IP_DUMMYNET_CONFIGURE     = 0x3c
+	IP_DUMMYNET_DEL           = 0x3d
+	IP_DUMMYNET_FLUSH         = 0x3e
+	IP_DUMMYNET_GET           = 0x40
+	IP_FAITH                  = 0x16
+	IP_FW_ADD                 = 0x32
+	IP_FW_DEL                 = 0x33
+	IP_FW_FLUSH               = 0x34
+	IP_FW_GET                 = 0x36
+	IP_FW_NAT_CFG             = 0x38
+	IP_FW_NAT_DEL             = 0x39
+	IP_FW_NAT_GET_CONFIG      = 0x3a
+	IP_FW_NAT_GET_LOG         = 0x3b
+	IP_FW_RESETLOG            = 0x37
+	IP_FW_TABLE_ADD           = 0x28
+	IP_FW_TABLE_DEL           = 0x29
+	IP_FW_TABLE_FLUSH         = 0x2a
+	IP_FW_TABLE_GETSIZE       = 0x2b
+	IP_FW_TABLE_LIST          = 0x2c
+	IP_FW_ZERO                = 0x35
+	IP_HDRINCL                = 0x2
+	IP_IPSEC_POLICY           = 0x15
+	IP_MAX_GROUP_SRC_FILTER   = 0x200
+	IP_MAX_MEMBERSHIPS        = 0xfff
+	IP_MAX_SOCK_MUTE_FILTER   = 0x80
+	IP_MAX_SOCK_SRC_FILTER    = 0x80
+	IP_MAX_SOURCE_FILTER      = 0x400
+	IP_MINTTL                 = 0x42
+	IP_MIN_MEMBERSHIPS        = 0x1f
+	IP_MSFILTER               = 0x4a
+	IP_MULTICAST_IF           = 0x9
+	IP_MULTICAST_LOOP         = 0xb
+	IP_MULTICAST_TTL          = 0xa
+	IP_MULTICAST_VIF          = 0xe
+	IP_ONESBCAST              = 0x17
+	IP_OPTIONS                = 0x1
+	IP_PORTRANGE              = 0x13
+	IP_PORTRANGE_DEFAULT      = 0
+	IP_PORTRANGE_HIGH         = 0x1
+	IP_PORTRANGE_LOW          = 0x2
+	IP_RECVDSTADDR            = 0x7
+	IP_RECVIF                 = 0x14
+	IP_RECVOPTS               = 0x5
+	IP_RECVRETOPTS            = 0x6
+	IP_RECVTTL                = 0x41
+	IP_RETOPTS                = 0x8
+	IP_RSVP_OFF               = 0x10
+	IP_RSVP_ON                = 0xf
+	IP_RSVP_VIF_OFF           = 0x12
+	IP_RSVP_VIF_ON            = 0x11
+	IP_SENDSRCADDR            = 0x7
+	IP_TOS                    = 0x3
+	IP_TTL                    = 0x4
+	IP_UNBLOCK_SOURCE         = 0x49
+	O_ACCMODE                 = 0x3
+	O_APPEND                  = 0x8
+	O_ASYNC                   = 0x40
+	O_CREAT                   = 0x200
+	O_DIRECT                  = 0x10000
+	O_DIRECTORY               = 0x20000
+	O_EXCL                    = 0x800
+	O_EXEC                    = 0x40000
+	O_EXLOCK                  = 0x20
+	O_FSYNC                   = 0x80
+	O_NDELAY                  = 0x4
+	O_NOCTTY                  = 0x8000
+	O_NOFOLLOW                = 0x100
+	O_NONBLOCK                = 0x4
+	O_RDONLY                  = 0
+	O_RDWR                    = 0x2
+	O_SHLOCK                  = 0x10
+	O_SYNC                    = 0x80
+	O_TRUNC                   = 0x400
+	O_TTY_INIT                = 0x80000
+	O_WRONLY                  = 0x1
+	SHUT_RD                   = 0
+	SHUT_RDWR                 = 0x2
+	SHUT_WR                   = 0x1
+	SIGABRT                   = 0x6
+	SIGALRM                   = 0xe
+	SIGBUS                    = 0xa
+	SIGCHLD                   = 0x14
+	SIGCONT                   = 0x13
+	SIGEMT                    = 0x7
+	SIGFPE                    = 0x8
+	SIGHUP                    = 0x1
+	SIGILL                    = 0x4
+	SIGINFO                   = 0x1d
+	SIGINT                    = 0x2
+	SIGIO                     = 0x17
+	SIGIOT                    = 0x6
+	SIGKILL                   = 0x9
+	SIGLWP                    = 0x20
+	SIGPIPE                   = 0xd
+	SIGPROF                   = 0x1b
+	SIGQUIT                   = 0x3
+	SIGSEGV                   = 0xb
+	SIGSTOP                   = 0x11
+	SIGSYS                    = 0xc
+	SIGTERM                   = 0xf
+	SIGTHR                    = 0x20
+	SIGTRAP                   = 0x5
+	SIGTSTP                   = 0x12
+	SIGTTIN                   = 0x15
+	SIGTTOU                   = 0x16
+	SIGURG                    = 0x10
+	SIGUSR1                   = 0x1e
+	SIGUSR2                   = 0x1f
+	SIGVTALRM                 = 0x1a
+	SIGWINCH                  = 0x1c
+	SIGXCPU                   = 0x18
+	SIGXFSZ                   = 0x19
+	SOCK_DGRAM                = 0x2
+	SOCK_MAXADDRLEN           = 0xff
+	SOCK_RAW                  = 0x3
+	SOCK_RDM                  = 0x4
+	SOCK_SEQPACKET            = 0x5
+	SOCK_STREAM               = 0x1
+	SOL_SOCKET                = 0xffff
+	SOMAXCONN                 = 0x80
+	SO_ACCEPTCONN             = 0x2
+	SO_ACCEPTFILTER           = 0x1000
+	SO_BINTIME                = 0x2000
+	SO_BROADCAST              = 0x20
+	SO_DEBUG                  = 0x1
+	SO_DONTROUTE              = 0x10
+	SO_ERROR                  = 0x1007
+	SO_KEEPALIVE              = 0x8
+	SO_LABEL                  = 0x1009
+	SO_LINGER                 = 0x80
+	SO_LISTENINCQLEN          = 0x1013
+	SO_LISTENQLEN             = 0x1012
+	SO_LISTENQLIMIT           = 0x1011
+	SO_NOSIGPIPE              = 0x800
+	SO_NO_DDP                 = 0x8000
+	SO_NO_OFFLOAD             = 0x4000
+	SO_OOBINLINE              = 0x100
+	SO_PEERLABEL              = 0x1010
+	SO_RCVBUF                 = 0x1002
+	SO_RCVLOWAT               = 0x1004
+	SO_RCVTIMEO               = 0x1006
+	SO_REUSEADDR              = 0x4
+	SO_REUSEPORT              = 0x200
+	SO_SETFIB                 = 0x1014
+	SO_SNDBUF                 = 0x1001
+	SO_SNDLOWAT               = 0x1003
+	SO_SNDTIMEO               = 0x1005
+	SO_TIMESTAMP              = 0x400
+	SO_TYPE                   = 0x1008
+	SO_USELOOPBACK            = 0x40
+	TCP_CA_NAME_MAX           = 0x10
+	TCP_CONGESTION            = 0x40
+	TCP_INFO                  = 0x20
+	TCP_MAXBURST              = 0x4
+	TCP_MAXHLEN               = 0x3c
+	TCP_MAXOLEN               = 0x28
+	TCP_MAXSEG                = 0x2
+	TCP_MAXWIN                = 0xffff
+	TCP_MAX_SACK              = 0x4
+	TCP_MAX_WINSHIFT          = 0xe
+	TCP_MD5SIG                = 0x10
+	TCP_MINMSS                = 0xd8
+	TCP_MSS                   = 0x200
+	TCP_NODELAY               = 0x1
+	TCP_NOOPT                 = 0x8
+	TCP_NOPUSH                = 0x4
+	WCONTINUED                = 0x4
+	WCOREFLAG                 = 0x80
+	WLINUXCLONE               = 0x80000000
+	WNOHANG                   = 0x1
+	WNOWAIT                   = 0x8
+	WSTOPPED                  = 0x2
+	WUNTRACED                 = 0x2
 )
 
 // Types
diff --git a/src/pkg/syscall/zerrors_freebsd_amd64.go b/src/pkg/syscall/zerrors_freebsd_amd64.go
index b198adb95b..4c1b828e54 100644
--- a/src/pkg/syscall/zerrors_freebsd_amd64.go
+++ b/src/pkg/syscall/zerrors_freebsd_amd64.go
@@ -9,526 +9,526 @@ package syscall
 
 // Constants
 const (
-	AF_APPLETALK			= 0x10;
-	AF_ARP				= 0x23;
-	AF_ATM				= 0x1e;
-	AF_BLUETOOTH			= 0x24;
-	AF_CCITT			= 0xa;
-	AF_CHAOS			= 0x5;
-	AF_CNT				= 0x15;
-	AF_COIP				= 0x14;
-	AF_DATAKIT			= 0x9;
-	AF_DECnet			= 0xc;
-	AF_DLI				= 0xd;
-	AF_E164				= 0x1a;
-	AF_ECMA				= 0x8;
-	AF_HYLINK			= 0xf;
-	AF_IEEE80211			= 0x25;
-	AF_IMPLINK			= 0x3;
-	AF_INET				= 0x2;
-	AF_INET6			= 0x1c;
-	AF_IPX				= 0x17;
-	AF_ISDN				= 0x1a;
-	AF_ISO				= 0x7;
-	AF_LAT				= 0xe;
-	AF_LINK				= 0x12;
-	AF_LOCAL			= 0x1;
-	AF_MAX				= 0x26;
-	AF_NATM				= 0x1d;
-	AF_NETBIOS			= 0x6;
-	AF_NETGRAPH			= 0x20;
-	AF_OSI				= 0x7;
-	AF_PUP				= 0x4;
-	AF_ROUTE			= 0x11;
-	AF_SCLUSTER			= 0x22;
-	AF_SIP				= 0x18;
-	AF_SLOW				= 0x21;
-	AF_SNA				= 0xb;
-	AF_UNIX				= 0x1;
-	AF_UNSPEC			= 0;
-	AF_VENDOR00			= 0x27;
-	AF_VENDOR01			= 0x29;
-	AF_VENDOR02			= 0x2b;
-	AF_VENDOR03			= 0x2d;
-	AF_VENDOR04			= 0x2f;
-	AF_VENDOR05			= 0x31;
-	AF_VENDOR06			= 0x33;
-	AF_VENDOR07			= 0x35;
-	AF_VENDOR08			= 0x37;
-	AF_VENDOR09			= 0x39;
-	AF_VENDOR10			= 0x3b;
-	AF_VENDOR11			= 0x3d;
-	AF_VENDOR12			= 0x3f;
-	AF_VENDOR13			= 0x41;
-	AF_VENDOR14			= 0x43;
-	AF_VENDOR15			= 0x45;
-	AF_VENDOR16			= 0x47;
-	AF_VENDOR17			= 0x49;
-	AF_VENDOR18			= 0x4b;
-	AF_VENDOR19			= 0x4d;
-	AF_VENDOR20			= 0x4f;
-	AF_VENDOR21			= 0x51;
-	AF_VENDOR22			= 0x53;
-	AF_VENDOR23			= 0x55;
-	AF_VENDOR24			= 0x57;
-	AF_VENDOR25			= 0x59;
-	AF_VENDOR26			= 0x5b;
-	AF_VENDOR27			= 0x5d;
-	AF_VENDOR28			= 0x5f;
-	AF_VENDOR29			= 0x61;
-	AF_VENDOR30			= 0x63;
-	AF_VENDOR31			= 0x65;
-	AF_VENDOR32			= 0x67;
-	AF_VENDOR33			= 0x69;
-	AF_VENDOR34			= 0x6b;
-	AF_VENDOR35			= 0x6d;
-	AF_VENDOR36			= 0x6f;
-	AF_VENDOR37			= 0x71;
-	AF_VENDOR38			= 0x73;
-	AF_VENDOR39			= 0x75;
-	AF_VENDOR40			= 0x77;
-	AF_VENDOR41			= 0x79;
-	AF_VENDOR42			= 0x7b;
-	AF_VENDOR43			= 0x7d;
-	AF_VENDOR44			= 0x7f;
-	AF_VENDOR45			= 0x81;
-	AF_VENDOR46			= 0x83;
-	AF_VENDOR47			= 0x85;
-	E2BIG				= 0x7;
-	EACCES				= 0xd;
-	EADDRINUSE			= 0x30;
-	EADDRNOTAVAIL			= 0x31;
-	EAFNOSUPPORT			= 0x2f;
-	EAGAIN				= 0x23;
-	EALREADY			= 0x25;
-	EAUTH				= 0x50;
-	EBADF				= 0x9;
-	EBADMSG				= 0x59;
-	EBADRPC				= 0x48;
-	EBUSY				= 0x10;
-	ECANCELED			= 0x55;
-	ECHILD				= 0xa;
-	ECONNABORTED			= 0x35;
-	ECONNREFUSED			= 0x3d;
-	ECONNRESET			= 0x36;
-	EDEADLK				= 0xb;
-	EDESTADDRREQ			= 0x27;
-	EDOM				= 0x21;
-	EDOOFUS				= 0x58;
-	EDQUOT				= 0x45;
-	EEXIST				= 0x11;
-	EFAULT				= 0xe;
-	EFBIG				= 0x1b;
-	EFTYPE				= 0x4f;
-	EHOSTDOWN			= 0x40;
-	EHOSTUNREACH			= 0x41;
-	EIDRM				= 0x52;
-	EILSEQ				= 0x56;
-	EINPROGRESS			= 0x24;
-	EINTR				= 0x4;
-	EINVAL				= 0x16;
-	EIO				= 0x5;
-	EISCONN				= 0x38;
-	EISDIR				= 0x15;
-	ELAST				= 0x5c;
-	ELOOP				= 0x3e;
-	EMFILE				= 0x18;
-	EMLINK				= 0x1f;
-	EMSGSIZE			= 0x28;
-	EMULTIHOP			= 0x5a;
-	ENAMETOOLONG			= 0x3f;
-	ENEEDAUTH			= 0x51;
-	ENETDOWN			= 0x32;
-	ENETRESET			= 0x34;
-	ENETUNREACH			= 0x33;
-	ENFILE				= 0x17;
-	ENOATTR				= 0x57;
-	ENOBUFS				= 0x37;
-	ENODEV				= 0x13;
-	ENOENT				= 0x2;
-	ENOEXEC				= 0x8;
-	ENOLCK				= 0x4d;
-	ENOLINK				= 0x5b;
-	ENOMEM				= 0xc;
-	ENOMSG				= 0x53;
-	ENOPROTOOPT			= 0x2a;
-	ENOSPC				= 0x1c;
-	ENOSYS				= 0x4e;
-	ENOTBLK				= 0xf;
-	ENOTCONN			= 0x39;
-	ENOTDIR				= 0x14;
-	ENOTEMPTY			= 0x42;
-	ENOTSOCK			= 0x26;
-	ENOTSUP				= 0x2d;
-	ENOTTY				= 0x19;
-	ENXIO				= 0x6;
-	EOPNOTSUPP			= 0x2d;
-	EOVERFLOW			= 0x54;
-	EPERM				= 0x1;
-	EPFNOSUPPORT			= 0x2e;
-	EPIPE				= 0x20;
-	EPROCLIM			= 0x43;
-	EPROCUNAVAIL			= 0x4c;
-	EPROGMISMATCH			= 0x4b;
-	EPROGUNAVAIL			= 0x4a;
-	EPROTO				= 0x5c;
-	EPROTONOSUPPORT			= 0x2b;
-	EPROTOTYPE			= 0x29;
-	ERANGE				= 0x22;
-	EREMOTE				= 0x47;
-	EROFS				= 0x1e;
-	ERPCMISMATCH			= 0x49;
-	ESHUTDOWN			= 0x3a;
-	ESOCKTNOSUPPORT			= 0x2c;
-	ESPIPE				= 0x1d;
-	ESRCH				= 0x3;
-	ESTALE				= 0x46;
-	ETIMEDOUT			= 0x3c;
-	ETOOMANYREFS			= 0x3b;
-	ETXTBSY				= 0x1a;
-	EUSERS				= 0x44;
-	EVFILT_AIO			= -0x3;
-	EVFILT_FS			= -0x9;
-	EVFILT_LIO			= -0xa;
-	EVFILT_NETDEV			= -0x8;
-	EVFILT_PROC			= -0x5;
-	EVFILT_READ			= -0x1;
-	EVFILT_SIGNAL			= -0x6;
-	EVFILT_SYSCOUNT			= 0xa;
-	EVFILT_TIMER			= -0x7;
-	EVFILT_VNODE			= -0x4;
-	EVFILT_WRITE			= -0x2;
-	EV_ADD				= 0x1;
-	EV_CLEAR			= 0x20;
-	EV_DELETE			= 0x2;
-	EV_DISABLE			= 0x8;
-	EV_ENABLE			= 0x4;
-	EV_EOF				= 0x8000;
-	EV_ERROR			= 0x4000;
-	EV_FLAG1			= 0x2000;
-	EV_ONESHOT			= 0x10;
-	EV_SYSFLAGS			= 0xf000;
-	EWOULDBLOCK			= 0x23;
-	EXDEV				= 0x12;
-	FD_CLOEXEC			= 0x1;
-	FD_SETSIZE			= 0x400;
-	F_CANCEL			= 0x5;
-	F_DUP2FD			= 0xa;
-	F_DUPFD				= 0;
-	F_GETFD				= 0x1;
-	F_GETFL				= 0x3;
-	F_GETLK				= 0xb;
-	F_GETOWN			= 0x5;
-	F_OGETLK			= 0x7;
-	F_OSETLK			= 0x8;
-	F_OSETLKW			= 0x9;
-	F_RDLCK				= 0x1;
-	F_SETFD				= 0x2;
-	F_SETFL				= 0x4;
-	F_SETLK				= 0xc;
-	F_SETLKW			= 0xd;
-	F_SETLK_REMOTE			= 0xe;
-	F_SETOWN			= 0x6;
-	F_UNLCK				= 0x2;
-	F_UNLCKSYS			= 0x4;
-	F_WRLCK				= 0x3;
-	IPPROTO_3PC			= 0x22;
-	IPPROTO_ADFS			= 0x44;
-	IPPROTO_AH			= 0x33;
-	IPPROTO_AHIP			= 0x3d;
-	IPPROTO_APES			= 0x63;
-	IPPROTO_ARGUS			= 0xd;
-	IPPROTO_AX25			= 0x5d;
-	IPPROTO_BHA			= 0x31;
-	IPPROTO_BLT			= 0x1e;
-	IPPROTO_BRSATMON		= 0x4c;
-	IPPROTO_CARP			= 0x70;
-	IPPROTO_CFTP			= 0x3e;
-	IPPROTO_CHAOS			= 0x10;
-	IPPROTO_CMTP			= 0x26;
-	IPPROTO_CPHB			= 0x49;
-	IPPROTO_CPNX			= 0x48;
-	IPPROTO_DDP			= 0x25;
-	IPPROTO_DGP			= 0x56;
-	IPPROTO_DIVERT			= 0x102;
-	IPPROTO_DONE			= 0x101;
-	IPPROTO_DSTOPTS			= 0x3c;
-	IPPROTO_EGP			= 0x8;
-	IPPROTO_EMCON			= 0xe;
-	IPPROTO_ENCAP			= 0x62;
-	IPPROTO_EON			= 0x50;
-	IPPROTO_ESP			= 0x32;
-	IPPROTO_ETHERIP			= 0x61;
-	IPPROTO_FRAGMENT		= 0x2c;
-	IPPROTO_GGP			= 0x3;
-	IPPROTO_GMTP			= 0x64;
-	IPPROTO_GRE			= 0x2f;
-	IPPROTO_HELLO			= 0x3f;
-	IPPROTO_HMP			= 0x14;
-	IPPROTO_HOPOPTS			= 0;
-	IPPROTO_ICMP			= 0x1;
-	IPPROTO_ICMPV6			= 0x3a;
-	IPPROTO_IDP			= 0x16;
-	IPPROTO_IDPR			= 0x23;
-	IPPROTO_IDRP			= 0x2d;
-	IPPROTO_IGMP			= 0x2;
-	IPPROTO_IGP			= 0x55;
-	IPPROTO_IGRP			= 0x58;
-	IPPROTO_IL			= 0x28;
-	IPPROTO_INLSP			= 0x34;
-	IPPROTO_INP			= 0x20;
-	IPPROTO_IP			= 0;
-	IPPROTO_IPCOMP			= 0x6c;
-	IPPROTO_IPCV			= 0x47;
-	IPPROTO_IPEIP			= 0x5e;
-	IPPROTO_IPIP			= 0x4;
-	IPPROTO_IPPC			= 0x43;
-	IPPROTO_IPV4			= 0x4;
-	IPPROTO_IPV6			= 0x29;
-	IPPROTO_IRTP			= 0x1c;
-	IPPROTO_KRYPTOLAN		= 0x41;
-	IPPROTO_LARP			= 0x5b;
-	IPPROTO_LEAF1			= 0x19;
-	IPPROTO_LEAF2			= 0x1a;
-	IPPROTO_MAX			= 0x100;
-	IPPROTO_MAXID			= 0x34;
-	IPPROTO_MEAS			= 0x13;
-	IPPROTO_MHRP			= 0x30;
-	IPPROTO_MICP			= 0x5f;
-	IPPROTO_MOBILE			= 0x37;
-	IPPROTO_MTP			= 0x5c;
-	IPPROTO_MUX			= 0x12;
-	IPPROTO_ND			= 0x4d;
-	IPPROTO_NHRP			= 0x36;
-	IPPROTO_NONE			= 0x3b;
-	IPPROTO_NSP			= 0x1f;
-	IPPROTO_NVPII			= 0xb;
-	IPPROTO_OLD_DIVERT		= 0xfe;
-	IPPROTO_OSPFIGP			= 0x59;
-	IPPROTO_PFSYNC			= 0xf0;
-	IPPROTO_PGM			= 0x71;
-	IPPROTO_PIGP			= 0x9;
-	IPPROTO_PIM			= 0x67;
-	IPPROTO_PRM			= 0x15;
-	IPPROTO_PUP			= 0xc;
-	IPPROTO_PVP			= 0x4b;
-	IPPROTO_RAW			= 0xff;
-	IPPROTO_RCCMON			= 0xa;
-	IPPROTO_RDP			= 0x1b;
-	IPPROTO_ROUTING			= 0x2b;
-	IPPROTO_RSVP			= 0x2e;
-	IPPROTO_RVD			= 0x42;
-	IPPROTO_SATEXPAK		= 0x40;
-	IPPROTO_SATMON			= 0x45;
-	IPPROTO_SCCSP			= 0x60;
-	IPPROTO_SCTP			= 0x84;
-	IPPROTO_SDRP			= 0x2a;
-	IPPROTO_SEP			= 0x21;
-	IPPROTO_SKIP			= 0x39;
-	IPPROTO_SPACER			= 0x7fff;
-	IPPROTO_SRPC			= 0x5a;
-	IPPROTO_ST			= 0x7;
-	IPPROTO_SVMTP			= 0x52;
-	IPPROTO_SWIPE			= 0x35;
-	IPPROTO_TCF			= 0x57;
-	IPPROTO_TCP			= 0x6;
-	IPPROTO_TLSP			= 0x38;
-	IPPROTO_TP			= 0x1d;
-	IPPROTO_TPXX			= 0x27;
-	IPPROTO_TRUNK1			= 0x17;
-	IPPROTO_TRUNK2			= 0x18;
-	IPPROTO_TTP			= 0x54;
-	IPPROTO_UDP			= 0x11;
-	IPPROTO_VINES			= 0x53;
-	IPPROTO_VISA			= 0x46;
-	IPPROTO_VMTP			= 0x51;
-	IPPROTO_WBEXPAK			= 0x4f;
-	IPPROTO_WBMON			= 0x4e;
-	IPPROTO_WSN			= 0x4a;
-	IPPROTO_XNET			= 0xf;
-	IPPROTO_XTP			= 0x24;
-	IP_ADD_MEMBERSHIP		= 0xc;
-	IP_ADD_SOURCE_MEMBERSHIP	= 0x46;
-	IP_BINDANY			= 0x18;
-	IP_BLOCK_SOURCE			= 0x48;
-	IP_DEFAULT_MULTICAST_LOOP	= 0x1;
-	IP_DEFAULT_MULTICAST_TTL	= 0x1;
-	IP_DONTFRAG			= 0x43;
-	IP_DROP_MEMBERSHIP		= 0xd;
-	IP_DROP_SOURCE_MEMBERSHIP	= 0x47;
-	IP_DUMMYNET_CONFIGURE		= 0x3c;
-	IP_DUMMYNET_DEL			= 0x3d;
-	IP_DUMMYNET_FLUSH		= 0x3e;
-	IP_DUMMYNET_GET			= 0x40;
-	IP_FAITH			= 0x16;
-	IP_FW_ADD			= 0x32;
-	IP_FW_DEL			= 0x33;
-	IP_FW_FLUSH			= 0x34;
-	IP_FW_GET			= 0x36;
-	IP_FW_NAT_CFG			= 0x38;
-	IP_FW_NAT_DEL			= 0x39;
-	IP_FW_NAT_GET_CONFIG		= 0x3a;
-	IP_FW_NAT_GET_LOG		= 0x3b;
-	IP_FW_RESETLOG			= 0x37;
-	IP_FW_TABLE_ADD			= 0x28;
-	IP_FW_TABLE_DEL			= 0x29;
-	IP_FW_TABLE_FLUSH		= 0x2a;
-	IP_FW_TABLE_GETSIZE		= 0x2b;
-	IP_FW_TABLE_LIST		= 0x2c;
-	IP_FW_ZERO			= 0x35;
-	IP_HDRINCL			= 0x2;
-	IP_IPSEC_POLICY			= 0x15;
-	IP_MAX_GROUP_SRC_FILTER		= 0x200;
-	IP_MAX_MEMBERSHIPS		= 0xfff;
-	IP_MAX_SOCK_MUTE_FILTER		= 0x80;
-	IP_MAX_SOCK_SRC_FILTER		= 0x80;
-	IP_MAX_SOURCE_FILTER		= 0x400;
-	IP_MINTTL			= 0x42;
-	IP_MIN_MEMBERSHIPS		= 0x1f;
-	IP_MSFILTER			= 0x4a;
-	IP_MULTICAST_IF			= 0x9;
-	IP_MULTICAST_LOOP		= 0xb;
-	IP_MULTICAST_TTL		= 0xa;
-	IP_MULTICAST_VIF		= 0xe;
-	IP_ONESBCAST			= 0x17;
-	IP_OPTIONS			= 0x1;
-	IP_PORTRANGE			= 0x13;
-	IP_PORTRANGE_DEFAULT		= 0;
-	IP_PORTRANGE_HIGH		= 0x1;
-	IP_PORTRANGE_LOW		= 0x2;
-	IP_RECVDSTADDR			= 0x7;
-	IP_RECVIF			= 0x14;
-	IP_RECVOPTS			= 0x5;
-	IP_RECVRETOPTS			= 0x6;
-	IP_RECVTTL			= 0x41;
-	IP_RETOPTS			= 0x8;
-	IP_RSVP_OFF			= 0x10;
-	IP_RSVP_ON			= 0xf;
-	IP_RSVP_VIF_OFF			= 0x12;
-	IP_RSVP_VIF_ON			= 0x11;
-	IP_SENDSRCADDR			= 0x7;
-	IP_TOS				= 0x3;
-	IP_TTL				= 0x4;
-	IP_UNBLOCK_SOURCE		= 0x49;
-	O_ACCMODE			= 0x3;
-	O_APPEND			= 0x8;
-	O_ASYNC				= 0x40;
-	O_CREAT				= 0x200;
-	O_DIRECT			= 0x10000;
-	O_DIRECTORY			= 0x20000;
-	O_EXCL				= 0x800;
-	O_EXEC				= 0x40000;
-	O_EXLOCK			= 0x20;
-	O_FSYNC				= 0x80;
-	O_NDELAY			= 0x4;
-	O_NOCTTY			= 0x8000;
-	O_NOFOLLOW			= 0x100;
-	O_NONBLOCK			= 0x4;
-	O_RDONLY			= 0;
-	O_RDWR				= 0x2;
-	O_SHLOCK			= 0x10;
-	O_SYNC				= 0x80;
-	O_TRUNC				= 0x400;
-	O_TTY_INIT			= 0x80000;
-	O_WRONLY			= 0x1;
-	SHUT_RD				= 0;
-	SHUT_RDWR			= 0x2;
-	SHUT_WR				= 0x1;
-	SIGABRT				= 0x6;
-	SIGALRM				= 0xe;
-	SIGBUS				= 0xa;
-	SIGCHLD				= 0x14;
-	SIGCONT				= 0x13;
-	SIGEMT				= 0x7;
-	SIGFPE				= 0x8;
-	SIGHUP				= 0x1;
-	SIGILL				= 0x4;
-	SIGINFO				= 0x1d;
-	SIGINT				= 0x2;
-	SIGIO				= 0x17;
-	SIGIOT				= 0x6;
-	SIGKILL				= 0x9;
-	SIGLWP				= 0x20;
-	SIGPIPE				= 0xd;
-	SIGPROF				= 0x1b;
-	SIGQUIT				= 0x3;
-	SIGSEGV				= 0xb;
-	SIGSTOP				= 0x11;
-	SIGSYS				= 0xc;
-	SIGTERM				= 0xf;
-	SIGTHR				= 0x20;
-	SIGTRAP				= 0x5;
-	SIGTSTP				= 0x12;
-	SIGTTIN				= 0x15;
-	SIGTTOU				= 0x16;
-	SIGURG				= 0x10;
-	SIGUSR1				= 0x1e;
-	SIGUSR2				= 0x1f;
-	SIGVTALRM			= 0x1a;
-	SIGWINCH			= 0x1c;
-	SIGXCPU				= 0x18;
-	SIGXFSZ				= 0x19;
-	SOCK_DGRAM			= 0x2;
-	SOCK_MAXADDRLEN			= 0xff;
-	SOCK_RAW			= 0x3;
-	SOCK_RDM			= 0x4;
-	SOCK_SEQPACKET			= 0x5;
-	SOCK_STREAM			= 0x1;
-	SOL_SOCKET			= 0xffff;
-	SOMAXCONN			= 0x80;
-	SO_ACCEPTCONN			= 0x2;
-	SO_ACCEPTFILTER			= 0x1000;
-	SO_BINTIME			= 0x2000;
-	SO_BROADCAST			= 0x20;
-	SO_DEBUG			= 0x1;
-	SO_DONTROUTE			= 0x10;
-	SO_ERROR			= 0x1007;
-	SO_KEEPALIVE			= 0x8;
-	SO_LABEL			= 0x1009;
-	SO_LINGER			= 0x80;
-	SO_LISTENINCQLEN		= 0x1013;
-	SO_LISTENQLEN			= 0x1012;
-	SO_LISTENQLIMIT			= 0x1011;
-	SO_NOSIGPIPE			= 0x800;
-	SO_NO_DDP			= 0x8000;
-	SO_NO_OFFLOAD			= 0x4000;
-	SO_OOBINLINE			= 0x100;
-	SO_PEERLABEL			= 0x1010;
-	SO_RCVBUF			= 0x1002;
-	SO_RCVLOWAT			= 0x1004;
-	SO_RCVTIMEO			= 0x1006;
-	SO_REUSEADDR			= 0x4;
-	SO_REUSEPORT			= 0x200;
-	SO_SETFIB			= 0x1014;
-	SO_SNDBUF			= 0x1001;
-	SO_SNDLOWAT			= 0x1003;
-	SO_SNDTIMEO			= 0x1005;
-	SO_TIMESTAMP			= 0x400;
-	SO_TYPE				= 0x1008;
-	SO_USELOOPBACK			= 0x40;
-	TCP_CA_NAME_MAX			= 0x10;
-	TCP_CONGESTION			= 0x40;
-	TCP_INFO			= 0x20;
-	TCP_MAXBURST			= 0x4;
-	TCP_MAXHLEN			= 0x3c;
-	TCP_MAXOLEN			= 0x28;
-	TCP_MAXSEG			= 0x2;
-	TCP_MAXWIN			= 0xffff;
-	TCP_MAX_SACK			= 0x4;
-	TCP_MAX_WINSHIFT		= 0xe;
-	TCP_MD5SIG			= 0x10;
-	TCP_MINMSS			= 0xd8;
-	TCP_MSS				= 0x200;
-	TCP_NODELAY			= 0x1;
-	TCP_NOOPT			= 0x8;
-	TCP_NOPUSH			= 0x4;
-	WCONTINUED			= 0x4;
-	WCOREFLAG			= 0x80;
-	WLINUXCLONE			= 0x80000000;
-	WNOHANG				= 0x1;
-	WNOWAIT				= 0x8;
-	WSTOPPED			= 0x2;
-	WUNTRACED			= 0x2;
+	AF_APPLETALK              = 0x10
+	AF_ARP                    = 0x23
+	AF_ATM                    = 0x1e
+	AF_BLUETOOTH              = 0x24
+	AF_CCITT                  = 0xa
+	AF_CHAOS                  = 0x5
+	AF_CNT                    = 0x15
+	AF_COIP                   = 0x14
+	AF_DATAKIT                = 0x9
+	AF_DECnet                 = 0xc
+	AF_DLI                    = 0xd
+	AF_E164                   = 0x1a
+	AF_ECMA                   = 0x8
+	AF_HYLINK                 = 0xf
+	AF_IEEE80211              = 0x25
+	AF_IMPLINK                = 0x3
+	AF_INET                   = 0x2
+	AF_INET6                  = 0x1c
+	AF_IPX                    = 0x17
+	AF_ISDN                   = 0x1a
+	AF_ISO                    = 0x7
+	AF_LAT                    = 0xe
+	AF_LINK                   = 0x12
+	AF_LOCAL                  = 0x1
+	AF_MAX                    = 0x26
+	AF_NATM                   = 0x1d
+	AF_NETBIOS                = 0x6
+	AF_NETGRAPH               = 0x20
+	AF_OSI                    = 0x7
+	AF_PUP                    = 0x4
+	AF_ROUTE                  = 0x11
+	AF_SCLUSTER               = 0x22
+	AF_SIP                    = 0x18
+	AF_SLOW                   = 0x21
+	AF_SNA                    = 0xb
+	AF_UNIX                   = 0x1
+	AF_UNSPEC                 = 0
+	AF_VENDOR00               = 0x27
+	AF_VENDOR01               = 0x29
+	AF_VENDOR02               = 0x2b
+	AF_VENDOR03               = 0x2d
+	AF_VENDOR04               = 0x2f
+	AF_VENDOR05               = 0x31
+	AF_VENDOR06               = 0x33
+	AF_VENDOR07               = 0x35
+	AF_VENDOR08               = 0x37
+	AF_VENDOR09               = 0x39
+	AF_VENDOR10               = 0x3b
+	AF_VENDOR11               = 0x3d
+	AF_VENDOR12               = 0x3f
+	AF_VENDOR13               = 0x41
+	AF_VENDOR14               = 0x43
+	AF_VENDOR15               = 0x45
+	AF_VENDOR16               = 0x47
+	AF_VENDOR17               = 0x49
+	AF_VENDOR18               = 0x4b
+	AF_VENDOR19               = 0x4d
+	AF_VENDOR20               = 0x4f
+	AF_VENDOR21               = 0x51
+	AF_VENDOR22               = 0x53
+	AF_VENDOR23               = 0x55
+	AF_VENDOR24               = 0x57
+	AF_VENDOR25               = 0x59
+	AF_VENDOR26               = 0x5b
+	AF_VENDOR27               = 0x5d
+	AF_VENDOR28               = 0x5f
+	AF_VENDOR29               = 0x61
+	AF_VENDOR30               = 0x63
+	AF_VENDOR31               = 0x65
+	AF_VENDOR32               = 0x67
+	AF_VENDOR33               = 0x69
+	AF_VENDOR34               = 0x6b
+	AF_VENDOR35               = 0x6d
+	AF_VENDOR36               = 0x6f
+	AF_VENDOR37               = 0x71
+	AF_VENDOR38               = 0x73
+	AF_VENDOR39               = 0x75
+	AF_VENDOR40               = 0x77
+	AF_VENDOR41               = 0x79
+	AF_VENDOR42               = 0x7b
+	AF_VENDOR43               = 0x7d
+	AF_VENDOR44               = 0x7f
+	AF_VENDOR45               = 0x81
+	AF_VENDOR46               = 0x83
+	AF_VENDOR47               = 0x85
+	E2BIG                     = 0x7
+	EACCES                    = 0xd
+	EADDRINUSE                = 0x30
+	EADDRNOTAVAIL             = 0x31
+	EAFNOSUPPORT              = 0x2f
+	EAGAIN                    = 0x23
+	EALREADY                  = 0x25
+	EAUTH                     = 0x50
+	EBADF                     = 0x9
+	EBADMSG                   = 0x59
+	EBADRPC                   = 0x48
+	EBUSY                     = 0x10
+	ECANCELED                 = 0x55
+	ECHILD                    = 0xa
+	ECONNABORTED              = 0x35
+	ECONNREFUSED              = 0x3d
+	ECONNRESET                = 0x36
+	EDEADLK                   = 0xb
+	EDESTADDRREQ              = 0x27
+	EDOM                      = 0x21
+	EDOOFUS                   = 0x58
+	EDQUOT                    = 0x45
+	EEXIST                    = 0x11
+	EFAULT                    = 0xe
+	EFBIG                     = 0x1b
+	EFTYPE                    = 0x4f
+	EHOSTDOWN                 = 0x40
+	EHOSTUNREACH              = 0x41
+	EIDRM                     = 0x52
+	EILSEQ                    = 0x56
+	EINPROGRESS               = 0x24
+	EINTR                     = 0x4
+	EINVAL                    = 0x16
+	EIO                       = 0x5
+	EISCONN                   = 0x38
+	EISDIR                    = 0x15
+	ELAST                     = 0x5c
+	ELOOP                     = 0x3e
+	EMFILE                    = 0x18
+	EMLINK                    = 0x1f
+	EMSGSIZE                  = 0x28
+	EMULTIHOP                 = 0x5a
+	ENAMETOOLONG              = 0x3f
+	ENEEDAUTH                 = 0x51
+	ENETDOWN                  = 0x32
+	ENETRESET                 = 0x34
+	ENETUNREACH               = 0x33
+	ENFILE                    = 0x17
+	ENOATTR                   = 0x57
+	ENOBUFS                   = 0x37
+	ENODEV                    = 0x13
+	ENOENT                    = 0x2
+	ENOEXEC                   = 0x8
+	ENOLCK                    = 0x4d
+	ENOLINK                   = 0x5b
+	ENOMEM                    = 0xc
+	ENOMSG                    = 0x53
+	ENOPROTOOPT               = 0x2a
+	ENOSPC                    = 0x1c
+	ENOSYS                    = 0x4e
+	ENOTBLK                   = 0xf
+	ENOTCONN                  = 0x39
+	ENOTDIR                   = 0x14
+	ENOTEMPTY                 = 0x42
+	ENOTSOCK                  = 0x26
+	ENOTSUP                   = 0x2d
+	ENOTTY                    = 0x19
+	ENXIO                     = 0x6
+	EOPNOTSUPP                = 0x2d
+	EOVERFLOW                 = 0x54
+	EPERM                     = 0x1
+	EPFNOSUPPORT              = 0x2e
+	EPIPE                     = 0x20
+	EPROCLIM                  = 0x43
+	EPROCUNAVAIL              = 0x4c
+	EPROGMISMATCH             = 0x4b
+	EPROGUNAVAIL              = 0x4a
+	EPROTO                    = 0x5c
+	EPROTONOSUPPORT           = 0x2b
+	EPROTOTYPE                = 0x29
+	ERANGE                    = 0x22
+	EREMOTE                   = 0x47
+	EROFS                     = 0x1e
+	ERPCMISMATCH              = 0x49
+	ESHUTDOWN                 = 0x3a
+	ESOCKTNOSUPPORT           = 0x2c
+	ESPIPE                    = 0x1d
+	ESRCH                     = 0x3
+	ESTALE                    = 0x46
+	ETIMEDOUT                 = 0x3c
+	ETOOMANYREFS              = 0x3b
+	ETXTBSY                   = 0x1a
+	EUSERS                    = 0x44
+	EVFILT_AIO                = -0x3
+	EVFILT_FS                 = -0x9
+	EVFILT_LIO                = -0xa
+	EVFILT_NETDEV             = -0x8
+	EVFILT_PROC               = -0x5
+	EVFILT_READ               = -0x1
+	EVFILT_SIGNAL             = -0x6
+	EVFILT_SYSCOUNT           = 0xa
+	EVFILT_TIMER              = -0x7
+	EVFILT_VNODE              = -0x4
+	EVFILT_WRITE              = -0x2
+	EV_ADD                    = 0x1
+	EV_CLEAR                  = 0x20
+	EV_DELETE                 = 0x2
+	EV_DISABLE                = 0x8
+	EV_ENABLE                 = 0x4
+	EV_EOF                    = 0x8000
+	EV_ERROR                  = 0x4000
+	EV_FLAG1                  = 0x2000
+	EV_ONESHOT                = 0x10
+	EV_SYSFLAGS               = 0xf000
+	EWOULDBLOCK               = 0x23
+	EXDEV                     = 0x12
+	FD_CLOEXEC                = 0x1
+	FD_SETSIZE                = 0x400
+	F_CANCEL                  = 0x5
+	F_DUP2FD                  = 0xa
+	F_DUPFD                   = 0
+	F_GETFD                   = 0x1
+	F_GETFL                   = 0x3
+	F_GETLK                   = 0xb
+	F_GETOWN                  = 0x5
+	F_OGETLK                  = 0x7
+	F_OSETLK                  = 0x8
+	F_OSETLKW                 = 0x9
+	F_RDLCK                   = 0x1
+	F_SETFD                   = 0x2
+	F_SETFL                   = 0x4
+	F_SETLK                   = 0xc
+	F_SETLKW                  = 0xd
+	F_SETLK_REMOTE            = 0xe
+	F_SETOWN                  = 0x6
+	F_UNLCK                   = 0x2
+	F_UNLCKSYS                = 0x4
+	F_WRLCK                   = 0x3
+	IPPROTO_3PC               = 0x22
+	IPPROTO_ADFS              = 0x44
+	IPPROTO_AH                = 0x33
+	IPPROTO_AHIP              = 0x3d
+	IPPROTO_APES              = 0x63
+	IPPROTO_ARGUS             = 0xd
+	IPPROTO_AX25              = 0x5d
+	IPPROTO_BHA               = 0x31
+	IPPROTO_BLT               = 0x1e
+	IPPROTO_BRSATMON          = 0x4c
+	IPPROTO_CARP              = 0x70
+	IPPROTO_CFTP              = 0x3e
+	IPPROTO_CHAOS             = 0x10
+	IPPROTO_CMTP              = 0x26
+	IPPROTO_CPHB              = 0x49
+	IPPROTO_CPNX              = 0x48
+	IPPROTO_DDP               = 0x25
+	IPPROTO_DGP               = 0x56
+	IPPROTO_DIVERT            = 0x102
+	IPPROTO_DONE              = 0x101
+	IPPROTO_DSTOPTS           = 0x3c
+	IPPROTO_EGP               = 0x8
+	IPPROTO_EMCON             = 0xe
+	IPPROTO_ENCAP             = 0x62
+	IPPROTO_EON               = 0x50
+	IPPROTO_ESP               = 0x32
+	IPPROTO_ETHERIP           = 0x61
+	IPPROTO_FRAGMENT          = 0x2c
+	IPPROTO_GGP               = 0x3
+	IPPROTO_GMTP              = 0x64
+	IPPROTO_GRE               = 0x2f
+	IPPROTO_HELLO             = 0x3f
+	IPPROTO_HMP               = 0x14
+	IPPROTO_HOPOPTS           = 0
+	IPPROTO_ICMP              = 0x1
+	IPPROTO_ICMPV6            = 0x3a
+	IPPROTO_IDP               = 0x16
+	IPPROTO_IDPR              = 0x23
+	IPPROTO_IDRP              = 0x2d
+	IPPROTO_IGMP              = 0x2
+	IPPROTO_IGP               = 0x55
+	IPPROTO_IGRP              = 0x58
+	IPPROTO_IL                = 0x28
+	IPPROTO_INLSP             = 0x34
+	IPPROTO_INP               = 0x20
+	IPPROTO_IP                = 0
+	IPPROTO_IPCOMP            = 0x6c
+	IPPROTO_IPCV              = 0x47
+	IPPROTO_IPEIP             = 0x5e
+	IPPROTO_IPIP              = 0x4
+	IPPROTO_IPPC              = 0x43
+	IPPROTO_IPV4              = 0x4
+	IPPROTO_IPV6              = 0x29
+	IPPROTO_IRTP              = 0x1c
+	IPPROTO_KRYPTOLAN         = 0x41
+	IPPROTO_LARP              = 0x5b
+	IPPROTO_LEAF1             = 0x19
+	IPPROTO_LEAF2             = 0x1a
+	IPPROTO_MAX               = 0x100
+	IPPROTO_MAXID             = 0x34
+	IPPROTO_MEAS              = 0x13
+	IPPROTO_MHRP              = 0x30
+	IPPROTO_MICP              = 0x5f
+	IPPROTO_MOBILE            = 0x37
+	IPPROTO_MTP               = 0x5c
+	IPPROTO_MUX               = 0x12
+	IPPROTO_ND                = 0x4d
+	IPPROTO_NHRP              = 0x36
+	IPPROTO_NONE              = 0x3b
+	IPPROTO_NSP               = 0x1f
+	IPPROTO_NVPII             = 0xb
+	IPPROTO_OLD_DIVERT        = 0xfe
+	IPPROTO_OSPFIGP           = 0x59
+	IPPROTO_PFSYNC            = 0xf0
+	IPPROTO_PGM               = 0x71
+	IPPROTO_PIGP              = 0x9
+	IPPROTO_PIM               = 0x67
+	IPPROTO_PRM               = 0x15
+	IPPROTO_PUP               = 0xc
+	IPPROTO_PVP               = 0x4b
+	IPPROTO_RAW               = 0xff
+	IPPROTO_RCCMON            = 0xa
+	IPPROTO_RDP               = 0x1b
+	IPPROTO_ROUTING           = 0x2b
+	IPPROTO_RSVP              = 0x2e
+	IPPROTO_RVD               = 0x42
+	IPPROTO_SATEXPAK          = 0x40
+	IPPROTO_SATMON            = 0x45
+	IPPROTO_SCCSP             = 0x60
+	IPPROTO_SCTP              = 0x84
+	IPPROTO_SDRP              = 0x2a
+	IPPROTO_SEP               = 0x21
+	IPPROTO_SKIP              = 0x39
+	IPPROTO_SPACER            = 0x7fff
+	IPPROTO_SRPC              = 0x5a
+	IPPROTO_ST                = 0x7
+	IPPROTO_SVMTP             = 0x52
+	IPPROTO_SWIPE             = 0x35
+	IPPROTO_TCF               = 0x57
+	IPPROTO_TCP               = 0x6
+	IPPROTO_TLSP              = 0x38
+	IPPROTO_TP                = 0x1d
+	IPPROTO_TPXX              = 0x27
+	IPPROTO_TRUNK1            = 0x17
+	IPPROTO_TRUNK2            = 0x18
+	IPPROTO_TTP               = 0x54
+	IPPROTO_UDP               = 0x11
+	IPPROTO_VINES             = 0x53
+	IPPROTO_VISA              = 0x46
+	IPPROTO_VMTP              = 0x51
+	IPPROTO_WBEXPAK           = 0x4f
+	IPPROTO_WBMON             = 0x4e
+	IPPROTO_WSN               = 0x4a
+	IPPROTO_XNET              = 0xf
+	IPPROTO_XTP               = 0x24
+	IP_ADD_MEMBERSHIP         = 0xc
+	IP_ADD_SOURCE_MEMBERSHIP  = 0x46
+	IP_BINDANY                = 0x18
+	IP_BLOCK_SOURCE           = 0x48
+	IP_DEFAULT_MULTICAST_LOOP = 0x1
+	IP_DEFAULT_MULTICAST_TTL  = 0x1
+	IP_DONTFRAG               = 0x43
+	IP_DROP_MEMBERSHIP        = 0xd
+	IP_DROP_SOURCE_MEMBERSHIP = 0x47
+	IP_DUMMYNET_CONFIGURE     = 0x3c
+	IP_DUMMYNET_DEL           = 0x3d
+	IP_DUMMYNET_FLUSH         = 0x3e
+	IP_DUMMYNET_GET           = 0x40
+	IP_FAITH                  = 0x16
+	IP_FW_ADD                 = 0x32
+	IP_FW_DEL                 = 0x33
+	IP_FW_FLUSH               = 0x34
+	IP_FW_GET                 = 0x36
+	IP_FW_NAT_CFG             = 0x38
+	IP_FW_NAT_DEL             = 0x39
+	IP_FW_NAT_GET_CONFIG      = 0x3a
+	IP_FW_NAT_GET_LOG         = 0x3b
+	IP_FW_RESETLOG            = 0x37
+	IP_FW_TABLE_ADD           = 0x28
+	IP_FW_TABLE_DEL           = 0x29
+	IP_FW_TABLE_FLUSH         = 0x2a
+	IP_FW_TABLE_GETSIZE       = 0x2b
+	IP_FW_TABLE_LIST          = 0x2c
+	IP_FW_ZERO                = 0x35
+	IP_HDRINCL                = 0x2
+	IP_IPSEC_POLICY           = 0x15
+	IP_MAX_GROUP_SRC_FILTER   = 0x200
+	IP_MAX_MEMBERSHIPS        = 0xfff
+	IP_MAX_SOCK_MUTE_FILTER   = 0x80
+	IP_MAX_SOCK_SRC_FILTER    = 0x80
+	IP_MAX_SOURCE_FILTER      = 0x400
+	IP_MINTTL                 = 0x42
+	IP_MIN_MEMBERSHIPS        = 0x1f
+	IP_MSFILTER               = 0x4a
+	IP_MULTICAST_IF           = 0x9
+	IP_MULTICAST_LOOP         = 0xb
+	IP_MULTICAST_TTL          = 0xa
+	IP_MULTICAST_VIF          = 0xe
+	IP_ONESBCAST              = 0x17
+	IP_OPTIONS                = 0x1
+	IP_PORTRANGE              = 0x13
+	IP_PORTRANGE_DEFAULT      = 0
+	IP_PORTRANGE_HIGH         = 0x1
+	IP_PORTRANGE_LOW          = 0x2
+	IP_RECVDSTADDR            = 0x7
+	IP_RECVIF                 = 0x14
+	IP_RECVOPTS               = 0x5
+	IP_RECVRETOPTS            = 0x6
+	IP_RECVTTL                = 0x41
+	IP_RETOPTS                = 0x8
+	IP_RSVP_OFF               = 0x10
+	IP_RSVP_ON                = 0xf
+	IP_RSVP_VIF_OFF           = 0x12
+	IP_RSVP_VIF_ON            = 0x11
+	IP_SENDSRCADDR            = 0x7
+	IP_TOS                    = 0x3
+	IP_TTL                    = 0x4
+	IP_UNBLOCK_SOURCE         = 0x49
+	O_ACCMODE                 = 0x3
+	O_APPEND                  = 0x8
+	O_ASYNC                   = 0x40
+	O_CREAT                   = 0x200
+	O_DIRECT                  = 0x10000
+	O_DIRECTORY               = 0x20000
+	O_EXCL                    = 0x800
+	O_EXEC                    = 0x40000
+	O_EXLOCK                  = 0x20
+	O_FSYNC                   = 0x80
+	O_NDELAY                  = 0x4
+	O_NOCTTY                  = 0x8000
+	O_NOFOLLOW                = 0x100
+	O_NONBLOCK                = 0x4
+	O_RDONLY                  = 0
+	O_RDWR                    = 0x2
+	O_SHLOCK                  = 0x10
+	O_SYNC                    = 0x80
+	O_TRUNC                   = 0x400
+	O_TTY_INIT                = 0x80000
+	O_WRONLY                  = 0x1
+	SHUT_RD                   = 0
+	SHUT_RDWR                 = 0x2
+	SHUT_WR                   = 0x1
+	SIGABRT                   = 0x6
+	SIGALRM                   = 0xe
+	SIGBUS                    = 0xa
+	SIGCHLD                   = 0x14
+	SIGCONT                   = 0x13
+	SIGEMT                    = 0x7
+	SIGFPE                    = 0x8
+	SIGHUP                    = 0x1
+	SIGILL                    = 0x4
+	SIGINFO                   = 0x1d
+	SIGINT                    = 0x2
+	SIGIO                     = 0x17
+	SIGIOT                    = 0x6
+	SIGKILL                   = 0x9
+	SIGLWP                    = 0x20
+	SIGPIPE                   = 0xd
+	SIGPROF                   = 0x1b
+	SIGQUIT                   = 0x3
+	SIGSEGV                   = 0xb
+	SIGSTOP                   = 0x11
+	SIGSYS                    = 0xc
+	SIGTERM                   = 0xf
+	SIGTHR                    = 0x20
+	SIGTRAP                   = 0x5
+	SIGTSTP                   = 0x12
+	SIGTTIN                   = 0x15
+	SIGTTOU                   = 0x16
+	SIGURG                    = 0x10
+	SIGUSR1                   = 0x1e
+	SIGUSR2                   = 0x1f
+	SIGVTALRM                 = 0x1a
+	SIGWINCH                  = 0x1c
+	SIGXCPU                   = 0x18
+	SIGXFSZ                   = 0x19
+	SOCK_DGRAM                = 0x2
+	SOCK_MAXADDRLEN           = 0xff
+	SOCK_RAW                  = 0x3
+	SOCK_RDM                  = 0x4
+	SOCK_SEQPACKET            = 0x5
+	SOCK_STREAM               = 0x1
+	SOL_SOCKET                = 0xffff
+	SOMAXCONN                 = 0x80
+	SO_ACCEPTCONN             = 0x2
+	SO_ACCEPTFILTER           = 0x1000
+	SO_BINTIME                = 0x2000
+	SO_BROADCAST              = 0x20
+	SO_DEBUG                  = 0x1
+	SO_DONTROUTE              = 0x10
+	SO_ERROR                  = 0x1007
+	SO_KEEPALIVE              = 0x8
+	SO_LABEL                  = 0x1009
+	SO_LINGER                 = 0x80
+	SO_LISTENINCQLEN          = 0x1013
+	SO_LISTENQLEN             = 0x1012
+	SO_LISTENQLIMIT           = 0x1011
+	SO_NOSIGPIPE              = 0x800
+	SO_NO_DDP                 = 0x8000
+	SO_NO_OFFLOAD             = 0x4000
+	SO_OOBINLINE              = 0x100
+	SO_PEERLABEL              = 0x1010
+	SO_RCVBUF                 = 0x1002
+	SO_RCVLOWAT               = 0x1004
+	SO_RCVTIMEO               = 0x1006
+	SO_REUSEADDR              = 0x4
+	SO_REUSEPORT              = 0x200
+	SO_SETFIB                 = 0x1014
+	SO_SNDBUF                 = 0x1001
+	SO_SNDLOWAT               = 0x1003
+	SO_SNDTIMEO               = 0x1005
+	SO_TIMESTAMP              = 0x400
+	SO_TYPE                   = 0x1008
+	SO_USELOOPBACK            = 0x40
+	TCP_CA_NAME_MAX           = 0x10
+	TCP_CONGESTION            = 0x40
+	TCP_INFO                  = 0x20
+	TCP_MAXBURST              = 0x4
+	TCP_MAXHLEN               = 0x3c
+	TCP_MAXOLEN               = 0x28
+	TCP_MAXSEG                = 0x2
+	TCP_MAXWIN                = 0xffff
+	TCP_MAX_SACK              = 0x4
+	TCP_MAX_WINSHIFT          = 0xe
+	TCP_MD5SIG                = 0x10
+	TCP_MINMSS                = 0xd8
+	TCP_MSS                   = 0x200
+	TCP_NODELAY               = 0x1
+	TCP_NOOPT                 = 0x8
+	TCP_NOPUSH                = 0x4
+	WCONTINUED                = 0x4
+	WCOREFLAG                 = 0x80
+	WLINUXCLONE               = 0x80000000
+	WNOHANG                   = 0x1
+	WNOWAIT                   = 0x8
+	WSTOPPED                  = 0x2
+	WUNTRACED                 = 0x2
 )
 
 // Types
diff --git a/src/pkg/syscall/zerrors_linux_386.go b/src/pkg/syscall/zerrors_linux_386.go
index bca74b3402..ba744a70c4 100644
--- a/src/pkg/syscall/zerrors_linux_386.go
+++ b/src/pkg/syscall/zerrors_linux_386.go
@@ -9,516 +9,516 @@ package syscall
 
 // Constants
 const (
-	AF_APPLETALK				= 0x5;
-	AF_ASH					= 0x12;
-	AF_ATMPVC				= 0x8;
-	AF_ATMSVC				= 0x14;
-	AF_AX25					= 0x3;
-	AF_BLUETOOTH				= 0x1f;
-	AF_BRIDGE				= 0x7;
-	AF_CAN					= 0x1d;
-	AF_DECnet				= 0xc;
-	AF_ECONET				= 0x13;
-	AF_FILE					= 0x1;
-	AF_IEEE802154				= 0x24;
-	AF_INET					= 0x2;
-	AF_INET6				= 0xa;
-	AF_IPX					= 0x4;
-	AF_IRDA					= 0x17;
-	AF_ISDN					= 0x22;
-	AF_IUCV					= 0x20;
-	AF_KEY					= 0xf;
-	AF_LLC					= 0x1a;
-	AF_LOCAL				= 0x1;
-	AF_MAX					= 0x25;
-	AF_NETBEUI				= 0xd;
-	AF_NETLINK				= 0x10;
-	AF_NETROM				= 0x6;
-	AF_PACKET				= 0x11;
-	AF_PHONET				= 0x23;
-	AF_PPPOX				= 0x18;
-	AF_RDS					= 0x15;
-	AF_ROSE					= 0xb;
-	AF_ROUTE				= 0x10;
-	AF_RXRPC				= 0x21;
-	AF_SECURITY				= 0xe;
-	AF_SNA					= 0x16;
-	AF_TIPC					= 0x1e;
-	AF_UNIX					= 0x1;
-	AF_UNSPEC				= 0;
-	AF_WANPIPE				= 0x19;
-	AF_X25					= 0x9;
-	E2BIG					= 0x7;
-	EACCES					= 0xd;
-	EADDRINUSE				= 0x62;
-	EADDRNOTAVAIL				= 0x63;
-	EADV					= 0x44;
-	EAFNOSUPPORT				= 0x61;
-	EAGAIN					= 0xb;
-	EALREADY				= 0x72;
-	EBADE					= 0x34;
-	EBADF					= 0x9;
-	EBADFD					= 0x4d;
-	EBADMSG					= 0x4a;
-	EBADR					= 0x35;
-	EBADRQC					= 0x38;
-	EBADSLT					= 0x39;
-	EBFONT					= 0x3b;
-	EBUSY					= 0x10;
-	ECANCELED				= 0x7d;
-	ECHILD					= 0xa;
-	ECHRNG					= 0x2c;
-	ECOMM					= 0x46;
-	ECONNABORTED				= 0x67;
-	ECONNREFUSED				= 0x6f;
-	ECONNRESET				= 0x68;
-	EDEADLK					= 0x23;
-	EDEADLOCK				= 0x23;
-	EDESTADDRREQ				= 0x59;
-	EDOM					= 0x21;
-	EDOTDOT					= 0x49;
-	EDQUOT					= 0x7a;
-	EEXIST					= 0x11;
-	EFAULT					= 0xe;
-	EFBIG					= 0x1b;
-	EHOSTDOWN				= 0x70;
-	EHOSTUNREACH				= 0x71;
-	EIDRM					= 0x2b;
-	EILSEQ					= 0x54;
-	EINPROGRESS				= 0x73;
-	EINTR					= 0x4;
-	EINVAL					= 0x16;
-	EIO					= 0x5;
-	EISCONN					= 0x6a;
-	EISDIR					= 0x15;
-	EISNAM					= 0x78;
-	EKEYEXPIRED				= 0x7f;
-	EKEYREJECTED				= 0x81;
-	EKEYREVOKED				= 0x80;
-	EL2HLT					= 0x33;
-	EL2NSYNC				= 0x2d;
-	EL3HLT					= 0x2e;
-	EL3RST					= 0x2f;
-	ELIBACC					= 0x4f;
-	ELIBBAD					= 0x50;
-	ELIBEXEC				= 0x53;
-	ELIBMAX					= 0x52;
-	ELIBSCN					= 0x51;
-	ELNRNG					= 0x30;
-	ELOOP					= 0x28;
-	EMEDIUMTYPE				= 0x7c;
-	EMFILE					= 0x18;
-	EMLINK					= 0x1f;
-	EMSGSIZE				= 0x5a;
-	EMULTIHOP				= 0x48;
-	ENAMETOOLONG				= 0x24;
-	ENAVAIL					= 0x77;
-	ENETDOWN				= 0x64;
-	ENETRESET				= 0x66;
-	ENETUNREACH				= 0x65;
-	ENFILE					= 0x17;
-	ENOANO					= 0x37;
-	ENOBUFS					= 0x69;
-	ENOCSI					= 0x32;
-	ENODATA					= 0x3d;
-	ENODEV					= 0x13;
-	ENOENT					= 0x2;
-	ENOEXEC					= 0x8;
-	ENOKEY					= 0x7e;
-	ENOLCK					= 0x25;
-	ENOLINK					= 0x43;
-	ENOMEDIUM				= 0x7b;
-	ENOMEM					= 0xc;
-	ENOMSG					= 0x2a;
-	ENONET					= 0x40;
-	ENOPKG					= 0x41;
-	ENOPROTOOPT				= 0x5c;
-	ENOSPC					= 0x1c;
-	ENOSR					= 0x3f;
-	ENOSTR					= 0x3c;
-	ENOSYS					= 0x26;
-	ENOTBLK					= 0xf;
-	ENOTCONN				= 0x6b;
-	ENOTDIR					= 0x14;
-	ENOTEMPTY				= 0x27;
-	ENOTNAM					= 0x76;
-	ENOTRECOVERABLE				= 0x83;
-	ENOTSOCK				= 0x58;
-	ENOTSUP					= 0x5f;
-	ENOTTY					= 0x19;
-	ENOTUNIQ				= 0x4c;
-	ENXIO					= 0x6;
-	EOPNOTSUPP				= 0x5f;
-	EOVERFLOW				= 0x4b;
-	EOWNERDEAD				= 0x82;
-	EPERM					= 0x1;
-	EPFNOSUPPORT				= 0x60;
-	EPIPE					= 0x20;
-	EPOLLERR				= 0x8;
-	EPOLLET					= -0x80000000;
-	EPOLLHUP				= 0x10;
-	EPOLLIN					= 0x1;
-	EPOLLMSG				= 0x400;
-	EPOLLONESHOT				= 0x40000000;
-	EPOLLOUT				= 0x4;
-	EPOLLPRI				= 0x2;
-	EPOLLRDBAND				= 0x80;
-	EPOLLRDHUP				= 0x2000;
-	EPOLLRDNORM				= 0x40;
-	EPOLLWRBAND				= 0x200;
-	EPOLLWRNORM				= 0x100;
-	EPOLL_CLOEXEC				= 0x80000;
-	EPOLL_CTL_ADD				= 0x1;
-	EPOLL_CTL_DEL				= 0x2;
-	EPOLL_CTL_MOD				= 0x3;
-	EPOLL_NONBLOCK				= 0x800;
-	EPROTO					= 0x47;
-	EPROTONOSUPPORT				= 0x5d;
-	EPROTOTYPE				= 0x5b;
-	ERANGE					= 0x22;
-	EREMCHG					= 0x4e;
-	EREMOTE					= 0x42;
-	EREMOTEIO				= 0x79;
-	ERESTART				= 0x55;
-	ERFKILL					= 0x84;
-	EROFS					= 0x1e;
-	ESHUTDOWN				= 0x6c;
-	ESOCKTNOSUPPORT				= 0x5e;
-	ESPIPE					= 0x1d;
-	ESRCH					= 0x3;
-	ESRMNT					= 0x45;
-	ESTALE					= 0x74;
-	ESTRPIPE				= 0x56;
-	ETIME					= 0x3e;
-	ETIMEDOUT				= 0x6e;
-	ETOOMANYREFS				= 0x6d;
-	ETXTBSY					= 0x1a;
-	EUCLEAN					= 0x75;
-	EUNATCH					= 0x31;
-	EUSERS					= 0x57;
-	EWOULDBLOCK				= 0xb;
-	EXDEV					= 0x12;
-	EXFULL					= 0x36;
-	FD_CLOEXEC				= 0x1;
-	FD_SETSIZE				= 0x400;
-	F_DUPFD					= 0;
-	F_DUPFD_CLOEXEC				= 0x406;
-	F_EXLCK					= 0x4;
-	F_GETFD					= 0x1;
-	F_GETFL					= 0x3;
-	F_GETLEASE				= 0x401;
-	F_GETLK					= 0x5;
-	F_GETLK64				= 0x5;
-	F_GETOWN				= 0x9;
-	F_GETSIG				= 0xb;
-	F_LOCK					= 0x1;
-	F_NOTIFY				= 0x402;
-	F_OK					= 0;
-	F_RDLCK					= 0;
-	F_SETFD					= 0x2;
-	F_SETFL					= 0x4;
-	F_SETLEASE				= 0x400;
-	F_SETLK					= 0x6;
-	F_SETLK64				= 0x6;
-	F_SETLKW				= 0x7;
-	F_SETLKW64				= 0x7;
-	F_SETOWN				= 0x8;
-	F_SETSIG				= 0xa;
-	F_SHLCK					= 0x8;
-	F_TEST					= 0x3;
-	F_TLOCK					= 0x2;
-	F_ULOCK					= 0;
-	F_UNLCK					= 0x2;
-	F_WRLCK					= 0x1;
-	IPPROTO_AH				= 0x33;
-	IPPROTO_COMP				= 0x6c;
-	IPPROTO_DCCP				= 0x21;
-	IPPROTO_DSTOPTS				= 0x3c;
-	IPPROTO_EGP				= 0x8;
-	IPPROTO_ENCAP				= 0x62;
-	IPPROTO_ESP				= 0x32;
-	IPPROTO_FRAGMENT			= 0x2c;
-	IPPROTO_GRE				= 0x2f;
-	IPPROTO_HOPOPTS				= 0;
-	IPPROTO_ICMP				= 0x1;
-	IPPROTO_ICMPV6				= 0x3a;
-	IPPROTO_IDP				= 0x16;
-	IPPROTO_IGMP				= 0x2;
-	IPPROTO_IP				= 0;
-	IPPROTO_IPIP				= 0x4;
-	IPPROTO_IPV6				= 0x29;
-	IPPROTO_MTP				= 0x5c;
-	IPPROTO_NONE				= 0x3b;
-	IPPROTO_PIM				= 0x67;
-	IPPROTO_PUP				= 0xc;
-	IPPROTO_RAW				= 0xff;
-	IPPROTO_ROUTING				= 0x2b;
-	IPPROTO_RSVP				= 0x2e;
-	IPPROTO_SCTP				= 0x84;
-	IPPROTO_TCP				= 0x6;
-	IPPROTO_TP				= 0x1d;
-	IPPROTO_UDP				= 0x11;
-	IPPROTO_UDPLITE				= 0x88;
-	IP_ADD_MEMBERSHIP			= 0x23;
-	IP_ADD_SOURCE_MEMBERSHIP		= 0x27;
-	IP_BLOCK_SOURCE				= 0x26;
-	IP_DEFAULT_MULTICAST_LOOP		= 0x1;
-	IP_DEFAULT_MULTICAST_TTL		= 0x1;
-	IP_DROP_MEMBERSHIP			= 0x24;
-	IP_DROP_SOURCE_MEMBERSHIP		= 0x28;
-	IP_HDRINCL				= 0x3;
-	IP_MAX_MEMBERSHIPS			= 0x14;
-	IP_MSFILTER				= 0x29;
-	IP_MTU_DISCOVER				= 0xa;
-	IP_MULTICAST_IF				= 0x20;
-	IP_MULTICAST_LOOP			= 0x22;
-	IP_MULTICAST_TTL			= 0x21;
-	IP_OPTIONS				= 0x4;
-	IP_PKTINFO				= 0x8;
-	IP_PKTOPTIONS				= 0x9;
-	IP_PMTUDISC				= 0xa;
-	IP_PMTUDISC_DO				= 0x2;
-	IP_PMTUDISC_DONT			= 0;
-	IP_PMTUDISC_PROBE			= 0x3;
-	IP_PMTUDISC_WANT			= 0x1;
-	IP_RECVERR				= 0xb;
-	IP_RECVOPTS				= 0x6;
-	IP_RECVRETOPTS				= 0x7;
-	IP_RECVTOS				= 0xd;
-	IP_RECVTTL				= 0xc;
-	IP_RETOPTS				= 0x7;
-	IP_ROUTER_ALERT				= 0x5;
-	IP_TOS					= 0x1;
-	IP_TTL					= 0x2;
-	IP_UNBLOCK_SOURCE			= 0x25;
-	NAME_MAX				= 0xff;
-	O_ACCMODE				= 0x3;
-	O_APPEND				= 0x400;
-	O_ASYNC					= 0x2000;
-	O_CLOEXEC				= 0x80000;
-	O_CREAT					= 0x40;
-	O_DIRECT				= 0x4000;
-	O_DIRECTORY				= 0x10000;
-	O_DSYNC					= 0x1000;
-	O_EXCL					= 0x80;
-	O_FSYNC					= 0x1000;
-	O_LARGEFILE				= 0;
-	O_NDELAY				= 0x800;
-	O_NOATIME				= 0x40000;
-	O_NOCTTY				= 0x100;
-	O_NOFOLLOW				= 0x20000;
-	O_NONBLOCK				= 0x800;
-	O_RDONLY				= 0;
-	O_RDWR					= 0x2;
-	O_RSYNC					= 0x1000;
-	O_SYNC					= 0x1000;
-	O_TRUNC					= 0x200;
-	O_WRONLY				= 0x1;
-	PTRACE_ARCH_PRCTL			= 0x1e;
-	PTRACE_ATTACH				= 0x10;
-	PTRACE_BTS_CLEAR			= 0x2c;
-	PTRACE_BTS_CONFIG			= 0x28;
-	PTRACE_BTS_DRAIN			= 0x2d;
-	PTRACE_BTS_GET				= 0x2b;
-	PTRACE_BTS_O_ALLOC			= 0x8;
-	PTRACE_BTS_O_SCHED			= 0x2;
-	PTRACE_BTS_O_SIGNAL			= 0x4;
-	PTRACE_BTS_O_TRACE			= 0x1;
-	PTRACE_BTS_SIZE				= 0x2a;
-	PTRACE_BTS_STATUS			= 0x29;
-	PTRACE_CONT				= 0x7;
-	PTRACE_DETACH				= 0x11;
-	PTRACE_EVENT_CLONE			= 0x3;
-	PTRACE_EVENT_EXEC			= 0x4;
-	PTRACE_EVENT_EXIT			= 0x6;
-	PTRACE_EVENT_FORK			= 0x1;
-	PTRACE_EVENT_VFORK			= 0x2;
-	PTRACE_EVENT_VFORK_DONE			= 0x5;
-	PTRACE_GETEVENTMSG			= 0x4201;
-	PTRACE_GETFPREGS			= 0xe;
-	PTRACE_GETFPXREGS			= 0x12;
-	PTRACE_GETREGS				= 0xc;
-	PTRACE_GETSIGINFO			= 0x4202;
-	PTRACE_GET_THREAD_AREA			= 0x19;
-	PTRACE_KILL				= 0x8;
-	PTRACE_OLDSETOPTIONS			= 0x15;
-	PTRACE_O_MASK				= 0x7f;
-	PTRACE_O_TRACECLONE			= 0x8;
-	PTRACE_O_TRACEEXEC			= 0x10;
-	PTRACE_O_TRACEEXIT			= 0x40;
-	PTRACE_O_TRACEFORK			= 0x2;
-	PTRACE_O_TRACESYSGOOD			= 0x1;
-	PTRACE_O_TRACEVFORK			= 0x4;
-	PTRACE_O_TRACEVFORKDONE			= 0x20;
-	PTRACE_PEEKDATA				= 0x2;
-	PTRACE_PEEKTEXT				= 0x1;
-	PTRACE_PEEKUSR				= 0x3;
-	PTRACE_POKEDATA				= 0x5;
-	PTRACE_POKETEXT				= 0x4;
-	PTRACE_POKEUSR				= 0x6;
-	PTRACE_SETFPREGS			= 0xf;
-	PTRACE_SETFPXREGS			= 0x13;
-	PTRACE_SETOPTIONS			= 0x4200;
-	PTRACE_SETREGS				= 0xd;
-	PTRACE_SETSIGINFO			= 0x4203;
-	PTRACE_SET_THREAD_AREA			= 0x1a;
-	PTRACE_SINGLEBLOCK			= 0x21;
-	PTRACE_SINGLESTEP			= 0x9;
-	PTRACE_SYSCALL				= 0x18;
-	PTRACE_SYSEMU				= 0x1f;
-	PTRACE_SYSEMU_SINGLESTEP		= 0x20;
-	PTRACE_TRACEME				= 0;
-	SHUT_RD					= 0;
-	SHUT_RDWR				= 0x2;
-	SHUT_WR					= 0x1;
-	SIGABRT					= 0x6;
-	SIGALRM					= 0xe;
-	SIGBUS					= 0x7;
-	SIGCHLD					= 0x11;
-	SIGCLD					= 0x11;
-	SIGCONT					= 0x12;
-	SIGFPE					= 0x8;
-	SIGHUP					= 0x1;
-	SIGILL					= 0x4;
-	SIGINT					= 0x2;
-	SIGIO					= 0x1d;
-	SIGIOT					= 0x6;
-	SIGKILL					= 0x9;
-	SIGPIPE					= 0xd;
-	SIGPOLL					= 0x1d;
-	SIGPROF					= 0x1b;
-	SIGPWR					= 0x1e;
-	SIGQUIT					= 0x3;
-	SIGSEGV					= 0xb;
-	SIGSTKFLT				= 0x10;
-	SIGSTOP					= 0x13;
-	SIGSYS					= 0x1f;
-	SIGTERM					= 0xf;
-	SIGTRAP					= 0x5;
-	SIGTSTP					= 0x14;
-	SIGTTIN					= 0x15;
-	SIGTTOU					= 0x16;
-	SIGUNUSED				= 0x1f;
-	SIGURG					= 0x17;
-	SIGUSR1					= 0xa;
-	SIGUSR2					= 0xc;
-	SIGVTALRM				= 0x1a;
-	SIGWINCH				= 0x1c;
-	SIGXCPU					= 0x18;
-	SIGXFSZ					= 0x19;
-	SOCK_CLOEXEC				= 0x80000;
-	SOCK_DCCP				= 0x6;
-	SOCK_DGRAM				= 0x2;
-	SOCK_NONBLOCK				= 0x800;
-	SOCK_PACKET				= 0xa;
-	SOCK_RAW				= 0x3;
-	SOCK_RDM				= 0x4;
-	SOCK_SEQPACKET				= 0x5;
-	SOCK_STREAM				= 0x1;
-	SOL_AAL					= 0x109;
-	SOL_ATM					= 0x108;
-	SOL_DECNET				= 0x105;
-	SOL_ICMPV6				= 0x3a;
-	SOL_IP					= 0;
-	SOL_IPV6				= 0x29;
-	SOL_IRDA				= 0x10a;
-	SOL_PACKET				= 0x107;
-	SOL_RAW					= 0xff;
-	SOL_SOCKET				= 0x1;
-	SOL_TCP					= 0x6;
-	SOL_X25					= 0x106;
-	SOMAXCONN				= 0x80;
-	SO_ACCEPTCONN				= 0x1e;
-	SO_ATTACH_FILTER			= 0x1a;
-	SO_BINDTODEVICE				= 0x19;
-	SO_BROADCAST				= 0x6;
-	SO_BSDCOMPAT				= 0xe;
-	SO_DEBUG				= 0x1;
-	SO_DETACH_FILTER			= 0x1b;
-	SO_DONTROUTE				= 0x5;
-	SO_ERROR				= 0x4;
-	SO_KEEPALIVE				= 0x9;
-	SO_LINGER				= 0xd;
-	SO_MARK					= 0x24;
-	SO_NO_CHECK				= 0xb;
-	SO_OOBINLINE				= 0xa;
-	SO_PASSCRED				= 0x10;
-	SO_PASSSEC				= 0x22;
-	SO_PEERCRED				= 0x11;
-	SO_PEERNAME				= 0x1c;
-	SO_PEERSEC				= 0x1f;
-	SO_PRIORITY				= 0xc;
-	SO_RCVBUF				= 0x8;
-	SO_RCVBUFFORCE				= 0x21;
-	SO_RCVLOWAT				= 0x12;
-	SO_RCVTIMEO				= 0x14;
-	SO_REUSEADDR				= 0x2;
-	SO_SECURITY_AUTHENTICATION		= 0x16;
-	SO_SECURITY_ENCRYPTION_NETWORK		= 0x18;
-	SO_SECURITY_ENCRYPTION_TRANSPORT	= 0x17;
-	SO_SNDBUF				= 0x7;
-	SO_SNDBUFFORCE				= 0x20;
-	SO_SNDLOWAT				= 0x13;
-	SO_SNDTIMEO				= 0x15;
-	SO_TIMESTAMP				= 0x1d;
-	SO_TIMESTAMPING				= 0x25;
-	SO_TIMESTAMPNS				= 0x23;
-	SO_TYPE					= 0x3;
-	S_BLKSIZE				= 0x200;
-	S_IEXEC					= 0x40;
-	S_IFBLK					= 0x6000;
-	S_IFCHR					= 0x2000;
-	S_IFDIR					= 0x4000;
-	S_IFIFO					= 0x1000;
-	S_IFLNK					= 0xa000;
-	S_IFMT					= 0xf000;
-	S_IFREG					= 0x8000;
-	S_IFSOCK				= 0xc000;
-	S_IREAD					= 0x100;
-	S_IRGRP					= 0x20;
-	S_IROTH					= 0x4;
-	S_IRUSR					= 0x100;
-	S_IRWXG					= 0x38;
-	S_IRWXO					= 0x7;
-	S_IRWXU					= 0x1c0;
-	S_ISGID					= 0x400;
-	S_ISUID					= 0x800;
-	S_ISVTX					= 0x200;
-	S_IWGRP					= 0x10;
-	S_IWOTH					= 0x2;
-	S_IWRITE				= 0x80;
-	S_IWUSR					= 0x80;
-	S_IXGRP					= 0x8;
-	S_IXOTH					= 0x1;
-	S_IXUSR					= 0x40;
-	TCP_CONGESTION				= 0xd;
-	TCP_CORK				= 0x3;
-	TCP_DEFER_ACCEPT			= 0x9;
-	TCP_INFO				= 0xb;
-	TCP_KEEPCNT				= 0x6;
-	TCP_KEEPIDLE				= 0x4;
-	TCP_KEEPINTVL				= 0x5;
-	TCP_LINGER2				= 0x8;
-	TCP_MAXSEG				= 0x2;
-	TCP_MAXWIN				= 0xffff;
-	TCP_MAX_WINSHIFT			= 0xe;
-	TCP_MD5SIG				= 0xe;
-	TCP_MD5SIG_MAXKEYLEN			= 0x50;
-	TCP_MSS					= 0x200;
-	TCP_NODELAY				= 0x1;
-	TCP_QUICKACK				= 0xc;
-	TCP_SYNCNT				= 0x7;
-	TCP_WINDOW_CLAMP			= 0xa;
-	WALL					= 0x40000000;
-	WCLONE					= 0x80000000;
-	WCONTINUED				= 0x8;
-	WEXITED					= 0x4;
-	WNOHANG					= 0x1;
-	WNOTHREAD				= 0x20000000;
-	WNOWAIT					= 0x1000000;
-	WORDSIZE				= 0x40;
-	WSTOPPED				= 0x2;
-	WUNTRACED				= 0x2;
+	AF_APPLETALK                     = 0x5
+	AF_ASH                           = 0x12
+	AF_ATMPVC                        = 0x8
+	AF_ATMSVC                        = 0x14
+	AF_AX25                          = 0x3
+	AF_BLUETOOTH                     = 0x1f
+	AF_BRIDGE                        = 0x7
+	AF_CAN                           = 0x1d
+	AF_DECnet                        = 0xc
+	AF_ECONET                        = 0x13
+	AF_FILE                          = 0x1
+	AF_IEEE802154                    = 0x24
+	AF_INET                          = 0x2
+	AF_INET6                         = 0xa
+	AF_IPX                           = 0x4
+	AF_IRDA                          = 0x17
+	AF_ISDN                          = 0x22
+	AF_IUCV                          = 0x20
+	AF_KEY                           = 0xf
+	AF_LLC                           = 0x1a
+	AF_LOCAL                         = 0x1
+	AF_MAX                           = 0x25
+	AF_NETBEUI                       = 0xd
+	AF_NETLINK                       = 0x10
+	AF_NETROM                        = 0x6
+	AF_PACKET                        = 0x11
+	AF_PHONET                        = 0x23
+	AF_PPPOX                         = 0x18
+	AF_RDS                           = 0x15
+	AF_ROSE                          = 0xb
+	AF_ROUTE                         = 0x10
+	AF_RXRPC                         = 0x21
+	AF_SECURITY                      = 0xe
+	AF_SNA                           = 0x16
+	AF_TIPC                          = 0x1e
+	AF_UNIX                          = 0x1
+	AF_UNSPEC                        = 0
+	AF_WANPIPE                       = 0x19
+	AF_X25                           = 0x9
+	E2BIG                            = 0x7
+	EACCES                           = 0xd
+	EADDRINUSE                       = 0x62
+	EADDRNOTAVAIL                    = 0x63
+	EADV                             = 0x44
+	EAFNOSUPPORT                     = 0x61
+	EAGAIN                           = 0xb
+	EALREADY                         = 0x72
+	EBADE                            = 0x34
+	EBADF                            = 0x9
+	EBADFD                           = 0x4d
+	EBADMSG                          = 0x4a
+	EBADR                            = 0x35
+	EBADRQC                          = 0x38
+	EBADSLT                          = 0x39
+	EBFONT                           = 0x3b
+	EBUSY                            = 0x10
+	ECANCELED                        = 0x7d
+	ECHILD                           = 0xa
+	ECHRNG                           = 0x2c
+	ECOMM                            = 0x46
+	ECONNABORTED                     = 0x67
+	ECONNREFUSED                     = 0x6f
+	ECONNRESET                       = 0x68
+	EDEADLK                          = 0x23
+	EDEADLOCK                        = 0x23
+	EDESTADDRREQ                     = 0x59
+	EDOM                             = 0x21
+	EDOTDOT                          = 0x49
+	EDQUOT                           = 0x7a
+	EEXIST                           = 0x11
+	EFAULT                           = 0xe
+	EFBIG                            = 0x1b
+	EHOSTDOWN                        = 0x70
+	EHOSTUNREACH                     = 0x71
+	EIDRM                            = 0x2b
+	EILSEQ                           = 0x54
+	EINPROGRESS                      = 0x73
+	EINTR                            = 0x4
+	EINVAL                           = 0x16
+	EIO                              = 0x5
+	EISCONN                          = 0x6a
+	EISDIR                           = 0x15
+	EISNAM                           = 0x78
+	EKEYEXPIRED                      = 0x7f
+	EKEYREJECTED                     = 0x81
+	EKEYREVOKED                      = 0x80
+	EL2HLT                           = 0x33
+	EL2NSYNC                         = 0x2d
+	EL3HLT                           = 0x2e
+	EL3RST                           = 0x2f
+	ELIBACC                          = 0x4f
+	ELIBBAD                          = 0x50
+	ELIBEXEC                         = 0x53
+	ELIBMAX                          = 0x52
+	ELIBSCN                          = 0x51
+	ELNRNG                           = 0x30
+	ELOOP                            = 0x28
+	EMEDIUMTYPE                      = 0x7c
+	EMFILE                           = 0x18
+	EMLINK                           = 0x1f
+	EMSGSIZE                         = 0x5a
+	EMULTIHOP                        = 0x48
+	ENAMETOOLONG                     = 0x24
+	ENAVAIL                          = 0x77
+	ENETDOWN                         = 0x64
+	ENETRESET                        = 0x66
+	ENETUNREACH                      = 0x65
+	ENFILE                           = 0x17
+	ENOANO                           = 0x37
+	ENOBUFS                          = 0x69
+	ENOCSI                           = 0x32
+	ENODATA                          = 0x3d
+	ENODEV                           = 0x13
+	ENOENT                           = 0x2
+	ENOEXEC                          = 0x8
+	ENOKEY                           = 0x7e
+	ENOLCK                           = 0x25
+	ENOLINK                          = 0x43
+	ENOMEDIUM                        = 0x7b
+	ENOMEM                           = 0xc
+	ENOMSG                           = 0x2a
+	ENONET                           = 0x40
+	ENOPKG                           = 0x41
+	ENOPROTOOPT                      = 0x5c
+	ENOSPC                           = 0x1c
+	ENOSR                            = 0x3f
+	ENOSTR                           = 0x3c
+	ENOSYS                           = 0x26
+	ENOTBLK                          = 0xf
+	ENOTCONN                         = 0x6b
+	ENOTDIR                          = 0x14
+	ENOTEMPTY                        = 0x27
+	ENOTNAM                          = 0x76
+	ENOTRECOVERABLE                  = 0x83
+	ENOTSOCK                         = 0x58
+	ENOTSUP                          = 0x5f
+	ENOTTY                           = 0x19
+	ENOTUNIQ                         = 0x4c
+	ENXIO                            = 0x6
+	EOPNOTSUPP                       = 0x5f
+	EOVERFLOW                        = 0x4b
+	EOWNERDEAD                       = 0x82
+	EPERM                            = 0x1
+	EPFNOSUPPORT                     = 0x60
+	EPIPE                            = 0x20
+	EPOLLERR                         = 0x8
+	EPOLLET                          = -0x80000000
+	EPOLLHUP                         = 0x10
+	EPOLLIN                          = 0x1
+	EPOLLMSG                         = 0x400
+	EPOLLONESHOT                     = 0x40000000
+	EPOLLOUT                         = 0x4
+	EPOLLPRI                         = 0x2
+	EPOLLRDBAND                      = 0x80
+	EPOLLRDHUP                       = 0x2000
+	EPOLLRDNORM                      = 0x40
+	EPOLLWRBAND                      = 0x200
+	EPOLLWRNORM                      = 0x100
+	EPOLL_CLOEXEC                    = 0x80000
+	EPOLL_CTL_ADD                    = 0x1
+	EPOLL_CTL_DEL                    = 0x2
+	EPOLL_CTL_MOD                    = 0x3
+	EPOLL_NONBLOCK                   = 0x800
+	EPROTO                           = 0x47
+	EPROTONOSUPPORT                  = 0x5d
+	EPROTOTYPE                       = 0x5b
+	ERANGE                           = 0x22
+	EREMCHG                          = 0x4e
+	EREMOTE                          = 0x42
+	EREMOTEIO                        = 0x79
+	ERESTART                         = 0x55
+	ERFKILL                          = 0x84
+	EROFS                            = 0x1e
+	ESHUTDOWN                        = 0x6c
+	ESOCKTNOSUPPORT                  = 0x5e
+	ESPIPE                           = 0x1d
+	ESRCH                            = 0x3
+	ESRMNT                           = 0x45
+	ESTALE                           = 0x74
+	ESTRPIPE                         = 0x56
+	ETIME                            = 0x3e
+	ETIMEDOUT                        = 0x6e
+	ETOOMANYREFS                     = 0x6d
+	ETXTBSY                          = 0x1a
+	EUCLEAN                          = 0x75
+	EUNATCH                          = 0x31
+	EUSERS                           = 0x57
+	EWOULDBLOCK                      = 0xb
+	EXDEV                            = 0x12
+	EXFULL                           = 0x36
+	FD_CLOEXEC                       = 0x1
+	FD_SETSIZE                       = 0x400
+	F_DUPFD                          = 0
+	F_DUPFD_CLOEXEC                  = 0x406
+	F_EXLCK                          = 0x4
+	F_GETFD                          = 0x1
+	F_GETFL                          = 0x3
+	F_GETLEASE                       = 0x401
+	F_GETLK                          = 0x5
+	F_GETLK64                        = 0x5
+	F_GETOWN                         = 0x9
+	F_GETSIG                         = 0xb
+	F_LOCK                           = 0x1
+	F_NOTIFY                         = 0x402
+	F_OK                             = 0
+	F_RDLCK                          = 0
+	F_SETFD                          = 0x2
+	F_SETFL                          = 0x4
+	F_SETLEASE                       = 0x400
+	F_SETLK                          = 0x6
+	F_SETLK64                        = 0x6
+	F_SETLKW                         = 0x7
+	F_SETLKW64                       = 0x7
+	F_SETOWN                         = 0x8
+	F_SETSIG                         = 0xa
+	F_SHLCK                          = 0x8
+	F_TEST                           = 0x3
+	F_TLOCK                          = 0x2
+	F_ULOCK                          = 0
+	F_UNLCK                          = 0x2
+	F_WRLCK                          = 0x1
+	IPPROTO_AH                       = 0x33
+	IPPROTO_COMP                     = 0x6c
+	IPPROTO_DCCP                     = 0x21
+	IPPROTO_DSTOPTS                  = 0x3c
+	IPPROTO_EGP                      = 0x8
+	IPPROTO_ENCAP                    = 0x62
+	IPPROTO_ESP                      = 0x32
+	IPPROTO_FRAGMENT                 = 0x2c
+	IPPROTO_GRE                      = 0x2f
+	IPPROTO_HOPOPTS                  = 0
+	IPPROTO_ICMP                     = 0x1
+	IPPROTO_ICMPV6                   = 0x3a
+	IPPROTO_IDP                      = 0x16
+	IPPROTO_IGMP                     = 0x2
+	IPPROTO_IP                       = 0
+	IPPROTO_IPIP                     = 0x4
+	IPPROTO_IPV6                     = 0x29
+	IPPROTO_MTP                      = 0x5c
+	IPPROTO_NONE                     = 0x3b
+	IPPROTO_PIM                      = 0x67
+	IPPROTO_PUP                      = 0xc
+	IPPROTO_RAW                      = 0xff
+	IPPROTO_ROUTING                  = 0x2b
+	IPPROTO_RSVP                     = 0x2e
+	IPPROTO_SCTP                     = 0x84
+	IPPROTO_TCP                      = 0x6
+	IPPROTO_TP                       = 0x1d
+	IPPROTO_UDP                      = 0x11
+	IPPROTO_UDPLITE                  = 0x88
+	IP_ADD_MEMBERSHIP                = 0x23
+	IP_ADD_SOURCE_MEMBERSHIP         = 0x27
+	IP_BLOCK_SOURCE                  = 0x26
+	IP_DEFAULT_MULTICAST_LOOP        = 0x1
+	IP_DEFAULT_MULTICAST_TTL         = 0x1
+	IP_DROP_MEMBERSHIP               = 0x24
+	IP_DROP_SOURCE_MEMBERSHIP        = 0x28
+	IP_HDRINCL                       = 0x3
+	IP_MAX_MEMBERSHIPS               = 0x14
+	IP_MSFILTER                      = 0x29
+	IP_MTU_DISCOVER                  = 0xa
+	IP_MULTICAST_IF                  = 0x20
+	IP_MULTICAST_LOOP                = 0x22
+	IP_MULTICAST_TTL                 = 0x21
+	IP_OPTIONS                       = 0x4
+	IP_PKTINFO                       = 0x8
+	IP_PKTOPTIONS                    = 0x9
+	IP_PMTUDISC                      = 0xa
+	IP_PMTUDISC_DO                   = 0x2
+	IP_PMTUDISC_DONT                 = 0
+	IP_PMTUDISC_PROBE                = 0x3
+	IP_PMTUDISC_WANT                 = 0x1
+	IP_RECVERR                       = 0xb
+	IP_RECVOPTS                      = 0x6
+	IP_RECVRETOPTS                   = 0x7
+	IP_RECVTOS                       = 0xd
+	IP_RECVTTL                       = 0xc
+	IP_RETOPTS                       = 0x7
+	IP_ROUTER_ALERT                  = 0x5
+	IP_TOS                           = 0x1
+	IP_TTL                           = 0x2
+	IP_UNBLOCK_SOURCE                = 0x25
+	NAME_MAX                         = 0xff
+	O_ACCMODE                        = 0x3
+	O_APPEND                         = 0x400
+	O_ASYNC                          = 0x2000
+	O_CLOEXEC                        = 0x80000
+	O_CREAT                          = 0x40
+	O_DIRECT                         = 0x4000
+	O_DIRECTORY                      = 0x10000
+	O_DSYNC                          = 0x1000
+	O_EXCL                           = 0x80
+	O_FSYNC                          = 0x1000
+	O_LARGEFILE                      = 0
+	O_NDELAY                         = 0x800
+	O_NOATIME                        = 0x40000
+	O_NOCTTY                         = 0x100
+	O_NOFOLLOW                       = 0x20000
+	O_NONBLOCK                       = 0x800
+	O_RDONLY                         = 0
+	O_RDWR                           = 0x2
+	O_RSYNC                          = 0x1000
+	O_SYNC                           = 0x1000
+	O_TRUNC                          = 0x200
+	O_WRONLY                         = 0x1
+	PTRACE_ARCH_PRCTL                = 0x1e
+	PTRACE_ATTACH                    = 0x10
+	PTRACE_BTS_CLEAR                 = 0x2c
+	PTRACE_BTS_CONFIG                = 0x28
+	PTRACE_BTS_DRAIN                 = 0x2d
+	PTRACE_BTS_GET                   = 0x2b
+	PTRACE_BTS_O_ALLOC               = 0x8
+	PTRACE_BTS_O_SCHED               = 0x2
+	PTRACE_BTS_O_SIGNAL              = 0x4
+	PTRACE_BTS_O_TRACE               = 0x1
+	PTRACE_BTS_SIZE                  = 0x2a
+	PTRACE_BTS_STATUS                = 0x29
+	PTRACE_CONT                      = 0x7
+	PTRACE_DETACH                    = 0x11
+	PTRACE_EVENT_CLONE               = 0x3
+	PTRACE_EVENT_EXEC                = 0x4
+	PTRACE_EVENT_EXIT                = 0x6
+	PTRACE_EVENT_FORK                = 0x1
+	PTRACE_EVENT_VFORK               = 0x2
+	PTRACE_EVENT_VFORK_DONE          = 0x5
+	PTRACE_GETEVENTMSG               = 0x4201
+	PTRACE_GETFPREGS                 = 0xe
+	PTRACE_GETFPXREGS                = 0x12
+	PTRACE_GETREGS                   = 0xc
+	PTRACE_GETSIGINFO                = 0x4202
+	PTRACE_GET_THREAD_AREA           = 0x19
+	PTRACE_KILL                      = 0x8
+	PTRACE_OLDSETOPTIONS             = 0x15
+	PTRACE_O_MASK                    = 0x7f
+	PTRACE_O_TRACECLONE              = 0x8
+	PTRACE_O_TRACEEXEC               = 0x10
+	PTRACE_O_TRACEEXIT               = 0x40
+	PTRACE_O_TRACEFORK               = 0x2
+	PTRACE_O_TRACESYSGOOD            = 0x1
+	PTRACE_O_TRACEVFORK              = 0x4
+	PTRACE_O_TRACEVFORKDONE          = 0x20
+	PTRACE_PEEKDATA                  = 0x2
+	PTRACE_PEEKTEXT                  = 0x1
+	PTRACE_PEEKUSR                   = 0x3
+	PTRACE_POKEDATA                  = 0x5
+	PTRACE_POKETEXT                  = 0x4
+	PTRACE_POKEUSR                   = 0x6
+	PTRACE_SETFPREGS                 = 0xf
+	PTRACE_SETFPXREGS                = 0x13
+	PTRACE_SETOPTIONS                = 0x4200
+	PTRACE_SETREGS                   = 0xd
+	PTRACE_SETSIGINFO                = 0x4203
+	PTRACE_SET_THREAD_AREA           = 0x1a
+	PTRACE_SINGLEBLOCK               = 0x21
+	PTRACE_SINGLESTEP                = 0x9
+	PTRACE_SYSCALL                   = 0x18
+	PTRACE_SYSEMU                    = 0x1f
+	PTRACE_SYSEMU_SINGLESTEP         = 0x20
+	PTRACE_TRACEME                   = 0
+	SHUT_RD                          = 0
+	SHUT_RDWR                        = 0x2
+	SHUT_WR                          = 0x1
+	SIGABRT                          = 0x6
+	SIGALRM                          = 0xe
+	SIGBUS                           = 0x7
+	SIGCHLD                          = 0x11
+	SIGCLD                           = 0x11
+	SIGCONT                          = 0x12
+	SIGFPE                           = 0x8
+	SIGHUP                           = 0x1
+	SIGILL                           = 0x4
+	SIGINT                           = 0x2
+	SIGIO                            = 0x1d
+	SIGIOT                           = 0x6
+	SIGKILL                          = 0x9
+	SIGPIPE                          = 0xd
+	SIGPOLL                          = 0x1d
+	SIGPROF                          = 0x1b
+	SIGPWR                           = 0x1e
+	SIGQUIT                          = 0x3
+	SIGSEGV                          = 0xb
+	SIGSTKFLT                        = 0x10
+	SIGSTOP                          = 0x13
+	SIGSYS                           = 0x1f
+	SIGTERM                          = 0xf
+	SIGTRAP                          = 0x5
+	SIGTSTP                          = 0x14
+	SIGTTIN                          = 0x15
+	SIGTTOU                          = 0x16
+	SIGUNUSED                        = 0x1f
+	SIGURG                           = 0x17
+	SIGUSR1                          = 0xa
+	SIGUSR2                          = 0xc
+	SIGVTALRM                        = 0x1a
+	SIGWINCH                         = 0x1c
+	SIGXCPU                          = 0x18
+	SIGXFSZ                          = 0x19
+	SOCK_CLOEXEC                     = 0x80000
+	SOCK_DCCP                        = 0x6
+	SOCK_DGRAM                       = 0x2
+	SOCK_NONBLOCK                    = 0x800
+	SOCK_PACKET                      = 0xa
+	SOCK_RAW                         = 0x3
+	SOCK_RDM                         = 0x4
+	SOCK_SEQPACKET                   = 0x5
+	SOCK_STREAM                      = 0x1
+	SOL_AAL                          = 0x109
+	SOL_ATM                          = 0x108
+	SOL_DECNET                       = 0x105
+	SOL_ICMPV6                       = 0x3a
+	SOL_IP                           = 0
+	SOL_IPV6                         = 0x29
+	SOL_IRDA                         = 0x10a
+	SOL_PACKET                       = 0x107
+	SOL_RAW                          = 0xff
+	SOL_SOCKET                       = 0x1
+	SOL_TCP                          = 0x6
+	SOL_X25                          = 0x106
+	SOMAXCONN                        = 0x80
+	SO_ACCEPTCONN                    = 0x1e
+	SO_ATTACH_FILTER                 = 0x1a
+	SO_BINDTODEVICE                  = 0x19
+	SO_BROADCAST                     = 0x6
+	SO_BSDCOMPAT                     = 0xe
+	SO_DEBUG                         = 0x1
+	SO_DETACH_FILTER                 = 0x1b
+	SO_DONTROUTE                     = 0x5
+	SO_ERROR                         = 0x4
+	SO_KEEPALIVE                     = 0x9
+	SO_LINGER                        = 0xd
+	SO_MARK                          = 0x24
+	SO_NO_CHECK                      = 0xb
+	SO_OOBINLINE                     = 0xa
+	SO_PASSCRED                      = 0x10
+	SO_PASSSEC                       = 0x22
+	SO_PEERCRED                      = 0x11
+	SO_PEERNAME                      = 0x1c
+	SO_PEERSEC                       = 0x1f
+	SO_PRIORITY                      = 0xc
+	SO_RCVBUF                        = 0x8
+	SO_RCVBUFFORCE                   = 0x21
+	SO_RCVLOWAT                      = 0x12
+	SO_RCVTIMEO                      = 0x14
+	SO_REUSEADDR                     = 0x2
+	SO_SECURITY_AUTHENTICATION       = 0x16
+	SO_SECURITY_ENCRYPTION_NETWORK   = 0x18
+	SO_SECURITY_ENCRYPTION_TRANSPORT = 0x17
+	SO_SNDBUF                        = 0x7
+	SO_SNDBUFFORCE                   = 0x20
+	SO_SNDLOWAT                      = 0x13
+	SO_SNDTIMEO                      = 0x15
+	SO_TIMESTAMP                     = 0x1d
+	SO_TIMESTAMPING                  = 0x25
+	SO_TIMESTAMPNS                   = 0x23
+	SO_TYPE                          = 0x3
+	S_BLKSIZE                        = 0x200
+	S_IEXEC                          = 0x40
+	S_IFBLK                          = 0x6000
+	S_IFCHR                          = 0x2000
+	S_IFDIR                          = 0x4000
+	S_IFIFO                          = 0x1000
+	S_IFLNK                          = 0xa000
+	S_IFMT                           = 0xf000
+	S_IFREG                          = 0x8000
+	S_IFSOCK                         = 0xc000
+	S_IREAD                          = 0x100
+	S_IRGRP                          = 0x20
+	S_IROTH                          = 0x4
+	S_IRUSR                          = 0x100
+	S_IRWXG                          = 0x38
+	S_IRWXO                          = 0x7
+	S_IRWXU                          = 0x1c0
+	S_ISGID                          = 0x400
+	S_ISUID                          = 0x800
+	S_ISVTX                          = 0x200
+	S_IWGRP                          = 0x10
+	S_IWOTH                          = 0x2
+	S_IWRITE                         = 0x80
+	S_IWUSR                          = 0x80
+	S_IXGRP                          = 0x8
+	S_IXOTH                          = 0x1
+	S_IXUSR                          = 0x40
+	TCP_CONGESTION                   = 0xd
+	TCP_CORK                         = 0x3
+	TCP_DEFER_ACCEPT                 = 0x9
+	TCP_INFO                         = 0xb
+	TCP_KEEPCNT                      = 0x6
+	TCP_KEEPIDLE                     = 0x4
+	TCP_KEEPINTVL                    = 0x5
+	TCP_LINGER2                      = 0x8
+	TCP_MAXSEG                       = 0x2
+	TCP_MAXWIN                       = 0xffff
+	TCP_MAX_WINSHIFT                 = 0xe
+	TCP_MD5SIG                       = 0xe
+	TCP_MD5SIG_MAXKEYLEN             = 0x50
+	TCP_MSS                          = 0x200
+	TCP_NODELAY                      = 0x1
+	TCP_QUICKACK                     = 0xc
+	TCP_SYNCNT                       = 0x7
+	TCP_WINDOW_CLAMP                 = 0xa
+	WALL                             = 0x40000000
+	WCLONE                           = 0x80000000
+	WCONTINUED                       = 0x8
+	WEXITED                          = 0x4
+	WNOHANG                          = 0x1
+	WNOTHREAD                        = 0x20000000
+	WNOWAIT                          = 0x1000000
+	WORDSIZE                         = 0x40
+	WSTOPPED                         = 0x2
+	WUNTRACED                        = 0x2
 )
 
 // Types
diff --git a/src/pkg/syscall/zerrors_linux_amd64.go b/src/pkg/syscall/zerrors_linux_amd64.go
index bca74b3402..ba744a70c4 100644
--- a/src/pkg/syscall/zerrors_linux_amd64.go
+++ b/src/pkg/syscall/zerrors_linux_amd64.go
@@ -9,516 +9,516 @@ package syscall
 
 // Constants
 const (
-	AF_APPLETALK				= 0x5;
-	AF_ASH					= 0x12;
-	AF_ATMPVC				= 0x8;
-	AF_ATMSVC				= 0x14;
-	AF_AX25					= 0x3;
-	AF_BLUETOOTH				= 0x1f;
-	AF_BRIDGE				= 0x7;
-	AF_CAN					= 0x1d;
-	AF_DECnet				= 0xc;
-	AF_ECONET				= 0x13;
-	AF_FILE					= 0x1;
-	AF_IEEE802154				= 0x24;
-	AF_INET					= 0x2;
-	AF_INET6				= 0xa;
-	AF_IPX					= 0x4;
-	AF_IRDA					= 0x17;
-	AF_ISDN					= 0x22;
-	AF_IUCV					= 0x20;
-	AF_KEY					= 0xf;
-	AF_LLC					= 0x1a;
-	AF_LOCAL				= 0x1;
-	AF_MAX					= 0x25;
-	AF_NETBEUI				= 0xd;
-	AF_NETLINK				= 0x10;
-	AF_NETROM				= 0x6;
-	AF_PACKET				= 0x11;
-	AF_PHONET				= 0x23;
-	AF_PPPOX				= 0x18;
-	AF_RDS					= 0x15;
-	AF_ROSE					= 0xb;
-	AF_ROUTE				= 0x10;
-	AF_RXRPC				= 0x21;
-	AF_SECURITY				= 0xe;
-	AF_SNA					= 0x16;
-	AF_TIPC					= 0x1e;
-	AF_UNIX					= 0x1;
-	AF_UNSPEC				= 0;
-	AF_WANPIPE				= 0x19;
-	AF_X25					= 0x9;
-	E2BIG					= 0x7;
-	EACCES					= 0xd;
-	EADDRINUSE				= 0x62;
-	EADDRNOTAVAIL				= 0x63;
-	EADV					= 0x44;
-	EAFNOSUPPORT				= 0x61;
-	EAGAIN					= 0xb;
-	EALREADY				= 0x72;
-	EBADE					= 0x34;
-	EBADF					= 0x9;
-	EBADFD					= 0x4d;
-	EBADMSG					= 0x4a;
-	EBADR					= 0x35;
-	EBADRQC					= 0x38;
-	EBADSLT					= 0x39;
-	EBFONT					= 0x3b;
-	EBUSY					= 0x10;
-	ECANCELED				= 0x7d;
-	ECHILD					= 0xa;
-	ECHRNG					= 0x2c;
-	ECOMM					= 0x46;
-	ECONNABORTED				= 0x67;
-	ECONNREFUSED				= 0x6f;
-	ECONNRESET				= 0x68;
-	EDEADLK					= 0x23;
-	EDEADLOCK				= 0x23;
-	EDESTADDRREQ				= 0x59;
-	EDOM					= 0x21;
-	EDOTDOT					= 0x49;
-	EDQUOT					= 0x7a;
-	EEXIST					= 0x11;
-	EFAULT					= 0xe;
-	EFBIG					= 0x1b;
-	EHOSTDOWN				= 0x70;
-	EHOSTUNREACH				= 0x71;
-	EIDRM					= 0x2b;
-	EILSEQ					= 0x54;
-	EINPROGRESS				= 0x73;
-	EINTR					= 0x4;
-	EINVAL					= 0x16;
-	EIO					= 0x5;
-	EISCONN					= 0x6a;
-	EISDIR					= 0x15;
-	EISNAM					= 0x78;
-	EKEYEXPIRED				= 0x7f;
-	EKEYREJECTED				= 0x81;
-	EKEYREVOKED				= 0x80;
-	EL2HLT					= 0x33;
-	EL2NSYNC				= 0x2d;
-	EL3HLT					= 0x2e;
-	EL3RST					= 0x2f;
-	ELIBACC					= 0x4f;
-	ELIBBAD					= 0x50;
-	ELIBEXEC				= 0x53;
-	ELIBMAX					= 0x52;
-	ELIBSCN					= 0x51;
-	ELNRNG					= 0x30;
-	ELOOP					= 0x28;
-	EMEDIUMTYPE				= 0x7c;
-	EMFILE					= 0x18;
-	EMLINK					= 0x1f;
-	EMSGSIZE				= 0x5a;
-	EMULTIHOP				= 0x48;
-	ENAMETOOLONG				= 0x24;
-	ENAVAIL					= 0x77;
-	ENETDOWN				= 0x64;
-	ENETRESET				= 0x66;
-	ENETUNREACH				= 0x65;
-	ENFILE					= 0x17;
-	ENOANO					= 0x37;
-	ENOBUFS					= 0x69;
-	ENOCSI					= 0x32;
-	ENODATA					= 0x3d;
-	ENODEV					= 0x13;
-	ENOENT					= 0x2;
-	ENOEXEC					= 0x8;
-	ENOKEY					= 0x7e;
-	ENOLCK					= 0x25;
-	ENOLINK					= 0x43;
-	ENOMEDIUM				= 0x7b;
-	ENOMEM					= 0xc;
-	ENOMSG					= 0x2a;
-	ENONET					= 0x40;
-	ENOPKG					= 0x41;
-	ENOPROTOOPT				= 0x5c;
-	ENOSPC					= 0x1c;
-	ENOSR					= 0x3f;
-	ENOSTR					= 0x3c;
-	ENOSYS					= 0x26;
-	ENOTBLK					= 0xf;
-	ENOTCONN				= 0x6b;
-	ENOTDIR					= 0x14;
-	ENOTEMPTY				= 0x27;
-	ENOTNAM					= 0x76;
-	ENOTRECOVERABLE				= 0x83;
-	ENOTSOCK				= 0x58;
-	ENOTSUP					= 0x5f;
-	ENOTTY					= 0x19;
-	ENOTUNIQ				= 0x4c;
-	ENXIO					= 0x6;
-	EOPNOTSUPP				= 0x5f;
-	EOVERFLOW				= 0x4b;
-	EOWNERDEAD				= 0x82;
-	EPERM					= 0x1;
-	EPFNOSUPPORT				= 0x60;
-	EPIPE					= 0x20;
-	EPOLLERR				= 0x8;
-	EPOLLET					= -0x80000000;
-	EPOLLHUP				= 0x10;
-	EPOLLIN					= 0x1;
-	EPOLLMSG				= 0x400;
-	EPOLLONESHOT				= 0x40000000;
-	EPOLLOUT				= 0x4;
-	EPOLLPRI				= 0x2;
-	EPOLLRDBAND				= 0x80;
-	EPOLLRDHUP				= 0x2000;
-	EPOLLRDNORM				= 0x40;
-	EPOLLWRBAND				= 0x200;
-	EPOLLWRNORM				= 0x100;
-	EPOLL_CLOEXEC				= 0x80000;
-	EPOLL_CTL_ADD				= 0x1;
-	EPOLL_CTL_DEL				= 0x2;
-	EPOLL_CTL_MOD				= 0x3;
-	EPOLL_NONBLOCK				= 0x800;
-	EPROTO					= 0x47;
-	EPROTONOSUPPORT				= 0x5d;
-	EPROTOTYPE				= 0x5b;
-	ERANGE					= 0x22;
-	EREMCHG					= 0x4e;
-	EREMOTE					= 0x42;
-	EREMOTEIO				= 0x79;
-	ERESTART				= 0x55;
-	ERFKILL					= 0x84;
-	EROFS					= 0x1e;
-	ESHUTDOWN				= 0x6c;
-	ESOCKTNOSUPPORT				= 0x5e;
-	ESPIPE					= 0x1d;
-	ESRCH					= 0x3;
-	ESRMNT					= 0x45;
-	ESTALE					= 0x74;
-	ESTRPIPE				= 0x56;
-	ETIME					= 0x3e;
-	ETIMEDOUT				= 0x6e;
-	ETOOMANYREFS				= 0x6d;
-	ETXTBSY					= 0x1a;
-	EUCLEAN					= 0x75;
-	EUNATCH					= 0x31;
-	EUSERS					= 0x57;
-	EWOULDBLOCK				= 0xb;
-	EXDEV					= 0x12;
-	EXFULL					= 0x36;
-	FD_CLOEXEC				= 0x1;
-	FD_SETSIZE				= 0x400;
-	F_DUPFD					= 0;
-	F_DUPFD_CLOEXEC				= 0x406;
-	F_EXLCK					= 0x4;
-	F_GETFD					= 0x1;
-	F_GETFL					= 0x3;
-	F_GETLEASE				= 0x401;
-	F_GETLK					= 0x5;
-	F_GETLK64				= 0x5;
-	F_GETOWN				= 0x9;
-	F_GETSIG				= 0xb;
-	F_LOCK					= 0x1;
-	F_NOTIFY				= 0x402;
-	F_OK					= 0;
-	F_RDLCK					= 0;
-	F_SETFD					= 0x2;
-	F_SETFL					= 0x4;
-	F_SETLEASE				= 0x400;
-	F_SETLK					= 0x6;
-	F_SETLK64				= 0x6;
-	F_SETLKW				= 0x7;
-	F_SETLKW64				= 0x7;
-	F_SETOWN				= 0x8;
-	F_SETSIG				= 0xa;
-	F_SHLCK					= 0x8;
-	F_TEST					= 0x3;
-	F_TLOCK					= 0x2;
-	F_ULOCK					= 0;
-	F_UNLCK					= 0x2;
-	F_WRLCK					= 0x1;
-	IPPROTO_AH				= 0x33;
-	IPPROTO_COMP				= 0x6c;
-	IPPROTO_DCCP				= 0x21;
-	IPPROTO_DSTOPTS				= 0x3c;
-	IPPROTO_EGP				= 0x8;
-	IPPROTO_ENCAP				= 0x62;
-	IPPROTO_ESP				= 0x32;
-	IPPROTO_FRAGMENT			= 0x2c;
-	IPPROTO_GRE				= 0x2f;
-	IPPROTO_HOPOPTS				= 0;
-	IPPROTO_ICMP				= 0x1;
-	IPPROTO_ICMPV6				= 0x3a;
-	IPPROTO_IDP				= 0x16;
-	IPPROTO_IGMP				= 0x2;
-	IPPROTO_IP				= 0;
-	IPPROTO_IPIP				= 0x4;
-	IPPROTO_IPV6				= 0x29;
-	IPPROTO_MTP				= 0x5c;
-	IPPROTO_NONE				= 0x3b;
-	IPPROTO_PIM				= 0x67;
-	IPPROTO_PUP				= 0xc;
-	IPPROTO_RAW				= 0xff;
-	IPPROTO_ROUTING				= 0x2b;
-	IPPROTO_RSVP				= 0x2e;
-	IPPROTO_SCTP				= 0x84;
-	IPPROTO_TCP				= 0x6;
-	IPPROTO_TP				= 0x1d;
-	IPPROTO_UDP				= 0x11;
-	IPPROTO_UDPLITE				= 0x88;
-	IP_ADD_MEMBERSHIP			= 0x23;
-	IP_ADD_SOURCE_MEMBERSHIP		= 0x27;
-	IP_BLOCK_SOURCE				= 0x26;
-	IP_DEFAULT_MULTICAST_LOOP		= 0x1;
-	IP_DEFAULT_MULTICAST_TTL		= 0x1;
-	IP_DROP_MEMBERSHIP			= 0x24;
-	IP_DROP_SOURCE_MEMBERSHIP		= 0x28;
-	IP_HDRINCL				= 0x3;
-	IP_MAX_MEMBERSHIPS			= 0x14;
-	IP_MSFILTER				= 0x29;
-	IP_MTU_DISCOVER				= 0xa;
-	IP_MULTICAST_IF				= 0x20;
-	IP_MULTICAST_LOOP			= 0x22;
-	IP_MULTICAST_TTL			= 0x21;
-	IP_OPTIONS				= 0x4;
-	IP_PKTINFO				= 0x8;
-	IP_PKTOPTIONS				= 0x9;
-	IP_PMTUDISC				= 0xa;
-	IP_PMTUDISC_DO				= 0x2;
-	IP_PMTUDISC_DONT			= 0;
-	IP_PMTUDISC_PROBE			= 0x3;
-	IP_PMTUDISC_WANT			= 0x1;
-	IP_RECVERR				= 0xb;
-	IP_RECVOPTS				= 0x6;
-	IP_RECVRETOPTS				= 0x7;
-	IP_RECVTOS				= 0xd;
-	IP_RECVTTL				= 0xc;
-	IP_RETOPTS				= 0x7;
-	IP_ROUTER_ALERT				= 0x5;
-	IP_TOS					= 0x1;
-	IP_TTL					= 0x2;
-	IP_UNBLOCK_SOURCE			= 0x25;
-	NAME_MAX				= 0xff;
-	O_ACCMODE				= 0x3;
-	O_APPEND				= 0x400;
-	O_ASYNC					= 0x2000;
-	O_CLOEXEC				= 0x80000;
-	O_CREAT					= 0x40;
-	O_DIRECT				= 0x4000;
-	O_DIRECTORY				= 0x10000;
-	O_DSYNC					= 0x1000;
-	O_EXCL					= 0x80;
-	O_FSYNC					= 0x1000;
-	O_LARGEFILE				= 0;
-	O_NDELAY				= 0x800;
-	O_NOATIME				= 0x40000;
-	O_NOCTTY				= 0x100;
-	O_NOFOLLOW				= 0x20000;
-	O_NONBLOCK				= 0x800;
-	O_RDONLY				= 0;
-	O_RDWR					= 0x2;
-	O_RSYNC					= 0x1000;
-	O_SYNC					= 0x1000;
-	O_TRUNC					= 0x200;
-	O_WRONLY				= 0x1;
-	PTRACE_ARCH_PRCTL			= 0x1e;
-	PTRACE_ATTACH				= 0x10;
-	PTRACE_BTS_CLEAR			= 0x2c;
-	PTRACE_BTS_CONFIG			= 0x28;
-	PTRACE_BTS_DRAIN			= 0x2d;
-	PTRACE_BTS_GET				= 0x2b;
-	PTRACE_BTS_O_ALLOC			= 0x8;
-	PTRACE_BTS_O_SCHED			= 0x2;
-	PTRACE_BTS_O_SIGNAL			= 0x4;
-	PTRACE_BTS_O_TRACE			= 0x1;
-	PTRACE_BTS_SIZE				= 0x2a;
-	PTRACE_BTS_STATUS			= 0x29;
-	PTRACE_CONT				= 0x7;
-	PTRACE_DETACH				= 0x11;
-	PTRACE_EVENT_CLONE			= 0x3;
-	PTRACE_EVENT_EXEC			= 0x4;
-	PTRACE_EVENT_EXIT			= 0x6;
-	PTRACE_EVENT_FORK			= 0x1;
-	PTRACE_EVENT_VFORK			= 0x2;
-	PTRACE_EVENT_VFORK_DONE			= 0x5;
-	PTRACE_GETEVENTMSG			= 0x4201;
-	PTRACE_GETFPREGS			= 0xe;
-	PTRACE_GETFPXREGS			= 0x12;
-	PTRACE_GETREGS				= 0xc;
-	PTRACE_GETSIGINFO			= 0x4202;
-	PTRACE_GET_THREAD_AREA			= 0x19;
-	PTRACE_KILL				= 0x8;
-	PTRACE_OLDSETOPTIONS			= 0x15;
-	PTRACE_O_MASK				= 0x7f;
-	PTRACE_O_TRACECLONE			= 0x8;
-	PTRACE_O_TRACEEXEC			= 0x10;
-	PTRACE_O_TRACEEXIT			= 0x40;
-	PTRACE_O_TRACEFORK			= 0x2;
-	PTRACE_O_TRACESYSGOOD			= 0x1;
-	PTRACE_O_TRACEVFORK			= 0x4;
-	PTRACE_O_TRACEVFORKDONE			= 0x20;
-	PTRACE_PEEKDATA				= 0x2;
-	PTRACE_PEEKTEXT				= 0x1;
-	PTRACE_PEEKUSR				= 0x3;
-	PTRACE_POKEDATA				= 0x5;
-	PTRACE_POKETEXT				= 0x4;
-	PTRACE_POKEUSR				= 0x6;
-	PTRACE_SETFPREGS			= 0xf;
-	PTRACE_SETFPXREGS			= 0x13;
-	PTRACE_SETOPTIONS			= 0x4200;
-	PTRACE_SETREGS				= 0xd;
-	PTRACE_SETSIGINFO			= 0x4203;
-	PTRACE_SET_THREAD_AREA			= 0x1a;
-	PTRACE_SINGLEBLOCK			= 0x21;
-	PTRACE_SINGLESTEP			= 0x9;
-	PTRACE_SYSCALL				= 0x18;
-	PTRACE_SYSEMU				= 0x1f;
-	PTRACE_SYSEMU_SINGLESTEP		= 0x20;
-	PTRACE_TRACEME				= 0;
-	SHUT_RD					= 0;
-	SHUT_RDWR				= 0x2;
-	SHUT_WR					= 0x1;
-	SIGABRT					= 0x6;
-	SIGALRM					= 0xe;
-	SIGBUS					= 0x7;
-	SIGCHLD					= 0x11;
-	SIGCLD					= 0x11;
-	SIGCONT					= 0x12;
-	SIGFPE					= 0x8;
-	SIGHUP					= 0x1;
-	SIGILL					= 0x4;
-	SIGINT					= 0x2;
-	SIGIO					= 0x1d;
-	SIGIOT					= 0x6;
-	SIGKILL					= 0x9;
-	SIGPIPE					= 0xd;
-	SIGPOLL					= 0x1d;
-	SIGPROF					= 0x1b;
-	SIGPWR					= 0x1e;
-	SIGQUIT					= 0x3;
-	SIGSEGV					= 0xb;
-	SIGSTKFLT				= 0x10;
-	SIGSTOP					= 0x13;
-	SIGSYS					= 0x1f;
-	SIGTERM					= 0xf;
-	SIGTRAP					= 0x5;
-	SIGTSTP					= 0x14;
-	SIGTTIN					= 0x15;
-	SIGTTOU					= 0x16;
-	SIGUNUSED				= 0x1f;
-	SIGURG					= 0x17;
-	SIGUSR1					= 0xa;
-	SIGUSR2					= 0xc;
-	SIGVTALRM				= 0x1a;
-	SIGWINCH				= 0x1c;
-	SIGXCPU					= 0x18;
-	SIGXFSZ					= 0x19;
-	SOCK_CLOEXEC				= 0x80000;
-	SOCK_DCCP				= 0x6;
-	SOCK_DGRAM				= 0x2;
-	SOCK_NONBLOCK				= 0x800;
-	SOCK_PACKET				= 0xa;
-	SOCK_RAW				= 0x3;
-	SOCK_RDM				= 0x4;
-	SOCK_SEQPACKET				= 0x5;
-	SOCK_STREAM				= 0x1;
-	SOL_AAL					= 0x109;
-	SOL_ATM					= 0x108;
-	SOL_DECNET				= 0x105;
-	SOL_ICMPV6				= 0x3a;
-	SOL_IP					= 0;
-	SOL_IPV6				= 0x29;
-	SOL_IRDA				= 0x10a;
-	SOL_PACKET				= 0x107;
-	SOL_RAW					= 0xff;
-	SOL_SOCKET				= 0x1;
-	SOL_TCP					= 0x6;
-	SOL_X25					= 0x106;
-	SOMAXCONN				= 0x80;
-	SO_ACCEPTCONN				= 0x1e;
-	SO_ATTACH_FILTER			= 0x1a;
-	SO_BINDTODEVICE				= 0x19;
-	SO_BROADCAST				= 0x6;
-	SO_BSDCOMPAT				= 0xe;
-	SO_DEBUG				= 0x1;
-	SO_DETACH_FILTER			= 0x1b;
-	SO_DONTROUTE				= 0x5;
-	SO_ERROR				= 0x4;
-	SO_KEEPALIVE				= 0x9;
-	SO_LINGER				= 0xd;
-	SO_MARK					= 0x24;
-	SO_NO_CHECK				= 0xb;
-	SO_OOBINLINE				= 0xa;
-	SO_PASSCRED				= 0x10;
-	SO_PASSSEC				= 0x22;
-	SO_PEERCRED				= 0x11;
-	SO_PEERNAME				= 0x1c;
-	SO_PEERSEC				= 0x1f;
-	SO_PRIORITY				= 0xc;
-	SO_RCVBUF				= 0x8;
-	SO_RCVBUFFORCE				= 0x21;
-	SO_RCVLOWAT				= 0x12;
-	SO_RCVTIMEO				= 0x14;
-	SO_REUSEADDR				= 0x2;
-	SO_SECURITY_AUTHENTICATION		= 0x16;
-	SO_SECURITY_ENCRYPTION_NETWORK		= 0x18;
-	SO_SECURITY_ENCRYPTION_TRANSPORT	= 0x17;
-	SO_SNDBUF				= 0x7;
-	SO_SNDBUFFORCE				= 0x20;
-	SO_SNDLOWAT				= 0x13;
-	SO_SNDTIMEO				= 0x15;
-	SO_TIMESTAMP				= 0x1d;
-	SO_TIMESTAMPING				= 0x25;
-	SO_TIMESTAMPNS				= 0x23;
-	SO_TYPE					= 0x3;
-	S_BLKSIZE				= 0x200;
-	S_IEXEC					= 0x40;
-	S_IFBLK					= 0x6000;
-	S_IFCHR					= 0x2000;
-	S_IFDIR					= 0x4000;
-	S_IFIFO					= 0x1000;
-	S_IFLNK					= 0xa000;
-	S_IFMT					= 0xf000;
-	S_IFREG					= 0x8000;
-	S_IFSOCK				= 0xc000;
-	S_IREAD					= 0x100;
-	S_IRGRP					= 0x20;
-	S_IROTH					= 0x4;
-	S_IRUSR					= 0x100;
-	S_IRWXG					= 0x38;
-	S_IRWXO					= 0x7;
-	S_IRWXU					= 0x1c0;
-	S_ISGID					= 0x400;
-	S_ISUID					= 0x800;
-	S_ISVTX					= 0x200;
-	S_IWGRP					= 0x10;
-	S_IWOTH					= 0x2;
-	S_IWRITE				= 0x80;
-	S_IWUSR					= 0x80;
-	S_IXGRP					= 0x8;
-	S_IXOTH					= 0x1;
-	S_IXUSR					= 0x40;
-	TCP_CONGESTION				= 0xd;
-	TCP_CORK				= 0x3;
-	TCP_DEFER_ACCEPT			= 0x9;
-	TCP_INFO				= 0xb;
-	TCP_KEEPCNT				= 0x6;
-	TCP_KEEPIDLE				= 0x4;
-	TCP_KEEPINTVL				= 0x5;
-	TCP_LINGER2				= 0x8;
-	TCP_MAXSEG				= 0x2;
-	TCP_MAXWIN				= 0xffff;
-	TCP_MAX_WINSHIFT			= 0xe;
-	TCP_MD5SIG				= 0xe;
-	TCP_MD5SIG_MAXKEYLEN			= 0x50;
-	TCP_MSS					= 0x200;
-	TCP_NODELAY				= 0x1;
-	TCP_QUICKACK				= 0xc;
-	TCP_SYNCNT				= 0x7;
-	TCP_WINDOW_CLAMP			= 0xa;
-	WALL					= 0x40000000;
-	WCLONE					= 0x80000000;
-	WCONTINUED				= 0x8;
-	WEXITED					= 0x4;
-	WNOHANG					= 0x1;
-	WNOTHREAD				= 0x20000000;
-	WNOWAIT					= 0x1000000;
-	WORDSIZE				= 0x40;
-	WSTOPPED				= 0x2;
-	WUNTRACED				= 0x2;
+	AF_APPLETALK                     = 0x5
+	AF_ASH                           = 0x12
+	AF_ATMPVC                        = 0x8
+	AF_ATMSVC                        = 0x14
+	AF_AX25                          = 0x3
+	AF_BLUETOOTH                     = 0x1f
+	AF_BRIDGE                        = 0x7
+	AF_CAN                           = 0x1d
+	AF_DECnet                        = 0xc
+	AF_ECONET                        = 0x13
+	AF_FILE                          = 0x1
+	AF_IEEE802154                    = 0x24
+	AF_INET                          = 0x2
+	AF_INET6                         = 0xa
+	AF_IPX                           = 0x4
+	AF_IRDA                          = 0x17
+	AF_ISDN                          = 0x22
+	AF_IUCV                          = 0x20
+	AF_KEY                           = 0xf
+	AF_LLC                           = 0x1a
+	AF_LOCAL                         = 0x1
+	AF_MAX                           = 0x25
+	AF_NETBEUI                       = 0xd
+	AF_NETLINK                       = 0x10
+	AF_NETROM                        = 0x6
+	AF_PACKET                        = 0x11
+	AF_PHONET                        = 0x23
+	AF_PPPOX                         = 0x18
+	AF_RDS                           = 0x15
+	AF_ROSE                          = 0xb
+	AF_ROUTE                         = 0x10
+	AF_RXRPC                         = 0x21
+	AF_SECURITY                      = 0xe
+	AF_SNA                           = 0x16
+	AF_TIPC                          = 0x1e
+	AF_UNIX                          = 0x1
+	AF_UNSPEC                        = 0
+	AF_WANPIPE                       = 0x19
+	AF_X25                           = 0x9
+	E2BIG                            = 0x7
+	EACCES                           = 0xd
+	EADDRINUSE                       = 0x62
+	EADDRNOTAVAIL                    = 0x63
+	EADV                             = 0x44
+	EAFNOSUPPORT                     = 0x61
+	EAGAIN                           = 0xb
+	EALREADY                         = 0x72
+	EBADE                            = 0x34
+	EBADF                            = 0x9
+	EBADFD                           = 0x4d
+	EBADMSG                          = 0x4a
+	EBADR                            = 0x35
+	EBADRQC                          = 0x38
+	EBADSLT                          = 0x39
+	EBFONT                           = 0x3b
+	EBUSY                            = 0x10
+	ECANCELED                        = 0x7d
+	ECHILD                           = 0xa
+	ECHRNG                           = 0x2c
+	ECOMM                            = 0x46
+	ECONNABORTED                     = 0x67
+	ECONNREFUSED                     = 0x6f
+	ECONNRESET                       = 0x68
+	EDEADLK                          = 0x23
+	EDEADLOCK                        = 0x23
+	EDESTADDRREQ                     = 0x59
+	EDOM                             = 0x21
+	EDOTDOT                          = 0x49
+	EDQUOT                           = 0x7a
+	EEXIST                           = 0x11
+	EFAULT                           = 0xe
+	EFBIG                            = 0x1b
+	EHOSTDOWN                        = 0x70
+	EHOSTUNREACH                     = 0x71
+	EIDRM                            = 0x2b
+	EILSEQ                           = 0x54
+	EINPROGRESS                      = 0x73
+	EINTR                            = 0x4
+	EINVAL                           = 0x16
+	EIO                              = 0x5
+	EISCONN                          = 0x6a
+	EISDIR                           = 0x15
+	EISNAM                           = 0x78
+	EKEYEXPIRED                      = 0x7f
+	EKEYREJECTED                     = 0x81
+	EKEYREVOKED                      = 0x80
+	EL2HLT                           = 0x33
+	EL2NSYNC                         = 0x2d
+	EL3HLT                           = 0x2e
+	EL3RST                           = 0x2f
+	ELIBACC                          = 0x4f
+	ELIBBAD                          = 0x50
+	ELIBEXEC                         = 0x53
+	ELIBMAX                          = 0x52
+	ELIBSCN                          = 0x51
+	ELNRNG                           = 0x30
+	ELOOP                            = 0x28
+	EMEDIUMTYPE                      = 0x7c
+	EMFILE                           = 0x18
+	EMLINK                           = 0x1f
+	EMSGSIZE                         = 0x5a
+	EMULTIHOP                        = 0x48
+	ENAMETOOLONG                     = 0x24
+	ENAVAIL                          = 0x77
+	ENETDOWN                         = 0x64
+	ENETRESET                        = 0x66
+	ENETUNREACH                      = 0x65
+	ENFILE                           = 0x17
+	ENOANO                           = 0x37
+	ENOBUFS                          = 0x69
+	ENOCSI                           = 0x32
+	ENODATA                          = 0x3d
+	ENODEV                           = 0x13
+	ENOENT                           = 0x2
+	ENOEXEC                          = 0x8
+	ENOKEY                           = 0x7e
+	ENOLCK                           = 0x25
+	ENOLINK                          = 0x43
+	ENOMEDIUM                        = 0x7b
+	ENOMEM                           = 0xc
+	ENOMSG                           = 0x2a
+	ENONET                           = 0x40
+	ENOPKG                           = 0x41
+	ENOPROTOOPT                      = 0x5c
+	ENOSPC                           = 0x1c
+	ENOSR                            = 0x3f
+	ENOSTR                           = 0x3c
+	ENOSYS                           = 0x26
+	ENOTBLK                          = 0xf
+	ENOTCONN                         = 0x6b
+	ENOTDIR                          = 0x14
+	ENOTEMPTY                        = 0x27
+	ENOTNAM                          = 0x76
+	ENOTRECOVERABLE                  = 0x83
+	ENOTSOCK                         = 0x58
+	ENOTSUP                          = 0x5f
+	ENOTTY                           = 0x19
+	ENOTUNIQ                         = 0x4c
+	ENXIO                            = 0x6
+	EOPNOTSUPP                       = 0x5f
+	EOVERFLOW                        = 0x4b
+	EOWNERDEAD                       = 0x82
+	EPERM                            = 0x1
+	EPFNOSUPPORT                     = 0x60
+	EPIPE                            = 0x20
+	EPOLLERR                         = 0x8
+	EPOLLET                          = -0x80000000
+	EPOLLHUP                         = 0x10
+	EPOLLIN                          = 0x1
+	EPOLLMSG                         = 0x400
+	EPOLLONESHOT                     = 0x40000000
+	EPOLLOUT                         = 0x4
+	EPOLLPRI                         = 0x2
+	EPOLLRDBAND                      = 0x80
+	EPOLLRDHUP                       = 0x2000
+	EPOLLRDNORM                      = 0x40
+	EPOLLWRBAND                      = 0x200
+	EPOLLWRNORM                      = 0x100
+	EPOLL_CLOEXEC                    = 0x80000
+	EPOLL_CTL_ADD                    = 0x1
+	EPOLL_CTL_DEL                    = 0x2
+	EPOLL_CTL_MOD                    = 0x3
+	EPOLL_NONBLOCK                   = 0x800
+	EPROTO                           = 0x47
+	EPROTONOSUPPORT                  = 0x5d
+	EPROTOTYPE                       = 0x5b
+	ERANGE                           = 0x22
+	EREMCHG                          = 0x4e
+	EREMOTE                          = 0x42
+	EREMOTEIO                        = 0x79
+	ERESTART                         = 0x55
+	ERFKILL                          = 0x84
+	EROFS                            = 0x1e
+	ESHUTDOWN                        = 0x6c
+	ESOCKTNOSUPPORT                  = 0x5e
+	ESPIPE                           = 0x1d
+	ESRCH                            = 0x3
+	ESRMNT                           = 0x45
+	ESTALE                           = 0x74
+	ESTRPIPE                         = 0x56
+	ETIME                            = 0x3e
+	ETIMEDOUT                        = 0x6e
+	ETOOMANYREFS                     = 0x6d
+	ETXTBSY                          = 0x1a
+	EUCLEAN                          = 0x75
+	EUNATCH                          = 0x31
+	EUSERS                           = 0x57
+	EWOULDBLOCK                      = 0xb
+	EXDEV                            = 0x12
+	EXFULL                           = 0x36
+	FD_CLOEXEC                       = 0x1
+	FD_SETSIZE                       = 0x400
+	F_DUPFD                          = 0
+	F_DUPFD_CLOEXEC                  = 0x406
+	F_EXLCK                          = 0x4
+	F_GETFD                          = 0x1
+	F_GETFL                          = 0x3
+	F_GETLEASE                       = 0x401
+	F_GETLK                          = 0x5
+	F_GETLK64                        = 0x5
+	F_GETOWN                         = 0x9
+	F_GETSIG                         = 0xb
+	F_LOCK                           = 0x1
+	F_NOTIFY                         = 0x402
+	F_OK                             = 0
+	F_RDLCK                          = 0
+	F_SETFD                          = 0x2
+	F_SETFL                          = 0x4
+	F_SETLEASE                       = 0x400
+	F_SETLK                          = 0x6
+	F_SETLK64                        = 0x6
+	F_SETLKW                         = 0x7
+	F_SETLKW64                       = 0x7
+	F_SETOWN                         = 0x8
+	F_SETSIG                         = 0xa
+	F_SHLCK                          = 0x8
+	F_TEST                           = 0x3
+	F_TLOCK                          = 0x2
+	F_ULOCK                          = 0
+	F_UNLCK                          = 0x2
+	F_WRLCK                          = 0x1
+	IPPROTO_AH                       = 0x33
+	IPPROTO_COMP                     = 0x6c
+	IPPROTO_DCCP                     = 0x21
+	IPPROTO_DSTOPTS                  = 0x3c
+	IPPROTO_EGP                      = 0x8
+	IPPROTO_ENCAP                    = 0x62
+	IPPROTO_ESP                      = 0x32
+	IPPROTO_FRAGMENT                 = 0x2c
+	IPPROTO_GRE                      = 0x2f
+	IPPROTO_HOPOPTS                  = 0
+	IPPROTO_ICMP                     = 0x1
+	IPPROTO_ICMPV6                   = 0x3a
+	IPPROTO_IDP                      = 0x16
+	IPPROTO_IGMP                     = 0x2
+	IPPROTO_IP                       = 0
+	IPPROTO_IPIP                     = 0x4
+	IPPROTO_IPV6                     = 0x29
+	IPPROTO_MTP                      = 0x5c
+	IPPROTO_NONE                     = 0x3b
+	IPPROTO_PIM                      = 0x67
+	IPPROTO_PUP                      = 0xc
+	IPPROTO_RAW                      = 0xff
+	IPPROTO_ROUTING                  = 0x2b
+	IPPROTO_RSVP                     = 0x2e
+	IPPROTO_SCTP                     = 0x84
+	IPPROTO_TCP                      = 0x6
+	IPPROTO_TP                       = 0x1d
+	IPPROTO_UDP                      = 0x11
+	IPPROTO_UDPLITE                  = 0x88
+	IP_ADD_MEMBERSHIP                = 0x23
+	IP_ADD_SOURCE_MEMBERSHIP         = 0x27
+	IP_BLOCK_SOURCE                  = 0x26
+	IP_DEFAULT_MULTICAST_LOOP        = 0x1
+	IP_DEFAULT_MULTICAST_TTL         = 0x1
+	IP_DROP_MEMBERSHIP               = 0x24
+	IP_DROP_SOURCE_MEMBERSHIP        = 0x28
+	IP_HDRINCL                       = 0x3
+	IP_MAX_MEMBERSHIPS               = 0x14
+	IP_MSFILTER                      = 0x29
+	IP_MTU_DISCOVER                  = 0xa
+	IP_MULTICAST_IF                  = 0x20
+	IP_MULTICAST_LOOP                = 0x22
+	IP_MULTICAST_TTL                 = 0x21
+	IP_OPTIONS                       = 0x4
+	IP_PKTINFO                       = 0x8
+	IP_PKTOPTIONS                    = 0x9
+	IP_PMTUDISC                      = 0xa
+	IP_PMTUDISC_DO                   = 0x2
+	IP_PMTUDISC_DONT                 = 0
+	IP_PMTUDISC_PROBE                = 0x3
+	IP_PMTUDISC_WANT                 = 0x1
+	IP_RECVERR                       = 0xb
+	IP_RECVOPTS                      = 0x6
+	IP_RECVRETOPTS                   = 0x7
+	IP_RECVTOS                       = 0xd
+	IP_RECVTTL                       = 0xc
+	IP_RETOPTS                       = 0x7
+	IP_ROUTER_ALERT                  = 0x5
+	IP_TOS                           = 0x1
+	IP_TTL                           = 0x2
+	IP_UNBLOCK_SOURCE                = 0x25
+	NAME_MAX                         = 0xff
+	O_ACCMODE                        = 0x3
+	O_APPEND                         = 0x400
+	O_ASYNC                          = 0x2000
+	O_CLOEXEC                        = 0x80000
+	O_CREAT                          = 0x40
+	O_DIRECT                         = 0x4000
+	O_DIRECTORY                      = 0x10000
+	O_DSYNC                          = 0x1000
+	O_EXCL                           = 0x80
+	O_FSYNC                          = 0x1000
+	O_LARGEFILE                      = 0
+	O_NDELAY                         = 0x800
+	O_NOATIME                        = 0x40000
+	O_NOCTTY                         = 0x100
+	O_NOFOLLOW                       = 0x20000
+	O_NONBLOCK                       = 0x800
+	O_RDONLY                         = 0
+	O_RDWR                           = 0x2
+	O_RSYNC                          = 0x1000
+	O_SYNC                           = 0x1000
+	O_TRUNC                          = 0x200
+	O_WRONLY                         = 0x1
+	PTRACE_ARCH_PRCTL                = 0x1e
+	PTRACE_ATTACH                    = 0x10
+	PTRACE_BTS_CLEAR                 = 0x2c
+	PTRACE_BTS_CONFIG                = 0x28
+	PTRACE_BTS_DRAIN                 = 0x2d
+	PTRACE_BTS_GET                   = 0x2b
+	PTRACE_BTS_O_ALLOC               = 0x8
+	PTRACE_BTS_O_SCHED               = 0x2
+	PTRACE_BTS_O_SIGNAL              = 0x4
+	PTRACE_BTS_O_TRACE               = 0x1
+	PTRACE_BTS_SIZE                  = 0x2a
+	PTRACE_BTS_STATUS                = 0x29
+	PTRACE_CONT                      = 0x7
+	PTRACE_DETACH                    = 0x11
+	PTRACE_EVENT_CLONE               = 0x3
+	PTRACE_EVENT_EXEC                = 0x4
+	PTRACE_EVENT_EXIT                = 0x6
+	PTRACE_EVENT_FORK                = 0x1
+	PTRACE_EVENT_VFORK               = 0x2
+	PTRACE_EVENT_VFORK_DONE          = 0x5
+	PTRACE_GETEVENTMSG               = 0x4201
+	PTRACE_GETFPREGS                 = 0xe
+	PTRACE_GETFPXREGS                = 0x12
+	PTRACE_GETREGS                   = 0xc
+	PTRACE_GETSIGINFO                = 0x4202
+	PTRACE_GET_THREAD_AREA           = 0x19
+	PTRACE_KILL                      = 0x8
+	PTRACE_OLDSETOPTIONS             = 0x15
+	PTRACE_O_MASK                    = 0x7f
+	PTRACE_O_TRACECLONE              = 0x8
+	PTRACE_O_TRACEEXEC               = 0x10
+	PTRACE_O_TRACEEXIT               = 0x40
+	PTRACE_O_TRACEFORK               = 0x2
+	PTRACE_O_TRACESYSGOOD            = 0x1
+	PTRACE_O_TRACEVFORK              = 0x4
+	PTRACE_O_TRACEVFORKDONE          = 0x20
+	PTRACE_PEEKDATA                  = 0x2
+	PTRACE_PEEKTEXT                  = 0x1
+	PTRACE_PEEKUSR                   = 0x3
+	PTRACE_POKEDATA                  = 0x5
+	PTRACE_POKETEXT                  = 0x4
+	PTRACE_POKEUSR                   = 0x6
+	PTRACE_SETFPREGS                 = 0xf
+	PTRACE_SETFPXREGS                = 0x13
+	PTRACE_SETOPTIONS                = 0x4200
+	PTRACE_SETREGS                   = 0xd
+	PTRACE_SETSIGINFO                = 0x4203
+	PTRACE_SET_THREAD_AREA           = 0x1a
+	PTRACE_SINGLEBLOCK               = 0x21
+	PTRACE_SINGLESTEP                = 0x9
+	PTRACE_SYSCALL                   = 0x18
+	PTRACE_SYSEMU                    = 0x1f
+	PTRACE_SYSEMU_SINGLESTEP         = 0x20
+	PTRACE_TRACEME                   = 0
+	SHUT_RD                          = 0
+	SHUT_RDWR                        = 0x2
+	SHUT_WR                          = 0x1
+	SIGABRT                          = 0x6
+	SIGALRM                          = 0xe
+	SIGBUS                           = 0x7
+	SIGCHLD                          = 0x11
+	SIGCLD                           = 0x11
+	SIGCONT                          = 0x12
+	SIGFPE                           = 0x8
+	SIGHUP                           = 0x1
+	SIGILL                           = 0x4
+	SIGINT                           = 0x2
+	SIGIO                            = 0x1d
+	SIGIOT                           = 0x6
+	SIGKILL                          = 0x9
+	SIGPIPE                          = 0xd
+	SIGPOLL                          = 0x1d
+	SIGPROF                          = 0x1b
+	SIGPWR                           = 0x1e
+	SIGQUIT                          = 0x3
+	SIGSEGV                          = 0xb
+	SIGSTKFLT                        = 0x10
+	SIGSTOP                          = 0x13
+	SIGSYS                           = 0x1f
+	SIGTERM                          = 0xf
+	SIGTRAP                          = 0x5
+	SIGTSTP                          = 0x14
+	SIGTTIN                          = 0x15
+	SIGTTOU                          = 0x16
+	SIGUNUSED                        = 0x1f
+	SIGURG                           = 0x17
+	SIGUSR1                          = 0xa
+	SIGUSR2                          = 0xc
+	SIGVTALRM                        = 0x1a
+	SIGWINCH                         = 0x1c
+	SIGXCPU                          = 0x18
+	SIGXFSZ                          = 0x19
+	SOCK_CLOEXEC                     = 0x80000
+	SOCK_DCCP                        = 0x6
+	SOCK_DGRAM                       = 0x2
+	SOCK_NONBLOCK                    = 0x800
+	SOCK_PACKET                      = 0xa
+	SOCK_RAW                         = 0x3
+	SOCK_RDM                         = 0x4
+	SOCK_SEQPACKET                   = 0x5
+	SOCK_STREAM                      = 0x1
+	SOL_AAL                          = 0x109
+	SOL_ATM                          = 0x108
+	SOL_DECNET                       = 0x105
+	SOL_ICMPV6                       = 0x3a
+	SOL_IP                           = 0
+	SOL_IPV6                         = 0x29
+	SOL_IRDA                         = 0x10a
+	SOL_PACKET                       = 0x107
+	SOL_RAW                          = 0xff
+	SOL_SOCKET                       = 0x1
+	SOL_TCP                          = 0x6
+	SOL_X25                          = 0x106
+	SOMAXCONN                        = 0x80
+	SO_ACCEPTCONN                    = 0x1e
+	SO_ATTACH_FILTER                 = 0x1a
+	SO_BINDTODEVICE                  = 0x19
+	SO_BROADCAST                     = 0x6
+	SO_BSDCOMPAT                     = 0xe
+	SO_DEBUG                         = 0x1
+	SO_DETACH_FILTER                 = 0x1b
+	SO_DONTROUTE                     = 0x5
+	SO_ERROR                         = 0x4
+	SO_KEEPALIVE                     = 0x9
+	SO_LINGER                        = 0xd
+	SO_MARK                          = 0x24
+	SO_NO_CHECK                      = 0xb
+	SO_OOBINLINE                     = 0xa
+	SO_PASSCRED                      = 0x10
+	SO_PASSSEC                       = 0x22
+	SO_PEERCRED                      = 0x11
+	SO_PEERNAME                      = 0x1c
+	SO_PEERSEC                       = 0x1f
+	SO_PRIORITY                      = 0xc
+	SO_RCVBUF                        = 0x8
+	SO_RCVBUFFORCE                   = 0x21
+	SO_RCVLOWAT                      = 0x12
+	SO_RCVTIMEO                      = 0x14
+	SO_REUSEADDR                     = 0x2
+	SO_SECURITY_AUTHENTICATION       = 0x16
+	SO_SECURITY_ENCRYPTION_NETWORK   = 0x18
+	SO_SECURITY_ENCRYPTION_TRANSPORT = 0x17
+	SO_SNDBUF                        = 0x7
+	SO_SNDBUFFORCE                   = 0x20
+	SO_SNDLOWAT                      = 0x13
+	SO_SNDTIMEO                      = 0x15
+	SO_TIMESTAMP                     = 0x1d
+	SO_TIMESTAMPING                  = 0x25
+	SO_TIMESTAMPNS                   = 0x23
+	SO_TYPE                          = 0x3
+	S_BLKSIZE                        = 0x200
+	S_IEXEC                          = 0x40
+	S_IFBLK                          = 0x6000
+	S_IFCHR                          = 0x2000
+	S_IFDIR                          = 0x4000
+	S_IFIFO                          = 0x1000
+	S_IFLNK                          = 0xa000
+	S_IFMT                           = 0xf000
+	S_IFREG                          = 0x8000
+	S_IFSOCK                         = 0xc000
+	S_IREAD                          = 0x100
+	S_IRGRP                          = 0x20
+	S_IROTH                          = 0x4
+	S_IRUSR                          = 0x100
+	S_IRWXG                          = 0x38
+	S_IRWXO                          = 0x7
+	S_IRWXU                          = 0x1c0
+	S_ISGID                          = 0x400
+	S_ISUID                          = 0x800
+	S_ISVTX                          = 0x200
+	S_IWGRP                          = 0x10
+	S_IWOTH                          = 0x2
+	S_IWRITE                         = 0x80
+	S_IWUSR                          = 0x80
+	S_IXGRP                          = 0x8
+	S_IXOTH                          = 0x1
+	S_IXUSR                          = 0x40
+	TCP_CONGESTION                   = 0xd
+	TCP_CORK                         = 0x3
+	TCP_DEFER_ACCEPT                 = 0x9
+	TCP_INFO                         = 0xb
+	TCP_KEEPCNT                      = 0x6
+	TCP_KEEPIDLE                     = 0x4
+	TCP_KEEPINTVL                    = 0x5
+	TCP_LINGER2                      = 0x8
+	TCP_MAXSEG                       = 0x2
+	TCP_MAXWIN                       = 0xffff
+	TCP_MAX_WINSHIFT                 = 0xe
+	TCP_MD5SIG                       = 0xe
+	TCP_MD5SIG_MAXKEYLEN             = 0x50
+	TCP_MSS                          = 0x200
+	TCP_NODELAY                      = 0x1
+	TCP_QUICKACK                     = 0xc
+	TCP_SYNCNT                       = 0x7
+	TCP_WINDOW_CLAMP                 = 0xa
+	WALL                             = 0x40000000
+	WCLONE                           = 0x80000000
+	WCONTINUED                       = 0x8
+	WEXITED                          = 0x4
+	WNOHANG                          = 0x1
+	WNOTHREAD                        = 0x20000000
+	WNOWAIT                          = 0x1000000
+	WORDSIZE                         = 0x40
+	WSTOPPED                         = 0x2
+	WUNTRACED                        = 0x2
 )
 
 // Types
diff --git a/src/pkg/syscall/zerrors_linux_arm.go b/src/pkg/syscall/zerrors_linux_arm.go
index 1d7ff44985..19d676074d 100644
--- a/src/pkg/syscall/zerrors_linux_arm.go
+++ b/src/pkg/syscall/zerrors_linux_arm.go
@@ -9,177 +9,177 @@ package syscall
 
 // Constants
 const (
-	EMULTIHOP	= 0x48;
-	EUNATCH		= 0x31;
-	EAFNOSUPPORT	= 0x61;
-	EREMCHG		= 0x4e;
-	EACCES		= 0xd;
-	EL3RST		= 0x2f;
-	EDESTADDRREQ	= 0x59;
-	EILSEQ		= 0x54;
-	ESPIPE		= 0x1d;
-	EMLINK		= 0x1f;
-	EOWNERDEAD	= 0x82;
-	ENOTTY		= 0x19;
-	EBADE		= 0x34;
-	EBADF		= 0x9;
-	EBADR		= 0x35;
-	EADV		= 0x44;
-	ERANGE		= 0x22;
-	ECANCELED	= 0x7d;
-	ETXTBSY		= 0x1a;
-	ENOMEM		= 0xc;
-	EINPROGRESS	= 0x73;
-	ENOTEMPTY	= 0x27;
-	ENOTBLK		= 0xf;
-	EPROTOTYPE	= 0x5b;
-	ERESTART	= 0x55;
-	EISNAM		= 0x78;
-	ENOMSG		= 0x2a;
-	EALREADY	= 0x72;
-	ETIMEDOUT	= 0x6e;
-	ENODATA		= 0x3d;
-	EINTR		= 0x4;
-	ENOLINK		= 0x43;
-	EPERM		= 0x1;
-	ELOOP		= 0x28;
-	ENETDOWN	= 0x64;
-	ESTALE		= 0x74;
-	ENOTSOCK	= 0x58;
-	ENOSR		= 0x3f;
-	ECHILD		= 0xa;
-	ELNRNG		= 0x30;
-	EPIPE		= 0x20;
-	EBADMSG		= 0x4a;
-	EBFONT		= 0x3b;
-	EREMOTE		= 0x42;
-	ETOOMANYREFS	= 0x6d;
-	EPFNOSUPPORT	= 0x60;
-	ENONET		= 0x40;
-	EXFULL		= 0x36;
-	EBADSLT		= 0x39;
-	ENOTNAM		= 0x76;
-	ENOCSI		= 0x32;
-	EADDRINUSE	= 0x62;
-	ENETRESET	= 0x66;
-	EISDIR		= 0x15;
-	EIDRM		= 0x2b;
-	ECOMM		= 0x46;
-	EBADFD		= 0x4d;
-	EL2HLT		= 0x33;
-	ENOKEY		= 0x7e;
-	EINVAL		= 0x16;
-	ESHUTDOWN	= 0x6c;
-	EKEYREJECTED	= 0x81;
-	ELIBSCN		= 0x51;
-	ENAVAIL		= 0x77;
-	EOVERFLOW	= 0x4b;
-	EUCLEAN		= 0x75;
-	ENOMEDIUM	= 0x7b;
-	EBUSY		= 0x10;
-	EPROTO		= 0x47;
-	ENODEV		= 0x13;
-	EKEYEXPIRED	= 0x7f;
-	EROFS		= 0x1e;
-	ELIBACC		= 0x4f;
-	E2BIG		= 0x7;
-	EDEADLK		= 0x23;
-	ENOTDIR		= 0x14;
-	ECONNRESET	= 0x68;
-	ENXIO		= 0x6;
-	EBADRQC		= 0x38;
-	ENAMETOOLONG	= 0x24;
-	ESOCKTNOSUPPORT	= 0x5e;
-	ELIBEXEC	= 0x53;
-	EDOTDOT		= 0x49;
-	EADDRNOTAVAIL	= 0x63;
-	ETIME		= 0x3e;
-	EPROTONOSUPPORT	= 0x5d;
-	ENOTRECOVERABLE	= 0x83;
-	EIO		= 0x5;
-	ENETUNREACH	= 0x65;
-	EXDEV		= 0x12;
-	EDQUOT		= 0x7a;
-	EREMOTEIO	= 0x79;
-	ENOSPC		= 0x1c;
-	ENOEXEC		= 0x8;
-	EMSGSIZE	= 0x5a;
-	EDOM		= 0x21;
-	ENOSTR		= 0x3c;
-	EFBIG		= 0x1b;
-	ESRCH		= 0x3;
-	ECHRNG		= 0x2c;
-	EHOSTDOWN	= 0x70;
-	ENOLCK		= 0x25;
-	ENFILE		= 0x17;
-	ENOSYS		= 0x26;
-	ENOTCONN	= 0x6b;
-	ENOTSUP		= 0x5f;
-	ESRMNT		= 0x45;
-	EDEADLOCK	= 0x23;
-	ECONNABORTED	= 0x67;
-	ENOANO		= 0x37;
-	EISCONN		= 0x6a;
-	EUSERS		= 0x57;
-	ENOPROTOOPT	= 0x5c;
-	EMFILE		= 0x18;
-	ENOBUFS		= 0x69;
-	EL3HLT		= 0x2e;
-	EFAULT		= 0xe;
-	EWOULDBLOCK	= 0xb;
-	ELIBBAD		= 0x50;
-	ESTRPIPE	= 0x56;
-	ECONNREFUSED	= 0x6f;
-	EAGAIN		= 0xb;
-	ELIBMAX		= 0x52;
-	EEXIST		= 0x11;
-	EL2NSYNC	= 0x2d;
-	ENOENT		= 0x2;
-	ENOPKG		= 0x41;
-	EKEYREVOKED	= 0x80;
-	EHOSTUNREACH	= 0x71;
-	ENOTUNIQ	= 0x4c;
-	EOPNOTSUPP	= 0x5f;
-	EMEDIUMTYPE	= 0x7c;
-	SIGBUS		= 0x7;
-	SIGTTIN		= 0x15;
-	SIGPROF		= 0x1b;
-	SIGFPE		= 0x8;
-	SIGHUP		= 0x1;
-	SIGTTOU		= 0x16;
-	SIGSTKFLT	= 0x10;
-	SIGUSR1		= 0xa;
-	SIGURG		= 0x17;
-	SIGIO		= 0x1d;
-	SIGQUIT		= 0x3;
-	SIGCLD		= 0x11;
-	SHUT_RD		= 0;
-	SHUT_RDWR	= 0x2;
-	SHUT_WR		= 0x1;
-	SIGABRT		= 0x6;
-	SIGTRAP		= 0x5;
-	SIGVTALRM	= 0x1a;
-	SIGPOLL		= 0x1d;
-	SIGSEGV		= 0xb;
-	SIGCONT		= 0x12;
-	SIGPIPE		= 0xd;
-	SIGWINCH	= 0x1c;
-	SIGXFSZ		= 0x19;
-	SIGCHLD		= 0x11;
-	SIGSYS		= 0x1f;
-	SIGSTOP		= 0x13;
-	SIGALRM		= 0xe;
-	SIGUSR2		= 0xc;
-	SIGTSTP		= 0x14;
-	SIGKILL		= 0x9;
-	SIGXCPU		= 0x18;
-	SIGUNUSED	= 0x1f;
-	SIGPWR		= 0x1e;
-	SIGILL		= 0x4;
-	SIGINT		= 0x2;
-	SIGIOT		= 0x6;
-	SIGTERM		= 0xf;
-	O_EXCL		= 0x80;
+	EMULTIHOP       = 0x48
+	EUNATCH         = 0x31
+	EAFNOSUPPORT    = 0x61
+	EREMCHG         = 0x4e
+	EACCES          = 0xd
+	EL3RST          = 0x2f
+	EDESTADDRREQ    = 0x59
+	EILSEQ          = 0x54
+	ESPIPE          = 0x1d
+	EMLINK          = 0x1f
+	EOWNERDEAD      = 0x82
+	ENOTTY          = 0x19
+	EBADE           = 0x34
+	EBADF           = 0x9
+	EBADR           = 0x35
+	EADV            = 0x44
+	ERANGE          = 0x22
+	ECANCELED       = 0x7d
+	ETXTBSY         = 0x1a
+	ENOMEM          = 0xc
+	EINPROGRESS     = 0x73
+	ENOTEMPTY       = 0x27
+	ENOTBLK         = 0xf
+	EPROTOTYPE      = 0x5b
+	ERESTART        = 0x55
+	EISNAM          = 0x78
+	ENOMSG          = 0x2a
+	EALREADY        = 0x72
+	ETIMEDOUT       = 0x6e
+	ENODATA         = 0x3d
+	EINTR           = 0x4
+	ENOLINK         = 0x43
+	EPERM           = 0x1
+	ELOOP           = 0x28
+	ENETDOWN        = 0x64
+	ESTALE          = 0x74
+	ENOTSOCK        = 0x58
+	ENOSR           = 0x3f
+	ECHILD          = 0xa
+	ELNRNG          = 0x30
+	EPIPE           = 0x20
+	EBADMSG         = 0x4a
+	EBFONT          = 0x3b
+	EREMOTE         = 0x42
+	ETOOMANYREFS    = 0x6d
+	EPFNOSUPPORT    = 0x60
+	ENONET          = 0x40
+	EXFULL          = 0x36
+	EBADSLT         = 0x39
+	ENOTNAM         = 0x76
+	ENOCSI          = 0x32
+	EADDRINUSE      = 0x62
+	ENETRESET       = 0x66
+	EISDIR          = 0x15
+	EIDRM           = 0x2b
+	ECOMM           = 0x46
+	EBADFD          = 0x4d
+	EL2HLT          = 0x33
+	ENOKEY          = 0x7e
+	EINVAL          = 0x16
+	ESHUTDOWN       = 0x6c
+	EKEYREJECTED    = 0x81
+	ELIBSCN         = 0x51
+	ENAVAIL         = 0x77
+	EOVERFLOW       = 0x4b
+	EUCLEAN         = 0x75
+	ENOMEDIUM       = 0x7b
+	EBUSY           = 0x10
+	EPROTO          = 0x47
+	ENODEV          = 0x13
+	EKEYEXPIRED     = 0x7f
+	EROFS           = 0x1e
+	ELIBACC         = 0x4f
+	E2BIG           = 0x7
+	EDEADLK         = 0x23
+	ENOTDIR         = 0x14
+	ECONNRESET      = 0x68
+	ENXIO           = 0x6
+	EBADRQC         = 0x38
+	ENAMETOOLONG    = 0x24
+	ESOCKTNOSUPPORT = 0x5e
+	ELIBEXEC        = 0x53
+	EDOTDOT         = 0x49
+	EADDRNOTAVAIL   = 0x63
+	ETIME           = 0x3e
+	EPROTONOSUPPORT = 0x5d
+	ENOTRECOVERABLE = 0x83
+	EIO             = 0x5
+	ENETUNREACH     = 0x65
+	EXDEV           = 0x12
+	EDQUOT          = 0x7a
+	EREMOTEIO       = 0x79
+	ENOSPC          = 0x1c
+	ENOEXEC         = 0x8
+	EMSGSIZE        = 0x5a
+	EDOM            = 0x21
+	ENOSTR          = 0x3c
+	EFBIG           = 0x1b
+	ESRCH           = 0x3
+	ECHRNG          = 0x2c
+	EHOSTDOWN       = 0x70
+	ENOLCK          = 0x25
+	ENFILE          = 0x17
+	ENOSYS          = 0x26
+	ENOTCONN        = 0x6b
+	ENOTSUP         = 0x5f
+	ESRMNT          = 0x45
+	EDEADLOCK       = 0x23
+	ECONNABORTED    = 0x67
+	ENOANO          = 0x37
+	EISCONN         = 0x6a
+	EUSERS          = 0x57
+	ENOPROTOOPT     = 0x5c
+	EMFILE          = 0x18
+	ENOBUFS         = 0x69
+	EL3HLT          = 0x2e
+	EFAULT          = 0xe
+	EWOULDBLOCK     = 0xb
+	ELIBBAD         = 0x50
+	ESTRPIPE        = 0x56
+	ECONNREFUSED    = 0x6f
+	EAGAIN          = 0xb
+	ELIBMAX         = 0x52
+	EEXIST          = 0x11
+	EL2NSYNC        = 0x2d
+	ENOENT          = 0x2
+	ENOPKG          = 0x41
+	EKEYREVOKED     = 0x80
+	EHOSTUNREACH    = 0x71
+	ENOTUNIQ        = 0x4c
+	EOPNOTSUPP      = 0x5f
+	EMEDIUMTYPE     = 0x7c
+	SIGBUS          = 0x7
+	SIGTTIN         = 0x15
+	SIGPROF         = 0x1b
+	SIGFPE          = 0x8
+	SIGHUP          = 0x1
+	SIGTTOU         = 0x16
+	SIGSTKFLT       = 0x10
+	SIGUSR1         = 0xa
+	SIGURG          = 0x17
+	SIGIO           = 0x1d
+	SIGQUIT         = 0x3
+	SIGCLD          = 0x11
+	SHUT_RD         = 0
+	SHUT_RDWR       = 0x2
+	SHUT_WR         = 0x1
+	SIGABRT         = 0x6
+	SIGTRAP         = 0x5
+	SIGVTALRM       = 0x1a
+	SIGPOLL         = 0x1d
+	SIGSEGV         = 0xb
+	SIGCONT         = 0x12
+	SIGPIPE         = 0xd
+	SIGWINCH        = 0x1c
+	SIGXFSZ         = 0x19
+	SIGCHLD         = 0x11
+	SIGSYS          = 0x1f
+	SIGSTOP         = 0x13
+	SIGALRM         = 0xe
+	SIGUSR2         = 0xc
+	SIGTSTP         = 0x14
+	SIGKILL         = 0x9
+	SIGXCPU         = 0x18
+	SIGUNUSED       = 0x1f
+	SIGPWR          = 0x1e
+	SIGILL          = 0x4
+	SIGINT          = 0x2
+	SIGIOT          = 0x6
+	SIGTERM         = 0xf
+	O_EXCL          = 0x80
 )
 
 // Types
diff --git a/src/pkg/syscall/zerrors_nacl_386.go b/src/pkg/syscall/zerrors_nacl_386.go
index c80557e49f..2c1dff8cf8 100644
--- a/src/pkg/syscall/zerrors_nacl_386.go
+++ b/src/pkg/syscall/zerrors_nacl_386.go
@@ -4,126 +4,126 @@
 package syscall
 
 const (
-	EPERM		= 1;
-	ENOENT		= 2;
-	ESRCH		= 3;
-	EINTR		= 4;
-	EIO		= 5;
-	ENXIO		= 6;
-	E2BIG		= 7;
-	ENOEXEC		= 8;
-	EBADF		= 9;
-	ECHILD		= 10;
-	EAGAIN		= 11;
-	ENOMEM		= 12;
-	EACCES		= 13;
-	EFAULT		= 14;
-	EBUSY		= 16;
-	EEXIST		= 17;
-	EXDEV		= 18;
-	ENODEV		= 19;
-	ENOTDIR		= 20;
-	EISDIR		= 21;
-	EINVAL		= 22;
-	ENFILE		= 23;
-	EMFILE		= 24;
-	ENOTTY		= 25;
-	EFBIG		= 27;
-	ENOSPC		= 28;
-	ESPIPE		= 29;
-	EROFS		= 30;
-	EMLINK		= 31;
-	EPIPE		= 32;
-	ENAMETOOLONG	= 36;
-	ENOSYS		= 38;
-	EDQUOT		= 122;
-	EDOM		= 33;
-	ERANGE		= 34;
-	ENOMSG		= 35;
-	ECHRNG		= 37;
-	EL3HLT		= 39;
-	EL3RST		= 40;
-	ELNRNG		= 41;
-	EUNATCH		= 42;
-	ENOCSI		= 43;
-	EL2HLT		= 44;
-	EDEADLK		= 45;
-	ENOLCK		= 46;
-	EBADE		= 50;
-	EBADR		= 51;
-	EXFULL		= 52;
-	ENOANO		= 53;
-	EBADRQC		= 54;
-	EBADSLT		= 55;
-	EBFONT		= 57;
-	ENOSTR		= 60;
-	ENODATA		= 61;
-	ETIME		= 62;
-	ENOSR		= 63;
-	ENONET		= 64;
-	ENOPKG		= 65;
-	EREMOTE		= 66;
-	ENOLINK		= 67;
-	EADV		= 68;
-	ESRMNT		= 69;
-	ECOMM		= 70;
-	EPROTO		= 71;
-	EMULTIHOP	= 74;
-	ELBIN		= 75;
-	EDOTDOT		= 76;
-	EBADMSG		= 77;
-	EFTYPE		= 79;
-	ENOTUNIQ	= 80;
-	EBADFD		= 81;
-	EREMCHG		= 82;
-	ELIBACC		= 83;
-	ELIBBAD		= 84;
-	ELIBSCN		= 85;
-	ELIBMAX		= 86;
-	ELIBEXEC	= 87;
-	ENMFILE		= 89;
-	ENOTEMPTY	= 90;
-	ELOOP		= 92;
-	EOPNOTSUPP	= 95;
-	EPFNOSUPPORT	= 96;
-	ECONNRESET	= 104;
-	ENOBUFS		= 105;
-	EAFNOSUPPORT	= 106;
-	EPROTOTYPE	= 107;
-	ENOTSOCK	= 108;
-	ENOPROTOOPT	= 109;
-	ESHUTDOWN	= 110;
-	ECONNREFUSED	= 111;
-	EADDRINUSE	= 112;
-	ECONNABORTED	= 113;
-	ENETUNREACH	= 114;
-	ENETDOWN	= 115;
-	ETIMEDOUT	= 116;
-	EHOSTDOWN	= 117;
-	EHOSTUNREACH	= 118;
-	EINPROGRESS	= 119;
-	EALREADY	= 120;
-	EDESTADDRREQ	= 121;
-	EPROTONOSUPPORT	= 123;
-	ESOCKTNOSUPPORT	= 124;
-	EADDRNOTAVAIL	= 125;
-	ENETRESET	= 126;
-	EISCONN		= 127;
-	ENOTCONN	= 128;
-	ETOOMANYREFS	= 129;
-	EPROCLIM	= 130;
-	EUSERS		= 131;
-	ESTALE		= 133;
-	ENOMEDIUM	= 135;
-	ENOSHARE	= 136;
-	ECASECLASH	= 137;
-	EILSEQ		= 138;
-	EOVERFLOW	= 139;
-	ECANCELED	= 140;
-	EL2NSYNC	= 88;
-	EIDRM		= 91;
-	EMSGSIZE	= 132;
-	ENACL		= 99;	/* otherwise unused */
+	EPERM           = 1
+	ENOENT          = 2
+	ESRCH           = 3
+	EINTR           = 4
+	EIO             = 5
+	ENXIO           = 6
+	E2BIG           = 7
+	ENOEXEC         = 8
+	EBADF           = 9
+	ECHILD          = 10
+	EAGAIN          = 11
+	ENOMEM          = 12
+	EACCES          = 13
+	EFAULT          = 14
+	EBUSY           = 16
+	EEXIST          = 17
+	EXDEV           = 18
+	ENODEV          = 19
+	ENOTDIR         = 20
+	EISDIR          = 21
+	EINVAL          = 22
+	ENFILE          = 23
+	EMFILE          = 24
+	ENOTTY          = 25
+	EFBIG           = 27
+	ENOSPC          = 28
+	ESPIPE          = 29
+	EROFS           = 30
+	EMLINK          = 31
+	EPIPE           = 32
+	ENAMETOOLONG    = 36
+	ENOSYS          = 38
+	EDQUOT          = 122
+	EDOM            = 33
+	ERANGE          = 34
+	ENOMSG          = 35
+	ECHRNG          = 37
+	EL3HLT          = 39
+	EL3RST          = 40
+	ELNRNG          = 41
+	EUNATCH         = 42
+	ENOCSI          = 43
+	EL2HLT          = 44
+	EDEADLK         = 45
+	ENOLCK          = 46
+	EBADE           = 50
+	EBADR           = 51
+	EXFULL          = 52
+	ENOANO          = 53
+	EBADRQC         = 54
+	EBADSLT         = 55
+	EBFONT          = 57
+	ENOSTR          = 60
+	ENODATA         = 61
+	ETIME           = 62
+	ENOSR           = 63
+	ENONET          = 64
+	ENOPKG          = 65
+	EREMOTE         = 66
+	ENOLINK         = 67
+	EADV            = 68
+	ESRMNT          = 69
+	ECOMM           = 70
+	EPROTO          = 71
+	EMULTIHOP       = 74
+	ELBIN           = 75
+	EDOTDOT         = 76
+	EBADMSG         = 77
+	EFTYPE          = 79
+	ENOTUNIQ        = 80
+	EBADFD          = 81
+	EREMCHG         = 82
+	ELIBACC         = 83
+	ELIBBAD         = 84
+	ELIBSCN         = 85
+	ELIBMAX         = 86
+	ELIBEXEC        = 87
+	ENMFILE         = 89
+	ENOTEMPTY       = 90
+	ELOOP           = 92
+	EOPNOTSUPP      = 95
+	EPFNOSUPPORT    = 96
+	ECONNRESET      = 104
+	ENOBUFS         = 105
+	EAFNOSUPPORT    = 106
+	EPROTOTYPE      = 107
+	ENOTSOCK        = 108
+	ENOPROTOOPT     = 109
+	ESHUTDOWN       = 110
+	ECONNREFUSED    = 111
+	EADDRINUSE      = 112
+	ECONNABORTED    = 113
+	ENETUNREACH     = 114
+	ENETDOWN        = 115
+	ETIMEDOUT       = 116
+	EHOSTDOWN       = 117
+	EHOSTUNREACH    = 118
+	EINPROGRESS     = 119
+	EALREADY        = 120
+	EDESTADDRREQ    = 121
+	EPROTONOSUPPORT = 123
+	ESOCKTNOSUPPORT = 124
+	EADDRNOTAVAIL   = 125
+	ENETRESET       = 126
+	EISCONN         = 127
+	ENOTCONN        = 128
+	ETOOMANYREFS    = 129
+	EPROCLIM        = 130
+	EUSERS          = 131
+	ESTALE          = 133
+	ENOMEDIUM       = 135
+	ENOSHARE        = 136
+	ECASECLASH      = 137
+	EILSEQ          = 138
+	EOVERFLOW       = 139
+	ECANCELED       = 140
+	EL2NSYNC        = 88
+	EIDRM           = 91
+	EMSGSIZE        = 132
+	ENACL           = 99 /* otherwise unused */
 )
 
 
diff --git a/src/pkg/syscall/zsyscall_darwin_386.go b/src/pkg/syscall/zsyscall_darwin_386.go
index f4c33edc96..303919ce45 100644
--- a/src/pkg/syscall/zsyscall_darwin_386.go
+++ b/src/pkg/syscall/zsyscall_darwin_386.go
@@ -6,676 +6,676 @@ package syscall
 import "unsafe"
 
 func getgroups(ngid int, gid *_Gid_t) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func setgroups(ngid int, gid *_Gid_t) (errno int) {
-	_, _, e1 := Syscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)
+	errno = int(e1)
+	return
 }
 
 func wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, errno int) {
-	r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0);
-	wpid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)
+	wpid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func pipe() (r int, w int, errno int) {
-	r0, r1, e1 := Syscall(SYS_PIPE, 0, 0, 0);
-	r = int(r0);
-	w = int(r1);
-	errno = int(e1);
-	return;
+	r0, r1, e1 := Syscall(SYS_PIPE, 0, 0, 0)
+	r = int(r0)
+	w = int(r1)
+	errno = int(e1)
+	return
 }
 
 func accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func bind(s int, addr uintptr, addrlen _Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))
+	errno = int(e1)
+	return
 }
 
 func connect(s int, addr uintptr, addrlen _Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))
+	errno = int(e1)
+	return
 }
 
 func socket(domain int, typ int, proto int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func setsockopt(s int, level int, name int, val uintptr, vallen int) (errno int) {
-	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)
+	errno = int(e1)
+	return
 }
 
 func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	errno = int(e1)
+	return
 }
 
 func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	errno = int(e1)
+	return
 }
 
 func Shutdown(s int, how int) (errno int) {
-	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)
+	errno = int(e1)
+	return
 }
 
 func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func sendto(s int, buf []byte, flags int, to uintptr, addrlen _Socklen) (errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))
+	errno = int(e1)
+	return
 }
 
 func kevent(kq int, change uintptr, nchange int, event uintptr, nevent int, timeout *Timespec) (n int, errno int) {
-	r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (errno int) {
-	var _p0 *_C_int;
+	var _p0 *_C_int
 	if len(mib) > 0 {
 		_p0 = &mib[0]
 	}
-	_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(unsafe.Pointer(_p0)), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(unsafe.Pointer(_p0)), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))
+	errno = int(e1)
+	return
 }
 
 func fcntl(fd int, cmd int, arg int) (val int, errno int) {
-	r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg));
-	val = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))
+	val = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Access(path string, flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func Adjtime(delta *Timeval, olddelta *Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)
+	errno = int(e1)
+	return
 }
 
 func Chdir(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Chflags(path string, flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func Chmod(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Chown(path string, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Chroot(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Close(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Dup(fd int) (nfd int, errno int) {
-	r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0);
-	nfd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)
+	nfd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Dup2(from int, to int) (errno int) {
-	_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)
+	errno = int(e1)
+	return
 }
 
 func Exchangedata(path1 string, path2 string, options int) (errno int) {
-	_, _, e1 := Syscall(SYS_EXCHANGEDATA, uintptr(unsafe.Pointer(StringBytePtr(path1))), uintptr(unsafe.Pointer(StringBytePtr(path2))), uintptr(options));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_EXCHANGEDATA, uintptr(unsafe.Pointer(StringBytePtr(path1))), uintptr(unsafe.Pointer(StringBytePtr(path2))), uintptr(options))
+	errno = int(e1)
+	return
 }
 
 func Exit(code int) {
-	Syscall(SYS_EXIT, uintptr(code), 0, 0);
-	return;
+	Syscall(SYS_EXIT, uintptr(code), 0, 0)
+	return
 }
 
 func Fchdir(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Fchflags(path string, flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func Fchmod(fd int, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Fchown(fd int, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Flock(fd int, how int) (errno int) {
-	_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)
+	errno = int(e1)
+	return
 }
 
 func Fpathconf(fd int, name int) (val int, errno int) {
-	r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0);
-	val = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)
+	val = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Fstat(fd int, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Fstatfs(fd int, stat *Statfs_t) (errno int) {
-	_, _, e1 := Syscall(SYS_FSTATFS64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSTATFS64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Fsync(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Ftruncate(fd int, length int64) (errno int) {
-	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length>>32));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length>>32))
+	errno = int(e1)
+	return
 }
 
 func Getdirentries(fd int, buf []byte, basep *uintptr) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall6(SYS_GETDIRENTRIES64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_GETDIRENTRIES64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getdtablesize() (size int) {
-	r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0);
-	size = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)
+	size = int(r0)
+	return
 }
 
 func Getegid() (egid int) {
-	r0, _, _ := Syscall(SYS_GETEGID, 0, 0, 0);
-	egid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETEGID, 0, 0, 0)
+	egid = int(r0)
+	return
 }
 
 func Geteuid() (uid int) {
-	r0, _, _ := Syscall(SYS_GETEUID, 0, 0, 0);
-	uid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETEUID, 0, 0, 0)
+	uid = int(r0)
+	return
 }
 
 func Getfsstat(buf []Statfs_t, flags int) (n int, errno int) {
-	var _p0 *Statfs_t;
+	var _p0 *Statfs_t
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_GETFSSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETFSSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getgid() (gid int) {
-	r0, _, _ := Syscall(SYS_GETGID, 0, 0, 0);
-	gid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETGID, 0, 0, 0)
+	gid = int(r0)
+	return
 }
 
 func Getpgid(pid int) (pgid int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0);
-	pgid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0)
+	pgid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getpgrp() (pgrp int) {
-	r0, _, _ := Syscall(SYS_GETPGRP, 0, 0, 0);
-	pgrp = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPGRP, 0, 0, 0)
+	pgrp = int(r0)
+	return
 }
 
 func Getpid() (pid int) {
-	r0, _, _ := Syscall(SYS_GETPID, 0, 0, 0);
-	pid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPID, 0, 0, 0)
+	pid = int(r0)
+	return
 }
 
 func Getppid() (ppid int) {
-	r0, _, _ := Syscall(SYS_GETPPID, 0, 0, 0);
-	ppid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPPID, 0, 0, 0)
+	ppid = int(r0)
+	return
 }
 
 func Getpriority(which int, who int) (prio int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0);
-	prio = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)
+	prio = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getrlimit(which int, lim *Rlimit) (errno int) {
-	_, _, e1 := Syscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)
+	errno = int(e1)
+	return
 }
 
 func Getrusage(who int, rusage *Rusage) (errno int) {
-	_, _, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)
+	errno = int(e1)
+	return
 }
 
 func Getsid(pid int) (sid int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETSID, uintptr(pid), 0, 0);
-	sid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETSID, uintptr(pid), 0, 0)
+	sid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getuid() (uid int) {
-	r0, _, _ := Syscall(SYS_GETUID, 0, 0, 0);
-	uid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETUID, 0, 0, 0)
+	uid = int(r0)
+	return
 }
 
 func Issetugid() (tainted bool) {
-	r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0);
-	tainted = bool(r0 != 0);
-	return;
+	r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)
+	tainted = bool(r0 != 0)
+	return
 }
 
 func Kill(pid int, signum int, posix int) (errno int) {
-	_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), uintptr(posix));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), uintptr(posix))
+	errno = int(e1)
+	return
 }
 
 func Kqueue() (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Lchown(path string, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Link(path string, link string) (errno int) {
-	_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0)
+	errno = int(e1)
+	return
 }
 
 func Listen(s int, backlog int) (errno int) {
-	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)
+	errno = int(e1)
+	return
 }
 
 func Lstat(path string, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Mkdir(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Mkfifo(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Mknod(path string, mode int, dev int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev))
+	errno = int(e1)
+	return
 }
 
 func Open(path string, mode int, perm int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Pathconf(path string, name int) (val int, errno int) {
-	r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(name), 0);
-	val = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(name), 0)
+	val = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Pread(fd int, p []byte, offset int64) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Read(fd int, p []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Readlink(path string, buf []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Rename(from string, to string) (errno int) {
-	_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(from))), uintptr(unsafe.Pointer(StringBytePtr(to))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(from))), uintptr(unsafe.Pointer(StringBytePtr(to))), 0)
+	errno = int(e1)
+	return
 }
 
 func Revoke(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Rmdir(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Seek(fd int, offset int64, whence int) (newoffset int64, errno int) {
-	r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(offset>>32), uintptr(whence), 0, 0);
-	newoffset = int64(int64(r1)<<32 | int64(r0));
-	errno = int(e1);
-	return;
+	r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(offset>>32), uintptr(whence), 0, 0)
+	newoffset = int64(int64(r1)<<32 | int64(r0))
+	errno = int(e1)
+	return
 }
 
 func Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (errno int) {
-	_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)
+	errno = int(e1)
+	return
 }
 
 func Setegid(egid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETEGID, uintptr(egid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETEGID, uintptr(egid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Seteuid(euid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETEUID, uintptr(euid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETEUID, uintptr(euid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setgid(gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETGID, uintptr(gid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETGID, uintptr(gid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setlogin(name string) (errno int) {
-	_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(StringBytePtr(name))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(StringBytePtr(name))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setpgid(pid int, pgid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)
+	errno = int(e1)
+	return
 }
 
 func Setpriority(which int, who int, prio int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))
+	errno = int(e1)
+	return
 }
 
 func Setprivexec(flag int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETPRIVEXEC, uintptr(flag), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETPRIVEXEC, uintptr(flag), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setregid(rgid int, egid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)
+	errno = int(e1)
+	return
 }
 
 func Setreuid(ruid int, euid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)
+	errno = int(e1)
+	return
 }
 
 func Setrlimit(which int, lim *Rlimit) (errno int) {
-	_, _, e1 := Syscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)
+	errno = int(e1)
+	return
 }
 
 func Setsid() (pid int, errno int) {
-	r0, _, e1 := Syscall(SYS_SETSID, 0, 0, 0);
-	pid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_SETSID, 0, 0, 0)
+	pid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Settimeofday(tp *Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setuid(uid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Stat(path string, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Statfs(path string, stat *Statfs_t) (errno int) {
-	_, _, e1 := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Symlink(path string, link string) (errno int) {
-	_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0)
+	errno = int(e1)
+	return
 }
 
 func Sync() (errno int) {
-	_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Truncate(path string, length int64) (errno int) {
-	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), uintptr(length>>32));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), uintptr(length>>32))
+	errno = int(e1)
+	return
 }
 
 func Umask(newmask int) (errno int) {
-	_, _, e1 := Syscall(SYS_UMASK, uintptr(newmask), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Undelete(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Unlink(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Unmount(path string, flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func Write(fd int, p []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func read(fd int, buf *byte, nbuf int) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func write(fd int, buf *byte, nbuf int) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func gettimeofday(tp *Timeval) (sec int32, usec int32, errno int) {
-	r0, r1, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0);
-	sec = int32(r0);
-	usec = int32(r1);
-	errno = int(e1);
-	return;
+	r0, r1, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)
+	sec = int32(r0)
+	usec = int32(r1)
+	errno = int(e1)
+	return
 }
diff --git a/src/pkg/syscall/zsyscall_darwin_amd64.go b/src/pkg/syscall/zsyscall_darwin_amd64.go
index 998f008314..6e25cf3813 100644
--- a/src/pkg/syscall/zsyscall_darwin_amd64.go
+++ b/src/pkg/syscall/zsyscall_darwin_amd64.go
@@ -6,676 +6,676 @@ package syscall
 import "unsafe"
 
 func getgroups(ngid int, gid *_Gid_t) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func setgroups(ngid int, gid *_Gid_t) (errno int) {
-	_, _, e1 := Syscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)
+	errno = int(e1)
+	return
 }
 
 func wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, errno int) {
-	r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0);
-	wpid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)
+	wpid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func pipe() (r int, w int, errno int) {
-	r0, r1, e1 := Syscall(SYS_PIPE, 0, 0, 0);
-	r = int(r0);
-	w = int(r1);
-	errno = int(e1);
-	return;
+	r0, r1, e1 := Syscall(SYS_PIPE, 0, 0, 0)
+	r = int(r0)
+	w = int(r1)
+	errno = int(e1)
+	return
 }
 
 func accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func bind(s int, addr uintptr, addrlen _Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))
+	errno = int(e1)
+	return
 }
 
 func connect(s int, addr uintptr, addrlen _Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))
+	errno = int(e1)
+	return
 }
 
 func socket(domain int, typ int, proto int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func setsockopt(s int, level int, name int, val uintptr, vallen int) (errno int) {
-	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)
+	errno = int(e1)
+	return
 }
 
 func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	errno = int(e1)
+	return
 }
 
 func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	errno = int(e1)
+	return
 }
 
 func Shutdown(s int, how int) (errno int) {
-	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)
+	errno = int(e1)
+	return
 }
 
 func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func sendto(s int, buf []byte, flags int, to uintptr, addrlen _Socklen) (errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))
+	errno = int(e1)
+	return
 }
 
 func kevent(kq int, change uintptr, nchange int, event uintptr, nevent int, timeout *Timespec) (n int, errno int) {
-	r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (errno int) {
-	var _p0 *_C_int;
+	var _p0 *_C_int
 	if len(mib) > 0 {
 		_p0 = &mib[0]
 	}
-	_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(unsafe.Pointer(_p0)), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(unsafe.Pointer(_p0)), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))
+	errno = int(e1)
+	return
 }
 
 func fcntl(fd int, cmd int, arg int) (val int, errno int) {
-	r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg));
-	val = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))
+	val = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Access(path string, flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func Adjtime(delta *Timeval, olddelta *Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)
+	errno = int(e1)
+	return
 }
 
 func Chdir(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Chflags(path string, flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func Chmod(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Chown(path string, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Chroot(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Close(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Dup(fd int) (nfd int, errno int) {
-	r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0);
-	nfd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)
+	nfd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Dup2(from int, to int) (errno int) {
-	_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)
+	errno = int(e1)
+	return
 }
 
 func Exchangedata(path1 string, path2 string, options int) (errno int) {
-	_, _, e1 := Syscall(SYS_EXCHANGEDATA, uintptr(unsafe.Pointer(StringBytePtr(path1))), uintptr(unsafe.Pointer(StringBytePtr(path2))), uintptr(options));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_EXCHANGEDATA, uintptr(unsafe.Pointer(StringBytePtr(path1))), uintptr(unsafe.Pointer(StringBytePtr(path2))), uintptr(options))
+	errno = int(e1)
+	return
 }
 
 func Exit(code int) {
-	Syscall(SYS_EXIT, uintptr(code), 0, 0);
-	return;
+	Syscall(SYS_EXIT, uintptr(code), 0, 0)
+	return
 }
 
 func Fchdir(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Fchflags(path string, flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func Fchmod(fd int, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Fchown(fd int, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Flock(fd int, how int) (errno int) {
-	_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)
+	errno = int(e1)
+	return
 }
 
 func Fpathconf(fd int, name int) (val int, errno int) {
-	r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0);
-	val = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)
+	val = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Fstat(fd int, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Fstatfs(fd int, stat *Statfs_t) (errno int) {
-	_, _, e1 := Syscall(SYS_FSTATFS64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSTATFS64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Fsync(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Ftruncate(fd int, length int64) (errno int) {
-	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)
+	errno = int(e1)
+	return
 }
 
 func Getdirentries(fd int, buf []byte, basep *uintptr) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall6(SYS_GETDIRENTRIES64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_GETDIRENTRIES64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getdtablesize() (size int) {
-	r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0);
-	size = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)
+	size = int(r0)
+	return
 }
 
 func Getegid() (egid int) {
-	r0, _, _ := Syscall(SYS_GETEGID, 0, 0, 0);
-	egid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETEGID, 0, 0, 0)
+	egid = int(r0)
+	return
 }
 
 func Geteuid() (uid int) {
-	r0, _, _ := Syscall(SYS_GETEUID, 0, 0, 0);
-	uid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETEUID, 0, 0, 0)
+	uid = int(r0)
+	return
 }
 
 func Getfsstat(buf []Statfs_t, flags int) (n int, errno int) {
-	var _p0 *Statfs_t;
+	var _p0 *Statfs_t
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_GETFSSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETFSSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getgid() (gid int) {
-	r0, _, _ := Syscall(SYS_GETGID, 0, 0, 0);
-	gid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETGID, 0, 0, 0)
+	gid = int(r0)
+	return
 }
 
 func Getpgid(pid int) (pgid int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0);
-	pgid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0)
+	pgid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getpgrp() (pgrp int) {
-	r0, _, _ := Syscall(SYS_GETPGRP, 0, 0, 0);
-	pgrp = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPGRP, 0, 0, 0)
+	pgrp = int(r0)
+	return
 }
 
 func Getpid() (pid int) {
-	r0, _, _ := Syscall(SYS_GETPID, 0, 0, 0);
-	pid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPID, 0, 0, 0)
+	pid = int(r0)
+	return
 }
 
 func Getppid() (ppid int) {
-	r0, _, _ := Syscall(SYS_GETPPID, 0, 0, 0);
-	ppid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPPID, 0, 0, 0)
+	ppid = int(r0)
+	return
 }
 
 func Getpriority(which int, who int) (prio int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0);
-	prio = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)
+	prio = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getrlimit(which int, lim *Rlimit) (errno int) {
-	_, _, e1 := Syscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)
+	errno = int(e1)
+	return
 }
 
 func Getrusage(who int, rusage *Rusage) (errno int) {
-	_, _, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)
+	errno = int(e1)
+	return
 }
 
 func Getsid(pid int) (sid int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETSID, uintptr(pid), 0, 0);
-	sid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETSID, uintptr(pid), 0, 0)
+	sid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getuid() (uid int) {
-	r0, _, _ := Syscall(SYS_GETUID, 0, 0, 0);
-	uid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETUID, 0, 0, 0)
+	uid = int(r0)
+	return
 }
 
 func Issetugid() (tainted bool) {
-	r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0);
-	tainted = bool(r0 != 0);
-	return;
+	r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)
+	tainted = bool(r0 != 0)
+	return
 }
 
 func Kill(pid int, signum int, posix int) (errno int) {
-	_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), uintptr(posix));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), uintptr(posix))
+	errno = int(e1)
+	return
 }
 
 func Kqueue() (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Lchown(path string, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Link(path string, link string) (errno int) {
-	_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0)
+	errno = int(e1)
+	return
 }
 
 func Listen(s int, backlog int) (errno int) {
-	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)
+	errno = int(e1)
+	return
 }
 
 func Lstat(path string, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Mkdir(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Mkfifo(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Mknod(path string, mode int, dev int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev))
+	errno = int(e1)
+	return
 }
 
 func Open(path string, mode int, perm int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Pathconf(path string, name int) (val int, errno int) {
-	r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(name), 0);
-	val = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(name), 0)
+	val = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Pread(fd int, p []byte, offset int64) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Read(fd int, p []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Readlink(path string, buf []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Rename(from string, to string) (errno int) {
-	_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(from))), uintptr(unsafe.Pointer(StringBytePtr(to))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(from))), uintptr(unsafe.Pointer(StringBytePtr(to))), 0)
+	errno = int(e1)
+	return
 }
 
 func Revoke(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Rmdir(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Seek(fd int, offset int64, whence int) (newoffset int64, errno int) {
-	r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence));
-	newoffset = int64(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))
+	newoffset = int64(r0)
+	errno = int(e1)
+	return
 }
 
 func Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (errno int) {
-	_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)
+	errno = int(e1)
+	return
 }
 
 func Setegid(egid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETEGID, uintptr(egid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETEGID, uintptr(egid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Seteuid(euid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETEUID, uintptr(euid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETEUID, uintptr(euid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setgid(gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETGID, uintptr(gid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETGID, uintptr(gid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setlogin(name string) (errno int) {
-	_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(StringBytePtr(name))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(StringBytePtr(name))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setpgid(pid int, pgid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)
+	errno = int(e1)
+	return
 }
 
 func Setpriority(which int, who int, prio int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))
+	errno = int(e1)
+	return
 }
 
 func Setprivexec(flag int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETPRIVEXEC, uintptr(flag), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETPRIVEXEC, uintptr(flag), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setregid(rgid int, egid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)
+	errno = int(e1)
+	return
 }
 
 func Setreuid(ruid int, euid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)
+	errno = int(e1)
+	return
 }
 
 func Setrlimit(which int, lim *Rlimit) (errno int) {
-	_, _, e1 := Syscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)
+	errno = int(e1)
+	return
 }
 
 func Setsid() (pid int, errno int) {
-	r0, _, e1 := Syscall(SYS_SETSID, 0, 0, 0);
-	pid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_SETSID, 0, 0, 0)
+	pid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Settimeofday(tp *Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setuid(uid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Stat(path string, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Statfs(path string, stat *Statfs_t) (errno int) {
-	_, _, e1 := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Symlink(path string, link string) (errno int) {
-	_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0)
+	errno = int(e1)
+	return
 }
 
 func Sync() (errno int) {
-	_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Truncate(path string, length int64) (errno int) {
-	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), 0)
+	errno = int(e1)
+	return
 }
 
 func Umask(newmask int) (errno int) {
-	_, _, e1 := Syscall(SYS_UMASK, uintptr(newmask), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Undelete(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Unlink(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Unmount(path string, flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func Write(fd int, p []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func read(fd int, buf *byte, nbuf int) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func write(fd int, buf *byte, nbuf int) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func gettimeofday(tp *Timeval) (sec int64, usec int32, errno int) {
-	r0, r1, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0);
-	sec = int64(r0);
-	usec = int32(r1);
-	errno = int(e1);
-	return;
+	r0, r1, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)
+	sec = int64(r0)
+	usec = int32(r1)
+	errno = int(e1)
+	return
 }
diff --git a/src/pkg/syscall/zsyscall_freebsd_386.go b/src/pkg/syscall/zsyscall_freebsd_386.go
index 055d12775e..99f23d0fc4 100644
--- a/src/pkg/syscall/zsyscall_freebsd_386.go
+++ b/src/pkg/syscall/zsyscall_freebsd_386.go
@@ -6,662 +6,662 @@ package syscall
 import "unsafe"
 
 func getgroups(ngid int, gid *_Gid_t) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func setgroups(ngid int, gid *_Gid_t) (errno int) {
-	_, _, e1 := Syscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)
+	errno = int(e1)
+	return
 }
 
 func wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, errno int) {
-	r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0);
-	wpid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)
+	wpid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func pipe() (r int, w int, errno int) {
-	r0, r1, e1 := Syscall(SYS_PIPE, 0, 0, 0);
-	r = int(r0);
-	w = int(r1);
-	errno = int(e1);
-	return;
+	r0, r1, e1 := Syscall(SYS_PIPE, 0, 0, 0)
+	r = int(r0)
+	w = int(r1)
+	errno = int(e1)
+	return
 }
 
 func accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func bind(s int, addr uintptr, addrlen _Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))
+	errno = int(e1)
+	return
 }
 
 func connect(s int, addr uintptr, addrlen _Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))
+	errno = int(e1)
+	return
 }
 
 func socket(domain int, typ int, proto int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func setsockopt(s int, level int, name int, val uintptr, vallen int) (errno int) {
-	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)
+	errno = int(e1)
+	return
 }
 
 func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	errno = int(e1)
+	return
 }
 
 func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	errno = int(e1)
+	return
 }
 
 func Shutdown(s int, how int) (errno int) {
-	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)
+	errno = int(e1)
+	return
 }
 
 func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func sendto(s int, buf []byte, flags int, to uintptr, addrlen _Socklen) (errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))
+	errno = int(e1)
+	return
 }
 
 func kevent(kq int, change uintptr, nchange int, event uintptr, nevent int, timeout *Timespec) (n int, errno int) {
-	r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (errno int) {
-	var _p0 *_C_int;
+	var _p0 *_C_int
 	if len(mib) > 0 {
 		_p0 = &mib[0]
 	}
-	_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(unsafe.Pointer(_p0)), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(unsafe.Pointer(_p0)), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))
+	errno = int(e1)
+	return
 }
 
 func fcntl(fd int, cmd int, arg int) (val int, errno int) {
-	r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg));
-	val = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))
+	val = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Access(path string, flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func Adjtime(delta *Timeval, olddelta *Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)
+	errno = int(e1)
+	return
 }
 
 func Chdir(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Chflags(path string, flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func Chmod(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Chown(path string, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Chroot(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Close(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Dup(fd int) (nfd int, errno int) {
-	r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0);
-	nfd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)
+	nfd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Dup2(from int, to int) (errno int) {
-	_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)
+	errno = int(e1)
+	return
 }
 
 func Exit(code int) {
-	Syscall(SYS_EXIT, uintptr(code), 0, 0);
-	return;
+	Syscall(SYS_EXIT, uintptr(code), 0, 0)
+	return
 }
 
 func Fchdir(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Fchflags(path string, flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func Fchmod(fd int, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Fchown(fd int, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Flock(fd int, how int) (errno int) {
-	_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)
+	errno = int(e1)
+	return
 }
 
 func Fpathconf(fd int, name int) (val int, errno int) {
-	r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0);
-	val = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)
+	val = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Fstat(fd int, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Fstatfs(fd int, stat *Statfs_t) (errno int) {
-	_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Fsync(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Ftruncate(fd int, length int64) (errno int) {
-	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length>>32));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length>>32))
+	errno = int(e1)
+	return
 }
 
 func Getdirentries(fd int, buf []byte, basep *uintptr) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall6(SYS_GETDIRENTRIES, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_GETDIRENTRIES, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getdtablesize() (size int) {
-	r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0);
-	size = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)
+	size = int(r0)
+	return
 }
 
 func Getegid() (egid int) {
-	r0, _, _ := Syscall(SYS_GETEGID, 0, 0, 0);
-	egid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETEGID, 0, 0, 0)
+	egid = int(r0)
+	return
 }
 
 func Geteuid() (uid int) {
-	r0, _, _ := Syscall(SYS_GETEUID, 0, 0, 0);
-	uid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETEUID, 0, 0, 0)
+	uid = int(r0)
+	return
 }
 
 func Getfsstat(buf []Statfs_t, flags int) (n int, errno int) {
-	var _p0 *Statfs_t;
+	var _p0 *Statfs_t
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_GETFSSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETFSSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getgid() (gid int) {
-	r0, _, _ := Syscall(SYS_GETGID, 0, 0, 0);
-	gid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETGID, 0, 0, 0)
+	gid = int(r0)
+	return
 }
 
 func Getpgid(pid int) (pgid int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0);
-	pgid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0)
+	pgid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getpgrp() (pgrp int) {
-	r0, _, _ := Syscall(SYS_GETPGRP, 0, 0, 0);
-	pgrp = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPGRP, 0, 0, 0)
+	pgrp = int(r0)
+	return
 }
 
 func Getpid() (pid int) {
-	r0, _, _ := Syscall(SYS_GETPID, 0, 0, 0);
-	pid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPID, 0, 0, 0)
+	pid = int(r0)
+	return
 }
 
 func Getppid() (ppid int) {
-	r0, _, _ := Syscall(SYS_GETPPID, 0, 0, 0);
-	ppid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPPID, 0, 0, 0)
+	ppid = int(r0)
+	return
 }
 
 func Getpriority(which int, who int) (prio int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0);
-	prio = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)
+	prio = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getrlimit(which int, lim *Rlimit) (errno int) {
-	_, _, e1 := Syscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)
+	errno = int(e1)
+	return
 }
 
 func Getrusage(who int, rusage *Rusage) (errno int) {
-	_, _, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)
+	errno = int(e1)
+	return
 }
 
 func Getsid(pid int) (sid int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETSID, uintptr(pid), 0, 0);
-	sid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETSID, uintptr(pid), 0, 0)
+	sid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Gettimeofday(tv *Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Getuid() (uid int) {
-	r0, _, _ := Syscall(SYS_GETUID, 0, 0, 0);
-	uid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETUID, 0, 0, 0)
+	uid = int(r0)
+	return
 }
 
 func Issetugid() (tainted bool) {
-	r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0);
-	tainted = bool(r0 != 0);
-	return;
+	r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)
+	tainted = bool(r0 != 0)
+	return
 }
 
 func Kill(pid int, signum int, posix int) (errno int) {
-	_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), uintptr(posix));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), uintptr(posix))
+	errno = int(e1)
+	return
 }
 
 func Kqueue() (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Lchown(path string, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Link(path string, link string) (errno int) {
-	_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0)
+	errno = int(e1)
+	return
 }
 
 func Listen(s int, backlog int) (errno int) {
-	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)
+	errno = int(e1)
+	return
 }
 
 func Lstat(path string, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Mkdir(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Mkfifo(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Mknod(path string, mode int, dev int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev))
+	errno = int(e1)
+	return
 }
 
 func Open(path string, mode int, perm int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Pathconf(path string, name int) (val int, errno int) {
-	r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(name), 0);
-	val = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(name), 0)
+	val = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Pread(fd int, p []byte, offset int64) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Read(fd int, p []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Readlink(path string, buf []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Rename(from string, to string) (errno int) {
-	_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(from))), uintptr(unsafe.Pointer(StringBytePtr(to))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(from))), uintptr(unsafe.Pointer(StringBytePtr(to))), 0)
+	errno = int(e1)
+	return
 }
 
 func Revoke(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Rmdir(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Seek(fd int, offset int64, whence int) (newoffset int64, errno int) {
-	r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(offset>>32), uintptr(whence), 0, 0);
-	newoffset = int64(int64(r1)<<32 | int64(r0));
-	errno = int(e1);
-	return;
+	r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(offset>>32), uintptr(whence), 0, 0)
+	newoffset = int64(int64(r1)<<32 | int64(r0))
+	errno = int(e1)
+	return
 }
 
 func Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (errno int) {
-	_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)
+	errno = int(e1)
+	return
 }
 
 func Setegid(egid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETEGID, uintptr(egid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETEGID, uintptr(egid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Seteuid(euid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETEUID, uintptr(euid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETEUID, uintptr(euid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setgid(gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETGID, uintptr(gid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETGID, uintptr(gid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setlogin(name string) (errno int) {
-	_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(StringBytePtr(name))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(StringBytePtr(name))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setpgid(pid int, pgid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)
+	errno = int(e1)
+	return
 }
 
 func Setpriority(which int, who int, prio int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))
+	errno = int(e1)
+	return
 }
 
 func Setregid(rgid int, egid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)
+	errno = int(e1)
+	return
 }
 
 func Setreuid(ruid int, euid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)
+	errno = int(e1)
+	return
 }
 
 func Setrlimit(which int, lim *Rlimit) (errno int) {
-	_, _, e1 := Syscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)
+	errno = int(e1)
+	return
 }
 
 func Setsid() (pid int, errno int) {
-	r0, _, e1 := Syscall(SYS_SETSID, 0, 0, 0);
-	pid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_SETSID, 0, 0, 0)
+	pid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Settimeofday(tp *Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setuid(uid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Stat(path string, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Statfs(path string, stat *Statfs_t) (errno int) {
-	_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Symlink(path string, link string) (errno int) {
-	_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0)
+	errno = int(e1)
+	return
 }
 
 func Sync() (errno int) {
-	_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Truncate(path string, length int64) (errno int) {
-	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), uintptr(length>>32));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), uintptr(length>>32))
+	errno = int(e1)
+	return
 }
 
 func Umask(newmask int) (errno int) {
-	_, _, e1 := Syscall(SYS_UMASK, uintptr(newmask), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Undelete(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Unlink(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Unmount(path string, flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func Write(fd int, p []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func read(fd int, buf *byte, nbuf int) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func write(fd int, buf *byte, nbuf int) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
diff --git a/src/pkg/syscall/zsyscall_freebsd_amd64.go b/src/pkg/syscall/zsyscall_freebsd_amd64.go
index e619637d98..a670ce1492 100644
--- a/src/pkg/syscall/zsyscall_freebsd_amd64.go
+++ b/src/pkg/syscall/zsyscall_freebsd_amd64.go
@@ -6,662 +6,662 @@ package syscall
 import "unsafe"
 
 func getgroups(ngid int, gid *_Gid_t) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func setgroups(ngid int, gid *_Gid_t) (errno int) {
-	_, _, e1 := Syscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)
+	errno = int(e1)
+	return
 }
 
 func wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, errno int) {
-	r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0);
-	wpid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)
+	wpid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func pipe() (r int, w int, errno int) {
-	r0, r1, e1 := Syscall(SYS_PIPE, 0, 0, 0);
-	r = int(r0);
-	w = int(r1);
-	errno = int(e1);
-	return;
+	r0, r1, e1 := Syscall(SYS_PIPE, 0, 0, 0)
+	r = int(r0)
+	w = int(r1)
+	errno = int(e1)
+	return
 }
 
 func accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func bind(s int, addr uintptr, addrlen _Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))
+	errno = int(e1)
+	return
 }
 
 func connect(s int, addr uintptr, addrlen _Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))
+	errno = int(e1)
+	return
 }
 
 func socket(domain int, typ int, proto int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func setsockopt(s int, level int, name int, val uintptr, vallen int) (errno int) {
-	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)
+	errno = int(e1)
+	return
 }
 
 func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	errno = int(e1)
+	return
 }
 
 func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	errno = int(e1)
+	return
 }
 
 func Shutdown(s int, how int) (errno int) {
-	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)
+	errno = int(e1)
+	return
 }
 
 func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func sendto(s int, buf []byte, flags int, to uintptr, addrlen _Socklen) (errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))
+	errno = int(e1)
+	return
 }
 
 func kevent(kq int, change uintptr, nchange int, event uintptr, nevent int, timeout *Timespec) (n int, errno int) {
-	r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (errno int) {
-	var _p0 *_C_int;
+	var _p0 *_C_int
 	if len(mib) > 0 {
 		_p0 = &mib[0]
 	}
-	_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(unsafe.Pointer(_p0)), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(unsafe.Pointer(_p0)), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))
+	errno = int(e1)
+	return
 }
 
 func fcntl(fd int, cmd int, arg int) (val int, errno int) {
-	r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg));
-	val = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))
+	val = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Access(path string, flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func Adjtime(delta *Timeval, olddelta *Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)
+	errno = int(e1)
+	return
 }
 
 func Chdir(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Chflags(path string, flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func Chmod(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Chown(path string, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Chroot(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Close(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Dup(fd int) (nfd int, errno int) {
-	r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0);
-	nfd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)
+	nfd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Dup2(from int, to int) (errno int) {
-	_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)
+	errno = int(e1)
+	return
 }
 
 func Exit(code int) {
-	Syscall(SYS_EXIT, uintptr(code), 0, 0);
-	return;
+	Syscall(SYS_EXIT, uintptr(code), 0, 0)
+	return
 }
 
 func Fchdir(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Fchflags(path string, flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func Fchmod(fd int, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Fchown(fd int, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Flock(fd int, how int) (errno int) {
-	_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)
+	errno = int(e1)
+	return
 }
 
 func Fpathconf(fd int, name int) (val int, errno int) {
-	r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0);
-	val = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)
+	val = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Fstat(fd int, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Fstatfs(fd int, stat *Statfs_t) (errno int) {
-	_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Fsync(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Ftruncate(fd int, length int64) (errno int) {
-	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)
+	errno = int(e1)
+	return
 }
 
 func Getdirentries(fd int, buf []byte, basep *uintptr) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall6(SYS_GETDIRENTRIES, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_GETDIRENTRIES, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getdtablesize() (size int) {
-	r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0);
-	size = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)
+	size = int(r0)
+	return
 }
 
 func Getegid() (egid int) {
-	r0, _, _ := Syscall(SYS_GETEGID, 0, 0, 0);
-	egid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETEGID, 0, 0, 0)
+	egid = int(r0)
+	return
 }
 
 func Geteuid() (uid int) {
-	r0, _, _ := Syscall(SYS_GETEUID, 0, 0, 0);
-	uid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETEUID, 0, 0, 0)
+	uid = int(r0)
+	return
 }
 
 func Getfsstat(buf []Statfs_t, flags int) (n int, errno int) {
-	var _p0 *Statfs_t;
+	var _p0 *Statfs_t
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_GETFSSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETFSSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getgid() (gid int) {
-	r0, _, _ := Syscall(SYS_GETGID, 0, 0, 0);
-	gid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETGID, 0, 0, 0)
+	gid = int(r0)
+	return
 }
 
 func Getpgid(pid int) (pgid int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0);
-	pgid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0)
+	pgid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getpgrp() (pgrp int) {
-	r0, _, _ := Syscall(SYS_GETPGRP, 0, 0, 0);
-	pgrp = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPGRP, 0, 0, 0)
+	pgrp = int(r0)
+	return
 }
 
 func Getpid() (pid int) {
-	r0, _, _ := Syscall(SYS_GETPID, 0, 0, 0);
-	pid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPID, 0, 0, 0)
+	pid = int(r0)
+	return
 }
 
 func Getppid() (ppid int) {
-	r0, _, _ := Syscall(SYS_GETPPID, 0, 0, 0);
-	ppid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPPID, 0, 0, 0)
+	ppid = int(r0)
+	return
 }
 
 func Getpriority(which int, who int) (prio int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0);
-	prio = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)
+	prio = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getrlimit(which int, lim *Rlimit) (errno int) {
-	_, _, e1 := Syscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)
+	errno = int(e1)
+	return
 }
 
 func Getrusage(who int, rusage *Rusage) (errno int) {
-	_, _, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)
+	errno = int(e1)
+	return
 }
 
 func Getsid(pid int) (sid int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETSID, uintptr(pid), 0, 0);
-	sid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETSID, uintptr(pid), 0, 0)
+	sid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Gettimeofday(tv *Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Getuid() (uid int) {
-	r0, _, _ := Syscall(SYS_GETUID, 0, 0, 0);
-	uid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETUID, 0, 0, 0)
+	uid = int(r0)
+	return
 }
 
 func Issetugid() (tainted bool) {
-	r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0);
-	tainted = bool(r0 != 0);
-	return;
+	r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)
+	tainted = bool(r0 != 0)
+	return
 }
 
 func Kill(pid int, signum int, posix int) (errno int) {
-	_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), uintptr(posix));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), uintptr(posix))
+	errno = int(e1)
+	return
 }
 
 func Kqueue() (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Lchown(path string, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Link(path string, link string) (errno int) {
-	_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0)
+	errno = int(e1)
+	return
 }
 
 func Listen(s int, backlog int) (errno int) {
-	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)
+	errno = int(e1)
+	return
 }
 
 func Lstat(path string, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Mkdir(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Mkfifo(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Mknod(path string, mode int, dev int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev))
+	errno = int(e1)
+	return
 }
 
 func Open(path string, mode int, perm int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Pathconf(path string, name int) (val int, errno int) {
-	r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(name), 0);
-	val = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(name), 0)
+	val = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Pread(fd int, p []byte, offset int64) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Read(fd int, p []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Readlink(path string, buf []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Rename(from string, to string) (errno int) {
-	_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(from))), uintptr(unsafe.Pointer(StringBytePtr(to))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(from))), uintptr(unsafe.Pointer(StringBytePtr(to))), 0)
+	errno = int(e1)
+	return
 }
 
 func Revoke(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Rmdir(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Seek(fd int, offset int64, whence int) (newoffset int64, errno int) {
-	r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence));
-	newoffset = int64(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))
+	newoffset = int64(r0)
+	errno = int(e1)
+	return
 }
 
 func Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (errno int) {
-	_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)
+	errno = int(e1)
+	return
 }
 
 func Setegid(egid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETEGID, uintptr(egid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETEGID, uintptr(egid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Seteuid(euid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETEUID, uintptr(euid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETEUID, uintptr(euid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setgid(gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETGID, uintptr(gid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETGID, uintptr(gid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setlogin(name string) (errno int) {
-	_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(StringBytePtr(name))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(StringBytePtr(name))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setpgid(pid int, pgid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)
+	errno = int(e1)
+	return
 }
 
 func Setpriority(which int, who int, prio int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))
+	errno = int(e1)
+	return
 }
 
 func Setregid(rgid int, egid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)
+	errno = int(e1)
+	return
 }
 
 func Setreuid(ruid int, euid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)
+	errno = int(e1)
+	return
 }
 
 func Setrlimit(which int, lim *Rlimit) (errno int) {
-	_, _, e1 := Syscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)
+	errno = int(e1)
+	return
 }
 
 func Setsid() (pid int, errno int) {
-	r0, _, e1 := Syscall(SYS_SETSID, 0, 0, 0);
-	pid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_SETSID, 0, 0, 0)
+	pid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Settimeofday(tp *Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setuid(uid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Stat(path string, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Statfs(path string, stat *Statfs_t) (errno int) {
-	_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Symlink(path string, link string) (errno int) {
-	_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(StringBytePtr(link))), 0)
+	errno = int(e1)
+	return
 }
 
 func Sync() (errno int) {
-	_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Truncate(path string, length int64) (errno int) {
-	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), 0)
+	errno = int(e1)
+	return
 }
 
 func Umask(newmask int) (errno int) {
-	_, _, e1 := Syscall(SYS_UMASK, uintptr(newmask), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Undelete(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Unlink(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Unmount(path string, flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func Write(fd int, p []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func read(fd int, buf *byte, nbuf int) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func write(fd int, buf *byte, nbuf int) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
diff --git a/src/pkg/syscall/zsyscall_linux_386.go b/src/pkg/syscall/zsyscall_linux_386.go
index e7019b63e7..519b52f0ed 100644
--- a/src/pkg/syscall/zsyscall_linux_386.go
+++ b/src/pkg/syscall/zsyscall_linux_386.go
@@ -6,718 +6,718 @@ package syscall
 import "unsafe"
 
 func pipe(p *[2]_C_int) (errno int) {
-	_, _, e1 := Syscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func utimes(path string, times *[2]Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(times)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(times)), 0)
+	errno = int(e1)
+	return
 }
 
 func futimesat(dirfd int, path string, times *[2]Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(times)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(times)))
+	errno = int(e1)
+	return
 }
 
 func Getcwd(buf []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_GETCWD, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETCWD, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, errno int) {
-	r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0);
-	wpid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)
+	wpid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func ptrace(request int, pid int, addr uintptr, data uintptr) (errno int) {
-	_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Access(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Acct(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Adjtimex(buf *Timex) (state int, errno int) {
-	r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0);
-	state = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)
+	state = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Chdir(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Chmod(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Chroot(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Close(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Creat(path string, mode int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_CREAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_CREAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Dup(oldfd int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Dup2(oldfd int, newfd int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func EpollCreate(size int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func EpollCtl(epfd int, op int, fd int, event *EpollEvent) (errno int) {
-	_, _, e1 := Syscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func EpollWait(epfd int, events []EpollEvent, msec int) (n int, errno int) {
-	var _p0 *EpollEvent;
+	var _p0 *EpollEvent
 	if len(events) > 0 {
 		_p0 = &events[0]
 	}
-	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(unsafe.Pointer(_p0)), uintptr(len(events)), uintptr(msec), 0, 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(unsafe.Pointer(_p0)), uintptr(len(events)), uintptr(msec), 0, 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Exit(code int) {
-	Syscall(SYS_EXIT_GROUP, uintptr(code), 0, 0);
-	return;
+	Syscall(SYS_EXIT_GROUP, uintptr(code), 0, 0)
+	return
 }
 
 func Faccessat(dirfd int, path string, mode int, flags int) (errno int) {
-	_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(flags), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(flags), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Fallocate(fd int, mode int, off int64, len int64) (errno int) {
-	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(off>>32), uintptr(len), uintptr(len>>32));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(off>>32), uintptr(len), uintptr(len>>32))
+	errno = int(e1)
+	return
 }
 
 func Fchdir(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Fchmod(fd int, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Fchmodat(dirfd int, path string, mode int, flags int) (errno int) {
-	_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(flags), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(flags), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Fchownat(dirfd int, path string, uid int, gid int, flags int) (errno int) {
-	_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func fcntl(fd int, cmd int, arg int) (val int, errno int) {
-	r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg));
-	val = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))
+	val = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Fdatasync(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Fsync(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Ftruncate(fd int, length int64) (errno int) {
-	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length>>32));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length>>32))
+	errno = int(e1)
+	return
 }
 
 func Getdents(fd int, buf []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getpgid(pid int) (pgid int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0);
-	pgid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0)
+	pgid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getpgrp() (pid int) {
-	r0, _, _ := Syscall(SYS_GETPGRP, 0, 0, 0);
-	pid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPGRP, 0, 0, 0)
+	pid = int(r0)
+	return
 }
 
 func Getpid() (pid int) {
-	r0, _, _ := Syscall(SYS_GETPID, 0, 0, 0);
-	pid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPID, 0, 0, 0)
+	pid = int(r0)
+	return
 }
 
 func Getppid() (ppid int) {
-	r0, _, _ := Syscall(SYS_GETPPID, 0, 0, 0);
-	ppid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPPID, 0, 0, 0)
+	ppid = int(r0)
+	return
 }
 
 func Getrlimit(resource int, rlim *Rlimit) (errno int) {
-	_, _, e1 := Syscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)
+	errno = int(e1)
+	return
 }
 
 func Getrusage(who int, rusage *Rusage) (errno int) {
-	_, _, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)
+	errno = int(e1)
+	return
 }
 
 func Gettid() (tid int) {
-	r0, _, _ := Syscall(SYS_GETTID, 0, 0, 0);
-	tid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETTID, 0, 0, 0)
+	tid = int(r0)
+	return
 }
 
 func Gettimeofday(tv *Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Kill(pid int, sig int) (errno int) {
-	_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(sig), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)
+	errno = int(e1)
+	return
 }
 
 func Klogctl(typ int, buf []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Link(oldpath string, newpath string) (errno int) {
-	_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0)
+	errno = int(e1)
+	return
 }
 
 func Mkdir(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Mkdirat(dirfd int, path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode))
+	errno = int(e1)
+	return
 }
 
 func Mknod(path string, mode int, dev int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev))
+	errno = int(e1)
+	return
 }
 
 func Mknodat(dirfd int, path string, mode int, dev int) (errno int) {
-	_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Nanosleep(time *Timespec, leftover *Timespec) (errno int) {
-	_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)
+	errno = int(e1)
+	return
 }
 
 func Open(path string, mode int, perm int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Openat(dirfd int, path string, flags int, mode int) (fd int, errno int) {
-	r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), uintptr(mode), 0, 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), uintptr(mode), 0, 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Pause() (errno int) {
-	_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)
+	errno = int(e1)
+	return
 }
 
 func PivotRoot(newroot string, putold string) (errno int) {
-	_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(StringBytePtr(newroot))), uintptr(unsafe.Pointer(StringBytePtr(putold))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(StringBytePtr(newroot))), uintptr(unsafe.Pointer(StringBytePtr(putold))), 0)
+	errno = int(e1)
+	return
 }
 
 func Pread(fd int, p []byte, offset int64) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Read(fd int, p []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Readlink(path string, buf []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Rename(oldpath string, newpath string) (errno int) {
-	_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0)
+	errno = int(e1)
+	return
 }
 
 func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (errno int) {
-	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(newdirfd), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(newdirfd), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Rmdir(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setdomainname(p []byte) (errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0)
+	errno = int(e1)
+	return
 }
 
 func Sethostname(p []byte) (errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0)
+	errno = int(e1)
+	return
 }
 
 func Setpgid(pid int, pgid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)
+	errno = int(e1)
+	return
 }
 
 func Setrlimit(resource int, rlim *Rlimit) (errno int) {
-	_, _, e1 := Syscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)
+	errno = int(e1)
+	return
 }
 
 func Setsid() (pid int) {
-	r0, _, _ := Syscall(SYS_SETSID, 0, 0, 0);
-	pid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_SETSID, 0, 0, 0)
+	pid = int(r0)
+	return
 }
 
 func Settimeofday(tv *Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setuid(uid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, errno int) {
-	r0, r1, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags));
-	n = int64(int64(r1)<<32 | int64(r0));
-	errno = int(e1);
-	return;
+	r0, r1, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))
+	n = int64(int64(r1)<<32 | int64(r0))
+	errno = int(e1)
+	return
 }
 
 func Symlink(oldpath string, newpath string) (errno int) {
-	_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0)
+	errno = int(e1)
+	return
 }
 
 func Sync() {
-	Syscall(SYS_SYNC, 0, 0, 0);
-	return;
+	Syscall(SYS_SYNC, 0, 0, 0)
+	return
 }
 
 func Sysinfo(info *Sysinfo_t) (errno int) {
-	_, _, e1 := Syscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Tee(rfd int, wfd int, len int, flags int) (n int64, errno int) {
-	r0, r1, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0);
-	n = int64(int64(r1)<<32 | int64(r0));
-	errno = int(e1);
-	return;
+	r0, r1, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)
+	n = int64(int64(r1)<<32 | int64(r0))
+	errno = int(e1)
+	return
 }
 
 func Tgkill(tgid int, tid int, sig int) (errno int) {
-	_, _, e1 := Syscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))
+	errno = int(e1)
+	return
 }
 
 func Time(t *Time_t) (tt Time_t, errno int) {
-	r0, _, e1 := Syscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0);
-	tt = Time_t(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0)
+	tt = Time_t(r0)
+	errno = int(e1)
+	return
 }
 
 func Times(tms *Tms) (ticks uintptr, errno int) {
-	r0, _, e1 := Syscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0);
-	ticks = uintptr(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)
+	ticks = uintptr(r0)
+	errno = int(e1)
+	return
 }
 
 func Truncate(path string, length int64) (errno int) {
-	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), uintptr(length>>32));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), uintptr(length>>32))
+	errno = int(e1)
+	return
 }
 
 func Umask(mask int) (oldmask int) {
-	r0, _, _ := Syscall(SYS_UMASK, uintptr(mask), 0, 0);
-	oldmask = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_UMASK, uintptr(mask), 0, 0)
+	oldmask = int(r0)
+	return
 }
 
 func Uname(buf *Utsname) (errno int) {
-	_, _, e1 := Syscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Unlink(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Unlinkat(dirfd int, path string) (errno int) {
-	_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), 0)
+	errno = int(e1)
+	return
 }
 
 func Unshare(flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Ustat(dev int, ubuf *Ustat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)
+	errno = int(e1)
+	return
 }
 
 func Utime(path string, buf *Utimbuf) (errno int) {
-	_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(buf)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(buf)), 0)
+	errno = int(e1)
+	return
 }
 
 func Write(fd int, p []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func exitThread(code int) (errno int) {
-	_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func read(fd int, p *byte, np int) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func write(fd int, p *byte, np int) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Chown(path string, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHOWN32, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHOWN32, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Fchown(fd int, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHOWN32, uintptr(fd), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHOWN32, uintptr(fd), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Fstat(fd int, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Getegid() (egid int) {
-	r0, _, _ := Syscall(SYS_GETEGID32, 0, 0, 0);
-	egid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETEGID32, 0, 0, 0)
+	egid = int(r0)
+	return
 }
 
 func Geteuid() (euid int) {
-	r0, _, _ := Syscall(SYS_GETEUID32, 0, 0, 0);
-	euid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETEUID32, 0, 0, 0)
+	euid = int(r0)
+	return
 }
 
 func Getgid() (gid int) {
-	r0, _, _ := Syscall(SYS_GETGID32, 0, 0, 0);
-	gid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETGID32, 0, 0, 0)
+	gid = int(r0)
+	return
 }
 
 func Getuid() (uid int) {
-	r0, _, _ := Syscall(SYS_GETUID32, 0, 0, 0);
-	uid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETUID32, 0, 0, 0)
+	uid = int(r0)
+	return
 }
 
 func Ioperm(from int, num int, on int) (errno int) {
-	_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on))
+	errno = int(e1)
+	return
 }
 
 func Iopl(level int) (errno int) {
-	_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Lchown(path string, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_LCHOWN32, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LCHOWN32, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Lstat(path string, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Setfsgid(gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETFSGID32, uintptr(gid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETFSGID32, uintptr(gid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setfsuid(uid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETFSUID32, uintptr(uid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETFSUID32, uintptr(uid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setgid(gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETGID32, uintptr(gid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETGID32, uintptr(gid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setregid(rgid int, egid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETREGID32, uintptr(rgid), uintptr(egid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETREGID32, uintptr(rgid), uintptr(egid), 0)
+	errno = int(e1)
+	return
 }
 
 func Setresgid(rgid int, egid int, sgid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETRESGID32, uintptr(rgid), uintptr(egid), uintptr(sgid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETRESGID32, uintptr(rgid), uintptr(egid), uintptr(sgid))
+	errno = int(e1)
+	return
 }
 
 func Setresuid(ruid int, euid int, suid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETRESUID32, uintptr(ruid), uintptr(euid), uintptr(suid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETRESUID32, uintptr(ruid), uintptr(euid), uintptr(suid))
+	errno = int(e1)
+	return
 }
 
 func Setreuid(ruid int, euid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETREUID32, uintptr(ruid), uintptr(euid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETREUID32, uintptr(ruid), uintptr(euid), 0)
+	errno = int(e1)
+	return
 }
 
 func Stat(path string, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func SyncFileRange(fd int, off int64, n int64, flags int) (errno int) {
-	_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(off>>32), uintptr(n), uintptr(n>>32), uintptr(flags));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(off>>32), uintptr(n), uintptr(n>>32), uintptr(flags))
+	errno = int(e1)
+	return
 }
 
 func getgroups(n int, list *_Gid_t) (nn int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0);
-	nn = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
+	nn = int(r0)
+	errno = int(e1)
+	return
 }
 
 func setgroups(n int, list *_Gid_t) (errno int) {
-	_, _, e1 := Syscall(SYS_SETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
+	errno = int(e1)
+	return
 }
 
 func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, errno int) {
-	r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
diff --git a/src/pkg/syscall/zsyscall_linux_amd64.go b/src/pkg/syscall/zsyscall_linux_amd64.go
index 15ccf3bbee..8eba799452 100644
--- a/src/pkg/syscall/zsyscall_linux_amd64.go
+++ b/src/pkg/syscall/zsyscall_linux_amd64.go
@@ -6,814 +6,814 @@ package syscall
 import "unsafe"
 
 func pipe(p *[2]_C_int) (errno int) {
-	_, _, e1 := Syscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func utimes(path string, times *[2]Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(times)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(times)), 0)
+	errno = int(e1)
+	return
 }
 
 func futimesat(dirfd int, path string, times *[2]Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(times)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(times)))
+	errno = int(e1)
+	return
 }
 
 func Getcwd(buf []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_GETCWD, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETCWD, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, errno int) {
-	r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0);
-	wpid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)
+	wpid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func ptrace(request int, pid int, addr uintptr, data uintptr) (errno int) {
-	_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Access(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Acct(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Adjtimex(buf *Timex) (state int, errno int) {
-	r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0);
-	state = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)
+	state = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Chdir(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Chmod(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Chroot(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Close(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Creat(path string, mode int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_CREAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_CREAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Dup(oldfd int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Dup2(oldfd int, newfd int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func EpollCreate(size int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func EpollCtl(epfd int, op int, fd int, event *EpollEvent) (errno int) {
-	_, _, e1 := Syscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func EpollWait(epfd int, events []EpollEvent, msec int) (n int, errno int) {
-	var _p0 *EpollEvent;
+	var _p0 *EpollEvent
 	if len(events) > 0 {
 		_p0 = &events[0]
 	}
-	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(unsafe.Pointer(_p0)), uintptr(len(events)), uintptr(msec), 0, 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(unsafe.Pointer(_p0)), uintptr(len(events)), uintptr(msec), 0, 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Exit(code int) {
-	Syscall(SYS_EXIT_GROUP, uintptr(code), 0, 0);
-	return;
+	Syscall(SYS_EXIT_GROUP, uintptr(code), 0, 0)
+	return
 }
 
 func Faccessat(dirfd int, path string, mode int, flags int) (errno int) {
-	_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(flags), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(flags), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Fallocate(fd int, mode int, off int64, len int64) (errno int) {
-	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Fchdir(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Fchmod(fd int, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Fchmodat(dirfd int, path string, mode int, flags int) (errno int) {
-	_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(flags), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(flags), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Fchownat(dirfd int, path string, uid int, gid int, flags int) (errno int) {
-	_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func fcntl(fd int, cmd int, arg int) (val int, errno int) {
-	r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg));
-	val = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))
+	val = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Fdatasync(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Fsync(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Ftruncate(fd int, length int64) (errno int) {
-	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)
+	errno = int(e1)
+	return
 }
 
 func Getdents(fd int, buf []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getpgid(pid int) (pgid int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0);
-	pgid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0)
+	pgid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getpgrp() (pid int) {
-	r0, _, _ := Syscall(SYS_GETPGRP, 0, 0, 0);
-	pid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPGRP, 0, 0, 0)
+	pid = int(r0)
+	return
 }
 
 func Getpid() (pid int) {
-	r0, _, _ := Syscall(SYS_GETPID, 0, 0, 0);
-	pid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPID, 0, 0, 0)
+	pid = int(r0)
+	return
 }
 
 func Getppid() (ppid int) {
-	r0, _, _ := Syscall(SYS_GETPPID, 0, 0, 0);
-	ppid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPPID, 0, 0, 0)
+	ppid = int(r0)
+	return
 }
 
 func Getrlimit(resource int, rlim *Rlimit) (errno int) {
-	_, _, e1 := Syscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)
+	errno = int(e1)
+	return
 }
 
 func Getrusage(who int, rusage *Rusage) (errno int) {
-	_, _, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)
+	errno = int(e1)
+	return
 }
 
 func Gettid() (tid int) {
-	r0, _, _ := Syscall(SYS_GETTID, 0, 0, 0);
-	tid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETTID, 0, 0, 0)
+	tid = int(r0)
+	return
 }
 
 func Gettimeofday(tv *Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Kill(pid int, sig int) (errno int) {
-	_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(sig), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)
+	errno = int(e1)
+	return
 }
 
 func Klogctl(typ int, buf []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Link(oldpath string, newpath string) (errno int) {
-	_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0)
+	errno = int(e1)
+	return
 }
 
 func Mkdir(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Mkdirat(dirfd int, path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode))
+	errno = int(e1)
+	return
 }
 
 func Mknod(path string, mode int, dev int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev))
+	errno = int(e1)
+	return
 }
 
 func Mknodat(dirfd int, path string, mode int, dev int) (errno int) {
-	_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Nanosleep(time *Timespec, leftover *Timespec) (errno int) {
-	_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)
+	errno = int(e1)
+	return
 }
 
 func Open(path string, mode int, perm int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Openat(dirfd int, path string, flags int, mode int) (fd int, errno int) {
-	r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), uintptr(mode), 0, 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), uintptr(mode), 0, 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Pause() (errno int) {
-	_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)
+	errno = int(e1)
+	return
 }
 
 func PivotRoot(newroot string, putold string) (errno int) {
-	_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(StringBytePtr(newroot))), uintptr(unsafe.Pointer(StringBytePtr(putold))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(StringBytePtr(newroot))), uintptr(unsafe.Pointer(StringBytePtr(putold))), 0)
+	errno = int(e1)
+	return
 }
 
 func Pread(fd int, p []byte, offset int64) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Read(fd int, p []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Readlink(path string, buf []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Rename(oldpath string, newpath string) (errno int) {
-	_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0)
+	errno = int(e1)
+	return
 }
 
 func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (errno int) {
-	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(newdirfd), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(newdirfd), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Rmdir(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setdomainname(p []byte) (errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0)
+	errno = int(e1)
+	return
 }
 
 func Sethostname(p []byte) (errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0)
+	errno = int(e1)
+	return
 }
 
 func Setpgid(pid int, pgid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)
+	errno = int(e1)
+	return
 }
 
 func Setrlimit(resource int, rlim *Rlimit) (errno int) {
-	_, _, e1 := Syscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)
+	errno = int(e1)
+	return
 }
 
 func Setsid() (pid int) {
-	r0, _, _ := Syscall(SYS_SETSID, 0, 0, 0);
-	pid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_SETSID, 0, 0, 0)
+	pid = int(r0)
+	return
 }
 
 func Settimeofday(tv *Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setuid(uid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, errno int) {
-	r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags));
-	n = int64(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))
+	n = int64(r0)
+	errno = int(e1)
+	return
 }
 
 func Symlink(oldpath string, newpath string) (errno int) {
-	_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0)
+	errno = int(e1)
+	return
 }
 
 func Sync() {
-	Syscall(SYS_SYNC, 0, 0, 0);
-	return;
+	Syscall(SYS_SYNC, 0, 0, 0)
+	return
 }
 
 func Sysinfo(info *Sysinfo_t) (errno int) {
-	_, _, e1 := Syscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Tee(rfd int, wfd int, len int, flags int) (n int64, errno int) {
-	r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0);
-	n = int64(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)
+	n = int64(r0)
+	errno = int(e1)
+	return
 }
 
 func Tgkill(tgid int, tid int, sig int) (errno int) {
-	_, _, e1 := Syscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))
+	errno = int(e1)
+	return
 }
 
 func Time(t *Time_t) (tt Time_t, errno int) {
-	r0, _, e1 := Syscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0);
-	tt = Time_t(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0)
+	tt = Time_t(r0)
+	errno = int(e1)
+	return
 }
 
 func Times(tms *Tms) (ticks uintptr, errno int) {
-	r0, _, e1 := Syscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0);
-	ticks = uintptr(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)
+	ticks = uintptr(r0)
+	errno = int(e1)
+	return
 }
 
 func Truncate(path string, length int64) (errno int) {
-	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), 0)
+	errno = int(e1)
+	return
 }
 
 func Umask(mask int) (oldmask int) {
-	r0, _, _ := Syscall(SYS_UMASK, uintptr(mask), 0, 0);
-	oldmask = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_UMASK, uintptr(mask), 0, 0)
+	oldmask = int(r0)
+	return
 }
 
 func Uname(buf *Utsname) (errno int) {
-	_, _, e1 := Syscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Unlink(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Unlinkat(dirfd int, path string) (errno int) {
-	_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), 0)
+	errno = int(e1)
+	return
 }
 
 func Unshare(flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Ustat(dev int, ubuf *Ustat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)
+	errno = int(e1)
+	return
 }
 
 func Utime(path string, buf *Utimbuf) (errno int) {
-	_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(buf)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(buf)), 0)
+	errno = int(e1)
+	return
 }
 
 func Write(fd int, p []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func exitThread(code int) (errno int) {
-	_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func read(fd int, p *byte, np int) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func write(fd int, p *byte, np int) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Chown(path string, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Fchown(fd int, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Fstat(fd int, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Fstatfs(fd int, buf *Statfs_t) (errno int) {
-	_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)
+	errno = int(e1)
+	return
 }
 
 func Getegid() (egid int) {
-	r0, _, _ := Syscall(SYS_GETEGID, 0, 0, 0);
-	egid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETEGID, 0, 0, 0)
+	egid = int(r0)
+	return
 }
 
 func Geteuid() (euid int) {
-	r0, _, _ := Syscall(SYS_GETEUID, 0, 0, 0);
-	euid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETEUID, 0, 0, 0)
+	euid = int(r0)
+	return
 }
 
 func Getgid() (gid int) {
-	r0, _, _ := Syscall(SYS_GETGID, 0, 0, 0);
-	gid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETGID, 0, 0, 0)
+	gid = int(r0)
+	return
 }
 
 func Getuid() (uid int) {
-	r0, _, _ := Syscall(SYS_GETUID, 0, 0, 0);
-	uid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETUID, 0, 0, 0)
+	uid = int(r0)
+	return
 }
 
 func Ioperm(from int, num int, on int) (errno int) {
-	_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on))
+	errno = int(e1)
+	return
 }
 
 func Iopl(level int) (errno int) {
-	_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Lchown(path string, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Listen(s int, n int) (errno int) {
-	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)
+	errno = int(e1)
+	return
 }
 
 func Lstat(path string, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Seek(fd int, offset int64, whence int) (off int64, errno int) {
-	r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence));
-	off = int64(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))
+	off = int64(r0)
+	errno = int(e1)
+	return
 }
 
 func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, errno int) {
-	r0, _, e1 := Syscall6(SYS_SELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_SELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Setfsgid(gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setfsuid(uid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setgid(gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETGID, uintptr(gid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETGID, uintptr(gid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setregid(rgid int, egid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)
+	errno = int(e1)
+	return
 }
 
 func Setresgid(rgid int, egid int, sgid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))
+	errno = int(e1)
+	return
 }
 
 func Setresuid(ruid int, euid int, suid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))
+	errno = int(e1)
+	return
 }
 
 func Setreuid(ruid int, euid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)
+	errno = int(e1)
+	return
 }
 
 func Shutdown(fd int, how int) (errno int) {
-	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)
+	errno = int(e1)
+	return
 }
 
 func Stat(path string, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Statfs(path string, buf *Statfs_t) (errno int) {
-	_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(buf)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(buf)), 0)
+	errno = int(e1)
+	return
 }
 
 func SyncFileRange(fd int, off int64, n int64, flags int) (errno int) {
-	_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func bind(s int, addr uintptr, addrlen _Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))
+	errno = int(e1)
+	return
 }
 
 func connect(s int, addr uintptr, addrlen _Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))
+	errno = int(e1)
+	return
 }
 
 func getgroups(n int, list *_Gid_t) (nn int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0);
-	nn = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
+	nn = int(r0)
+	errno = int(e1)
+	return
 }
 
 func setgroups(n int, list *_Gid_t) (errno int) {
-	_, _, e1 := Syscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
+	errno = int(e1)
+	return
 }
 
 func setsockopt(s int, level int, name int, val uintptr, vallen int) (errno int) {
-	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)
+	errno = int(e1)
+	return
 }
 
 func socket(domain int, typ int, proto int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	errno = int(e1)
+	return
 }
 
 func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	errno = int(e1)
+	return
 }
 
 func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func sendto(s int, buf []byte, flags int, to uintptr, addrlen _Socklen) (errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))
+	errno = int(e1)
+	return
 }
diff --git a/src/pkg/syscall/zsyscall_linux_arm.go b/src/pkg/syscall/zsyscall_linux_arm.go
index c221d3c48d..bef7148ca6 100644
--- a/src/pkg/syscall/zsyscall_linux_arm.go
+++ b/src/pkg/syscall/zsyscall_linux_arm.go
@@ -6,796 +6,796 @@ package syscall
 import "unsafe"
 
 func pipe(p *[2]_C_int) (errno int) {
-	_, _, e1 := Syscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func utimes(path string, times *[2]Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(times)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(times)), 0)
+	errno = int(e1)
+	return
 }
 
 func futimesat(dirfd int, path string, times *[2]Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(times)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(times)))
+	errno = int(e1)
+	return
 }
 
 func Getcwd(buf []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_GETCWD, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETCWD, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, errno int) {
-	r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0);
-	wpid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)
+	wpid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func ptrace(request int, pid int, addr uintptr, data uintptr) (errno int) {
-	_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Access(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Acct(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Adjtimex(buf *Timex) (state int, errno int) {
-	r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0);
-	state = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)
+	state = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Chdir(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Chmod(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Chroot(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Close(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Creat(path string, mode int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_CREAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_CREAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Dup(oldfd int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Dup2(oldfd int, newfd int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func EpollCreate(size int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func EpollCtl(epfd int, op int, fd int, event *EpollEvent) (errno int) {
-	_, _, e1 := Syscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func EpollWait(epfd int, events []EpollEvent, msec int) (n int, errno int) {
-	var _p0 *EpollEvent;
+	var _p0 *EpollEvent
 	if len(events) > 0 {
 		_p0 = &events[0]
 	}
-	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(unsafe.Pointer(_p0)), uintptr(len(events)), uintptr(msec), 0, 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(unsafe.Pointer(_p0)), uintptr(len(events)), uintptr(msec), 0, 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Exit(code int) {
-	Syscall(SYS_EXIT_GROUP, uintptr(code), 0, 0);
-	return;
+	Syscall(SYS_EXIT_GROUP, uintptr(code), 0, 0)
+	return
 }
 
 func Faccessat(dirfd int, path string, mode int, flags int) (errno int) {
-	_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(flags), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(flags), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Fallocate(fd int, mode int, off int64, len int64) (errno int) {
-	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(off>>32), uintptr(len), uintptr(len>>32));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(off>>32), uintptr(len), uintptr(len>>32))
+	errno = int(e1)
+	return
 }
 
 func Fchdir(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Fchmod(fd int, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Fchmodat(dirfd int, path string, mode int, flags int) (errno int) {
-	_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(flags), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(flags), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Fchownat(dirfd int, path string, uid int, gid int, flags int) (errno int) {
-	_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid), uintptr(flags), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid), uintptr(flags), 0)
+	errno = int(e1)
+	return
 }
 
 func fcntl(fd int, cmd int, arg int) (val int, errno int) {
-	r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg));
-	val = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))
+	val = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Fdatasync(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Fsync(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Ftruncate(fd int, length int64) (errno int) {
-	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length>>32));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length>>32))
+	errno = int(e1)
+	return
 }
 
 func Getdents(fd int, buf []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getpgid(pid int) (pgid int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0);
-	pgid = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETPGID, uintptr(pid), 0, 0)
+	pgid = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getpgrp() (pid int) {
-	r0, _, _ := Syscall(SYS_GETPGRP, 0, 0, 0);
-	pid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPGRP, 0, 0, 0)
+	pid = int(r0)
+	return
 }
 
 func Getpid() (pid int) {
-	r0, _, _ := Syscall(SYS_GETPID, 0, 0, 0);
-	pid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPID, 0, 0, 0)
+	pid = int(r0)
+	return
 }
 
 func Getppid() (ppid int) {
-	r0, _, _ := Syscall(SYS_GETPPID, 0, 0, 0);
-	ppid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPPID, 0, 0, 0)
+	ppid = int(r0)
+	return
 }
 
 func Getrlimit(resource int, rlim *Rlimit) (errno int) {
-	_, _, e1 := Syscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)
+	errno = int(e1)
+	return
 }
 
 func Getrusage(who int, rusage *Rusage) (errno int) {
-	_, _, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)
+	errno = int(e1)
+	return
 }
 
 func Gettid() (tid int) {
-	r0, _, _ := Syscall(SYS_GETTID, 0, 0, 0);
-	tid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETTID, 0, 0, 0)
+	tid = int(r0)
+	return
 }
 
 func Gettimeofday(tv *Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Kill(pid int, sig int) (errno int) {
-	_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(sig), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)
+	errno = int(e1)
+	return
 }
 
 func Klogctl(typ int, buf []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Link(oldpath string, newpath string) (errno int) {
-	_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0)
+	errno = int(e1)
+	return
 }
 
 func Mkdir(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Mkdirat(dirfd int, path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode))
+	errno = int(e1)
+	return
 }
 
 func Mknod(path string, mode int, dev int) (errno int) {
-	_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev))
+	errno = int(e1)
+	return
 }
 
 func Mknodat(dirfd int, path string, mode int, dev int) (errno int) {
-	_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(dev), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Nanosleep(time *Timespec, leftover *Timespec) (errno int) {
-	_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)
+	errno = int(e1)
+	return
 }
 
 func Open(path string, mode int, perm int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Openat(dirfd int, path string, flags int, mode int) (fd int, errno int) {
-	r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), uintptr(mode), 0, 0);
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(flags), uintptr(mode), 0, 0)
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Pause() (errno int) {
-	_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)
+	errno = int(e1)
+	return
 }
 
 func PivotRoot(newroot string, putold string) (errno int) {
-	_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(StringBytePtr(newroot))), uintptr(unsafe.Pointer(StringBytePtr(putold))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(StringBytePtr(newroot))), uintptr(unsafe.Pointer(StringBytePtr(putold))), 0)
+	errno = int(e1)
+	return
 }
 
 func Pread(fd int, p []byte, offset int64) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Read(fd int, p []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Readlink(path string, buf []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Rename(oldpath string, newpath string) (errno int) {
-	_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0)
+	errno = int(e1)
+	return
 }
 
 func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (errno int) {
-	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(newdirfd), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(newdirfd), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Rmdir(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setdomainname(p []byte) (errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0)
+	errno = int(e1)
+	return
 }
 
 func Sethostname(p []byte) (errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0)
+	errno = int(e1)
+	return
 }
 
 func Setpgid(pid int, pgid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)
+	errno = int(e1)
+	return
 }
 
 func Setrlimit(resource int, rlim *Rlimit) (errno int) {
-	_, _, e1 := Syscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)
+	errno = int(e1)
+	return
 }
 
 func Setsid() (pid int) {
-	r0, _, _ := Syscall(SYS_SETSID, 0, 0, 0);
-	pid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_SETSID, 0, 0, 0)
+	pid = int(r0)
+	return
 }
 
 func Settimeofday(tv *Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setuid(uid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETUID, uintptr(uid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, errno int) {
-	r0, r1, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags));
-	n = int64(int64(r1)<<32 | int64(r0));
-	errno = int(e1);
-	return;
+	r0, r1, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))
+	n = int64(int64(r1)<<32 | int64(r0))
+	errno = int(e1)
+	return
 }
 
 func Symlink(oldpath string, newpath string) (errno int) {
-	_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(StringBytePtr(oldpath))), uintptr(unsafe.Pointer(StringBytePtr(newpath))), 0)
+	errno = int(e1)
+	return
 }
 
 func Sync() {
-	Syscall(SYS_SYNC, 0, 0, 0);
-	return;
+	Syscall(SYS_SYNC, 0, 0, 0)
+	return
 }
 
 func Sysinfo(info *Sysinfo_t) (errno int) {
-	_, _, e1 := Syscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Tee(rfd int, wfd int, len int, flags int) (n int64, errno int) {
-	r0, r1, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0);
-	n = int64(int64(r1)<<32 | int64(r0));
-	errno = int(e1);
-	return;
+	r0, r1, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)
+	n = int64(int64(r1)<<32 | int64(r0))
+	errno = int(e1)
+	return
 }
 
 func Tgkill(tgid int, tid int, sig int) (errno int) {
-	_, _, e1 := Syscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))
+	errno = int(e1)
+	return
 }
 
 func Time(t *Time_t) (tt Time_t, errno int) {
-	r0, _, e1 := Syscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0);
-	tt = Time_t(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0)
+	tt = Time_t(r0)
+	errno = int(e1)
+	return
 }
 
 func Times(tms *Tms) (ticks uintptr, errno int) {
-	r0, _, e1 := Syscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0);
-	ticks = uintptr(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)
+	ticks = uintptr(r0)
+	errno = int(e1)
+	return
 }
 
 func Truncate(path string, length int64) (errno int) {
-	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), uintptr(length>>32));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(length), uintptr(length>>32))
+	errno = int(e1)
+	return
 }
 
 func Umask(mask int) (oldmask int) {
-	r0, _, _ := Syscall(SYS_UMASK, uintptr(mask), 0, 0);
-	oldmask = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_UMASK, uintptr(mask), 0, 0)
+	oldmask = int(r0)
+	return
 }
 
 func Uname(buf *Utsname) (errno int) {
-	_, _, e1 := Syscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Unlink(path string) (errno int) {
-	_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(StringBytePtr(path))), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Unlinkat(dirfd int, path string) (errno int) {
-	_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(StringBytePtr(path))), 0)
+	errno = int(e1)
+	return
 }
 
 func Unshare(flags int) (errno int) {
-	_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Ustat(dev int, ubuf *Ustat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)
+	errno = int(e1)
+	return
 }
 
 func Utime(path string, buf *Utimbuf) (errno int) {
-	_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(buf)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(buf)), 0)
+	errno = int(e1)
+	return
 }
 
 func Write(fd int, p []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func exitThread(code int) (errno int) {
-	_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func read(fd int, p *byte, np int) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func write(fd int, p *byte, np int) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func bind(s int, addr uintptr, addrlen _Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))
+	errno = int(e1)
+	return
 }
 
 func connect(s int, addr uintptr, addrlen _Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))
+	errno = int(e1)
+	return
 }
 
 func getgroups(n int, list *_Gid_t) (nn int, errno int) {
-	r0, _, e1 := Syscall(SYS_GETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0);
-	nn = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
+	nn = int(r0)
+	errno = int(e1)
+	return
 }
 
 func setgroups(n int, list *_Gid_t) (errno int) {
-	_, _, e1 := Syscall(SYS_SETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
+	errno = int(e1)
+	return
 }
 
 func setsockopt(s int, level int, name int, val uintptr, vallen int) (errno int) {
-	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)
+	errno = int(e1)
+	return
 }
 
 func socket(domain int, typ int, proto int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	errno = int(e1)
+	return
 }
 
 func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (errno int) {
-	_, _, e1 := Syscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	errno = int(e1)
+	return
 }
 
 func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func sendto(s int, buf []byte, flags int, to uintptr, addrlen _Socklen) (errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))
+	errno = int(e1)
+	return
 }
 
 func Chown(path string, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Fchown(fd int, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Fstat(fd int, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Fstatfs(fd int, buf *Statfs_t) (errno int) {
-	_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)
+	errno = int(e1)
+	return
 }
 
 func Getegid() (egid int) {
-	r0, _, _ := Syscall(SYS_GETEGID, 0, 0, 0);
-	egid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETEGID, 0, 0, 0)
+	egid = int(r0)
+	return
 }
 
 func Geteuid() (euid int) {
-	r0, _, _ := Syscall(SYS_GETEUID, 0, 0, 0);
-	euid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETEUID, 0, 0, 0)
+	euid = int(r0)
+	return
 }
 
 func Getgid() (gid int) {
-	r0, _, _ := Syscall(SYS_GETGID, 0, 0, 0);
-	gid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETGID, 0, 0, 0)
+	gid = int(r0)
+	return
 }
 
 func Getuid() (uid int) {
-	r0, _, _ := Syscall(SYS_GETUID, 0, 0, 0);
-	uid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETUID, 0, 0, 0)
+	uid = int(r0)
+	return
 }
 
 func Lchown(path string, uid int, gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(uid), uintptr(gid))
+	errno = int(e1)
+	return
 }
 
 func Listen(s int, n int) (errno int) {
-	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)
+	errno = int(e1)
+	return
 }
 
 func Lstat(path string, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Seek(fd int, offset int64, whence int) (off int64, errno int) {
-	r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(offset>>32), uintptr(whence), 0, 0);
-	off = int64(int64(r1)<<32 | int64(r0));
-	errno = int(e1);
-	return;
+	r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(offset>>32), uintptr(whence), 0, 0)
+	off = int64(int64(r1)<<32 | int64(r0))
+	errno = int(e1)
+	return
 }
 
 func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, errno int) {
-	r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0);
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Setfsgid(gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setfsuid(uid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setgid(gid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETGID, uintptr(gid), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETGID, uintptr(gid), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Setregid(rgid int, egid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)
+	errno = int(e1)
+	return
 }
 
 func Setresgid(rgid int, egid int, sgid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))
+	errno = int(e1)
+	return
 }
 
 func Setresuid(ruid int, euid int, suid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))
+	errno = int(e1)
+	return
 }
 
 func Setreuid(ruid int, euid int) (errno int) {
-	_, _, e1 := Syscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)
+	errno = int(e1)
+	return
 }
 
 func Shutdown(fd int, how int) (errno int) {
-	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)
+	errno = int(e1)
+	return
 }
 
 func Stat(path string, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Statfs(path string, buf *Statfs_t) (errno int) {
-	_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(buf)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(buf)), 0)
+	errno = int(e1)
+	return
 }
diff --git a/src/pkg/syscall/zsyscall_nacl_386.go b/src/pkg/syscall/zsyscall_nacl_386.go
index 7cf331dbac..34a0bd4668 100644
--- a/src/pkg/syscall/zsyscall_nacl_386.go
+++ b/src/pkg/syscall/zsyscall_nacl_386.go
@@ -6,224 +6,224 @@ package syscall
 import "unsafe"
 
 func Chmod(path string, mode int) (errno int) {
-	_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), 0)
+	errno = int(e1)
+	return
 }
 
 func Clock() (clock int) {
-	r0, _, _ := Syscall(SYS_CLOCK, 0, 0, 0);
-	clock = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_CLOCK, 0, 0, 0)
+	clock = int(r0)
+	return
 }
 
 func Close(fd int) (errno int) {
-	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Exit(code int) {
-	Syscall(SYS_EXIT, uintptr(code), 0, 0);
-	return;
+	Syscall(SYS_EXIT, uintptr(code), 0, 0)
+	return
 }
 
 func Fstat(fd int, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Getdents(fd int, buf []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(buf) > 0 {
 		_p0 = &buf[0]
 	}
-	r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Getpid() (pid int) {
-	r0, _, _ := Syscall(SYS_GETPID, 0, 0, 0);
-	pid = int(r0);
-	return;
+	r0, _, _ := Syscall(SYS_GETPID, 0, 0, 0)
+	pid = int(r0)
+	return
 }
 
 func Gettimeofday(tv *Timeval) (errno int) {
-	_, _, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func Open(path string, mode int, perm int) (fd int, errno int) {
-	r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm));
-	fd = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(mode), uintptr(perm))
+	fd = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Read(fd int, p []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func read(fd int, buf *byte, nbuf int) (n int, errno int) {
-	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func Stat(path string, stat *Stat_t) (errno int) {
-	_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(StringBytePtr(path))), uintptr(unsafe.Pointer(stat)), 0)
+	errno = int(e1)
+	return
 }
 
 func Write(fd int, p []byte) (n int, errno int) {
-	var _p0 *byte;
+	var _p0 *byte
 	if len(p) > 0 {
 		_p0 = &p[0]
 	}
-	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)));
-	n = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)))
+	n = int(r0)
+	errno = int(e1)
+	return
 }
 
 func MultimediaInit(subsys int) (errno int) {
-	_, _, e1 := Syscall(SYS_MULTIMEDIA_INIT, uintptr(subsys), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MULTIMEDIA_INIT, uintptr(subsys), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func MultimediaShutdown() (errno int) {
-	_, _, e1 := Syscall(SYS_MULTIMEDIA_SHUTDOWN, 0, 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MULTIMEDIA_SHUTDOWN, 0, 0, 0)
+	errno = int(e1)
+	return
 }
 
 func CondCreate() (cv int, errno int) {
-	r0, _, e1 := Syscall(SYS_COND_CREATE, 0, 0, 0);
-	cv = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_COND_CREATE, 0, 0, 0)
+	cv = int(r0)
+	errno = int(e1)
+	return
 }
 
 func CondWait(cv int, mutex int) (errno int) {
-	_, _, e1 := Syscall(SYS_COND_WAIT, uintptr(cv), uintptr(mutex), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_COND_WAIT, uintptr(cv), uintptr(mutex), 0)
+	errno = int(e1)
+	return
 }
 
 func CondSignal(cv int) (errno int) {
-	_, _, e1 := Syscall(SYS_COND_SIGNAL, uintptr(cv), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_COND_SIGNAL, uintptr(cv), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func CondBroadcast(cv int) (errno int) {
-	_, _, e1 := Syscall(SYS_COND_BROADCAST, uintptr(cv), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_COND_BROADCAST, uintptr(cv), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func CondTimedWaitAbs(cv int, mutex int, abstime *Timespec) (errno int) {
-	_, _, e1 := Syscall(SYS_COND_TIMED_WAIT_ABS, uintptr(cv), uintptr(mutex), uintptr(unsafe.Pointer(abstime)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_COND_TIMED_WAIT_ABS, uintptr(cv), uintptr(mutex), uintptr(unsafe.Pointer(abstime)))
+	errno = int(e1)
+	return
 }
 
 func MutexCreate() (mutex int, errno int) {
-	r0, _, e1 := Syscall(SYS_MUTEX_CREATE, 0, 0, 0);
-	mutex = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_MUTEX_CREATE, 0, 0, 0)
+	mutex = int(r0)
+	errno = int(e1)
+	return
 }
 
 func MutexLock(mutex int) (errno int) {
-	_, _, e1 := Syscall(SYS_MUTEX_LOCK, uintptr(mutex), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MUTEX_LOCK, uintptr(mutex), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func MutexUnlock(mutex int) (errno int) {
-	_, _, e1 := Syscall(SYS_MUTEX_UNLOCK, uintptr(mutex), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MUTEX_UNLOCK, uintptr(mutex), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func MutexTryLock(mutex int) (errno int) {
-	_, _, e1 := Syscall(SYS_MUTEX_TRYLOCK, uintptr(mutex), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_MUTEX_TRYLOCK, uintptr(mutex), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func SemCreate() (sema int, errno int) {
-	r0, _, e1 := Syscall(SYS_SEM_CREATE, 0, 0, 0);
-	sema = int(r0);
-	errno = int(e1);
-	return;
+	r0, _, e1 := Syscall(SYS_SEM_CREATE, 0, 0, 0)
+	sema = int(r0)
+	errno = int(e1)
+	return
 }
 
 func SemWait(sema int) (errno int) {
-	_, _, e1 := Syscall(SYS_SEM_WAIT, uintptr(sema), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SEM_WAIT, uintptr(sema), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func SemPost(sema int) (errno int) {
-	_, _, e1 := Syscall(SYS_SEM_POST, uintptr(sema), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_SEM_POST, uintptr(sema), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func VideoInit(dx int, dy int) (errno int) {
-	_, _, e1 := Syscall(SYS_VIDEO_INIT, uintptr(dx), uintptr(dy), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_VIDEO_INIT, uintptr(dx), uintptr(dy), 0)
+	errno = int(e1)
+	return
 }
 
 func VideoUpdate(data *uint32) (errno int) {
-	_, _, e1 := Syscall(SYS_VIDEO_UPDATE, uintptr(unsafe.Pointer(data)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_VIDEO_UPDATE, uintptr(unsafe.Pointer(data)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func VideoPollEvent(ev *byte) (errno int) {
-	_, _, e1 := Syscall(SYS_VIDEO_POLL_EVENT, uintptr(unsafe.Pointer(ev)), 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_VIDEO_POLL_EVENT, uintptr(unsafe.Pointer(ev)), 0, 0)
+	errno = int(e1)
+	return
 }
 
 func VideoShutdown() (errno int) {
-	_, _, e1 := Syscall(SYS_VIDEO_SHUTDOWN, 0, 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_VIDEO_SHUTDOWN, 0, 0, 0)
+	errno = int(e1)
+	return
 }
 
 func AudioInit(fmt int, nreq int, data *int) (errno int) {
-	_, _, e1 := Syscall(SYS_AUDIO_INIT, uintptr(fmt), uintptr(nreq), uintptr(unsafe.Pointer(data)));
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_AUDIO_INIT, uintptr(fmt), uintptr(nreq), uintptr(unsafe.Pointer(data)))
+	errno = int(e1)
+	return
 }
 
 func AudioShutdown() (errno int) {
-	_, _, e1 := Syscall(SYS_AUDIO_SHUTDOWN, 0, 0, 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_AUDIO_SHUTDOWN, 0, 0, 0)
+	errno = int(e1)
+	return
 }
 
 func AudioStream(data *uint16, size *uintptr) (errno int) {
-	_, _, e1 := Syscall(SYS_AUDIO_STREAM, uintptr(unsafe.Pointer(data)), uintptr(unsafe.Pointer(size)), 0);
-	errno = int(e1);
-	return;
+	_, _, e1 := Syscall(SYS_AUDIO_STREAM, uintptr(unsafe.Pointer(data)), uintptr(unsafe.Pointer(size)), 0)
+	errno = int(e1)
+	return
 }
diff --git a/src/pkg/syscall/zsysnum_darwin_386.go b/src/pkg/syscall/zsysnum_darwin_386.go
index c1cfbd4fc5..8d5c93478b 100644
--- a/src/pkg/syscall/zsysnum_darwin_386.go
+++ b/src/pkg/syscall/zsysnum_darwin_386.go
@@ -5,120 +5,120 @@ package syscall
 
 const (
 	// SYS_NOSYS = 0;  // { int nosys(void); }   { indirect syscall }
-	SYS_EXIT	= 1;	// { void exit(int rval); }
-	SYS_FORK	= 2;	// { int fork(void); }
-	SYS_READ	= 3;	// { user_ssize_t read(int fd, user_addr_t cbuf, user_size_t nbyte); }
-	SYS_WRITE	= 4;	// { user_ssize_t write(int fd, user_addr_t cbuf, user_size_t nbyte); }
-	SYS_OPEN	= 5;	// { int open(user_addr_t path, int flags, int mode); }
-	SYS_CLOSE	= 6;	// { int close(int fd); }
-	SYS_WAIT4	= 7;	// { int wait4(int pid, user_addr_t status, int options, user_addr_t rusage); }
+	SYS_EXIT  = 1 // { void exit(int rval); }
+	SYS_FORK  = 2 // { int fork(void); }
+	SYS_READ  = 3 // { user_ssize_t read(int fd, user_addr_t cbuf, user_size_t nbyte); }
+	SYS_WRITE = 4 // { user_ssize_t write(int fd, user_addr_t cbuf, user_size_t nbyte); }
+	SYS_OPEN  = 5 // { int open(user_addr_t path, int flags, int mode); }
+	SYS_CLOSE = 6 // { int close(int fd); }
+	SYS_WAIT4 = 7 // { int wait4(int pid, user_addr_t status, int options, user_addr_t rusage); }
 	// SYS_NOSYS = 8;  // { int nosys(void); }   { old creat }
-	SYS_LINK	= 9;	// { int link(user_addr_t path, user_addr_t link); }
-	SYS_UNLINK	= 10;	// { int unlink(user_addr_t path); }
+	SYS_LINK   = 9  // { int link(user_addr_t path, user_addr_t link); }
+	SYS_UNLINK = 10 // { int unlink(user_addr_t path); }
 	// SYS_NOSYS = 11;  // { int nosys(void); }   { old execv }
-	SYS_CHDIR	= 12;	// { int chdir(user_addr_t path); }
-	SYS_FCHDIR	= 13;	// { int fchdir(int fd); }
-	SYS_MKNOD	= 14;	// { int mknod(user_addr_t path, int mode, int dev); }
-	SYS_CHMOD	= 15;	// { int chmod(user_addr_t path, int mode); }
-	SYS_CHOWN	= 16;	// { int chown(user_addr_t path, int uid, int gid); }
-	SYS_OGETFSSTAT	= 18;	// { int ogetfsstat(user_addr_t buf, int bufsize, int flags); }
-	SYS_GETFSSTAT	= 18;	// { int getfsstat(user_addr_t buf, int bufsize, int flags); }
+	SYS_CHDIR      = 12 // { int chdir(user_addr_t path); }
+	SYS_FCHDIR     = 13 // { int fchdir(int fd); }
+	SYS_MKNOD      = 14 // { int mknod(user_addr_t path, int mode, int dev); }
+	SYS_CHMOD      = 15 // { int chmod(user_addr_t path, int mode); }
+	SYS_CHOWN      = 16 // { int chown(user_addr_t path, int uid, int gid); }
+	SYS_OGETFSSTAT = 18 // { int ogetfsstat(user_addr_t buf, int bufsize, int flags); }
+	SYS_GETFSSTAT  = 18 // { int getfsstat(user_addr_t buf, int bufsize, int flags); }
 	// SYS_NOSYS = 19;  // { int nosys(void); }   { old lseek }
-	SYS_GETPID	= 20;	// { int getpid(void); }
+	SYS_GETPID = 20 // { int getpid(void); }
 	// SYS_NOSYS = 21;  // { int nosys(void); }   { old mount }
 	// SYS_NOSYS = 22;  // { int nosys(void); }   { old umount }
-	SYS_SETUID	= 23;	// { int setuid(uid_t uid); }
-	SYS_GETUID	= 24;	// { int getuid(void); }
-	SYS_GETEUID	= 25;	// { int geteuid(void); }
-	SYS_PTRACE	= 26;	// { int ptrace(int req, pid_t pid, caddr_t addr, int data); }
-	SYS_RECVMSG	= 27;	// { int recvmsg(int s, struct msghdr *msg, int flags); }
-	SYS_SENDMSG	= 28;	// { int sendmsg(int s, caddr_t msg, int flags); }
-	SYS_RECVFROM	= 29;	// { int recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, int *fromlenaddr); }
-	SYS_ACCEPT	= 30;	// { int accept(int s, caddr_t name, socklen_t	*anamelen); }
-	SYS_GETPEERNAME	= 31;	// { int getpeername(int fdes, caddr_t asa, socklen_t *alen); }
-	SYS_GETSOCKNAME	= 32;	// { int getsockname(int fdes, caddr_t asa, socklen_t *alen); }
+	SYS_SETUID      = 23 // { int setuid(uid_t uid); }
+	SYS_GETUID      = 24 // { int getuid(void); }
+	SYS_GETEUID     = 25 // { int geteuid(void); }
+	SYS_PTRACE      = 26 // { int ptrace(int req, pid_t pid, caddr_t addr, int data); }
+	SYS_RECVMSG     = 27 // { int recvmsg(int s, struct msghdr *msg, int flags); }
+	SYS_SENDMSG     = 28 // { int sendmsg(int s, caddr_t msg, int flags); }
+	SYS_RECVFROM    = 29 // { int recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, int *fromlenaddr); }
+	SYS_ACCEPT      = 30 // { int accept(int s, caddr_t name, socklen_t	*anamelen); }
+	SYS_GETPEERNAME = 31 // { int getpeername(int fdes, caddr_t asa, socklen_t *alen); }
+	SYS_GETSOCKNAME = 32 // { int getsockname(int fdes, caddr_t asa, socklen_t *alen); }
 	// SYS_NOSYS = 27;  // { int nosys(void); }
 	// SYS_NOSYS = 28;  // { int nosys(void); }
 	// SYS_NOSYS = 29;  // { int nosys(void); }
 	// SYS_NOSYS = 30;  // { int nosys(void); }
 	// SYS_NOSYS = 31;  // { int nosys(void); }
 	// SYS_NOSYS = 32;  // { int nosys(void); }
-	SYS_ACCESS	= 33;	// { int access(user_addr_t path, int flags); }
-	SYS_CHFLAGS	= 34;	// { int chflags(char *path, int flags); }
-	SYS_FCHFLAGS	= 35;	// { int fchflags(int fd, int flags); }
-	SYS_SYNC	= 36;	// { int sync(void); }
-	SYS_KILL	= 37;	// { int kill(int pid, int signum, int posix); }
+	SYS_ACCESS   = 33 // { int access(user_addr_t path, int flags); }
+	SYS_CHFLAGS  = 34 // { int chflags(char *path, int flags); }
+	SYS_FCHFLAGS = 35 // { int fchflags(int fd, int flags); }
+	SYS_SYNC     = 36 // { int sync(void); }
+	SYS_KILL     = 37 // { int kill(int pid, int signum, int posix); }
 	// SYS_NOSYS = 38;  // { int nosys(void); }   { old stat  }
-	SYS_GETPPID	= 39;	// { int getppid(void); }
+	SYS_GETPPID = 39 // { int getppid(void); }
 	// SYS_NOSYS = 40;  // { int nosys(void); }   { old lstat }
-	SYS_DUP		= 41;	// { int dup(u_int fd); }
-	SYS_PIPE	= 42;	// { int pipe(void); }
-	SYS_GETEGID	= 43;	// { int getegid(void); }
-	SYS_PROFIL	= 44;	// { int profil(short *bufbase, size_t bufsize, u_long pcoffset, u_int pcscale); }
+	SYS_DUP     = 41 // { int dup(u_int fd); }
+	SYS_PIPE    = 42 // { int pipe(void); }
+	SYS_GETEGID = 43 // { int getegid(void); }
+	SYS_PROFIL  = 44 // { int profil(short *bufbase, size_t bufsize, u_long pcoffset, u_int pcscale); }
 	// SYS_NOSYS = 45;  // { int nosys(void); } { old ktrace }
-	SYS_SIGACTION	= 46;	// { int sigaction(int signum, struct __sigaction *nsa, struct sigaction *osa); }
-	SYS_GETGID	= 47;	// { int getgid(void); }
-	SYS_SIGPROCMASK	= 48;	// { int sigprocmask(int how, user_addr_t mask, user_addr_t omask); }
-	SYS_GETLOGIN	= 49;	// { int getlogin(char *namebuf, u_int namelen); }
-	SYS_SETLOGIN	= 50;	// { int setlogin(char *namebuf); }
-	SYS_ACCT	= 51;	// { int acct(char *path); }
-	SYS_SIGPENDING	= 52;	// { int sigpending(struct sigvec *osv); }
-	SYS_SIGALTSTACK	= 53;	// { int sigaltstack(struct sigaltstack *nss, struct sigaltstack *oss); }
-	SYS_IOCTL	= 54;	// { int ioctl(int fd, u_long com, caddr_t data); }
-	SYS_REBOOT	= 55;	// { int reboot(int opt, char *command); }
-	SYS_REVOKE	= 56;	// { int revoke(char *path); }
-	SYS_SYMLINK	= 57;	// { int symlink(char *path, char *link); }
-	SYS_READLINK	= 58;	// { int readlink(char *path, char *buf, int count); }
-	SYS_EXECVE	= 59;	// { int execve(char *fname, char **argp, char **envp); }
-	SYS_UMASK	= 60;	// { int umask(int newmask); }
-	SYS_CHROOT	= 61;	// { int chroot(user_addr_t path); }
+	SYS_SIGACTION   = 46 // { int sigaction(int signum, struct __sigaction *nsa, struct sigaction *osa); }
+	SYS_GETGID      = 47 // { int getgid(void); }
+	SYS_SIGPROCMASK = 48 // { int sigprocmask(int how, user_addr_t mask, user_addr_t omask); }
+	SYS_GETLOGIN    = 49 // { int getlogin(char *namebuf, u_int namelen); }
+	SYS_SETLOGIN    = 50 // { int setlogin(char *namebuf); }
+	SYS_ACCT        = 51 // { int acct(char *path); }
+	SYS_SIGPENDING  = 52 // { int sigpending(struct sigvec *osv); }
+	SYS_SIGALTSTACK = 53 // { int sigaltstack(struct sigaltstack *nss, struct sigaltstack *oss); }
+	SYS_IOCTL       = 54 // { int ioctl(int fd, u_long com, caddr_t data); }
+	SYS_REBOOT      = 55 // { int reboot(int opt, char *command); }
+	SYS_REVOKE      = 56 // { int revoke(char *path); }
+	SYS_SYMLINK     = 57 // { int symlink(char *path, char *link); }
+	SYS_READLINK    = 58 // { int readlink(char *path, char *buf, int count); }
+	SYS_EXECVE      = 59 // { int execve(char *fname, char **argp, char **envp); }
+	SYS_UMASK       = 60 // { int umask(int newmask); }
+	SYS_CHROOT      = 61 // { int chroot(user_addr_t path); }
 	// SYS_NOSYS = 62;  // { int nosys(void); }   { old fstat }
 	// SYS_NOSYS = 63;  // { int nosys(void); }   { used internally, reserved }
 	// SYS_NOSYS = 64;  // { int nosys(void); }   { old getpagesize }
-	SYS_MSYNC	= 65;	// { int msync(caddr_t addr, size_t len, int flags); }
-	SYS_VFORK	= 66;	// { int vfork(void); }
+	SYS_MSYNC = 65 // { int msync(caddr_t addr, size_t len, int flags); }
+	SYS_VFORK = 66 // { int vfork(void); }
 	// SYS_NOSYS = 67;  // { int nosys(void); }   { old vread }
 	// SYS_NOSYS = 68;  // { int nosys(void); }   { old vwrite }
-	SYS_SBRK	= 69;	// { int sbrk(int incr) NO_SYSCALL_STUB; }
-	SYS_SSTK	= 70;	// { int sstk(int incr) NO_SYSCALL_STUB; }
+	SYS_SBRK = 69 // { int sbrk(int incr) NO_SYSCALL_STUB; }
+	SYS_SSTK = 70 // { int sstk(int incr) NO_SYSCALL_STUB; }
 	// SYS_NOSYS = 71;  // { int nosys(void); }   { old mmap }
-	SYS_OVADVISE	= 72;	// { int ovadvise(void) NO_SYSCALL_STUB; }   { old vadvise }
-	SYS_MUNMAP	= 73;	// { int munmap(caddr_t addr, size_t len); }
-	SYS_MPROTECT	= 74;	// { int mprotect(caddr_t addr, size_t len, int prot); }
-	SYS_MADVISE	= 75;	// { int madvise(caddr_t addr, size_t len, int behav); }
+	SYS_OVADVISE = 72 // { int ovadvise(void) NO_SYSCALL_STUB; }   { old vadvise }
+	SYS_MUNMAP   = 73 // { int munmap(caddr_t addr, size_t len); }
+	SYS_MPROTECT = 74 // { int mprotect(caddr_t addr, size_t len, int prot); }
+	SYS_MADVISE  = 75 // { int madvise(caddr_t addr, size_t len, int behav); }
 	// SYS_NOSYS = 76;  // { int nosys(void); }   { old vhangup }
 	// SYS_NOSYS = 77;  // { int nosys(void); }   { old vlimit }
-	SYS_MINCORE	= 78;	// { int mincore(user_addr_t addr, user_size_t len, user_addr_t vec); }
-	SYS_GETGROUPS	= 79;	// { int getgroups(u_int gidsetsize, gid_t *gidset); }
-	SYS_SETGROUPS	= 80;	// { int setgroups(u_int gidsetsize, gid_t *gidset); }
-	SYS_GETPGRP	= 81;	// { int getpgrp(void); }
-	SYS_SETPGID	= 82;	// { int setpgid(int pid, int pgid); }
-	SYS_SETITIMER	= 83;	// { int setitimer(u_int which, struct itimerval *itv, struct itimerval *oitv); }
+	SYS_MINCORE   = 78 // { int mincore(user_addr_t addr, user_size_t len, user_addr_t vec); }
+	SYS_GETGROUPS = 79 // { int getgroups(u_int gidsetsize, gid_t *gidset); }
+	SYS_SETGROUPS = 80 // { int setgroups(u_int gidsetsize, gid_t *gidset); }
+	SYS_GETPGRP   = 81 // { int getpgrp(void); }
+	SYS_SETPGID   = 82 // { int setpgid(int pid, int pgid); }
+	SYS_SETITIMER = 83 // { int setitimer(u_int which, struct itimerval *itv, struct itimerval *oitv); }
 	// SYS_NOSYS = 84;  // { int nosys(void); }   { old wait }
-	SYS_SWAPON	= 85;	// { int swapon(void); }
-	SYS_GETITIMER	= 86;	// { int getitimer(u_int which, struct itimerval *itv); }
+	SYS_SWAPON    = 85 // { int swapon(void); }
+	SYS_GETITIMER = 86 // { int getitimer(u_int which, struct itimerval *itv); }
 	// SYS_NOSYS = 87;  // { int nosys(void); }   { old gethostname }
 	// SYS_NOSYS = 88;  // { int nosys(void); }   { old sethostname }
-	SYS_GETDTABLESIZE	= 89;	// { int getdtablesize(void); }
-	SYS_DUP2		= 90;	// { int dup2(u_int from, u_int to); }
+	SYS_GETDTABLESIZE = 89 // { int getdtablesize(void); }
+	SYS_DUP2          = 90 // { int dup2(u_int from, u_int to); }
 	// SYS_NOSYS = 91;  // { int nosys(void); }   { old getdopt }
-	SYS_FCNTL	= 92;	// { int fcntl(int fd, int cmd, long arg); }
-	SYS_SELECT	= 93;	// { int select(int nd, u_int32_t *in, u_int32_t *ou, u_int32_t *ex, struct timeval *tv); }
+	SYS_FCNTL  = 92 // { int fcntl(int fd, int cmd, long arg); }
+	SYS_SELECT = 93 // { int select(int nd, u_int32_t *in, u_int32_t *ou, u_int32_t *ex, struct timeval *tv); }
 	// SYS_NOSYS = 94;  // { int nosys(void); }   { old setdopt }
-	SYS_FSYNC	= 95;	// { int fsync(int fd); }
-	SYS_SETPRIORITY	= 96;	// { int setpriority(int which, id_t who, int prio); }
-	SYS_SOCKET	= 97;	// { int socket(int domain, int type, int protocol); }
-	SYS_CONNECT	= 98;	// { int connect(int s, caddr_t name, socklen_t namelen); }
+	SYS_FSYNC       = 95 // { int fsync(int fd); }
+	SYS_SETPRIORITY = 96 // { int setpriority(int which, id_t who, int prio); }
+	SYS_SOCKET      = 97 // { int socket(int domain, int type, int protocol); }
+	SYS_CONNECT     = 98 // { int connect(int s, caddr_t name, socklen_t namelen); }
 	// SYS_NOSYS = 97;  // { int nosys(void); }
 	// SYS_NOSYS = 98;  // { int nosys(void); }
 	// SYS_NOSYS = 99;  // { int nosys(void); }   { old accept }
-	SYS_GETPRIORITY	= 100;	// { int getpriority(int which, id_t who); }
+	SYS_GETPRIORITY = 100 // { int getpriority(int which, id_t who); }
 	// SYS_NOSYS = 101;  // { int nosys(void); }   { old send }
 	// SYS_NOSYS = 102;  // { int nosys(void); }   { old recv }
 	// SYS_NOSYS = 103;  // { int nosys(void); }   { old sigreturn }
-	SYS_BIND	= 104;	// { int bind(int s, caddr_t name, socklen_t namelen); }
-	SYS_SETSOCKOPT	= 105;	// { int setsockopt(int s, int level, int name, caddr_t val, socklen_t valsize); }
-	SYS_LISTEN	= 106;	// { int listen(int s, int backlog); }
+	SYS_BIND       = 104 // { int bind(int s, caddr_t name, socklen_t namelen); }
+	SYS_SETSOCKOPT = 105 // { int setsockopt(int s, int level, int name, caddr_t val, socklen_t valsize); }
+	SYS_LISTEN     = 106 // { int listen(int s, int backlog); }
 	// SYS_NOSYS = 104;  // { int nosys(void); }
 	// SYS_NOSYS = 105;  // { int nosys(void); }
 	// SYS_NOSYS = 106;  // { int nosys(void); }
@@ -126,108 +126,108 @@ const (
 	// SYS_NOSYS = 108;  // { int nosys(void); }   { old sigvec }
 	// SYS_NOSYS = 109;  // { int nosys(void); }   { old sigblock }
 	// SYS_NOSYS = 110;  // { int nosys(void); }   { old sigsetmask }
-	SYS_SIGSUSPEND	= 111;	// { int sigsuspend(sigset_t mask); }
+	SYS_SIGSUSPEND = 111 // { int sigsuspend(sigset_t mask); }
 	// SYS_NOSYS = 112;  // { int nosys(void); }   { old sigstack }
 	// SYS_NOSYS = 113;  // { int nosys(void); }   { old recvmsg }
 	// SYS_NOSYS = 114;  // { int nosys(void); }   { old sendmsg }
 	// SYS_NOSYS = 113;  // { int nosys(void); }
 	// SYS_NOSYS = 114;  // { int nosys(void); }
 	// SYS_NOSYS = 115;  // { int nosys(void); }   { old vtrace }
-	SYS_GETTIMEOFDAY	= 116;	// { int gettimeofday(struct timeval *tp, struct timezone *tzp); }
-	SYS_GETRUSAGE		= 117;	// { int getrusage(int who, struct rusage *rusage); }
-	SYS_GETSOCKOPT		= 118;	// { int getsockopt(int s, int level, int name, caddr_t val, socklen_t *avalsize); }
+	SYS_GETTIMEOFDAY = 116 // { int gettimeofday(struct timeval *tp, struct timezone *tzp); }
+	SYS_GETRUSAGE    = 117 // { int getrusage(int who, struct rusage *rusage); }
+	SYS_GETSOCKOPT   = 118 // { int getsockopt(int s, int level, int name, caddr_t val, socklen_t *avalsize); }
 	// SYS_NOSYS = 118;  // { int nosys(void); }
 	// SYS_NOSYS = 119;  // { int nosys(void); }   { old resuba }
-	SYS_READV		= 120;	// { user_ssize_t readv(int fd, struct iovec *iovp, u_int iovcnt); }
-	SYS_WRITEV		= 121;	// { user_ssize_t writev(int fd, struct iovec *iovp, u_int iovcnt); }
-	SYS_SETTIMEOFDAY	= 122;	// { int settimeofday(struct timeval *tv, struct timezone *tzp); }
-	SYS_FCHOWN		= 123;	// { int fchown(int fd, int uid, int gid); }
-	SYS_FCHMOD		= 124;	// { int fchmod(int fd, int mode); }
+	SYS_READV        = 120 // { user_ssize_t readv(int fd, struct iovec *iovp, u_int iovcnt); }
+	SYS_WRITEV       = 121 // { user_ssize_t writev(int fd, struct iovec *iovp, u_int iovcnt); }
+	SYS_SETTIMEOFDAY = 122 // { int settimeofday(struct timeval *tv, struct timezone *tzp); }
+	SYS_FCHOWN       = 123 // { int fchown(int fd, int uid, int gid); }
+	SYS_FCHMOD       = 124 // { int fchmod(int fd, int mode); }
 	// SYS_NOSYS = 125;  // { int nosys(void); }   { old recvfrom }
-	SYS_SETREUID	= 126;	// { int setreuid(uid_t ruid, uid_t euid); }
-	SYS_SETREGID	= 127;	// { int setregid(gid_t rgid, gid_t egid); }
-	SYS_RENAME	= 128;	// { int rename(char *from, char *to); }
+	SYS_SETREUID = 126 // { int setreuid(uid_t ruid, uid_t euid); }
+	SYS_SETREGID = 127 // { int setregid(gid_t rgid, gid_t egid); }
+	SYS_RENAME   = 128 // { int rename(char *from, char *to); }
 	// SYS_NOSYS = 129;  // { int nosys(void); }   { old truncate }
 	// SYS_NOSYS = 130;  // { int nosys(void); }   { old ftruncate }
-	SYS_FLOCK	= 131;	// { int flock(int fd, int how); }
-	SYS_MKFIFO	= 132;	// { int mkfifo(user_addr_t path, int mode); }
-	SYS_SENDTO	= 133;	// { int sendto(int s, caddr_t buf, size_t len, int flags, caddr_t to, socklen_t tolen); }
-	SYS_SHUTDOWN	= 134;	// { int shutdown(int s, int how); }
-	SYS_SOCKETPAIR	= 135;	// { int socketpair(int domain, int type, int protocol, int *rsv); }
+	SYS_FLOCK      = 131 // { int flock(int fd, int how); }
+	SYS_MKFIFO     = 132 // { int mkfifo(user_addr_t path, int mode); }
+	SYS_SENDTO     = 133 // { int sendto(int s, caddr_t buf, size_t len, int flags, caddr_t to, socklen_t tolen); }
+	SYS_SHUTDOWN   = 134 // { int shutdown(int s, int how); }
+	SYS_SOCKETPAIR = 135 // { int socketpair(int domain, int type, int protocol, int *rsv); }
 	// SYS_NOSYS = 133;  // { int nosys(void); }
 	// SYS_NOSYS = 134;  // { int nosys(void); }
 	// SYS_NOSYS = 135;  // { int nosys(void); }
-	SYS_MKDIR	= 136;	// { int mkdir(user_addr_t path, int mode); }
-	SYS_RMDIR	= 137;	// { int rmdir(char *path); }
-	SYS_UTIMES	= 138;	// { int utimes(char *path, struct timeval *tptr); }
-	SYS_FUTIMES	= 139;	// { int futimes(int fd, struct timeval *tptr); }
-	SYS_ADJTIME	= 140;	// { int adjtime(struct timeval *delta, struct timeval *olddelta); }
+	SYS_MKDIR   = 136 // { int mkdir(user_addr_t path, int mode); }
+	SYS_RMDIR   = 137 // { int rmdir(char *path); }
+	SYS_UTIMES  = 138 // { int utimes(char *path, struct timeval *tptr); }
+	SYS_FUTIMES = 139 // { int futimes(int fd, struct timeval *tptr); }
+	SYS_ADJTIME = 140 // { int adjtime(struct timeval *delta, struct timeval *olddelta); }
 	// SYS_NOSYS = 141;  // { int nosys(void); }   { old getpeername }
-	SYS_GETHOSTUUID	= 142;	// { int gethostuuid(unsigned char *uuid_buf, const struct timespec *timeoutp); }
+	SYS_GETHOSTUUID = 142 // { int gethostuuid(unsigned char *uuid_buf, const struct timespec *timeoutp); }
 	// SYS_NOSYS = 143;  // { int nosys(void); }   { old sethostid 	}
 	// SYS_NOSYS = 144;  // { int nosys(void); }   { old getrlimit }
 	// SYS_NOSYS = 145;  // { int nosys(void); }   { old setrlimit }
 	// SYS_NOSYS = 146;  // { int nosys(void); }   { old killpg }
-	SYS_SETSID	= 147;	// { int setsid(void); }
+	SYS_SETSID = 147 // { int setsid(void); }
 	// SYS_NOSYS = 148;  // { int nosys(void); }   { old setquota }
 	// SYS_NOSYS = 149;  // { int nosys(void); }   { old qquota }
 	// SYS_NOSYS = 150;  // { int nosys(void); }   { old getsockname }
-	SYS_GETPGID	= 151;	// { int getpgid(pid_t pid); }
-	SYS_SETPRIVEXEC	= 152;	// { int setprivexec(int flag); }
-	SYS_PREAD	= 153;	// { user_ssize_t pread(int fd, user_addr_t buf, user_size_t nbyte, off_t offset); }
-	SYS_PWRITE	= 154;	// { user_ssize_t pwrite(int fd, user_addr_t buf, user_size_t nbyte, off_t offset); }
-	SYS_NFSSVC	= 155;	// { int nfssvc(int flag, caddr_t argp); }
+	SYS_GETPGID     = 151 // { int getpgid(pid_t pid); }
+	SYS_SETPRIVEXEC = 152 // { int setprivexec(int flag); }
+	SYS_PREAD       = 153 // { user_ssize_t pread(int fd, user_addr_t buf, user_size_t nbyte, off_t offset); }
+	SYS_PWRITE      = 154 // { user_ssize_t pwrite(int fd, user_addr_t buf, user_size_t nbyte, off_t offset); }
+	SYS_NFSSVC      = 155 // { int nfssvc(int flag, caddr_t argp); }
 	// SYS_NOSYS = 155;  // { int nosys(void); }
 	// SYS_NOSYS = 156;  // { int nosys(void); }   { old getdirentries }
-	SYS_STATFS	= 157;	// { int statfs(char *path, struct statfs *buf); }
-	SYS_FSTATFS	= 158;	// { int fstatfs(int fd, struct statfs *buf); }
-	SYS_UNMOUNT	= 159;	// { int unmount(user_addr_t path, int flags); }
+	SYS_STATFS  = 157 // { int statfs(char *path, struct statfs *buf); }
+	SYS_FSTATFS = 158 // { int fstatfs(int fd, struct statfs *buf); }
+	SYS_UNMOUNT = 159 // { int unmount(user_addr_t path, int flags); }
 	// SYS_NOSYS = 160;  // { int nosys(void); }   { old async_daemon }
-	SYS_GETFH	= 161;	// { int getfh(char *fname, fhandle_t *fhp); }
+	SYS_GETFH = 161 // { int getfh(char *fname, fhandle_t *fhp); }
 	// SYS_NOSYS = 161;  // { int nosys(void); }
 	// SYS_NOSYS = 162;  // { int nosys(void); }   { old getdomainname }
 	// SYS_NOSYS = 163;  // { int nosys(void); }   { old setdomainname }
 	// SYS_NOSYS = 164;  // { int nosys(void); }
-	SYS_QUOTACTL	= 165;	// { int quotactl(const char *path, int cmd, int uid, caddr_t arg); }
+	SYS_QUOTACTL = 165 // { int quotactl(const char *path, int cmd, int uid, caddr_t arg); }
 	// SYS_NOSYS = 166;  // { int nosys(void); }   { old exportfs }
-	SYS_MOUNT	= 167;	// { int mount(char *type, char *path, int flags, caddr_t data); }
+	SYS_MOUNT = 167 // { int mount(char *type, char *path, int flags, caddr_t data); }
 	// SYS_NOSYS = 168;  // { int nosys(void); }   { old ustat }
-	SYS_CSOPS	= 169;	// { int csops(pid_t pid, uint32_t ops, user_addr_t useraddr, user_size_t usersize); }
+	SYS_CSOPS = 169 // { int csops(pid_t pid, uint32_t ops, user_addr_t useraddr, user_size_t usersize); }
 	// SYS_NOSYS = 171;  // { int nosys(void); }   { old wait3 }
 	// SYS_NOSYS = 172;  // { int nosys(void); }   { old rpause	}
-	SYS_WAITID	= 173;	// { int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); }
+	SYS_WAITID = 173 // { int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); }
 	// SYS_NOSYS = 174;  // { int nosys(void); }   { old getdents }
 	// SYS_NOSYS = 175;  // { int nosys(void); }   { old gc_control }
-	SYS_ADD_PROFIL	= 176;	// { int add_profil(short *bufbase, size_t bufsize, u_long pcoffset, u_int pcscale); }
+	SYS_ADD_PROFIL = 176 // { int add_profil(short *bufbase, size_t bufsize, u_long pcoffset, u_int pcscale); }
 	// SYS_NOSYS = 177;  // { int nosys(void); }
 	// SYS_NOSYS = 178;  // { int nosys(void); }
 	// SYS_NOSYS = 179;  // { int nosys(void); }
-	SYS_KDEBUG_TRACE	= 180;	// { int kdebug_trace(int code, int arg1, int arg2, int arg3, int arg4, int arg5) NO_SYSCALL_STUB; }
-	SYS_SETGID		= 181;	// { int setgid(gid_t gid); }
-	SYS_SETEGID		= 182;	// { int setegid(gid_t egid); }
-	SYS_SETEUID		= 183;	// { int seteuid(uid_t euid); }
-	SYS_SIGRETURN		= 184;	// { int sigreturn(struct ucontext *uctx, int infostyle); }
+	SYS_KDEBUG_TRACE = 180 // { int kdebug_trace(int code, int arg1, int arg2, int arg3, int arg4, int arg5) NO_SYSCALL_STUB; }
+	SYS_SETGID       = 181 // { int setgid(gid_t gid); }
+	SYS_SETEGID      = 182 // { int setegid(gid_t egid); }
+	SYS_SETEUID      = 183 // { int seteuid(uid_t euid); }
+	SYS_SIGRETURN    = 184 // { int sigreturn(struct ucontext *uctx, int infostyle); }
 	// SYS_NOSYS = 186;  // { int nosys(void); }
 	// SYS_NOSYS = 187;  // { int nosys(void); }
-	SYS_STAT	= 188;	// { int stat(user_addr_t path, user_addr_t ub); }
-	SYS_FSTAT	= 189;	// { int fstat(int fd, user_addr_t ub); }
-	SYS_LSTAT	= 190;	// { int lstat(user_addr_t path, user_addr_t ub); }
-	SYS_PATHCONF	= 191;	// { int pathconf(char *path, int name); }
-	SYS_FPATHCONF	= 192;	// { int fpathconf(int fd, int name); }
+	SYS_STAT      = 188 // { int stat(user_addr_t path, user_addr_t ub); }
+	SYS_FSTAT     = 189 // { int fstat(int fd, user_addr_t ub); }
+	SYS_LSTAT     = 190 // { int lstat(user_addr_t path, user_addr_t ub); }
+	SYS_PATHCONF  = 191 // { int pathconf(char *path, int name); }
+	SYS_FPATHCONF = 192 // { int fpathconf(int fd, int name); }
 	// SYS_NOSYS = 193;  // { int nosys(void); }
-	SYS_GETRLIMIT		= 194;	// { int getrlimit(u_int which, struct rlimit *rlp); }
-	SYS_SETRLIMIT		= 195;	// { int setrlimit(u_int which, struct rlimit *rlp); }
-	SYS_GETDIRENTRIES	= 196;	// { int getdirentries(int fd, char *buf, u_int count, long *basep); }
-	SYS_MMAP		= 197;	// { user_addr_t mmap(caddr_t addr, size_t len, int prot, int flags, int fd, off_t pos); }
+	SYS_GETRLIMIT     = 194 // { int getrlimit(u_int which, struct rlimit *rlp); }
+	SYS_SETRLIMIT     = 195 // { int setrlimit(u_int which, struct rlimit *rlp); }
+	SYS_GETDIRENTRIES = 196 // { int getdirentries(int fd, char *buf, u_int count, long *basep); }
+	SYS_MMAP          = 197 // { user_addr_t mmap(caddr_t addr, size_t len, int prot, int flags, int fd, off_t pos); }
 	// SYS_NOSYS = 198;  // { int nosys(void); } 	{ __syscall }
-	SYS_LSEEK	= 199;	// { off_t lseek(int fd, off_t offset, int whence); }
-	SYS_TRUNCATE	= 200;	// { int truncate(char *path, off_t length); }
-	SYS_FTRUNCATE	= 201;	// { int ftruncate(int fd, off_t length); }
-	SYS___SYSCTL	= 202;	// { int __sysctl(int *name, u_int namelen, void *old, size_t *oldlenp, void *new, size_t newlen); }
-	SYS_MLOCK	= 203;	// { int mlock(caddr_t addr, size_t len); }
-	SYS_MUNLOCK	= 204;	// { int munlock(caddr_t addr, size_t len); }
-	SYS_UNDELETE	= 205;	// { int undelete(user_addr_t path); }
-	SYS_ATSOCKET	= 206;	// { int ATsocket(int proto); }
+	SYS_LSEEK     = 199 // { off_t lseek(int fd, off_t offset, int whence); }
+	SYS_TRUNCATE  = 200 // { int truncate(char *path, off_t length); }
+	SYS_FTRUNCATE = 201 // { int ftruncate(int fd, off_t length); }
+	SYS___SYSCTL  = 202 // { int __sysctl(int *name, u_int namelen, void *old, size_t *oldlenp, void *new, size_t newlen); }
+	SYS_MLOCK     = 203 // { int mlock(caddr_t addr, size_t len); }
+	SYS_MUNLOCK   = 204 // { int munlock(caddr_t addr, size_t len); }
+	SYS_UNDELETE  = 205 // { int undelete(user_addr_t path); }
+	SYS_ATSOCKET  = 206 // { int ATsocket(int proto); }
 	// SYS_NOSYS = 213;  // { int nosys(void); } 	{ Reserved for AppleTalk }
 	// SYS_NOSYS = 206;  // { int nosys(void); }
 	// SYS_NOSYS = 207;  // { int nosys(void); }
@@ -237,166 +237,166 @@ const (
 	// SYS_NOSYS = 211;  // { int nosys(void); }
 	// SYS_NOSYS = 212;  // { int nosys(void); }
 	// SYS_NOSYS = 213;  // { int nosys(void); } 	{ Reserved for AppleTalk }
-	SYS_KQUEUE_FROM_PORTSET_NP	= 214;	// { int kqueue_from_portset_np(int portset); }
-	SYS_KQUEUE_PORTSET_NP		= 215;	// { int kqueue_portset_np(int fd); }
-	SYS_GETATTRLIST			= 220;	// { int getattrlist(const char *path, struct attrlist *alist, void *attributeBuffer, size_t bufferSize, u_long options); }
-	SYS_SETATTRLIST			= 221;	// { int setattrlist(const char *path, struct attrlist *alist, void *attributeBuffer, size_t bufferSize, u_long options); }
-	SYS_GETDIRENTRIESATTR		= 222;	// { int getdirentriesattr(int fd, struct attrlist *alist, void *buffer, size_t buffersize, u_long *count, u_long *basep, u_long *newstate, u_long options); }
-	SYS_EXCHANGEDATA		= 223;	// { int exchangedata(const char *path1, const char *path2, u_long options); }
+	SYS_KQUEUE_FROM_PORTSET_NP = 214 // { int kqueue_from_portset_np(int portset); }
+	SYS_KQUEUE_PORTSET_NP      = 215 // { int kqueue_portset_np(int fd); }
+	SYS_GETATTRLIST            = 220 // { int getattrlist(const char *path, struct attrlist *alist, void *attributeBuffer, size_t bufferSize, u_long options); }
+	SYS_SETATTRLIST            = 221 // { int setattrlist(const char *path, struct attrlist *alist, void *attributeBuffer, size_t bufferSize, u_long options); }
+	SYS_GETDIRENTRIESATTR      = 222 // { int getdirentriesattr(int fd, struct attrlist *alist, void *buffer, size_t buffersize, u_long *count, u_long *basep, u_long *newstate, u_long options); }
+	SYS_EXCHANGEDATA           = 223 // { int exchangedata(const char *path1, const char *path2, u_long options); }
 	// SYS_NOSYS = 224;  // { int nosys(void); } { was checkuseraccess }
-	SYS_SEARCHFS	= 225;	// { int searchfs(const char *path, struct fssearchblock *searchblock, u_long *nummatches, u_long scriptcode, u_long options, struct searchstate *state); }
-	SYS_DELETE	= 226;	// { int delete(user_addr_t path) NO_SYSCALL_STUB; }       { private delete (Carbon semantics) }
-	SYS_COPYFILE	= 227;	// { int copyfile(char *from, char *to, int mode, int flags) NO_SYSCALL_STUB; }
+	SYS_SEARCHFS = 225 // { int searchfs(const char *path, struct fssearchblock *searchblock, u_long *nummatches, u_long scriptcode, u_long options, struct searchstate *state); }
+	SYS_DELETE   = 226 // { int delete(user_addr_t path) NO_SYSCALL_STUB; }       { private delete (Carbon semantics) }
+	SYS_COPYFILE = 227 // { int copyfile(char *from, char *to, int mode, int flags) NO_SYSCALL_STUB; }
 	// SYS_NOSYS = 228;  // { int nosys(void); }
 	// SYS_NOSYS = 229;  // { int nosys(void); }
-	SYS_POLL		= 230;	// { int poll(struct pollfd *fds, u_int nfds, int timeout); }
-	SYS_WATCHEVENT		= 231;	// { int watchevent(struct eventreq *u_req, int u_eventmask); }
-	SYS_WAITEVENT		= 232;	// { int waitevent(struct eventreq *u_req, struct timeval *tv); }
-	SYS_MODWATCH		= 233;	// { int modwatch(struct eventreq *u_req, int u_eventmask); }
-	SYS_GETXATTR		= 234;	// { user_ssize_t getxattr(user_addr_t path, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
-	SYS_FGETXATTR		= 235;	// { user_ssize_t fgetxattr(int fd, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
-	SYS_SETXATTR		= 236;	// { int setxattr(user_addr_t path, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
-	SYS_FSETXATTR		= 237;	// { int fsetxattr(int fd, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
-	SYS_REMOVEXATTR		= 238;	// { int removexattr(user_addr_t path, user_addr_t attrname, int options); }
-	SYS_FREMOVEXATTR	= 239;	// { int fremovexattr(int fd, user_addr_t attrname, int options); }
-	SYS_LISTXATTR		= 240;	// { user_ssize_t listxattr(user_addr_t path, user_addr_t namebuf, size_t bufsize, int options); }
-	SYS_FLISTXATTR		= 241;	// { user_ssize_t flistxattr(int fd, user_addr_t namebuf, size_t bufsize, int options); }
-	SYS_FSCTL		= 242;	// { int fsctl(const char *path, u_long cmd, caddr_t data, u_long options); }
-	SYS_INITGROUPS		= 243;	// { int initgroups(u_int gidsetsize, gid_t *gidset, int gmuid); }
-	SYS_POSIX_SPAWN		= 244;	// { int posix_spawn(pid_t *pid, const char *path, const struct _posix_spawn_args_desc *adesc, char **argv, char **envp); }
+	SYS_POLL         = 230 // { int poll(struct pollfd *fds, u_int nfds, int timeout); }
+	SYS_WATCHEVENT   = 231 // { int watchevent(struct eventreq *u_req, int u_eventmask); }
+	SYS_WAITEVENT    = 232 // { int waitevent(struct eventreq *u_req, struct timeval *tv); }
+	SYS_MODWATCH     = 233 // { int modwatch(struct eventreq *u_req, int u_eventmask); }
+	SYS_GETXATTR     = 234 // { user_ssize_t getxattr(user_addr_t path, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
+	SYS_FGETXATTR    = 235 // { user_ssize_t fgetxattr(int fd, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
+	SYS_SETXATTR     = 236 // { int setxattr(user_addr_t path, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
+	SYS_FSETXATTR    = 237 // { int fsetxattr(int fd, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
+	SYS_REMOVEXATTR  = 238 // { int removexattr(user_addr_t path, user_addr_t attrname, int options); }
+	SYS_FREMOVEXATTR = 239 // { int fremovexattr(int fd, user_addr_t attrname, int options); }
+	SYS_LISTXATTR    = 240 // { user_ssize_t listxattr(user_addr_t path, user_addr_t namebuf, size_t bufsize, int options); }
+	SYS_FLISTXATTR   = 241 // { user_ssize_t flistxattr(int fd, user_addr_t namebuf, size_t bufsize, int options); }
+	SYS_FSCTL        = 242 // { int fsctl(const char *path, u_long cmd, caddr_t data, u_long options); }
+	SYS_INITGROUPS   = 243 // { int initgroups(u_int gidsetsize, gid_t *gidset, int gmuid); }
+	SYS_POSIX_SPAWN  = 244 // { int posix_spawn(pid_t *pid, const char *path, const struct _posix_spawn_args_desc *adesc, char **argv, char **envp); }
 	// SYS_NOSYS = 245;  // { int nosys(void); }
 	// SYS_NOSYS = 246;  // { int nosys(void); }
-	SYS_NFSCLNT	= 247;	// { int nfsclnt(int flag, caddr_t argp); }
+	SYS_NFSCLNT = 247 // { int nfsclnt(int flag, caddr_t argp); }
 	// SYS_NOSYS = 247;  // { int nosys(void); }
-	SYS_FHOPEN	= 248;	// { int fhopen(const struct fhandle *u_fhp, int flags); }
+	SYS_FHOPEN = 248 // { int fhopen(const struct fhandle *u_fhp, int flags); }
 	// SYS_NOSYS = 248;  // { int nosys(void); }
 	// SYS_NOSYS = 249;  // { int nosys(void); }
-	SYS_MINHERIT	= 250;	// { int minherit(void *addr, size_t len, int inherit); }
-	SYS_SEMSYS	= 251;	// { int semsys(u_int which, int a2, int a3, int a4, int a5); }
+	SYS_MINHERIT = 250 // { int minherit(void *addr, size_t len, int inherit); }
+	SYS_SEMSYS   = 251 // { int semsys(u_int which, int a2, int a3, int a4, int a5); }
 	// SYS_NOSYS = 251;  // { int nosys(void); }
-	SYS_MSGSYS	= 252;	// { int msgsys(u_int which, int a2, int a3, int a4, int a5); }
+	SYS_MSGSYS = 252 // { int msgsys(u_int which, int a2, int a3, int a4, int a5); }
 	// SYS_NOSYS = 252;  // { int nosys(void); }
-	SYS_SHMSYS	= 253;	// { int shmsys(u_int which, int a2, int a3, int a4); }
+	SYS_SHMSYS = 253 // { int shmsys(u_int which, int a2, int a3, int a4); }
 	// SYS_NOSYS = 253;  // { int nosys(void); }
-	SYS_SEMCTL	= 254;	// { int semctl(int semid, int semnum, int cmd, semun_t arg); }
-	SYS_SEMGET	= 255;	// { int semget(key_t key, int	nsems, int semflg); }
-	SYS_SEMOP	= 256;	// { int semop(int semid, struct sembuf *sops, int nsops); }
+	SYS_SEMCTL = 254 // { int semctl(int semid, int semnum, int cmd, semun_t arg); }
+	SYS_SEMGET = 255 // { int semget(key_t key, int	nsems, int semflg); }
+	SYS_SEMOP  = 256 // { int semop(int semid, struct sembuf *sops, int nsops); }
 	// SYS_NOSYS = 257;  // { int nosys(void); }
 	// SYS_NOSYS = 254;  // { int nosys(void); }
 	// SYS_NOSYS = 255;  // { int nosys(void); }
 	// SYS_NOSYS = 256;  // { int nosys(void); }
 	// SYS_NOSYS = 257;  // { int nosys(void); }
-	SYS_MSGCTL	= 258;	// { int msgctl(int msqid, int cmd, struct	msqid_ds *buf); }
-	SYS_MSGGET	= 259;	// { int msgget(key_t key, int msgflg); }
-	SYS_MSGSND	= 260;	// { int msgsnd(int msqid, void *msgp, size_t msgsz, int msgflg); }
-	SYS_MSGRCV	= 261;	// { user_ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); }
+	SYS_MSGCTL = 258 // { int msgctl(int msqid, int cmd, struct	msqid_ds *buf); }
+	SYS_MSGGET = 259 // { int msgget(key_t key, int msgflg); }
+	SYS_MSGSND = 260 // { int msgsnd(int msqid, void *msgp, size_t msgsz, int msgflg); }
+	SYS_MSGRCV = 261 // { user_ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); }
 	// SYS_NOSYS = 258;  // { int nosys(void); }
 	// SYS_NOSYS = 259;  // { int nosys(void); }
 	// SYS_NOSYS = 260;  // { int nosys(void); }
 	// SYS_NOSYS = 261;  // { int nosys(void); }
-	SYS_SHMAT	= 262;	// { user_addr_t shmat(int shmid, void *shmaddr, int shmflg); }
-	SYS_SHMCTL	= 263;	// { int shmctl(int shmid, int cmd, struct shmid_ds *buf); }
-	SYS_SHMDT	= 264;	// { int shmdt(void *shmaddr); }
-	SYS_SHMGET	= 265;	// { int shmget(key_t key, size_t size, int shmflg); }
+	SYS_SHMAT  = 262 // { user_addr_t shmat(int shmid, void *shmaddr, int shmflg); }
+	SYS_SHMCTL = 263 // { int shmctl(int shmid, int cmd, struct shmid_ds *buf); }
+	SYS_SHMDT  = 264 // { int shmdt(void *shmaddr); }
+	SYS_SHMGET = 265 // { int shmget(key_t key, size_t size, int shmflg); }
 	// SYS_NOSYS = 262;  // { int nosys(void); }
 	// SYS_NOSYS = 263;  // { int nosys(void); }
 	// SYS_NOSYS = 264;  // { int nosys(void); }
 	// SYS_NOSYS = 265;  // { int nosys(void); }
-	SYS_SHM_OPEN			= 266;	// { int shm_open(const char *name, int oflag, int mode); }
-	SYS_SHM_UNLINK			= 267;	// { int shm_unlink(const char *name); }
-	SYS_SEM_OPEN			= 268;	// { user_addr_t sem_open(const char *name, int oflag, int mode, int value); }
-	SYS_SEM_CLOSE			= 269;	// { int sem_close(sem_t *sem); }
-	SYS_SEM_UNLINK			= 270;	// { int sem_unlink(const char *name); }
-	SYS_SEM_WAIT			= 271;	// { int sem_wait(sem_t *sem); }
-	SYS_SEM_TRYWAIT			= 272;	// { int sem_trywait(sem_t *sem); }
-	SYS_SEM_POST			= 273;	// { int sem_post(sem_t *sem); }
-	SYS_SEM_GETVALUE		= 274;	// { int sem_getvalue(sem_t *sem, int *sval); }
-	SYS_SEM_INIT			= 275;	// { int sem_init(sem_t *sem, int phsared, u_int value); }
-	SYS_SEM_DESTROY			= 276;	// { int sem_destroy(sem_t *sem); }
-	SYS_OPEN_EXTENDED		= 277;	// { int open_extended(user_addr_t path, int flags, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
-	SYS_UMASK_EXTENDED		= 278;	// { int umask_extended(int newmask, user_addr_t xsecurity) NO_SYSCALL_STUB; }
-	SYS_STAT_EXTENDED		= 279;	// { int stat_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
-	SYS_LSTAT_EXTENDED		= 280;	// { int lstat_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
-	SYS_FSTAT_EXTENDED		= 281;	// { int fstat_extended(int fd, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
-	SYS_CHMOD_EXTENDED		= 282;	// { int chmod_extended(user_addr_t path, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
-	SYS_FCHMOD_EXTENDED		= 283;	// { int fchmod_extended(int fd, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
-	SYS_ACCESS_EXTENDED		= 284;	// { int access_extended(user_addr_t entries, size_t size, user_addr_t results, uid_t uid) NO_SYSCALL_STUB; }
-	SYS_SETTID			= 285;	// { int settid(uid_t uid, gid_t gid) NO_SYSCALL_STUB; }
-	SYS_GETTID			= 286;	// { int gettid(uid_t *uidp, gid_t *gidp) NO_SYSCALL_STUB; }
-	SYS_SETSGROUPS			= 287;	// { int setsgroups(int setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
-	SYS_GETSGROUPS			= 288;	// { int getsgroups(user_addr_t setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
-	SYS_SETWGROUPS			= 289;	// { int setwgroups(int setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
-	SYS_GETWGROUPS			= 290;	// { int getwgroups(user_addr_t setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
-	SYS_MKFIFO_EXTENDED		= 291;	// { int mkfifo_extended(user_addr_t path, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
-	SYS_MKDIR_EXTENDED		= 292;	// { int mkdir_extended(user_addr_t path, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
-	SYS_IDENTITYSVC			= 293;	// { int identitysvc(int opcode, user_addr_t message) NO_SYSCALL_STUB; }
-	SYS_SHARED_REGION_CHECK_NP	= 294;	// { int shared_region_check_np(uint64_t *start_address) NO_SYSCALL_STUB; }
-	SYS_SHARED_REGION_MAP_NP	= 295;	// { int shared_region_map_np(int fd, uint32_t count, const struct shared_file_mapping_np *mappings) NO_SYSCALL_STUB; }
+	SYS_SHM_OPEN               = 266 // { int shm_open(const char *name, int oflag, int mode); }
+	SYS_SHM_UNLINK             = 267 // { int shm_unlink(const char *name); }
+	SYS_SEM_OPEN               = 268 // { user_addr_t sem_open(const char *name, int oflag, int mode, int value); }
+	SYS_SEM_CLOSE              = 269 // { int sem_close(sem_t *sem); }
+	SYS_SEM_UNLINK             = 270 // { int sem_unlink(const char *name); }
+	SYS_SEM_WAIT               = 271 // { int sem_wait(sem_t *sem); }
+	SYS_SEM_TRYWAIT            = 272 // { int sem_trywait(sem_t *sem); }
+	SYS_SEM_POST               = 273 // { int sem_post(sem_t *sem); }
+	SYS_SEM_GETVALUE           = 274 // { int sem_getvalue(sem_t *sem, int *sval); }
+	SYS_SEM_INIT               = 275 // { int sem_init(sem_t *sem, int phsared, u_int value); }
+	SYS_SEM_DESTROY            = 276 // { int sem_destroy(sem_t *sem); }
+	SYS_OPEN_EXTENDED          = 277 // { int open_extended(user_addr_t path, int flags, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_UMASK_EXTENDED         = 278 // { int umask_extended(int newmask, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_STAT_EXTENDED          = 279 // { int stat_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_LSTAT_EXTENDED         = 280 // { int lstat_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_FSTAT_EXTENDED         = 281 // { int fstat_extended(int fd, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_CHMOD_EXTENDED         = 282 // { int chmod_extended(user_addr_t path, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_FCHMOD_EXTENDED        = 283 // { int fchmod_extended(int fd, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_ACCESS_EXTENDED        = 284 // { int access_extended(user_addr_t entries, size_t size, user_addr_t results, uid_t uid) NO_SYSCALL_STUB; }
+	SYS_SETTID                 = 285 // { int settid(uid_t uid, gid_t gid) NO_SYSCALL_STUB; }
+	SYS_GETTID                 = 286 // { int gettid(uid_t *uidp, gid_t *gidp) NO_SYSCALL_STUB; }
+	SYS_SETSGROUPS             = 287 // { int setsgroups(int setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
+	SYS_GETSGROUPS             = 288 // { int getsgroups(user_addr_t setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
+	SYS_SETWGROUPS             = 289 // { int setwgroups(int setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
+	SYS_GETWGROUPS             = 290 // { int getwgroups(user_addr_t setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
+	SYS_MKFIFO_EXTENDED        = 291 // { int mkfifo_extended(user_addr_t path, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_MKDIR_EXTENDED         = 292 // { int mkdir_extended(user_addr_t path, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_IDENTITYSVC            = 293 // { int identitysvc(int opcode, user_addr_t message) NO_SYSCALL_STUB; }
+	SYS_SHARED_REGION_CHECK_NP = 294 // { int shared_region_check_np(uint64_t *start_address) NO_SYSCALL_STUB; }
+	SYS_SHARED_REGION_MAP_NP   = 295 // { int shared_region_map_np(int fd, uint32_t count, const struct shared_file_mapping_np *mappings) NO_SYSCALL_STUB; }
 	// SYS_NOSYS = 296;  // { int nosys(void); } { old load_shared_file }
 	// SYS_NOSYS = 297;  // { int nosys(void); } { old reset_shared_file }
 	// SYS_NOSYS = 298;  // { int nosys(void); } { old new_system_shared_regions }
 	// SYS_ENOSYS = 299;  // { int enosys(void); } { old shared_region_map_file_np }
 	// SYS_ENOSYS = 300;  // { int enosys(void); } { old shared_region_make_private_np }
-	SYS___PTHREAD_MUTEX_DESTROY	= 301;	// { int __pthread_mutex_destroy(int mutexid); }
-	SYS___PTHREAD_MUTEX_INIT	= 302;	// { int __pthread_mutex_init(user_addr_t  mutex, user_addr_t attr); }
-	SYS___PTHREAD_MUTEX_LOCK	= 303;	// { int __pthread_mutex_lock(int mutexid); }
-	SYS___PTHREAD_MUTEX_TRYLOCK	= 304;	// { int __pthread_mutex_trylock(int mutexid); }
-	SYS___PTHREAD_MUTEX_UNLOCK	= 305;	// { int __pthread_mutex_unlock(int mutexid); }
-	SYS___PTHREAD_COND_INIT		= 306;	// { int __pthread_cond_init(user_addr_t cond, user_addr_t attr); }
-	SYS___PTHREAD_COND_DESTROY	= 307;	// { int __pthread_cond_destroy(int condid); }
-	SYS___PTHREAD_COND_BROADCAST	= 308;	// { int __pthread_cond_broadcast(int condid); }
-	SYS___PTHREAD_COND_SIGNAL	= 309;	// { int __pthread_cond_signal(int condid); }
-	SYS_GETSID			= 310;	// { int getsid(pid_t pid); }
-	SYS_SETTID_WITH_PID		= 311;	// { int settid_with_pid(pid_t pid, int assume) NO_SYSCALL_STUB; }
-	SYS___PTHREAD_COND_TIMEDWAIT	= 312;	// { int __pthread_cond_timedwait(int condid, int mutexid, user_addr_t abstime); }
-	SYS_AIO_FSYNC			= 313;	// { int aio_fsync(int op, user_addr_t aiocbp); }
-	SYS_AIO_RETURN			= 314;	// { user_ssize_t aio_return(user_addr_t aiocbp); }
-	SYS_AIO_SUSPEND			= 315;	// { int aio_suspend(user_addr_t aiocblist, int nent, user_addr_t timeoutp); }
-	SYS_AIO_CANCEL			= 316;	// { int aio_cancel(int fd, user_addr_t aiocbp); }
-	SYS_AIO_ERROR			= 317;	// { int aio_error(user_addr_t aiocbp); }
-	SYS_AIO_READ			= 318;	// { int aio_read(user_addr_t aiocbp); }
-	SYS_AIO_WRITE			= 319;	// { int aio_write(user_addr_t aiocbp); }
-	SYS_LIO_LISTIO			= 320;	// { int lio_listio(int mode, user_addr_t aiocblist, int nent, user_addr_t sigp); }
-	SYS___PTHREAD_COND_WAIT		= 321;	// { int __pthread_cond_wait(int condid, int mutexid); }
-	SYS_IOPOLICYSYS			= 322;	// { int iopolicysys(int cmd, void *arg) NO_SYSCALL_STUB; }
+	SYS___PTHREAD_MUTEX_DESTROY  = 301 // { int __pthread_mutex_destroy(int mutexid); }
+	SYS___PTHREAD_MUTEX_INIT     = 302 // { int __pthread_mutex_init(user_addr_t  mutex, user_addr_t attr); }
+	SYS___PTHREAD_MUTEX_LOCK     = 303 // { int __pthread_mutex_lock(int mutexid); }
+	SYS___PTHREAD_MUTEX_TRYLOCK  = 304 // { int __pthread_mutex_trylock(int mutexid); }
+	SYS___PTHREAD_MUTEX_UNLOCK   = 305 // { int __pthread_mutex_unlock(int mutexid); }
+	SYS___PTHREAD_COND_INIT      = 306 // { int __pthread_cond_init(user_addr_t cond, user_addr_t attr); }
+	SYS___PTHREAD_COND_DESTROY   = 307 // { int __pthread_cond_destroy(int condid); }
+	SYS___PTHREAD_COND_BROADCAST = 308 // { int __pthread_cond_broadcast(int condid); }
+	SYS___PTHREAD_COND_SIGNAL    = 309 // { int __pthread_cond_signal(int condid); }
+	SYS_GETSID                   = 310 // { int getsid(pid_t pid); }
+	SYS_SETTID_WITH_PID          = 311 // { int settid_with_pid(pid_t pid, int assume) NO_SYSCALL_STUB; }
+	SYS___PTHREAD_COND_TIMEDWAIT = 312 // { int __pthread_cond_timedwait(int condid, int mutexid, user_addr_t abstime); }
+	SYS_AIO_FSYNC                = 313 // { int aio_fsync(int op, user_addr_t aiocbp); }
+	SYS_AIO_RETURN               = 314 // { user_ssize_t aio_return(user_addr_t aiocbp); }
+	SYS_AIO_SUSPEND              = 315 // { int aio_suspend(user_addr_t aiocblist, int nent, user_addr_t timeoutp); }
+	SYS_AIO_CANCEL               = 316 // { int aio_cancel(int fd, user_addr_t aiocbp); }
+	SYS_AIO_ERROR                = 317 // { int aio_error(user_addr_t aiocbp); }
+	SYS_AIO_READ                 = 318 // { int aio_read(user_addr_t aiocbp); }
+	SYS_AIO_WRITE                = 319 // { int aio_write(user_addr_t aiocbp); }
+	SYS_LIO_LISTIO               = 320 // { int lio_listio(int mode, user_addr_t aiocblist, int nent, user_addr_t sigp); }
+	SYS___PTHREAD_COND_WAIT      = 321 // { int __pthread_cond_wait(int condid, int mutexid); }
+	SYS_IOPOLICYSYS              = 322 // { int iopolicysys(int cmd, void *arg) NO_SYSCALL_STUB; }
 	// SYS_NOSYS = 323;  // { int nosys(void); }
-	SYS_MLOCKALL	= 324;	// { int mlockall(int how); }
-	SYS_MUNLOCKALL	= 325;	// { int munlockall(int how); }
+	SYS_MLOCKALL   = 324 // { int mlockall(int how); }
+	SYS_MUNLOCKALL = 325 // { int munlockall(int how); }
 	// SYS_NOSYS = 326;  // { int nosys(void); }
-	SYS_ISSETUGID			= 327;	// { int issetugid(void); }
-	SYS___PTHREAD_KILL		= 328;	// { int __pthread_kill(int thread_port, int sig); }
-	SYS___PTHREAD_SIGMASK		= 329;	// { int __pthread_sigmask(int how, user_addr_t set, user_addr_t oset); }
-	SYS___SIGWAIT			= 330;	// { int __sigwait(user_addr_t set, user_addr_t sig); }
-	SYS___DISABLE_THREADSIGNAL	= 331;	// { int __disable_threadsignal(int value); }
-	SYS___PTHREAD_MARKCANCEL	= 332;	// { int __pthread_markcancel(int thread_port); }
-	SYS___PTHREAD_CANCELED		= 333;	// { int __pthread_canceled(int  action); }
-	SYS___SEMWAIT_SIGNAL		= 334;	// { int __semwait_signal(int cond_sem, int mutex_sem, int timeout, int relative, time_t tv_sec, int32_t tv_nsec); }
+	SYS_ISSETUGID              = 327 // { int issetugid(void); }
+	SYS___PTHREAD_KILL         = 328 // { int __pthread_kill(int thread_port, int sig); }
+	SYS___PTHREAD_SIGMASK      = 329 // { int __pthread_sigmask(int how, user_addr_t set, user_addr_t oset); }
+	SYS___SIGWAIT              = 330 // { int __sigwait(user_addr_t set, user_addr_t sig); }
+	SYS___DISABLE_THREADSIGNAL = 331 // { int __disable_threadsignal(int value); }
+	SYS___PTHREAD_MARKCANCEL   = 332 // { int __pthread_markcancel(int thread_port); }
+	SYS___PTHREAD_CANCELED     = 333 // { int __pthread_canceled(int  action); }
+	SYS___SEMWAIT_SIGNAL       = 334 // { int __semwait_signal(int cond_sem, int mutex_sem, int timeout, int relative, time_t tv_sec, int32_t tv_nsec); }
 	// SYS_NOSYS = 335;  // { int nosys(void); }   { old utrace }
-	SYS_PROC_INFO	= 336;	// { int proc_info(int32_t callnum,int32_t pid,uint32_t flavor, uint64_t arg,user_addr_t buffer,int32_t buffersize) NO_SYSCALL_STUB; }
-	SYS_SENDFILE	= 337;	// { int sendfile(int fd, int s, off_t offset, off_t *nbytes, struct sf_hdtr *hdtr, int flags); }
+	SYS_PROC_INFO = 336 // { int proc_info(int32_t callnum,int32_t pid,uint32_t flavor, uint64_t arg,user_addr_t buffer,int32_t buffersize) NO_SYSCALL_STUB; }
+	SYS_SENDFILE  = 337 // { int sendfile(int fd, int s, off_t offset, off_t *nbytes, struct sf_hdtr *hdtr, int flags); }
 	// SYS_NOSYS = 337;  // { int nosys(void); }
-	SYS_STAT64		= 338;	// { int stat64(user_addr_t path, user_addr_t ub); }
-	SYS_FSTAT64		= 339;	// { int fstat64(int fd, user_addr_t ub); }
-	SYS_LSTAT64		= 340;	// { int lstat64(user_addr_t path, user_addr_t ub); }
-	SYS_STAT64_EXTENDED	= 341;	// { int stat64_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
-	SYS_LSTAT64_EXTENDED	= 342;	// { int lstat64_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
-	SYS_FSTAT64_EXTENDED	= 343;	// { int fstat64_extended(int fd, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
-	SYS_GETDIRENTRIES64	= 344;	// { user_ssize_t getdirentries64(int fd, void *buf, user_size_t bufsize, off_t *position) NO_SYSCALL_STUB; }
-	SYS_STATFS64		= 345;	// { int statfs64(char *path, struct statfs64 *buf); }
-	SYS_FSTATFS64		= 346;	// { int fstatfs64(int fd, struct statfs64 *buf); }
-	SYS_GETFSSTAT64		= 347;	// { int getfsstat64(user_addr_t buf, int bufsize, int flags); }
-	SYS___PTHREAD_CHDIR	= 348;	// { int __pthread_chdir(user_addr_t path); }
-	SYS___PTHREAD_FCHDIR	= 349;	// { int __pthread_fchdir(int fd); }
-	SYS_AUDIT		= 350;	// { int audit(void *record, int length); }
-	SYS_AUDITON		= 351;	// { int auditon(int cmd, void *data, int length); }
+	SYS_STAT64           = 338 // { int stat64(user_addr_t path, user_addr_t ub); }
+	SYS_FSTAT64          = 339 // { int fstat64(int fd, user_addr_t ub); }
+	SYS_LSTAT64          = 340 // { int lstat64(user_addr_t path, user_addr_t ub); }
+	SYS_STAT64_EXTENDED  = 341 // { int stat64_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_LSTAT64_EXTENDED = 342 // { int lstat64_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_FSTAT64_EXTENDED = 343 // { int fstat64_extended(int fd, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_GETDIRENTRIES64  = 344 // { user_ssize_t getdirentries64(int fd, void *buf, user_size_t bufsize, off_t *position) NO_SYSCALL_STUB; }
+	SYS_STATFS64         = 345 // { int statfs64(char *path, struct statfs64 *buf); }
+	SYS_FSTATFS64        = 346 // { int fstatfs64(int fd, struct statfs64 *buf); }
+	SYS_GETFSSTAT64      = 347 // { int getfsstat64(user_addr_t buf, int bufsize, int flags); }
+	SYS___PTHREAD_CHDIR  = 348 // { int __pthread_chdir(user_addr_t path); }
+	SYS___PTHREAD_FCHDIR = 349 // { int __pthread_fchdir(int fd); }
+	SYS_AUDIT            = 350 // { int audit(void *record, int length); }
+	SYS_AUDITON          = 351 // { int auditon(int cmd, void *data, int length); }
 	// SYS_NOSYS = 352;  // { int nosys(void); }
-	SYS_GETAUID		= 353;	// { int getauid(au_id_t *auid); }
-	SYS_SETAUID		= 354;	// { int setauid(au_id_t *auid); }
-	SYS_GETAUDIT		= 355;	// { int getaudit(struct auditinfo *auditinfo); }
-	SYS_SETAUDIT		= 356;	// { int setaudit(struct auditinfo *auditinfo); }
-	SYS_GETAUDIT_ADDR	= 357;	// { int getaudit_addr(struct auditinfo_addr *auditinfo_addr, int length); }
-	SYS_SETAUDIT_ADDR	= 358;	// { int setaudit_addr(struct auditinfo_addr *auditinfo_addr, int length); }
-	SYS_AUDITCTL		= 359;	// { int auditctl(char *path); }
+	SYS_GETAUID       = 353 // { int getauid(au_id_t *auid); }
+	SYS_SETAUID       = 354 // { int setauid(au_id_t *auid); }
+	SYS_GETAUDIT      = 355 // { int getaudit(struct auditinfo *auditinfo); }
+	SYS_SETAUDIT      = 356 // { int setaudit(struct auditinfo *auditinfo); }
+	SYS_GETAUDIT_ADDR = 357 // { int getaudit_addr(struct auditinfo_addr *auditinfo_addr, int length); }
+	SYS_SETAUDIT_ADDR = 358 // { int setaudit_addr(struct auditinfo_addr *auditinfo_addr, int length); }
+	SYS_AUDITCTL      = 359 // { int auditctl(char *path); }
 	// SYS_NOSYS = 350;  // { int nosys(void); }
 	// SYS_NOSYS = 351;  // { int nosys(void); }
 	// SYS_NOSYS = 352;  // { int nosys(void); }
@@ -407,15 +407,15 @@ const (
 	// SYS_NOSYS = 357;  // { int nosys(void); }
 	// SYS_NOSYS = 358;  // { int nosys(void); }
 	// SYS_NOSYS = 359;  // { int nosys(void); }
-	SYS_BSDTHREAD_CREATE	= 360;	// { user_addr_t bsdthread_create(user_addr_t func, user_addr_t func_arg, user_addr_t stack, user_addr_t pthread, uint32_t flags) NO_SYSCALL_STUB; }
-	SYS_BSDTHREAD_TERMINATE	= 361;	// { int bsdthread_terminate(user_addr_t stackaddr, size_t freesize, uint32_t port, uint32_t sem) NO_SYSCALL_STUB; }
-	SYS_KQUEUE		= 362;	// { int kqueue(void); }
-	SYS_KEVENT		= 363;	// { int kevent(int fd, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout); }
-	SYS_LCHOWN		= 364;	// { int lchown(user_addr_t path, uid_t owner, gid_t group); }
-	SYS_STACK_SNAPSHOT	= 365;	// { int stack_snapshot(pid_t pid, user_addr_t tracebuf, uint32_t tracebuf_size, uint32_t options) NO_SYSCALL_STUB; }
-	SYS_BSDTHREAD_REGISTER	= 366;	// { int bsdthread_register(user_addr_t threadstart, user_addr_t wqthread, int pthsize) NO_SYSCALL_STUB; }
-	SYS_WORKQ_OPEN		= 367;	// { int workq_open(void) NO_SYSCALL_STUB; }
-	SYS_WORKQ_OPS		= 368;	// { int workq_ops(int options, user_addr_t item, int prio) NO_SYSCALL_STUB; }
+	SYS_BSDTHREAD_CREATE    = 360 // { user_addr_t bsdthread_create(user_addr_t func, user_addr_t func_arg, user_addr_t stack, user_addr_t pthread, uint32_t flags) NO_SYSCALL_STUB; }
+	SYS_BSDTHREAD_TERMINATE = 361 // { int bsdthread_terminate(user_addr_t stackaddr, size_t freesize, uint32_t port, uint32_t sem) NO_SYSCALL_STUB; }
+	SYS_KQUEUE              = 362 // { int kqueue(void); }
+	SYS_KEVENT              = 363 // { int kevent(int fd, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout); }
+	SYS_LCHOWN              = 364 // { int lchown(user_addr_t path, uid_t owner, gid_t group); }
+	SYS_STACK_SNAPSHOT      = 365 // { int stack_snapshot(pid_t pid, user_addr_t tracebuf, uint32_t tracebuf_size, uint32_t options) NO_SYSCALL_STUB; }
+	SYS_BSDTHREAD_REGISTER  = 366 // { int bsdthread_register(user_addr_t threadstart, user_addr_t wqthread, int pthsize) NO_SYSCALL_STUB; }
+	SYS_WORKQ_OPEN          = 367 // { int workq_open(void) NO_SYSCALL_STUB; }
+	SYS_WORKQ_OPS           = 368 // { int workq_ops(int options, user_addr_t item, int prio) NO_SYSCALL_STUB; }
 	// SYS_NOSYS = 369;  // { int nosys(void); }
 	// SYS_NOSYS = 370;  // { int nosys(void); }
 	// SYS_NOSYS = 371;  // { int nosys(void); }
@@ -427,59 +427,59 @@ const (
 	// SYS_NOSYS = 377;  // { int nosys(void); }
 	// SYS_NOSYS = 378;  // { int nosys(void); }
 	// SYS_NOSYS = 379;  // { int nosys(void); }
-	SYS___MAC_EXECVE	= 380;	// { int __mac_execve(char *fname, char **argp, char **envp, struct mac *mac_p); }
-	SYS___MAC_SYSCALL	= 381;	// { int __mac_syscall(char *policy, int call, user_addr_t arg); }
-	SYS___MAC_GET_FILE	= 382;	// { int __mac_get_file(char *path_p, struct mac *mac_p); }
-	SYS___MAC_SET_FILE	= 383;	// { int __mac_set_file(char *path_p, struct mac *mac_p); }
-	SYS___MAC_GET_LINK	= 384;	// { int __mac_get_link(char *path_p, struct mac *mac_p); }
-	SYS___MAC_SET_LINK	= 385;	// { int __mac_set_link(char *path_p, struct mac *mac_p); }
-	SYS___MAC_GET_PROC	= 386;	// { int __mac_get_proc(struct mac *mac_p); }
-	SYS___MAC_SET_PROC	= 387;	// { int __mac_set_proc(struct mac *mac_p); }
-	SYS___MAC_GET_FD	= 388;	// { int __mac_get_fd(int fd, struct mac *mac_p); }
-	SYS___MAC_SET_FD	= 389;	// { int __mac_set_fd(int fd, struct mac *mac_p); }
-	SYS___MAC_GET_PID	= 390;	// { int __mac_get_pid(pid_t pid, struct mac *mac_p); }
-	SYS___MAC_GET_LCID	= 391;	// { int __mac_get_lcid(pid_t lcid, struct mac *mac_p); }
-	SYS___MAC_GET_LCTX	= 392;	// { int __mac_get_lctx(struct mac *mac_p); }
-	SYS___MAC_SET_LCTX	= 393;	// { int __mac_set_lctx(struct mac *mac_p); }
-	SYS_SETLCID		= 394;	// { int setlcid(pid_t pid, pid_t lcid) NO_SYSCALL_STUB; }
-	SYS_GETLCID		= 395;	// { int getlcid(pid_t pid) NO_SYSCALL_STUB; }
-	SYS_READ_NOCANCEL	= 396;	// { user_ssize_t read_nocancel(int fd, user_addr_t cbuf, user_size_t nbyte) NO_SYSCALL_STUB; }
-	SYS_WRITE_NOCANCEL	= 397;	// { user_ssize_t write_nocancel(int fd, user_addr_t cbuf, user_size_t nbyte) NO_SYSCALL_STUB; }
-	SYS_OPEN_NOCANCEL	= 398;	// { int open_nocancel(user_addr_t path, int flags, int mode) NO_SYSCALL_STUB; }
-	SYS_CLOSE_NOCANCEL	= 399;	// { int close_nocancel(int fd) NO_SYSCALL_STUB; }
-	SYS_WAIT4_NOCANCEL	= 400;	// { int wait4_nocancel(int pid, user_addr_t status, int options, user_addr_t rusage) NO_SYSCALL_STUB; }
-	SYS_RECVMSG_NOCANCEL	= 401;	// { int recvmsg_nocancel(int s, struct msghdr *msg, int flags) NO_SYSCALL_STUB; }
-	SYS_SENDMSG_NOCANCEL	= 402;	// { int sendmsg_nocancel(int s, caddr_t msg, int flags) NO_SYSCALL_STUB; }
-	SYS_RECVFROM_NOCANCEL	= 403;	// { int recvfrom_nocancel(int s, void *buf, size_t len, int flags, struct sockaddr *from, int *fromlenaddr) NO_SYSCALL_STUB; }
-	SYS_ACCEPT_NOCANCEL	= 404;	// { int accept_nocancel(int s, caddr_t name, socklen_t	*anamelen) NO_SYSCALL_STUB; }
+	SYS___MAC_EXECVE      = 380 // { int __mac_execve(char *fname, char **argp, char **envp, struct mac *mac_p); }
+	SYS___MAC_SYSCALL     = 381 // { int __mac_syscall(char *policy, int call, user_addr_t arg); }
+	SYS___MAC_GET_FILE    = 382 // { int __mac_get_file(char *path_p, struct mac *mac_p); }
+	SYS___MAC_SET_FILE    = 383 // { int __mac_set_file(char *path_p, struct mac *mac_p); }
+	SYS___MAC_GET_LINK    = 384 // { int __mac_get_link(char *path_p, struct mac *mac_p); }
+	SYS___MAC_SET_LINK    = 385 // { int __mac_set_link(char *path_p, struct mac *mac_p); }
+	SYS___MAC_GET_PROC    = 386 // { int __mac_get_proc(struct mac *mac_p); }
+	SYS___MAC_SET_PROC    = 387 // { int __mac_set_proc(struct mac *mac_p); }
+	SYS___MAC_GET_FD      = 388 // { int __mac_get_fd(int fd, struct mac *mac_p); }
+	SYS___MAC_SET_FD      = 389 // { int __mac_set_fd(int fd, struct mac *mac_p); }
+	SYS___MAC_GET_PID     = 390 // { int __mac_get_pid(pid_t pid, struct mac *mac_p); }
+	SYS___MAC_GET_LCID    = 391 // { int __mac_get_lcid(pid_t lcid, struct mac *mac_p); }
+	SYS___MAC_GET_LCTX    = 392 // { int __mac_get_lctx(struct mac *mac_p); }
+	SYS___MAC_SET_LCTX    = 393 // { int __mac_set_lctx(struct mac *mac_p); }
+	SYS_SETLCID           = 394 // { int setlcid(pid_t pid, pid_t lcid) NO_SYSCALL_STUB; }
+	SYS_GETLCID           = 395 // { int getlcid(pid_t pid) NO_SYSCALL_STUB; }
+	SYS_READ_NOCANCEL     = 396 // { user_ssize_t read_nocancel(int fd, user_addr_t cbuf, user_size_t nbyte) NO_SYSCALL_STUB; }
+	SYS_WRITE_NOCANCEL    = 397 // { user_ssize_t write_nocancel(int fd, user_addr_t cbuf, user_size_t nbyte) NO_SYSCALL_STUB; }
+	SYS_OPEN_NOCANCEL     = 398 // { int open_nocancel(user_addr_t path, int flags, int mode) NO_SYSCALL_STUB; }
+	SYS_CLOSE_NOCANCEL    = 399 // { int close_nocancel(int fd) NO_SYSCALL_STUB; }
+	SYS_WAIT4_NOCANCEL    = 400 // { int wait4_nocancel(int pid, user_addr_t status, int options, user_addr_t rusage) NO_SYSCALL_STUB; }
+	SYS_RECVMSG_NOCANCEL  = 401 // { int recvmsg_nocancel(int s, struct msghdr *msg, int flags) NO_SYSCALL_STUB; }
+	SYS_SENDMSG_NOCANCEL  = 402 // { int sendmsg_nocancel(int s, caddr_t msg, int flags) NO_SYSCALL_STUB; }
+	SYS_RECVFROM_NOCANCEL = 403 // { int recvfrom_nocancel(int s, void *buf, size_t len, int flags, struct sockaddr *from, int *fromlenaddr) NO_SYSCALL_STUB; }
+	SYS_ACCEPT_NOCANCEL   = 404 // { int accept_nocancel(int s, caddr_t name, socklen_t	*anamelen) NO_SYSCALL_STUB; }
 	// SYS_NOSYS = 401;  // { int nosys(void); }
 	// SYS_NOSYS = 402;  // { int nosys(void); }
 	// SYS_NOSYS = 403;  // { int nosys(void); }
 	// SYS_NOSYS = 404;  // { int nosys(void); }
-	SYS_MSYNC_NOCANCEL	= 405;	// { int msync_nocancel(caddr_t addr, size_t len, int flags) NO_SYSCALL_STUB; }
-	SYS_FCNTL_NOCANCEL	= 406;	// { int fcntl_nocancel(int fd, int cmd, long arg) NO_SYSCALL_STUB; }
-	SYS_SELECT_NOCANCEL	= 407;	// { int select_nocancel(int nd, u_int32_t *in, u_int32_t *ou, u_int32_t *ex, struct timeval *tv) NO_SYSCALL_STUB; }
-	SYS_FSYNC_NOCANCEL	= 408;	// { int fsync_nocancel(int fd) NO_SYSCALL_STUB; }
-	SYS_CONNECT_NOCANCEL	= 409;	// { int connect_nocancel(int s, caddr_t name, socklen_t namelen) NO_SYSCALL_STUB; }
+	SYS_MSYNC_NOCANCEL   = 405 // { int msync_nocancel(caddr_t addr, size_t len, int flags) NO_SYSCALL_STUB; }
+	SYS_FCNTL_NOCANCEL   = 406 // { int fcntl_nocancel(int fd, int cmd, long arg) NO_SYSCALL_STUB; }
+	SYS_SELECT_NOCANCEL  = 407 // { int select_nocancel(int nd, u_int32_t *in, u_int32_t *ou, u_int32_t *ex, struct timeval *tv) NO_SYSCALL_STUB; }
+	SYS_FSYNC_NOCANCEL   = 408 // { int fsync_nocancel(int fd) NO_SYSCALL_STUB; }
+	SYS_CONNECT_NOCANCEL = 409 // { int connect_nocancel(int s, caddr_t name, socklen_t namelen) NO_SYSCALL_STUB; }
 	// SYS_NOSYS = 409;  // { int nosys(void); }
-	SYS_SIGSUSPEND_NOCANCEL	= 410;	// { int sigsuspend_nocancel(sigset_t mask) NO_SYSCALL_STUB; }
-	SYS_READV_NOCANCEL	= 411;	// { user_ssize_t readv_nocancel(int fd, struct iovec *iovp, u_int iovcnt) NO_SYSCALL_STUB; }
-	SYS_WRITEV_NOCANCEL	= 412;	// { user_ssize_t writev_nocancel(int fd, struct iovec *iovp, u_int iovcnt) NO_SYSCALL_STUB; }
-	SYS_SENDTO_NOCANCEL	= 413;	// { int sendto_nocancel(int s, caddr_t buf, size_t len, int flags, caddr_t to, socklen_t tolen) NO_SYSCALL_STUB; }
+	SYS_SIGSUSPEND_NOCANCEL = 410 // { int sigsuspend_nocancel(sigset_t mask) NO_SYSCALL_STUB; }
+	SYS_READV_NOCANCEL      = 411 // { user_ssize_t readv_nocancel(int fd, struct iovec *iovp, u_int iovcnt) NO_SYSCALL_STUB; }
+	SYS_WRITEV_NOCANCEL     = 412 // { user_ssize_t writev_nocancel(int fd, struct iovec *iovp, u_int iovcnt) NO_SYSCALL_STUB; }
+	SYS_SENDTO_NOCANCEL     = 413 // { int sendto_nocancel(int s, caddr_t buf, size_t len, int flags, caddr_t to, socklen_t tolen) NO_SYSCALL_STUB; }
 	// SYS_NOSYS = 413;  // { int nosys(void); }
-	SYS_PREAD_NOCANCEL	= 414;	// { user_ssize_t pread_nocancel(int fd, user_addr_t buf, user_size_t nbyte, off_t offset) NO_SYSCALL_STUB; }
-	SYS_PWRITE_NOCANCEL	= 415;	// { user_ssize_t pwrite_nocancel(int fd, user_addr_t buf, user_size_t nbyte, off_t offset) NO_SYSCALL_STUB; }
-	SYS_WAITID_NOCANCEL	= 416;	// { int waitid_nocancel(idtype_t idtype, id_t id, siginfo_t *infop, int options) NO_SYSCALL_STUB; }
-	SYS_POLL_NOCANCEL	= 417;	// { int poll_nocancel(struct pollfd *fds, u_int nfds, int timeout) NO_SYSCALL_STUB; }
-	SYS_MSGSND_NOCANCEL	= 418;	// { int msgsnd_nocancel(int msqid, void *msgp, size_t msgsz, int msgflg) NO_SYSCALL_STUB; }
-	SYS_MSGRCV_NOCANCEL	= 419;	// { user_ssize_t msgrcv_nocancel(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg) NO_SYSCALL_STUB; }
+	SYS_PREAD_NOCANCEL  = 414 // { user_ssize_t pread_nocancel(int fd, user_addr_t buf, user_size_t nbyte, off_t offset) NO_SYSCALL_STUB; }
+	SYS_PWRITE_NOCANCEL = 415 // { user_ssize_t pwrite_nocancel(int fd, user_addr_t buf, user_size_t nbyte, off_t offset) NO_SYSCALL_STUB; }
+	SYS_WAITID_NOCANCEL = 416 // { int waitid_nocancel(idtype_t idtype, id_t id, siginfo_t *infop, int options) NO_SYSCALL_STUB; }
+	SYS_POLL_NOCANCEL   = 417 // { int poll_nocancel(struct pollfd *fds, u_int nfds, int timeout) NO_SYSCALL_STUB; }
+	SYS_MSGSND_NOCANCEL = 418 // { int msgsnd_nocancel(int msqid, void *msgp, size_t msgsz, int msgflg) NO_SYSCALL_STUB; }
+	SYS_MSGRCV_NOCANCEL = 419 // { user_ssize_t msgrcv_nocancel(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg) NO_SYSCALL_STUB; }
 	// SYS_NOSYS = 418;  // { int nosys(void); }
 	// SYS_NOSYS = 419;  // { int nosys(void); }
-	SYS_SEM_WAIT_NOCANCEL		= 420;	// { int sem_wait_nocancel(sem_t *sem) NO_SYSCALL_STUB; }
-	SYS_AIO_SUSPEND_NOCANCEL	= 421;	// { int aio_suspend_nocancel(user_addr_t aiocblist, int nent, user_addr_t timeoutp) NO_SYSCALL_STUB; }
-	SYS___SIGWAIT_NOCANCEL		= 422;	// { int __sigwait_nocancel(user_addr_t set, user_addr_t sig) NO_SYSCALL_STUB; }
-	SYS___SEMWAIT_SIGNAL_NOCANCEL	= 423;	// { int __semwait_signal_nocancel(int cond_sem, int mutex_sem, int timeout, int relative, time_t tv_sec, int32_t tv_nsec) NO_SYSCALL_STUB; }
-	SYS___MAC_MOUNT			= 424;	// { int __mac_mount(char *type, char *path, int flags, caddr_t data, struct mac *mac_p); }
-	SYS___MAC_GET_MOUNT		= 425;	// { int __mac_get_mount(char *path, struct mac *mac_p); }
-	SYS___MAC_GETFSSTAT		= 426;	// { int __mac_getfsstat(user_addr_t buf, int bufsize, user_addr_t mac, int macsize, int flags); }
+	SYS_SEM_WAIT_NOCANCEL         = 420 // { int sem_wait_nocancel(sem_t *sem) NO_SYSCALL_STUB; }
+	SYS_AIO_SUSPEND_NOCANCEL      = 421 // { int aio_suspend_nocancel(user_addr_t aiocblist, int nent, user_addr_t timeoutp) NO_SYSCALL_STUB; }
+	SYS___SIGWAIT_NOCANCEL        = 422 // { int __sigwait_nocancel(user_addr_t set, user_addr_t sig) NO_SYSCALL_STUB; }
+	SYS___SEMWAIT_SIGNAL_NOCANCEL = 423 // { int __semwait_signal_nocancel(int cond_sem, int mutex_sem, int timeout, int relative, time_t tv_sec, int32_t tv_nsec) NO_SYSCALL_STUB; }
+	SYS___MAC_MOUNT               = 424 // { int __mac_mount(char *type, char *path, int flags, caddr_t data, struct mac *mac_p); }
+	SYS___MAC_GET_MOUNT           = 425 // { int __mac_get_mount(char *path, struct mac *mac_p); }
+	SYS___MAC_GETFSSTAT           = 426 // { int __mac_getfsstat(user_addr_t buf, int bufsize, user_addr_t mac, int macsize, int flags); }
 )
diff --git a/src/pkg/syscall/zsysnum_darwin_amd64.go b/src/pkg/syscall/zsysnum_darwin_amd64.go
index c1cfbd4fc5..8d5c93478b 100644
--- a/src/pkg/syscall/zsysnum_darwin_amd64.go
+++ b/src/pkg/syscall/zsysnum_darwin_amd64.go
@@ -5,120 +5,120 @@ package syscall
 
 const (
 	// SYS_NOSYS = 0;  // { int nosys(void); }   { indirect syscall }
-	SYS_EXIT	= 1;	// { void exit(int rval); }
-	SYS_FORK	= 2;	// { int fork(void); }
-	SYS_READ	= 3;	// { user_ssize_t read(int fd, user_addr_t cbuf, user_size_t nbyte); }
-	SYS_WRITE	= 4;	// { user_ssize_t write(int fd, user_addr_t cbuf, user_size_t nbyte); }
-	SYS_OPEN	= 5;	// { int open(user_addr_t path, int flags, int mode); }
-	SYS_CLOSE	= 6;	// { int close(int fd); }
-	SYS_WAIT4	= 7;	// { int wait4(int pid, user_addr_t status, int options, user_addr_t rusage); }
+	SYS_EXIT  = 1 // { void exit(int rval); }
+	SYS_FORK  = 2 // { int fork(void); }
+	SYS_READ  = 3 // { user_ssize_t read(int fd, user_addr_t cbuf, user_size_t nbyte); }
+	SYS_WRITE = 4 // { user_ssize_t write(int fd, user_addr_t cbuf, user_size_t nbyte); }
+	SYS_OPEN  = 5 // { int open(user_addr_t path, int flags, int mode); }
+	SYS_CLOSE = 6 // { int close(int fd); }
+	SYS_WAIT4 = 7 // { int wait4(int pid, user_addr_t status, int options, user_addr_t rusage); }
 	// SYS_NOSYS = 8;  // { int nosys(void); }   { old creat }
-	SYS_LINK	= 9;	// { int link(user_addr_t path, user_addr_t link); }
-	SYS_UNLINK	= 10;	// { int unlink(user_addr_t path); }
+	SYS_LINK   = 9  // { int link(user_addr_t path, user_addr_t link); }
+	SYS_UNLINK = 10 // { int unlink(user_addr_t path); }
 	// SYS_NOSYS = 11;  // { int nosys(void); }   { old execv }
-	SYS_CHDIR	= 12;	// { int chdir(user_addr_t path); }
-	SYS_FCHDIR	= 13;	// { int fchdir(int fd); }
-	SYS_MKNOD	= 14;	// { int mknod(user_addr_t path, int mode, int dev); }
-	SYS_CHMOD	= 15;	// { int chmod(user_addr_t path, int mode); }
-	SYS_CHOWN	= 16;	// { int chown(user_addr_t path, int uid, int gid); }
-	SYS_OGETFSSTAT	= 18;	// { int ogetfsstat(user_addr_t buf, int bufsize, int flags); }
-	SYS_GETFSSTAT	= 18;	// { int getfsstat(user_addr_t buf, int bufsize, int flags); }
+	SYS_CHDIR      = 12 // { int chdir(user_addr_t path); }
+	SYS_FCHDIR     = 13 // { int fchdir(int fd); }
+	SYS_MKNOD      = 14 // { int mknod(user_addr_t path, int mode, int dev); }
+	SYS_CHMOD      = 15 // { int chmod(user_addr_t path, int mode); }
+	SYS_CHOWN      = 16 // { int chown(user_addr_t path, int uid, int gid); }
+	SYS_OGETFSSTAT = 18 // { int ogetfsstat(user_addr_t buf, int bufsize, int flags); }
+	SYS_GETFSSTAT  = 18 // { int getfsstat(user_addr_t buf, int bufsize, int flags); }
 	// SYS_NOSYS = 19;  // { int nosys(void); }   { old lseek }
-	SYS_GETPID	= 20;	// { int getpid(void); }
+	SYS_GETPID = 20 // { int getpid(void); }
 	// SYS_NOSYS = 21;  // { int nosys(void); }   { old mount }
 	// SYS_NOSYS = 22;  // { int nosys(void); }   { old umount }
-	SYS_SETUID	= 23;	// { int setuid(uid_t uid); }
-	SYS_GETUID	= 24;	// { int getuid(void); }
-	SYS_GETEUID	= 25;	// { int geteuid(void); }
-	SYS_PTRACE	= 26;	// { int ptrace(int req, pid_t pid, caddr_t addr, int data); }
-	SYS_RECVMSG	= 27;	// { int recvmsg(int s, struct msghdr *msg, int flags); }
-	SYS_SENDMSG	= 28;	// { int sendmsg(int s, caddr_t msg, int flags); }
-	SYS_RECVFROM	= 29;	// { int recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, int *fromlenaddr); }
-	SYS_ACCEPT	= 30;	// { int accept(int s, caddr_t name, socklen_t	*anamelen); }
-	SYS_GETPEERNAME	= 31;	// { int getpeername(int fdes, caddr_t asa, socklen_t *alen); }
-	SYS_GETSOCKNAME	= 32;	// { int getsockname(int fdes, caddr_t asa, socklen_t *alen); }
+	SYS_SETUID      = 23 // { int setuid(uid_t uid); }
+	SYS_GETUID      = 24 // { int getuid(void); }
+	SYS_GETEUID     = 25 // { int geteuid(void); }
+	SYS_PTRACE      = 26 // { int ptrace(int req, pid_t pid, caddr_t addr, int data); }
+	SYS_RECVMSG     = 27 // { int recvmsg(int s, struct msghdr *msg, int flags); }
+	SYS_SENDMSG     = 28 // { int sendmsg(int s, caddr_t msg, int flags); }
+	SYS_RECVFROM    = 29 // { int recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, int *fromlenaddr); }
+	SYS_ACCEPT      = 30 // { int accept(int s, caddr_t name, socklen_t	*anamelen); }
+	SYS_GETPEERNAME = 31 // { int getpeername(int fdes, caddr_t asa, socklen_t *alen); }
+	SYS_GETSOCKNAME = 32 // { int getsockname(int fdes, caddr_t asa, socklen_t *alen); }
 	// SYS_NOSYS = 27;  // { int nosys(void); }
 	// SYS_NOSYS = 28;  // { int nosys(void); }
 	// SYS_NOSYS = 29;  // { int nosys(void); }
 	// SYS_NOSYS = 30;  // { int nosys(void); }
 	// SYS_NOSYS = 31;  // { int nosys(void); }
 	// SYS_NOSYS = 32;  // { int nosys(void); }
-	SYS_ACCESS	= 33;	// { int access(user_addr_t path, int flags); }
-	SYS_CHFLAGS	= 34;	// { int chflags(char *path, int flags); }
-	SYS_FCHFLAGS	= 35;	// { int fchflags(int fd, int flags); }
-	SYS_SYNC	= 36;	// { int sync(void); }
-	SYS_KILL	= 37;	// { int kill(int pid, int signum, int posix); }
+	SYS_ACCESS   = 33 // { int access(user_addr_t path, int flags); }
+	SYS_CHFLAGS  = 34 // { int chflags(char *path, int flags); }
+	SYS_FCHFLAGS = 35 // { int fchflags(int fd, int flags); }
+	SYS_SYNC     = 36 // { int sync(void); }
+	SYS_KILL     = 37 // { int kill(int pid, int signum, int posix); }
 	// SYS_NOSYS = 38;  // { int nosys(void); }   { old stat  }
-	SYS_GETPPID	= 39;	// { int getppid(void); }
+	SYS_GETPPID = 39 // { int getppid(void); }
 	// SYS_NOSYS = 40;  // { int nosys(void); }   { old lstat }
-	SYS_DUP		= 41;	// { int dup(u_int fd); }
-	SYS_PIPE	= 42;	// { int pipe(void); }
-	SYS_GETEGID	= 43;	// { int getegid(void); }
-	SYS_PROFIL	= 44;	// { int profil(short *bufbase, size_t bufsize, u_long pcoffset, u_int pcscale); }
+	SYS_DUP     = 41 // { int dup(u_int fd); }
+	SYS_PIPE    = 42 // { int pipe(void); }
+	SYS_GETEGID = 43 // { int getegid(void); }
+	SYS_PROFIL  = 44 // { int profil(short *bufbase, size_t bufsize, u_long pcoffset, u_int pcscale); }
 	// SYS_NOSYS = 45;  // { int nosys(void); } { old ktrace }
-	SYS_SIGACTION	= 46;	// { int sigaction(int signum, struct __sigaction *nsa, struct sigaction *osa); }
-	SYS_GETGID	= 47;	// { int getgid(void); }
-	SYS_SIGPROCMASK	= 48;	// { int sigprocmask(int how, user_addr_t mask, user_addr_t omask); }
-	SYS_GETLOGIN	= 49;	// { int getlogin(char *namebuf, u_int namelen); }
-	SYS_SETLOGIN	= 50;	// { int setlogin(char *namebuf); }
-	SYS_ACCT	= 51;	// { int acct(char *path); }
-	SYS_SIGPENDING	= 52;	// { int sigpending(struct sigvec *osv); }
-	SYS_SIGALTSTACK	= 53;	// { int sigaltstack(struct sigaltstack *nss, struct sigaltstack *oss); }
-	SYS_IOCTL	= 54;	// { int ioctl(int fd, u_long com, caddr_t data); }
-	SYS_REBOOT	= 55;	// { int reboot(int opt, char *command); }
-	SYS_REVOKE	= 56;	// { int revoke(char *path); }
-	SYS_SYMLINK	= 57;	// { int symlink(char *path, char *link); }
-	SYS_READLINK	= 58;	// { int readlink(char *path, char *buf, int count); }
-	SYS_EXECVE	= 59;	// { int execve(char *fname, char **argp, char **envp); }
-	SYS_UMASK	= 60;	// { int umask(int newmask); }
-	SYS_CHROOT	= 61;	// { int chroot(user_addr_t path); }
+	SYS_SIGACTION   = 46 // { int sigaction(int signum, struct __sigaction *nsa, struct sigaction *osa); }
+	SYS_GETGID      = 47 // { int getgid(void); }
+	SYS_SIGPROCMASK = 48 // { int sigprocmask(int how, user_addr_t mask, user_addr_t omask); }
+	SYS_GETLOGIN    = 49 // { int getlogin(char *namebuf, u_int namelen); }
+	SYS_SETLOGIN    = 50 // { int setlogin(char *namebuf); }
+	SYS_ACCT        = 51 // { int acct(char *path); }
+	SYS_SIGPENDING  = 52 // { int sigpending(struct sigvec *osv); }
+	SYS_SIGALTSTACK = 53 // { int sigaltstack(struct sigaltstack *nss, struct sigaltstack *oss); }
+	SYS_IOCTL       = 54 // { int ioctl(int fd, u_long com, caddr_t data); }
+	SYS_REBOOT      = 55 // { int reboot(int opt, char *command); }
+	SYS_REVOKE      = 56 // { int revoke(char *path); }
+	SYS_SYMLINK     = 57 // { int symlink(char *path, char *link); }
+	SYS_READLINK    = 58 // { int readlink(char *path, char *buf, int count); }
+	SYS_EXECVE      = 59 // { int execve(char *fname, char **argp, char **envp); }
+	SYS_UMASK       = 60 // { int umask(int newmask); }
+	SYS_CHROOT      = 61 // { int chroot(user_addr_t path); }
 	// SYS_NOSYS = 62;  // { int nosys(void); }   { old fstat }
 	// SYS_NOSYS = 63;  // { int nosys(void); }   { used internally, reserved }
 	// SYS_NOSYS = 64;  // { int nosys(void); }   { old getpagesize }
-	SYS_MSYNC	= 65;	// { int msync(caddr_t addr, size_t len, int flags); }
-	SYS_VFORK	= 66;	// { int vfork(void); }
+	SYS_MSYNC = 65 // { int msync(caddr_t addr, size_t len, int flags); }
+	SYS_VFORK = 66 // { int vfork(void); }
 	// SYS_NOSYS = 67;  // { int nosys(void); }   { old vread }
 	// SYS_NOSYS = 68;  // { int nosys(void); }   { old vwrite }
-	SYS_SBRK	= 69;	// { int sbrk(int incr) NO_SYSCALL_STUB; }
-	SYS_SSTK	= 70;	// { int sstk(int incr) NO_SYSCALL_STUB; }
+	SYS_SBRK = 69 // { int sbrk(int incr) NO_SYSCALL_STUB; }
+	SYS_SSTK = 70 // { int sstk(int incr) NO_SYSCALL_STUB; }
 	// SYS_NOSYS = 71;  // { int nosys(void); }   { old mmap }
-	SYS_OVADVISE	= 72;	// { int ovadvise(void) NO_SYSCALL_STUB; }   { old vadvise }
-	SYS_MUNMAP	= 73;	// { int munmap(caddr_t addr, size_t len); }
-	SYS_MPROTECT	= 74;	// { int mprotect(caddr_t addr, size_t len, int prot); }
-	SYS_MADVISE	= 75;	// { int madvise(caddr_t addr, size_t len, int behav); }
+	SYS_OVADVISE = 72 // { int ovadvise(void) NO_SYSCALL_STUB; }   { old vadvise }
+	SYS_MUNMAP   = 73 // { int munmap(caddr_t addr, size_t len); }
+	SYS_MPROTECT = 74 // { int mprotect(caddr_t addr, size_t len, int prot); }
+	SYS_MADVISE  = 75 // { int madvise(caddr_t addr, size_t len, int behav); }
 	// SYS_NOSYS = 76;  // { int nosys(void); }   { old vhangup }
 	// SYS_NOSYS = 77;  // { int nosys(void); }   { old vlimit }
-	SYS_MINCORE	= 78;	// { int mincore(user_addr_t addr, user_size_t len, user_addr_t vec); }
-	SYS_GETGROUPS	= 79;	// { int getgroups(u_int gidsetsize, gid_t *gidset); }
-	SYS_SETGROUPS	= 80;	// { int setgroups(u_int gidsetsize, gid_t *gidset); }
-	SYS_GETPGRP	= 81;	// { int getpgrp(void); }
-	SYS_SETPGID	= 82;	// { int setpgid(int pid, int pgid); }
-	SYS_SETITIMER	= 83;	// { int setitimer(u_int which, struct itimerval *itv, struct itimerval *oitv); }
+	SYS_MINCORE   = 78 // { int mincore(user_addr_t addr, user_size_t len, user_addr_t vec); }
+	SYS_GETGROUPS = 79 // { int getgroups(u_int gidsetsize, gid_t *gidset); }
+	SYS_SETGROUPS = 80 // { int setgroups(u_int gidsetsize, gid_t *gidset); }
+	SYS_GETPGRP   = 81 // { int getpgrp(void); }
+	SYS_SETPGID   = 82 // { int setpgid(int pid, int pgid); }
+	SYS_SETITIMER = 83 // { int setitimer(u_int which, struct itimerval *itv, struct itimerval *oitv); }
 	// SYS_NOSYS = 84;  // { int nosys(void); }   { old wait }
-	SYS_SWAPON	= 85;	// { int swapon(void); }
-	SYS_GETITIMER	= 86;	// { int getitimer(u_int which, struct itimerval *itv); }
+	SYS_SWAPON    = 85 // { int swapon(void); }
+	SYS_GETITIMER = 86 // { int getitimer(u_int which, struct itimerval *itv); }
 	// SYS_NOSYS = 87;  // { int nosys(void); }   { old gethostname }
 	// SYS_NOSYS = 88;  // { int nosys(void); }   { old sethostname }
-	SYS_GETDTABLESIZE	= 89;	// { int getdtablesize(void); }
-	SYS_DUP2		= 90;	// { int dup2(u_int from, u_int to); }
+	SYS_GETDTABLESIZE = 89 // { int getdtablesize(void); }
+	SYS_DUP2          = 90 // { int dup2(u_int from, u_int to); }
 	// SYS_NOSYS = 91;  // { int nosys(void); }   { old getdopt }
-	SYS_FCNTL	= 92;	// { int fcntl(int fd, int cmd, long arg); }
-	SYS_SELECT	= 93;	// { int select(int nd, u_int32_t *in, u_int32_t *ou, u_int32_t *ex, struct timeval *tv); }
+	SYS_FCNTL  = 92 // { int fcntl(int fd, int cmd, long arg); }
+	SYS_SELECT = 93 // { int select(int nd, u_int32_t *in, u_int32_t *ou, u_int32_t *ex, struct timeval *tv); }
 	// SYS_NOSYS = 94;  // { int nosys(void); }   { old setdopt }
-	SYS_FSYNC	= 95;	// { int fsync(int fd); }
-	SYS_SETPRIORITY	= 96;	// { int setpriority(int which, id_t who, int prio); }
-	SYS_SOCKET	= 97;	// { int socket(int domain, int type, int protocol); }
-	SYS_CONNECT	= 98;	// { int connect(int s, caddr_t name, socklen_t namelen); }
+	SYS_FSYNC       = 95 // { int fsync(int fd); }
+	SYS_SETPRIORITY = 96 // { int setpriority(int which, id_t who, int prio); }
+	SYS_SOCKET      = 97 // { int socket(int domain, int type, int protocol); }
+	SYS_CONNECT     = 98 // { int connect(int s, caddr_t name, socklen_t namelen); }
 	// SYS_NOSYS = 97;  // { int nosys(void); }
 	// SYS_NOSYS = 98;  // { int nosys(void); }
 	// SYS_NOSYS = 99;  // { int nosys(void); }   { old accept }
-	SYS_GETPRIORITY	= 100;	// { int getpriority(int which, id_t who); }
+	SYS_GETPRIORITY = 100 // { int getpriority(int which, id_t who); }
 	// SYS_NOSYS = 101;  // { int nosys(void); }   { old send }
 	// SYS_NOSYS = 102;  // { int nosys(void); }   { old recv }
 	// SYS_NOSYS = 103;  // { int nosys(void); }   { old sigreturn }
-	SYS_BIND	= 104;	// { int bind(int s, caddr_t name, socklen_t namelen); }
-	SYS_SETSOCKOPT	= 105;	// { int setsockopt(int s, int level, int name, caddr_t val, socklen_t valsize); }
-	SYS_LISTEN	= 106;	// { int listen(int s, int backlog); }
+	SYS_BIND       = 104 // { int bind(int s, caddr_t name, socklen_t namelen); }
+	SYS_SETSOCKOPT = 105 // { int setsockopt(int s, int level, int name, caddr_t val, socklen_t valsize); }
+	SYS_LISTEN     = 106 // { int listen(int s, int backlog); }
 	// SYS_NOSYS = 104;  // { int nosys(void); }
 	// SYS_NOSYS = 105;  // { int nosys(void); }
 	// SYS_NOSYS = 106;  // { int nosys(void); }
@@ -126,108 +126,108 @@ const (
 	// SYS_NOSYS = 108;  // { int nosys(void); }   { old sigvec }
 	// SYS_NOSYS = 109;  // { int nosys(void); }   { old sigblock }
 	// SYS_NOSYS = 110;  // { int nosys(void); }   { old sigsetmask }
-	SYS_SIGSUSPEND	= 111;	// { int sigsuspend(sigset_t mask); }
+	SYS_SIGSUSPEND = 111 // { int sigsuspend(sigset_t mask); }
 	// SYS_NOSYS = 112;  // { int nosys(void); }   { old sigstack }
 	// SYS_NOSYS = 113;  // { int nosys(void); }   { old recvmsg }
 	// SYS_NOSYS = 114;  // { int nosys(void); }   { old sendmsg }
 	// SYS_NOSYS = 113;  // { int nosys(void); }
 	// SYS_NOSYS = 114;  // { int nosys(void); }
 	// SYS_NOSYS = 115;  // { int nosys(void); }   { old vtrace }
-	SYS_GETTIMEOFDAY	= 116;	// { int gettimeofday(struct timeval *tp, struct timezone *tzp); }
-	SYS_GETRUSAGE		= 117;	// { int getrusage(int who, struct rusage *rusage); }
-	SYS_GETSOCKOPT		= 118;	// { int getsockopt(int s, int level, int name, caddr_t val, socklen_t *avalsize); }
+	SYS_GETTIMEOFDAY = 116 // { int gettimeofday(struct timeval *tp, struct timezone *tzp); }
+	SYS_GETRUSAGE    = 117 // { int getrusage(int who, struct rusage *rusage); }
+	SYS_GETSOCKOPT   = 118 // { int getsockopt(int s, int level, int name, caddr_t val, socklen_t *avalsize); }
 	// SYS_NOSYS = 118;  // { int nosys(void); }
 	// SYS_NOSYS = 119;  // { int nosys(void); }   { old resuba }
-	SYS_READV		= 120;	// { user_ssize_t readv(int fd, struct iovec *iovp, u_int iovcnt); }
-	SYS_WRITEV		= 121;	// { user_ssize_t writev(int fd, struct iovec *iovp, u_int iovcnt); }
-	SYS_SETTIMEOFDAY	= 122;	// { int settimeofday(struct timeval *tv, struct timezone *tzp); }
-	SYS_FCHOWN		= 123;	// { int fchown(int fd, int uid, int gid); }
-	SYS_FCHMOD		= 124;	// { int fchmod(int fd, int mode); }
+	SYS_READV        = 120 // { user_ssize_t readv(int fd, struct iovec *iovp, u_int iovcnt); }
+	SYS_WRITEV       = 121 // { user_ssize_t writev(int fd, struct iovec *iovp, u_int iovcnt); }
+	SYS_SETTIMEOFDAY = 122 // { int settimeofday(struct timeval *tv, struct timezone *tzp); }
+	SYS_FCHOWN       = 123 // { int fchown(int fd, int uid, int gid); }
+	SYS_FCHMOD       = 124 // { int fchmod(int fd, int mode); }
 	// SYS_NOSYS = 125;  // { int nosys(void); }   { old recvfrom }
-	SYS_SETREUID	= 126;	// { int setreuid(uid_t ruid, uid_t euid); }
-	SYS_SETREGID	= 127;	// { int setregid(gid_t rgid, gid_t egid); }
-	SYS_RENAME	= 128;	// { int rename(char *from, char *to); }
+	SYS_SETREUID = 126 // { int setreuid(uid_t ruid, uid_t euid); }
+	SYS_SETREGID = 127 // { int setregid(gid_t rgid, gid_t egid); }
+	SYS_RENAME   = 128 // { int rename(char *from, char *to); }
 	// SYS_NOSYS = 129;  // { int nosys(void); }   { old truncate }
 	// SYS_NOSYS = 130;  // { int nosys(void); }   { old ftruncate }
-	SYS_FLOCK	= 131;	// { int flock(int fd, int how); }
-	SYS_MKFIFO	= 132;	// { int mkfifo(user_addr_t path, int mode); }
-	SYS_SENDTO	= 133;	// { int sendto(int s, caddr_t buf, size_t len, int flags, caddr_t to, socklen_t tolen); }
-	SYS_SHUTDOWN	= 134;	// { int shutdown(int s, int how); }
-	SYS_SOCKETPAIR	= 135;	// { int socketpair(int domain, int type, int protocol, int *rsv); }
+	SYS_FLOCK      = 131 // { int flock(int fd, int how); }
+	SYS_MKFIFO     = 132 // { int mkfifo(user_addr_t path, int mode); }
+	SYS_SENDTO     = 133 // { int sendto(int s, caddr_t buf, size_t len, int flags, caddr_t to, socklen_t tolen); }
+	SYS_SHUTDOWN   = 134 // { int shutdown(int s, int how); }
+	SYS_SOCKETPAIR = 135 // { int socketpair(int domain, int type, int protocol, int *rsv); }
 	// SYS_NOSYS = 133;  // { int nosys(void); }
 	// SYS_NOSYS = 134;  // { int nosys(void); }
 	// SYS_NOSYS = 135;  // { int nosys(void); }
-	SYS_MKDIR	= 136;	// { int mkdir(user_addr_t path, int mode); }
-	SYS_RMDIR	= 137;	// { int rmdir(char *path); }
-	SYS_UTIMES	= 138;	// { int utimes(char *path, struct timeval *tptr); }
-	SYS_FUTIMES	= 139;	// { int futimes(int fd, struct timeval *tptr); }
-	SYS_ADJTIME	= 140;	// { int adjtime(struct timeval *delta, struct timeval *olddelta); }
+	SYS_MKDIR   = 136 // { int mkdir(user_addr_t path, int mode); }
+	SYS_RMDIR   = 137 // { int rmdir(char *path); }
+	SYS_UTIMES  = 138 // { int utimes(char *path, struct timeval *tptr); }
+	SYS_FUTIMES = 139 // { int futimes(int fd, struct timeval *tptr); }
+	SYS_ADJTIME = 140 // { int adjtime(struct timeval *delta, struct timeval *olddelta); }
 	// SYS_NOSYS = 141;  // { int nosys(void); }   { old getpeername }
-	SYS_GETHOSTUUID	= 142;	// { int gethostuuid(unsigned char *uuid_buf, const struct timespec *timeoutp); }
+	SYS_GETHOSTUUID = 142 // { int gethostuuid(unsigned char *uuid_buf, const struct timespec *timeoutp); }
 	// SYS_NOSYS = 143;  // { int nosys(void); }   { old sethostid 	}
 	// SYS_NOSYS = 144;  // { int nosys(void); }   { old getrlimit }
 	// SYS_NOSYS = 145;  // { int nosys(void); }   { old setrlimit }
 	// SYS_NOSYS = 146;  // { int nosys(void); }   { old killpg }
-	SYS_SETSID	= 147;	// { int setsid(void); }
+	SYS_SETSID = 147 // { int setsid(void); }
 	// SYS_NOSYS = 148;  // { int nosys(void); }   { old setquota }
 	// SYS_NOSYS = 149;  // { int nosys(void); }   { old qquota }
 	// SYS_NOSYS = 150;  // { int nosys(void); }   { old getsockname }
-	SYS_GETPGID	= 151;	// { int getpgid(pid_t pid); }
-	SYS_SETPRIVEXEC	= 152;	// { int setprivexec(int flag); }
-	SYS_PREAD	= 153;	// { user_ssize_t pread(int fd, user_addr_t buf, user_size_t nbyte, off_t offset); }
-	SYS_PWRITE	= 154;	// { user_ssize_t pwrite(int fd, user_addr_t buf, user_size_t nbyte, off_t offset); }
-	SYS_NFSSVC	= 155;	// { int nfssvc(int flag, caddr_t argp); }
+	SYS_GETPGID     = 151 // { int getpgid(pid_t pid); }
+	SYS_SETPRIVEXEC = 152 // { int setprivexec(int flag); }
+	SYS_PREAD       = 153 // { user_ssize_t pread(int fd, user_addr_t buf, user_size_t nbyte, off_t offset); }
+	SYS_PWRITE      = 154 // { user_ssize_t pwrite(int fd, user_addr_t buf, user_size_t nbyte, off_t offset); }
+	SYS_NFSSVC      = 155 // { int nfssvc(int flag, caddr_t argp); }
 	// SYS_NOSYS = 155;  // { int nosys(void); }
 	// SYS_NOSYS = 156;  // { int nosys(void); }   { old getdirentries }
-	SYS_STATFS	= 157;	// { int statfs(char *path, struct statfs *buf); }
-	SYS_FSTATFS	= 158;	// { int fstatfs(int fd, struct statfs *buf); }
-	SYS_UNMOUNT	= 159;	// { int unmount(user_addr_t path, int flags); }
+	SYS_STATFS  = 157 // { int statfs(char *path, struct statfs *buf); }
+	SYS_FSTATFS = 158 // { int fstatfs(int fd, struct statfs *buf); }
+	SYS_UNMOUNT = 159 // { int unmount(user_addr_t path, int flags); }
 	// SYS_NOSYS = 160;  // { int nosys(void); }   { old async_daemon }
-	SYS_GETFH	= 161;	// { int getfh(char *fname, fhandle_t *fhp); }
+	SYS_GETFH = 161 // { int getfh(char *fname, fhandle_t *fhp); }
 	// SYS_NOSYS = 161;  // { int nosys(void); }
 	// SYS_NOSYS = 162;  // { int nosys(void); }   { old getdomainname }
 	// SYS_NOSYS = 163;  // { int nosys(void); }   { old setdomainname }
 	// SYS_NOSYS = 164;  // { int nosys(void); }
-	SYS_QUOTACTL	= 165;	// { int quotactl(const char *path, int cmd, int uid, caddr_t arg); }
+	SYS_QUOTACTL = 165 // { int quotactl(const char *path, int cmd, int uid, caddr_t arg); }
 	// SYS_NOSYS = 166;  // { int nosys(void); }   { old exportfs }
-	SYS_MOUNT	= 167;	// { int mount(char *type, char *path, int flags, caddr_t data); }
+	SYS_MOUNT = 167 // { int mount(char *type, char *path, int flags, caddr_t data); }
 	// SYS_NOSYS = 168;  // { int nosys(void); }   { old ustat }
-	SYS_CSOPS	= 169;	// { int csops(pid_t pid, uint32_t ops, user_addr_t useraddr, user_size_t usersize); }
+	SYS_CSOPS = 169 // { int csops(pid_t pid, uint32_t ops, user_addr_t useraddr, user_size_t usersize); }
 	// SYS_NOSYS = 171;  // { int nosys(void); }   { old wait3 }
 	// SYS_NOSYS = 172;  // { int nosys(void); }   { old rpause	}
-	SYS_WAITID	= 173;	// { int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); }
+	SYS_WAITID = 173 // { int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); }
 	// SYS_NOSYS = 174;  // { int nosys(void); }   { old getdents }
 	// SYS_NOSYS = 175;  // { int nosys(void); }   { old gc_control }
-	SYS_ADD_PROFIL	= 176;	// { int add_profil(short *bufbase, size_t bufsize, u_long pcoffset, u_int pcscale); }
+	SYS_ADD_PROFIL = 176 // { int add_profil(short *bufbase, size_t bufsize, u_long pcoffset, u_int pcscale); }
 	// SYS_NOSYS = 177;  // { int nosys(void); }
 	// SYS_NOSYS = 178;  // { int nosys(void); }
 	// SYS_NOSYS = 179;  // { int nosys(void); }
-	SYS_KDEBUG_TRACE	= 180;	// { int kdebug_trace(int code, int arg1, int arg2, int arg3, int arg4, int arg5) NO_SYSCALL_STUB; }
-	SYS_SETGID		= 181;	// { int setgid(gid_t gid); }
-	SYS_SETEGID		= 182;	// { int setegid(gid_t egid); }
-	SYS_SETEUID		= 183;	// { int seteuid(uid_t euid); }
-	SYS_SIGRETURN		= 184;	// { int sigreturn(struct ucontext *uctx, int infostyle); }
+	SYS_KDEBUG_TRACE = 180 // { int kdebug_trace(int code, int arg1, int arg2, int arg3, int arg4, int arg5) NO_SYSCALL_STUB; }
+	SYS_SETGID       = 181 // { int setgid(gid_t gid); }
+	SYS_SETEGID      = 182 // { int setegid(gid_t egid); }
+	SYS_SETEUID      = 183 // { int seteuid(uid_t euid); }
+	SYS_SIGRETURN    = 184 // { int sigreturn(struct ucontext *uctx, int infostyle); }
 	// SYS_NOSYS = 186;  // { int nosys(void); }
 	// SYS_NOSYS = 187;  // { int nosys(void); }
-	SYS_STAT	= 188;	// { int stat(user_addr_t path, user_addr_t ub); }
-	SYS_FSTAT	= 189;	// { int fstat(int fd, user_addr_t ub); }
-	SYS_LSTAT	= 190;	// { int lstat(user_addr_t path, user_addr_t ub); }
-	SYS_PATHCONF	= 191;	// { int pathconf(char *path, int name); }
-	SYS_FPATHCONF	= 192;	// { int fpathconf(int fd, int name); }
+	SYS_STAT      = 188 // { int stat(user_addr_t path, user_addr_t ub); }
+	SYS_FSTAT     = 189 // { int fstat(int fd, user_addr_t ub); }
+	SYS_LSTAT     = 190 // { int lstat(user_addr_t path, user_addr_t ub); }
+	SYS_PATHCONF  = 191 // { int pathconf(char *path, int name); }
+	SYS_FPATHCONF = 192 // { int fpathconf(int fd, int name); }
 	// SYS_NOSYS = 193;  // { int nosys(void); }
-	SYS_GETRLIMIT		= 194;	// { int getrlimit(u_int which, struct rlimit *rlp); }
-	SYS_SETRLIMIT		= 195;	// { int setrlimit(u_int which, struct rlimit *rlp); }
-	SYS_GETDIRENTRIES	= 196;	// { int getdirentries(int fd, char *buf, u_int count, long *basep); }
-	SYS_MMAP		= 197;	// { user_addr_t mmap(caddr_t addr, size_t len, int prot, int flags, int fd, off_t pos); }
+	SYS_GETRLIMIT     = 194 // { int getrlimit(u_int which, struct rlimit *rlp); }
+	SYS_SETRLIMIT     = 195 // { int setrlimit(u_int which, struct rlimit *rlp); }
+	SYS_GETDIRENTRIES = 196 // { int getdirentries(int fd, char *buf, u_int count, long *basep); }
+	SYS_MMAP          = 197 // { user_addr_t mmap(caddr_t addr, size_t len, int prot, int flags, int fd, off_t pos); }
 	// SYS_NOSYS = 198;  // { int nosys(void); } 	{ __syscall }
-	SYS_LSEEK	= 199;	// { off_t lseek(int fd, off_t offset, int whence); }
-	SYS_TRUNCATE	= 200;	// { int truncate(char *path, off_t length); }
-	SYS_FTRUNCATE	= 201;	// { int ftruncate(int fd, off_t length); }
-	SYS___SYSCTL	= 202;	// { int __sysctl(int *name, u_int namelen, void *old, size_t *oldlenp, void *new, size_t newlen); }
-	SYS_MLOCK	= 203;	// { int mlock(caddr_t addr, size_t len); }
-	SYS_MUNLOCK	= 204;	// { int munlock(caddr_t addr, size_t len); }
-	SYS_UNDELETE	= 205;	// { int undelete(user_addr_t path); }
-	SYS_ATSOCKET	= 206;	// { int ATsocket(int proto); }
+	SYS_LSEEK     = 199 // { off_t lseek(int fd, off_t offset, int whence); }
+	SYS_TRUNCATE  = 200 // { int truncate(char *path, off_t length); }
+	SYS_FTRUNCATE = 201 // { int ftruncate(int fd, off_t length); }
+	SYS___SYSCTL  = 202 // { int __sysctl(int *name, u_int namelen, void *old, size_t *oldlenp, void *new, size_t newlen); }
+	SYS_MLOCK     = 203 // { int mlock(caddr_t addr, size_t len); }
+	SYS_MUNLOCK   = 204 // { int munlock(caddr_t addr, size_t len); }
+	SYS_UNDELETE  = 205 // { int undelete(user_addr_t path); }
+	SYS_ATSOCKET  = 206 // { int ATsocket(int proto); }
 	// SYS_NOSYS = 213;  // { int nosys(void); } 	{ Reserved for AppleTalk }
 	// SYS_NOSYS = 206;  // { int nosys(void); }
 	// SYS_NOSYS = 207;  // { int nosys(void); }
@@ -237,166 +237,166 @@ const (
 	// SYS_NOSYS = 211;  // { int nosys(void); }
 	// SYS_NOSYS = 212;  // { int nosys(void); }
 	// SYS_NOSYS = 213;  // { int nosys(void); } 	{ Reserved for AppleTalk }
-	SYS_KQUEUE_FROM_PORTSET_NP	= 214;	// { int kqueue_from_portset_np(int portset); }
-	SYS_KQUEUE_PORTSET_NP		= 215;	// { int kqueue_portset_np(int fd); }
-	SYS_GETATTRLIST			= 220;	// { int getattrlist(const char *path, struct attrlist *alist, void *attributeBuffer, size_t bufferSize, u_long options); }
-	SYS_SETATTRLIST			= 221;	// { int setattrlist(const char *path, struct attrlist *alist, void *attributeBuffer, size_t bufferSize, u_long options); }
-	SYS_GETDIRENTRIESATTR		= 222;	// { int getdirentriesattr(int fd, struct attrlist *alist, void *buffer, size_t buffersize, u_long *count, u_long *basep, u_long *newstate, u_long options); }
-	SYS_EXCHANGEDATA		= 223;	// { int exchangedata(const char *path1, const char *path2, u_long options); }
+	SYS_KQUEUE_FROM_PORTSET_NP = 214 // { int kqueue_from_portset_np(int portset); }
+	SYS_KQUEUE_PORTSET_NP      = 215 // { int kqueue_portset_np(int fd); }
+	SYS_GETATTRLIST            = 220 // { int getattrlist(const char *path, struct attrlist *alist, void *attributeBuffer, size_t bufferSize, u_long options); }
+	SYS_SETATTRLIST            = 221 // { int setattrlist(const char *path, struct attrlist *alist, void *attributeBuffer, size_t bufferSize, u_long options); }
+	SYS_GETDIRENTRIESATTR      = 222 // { int getdirentriesattr(int fd, struct attrlist *alist, void *buffer, size_t buffersize, u_long *count, u_long *basep, u_long *newstate, u_long options); }
+	SYS_EXCHANGEDATA           = 223 // { int exchangedata(const char *path1, const char *path2, u_long options); }
 	// SYS_NOSYS = 224;  // { int nosys(void); } { was checkuseraccess }
-	SYS_SEARCHFS	= 225;	// { int searchfs(const char *path, struct fssearchblock *searchblock, u_long *nummatches, u_long scriptcode, u_long options, struct searchstate *state); }
-	SYS_DELETE	= 226;	// { int delete(user_addr_t path) NO_SYSCALL_STUB; }       { private delete (Carbon semantics) }
-	SYS_COPYFILE	= 227;	// { int copyfile(char *from, char *to, int mode, int flags) NO_SYSCALL_STUB; }
+	SYS_SEARCHFS = 225 // { int searchfs(const char *path, struct fssearchblock *searchblock, u_long *nummatches, u_long scriptcode, u_long options, struct searchstate *state); }
+	SYS_DELETE   = 226 // { int delete(user_addr_t path) NO_SYSCALL_STUB; }       { private delete (Carbon semantics) }
+	SYS_COPYFILE = 227 // { int copyfile(char *from, char *to, int mode, int flags) NO_SYSCALL_STUB; }
 	// SYS_NOSYS = 228;  // { int nosys(void); }
 	// SYS_NOSYS = 229;  // { int nosys(void); }
-	SYS_POLL		= 230;	// { int poll(struct pollfd *fds, u_int nfds, int timeout); }
-	SYS_WATCHEVENT		= 231;	// { int watchevent(struct eventreq *u_req, int u_eventmask); }
-	SYS_WAITEVENT		= 232;	// { int waitevent(struct eventreq *u_req, struct timeval *tv); }
-	SYS_MODWATCH		= 233;	// { int modwatch(struct eventreq *u_req, int u_eventmask); }
-	SYS_GETXATTR		= 234;	// { user_ssize_t getxattr(user_addr_t path, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
-	SYS_FGETXATTR		= 235;	// { user_ssize_t fgetxattr(int fd, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
-	SYS_SETXATTR		= 236;	// { int setxattr(user_addr_t path, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
-	SYS_FSETXATTR		= 237;	// { int fsetxattr(int fd, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
-	SYS_REMOVEXATTR		= 238;	// { int removexattr(user_addr_t path, user_addr_t attrname, int options); }
-	SYS_FREMOVEXATTR	= 239;	// { int fremovexattr(int fd, user_addr_t attrname, int options); }
-	SYS_LISTXATTR		= 240;	// { user_ssize_t listxattr(user_addr_t path, user_addr_t namebuf, size_t bufsize, int options); }
-	SYS_FLISTXATTR		= 241;	// { user_ssize_t flistxattr(int fd, user_addr_t namebuf, size_t bufsize, int options); }
-	SYS_FSCTL		= 242;	// { int fsctl(const char *path, u_long cmd, caddr_t data, u_long options); }
-	SYS_INITGROUPS		= 243;	// { int initgroups(u_int gidsetsize, gid_t *gidset, int gmuid); }
-	SYS_POSIX_SPAWN		= 244;	// { int posix_spawn(pid_t *pid, const char *path, const struct _posix_spawn_args_desc *adesc, char **argv, char **envp); }
+	SYS_POLL         = 230 // { int poll(struct pollfd *fds, u_int nfds, int timeout); }
+	SYS_WATCHEVENT   = 231 // { int watchevent(struct eventreq *u_req, int u_eventmask); }
+	SYS_WAITEVENT    = 232 // { int waitevent(struct eventreq *u_req, struct timeval *tv); }
+	SYS_MODWATCH     = 233 // { int modwatch(struct eventreq *u_req, int u_eventmask); }
+	SYS_GETXATTR     = 234 // { user_ssize_t getxattr(user_addr_t path, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
+	SYS_FGETXATTR    = 235 // { user_ssize_t fgetxattr(int fd, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
+	SYS_SETXATTR     = 236 // { int setxattr(user_addr_t path, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
+	SYS_FSETXATTR    = 237 // { int fsetxattr(int fd, user_addr_t attrname, user_addr_t value, size_t size, uint32_t position, int options); }
+	SYS_REMOVEXATTR  = 238 // { int removexattr(user_addr_t path, user_addr_t attrname, int options); }
+	SYS_FREMOVEXATTR = 239 // { int fremovexattr(int fd, user_addr_t attrname, int options); }
+	SYS_LISTXATTR    = 240 // { user_ssize_t listxattr(user_addr_t path, user_addr_t namebuf, size_t bufsize, int options); }
+	SYS_FLISTXATTR   = 241 // { user_ssize_t flistxattr(int fd, user_addr_t namebuf, size_t bufsize, int options); }
+	SYS_FSCTL        = 242 // { int fsctl(const char *path, u_long cmd, caddr_t data, u_long options); }
+	SYS_INITGROUPS   = 243 // { int initgroups(u_int gidsetsize, gid_t *gidset, int gmuid); }
+	SYS_POSIX_SPAWN  = 244 // { int posix_spawn(pid_t *pid, const char *path, const struct _posix_spawn_args_desc *adesc, char **argv, char **envp); }
 	// SYS_NOSYS = 245;  // { int nosys(void); }
 	// SYS_NOSYS = 246;  // { int nosys(void); }
-	SYS_NFSCLNT	= 247;	// { int nfsclnt(int flag, caddr_t argp); }
+	SYS_NFSCLNT = 247 // { int nfsclnt(int flag, caddr_t argp); }
 	// SYS_NOSYS = 247;  // { int nosys(void); }
-	SYS_FHOPEN	= 248;	// { int fhopen(const struct fhandle *u_fhp, int flags); }
+	SYS_FHOPEN = 248 // { int fhopen(const struct fhandle *u_fhp, int flags); }
 	// SYS_NOSYS = 248;  // { int nosys(void); }
 	// SYS_NOSYS = 249;  // { int nosys(void); }
-	SYS_MINHERIT	= 250;	// { int minherit(void *addr, size_t len, int inherit); }
-	SYS_SEMSYS	= 251;	// { int semsys(u_int which, int a2, int a3, int a4, int a5); }
+	SYS_MINHERIT = 250 // { int minherit(void *addr, size_t len, int inherit); }
+	SYS_SEMSYS   = 251 // { int semsys(u_int which, int a2, int a3, int a4, int a5); }
 	// SYS_NOSYS = 251;  // { int nosys(void); }
-	SYS_MSGSYS	= 252;	// { int msgsys(u_int which, int a2, int a3, int a4, int a5); }
+	SYS_MSGSYS = 252 // { int msgsys(u_int which, int a2, int a3, int a4, int a5); }
 	// SYS_NOSYS = 252;  // { int nosys(void); }
-	SYS_SHMSYS	= 253;	// { int shmsys(u_int which, int a2, int a3, int a4); }
+	SYS_SHMSYS = 253 // { int shmsys(u_int which, int a2, int a3, int a4); }
 	// SYS_NOSYS = 253;  // { int nosys(void); }
-	SYS_SEMCTL	= 254;	// { int semctl(int semid, int semnum, int cmd, semun_t arg); }
-	SYS_SEMGET	= 255;	// { int semget(key_t key, int	nsems, int semflg); }
-	SYS_SEMOP	= 256;	// { int semop(int semid, struct sembuf *sops, int nsops); }
+	SYS_SEMCTL = 254 // { int semctl(int semid, int semnum, int cmd, semun_t arg); }
+	SYS_SEMGET = 255 // { int semget(key_t key, int	nsems, int semflg); }
+	SYS_SEMOP  = 256 // { int semop(int semid, struct sembuf *sops, int nsops); }
 	// SYS_NOSYS = 257;  // { int nosys(void); }
 	// SYS_NOSYS = 254;  // { int nosys(void); }
 	// SYS_NOSYS = 255;  // { int nosys(void); }
 	// SYS_NOSYS = 256;  // { int nosys(void); }
 	// SYS_NOSYS = 257;  // { int nosys(void); }
-	SYS_MSGCTL	= 258;	// { int msgctl(int msqid, int cmd, struct	msqid_ds *buf); }
-	SYS_MSGGET	= 259;	// { int msgget(key_t key, int msgflg); }
-	SYS_MSGSND	= 260;	// { int msgsnd(int msqid, void *msgp, size_t msgsz, int msgflg); }
-	SYS_MSGRCV	= 261;	// { user_ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); }
+	SYS_MSGCTL = 258 // { int msgctl(int msqid, int cmd, struct	msqid_ds *buf); }
+	SYS_MSGGET = 259 // { int msgget(key_t key, int msgflg); }
+	SYS_MSGSND = 260 // { int msgsnd(int msqid, void *msgp, size_t msgsz, int msgflg); }
+	SYS_MSGRCV = 261 // { user_ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); }
 	// SYS_NOSYS = 258;  // { int nosys(void); }
 	// SYS_NOSYS = 259;  // { int nosys(void); }
 	// SYS_NOSYS = 260;  // { int nosys(void); }
 	// SYS_NOSYS = 261;  // { int nosys(void); }
-	SYS_SHMAT	= 262;	// { user_addr_t shmat(int shmid, void *shmaddr, int shmflg); }
-	SYS_SHMCTL	= 263;	// { int shmctl(int shmid, int cmd, struct shmid_ds *buf); }
-	SYS_SHMDT	= 264;	// { int shmdt(void *shmaddr); }
-	SYS_SHMGET	= 265;	// { int shmget(key_t key, size_t size, int shmflg); }
+	SYS_SHMAT  = 262 // { user_addr_t shmat(int shmid, void *shmaddr, int shmflg); }
+	SYS_SHMCTL = 263 // { int shmctl(int shmid, int cmd, struct shmid_ds *buf); }
+	SYS_SHMDT  = 264 // { int shmdt(void *shmaddr); }
+	SYS_SHMGET = 265 // { int shmget(key_t key, size_t size, int shmflg); }
 	// SYS_NOSYS = 262;  // { int nosys(void); }
 	// SYS_NOSYS = 263;  // { int nosys(void); }
 	// SYS_NOSYS = 264;  // { int nosys(void); }
 	// SYS_NOSYS = 265;  // { int nosys(void); }
-	SYS_SHM_OPEN			= 266;	// { int shm_open(const char *name, int oflag, int mode); }
-	SYS_SHM_UNLINK			= 267;	// { int shm_unlink(const char *name); }
-	SYS_SEM_OPEN			= 268;	// { user_addr_t sem_open(const char *name, int oflag, int mode, int value); }
-	SYS_SEM_CLOSE			= 269;	// { int sem_close(sem_t *sem); }
-	SYS_SEM_UNLINK			= 270;	// { int sem_unlink(const char *name); }
-	SYS_SEM_WAIT			= 271;	// { int sem_wait(sem_t *sem); }
-	SYS_SEM_TRYWAIT			= 272;	// { int sem_trywait(sem_t *sem); }
-	SYS_SEM_POST			= 273;	// { int sem_post(sem_t *sem); }
-	SYS_SEM_GETVALUE		= 274;	// { int sem_getvalue(sem_t *sem, int *sval); }
-	SYS_SEM_INIT			= 275;	// { int sem_init(sem_t *sem, int phsared, u_int value); }
-	SYS_SEM_DESTROY			= 276;	// { int sem_destroy(sem_t *sem); }
-	SYS_OPEN_EXTENDED		= 277;	// { int open_extended(user_addr_t path, int flags, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
-	SYS_UMASK_EXTENDED		= 278;	// { int umask_extended(int newmask, user_addr_t xsecurity) NO_SYSCALL_STUB; }
-	SYS_STAT_EXTENDED		= 279;	// { int stat_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
-	SYS_LSTAT_EXTENDED		= 280;	// { int lstat_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
-	SYS_FSTAT_EXTENDED		= 281;	// { int fstat_extended(int fd, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
-	SYS_CHMOD_EXTENDED		= 282;	// { int chmod_extended(user_addr_t path, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
-	SYS_FCHMOD_EXTENDED		= 283;	// { int fchmod_extended(int fd, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
-	SYS_ACCESS_EXTENDED		= 284;	// { int access_extended(user_addr_t entries, size_t size, user_addr_t results, uid_t uid) NO_SYSCALL_STUB; }
-	SYS_SETTID			= 285;	// { int settid(uid_t uid, gid_t gid) NO_SYSCALL_STUB; }
-	SYS_GETTID			= 286;	// { int gettid(uid_t *uidp, gid_t *gidp) NO_SYSCALL_STUB; }
-	SYS_SETSGROUPS			= 287;	// { int setsgroups(int setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
-	SYS_GETSGROUPS			= 288;	// { int getsgroups(user_addr_t setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
-	SYS_SETWGROUPS			= 289;	// { int setwgroups(int setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
-	SYS_GETWGROUPS			= 290;	// { int getwgroups(user_addr_t setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
-	SYS_MKFIFO_EXTENDED		= 291;	// { int mkfifo_extended(user_addr_t path, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
-	SYS_MKDIR_EXTENDED		= 292;	// { int mkdir_extended(user_addr_t path, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
-	SYS_IDENTITYSVC			= 293;	// { int identitysvc(int opcode, user_addr_t message) NO_SYSCALL_STUB; }
-	SYS_SHARED_REGION_CHECK_NP	= 294;	// { int shared_region_check_np(uint64_t *start_address) NO_SYSCALL_STUB; }
-	SYS_SHARED_REGION_MAP_NP	= 295;	// { int shared_region_map_np(int fd, uint32_t count, const struct shared_file_mapping_np *mappings) NO_SYSCALL_STUB; }
+	SYS_SHM_OPEN               = 266 // { int shm_open(const char *name, int oflag, int mode); }
+	SYS_SHM_UNLINK             = 267 // { int shm_unlink(const char *name); }
+	SYS_SEM_OPEN               = 268 // { user_addr_t sem_open(const char *name, int oflag, int mode, int value); }
+	SYS_SEM_CLOSE              = 269 // { int sem_close(sem_t *sem); }
+	SYS_SEM_UNLINK             = 270 // { int sem_unlink(const char *name); }
+	SYS_SEM_WAIT               = 271 // { int sem_wait(sem_t *sem); }
+	SYS_SEM_TRYWAIT            = 272 // { int sem_trywait(sem_t *sem); }
+	SYS_SEM_POST               = 273 // { int sem_post(sem_t *sem); }
+	SYS_SEM_GETVALUE           = 274 // { int sem_getvalue(sem_t *sem, int *sval); }
+	SYS_SEM_INIT               = 275 // { int sem_init(sem_t *sem, int phsared, u_int value); }
+	SYS_SEM_DESTROY            = 276 // { int sem_destroy(sem_t *sem); }
+	SYS_OPEN_EXTENDED          = 277 // { int open_extended(user_addr_t path, int flags, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_UMASK_EXTENDED         = 278 // { int umask_extended(int newmask, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_STAT_EXTENDED          = 279 // { int stat_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_LSTAT_EXTENDED         = 280 // { int lstat_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_FSTAT_EXTENDED         = 281 // { int fstat_extended(int fd, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_CHMOD_EXTENDED         = 282 // { int chmod_extended(user_addr_t path, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_FCHMOD_EXTENDED        = 283 // { int fchmod_extended(int fd, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_ACCESS_EXTENDED        = 284 // { int access_extended(user_addr_t entries, size_t size, user_addr_t results, uid_t uid) NO_SYSCALL_STUB; }
+	SYS_SETTID                 = 285 // { int settid(uid_t uid, gid_t gid) NO_SYSCALL_STUB; }
+	SYS_GETTID                 = 286 // { int gettid(uid_t *uidp, gid_t *gidp) NO_SYSCALL_STUB; }
+	SYS_SETSGROUPS             = 287 // { int setsgroups(int setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
+	SYS_GETSGROUPS             = 288 // { int getsgroups(user_addr_t setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
+	SYS_SETWGROUPS             = 289 // { int setwgroups(int setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
+	SYS_GETWGROUPS             = 290 // { int getwgroups(user_addr_t setlen, user_addr_t guidset) NO_SYSCALL_STUB; }
+	SYS_MKFIFO_EXTENDED        = 291 // { int mkfifo_extended(user_addr_t path, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_MKDIR_EXTENDED         = 292 // { int mkdir_extended(user_addr_t path, uid_t uid, gid_t gid, int mode, user_addr_t xsecurity) NO_SYSCALL_STUB; }
+	SYS_IDENTITYSVC            = 293 // { int identitysvc(int opcode, user_addr_t message) NO_SYSCALL_STUB; }
+	SYS_SHARED_REGION_CHECK_NP = 294 // { int shared_region_check_np(uint64_t *start_address) NO_SYSCALL_STUB; }
+	SYS_SHARED_REGION_MAP_NP   = 295 // { int shared_region_map_np(int fd, uint32_t count, const struct shared_file_mapping_np *mappings) NO_SYSCALL_STUB; }
 	// SYS_NOSYS = 296;  // { int nosys(void); } { old load_shared_file }
 	// SYS_NOSYS = 297;  // { int nosys(void); } { old reset_shared_file }
 	// SYS_NOSYS = 298;  // { int nosys(void); } { old new_system_shared_regions }
 	// SYS_ENOSYS = 299;  // { int enosys(void); } { old shared_region_map_file_np }
 	// SYS_ENOSYS = 300;  // { int enosys(void); } { old shared_region_make_private_np }
-	SYS___PTHREAD_MUTEX_DESTROY	= 301;	// { int __pthread_mutex_destroy(int mutexid); }
-	SYS___PTHREAD_MUTEX_INIT	= 302;	// { int __pthread_mutex_init(user_addr_t  mutex, user_addr_t attr); }
-	SYS___PTHREAD_MUTEX_LOCK	= 303;	// { int __pthread_mutex_lock(int mutexid); }
-	SYS___PTHREAD_MUTEX_TRYLOCK	= 304;	// { int __pthread_mutex_trylock(int mutexid); }
-	SYS___PTHREAD_MUTEX_UNLOCK	= 305;	// { int __pthread_mutex_unlock(int mutexid); }
-	SYS___PTHREAD_COND_INIT		= 306;	// { int __pthread_cond_init(user_addr_t cond, user_addr_t attr); }
-	SYS___PTHREAD_COND_DESTROY	= 307;	// { int __pthread_cond_destroy(int condid); }
-	SYS___PTHREAD_COND_BROADCAST	= 308;	// { int __pthread_cond_broadcast(int condid); }
-	SYS___PTHREAD_COND_SIGNAL	= 309;	// { int __pthread_cond_signal(int condid); }
-	SYS_GETSID			= 310;	// { int getsid(pid_t pid); }
-	SYS_SETTID_WITH_PID		= 311;	// { int settid_with_pid(pid_t pid, int assume) NO_SYSCALL_STUB; }
-	SYS___PTHREAD_COND_TIMEDWAIT	= 312;	// { int __pthread_cond_timedwait(int condid, int mutexid, user_addr_t abstime); }
-	SYS_AIO_FSYNC			= 313;	// { int aio_fsync(int op, user_addr_t aiocbp); }
-	SYS_AIO_RETURN			= 314;	// { user_ssize_t aio_return(user_addr_t aiocbp); }
-	SYS_AIO_SUSPEND			= 315;	// { int aio_suspend(user_addr_t aiocblist, int nent, user_addr_t timeoutp); }
-	SYS_AIO_CANCEL			= 316;	// { int aio_cancel(int fd, user_addr_t aiocbp); }
-	SYS_AIO_ERROR			= 317;	// { int aio_error(user_addr_t aiocbp); }
-	SYS_AIO_READ			= 318;	// { int aio_read(user_addr_t aiocbp); }
-	SYS_AIO_WRITE			= 319;	// { int aio_write(user_addr_t aiocbp); }
-	SYS_LIO_LISTIO			= 320;	// { int lio_listio(int mode, user_addr_t aiocblist, int nent, user_addr_t sigp); }
-	SYS___PTHREAD_COND_WAIT		= 321;	// { int __pthread_cond_wait(int condid, int mutexid); }
-	SYS_IOPOLICYSYS			= 322;	// { int iopolicysys(int cmd, void *arg) NO_SYSCALL_STUB; }
+	SYS___PTHREAD_MUTEX_DESTROY  = 301 // { int __pthread_mutex_destroy(int mutexid); }
+	SYS___PTHREAD_MUTEX_INIT     = 302 // { int __pthread_mutex_init(user_addr_t  mutex, user_addr_t attr); }
+	SYS___PTHREAD_MUTEX_LOCK     = 303 // { int __pthread_mutex_lock(int mutexid); }
+	SYS___PTHREAD_MUTEX_TRYLOCK  = 304 // { int __pthread_mutex_trylock(int mutexid); }
+	SYS___PTHREAD_MUTEX_UNLOCK   = 305 // { int __pthread_mutex_unlock(int mutexid); }
+	SYS___PTHREAD_COND_INIT      = 306 // { int __pthread_cond_init(user_addr_t cond, user_addr_t attr); }
+	SYS___PTHREAD_COND_DESTROY   = 307 // { int __pthread_cond_destroy(int condid); }
+	SYS___PTHREAD_COND_BROADCAST = 308 // { int __pthread_cond_broadcast(int condid); }
+	SYS___PTHREAD_COND_SIGNAL    = 309 // { int __pthread_cond_signal(int condid); }
+	SYS_GETSID                   = 310 // { int getsid(pid_t pid); }
+	SYS_SETTID_WITH_PID          = 311 // { int settid_with_pid(pid_t pid, int assume) NO_SYSCALL_STUB; }
+	SYS___PTHREAD_COND_TIMEDWAIT = 312 // { int __pthread_cond_timedwait(int condid, int mutexid, user_addr_t abstime); }
+	SYS_AIO_FSYNC                = 313 // { int aio_fsync(int op, user_addr_t aiocbp); }
+	SYS_AIO_RETURN               = 314 // { user_ssize_t aio_return(user_addr_t aiocbp); }
+	SYS_AIO_SUSPEND              = 315 // { int aio_suspend(user_addr_t aiocblist, int nent, user_addr_t timeoutp); }
+	SYS_AIO_CANCEL               = 316 // { int aio_cancel(int fd, user_addr_t aiocbp); }
+	SYS_AIO_ERROR                = 317 // { int aio_error(user_addr_t aiocbp); }
+	SYS_AIO_READ                 = 318 // { int aio_read(user_addr_t aiocbp); }
+	SYS_AIO_WRITE                = 319 // { int aio_write(user_addr_t aiocbp); }
+	SYS_LIO_LISTIO               = 320 // { int lio_listio(int mode, user_addr_t aiocblist, int nent, user_addr_t sigp); }
+	SYS___PTHREAD_COND_WAIT      = 321 // { int __pthread_cond_wait(int condid, int mutexid); }
+	SYS_IOPOLICYSYS              = 322 // { int iopolicysys(int cmd, void *arg) NO_SYSCALL_STUB; }
 	// SYS_NOSYS = 323;  // { int nosys(void); }
-	SYS_MLOCKALL	= 324;	// { int mlockall(int how); }
-	SYS_MUNLOCKALL	= 325;	// { int munlockall(int how); }
+	SYS_MLOCKALL   = 324 // { int mlockall(int how); }
+	SYS_MUNLOCKALL = 325 // { int munlockall(int how); }
 	// SYS_NOSYS = 326;  // { int nosys(void); }
-	SYS_ISSETUGID			= 327;	// { int issetugid(void); }
-	SYS___PTHREAD_KILL		= 328;	// { int __pthread_kill(int thread_port, int sig); }
-	SYS___PTHREAD_SIGMASK		= 329;	// { int __pthread_sigmask(int how, user_addr_t set, user_addr_t oset); }
-	SYS___SIGWAIT			= 330;	// { int __sigwait(user_addr_t set, user_addr_t sig); }
-	SYS___DISABLE_THREADSIGNAL	= 331;	// { int __disable_threadsignal(int value); }
-	SYS___PTHREAD_MARKCANCEL	= 332;	// { int __pthread_markcancel(int thread_port); }
-	SYS___PTHREAD_CANCELED		= 333;	// { int __pthread_canceled(int  action); }
-	SYS___SEMWAIT_SIGNAL		= 334;	// { int __semwait_signal(int cond_sem, int mutex_sem, int timeout, int relative, time_t tv_sec, int32_t tv_nsec); }
+	SYS_ISSETUGID              = 327 // { int issetugid(void); }
+	SYS___PTHREAD_KILL         = 328 // { int __pthread_kill(int thread_port, int sig); }
+	SYS___PTHREAD_SIGMASK      = 329 // { int __pthread_sigmask(int how, user_addr_t set, user_addr_t oset); }
+	SYS___SIGWAIT              = 330 // { int __sigwait(user_addr_t set, user_addr_t sig); }
+	SYS___DISABLE_THREADSIGNAL = 331 // { int __disable_threadsignal(int value); }
+	SYS___PTHREAD_MARKCANCEL   = 332 // { int __pthread_markcancel(int thread_port); }
+	SYS___PTHREAD_CANCELED     = 333 // { int __pthread_canceled(int  action); }
+	SYS___SEMWAIT_SIGNAL       = 334 // { int __semwait_signal(int cond_sem, int mutex_sem, int timeout, int relative, time_t tv_sec, int32_t tv_nsec); }
 	// SYS_NOSYS = 335;  // { int nosys(void); }   { old utrace }
-	SYS_PROC_INFO	= 336;	// { int proc_info(int32_t callnum,int32_t pid,uint32_t flavor, uint64_t arg,user_addr_t buffer,int32_t buffersize) NO_SYSCALL_STUB; }
-	SYS_SENDFILE	= 337;	// { int sendfile(int fd, int s, off_t offset, off_t *nbytes, struct sf_hdtr *hdtr, int flags); }
+	SYS_PROC_INFO = 336 // { int proc_info(int32_t callnum,int32_t pid,uint32_t flavor, uint64_t arg,user_addr_t buffer,int32_t buffersize) NO_SYSCALL_STUB; }
+	SYS_SENDFILE  = 337 // { int sendfile(int fd, int s, off_t offset, off_t *nbytes, struct sf_hdtr *hdtr, int flags); }
 	// SYS_NOSYS = 337;  // { int nosys(void); }
-	SYS_STAT64		= 338;	// { int stat64(user_addr_t path, user_addr_t ub); }
-	SYS_FSTAT64		= 339;	// { int fstat64(int fd, user_addr_t ub); }
-	SYS_LSTAT64		= 340;	// { int lstat64(user_addr_t path, user_addr_t ub); }
-	SYS_STAT64_EXTENDED	= 341;	// { int stat64_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
-	SYS_LSTAT64_EXTENDED	= 342;	// { int lstat64_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
-	SYS_FSTAT64_EXTENDED	= 343;	// { int fstat64_extended(int fd, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
-	SYS_GETDIRENTRIES64	= 344;	// { user_ssize_t getdirentries64(int fd, void *buf, user_size_t bufsize, off_t *position) NO_SYSCALL_STUB; }
-	SYS_STATFS64		= 345;	// { int statfs64(char *path, struct statfs64 *buf); }
-	SYS_FSTATFS64		= 346;	// { int fstatfs64(int fd, struct statfs64 *buf); }
-	SYS_GETFSSTAT64		= 347;	// { int getfsstat64(user_addr_t buf, int bufsize, int flags); }
-	SYS___PTHREAD_CHDIR	= 348;	// { int __pthread_chdir(user_addr_t path); }
-	SYS___PTHREAD_FCHDIR	= 349;	// { int __pthread_fchdir(int fd); }
-	SYS_AUDIT		= 350;	// { int audit(void *record, int length); }
-	SYS_AUDITON		= 351;	// { int auditon(int cmd, void *data, int length); }
+	SYS_STAT64           = 338 // { int stat64(user_addr_t path, user_addr_t ub); }
+	SYS_FSTAT64          = 339 // { int fstat64(int fd, user_addr_t ub); }
+	SYS_LSTAT64          = 340 // { int lstat64(user_addr_t path, user_addr_t ub); }
+	SYS_STAT64_EXTENDED  = 341 // { int stat64_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_LSTAT64_EXTENDED = 342 // { int lstat64_extended(user_addr_t path, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_FSTAT64_EXTENDED = 343 // { int fstat64_extended(int fd, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size) NO_SYSCALL_STUB; }
+	SYS_GETDIRENTRIES64  = 344 // { user_ssize_t getdirentries64(int fd, void *buf, user_size_t bufsize, off_t *position) NO_SYSCALL_STUB; }
+	SYS_STATFS64         = 345 // { int statfs64(char *path, struct statfs64 *buf); }
+	SYS_FSTATFS64        = 346 // { int fstatfs64(int fd, struct statfs64 *buf); }
+	SYS_GETFSSTAT64      = 347 // { int getfsstat64(user_addr_t buf, int bufsize, int flags); }
+	SYS___PTHREAD_CHDIR  = 348 // { int __pthread_chdir(user_addr_t path); }
+	SYS___PTHREAD_FCHDIR = 349 // { int __pthread_fchdir(int fd); }
+	SYS_AUDIT            = 350 // { int audit(void *record, int length); }
+	SYS_AUDITON          = 351 // { int auditon(int cmd, void *data, int length); }
 	// SYS_NOSYS = 352;  // { int nosys(void); }
-	SYS_GETAUID		= 353;	// { int getauid(au_id_t *auid); }
-	SYS_SETAUID		= 354;	// { int setauid(au_id_t *auid); }
-	SYS_GETAUDIT		= 355;	// { int getaudit(struct auditinfo *auditinfo); }
-	SYS_SETAUDIT		= 356;	// { int setaudit(struct auditinfo *auditinfo); }
-	SYS_GETAUDIT_ADDR	= 357;	// { int getaudit_addr(struct auditinfo_addr *auditinfo_addr, int length); }
-	SYS_SETAUDIT_ADDR	= 358;	// { int setaudit_addr(struct auditinfo_addr *auditinfo_addr, int length); }
-	SYS_AUDITCTL		= 359;	// { int auditctl(char *path); }
+	SYS_GETAUID       = 353 // { int getauid(au_id_t *auid); }
+	SYS_SETAUID       = 354 // { int setauid(au_id_t *auid); }
+	SYS_GETAUDIT      = 355 // { int getaudit(struct auditinfo *auditinfo); }
+	SYS_SETAUDIT      = 356 // { int setaudit(struct auditinfo *auditinfo); }
+	SYS_GETAUDIT_ADDR = 357 // { int getaudit_addr(struct auditinfo_addr *auditinfo_addr, int length); }
+	SYS_SETAUDIT_ADDR = 358 // { int setaudit_addr(struct auditinfo_addr *auditinfo_addr, int length); }
+	SYS_AUDITCTL      = 359 // { int auditctl(char *path); }
 	// SYS_NOSYS = 350;  // { int nosys(void); }
 	// SYS_NOSYS = 351;  // { int nosys(void); }
 	// SYS_NOSYS = 352;  // { int nosys(void); }
@@ -407,15 +407,15 @@ const (
 	// SYS_NOSYS = 357;  // { int nosys(void); }
 	// SYS_NOSYS = 358;  // { int nosys(void); }
 	// SYS_NOSYS = 359;  // { int nosys(void); }
-	SYS_BSDTHREAD_CREATE	= 360;	// { user_addr_t bsdthread_create(user_addr_t func, user_addr_t func_arg, user_addr_t stack, user_addr_t pthread, uint32_t flags) NO_SYSCALL_STUB; }
-	SYS_BSDTHREAD_TERMINATE	= 361;	// { int bsdthread_terminate(user_addr_t stackaddr, size_t freesize, uint32_t port, uint32_t sem) NO_SYSCALL_STUB; }
-	SYS_KQUEUE		= 362;	// { int kqueue(void); }
-	SYS_KEVENT		= 363;	// { int kevent(int fd, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout); }
-	SYS_LCHOWN		= 364;	// { int lchown(user_addr_t path, uid_t owner, gid_t group); }
-	SYS_STACK_SNAPSHOT	= 365;	// { int stack_snapshot(pid_t pid, user_addr_t tracebuf, uint32_t tracebuf_size, uint32_t options) NO_SYSCALL_STUB; }
-	SYS_BSDTHREAD_REGISTER	= 366;	// { int bsdthread_register(user_addr_t threadstart, user_addr_t wqthread, int pthsize) NO_SYSCALL_STUB; }
-	SYS_WORKQ_OPEN		= 367;	// { int workq_open(void) NO_SYSCALL_STUB; }
-	SYS_WORKQ_OPS		= 368;	// { int workq_ops(int options, user_addr_t item, int prio) NO_SYSCALL_STUB; }
+	SYS_BSDTHREAD_CREATE    = 360 // { user_addr_t bsdthread_create(user_addr_t func, user_addr_t func_arg, user_addr_t stack, user_addr_t pthread, uint32_t flags) NO_SYSCALL_STUB; }
+	SYS_BSDTHREAD_TERMINATE = 361 // { int bsdthread_terminate(user_addr_t stackaddr, size_t freesize, uint32_t port, uint32_t sem) NO_SYSCALL_STUB; }
+	SYS_KQUEUE              = 362 // { int kqueue(void); }
+	SYS_KEVENT              = 363 // { int kevent(int fd, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout); }
+	SYS_LCHOWN              = 364 // { int lchown(user_addr_t path, uid_t owner, gid_t group); }
+	SYS_STACK_SNAPSHOT      = 365 // { int stack_snapshot(pid_t pid, user_addr_t tracebuf, uint32_t tracebuf_size, uint32_t options) NO_SYSCALL_STUB; }
+	SYS_BSDTHREAD_REGISTER  = 366 // { int bsdthread_register(user_addr_t threadstart, user_addr_t wqthread, int pthsize) NO_SYSCALL_STUB; }
+	SYS_WORKQ_OPEN          = 367 // { int workq_open(void) NO_SYSCALL_STUB; }
+	SYS_WORKQ_OPS           = 368 // { int workq_ops(int options, user_addr_t item, int prio) NO_SYSCALL_STUB; }
 	// SYS_NOSYS = 369;  // { int nosys(void); }
 	// SYS_NOSYS = 370;  // { int nosys(void); }
 	// SYS_NOSYS = 371;  // { int nosys(void); }
@@ -427,59 +427,59 @@ const (
 	// SYS_NOSYS = 377;  // { int nosys(void); }
 	// SYS_NOSYS = 378;  // { int nosys(void); }
 	// SYS_NOSYS = 379;  // { int nosys(void); }
-	SYS___MAC_EXECVE	= 380;	// { int __mac_execve(char *fname, char **argp, char **envp, struct mac *mac_p); }
-	SYS___MAC_SYSCALL	= 381;	// { int __mac_syscall(char *policy, int call, user_addr_t arg); }
-	SYS___MAC_GET_FILE	= 382;	// { int __mac_get_file(char *path_p, struct mac *mac_p); }
-	SYS___MAC_SET_FILE	= 383;	// { int __mac_set_file(char *path_p, struct mac *mac_p); }
-	SYS___MAC_GET_LINK	= 384;	// { int __mac_get_link(char *path_p, struct mac *mac_p); }
-	SYS___MAC_SET_LINK	= 385;	// { int __mac_set_link(char *path_p, struct mac *mac_p); }
-	SYS___MAC_GET_PROC	= 386;	// { int __mac_get_proc(struct mac *mac_p); }
-	SYS___MAC_SET_PROC	= 387;	// { int __mac_set_proc(struct mac *mac_p); }
-	SYS___MAC_GET_FD	= 388;	// { int __mac_get_fd(int fd, struct mac *mac_p); }
-	SYS___MAC_SET_FD	= 389;	// { int __mac_set_fd(int fd, struct mac *mac_p); }
-	SYS___MAC_GET_PID	= 390;	// { int __mac_get_pid(pid_t pid, struct mac *mac_p); }
-	SYS___MAC_GET_LCID	= 391;	// { int __mac_get_lcid(pid_t lcid, struct mac *mac_p); }
-	SYS___MAC_GET_LCTX	= 392;	// { int __mac_get_lctx(struct mac *mac_p); }
-	SYS___MAC_SET_LCTX	= 393;	// { int __mac_set_lctx(struct mac *mac_p); }
-	SYS_SETLCID		= 394;	// { int setlcid(pid_t pid, pid_t lcid) NO_SYSCALL_STUB; }
-	SYS_GETLCID		= 395;	// { int getlcid(pid_t pid) NO_SYSCALL_STUB; }
-	SYS_READ_NOCANCEL	= 396;	// { user_ssize_t read_nocancel(int fd, user_addr_t cbuf, user_size_t nbyte) NO_SYSCALL_STUB; }
-	SYS_WRITE_NOCANCEL	= 397;	// { user_ssize_t write_nocancel(int fd, user_addr_t cbuf, user_size_t nbyte) NO_SYSCALL_STUB; }
-	SYS_OPEN_NOCANCEL	= 398;	// { int open_nocancel(user_addr_t path, int flags, int mode) NO_SYSCALL_STUB; }
-	SYS_CLOSE_NOCANCEL	= 399;	// { int close_nocancel(int fd) NO_SYSCALL_STUB; }
-	SYS_WAIT4_NOCANCEL	= 400;	// { int wait4_nocancel(int pid, user_addr_t status, int options, user_addr_t rusage) NO_SYSCALL_STUB; }
-	SYS_RECVMSG_NOCANCEL	= 401;	// { int recvmsg_nocancel(int s, struct msghdr *msg, int flags) NO_SYSCALL_STUB; }
-	SYS_SENDMSG_NOCANCEL	= 402;	// { int sendmsg_nocancel(int s, caddr_t msg, int flags) NO_SYSCALL_STUB; }
-	SYS_RECVFROM_NOCANCEL	= 403;	// { int recvfrom_nocancel(int s, void *buf, size_t len, int flags, struct sockaddr *from, int *fromlenaddr) NO_SYSCALL_STUB; }
-	SYS_ACCEPT_NOCANCEL	= 404;	// { int accept_nocancel(int s, caddr_t name, socklen_t	*anamelen) NO_SYSCALL_STUB; }
+	SYS___MAC_EXECVE      = 380 // { int __mac_execve(char *fname, char **argp, char **envp, struct mac *mac_p); }
+	SYS___MAC_SYSCALL     = 381 // { int __mac_syscall(char *policy, int call, user_addr_t arg); }
+	SYS___MAC_GET_FILE    = 382 // { int __mac_get_file(char *path_p, struct mac *mac_p); }
+	SYS___MAC_SET_FILE    = 383 // { int __mac_set_file(char *path_p, struct mac *mac_p); }
+	SYS___MAC_GET_LINK    = 384 // { int __mac_get_link(char *path_p, struct mac *mac_p); }
+	SYS___MAC_SET_LINK    = 385 // { int __mac_set_link(char *path_p, struct mac *mac_p); }
+	SYS___MAC_GET_PROC    = 386 // { int __mac_get_proc(struct mac *mac_p); }
+	SYS___MAC_SET_PROC    = 387 // { int __mac_set_proc(struct mac *mac_p); }
+	SYS___MAC_GET_FD      = 388 // { int __mac_get_fd(int fd, struct mac *mac_p); }
+	SYS___MAC_SET_FD      = 389 // { int __mac_set_fd(int fd, struct mac *mac_p); }
+	SYS___MAC_GET_PID     = 390 // { int __mac_get_pid(pid_t pid, struct mac *mac_p); }
+	SYS___MAC_GET_LCID    = 391 // { int __mac_get_lcid(pid_t lcid, struct mac *mac_p); }
+	SYS___MAC_GET_LCTX    = 392 // { int __mac_get_lctx(struct mac *mac_p); }
+	SYS___MAC_SET_LCTX    = 393 // { int __mac_set_lctx(struct mac *mac_p); }
+	SYS_SETLCID           = 394 // { int setlcid(pid_t pid, pid_t lcid) NO_SYSCALL_STUB; }
+	SYS_GETLCID           = 395 // { int getlcid(pid_t pid) NO_SYSCALL_STUB; }
+	SYS_READ_NOCANCEL     = 396 // { user_ssize_t read_nocancel(int fd, user_addr_t cbuf, user_size_t nbyte) NO_SYSCALL_STUB; }
+	SYS_WRITE_NOCANCEL    = 397 // { user_ssize_t write_nocancel(int fd, user_addr_t cbuf, user_size_t nbyte) NO_SYSCALL_STUB; }
+	SYS_OPEN_NOCANCEL     = 398 // { int open_nocancel(user_addr_t path, int flags, int mode) NO_SYSCALL_STUB; }
+	SYS_CLOSE_NOCANCEL    = 399 // { int close_nocancel(int fd) NO_SYSCALL_STUB; }
+	SYS_WAIT4_NOCANCEL    = 400 // { int wait4_nocancel(int pid, user_addr_t status, int options, user_addr_t rusage) NO_SYSCALL_STUB; }
+	SYS_RECVMSG_NOCANCEL  = 401 // { int recvmsg_nocancel(int s, struct msghdr *msg, int flags) NO_SYSCALL_STUB; }
+	SYS_SENDMSG_NOCANCEL  = 402 // { int sendmsg_nocancel(int s, caddr_t msg, int flags) NO_SYSCALL_STUB; }
+	SYS_RECVFROM_NOCANCEL = 403 // { int recvfrom_nocancel(int s, void *buf, size_t len, int flags, struct sockaddr *from, int *fromlenaddr) NO_SYSCALL_STUB; }
+	SYS_ACCEPT_NOCANCEL   = 404 // { int accept_nocancel(int s, caddr_t name, socklen_t	*anamelen) NO_SYSCALL_STUB; }
 	// SYS_NOSYS = 401;  // { int nosys(void); }
 	// SYS_NOSYS = 402;  // { int nosys(void); }
 	// SYS_NOSYS = 403;  // { int nosys(void); }
 	// SYS_NOSYS = 404;  // { int nosys(void); }
-	SYS_MSYNC_NOCANCEL	= 405;	// { int msync_nocancel(caddr_t addr, size_t len, int flags) NO_SYSCALL_STUB; }
-	SYS_FCNTL_NOCANCEL	= 406;	// { int fcntl_nocancel(int fd, int cmd, long arg) NO_SYSCALL_STUB; }
-	SYS_SELECT_NOCANCEL	= 407;	// { int select_nocancel(int nd, u_int32_t *in, u_int32_t *ou, u_int32_t *ex, struct timeval *tv) NO_SYSCALL_STUB; }
-	SYS_FSYNC_NOCANCEL	= 408;	// { int fsync_nocancel(int fd) NO_SYSCALL_STUB; }
-	SYS_CONNECT_NOCANCEL	= 409;	// { int connect_nocancel(int s, caddr_t name, socklen_t namelen) NO_SYSCALL_STUB; }
+	SYS_MSYNC_NOCANCEL   = 405 // { int msync_nocancel(caddr_t addr, size_t len, int flags) NO_SYSCALL_STUB; }
+	SYS_FCNTL_NOCANCEL   = 406 // { int fcntl_nocancel(int fd, int cmd, long arg) NO_SYSCALL_STUB; }
+	SYS_SELECT_NOCANCEL  = 407 // { int select_nocancel(int nd, u_int32_t *in, u_int32_t *ou, u_int32_t *ex, struct timeval *tv) NO_SYSCALL_STUB; }
+	SYS_FSYNC_NOCANCEL   = 408 // { int fsync_nocancel(int fd) NO_SYSCALL_STUB; }
+	SYS_CONNECT_NOCANCEL = 409 // { int connect_nocancel(int s, caddr_t name, socklen_t namelen) NO_SYSCALL_STUB; }
 	// SYS_NOSYS = 409;  // { int nosys(void); }
-	SYS_SIGSUSPEND_NOCANCEL	= 410;	// { int sigsuspend_nocancel(sigset_t mask) NO_SYSCALL_STUB; }
-	SYS_READV_NOCANCEL	= 411;	// { user_ssize_t readv_nocancel(int fd, struct iovec *iovp, u_int iovcnt) NO_SYSCALL_STUB; }
-	SYS_WRITEV_NOCANCEL	= 412;	// { user_ssize_t writev_nocancel(int fd, struct iovec *iovp, u_int iovcnt) NO_SYSCALL_STUB; }
-	SYS_SENDTO_NOCANCEL	= 413;	// { int sendto_nocancel(int s, caddr_t buf, size_t len, int flags, caddr_t to, socklen_t tolen) NO_SYSCALL_STUB; }
+	SYS_SIGSUSPEND_NOCANCEL = 410 // { int sigsuspend_nocancel(sigset_t mask) NO_SYSCALL_STUB; }
+	SYS_READV_NOCANCEL      = 411 // { user_ssize_t readv_nocancel(int fd, struct iovec *iovp, u_int iovcnt) NO_SYSCALL_STUB; }
+	SYS_WRITEV_NOCANCEL     = 412 // { user_ssize_t writev_nocancel(int fd, struct iovec *iovp, u_int iovcnt) NO_SYSCALL_STUB; }
+	SYS_SENDTO_NOCANCEL     = 413 // { int sendto_nocancel(int s, caddr_t buf, size_t len, int flags, caddr_t to, socklen_t tolen) NO_SYSCALL_STUB; }
 	// SYS_NOSYS = 413;  // { int nosys(void); }
-	SYS_PREAD_NOCANCEL	= 414;	// { user_ssize_t pread_nocancel(int fd, user_addr_t buf, user_size_t nbyte, off_t offset) NO_SYSCALL_STUB; }
-	SYS_PWRITE_NOCANCEL	= 415;	// { user_ssize_t pwrite_nocancel(int fd, user_addr_t buf, user_size_t nbyte, off_t offset) NO_SYSCALL_STUB; }
-	SYS_WAITID_NOCANCEL	= 416;	// { int waitid_nocancel(idtype_t idtype, id_t id, siginfo_t *infop, int options) NO_SYSCALL_STUB; }
-	SYS_POLL_NOCANCEL	= 417;	// { int poll_nocancel(struct pollfd *fds, u_int nfds, int timeout) NO_SYSCALL_STUB; }
-	SYS_MSGSND_NOCANCEL	= 418;	// { int msgsnd_nocancel(int msqid, void *msgp, size_t msgsz, int msgflg) NO_SYSCALL_STUB; }
-	SYS_MSGRCV_NOCANCEL	= 419;	// { user_ssize_t msgrcv_nocancel(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg) NO_SYSCALL_STUB; }
+	SYS_PREAD_NOCANCEL  = 414 // { user_ssize_t pread_nocancel(int fd, user_addr_t buf, user_size_t nbyte, off_t offset) NO_SYSCALL_STUB; }
+	SYS_PWRITE_NOCANCEL = 415 // { user_ssize_t pwrite_nocancel(int fd, user_addr_t buf, user_size_t nbyte, off_t offset) NO_SYSCALL_STUB; }
+	SYS_WAITID_NOCANCEL = 416 // { int waitid_nocancel(idtype_t idtype, id_t id, siginfo_t *infop, int options) NO_SYSCALL_STUB; }
+	SYS_POLL_NOCANCEL   = 417 // { int poll_nocancel(struct pollfd *fds, u_int nfds, int timeout) NO_SYSCALL_STUB; }
+	SYS_MSGSND_NOCANCEL = 418 // { int msgsnd_nocancel(int msqid, void *msgp, size_t msgsz, int msgflg) NO_SYSCALL_STUB; }
+	SYS_MSGRCV_NOCANCEL = 419 // { user_ssize_t msgrcv_nocancel(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg) NO_SYSCALL_STUB; }
 	// SYS_NOSYS = 418;  // { int nosys(void); }
 	// SYS_NOSYS = 419;  // { int nosys(void); }
-	SYS_SEM_WAIT_NOCANCEL		= 420;	// { int sem_wait_nocancel(sem_t *sem) NO_SYSCALL_STUB; }
-	SYS_AIO_SUSPEND_NOCANCEL	= 421;	// { int aio_suspend_nocancel(user_addr_t aiocblist, int nent, user_addr_t timeoutp) NO_SYSCALL_STUB; }
-	SYS___SIGWAIT_NOCANCEL		= 422;	// { int __sigwait_nocancel(user_addr_t set, user_addr_t sig) NO_SYSCALL_STUB; }
-	SYS___SEMWAIT_SIGNAL_NOCANCEL	= 423;	// { int __semwait_signal_nocancel(int cond_sem, int mutex_sem, int timeout, int relative, time_t tv_sec, int32_t tv_nsec) NO_SYSCALL_STUB; }
-	SYS___MAC_MOUNT			= 424;	// { int __mac_mount(char *type, char *path, int flags, caddr_t data, struct mac *mac_p); }
-	SYS___MAC_GET_MOUNT		= 425;	// { int __mac_get_mount(char *path, struct mac *mac_p); }
-	SYS___MAC_GETFSSTAT		= 426;	// { int __mac_getfsstat(user_addr_t buf, int bufsize, user_addr_t mac, int macsize, int flags); }
+	SYS_SEM_WAIT_NOCANCEL         = 420 // { int sem_wait_nocancel(sem_t *sem) NO_SYSCALL_STUB; }
+	SYS_AIO_SUSPEND_NOCANCEL      = 421 // { int aio_suspend_nocancel(user_addr_t aiocblist, int nent, user_addr_t timeoutp) NO_SYSCALL_STUB; }
+	SYS___SIGWAIT_NOCANCEL        = 422 // { int __sigwait_nocancel(user_addr_t set, user_addr_t sig) NO_SYSCALL_STUB; }
+	SYS___SEMWAIT_SIGNAL_NOCANCEL = 423 // { int __semwait_signal_nocancel(int cond_sem, int mutex_sem, int timeout, int relative, time_t tv_sec, int32_t tv_nsec) NO_SYSCALL_STUB; }
+	SYS___MAC_MOUNT               = 424 // { int __mac_mount(char *type, char *path, int flags, caddr_t data, struct mac *mac_p); }
+	SYS___MAC_GET_MOUNT           = 425 // { int __mac_get_mount(char *path, struct mac *mac_p); }
+	SYS___MAC_GETFSSTAT           = 426 // { int __mac_getfsstat(user_addr_t buf, int bufsize, user_addr_t mac, int macsize, int flags); }
 )
diff --git a/src/pkg/syscall/zsysnum_freebsd_386.go b/src/pkg/syscall/zsysnum_freebsd_386.go
index 71d35cb618..b7c6abeca5 100644
--- a/src/pkg/syscall/zsysnum_freebsd_386.go
+++ b/src/pkg/syscall/zsysnum_freebsd_386.go
@@ -5,316 +5,316 @@ package syscall
 
 const (
 	// SYS_NOSYS = 0;  // { int nosys(void); } syscall nosys_args int
-	SYS_EXIT			= 1;	// { void sys_exit(int rval); } exit \
-	SYS_FORK			= 2;	// { int fork(void); }
-	SYS_READ			= 3;	// { ssize_t read(int fd, void *buf, \
-	SYS_WRITE			= 4;	// { ssize_t write(int fd, const void *buf, \
-	SYS_OPEN			= 5;	// { int open(char *path, int flags, int mode); }
-	SYS_CLOSE			= 6;	// { int close(int fd); }
-	SYS_WAIT4			= 7;	// { int wait4(int pid, int *status, \
-	SYS_LINK			= 9;	// { int link(char *path, char *link); }
-	SYS_UNLINK			= 10;	// { int unlink(char *path); }
-	SYS_CHDIR			= 12;	// { int chdir(char *path); }
-	SYS_FCHDIR			= 13;	// { int fchdir(int fd); }
-	SYS_MKNOD			= 14;	// { int mknod(char *path, int mode, int dev); }
-	SYS_CHMOD			= 15;	// { int chmod(char *path, int mode); }
-	SYS_CHOWN			= 16;	// { int chown(char *path, int uid, int gid); }
-	SYS_OBREAK			= 17;	// { int obreak(char *nsize); } break \
-	SYS_GETPID			= 20;	// { pid_t getpid(void); }
-	SYS_MOUNT			= 21;	// { int mount(char *type, char *path, \
-	SYS_UNMOUNT			= 22;	// { int unmount(char *path, int flags); }
-	SYS_SETUID			= 23;	// { int setuid(uid_t uid); }
-	SYS_GETUID			= 24;	// { uid_t getuid(void); }
-	SYS_GETEUID			= 25;	// { uid_t geteuid(void); }
-	SYS_PTRACE			= 26;	// { int ptrace(int req, pid_t pid, \
-	SYS_RECVMSG			= 27;	// { int recvmsg(int s, struct msghdr *msg, \
-	SYS_SENDMSG			= 28;	// { int sendmsg(int s, struct msghdr *msg, \
-	SYS_RECVFROM			= 29;	// { int recvfrom(int s, caddr_t buf, \
-	SYS_ACCEPT			= 30;	// { int accept(int s, \
-	SYS_GETPEERNAME			= 31;	// { int getpeername(int fdes, \
-	SYS_GETSOCKNAME			= 32;	// { int getsockname(int fdes, \
-	SYS_ACCESS			= 33;	// { int access(char *path, int flags); }
-	SYS_CHFLAGS			= 34;	// { int chflags(char *path, int flags); }
-	SYS_FCHFLAGS			= 35;	// { int fchflags(int fd, int flags); }
-	SYS_SYNC			= 36;	// { int sync(void); }
-	SYS_KILL			= 37;	// { int kill(int pid, int signum); }
-	SYS_GETPPID			= 39;	// { pid_t getppid(void); }
-	SYS_DUP				= 41;	// { int dup(u_int fd); }
-	SYS_PIPE			= 42;	// { int pipe(void); }
-	SYS_GETEGID			= 43;	// { gid_t getegid(void); }
-	SYS_PROFIL			= 44;	// { int profil(caddr_t samples, size_t size, \
-	SYS_KTRACE			= 45;	// { int ktrace(const char *fname, int ops, \
-	SYS_GETGID			= 47;	// { gid_t getgid(void); }
-	SYS_GETLOGIN			= 49;	// { int getlogin(char *namebuf, u_int \
-	SYS_SETLOGIN			= 50;	// { int setlogin(char *namebuf); }
-	SYS_ACCT			= 51;	// { int acct(char *path); }
-	SYS_SIGALTSTACK			= 53;	// { int sigaltstack(stack_t *ss, \
-	SYS_IOCTL			= 54;	// { int ioctl(int fd, u_long com, \
-	SYS_REBOOT			= 55;	// { int reboot(int opt); }
-	SYS_REVOKE			= 56;	// { int revoke(char *path); }
-	SYS_SYMLINK			= 57;	// { int symlink(char *path, char *link); }
-	SYS_READLINK			= 58;	// { ssize_t readlink(char *path, char *buf, \
-	SYS_EXECVE			= 59;	// { int execve(char *fname, char **argv, \
-	SYS_UMASK			= 60;	// { int umask(int newmask); } umask umask_args \
-	SYS_CHROOT			= 61;	// { int chroot(char *path); }
-	SYS_MSYNC			= 65;	// { int msync(void *addr, size_t len, \
-	SYS_VFORK			= 66;	// { int vfork(void); }
-	SYS_SBRK			= 69;	// { int sbrk(int incr); }
-	SYS_SSTK			= 70;	// { int sstk(int incr); }
-	SYS_OVADVISE			= 72;	// { int ovadvise(int anom); } vadvise \
-	SYS_MUNMAP			= 73;	// { int munmap(void *addr, size_t len); }
-	SYS_MPROTECT			= 74;	// { int mprotect(const void *addr, size_t len, \
-	SYS_MADVISE			= 75;	// { int madvise(void *addr, size_t len, \
-	SYS_MINCORE			= 78;	// { int mincore(const void *addr, size_t len, \
-	SYS_GETGROUPS			= 79;	// { int getgroups(u_int gidsetsize, \
-	SYS_SETGROUPS			= 80;	// { int setgroups(u_int gidsetsize, \
-	SYS_GETPGRP			= 81;	// { int getpgrp(void); }
-	SYS_SETPGID			= 82;	// { int setpgid(int pid, int pgid); }
-	SYS_SETITIMER			= 83;	// { int setitimer(u_int which, struct \
-	SYS_SWAPON			= 85;	// { int swapon(char *name); }
-	SYS_GETITIMER			= 86;	// { int getitimer(u_int which, \
-	SYS_GETDTABLESIZE		= 89;	// { int getdtablesize(void); }
-	SYS_DUP2			= 90;	// { int dup2(u_int from, u_int to); }
-	SYS_FCNTL			= 92;	// { int fcntl(int fd, int cmd, long arg); }
-	SYS_SELECT			= 93;	// { int select(int nd, fd_set *in, fd_set *ou, \
-	SYS_FSYNC			= 95;	// { int fsync(int fd); }
-	SYS_SETPRIORITY			= 96;	// { int setpriority(int which, int who, \
-	SYS_SOCKET			= 97;	// { int socket(int domain, int type, \
-	SYS_CONNECT			= 98;	// { int connect(int s, caddr_t name, \
-	SYS_GETPRIORITY			= 100;	// { int getpriority(int which, int who); }
-	SYS_BIND			= 104;	// { int bind(int s, caddr_t name, \
-	SYS_SETSOCKOPT			= 105;	// { int setsockopt(int s, int level, int name, \
-	SYS_LISTEN			= 106;	// { int listen(int s, int backlog); }
-	SYS_GETTIMEOFDAY		= 116;	// { int gettimeofday(struct timeval *tp, \
-	SYS_GETRUSAGE			= 117;	// { int getrusage(int who, \
-	SYS_GETSOCKOPT			= 118;	// { int getsockopt(int s, int level, int name, \
-	SYS_READV			= 120;	// { int readv(int fd, struct iovec *iovp, \
-	SYS_WRITEV			= 121;	// { int writev(int fd, struct iovec *iovp, \
-	SYS_SETTIMEOFDAY		= 122;	// { int settimeofday(struct timeval *tv, \
-	SYS_FCHOWN			= 123;	// { int fchown(int fd, int uid, int gid); }
-	SYS_FCHMOD			= 124;	// { int fchmod(int fd, int mode); }
-	SYS_SETREUID			= 126;	// { int setreuid(int ruid, int euid); }
-	SYS_SETREGID			= 127;	// { int setregid(int rgid, int egid); }
-	SYS_RENAME			= 128;	// { int rename(char *from, char *to); }
-	SYS_FLOCK			= 131;	// { int flock(int fd, int how); }
-	SYS_MKFIFO			= 132;	// { int mkfifo(char *path, int mode); }
-	SYS_SENDTO			= 133;	// { int sendto(int s, caddr_t buf, size_t len, \
-	SYS_SHUTDOWN			= 134;	// { int shutdown(int s, int how); }
-	SYS_SOCKETPAIR			= 135;	// { int socketpair(int domain, int type, \
-	SYS_MKDIR			= 136;	// { int mkdir(char *path, int mode); }
-	SYS_RMDIR			= 137;	// { int rmdir(char *path); }
-	SYS_UTIMES			= 138;	// { int utimes(char *path, \
-	SYS_ADJTIME			= 140;	// { int adjtime(struct timeval *delta, \
-	SYS_SETSID			= 147;	// { int setsid(void); }
-	SYS_QUOTACTL			= 148;	// { int quotactl(char *path, int cmd, int uid, \
-	SYS_LGETFH			= 160;	// { int lgetfh(char *fname, \
-	SYS_GETFH			= 161;	// { int getfh(char *fname, \
-	SYS_SYSARCH			= 165;	// { int sysarch(int op, char *parms); }
-	SYS_RTPRIO			= 166;	// { int rtprio(int function, pid_t pid, \
-	SYS_FREEBSD6_PREAD		= 173;	// { ssize_t freebsd6_pread(int fd, void *buf, \
-	SYS_FREEBSD6_PWRITE		= 174;	// { ssize_t freebsd6_pwrite(int fd, \
-	SYS_SETFIB			= 175;	// { int setfib(int fibnum); }
-	SYS_NTP_ADJTIME			= 176;	// { int ntp_adjtime(struct timex *tp); }
-	SYS_SETGID			= 181;	// { int setgid(gid_t gid); }
-	SYS_SETEGID			= 182;	// { int setegid(gid_t egid); }
-	SYS_SETEUID			= 183;	// { int seteuid(uid_t euid); }
-	SYS_STAT			= 188;	// { int stat(char *path, struct stat *ub); }
-	SYS_FSTAT			= 189;	// { int fstat(int fd, struct stat *sb); }
-	SYS_LSTAT			= 190;	// { int lstat(char *path, struct stat *ub); }
-	SYS_PATHCONF			= 191;	// { int pathconf(char *path, int name); }
-	SYS_FPATHCONF			= 192;	// { int fpathconf(int fd, int name); }
-	SYS_GETRLIMIT			= 194;	// { int getrlimit(u_int which, \
-	SYS_SETRLIMIT			= 195;	// { int setrlimit(u_int which, \
-	SYS_GETDIRENTRIES		= 196;	// { int getdirentries(int fd, char *buf, \
-	SYS_FREEBSD6_MMAP		= 197;	// { caddr_t freebsd6_mmap(caddr_t addr, \
-	SYS_FREEBSD6_LSEEK		= 199;	// { off_t freebsd6_lseek(int fd, int pad, \
-	SYS_FREEBSD6_TRUNCATE		= 200;	// { int freebsd6_truncate(char *path, int pad, \
-	SYS_FREEBSD6_FTRUNCATE		= 201;	// { int freebsd6_ftruncate(int fd, int pad, \
-	SYS___SYSCTL			= 202;	// { int __sysctl(int *name, u_int namelen, \
-	SYS_MLOCK			= 203;	// { int mlock(const void *addr, size_t len); }
-	SYS_MUNLOCK			= 204;	// { int munlock(const void *addr, size_t len); }
-	SYS_UNDELETE			= 205;	// { int undelete(char *path); }
-	SYS_FUTIMES			= 206;	// { int futimes(int fd, struct timeval *tptr); }
-	SYS_GETPGID			= 207;	// { int getpgid(pid_t pid); }
-	SYS_POLL			= 209;	// { int poll(struct pollfd *fds, u_int nfds, \
-	SYS_CLOCK_GETTIME		= 232;	// { int clock_gettime(clockid_t clock_id, \
-	SYS_CLOCK_SETTIME		= 233;	// { int clock_settime( \
-	SYS_CLOCK_GETRES		= 234;	// { int clock_getres(clockid_t clock_id, \
-	SYS_KTIMER_CREATE		= 235;	// { int ktimer_create(clockid_t clock_id, \
-	SYS_KTIMER_DELETE		= 236;	// { int ktimer_delete(int timerid); }
-	SYS_KTIMER_SETTIME		= 237;	// { int ktimer_settime(int timerid, int flags, \
-	SYS_KTIMER_GETTIME		= 238;	// { int ktimer_gettime(int timerid, struct \
-	SYS_KTIMER_GETOVERRUN		= 239;	// { int ktimer_getoverrun(int timerid); }
-	SYS_NANOSLEEP			= 240;	// { int nanosleep(const struct timespec *rqtp, \
-	SYS_NTP_GETTIME			= 248;	// { int ntp_gettime(struct ntptimeval *ntvp); }
-	SYS_MINHERIT			= 250;	// { int minherit(void *addr, size_t len, \
-	SYS_RFORK			= 251;	// { int rfork(int flags); }
-	SYS_OPENBSD_POLL		= 252;	// { int openbsd_poll(struct pollfd *fds, \
-	SYS_ISSETUGID			= 253;	// { int issetugid(void); }
-	SYS_LCHOWN			= 254;	// { int lchown(char *path, int uid, int gid); }
-	SYS_GETDENTS			= 272;	// { int getdents(int fd, char *buf, \
-	SYS_LCHMOD			= 274;	// { int lchmod(char *path, mode_t mode); }
-	SYS_LUTIMES			= 276;	// { int lutimes(char *path, \
-	SYS_NSTAT			= 278;	// { int nstat(char *path, struct nstat *ub); }
-	SYS_NFSTAT			= 279;	// { int nfstat(int fd, struct nstat *sb); }
-	SYS_NLSTAT			= 280;	// { int nlstat(char *path, struct nstat *ub); }
-	SYS_PREADV			= 289;	// { ssize_t preadv(int fd, struct iovec *iovp, \
-	SYS_PWRITEV			= 290;	// { ssize_t pwritev(int fd, struct iovec *iovp, \
-	SYS_FHOPEN			= 298;	// { int fhopen(const struct fhandle *u_fhp, \
-	SYS_FHSTAT			= 299;	// { int fhstat(const struct fhandle *u_fhp, \
-	SYS_MODNEXT			= 300;	// { int modnext(int modid); }
-	SYS_MODSTAT			= 301;	// { int modstat(int modid, \
-	SYS_MODFNEXT			= 302;	// { int modfnext(int modid); }
-	SYS_MODFIND			= 303;	// { int modfind(const char *name); }
-	SYS_KLDLOAD			= 304;	// { int kldload(const char *file); }
-	SYS_KLDUNLOAD			= 305;	// { int kldunload(int fileid); }
-	SYS_KLDFIND			= 306;	// { int kldfind(const char *file); }
-	SYS_KLDNEXT			= 307;	// { int kldnext(int fileid); }
-	SYS_KLDSTAT			= 308;	// { int kldstat(int fileid, struct \
-	SYS_KLDFIRSTMOD			= 309;	// { int kldfirstmod(int fileid); }
-	SYS_GETSID			= 310;	// { int getsid(pid_t pid); }
-	SYS_SETRESUID			= 311;	// { int setresuid(uid_t ruid, uid_t euid, \
-	SYS_SETRESGID			= 312;	// { int setresgid(gid_t rgid, gid_t egid, \
-	SYS_YIELD			= 321;	// { int yield(void); }
-	SYS_MLOCKALL			= 324;	// { int mlockall(int how); }
-	SYS_MUNLOCKALL			= 325;	// { int munlockall(void); }
-	SYS___GETCWD			= 326;	// { int __getcwd(u_char *buf, u_int buflen); }
-	SYS_SCHED_SETPARAM		= 327;	// { int sched_setparam (pid_t pid, \
-	SYS_SCHED_GETPARAM		= 328;	// { int sched_getparam (pid_t pid, struct \
-	SYS_SCHED_SETSCHEDULER		= 329;	// { int sched_setscheduler (pid_t pid, int \
-	SYS_SCHED_GETSCHEDULER		= 330;	// { int sched_getscheduler (pid_t pid); }
-	SYS_SCHED_YIELD			= 331;	// { int sched_yield (void); }
-	SYS_SCHED_GET_PRIORITY_MAX	= 332;	// { int sched_get_priority_max (int policy); }
-	SYS_SCHED_GET_PRIORITY_MIN	= 333;	// { int sched_get_priority_min (int policy); }
-	SYS_SCHED_RR_GET_INTERVAL	= 334;	// { int sched_rr_get_interval (pid_t pid, \
-	SYS_UTRACE			= 335;	// { int utrace(const void *addr, size_t len); }
-	SYS_KLDSYM			= 337;	// { int kldsym(int fileid, int cmd, \
-	SYS_JAIL			= 338;	// { int jail(struct jail *jail); }
-	SYS_SIGPROCMASK			= 340;	// { int sigprocmask(int how, \
-	SYS_SIGSUSPEND			= 341;	// { int sigsuspend(const sigset_t *sigmask); }
-	SYS_SIGPENDING			= 343;	// { int sigpending(sigset_t *set); }
-	SYS_SIGTIMEDWAIT		= 345;	// { int sigtimedwait(const sigset_t *set, \
-	SYS_SIGWAITINFO			= 346;	// { int sigwaitinfo(const sigset_t *set, \
-	SYS___ACL_GET_FILE		= 347;	// { int __acl_get_file(const char *path, \
-	SYS___ACL_SET_FILE		= 348;	// { int __acl_set_file(const char *path, \
-	SYS___ACL_GET_FD		= 349;	// { int __acl_get_fd(int filedes, \
-	SYS___ACL_SET_FD		= 350;	// { int __acl_set_fd(int filedes, \
-	SYS___ACL_DELETE_FILE		= 351;	// { int __acl_delete_file(const char *path, \
-	SYS___ACL_DELETE_FD		= 352;	// { int __acl_delete_fd(int filedes, \
-	SYS___ACL_ACLCHECK_FILE		= 353;	// { int __acl_aclcheck_file(const char *path, \
-	SYS___ACL_ACLCHECK_FD		= 354;	// { int __acl_aclcheck_fd(int filedes, \
-	SYS_EXTATTRCTL			= 355;	// { int extattrctl(const char *path, int cmd, \
-	SYS_EXTATTR_SET_FILE		= 356;	// { int extattr_set_file( \
-	SYS_EXTATTR_GET_FILE		= 357;	// { ssize_t extattr_get_file( \
-	SYS_EXTATTR_DELETE_FILE		= 358;	// { int extattr_delete_file(const char *path, \
-	SYS_GETRESUID			= 360;	// { int getresuid(uid_t *ruid, uid_t *euid, \
-	SYS_GETRESGID			= 361;	// { int getresgid(gid_t *rgid, gid_t *egid, \
-	SYS_KQUEUE			= 362;	// { int kqueue(void); }
-	SYS_KEVENT			= 363;	// { int kevent(int fd, \
-	SYS_EXTATTR_SET_FD		= 371;	// { int extattr_set_fd(int fd, \
-	SYS_EXTATTR_GET_FD		= 372;	// { ssize_t extattr_get_fd(int fd, \
-	SYS_EXTATTR_DELETE_FD		= 373;	// { int extattr_delete_fd(int fd, \
-	SYS___SETUGID			= 374;	// { int __setugid(int flag); }
-	SYS_EACCESS			= 376;	// { int eaccess(char *path, int flags); }
-	SYS_NMOUNT			= 378;	// { int nmount(struct iovec *iovp, \
-	SYS___MAC_GET_PROC		= 384;	// { int __mac_get_proc(struct mac *mac_p); }
-	SYS___MAC_SET_PROC		= 385;	// { int __mac_set_proc(struct mac *mac_p); }
-	SYS___MAC_GET_FD		= 386;	// { int __mac_get_fd(int fd, \
-	SYS___MAC_GET_FILE		= 387;	// { int __mac_get_file(const char *path_p, \
-	SYS___MAC_SET_FD		= 388;	// { int __mac_set_fd(int fd, \
-	SYS___MAC_SET_FILE		= 389;	// { int __mac_set_file(const char *path_p, \
-	SYS_KENV			= 390;	// { int kenv(int what, const char *name, \
-	SYS_LCHFLAGS			= 391;	// { int lchflags(const char *path, int flags); }
-	SYS_UUIDGEN			= 392;	// { int uuidgen(struct uuid *store, \
-	SYS_SENDFILE			= 393;	// { int sendfile(int fd, int s, off_t offset, \
-	SYS_MAC_SYSCALL			= 394;	// { int mac_syscall(const char *policy, \
-	SYS_GETFSSTAT			= 395;	// { int getfsstat(struct statfs *buf, \
-	SYS_STATFS			= 396;	// { int statfs(char *path, \
-	SYS_FSTATFS			= 397;	// { int fstatfs(int fd, struct statfs *buf); }
-	SYS_FHSTATFS			= 398;	// { int fhstatfs(const struct fhandle *u_fhp, \
-	SYS___MAC_GET_PID		= 409;	// { int __mac_get_pid(pid_t pid, \
-	SYS___MAC_GET_LINK		= 410;	// { int __mac_get_link(const char *path_p, \
-	SYS___MAC_SET_LINK		= 411;	// { int __mac_set_link(const char *path_p, \
-	SYS_EXTATTR_SET_LINK		= 412;	// { int extattr_set_link( \
-	SYS_EXTATTR_GET_LINK		= 413;	// { ssize_t extattr_get_link( \
-	SYS_EXTATTR_DELETE_LINK		= 414;	// { int extattr_delete_link( \
-	SYS___MAC_EXECVE		= 415;	// { int __mac_execve(char *fname, char **argv, \
-	SYS_SIGACTION			= 416;	// { int sigaction(int sig, \
-	SYS_SIGRETURN			= 417;	// { int sigreturn( \
-	SYS_GETCONTEXT			= 421;	// { int getcontext(struct __ucontext *ucp); }
-	SYS_SETCONTEXT			= 422;	// { int setcontext( \
-	SYS_SWAPCONTEXT			= 423;	// { int swapcontext(struct __ucontext *oucp, \
-	SYS_SWAPOFF			= 424;	// { int swapoff(const char *name); }
-	SYS___ACL_GET_LINK		= 425;	// { int __acl_get_link(const char *path, \
-	SYS___ACL_SET_LINK		= 426;	// { int __acl_set_link(const char *path, \
-	SYS___ACL_DELETE_LINK		= 427;	// { int __acl_delete_link(const char *path, \
-	SYS___ACL_ACLCHECK_LINK		= 428;	// { int __acl_aclcheck_link(const char *path, \
-	SYS_SIGWAIT			= 429;	// { int sigwait(const sigset_t *set, \
-	SYS_THR_CREATE			= 430;	// { int thr_create(ucontext_t *ctx, long *id, \
-	SYS_THR_EXIT			= 431;	// { void thr_exit(long *state); }
-	SYS_THR_SELF			= 432;	// { int thr_self(long *id); }
-	SYS_THR_KILL			= 433;	// { int thr_kill(long id, int sig); }
-	SYS__UMTX_LOCK			= 434;	// { int _umtx_lock(struct umtx *umtx); }
-	SYS__UMTX_UNLOCK		= 435;	// { int _umtx_unlock(struct umtx *umtx); }
-	SYS_JAIL_ATTACH			= 436;	// { int jail_attach(int jid); }
-	SYS_EXTATTR_LIST_FD		= 437;	// { ssize_t extattr_list_fd(int fd, \
-	SYS_EXTATTR_LIST_FILE		= 438;	// { ssize_t extattr_list_file( \
-	SYS_EXTATTR_LIST_LINK		= 439;	// { ssize_t extattr_list_link( \
-	SYS_THR_SUSPEND			= 442;	// { int thr_suspend( \
-	SYS_THR_WAKE			= 443;	// { int thr_wake(long id); }
-	SYS_KLDUNLOADF			= 444;	// { int kldunloadf(int fileid, int flags); }
-	SYS_AUDIT			= 445;	// { int audit(const void *record, \
-	SYS_AUDITON			= 446;	// { int auditon(int cmd, void *data, \
-	SYS_GETAUID			= 447;	// { int getauid(uid_t *auid); }
-	SYS_SETAUID			= 448;	// { int setauid(uid_t *auid); }
-	SYS_GETAUDIT			= 449;	// { int getaudit(struct auditinfo *auditinfo); }
-	SYS_SETAUDIT			= 450;	// { int setaudit(struct auditinfo *auditinfo); }
-	SYS_GETAUDIT_ADDR		= 451;	// { int getaudit_addr( \
-	SYS_SETAUDIT_ADDR		= 452;	// { int setaudit_addr( \
-	SYS_AUDITCTL			= 453;	// { int auditctl(char *path); }
-	SYS__UMTX_OP			= 454;	// { int _umtx_op(void *obj, int op, \
-	SYS_THR_NEW			= 455;	// { int thr_new(struct thr_param *param, \
-	SYS_SIGQUEUE			= 456;	// { int sigqueue(pid_t pid, int signum, void *value); }
-	SYS_ABORT2			= 463;	// { int abort2(const char *why, int nargs, void **args); }
-	SYS_THR_SET_NAME		= 464;	// { int thr_set_name(long id, const char *name); }
-	SYS_RTPRIO_THREAD		= 466;	// { int rtprio_thread(int function, \
-	SYS_SCTP_PEELOFF		= 471;	// { int sctp_peeloff(int sd, uint32_t name); }
-	SYS_SCTP_GENERIC_SENDMSG	= 472;	// { int sctp_generic_sendmsg(int sd, caddr_t msg, int mlen, \
-	SYS_SCTP_GENERIC_SENDMSG_IOV	= 473;	// { int sctp_generic_sendmsg_iov(int sd, struct iovec *iov, int iovlen, \
-	SYS_SCTP_GENERIC_RECVMSG	= 474;	// { int sctp_generic_recvmsg(int sd, struct iovec *iov, int iovlen, \
-	SYS_PREAD			= 475;	// { ssize_t pread(int fd, void *buf, \
-	SYS_PWRITE			= 476;	// { ssize_t pwrite(int fd, const void *buf, \
-	SYS_MMAP			= 477;	// { caddr_t mmap(caddr_t addr, size_t len, \
-	SYS_LSEEK			= 478;	// { off_t lseek(int fd, off_t offset, \
-	SYS_TRUNCATE			= 479;	// { int truncate(char *path, off_t length); }
-	SYS_FTRUNCATE			= 480;	// { int ftruncate(int fd, off_t length); }
-	SYS_THR_KILL2			= 481;	// { int thr_kill2(pid_t pid, long id, int sig); }
-	SYS_SHM_OPEN			= 482;	// { int shm_open(const char *path, int flags, \
-	SYS_SHM_UNLINK			= 483;	// { int shm_unlink(const char *path); }
-	SYS_CPUSET			= 484;	// { int cpuset(cpusetid_t *setid); }
-	SYS_CPUSET_SETID		= 485;	// { int cpuset_setid(cpuwhich_t which, id_t id, \
-	SYS_CPUSET_GETID		= 486;	// { int cpuset_getid(cpulevel_t level, \
-	SYS_CPUSET_GETAFFINITY		= 487;	// { int cpuset_getaffinity(cpulevel_t level, \
-	SYS_CPUSET_SETAFFINITY		= 488;	// { int cpuset_setaffinity(cpulevel_t level, \
-	SYS_FACCESSAT			= 489;	// { int faccessat(int fd, char *path, int mode, \
-	SYS_FCHMODAT			= 490;	// { int fchmodat(int fd, char *path, mode_t mode, \
-	SYS_FCHOWNAT			= 491;	// { int fchownat(int fd, char *path, uid_t uid, \
-	SYS_FEXECVE			= 492;	// { int fexecve(int fd, char **argv, \
-	SYS_FSTATAT			= 493;	// { int fstatat(int fd, char *path, \
-	SYS_FUTIMESAT			= 494;	// { int futimesat(int fd, char *path, \
-	SYS_LINKAT			= 495;	// { int linkat(int fd1, char *path1, int fd2, \
-	SYS_MKDIRAT			= 496;	// { int mkdirat(int fd, char *path, mode_t mode); }
-	SYS_MKFIFOAT			= 497;	// { int mkfifoat(int fd, char *path, mode_t mode); }
-	SYS_MKNODAT			= 498;	// { int mknodat(int fd, char *path, mode_t mode, \
-	SYS_OPENAT			= 499;	// { int openat(int fd, char *path, int flag, \
-	SYS_READLINKAT			= 500;	// { int readlinkat(int fd, char *path, char *buf, \
-	SYS_RENAMEAT			= 501;	// { int renameat(int oldfd, char *old, int newfd, \
-	SYS_SYMLINKAT			= 502;	// { int symlinkat(char *path1, int fd, \
-	SYS_UNLINKAT			= 503;	// { int unlinkat(int fd, char *path, int flag); }
-	SYS_POSIX_OPENPT		= 504;	// { int posix_openpt(int flags); }
-	SYS_JAIL_GET			= 506;	// { int jail_get(struct iovec *iovp, \
-	SYS_JAIL_SET			= 507;	// { int jail_set(struct iovec *iovp, \
-	SYS_JAIL_REMOVE			= 508;	// { int jail_remove(int jid); }
-	SYS_CLOSEFROM			= 509;	// { int closefrom(int lowfd); }
-	SYS_LPATHCONF			= 513;	// { int lpathconf(char *path, int name); }
+	SYS_EXIT                     = 1   // { void sys_exit(int rval); } exit \
+	SYS_FORK                     = 2   // { int fork(void); }
+	SYS_READ                     = 3   // { ssize_t read(int fd, void *buf, \
+	SYS_WRITE                    = 4   // { ssize_t write(int fd, const void *buf, \
+	SYS_OPEN                     = 5   // { int open(char *path, int flags, int mode); }
+	SYS_CLOSE                    = 6   // { int close(int fd); }
+	SYS_WAIT4                    = 7   // { int wait4(int pid, int *status, \
+	SYS_LINK                     = 9   // { int link(char *path, char *link); }
+	SYS_UNLINK                   = 10  // { int unlink(char *path); }
+	SYS_CHDIR                    = 12  // { int chdir(char *path); }
+	SYS_FCHDIR                   = 13  // { int fchdir(int fd); }
+	SYS_MKNOD                    = 14  // { int mknod(char *path, int mode, int dev); }
+	SYS_CHMOD                    = 15  // { int chmod(char *path, int mode); }
+	SYS_CHOWN                    = 16  // { int chown(char *path, int uid, int gid); }
+	SYS_OBREAK                   = 17  // { int obreak(char *nsize); } break \
+	SYS_GETPID                   = 20  // { pid_t getpid(void); }
+	SYS_MOUNT                    = 21  // { int mount(char *type, char *path, \
+	SYS_UNMOUNT                  = 22  // { int unmount(char *path, int flags); }
+	SYS_SETUID                   = 23  // { int setuid(uid_t uid); }
+	SYS_GETUID                   = 24  // { uid_t getuid(void); }
+	SYS_GETEUID                  = 25  // { uid_t geteuid(void); }
+	SYS_PTRACE                   = 26  // { int ptrace(int req, pid_t pid, \
+	SYS_RECVMSG                  = 27  // { int recvmsg(int s, struct msghdr *msg, \
+	SYS_SENDMSG                  = 28  // { int sendmsg(int s, struct msghdr *msg, \
+	SYS_RECVFROM                 = 29  // { int recvfrom(int s, caddr_t buf, \
+	SYS_ACCEPT                   = 30  // { int accept(int s, \
+	SYS_GETPEERNAME              = 31  // { int getpeername(int fdes, \
+	SYS_GETSOCKNAME              = 32  // { int getsockname(int fdes, \
+	SYS_ACCESS                   = 33  // { int access(char *path, int flags); }
+	SYS_CHFLAGS                  = 34  // { int chflags(char *path, int flags); }
+	SYS_FCHFLAGS                 = 35  // { int fchflags(int fd, int flags); }
+	SYS_SYNC                     = 36  // { int sync(void); }
+	SYS_KILL                     = 37  // { int kill(int pid, int signum); }
+	SYS_GETPPID                  = 39  // { pid_t getppid(void); }
+	SYS_DUP                      = 41  // { int dup(u_int fd); }
+	SYS_PIPE                     = 42  // { int pipe(void); }
+	SYS_GETEGID                  = 43  // { gid_t getegid(void); }
+	SYS_PROFIL                   = 44  // { int profil(caddr_t samples, size_t size, \
+	SYS_KTRACE                   = 45  // { int ktrace(const char *fname, int ops, \
+	SYS_GETGID                   = 47  // { gid_t getgid(void); }
+	SYS_GETLOGIN                 = 49  // { int getlogin(char *namebuf, u_int \
+	SYS_SETLOGIN                 = 50  // { int setlogin(char *namebuf); }
+	SYS_ACCT                     = 51  // { int acct(char *path); }
+	SYS_SIGALTSTACK              = 53  // { int sigaltstack(stack_t *ss, \
+	SYS_IOCTL                    = 54  // { int ioctl(int fd, u_long com, \
+	SYS_REBOOT                   = 55  // { int reboot(int opt); }
+	SYS_REVOKE                   = 56  // { int revoke(char *path); }
+	SYS_SYMLINK                  = 57  // { int symlink(char *path, char *link); }
+	SYS_READLINK                 = 58  // { ssize_t readlink(char *path, char *buf, \
+	SYS_EXECVE                   = 59  // { int execve(char *fname, char **argv, \
+	SYS_UMASK                    = 60  // { int umask(int newmask); } umask umask_args \
+	SYS_CHROOT                   = 61  // { int chroot(char *path); }
+	SYS_MSYNC                    = 65  // { int msync(void *addr, size_t len, \
+	SYS_VFORK                    = 66  // { int vfork(void); }
+	SYS_SBRK                     = 69  // { int sbrk(int incr); }
+	SYS_SSTK                     = 70  // { int sstk(int incr); }
+	SYS_OVADVISE                 = 72  // { int ovadvise(int anom); } vadvise \
+	SYS_MUNMAP                   = 73  // { int munmap(void *addr, size_t len); }
+	SYS_MPROTECT                 = 74  // { int mprotect(const void *addr, size_t len, \
+	SYS_MADVISE                  = 75  // { int madvise(void *addr, size_t len, \
+	SYS_MINCORE                  = 78  // { int mincore(const void *addr, size_t len, \
+	SYS_GETGROUPS                = 79  // { int getgroups(u_int gidsetsize, \
+	SYS_SETGROUPS                = 80  // { int setgroups(u_int gidsetsize, \
+	SYS_GETPGRP                  = 81  // { int getpgrp(void); }
+	SYS_SETPGID                  = 82  // { int setpgid(int pid, int pgid); }
+	SYS_SETITIMER                = 83  // { int setitimer(u_int which, struct \
+	SYS_SWAPON                   = 85  // { int swapon(char *name); }
+	SYS_GETITIMER                = 86  // { int getitimer(u_int which, \
+	SYS_GETDTABLESIZE            = 89  // { int getdtablesize(void); }
+	SYS_DUP2                     = 90  // { int dup2(u_int from, u_int to); }
+	SYS_FCNTL                    = 92  // { int fcntl(int fd, int cmd, long arg); }
+	SYS_SELECT                   = 93  // { int select(int nd, fd_set *in, fd_set *ou, \
+	SYS_FSYNC                    = 95  // { int fsync(int fd); }
+	SYS_SETPRIORITY              = 96  // { int setpriority(int which, int who, \
+	SYS_SOCKET                   = 97  // { int socket(int domain, int type, \
+	SYS_CONNECT                  = 98  // { int connect(int s, caddr_t name, \
+	SYS_GETPRIORITY              = 100 // { int getpriority(int which, int who); }
+	SYS_BIND                     = 104 // { int bind(int s, caddr_t name, \
+	SYS_SETSOCKOPT               = 105 // { int setsockopt(int s, int level, int name, \
+	SYS_LISTEN                   = 106 // { int listen(int s, int backlog); }
+	SYS_GETTIMEOFDAY             = 116 // { int gettimeofday(struct timeval *tp, \
+	SYS_GETRUSAGE                = 117 // { int getrusage(int who, \
+	SYS_GETSOCKOPT               = 118 // { int getsockopt(int s, int level, int name, \
+	SYS_READV                    = 120 // { int readv(int fd, struct iovec *iovp, \
+	SYS_WRITEV                   = 121 // { int writev(int fd, struct iovec *iovp, \
+	SYS_SETTIMEOFDAY             = 122 // { int settimeofday(struct timeval *tv, \
+	SYS_FCHOWN                   = 123 // { int fchown(int fd, int uid, int gid); }
+	SYS_FCHMOD                   = 124 // { int fchmod(int fd, int mode); }
+	SYS_SETREUID                 = 126 // { int setreuid(int ruid, int euid); }
+	SYS_SETREGID                 = 127 // { int setregid(int rgid, int egid); }
+	SYS_RENAME                   = 128 // { int rename(char *from, char *to); }
+	SYS_FLOCK                    = 131 // { int flock(int fd, int how); }
+	SYS_MKFIFO                   = 132 // { int mkfifo(char *path, int mode); }
+	SYS_SENDTO                   = 133 // { int sendto(int s, caddr_t buf, size_t len, \
+	SYS_SHUTDOWN                 = 134 // { int shutdown(int s, int how); }
+	SYS_SOCKETPAIR               = 135 // { int socketpair(int domain, int type, \
+	SYS_MKDIR                    = 136 // { int mkdir(char *path, int mode); }
+	SYS_RMDIR                    = 137 // { int rmdir(char *path); }
+	SYS_UTIMES                   = 138 // { int utimes(char *path, \
+	SYS_ADJTIME                  = 140 // { int adjtime(struct timeval *delta, \
+	SYS_SETSID                   = 147 // { int setsid(void); }
+	SYS_QUOTACTL                 = 148 // { int quotactl(char *path, int cmd, int uid, \
+	SYS_LGETFH                   = 160 // { int lgetfh(char *fname, \
+	SYS_GETFH                    = 161 // { int getfh(char *fname, \
+	SYS_SYSARCH                  = 165 // { int sysarch(int op, char *parms); }
+	SYS_RTPRIO                   = 166 // { int rtprio(int function, pid_t pid, \
+	SYS_FREEBSD6_PREAD           = 173 // { ssize_t freebsd6_pread(int fd, void *buf, \
+	SYS_FREEBSD6_PWRITE          = 174 // { ssize_t freebsd6_pwrite(int fd, \
+	SYS_SETFIB                   = 175 // { int setfib(int fibnum); }
+	SYS_NTP_ADJTIME              = 176 // { int ntp_adjtime(struct timex *tp); }
+	SYS_SETGID                   = 181 // { int setgid(gid_t gid); }
+	SYS_SETEGID                  = 182 // { int setegid(gid_t egid); }
+	SYS_SETEUID                  = 183 // { int seteuid(uid_t euid); }
+	SYS_STAT                     = 188 // { int stat(char *path, struct stat *ub); }
+	SYS_FSTAT                    = 189 // { int fstat(int fd, struct stat *sb); }
+	SYS_LSTAT                    = 190 // { int lstat(char *path, struct stat *ub); }
+	SYS_PATHCONF                 = 191 // { int pathconf(char *path, int name); }
+	SYS_FPATHCONF                = 192 // { int fpathconf(int fd, int name); }
+	SYS_GETRLIMIT                = 194 // { int getrlimit(u_int which, \
+	SYS_SETRLIMIT                = 195 // { int setrlimit(u_int which, \
+	SYS_GETDIRENTRIES            = 196 // { int getdirentries(int fd, char *buf, \
+	SYS_FREEBSD6_MMAP            = 197 // { caddr_t freebsd6_mmap(caddr_t addr, \
+	SYS_FREEBSD6_LSEEK           = 199 // { off_t freebsd6_lseek(int fd, int pad, \
+	SYS_FREEBSD6_TRUNCATE        = 200 // { int freebsd6_truncate(char *path, int pad, \
+	SYS_FREEBSD6_FTRUNCATE       = 201 // { int freebsd6_ftruncate(int fd, int pad, \
+	SYS___SYSCTL                 = 202 // { int __sysctl(int *name, u_int namelen, \
+	SYS_MLOCK                    = 203 // { int mlock(const void *addr, size_t len); }
+	SYS_MUNLOCK                  = 204 // { int munlock(const void *addr, size_t len); }
+	SYS_UNDELETE                 = 205 // { int undelete(char *path); }
+	SYS_FUTIMES                  = 206 // { int futimes(int fd, struct timeval *tptr); }
+	SYS_GETPGID                  = 207 // { int getpgid(pid_t pid); }
+	SYS_POLL                     = 209 // { int poll(struct pollfd *fds, u_int nfds, \
+	SYS_CLOCK_GETTIME            = 232 // { int clock_gettime(clockid_t clock_id, \
+	SYS_CLOCK_SETTIME            = 233 // { int clock_settime( \
+	SYS_CLOCK_GETRES             = 234 // { int clock_getres(clockid_t clock_id, \
+	SYS_KTIMER_CREATE            = 235 // { int ktimer_create(clockid_t clock_id, \
+	SYS_KTIMER_DELETE            = 236 // { int ktimer_delete(int timerid); }
+	SYS_KTIMER_SETTIME           = 237 // { int ktimer_settime(int timerid, int flags, \
+	SYS_KTIMER_GETTIME           = 238 // { int ktimer_gettime(int timerid, struct \
+	SYS_KTIMER_GETOVERRUN        = 239 // { int ktimer_getoverrun(int timerid); }
+	SYS_NANOSLEEP                = 240 // { int nanosleep(const struct timespec *rqtp, \
+	SYS_NTP_GETTIME              = 248 // { int ntp_gettime(struct ntptimeval *ntvp); }
+	SYS_MINHERIT                 = 250 // { int minherit(void *addr, size_t len, \
+	SYS_RFORK                    = 251 // { int rfork(int flags); }
+	SYS_OPENBSD_POLL             = 252 // { int openbsd_poll(struct pollfd *fds, \
+	SYS_ISSETUGID                = 253 // { int issetugid(void); }
+	SYS_LCHOWN                   = 254 // { int lchown(char *path, int uid, int gid); }
+	SYS_GETDENTS                 = 272 // { int getdents(int fd, char *buf, \
+	SYS_LCHMOD                   = 274 // { int lchmod(char *path, mode_t mode); }
+	SYS_LUTIMES                  = 276 // { int lutimes(char *path, \
+	SYS_NSTAT                    = 278 // { int nstat(char *path, struct nstat *ub); }
+	SYS_NFSTAT                   = 279 // { int nfstat(int fd, struct nstat *sb); }
+	SYS_NLSTAT                   = 280 // { int nlstat(char *path, struct nstat *ub); }
+	SYS_PREADV                   = 289 // { ssize_t preadv(int fd, struct iovec *iovp, \
+	SYS_PWRITEV                  = 290 // { ssize_t pwritev(int fd, struct iovec *iovp, \
+	SYS_FHOPEN                   = 298 // { int fhopen(const struct fhandle *u_fhp, \
+	SYS_FHSTAT                   = 299 // { int fhstat(const struct fhandle *u_fhp, \
+	SYS_MODNEXT                  = 300 // { int modnext(int modid); }
+	SYS_MODSTAT                  = 301 // { int modstat(int modid, \
+	SYS_MODFNEXT                 = 302 // { int modfnext(int modid); }
+	SYS_MODFIND                  = 303 // { int modfind(const char *name); }
+	SYS_KLDLOAD                  = 304 // { int kldload(const char *file); }
+	SYS_KLDUNLOAD                = 305 // { int kldunload(int fileid); }
+	SYS_KLDFIND                  = 306 // { int kldfind(const char *file); }
+	SYS_KLDNEXT                  = 307 // { int kldnext(int fileid); }
+	SYS_KLDSTAT                  = 308 // { int kldstat(int fileid, struct \
+	SYS_KLDFIRSTMOD              = 309 // { int kldfirstmod(int fileid); }
+	SYS_GETSID                   = 310 // { int getsid(pid_t pid); }
+	SYS_SETRESUID                = 311 // { int setresuid(uid_t ruid, uid_t euid, \
+	SYS_SETRESGID                = 312 // { int setresgid(gid_t rgid, gid_t egid, \
+	SYS_YIELD                    = 321 // { int yield(void); }
+	SYS_MLOCKALL                 = 324 // { int mlockall(int how); }
+	SYS_MUNLOCKALL               = 325 // { int munlockall(void); }
+	SYS___GETCWD                 = 326 // { int __getcwd(u_char *buf, u_int buflen); }
+	SYS_SCHED_SETPARAM           = 327 // { int sched_setparam (pid_t pid, \
+	SYS_SCHED_GETPARAM           = 328 // { int sched_getparam (pid_t pid, struct \
+	SYS_SCHED_SETSCHEDULER       = 329 // { int sched_setscheduler (pid_t pid, int \
+	SYS_SCHED_GETSCHEDULER       = 330 // { int sched_getscheduler (pid_t pid); }
+	SYS_SCHED_YIELD              = 331 // { int sched_yield (void); }
+	SYS_SCHED_GET_PRIORITY_MAX   = 332 // { int sched_get_priority_max (int policy); }
+	SYS_SCHED_GET_PRIORITY_MIN   = 333 // { int sched_get_priority_min (int policy); }
+	SYS_SCHED_RR_GET_INTERVAL    = 334 // { int sched_rr_get_interval (pid_t pid, \
+	SYS_UTRACE                   = 335 // { int utrace(const void *addr, size_t len); }
+	SYS_KLDSYM                   = 337 // { int kldsym(int fileid, int cmd, \
+	SYS_JAIL                     = 338 // { int jail(struct jail *jail); }
+	SYS_SIGPROCMASK              = 340 // { int sigprocmask(int how, \
+	SYS_SIGSUSPEND               = 341 // { int sigsuspend(const sigset_t *sigmask); }
+	SYS_SIGPENDING               = 343 // { int sigpending(sigset_t *set); }
+	SYS_SIGTIMEDWAIT             = 345 // { int sigtimedwait(const sigset_t *set, \
+	SYS_SIGWAITINFO              = 346 // { int sigwaitinfo(const sigset_t *set, \
+	SYS___ACL_GET_FILE           = 347 // { int __acl_get_file(const char *path, \
+	SYS___ACL_SET_FILE           = 348 // { int __acl_set_file(const char *path, \
+	SYS___ACL_GET_FD             = 349 // { int __acl_get_fd(int filedes, \
+	SYS___ACL_SET_FD             = 350 // { int __acl_set_fd(int filedes, \
+	SYS___ACL_DELETE_FILE        = 351 // { int __acl_delete_file(const char *path, \
+	SYS___ACL_DELETE_FD          = 352 // { int __acl_delete_fd(int filedes, \
+	SYS___ACL_ACLCHECK_FILE      = 353 // { int __acl_aclcheck_file(const char *path, \
+	SYS___ACL_ACLCHECK_FD        = 354 // { int __acl_aclcheck_fd(int filedes, \
+	SYS_EXTATTRCTL               = 355 // { int extattrctl(const char *path, int cmd, \
+	SYS_EXTATTR_SET_FILE         = 356 // { int extattr_set_file( \
+	SYS_EXTATTR_GET_FILE         = 357 // { ssize_t extattr_get_file( \
+	SYS_EXTATTR_DELETE_FILE      = 358 // { int extattr_delete_file(const char *path, \
+	SYS_GETRESUID                = 360 // { int getresuid(uid_t *ruid, uid_t *euid, \
+	SYS_GETRESGID                = 361 // { int getresgid(gid_t *rgid, gid_t *egid, \
+	SYS_KQUEUE                   = 362 // { int kqueue(void); }
+	SYS_KEVENT                   = 363 // { int kevent(int fd, \
+	SYS_EXTATTR_SET_FD           = 371 // { int extattr_set_fd(int fd, \
+	SYS_EXTATTR_GET_FD           = 372 // { ssize_t extattr_get_fd(int fd, \
+	SYS_EXTATTR_DELETE_FD        = 373 // { int extattr_delete_fd(int fd, \
+	SYS___SETUGID                = 374 // { int __setugid(int flag); }
+	SYS_EACCESS                  = 376 // { int eaccess(char *path, int flags); }
+	SYS_NMOUNT                   = 378 // { int nmount(struct iovec *iovp, \
+	SYS___MAC_GET_PROC           = 384 // { int __mac_get_proc(struct mac *mac_p); }
+	SYS___MAC_SET_PROC           = 385 // { int __mac_set_proc(struct mac *mac_p); }
+	SYS___MAC_GET_FD             = 386 // { int __mac_get_fd(int fd, \
+	SYS___MAC_GET_FILE           = 387 // { int __mac_get_file(const char *path_p, \
+	SYS___MAC_SET_FD             = 388 // { int __mac_set_fd(int fd, \
+	SYS___MAC_SET_FILE           = 389 // { int __mac_set_file(const char *path_p, \
+	SYS_KENV                     = 390 // { int kenv(int what, const char *name, \
+	SYS_LCHFLAGS                 = 391 // { int lchflags(const char *path, int flags); }
+	SYS_UUIDGEN                  = 392 // { int uuidgen(struct uuid *store, \
+	SYS_SENDFILE                 = 393 // { int sendfile(int fd, int s, off_t offset, \
+	SYS_MAC_SYSCALL              = 394 // { int mac_syscall(const char *policy, \
+	SYS_GETFSSTAT                = 395 // { int getfsstat(struct statfs *buf, \
+	SYS_STATFS                   = 396 // { int statfs(char *path, \
+	SYS_FSTATFS                  = 397 // { int fstatfs(int fd, struct statfs *buf); }
+	SYS_FHSTATFS                 = 398 // { int fhstatfs(const struct fhandle *u_fhp, \
+	SYS___MAC_GET_PID            = 409 // { int __mac_get_pid(pid_t pid, \
+	SYS___MAC_GET_LINK           = 410 // { int __mac_get_link(const char *path_p, \
+	SYS___MAC_SET_LINK           = 411 // { int __mac_set_link(const char *path_p, \
+	SYS_EXTATTR_SET_LINK         = 412 // { int extattr_set_link( \
+	SYS_EXTATTR_GET_LINK         = 413 // { ssize_t extattr_get_link( \
+	SYS_EXTATTR_DELETE_LINK      = 414 // { int extattr_delete_link( \
+	SYS___MAC_EXECVE             = 415 // { int __mac_execve(char *fname, char **argv, \
+	SYS_SIGACTION                = 416 // { int sigaction(int sig, \
+	SYS_SIGRETURN                = 417 // { int sigreturn( \
+	SYS_GETCONTEXT               = 421 // { int getcontext(struct __ucontext *ucp); }
+	SYS_SETCONTEXT               = 422 // { int setcontext( \
+	SYS_SWAPCONTEXT              = 423 // { int swapcontext(struct __ucontext *oucp, \
+	SYS_SWAPOFF                  = 424 // { int swapoff(const char *name); }
+	SYS___ACL_GET_LINK           = 425 // { int __acl_get_link(const char *path, \
+	SYS___ACL_SET_LINK           = 426 // { int __acl_set_link(const char *path, \
+	SYS___ACL_DELETE_LINK        = 427 // { int __acl_delete_link(const char *path, \
+	SYS___ACL_ACLCHECK_LINK      = 428 // { int __acl_aclcheck_link(const char *path, \
+	SYS_SIGWAIT                  = 429 // { int sigwait(const sigset_t *set, \
+	SYS_THR_CREATE               = 430 // { int thr_create(ucontext_t *ctx, long *id, \
+	SYS_THR_EXIT                 = 431 // { void thr_exit(long *state); }
+	SYS_THR_SELF                 = 432 // { int thr_self(long *id); }
+	SYS_THR_KILL                 = 433 // { int thr_kill(long id, int sig); }
+	SYS__UMTX_LOCK               = 434 // { int _umtx_lock(struct umtx *umtx); }
+	SYS__UMTX_UNLOCK             = 435 // { int _umtx_unlock(struct umtx *umtx); }
+	SYS_JAIL_ATTACH              = 436 // { int jail_attach(int jid); }
+	SYS_EXTATTR_LIST_FD          = 437 // { ssize_t extattr_list_fd(int fd, \
+	SYS_EXTATTR_LIST_FILE        = 438 // { ssize_t extattr_list_file( \
+	SYS_EXTATTR_LIST_LINK        = 439 // { ssize_t extattr_list_link( \
+	SYS_THR_SUSPEND              = 442 // { int thr_suspend( \
+	SYS_THR_WAKE                 = 443 // { int thr_wake(long id); }
+	SYS_KLDUNLOADF               = 444 // { int kldunloadf(int fileid, int flags); }
+	SYS_AUDIT                    = 445 // { int audit(const void *record, \
+	SYS_AUDITON                  = 446 // { int auditon(int cmd, void *data, \
+	SYS_GETAUID                  = 447 // { int getauid(uid_t *auid); }
+	SYS_SETAUID                  = 448 // { int setauid(uid_t *auid); }
+	SYS_GETAUDIT                 = 449 // { int getaudit(struct auditinfo *auditinfo); }
+	SYS_SETAUDIT                 = 450 // { int setaudit(struct auditinfo *auditinfo); }
+	SYS_GETAUDIT_ADDR            = 451 // { int getaudit_addr( \
+	SYS_SETAUDIT_ADDR            = 452 // { int setaudit_addr( \
+	SYS_AUDITCTL                 = 453 // { int auditctl(char *path); }
+	SYS__UMTX_OP                 = 454 // { int _umtx_op(void *obj, int op, \
+	SYS_THR_NEW                  = 455 // { int thr_new(struct thr_param *param, \
+	SYS_SIGQUEUE                 = 456 // { int sigqueue(pid_t pid, int signum, void *value); }
+	SYS_ABORT2                   = 463 // { int abort2(const char *why, int nargs, void **args); }
+	SYS_THR_SET_NAME             = 464 // { int thr_set_name(long id, const char *name); }
+	SYS_RTPRIO_THREAD            = 466 // { int rtprio_thread(int function, \
+	SYS_SCTP_PEELOFF             = 471 // { int sctp_peeloff(int sd, uint32_t name); }
+	SYS_SCTP_GENERIC_SENDMSG     = 472 // { int sctp_generic_sendmsg(int sd, caddr_t msg, int mlen, \
+	SYS_SCTP_GENERIC_SENDMSG_IOV = 473 // { int sctp_generic_sendmsg_iov(int sd, struct iovec *iov, int iovlen, \
+	SYS_SCTP_GENERIC_RECVMSG     = 474 // { int sctp_generic_recvmsg(int sd, struct iovec *iov, int iovlen, \
+	SYS_PREAD                    = 475 // { ssize_t pread(int fd, void *buf, \
+	SYS_PWRITE                   = 476 // { ssize_t pwrite(int fd, const void *buf, \
+	SYS_MMAP                     = 477 // { caddr_t mmap(caddr_t addr, size_t len, \
+	SYS_LSEEK                    = 478 // { off_t lseek(int fd, off_t offset, \
+	SYS_TRUNCATE                 = 479 // { int truncate(char *path, off_t length); }
+	SYS_FTRUNCATE                = 480 // { int ftruncate(int fd, off_t length); }
+	SYS_THR_KILL2                = 481 // { int thr_kill2(pid_t pid, long id, int sig); }
+	SYS_SHM_OPEN                 = 482 // { int shm_open(const char *path, int flags, \
+	SYS_SHM_UNLINK               = 483 // { int shm_unlink(const char *path); }
+	SYS_CPUSET                   = 484 // { int cpuset(cpusetid_t *setid); }
+	SYS_CPUSET_SETID             = 485 // { int cpuset_setid(cpuwhich_t which, id_t id, \
+	SYS_CPUSET_GETID             = 486 // { int cpuset_getid(cpulevel_t level, \
+	SYS_CPUSET_GETAFFINITY       = 487 // { int cpuset_getaffinity(cpulevel_t level, \
+	SYS_CPUSET_SETAFFINITY       = 488 // { int cpuset_setaffinity(cpulevel_t level, \
+	SYS_FACCESSAT                = 489 // { int faccessat(int fd, char *path, int mode, \
+	SYS_FCHMODAT                 = 490 // { int fchmodat(int fd, char *path, mode_t mode, \
+	SYS_FCHOWNAT                 = 491 // { int fchownat(int fd, char *path, uid_t uid, \
+	SYS_FEXECVE                  = 492 // { int fexecve(int fd, char **argv, \
+	SYS_FSTATAT                  = 493 // { int fstatat(int fd, char *path, \
+	SYS_FUTIMESAT                = 494 // { int futimesat(int fd, char *path, \
+	SYS_LINKAT                   = 495 // { int linkat(int fd1, char *path1, int fd2, \
+	SYS_MKDIRAT                  = 496 // { int mkdirat(int fd, char *path, mode_t mode); }
+	SYS_MKFIFOAT                 = 497 // { int mkfifoat(int fd, char *path, mode_t mode); }
+	SYS_MKNODAT                  = 498 // { int mknodat(int fd, char *path, mode_t mode, \
+	SYS_OPENAT                   = 499 // { int openat(int fd, char *path, int flag, \
+	SYS_READLINKAT               = 500 // { int readlinkat(int fd, char *path, char *buf, \
+	SYS_RENAMEAT                 = 501 // { int renameat(int oldfd, char *old, int newfd, \
+	SYS_SYMLINKAT                = 502 // { int symlinkat(char *path1, int fd, \
+	SYS_UNLINKAT                 = 503 // { int unlinkat(int fd, char *path, int flag); }
+	SYS_POSIX_OPENPT             = 504 // { int posix_openpt(int flags); }
+	SYS_JAIL_GET                 = 506 // { int jail_get(struct iovec *iovp, \
+	SYS_JAIL_SET                 = 507 // { int jail_set(struct iovec *iovp, \
+	SYS_JAIL_REMOVE              = 508 // { int jail_remove(int jid); }
+	SYS_CLOSEFROM                = 509 // { int closefrom(int lowfd); }
+	SYS_LPATHCONF                = 513 // { int lpathconf(char *path, int name); }
 )
diff --git a/src/pkg/syscall/zsysnum_freebsd_amd64.go b/src/pkg/syscall/zsysnum_freebsd_amd64.go
index 71d35cb618..b7c6abeca5 100644
--- a/src/pkg/syscall/zsysnum_freebsd_amd64.go
+++ b/src/pkg/syscall/zsysnum_freebsd_amd64.go
@@ -5,316 +5,316 @@ package syscall
 
 const (
 	// SYS_NOSYS = 0;  // { int nosys(void); } syscall nosys_args int
-	SYS_EXIT			= 1;	// { void sys_exit(int rval); } exit \
-	SYS_FORK			= 2;	// { int fork(void); }
-	SYS_READ			= 3;	// { ssize_t read(int fd, void *buf, \
-	SYS_WRITE			= 4;	// { ssize_t write(int fd, const void *buf, \
-	SYS_OPEN			= 5;	// { int open(char *path, int flags, int mode); }
-	SYS_CLOSE			= 6;	// { int close(int fd); }
-	SYS_WAIT4			= 7;	// { int wait4(int pid, int *status, \
-	SYS_LINK			= 9;	// { int link(char *path, char *link); }
-	SYS_UNLINK			= 10;	// { int unlink(char *path); }
-	SYS_CHDIR			= 12;	// { int chdir(char *path); }
-	SYS_FCHDIR			= 13;	// { int fchdir(int fd); }
-	SYS_MKNOD			= 14;	// { int mknod(char *path, int mode, int dev); }
-	SYS_CHMOD			= 15;	// { int chmod(char *path, int mode); }
-	SYS_CHOWN			= 16;	// { int chown(char *path, int uid, int gid); }
-	SYS_OBREAK			= 17;	// { int obreak(char *nsize); } break \
-	SYS_GETPID			= 20;	// { pid_t getpid(void); }
-	SYS_MOUNT			= 21;	// { int mount(char *type, char *path, \
-	SYS_UNMOUNT			= 22;	// { int unmount(char *path, int flags); }
-	SYS_SETUID			= 23;	// { int setuid(uid_t uid); }
-	SYS_GETUID			= 24;	// { uid_t getuid(void); }
-	SYS_GETEUID			= 25;	// { uid_t geteuid(void); }
-	SYS_PTRACE			= 26;	// { int ptrace(int req, pid_t pid, \
-	SYS_RECVMSG			= 27;	// { int recvmsg(int s, struct msghdr *msg, \
-	SYS_SENDMSG			= 28;	// { int sendmsg(int s, struct msghdr *msg, \
-	SYS_RECVFROM			= 29;	// { int recvfrom(int s, caddr_t buf, \
-	SYS_ACCEPT			= 30;	// { int accept(int s, \
-	SYS_GETPEERNAME			= 31;	// { int getpeername(int fdes, \
-	SYS_GETSOCKNAME			= 32;	// { int getsockname(int fdes, \
-	SYS_ACCESS			= 33;	// { int access(char *path, int flags); }
-	SYS_CHFLAGS			= 34;	// { int chflags(char *path, int flags); }
-	SYS_FCHFLAGS			= 35;	// { int fchflags(int fd, int flags); }
-	SYS_SYNC			= 36;	// { int sync(void); }
-	SYS_KILL			= 37;	// { int kill(int pid, int signum); }
-	SYS_GETPPID			= 39;	// { pid_t getppid(void); }
-	SYS_DUP				= 41;	// { int dup(u_int fd); }
-	SYS_PIPE			= 42;	// { int pipe(void); }
-	SYS_GETEGID			= 43;	// { gid_t getegid(void); }
-	SYS_PROFIL			= 44;	// { int profil(caddr_t samples, size_t size, \
-	SYS_KTRACE			= 45;	// { int ktrace(const char *fname, int ops, \
-	SYS_GETGID			= 47;	// { gid_t getgid(void); }
-	SYS_GETLOGIN			= 49;	// { int getlogin(char *namebuf, u_int \
-	SYS_SETLOGIN			= 50;	// { int setlogin(char *namebuf); }
-	SYS_ACCT			= 51;	// { int acct(char *path); }
-	SYS_SIGALTSTACK			= 53;	// { int sigaltstack(stack_t *ss, \
-	SYS_IOCTL			= 54;	// { int ioctl(int fd, u_long com, \
-	SYS_REBOOT			= 55;	// { int reboot(int opt); }
-	SYS_REVOKE			= 56;	// { int revoke(char *path); }
-	SYS_SYMLINK			= 57;	// { int symlink(char *path, char *link); }
-	SYS_READLINK			= 58;	// { ssize_t readlink(char *path, char *buf, \
-	SYS_EXECVE			= 59;	// { int execve(char *fname, char **argv, \
-	SYS_UMASK			= 60;	// { int umask(int newmask); } umask umask_args \
-	SYS_CHROOT			= 61;	// { int chroot(char *path); }
-	SYS_MSYNC			= 65;	// { int msync(void *addr, size_t len, \
-	SYS_VFORK			= 66;	// { int vfork(void); }
-	SYS_SBRK			= 69;	// { int sbrk(int incr); }
-	SYS_SSTK			= 70;	// { int sstk(int incr); }
-	SYS_OVADVISE			= 72;	// { int ovadvise(int anom); } vadvise \
-	SYS_MUNMAP			= 73;	// { int munmap(void *addr, size_t len); }
-	SYS_MPROTECT			= 74;	// { int mprotect(const void *addr, size_t len, \
-	SYS_MADVISE			= 75;	// { int madvise(void *addr, size_t len, \
-	SYS_MINCORE			= 78;	// { int mincore(const void *addr, size_t len, \
-	SYS_GETGROUPS			= 79;	// { int getgroups(u_int gidsetsize, \
-	SYS_SETGROUPS			= 80;	// { int setgroups(u_int gidsetsize, \
-	SYS_GETPGRP			= 81;	// { int getpgrp(void); }
-	SYS_SETPGID			= 82;	// { int setpgid(int pid, int pgid); }
-	SYS_SETITIMER			= 83;	// { int setitimer(u_int which, struct \
-	SYS_SWAPON			= 85;	// { int swapon(char *name); }
-	SYS_GETITIMER			= 86;	// { int getitimer(u_int which, \
-	SYS_GETDTABLESIZE		= 89;	// { int getdtablesize(void); }
-	SYS_DUP2			= 90;	// { int dup2(u_int from, u_int to); }
-	SYS_FCNTL			= 92;	// { int fcntl(int fd, int cmd, long arg); }
-	SYS_SELECT			= 93;	// { int select(int nd, fd_set *in, fd_set *ou, \
-	SYS_FSYNC			= 95;	// { int fsync(int fd); }
-	SYS_SETPRIORITY			= 96;	// { int setpriority(int which, int who, \
-	SYS_SOCKET			= 97;	// { int socket(int domain, int type, \
-	SYS_CONNECT			= 98;	// { int connect(int s, caddr_t name, \
-	SYS_GETPRIORITY			= 100;	// { int getpriority(int which, int who); }
-	SYS_BIND			= 104;	// { int bind(int s, caddr_t name, \
-	SYS_SETSOCKOPT			= 105;	// { int setsockopt(int s, int level, int name, \
-	SYS_LISTEN			= 106;	// { int listen(int s, int backlog); }
-	SYS_GETTIMEOFDAY		= 116;	// { int gettimeofday(struct timeval *tp, \
-	SYS_GETRUSAGE			= 117;	// { int getrusage(int who, \
-	SYS_GETSOCKOPT			= 118;	// { int getsockopt(int s, int level, int name, \
-	SYS_READV			= 120;	// { int readv(int fd, struct iovec *iovp, \
-	SYS_WRITEV			= 121;	// { int writev(int fd, struct iovec *iovp, \
-	SYS_SETTIMEOFDAY		= 122;	// { int settimeofday(struct timeval *tv, \
-	SYS_FCHOWN			= 123;	// { int fchown(int fd, int uid, int gid); }
-	SYS_FCHMOD			= 124;	// { int fchmod(int fd, int mode); }
-	SYS_SETREUID			= 126;	// { int setreuid(int ruid, int euid); }
-	SYS_SETREGID			= 127;	// { int setregid(int rgid, int egid); }
-	SYS_RENAME			= 128;	// { int rename(char *from, char *to); }
-	SYS_FLOCK			= 131;	// { int flock(int fd, int how); }
-	SYS_MKFIFO			= 132;	// { int mkfifo(char *path, int mode); }
-	SYS_SENDTO			= 133;	// { int sendto(int s, caddr_t buf, size_t len, \
-	SYS_SHUTDOWN			= 134;	// { int shutdown(int s, int how); }
-	SYS_SOCKETPAIR			= 135;	// { int socketpair(int domain, int type, \
-	SYS_MKDIR			= 136;	// { int mkdir(char *path, int mode); }
-	SYS_RMDIR			= 137;	// { int rmdir(char *path); }
-	SYS_UTIMES			= 138;	// { int utimes(char *path, \
-	SYS_ADJTIME			= 140;	// { int adjtime(struct timeval *delta, \
-	SYS_SETSID			= 147;	// { int setsid(void); }
-	SYS_QUOTACTL			= 148;	// { int quotactl(char *path, int cmd, int uid, \
-	SYS_LGETFH			= 160;	// { int lgetfh(char *fname, \
-	SYS_GETFH			= 161;	// { int getfh(char *fname, \
-	SYS_SYSARCH			= 165;	// { int sysarch(int op, char *parms); }
-	SYS_RTPRIO			= 166;	// { int rtprio(int function, pid_t pid, \
-	SYS_FREEBSD6_PREAD		= 173;	// { ssize_t freebsd6_pread(int fd, void *buf, \
-	SYS_FREEBSD6_PWRITE		= 174;	// { ssize_t freebsd6_pwrite(int fd, \
-	SYS_SETFIB			= 175;	// { int setfib(int fibnum); }
-	SYS_NTP_ADJTIME			= 176;	// { int ntp_adjtime(struct timex *tp); }
-	SYS_SETGID			= 181;	// { int setgid(gid_t gid); }
-	SYS_SETEGID			= 182;	// { int setegid(gid_t egid); }
-	SYS_SETEUID			= 183;	// { int seteuid(uid_t euid); }
-	SYS_STAT			= 188;	// { int stat(char *path, struct stat *ub); }
-	SYS_FSTAT			= 189;	// { int fstat(int fd, struct stat *sb); }
-	SYS_LSTAT			= 190;	// { int lstat(char *path, struct stat *ub); }
-	SYS_PATHCONF			= 191;	// { int pathconf(char *path, int name); }
-	SYS_FPATHCONF			= 192;	// { int fpathconf(int fd, int name); }
-	SYS_GETRLIMIT			= 194;	// { int getrlimit(u_int which, \
-	SYS_SETRLIMIT			= 195;	// { int setrlimit(u_int which, \
-	SYS_GETDIRENTRIES		= 196;	// { int getdirentries(int fd, char *buf, \
-	SYS_FREEBSD6_MMAP		= 197;	// { caddr_t freebsd6_mmap(caddr_t addr, \
-	SYS_FREEBSD6_LSEEK		= 199;	// { off_t freebsd6_lseek(int fd, int pad, \
-	SYS_FREEBSD6_TRUNCATE		= 200;	// { int freebsd6_truncate(char *path, int pad, \
-	SYS_FREEBSD6_FTRUNCATE		= 201;	// { int freebsd6_ftruncate(int fd, int pad, \
-	SYS___SYSCTL			= 202;	// { int __sysctl(int *name, u_int namelen, \
-	SYS_MLOCK			= 203;	// { int mlock(const void *addr, size_t len); }
-	SYS_MUNLOCK			= 204;	// { int munlock(const void *addr, size_t len); }
-	SYS_UNDELETE			= 205;	// { int undelete(char *path); }
-	SYS_FUTIMES			= 206;	// { int futimes(int fd, struct timeval *tptr); }
-	SYS_GETPGID			= 207;	// { int getpgid(pid_t pid); }
-	SYS_POLL			= 209;	// { int poll(struct pollfd *fds, u_int nfds, \
-	SYS_CLOCK_GETTIME		= 232;	// { int clock_gettime(clockid_t clock_id, \
-	SYS_CLOCK_SETTIME		= 233;	// { int clock_settime( \
-	SYS_CLOCK_GETRES		= 234;	// { int clock_getres(clockid_t clock_id, \
-	SYS_KTIMER_CREATE		= 235;	// { int ktimer_create(clockid_t clock_id, \
-	SYS_KTIMER_DELETE		= 236;	// { int ktimer_delete(int timerid); }
-	SYS_KTIMER_SETTIME		= 237;	// { int ktimer_settime(int timerid, int flags, \
-	SYS_KTIMER_GETTIME		= 238;	// { int ktimer_gettime(int timerid, struct \
-	SYS_KTIMER_GETOVERRUN		= 239;	// { int ktimer_getoverrun(int timerid); }
-	SYS_NANOSLEEP			= 240;	// { int nanosleep(const struct timespec *rqtp, \
-	SYS_NTP_GETTIME			= 248;	// { int ntp_gettime(struct ntptimeval *ntvp); }
-	SYS_MINHERIT			= 250;	// { int minherit(void *addr, size_t len, \
-	SYS_RFORK			= 251;	// { int rfork(int flags); }
-	SYS_OPENBSD_POLL		= 252;	// { int openbsd_poll(struct pollfd *fds, \
-	SYS_ISSETUGID			= 253;	// { int issetugid(void); }
-	SYS_LCHOWN			= 254;	// { int lchown(char *path, int uid, int gid); }
-	SYS_GETDENTS			= 272;	// { int getdents(int fd, char *buf, \
-	SYS_LCHMOD			= 274;	// { int lchmod(char *path, mode_t mode); }
-	SYS_LUTIMES			= 276;	// { int lutimes(char *path, \
-	SYS_NSTAT			= 278;	// { int nstat(char *path, struct nstat *ub); }
-	SYS_NFSTAT			= 279;	// { int nfstat(int fd, struct nstat *sb); }
-	SYS_NLSTAT			= 280;	// { int nlstat(char *path, struct nstat *ub); }
-	SYS_PREADV			= 289;	// { ssize_t preadv(int fd, struct iovec *iovp, \
-	SYS_PWRITEV			= 290;	// { ssize_t pwritev(int fd, struct iovec *iovp, \
-	SYS_FHOPEN			= 298;	// { int fhopen(const struct fhandle *u_fhp, \
-	SYS_FHSTAT			= 299;	// { int fhstat(const struct fhandle *u_fhp, \
-	SYS_MODNEXT			= 300;	// { int modnext(int modid); }
-	SYS_MODSTAT			= 301;	// { int modstat(int modid, \
-	SYS_MODFNEXT			= 302;	// { int modfnext(int modid); }
-	SYS_MODFIND			= 303;	// { int modfind(const char *name); }
-	SYS_KLDLOAD			= 304;	// { int kldload(const char *file); }
-	SYS_KLDUNLOAD			= 305;	// { int kldunload(int fileid); }
-	SYS_KLDFIND			= 306;	// { int kldfind(const char *file); }
-	SYS_KLDNEXT			= 307;	// { int kldnext(int fileid); }
-	SYS_KLDSTAT			= 308;	// { int kldstat(int fileid, struct \
-	SYS_KLDFIRSTMOD			= 309;	// { int kldfirstmod(int fileid); }
-	SYS_GETSID			= 310;	// { int getsid(pid_t pid); }
-	SYS_SETRESUID			= 311;	// { int setresuid(uid_t ruid, uid_t euid, \
-	SYS_SETRESGID			= 312;	// { int setresgid(gid_t rgid, gid_t egid, \
-	SYS_YIELD			= 321;	// { int yield(void); }
-	SYS_MLOCKALL			= 324;	// { int mlockall(int how); }
-	SYS_MUNLOCKALL			= 325;	// { int munlockall(void); }
-	SYS___GETCWD			= 326;	// { int __getcwd(u_char *buf, u_int buflen); }
-	SYS_SCHED_SETPARAM		= 327;	// { int sched_setparam (pid_t pid, \
-	SYS_SCHED_GETPARAM		= 328;	// { int sched_getparam (pid_t pid, struct \
-	SYS_SCHED_SETSCHEDULER		= 329;	// { int sched_setscheduler (pid_t pid, int \
-	SYS_SCHED_GETSCHEDULER		= 330;	// { int sched_getscheduler (pid_t pid); }
-	SYS_SCHED_YIELD			= 331;	// { int sched_yield (void); }
-	SYS_SCHED_GET_PRIORITY_MAX	= 332;	// { int sched_get_priority_max (int policy); }
-	SYS_SCHED_GET_PRIORITY_MIN	= 333;	// { int sched_get_priority_min (int policy); }
-	SYS_SCHED_RR_GET_INTERVAL	= 334;	// { int sched_rr_get_interval (pid_t pid, \
-	SYS_UTRACE			= 335;	// { int utrace(const void *addr, size_t len); }
-	SYS_KLDSYM			= 337;	// { int kldsym(int fileid, int cmd, \
-	SYS_JAIL			= 338;	// { int jail(struct jail *jail); }
-	SYS_SIGPROCMASK			= 340;	// { int sigprocmask(int how, \
-	SYS_SIGSUSPEND			= 341;	// { int sigsuspend(const sigset_t *sigmask); }
-	SYS_SIGPENDING			= 343;	// { int sigpending(sigset_t *set); }
-	SYS_SIGTIMEDWAIT		= 345;	// { int sigtimedwait(const sigset_t *set, \
-	SYS_SIGWAITINFO			= 346;	// { int sigwaitinfo(const sigset_t *set, \
-	SYS___ACL_GET_FILE		= 347;	// { int __acl_get_file(const char *path, \
-	SYS___ACL_SET_FILE		= 348;	// { int __acl_set_file(const char *path, \
-	SYS___ACL_GET_FD		= 349;	// { int __acl_get_fd(int filedes, \
-	SYS___ACL_SET_FD		= 350;	// { int __acl_set_fd(int filedes, \
-	SYS___ACL_DELETE_FILE		= 351;	// { int __acl_delete_file(const char *path, \
-	SYS___ACL_DELETE_FD		= 352;	// { int __acl_delete_fd(int filedes, \
-	SYS___ACL_ACLCHECK_FILE		= 353;	// { int __acl_aclcheck_file(const char *path, \
-	SYS___ACL_ACLCHECK_FD		= 354;	// { int __acl_aclcheck_fd(int filedes, \
-	SYS_EXTATTRCTL			= 355;	// { int extattrctl(const char *path, int cmd, \
-	SYS_EXTATTR_SET_FILE		= 356;	// { int extattr_set_file( \
-	SYS_EXTATTR_GET_FILE		= 357;	// { ssize_t extattr_get_file( \
-	SYS_EXTATTR_DELETE_FILE		= 358;	// { int extattr_delete_file(const char *path, \
-	SYS_GETRESUID			= 360;	// { int getresuid(uid_t *ruid, uid_t *euid, \
-	SYS_GETRESGID			= 361;	// { int getresgid(gid_t *rgid, gid_t *egid, \
-	SYS_KQUEUE			= 362;	// { int kqueue(void); }
-	SYS_KEVENT			= 363;	// { int kevent(int fd, \
-	SYS_EXTATTR_SET_FD		= 371;	// { int extattr_set_fd(int fd, \
-	SYS_EXTATTR_GET_FD		= 372;	// { ssize_t extattr_get_fd(int fd, \
-	SYS_EXTATTR_DELETE_FD		= 373;	// { int extattr_delete_fd(int fd, \
-	SYS___SETUGID			= 374;	// { int __setugid(int flag); }
-	SYS_EACCESS			= 376;	// { int eaccess(char *path, int flags); }
-	SYS_NMOUNT			= 378;	// { int nmount(struct iovec *iovp, \
-	SYS___MAC_GET_PROC		= 384;	// { int __mac_get_proc(struct mac *mac_p); }
-	SYS___MAC_SET_PROC		= 385;	// { int __mac_set_proc(struct mac *mac_p); }
-	SYS___MAC_GET_FD		= 386;	// { int __mac_get_fd(int fd, \
-	SYS___MAC_GET_FILE		= 387;	// { int __mac_get_file(const char *path_p, \
-	SYS___MAC_SET_FD		= 388;	// { int __mac_set_fd(int fd, \
-	SYS___MAC_SET_FILE		= 389;	// { int __mac_set_file(const char *path_p, \
-	SYS_KENV			= 390;	// { int kenv(int what, const char *name, \
-	SYS_LCHFLAGS			= 391;	// { int lchflags(const char *path, int flags); }
-	SYS_UUIDGEN			= 392;	// { int uuidgen(struct uuid *store, \
-	SYS_SENDFILE			= 393;	// { int sendfile(int fd, int s, off_t offset, \
-	SYS_MAC_SYSCALL			= 394;	// { int mac_syscall(const char *policy, \
-	SYS_GETFSSTAT			= 395;	// { int getfsstat(struct statfs *buf, \
-	SYS_STATFS			= 396;	// { int statfs(char *path, \
-	SYS_FSTATFS			= 397;	// { int fstatfs(int fd, struct statfs *buf); }
-	SYS_FHSTATFS			= 398;	// { int fhstatfs(const struct fhandle *u_fhp, \
-	SYS___MAC_GET_PID		= 409;	// { int __mac_get_pid(pid_t pid, \
-	SYS___MAC_GET_LINK		= 410;	// { int __mac_get_link(const char *path_p, \
-	SYS___MAC_SET_LINK		= 411;	// { int __mac_set_link(const char *path_p, \
-	SYS_EXTATTR_SET_LINK		= 412;	// { int extattr_set_link( \
-	SYS_EXTATTR_GET_LINK		= 413;	// { ssize_t extattr_get_link( \
-	SYS_EXTATTR_DELETE_LINK		= 414;	// { int extattr_delete_link( \
-	SYS___MAC_EXECVE		= 415;	// { int __mac_execve(char *fname, char **argv, \
-	SYS_SIGACTION			= 416;	// { int sigaction(int sig, \
-	SYS_SIGRETURN			= 417;	// { int sigreturn( \
-	SYS_GETCONTEXT			= 421;	// { int getcontext(struct __ucontext *ucp); }
-	SYS_SETCONTEXT			= 422;	// { int setcontext( \
-	SYS_SWAPCONTEXT			= 423;	// { int swapcontext(struct __ucontext *oucp, \
-	SYS_SWAPOFF			= 424;	// { int swapoff(const char *name); }
-	SYS___ACL_GET_LINK		= 425;	// { int __acl_get_link(const char *path, \
-	SYS___ACL_SET_LINK		= 426;	// { int __acl_set_link(const char *path, \
-	SYS___ACL_DELETE_LINK		= 427;	// { int __acl_delete_link(const char *path, \
-	SYS___ACL_ACLCHECK_LINK		= 428;	// { int __acl_aclcheck_link(const char *path, \
-	SYS_SIGWAIT			= 429;	// { int sigwait(const sigset_t *set, \
-	SYS_THR_CREATE			= 430;	// { int thr_create(ucontext_t *ctx, long *id, \
-	SYS_THR_EXIT			= 431;	// { void thr_exit(long *state); }
-	SYS_THR_SELF			= 432;	// { int thr_self(long *id); }
-	SYS_THR_KILL			= 433;	// { int thr_kill(long id, int sig); }
-	SYS__UMTX_LOCK			= 434;	// { int _umtx_lock(struct umtx *umtx); }
-	SYS__UMTX_UNLOCK		= 435;	// { int _umtx_unlock(struct umtx *umtx); }
-	SYS_JAIL_ATTACH			= 436;	// { int jail_attach(int jid); }
-	SYS_EXTATTR_LIST_FD		= 437;	// { ssize_t extattr_list_fd(int fd, \
-	SYS_EXTATTR_LIST_FILE		= 438;	// { ssize_t extattr_list_file( \
-	SYS_EXTATTR_LIST_LINK		= 439;	// { ssize_t extattr_list_link( \
-	SYS_THR_SUSPEND			= 442;	// { int thr_suspend( \
-	SYS_THR_WAKE			= 443;	// { int thr_wake(long id); }
-	SYS_KLDUNLOADF			= 444;	// { int kldunloadf(int fileid, int flags); }
-	SYS_AUDIT			= 445;	// { int audit(const void *record, \
-	SYS_AUDITON			= 446;	// { int auditon(int cmd, void *data, \
-	SYS_GETAUID			= 447;	// { int getauid(uid_t *auid); }
-	SYS_SETAUID			= 448;	// { int setauid(uid_t *auid); }
-	SYS_GETAUDIT			= 449;	// { int getaudit(struct auditinfo *auditinfo); }
-	SYS_SETAUDIT			= 450;	// { int setaudit(struct auditinfo *auditinfo); }
-	SYS_GETAUDIT_ADDR		= 451;	// { int getaudit_addr( \
-	SYS_SETAUDIT_ADDR		= 452;	// { int setaudit_addr( \
-	SYS_AUDITCTL			= 453;	// { int auditctl(char *path); }
-	SYS__UMTX_OP			= 454;	// { int _umtx_op(void *obj, int op, \
-	SYS_THR_NEW			= 455;	// { int thr_new(struct thr_param *param, \
-	SYS_SIGQUEUE			= 456;	// { int sigqueue(pid_t pid, int signum, void *value); }
-	SYS_ABORT2			= 463;	// { int abort2(const char *why, int nargs, void **args); }
-	SYS_THR_SET_NAME		= 464;	// { int thr_set_name(long id, const char *name); }
-	SYS_RTPRIO_THREAD		= 466;	// { int rtprio_thread(int function, \
-	SYS_SCTP_PEELOFF		= 471;	// { int sctp_peeloff(int sd, uint32_t name); }
-	SYS_SCTP_GENERIC_SENDMSG	= 472;	// { int sctp_generic_sendmsg(int sd, caddr_t msg, int mlen, \
-	SYS_SCTP_GENERIC_SENDMSG_IOV	= 473;	// { int sctp_generic_sendmsg_iov(int sd, struct iovec *iov, int iovlen, \
-	SYS_SCTP_GENERIC_RECVMSG	= 474;	// { int sctp_generic_recvmsg(int sd, struct iovec *iov, int iovlen, \
-	SYS_PREAD			= 475;	// { ssize_t pread(int fd, void *buf, \
-	SYS_PWRITE			= 476;	// { ssize_t pwrite(int fd, const void *buf, \
-	SYS_MMAP			= 477;	// { caddr_t mmap(caddr_t addr, size_t len, \
-	SYS_LSEEK			= 478;	// { off_t lseek(int fd, off_t offset, \
-	SYS_TRUNCATE			= 479;	// { int truncate(char *path, off_t length); }
-	SYS_FTRUNCATE			= 480;	// { int ftruncate(int fd, off_t length); }
-	SYS_THR_KILL2			= 481;	// { int thr_kill2(pid_t pid, long id, int sig); }
-	SYS_SHM_OPEN			= 482;	// { int shm_open(const char *path, int flags, \
-	SYS_SHM_UNLINK			= 483;	// { int shm_unlink(const char *path); }
-	SYS_CPUSET			= 484;	// { int cpuset(cpusetid_t *setid); }
-	SYS_CPUSET_SETID		= 485;	// { int cpuset_setid(cpuwhich_t which, id_t id, \
-	SYS_CPUSET_GETID		= 486;	// { int cpuset_getid(cpulevel_t level, \
-	SYS_CPUSET_GETAFFINITY		= 487;	// { int cpuset_getaffinity(cpulevel_t level, \
-	SYS_CPUSET_SETAFFINITY		= 488;	// { int cpuset_setaffinity(cpulevel_t level, \
-	SYS_FACCESSAT			= 489;	// { int faccessat(int fd, char *path, int mode, \
-	SYS_FCHMODAT			= 490;	// { int fchmodat(int fd, char *path, mode_t mode, \
-	SYS_FCHOWNAT			= 491;	// { int fchownat(int fd, char *path, uid_t uid, \
-	SYS_FEXECVE			= 492;	// { int fexecve(int fd, char **argv, \
-	SYS_FSTATAT			= 493;	// { int fstatat(int fd, char *path, \
-	SYS_FUTIMESAT			= 494;	// { int futimesat(int fd, char *path, \
-	SYS_LINKAT			= 495;	// { int linkat(int fd1, char *path1, int fd2, \
-	SYS_MKDIRAT			= 496;	// { int mkdirat(int fd, char *path, mode_t mode); }
-	SYS_MKFIFOAT			= 497;	// { int mkfifoat(int fd, char *path, mode_t mode); }
-	SYS_MKNODAT			= 498;	// { int mknodat(int fd, char *path, mode_t mode, \
-	SYS_OPENAT			= 499;	// { int openat(int fd, char *path, int flag, \
-	SYS_READLINKAT			= 500;	// { int readlinkat(int fd, char *path, char *buf, \
-	SYS_RENAMEAT			= 501;	// { int renameat(int oldfd, char *old, int newfd, \
-	SYS_SYMLINKAT			= 502;	// { int symlinkat(char *path1, int fd, \
-	SYS_UNLINKAT			= 503;	// { int unlinkat(int fd, char *path, int flag); }
-	SYS_POSIX_OPENPT		= 504;	// { int posix_openpt(int flags); }
-	SYS_JAIL_GET			= 506;	// { int jail_get(struct iovec *iovp, \
-	SYS_JAIL_SET			= 507;	// { int jail_set(struct iovec *iovp, \
-	SYS_JAIL_REMOVE			= 508;	// { int jail_remove(int jid); }
-	SYS_CLOSEFROM			= 509;	// { int closefrom(int lowfd); }
-	SYS_LPATHCONF			= 513;	// { int lpathconf(char *path, int name); }
+	SYS_EXIT                     = 1   // { void sys_exit(int rval); } exit \
+	SYS_FORK                     = 2   // { int fork(void); }
+	SYS_READ                     = 3   // { ssize_t read(int fd, void *buf, \
+	SYS_WRITE                    = 4   // { ssize_t write(int fd, const void *buf, \
+	SYS_OPEN                     = 5   // { int open(char *path, int flags, int mode); }
+	SYS_CLOSE                    = 6   // { int close(int fd); }
+	SYS_WAIT4                    = 7   // { int wait4(int pid, int *status, \
+	SYS_LINK                     = 9   // { int link(char *path, char *link); }
+	SYS_UNLINK                   = 10  // { int unlink(char *path); }
+	SYS_CHDIR                    = 12  // { int chdir(char *path); }
+	SYS_FCHDIR                   = 13  // { int fchdir(int fd); }
+	SYS_MKNOD                    = 14  // { int mknod(char *path, int mode, int dev); }
+	SYS_CHMOD                    = 15  // { int chmod(char *path, int mode); }
+	SYS_CHOWN                    = 16  // { int chown(char *path, int uid, int gid); }
+	SYS_OBREAK                   = 17  // { int obreak(char *nsize); } break \
+	SYS_GETPID                   = 20  // { pid_t getpid(void); }
+	SYS_MOUNT                    = 21  // { int mount(char *type, char *path, \
+	SYS_UNMOUNT                  = 22  // { int unmount(char *path, int flags); }
+	SYS_SETUID                   = 23  // { int setuid(uid_t uid); }
+	SYS_GETUID                   = 24  // { uid_t getuid(void); }
+	SYS_GETEUID                  = 25  // { uid_t geteuid(void); }
+	SYS_PTRACE                   = 26  // { int ptrace(int req, pid_t pid, \
+	SYS_RECVMSG                  = 27  // { int recvmsg(int s, struct msghdr *msg, \
+	SYS_SENDMSG                  = 28  // { int sendmsg(int s, struct msghdr *msg, \
+	SYS_RECVFROM                 = 29  // { int recvfrom(int s, caddr_t buf, \
+	SYS_ACCEPT                   = 30  // { int accept(int s, \
+	SYS_GETPEERNAME              = 31  // { int getpeername(int fdes, \
+	SYS_GETSOCKNAME              = 32  // { int getsockname(int fdes, \
+	SYS_ACCESS                   = 33  // { int access(char *path, int flags); }
+	SYS_CHFLAGS                  = 34  // { int chflags(char *path, int flags); }
+	SYS_FCHFLAGS                 = 35  // { int fchflags(int fd, int flags); }
+	SYS_SYNC                     = 36  // { int sync(void); }
+	SYS_KILL                     = 37  // { int kill(int pid, int signum); }
+	SYS_GETPPID                  = 39  // { pid_t getppid(void); }
+	SYS_DUP                      = 41  // { int dup(u_int fd); }
+	SYS_PIPE                     = 42  // { int pipe(void); }
+	SYS_GETEGID                  = 43  // { gid_t getegid(void); }
+	SYS_PROFIL                   = 44  // { int profil(caddr_t samples, size_t size, \
+	SYS_KTRACE                   = 45  // { int ktrace(const char *fname, int ops, \
+	SYS_GETGID                   = 47  // { gid_t getgid(void); }
+	SYS_GETLOGIN                 = 49  // { int getlogin(char *namebuf, u_int \
+	SYS_SETLOGIN                 = 50  // { int setlogin(char *namebuf); }
+	SYS_ACCT                     = 51  // { int acct(char *path); }
+	SYS_SIGALTSTACK              = 53  // { int sigaltstack(stack_t *ss, \
+	SYS_IOCTL                    = 54  // { int ioctl(int fd, u_long com, \
+	SYS_REBOOT                   = 55  // { int reboot(int opt); }
+	SYS_REVOKE                   = 56  // { int revoke(char *path); }
+	SYS_SYMLINK                  = 57  // { int symlink(char *path, char *link); }
+	SYS_READLINK                 = 58  // { ssize_t readlink(char *path, char *buf, \
+	SYS_EXECVE                   = 59  // { int execve(char *fname, char **argv, \
+	SYS_UMASK                    = 60  // { int umask(int newmask); } umask umask_args \
+	SYS_CHROOT                   = 61  // { int chroot(char *path); }
+	SYS_MSYNC                    = 65  // { int msync(void *addr, size_t len, \
+	SYS_VFORK                    = 66  // { int vfork(void); }
+	SYS_SBRK                     = 69  // { int sbrk(int incr); }
+	SYS_SSTK                     = 70  // { int sstk(int incr); }
+	SYS_OVADVISE                 = 72  // { int ovadvise(int anom); } vadvise \
+	SYS_MUNMAP                   = 73  // { int munmap(void *addr, size_t len); }
+	SYS_MPROTECT                 = 74  // { int mprotect(const void *addr, size_t len, \
+	SYS_MADVISE                  = 75  // { int madvise(void *addr, size_t len, \
+	SYS_MINCORE                  = 78  // { int mincore(const void *addr, size_t len, \
+	SYS_GETGROUPS                = 79  // { int getgroups(u_int gidsetsize, \
+	SYS_SETGROUPS                = 80  // { int setgroups(u_int gidsetsize, \
+	SYS_GETPGRP                  = 81  // { int getpgrp(void); }
+	SYS_SETPGID                  = 82  // { int setpgid(int pid, int pgid); }
+	SYS_SETITIMER                = 83  // { int setitimer(u_int which, struct \
+	SYS_SWAPON                   = 85  // { int swapon(char *name); }
+	SYS_GETITIMER                = 86  // { int getitimer(u_int which, \
+	SYS_GETDTABLESIZE            = 89  // { int getdtablesize(void); }
+	SYS_DUP2                     = 90  // { int dup2(u_int from, u_int to); }
+	SYS_FCNTL                    = 92  // { int fcntl(int fd, int cmd, long arg); }
+	SYS_SELECT                   = 93  // { int select(int nd, fd_set *in, fd_set *ou, \
+	SYS_FSYNC                    = 95  // { int fsync(int fd); }
+	SYS_SETPRIORITY              = 96  // { int setpriority(int which, int who, \
+	SYS_SOCKET                   = 97  // { int socket(int domain, int type, \
+	SYS_CONNECT                  = 98  // { int connect(int s, caddr_t name, \
+	SYS_GETPRIORITY              = 100 // { int getpriority(int which, int who); }
+	SYS_BIND                     = 104 // { int bind(int s, caddr_t name, \
+	SYS_SETSOCKOPT               = 105 // { int setsockopt(int s, int level, int name, \
+	SYS_LISTEN                   = 106 // { int listen(int s, int backlog); }
+	SYS_GETTIMEOFDAY             = 116 // { int gettimeofday(struct timeval *tp, \
+	SYS_GETRUSAGE                = 117 // { int getrusage(int who, \
+	SYS_GETSOCKOPT               = 118 // { int getsockopt(int s, int level, int name, \
+	SYS_READV                    = 120 // { int readv(int fd, struct iovec *iovp, \
+	SYS_WRITEV                   = 121 // { int writev(int fd, struct iovec *iovp, \
+	SYS_SETTIMEOFDAY             = 122 // { int settimeofday(struct timeval *tv, \
+	SYS_FCHOWN                   = 123 // { int fchown(int fd, int uid, int gid); }
+	SYS_FCHMOD                   = 124 // { int fchmod(int fd, int mode); }
+	SYS_SETREUID                 = 126 // { int setreuid(int ruid, int euid); }
+	SYS_SETREGID                 = 127 // { int setregid(int rgid, int egid); }
+	SYS_RENAME                   = 128 // { int rename(char *from, char *to); }
+	SYS_FLOCK                    = 131 // { int flock(int fd, int how); }
+	SYS_MKFIFO                   = 132 // { int mkfifo(char *path, int mode); }
+	SYS_SENDTO                   = 133 // { int sendto(int s, caddr_t buf, size_t len, \
+	SYS_SHUTDOWN                 = 134 // { int shutdown(int s, int how); }
+	SYS_SOCKETPAIR               = 135 // { int socketpair(int domain, int type, \
+	SYS_MKDIR                    = 136 // { int mkdir(char *path, int mode); }
+	SYS_RMDIR                    = 137 // { int rmdir(char *path); }
+	SYS_UTIMES                   = 138 // { int utimes(char *path, \
+	SYS_ADJTIME                  = 140 // { int adjtime(struct timeval *delta, \
+	SYS_SETSID                   = 147 // { int setsid(void); }
+	SYS_QUOTACTL                 = 148 // { int quotactl(char *path, int cmd, int uid, \
+	SYS_LGETFH                   = 160 // { int lgetfh(char *fname, \
+	SYS_GETFH                    = 161 // { int getfh(char *fname, \
+	SYS_SYSARCH                  = 165 // { int sysarch(int op, char *parms); }
+	SYS_RTPRIO                   = 166 // { int rtprio(int function, pid_t pid, \
+	SYS_FREEBSD6_PREAD           = 173 // { ssize_t freebsd6_pread(int fd, void *buf, \
+	SYS_FREEBSD6_PWRITE          = 174 // { ssize_t freebsd6_pwrite(int fd, \
+	SYS_SETFIB                   = 175 // { int setfib(int fibnum); }
+	SYS_NTP_ADJTIME              = 176 // { int ntp_adjtime(struct timex *tp); }
+	SYS_SETGID                   = 181 // { int setgid(gid_t gid); }
+	SYS_SETEGID                  = 182 // { int setegid(gid_t egid); }
+	SYS_SETEUID                  = 183 // { int seteuid(uid_t euid); }
+	SYS_STAT                     = 188 // { int stat(char *path, struct stat *ub); }
+	SYS_FSTAT                    = 189 // { int fstat(int fd, struct stat *sb); }
+	SYS_LSTAT                    = 190 // { int lstat(char *path, struct stat *ub); }
+	SYS_PATHCONF                 = 191 // { int pathconf(char *path, int name); }
+	SYS_FPATHCONF                = 192 // { int fpathconf(int fd, int name); }
+	SYS_GETRLIMIT                = 194 // { int getrlimit(u_int which, \
+	SYS_SETRLIMIT                = 195 // { int setrlimit(u_int which, \
+	SYS_GETDIRENTRIES            = 196 // { int getdirentries(int fd, char *buf, \
+	SYS_FREEBSD6_MMAP            = 197 // { caddr_t freebsd6_mmap(caddr_t addr, \
+	SYS_FREEBSD6_LSEEK           = 199 // { off_t freebsd6_lseek(int fd, int pad, \
+	SYS_FREEBSD6_TRUNCATE        = 200 // { int freebsd6_truncate(char *path, int pad, \
+	SYS_FREEBSD6_FTRUNCATE       = 201 // { int freebsd6_ftruncate(int fd, int pad, \
+	SYS___SYSCTL                 = 202 // { int __sysctl(int *name, u_int namelen, \
+	SYS_MLOCK                    = 203 // { int mlock(const void *addr, size_t len); }
+	SYS_MUNLOCK                  = 204 // { int munlock(const void *addr, size_t len); }
+	SYS_UNDELETE                 = 205 // { int undelete(char *path); }
+	SYS_FUTIMES                  = 206 // { int futimes(int fd, struct timeval *tptr); }
+	SYS_GETPGID                  = 207 // { int getpgid(pid_t pid); }
+	SYS_POLL                     = 209 // { int poll(struct pollfd *fds, u_int nfds, \
+	SYS_CLOCK_GETTIME            = 232 // { int clock_gettime(clockid_t clock_id, \
+	SYS_CLOCK_SETTIME            = 233 // { int clock_settime( \
+	SYS_CLOCK_GETRES             = 234 // { int clock_getres(clockid_t clock_id, \
+	SYS_KTIMER_CREATE            = 235 // { int ktimer_create(clockid_t clock_id, \
+	SYS_KTIMER_DELETE            = 236 // { int ktimer_delete(int timerid); }
+	SYS_KTIMER_SETTIME           = 237 // { int ktimer_settime(int timerid, int flags, \
+	SYS_KTIMER_GETTIME           = 238 // { int ktimer_gettime(int timerid, struct \
+	SYS_KTIMER_GETOVERRUN        = 239 // { int ktimer_getoverrun(int timerid); }
+	SYS_NANOSLEEP                = 240 // { int nanosleep(const struct timespec *rqtp, \
+	SYS_NTP_GETTIME              = 248 // { int ntp_gettime(struct ntptimeval *ntvp); }
+	SYS_MINHERIT                 = 250 // { int minherit(void *addr, size_t len, \
+	SYS_RFORK                    = 251 // { int rfork(int flags); }
+	SYS_OPENBSD_POLL             = 252 // { int openbsd_poll(struct pollfd *fds, \
+	SYS_ISSETUGID                = 253 // { int issetugid(void); }
+	SYS_LCHOWN                   = 254 // { int lchown(char *path, int uid, int gid); }
+	SYS_GETDENTS                 = 272 // { int getdents(int fd, char *buf, \
+	SYS_LCHMOD                   = 274 // { int lchmod(char *path, mode_t mode); }
+	SYS_LUTIMES                  = 276 // { int lutimes(char *path, \
+	SYS_NSTAT                    = 278 // { int nstat(char *path, struct nstat *ub); }
+	SYS_NFSTAT                   = 279 // { int nfstat(int fd, struct nstat *sb); }
+	SYS_NLSTAT                   = 280 // { int nlstat(char *path, struct nstat *ub); }
+	SYS_PREADV                   = 289 // { ssize_t preadv(int fd, struct iovec *iovp, \
+	SYS_PWRITEV                  = 290 // { ssize_t pwritev(int fd, struct iovec *iovp, \
+	SYS_FHOPEN                   = 298 // { int fhopen(const struct fhandle *u_fhp, \
+	SYS_FHSTAT                   = 299 // { int fhstat(const struct fhandle *u_fhp, \
+	SYS_MODNEXT                  = 300 // { int modnext(int modid); }
+	SYS_MODSTAT                  = 301 // { int modstat(int modid, \
+	SYS_MODFNEXT                 = 302 // { int modfnext(int modid); }
+	SYS_MODFIND                  = 303 // { int modfind(const char *name); }
+	SYS_KLDLOAD                  = 304 // { int kldload(const char *file); }
+	SYS_KLDUNLOAD                = 305 // { int kldunload(int fileid); }
+	SYS_KLDFIND                  = 306 // { int kldfind(const char *file); }
+	SYS_KLDNEXT                  = 307 // { int kldnext(int fileid); }
+	SYS_KLDSTAT                  = 308 // { int kldstat(int fileid, struct \
+	SYS_KLDFIRSTMOD              = 309 // { int kldfirstmod(int fileid); }
+	SYS_GETSID                   = 310 // { int getsid(pid_t pid); }
+	SYS_SETRESUID                = 311 // { int setresuid(uid_t ruid, uid_t euid, \
+	SYS_SETRESGID                = 312 // { int setresgid(gid_t rgid, gid_t egid, \
+	SYS_YIELD                    = 321 // { int yield(void); }
+	SYS_MLOCKALL                 = 324 // { int mlockall(int how); }
+	SYS_MUNLOCKALL               = 325 // { int munlockall(void); }
+	SYS___GETCWD                 = 326 // { int __getcwd(u_char *buf, u_int buflen); }
+	SYS_SCHED_SETPARAM           = 327 // { int sched_setparam (pid_t pid, \
+	SYS_SCHED_GETPARAM           = 328 // { int sched_getparam (pid_t pid, struct \
+	SYS_SCHED_SETSCHEDULER       = 329 // { int sched_setscheduler (pid_t pid, int \
+	SYS_SCHED_GETSCHEDULER       = 330 // { int sched_getscheduler (pid_t pid); }
+	SYS_SCHED_YIELD              = 331 // { int sched_yield (void); }
+	SYS_SCHED_GET_PRIORITY_MAX   = 332 // { int sched_get_priority_max (int policy); }
+	SYS_SCHED_GET_PRIORITY_MIN   = 333 // { int sched_get_priority_min (int policy); }
+	SYS_SCHED_RR_GET_INTERVAL    = 334 // { int sched_rr_get_interval (pid_t pid, \
+	SYS_UTRACE                   = 335 // { int utrace(const void *addr, size_t len); }
+	SYS_KLDSYM                   = 337 // { int kldsym(int fileid, int cmd, \
+	SYS_JAIL                     = 338 // { int jail(struct jail *jail); }
+	SYS_SIGPROCMASK              = 340 // { int sigprocmask(int how, \
+	SYS_SIGSUSPEND               = 341 // { int sigsuspend(const sigset_t *sigmask); }
+	SYS_SIGPENDING               = 343 // { int sigpending(sigset_t *set); }
+	SYS_SIGTIMEDWAIT             = 345 // { int sigtimedwait(const sigset_t *set, \
+	SYS_SIGWAITINFO              = 346 // { int sigwaitinfo(const sigset_t *set, \
+	SYS___ACL_GET_FILE           = 347 // { int __acl_get_file(const char *path, \
+	SYS___ACL_SET_FILE           = 348 // { int __acl_set_file(const char *path, \
+	SYS___ACL_GET_FD             = 349 // { int __acl_get_fd(int filedes, \
+	SYS___ACL_SET_FD             = 350 // { int __acl_set_fd(int filedes, \
+	SYS___ACL_DELETE_FILE        = 351 // { int __acl_delete_file(const char *path, \
+	SYS___ACL_DELETE_FD          = 352 // { int __acl_delete_fd(int filedes, \
+	SYS___ACL_ACLCHECK_FILE      = 353 // { int __acl_aclcheck_file(const char *path, \
+	SYS___ACL_ACLCHECK_FD        = 354 // { int __acl_aclcheck_fd(int filedes, \
+	SYS_EXTATTRCTL               = 355 // { int extattrctl(const char *path, int cmd, \
+	SYS_EXTATTR_SET_FILE         = 356 // { int extattr_set_file( \
+	SYS_EXTATTR_GET_FILE         = 357 // { ssize_t extattr_get_file( \
+	SYS_EXTATTR_DELETE_FILE      = 358 // { int extattr_delete_file(const char *path, \
+	SYS_GETRESUID                = 360 // { int getresuid(uid_t *ruid, uid_t *euid, \
+	SYS_GETRESGID                = 361 // { int getresgid(gid_t *rgid, gid_t *egid, \
+	SYS_KQUEUE                   = 362 // { int kqueue(void); }
+	SYS_KEVENT                   = 363 // { int kevent(int fd, \
+	SYS_EXTATTR_SET_FD           = 371 // { int extattr_set_fd(int fd, \
+	SYS_EXTATTR_GET_FD           = 372 // { ssize_t extattr_get_fd(int fd, \
+	SYS_EXTATTR_DELETE_FD        = 373 // { int extattr_delete_fd(int fd, \
+	SYS___SETUGID                = 374 // { int __setugid(int flag); }
+	SYS_EACCESS                  = 376 // { int eaccess(char *path, int flags); }
+	SYS_NMOUNT                   = 378 // { int nmount(struct iovec *iovp, \
+	SYS___MAC_GET_PROC           = 384 // { int __mac_get_proc(struct mac *mac_p); }
+	SYS___MAC_SET_PROC           = 385 // { int __mac_set_proc(struct mac *mac_p); }
+	SYS___MAC_GET_FD             = 386 // { int __mac_get_fd(int fd, \
+	SYS___MAC_GET_FILE           = 387 // { int __mac_get_file(const char *path_p, \
+	SYS___MAC_SET_FD             = 388 // { int __mac_set_fd(int fd, \
+	SYS___MAC_SET_FILE           = 389 // { int __mac_set_file(const char *path_p, \
+	SYS_KENV                     = 390 // { int kenv(int what, const char *name, \
+	SYS_LCHFLAGS                 = 391 // { int lchflags(const char *path, int flags); }
+	SYS_UUIDGEN                  = 392 // { int uuidgen(struct uuid *store, \
+	SYS_SENDFILE                 = 393 // { int sendfile(int fd, int s, off_t offset, \
+	SYS_MAC_SYSCALL              = 394 // { int mac_syscall(const char *policy, \
+	SYS_GETFSSTAT                = 395 // { int getfsstat(struct statfs *buf, \
+	SYS_STATFS                   = 396 // { int statfs(char *path, \
+	SYS_FSTATFS                  = 397 // { int fstatfs(int fd, struct statfs *buf); }
+	SYS_FHSTATFS                 = 398 // { int fhstatfs(const struct fhandle *u_fhp, \
+	SYS___MAC_GET_PID            = 409 // { int __mac_get_pid(pid_t pid, \
+	SYS___MAC_GET_LINK           = 410 // { int __mac_get_link(const char *path_p, \
+	SYS___MAC_SET_LINK           = 411 // { int __mac_set_link(const char *path_p, \
+	SYS_EXTATTR_SET_LINK         = 412 // { int extattr_set_link( \
+	SYS_EXTATTR_GET_LINK         = 413 // { ssize_t extattr_get_link( \
+	SYS_EXTATTR_DELETE_LINK      = 414 // { int extattr_delete_link( \
+	SYS___MAC_EXECVE             = 415 // { int __mac_execve(char *fname, char **argv, \
+	SYS_SIGACTION                = 416 // { int sigaction(int sig, \
+	SYS_SIGRETURN                = 417 // { int sigreturn( \
+	SYS_GETCONTEXT               = 421 // { int getcontext(struct __ucontext *ucp); }
+	SYS_SETCONTEXT               = 422 // { int setcontext( \
+	SYS_SWAPCONTEXT              = 423 // { int swapcontext(struct __ucontext *oucp, \
+	SYS_SWAPOFF                  = 424 // { int swapoff(const char *name); }
+	SYS___ACL_GET_LINK           = 425 // { int __acl_get_link(const char *path, \
+	SYS___ACL_SET_LINK           = 426 // { int __acl_set_link(const char *path, \
+	SYS___ACL_DELETE_LINK        = 427 // { int __acl_delete_link(const char *path, \
+	SYS___ACL_ACLCHECK_LINK      = 428 // { int __acl_aclcheck_link(const char *path, \
+	SYS_SIGWAIT                  = 429 // { int sigwait(const sigset_t *set, \
+	SYS_THR_CREATE               = 430 // { int thr_create(ucontext_t *ctx, long *id, \
+	SYS_THR_EXIT                 = 431 // { void thr_exit(long *state); }
+	SYS_THR_SELF                 = 432 // { int thr_self(long *id); }
+	SYS_THR_KILL                 = 433 // { int thr_kill(long id, int sig); }
+	SYS__UMTX_LOCK               = 434 // { int _umtx_lock(struct umtx *umtx); }
+	SYS__UMTX_UNLOCK             = 435 // { int _umtx_unlock(struct umtx *umtx); }
+	SYS_JAIL_ATTACH              = 436 // { int jail_attach(int jid); }
+	SYS_EXTATTR_LIST_FD          = 437 // { ssize_t extattr_list_fd(int fd, \
+	SYS_EXTATTR_LIST_FILE        = 438 // { ssize_t extattr_list_file( \
+	SYS_EXTATTR_LIST_LINK        = 439 // { ssize_t extattr_list_link( \
+	SYS_THR_SUSPEND              = 442 // { int thr_suspend( \
+	SYS_THR_WAKE                 = 443 // { int thr_wake(long id); }
+	SYS_KLDUNLOADF               = 444 // { int kldunloadf(int fileid, int flags); }
+	SYS_AUDIT                    = 445 // { int audit(const void *record, \
+	SYS_AUDITON                  = 446 // { int auditon(int cmd, void *data, \
+	SYS_GETAUID                  = 447 // { int getauid(uid_t *auid); }
+	SYS_SETAUID                  = 448 // { int setauid(uid_t *auid); }
+	SYS_GETAUDIT                 = 449 // { int getaudit(struct auditinfo *auditinfo); }
+	SYS_SETAUDIT                 = 450 // { int setaudit(struct auditinfo *auditinfo); }
+	SYS_GETAUDIT_ADDR            = 451 // { int getaudit_addr( \
+	SYS_SETAUDIT_ADDR            = 452 // { int setaudit_addr( \
+	SYS_AUDITCTL                 = 453 // { int auditctl(char *path); }
+	SYS__UMTX_OP                 = 454 // { int _umtx_op(void *obj, int op, \
+	SYS_THR_NEW                  = 455 // { int thr_new(struct thr_param *param, \
+	SYS_SIGQUEUE                 = 456 // { int sigqueue(pid_t pid, int signum, void *value); }
+	SYS_ABORT2                   = 463 // { int abort2(const char *why, int nargs, void **args); }
+	SYS_THR_SET_NAME             = 464 // { int thr_set_name(long id, const char *name); }
+	SYS_RTPRIO_THREAD            = 466 // { int rtprio_thread(int function, \
+	SYS_SCTP_PEELOFF             = 471 // { int sctp_peeloff(int sd, uint32_t name); }
+	SYS_SCTP_GENERIC_SENDMSG     = 472 // { int sctp_generic_sendmsg(int sd, caddr_t msg, int mlen, \
+	SYS_SCTP_GENERIC_SENDMSG_IOV = 473 // { int sctp_generic_sendmsg_iov(int sd, struct iovec *iov, int iovlen, \
+	SYS_SCTP_GENERIC_RECVMSG     = 474 // { int sctp_generic_recvmsg(int sd, struct iovec *iov, int iovlen, \
+	SYS_PREAD                    = 475 // { ssize_t pread(int fd, void *buf, \
+	SYS_PWRITE                   = 476 // { ssize_t pwrite(int fd, const void *buf, \
+	SYS_MMAP                     = 477 // { caddr_t mmap(caddr_t addr, size_t len, \
+	SYS_LSEEK                    = 478 // { off_t lseek(int fd, off_t offset, \
+	SYS_TRUNCATE                 = 479 // { int truncate(char *path, off_t length); }
+	SYS_FTRUNCATE                = 480 // { int ftruncate(int fd, off_t length); }
+	SYS_THR_KILL2                = 481 // { int thr_kill2(pid_t pid, long id, int sig); }
+	SYS_SHM_OPEN                 = 482 // { int shm_open(const char *path, int flags, \
+	SYS_SHM_UNLINK               = 483 // { int shm_unlink(const char *path); }
+	SYS_CPUSET                   = 484 // { int cpuset(cpusetid_t *setid); }
+	SYS_CPUSET_SETID             = 485 // { int cpuset_setid(cpuwhich_t which, id_t id, \
+	SYS_CPUSET_GETID             = 486 // { int cpuset_getid(cpulevel_t level, \
+	SYS_CPUSET_GETAFFINITY       = 487 // { int cpuset_getaffinity(cpulevel_t level, \
+	SYS_CPUSET_SETAFFINITY       = 488 // { int cpuset_setaffinity(cpulevel_t level, \
+	SYS_FACCESSAT                = 489 // { int faccessat(int fd, char *path, int mode, \
+	SYS_FCHMODAT                 = 490 // { int fchmodat(int fd, char *path, mode_t mode, \
+	SYS_FCHOWNAT                 = 491 // { int fchownat(int fd, char *path, uid_t uid, \
+	SYS_FEXECVE                  = 492 // { int fexecve(int fd, char **argv, \
+	SYS_FSTATAT                  = 493 // { int fstatat(int fd, char *path, \
+	SYS_FUTIMESAT                = 494 // { int futimesat(int fd, char *path, \
+	SYS_LINKAT                   = 495 // { int linkat(int fd1, char *path1, int fd2, \
+	SYS_MKDIRAT                  = 496 // { int mkdirat(int fd, char *path, mode_t mode); }
+	SYS_MKFIFOAT                 = 497 // { int mkfifoat(int fd, char *path, mode_t mode); }
+	SYS_MKNODAT                  = 498 // { int mknodat(int fd, char *path, mode_t mode, \
+	SYS_OPENAT                   = 499 // { int openat(int fd, char *path, int flag, \
+	SYS_READLINKAT               = 500 // { int readlinkat(int fd, char *path, char *buf, \
+	SYS_RENAMEAT                 = 501 // { int renameat(int oldfd, char *old, int newfd, \
+	SYS_SYMLINKAT                = 502 // { int symlinkat(char *path1, int fd, \
+	SYS_UNLINKAT                 = 503 // { int unlinkat(int fd, char *path, int flag); }
+	SYS_POSIX_OPENPT             = 504 // { int posix_openpt(int flags); }
+	SYS_JAIL_GET                 = 506 // { int jail_get(struct iovec *iovp, \
+	SYS_JAIL_SET                 = 507 // { int jail_set(struct iovec *iovp, \
+	SYS_JAIL_REMOVE              = 508 // { int jail_remove(int jid); }
+	SYS_CLOSEFROM                = 509 // { int closefrom(int lowfd); }
+	SYS_LPATHCONF                = 513 // { int lpathconf(char *path, int name); }
 )
diff --git a/src/pkg/syscall/zsysnum_linux_386.go b/src/pkg/syscall/zsysnum_linux_386.go
index d0d743f3ec..fca0a1a6a6 100644
--- a/src/pkg/syscall/zsysnum_linux_386.go
+++ b/src/pkg/syscall/zsysnum_linux_386.go
@@ -4,315 +4,315 @@
 package syscall
 
 const (
-	SYS_RESTART_SYSCALL		= 0;
-	SYS_EXIT			= 1;
-	SYS_FORK			= 2;
-	SYS_READ			= 3;
-	SYS_WRITE			= 4;
-	SYS_OPEN			= 5;
-	SYS_CLOSE			= 6;
-	SYS_WAITPID			= 7;
-	SYS_CREAT			= 8;
-	SYS_LINK			= 9;
-	SYS_UNLINK			= 10;
-	SYS_EXECVE			= 11;
-	SYS_CHDIR			= 12;
-	SYS_TIME			= 13;
-	SYS_MKNOD			= 14;
-	SYS_CHMOD			= 15;
-	SYS_LCHOWN			= 16;
-	SYS_BREAK			= 17;
-	SYS_OLDSTAT			= 18;
-	SYS_LSEEK			= 19;
-	SYS_GETPID			= 20;
-	SYS_MOUNT			= 21;
-	SYS_UMOUNT			= 22;
-	SYS_SETUID			= 23;
-	SYS_GETUID			= 24;
-	SYS_STIME			= 25;
-	SYS_PTRACE			= 26;
-	SYS_ALARM			= 27;
-	SYS_OLDFSTAT			= 28;
-	SYS_PAUSE			= 29;
-	SYS_UTIME			= 30;
-	SYS_STTY			= 31;
-	SYS_GTTY			= 32;
-	SYS_ACCESS			= 33;
-	SYS_NICE			= 34;
-	SYS_FTIME			= 35;
-	SYS_SYNC			= 36;
-	SYS_KILL			= 37;
-	SYS_RENAME			= 38;
-	SYS_MKDIR			= 39;
-	SYS_RMDIR			= 40;
-	SYS_DUP				= 41;
-	SYS_PIPE			= 42;
-	SYS_TIMES			= 43;
-	SYS_PROF			= 44;
-	SYS_BRK				= 45;
-	SYS_SETGID			= 46;
-	SYS_GETGID			= 47;
-	SYS_SIGNAL			= 48;
-	SYS_GETEUID			= 49;
-	SYS_GETEGID			= 50;
-	SYS_ACCT			= 51;
-	SYS_UMOUNT2			= 52;
-	SYS_LOCK			= 53;
-	SYS_IOCTL			= 54;
-	SYS_FCNTL			= 55;
-	SYS_MPX				= 56;
-	SYS_SETPGID			= 57;
-	SYS_ULIMIT			= 58;
-	SYS_OLDOLDUNAME			= 59;
-	SYS_UMASK			= 60;
-	SYS_CHROOT			= 61;
-	SYS_USTAT			= 62;
-	SYS_DUP2			= 63;
-	SYS_GETPPID			= 64;
-	SYS_GETPGRP			= 65;
-	SYS_SETSID			= 66;
-	SYS_SIGACTION			= 67;
-	SYS_SGETMASK			= 68;
-	SYS_SSETMASK			= 69;
-	SYS_SETREUID			= 70;
-	SYS_SETREGID			= 71;
-	SYS_SIGSUSPEND			= 72;
-	SYS_SIGPENDING			= 73;
-	SYS_SETHOSTNAME			= 74;
-	SYS_SETRLIMIT			= 75;
-	SYS_GETRLIMIT			= 76;
-	SYS_GETRUSAGE			= 77;
-	SYS_GETTIMEOFDAY		= 78;
-	SYS_SETTIMEOFDAY		= 79;
-	SYS_GETGROUPS			= 80;
-	SYS_SETGROUPS			= 81;
-	SYS_SELECT			= 82;
-	SYS_SYMLINK			= 83;
-	SYS_OLDLSTAT			= 84;
-	SYS_READLINK			= 85;
-	SYS_USELIB			= 86;
-	SYS_SWAPON			= 87;
-	SYS_REBOOT			= 88;
-	SYS_READDIR			= 89;
-	SYS_MMAP			= 90;
-	SYS_MUNMAP			= 91;
-	SYS_TRUNCATE			= 92;
-	SYS_FTRUNCATE			= 93;
-	SYS_FCHMOD			= 94;
-	SYS_FCHOWN			= 95;
-	SYS_GETPRIORITY			= 96;
-	SYS_SETPRIORITY			= 97;
-	SYS_PROFIL			= 98;
-	SYS_STATFS			= 99;
-	SYS_FSTATFS			= 100;
-	SYS_IOPERM			= 101;
-	SYS_SOCKETCALL			= 102;
-	SYS_SYSLOG			= 103;
-	SYS_SETITIMER			= 104;
-	SYS_GETITIMER			= 105;
-	SYS_STAT			= 106;
-	SYS_LSTAT			= 107;
-	SYS_FSTAT			= 108;
-	SYS_OLDUNAME			= 109;
-	SYS_IOPL			= 110;
-	SYS_VHANGUP			= 111;
-	SYS_IDLE			= 112;
-	SYS_VM86OLD			= 113;
-	SYS_WAIT4			= 114;
-	SYS_SWAPOFF			= 115;
-	SYS_SYSINFO			= 116;
-	SYS_IPC				= 117;
-	SYS_FSYNC			= 118;
-	SYS_SIGRETURN			= 119;
-	SYS_CLONE			= 120;
-	SYS_SETDOMAINNAME		= 121;
-	SYS_UNAME			= 122;
-	SYS_MODIFY_LDT			= 123;
-	SYS_ADJTIMEX			= 124;
-	SYS_MPROTECT			= 125;
-	SYS_SIGPROCMASK			= 126;
-	SYS_CREATE_MODULE		= 127;
-	SYS_INIT_MODULE			= 128;
-	SYS_DELETE_MODULE		= 129;
-	SYS_GET_KERNEL_SYMS		= 130;
-	SYS_QUOTACTL			= 131;
-	SYS_GETPGID			= 132;
-	SYS_FCHDIR			= 133;
-	SYS_BDFLUSH			= 134;
-	SYS_SYSFS			= 135;
-	SYS_PERSONALITY			= 136;
-	SYS_AFS_SYSCALL			= 137;
-	SYS_SETFSUID			= 138;
-	SYS_SETFSGID			= 139;
-	SYS__LLSEEK			= 140;
-	SYS_GETDENTS			= 141;
-	SYS__NEWSELECT			= 142;
-	SYS_FLOCK			= 143;
-	SYS_MSYNC			= 144;
-	SYS_READV			= 145;
-	SYS_WRITEV			= 146;
-	SYS_GETSID			= 147;
-	SYS_FDATASYNC			= 148;
-	SYS__SYSCTL			= 149;
-	SYS_MLOCK			= 150;
-	SYS_MUNLOCK			= 151;
-	SYS_MLOCKALL			= 152;
-	SYS_MUNLOCKALL			= 153;
-	SYS_SCHED_SETPARAM		= 154;
-	SYS_SCHED_GETPARAM		= 155;
-	SYS_SCHED_SETSCHEDULER		= 156;
-	SYS_SCHED_GETSCHEDULER		= 157;
-	SYS_SCHED_YIELD			= 158;
-	SYS_SCHED_GET_PRIORITY_MAX	= 159;
-	SYS_SCHED_GET_PRIORITY_MIN	= 160;
-	SYS_SCHED_RR_GET_INTERVAL	= 161;
-	SYS_NANOSLEEP			= 162;
-	SYS_MREMAP			= 163;
-	SYS_SETRESUID			= 164;
-	SYS_GETRESUID			= 165;
-	SYS_VM86			= 166;
-	SYS_QUERY_MODULE		= 167;
-	SYS_POLL			= 168;
-	SYS_NFSSERVCTL			= 169;
-	SYS_SETRESGID			= 170;
-	SYS_GETRESGID			= 171;
-	SYS_PRCTL			= 172;
-	SYS_RT_SIGRETURN		= 173;
-	SYS_RT_SIGACTION		= 174;
-	SYS_RT_SIGPROCMASK		= 175;
-	SYS_RT_SIGPENDING		= 176;
-	SYS_RT_SIGTIMEDWAIT		= 177;
-	SYS_RT_SIGQUEUEINFO		= 178;
-	SYS_RT_SIGSUSPEND		= 179;
-	SYS_PREAD64			= 180;
-	SYS_PWRITE64			= 181;
-	SYS_CHOWN			= 182;
-	SYS_GETCWD			= 183;
-	SYS_CAPGET			= 184;
-	SYS_CAPSET			= 185;
-	SYS_SIGALTSTACK			= 186;
-	SYS_SENDFILE			= 187;
-	SYS_GETPMSG			= 188;
-	SYS_PUTPMSG			= 189;
-	SYS_VFORK			= 190;
-	SYS_UGETRLIMIT			= 191;
-	SYS_MMAP2			= 192;
-	SYS_TRUNCATE64			= 193;
-	SYS_FTRUNCATE64			= 194;
-	SYS_STAT64			= 195;
-	SYS_LSTAT64			= 196;
-	SYS_FSTAT64			= 197;
-	SYS_LCHOWN32			= 198;
-	SYS_GETUID32			= 199;
-	SYS_GETGID32			= 200;
-	SYS_GETEUID32			= 201;
-	SYS_GETEGID32			= 202;
-	SYS_SETREUID32			= 203;
-	SYS_SETREGID32			= 204;
-	SYS_GETGROUPS32			= 205;
-	SYS_SETGROUPS32			= 206;
-	SYS_FCHOWN32			= 207;
-	SYS_SETRESUID32			= 208;
-	SYS_GETRESUID32			= 209;
-	SYS_SETRESGID32			= 210;
-	SYS_GETRESGID32			= 211;
-	SYS_CHOWN32			= 212;
-	SYS_SETUID32			= 213;
-	SYS_SETGID32			= 214;
-	SYS_SETFSUID32			= 215;
-	SYS_SETFSGID32			= 216;
-	SYS_PIVOT_ROOT			= 217;
-	SYS_MINCORE			= 218;
-	SYS_MADVISE			= 219;
-	SYS_MADVISE1			= 219;
-	SYS_GETDENTS64			= 220;
-	SYS_FCNTL64			= 221;
-	SYS_GETTID			= 224;
-	SYS_READAHEAD			= 225;
-	SYS_SETXATTR			= 226;
-	SYS_LSETXATTR			= 227;
-	SYS_FSETXATTR			= 228;
-	SYS_GETXATTR			= 229;
-	SYS_LGETXATTR			= 230;
-	SYS_FGETXATTR			= 231;
-	SYS_LISTXATTR			= 232;
-	SYS_LLISTXATTR			= 233;
-	SYS_FLISTXATTR			= 234;
-	SYS_REMOVEXATTR			= 235;
-	SYS_LREMOVEXATTR		= 236;
-	SYS_FREMOVEXATTR		= 237;
-	SYS_TKILL			= 238;
-	SYS_SENDFILE64			= 239;
-	SYS_FUTEX			= 240;
-	SYS_SCHED_SETAFFINITY		= 241;
-	SYS_SCHED_GETAFFINITY		= 242;
-	SYS_SET_THREAD_AREA		= 243;
-	SYS_GET_THREAD_AREA		= 244;
-	SYS_IO_SETUP			= 245;
-	SYS_IO_DESTROY			= 246;
-	SYS_IO_GETEVENTS		= 247;
-	SYS_IO_SUBMIT			= 248;
-	SYS_IO_CANCEL			= 249;
-	SYS_FADVISE64			= 250;
-	SYS_EXIT_GROUP			= 252;
-	SYS_LOOKUP_DCOOKIE		= 253;
-	SYS_EPOLL_CREATE		= 254;
-	SYS_EPOLL_CTL			= 255;
-	SYS_EPOLL_WAIT			= 256;
-	SYS_REMAP_FILE_PAGES		= 257;
-	SYS_SET_TID_ADDRESS		= 258;
-	SYS_TIMER_CREATE		= 259;
-	SYS_STATFS64			= 268;
-	SYS_FSTATFS64			= 269;
-	SYS_TGKILL			= 270;
-	SYS_UTIMES			= 271;
-	SYS_FADVISE64_64		= 272;
-	SYS_VSERVER			= 273;
-	SYS_MBIND			= 274;
-	SYS_GET_MEMPOLICY		= 275;
-	SYS_SET_MEMPOLICY		= 276;
-	SYS_MQ_OPEN			= 277;
-	SYS_KEXEC_LOAD			= 283;
-	SYS_WAITID			= 284;
-	SYS_ADD_KEY			= 286;
-	SYS_REQUEST_KEY			= 287;
-	SYS_KEYCTL			= 288;
-	SYS_IOPRIO_SET			= 289;
-	SYS_IOPRIO_GET			= 290;
-	SYS_INOTIFY_INIT		= 291;
-	SYS_INOTIFY_ADD_WATCH		= 292;
-	SYS_INOTIFY_RM_WATCH		= 293;
-	SYS_MIGRATE_PAGES		= 294;
-	SYS_OPENAT			= 295;
-	SYS_MKDIRAT			= 296;
-	SYS_MKNODAT			= 297;
-	SYS_FCHOWNAT			= 298;
-	SYS_FUTIMESAT			= 299;
-	SYS_FSTATAT64			= 300;
-	SYS_UNLINKAT			= 301;
-	SYS_RENAMEAT			= 302;
-	SYS_LINKAT			= 303;
-	SYS_SYMLINKAT			= 304;
-	SYS_READLINKAT			= 305;
-	SYS_FCHMODAT			= 306;
-	SYS_FACCESSAT			= 307;
-	SYS_PSELECT6			= 308;
-	SYS_PPOLL			= 309;
-	SYS_UNSHARE			= 310;
-	SYS_SET_ROBUST_LIST		= 311;
-	SYS_GET_ROBUST_LIST		= 312;
-	SYS_SPLICE			= 313;
-	SYS_SYNC_FILE_RANGE		= 314;
-	SYS_TEE				= 315;
-	SYS_VMSPLICE			= 316;
-	SYS_MOVE_PAGES			= 317;
-	SYS_GETCPU			= 318;
-	SYS_EPOLL_PWAIT			= 319;
-	SYS_UTIMENSAT			= 320;
-	SYS_SIGNALFD			= 321;
-	SYS_TIMERFD			= 322;
-	SYS_EVENTFD			= 323;
-	SYS_FALLOCATE			= 324;
+	SYS_RESTART_SYSCALL        = 0
+	SYS_EXIT                   = 1
+	SYS_FORK                   = 2
+	SYS_READ                   = 3
+	SYS_WRITE                  = 4
+	SYS_OPEN                   = 5
+	SYS_CLOSE                  = 6
+	SYS_WAITPID                = 7
+	SYS_CREAT                  = 8
+	SYS_LINK                   = 9
+	SYS_UNLINK                 = 10
+	SYS_EXECVE                 = 11
+	SYS_CHDIR                  = 12
+	SYS_TIME                   = 13
+	SYS_MKNOD                  = 14
+	SYS_CHMOD                  = 15
+	SYS_LCHOWN                 = 16
+	SYS_BREAK                  = 17
+	SYS_OLDSTAT                = 18
+	SYS_LSEEK                  = 19
+	SYS_GETPID                 = 20
+	SYS_MOUNT                  = 21
+	SYS_UMOUNT                 = 22
+	SYS_SETUID                 = 23
+	SYS_GETUID                 = 24
+	SYS_STIME                  = 25
+	SYS_PTRACE                 = 26
+	SYS_ALARM                  = 27
+	SYS_OLDFSTAT               = 28
+	SYS_PAUSE                  = 29
+	SYS_UTIME                  = 30
+	SYS_STTY                   = 31
+	SYS_GTTY                   = 32
+	SYS_ACCESS                 = 33
+	SYS_NICE                   = 34
+	SYS_FTIME                  = 35
+	SYS_SYNC                   = 36
+	SYS_KILL                   = 37
+	SYS_RENAME                 = 38
+	SYS_MKDIR                  = 39
+	SYS_RMDIR                  = 40
+	SYS_DUP                    = 41
+	SYS_PIPE                   = 42
+	SYS_TIMES                  = 43
+	SYS_PROF                   = 44
+	SYS_BRK                    = 45
+	SYS_SETGID                 = 46
+	SYS_GETGID                 = 47
+	SYS_SIGNAL                 = 48
+	SYS_GETEUID                = 49
+	SYS_GETEGID                = 50
+	SYS_ACCT                   = 51
+	SYS_UMOUNT2                = 52
+	SYS_LOCK                   = 53
+	SYS_IOCTL                  = 54
+	SYS_FCNTL                  = 55
+	SYS_MPX                    = 56
+	SYS_SETPGID                = 57
+	SYS_ULIMIT                 = 58
+	SYS_OLDOLDUNAME            = 59
+	SYS_UMASK                  = 60
+	SYS_CHROOT                 = 61
+	SYS_USTAT                  = 62
+	SYS_DUP2                   = 63
+	SYS_GETPPID                = 64
+	SYS_GETPGRP                = 65
+	SYS_SETSID                 = 66
+	SYS_SIGACTION              = 67
+	SYS_SGETMASK               = 68
+	SYS_SSETMASK               = 69
+	SYS_SETREUID               = 70
+	SYS_SETREGID               = 71
+	SYS_SIGSUSPEND             = 72
+	SYS_SIGPENDING             = 73
+	SYS_SETHOSTNAME            = 74
+	SYS_SETRLIMIT              = 75
+	SYS_GETRLIMIT              = 76
+	SYS_GETRUSAGE              = 77
+	SYS_GETTIMEOFDAY           = 78
+	SYS_SETTIMEOFDAY           = 79
+	SYS_GETGROUPS              = 80
+	SYS_SETGROUPS              = 81
+	SYS_SELECT                 = 82
+	SYS_SYMLINK                = 83
+	SYS_OLDLSTAT               = 84
+	SYS_READLINK               = 85
+	SYS_USELIB                 = 86
+	SYS_SWAPON                 = 87
+	SYS_REBOOT                 = 88
+	SYS_READDIR                = 89
+	SYS_MMAP                   = 90
+	SYS_MUNMAP                 = 91
+	SYS_TRUNCATE               = 92
+	SYS_FTRUNCATE              = 93
+	SYS_FCHMOD                 = 94
+	SYS_FCHOWN                 = 95
+	SYS_GETPRIORITY            = 96
+	SYS_SETPRIORITY            = 97
+	SYS_PROFIL                 = 98
+	SYS_STATFS                 = 99
+	SYS_FSTATFS                = 100
+	SYS_IOPERM                 = 101
+	SYS_SOCKETCALL             = 102
+	SYS_SYSLOG                 = 103
+	SYS_SETITIMER              = 104
+	SYS_GETITIMER              = 105
+	SYS_STAT                   = 106
+	SYS_LSTAT                  = 107
+	SYS_FSTAT                  = 108
+	SYS_OLDUNAME               = 109
+	SYS_IOPL                   = 110
+	SYS_VHANGUP                = 111
+	SYS_IDLE                   = 112
+	SYS_VM86OLD                = 113
+	SYS_WAIT4                  = 114
+	SYS_SWAPOFF                = 115
+	SYS_SYSINFO                = 116
+	SYS_IPC                    = 117
+	SYS_FSYNC                  = 118
+	SYS_SIGRETURN              = 119
+	SYS_CLONE                  = 120
+	SYS_SETDOMAINNAME          = 121
+	SYS_UNAME                  = 122
+	SYS_MODIFY_LDT             = 123
+	SYS_ADJTIMEX               = 124
+	SYS_MPROTECT               = 125
+	SYS_SIGPROCMASK            = 126
+	SYS_CREATE_MODULE          = 127
+	SYS_INIT_MODULE            = 128
+	SYS_DELETE_MODULE          = 129
+	SYS_GET_KERNEL_SYMS        = 130
+	SYS_QUOTACTL               = 131
+	SYS_GETPGID                = 132
+	SYS_FCHDIR                 = 133
+	SYS_BDFLUSH                = 134
+	SYS_SYSFS                  = 135
+	SYS_PERSONALITY            = 136
+	SYS_AFS_SYSCALL            = 137
+	SYS_SETFSUID               = 138
+	SYS_SETFSGID               = 139
+	SYS__LLSEEK                = 140
+	SYS_GETDENTS               = 141
+	SYS__NEWSELECT             = 142
+	SYS_FLOCK                  = 143
+	SYS_MSYNC                  = 144
+	SYS_READV                  = 145
+	SYS_WRITEV                 = 146
+	SYS_GETSID                 = 147
+	SYS_FDATASYNC              = 148
+	SYS__SYSCTL                = 149
+	SYS_MLOCK                  = 150
+	SYS_MUNLOCK                = 151
+	SYS_MLOCKALL               = 152
+	SYS_MUNLOCKALL             = 153
+	SYS_SCHED_SETPARAM         = 154
+	SYS_SCHED_GETPARAM         = 155
+	SYS_SCHED_SETSCHEDULER     = 156
+	SYS_SCHED_GETSCHEDULER     = 157
+	SYS_SCHED_YIELD            = 158
+	SYS_SCHED_GET_PRIORITY_MAX = 159
+	SYS_SCHED_GET_PRIORITY_MIN = 160
+	SYS_SCHED_RR_GET_INTERVAL  = 161
+	SYS_NANOSLEEP              = 162
+	SYS_MREMAP                 = 163
+	SYS_SETRESUID              = 164
+	SYS_GETRESUID              = 165
+	SYS_VM86                   = 166
+	SYS_QUERY_MODULE           = 167
+	SYS_POLL                   = 168
+	SYS_NFSSERVCTL             = 169
+	SYS_SETRESGID              = 170
+	SYS_GETRESGID              = 171
+	SYS_PRCTL                  = 172
+	SYS_RT_SIGRETURN           = 173
+	SYS_RT_SIGACTION           = 174
+	SYS_RT_SIGPROCMASK         = 175
+	SYS_RT_SIGPENDING          = 176
+	SYS_RT_SIGTIMEDWAIT        = 177
+	SYS_RT_SIGQUEUEINFO        = 178
+	SYS_RT_SIGSUSPEND          = 179
+	SYS_PREAD64                = 180
+	SYS_PWRITE64               = 181
+	SYS_CHOWN                  = 182
+	SYS_GETCWD                 = 183
+	SYS_CAPGET                 = 184
+	SYS_CAPSET                 = 185
+	SYS_SIGALTSTACK            = 186
+	SYS_SENDFILE               = 187
+	SYS_GETPMSG                = 188
+	SYS_PUTPMSG                = 189
+	SYS_VFORK                  = 190
+	SYS_UGETRLIMIT             = 191
+	SYS_MMAP2                  = 192
+	SYS_TRUNCATE64             = 193
+	SYS_FTRUNCATE64            = 194
+	SYS_STAT64                 = 195
+	SYS_LSTAT64                = 196
+	SYS_FSTAT64                = 197
+	SYS_LCHOWN32               = 198
+	SYS_GETUID32               = 199
+	SYS_GETGID32               = 200
+	SYS_GETEUID32              = 201
+	SYS_GETEGID32              = 202
+	SYS_SETREUID32             = 203
+	SYS_SETREGID32             = 204
+	SYS_GETGROUPS32            = 205
+	SYS_SETGROUPS32            = 206
+	SYS_FCHOWN32               = 207
+	SYS_SETRESUID32            = 208
+	SYS_GETRESUID32            = 209
+	SYS_SETRESGID32            = 210
+	SYS_GETRESGID32            = 211
+	SYS_CHOWN32                = 212
+	SYS_SETUID32               = 213
+	SYS_SETGID32               = 214
+	SYS_SETFSUID32             = 215
+	SYS_SETFSGID32             = 216
+	SYS_PIVOT_ROOT             = 217
+	SYS_MINCORE                = 218
+	SYS_MADVISE                = 219
+	SYS_MADVISE1               = 219
+	SYS_GETDENTS64             = 220
+	SYS_FCNTL64                = 221
+	SYS_GETTID                 = 224
+	SYS_READAHEAD              = 225
+	SYS_SETXATTR               = 226
+	SYS_LSETXATTR              = 227
+	SYS_FSETXATTR              = 228
+	SYS_GETXATTR               = 229
+	SYS_LGETXATTR              = 230
+	SYS_FGETXATTR              = 231
+	SYS_LISTXATTR              = 232
+	SYS_LLISTXATTR             = 233
+	SYS_FLISTXATTR             = 234
+	SYS_REMOVEXATTR            = 235
+	SYS_LREMOVEXATTR           = 236
+	SYS_FREMOVEXATTR           = 237
+	SYS_TKILL                  = 238
+	SYS_SENDFILE64             = 239
+	SYS_FUTEX                  = 240
+	SYS_SCHED_SETAFFINITY      = 241
+	SYS_SCHED_GETAFFINITY      = 242
+	SYS_SET_THREAD_AREA        = 243
+	SYS_GET_THREAD_AREA        = 244
+	SYS_IO_SETUP               = 245
+	SYS_IO_DESTROY             = 246
+	SYS_IO_GETEVENTS           = 247
+	SYS_IO_SUBMIT              = 248
+	SYS_IO_CANCEL              = 249
+	SYS_FADVISE64              = 250
+	SYS_EXIT_GROUP             = 252
+	SYS_LOOKUP_DCOOKIE         = 253
+	SYS_EPOLL_CREATE           = 254
+	SYS_EPOLL_CTL              = 255
+	SYS_EPOLL_WAIT             = 256
+	SYS_REMAP_FILE_PAGES       = 257
+	SYS_SET_TID_ADDRESS        = 258
+	SYS_TIMER_CREATE           = 259
+	SYS_STATFS64               = 268
+	SYS_FSTATFS64              = 269
+	SYS_TGKILL                 = 270
+	SYS_UTIMES                 = 271
+	SYS_FADVISE64_64           = 272
+	SYS_VSERVER                = 273
+	SYS_MBIND                  = 274
+	SYS_GET_MEMPOLICY          = 275
+	SYS_SET_MEMPOLICY          = 276
+	SYS_MQ_OPEN                = 277
+	SYS_KEXEC_LOAD             = 283
+	SYS_WAITID                 = 284
+	SYS_ADD_KEY                = 286
+	SYS_REQUEST_KEY            = 287
+	SYS_KEYCTL                 = 288
+	SYS_IOPRIO_SET             = 289
+	SYS_IOPRIO_GET             = 290
+	SYS_INOTIFY_INIT           = 291
+	SYS_INOTIFY_ADD_WATCH      = 292
+	SYS_INOTIFY_RM_WATCH       = 293
+	SYS_MIGRATE_PAGES          = 294
+	SYS_OPENAT                 = 295
+	SYS_MKDIRAT                = 296
+	SYS_MKNODAT                = 297
+	SYS_FCHOWNAT               = 298
+	SYS_FUTIMESAT              = 299
+	SYS_FSTATAT64              = 300
+	SYS_UNLINKAT               = 301
+	SYS_RENAMEAT               = 302
+	SYS_LINKAT                 = 303
+	SYS_SYMLINKAT              = 304
+	SYS_READLINKAT             = 305
+	SYS_FCHMODAT               = 306
+	SYS_FACCESSAT              = 307
+	SYS_PSELECT6               = 308
+	SYS_PPOLL                  = 309
+	SYS_UNSHARE                = 310
+	SYS_SET_ROBUST_LIST        = 311
+	SYS_GET_ROBUST_LIST        = 312
+	SYS_SPLICE                 = 313
+	SYS_SYNC_FILE_RANGE        = 314
+	SYS_TEE                    = 315
+	SYS_VMSPLICE               = 316
+	SYS_MOVE_PAGES             = 317
+	SYS_GETCPU                 = 318
+	SYS_EPOLL_PWAIT            = 319
+	SYS_UTIMENSAT              = 320
+	SYS_SIGNALFD               = 321
+	SYS_TIMERFD                = 322
+	SYS_EVENTFD                = 323
+	SYS_FALLOCATE              = 324
 )
 
-func _darwin_system_call_conflict()	{}
+func _darwin_system_call_conflict() {}
diff --git a/src/pkg/syscall/zsysnum_linux_amd64.go b/src/pkg/syscall/zsysnum_linux_amd64.go
index 055e65b5d7..e7a2929943 100644
--- a/src/pkg/syscall/zsysnum_linux_amd64.go
+++ b/src/pkg/syscall/zsysnum_linux_amd64.go
@@ -4,292 +4,292 @@
 package syscall
 
 const (
-	SYS_READ			= 0;
-	SYS_WRITE			= 1;
-	SYS_OPEN			= 2;
-	SYS_CLOSE			= 3;
-	SYS_STAT			= 4;
-	SYS_FSTAT			= 5;
-	SYS_LSTAT			= 6;
-	SYS_POLL			= 7;
-	SYS_LSEEK			= 8;
-	SYS_MMAP			= 9;
-	SYS_MPROTECT			= 10;
-	SYS_MUNMAP			= 11;
-	SYS_BRK				= 12;
-	SYS_RT_SIGACTION		= 13;
-	SYS_RT_SIGPROCMASK		= 14;
-	SYS_RT_SIGRETURN		= 15;
-	SYS_IOCTL			= 16;
-	SYS_PREAD64			= 17;
-	SYS_PWRITE64			= 18;
-	SYS_READV			= 19;
-	SYS_WRITEV			= 20;
-	SYS_ACCESS			= 21;
-	SYS_PIPE			= 22;
-	SYS_SELECT			= 23;
-	SYS_SCHED_YIELD			= 24;
-	SYS_MREMAP			= 25;
-	SYS_MSYNC			= 26;
-	SYS_MINCORE			= 27;
-	SYS_MADVISE			= 28;
-	SYS_SHMGET			= 29;
-	SYS_SHMAT			= 30;
-	SYS_SHMCTL			= 31;
-	SYS_DUP				= 32;
-	SYS_DUP2			= 33;
-	SYS_PAUSE			= 34;
-	SYS_NANOSLEEP			= 35;
-	SYS_GETITIMER			= 36;
-	SYS_ALARM			= 37;
-	SYS_SETITIMER			= 38;
-	SYS_GETPID			= 39;
-	SYS_SENDFILE			= 40;
-	SYS_SOCKET			= 41;
-	SYS_CONNECT			= 42;
-	SYS_ACCEPT			= 43;
-	SYS_SENDTO			= 44;
-	SYS_RECVFROM			= 45;
-	SYS_SENDMSG			= 46;
-	SYS_RECVMSG			= 47;
-	SYS_SHUTDOWN			= 48;
-	SYS_BIND			= 49;
-	SYS_LISTEN			= 50;
-	SYS_GETSOCKNAME			= 51;
-	SYS_GETPEERNAME			= 52;
-	SYS_SOCKETPAIR			= 53;
-	SYS_SETSOCKOPT			= 54;
-	SYS_GETSOCKOPT			= 55;
-	SYS_CLONE			= 56;
-	SYS_FORK			= 57;
-	SYS_VFORK			= 58;
-	SYS_EXECVE			= 59;
-	SYS_EXIT			= 60;
-	SYS_WAIT4			= 61;
-	SYS_KILL			= 62;
-	SYS_UNAME			= 63;
-	SYS_SEMGET			= 64;
-	SYS_SEMOP			= 65;
-	SYS_SEMCTL			= 66;
-	SYS_SHMDT			= 67;
-	SYS_MSGGET			= 68;
-	SYS_MSGSND			= 69;
-	SYS_MSGRCV			= 70;
-	SYS_MSGCTL			= 71;
-	SYS_FCNTL			= 72;
-	SYS_FLOCK			= 73;
-	SYS_FSYNC			= 74;
-	SYS_FDATASYNC			= 75;
-	SYS_TRUNCATE			= 76;
-	SYS_FTRUNCATE			= 77;
-	SYS_GETDENTS			= 78;
-	SYS_GETCWD			= 79;
-	SYS_CHDIR			= 80;
-	SYS_FCHDIR			= 81;
-	SYS_RENAME			= 82;
-	SYS_MKDIR			= 83;
-	SYS_RMDIR			= 84;
-	SYS_CREAT			= 85;
-	SYS_LINK			= 86;
-	SYS_UNLINK			= 87;
-	SYS_SYMLINK			= 88;
-	SYS_READLINK			= 89;
-	SYS_CHMOD			= 90;
-	SYS_FCHMOD			= 91;
-	SYS_CHOWN			= 92;
-	SYS_FCHOWN			= 93;
-	SYS_LCHOWN			= 94;
-	SYS_UMASK			= 95;
-	SYS_GETTIMEOFDAY		= 96;
-	SYS_GETRLIMIT			= 97;
-	SYS_GETRUSAGE			= 98;
-	SYS_SYSINFO			= 99;
-	SYS_TIMES			= 100;
-	SYS_PTRACE			= 101;
-	SYS_GETUID			= 102;
-	SYS_SYSLOG			= 103;
-	SYS_GETGID			= 104;
-	SYS_SETUID			= 105;
-	SYS_SETGID			= 106;
-	SYS_GETEUID			= 107;
-	SYS_GETEGID			= 108;
-	SYS_SETPGID			= 109;
-	SYS_GETPPID			= 110;
-	SYS_GETPGRP			= 111;
-	SYS_SETSID			= 112;
-	SYS_SETREUID			= 113;
-	SYS_SETREGID			= 114;
-	SYS_GETGROUPS			= 115;
-	SYS_SETGROUPS			= 116;
-	SYS_SETRESUID			= 117;
-	SYS_GETRESUID			= 118;
-	SYS_SETRESGID			= 119;
-	SYS_GETRESGID			= 120;
-	SYS_GETPGID			= 121;
-	SYS_SETFSUID			= 122;
-	SYS_SETFSGID			= 123;
-	SYS_GETSID			= 124;
-	SYS_CAPGET			= 125;
-	SYS_CAPSET			= 126;
-	SYS_RT_SIGPENDING		= 127;
-	SYS_RT_SIGTIMEDWAIT		= 128;
-	SYS_RT_SIGQUEUEINFO		= 129;
-	SYS_RT_SIGSUSPEND		= 130;
-	SYS_SIGALTSTACK			= 131;
-	SYS_UTIME			= 132;
-	SYS_MKNOD			= 133;
-	SYS_USELIB			= 134;
-	SYS_PERSONALITY			= 135;
-	SYS_USTAT			= 136;
-	SYS_STATFS			= 137;
-	SYS_FSTATFS			= 138;
-	SYS_SYSFS			= 139;
-	SYS_GETPRIORITY			= 140;
-	SYS_SETPRIORITY			= 141;
-	SYS_SCHED_SETPARAM		= 142;
-	SYS_SCHED_GETPARAM		= 143;
-	SYS_SCHED_SETSCHEDULER		= 144;
-	SYS_SCHED_GETSCHEDULER		= 145;
-	SYS_SCHED_GET_PRIORITY_MAX	= 146;
-	SYS_SCHED_GET_PRIORITY_MIN	= 147;
-	SYS_SCHED_RR_GET_INTERVAL	= 148;
-	SYS_MLOCK			= 149;
-	SYS_MUNLOCK			= 150;
-	SYS_MLOCKALL			= 151;
-	SYS_MUNLOCKALL			= 152;
-	SYS_VHANGUP			= 153;
-	SYS_MODIFY_LDT			= 154;
-	SYS_PIVOT_ROOT			= 155;
-	SYS__SYSCTL			= 156;
-	SYS_PRCTL			= 157;
-	SYS_ARCH_PRCTL			= 158;
-	SYS_ADJTIMEX			= 159;
-	SYS_SETRLIMIT			= 160;
-	SYS_CHROOT			= 161;
-	SYS_SYNC			= 162;
-	SYS_ACCT			= 163;
-	SYS_SETTIMEOFDAY		= 164;
-	SYS_MOUNT			= 165;
-	SYS_UMOUNT2			= 166;
-	SYS_SWAPON			= 167;
-	SYS_SWAPOFF			= 168;
-	SYS_REBOOT			= 169;
-	SYS_SETHOSTNAME			= 170;
-	SYS_SETDOMAINNAME		= 171;
-	SYS_IOPL			= 172;
-	SYS_IOPERM			= 173;
-	SYS_CREATE_MODULE		= 174;
-	SYS_INIT_MODULE			= 175;
-	SYS_DELETE_MODULE		= 176;
-	SYS_GET_KERNEL_SYMS		= 177;
-	SYS_QUERY_MODULE		= 178;
-	SYS_QUOTACTL			= 179;
-	SYS_NFSSERVCTL			= 180;
-	SYS_GETPMSG			= 181;
-	SYS_PUTPMSG			= 182;
-	SYS_AFS_SYSCALL			= 183;
-	SYS_TUXCALL			= 184;
-	SYS_SECURITY			= 185;
-	SYS_GETTID			= 186;
-	SYS_READAHEAD			= 187;
-	SYS_SETXATTR			= 188;
-	SYS_LSETXATTR			= 189;
-	SYS_FSETXATTR			= 190;
-	SYS_GETXATTR			= 191;
-	SYS_LGETXATTR			= 192;
-	SYS_FGETXATTR			= 193;
-	SYS_LISTXATTR			= 194;
-	SYS_LLISTXATTR			= 195;
-	SYS_FLISTXATTR			= 196;
-	SYS_REMOVEXATTR			= 197;
-	SYS_LREMOVEXATTR		= 198;
-	SYS_FREMOVEXATTR		= 199;
-	SYS_TKILL			= 200;
-	SYS_TIME			= 201;
-	SYS_FUTEX			= 202;
-	SYS_SCHED_SETAFFINITY		= 203;
-	SYS_SCHED_GETAFFINITY		= 204;
-	SYS_SET_THREAD_AREA		= 205;
-	SYS_IO_SETUP			= 206;
-	SYS_IO_DESTROY			= 207;
-	SYS_IO_GETEVENTS		= 208;
-	SYS_IO_SUBMIT			= 209;
-	SYS_IO_CANCEL			= 210;
-	SYS_GET_THREAD_AREA		= 211;
-	SYS_LOOKUP_DCOOKIE		= 212;
-	SYS_EPOLL_CREATE		= 213;
-	SYS_EPOLL_CTL_OLD		= 214;
-	SYS_EPOLL_WAIT_OLD		= 215;
-	SYS_REMAP_FILE_PAGES		= 216;
-	SYS_GETDENTS64			= 217;
-	SYS_SET_TID_ADDRESS		= 218;
-	SYS_RESTART_SYSCALL		= 219;
-	SYS_SEMTIMEDOP			= 220;
-	SYS_FADVISE64			= 221;
-	SYS_TIMER_CREATE		= 222;
-	SYS_TIMER_SETTIME		= 223;
-	SYS_TIMER_GETTIME		= 224;
-	SYS_TIMER_GETOVERRUN		= 225;
-	SYS_TIMER_DELETE		= 226;
-	SYS_CLOCK_SETTIME		= 227;
-	SYS_CLOCK_GETTIME		= 228;
-	SYS_CLOCK_GETRES		= 229;
-	SYS_CLOCK_NANOSLEEP		= 230;
-	SYS_EXIT_GROUP			= 231;
-	SYS_EPOLL_WAIT			= 232;
-	SYS_EPOLL_CTL			= 233;
-	SYS_TGKILL			= 234;
-	SYS_UTIMES			= 235;
-	SYS_VSERVER			= 236;
-	SYS_MBIND			= 237;
-	SYS_SET_MEMPOLICY		= 238;
-	SYS_GET_MEMPOLICY		= 239;
-	SYS_MQ_OPEN			= 240;
-	SYS_MQ_UNLINK			= 241;
-	SYS_MQ_TIMEDSEND		= 242;
-	SYS_MQ_TIMEDRECEIVE		= 243;
-	SYS_MQ_NOTIFY			= 244;
-	SYS_MQ_GETSETATTR		= 245;
-	SYS_KEXEC_LOAD			= 246;
-	SYS_WAITID			= 247;
-	SYS_ADD_KEY			= 248;
-	SYS_REQUEST_KEY			= 249;
-	SYS_KEYCTL			= 250;
-	SYS_IOPRIO_SET			= 251;
-	SYS_IOPRIO_GET			= 252;
-	SYS_INOTIFY_INIT		= 253;
-	SYS_INOTIFY_ADD_WATCH		= 254;
-	SYS_INOTIFY_RM_WATCH		= 255;
-	SYS_MIGRATE_PAGES		= 256;
-	SYS_OPENAT			= 257;
-	SYS_MKDIRAT			= 258;
-	SYS_MKNODAT			= 259;
-	SYS_FCHOWNAT			= 260;
-	SYS_FUTIMESAT			= 261;
-	SYS_NEWFSTATAT			= 262;
-	SYS_UNLINKAT			= 263;
-	SYS_RENAMEAT			= 264;
-	SYS_LINKAT			= 265;
-	SYS_SYMLINKAT			= 266;
-	SYS_READLINKAT			= 267;
-	SYS_FCHMODAT			= 268;
-	SYS_FACCESSAT			= 269;
-	SYS_PSELECT6			= 270;
-	SYS_PPOLL			= 271;
-	SYS_UNSHARE			= 272;
-	SYS_SET_ROBUST_LIST		= 273;
-	SYS_GET_ROBUST_LIST		= 274;
-	SYS_SPLICE			= 275;
-	SYS_TEE				= 276;
-	SYS_SYNC_FILE_RANGE		= 277;
-	SYS_VMSPLICE			= 278;
-	SYS_MOVE_PAGES			= 279;
-	SYS_UTIMENSAT			= 280;
-	SYS_EPOLL_PWAIT			= 281;
-	SYS_SIGNALFD			= 282;
-	SYS_TIMERFD			= 283;
-	SYS_EVENTFD			= 284;
-	SYS_FALLOCATE			= 285;
+	SYS_READ                   = 0
+	SYS_WRITE                  = 1
+	SYS_OPEN                   = 2
+	SYS_CLOSE                  = 3
+	SYS_STAT                   = 4
+	SYS_FSTAT                  = 5
+	SYS_LSTAT                  = 6
+	SYS_POLL                   = 7
+	SYS_LSEEK                  = 8
+	SYS_MMAP                   = 9
+	SYS_MPROTECT               = 10
+	SYS_MUNMAP                 = 11
+	SYS_BRK                    = 12
+	SYS_RT_SIGACTION           = 13
+	SYS_RT_SIGPROCMASK         = 14
+	SYS_RT_SIGRETURN           = 15
+	SYS_IOCTL                  = 16
+	SYS_PREAD64                = 17
+	SYS_PWRITE64               = 18
+	SYS_READV                  = 19
+	SYS_WRITEV                 = 20
+	SYS_ACCESS                 = 21
+	SYS_PIPE                   = 22
+	SYS_SELECT                 = 23
+	SYS_SCHED_YIELD            = 24
+	SYS_MREMAP                 = 25
+	SYS_MSYNC                  = 26
+	SYS_MINCORE                = 27
+	SYS_MADVISE                = 28
+	SYS_SHMGET                 = 29
+	SYS_SHMAT                  = 30
+	SYS_SHMCTL                 = 31
+	SYS_DUP                    = 32
+	SYS_DUP2                   = 33
+	SYS_PAUSE                  = 34
+	SYS_NANOSLEEP              = 35
+	SYS_GETITIMER              = 36
+	SYS_ALARM                  = 37
+	SYS_SETITIMER              = 38
+	SYS_GETPID                 = 39
+	SYS_SENDFILE               = 40
+	SYS_SOCKET                 = 41
+	SYS_CONNECT                = 42
+	SYS_ACCEPT                 = 43
+	SYS_SENDTO                 = 44
+	SYS_RECVFROM               = 45
+	SYS_SENDMSG                = 46
+	SYS_RECVMSG                = 47
+	SYS_SHUTDOWN               = 48
+	SYS_BIND                   = 49
+	SYS_LISTEN                 = 50
+	SYS_GETSOCKNAME            = 51
+	SYS_GETPEERNAME            = 52
+	SYS_SOCKETPAIR             = 53
+	SYS_SETSOCKOPT             = 54
+	SYS_GETSOCKOPT             = 55
+	SYS_CLONE                  = 56
+	SYS_FORK                   = 57
+	SYS_VFORK                  = 58
+	SYS_EXECVE                 = 59
+	SYS_EXIT                   = 60
+	SYS_WAIT4                  = 61
+	SYS_KILL                   = 62
+	SYS_UNAME                  = 63
+	SYS_SEMGET                 = 64
+	SYS_SEMOP                  = 65
+	SYS_SEMCTL                 = 66
+	SYS_SHMDT                  = 67
+	SYS_MSGGET                 = 68
+	SYS_MSGSND                 = 69
+	SYS_MSGRCV                 = 70
+	SYS_MSGCTL                 = 71
+	SYS_FCNTL                  = 72
+	SYS_FLOCK                  = 73
+	SYS_FSYNC                  = 74
+	SYS_FDATASYNC              = 75
+	SYS_TRUNCATE               = 76
+	SYS_FTRUNCATE              = 77
+	SYS_GETDENTS               = 78
+	SYS_GETCWD                 = 79
+	SYS_CHDIR                  = 80
+	SYS_FCHDIR                 = 81
+	SYS_RENAME                 = 82
+	SYS_MKDIR                  = 83
+	SYS_RMDIR                  = 84
+	SYS_CREAT                  = 85
+	SYS_LINK                   = 86
+	SYS_UNLINK                 = 87
+	SYS_SYMLINK                = 88
+	SYS_READLINK               = 89
+	SYS_CHMOD                  = 90
+	SYS_FCHMOD                 = 91
+	SYS_CHOWN                  = 92
+	SYS_FCHOWN                 = 93
+	SYS_LCHOWN                 = 94
+	SYS_UMASK                  = 95
+	SYS_GETTIMEOFDAY           = 96
+	SYS_GETRLIMIT              = 97
+	SYS_GETRUSAGE              = 98
+	SYS_SYSINFO                = 99
+	SYS_TIMES                  = 100
+	SYS_PTRACE                 = 101
+	SYS_GETUID                 = 102
+	SYS_SYSLOG                 = 103
+	SYS_GETGID                 = 104
+	SYS_SETUID                 = 105
+	SYS_SETGID                 = 106
+	SYS_GETEUID                = 107
+	SYS_GETEGID                = 108
+	SYS_SETPGID                = 109
+	SYS_GETPPID                = 110
+	SYS_GETPGRP                = 111
+	SYS_SETSID                 = 112
+	SYS_SETREUID               = 113
+	SYS_SETREGID               = 114
+	SYS_GETGROUPS              = 115
+	SYS_SETGROUPS              = 116
+	SYS_SETRESUID              = 117
+	SYS_GETRESUID              = 118
+	SYS_SETRESGID              = 119
+	SYS_GETRESGID              = 120
+	SYS_GETPGID                = 121
+	SYS_SETFSUID               = 122
+	SYS_SETFSGID               = 123
+	SYS_GETSID                 = 124
+	SYS_CAPGET                 = 125
+	SYS_CAPSET                 = 126
+	SYS_RT_SIGPENDING          = 127
+	SYS_RT_SIGTIMEDWAIT        = 128
+	SYS_RT_SIGQUEUEINFO        = 129
+	SYS_RT_SIGSUSPEND          = 130
+	SYS_SIGALTSTACK            = 131
+	SYS_UTIME                  = 132
+	SYS_MKNOD                  = 133
+	SYS_USELIB                 = 134
+	SYS_PERSONALITY            = 135
+	SYS_USTAT                  = 136
+	SYS_STATFS                 = 137
+	SYS_FSTATFS                = 138
+	SYS_SYSFS                  = 139
+	SYS_GETPRIORITY            = 140
+	SYS_SETPRIORITY            = 141
+	SYS_SCHED_SETPARAM         = 142
+	SYS_SCHED_GETPARAM         = 143
+	SYS_SCHED_SETSCHEDULER     = 144
+	SYS_SCHED_GETSCHEDULER     = 145
+	SYS_SCHED_GET_PRIORITY_MAX = 146
+	SYS_SCHED_GET_PRIORITY_MIN = 147
+	SYS_SCHED_RR_GET_INTERVAL  = 148
+	SYS_MLOCK                  = 149
+	SYS_MUNLOCK                = 150
+	SYS_MLOCKALL               = 151
+	SYS_MUNLOCKALL             = 152
+	SYS_VHANGUP                = 153
+	SYS_MODIFY_LDT             = 154
+	SYS_PIVOT_ROOT             = 155
+	SYS__SYSCTL                = 156
+	SYS_PRCTL                  = 157
+	SYS_ARCH_PRCTL             = 158
+	SYS_ADJTIMEX               = 159
+	SYS_SETRLIMIT              = 160
+	SYS_CHROOT                 = 161
+	SYS_SYNC                   = 162
+	SYS_ACCT                   = 163
+	SYS_SETTIMEOFDAY           = 164
+	SYS_MOUNT                  = 165
+	SYS_UMOUNT2                = 166
+	SYS_SWAPON                 = 167
+	SYS_SWAPOFF                = 168
+	SYS_REBOOT                 = 169
+	SYS_SETHOSTNAME            = 170
+	SYS_SETDOMAINNAME          = 171
+	SYS_IOPL                   = 172
+	SYS_IOPERM                 = 173
+	SYS_CREATE_MODULE          = 174
+	SYS_INIT_MODULE            = 175
+	SYS_DELETE_MODULE          = 176
+	SYS_GET_KERNEL_SYMS        = 177
+	SYS_QUERY_MODULE           = 178
+	SYS_QUOTACTL               = 179
+	SYS_NFSSERVCTL             = 180
+	SYS_GETPMSG                = 181
+	SYS_PUTPMSG                = 182
+	SYS_AFS_SYSCALL            = 183
+	SYS_TUXCALL                = 184
+	SYS_SECURITY               = 185
+	SYS_GETTID                 = 186
+	SYS_READAHEAD              = 187
+	SYS_SETXATTR               = 188
+	SYS_LSETXATTR              = 189
+	SYS_FSETXATTR              = 190
+	SYS_GETXATTR               = 191
+	SYS_LGETXATTR              = 192
+	SYS_FGETXATTR              = 193
+	SYS_LISTXATTR              = 194
+	SYS_LLISTXATTR             = 195
+	SYS_FLISTXATTR             = 196
+	SYS_REMOVEXATTR            = 197
+	SYS_LREMOVEXATTR           = 198
+	SYS_FREMOVEXATTR           = 199
+	SYS_TKILL                  = 200
+	SYS_TIME                   = 201
+	SYS_FUTEX                  = 202
+	SYS_SCHED_SETAFFINITY      = 203
+	SYS_SCHED_GETAFFINITY      = 204
+	SYS_SET_THREAD_AREA        = 205
+	SYS_IO_SETUP               = 206
+	SYS_IO_DESTROY             = 207
+	SYS_IO_GETEVENTS           = 208
+	SYS_IO_SUBMIT              = 209
+	SYS_IO_CANCEL              = 210
+	SYS_GET_THREAD_AREA        = 211
+	SYS_LOOKUP_DCOOKIE         = 212
+	SYS_EPOLL_CREATE           = 213
+	SYS_EPOLL_CTL_OLD          = 214
+	SYS_EPOLL_WAIT_OLD         = 215
+	SYS_REMAP_FILE_PAGES       = 216
+	SYS_GETDENTS64             = 217
+	SYS_SET_TID_ADDRESS        = 218
+	SYS_RESTART_SYSCALL        = 219
+	SYS_SEMTIMEDOP             = 220
+	SYS_FADVISE64              = 221
+	SYS_TIMER_CREATE           = 222
+	SYS_TIMER_SETTIME          = 223
+	SYS_TIMER_GETTIME          = 224
+	SYS_TIMER_GETOVERRUN       = 225
+	SYS_TIMER_DELETE           = 226
+	SYS_CLOCK_SETTIME          = 227
+	SYS_CLOCK_GETTIME          = 228
+	SYS_CLOCK_GETRES           = 229
+	SYS_CLOCK_NANOSLEEP        = 230
+	SYS_EXIT_GROUP             = 231
+	SYS_EPOLL_WAIT             = 232
+	SYS_EPOLL_CTL              = 233
+	SYS_TGKILL                 = 234
+	SYS_UTIMES                 = 235
+	SYS_VSERVER                = 236
+	SYS_MBIND                  = 237
+	SYS_SET_MEMPOLICY          = 238
+	SYS_GET_MEMPOLICY          = 239
+	SYS_MQ_OPEN                = 240
+	SYS_MQ_UNLINK              = 241
+	SYS_MQ_TIMEDSEND           = 242
+	SYS_MQ_TIMEDRECEIVE        = 243
+	SYS_MQ_NOTIFY              = 244
+	SYS_MQ_GETSETATTR          = 245
+	SYS_KEXEC_LOAD             = 246
+	SYS_WAITID                 = 247
+	SYS_ADD_KEY                = 248
+	SYS_REQUEST_KEY            = 249
+	SYS_KEYCTL                 = 250
+	SYS_IOPRIO_SET             = 251
+	SYS_IOPRIO_GET             = 252
+	SYS_INOTIFY_INIT           = 253
+	SYS_INOTIFY_ADD_WATCH      = 254
+	SYS_INOTIFY_RM_WATCH       = 255
+	SYS_MIGRATE_PAGES          = 256
+	SYS_OPENAT                 = 257
+	SYS_MKDIRAT                = 258
+	SYS_MKNODAT                = 259
+	SYS_FCHOWNAT               = 260
+	SYS_FUTIMESAT              = 261
+	SYS_NEWFSTATAT             = 262
+	SYS_UNLINKAT               = 263
+	SYS_RENAMEAT               = 264
+	SYS_LINKAT                 = 265
+	SYS_SYMLINKAT              = 266
+	SYS_READLINKAT             = 267
+	SYS_FCHMODAT               = 268
+	SYS_FACCESSAT              = 269
+	SYS_PSELECT6               = 270
+	SYS_PPOLL                  = 271
+	SYS_UNSHARE                = 272
+	SYS_SET_ROBUST_LIST        = 273
+	SYS_GET_ROBUST_LIST        = 274
+	SYS_SPLICE                 = 275
+	SYS_TEE                    = 276
+	SYS_SYNC_FILE_RANGE        = 277
+	SYS_VMSPLICE               = 278
+	SYS_MOVE_PAGES             = 279
+	SYS_UTIMENSAT              = 280
+	SYS_EPOLL_PWAIT            = 281
+	SYS_SIGNALFD               = 282
+	SYS_TIMERFD                = 283
+	SYS_EVENTFD                = 284
+	SYS_FALLOCATE              = 285
 )
 
-func _darwin_system_call_conflict()	{}
+func _darwin_system_call_conflict() {}
diff --git a/src/pkg/syscall/zsysnum_linux_arm.go b/src/pkg/syscall/zsysnum_linux_arm.go
index d1936c049e..8d22929ef7 100644
--- a/src/pkg/syscall/zsysnum_linux_arm.go
+++ b/src/pkg/syscall/zsysnum_linux_arm.go
@@ -3,334 +3,334 @@
 package syscall
 
 const (
-	SYS_SYSCALL_BASE	= 0;
+	SYS_SYSCALL_BASE = 0
 
-	SYS_RESTART_SYSCALL		= (SYS_SYSCALL_BASE + 0);
-	SYS_EXIT			= (SYS_SYSCALL_BASE + 1);
-	SYS_FORK			= (SYS_SYSCALL_BASE + 2);
-	SYS_READ			= (SYS_SYSCALL_BASE + 3);
-	SYS_WRITE			= (SYS_SYSCALL_BASE + 4);
-	SYS_OPEN			= (SYS_SYSCALL_BASE + 5);
-	SYS_CLOSE			= (SYS_SYSCALL_BASE + 6);
-	SYS_CREAT			= (SYS_SYSCALL_BASE + 8);
-	SYS_LINK			= (SYS_SYSCALL_BASE + 9);
-	SYS_UNLINK			= (SYS_SYSCALL_BASE + 10);
-	SYS_EXECVE			= (SYS_SYSCALL_BASE + 11);
-	SYS_CHDIR			= (SYS_SYSCALL_BASE + 12);
-	SYS_TIME			= (SYS_SYSCALL_BASE + 13);
-	SYS_MKNOD			= (SYS_SYSCALL_BASE + 14);
-	SYS_CHMOD			= (SYS_SYSCALL_BASE + 15);
-	SYS_LCHOWN			= (SYS_SYSCALL_BASE + 16);
-	SYS_LSEEK			= (SYS_SYSCALL_BASE + 19);
-	SYS_GETPID			= (SYS_SYSCALL_BASE + 20);
-	SYS_MOUNT			= (SYS_SYSCALL_BASE + 21);
-	SYS_UMOUNT			= (SYS_SYSCALL_BASE + 22);
-	SYS_SETUID			= (SYS_SYSCALL_BASE + 23);
-	SYS_GETUID			= (SYS_SYSCALL_BASE + 24);
-	SYS_STIME			= (SYS_SYSCALL_BASE + 25);
-	SYS_PTRACE			= (SYS_SYSCALL_BASE + 26);
-	SYS_ALARM			= (SYS_SYSCALL_BASE + 27);
-	SYS_PAUSE			= (SYS_SYSCALL_BASE + 29);
-	SYS_UTIME			= (SYS_SYSCALL_BASE + 30);
-	SYS_ACCESS			= (SYS_SYSCALL_BASE + 33);
-	SYS_NICE			= (SYS_SYSCALL_BASE + 34);
-	SYS_SYNC			= (SYS_SYSCALL_BASE + 36);
-	SYS_KILL			= (SYS_SYSCALL_BASE + 37);
-	SYS_RENAME			= (SYS_SYSCALL_BASE + 38);
-	SYS_MKDIR			= (SYS_SYSCALL_BASE + 39);
-	SYS_RMDIR			= (SYS_SYSCALL_BASE + 40);
-	SYS_DUP				= (SYS_SYSCALL_BASE + 41);
-	SYS_PIPE			= (SYS_SYSCALL_BASE + 42);
-	SYS_TIMES			= (SYS_SYSCALL_BASE + 43);
-	SYS_BRK				= (SYS_SYSCALL_BASE + 45);
-	SYS_SETGID			= (SYS_SYSCALL_BASE + 46);
-	SYS_GETGID			= (SYS_SYSCALL_BASE + 47);
-	SYS_GETEUID			= (SYS_SYSCALL_BASE + 49);
-	SYS_GETEGID			= (SYS_SYSCALL_BASE + 50);
-	SYS_ACCT			= (SYS_SYSCALL_BASE + 51);
-	SYS_UMOUNT2			= (SYS_SYSCALL_BASE + 52);
-	SYS_IOCTL			= (SYS_SYSCALL_BASE + 54);
-	SYS_FCNTL			= (SYS_SYSCALL_BASE + 55);
-	SYS_SETPGID			= (SYS_SYSCALL_BASE + 57);
-	SYS_UMASK			= (SYS_SYSCALL_BASE + 60);
-	SYS_CHROOT			= (SYS_SYSCALL_BASE + 61);
-	SYS_USTAT			= (SYS_SYSCALL_BASE + 62);
-	SYS_DUP2			= (SYS_SYSCALL_BASE + 63);
-	SYS_GETPPID			= (SYS_SYSCALL_BASE + 64);
-	SYS_GETPGRP			= (SYS_SYSCALL_BASE + 65);
-	SYS_SETSID			= (SYS_SYSCALL_BASE + 66);
-	SYS_SIGACTION			= (SYS_SYSCALL_BASE + 67);
-	SYS_SETREUID			= (SYS_SYSCALL_BASE + 70);
-	SYS_SETREGID			= (SYS_SYSCALL_BASE + 71);
-	SYS_SIGSUSPEND			= (SYS_SYSCALL_BASE + 72);
-	SYS_SIGPENDING			= (SYS_SYSCALL_BASE + 73);
-	SYS_SETHOSTNAME			= (SYS_SYSCALL_BASE + 74);
-	SYS_SETRLIMIT			= (SYS_SYSCALL_BASE + 75);
-	SYS_GETRLIMIT			= (SYS_SYSCALL_BASE + 76);
-	SYS_GETRUSAGE			= (SYS_SYSCALL_BASE + 77);
-	SYS_GETTIMEOFDAY		= (SYS_SYSCALL_BASE + 78);
-	SYS_SETTIMEOFDAY		= (SYS_SYSCALL_BASE + 79);
-	SYS_GETGROUPS			= (SYS_SYSCALL_BASE + 80);
-	SYS_SETGROUPS			= (SYS_SYSCALL_BASE + 81);
-	SYS_SELECT			= (SYS_SYSCALL_BASE + 82);
-	SYS_SYMLINK			= (SYS_SYSCALL_BASE + 83);
-	SYS_READLINK			= (SYS_SYSCALL_BASE + 85);
-	SYS_USELIB			= (SYS_SYSCALL_BASE + 86);
-	SYS_SWAPON			= (SYS_SYSCALL_BASE + 87);
-	SYS_REBOOT			= (SYS_SYSCALL_BASE + 88);
-	SYS_READDIR			= (SYS_SYSCALL_BASE + 89);
-	SYS_MMAP			= (SYS_SYSCALL_BASE + 90);
-	SYS_MUNMAP			= (SYS_SYSCALL_BASE + 91);
-	SYS_TRUNCATE			= (SYS_SYSCALL_BASE + 92);
-	SYS_FTRUNCATE			= (SYS_SYSCALL_BASE + 93);
-	SYS_FCHMOD			= (SYS_SYSCALL_BASE + 94);
-	SYS_FCHOWN			= (SYS_SYSCALL_BASE + 95);
-	SYS_GETPRIORITY			= (SYS_SYSCALL_BASE + 96);
-	SYS_SETPRIORITY			= (SYS_SYSCALL_BASE + 97);
-	SYS_STATFS			= (SYS_SYSCALL_BASE + 99);
-	SYS_FSTATFS			= (SYS_SYSCALL_BASE + 100);
-	SYS_SOCKETCALL			= (SYS_SYSCALL_BASE + 102);
-	SYS_SYSLOG			= (SYS_SYSCALL_BASE + 103);
-	SYS_SETITIMER			= (SYS_SYSCALL_BASE + 104);
-	SYS_GETITIMER			= (SYS_SYSCALL_BASE + 105);
-	SYS_STAT			= (SYS_SYSCALL_BASE + 106);
-	SYS_LSTAT			= (SYS_SYSCALL_BASE + 107);
-	SYS_FSTAT			= (SYS_SYSCALL_BASE + 108);
-	SYS_VHANGUP			= (SYS_SYSCALL_BASE + 111);
-	SYS_SYSCALL			= (SYS_SYSCALL_BASE + 113);
-	SYS_WAIT4			= (SYS_SYSCALL_BASE + 114);
-	SYS_SWAPOFF			= (SYS_SYSCALL_BASE + 115);
-	SYS_SYSINFO			= (SYS_SYSCALL_BASE + 116);
-	SYS_IPC				= (SYS_SYSCALL_BASE + 117);
-	SYS_FSYNC			= (SYS_SYSCALL_BASE + 118);
-	SYS_SIGRETURN			= (SYS_SYSCALL_BASE + 119);
-	SYS_CLONE			= (SYS_SYSCALL_BASE + 120);
-	SYS_SETDOMAINNAME		= (SYS_SYSCALL_BASE + 121);
-	SYS_UNAME			= (SYS_SYSCALL_BASE + 122);
-	SYS_ADJTIMEX			= (SYS_SYSCALL_BASE + 124);
-	SYS_MPROTECT			= (SYS_SYSCALL_BASE + 125);
-	SYS_SIGPROCMASK			= (SYS_SYSCALL_BASE + 126);
-	SYS_INIT_MODULE			= (SYS_SYSCALL_BASE + 128);
-	SYS_DELETE_MODULE		= (SYS_SYSCALL_BASE + 129);
-	SYS_QUOTACTL			= (SYS_SYSCALL_BASE + 131);
-	SYS_GETPGID			= (SYS_SYSCALL_BASE + 132);
-	SYS_FCHDIR			= (SYS_SYSCALL_BASE + 133);
-	SYS_BDFLUSH			= (SYS_SYSCALL_BASE + 134);
-	SYS_SYSFS			= (SYS_SYSCALL_BASE + 135);
-	SYS_PERSONALITY			= (SYS_SYSCALL_BASE + 136);
-	SYS_SETFSUID			= (SYS_SYSCALL_BASE + 138);
-	SYS_SETFSGID			= (SYS_SYSCALL_BASE + 139);
-	SYS__LLSEEK			= (SYS_SYSCALL_BASE + 140);
-	SYS_GETDENTS			= (SYS_SYSCALL_BASE + 141);
-	SYS__NEWSELECT			= (SYS_SYSCALL_BASE + 142);
-	SYS_FLOCK			= (SYS_SYSCALL_BASE + 143);
-	SYS_MSYNC			= (SYS_SYSCALL_BASE + 144);
-	SYS_READV			= (SYS_SYSCALL_BASE + 145);
-	SYS_WRITEV			= (SYS_SYSCALL_BASE + 146);
-	SYS_GETSID			= (SYS_SYSCALL_BASE + 147);
-	SYS_FDATASYNC			= (SYS_SYSCALL_BASE + 148);
-	SYS__SYSCTL			= (SYS_SYSCALL_BASE + 149);
-	SYS_MLOCK			= (SYS_SYSCALL_BASE + 150);
-	SYS_MUNLOCK			= (SYS_SYSCALL_BASE + 151);
-	SYS_MLOCKALL			= (SYS_SYSCALL_BASE + 152);
-	SYS_MUNLOCKALL			= (SYS_SYSCALL_BASE + 153);
-	SYS_SCHED_SETPARAM		= (SYS_SYSCALL_BASE + 154);
-	SYS_SCHED_GETPARAM		= (SYS_SYSCALL_BASE + 155);
-	SYS_SCHED_SETSCHEDULER		= (SYS_SYSCALL_BASE + 156);
-	SYS_SCHED_GETSCHEDULER		= (SYS_SYSCALL_BASE + 157);
-	SYS_SCHED_YIELD			= (SYS_SYSCALL_BASE + 158);
-	SYS_SCHED_GET_PRIORITY_MAX	= (SYS_SYSCALL_BASE + 159);
-	SYS_SCHED_GET_PRIORITY_MIN	= (SYS_SYSCALL_BASE + 160);
-	SYS_SCHED_RR_GET_INTERVAL	= (SYS_SYSCALL_BASE + 161);
-	SYS_NANOSLEEP			= (SYS_SYSCALL_BASE + 162);
-	SYS_MREMAP			= (SYS_SYSCALL_BASE + 163);
-	SYS_SETRESUID			= (SYS_SYSCALL_BASE + 164);
-	SYS_GETRESUID			= (SYS_SYSCALL_BASE + 165);
-	SYS_POLL			= (SYS_SYSCALL_BASE + 168);
-	SYS_NFSSERVCTL			= (SYS_SYSCALL_BASE + 169);
-	SYS_SETRESGID			= (SYS_SYSCALL_BASE + 170);
-	SYS_GETRESGID			= (SYS_SYSCALL_BASE + 171);
-	SYS_PRCTL			= (SYS_SYSCALL_BASE + 172);
-	SYS_RT_SIGRETURN		= (SYS_SYSCALL_BASE + 173);
-	SYS_RT_SIGACTION		= (SYS_SYSCALL_BASE + 174);
-	SYS_RT_SIGPROCMASK		= (SYS_SYSCALL_BASE + 175);
-	SYS_RT_SIGPENDING		= (SYS_SYSCALL_BASE + 176);
-	SYS_RT_SIGTIMEDWAIT		= (SYS_SYSCALL_BASE + 177);
-	SYS_RT_SIGQUEUEINFO		= (SYS_SYSCALL_BASE + 178);
-	SYS_RT_SIGSUSPEND		= (SYS_SYSCALL_BASE + 179);
-	SYS_PREAD64			= (SYS_SYSCALL_BASE + 180);
-	SYS_PWRITE64			= (SYS_SYSCALL_BASE + 181);
-	SYS_CHOWN			= (SYS_SYSCALL_BASE + 182);
-	SYS_GETCWD			= (SYS_SYSCALL_BASE + 183);
-	SYS_CAPGET			= (SYS_SYSCALL_BASE + 184);
-	SYS_CAPSET			= (SYS_SYSCALL_BASE + 185);
-	SYS_SIGALTSTACK			= (SYS_SYSCALL_BASE + 186);
-	SYS_SENDFILE			= (SYS_SYSCALL_BASE + 187);
-	SYS_VFORK			= (SYS_SYSCALL_BASE + 190);
-	SYS_UGETRLIMIT			= (SYS_SYSCALL_BASE + 191);
-	SYS_MMAP2			= (SYS_SYSCALL_BASE + 192);
-	SYS_TRUNCATE64			= (SYS_SYSCALL_BASE + 193);
-	SYS_FTRUNCATE64			= (SYS_SYSCALL_BASE + 194);
-	SYS_STAT64			= (SYS_SYSCALL_BASE + 195);
-	SYS_LSTAT64			= (SYS_SYSCALL_BASE + 196);
-	SYS_FSTAT64			= (SYS_SYSCALL_BASE + 197);
-	SYS_LCHOWN32			= (SYS_SYSCALL_BASE + 198);
-	SYS_GETUID32			= (SYS_SYSCALL_BASE + 199);
-	SYS_GETGID32			= (SYS_SYSCALL_BASE + 200);
-	SYS_GETEUID32			= (SYS_SYSCALL_BASE + 201);
-	SYS_GETEGID32			= (SYS_SYSCALL_BASE + 202);
-	SYS_SETREUID32			= (SYS_SYSCALL_BASE + 203);
-	SYS_SETREGID32			= (SYS_SYSCALL_BASE + 204);
-	SYS_GETGROUPS32			= (SYS_SYSCALL_BASE + 205);
-	SYS_SETGROUPS32			= (SYS_SYSCALL_BASE + 206);
-	SYS_FCHOWN32			= (SYS_SYSCALL_BASE + 207);
-	SYS_SETRESUID32			= (SYS_SYSCALL_BASE + 208);
-	SYS_GETRESUID32			= (SYS_SYSCALL_BASE + 209);
-	SYS_SETRESGID32			= (SYS_SYSCALL_BASE + 210);
-	SYS_GETRESGID32			= (SYS_SYSCALL_BASE + 211);
-	SYS_CHOWN32			= (SYS_SYSCALL_BASE + 212);
-	SYS_SETUID32			= (SYS_SYSCALL_BASE + 213);
-	SYS_SETGID32			= (SYS_SYSCALL_BASE + 214);
-	SYS_SETFSUID32			= (SYS_SYSCALL_BASE + 215);
-	SYS_SETFSGID32			= (SYS_SYSCALL_BASE + 216);
-	SYS_GETDENTS64			= (SYS_SYSCALL_BASE + 217);
-	SYS_PIVOT_ROOT			= (SYS_SYSCALL_BASE + 218);
-	SYS_MINCORE			= (SYS_SYSCALL_BASE + 219);
-	SYS_MADVISE			= (SYS_SYSCALL_BASE + 220);
-	SYS_FCNTL64			= (SYS_SYSCALL_BASE + 221);
-	SYS_GETTID			= (SYS_SYSCALL_BASE + 224);
-	SYS_READAHEAD			= (SYS_SYSCALL_BASE + 225);
-	SYS_SETXATTR			= (SYS_SYSCALL_BASE + 226);
-	SYS_LSETXATTR			= (SYS_SYSCALL_BASE + 227);
-	SYS_FSETXATTR			= (SYS_SYSCALL_BASE + 228);
-	SYS_GETXATTR			= (SYS_SYSCALL_BASE + 229);
-	SYS_LGETXATTR			= (SYS_SYSCALL_BASE + 230);
-	SYS_FGETXATTR			= (SYS_SYSCALL_BASE + 231);
-	SYS_LISTXATTR			= (SYS_SYSCALL_BASE + 232);
-	SYS_LLISTXATTR			= (SYS_SYSCALL_BASE + 233);
-	SYS_FLISTXATTR			= (SYS_SYSCALL_BASE + 234);
-	SYS_REMOVEXATTR			= (SYS_SYSCALL_BASE + 235);
-	SYS_LREMOVEXATTR		= (SYS_SYSCALL_BASE + 236);
-	SYS_FREMOVEXATTR		= (SYS_SYSCALL_BASE + 237);
-	SYS_TKILL			= (SYS_SYSCALL_BASE + 238);
-	SYS_SENDFILE64			= (SYS_SYSCALL_BASE + 239);
-	SYS_FUTEX			= (SYS_SYSCALL_BASE + 240);
-	SYS_SCHED_SETAFFINITY		= (SYS_SYSCALL_BASE + 241);
-	SYS_SCHED_GETAFFINITY		= (SYS_SYSCALL_BASE + 242);
-	SYS_IO_SETUP			= (SYS_SYSCALL_BASE + 243);
-	SYS_IO_DESTROY			= (SYS_SYSCALL_BASE + 244);
-	SYS_IO_GETEVENTS		= (SYS_SYSCALL_BASE + 245);
-	SYS_IO_SUBMIT			= (SYS_SYSCALL_BASE + 246);
-	SYS_IO_CANCEL			= (SYS_SYSCALL_BASE + 247);
-	SYS_EXIT_GROUP			= (SYS_SYSCALL_BASE + 248);
-	SYS_LOOKUP_DCOOKIE		= (SYS_SYSCALL_BASE + 249);
-	SYS_EPOLL_CREATE		= (SYS_SYSCALL_BASE + 250);
-	SYS_EPOLL_CTL			= (SYS_SYSCALL_BASE + 251);
-	SYS_EPOLL_WAIT			= (SYS_SYSCALL_BASE + 252);
-	SYS_REMAP_FILE_PAGES		= (SYS_SYSCALL_BASE + 253);
-	SYS_SET_TID_ADDRESS		= (SYS_SYSCALL_BASE + 256);
-	SYS_TIMER_CREATE		= (SYS_SYSCALL_BASE + 257);
-	SYS_TIMER_SETTIME		= (SYS_SYSCALL_BASE + 258);
-	SYS_TIMER_GETTIME		= (SYS_SYSCALL_BASE + 259);
-	SYS_TIMER_GETOVERRUN		= (SYS_SYSCALL_BASE + 260);
-	SYS_TIMER_DELETE		= (SYS_SYSCALL_BASE + 261);
-	SYS_CLOCK_SETTIME		= (SYS_SYSCALL_BASE + 262);
-	SYS_CLOCK_GETTIME		= (SYS_SYSCALL_BASE + 263);
-	SYS_CLOCK_GETRES		= (SYS_SYSCALL_BASE + 264);
-	SYS_CLOCK_NANOSLEEP		= (SYS_SYSCALL_BASE + 265);
-	SYS_STATFS64			= (SYS_SYSCALL_BASE + 266);
-	SYS_FSTATFS64			= (SYS_SYSCALL_BASE + 267);
-	SYS_TGKILL			= (SYS_SYSCALL_BASE + 268);
-	SYS_UTIMES			= (SYS_SYSCALL_BASE + 269);
-	SYS_ARM_FADVISE64_64		= (SYS_SYSCALL_BASE + 270);
-	SYS_PCICONFIG_IOBASE		= (SYS_SYSCALL_BASE + 271);
-	SYS_PCICONFIG_READ		= (SYS_SYSCALL_BASE + 272);
-	SYS_PCICONFIG_WRITE		= (SYS_SYSCALL_BASE + 273);
-	SYS_MQ_OPEN			= (SYS_SYSCALL_BASE + 274);
-	SYS_MQ_UNLINK			= (SYS_SYSCALL_BASE + 275);
-	SYS_MQ_TIMEDSEND		= (SYS_SYSCALL_BASE + 276);
-	SYS_MQ_TIMEDRECEIVE		= (SYS_SYSCALL_BASE + 277);
-	SYS_MQ_NOTIFY			= (SYS_SYSCALL_BASE + 278);
-	SYS_MQ_GETSETATTR		= (SYS_SYSCALL_BASE + 279);
-	SYS_WAITID			= (SYS_SYSCALL_BASE + 280);
-	SYS_SOCKET			= (SYS_SYSCALL_BASE + 281);
-	SYS_BIND			= (SYS_SYSCALL_BASE + 282);
-	SYS_CONNECT			= (SYS_SYSCALL_BASE + 283);
-	SYS_LISTEN			= (SYS_SYSCALL_BASE + 284);
-	SYS_ACCEPT			= (SYS_SYSCALL_BASE + 285);
-	SYS_GETSOCKNAME			= (SYS_SYSCALL_BASE + 286);
-	SYS_GETPEERNAME			= (SYS_SYSCALL_BASE + 287);
-	SYS_SOCKETPAIR			= (SYS_SYSCALL_BASE + 288);
-	SYS_SEND			= (SYS_SYSCALL_BASE + 289);
-	SYS_SENDTO			= (SYS_SYSCALL_BASE + 290);
-	SYS_RECV			= (SYS_SYSCALL_BASE + 291);
-	SYS_RECVFROM			= (SYS_SYSCALL_BASE + 292);
-	SYS_SHUTDOWN			= (SYS_SYSCALL_BASE + 293);
-	SYS_SETSOCKOPT			= (SYS_SYSCALL_BASE + 294);
-	SYS_GETSOCKOPT			= (SYS_SYSCALL_BASE + 295);
-	SYS_SENDMSG			= (SYS_SYSCALL_BASE + 296);
-	SYS_RECVMSG			= (SYS_SYSCALL_BASE + 297);
-	SYS_SEMOP			= (SYS_SYSCALL_BASE + 298);
-	SYS_SEMGET			= (SYS_SYSCALL_BASE + 299);
-	SYS_SEMCTL			= (SYS_SYSCALL_BASE + 300);
-	SYS_MSGSND			= (SYS_SYSCALL_BASE + 301);
-	SYS_MSGRCV			= (SYS_SYSCALL_BASE + 302);
-	SYS_MSGGET			= (SYS_SYSCALL_BASE + 303);
-	SYS_MSGCTL			= (SYS_SYSCALL_BASE + 304);
-	SYS_SHMAT			= (SYS_SYSCALL_BASE + 305);
-	SYS_SHMDT			= (SYS_SYSCALL_BASE + 306);
-	SYS_SHMGET			= (SYS_SYSCALL_BASE + 307);
-	SYS_SHMCTL			= (SYS_SYSCALL_BASE + 308);
-	SYS_ADD_KEY			= (SYS_SYSCALL_BASE + 309);
-	SYS_REQUEST_KEY			= (SYS_SYSCALL_BASE + 310);
-	SYS_KEYCTL			= (SYS_SYSCALL_BASE + 311);
-	SYS_SEMTIMEDOP			= (SYS_SYSCALL_BASE + 312);
-	SYS_VSERVER			= (SYS_SYSCALL_BASE + 313);
-	SYS_IOPRIO_SET			= (SYS_SYSCALL_BASE + 314);
-	SYS_IOPRIO_GET			= (SYS_SYSCALL_BASE + 315);
-	SYS_INOTIFY_INIT		= (SYS_SYSCALL_BASE + 316);
-	SYS_INOTIFY_ADD_WATCH		= (SYS_SYSCALL_BASE + 317);
-	SYS_INOTIFY_RM_WATCH		= (SYS_SYSCALL_BASE + 318);
-	SYS_MBIND			= (SYS_SYSCALL_BASE + 319);
-	SYS_GET_MEMPOLICY		= (SYS_SYSCALL_BASE + 320);
-	SYS_SET_MEMPOLICY		= (SYS_SYSCALL_BASE + 321);
-	SYS_OPENAT			= (SYS_SYSCALL_BASE + 322);
-	SYS_MKDIRAT			= (SYS_SYSCALL_BASE + 323);
-	SYS_MKNODAT			= (SYS_SYSCALL_BASE + 324);
-	SYS_FCHOWNAT			= (SYS_SYSCALL_BASE + 325);
-	SYS_FUTIMESAT			= (SYS_SYSCALL_BASE + 326);
-	SYS_FSTATAT64			= (SYS_SYSCALL_BASE + 327);
-	SYS_UNLINKAT			= (SYS_SYSCALL_BASE + 328);
-	SYS_RENAMEAT			= (SYS_SYSCALL_BASE + 329);
-	SYS_LINKAT			= (SYS_SYSCALL_BASE + 330);
-	SYS_SYMLINKAT			= (SYS_SYSCALL_BASE + 331);
-	SYS_READLINKAT			= (SYS_SYSCALL_BASE + 332);
-	SYS_FCHMODAT			= (SYS_SYSCALL_BASE + 333);
-	SYS_FACCESSAT			= (SYS_SYSCALL_BASE + 334);
-	SYS_UNSHARE			= (SYS_SYSCALL_BASE + 337);
-	SYS_SET_ROBUST_LIST		= (SYS_SYSCALL_BASE + 338);
-	SYS_GET_ROBUST_LIST		= (SYS_SYSCALL_BASE + 339);
-	SYS_SPLICE			= (SYS_SYSCALL_BASE + 340);
-	SYS_ARM_SYNC_FILE_RANGE		= (SYS_SYSCALL_BASE + 341);
-	SYS_SYNC_FILE_RANGE2		= SYS_ARM_SYNC_FILE_RANGE;
-	SYS_TEE				= (SYS_SYSCALL_BASE + 342);
-	SYS_VMSPLICE			= (SYS_SYSCALL_BASE + 343);
-	SYS_MOVE_PAGES			= (SYS_SYSCALL_BASE + 344);
-	SYS_GETCPU			= (SYS_SYSCALL_BASE + 345);
-	SYS_KEXEC_LOAD			= (SYS_SYSCALL_BASE + 347);
-	SYS_UTIMENSAT			= (SYS_SYSCALL_BASE + 348);
-	SYS_SIGNALFD			= (SYS_SYSCALL_BASE + 349);
-	SYS_TIMERFD_CREATE		= (SYS_SYSCALL_BASE + 350);
-	SYS_EVENTFD			= (SYS_SYSCALL_BASE + 351);
-	SYS_FALLOCATE			= (SYS_SYSCALL_BASE + 352);
-	SYS_TIMERFD_SETTIME		= (SYS_SYSCALL_BASE + 353);
-	SYS_TIMERFD_GETTIME		= (SYS_SYSCALL_BASE + 354);
-	SYS_SIGNALFD4			= (SYS_SYSCALL_BASE + 355);
-	SYS_EVENTFD2			= (SYS_SYSCALL_BASE + 356);
-	SYS_EPOLL_CREATE1		= (SYS_SYSCALL_BASE + 357);
-	SYS_DUP3			= (SYS_SYSCALL_BASE + 358);
-	SYS_PIPE2			= (SYS_SYSCALL_BASE + 359);
-	SYS_INOTIFY_INIT1		= (SYS_SYSCALL_BASE + 360);
+	SYS_RESTART_SYSCALL        = (SYS_SYSCALL_BASE + 0)
+	SYS_EXIT                   = (SYS_SYSCALL_BASE + 1)
+	SYS_FORK                   = (SYS_SYSCALL_BASE + 2)
+	SYS_READ                   = (SYS_SYSCALL_BASE + 3)
+	SYS_WRITE                  = (SYS_SYSCALL_BASE + 4)
+	SYS_OPEN                   = (SYS_SYSCALL_BASE + 5)
+	SYS_CLOSE                  = (SYS_SYSCALL_BASE + 6)
+	SYS_CREAT                  = (SYS_SYSCALL_BASE + 8)
+	SYS_LINK                   = (SYS_SYSCALL_BASE + 9)
+	SYS_UNLINK                 = (SYS_SYSCALL_BASE + 10)
+	SYS_EXECVE                 = (SYS_SYSCALL_BASE + 11)
+	SYS_CHDIR                  = (SYS_SYSCALL_BASE + 12)
+	SYS_TIME                   = (SYS_SYSCALL_BASE + 13)
+	SYS_MKNOD                  = (SYS_SYSCALL_BASE + 14)
+	SYS_CHMOD                  = (SYS_SYSCALL_BASE + 15)
+	SYS_LCHOWN                 = (SYS_SYSCALL_BASE + 16)
+	SYS_LSEEK                  = (SYS_SYSCALL_BASE + 19)
+	SYS_GETPID                 = (SYS_SYSCALL_BASE + 20)
+	SYS_MOUNT                  = (SYS_SYSCALL_BASE + 21)
+	SYS_UMOUNT                 = (SYS_SYSCALL_BASE + 22)
+	SYS_SETUID                 = (SYS_SYSCALL_BASE + 23)
+	SYS_GETUID                 = (SYS_SYSCALL_BASE + 24)
+	SYS_STIME                  = (SYS_SYSCALL_BASE + 25)
+	SYS_PTRACE                 = (SYS_SYSCALL_BASE + 26)
+	SYS_ALARM                  = (SYS_SYSCALL_BASE + 27)
+	SYS_PAUSE                  = (SYS_SYSCALL_BASE + 29)
+	SYS_UTIME                  = (SYS_SYSCALL_BASE + 30)
+	SYS_ACCESS                 = (SYS_SYSCALL_BASE + 33)
+	SYS_NICE                   = (SYS_SYSCALL_BASE + 34)
+	SYS_SYNC                   = (SYS_SYSCALL_BASE + 36)
+	SYS_KILL                   = (SYS_SYSCALL_BASE + 37)
+	SYS_RENAME                 = (SYS_SYSCALL_BASE + 38)
+	SYS_MKDIR                  = (SYS_SYSCALL_BASE + 39)
+	SYS_RMDIR                  = (SYS_SYSCALL_BASE + 40)
+	SYS_DUP                    = (SYS_SYSCALL_BASE + 41)
+	SYS_PIPE                   = (SYS_SYSCALL_BASE + 42)
+	SYS_TIMES                  = (SYS_SYSCALL_BASE + 43)
+	SYS_BRK                    = (SYS_SYSCALL_BASE + 45)
+	SYS_SETGID                 = (SYS_SYSCALL_BASE + 46)
+	SYS_GETGID                 = (SYS_SYSCALL_BASE + 47)
+	SYS_GETEUID                = (SYS_SYSCALL_BASE + 49)
+	SYS_GETEGID                = (SYS_SYSCALL_BASE + 50)
+	SYS_ACCT                   = (SYS_SYSCALL_BASE + 51)
+	SYS_UMOUNT2                = (SYS_SYSCALL_BASE + 52)
+	SYS_IOCTL                  = (SYS_SYSCALL_BASE + 54)
+	SYS_FCNTL                  = (SYS_SYSCALL_BASE + 55)
+	SYS_SETPGID                = (SYS_SYSCALL_BASE + 57)
+	SYS_UMASK                  = (SYS_SYSCALL_BASE + 60)
+	SYS_CHROOT                 = (SYS_SYSCALL_BASE + 61)
+	SYS_USTAT                  = (SYS_SYSCALL_BASE + 62)
+	SYS_DUP2                   = (SYS_SYSCALL_BASE + 63)
+	SYS_GETPPID                = (SYS_SYSCALL_BASE + 64)
+	SYS_GETPGRP                = (SYS_SYSCALL_BASE + 65)
+	SYS_SETSID                 = (SYS_SYSCALL_BASE + 66)
+	SYS_SIGACTION              = (SYS_SYSCALL_BASE + 67)
+	SYS_SETREUID               = (SYS_SYSCALL_BASE + 70)
+	SYS_SETREGID               = (SYS_SYSCALL_BASE + 71)
+	SYS_SIGSUSPEND             = (SYS_SYSCALL_BASE + 72)
+	SYS_SIGPENDING             = (SYS_SYSCALL_BASE + 73)
+	SYS_SETHOSTNAME            = (SYS_SYSCALL_BASE + 74)
+	SYS_SETRLIMIT              = (SYS_SYSCALL_BASE + 75)
+	SYS_GETRLIMIT              = (SYS_SYSCALL_BASE + 76)
+	SYS_GETRUSAGE              = (SYS_SYSCALL_BASE + 77)
+	SYS_GETTIMEOFDAY           = (SYS_SYSCALL_BASE + 78)
+	SYS_SETTIMEOFDAY           = (SYS_SYSCALL_BASE + 79)
+	SYS_GETGROUPS              = (SYS_SYSCALL_BASE + 80)
+	SYS_SETGROUPS              = (SYS_SYSCALL_BASE + 81)
+	SYS_SELECT                 = (SYS_SYSCALL_BASE + 82)
+	SYS_SYMLINK                = (SYS_SYSCALL_BASE + 83)
+	SYS_READLINK               = (SYS_SYSCALL_BASE + 85)
+	SYS_USELIB                 = (SYS_SYSCALL_BASE + 86)
+	SYS_SWAPON                 = (SYS_SYSCALL_BASE + 87)
+	SYS_REBOOT                 = (SYS_SYSCALL_BASE + 88)
+	SYS_READDIR                = (SYS_SYSCALL_BASE + 89)
+	SYS_MMAP                   = (SYS_SYSCALL_BASE + 90)
+	SYS_MUNMAP                 = (SYS_SYSCALL_BASE + 91)
+	SYS_TRUNCATE               = (SYS_SYSCALL_BASE + 92)
+	SYS_FTRUNCATE              = (SYS_SYSCALL_BASE + 93)
+	SYS_FCHMOD                 = (SYS_SYSCALL_BASE + 94)
+	SYS_FCHOWN                 = (SYS_SYSCALL_BASE + 95)
+	SYS_GETPRIORITY            = (SYS_SYSCALL_BASE + 96)
+	SYS_SETPRIORITY            = (SYS_SYSCALL_BASE + 97)
+	SYS_STATFS                 = (SYS_SYSCALL_BASE + 99)
+	SYS_FSTATFS                = (SYS_SYSCALL_BASE + 100)
+	SYS_SOCKETCALL             = (SYS_SYSCALL_BASE + 102)
+	SYS_SYSLOG                 = (SYS_SYSCALL_BASE + 103)
+	SYS_SETITIMER              = (SYS_SYSCALL_BASE + 104)
+	SYS_GETITIMER              = (SYS_SYSCALL_BASE + 105)
+	SYS_STAT                   = (SYS_SYSCALL_BASE + 106)
+	SYS_LSTAT                  = (SYS_SYSCALL_BASE + 107)
+	SYS_FSTAT                  = (SYS_SYSCALL_BASE + 108)
+	SYS_VHANGUP                = (SYS_SYSCALL_BASE + 111)
+	SYS_SYSCALL                = (SYS_SYSCALL_BASE + 113)
+	SYS_WAIT4                  = (SYS_SYSCALL_BASE + 114)
+	SYS_SWAPOFF                = (SYS_SYSCALL_BASE + 115)
+	SYS_SYSINFO                = (SYS_SYSCALL_BASE + 116)
+	SYS_IPC                    = (SYS_SYSCALL_BASE + 117)
+	SYS_FSYNC                  = (SYS_SYSCALL_BASE + 118)
+	SYS_SIGRETURN              = (SYS_SYSCALL_BASE + 119)
+	SYS_CLONE                  = (SYS_SYSCALL_BASE + 120)
+	SYS_SETDOMAINNAME          = (SYS_SYSCALL_BASE + 121)
+	SYS_UNAME                  = (SYS_SYSCALL_BASE + 122)
+	SYS_ADJTIMEX               = (SYS_SYSCALL_BASE + 124)
+	SYS_MPROTECT               = (SYS_SYSCALL_BASE + 125)
+	SYS_SIGPROCMASK            = (SYS_SYSCALL_BASE + 126)
+	SYS_INIT_MODULE            = (SYS_SYSCALL_BASE + 128)
+	SYS_DELETE_MODULE          = (SYS_SYSCALL_BASE + 129)
+	SYS_QUOTACTL               = (SYS_SYSCALL_BASE + 131)
+	SYS_GETPGID                = (SYS_SYSCALL_BASE + 132)
+	SYS_FCHDIR                 = (SYS_SYSCALL_BASE + 133)
+	SYS_BDFLUSH                = (SYS_SYSCALL_BASE + 134)
+	SYS_SYSFS                  = (SYS_SYSCALL_BASE + 135)
+	SYS_PERSONALITY            = (SYS_SYSCALL_BASE + 136)
+	SYS_SETFSUID               = (SYS_SYSCALL_BASE + 138)
+	SYS_SETFSGID               = (SYS_SYSCALL_BASE + 139)
+	SYS__LLSEEK                = (SYS_SYSCALL_BASE + 140)
+	SYS_GETDENTS               = (SYS_SYSCALL_BASE + 141)
+	SYS__NEWSELECT             = (SYS_SYSCALL_BASE + 142)
+	SYS_FLOCK                  = (SYS_SYSCALL_BASE + 143)
+	SYS_MSYNC                  = (SYS_SYSCALL_BASE + 144)
+	SYS_READV                  = (SYS_SYSCALL_BASE + 145)
+	SYS_WRITEV                 = (SYS_SYSCALL_BASE + 146)
+	SYS_GETSID                 = (SYS_SYSCALL_BASE + 147)
+	SYS_FDATASYNC              = (SYS_SYSCALL_BASE + 148)
+	SYS__SYSCTL                = (SYS_SYSCALL_BASE + 149)
+	SYS_MLOCK                  = (SYS_SYSCALL_BASE + 150)
+	SYS_MUNLOCK                = (SYS_SYSCALL_BASE + 151)
+	SYS_MLOCKALL               = (SYS_SYSCALL_BASE + 152)
+	SYS_MUNLOCKALL             = (SYS_SYSCALL_BASE + 153)
+	SYS_SCHED_SETPARAM         = (SYS_SYSCALL_BASE + 154)
+	SYS_SCHED_GETPARAM         = (SYS_SYSCALL_BASE + 155)
+	SYS_SCHED_SETSCHEDULER     = (SYS_SYSCALL_BASE + 156)
+	SYS_SCHED_GETSCHEDULER     = (SYS_SYSCALL_BASE + 157)
+	SYS_SCHED_YIELD            = (SYS_SYSCALL_BASE + 158)
+	SYS_SCHED_GET_PRIORITY_MAX = (SYS_SYSCALL_BASE + 159)
+	SYS_SCHED_GET_PRIORITY_MIN = (SYS_SYSCALL_BASE + 160)
+	SYS_SCHED_RR_GET_INTERVAL  = (SYS_SYSCALL_BASE + 161)
+	SYS_NANOSLEEP              = (SYS_SYSCALL_BASE + 162)
+	SYS_MREMAP                 = (SYS_SYSCALL_BASE + 163)
+	SYS_SETRESUID              = (SYS_SYSCALL_BASE + 164)
+	SYS_GETRESUID              = (SYS_SYSCALL_BASE + 165)
+	SYS_POLL                   = (SYS_SYSCALL_BASE + 168)
+	SYS_NFSSERVCTL             = (SYS_SYSCALL_BASE + 169)
+	SYS_SETRESGID              = (SYS_SYSCALL_BASE + 170)
+	SYS_GETRESGID              = (SYS_SYSCALL_BASE + 171)
+	SYS_PRCTL                  = (SYS_SYSCALL_BASE + 172)
+	SYS_RT_SIGRETURN           = (SYS_SYSCALL_BASE + 173)
+	SYS_RT_SIGACTION           = (SYS_SYSCALL_BASE + 174)
+	SYS_RT_SIGPROCMASK         = (SYS_SYSCALL_BASE + 175)
+	SYS_RT_SIGPENDING          = (SYS_SYSCALL_BASE + 176)
+	SYS_RT_SIGTIMEDWAIT        = (SYS_SYSCALL_BASE + 177)
+	SYS_RT_SIGQUEUEINFO        = (SYS_SYSCALL_BASE + 178)
+	SYS_RT_SIGSUSPEND          = (SYS_SYSCALL_BASE + 179)
+	SYS_PREAD64                = (SYS_SYSCALL_BASE + 180)
+	SYS_PWRITE64               = (SYS_SYSCALL_BASE + 181)
+	SYS_CHOWN                  = (SYS_SYSCALL_BASE + 182)
+	SYS_GETCWD                 = (SYS_SYSCALL_BASE + 183)
+	SYS_CAPGET                 = (SYS_SYSCALL_BASE + 184)
+	SYS_CAPSET                 = (SYS_SYSCALL_BASE + 185)
+	SYS_SIGALTSTACK            = (SYS_SYSCALL_BASE + 186)
+	SYS_SENDFILE               = (SYS_SYSCALL_BASE + 187)
+	SYS_VFORK                  = (SYS_SYSCALL_BASE + 190)
+	SYS_UGETRLIMIT             = (SYS_SYSCALL_BASE + 191)
+	SYS_MMAP2                  = (SYS_SYSCALL_BASE + 192)
+	SYS_TRUNCATE64             = (SYS_SYSCALL_BASE + 193)
+	SYS_FTRUNCATE64            = (SYS_SYSCALL_BASE + 194)
+	SYS_STAT64                 = (SYS_SYSCALL_BASE + 195)
+	SYS_LSTAT64                = (SYS_SYSCALL_BASE + 196)
+	SYS_FSTAT64                = (SYS_SYSCALL_BASE + 197)
+	SYS_LCHOWN32               = (SYS_SYSCALL_BASE + 198)
+	SYS_GETUID32               = (SYS_SYSCALL_BASE + 199)
+	SYS_GETGID32               = (SYS_SYSCALL_BASE + 200)
+	SYS_GETEUID32              = (SYS_SYSCALL_BASE + 201)
+	SYS_GETEGID32              = (SYS_SYSCALL_BASE + 202)
+	SYS_SETREUID32             = (SYS_SYSCALL_BASE + 203)
+	SYS_SETREGID32             = (SYS_SYSCALL_BASE + 204)
+	SYS_GETGROUPS32            = (SYS_SYSCALL_BASE + 205)
+	SYS_SETGROUPS32            = (SYS_SYSCALL_BASE + 206)
+	SYS_FCHOWN32               = (SYS_SYSCALL_BASE + 207)
+	SYS_SETRESUID32            = (SYS_SYSCALL_BASE + 208)
+	SYS_GETRESUID32            = (SYS_SYSCALL_BASE + 209)
+	SYS_SETRESGID32            = (SYS_SYSCALL_BASE + 210)
+	SYS_GETRESGID32            = (SYS_SYSCALL_BASE + 211)
+	SYS_CHOWN32                = (SYS_SYSCALL_BASE + 212)
+	SYS_SETUID32               = (SYS_SYSCALL_BASE + 213)
+	SYS_SETGID32               = (SYS_SYSCALL_BASE + 214)
+	SYS_SETFSUID32             = (SYS_SYSCALL_BASE + 215)
+	SYS_SETFSGID32             = (SYS_SYSCALL_BASE + 216)
+	SYS_GETDENTS64             = (SYS_SYSCALL_BASE + 217)
+	SYS_PIVOT_ROOT             = (SYS_SYSCALL_BASE + 218)
+	SYS_MINCORE                = (SYS_SYSCALL_BASE + 219)
+	SYS_MADVISE                = (SYS_SYSCALL_BASE + 220)
+	SYS_FCNTL64                = (SYS_SYSCALL_BASE + 221)
+	SYS_GETTID                 = (SYS_SYSCALL_BASE + 224)
+	SYS_READAHEAD              = (SYS_SYSCALL_BASE + 225)
+	SYS_SETXATTR               = (SYS_SYSCALL_BASE + 226)
+	SYS_LSETXATTR              = (SYS_SYSCALL_BASE + 227)
+	SYS_FSETXATTR              = (SYS_SYSCALL_BASE + 228)
+	SYS_GETXATTR               = (SYS_SYSCALL_BASE + 229)
+	SYS_LGETXATTR              = (SYS_SYSCALL_BASE + 230)
+	SYS_FGETXATTR              = (SYS_SYSCALL_BASE + 231)
+	SYS_LISTXATTR              = (SYS_SYSCALL_BASE + 232)
+	SYS_LLISTXATTR             = (SYS_SYSCALL_BASE + 233)
+	SYS_FLISTXATTR             = (SYS_SYSCALL_BASE + 234)
+	SYS_REMOVEXATTR            = (SYS_SYSCALL_BASE + 235)
+	SYS_LREMOVEXATTR           = (SYS_SYSCALL_BASE + 236)
+	SYS_FREMOVEXATTR           = (SYS_SYSCALL_BASE + 237)
+	SYS_TKILL                  = (SYS_SYSCALL_BASE + 238)
+	SYS_SENDFILE64             = (SYS_SYSCALL_BASE + 239)
+	SYS_FUTEX                  = (SYS_SYSCALL_BASE + 240)
+	SYS_SCHED_SETAFFINITY      = (SYS_SYSCALL_BASE + 241)
+	SYS_SCHED_GETAFFINITY      = (SYS_SYSCALL_BASE + 242)
+	SYS_IO_SETUP               = (SYS_SYSCALL_BASE + 243)
+	SYS_IO_DESTROY             = (SYS_SYSCALL_BASE + 244)
+	SYS_IO_GETEVENTS           = (SYS_SYSCALL_BASE + 245)
+	SYS_IO_SUBMIT              = (SYS_SYSCALL_BASE + 246)
+	SYS_IO_CANCEL              = (SYS_SYSCALL_BASE + 247)
+	SYS_EXIT_GROUP             = (SYS_SYSCALL_BASE + 248)
+	SYS_LOOKUP_DCOOKIE         = (SYS_SYSCALL_BASE + 249)
+	SYS_EPOLL_CREATE           = (SYS_SYSCALL_BASE + 250)
+	SYS_EPOLL_CTL              = (SYS_SYSCALL_BASE + 251)
+	SYS_EPOLL_WAIT             = (SYS_SYSCALL_BASE + 252)
+	SYS_REMAP_FILE_PAGES       = (SYS_SYSCALL_BASE + 253)
+	SYS_SET_TID_ADDRESS        = (SYS_SYSCALL_BASE + 256)
+	SYS_TIMER_CREATE           = (SYS_SYSCALL_BASE + 257)
+	SYS_TIMER_SETTIME          = (SYS_SYSCALL_BASE + 258)
+	SYS_TIMER_GETTIME          = (SYS_SYSCALL_BASE + 259)
+	SYS_TIMER_GETOVERRUN       = (SYS_SYSCALL_BASE + 260)
+	SYS_TIMER_DELETE           = (SYS_SYSCALL_BASE + 261)
+	SYS_CLOCK_SETTIME          = (SYS_SYSCALL_BASE + 262)
+	SYS_CLOCK_GETTIME          = (SYS_SYSCALL_BASE + 263)
+	SYS_CLOCK_GETRES           = (SYS_SYSCALL_BASE + 264)
+	SYS_CLOCK_NANOSLEEP        = (SYS_SYSCALL_BASE + 265)
+	SYS_STATFS64               = (SYS_SYSCALL_BASE + 266)
+	SYS_FSTATFS64              = (SYS_SYSCALL_BASE + 267)
+	SYS_TGKILL                 = (SYS_SYSCALL_BASE + 268)
+	SYS_UTIMES                 = (SYS_SYSCALL_BASE + 269)
+	SYS_ARM_FADVISE64_64       = (SYS_SYSCALL_BASE + 270)
+	SYS_PCICONFIG_IOBASE       = (SYS_SYSCALL_BASE + 271)
+	SYS_PCICONFIG_READ         = (SYS_SYSCALL_BASE + 272)
+	SYS_PCICONFIG_WRITE        = (SYS_SYSCALL_BASE + 273)
+	SYS_MQ_OPEN                = (SYS_SYSCALL_BASE + 274)
+	SYS_MQ_UNLINK              = (SYS_SYSCALL_BASE + 275)
+	SYS_MQ_TIMEDSEND           = (SYS_SYSCALL_BASE + 276)
+	SYS_MQ_TIMEDRECEIVE        = (SYS_SYSCALL_BASE + 277)
+	SYS_MQ_NOTIFY              = (SYS_SYSCALL_BASE + 278)
+	SYS_MQ_GETSETATTR          = (SYS_SYSCALL_BASE + 279)
+	SYS_WAITID                 = (SYS_SYSCALL_BASE + 280)
+	SYS_SOCKET                 = (SYS_SYSCALL_BASE + 281)
+	SYS_BIND                   = (SYS_SYSCALL_BASE + 282)
+	SYS_CONNECT                = (SYS_SYSCALL_BASE + 283)
+	SYS_LISTEN                 = (SYS_SYSCALL_BASE + 284)
+	SYS_ACCEPT                 = (SYS_SYSCALL_BASE + 285)
+	SYS_GETSOCKNAME            = (SYS_SYSCALL_BASE + 286)
+	SYS_GETPEERNAME            = (SYS_SYSCALL_BASE + 287)
+	SYS_SOCKETPAIR             = (SYS_SYSCALL_BASE + 288)
+	SYS_SEND                   = (SYS_SYSCALL_BASE + 289)
+	SYS_SENDTO                 = (SYS_SYSCALL_BASE + 290)
+	SYS_RECV                   = (SYS_SYSCALL_BASE + 291)
+	SYS_RECVFROM               = (SYS_SYSCALL_BASE + 292)
+	SYS_SHUTDOWN               = (SYS_SYSCALL_BASE + 293)
+	SYS_SETSOCKOPT             = (SYS_SYSCALL_BASE + 294)
+	SYS_GETSOCKOPT             = (SYS_SYSCALL_BASE + 295)
+	SYS_SENDMSG                = (SYS_SYSCALL_BASE + 296)
+	SYS_RECVMSG                = (SYS_SYSCALL_BASE + 297)
+	SYS_SEMOP                  = (SYS_SYSCALL_BASE + 298)
+	SYS_SEMGET                 = (SYS_SYSCALL_BASE + 299)
+	SYS_SEMCTL                 = (SYS_SYSCALL_BASE + 300)
+	SYS_MSGSND                 = (SYS_SYSCALL_BASE + 301)
+	SYS_MSGRCV                 = (SYS_SYSCALL_BASE + 302)
+	SYS_MSGGET                 = (SYS_SYSCALL_BASE + 303)
+	SYS_MSGCTL                 = (SYS_SYSCALL_BASE + 304)
+	SYS_SHMAT                  = (SYS_SYSCALL_BASE + 305)
+	SYS_SHMDT                  = (SYS_SYSCALL_BASE + 306)
+	SYS_SHMGET                 = (SYS_SYSCALL_BASE + 307)
+	SYS_SHMCTL                 = (SYS_SYSCALL_BASE + 308)
+	SYS_ADD_KEY                = (SYS_SYSCALL_BASE + 309)
+	SYS_REQUEST_KEY            = (SYS_SYSCALL_BASE + 310)
+	SYS_KEYCTL                 = (SYS_SYSCALL_BASE + 311)
+	SYS_SEMTIMEDOP             = (SYS_SYSCALL_BASE + 312)
+	SYS_VSERVER                = (SYS_SYSCALL_BASE + 313)
+	SYS_IOPRIO_SET             = (SYS_SYSCALL_BASE + 314)
+	SYS_IOPRIO_GET             = (SYS_SYSCALL_BASE + 315)
+	SYS_INOTIFY_INIT           = (SYS_SYSCALL_BASE + 316)
+	SYS_INOTIFY_ADD_WATCH      = (SYS_SYSCALL_BASE + 317)
+	SYS_INOTIFY_RM_WATCH       = (SYS_SYSCALL_BASE + 318)
+	SYS_MBIND                  = (SYS_SYSCALL_BASE + 319)
+	SYS_GET_MEMPOLICY          = (SYS_SYSCALL_BASE + 320)
+	SYS_SET_MEMPOLICY          = (SYS_SYSCALL_BASE + 321)
+	SYS_OPENAT                 = (SYS_SYSCALL_BASE + 322)
+	SYS_MKDIRAT                = (SYS_SYSCALL_BASE + 323)
+	SYS_MKNODAT                = (SYS_SYSCALL_BASE + 324)
+	SYS_FCHOWNAT               = (SYS_SYSCALL_BASE + 325)
+	SYS_FUTIMESAT              = (SYS_SYSCALL_BASE + 326)
+	SYS_FSTATAT64              = (SYS_SYSCALL_BASE + 327)
+	SYS_UNLINKAT               = (SYS_SYSCALL_BASE + 328)
+	SYS_RENAMEAT               = (SYS_SYSCALL_BASE + 329)
+	SYS_LINKAT                 = (SYS_SYSCALL_BASE + 330)
+	SYS_SYMLINKAT              = (SYS_SYSCALL_BASE + 331)
+	SYS_READLINKAT             = (SYS_SYSCALL_BASE + 332)
+	SYS_FCHMODAT               = (SYS_SYSCALL_BASE + 333)
+	SYS_FACCESSAT              = (SYS_SYSCALL_BASE + 334)
+	SYS_UNSHARE                = (SYS_SYSCALL_BASE + 337)
+	SYS_SET_ROBUST_LIST        = (SYS_SYSCALL_BASE + 338)
+	SYS_GET_ROBUST_LIST        = (SYS_SYSCALL_BASE + 339)
+	SYS_SPLICE                 = (SYS_SYSCALL_BASE + 340)
+	SYS_ARM_SYNC_FILE_RANGE    = (SYS_SYSCALL_BASE + 341)
+	SYS_SYNC_FILE_RANGE2       = SYS_ARM_SYNC_FILE_RANGE
+	SYS_TEE                    = (SYS_SYSCALL_BASE + 342)
+	SYS_VMSPLICE               = (SYS_SYSCALL_BASE + 343)
+	SYS_MOVE_PAGES             = (SYS_SYSCALL_BASE + 344)
+	SYS_GETCPU                 = (SYS_SYSCALL_BASE + 345)
+	SYS_KEXEC_LOAD             = (SYS_SYSCALL_BASE + 347)
+	SYS_UTIMENSAT              = (SYS_SYSCALL_BASE + 348)
+	SYS_SIGNALFD               = (SYS_SYSCALL_BASE + 349)
+	SYS_TIMERFD_CREATE         = (SYS_SYSCALL_BASE + 350)
+	SYS_EVENTFD                = (SYS_SYSCALL_BASE + 351)
+	SYS_FALLOCATE              = (SYS_SYSCALL_BASE + 352)
+	SYS_TIMERFD_SETTIME        = (SYS_SYSCALL_BASE + 353)
+	SYS_TIMERFD_GETTIME        = (SYS_SYSCALL_BASE + 354)
+	SYS_SIGNALFD4              = (SYS_SYSCALL_BASE + 355)
+	SYS_EVENTFD2               = (SYS_SYSCALL_BASE + 356)
+	SYS_EPOLL_CREATE1          = (SYS_SYSCALL_BASE + 357)
+	SYS_DUP3                   = (SYS_SYSCALL_BASE + 358)
+	SYS_PIPE2                  = (SYS_SYSCALL_BASE + 359)
+	SYS_INOTIFY_INIT1          = (SYS_SYSCALL_BASE + 360)
 )
 
-func _darwin_system_call_conflict()	{}
+func _darwin_system_call_conflict() {}
diff --git a/src/pkg/syscall/zsysnum_nacl_386.go b/src/pkg/syscall/zsysnum_nacl_386.go
index d41cfec779..4099b25075 100644
--- a/src/pkg/syscall/zsysnum_nacl_386.go
+++ b/src/pkg/syscall/zsysnum_nacl_386.go
@@ -4,58 +4,58 @@
 package syscall
 
 const (
-	SYS_NULL		= 1;
-	SYS_OPEN		= 10;
-	SYS_CLOSE		= 11;
-	SYS_READ		= 12;
-	SYS_WRITE		= 13;
-	SYS_LSEEK		= 14;
-	SYS_IOCTL		= 15;
-	SYS_STAT		= 16;
-	SYS_FSTAT		= 17;
-	SYS_CHMOD		= 18;
-	SYS_SYSBRK		= 20;
-	SYS_MMAP		= 21;
-	SYS_MUNMAP		= 22;
-	SYS_GETDENTS		= 23;
-	SYS_EXIT		= 30;
-	SYS_GETPID		= 31;
-	SYS_SCHED_YIELD		= 32;
-	SYS_SYSCONF		= 33;
-	SYS_GETTIMEOFDAY	= 40;
-	SYS_CLOCK		= 41;
-	SYS_MULTIMEDIA_INIT	= 50;
-	SYS_MULTIMEDIA_SHUTDOWN	= 51;
-	SYS_VIDEO_INIT		= 52;
-	SYS_VIDEO_SHUTDOWN	= 53;
-	SYS_VIDEO_UPDATE	= 54;
-	SYS_VIDEO_POLL_EVENT	= 55;
-	SYS_AUDIO_INIT		= 56;
-	SYS_AUDIO_SHUTDOWN	= 57;
-	SYS_AUDIO_STREAM	= 58;
-	SYS_IMC_MAKEBOUNDSOCK	= 60;
-	SYS_IMC_ACCEPT		= 61;
-	SYS_IMC_CONNECT		= 62;
-	SYS_IMC_SENDMSG		= 63;
-	SYS_IMC_RECVMSG		= 64;
-	SYS_IMC_MEM_OBJ_CREATE	= 65;
-	SYS_IMC_SOCKETPAIR	= 66;
-	SYS_MUTEX_CREATE	= 70;
-	SYS_MUTEX_LOCK		= 71;
-	SYS_MUTEX_TRYLOCK	= 72;
-	SYS_MUTEX_UNLOCK	= 73;
-	SYS_COND_CREATE		= 74;
-	SYS_COND_WAIT		= 75;
-	SYS_COND_SIGNAL		= 76;
-	SYS_COND_BROADCAST	= 77;
-	SYS_COND_TIMED_WAIT_ABS	= 79;
-	SYS_THREAD_CREATE	= 80;
-	SYS_THREAD_EXIT		= 81;
-	SYS_TLS_INIT		= 82;
-	SYS_THREAD_NICE		= 83;
-	SYS_SRPC_GET_FD		= 90;
-	SYS_SEM_CREATE		= 100;
-	SYS_SEM_WAIT		= 101;
-	SYS_SEM_POST		= 102;
-	SYS_SEM_GET_VALUE	= 103;
+	SYS_NULL                = 1
+	SYS_OPEN                = 10
+	SYS_CLOSE               = 11
+	SYS_READ                = 12
+	SYS_WRITE               = 13
+	SYS_LSEEK               = 14
+	SYS_IOCTL               = 15
+	SYS_STAT                = 16
+	SYS_FSTAT               = 17
+	SYS_CHMOD               = 18
+	SYS_SYSBRK              = 20
+	SYS_MMAP                = 21
+	SYS_MUNMAP              = 22
+	SYS_GETDENTS            = 23
+	SYS_EXIT                = 30
+	SYS_GETPID              = 31
+	SYS_SCHED_YIELD         = 32
+	SYS_SYSCONF             = 33
+	SYS_GETTIMEOFDAY        = 40
+	SYS_CLOCK               = 41
+	SYS_MULTIMEDIA_INIT     = 50
+	SYS_MULTIMEDIA_SHUTDOWN = 51
+	SYS_VIDEO_INIT          = 52
+	SYS_VIDEO_SHUTDOWN      = 53
+	SYS_VIDEO_UPDATE        = 54
+	SYS_VIDEO_POLL_EVENT    = 55
+	SYS_AUDIO_INIT          = 56
+	SYS_AUDIO_SHUTDOWN      = 57
+	SYS_AUDIO_STREAM        = 58
+	SYS_IMC_MAKEBOUNDSOCK   = 60
+	SYS_IMC_ACCEPT          = 61
+	SYS_IMC_CONNECT         = 62
+	SYS_IMC_SENDMSG         = 63
+	SYS_IMC_RECVMSG         = 64
+	SYS_IMC_MEM_OBJ_CREATE  = 65
+	SYS_IMC_SOCKETPAIR      = 66
+	SYS_MUTEX_CREATE        = 70
+	SYS_MUTEX_LOCK          = 71
+	SYS_MUTEX_TRYLOCK       = 72
+	SYS_MUTEX_UNLOCK        = 73
+	SYS_COND_CREATE         = 74
+	SYS_COND_WAIT           = 75
+	SYS_COND_SIGNAL         = 76
+	SYS_COND_BROADCAST      = 77
+	SYS_COND_TIMED_WAIT_ABS = 79
+	SYS_THREAD_CREATE       = 80
+	SYS_THREAD_EXIT         = 81
+	SYS_TLS_INIT            = 82
+	SYS_THREAD_NICE         = 83
+	SYS_SRPC_GET_FD         = 90
+	SYS_SEM_CREATE          = 100
+	SYS_SEM_WAIT            = 101
+	SYS_SEM_POST            = 102
+	SYS_SEM_GET_VALUE       = 103
 )
diff --git a/src/pkg/syscall/ztypes_darwin_386.go b/src/pkg/syscall/ztypes_darwin_386.go
index 003d58ba3c..708bba400f 100644
--- a/src/pkg/syscall/ztypes_darwin_386.go
+++ b/src/pkg/syscall/ztypes_darwin_386.go
@@ -6,22 +6,22 @@ package syscall
 
 // Constants
 const (
-	sizeofPtr		= 0x4;
-	sizeofShort		= 0x2;
-	sizeofInt		= 0x4;
-	sizeofLong		= 0x4;
-	sizeofLongLong		= 0x8;
-	O_CLOEXEC		= 0;
-	SizeofSockaddrInet4	= 0x10;
-	SizeofSockaddrInet6	= 0x1c;
-	SizeofSockaddrAny	= 0x6c;
-	SizeofSockaddrUnix	= 0x6a;
-	SizeofLinger		= 0x8;
-	SizeofMsghdr		= 0x1c;
-	SizeofCmsghdr		= 0xc;
-	PTRACE_TRACEME		= 0;
-	PTRACE_CONT		= 0x7;
-	PTRACE_KILL		= 0x8;
+	sizeofPtr           = 0x4
+	sizeofShort         = 0x2
+	sizeofInt           = 0x4
+	sizeofLong          = 0x4
+	sizeofLongLong      = 0x8
+	O_CLOEXEC           = 0
+	SizeofSockaddrInet4 = 0x10
+	SizeofSockaddrInet6 = 0x1c
+	SizeofSockaddrAny   = 0x6c
+	SizeofSockaddrUnix  = 0x6a
+	SizeofLinger        = 0x8
+	SizeofMsghdr        = 0x1c
+	SizeofCmsghdr       = 0xc
+	PTRACE_TRACEME      = 0
+	PTRACE_CONT         = 0x7
+	PTRACE_KILL         = 0x8
 )
 
 // Types
@@ -35,195 +35,195 @@ type _C_long int32
 type _C_long_long int64
 
 type Timespec struct {
-	Sec	int32;
-	Nsec	int32;
+	Sec  int32
+	Nsec int32
 }
 
 type Timeval struct {
-	Sec	int32;
-	Usec	int32;
+	Sec  int32
+	Usec int32
 }
 
 type Rusage struct {
-	Utime		Timeval;
-	Stime		Timeval;
-	Maxrss		int32;
-	Ixrss		int32;
-	Idrss		int32;
-	Isrss		int32;
-	Minflt		int32;
-	Majflt		int32;
-	Nswap		int32;
-	Inblock		int32;
-	Oublock		int32;
-	Msgsnd		int32;
-	Msgrcv		int32;
-	Nsignals	int32;
-	Nvcsw		int32;
-	Nivcsw		int32;
+	Utime    Timeval
+	Stime    Timeval
+	Maxrss   int32
+	Ixrss    int32
+	Idrss    int32
+	Isrss    int32
+	Minflt   int32
+	Majflt   int32
+	Nswap    int32
+	Inblock  int32
+	Oublock  int32
+	Msgsnd   int32
+	Msgrcv   int32
+	Nsignals int32
+	Nvcsw    int32
+	Nivcsw   int32
 }
 
 type Rlimit struct {
-	Cur	uint64;
-	Max	uint64;
+	Cur uint64
+	Max uint64
 }
 
 type _Gid_t uint32
 
 type Stat_t struct {
-	Dev		int32;
-	Mode		uint16;
-	Nlink		uint16;
-	Ino		uint64;
-	Uid		uint32;
-	Gid		uint32;
-	Rdev		int32;
-	Atimespec	Timespec;
-	Mtimespec	Timespec;
-	Ctimespec	Timespec;
-	Birthtimespec	Timespec;
-	Size		int64;
-	Blocks		int64;
-	Blksize		int32;
-	Flags		uint32;
-	Gen		uint32;
-	Lspare		int32;
-	Qspare		[2]int64;
+	Dev           int32
+	Mode          uint16
+	Nlink         uint16
+	Ino           uint64
+	Uid           uint32
+	Gid           uint32
+	Rdev          int32
+	Atimespec     Timespec
+	Mtimespec     Timespec
+	Ctimespec     Timespec
+	Birthtimespec Timespec
+	Size          int64
+	Blocks        int64
+	Blksize       int32
+	Flags         uint32
+	Gen           uint32
+	Lspare        int32
+	Qspare        [2]int64
 }
 
 type Statfs_t struct {
-	Bsize		uint32;
-	Iosize		int32;
-	Blocks		uint64;
-	Bfree		uint64;
-	Bavail		uint64;
-	Files		uint64;
-	Ffree		uint64;
-	Fsid		[8]byte;	/* fsid */
-	Owner		uint32;
-	Type		uint32;
-	Flags		uint32;
-	Fssubtype	uint32;
-	Fstypename	[16]int8;
-	Mntonname	[1024]int8;
-	Mntfromname	[1024]int8;
-	Reserved	[8]uint32;
+	Bsize       uint32
+	Iosize      int32
+	Blocks      uint64
+	Bfree       uint64
+	Bavail      uint64
+	Files       uint64
+	Ffree       uint64
+	Fsid        [8]byte /* fsid */
+	Owner       uint32
+	Type        uint32
+	Flags       uint32
+	Fssubtype   uint32
+	Fstypename  [16]int8
+	Mntonname   [1024]int8
+	Mntfromname [1024]int8
+	Reserved    [8]uint32
 }
 
 type Flock_t struct {
-	Start	int64;
-	Len	int64;
-	Pid	int32;
-	Type	int16;
-	Whence	int16;
+	Start  int64
+	Len    int64
+	Pid    int32
+	Type   int16
+	Whence int16
 }
 
 type Fstore_t struct {
-	Flags		uint32;
-	Posmode		int32;
-	Offset		int64;
-	Length		int64;
-	Bytesalloc	int64;
+	Flags      uint32
+	Posmode    int32
+	Offset     int64
+	Length     int64
+	Bytesalloc int64
 }
 
 type Radvisory_t struct {
-	Offset	int64;
-	Count	int32;
+	Offset int64
+	Count  int32
 }
 
 type Fbootstraptransfer_t struct {
-	Offset	int64;
-	Length	uint32;
-	Buffer	*byte;
+	Offset int64
+	Length uint32
+	Buffer *byte
 }
 
 type Log2phys_t struct {
-	Flags		uint32;
-	Contigbytes	int64;
-	Devoffset	int64;
+	Flags       uint32
+	Contigbytes int64
+	Devoffset   int64
 }
 
 type Dirent struct {
-	Ino	uint64;
-	Seekoff	uint64;
-	Reclen	uint16;
-	Namlen	uint16;
-	Type	uint8;
-	Name	[1024]int8;
-	Pad0	[3]byte;
+	Ino     uint64
+	Seekoff uint64
+	Reclen  uint16
+	Namlen  uint16
+	Type    uint8
+	Name    [1024]int8
+	Pad0    [3]byte
 }
 
 type RawSockaddrInet4 struct {
-	Len	uint8;
-	Family	uint8;
-	Port	uint16;
-	Addr	[4]byte;	/* in_addr */
-	Zero	[8]int8;
+	Len    uint8
+	Family uint8
+	Port   uint16
+	Addr   [4]byte /* in_addr */
+	Zero   [8]int8
 }
 
 type RawSockaddrInet6 struct {
-	Len		uint8;
-	Family		uint8;
-	Port		uint16;
-	Flowinfo	uint32;
-	Addr		[16]byte;	/* in6_addr */
-	Scope_id	uint32;
+	Len      uint8
+	Family   uint8
+	Port     uint16
+	Flowinfo uint32
+	Addr     [16]byte /* in6_addr */
+	Scope_id uint32
 }
 
 type RawSockaddrUnix struct {
-	Len	uint8;
-	Family	uint8;
-	Path	[104]int8;
+	Len    uint8
+	Family uint8
+	Path   [104]int8
 }
 
 type RawSockaddr struct {
-	Len	uint8;
-	Family	uint8;
-	Data	[14]int8;
+	Len    uint8
+	Family uint8
+	Data   [14]int8
 }
 
 type RawSockaddrAny struct {
-	Addr	RawSockaddr;
-	Pad	[92]int8;
+	Addr RawSockaddr
+	Pad  [92]int8
 }
 
 type _Socklen uint32
 
 type Linger struct {
-	Onoff	int32;
-	Linger	int32;
+	Onoff  int32
+	Linger int32
 }
 
 type Iovec struct {
-	Base	*byte;
-	Len	uint32;
+	Base *byte
+	Len  uint32
 }
 
 type Msghdr struct {
-	Name		*byte;
-	Namelen		uint32;
-	Iov		*Iovec;
-	Iovlen		int32;
-	Control		*byte;
-	Controllen	uint32;
-	Flags		int32;
+	Name       *byte
+	Namelen    uint32
+	Iov        *Iovec
+	Iovlen     int32
+	Control    *byte
+	Controllen uint32
+	Flags      int32
 }
 
 type Cmsghdr struct {
-	Len	uint32;
-	Level	int32;
-	Type	int32;
+	Len   uint32
+	Level int32
+	Type  int32
 }
 
 type Kevent_t struct {
-	Ident	uint32;
-	Filter	int16;
-	Flags	uint16;
-	Fflags	uint32;
-	Data	int32;
-	Udata	*byte;
+	Ident  uint32
+	Filter int16
+	Flags  uint16
+	Fflags uint32
+	Data   int32
+	Udata  *byte
 }
 
 type FdSet struct {
-	Bits [32]int32;
+	Bits [32]int32
 }
diff --git a/src/pkg/syscall/ztypes_darwin_amd64.go b/src/pkg/syscall/ztypes_darwin_amd64.go
index ff85b2723e..5b273768f5 100644
--- a/src/pkg/syscall/ztypes_darwin_amd64.go
+++ b/src/pkg/syscall/ztypes_darwin_amd64.go
@@ -6,22 +6,22 @@ package syscall
 
 // Constants
 const (
-	sizeofPtr		= 0x8;
-	sizeofShort		= 0x2;
-	sizeofInt		= 0x4;
-	sizeofLong		= 0x8;
-	sizeofLongLong		= 0x8;
-	O_CLOEXEC		= 0;
-	SizeofSockaddrInet4	= 0x10;
-	SizeofSockaddrInet6	= 0x1c;
-	SizeofSockaddrAny	= 0x6c;
-	SizeofSockaddrUnix	= 0x6a;
-	SizeofLinger		= 0x8;
-	SizeofMsghdr		= 0x30;
-	SizeofCmsghdr		= 0xc;
-	PTRACE_TRACEME		= 0;
-	PTRACE_CONT		= 0x7;
-	PTRACE_KILL		= 0x8;
+	sizeofPtr           = 0x8
+	sizeofShort         = 0x2
+	sizeofInt           = 0x4
+	sizeofLong          = 0x8
+	sizeofLongLong      = 0x8
+	O_CLOEXEC           = 0
+	SizeofSockaddrInet4 = 0x10
+	SizeofSockaddrInet6 = 0x1c
+	SizeofSockaddrAny   = 0x6c
+	SizeofSockaddrUnix  = 0x6a
+	SizeofLinger        = 0x8
+	SizeofMsghdr        = 0x30
+	SizeofCmsghdr       = 0xc
+	PTRACE_TRACEME      = 0
+	PTRACE_CONT         = 0x7
+	PTRACE_KILL         = 0x8
 )
 
 // Types
@@ -35,200 +35,200 @@ type _C_long int64
 type _C_long_long int64
 
 type Timespec struct {
-	Sec	int64;
-	Nsec	int64;
+	Sec  int64
+	Nsec int64
 }
 
 type Timeval struct {
-	Sec	int64;
-	Usec	int32;
-	Pad0	[4]byte;
+	Sec  int64
+	Usec int32
+	Pad0 [4]byte
 }
 
 type Rusage struct {
-	Utime		Timeval;
-	Stime		Timeval;
-	Maxrss		int64;
-	Ixrss		int64;
-	Idrss		int64;
-	Isrss		int64;
-	Minflt		int64;
-	Majflt		int64;
-	Nswap		int64;
-	Inblock		int64;
-	Oublock		int64;
-	Msgsnd		int64;
-	Msgrcv		int64;
-	Nsignals	int64;
-	Nvcsw		int64;
-	Nivcsw		int64;
+	Utime    Timeval
+	Stime    Timeval
+	Maxrss   int64
+	Ixrss    int64
+	Idrss    int64
+	Isrss    int64
+	Minflt   int64
+	Majflt   int64
+	Nswap    int64
+	Inblock  int64
+	Oublock  int64
+	Msgsnd   int64
+	Msgrcv   int64
+	Nsignals int64
+	Nvcsw    int64
+	Nivcsw   int64
 }
 
 type Rlimit struct {
-	Cur	uint64;
-	Max	uint64;
+	Cur uint64
+	Max uint64
 }
 
 type _Gid_t uint32
 
 type Stat_t struct {
-	Dev		int32;
-	Mode		uint16;
-	Nlink		uint16;
-	Ino		uint64;
-	Uid		uint32;
-	Gid		uint32;
-	Rdev		int32;
-	Pad0		[4]byte;
-	Atimespec	Timespec;
-	Mtimespec	Timespec;
-	Ctimespec	Timespec;
-	Birthtimespec	Timespec;
-	Size		int64;
-	Blocks		int64;
-	Blksize		int32;
-	Flags		uint32;
-	Gen		uint32;
-	Lspare		int32;
-	Qspare		[2]int64;
+	Dev           int32
+	Mode          uint16
+	Nlink         uint16
+	Ino           uint64
+	Uid           uint32
+	Gid           uint32
+	Rdev          int32
+	Pad0          [4]byte
+	Atimespec     Timespec
+	Mtimespec     Timespec
+	Ctimespec     Timespec
+	Birthtimespec Timespec
+	Size          int64
+	Blocks        int64
+	Blksize       int32
+	Flags         uint32
+	Gen           uint32
+	Lspare        int32
+	Qspare        [2]int64
 }
 
 type Statfs_t struct {
-	Bsize		uint32;
-	Iosize		int32;
-	Blocks		uint64;
-	Bfree		uint64;
-	Bavail		uint64;
-	Files		uint64;
-	Ffree		uint64;
-	Fsid		[8]byte;	/* fsid */
-	Owner		uint32;
-	Type		uint32;
-	Flags		uint32;
-	Fssubtype	uint32;
-	Fstypename	[16]int8;
-	Mntonname	[1024]int8;
-	Mntfromname	[1024]int8;
-	Reserved	[8]uint32;
+	Bsize       uint32
+	Iosize      int32
+	Blocks      uint64
+	Bfree       uint64
+	Bavail      uint64
+	Files       uint64
+	Ffree       uint64
+	Fsid        [8]byte /* fsid */
+	Owner       uint32
+	Type        uint32
+	Flags       uint32
+	Fssubtype   uint32
+	Fstypename  [16]int8
+	Mntonname   [1024]int8
+	Mntfromname [1024]int8
+	Reserved    [8]uint32
 }
 
 type Flock_t struct {
-	Start	int64;
-	Len	int64;
-	Pid	int32;
-	Type	int16;
-	Whence	int16;
+	Start  int64
+	Len    int64
+	Pid    int32
+	Type   int16
+	Whence int16
 }
 
 type Fstore_t struct {
-	Flags		uint32;
-	Posmode		int32;
-	Offset		int64;
-	Length		int64;
-	Bytesalloc	int64;
+	Flags      uint32
+	Posmode    int32
+	Offset     int64
+	Length     int64
+	Bytesalloc int64
 }
 
 type Radvisory_t struct {
-	Offset	int64;
-	Count	int32;
-	Pad0	[4]byte;
+	Offset int64
+	Count  int32
+	Pad0   [4]byte
 }
 
 type Fbootstraptransfer_t struct {
-	Offset	int64;
-	Length	uint64;
-	Buffer	*byte;
+	Offset int64
+	Length uint64
+	Buffer *byte
 }
 
 type Log2phys_t struct {
-	Flags		uint32;
-	Contigbytes	int64;
-	Devoffset	int64;
+	Flags       uint32
+	Contigbytes int64
+	Devoffset   int64
 }
 
 type Dirent struct {
-	Ino	uint64;
-	Seekoff	uint64;
-	Reclen	uint16;
-	Namlen	uint16;
-	Type	uint8;
-	Name	[1024]int8;
-	Pad0	[3]byte;
+	Ino     uint64
+	Seekoff uint64
+	Reclen  uint16
+	Namlen  uint16
+	Type    uint8
+	Name    [1024]int8
+	Pad0    [3]byte
 }
 
 type RawSockaddrInet4 struct {
-	Len	uint8;
-	Family	uint8;
-	Port	uint16;
-	Addr	[4]byte;	/* in_addr */
-	Zero	[8]int8;
+	Len    uint8
+	Family uint8
+	Port   uint16
+	Addr   [4]byte /* in_addr */
+	Zero   [8]int8
 }
 
 type RawSockaddrInet6 struct {
-	Len		uint8;
-	Family		uint8;
-	Port		uint16;
-	Flowinfo	uint32;
-	Addr		[16]byte;	/* in6_addr */
-	Scope_id	uint32;
+	Len      uint8
+	Family   uint8
+	Port     uint16
+	Flowinfo uint32
+	Addr     [16]byte /* in6_addr */
+	Scope_id uint32
 }
 
 type RawSockaddrUnix struct {
-	Len	uint8;
-	Family	uint8;
-	Path	[104]int8;
+	Len    uint8
+	Family uint8
+	Path   [104]int8
 }
 
 type RawSockaddr struct {
-	Len	uint8;
-	Family	uint8;
-	Data	[14]int8;
+	Len    uint8
+	Family uint8
+	Data   [14]int8
 }
 
 type RawSockaddrAny struct {
-	Addr	RawSockaddr;
-	Pad	[92]int8;
+	Addr RawSockaddr
+	Pad  [92]int8
 }
 
 type _Socklen uint32
 
 type Linger struct {
-	Onoff	int32;
-	Linger	int32;
+	Onoff  int32
+	Linger int32
 }
 
 type Iovec struct {
-	Base	*byte;
-	Len	uint64;
+	Base *byte
+	Len  uint64
 }
 
 type Msghdr struct {
-	Name		*byte;
-	Namelen		uint32;
-	Pad0		[4]byte;
-	Iov		*Iovec;
-	Iovlen		int32;
-	Pad1		[4]byte;
-	Control		*byte;
-	Controllen	uint32;
-	Flags		int32;
+	Name       *byte
+	Namelen    uint32
+	Pad0       [4]byte
+	Iov        *Iovec
+	Iovlen     int32
+	Pad1       [4]byte
+	Control    *byte
+	Controllen uint32
+	Flags      int32
 }
 
 type Cmsghdr struct {
-	Len	uint32;
-	Level	int32;
-	Type	int32;
+	Len   uint32
+	Level int32
+	Type  int32
 }
 
 type Kevent_t struct {
-	Ident	uint64;
-	Filter	int16;
-	Flags	uint16;
-	Fflags	uint32;
-	Data	int64;
-	Udata	*byte;
+	Ident  uint64
+	Filter int16
+	Flags  uint16
+	Fflags uint32
+	Data   int64
+	Udata  *byte
 }
 
 type FdSet struct {
-	Bits [32]int32;
+	Bits [32]int32
 }
diff --git a/src/pkg/syscall/ztypes_freebsd_386.go b/src/pkg/syscall/ztypes_freebsd_386.go
index 5a67a9fc74..39e74522d5 100644
--- a/src/pkg/syscall/ztypes_freebsd_386.go
+++ b/src/pkg/syscall/ztypes_freebsd_386.go
@@ -6,36 +6,36 @@ package syscall
 
 // Constants
 const (
-	sizeofPtr		= 0x4;
-	sizeofShort		= 0x2;
-	sizeofInt		= 0x4;
-	sizeofLong		= 0x4;
-	sizeofLongLong		= 0x8;
-	O_CLOEXEC		= 0;
-	S_IFMT			= 0xf000;
-	S_IFIFO			= 0x1000;
-	S_IFCHR			= 0x2000;
-	S_IFDIR			= 0x4000;
-	S_IFBLK			= 0x6000;
-	S_IFREG			= 0x8000;
-	S_IFLNK			= 0xa000;
-	S_IFSOCK		= 0xc000;
-	S_ISUID			= 0x800;
-	S_ISGID			= 0x400;
-	S_ISVTX			= 0x200;
-	S_IRUSR			= 0x100;
-	S_IWUSR			= 0x80;
-	S_IXUSR			= 0x40;
-	SizeofSockaddrInet4	= 0x10;
-	SizeofSockaddrInet6	= 0x1c;
-	SizeofSockaddrAny	= 0x6c;
-	SizeofSockaddrUnix	= 0x6a;
-	SizeofLinger		= 0x8;
-	SizeofMsghdr		= 0x1c;
-	SizeofCmsghdr		= 0xc;
-	PTRACE_TRACEME		= 0;
-	PTRACE_CONT		= 0x7;
-	PTRACE_KILL		= 0x8;
+	sizeofPtr           = 0x4
+	sizeofShort         = 0x2
+	sizeofInt           = 0x4
+	sizeofLong          = 0x4
+	sizeofLongLong      = 0x8
+	O_CLOEXEC           = 0
+	S_IFMT              = 0xf000
+	S_IFIFO             = 0x1000
+	S_IFCHR             = 0x2000
+	S_IFDIR             = 0x4000
+	S_IFBLK             = 0x6000
+	S_IFREG             = 0x8000
+	S_IFLNK             = 0xa000
+	S_IFSOCK            = 0xc000
+	S_ISUID             = 0x800
+	S_ISGID             = 0x400
+	S_ISVTX             = 0x200
+	S_IRUSR             = 0x100
+	S_IWUSR             = 0x80
+	S_IXUSR             = 0x40
+	SizeofSockaddrInet4 = 0x10
+	SizeofSockaddrInet6 = 0x1c
+	SizeofSockaddrAny   = 0x6c
+	SizeofSockaddrUnix  = 0x6a
+	SizeofLinger        = 0x8
+	SizeofMsghdr        = 0x1c
+	SizeofCmsghdr       = 0xc
+	PTRACE_TRACEME      = 0
+	PTRACE_CONT         = 0x7
+	PTRACE_KILL         = 0x8
 )
 
 // Types
@@ -49,176 +49,176 @@ type _C_long int32
 type _C_long_long int64
 
 type Timespec struct {
-	Sec	int32;
-	Nsec	int32;
+	Sec  int32
+	Nsec int32
 }
 
 type Timeval struct {
-	Sec	int32;
-	Usec	int32;
+	Sec  int32
+	Usec int32
 }
 
 type Rusage struct {
-	Utime		Timeval;
-	Stime		Timeval;
-	Maxrss		int32;
-	Ixrss		int32;
-	Idrss		int32;
-	Isrss		int32;
-	Minflt		int32;
-	Majflt		int32;
-	Nswap		int32;
-	Inblock		int32;
-	Oublock		int32;
-	Msgsnd		int32;
-	Msgrcv		int32;
-	Nsignals	int32;
-	Nvcsw		int32;
-	Nivcsw		int32;
+	Utime    Timeval
+	Stime    Timeval
+	Maxrss   int32
+	Ixrss    int32
+	Idrss    int32
+	Isrss    int32
+	Minflt   int32
+	Majflt   int32
+	Nswap    int32
+	Inblock  int32
+	Oublock  int32
+	Msgsnd   int32
+	Msgrcv   int32
+	Nsignals int32
+	Nvcsw    int32
+	Nivcsw   int32
 }
 
 type Rlimit struct {
-	Cur	int64;
-	Max	int64;
+	Cur int64
+	Max int64
 }
 
 type _Gid_t uint32
 
 type Stat_t struct {
-	Dev		uint32;
-	Ino		uint32;
-	Mode		uint16;
-	Nlink		uint16;
-	Uid		uint32;
-	Gid		uint32;
-	Rdev		uint32;
-	Atimespec	Timespec;
-	Mtimespec	Timespec;
-	Ctimespec	Timespec;
-	Size		int64;
-	Blocks		int64;
-	Blksize		uint32;
-	Flags		uint32;
-	Gen		uint32;
-	Lspare		int32;
-	Birthtimespec	Timespec;
-	Pad0		uint32;
-	Pad1		uint32;
+	Dev           uint32
+	Ino           uint32
+	Mode          uint16
+	Nlink         uint16
+	Uid           uint32
+	Gid           uint32
+	Rdev          uint32
+	Atimespec     Timespec
+	Mtimespec     Timespec
+	Ctimespec     Timespec
+	Size          int64
+	Blocks        int64
+	Blksize       uint32
+	Flags         uint32
+	Gen           uint32
+	Lspare        int32
+	Birthtimespec Timespec
+	Pad0          uint32
+	Pad1          uint32
 }
 
 type Statfs_t struct {
-	Version		uint32;
-	Type		uint32;
-	Flags		uint64;
-	Bsize		uint64;
-	Iosize		uint64;
-	Blocks		uint64;
-	Bfree		uint64;
-	Bavail		int64;
-	Files		uint64;
-	Ffree		int64;
-	Syncwrites	uint64;
-	Asyncwrites	uint64;
-	Syncreads	uint64;
-	Asyncreads	uint64;
-	Spare		[10]uint64;
-	Namemax		uint32;
-	Owner		uint32;
-	Fsid		[8]byte;	/* fsid */
-	Charspare	[80]int8;
-	Fstypename	[16]int8;
-	Mntfromname	[88]int8;
-	Mntonname	[88]int8;
+	Version     uint32
+	Type        uint32
+	Flags       uint64
+	Bsize       uint64
+	Iosize      uint64
+	Blocks      uint64
+	Bfree       uint64
+	Bavail      int64
+	Files       uint64
+	Ffree       int64
+	Syncwrites  uint64
+	Asyncwrites uint64
+	Syncreads   uint64
+	Asyncreads  uint64
+	Spare       [10]uint64
+	Namemax     uint32
+	Owner       uint32
+	Fsid        [8]byte /* fsid */
+	Charspare   [80]int8
+	Fstypename  [16]int8
+	Mntfromname [88]int8
+	Mntonname   [88]int8
 }
 
 type Flock_t struct {
-	Start	int64;
-	Len	int64;
-	Pid	int32;
-	Type	int16;
-	Whence	int16;
-	Sysid	int32;
+	Start  int64
+	Len    int64
+	Pid    int32
+	Type   int16
+	Whence int16
+	Sysid  int32
 }
 
 type Dirent struct {
-	Fileno	uint32;
-	Reclen	uint16;
-	Type	uint8;
-	Namlen	uint8;
-	Name	[256]int8;
+	Fileno uint32
+	Reclen uint16
+	Type   uint8
+	Namlen uint8
+	Name   [256]int8
 }
 
 type RawSockaddrInet4 struct {
-	Len	uint8;
-	Family	uint8;
-	Port	uint16;
-	Addr	[4]byte;	/* in_addr */
-	Zero	[8]int8;
+	Len    uint8
+	Family uint8
+	Port   uint16
+	Addr   [4]byte /* in_addr */
+	Zero   [8]int8
 }
 
 type RawSockaddrInet6 struct {
-	Len		uint8;
-	Family		uint8;
-	Port		uint16;
-	Flowinfo	uint32;
-	Addr		[16]byte;	/* in6_addr */
-	Scope_id	uint32;
+	Len      uint8
+	Family   uint8
+	Port     uint16
+	Flowinfo uint32
+	Addr     [16]byte /* in6_addr */
+	Scope_id uint32
 }
 
 type RawSockaddrUnix struct {
-	Len	uint8;
-	Family	uint8;
-	Path	[104]int8;
+	Len    uint8
+	Family uint8
+	Path   [104]int8
 }
 
 type RawSockaddr struct {
-	Len	uint8;
-	Family	uint8;
-	Data	[14]int8;
+	Len    uint8
+	Family uint8
+	Data   [14]int8
 }
 
 type RawSockaddrAny struct {
-	Addr	RawSockaddr;
-	Pad	[92]int8;
+	Addr RawSockaddr
+	Pad  [92]int8
 }
 
 type _Socklen uint32
 
 type Linger struct {
-	Onoff	int32;
-	Linger	int32;
+	Onoff  int32
+	Linger int32
 }
 
 type Iovec struct {
-	Base	*byte;
-	Len	uint32;
+	Base *byte
+	Len  uint32
 }
 
 type Msghdr struct {
-	Name		*byte;
-	Namelen		uint32;
-	Iov		*Iovec;
-	Iovlen		int32;
-	Control		*byte;
-	Controllen	uint32;
-	Flags		int32;
+	Name       *byte
+	Namelen    uint32
+	Iov        *Iovec
+	Iovlen     int32
+	Control    *byte
+	Controllen uint32
+	Flags      int32
 }
 
 type Cmsghdr struct {
-	Len	uint32;
-	Level	int32;
-	Type	int32;
+	Len   uint32
+	Level int32
+	Type  int32
 }
 
 type Kevent_t struct {
-	Ident	uint32;
-	Filter	int16;
-	Flags	uint16;
-	Fflags	uint32;
-	Data	int32;
-	Udata	*byte;
+	Ident  uint32
+	Filter int16
+	Flags  uint16
+	Fflags uint32
+	Data   int32
+	Udata  *byte
 }
 
 type FdSet struct {
-	X__fds_bits [32]uint32;
+	X__fds_bits [32]uint32
 }
diff --git a/src/pkg/syscall/ztypes_freebsd_amd64.go b/src/pkg/syscall/ztypes_freebsd_amd64.go
index 076acc6980..eea7a05175 100644
--- a/src/pkg/syscall/ztypes_freebsd_amd64.go
+++ b/src/pkg/syscall/ztypes_freebsd_amd64.go
@@ -6,36 +6,36 @@ package syscall
 
 // Constants
 const (
-	sizeofPtr		= 0x8;
-	sizeofShort		= 0x2;
-	sizeofInt		= 0x4;
-	sizeofLong		= 0x8;
-	sizeofLongLong		= 0x8;
-	O_CLOEXEC		= 0;
-	S_IFMT			= 0xf000;
-	S_IFIFO			= 0x1000;
-	S_IFCHR			= 0x2000;
-	S_IFDIR			= 0x4000;
-	S_IFBLK			= 0x6000;
-	S_IFREG			= 0x8000;
-	S_IFLNK			= 0xa000;
-	S_IFSOCK		= 0xc000;
-	S_ISUID			= 0x800;
-	S_ISGID			= 0x400;
-	S_ISVTX			= 0x200;
-	S_IRUSR			= 0x100;
-	S_IWUSR			= 0x80;
-	S_IXUSR			= 0x40;
-	SizeofSockaddrInet4	= 0x10;
-	SizeofSockaddrInet6	= 0x1c;
-	SizeofSockaddrAny	= 0x6c;
-	SizeofSockaddrUnix	= 0x6a;
-	SizeofLinger		= 0x8;
-	SizeofMsghdr		= 0x30;
-	SizeofCmsghdr		= 0xc;
-	PTRACE_TRACEME		= 0;
-	PTRACE_CONT		= 0x7;
-	PTRACE_KILL		= 0x8;
+	sizeofPtr           = 0x8
+	sizeofShort         = 0x2
+	sizeofInt           = 0x4
+	sizeofLong          = 0x8
+	sizeofLongLong      = 0x8
+	O_CLOEXEC           = 0
+	S_IFMT              = 0xf000
+	S_IFIFO             = 0x1000
+	S_IFCHR             = 0x2000
+	S_IFDIR             = 0x4000
+	S_IFBLK             = 0x6000
+	S_IFREG             = 0x8000
+	S_IFLNK             = 0xa000
+	S_IFSOCK            = 0xc000
+	S_ISUID             = 0x800
+	S_ISGID             = 0x400
+	S_ISVTX             = 0x200
+	S_IRUSR             = 0x100
+	S_IWUSR             = 0x80
+	S_IXUSR             = 0x40
+	SizeofSockaddrInet4 = 0x10
+	SizeofSockaddrInet6 = 0x1c
+	SizeofSockaddrAny   = 0x6c
+	SizeofSockaddrUnix  = 0x6a
+	SizeofLinger        = 0x8
+	SizeofMsghdr        = 0x30
+	SizeofCmsghdr       = 0xc
+	PTRACE_TRACEME      = 0
+	PTRACE_CONT         = 0x7
+	PTRACE_KILL         = 0x8
 )
 
 // Types
@@ -49,179 +49,179 @@ type _C_long int64
 type _C_long_long int64
 
 type Timespec struct {
-	Sec	int64;
-	Nsec	int64;
+	Sec  int64
+	Nsec int64
 }
 
 type Timeval struct {
-	Sec	int64;
-	Usec	int64;
+	Sec  int64
+	Usec int64
 }
 
 type Rusage struct {
-	Utime		Timeval;
-	Stime		Timeval;
-	Maxrss		int64;
-	Ixrss		int64;
-	Idrss		int64;
-	Isrss		int64;
-	Minflt		int64;
-	Majflt		int64;
-	Nswap		int64;
-	Inblock		int64;
-	Oublock		int64;
-	Msgsnd		int64;
-	Msgrcv		int64;
-	Nsignals	int64;
-	Nvcsw		int64;
-	Nivcsw		int64;
+	Utime    Timeval
+	Stime    Timeval
+	Maxrss   int64
+	Ixrss    int64
+	Idrss    int64
+	Isrss    int64
+	Minflt   int64
+	Majflt   int64
+	Nswap    int64
+	Inblock  int64
+	Oublock  int64
+	Msgsnd   int64
+	Msgrcv   int64
+	Nsignals int64
+	Nvcsw    int64
+	Nivcsw   int64
 }
 
 type Rlimit struct {
-	Cur	int64;
-	Max	int64;
+	Cur int64
+	Max int64
 }
 
 type _Gid_t uint32
 
 type Stat_t struct {
-	Dev		uint32;
-	Ino		uint32;
-	Mode		uint16;
-	Nlink		uint16;
-	Uid		uint32;
-	Gid		uint32;
-	Rdev		uint32;
-	Atimespec	Timespec;
-	Mtimespec	Timespec;
-	Ctimespec	Timespec;
-	Size		int64;
-	Blocks		int64;
-	Blksize		uint32;
-	Flags		uint32;
-	Gen		uint32;
-	Lspare		int32;
-	Birthtimespec	Timespec;
-	Pad0		uint8;
-	Pad1		uint8;
+	Dev           uint32
+	Ino           uint32
+	Mode          uint16
+	Nlink         uint16
+	Uid           uint32
+	Gid           uint32
+	Rdev          uint32
+	Atimespec     Timespec
+	Mtimespec     Timespec
+	Ctimespec     Timespec
+	Size          int64
+	Blocks        int64
+	Blksize       uint32
+	Flags         uint32
+	Gen           uint32
+	Lspare        int32
+	Birthtimespec Timespec
+	Pad0          uint8
+	Pad1          uint8
 }
 
 type Statfs_t struct {
-	Version		uint32;
-	Type		uint32;
-	Flags		uint64;
-	Bsize		uint64;
-	Iosize		uint64;
-	Blocks		uint64;
-	Bfree		uint64;
-	Bavail		int64;
-	Files		uint64;
-	Ffree		int64;
-	Syncwrites	uint64;
-	Asyncwrites	uint64;
-	Syncreads	uint64;
-	Asyncreads	uint64;
-	Spare		[10]uint64;
-	Namemax		uint32;
-	Owner		uint32;
-	Fsid		[8]byte;	/* fsid */
-	Charspare	[80]int8;
-	Fstypename	[16]int8;
-	Mntfromname	[88]int8;
-	Mntonname	[88]int8;
+	Version     uint32
+	Type        uint32
+	Flags       uint64
+	Bsize       uint64
+	Iosize      uint64
+	Blocks      uint64
+	Bfree       uint64
+	Bavail      int64
+	Files       uint64
+	Ffree       int64
+	Syncwrites  uint64
+	Asyncwrites uint64
+	Syncreads   uint64
+	Asyncreads  uint64
+	Spare       [10]uint64
+	Namemax     uint32
+	Owner       uint32
+	Fsid        [8]byte /* fsid */
+	Charspare   [80]int8
+	Fstypename  [16]int8
+	Mntfromname [88]int8
+	Mntonname   [88]int8
 }
 
 type Flock_t struct {
-	Start	int64;
-	Len	int64;
-	Pid	int32;
-	Type	int16;
-	Whence	int16;
-	Sysid	int32;
-	Pad0	[4]byte;
+	Start  int64
+	Len    int64
+	Pid    int32
+	Type   int16
+	Whence int16
+	Sysid  int32
+	Pad0   [4]byte
 }
 
 type Dirent struct {
-	Fileno	uint32;
-	Reclen	uint16;
-	Type	uint8;
-	Namlen	uint8;
-	Name	[256]int8;
+	Fileno uint32
+	Reclen uint16
+	Type   uint8
+	Namlen uint8
+	Name   [256]int8
 }
 
 type RawSockaddrInet4 struct {
-	Len	uint8;
-	Family	uint8;
-	Port	uint16;
-	Addr	[4]byte;	/* in_addr */
-	Zero	[8]int8;
+	Len    uint8
+	Family uint8
+	Port   uint16
+	Addr   [4]byte /* in_addr */
+	Zero   [8]int8
 }
 
 type RawSockaddrInet6 struct {
-	Len		uint8;
-	Family		uint8;
-	Port		uint16;
-	Flowinfo	uint32;
-	Addr		[16]byte;	/* in6_addr */
-	Scope_id	uint32;
+	Len      uint8
+	Family   uint8
+	Port     uint16
+	Flowinfo uint32
+	Addr     [16]byte /* in6_addr */
+	Scope_id uint32
 }
 
 type RawSockaddrUnix struct {
-	Len	uint8;
-	Family	uint8;
-	Path	[104]int8;
+	Len    uint8
+	Family uint8
+	Path   [104]int8
 }
 
 type RawSockaddr struct {
-	Len	uint8;
-	Family	uint8;
-	Data	[14]int8;
+	Len    uint8
+	Family uint8
+	Data   [14]int8
 }
 
 type RawSockaddrAny struct {
-	Addr	RawSockaddr;
-	Pad	[92]int8;
+	Addr RawSockaddr
+	Pad  [92]int8
 }
 
 type _Socklen uint32
 
 type Linger struct {
-	Onoff	int32;
-	Linger	int32;
+	Onoff  int32
+	Linger int32
 }
 
 type Iovec struct {
-	Base	*byte;
-	Len	uint64;
+	Base *byte
+	Len  uint64
 }
 
 type Msghdr struct {
-	Name		*byte;
-	Namelen		uint32;
-	Pad0		[4]byte;
-	Iov		*Iovec;
-	Iovlen		int32;
-	Pad1		[4]byte;
-	Control		*byte;
-	Controllen	uint32;
-	Flags		int32;
+	Name       *byte
+	Namelen    uint32
+	Pad0       [4]byte
+	Iov        *Iovec
+	Iovlen     int32
+	Pad1       [4]byte
+	Control    *byte
+	Controllen uint32
+	Flags      int32
 }
 
 type Cmsghdr struct {
-	Len	uint32;
-	Level	int32;
-	Type	int32;
+	Len   uint32
+	Level int32
+	Type  int32
 }
 
 type Kevent_t struct {
-	Ident	uint64;
-	Filter	int16;
-	Flags	uint16;
-	Fflags	uint32;
-	Data	int64;
-	Udata	*byte;
+	Ident  uint64
+	Filter int16
+	Flags  uint16
+	Fflags uint32
+	Data   int64
+	Udata  *byte
 }
 
 type FdSet struct {
-	X__fds_bits [16]uint64;
+	X__fds_bits [16]uint64
 }
diff --git a/src/pkg/syscall/ztypes_linux_386.go b/src/pkg/syscall/ztypes_linux_386.go
index 68f2032b83..866c119592 100644
--- a/src/pkg/syscall/ztypes_linux_386.go
+++ b/src/pkg/syscall/ztypes_linux_386.go
@@ -6,19 +6,19 @@ package syscall
 
 // Constants
 const (
-	sizeofPtr		= 0x4;
-	sizeofShort		= 0x2;
-	sizeofInt		= 0x4;
-	sizeofLong		= 0x4;
-	sizeofLongLong		= 0x8;
-	PathMax			= 0x1000;
-	SizeofSockaddrInet4	= 0x10;
-	SizeofSockaddrInet6	= 0x1c;
-	SizeofSockaddrAny	= 0x70;
-	SizeofSockaddrUnix	= 0x6e;
-	SizeofLinger		= 0x8;
-	SizeofMsghdr		= 0x1c;
-	SizeofCmsghdr		= 0xc;
+	sizeofPtr           = 0x4
+	sizeofShort         = 0x2
+	sizeofInt           = 0x4
+	sizeofLong          = 0x4
+	sizeofLongLong      = 0x8
+	PathMax             = 0x1000
+	SizeofSockaddrInet4 = 0x10
+	SizeofSockaddrInet6 = 0x1c
+	SizeofSockaddrAny   = 0x70
+	SizeofSockaddrUnix  = 0x6e
+	SizeofLinger        = 0x8
+	SizeofMsghdr        = 0x1c
+	SizeofCmsghdr       = 0xc
 )
 
 // Types
@@ -32,256 +32,256 @@ type _C_long int32
 type _C_long_long int64
 
 type Timespec struct {
-	Sec	int32;
-	Nsec	int32;
+	Sec  int32
+	Nsec int32
 }
 
 type Timeval struct {
-	Sec	int32;
-	Usec	int32;
+	Sec  int32
+	Usec int32
 }
 
 type Timex struct {
-	Modes		uint32;
-	Offset		int32;
-	Freq		int32;
-	Maxerror	int32;
-	Esterror	int32;
-	Status		int32;
-	Constant	int32;
-	Precision	int32;
-	Tolerance	int32;
-	Time		Timeval;
-	Tick		int32;
-	Ppsfreq		int32;
-	Jitter		int32;
-	Shift		int32;
-	Stabil		int32;
-	Jitcnt		int32;
-	Calcnt		int32;
-	Errcnt		int32;
-	Stbcnt		int32;
-	Pad0		int32;
-	Pad1		int32;
-	Pad2		int32;
-	Pad3		int32;
-	Pad4		int32;
-	Pad5		int32;
-	Pad6		int32;
-	Pad7		int32;
-	Pad8		int32;
-	Pad9		int32;
-	Pad10		int32;
-	Pad11		int32;
+	Modes     uint32
+	Offset    int32
+	Freq      int32
+	Maxerror  int32
+	Esterror  int32
+	Status    int32
+	Constant  int32
+	Precision int32
+	Tolerance int32
+	Time      Timeval
+	Tick      int32
+	Ppsfreq   int32
+	Jitter    int32
+	Shift     int32
+	Stabil    int32
+	Jitcnt    int32
+	Calcnt    int32
+	Errcnt    int32
+	Stbcnt    int32
+	Pad0      int32
+	Pad1      int32
+	Pad2      int32
+	Pad3      int32
+	Pad4      int32
+	Pad5      int32
+	Pad6      int32
+	Pad7      int32
+	Pad8      int32
+	Pad9      int32
+	Pad10     int32
+	Pad11     int32
 }
 
 type Time_t int32
 
 type Tms struct {
-	Utime	int32;
-	Stime	int32;
-	Cutime	int32;
-	Cstime	int32;
+	Utime  int32
+	Stime  int32
+	Cutime int32
+	Cstime int32
 }
 
 type Utimbuf struct {
-	Actime	int32;
-	Modtime	int32;
+	Actime  int32
+	Modtime int32
 }
 
 type Rusage struct {
-	Utime		Timeval;
-	Stime		Timeval;
-	Maxrss		int32;
-	Ixrss		int32;
-	Idrss		int32;
-	Isrss		int32;
-	Minflt		int32;
-	Majflt		int32;
-	Nswap		int32;
-	Inblock		int32;
-	Oublock		int32;
-	Msgsnd		int32;
-	Msgrcv		int32;
-	Nsignals	int32;
-	Nvcsw		int32;
-	Nivcsw		int32;
+	Utime    Timeval
+	Stime    Timeval
+	Maxrss   int32
+	Ixrss    int32
+	Idrss    int32
+	Isrss    int32
+	Minflt   int32
+	Majflt   int32
+	Nswap    int32
+	Inblock  int32
+	Oublock  int32
+	Msgsnd   int32
+	Msgrcv   int32
+	Nsignals int32
+	Nvcsw    int32
+	Nivcsw   int32
 }
 
 type Rlimit struct {
-	Cur	uint64;
-	Max	uint64;
+	Cur uint64
+	Max uint64
 }
 
 type _Gid_t uint32
 
 type Stat_t struct {
-	Dev		uint64;
-	X__pad1		uint16;
-	Pad0		[2]byte;
-	X__st_ino	uint32;
-	Mode		uint32;
-	Nlink		uint32;
-	Uid		uint32;
-	Gid		uint32;
-	Rdev		uint64;
-	X__pad2		uint16;
-	Pad1		[2]byte;
-	Size		int64;
-	Blksize		int32;
-	Blocks		int64;
-	Atim		Timespec;
-	Mtim		Timespec;
-	Ctim		Timespec;
-	Ino		uint64;
+	Dev       uint64
+	X__pad1   uint16
+	Pad0      [2]byte
+	X__st_ino uint32
+	Mode      uint32
+	Nlink     uint32
+	Uid       uint32
+	Gid       uint32
+	Rdev      uint64
+	X__pad2   uint16
+	Pad1      [2]byte
+	Size      int64
+	Blksize   int32
+	Blocks    int64
+	Atim      Timespec
+	Mtim      Timespec
+	Ctim      Timespec
+	Ino       uint64
 }
 
 type Statfs_t struct {
-	Type	int32;
-	Bsize	int32;
-	Blocks	uint64;
-	Bfree	uint64;
-	Bavail	uint64;
-	Files	uint64;
-	Ffree	uint64;
-	Fsid	[8]byte;	/* __fsid_t */
-	Namelen	int32;
-	Frsize	int32;
-	Spare	[5]int32;
+	Type    int32
+	Bsize   int32
+	Blocks  uint64
+	Bfree   uint64
+	Bavail  uint64
+	Files   uint64
+	Ffree   uint64
+	Fsid    [8]byte /* __fsid_t */
+	Namelen int32
+	Frsize  int32
+	Spare   [5]int32
 }
 
 type Dirent struct {
-	Ino	uint64;
-	Off	int64;
-	Reclen	uint16;
-	Type	uint8;
-	Name	[256]int8;
-	Pad0	[1]byte;
+	Ino    uint64
+	Off    int64
+	Reclen uint16
+	Type   uint8
+	Name   [256]int8
+	Pad0   [1]byte
 }
 
 type RawSockaddrInet4 struct {
-	Family	uint16;
-	Port	uint16;
-	Addr	[4]byte;	/* in_addr */
-	Zero	[8]uint8;
+	Family uint16
+	Port   uint16
+	Addr   [4]byte /* in_addr */
+	Zero   [8]uint8
 }
 
 type RawSockaddrInet6 struct {
-	Family		uint16;
-	Port		uint16;
-	Flowinfo	uint32;
-	Addr		[16]byte;	/* in6_addr */
-	Scope_id	uint32;
+	Family   uint16
+	Port     uint16
+	Flowinfo uint32
+	Addr     [16]byte /* in6_addr */
+	Scope_id uint32
 }
 
 type RawSockaddrUnix struct {
-	Family	uint16;
-	Path	[108]int8;
+	Family uint16
+	Path   [108]int8
 }
 
 type RawSockaddr struct {
-	Family	uint16;
-	Data	[14]int8;
+	Family uint16
+	Data   [14]int8
 }
 
 type RawSockaddrAny struct {
-	Addr	RawSockaddr;
-	Pad	[96]int8;
+	Addr RawSockaddr
+	Pad  [96]int8
 }
 
 type _Socklen uint32
 
 type Linger struct {
-	Onoff	int32;
-	Linger	int32;
+	Onoff  int32
+	Linger int32
 }
 
 type Iovec struct {
-	Base	*byte;
-	Len	uint32;
+	Base *byte
+	Len  uint32
 }
 
 type Msghdr struct {
-	Name		*byte;
-	Namelen		uint32;
-	Iov		*Iovec;
-	Iovlen		uint32;
-	Control		*byte;
-	Controllen	uint32;
-	Flags		int32;
+	Name       *byte
+	Namelen    uint32
+	Iov        *Iovec
+	Iovlen     uint32
+	Control    *byte
+	Controllen uint32
+	Flags      int32
 }
 
 type Cmsghdr struct {
-	Len	uint32;
-	Level	int32;
-	Type	int32;
+	Len   uint32
+	Level int32
+	Type  int32
 }
 
 type PtraceRegs struct {
-	Ebx		int32;
-	Ecx		int32;
-	Edx		int32;
-	Esi		int32;
-	Edi		int32;
-	Ebp		int32;
-	Eax		int32;
-	Ds		uint16;
-	X__ds		uint16;
-	Es		uint16;
-	X__es		uint16;
-	Fs		uint16;
-	X__fs		uint16;
-	Gs		uint16;
-	X__gs		uint16;
-	Orig_eax	int32;
-	Eip		int32;
-	Cs		uint16;
-	X__cs		uint16;
-	Eflags		int32;
-	Esp		int32;
-	Ss		uint16;
-	X__ss		uint16;
+	Ebx      int32
+	Ecx      int32
+	Edx      int32
+	Esi      int32
+	Edi      int32
+	Ebp      int32
+	Eax      int32
+	Ds       uint16
+	X__ds    uint16
+	Es       uint16
+	X__es    uint16
+	Fs       uint16
+	X__fs    uint16
+	Gs       uint16
+	X__gs    uint16
+	Orig_eax int32
+	Eip      int32
+	Cs       uint16
+	X__cs    uint16
+	Eflags   int32
+	Esp      int32
+	Ss       uint16
+	X__ss    uint16
 }
 
 type FdSet struct {
-	Bits [32]int32;
+	Bits [32]int32
 }
 
 type Sysinfo_t struct {
-	Uptime		int32;
-	Loads		[3]uint32;
-	Totalram	uint32;
-	Freeram		uint32;
-	Sharedram	uint32;
-	Bufferram	uint32;
-	Totalswap	uint32;
-	Freeswap	uint32;
-	Procs		uint16;
-	Pad		uint16;
-	Totalhigh	uint32;
-	Freehigh	uint32;
-	Unit		uint32;
-	X_f		[8]int8;
+	Uptime    int32
+	Loads     [3]uint32
+	Totalram  uint32
+	Freeram   uint32
+	Sharedram uint32
+	Bufferram uint32
+	Totalswap uint32
+	Freeswap  uint32
+	Procs     uint16
+	Pad       uint16
+	Totalhigh uint32
+	Freehigh  uint32
+	Unit      uint32
+	X_f       [8]int8
 }
 
 type Utsname struct {
-	Sysname		[65]int8;
-	Nodename	[65]int8;
-	Release		[65]int8;
-	Version		[65]int8;
-	Machine		[65]int8;
-	Domainname	[65]int8;
+	Sysname    [65]int8
+	Nodename   [65]int8
+	Release    [65]int8
+	Version    [65]int8
+	Machine    [65]int8
+	Domainname [65]int8
 }
 
 type Ustat_t struct {
-	Tfree	int32;
-	Tinode	uint32;
-	Fname	[6]int8;
-	Fpack	[6]int8;
+	Tfree  int32
+	Tinode uint32
+	Fname  [6]int8
+	Fpack  [6]int8
 }
 
 type EpollEvent struct {
-	Events	uint32;
-	Fd	int32;
-	Pad	int32;
+	Events uint32
+	Fd     int32
+	Pad    int32
 }
diff --git a/src/pkg/syscall/ztypes_linux_amd64.go b/src/pkg/syscall/ztypes_linux_amd64.go
index 74e9750f9a..a5fc0ab536 100644
--- a/src/pkg/syscall/ztypes_linux_amd64.go
+++ b/src/pkg/syscall/ztypes_linux_amd64.go
@@ -6,19 +6,19 @@ package syscall
 
 // Constants
 const (
-	sizeofPtr		= 0x8;
-	sizeofShort		= 0x2;
-	sizeofInt		= 0x4;
-	sizeofLong		= 0x8;
-	sizeofLongLong		= 0x8;
-	PathMax			= 0x1000;
-	SizeofSockaddrInet4	= 0x10;
-	SizeofSockaddrInet6	= 0x1c;
-	SizeofSockaddrAny	= 0x70;
-	SizeofSockaddrUnix	= 0x6e;
-	SizeofLinger		= 0x8;
-	SizeofMsghdr		= 0x38;
-	SizeofCmsghdr		= 0x10;
+	sizeofPtr           = 0x8
+	sizeofShort         = 0x2
+	sizeofInt           = 0x4
+	sizeofLong          = 0x8
+	sizeofLongLong      = 0x8
+	PathMax             = 0x1000
+	SizeofSockaddrInet4 = 0x10
+	SizeofSockaddrInet6 = 0x1c
+	SizeofSockaddrAny   = 0x70
+	SizeofSockaddrUnix  = 0x6e
+	SizeofLinger        = 0x8
+	SizeofMsghdr        = 0x38
+	SizeofCmsghdr       = 0x10
 )
 
 // Types
@@ -32,266 +32,266 @@ type _C_long int64
 type _C_long_long int64
 
 type Timespec struct {
-	Sec	int64;
-	Nsec	int64;
+	Sec  int64
+	Nsec int64
 }
 
 type Timeval struct {
-	Sec	int64;
-	Usec	int64;
+	Sec  int64
+	Usec int64
 }
 
 type Timex struct {
-	Modes		uint32;
-	Pad0		[4]byte;
-	Offset		int64;
-	Freq		int64;
-	Maxerror	int64;
-	Esterror	int64;
-	Status		int32;
-	Pad1		[4]byte;
-	Constant	int64;
-	Precision	int64;
-	Tolerance	int64;
-	Time		Timeval;
-	Tick		int64;
-	Ppsfreq		int64;
-	Jitter		int64;
-	Shift		int32;
-	Pad2		[4]byte;
-	Stabil		int64;
-	Jitcnt		int64;
-	Calcnt		int64;
-	Errcnt		int64;
-	Stbcnt		int64;
-	Pad3		int32;
-	Pad4		int32;
-	Pad5		int32;
-	Pad6		int32;
-	Pad7		int32;
-	Pad8		int32;
-	Pad9		int32;
-	Pad10		int32;
-	Pad11		int32;
-	Pad12		int32;
-	Pad13		int32;
-	Pad14		int32;
+	Modes     uint32
+	Pad0      [4]byte
+	Offset    int64
+	Freq      int64
+	Maxerror  int64
+	Esterror  int64
+	Status    int32
+	Pad1      [4]byte
+	Constant  int64
+	Precision int64
+	Tolerance int64
+	Time      Timeval
+	Tick      int64
+	Ppsfreq   int64
+	Jitter    int64
+	Shift     int32
+	Pad2      [4]byte
+	Stabil    int64
+	Jitcnt    int64
+	Calcnt    int64
+	Errcnt    int64
+	Stbcnt    int64
+	Pad3      int32
+	Pad4      int32
+	Pad5      int32
+	Pad6      int32
+	Pad7      int32
+	Pad8      int32
+	Pad9      int32
+	Pad10     int32
+	Pad11     int32
+	Pad12     int32
+	Pad13     int32
+	Pad14     int32
 }
 
 type Time_t int64
 
 type Tms struct {
-	Utime	int64;
-	Stime	int64;
-	Cutime	int64;
-	Cstime	int64;
+	Utime  int64
+	Stime  int64
+	Cutime int64
+	Cstime int64
 }
 
 type Utimbuf struct {
-	Actime	int64;
-	Modtime	int64;
+	Actime  int64
+	Modtime int64
 }
 
 type Rusage struct {
-	Utime		Timeval;
-	Stime		Timeval;
-	Maxrss		int64;
-	Ixrss		int64;
-	Idrss		int64;
-	Isrss		int64;
-	Minflt		int64;
-	Majflt		int64;
-	Nswap		int64;
-	Inblock		int64;
-	Oublock		int64;
-	Msgsnd		int64;
-	Msgrcv		int64;
-	Nsignals	int64;
-	Nvcsw		int64;
-	Nivcsw		int64;
+	Utime    Timeval
+	Stime    Timeval
+	Maxrss   int64
+	Ixrss    int64
+	Idrss    int64
+	Isrss    int64
+	Minflt   int64
+	Majflt   int64
+	Nswap    int64
+	Inblock  int64
+	Oublock  int64
+	Msgsnd   int64
+	Msgrcv   int64
+	Nsignals int64
+	Nvcsw    int64
+	Nivcsw   int64
 }
 
 type Rlimit struct {
-	Cur	uint64;
-	Max	uint64;
+	Cur uint64
+	Max uint64
 }
 
 type _Gid_t uint32
 
 type Stat_t struct {
-	Dev		uint64;
-	Ino		uint64;
-	Nlink		uint64;
-	Mode		uint32;
-	Uid		uint32;
-	Gid		uint32;
-	Pad0		int32;
-	Rdev		uint64;
-	Size		int64;
-	Blksize		int64;
-	Blocks		int64;
-	Atim		Timespec;
-	Mtim		Timespec;
-	Ctim		Timespec;
-	__unused	[3]int64;
+	Dev      uint64
+	Ino      uint64
+	Nlink    uint64
+	Mode     uint32
+	Uid      uint32
+	Gid      uint32
+	Pad0     int32
+	Rdev     uint64
+	Size     int64
+	Blksize  int64
+	Blocks   int64
+	Atim     Timespec
+	Mtim     Timespec
+	Ctim     Timespec
+	__unused [3]int64
 }
 
 type Statfs_t struct {
-	Type	int64;
-	Bsize	int64;
-	Blocks	uint64;
-	Bfree	uint64;
-	Bavail	uint64;
-	Files	uint64;
-	Ffree	uint64;
-	Fsid	[8]byte;	/* __fsid_t */
-	Namelen	int64;
-	Frsize	int64;
-	Spare	[5]int64;
+	Type    int64
+	Bsize   int64
+	Blocks  uint64
+	Bfree   uint64
+	Bavail  uint64
+	Files   uint64
+	Ffree   uint64
+	Fsid    [8]byte /* __fsid_t */
+	Namelen int64
+	Frsize  int64
+	Spare   [5]int64
 }
 
 type Dirent struct {
-	Ino	uint64;
-	Off	int64;
-	Reclen	uint16;
-	Type	uint8;
-	Name	[256]int8;
-	Pad0	[5]byte;
+	Ino    uint64
+	Off    int64
+	Reclen uint16
+	Type   uint8
+	Name   [256]int8
+	Pad0   [5]byte
 }
 
 type RawSockaddrInet4 struct {
-	Family	uint16;
-	Port	uint16;
-	Addr	[4]byte;	/* in_addr */
-	Zero	[8]uint8;
+	Family uint16
+	Port   uint16
+	Addr   [4]byte /* in_addr */
+	Zero   [8]uint8
 }
 
 type RawSockaddrInet6 struct {
-	Family		uint16;
-	Port		uint16;
-	Flowinfo	uint32;
-	Addr		[16]byte;	/* in6_addr */
-	Scope_id	uint32;
+	Family   uint16
+	Port     uint16
+	Flowinfo uint32
+	Addr     [16]byte /* in6_addr */
+	Scope_id uint32
 }
 
 type RawSockaddrUnix struct {
-	Family	uint16;
-	Path	[108]int8;
+	Family uint16
+	Path   [108]int8
 }
 
 type RawSockaddr struct {
-	Family	uint16;
-	Data	[14]int8;
+	Family uint16
+	Data   [14]int8
 }
 
 type RawSockaddrAny struct {
-	Addr	RawSockaddr;
-	Pad	[96]int8;
+	Addr RawSockaddr
+	Pad  [96]int8
 }
 
 type _Socklen uint32
 
 type Linger struct {
-	Onoff	int32;
-	Linger	int32;
+	Onoff  int32
+	Linger int32
 }
 
 type Iovec struct {
-	Base	*byte;
-	Len	uint64;
+	Base *byte
+	Len  uint64
 }
 
 type Msghdr struct {
-	Name		*byte;
-	Namelen		uint32;
-	Pad0		[4]byte;
-	Iov		*Iovec;
-	Iovlen		uint64;
-	Control		*byte;
-	Controllen	uint64;
-	Flags		int32;
-	Pad1		[4]byte;
+	Name       *byte
+	Namelen    uint32
+	Pad0       [4]byte
+	Iov        *Iovec
+	Iovlen     uint64
+	Control    *byte
+	Controllen uint64
+	Flags      int32
+	Pad1       [4]byte
 }
 
 type Cmsghdr struct {
-	Len	uint64;
-	Level	int32;
-	Type	int32;
+	Len   uint64
+	Level int32
+	Type  int32
 }
 
 type PtraceRegs struct {
-	R15		uint64;
-	R14		uint64;
-	R13		uint64;
-	R12		uint64;
-	Rbp		uint64;
-	Rbx		uint64;
-	R11		uint64;
-	R10		uint64;
-	R9		uint64;
-	R8		uint64;
-	Rax		uint64;
-	Rcx		uint64;
-	Rdx		uint64;
-	Rsi		uint64;
-	Rdi		uint64;
-	Orig_rax	uint64;
-	Rip		uint64;
-	Cs		uint64;
-	Eflags		uint64;
-	Rsp		uint64;
-	Ss		uint64;
-	Fs_base		uint64;
-	Gs_base		uint64;
-	Ds		uint64;
-	Es		uint64;
-	Fs		uint64;
-	Gs		uint64;
+	R15      uint64
+	R14      uint64
+	R13      uint64
+	R12      uint64
+	Rbp      uint64
+	Rbx      uint64
+	R11      uint64
+	R10      uint64
+	R9       uint64
+	R8       uint64
+	Rax      uint64
+	Rcx      uint64
+	Rdx      uint64
+	Rsi      uint64
+	Rdi      uint64
+	Orig_rax uint64
+	Rip      uint64
+	Cs       uint64
+	Eflags   uint64
+	Rsp      uint64
+	Ss       uint64
+	Fs_base  uint64
+	Gs_base  uint64
+	Ds       uint64
+	Es       uint64
+	Fs       uint64
+	Gs       uint64
 }
 
 type FdSet struct {
-	Bits [16]int64;
+	Bits [16]int64
 }
 
 type Sysinfo_t struct {
-	Uptime		int64;
-	Loads		[3]uint64;
-	Totalram	uint64;
-	Freeram		uint64;
-	Sharedram	uint64;
-	Bufferram	uint64;
-	Totalswap	uint64;
-	Freeswap	uint64;
-	Procs		uint16;
-	Pad		uint16;
-	Pad0		[4]byte;
-	Totalhigh	uint64;
-	Freehigh	uint64;
-	Unit		uint32;
-	_f		[2]int8;
-	Pad1		[4]byte;
+	Uptime    int64
+	Loads     [3]uint64
+	Totalram  uint64
+	Freeram   uint64
+	Sharedram uint64
+	Bufferram uint64
+	Totalswap uint64
+	Freeswap  uint64
+	Procs     uint16
+	Pad       uint16
+	Pad0      [4]byte
+	Totalhigh uint64
+	Freehigh  uint64
+	Unit      uint32
+	_f        [2]int8
+	Pad1      [4]byte
 }
 
 type Utsname struct {
-	Sysname		[65]int8;
-	Nodename	[65]int8;
-	Release		[65]int8;
-	Version		[65]int8;
-	Machine		[65]int8;
-	Domainname	[65]int8;
+	Sysname    [65]int8
+	Nodename   [65]int8
+	Release    [65]int8
+	Version    [65]int8
+	Machine    [65]int8
+	Domainname [65]int8
 }
 
 type Ustat_t struct {
-	Tfree	int32;
-	Pad0	[4]byte;
-	Tinode	uint64;
-	Fname	[6]int8;
-	Fpack	[6]int8;
-	Pad1	[4]byte;
+	Tfree  int32
+	Pad0   [4]byte
+	Tinode uint64
+	Fname  [6]int8
+	Fpack  [6]int8
+	Pad1   [4]byte
 }
 
 type EpollEvent struct {
-	Events	uint32;
-	Fd	int32;
-	Pad	int32;
+	Events uint32
+	Fd     int32
+	Pad    int32
 }
diff --git a/src/pkg/syscall/ztypes_linux_arm.go b/src/pkg/syscall/ztypes_linux_arm.go
index 536b08bfae..ffac446aed 100644
--- a/src/pkg/syscall/ztypes_linux_arm.go
+++ b/src/pkg/syscall/ztypes_linux_arm.go
@@ -6,121 +6,121 @@ package syscall
 
 // Constants
 const (
-	sizeofPtr		= 0x4;
-	sizeofShort		= 0x2;
-	sizeofInt		= 0x4;
-	sizeofLong		= 0x4;
-	sizeofLongLong		= 0x8;
-	PathMax			= 0x1000;
-	O_RDONLY		= 0;
-	O_WRONLY		= 0x1;
-	O_RDWR			= 0x2;
-	O_APPEND		= 0x400;
-	O_ASYNC			= 0x2000;
-	O_CREAT			= 0x40;
-	O_NOCTTY		= 0x100;
-	O_NONBLOCK		= 0x800;
-	O_SYNC			= 0x1000;
-	O_TRUNC			= 0x200;
-	O_CLOEXEC		= 0;
-	F_GETFD			= 0x1;
-	F_SETFD			= 0x2;
-	F_GETFL			= 0x3;
-	F_SETFL			= 0x4;
-	FD_CLOEXEC		= 0x1;
-	NAME_MAX		= 0xff;
-	S_IFMT			= 0xf000;
-	S_IFIFO			= 0x1000;
-	S_IFCHR			= 0x2000;
-	S_IFDIR			= 0x4000;
-	S_IFBLK			= 0x6000;
-	S_IFREG			= 0x8000;
-	S_IFLNK			= 0xa000;
-	S_IFSOCK		= 0xc000;
-	S_ISUID			= 0x800;
-	S_ISGID			= 0x400;
-	S_ISVTX			= 0x200;
-	S_IRUSR			= 0x100;
-	S_IWUSR			= 0x80;
-	S_IXUSR			= 0x40;
-	WNOHANG			= 0x1;
-	WUNTRACED		= 0x2;
-	WEXITED			= 0x4;
-	WSTOPPED		= 0x2;
-	WCONTINUED		= 0x8;
-	WNOWAIT			= 0x1000000;
-	WCLONE			= 0x80000000;
-	WALL			= 0x40000000;
-	WNOTHREAD		= 0x20000000;
-	AF_UNIX			= 0x1;
-	AF_INET			= 0x2;
-	AF_INET6		= 0xa;
-	SOCK_STREAM		= 0x1;
-	SOCK_DGRAM		= 0x2;
-	SOCK_RAW		= 0x3;
-	SOCK_SEQPACKET		= 0x5;
-	SOL_SOCKET		= 0x1;
-	SO_REUSEADDR		= 0x2;
-	SO_KEEPALIVE		= 0x9;
-	SO_DONTROUTE		= 0x5;
-	SO_BROADCAST		= 0x6;
-	SO_LINGER		= 0xd;
-	SO_SNDBUF		= 0x7;
-	SO_RCVBUF		= 0x8;
-	SO_SNDTIMEO		= 0x15;
-	SO_RCVTIMEO		= 0x14;
-	IPPROTO_TCP		= 0x6;
-	IPPROTO_UDP		= 0x11;
-	TCP_NODELAY		= 0x1;
-	SOMAXCONN		= 0x80;
-	SizeofSockaddrInet4	= 0x10;
-	SizeofSockaddrInet6	= 0x1c;
-	SizeofSockaddrAny	= 0x1c;
-	SizeofSockaddrUnix	= 0x6e;
-	PTRACE_TRACEME		= 0;
-	PTRACE_PEEKTEXT		= 0x1;
-	PTRACE_PEEKDATA		= 0x2;
-	PTRACE_PEEKUSER		= 0x3;
-	PTRACE_POKETEXT		= 0x4;
-	PTRACE_POKEDATA		= 0x5;
-	PTRACE_POKEUSER		= 0x6;
-	PTRACE_CONT		= 0x7;
-	PTRACE_KILL		= 0x8;
-	PTRACE_SINGLESTEP	= 0x9;
-	PTRACE_GETREGS		= 0xc;
-	PTRACE_SETREGS		= 0xd;
-	PTRACE_GETFPREGS	= 0xe;
-	PTRACE_SETFPREGS	= 0xf;
-	PTRACE_ATTACH		= 0x10;
-	PTRACE_DETACH		= 0x11;
-	PTRACE_GETFPXREGS	= 0x12;
-	PTRACE_SETFPXREGS	= 0x13;
-	PTRACE_SYSCALL		= 0x18;
-	PTRACE_SETOPTIONS	= 0x4200;
-	PTRACE_GETEVENTMSG	= 0x4201;
-	PTRACE_GETSIGINFO	= 0x4202;
-	PTRACE_SETSIGINFO	= 0x4203;
-	PTRACE_O_TRACESYSGOOD	= 0x1;
-	PTRACE_O_TRACEFORK	= 0x2;
-	PTRACE_O_TRACEVFORK	= 0x4;
-	PTRACE_O_TRACECLONE	= 0x8;
-	PTRACE_O_TRACEEXEC	= 0x10;
-	PTRACE_O_TRACEVFORKDONE	= 0x20;
-	PTRACE_O_TRACEEXIT	= 0x40;
-	PTRACE_O_MASK		= 0x7f;
-	PTRACE_EVENT_FORK	= 0x1;
-	PTRACE_EVENT_VFORK	= 0x2;
-	PTRACE_EVENT_CLONE	= 0x3;
-	PTRACE_EVENT_EXEC	= 0x4;
-	PTRACE_EVENT_VFORK_DONE	= 0x5;
-	PTRACE_EVENT_EXIT	= 0x6;
-	EPOLLIN			= 0x1;
-	EPOLLRDHUP		= 0x2000;
-	EPOLLOUT		= 0x4;
-	EPOLLONESHOT		= 0x40000000;
-	EPOLL_CTL_MOD		= 0x3;
-	EPOLL_CTL_ADD		= 0x1;
-	EPOLL_CTL_DEL		= 0x2;
+	sizeofPtr               = 0x4
+	sizeofShort             = 0x2
+	sizeofInt               = 0x4
+	sizeofLong              = 0x4
+	sizeofLongLong          = 0x8
+	PathMax                 = 0x1000
+	O_RDONLY                = 0
+	O_WRONLY                = 0x1
+	O_RDWR                  = 0x2
+	O_APPEND                = 0x400
+	O_ASYNC                 = 0x2000
+	O_CREAT                 = 0x40
+	O_NOCTTY                = 0x100
+	O_NONBLOCK              = 0x800
+	O_SYNC                  = 0x1000
+	O_TRUNC                 = 0x200
+	O_CLOEXEC               = 0
+	F_GETFD                 = 0x1
+	F_SETFD                 = 0x2
+	F_GETFL                 = 0x3
+	F_SETFL                 = 0x4
+	FD_CLOEXEC              = 0x1
+	NAME_MAX                = 0xff
+	S_IFMT                  = 0xf000
+	S_IFIFO                 = 0x1000
+	S_IFCHR                 = 0x2000
+	S_IFDIR                 = 0x4000
+	S_IFBLK                 = 0x6000
+	S_IFREG                 = 0x8000
+	S_IFLNK                 = 0xa000
+	S_IFSOCK                = 0xc000
+	S_ISUID                 = 0x800
+	S_ISGID                 = 0x400
+	S_ISVTX                 = 0x200
+	S_IRUSR                 = 0x100
+	S_IWUSR                 = 0x80
+	S_IXUSR                 = 0x40
+	WNOHANG                 = 0x1
+	WUNTRACED               = 0x2
+	WEXITED                 = 0x4
+	WSTOPPED                = 0x2
+	WCONTINUED              = 0x8
+	WNOWAIT                 = 0x1000000
+	WCLONE                  = 0x80000000
+	WALL                    = 0x40000000
+	WNOTHREAD               = 0x20000000
+	AF_UNIX                 = 0x1
+	AF_INET                 = 0x2
+	AF_INET6                = 0xa
+	SOCK_STREAM             = 0x1
+	SOCK_DGRAM              = 0x2
+	SOCK_RAW                = 0x3
+	SOCK_SEQPACKET          = 0x5
+	SOL_SOCKET              = 0x1
+	SO_REUSEADDR            = 0x2
+	SO_KEEPALIVE            = 0x9
+	SO_DONTROUTE            = 0x5
+	SO_BROADCAST            = 0x6
+	SO_LINGER               = 0xd
+	SO_SNDBUF               = 0x7
+	SO_RCVBUF               = 0x8
+	SO_SNDTIMEO             = 0x15
+	SO_RCVTIMEO             = 0x14
+	IPPROTO_TCP             = 0x6
+	IPPROTO_UDP             = 0x11
+	TCP_NODELAY             = 0x1
+	SOMAXCONN               = 0x80
+	SizeofSockaddrInet4     = 0x10
+	SizeofSockaddrInet6     = 0x1c
+	SizeofSockaddrAny       = 0x1c
+	SizeofSockaddrUnix      = 0x6e
+	PTRACE_TRACEME          = 0
+	PTRACE_PEEKTEXT         = 0x1
+	PTRACE_PEEKDATA         = 0x2
+	PTRACE_PEEKUSER         = 0x3
+	PTRACE_POKETEXT         = 0x4
+	PTRACE_POKEDATA         = 0x5
+	PTRACE_POKEUSER         = 0x6
+	PTRACE_CONT             = 0x7
+	PTRACE_KILL             = 0x8
+	PTRACE_SINGLESTEP       = 0x9
+	PTRACE_GETREGS          = 0xc
+	PTRACE_SETREGS          = 0xd
+	PTRACE_GETFPREGS        = 0xe
+	PTRACE_SETFPREGS        = 0xf
+	PTRACE_ATTACH           = 0x10
+	PTRACE_DETACH           = 0x11
+	PTRACE_GETFPXREGS       = 0x12
+	PTRACE_SETFPXREGS       = 0x13
+	PTRACE_SYSCALL          = 0x18
+	PTRACE_SETOPTIONS       = 0x4200
+	PTRACE_GETEVENTMSG      = 0x4201
+	PTRACE_GETSIGINFO       = 0x4202
+	PTRACE_SETSIGINFO       = 0x4203
+	PTRACE_O_TRACESYSGOOD   = 0x1
+	PTRACE_O_TRACEFORK      = 0x2
+	PTRACE_O_TRACEVFORK     = 0x4
+	PTRACE_O_TRACECLONE     = 0x8
+	PTRACE_O_TRACEEXEC      = 0x10
+	PTRACE_O_TRACEVFORKDONE = 0x20
+	PTRACE_O_TRACEEXIT      = 0x40
+	PTRACE_O_MASK           = 0x7f
+	PTRACE_EVENT_FORK       = 0x1
+	PTRACE_EVENT_VFORK      = 0x2
+	PTRACE_EVENT_CLONE      = 0x3
+	PTRACE_EVENT_EXEC       = 0x4
+	PTRACE_EVENT_VFORK_DONE = 0x5
+	PTRACE_EVENT_EXIT       = 0x6
+	EPOLLIN                 = 0x1
+	EPOLLRDHUP              = 0x2000
+	EPOLLOUT                = 0x4
+	EPOLLONESHOT            = 0x40000000
+	EPOLL_CTL_MOD           = 0x3
+	EPOLL_CTL_ADD           = 0x1
+	EPOLL_CTL_DEL           = 0x2
 )
 
 // Types
@@ -134,235 +134,235 @@ type _C_long int32
 type _C_long_long int64
 
 type Timespec struct {
-	Sec	int32;
-	Nsec	int32;
+	Sec  int32
+	Nsec int32
 }
 
 type Timeval struct {
-	Sec	int32;
-	Usec	int32;
+	Sec  int32
+	Usec int32
 }
 
 type Timex struct {
-	Modes		uint32;
-	Offset		int32;
-	Freq		int32;
-	Maxerror	int32;
-	Esterror	int32;
-	Status		int32;
-	Constant	int32;
-	Precision	int32;
-	Tolerance	int32;
-	Time		Timeval;
-	Tick		int32;
-	Ppsfreq		int32;
-	Jitter		int32;
-	Shift		int32;
-	Stabil		int32;
-	Jitcnt		int32;
-	Calcnt		int32;
-	Errcnt		int32;
-	Stbcnt		int32;
-	Pad0		int32;
-	Pad1		int32;
-	Pad2		int32;
-	Pad3		int32;
-	Pad4		int32;
-	Pad5		int32;
-	Pad6		int32;
-	Pad7		int32;
-	Pad8		int32;
-	Pad9		int32;
-	Pad10		int32;
-	Pad11		int32;
+	Modes     uint32
+	Offset    int32
+	Freq      int32
+	Maxerror  int32
+	Esterror  int32
+	Status    int32
+	Constant  int32
+	Precision int32
+	Tolerance int32
+	Time      Timeval
+	Tick      int32
+	Ppsfreq   int32
+	Jitter    int32
+	Shift     int32
+	Stabil    int32
+	Jitcnt    int32
+	Calcnt    int32
+	Errcnt    int32
+	Stbcnt    int32
+	Pad0      int32
+	Pad1      int32
+	Pad2      int32
+	Pad3      int32
+	Pad4      int32
+	Pad5      int32
+	Pad6      int32
+	Pad7      int32
+	Pad8      int32
+	Pad9      int32
+	Pad10     int32
+	Pad11     int32
 }
 
 type Time_t int32
 
 type Tms struct {
-	Utime	int32;
-	Stime	int32;
-	Cutime	int32;
-	Cstime	int32;
+	Utime  int32
+	Stime  int32
+	Cutime int32
+	Cstime int32
 }
 
 type Utimbuf struct {
-	Actime	int32;
-	Modtime	int32;
+	Actime  int32
+	Modtime int32
 }
 
 type Rusage struct {
-	Utime		Timeval;
-	Stime		Timeval;
-	Maxrss		int32;
-	Ixrss		int32;
-	Idrss		int32;
-	Isrss		int32;
-	Minflt		int32;
-	Majflt		int32;
-	Nswap		int32;
-	Inblock		int32;
-	Oublock		int32;
-	Msgsnd		int32;
-	Msgrcv		int32;
-	Nsignals	int32;
-	Nvcsw		int32;
-	Nivcsw		int32;
+	Utime    Timeval
+	Stime    Timeval
+	Maxrss   int32
+	Ixrss    int32
+	Idrss    int32
+	Isrss    int32
+	Minflt   int32
+	Majflt   int32
+	Nswap    int32
+	Inblock  int32
+	Oublock  int32
+	Msgsnd   int32
+	Msgrcv   int32
+	Nsignals int32
+	Nvcsw    int32
+	Nivcsw   int32
 }
 
 type Rlimit struct {
-	Cur	uint64;
-	Max	uint64;
+	Cur uint64
+	Max uint64
 }
 
 type _Gid_t uint32
 
 type Stat_t struct {
-	Dev		uint64;
-	__pad1		uint16;
-	Pad0		[2]byte;
-	__st_ino	uint32;
-	Mode		uint32;
-	Nlink		uint32;
-	Uid		uint32;
-	Gid		uint32;
-	Rdev		uint64;
-	__pad2		uint16;
-	Pad1		[2]byte;
-	Size		int64;
-	Blksize		int32;
-	Blocks		int64;
-	Atim		Timespec;
-	Mtim		Timespec;
-	Ctim		Timespec;
-	Ino		uint64;
+	Dev      uint64
+	__pad1   uint16
+	Pad0     [2]byte
+	__st_ino uint32
+	Mode     uint32
+	Nlink    uint32
+	Uid      uint32
+	Gid      uint32
+	Rdev     uint64
+	__pad2   uint16
+	Pad1     [2]byte
+	Size     int64
+	Blksize  int32
+	Blocks   int64
+	Atim     Timespec
+	Mtim     Timespec
+	Ctim     Timespec
+	Ino      uint64
 }
 
 type Statfs_t struct {
-	Type	int32;
-	Bsize	int32;
-	Blocks	uint64;
-	Bfree	uint64;
-	Bavail	uint64;
-	Files	uint64;
-	Ffree	uint64;
-	Fsid	[8]byte;	/* __fsid_t */
-	Namelen	int32;
-	Frsize	int32;
-	Spare	[5]int32;
+	Type    int32
+	Bsize   int32
+	Blocks  uint64
+	Bfree   uint64
+	Bavail  uint64
+	Files   uint64
+	Ffree   uint64
+	Fsid    [8]byte /* __fsid_t */
+	Namelen int32
+	Frsize  int32
+	Spare   [5]int32
 }
 
 type Dirent struct {
-	Ino	uint64;
-	Off	int64;
-	Reclen	uint16;
-	Type	uint8;
-	Name	[256]int8;
-	Pad0	[1]byte;
+	Ino    uint64
+	Off    int64
+	Reclen uint16
+	Type   uint8
+	Name   [256]int8
+	Pad0   [1]byte
 }
 
 type RawSockaddrInet4 struct {
-	Family	uint16;
-	Port	uint16;
-	Addr	[4]byte;	/* in_addr */
-	Zero	[8]uint8;
+	Family uint16
+	Port   uint16
+	Addr   [4]byte /* in_addr */
+	Zero   [8]uint8
 }
 
 type RawSockaddrInet6 struct {
-	Family		uint16;
-	Port		uint16;
-	Flowinfo	uint32;
-	Addr		[16]byte;	/* in6_addr */
-	Scope_id	uint32;
+	Family   uint16
+	Port     uint16
+	Flowinfo uint32
+	Addr     [16]byte /* in6_addr */
+	Scope_id uint32
 }
 
 type RawSockaddrUnix struct {
-	Family	uint16;
-	Path	[108]int8;
+	Family uint16
+	Path   [108]int8
 }
 
 type RawSockaddr struct {
-	Family	uint16;
-	Data	[14]int8;
+	Family uint16
+	Data   [14]int8
 }
 
 type RawSockaddrAny struct {
-	Addr	RawSockaddr;
-	Pad	[12]int8;
+	Addr RawSockaddr
+	Pad  [12]int8
 }
 
 type _Socklen uint32
 
 type Linger struct {
-	Onoff	int32;
-	Linger	int32;
+	Onoff  int32
+	Linger int32
 }
 
 type PtraceRegs struct {
-	Ebx		int32;
-	Ecx		int32;
-	Edx		int32;
-	Esi		int32;
-	Edi		int32;
-	Ebp		int32;
-	Eax		int32;
-	Ds		uint16;
-	__ds		uint16;
-	Es		uint16;
-	__es		uint16;
-	Fs		uint16;
-	__fs		uint16;
-	Gs		uint16;
-	__gs		uint16;
-	Orig_eax	int32;
-	Eip		int32;
-	Cs		uint16;
-	__cs		uint16;
-	Eflags		int32;
-	Esp		int32;
-	Ss		uint16;
-	__ss		uint16;
+	Ebx      int32
+	Ecx      int32
+	Edx      int32
+	Esi      int32
+	Edi      int32
+	Ebp      int32
+	Eax      int32
+	Ds       uint16
+	__ds     uint16
+	Es       uint16
+	__es     uint16
+	Fs       uint16
+	__fs     uint16
+	Gs       uint16
+	__gs     uint16
+	Orig_eax int32
+	Eip      int32
+	Cs       uint16
+	__cs     uint16
+	Eflags   int32
+	Esp      int32
+	Ss       uint16
+	__ss     uint16
 }
 
 type FdSet struct {
-	Bits [32]int32;
+	Bits [32]int32
 }
 
 type Sysinfo_t struct {
-	Uptime		int32;
-	Loads		[3]uint32;
-	Totalram	uint32;
-	Freeram		uint32;
-	Sharedram	uint32;
-	Bufferram	uint32;
-	Totalswap	uint32;
-	Freeswap	uint32;
-	Procs		uint16;
-	Pad		uint16;
-	Totalhigh	uint32;
-	Freehigh	uint32;
-	Unit		uint32;
-	_f		[8]int8;
+	Uptime    int32
+	Loads     [3]uint32
+	Totalram  uint32
+	Freeram   uint32
+	Sharedram uint32
+	Bufferram uint32
+	Totalswap uint32
+	Freeswap  uint32
+	Procs     uint16
+	Pad       uint16
+	Totalhigh uint32
+	Freehigh  uint32
+	Unit      uint32
+	_f        [8]int8
 }
 
 type Utsname struct {
-	Sysname		[65]int8;
-	Nodename	[65]int8;
-	Release		[65]int8;
-	Version		[65]int8;
-	Machine		[65]int8;
-	Domainname	[65]int8;
+	Sysname    [65]int8
+	Nodename   [65]int8
+	Release    [65]int8
+	Version    [65]int8
+	Machine    [65]int8
+	Domainname [65]int8
 }
 
 type Ustat_t struct {
-	Tfree	int32;
-	Tinode	uint32;
-	Fname	[6]int8;
-	Fpack	[6]int8;
+	Tfree  int32
+	Tinode uint32
+	Fname  [6]int8
+	Fpack  [6]int8
 }
 
 type EpollEvent struct {
-	Events	uint32;
-	Fd	int32;
-	Pad	int32;
+	Events uint32
+	Fd     int32
+	Pad    int32
 }
diff --git a/src/pkg/syscall/ztypes_nacl_386.go b/src/pkg/syscall/ztypes_nacl_386.go
index 27bcc43bf9..524a196f97 100644
--- a/src/pkg/syscall/ztypes_nacl_386.go
+++ b/src/pkg/syscall/ztypes_nacl_386.go
@@ -6,51 +6,51 @@ package syscall
 
 // Constants
 const (
-	sizeofPtr	= 0x4;
-	sizeofShort	= 0x2;
-	sizeofInt	= 0x4;
-	sizeofLong	= 0x4;
-	sizeofLongLong	= 0x8;
-	PROT_READ	= 0x1;
-	PROT_WRITE	= 0x2;
-	MAP_SHARED	= 0x1;
-	SYS_FORK	= 0;
-	SYS_PTRACE	= 0;
-	SYS_CHDIR	= 0;
-	SYS_DUP2	= 0;
-	SYS_FCNTL	= 0;
-	SYS_EXECVE	= 0;
-	O_RDONLY	= 0;
-	O_WRONLY	= 0x1;
-	O_RDWR		= 0x2;
-	O_APPEND	= 0x400;
-	O_ASYNC		= 0x2000;
-	O_CREAT		= 0x40;
-	O_NOCTTY	= 0;
-	O_NONBLOCK	= 0x800;
-	O_SYNC		= 0x1000;
-	O_TRUNC		= 0x200;
-	O_CLOEXEC	= 0;
-	O_EXCL		= 0;
-	F_GETFD		= 0x1;
-	F_SETFD		= 0x2;
-	F_GETFL		= 0x3;
-	F_SETFL		= 0x4;
-	FD_CLOEXEC	= 0;
-	S_IFMT		= 0x1f000;
-	S_IFIFO		= 0x1000;
-	S_IFCHR		= 0x2000;
-	S_IFDIR		= 0x4000;
-	S_IFBLK		= 0x6000;
-	S_IFREG		= 0x8000;
-	S_IFLNK		= 0xa000;
-	S_IFSOCK	= 0xc000;
-	S_ISUID		= 0x800;
-	S_ISGID		= 0x400;
-	S_ISVTX		= 0x200;
-	S_IRUSR		= 0x100;
-	S_IWUSR		= 0x80;
-	S_IXUSR		= 0x40;
+	sizeofPtr      = 0x4
+	sizeofShort    = 0x2
+	sizeofInt      = 0x4
+	sizeofLong     = 0x4
+	sizeofLongLong = 0x8
+	PROT_READ      = 0x1
+	PROT_WRITE     = 0x2
+	MAP_SHARED     = 0x1
+	SYS_FORK       = 0
+	SYS_PTRACE     = 0
+	SYS_CHDIR      = 0
+	SYS_DUP2       = 0
+	SYS_FCNTL      = 0
+	SYS_EXECVE     = 0
+	O_RDONLY       = 0
+	O_WRONLY       = 0x1
+	O_RDWR         = 0x2
+	O_APPEND       = 0x400
+	O_ASYNC        = 0x2000
+	O_CREAT        = 0x40
+	O_NOCTTY       = 0
+	O_NONBLOCK     = 0x800
+	O_SYNC         = 0x1000
+	O_TRUNC        = 0x200
+	O_CLOEXEC      = 0
+	O_EXCL         = 0
+	F_GETFD        = 0x1
+	F_SETFD        = 0x2
+	F_GETFL        = 0x3
+	F_SETFL        = 0x4
+	FD_CLOEXEC     = 0
+	S_IFMT         = 0x1f000
+	S_IFIFO        = 0x1000
+	S_IFCHR        = 0x2000
+	S_IFDIR        = 0x4000
+	S_IFBLK        = 0x6000
+	S_IFREG        = 0x8000
+	S_IFLNK        = 0xa000
+	S_IFSOCK       = 0xc000
+	S_ISUID        = 0x800
+	S_ISGID        = 0x400
+	S_ISVTX        = 0x200
+	S_IRUSR        = 0x100
+	S_IWUSR        = 0x80
+	S_IXUSR        = 0x40
 )
 
 // Types
@@ -66,13 +66,13 @@ type _C_long_long int64
 type _C_off_t int32
 
 type Timespec struct {
-	Sec	int32;
-	Nsec	int32;
+	Sec  int32
+	Nsec int32
 }
 
 type Timeval struct {
-	Sec	int32;
-	Usec	int32;
+	Sec  int32
+	Usec int32
 }
 
 type Time_t int32
@@ -80,26 +80,26 @@ type Time_t int32
 type _Gid_t uint32
 
 type Stat_t struct {
-	Dev		int64;
-	Ino		uint32;
-	Mode		uint32;
-	Nlink		uint32;
-	Uid		uint32;
-	Gid		uint32;
-	__padding	int32;
-	Rdev		int64;
-	Size		int32;
-	Blksize		int32;
-	Blocks		int32;
-	Atime		int32;
-	Mtime		int32;
-	Ctime		int32;
+	Dev       int64
+	Ino       uint32
+	Mode      uint32
+	Nlink     uint32
+	Uid       uint32
+	Gid       uint32
+	__padding int32
+	Rdev      int64
+	Size      int32
+	Blksize   int32
+	Blocks    int32
+	Atime     int32
+	Mtime     int32
+	Ctime     int32
 }
 
 type Dirent struct {
-	Ino	uint32;
-	Off	int32;
-	Reclen	uint16;
-	Name	[256]int8;
-	Pad0	[2]byte;
+	Ino    uint32
+	Off    int32
+	Reclen uint16
+	Name   [256]int8
+	Pad0   [2]byte
 }
