commit b5a9459cd08ec2a74ee4fdabfa4bc1eba0e87e49
Author: Nigel Tao <nigeltao@golang.org>
Date:   Fri Aug 19 16:39:38 2022 +1000

    image/png: have DecodeConfig read tRNS chunks
    
    Fixes #54325
    
    Change-Id: Ie468180c4d6f21db7672dd71bd2a40f3a5881b7d
    Reviewed-on: https://go-review.googlesource.com/c/go/+/424917
    Reviewed-by: Dmitri Shuralyov <dmitshur@golang.org>
    Reviewed-by: Nigel Tao (INACTIVE; USE @golang.org INSTEAD) <nigeltao@google.com>
    Reviewed-by: Dmitri Shuralyov <dmitshur@google.com>
---
 src/image/png/reader.go      | 26 ++++++++++++++--------
 src/image/png/reader_test.go | 53 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 70 insertions(+), 9 deletions(-)

diff --git a/src/image/png/reader.go b/src/image/png/reader.go
index 95b507cf68..b608bec2ef 100644
--- a/src/image/png/reader.go
+++ b/src/image/png/reader.go
@@ -870,7 +870,7 @@ func (d *decoder) parseIEND(length uint32) error {
 	return d.verifyChecksum()
 }
 
-func (d *decoder) parseChunk() error {
+func (d *decoder) parseChunk(configOnly bool) error {
 	// Read the length and chunk type.
 	if _, err := io.ReadFull(d.r, d.tmp[:8]); err != nil {
 		return err
@@ -915,6 +915,9 @@ func (d *decoder) parseChunk() error {
 			break
 		}
 		d.stage = dsSeenIDAT
+		if configOnly {
+			return nil
+		}
 		return d.parseIDAT(length)
 	case "IEND":
 		if d.stage != dsSeenIDAT {
@@ -974,7 +977,7 @@ func Decode(r io.Reader) (image.Image, error) {
 		return nil, err
 	}
 	for d.stage != dsSeenIEND {
-		if err := d.parseChunk(); err != nil {
+		if err := d.parseChunk(false); err != nil {
 			if err == io.EOF {
 				err = io.ErrUnexpectedEOF
 			}
@@ -997,21 +1000,26 @@ func DecodeConfig(r io.Reader) (image.Config, error) {
 		}
 		return image.Config{}, err
 	}
+
 	for {
-		if err := d.parseChunk(); err != nil {
+		if err := d.parseChunk(true); err != nil {
 			if err == io.EOF {
 				err = io.ErrUnexpectedEOF
 			}
 			return image.Config{}, err
 		}
-		paletted := cbPaletted(d.cb)
-		if d.stage == dsSeenIHDR && !paletted {
-			break
-		}
-		if d.stage == dsSeenPLTE && paletted {
-			break
+
+		if cbPaletted(d.cb) {
+			if d.stage >= dsSeentRNS {
+				break
+			}
+		} else {
+			if d.stage >= dsSeenIHDR {
+				break
+			}
 		}
 	}
+
 	var cm color.Model
 	switch d.cb {
 	case cbG1, cbG2, cbG4, cbG8:
diff --git a/src/image/png/reader_test.go b/src/image/png/reader_test.go
index 3937685294..ccf30b2c6e 100644
--- a/src/image/png/reader_test.go
+++ b/src/image/png/reader_test.go
@@ -783,6 +783,59 @@ func TestDimensionOverflow(t *testing.T) {
 	}
 }
 
+func TestDecodePalettedWithTransparency(t *testing.T) {
+	// These bytes come from https://go.dev/issue/54325
+	//
+	// Per the PNG spec, a PLTE chunk contains 3 (not 4) bytes per palette
+	// entry: RGB (not RGBA). The alpha value comes from the optional tRNS
+	// chunk. Here, the PLTE chunk (0x50, 0x4c, 0x54, 0x45, etc) has 16 entries
+	// (0x30 = 48 bytes) and the tRNS chunk (0x74, 0x52, 0x4e, 0x53, etc) has 1
+	// entry (0x01 = 1 byte) that sets the first palette entry's alpha to zero.
+	//
+	// Both Decode and DecodeConfig should pick up that the first palette
+	// entry's alpha is zero.
+	src := []byte{
+		0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
+		0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x20, 0x04, 0x03, 0x00, 0x00, 0x00, 0x81, 0x54, 0x67,
+		0xc7, 0x00, 0x00, 0x00, 0x30, 0x50, 0x4c, 0x54, 0x45, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0e,
+		0x00, 0x23, 0x27, 0x7b, 0xb1, 0x2d, 0x0a, 0x49, 0x3f, 0x19, 0x78, 0x5f, 0xcd, 0xe4, 0x69, 0x69,
+		0xe4, 0x71, 0x59, 0x53, 0x80, 0x11, 0x14, 0x8b, 0x00, 0xa9, 0x8d, 0x95, 0xcb, 0x99, 0x2f, 0x6b,
+		0xd7, 0x29, 0x91, 0xd7, 0x7b, 0xba, 0xff, 0xe3, 0xd7, 0x13, 0xc6, 0xd3, 0x58, 0x00, 0x00, 0x00,
+		0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 0x00, 0xfd, 0x49, 0x44,
+		0x41, 0x54, 0x28, 0xcf, 0x63, 0x60, 0x00, 0x83, 0x55, 0x0c, 0x68, 0x60, 0x9d, 0x02, 0x9a, 0x80,
+		0xde, 0x23, 0x74, 0x15, 0xef, 0x50, 0x94, 0x70, 0x2d, 0xd2, 0x7b, 0x87, 0xa2, 0x84, 0xeb, 0xee,
+		0xbb, 0x77, 0x6f, 0x51, 0x94, 0xe8, 0xbd, 0x7d, 0xf7, 0xee, 0x12, 0xb2, 0x80, 0xd2, 0x3d, 0x54,
+		0x01, 0x26, 0x10, 0x1f, 0x59, 0x40, 0x0f, 0xc8, 0xd7, 0x7e, 0x84, 0x70, 0x1c, 0xd7, 0xba, 0xb7,
+		0x4a, 0xda, 0xda, 0x77, 0x11, 0xf6, 0xac, 0x5a, 0xa5, 0xf4, 0xf9, 0xbf, 0xfd, 0x3d, 0x24, 0x6b,
+		0x98, 0x94, 0xf4, 0xff, 0x7f, 0x52, 0x42, 0x16, 0x30, 0x0e, 0xd9, 0xed, 0x6a, 0x8c, 0xec, 0x10,
+		0x65, 0x53, 0x97, 0x60, 0x23, 0x64, 0x1d, 0x8a, 0x2e, 0xc6, 0x2e, 0x42, 0x08, 0x3d, 0x4c, 0xca,
+		0x81, 0xc1, 0x82, 0xa6, 0xa2, 0x46, 0x08, 0x3d, 0x4a, 0xa1, 0x82, 0xc6, 0x82, 0xa1, 0x4a, 0x08,
+		0x3d, 0xfa, 0xa6, 0x81, 0xa1, 0xa2, 0xc1, 0x9f, 0x10, 0x66, 0xd4, 0x2b, 0x87, 0x0a, 0x86, 0x1a,
+		0x7d, 0x57, 0x80, 0x9b, 0x99, 0xaf, 0x62, 0x1a, 0x1a, 0xec, 0xf0, 0x0d, 0x66, 0x2a, 0x7b, 0x5a,
+		0xba, 0xd2, 0x64, 0x63, 0x4b, 0xa6, 0xb2, 0xb4, 0x02, 0xa8, 0x12, 0xb5, 0x24, 0xa5, 0x99, 0x2e,
+		0x33, 0x95, 0xd4, 0x92, 0x10, 0xee, 0xd0, 0x59, 0xb9, 0x6a, 0xd6, 0x21, 0x24, 0xb7, 0x33, 0x9d,
+		0x01, 0x01, 0x64, 0xbf, 0xac, 0x59, 0xb2, 0xca, 0xeb, 0x14, 0x92, 0x80, 0xd6, 0x9a, 0x53, 0x4a,
+		0x6b, 0x4e, 0x2d, 0x42, 0x52, 0xa1, 0x73, 0x28, 0x54, 0xe7, 0x90, 0x6a, 0x00, 0x92, 0x92, 0x45,
+		0xa1, 0x40, 0x84, 0x2c, 0xe0, 0xc4, 0xa0, 0xb2, 0x28, 0x14, 0xc1, 0x67, 0xe9, 0x50, 0x60, 0x60,
+		0xea, 0x70, 0x40, 0x12, 0x00, 0x79, 0x54, 0x09, 0x22, 0x00, 0x00, 0x30, 0xf3, 0x52, 0x87, 0xc6,
+		0xe4, 0xbd, 0x70, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82,
+	}
+
+	cfg, err := DecodeConfig(bytes.NewReader(src))
+	if err != nil {
+		t.Fatalf("DecodeConfig: %v", err)
+	} else if _, _, _, alpha := cfg.ColorModel.(color.Palette)[0].RGBA(); alpha != 0 {
+		t.Errorf("DecodeConfig: got %d, want 0", alpha)
+	}
+
+	img, err := Decode(bytes.NewReader(src))
+	if err != nil {
+		t.Fatalf("Decode: %v", err)
+	} else if _, _, _, alpha := img.ColorModel().(color.Palette)[0].RGBA(); alpha != 0 {
+		t.Errorf("Decode: got %d, want 0", alpha)
+	}
+}
+
 func benchmarkDecode(b *testing.B, filename string, bytesPerPixel int) {
 	data, err := os.ReadFile(filename)
 	if err != nil {
