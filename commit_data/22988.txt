commit 17228f44b223c146714040143baa336f4a1d3021
Author: Russ Cox <rsc@golang.org>
Date:   Fri Apr 17 12:03:22 2015 -0400

    cmd/internal/gc: make use of new String methods in prints
    
    $ sam -d cmd/internal/gc/*.{go,y} cmd/?g/*.go
    X ,s/, (gc\.)?[BFHNST]conv\(([^()]+), 0\)/, \2/g
    X/'/w
    q
    $
    
    Change-Id: Ic28a4807d237b8ae53ceca1e4e7fdb43580ab560
    Reviewed-on: https://go-review.googlesource.com/9032
    Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org>
    Reviewed-by: Austin Clements <austin@google.com>
---
 src/cmd/5g/cgen.go               |   4 +-
 src/cmd/5g/cgen64.go             |   4 +-
 src/cmd/5g/ggen.go               |   4 +-
 src/cmd/5g/gsubr.go              |   8 +-
 src/cmd/6g/gsubr.go              |   4 +-
 src/cmd/7g/cgen.go               |   4 +-
 src/cmd/7g/ggen.go               |   4 +-
 src/cmd/7g/gsubr.go              |   2 +-
 src/cmd/8g/cgen64.go             |   2 +-
 src/cmd/8g/ggen.go               |   4 +-
 src/cmd/8g/gsubr.go              |  20 ++--
 src/cmd/9g/cgen.go               |   4 +-
 src/cmd/9g/ggen.go               |   4 +-
 src/cmd/9g/gsubr.go              |   4 +-
 src/cmd/internal/gc/align.go     |  18 +--
 src/cmd/internal/gc/cgen.go      |   4 +-
 src/cmd/internal/gc/closure.go   |   4 +-
 src/cmd/internal/gc/const.go     |  26 ++---
 src/cmd/internal/gc/cplx.go      |   4 +-
 src/cmd/internal/gc/dcl.go       |  54 ++++-----
 src/cmd/internal/gc/esc.go       |  22 ++--
 src/cmd/internal/gc/export.go    |  36 +++---
 src/cmd/internal/gc/fmt.go       | 198 ++++++++++++++++----------------
 src/cmd/internal/gc/gen.go       |  28 ++---
 src/cmd/internal/gc/go.y         |   8 +-
 src/cmd/internal/gc/gsubr.go     |  10 +-
 src/cmd/internal/gc/inl.go       |  20 ++--
 src/cmd/internal/gc/lex.go       |   2 +-
 src/cmd/internal/gc/mparith3.go  |  18 +--
 src/cmd/internal/gc/obj.go       |   4 +-
 src/cmd/internal/gc/order.go     |   6 +-
 src/cmd/internal/gc/pgen.go      |   2 +-
 src/cmd/internal/gc/plive.go     |  34 +++---
 src/cmd/internal/gc/popt.go      |  14 +--
 src/cmd/internal/gc/racewalk.go  |   6 +-
 src/cmd/internal/gc/range.go     |   6 +-
 src/cmd/internal/gc/reflect.go   |  18 +--
 src/cmd/internal/gc/reg.go       |   4 +-
 src/cmd/internal/gc/sinit.go     |  22 ++--
 src/cmd/internal/gc/subr.go      |  86 +++++++-------
 src/cmd/internal/gc/swt.go       |  18 +--
 src/cmd/internal/gc/typecheck.go | 242 +++++++++++++++++++--------------------
 src/cmd/internal/gc/unsafe.go    |  10 +-
 src/cmd/internal/gc/walk.go      |  36 +++---
 src/cmd/internal/gc/y.go         |   8 +-
 45 files changed, 520 insertions(+), 520 deletions(-)

diff --git a/src/cmd/5g/cgen.go b/src/cmd/5g/cgen.go
index a2e81f1f6b..a79c55fd49 100644
--- a/src/cmd/5g/cgen.go
+++ b/src/cmd/5g/cgen.go
@@ -85,7 +85,7 @@ func stackcopy(n, res *gc.Node, osrc, odst, w int64) {
 	var op int
 	switch align {
 	default:
-		gc.Fatal("sgen: invalid alignment %d for %v", align, gc.Tconv(n.Type, 0))
+		gc.Fatal("sgen: invalid alignment %d for %v", align, n.Type)
 
 	case 1:
 		op = arm.AMOVB
@@ -98,7 +98,7 @@ func stackcopy(n, res *gc.Node, osrc, odst, w int64) {
 	}
 
 	if w%int64(align) != 0 {
-		gc.Fatal("sgen: unaligned size %d (align=%d) for %v", w, align, gc.Tconv(n.Type, 0))
+		gc.Fatal("sgen: unaligned size %d (align=%d) for %v", w, align, n.Type)
 	}
 	c := int32(w / int64(align))
 
diff --git a/src/cmd/5g/cgen64.go b/src/cmd/5g/cgen64.go
index 414ff0a164..699e555f71 100644
--- a/src/cmd/5g/cgen64.go
+++ b/src/cmd/5g/cgen64.go
@@ -129,7 +129,7 @@ func cgen64(n *gc.Node, res *gc.Node) {
 	// Do op.  Leave result in ah:al.
 	switch n.Op {
 	default:
-		gc.Fatal("cgen64: not implemented: %v\n", gc.Nconv(n, 0))
+		gc.Fatal("cgen64: not implemented: %v\n", n)
 
 		// TODO: Constants
 	case gc.OADD:
@@ -793,7 +793,7 @@ func cmp64(nl *gc.Node, nr *gc.Node, op int, likely int, to *obj.Prog) {
 	var br *obj.Prog
 	switch op {
 	default:
-		gc.Fatal("cmp64 %v %v", gc.Oconv(int(op), 0), gc.Tconv(t, 0))
+		gc.Fatal("cmp64 %v %v", gc.Oconv(int(op), 0), t)
 
 		// cmp hi
 	// bne L
diff --git a/src/cmd/5g/ggen.go b/src/cmd/5g/ggen.go
index 65b0a2022d..0cf0d9299c 100644
--- a/src/cmd/5g/ggen.go
+++ b/src/cmd/5g/ggen.go
@@ -162,7 +162,7 @@ func cgen_hmul(nl *gc.Node, nr *gc.Node, res *gc.Node) {
 		p.To.Offset = int64(n2.Reg)
 
 	default:
-		gc.Fatal("cgen_hmul %v", gc.Tconv(t, 0))
+		gc.Fatal("cgen_hmul %v", t)
 	}
 
 	gc.Cgen(&n1, res)
@@ -177,7 +177,7 @@ func cgen_hmul(nl *gc.Node, nr *gc.Node, res *gc.Node) {
  */
 func cgen_shift(op int, bounded bool, nl *gc.Node, nr *gc.Node, res *gc.Node) {
 	if nl.Type.Width > 4 {
-		gc.Fatal("cgen_shift %v", gc.Tconv(nl.Type, 0))
+		gc.Fatal("cgen_shift %v", nl.Type)
 	}
 
 	w := int(nl.Type.Width * 8)
diff --git a/src/cmd/5g/gsubr.go b/src/cmd/5g/gsubr.go
index 533b7bf0ee..57d511e6f6 100644
--- a/src/cmd/5g/gsubr.go
+++ b/src/cmd/5g/gsubr.go
@@ -66,7 +66,7 @@ var nsclean int
  */
 func split64(n *gc.Node, lo *gc.Node, hi *gc.Node) {
 	if !gc.Is64(n.Type) {
-		gc.Fatal("split64 %v", gc.Tconv(n.Type, 0))
+		gc.Fatal("split64 %v", n.Type)
 	}
 
 	if nsclean >= len(sclean) {
@@ -135,7 +135,7 @@ func splitclean() {
 
 func gmove(f *gc.Node, t *gc.Node) {
 	if gc.Debug['M'] != 0 {
-		fmt.Printf("gmove %v -> %v\n", gc.Nconv(f, 0), gc.Nconv(t, 0))
+		fmt.Printf("gmove %v -> %v\n", f, t)
 	}
 
 	ft := gc.Simsimtype(f.Type)
@@ -204,7 +204,7 @@ func gmove(f *gc.Node, t *gc.Node) {
 	switch uint32(ft)<<16 | uint32(tt) {
 	default:
 		// should not happen
-		gc.Fatal("gmove %v -> %v", gc.Nconv(f, 0), gc.Nconv(t, 0))
+		gc.Fatal("gmove %v -> %v", f, t)
 		return
 
 		/*
@@ -765,7 +765,7 @@ func optoas(op int, t *gc.Type) int {
 	a := obj.AXXX
 	switch uint32(op)<<16 | uint32(gc.Simtype[t.Etype]) {
 	default:
-		gc.Fatal("optoas: no entry %v-%v etype %v simtype %v", gc.Oconv(int(op), 0), gc.Tconv(t, 0), gc.Tconv(gc.Types[t.Etype], 0), gc.Tconv(gc.Types[gc.Simtype[t.Etype]], 0))
+		gc.Fatal("optoas: no entry %v-%v etype %v simtype %v", gc.Oconv(int(op), 0), t, gc.Types[t.Etype], gc.Types[gc.Simtype[t.Etype]])
 
 		/*	case CASE(OADDR, TPTR32):
 				a = ALEAL;
diff --git a/src/cmd/6g/gsubr.go b/src/cmd/6g/gsubr.go
index 824da47c1a..0ac103e853 100644
--- a/src/cmd/6g/gsubr.go
+++ b/src/cmd/6g/gsubr.go
@@ -585,7 +585,7 @@ func gins(as int, f *gc.Node, t *gc.Node) *obj.Prog {
 
 	case x86.ALEAQ:
 		if f != nil && gc.Isconst(f, gc.CTNIL) {
-			gc.Fatal("gins LEAQ nil %v", gc.Tconv(f.Type, 0))
+			gc.Fatal("gins LEAQ nil %v", f.Type)
 		}
 	}
 
@@ -645,7 +645,7 @@ func optoas(op int, t *gc.Type) int {
 	a := obj.AXXX
 	switch uint32(op)<<16 | uint32(gc.Simtype[t.Etype]) {
 	default:
-		gc.Fatal("optoas: no entry %v-%v", gc.Oconv(int(op), 0), gc.Tconv(t, 0))
+		gc.Fatal("optoas: no entry %v-%v", gc.Oconv(int(op), 0), t)
 
 	case gc.OADDR<<16 | gc.TPTR32:
 		a = x86.ALEAL
diff --git a/src/cmd/7g/cgen.go b/src/cmd/7g/cgen.go
index 8d6dce41df..1d4f391d75 100644
--- a/src/cmd/7g/cgen.go
+++ b/src/cmd/7g/cgen.go
@@ -20,7 +20,7 @@ func stackcopy(n, res *gc.Node, osrc, odst, w int64) {
 	var op int
 	switch align {
 	default:
-		gc.Fatal("sgen: invalid alignment %d for %v", align, gc.Tconv(n.Type, 0))
+		gc.Fatal("sgen: invalid alignment %d for %v", align, n.Type)
 
 	case 1:
 		op = arm64.AMOVB
@@ -36,7 +36,7 @@ func stackcopy(n, res *gc.Node, osrc, odst, w int64) {
 	}
 
 	if w%int64(align) != 0 {
-		gc.Fatal("sgen: unaligned size %d (align=%d) for %v", w, align, gc.Tconv(n.Type, 0))
+		gc.Fatal("sgen: unaligned size %d (align=%d) for %v", w, align, n.Type)
 	}
 	c := int32(w / int64(align))
 
diff --git a/src/cmd/7g/ggen.go b/src/cmd/7g/ggen.go
index 9b3ffce38a..3b02b96e98 100644
--- a/src/cmd/7g/ggen.go
+++ b/src/cmd/7g/ggen.go
@@ -290,7 +290,7 @@ func cgen_hmul(nl *gc.Node, nr *gc.Node, res *gc.Node) {
 		}
 
 	default:
-		gc.Fatal("cgen_hmul %v", gc.Tconv(t, 0))
+		gc.Fatal("cgen_hmul %v", t)
 	}
 
 	gc.Cgen(&n1, res)
@@ -396,7 +396,7 @@ func cgen_shift(op int, bounded bool, nl *gc.Node, nr *gc.Node, res *gc.Node) {
 func clearfat(nl *gc.Node) {
 	/* clear a fat object */
 	if gc.Debug['g'] != 0 {
-		fmt.Printf("clearfat %v (%v, size: %d)\n", gc.Nconv(nl, 0), gc.Tconv(nl.Type, 0), nl.Type.Width)
+		fmt.Printf("clearfat %v (%v, size: %d)\n", nl, nl.Type, nl.Type.Width)
 	}
 
 	w := uint64(uint64(nl.Type.Width))
diff --git a/src/cmd/7g/gsubr.go b/src/cmd/7g/gsubr.go
index d2e83ad20d..23c6c0a6f0 100644
--- a/src/cmd/7g/gsubr.go
+++ b/src/cmd/7g/gsubr.go
@@ -602,7 +602,7 @@ func optoas(op int, t *gc.Type) int {
 	a := int(obj.AXXX)
 	switch uint32(op)<<16 | uint32(gc.Simtype[t.Etype]) {
 	default:
-		gc.Fatal("optoas: no entry for op=%v type=%v", gc.Oconv(int(op), 0), gc.Tconv(t, 0))
+		gc.Fatal("optoas: no entry for op=%v type=%v", gc.Oconv(int(op), 0), t)
 
 	case gc.OEQ<<16 | gc.TBOOL,
 		gc.OEQ<<16 | gc.TINT8,
diff --git a/src/cmd/8g/cgen64.go b/src/cmd/8g/cgen64.go
index 7fb6549689..a682e2fb44 100644
--- a/src/cmd/8g/cgen64.go
+++ b/src/cmd/8g/cgen64.go
@@ -532,7 +532,7 @@ func cmp64(nl *gc.Node, nr *gc.Node, op int, likely int, to *obj.Prog) {
 	var br *obj.Prog
 	switch op {
 	default:
-		gc.Fatal("cmp64 %v %v", gc.Oconv(int(op), 0), gc.Tconv(t, 0))
+		gc.Fatal("cmp64 %v %v", gc.Oconv(int(op), 0), t)
 
 		// cmp hi
 	// jne L
diff --git a/src/cmd/8g/ggen.go b/src/cmd/8g/ggen.go
index b9792d1993..21191edeb7 100644
--- a/src/cmd/8g/ggen.go
+++ b/src/cmd/8g/ggen.go
@@ -348,7 +348,7 @@ func restx(x *gc.Node, oldx *gc.Node) {
  */
 func cgen_div(op int, nl *gc.Node, nr *gc.Node, res *gc.Node) {
 	if gc.Is64(nl.Type) {
-		gc.Fatal("cgen_div %v", gc.Tconv(nl.Type, 0))
+		gc.Fatal("cgen_div %v", nl.Type)
 	}
 
 	var t *gc.Type
@@ -375,7 +375,7 @@ func cgen_div(op int, nl *gc.Node, nr *gc.Node, res *gc.Node) {
  */
 func cgen_shift(op int, bounded bool, nl *gc.Node, nr *gc.Node, res *gc.Node) {
 	if nl.Type.Width > 4 {
-		gc.Fatal("cgen_shift %v", gc.Tconv(nl.Type, 0))
+		gc.Fatal("cgen_shift %v", nl.Type)
 	}
 
 	w := int(nl.Type.Width * 8)
diff --git a/src/cmd/8g/gsubr.go b/src/cmd/8g/gsubr.go
index 334e99ea9d..a5ee8edb41 100644
--- a/src/cmd/8g/gsubr.go
+++ b/src/cmd/8g/gsubr.go
@@ -53,7 +53,7 @@ func optoas(op int, t *gc.Type) int {
 	a := obj.AXXX
 	switch uint32(op)<<16 | uint32(gc.Simtype[t.Etype]) {
 	default:
-		gc.Fatal("optoas: no entry %v-%v", gc.Oconv(int(op), 0), gc.Tconv(t, 0))
+		gc.Fatal("optoas: no entry %v-%v", gc.Oconv(int(op), 0), t)
 
 	case gc.OADDR<<16 | gc.TPTR32:
 		a = x86.ALEAL
@@ -405,7 +405,7 @@ func foptoas(op int, t *gc.Type, flg int) int {
 	if !gc.Thearch.Use387 {
 		switch uint32(op)<<16 | uint32(et) {
 		default:
-			gc.Fatal("foptoas-sse: no entry %v-%v", gc.Oconv(int(op), 0), gc.Tconv(t, 0))
+			gc.Fatal("foptoas-sse: no entry %v-%v", gc.Oconv(int(op), 0), t)
 
 		case gc.OCMP<<16 | gc.TFLOAT32:
 			a = x86.AUCOMISS
@@ -538,7 +538,7 @@ func foptoas(op int, t *gc.Type, flg int) int {
 		return x86.AFCHS
 	}
 
-	gc.Fatal("foptoas %v %v %#x", gc.Oconv(int(op), 0), gc.Tconv(t, 0), flg)
+	gc.Fatal("foptoas %v %v %#x", gc.Oconv(int(op), 0), t, flg)
 	return 0
 }
 
@@ -608,7 +608,7 @@ var nsclean int
  */
 func split64(n *gc.Node, lo *gc.Node, hi *gc.Node) {
 	if !gc.Is64(n.Type) {
-		gc.Fatal("split64 %v", gc.Tconv(n.Type, 0))
+		gc.Fatal("split64 %v", n.Type)
 	}
 
 	if nsclean >= len(sclean) {
@@ -715,7 +715,7 @@ func memname(n *gc.Node, t *gc.Type) {
 
 func gmove(f *gc.Node, t *gc.Node) {
 	if gc.Debug['M'] != 0 {
-		fmt.Printf("gmove %v -> %v\n", gc.Nconv(f, 0), gc.Nconv(t, 0))
+		fmt.Printf("gmove %v -> %v\n", f, t)
 	}
 
 	ft := gc.Simsimtype(f.Type)
@@ -758,7 +758,7 @@ func gmove(f *gc.Node, t *gc.Node) {
 	switch uint32(ft)<<16 | uint32(tt) {
 	default:
 		// should not happen
-		gc.Fatal("gmove %v -> %v", gc.Nconv(f, 0), gc.Nconv(t, 0))
+		gc.Fatal("gmove %v -> %v", f, t)
 		return
 
 		/*
@@ -1322,7 +1322,7 @@ func floatmove_387(f *gc.Node, t *gc.Node) {
 		gmove(f, &t1)
 		switch tt {
 		default:
-			gc.Fatal("gmove %v", gc.Nconv(t, 0))
+			gc.Fatal("gmove %v", t)
 
 		case gc.TINT8:
 			gins(x86.ACMPL, &t1, ncon(-0x80&(1<<32-1)))
@@ -1433,7 +1433,7 @@ func floatmove_387(f *gc.Node, t *gc.Node) {
 		}
 		if gc.Ismem(t) {
 			if f.Op != gc.OREGISTER || f.Reg != x86.REG_F0 {
-				gc.Fatal("gmove %v", gc.Nconv(f, 0))
+				gc.Fatal("gmove %v", f)
 			}
 			a = x86.AFMOVFP
 			if ft == gc.TFLOAT64 {
@@ -1517,7 +1517,7 @@ func floatmove_sse(f *gc.Node, t *gc.Node) {
 	switch uint32(ft)<<16 | uint32(tt) {
 	// should not happen
 	default:
-		gc.Fatal("gmove %v -> %v", gc.Nconv(f, 0), gc.Nconv(t, 0))
+		gc.Fatal("gmove %v -> %v", f, t)
 
 		return
 
@@ -1681,7 +1681,7 @@ func gins(as int, f *gc.Node, t *gc.Node) *obj.Prog {
 
 	case x86.ALEAL:
 		if f != nil && gc.Isconst(f, gc.CTNIL) {
-			gc.Fatal("gins LEAL nil %v", gc.Tconv(f.Type, 0))
+			gc.Fatal("gins LEAL nil %v", f.Type)
 		}
 	}
 
diff --git a/src/cmd/9g/cgen.go b/src/cmd/9g/cgen.go
index 0f7fc07a60..feadfeb9a9 100644
--- a/src/cmd/9g/cgen.go
+++ b/src/cmd/9g/cgen.go
@@ -20,7 +20,7 @@ func stackcopy(n, res *gc.Node, osrc, odst, w int64) {
 	var op int
 	switch align {
 	default:
-		gc.Fatal("sgen: invalid alignment %d for %v", align, gc.Tconv(n.Type, 0))
+		gc.Fatal("sgen: invalid alignment %d for %v", align, n.Type)
 
 	case 1:
 		op = ppc64.AMOVBU
@@ -36,7 +36,7 @@ func stackcopy(n, res *gc.Node, osrc, odst, w int64) {
 	}
 
 	if w%int64(align) != 0 {
-		gc.Fatal("sgen: unaligned size %d (align=%d) for %v", w, align, gc.Tconv(n.Type, 0))
+		gc.Fatal("sgen: unaligned size %d (align=%d) for %v", w, align, n.Type)
 	}
 	c := int32(w / int64(align))
 
diff --git a/src/cmd/9g/ggen.go b/src/cmd/9g/ggen.go
index 769cab3fcf..28ebd9cc01 100644
--- a/src/cmd/9g/ggen.go
+++ b/src/cmd/9g/ggen.go
@@ -288,7 +288,7 @@ func cgen_hmul(nl *gc.Node, nr *gc.Node, res *gc.Node) {
 		}
 
 	default:
-		gc.Fatal("cgen_hmul %v", gc.Tconv(t, 0))
+		gc.Fatal("cgen_hmul %v", t)
 	}
 
 	gc.Cgen(&n1, res)
@@ -394,7 +394,7 @@ func cgen_shift(op int, bounded bool, nl *gc.Node, nr *gc.Node, res *gc.Node) {
 func clearfat(nl *gc.Node) {
 	/* clear a fat object */
 	if gc.Debug['g'] != 0 {
-		fmt.Printf("clearfat %v (%v, size: %d)\n", gc.Nconv(nl, 0), gc.Tconv(nl.Type, 0), nl.Type.Width)
+		fmt.Printf("clearfat %v (%v, size: %d)\n", nl, nl.Type, nl.Type.Width)
 	}
 
 	w := uint64(uint64(nl.Type.Width))
diff --git a/src/cmd/9g/gsubr.go b/src/cmd/9g/gsubr.go
index df2b4aac9a..3b0e090e07 100644
--- a/src/cmd/9g/gsubr.go
+++ b/src/cmd/9g/gsubr.go
@@ -651,7 +651,7 @@ func fixlargeoffset(n *gc.Node) {
 	if n.Xoffset != int64(int32(n.Xoffset)) {
 		// TODO(minux): offset too large, move into R31 and add to R31 instead.
 		// this is used only in test/fixedbugs/issue6036.go.
-		gc.Fatal("offset too large: %v", gc.Nconv(n, 0))
+		gc.Fatal("offset too large: %v", n)
 
 		a := gc.Node(*n)
 		a.Op = gc.OREGISTER
@@ -674,7 +674,7 @@ func optoas(op int, t *gc.Type) int {
 	a := int(obj.AXXX)
 	switch uint32(op)<<16 | uint32(gc.Simtype[t.Etype]) {
 	default:
-		gc.Fatal("optoas: no entry for op=%v type=%v", gc.Oconv(int(op), 0), gc.Tconv(t, 0))
+		gc.Fatal("optoas: no entry for op=%v type=%v", gc.Oconv(int(op), 0), t)
 
 	case gc.OEQ<<16 | gc.TBOOL,
 		gc.OEQ<<16 | gc.TINT8,
diff --git a/src/cmd/internal/gc/align.go b/src/cmd/internal/gc/align.go
index bb15bea60c..954e599021 100644
--- a/src/cmd/internal/gc/align.go
+++ b/src/cmd/internal/gc/align.go
@@ -127,7 +127,7 @@ func dowidth(t *Type) {
 		lineno = int32(t.Lineno)
 		if t.Broke == 0 {
 			t.Broke = 1
-			Yyerror("invalid recursive type %v", Tconv(t, 0))
+			Yyerror("invalid recursive type %v", t)
 		}
 
 		t.Width = 0
@@ -164,7 +164,7 @@ func dowidth(t *Type) {
 	w := int64(0)
 	switch et {
 	default:
-		Fatal("dowidth: unknown type: %v", Tconv(t, 0))
+		Fatal("dowidth: unknown type: %v", t)
 
 		/* compiler-specific stuff */
 	case TINT8, TUINT8, TBOOL:
@@ -230,7 +230,7 @@ func dowidth(t *Type) {
 
 	case TFORW: // should have been filled in
 		if t.Broke == 0 {
-			Yyerror("invalid recursive type %v", Tconv(t, 0))
+			Yyerror("invalid recursive type %v", t)
 		}
 		w = 1 // anything will do
 
@@ -273,12 +273,12 @@ func dowidth(t *Type) {
 				t.Broke = 1
 			}
 		} else {
-			Fatal("dowidth %v", Tconv(t, 0)) // probably [...]T
+			Fatal("dowidth %v", t) // probably [...]T
 		}
 
 	case TSTRUCT:
 		if t.Funarg != 0 {
-			Fatal("dowidth fn struct %v", Tconv(t, 0))
+			Fatal("dowidth fn struct %v", t)
 		}
 		w = widstruct(t, t, 0, 1)
 
@@ -303,19 +303,19 @@ func dowidth(t *Type) {
 		w = widstruct(t.Type, *Getoutarg(t1), w, Widthreg)
 		t1.Argwid = w
 		if w%int64(Widthreg) != 0 {
-			Warn("bad type %v %d\n", Tconv(t1, 0), w)
+			Warn("bad type %v %d\n", t1, w)
 		}
 		t.Align = 1
 	}
 
 	if Widthptr == 4 && w != int64(int32(w)) {
-		Yyerror("type %v too large", Tconv(t, 0))
+		Yyerror("type %v too large", t)
 	}
 
 	t.Width = w
 	if t.Align == 0 {
 		if w > 8 || w&(w-1) != 0 {
-			Fatal("invalid alignment for %v", Tconv(t, 0))
+			Fatal("invalid alignment for %v", t)
 		}
 		t.Align = uint8(w)
 	}
@@ -363,7 +363,7 @@ func checkwidth(t *Type) {
 	// function arg structs should not be checked
 	// outside of the enclosing function.
 	if t.Funarg != 0 {
-		Fatal("checkwidth %v", Tconv(t, 0))
+		Fatal("checkwidth %v", t)
 	}
 
 	if defercalc == 0 {
diff --git a/src/cmd/internal/gc/cgen.go b/src/cmd/internal/gc/cgen.go
index 8c7cb0eb88..3a3a4c6076 100644
--- a/src/cmd/internal/gc/cgen.go
+++ b/src/cmd/internal/gc/cgen.go
@@ -75,7 +75,7 @@ func Cgen(n *Node, res *Node) {
 
 	if Isfat(n.Type) {
 		if n.Type.Width < 0 {
-			Fatal("forgot to compute width for %v", Tconv(n.Type, 0))
+			Fatal("forgot to compute width for %v", n.Type)
 		}
 		sgen(n, res, n.Type.Width)
 		return
@@ -1659,7 +1659,7 @@ func Bgen(n *Node, wantTrue bool, likely int, to *obj.Prog) {
 	}
 
 	if n.Type.Etype != TBOOL {
-		Yyerror("cgen: bad type %v for %v", Tconv(n.Type, 0), Oconv(int(n.Op), 0))
+		Yyerror("cgen: bad type %v for %v", n.Type, Oconv(int(n.Op), 0))
 		Patch(Thearch.Gins(obj.AEND, nil, nil), to)
 		return
 	}
diff --git a/src/cmd/internal/gc/closure.go b/src/cmd/internal/gc/closure.go
index 62e060e7d4..8d5fd5a600 100644
--- a/src/cmd/internal/gc/closure.go
+++ b/src/cmd/internal/gc/closure.go
@@ -269,7 +269,7 @@ func capturevars(xfunc *Node) {
 			if v.Byval {
 				how = "value"
 			}
-			Warnl(int(v.Lineno), "%v capturing by %s: %v (addr=%v assign=%v width=%d)", Sconv(name, 0), how, Sconv(v.Sym, 0), v.Closure.Addrtaken, v.Closure.Assigned, int32(v.Type.Width))
+			Warnl(int(v.Lineno), "%v capturing by %s: %v (addr=%v assign=%v width=%d)", name, how, v.Sym, v.Closure.Addrtaken, v.Closure.Assigned, int32(v.Type.Width))
 		}
 
 		typecheck(&outer, Erv)
@@ -517,7 +517,7 @@ func makepartialcall(fn *Node, t0 *Type, meth *Node) *Node {
 		basetype = basetype.Type
 	}
 	if basetype.Etype != TINTER && basetype.Sym == nil {
-		Fatal("missing base type for %v", Tconv(rcvrtype, 0))
+		Fatal("missing base type for %v", rcvrtype)
 	}
 
 	var spkg *Pkg
diff --git a/src/cmd/internal/gc/const.go b/src/cmd/internal/gc/const.go
index 5d44c552cf..ab526f5258 100644
--- a/src/cmd/internal/gc/const.go
+++ b/src/cmd/internal/gc/const.go
@@ -103,7 +103,7 @@ func convlit1(np **Node, t *Type, explicit bool) {
 			n.Val = toint(n.Val)
 		}
 		if t != nil && !Isint[t.Etype] {
-			Yyerror("invalid operation: %v (shift of type %v)", Nconv(n, 0), Tconv(t, 0))
+			Yyerror("invalid operation: %v (shift of type %v)", n, t)
 			t = nil
 		}
 
@@ -255,7 +255,7 @@ func convlit1(np **Node, t *Type, explicit bool) {
 bad:
 	if n.Diag == 0 {
 		if t.Broke == 0 {
-			Yyerror("cannot convert %v to type %v", Nconv(n, 0), Tconv(t, 0))
+			Yyerror("cannot convert %v to type %v", n, t)
 		}
 		n.Diag = 1
 	}
@@ -363,7 +363,7 @@ func doesoverflow(v Val, t *Type) bool {
 	switch v.Ctype {
 	case CTINT, CTRUNE:
 		if !Isint[t.Etype] {
-			Fatal("overflow: %v integer constant", Tconv(t, 0))
+			Fatal("overflow: %v integer constant", t)
 		}
 		if Mpcmpfixfix(v.U.Xval, Minintval[t.Etype]) < 0 || Mpcmpfixfix(v.U.Xval, Maxintval[t.Etype]) > 0 {
 			return true
@@ -371,7 +371,7 @@ func doesoverflow(v Val, t *Type) bool {
 
 	case CTFLT:
 		if !Isfloat[t.Etype] {
-			Fatal("overflow: %v floating-point constant", Tconv(t, 0))
+			Fatal("overflow: %v floating-point constant", t)
 		}
 		if mpcmpfltflt(v.U.Fval, minfltval[t.Etype]) <= 0 || mpcmpfltflt(v.U.Fval, maxfltval[t.Etype]) >= 0 {
 			return true
@@ -379,7 +379,7 @@ func doesoverflow(v Val, t *Type) bool {
 
 	case CTCPLX:
 		if !Iscomplex[t.Etype] {
-			Fatal("overflow: %v complex constant", Tconv(t, 0))
+			Fatal("overflow: %v complex constant", t)
 		}
 		if mpcmpfltflt(&v.U.Cval.Real, minfltval[t.Etype]) <= 0 || mpcmpfltflt(&v.U.Cval.Real, maxfltval[t.Etype]) >= 0 || mpcmpfltflt(&v.U.Cval.Imag, minfltval[t.Etype]) <= 0 || mpcmpfltflt(&v.U.Cval.Imag, maxfltval[t.Etype]) >= 0 {
 			return true
@@ -402,13 +402,13 @@ func overflow(v Val, t *Type) {
 
 	switch v.Ctype {
 	case CTINT, CTRUNE:
-		Yyerror("constant %v overflows %v", Bconv(v.U.Xval, 0), Tconv(t, 0))
+		Yyerror("constant %v overflows %v", v.U.Xval, t)
 
 	case CTFLT:
-		Yyerror("constant %v overflows %v", Fconv(v.U.Fval, obj.FmtSharp), Tconv(t, 0))
+		Yyerror("constant %v overflows %v", Fconv(v.U.Fval, obj.FmtSharp), t)
 
 	case CTCPLX:
-		Yyerror("constant %v overflows %v", Fconv(v.U.Fval, obj.FmtSharp), Tconv(t, 0))
+		Yyerror("constant %v overflows %v", Fconv(v.U.Fval, obj.FmtSharp), t)
 	}
 }
 
@@ -577,7 +577,7 @@ func evconst(n *Node) {
 		switch uint32(n.Op)<<16 | uint32(v.Ctype) {
 		default:
 			if n.Diag == 0 {
-				Yyerror("illegal constant expression %v %v", Oconv(int(n.Op), 0), Tconv(nl.Type, 0))
+				Yyerror("illegal constant expression %v %v", Oconv(int(n.Op), 0), nl.Type)
 				n.Diag = 1
 			}
 
@@ -744,7 +744,7 @@ func evconst(n *Node) {
 		if (v.Ctype == 0 || rv.Ctype == 0) && nerrors > 0 {
 			return
 		}
-		Fatal("constant type mismatch %v(%d) %v(%d)", Tconv(nl.Type, 0), v.Ctype, Tconv(nr.Type, 0), rv.Ctype)
+		Fatal("constant type mismatch %v(%d) %v(%d)", nl.Type, v.Ctype, nr.Type, rv.Ctype)
 	}
 
 	// run op
@@ -1051,7 +1051,7 @@ setfalse:
 
 illegal:
 	if n.Diag == 0 {
-		Yyerror("illegal constant expression: %v %v %v", Tconv(nl.Type, 0), Oconv(int(n.Op), 0), Tconv(nr.Type, 0))
+		Yyerror("illegal constant expression: %v %v %v", nl.Type, Oconv(int(n.Op), 0), nr.Type)
 		n.Diag = 1
 	}
 
@@ -1205,7 +1205,7 @@ func defaultlit(np **Node, t *Type) {
 			break
 		}
 
-		Yyerror("defaultlit: unknown literal: %v", Nconv(n, 0))
+		Yyerror("defaultlit: unknown literal: %v", n)
 
 	case CTxxx:
 		Fatal("defaultlit: idealkind is CTxxx: %v", Nconv(n, obj.FmtSign))
@@ -1432,7 +1432,7 @@ func Convconst(con *Node, t *Type, val *Val) {
 	if Isfloat[tt] {
 		con.Val = toflt(con.Val)
 		if con.Val.Ctype != CTFLT {
-			Fatal("convconst ctype=%d %v", con.Val.Ctype, Tconv(t, 0))
+			Fatal("convconst ctype=%d %v", con.Val.Ctype, t)
 		}
 		if tt == TFLOAT32 {
 			con.Val.U.Fval = truncfltlit(con.Val.U.Fval, t)
diff --git a/src/cmd/internal/gc/cplx.go b/src/cmd/internal/gc/cplx.go
index 73251bd1ba..c457bbf924 100644
--- a/src/cmd/internal/gc/cplx.go
+++ b/src/cmd/internal/gc/cplx.go
@@ -215,7 +215,7 @@ func nodfconst(n *Node, t *Type, fval *Mpflt) {
 	n.Type = t
 
 	if !Isfloat[t.Etype] {
-		Fatal("nodfconst: bad type %v", Tconv(t, 0))
+		Fatal("nodfconst: bad type %v", t)
 	}
 }
 
@@ -280,7 +280,7 @@ func Complexmove(f *Node, t *Node) {
 	tt := Simsimtype(t.Type)
 	switch uint32(ft)<<16 | uint32(tt) {
 	default:
-		Fatal("complexmove: unknown conversion: %v -> %v\n", Tconv(f.Type, 0), Tconv(t.Type, 0))
+		Fatal("complexmove: unknown conversion: %v -> %v\n", f.Type, t.Type)
 
 		// complex to complex move/convert.
 	// make f addable.
diff --git a/src/cmd/internal/gc/dcl.go b/src/cmd/internal/gc/dcl.go
index 786b7b2b07..a1f85543de 100644
--- a/src/cmd/internal/gc/dcl.go
+++ b/src/cmd/internal/gc/dcl.go
@@ -46,7 +46,7 @@ func pushdcl(s *Sym) *Sym {
 	d := push()
 	dcopy(d, s)
 	if dflag() {
-		fmt.Printf("\t%v push %v %p\n", Ctxt.Line(int(lineno)), Sconv(s, 0), s.Def)
+		fmt.Printf("\t%v push %v %p\n", Ctxt.Line(int(lineno)), s, s.Def)
 	}
 	return d
 }
@@ -68,7 +68,7 @@ func popdcl() {
 		dcopy(s, d)
 		d.Lastlineno = int32(lno)
 		if dflag() {
-			fmt.Printf("\t%v pop %v %p\n", Ctxt.Line(int(lineno)), Sconv(s, 0), s.Def)
+			fmt.Printf("\t%v pop %v %p\n", Ctxt.Line(int(lineno)), s, s.Def)
 		}
 	}
 
@@ -114,7 +114,7 @@ func dumpdcl(st string) {
 
 		fmt.Printf(" '%s'", d.Name)
 		s = Pkglookup(d.Name, d.Pkg)
-		fmt.Printf(" %v\n", Sconv(s, 0))
+		fmt.Printf(" %v\n", s)
 	}
 }
 
@@ -139,7 +139,7 @@ func redeclare(s *Sym, where string) {
 			tmp = s.Pkg.Path
 		}
 		pkgstr := tmp
-		Yyerror("%v redeclared %s\n"+"\tprevious declaration during import %q", Sconv(s, 0), where, pkgstr)
+		Yyerror("%v redeclared %s\n"+"\tprevious declaration during import %q", s, where, pkgstr)
 	} else {
 		line1 := parserline()
 		line2 := int(s.Lastlineno)
@@ -153,7 +153,7 @@ func redeclare(s *Sym, where string) {
 			line1 = int(s.Lastlineno)
 		}
 
-		yyerrorl(int(line1), "%v redeclared %s\n"+"\tprevious declaration at %v", Sconv(s, 0), where, Ctxt.Line(line2))
+		yyerrorl(int(line1), "%v redeclared %s\n"+"\tprevious declaration at %v", s, where, Ctxt.Line(line2))
 	}
 }
 
@@ -179,7 +179,7 @@ func declare(n *Node, ctxt uint8) {
 
 	// kludgy: typecheckok means we're past parsing.  Eg genwrapper may declare out of package names later.
 	if importpkg == nil && typecheckok == 0 && s.Pkg != localpkg {
-		Yyerror("cannot declare name %v", Sconv(s, 0))
+		Yyerror("cannot declare name %v", s)
 	}
 
 	if ctxt == PEXTERN && s.Name == "init" {
@@ -190,7 +190,7 @@ func declare(n *Node, ctxt uint8) {
 	if ctxt == PEXTERN {
 		externdcl = list(externdcl, n)
 		if dflag() {
-			fmt.Printf("\t%v global decl %v %p\n", Ctxt.Line(int(lineno)), Sconv(s, 0), n)
+			fmt.Printf("\t%v global decl %v %p\n", Ctxt.Line(int(lineno)), s, n)
 		}
 	} else {
 		if Curfn == nil && ctxt == PAUTO {
@@ -234,7 +234,7 @@ func declare(n *Node, ctxt uint8) {
 
 func addvar(n *Node, t *Type, ctxt uint8) {
 	if n == nil || n.Sym == nil || (n.Op != ONAME && n.Op != ONONAME) || t == nil {
-		Fatal("addvar: n=%v t=%v nil", Nconv(n, 0), Tconv(t, 0))
+		Fatal("addvar: n=%v t=%v nil", n, t)
 	}
 
 	n.Op = ONAME
@@ -487,13 +487,13 @@ func colasdefn(left *NodeList, defn *Node) {
 			continue
 		}
 		if !colasname(n) {
-			yyerrorl(int(defn.Lineno), "non-name %v on left side of :=", Nconv(n, 0))
+			yyerrorl(int(defn.Lineno), "non-name %v on left side of :=", n)
 			nerr++
 			continue
 		}
 
 		if n.Sym.Flags&SymUniq == 0 {
-			yyerrorl(int(defn.Lineno), "%v repeated on left side of :=", Sconv(n.Sym, 0))
+			yyerrorl(int(defn.Lineno), "%v repeated on left side of :=", n.Sym)
 			n.Diag++
 			nerr++
 			continue
@@ -695,7 +695,7 @@ func funcargs(nt *Node) {
  */
 func funcargs2(t *Type) {
 	if t.Etype != TFUNC {
-		Fatal("funcargs2 %v", Tconv(t, 0))
+		Fatal("funcargs2 %v", t)
 	}
 
 	if t.Thistuple != 0 {
@@ -803,7 +803,7 @@ func structfield(n *Node) *Type {
 	lineno = n.Lineno
 
 	if n.Op != ODCLFIELD {
-		Fatal("structfield: oops %v\n", Nconv(n, 0))
+		Fatal("structfield: oops %v\n", n)
 	}
 
 	f := typ(TFIELD)
@@ -934,7 +934,7 @@ func interfacefield(n *Node) *Type {
 	lineno = n.Lineno
 
 	if n.Op != ODCLFIELD {
-		Fatal("interfacefield: oops %v\n", Nconv(n, 0))
+		Fatal("interfacefield: oops %v\n", n)
 	}
 
 	if n.Val.Ctype != CTxxx {
@@ -974,11 +974,11 @@ func interfacefield(n *Node) *Type {
 					break
 
 				case TFORW:
-					Yyerror("interface type loop involving %v", Tconv(n.Type, 0))
+					Yyerror("interface type loop involving %v", n.Type)
 					f.Broke = 1
 
 				default:
-					Yyerror("interface contains embedded non-interface %v", Tconv(n.Type, 0))
+					Yyerror("interface contains embedded non-interface %v", n.Type)
 					f.Broke = 1
 				}
 			}
@@ -1301,7 +1301,7 @@ func methodsym(nsym *Sym, t0 *Type, iface int) *Sym {
 	return s
 
 bad:
-	Yyerror("illegal receiver type: %v", Tconv(t0, 0))
+	Yyerror("illegal receiver type: %v", t0)
 	return nil
 }
 
@@ -1326,9 +1326,9 @@ func methodname1(n *Node, t *Node) *Node {
 
 	var p string
 	if star != "" {
-		p = fmt.Sprintf("(%s%v).%v", star, Sconv(t.Sym, 0), Sconv(n.Sym, 0))
+		p = fmt.Sprintf("(%s%v).%v", star, t.Sym, n.Sym)
 	} else {
-		p = fmt.Sprintf("%v.%v", Sconv(t.Sym, 0), Sconv(n.Sym, 0))
+		p = fmt.Sprintf("%v.%v", t.Sym, n.Sym)
 	}
 
 	if exportname(t.Sym.Name) {
@@ -1367,7 +1367,7 @@ func addmethod(sf *Sym, t *Type, local bool, nointerface bool) {
 		if t != nil {
 			if Isptr[t.Etype] {
 				if t.Sym != nil {
-					Yyerror("invalid receiver type %v (%v is a pointer type)", Tconv(pa, 0), Tconv(t, 0))
+					Yyerror("invalid receiver type %v (%v is a pointer type)", pa, t)
 					return
 				}
 
@@ -1378,24 +1378,24 @@ func addmethod(sf *Sym, t *Type, local bool, nointerface bool) {
 				return
 			}
 			if t.Sym == nil {
-				Yyerror("invalid receiver type %v (%v is an unnamed type)", Tconv(pa, 0), Tconv(t, 0))
+				Yyerror("invalid receiver type %v (%v is an unnamed type)", pa, t)
 				return
 			}
 
 			if Isptr[t.Etype] {
-				Yyerror("invalid receiver type %v (%v is a pointer type)", Tconv(pa, 0), Tconv(t, 0))
+				Yyerror("invalid receiver type %v (%v is a pointer type)", pa, t)
 				return
 			}
 
 			if t.Etype == TINTER {
-				Yyerror("invalid receiver type %v (%v is an interface type)", Tconv(pa, 0), Tconv(t, 0))
+				Yyerror("invalid receiver type %v (%v is an interface type)", pa, t)
 				return
 			}
 		}
 
 		// Should have picked off all the reasons above,
 		// but just in case, fall back to generic error.
-		Yyerror("invalid receiver type %v (%v / %v)", Tconv(pa, 0), Tconv(pa, obj.FmtLong), Tconv(t, obj.FmtLong))
+		Yyerror("invalid receiver type %v (%v / %v)", pa, Tconv(pa, obj.FmtLong), Tconv(t, obj.FmtLong))
 
 		return
 	}
@@ -1404,7 +1404,7 @@ func addmethod(sf *Sym, t *Type, local bool, nointerface bool) {
 	if pa.Etype == TSTRUCT {
 		for f := pa.Type; f != nil; f = f.Down {
 			if f.Sym == sf {
-				Yyerror("type %v has both field and method named %v", Tconv(pa, 0), Sconv(sf, 0))
+				Yyerror("type %v has both field and method named %v", pa, sf)
 				return
 			}
 		}
@@ -1412,7 +1412,7 @@ func addmethod(sf *Sym, t *Type, local bool, nointerface bool) {
 
 	if local && !pa.Local {
 		// defining method on non-local type.
-		Yyerror("cannot define new methods on non-local type %v", Tconv(pa, 0))
+		Yyerror("cannot define new methods on non-local type %v", pa)
 
 		return
 	}
@@ -1430,7 +1430,7 @@ func addmethod(sf *Sym, t *Type, local bool, nointerface bool) {
 			continue
 		}
 		if !Eqtype(t, f.Type) {
-			Yyerror("method redeclared: %v.%v\n\t%v\n\t%v", Tconv(pa, 0), Sconv(sf, 0), Tconv(f.Type, 0), Tconv(t, 0))
+			Yyerror("method redeclared: %v.%v\n\t%v\n\t%v", pa, sf, f.Type, t)
 		}
 		return
 	}
@@ -1466,7 +1466,7 @@ func funccompile(n *Node) {
 	checkwidth(n.Type)
 
 	if Curfn != nil {
-		Fatal("funccompile %v inside %v", Sconv(n.Nname.Sym, 0), Sconv(Curfn.Nname.Sym, 0))
+		Fatal("funccompile %v inside %v", n.Nname.Sym, Curfn.Nname.Sym)
 	}
 
 	Stksize = 0
diff --git a/src/cmd/internal/gc/esc.go b/src/cmd/internal/gc/esc.go
index 0ca407a734..fe2cda3e95 100644
--- a/src/cmd/internal/gc/esc.go
+++ b/src/cmd/internal/gc/esc.go
@@ -318,7 +318,7 @@ func escAnalyze(all *NodeList, recursive bool) {
 				} else {
 					tmp = nil
 				}
-				Warnl(int(l.N.Lineno), "%v %v does not escape", Sconv(tmp, 0), Nconv(l.N, obj.FmtShort))
+				Warnl(int(l.N.Lineno), "%v %v does not escape", tmp, Nconv(l.N, obj.FmtShort))
 			}
 		}
 	}
@@ -328,7 +328,7 @@ func escfunc(e *EscState, func_ *Node) {
 	//	print("escfunc %N %s\n", func->nname, e->recursive?"(recursive)":"");
 
 	if func_.Esc != 1 {
-		Fatal("repeat escfunc %v", Nconv(func_.Nname, 0))
+		Fatal("repeat escfunc %v", func_.Nname)
 	}
 	func_.Esc = EscFuncStarted
 
@@ -483,7 +483,7 @@ func esc(e *EscState, n *Node, up *Node) {
 		} else {
 			tmp = nil
 		}
-		fmt.Printf("%v:[%d] %v esc: %v\n", Ctxt.Line(int(lineno)), e.loopdepth, Sconv(tmp, 0), Nconv(n, 0))
+		fmt.Printf("%v:[%d] %v esc: %v\n", Ctxt.Line(int(lineno)), e.loopdepth, tmp, n)
 	}
 
 	switch n.Op {
@@ -496,11 +496,11 @@ func esc(e *EscState, n *Node, up *Node) {
 	case OLABEL:
 		if n.Left.Sym.Label == &nonlooping {
 			if Debug['m'] > 1 {
-				fmt.Printf("%v:%v non-looping label\n", Ctxt.Line(int(lineno)), Nconv(n, 0))
+				fmt.Printf("%v:%v non-looping label\n", Ctxt.Line(int(lineno)), n)
 			}
 		} else if n.Left.Sym.Label == &looping {
 			if Debug['m'] > 1 {
-				fmt.Printf("%v: %v looping label\n", Ctxt.Line(int(lineno)), Nconv(n, 0))
+				fmt.Printf("%v: %v looping label\n", Ctxt.Line(int(lineno)), n)
 			}
 			e.loopdepth++
 		}
@@ -560,7 +560,7 @@ func esc(e *EscState, n *Node, up *Node) {
 				} else {
 					tmp = nil
 				}
-				Warnl(int(n.Lineno), "%v ignoring self-assignment to %v", Sconv(tmp, 0), Nconv(n.Left, obj.FmtShort))
+				Warnl(int(n.Lineno), "%v ignoring self-assignment to %v", tmp, Nconv(n.Left, obj.FmtShort))
 			}
 
 			break
@@ -800,7 +800,7 @@ func escassign(e *EscState, dst *Node, src *Node) {
 		} else {
 			tmp = nil
 		}
-		fmt.Printf("%v:[%d] %v escassign: %v(%v) = %v(%v)\n", Ctxt.Line(int(lineno)), e.loopdepth, Sconv(tmp, 0), Nconv(dst, obj.FmtShort), Jconv(dst, obj.FmtShort), Nconv(src, obj.FmtShort), Jconv(src, obj.FmtShort))
+		fmt.Printf("%v:[%d] %v escassign: %v(%v) = %v(%v)\n", Ctxt.Line(int(lineno)), e.loopdepth, tmp, Nconv(dst, obj.FmtShort), Jconv(dst, obj.FmtShort), Nconv(src, obj.FmtShort), Jconv(src, obj.FmtShort))
 	}
 
 	setlineno(dst)
@@ -1217,7 +1217,7 @@ func escflood(e *EscState, dst *Node) {
 		} else {
 			tmp = nil
 		}
-		fmt.Printf("\nescflood:%d: dst %v scope:%v[%d]\n", walkgen, Nconv(dst, obj.FmtShort), Sconv(tmp, 0), dst.Escloopdepth)
+		fmt.Printf("\nescflood:%d: dst %v scope:%v[%d]\n", walkgen, Nconv(dst, obj.FmtShort), tmp, dst.Escloopdepth)
 	}
 
 	for l := dst.Escflowsrc; l != nil; l = l.Next {
@@ -1255,7 +1255,7 @@ func escwalk(e *EscState, level int, dst *Node, src *Node) {
 		} else {
 			tmp = nil
 		}
-		fmt.Printf("escwalk: level:%d depth:%d %.*s %v(%v) scope:%v[%d]\n", level, e.pdepth, e.pdepth, "\t\t\t\t\t\t\t\t\t\t", Nconv(src, obj.FmtShort), Jconv(src, obj.FmtShort), Sconv(tmp, 0), src.Escloopdepth)
+		fmt.Printf("escwalk: level:%d depth:%d %.*s %v(%v) scope:%v[%d]\n", level, e.pdepth, e.pdepth, "\t\t\t\t\t\t\t\t\t\t", Nconv(src, obj.FmtShort), Jconv(src, obj.FmtShort), tmp, src.Escloopdepth)
 	}
 
 	e.pdepth++
@@ -1266,7 +1266,7 @@ func escwalk(e *EscState, level int, dst *Node, src *Node) {
 		if src.Op == ONAME && src.Class == PPARAM && src.Curfn == dst.Curfn && src.Esc != EscScope && src.Esc != EscHeap {
 			if level == 0 {
 				if Debug['m'] != 0 {
-					Warnl(int(src.Lineno), "leaking param: %v to result %v", Nconv(src, obj.FmtShort), Sconv(dst.Sym, 0))
+					Warnl(int(src.Lineno), "leaking param: %v to result %v", Nconv(src, obj.FmtShort), dst.Sym)
 				}
 				if src.Esc&EscMask != EscReturn {
 					src.Esc = EscReturn
@@ -1275,7 +1275,7 @@ func escwalk(e *EscState, level int, dst *Node, src *Node) {
 				goto recurse
 			} else if level > 0 {
 				if Debug['m'] != 0 {
-					Warnl(int(src.Lineno), "%v leaking param %v content to result %v", Nconv(src.Curfn.Nname, 0), Nconv(src, obj.FmtShort), Sconv(dst.Sym, 0))
+					Warnl(int(src.Lineno), "%v leaking param %v content to result %v", src.Curfn.Nname, Nconv(src, obj.FmtShort), dst.Sym)
 				}
 				if src.Esc&EscMask != EscReturn {
 					src.Esc = EscReturn
diff --git a/src/cmd/internal/gc/export.go b/src/cmd/internal/gc/export.go
index 76bb55ad4d..c9d11d5ced 100644
--- a/src/cmd/internal/gc/export.go
+++ b/src/cmd/internal/gc/export.go
@@ -21,7 +21,7 @@ func exportsym(n *Node) {
 	}
 	if n.Sym.Flags&(SymExport|SymPackage) != 0 {
 		if n.Sym.Flags&SymPackage != 0 {
-			Yyerror("export/package mismatch: %v", Sconv(n.Sym, 0))
+			Yyerror("export/package mismatch: %v", n.Sym)
 		}
 		return
 	}
@@ -29,7 +29,7 @@ func exportsym(n *Node) {
 	n.Sym.Flags |= SymExport
 
 	if Debug['E'] != 0 {
-		fmt.Printf("export symbol %v\n", Sconv(n.Sym, 0))
+		fmt.Printf("export symbol %v\n", n.Sym)
 	}
 	exportlist = list(exportlist, n)
 }
@@ -123,7 +123,7 @@ func reexportdep(n *Node) {
 		case PEXTERN:
 			if n.Sym != nil && !exportedsym(n.Sym) {
 				if Debug['E'] != 0 {
-					fmt.Printf("reexport name %v\n", Sconv(n.Sym, 0))
+					fmt.Printf("reexport name %v\n", n.Sym)
 				}
 				exportlist = list(exportlist, n)
 			}
@@ -139,7 +139,7 @@ func reexportdep(n *Node) {
 			}
 			if t != nil && t.Sym != nil && t.Sym.Def != nil && !exportedsym(t.Sym) {
 				if Debug['E'] != 0 {
-					fmt.Printf("reexport type %v from declaration\n", Sconv(t.Sym, 0))
+					fmt.Printf("reexport type %v from declaration\n", t.Sym)
 				}
 				exportlist = list(exportlist, t.Sym.Def)
 			}
@@ -153,7 +153,7 @@ func reexportdep(n *Node) {
 			}
 			if t != nil && t.Sym != nil && t.Sym.Def != nil && !exportedsym(t.Sym) {
 				if Debug['E'] != 0 {
-					fmt.Printf("reexport literal type %v\n", Sconv(t.Sym, 0))
+					fmt.Printf("reexport literal type %v\n", t.Sym)
 				}
 				exportlist = list(exportlist, t.Sym.Def)
 			}
@@ -164,7 +164,7 @@ func reexportdep(n *Node) {
 	case OTYPE:
 		if n.Sym != nil && !exportedsym(n.Sym) {
 			if Debug['E'] != 0 {
-				fmt.Printf("reexport literal/type %v\n", Sconv(n.Sym, 0))
+				fmt.Printf("reexport literal/type %v\n", n.Sym)
 			}
 			exportlist = list(exportlist, n)
 		}
@@ -193,7 +193,7 @@ func reexportdep(n *Node) {
 		}
 		if t != nil && t.Sym != nil && t.Sym.Def != nil && !exportedsym(t.Sym) {
 			if Debug['E'] != 0 {
-				fmt.Printf("reexport type for expression %v\n", Sconv(t.Sym, 0))
+				fmt.Printf("reexport type for expression %v\n", t.Sym)
 			}
 			exportlist = list(exportlist, t.Sym.Def)
 		}
@@ -214,7 +214,7 @@ func dumpexportconst(s *Sym) {
 	n := s.Def
 	typecheck(&n, Erv)
 	if n == nil || n.Op != OLITERAL {
-		Fatal("dumpexportconst: oconst nil: %v", Sconv(s, 0))
+		Fatal("dumpexportconst: oconst nil: %v", s)
 	}
 
 	t := n.Type // may or may not be specified
@@ -231,7 +231,7 @@ func dumpexportvar(s *Sym) {
 	n := s.Def
 	typecheck(&n, Erv|Ecall)
 	if n == nil || n.Type == nil {
-		Yyerror("variable exported but not defined: %v", Sconv(s, 0))
+		Yyerror("variable exported but not defined: %v", s)
 		return
 	}
 
@@ -337,7 +337,7 @@ func dumpsym(s *Sym) {
 	s.Flags |= SymExported
 
 	if s.Def == nil {
-		Yyerror("unknown export symbol: %v", Sconv(s, 0))
+		Yyerror("unknown export symbol: %v", s)
 		return
 	}
 
@@ -346,14 +346,14 @@ func dumpsym(s *Sym) {
 
 	switch s.Def.Op {
 	default:
-		Yyerror("unexpected export symbol: %v %v", Oconv(int(s.Def.Op), 0), Sconv(s, 0))
+		Yyerror("unexpected export symbol: %v %v", Oconv(int(s.Def.Op), 0), s)
 
 	case OLITERAL:
 		dumpexportconst(s)
 
 	case OTYPE:
 		if s.Def.Type.Etype == TFORW {
-			Yyerror("export of incomplete type %v", Sconv(s, 0))
+			Yyerror("export of incomplete type %v", s)
 		} else {
 			dumpexporttype(s.Def.Type)
 		}
@@ -424,7 +424,7 @@ func pkgtype(s *Sym) *Type {
 	}
 
 	if s.Def.Type == nil {
-		Yyerror("pkgtype %v", Sconv(s, 0))
+		Yyerror("pkgtype %v", s)
 	}
 	return s.Def.Type
 }
@@ -477,7 +477,7 @@ func importconst(s *Sym, t *Type, n *Node) {
 	declare(n, PEXTERN)
 
 	if Debug['E'] != 0 {
-		fmt.Printf("import const %v\n", Sconv(s, 0))
+		fmt.Printf("import const %v\n", s)
 	}
 }
 
@@ -487,7 +487,7 @@ func importvar(s *Sym, t *Type) {
 		if Eqtype(t, s.Def.Type) {
 			return
 		}
-		Yyerror("inconsistent definition for var %v during import\n\t%v (in %q)\n\t%v (in %q)", Sconv(s, 0), Tconv(s.Def.Type, 0), s.Importdef.Path, Tconv(t, 0), importpkg.Path)
+		Yyerror("inconsistent definition for var %v during import\n\t%v (in %q)\n\t%v (in %q)", s, s.Def.Type, s.Importdef.Path, t, importpkg.Path)
 	}
 
 	n := newname(s)
@@ -496,7 +496,7 @@ func importvar(s *Sym, t *Type) {
 	declare(n, PEXTERN)
 
 	if Debug['E'] != 0 {
-		fmt.Printf("import var %v %v\n", Sconv(s, 0), Tconv(t, obj.FmtLong))
+		fmt.Printf("import var %v %v\n", s, Tconv(t, obj.FmtLong))
 	}
 }
 
@@ -517,11 +517,11 @@ func importtype(pt *Type, t *Type) {
 		declare(n, PEXTERN)
 		checkwidth(pt)
 	} else if !Eqtype(pt.Orig, t) {
-		Yyerror("inconsistent definition for type %v during import\n\t%v (in %q)\n\t%v (in %q)", Sconv(pt.Sym, 0), Tconv(pt, obj.FmtLong), pt.Sym.Importdef.Path, Tconv(t, obj.FmtLong), importpkg.Path)
+		Yyerror("inconsistent definition for type %v during import\n\t%v (in %q)\n\t%v (in %q)", pt.Sym, Tconv(pt, obj.FmtLong), pt.Sym.Importdef.Path, Tconv(t, obj.FmtLong), importpkg.Path)
 	}
 
 	if Debug['E'] != 0 {
-		fmt.Printf("import type %v %v\n", Tconv(pt, 0), Tconv(t, obj.FmtLong))
+		fmt.Printf("import type %v %v\n", pt, Tconv(t, obj.FmtLong))
 	}
 }
 
diff --git a/src/cmd/internal/gc/fmt.go b/src/cmd/internal/gc/fmt.go
index 5d1990e48c..f7e2583ec0 100644
--- a/src/cmd/internal/gc/fmt.go
+++ b/src/cmd/internal/gc/fmt.go
@@ -317,7 +317,7 @@ func Vconv(v *Val, flag int) string {
 		if 0 <= x && x <= utf8.MaxRune {
 			return fmt.Sprintf("'\\U%08x'", uint64(x))
 		}
-		return fmt.Sprintf("('\\x00' + %v)", Bconv(v.U.Xval, 0))
+		return fmt.Sprintf("('\\x00' + %v)", v.U.Xval)
 
 	case CTFLT:
 		if (flag&obj.FmtSharp != 0 /*untyped*/) || fmtmode == FExp {
@@ -327,7 +327,7 @@ func Vconv(v *Val, flag int) string {
 
 	case CTCPLX:
 		if (flag&obj.FmtSharp != 0 /*untyped*/) || fmtmode == FExp {
-			return fmt.Sprintf("(%v+%vi)", Fconv(&v.U.Cval.Real, 0), Fconv(&v.U.Cval.Imag, 0))
+			return fmt.Sprintf("(%v+%vi)", &v.U.Cval.Real, &v.U.Cval.Imag)
 		}
 		if mpcmpfltc(&v.U.Cval.Real, 0) == 0 {
 			return fmt.Sprintf("%vi", Fconv(&v.U.Cval.Imag, obj.FmtSharp))
@@ -517,7 +517,7 @@ func typefmt(t *Type, flag int) string {
 			// fallthrough
 		case FExp:
 			if t.Sym.Pkg == localpkg && t.Vargen != 0 {
-				return fmt.Sprintf("%v·%d", Sconv(t.Sym, 0), t.Vargen)
+				return fmt.Sprintf("%v·%d", t.Sym, t.Vargen)
 			}
 		}
 
@@ -544,33 +544,33 @@ func typefmt(t *Type, flag int) string {
 		if fmtmode == FTypeId && (flag&obj.FmtShort != 0 /*untyped*/) {
 			return fmt.Sprintf("*%v", Tconv(t.Type, obj.FmtShort))
 		}
-		return fmt.Sprintf("*%v", Tconv(t.Type, 0))
+		return fmt.Sprintf("*%v", t.Type)
 
 	case TARRAY:
 		if t.Bound >= 0 {
-			return fmt.Sprintf("[%d]%v", t.Bound, Tconv(t.Type, 0))
+			return fmt.Sprintf("[%d]%v", t.Bound, t.Type)
 		}
 		if t.Bound == -100 {
-			return fmt.Sprintf("[...]%v", Tconv(t.Type, 0))
+			return fmt.Sprintf("[...]%v", t.Type)
 		}
-		return fmt.Sprintf("[]%v", Tconv(t.Type, 0))
+		return fmt.Sprintf("[]%v", t.Type)
 
 	case TCHAN:
 		switch t.Chan {
 		case Crecv:
-			return fmt.Sprintf("<-chan %v", Tconv(t.Type, 0))
+			return fmt.Sprintf("<-chan %v", t.Type)
 
 		case Csend:
-			return fmt.Sprintf("chan<- %v", Tconv(t.Type, 0))
+			return fmt.Sprintf("chan<- %v", t.Type)
 		}
 
 		if t.Type != nil && t.Type.Etype == TCHAN && t.Type.Sym == nil && t.Type.Chan == Crecv {
-			return fmt.Sprintf("chan (%v)", Tconv(t.Type, 0))
+			return fmt.Sprintf("chan (%v)", t.Type)
 		}
-		return fmt.Sprintf("chan %v", Tconv(t.Type, 0))
+		return fmt.Sprintf("chan %v", t.Type)
 
 	case TMAP:
-		return fmt.Sprintf("map[%v]%v", Tconv(t.Down, 0), Tconv(t.Type, 0))
+		return fmt.Sprintf("map[%v]%v", t.Down, t.Type)
 
 	case TINTER:
 		var buf bytes.Buffer
@@ -630,15 +630,15 @@ func typefmt(t *Type, flag int) string {
 			// Format the bucket struct for map[x]y as map.bucket[x]y.
 			// This avoids a recursive print that generates very long names.
 			if t.Map.Bucket == t {
-				return fmt.Sprintf("map.bucket[%v]%v", Tconv(t.Map.Down, 0), Tconv(t.Map.Type, 0))
+				return fmt.Sprintf("map.bucket[%v]%v", t.Map.Down, t.Map.Type)
 			}
 
 			if t.Map.Hmap == t {
-				return fmt.Sprintf("map.hdr[%v]%v", Tconv(t.Map.Down, 0), Tconv(t.Map.Type, 0))
+				return fmt.Sprintf("map.hdr[%v]%v", t.Map.Down, t.Map.Type)
 			}
 
 			if t.Map.Hiter == t {
-				return fmt.Sprintf("map.iter[%v]%v", Tconv(t.Map.Down, 0), Tconv(t.Map.Type, 0))
+				return fmt.Sprintf("map.iter[%v]%v", t.Map.Down, t.Map.Type)
 			}
 
 			Yyerror("unknown internal map type")
@@ -741,7 +741,7 @@ func typefmt(t *Type, flag int) string {
 
 	case TFORW:
 		if t.Sym != nil {
-			return fmt.Sprintf("undefined %v", Sconv(t.Sym, 0))
+			return fmt.Sprintf("undefined %v", t.Sym)
 		}
 		return "undefined"
 
@@ -757,7 +757,7 @@ func typefmt(t *Type, flag int) string {
 	}
 
 	// Don't know how to handle - fall back to detailed prints.
-	return fmt.Sprintf("%v <%v> %v", Econv(int(t.Etype), 0), Sconv(t.Sym, 0), Tconv(t.Type, 0))
+	return fmt.Sprintf("%v <%v> %v", Econv(int(t.Etype), 0), t.Sym, t.Type)
 }
 
 // Statements which may be rendered with a simplestmt as init.
@@ -792,7 +792,7 @@ func stmtfmt(n *Node) string {
 	}
 
 	if complexinit {
-		f += fmt.Sprintf(" %v; ", Hconv(n.Ninit, 0))
+		f += fmt.Sprintf(" %v; ", n.Ninit)
 	}
 
 	switch n.Op {
@@ -800,16 +800,16 @@ func stmtfmt(n *Node) string {
 		if fmtmode == FExp {
 			switch n.Left.Class &^ PHEAP {
 			case PPARAM, PPARAMOUT, PAUTO:
-				f += fmt.Sprintf("var %v %v", Nconv(n.Left, 0), Tconv(n.Left.Type, 0))
+				f += fmt.Sprintf("var %v %v", n.Left, n.Left.Type)
 				goto ret
 			}
 		}
 
-		f += fmt.Sprintf("var %v %v", Sconv(n.Left.Sym, 0), Tconv(n.Left.Type, 0))
+		f += fmt.Sprintf("var %v %v", n.Left.Sym, n.Left.Type)
 
 	case ODCLFIELD:
 		if n.Left != nil {
-			f += fmt.Sprintf("%v %v", Nconv(n.Left, 0), Nconv(n.Right, 0))
+			f += fmt.Sprintf("%v %v", n.Left, n.Right)
 		} else {
 			f += Nconv(n.Right, 0)
 		}
@@ -823,22 +823,22 @@ func stmtfmt(n *Node) string {
 		}
 
 		if n.Colas && !complexinit {
-			f += fmt.Sprintf("%v := %v", Nconv(n.Left, 0), Nconv(n.Right, 0))
+			f += fmt.Sprintf("%v := %v", n.Left, n.Right)
 		} else {
-			f += fmt.Sprintf("%v = %v", Nconv(n.Left, 0), Nconv(n.Right, 0))
+			f += fmt.Sprintf("%v = %v", n.Left, n.Right)
 		}
 
 	case OASOP:
 		if n.Implicit {
 			if n.Etype == OADD {
-				f += fmt.Sprintf("%v++", Nconv(n.Left, 0))
+				f += fmt.Sprintf("%v++", n.Left)
 			} else {
-				f += fmt.Sprintf("%v--", Nconv(n.Left, 0))
+				f += fmt.Sprintf("%v--", n.Left)
 			}
 			break
 		}
 
-		f += fmt.Sprintf("%v %v= %v", Nconv(n.Left, 0), Oconv(int(n.Etype), obj.FmtSharp), Nconv(n.Right, 0))
+		f += fmt.Sprintf("%v %v= %v", n.Left, Oconv(int(n.Etype), obj.FmtSharp), n.Right)
 
 	case OAS2:
 		if n.Colas && !complexinit {
@@ -855,22 +855,22 @@ func stmtfmt(n *Node) string {
 		f += fmt.Sprintf("return %v", Hconv(n.List, obj.FmtComma))
 
 	case ORETJMP:
-		f += fmt.Sprintf("retjmp %v", Sconv(n.Sym, 0))
+		f += fmt.Sprintf("retjmp %v", n.Sym)
 
 	case OPROC:
-		f += fmt.Sprintf("go %v", Nconv(n.Left, 0))
+		f += fmt.Sprintf("go %v", n.Left)
 
 	case ODEFER:
-		f += fmt.Sprintf("defer %v", Nconv(n.Left, 0))
+		f += fmt.Sprintf("defer %v", n.Left)
 
 	case OIF:
 		if simpleinit {
-			f += fmt.Sprintf("if %v; %v { %v }", Nconv(n.Ninit.N, 0), Nconv(n.Ntest, 0), Hconv(n.Nbody, 0))
+			f += fmt.Sprintf("if %v; %v { %v }", n.Ninit.N, n.Ntest, n.Nbody)
 		} else {
-			f += fmt.Sprintf("if %v { %v }", Nconv(n.Ntest, 0), Hconv(n.Nbody, 0))
+			f += fmt.Sprintf("if %v { %v }", n.Ntest, n.Nbody)
 		}
 		if n.Nelse != nil {
-			f += fmt.Sprintf(" else { %v }", Hconv(n.Nelse, 0))
+			f += fmt.Sprintf(" else { %v }", n.Nelse)
 		}
 
 	case OFOR:
@@ -881,22 +881,22 @@ func stmtfmt(n *Node) string {
 
 		f += "for"
 		if simpleinit {
-			f += fmt.Sprintf(" %v;", Nconv(n.Ninit.N, 0))
+			f += fmt.Sprintf(" %v;", n.Ninit.N)
 		} else if n.Nincr != nil {
 			f += " ;"
 		}
 
 		if n.Ntest != nil {
-			f += fmt.Sprintf(" %v", Nconv(n.Ntest, 0))
+			f += fmt.Sprintf(" %v", n.Ntest)
 		}
 
 		if n.Nincr != nil {
-			f += fmt.Sprintf("; %v", Nconv(n.Nincr, 0))
+			f += fmt.Sprintf("; %v", n.Nincr)
 		} else if simpleinit {
 			f += ";"
 		}
 
-		f += fmt.Sprintf(" { %v }", Hconv(n.Nbody, 0))
+		f += fmt.Sprintf(" { %v }", n.Nbody)
 
 	case ORANGE:
 		if fmtmode == FErr {
@@ -905,11 +905,11 @@ func stmtfmt(n *Node) string {
 		}
 
 		if n.List == nil {
-			f += fmt.Sprintf("for range %v { %v }", Nconv(n.Right, 0), Hconv(n.Nbody, 0))
+			f += fmt.Sprintf("for range %v { %v }", n.Right, n.Nbody)
 			break
 		}
 
-		f += fmt.Sprintf("for %v = range %v { %v }", Hconv(n.List, obj.FmtComma), Nconv(n.Right, 0), Hconv(n.Nbody, 0))
+		f += fmt.Sprintf("for %v = range %v { %v }", Hconv(n.List, obj.FmtComma), n.Right, n.Nbody)
 
 	case OSELECT, OSWITCH:
 		if fmtmode == FErr {
@@ -919,19 +919,19 @@ func stmtfmt(n *Node) string {
 
 		f += Oconv(int(n.Op), obj.FmtSharp)
 		if simpleinit {
-			f += fmt.Sprintf(" %v;", Nconv(n.Ninit.N, 0))
+			f += fmt.Sprintf(" %v;", n.Ninit.N)
 		}
 		if n.Ntest != nil {
 			f += Nconv(n.Ntest, 0)
 		}
 
-		f += fmt.Sprintf(" { %v }", Hconv(n.List, 0))
+		f += fmt.Sprintf(" { %v }", n.List)
 
 	case OCASE, OXCASE:
 		if n.List != nil {
-			f += fmt.Sprintf("case %v: %v", Hconv(n.List, obj.FmtComma), Hconv(n.Nbody, 0))
+			f += fmt.Sprintf("case %v: %v", Hconv(n.List, obj.FmtComma), n.Nbody)
 		} else {
-			f += fmt.Sprintf("default: %v", Hconv(n.Nbody, 0))
+			f += fmt.Sprintf("default: %v", n.Nbody)
 		}
 
 	case OBREAK,
@@ -940,7 +940,7 @@ func stmtfmt(n *Node) string {
 		OFALL,
 		OXFALL:
 		if n.Left != nil {
-			f += fmt.Sprintf("%v %v", Oconv(int(n.Op), obj.FmtSharp), Nconv(n.Left, 0))
+			f += fmt.Sprintf("%v %v", Oconv(int(n.Op), obj.FmtSharp), n.Left)
 		} else {
 			f += Oconv(int(n.Op), obj.FmtSharp)
 		}
@@ -949,7 +949,7 @@ func stmtfmt(n *Node) string {
 		break
 
 	case OLABEL:
-		f += fmt.Sprintf("%v: ", Nconv(n.Left, 0))
+		f += fmt.Sprintf("%v: ", n.Left)
 	}
 
 ret:
@@ -1089,12 +1089,12 @@ func exprfmt(n *Node, prec int) string {
 	}
 
 	if prec > nprec {
-		return fmt.Sprintf("(%v)", Nconv(n, 0))
+		return fmt.Sprintf("(%v)", n)
 	}
 
 	switch n.Op {
 	case OPAREN:
-		return fmt.Sprintf("(%v)", Nconv(n.Left, 0))
+		return fmt.Sprintf("(%v)", n.Left)
 
 	case ODDDARG:
 		return "... argument"
@@ -1118,9 +1118,9 @@ func exprfmt(n *Node, prec int) string {
 			// Need parens when type begins with what might
 			// be misinterpreted as a unary operator: * or <-.
 			if Isptr[n.Type.Etype] || (n.Type.Etype == TCHAN && n.Type.Chan == Crecv) {
-				return fmt.Sprintf("(%v)(%v)", Tconv(n.Type, 0), Vconv(&n.Val, 0))
+				return fmt.Sprintf("(%v)(%v)", n.Type, Vconv(&n.Val, 0))
 			} else {
-				return fmt.Sprintf("%v(%v)", Tconv(n.Type, 0), Vconv(&n.Val, 0))
+				return fmt.Sprintf("%v(%v)", n.Type, Vconv(&n.Val, 0))
 			}
 		}
 
@@ -1133,7 +1133,7 @@ func exprfmt(n *Node, prec int) string {
 			return "_"
 		}
 		if fmtmode == FExp && n.Sym != nil && !isblank(n) && n.Vargen > 0 {
-			return fmt.Sprintf("%v·%d", Sconv(n.Sym, 0), n.Vargen)
+			return fmt.Sprintf("%v·%d", n.Sym, n.Vargen)
 		}
 
 		// Special case: explicit name of func (*T) method(...) is turned into pkg.(*T).method,
@@ -1141,9 +1141,9 @@ func exprfmt(n *Node, prec int) string {
 		// These nodes have the special property that they are names with a left OTYPE and a right ONAME.
 		if fmtmode == FExp && n.Left != nil && n.Left.Op == OTYPE && n.Right != nil && n.Right.Op == ONAME {
 			if Isptr[n.Left.Type.Etype] {
-				return fmt.Sprintf("(%v).%v", Tconv(n.Left.Type, 0), Sconv(n.Right.Sym, obj.FmtShort|obj.FmtByte))
+				return fmt.Sprintf("(%v).%v", n.Left.Type, Sconv(n.Right.Sym, obj.FmtShort|obj.FmtByte))
 			} else {
-				return fmt.Sprintf("%v.%v", Tconv(n.Left.Type, 0), Sconv(n.Right.Sym, obj.FmtShort|obj.FmtByte))
+				return fmt.Sprintf("%v.%v", n.Left.Type, Sconv(n.Right.Sym, obj.FmtShort|obj.FmtByte))
 			}
 		}
 		fallthrough
@@ -1160,28 +1160,28 @@ func exprfmt(n *Node, prec int) string {
 
 	case OTARRAY:
 		if n.Left != nil {
-			return fmt.Sprintf("[]%v", Nconv(n.Left, 0))
+			return fmt.Sprintf("[]%v", n.Left)
 		}
 		var f string
-		f += fmt.Sprintf("[]%v", Nconv(n.Right, 0))
+		f += fmt.Sprintf("[]%v", n.Right)
 		return f // happens before typecheck
 
 	case OTMAP:
-		return fmt.Sprintf("map[%v]%v", Nconv(n.Left, 0), Nconv(n.Right, 0))
+		return fmt.Sprintf("map[%v]%v", n.Left, n.Right)
 
 	case OTCHAN:
 		switch n.Etype {
 		case Crecv:
-			return fmt.Sprintf("<-chan %v", Nconv(n.Left, 0))
+			return fmt.Sprintf("<-chan %v", n.Left)
 
 		case Csend:
-			return fmt.Sprintf("chan<- %v", Nconv(n.Left, 0))
+			return fmt.Sprintf("chan<- %v", n.Left)
 
 		default:
 			if n.Left != nil && n.Left.Op == OTCHAN && n.Left.Sym == nil && n.Left.Etype == Crecv {
-				return fmt.Sprintf("chan (%v)", Nconv(n.Left, 0))
+				return fmt.Sprintf("chan (%v)", n.Left)
 			} else {
-				return fmt.Sprintf("chan %v", Nconv(n.Left, 0))
+				return fmt.Sprintf("chan %v", n.Left)
 			}
 		}
 		fallthrough
@@ -1200,18 +1200,18 @@ func exprfmt(n *Node, prec int) string {
 			return "func literal"
 		}
 		if n.Nbody != nil {
-			return fmt.Sprintf("%v { %v }", Tconv(n.Type, 0), Hconv(n.Nbody, 0))
+			return fmt.Sprintf("%v { %v }", n.Type, n.Nbody)
 		}
-		return fmt.Sprintf("%v { %v }", Tconv(n.Type, 0), Hconv(n.Closure.Nbody, 0))
+		return fmt.Sprintf("%v { %v }", n.Type, n.Closure.Nbody)
 
 	case OCOMPLIT:
 		ptrlit := n.Right != nil && n.Right.Implicit && n.Right.Type != nil && Isptr[n.Right.Type.Etype]
 		if fmtmode == FErr {
 			if n.Right != nil && n.Right.Type != nil && !n.Implicit {
 				if ptrlit {
-					return fmt.Sprintf("&%v literal", Tconv(n.Right.Type.Type, 0))
+					return fmt.Sprintf("&%v literal", n.Right.Type.Type)
 				} else {
-					return fmt.Sprintf("%v literal", Tconv(n.Right.Type, 0))
+					return fmt.Sprintf("%v literal", n.Right.Type)
 				}
 			}
 
@@ -1220,16 +1220,16 @@ func exprfmt(n *Node, prec int) string {
 
 		if fmtmode == FExp && ptrlit {
 			// typecheck has overwritten OIND by OTYPE with pointer type.
-			return fmt.Sprintf("(&%v{ %v })", Tconv(n.Right.Type.Type, 0), Hconv(n.List, obj.FmtComma))
+			return fmt.Sprintf("(&%v{ %v })", n.Right.Type.Type, Hconv(n.List, obj.FmtComma))
 		}
 
-		return fmt.Sprintf("(%v{ %v })", Nconv(n.Right, 0), Hconv(n.List, obj.FmtComma))
+		return fmt.Sprintf("(%v{ %v })", n.Right, Hconv(n.List, obj.FmtComma))
 
 	case OPTRLIT:
 		if fmtmode == FExp && n.Left.Implicit {
 			return Nconv(n.Left, 0)
 		}
-		return fmt.Sprintf("&%v", Nconv(n.Left, 0))
+		return fmt.Sprintf("&%v", n.Left)
 
 	case OSTRUCTLIT:
 		if fmtmode == FExp { // requires special handling of field names
@@ -1237,10 +1237,10 @@ func exprfmt(n *Node, prec int) string {
 			if n.Implicit {
 				f += "{"
 			} else {
-				f += fmt.Sprintf("(%v{", Tconv(n.Type, 0))
+				f += fmt.Sprintf("(%v{", n.Type)
 			}
 			for l := n.List; l != nil; l = l.Next {
-				f += fmt.Sprintf(" %v:%v", Sconv(l.N.Left.Sym, obj.FmtShort|obj.FmtByte), Nconv(l.N.Right, 0))
+				f += fmt.Sprintf(" %v:%v", Sconv(l.N.Left.Sym, obj.FmtShort|obj.FmtByte), l.N.Right)
 
 				if l.Next != nil {
 					f += ","
@@ -1262,28 +1262,28 @@ func exprfmt(n *Node, prec int) string {
 
 	case OARRAYLIT, OMAPLIT:
 		if fmtmode == FErr {
-			return fmt.Sprintf("%v literal", Tconv(n.Type, 0))
+			return fmt.Sprintf("%v literal", n.Type)
 		}
 		if fmtmode == FExp && n.Implicit {
 			return fmt.Sprintf("{ %v }", Hconv(n.List, obj.FmtComma))
 		}
-		return fmt.Sprintf("(%v{ %v })", Tconv(n.Type, 0), Hconv(n.List, obj.FmtComma))
+		return fmt.Sprintf("(%v{ %v })", n.Type, Hconv(n.List, obj.FmtComma))
 
 	case OKEY:
 		if n.Left != nil && n.Right != nil {
 			if fmtmode == FExp && n.Left.Type != nil && n.Left.Type.Etype == TFIELD {
 				// requires special handling of field names
-				return fmt.Sprintf("%v:%v", Sconv(n.Left.Sym, obj.FmtShort|obj.FmtByte), Nconv(n.Right, 0))
+				return fmt.Sprintf("%v:%v", Sconv(n.Left.Sym, obj.FmtShort|obj.FmtByte), n.Right)
 			} else {
-				return fmt.Sprintf("%v:%v", Nconv(n.Left, 0), Nconv(n.Right, 0))
+				return fmt.Sprintf("%v:%v", n.Left, n.Right)
 			}
 		}
 
 		if n.Left == nil && n.Right != nil {
-			return fmt.Sprintf(":%v", Nconv(n.Right, 0))
+			return fmt.Sprintf(":%v", n.Right)
 		}
 		if n.Left != nil && n.Right == nil {
-			return fmt.Sprintf("%v:", Nconv(n.Left, 0))
+			return fmt.Sprintf("%v:", n.Left)
 		}
 		return ":"
 
@@ -1306,10 +1306,10 @@ func exprfmt(n *Node, prec int) string {
 		var f string
 		f += exprfmt(n.Left, nprec)
 		if n.Right != nil {
-			f += fmt.Sprintf(".(%v)", Nconv(n.Right, 0))
+			f += fmt.Sprintf(".(%v)", n.Right)
 			return f
 		}
-		f += fmt.Sprintf(".(%v)", Tconv(n.Type, 0))
+		f += fmt.Sprintf(".(%v)", n.Type)
 		return f
 
 	case OINDEX,
@@ -1321,11 +1321,11 @@ func exprfmt(n *Node, prec int) string {
 		OSLICE3ARR:
 		var f string
 		f += exprfmt(n.Left, nprec)
-		f += fmt.Sprintf("[%v]", Nconv(n.Right, 0))
+		f += fmt.Sprintf("[%v]", n.Right)
 		return f
 
 	case OCOPY, OCOMPLEX:
-		return fmt.Sprintf("%v(%v, %v)", Oconv(int(n.Op), obj.FmtSharp), Nconv(n.Left, 0), Nconv(n.Right, 0))
+		return fmt.Sprintf("%v(%v, %v)", Oconv(int(n.Op), obj.FmtSharp), n.Left, n.Right)
 
 	case OCONV,
 		OCONVIFACE,
@@ -1336,12 +1336,12 @@ func exprfmt(n *Node, prec int) string {
 		OSTRARRAYRUNE,
 		ORUNESTR:
 		if n.Type == nil || n.Type.Sym == nil {
-			return fmt.Sprintf("(%v)(%v)", Tconv(n.Type, 0), Nconv(n.Left, 0))
+			return fmt.Sprintf("(%v)(%v)", n.Type, n.Left)
 		}
 		if n.Left != nil {
-			return fmt.Sprintf("%v(%v)", Tconv(n.Type, 0), Nconv(n.Left, 0))
+			return fmt.Sprintf("%v(%v)", n.Type, n.Left)
 		}
-		return fmt.Sprintf("%v(%v)", Tconv(n.Type, 0), Hconv(n.List, obj.FmtComma))
+		return fmt.Sprintf("%v(%v)", n.Type, Hconv(n.List, obj.FmtComma))
 
 	case OREAL,
 		OIMAG,
@@ -1357,7 +1357,7 @@ func exprfmt(n *Node, prec int) string {
 		OPRINT,
 		OPRINTN:
 		if n.Left != nil {
-			return fmt.Sprintf("%v(%v)", Oconv(int(n.Op), obj.FmtSharp), Nconv(n.Left, 0))
+			return fmt.Sprintf("%v(%v)", Oconv(int(n.Op), obj.FmtSharp), n.Left)
 		}
 		if n.Isddd {
 			return fmt.Sprintf("%v(%v...)", Oconv(int(n.Op), obj.FmtSharp), Hconv(n.List, obj.FmtComma))
@@ -1376,15 +1376,15 @@ func exprfmt(n *Node, prec int) string {
 
 	case OMAKEMAP, OMAKECHAN, OMAKESLICE:
 		if n.List != nil { // pre-typecheck
-			return fmt.Sprintf("make(%v, %v)", Tconv(n.Type, 0), Hconv(n.List, obj.FmtComma))
+			return fmt.Sprintf("make(%v, %v)", n.Type, Hconv(n.List, obj.FmtComma))
 		}
 		if n.Right != nil {
-			return fmt.Sprintf("make(%v, %v, %v)", Tconv(n.Type, 0), Nconv(n.Left, 0), Nconv(n.Right, 0))
+			return fmt.Sprintf("make(%v, %v, %v)", n.Type, n.Left, n.Right)
 		}
 		if n.Left != nil && (n.Op == OMAKESLICE || !isideal(n.Left.Type)) {
-			return fmt.Sprintf("make(%v, %v)", Tconv(n.Type, 0), Nconv(n.Left, 0))
+			return fmt.Sprintf("make(%v, %v)", n.Type, n.Left)
 		}
-		return fmt.Sprintf("make(%v)", Tconv(n.Type, 0))
+		return fmt.Sprintf("make(%v)", n.Type)
 
 		// Unary
 	case OPLUS,
@@ -1467,7 +1467,7 @@ func nodefmt(n *Node, flag int) string {
 		if t.Etype == TNIL {
 			return "nil"
 		} else {
-			return fmt.Sprintf("%v (type %v)", Nconv(n, 0), Tconv(t, 0))
+			return fmt.Sprintf("%v (type %v)", n, t)
 		}
 	}
 
@@ -1505,7 +1505,7 @@ func nodedump(n *Node, flag int) string {
 		}
 
 		if n.Ninit != nil {
-			fmt.Fprintf(&buf, "%v-init%v", Oconv(int(n.Op), 0), Hconv(n.Ninit, 0))
+			fmt.Fprintf(&buf, "%v-init%v", Oconv(int(n.Op), 0), n.Ninit)
 			indent(&buf)
 		}
 	}
@@ -1522,32 +1522,32 @@ func nodedump(n *Node, flag int) string {
 
 	case ONAME, ONONAME:
 		if n.Sym != nil {
-			fmt.Fprintf(&buf, "%v-%v%v", Oconv(int(n.Op), 0), Sconv(n.Sym, 0), Jconv(n, 0))
+			fmt.Fprintf(&buf, "%v-%v%v", Oconv(int(n.Op), 0), n.Sym, Jconv(n, 0))
 		} else {
 			fmt.Fprintf(&buf, "%v%v", Oconv(int(n.Op), 0), Jconv(n, 0))
 		}
 		if recur && n.Type == nil && n.Ntype != nil {
 			indent(&buf)
-			fmt.Fprintf(&buf, "%v-ntype%v", Oconv(int(n.Op), 0), Nconv(n.Ntype, 0))
+			fmt.Fprintf(&buf, "%v-ntype%v", Oconv(int(n.Op), 0), n.Ntype)
 		}
 
 	case OASOP:
 		fmt.Fprintf(&buf, "%v-%v%v", Oconv(int(n.Op), 0), Oconv(int(n.Etype), 0), Jconv(n, 0))
 
 	case OTYPE:
-		fmt.Fprintf(&buf, "%v %v%v type=%v", Oconv(int(n.Op), 0), Sconv(n.Sym, 0), Jconv(n, 0), Tconv(n.Type, 0))
+		fmt.Fprintf(&buf, "%v %v%v type=%v", Oconv(int(n.Op), 0), n.Sym, Jconv(n, 0), n.Type)
 		if recur && n.Type == nil && n.Ntype != nil {
 			indent(&buf)
-			fmt.Fprintf(&buf, "%v-ntype%v", Oconv(int(n.Op), 0), Nconv(n.Ntype, 0))
+			fmt.Fprintf(&buf, "%v-ntype%v", Oconv(int(n.Op), 0), n.Ntype)
 		}
 	}
 
 	if n.Sym != nil && n.Op != ONAME {
-		fmt.Fprintf(&buf, " %v G%d", Sconv(n.Sym, 0), n.Vargen)
+		fmt.Fprintf(&buf, " %v G%d", n.Sym, n.Vargen)
 	}
 
 	if n.Type != nil {
-		fmt.Fprintf(&buf, " %v", Tconv(n.Type, 0))
+		fmt.Fprintf(&buf, " %v", n.Type)
 	}
 
 	if recur {
@@ -1559,32 +1559,32 @@ func nodedump(n *Node, flag int) string {
 		}
 		if n.List != nil {
 			indent(&buf)
-			fmt.Fprintf(&buf, "%v-list%v", Oconv(int(n.Op), 0), Hconv(n.List, 0))
+			fmt.Fprintf(&buf, "%v-list%v", Oconv(int(n.Op), 0), n.List)
 		}
 
 		if n.Rlist != nil {
 			indent(&buf)
-			fmt.Fprintf(&buf, "%v-rlist%v", Oconv(int(n.Op), 0), Hconv(n.Rlist, 0))
+			fmt.Fprintf(&buf, "%v-rlist%v", Oconv(int(n.Op), 0), n.Rlist)
 		}
 
 		if n.Ntest != nil {
 			indent(&buf)
-			fmt.Fprintf(&buf, "%v-test%v", Oconv(int(n.Op), 0), Nconv(n.Ntest, 0))
+			fmt.Fprintf(&buf, "%v-test%v", Oconv(int(n.Op), 0), n.Ntest)
 		}
 
 		if n.Nbody != nil {
 			indent(&buf)
-			fmt.Fprintf(&buf, "%v-body%v", Oconv(int(n.Op), 0), Hconv(n.Nbody, 0))
+			fmt.Fprintf(&buf, "%v-body%v", Oconv(int(n.Op), 0), n.Nbody)
 		}
 
 		if n.Nelse != nil {
 			indent(&buf)
-			fmt.Fprintf(&buf, "%v-else%v", Oconv(int(n.Op), 0), Hconv(n.Nelse, 0))
+			fmt.Fprintf(&buf, "%v-else%v", Oconv(int(n.Op), 0), n.Nelse)
 		}
 
 		if n.Nincr != nil {
 			indent(&buf)
-			fmt.Fprintf(&buf, "%v-incr%v", Oconv(int(n.Op), 0), Nconv(n.Nincr, 0))
+			fmt.Fprintf(&buf, "%v-incr%v", Oconv(int(n.Op), 0), n.Nincr)
 		}
 	}
 
diff --git a/src/cmd/internal/gc/gen.go b/src/cmd/internal/gc/gen.go
index 60de0831b2..9de41910f6 100644
--- a/src/cmd/internal/gc/gen.go
+++ b/src/cmd/internal/gc/gen.go
@@ -82,12 +82,12 @@ func addrescapes(n *Node) {
 
 			Curfn = n.Curfn
 			n.Heapaddr = temp(Ptrto(n.Type))
-			buf := fmt.Sprintf("&%v", Sconv(n.Sym, 0))
+			buf := fmt.Sprintf("&%v", n.Sym)
 			n.Heapaddr.Sym = Lookup(buf)
 			n.Heapaddr.Orig.Sym = n.Heapaddr.Sym
 			n.Esc = EscHeap
 			if Debug['m'] != 0 {
-				fmt.Printf("%v: moved to heap: %v\n", n.Line(), Nconv(n, 0))
+				fmt.Printf("%v: moved to heap: %v\n", n.Line(), n)
 			}
 			Curfn = oldfn
 		}
@@ -133,7 +133,7 @@ func newlab(n *Node) *Label {
 
 	if n.Op == OLABEL {
 		if lab.Def != nil {
-			Yyerror("label %v already defined at %v", Sconv(s, 0), lab.Def.Line())
+			Yyerror("label %v already defined at %v", s, lab.Def.Line())
 		} else {
 			lab.Def = n
 		}
@@ -192,9 +192,9 @@ func checkgoto(from *Node, to *Node) {
 		}
 
 		if block != nil {
-			Yyerror("goto %v jumps into block starting at %v", Sconv(from.Left.Sym, 0), Ctxt.Line(int(block.Lastlineno)))
+			Yyerror("goto %v jumps into block starting at %v", from.Left.Sym, Ctxt.Line(int(block.Lastlineno)))
 		} else {
-			Yyerror("goto %v jumps over declaration of %v at %v", Sconv(from.Left.Sym, 0), Sconv(dcl, 0), Ctxt.Line(int(dcl.Lastlineno)))
+			Yyerror("goto %v jumps over declaration of %v at %v", from.Left.Sym, dcl, Ctxt.Line(int(dcl.Lastlineno)))
 		}
 		lineno = int32(lno)
 	}
@@ -260,7 +260,7 @@ func cgen_dcl(n *Node) {
 		return
 	}
 	if compiling_runtime != 0 {
-		Yyerror("%v escapes to heap, not allowed in runtime.", Nconv(n, 0))
+		Yyerror("%v escapes to heap, not allowed in runtime.", n)
 	}
 	if n.Alloc == nil {
 		n.Alloc = callnew(n.Type)
@@ -365,7 +365,7 @@ func Clearslim(n *Node) {
 		Mpmovecfix(z.Val.U.Xval, 0)
 
 	default:
-		Fatal("clearslim called on type %v", Tconv(n.Type, 0))
+		Fatal("clearslim called on type %v", n.Type)
 	}
 
 	ullmancalc(&z)
@@ -850,13 +850,13 @@ func gen(n *Node) {
 		if n.Left != nil {
 			lab := n.Left.Sym.Label
 			if lab == nil {
-				Yyerror("break label not defined: %v", Sconv(n.Left.Sym, 0))
+				Yyerror("break label not defined: %v", n.Left.Sym)
 				break
 			}
 
 			lab.Used = 1
 			if lab.Breakpc == nil {
-				Yyerror("invalid break label %v", Sconv(n.Left.Sym, 0))
+				Yyerror("invalid break label %v", n.Left.Sym)
 				break
 			}
 
@@ -875,13 +875,13 @@ func gen(n *Node) {
 		if n.Left != nil {
 			lab := n.Left.Sym.Label
 			if lab == nil {
-				Yyerror("continue label not defined: %v", Sconv(n.Left.Sym, 0))
+				Yyerror("continue label not defined: %v", n.Left.Sym)
 				break
 			}
 
 			lab.Used = 1
 			if lab.Continpc == nil {
-				Yyerror("invalid continue label %v", Sconv(n.Left.Sym, 0))
+				Yyerror("invalid continue label %v", n.Left.Sym)
 				break
 			}
 
@@ -1105,18 +1105,18 @@ func checklabels() {
 	for lab := labellist; lab != nil; lab = lab.Link {
 		if lab.Def == nil {
 			for l = lab.Use; l != nil; l = l.Next {
-				yyerrorl(int(l.N.Lineno), "label %v not defined", Sconv(lab.Sym, 0))
+				yyerrorl(int(l.N.Lineno), "label %v not defined", lab.Sym)
 			}
 			continue
 		}
 
 		if lab.Use == nil && lab.Used == 0 {
-			yyerrorl(int(lab.Def.Lineno), "label %v defined and not used", Sconv(lab.Sym, 0))
+			yyerrorl(int(lab.Def.Lineno), "label %v defined and not used", lab.Sym)
 			continue
 		}
 
 		if lab.Gotopc != nil {
-			Fatal("label %v never resolved", Sconv(lab.Sym, 0))
+			Fatal("label %v never resolved", lab.Sym)
 		}
 		for l = lab.Use; l != nil; l = l.Next {
 			checkgoto(l.N, lab.Def)
diff --git a/src/cmd/internal/gc/go.y b/src/cmd/internal/gc/go.y
index aa2eac1ff6..f1904b0085 100644
--- a/src/cmd/internal/gc/go.y
+++ b/src/cmd/internal/gc/go.y
@@ -449,7 +449,7 @@ simple_stmt:
 			if $1.Next != nil {
 				Yyerror("argument count mismatch: %d = %d", count($1), 1);
 			} else if ($1.N.Op != ONAME && $1.N.Op != OTYPE && $1.N.Op != ONONAME) || isblank($1.N) {
-				Yyerror("invalid variable name %s in type switch", Nconv($1.N, 0));
+				Yyerror("invalid variable name %s in type switch", $1.N);
 			} else {
 				$$.Left = dclname($1.N.Sym);
 			}  // it's a colas, so must not re-use an oldname.
@@ -1419,7 +1419,7 @@ hidden_fndcl:
 				dclcontext = PDISCARD;  // since we skip funchdr below
 				break;
 			}
-			Yyerror("inconsistent definition for func %v during import\n\t%v\n\t%v", Sconv(s, 0), Tconv(s.Def.Type, 0), Tconv(t, 0));
+			Yyerror("inconsistent definition for func %v during import\n\t%v\n\t%v", s, s.Def.Type, t);
 		}
 
 		$$ = newfuncname(s);
@@ -1634,7 +1634,7 @@ packname:
 		var pkg *Pkg
 
 		if $1.Def == nil || $1.Def.Op != OPACK {
-			Yyerror("%v is not a package", Sconv($1, 0));
+			Yyerror("%v is not a package", $1);
 			pkg = localpkg;
 		} else {
 			$1.Def.Used = true;
@@ -2188,7 +2188,7 @@ hidden_literal:
 	{
 		$$ = oldname(Pkglookup($1.Name, builtinpkg));
 		if $$.Op != OLITERAL {
-			Yyerror("bad constant %v", Sconv($$.Sym, 0));
+			Yyerror("bad constant %v", $$.Sym);
 		}
 	}
 
diff --git a/src/cmd/internal/gc/gsubr.go b/src/cmd/internal/gc/gsubr.go
index 99ef74e428..34b9612f67 100644
--- a/src/cmd/internal/gc/gsubr.go
+++ b/src/cmd/internal/gc/gsubr.go
@@ -374,7 +374,7 @@ func Naddr(a *obj.Addr, n *Node) {
 		a.Type = obj.TYPE_MEM
 		switch n.Class {
 		default:
-			Fatal("naddr: ONAME class %v %d\n", Sconv(n.Sym, 0), n.Class)
+			Fatal("naddr: ONAME class %v %d\n", n.Sym, n.Class)
 
 		case PEXTERN:
 			a.Name = obj.NAME_EXTERN
@@ -511,7 +511,7 @@ func nodarg(t *Type, fp int) *Node {
 			Fatal("nodarg: bad struct")
 		}
 		if first.Width == BADWIDTH {
-			Fatal("nodarg: offset not computed for %v", Tconv(t, 0))
+			Fatal("nodarg: offset not computed for %v", t)
 		}
 		n.Xoffset = first.Width
 		n.Addable = true
@@ -519,7 +519,7 @@ func nodarg(t *Type, fp int) *Node {
 	}
 
 	if t.Etype != TFIELD {
-		Fatal("nodarg: not field %v", Tconv(t, 0))
+		Fatal("nodarg: not field %v", t)
 	}
 
 	if fp == 1 {
@@ -537,7 +537,7 @@ func nodarg(t *Type, fp int) *Node {
 	n.Sym = t.Sym
 
 	if t.Width == BADWIDTH {
-		Fatal("nodarg: offset not computed for %v", Tconv(t, 0))
+		Fatal("nodarg: offset not computed for %v", t)
 	}
 	n.Xoffset = t.Width
 	n.Addable = true
@@ -663,7 +663,7 @@ func Regalloc(n *Node, t *Type, o *Node) {
 Switch:
 	switch et {
 	default:
-		Fatal("regalloc: unknown type %v", Tconv(t, 0))
+		Fatal("regalloc: unknown type %v", t)
 
 	case TINT8, TUINT8, TINT16, TUINT16, TINT32, TUINT32, TINT64, TUINT64, TPTR32, TPTR64, TBOOL:
 		if o != nil && o.Op == OREGISTER {
diff --git a/src/cmd/internal/gc/inl.go b/src/cmd/internal/gc/inl.go
index 8850a8b383..71e9594717 100644
--- a/src/cmd/internal/gc/inl.go
+++ b/src/cmd/internal/gc/inl.go
@@ -54,7 +54,7 @@ func fnpkg(fn *Node) *Pkg {
 			rcvr = rcvr.Type
 		}
 		if rcvr.Sym == nil {
-			Fatal("receiver with no sym: [%v] %v  (%v)", Sconv(fn.Sym, 0), Nconv(fn, obj.FmtLong), Tconv(rcvr, 0))
+			Fatal("receiver with no sym: [%v] %v  (%v)", fn.Sym, Nconv(fn, obj.FmtLong), rcvr)
 		}
 		return rcvr.Sym.Pkg
 	}
@@ -79,7 +79,7 @@ func typecheckinl(fn *Node) {
 	}
 
 	if Debug['m'] > 2 {
-		fmt.Printf("typecheck import [%v] %v { %v }\n", Sconv(fn.Sym, 0), Nconv(fn, obj.FmtLong), Hconv(fn.Func.Inl, obj.FmtSharp))
+		fmt.Printf("typecheck import [%v] %v { %v }\n", fn.Sym, Nconv(fn, obj.FmtLong), Hconv(fn.Func.Inl, obj.FmtSharp))
 	}
 
 	save_safemode := safemode
@@ -100,7 +100,7 @@ func typecheckinl(fn *Node) {
 // fn and ->nbody will already have been typechecked.
 func caninl(fn *Node) {
 	if fn.Op != ODCLFUNC {
-		Fatal("caninl %v", Nconv(fn, 0))
+		Fatal("caninl %v", fn)
 	}
 	if fn.Nname == nil {
 		Fatal("caninl no nname %v", Nconv(fn, obj.FmtSign))
@@ -112,7 +112,7 @@ func caninl(fn *Node) {
 	}
 
 	if fn.Typecheck == 0 {
-		Fatal("caninl on non-typechecked function %v", Nconv(fn, 0))
+		Fatal("caninl on non-typechecked function %v", fn)
 	}
 
 	// can't handle ... args yet
@@ -155,7 +155,7 @@ func caninl(fn *Node) {
 	if Debug['m'] > 1 {
 		fmt.Printf("%v: can inline %v as: %v { %v }\n", fn.Line(), Nconv(fn.Nname, obj.FmtSharp), Tconv(fn.Type, obj.FmtSharp), Hconv(fn.Nname.Func.Inl, obj.FmtSharp))
 	} else if Debug['m'] != 0 {
-		fmt.Printf("%v: can inline %v\n", fn.Line(), Nconv(fn.Nname, 0))
+		fmt.Printf("%v: can inline %v\n", fn.Line(), fn.Nname)
 	}
 
 	Curfn = savefn
@@ -514,7 +514,7 @@ func mkinlcall(np **Node, fn *Node, isddd bool) {
 func tinlvar(t *Type) *Node {
 	if t.Nname != nil && !isblank(t.Nname) {
 		if t.Nname.Inlvar == nil {
-			Fatal("missing inlvar for %v\n", Nconv(t.Nname, 0))
+			Fatal("missing inlvar for %v\n", t.Nname)
 		}
 		return t.Nname.Inlvar
 	}
@@ -547,9 +547,9 @@ func mkinlcall1(np **Node, fn *Node, isddd bool) {
 
 	// Bingo, we have a function node, and it has an inlineable body
 	if Debug['m'] > 1 {
-		fmt.Printf("%v: inlining call to %v %v { %v }\n", n.Line(), Sconv(fn.Sym, 0), Tconv(fn.Type, obj.FmtSharp), Hconv(fn.Func.Inl, obj.FmtSharp))
+		fmt.Printf("%v: inlining call to %v %v { %v }\n", n.Line(), fn.Sym, Tconv(fn.Type, obj.FmtSharp), Hconv(fn.Func.Inl, obj.FmtSharp))
 	} else if Debug['m'] != 0 {
-		fmt.Printf("%v: inlining call to %v\n", n.Line(), Nconv(fn, 0))
+		fmt.Printf("%v: inlining call to %v\n", n.Line(), fn)
 	}
 
 	if Debug['m'] > 2 {
@@ -614,7 +614,7 @@ func mkinlcall1(np **Node, fn *Node, isddd bool) {
 		t := getthisx(fn.Type).Type
 
 		if t != nil && t.Nname != nil && !isblank(t.Nname) && t.Nname.Inlvar == nil {
-			Fatal("missing inlvar for %v\n", Nconv(t.Nname, 0))
+			Fatal("missing inlvar for %v\n", t.Nname)
 		}
 		if n.Left.Left == nil {
 			Fatal("method call without receiver: %v", Nconv(n, obj.FmtSign))
@@ -683,7 +683,7 @@ func mkinlcall1(np **Node, fn *Node, isddd bool) {
 		t := getthisx(fn.Type).Type
 
 		if t != nil && t.Nname != nil && !isblank(t.Nname) && t.Nname.Inlvar == nil {
-			Fatal("missing inlvar for %v\n", Nconv(t.Nname, 0))
+			Fatal("missing inlvar for %v\n", t.Nname)
 		}
 		if t == nil {
 			Fatal("method call unknown receiver type: %v", Nconv(n, obj.FmtSign))
diff --git a/src/cmd/internal/gc/lex.go b/src/cmd/internal/gc/lex.go
index 1f0e88375c..8266e5e5f6 100644
--- a/src/cmd/internal/gc/lex.go
+++ b/src/cmd/internal/gc/lex.go
@@ -1380,7 +1380,7 @@ talph:
 	}
 
 	if Debug['x'] != 0 {
-		fmt.Printf("lex: %s %s\n", Sconv(s, 0), lexname(int(s.Lexical)))
+		fmt.Printf("lex: %s %s\n", s, lexname(int(s.Lexical)))
 	}
 	yylval.sym = s
 	return int32(s.Lexical)
diff --git a/src/cmd/internal/gc/mparith3.go b/src/cmd/internal/gc/mparith3.go
index 53ab9c63a0..2700b64a89 100644
--- a/src/cmd/internal/gc/mparith3.go
+++ b/src/cmd/internal/gc/mparith3.go
@@ -34,13 +34,13 @@ func mpmovefltflt(a *Mpflt, b *Mpflt) {
 
 func mpaddfltflt(a *Mpflt, b *Mpflt) {
 	if Mpdebug {
-		fmt.Printf("\n%v + %v", Fconv(a, 0), Fconv(b, 0))
+		fmt.Printf("\n%v + %v", a, b)
 	}
 
 	a.Val.Add(&a.Val, &b.Val)
 
 	if Mpdebug {
-		fmt.Printf(" = %v\n\n", Fconv(a, 0))
+		fmt.Printf(" = %v\n\n", a)
 	}
 }
 
@@ -53,25 +53,25 @@ func mpaddcflt(a *Mpflt, c float64) {
 
 func mpsubfltflt(a *Mpflt, b *Mpflt) {
 	if Mpdebug {
-		fmt.Printf("\n%v - %v", Fconv(a, 0), Fconv(b, 0))
+		fmt.Printf("\n%v - %v", a, b)
 	}
 
 	a.Val.Sub(&a.Val, &b.Val)
 
 	if Mpdebug {
-		fmt.Printf(" = %v\n\n", Fconv(a, 0))
+		fmt.Printf(" = %v\n\n", a)
 	}
 }
 
 func mpmulfltflt(a *Mpflt, b *Mpflt) {
 	if Mpdebug {
-		fmt.Printf("%v\n * %v\n", Fconv(a, 0), Fconv(b, 0))
+		fmt.Printf("%v\n * %v\n", a, b)
 	}
 
 	a.Val.Mul(&a.Val, &b.Val)
 
 	if Mpdebug {
-		fmt.Printf(" = %v\n\n", Fconv(a, 0))
+		fmt.Printf(" = %v\n\n", a)
 	}
 }
 
@@ -84,13 +84,13 @@ func mpmulcflt(a *Mpflt, c float64) {
 
 func mpdivfltflt(a *Mpflt, b *Mpflt) {
 	if Mpdebug {
-		fmt.Printf("%v\n / %v\n", Fconv(a, 0), Fconv(b, 0))
+		fmt.Printf("%v\n / %v\n", a, b)
 	}
 
 	a.Val.Quo(&a.Val, &b.Val)
 
 	if Mpdebug {
-		fmt.Printf(" = %v\n\n", Fconv(a, 0))
+		fmt.Printf(" = %v\n\n", a)
 	}
 }
 
@@ -148,7 +148,7 @@ func Mpmovecflt(a *Mpflt, c float64) {
 	a.Val.SetFloat64(c)
 
 	if Mpdebug {
-		fmt.Printf(" = %v\n", Fconv(a, 0))
+		fmt.Printf(" = %v\n", a)
 	}
 }
 
diff --git a/src/cmd/internal/gc/obj.go b/src/cmd/internal/gc/obj.go
index 34c107069c..5885eb5d7e 100644
--- a/src/cmd/internal/gc/obj.go
+++ b/src/cmd/internal/gc/obj.go
@@ -121,7 +121,7 @@ func dumpglobls() {
 		}
 
 		if n.Type == nil {
-			Fatal("external %v nil type\n", Nconv(n, 0))
+			Fatal("external %v nil type\n", n)
 		}
 		if n.Class == PFUNC {
 			continue
@@ -272,7 +272,7 @@ func slicebytes(nam *Node, s string, len int) {
 	ggloblsym(sym, int32(off), obj.NOPTR)
 
 	if nam.Op != ONAME {
-		Fatal("slicebytes %v", Nconv(nam, 0))
+		Fatal("slicebytes %v", nam)
 	}
 	off = int(nam.Xoffset)
 	off = dsymptr(nam.Sym, off, sym, 0)
diff --git a/src/cmd/internal/gc/order.go b/src/cmd/internal/gc/order.go
index ec744638a1..f08f5f20fe 100644
--- a/src/cmd/internal/gc/order.go
+++ b/src/cmd/internal/gc/order.go
@@ -50,7 +50,7 @@ type Order struct {
 // described in the comment at the top of the file.
 func order(fn *Node) {
 	if Debug['W'] > 1 {
-		s := fmt.Sprintf("\nbefore order %v", Sconv(fn.Nname.Sym, 0))
+		s := fmt.Sprintf("\nbefore order %v", fn.Nname.Sym)
 		dumplist(s, fn.Nbody)
 	}
 
@@ -323,7 +323,7 @@ func ismulticall(l *NodeList) bool {
 // and then returns the list t1, t2, ....
 func copyret(n *Node, order *Order) *NodeList {
 	if n.Type.Etype != TSTRUCT || n.Type.Funarg == 0 {
-		Fatal("copyret %v %d", Tconv(n.Type, 0), n.Left.Type.Outtuple)
+		Fatal("copyret %v %d", n.Type, n.Left.Type.Outtuple)
 	}
 
 	var l1 *NodeList
@@ -680,7 +680,7 @@ func orderstmt(n *Node, order *Order) {
 		orderexpr(&n.Right, order)
 		switch n.Type.Etype {
 		default:
-			Fatal("orderstmt range %v", Tconv(n.Type, 0))
+			Fatal("orderstmt range %v", n.Type)
 
 			// Mark []byte(str) range expression to reuse string backing storage.
 		// It is safe because the storage cannot be mutated.
diff --git a/src/cmd/internal/gc/pgen.go b/src/cmd/internal/gc/pgen.go
index 4100c20205..3c4a11e4eb 100644
--- a/src/cmd/internal/gc/pgen.go
+++ b/src/cmd/internal/gc/pgen.go
@@ -88,7 +88,7 @@ func gvardefx(n *Node, as int) {
 		Fatal("gvardef nil")
 	}
 	if n.Op != ONAME {
-		Yyerror("gvardef %v; %v", Oconv(int(n.Op), obj.FmtSharp), Nconv(n, 0))
+		Yyerror("gvardef %v; %v", Oconv(int(n.Op), obj.FmtSharp), n)
 		return
 	}
 
diff --git a/src/cmd/internal/gc/plive.go b/src/cmd/internal/gc/plive.go
index 02863fb5e8..7f19c75dc6 100644
--- a/src/cmd/internal/gc/plive.go
+++ b/src/cmd/internal/gc/plive.go
@@ -740,7 +740,7 @@ func printnode(node *Node) {
 	if node.Addrtaken {
 		a = "@"
 	}
-	fmt.Printf(" %v%s%s", Nconv(node, 0), p, a)
+	fmt.Printf(" %v%s%s", node, p, a)
 }
 
 // Pretty print a list of variables.  The vars argument is an array of Node*s.
@@ -812,13 +812,13 @@ func checkauto(fn *Node, p *obj.Prog, n *Node) {
 	}
 
 	if n == nil {
-		fmt.Printf("%v: checkauto %v: nil node in %v\n", p.Line(), Nconv(Curfn, 0), p)
+		fmt.Printf("%v: checkauto %v: nil node in %v\n", p.Line(), Curfn, p)
 		return
 	}
 
-	fmt.Printf("checkauto %v: %v (%p; class=%d) not found in %v\n", Nconv(Curfn, 0), Nconv(n, 0), n, n.Class, p)
+	fmt.Printf("checkauto %v: %v (%p; class=%d) not found in %v\n", Curfn, n, n, n.Class, p)
 	for l := fn.Func.Dcl; l != nil; l = l.Next {
-		fmt.Printf("\t%v (%p; class=%d)\n", Nconv(l.N, 0), l.N, l.N.Class)
+		fmt.Printf("\t%v (%p; class=%d)\n", l.N, l.N, l.N.Class)
 	}
 	Yyerror("checkauto: invariant lost")
 }
@@ -837,9 +837,9 @@ func checkparam(fn *Node, p *obj.Prog, n *Node) {
 		}
 	}
 
-	fmt.Printf("checkparam %v: %v (%p; class=%d) not found in %v\n", Nconv(Curfn, 0), Nconv(n, 0), n, n.Class, p)
+	fmt.Printf("checkparam %v: %v (%p; class=%d) not found in %v\n", Curfn, n, n, n.Class, p)
 	for l := fn.Func.Dcl; l != nil; l = l.Next {
-		fmt.Printf("\t%v (%p; class=%d)\n", Nconv(l.N, 0), l.N, l.N.Class)
+		fmt.Printf("\t%v (%p; class=%d)\n", l.N, l.N, l.N.Class)
 	}
 	Yyerror("checkparam: invariant lost")
 }
@@ -885,7 +885,7 @@ func checkptxt(fn *Node, firstp *obj.Prog) {
 // accounts for 40% of the 6g execution time.
 func twobitwalktype1(t *Type, xoffset *int64, bv Bvec) {
 	if t.Align > 0 && *xoffset&int64(t.Align-1) != 0 {
-		Fatal("twobitwalktype1: invalid initial alignment, %v", Tconv(t, 0))
+		Fatal("twobitwalktype1: invalid initial alignment, %v", t)
 	}
 
 	switch t.Etype {
@@ -918,7 +918,7 @@ func twobitwalktype1(t *Type, xoffset *int64, bv Bvec) {
 		TCHAN,
 		TMAP:
 		if *xoffset&int64(Widthptr-1) != 0 {
-			Fatal("twobitwalktype1: invalid alignment, %v", Tconv(t, 0))
+			Fatal("twobitwalktype1: invalid alignment, %v", t)
 		}
 		bvset(bv, int32((*xoffset/int64(Widthptr))*obj.BitsPerPointer+1)) // 2 = live ptr (BitsPointer)
 		*xoffset += t.Width
@@ -926,7 +926,7 @@ func twobitwalktype1(t *Type, xoffset *int64, bv Bvec) {
 		// struct { byte *str; intgo len; }
 	case TSTRING:
 		if *xoffset&int64(Widthptr-1) != 0 {
-			Fatal("twobitwalktype1: invalid alignment, %v", Tconv(t, 0))
+			Fatal("twobitwalktype1: invalid alignment, %v", t)
 		}
 		bvset(bv, int32((*xoffset/int64(Widthptr))*obj.BitsPerPointer+1)) // 2 = live ptr in first slot (BitsPointer)
 		*xoffset += t.Width
@@ -936,7 +936,7 @@ func twobitwalktype1(t *Type, xoffset *int64, bv Bvec) {
 	// struct { Type *type; union { void *ptr, uintptr val } data; }
 	case TINTER:
 		if *xoffset&int64(Widthptr-1) != 0 {
-			Fatal("twobitwalktype1: invalid alignment, %v", Tconv(t, 0))
+			Fatal("twobitwalktype1: invalid alignment, %v", t)
 		}
 		bvset(bv, int32((*xoffset/int64(Widthptr))*obj.BitsPerPointer+1)) // 2 = live ptr in first slot (BitsPointer)
 		bvset(bv, int32((*xoffset/int64(Widthptr))*obj.BitsPerPointer+3)) // 2 = live ptr in second slot (BitsPointer)
@@ -946,12 +946,12 @@ func twobitwalktype1(t *Type, xoffset *int64, bv Bvec) {
 	// for fixed array types.  All other values are invalid.
 	case TARRAY:
 		if t.Bound < -1 {
-			Fatal("twobitwalktype1: invalid bound, %v", Tconv(t, 0))
+			Fatal("twobitwalktype1: invalid bound, %v", t)
 		}
 		if Isslice(t) {
 			// struct { byte *array; uintgo len; uintgo cap; }
 			if *xoffset&int64(Widthptr-1) != 0 {
-				Fatal("twobitwalktype1: invalid TARRAY alignment, %v", Tconv(t, 0))
+				Fatal("twobitwalktype1: invalid TARRAY alignment, %v", t)
 			}
 			bvset(bv, int32((*xoffset/int64(Widthptr))*obj.BitsPerPointer+1)) // 2 = live ptr in first slot (BitsPointer)
 			*xoffset += t.Width
@@ -974,7 +974,7 @@ func twobitwalktype1(t *Type, xoffset *int64, bv Bvec) {
 		*xoffset += t.Width - o
 
 	default:
-		Fatal("twobitwalktype1: unexpected type, %v", Tconv(t, 0))
+		Fatal("twobitwalktype1: unexpected type, %v", t)
 	}
 }
 
@@ -1283,7 +1283,7 @@ func livenessepilogue(lv *Liveness) {
 						if !n.Needzero {
 							n.Needzero = true
 							if debuglive >= 1 {
-								Warnl(int(p.Lineno), "%v: %v is ambiguously live", Nconv(Curfn.Nname, 0), Nconv(n, obj.FmtLong))
+								Warnl(int(p.Lineno), "%v: %v is ambiguously live", Curfn.Nname, Nconv(n, obj.FmtLong))
 							}
 
 							// Record in 'ambiguous' bitmap.
@@ -1380,7 +1380,7 @@ func livenessepilogue(lv *Liveness) {
 						}
 						n = lv.vars[j]
 						if n.Class != PPARAM {
-							yyerrorl(int(p.Lineno), "internal error: %v %v recorded as live on entry", Nconv(Curfn.Nname, 0), Nconv(n, obj.FmtLong))
+							yyerrorl(int(p.Lineno), "internal error: %v %v recorded as live on entry", Curfn.Nname, Nconv(n, obj.FmtLong))
 						}
 					}
 				}
@@ -1416,7 +1416,7 @@ func livenessepilogue(lv *Liveness) {
 					for j = 0; j < int32(len(lv.vars)); j++ {
 						n = lv.vars[j]
 						if islive(n, args, locals) {
-							fmt_ += fmt.Sprintf(" %v", Nconv(n, 0))
+							fmt_ += fmt.Sprintf(" %v", n)
 							numlive++
 						}
 					}
@@ -1689,7 +1689,7 @@ func livenessprintdebug(lv *Liveness) {
 						if tmp9 != 0 {
 							fmt.Printf(",")
 						}
-						fmt.Printf("%v", Nconv(n, 0))
+						fmt.Printf("%v", n)
 					}
 				}
 
diff --git a/src/cmd/internal/gc/popt.go b/src/cmd/internal/gc/popt.go
index 57d57c5ab2..ce904e155b 100644
--- a/src/cmd/internal/gc/popt.go
+++ b/src/cmd/internal/gc/popt.go
@@ -263,7 +263,7 @@ func Flowstart(firstp *obj.Prog, newData func() interface{}) *Graph {
 
 	if nf >= MaxFlowProg {
 		if Debug['v'] != 0 {
-			Warn("%v is too big (%d instructions)", Sconv(Curfn.Nname.Sym, 0), nf)
+			Warn("%v is too big (%d instructions)", Curfn.Nname.Sym, nf)
 		}
 		return nil
 	}
@@ -652,7 +652,7 @@ func mergetemp(firstp *obj.Prog) {
 				p.To = obj.Addr{}
 				v.removed = 1
 				if debugmerge > 0 && Debug['v'] != 0 {
-					fmt.Printf("drop write-only %v\n", Sconv(v.node.Sym, 0))
+					fmt.Printf("drop write-only %v\n", v.node.Sym)
 				}
 			} else {
 				Fatal("temp used and not set: %v", p)
@@ -675,7 +675,7 @@ func mergetemp(firstp *obj.Prog) {
 				Thearch.Excise(f)
 				v.removed = 1
 				if debugmerge > 0 && Debug['v'] != 0 {
-					fmt.Printf("drop immediate-use %v\n", Sconv(v.node.Sym, 0))
+					fmt.Printf("drop immediate-use %v\n", v.node.Sym)
 				}
 			}
 
@@ -752,7 +752,7 @@ func mergetemp(firstp *obj.Prog) {
 		for j = nfree; j < len(var_); j++ {
 			v1 = inuse[j]
 			if debugmerge > 0 && Debug['v'] != 0 {
-				fmt.Printf("consider %v: maybe %v: type=%v,%v addrtaken=%v,%v\n", Nconv(v.node, obj.FmtSharp), Nconv(v1.node, obj.FmtSharp), Tconv(t, 0), Tconv(v1.node.Type, 0), v.node.Addrtaken, v1.node.Addrtaken)
+				fmt.Printf("consider %v: maybe %v: type=%v,%v addrtaken=%v,%v\n", Nconv(v.node, obj.FmtSharp), Nconv(v1.node, obj.FmtSharp), t, v1.node.Type, v.node.Addrtaken, v1.node.Addrtaken)
 			}
 
 			// Require the types to match but also require the addrtaken bits to match.
@@ -786,11 +786,11 @@ func mergetemp(firstp *obj.Prog) {
 	}
 
 	if debugmerge > 0 && Debug['v'] != 0 {
-		fmt.Printf("%v [%d - %d]\n", Sconv(Curfn.Nname.Sym, 0), len(var_), nkill)
+		fmt.Printf("%v [%d - %d]\n", Curfn.Nname.Sym, len(var_), nkill)
 		var v *TempVar
 		for i := 0; i < len(var_); i++ {
 			v = &var_[i]
-			fmt.Printf("var %v %v %d-%d", Nconv(v.node, obj.FmtSharp), Tconv(v.node.Type, 0), v.start, v.end)
+			fmt.Printf("var %v %v %d-%d", Nconv(v.node, obj.FmtSharp), v.node.Type, v.start, v.end)
 			if v.addr != 0 {
 				fmt.Printf(" addr=1")
 			}
@@ -980,7 +980,7 @@ func nilopt(firstp *obj.Prog) {
 	Flowend(g)
 
 	if Debug_checknil > 1 {
-		fmt.Printf("%v: removed %d of %d nil checks\n", Sconv(Curfn.Nname.Sym, 0), nkill, ncheck)
+		fmt.Printf("%v: removed %d of %d nil checks\n", Curfn.Nname.Sym, nkill, ncheck)
 	}
 }
 
diff --git a/src/cmd/internal/gc/racewalk.go b/src/cmd/internal/gc/racewalk.go
index 1efd6393c1..934cfe7a19 100644
--- a/src/cmd/internal/gc/racewalk.go
+++ b/src/cmd/internal/gc/racewalk.go
@@ -77,11 +77,11 @@ func racewalk(fn *Node) {
 	fn.Func.Exit = list(fn.Func.Exit, nd)
 
 	if Debug['W'] != 0 {
-		s := fmt.Sprintf("after racewalk %v", Sconv(fn.Nname.Sym, 0))
+		s := fmt.Sprintf("after racewalk %v", fn.Nname.Sym)
 		dumplist(s, fn.Nbody)
-		s = fmt.Sprintf("enter %v", Sconv(fn.Nname.Sym, 0))
+		s = fmt.Sprintf("enter %v", fn.Nname.Sym)
 		dumplist(s, fn.Func.Enter)
-		s = fmt.Sprintf("exit %v", Sconv(fn.Nname.Sym, 0))
+		s = fmt.Sprintf("exit %v", fn.Nname.Sym)
 		dumplist(s, fn.Func.Exit)
 	}
 }
diff --git a/src/cmd/internal/gc/range.go b/src/cmd/internal/gc/range.go
index 979c76affb..03beb1c673 100644
--- a/src/cmd/internal/gc/range.go
+++ b/src/cmd/internal/gc/range.go
@@ -62,7 +62,7 @@ func typecheckrange(n *Node) {
 
 	case TCHAN:
 		if t.Chan&Crecv == 0 {
-			Yyerror("invalid operation: range %v (receive from send-only type %v)", Nconv(n.Right, 0), Tconv(n.Right.Type, 0))
+			Yyerror("invalid operation: range %v (receive from send-only type %v)", n.Right, n.Right.Type)
 			goto out
 		}
 
@@ -105,7 +105,7 @@ func typecheckrange(n *Node) {
 		if v1.Defn == n {
 			v1.Type = t1
 		} else if v1.Type != nil && assignop(t1, v1.Type, &why) == 0 {
-			Yyerror("cannot assign type %v to %v in range%s", Tconv(t1, 0), Nconv(v1, obj.FmtLong), why)
+			Yyerror("cannot assign type %v to %v in range%s", t1, Nconv(v1, obj.FmtLong), why)
 		}
 		checkassign(n, v1)
 	}
@@ -114,7 +114,7 @@ func typecheckrange(n *Node) {
 		if v2.Defn == n {
 			v2.Type = t2
 		} else if v2.Type != nil && assignop(t2, v2.Type, &why) == 0 {
-			Yyerror("cannot assign type %v to %v in range%s", Tconv(t2, 0), Nconv(v2, obj.FmtLong), why)
+			Yyerror("cannot assign type %v to %v in range%s", t2, Nconv(v2, obj.FmtLong), why)
 		}
 		checkassign(n, v2)
 	}
diff --git a/src/cmd/internal/gc/reflect.go b/src/cmd/internal/gc/reflect.go
index ef3ebe3537..725f224bf0 100644
--- a/src/cmd/internal/gc/reflect.go
+++ b/src/cmd/internal/gc/reflect.go
@@ -335,13 +335,13 @@ func methods(t *Type) *Sig {
 	var method *Sym
 	for f := mt.Xmethod; f != nil; f = f.Down {
 		if f.Etype != TFIELD {
-			Fatal("methods: not field %v", Tconv(f, 0))
+			Fatal("methods: not field %v", f)
 		}
 		if f.Type.Etype != TFUNC || f.Type.Thistuple == 0 {
-			Fatal("non-method on %v method %v %v\n", Tconv(mt, 0), Sconv(f.Sym, 0), Tconv(f, 0))
+			Fatal("non-method on %v method %v %v\n", mt, f.Sym, f)
 		}
 		if getthisx(f.Type).Type == nil {
-			Fatal("receiver with no type on %v method %v %v\n", Tconv(mt, 0), Sconv(f.Sym, 0), Tconv(f, 0))
+			Fatal("receiver with no type on %v method %v %v\n", mt, f.Sym, f)
 		}
 		if f.Nointerface {
 			continue
@@ -753,7 +753,7 @@ func dcommontype(s *Sym, ot int, t *Type) int {
 		i = 1
 	}
 	if i&(i-1) != 0 {
-		Fatal("invalid alignment %d for %v", t.Align, Tconv(t, 0))
+		Fatal("invalid alignment %d for %v", t.Align, t)
 	}
 	ot = duint8(s, ot, t.Align) // align
 	ot = duint8(s, ot, t.Align) // fieldAlign
@@ -876,7 +876,7 @@ func typesymprefix(prefix string, t *Type) *Sym {
 
 func typenamesym(t *Type) *Sym {
 	if t == nil || (Isptr[t.Etype] && t.Type == nil) || isideal(t) {
-		Fatal("typename %v", Tconv(t, 0))
+		Fatal("typename %v", t)
 	}
 	s := typesym(t)
 	if s.Def == nil {
@@ -949,7 +949,7 @@ func isreflexive(t *Type) bool {
 
 	case TARRAY:
 		if Isslice(t) {
-			Fatal("slice can't be a map key: %v", Tconv(t, 0))
+			Fatal("slice can't be a map key: %v", t)
 		}
 		return isreflexive(t.Type)
 
@@ -963,7 +963,7 @@ func isreflexive(t *Type) bool {
 		return true
 
 	default:
-		Fatal("bad type for map key: %v", Tconv(t, 0))
+		Fatal("bad type for map key: %v", t)
 		return false
 	}
 }
@@ -977,7 +977,7 @@ func dtypesym(t *Type) *Sym {
 	}
 
 	if isideal(t) {
-		Fatal("dtypesym %v", Tconv(t, 0))
+		Fatal("dtypesym %v", t)
 	}
 
 	s := typesym(t)
@@ -1631,6 +1631,6 @@ func gengcprog1(g *ProgGen, t *Type, xoffset *int64) {
 		*xoffset += t.Width - o
 
 	default:
-		Fatal("gengcprog1: unexpected type, %v", Tconv(t, 0))
+		Fatal("gengcprog1: unexpected type, %v", t)
 	}
 }
diff --git a/src/cmd/internal/gc/reg.go b/src/cmd/internal/gc/reg.go
index 66982ef22b..afe95230c7 100644
--- a/src/cmd/internal/gc/reg.go
+++ b/src/cmd/internal/gc/reg.go
@@ -1151,7 +1151,7 @@ func regopt(firstp *obj.Prog) {
 		}
 
 		if Debug['R'] != 0 && Debug['v'] != 0 {
-			fmt.Printf("bit=%2d addr=%d et=%v w=%-2d s=%v + %d\n", i, v.addr, Econv(int(v.etype), 0), v.width, Nconv(v.node, 0), v.offset)
+			fmt.Printf("bit=%2d addr=%d et=%v w=%-2d s=%v + %d\n", i, v.addr, Econv(int(v.etype), 0), v.width, v.node, v.offset)
 		}
 	}
 
@@ -1379,7 +1379,7 @@ loop2:
 		if rgp.regno != 0 {
 			if Debug['R'] != 0 && Debug['v'] != 0 {
 				v := &vars[rgp.varno]
-				fmt.Printf("registerize %v+%d (bit=%2d et=%v) in %v usedreg=%#x vreg=%#x\n", Nconv(v.node, 0), v.offset, rgp.varno, Econv(int(v.etype), 0), obj.Rconv(int(rgp.regno)), usedreg, vreg)
+				fmt.Printf("registerize %v+%d (bit=%2d et=%v) in %v usedreg=%#x vreg=%#x\n", v.node, v.offset, rgp.varno, Econv(int(v.etype), 0), obj.Rconv(int(rgp.regno)), usedreg, vreg)
 			}
 
 			paint3(rgp.enter, int(rgp.varno), vreg, int(rgp.regno))
diff --git a/src/cmd/internal/gc/sinit.go b/src/cmd/internal/gc/sinit.go
index 14aca86fa0..a9af9450ae 100644
--- a/src/cmd/internal/gc/sinit.go
+++ b/src/cmd/internal/gc/sinit.go
@@ -111,16 +111,16 @@ func init1(n *Node, out **NodeList) {
 		for l = initlist; l.N != nv; l = l.Next {
 		}
 		for ; l != nil; l = l.End {
-			fmt.Printf("\t%v %v refers to\n", l.N.Line(), Sconv(l.N.Sym, 0))
+			fmt.Printf("\t%v %v refers to\n", l.N.Line(), l.N.Sym)
 		}
 
 		// Print n -> ... -> nv.
 		for l = initlist; l.N != n; l = l.Next {
 		}
 		for ; l.N != nv; l = l.End {
-			fmt.Printf("\t%v %v refers to\n", l.N.Line(), Sconv(l.N.Sym, 0))
+			fmt.Printf("\t%v %v refers to\n", l.N.Line(), l.N.Sym)
 		}
-		fmt.Printf("\t%v %v\n", nv.Line(), Sconv(nv.Sym, 0))
+		fmt.Printf("\t%v %v\n", nv.Line(), nv.Sym)
 		errorexit()
 	}
 
@@ -162,7 +162,7 @@ func init1(n *Node, out **NodeList) {
 
 			init2(n.Defn.Right, out)
 			if Debug['j'] != 0 {
-				fmt.Printf("%v\n", Sconv(n.Sym, 0))
+				fmt.Printf("%v\n", n.Sym)
 			}
 			if isblank(n) || !staticinit(n, out) {
 				if Debug['%'] != 0 {
@@ -207,7 +207,7 @@ func init2(n *Node, out **NodeList) {
 	}
 
 	if n.Op == ONAME && n.Ninit != nil {
-		Fatal("name %v with ninit: %v\n", Sconv(n.Sym, 0), Nconv(n, obj.FmtSign))
+		Fatal("name %v with ninit: %v\n", n.Sym, Nconv(n, obj.FmtSign))
 	}
 
 	init1(n, out)
@@ -593,7 +593,7 @@ func structlit(ctxt int, pass int, n *Node, var_ *Node, init **NodeList) {
 	for nl := n.List; nl != nil; nl = nl.Next {
 		r = nl.N
 		if r.Op != OKEY {
-			Fatal("structlit: rhs not OKEY: %v", Nconv(r, 0))
+			Fatal("structlit: rhs not OKEY: %v", r)
 		}
 		index = r.Left
 		value = r.Right
@@ -660,7 +660,7 @@ func arraylit(ctxt int, pass int, n *Node, var_ *Node, init **NodeList) {
 	for l := n.List; l != nil; l = l.Next {
 		r = l.N
 		if r.Op != OKEY {
-			Fatal("arraylit: rhs not OKEY: %v", Nconv(r, 0))
+			Fatal("arraylit: rhs not OKEY: %v", r)
 		}
 		index = r.Left
 		value = r.Right
@@ -835,7 +835,7 @@ func slicelit(ctxt int, n *Node, var_ *Node, init **NodeList) {
 	for l := n.List; l != nil; l = l.Next {
 		r = l.N
 		if r.Op != OKEY {
-			Fatal("slicelit: rhs not OKEY: %v", Nconv(r, 0))
+			Fatal("slicelit: rhs not OKEY: %v", r)
 		}
 		index = r.Left
 		value = r.Right
@@ -892,7 +892,7 @@ func maplit(ctxt int, n *Node, var_ *Node, init **NodeList) {
 		r = l.N
 
 		if r.Op != OKEY {
-			Fatal("maplit: rhs not OKEY: %v", Nconv(r, 0))
+			Fatal("maplit: rhs not OKEY: %v", r)
 		}
 		index = r.Left
 		value = r.Right
@@ -943,7 +943,7 @@ func maplit(ctxt int, n *Node, var_ *Node, init **NodeList) {
 			r = l.N
 
 			if r.Op != OKEY {
-				Fatal("maplit: rhs not OKEY: %v", Nconv(r, 0))
+				Fatal("maplit: rhs not OKEY: %v", r)
 			}
 			index = r.Left
 			value = r.Right
@@ -1012,7 +1012,7 @@ func maplit(ctxt int, n *Node, var_ *Node, init **NodeList) {
 		r = l.N
 
 		if r.Op != OKEY {
-			Fatal("maplit: rhs not OKEY: %v", Nconv(r, 0))
+			Fatal("maplit: rhs not OKEY: %v", r)
 		}
 		index = r.Left
 		value = r.Right
diff --git a/src/cmd/internal/gc/subr.go b/src/cmd/internal/gc/subr.go
index 5b883d8e1d..cfe1b879ef 100644
--- a/src/cmd/internal/gc/subr.go
+++ b/src/cmd/internal/gc/subr.go
@@ -45,9 +45,9 @@ func adderrorname(n *Node) {
 	if n.Op != ODOT {
 		return
 	}
-	old := fmt.Sprintf("%v: undefined: %v\n", n.Line(), Nconv(n.Left, 0))
+	old := fmt.Sprintf("%v: undefined: %v\n", n.Line(), n.Left)
 	if len(errors) > 0 && int32(errors[len(errors)-1].lineno) == n.Lineno && errors[len(errors)-1].msg == old {
-		errors[len(errors)-1].msg = fmt.Sprintf("%v: undefined: %v in %v\n", n.Line(), Nconv(n.Left, 0), Nconv(n, 0))
+		errors[len(errors)-1].msg = fmt.Sprintf("%v: undefined: %v in %v\n", n.Line(), n.Left, n)
 	}
 }
 
@@ -398,7 +398,7 @@ func saveorignode(n *Node) {
 // the last field, total gives the size of the enclosing struct.
 func ispaddedfield(t *Type, total int64) bool {
 	if t.Etype != TFIELD {
-		Fatal("ispaddedfield called non-field %v", Tconv(t, 0))
+		Fatal("ispaddedfield called non-field %v", t)
 	}
 	if t.Down == nil {
 		return t.Width+t.Type.Width != total
@@ -514,7 +514,7 @@ func algtype1(t *Type, bad **Type) int {
 		return ret
 	}
 
-	Fatal("algtype1: unexpected type %v", Tconv(t, 0))
+	Fatal("algtype1: unexpected type %v", t)
 	return 0
 }
 
@@ -561,7 +561,7 @@ func maptype(key *Type, val *Type) *Type {
 		switch mtype {
 		default:
 			if atype == ANOEQ {
-				Yyerror("invalid map key type %v", Tconv(key, 0))
+				Yyerror("invalid map key type %v", key)
 			}
 
 			// will be resolved later.
@@ -696,7 +696,7 @@ func Nodconst(n *Node, t *Type, v int64) {
 	n.Type = t
 
 	if Isfloat[t.Etype] {
-		Fatal("nodconst: bad type %v", Tconv(t, 0))
+		Fatal("nodconst: bad type %v", t)
 	}
 }
 
@@ -986,7 +986,7 @@ func eqtype1(t1 *Type, t2 *Type, assumed_equal *TypePairList) bool {
 		t2 = t2.Type
 		for ; t1 != nil && t2 != nil; t1, t2 = t1.Down, t2.Down {
 			if t1.Etype != TFIELD || t2.Etype != TFIELD {
-				Fatal("struct/interface missing field: %v %v", Tconv(t1, 0), Tconv(t2, 0))
+				Fatal("struct/interface missing field: %v %v", t1, t2)
 			}
 			if t1.Sym != t2.Sym || t1.Embedded != t2.Embedded || !eqtype1(t1.Type, t2.Type, &l) || !eqnote(t1.Note, t2.Note) {
 				return false
@@ -1004,7 +1004,7 @@ func eqtype1(t1 *Type, t2 *Type, assumed_equal *TypePairList) bool {
 		t2 = t2.Type
 		for ; t1 != nil && t2 != nil; t1, t2 = t1.Down, t2.Down {
 			if t1.Etype != TSTRUCT || t2.Etype != TSTRUCT {
-				Fatal("func missing struct: %v %v", Tconv(t1, 0), Tconv(t2, 0))
+				Fatal("func missing struct: %v %v", t1, t2)
 			}
 
 			// Loop over fields in structs, ignoring argument names.
@@ -1012,7 +1012,7 @@ func eqtype1(t1 *Type, t2 *Type, assumed_equal *TypePairList) bool {
 			tb := t2.Type
 			for ; ta != nil && tb != nil; ta, tb = ta.Down, tb.Down {
 				if ta.Etype != TFIELD || tb.Etype != TFIELD {
-					Fatal("func struct missing field: %v %v", Tconv(ta, 0), Tconv(tb, 0))
+					Fatal("func struct missing field: %v %v", ta, tb)
 				}
 				if ta.Isddd != tb.Isddd || !eqtype1(ta.Type, tb.Type, &l) {
 					return false
@@ -1120,17 +1120,17 @@ func assignop(src *Type, dst *Type, why *string) int {
 
 		if why != nil {
 			if isptrto(src, TINTER) {
-				*why = fmt.Sprintf(":\n\t%v is pointer to interface, not interface", Tconv(src, 0))
+				*why = fmt.Sprintf(":\n\t%v is pointer to interface, not interface", src)
 			} else if have != nil && have.Sym == missing.Sym && have.Nointerface {
-				*why = fmt.Sprintf(":\n\t%v does not implement %v (%v method is marked 'nointerface')", Tconv(src, 0), Tconv(dst, 0), Sconv(missing.Sym, 0))
+				*why = fmt.Sprintf(":\n\t%v does not implement %v (%v method is marked 'nointerface')", src, dst, missing.Sym)
 			} else if have != nil && have.Sym == missing.Sym {
-				*why = fmt.Sprintf(":\n\t%v does not implement %v (wrong type for %v method)\n"+"\t\thave %v%v\n\t\twant %v%v", Tconv(src, 0), Tconv(dst, 0), Sconv(missing.Sym, 0), Sconv(have.Sym, 0), Tconv(have.Type, obj.FmtShort|obj.FmtByte), Sconv(missing.Sym, 0), Tconv(missing.Type, obj.FmtShort|obj.FmtByte))
+				*why = fmt.Sprintf(":\n\t%v does not implement %v (wrong type for %v method)\n"+"\t\thave %v%v\n\t\twant %v%v", src, dst, missing.Sym, have.Sym, Tconv(have.Type, obj.FmtShort|obj.FmtByte), missing.Sym, Tconv(missing.Type, obj.FmtShort|obj.FmtByte))
 			} else if ptr != 0 {
-				*why = fmt.Sprintf(":\n\t%v does not implement %v (%v method has pointer receiver)", Tconv(src, 0), Tconv(dst, 0), Sconv(missing.Sym, 0))
+				*why = fmt.Sprintf(":\n\t%v does not implement %v (%v method has pointer receiver)", src, dst, missing.Sym)
 			} else if have != nil {
-				*why = fmt.Sprintf(":\n\t%v does not implement %v (missing %v method)\n"+"\t\thave %v%v\n\t\twant %v%v", Tconv(src, 0), Tconv(dst, 0), Sconv(missing.Sym, 0), Sconv(have.Sym, 0), Tconv(have.Type, obj.FmtShort|obj.FmtByte), Sconv(missing.Sym, 0), Tconv(missing.Type, obj.FmtShort|obj.FmtByte))
+				*why = fmt.Sprintf(":\n\t%v does not implement %v (missing %v method)\n"+"\t\thave %v%v\n\t\twant %v%v", src, dst, missing.Sym, have.Sym, Tconv(have.Type, obj.FmtShort|obj.FmtByte), missing.Sym, Tconv(missing.Type, obj.FmtShort|obj.FmtByte))
 			} else {
-				*why = fmt.Sprintf(":\n\t%v does not implement %v (missing %v method)", Tconv(src, 0), Tconv(dst, 0), Sconv(missing.Sym, 0))
+				*why = fmt.Sprintf(":\n\t%v does not implement %v (missing %v method)", src, dst, missing.Sym)
 			}
 		}
 
@@ -1139,7 +1139,7 @@ func assignop(src *Type, dst *Type, why *string) int {
 
 	if isptrto(dst, TINTER) {
 		if why != nil {
-			*why = fmt.Sprintf(":\n\t%v is pointer to interface, not interface", Tconv(dst, 0))
+			*why = fmt.Sprintf(":\n\t%v is pointer to interface, not interface", dst)
 		}
 		return 0
 	}
@@ -1333,7 +1333,7 @@ func assignconvfn(n *Node, t *Type, context func() string) *Node {
 	var why string
 	op := assignop(n.Type, t, &why)
 	if op == 0 {
-		Yyerror("cannot use %v as type %v in %s%s", Nconv(n, obj.FmtLong), Tconv(t, 0), context(), why)
+		Yyerror("cannot use %v as type %v in %s%s", Nconv(n, obj.FmtLong), t, context(), why)
 		op = OCONV
 	}
 
@@ -1564,7 +1564,7 @@ func frame(context int) {
 		fmt.Printf("--- external frame ---\n")
 		l = externdcl
 	} else if Curfn != nil {
-		fmt.Printf("--- %v frame ---\n", Sconv(Curfn.Nname.Sym, 0))
+		fmt.Printf("--- %v frame ---\n", Curfn.Nname.Sym)
 		l = Curfn.Func.Dcl
 	} else {
 		return
@@ -1580,10 +1580,10 @@ func frame(context int) {
 		}
 		switch n.Op {
 		case ONAME:
-			fmt.Printf("%v %v G%d %v width=%d\n", Oconv(int(n.Op), 0), Sconv(n.Sym, 0), n.Vargen, Tconv(n.Type, 0), w)
+			fmt.Printf("%v %v G%d %v width=%d\n", Oconv(int(n.Op), 0), n.Sym, n.Vargen, n.Type, w)
 
 		case OTYPE:
-			fmt.Printf("%v %v width=%d\n", Oconv(int(n.Op), 0), Tconv(n.Type, 0), w)
+			fmt.Printf("%v %v width=%d\n", Oconv(int(n.Op), 0), n.Type, w)
 		}
 	}
 }
@@ -1651,10 +1651,10 @@ out:
 func badtype(o int, tl *Type, tr *Type) {
 	fmt_ := ""
 	if tl != nil {
-		fmt_ += fmt.Sprintf("\n\t%v", Tconv(tl, 0))
+		fmt_ += fmt.Sprintf("\n\t%v", tl)
 	}
 	if tr != nil {
-		fmt_ += fmt.Sprintf("\n\t%v", Tconv(tr, 0))
+		fmt_ += fmt.Sprintf("\n\t%v", tr)
 	}
 
 	// common mistake: *struct and *interface.
@@ -1695,14 +1695,14 @@ func Structfirst(s *Iter, nn **Type) *Type {
 	}
 
 	if t.Etype != TFIELD {
-		Fatal("structfirst: not field %v", Tconv(t, 0))
+		Fatal("structfirst: not field %v", t)
 	}
 
 	s.T = t
 	return t
 
 bad:
-	Fatal("structfirst: not struct %v", Tconv(n, 0))
+	Fatal("structfirst: not struct %v", n)
 
 	return nil
 }
@@ -1715,7 +1715,7 @@ func structnext(s *Iter) *Type {
 	}
 
 	if t.Etype != TFIELD {
-		Fatal("structnext: not struct %v", Tconv(n, 0))
+		Fatal("structnext: not struct %v", n)
 
 		return nil
 	}
@@ -1749,7 +1749,7 @@ func funcfirst(s *Iter, t *Type) *Type {
 	return fp
 
 bad:
-	Fatal("funcfirst: not func %v", Tconv(t, 0))
+	Fatal("funcfirst: not func %v", t)
 	return nil
 }
 
@@ -1765,21 +1765,21 @@ func funcnext(s *Iter) *Type {
 
 func getthis(t *Type) **Type {
 	if t.Etype != TFUNC {
-		Fatal("getthis: not a func %v", Tconv(t, 0))
+		Fatal("getthis: not a func %v", t)
 	}
 	return &t.Type
 }
 
 func Getoutarg(t *Type) **Type {
 	if t.Etype != TFUNC {
-		Fatal("getoutarg: not a func %v", Tconv(t, 0))
+		Fatal("getoutarg: not a func %v", t)
 	}
 	return &t.Type.Down
 }
 
 func getinarg(t *Type) **Type {
 	if t.Etype != TFUNC {
-		Fatal("getinarg: not a func %v", Tconv(t, 0))
+		Fatal("getinarg: not a func %v", t)
 	}
 	return &t.Type.Down.Down
 }
@@ -1896,7 +1896,7 @@ func safeexpr(n *Node, init **NodeList) *Node {
 
 	// make a copy; must not be used as an lvalue
 	if islvalue(n) {
-		Fatal("missing lvalue case in safeexpr: %v", Nconv(n, 0))
+		Fatal("missing lvalue case in safeexpr: %v", n)
 	}
 	return cheapexpr(n, init)
 }
@@ -1940,11 +1940,11 @@ func Setmaxarg(t *Type, extra int32) {
 	dowidth(t)
 	w := t.Argwid
 	if w >= Thearch.MAXWIDTH {
-		Fatal("bad argwid %v", Tconv(t, 0))
+		Fatal("bad argwid %v", t)
 	}
 	w += int64(extra)
 	if w >= Thearch.MAXWIDTH {
-		Fatal("bad argwid %d + %v", extra, Tconv(t, 0))
+		Fatal("bad argwid %d + %v", extra, t)
 	}
 	if w > Maxarg {
 		Maxarg = w
@@ -2073,7 +2073,7 @@ func adddot(n *Node) *Node {
 		c = adddot1(s, t, d, nil, 0)
 		if c > 0 {
 			if c > 1 {
-				Yyerror("ambiguous selector %v", Nconv(n, 0))
+				Yyerror("ambiguous selector %v", n)
 				n.Left = nil
 				return n
 			}
@@ -2311,7 +2311,7 @@ var genwrapper_linehistdone int = 0
 
 func genwrapper(rcvr *Type, method *Type, newnam *Sym, iface int) {
 	if false && Debug['r'] != 0 {
-		fmt.Printf("genwrapper rcvrtype=%v method=%v newnam=%v\n", Tconv(rcvr, 0), Tconv(method, 0), Sconv(newnam, 0))
+		fmt.Printf("genwrapper rcvrtype=%v method=%v newnam=%v\n", rcvr, method, newnam)
 	}
 
 	lexlineno++
@@ -2514,7 +2514,7 @@ func hashfor(t *Type) *Node {
  */
 func genhash(sym *Sym, t *Type) {
 	if Debug['r'] != 0 {
-		fmt.Printf("genhash %v %v\n", Sconv(sym, 0), Tconv(t, 0))
+		fmt.Printf("genhash %v %v\n", sym, t)
 	}
 
 	lineno = 1 // less confusing than end of input
@@ -2546,11 +2546,11 @@ func genhash(sym *Sym, t *Type) {
 	// so t must be either an array or a struct.
 	switch t.Etype {
 	default:
-		Fatal("genhash %v", Tconv(t, 0))
+		Fatal("genhash %v", t)
 
 	case TARRAY:
 		if Isslice(t) {
-			Fatal("genhash %v", Tconv(t, 0))
+			Fatal("genhash %v", t)
 		}
 
 		// An array of pure memory would be handled by the
@@ -2766,7 +2766,7 @@ func eqmem(p *Node, q *Node, field *Node, size int64) *Node {
  */
 func geneq(sym *Sym, t *Type) {
 	if Debug['r'] != 0 {
-		fmt.Printf("geneq %v %v\n", Sconv(sym, 0), Tconv(t, 0))
+		fmt.Printf("geneq %v %v\n", sym, t)
 	}
 
 	lineno = 1 // less confusing than end of input
@@ -2797,11 +2797,11 @@ func geneq(sym *Sym, t *Type) {
 	// so t must be either an array or a struct.
 	switch t.Etype {
 	default:
-		Fatal("geneq %v", Tconv(t, 0))
+		Fatal("geneq %v", t)
 
 	case TARRAY:
 		if Isslice(t) {
-			Fatal("geneq %v", Tconv(t, 0))
+			Fatal("geneq %v", t)
 		}
 
 		// An array of pure memory would be handled by the
@@ -2931,7 +2931,7 @@ func ifacelookdot(s *Sym, t *Type, followptr *int, ignorecase int) *Type {
 	for d := 0; d < len(dotlist); d++ {
 		c = adddot1(s, t, d, &m, ignorecase)
 		if c > 1 {
-			Yyerror("%v.%v is ambiguous", Tconv(t, 0), Sconv(s, 0))
+			Yyerror("%v.%v is ambiguous", t, s)
 			return nil
 		}
 
@@ -2944,7 +2944,7 @@ func ifacelookdot(s *Sym, t *Type, followptr *int, ignorecase int) *Type {
 			}
 
 			if m.Type.Etype != TFUNC || m.Type.Thistuple == 0 {
-				Yyerror("%v.%v is a field, not a method", Tconv(t, 0), Sconv(s, 0))
+				Yyerror("%v.%v is a field, not a method", t, s)
 				return nil
 			}
 
@@ -3134,7 +3134,7 @@ func tounsigned(t *Type) *Type {
 	// that this relation is immutable
 	switch t.Etype {
 	default:
-		fmt.Printf("tounsigned: unknown type %v\n", Tconv(t, 0))
+		fmt.Printf("tounsigned: unknown type %v\n", t)
 		t = nil
 
 	case TINT:
diff --git a/src/cmd/internal/gc/swt.go b/src/cmd/internal/gc/swt.go
index 793a0d6235..7cb632cebe 100644
--- a/src/cmd/internal/gc/swt.go
+++ b/src/cmd/internal/gc/swt.go
@@ -94,7 +94,7 @@ func typecheckswitch(n *Node) {
 			case t.Etype == TARRAY && Isfixedarray(t) && algtype1(t, nil) == ANOEQ:
 				Yyerror("cannot switch on %v", Nconv(n.Ntest, obj.FmtLong))
 			case t.Etype == TSTRUCT && algtype1(t, &badtype) == ANOEQ:
-				Yyerror("cannot switch on %v (struct containing %v cannot be compared)", Nconv(n.Ntest, obj.FmtLong), Tconv(badtype, 0))
+				Yyerror("cannot switch on %v (struct containing %v cannot be compared)", Nconv(n.Ntest, obj.FmtLong), badtype)
 			case t.Etype == TFUNC:
 				nilonly = "func"
 			case t.Etype == TMAP:
@@ -131,15 +131,15 @@ func typecheckswitch(n *Node) {
 					defaultlit(&ll.N, t)
 					switch {
 					case ll.N.Op == OTYPE:
-						Yyerror("type %v is not an expression", Tconv(ll.N.Type, 0))
+						Yyerror("type %v is not an expression", ll.N.Type)
 					case ll.N.Type != nil && assignop(ll.N.Type, t, nil) == 0 && assignop(t, ll.N.Type, nil) == 0:
 						if n.Ntest != nil {
-							Yyerror("invalid case %v in switch on %v (mismatched types %v and %v)", Nconv(ll.N, 0), Nconv(n.Ntest, 0), Tconv(ll.N.Type, 0), Tconv(t, 0))
+							Yyerror("invalid case %v in switch on %v (mismatched types %v and %v)", ll.N, n.Ntest, ll.N.Type, t)
 						} else {
-							Yyerror("invalid case %v in switch (mismatched types %v and bool)", Nconv(ll.N, 0), Tconv(ll.N.Type, 0))
+							Yyerror("invalid case %v in switch (mismatched types %v and bool)", ll.N, ll.N.Type)
 						}
 					case nilonly != "" && !Isconst(ll.N, CTNIL):
-						Yyerror("invalid case %v in switch (can only compare %s %v to nil)", Nconv(ll.N, 0), nilonly, Nconv(n.Ntest, 0))
+						Yyerror("invalid case %v in switch (can only compare %s %v to nil)", ll.N, nilonly, n.Ntest)
 					}
 
 				// type switch
@@ -154,9 +154,9 @@ func typecheckswitch(n *Node) {
 						ll.N = n.Ntest.Right
 					case ll.N.Type.Etype != TINTER && t.Etype == TINTER && !implements(ll.N.Type, t, &missing, &have, &ptr):
 						if have != nil && missing.Broke == 0 && have.Broke == 0 {
-							Yyerror("impossible type switch case: %v cannot have dynamic type %v"+" (wrong type for %v method)\n\thave %v%v\n\twant %v%v", Nconv(n.Ntest.Right, obj.FmtLong), Tconv(ll.N.Type, 0), Sconv(missing.Sym, 0), Sconv(have.Sym, 0), Tconv(have.Type, obj.FmtShort), Sconv(missing.Sym, 0), Tconv(missing.Type, obj.FmtShort))
+							Yyerror("impossible type switch case: %v cannot have dynamic type %v"+" (wrong type for %v method)\n\thave %v%v\n\twant %v%v", Nconv(n.Ntest.Right, obj.FmtLong), ll.N.Type, missing.Sym, have.Sym, Tconv(have.Type, obj.FmtShort), missing.Sym, Tconv(missing.Type, obj.FmtShort))
 						} else if missing.Broke == 0 {
-							Yyerror("impossible type switch case: %v cannot have dynamic type %v"+" (missing %v method)", Nconv(n.Ntest.Right, obj.FmtLong), Tconv(ll.N.Type, 0), Sconv(missing.Sym, 0))
+							Yyerror("impossible type switch case: %v cannot have dynamic type %v"+" (missing %v method)", Nconv(n.Ntest.Right, obj.FmtLong), ll.N.Type, missing.Sym)
 						}
 					}
 				}
@@ -481,7 +481,7 @@ func caseClauses(sw *Node, kind int) []*caseClause {
 					break
 				}
 				if Eqtype(c1.node.Left.Type, c2.node.Left.Type) {
-					yyerrorl(int(c2.node.Lineno), "duplicate case %v in type switch\n\tprevious case at %v", Tconv(c2.node.Left.Type, 0), c1.node.Line())
+					yyerrorl(int(c2.node.Lineno), "duplicate case %v in type switch\n\tprevious case at %v", c2.node.Left.Type, c1.node.Line())
 				}
 			}
 		}
@@ -497,7 +497,7 @@ func caseClauses(sw *Node, kind int) []*caseClause {
 				continue
 			}
 			setlineno(c2.node)
-			Yyerror("duplicate case %v in switch\n\tprevious case at %v", Nconv(c1.node.Left, 0), c1.node.Line())
+			Yyerror("duplicate case %v in switch\n\tprevious case at %v", c1.node.Left, c1.node.Line())
 		}
 	}
 
diff --git a/src/cmd/internal/gc/typecheck.go b/src/cmd/internal/gc/typecheck.go
index 5c31e3e401..a637780fc0 100644
--- a/src/cmd/internal/gc/typecheck.go
+++ b/src/cmd/internal/gc/typecheck.go
@@ -104,7 +104,7 @@ func sprint_depchain(fmt_ *string, stack *NodeList, cur *Node, first *Node) {
 			if l.N != first {
 				sprint_depchain(fmt_, l.Next, l.N, first)
 			}
-			*fmt_ += fmt.Sprintf("\n\t%v: %v uses %v", l.N.Line(), Nconv(l.N, 0), Nconv(cur, 0))
+			*fmt_ += fmt.Sprintf("\n\t%v: %v uses %v", l.N.Line(), l.N, cur)
 			return
 		}
 	}
@@ -163,12 +163,12 @@ func typecheck(np **Node, top int) *Node {
 		// We can already diagnose variables used as types.
 		case ONAME:
 			if top&(Erv|Etype) == Etype {
-				Yyerror("%v is not a type", Nconv(n, 0))
+				Yyerror("%v is not a type", n)
 			}
 
 		case OLITERAL:
 			if top&(Erv|Etype) == Etype {
-				Yyerror("%v is not a type", Nconv(n, 0))
+				Yyerror("%v is not a type", n)
 				break
 			}
 
@@ -180,9 +180,9 @@ func typecheck(np **Node, top int) *Node {
 		if nsavederrors+nerrors == 0 {
 			fmt_ = ""
 			for l := typecheck_tcstack; l != nil; l = l.Next {
-				fmt_ += fmt.Sprintf("\n\t%v %v", l.N.Line(), Nconv(l.N, 0))
+				fmt_ += fmt.Sprintf("\n\t%v %v", l.N.Line(), l.N)
 			}
-			Yyerror("typechecking loop involving %v%s", Nconv(n, 0), fmt_)
+			Yyerror("typechecking loop involving %v%s", n, fmt_)
 		}
 
 		lineno = int32(lno)
@@ -277,7 +277,7 @@ func typecheck1(np **Node, top int) {
 
 	if n.Sym != nil {
 		if n.Op == ONAME && n.Etype != 0 && top&Ecall == 0 {
-			Yyerror("use of builtin %v not in function call", Sconv(n.Sym, 0))
+			Yyerror("use of builtin %v not in function call", n.Sym)
 			n.Type = nil
 			return
 		}
@@ -334,7 +334,7 @@ OpSwitch:
 		}
 
 		if top&Ecall == 0 && isunsafebuiltin(n) {
-			Yyerror("%v is not an expression, must be called", Nconv(n, 0))
+			Yyerror("%v is not an expression, must be called", n)
 			n.Type = nil
 			return
 		}
@@ -343,7 +343,7 @@ OpSwitch:
 		break OpSwitch
 
 	case OPACK:
-		Yyerror("use of package %v without selector", Sconv(n.Sym, 0))
+		Yyerror("use of package %v without selector", n.Sym)
 		n.Type = nil
 		return
 
@@ -387,9 +387,9 @@ OpSwitch:
 
 			default:
 				if l.Type != nil && Isint[l.Type.Etype] && l.Op != OLITERAL {
-					Yyerror("non-constant array bound %v", Nconv(l, 0))
+					Yyerror("non-constant array bound %v", l)
 				} else {
-					Yyerror("invalid array bound %v", Nconv(l, 0))
+					Yyerror("invalid array bound %v", l)
 				}
 				n.Type = nil
 				return
@@ -566,14 +566,14 @@ OpSwitch:
 			n.Right = r
 			t := r.Type
 			if !Isint[t.Etype] || Issigned[t.Etype] {
-				Yyerror("invalid operation: %v (shift count type %v, must be unsigned integer)", Nconv(n, 0), Tconv(r.Type, 0))
+				Yyerror("invalid operation: %v (shift count type %v, must be unsigned integer)", n, r.Type)
 				n.Type = nil
 				return
 			}
 
 			t = l.Type
 			if t != nil && t.Etype != TIDEAL && !Isint[t.Etype] {
-				Yyerror("invalid operation: %v (shift of type %v)", Nconv(n, 0), Tconv(t, 0))
+				Yyerror("invalid operation: %v (shift of type %v)", n, t)
 				n.Type = nil
 				return
 			}
@@ -615,7 +615,7 @@ OpSwitch:
 				aop = assignop(l.Type, r.Type, nil)
 				if aop != 0 {
 					if Isinter(r.Type) && !Isinter(l.Type) && algtype1(l.Type, nil) == ANOEQ {
-						Yyerror("invalid operation: %v (operator %v not defined on %s)", Nconv(n, 0), Oconv(int(op), 0), typekind(l.Type))
+						Yyerror("invalid operation: %v (operator %v not defined on %s)", n, Oconv(int(op), 0), typekind(l.Type))
 						n.Type = nil
 						return
 					}
@@ -637,7 +637,7 @@ OpSwitch:
 				aop = assignop(r.Type, l.Type, nil)
 				if aop != 0 {
 					if Isinter(l.Type) && !Isinter(r.Type) && algtype1(r.Type, nil) == ANOEQ {
-						Yyerror("invalid operation: %v (operator %v not defined on %s)", Nconv(n, 0), Oconv(int(op), 0), typekind(r.Type))
+						Yyerror("invalid operation: %v (operator %v not defined on %s)", n, Oconv(int(op), 0), typekind(r.Type))
 						n.Type = nil
 						return
 					}
@@ -661,20 +661,20 @@ OpSwitch:
 		if t.Etype != TIDEAL && !Eqtype(l.Type, r.Type) {
 			defaultlit2(&l, &r, 1)
 			if n.Op == OASOP && n.Implicit {
-				Yyerror("invalid operation: %v (non-numeric type %v)", Nconv(n, 0), Tconv(l.Type, 0))
+				Yyerror("invalid operation: %v (non-numeric type %v)", n, l.Type)
 				n.Type = nil
 				return
 			}
 
 			if Isinter(r.Type) == Isinter(l.Type) || aop == 0 {
-				Yyerror("invalid operation: %v (mismatched types %v and %v)", Nconv(n, 0), Tconv(l.Type, 0), Tconv(r.Type, 0))
+				Yyerror("invalid operation: %v (mismatched types %v and %v)", n, l.Type, r.Type)
 				n.Type = nil
 				return
 			}
 		}
 
 		if !okfor[op][et] {
-			Yyerror("invalid operation: %v (operator %v not defined on %s)", Nconv(n, 0), Oconv(int(op), 0), typekind(t))
+			Yyerror("invalid operation: %v (operator %v not defined on %s)", n, Oconv(int(op), 0), typekind(t))
 			n.Type = nil
 			return
 		}
@@ -682,32 +682,32 @@ OpSwitch:
 		// okfor allows any array == array, map == map, func == func.
 		// restrict to slice/map/func == nil and nil == slice/map/func.
 		if Isfixedarray(l.Type) && algtype1(l.Type, nil) == ANOEQ {
-			Yyerror("invalid operation: %v (%v cannot be compared)", Nconv(n, 0), Tconv(l.Type, 0))
+			Yyerror("invalid operation: %v (%v cannot be compared)", n, l.Type)
 			n.Type = nil
 			return
 		}
 
 		if Isslice(l.Type) && !isnil(l) && !isnil(r) {
-			Yyerror("invalid operation: %v (slice can only be compared to nil)", Nconv(n, 0))
+			Yyerror("invalid operation: %v (slice can only be compared to nil)", n)
 			n.Type = nil
 			return
 		}
 
 		if l.Type.Etype == TMAP && !isnil(l) && !isnil(r) {
-			Yyerror("invalid operation: %v (map can only be compared to nil)", Nconv(n, 0))
+			Yyerror("invalid operation: %v (map can only be compared to nil)", n)
 			n.Type = nil
 			return
 		}
 
 		if l.Type.Etype == TFUNC && !isnil(l) && !isnil(r) {
-			Yyerror("invalid operation: %v (func can only be compared to nil)", Nconv(n, 0))
+			Yyerror("invalid operation: %v (func can only be compared to nil)", n)
 			n.Type = nil
 			return
 		}
 
 		var badtype *Type
 		if l.Type.Etype == TSTRUCT && algtype1(l.Type, &badtype) == ANOEQ {
-			Yyerror("invalid operation: %v (struct containing %v cannot be compared)", Nconv(n, 0), Tconv(badtype, 0))
+			Yyerror("invalid operation: %v (struct containing %v cannot be compared)", n, badtype)
 			n.Type = nil
 			return
 		}
@@ -792,7 +792,7 @@ OpSwitch:
 			return
 		}
 		if !okfor[n.Op][t.Etype] {
-			Yyerror("invalid operation: %v %v", Oconv(int(n.Op), 0), Tconv(t, 0))
+			Yyerror("invalid operation: %v %v", Oconv(int(n.Op), 0), t)
 			n.Type = nil
 			return
 		}
@@ -822,7 +822,7 @@ OpSwitch:
 		}
 
 		if l.Orig != l && l.Op == ONAME {
-			Fatal("found non-orig name node %v", Nconv(l, 0))
+			Fatal("found non-orig name node %v", l)
 		}
 		l.Addrtaken = true
 		if l.Closure != nil {
@@ -878,16 +878,16 @@ OpSwitch:
 		if n.Left.Op == OTYPE {
 			if !looktypedot(n, t, 0) {
 				if looktypedot(n, t, 1) {
-					Yyerror("%v undefined (cannot refer to unexported method %v)", Nconv(n, 0), Sconv(n.Right.Sym, 0))
+					Yyerror("%v undefined (cannot refer to unexported method %v)", n, n.Right.Sym)
 				} else {
-					Yyerror("%v undefined (type %v has no method %v)", Nconv(n, 0), Tconv(t, 0), Sconv(n.Right.Sym, 0))
+					Yyerror("%v undefined (type %v has no method %v)", n, t, n.Right.Sym)
 				}
 				n.Type = nil
 				return
 			}
 
 			if n.Type.Etype != TFUNC || n.Type.Thistuple != 1 {
-				Yyerror("type %v has no method %v", Tconv(n.Left.Type, 0), Sconv(n.Right.Sym, obj.FmtShort))
+				Yyerror("type %v has no method %v", n.Left.Type, Sconv(n.Right.Sym, obj.FmtShort))
 				n.Type = nil
 				n.Type = nil
 				return
@@ -920,9 +920,9 @@ OpSwitch:
 
 		if !lookdot(n, t, 0) {
 			if lookdot(n, t, 1) {
-				Yyerror("%v undefined (cannot refer to unexported field or method %v)", Nconv(n, 0), Sconv(n.Right.Sym, 0))
+				Yyerror("%v undefined (cannot refer to unexported field or method %v)", n, n.Right.Sym)
 			} else {
-				Yyerror("%v undefined (type %v has no field or method %v)", Nconv(n, 0), Tconv(n.Left.Type, 0), Sconv(n.Right.Sym, 0))
+				Yyerror("%v undefined (type %v has no field or method %v)", n, n.Left.Type, n.Right.Sym)
 			}
 			n.Type = nil
 			return
@@ -954,7 +954,7 @@ OpSwitch:
 			return
 		}
 		if !Isinter(t) {
-			Yyerror("invalid type assertion: %v (non-interface type %v on left)", Nconv(n, 0), Tconv(t, 0))
+			Yyerror("invalid type assertion: %v (non-interface type %v on left)", n, t)
 			n.Type = nil
 			return
 		}
@@ -975,13 +975,13 @@ OpSwitch:
 			var ptr int
 			if !implements(n.Type, t, &missing, &have, &ptr) {
 				if have != nil && have.Sym == missing.Sym {
-					Yyerror("impossible type assertion:\n\t%v does not implement %v (wrong type for %v method)\n"+"\t\thave %v%v\n\t\twant %v%v", Tconv(n.Type, 0), Tconv(t, 0), Sconv(missing.Sym, 0), Sconv(have.Sym, 0), Tconv(have.Type, obj.FmtShort|obj.FmtByte), Sconv(missing.Sym, 0), Tconv(missing.Type, obj.FmtShort|obj.FmtByte))
+					Yyerror("impossible type assertion:\n\t%v does not implement %v (wrong type for %v method)\n"+"\t\thave %v%v\n\t\twant %v%v", n.Type, t, missing.Sym, have.Sym, Tconv(have.Type, obj.FmtShort|obj.FmtByte), missing.Sym, Tconv(missing.Type, obj.FmtShort|obj.FmtByte))
 				} else if ptr != 0 {
-					Yyerror("impossible type assertion:\n\t%v does not implement %v (%v method has pointer receiver)", Tconv(n.Type, 0), Tconv(t, 0), Sconv(missing.Sym, 0))
+					Yyerror("impossible type assertion:\n\t%v does not implement %v (%v method has pointer receiver)", n.Type, t, missing.Sym)
 				} else if have != nil {
-					Yyerror("impossible type assertion:\n\t%v does not implement %v (missing %v method)\n"+"\t\thave %v%v\n\t\twant %v%v", Tconv(n.Type, 0), Tconv(t, 0), Sconv(missing.Sym, 0), Sconv(have.Sym, 0), Tconv(have.Type, obj.FmtShort|obj.FmtByte), Sconv(missing.Sym, 0), Tconv(missing.Type, obj.FmtShort|obj.FmtByte))
+					Yyerror("impossible type assertion:\n\t%v does not implement %v (missing %v method)\n"+"\t\thave %v%v\n\t\twant %v%v", n.Type, t, missing.Sym, have.Sym, Tconv(have.Type, obj.FmtShort|obj.FmtByte), missing.Sym, Tconv(missing.Type, obj.FmtShort|obj.FmtByte))
 				} else {
-					Yyerror("impossible type assertion:\n\t%v does not implement %v (missing %v method)", Tconv(n.Type, 0), Tconv(t, 0), Sconv(missing.Sym, 0))
+					Yyerror("impossible type assertion:\n\t%v does not implement %v (missing %v method)", n.Type, t, missing.Sym)
 				}
 				n.Type = nil
 				return
@@ -1005,7 +1005,7 @@ OpSwitch:
 		}
 		switch t.Etype {
 		default:
-			Yyerror("invalid operation: %v (type %v does not support indexing)", Nconv(n, 0), Tconv(t, 0))
+			Yyerror("invalid operation: %v (type %v does not support indexing)", n, t)
 			n.Type = nil
 			return
 
@@ -1026,20 +1026,20 @@ OpSwitch:
 			}
 
 			if n.Right.Type != nil && !Isint[n.Right.Type.Etype] {
-				Yyerror("non-integer %s index %v", why, Nconv(n.Right, 0))
+				Yyerror("non-integer %s index %v", why, n.Right)
 				break
 			}
 
 			if Isconst(n.Right, CTINT) {
 				x := Mpgetfix(n.Right.Val.U.Xval)
 				if x < 0 {
-					Yyerror("invalid %s index %v (index must be non-negative)", why, Nconv(n.Right, 0))
+					Yyerror("invalid %s index %v (index must be non-negative)", why, n.Right)
 				} else if Isfixedarray(t) && t.Bound > 0 && x >= t.Bound {
-					Yyerror("invalid array index %v (out of bounds for %d-element array)", Nconv(n.Right, 0), t.Bound)
+					Yyerror("invalid array index %v (out of bounds for %d-element array)", n.Right, t.Bound)
 				} else if Isconst(n.Left, CTSTR) && x >= int64(len(n.Left.Val.U.Sval)) {
-					Yyerror("invalid string index %v (out of bounds for %d-byte string)", Nconv(n.Right, 0), len(n.Left.Val.U.Sval))
+					Yyerror("invalid string index %v (out of bounds for %d-byte string)", n.Right, len(n.Left.Val.U.Sval))
 				} else if Mpcmpfixfix(n.Right.Val.U.Xval, Maxintval[TINT]) > 0 {
-					Yyerror("invalid %s index %v (index too large)", why, Nconv(n.Right, 0))
+					Yyerror("invalid %s index %v (index too large)", why, n.Right)
 				}
 			}
 
@@ -1066,13 +1066,13 @@ OpSwitch:
 			return
 		}
 		if t.Etype != TCHAN {
-			Yyerror("invalid operation: %v (receive from non-chan type %v)", Nconv(n, 0), Tconv(t, 0))
+			Yyerror("invalid operation: %v (receive from non-chan type %v)", n, t)
 			n.Type = nil
 			return
 		}
 
 		if t.Chan&Crecv == 0 {
-			Yyerror("invalid operation: %v (receive from send-only type %v)", Nconv(n, 0), Tconv(t, 0))
+			Yyerror("invalid operation: %v (receive from send-only type %v)", n, t)
 			n.Type = nil
 			return
 		}
@@ -1092,13 +1092,13 @@ OpSwitch:
 			return
 		}
 		if t.Etype != TCHAN {
-			Yyerror("invalid operation: %v (send to non-chan type %v)", Nconv(n, 0), Tconv(t, 0))
+			Yyerror("invalid operation: %v (send to non-chan type %v)", n, t)
 			n.Type = nil
 			return
 		}
 
 		if t.Chan&Csend == 0 {
-			Yyerror("invalid operation: %v (send to receive-only type %v)", Nconv(n, 0), Tconv(t, 0))
+			Yyerror("invalid operation: %v (send to receive-only type %v)", n, t)
 			n.Type = nil
 			return
 		}
@@ -1128,7 +1128,7 @@ OpSwitch:
 		l := n.Left
 		if Isfixedarray(l.Type) {
 			if !islvalue(n.Left) {
-				Yyerror("invalid operation %v (slice of unaddressable value)", Nconv(n, 0))
+				Yyerror("invalid operation %v (slice of unaddressable value)", n)
 				n.Type = nil
 				return
 			}
@@ -1158,7 +1158,7 @@ OpSwitch:
 		} else if Isslice(t) {
 			n.Type = t
 		} else {
-			Yyerror("cannot slice %v (type %v)", Nconv(l, 0), Tconv(t, 0))
+			Yyerror("cannot slice %v (type %v)", l, t)
 			n.Type = nil
 			return
 		}
@@ -1192,7 +1192,7 @@ OpSwitch:
 		l := n.Left
 		if Isfixedarray(l.Type) {
 			if !islvalue(n.Left) {
-				Yyerror("invalid operation %v (slice of unaddressable value)", Nconv(n, 0))
+				Yyerror("invalid operation %v (slice of unaddressable value)", n)
 				n.Type = nil
 				return
 			}
@@ -1209,7 +1209,7 @@ OpSwitch:
 			return
 		}
 		if Istype(t, TSTRING) {
-			Yyerror("invalid operation %v (3-index slice of string)", Nconv(n, 0))
+			Yyerror("invalid operation %v (3-index slice of string)", n)
 			n.Type = nil
 			return
 		}
@@ -1225,7 +1225,7 @@ OpSwitch:
 		} else if Isslice(t) {
 			n.Type = t
 		} else {
-			Yyerror("cannot slice %v (type %v)", Nconv(l, 0), Tconv(t, 0))
+			Yyerror("cannot slice %v (type %v)", l, t)
 			n.Type = nil
 			return
 		}
@@ -1261,7 +1261,7 @@ OpSwitch:
 			r := unsafenmagic(n)
 			if r != nil {
 				if n.Isddd {
-					Yyerror("invalid use of ... with builtin %v", Nconv(l, 0))
+					Yyerror("invalid use of ... with builtin %v", l)
 				}
 				n = r
 				typecheck1(&n, top)
@@ -1274,7 +1274,7 @@ OpSwitch:
 		l = n.Left
 		if l.Op == ONAME && l.Etype != 0 {
 			if n.Isddd && l.Etype != OAPPEND {
-				Yyerror("invalid use of ... with builtin %v", Nconv(l, 0))
+				Yyerror("invalid use of ... with builtin %v", l)
 			}
 
 			// builtin: OLEN, OCAP, etc.
@@ -1304,7 +1304,7 @@ OpSwitch:
 
 			n.Op = OCONV
 			n.Type = l.Type
-			if onearg(n, "conversion to %v", Tconv(l.Type, 0)) < 0 {
+			if onearg(n, "conversion to %v", l.Type) < 0 {
 				n.Type = nil
 				return
 			}
@@ -1344,13 +1344,13 @@ OpSwitch:
 		default:
 			n.Op = OCALLFUNC
 			if t.Etype != TFUNC {
-				Yyerror("cannot call non-function %v (type %v)", Nconv(l, 0), Tconv(t, 0))
+				Yyerror("cannot call non-function %v (type %v)", l, t)
 				n.Type = nil
 				return
 			}
 		}
 
-		typecheckaste(OCALL, n.Left, n.Isddd, getinargx(t), n.List, func() string { return fmt.Sprintf("argument to %v", Nconv(n.Left, 0)) })
+		typecheckaste(OCALL, n.Left, n.Isddd, getinargx(t), n.List, func() string { return fmt.Sprintf("argument to %v", n.Left) })
 		ok |= Etop
 		if t.Outtuple == 0 {
 			break OpSwitch
@@ -1382,7 +1382,7 @@ OpSwitch:
 
 		// multiple return
 		if top&(Efnstruct|Etop) == 0 {
-			Yyerror("multiple-value %v() in single-value context", Nconv(l, 0))
+			Yyerror("multiple-value %v() in single-value context", l)
 			break OpSwitch
 		}
 
@@ -1479,7 +1479,7 @@ OpSwitch:
 
 			t := n.List.N.Left.Type
 			if t.Outtuple != 2 {
-				Yyerror("invalid operation: complex expects two arguments, %v returns %d results", Nconv(n.List.N, 0), t.Outtuple)
+				Yyerror("invalid operation: complex expects two arguments, %v returns %d results", n.List.N, t.Outtuple)
 				n.Type = nil
 				return
 			}
@@ -1508,7 +1508,7 @@ OpSwitch:
 		}
 
 		if !Eqtype(l.Type, r.Type) {
-			Yyerror("invalid operation: %v (mismatched types %v and %v)", Nconv(n, 0), Tconv(l.Type, 0), Tconv(r.Type, 0))
+			Yyerror("invalid operation: %v (mismatched types %v and %v)", n, l.Type, r.Type)
 			n.Type = nil
 			return
 		}
@@ -1516,7 +1516,7 @@ OpSwitch:
 		var t *Type
 		switch l.Type.Etype {
 		default:
-			Yyerror("invalid operation: %v (arguments have type %v, expected floating-point)", Nconv(n, 0), Tconv(l.Type, 0), r.Type)
+			Yyerror("invalid operation: %v (arguments have type %v, expected floating-point)", n, l.Type, r.Type)
 			n.Type = nil
 			return
 
@@ -1555,13 +1555,13 @@ OpSwitch:
 			return
 		}
 		if t.Etype != TCHAN {
-			Yyerror("invalid operation: %v (non-chan type %v)", Nconv(n, 0), Tconv(t, 0))
+			Yyerror("invalid operation: %v (non-chan type %v)", n, t)
 			n.Type = nil
 			return
 		}
 
 		if t.Chan&Csend == 0 {
-			Yyerror("invalid operation: %v (cannot close receive-only channel)", Nconv(n, 0))
+			Yyerror("invalid operation: %v (cannot close receive-only channel)", n)
 			n.Type = nil
 			return
 		}
@@ -1752,7 +1752,7 @@ OpSwitch:
 			n.Op = uint8(convertop(t, n.Type, &why))
 			if (n.Op) == 0 {
 				if n.Diag == 0 && n.Type.Broke == 0 {
-					Yyerror("cannot convert %v to type %v%s", Nconv(n.Left, obj.FmtLong), Tconv(n.Type, 0), why)
+					Yyerror("cannot convert %v to type %v%s", Nconv(n.Left, obj.FmtLong), n.Type, why)
 					n.Diag = 1
 				}
 
@@ -1806,19 +1806,19 @@ OpSwitch:
 
 		switch t.Etype {
 		default:
-			Yyerror("cannot make type %v", Tconv(t, 0))
+			Yyerror("cannot make type %v", t)
 			n.Type = nil
 			return
 
 		case TARRAY:
 			if !Isslice(t) {
-				Yyerror("cannot make type %v", Tconv(t, 0))
+				Yyerror("cannot make type %v", t)
 				n.Type = nil
 				return
 			}
 
 			if args == nil {
-				Yyerror("missing len argument to make(%v)", Tconv(t, 0))
+				Yyerror("missing len argument to make(%v)", t)
 				n.Type = nil
 				return
 			}
@@ -1844,7 +1844,7 @@ OpSwitch:
 				return
 			}
 			if Isconst(l, CTINT) && r != nil && Isconst(r, CTINT) && Mpcmpfixfix(l.Val.U.Xval, r.Val.U.Xval) > 0 {
-				Yyerror("len larger than cap in make(%v)", Tconv(t, 0))
+				Yyerror("len larger than cap in make(%v)", t)
 				n.Type = nil
 				return
 			}
@@ -1896,7 +1896,7 @@ OpSwitch:
 		}
 
 		if args != nil {
-			Yyerror("too many arguments to make(%v)", Tconv(t, 0))
+			Yyerror("too many arguments to make(%v)", t)
 			n.Op = OMAKE
 			n.Type = nil
 			return
@@ -1922,7 +1922,7 @@ OpSwitch:
 			return
 		}
 		if args.Next != nil {
-			Yyerror("too many arguments to new(%v)", Tconv(t, 0))
+			Yyerror("too many arguments to new(%v)", t)
 			n.Type = nil
 			return
 		}
@@ -1988,7 +1988,7 @@ OpSwitch:
 			return
 		}
 		if t.Etype != TINTER {
-			Fatal("OITAB of %v", Tconv(t, 0))
+			Fatal("OITAB of %v", t)
 		}
 		n.Type = Ptrto(Types[TUINTPTR])
 		break OpSwitch
@@ -2002,7 +2002,7 @@ OpSwitch:
 			return
 		}
 		if !Isslice(t) && t.Etype != TSTRING {
-			Fatal("OSPTR of %v", Tconv(t, 0))
+			Fatal("OSPTR of %v", t)
 		}
 		if t.Etype == TSTRING {
 			n.Type = Ptrto(Types[TUINT8])
@@ -2194,27 +2194,27 @@ OpSwitch:
 
 	evconst(n)
 	if n.Op == OTYPE && top&Etype == 0 {
-		Yyerror("type %v is not an expression", Tconv(n.Type, 0))
+		Yyerror("type %v is not an expression", n.Type)
 		n.Type = nil
 		return
 	}
 
 	if top&(Erv|Etype) == Etype && n.Op != OTYPE {
-		Yyerror("%v is not a type", Nconv(n, 0))
+		Yyerror("%v is not a type", n)
 		n.Type = nil
 		return
 	}
 
 	// TODO(rsc): simplify
 	if (top&(Ecall|Erv|Etype) != 0) && top&Etop == 0 && ok&(Erv|Etype|Ecall) == 0 {
-		Yyerror("%v used as value", Nconv(n, 0))
+		Yyerror("%v used as value", n)
 		n.Type = nil
 		return
 	}
 
 	if (top&Etop != 0) && top&(Ecall|Erv|Etype) == 0 && ok&Etop == 0 {
 		if n.Diag == 0 {
-			Yyerror("%v evaluated but not used", Nconv(n, 0))
+			Yyerror("%v evaluated but not used", n)
 			n.Diag = 1
 		}
 
@@ -2234,22 +2234,22 @@ func checksliceindex(l *Node, r *Node, tp *Type) int {
 		return -1
 	}
 	if !Isint[t.Etype] {
-		Yyerror("invalid slice index %v (type %v)", Nconv(r, 0), Tconv(t, 0))
+		Yyerror("invalid slice index %v (type %v)", r, t)
 		return -1
 	}
 
 	if r.Op == OLITERAL {
 		if Mpgetfix(r.Val.U.Xval) < 0 {
-			Yyerror("invalid slice index %v (index must be non-negative)", Nconv(r, 0))
+			Yyerror("invalid slice index %v (index must be non-negative)", r)
 			return -1
 		} else if tp != nil && tp.Bound > 0 && Mpgetfix(r.Val.U.Xval) > tp.Bound {
-			Yyerror("invalid slice index %v (out of bounds for %d-element array)", Nconv(r, 0), tp.Bound)
+			Yyerror("invalid slice index %v (out of bounds for %d-element array)", r, tp.Bound)
 			return -1
 		} else if Isconst(l, CTSTR) && Mpgetfix(r.Val.U.Xval) > int64(len(l.Val.U.Sval)) {
-			Yyerror("invalid slice index %v (out of bounds for %d-byte string)", Nconv(r, 0), len(l.Val.U.Sval))
+			Yyerror("invalid slice index %v (out of bounds for %d-byte string)", r, len(l.Val.U.Sval))
 			return -1
 		} else if Mpcmpfixfix(r.Val.U.Xval, Maxintval[TINT]) > 0 {
-			Yyerror("invalid slice index %v (index too large)", Nconv(r, 0))
+			Yyerror("invalid slice index %v (index too large)", r)
 			return -1
 		}
 	}
@@ -2259,7 +2259,7 @@ func checksliceindex(l *Node, r *Node, tp *Type) int {
 
 func checksliceconst(lo *Node, hi *Node) int {
 	if lo != nil && hi != nil && lo.Op == OLITERAL && hi.Op == OLITERAL && Mpcmpfixfix(lo.Val.U.Xval, hi.Val.U.Xval) > 0 {
-		Yyerror("invalid slice index: %v > %v", Nconv(lo, 0), Nconv(hi, 0))
+		Yyerror("invalid slice index: %v > %v", lo, hi)
 		return -1
 	}
 
@@ -2301,7 +2301,7 @@ func checkdefergo(n *Node) {
 		if n.Left.Orig != nil && n.Left.Orig.Op == OCONV {
 			break
 		}
-		Yyerror("%s discards result of %v", what, Nconv(n.Left, 0))
+		Yyerror("%s discards result of %v", what, n.Left)
 		return
 	}
 
@@ -2347,13 +2347,13 @@ func onearg(n *Node, f string, args ...interface{}) int {
 	}
 	if n.List == nil {
 		p := fmt.Sprintf(f, args...)
-		Yyerror("missing argument to %s: %v", p, Nconv(n, 0))
+		Yyerror("missing argument to %s: %v", p, n)
 		return -1
 	}
 
 	if n.List.Next != nil {
 		p := fmt.Sprintf(f, args...)
-		Yyerror("too many arguments to %s: %v", p, Nconv(n, 0))
+		Yyerror("too many arguments to %s: %v", p, n)
 		n.Left = n.List.N
 		n.List = nil
 		return -1
@@ -2369,19 +2369,19 @@ func twoarg(n *Node) int {
 		return 0
 	}
 	if n.List == nil {
-		Yyerror("missing argument to %v - %v", Oconv(int(n.Op), 0), Nconv(n, 0))
+		Yyerror("missing argument to %v - %v", Oconv(int(n.Op), 0), n)
 		return -1
 	}
 
 	n.Left = n.List.N
 	if n.List.Next == nil {
-		Yyerror("missing argument to %v - %v", Oconv(int(n.Op), 0), Nconv(n, 0))
+		Yyerror("missing argument to %v - %v", Oconv(int(n.Op), 0), n)
 		n.List = nil
 		return -1
 	}
 
 	if n.List.Next.Next != nil {
-		Yyerror("too many arguments to %v - %v", Oconv(int(n.Op), 0), Nconv(n, 0))
+		Yyerror("too many arguments to %v - %v", Oconv(int(n.Op), 0), n)
 		n.List = nil
 		return -1
 	}
@@ -2402,11 +2402,11 @@ func lookdot1(errnode *Node, s *Sym, t *Type, f *Type, dostrcmp int) *Type {
 		}
 		if r != nil {
 			if errnode != nil {
-				Yyerror("ambiguous selector %v", Nconv(errnode, 0))
+				Yyerror("ambiguous selector %v", errnode)
 			} else if Isptr[t.Etype] {
-				Yyerror("ambiguous selector (%v).%v", Tconv(t, 0), Sconv(s, 0))
+				Yyerror("ambiguous selector (%v).%v", t, s)
 			} else {
-				Yyerror("ambiguous selector %v.%v", Tconv(t, 0), Sconv(s, 0))
+				Yyerror("ambiguous selector %v.%v", t, s)
 			}
 			break
 		}
@@ -2449,7 +2449,7 @@ func looktypedot(n *Node, t *Type, dostrcmp int) bool {
 
 	// disallow T.m if m requires *T receiver
 	if Isptr[getthisx(f2.Type).Type.Type.Etype] && !Isptr[t.Etype] && f2.Embedded != 2 && !isifacemethod(f2.Type) {
-		Yyerror("invalid method expression %v (needs pointer receiver: (*%v).%v)", Nconv(n, 0), Tconv(t, 0), Sconv(f2.Sym, obj.FmtShort))
+		Yyerror("invalid method expression %v (needs pointer receiver: (*%v).%v)", n, t, Sconv(f2.Sym, obj.FmtShort))
 		return false
 	}
 
@@ -2488,10 +2488,10 @@ func lookdot(n *Node, t *Type, dostrcmp int) bool {
 
 	if f1 != nil {
 		if f2 != nil {
-			Yyerror("%v is both field and method", Sconv(n.Right.Sym, 0))
+			Yyerror("%v is both field and method", n.Right.Sym)
 		}
 		if f1.Width == BADWIDTH {
-			Fatal("lookdot badwidth %v %p", Tconv(f1, 0), f1)
+			Fatal("lookdot badwidth %v %p", f1, f1)
 		}
 		n.Xoffset = f1.Width
 		n.Type = f1.Type
@@ -2524,7 +2524,7 @@ func lookdot(n *Node, t *Type, dostrcmp int) bool {
 				n.Left.Implicit = true
 				typecheck(&n.Left, Etype|Erv)
 			} else if int(tt.Etype) == Tptr && int(tt.Type.Etype) == Tptr && Eqtype(derefall(tt), derefall(rcvr)) {
-				Yyerror("calling method %v with receiver %v requires explicit dereference", Nconv(n.Right, 0), Nconv(n.Left, obj.FmtLong))
+				Yyerror("calling method %v with receiver %v requires explicit dereference", n.Right, Nconv(n.Left, obj.FmtLong))
 				for int(tt.Etype) == Tptr {
 					// Stop one level early for method with pointer receiver.
 					if int(rcvr.Etype) == Tptr && int(tt.Type.Etype) != Tptr {
@@ -2536,7 +2536,7 @@ func lookdot(n *Node, t *Type, dostrcmp int) bool {
 					tt = tt.Type
 				}
 			} else {
-				Fatal("method mismatch: %v for %v", Tconv(rcvr, 0), Tconv(tt, 0))
+				Fatal("method mismatch: %v for %v", rcvr, tt)
 			}
 		}
 
@@ -2632,9 +2632,9 @@ func typecheckaste(op int, call *Node, isddd bool, tstruct *Type, nl *NodeList,
 						for ; tn != nil; tn = tn.Down {
 							if assignop(tn.Type, tl.Type.Type, &why) == 0 {
 								if call != nil {
-									Yyerror("cannot use %v as type %v in argument to %v%s", Tconv(tn.Type, 0), Tconv(tl.Type.Type, 0), Nconv(call, 0), why)
+									Yyerror("cannot use %v as type %v in argument to %v%s", tn.Type, tl.Type.Type, call, why)
 								} else {
-									Yyerror("cannot use %v as type %v in %s%s", Tconv(tn.Type, 0), Tconv(tl.Type.Type, 0), desc(), why)
+									Yyerror("cannot use %v as type %v in %s%s", tn.Type, tl.Type.Type, desc(), why)
 								}
 							}
 						}
@@ -2647,9 +2647,9 @@ func typecheckaste(op int, call *Node, isddd bool, tstruct *Type, nl *NodeList,
 					}
 					if assignop(tn.Type, tl.Type, &why) == 0 {
 						if call != nil {
-							Yyerror("cannot use %v as type %v in argument to %v%s", Tconv(tn.Type, 0), Tconv(tl.Type, 0), Nconv(call, 0), why)
+							Yyerror("cannot use %v as type %v in argument to %v%s", tn.Type, tl.Type, call, why)
 						} else {
-							Yyerror("cannot use %v as type %v in %s%s", Tconv(tn.Type, 0), Tconv(tl.Type, 0), desc(), why)
+							Yyerror("cannot use %v as type %v in %s%s", tn.Type, tl.Type, desc(), why)
 						}
 					}
 
@@ -2733,7 +2733,7 @@ func typecheckaste(op int, call *Node, isddd bool, tstruct *Type, nl *NodeList,
 	}
 	if isddd {
 		if call != nil {
-			Yyerror("invalid use of ... in call to %v", Nconv(call, 0))
+			Yyerror("invalid use of ... in call to %v", call)
 		} else {
 			Yyerror("invalid use of ... in %v", Oconv(int(op), 0))
 		}
@@ -2746,7 +2746,7 @@ out:
 notenough:
 	if n == nil || n.Diag == 0 {
 		if call != nil {
-			Yyerror("not enough arguments in call to %v", Nconv(call, 0))
+			Yyerror("not enough arguments in call to %v", call)
 		} else {
 			Yyerror("not enough arguments to %v", Oconv(int(op), 0))
 		}
@@ -2759,7 +2759,7 @@ notenough:
 
 toomany:
 	if call != nil {
-		Yyerror("too many arguments in call to %v", Nconv(call, 0))
+		Yyerror("too many arguments in call to %v", call)
 	} else {
 		Yyerror("too many arguments to %v", Oconv(int(op), 0))
 	}
@@ -2835,7 +2835,7 @@ func keydup(n *Node, hash []*Node) {
 		}
 
 		if b != 0 {
-			Yyerror("duplicate key %v in map literal", Nconv(n, 0))
+			Yyerror("duplicate key %v in map literal", n)
 			return
 		}
 	}
@@ -2938,7 +2938,7 @@ func pushtype(n *Node, t *Type) {
 	} else if Debug['s'] != 0 {
 		typecheck(&n.Right, Etype)
 		if n.Right.Type != nil && Eqtype(n.Right.Type, t) {
-			fmt.Printf("%v: redundant type: %v\n", n.Line(), Tconv(t, 0))
+			fmt.Printf("%v: redundant type: %v\n", n.Line(), t)
 		}
 	}
 }
@@ -2979,14 +2979,14 @@ func typecheckcomplit(np **Node) {
 		// For better or worse, we don't allow pointers as the composite literal type,
 		// except when using the &T syntax, which sets implicit on the OIND.
 		if !n.Right.Implicit {
-			Yyerror("invalid pointer type %v for composite literal (use &%v instead)", Tconv(t, 0), Tconv(t.Type, 0))
+			Yyerror("invalid pointer type %v for composite literal (use &%v instead)", t, t.Type)
 			n.Type = nil
 			return
 		}
 
 		// Also, the underlying type must be a struct, map, slice, or array.
 		if !iscomptype(t) {
-			Yyerror("invalid pointer type %v for composite literal", Tconv(t, 0))
+			Yyerror("invalid pointer type %v for composite literal", t)
 			n.Type = nil
 			return
 		}
@@ -2997,7 +2997,7 @@ func typecheckcomplit(np **Node) {
 	var r *Node
 	switch t.Etype {
 	default:
-		Yyerror("invalid type for composite literal: %v", Tconv(t, 0))
+		Yyerror("invalid type for composite literal: %v", t)
 		n.Type = nil
 
 	case TARRAY:
@@ -3105,7 +3105,7 @@ func typecheckcomplit(np **Node) {
 
 				s = f.Sym
 				if s != nil && !exportname(s.Name) && s.Pkg != localpkg {
-					Yyerror("implicit assignment of unexported field '%s' in %v literal", s.Name, Tconv(t, 0))
+					Yyerror("implicit assignment of unexported field '%s' in %v literal", s.Name, t)
 				}
 
 				// No pushtype allowed here.  Must name fields for that.
@@ -3143,7 +3143,7 @@ func typecheckcomplit(np **Node) {
 
 				s = l.Left.Sym
 				if s == nil {
-					Yyerror("invalid field name %v in struct initializer", Nconv(l.Left, 0))
+					Yyerror("invalid field name %v in struct initializer", l.Left)
 					typecheck(&l.Right, Erv)
 					continue
 				}
@@ -3160,7 +3160,7 @@ func typecheckcomplit(np **Node) {
 
 				f = lookdot1(nil, s, t, t.Type, 0)
 				if f == nil {
-					Yyerror("unknown %v field '%v' in struct literal", Tconv(t, 0), Sconv(s, 0))
+					Yyerror("unknown %v field '%v' in struct literal", t, s)
 					continue
 				}
 
@@ -3232,7 +3232,7 @@ func islvalue(n *Node) bool {
 
 func checklvalue(n *Node, verb string) {
 	if !islvalue(n) {
-		Yyerror("cannot %s %v", verb, Nconv(n, 0))
+		Yyerror("cannot %s %v", verb, n)
 	}
 }
 
@@ -3267,7 +3267,7 @@ func checkassign(stmt *Node, n *Node) {
 		return
 	}
 
-	Yyerror("cannot assign to %v", Nconv(n, 0))
+	Yyerror("cannot assign to %v", n)
 }
 
 func checkassignlist(stmt *Node, l *NodeList) {
@@ -3369,7 +3369,7 @@ func checkassignto(src *Type, dst *Node) {
 	var why string
 
 	if assignop(src, dst.Type, &why) == 0 {
-		Yyerror("cannot assign %v to %v in multiple assignment%s", Tconv(src, 0), Nconv(dst, obj.FmtLong), why)
+		Yyerror("cannot assign %v to %v in multiple assignment%s", src, Nconv(dst, obj.FmtLong), why)
 		return
 	}
 }
@@ -3710,7 +3710,7 @@ func typecheckdef(n *Node) *Node {
 
 			// Note: adderrorname looks for this string and
 			// adds context about the outer expression
-			Yyerror("undefined: %v", Sconv(n.Sym, 0))
+			Yyerror("undefined: %v", n.Sym)
 		}
 
 		return n
@@ -3729,7 +3729,7 @@ func typecheckdef(n *Node) *Node {
 		Flusherrors()
 		fmt.Printf("typecheckdef loop:")
 		for l := typecheckdefstack; l != nil; l = l.Next {
-			fmt.Printf(" %v", Sconv(l.N.Sym, 0))
+			fmt.Printf(" %v", l.N.Sym)
 		}
 		fmt.Printf("\n")
 		Fatal("typecheckdef loop")
@@ -3776,7 +3776,7 @@ func typecheckdef(n *Node) *Node {
 
 		if e.Type != nil && e.Op != OLITERAL || !isgoconst(e) {
 			if e.Diag == 0 {
-				Yyerror("const initializer %v is not a constant", Nconv(e, 0))
+				Yyerror("const initializer %v is not a constant", e)
 				e.Diag = 1
 			}
 
@@ -3786,12 +3786,12 @@ func typecheckdef(n *Node) *Node {
 		t := n.Type
 		if t != nil {
 			if !okforconst[t.Etype] {
-				Yyerror("invalid constant type %v", Tconv(t, 0))
+				Yyerror("invalid constant type %v", t)
 				goto ret
 			}
 
 			if !isideal(e.Type) && !Eqtype(t, e.Type) {
-				Yyerror("cannot use %v as type %v in const initializer", Nconv(e, obj.FmtLong), Tconv(t, 0))
+				Yyerror("cannot use %v as type %v in const initializer", Nconv(e, obj.FmtLong), t)
 				goto ret
 			}
 
@@ -3827,7 +3827,7 @@ func typecheckdef(n *Node) *Node {
 				break
 			}
 
-			Fatal("var without type, init: %v", Sconv(n.Sym, 0))
+			Fatal("var without type, init: %v", n.Sym)
 		}
 
 		if n.Defn.Op == ONAME {
@@ -3864,7 +3864,7 @@ func typecheckdef(n *Node) *Node {
 
 ret:
 	if n.Op != OLITERAL && n.Type != nil && isideal(n.Type) {
-		Fatal("got %v for %v", Tconv(n.Type, 0), Nconv(n, 0))
+		Fatal("got %v for %v", n.Type, n)
 	}
 	if typecheckdefstack.N != n {
 		Fatal("typecheckdefstack mismatch")
@@ -3883,12 +3883,12 @@ func checkmake(t *Type, arg string, n *Node) int {
 		case CTINT, CTRUNE, CTFLT, CTCPLX:
 			n.Val = toint(n.Val)
 			if mpcmpfixc(n.Val.U.Xval, 0) < 0 {
-				Yyerror("negative %s argument in make(%v)", arg, Tconv(t, 0))
+				Yyerror("negative %s argument in make(%v)", arg, t)
 				return -1
 			}
 
 			if Mpcmpfixfix(n.Val.U.Xval, Maxintval[TINT]) > 0 {
-				Yyerror("%s argument too large in make(%v)", arg, Tconv(t, 0))
+				Yyerror("%s argument too large in make(%v)", arg, t)
 				return -1
 			}
 
@@ -3904,7 +3904,7 @@ func checkmake(t *Type, arg string, n *Node) int {
 	}
 
 	if !Isint[n.Type.Etype] && n.Type.Etype != TIDEAL {
-		Yyerror("non-integer %s argument in make(%v) - %v", arg, Tconv(t, 0), Tconv(n.Type, 0))
+		Yyerror("non-integer %s argument in make(%v) - %v", arg, t, n.Type)
 		return -1
 	}
 
diff --git a/src/cmd/internal/gc/unsafe.go b/src/cmd/internal/gc/unsafe.go
index 7bd35f8a7e..aa90a19308 100644
--- a/src/cmd/internal/gc/unsafe.go
+++ b/src/cmd/internal/gc/unsafe.go
@@ -29,7 +29,7 @@ func unsafenmagic(nn *Node) *Node {
 	}
 
 	if args == nil {
-		Yyerror("missing argument for %v", Sconv(s, 0))
+		Yyerror("missing argument for %v", s)
 		return nil
 	}
 
@@ -66,7 +66,7 @@ func unsafenmagic(nn *Node) *Node {
 			break
 
 		case OCALLPART:
-			Yyerror("invalid expression %v: argument is a method value", Nconv(nn, 0))
+			Yyerror("invalid expression %v: argument is a method value", nn)
 			v = 0
 			goto ret
 
@@ -84,7 +84,7 @@ func unsafenmagic(nn *Node) *Node {
 				v += r1.Xoffset
 
 			case ODOTPTR:
-				Yyerror("invalid expression %v: selector implies indirection of embedded %v", Nconv(nn, 0), Nconv(r1.Left, 0))
+				Yyerror("invalid expression %v: selector implies indirection of embedded %v", nn, r1.Left)
 				goto ret
 
 			default:
@@ -126,13 +126,13 @@ func unsafenmagic(nn *Node) *Node {
 	return nil
 
 bad:
-	Yyerror("invalid expression %v", Nconv(nn, 0))
+	Yyerror("invalid expression %v", nn)
 	v = 0
 	goto ret
 
 yes:
 	if args.Next != nil {
-		Yyerror("extra arguments for %v", Sconv(s, 0))
+		Yyerror("extra arguments for %v", s)
 	}
 
 	// any side effects disappear; ignore init
diff --git a/src/cmd/internal/gc/walk.go b/src/cmd/internal/gc/walk.go
index 1012aa0538..0bdc4888ef 100644
--- a/src/cmd/internal/gc/walk.go
+++ b/src/cmd/internal/gc/walk.go
@@ -21,7 +21,7 @@ func walk(fn *Node) {
 	Curfn = fn
 
 	if Debug['W'] != 0 {
-		s := fmt.Sprintf("\nbefore %v", Sconv(Curfn.Nname.Sym, 0))
+		s := fmt.Sprintf("\nbefore %v", Curfn.Nname.Sym)
 		dumplist(s, Curfn.Nbody)
 	}
 
@@ -51,11 +51,11 @@ func walk(fn *Node) {
 				continue
 			}
 			lineno = l.N.Defn.Left.Lineno
-			Yyerror("%v declared and not used", Sconv(l.N.Sym, 0))
+			Yyerror("%v declared and not used", l.N.Sym)
 			l.N.Defn.Left.Used = true // suppress repeats
 		} else {
 			lineno = l.N.Lineno
-			Yyerror("%v declared and not used", Sconv(l.N.Sym, 0))
+			Yyerror("%v declared and not used", l.N.Sym)
 		}
 	}
 
@@ -65,13 +65,13 @@ func walk(fn *Node) {
 	}
 	walkstmtlist(Curfn.Nbody)
 	if Debug['W'] != 0 {
-		s := fmt.Sprintf("after walk %v", Sconv(Curfn.Nname.Sym, 0))
+		s := fmt.Sprintf("after walk %v", Curfn.Nname.Sym)
 		dumplist(s, Curfn.Nbody)
 	}
 
 	heapmoves()
 	if Debug['W'] != 0 && Curfn.Func.Enter != nil {
-		s := fmt.Sprintf("enter %v", Sconv(Curfn.Nname.Sym, 0))
+		s := fmt.Sprintf("enter %v", Curfn.Nname.Sym)
 		dumplist(s, Curfn.Func.Enter)
 	}
 }
@@ -154,7 +154,7 @@ func walkstmt(np **Node) {
 	switch n.Op {
 	default:
 		if n.Op == ONAME {
-			Yyerror("%v is not a top level statement", Sconv(n.Sym, 0))
+			Yyerror("%v is not a top level statement", n.Sym)
 		} else {
 			Yyerror("%v is not a top level statement", Oconv(int(n.Op), 0))
 		}
@@ -311,7 +311,7 @@ func walkstmt(np **Node) {
 				f := n.List.N
 
 				if f.Op != OCALLFUNC && f.Op != OCALLMETH && f.Op != OCALLINTER {
-					Fatal("expected return of call, have %v", Nconv(f, 0))
+					Fatal("expected return of call, have %v", f)
 				}
 				n.List = concat(list1(f), ascompatet(int(n.Op), rl, &f.Type, 0, &n.Ninit))
 				break
@@ -1390,7 +1390,7 @@ func walkexpr(np **Node, init **NodeList) {
 
 		typecheck(&r, Erv)
 		if n.Type.Etype != TBOOL {
-			Fatal("cmp %v", Tconv(n.Type, 0))
+			Fatal("cmp %v", n.Type)
 		}
 		r.Type = n.Type
 		n = r
@@ -1570,7 +1570,7 @@ func walkexpr(np **Node, init **NodeList) {
 		// ifaceeq(i1 any-1, i2 any-2) (ret bool);
 	case OCMPIFACE:
 		if !Eqtype(n.Left.Type, n.Right.Type) {
-			Fatal("ifaceeq %v %v %v", Oconv(int(n.Op), 0), Tconv(n.Left.Type, 0), Tconv(n.Right.Type, 0))
+			Fatal("ifaceeq %v %v %v", Oconv(int(n.Op), 0), n.Left.Type, n.Right.Type)
 		}
 		var fn *Node
 		if isnilinter(n.Left.Type) {
@@ -2247,7 +2247,7 @@ func applywritebarrier(n *Node, init **NodeList) *Node {
 			var name string
 			switch t.Width / int64(Widthptr) {
 			default:
-				Fatal("found writebarrierfat for %d-byte object of type %v", int(t.Width), Tconv(t, 0))
+				Fatal("found writebarrierfat for %d-byte object of type %v", int(t.Width), t)
 
 			case 2:
 				name = fmt.Sprintf("writebarrierfat%d%d", bvget(applywritebarrier_bv, PtrBit), bvget(applywritebarrier_bv, obj.BitsPerPointer+PtrBit))
@@ -2721,7 +2721,7 @@ func paramstoheap(argin **Type, out int) *NodeList {
 
 		// generate allocation & copying code
 		if compiling_runtime != 0 {
-			Yyerror("%v escapes to heap, not allowed in runtime.", Nconv(v, 0))
+			Yyerror("%v escapes to heap, not allowed in runtime.", v)
 		}
 		if v.Alloc == nil {
 			v.Alloc = callnew(v.Type)
@@ -2777,7 +2777,7 @@ func heapmoves() {
 
 func vmkcall(fn *Node, t *Type, init **NodeList, va []*Node) *Node {
 	if fn.Type == nil || fn.Type.Etype != TFUNC {
-		Fatal("mkcall %v %v", Nconv(fn, 0), Tconv(fn.Type, 0))
+		Fatal("mkcall %v %v", fn, fn.Type)
 	}
 
 	var args *NodeList
@@ -2818,7 +2818,7 @@ func conv(n *Node, t *Type) *Node {
 
 func chanfn(name string, n int, t *Type) *Node {
 	if t.Etype != TCHAN {
-		Fatal("chanfn %v", Tconv(t, 0))
+		Fatal("chanfn %v", t)
 	}
 	fn := syslook(name, 1)
 	switch n {
@@ -2834,7 +2834,7 @@ func chanfn(name string, n int, t *Type) *Node {
 
 func mapfn(name string, t *Type) *Node {
 	if t.Etype != TMAP {
-		Fatal("mapfn %v", Tconv(t, 0))
+		Fatal("mapfn %v", t)
 	}
 	fn := syslook(name, 1)
 	substArgTypes(fn, t.Down, t.Type, t.Down, t.Type)
@@ -2843,7 +2843,7 @@ func mapfn(name string, t *Type) *Node {
 
 func mapfndel(name string, t *Type) *Node {
 	if t.Etype != TMAP {
-		Fatal("mapfn %v", Tconv(t, 0))
+		Fatal("mapfn %v", t)
 	}
 	fn := syslook(name, 1)
 	substArgTypes(fn, t.Down, t.Type, t.Down)
@@ -3379,7 +3379,7 @@ func eqfor(t *Type, needsize *int) *Node {
 	a := algtype1(t, nil)
 
 	if a != AMEM && a != -1 {
-		Fatal("eqfor %v", Tconv(t, 0))
+		Fatal("eqfor %v", t)
 	}
 
 	if a == AMEM {
@@ -3486,7 +3486,7 @@ func walkcompare(np **Node, init **NodeList) {
 	}
 
 	if !islvalue(cmpl) || !islvalue(cmpr) {
-		Fatal("arguments of comparison must be lvalues - %v %v", Nconv(cmpl, 0), Nconv(cmpr, 0))
+		Fatal("arguments of comparison must be lvalues - %v %v", cmpl, cmpr)
 	}
 
 	l = temp(Ptrto(t))
@@ -4087,7 +4087,7 @@ func usefield(n *Node) {
 
 	field := n.Paramfld
 	if field == nil {
-		Fatal("usefield %v %v without paramfld", Tconv(n.Left.Type, 0), Sconv(n.Right.Sym, 0))
+		Fatal("usefield %v %v without paramfld", n.Left.Type, n.Right.Sym)
 	}
 	if field.Note == nil || !strings.Contains(*field.Note, "go:\"track\"") {
 		return
diff --git a/src/cmd/internal/gc/y.go b/src/cmd/internal/gc/y.go
index c952e656ba..f2c8b96982 100644
--- a/src/cmd/internal/gc/y.go
+++ b/src/cmd/internal/gc/y.go
@@ -1543,7 +1543,7 @@ yydefault:
 				if yyDollar[1].list.Next != nil {
 					Yyerror("argument count mismatch: %d = %d", count(yyDollar[1].list), 1)
 				} else if (yyDollar[1].list.N.Op != ONAME && yyDollar[1].list.N.Op != OTYPE && yyDollar[1].list.N.Op != ONONAME) || isblank(yyDollar[1].list.N) {
-					Yyerror("invalid variable name %s in type switch", Nconv(yyDollar[1].list.N, 0))
+					Yyerror("invalid variable name %s in type switch", yyDollar[1].list.N)
 				} else {
 					yyVAL.node.Left = dclname(yyDollar[1].list.N.Sym)
 				} // it's a colas, so must not re-use an oldname.
@@ -2588,7 +2588,7 @@ yydefault:
 					dclcontext = PDISCARD // since we skip funchdr below
 					break
 				}
-				Yyerror("inconsistent definition for func %v during import\n\t%v\n\t%v", Sconv(s, 0), Tconv(s.Def.Type, 0), Tconv(t, 0))
+				Yyerror("inconsistent definition for func %v during import\n\t%v\n\t%v", s, s.Def.Type, t)
 			}
 
 			yyVAL.node = newfuncname(s)
@@ -2824,7 +2824,7 @@ yydefault:
 			var pkg *Pkg
 
 			if yyDollar[1].sym.Def == nil || yyDollar[1].sym.Def.Op != OPACK {
-				Yyerror("%v is not a package", Sconv(yyDollar[1].sym, 0))
+				Yyerror("%v is not a package", yyDollar[1].sym)
 				pkg = localpkg
 			} else {
 				yyDollar[1].sym.Def.Used = true
@@ -3422,7 +3422,7 @@ yydefault:
 		{
 			yyVAL.node = oldname(Pkglookup(yyDollar[1].sym.Name, builtinpkg))
 			if yyVAL.node.Op != OLITERAL {
-				Yyerror("bad constant %v", Sconv(yyVAL.node.Sym, 0))
+				Yyerror("bad constant %v", yyVAL.node.Sym)
 			}
 		}
 	case 343:
