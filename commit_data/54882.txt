commit b2faff18ce28edad98303d2c3134dec1331fd7b5
Author: cui fliter <imcusg@gmail.com>
Date:   Fri Nov 11 19:22:35 2022 +0800

    all: add missing periods in comments
    
    Change-Id: I69065f8adf101fdb28682c55997f503013a50e29
    Reviewed-on: https://go-review.googlesource.com/c/go/+/449757
    Auto-Submit: Ian Lance Taylor <iant@google.com>
    Reviewed-by: Joedian Reid <joedian@golang.org>
    Reviewed-by: Keith Randall <khr@google.com>
    Reviewed-by: Keith Randall <khr@golang.org>
    TryBot-Result: Gopher Robot <gobot@golang.org>
    Run-TryBot: Joedian Reid <joedian@golang.org>
    Run-TryBot: Ian Lance Taylor <iant@google.com>
    Reviewed-by: Ian Lance Taylor <iant@google.com>
---
 src/archive/tar/reader.go                         |  2 +-
 src/cmd/asm/internal/arch/arm.go                  |  2 +-
 src/cmd/cgo/gcc.go                                |  2 +-
 src/cmd/compile/internal/abi/abiutils.go          |  2 +-
 src/cmd/compile/internal/arm/ssa.go               | 14 +++++++-------
 src/cmd/compile/internal/arm64/ssa.go             |  8 ++++----
 src/cmd/compile/internal/base/print.go            |  2 +-
 src/cmd/compile/internal/escape/leaks.go          |  2 +-
 src/cmd/compile/internal/ir/func.go               |  2 +-
 src/cmd/compile/internal/liveness/plive.go        |  2 +-
 src/cmd/compile/internal/logopt/log_opts.go       |  8 ++++----
 src/cmd/compile/internal/loong64/ssa.go           |  2 +-
 src/cmd/compile/internal/mips/ssa.go              |  4 ++--
 src/cmd/compile/internal/mips64/ssa.go            |  4 ++--
 src/cmd/compile/internal/ssa/dom.go               |  4 ++--
 src/cmd/compile/internal/ssa/loopreschedchecks.go |  2 +-
 src/cmd/compile/internal/ssa/lower.go             |  2 +-
 src/cmd/compile/internal/ssa/op.go                |  4 ++--
 src/cmd/compile/internal/ssa/opt.go               |  2 +-
 src/cmd/compile/internal/ssa/prove.go             |  2 +-
 src/cmd/compile/internal/ssa/rewrite.go           | 20 ++++++++++----------
 src/cmd/compile/internal/ssa/sparseset.go         |  2 +-
 src/cmd/compile/internal/ssa/sparsetree.go        |  4 ++--
 src/cmd/compile/internal/ssa/trim.go              | 10 +++++-----
 src/cmd/compile/internal/ssa/writebarrier.go      |  2 +-
 src/cmd/compile/internal/ssagen/nowb.go           |  2 +-
 src/cmd/compile/internal/ssagen/phi.go            |  2 +-
 src/cmd/compile/internal/ssagen/ssa.go            |  2 +-
 src/cmd/compile/internal/typecheck/dcl.go         |  2 +-
 src/cmd/compile/internal/typecheck/export.go      | 12 ++++++------
 src/cmd/compile/internal/typecheck/typecheck.go   |  2 +-
 src/cmd/compile/internal/walk/builtin.go          |  2 +-
 src/cmd/compile/internal/walk/expr.go             |  4 ++--
 src/cmd/dist/util.go                              |  2 +-
 src/cmd/go/internal/modfetch/fetch.go             |  2 +-
 src/cmd/internal/dwarf/dwarf.go                   |  4 ++--
 src/cmd/internal/obj/arm64/asm7.go                |  4 ++--
 src/cmd/internal/obj/loong64/asm.go               |  2 +-
 src/cmd/internal/obj/ppc64/asm9.go                |  4 ++--
 src/cmd/internal/obj/s390x/asmz.go                | 16 ++++++++--------
 src/cmd/link/internal/arm/asm.go                  | 12 ++++++------
 src/cmd/link/internal/arm64/asm.go                |  2 +-
 src/cmd/link/internal/ld/data.go                  |  4 ++--
 src/cmd/link/internal/ld/elf.go                   |  4 ++--
 src/cmd/link/internal/ld/xcoff.go                 |  8 ++++----
 src/cmd/link/internal/ppc64/asm.go                |  8 ++++----
 src/cmd/pprof/pprof.go                            |  2 +-
 src/compress/flate/deflate.go                     |  2 +-
 src/compress/flate/huffman_code.go                |  2 +-
 src/compress/flate/token.go                       |  6 +++---
 src/crypto/des/block.go                           |  6 +++---
 src/crypto/internal/boring/boring.go              |  2 +-
 src/crypto/x509/internal/macos/corefoundation.go  |  2 +-
 src/encoding/json/scanner.go                      |  2 +-
 src/go/doc/example.go                             |  2 +-
 src/go/doc/reader.go                              |  2 +-
 src/go/types/gotype.go                            |  2 +-
 src/hash/crc32/crc32_ppc64le.go                   |  2 +-
 src/html/template/content.go                      |  2 +-
 src/internal/fuzz/coverage.go                     |  2 +-
 src/internal/profile/filter.go                    |  2 +-
 src/math/big/int.go                               |  4 ++--
 src/math/big/intconv.go                           |  2 +-
 src/math/big/natconv.go                           |  2 +-
 src/math/cmplx/sin.go                             |  2 +-
 src/net/http/client.go                            |  2 +-
 src/net/http/cookie.go                            |  2 +-
 src/net/http/transfer.go                          |  8 ++++----
 src/net/http/transport.go                         |  2 +-
 src/net/http/triv.go                              |  2 +-
 src/net/lookup_windows.go                         |  4 ++--
 src/net/mail/message.go                           |  2 +-
 src/net/smtp/smtp.go                              |  2 +-
 src/os/env.go                                     |  2 +-
 src/plugin/plugin_dlopen.go                       |  4 ++--
 src/regexp/onepass.go                             |  4 ++--
 src/regexp/regexp.go                              |  2 +-
 src/runtime/cgocall.go                            |  4 ++--
 src/runtime/chan.go                               |  4 ++--
 src/runtime/debug/mod.go                          |  2 +-
 src/runtime/heapdump.go                           | 10 +++++-----
 src/runtime/lock_futex.go                         |  2 +-
 src/runtime/lock_sema.go                          |  2 +-
 src/runtime/malloc.go                             |  2 +-
 src/runtime/map.go                                |  2 +-
 src/runtime/mfinal.go                             |  2 +-
 src/runtime/mgcwork.go                            |  2 +-
 src/runtime/os_aix.go                             |  2 +-
 src/runtime/os_openbsd_syscall2.go                |  2 +-
 src/runtime/pprof/pprof.go                        |  2 +-
 src/runtime/proc.go                               |  4 ++--
 src/runtime/race.go                               |  2 +-
 src/runtime/runtime1.go                           |  2 +-
 src/runtime/stubs2.go                             |  2 +-
 src/runtime/stubs_ppc64.go                        |  2 +-
 src/syscall/fs_js.go                              |  2 +-
 src/time/format.go                                |  2 +-
 97 files changed, 174 insertions(+), 174 deletions(-)

diff --git a/src/archive/tar/reader.go b/src/archive/tar/reader.go
index 44166b4cdf..3495f083e3 100644
--- a/src/archive/tar/reader.go
+++ b/src/archive/tar/reader.go
@@ -304,7 +304,7 @@ func mergePAX(hdr *Header, paxHdrs map[string]string) (err error) {
 }
 
 // parsePAX parses PAX headers.
-// If an extended header (type 'x') is invalid, ErrHeader is returned
+// If an extended header (type 'x') is invalid, ErrHeader is returned.
 func parsePAX(r io.Reader) (map[string]string, error) {
 	buf, err := readSpecialFile(r)
 	if err != nil {
diff --git a/src/cmd/asm/internal/arch/arm.go b/src/cmd/asm/internal/arch/arm.go
index b0e985f0bc..22ac483b92 100644
--- a/src/cmd/asm/internal/arch/arm.go
+++ b/src/cmd/asm/internal/arch/arm.go
@@ -113,7 +113,7 @@ func IsARMSTREX(op obj.As) bool {
 const aMCR = arm.ALAST + 1
 
 // IsARMMRC reports whether the op (as defined by an arm.A* constant) is
-// MRC or MCR
+// MRC or MCR.
 func IsARMMRC(op obj.As) bool {
 	switch op {
 	case arm.AMRC, aMCR: // Note: aMCR is defined in this package.
diff --git a/src/cmd/cgo/gcc.go b/src/cmd/cgo/gcc.go
index c25aa0c7f8..5df4a8c4ad 100644
--- a/src/cmd/cgo/gcc.go
+++ b/src/cmd/cgo/gcc.go
@@ -2222,7 +2222,7 @@ func (c *typeConv) Init(ptrSize, intSize int64) {
 	}
 }
 
-// base strips away qualifiers and typedefs to get the underlying type
+// base strips away qualifiers and typedefs to get the underlying type.
 func base(dt dwarf.Type) dwarf.Type {
 	for {
 		if d, ok := dt.(*dwarf.QualType); ok {
diff --git a/src/cmd/compile/internal/abi/abiutils.go b/src/cmd/compile/internal/abi/abiutils.go
index 09bc0fbf85..a88f8c4b06 100644
--- a/src/cmd/compile/internal/abi/abiutils.go
+++ b/src/cmd/compile/internal/abi/abiutils.go
@@ -529,7 +529,7 @@ type assignState struct {
 	spillOffset int64      // current spill offset
 }
 
-// align returns a rounded up to t's alignment
+// align returns a rounded up to t's alignment.
 func align(a int64, t *types.Type) int64 {
 	return alignTo(a, int(uint8(t.Alignment())))
 }
diff --git a/src/cmd/compile/internal/arm/ssa.go b/src/cmd/compile/internal/arm/ssa.go
index a53f51bd13..fd0da34418 100644
--- a/src/cmd/compile/internal/arm/ssa.go
+++ b/src/cmd/compile/internal/arm/ssa.go
@@ -72,7 +72,7 @@ func storeByType(t *types.Type) obj.As {
 	panic("bad store type")
 }
 
-// shift type is used as Offset in obj.TYPE_SHIFT operands to encode shifted register operands
+// shift type is used as Offset in obj.TYPE_SHIFT operands to encode shifted register operands.
 type shift int64
 
 // copied from ../../../internal/obj/util.go:/TYPE_SHIFT
@@ -87,7 +87,7 @@ func (v shift) String() string {
 	}
 }
 
-// makeshift encodes a register shifted by a constant
+// makeshift encodes a register shifted by a constant.
 func makeshift(v *ssa.Value, reg int16, typ int64, s int64) shift {
 	if s < 0 || s >= 32 {
 		v.Fatalf("shift out of range: %d", s)
@@ -95,7 +95,7 @@ func makeshift(v *ssa.Value, reg int16, typ int64, s int64) shift {
 	return shift(int64(reg&0xf) | typ | (s&31)<<7)
 }
 
-// genshift generates a Prog for r = r0 op (r1 shifted by n)
+// genshift generates a Prog for r = r0 op (r1 shifted by n).
 func genshift(s *ssagen.State, v *ssa.Value, as obj.As, r0, r1, r int16, typ int64, n int64) *obj.Prog {
 	p := s.Prog(as)
 	p.From.Type = obj.TYPE_SHIFT
@@ -108,12 +108,12 @@ func genshift(s *ssagen.State, v *ssa.Value, as obj.As, r0, r1, r int16, typ int
 	return p
 }
 
-// makeregshift encodes a register shifted by a register
+// makeregshift encodes a register shifted by a register.
 func makeregshift(r1 int16, typ int64, r2 int16) shift {
 	return shift(int64(r1&0xf) | typ | int64(r2&0xf)<<8 | 1<<4)
 }
 
-// genregshift generates a Prog for r = r0 op (r1 shifted by r2)
+// genregshift generates a Prog for r = r0 op (r1 shifted by r2).
 func genregshift(s *ssagen.State, as obj.As, r0, r1, r2, r int16, typ int64) *obj.Prog {
 	p := s.Prog(as)
 	p.From.Type = obj.TYPE_SHIFT
@@ -903,13 +903,13 @@ var blockJump = map[ssa.BlockKind]struct {
 	ssa.BlockARMGEnoov: {arm.ABPL, arm.ABMI},
 }
 
-// To model a 'LEnoov' ('<=' without overflow checking) branching
+// To model a 'LEnoov' ('<=' without overflow checking) branching.
 var leJumps = [2][2]ssagen.IndexJump{
 	{{Jump: arm.ABEQ, Index: 0}, {Jump: arm.ABPL, Index: 1}}, // next == b.Succs[0]
 	{{Jump: arm.ABMI, Index: 0}, {Jump: arm.ABEQ, Index: 0}}, // next == b.Succs[1]
 }
 
-// To model a 'GTnoov' ('>' without overflow checking) branching
+// To model a 'GTnoov' ('>' without overflow checking) branching.
 var gtJumps = [2][2]ssagen.IndexJump{
 	{{Jump: arm.ABMI, Index: 1}, {Jump: arm.ABEQ, Index: 1}}, // next == b.Succs[0]
 	{{Jump: arm.ABEQ, Index: 1}, {Jump: arm.ABPL, Index: 0}}, // next == b.Succs[1]
diff --git a/src/cmd/compile/internal/arm64/ssa.go b/src/cmd/compile/internal/arm64/ssa.go
index 8299cb1de4..88856558aa 100644
--- a/src/cmd/compile/internal/arm64/ssa.go
+++ b/src/cmd/compile/internal/arm64/ssa.go
@@ -78,7 +78,7 @@ func storeByType(t *types.Type) obj.As {
 	panic("bad store type")
 }
 
-// makeshift encodes a register shifted by a constant, used as an Offset in Prog
+// makeshift encodes a register shifted by a constant, used as an Offset in Prog.
 func makeshift(v *ssa.Value, reg int16, typ int64, s int64) int64 {
 	if s < 0 || s >= 64 {
 		v.Fatalf("shift out of range: %d", s)
@@ -86,7 +86,7 @@ func makeshift(v *ssa.Value, reg int16, typ int64, s int64) int64 {
 	return int64(reg&31)<<16 | typ | (s&63)<<10
 }
 
-// genshift generates a Prog for r = r0 op (r1 shifted by n)
+// genshift generates a Prog for r = r0 op (r1 shifted by n).
 func genshift(s *ssagen.State, v *ssa.Value, as obj.As, r0, r1, r int16, typ int64, n int64) *obj.Prog {
 	p := s.Prog(as)
 	p.From.Type = obj.TYPE_SHIFT
@@ -1223,13 +1223,13 @@ var blockJump = map[ssa.BlockKind]struct {
 	ssa.BlockARM64GEnoov: {arm64.ABPL, arm64.ABMI},
 }
 
-// To model a 'LEnoov' ('<=' without overflow checking) branching
+// To model a 'LEnoov' ('<=' without overflow checking) branching.
 var leJumps = [2][2]ssagen.IndexJump{
 	{{Jump: arm64.ABEQ, Index: 0}, {Jump: arm64.ABPL, Index: 1}}, // next == b.Succs[0]
 	{{Jump: arm64.ABMI, Index: 0}, {Jump: arm64.ABEQ, Index: 0}}, // next == b.Succs[1]
 }
 
-// To model a 'GTnoov' ('>' without overflow checking) branching
+// To model a 'GTnoov' ('>' without overflow checking) branching.
 var gtJumps = [2][2]ssagen.IndexJump{
 	{{Jump: arm64.ABMI, Index: 1}, {Jump: arm64.ABEQ, Index: 1}}, // next == b.Succs[0]
 	{{Jump: arm64.ABEQ, Index: 1}, {Jump: arm64.ABPL, Index: 0}}, // next == b.Succs[1]
diff --git a/src/cmd/compile/internal/base/print.go b/src/cmd/compile/internal/base/print.go
index 70a9e9fb74..21fa001457 100644
--- a/src/cmd/compile/internal/base/print.go
+++ b/src/cmd/compile/internal/base/print.go
@@ -36,7 +36,7 @@ func Errors() int {
 	return numErrors
 }
 
-// SyntaxErrors returns the number of syntax errors reported
+// SyntaxErrors returns the number of syntax errors reported.
 func SyntaxErrors() int {
 	return numSyntaxErrors
 }
diff --git a/src/cmd/compile/internal/escape/leaks.go b/src/cmd/compile/internal/escape/leaks.go
index 4c848a5ee7..1432607c2d 100644
--- a/src/cmd/compile/internal/escape/leaks.go
+++ b/src/cmd/compile/internal/escape/leaks.go
@@ -94,7 +94,7 @@ func (l leaks) Encode() string {
 	return s
 }
 
-// parseLeaks parses a binary string representing a leaks
+// parseLeaks parses a binary string representing a leaks.
 func parseLeaks(s string) leaks {
 	var l leaks
 	if !strings.HasPrefix(s, "esc:") {
diff --git a/src/cmd/compile/internal/ir/func.go b/src/cmd/compile/internal/ir/func.go
index 2bbacfc2c3..31c11f8297 100644
--- a/src/cmd/compile/internal/ir/func.go
+++ b/src/cmd/compile/internal/ir/func.go
@@ -299,7 +299,7 @@ func MarkFunc(n *Name) {
 }
 
 // ClosureDebugRuntimeCheck applies boilerplate checks for debug flags
-// and compiling runtime
+// and compiling runtime.
 func ClosureDebugRuntimeCheck(clo *ClosureExpr) {
 	if base.Debug.Closure > 0 {
 		if clo.Esc() == EscHeap {
diff --git a/src/cmd/compile/internal/liveness/plive.go b/src/cmd/compile/internal/liveness/plive.go
index 20342e292c..689b5286c6 100644
--- a/src/cmd/compile/internal/liveness/plive.go
+++ b/src/cmd/compile/internal/liveness/plive.go
@@ -296,7 +296,7 @@ func (lv *liveness) valueEffects(v *ssa.Value) (int32, liveEffect) {
 	return -1, 0
 }
 
-// affectedVar returns the *ir.Name node affected by v
+// affectedVar returns the *ir.Name node affected by v.
 func affectedVar(v *ssa.Value) (*ir.Name, ssa.SymEffect) {
 	// Special cases.
 	switch v.Op {
diff --git a/src/cmd/compile/internal/logopt/log_opts.go b/src/cmd/compile/internal/logopt/log_opts.go
index 5c7f580f0b..1e83227816 100644
--- a/src/cmd/compile/internal/logopt/log_opts.go
+++ b/src/cmd/compile/internal/logopt/log_opts.go
@@ -304,7 +304,7 @@ func parseLogPath(destination string) (string, string) {
 
 // checkLogPath does superficial early checking of the string specifying
 // the directory to which optimizer logging is directed, and if
-// it passes the test, stores the string in LO_dir
+// it passes the test, stores the string in LO_dir.
 func checkLogPath(destination string) string {
 	path, complaint := parseLogPath(destination)
 	if complaint != "" {
@@ -331,7 +331,7 @@ func NewLoggedOpt(pos src.XPos, what, pass, funcName string, args ...interface{}
 
 // LogOpt logs information about a (usually missed) optimization performed by the compiler.
 // Pos is the source position (including inlining), what is the message, pass is which pass created the message,
-// funcName is the name of the function
+// funcName is the name of the function.
 func LogOpt(pos src.XPos, what, pass, funcName string, args ...interface{}) {
 	if Format == None {
 		return
@@ -499,13 +499,13 @@ func newPointRange(p src.Pos) Range {
 		End: Position{p.Line(), p.Col()}}
 }
 
-// newLocation returns the Location for the compiler source location p
+// newLocation returns the Location for the compiler source location p.
 func newLocation(p src.Pos) Location {
 	loc := Location{URI: uriIfy(uprootedPath(p.Filename())), Range: newPointRange(p)}
 	return loc
 }
 
-// appendInlinedPos extracts inlining information from posTmp and append it to diagnostic
+// appendInlinedPos extracts inlining information from posTmp and append it to diagnostic.
 func appendInlinedPos(posTmp []src.Pos, diagnostic *Diagnostic) {
 	for i := 1; i < len(posTmp); i++ {
 		p := posTmp[i]
diff --git a/src/cmd/compile/internal/loong64/ssa.go b/src/cmd/compile/internal/loong64/ssa.go
index a1cebdca56..59f9e189bd 100644
--- a/src/cmd/compile/internal/loong64/ssa.go
+++ b/src/cmd/compile/internal/loong64/ssa.go
@@ -17,7 +17,7 @@ import (
 	"cmd/internal/obj/loong64"
 )
 
-// isFPreg reports whether r is an FP register
+// isFPreg reports whether r is an FP register.
 func isFPreg(r int16) bool {
 	return loong64.REG_F0 <= r && r <= loong64.REG_F31
 }
diff --git a/src/cmd/compile/internal/mips/ssa.go b/src/cmd/compile/internal/mips/ssa.go
index 0411756c8d..2ad75207e1 100644
--- a/src/cmd/compile/internal/mips/ssa.go
+++ b/src/cmd/compile/internal/mips/ssa.go
@@ -17,12 +17,12 @@ import (
 	"cmd/internal/obj/mips"
 )
 
-// isFPreg reports whether r is an FP register
+// isFPreg reports whether r is an FP register.
 func isFPreg(r int16) bool {
 	return mips.REG_F0 <= r && r <= mips.REG_F31
 }
 
-// isHILO reports whether r is HI or LO register
+// isHILO reports whether r is HI or LO register.
 func isHILO(r int16) bool {
 	return r == mips.REG_HI || r == mips.REG_LO
 }
diff --git a/src/cmd/compile/internal/mips64/ssa.go b/src/cmd/compile/internal/mips64/ssa.go
index f3e372c3bc..8612763ced 100644
--- a/src/cmd/compile/internal/mips64/ssa.go
+++ b/src/cmd/compile/internal/mips64/ssa.go
@@ -17,12 +17,12 @@ import (
 	"cmd/internal/obj/mips"
 )
 
-// isFPreg reports whether r is an FP register
+// isFPreg reports whether r is an FP register.
 func isFPreg(r int16) bool {
 	return mips.REG_F0 <= r && r <= mips.REG_F31
 }
 
-// isHILO reports whether r is HI or LO register
+// isHILO reports whether r is HI or LO register.
 func isHILO(r int16) bool {
 	return r == mips.REG_HI || r == mips.REG_LO
 }
diff --git a/src/cmd/compile/internal/ssa/dom.go b/src/cmd/compile/internal/ssa/dom.go
index dd40b2ae81..347038bf82 100644
--- a/src/cmd/compile/internal/ssa/dom.go
+++ b/src/cmd/compile/internal/ssa/dom.go
@@ -179,7 +179,7 @@ func (f *Func) dfsOrig(entry *Block, succFn linkedBlocks, semi, vertex, label, p
 	return n
 }
 
-// compressOrig is the "simple" compress function from LT paper
+// compressOrig is the "simple" compress function from LT paper.
 func compressOrig(v ID, ancestor, semi, label []ID) {
 	if ancestor[ancestor[v]] != 0 {
 		compressOrig(ancestor[v], ancestor, semi, label)
@@ -190,7 +190,7 @@ func compressOrig(v ID, ancestor, semi, label []ID) {
 	}
 }
 
-// evalOrig is the "simple" eval function from LT paper
+// evalOrig is the "simple" eval function from LT paper.
 func evalOrig(v ID, ancestor, semi, label []ID) ID {
 	if ancestor[v] == 0 {
 		return v
diff --git a/src/cmd/compile/internal/ssa/loopreschedchecks.go b/src/cmd/compile/internal/ssa/loopreschedchecks.go
index 5a4f0b23d6..7c56523ad8 100644
--- a/src/cmd/compile/internal/ssa/loopreschedchecks.go
+++ b/src/cmd/compile/internal/ssa/loopreschedchecks.go
@@ -401,7 +401,7 @@ outer:
 	}
 }
 
-// findLastMems maps block ids to last memory-output op in a block, if any
+// findLastMems maps block ids to last memory-output op in a block, if any.
 func findLastMems(f *Func) []*Value {
 
 	var stores []*Value
diff --git a/src/cmd/compile/internal/ssa/lower.go b/src/cmd/compile/internal/ssa/lower.go
index df25ac9f1a..0b79d77c50 100644
--- a/src/cmd/compile/internal/ssa/lower.go
+++ b/src/cmd/compile/internal/ssa/lower.go
@@ -4,7 +4,7 @@
 
 package ssa
 
-// convert to machine-dependent ops
+// convert to machine-dependent ops.
 func lower(f *Func) {
 	// repeat rewrites until we find no more rewrites
 	applyRewrite(f, f.Config.lowerBlock, f.Config.lowerValue, removeDeadValues)
diff --git a/src/cmd/compile/internal/ssa/op.go b/src/cmd/compile/internal/ssa/op.go
index 9157733cfc..9434c0ef16 100644
--- a/src/cmd/compile/internal/ssa/op.go
+++ b/src/cmd/compile/internal/ssa/op.go
@@ -269,7 +269,7 @@ func (a *AuxCall) SizeOfArg(which int64) int64 {
 	return a.TypeOfArg(which).Size()
 }
 
-// NResults returns the number of results
+// NResults returns the number of results.
 func (a *AuxCall) NResults() int64 {
 	return int64(len(a.abiInfo.OutParams()))
 }
@@ -335,7 +335,7 @@ func ClosureAuxCall(paramResultInfo *abi.ABIParamResultInfo) *AuxCall {
 
 func (*AuxCall) CanBeAnSSAAux() {}
 
-// OwnAuxCall returns a function's own AuxCall
+// OwnAuxCall returns a function's own AuxCall.
 func OwnAuxCall(fn *obj.LSym, paramResultInfo *abi.ABIParamResultInfo) *AuxCall {
 	// TODO if this remains identical to ClosureAuxCall above after new ABI is done, should deduplicate.
 	var reg *regInfo
diff --git a/src/cmd/compile/internal/ssa/opt.go b/src/cmd/compile/internal/ssa/opt.go
index 128e614175..0f15c3db4a 100644
--- a/src/cmd/compile/internal/ssa/opt.go
+++ b/src/cmd/compile/internal/ssa/opt.go
@@ -4,7 +4,7 @@
 
 package ssa
 
-// machine-independent optimization
+// machine-independent optimization.
 func opt(f *Func) {
 	applyRewrite(f, rewriteBlockgeneric, rewriteValuegeneric, removeDeadValues)
 }
diff --git a/src/cmd/compile/internal/ssa/prove.go b/src/cmd/compile/internal/ssa/prove.go
index eca04e0bf0..908fb5af46 100644
--- a/src/cmd/compile/internal/ssa/prove.go
+++ b/src/cmd/compile/internal/ssa/prove.go
@@ -1604,7 +1604,7 @@ func isConstDelta(v *Value) (w *Value, delta int64) {
 }
 
 // isCleanExt reports whether v is the result of a value-preserving
-// sign or zero extension
+// sign or zero extension.
 func isCleanExt(v *Value) bool {
 	switch v.Op {
 	case OpSignExt8to16, OpSignExt8to32, OpSignExt8to64,
diff --git a/src/cmd/compile/internal/ssa/rewrite.go b/src/cmd/compile/internal/ssa/rewrite.go
index bf0135c2c8..99dc779c90 100644
--- a/src/cmd/compile/internal/ssa/rewrite.go
+++ b/src/cmd/compile/internal/ssa/rewrite.go
@@ -412,13 +412,13 @@ func canMergeLoad(target, load *Value) bool {
 	return true
 }
 
-// isSameCall reports whether sym is the same as the given named symbol
+// isSameCall reports whether sym is the same as the given named symbol.
 func isSameCall(sym interface{}, name string) bool {
 	fn := sym.(*AuxCall).Fn
 	return fn != nil && fn.String() == name
 }
 
-// canLoadUnaligned reports if the architecture supports unaligned load operations
+// canLoadUnaligned reports if the architecture supports unaligned load operations.
 func canLoadUnaligned(c *Config) bool {
 	return c.ctxt.Arch.Alignment == 1
 }
@@ -797,7 +797,7 @@ func loadLSymOffset(lsym *obj.LSym, offset int64) *obj.LSym {
 }
 
 // de-virtualize an InterLECall
-// 'sym' is the symbol for the itab
+// 'sym' is the symbol for the itab.
 func devirtLESym(v *Value, aux Aux, sym Sym, offset int64) *obj.LSym {
 	n, ok := sym.(*obj.LSym)
 	if !ok {
@@ -898,7 +898,7 @@ func disjoint(p1 *Value, n1 int64, p2 *Value, n2 int64) bool {
 	return false
 }
 
-// moveSize returns the number of bytes an aligned MOV instruction moves
+// moveSize returns the number of bytes an aligned MOV instruction moves.
 func moveSize(align int64, c *Config) int64 {
 	switch {
 	case align%8 == 0 && c.PtrSize == 8:
@@ -1019,7 +1019,7 @@ func warnRule(cond bool, v *Value, s string) bool {
 	return true
 }
 
-// for a pseudo-op like (LessThan x), extract x
+// for a pseudo-op like (LessThan x), extract x.
 func flagArg(v *Value) *Value {
 	if len(v.Args) != 1 || !v.Args[0].Type.IsFlags() {
 		return nil
@@ -1250,7 +1250,7 @@ func reciprocalExact32(c float32) bool {
 	}
 }
 
-// check if an immediate can be directly encoded into an ARM's instruction
+// check if an immediate can be directly encoded into an ARM's instruction.
 func isARMImmRot(v uint32) bool {
 	for i := 0; i < 16; i++ {
 		if v&^0xff == 0 {
@@ -1312,7 +1312,7 @@ func zeroUpper32Bits(x *Value, depth int) bool {
 	return false
 }
 
-// zeroUpper48Bits is similar to zeroUpper32Bits, but for upper 48 bits
+// zeroUpper48Bits is similar to zeroUpper32Bits, but for upper 48 bits.
 func zeroUpper48Bits(x *Value, depth int) bool {
 	switch x.Op {
 	case OpAMD64MOVWQZX, OpAMD64MOVWload, OpAMD64MOVWloadidx1, OpAMD64MOVWloadidx2:
@@ -1336,7 +1336,7 @@ func zeroUpper48Bits(x *Value, depth int) bool {
 	return false
 }
 
-// zeroUpper56Bits is similar to zeroUpper32Bits, but for upper 56 bits
+// zeroUpper56Bits is similar to zeroUpper32Bits, but for upper 56 bits.
 func zeroUpper56Bits(x *Value, depth int) bool {
 	switch x.Op {
 	case OpAMD64MOVBQZX, OpAMD64MOVBload, OpAMD64MOVBloadidx1:
@@ -1486,7 +1486,7 @@ func encodePPC64RotateMask(rotate, mask, nbits int64) int64 {
 	return int64(me) | int64(mb<<8) | int64(rotate<<16) | int64(nbits<<24)
 }
 
-// The inverse operation of encodePPC64RotateMask.  The values returned as
+// DecodePPC64RotateMask is the inverse operation of encodePPC64RotateMask.  The values returned as
 // mb and me satisfy the POWER ISA definition of MASK(x,y) where MASK(mb,me) = mask.
 func DecodePPC64RotateMask(sauxint int64) (rotate, mb, me int64, mask uint64) {
 	auxint := uint64(sauxint)
@@ -1625,7 +1625,7 @@ func isARM64BFMask(lsb, mask, rshift int64) bool {
 	return shiftedMask != 0 && isPowerOfTwo64(shiftedMask+1) && nto(shiftedMask)+lsb < 64
 }
 
-// returns the bitfield width of mask >> rshift for arm64 bitfield ops
+// returns the bitfield width of mask >> rshift for arm64 bitfield ops.
 func arm64BFWidth(mask, rshift int64) int64 {
 	shiftedMask := int64(uint64(mask) >> uint64(rshift))
 	if shiftedMask == 0 {
diff --git a/src/cmd/compile/internal/ssa/sparseset.go b/src/cmd/compile/internal/ssa/sparseset.go
index 395931d1ff..07d40dc948 100644
--- a/src/cmd/compile/internal/ssa/sparseset.go
+++ b/src/cmd/compile/internal/ssa/sparseset.go
@@ -13,7 +13,7 @@ type sparseSet struct {
 }
 
 // newSparseSet returns a sparseSet that can represent
-// integers between 0 and n-1
+// integers between 0 and n-1.
 func newSparseSet(n int) *sparseSet {
 	return &sparseSet{dense: nil, sparse: make([]int32, n)}
 }
diff --git a/src/cmd/compile/internal/ssa/sparsetree.go b/src/cmd/compile/internal/ssa/sparsetree.go
index 9f4e0007d3..6f2bd04037 100644
--- a/src/cmd/compile/internal/ssa/sparsetree.go
+++ b/src/cmd/compile/internal/ssa/sparsetree.go
@@ -55,7 +55,7 @@ const (
 // such as whether one block dominates another.
 type SparseTree []SparseTreeNode
 
-// newSparseTree creates a SparseTree from a block-to-parent map (array indexed by Block.ID)
+// newSparseTree creates a SparseTree from a block-to-parent map (array indexed by Block.ID).
 func newSparseTree(f *Func, parentOf []*Block) SparseTree {
 	t := make(SparseTree, f.NumBlocks())
 	for _, b := range f.Blocks {
@@ -184,7 +184,7 @@ func (t SparseTree) Parent(x *Block) *Block {
 	return t[x.ID].parent
 }
 
-// isAncestorEq reports whether x is an ancestor of or equal to y.
+// IsAncestorEq reports whether x is an ancestor of or equal to y.
 func (t SparseTree) IsAncestorEq(x, y *Block) bool {
 	if x == y {
 		return true
diff --git a/src/cmd/compile/internal/ssa/trim.go b/src/cmd/compile/internal/ssa/trim.go
index 1fd7b33d5f..13798c6c39 100644
--- a/src/cmd/compile/internal/ssa/trim.go
+++ b/src/cmd/compile/internal/ssa/trim.go
@@ -118,7 +118,7 @@ func trim(f *Func) {
 }
 
 // emptyBlock reports whether the block does not contain actual
-// instructions
+// instructions.
 func emptyBlock(b *Block) bool {
 	for _, v := range b.Values {
 		if v.Op != OpPhi {
@@ -130,11 +130,11 @@ func emptyBlock(b *Block) bool {
 
 // trimmableBlock reports whether the block can be trimmed from the CFG,
 // subject to the following criteria:
-//   - it should not be the first block
-//   - it should be BlockPlain
-//   - it should not loop back to itself
+//   - it should not be the first block.
+//   - it should be BlockPlain.
+//   - it should not loop back to itself.
 //   - it either is the single predecessor of the successor block or
-//     contains no actual instructions
+//     contains no actual instructions.
 func trimmableBlock(b *Block) bool {
 	if b.Kind != BlockPlain || b == b.Func.Entry {
 		return false
diff --git a/src/cmd/compile/internal/ssa/writebarrier.go b/src/cmd/compile/internal/ssa/writebarrier.go
index 2e7fc769df..3b2f781cbe 100644
--- a/src/cmd/compile/internal/ssa/writebarrier.go
+++ b/src/cmd/compile/internal/ssa/writebarrier.go
@@ -536,7 +536,7 @@ func wbcall(pos src.XPos, b *Block, fn, typ *obj.LSym, ptr, val, mem, sp, sb *Va
 	return b.NewValue1I(pos, OpSelectN, types.TypeMem, 0, call)
 }
 
-// round to a multiple of r, r is a power of 2
+// round to a multiple of r, r is a power of 2.
 func round(o int64, r int64) int64 {
 	return (o + r - 1) &^ (r - 1)
 }
diff --git a/src/cmd/compile/internal/ssagen/nowb.go b/src/cmd/compile/internal/ssagen/nowb.go
index 2085618b88..909319dcbf 100644
--- a/src/cmd/compile/internal/ssagen/nowb.go
+++ b/src/cmd/compile/internal/ssagen/nowb.go
@@ -45,7 +45,7 @@ type nowritebarrierrecCall struct {
 }
 
 // newNowritebarrierrecChecker creates a nowritebarrierrecChecker. It
-// must be called before walk
+// must be called before walk.
 func newNowritebarrierrecChecker() *nowritebarrierrecChecker {
 	c := &nowritebarrierrecChecker{
 		extraCalls: make(map[*ir.Func][]nowritebarrierrecCall),
diff --git a/src/cmd/compile/internal/ssagen/phi.go b/src/cmd/compile/internal/ssagen/phi.go
index 3e31ac7fd6..19b6920913 100644
--- a/src/cmd/compile/internal/ssagen/phi.go
+++ b/src/cmd/compile/internal/ssagen/phi.go
@@ -424,7 +424,7 @@ type sparseSet struct {
 }
 
 // newSparseSet returns a sparseSet that can represent
-// integers between 0 and n-1
+// integers between 0 and n-1.
 func newSparseSet(n int) *sparseSet {
 	return &sparseSet{dense: nil, sparse: make([]int32, n)}
 }
diff --git a/src/cmd/compile/internal/ssagen/ssa.go b/src/cmd/compile/internal/ssagen/ssa.go
index 7966cd4860..c6d6e0deee 100644
--- a/src/cmd/compile/internal/ssagen/ssa.go
+++ b/src/cmd/compile/internal/ssagen/ssa.go
@@ -252,7 +252,7 @@ func abiForFunc(fn *ir.Func, abi0, abi1 *abi.ABIConfig) *abi.ABIConfig {
 	return a
 }
 
-// dvarint writes a varint v to the funcdata in symbol x and returns the new offset
+// dvarint writes a varint v to the funcdata in symbol x and returns the new offset.
 func dvarint(x *obj.LSym, off int, v int64) int {
 	if v < 0 || v > 1e9 {
 		panic(fmt.Sprintf("dvarint: bad offset for funcdata - %v", v))
diff --git a/src/cmd/compile/internal/typecheck/dcl.go b/src/cmd/compile/internal/typecheck/dcl.go
index 4001fa5f5e..fce7d3d889 100644
--- a/src/cmd/compile/internal/typecheck/dcl.go
+++ b/src/cmd/compile/internal/typecheck/dcl.go
@@ -238,7 +238,7 @@ func Temp(t *types.Type) *ir.Name {
 	return TempAt(base.Pos, ir.CurFunc, t)
 }
 
-// make a new Node off the books
+// make a new Node off the books.
 func TempAt(pos src.XPos, curfn *ir.Func, t *types.Type) *ir.Name {
 	if curfn == nil {
 		base.Fatalf("no curfn for TempAt")
diff --git a/src/cmd/compile/internal/typecheck/export.go b/src/cmd/compile/internal/typecheck/export.go
index 30726d4327..af56ea8d98 100644
--- a/src/cmd/compile/internal/typecheck/export.go
+++ b/src/cmd/compile/internal/typecheck/export.go
@@ -14,13 +14,13 @@ import (
 )
 
 // importalias declares symbol s as an imported type alias with type t.
-// ipkg is the package being imported
+// ipkg is the package being imported.
 func importalias(pos src.XPos, s *types.Sym, t *types.Type) *ir.Name {
 	return importobj(pos, s, ir.OTYPE, ir.PEXTERN, t)
 }
 
 // importconst declares symbol s as an imported constant with type t and value val.
-// ipkg is the package being imported
+// ipkg is the package being imported.
 func importconst(pos src.XPos, s *types.Sym, t *types.Type, val constant.Value) *ir.Name {
 	n := importobj(pos, s, ir.OLITERAL, ir.PEXTERN, t)
 	n.SetVal(val)
@@ -28,7 +28,7 @@ func importconst(pos src.XPos, s *types.Sym, t *types.Type, val constant.Value)
 }
 
 // importfunc declares symbol s as an imported function with type t.
-// ipkg is the package being imported
+// ipkg is the package being imported.
 func importfunc(pos src.XPos, s *types.Sym, t *types.Type) *ir.Name {
 	n := importobj(pos, s, ir.ONAME, ir.PFUNC, t)
 	n.Func = ir.NewFunc(pos)
@@ -37,7 +37,7 @@ func importfunc(pos src.XPos, s *types.Sym, t *types.Type) *ir.Name {
 }
 
 // importobj declares symbol s as an imported object representable by op.
-// ipkg is the package being imported
+// ipkg is the package being imported.
 func importobj(pos src.XPos, s *types.Sym, op ir.Op, ctxt ir.Class, t *types.Type) *ir.Name {
 	n := importsym(pos, s, op, ctxt)
 	n.SetType(t)
@@ -60,7 +60,7 @@ func importsym(pos src.XPos, s *types.Sym, op ir.Op, ctxt ir.Class) *ir.Name {
 
 // importtype returns the named type declared by symbol s.
 // If no such type has been declared yet, a forward declaration is returned.
-// ipkg is the package being imported
+// ipkg is the package being imported.
 func importtype(pos src.XPos, s *types.Sym) *ir.Name {
 	n := importsym(pos, s, ir.OTYPE, ir.PEXTERN)
 	n.SetType(types.NewNamed(n))
@@ -68,7 +68,7 @@ func importtype(pos src.XPos, s *types.Sym) *ir.Name {
 }
 
 // importvar declares symbol s as an imported variable with type t.
-// ipkg is the package being imported
+// ipkg is the package being imported.
 func importvar(pos src.XPos, s *types.Sym, t *types.Type) *ir.Name {
 	return importobj(pos, s, ir.ONAME, ir.PEXTERN, t)
 }
diff --git a/src/cmd/compile/internal/typecheck/typecheck.go b/src/cmd/compile/internal/typecheck/typecheck.go
index f4174d1a60..1857994b62 100644
--- a/src/cmd/compile/internal/typecheck/typecheck.go
+++ b/src/cmd/compile/internal/typecheck/typecheck.go
@@ -1484,7 +1484,7 @@ func fmtSignature(nl ir.Nodes, isddd bool) string {
 	return fmt.Sprintf("(%s)", strings.Join(typeStrings, ", "))
 }
 
-// type check composite
+// type check composite.
 func fielddup(name string, hash map[string]bool) {
 	if hash[name] {
 		base.Errorf("duplicate field name in struct literal: %s", name)
diff --git a/src/cmd/compile/internal/walk/builtin.go b/src/cmd/compile/internal/walk/builtin.go
index 7d55494737..31c4b060d5 100644
--- a/src/cmd/compile/internal/walk/builtin.go
+++ b/src/cmd/compile/internal/walk/builtin.go
@@ -513,7 +513,7 @@ func walkNew(n *ir.UnaryExpr, init *ir.Nodes) ir.Node {
 	return n
 }
 
-// generate code for print
+// generate code for print.
 func walkPrint(nn *ir.CallExpr, init *ir.Nodes) ir.Node {
 	// Hoist all the argument evaluation up before the lock.
 	walkExprListCheap(nn.Args, init)
diff --git a/src/cmd/compile/internal/walk/expr.go b/src/cmd/compile/internal/walk/expr.go
index 7205107f6f..24fe0d0b9f 100644
--- a/src/cmd/compile/internal/walk/expr.go
+++ b/src/cmd/compile/internal/walk/expr.go
@@ -346,7 +346,7 @@ func walkExpr1(n ir.Node, init *ir.Nodes) ir.Node {
 // expression or simple statement.
 // the types expressions are calculated.
 // compile-time constants are evaluated.
-// complex side effects like statements are appended to init
+// complex side effects like statements are appended to init.
 func walkExprList(s []ir.Node, init *ir.Nodes) {
 	for i := range s {
 		s[i] = walkExpr(s[i], init)
@@ -867,7 +867,7 @@ func walkStringHeader(n *ir.StringHeaderExpr, init *ir.Nodes) ir.Node {
 	return n
 }
 
-// return 1 if integer n must be in range [0, max), 0 otherwise
+// return 1 if integer n must be in range [0, max), 0 otherwise.
 func bounded(n ir.Node, max int64) bool {
 	if n.Type() == nil || !n.Type().IsInteger() {
 		return false
diff --git a/src/cmd/dist/util.go b/src/cmd/dist/util.go
index a4d49f4614..a8efa513d2 100644
--- a/src/cmd/dist/util.go
+++ b/src/cmd/dist/util.go
@@ -379,7 +379,7 @@ func errprintf(format string, args ...interface{}) {
 	fmt.Fprintf(os.Stderr, format, args...)
 }
 
-// xsamefile reports whether f1 and f2 are the same file (or dir)
+// xsamefile reports whether f1 and f2 are the same file (or dir).
 func xsamefile(f1, f2 string) bool {
 	fi1, err1 := os.Stat(f1)
 	fi2, err2 := os.Stat(f2)
diff --git a/src/cmd/go/internal/modfetch/fetch.go b/src/cmd/go/internal/modfetch/fetch.go
index 003bc79fe9..dfe5da677e 100644
--- a/src/cmd/go/internal/modfetch/fetch.go
+++ b/src/cmd/go/internal/modfetch/fetch.go
@@ -408,7 +408,7 @@ type modSumStatus struct {
 }
 
 // Reset resets globals in the modfetch package, so previous loads don't affect
-// contents of go.sum files
+// contents of go.sum files.
 func Reset() {
 	GoSumFile = ""
 	WorkspaceGoSumFiles = nil
diff --git a/src/cmd/internal/dwarf/dwarf.go b/src/cmd/internal/dwarf/dwarf.go
index 045fc9c263..a6d19c61d1 100644
--- a/src/cmd/internal/dwarf/dwarf.go
+++ b/src/cmd/internal/dwarf/dwarf.go
@@ -1159,8 +1159,8 @@ func isEmptyInlinedCall(slot int, calls *InlCalls) bool {
 	return !live
 }
 
-// Slot -1:    return top-level inlines
-// Slot >= 0:  return children of that slot
+// Slot -1:    return top-level inlines.
+// Slot >= 0:  return children of that slot.
 func inlChildren(slot int, calls *InlCalls) []int {
 	var kids []int
 	if slot != -1 {
diff --git a/src/cmd/internal/obj/arm64/asm7.go b/src/cmd/internal/obj/arm64/asm7.go
index 3d5abedc1e..d7a28388e5 100644
--- a/src/cmd/internal/obj/arm64/asm7.go
+++ b/src/cmd/internal/obj/arm64/asm7.go
@@ -1525,7 +1525,7 @@ func isbitcon(x uint64) bool {
 	return sequenceOfOnes(x) || sequenceOfOnes(^x)
 }
 
-// sequenceOfOnes tests whether a constant is a sequence of ones in binary, with leading and trailing zeros
+// sequenceOfOnes tests whether a constant is a sequence of ones in binary, with leading and trailing zeros.
 func sequenceOfOnes(x uint64) bool {
 	y := x & -x // lowest set bit of x. x is good iff x+y is a power of 2
 	y += x
@@ -1778,7 +1778,7 @@ func (c *ctxt7) offsetshift(p *obj.Prog, v int64, cls int) int64 {
 /*
  * if v contains a single 16-bit value aligned
  * on a 16-bit field, and thus suitable for movk/movn,
- * return the field index 0 to 3; otherwise return -1
+ * return the field index 0 to 3; otherwise return -1.
  */
 func movcon(v int64) int {
 	for s := 0; s < 64; s += 16 {
diff --git a/src/cmd/internal/obj/loong64/asm.go b/src/cmd/internal/obj/loong64/asm.go
index 2ac4d3e50e..df3e9bf866 100644
--- a/src/cmd/internal/obj/loong64/asm.go
+++ b/src/cmd/internal/obj/loong64/asm.go
@@ -1092,7 +1092,7 @@ func OP_IR(op uint32, i uint32, r2 uint32) uint32 {
 	return op | (i&0xFFFFF)<<5 | (r2&0x1F)<<0 // ui20, rd5
 }
 
-// Encoding for the 'b' or 'bl' instruction
+// Encoding for the 'b' or 'bl' instruction.
 func OP_B_BL(op uint32, i uint32) uint32 {
 	return op | ((i & 0xFFFF) << 10) | ((i >> 16) & 0x3FF)
 }
diff --git a/src/cmd/internal/obj/ppc64/asm9.go b/src/cmd/internal/obj/ppc64/asm9.go
index 3e7b7b4913..9469edaf4c 100644
--- a/src/cmd/internal/obj/ppc64/asm9.go
+++ b/src/cmd/internal/obj/ppc64/asm9.go
@@ -539,7 +539,7 @@ var oprange [ALAST & obj.AMask][]Optab
 
 var xcmp [C_NCLASS][C_NCLASS]bool
 
-// padding bytes to add to align code as requested
+// padding bytes to add to align code as requested.
 func addpad(pc, a int64, ctxt *obj.Link, cursym *obj.LSym) int {
 	// For 16 and 32 byte alignment, there is a tradeoff
 	// between aligning the code and adding too many NOPs.
@@ -2105,7 +2105,7 @@ func OPMD(o, xo, rc uint32) uint32 {
 	return o<<26 | xo<<2 | rc&1
 }
 
-/* the order is dest, a/s, b/imm for both arithmetic and logical operations */
+/* the order is dest, a/s, b/imm for both arithmetic and logical operations. */
 func AOP_RRR(op uint32, d uint32, a uint32, b uint32) uint32 {
 	return op | (d&31)<<21 | (a&31)<<16 | (b&31)<<11
 }
diff --git a/src/cmd/internal/obj/s390x/asmz.go b/src/cmd/internal/obj/s390x/asmz.go
index 5760847bcd..d8a36c4e9c 100644
--- a/src/cmd/internal/obj/s390x/asmz.go
+++ b/src/cmd/internal/obj/s390x/asmz.go
@@ -4374,12 +4374,12 @@ func (c *ctxtz) regoff(a *obj.Addr) int32 {
 	return int32(c.vregoff(a))
 }
 
-// find if the displacement is within 12 bit
+// find if the displacement is within 12 bit.
 func isU12(displacement int32) bool {
 	return displacement >= 0 && displacement < DISP12
 }
 
-// zopload12 returns the RX op with 12 bit displacement for the given load
+// zopload12 returns the RX op with 12 bit displacement for the given load.
 func (c *ctxtz) zopload12(a obj.As) (uint32, bool) {
 	switch a {
 	case AFMOVD:
@@ -4390,7 +4390,7 @@ func (c *ctxtz) zopload12(a obj.As) (uint32, bool) {
 	return 0, false
 }
 
-// zopload returns the RXY op for the given load
+// zopload returns the RXY op for the given load.
 func (c *ctxtz) zopload(a obj.As) uint32 {
 	switch a {
 	// fixed point load
@@ -4428,7 +4428,7 @@ func (c *ctxtz) zopload(a obj.As) uint32 {
 	return 0
 }
 
-// zopstore12 returns the RX op with 12 bit displacement for the given store
+// zopstore12 returns the RX op with 12 bit displacement for the given store.
 func (c *ctxtz) zopstore12(a obj.As) (uint32, bool) {
 	switch a {
 	case AFMOVD:
@@ -4445,7 +4445,7 @@ func (c *ctxtz) zopstore12(a obj.As) (uint32, bool) {
 	return 0, false
 }
 
-// zopstore returns the RXY op for the given store
+// zopstore returns the RXY op for the given store.
 func (c *ctxtz) zopstore(a obj.As) uint32 {
 	switch a {
 	// fixed point store
@@ -4477,7 +4477,7 @@ func (c *ctxtz) zopstore(a obj.As) uint32 {
 	return 0
 }
 
-// zoprre returns the RRE op for the given a
+// zoprre returns the RRE op for the given a.
 func (c *ctxtz) zoprre(a obj.As) uint32 {
 	switch a {
 	case ACMP:
@@ -4495,7 +4495,7 @@ func (c *ctxtz) zoprre(a obj.As) uint32 {
 	return 0
 }
 
-// zoprr returns the RR op for the given a
+// zoprr returns the RR op for the given a.
 func (c *ctxtz) zoprr(a obj.As) uint32 {
 	switch a {
 	case ACMPW:
@@ -4507,7 +4507,7 @@ func (c *ctxtz) zoprr(a obj.As) uint32 {
 	return 0
 }
 
-// zopril returns the RIL op for the given a
+// zopril returns the RIL op for the given a.
 func (c *ctxtz) zopril(a obj.As) uint32 {
 	switch a {
 	case ACMP:
diff --git a/src/cmd/link/internal/arm/asm.go b/src/cmd/link/internal/arm/asm.go
index 347932c6e1..9eaa7b9eea 100644
--- a/src/cmd/link/internal/arm/asm.go
+++ b/src/cmd/link/internal/arm/asm.go
@@ -91,7 +91,7 @@ func gentext(ctxt *ld.Link, ldr *loader.Loader) {
 }
 
 // Preserve highest 8 bits of a, and do addition to lower 24-bit
-// of a and b; used to adjust ARM branch instruction's target
+// of a and b; used to adjust ARM branch instruction's target.
 func braddoff(a int32, b int32) int32 {
 	return int32((uint32(a))&0xff000000 | 0x00ffffff&uint32(a+b))
 }
@@ -363,7 +363,7 @@ func pereloc1(arch *sys.Arch, out *ld.OutBuf, ldr *loader.Loader, s loader.Sym,
 	return true
 }
 
-// sign extend a 24-bit integer
+// sign extend a 24-bit integer.
 func signext24(x int64) int32 {
 	return (int32(x) << 8) >> 8
 }
@@ -379,7 +379,7 @@ func immrot(v uint32) uint32 {
 	return 0
 }
 
-// Convert the direct jump relocation r to refer to a trampoline if the target is too far
+// Convert the direct jump relocation r to refer to a trampoline if the target is too far.
 func trampoline(ctxt *ld.Link, ldr *loader.Loader, ri int, rs, s loader.Sym) {
 	relocs := ldr.Relocs(s)
 	r := relocs.At(ri)
@@ -459,7 +459,7 @@ func trampoline(ctxt *ld.Link, ldr *loader.Loader, ri int, rs, s loader.Sym) {
 	}
 }
 
-// generate a trampoline to target+offset
+// generate a trampoline to target+offset.
 func gentramp(arch *sys.Arch, linkmode ld.LinkMode, ldr *loader.Loader, tramp *loader.SymbolBuilder, target loader.Sym, offset int64) {
 	tramp.SetSize(12) // 3 instructions
 	P := make([]byte, tramp.Size())
@@ -481,7 +481,7 @@ func gentramp(arch *sys.Arch, linkmode ld.LinkMode, ldr *loader.Loader, tramp *l
 	}
 }
 
-// generate a trampoline to target+offset in position independent code
+// generate a trampoline to target+offset in position independent code.
 func gentramppic(arch *sys.Arch, tramp *loader.SymbolBuilder, target loader.Sym, offset int64) {
 	tramp.SetSize(16) // 4 instructions
 	P := make([]byte, tramp.Size())
@@ -502,7 +502,7 @@ func gentramppic(arch *sys.Arch, tramp *loader.SymbolBuilder, target loader.Sym,
 	r.SetAdd(offset + 4)
 }
 
-// generate a trampoline to target+offset in dynlink mode (using GOT)
+// generate a trampoline to target+offset in dynlink mode (using GOT).
 func gentrampdyn(arch *sys.Arch, tramp *loader.SymbolBuilder, target loader.Sym, offset int64) {
 	tramp.SetSize(20)                               // 5 instructions
 	o1 := uint32(0xe5900000 | 12<<12 | 15<<16 | 8)  // MOVW 8(R15), R12 // R15 is actual pc + 8
diff --git a/src/cmd/link/internal/arm64/asm.go b/src/cmd/link/internal/arm64/asm.go
index e0fdc202f5..fc0ad3fb4e 100644
--- a/src/cmd/link/internal/arm64/asm.go
+++ b/src/cmd/link/internal/arm64/asm.go
@@ -1271,7 +1271,7 @@ func offsetLabelName(ldr *loader.Loader, s loader.Sym, off int64) string {
 	return fmt.Sprintf("%s+%d", ldr.SymExtname(s), off)
 }
 
-// Convert the direct jump relocation r to refer to a trampoline if the target is too far
+// Convert the direct jump relocation r to refer to a trampoline if the target is too far.
 func trampoline(ctxt *ld.Link, ldr *loader.Loader, ri int, rs, s loader.Sym) {
 	relocs := ldr.Relocs(s)
 	r := relocs.At(ri)
diff --git a/src/cmd/link/internal/ld/data.go b/src/cmd/link/internal/ld/data.go
index 0f2fd214a7..daf96f0c4f 100644
--- a/src/cmd/link/internal/ld/data.go
+++ b/src/cmd/link/internal/ld/data.go
@@ -51,7 +51,7 @@ import (
 	"sync/atomic"
 )
 
-// isRuntimeDepPkg reports whether pkg is the runtime package or its dependency
+// isRuntimeDepPkg reports whether pkg is the runtime package or its dependency.
 func isRuntimeDepPkg(pkg string) bool {
 	switch pkg {
 	case "runtime",
@@ -2349,7 +2349,7 @@ func (ctxt *Link) textaddress() {
 	}
 }
 
-// assigns address for a text symbol, returns (possibly new) section, its number, and the address
+// assigns address for a text symbol, returns (possibly new) section, its number, and the address.
 func assignAddress(ctxt *Link, sect *sym.Section, n int, s loader.Sym, va uint64, isTramp, big bool) (*sym.Section, int, uint64) {
 	ldr := ctxt.loader
 	if thearch.AssignAddress != nil {
diff --git a/src/cmd/link/internal/ld/elf.go b/src/cmd/link/internal/ld/elf.go
index 41fc9ab76f..082adcc3c7 100644
--- a/src/cmd/link/internal/ld/elf.go
+++ b/src/cmd/link/internal/ld/elf.go
@@ -458,7 +458,7 @@ func elfwritehdr(out *OutBuf) uint32 {
 	return elf32writehdr(out)
 }
 
-/* Taken directly from the definition document for ELF64 */
+/* Taken directly from the definition document for ELF64. */
 func elfhash(name string) uint32 {
 	var h uint32
 	for i := 0; i < len(name); i++ {
@@ -1097,7 +1097,7 @@ func elfshname(name string) *ElfShdr {
 }
 
 // Create an ElfShdr for the section with name.
-// Create a duplicate if one already exists with that name
+// Create a duplicate if one already exists with that name.
 func elfshnamedup(name string) *ElfShdr {
 	for i := 0; i < nelfstr; i++ {
 		if name == elfstr[i].s {
diff --git a/src/cmd/link/internal/ld/xcoff.go b/src/cmd/link/internal/ld/xcoff.go
index 133858c764..1265c458fe 100644
--- a/src/cmd/link/internal/ld/xcoff.go
+++ b/src/cmd/link/internal/ld/xcoff.go
@@ -539,7 +539,7 @@ func (f *xcoffFile) getXCOFFscnum(sect *sym.Section) int16 {
 }
 
 // Xcoffinit initialised some internal value and setups
-// already known header information
+// already known header information.
 func Xcoffinit(ctxt *Link) {
 	xfile.dynLibraries = make(map[string]int)
 
@@ -872,7 +872,7 @@ func (f *xcoffFile) writeSymbolFunc(ctxt *Link, x loader.Sym) []xcoffSym {
 	return syms
 }
 
-// put function used by genasmsym to write symbol table
+// put function used by genasmsym to write symbol table.
 func putaixsym(ctxt *Link, x loader.Sym, t SymbolType) {
 	// All XCOFF symbols generated by this GO symbols
 	// Can be a symbol entry or a auxiliary entry
@@ -1355,7 +1355,7 @@ func (ctxt *Link) doxcoff() {
 // Currently, this section is created from scratch when assembling the XCOFF file
 // according to information retrieved in xfile object.
 
-// Create loader section and returns its size
+// Create loader section and returns its size.
 func Loaderblk(ctxt *Link, off uint64) {
 	xfile.writeLdrScn(ctxt, off)
 }
@@ -1582,7 +1582,7 @@ func xcoffwrite(ctxt *Link) {
 	}
 }
 
-// Generate XCOFF assembly file
+// Generate XCOFF assembly file.
 func asmbXcoff(ctxt *Link) {
 	ctxt.Out.SeekSet(0)
 	fileoff := int64(Segdwarf.Fileoff + Segdwarf.Filelen)
diff --git a/src/cmd/link/internal/ppc64/asm.go b/src/cmd/link/internal/ppc64/asm.go
index 71c8ca23c4..7413599f4d 100644
--- a/src/cmd/link/internal/ppc64/asm.go
+++ b/src/cmd/link/internal/ppc64/asm.go
@@ -133,7 +133,7 @@ func genpltstub(ctxt *ld.Link, ldr *loader.Loader, r loader.Reloc, s loader.Sym)
 	return stub.Sym(), firstUse
 }
 
-// Scan relocs and generate PLT stubs and generate/fixup ABI defined functions created by the linker
+// Scan relocs and generate PLT stubs and generate/fixup ABI defined functions created by the linker.
 func genstubs(ctxt *ld.Link, ldr *loader.Loader) {
 	var stubs []loader.Sym
 	var abifuncs []loader.Sym
@@ -933,7 +933,7 @@ func archrelocaddr(ldr *loader.Loader, target *ld.Target, syms *ld.ArchSyms, r l
 	return packInstPair(target, o1, o2)
 }
 
-// Determine if the code was compiled so that the TOC register R2 is initialized and maintained
+// Determine if the code was compiled so that the TOC register R2 is initialized and maintained.
 func r2Valid(ctxt *ld.Link) bool {
 	switch ctxt.BuildMode {
 	case ld.BuildModeCArchive, ld.BuildModeCShared, ld.BuildModePIE, ld.BuildModeShared, ld.BuildModePlugin:
@@ -943,7 +943,7 @@ func r2Valid(ctxt *ld.Link) bool {
 	return ctxt.IsSharedGoLink()
 }
 
-// resolve direct jump relocation r in s, and add trampoline if necessary
+// resolve direct jump relocation r in s, and add trampoline if necessary.
 func trampoline(ctxt *ld.Link, ldr *loader.Loader, ri int, rs, s loader.Sym) {
 
 	// Trampolines are created if the branch offset is too large and the linker cannot insert a call stub to handle it.
@@ -1462,7 +1462,7 @@ func addpltsym(ctxt *ld.Link, ldr *loader.Loader, s loader.Sym) {
 	}
 }
 
-// Generate the glink resolver stub if necessary and return the .glink section
+// Generate the glink resolver stub if necessary and return the .glink section.
 func ensureglinkresolver(ctxt *ld.Link, ldr *loader.Loader) *loader.SymbolBuilder {
 	glink := ldr.CreateSymForUpdate(".glink", 0)
 	if glink.Size() != 0 {
diff --git a/src/cmd/pprof/pprof.go b/src/cmd/pprof/pprof.go
index 147b3ad418..bc1a4cf9f7 100644
--- a/src/cmd/pprof/pprof.go
+++ b/src/cmd/pprof/pprof.go
@@ -104,7 +104,7 @@ func statusCodeError(resp *http.Response) error {
 // cpuProfileHandler is the Go pprof CPU profile handler URL.
 const cpuProfileHandler = "/debug/pprof/profile"
 
-// adjustURL applies the duration/timeout values and Go specific defaults
+// adjustURL applies the duration/timeout values and Go specific defaults.
 func adjustURL(source string, duration, timeout time.Duration) (string, time.Duration) {
 	u, err := url.Parse(source)
 	if err != nil || (u.Host == "" && u.Scheme != "" && u.Scheme != "file") {
diff --git a/src/compress/flate/deflate.go b/src/compress/flate/deflate.go
index 93efd7cafb..b53764b552 100644
--- a/src/compress/flate/deflate.go
+++ b/src/compress/flate/deflate.go
@@ -297,7 +297,7 @@ func hash4(b []byte) uint32 {
 }
 
 // bulkHash4 will compute hashes using the same
-// algorithm as hash4
+// algorithm as hash4.
 func bulkHash4(b []byte, dst []uint32) {
 	if len(b) < minMatchLength {
 		return
diff --git a/src/compress/flate/huffman_code.go b/src/compress/flate/huffman_code.go
index 6b1aaea2b2..ade4c8fb28 100644
--- a/src/compress/flate/huffman_code.go
+++ b/src/compress/flate/huffman_code.go
@@ -60,7 +60,7 @@ func newHuffmanEncoder(size int) *huffmanEncoder {
 	return &huffmanEncoder{codes: make([]hcode, size)}
 }
 
-// Generates a HuffmanCode corresponding to the fixed literal table
+// Generates a HuffmanCode corresponding to the fixed literal table.
 func generateFixedLiteralEncoding() *huffmanEncoder {
 	h := newHuffmanEncoder(maxNumLit)
 	codes := h.codes
diff --git a/src/compress/flate/token.go b/src/compress/flate/token.go
index ae01391f9c..fc0e4941e7 100644
--- a/src/compress/flate/token.go
+++ b/src/compress/flate/token.go
@@ -75,17 +75,17 @@ func matchToken(xlength uint32, xoffset uint32) token {
 	return token(matchType + xlength<<lengthShift + xoffset)
 }
 
-// Returns the literal of a literal token
+// Returns the literal of a literal token.
 func (t token) literal() uint32 { return uint32(t - literalType) }
 
-// Returns the extra offset of a match token
+// Returns the extra offset of a match token.
 func (t token) offset() uint32 { return uint32(t) & offsetMask }
 
 func (t token) length() uint32 { return uint32((t - matchType) >> lengthShift) }
 
 func lengthCode(len uint32) uint32 { return lengthCodes[len] }
 
-// Returns the offset code corresponding to a specific offset
+// Returns the offset code corresponding to a specific offset.
 func offsetCode(off uint32) uint32 {
 	if off < uint32(len(offsetCodes)) {
 		return offsetCodes[off]
diff --git a/src/crypto/des/block.go b/src/crypto/des/block.go
index c649dee94f..192913094e 100644
--- a/src/crypto/des/block.go
+++ b/src/crypto/des/block.go
@@ -83,7 +83,7 @@ var feistelBox [8][64]uint32
 
 var feistelBoxOnce sync.Once
 
-// general purpose function to perform DES block permutations
+// general purpose function to perform DES block permutations.
 func permuteBlock(src uint64, permutation []uint8) (block uint64) {
 	for position, n := range permutation {
 		bit := (src >> n) & 1
@@ -209,7 +209,7 @@ func permuteFinalBlock(block uint64) uint64 {
 }
 
 // creates 16 28-bit blocks rotated according
-// to the rotation schedule
+// to the rotation schedule.
 func ksRotate(in uint32) (out []uint32) {
 	out = make([]uint32, 16)
 	last := in
@@ -223,7 +223,7 @@ func ksRotate(in uint32) (out []uint32) {
 	return
 }
 
-// creates 16 56-bit subkeys from the original key
+// creates 16 56-bit subkeys from the original key.
 func (c *desCipher) generateSubkeys(keyBytes []byte) {
 	feistelBoxOnce.Do(initFeistelBox)
 
diff --git a/src/crypto/internal/boring/boring.go b/src/crypto/internal/boring/boring.go
index 7ea438d3a7..102380a839 100644
--- a/src/crypto/internal/boring/boring.go
+++ b/src/crypto/internal/boring/boring.go
@@ -36,7 +36,7 @@ func Unreachable() {
 	panic("boringcrypto: invalid code execution")
 }
 
-// provided by runtime to avoid os import
+// provided by runtime to avoid os import.
 func runtime_arg0() string
 
 func hasSuffix(s, t string) bool {
diff --git a/src/crypto/x509/internal/macos/corefoundation.go b/src/crypto/x509/internal/macos/corefoundation.go
index 352eb8eecc..5387c5a015 100644
--- a/src/crypto/x509/internal/macos/corefoundation.go
+++ b/src/crypto/x509/internal/macos/corefoundation.go
@@ -47,7 +47,7 @@ func CFStringToString(ref CFRef) string {
 	return string(b)
 }
 
-// TimeToCFDateRef converts a time.Time into an apple CFDateRef
+// TimeToCFDateRef converts a time.Time into an apple CFDateRef.
 func TimeToCFDateRef(t time.Time) CFRef {
 	secs := t.Sub(time.Date(2001, 1, 1, 0, 0, 0, 0, time.UTC)).Seconds()
 	ref := CFDateCreate(secs)
diff --git a/src/encoding/json/scanner.go b/src/encoding/json/scanner.go
index 22fc6922da..4c43f5f98c 100644
--- a/src/encoding/json/scanner.go
+++ b/src/encoding/json/scanner.go
@@ -594,7 +594,7 @@ func (s *scanner) error(c byte, context string) int {
 	return scanError
 }
 
-// quoteChar formats c as a quoted character literal
+// quoteChar formats c as a quoted character literal.
 func quoteChar(c byte) string {
 	// special cases - different from quoted strings
 	if c == '\'' {
diff --git a/src/go/doc/example.go b/src/go/doc/example.go
index 6d0459ec5b..65ca88540f 100644
--- a/src/go/doc/example.go
+++ b/src/go/doc/example.go
@@ -112,7 +112,7 @@ func Examples(testFiles ...*ast.File) []*Example {
 
 var outputPrefix = lazyregexp.New(`(?i)^[[:space:]]*(unordered )?output:`)
 
-// Extracts the expected output and whether there was a valid output comment
+// Extracts the expected output and whether there was a valid output comment.
 func exampleOutput(b *ast.BlockStmt, comments []*ast.CommentGroup) (output string, unordered, ok bool) {
 	if _, last := lastComment(b, comments); last != nil {
 		// test that it begins with the correct prefix
diff --git a/src/go/doc/reader.go b/src/go/doc/reader.go
index 492e039703..8f9fda41ff 100644
--- a/src/go/doc/reader.go
+++ b/src/go/doc/reader.go
@@ -826,7 +826,7 @@ func (d *data) Len() int           { return d.n }
 func (d *data) Swap(i, j int)      { d.swap(i, j) }
 func (d *data) Less(i, j int) bool { return d.less(i, j) }
 
-// sortBy is a helper function for sorting
+// sortBy is a helper function for sorting.
 func sortBy(less func(i, j int) bool, swap func(i, j int), n int) {
 	sort.Sort(&data{n, swap, less})
 }
diff --git a/src/go/types/gotype.go b/src/go/types/gotype.go
index e8ff9658da..ee9c12c447 100644
--- a/src/go/types/gotype.go
+++ b/src/go/types/gotype.go
@@ -180,7 +180,7 @@ func report(err error) {
 	errorCount++
 }
 
-// parse may be called concurrently
+// parse may be called concurrently.
 func parse(filename string, src any) (*ast.File, error) {
 	if *verbose {
 		fmt.Println(filename)
diff --git a/src/hash/crc32/crc32_ppc64le.go b/src/hash/crc32/crc32_ppc64le.go
index dcd32351a5..c22e38e009 100644
--- a/src/hash/crc32/crc32_ppc64le.go
+++ b/src/hash/crc32/crc32_ppc64le.go
@@ -18,7 +18,7 @@ const (
 //go:noescape
 func ppc64SlicingUpdateBy8(crc uint32, table8 *slicing8Table, p []byte) uint32
 
-// this function requires the buffer to be 16 byte aligned and > 16 bytes long
+// this function requires the buffer to be 16 byte aligned and > 16 bytes long.
 //
 //go:noescape
 func vectorCrc32(crc uint32, poly uint32, p []byte) uint32
diff --git a/src/html/template/content.go b/src/html/template/content.go
index b104267177..49d2f261af 100644
--- a/src/html/template/content.go
+++ b/src/html/template/content.go
@@ -134,7 +134,7 @@ var (
 
 // indirectToStringerOrError returns the value, after dereferencing as many times
 // as necessary to reach the base type (or nil) or an implementation of fmt.Stringer
-// or error,
+// or error.
 func indirectToStringerOrError(a any) any {
 	if a == nil {
 		return nil
diff --git a/src/internal/fuzz/coverage.go b/src/internal/fuzz/coverage.go
index 0d96be2f7a..0c5e17e3bb 100644
--- a/src/internal/fuzz/coverage.go
+++ b/src/internal/fuzz/coverage.go
@@ -67,7 +67,7 @@ func countNewCoverageBits(base, snapshot []byte) int {
 }
 
 // isCoverageSubset returns true if all the base coverage bits are set in
-// snapshot
+// snapshot.
 func isCoverageSubset(base, snapshot []byte) bool {
 	for i, v := range base {
 		if v&snapshot[i] != v {
diff --git a/src/internal/profile/filter.go b/src/internal/profile/filter.go
index 65e50db99d..141dd1f405 100644
--- a/src/internal/profile/filter.go
+++ b/src/internal/profile/filter.go
@@ -131,7 +131,7 @@ func (p *Profile) FilterSamplesByTag(focus, ignore TagMatch) (fm, im bool) {
 }
 
 // focusedSample checks a sample against focus and ignore regexps.
-// Returns whether the focus/ignore regexps match any tags
+// Returns whether the focus/ignore regexps match any tags.
 func focusedSample(s *Sample, focus, ignore TagMatch) (fm, im bool) {
 	fm = focus == nil
 	for key, vals := range s.Label {
diff --git a/src/math/big/int.go b/src/math/big/int.go
index 29b5ddf3a5..d747078e23 100644
--- a/src/math/big/int.go
+++ b/src/math/big/int.go
@@ -671,7 +671,7 @@ func lehmerSimulate(A, B *Int) (u0, u1, v0, v1 Word, even bool) {
 // where the signs of u0, u1, v0, v1 are given by even
 // For even == true: u0, v1 >= 0 && u1, v0 <= 0
 // For even == false: u0, v1 <= 0 && u1, v0 >= 0
-// q, r, s, t are temporary variables to avoid allocations in the multiplication
+// q, r, s, t are temporary variables to avoid allocations in the multiplication.
 func lehmerUpdate(A, B, q, r, s, t *Int, u0, u1, v0, v1 Word, even bool) {
 
 	t.abs = t.abs.setWord(u0)
@@ -695,7 +695,7 @@ func lehmerUpdate(A, B, q, r, s, t *Int, u0, u1, v0, v1 Word, even bool) {
 }
 
 // euclidUpdate performs a single step of the Euclidean GCD algorithm
-// if extended is true, it also updates the cosequence Ua, Ub
+// if extended is true, it also updates the cosequence Ua, Ub.
 func euclidUpdate(A, B, Ua, Ub, q, r, s, t *Int, extended bool) {
 	q, r = q.QuoRem(A, B, r)
 
diff --git a/src/math/big/intconv.go b/src/math/big/intconv.go
index a3a4023caa..04e8c24ed5 100644
--- a/src/math/big/intconv.go
+++ b/src/math/big/intconv.go
@@ -40,7 +40,7 @@ func (x *Int) String() string {
 	return x.Text(10)
 }
 
-// write count copies of text to s
+// write count copies of text to s.
 func writeMultiple(s fmt.State, text string, count int) {
 	if len(text) > 0 {
 		b := []byte(text)
diff --git a/src/math/big/natconv.go b/src/math/big/natconv.go
index da59bd6e4c..ce94f2cf72 100644
--- a/src/math/big/natconv.go
+++ b/src/math/big/natconv.go
@@ -455,7 +455,7 @@ func (z nat) expWW(x, y Word) nat {
 	return z.expNN(nat(nil).setWord(x), nat(nil).setWord(y), nil, false)
 }
 
-// construct table of powers of bb*leafSize to use in subdivisions
+// construct table of powers of bb*leafSize to use in subdivisions.
 func divisors(m int, b Word, ndigits int, bb Word) []divisor {
 	// only compute table when recursive conversion is enabled and x is large
 	if leafSize == 0 || m <= leafSize {
diff --git a/src/math/cmplx/sin.go b/src/math/cmplx/sin.go
index febac0e0bb..51cf40566d 100644
--- a/src/math/cmplx/sin.go
+++ b/src/math/cmplx/sin.go
@@ -172,7 +172,7 @@ func Cosh(x complex128) complex128 {
 	return complex(c*ch, s*sh)
 }
 
-// calculate sinh and cosh
+// calculate sinh and cosh.
 func sinhcosh(x float64) (sh, ch float64) {
 	if math.Abs(x) <= 0.5 {
 		return math.Sinh(x), math.Cosh(x)
diff --git a/src/net/http/client.go b/src/net/http/client.go
index 617446b030..122e8d030d 100644
--- a/src/net/http/client.go
+++ b/src/net/http/client.go
@@ -499,7 +499,7 @@ func (c *Client) checkRedirect(req *Request, via []*Request) error {
 }
 
 // redirectBehavior describes what should happen when the
-// client encounters a 3xx status code from the server
+// client encounters a 3xx status code from the server.
 func redirectBehavior(reqMethod string, resp *Response, ireq *Request) (redirectMethod string, shouldRedirect, includeBody bool) {
 	switch resp.StatusCode {
 	case 301, 302, 303:
diff --git a/src/net/http/cookie.go b/src/net/http/cookie.go
index b7b0455ee1..912fde6b95 100644
--- a/src/net/http/cookie.go
+++ b/src/net/http/cookie.go
@@ -273,7 +273,7 @@ func (c *Cookie) Valid() error {
 // readCookies parses all "Cookie" values from the header h and
 // returns the successfully parsed Cookies.
 //
-// if filter isn't empty, only cookies of that name are returned
+// if filter isn't empty, only cookies of that name are returned.
 func readCookies(h Header, filter string) []*Cookie {
 	lines := h["Cookie"]
 	if len(lines) == 0 {
diff --git a/src/net/http/transfer.go b/src/net/http/transfer.go
index 09b42c188a..7c7afd7de4 100644
--- a/src/net/http/transfer.go
+++ b/src/net/http/transfer.go
@@ -600,7 +600,7 @@ func readTransfer(msg any, r *bufio.Reader) (err error) {
 	return nil
 }
 
-// Checks whether chunked is part of the encodings stack
+// Checks whether chunked is part of the encodings stack.
 func chunked(te []string) bool { return len(te) > 0 && te[0] == "chunked" }
 
 // Checks whether the encoding is explicitly "identity".
@@ -738,7 +738,7 @@ func fixLength(isResponse bool, status int, requestMethod string, header Header,
 
 // Determine whether to hang up after sending a request and body, or
 // receiving a response and body
-// 'header' is the request headers
+// 'header' is the request headers.
 func shouldClose(major, minor int, header Header, removeCloseHeader bool) bool {
 	if major < 1 {
 		return true
@@ -757,7 +757,7 @@ func shouldClose(major, minor int, header Header, removeCloseHeader bool) bool {
 	return hasClose
 }
 
-// Parse the trailer header
+// Parse the trailer header.
 func fixTrailer(header Header, chunked bool) (Header, error) {
 	vv, ok := header["Trailer"]
 	if !ok {
@@ -1081,7 +1081,7 @@ var nopCloserWriterToType = reflect.TypeOf(io.NopCloser(struct {
 }{}))
 
 // unwrapNopCloser return the underlying reader and true if r is a NopCloser
-// else it return false
+// else it return false.
 func unwrapNopCloser(r io.Reader) (underlyingReader io.Reader, isNopCloser bool) {
 	switch reflect.TypeOf(r) {
 	case nopCloserType, nopCloserWriterToType:
diff --git a/src/net/http/transport.go b/src/net/http/transport.go
index e4434e8076..ddcb64815c 100644
--- a/src/net/http/transport.go
+++ b/src/net/http/transport.go
@@ -2743,7 +2743,7 @@ var portMap = map[string]string{
 	"socks5": "1080",
 }
 
-// canonicalAddr returns url.Host but always with a ":port" suffix
+// canonicalAddr returns url.Host but always with a ":port" suffix.
 func canonicalAddr(url *url.URL) string {
 	addr := url.Hostname()
 	if v, err := idnaASCII(addr); err == nil {
diff --git a/src/net/http/triv.go b/src/net/http/triv.go
index 1e2eea22b7..32edbbb344 100644
--- a/src/net/http/triv.go
+++ b/src/net/http/triv.go
@@ -101,7 +101,7 @@ func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	io.WriteString(w, fmt.Sprintf("channel send #%d\n", <-ch))
 }
 
-// exec a program, redirecting output
+// exec a program, redirecting output.
 func DateServer(rw http.ResponseWriter, req *http.Request) {
 	rw.Header().Set("Content-Type", "text/plain; charset=utf-8")
 
diff --git a/src/net/lookup_windows.go b/src/net/lookup_windows.go
index 218523f28d..4ee728196b 100644
--- a/src/net/lookup_windows.go
+++ b/src/net/lookup_windows.go
@@ -383,7 +383,7 @@ func (r *Resolver) lookupAddr(ctx context.Context, addr string) ([]string, error
 
 const dnsSectionMask = 0x0003
 
-// returns only results applicable to name and resolves CNAME entries
+// returns only results applicable to name and resolves CNAME entries.
 func validRecs(r *syscall.DNSRecord, dnstype uint16, name string) []*syscall.DNSRecord {
 	cname := syscall.StringToUTF16Ptr(name)
 	if dnstype != syscall.DNS_TYPE_CNAME {
@@ -406,7 +406,7 @@ func validRecs(r *syscall.DNSRecord, dnstype uint16, name string) []*syscall.DNS
 	return rec
 }
 
-// returns the last CNAME in chain
+// returns the last CNAME in chain.
 func resolveCNAME(name *uint16, r *syscall.DNSRecord) *uint16 {
 	// limit cname resolving to 10 in case of an infinite CNAME loop
 Cname:
diff --git a/src/net/mail/message.go b/src/net/mail/message.go
index 5de47eb45b..6268c08f47 100644
--- a/src/net/mail/message.go
+++ b/src/net/mail/message.go
@@ -850,7 +850,7 @@ func isVchar(r rune) bool {
 }
 
 // isMultibyte reports whether r is a multi-byte UTF-8 character
-// as supported by RFC 6532
+// as supported by RFC 6532.
 func isMultibyte(r rune) bool {
 	return r >= utf8.RuneSelf
 }
diff --git a/src/net/smtp/smtp.go b/src/net/smtp/smtp.go
index 3bd2061b0c..b5a025ef2a 100644
--- a/src/net/smtp/smtp.go
+++ b/src/net/smtp/smtp.go
@@ -423,7 +423,7 @@ func (c *Client) Quit() error {
 	return c.Text.Close()
 }
 
-// validateLine checks to see if a line has CR or LF as per RFC 5321
+// validateLine checks to see if a line has CR or LF as per RFC 5321.
 func validateLine(line string) error {
 	if strings.ContainsAny(line, "\n\r") {
 		return errors.New("smtp: A line must not contain CR or LF")
diff --git a/src/os/env.go b/src/os/env.go
index 330297b36a..63ad5ab4bd 100644
--- a/src/os/env.go
+++ b/src/os/env.go
@@ -61,7 +61,7 @@ func isShellSpecialVar(c uint8) bool {
 	return false
 }
 
-// isAlphaNum reports whether the byte is an ASCII letter, number, or underscore
+// isAlphaNum reports whether the byte is an ASCII letter, number, or underscore.
 func isAlphaNum(c uint8) bool {
 	return c == '_' || '0' <= c && c <= '9' || 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z'
 }
diff --git a/src/plugin/plugin_dlopen.go b/src/plugin/plugin_dlopen.go
index 6ba0f78065..b4c4e4061c 100644
--- a/src/plugin/plugin_dlopen.go
+++ b/src/plugin/plugin_dlopen.go
@@ -146,10 +146,10 @@ var (
 	plugins   map[string]*Plugin
 )
 
-// lastmoduleinit is defined in package runtime
+// lastmoduleinit is defined in package runtime.
 func lastmoduleinit() (pluginpath string, syms map[string]any, errstr string)
 
-// doInit is defined in package runtime
+// doInit is defined in package runtime.
 //
 //go:linkname doInit runtime.doInit
 func doInit(t unsafe.Pointer) // t should be a *runtime.initTask
diff --git a/src/regexp/onepass.go b/src/regexp/onepass.go
index 89040d7b0e..b3066e88ee 100644
--- a/src/regexp/onepass.go
+++ b/src/regexp/onepass.go
@@ -37,7 +37,7 @@ type onePassInst struct {
 // regexp must start with. Complete is true if the prefix
 // is the entire match. Pc is the index of the last rune instruction
 // in the string. The onePassPrefix skips over the mandatory
-// EmptyBeginText
+// EmptyBeginText.
 func onePassPrefix(p *syntax.Prog) (prefix string, complete bool, pc uint32) {
 	i := &p.Inst[p.Start]
 	if i.Op != syntax.InstEmptyWidth || (syntax.EmptyOp(i.Arg))&syntax.EmptyBeginText == 0 {
@@ -218,7 +218,7 @@ func cleanupOnePass(prog *onePassProg, original *syntax.Prog) {
 	}
 }
 
-// onePassCopy creates a copy of the original Prog, as we'll be modifying it
+// onePassCopy creates a copy of the original Prog, as we'll be modifying it.
 func onePassCopy(prog *syntax.Prog) *onePassProg {
 	p := &onePassProg{
 		Start:  prog.Start,
diff --git a/src/regexp/regexp.go b/src/regexp/regexp.go
index 7958a39728..990c06e891 100644
--- a/src/regexp/regexp.go
+++ b/src/regexp/regexp.go
@@ -270,7 +270,7 @@ func (re *Regexp) put(m *machine) {
 	matchPool[re.mpool].Put(m)
 }
 
-// minInputLen walks the regexp to find the minimum length of any matchable input
+// minInputLen walks the regexp to find the minimum length of any matchable input.
 func minInputLen(re *syntax.Regexp) int {
 	switch re.Op {
 	default:
diff --git a/src/runtime/cgocall.go b/src/runtime/cgocall.go
index 0a25cb6562..9c75280d62 100644
--- a/src/runtime/cgocall.go
+++ b/src/runtime/cgocall.go
@@ -346,12 +346,12 @@ func unwindm(restore *bool) {
 	}
 }
 
-// called from assembly
+// called from assembly.
 func badcgocallback() {
 	throw("misaligned stack in cgocallback")
 }
 
-// called from (incomplete) assembly
+// called from (incomplete) assembly.
 func cgounimpl() {
 	throw("cgo not implemented")
 }
diff --git a/src/runtime/chan.go b/src/runtime/chan.go
index a9ef0781ce..6a0ad35b86 100644
--- a/src/runtime/chan.go
+++ b/src/runtime/chan.go
@@ -138,7 +138,7 @@ func full(c *hchan) bool {
 	return c.qcount == c.dataqsiz
 }
 
-// entry point for c <- x from compiled code
+// entry point for c <- x from compiled code.
 //
 //go:nosplit
 func chansend1(c *hchan, elem unsafe.Pointer) {
@@ -435,7 +435,7 @@ func empty(c *hchan) bool {
 	return atomic.Loaduint(&c.qcount) == 0
 }
 
-// entry points for <- c from compiled code
+// entry points for <- c from compiled code.
 //
 //go:nosplit
 func chanrecv1(c *hchan, elem unsafe.Pointer) {
diff --git a/src/runtime/debug/mod.go b/src/runtime/debug/mod.go
index 688e2581ed..3ef8cfb5de 100644
--- a/src/runtime/debug/mod.go
+++ b/src/runtime/debug/mod.go
@@ -11,7 +11,7 @@ import (
 	"strings"
 )
 
-// exported from runtime
+// exported from runtime.
 func modinfo() string
 
 // ReadBuildInfo returns the build information embedded
diff --git a/src/runtime/heapdump.go b/src/runtime/heapdump.go
index 6fcc232313..f57a1a1e17 100644
--- a/src/runtime/heapdump.go
+++ b/src/runtime/heapdump.go
@@ -120,7 +120,7 @@ type typeCacheBucket struct {
 
 var typecache [typeCacheBuckets]typeCacheBucket
 
-// dump a uint64 in a varint format parseable by encoding/binary
+// dump a uint64 in a varint format parseable by encoding/binary.
 func dumpint(v uint64) {
 	var buf [10]byte
 	var n int
@@ -142,7 +142,7 @@ func dumpbool(b bool) {
 	}
 }
 
-// dump varint uint64 length followed by memory contents
+// dump varint uint64 length followed by memory contents.
 func dumpmemrange(data unsafe.Pointer, len uintptr) {
 	dumpint(uint64(len))
 	dwrite(data, len)
@@ -159,7 +159,7 @@ func dumpstr(s string) {
 	dumpmemrange(unsafe.Pointer(unsafe.StringData(s)), uintptr(len(s)))
 }
 
-// dump information for a type
+// dump information for a type.
 func dumptype(t *_type) {
 	if t == nil {
 		return
@@ -206,7 +206,7 @@ func dumptype(t *_type) {
 	dumpbool(t.kind&kindDirectIface == 0 || t.ptrdata != 0)
 }
 
-// dump an object
+// dump an object.
 func dumpobj(obj unsafe.Pointer, size uintptr, bv bitvector) {
 	dumpint(tagObject)
 	dumpint(uint64(uintptr(obj)))
@@ -239,7 +239,7 @@ type childInfo struct {
 	depth  uintptr   // depth in call stack (0 == most recent)
 }
 
-// dump kinds & offsets of interesting fields in bv
+// dump kinds & offsets of interesting fields in bv.
 func dumpbv(cbv *bitvector, offset uintptr) {
 	for i := uintptr(0); i < uintptr(cbv.n); i++ {
 		if cbv.ptrbit(i) == 1 {
diff --git a/src/runtime/lock_futex.go b/src/runtime/lock_futex.go
index 1578984ce2..cc7d465ef1 100644
--- a/src/runtime/lock_futex.go
+++ b/src/runtime/lock_futex.go
@@ -226,7 +226,7 @@ func notetsleep(n *note, ns int64) bool {
 }
 
 // same as runtime·notetsleep, but called on user g (not g0)
-// calls only nosplit functions between entersyscallblock/exitsyscall
+// calls only nosplit functions between entersyscallblock/exitsyscall.
 func notetsleepg(n *note, ns int64) bool {
 	gp := getg()
 	if gp == gp.m.g0 {
diff --git a/src/runtime/lock_sema.go b/src/runtime/lock_sema.go
index c5e8cfe24a..e15bbf79ae 100644
--- a/src/runtime/lock_sema.go
+++ b/src/runtime/lock_sema.go
@@ -284,7 +284,7 @@ func notetsleep(n *note, ns int64) bool {
 }
 
 // same as runtime·notetsleep, but called on user g (not g0)
-// calls only nosplit functions between entersyscallblock/exitsyscall
+// calls only nosplit functions between entersyscallblock/exitsyscall.
 func notetsleepg(n *note, ns int64) bool {
 	gp := getg()
 	if gp == gp.m.g0 {
diff --git a/src/runtime/malloc.go b/src/runtime/malloc.go
index 3b9828fe54..7ff2190876 100644
--- a/src/runtime/malloc.go
+++ b/src/runtime/malloc.go
@@ -1249,7 +1249,7 @@ func memclrNoHeapPointersChunked(size uintptr, x unsafe.Pointer) {
 
 // implementation of new builtin
 // compiler (both frontend and SSA backend) knows the signature
-// of this function
+// of this function.
 func newobject(typ *_type) unsafe.Pointer {
 	return mallocgc(typ.size, typ, true)
 }
diff --git a/src/runtime/map.go b/src/runtime/map.go
index 65be4727fd..f546ce8609 100644
--- a/src/runtime/map.go
+++ b/src/runtime/map.go
@@ -514,7 +514,7 @@ bucketloop:
 	return unsafe.Pointer(&zeroVal[0]), false
 }
 
-// returns both key and elem. Used by map iterator
+// returns both key and elem. Used by map iterator.
 func mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer) {
 	if h == nil || h.count == 0 {
 		return nil, nil
diff --git a/src/runtime/mfinal.go b/src/runtime/mfinal.go
index 257e9d1560..d4d4f1f302 100644
--- a/src/runtime/mfinal.go
+++ b/src/runtime/mfinal.go
@@ -172,7 +172,7 @@ func finalizercommit(gp *g, lock unsafe.Pointer) bool {
 	return true
 }
 
-// This is the goroutine that runs all of the finalizers
+// This is the goroutine that runs all of the finalizers.
 func runfinq() {
 	var (
 		frame    unsafe.Pointer
diff --git a/src/runtime/mgcwork.go b/src/runtime/mgcwork.go
index 65ac0a6fc7..7ab89754d4 100644
--- a/src/runtime/mgcwork.go
+++ b/src/runtime/mgcwork.go
@@ -421,7 +421,7 @@ func putfull(b *workbuf) {
 }
 
 // trygetfull tries to get a full or partially empty workbuffer.
-// If one is not immediately available return nil
+// If one is not immediately available return nil.
 //
 //go:nowritebarrier
 func trygetfull() *workbuf {
diff --git a/src/runtime/os_aix.go b/src/runtime/os_aix.go
index 7c5947d06f..e07c7f1da6 100644
--- a/src/runtime/os_aix.go
+++ b/src/runtime/os_aix.go
@@ -163,7 +163,7 @@ func mpreinit(mp *m) {
 }
 
 // errno address must be retrieved by calling _Errno libc function.
-// This will return a pointer to errno
+// This will return a pointer to errno.
 func miniterrno() {
 	mp := getg().m
 	r, _ := syscall0(&libc__Errno)
diff --git a/src/runtime/os_openbsd_syscall2.go b/src/runtime/os_openbsd_syscall2.go
index 2fed794d7a..ebf478badf 100644
--- a/src/runtime/os_openbsd_syscall2.go
+++ b/src/runtime/os_openbsd_syscall2.go
@@ -47,7 +47,7 @@ func write1(fd uintptr, p unsafe.Pointer, n int32) int32
 //go:noescape
 func open(name *byte, mode, perm int32) int32
 
-// return value is only set on linux to be used in osinit()
+// return value is only set on linux to be used in osinit().
 func madvise(addr unsafe.Pointer, n uintptr, flags int32) int32
 
 // exitThread terminates the current thread, writing *wait = freeMStack when
diff --git a/src/runtime/pprof/pprof.go b/src/runtime/pprof/pprof.go
index 725fd26c13..17a490efed 100644
--- a/src/runtime/pprof/pprof.go
+++ b/src/runtime/pprof/pprof.go
@@ -861,7 +861,7 @@ func writeMutex(w io.Writer, debug int) error {
 	return writeProfileInternal(w, debug, "mutex", runtime.MutexProfile)
 }
 
-// writeProfileInternal writes the current blocking or mutex profile depending on the passed parameters
+// writeProfileInternal writes the current blocking or mutex profile depending on the passed parameters.
 func writeProfileInternal(w io.Writer, debug int, name string, runtimeProfile func([]runtime.BlockProfileRecord) (int, bool)) error {
 	var p []runtime.BlockProfileRecord
 	n, ok := runtimeProfile(nil)
diff --git a/src/runtime/proc.go b/src/runtime/proc.go
index 176399c7eb..56565479e0 100644
--- a/src/runtime/proc.go
+++ b/src/runtime/proc.go
@@ -481,7 +481,7 @@ func releaseSudog(s *sudog) {
 	releasem(mp)
 }
 
-// called from assembly
+// called from assembly.
 func badmcall(fn func(*g)) {
 	throw("runtime: mcall called on m->g0 stack")
 }
@@ -3534,7 +3534,7 @@ func gosched_m(gp *g) {
 	goschedImpl(gp)
 }
 
-// goschedguarded is a forbidden-states-avoided version of gosched_m
+// goschedguarded is a forbidden-states-avoided version of gosched_m.
 func goschedguarded_m(gp *g) {
 
 	if !canPreemptM(gp.m) {
diff --git a/src/runtime/race.go b/src/runtime/race.go
index 40b6e00398..f83a04db4a 100644
--- a/src/runtime/race.go
+++ b/src/runtime/race.go
@@ -350,7 +350,7 @@ func racecallbackthunk(uintptr)
 // with up to 4 uintptr arguments.
 func racecall(fn *byte, arg0, arg1, arg2, arg3 uintptr)
 
-// checks if the address has shadow (i.e. heap or data/bss)
+// checks if the address has shadow (i.e. heap or data/bss).
 //
 //go:nosplit
 func isvalidaddr(addr unsafe.Pointer) bool {
diff --git a/src/runtime/runtime1.go b/src/runtime/runtime1.go
index 76dca9ca77..277f18a5a6 100644
--- a/src/runtime/runtime1.go
+++ b/src/runtime/runtime1.go
@@ -56,7 +56,7 @@ var (
 	argv **byte
 )
 
-// nosplit for use in linux startup sysargs
+// nosplit for use in linux startup sysargs.
 //
 //go:nosplit
 func argv_index(argv **byte, i int32) *byte {
diff --git a/src/runtime/stubs2.go b/src/runtime/stubs2.go
index c245c9c1a1..0d83deb2af 100644
--- a/src/runtime/stubs2.go
+++ b/src/runtime/stubs2.go
@@ -34,7 +34,7 @@ func write1(fd uintptr, p unsafe.Pointer, n int32) int32
 //go:noescape
 func open(name *byte, mode, perm int32) int32
 
-// return value is only set on linux to be used in osinit()
+// return value is only set on linux to be used in osinit().
 func madvise(addr unsafe.Pointer, n uintptr, flags int32) int32
 
 // exitThread terminates the current thread, writing *wait = freeMStack when
diff --git a/src/runtime/stubs_ppc64.go b/src/runtime/stubs_ppc64.go
index 6919b748f0..e23e33871b 100644
--- a/src/runtime/stubs_ppc64.go
+++ b/src/runtime/stubs_ppc64.go
@@ -6,7 +6,7 @@
 
 package runtime
 
-// This is needed for vet
+// This is needed for vet.
 //
 //go:noescape
 func callCgoSigaction(sig uintptr, new, old *sigactiont) int32
diff --git a/src/syscall/fs_js.go b/src/syscall/fs_js.go
index 3541446b0b..ce0aa88828 100644
--- a/src/syscall/fs_js.go
+++ b/src/syscall/fs_js.go
@@ -544,7 +544,7 @@ func recoverErr(errPtr *error) {
 	}
 }
 
-// mapJSError maps an error given by Node.js to the appropriate Go error
+// mapJSError maps an error given by Node.js to the appropriate Go error.
 func mapJSError(jsErr js.Value) error {
 	errno, ok := errnoByCode[jsErr.Get("code").String()]
 	if !ok {
diff --git a/src/time/format.go b/src/time/format.go
index e4f5750b0c..f94d68ee02 100644
--- a/src/time/format.go
+++ b/src/time/format.go
@@ -1469,7 +1469,7 @@ func parseGMT(value string) int {
 
 // parseSignedOffset parses a signed timezone offset (e.g. "+03" or "-04").
 // The function checks for a signed number in the range -23 through +23 excluding zero.
-// Returns length of the found offset string or 0 otherwise
+// Returns length of the found offset string or 0 otherwise.
 func parseSignedOffset(value string) int {
 	sign := value[0]
 	if sign != '-' && sign != '+' {
